Title: OpenVDB: News Features and Open Discussions
Publication date: 2020-08-24
Playlist: Open Source Days 2020
Description: 
	OpenVDB: News Features and Open Discussions
Speakers: Ken Museth, Nick Avramoussis

For more information about the Academy Software Foundation go to: https://www.aswf.io/

The purpose of this meeting is twofold; to summarize the state of the OpenVDB project and invite attendees to openly discuss issues and possible future directions. To this end we will first give a brief introduction to OpenVDB and it's governance, followed by an overview of new and upcoming features - including an exciting new announcement! For the second half we invite attendees to participate in an open discussion about anything related to our project, including suggestions for new features,  bugs and issues, and questions on how to get involved etc.
Captions: 
	                              hi everyone and welcome to this session                               on                               the openvdb project                               we've decided to split the session in                               two parts so nick and myself                               will give a brief introduction to the                               projects some of the latest activities                               uh we'll make an announcement and then                               the second half of this session will be                                sort of a live                                live session where we try to um to                                answer questions so                                you're really encouraged to to use the q                                a uh chat                                window and and uh give us as many                                questions as you can come up with                                um but we will we will talk about uh we                                would give two presentations first so we                                we ask you to please have patience uh                                in the second half we'll start answering                                those questions so                                um let me first introduce you to uh the                                steering committee for                                openvdb so as you probably know openvdb                                transitioned as one of the first                                projects to the aswf                                uh a little over a year ago uh at this                                point we have four members                                uh there is nick from double negative                                who's actually                                part of this presentation there is dan                                bailey from                                ilm there is peter cooker who is                                officially still a member but he's                                currently on leave                                jeff laid um who's at side effects and                                then there's myself                                who's at nvidia um in case you want to                                join our weekly meetings it's every                                tuesday                                at                                                                    and we also actually post sometimes we                                we update the time so you can                                you can follow the second url on this                                slide                                to see as we you know might change or                                cancel a meeting                                um and finally the the the minutes of                                the meetings                                are uh posted in the um repository the                                github repository so you can also go and                                sort of look back and see what what we                                talked about decided on                                all right so now i i wanted to give you                                sort of a very quick                                uh introduction and actually a                                motivation for for                                openvdb and sparse volumes in particular                                um so                                bear with me if you if this is uh too                                simple but                                i think it does actually serve a good                                purpose um                                so as you probably know it's relatively                                easy to design a data structure                                uh that's fast i spot data structure                                that's fast                                right um we typically just need a very                                shallow tree                                like a tile grid that actually offers                                a guaranteed constant time access which                                is sort of ideal                                the problem with this approach is that                                the memory overhead of storing the                                list of blocks the table itself                                um can get prohibitedly large and it                                actually doesn't scale this approach                                um so on the other sort of end of the                                spectrum                                we have very compact data structures                                and sort of the prototypical example of                                that is of course an octree                                that has ideal additivity it's two in                                its coordinate direction                                so it often produces fairly tall trees                                when you have a lot of resolution and                                the problem with that approach is that                                navigating tall trees can be                                computationally expensive                                so really the motivation behind the core                                data structure                                in openvdb is to try and strike a                                balance between these two extremes                                um and that leads to this this                                data structure called a vdb structure                                and it's sort of a it's a                                it's a hybrid um and this is a                                                                                            um vdb data structure and it's as you                                 can see it's it's a                                 it's a four level tree so it's very                                 shallow um                                 and the root note is the only node                                 that's actually dynamic the rest are                                 depths                                 with progressively smaller leaf nodes if                                 you want more details you can                                 look at the paper listed below so                                 the way that you typically extract                                 values from a data structure three data                                 structure in fact any tree data                                 structure                                 is through a top-down traversal right so                                 let's say we want to look up the value                                 at xyz                                 you typically navigate the tree starting                                 at the very top                                 the root node and you navigate through                                 the branch until you have a hit                                 and you return the value the good news                                 is                                 it's a shallow tree so it should be                                 fairly fairly fast                                 compared to let's say an octre the bad                                 news is                                 the first node is a dynamic node it's a                                 root node                                 so that actually has a computational                                 cost associated with it so vdb                                 actually makes use of a technique that i                                 believe is pretty unique to                                 this data structure it allows you to do                                 not top-down but bottom-up traversal                                 and the idea is very simple suppose                                 you've done one access already                                 what you do is you cache the pointer                                 structures                                 of that of that traversal and                                 for subsequent access you do a few bit                                 operations                                 to um to check and see if the subsequent                                 access falls in the same leaf node and                                 if it does                                 well then there's no traversal involved                                 you immediately um                                 return the value if there's a miss you                                 move                                 up to the second entry in this small                                 hash table                                 so it's a common ancestor of the leave                                 node and you perform another check                                 and if there's a match you go down and                                 then you return the value                                 so the idea is that you on average                                 completely avoid the                                 overhead of the road node and it                                 actually on average produces a constant                                 time access which is                                 which is great so it's fast um                                 so these are some of the highlights uh                                 so the vdb data structure is unbounded                                 to within the bid procession of the quad                                 nuts which is typically                                        science integers it's compact both the                                 memory and                                 disk it offers fast random access and                                 sequential access                                 we also have our own file formats and we                                 have our own                                 codecs to make sure that the footprint                                 is very small on disk                                 and the fact that it's a native sorry                                 that it's a tree data structure actually                                 means that                                 it also has a native acceleration                                 structure which can accelerate                                 many different applications like ray                                 tracing or even things like                                 boolean operations um                                 it does have quite a lot of external                                 dependencies                                 and uh that among other things means                                 that it's actually limited to                                 to the cpu um so openvdb has                                 enjoyed over a decade of adoption in the                                 vfx industry and these are                                 some of the third-party software                                 that have adopted most of them are                                 actually                                 renders um so                                 most people are probably more excited                                 about uh                                 the tools that come with open b and not                                 so much about the data structure                                 and uh there are a lot far far                                 more than we can cover in this brief                                 presentation                                 but at this point we're actually over a                                 hundred different                                 tools that have been developed over the                                 past                                          there is there's there's one tool i just                                 want to call out because we actually                                 released it last week so we just                                 released version seven one                                 seven one is is a big release it has far                                 more than what i'm going to tell you now                                 um but this is one of the new sort of                                 tools that we added in this release                                 and it's a new way of computing assigned                                 distances                                 and also computing or extending                                 attributes off surfaces um so it comes                                 in                                 in many different flavors um there are                                 these two tools that                                 allow you to go from an arbitrary scalar                                 field it could be a fog volume it could                                 be                                 an existing sign distance field and then                                 it produces                                 a narrow band sign distance field very                                 very efficiently there are two other                                 flavors                                 um that actually allow you to take                                 attributes that are defined                                 on an isosurface and sort of extend them                                 into the embedding of the surface itself                                 which can be very useful so for instance                                 it could be you have velocities on the                                 surface but you actually need                                 to have velocities associated with                                 values that are outside of the surface                                 these two methods will do that and there                                 are combinations                                 of these four methods that actually                                 perform both tasks at the same time so                                 it both extends velocities and                                 and also attributes from the surface and                                 finally there are two                                 methods that actually sort of                                 complements                                 methods that we already have but but it                                 turns out these are                                 significantly faster so we can take an                                 existing                                 sign distance field narrowband and we                                 can dilate it sort of inflate it                                 make the the nare bandwidth wider and as                                 a completely new thing we can also                                 extend a sign distance field into                                 a mask of another grid which is a                                 complete new feature                                 all right so at this point i uh                                 i'm going to make what i believe is is a                                 pretty exciting uh                                 announcement for for openvdb so as i                                 mentioned before                                 openvdb was from the onset a sort of                                 develop for the cpu                                 and today nvidia is actually                                 sharing a library called nanovdb um                                 that was developed actually since the                                 the beginning of the year when i when i                                 joined nvidia                                 and it's the first attempt to try and                                 take some of the workflows                                 in openvdb to the gpu you should really                                 read something into the name                                 nano right it's not an attempt to take                                 the full open vdb library and port it to                                 the gpu                                 this is taking sort of a small subset of                                 problems specifically it's looking at                                 things like rendering real-time                                 rendering and ray tracing                                 and also things like collision detection                                 um so what is it                                 it's essentially a sort of a a                                 snapshot of an existing vdb data                                 structure                                 reshuffling the memory into a contiguous                                 block of memory                                 and then it also gets rid of pointers so                                 it's very efficient to copy between cpu                                 and gpu                                 it offers the same constant time random                                 access that we looked at earlier                                 that you will find in openvdb in fact it                                 turns out that                                 they're slightly faster in nanovdb than                                 in openvdb                                 simply because it's it's a more nimble                                 implementation um                                 it has a few extra things that openvdb                                 does not have                                 which is specifically to accelerate ray                                 tracing so                                 it bakes in meta data in the nodes                                 that accelerate things like volume                                 rendering                                 and ray intersection so it it has                                 bounding boxes of the active values at                                 every single node                                 and it also has statistics like min max                                 values                                 it supports all the types that you will                                 find in openvdb                                 including points with arbitrary                                 attributes so point index squares and                                 point data grids are also supported in                                 nanovcdp um another thing that's                                 quite exciting is that it's it's                                 virtually agnostic to the platform                                 so it's implemented in both c plus plus                                                                    and also there's a c                                              that geoflate actually uh ported                                 this the core data structure itself um                                 is a single header file                                 so in theory your client code only needs                                 to                                 include a single header file and this                                 set of header file has                                 uh no dependencies like optionally of                                 course you can                                 have a dependency on openvdb in case you                                 want to go from openvdb to nanovdb                                 but for a renderer to pick up nanovdb                                 you actually don't have any other                                 dependencies in this single header fr                                 it's using explicit memory alignment so                                                                                   which is required so we can tap into all                                 the different graphics apis out there so                                 it supports cuda optics opengl opencl                                 gsl and sperf it also has                                 a cpu fallback so it works equally well                                 on the cpu and the gpu                                 and currently nvidia's are also working                                 on adding                                 support for directx that's coming                                 soon um there's also a fast mapping                                 between the two and we can actually do                                 round trips so you can both go both from                                 openvdb to nanovdb and you can go back                                 again                                 um all right so it also comes with a                                 separate file format                                 um it's not that we are sort of                                 promoting the file format of any                                 of nanowrimo b to replace openvdb um                                 but it does allow as i mentioned before                                 it does allow applications like a render                                 to only depend on uh the nanovb library                                 itself in case you want that                                 um so we as i said we can do                                 serialization                                 in both directions uh we include a few                                 functions in the library as well                                 uh particular to cater for rendering so                                 serial first second and third order                                 interpolation                                 there's also the ability to actually                                 generate                                 nano vdb grids out of pretty much                                 any other volumetric data structure                                 without                                 necessarily converting to an openvdb                                 first there's a this is what's called                                 the grid builder                                 um there's a very advanced and cool                                 uh renderer including that was developed                                 by will breitbart                                 at nvidia uh that's actually included as                                 a demonstration                                 of of how to use nanodb with all these                                 different graphics apis and and as you                                 probably noticed                                 uh it's not that nanov only supports                                 nvidia's                                 api right so it's also open opengl                                 opencl                                 and some of the other ones so it's in                                 that sense it is truly agnostic                                 and there's also acceleration for uh                                 rate reversal and so skipping of empty                                 space this thing called                                 an an hdda hierarchical digital                                 differential                                 analyzer which is actually something an                                 idea that came from from openvdb                                 uh so it's been ported it's actually a                                 different implementation                                 and it turns out to be uh outperforming                                 the one in openvdb                                 um so these are some uh                                 oh sorry these are some uh benchmark                                 tests                                 uh it's just these actually very old but                                 they still hold up                                 so this is ray tracing uh the amadillo                                 um it's casting close to two billion or                                 two million rays per frame                                 um and uh the first thing you'll note is                                 that conversion from openvp's nanovdb                                 is is really fast it's about                                    milliseconds in this case                                 um and you're seeing different                                 um computational times                                 for single threaded cpu uh multi-core                                 cpu                                 actually                                                      the acceleration that you get from using                                 the hdda and                                 to sort of make a long story short uh                                 for this particular example we're able                                 to                                 retrace over a billion rays per second                                 which is                                 quite fast this is                                 another example just to show that it                                 really doesn't depend                                 much on the complexity of the model                                 it also has close to two million rays                                 um and again it's it's achieving                                 more than a billion ray intersections                                 per                                 second so this is this is full on um                                 ray level sets intersect so we're                                 obviously not rendering a match we're                                 actually rendering                                 a level set volume um this                                 is a screen session uh from                                 will's viewer that we are including                                 um so you can you can point it to an                                 open vdb file you can point it to a nano                                 vdp file and the nvp file of course can                                 um encapsulate many different grids of                                 arbitrary type                                 uh you can on the right hand side you                                 can actually have you have a drop down                                 menu so you can drop down and take                                 different graphics apis                                 uh so there's cuda optics                                 there is uh intel's threat building                                 blocks so the cpu                                 and so on you have the um you have the                                 frame count um                                 you have statistics um and you have drop                                 down menus where you can sort of                                 switch between your grids um so this is                                 the                                 the disney cloud um and of course we get                                 interactive frame rates                                 which is sort of the main point here                                 it's obviously not a production render                                 never it was never intended to be but                                 it's great for                                 debugging it's great for a sort of                                 example and starting code                                 in case you want to know how to use this                                 let's say for opencl                                 there are also lots of examples included                                 i'll point you to how to get to the                                 software at the end of this                                 presentation so this is importing point                                 cloud                                 and yeah i think i'll move on to the                                 next slide                                 so um this is actually an internal                                 application of a nanov                                 so andrew ritmeyer has developed a                                 really cool interactive                                 fluid solver called flow and he was able                                 to pick up                                 nanovdb and use it for sourcing                                 in the span of a couple of days um and                                 he's able to source                                 uh uh fuel on the left-hand side                                 and smoke density on the right-hand side                                 at about a millisecond per frame so                                 random access uh is very fast on on the                                 device                                 um these are two other examples uh this                                 these are kind of silly examples but we                                 really wanted to sort of                                 stress a point that the ray tracing                                 performance is is virtually independent                                 of the complexity of the model itself in                                 the sense that                                 the vdb data structure offers constant                                 time                                 access um so on the left hand side                                 you're seeing a level set of volume                                 representation of a hair ball                                 uh using two billion boxes which is                                 it's granted it's overkill but a certain                                 guess gives the point across we still                                 get interactive frame rates                                 and on the right hand side we have again                                 the disney cloud                                 but at a much higher resolution than you                                 saw earlier                                 all right so i really want to thank uh                                 obviously nvidia                                 for contributing this to the openvdb                                 project                                 but i also want to thank a number of                                 other companies that were helped us                                 sort of mature it and gave feedback uh                                 particular side effects ilm                                 and pixar and then i want to call out a                                 few people so                                 especially will breitbart have been an                                 amazing collaborator                                 as i mentioned he wrote the included                                 interactive raytracer um and he did a                                 lot of things as well                                 he did the cmake and and helped help                                 with the memory alignment and stuff                                 jeff uh was a great contributor as well                                 he                                 jeff who's actually on the on the tsc                                 committee uh                                 he ported uh the first c plus plus                                 implementation to c                                 and actually integrated nanovdb in                                 uh the next major release of houdini                                 so it's it's already on the way there's                                 also andrew                                 uh and frank that were uh very helpful                                 uh they're both at nvidia so                                 uh in case in case you want to try it                                 out i should say that                                 the release that we have today is sort                                 of a better release it's not a                                 production release it still needs to                                 go undergo some changes we need to add                                 directx support                                 we also need to go through the regular                                 sort of code review                                 but it's available uh it's actually                                 exists in what's called a feature branch                                 in                                 uh the openvp repository so just check                                 out                                 the the repo uh                                 and check out the feature itself so it's                                 called                                 features less nano db um and we also                                 have                                 a live blog that's hosted at nvidia                                 that discusses nano vdb a little bit                                 further and actually show some                                 performance tests and also some of the                                 examples                                 so that is it for me um                                 i think it's over to you now nick i'll                                 just stop sharing                                 awesome thanks ken yeah just a reminder                                 uh                                 any questions please put them in the q a                                 and we'll get to them afterwards                                 uh                                 but yeah we are we are watching it thank                                 you very much guys for tuning in thanks                                 ken um                                 cool so i'm going to give a very brief                                 uh                                 recap or and uh presentation on                                 openbdbax                                 uh for those that aren't aware i'm going                                 to do a bit of a history                                 very brief history of the project um                                 where we're at today and what the                                 project is                                 and also where we're what we're                                 currently working on where we see the                                 project                                 uh going so super quickly so                                 quick recap open bdb x was open source                                 at digipro in                                      it was always intended to be                                 incorporated into openvdb                                 and it's something that the tfc wants to                                 do uh but since the teens tsc's                                 creation uh roughly around the same time                                 we've had a lot of stuff                                 uh on the on the backlog to work through                                 so it's been a bit delayed                                 but i think we see a part in in the near                                 future to get openvp ax into the core                                 repository                                 it currently exists as a feature branch                                 and i'll share links for this at the end                                 of the slides as well                                 ax itself for those that are unaware is                                 a just-in-time compiled expression                                 language                                 for focus around manipulating geometry                                 attributes                                 it's it aims to provide compiled time                                 cpr plus equivalent performance                                 but also provide the portability and                                 deterministic behavior associated with                                 an expression language so you can plug                                 it into a variety of applications                                 and it's domain specific for vdb which                                 is                                 which is half true the language is                                 agnostic technically to the underlying                                 primitive types                                 but since it's since its original design                                 it was always intended to be specific                                 for openvdb points and volumes                                 and focusing on that allows us to tailor                                 the language                                 features to better act on those kind of                                 data types and i don't see that changing                                 anytime soon                                 so this is a super simple example                                 of how ax can be used                                 uh and also kind of highlights why we                                 wanted it in the first place well we                                 came up with the idea why we worked on                                 it                                 uh so this is a very basic uh openvdb                                 simulation we've got overview points                                 being a defective through a vpdp                                 velocity field                                 uh the level level set representing the                                 collision and it's pretty boring it's                                 pretty smooth                                 so one technique that we could use to uh                                 make this more interesting is by                                 injecting some cone noise injecting any                                 noise at all really onto                                 some of the particle velocities within a                                 certain scale                                 this is kind of what that looks like in                                 c plus plus you don't need to                                 be able to see the code here this is                                 more just to highlight how much                                 boilerplate there is                                 and just stuff you have to do before you                                 can actually get to the interesting                                 parts                                 of your operation um which is basically                                 running your per point manipulation                                 and altering those velocity values and                                 you can kind of think of ax as a window                                 into                                 that side of interfacing with bdb data                                 when it handles                                 the uh or everything else for you and                                 here's what the code looks like                                 in ax so this is the equivalent coding                                 ax um                                 just to kind of talk through the syntax                                 hopefully this isn't too um                                 unfamiliar with other coding styles                                 looping over every point in this case                                 this dollar syntax is pulling from                                 user-defined parameters                                 and then we have a little function here                                 that's building there uh building some                                 noise                                 and applying that to uh open uh point                                 velocity attributes                                 this could also run over uh vdb or vw                                 velocity field but in this case we're                                 running over points and accumulating                                 uh velocity attribute with this syntax                                 and that's this is what the result looks                                 like                                 um so yeah fairly fairly simple and                                 fairly simple kind of example but i just                                 wanted to show                                 everyone that's unfamiliar with what the                                 language looks like and what the project                                 is how it can be used to influence vdb                                 data                                 cool so i want to spend the majority of                                 the presentation talking about new                                 features and where the project's going                                 uh the first thing we've done is                                 documentation which might not be                                 the most exciting thing but it's                                 definitely one of the most useful                                 uh parts of uh the the new release                                 it's uh currently hosted on my personal                                 github but will be moved into the um                                 open bdb docs uh when that merges                                 completes                                 so please check that out the language                                 docs are looking pretty good now                                 still a lot more work needs to be done                                 here but it's going to be a work in                                 progress up until that that gold release                                 other new features so previously you                                 could only iterate                                 over voxels within vdb you can now                                 specify any                                 uh tree level within a vb data structure                                 to execute over                                 so if you run back to ken's presentation                                 you can choose any                                 uh node level within the vdb data                                 structure and iterate over those                                 and allows you to manipulate every value                                 in a vdb                                 and we've just made a bunch of                                 improvements and fixes which you can                                 also check out at the uh                                 changes blog and i'll provide that link                                 to the end of the presentation as well                                 one of the uh other additions we made is                                 the introduction of this header file                                 so for those that are familiar with the                                 project before                                 to run like a full ax pipeline from                                 parsing uh                                 compiling code generation to execution                                 you have to interface with a few                                 uh different parts of ax this kind of                                 wraps all that in to get                                 all that together so at the c plus plus                                 in c plus api                                 you can now run a single function and                                 incorporate that into your programs                                 so i just want to demo that super                                 quickly so this is a really                                 hamming example really simple file about                                 uh sorry simple example where you can                                 read in                                 uh an openvdb file it's not doing                                 anything with it and then just writing                                 writing it back out                                 and then to incorporate ax uh we can                                 step through this particular                                 uh code on the left we're going to                                 include ax as a header                                 we're going to initialize ax in a                                 similar way that you initialize                                 um openvdb we can then run any custom                                 ax code so here we're looking for a                                 surface attribute or grid                                 uh attribute if it's points um grid                                 obviously if it's a vdb volume                                 and we're accumulating a just a small                                 value onto that um                                 and passing in the grids that we've read                                 from the file                                 making sure we uninitialize ax and then                                 writing everything back out to                                 disk so hopefully that demonstrates um                                 how simple it can be to                                 incorporate ax into existing b                                   workflows                                 so a couple of uh things that we're                                 working on that aren't currently                                 released but we'd like to get                                 out as soon as possible as i mentioned                                 ax was a bit                                 a bit in feature lock to uh try and                                 help with the adoption into the openvp                                 project um                                 but since then we've added a few we're                                 working on a few new features the first                                 is                                 attribute function syntax and this                                 syntax is subject to change so                                 this might might change before its                                 release but the idea here is to be able                                 to call                                 functions which are specific to a                                 primitive type and have specific                                 behavior for that primitive type so in                                 this example                                 all these functions that you see here                                 that are being called                                 after this app surface syntax                                 are specific for vdbe volumes                                 so the first four here we are retrieving                                 arbitrary coordinates and performing                                 arbitrary                                 samples from a coordinate the next three                                 here are retrieving transform                                 information from a volume                                 and the last two here are querying                                 whether or not a particular coordinates                                 is a voxel which will return force if                                 it's a tile or another node type                                 uh and also whether or not i know it is                                 active or not um                                 and you can see with the last few                                 functions here how                                 focusing on vdb specific functionality                                 lets the language                                 uh uh leverages the language to be out                                 and called to be able to focus on more                                 specific vdb                                 features so for example the activation                                 uh                                 kind of node masking of the bdb or                                 whether or not a vdb is app uh noise at                                 a particular level within a bdb                                 cool so this is a quick demo just going                                 to pause it                                 so this is a super quick demo in houdini                                 which demonstrates these new features                                 so i'm reading in the dragon asset that                                 you can get from the vdb websites                                 and on the left here i've got a smooth                                 operation and forming a mean filter                                 with five within five voxels                                 so with these new operations you can                                 construct your own filters you can                                 match existing functionality and you can                                 extend it as well so if we don't uh jump                                 into this                                 little subnet here so a very one                                 unfamiliar this                                 uh node network on the right is going to                                 try and match the same network on the                                 left                                 uh this is this is a vdb ax sop which is                                 part of the                                 um part of the software that we're                                 that's publicly available um on the                                 right here you can                                 maybe just make out the kind of code                                 that's being run uh which is this node                                 that's not attached to anything                                 and this just simply demonstrates how a                                 naive implementation or a naive                                 implementation of                                 a mean filter which is accumulating                                 neighboring values and forming an                                 average and then writing to the original                                 level sets                                 on the left here instead we have these                                 three ax                                 nodes which are chained together which                                 perform individual mean filters across                                 this vdb and are gathering uh                                 voxels in a particular axis summing them                                 together averaging them and writing them                                 back to the level sets                                 and the idea here is that that that no                                 chain on the                                 left matches the result exactly which                                 hopefully you can see now                                 so this isn't a particularly uh perhaps                                 not a                                 too interesting example in terms of new                                 functionality                                 but hopefully you can immediately see                                 how just by accessing                                 the different kernels the different uh                                 ways that you're looping over voxels                                 you could manipulate this mean filter                                 and uh                                 change uh perhaps the width of one axis                                 the scaling of an axis or                                 incorporate a whole different type of uh                                 voxel lookup pattern                                 lastly just to cover where we're looking                                 to take the project                                 so the first major thing is point volume                                 interaction                                 currently with ax you have to only                                 execute over                                 vdb numerical volumes or vdb points this                                 is a                                 bit annoying because with things like                                 sampling it's such a common operation                                 for you to be able to sample                                 from a points position onto another                                 points attribute                                 um so this is this is definitely i think                                 our number one priority uh to be able to                                 incorporate different volume                                 uh functions with points and vice versa                                 uh a metadata executable so executables                                 in ax                                 are linked to the geometry that they're                                 uh                                 accessing so the two current executables                                 we have are points and volumes                                 a metadata executable would allow you to                                 iterate once over each individual vdb                                 still provide you read and write access                                 to that vdb but also allow you to write                                 completely arbitrary metadata to the                                 grid which supports metadata                                 uh read from that metadata and perform                                 wholesale operations across a vdb                                 uh user functions so we spent a long                                 time                                 uh improving the c plus plus api for                                 developers to be able to customize                                 how you can inject c plus bindings into                                 ax uh so that's come a long way                                 and the reason we did that is because                                 that's                                 one of our first ports of call to be                                 able to extend ax's functionality just                                 very quickly we have a complicated c                                 plus plus                                 method but if it's purely mathematical                                 we can quickly inject that into ax and                                 that becomes available                                 however what you can't do is customize                                 and define user front-end functions                                 currently so that's that's definitely on                                 the roadmap                                 python bindings we python bindings do                                 exist in the standalone repository but                                 uh they probably won't be part of the                                 original merge into the                                 uh into the openvdb repository                                 uh they need a bit of work but they do                                 allow you to run ax                                 through python so you can use the python                                 library that b                                                       uh vdb grid you can use these pipe                                 bindings to                                 then call ax from python                                 and finally uh nanobeat nano bdb support                                 as as ken has                                 announced we would love to be able to                                 instead of targeting points and volumes                                 in the cpu                                 target nano vdb uh back-end kernels on                                 the gpu                                 ix as far as the language is concerned                                 wouldn't change you'd still write the                                 exact same code but this would allow you                                 to                                 manipulate and write custom kernels for                                 nano vdb data types                                 and that's that's everything yeah so                                 if you have any questions please let me                                 know um and if anything doesn't get                                 answered                                 feel free to uh email this the                                 developers here                                 uh i just want to give a quick shout out                                 to rich jones as well i think he's on                                 the                                 in my me might be listening uh but he                                 was also a big part of this entire                                 project                                 and is continuously working on it as                                 well in terms of                                 accessing the projects it's in a bit of                                 a weird transition because we're still                                 getting it into vdb you can access it as                                 a standalone project through                                 the dnx github or you can access it as a                                 feature branch                                 through the academy software                                 foundation's fork of openvdb                                 where it will um where will be migrated                                 to                                 the dna repository will be retired once                                 that's once that's                                 completed that's that's everything um                                 so i guess now we can move on to                                 questions i'm gonna before we do that                                 what i'm gonna do is                                 pull up a more generic roadmap for                                 openvdb                                 i should probably i should probably not                                 call this a robot this is more of just                                 a bunch of things that we are we have                                 discussed over the last few years                                 we know there is interest in and we                                 would love to pursue further                                 so as well as questions if anyone has                                 any comments any thoughts                                 if there's enough if there are things                                 here that you would like to see                                 or if you just want to get something a                                 plus one please just uh                                 yeah please put it in the chat um but                                 yeah i'll hand over to questions now                                 let's have a look cool                                 uh so i think the first                                 question uh is from                                 an anonymous uh teddy it asks about                                 i'm assuming this is related to nanowriv                                 that's about                                 um with gl if webgl is supported um                                 it isn't today but it's actually one of                                 the things that uh                                 we're looking at so that's a good chance                                  that it will be                                  uh uh                                  oh yeah actually i i forgot there's                                  there's one name that i forgot to                                  to add to my uh list of acknowledgements                                  so                                  uh yomning who i'm i'm might actually be                                  butchering your name                                  or in your promising nation i'm sorry uh                                  but he's he provided the um                                  the softbody simulation uh that you saw                                  in the in the beginning of the nov                                  presentation using tai chi so uh                                  he has also added uh support for nano                                  vtb                                  in in tai chi um                                  let's can can see                                  just see the uh roadblock right now is                                  that okay                                  yeah okay okay you want to talk about                                  that or do you want to go through                                  [Music]                                  i just wanted to make sure that uh that                                  that you were seeing just the roadmap                                  so i can bring up the questions as well                                  yeah feel free to                                  cool um oh cool yeah so i can i can                                  see so the next one is uh how ax                                  compares against the tai chi programming                                  language                                  is there any comparison against it in                                  terms of performance um                                  so i think that's a good question there                                  are two very different things                                  so tai chi is is a is a high level                                  uh programming language for for                                  simulation specifically uh whereas                                  nanovdb today is                                  um specifically for vdb and it's                                  specifically targeting real-time                                  rendering                                  um in in a way that's agnostic                                  so it's it's a little bit like apples                                  and bananas                                  you know it it's it's it's possible that                                  they will overlap more in the future but                                  today i think it's it's very difficult                                  because                                  because nano b                                                  simulations that                                  um that tai chi can do and tai chi can't                                  do the                                  the real-time rendering that uh nanov                                  can do so                                  yeah i don't really know how to answer                                  that question                                  um but but if you're interested in                                  in benchmark specifically uh the blog                                  post that i                                  mentioned the one that's hosted on uh                                  nvidia's website actually has some                                  benchmarks                                  and the repository itself has several                                  benchmark tests                                  that you can you can try                                  and in terms of ax in comparison to tai                                  chi                                  it's not something we've actually                                  investigated um                                  tai chi as far as i understand it                                  attempts to solve a similar but slightly                                  different problem                                  ax is more designed to um manipulate                                  attributes                                  run this specific kernels per attribute                                  on a very                                  uh on a more granular level whereas tai                                  chi you're able to build entire solar                                  frameworks                                  out of um i i imagine there is some                                  crossover                                  and i know that tai chi also um uh                                  it is targeting similar you know compile                                  time parallel performance                                  uh so i'd like to think that they're                                  very similar because the in our                                  benchmarking against cbos plus code                                  we come out very very very similar so if                                  tai chi is doing the same thing then i'm                                  not sure there'll be too much difference                                  right uh i see that's a question about                                  support for metal um                                  and it's it's the same answer it's not                                  in there today                                  but uh we're working on it definitely                                  should be                                  uh supportive so so the goal the goal is                                  really to try and support us                                  as many of these apis as possible                                  without you know                                  there are some apis that have some                                  restrictions uh that are                                  tough to work around i believe metal has                                  a limitation in terms of                                                and floats um but we can probably                                  find a work around that um and and only                                  support                                  single person grids i don't know but it                                  is something we're working on                                  for sure um                                  make feel free to pitch in oh yeah sure                                  sorry um                                  so one way uh is the nano vdb viewer                                  available to download is open source                                  yes to both yes yes it is uh you have to                                  check                                  it's like it currently exists as a                                  feature branch in the economy software                                  foundations                                  uh over the repository right                                  actually i think i think what we'll do                                  is we will make a little post                                  on the openvdb website                                  uh sort of announcing that nanovdb is                                  available but also tell you how to                                  access it how to get it                                  it's quite simple but we'll spell it out                                  what else lots of questions on nanovdb                                  uh these are mainly for you ken right                                  so i think common a common thread in                                  these questions                                  are sort of related to simulation like                                  will nanovdb                                  be able to do simulations in the future                                  um that's a that's a good question                                  uh so i i should emphasize                                  that the data structure itself the                                  linearization when you go from an open                                  vdb                                  to a nanovdb is actually                                  it's sort of a snapshot so it's not a                                  dynamic data structure today                                  on the gpu so we will have to                                  to add changes to support dynamic trees                                  um that's not to say that it's                                  impossible um                                  and i should also for full disclosure                                  say that nvidia is actually working on                                  something                                  of this nature um but i can't really say                                  much more than that                                  so it is coming in in one form or                                  another                                  um but today uh the only thing you can                                  use that nano for                                  are things that involve static trees um                                  so as i said ray tracing is sort of the                                  the                                  prime example but actually the way that                                  this is used                                  in houdini today is for collision                                  detection so                                  imagine that you have a class                                  formulation or some character simulation                                  and you're actually representing the                                  collision geometry as an implicit                                  um sine distance field and that's that's                                  a                                  brilliant um use case for nano db right                                  because                                  all you have to do is you do you do very                                  fast queries                                  into the volume data structure to                                  compute                                  inside outside and closest point                                  transform                                  so so oh sorry go ahead that's right i                                  was going to                                  address another question if you were                                  going to carry on yeah                                  yeah so one uh is there any example i                                  know yeah is there any example of usage                                  of openvdb on hpc cluster using                                  distributed memory parallelization or                                  hybrid open                                  uh mpi tbb um                                  i don't think there's an example that i                                  can point to but it's something that                                  we're very interested in                                  pursuing uh i think it appears in the                                  roadmap it's it's been brought up before                                  um using openmpi specific specifically                                  for distributed                                  bdb tasks would be uh very interesting                                  to pursue                                  uh it would still obviously be parallel                                  under the hood                                  um each individual cluster would have uh                                  would would be able to leverage                                  the overview these multi-threaded tools                                  but we'd look to distribute the work                                  um with some kind of you know halo                                  communication jeff is you gonna put                                  chiming yeah                                  yeah because uh here's an example dan um                                  added graph                                  a few years back of the distributed                                  fluid solver based on vdb                                  and likewise um there's a toolkit                                  example in houdini now                                  of doing uh sliced distribution of vdbs                                  yeah so those are two examples of people                                  trying to do distribution                                  so the short story is that there are                                  there are several examples of people                                  that have done it and are doing it uh                                  but it's not part of the distribution                                  yet and that's that's actually what's                                  listed under the                                  major proposals on the roadmap uh i                                  think                                  nick is trying to see if he can possibly                                  share                                  some of the some of the code that you                                  guys are using at d-neck                                  that um yeah api                                  yeah so so my experience with this is                                  specifically of open mpi and it                                  is completely possible it is it's a it's                                  a huge                                  task uh so and it would be                                  to design a kind of a generic framework                                  to work with openvdb                                  and and all of its tools as well so uh                                  but if if it's good to know that other                                  people are also interested in this                                  right                                  can is there any other yeah there's a                                  question about what version of dslr                                  uh does an nwdb require actually                                  i i don't know i can definitely find out                                  but i don't know so                                  uh i encourage whoever submitted that to                                  maybe shoot me                                  an email directly and i promise to find                                  out for you um                                  we'll write for you we'll we'll know                                  uh there's one uh is there any example                                  how uh how to extract sharp features                                  when doing mesh to volume back to volume                                  to mesh                                  oh is this um                                  is this part of the houdini toolkit is                                  this what we pulled up before yeah                                  yeah i think it is the best example we                                  have is the                                  um houdini open vdb houdini um                                  uh bdb                                                                   all the code in                                  like open source there for how you have                                  to do it it calls into the functions all                                  the time                                  so you'd have to figure out the                                  equivalent for polygons are but you'd                                  have to do that anyways forever your                                  local polygon libraries                                  but we did recognize this is something                                  missing from the uh                                  default toolkit ideally there would be                                  something that does it entirely in dvd                                  land                                  if you make something like he's                                  contributed to the project                                  i think i think the main problem is that                                  the openvp library doesn't really have                                  a very sophisticated mesh data structure                                  so it's it's not easy for us to                                  provide an example outside of a dcc that                                  has                                  its own mesh data structure like houdini                                  but but the idea itself is actually                                  quite straightforward                                  the idea is that you use you use the                                  original                                  um mesh um                                  to sort of project the the the sharp                                  features of the new mesh                                  onto and that's what allows you to                                  preserve these very sharp                                  sharp corners when you're doing let's                                  say um                                  when you're doing cst operations uh                                  let's say you                                  you're breaking up a structure um and                                  you want to have a swap frame                                  so you want to pre-fracture everything                                  but you want to do it in a way that's                                  sort of seamless                                  and that's a great application for this                                  so you do your your                                  volumetric csg that that on in itself                                  actually will create increases but then                                  this mesh extraction tool                                  will allow you to project the new mesh                                  onto the original mesh                                  such that these creases are completely                                  gone                                  but we we can try and see if we can if                                  we can provide an example                                  in openvp itself it's just not                                  so straightforward and um question any                                  plans to extend nanovdb to multi gpu                                  yes definitely definitely                                  cool easy answer                                  um i think i've i've mentioned this                                  before but i'll                                  say it one more time so so what we're                                  releasing today                                  is is a better release right it's not                                  it's not a production release                                  you're absolutely encouraged to pick it                                  up and you know                                  kick tires and give us feedback um                                  and as i mentioned houdini is already                                  going to ship with it                                  but we will be making changes we will be                                  making improvements so                                  yeah let us know if there are things                                  things that are missing that you'd like                                  to see                                  added to it and then hopefully hopefully                                  it will be                                  in a production release before the end                                  of this year that's at least my goal                                  does uh nano b                                                          surface extraction and level set                                  conversion on the gpu                                  no it does not um                                  but again that's that is something that                                  we've talked about something                                  we're looking into but whether it will                                  be in nanovdb and or some other gpu                                  library i don't know but i think it's                                  fair to say it's coming                                  and i think you addressed the glsl                                  question one sure but uh uh                                  next one was as far as i understand                                  nanovdb is focused on ray tracing would                                                                                                        um that's a a good question i                                  it depends on what what what you use it                                  for like if you're actually manipulating                                  the volume uh changing the tree                                  structure                                  probably not uh if you're                                  obviously if if anything that you're                                  you're using a static                                  sparse volume for would be a great                                  candidate for for nanoadb                                  um but if you're if you're dynamically                                  modifying it                                  uh probably not i need to                                  clarify it's not about ray tracing                                  that's how it was originally                                  discussed but it's actually very much                                  just about having the sparse                                  volume on the gpu and um so like                                  everything we use was not ray tracing                                  and so i could think of a lot of things                                  for                                                              right off the bat without having to                                  manipulate topologies to work with it                                  right right oh that's true that is true                                  and in fact jeff you                                  you're the first one to sort of break                                  break the tradition and use it for                                  something completely different                                  uh your collision detection right                                  got a got a good one here uh where's the                                  best forum location is it the google                                  forum group or                                  via the aswf that's a great question                                  we ask ourselves that every week                                  it's the google forum                                  i i think the google forum we've been                                  looking at as uh                                  more of an open discussion about uh you                                  know high level discussion about tools                                  and features                                  whereas um                                  again we we do use github issues as well                                  for more specific software                                  issue uh specific issues with the                                  software but yeah i don't think we're                                  currently using the aswf abs developers                                  for too much discussion                                  that doesn't revolve around the tfc                                  meetings                                  i agree that it would be good to try and                                  consolidate some of these                                  in major proposals how does                                  multi-resolution bbb                                  differ from current pdb uh                                  i think the main thing here so there is                                  actually a again again uh can i guess                                  i'll let you talk to this because it was                                  your implementation                                  of the current multi-grid supports that                                  exists in                                  bdb right so so                                  there is sort of limited what i call                                  limited support for multi-resolution                                  grids                                  in vdb today through the tool called                                  multi-res grid and it is essentially it                                  builds um                                  again it's it's for static applications                                  and it builds                                  a level of detail hierarchy of                                  of graceful progressively coarser                                  voxel sampling so imagine that you have                                  a high resolution                                  let's say you have a high resolution uh                                  stf that you want to use for creation                                  detection                                  um you can then build a hierarchy of                                  of trees uh with progressively                                  caution causal resolution that you can                                  probe um                                  but the the proposal that's listed in                                  in the roadmap is something entirely                                  different um it's actually                                  um it's so we've been in dialogue                                  with the bifrost team at autodesk and                                  they have a very cool                                  uh multi-resolution volumetric grid                                  that's dynamic                                  um and as far as i understand they're                                  actually using                                  openvdb for io um                                  so we've been looking into unfortunately                                  it's it's not moving very fast i think                                  the ball is                                  our caught to be honest um well we've                                  been talking                                  with them about adopting essentially                                  their their great structure and that's                                  that's a uh an adaptive um                                  structure so so maybe it's worth                                  pointing out when we say at                                  when we say motor resolution and                                  adaptive um                                  you know additivity can mean many                                  different things                                  and in this case what we mean by                                  multi-resolution is the fact that                                  a grid value can be sampled at different                                  resolutions                                  so a single a single value may exist                                  at different levels in this in this tree                                  structure                                  whereas currently in vdb a grid value                                  ijk                                  only exists at a one level                                  you know it can either be at a leaf node                                  at the finest resolution                                  or it can be higher up in the tree at a                                  tile                                  the fact that that vdb has a very very                                  high fade out factor                                  remember remember the diagram i showed                                  you with                                  four different levels uh demonstrating                                  that it's a very shallow tree                                  the reason it's so shallow is that the                                  fan out factor is very high                                  that's great for access but it's not                                  very good for adaptivity                                  because the refinement in resolution                                  when you jump from one level to the next                                  is is very big um you know                                  you can sort of contrast it to an octree                                  which has                                  ideal refinement because it's one in                                  sorry it's two in its coordinate                                  direction um                                  so yeah so it's a long way of saying                                  there is                                  there is some support for ultra                                  resolution today in vdb uh                                  but but if you're looking for something                                  that's adaptive dynamic                                  uh you still have to wait a bit um                                  just before we go on to the next                                  question um jeff makes a good point                                  we are considering removing the                                  makefiles from the vb distribution                                  and if anyone has any thoughts about                                  that or concerns or doesn't want us to                                  do that                                  just let us know soon or now um                                  uh yeah just wanted to mention that                                  before we go on to the next question                                  uh ken one for you can nanovdb use                                  paging or similar methods on the gpu to                                  reach large volumes                                  eg production caches onto the gpu                                  while staying within gpu memory limits i                                  assume we're talking about streaming                                  that's just something to extend here                                  um not not today uh but there is                                  actually                                  there is uh another team at nvidia                                  that's that's working on this                                  so nvidia has a commercial product                                  called index it's a scientific                                  utilization                                  tool that allows you to visualize                                  very very large scientific data sets                                  like typically stuff that comes out of                                  hpc                                  and it actually uses obviously                                  multiple gpus that actually use the api                                  and they're working on adapt on adding                                  other core support to                                  nano adp i'm i'm hoping i don't know for                                  sure but i'm hoping that                                  we can share that back but the                                  the idea of using memory pools is a                                  great idea and obviously this is what                                  you need                                  to have a dynamic data structure on on                                  the gpu                                  um and because nanovdb doesn't have this                                  pool                                  you know that that's also why it's not                                  it's                                  not um it's limited it's not                                  able to uh modify the tree yet                                  um                                  last one again was about communication                                  how about slack or discord group                                  i don't think we're opposed to any forum                                  type for discussion                                  uh is perhaps something we should bring                                  up in in one of our steering committees                                  i would love slack i have great                                  experience with it                                  um i can't remember does aswf                                  have a slack channel or a slack account                                  yeah we do have a slack group we do go                                  slack.aswf.io                                  and there's an openvdb channel on there                                  oh there it is                                  wow okay there you go                                  maybe we should start using it                                  cool cool                                  yeah looks like we've exhausted all the                                  questions                                  um is there anything more you want to                                  say about the robot nick                                  um is there anything you could say about                                  like when do you think ax will be                                  available you think you know this year                                  or i mean you don't know ax is ax is                                  is ready to go i think uh it obviously                                  it still needs to be vetted                                  thoroughly by the tsc um we've had a                                  good round on the front end language on                                  the actual language specifically                                  so i think that's in pretty solid states                                  uh                                  so we would like to see it i think                                  in a                                                                     next release of bbb                                  cool i don't know if anyone else has any                                  comments on the roadmap                                  yeah i can make a few quick comments um                                  i'm just going to quickly mention that                                  like                                  some of our focus uh over the last year                                  or so and i imagine going forward will                                  be the case as well is                                  trying to kind of streamline the library                                  and the tree hierarchy                                  a little bit uh over the years it's kind                                  of grown in size and there's more and                                  more tools that are that are in the tree                                  hierarchy and especially with                                  uh examples like nanovdb where a very                                  lightweight hierarchy has a lot of                                  benefits                                  uh we're trying to sort of pull some of                                  those tools out                                  uh we've also found some performance                                  improvements through through some of                                  those tools being                                  being separate so that we can use                                  different kind of techniques for                                  for paralyzing uh that makes them a bit                                  faster                                  um and so yeah so some of the work                                  that's happening with that                                  and then obviously framework building                                  stuff improving the c                                  make we've done a huge amount of work on                                  the cmake over the last year or so                                  and there's a lot more to do with that i                                  think but uh it's getting to a stage                                  where it's becoming a lot more mature                                  so definitely we're trying to formalize                                  that and that's giving us opportunities                                  to try and reorganize the code base a                                  little bit move things around a bit                                  just kind of tidying up and modernize it                                  in a few places where it needs to be                                  um yeah i haven't got any more comments                                  in terms of the                                  different features that are there we we                                  need to kind of discuss some of the                                  roadmap items and figure out which of                                  the big kind of priorities but yeah for                                  the for the time being ax and nanov                                  remain the two                                  sort of focus points at the moment                                  one last question uh ken how does                                  nanovdb compare against gvdb                                  oh um i honestly don't know                                  um so i think i think                                  gvdb so actually the                                  rama the the core                                  architect of tvdb uh                                  has left nvidia and i                                  believe the project is not being                                  developed more                                  so                                  nvidia itself is actually is moving on                                  to another project that unfortunately i                                  can't talk about                                  um but in terms of comparison between tv                                  db                                  and nano vdb it's                                  again it's it's a little bit apples and                                  bananas because gvdb                                  allows you to do simulation uh                                  nano video does not uh that will be                                  focusing on rendering                                  i have not i i'm pretty sure dvdb can                                  also do                                  uh uh ray tracing i have not compared                                  the two                                  uh i would be surprised if there's a if                                  there's a big performance difference                                  there really shouldn't be because                                  underneath i think gvdb is using a data                                  structure that's fairly similar to                                  to the vdb data structure so                                  yeah i think that's that's actually a                                  good question i should uh                                  i should check that out um i see a                                  comment came in uh that apparently gvdb                                  will be out of support for nanobb in a                                  few days                                  oh sorry gvdb will be out of support in                                  a few days                                  no add in support for nanovdb in a few                                  days it's in the chat                                  oh cool okay sounds like someone is                                  still working on it                                  that is cool okay i take i take back                                  what i said then                                  there was another question i                                  accidentally dismissed it was                                  oh is it over that's no i just i just                                  ended the                                  screenshot um what was the license for                                  this and can be used for commercial uh                                  development i hope it can be used for                                  commercial development because                                  uh houdini is                                  oh i forgot to mention that there's a                                  pig light no                                  um it's it's the exact same license as                                  open                                      right so the same same same restrictions                                  or                                  lag off as open vb so yes you could                                  definitely use it for commercials also                                  if we have time super quickly one last                                  one are there any examples of how to                                  load triangle meshes to nano bdb                                  i guess you could go through open vdb to                                  a nano vtp                                  yes that would that would be the                                  workflow today so so think of                                  think of nanovdb as a bridge to the gpu                                  uh where you can do anything on the gpu                                  that involves a static tree                                  and as i mentioned many times before                                  rendering is one example creation                                  detection is another one                                  i'm sure there's a bunch of other                                  examples that we haven't even thought of                                  yet                                  um but in terms of authoring                                  uh vdbs from a mesh you                                  currently have to go through um openvdb                                  um but that that may change                                  so cool i think we're spot on                                  uh yeah so so thanks everyone for                                  uh dialing in and for listening to this                                  uh presentation uh if you have more                                  questions                                  by all means please reach out uh you can                                  you can use email you can use the the                                  two forums that we talked about                                  um and we'll try and keep you up to date                                  yes thank everyone                                  cheers
YouTube URL: https://www.youtube.com/watch?v=VJBv9lh5kqg


