Title: Open Shading Language Community Meeting
Publication date: 2020-08-24
Playlist: Open Source Days 2020
Description: 
	Open Shading Language Community Meeting
Speakers: Larry Gritz, Declan Russell, Zap Andersson, Adrien Herubel, Chris Kulla

For more information about the Academy Software Foundation go to: https://www.aswf.io/

Open Shading Language users and contributors will get a project update including the following topics:
* Project overview and brief introduction to OSL for new users.
* Adoption of OSL into the Academy Software Foundation, and what that means for the leadership and future of the project.
* Recap of recent changes, leading to release 1.10.
* Current status and roadmap, including update on major initiatives such as GPU support with OptiX and SIMD batch shading on CPU.
* Ways to participate and help steer the project.
* Q&A and community discussion
Captions: 
	                              uh so hello welcome to the open shading                               language community meeting                               uh i'm larry gritz i'm on the tsc                               and i'm the chief architect of asl um                               so uh briefly today um                               we're gonna give a little bit of a an                               introduction to the project                               um we have a wonderful section from zach                               anderson                                um that is a video giving                                both a an overview of what osl is all                                about                                um sort of from a user perspective as                                well as a brilliant                                demo of what the implementation                                is looking like from a user experience                                perspective in                                                      think is really kind of                                best for class of these things at this                                point um i                                will return to me for a general project                                update                                on you know what our status is and what                                we've done over the last year since                                since the last of these meetings at                                siggraph                                we will then uh go back to um                                to declan and adrian to talk about the                                progress                                on osl running on the gpu and their                                experience integrating that                                into the arnold renderer um                                back to me to finish a little bit of uh                                future looking                                road map for the project and then                                hopefully we'll have                                lots of time left for uh general q                                a and uh chris culla who is the                                the chair of the tse long time                                developer on osl will moderate the                                q a for us so                                let me start with a little bit of a                                brief intro and a recap on                                the important details about the project                                that everybody here should know                                so just in case there are people who are                                not super familiar with it you're just                                passing through                                this is your first introduction to the                                project open shading language or osl                                is a domain specific language that is                                geared toward describing                                uh patterns and materials um that you                                typically find as a way to                                extend programmability to uh to                                renderers but they're not                                exclusively for that but that's that's                                the main target                                it's delivered as a software uh system                                that is um it's not an end user system                                that                                that users you know sort of directly                                interact with this map                                but rather as a library that different                                renderers                                embed in their core to handle the                                handler sharing it is an open source                                project                                has been for                                         under the bsd license we have a pretty                                broad                                participation we've had over                                   contributors from across the industry                                and and in case you haven't seen it on                                the                                here's the github link to go to the                                heart of the project page                                this will eventually be moving but even                                when it does                                um this link will always take you to the                                right place                                so the core design goals for osl                                is that we wanted to make a chain                                language that was really                                um sort of modern and geared toward                                today's uh and future physically based                                path tracers a lot of the other                                languages out there                                that have been used for shaving                                historically had really been designed                                around much older technology older                                rendering methods                                and had become a bit of a mismatch to                                where the rendering field                                had been going lately so in particular                                some of the things that we changed                                versus other languages                                are to make much more of an effort to                                have a view independent material                                 description                                 um we compute what we call closures                                 rather than                                 the final lit colors from the particular                                 direction and that's what gives us a lot                                 of the flexibility                                 and we inside the shaders you know a                                 cell shader                                 you don't the shader code itself does                                 not directly                                 um loop over lights or cast rays inside                                 the shader                                 and those things have been pushed back                                 to the renderer that's where it can                                 really be done                                 better we base this implementation                                 on a lot of modern compiler technology                                 with llvm at the heart of that and that                                 means that                                 we assembling these shaders on the fly                                 at run time                                 and jitting all the way down to direct                                 machine code that can be                                 executed very quickly down to the                                 hardware level                                 and yet we keep the language itself                                 really free from any kind of hardware                                 specific idioms so we're                                 we're trying very hard not to tie it to                                 any current hardware                                 anything that might change we want these                                 things to last                                 um as well to not have                                 very many artifacts that that would make                                 you need to be                                 especially aware of which renderer                                 you're you're running on                                 um there are there are some details uh                                 of course they creep in                                 but in general the language is meant to                                 not reflect any particular renderer or                                 or rendering algorithm uh and of course                                 it's all open source                                 um so a brief idea of the timeline for                                 people who are new                                 um at sony imageworks we were starting                                 to look at this                                 as a project um really really as an                                 internal project                                 um back around mid-                                     by the time it was really starting to                                 take shape as a company we were                                 becoming very committed to open source                                 projects and this became one of our                                 early ones so we announced that it would                                 be an open source project in the summer                                 of                                      by the following winter the code was                                 live i think we're on                                 google code at the time and later                                 switched to github                                 the following summer in                                               myself cliff stein and alex conte                                 uh gave a sgraph talk um really letting                                 out a bunch of the details                                 um and following that we were actually                                 working on getting production ready and                                 the first                                 real movie that we saw released that was                                 relying completely on osl                                 was men in black three in                                             that was our                                 childhood the adolescence was a                                 whirlwind                                 of our little project getting picked up                                 by                                 more and more studios uh embedded in                                 more and more                                 commercial and other product products                                 and in                                                               academy                                 scitec award to recognize you know how                                 transformative                                 it had been earlier this year                                 we also applied for                                 adoption as a academy software                                 foundation project                                 which we now are so where                                 will you see this in the wild um you                                 know the majority                                 of the high-end film oriented                                 commercial renderers and now have                                 various levels of support                                 including for many of them oso being the                                 sole                                 or primary method for programmable                                 shading and patterns                                 it's also the shading system in                                 a variety of studio internal                                 uh renders and in a growing number of                                 open source projects as well                                 and uh just the films that we                                 super uh surely know about um we're kind                                 of well over                                                                                                    um but um the actual number is probably                                 uh vastly greater than that because osl                                 is                                 embedded in so many renderers um people                                 just use it as a matter of course                                 and it's actually quite hard for us to                                 keep track of all the projects they use                                 it on                                 so with that i would like to play                                 the video from zap uh that goes much                                 more um eloquently than me uh                                 into uh user perspective um and really                                 shows off i think what oso can be                                 for a more comprehensive system                                 hello i'm zap anderson from autodesk                                 today i'm going to do a little                                 introduction to osl                                 and i'm going to exemplify that with the                                 implementation                                 in                                                              well it stands obviously from open                                 shading language                                 and larry made it of course but what's a                                 shading language well it's basically a                                 way to make                                 procedural fun things happen with your                                 objects without relying on texture so                                 what you're seeing here                                 the steampunk teapot or the knotted wood                                 these are not bitmap textures                                 these are pieces of code that generate                                 this                                 appearance that's what you can do with                                 the shader                                 now in classic shader right here you                                 basically have to write one for every                                 render there were lots of different                                 kinds so for instance you had to write                                 something in c plus plus running through                                 a                                 slow c compiler and maybe egypt                                 dll that you can only load when the                                 application starts having your iteration                                 cycle be really slow                                 or if you wrote something in hlsl you                                 would take a                                 different compiler and a different                                 pipeline                                 and maybe for some other render it was                                 still c plus plus but it was                                 different maybe different compiler other                                 dll incompatible dlls completely                                 different syntax of the shader                                 it was kind of a mess and how this                                 applies to max is that                                 you see on the top line that's what you                                 do for the shaders for the max c                                 plus api and the renders such as the                                 built-in scan line                                 or other renders built on that api like                                 v-ray or corona                                 will be served by that approach the                                 middle line is what you would need to do                                 for the nitrous viewport which runs hsl                                 and the bottom line is what you would                                 have to do for                                 renders that were external to macs like                                 arnold or mental ray or whatever                                 so basically you have to write                                 everything four or five times                                 but with osl you write your shader once                                 run it through the really quick osl                                 compiler                                 and it turns into a thing called oso                                 which can be loaded at runtime now                                 waiting for an application                                 a bunch of osls are plugged together in                                 the shading group and sent to llvm which                                 performs                                 magic and turns this into running code                                 and sends to the render                                 but you can also take the osos                                 themselves and information from the                                 shading group and                                 transcode them into some other shading                                 language like for instance hlsl                                 or if you have a third-party renderer                                 plug-in render to your application                                 that you don't have control over but it                                 accepts osl well just send it the osl                                 the renderer does whatever it wants and                                 then it works                                 so in the                                                              again                                 covers the c plus plus shaders the scan                                 library corona                                 the middle line that's the viewport and                                 the bottom line does external render                                 surrenders that translate through scenes                                 and not using the max api like for                                 instance arnold or maybe v-ray in gpu                                 mode                                 or many other examples so one funny                                 thing with oslo in spite of being called                                 a shading language it doesn't actually                                 shade anything                                 normal shading language tends to look                                 like on the left there's loops over                                 lights there's a bunch of ray tracing                                 going on and all this kind of stuff to                                 make                                 a material but in osl you use something                                 known                                 as closures you basically tell the                                 renderer i wouldn't want this much                                 diffuse and this much                                 fong or whatever and the renderer                                 figures this out                                 this has a giant benefit it moves the                                 actual                                 algorithm into the rendering side so if                                 it's a vr engine for instance it can                                 fake glossy reflections with blurry                                 environments                                 it has one giant drawback though the                                 closures are not standardized                                 so if you look at a classic osl shade                                 tree here which contains a bunch of                                 texturing shaders which send quite                                 normal data back and forth like points                                 and colors or whatever                                 they somewhere go into a surface shader                                 and what comes out of the surface shader                                 is a closure and that goes to the                                 renderer                                 the way we solve this in max is that we                                 actually                                 intercede before the surface shader we                                 take colors and this kind of stuff from                                 osl                                 but the surface shader is based on                                 native code                                 so it's basically the autodesk standard                                 surface or as it's known in max the                                 physical material that the render runs                                 natively so we don't support closures                                 for now at least in macs so osl itself                                 is only used for textures not materials                                 the benefit here is of course you have                                 one shader and it runs everywhere real                                 time in the viewport offline on your                                 render farm wherever                                 and we can switch renderers because we                                 do the                                 surface shader bit natively we can                                 switch and get the same appearance                                 we don't care if arnold have different                                 closers than v-ray because we don't use                                 them                                 of course this all gives a very quick                                 development time for shaders                                 and they're easy to deploy it's just a                                 text file                                 so what do we have in max well max has a                                 built-in osl editor                                 syntax highlighting all sorts of things                                 you just hit the compile button                                 and it immediately happens since we have                                 the automatic transcoding for the                                 viewport this actually happens straight                                 in the viewport                                 interactively you don't even need to hit                                 the render button                                 to develop osl shaders in max also                                 we embed the osel source in the scene so                                 when i send the file to you                                 or to a render farm you would never run                                 into the problem of oh i'm missing                                 shader x                                 it's always in there we also build ui                                 automatically for the shaders                                 but we also added the option to build a                                 qt dot ui file you use qt designer                                 and build the user interface and then                                 that user interface can simply be used                                 on the shader we also support dynamic ui                                 in some cases                                 so you can have these action buttons                                 that run scripts that actually                                 modifies the shaders at runtime and for                                 instance in this case adds removes                                 inputs to a gradient shader                                 pretty clever actually the entire                                 prototype                                 for the material x implementation is max                                 that you will see in the material x buff                                 spoiler is completely done via osl so                                                                              update                                                  osl shaders i'm going to show you a                                 couple of those                                 real quick now for instance we have this                                 environment mapping shader that allows                                 ground projections it flattens out the                                 bottom of the environment                                 it looks like objects are standing                                 properly on the ground                                 quite nice we also have this hdri light                                 designer where you can basically add in                                 images of lights and treat them as light                                 cards they basically add to the                                 environment                                 and we can even interactively drag                                 reflections of the light on the surface                                 very nice little feature we have our                                 cool                                 texture look up randomizer which removes                                 all repetitiveness from your textures                                 so this is also very cool so you can use                                 like a single square of gravel and                                 fill a whole gravel road                                 or whatever we have the uber noise                                 which basically is all the noises at the                                 same time                                 much fun and we                                 do texture protection you can project                                 and of course it works interactively in                                 the viewport                                 did i mention that before and of course                                 me being me there's a sushi shader                                 so you want to play with any of this                                 well you can check out the trial version                                 of max of course but you can also join                                 the beta that's where all the fun is                                 you can also check on the max osel                                 github all our shaders are apache                                     and the osl shaders facebook group                                 follow me on twitter if you want and of                                 course                                 i didn't put any links in because if you                                 literally google                                 any of those things the first hit is the                                 right link                                 so let's do that that's all from me zap                                 out                                 bye                                 great uh so with with that uh i'll give                                 a bit of a project update of uh the most                                 important things that have happened                                 uh in our world in the uh in the last                                 year for osl                                 so a big one for us                                 is the transfer of the project to the                                 academy software foundation                                 so very close to the beginning of the                                 year we submitted an application                                 um this was not a project that was                                 unknown                                 uh to the foundation uh and uh                                 and it was uh unanimously accepted                                 with much fanfare um in short order                                 uh i think this was one of the projects                                 that many people would                                 always wish would come on board but what                                 does that mean for                                 us as a project and a community                                 mostly uh extremely good things i think                                 it will really                                 turbo charge our efforts um so                                 the first thing is um you know rather                                 than being                                 a an ad hoc organization                                 where the project was sponsored by one                                 company                                 even though we always took contributions                                 from anyone                                 you know really                                 part of the purpose of going into the                                 foundation                                 is to sort of dispel this idea that it's                                 one                                 it's one company's project and everyone                                 else is just the user                                 we really are very committed to making                                 this um                                 an industry project lots of people                                 depend on this                                 there are many stakeholders and they                                 really should all have a hand                                 in steering it and contributing to it                                 and feeling a joint ownership                                 so that it's not dependent on on just me                                 or just the company that i work for in                                 any way                                 um so we now have a a formal charter                                 and a set of governance rules um you can                                 actually                                 the documents that define both of those                                 are just in the repo they're pretty easy                                 to find and we have a technical security                                 committee                                 the tsc as we call it consists                                 of a number of representatives from many                                 studios and and uh software vendors that                                 uh were the big um the big stakeholders                                 um and uh and we meet uh every second                                 week                                 uh with the zoom call um the meetings                                 are open they're on the aswf calendar                                 uh anyone is welcome to join uh whether                                 it's just as an observer or a                                 participant um                                 uh all are welcome here and there is                                 there's not really any magic to                                 who's on on the tse either um you know                                 basically if                                 if you're a major contributor uh with                                 the track record or your company                                 um you know is a major user or                                 integrator of this technology and you                                 feel like you have an important stake in                                 it                                 um that's that's basically the path to                                 to getting representation here                                 so in in addition to the tsc and sort of                                 formal                                 governance documents we've also switched                                 our mail list                                 away from an old google group and into                                 an aswf managed mail list                                 we will have a new set of contributor                                 license agreements that will                                 get voted on and take effect uh shortly                                 so even if you've been a contributor in                                 the past you might want to sign a new                                 cla when that is done                                 uh coming up soon um it is very similar                                 to the one we used before it's based                                 on apache two there's some really minor                                 differences                                 um but no no new uh food groups here                                 um the the cla that we used when it was                                 in                                 an image works project uh is is very                                 close to                                 identical so hopefully this should just                                 sail through your organizations                                 after that is done and a couple of other                                 you know remaining paperwork issues                                 we will move the project from the                                 imageworks                                 github accounts to the academy software                                 foundation github account                                 uh the old one will be direct so you                                 know don't worry about anything getting                                 lost along the way                                 but we will officially move it to be a                                 direct sibling of the other aswf                                 uh projects um and we are                                 also um you know officially                                 we're in what they call an incubating                                 project and what we really what we                                 really want to do is move to                                 uh graduation to be a you know a fully                                 you know adult project under the aswf                                 and a very                                 important uh part of that is going to be                                 um community diversity we talk about                                 diversity a lot                                 but in this context i'm actually not                                 talking about                                 demographic diversity which of course we                                 also                                 are very committed to but in this case                                 this is the um this is diversity of                                 participants as being um                                 multiple people lots of uh people who                                 know how things work                                 um representatives of many companies so                                 this                                 is the this is the risk mitigation um                                 that is part of the purpose of                                 putting the project into this                                 organization                                 it is making sure that um if something                                 happens to                                 an existing one or a couple of key                                 developers                                 or uh if they're distracted by things                                 that work or if one company that's                                 running a project                                 doesn't have the resources or the                                 interest it is not putting                                 everyone else in the industry who's                                 dependent on the project                                 in some kind of very risky position                                 right it's it's spreading the                                 responsibility and the knowledge                                 and the contributions um across                                 the stakeholders in a more even way so                                 that                                 there's very low risk um from any one                                 person or any                                 one company being able to jeopardize the                                 project and i don't mean through any                                 malicious way i just mean                                 you know people's attentions and                                 abilities to contribute uh                                 wax and win and we don't want that to                                 hold up on all of the many uses                                 another uh big thing that                                 is going on in osl is we have finally                                 are in the middle of a                                              this is long overdue we apologize for                                 that uh                                 we have not had a although we do um                                 minor you know sort of patch                                 on you know fixes minor enhancements                                 sort of spiral releases                                 approximately monthly um the the big                                 changes that introduce new features and                                 can potentially                                 break compatibility um we only do every                                 once in a while and                                 unfortunately we have not had one of                                 those um                                 since the end of                                                       um which means that a lot of great                                 features and improvements that have been                                 locked up                                 in the development branch have not made                                 it into a supported official release                                 for quite some time we've been in beta                                 now                                 since the beginning of the month i just                                 tagged a                                 release candidate last night i hope that                                 that means that there won't be any other                                 changes                                 other than critical bug fixes                                 between now and the beginning of                                 september when we'll call it                                 the official release then that will be                                 the supported release branch                                 um and the older one                                                     be                                 obsolete and will really only be patched                                 if there                                 are emergencies meanwhile                                 in the main development branch that is                                 where um all the big changes continue to                                 happen                                 so highlights of this release from the                                 language standpoint someone who                                 is writing osl shader source code                                 you know probably the biggest                                 convenience factor that that you'll see                                 is that we've uh finally allowed our                                 components of                                 colors and vectors and points and so on                                 to be addressed by the field names like                                 dot x dot y dot z x.y.z.r.g.b and so on                                 um you used to have to use the                                 subscripting notation which still works                                 but a lot of people like this so we                                 added it                                 there have also been a bunch of oslc                                 compilers improvements uh                                 in the handling of polymorphic functions                                 uh polymorphic means                                 there are multiple functions with the                                 same name but they take different                                 arguments                                 and sometimes you can get yourself into                                 cases where                                 the arguments you try to pass could                                 potentially                                 match more than one function signature                                 um or have ambiguity                                 and so there was a big overhaul where we                                 greatly improved the consistency of how                                 we                                 resolve which of the polymorphic                                 functions it chooses for you                                 and greatly improves the error messages                                 that you get if you                                 do something that's ambiguous and it's                                 not sure what to do                                 a few important dependencies have                                 changed                                 i'm only talking about changes in                                 minimum dependencies here                                 of course as compilers and other                                 libraries                                 that we depend on advance we're always                                 making the changes                                 to support the newer versions of those                                 that's not what i'm talking about at the                                 moment                                 this is about things that we're dropping                                 support for so right now                                 um one of the biggest baddest                                 dependencies we have                                 is oodm and so for                                      the lvm versions we're supporting are                                 opm                                 seven through eleven so we've we've                                 added several new versions uh but we've                                 also dropped the old lvm four five and                                 six                                 and primarily that's because they are                                 lacking                                 um some support for features that we are                                 needed                                 needing for some of our forward moving                                 work                                 um also open image i o is a major                                 dependency                                 um yeah i hope this isn't true                                 controversial but we've dropped                                 um the old one point x uh support                                 it's got to be open image io                                        above                                 for this release um that's already two                                 years old so i don't                                 i don't think this should be a big thing                                 for people uh also our build system                                 for quite some time has been dependent                                 on cmake                                 but in this release we bumped the                                 mandatory minimum to                                                                                                      advantage of that                                 to simplify a lot of the build scripts                                 as far as uh internal uh changes that                                 renderer uh authors will appreciate                                 um we have changed the way through the                                 api that you specify                                 shader groups to have thread safe                                 versions so you can have multiple                                 threads setting up                                 shader groups uh in parallel they're not                                 staple anymore                                 uh and we've improved uh as always some                                 of the runtime                                 optimizations so your shaders should run                                 a little faster                                 and we've also improved the jit time so                                 that                                 startup time that we're generating                                 machine curve from                                 from the shaders at one time and                                 it's not really supported features in                                 this version but in along the road here                                 we've made a lot of progress on the both                                 the batch speeding                                 uh and the gpu projects which are talked                                 about                                 shortly um so let's that was recap                                 let's talk a little bit about roadmap in                                 the future                                 so as i just referred to um the two um                                 big transformative uh subprojects that                                 are                                 in progress right now are a batch                                 shading mode                                 based on cpu cmd instructions                                 uh and a gpu shading that are primarily                                 targeted at                                 optics so this this batch shading                                 this is work that is um being led by                                 intel and pixar um the lead author on                                 that is alex wells from intel                                 uh the idea here is that on the old                                 style uh primary interface                                 to osl from the renderer's standpoint of                                 getting it to shape things                                 is you're saving the point of time um                                 and so this is presenting a second                                 interface                                 where you can shade uh collections of um                                 either eight or sixteen points at a time                                 and do so very efficiently by taking                                 advantage of                                 um cindy hardware that can do uh eight                                 or                                                       in one instruction each um on some of                                 the newer                                 uh cpu program                                 and so um you know very very basically                                 um we're in isolated shader only tests                                 we're seeing you know between a                                          sometimes faster than                                     speed up where we're really isolating                                 these particular things in the context                                 of a larger renderer                                 there are many factors that affect                                 performance and of course                                 shading isn't all of rendering time it's                                 just a fraction of that                                 um so like i said this was been                                 implemented already                                 in renderman and using production pixar                                 and so                                 they have been reporting that um                                 in sort of old style render man tests                                 they're seeing                                 about a                                                               using the cindy instructions                                 for a newer uh research initiative they                                 have called the                                 underground xpu look for their toxins                                 they're seeing more like a                                 a                                                                       all told this isn't just isolated                                 the shading time and this is for some                                 plus they were doing fully shaded                                 objects in the real scene um                                 this is uh this is in a private branch                                 um and it was based off a slightly older                                 version of osl so we're in the process                                 of a big project to slowly port the                                 pieces back to the current                                 osl main line and so                                 we've got a lot of it there all the                                 pieces aren't there but it's an ongoing                                 project so                                 certainly the next major release should                                 have this uh fully working                                 and if you uh if you snapchat this or go                                 back and look at the video                                 um there is a a talk                                 that um telling people did about some of                                 the gory technical details if you're                                 really into that stuff                                 uh i recommend it um the other big                                 project is                                 uh is gpu sharing the trend                                 among all of these high-end film                                 renderers is that                                 long last um they're all in various                                 stages                                 of having gpu ports um                                 largely based on nvidia's optics                                 ray tracing toolkit and so that is the                                 primary target right now for for direct                                 gpu support of osl uh so currently we                                 have quite a bit of it working a lot of                                 basic shaders just work                                 with both optics six and seven but there                                 is                                 uh not complete support of everything                                 you can do in oso                                 and in fact there's a lot of work that                                 we still need to do                                 to really support it all well this is an                                 ongoing project                                 so what i would like to do now                                 actually is um switch to adrian and                                 declan they also have some video                                 and material to present that will flesh                                 out a little bit more about the state of                                 this project and in particular                                 um how its current shape                                 in in arnold limited so i'm gonna                                 unshare my screen                                 and adrian's gonna take over                                 um hi everyone i'm irian i'm the arnold                                 colleague at autodesk and i'll be                                 co-presenting with declan also an arnold                                 core developer                                 so we're going to talk about the the                                 status of the                                 osl gpu project and then we're going to                                 talk about                                 what's the status in arnold and and                                 we're going also to talk about like how                                 uh                                 different you integrate sol gpu                                 product project into your renderer and                                 the few caveats that are still there                                 and then we'll end up by showing or                                 showing off the on                                 gpu in a in a demo                                 okay so um osl gpu                                 has initially contributed by nvidia the                                 first pull request was in                                              and and it's been steadily improving                                 uh since and and i really want to thank                                 tim grant from nvidia who contributed                                 the first                                 pull request and has been super active                                 in fixing bugs and adding                                 features                                 so currently osl gpu is fully integrated                                 in current osl in master if you're                                 building yourself from master you simply                                 build with optics                                 it relies on the nvpx                                                  most of the easy native shadows                                 in osl are supported                                 what requires a bit more work if you're                                 interested integrating or sell gpu in                                 your own renderer is all the shared up                                 that are                                 depending on the renderer services or                                 platform dependent like printf and stuff                                 like that                                 um for those you do have to                                 send your own llvm bitcode to your                                 search engine system                                 um so yeah a bit more work but as you                                 all know like gpu programming is harder                                 it's a                                 constant the main limitations                                 are really the absence of dynamic                                 strings and string arrays                                 those require some sort of global logs                                 and memory allocation which never                                 help you although some people would                                 argue that it's not a good idea on cpu                                 either                                 and are actually glad that this                                 limitation exists so                                 it's ongoing debates um and and                                 for the status of the project one major                                 contribution that was added recently is                                 optic seven support like basic optic                                 seven support                                 which is going to be if you all if you                                 know optic seven                                 is the big rewrite of the optics api uh                                 it's completely breaking its new and                                 modern way of using optics and it's                                 really the way to go forward                                 um so arnold as though as you all know                                 probably arnold is a path forcing a                                 prediction                                 renderer arnold is has been                                 fully compatible with osl we have full                                 support for sl not just buttons                                 like we also support closures and and so                                 it was super important when we                                 introduced our gpu that we were also                                 supporting                                 uh osl on the gpu and                                 and we released uh arnold with gpu                                 support and osl gpu support last year at                                 seagraph                                 at first it was like with very basic osl                                 functionality                                 uh and we've been uh adding uh                                 building up on top of what we've we had                                 and adding a support for more and more                                 osl features                                 until last month when we released                                 another                                          uh ray tracing in osl and and attribute                                 queries                                 and then although hand over to declan                                 who is going to talk a bit more about                                 how to uh how we integrated                                 osl gpu into arnold                                 okay so here's a kind of basic overview                                 of how the                                 osl gpu pipeline works uh if you've                                 implemented a uh osl on the cpu and your                                 renderer before this is all going to be                                 quite familiar so you have your osl                                 you create your your shader group which                                 is like a shading network                                 and then you give it to the oso runtime                                 time so runtime                                 jits all this and then produces sub                                 machine code                                 in on the gpu this is in the                                 in the form of a callable program this                                 is a optics feature which is                                 functionally equivalent to                                 a function pointer but it runs on the                                 gpu                                 and then execution time it's very                                 similar to the cpu                                 you set up your shader globals you                                 execute your shader group in this                                 in this in the gpu this will be your                                 coolable program and then you read the                                 outputs                                 after your your program is run                                 so let's have a take a little bit more                                 of a deeper look                                 at what's going on in                                 the compilation so                                 when oso jit compiles your osl code                                 on the gpu we we take some of your                                  render                                  specific shading ops which you                                  pre-compile into                                  llvm bit code then osl turns this all                                  into                                  into its love immediate                                  representation and then hands it to the                                  llvm                                  nv ptx back end which produces ptx                                  which is like a as like a ascii based                                  like um assembly like language for for                                  nvidia cards and then this ptx is given                                  to optics                                  which is then jig compiled again and                                  turned into your callable program that                                  you can then call                                  uh when you run your optics renderer                                  so this is where some of the challenges                                  sort of                                  start uh the generating gpu code can be                                  a lot more expensive than than cpu code                                  there's                                  a for starter there's a one one more                                  level of                                  indirection from where like on the cpu                                  you would just compile your code into                                  like machine code and then run                                  here we go to ptx and then optics and                                  then                                  the call will program we have to compile                                  everything                                  up front we can't do it lazily because                                  everything has to be done before the gpu                                  kernel launches uh gpu ptx takes                                  longer to compile anyway because it more                                  aggressively inlines and optimizes code                                  currently there's a limitation with the                                  nvptx back end where you can't compile                                  stuff in parallel                                  which makes the problem even                                  more difficult as uh we're seeing some                                  shaders                                  hit kind of take minutes to compile and                                  the fact that we can't do this in                                  parallel makes it even longer                                  and it's wrecking sort of time to first                                  pixel and                                  makes ipr pretty painful so                                  we've done some things in in arnold to                                  to kind of mitigate                                  um this this compile time so so how do                                  we do this well                                  the problem is that we have too much                                  llvm bit code                                  like some of this is coming from the oso                                  code that you                                  your user is providing to the renderer                                  and but most of it is coming from                                  shading ops which are being inlined over                                  and over again and you're just producing                                  huge amounts of code                                  so how do we solve this well the simple                                  answer is we want to compile                                  less code so you can do some simple                                  stuff like                                  reduce any redundant code you may have                                  written or                                  try and reduce the amount of templates                                  you're using which generate a lot of                                  code                                  but the main thing well the best thing                                  that we found worked                                  was to take advantage of some of                                  optics's                                  features this callable program and                                  move some of the logic there so these                                  callable programs                                  generated by optics are once they're                                  compiled by optics                                  they're cached to disk and then you                                  don't need to recompile them later you                                  can just                                  call them straight away so what we do is                                  we move                                  the logic from the from osl shade ops                                  into these callable programs                                  and then just call them from the shade                                  ups                                  so this reduces the amount of code                                  that's actually jit compiled                                  by osl significantly so see on the left                                  we would have a traditional kind of osl                                  shader                                  which has many lines of code and this                                  effectively turns into                                  two lines of code there is                                  still an investigation to go on about                                  with this                                  indirection like there's not going to be                                  as much lines of                                  code in lined when you get jit compile                                  so there might be some performance loss                                  but                                  we haven't really found that in our                                  results so far                                  so let's look at the numbers using one                                  of zapp's                                  shaders that he he mentioned earlier                                  from from max                                  so we're using the randomized bitmap                                  shader                                  uh it's got five textuals uh get                                  actually cool and i get texture info                                  call                                  so this used to take about nine and a                                  half seconds                                  and then we've done all our                                  optimizations and it's taking about                                                                                                      times speed up which is great but                                  compared to cpu we're still                                  orders of magnitude away and we need to                                  we need to do better which um                                  we're still working on so other things                                  we can                                  look at improving is there's there's                                  some balance to                                  investigate between llvm and optics                                  because optics is also                                  compiling the code there's some argument                                  that we don't need to jit compile it in                                  llvm                                  because some of these optimizations                                  might be redundant and redone                                  however if you don't do any optimization                                  in llvm then you're not doing any dead                                  code elimination and you're just giving                                  optics heaps and heaps of ptx which it                                  just has to deal with which which would                                  also                                  be a bottleneck eventually                                  so some other caveats that are still                                  sort of open problems                                  is the current attribute and user data                                  binding mechanism                                  isn't very gpu friendly uh it's not                                  it's very flexible in osl but it's still                                  there's a lot of performance that could                                  be improved                                  because at the moment it pretty much                                  just requires a lot of like dictionary                                  lookups                                  a lot of random memory accesses and this                                  is the the same on the gpu                                  uh there's a really interesting proposal                                  by luke emers from                                  animal logic on the osl mailing list                                  which is definitely worth checking out                                  uh basically we just uh you can you                                  write all your                                  known attributes to a predefined                                  memory block as much as you can up front                                  and then                                  when you need these like dynamic lookups                                  because you can't know                                  what you need then we drop back to these                                  this sort of slow dynamic                                  dictionary lookup case so now i have a                                  demo of osl running on the gpu                                  in arnold in in maya using                                  m                                                 so here we have our robot with this                                  simple shading network applied the                                  shading network has                                  an oso shader some arnold shaders and                                  this is all running on the gpu                                  this is a good example of the level of                                  support we had for ursa on the gpu last                                  year                                  so we have some closures we have simple                                  arithmetic we have                                  arnold and osl shader interop and we can                                  run the same thing                                  on the cpu and expect the same result                                  uh this was a good starting point for us                                  for the gpu we could                                  expose a way for users to write custom                                  patterns and stuff but there were some                                  big parts of our cell that were still                                  missing                                  we've implemented over the last year so                                  first off i'm going to show off                                  some attributes which were added in                                      so previously i've added some user data                                  to this mesh                                  to drive the color of each metal plate                                  and we're going to use the oso's get                                  attribute function                                  to grab this color and                                  uh drive the color of our metal shader                                  so it's going to call attribute                                  uh on the attribute                                  metal color                                  i'm gonna go ahead and compile that                                  and now once it is all jitted                                  uh by osl start rendering and                                  see the result so as you can see now the                                  color is being grabbed by the mesh and                                  it's driving the                                  color of our metal so this is looking a                                  bit too new for my liking we kind of                                  want this robot to look a bit more like                                  old and worn out so                                  we're going to do something a bit more                                  complicated so previously i've written                                  this                                  shader that it basically does the same                                  thing as our last shader                                  but it also has a diffuse closure which                                  is being driven by a                                  dirt color and a rust color and then we                                  have some weights                                  applied to both of these so we could for                                  instance up the weight of the                                  dirt and compare the shader again                                  and then once it's jitted we're gonna                                  see basically there's gonna be like a                                  diffuse                                  brown layer across our surface too                                  so this doesn't look too realistic we                                  kind of want to break up our                                  a little bit uh so we're going to use a                                  texture to do this                                  so i have this sort of like grunge                                  texture on my system                                  and we're going to use this to mask                                  i would do it so simply have the                                  get the                                  file path                                  and then we're just going to call osl's                                  texture function                                  on the file shadow again                                  and                                  now we have our texture driving                                  the the weight of the dirt on our                                  texture and we can of course                                  switch back to cpu and we'll get the                                  same result                                  so i also want to add some like rust to                                  this                                  mesh i kind of want it to fall in these                                  sort of corners where the                                  plates of the metal meet and to do that                                  we're going to use a                                  trace call so i previously written this                                  function                                  to do this essentially it just                                  traces rays uh from the shading point                                  around the uh near points of that                                  surface and then just                                  gets the the average angle between the                                  normals and then we normalize that                                  between zero and one                                  so we're just simply gonna call this                                  function                                  uh on our                                  rust weight                                  let me compile our shadow again                                  and then we're going to go ahead and jit                                  this                                  and then because this is using a tracing                                  cool                                  this can take a little bit longer                                  because optics has to recompile the                                  whole shading network                                  for tracing shaders once it's done we'll                                  see the result                                  so as you can see now uh we have                                  some nice sort of like orange sort of                                  rust                                  in the edges where these plates are                                  meeting                                  and our old kind of robot                                  is looking nice and it's done                                  cheers and uh back to you larry                                  great okay let me reshare my screen                                  great uh so just to to really briefly                                  talk about some other                                  uh smaller things that are on our                                  roadmap um                                  we we will be working on uh built-in                                  um two and and four vectors um                                  largely so that we can play a little bit                                  better in the material x                                  uh ecosystem um right now they would                                  have they're                                  implemented as structs and classes in                                  osl but                                  you want to make those into into                                  built-ins and be first-class                                  types as uh                                  as just uh referred to there is a plan                                  of                                  foot to change the way renders explain                                  to osl on what the memory layout                                  is of various things that it needs and                                  so the                                  shaders will then jit in such a way that                                  they just directly pull                                  uh or write to those areas instead of                                  this will eliminate a lot of data                                  shuffling and copying                                  and they've done a similar thing in the                                  osl implementation of animal logic and                                  report                                  a substantial performance improvement                                  from it                                  and then there are a variety of other                                  odds and ends                                  that will get us in full uh compliance                                  for                                  for graduation uh in the foundation um                                  and an endless uh you know array of                                  other small tasks and whatever other                                  features we think of in the future that                                  we want to put in                                  so if you're thinking you know this                                  looks like an interesting project to get                                  involved with                                  there is no shortage of ways to help                                  we need all the hands that we can get                                  look for us on the mail list and                                  subscribe                                  um you know watch the issues on the                                  github                                  there's an open invitation for anyone to                                  join the the technical                                  steering committee meetings and the                                  bottom line is                                  as they like to say in the linux                                  foundation uh this is a duocracy                                  um you get uh you get um capital in this                                  organization                                  um by actually chipping in and uh and                                  making things happen                                  um uh and uh                                  you know we we talked about this but                                  like many of us on the tse and other                                  people                                  involved um this isn't just a you know                                  hobby for us                                  um this is this is a part of our jobs uh                                  and so that's another                                  route to get involved with these things                                  and i can't speak for any of the other                                  companies but i know that                                  that at my place we're actually hiring                                  uh right now for                                  engineers in a variety of ways including                                  for both shader development                                  and uh and renderer development and both                                  of those                                  are areas where one would directly be                                  involved                                  with this project i'd also like to                                  direct you to a couple of other things                                  coming up                                  over the next week or so related to oso                                  at siggraph                                  i encourage you to look at the                                  physically based shading and theory and                                  practice                                  course that is live on wednesday                                  not only is that just a great set of                                  topics generally but                                  um tsc member and imageworks head of                                  shading lee curley is one of the                                  speakers there                                  there's also a really interesting                                  siggraph talk i just watched yesterday                                  on on demand                                  from pixar about their use of open                                  shading language                                  for procedural geometry i thought that                                  was super interesting                                  i didn't know a thing about it until i                                  saw it on the siggraph program                                  which i would like to think speaks for                                  the                                  implementability of such things without                                  having to                                  beg for too much help from us they they                                  did it all and it's uh it's quite a neat                                  uh set of tools um so with that                                  um for the rest of our time                                  um let's just open it to any uh q a or                                  discussion                                  and um yeah how about it                                  let me unshare and we can all switch to                                  our                                  faces again                                  if i can find my mouse                                  there we go                                  okay well thanks guys oh that was great                                  um                                  i am looking at the q a box right here i                                  don't see any q a                                  um uh                                  i've seen any questions lined up yet but                                  feel free don't be shy                                  ask any questions you may have oh so                                  um so okay                                  one question that just came in um how                                  does                                  or uh how does spear v relate to oso                                  and what might we see there in the                                  future                                  uh yeah maybe uh maybe i'll take it                                  though yeah so                                  spuri is another one of these sort of                                  abstracted                                  kind of assembly languages virtually                                  speaking                                  that is the basis of going to a lot of                                  the other                                  non-cuda hardware implementations                                  i think in the materialx talk that we                                  just saw                                  um they were talking about a spear b                                  generator for material x                                  and that unlocks access to um                                  you know vulcan and metal and other such                                  things                                  i think that would be great um i think                                  that um that we could have something                                  like that as an alternate back end                                  uh in much the same way that we have uh                                  cuda and other things as a back end and                                  it may be similar to some of the way                                  that                                  zaps team has done the transcoding to                                  get to                                  um i think it was hlsl max um                                  to have viewport uh visualization of                                  those cell shaders                                  um i i think that that is just                                  a project that is waiting for a champion                                  to step forward                                  and want to both advocate for it                                  and help organize and tackle some of the                                  work but architecturally speaking                                  i think we know where it fits in um                                  and we just lack the hands to do it all                                  at the same time as these major projects                                  unless some other people                                  can help out which we would love to have                                  but but i think that's a really                                  important project i think                                  it is it would be the key to um                                  to more people sort of being able to do                                  the stuff                                  that zap was showing in                                                where you can have like full viewport                                  osl shaders                                  um but without everyone who wants that                                  having to completely re-implement it as                                  x team has done that's a                                  that's a pretty high bar uh and that's                                  sort of the point                                  in my mind of these open source projects                                  is it gives us the ability to do some of                                  these hard tasks once                                  and then have many products and studios                                  and other projects use them without                                  having to                                  redo them from the ground up                                  yeah great so                                  what gpu ci capabilities would help osl                                  um i mean i can take a stab maybe                                  um by saying that i think the the main                                  thing                                  uh like larry alluded to in the talk the                                  main thing we're developing is                                  an optics cuda back end and                                  that specifically ties to                                  at the minimum requires some kind of                                  cuda capable hardware                                  and ideally something with rtx support                                  as well                                  um so that's that's kind of what we're                                  hoping to see there                                  um yeah i i know                                  through tangential association with the                                  open colorio project                                  that they are working on getting                                  um gpu ci because they they have                                  a cpu path and a gpu path they're a                                  little different because they are their                                  gpu                                  is based on um opengl functionality um                                  but                                  in the course of trying to make this                                  work they're you know basically finding                                  ways to work                                  into their ci the provisioning of um                                  you know amazon cloud instances                                  that have the gpus that they need and so                                  this is another one of those benefits of                                  being part of the aswf                                  is we're going to wait for them to                                  figure some of those details out                                  and then draft off of everything they've                                  learned to                                  set those up github we're using github                                  actions ci for for our ci right now                                  on their roadmap they mention gpus                                  um i it's not clear exactly when those                                  will come                                  if we if they'll be kind of in time for                                  us or if we have to                                  do more of this you know provisioning                                  the instances that we need                                  is kind of a special route but um                                  if someone knows about how this stuff                                  works and wants to tackle it it would be                                  hugely helpful like we've already had                                  problems where                                  we've accidentally checked things in                                  from                                  someone who didn't thoroughly test the                                  gpu path and it broke it in some sort of                                  way                                  being even if you're not working on the                                  gpu stuff itself                                  just knowing that as you submit the pull                                  requests that it's going through ci                                  tests and you know                                  it's not breaking anything on the gpu                                  path is just                                  it would be a huge step forward                                  yeah um so one more question                                  um how does material x relate to osl                                  i can can we start to answer that                                  question uh                                  so material x is essentially a higher                                  level than osl                                  material x will describe like whole                                  materials                                  and shading networks and and and so it's                                  kind of a very                                  high level xml based representation now                                  osl will be a back end for                                  whatever shaders are generated by meta                                  lx                                  for for example if you load the metalx                                  file in arnold right now                                  it will rely on the osl code gen                                  to render the material as specified                                  though they they they overlap slightly                                  in some ways but in general like                                  metallics is higher level than than also                                  i think i think perhaps of osl as being                                  the primary um thing that                                  materialx is targeting as it generates                                  you know things that will execute the                                  materialized descriptions so we're                                  we're an important part of their                                  ecosystem and vice versa                                  but we are we're kind of adjacent to                                  each other                                  um rather than either one really trying                                  to do what the other does but they                                  they play well together and we want to                                  further that relationship                                  we're pretty short on time so for                                  whatever questions we don't get to                                  point people to the slack channel but                                  before                                  or if we have a minute maybe you can say                                  something about                                  any other gpu back-ends                                  sorry sorry was that a question for me                                  yeah other gpu back-ends other gpu back                                  ends uh                                  yeah i think we're waiting for people to                                  suggest what they should be                                  uh the main debut effort we have going                                  right now the primary target is cuda and                                  optics                                  um it would be great to have more it                                  just                                  it requires a champion                                  um okay so i think that's                                  a wrap on the questions we have so far                                  like i said um                                  if you have more questions feel free to                                  meet us on slack                                  and i think um                                  i think that covers it for for today                                  thank you all for joining                                  us yeah thank you
YouTube URL: https://www.youtube.com/watch?v=WL9FBwV0-3E


