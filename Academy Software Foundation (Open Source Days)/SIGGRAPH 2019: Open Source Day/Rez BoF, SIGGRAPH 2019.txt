Title: Rez BoF, SIGGRAPH 2019
Publication date: 2019-08-08
Playlist: SIGGRAPH 2019: Open Source Day
Description: 
	An overview of how Method Studios integrates Rez into their pipeline, followed by an overview of outstanding feature development and a conversation about the future goals of the project. Part of Open Source Day at SIGGRAPH 2019, hosted by Academy Software Foundation.

Speakers: 
Allan Johns, Method Studios
Stephen Mackenzie, Method Studios
Captions: 
	                              hi everyone welcome to the res ball for                                                                                                    sections so the first part is going to                               be an overview of how we've integrated                               res at Method studios the second part is                               going to be a roadmap for development so                               I was going to talk about what's been                               done and what's coming up in the next                               year and the last third will be a Q&A so                                let's get started so I'm Alan Jones I'm                                a lead-pipe dev at method LA and I wrote                                res and my colleague he's doing the                                first part of the presentation is Steve                                McKenzie he's Alf hourly pipe dev at                                method New York and he builds lots of                                stuff and Reza fires lots of stuff thank                                you to the Academy for making this                                happen and specifically for sponsoring                                me to make this just this talk possible                                first of all I just want to start with a                                bit of a poll so who's using raise at                                their studio hands up and so from those                                people to what extent are you using it                                so a across most all of production                                partially like maybe one department or                                maybe just for building and testing or                                kind of beta phase all right and and                                who's already reasonably familiar with                                res ok all right so very briefly a                                history of the project it started life                                at a SEO in Sydney called dr. D it was                                called dat config at the time it was                                open sourced and renamed in                                         first version was really just the                                dependency solver in written in Python                                with some bash stuck around it to get it                                to be useful in a practical way there                                was then a version to rewrite that it                                was pretty much a complete rewrite that                                turned into a full API or written in                                Python cross-platform multiple shell                                support and a python-based package                                definition                                format which change things so as you can                                see there's there's a bit of a                                reasonable spike of activity just                                recently as well so that's good I'll now                                hand it over to Stephen to talk about                                how we integrated it method                                [Applause]                                everybody so so first of all it's useful                                to ask the problem of like just what                                does production even want out of their                                situation generally speaking we have a                                variety of needs things like I need to                                use five different versions of Maya or                                five different versions of nuke we also                                commonly come across the issue of how we                                migrate operating systems in a sane way                                where we're stepping from you know a                                bunt to descent OS or even sub versions                                between like sent OS seven point two                                three four kind of ways of versioning                                forward you know in a way that does not                                break the pipeline while people are                                working on in a way we can do migrations                                in a stepwise manner and as well as just                                to like essentially flexibility around                                our runtime environments so that when                                developers inevitably screw something up                                we are able to quickly adapt to that                                situation it's also becoming more common                                that we want to be able to plug on new                                renderers or different situations                                workflow types into different                                environments and quickly and rapidly                                assemble a different workflow for a                                certain kind of production you know I've                                got a feature that needs to use render                                man I've got a commercial I'm using                                redshift whatever being able to split                                environments up and sort of add on                                optional functionalities onto your DCC                                dynamically it's always been really                                helpful for us and of course production                                wants to be able to have low impact                                events whenever things are screwed up so                                being able to have an artist to be able                                to do something as simple as work as if                                it were yesterday before pipelines                                screwed something up then you know                                that's a that's a level of adaptation                                that we can present to the user in a way                                that actually functions you know in a                                way that is completely dynamic to them                                and just to be able to like optionally                                provide different plugins like I was                                talking about before like not every nuke                                that runs needs to use every license to                                 plug in in your facility and maybe you                                 want to be able to have compositors                                 dynamically add something on                                 so essentially runtime management                                 just a little timeline for context about                                 how method used rez for a long time sort                                 of -                                                                    site suites where every single suite                                 basically had a folder of context that                                 would get up                                 constantly somewhere around                                             that range we got to a point where it                                 became obvious we needed to sort of have                                 show sweets on top of site sweets so                                 that we could have a essentially like a                                 show could override a specific tool set                                 and then what I'm going to talk about a                                 little bit in more detail soon is                                 something we've cobbled together called                                 and I'm config and in production and                                 that's got some implications down the                                 line eventually what this has given us                                 is an ability to give artists                                 essentially a command that is running                                 their version of Maya or nuke or                                 whatever but is dynamically resolving                                 what they want at the exact time they                                 ask for it so there's no more staleness                                 in terms of an artist opening something                                 up and you know having a shell open for                                 like a week and ending up like in some                                 bad environment where maybe some service                                 has been migrated and things are not                                 functioning quite right so it's to avoid                                 a lot of those issues and then I'll just                                 very briefly outline a model we're                                 moving to called our software deployment                                 system and that'll just have a slide at                                 the end just for one thing so generally                                 this is kind of our artist experience at                                 the simplest we want it to be as simple                                 as set your shot and you know be able to                                 seee to something convenient and run                                 your application at it's more                                 complicated we are exposing two artists                                 a time flag with the ability to                                 essentially turn on or off the                                 visibility of packages that have been                                 released so as you know res packages                                 have a timestamp associated with them so                                 our set shot system can essentially                                 inform res as to the - - time flag                                 passed along so if you walk in in the                                 morning on Tuesday when we've updated a                                 whole bunch of packages the artists                                 experience is a break nooks not                                 launching hey what's going on ok let me                                 just set it to yesterday until the                                 pipeline guys come in at their leisurely                                 hour and start actually fixing things                                 it's also possible for us later on I'll                                 get into this unstable previous table                                 bit but essentially we have a concept                                 called package views which maps to a                                 channel or a service managed package                                 path that is taking the raw package path                                 of the studio and translating it into a                                 specific sort of channel of packages                                 that are being timed out in a specific                                 way                                 and the artist has the ability to patch                                 on existing tools additional reza jizz                                 into their environment dynamically                                 because it's happening at tool launch                                 time and you'll notice the new                                         in rez contexts from long time ago you                                 are able to suffix your tools so you're                                 able to present as many versions of nuke                                 or Maya to the facility as you want we                                 usually take the step of making a                                 certain default present so in our case                                 like nuke                                                             have to backpedal for some reason you                                 can you can run the nuke                                                on the flip side as a developer it's                                 very helpful to be able to test in the                                 production environment with your extra                                 stuff so we have some flags that                                 essentially are again dynamically adding                                 this in but are allowing things like                                 local packages to the developer having                                 sane ways of just quickly printing out                                 the resolved package lists to help debug                                 and at the at the very bottom you'll see                                 sort of typical things I find myself                                 doing when debugging or resolve pulling                                 out the the DC C's requests and starting                                 to graph things find the conflicts be                                 able to mess around with things a little                                 bit that way so just a brief overview                                 for people that aren't terribly exposed                                 to res all that much a context is                                 basically just a request that has been                                 resolved and baked off and so the way                                 our even current course suite is handled                                 is essentially just a system of having a                                 folder full of contexts and you're able                                 to use the - - fetch command on a                                 context to see what would update so                                 that's a fantastic preview device to say                                 what am I about to expose to my facility                                 before I've gone and done it so that's                                 kind of a critical step when we're                                 making sure we you know aren't it might                                 be we're sending up a warning to                                 production when like some very large new                                 version of things with many dependencies                                 is about to come in it's like okay guys                                 just so you know like let us know if                                 there's going to be problems or whatever                                 and then the concept of a suite is                                 basically as I said a whole bunch of                                 contexts that are in a folder and                                 essentially just wrapping that fetch                                 functionality we can do something like                                 just quickly query what all of these                                 contexts are going to expose to the                                 facility and simply as as shown at the                                 top there where you're creating a                                 context just to take                                 request and bake it out into a new one                                 that's really all you're doing with this                                 - - update flag - basically actually                                 take that fetched context and bake it                                 back into the resolve there's a little                                 script somewhere called soma that has                                 some rich history add method that                                 essentially is wrapping even that                                 process to say all right I'm going to                                 create a version subfolder that takes                                 copies of all the contexts and starts to                                 bake out the tools present in the                                 contexts out to a bin path in that                                 structure so essentially what we end up                                 with down here at the bottom is                                 assembling putting two sim links one                                 pointing to current one point to latest                                 and so which we can manipulate if we                                 have to and just kind of sim like one                                 thing to the other if or backpedal                                 aversion and what you exposed to your                                 path is this path to your current or                                 latest depending on what your what your                                 attitude is /bin and that's where all                                 your tools live so that's just kind of                                 like a super simple way to take a                                 facility that doesn't use res yet and                                 just kind of put on a very basic level                                 of of management around a very core set                                 of tools that are being constantly used                                 with method we sort of came to the                                 conclusion that managing individual show                                 Suites for literally hundreds of shows                                 was untenable so you know we handle                                 commercials we handle features so while                                 I'm in Vancouver I might have six ten                                 fifteen shows in New York I have a new                                 one every week so it's important to be                                 able to not just not just be able to                                 manage context and like one singular way                                 but also be able to manage them                                 dynamically so that's we're gonna head                                 so we have something called M config and                                 production and fig when you hear me                                 saying M config and fig it's really the                                 same thing but the MM config is the                                 disk-based version of this and fig as                                 the is the newer service based model                                 that we're currently a middle of                                 migrating on - so just same concept but                                 once completely restful and all of that                                 and then the other is just based on like                                 grabbing the ml files off of disk so and                                 a little look at sort of simplified                                 infrastructure of this we really want to                                 expose to our workstations and our                                 render farm the exact same environments                                 so it's kind of important to just take a                                 quick peek at how your overall                                 infrastructure is and make sure that                                 this                                 something that works and very                                 importantly for optimisation reasons                                 it's important to expose a memcache D                                 server to res because we're able to                                 catch the resolves and you'll see later                                 on some metrics about exactly how much                                 the caching is helping us out and at the                                 bottom here I just want to really stress                                 that we've got some replication of our                                 files in our database stuff to other                                 sites so what's really neat about the                                 system is I'm changing something in New                                 York and that same exact definition is                                 changing in Vancouver and LA and                                 everywhere else at the same exact time                                 so my entire facility is being upgraded                                 at just by changing one file in one                                 location here's a look at the sort of                                 illustrating the EM production and M                                 config system so what what M production                                 is is abstracting sort of methods                                 configuration of file system you know in                                 a way so that I provide shards of                                 requirements to res in a way that I'm                                 able to associate with the in production                                 entity that my facility or sorry that my                                 artist is using so they're on a specific                                 shot on a specific job and a specific                                 task and production is kind of looking                                 at the various places we can figure this                                 data and in concert with fig which is                                 actually performing the the merge of                                 this information is presenting me with a                                 final request that I've made so every                                 single one of our you know at the                                 facility level at the show level of the                                 sequence and shot level we're able to                                 completely override any given request                                 for any given tool that's being                                 presented to the pipeline so at the end                                 of the day what's happening is again the                                 artist is running their new plus peeking                                 tools and so it's merged together that                                 request from our file system or from our                                 service side and presenting essentially                                 to res one flattened request that is the                                 result of the entity that they are in                                 and the way that has found the fragments                                 of Y amel to merge together so res the                                 resolve happens the tool runs and it's                                 kind of also important to note that you                                 know there's environment variables                                 available to you in res that are going                                 to pass into your DCC s that you can use                                 and to guide the way that your your                                 render farm will eventually handle                                 things so we're passing in our timestamp                                 of when the user did their MSS and                                 passing in the request that's been used                                 to the render farm so that the render                                 farm can run exactly with the same code                                 that the that the artist was using when                                 they launched their application so                                 there's no schism if someone launches a                                 new app new a new new release of                                 something it's not going to get into                                 what the artist is using this is just                                 kind of a little overview of just like                                 the simplicity of this configuration so                                 an example profile that is exposing                                 these requirements and tools over on the                                 left to saying well I needed a version                                 of open image i/o a need a version open                                 Colorado here are the tools that are                                 exposed the views yeah Mel is how we is                                 how we specify the suffix Inge prefixing                                 of any given set of tools so you'll see                                 that the Maya set of stuff has a default                                 of my                                                                    and everything else has done prefix so                                 you can access those individually also                                 super helpfully until the software                                 deployment system we had is is being                                 moved to you we've used a system of                                 locks that uses a cron syntax which is                                 essentially driving the res - tee time                                 flag so that new packages are only                                 allowed into a resolve at a specific                                 cron like time so for us the one method                                 we found to be super helpful was that on                                 Tuesdays Wednesdays and Thursdays at                                                                                                      allowed in from the previous cycle                                 because things break on Friday I have to                                 get renders out for the weekend and I                                 need Monday to fix whatever went wrong                                 on the weekend and then from there we                                 also just have a little like a shard of                                 this common Amal which adds a request to                                 every single profile that is in our                                 system whatsoever so we can put common                                 things there or common constraints like                                 beak requirements on something important                                 like our review system that needs to be                                 a common version across an entire                                 production or cost an entire facility                                 and just a brief note about the software                                 deployment system we're moving to so we                                 have a method of taking service based a                                 service based approach to essentially                                 maintaining a raw unstable pre-release                                 and stable set of packages where all the                                 res builds                                 against a common raw set of packages                                 that are just the base res repository                                 and then we essentially construct dummy                                 packages that are copies or sim links to                                 those packages in a new in a new                                 location point artists as far as their                                 package path is to a specific package                                 view or channel or we have how you want                                 to think about it and just kind of                                 migrate this forward giving pipeline the                                 ability to promote and demote from these                                 various channels so that by the time                                 something gets to pre-release and into                                 stable it's already been vetted by a few                                 key users that are identified TDS as                                 people that are going to be working with                                 this so a couple of metrics that are                                 just kind of nice to look at and                                 interesting to think about when thinking                                 about the volume of resolves that might                                 happen as we just said our farm is                                 performing a res resolve it's not                                 passing along an environment it's                                 passing along the recipe to rebuild the                                 environment so sorry can I go into a                                 couple things here so on average we've                                 got                                                             maximally                                                            less than our profiles as on average                                 it's                                                                    our Houdini profiles the packages in our                                 resolves generally speaking our resolves                                 have averaged out at about a hundred and                                 nine packages per resolve and the                                 highest one I could find was my ax at                                 three hundred and thirty which is as                                 you'll see in the next slide                                 approximately a third of our ecosystem                                 so our my is a little bit heavy this is                                 the breakdown of how many packages we                                 have built internally and externally and                                 you'll see that a huge portion of our                                 external packages are individually                                 packaged pip packages res is more than                                 happy to handle this level of volume and                                 granularity of course there are plenty                                 of times where it's not worth packaging                                 all the stuff individually there are                                 sometimes meta packages where someone's                                 taken ten pip requirements and just like                                 shoved it into one package and calling                                 it a day because sometimes you just need                                 to get it done so this is our this is                                 the config system metrics that are worth                                 seeing it's worth keeping in mind that                                 fig is not just fielding res                                 configuration request is also fielding                                 requests for every single package ax                                 bowl configuration attribute in our                                 system                                 so and this isn't even in full                                 production yet it's in it's in mostly in                                 production in Vancouver right now and so                                 that for example this is Vancouver                                 metrics fielding                                                   requests every this is you know in a                                 week                                 here's a                                                            metrics and a                                                          of the same same area where you can sort                                 of see the heartbeat of our studio as                                 people come online in mornings this is                                 showing that in one site at a time we're                                 peaking at about                                                       definitely a result of the render farm                                 ability but we're able to handle it just                                 fine and that comes up in the next                                 little bit where we start looking at how                                 resolves are cached and how how long                                 uncashed resolves take this particular                                 graph is histograms of the maximum                                 resolved time for an uncashed resolved                                 could be as high as                                                    facility it's very rare but it does                                 happen like even if one resolved took a                                 long time                                 so imagine what's happening if your cash                                 and resolves the first person to run                                 nuke for the day is gonna experience a                                 little lag time but then that resolve is                                 now cached because that's when the                                 package is changed and now everything                                 every other user of that package is                                 essentially using the same resolve on                                 average though every uncashed resolve is                                 three to seven seconds depending on this                                 is a week worth of metric and and you'll                                 see like the min for a given day is                                 usually like zero to one because there's                                 just results that are blindingly fast                                 and here's a little bit of histogram of                                 the ratio of caching so you'll see on                                 the right with the pie chart that we're                                 achieving a little bit this fluctuates a                                 little bit but generally no more than                                    of resolves are uncashed in a given time                                 and that's taking to account that                                 artists are doing things like patching                                 on a specific plugin or altering things                                 a little bit slightly and you'll see at                                 the very bottom that we're pulling                                                                                                         which are uncashed so generally speaking                                 this is a tremendous benefit and you'll                                 remember back here when I said there was                                 a max of                                                                we're seeing is that in this week only                                                                             took more than                                                          more than                                                             number of slow resolves is extremely                                 small and probably that was because                                 someone was resolving something that was                                 uncashed on a bogged down host that was                                 not doing something terribly happy so                                 just bear worth it's keeping in mind and                                 on the left is just a histogram of how                                 many the how many seconds each resolve                                 each each resolve is taken                                 we're also doing a lot of metrics based                                 gathering so here we've got a breakdown                                 of which packages were used in resolves                                 at that point in time and we treat this                                 very granular lis we can even do it by                                 package version so we're able to sort of                                 keep eyeballs on asking questions like                                 how far are we to migrating on to a new                                 version of something what's the what's                                 our ability to be able to introspect                                 into artists are actually using look at                                 versions of things that have problems                                 associate this with other metrics in our                                 systems that are you know logging errors                                 and seeing how we can move forward in                                 our ecosystems in order to push you know                                 push further into you know say Python                                   usage and that kind of thing and Louis                                 Python to                                                          [Music]                                 failed Sol's in a week                                               million it's pretty rare so it usually                                 just developers so just really good to                                 have this level of confidence in your                                 system that generally speaking there                                 aren't a ton of artists trying to run a                                 tool and failing and just a little fun                                 that's our maya graph just couldn't help                                 myself                                 next up so just a couple quick bits of                                 advice things we found useful in general                                 we find it super helpful to externalize                                 our licensing details to some kind of                                 like oh it's like the package needs the                                 license but you don't need to read the                                 license from the package you can read                                 the license from some file outside so                                 it's good to manage that separately                                 stand not like a sign license servers                                 into packages and then have to release                                 something arbitrarily just kind of                                 little silly we find people it's common                                 to see that as a first pattern that                                 people use and they're like aha why                                 can't I change my package on the fly and                                 then expect everything to work well as                                 well as adaptive packages here's a sort                                 of reactionary approach that a package                                 is taking to the presence of other                                 packages in the resolved                                 so it can be useful to do things like                                 check if if your resolve has Maya in it                                 and react accordingly presents certain                                 plugin paths in that way you can present                                 just one variant or one mega variant of                                 something that has a lot of components                                 if if need be and simply add on features                                 in a way and that's something that is                                 going to get expounded on more with                                 Alan's work we often get asked things                                 about like what about configuration                                 management what about details that have                                 to do with say you want to alter                                 something in a task-based way that                                 somehow ties together with a package and                                 the way our system works it's not always                                 transparent to be able to do that but                                 one thing that we found useful is res                                 has a in its commands section has a                                 command directive that can be used that                                 injects things into the context SH file                                 that's generated to produce the resolve                                 for the user we've used a tool that                                 basically at that point in time will                                 look at the environment and react                                 accordingly and do things essentially                                 abstracting our tasks system and using                                 the exact same configuration methodology                                 as the EM production stuff where I can                                 set context of show shot whatever all                                 the stuff and sort of drill down and say                                 if my ax is in there is in the                                 environment and if the task is animation                                 maybe I want a disable OCIO and it turns                                 it off so it's I find it I find it wise                                 to try to find a way to abstract what                                 you might consider to be configuration                                 management for yourself problems we                                 experience we get mutual exclusivity                                 issues where a good example would be for                                 USD we build a katana variant and a Maya                                 variant because we haven't quite broken                                 it down into sub packages yet and then                                 essentially we might have a resolve that                                 actually has both Maya and katana in the                                 environment for some other exotic                                 reasons and res is going to pick one and                                 can't be using two variants at the same                                 time so that's the problem for us                                 occasionally thankfully I think we have                                 a solution for that on the way it's also                                 hard to set up build chains that do                                 things in a useful way when you want to                                 clarify whether something is a release                                 build or a debug build past that to see                                 make be able to build multiple build                                 chains one that's your debug build chain                                 and once you're really                                 they'll chain you can kind of do it with                                 like sort of dummy packages that you use                                 to alter your resolve but it gets come                                 it gets cumbersome and extends file                                 paths a little too long for comfort and                                 so on similarly lack of negations and                                 variance is definitely an issue for us                                 right now where I may want to exclude                                 everything in a specific variant and                                 it's just not really possible to do that                                 because file paths don't like                                 exclamation marks all that well or our                                 shells don't at least configuration                                 management                                 I was ready going into that a little bit                                 so I'll skip over that and it's a common                                 complaint with our system engineers that                                 storing all of our packages on central                                 file servers is a huge burden of i/o and                                 querying these packages and pulling data                                 together actually contributes to the                                 overall load of the system we've started                                 looking at localization strategies I'm                                 led to believe I think that's that's                                 something that a couple studios are                                 dealing with they're localizing packages                                 to their hosts will have something to                                 say about that common thing is kind of                                 the question of how far do you take this                                 where do you where do you stop when                                 you're trying to resolve dependencies                                 when you're trying to make packages I                                 we've definitely made the mistake of                                 going too far at times where like we've                                 gone so far back in system level                                 dependencies that it became unwieldy on                                 its own so it's good to like have talks                                 with your system engineers and think                                 about your use cases and how much                                 exactly you need to represent in                                 dependencies what do you actually need                                 multiple versions of in production and                                 what's provided by your operating system                                 in a really clean way and yeah we're                                 looking at how to do some performance                                 testing with rest with the res tests                                 themselves I don't mean res tests in the                                 packages and once in a while like                                 something weird happens with our resolve                                 and it's kind of hard to debug when a                                 backpedal happens when some new                                 requirement is added and it backpedals                                 your entire resolve like a huge distance                                 back to some really older set of stuff                                 it'd be nice to have something that                                 could detect situations like that and                                 with that I'll pass it over down                                 thanks Steven okay so now I'm going to                                 talk about where we're going in terms of                                 development with res so we've introduced                                 this new idea on the github project of                                 reps of stolen the idea of peps there is                                 enhancement proposals they're kind of                                 analogous to epochs in agile so they'll                                 describe a sub project within the res                                 project and attempt to break it down                                 into the tasks required to implement it                                 and they're labeled as rep in the issues                                 in github we have three reps at the                                 moment we've got one based on some                                 enhancements to res tests which I won't                                 cover right right now it's a fairly                                 minor point rep oo                                                       I'll talk a lot about and that's getting                                 us to the point where well I'll explain                                 it in a second but it's called recipe                                 repositories and repo                                                   about now is something called package                                 and context localization so localized                                 means removing the need for external                                 resources and by that I mean when you                                 create a context by running rows em what                                 doing what if you want to do there's                                 currently two external resources you                                 typically need you need to access                                 memcache D in order to pull down the                                 entire package definition to get the                                 commands to configure the environment                                 and you also typically need access over                                 NFS to get to the to the package                                 installation and as Stephan already                                 mentioned that can be problematic and                                 put a lot of load on the filer                                 so why localized there's two reasons one                                 as I just mentioned is to speed things                                 up with regard to performance and stop                                 feeding the filer so much but the other                                 reason is because you might want some                                 sort of standalone installation                                 particularly for services for example so                                 this is what happens currently you                                 create a context and in a context it                                 contains these things called variant                                 handles just small metadata dictionaries                                 that give enough information to be able                                 to fetch the entire package definition                                 when you source one of those contexts it                                 will then create the resolving                                 environment the process running inside                                 that environment is typically in a hit                                 and a first in order to pull down Python                                 Python sauce files so by localizing both                                 of those things you remove any                                 externalities so the package definitions                                 themselves end up completely embedded                                 into the context which just results in a                                 larger JSON file basically and the                                 process you run will end up on hitting                                 package payloads that are actually on                                 the local disk instead to give you                                 fine-grained control                                 there'll be a new tool that that does                                 this that allows you to do this and I've                                 got some examples here so you may have                                 an existing context and you want to then                                 populate a localized package cache with                                 its variants so you'd be able to do that                                 you'd be able to just introspect the the                                 cache directly you'll be able to create                                 a context and explicitly associate that                                 context with a given cache                                 you might want to modify an existing                                 cache and associate it with a different                                 with the different cache context saurian                                 as I said the different cache or you                                 might want to source an existing context                                 and override where the cache it had                                 already specified if any so those are                                 just some examples this is a more                                 interesting case where you want to                                 create a context that's entirely                                 standalone so this example would create                                 a directory that contains both the                                 context and all of the variants of that                                 context refers to you would then                                 literally be able to just copy that onto                                 a server or into a into an image or                                 something into a containerized situation                                 and have something running completely                                 standalone the only prerequisite you                                 need at that point is that res would                                 have to be installed on the target                                 system ok now on to the main the main                                 point which is something called res                                 repositories a recipe repository sorry                                 so one of the biggest goals from res                                 from the start has been to be able to                                 install packages from public                                 repositories much in the same way that                                 something like pip can right now studios                                 do spend a lot of time having to build                                 their own packages and what we what we                                 call Reza Phi packages as a result                                 there's not really any sharing of                                 package                                 munitions across studios or all the                                 build code associated with those and                                 there's no standardization either in                                 terms of what what particular variants                                 might get created for a given package                                 for example and so we're going to                                 introduce a new tool called res install                                 and that will install packages and                                 package and its dependencies and also                                 give you control over over the built                                 configurations as well I'm going to show                                 you how that is theoretically going to                                 work so you can already write reusable                                 package definitions that build the party                                 software to an extent it's helped a lot                                 by the fact that package definition                                 files right now quite programmatic you                                 have early and late down requirements up                                 earlier late bound attributes that'll a                                 to define something like the the                                 requires section of a package as a                                 function that's very very useful but we                                 need to we need to build on that so the                                 problems at the moment is no dependency                                 tracking res build which is the tool                                 used to build a package or res install                                 doesn't determine and and build and                                 install dependencies and shouldn't it's                                 never been its job there's no build                                 configuration support in the sense that                                 you can hack around but it's it's quite                                 difficult to say well I want to build a                                 debug version of this package and                                 release it as such and they have some                                 other package or person consume that                                 package but specifying that they want                                 that they want to put that particular                                 build type so here's an example of what                                 res install will probably look like and                                 I've just used open behavior here as an                                 example so you'd pull down what's going                                 to be called a well it's a recipe and                                 recipes just contains standard package                                 definitions exactly the same as you'd                                 have when you build your package to                                 apply it's no different but they reside                                 on a different search path which is                                 defined by Reza's recipes path rather                                 than res packages path to inform res                                 that they haven't been built yet and so                                 it should expect some some things in                                 that in that some build in that package                                 definition that it wouldn't see in                                 released packages and then it's going to                                 go through and find some packages that                                 need to be built and do that in the                                 right order and then perhaps some that                                 don't because they're already installed                                 at the studio                                 so yeah packet I already explained I                                 think of what it's just now packages can                                 exist in recipe repositories so their                                 standard package definitions but what                                 they do is they programmatically                                 construct a single variant to be                                 installed and that will make it a bit                                 more sense in a second what it then does                                 in order to determine what packages what                                 what dependencies need to be built it                                 actually will perform a standard resolve                                 across both the rest of your                                 repositories on whatever existing                                 package repositories you have and then                                 when you get the result of that result                                 and you go up in a reverse dependency                                 order that actually tells you what                                 packages need to be built in order to                                 satisfy all the requirements so here's                                 what it looks like graphically res                                 install so we want to install a it                                 doesn't resolve the graph there shows                                 you the resulting result and the green                                 ones are the ones that have come from                                 recipe repositories and so their                                 packages that haven't been built yet so                                 we then just traverse the graph from                                 bottom to top and we build DNA in this                                 case so package features are a crucial                                 part of this this doesn't exist yet it's                                 a way for package to describe their                                 properties and so for example you might                                 model the build mode of the package that                                 you know it was built as a debugger                                 release you describe that as a package                                 which would be some information that's                                 that's now available a runtime from that                                 from that package definition features                                 are listed in invariants much like                                 normal requirements and both users or                                 packages that request packages can                                 request them by their features and I'll                                 show you how that works in a second if a                                 package feature is asked for then only                                 packages with that feature can can be                                 returned can match the request and                                 they're based on something else that                                 I'll explain in a second called the                                 ephemeral packages so here's an example                                 let's say you want version                                              of some packaged food but you want it to                                 be built in debug mode sorry you want to                                 retrieve the version of food that was                                 built in debug mode this is what that                                 will look like so resin through one plus                                 which are gonna be very familiar with                                 but then you have this kind of odd                                 syntax here which I'll explain shortly                                 and this is actually requesting                                 feature the feature in this case is the                                 fact that food was built in debug mode                                 so ephemeral packages are packages that                                 don't exist which sounds odd but they'll                                 be very useful they start with a dot                                 currently packages can't start with a                                 dot so that works out nicely because I                                 won't be any clashing they behave the                                 same way as standard packages but they                                 never resolve to a version because they                                 don't exist and it turns out there's a                                 few different ways we can use these that                                 the turn out to be quite useful one of                                 them is to model a requirement of a                                 package that is a bit of an abstract                                 concept it's not actually a package and                                 an example that you could that you could                                 use to describe this is the platform in                                 the current platform so for example for                                 Linux it's it's an ephemeral thing you                                 don't necessarily need to configure                                 something in the environment or if like                                 that depending on what your setup is it                                 turns out also that you can use                                 ephemeral as a general way to pass                                 information to packages so that they can                                 change their definitions or change their                                 behavior and when they use this way they                                 called a package option but there's                                 nothing special about them besides that                                 and the last point is that they also                                 form the basis for package features so                                 here's an example of a package option we                                 have some package here and what it's                                 going to do is it's going to check to                                 see if an ephemeral is in the request                                 called food CLI and if it falls within                                 the version range                                                       it's going to take that to mean well I                                 shouldn't make my my binaries available                                 on path and then a user can can simply                                 put that option in and you won't get                                 those command-line tools bare mind also                                 that packages would also be able to do                                 this like everything else with requests                                 in res there's no difference between                                 what you can do as somebody using res m                                 and what a package can do when it's                                 requesting other packages                                 so that's all it's all quite homogeneous                                 so using a femorals as the basis for                                 package options and features actually                                 avoids a lot of extra complexity there's                                 a lot of the behavior of packages that                                 match the behavior of what we want                                 see in these cases and it just means                                 just means a lot of extra stuff in the                                 code doesn't need to be added so just                                 avoids complexity but it does also look                                 a bit weird so we're gonna support some                                 use some taxes so you can see here slash                                 that's a going to specify an option and                                 a colon will specify a feature so here's                                 a full example recipe it's open BTB i've                                 made it really really simple for for                                 display purposes and i'll just run                                 through it now so get debug is just a                                 utility function that would get stripped                                 when the package is released it's just                                 figuring out if the debug feature has                                 been asked for and says it's a                                        accordingly and defaults to zero I mean                                 you generally want to release pack a non                                 debug package the crucial part of this                                 is the variance section which is                                 dynamically defining the requirements of                                  this package as a response to a res                                  install request so it has a bunch of                                  packages in the in the list which are                                  standard so it always requires boost                                  styling based on open XR and avoids a                                  particular version openexr but then what                                  it does as well is it checks what the                                  debug feature should be and then sets                                  that feature in to its own requirements                                  in response to the request from the user                                  whose run res install so it's adapting                                  to what's been asked for by the by the                                  Installer and lastly just as a point                                  here I've shown just a example scenario                                  where it may be true that if open VB is                                  getting built in debug mode and also                                  wants access to a debug build a boost                                  that's just by way of example so ok I've                                  already explained packages dynamic the                                  construct barriers to respond to the                                  request a problem that this raises is                                  that you're gonna get really weird long                                  variants that are not necessarily POSIX                                  compliant or will probably screw up                                  build systems and shells so we have                                  something new these are called hashed                                  variants hash variants already                                  implemented and they do away with the                                  full very installation path which up                                  till now has been based on the                                  requirements of the variant and instead                                  they they based on a hash                                  now what you see here is not a hash it's                                  something else called a short link a                                  short link is just another process in                                  the release that goes through and um                                  just creates a very short version which                                  is assembling to the hash and does it in                                  a way that's not gonna it's not going to                                  cause some conflicts within that already                                  or any release package to do that you                                  just add this new attribute called hash                                  variance you said it's true and of your                                  uncle we have a new type of requirements                                  expansion so so what this is oftentimes                                  I'll have a package that before it has                                  been built is compatible with some large                                  number of versions of a package but then                                  after it's built and compiled and linked                                  against whether that is then that turns                                  into into a hardened requirement and so                                  you can currently express that but it                                  doesn't work too well as a few problems                                  with it the syntax is too limiting and                                  that expansion happens too early so I'm                                  planning on replacing that completely                                  with a new syntax and a new system the                                  slash slash is something called a                                  request directive it'll be it'll                                  indicate that what's there is some kind                                  of a modifier that alters the the                                  request at some point provides                                  functionality is something that has been                                  thought about for a long time                                  it's a specialization of package                                  features and it's a way for a package to                                  tell other packages that it also                                  provides another package the classic                                  case being the DCC that comes with                                  Python what it will do is if the native                                  version of that package is also present                                  in a resolve it will effectively                                  override it and will remove that                                  packages ability to configure that so                                  configure the environment and here we                                  have an example of Maya expressing two                                  other packages that it actually already                                  provides provides Python this one's                                  really interesting so Steven mentioned                                  already that we have issues where there                                  are cases where we can't reliably                                  guarantee that a particular variant of                                  the package will be chosen even though                                  the rules the                                  that do choose a very a completely                                  deterministic it can be very hard to                                  tell why your Maya variant wasn't chosen                                  and instead you're Houdini one was or                                  your variant that actually doesn't have                                  a TCC was chosen so the way that we can                                  solve that which is kind of neat is to                                  consider all the requirements of a                                  package as being features unto                                  themselves and because now we can                                  actually request package features we now                                  have a way to say explicitly well I want                                  a version of foo in this example shown                                  here that actually requires Houdini and                                  so now you've struck that down to only                                  be able to select those variants that                                  match that request the end goal of all                                  this is to be able to install anything                                  easily from the VFX reference platform                                  which is where we really like to get to                                  sometime next year                                  with full control over the build                                  configurations that you would need in                                  order to do that and one example of how                                  this would be used in practices that                                  we'd also have a VFX reference platform                                  package which just acts as like a bundle                                  it would just be a big list of weak weak                                  package references that they're just                                  limited versions and here's an example                                  of how you have your dres install USD                                  specifically saying that you want to                                  install the maya plugin for USD the -                                  end is something i haven't really                                  touched on but it's basically something                                  that will be added to res build as well                                  and res release mr. sway of narrowing                                  the build environment so in this case                                  your by adding the effects reference                                  platform to the environment to the build                                  environment sorry you will in effect be                                  limiting the versions of USD to whatever                                  the reference platform is specified so                                  you don't have to know what that version                                  is you just you just reference the                                  reference platform loads more detail                                  about everything I've just talked about                                  are available on the wrap                                                 the github projects and the links there                                  it seemed easy to find other stuff were                                  in the middle of pythons report at the                                  moment it's coming along it should be                                  ready I think reasonably soon Python                                    will be supported at the same time you                                  will not be forced to use Python                                         that version of res is released                                  the Installer Perez itself has been                                  updated I won't get into details but                                  it's it's modernized now and it's all                                  going fine whole bunch of Windows fixes                                  a new shell was added PowerShell support                                  was added there's been a lot of work                                  done on respit which is the integration                                  tool that allows us to install pip and                                  and a pip package converted to res                                  packages lots and lots and lots of your                                  packages can be reliably installed this                                  way it also more correctly generates the                                  matching variants and a res pocket                                  analogous to the PIP package so for                                  example if ap package is pure Python                                  then it won't variant on the platform                                  architecture and operating system for                                  example it does some more things of that                                  though and takes into account things in                                  pip called environment markers which if                                  you're a Python packaging geek you'll                                  know about people extras aren't                                  supported yet because they don't fit                                  into the model res at the moment but                                  when package features are there they                                  will and it should be fairly trivial to                                  support them in that point in time                                  further work just very briefly further                                  things that we can do resolver                                  optimizations that will have to come I                                  suspect that as a result of this kind of                                  stuff which i've just talked about that                                  you would tend to see more packages and                                  more variants on the go in any given                                  solve and so it's possible but that will                                  cut that will cause some solve x to blow                                  out further fortunately I think there's                                  a lot of room for optimization still so                                  that's good in order to optimize you                                  need to know how long souls take and                                  it's very difficult to do that right now                                  because they can vary a lot from one                                  cell to another so we really need a                                  benchmarking suite and I'd quite like to                                  take our suite of packages from method                                  and anonymize it and put it into one big                                  repo and have a whole bunch of results                                  you can graph out the results and then                                  you can really see what differences                                  occur short of python pass so long                                  Python path is a big deal I won't get                                  into now cuz running out of time but                                  we've got that in mind and better                                  environment variable management and I'm                                  going to stop there cos we need to                                  hasn't your name governance is changing                                  I've been B DFL and it would be good to                                  change that because it's just it's                                  becoming too much work and I really want                                  to keep                                  project moving board a small group of                                  collaborators have actually been added                                  as of now but I am open to a new                                  governance model in the coming year                                  anyone who wants to get involved please                                  - there's                                                               already so that probably means there's                                  loads more thank you to all contributors                                  any questions                                  [Applause]                                  [Music]
YouTube URL: https://www.youtube.com/watch?v=y5VSPeeqJbM


