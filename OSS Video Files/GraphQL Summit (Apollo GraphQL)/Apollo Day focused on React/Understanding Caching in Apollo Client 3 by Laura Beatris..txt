Title: Understanding Caching in Apollo Client 3 by Laura Beatris.
Publication date: 2020-11-18
Playlist: Apollo Day focused on React
Description: 
	Join Laura Beatris in exploring how to use cache management with Apollo Client 3.

Resources:
Checkout the Apollo docs - Apollo docs at at https://www.apollographql.com/docs/
Explore Cache configuration - https://www.apollographql.com/docs/react/caching/cache-configuration/
Explore Cache normalization - https://www.apollographql.com/docs/android/essentials/normalized-cache/
Captions: 
	00:00:00,210 --> 00:00:06,469
[Music]

00:00:07,040 --> 00:00:12,160
hi guys today i would like to talk about

00:00:09,519 --> 00:00:12,719
cash management on apollo client 3. but

00:00:12,160 --> 00:00:15,200
before

00:00:12,719 --> 00:00:16,880
diving into details about cashy

00:00:15,200 --> 00:00:20,560
specifically on graphql

00:00:16,880 --> 00:00:24,160
or apollo we need to take a step back

00:00:20,560 --> 00:00:26,960
and see how cash works on the web

00:00:24,160 --> 00:00:28,720
in general what is cash and why it is

00:00:26,960 --> 00:00:31,840
necessary

00:00:28,720 --> 00:00:32,239
cash data is is stored on your computer

00:00:31,840 --> 00:00:35,520
or

00:00:32,239 --> 00:00:38,160
phone when you browse the internet and

00:00:35,520 --> 00:00:40,480
it it's really important because it

00:00:38,160 --> 00:00:44,000
decreases the response time of an

00:00:40,480 --> 00:00:46,559
uh web application and by

00:00:44,000 --> 00:00:48,320
doing that it also avoids unnecessary

00:00:46,559 --> 00:00:51,120
questions to the server

00:00:48,320 --> 00:00:52,030
which reduce the bandwidth and benefits

00:00:51,120 --> 00:00:53,600
the user

00:00:52,030 --> 00:00:56,960
[Music]

00:00:53,600 --> 00:01:00,079
but there are two kind of caches

00:00:56,960 --> 00:01:03,520
which is the server side caching usually

00:01:00,079 --> 00:01:06,479
is done by using nosql databases

00:01:03,520 --> 00:01:07,360
such redis then you can save the data on

00:01:06,479 --> 00:01:11,840
the database

00:01:07,360 --> 00:01:13,920
and retrieve it later on you can also uh

00:01:11,840 --> 00:01:15,840
perform client-side caching there's

00:01:13,920 --> 00:01:17,200
there's many ways to do client-side

00:01:15,840 --> 00:01:19,680
caching but

00:01:17,200 --> 00:01:20,799
one approach that have been used since

00:01:19,680 --> 00:01:23,759
the 19s

00:01:20,799 --> 00:01:25,200
it's client-side caching through http

00:01:23,759 --> 00:01:29,680
protocols

00:01:25,200 --> 00:01:32,960
and we use this we use the http headers

00:01:29,680 --> 00:01:36,000
uh can be less modified cache control

00:01:32,960 --> 00:01:38,400
etc and by

00:01:36,000 --> 00:01:40,000
using dhcp headers you control your

00:01:38,400 --> 00:01:42,960
client-side caching

00:01:40,000 --> 00:01:45,119
we have control over the browser

00:01:42,960 --> 00:01:47,680
requesters from the server

00:01:45,119 --> 00:01:49,119
but i won't get into uh details about

00:01:47,680 --> 00:01:51,680
client-side caching

00:01:49,119 --> 00:01:52,640
in general on the web but if you want to

00:01:51,680 --> 00:01:55,360
take a look

00:01:52,640 --> 00:01:56,479
and get more details about it i will put

00:01:55,360 --> 00:02:00,799
a link right here

00:01:56,479 --> 00:02:00,799
about the w3

00:02:00,960 --> 00:02:04,960
where you can get to know atp caching

00:02:03,920 --> 00:02:08,160
better

00:02:04,960 --> 00:02:08,800
and client cache local storage session

00:02:08,160 --> 00:02:11,680
storage

00:02:08,800 --> 00:02:12,720
all of these things have one things cl

00:02:11,680 --> 00:02:16,239
in common

00:02:12,720 --> 00:02:18,239
that is persistent data on the web

00:02:16,239 --> 00:02:19,440
so by persisting data although on the

00:02:18,239 --> 00:02:22,480
web we

00:02:19,440 --> 00:02:24,800
improve the user

00:02:22,480 --> 00:02:25,680
we improve the user experience because

00:02:24,800 --> 00:02:28,319
the user

00:02:25,680 --> 00:02:30,800
doesn't have to reload the page the user

00:02:28,319 --> 00:02:33,120
doesn't have to lose data when

00:02:30,800 --> 00:02:34,400
going back to a step on a form for

00:02:33,120 --> 00:02:36,879
example

00:02:34,400 --> 00:02:37,599
and it's really important to proceed on

00:02:36,879 --> 00:02:39,710
the web

00:02:37,599 --> 00:02:41,840
in order to improve the user experience

00:02:39,710 --> 00:02:44,959
[Music]

00:02:41,840 --> 00:02:48,560
but dealing with cash on graphql isn't

00:02:44,959 --> 00:02:51,200
easy and um the reasons for it

00:02:48,560 --> 00:02:52,400
is that graphql api it's a single

00:02:51,200 --> 00:02:54,560
endpoint

00:02:52,400 --> 00:02:56,560
and it's also hard to predict the

00:02:54,560 --> 00:02:58,239
response because of the flexibility of

00:02:56,560 --> 00:03:01,120
the fields

00:02:58,239 --> 00:03:01,440
graphql clients and bodies to the server

00:03:01,120 --> 00:03:04,640
with

00:03:01,440 --> 00:03:06,879
post method instead of get methods

00:03:04,640 --> 00:03:09,440
and apollo client provides an

00:03:06,879 --> 00:03:12,400
abstraction layer to manage cache

00:03:09,440 --> 00:03:14,159
which makes our life easier because we

00:03:12,400 --> 00:03:17,760
don't have to

00:03:14,159 --> 00:03:19,440
manage the cache data directly there's a

00:03:17,760 --> 00:03:21,840
layer of abstraction there

00:03:19,440 --> 00:03:22,720
of the cache api that apollo client

00:03:21,840 --> 00:03:24,560
exposed

00:03:22,720 --> 00:03:25,920
and we just need to learn how to deal

00:03:24,560 --> 00:03:29,040
with this api

00:03:25,920 --> 00:03:32,080
but what happens when

00:03:29,040 --> 00:03:32,640
you learn how uh how to deal with the

00:03:32,080 --> 00:03:35,599
api

00:03:32,640 --> 00:03:38,000
but but not on the right way you end up

00:03:35,599 --> 00:03:40,239
having unnecessary network requests

00:03:38,000 --> 00:03:43,280
because maybe there is some data

00:03:40,239 --> 00:03:46,319
that you're not caching the right way

00:03:43,280 --> 00:03:48,799
or you're using the wrong patch policy

00:03:46,319 --> 00:03:49,680
and leading to a bodywax a better user

00:03:48,799 --> 00:03:53,360
experience

00:03:49,680 --> 00:03:54,319
we'll talk more later about the fetch

00:03:53,360 --> 00:03:58,000
policies

00:03:54,319 --> 00:04:00,000
what each one does or maybe you are

00:03:58,000 --> 00:04:02,640
catching the wrong entities because

00:04:00,000 --> 00:04:03,360
there are kind of entities that doesn't

00:04:02,640 --> 00:04:05,840
need to be

00:04:03,360 --> 00:04:07,599
cached at all and you don't know how to

00:04:05,840 --> 00:04:10,720
disable the cache for

00:04:07,599 --> 00:04:12,799
these specific types

00:04:10,720 --> 00:04:14,480
but in this talk we are going to cover

00:04:12,799 --> 00:04:17,519
the following topics

00:04:14,480 --> 00:04:19,120
related to cash management on ac3

00:04:17,519 --> 00:04:22,079
we're going to talk about cash

00:04:19,120 --> 00:04:24,880
normalization fetch policies

00:04:22,079 --> 00:04:26,560
type policies food policies and how to

00:04:24,880 --> 00:04:28,639
perform pagination

00:04:26,560 --> 00:04:31,840
through food policies cache

00:04:28,639 --> 00:04:34,639
normalization is really important on ac3

00:04:31,840 --> 00:04:36,960
ac3 uses in-memory caching which is a

00:04:34,639 --> 00:04:39,280
normalized data store

00:04:36,960 --> 00:04:40,000
but how it is the process to normalize

00:04:39,280 --> 00:04:43,280
the cache

00:04:40,000 --> 00:04:46,240
data and what is normalization at all

00:04:43,280 --> 00:04:47,759
data normalization isn't something just

00:04:46,240 --> 00:04:51,600
related to apollo or

00:04:47,759 --> 00:04:54,639
graphql and uh data normalization

00:04:51,600 --> 00:04:58,639
is a technique very um important

00:04:54,639 --> 00:05:02,160
on data based on relational databases

00:04:58,639 --> 00:05:05,360
and it is really important

00:05:02,160 --> 00:05:06,240
in order to reduce data redundance and

00:05:05,360 --> 00:05:09,520
also

00:05:06,240 --> 00:05:12,400
to improve data integrity

00:05:09,520 --> 00:05:14,000
so as you can see on this image we have

00:05:12,400 --> 00:05:17,360
two tables

00:05:14,000 --> 00:05:19,360
and instead of duplicating the registers

00:05:17,360 --> 00:05:23,039
of the tables we are just

00:05:19,360 --> 00:05:26,080
referencing them by unique identifiers

00:05:23,039 --> 00:05:28,800
so in data in databases

00:05:26,080 --> 00:05:31,039
we usually have primary keys for a keys

00:05:28,800 --> 00:05:34,560
or other kinds of constraints

00:05:31,039 --> 00:05:37,440
that make the registers be unique

00:05:34,560 --> 00:05:38,400
and on apollo the normalization

00:05:37,440 --> 00:05:41,600
algorithm

00:05:38,400 --> 00:05:45,280
also creates unique identifiers for

00:05:41,600 --> 00:05:48,639
each response object but there are some

00:05:45,280 --> 00:05:51,600
steps which is the response data

00:05:48,639 --> 00:05:52,000
is splitted in different objects and

00:05:51,600 --> 00:05:54,560
each

00:05:52,000 --> 00:05:56,560
object receive an unique image fire

00:05:54,560 --> 00:05:59,280
which is calculated by the id

00:05:56,560 --> 00:06:00,639
field and the type name field the

00:05:59,280 --> 00:06:04,080
normalized items

00:06:00,639 --> 00:06:06,960
are started in a flat object

00:06:04,080 --> 00:06:09,600
and then one way to secure other kind of

00:06:06,960 --> 00:06:11,280
graphical operations such as notation in

00:06:09,600 --> 00:06:14,400
order to edit

00:06:11,280 --> 00:06:18,240
um a specific item the fields

00:06:14,400 --> 00:06:21,199
of those objects of the the new data

00:06:18,240 --> 00:06:22,319
coming to the response will be

00:06:21,199 --> 00:06:25,360
identified

00:06:22,319 --> 00:06:28,319
as already stored on the caching

00:06:25,360 --> 00:06:29,039
by a unique fire and those fields will

00:06:28,319 --> 00:06:31,680
be merged

00:06:29,039 --> 00:06:32,160
and the cache will be updated but in

00:06:31,680 --> 00:06:35,280
order

00:06:32,160 --> 00:06:38,720
to understand better the process of

00:06:35,280 --> 00:06:41,680
normalization i would show images

00:06:38,720 --> 00:06:43,680
of the of the process of the algorithm

00:06:41,680 --> 00:06:44,960
and i also recommend you guys to check

00:06:43,680 --> 00:06:46,639
it out this

00:06:44,960 --> 00:06:48,000
article the specifying cache

00:06:46,639 --> 00:06:50,560
normalization on the

00:06:48,000 --> 00:06:52,160
apollo graphql blog it's really good and

00:06:50,560 --> 00:06:55,360
i think we'll clarify

00:06:52,160 --> 00:06:58,639
your mind about the

00:06:55,360 --> 00:07:00,720
cache normalization algorithm on apollo

00:06:58,639 --> 00:07:02,479
but the first step is when you're

00:07:00,720 --> 00:07:04,720
executing the carry

00:07:02,479 --> 00:07:06,560
apollo client will execute the carry and

00:07:04,720 --> 00:07:07,280
the apollo server will return the

00:07:06,560 --> 00:07:10,639
response

00:07:07,280 --> 00:07:11,360
data the response data will start to be

00:07:10,639 --> 00:07:14,000
normalized

00:07:11,360 --> 00:07:14,800
by apollo client by splitting the

00:07:14,000 --> 00:07:17,759
response

00:07:14,800 --> 00:07:19,520
data in individual objects so by having

00:07:17,759 --> 00:07:24,240
these individual objects

00:07:19,520 --> 00:07:27,440
we are able to assign unique inspires

00:07:24,240 --> 00:07:29,520
for each one of these objects

00:07:27,440 --> 00:07:31,039
because we don't want to have redundance

00:07:29,520 --> 00:07:34,240
we also want to reference

00:07:31,039 --> 00:07:35,599
these objects in order to merge the the

00:07:34,240 --> 00:07:38,319
cache data

00:07:35,599 --> 00:07:39,919
to predate the cache data by default

00:07:38,319 --> 00:07:42,800
apollo uses the id

00:07:39,919 --> 00:07:45,440
field and the type name what i have but

00:07:42,800 --> 00:07:48,000
what happens if your entity doesn't have

00:07:45,440 --> 00:07:50,319
an id field but instead you have other

00:07:48,000 --> 00:07:54,400
kinds of fields that are unique

00:07:50,319 --> 00:07:57,919
apollo exposes an api

00:07:54,400 --> 00:07:59,840
in order to customize the unique inspire

00:07:57,919 --> 00:08:02,400
of a certain type

00:07:59,840 --> 00:08:03,440
by setting a side policy which we are

00:08:02,400 --> 00:08:07,039
going to talk more

00:08:03,440 --> 00:08:09,680
later about type policies but

00:08:07,039 --> 00:08:10,560
by setting a type policy of an of a

00:08:09,680 --> 00:08:12,400
certain type

00:08:10,560 --> 00:08:14,160
here we are showing an example of the

00:08:12,400 --> 00:08:16,639
user type

00:08:14,160 --> 00:08:17,440
and setting the key fields property we

00:08:16,639 --> 00:08:20,479
are able to

00:08:17,440 --> 00:08:24,240
change the keys that are using

00:08:20,479 --> 00:08:26,800
the fields that are used in order to

00:08:24,240 --> 00:08:27,520
assign the uniqueness buyer for those

00:08:26,800 --> 00:08:29,919
normalized

00:08:27,520 --> 00:08:32,159
items and here specifically on this

00:08:29,919 --> 00:08:35,839
example i'm saying that the user

00:08:32,159 --> 00:08:38,399
has a unique field called email and

00:08:35,839 --> 00:08:39,680
that will be used plus the type name in

00:08:38,399 --> 00:08:42,240
order to

00:08:39,680 --> 00:08:44,880
assign and calculate the unique

00:08:42,240 --> 00:08:44,880
identifier

00:08:45,040 --> 00:08:49,680
so it's really important to don't forget

00:08:47,360 --> 00:08:50,480
to fetch these unique identifiers of a

00:08:49,680 --> 00:08:52,800
type

00:08:50,480 --> 00:08:55,440
because by not fetching the unique fires

00:08:52,800 --> 00:08:56,720
of a type the response data won't be

00:08:55,440 --> 00:08:59,920
normalized

00:08:56,720 --> 00:09:03,920
and the cache won't be correctly started

00:08:59,920 --> 00:09:05,600
and by accessing then later on we are

00:09:03,920 --> 00:09:08,959
able to update the cache

00:09:05,600 --> 00:09:12,160
so all of the normalization process

00:09:08,959 --> 00:09:15,360
will go wrong if you forget to fetch

00:09:12,160 --> 00:09:18,959
these ideas these unique inspires

00:09:15,360 --> 00:09:20,000
because we are we are going to be able

00:09:18,959 --> 00:09:23,120
to access them

00:09:20,000 --> 00:09:25,920
on the store the the process of merging

00:09:23,120 --> 00:09:29,040
the field zone won't work as expected

00:09:25,920 --> 00:09:29,839
and after normalizing these items we are

00:09:29,040 --> 00:09:33,040
able

00:09:29,839 --> 00:09:36,320
to put these items on a flattened

00:09:33,040 --> 00:09:37,760
data structure and these items will be

00:09:36,320 --> 00:09:40,640
started on the hood

00:09:37,760 --> 00:09:43,279
and the keys will be the unique

00:09:40,640 --> 00:09:46,320
identifiers that we mentioned before

00:09:43,279 --> 00:09:49,360
but this is a since it's a plan

00:09:46,320 --> 00:09:51,760
structure the objects are accessible

00:09:49,360 --> 00:09:52,800
through their unique identifiers for

00:09:51,760 --> 00:09:56,399
example

00:09:52,800 --> 00:09:59,120
here i'm just simply how easy is for

00:09:56,399 --> 00:10:01,760
apollo behind the scenes access these

00:09:59,120 --> 00:10:03,760
normalized items and update the cache

00:10:01,760 --> 00:10:05,519
because imagine that this uniqueness

00:10:03,760 --> 00:10:08,560
fires are just

00:10:05,519 --> 00:10:11,839
strings and they are mapped on these

00:10:08,560 --> 00:10:12,560
flat data structures so now what apollo

00:10:11,839 --> 00:10:14,800
needs to do

00:10:12,560 --> 00:10:16,320
is access this flat object using this

00:10:14,800 --> 00:10:19,440
uniqueness fire

00:10:16,320 --> 00:10:20,560
and it updates the the field emerges

00:10:19,440 --> 00:10:23,519
fields

00:10:20,560 --> 00:10:24,480
so it's really fast and besides storing

00:10:23,519 --> 00:10:28,000
the normalized

00:10:24,480 --> 00:10:30,640
items the normalized objects the carries

00:10:28,000 --> 00:10:32,560
are also started in order to maintain

00:10:30,640 --> 00:10:35,120
the least items order

00:10:32,560 --> 00:10:36,959
so when you execute the carry for the

00:10:35,120 --> 00:10:40,079
first time

00:10:36,959 --> 00:10:43,200
the data will come from the server

00:10:40,079 --> 00:10:44,880
and will be saved on the cache but the

00:10:43,200 --> 00:10:47,680
list of items

00:10:44,880 --> 00:10:49,279
came with a specific order from the

00:10:47,680 --> 00:10:51,839
backhand right

00:10:49,279 --> 00:10:52,880
and at the second time that we execute

00:10:51,839 --> 00:10:55,120
the same carry

00:10:52,880 --> 00:10:56,560
we want the same order we don't want to

00:10:55,120 --> 00:10:59,279
use the order

00:10:56,560 --> 00:11:00,240
so that's why apollo also saves the

00:10:59,279 --> 00:11:03,760
carry

00:11:00,240 --> 00:11:04,560
and he have received the unique image

00:11:03,760 --> 00:11:07,760
fires

00:11:04,560 --> 00:11:10,720
in order to not repeat the normalized

00:11:07,760 --> 00:11:11,200
items and have data redundants but let's

00:11:10,720 --> 00:11:13,839
dive

00:11:11,200 --> 00:11:14,640
into cash policies in order to

00:11:13,839 --> 00:11:17,839
understand

00:11:14,640 --> 00:11:21,279
how to use the cached data and

00:11:17,839 --> 00:11:25,519
how to how apollo performs

00:11:21,279 --> 00:11:28,640
all the logic with by doing

00:11:25,519 --> 00:11:32,160
network requests in returning the cash

00:11:28,640 --> 00:11:33,680
data what are the types of cash policies

00:11:32,160 --> 00:11:36,959
that can affect

00:11:33,680 --> 00:11:37,920
the the process of cashing and returning

00:11:36,959 --> 00:11:41,920
the data

00:11:37,920 --> 00:11:43,920
to the client so basically the default

00:11:41,920 --> 00:11:49,279
cash policy from apollo is

00:11:43,920 --> 00:11:53,120
cashy first and the cash first fetch

00:11:49,279 --> 00:11:56,240
fetch policy executes the carry

00:11:53,120 --> 00:11:58,320
and checks for the cashier data so if

00:11:56,240 --> 00:11:59,040
the data is sketched it is going to be

00:11:58,320 --> 00:12:02,800
returned

00:11:59,040 --> 00:12:04,959
directly avoiding the network requests

00:12:02,800 --> 00:12:06,399
if there is no cached data apollo will

00:12:04,959 --> 00:12:09,200
make a network request

00:12:06,399 --> 00:12:10,959
in order to get response data and save

00:12:09,200 --> 00:12:14,000
it on the cache

00:12:10,959 --> 00:12:16,639
so the user at the first time

00:12:14,000 --> 00:12:17,279
will probably see a loading spinner but

00:12:16,639 --> 00:12:20,160
after

00:12:17,279 --> 00:12:21,040
the response data comes the data will be

00:12:20,160 --> 00:12:23,760
normalized

00:12:21,040 --> 00:12:26,320
and save it on the cache so at the first

00:12:23,760 --> 00:12:29,600
time that the user

00:12:26,320 --> 00:12:31,760
opened the page and executed the request

00:12:29,600 --> 00:12:33,519
the data will come right away from the

00:12:31,760 --> 00:12:36,320
cache we also have

00:12:33,519 --> 00:12:37,279
another cache policy called call it

00:12:36,320 --> 00:12:40,480
cache

00:12:37,279 --> 00:12:44,240
and network it is really recommended

00:12:40,480 --> 00:12:47,120
for data which is frequently updated

00:12:44,240 --> 00:12:48,320
for example social media applications

00:12:47,120 --> 00:12:50,560
where the users

00:12:48,320 --> 00:12:51,680
are interacting every time and the data

00:12:50,560 --> 00:12:54,959
is changing

00:12:51,680 --> 00:12:56,800
every time so this cache policy will

00:12:54,959 --> 00:12:59,839
always return the up-to-date

00:12:56,800 --> 00:13:03,760
data and by executing the carry

00:12:59,839 --> 00:13:06,639
it checks for if there is cached data

00:13:03,760 --> 00:13:07,200
if there is cached data it's going to be

00:13:06,639 --> 00:13:10,639
returned

00:13:07,200 --> 00:13:11,760
directly but even if there is cached

00:13:10,639 --> 00:13:14,560
data or not

00:13:11,760 --> 00:13:17,040
apollo will make the network request in

00:13:14,560 --> 00:13:20,079
order to get the up-to-date data

00:13:17,040 --> 00:13:21,279
and then we will update the cache so the

00:13:20,079 --> 00:13:24,639
key point here

00:13:21,279 --> 00:13:26,959
is that the user will always see the

00:13:24,639 --> 00:13:29,920
cached data for the first time

00:13:26,959 --> 00:13:31,279
he the user won't have to wait but after

00:13:29,920 --> 00:13:34,160
some milliseconds

00:13:31,279 --> 00:13:35,040
while the network request is being done

00:13:34,160 --> 00:13:37,760
apollo will

00:13:35,040 --> 00:13:38,480
update the cache so the user will see

00:13:37,760 --> 00:13:40,880
the data

00:13:38,480 --> 00:13:42,560
changing but without having to see a

00:13:40,880 --> 00:13:45,760
loading spinner

00:13:42,560 --> 00:13:49,279
and there's another one called

00:13:45,760 --> 00:13:51,360
network only this policy will never

00:13:49,279 --> 00:13:53,920
return up-to-date data

00:13:51,360 --> 00:13:55,279
because the network requests will always

00:13:53,920 --> 00:13:57,519
be executed

00:13:55,279 --> 00:13:59,279
and the data will be saved on the cash

00:13:57,519 --> 00:14:01,600
store at the same time

00:13:59,279 --> 00:14:03,920
he executes the carry and make the

00:14:01,600 --> 00:14:08,240
nitric requests

00:14:03,920 --> 00:14:11,920
but it also save the data on the cache

00:14:08,240 --> 00:14:15,040
so the key point here also is that

00:14:11,920 --> 00:14:16,880
it doesn't return the cache of data but

00:14:15,040 --> 00:14:18,800
it saves the data

00:14:16,880 --> 00:14:21,120
of the response on the cache because

00:14:18,800 --> 00:14:23,279
maybe you

00:14:21,120 --> 00:14:26,320
ain't going to use it the cached data on

00:14:23,279 --> 00:14:28,160
a specific carry of the type

00:14:26,320 --> 00:14:30,399
but let's say that you create another

00:14:28,160 --> 00:14:33,199
carry and you want to

00:14:30,399 --> 00:14:34,880
grab the cash data instead once you use

00:14:33,199 --> 00:14:37,760
one fetch policy here

00:14:34,880 --> 00:14:39,440
another fetch policy which grabs the

00:14:37,760 --> 00:14:41,680
data from the cash

00:14:39,440 --> 00:14:42,560
so it makes the network request anyway

00:14:41,680 --> 00:14:45,839
but

00:14:42,560 --> 00:14:49,760
this patch policy also saves on the

00:14:45,839 --> 00:14:53,199
cash the data maybe if it doesn't use it

00:14:49,760 --> 00:14:57,120
at all and the next one

00:14:53,199 --> 00:14:58,639
is no cash no cash it's really similar

00:14:57,120 --> 00:15:00,079
to network only

00:14:58,639 --> 00:15:03,199
but it doesn't save the date of the

00:15:00,079 --> 00:15:05,600
cache so you can reuse it later on

00:15:03,199 --> 00:15:07,839
it's going to be pretty straightforward

00:15:05,600 --> 00:15:11,040
it's just going to execute the carry

00:15:07,839 --> 00:15:13,120
make the network request and server the

00:15:11,040 --> 00:15:15,600
server responds with the data

00:15:13,120 --> 00:15:16,320
but there are some situations that we

00:15:15,600 --> 00:15:19,440
have to

00:15:16,320 --> 00:15:20,959
update the cache right and apollo will

00:15:19,440 --> 00:15:24,160
update the credit cache

00:15:20,959 --> 00:15:26,480
automatically if the mutation response

00:15:24,160 --> 00:15:28,399
always return the new data with the same

00:15:26,480 --> 00:15:30,000
type as the carry object

00:15:28,399 --> 00:15:33,279
in order to retrieve the unique

00:15:30,000 --> 00:15:37,199
identifier and merge the cached data

00:15:33,279 --> 00:15:40,160
so there are situations when the cache

00:15:37,199 --> 00:15:42,399
is going to be automatically updated

00:15:40,160 --> 00:15:45,120
by editing a single entity and returning

00:15:42,399 --> 00:15:47,600
the same time on the response object

00:15:45,120 --> 00:15:48,880
or by editing many entities and

00:15:47,600 --> 00:15:52,079
returning the same

00:15:48,880 --> 00:15:54,240
types on the response objects all the

00:15:52,079 --> 00:15:56,399
components actually currently carry

00:15:54,240 --> 00:15:58,000
will get hangry when the cache is

00:15:56,399 --> 00:16:01,519
updated

00:15:58,000 --> 00:16:03,680
but life is not easy and

00:16:01,519 --> 00:16:05,360
there are cases when the cache isn't

00:16:03,680 --> 00:16:08,079
automatically updated

00:16:05,360 --> 00:16:10,720
because the merge isn't possible when

00:16:08,079 --> 00:16:13,120
the merge isn't possible

00:16:10,720 --> 00:16:14,320
for instance if you have a carry which

00:16:13,120 --> 00:16:18,079
returns a user

00:16:14,320 --> 00:16:21,440
and exec you execute a notation to

00:16:18,079 --> 00:16:23,839
let's say edit a user right so

00:16:21,440 --> 00:16:25,360
instead of the mutation returning the

00:16:23,839 --> 00:16:28,480
updated user

00:16:25,360 --> 00:16:30,720
the mutation returns a boolean so

00:16:28,480 --> 00:16:32,079
there is no way to apollo merge the

00:16:30,720 --> 00:16:35,279
fields because

00:16:32,079 --> 00:16:38,560
they aren't related at all

00:16:35,279 --> 00:16:39,120
other situations is the entire set of

00:16:38,560 --> 00:16:41,600
objects

00:16:39,120 --> 00:16:43,440
isn't returned on your response data the

00:16:41,600 --> 00:16:46,160
mutation doesn't return the data with

00:16:43,440 --> 00:16:49,839
the same order as the cached data

00:16:46,160 --> 00:16:52,240
intermutation adds or remove items

00:16:49,839 --> 00:16:54,560
and the cache doesn't know how to list

00:16:52,240 --> 00:16:57,519
all items to exchange in these cases

00:16:54,560 --> 00:16:58,160
so we need to update the cache manually

00:16:57,519 --> 00:17:01,839
and

00:16:58,160 --> 00:17:02,800
how can we do them so we use the update

00:17:01,839 --> 00:17:05,839
function

00:17:02,800 --> 00:17:08,000
to update the cache manually and one

00:17:05,839 --> 00:17:09,280
example here is when you are adding an

00:17:08,000 --> 00:17:11,360
item so executing

00:17:09,280 --> 00:17:12,959
you are executing annotation in order to

00:17:11,360 --> 00:17:15,199
add an item

00:17:12,959 --> 00:17:17,120
and the update function is pretty

00:17:15,199 --> 00:17:19,839
straightforward it receives the

00:17:17,120 --> 00:17:20,640
access to the cash api as the first

00:17:19,839 --> 00:17:22,959
argument

00:17:20,640 --> 00:17:24,559
and as the second argument you receive

00:17:22,959 --> 00:17:28,000
is the response data

00:17:24,559 --> 00:17:32,400
so by doing it we are able to

00:17:28,000 --> 00:17:34,960
write to the cash again and

00:17:32,400 --> 00:17:37,600
uh we can also deal with the case when

00:17:34,960 --> 00:17:40,799
you are deleting an item

00:17:37,600 --> 00:17:42,320
when we are deleting an item here we are

00:17:40,799 --> 00:17:44,400
reading from the cache reading the

00:17:42,320 --> 00:17:47,799
existing data from the cache

00:17:44,400 --> 00:17:50,880
then we delete the old data using uh

00:17:47,799 --> 00:17:53,440
cache.right carry we are writing the new

00:17:50,880 --> 00:17:54,120
cache data and we delete the old data

00:17:53,440 --> 00:17:57,120
using

00:17:54,120 --> 00:17:57,120
cache.evict

00:17:57,679 --> 00:18:01,120
we also can disable the cache

00:17:59,280 --> 00:18:02,400
normalization because there are

00:18:01,120 --> 00:18:05,679
situations

00:18:02,400 --> 00:18:06,320
when the specific entity doesn't need to

00:18:05,679 --> 00:18:08,960
be cached

00:18:06,320 --> 00:18:11,039
at all for instance search results so it

00:18:08,960 --> 00:18:13,760
doesn't make sense to

00:18:11,039 --> 00:18:15,200
run the normalization algorithm behind

00:18:13,760 --> 00:18:18,880
the scenes if the data

00:18:15,200 --> 00:18:21,360
isn't going to be cached or

00:18:18,880 --> 00:18:23,200
if it doesn't need to be normalized it

00:18:21,360 --> 00:18:25,679
doesn't need to

00:18:23,200 --> 00:18:26,480
avoid redundancy so let's say that we

00:18:25,679 --> 00:18:29,600
want to

00:18:26,480 --> 00:18:32,799
cache the data well i'd say that

00:18:29,600 --> 00:18:35,840
you doesn't have you doesn't want to

00:18:32,799 --> 00:18:38,240
um to avoid redundancy

00:18:35,840 --> 00:18:39,360
you just want to cache the whole list of

00:18:38,240 --> 00:18:41,120
search results

00:18:39,360 --> 00:18:42,720
without assigning a unique identifier

00:18:41,120 --> 00:18:45,679
for each one so

00:18:42,720 --> 00:18:46,799
ac3 provides an api to customize how the

00:18:45,679 --> 00:18:50,320
cache interacts with

00:18:46,799 --> 00:18:52,480
specific types by mapping the type name

00:18:50,320 --> 00:18:54,080
to type policy options and creating a

00:18:52,480 --> 00:18:56,160
new memory cache

00:18:54,080 --> 00:18:57,600
so as you can see here i'm setting shoe

00:18:56,160 --> 00:18:59,520
type policies

00:18:57,600 --> 00:19:00,720
one for search result and the other one

00:18:59,520 --> 00:19:03,600
for user

00:19:00,720 --> 00:19:05,520
and on one type policy i'm disabling

00:19:03,600 --> 00:19:08,480
cache normalization

00:19:05,520 --> 00:19:10,080
in the other type policy i'm setting a

00:19:08,480 --> 00:19:12,240
custom field in order to

00:19:10,080 --> 00:19:14,400
generate unique identifier for your

00:19:12,240 --> 00:19:17,360
digital normalization process

00:19:14,400 --> 00:19:19,840
we have the field policies which is used

00:19:17,360 --> 00:19:20,880
to customize the behavior of cached

00:19:19,840 --> 00:19:23,840
fields

00:19:20,880 --> 00:19:25,919
and in that way we are able to customize

00:19:23,840 --> 00:19:29,440
how a particular field is read

00:19:25,919 --> 00:19:29,919
or written in the cache by providing a

00:19:29,440 --> 00:19:32,960
read

00:19:29,919 --> 00:19:36,160
and merge options so

00:19:32,960 --> 00:19:37,360
here i'm saying that when i'm going to

00:19:36,160 --> 00:19:39,840
retrieve the name

00:19:37,360 --> 00:19:41,280
from the cache when apollo client goes

00:19:39,840 --> 00:19:44,240
and retrieve and read

00:19:41,280 --> 00:19:44,960
the name field from the cache it can

00:19:44,240 --> 00:19:47,440
assign

00:19:44,960 --> 00:19:48,480
the unknown name string if it doesn't

00:19:47,440 --> 00:19:50,720
exist

00:19:48,480 --> 00:19:51,600
or i can also specify a custom merge

00:19:50,720 --> 00:19:53,760
function

00:19:51,600 --> 00:19:54,880
so an apollo client goes to merge the

00:19:53,760 --> 00:19:57,360
author field

00:19:54,880 --> 00:19:59,440
he always preferred incoming data

00:19:57,360 --> 00:20:01,440
instead of the existing one

00:19:59,440 --> 00:20:02,960
so as you can see the field policies are

00:20:01,440 --> 00:20:04,559
very powerful

00:20:02,960 --> 00:20:07,760
and one of the ways that we can use

00:20:04,559 --> 00:20:10,960
field policies is also with pagination

00:20:07,760 --> 00:20:13,360
but ac3 now exports

00:20:10,960 --> 00:20:16,240
pagination helpers which is really

00:20:13,360 --> 00:20:18,640
useful because pythonation logic

00:20:16,240 --> 00:20:19,600
isn't related with any specific entity

00:20:18,640 --> 00:20:22,240
at all

00:20:19,600 --> 00:20:23,200
so we can share it across application

00:20:22,240 --> 00:20:26,480
and across

00:20:23,200 --> 00:20:27,120
models and across entities so here i'm

00:20:26,480 --> 00:20:29,919
using

00:20:27,120 --> 00:20:30,640
uh offset label limit pagination on a

00:20:29,919 --> 00:20:34,000
specific

00:20:30,640 --> 00:20:36,080
type and the ingredient here

00:20:34,000 --> 00:20:37,919
diagram with the ingredients spring is

00:20:36,080 --> 00:20:41,039
the idea of key arcs

00:20:37,919 --> 00:20:45,200
that really make this field unique

00:20:41,039 --> 00:20:48,240
so i want to save the value of

00:20:45,200 --> 00:20:50,400
variations of that field by using the

00:20:48,240 --> 00:20:53,919
ingredient arc i don't want you to use

00:20:50,400 --> 00:20:56,960
offset or limit but they really uh

00:20:53,919 --> 00:20:59,679
the only arc that really

00:20:56,960 --> 00:21:01,600
meant here is the ingredient one and

00:20:59,679 --> 00:21:02,000
that's it i hope you guys enjoyed the

00:21:01,600 --> 00:21:05,200
talk

00:21:02,000 --> 00:21:08,240
and i hope that now you have um

00:21:05,200 --> 00:21:09,840
a clear mind about how apollo handles

00:21:08,240 --> 00:21:12,480
the cash for us

00:21:09,840 --> 00:21:14,400
also i just want to remind you to read

00:21:12,480 --> 00:21:17,120
the article about cash

00:21:14,400 --> 00:21:17,120
cash this much

00:21:17,600 --> 00:21:22,240
it's really good and that's it see you

00:21:20,720 --> 00:21:23,840
in the qa

00:21:22,240 --> 00:21:25,520
yeah we're super happy to have you that

00:21:23,840 --> 00:21:26,960
talk was absolutely phenomenal and we've

00:21:25,520 --> 00:21:28,559
already got a bunch of questions poured

00:21:26,960 --> 00:21:29,280
in so i'll just actually jump right into

00:21:28,559 --> 00:21:31,280
it

00:21:29,280 --> 00:21:32,559
our first question here you talked about

00:21:31,280 --> 00:21:34,480
cache normalization

00:21:32,559 --> 00:21:37,280
is it recommended in any way that is

00:21:34,480 --> 00:21:39,600
disable cache normalization

00:21:37,280 --> 00:21:41,760
so that's a really good question it

00:21:39,600 --> 00:21:43,360
isn't recommended to disable cache

00:21:41,760 --> 00:21:45,600
normalization

00:21:43,360 --> 00:21:47,280
it's really some specific cases like

00:21:45,600 --> 00:21:49,760
search results

00:21:47,280 --> 00:21:50,559
but most part of the cases you don't

00:21:49,760 --> 00:21:53,679
want to have

00:21:50,559 --> 00:21:54,000
a redundancy like duplicated data on

00:21:53,679 --> 00:21:57,200
your

00:21:54,000 --> 00:22:00,960
cache store so i don't recommend at all

00:21:57,200 --> 00:22:00,960
to disable cache normalization

00:22:02,080 --> 00:22:05,280
awesome don't worry we got more ready

00:22:04,799 --> 00:22:06,960
laura

00:22:05,280 --> 00:22:10,840
what are some examples when you might

00:22:06,960 --> 00:22:12,080
want to use key fields to segment your

00:22:10,840 --> 00:22:13,940
cache

00:22:12,080 --> 00:22:17,469
feels um

00:22:13,940 --> 00:22:17,469
[Music]

00:22:17,600 --> 00:22:21,039
maybe if you if you want to avoid using

00:22:20,320 --> 00:22:26,640
necessary

00:22:21,039 --> 00:22:30,240
feels like um

00:22:26,640 --> 00:22:32,000
oh i'm still thinking about it but

00:22:30,240 --> 00:22:33,600
take your time um we can always come

00:22:32,000 --> 00:22:35,200
back because we have we have a bunch

00:22:33,600 --> 00:22:36,159
more questions at the ready so if this

00:22:35,200 --> 00:22:37,760
is something you want to

00:22:36,159 --> 00:22:39,360
kind of circle back on towards the end

00:22:37,760 --> 00:22:41,039
more than happy to move on

00:22:39,360 --> 00:22:42,380
yeah yeah i think we can go to the next

00:22:41,039 --> 00:22:43,600
question and i'm sure

00:22:42,380 --> 00:22:46,640
[Music]

00:22:43,600 --> 00:22:48,080
no problem cool be thinking about it

00:22:46,640 --> 00:22:51,200
while

00:22:48,080 --> 00:22:53,200
no problem um well our next question

00:22:51,200 --> 00:22:54,000
here is um what resources did you find

00:22:53,200 --> 00:22:56,480
most useful

00:22:54,000 --> 00:22:57,679
for learning apollo client 3 and what do

00:22:56,480 --> 00:23:00,000
you think could be improved in that

00:22:57,679 --> 00:23:00,000
space

00:23:00,320 --> 00:23:06,000
um this trains that apollo does

00:23:03,679 --> 00:23:07,520
it's really good and also the youtube

00:23:06,000 --> 00:23:11,039
content about it

00:23:07,520 --> 00:23:14,880
but in general i read a lot of articles

00:23:11,039 --> 00:23:18,080
uh about cash issue on the apollo blog

00:23:14,880 --> 00:23:20,480
and uh the blog really teach me a lot of

00:23:18,080 --> 00:23:22,559
things about apollo clients so

00:23:20,480 --> 00:23:24,640
the vlog of apollo and the youtube

00:23:22,559 --> 00:23:25,760
channel to reach all of the content that

00:23:24,640 --> 00:23:27,440
apollo does

00:23:25,760 --> 00:23:29,760
it's really important to learn about

00:23:27,440 --> 00:23:31,120
apollo client

00:23:29,760 --> 00:23:32,530
that's awesome is there anything that

00:23:31,120 --> 00:23:35,280
you think could be improved

00:23:32,530 --> 00:23:38,960
[Music]

00:23:35,280 --> 00:23:41,360
um actually i don't think so

00:23:38,960 --> 00:23:42,320
but a lot of the examples that they

00:23:41,360 --> 00:23:45,520
bring

00:23:42,320 --> 00:23:47,840
are awesome and the live the

00:23:45,520 --> 00:23:48,720
the live streams on twitch especially i

00:23:47,840 --> 00:23:52,159
love it because

00:23:48,720 --> 00:23:53,919
it's it's really natural um i can watch

00:23:52,159 --> 00:23:57,679
it while i'm working or

00:23:53,919 --> 00:23:59,919
doing anything else yeah i agree the

00:23:57,679 --> 00:24:01,600
the content that comes out of apollo is

00:23:59,919 --> 00:24:03,120
always some of my favorite and i

00:24:01,600 --> 00:24:04,159
absolutely love their live streams one

00:24:03,120 --> 00:24:08,080
of my favorite things to tune

00:24:04,159 --> 00:24:09,919
into our next question here is um what

00:24:08,080 --> 00:24:13,840
do you think about integrating redux

00:24:09,919 --> 00:24:13,840
with apollo client cash management

00:24:16,000 --> 00:24:22,480
um that's the bad threats

00:24:19,440 --> 00:24:25,679
practicing gender because redux

00:24:22,480 --> 00:24:28,799
deals with the client stage management

00:24:25,679 --> 00:24:31,600
and the server side data

00:24:28,799 --> 00:24:32,799
is totally a sync so the idea is that

00:24:31,600 --> 00:24:36,159
you end up

00:24:32,799 --> 00:24:36,480
dealing with some weird things regarding

00:24:36,159 --> 00:24:39,679
to

00:24:36,480 --> 00:24:41,919
cash all of those things apollo already

00:24:39,679 --> 00:24:46,000
handles for you because it has a

00:24:41,919 --> 00:24:48,480
internal store the cash store so

00:24:46,000 --> 00:24:50,000
you really have to focus on dealing with

00:24:48,480 --> 00:24:53,279
this cyber side data

00:24:50,000 --> 00:24:56,720
on apollo and not uh persisting to

00:24:53,279 --> 00:24:59,200
other to another store especially being

00:24:56,720 --> 00:25:02,799
a client one like redux

00:24:59,200 --> 00:25:06,000
or zustin any kind of uh

00:25:02,799 --> 00:25:07,440
client state management library yeah

00:25:06,000 --> 00:25:09,039
yeah i agree i think that's one of like

00:25:07,440 --> 00:25:10,960
the really cool things about apollo is

00:25:09,039 --> 00:25:11,279
how much it handles a lot of that for

00:25:10,960 --> 00:25:13,360
you

00:25:11,279 --> 00:25:14,960
out of the box and i think one of my

00:25:13,360 --> 00:25:15,600
favorite things is when they introduced

00:25:14,960 --> 00:25:18,000
the

00:25:15,600 --> 00:25:19,440
hooks into uh the react ecosystem and

00:25:18,000 --> 00:25:21,760
how easy that made

00:25:19,440 --> 00:25:23,360
interacting with that cache and and

00:25:21,760 --> 00:25:23,840
controlling your data i feel like it was

00:25:23,360 --> 00:25:25,360
like

00:25:23,840 --> 00:25:27,679
night and day from you know the whole

00:25:25,360 --> 00:25:29,760
render props move that was uh previously

00:25:27,679 --> 00:25:33,120
there

00:25:29,760 --> 00:25:35,840
so the questions keep pouring in um

00:25:33,120 --> 00:25:38,080
let's see all right cool how do you

00:25:35,840 --> 00:25:41,200
think about using optimistic responses

00:25:38,080 --> 00:25:41,200
with the update function

00:25:41,520 --> 00:25:45,200
it's uh really uh it's a really good

00:25:44,720 --> 00:25:49,520
idea

00:25:45,200 --> 00:25:52,720
to have optimistic optimistic responses

00:25:49,520 --> 00:25:53,760
um i think it is optimistic updates in

00:25:52,720 --> 00:25:56,080
general right

00:25:53,760 --> 00:25:58,080
is the the same thing optimistic

00:25:56,080 --> 00:26:00,320
responses

00:25:58,080 --> 00:26:01,120
yeah yeah basically like updating the ui

00:26:00,320 --> 00:26:03,840
based off of

00:26:01,120 --> 00:26:05,440
what you believe the the change will be

00:26:03,840 --> 00:26:07,840
i see a lot of people

00:26:05,440 --> 00:26:09,120
also using refatch carries the refresh

00:26:07,840 --> 00:26:12,000
cards option

00:26:09,120 --> 00:26:12,720
all the time but in the end of the day

00:26:12,000 --> 00:26:14,880
you are

00:26:12,720 --> 00:26:16,640
really refreshing a lot of stuff and

00:26:14,880 --> 00:26:19,520
imagine if you have a huge

00:26:16,640 --> 00:26:20,880
list it will be easier for you to update

00:26:19,520 --> 00:26:24,720
the cash manually

00:26:20,880 --> 00:26:27,840
and avoiding to redo a

00:26:24,720 --> 00:26:31,039
redo the request then uh

00:26:27,840 --> 00:26:33,919
abusing the request a carries option

00:26:31,039 --> 00:26:35,279
on the use mutation hook so it's a

00:26:33,919 --> 00:26:38,000
really good idea to

00:26:35,279 --> 00:26:39,200
use the update option should do

00:26:38,000 --> 00:26:42,640
optimistic updates on

00:26:39,200 --> 00:26:44,240
cash definitely

00:26:42,640 --> 00:26:46,000
and we probably have time for about one

00:26:44,240 --> 00:26:46,720
more here so i'll just feed you this

00:26:46,000 --> 00:26:48,559
real quick

00:26:46,720 --> 00:26:52,640
uh what do you think about using apollo

00:26:48,559 --> 00:26:55,919
client cash for local state management

00:26:52,640 --> 00:26:58,720
uh it's really nice the la la

00:26:55,919 --> 00:27:00,559
now apollo client has this thing called

00:26:58,720 --> 00:27:03,919
reactive variables

00:27:00,559 --> 00:27:07,039
and you can using a single star

00:27:03,919 --> 00:27:10,159
so you have client data and the

00:27:07,039 --> 00:27:11,440
cyber side data in one single place i

00:27:10,159 --> 00:27:12,400
think that's really nice because you

00:27:11,440 --> 00:27:15,200
don't have to

00:27:12,400 --> 00:27:15,760
worry about having another library to

00:27:15,200 --> 00:27:18,799
deal with

00:27:15,760 --> 00:27:20,399
a store so three stars on the same app

00:27:18,799 --> 00:27:22,320
when it starts you with cash and the

00:27:20,399 --> 00:27:25,360
other starts to deal with client data

00:27:22,320 --> 00:27:27,039
and you can have just a single one um i

00:27:25,360 --> 00:27:28,799
didn't read a lot about it

00:27:27,039 --> 00:27:30,799
but i really recommend you check the

00:27:28,799 --> 00:27:32,720
docs and there is some good content that

00:27:30,799 --> 00:27:36,159
apollo did about it too

00:27:32,720 --> 00:27:37,520
but it's really nice yeah i definitely

00:27:36,159 --> 00:27:39,679
think it's come a long way

00:27:37,520 --> 00:27:41,600
uh as far as how you can start to handle

00:27:39,679 --> 00:27:43,440
your server and client together

00:27:41,600 --> 00:27:45,120
uh and and really start to use those

00:27:43,440 --> 00:27:45,840
reactive variables to start to make a

00:27:45,120 --> 00:27:47,279
difference in

00:27:45,840 --> 00:27:48,799
kind of the way because you know i think

00:27:47,279 --> 00:27:51,200
the really cool part is it really lets

00:27:48,799 --> 00:27:53,039
you control what the user is expecting

00:27:51,200 --> 00:27:54,880
and it really lets you really give them

00:27:53,039 --> 00:27:57,520
a nice ui flow

00:27:54,880 --> 00:27:58,320
based off of you know incoming data from

00:27:57,520 --> 00:28:00,080
the server

00:27:58,320 --> 00:28:01,440
anything that's changing for the ui it's

00:28:00,080 --> 00:28:03,600
kind of all nicely

00:28:01,440 --> 00:28:04,720
handled within one kind of state tree

00:28:03,600 --> 00:28:06,720
instead of having to

00:28:04,720 --> 00:28:09,600
combine multiple state trees and hope

00:28:06,720 --> 00:28:12,399
that they all keep up with each other

00:28:09,600 --> 00:28:12,880
yes exactly awesome thank you so much

00:28:12,399 --> 00:28:15,360
laura

00:28:12,880 --> 00:28:17,039
phenomenal talk amazing q a uh if

00:28:15,360 --> 00:28:18,799
anybody wants to find laura after talk

00:28:17,039 --> 00:28:20,159
go ahead and hit her up on twitter if

00:28:18,799 --> 00:28:21,520
you have any more questions your

00:28:20,159 --> 00:28:22,640
question didn't get answered today

00:28:21,520 --> 00:28:24,480
definitely reach out

00:28:22,640 --> 00:28:26,159
laura thank you so much and uh have a

00:28:24,480 --> 00:28:28,000
great day

00:28:26,159 --> 00:28:30,480
thanks i'm really glad to be here today

00:28:28,000 --> 00:28:44,720
and if you guys want to ask me anything

00:28:30,480 --> 00:28:44,720

YouTube URL: https://www.youtube.com/watch?v=PcAl3lRF4fQ


