Title: Designing Apollo's Mobile Clients for iOS and Android
Publication date: 2017-04-18
Playlist: Apollo Day 2017
Description: 
	Martijn Walraven from the Apollo team and Ben Schwab from Airbnb talk about why GraphQL is a great choice for mobile apps and how Apollo will provide a unified set of client libraries across all major UI platforms.

Learn more about Apollo iOS: https://github.com/apollographql/apollo-ios
Learn more about Apollo Android: https://github.com/apollographql/apollo-android
Captions: 
	00:00:04,609 --> 00:00:11,990
good morning I'm Martin Martin Lauren I

00:00:08,480 --> 00:00:16,910
work as an open source developer at

00:00:11,990 --> 00:00:20,720
meteor on below and I've been working

00:00:16,910 --> 00:00:23,570
mostly on an iOS Swift client for graph

00:00:20,720 --> 00:00:28,310
QL this is part of our sort of open

00:00:23,570 --> 00:00:29,990
source Apollo client projects so we

00:00:28,310 --> 00:00:33,050
really see this as sort of a family of

00:00:29,990 --> 00:00:36,250
rats kelp clients with as much as

00:00:33,050 --> 00:00:38,799
possible with similar similar design

00:00:36,250 --> 00:00:44,030
definitely a similar design philosophy

00:00:38,799 --> 00:00:47,119
and I'm really excited to sort of be

00:00:44,030 --> 00:00:51,350
sharing this stage with Ben Schwab who's

00:00:47,119 --> 00:00:53,720
a an Android developer on the native

00:00:51,350 --> 00:00:57,320
infrastructure team at Airbnb and he's

00:00:53,720 --> 00:00:59,720
been an active contributor on the apollo

00:00:57,320 --> 00:01:02,510
android client and i think this is

00:00:59,720 --> 00:01:04,489
probably the first time that we're

00:01:02,510 --> 00:01:08,299
actually talking about the apollo

00:01:04,489 --> 00:01:10,130
android client so i think it's a great

00:01:08,299 --> 00:01:14,899
example of sort of the community driven

00:01:10,130 --> 00:01:17,780
nature of the Apollo projects as men

00:01:14,899 --> 00:01:20,060
will will explain there's like a group

00:01:17,780 --> 00:01:22,460
of active developers who've been really

00:01:20,060 --> 00:01:23,840
building and designing this together and

00:01:22,460 --> 00:01:26,719
at the same time we've been able to

00:01:23,840 --> 00:01:29,119
share a lot of the design from web of

00:01:26,719 --> 00:01:36,259
the JavaScript client and the V iOS

00:01:29,119 --> 00:01:38,060
client so AB sort of background and

00:01:36,259 --> 00:01:43,189
there's a story that may be familiar to

00:01:38,060 --> 00:01:48,439
some of you or a lot of you maybe this

00:01:43,189 --> 00:01:52,340
is the Facebook app like sort of fall

00:01:48,439 --> 00:01:55,399
2012 this was the first native version

00:01:52,340 --> 00:01:57,170
of the sort of modern Facebook app and

00:01:55,399 --> 00:01:59,990
this was also the first app that

00:01:57,170 --> 00:02:02,299
actually used graph QL so Greg Hill was

00:01:59,990 --> 00:02:06,409
developed in the context of the redesign

00:02:02,299 --> 00:02:08,709
of the Facebook app so even though like

00:02:06,409 --> 00:02:11,980
most of you probably heard of graph QL

00:02:08,709 --> 00:02:14,720
for the first time about two years ago

00:02:11,980 --> 00:02:16,490
when people inside Facebook started

00:02:14,720 --> 00:02:17,790
talking about for SQL open source

00:02:16,490 --> 00:02:21,630
dispatch

00:02:17,790 --> 00:02:24,620
and the real a client Roscoe had been in

00:02:21,630 --> 00:02:29,160
used at that point for quite a few years

00:02:24,620 --> 00:02:32,010
and like right now it's been almost five

00:02:29,160 --> 00:02:34,740
years I think most of the people in this

00:02:32,010 --> 00:02:36,570
room have used the app like literally

00:02:34,740 --> 00:02:39,710
hundreds of millions of people have been

00:02:36,570 --> 00:02:43,470
using grass QL over the last five years

00:02:39,710 --> 00:02:45,660
so one of the one of the interesting

00:02:43,470 --> 00:02:49,920
things about the history of frac QL is

00:02:45,660 --> 00:02:52,440
that it was developed really to solve

00:02:49,920 --> 00:02:54,920
problems with mobile apps like really

00:02:52,440 --> 00:02:57,300
designing the best API for mobile apps

00:02:54,920 --> 00:02:59,910
but also that it was designed in the

00:02:57,300 --> 00:03:03,180
context of a very practical project so

00:02:59,910 --> 00:03:06,720
this was a project where but the the

00:03:03,180 --> 00:03:07,770
product team and the people that came up

00:03:06,720 --> 00:03:11,970
with graphically I'll really work

00:03:07,770 --> 00:03:13,770
together so the question they asked

00:03:11,970 --> 00:03:15,930
themselves was what would an ideal API

00:03:13,770 --> 00:03:18,450
for mobile apps look like and what's

00:03:15,930 --> 00:03:21,030
interesting looking back is that sort of

00:03:18,450 --> 00:03:23,730
the ideal API for mobile apps it's very

00:03:21,030 --> 00:03:25,950
similar to the ideal API for web apps

00:03:23,730 --> 00:03:28,709
nowadays so a lot of the problems that

00:03:25,950 --> 00:03:30,810
they that they were trying to solve for

00:03:28,709 --> 00:03:33,090
mobile apps are very similar to the

00:03:30,810 --> 00:03:37,320
problems people run into with mobile

00:03:33,090 --> 00:03:39,560
apps nowadays because a lot more sort of

00:03:37,320 --> 00:03:43,709
component oriented and client-side

00:03:39,560 --> 00:03:48,390
processing happens in modern interactive

00:03:43,709 --> 00:03:53,220
web apps so we're all familiar with sort

00:03:48,390 --> 00:03:54,959
of the basic the basic promise of crafty

00:03:53,220 --> 00:03:58,080
all like what does it really have to

00:03:54,959 --> 00:04:01,500
offer well it allows clients to not rely

00:03:58,080 --> 00:04:04,830
on the server exposing endpoints giving

00:04:01,500 --> 00:04:06,720
you sort of data that you may not

00:04:04,830 --> 00:04:08,670
actually need for a certain for a

00:04:06,720 --> 00:04:11,070
certain screen but it really allows you

00:04:08,670 --> 00:04:13,200
to specify the exact data needs so you

00:04:11,070 --> 00:04:15,390
have you have your schema on the server

00:04:13,200 --> 00:04:17,489
you write your queries on the client and

00:04:15,390 --> 00:04:19,530
you get the exact data you want so this

00:04:17,489 --> 00:04:22,290
is like a pretty big benefit for mobile

00:04:19,530 --> 00:04:25,200
apps you only get the data you need so

00:04:22,290 --> 00:04:28,370
that means you use less bandwidth less

00:04:25,200 --> 00:04:30,110
processing it also makes it easier to

00:04:28,370 --> 00:04:31,910
evolve your apps

00:04:30,110 --> 00:04:37,790
to have multiple versions of your app

00:04:31,910 --> 00:04:40,370
running in parallel but I want to make

00:04:37,790 --> 00:04:43,550
it clear that I don't think grass cow is

00:04:40,370 --> 00:04:45,380
just about performance - one of the big

00:04:43,550 --> 00:04:48,320
benefits of rescue L and I think that

00:04:45,380 --> 00:04:50,510
really shows sort of the the development

00:04:48,320 --> 00:04:53,720
process like how it was developed as

00:04:50,510 --> 00:04:55,580
part of a concrete project is that

00:04:53,720 --> 00:04:59,180
gravel has been designed from the start

00:04:55,580 --> 00:05:00,470
to really care about developer

00:04:59,180 --> 00:05:02,750
experience to really think carefully

00:05:00,470 --> 00:05:07,340
sort of what a good developer experience

00:05:02,750 --> 00:05:09,770
looks like and sort of the best example

00:05:07,340 --> 00:05:13,640
of that and I still think I mean this is

00:05:09,770 --> 00:05:15,470
probably something most people show when

00:05:13,640 --> 00:05:17,480
they want to explain graph QL rather

00:05:15,470 --> 00:05:19,910
than sort of try to explain what graph G

00:05:17,480 --> 00:05:22,580
is just showing people graphical it's a

00:05:19,910 --> 00:05:26,200
very good way of sort of showing the

00:05:22,580 --> 00:05:28,610
benefits of grass QL and

00:05:26,200 --> 00:05:30,590
that brings me to sort of one of the

00:05:28,610 --> 00:05:34,360
first design principles of the mobile

00:05:30,590 --> 00:05:38,210
clients that don't try to hide grass QL

00:05:34,360 --> 00:05:39,680
so graph QL is a really well designed

00:05:38,210 --> 00:05:41,990
language it's pretty easy to learn

00:05:39,680 --> 00:05:46,040
there's a lot of tooling around it like

00:05:41,990 --> 00:05:49,510
graphical and like especially in the

00:05:46,040 --> 00:05:51,950
early days I think a lot of people who

00:05:49,510 --> 00:05:53,720
started to think about sort of native

00:05:51,950 --> 00:05:56,900
clients for grass QL their first

00:05:53,720 --> 00:06:00,740
approach was to to build something like

00:05:56,900 --> 00:06:03,410
a query builder so they they they didn't

00:06:00,740 --> 00:06:06,980
want to sort of have to be with strings

00:06:03,410 --> 00:06:09,830
they perceived grass QL as a string and

00:06:06,980 --> 00:06:12,020
instead they developed something like a

00:06:09,830 --> 00:06:16,430
query builder who could use Swift or

00:06:12,020 --> 00:06:21,260
Java to basically construct a query and

00:06:16,430 --> 00:06:24,470
then you'd get a string back so this has

00:06:21,260 --> 00:06:27,040
a couple of drawbacks one is I actually

00:06:24,470 --> 00:06:30,320
think grass scale is much more readable

00:06:27,040 --> 00:06:33,950
but there are more sort of they're very

00:06:30,320 --> 00:06:35,660
additional drawbacks one is that this

00:06:33,950 --> 00:06:37,910
kind of query building is dynamic it's

00:06:35,660 --> 00:06:40,340
something that happens at runtime so

00:06:37,910 --> 00:06:43,350
that makes it difficult to analyze your

00:06:40,340 --> 00:06:46,020
queries at compile or build time

00:06:43,350 --> 00:06:49,140
and the kind of aesthetic aesthetically

00:06:46,020 --> 00:06:52,260
analyzable queries that you get from for

00:06:49,140 --> 00:06:56,700
instance storing your grass ql queries

00:06:52,260 --> 00:07:00,420
in a separate graph QL file is that you

00:06:56,700 --> 00:07:01,890
get additional features and persistent

00:07:00,420 --> 00:07:05,040
queries is something you may have heard

00:07:01,890 --> 00:07:07,410
of it's also a pretty nice feature for

00:07:05,040 --> 00:07:10,050
mobile it basically allows you to do

00:07:07,410 --> 00:07:14,370
instead of sending the full query with

00:07:10,050 --> 00:07:17,760
every request like in advance upload

00:07:14,370 --> 00:07:20,280
your queries to the server

00:07:17,760 --> 00:07:21,810
and identify your queries by an ID so at

00:07:20,280 --> 00:07:23,640
runtime you only send an ID to the

00:07:21,810 --> 00:07:26,460
server you don't have to send the full

00:07:23,640 --> 00:07:30,150
query that means you're using less

00:07:26,460 --> 00:07:31,620
bandwidth but it's also a potential

00:07:30,150 --> 00:07:34,350
security feature because you can

00:07:31,620 --> 00:07:35,850
whitelist queries like clients can no

00:07:34,350 --> 00:07:39,720
longer perform to the arbitrary queries

00:07:35,850 --> 00:07:43,680
against your server so these are these

00:07:39,720 --> 00:07:45,300
are other benefits aesthetic queries but

00:07:43,680 --> 00:07:48,990
I think from the perspective of

00:07:45,300 --> 00:07:51,780
developer experience it's also like as

00:07:48,990 --> 00:07:53,730
soon as you start looking at tooling so

00:07:51,780 --> 00:07:55,860
as soon as you have sort of the ability

00:07:53,730 --> 00:07:59,310
of treating grass kills more than just a

00:07:55,860 --> 00:08:00,930
just just a text string you start

00:07:59,310 --> 00:08:03,710
getting these benefits in the experience

00:08:00,930 --> 00:08:05,880
so for instance you can get integrated

00:08:03,710 --> 00:08:10,260
delegation of your queries I'll show an

00:08:05,880 --> 00:08:12,050
example of this later and there are some

00:08:10,260 --> 00:08:16,200
exciting developments here as well so

00:08:12,050 --> 00:08:17,370
Joe who worked at the it's part of the

00:08:16,200 --> 00:08:20,400
graphical team at Facebook

00:08:17,370 --> 00:08:22,710
he's one of the authors of graphical is

00:08:20,400 --> 00:08:25,950
working on a graphical language service

00:08:22,710 --> 00:08:27,900
which sort of extract the diagnostics

00:08:25,950 --> 00:08:31,350
and auto-completion from graphical into

00:08:27,900 --> 00:08:33,599
a separate library that runs on your

00:08:31,350 --> 00:08:36,060
machine in a process and that can be

00:08:33,599 --> 00:08:39,690
used by different front-end IDE is

00:08:36,060 --> 00:08:42,150
another tooling so there are a lot of

00:08:39,690 --> 00:08:46,170
potential ways of sort of benefiting

00:08:42,150 --> 00:08:48,420
from treating grass QL as its own

00:08:46,170 --> 00:08:53,010
language building share tooling around

00:08:48,420 --> 00:08:55,320
it but let's look at how you would

00:08:53,010 --> 00:08:56,320
actually sort of use graphical in your

00:08:55,320 --> 00:09:01,240
app

00:08:56,320 --> 00:09:02,080
so you have a query you can get data out

00:09:01,240 --> 00:09:03,670
of it

00:09:02,080 --> 00:09:06,070
that's what you get when you run your

00:09:03,670 --> 00:09:09,210
query in graphical but how do you how do

00:09:06,070 --> 00:09:11,830
you actually do this at runtime well as

00:09:09,210 --> 00:09:14,380
Jonas also explained the simplest way of

00:09:11,830 --> 00:09:17,620
using graph drell is simply to treat it

00:09:14,380 --> 00:09:20,530
as any other HTTP request so you use

00:09:17,620 --> 00:09:23,110
girl or any HTTP library in your native

00:09:20,530 --> 00:09:26,260
language to execute the query and you

00:09:23,110 --> 00:09:31,240
get back a JSON string basically and

00:09:26,260 --> 00:09:34,110
then for instance in Swift you would use

00:09:31,240 --> 00:09:38,530
the built-in jason serialization to

00:09:34,110 --> 00:09:44,040
convert that string of json into sort of

00:09:38,530 --> 00:09:46,900
an typed objects dictionaries arrays and

00:09:44,040 --> 00:09:48,760
it's pretty painful to have to deal with

00:09:46,900 --> 00:09:50,770
JSON in this way especially in a

00:09:48,760 --> 00:09:54,460
statically typed language like swift or

00:09:50,770 --> 00:09:57,010
Java so you have all these sort of

00:09:54,460 --> 00:10:00,690
dynamic casts all these type conversions

00:09:57,010 --> 00:10:04,090
all these all these sort of potential

00:10:00,690 --> 00:10:07,270
potential runtime failures you have to

00:10:04,090 --> 00:10:10,060
deal with missing data yourselves so

00:10:07,270 --> 00:10:12,370
it's a pretty painful process and I mean

00:10:10,060 --> 00:10:15,790
this is similar to what people who use

00:10:12,370 --> 00:10:21,790
REST API is have to deal with and the

00:10:15,790 --> 00:10:25,330
most common solution is to write some

00:10:21,790 --> 00:10:27,850
kind of model layer so instead of

00:10:25,330 --> 00:10:32,190
dealing with or if your untyped Jason at

00:10:27,850 --> 00:10:35,470
runtime you write models that contain

00:10:32,190 --> 00:10:37,020
properties and then you either manually

00:10:35,470 --> 00:10:41,670
or by using some kind of framework

00:10:37,020 --> 00:10:43,690
converts the JSON into those models and

00:10:41,670 --> 00:10:46,390
that works like the development

00:10:43,690 --> 00:10:49,320
experience is a lot nicer but you're

00:10:46,390 --> 00:10:51,700
doing a lot of extra work here so you

00:10:49,320 --> 00:10:54,010
write your you have your models on the

00:10:51,700 --> 00:10:55,600
server but you also have to write that

00:10:54,010 --> 00:10:59,110
entire model layer on the client and

00:10:55,600 --> 00:11:03,100
with rescue L we of course have

00:10:59,110 --> 00:11:05,530
something pretty amazing we have like a

00:11:03,100 --> 00:11:09,330
fully typed contract between the client

00:11:05,530 --> 00:11:09,330
and the server we have to have a schema

00:11:09,450 --> 00:11:18,300
so what you may want to do is instead of

00:11:13,530 --> 00:11:20,130
writing these model objects by hand you

00:11:18,300 --> 00:11:26,210
can you can actually generate them from

00:11:20,130 --> 00:11:26,210
your graphical schema so instead of

00:11:26,540 --> 00:11:32,490
writing a post struct with all these

00:11:29,790 --> 00:11:35,970
properties you simply take your graph QL

00:11:32,490 --> 00:11:38,330
schema and you run a cogeneration tool

00:11:35,970 --> 00:11:41,160
and then you would get these type models

00:11:38,330 --> 00:11:45,390
so that gives you a similar experience

00:11:41,160 --> 00:11:47,820
to what people are used to with rest but

00:11:45,390 --> 00:11:49,290
with a lot of automation you no longer

00:11:47,820 --> 00:11:54,050
have these sort of duplicate model

00:11:49,290 --> 00:11:56,280
definitions but there is a pretty big

00:11:54,050 --> 00:11:57,810
drawback here we're not taking the full

00:11:56,280 --> 00:11:59,970
advantage of what Rafael gives you

00:11:57,810 --> 00:12:02,310
because scratch shell doesn't just have

00:11:59,970 --> 00:12:04,050
a schema the schema represents the

00:12:02,310 --> 00:12:06,720
capabilities it represents it of what

00:12:04,050 --> 00:12:10,410
data you can potentially ask for but in

00:12:06,720 --> 00:12:12,030
a specific query you have to be you

00:12:10,410 --> 00:12:14,460
actually have to specify the exact data

00:12:12,030 --> 00:12:16,890
you want and so you know and if you know

00:12:14,460 --> 00:12:18,990
in advance what data you'll get back and

00:12:16,890 --> 00:12:21,510
it's very inconvenient to sort of have

00:12:18,990 --> 00:12:24,090
to deal with large model objects with a

00:12:21,510 --> 00:12:26,010
lot of properties that may not be filled

00:12:24,090 --> 00:12:29,000
from particular queries so every

00:12:26,010 --> 00:12:34,020
property is potentially potentially

00:12:29,000 --> 00:12:36,750
nullable before the null for instance so

00:12:34,020 --> 00:12:39,870
what we do with the with the Apollo

00:12:36,750 --> 00:12:41,970
clients both the the Swiss client and

00:12:39,870 --> 00:12:45,990
the android client is we actually

00:12:41,970 --> 00:12:48,900
generate models from queries so not from

00:12:45,990 --> 00:12:52,770
schemas but from queries and the types

00:12:48,900 --> 00:12:55,770
you get are specific to the query so

00:12:52,770 --> 00:12:58,800
there's no sort of GlobalPost object or

00:12:55,770 --> 00:13:01,350
a global author there is the post that

00:12:58,800 --> 00:13:04,140
you get when you execute this query and

00:13:01,350 --> 00:13:07,230
that post has a title it has an author

00:13:04,140 --> 00:13:09,350
that author has a first name but it

00:13:07,230 --> 00:13:13,920
doesn't have a last name for instance

00:13:09,350 --> 00:13:17,060
and this gives you a really nice

00:13:13,920 --> 00:13:19,410
experience of sort of static type safety

00:13:17,060 --> 00:13:22,480
all the way from your server through

00:13:19,410 --> 00:13:24,550
your UI so I'd like to give a

00:13:22,480 --> 00:13:35,080
short demo of what that would look like

00:13:24,550 --> 00:13:37,480
on iOS and Xcode so this is Xcode has

00:13:35,080 --> 00:13:40,510
the concept of a companion view so it

00:13:37,480 --> 00:13:44,980
shows in this case a swift file and a

00:13:40,510 --> 00:13:50,100
graphical file sort of side-by-side this

00:13:44,980 --> 00:13:54,370
is the query the old posts query that

00:13:50,100 --> 00:13:57,610
generates a Swiss class the old post

00:13:54,370 --> 00:14:00,640
query class we can use that to execute

00:13:57,610 --> 00:14:03,730
the query and we get back results and

00:14:00,640 --> 00:14:09,040
these results are fully typed so in this

00:14:03,730 --> 00:14:13,900
case it's an array of post objects we

00:14:09,040 --> 00:14:16,330
can then use those posts objects let me

00:14:13,900 --> 00:14:18,180
show you quickly show you what the app

00:14:16,330 --> 00:14:22,900
looks like this is simple sort of

00:14:18,180 --> 00:14:26,350
ListView table view posts with titles

00:14:22,900 --> 00:14:28,660
authors and the number of votes so we

00:14:26,350 --> 00:14:33,640
use in this case use the post details

00:14:28,660 --> 00:14:37,540
fragment to configure the cell and if we

00:14:33,640 --> 00:14:39,280
look at the episode and as you can see

00:14:37,540 --> 00:14:40,990
the sort of corresponding graphical

00:14:39,280 --> 00:14:42,700
changes automatically so we always work

00:14:40,990 --> 00:14:46,270
side by side with your Swift intro

00:14:42,700 --> 00:14:48,970
graphic well so here you actually deal

00:14:46,270 --> 00:14:53,100
with a post details object and this is

00:14:48,970 --> 00:14:56,320
fully tight so you get good completion

00:14:53,100 --> 00:14:59,470
but also if I for instance remove the

00:14:56,320 --> 00:15:02,590
title field from this query I now get a

00:14:59,470 --> 00:15:04,870
compile time error because this model

00:15:02,590 --> 00:15:07,000
object no longer has that field so you

00:15:04,870 --> 00:15:09,280
can be assured with that compile time

00:15:07,000 --> 00:15:11,530
that the data you use to construct your

00:15:09,280 --> 00:15:15,820
UI is actually data that's requested

00:15:11,530 --> 00:15:16,990
from your server and then the nice thing

00:15:15,820 --> 00:15:19,630
about this integration is that it also

00:15:16,990 --> 00:15:25,060
works sort of the other way around so

00:15:19,630 --> 00:15:28,960
you get full like SQL validation inside

00:15:25,060 --> 00:15:31,300
your dry de we're working on the similar

00:15:28,960 --> 00:15:33,380
experience for Android based on the

00:15:31,300 --> 00:15:36,470
rescue language service

00:15:33,380 --> 00:15:41,320
this is not as me not as mature right

00:15:36,470 --> 00:15:44,240
now as its really work in progress but

00:15:41,320 --> 00:15:46,280
it should offer some of the same

00:15:44,240 --> 00:15:48,620
experiences like a validation error for

00:15:46,280 --> 00:15:50,990
instance but one of the benefits of

00:15:48,620 --> 00:15:52,640
Android studio or like really the

00:15:50,990 --> 00:15:56,060
jetbrains platform that it's based and I

00:15:52,640 --> 00:15:58,970
said it's much more extendable Xcode is

00:15:56,060 --> 00:16:00,740
pretty closed so we we should be able to

00:15:58,970 --> 00:16:03,820
get Auto completion and all kinds of

00:16:00,740 --> 00:16:14,180
other nice features in here as well and

00:16:03,820 --> 00:16:20,630
with that let me let me start the next

00:16:14,180 --> 00:16:22,910
presentation and yeah awesome so my name

00:16:20,630 --> 00:16:24,590
is Ben I'm a contributor on the Apollo

00:16:22,910 --> 00:16:27,200
Android project and work on the native

00:16:24,590 --> 00:16:28,460
infrastructure team a or beam beam just

00:16:27,200 --> 00:16:30,050
to start off to have a quick show of

00:16:28,460 --> 00:16:34,210
hands of how many mobile developers we

00:16:30,050 --> 00:16:37,730
have an audience there ok a couple cool

00:16:34,210 --> 00:16:41,000
so first I want to give a really quick

00:16:37,730 --> 00:16:44,090
history of graph QL at Airbnb so back in

00:16:41,000 --> 00:16:47,300
2015 our foundation team started

00:16:44,090 --> 00:16:49,790
experimenting with a way to write graphs

00:16:47,300 --> 00:16:51,220
through L compliant rails api's and we

00:16:49,790 --> 00:16:54,080
started using this internally for

00:16:51,220 --> 00:16:56,000
services that Airbnb but we didn't

00:16:54,080 --> 00:17:00,970
really take a look at using this for

00:16:56,000 --> 00:17:03,050
clients until a quarter for 2016 and

00:17:00,970 --> 00:17:05,030
finally today we're getting ready to

00:17:03,050 --> 00:17:07,850
ship our first client feature written

00:17:05,030 --> 00:17:09,770
and graph QL but before we could get

00:17:07,850 --> 00:17:12,620
there we had to answer an important

00:17:09,770 --> 00:17:15,260
question which graphical client should

00:17:12,620 --> 00:17:18,350
we use so we use relay Apollo

00:17:15,260 --> 00:17:20,420
maybe we should roll our own so we sat

00:17:18,350 --> 00:17:21,680
down and we sort of wrote down a bunch

00:17:20,420 --> 00:17:23,420
of requirements of something we'd want

00:17:21,680 --> 00:17:26,120
to see in the graph field client we

00:17:23,420 --> 00:17:29,180
chose one of them was that we wanted

00:17:26,120 --> 00:17:31,280
graphical to be a first priority feature

00:17:29,180 --> 00:17:34,640
in the client for many of the reasons

00:17:31,280 --> 00:17:36,020
that Martin just explains one of the

00:17:34,640 --> 00:17:37,820
biggest ones though is we wanted

00:17:36,020 --> 00:17:41,390
something that was unified across iOS

00:17:37,820 --> 00:17:43,400
Android web and react native and this is

00:17:41,390 --> 00:17:44,870
because the Airbnb our mobile apps have

00:17:43,400 --> 00:17:47,010
some features written and react native

00:17:44,870 --> 00:17:49,260
so we have developers that are switch

00:17:47,010 --> 00:17:51,660
from potentially Android iOS and

00:17:49,260 --> 00:17:53,880
JavaScript contexts and having a unified

00:17:51,660 --> 00:17:56,220
architecture is important but not only

00:17:53,880 --> 00:17:58,680
that there's actually some possibility

00:17:56,220 --> 00:18:00,480
to share code across the the clients

00:17:58,680 --> 00:18:02,010
particularly with the cache I'll be

00:18:00,480 --> 00:18:03,810
getting said bit more later today and

00:18:02,010 --> 00:18:05,910
finally we want something that was

00:18:03,810 --> 00:18:07,920
extensible would we be able to control

00:18:05,910 --> 00:18:11,190
where I cashed out of the store with

00:18:07,920 --> 00:18:13,670
this client able to grow with us so

00:18:11,190 --> 00:18:19,500
spoiler alert we ended up choosing

00:18:13,670 --> 00:18:21,090
Apollo but it turned out when I took a

00:18:19,500 --> 00:18:22,920
look there was this Apollo Android

00:18:21,090 --> 00:18:24,900
project back in you know that's over

00:18:22,920 --> 00:18:27,090
timeframe but I had just one commit that

00:18:24,900 --> 00:18:29,940
was like work in progress maybe like

00:18:27,090 --> 00:18:31,830
readme with one thing in it but what was

00:18:29,940 --> 00:18:33,930
really awesome is the community really

00:18:31,830 --> 00:18:35,310
came together and in the last few months

00:18:33,930 --> 00:18:37,470
you can see a ton of activity on this

00:18:35,310 --> 00:18:40,740
client and we have contributors from

00:18:37,470 --> 00:18:42,270
Shopify near x and Airbnb and to give

00:18:40,740 --> 00:18:44,010
you an idea of the level of commitment

00:18:42,270 --> 00:18:46,560
of these contributors we got this

00:18:44,010 --> 00:18:47,610
message from Ivan a couple days ago and

00:18:46,560 --> 00:18:48,600
you're just letting us know that he was

00:18:47,610 --> 00:18:50,700
going to be a little bit slower

00:18:48,600 --> 00:18:55,380
reviewing his PRS that because he just

00:18:50,700 --> 00:18:56,580
had a baby boy and you know he I don't

00:18:55,380 --> 00:18:58,290
know how true this was you still

00:18:56,580 --> 00:19:00,120
reviewing PR it's really fast he's still

00:18:58,290 --> 00:19:02,010
putting up a lot of code I guess he's

00:19:00,120 --> 00:19:03,980
using his sleepless nights with that but

00:19:02,010 --> 00:19:06,560
it's a great guy

00:19:03,980 --> 00:19:11,040
so what I wanted to focus on today is

00:19:06,560 --> 00:19:14,280
how I see using Apollo and grab QL to

00:19:11,040 --> 00:19:16,080
build context responsive apps contacts

00:19:14,280 --> 00:19:17,430
is sort of an overloaded term but I

00:19:16,080 --> 00:19:20,190
think the best way to understand this is

00:19:17,430 --> 00:19:22,260
with an example so say I want to build

00:19:20,190 --> 00:19:24,900
get hunt this is sort of a prototypical

00:19:22,260 --> 00:19:27,240
example for graph QL it's just a mash-up

00:19:24,900 --> 00:19:29,640
of github and products hunts so pretty

00:19:27,240 --> 00:19:32,370
much a way for you to find new

00:19:29,640 --> 00:19:33,480
repositories and vote on them so these

00:19:32,370 --> 00:19:34,770
are the mocks that we're building and we

00:19:33,480 --> 00:19:36,930
see there's a couple really awesome

00:19:34,770 --> 00:19:40,230
repositories available related to graph

00:19:36,930 --> 00:19:40,680
QL this looks pretty easy right so let's

00:19:40,230 --> 00:19:43,740
build it

00:19:40,680 --> 00:19:45,510
but let's remember that mobile app

00:19:43,740 --> 00:19:47,130
constraints you're going to be

00:19:45,510 --> 00:19:49,740
frequently dealing with inconsistent and

00:19:47,130 --> 00:19:51,780
slow networks just prove this point this

00:19:49,740 --> 00:19:53,700
is me clicking into one of the detail

00:19:51,780 --> 00:19:57,150
pages on a client that doesn't have any

00:19:53,700 --> 00:19:59,310
caching and this might look like it's

00:19:57,150 --> 00:20:00,600
just looping but it's not looping this

00:19:59,310 --> 00:20:03,180
is actually me clicking while

00:20:00,600 --> 00:20:06,540
times and watching it load over and over

00:20:03,180 --> 00:20:08,790
again similarly there's a lot of people

00:20:06,540 --> 00:20:10,920
with old devices that don't have much

00:20:08,790 --> 00:20:12,960
memory and this is important with the

00:20:10,920 --> 00:20:15,620
last constraint which is you're going to

00:20:12,960 --> 00:20:18,690
be running in a lot of variable context

00:20:15,620 --> 00:20:20,000
apps need to be able to handle rotations

00:20:18,690 --> 00:20:22,290
which might load a different layout

00:20:20,000 --> 00:20:24,060
because there's low memory on mobile

00:20:22,290 --> 00:20:26,550
phones the operating system might

00:20:24,060 --> 00:20:27,870
actually come and kill your app even if

00:20:26,550 --> 00:20:30,330
the user just background it did periods

00:20:27,870 --> 00:20:31,560
few seconds but users expect when they

00:20:30,330 --> 00:20:35,280
come back to have all the information

00:20:31,560 --> 00:20:38,490
fast and ready so what can we do to

00:20:35,280 --> 00:20:41,130
create context responsiveness you know

00:20:38,490 --> 00:20:42,780
the simple answer is caching you know

00:20:41,130 --> 00:20:43,230
when you're showing data show cache data

00:20:42,780 --> 00:20:45,930
first

00:20:43,230 --> 00:20:48,690
when a user rotates their device show

00:20:45,930 --> 00:20:49,950
cache data if your app was killed from

00:20:48,690 --> 00:20:53,790
memory restrictions and a user comes

00:20:49,950 --> 00:20:58,590
back show cache data so this sounds

00:20:53,790 --> 00:21:00,060
pretty easy but it's not that easy so in

00:20:58,590 --> 00:21:01,620
the rest world the easiest thing that

00:21:00,060 --> 00:21:03,450
you could try to do is something just

00:21:01,620 --> 00:21:06,960
called response caching just take the

00:21:03,450 --> 00:21:07,380
response cache it and maybe you're good

00:21:06,960 --> 00:21:09,210
to go

00:21:07,380 --> 00:21:11,090
so what happens if you're watching this

00:21:09,210 --> 00:21:14,190
example is I go to upload something and

00:21:11,090 --> 00:21:16,230
I go back to the previous page and since

00:21:14,190 --> 00:21:18,240
these two pages have two different

00:21:16,230 --> 00:21:21,300
responses and these responses are

00:21:18,240 --> 00:21:22,590
separately cached the up the action I

00:21:21,300 --> 00:21:24,990
performed is not reflected when I go

00:21:22,590 --> 00:21:28,200
back on the first page and this is a big

00:21:24,990 --> 00:21:30,000
problem to really nail home why this is

00:21:28,200 --> 00:21:31,800
happening again you can see this is the

00:21:30,000 --> 00:21:35,010
JSON response on the first page it has

00:21:31,800 --> 00:21:37,200
this folk value I go to the next page

00:21:35,010 --> 00:21:39,090
and I up vote but I come back to the

00:21:37,200 --> 00:21:43,020
first page it's the old cache JSON

00:21:39,090 --> 00:21:45,570
response with zero so what can we do

00:21:43,020 --> 00:21:48,780
well a really good answer is response

00:21:45,570 --> 00:21:50,370
normalization so I know we talked a

00:21:48,780 --> 00:21:51,950
little bit about this already today but

00:21:50,370 --> 00:21:55,340
I'll go over real quick what that means

00:21:51,950 --> 00:21:57,630
so the idea is that in a response every

00:21:55,340 --> 00:22:01,440
object that you see is going to be a

00:21:57,630 --> 00:22:04,200
record every scalar value of an object

00:22:01,440 --> 00:22:05,880
is just going to be a field so what you

00:22:04,200 --> 00:22:07,950
see right now is I have multiple graph

00:22:05,880 --> 00:22:10,560
QL queries all of them representing a

00:22:07,950 --> 00:22:12,630
repository all their fields are going to

00:22:10,560 --> 00:22:13,710
be merged together if they're scalar

00:22:12,630 --> 00:22:16,370
values

00:22:13,710 --> 00:22:19,770
when we get to something interesting

00:22:16,370 --> 00:22:21,929
I'll come back set such as this boat

00:22:19,770 --> 00:22:25,919
object we're actually going to take that

00:22:21,929 --> 00:22:28,350
and store it as a new record but in the

00:22:25,919 --> 00:22:30,630
record that contains us as a reference

00:22:28,350 --> 00:22:32,460
we'll just have a cache reference and

00:22:30,630 --> 00:22:34,500
this will allow us to trace it down the

00:22:32,460 --> 00:22:37,350
last little nuance is every single

00:22:34,500 --> 00:22:39,270
record needs to be signed an ID often

00:22:37,350 --> 00:22:42,809
this could actually be an ID property on

00:22:39,270 --> 00:22:44,370
the object but sometimes your object

00:22:42,809 --> 00:22:48,890
might have something else that acts as

00:22:44,370 --> 00:22:48,890
an ID such as the repositories full name

00:22:50,240 --> 00:22:56,070
okay so without graph CL and what would

00:22:54,510 --> 00:22:58,230
you do if you wanted to build response

00:22:56,070 --> 00:23:00,539
normalization well it's really

00:22:58,230 --> 00:23:02,399
complicated the networking libraries

00:23:00,539 --> 00:23:04,200
that shift by mobile clients don't do

00:23:02,399 --> 00:23:07,649
this for you they would have no way to

00:23:04,200 --> 00:23:09,539
to do it is the problem so developers

00:23:07,649 --> 00:23:11,220
would have to write by hand some sort of

00:23:09,539 --> 00:23:14,429
bridge between a persistent technology

00:23:11,220 --> 00:23:16,500
like sequel or parsable or an ORM and it

00:23:14,429 --> 00:23:18,779
is in my mind a really big problem

00:23:16,500 --> 00:23:20,850
because it leads to codification which

00:23:18,779 --> 00:23:22,860
this means is your app has two different

00:23:20,850 --> 00:23:24,750
ways to load code whether or not you're

00:23:22,860 --> 00:23:26,720
loading from cache and from network and

00:23:24,750 --> 00:23:30,750
this can get a cause of a lot of bugs

00:23:26,720 --> 00:23:32,100
but with Apollo a lot of these problems

00:23:30,750 --> 00:23:34,169
are fixed it's really simple

00:23:32,100 --> 00:23:36,539
there's very little work you need to do

00:23:34,169 --> 00:23:38,370
as a developer to enable normalization

00:23:36,539 --> 00:23:40,110
and this is because the graphs trail

00:23:38,370 --> 00:23:42,960
schema and awareness of that helps out a

00:23:40,110 --> 00:23:45,090
lot and there's very very little code

00:23:42,960 --> 00:23:46,770
bifurcation really the only difference

00:23:45,090 --> 00:23:48,539
is this tiny little snippet right here

00:23:46,770 --> 00:23:50,940
that I've highlighted which is when

00:23:48,539 --> 00:23:53,399
we're reading from the cache we have a

00:23:50,940 --> 00:23:55,740
reader that checks to see if string

00:23:53,399 --> 00:23:57,029
fields are of a cache reference type and

00:23:55,740 --> 00:24:00,690
then it just follows that references

00:23:57,029 --> 00:24:02,190
it's reading so very very small

00:24:00,690 --> 00:24:04,890
differences between the two code paths

00:24:02,190 --> 00:24:07,380
so let's take a look at what it's

00:24:04,890 --> 00:24:09,630
actually like to set up a cache on the

00:24:07,380 --> 00:24:11,070
android client and there's some

00:24:09,630 --> 00:24:12,470
interesting things to note so you see

00:24:11,070 --> 00:24:14,940
that we're creating a normalized cache

00:24:12,470 --> 00:24:17,580
but the type of this cache is an LRU

00:24:14,940 --> 00:24:18,840
normalized cache this is important

00:24:17,580 --> 00:24:20,159
because remember one two constraints the

00:24:18,840 --> 00:24:22,590
mobile development is that you're

00:24:20,159 --> 00:24:25,559
running with very little memory so an

00:24:22,590 --> 00:24:27,030
LRU cache will evict records if you're

00:24:25,559 --> 00:24:29,700
running low on memory and

00:24:27,030 --> 00:24:31,050
then at least recently used basis but

00:24:29,700 --> 00:24:34,170
even if you have Vicks something from

00:24:31,050 --> 00:24:35,490
memory you probably have more persistent

00:24:34,170 --> 00:24:38,040
memory available to use on the mobile

00:24:35,490 --> 00:24:41,010
device so we can back the LRU cache with

00:24:38,040 --> 00:24:42,510
a sequel cache and the the memory cache

00:24:41,010 --> 00:24:44,940
will read through to the sequel cache if

00:24:42,510 --> 00:24:46,560
the record is not present and this is in

00:24:44,940 --> 00:24:51,360
this is all the code you need to do to

00:24:46,560 --> 00:24:53,490
set it up as Joyce was mentioning there

00:24:51,360 --> 00:24:55,110
is you know a few other things that you

00:24:53,490 --> 00:24:57,660
do have to do and one of the important

00:24:55,110 --> 00:24:59,700
things is specifying what the ID of your

00:24:57,660 --> 00:25:02,190
object is so we have a very similar

00:24:59,700 --> 00:25:05,070
concept on the android client we call it

00:25:02,190 --> 00:25:07,050
a cache key resolver so typically this

00:25:05,070 --> 00:25:09,810
will just be you grabbing the type name

00:25:07,050 --> 00:25:11,910
and the ID from the JSON and using as a

00:25:09,810 --> 00:25:14,340
key but in the example I went through

00:25:11,910 --> 00:25:16,260
earlier the repository actually wanted

00:25:14,340 --> 00:25:17,250
to use its full name as the key so you

00:25:16,260 --> 00:25:21,300
just have to write this little code

00:25:17,250 --> 00:25:22,950
snippet right there so one thing I just

00:25:21,300 --> 00:25:26,220
want to call out that was very

00:25:22,950 --> 00:25:28,140
intentional on our design was we wanted

00:25:26,220 --> 00:25:29,220
to make it very easy for any mobile

00:25:28,140 --> 00:25:31,320
developer to write their own

00:25:29,220 --> 00:25:32,460
implementation of a normalized cache so

00:25:31,320 --> 00:25:34,860
maybe you're not happy with our choice

00:25:32,460 --> 00:25:37,290
of sorting sequel all you need to do is

00:25:34,860 --> 00:25:38,850
implement these methods with it which is

00:25:37,290 --> 00:25:41,400
essentially just a key value store for

00:25:38,850 --> 00:25:43,140
records however what we do for you is we

00:25:41,400 --> 00:25:44,850
wrap the normalized cache in an Apollo

00:25:43,140 --> 00:25:45,750
store and this is going to give you

00:25:44,850 --> 00:25:47,600
thread safe access

00:25:45,750 --> 00:25:50,280
backed by a readwrite lock and

00:25:47,600 --> 00:25:54,870
subscription management with people are

00:25:50,280 --> 00:25:57,630
watching queries and as Jonas also

00:25:54,870 --> 00:25:59,880
mentioned one great thing is that this

00:25:57,630 --> 00:26:02,010
sort of architecture pattern is either

00:25:59,880 --> 00:26:06,900
very similar or will be very similar

00:26:02,010 --> 00:26:09,180
across all platforms so this is a really

00:26:06,900 --> 00:26:10,620
cool thing I'm excited about is what

00:26:09,180 --> 00:26:12,090
let's say this example app that we're

00:26:10,620 --> 00:26:14,700
building had an additional requirement

00:26:12,090 --> 00:26:16,860
that the feed page was going to be built

00:26:14,700 --> 00:26:19,400
in reactivated with JavaScript and the

00:26:16,860 --> 00:26:23,960
detail page is going to be built in Java

00:26:19,400 --> 00:26:26,190
even if we use a response normalization

00:26:23,960 --> 00:26:27,570
we're going to see the same exact

00:26:26,190 --> 00:26:30,240
loading error of that video that I

00:26:27,570 --> 00:26:32,100
showed you because traditionally a

00:26:30,240 --> 00:26:34,260
JavaScript and Java would not be able to

00:26:32,100 --> 00:26:36,780
share a cache but because we've

00:26:34,260 --> 00:26:38,040
standardized on the cache format we can

00:26:36,780 --> 00:26:40,650
actually write a react native bridge

00:26:38,040 --> 00:26:42,540
that explores the same Apollo store

00:26:40,650 --> 00:26:45,420
javascript client and java and you get

00:26:42,540 --> 00:26:50,450
all the benefits of caching even across

00:26:45,420 --> 00:26:53,730
react native and native so to show you

00:26:50,450 --> 00:26:54,150
with Apollo you can see I rotate my

00:26:53,730 --> 00:26:55,500
phone

00:26:54,150 --> 00:26:57,930
sano reloading so that low different

00:26:55,500 --> 00:27:00,060
cache I go vote you see the upload

00:26:57,930 --> 00:27:03,540
reflected there I go back and it's

00:27:00,060 --> 00:27:05,700
reflected in the app and the great thing

00:27:03,540 --> 00:27:06,660
is I'll go over this quick because I

00:27:05,700 --> 00:27:08,580
know there's not a lot of Java

00:27:06,660 --> 00:27:10,980
developers but this took very very

00:27:08,580 --> 00:27:14,790
little code all I had to do was create

00:27:10,980 --> 00:27:17,400
the call I specify how I want to load

00:27:14,790 --> 00:27:19,470
the data so with the feed I might want

00:27:17,400 --> 00:27:22,200
to actually not show cached data at

00:27:19,470 --> 00:27:23,460
first and instead rely on the network

00:27:22,200 --> 00:27:26,160
and fallback to the cache if you're

00:27:23,460 --> 00:27:27,450
offline but if I rotate the phone I

00:27:26,160 --> 00:27:29,970
actually do you want to go to cache

00:27:27,450 --> 00:27:32,370
first and all you see right here that's

00:27:29,970 --> 00:27:34,520
the only difference of the two code two

00:27:32,370 --> 00:27:36,570
pieces of code so this enables a

00:27:34,520 --> 00:27:39,000
unidirectional data flow which is very

00:27:36,570 --> 00:27:40,110
hard to get on mobile because of all the

00:27:39,000 --> 00:27:42,840
different situations that you're trying

00:27:40,110 --> 00:27:44,850
to handle but now we can have just one

00:27:42,840 --> 00:27:47,610
data callback that's going to be setting

00:27:44,850 --> 00:27:50,240
our view in one location and it's going

00:27:47,610 --> 00:27:53,280
to be a layer aware of the loading state

00:27:50,240 --> 00:27:55,470
so we can do cool things to sort of tell

00:27:53,280 --> 00:27:58,020
the user what state their app is in so

00:27:55,470 --> 00:27:59,880
what that might look like is maybe we do

00:27:58,020 --> 00:28:02,400
want to show cached data for the feed so

00:27:59,880 --> 00:28:03,420
you know while it's in the cache state

00:28:02,400 --> 00:28:05,160
and we're still touching for the network

00:28:03,420 --> 00:28:06,900
will grayed out so that the user has an

00:28:05,160 --> 00:28:09,720
idea that it's cached when it comes back

00:28:06,900 --> 00:28:11,250
we you know remove the opacity but if it

00:28:09,720 --> 00:28:12,690
turns out they're offline well remove

00:28:11,250 --> 00:28:13,620
the opacity but we're also put a little

00:28:12,690 --> 00:28:14,940
banner at the bottom of the screen

00:28:13,620 --> 00:28:17,790
they're telling the user that they're

00:28:14,940 --> 00:28:19,980
offline and this is all just really easy

00:28:17,790 --> 00:28:24,500
to do with Apollo because you're loading

00:28:19,980 --> 00:28:26,760
state is tied in with your data model so

00:28:24,500 --> 00:28:29,330
the palo android client is ready to try

00:28:26,760 --> 00:28:31,440
today you can check us out on github

00:28:29,330 --> 00:28:33,000
really appreciate if you join the slack

00:28:31,440 --> 00:28:35,010
channel let us know additional features

00:28:33,000 --> 00:28:37,530
you'd like to see and of course there's

00:28:35,010 --> 00:28:41,380
a lot left to build so more contributors

00:28:37,530 --> 00:28:43,440
would be welcome thank you

00:28:41,380 --> 00:28:43,440

YouTube URL: https://www.youtube.com/watch?v=4cDEfB1xcLc


