Title: Authentication and Error Handling in GraphQL - Andrew Rhyne
Publication date: 2017-04-18
Playlist: Apollo Day 2017
Description: 
	Andrew Rhyne from Boost explains a new pattern for handling authentication and errors with his new apollo-resolvers package.

Learn about apollo-resolvers here: https://github.com/thebigredgeek/apollo-resolvers

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Captions: 
	00:00:05,580 --> 00:00:11,550
so uh good morning everyone mr. Oscar

00:00:09,150 --> 00:00:12,990
said my name is Andrew I'm the lead in

00:00:11,550 --> 00:00:14,760
our head of engineering at a company

00:00:12,990 --> 00:00:18,930
called deuce

00:00:14,760 --> 00:00:21,660
so yeah just the elephant in the room

00:00:18,930 --> 00:00:24,750
I'm seven feet tall so hopefully you

00:00:21,660 --> 00:00:26,669
guys won't ask that again like I said

00:00:24,750 --> 00:00:29,790
I'm the head of engineering at boost I'm

00:00:26,669 --> 00:00:33,149
from Austin Texas I'm very much an open

00:00:29,790 --> 00:00:34,410
source nut I have been doing open source

00:00:33,149 --> 00:00:35,940
software since I was in high school so

00:00:34,410 --> 00:00:38,100
kind of always been my thing

00:00:35,940 --> 00:00:40,769
I'm the maintainer contributor and

00:00:38,100 --> 00:00:43,530
janitor for several nodejs modules

00:00:40,769 --> 00:00:46,100
including debug progress Microlock and

00:00:43,530 --> 00:00:49,199
apollo other errors and a few others and

00:00:46,100 --> 00:00:51,500
I think I definitely enjoy systems and

00:00:49,199 --> 00:00:55,140
back in programming more than anything I

00:00:51,500 --> 00:00:56,190
endure the front end but I like things

00:00:55,140 --> 00:00:59,789
that are a little bit more discreet and

00:00:56,190 --> 00:01:01,260
is predictable so what is boost boost is

00:00:59,789 --> 00:01:02,760
a career coaching platform powered by a

00:01:01,260 --> 00:01:06,180
mixture of industry experts and machine

00:01:02,760 --> 00:01:08,430
intelligence we provide you like custom

00:01:06,180 --> 00:01:10,830
tailored advice so you can like send

00:01:08,430 --> 00:01:12,630
boost a question like how do i navigate

00:01:10,830 --> 00:01:14,940
this difficult political situation at

00:01:12,630 --> 00:01:17,280
work or not and through a mixture of

00:01:14,940 --> 00:01:18,510
like industry experts and machine

00:01:17,280 --> 00:01:19,620
learning we kind of provide you with

00:01:18,510 --> 00:01:22,380
custom tailor responses to those

00:01:19,620 --> 00:01:23,760
questions we switched from Russell api's

00:01:22,380 --> 00:01:25,410
to graft you all about seven months ago

00:01:23,760 --> 00:01:26,970
so this presentation is just a little

00:01:25,410 --> 00:01:29,250
bit about like what we've experienced

00:01:26,970 --> 00:01:30,930
and some patterns that we found on the

00:01:29,250 --> 00:01:35,820
server work really well for access

00:01:30,930 --> 00:01:36,960
control and error handling okay so first

00:01:35,820 --> 00:01:39,420
impressions when we started working with

00:01:36,960 --> 00:01:39,870
graph QL it feels kind of like the Wild

00:01:39,420 --> 00:01:41,520
West

00:01:39,870 --> 00:01:44,720
but in a good way kind of like when

00:01:41,520 --> 00:01:46,650
angular 1 or even no js' first launched

00:01:44,720 --> 00:01:48,300
everyone has their own pattern for

00:01:46,650 --> 00:01:50,580
pretty much everything and there aren't

00:01:48,300 --> 00:01:52,650
really a lot of a lot of the standards

00:01:50,580 --> 00:01:53,970
are still emerging it does the community

00:01:52,650 --> 00:01:55,500
does feel very high energy kind of like

00:01:53,970 --> 00:01:57,090
nodejs when it first launched and that

00:01:55,500 --> 00:01:58,680
everyone's really excited and everyone's

00:01:57,090 --> 00:02:01,320
working really hard to sort of like make

00:01:58,680 --> 00:02:02,820
graph QL more mainstream and the people

00:02:01,320 --> 00:02:05,250
who are using graph QL seem to be pretty

00:02:02,820 --> 00:02:07,470
optimistic and enthusiastic about its

00:02:05,250 --> 00:02:10,619
future and like I said best practices

00:02:07,470 --> 00:02:11,910
are still emerging so teams kind of

00:02:10,619 --> 00:02:14,130
require a certain level grit and

00:02:11,910 --> 00:02:17,270
curiosity from those making the switch

00:02:14,130 --> 00:02:21,250
from restful api for instance

00:02:17,270 --> 00:02:23,810
so why why did boo switch to graph QL

00:02:21,250 --> 00:02:26,720
well first of all we had that huge set

00:02:23,810 --> 00:02:28,430
of restful API endpoints like I think we

00:02:26,720 --> 00:02:30,170
had like close to like 90 or 100 and

00:02:28,430 --> 00:02:31,340
they just kept growing with every time

00:02:30,170 --> 00:02:32,660
every time we wanted to iterate on the

00:02:31,340 --> 00:02:34,250
product or slightly adjust it while

00:02:32,660 --> 00:02:37,190
we're trying to find product market fit

00:02:34,250 --> 00:02:38,420
we had to may either tear down a bunch

00:02:37,190 --> 00:02:40,310
of existing endpoints and rebuild them

00:02:38,420 --> 00:02:41,420
for a new use case or we had to add new

00:02:40,310 --> 00:02:43,130
endpoints so it which is kind of an

00:02:41,420 --> 00:02:45,140
ever-expanding surface area on our API

00:02:43,130 --> 00:02:47,930
and we wanted to be more productive with

00:02:45,140 --> 00:02:49,430
less code writing risk to me restful api

00:02:47,930 --> 00:02:51,230
is you tend to write a ton and ton of

00:02:49,430 --> 00:02:52,940
code for every little use case that you

00:02:51,230 --> 00:02:57,140
have if you're doing like a strictly

00:02:52,940 --> 00:02:58,790
like resourceful REST API no one does

00:02:57,140 --> 00:02:59,950
that you would be requesting like one

00:02:58,790 --> 00:03:01,640
resource and then another and another

00:02:59,950 --> 00:03:03,160
maybe if you're using something like

00:03:01,640 --> 00:03:05,000
JSON API you're able to like specify

00:03:03,160 --> 00:03:07,880
relations that you also want to load

00:03:05,000 --> 00:03:09,890
with a resource but it's slow you're

00:03:07,880 --> 00:03:13,010
making in resource in requests for in

00:03:09,890 --> 00:03:15,080
resources usually so we wanted our new

00:03:13,010 --> 00:03:16,760
API to be incredibly fast especially on

00:03:15,080 --> 00:03:18,319
mobile as was mentioned before graph QL

00:03:16,760 --> 00:03:19,580
performs insanely well in mobile because

00:03:18,319 --> 00:03:21,829
you're making one request for pretty

00:03:19,580 --> 00:03:23,420
much all the data you need and we want

00:03:21,829 --> 00:03:24,709
to also of course wanted to spend less

00:03:23,420 --> 00:03:25,730
time thinking and more time slinging

00:03:24,709 --> 00:03:27,260
product we don't want to have to solve

00:03:25,730 --> 00:03:28,970
hard engineering problems to figure out

00:03:27,260 --> 00:03:32,329
how to reinvent the wheel every time we

00:03:28,970 --> 00:03:34,070
want to build a new feature and so

00:03:32,329 --> 00:03:36,350
sometimes coercing rests to play nice

00:03:34,070 --> 00:03:40,250
with complicated business logic needs to

00:03:36,350 --> 00:03:40,940
be challenging so why didn't do switch

00:03:40,250 --> 00:03:44,720
to something else

00:03:40,940 --> 00:03:47,780
G RPC which is another type sort of API

00:03:44,720 --> 00:03:49,370
esque system it only works server server

00:03:47,780 --> 00:03:51,290
and native to server because it requires

00:03:49,370 --> 00:03:54,230
HTTP two and most browsers don't support

00:03:51,290 --> 00:03:55,100
that yet and I don't know anyone who

00:03:54,230 --> 00:03:56,900
uses Falkor

00:03:55,100 --> 00:03:57,890
that was another alternative but I don't

00:03:56,900 --> 00:03:59,450
really think south or is getting a lot

00:03:57,890 --> 00:04:03,620
of traction and really nothing else

00:03:59,450 --> 00:04:05,660
looked promising so our primary concerns

00:04:03,620 --> 00:04:08,299
and I think these are also concerns with

00:04:05,660 --> 00:04:10,640
most people switching to graph QL or how

00:04:08,299 --> 00:04:13,519
do you handle access control and how do

00:04:10,640 --> 00:04:15,049
you handle errors with a REST API it's

00:04:13,519 --> 00:04:16,669
simple you are if for an error you

00:04:15,049 --> 00:04:18,140
return a status code and you return an

00:04:16,669 --> 00:04:20,750
error message right and that works great

00:04:18,140 --> 00:04:23,270
because an arrest API requests are not

00:04:20,750 --> 00:04:25,010
multiplexed you can't send multiple

00:04:23,270 --> 00:04:26,780
queries out on the same request and

00:04:25,010 --> 00:04:28,280
expect multiple responses back and

00:04:26,780 --> 00:04:29,810
likewise you can't send multiple updates

00:04:28,280 --> 00:04:30,330
if you're doing it properly anyway and

00:04:29,810 --> 00:04:33,629
if

00:04:30,330 --> 00:04:35,039
fact multiple update responses right so

00:04:33,629 --> 00:04:37,889
graph you all has like a bit of a new

00:04:35,039 --> 00:04:39,629
requirement there so of course this is

00:04:37,889 --> 00:04:41,099
kind of how most people write rest api

00:04:39,629 --> 00:04:42,750
is you have middleware that handles

00:04:41,099 --> 00:04:44,669
access control and request preconditions

00:04:42,750 --> 00:04:46,860
like should this user be able to access

00:04:44,669 --> 00:04:49,409
this what state should be loaded before

00:04:46,860 --> 00:04:50,909
it gets to the route handler etc usually

00:04:49,409 --> 00:04:52,500
you have some form of after where which

00:04:50,909 --> 00:04:53,789
is just like if you throw an error how

00:04:52,500 --> 00:04:55,620
do you format it on the way back out the

00:04:53,789 --> 00:04:57,030
pipe or if you want to like coerce a

00:04:55,620 --> 00:04:57,479
response into a certain format based on

00:04:57,030 --> 00:04:59,550
the route

00:04:57,479 --> 00:05:00,960
afterwards useful in those cases you

00:04:59,550 --> 00:05:02,940
have a route controller which is usually

00:05:00,960 --> 00:05:04,530
single purpose it receives a request and

00:05:02,940 --> 00:05:05,759
interacts with the model returns a

00:05:04,530 --> 00:05:07,530
successful response or throws an error

00:05:05,759 --> 00:05:09,180
right and then you always have a data

00:05:07,530 --> 00:05:11,280
layer and everyone has their own way of

00:05:09,180 --> 00:05:12,690
doing data right some people use the

00:05:11,280 --> 00:05:13,949
same service like a massive monolith

00:05:12,690 --> 00:05:16,379
application in which case you have

00:05:13,949 --> 00:05:17,789
models and service objects or some

00:05:16,379 --> 00:05:19,080
people use separate services so like a

00:05:17,789 --> 00:05:20,719
micro services architecture in which

00:05:19,080 --> 00:05:23,310
case you're using something like G RPC

00:05:20,719 --> 00:05:24,389
HTTP or some other transport to interact

00:05:23,310 --> 00:05:26,279
with other services running on your

00:05:24,389 --> 00:05:29,039
back-end so it kind of looks like this

00:05:26,279 --> 00:05:30,360
right Fred makes an HTTP request it goes

00:05:29,039 --> 00:05:31,800
through middleware it hits the route

00:05:30,360 --> 00:05:33,150
controller and interacts with the data

00:05:31,800 --> 00:05:35,000
layer and then a response is rendered

00:05:33,150 --> 00:05:37,680
back to the client

00:05:35,000 --> 00:05:39,360
so graph QL doesn't have middleware or

00:05:37,680 --> 00:05:41,550
after where it only has resolvers

00:05:39,360 --> 00:05:42,990
resolvers responsibilities are to bind

00:05:41,550 --> 00:05:45,449
portions of a request to functionality

00:05:42,990 --> 00:05:47,099
in the data layer so what is this user

00:05:45,449 --> 00:05:50,039
requesting based on the query and what

00:05:47,099 --> 00:05:52,169
do I do in order to get that data and

00:05:50,039 --> 00:05:53,969
the data later again is pretty much the

00:05:52,169 --> 00:05:55,710
same right you can use models and

00:05:53,969 --> 00:05:59,039
connectors or you can use different

00:05:55,710 --> 00:06:00,690
services so it looks more like this

00:05:59,039 --> 00:06:02,099
right much simpler Fred makes requests

00:06:00,690 --> 00:06:04,279
because the resolvers resolvers the data

00:06:02,099 --> 00:06:04,279
layer

00:06:04,589 --> 00:06:08,520
the challenges with this pattern are

00:06:06,110 --> 00:06:11,419
that access control must be moved from

00:06:08,520 --> 00:06:14,310
middleware to either models or resolvers

00:06:11,419 --> 00:06:16,349
graph QL allows the client to dictate

00:06:14,310 --> 00:06:17,490
what they want to load and with the REST

00:06:16,349 --> 00:06:19,949
API you don't have to worry about that

00:06:17,490 --> 00:06:21,330
right your your route reroute controller

00:06:19,949 --> 00:06:23,069
is usually only responsible for doing

00:06:21,330 --> 00:06:25,199
one thing really well right with graph

00:06:23,069 --> 00:06:28,580
QL you can sort of Traverse down your

00:06:25,199 --> 00:06:32,460
data however you want and that requires

00:06:28,580 --> 00:06:33,569
complicated access control rules and

00:06:32,460 --> 00:06:35,370
like I said before requests and

00:06:33,569 --> 00:06:36,719
responses have to multiplex you could do

00:06:35,370 --> 00:06:38,669
something like query bashing batching

00:06:36,719 --> 00:06:40,770
where you're sending you know 10 to 20

00:06:38,669 --> 00:06:42,240
queries in a single request and that

00:06:40,770 --> 00:06:43,159
means that every single request needs

00:06:42,240 --> 00:06:45,739
its own error State

00:06:43,159 --> 00:06:47,289
if applicable it needs done response so

00:06:45,739 --> 00:06:50,569
you kind of have to figure out how to

00:06:47,289 --> 00:06:52,039
handle that on the client so status

00:06:50,569 --> 00:06:54,979
codes don't work you can't say that the

00:06:52,039 --> 00:06:56,389
users like not authorized for a query if

00:06:54,979 --> 00:06:57,860
there are 10 queries coming back because

00:06:56,389 --> 00:07:00,110
it could be authorized which means you

00:06:57,860 --> 00:07:03,139
can't say you know like a 401 because

00:07:00,110 --> 00:07:04,999
which query was not authorized right you

00:07:03,139 --> 00:07:06,860
have to you have to be explicit as to

00:07:04,999 --> 00:07:11,119
which portion of the graph QL requests

00:07:06,860 --> 00:07:13,699
encountered certain arrow states so our

00:07:11,119 --> 00:07:15,740
solution acts of controlled and

00:07:13,699 --> 00:07:18,139
last-ditch error masking is handled at

00:07:15,740 --> 00:07:19,580
the resolver level through chaining this

00:07:18,139 --> 00:07:21,529
is not exactly how Facebook recommends

00:07:19,580 --> 00:07:22,969
you do this Facebook I know a lot of

00:07:21,529 --> 00:07:24,740
their main recommendation is that you

00:07:22,969 --> 00:07:27,619
put access control rules in the model

00:07:24,740 --> 00:07:29,419
layer and that's great if you have

00:07:27,619 --> 00:07:31,669
multiple API types interacting with the

00:07:29,419 --> 00:07:33,469
same data layer we do not are we only

00:07:31,669 --> 00:07:36,139
have a graph to LAPI so putting it in

00:07:33,469 --> 00:07:37,729
the model layer just is putting making

00:07:36,139 --> 00:07:40,039
the model layer even more of a god

00:07:37,729 --> 00:07:41,479
function right so we decided to split up

00:07:40,039 --> 00:07:43,999
access control rules and put them in the

00:07:41,479 --> 00:07:45,559
resolvers also errors we decided to

00:07:43,999 --> 00:07:47,629
present them in a standard the standard

00:07:45,559 --> 00:07:50,689
errors array that comes back with every

00:07:47,629 --> 00:07:51,919
graph QL response and present the errors

00:07:50,689 --> 00:07:55,119
in a consistent machine readable

00:07:51,919 --> 00:07:59,119
structure so what does that look like

00:07:55,119 --> 00:08:03,409
lightful open some code real quick well

00:07:59,119 --> 00:08:06,289
hopefully cool so this is a little demo

00:08:03,409 --> 00:08:07,999
and we have a graph QL server enough

00:08:06,289 --> 00:08:10,219
schema where we want to be able to

00:08:07,999 --> 00:08:14,479
register a user update a user's profile

00:08:10,219 --> 00:08:15,439
Dan a user and get a user right so we

00:08:14,479 --> 00:08:17,179
have three different authentication

00:08:15,439 --> 00:08:19,519
states right now we have I'm not

00:08:17,179 --> 00:08:21,110
authenticated we have I'm authenticated

00:08:19,519 --> 00:08:22,279
and we have I must authenticate it and

00:08:21,110 --> 00:08:24,079
I'm an admin right

00:08:22,279 --> 00:08:25,699
we don't want non admin users to be able

00:08:24,079 --> 00:08:27,259
to ban a user and we don't want users

00:08:25,699 --> 00:08:28,639
that are not logged in to be able to

00:08:27,259 --> 00:08:33,110
update the profile or get their user

00:08:28,639 --> 00:08:34,519
right likewise we probably do not we

00:08:33,110 --> 00:08:35,689
probably do not want a user who's

00:08:34,519 --> 00:08:40,550
already logged in to be able to register

00:08:35,689 --> 00:08:42,979
right that doesn't make any sense so you

00:08:40,550 --> 00:08:45,399
know as per the typical node.js server

00:08:42,979 --> 00:08:47,420
setup we use Express we hook up graph QL

00:08:45,399 --> 00:08:48,620
with a piece of middleware called graph

00:08:47,420 --> 00:08:50,509
QL Express I don't know if anyone here

00:08:48,620 --> 00:08:52,339
uses node.js for the graph the OLAP API

00:08:50,509 --> 00:08:54,900
but graph C all server is a really great

00:08:52,339 --> 00:08:56,850
tool and that's what we use

00:08:54,900 --> 00:08:59,220
and we have a few errors right for our

00:08:56,850 --> 00:09:00,960
different air states so we need an

00:08:59,220 --> 00:09:03,420
unknown error in case something on the

00:09:00,960 --> 00:09:04,830
backend craps out right like if the

00:09:03,420 --> 00:09:06,480
database disconnects or something we

00:09:04,830 --> 00:09:08,520
don't want to tell the end-user that the

00:09:06,480 --> 00:09:11,970
database died we want to mask it with an

00:09:08,520 --> 00:09:13,530
unknown error likewise we have an error

00:09:11,970 --> 00:09:15,210
if the user is not authenticated it

00:09:13,530 --> 00:09:17,790
needs to be to handle that state

00:09:15,210 --> 00:09:19,050
precondition we also have an error if

00:09:17,790 --> 00:09:20,550
the users already logged in and they're

00:09:19,050 --> 00:09:22,200
trying to register again for instance so

00:09:20,550 --> 00:09:23,250
an error that we presented the users

00:09:22,200 --> 00:09:24,330
already authenticated and they're do

00:09:23,250 --> 00:09:26,940
something that they shouldn't unless

00:09:24,330 --> 00:09:28,230
they are not authenticated we also have

00:09:26,940 --> 00:09:31,640
a forbidden error in case the user tries

00:09:28,230 --> 00:09:31,640
to ban someone and they're not an admin

00:09:31,850 --> 00:09:37,890
so then our schema definition we import

00:09:36,030 --> 00:09:39,540
our errors and we provide a few base

00:09:37,890 --> 00:09:42,180
resolvers I like to call them abstract

00:09:39,540 --> 00:09:46,890
resolvers and abstract resolvers are

00:09:42,180 --> 00:09:49,650
useful because we can in a single place

00:09:46,890 --> 00:09:51,810
define state preconditions that must be

00:09:49,650 --> 00:09:54,540
met in order to run certain routines on

00:09:51,810 --> 00:09:56,880
our resolver layer so let's let's take

00:09:54,540 --> 00:09:58,770
bandung a user for instance the client

00:09:56,880 --> 00:10:00,030
makes a graphs ql request which is a

00:09:58,770 --> 00:10:01,620
mutation saying that they want to ban a

00:10:00,030 --> 00:10:03,750
user the first thing we do is verify

00:10:01,620 --> 00:10:04,920
that the user is authenticated if they

00:10:03,750 --> 00:10:06,210
are not we immediately throw an

00:10:04,920 --> 00:10:09,300
authentication required error and we

00:10:06,210 --> 00:10:10,650
stop but then we check to see whether or

00:10:09,300 --> 00:10:12,410
not they're an admin if they are not we

00:10:10,650 --> 00:10:15,030
throw a forbidden error and we stop

00:10:12,410 --> 00:10:18,780
otherwise we unleash the ban hand hammer

00:10:15,030 --> 00:10:21,000
on whatever user selected so we provide

00:10:18,780 --> 00:10:24,030
first a base resolver that handles the

00:10:21,000 --> 00:10:26,580
case of something crapped out and we

00:10:24,030 --> 00:10:28,620
don't have control over it so our base

00:10:26,580 --> 00:10:31,200
resolver checks that whatever error has

00:10:28,620 --> 00:10:34,410
bubbled up to it is an instance of an

00:10:31,200 --> 00:10:36,780
Apollo error if it is not it masks the

00:10:34,410 --> 00:10:38,430
error with a new unknown Apollo Dare so

00:10:36,780 --> 00:10:39,570
that the client doesn't isn't told that

00:10:38,430 --> 00:10:42,870
the database crapped out for instance

00:10:39,570 --> 00:10:44,400
and we as a convenience attach the name

00:10:42,870 --> 00:10:46,830
of the original error on to the data

00:10:44,400 --> 00:10:48,240
property onto the new Apollo error so

00:10:46,830 --> 00:10:50,070
Apollo errors look kind of like this in

00:10:48,240 --> 00:10:53,100
the response so this is a standard graph

00:10:50,070 --> 00:10:54,870
QL response clearly if the user is

00:10:53,100 --> 00:10:56,220
attempting your request the user is

00:10:54,870 --> 00:10:58,650
trying to load their own profile on the

00:10:56,220 --> 00:11:00,720
database crafts to bed for instance we

00:10:58,650 --> 00:11:03,120
present that mast error so it gives us

00:11:00,720 --> 00:11:05,040
the strength that we define in the air

00:11:03,120 --> 00:11:06,420
and then the error has occurred the name

00:11:05,040 --> 00:11:07,580
of the error so that's machine readable

00:11:06,420 --> 00:11:10,010
on the client and the client can

00:11:07,580 --> 00:11:12,080
act appropriately the time that the

00:11:10,010 --> 00:11:13,610
error was thrown in case we want to

00:11:12,080 --> 00:11:15,560
programmatically handle that for

00:11:13,610 --> 00:11:16,940
instance and then any sort of metadata

00:11:15,560 --> 00:11:19,220
that we want to attach to the year in

00:11:16,940 --> 00:11:20,660
this case we're assuming that it was a

00:11:19,220 --> 00:11:22,070
database connection error and we're

00:11:20,660 --> 00:11:24,200
attaching the name of the database

00:11:22,070 --> 00:11:28,520
connection error to the error object so

00:11:24,200 --> 00:11:29,480
that's presented here so on this basis

00:11:28,520 --> 00:11:31,540
although we're going to create a few

00:11:29,480 --> 00:11:33,470
more preconditions the first is

00:11:31,540 --> 00:11:34,640
authenticated resolver which will handle

00:11:33,470 --> 00:11:35,990
the precondition that the user is

00:11:34,640 --> 00:11:38,390
authenticated who's making the request

00:11:35,990 --> 00:11:42,170
and you can see here oops

00:11:38,390 --> 00:11:44,120
typo that the is authenticated resolver

00:11:42,170 --> 00:11:48,710
is spawning itself from the base

00:11:44,120 --> 00:11:50,360
resolver so what that means is that when

00:11:48,710 --> 00:11:52,460
requests come in they're going to pass

00:11:50,360 --> 00:11:53,960
through the base resolver first before

00:11:52,460 --> 00:11:55,820
they get to the authenticated resolver

00:11:53,960 --> 00:11:57,710
and if errors are thrown down the

00:11:55,820 --> 00:12:00,110
resolver tree those errors are going to

00:11:57,710 --> 00:12:01,580
bubble back up to the base resolver and

00:12:00,110 --> 00:12:02,630
the base resolver is going to inspect

00:12:01,580 --> 00:12:06,620
the error and make sure it's an area

00:12:02,630 --> 00:12:08,000
that we actually wanted to throw so then

00:12:06,620 --> 00:12:09,590
we also have a not authenticated

00:12:08,000 --> 00:12:12,860
resolver that also spawns itself in the

00:12:09,590 --> 00:12:14,450
base resolver what that does and I

00:12:12,860 --> 00:12:15,620
didn't really go over this one first the

00:12:14,450 --> 00:12:17,210
is authenticated resolver of course

00:12:15,620 --> 00:12:19,910
checks to see if the user is attached to

00:12:17,210 --> 00:12:21,380
the request context and if it's not it

00:12:19,910 --> 00:12:23,750
throws than not authorized here right

00:12:21,380 --> 00:12:25,220
the is authenticated resolver checks to

00:12:23,750 --> 00:12:26,810
see if the error is attached and if it

00:12:25,220 --> 00:12:28,760
is it throws an error because we don't

00:12:26,810 --> 00:12:31,550
want to register or do an action that

00:12:28,760 --> 00:12:33,680
requires authentication if the user is

00:12:31,550 --> 00:12:36,620
already authenticated and then of course

00:12:33,680 --> 00:12:38,720
we haven't is admin resolver the admin

00:12:36,620 --> 00:12:42,020
resolver establishes the precondition

00:12:38,720 --> 00:12:43,760
that the user is the logged in user is

00:12:42,020 --> 00:12:45,770
also an administrator so you can see

00:12:43,760 --> 00:12:47,620
here we we spawn the is admin resolver

00:12:45,770 --> 00:12:50,260
from the is authenticated resolver and

00:12:47,620 --> 00:12:52,730
that's where we get this look right here

00:12:50,260 --> 00:12:53,240
so the request comes in from the client

00:12:52,730 --> 00:12:55,280
again

00:12:53,240 --> 00:12:57,410
it hits graph QL it goes through the is

00:12:55,280 --> 00:12:59,570
authenticated resolver then it goes

00:12:57,410 --> 00:13:01,010
through the is admin resolver and then

00:12:59,570 --> 00:13:05,920
finally it gets to the banned resolver

00:13:01,010 --> 00:13:05,920
which is down here

00:13:06,150 --> 00:13:11,100
so the band user resolver spawns itself

00:13:09,089 --> 00:13:12,990
in the is admin resolver so by the time

00:13:11,100 --> 00:13:14,070
it gets to this resolver it will have

00:13:12,990 --> 00:13:15,870
already checked that the user is

00:13:14,070 --> 00:13:18,420
authenticated and it will have checked

00:13:15,870 --> 00:13:20,430
that the user is in admin and then our

00:13:18,420 --> 00:13:21,839
band user resolver does whatever work at

00:13:20,430 --> 00:13:25,529
once in order to accomplish that goal

00:13:21,839 --> 00:13:28,800
right likewise for registration and

00:13:25,529 --> 00:13:30,210
login we we buy it we spawn that from

00:13:28,800 --> 00:13:31,620
the is not authenticated resolver

00:13:30,210 --> 00:13:32,970
because we don't want a user trying to

00:13:31,620 --> 00:13:36,000
log in or register when they're already

00:13:32,970 --> 00:13:38,520
authenticated and of course updating the

00:13:36,000 --> 00:13:40,650
profile and getting the user

00:13:38,520 --> 00:13:41,700
require the authentication state so they

00:13:40,650 --> 00:13:45,960
spawned themselves from the is

00:13:41,700 --> 00:13:47,460
authenticated resolver so that's a

00:13:45,960 --> 00:13:49,560
little complicated but we found that

00:13:47,460 --> 00:13:52,470
this is a really great way after once

00:13:49,560 --> 00:13:54,600
you kind of grok that request bubble

00:13:52,470 --> 00:13:56,880
down the resolver tree and errors bubble

00:13:54,600 --> 00:13:59,400
back up it's a great way to both handle

00:13:56,880 --> 00:14:01,140
like error masking and error transforms

00:13:59,400 --> 00:14:02,850
as well as ensure that certain state

00:14:01,140 --> 00:14:05,100
conditions are met before requests are

00:14:02,850 --> 00:14:09,420
allowed to sort of like interact with

00:14:05,100 --> 00:14:10,770
your data model so we send it very we

00:14:09,420 --> 00:14:12,180
spend very little time now thinking

00:14:10,770 --> 00:14:13,950
about access control if we need to

00:14:12,180 --> 00:14:15,690
certain like access control precondition

00:14:13,950 --> 00:14:17,190
we just create a new base resolver and

00:14:15,690 --> 00:14:18,839
we inherit from it and for every single

00:14:17,190 --> 00:14:19,860
case where the user needs to be in a

00:14:18,839 --> 00:14:22,620
certain state before they're allowed to

00:14:19,860 --> 00:14:24,060
make a request we also don't worry about

00:14:22,620 --> 00:14:28,440
graph QL air is leaking back to the

00:14:24,060 --> 00:14:29,730
client we found that you know one of the

00:14:28,440 --> 00:14:31,470
one of the most common questions that

00:14:29,730 --> 00:14:32,940
I've seen in like slack or on stack

00:14:31,470 --> 00:14:35,130
overflow for instance is like how do I

00:14:32,940 --> 00:14:36,630
make sure that the error that goes back

00:14:35,130 --> 00:14:38,730
to the client doesn't say there's a typo

00:14:36,630 --> 00:14:40,860
and I graph in a graph GL function or

00:14:38,730 --> 00:14:43,410
that there was some error thrown

00:14:40,860 --> 00:14:44,310
internally by the backend and what a lot

00:14:43,410 --> 00:14:45,810
of people end up doing is that write

00:14:44,310 --> 00:14:47,610
lots of try caches in their resolvers

00:14:45,810 --> 00:14:49,170
and it transform the error if they don't

00:14:47,610 --> 00:14:50,430
like it so if they don't like that this

00:14:49,170 --> 00:14:52,110
error is a database error they throw

00:14:50,430 --> 00:14:53,400
some other an error and this allows you

00:14:52,110 --> 00:14:57,589
to sort of do that in one place rather

00:14:53,400 --> 00:14:59,910
than doing it all over the place so we

00:14:57,589 --> 00:15:01,709
love open source software as I kind of

00:14:59,910 --> 00:15:03,930
said before I'm a big believer in it and

00:15:01,709 --> 00:15:05,580
the Apollo community and the Apollo team

00:15:03,930 --> 00:15:08,520
have been very supportive enough making

00:15:05,580 --> 00:15:10,650
this transition to grass QL so we

00:15:08,520 --> 00:15:12,900
released both packages as open source

00:15:10,650 --> 00:15:14,700
software both Apollo Ayres and Apollo

00:15:12,900 --> 00:15:15,990
resolvers so other people can avoid

00:15:14,700 --> 00:15:17,190
having to deal with some of these

00:15:15,990 --> 00:15:19,390
initial questions when they're sending

00:15:17,190 --> 00:15:24,070
up a graph QL server

00:15:19,390 --> 00:15:24,070
so yeah that's pretty much it

00:15:24,280 --> 00:15:27,419
[Music]

00:15:27,910 --> 00:15:33,190
wait we have time for like one question

00:15:31,880 --> 00:15:38,589
if anybody has a question about this

00:15:33,190 --> 00:15:39,860
type of approach questions all right oh

00:15:38,589 --> 00:15:42,140
yeah

00:15:39,860 --> 00:15:43,910
yes question was get Ken resolvers be

00:15:42,140 --> 00:15:45,860
asynchronous yeah the resolvers wrap

00:15:43,910 --> 00:15:48,110
everything that's returned and a promise

00:15:45,860 --> 00:15:49,040
dot resolved so anything that if it if

00:15:48,110 --> 00:15:51,350
it returns the promise and the promise

00:15:49,040 --> 00:15:52,940
rejects it throws right if it returns

00:15:51,350 --> 00:15:55,420
something synchronous it's also treated

00:15:52,940 --> 00:15:55,420

YouTube URL: https://www.youtube.com/watch?v=xaorvBjCE7A


