Title: Generating GraphQL APIs for Content-Based Sites - Chris Biscardi
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	Senior DropBox Engineer Chris Biscardi presents at our Practical GraphQL meetup on 1/19/17.

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/
Captions: 
	00:00:02,689 --> 00:00:09,389
cool so uh I'm Chris I said before I

00:00:08,160 --> 00:00:12,120
work at throughout box right now as a

00:00:09,389 --> 00:00:14,759
senior engineer before that I built the

00:00:12,120 --> 00:00:21,449
UI team at docker and before that I did

00:00:14,759 --> 00:00:22,830
a lot of consulting for many years if

00:00:21,449 --> 00:00:24,510
we're going to talk about sort of

00:00:22,830 --> 00:00:27,510
content based sites and sort of how to

00:00:24,510 --> 00:00:29,310
generate for SQL api's for them we have

00:00:27,510 --> 00:00:32,969
to sort of define what a content-based

00:00:29,310 --> 00:00:34,890
site is and it's pretty simple with

00:00:32,969 --> 00:00:36,360
sites that your own content that come

00:00:34,890 --> 00:00:40,620
from various areas

00:00:36,360 --> 00:00:44,129
it sounds vague but some examples of

00:00:40,620 --> 00:00:48,390
these are markdown files systems like

00:00:44,129 --> 00:00:51,270
Jekyll middleman Hugo all generally use

00:00:48,390 --> 00:00:52,890
or support markdown files with some sort

00:00:51,270 --> 00:00:57,239
of frontmatter maybe it's gamal maybe

00:00:52,890 --> 00:01:01,739
it's something else and you sort of take

00:00:57,239 --> 00:01:04,019
mark down in and spit HTML out you can

00:01:01,739 --> 00:01:06,689
get more data from content management

00:01:04,019 --> 00:01:11,369
systems like WordPress who are content

00:01:06,689 --> 00:01:13,170
full many of these have REST API s some

00:01:11,369 --> 00:01:16,220
of them don't and some of them like

00:01:13,170 --> 00:01:18,439
WordPress have recently grown rust api's

00:01:16,220 --> 00:01:23,640
depending on how you feel about that

00:01:18,439 --> 00:01:26,490
and then for git repos and open source

00:01:23,640 --> 00:01:28,619
projects you have documentation that's a

00:01:26,490 --> 00:01:32,670
version across multiple branches

00:01:28,619 --> 00:01:34,320
multiple tags multiple releases and you

00:01:32,670 --> 00:01:36,840
want to sort of pull all of that in and

00:01:34,320 --> 00:01:40,920
then generate sites based on that

00:01:36,840 --> 00:01:43,320
content and then finally you've got JSON

00:01:40,920 --> 00:01:46,079
files or third-party api's they're

00:01:43,320 --> 00:01:48,210
basically the same thing maybe you want

00:01:46,079 --> 00:01:50,159
to set your top repos from github for

00:01:48,210 --> 00:01:51,840
your personal site maybe you want to get

00:01:50,159 --> 00:01:54,509
the tweets from Twitter for a client

00:01:51,840 --> 00:01:59,299
site or maybe you want some YouTube

00:01:54,509 --> 00:01:59,299
videos from you know YouTube

00:01:59,540 --> 00:02:06,560
content-based sites are distributed in

00:02:01,520 --> 00:02:10,430
multiple forms static sites such as the

00:02:06,560 --> 00:02:13,610
generator Hugo or Jekyll are quite a

00:02:10,430 --> 00:02:16,930
common occurrence and then you get into

00:02:13,610 --> 00:02:19,730
sort of more progressive web app style

00:02:16,930 --> 00:02:22,460
content-based systems and these are

00:02:19,730 --> 00:02:24,190
built using app shells and manifests and

00:02:22,460 --> 00:02:26,270
service workers and things like that

00:02:24,190 --> 00:02:28,690
there's a project that I've built myself

00:02:26,270 --> 00:02:30,830
called weo which uses the grass dual

00:02:28,690 --> 00:02:33,230
style ApS that I'm going to talk about

00:02:30,830 --> 00:02:35,120
today and there's also another project

00:02:33,230 --> 00:02:38,870
called Gatsby that many of you may be

00:02:35,120 --> 00:02:40,130
aware of and then finally you can

00:02:38,870 --> 00:02:42,500
distribute it a sort of a content-based

00:02:40,130 --> 00:02:44,960
site as a universally rendered

00:02:42,500 --> 00:02:46,880
application and the difference between a

00:02:44,960 --> 00:02:49,040
universally rendered application and a

00:02:46,880 --> 00:02:50,890
system like Leo or Gatsby isn't that

00:02:49,040 --> 00:02:54,110
different

00:02:50,890 --> 00:02:56,840
for example docker hub is a universal

00:02:54,110 --> 00:02:58,190
application that renders static HTML and

00:02:56,840 --> 00:03:01,010
then bootstraps a single page

00:02:58,190 --> 00:03:05,450
application on the back end or on the

00:03:01,010 --> 00:03:08,180
front end but a sphere loads an each of

00:03:05,450 --> 00:03:12,110
these needs with data pipeline some of

00:03:08,180 --> 00:03:14,770
these are a little more ad hoc II sort

00:03:12,110 --> 00:03:16,730
of like Jekyll or something like that

00:03:14,770 --> 00:03:20,300
but basically they all need to take

00:03:16,730 --> 00:03:22,940
markdown or some content type JSON from

00:03:20,300 --> 00:03:25,790
api's and they need to turn it into HTML

00:03:22,940 --> 00:03:28,580
that the browser can see sort of JSON

00:03:25,790 --> 00:03:31,280
and script bundles manifest and service

00:03:28,580 --> 00:03:33,739
worker scripts and I would argue that

00:03:31,280 --> 00:03:38,480
the correct way to do this these days is

00:03:33,739 --> 00:03:39,020
to use graph QL as that interface so we

00:03:38,480 --> 00:03:41,900
have a problem

00:03:39,020 --> 00:03:43,790
we have a lot of different content types

00:03:41,900 --> 00:03:46,520
and we have a lot of different sources

00:03:43,790 --> 00:03:47,780
of data that we can get it from one

00:03:46,520 --> 00:03:49,959
example of the blog post like I

00:03:47,780 --> 00:03:53,030
mentioned before where you can have

00:03:49,959 --> 00:03:55,459
markdown with front matter and that can

00:03:53,030 --> 00:03:58,220
come from a markdown file or it can come

00:03:55,459 --> 00:04:02,030
from WordPress or content full as an API

00:03:58,220 --> 00:04:04,610
call but the blog post itself is a

00:04:02,030 --> 00:04:06,950
representation of that data it isn't the

00:04:04,610 --> 00:04:09,320
data format itself so we would like to

00:04:06,950 --> 00:04:11,840
use grass QL to specify what we want

00:04:09,320 --> 00:04:13,330
that blog post to be and then there's

00:04:11,840 --> 00:04:15,370
other situations where you get

00:04:13,330 --> 00:04:17,280
AAB content maybe you were using an

00:04:15,370 --> 00:04:20,080
early version of a wordpress api and

00:04:17,280 --> 00:04:21,730
basically you're just getting HTML blobs

00:04:20,080 --> 00:04:24,310
shipped down to you and you have to do

00:04:21,730 --> 00:04:26,260
something with them and then there's

00:04:24,310 --> 00:04:30,940
other more complicated content types

00:04:26,260 --> 00:04:34,330
like case study for an artist or maybe

00:04:30,940 --> 00:04:36,280
your client orc has varied applications

00:04:34,330 --> 00:04:39,070
you want to display it all so you can

00:04:36,280 --> 00:04:42,460
get more client work and these things

00:04:39,070 --> 00:04:45,520
lab images and media and sounds and

00:04:42,460 --> 00:04:48,460
things like that so generating these

00:04:45,520 --> 00:04:52,510
schemas is about combining these data

00:04:48,460 --> 00:04:55,960
sources so for example let's say we have

00:04:52,510 --> 00:04:57,660
a blog a lot of people raise our hands

00:04:55,960 --> 00:05:00,400
and that they're familiar with grass QL

00:04:57,660 --> 00:05:02,530
this is the grass ql shorthand for those

00:05:00,400 --> 00:05:04,390
of you who have not experienced it

00:05:02,530 --> 00:05:07,390
before but basically saying we have a

00:05:04,390 --> 00:05:11,230
query type there's a couple of sort of

00:05:07,390 --> 00:05:13,120
keys here that we can query on a post is

00:05:11,230 --> 00:05:18,310
identified by a slug and it returns you

00:05:13,120 --> 00:05:19,960
a blog post etc etc so that's our goal

00:05:18,310 --> 00:05:23,650
that's what we're trying to create from

00:05:19,960 --> 00:05:26,320
these disparate sources so for that the

00:05:23,650 --> 00:05:28,480
purposes of the schema it doesn't really

00:05:26,320 --> 00:05:31,000
matter where these are coming from when

00:05:28,480 --> 00:05:33,940
we're building our site for our client

00:05:31,000 --> 00:05:35,169
or for our company we don't care that

00:05:33,940 --> 00:05:36,430
it's coming from github

00:05:35,169 --> 00:05:39,190
we don't care there's coming from

00:05:36,430 --> 00:05:42,760
content so we just want the data which

00:05:39,190 --> 00:05:45,970
makes Gress uol a really nice solution

00:05:42,760 --> 00:05:47,919
to the problem so for the simple case

00:05:45,970 --> 00:05:51,040
you have pre-prepared

00:05:47,919 --> 00:05:53,500
content types lexmark down the

00:05:51,040 --> 00:05:56,830
frontmatter right you've got this blog

00:05:53,500 --> 00:05:59,620
post and sort of any contribute or

00:05:56,830 --> 00:06:01,060
computed properties will get stuck on

00:05:59,620 --> 00:06:05,650
this attributes key of this blog post

00:06:01,060 --> 00:06:09,070
and we have some standardized keys here

00:06:05,650 --> 00:06:12,400
one being the raw body which is a raw

00:06:09,070 --> 00:06:13,960
markdown file right just the output if

00:06:12,400 --> 00:06:16,840
you want to render it on the client side

00:06:13,960 --> 00:06:19,150
right and the other is the body which is

00:06:16,840 --> 00:06:22,990
the actual rendered markdown file and

00:06:19,150 --> 00:06:24,840
will come out as HTML and then there's

00:06:22,990 --> 00:06:27,300
the other things that you want to do too

00:06:24,840 --> 00:06:30,150
blog post as it's being processed so

00:06:27,300 --> 00:06:30,510
that you can expose on when you're

00:06:30,150 --> 00:06:32,669
querying

00:06:30,510 --> 00:06:36,510
right these things have titles these

00:06:32,669 --> 00:06:37,949
things have slugs published at the URL

00:06:36,510 --> 00:06:39,720
that you want to render it out and then

00:06:37,949 --> 00:06:44,070
maybe more exotic things like the

00:06:39,720 --> 00:06:46,110
excerpt maybe the first ten seconds

00:06:44,070 --> 00:06:48,660
worth of reading of this blog post so

00:06:46,110 --> 00:06:51,120
that you can include it in a list of 50

00:06:48,660 --> 00:06:53,250
other blog posts and then things like

00:06:51,120 --> 00:06:54,630
medium is popularized like time to read

00:06:53,250 --> 00:06:56,910
right I'm going to do a calculation

00:06:54,630 --> 00:07:00,360
based on the average words per minute of

00:06:56,910 --> 00:07:02,340
your average reader so what you can get

00:07:00,360 --> 00:07:05,720
out of this is basically if you if you

00:07:02,340 --> 00:07:09,120
construct the plug-in system you can

00:07:05,720 --> 00:07:12,180
create plugins schema fragments using

00:07:09,120 --> 00:07:15,840
basic objects in this case you can see

00:07:12,180 --> 00:07:17,070
that this post fragment is correlates

00:07:15,840 --> 00:07:20,100
very well to the schema that we saw

00:07:17,070 --> 00:07:22,289
before where you have a post you query

00:07:20,100 --> 00:07:25,199
it with a slug the slug is the unique

00:07:22,289 --> 00:07:26,760
identifier in this case and it returns

00:07:25,199 --> 00:07:29,070
you a blog post type and you have the

00:07:26,760 --> 00:07:33,870
same thing with posts for this blog post

00:07:29,070 --> 00:07:37,500
plug-in right so we if we can create

00:07:33,870 --> 00:07:39,479
these plugins fragments it becomes

00:07:37,500 --> 00:07:42,300
really important to figure out how to

00:07:39,479 --> 00:07:44,250
combine those into a graph UL schema

00:07:42,300 --> 00:07:47,460
that you can then introspect and query

00:07:44,250 --> 00:07:50,010
with say graph graphical or Apollo or

00:07:47,460 --> 00:07:52,169
relay or something like that and there

00:07:50,010 --> 00:07:54,570
are a couple options here the most

00:07:52,169 --> 00:07:57,419
common one is object at a sign funnily

00:07:54,570 --> 00:07:58,919
enough so basically you just take them

00:07:57,419 --> 00:08:02,220
and you put them all into the same

00:07:58,919 --> 00:08:05,210
object there are obvious disadvantages

00:08:02,220 --> 00:08:08,099
of that so there are other tools out

00:08:05,210 --> 00:08:10,530
such as grass QL marriage or gql merge

00:08:08,099 --> 00:08:14,130
these are two different packages on NPM

00:08:10,530 --> 00:08:19,580
right now they are both a very very very

00:08:14,130 --> 00:08:22,260
low version so Xavier for kind of thing

00:08:19,580 --> 00:08:25,860
but but they basically exist to do is

00:08:22,260 --> 00:08:28,289
merge two similarly named schema types

00:08:25,860 --> 00:08:32,010
into one and then you have to deal with

00:08:28,289 --> 00:08:34,140
a more complicated resolution function

00:08:32,010 --> 00:08:37,860
but you can actually get this scheme at

00:08:34,140 --> 00:08:40,230
emerge and then there's a further one

00:08:37,860 --> 00:08:42,180
which because we're building

00:08:40,230 --> 00:08:45,980
content-based sites and we're doing this

00:08:42,180 --> 00:08:48,390
all basically at build time we can use

00:08:45,980 --> 00:08:51,930
intersection queries and then merge the

00:08:48,390 --> 00:08:55,560
introspection query results for clients

00:08:51,930 --> 00:08:59,130
like rascal so that we can then pretend

00:08:55,560 --> 00:09:00,570
to have one graph QL API whereas some

00:08:59,130 --> 00:09:02,820
queries are actually getting sent to the

00:09:00,570 --> 00:09:07,470
github a rescue L API and some queries

00:09:02,820 --> 00:09:09,770
are hitting your disk so again the

00:09:07,470 --> 00:09:13,620
objects that assign is fairly simple you

00:09:09,770 --> 00:09:15,510
basically have some system that maps

00:09:13,620 --> 00:09:18,300
over all the plugins that you have and

00:09:15,510 --> 00:09:19,890
applies them all to the same object you

00:09:18,300 --> 00:09:24,090
get this query fields object and you

00:09:19,890 --> 00:09:27,360
stick it on your root type and this

00:09:24,090 --> 00:09:28,860
works really well it has a couple

00:09:27,360 --> 00:09:30,600
problems a couple of really obvious

00:09:28,860 --> 00:09:34,710
problems actually you get name

00:09:30,600 --> 00:09:36,540
collisions if you have multiple or

00:09:34,710 --> 00:09:37,530
multiple types that are the same names

00:09:36,540 --> 00:09:39,540
or the same

00:09:37,530 --> 00:09:42,390
similarly name types that are different

00:09:39,540 --> 00:09:45,090
things you'll get collisions when you go

00:09:42,390 --> 00:09:46,410
to actually use these and the other

00:09:45,090 --> 00:09:49,650
problem is that the types aren't really

00:09:46,410 --> 00:09:52,170
extensible right if you have a blog post

00:09:49,650 --> 00:09:55,140
that doesn't have an excerpt or doesn't

00:09:52,170 --> 00:09:57,090
have time to read and you want to add

00:09:55,140 --> 00:10:00,630
those things into that blog post you

00:09:57,090 --> 00:10:04,740
have to create a new fragment and then

00:10:00,630 --> 00:10:08,520
merge that new fragment in which is kind

00:10:04,740 --> 00:10:12,900
of a pain if you want to every usable

00:10:08,520 --> 00:10:15,480
content types across projects rescue all

00:10:12,900 --> 00:10:18,690
merging gql merge are a little more

00:10:15,480 --> 00:10:21,660
sophisticated in what they do and you

00:10:18,690 --> 00:10:26,280
can basically specify in shorthand these

00:10:21,660 --> 00:10:29,760
query schemas so in this case we have a

00:10:26,280 --> 00:10:31,500
top users query and it has a first name

00:10:29,760 --> 00:10:33,240
last name and then we have this other

00:10:31,500 --> 00:10:37,640
plug-in that's like hey by the way top

00:10:33,240 --> 00:10:40,170
users also have companies so what these

00:10:37,640 --> 00:10:41,850
these packages will do is actually merge

00:10:40,170 --> 00:10:45,600
those types when it sees that they're

00:10:41,850 --> 00:10:50,570
the same type and you get a top users

00:10:45,600 --> 00:10:53,640
query with all three of your fields

00:10:50,570 --> 00:10:57,060
so we've solved one problem and we've

00:10:53,640 --> 00:10:59,940
sort of introduced second problem we

00:10:57,060 --> 00:11:02,790
still have name collisions the types are

00:10:59,940 --> 00:11:06,330
now very extensible but with the extra

00:11:02,790 --> 00:11:09,150
extensibility comes an extra big problem

00:11:06,330 --> 00:11:10,890
with the resolve functions so now you're

00:11:09,150 --> 00:11:12,360
merging these types together but you

00:11:10,890 --> 00:11:16,860
also have to be merging these resolve

00:11:12,360 --> 00:11:17,850
functions together in some way and the

00:11:16,860 --> 00:11:20,340
other one that I'll mention is that

00:11:17,850 --> 00:11:26,430
graph QL tools also include some

00:11:20,340 --> 00:11:33,660
functions to merge types together in a

00:11:26,430 --> 00:11:35,280
similar way to object that assign just

00:11:33,660 --> 00:11:37,100
leave this up here for a brief second in

00:11:35,280 --> 00:11:40,110
case you've never seen the Apollo tools

00:11:37,100 --> 00:11:42,300
being used basically make executable

00:11:40,110 --> 00:11:43,980
schema takes a bunch of type def a bunch

00:11:42,300 --> 00:11:45,570
of resolvers and gives you something

00:11:43,980 --> 00:11:50,910
that you can execute your grassfield

00:11:45,570 --> 00:11:53,370
queries against and then maybe you want

00:11:50,910 --> 00:11:55,620
to generate some of these schemas sort

00:11:53,370 --> 00:11:57,900
of on the fly right we don't want to

00:11:55,620 --> 00:12:00,990
always have to pre write all of these

00:11:57,900 --> 00:12:05,430
blog posts and media types and things

00:12:00,990 --> 00:12:08,400
like that so if we generate them we get

00:12:05,430 --> 00:12:12,000
more reuse because that means we can use

00:12:08,400 --> 00:12:13,650
any other contents and management system

00:12:12,000 --> 00:12:15,450
like content full and we can import and

00:12:13,650 --> 00:12:17,580
export our content types out of content

00:12:15,450 --> 00:12:20,460
full and then we can introspect

00:12:17,580 --> 00:12:23,130
whatever's in content full write out our

00:12:20,460 --> 00:12:26,460
schema dot JSON file and do query

00:12:23,130 --> 00:12:29,250
analysis based on that to know if we set

00:12:26,460 --> 00:12:31,860
up our CMS correctly and then obviously

00:12:29,250 --> 00:12:35,430
the encapsulation of being able to do

00:12:31,860 --> 00:12:37,350
that and the question sort of les stands

00:12:35,430 --> 00:12:41,220
like what are we going to generate these

00:12:37,350 --> 00:12:42,960
things from and like sites like content

00:12:41,220 --> 00:12:44,490
will have REST API s where you can get

00:12:42,960 --> 00:12:47,220
introspection information about the

00:12:44,490 --> 00:12:49,860
content types that you have sitting in

00:12:47,220 --> 00:12:50,970
content soul or your CMS and then

00:12:49,860 --> 00:12:54,480
there's other things which are a little

00:12:50,970 --> 00:12:58,970
more advanced such as the github Gress

00:12:54,480 --> 00:13:02,250
ql api which obviously has very rich

00:12:58,970 --> 00:13:04,370
introspection capability because graph

00:13:02,250 --> 00:13:06,860
QL

00:13:04,370 --> 00:13:09,440
and content poll content types are just

00:13:06,860 --> 00:13:11,390
sort of like you go in you click a few

00:13:09,440 --> 00:13:16,190
buttons you have a couple fields maybe

00:13:11,390 --> 00:13:18,200
you have images it's all either GUI or

00:13:16,190 --> 00:13:19,460
API based which is really nice if you

00:13:18,200 --> 00:13:22,580
don't like it then you can you know

00:13:19,460 --> 00:13:25,430
write your own front end and we can

00:13:22,580 --> 00:13:29,450
introspect this content full content

00:13:25,430 --> 00:13:32,660
type endpoint and we end up with

00:13:29,450 --> 00:13:35,300
something that comes back and can be

00:13:32,660 --> 00:13:38,000
very directly translated into a grass ql

00:13:35,300 --> 00:13:40,220
schema alright so in this case i've cut

00:13:38,000 --> 00:13:44,470
down the response and the fields that

00:13:40,220 --> 00:13:47,960
you get back or title body category and

00:13:44,470 --> 00:13:51,290
title the type of symbol symbol and

00:13:47,960 --> 00:13:55,550
contents will speak is a very short non

00:13:51,290 --> 00:13:59,060
index string and text is there sort of

00:13:55,550 --> 00:14:01,700
long form string and then category comes

00:13:59,060 --> 00:14:03,740
back with validations on it which is

00:14:01,700 --> 00:14:07,010
basically just an enum right so we can

00:14:03,740 --> 00:14:11,840
spit out a graph QL enum and do queries

00:14:07,010 --> 00:14:13,760
based on that graph ul UNAM now and it

00:14:11,840 --> 00:14:15,740
basically looks like this when you when

00:14:13,760 --> 00:14:17,900
all is said and done you have your blog

00:14:15,740 --> 00:14:20,660
post you have a title you have a body or

00:14:17,900 --> 00:14:22,580
the category you set up a new scalar for

00:14:20,660 --> 00:14:26,180
symbol because you know content so likes

00:14:22,580 --> 00:14:31,790
to call it symbol and then you have your

00:14:26,180 --> 00:14:34,130
category which is your you know let me

00:14:31,790 --> 00:14:37,880
get look at the like the github graph QL

00:14:34,130 --> 00:14:42,590
API and this is this feels a lot like

00:14:37,880 --> 00:14:46,400
cheating I probably wouldn't do this if

00:14:42,590 --> 00:14:48,830
I was hosting a live grass QL server in

00:14:46,400 --> 00:14:50,540
production with say like user

00:14:48,830 --> 00:14:54,350
authentication and things like that

00:14:50,540 --> 00:14:56,690
just because it's uh when you when you

00:14:54,350 --> 00:14:59,210
look at the schema JSON file you

00:14:56,690 --> 00:15:00,950
basically get this data key and then

00:14:59,210 --> 00:15:02,960
this underscore underscore schema key

00:15:00,950 --> 00:15:05,120
have you never seen JQ before its

00:15:02,960 --> 00:15:08,780
command-line tool for interacting with

00:15:05,120 --> 00:15:11,450
JSON so basically just accessing data

00:15:08,780 --> 00:15:13,310
schema out of the schema JSON file

00:15:11,450 --> 00:15:15,920
piping it through and getting all the

00:15:13,310 --> 00:15:17,030
keys off that object now the one we

00:15:15,920 --> 00:15:20,540
really care about is

00:15:17,030 --> 00:15:22,940
two types the others are interesting but

00:15:20,540 --> 00:15:26,360
not really relevant to this talk and

00:15:22,940 --> 00:15:28,880
types is just an array of a very verbose

00:15:26,360 --> 00:15:31,400
way of writing all of your graph QL

00:15:28,880 --> 00:15:33,200
types so if you've ever looked at this

00:15:31,400 --> 00:15:34,850
schema dot JSON file if you've been

00:15:33,200 --> 00:15:36,560
trying to use relay or something like

00:15:34,850 --> 00:15:40,610
that you've seen this kind of thing

00:15:36,560 --> 00:15:42,110
before this file gets very long you

00:15:40,610 --> 00:15:45,050
there are a lot of things in here that

00:15:42,110 --> 00:15:46,970
you may not expect to be in here defined

00:15:45,050 --> 00:15:50,420
as types if you have never looked in

00:15:46,970 --> 00:15:53,270
here so if you have one go look at it

00:15:50,420 --> 00:15:55,850
when you go home but for example this

00:15:53,270 --> 00:15:58,460
markdown type is an object it has some

00:15:55,850 --> 00:16:02,270
fields one of them is attributes which

00:15:58,460 --> 00:16:05,780
is that computed bucket of fields that

00:16:02,270 --> 00:16:09,110
we were talking about before and then

00:16:05,780 --> 00:16:14,570
you get the type of that and so on and

00:16:09,110 --> 00:16:18,710
so forth so you can take these and if

00:16:14,570 --> 00:16:21,350
graphical sends an intersection query to

00:16:18,710 --> 00:16:24,350
your rescue elf server which at this

00:16:21,350 --> 00:16:27,980
point is basically running locally you

00:16:24,350 --> 00:16:29,750
can make the query at that time merge

00:16:27,980 --> 00:16:32,810
the introspection queries and send it

00:16:29,750 --> 00:16:35,870
back and graphical will think that you

00:16:32,810 --> 00:16:38,450
have this really nice wide graph QL

00:16:35,870 --> 00:16:41,420
endpoint that you can query so if you

00:16:38,450 --> 00:16:44,330
say have like a grass ql key you can

00:16:41,420 --> 00:16:47,860
then patch the introspection query from

00:16:44,330 --> 00:16:53,540
the grass ql api on to that key and get

00:16:47,860 --> 00:16:55,640
introspection ability in graphical that

00:16:53,540 --> 00:16:57,380
gives us a different problem and that

00:16:55,640 --> 00:17:00,350
now how do you how do you query that

00:16:57,380 --> 00:17:04,010
github key that you've created sort of

00:17:00,350 --> 00:17:08,810
artificially and if you look at the

00:17:04,010 --> 00:17:11,240
resolve function for this graph QL you

00:17:08,810 --> 00:17:13,310
see that there are a couple to it

00:17:11,240 --> 00:17:15,440
there's the root value

00:17:13,310 --> 00:17:17,420
there's the arguments there's context

00:17:15,440 --> 00:17:19,910
which is sort of a nice thing to stick

00:17:17,420 --> 00:17:22,240
things on and then there's info and info

00:17:19,910 --> 00:17:24,390
is the thing we really care about here

00:17:22,240 --> 00:17:28,439
info is this

00:17:24,390 --> 00:17:30,750
and this is not trivial now if you've

00:17:28,439 --> 00:17:34,470
never looked at the interior of grass ql

00:17:30,750 --> 00:17:37,380
types basically the one that we care

00:17:34,470 --> 00:17:40,290
about is filled a SPS which will give us

00:17:37,380 --> 00:17:44,250
the ASC is for the fields in our query

00:17:40,290 --> 00:17:45,690
at this point in the query you can see

00:17:44,250 --> 00:17:47,250
that there is another one called path

00:17:45,690 --> 00:17:49,860
which will give you your position in the

00:17:47,250 --> 00:17:55,010
query among other things like fragments

00:17:49,860 --> 00:17:57,840
and root values luckily there's a

00:17:55,010 --> 00:17:59,580
package that people have written so that

00:17:57,840 --> 00:18:02,309
you don't have to go in and manually

00:17:59,580 --> 00:18:04,530
merge all this stuff together basically

00:18:02,309 --> 00:18:06,540
you use graph you all parks fields or

00:18:04,530 --> 00:18:08,250
something like it you apply it to this

00:18:06,540 --> 00:18:09,750
info type which has all of the

00:18:08,250 --> 00:18:14,990
information you actually need to figure

00:18:09,750 --> 00:18:18,679
out what to do with the ast and you get

00:18:14,990 --> 00:18:21,350
effectively this parse sub query and

00:18:18,679 --> 00:18:25,890
this part sub query is really nice

00:18:21,350 --> 00:18:32,040
because it looks super familiar it's

00:18:25,890 --> 00:18:34,470
basically already grass QL and then you

00:18:32,040 --> 00:18:37,559
can send that to github you can get the

00:18:34,470 --> 00:18:40,370
query back and then you can send it back

00:18:37,559 --> 00:18:40,370
down the suppliant

00:18:41,150 --> 00:18:50,640
so that is graph QL API is for content

00:18:45,179 --> 00:18:52,380
based sites I hope you learned how we

00:18:50,640 --> 00:18:57,000
might be able to reuse these content

00:18:52,380 --> 00:18:59,450
types across projects exposing the

00:18:57,000 --> 00:19:04,049
processed data behind them is a

00:18:59,450 --> 00:19:05,880
different talk in itself merging grass

00:19:04,049 --> 00:19:07,080
ql schemas there's a couple issues here

00:19:05,880 --> 00:19:08,370
if you're interested in that kind of

00:19:07,080 --> 00:19:10,770
thing

00:19:08,370 --> 00:19:12,419
content fold there's a link here too and

00:19:10,770 --> 00:19:14,450
then the project that I was talking

00:19:12,419 --> 00:19:17,610
about Leo which implements these ideas

00:19:14,450 --> 00:19:19,919
is at super-awesome labs slash leo if

00:19:17,610 --> 00:19:23,549
you are interested in that I'm happy to

00:19:19,919 --> 00:19:25,940
answer any questions either now or file

00:19:23,549 --> 00:19:25,940
an issue

00:19:27,480 --> 00:19:36,600
[Applause]

00:19:33,600 --> 00:19:36,600
question

00:19:40,580 --> 00:19:48,350
so the whole merging remote things like

00:19:45,350 --> 00:19:50,270
is have you have you felt like proof of

00:19:48,350 --> 00:19:52,130
concepts of this or have you felt like

00:19:50,270 --> 00:19:55,010
you think this is going to be something

00:19:52,130 --> 00:19:57,590
that's like can work with any third

00:19:55,010 --> 00:20:00,200
party graphical endpoint or is it always

00:19:57,590 --> 00:20:03,890
going to be I think that it case-by-case

00:20:00,200 --> 00:20:05,750
it can work as long as the so basically

00:20:03,890 --> 00:20:07,940
the one of the big issues is how you

00:20:05,750 --> 00:20:09,530
rename the types that are in that API so

00:20:07,940 --> 00:20:11,690
that you can access against it on their

00:20:09,530 --> 00:20:16,340
own name and basically the standing

00:20:11,690 --> 00:20:17,930
solution to that is prefix it right yeah

00:20:16,340 --> 00:20:21,410
it's not a pretty solution but it works

00:20:17,930 --> 00:20:22,220
yeah I don't know if this will become

00:20:21,410 --> 00:20:25,850
common practice

00:20:22,220 --> 00:20:28,820
just because authentication and graph QL

00:20:25,850 --> 00:20:31,820
api's isn't necessarily a solved problem

00:20:28,820 --> 00:20:33,470
for everybody and things like that like

00:20:31,820 --> 00:20:36,530
subscriptions like how would you merge

00:20:33,470 --> 00:20:38,600
that in and then access it become a

00:20:36,530 --> 00:20:40,730
little more complicated but in this

00:20:38,600 --> 00:20:43,100
basic sort of situation that we're

00:20:40,730 --> 00:20:45,650
talking about yeah yeah well I think

00:20:43,100 --> 00:20:50,300
would be like enough open you know

00:20:45,650 --> 00:20:53,080
graphical instances that a generic NPM

00:20:50,300 --> 00:20:57,580
package Spadina don't like we could use

00:20:53,080 --> 00:20:57,580
okay I know it's not yeah yeah

00:21:00,740 --> 00:21:10,019
another question cool well if nobody has

00:21:07,350 --> 00:21:13,049
another question I actually have one so

00:21:10,019 --> 00:21:15,269
is this stuff that you actually use in

00:21:13,049 --> 00:21:17,940
your day-to-day work now or is it like

00:21:15,269 --> 00:21:20,580
something that you just like playing

00:21:17,940 --> 00:21:22,559
with and came up with on the side I came

00:21:20,580 --> 00:21:25,559
up with it on the side and now anytime I

00:21:22,559 --> 00:21:28,049
have to build sort of a static site or a

00:21:25,559 --> 00:21:31,890
progressive web app that has mostly

00:21:28,049 --> 00:21:35,669
static content I use it and you do find

00:21:31,890 --> 00:21:37,289
that like to actually make it faster for

00:21:35,669 --> 00:21:40,590
you or just like an intellectual

00:21:37,289 --> 00:21:43,740
exercise yeah it makes a lot faster for

00:21:40,590 --> 00:21:45,990
me because I get to reuse Solio actually

00:21:43,740 --> 00:21:48,809
has a lot of things on the backend of

00:21:45,990 --> 00:21:51,510
this that make it really nice for

00:21:48,809 --> 00:21:53,909
building say progressive web app with

00:21:51,510 --> 00:21:57,799
pre-act and reusing my component library

00:21:53,909 --> 00:22:00,510
that I built over here and not have to

00:21:57,799 --> 00:22:02,100
rebuild all of those components and then

00:22:00,510 --> 00:22:04,740
use them and like Jekyll or something

00:22:02,100 --> 00:22:07,110
like that the way it works is basically

00:22:04,740 --> 00:22:09,899
like you have a universal application

00:22:07,110 --> 00:22:11,580
and you render out your HTML pages in

00:22:09,899 --> 00:22:13,409
this Universal application and then you

00:22:11,580 --> 00:22:16,049
render out JSON files which you can then

00:22:13,409 --> 00:22:17,610
query with Apollo so it's a combination

00:22:16,049 --> 00:22:19,610
of all of those different things that

00:22:17,610 --> 00:22:21,899
make it actually very productive and

00:22:19,610 --> 00:22:24,090
then you get to quote we use cool tools

00:22:21,899 --> 00:22:26,539
like glamour if you want to that's that

00:22:24,090 --> 00:22:26,539

YouTube URL: https://www.youtube.com/watch?v=bc_28oOhoBQ


