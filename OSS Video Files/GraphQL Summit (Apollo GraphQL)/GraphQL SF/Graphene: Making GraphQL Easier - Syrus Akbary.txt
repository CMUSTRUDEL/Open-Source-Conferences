Title: Graphene: Making GraphQL Easier - Syrus Akbary
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	At GraphQL San Francisco's first meetup, Affirm's Syrus Akbary talks about how his project Graphene makes it easier to use GraphQL in Python (and beyond). 

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/
Read our event summary on Medium: https://medium.com/apollo-stack/graphql-in-2016-a-growing-ecosystem-89846d9bb29e#.tis6c7a0r
Captions: 
	00:00:02,510 --> 00:00:09,620
hi everyone and welcome to graph Q all

00:00:05,840 --> 00:00:11,930
in 2016 it's really exciting to see so

00:00:09,620 --> 00:00:13,670
many people here and yeah we didn't

00:00:11,930 --> 00:00:16,100
think that when we organized this meetup

00:00:13,670 --> 00:00:17,980
just about two weeks ago we also have a

00:00:16,100 --> 00:00:21,380
great lineup of speakers tonight

00:00:17,980 --> 00:00:23,480
including people from Facebook

00:00:21,380 --> 00:00:26,300
Joe Cibona the Crete and then we have

00:00:23,480 --> 00:00:28,670
the creator of graphene Cyrus Akbari

00:00:26,300 --> 00:00:30,890
here we have my colleague sashko Stabilo

00:00:28,670 --> 00:00:34,179
who's working on a palo stack and we

00:00:30,890 --> 00:00:37,640
have clay Allsop who built graphical hub

00:00:34,179 --> 00:00:41,359
so my name is jonas Helfer I also work

00:00:37,640 --> 00:00:42,920
on Apollo stack here at meteor and I'm

00:00:41,359 --> 00:00:45,859
going to give you a very quick intro

00:00:42,920 --> 00:00:48,109
into graph QL for those who are not

00:00:45,859 --> 00:00:50,179
super familiar with yet with it yet I'm

00:00:48,109 --> 00:00:51,469
sure the other speakers will also give

00:00:50,179 --> 00:00:52,670
you things like that will help you

00:00:51,469 --> 00:00:54,829
understand graphic you all better

00:00:52,670 --> 00:00:56,989
and then there's plenty of resources

00:00:54,829 --> 00:01:01,010
online that you can go to look it up

00:00:56,989 --> 00:01:04,129
okay so um here's graph Q all in a

00:01:01,010 --> 00:01:08,120
nutshell graph QL is basically uh why do

00:01:04,129 --> 00:01:12,020
I still hear the music by the way okay

00:01:08,120 --> 00:01:14,210
yeah nevermind sorry so graph QL in a

00:01:12,020 --> 00:01:16,850
nutshell graph QL is a layer between

00:01:14,210 --> 00:01:18,860
your backends and your front-end so you

00:01:16,850 --> 00:01:20,860
can put that in and it's a nice layer of

00:01:18,860 --> 00:01:23,120
abstraction that will help your

00:01:20,860 --> 00:01:25,280
front-ends communicate with any back-end

00:01:23,120 --> 00:01:27,410
so that can be any kind of front-end it

00:01:25,280 --> 00:01:30,980
can be an iOS client it can be Android

00:01:27,410 --> 00:01:33,620
this can be react it can be angular

00:01:30,980 --> 00:01:35,270
anything you want and backends it's the

00:01:33,620 --> 00:01:37,880
same it can communicate with rest

00:01:35,270 --> 00:01:39,860
backends it can communicate with sequel

00:01:37,880 --> 00:01:41,810
it's all up to you to set it up so graph

00:01:39,860 --> 00:01:43,790
QL is really just the nice layer of

00:01:41,810 --> 00:01:47,690
abstraction in between that's kind of

00:01:43,790 --> 00:01:49,100
been missing from restful api is what's

00:01:47,690 --> 00:01:51,860
really nice with graph QL is that

00:01:49,100 --> 00:01:53,480
clients can fetch all the data in just a

00:01:51,860 --> 00:01:56,270
single round trip so they fetch all the

00:01:53,480 --> 00:01:58,130
data necessary for a view to just be

00:01:56,270 --> 00:02:00,470
displayed in a single round trip now

00:01:58,130 --> 00:02:03,409
contrast that with rest endpoints where

00:02:00,470 --> 00:02:04,970
you either where you either split up

00:02:03,409 --> 00:02:06,770
your rest endpoint to have one endpoint

00:02:04,970 --> 00:02:09,349
for each model and then you have to do

00:02:06,770 --> 00:02:11,840
multiple round trips to put together all

00:02:09,349 --> 00:02:14,239
your hierarchical data or you make

00:02:11,840 --> 00:02:16,069
custom end points for just each view in

00:02:14,239 --> 00:02:18,469
graph QL you don't need to do any of

00:02:16,069 --> 00:02:21,439
at different clients all use the same

00:02:18,469 --> 00:02:25,310
endpoint they fetch all the data for one

00:02:21,439 --> 00:02:27,379
view and one round-trip usually um it's

00:02:25,310 --> 00:02:28,939
also nice about graph QL is you will not

00:02:27,379 --> 00:02:31,159
have any over fetching and you will not

00:02:28,939 --> 00:02:33,230
have any under fetching clients specify

00:02:31,159 --> 00:02:35,480
exactly the data that they need in the

00:02:33,230 --> 00:02:38,650
graphical server sends them that data in

00:02:35,480 --> 00:02:40,969
the shape they ask for not more not less

00:02:38,650 --> 00:02:42,650
what that also means is that you don't

00:02:40,969 --> 00:02:46,159
have headaches with versioning of your

00:02:42,650 --> 00:02:47,840
API anymore if you have iOS clients that

00:02:46,159 --> 00:02:50,419
you know where people don't update their

00:02:47,840 --> 00:02:52,939
app for four years but you still want

00:02:50,419 --> 00:02:54,349
them to be able to use your service you

00:02:52,939 --> 00:02:56,329
don't have that headache with graph QL

00:02:54,349 --> 00:02:58,579
because you can just apps you can add

00:02:56,329 --> 00:03:00,409
new fields and those old clients can

00:02:58,579 --> 00:03:02,180
keep sending their queries get exactly

00:03:00,409 --> 00:03:04,639
the data that they want while new

00:03:02,180 --> 00:03:06,859
clients that support the new feature get

00:03:04,639 --> 00:03:10,459
the data that they want with the new

00:03:06,859 --> 00:03:12,260
features supported a really nice thing

00:03:10,459 --> 00:03:17,540
about graph QL is that it's strongly

00:03:12,260 --> 00:03:20,659
typed so what that means is clients can

00:03:17,540 --> 00:03:22,519
ask what is the server support what is

00:03:20,659 --> 00:03:25,370
this field what is this type

00:03:22,519 --> 00:03:26,780
is that an integer is that a string how

00:03:25,370 --> 00:03:28,849
do these different types relate to each

00:03:26,780 --> 00:03:31,370
other and with that you can build

00:03:28,849 --> 00:03:33,680
amazing tools like graphical which is an

00:03:31,370 --> 00:03:35,930
in-browser IDE for exploring your API

00:03:33,680 --> 00:03:38,449
you also get your documentation

00:03:35,930 --> 00:03:41,060
essentially built in and my colleague

00:03:38,449 --> 00:03:44,030
Sasha Costa bio has actually made an es

00:03:41,060 --> 00:03:46,699
lint plugin that will let you in as you

00:03:44,030 --> 00:03:48,470
type in your editor will tell you when

00:03:46,699 --> 00:03:50,810
you're writing a query for graph queue

00:03:48,470 --> 00:03:52,909
all that contains a typo or that's

00:03:50,810 --> 00:03:54,259
asking for data that's not there now

00:03:52,909 --> 00:03:55,909
imagine if you could do that with your

00:03:54,259 --> 00:03:57,560
rest endpoints if you could write a URL

00:03:55,909 --> 00:03:59,209
and your editor would tell you oh

00:03:57,560 --> 00:04:00,919
actually you need to use a different

00:03:59,209 --> 00:04:04,099
argument here with graphic you all you

00:04:00,919 --> 00:04:06,799
have none of these problems um so just a

00:04:04,099 --> 00:04:08,780
very quick look on the left here we have

00:04:06,799 --> 00:04:11,209
a graph QL query as you can see it's

00:04:08,780 --> 00:04:14,389
sort of like JSON it's a hierarchical

00:04:11,209 --> 00:04:16,519
query and here we're asking for a first

00:04:14,389 --> 00:04:18,799
name of an author and all the posts that

00:04:16,519 --> 00:04:22,460
this author is written along with the

00:04:18,799 --> 00:04:25,760
title and on the right side we get the

00:04:22,460 --> 00:04:28,460
reply and you'll see that the shape of

00:04:25,760 --> 00:04:29,660
the reply is actually the same as the

00:04:28,460 --> 00:04:32,600
query which is another

00:04:29,660 --> 00:04:34,220
nice thing about graph QL now if you had

00:04:32,600 --> 00:04:36,800
an other client that also wants the last

00:04:34,220 --> 00:04:38,030
name of the author that would easy be

00:04:36,800 --> 00:04:40,330
easy to do and you would just add that

00:04:38,030 --> 00:04:43,100
field

00:04:40,330 --> 00:04:46,580
so here sort of to emphasize the

00:04:43,100 --> 00:04:47,960
contrast with rest like or restful I

00:04:46,580 --> 00:04:50,960
don't want to get into an argument you

00:04:47,960 --> 00:04:53,630
know what's proper rest but usually rest

00:04:50,960 --> 00:04:54,950
api's will kind of look the way you see

00:04:53,630 --> 00:04:57,140
on the left side where you have

00:04:54,950 --> 00:04:59,420
different end points for different types

00:04:57,140 --> 00:05:02,330
of data and they might talk to one or

00:04:59,420 --> 00:05:04,370
more databases in the backend so how you

00:05:02,330 --> 00:05:06,410
wire that up is really up to you and you

00:05:04,370 --> 00:05:08,300
put that into your rest endpoint now

00:05:06,410 --> 00:05:10,070
contrast that with graph QL on the right

00:05:08,300 --> 00:05:11,870
side where you really have one endpoint

00:05:10,070 --> 00:05:14,000
and all clients talk to that one

00:05:11,870 --> 00:05:15,800
endpoint and they send a single query

00:05:14,000 --> 00:05:17,840
and then the graph QL server figures out

00:05:15,800 --> 00:05:25,790
which backends to talk to to get the

00:05:17,840 --> 00:05:27,290
data and so graph QL is really more of a

00:05:25,790 --> 00:05:29,330
an idea

00:05:27,290 --> 00:05:31,430
so graph Jia has a specification it's

00:05:29,330 --> 00:05:33,380
not an implementation it's not for a

00:05:31,430 --> 00:05:35,660
specific language for specific type of

00:05:33,380 --> 00:05:37,490
technology it's really an idea and

00:05:35,660 --> 00:05:39,560
there's there are many implementations

00:05:37,490 --> 00:05:41,570
in different languages and it's really

00:05:39,560 --> 00:05:44,210
exciting to see how the graph QL

00:05:41,570 --> 00:05:46,100
ecosystem is growing very quickly and so

00:05:44,210 --> 00:05:48,650
we have you know we have JavaScript

00:05:46,100 --> 00:05:51,280
implementations Python there's Ruby

00:05:48,650 --> 00:05:54,140
there is implementations in Haskell

00:05:51,280 --> 00:05:56,480
dotnet really a lot of them and here

00:05:54,140 --> 00:05:59,330
I've just put a few a few of the logos

00:05:56,480 --> 00:06:00,890
and actually for four of them we'll have

00:05:59,330 --> 00:06:03,200
speakers tonight so the first one is

00:06:00,890 --> 00:06:05,330
going to be cyrus akbari for graphene

00:06:03,200 --> 00:06:08,270
then after him we'll have my colleague

00:06:05,330 --> 00:06:10,190
sashko Stabilo for apollo stack and then

00:06:08,270 --> 00:06:13,310
we have Joe sivanna from Facebook who

00:06:10,190 --> 00:06:15,590
will be talking about relay and last but

00:06:13,310 --> 00:06:17,330
not least we have we have clay toss-up

00:06:15,590 --> 00:06:20,120
who will be talking about graph QL hub

00:06:17,330 --> 00:06:21,440
so without further ado I'm going to hand

00:06:20,120 --> 00:06:24,740
over to Cyrus

00:06:21,440 --> 00:06:27,590
Akbari the creator of graphene who will

00:06:24,740 --> 00:06:30,530
be talking about implementing I think

00:06:27,590 --> 00:06:32,419
implementing how he implemented graphic

00:06:30,530 --> 00:06:37,419
you all in Python and what you can do

00:06:32,419 --> 00:06:37,419
with it that's it okay

00:06:39,220 --> 00:06:44,030
hello everybody

00:06:40,790 --> 00:06:46,250
so I'm serious Akbari today I'm the

00:06:44,030 --> 00:06:48,740
creator of graphene graphene is a

00:06:46,250 --> 00:06:50,630
framework for Python than let us create

00:06:48,740 --> 00:06:53,030
graphical schemas or operate with

00:06:50,630 --> 00:06:55,160
graphical in Python very easily and

00:06:53,030 --> 00:06:57,470
today I'm going to talk about what this

00:06:55,160 --> 00:07:00,920
graph cool Jonas did a very great

00:06:57,470 --> 00:07:03,500
introduction but I'm gonna I'm going to

00:07:00,920 --> 00:07:05,810
do it too then we'll see a little bit

00:07:03,500 --> 00:07:08,090
about graphing but not too much and then

00:07:05,810 --> 00:07:11,330
we will research about what we can do to

00:07:08,090 --> 00:07:13,820
make graphical better a second-team so

00:07:11,330 --> 00:07:15,680
first is right what is graph cool

00:07:13,820 --> 00:07:17,510
I want to ask you like how many of you

00:07:15,680 --> 00:07:22,610
already know what is graphically please

00:07:17,510 --> 00:07:25,490
raise your hands Lea perfect ok so it's

00:07:22,610 --> 00:07:27,680
almost half and half so I'm going to say

00:07:25,490 --> 00:07:29,450
almost the same thing as he did so graph

00:07:27,680 --> 00:07:33,230
QL is a query language created by

00:07:29,450 --> 00:07:35,090
Facebook that let us query exactly the

00:07:33,230 --> 00:07:37,790
data we want and we want without under

00:07:35,090 --> 00:07:40,010
fetching or over fetching data so if we

00:07:37,790 --> 00:07:43,340
expect to receive this data this how

00:07:40,010 --> 00:07:46,610
actually we have to query so as I said

00:07:43,340 --> 00:07:48,500
we only the graph QL query just look at

00:07:46,610 --> 00:07:51,560
the JSON but we have the values and

00:07:48,500 --> 00:07:54,410
that's great but what's the real thing

00:07:51,560 --> 00:07:56,720
like what we really love graph QL the

00:07:54,410 --> 00:07:59,060
memory so is the main reason is because

00:07:56,720 --> 00:08:02,420
we swap the responsibility of querying

00:07:59,060 --> 00:08:05,030
from the server to a client so before we

00:08:02,420 --> 00:08:08,420
have like all this data just in one RPC

00:08:05,030 --> 00:08:10,250
endpoint in our API this logic were

00:08:08,420 --> 00:08:12,620
living the server and actually when we

00:08:10,250 --> 00:08:15,170
want to add a new client like Android or

00:08:12,620 --> 00:08:17,840
whatever we have to add list logic again

00:08:15,170 --> 00:08:20,420
into the deserve PC endpoint but

00:08:17,840 --> 00:08:22,550
actually it makes more sense to let the

00:08:20,420 --> 00:08:25,850
client the data it wants and not the

00:08:22,550 --> 00:08:29,300
server so let's go again to this example

00:08:25,850 --> 00:08:31,490
so we want to fetch a user mean and we

00:08:29,300 --> 00:08:34,160
want to fetch the fields name company

00:08:31,490 --> 00:08:38,390
and friends and from friends we want to

00:08:34,160 --> 00:08:40,430
fetch the name so in graph coil we

00:08:38,390 --> 00:08:42,800
define the core the root query which is

00:08:40,430 --> 00:08:45,710
like the root type that we access when

00:08:42,800 --> 00:08:48,260
we query and this root query type have

00:08:45,710 --> 00:08:49,570
the me feel which is returning a user

00:08:48,260 --> 00:08:50,890
type which have

00:08:49,570 --> 00:08:53,950
same company and friends on it I'm

00:08:50,890 --> 00:08:57,730
friends this is just returning a list of

00:08:53,950 --> 00:09:00,250
users so for example if your Python guys

00:08:57,730 --> 00:09:03,010
this is how you have to implement it in

00:09:00,250 --> 00:09:04,660
Python and actually is not very readable

00:09:03,010 --> 00:09:06,970
it's not very easy to follow what's

00:09:04,660 --> 00:09:09,460
happening so what I was applying in

00:09:06,970 --> 00:09:11,530
Python like what I was trying to make

00:09:09,460 --> 00:09:13,210
graphically schemas in Python I realized

00:09:11,530 --> 00:09:16,480
that I didn't like the way of writing

00:09:13,210 --> 00:09:20,730
graphical schemas it was not natural for

00:09:16,480 --> 00:09:22,810
me so why can not make it simpler

00:09:20,730 --> 00:09:24,550
doesn't mean recently I decided to

00:09:22,810 --> 00:09:26,620
create the framework graph in Python as

00:09:24,550 --> 00:09:28,960
I told you before graph in Python is a

00:09:26,620 --> 00:09:31,720
framework for operating with graphical

00:09:28,960 --> 00:09:35,290
in Python very easily so let's see an

00:09:31,720 --> 00:09:38,410
example and see how it works so we

00:09:35,290 --> 00:09:40,210
define classes and types on we define

00:09:38,410 --> 00:09:42,820
graph coil types on top of Python

00:09:40,210 --> 00:09:45,640
classes then we define the attributes

00:09:42,820 --> 00:09:48,520
the - act as graphical fields and we

00:09:45,640 --> 00:09:50,530
define how what are these habits for so

00:09:48,520 --> 00:09:52,480
for example name is a string company's a

00:09:50,530 --> 00:09:55,060
string and Friends is just a list of

00:09:52,480 --> 00:09:57,850
self which in this case is a list of

00:09:55,060 --> 00:10:00,970
users a me is just referencing the user

00:09:57,850 --> 00:10:03,010
and also we move the resolvers to the

00:10:00,970 --> 00:10:07,660
class so actually it's much easier to

00:10:03,010 --> 00:10:09,640
see where our resolver belongs so what

00:10:07,660 --> 00:10:11,050
are the main features of riffin we have

00:10:09,640 --> 00:10:13,990
integration with Django

00:10:11,050 --> 00:10:16,690
seek welcoming and as of two weeks ago

00:10:13,990 --> 00:10:20,440
we also have google appengine support

00:10:16,690 --> 00:10:23,830
and thanks to Eric camp because he did a

00:10:20,440 --> 00:10:25,990
very great work on that and also we

00:10:23,830 --> 00:10:27,760
added two weeks ago middleware which I'm

00:10:25,990 --> 00:10:31,140
gonna research a little a little bit

00:10:27,760 --> 00:10:34,300
what is Mill were actually in graph QL

00:10:31,140 --> 00:10:39,940
so also I would like to give thanks to

00:10:34,300 --> 00:10:41,680
our community as a us today is graphene

00:10:39,940 --> 00:10:46,260
is the most asturian on JavaScript graft

00:10:41,680 --> 00:10:49,270
will repository so thank you everyone so

00:10:46,260 --> 00:10:51,280
next question how we can take graft

00:10:49,270 --> 00:10:53,500
world to the next level what we can do

00:10:51,280 --> 00:10:56,080
to make it better so while I was working

00:10:53,500 --> 00:10:57,820
with graphene in the backend and relay

00:10:56,080 --> 00:10:59,379
in the front-end I realized a lot of

00:10:57,820 --> 00:11:02,229
things that could make

00:10:59,379 --> 00:11:05,759
that could make my therefore of

00:11:02,229 --> 00:11:09,129
developing graphical schemas much easier

00:11:05,759 --> 00:11:11,229
so one is live queries if you see my

00:11:09,129 --> 00:11:13,509
presentation in the reactors comp I was

00:11:11,229 --> 00:11:16,359
trying to a complicit thing but after

00:11:13,509 --> 00:11:18,759
researching a lot I realize how hard it

00:11:16,359 --> 00:11:21,789
was to implement live queries without

00:11:18,759 --> 00:11:24,639
imposing how we have to handle that I

00:11:21,789 --> 00:11:26,859
actually like the way reactive X is

00:11:24,639 --> 00:11:29,019
doing but I just want to wait until

00:11:26,859 --> 00:11:32,889
leave iron and probably material is a

00:11:29,019 --> 00:11:35,199
good solution for that next one

00:11:32,889 --> 00:11:37,119
validation what I mean with validation

00:11:35,199 --> 00:11:39,819
if we actually already have validation

00:11:37,119 --> 00:11:41,739
in gradua right so imagine we want to

00:11:39,819 --> 00:11:44,349
create a user and we use the graphical

00:11:41,739 --> 00:11:46,869
mutation a gradual mutation is just an

00:11:44,349 --> 00:11:49,479
action that we take in our data in your

00:11:46,869 --> 00:11:51,549
graph QL schema so we want to create a

00:11:49,479 --> 00:11:53,769
user and we expect to receive HSI

00:11:51,549 --> 00:11:56,169
integer and will receive a string then

00:11:53,769 --> 00:11:57,879
graph will do a great job there and just

00:11:56,169 --> 00:12:01,569
like don't let sorry

00:11:57,879 --> 00:12:03,699
and don't let us to run this query like

00:12:01,569 --> 00:12:06,729
it will stop the execution because if

00:12:03,699 --> 00:12:09,879
the data the query that we are doing is

00:12:06,729 --> 00:12:11,739
not valid but what happens for example

00:12:09,879 --> 00:12:15,129
if we want to create a user and we

00:12:11,739 --> 00:12:17,169
expect to receive a email but email as

00:12:15,129 --> 00:12:19,269
all we know email as a string is a

00:12:17,169 --> 00:12:22,809
string right so in graphical for

00:12:19,269 --> 00:12:25,089
handling this thing we can either create

00:12:22,809 --> 00:12:28,989
a new type ml type which is kind of a

00:12:25,089 --> 00:12:32,169
string which validation or we can add

00:12:28,989 --> 00:12:36,669
the validation in the resolver but if we

00:12:32,169 --> 00:12:39,279
do that what happen the validation will

00:12:36,669 --> 00:12:41,919
be only available server-side is living

00:12:39,279 --> 00:12:44,529
in where the resolver lives so it's not

00:12:41,919 --> 00:12:46,779
very easy it's not very easy not sorry

00:12:44,529 --> 00:12:51,009
is not good because we cannot replicate

00:12:46,779 --> 00:12:53,889
easily or client and also it will be

00:12:51,009 --> 00:12:56,109
validated but not stopping the execution

00:12:53,889 --> 00:12:57,759
of the graphical query which is well

00:12:56,109 --> 00:13:00,369
actually if we are running mutation we

00:12:57,759 --> 00:13:03,009
want to stop if we are not doing a valid

00:13:00,369 --> 00:13:05,199
query right so what's the proposal here

00:13:03,009 --> 00:13:07,419
one thing that we can do in Brockville

00:13:05,199 --> 00:13:10,449
is just a new typed into the schema

00:13:07,419 --> 00:13:12,640
which is evaluation type or we can also

00:13:10,449 --> 00:13:16,190
use directives

00:13:12,640 --> 00:13:18,170
so another thing I would like to talk

00:13:16,190 --> 00:13:20,120
about is the planning phase what I mean

00:13:18,170 --> 00:13:22,190
with planning phase with learning phase

00:13:20,120 --> 00:13:24,380
I mean that actually when we are

00:13:22,190 --> 00:13:26,360
querying any kind of data when we are

00:13:24,380 --> 00:13:28,630
resolving a field it could know what are

00:13:26,360 --> 00:13:32,120
these who feels that we are querying and

00:13:28,630 --> 00:13:36,350
we are adding a phase between validation

00:13:32,120 --> 00:13:38,330
and really solving for fetching just the

00:13:36,350 --> 00:13:41,240
data we need so for example without

00:13:38,330 --> 00:13:42,740
planning phase we will query in our

00:13:41,240 --> 00:13:44,960
database like we will select everything

00:13:42,740 --> 00:13:46,910
but if we have some kind of planning

00:13:44,960 --> 00:13:49,850
phase we can know what feels we are

00:13:46,910 --> 00:13:51,880
requesting from the user and just query

00:13:49,850 --> 00:13:54,320
that from the database so that's good

00:13:51,880 --> 00:13:57,820
actually we can already do that in the

00:13:54,320 --> 00:14:01,280
resolver but it's not a very clean way

00:13:57,820 --> 00:14:03,410
okay one one of the things I'm more

00:14:01,280 --> 00:14:06,500
proud of is neither word but what I mean

00:14:03,410 --> 00:14:09,260
with middle were in graph QL in Express

00:14:06,500 --> 00:14:11,180
or Co are any kind of no GS framework we

00:14:09,260 --> 00:14:15,140
have middle word and what it means is we

00:14:11,180 --> 00:14:17,120
can modify the request at some point but

00:14:15,140 --> 00:14:19,820
in graphical we we don't have any paths

00:14:17,120 --> 00:14:23,570
or whatever so but we have we can

00:14:19,820 --> 00:14:24,110
assimilate our URL URI to a graph QL

00:14:23,570 --> 00:14:26,030
field

00:14:24,110 --> 00:14:28,490
so actually what I mean with middleware

00:14:26,030 --> 00:14:31,790
in graph QL is you can use it for affect

00:14:28,490 --> 00:14:33,740
the resolution of your fields in anytime

00:14:31,790 --> 00:14:35,660
at any time at the beginning when you

00:14:33,740 --> 00:14:40,280
are resolving in the middle or after

00:14:35,660 --> 00:14:42,410
easily resolved so this is actually

00:14:40,280 --> 00:14:44,480
already implemented in graphene but this

00:14:42,410 --> 00:14:46,580
is not just in graphene you can have

00:14:44,480 --> 00:14:48,800
mill warning radical Ruby and you can

00:14:46,580 --> 00:14:50,900
have malware in sangria so you can see

00:14:48,800 --> 00:14:52,880
how three very different frameworks that

00:14:50,900 --> 00:14:55,430
are not implemented in the same way we

00:14:52,880 --> 00:14:58,330
almost go to the same approach so let's

00:14:55,430 --> 00:15:02,000
see an example and how it looks

00:14:58,330 --> 00:15:06,530
middle warring graphene so this is out

00:15:02,000 --> 00:15:08,420
of 30 facial millwork that will be

00:15:06,530 --> 00:15:11,839
called it's time we resolve a field and

00:15:08,420 --> 00:15:15,200
we will check what is the return type

00:15:11,839 --> 00:15:17,270
for this field and if the user in the

00:15:15,200 --> 00:15:20,210
context doesn't have permission for

00:15:17,270 --> 00:15:22,490
access this return type then we will

00:15:20,210 --> 00:15:25,130
return now so we don't need to add this

00:15:22,490 --> 00:15:26,089
logic into all or resolve it and that's

00:15:25,130 --> 00:15:27,860
great

00:15:26,089 --> 00:15:30,410
but other example for example we want to

00:15:27,860 --> 00:15:34,579
have rate-limiting in our inner graph QL

00:15:30,410 --> 00:15:36,350
schema so for implemented the only thing

00:15:34,579 --> 00:15:38,629
that we have to do is just create a

00:15:36,350 --> 00:15:41,509
counter in the context and it's time we

00:15:38,629 --> 00:15:44,420
are resolving we implement we increment

00:15:41,509 --> 00:15:47,720
the counter if we resolve it correctly

00:15:44,420 --> 00:15:50,689
and if it reach the limit will return on

00:15:47,720 --> 00:15:55,579
for example you can raise an error or

00:15:50,689 --> 00:15:59,480
whatever you want and that's great so in

00:15:55,579 --> 00:16:04,420
conclusion we love we love graphical so

00:15:59,480 --> 00:16:04,420
let's make it better together thank you

00:16:08,890 --> 00:16:13,430
you have any question yeah we have about

00:16:11,900 --> 00:16:17,530
we have a couple minutes for questions

00:16:13,430 --> 00:16:17,530
so if anybody has a question for Syrus

00:16:18,550 --> 00:16:23,390
navigation all right if no one has a

00:16:21,380 --> 00:16:26,720
question then I have a question for you

00:16:23,390 --> 00:16:28,640
so what what inspired you to what was

00:16:26,720 --> 00:16:31,280
the sort of first inspiration for you to

00:16:28,640 --> 00:16:34,580
create graphene okay the main

00:16:31,280 --> 00:16:36,590
inspiration was like I said creating

00:16:34,580 --> 00:16:38,630
graphical schemas was not easy in

00:16:36,590 --> 00:16:41,540
Nehring JavaScript or even Python like I

00:16:38,630 --> 00:16:43,700
I was not feeling comfortable with it so

00:16:41,540 --> 00:16:45,770
as I was not feeling comfortable I just

00:16:43,700 --> 00:16:48,170
want to create a tool where I can write

00:16:45,770 --> 00:16:49,820
graphical schemas very easily so for

00:16:48,170 --> 00:16:51,950
example when I implemented graphene I

00:16:49,820 --> 00:16:53,540
started with the sink with with the way

00:16:51,950 --> 00:16:55,820
I want to use it before implementing

00:16:53,540 --> 00:16:58,580
anything and also I have the syntax

00:16:55,820 --> 00:17:01,460
which is like the true value of graphene

00:16:58,580 --> 00:17:04,220
I can make any kind of implementation so

00:17:01,460 --> 00:17:06,500
actually we switch we do three very big

00:17:04,220 --> 00:17:10,250
refractors but as the syntax remains

00:17:06,500 --> 00:17:14,090
valid we don't have to do any change on

00:17:10,250 --> 00:17:18,070
the graphene implementations so that was

00:17:14,090 --> 00:17:35,500
good I like it yeah that's great

00:17:18,070 --> 00:17:35,500
any questions from the audience yes yes

00:17:38,800 --> 00:17:44,810
it's implemented actually the middleware

00:17:41,540 --> 00:17:47,710
is called always the like always it's

00:17:44,810 --> 00:17:50,870
time we we call our resolver so we don't

00:17:47,710 --> 00:17:53,120
yeah like it's this way we can check

00:17:50,870 --> 00:17:55,220
either if the return type is the type

00:17:53,120 --> 00:17:57,500
that we expect or if we want to address

00:17:55,220 --> 00:18:00,440
limiting or if we want what for example

00:17:57,500 --> 00:18:03,170
we have already middleware for debugging

00:18:00,440 --> 00:18:05,120
or jungle queries so actually in the

00:18:03,170 --> 00:18:08,390
Star Wars API example that we have in

00:18:05,120 --> 00:18:09,890
the graphene which is the URL here if

00:18:08,390 --> 00:18:13,070
you go here and you see the Star Wars

00:18:09,890 --> 00:18:15,080
example and you try the debug field in

00:18:13,070 --> 00:18:17,300
the root query you will see what are all

00:18:15,080 --> 00:18:20,690
the sequel queries executed and this is

00:18:17,300 --> 00:18:22,010
thanks for using middleware so you have

00:18:20,690 --> 00:18:24,740
a lot of cool things

00:18:22,010 --> 00:18:27,050
for using that and this as we are using

00:18:24,740 --> 00:18:28,670
promises also in Python is very easy to

00:18:27,050 --> 00:18:33,320
like the implementation of mirror world

00:18:28,670 --> 00:18:36,170
will select ten lines of code we just

00:18:33,320 --> 00:18:37,760
implemented two weeks ago okay for those

00:18:36,170 --> 00:18:40,340
watching the live stream the question

00:18:37,760 --> 00:18:43,340
was how do you actually a use middleware

00:18:40,340 --> 00:18:46,220
and how do you decide where to apply it

00:18:43,340 --> 00:18:50,210
or where it doesn't apply and we just

00:18:46,220 --> 00:18:53,500
heard the answer before yeah question

00:18:50,210 --> 00:18:53,500
all right there's another question yeah

00:18:55,900 --> 00:19:01,220
okay so the question was what do you

00:18:58,970 --> 00:19:03,490
think is the biggest component missing

00:19:01,220 --> 00:19:05,750
from the graphical ecosystem I think I

00:19:03,490 --> 00:19:08,090
really think validation should be

00:19:05,750 --> 00:19:10,280
something either have to require some

00:19:08,090 --> 00:19:12,170
like not Apple request like I open my

00:19:10,280 --> 00:19:13,570
issue for discussion about that and I

00:19:12,170 --> 00:19:15,920
think that could be really useful

00:19:13,570 --> 00:19:18,290
actually I'm a little bit the scarab of

00:19:15,920 --> 00:19:20,030
directives because it opened this

00:19:18,290 --> 00:19:23,960
Pandora Box where like everything could

00:19:20,030 --> 00:19:26,810
be a directive and I just want to make

00:19:23,960 --> 00:19:29,240
sure that we know what using a directive

00:19:26,810 --> 00:19:31,910
is but for me validation is something

00:19:29,240 --> 00:19:34,100
that is quite important and it's

00:19:31,910 --> 00:19:36,680
important to stop the execution so I

00:19:34,100 --> 00:19:40,360
think it should be like alright let's

00:19:36,680 --> 00:19:40,360
think Cyrus again for stock

00:19:42,190 --> 00:19:44,250

YouTube URL: https://www.youtube.com/watch?v=ND9GWSkbUGM


