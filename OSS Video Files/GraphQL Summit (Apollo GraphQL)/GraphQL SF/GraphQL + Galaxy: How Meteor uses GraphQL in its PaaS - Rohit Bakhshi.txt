Title: GraphQL + Galaxy: How Meteor uses GraphQL in its PaaS - Rohit Bakhshi
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	Video our meetup GraphQL in Production on 8/25/16.

We're organizing the first-ever GraphQL conf! Register to attend GraphQL Summit in SF this October: http://graphqlsummit.com/

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/
Captions: 
	00:00:02,620 --> 00:00:09,219
our last speaker of tonight is Rohit he

00:00:06,430 --> 00:00:11,969
is the product manager of galaxies which

00:00:09,219 --> 00:00:14,799
is a meteor zone platform-as-a-service

00:00:11,969 --> 00:00:16,660
sort of for running meteor apps and

00:00:14,799 --> 00:00:19,000
he'll be talking about the tools that we

00:00:16,660 --> 00:00:22,270
use to sort of make graph to I'll work

00:00:19,000 --> 00:00:24,369
in development and production thank you

00:00:22,270 --> 00:00:31,360
jealous let me fire up the presentation

00:00:24,369 --> 00:00:32,739
here great let's get started so good

00:00:31,360 --> 00:00:34,750
evening everyone my name's rohit bakhshi

00:00:32,739 --> 00:00:37,000
I'm a responsible product management

00:00:34,750 --> 00:00:39,429
here at meter devolving group and we all

00:00:37,000 --> 00:00:41,429
talk about today is talk about our

00:00:39,429 --> 00:00:45,370
production app that we have galaxy I

00:00:41,429 --> 00:00:47,800
meaning going to how we incrementally

00:00:45,370 --> 00:00:49,839
adopted graph ql why we did it why was

00:00:47,800 --> 00:00:51,550
important what had helped us kind of

00:00:49,839 --> 00:00:53,890
enable an accomplished regret would

00:00:51,550 --> 00:00:56,289
galaxy and then how apollo and

00:00:53,890 --> 00:00:58,120
incrementally adopting it with apollo is

00:00:56,289 --> 00:01:00,069
really really useful in rolling this out

00:00:58,120 --> 00:01:02,319
to production and ensure key learnings

00:01:00,069 --> 00:01:05,170
that we had with the app in with our

00:01:02,319 --> 00:01:07,240
experience so let's start with galaxy so

00:01:05,170 --> 00:01:09,100
galaxy is a platform as a service for

00:01:07,240 --> 00:01:11,470
meteor JavaScript applications think of

00:01:09,100 --> 00:01:13,900
it as Heroku for meteor j/s connected

00:01:11,470 --> 00:01:16,060
client applications this has been in

00:01:13,900 --> 00:01:17,320
production since october of last year

00:01:16,060 --> 00:01:19,150
it's almost been a year that we've been

00:01:17,320 --> 00:01:21,040
in production we've got thousands of

00:01:19,150 --> 00:01:22,780
users thousands of applications deployed

00:01:21,040 --> 00:01:23,800
in our platform as a service and what

00:01:22,780 --> 00:01:26,500
you're looking at is actually the

00:01:23,800 --> 00:01:28,420
management interface for galaxy this is

00:01:26,500 --> 00:01:30,160
what users use that's the app to manage

00:01:28,420 --> 00:01:31,930
all their applications look at all the

00:01:30,160 --> 00:01:34,960
data for their applications it's a very

00:01:31,930 --> 00:01:37,390
data intensive rich client experience I

00:01:34,960 --> 00:01:39,460
mean the way we built it and architect

00:01:37,390 --> 00:01:41,530
of it is that the entire platform is

00:01:39,460 --> 00:01:42,790
built on AWS we leverage AWS for

00:01:41,530 --> 00:01:45,490
infrastructure and underlying data

00:01:42,790 --> 00:01:47,320
services we use a MongoDB for

00:01:45,490 --> 00:01:49,360
operational data store and the actual

00:01:47,320 --> 00:01:51,850
app that you were looking at is a meteor

00:01:49,360 --> 00:01:54,250
JavaScript app so it's react framework

00:01:51,850 --> 00:01:56,350
in the front end and then a nodejs meter

00:01:54,250 --> 00:01:58,180
back-end that then talks to these

00:01:56,350 --> 00:02:00,730
different data sources right so we have

00:01:58,180 --> 00:02:02,890
MongoDB operational database we use

00:02:00,730 --> 00:02:03,880
Amazon DynamoDB for all the container

00:02:02,890 --> 00:02:05,890
metrics so when you're running

00:02:03,880 --> 00:02:08,619
containers you want to calculate ram and

00:02:05,890 --> 00:02:09,879
cpu utilization and get those metrics

00:02:08,619 --> 00:02:12,159
that actually goes into animals on

00:02:09,879 --> 00:02:13,870
DynamoDB we use elastic stretch wrap

00:02:12,159 --> 00:02:15,720
logs so you've got different types of

00:02:13,870 --> 00:02:18,990
data stores that are powering that you

00:02:15,720 --> 00:02:20,640
interface and so as we scaled and as we

00:02:18,990 --> 00:02:22,200
kind of grew our business and asked more

00:02:20,640 --> 00:02:25,380
and more customers came on board with

00:02:22,200 --> 00:02:28,170
using our platform as a service we start

00:02:25,380 --> 00:02:29,970
seeing that the performance of search

00:02:28,170 --> 00:02:31,860
and pages was kind of degrading from

00:02:29,970 --> 00:02:33,360
where it was before right here's an

00:02:31,860 --> 00:02:35,850
example of what we what we kind of found

00:02:33,360 --> 00:02:36,840
so aston account this is you looking at

00:02:35,850 --> 00:02:38,880
an account you have a list of

00:02:36,840 --> 00:02:40,950
applications in an account as you have

00:02:38,880 --> 00:02:43,290
accounts that have tens or twenties of

00:02:40,950 --> 00:02:45,060
20 applications running in them what

00:02:43,290 --> 00:02:47,310
we're doing on this page is that we're

00:02:45,060 --> 00:02:48,810
actually hitting MongoDB to get there's

00:02:47,310 --> 00:02:50,880
one call to get the list of applications

00:02:48,810 --> 00:02:52,230
that account and then for each of those

00:02:50,880 --> 00:02:54,360
applications that account there's

00:02:52,230 --> 00:02:56,310
multiple calls to get summary data so we

00:02:54,360 --> 00:02:59,130
get data about who deployed it last we

00:02:56,310 --> 00:03:01,260
get data about sparklines to show you

00:02:59,130 --> 00:03:03,360
CPU trends over the last 24 hours around

00:03:01,260 --> 00:03:05,550
trends over the last 24 hours so it's a

00:03:03,360 --> 00:03:07,470
lot of data being loaded for the entire

00:03:05,550 --> 00:03:08,970
list of applications and this isn't a

00:03:07,470 --> 00:03:10,560
great example of a page when you're

00:03:08,970 --> 00:03:13,110
making multiple different endpoint calls

00:03:10,560 --> 00:03:15,150
become slower and load time becomes

00:03:13,110 --> 00:03:16,950
impactful to our customers another

00:03:15,150 --> 00:03:18,780
example of that is for a single

00:03:16,950 --> 00:03:21,480
application we have to provide pretty

00:03:18,780 --> 00:03:23,370
rich container metrics so one

00:03:21,480 --> 00:03:26,550
application can have multiple containers

00:03:23,370 --> 00:03:28,530
we use docker to run and orchestrate

00:03:26,550 --> 00:03:31,290
these containers across different ec2

00:03:28,530 --> 00:03:32,489
machines so for 11 application that 20

00:03:31,290 --> 00:03:35,010
containers we have applications that are

00:03:32,489 --> 00:03:36,239
running 40 50 60 containers you have all

00:03:35,010 --> 00:03:39,209
these charts of giving rate data

00:03:36,239 --> 00:03:41,880
intensive views into ram and cpu and

00:03:39,209 --> 00:03:43,290
number of connections and each of those

00:03:41,880 --> 00:03:44,940
is again hitting an endpoint to render

00:03:43,290 --> 00:03:46,739
each of those individual graphs so again

00:03:44,940 --> 00:03:48,239
a very data intensive view that gets

00:03:46,739 --> 00:03:50,519
expensive and impacts load tomic's

00:03:48,239 --> 00:03:53,850
impacts the end customer experience when

00:03:50,519 --> 00:03:55,530
you're working with these data rich user

00:03:53,850 --> 00:03:57,870
interface front ends hitting multiple

00:03:55,530 --> 00:03:59,519
different backends and so that's why

00:03:57,870 --> 00:04:02,250
graphical is really important to us as a

00:03:59,519 --> 00:04:03,540
team when we were developing and dealing

00:04:02,250 --> 00:04:06,360
with the scale that we were growing at

00:04:03,540 --> 00:04:07,620
right so one obvious thing is that once

00:04:06,360 --> 00:04:09,299
you have graphical queries that go

00:04:07,620 --> 00:04:11,549
across these different data sources and

00:04:09,299 --> 00:04:13,410
power and in one query that then pulls

00:04:11,549 --> 00:04:15,480
the information to power that and render

00:04:13,410 --> 00:04:16,979
that you I um you don't have the

00:04:15,480 --> 00:04:18,900
multiple round trips for every single

00:04:16,979 --> 00:04:21,239
individual graph and that's a big front

00:04:18,900 --> 00:04:23,040
end improvement in a big reduction load

00:04:21,239 --> 00:04:25,110
time as well as developer productivity

00:04:23,040 --> 00:04:27,000
so we have fun develop applications that

00:04:25,110 --> 00:04:28,510
are working with data sources different

00:04:27,000 --> 00:04:31,510
data sources right so one schemas

00:04:28,510 --> 00:04:33,310
to find across the different sources and

00:04:31,510 --> 00:04:34,840
using tools like graphical so we use

00:04:33,310 --> 00:04:39,670
that while developing it's really really

00:04:34,840 --> 00:04:41,560
useful it's immensely impactful and

00:04:39,670 --> 00:04:43,690
helpful to our front-end developers to

00:04:41,560 --> 00:04:46,300
build new functionality maintain

00:04:43,690 --> 00:04:47,590
existing code and existing queries and

00:04:46,300 --> 00:04:49,360
so gruff fuel is really important in

00:04:47,590 --> 00:04:50,590
that sense now as we kind of thought

00:04:49,360 --> 00:04:52,990
about rolling this out to production

00:04:50,590 --> 00:04:54,340
right we have this application it's been

00:04:52,990 --> 00:04:55,840
running for months we have thousands of

00:04:54,340 --> 00:04:58,330
users we want to do something in a way

00:04:55,840 --> 00:05:00,910
that doesn't tear apart a complete

00:04:58,330 --> 00:05:03,430
reactor re architect application and so

00:05:00,910 --> 00:05:04,960
we were big on incrementally pulling in

00:05:03,430 --> 00:05:08,080
an adopting graph fuel for certain

00:05:04,960 --> 00:05:09,700
pieces and so that's where Apollo and

00:05:08,080 --> 00:05:12,520
Apollo's approach of incrementally being

00:05:09,700 --> 00:05:14,590
allowing you to adopt a graph ql as a

00:05:12,520 --> 00:05:16,630
data layer into an architecture

00:05:14,590 --> 00:05:19,000
alongside your existing data layer so

00:05:16,630 --> 00:05:21,550
not rip and replace but incrementally

00:05:19,000 --> 00:05:22,900
adopt was really really important and so

00:05:21,550 --> 00:05:25,810
you know I've talked to other customers

00:05:22,900 --> 00:05:27,700
who are also looking at using graph ql

00:05:25,810 --> 00:05:29,260
and when they have production

00:05:27,700 --> 00:05:31,330
application is a very similar story they

00:05:29,260 --> 00:05:32,380
want to incrementally adopt it and not

00:05:31,330 --> 00:05:34,510
just write rewrite the entire

00:05:32,380 --> 00:05:35,770
application with a new data later and so

00:05:34,510 --> 00:05:37,570
how that kind of plays out in our

00:05:35,770 --> 00:05:39,370
architecture is that the same diagram

00:05:37,570 --> 00:05:42,670
that you're looking at before we now

00:05:39,370 --> 00:05:43,900
have an Apollo client piece and kind of

00:05:42,670 --> 00:05:46,810
part of the architecture that lives

00:05:43,900 --> 00:05:49,330
within our react front end client

00:05:46,810 --> 00:05:50,650
applications and that's hooked up to

00:05:49,330 --> 00:05:52,180
certain components that are powering the

00:05:50,650 --> 00:05:54,550
pages that are actually using graph ql

00:05:52,180 --> 00:05:56,230
to render those pages so they use a bulk

00:05:54,550 --> 00:05:57,970
line and then the other components on

00:05:56,230 --> 00:06:00,940
this on and the react application are

00:05:57,970 --> 00:06:04,810
using the rest like we have a meteor the

00:06:00,940 --> 00:06:06,760
DDP subscription data loading framework

00:06:04,810 --> 00:06:09,670
that we're using so they exist side by

00:06:06,760 --> 00:06:11,560
side in our application and then Apollo

00:06:09,670 --> 00:06:13,660
server so what Nick at Credit Karma was

00:06:11,560 --> 00:06:15,780
talking about using a koala server is a

00:06:13,660 --> 00:06:20,320
component that lives within our nodejs

00:06:15,780 --> 00:06:22,630
Express or no GS meteor backend and it's

00:06:20,320 --> 00:06:24,850
used to then you know the resolvers and

00:06:22,630 --> 00:06:26,920
logic is kind of lives in that component

00:06:24,850 --> 00:06:30,400
to talk to MongoDB to get operational

00:06:26,920 --> 00:06:32,950
data data for the application as well as

00:06:30,400 --> 00:06:34,870
from Amazon dynamo DD to render those

00:06:32,950 --> 00:06:37,060
metric views that you were saying so

00:06:34,870 --> 00:06:38,920
it's incremental lives alongside

00:06:37,060 --> 00:06:40,390
existing architecture and we can keep

00:06:38,920 --> 00:06:42,160
adding new and you

00:06:40,390 --> 00:06:45,730
instrumenting and orchestrating new

00:06:42,160 --> 00:06:47,050
components and pages would graph ql so

00:06:45,730 --> 00:06:49,240
now i'm going to switch over to show you

00:06:47,050 --> 00:06:51,310
what this actually looks like running

00:06:49,240 --> 00:06:58,450
live so let's see if I can share my

00:06:51,310 --> 00:07:04,900
screen and do this on large green can

00:06:58,450 --> 00:07:06,970
everyone see that okay great so this is

00:07:04,900 --> 00:07:09,580
um this is our corporate account

00:07:06,970 --> 00:07:13,540
actually mdg make it bigger let's see

00:07:09,580 --> 00:07:15,910
okay this is our corporate account a

00:07:13,540 --> 00:07:17,980
galaxy corporate account and we have

00:07:15,910 --> 00:07:20,140
multiple applications here that are in

00:07:17,980 --> 00:07:21,610
the account and you can see the same you

00:07:20,140 --> 00:07:22,750
can see summary information and the

00:07:21,610 --> 00:07:24,640
metric information about each of these

00:07:22,750 --> 00:07:25,930
and so what we actually did while we

00:07:24,640 --> 00:07:28,440
were building this is that we've also

00:07:25,930 --> 00:07:31,180
built production tooling tooling to help

00:07:28,440 --> 00:07:34,120
organizations social like ourselves our

00:07:31,180 --> 00:07:36,130
galaxy run implement graph ql and run in

00:07:34,120 --> 00:07:37,360
production and have the conference run

00:07:36,130 --> 00:07:40,060
in production so i'm going to zoom into

00:07:37,360 --> 00:07:41,710
this a bit so optics a polo optics is

00:07:40,060 --> 00:07:43,060
the tooling that we created and this is

00:07:41,710 --> 00:07:44,650
a preview that you're looking at here

00:07:43,060 --> 00:07:45,640
and what we have here is all the

00:07:44,650 --> 00:07:47,050
different queries that are actually

00:07:45,640 --> 00:07:48,970
going through the graphical service

00:07:47,050 --> 00:07:53,050
infrastructure that's powering galaxy um

00:07:48,970 --> 00:07:54,880
and so get user apps is it is a query

00:07:53,050 --> 00:07:56,590
here this is the query that's actually

00:07:54,880 --> 00:07:58,360
rendering that page I were just showing

00:07:56,590 --> 00:08:01,590
you so I'm going to go look into this

00:07:58,360 --> 00:08:03,700
and click on that and actually get

00:08:01,590 --> 00:08:05,230
because this tool is capturing

00:08:03,700 --> 00:08:06,310
information over the course of time as

00:08:05,230 --> 00:08:09,130
to how many times those queries are

00:08:06,310 --> 00:08:10,990
being rendered or executed across a

00:08:09,130 --> 00:08:14,080
different query request I can get in a

00:08:10,990 --> 00:08:15,490
view of kind of an idea of how its

00:08:14,080 --> 00:08:18,160
performing over time so a latency

00:08:15,490 --> 00:08:21,220
duration histogram to see that about

00:08:18,160 --> 00:08:23,620
half the time the queries executing

00:08:21,220 --> 00:08:27,010
under 100 milliseconds but there are a

00:08:23,620 --> 00:08:29,380
few outliers here that go into 3x 4x 5x

00:08:27,010 --> 00:08:31,000
range of running of executing the query

00:08:29,380 --> 00:08:32,620
right so I want to go and see what's

00:08:31,000 --> 00:08:36,390
happening there I can go click in and

00:08:32,620 --> 00:08:39,820
actually see I've one loaded up here a

00:08:36,390 --> 00:08:41,410
very visual introspection and view of

00:08:39,820 --> 00:08:44,080
what's happening how is the graphical

00:08:41,410 --> 00:08:45,460
query actually executing right so what

00:08:44,080 --> 00:08:48,550
you're looking at here and I'm going to

00:08:45,460 --> 00:08:50,950
zoom in here you're looking at a

00:08:48,550 --> 00:08:53,660
breakdown of all the different resolvers

00:08:50,950 --> 00:08:54,980
as the fields are being executed and

00:08:53,660 --> 00:08:58,490
it is being fetched for those different

00:08:54,980 --> 00:09:02,000
fields so this is the query that powers

00:08:58,490 --> 00:09:03,769
that page that was showing you so for an

00:09:02,000 --> 00:09:05,779
account get a list of applications for

00:09:03,769 --> 00:09:07,069
each application get information and go

00:09:05,779 --> 00:09:09,050
through that and iterate through the

00:09:07,069 --> 00:09:11,060
list of applications you seem that play

00:09:09,050 --> 00:09:12,889
out here and you get a sense of how long

00:09:11,060 --> 00:09:14,649
it takes to get each application you're

00:09:12,889 --> 00:09:18,560
getting a sense of which are the most

00:09:14,649 --> 00:09:20,209
duration full resolver executions and

00:09:18,560 --> 00:09:22,310
you can see here at all a lot of them

00:09:20,209 --> 00:09:24,800
point to the apt up metrics which is the

00:09:22,310 --> 00:09:25,810
resolver it's actually hitting DynamoDB

00:09:24,800 --> 00:09:28,129
and getting the summary information

00:09:25,810 --> 00:09:30,050
metric information for each app in the

00:09:28,129 --> 00:09:33,230
list and so this has been really helpful

00:09:30,050 --> 00:09:35,000
so our front-end one of our the Tim

00:09:33,230 --> 00:09:36,620
who's our engineer who implemented this

00:09:35,000 --> 00:09:38,959
was showing me what he got are they

00:09:36,620 --> 00:09:41,740
using this tool so here's an example of

00:09:38,959 --> 00:09:43,699
here's a trace that we actually captured

00:09:41,740 --> 00:09:45,439
multiple months ago when we roll this

00:09:43,699 --> 00:09:47,329
out into production reroll galaxy aden

00:09:45,439 --> 00:09:49,790
and apollo in galaxies out into

00:09:47,329 --> 00:09:51,889
production you can see see here this is

00:09:49,790 --> 00:09:53,930
the execution paths to the same query

00:09:51,889 --> 00:09:56,509
that was showing you every single

00:09:53,930 --> 00:09:58,610
application is being fetched in sequence

00:09:56,509 --> 00:10:00,199
right and so this is when we first

00:09:58,610 --> 00:10:02,000
rolled up the functionality for solder

00:10:00,199 --> 00:10:03,709
balls and integration seeing it in a

00:10:02,000 --> 00:10:05,750
very visual manner you can kind of see

00:10:03,709 --> 00:10:07,550
how the execution is happening and this

00:10:05,750 --> 00:10:09,470
pointed us to the fact that we were

00:10:07,550 --> 00:10:10,670
doing this synchronously and we should

00:10:09,470 --> 00:10:12,949
have actually implemented a synchronous

00:10:10,670 --> 00:10:14,870
wait and see the benefits that you be

00:10:12,949 --> 00:10:19,639
then get going back to what this

00:10:14,870 --> 00:10:21,079
actually looks like right right now this

00:10:19,639 --> 00:10:23,720
is after optimizing and kind of learning

00:10:21,079 --> 00:10:28,189
from the different architecture things

00:10:23,720 --> 00:10:30,470
that we rolled out before and so it's

00:10:28,189 --> 00:10:33,139
it's really helpful to graph qol as a

00:10:30,470 --> 00:10:35,509
kind of as a service layer and

00:10:33,139 --> 00:10:36,829
infrastructure sits above all the

00:10:35,509 --> 00:10:38,509
different back in endpoints and so it's

00:10:36,829 --> 00:10:40,069
a really nice way to the introspect what

00:10:38,509 --> 00:10:42,290
took friends doing how its querying for

00:10:40,069 --> 00:10:44,240
information what field is being it's

00:10:42,290 --> 00:10:47,300
using and so tooling like optics really

00:10:44,240 --> 00:10:49,399
helps you figure that out so to

00:10:47,300 --> 00:10:50,839
summarize what are the key takeaways

00:10:49,399 --> 00:10:52,459
that we had after rolling South the

00:10:50,839 --> 00:10:54,559
production and experiences with the

00:10:52,459 --> 00:10:58,100
running graph to l and production one is

00:10:54,559 --> 00:11:00,769
that incrementally adopt a major new

00:10:58,100 --> 00:11:03,139
data layer like graph ql and Apollo

00:11:00,769 --> 00:11:04,790
client Nepal so ever really help to do

00:11:03,139 --> 00:11:06,319
that and it's helped us because now that

00:11:04,790 --> 00:11:06,910
we've got a few of these components and

00:11:06,319 --> 00:11:08,959
pages

00:11:06,910 --> 00:11:11,239
orchestrated and then kind of load it up

00:11:08,959 --> 00:11:12,859
with graph ql we can then make choices

00:11:11,239 --> 00:11:16,689
about how to roll it out to other pages

00:11:12,859 --> 00:11:19,459
as i make sense in our application and

00:11:16,689 --> 00:11:21,319
four of you know a data intensive run an

00:11:19,459 --> 00:11:24,259
application like the galaxy galaxy

00:11:21,319 --> 00:11:26,600
management interface graph ql not only

00:11:24,259 --> 00:11:28,429
improves client load and application

00:11:26,600 --> 00:11:30,619
performance but it also helps our

00:11:28,429 --> 00:11:32,329
developers be a lot more productive so

00:11:30,619 --> 00:11:33,470
um those are definitely learnings that

00:11:32,329 --> 00:11:35,600
we've seen over the last two months of

00:11:33,470 --> 00:11:38,179
running this in production and i'm

00:11:35,600 --> 00:11:40,160
having tooling and having a way to view

00:11:38,179 --> 00:11:42,739
from a very graph you'll graphical

00:11:40,160 --> 00:11:44,989
centric way what your fun and how your

00:11:42,739 --> 00:11:47,299
front end clients are asking for data

00:11:44,989 --> 00:11:48,679
from the backend services what queries

00:11:47,299 --> 00:11:50,600
are executing how those queries are

00:11:48,679 --> 00:11:52,819
actually getting executed in real time

00:11:50,600 --> 00:11:55,279
across different parameters I'm is

00:11:52,819 --> 00:11:56,959
really helpful in figuring out where to

00:11:55,279 --> 00:11:59,209
optimize and how to make your load times

00:11:56,959 --> 00:12:00,589
faster and how to be more intelligent of

00:11:59,209 --> 00:12:03,379
how you use your different data points

00:12:00,589 --> 00:12:06,889
that you're kind of exposing from your

00:12:03,379 --> 00:12:09,379
back and services so thanks for

00:12:06,889 --> 00:12:10,609
listening I'm available enough if you

00:12:09,379 --> 00:12:12,649
ever have any questions about running

00:12:10,609 --> 00:12:14,749
Alps or implementing graph cue ball into

00:12:12,649 --> 00:12:16,009
production apps I'm hit me up on slack

00:12:14,749 --> 00:12:18,019
and hit me up on Twitter I'd love to

00:12:16,009 --> 00:12:20,509
kind of answer questions to talk about

00:12:18,019 --> 00:12:22,939
that as well as you want to see previews

00:12:20,509 --> 00:12:25,480
of the tooling that we built let's talk

00:12:22,939 --> 00:12:25,480
about that as well

00:12:30,380 --> 00:12:35,310
all right thank you rocket I think we

00:12:33,570 --> 00:12:38,610
have a couple questions so we'll take

00:12:35,310 --> 00:12:42,090
those so I don't know too much about

00:12:38,610 --> 00:12:44,370
hablo time but i know in the reactor

00:12:42,090 --> 00:12:47,190
most people are used in redux so you

00:12:44,370 --> 00:12:48,960
doing a comparison to say in what kind

00:12:47,190 --> 00:12:51,150
of case what kind of role a pro/con

00:12:48,960 --> 00:12:53,970
place in such case and doing a

00:12:51,150 --> 00:12:55,970
comparison between Redux and our program

00:12:53,970 --> 00:12:57,990
thanks it's a great question i think

00:12:55,970 --> 00:12:59,280
engineers working the pole climb i do

00:12:57,990 --> 00:13:01,830
better at answer to join us you want

00:12:59,280 --> 00:13:03,540
take that okay actually yeah so actually

00:13:01,830 --> 00:13:05,940
a palo client works really well

00:13:03,540 --> 00:13:07,080
alongside redux and sashko could

00:13:05,940 --> 00:13:09,690
probably tell you a whole story about

00:13:07,080 --> 00:13:12,450
how that how we made it to work really

00:13:09,690 --> 00:13:14,370
well with redux so yeah totally if you

00:13:12,450 --> 00:13:16,950
if you have a react application and

00:13:14,370 --> 00:13:18,990
you're using Redux in there you can use

00:13:16,950 --> 00:13:21,330
apollo client you can either like have

00:13:18,990 --> 00:13:23,640
two separate stores one that's managed

00:13:21,330 --> 00:13:25,560
by apollo client or one end one that's

00:13:23,640 --> 00:13:28,080
managed you know for your local app

00:13:25,560 --> 00:13:30,570
state and redux or you can actually pass

00:13:28,080 --> 00:13:32,280
that Redux store to apollo client and

00:13:30,570 --> 00:13:33,990
make it use just one store so you have

00:13:32,280 --> 00:13:35,790
everything managed in one place and you

00:13:33,990 --> 00:13:38,390
just have you know you're one set of

00:13:35,790 --> 00:13:38,390
reducers

00:13:43,020 --> 00:13:50,260
I'm curious to know how you how you do

00:13:47,350 --> 00:13:52,660
the timing thing like in your optics we

00:13:50,260 --> 00:13:54,340
have middle were like what approach you

00:13:52,660 --> 00:13:56,500
actually take for like doing the timing

00:13:54,340 --> 00:13:58,570
aha the question is how did we get this

00:13:56,500 --> 00:14:02,080
timing approach which I'm going to

00:13:58,570 --> 00:14:04,090
switch to see if I can so this is

00:14:02,080 --> 00:14:07,900
actually orchestrated by middleware

00:14:04,090 --> 00:14:09,100
that's sitting in the Apollo server acid

00:14:07,900 --> 00:14:12,460
package so there's actual middleware

00:14:09,100 --> 00:14:14,200
that we've used that is a trace logging

00:14:12,460 --> 00:14:15,550
middleware that is collecting traces for

00:14:14,200 --> 00:14:17,560
the different query requests and sending

00:14:15,550 --> 00:14:22,600
it back to the service so it does use

00:14:17,560 --> 00:14:25,060
the middleware although you you can use

00:14:22,600 --> 00:14:26,920
the same thing with any like JavaScript

00:14:25,060 --> 00:14:28,750
graphical server because what we do is

00:14:26,920 --> 00:14:31,300
basically just wrap the resolve

00:14:28,750 --> 00:14:34,300
functions and then set an object on the

00:14:31,300 --> 00:14:37,000
context that it writes the timing to and

00:14:34,300 --> 00:14:38,920
then that gets sent to the optics back

00:14:37,000 --> 00:14:40,390
end yeah yeah so this works with a pole

00:14:38,920 --> 00:14:41,710
server and act and Express graph cool

00:14:40,390 --> 00:14:46,410
and happy graph you all on different

00:14:41,710 --> 00:14:46,410
fields over there was good yes question

00:14:48,800 --> 00:14:54,019
so two parts first of all using and

00:14:51,560 --> 00:14:56,360
graphic UL subscriptions at all and the

00:14:54,019 --> 00:14:58,130
second thing is are you what's what kind

00:14:56,360 --> 00:15:01,370
of caching are you doing for example on

00:14:58,130 --> 00:15:03,050
your slow dynamo queries which you know

00:15:01,370 --> 00:15:05,120
and like in this case take a long time

00:15:03,050 --> 00:15:07,180
but what what kind of caching do you

00:15:05,120 --> 00:15:11,420
have implemented there to speed that up

00:15:07,180 --> 00:15:13,940
good question so on the first one we are

00:15:11,420 --> 00:15:15,170
not using graph ql subscriptions yet

00:15:13,940 --> 00:15:17,240
that's something we'll explore we're

00:15:15,170 --> 00:15:18,860
actually using polling with our

00:15:17,240 --> 00:15:20,510
graphical queries to keep to render

00:15:18,860 --> 00:15:22,640
those and those pages that we use we

00:15:20,510 --> 00:15:23,690
didn't have need to make it real time so

00:15:22,640 --> 00:15:26,740
we didn't have to use graphical

00:15:23,690 --> 00:15:29,149
subscriptions on the caching thing i'll

00:15:26,740 --> 00:15:30,470
follow up with you on that one I don't

00:15:29,149 --> 00:15:34,100
know if what we're doing on the back and

00:15:30,470 --> 00:15:36,470
there to to optimize loading from

00:15:34,100 --> 00:15:43,930
diamond on TV but we can follow up on

00:15:36,470 --> 00:15:43,930
that we have time for one more question

00:15:44,019 --> 00:15:48,529
hey yeah i'm just curious what's the

00:15:46,220 --> 00:15:50,180
future of optics it's something that i

00:15:48,529 --> 00:15:55,220
would definitely be interested in having

00:15:50,180 --> 00:15:58,010
yeah yeah good question so um we're

00:15:55,220 --> 00:16:00,200
really focused on you know once you've

00:15:58,010 --> 00:16:01,490
built once you've built and implemented

00:16:00,200 --> 00:16:03,050
graphical service in your architecture

00:16:01,490 --> 00:16:05,480
there's a whole set of things that kind

00:16:03,050 --> 00:16:07,279
of a whole sort of answers and questions

00:16:05,480 --> 00:16:08,720
that front end developers in front of

00:16:07,279 --> 00:16:10,279
ten people were in charge of the front

00:16:08,720 --> 00:16:11,899
and architecture can ask things like

00:16:10,279 --> 00:16:13,790
which fields are actually being used

00:16:11,899 --> 00:16:15,410
which fields are not being used how can

00:16:13,790 --> 00:16:17,360
I figure out what when I can deprecated

00:16:15,410 --> 00:16:19,520
certain back-end micro services that are

00:16:17,360 --> 00:16:21,470
exposed themselves exposed through the

00:16:19,520 --> 00:16:24,800
graphical schema which fields are being

00:16:21,470 --> 00:16:27,860
used which fields can be deprecated how

00:16:24,800 --> 00:16:30,829
often are native mobile clients asking

00:16:27,860 --> 00:16:32,180
for certain fields versus web clients

00:16:30,829 --> 00:16:33,500
you know are there different behavior

00:16:32,180 --> 00:16:36,290
patterns there how's it change across

00:16:33,500 --> 00:16:39,589
client versions right so providing this

00:16:36,290 --> 00:16:41,990
rich in sight across different client

00:16:39,589 --> 00:16:44,660
types client metadata client versions a

00:16:41,990 --> 00:16:47,120
very graphical query centric view about

00:16:44,660 --> 00:16:48,560
how your fields are being used and then

00:16:47,120 --> 00:16:50,269
as well as performance and kind of

00:16:48,560 --> 00:16:52,519
helping you optimize how you've

00:16:50,269 --> 00:16:54,250
implemented graph too well so it's all

00:16:52,519 --> 00:16:56,060
that kind of set of the genre of

00:16:54,250 --> 00:16:59,390
capabilities what we're looking at with

00:16:56,060 --> 00:17:01,130
this joy yeah and so if I understand

00:16:59,390 --> 00:17:01,620
correctly right now this works just with

00:17:01,130 --> 00:17:03,210
job

00:17:01,620 --> 00:17:05,130
stripped servers right you have any

00:17:03,210 --> 00:17:06,959
plans to make that work with other types

00:17:05,130 --> 00:17:09,720
of servers yep good question so the

00:17:06,959 --> 00:17:11,610
preview is for JavaScript servers and

00:17:09,720 --> 00:17:15,990
we're exploring ways and expanding it to

00:17:11,610 --> 00:17:17,939
be back in server runtime agnostic and

00:17:15,990 --> 00:17:22,530
it works with different client types so

00:17:17,939 --> 00:17:25,350
really in a ball client yeah all right

00:17:22,530 --> 00:17:28,220
thanks a lot Rohit let's give them

00:17:25,350 --> 00:17:28,220

YouTube URL: https://www.youtube.com/watch?v=NpphsLCLoMo


