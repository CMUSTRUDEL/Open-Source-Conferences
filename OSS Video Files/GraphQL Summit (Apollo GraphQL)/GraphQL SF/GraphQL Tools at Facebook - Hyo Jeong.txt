Title: GraphQL Tools at Facebook - Hyo Jeong
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	Facebook engineer and GraphiQL maintainers Hyo Jeong presents at our GraphQL in Production meetup on 8/25/16.

We're organizing the first-ever GraphQL conf! Register to attend GraphQL Summit in SF this October: http://graphql.com/summit/

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/
Captions: 
	00:00:03,159 --> 00:00:08,620
our next speaker is he oh he's a

00:00:06,580 --> 00:00:12,120
software engineer at Facebook where he

00:00:08,620 --> 00:00:15,460
works on tooling for graph QL to allow

00:00:12,120 --> 00:00:17,529
developers to use it at scale he's also

00:00:15,460 --> 00:00:22,380
the maintainer of the very popular

00:00:17,529 --> 00:00:26,169
open-source graphical which is a

00:00:22,380 --> 00:00:29,470
graphical UI for exploring schemas and

00:00:26,169 --> 00:00:40,300
that has also been called I think graph

00:00:29,470 --> 00:00:48,250
QL is killer app so welcome yo let me

00:00:40,300 --> 00:00:52,990
just do a couple of cool all right

00:00:48,250 --> 00:00:54,730
how you guys doing good all right I'm

00:00:52,990 --> 00:00:58,960
excited because I get to talk about what

00:00:54,730 --> 00:01:01,930
I did for pass whatever time so my name

00:00:58,960 --> 00:01:04,570
is Hugh Hill John I'm a software

00:01:01,930 --> 00:01:06,369
engineer at Facebook and tonight I want

00:01:04,570 --> 00:01:08,499
to talk about how graphic your powers

00:01:06,369 --> 00:01:12,429
thought development that scale of

00:01:08,499 --> 00:01:14,049
Facebook so hopefully everyone here

00:01:12,429 --> 00:01:16,329
knows about graphic oh yeah

00:01:14,049 --> 00:01:19,119
okay I can get a consensus of you know I

00:01:16,329 --> 00:01:21,549
know graph QL I've been to some talks

00:01:19,119 --> 00:01:24,100
about it maybe we could actually

00:01:21,549 --> 00:01:25,119
experience and hopefully you're stoked

00:01:24,100 --> 00:01:29,020
about it because I'm definitely

00:01:25,119 --> 00:01:31,270
interested and very excited but I'll

00:01:29,020 --> 00:01:33,789
just summarize it was just one more time

00:01:31,270 --> 00:01:35,920
and it is a query language that aligns

00:01:33,789 --> 00:01:40,569
with the way that productive of us think

00:01:35,920 --> 00:01:42,670
and it's amazing right and a Facebook we

00:01:40,569 --> 00:01:44,530
are using graticule to power many

00:01:42,670 --> 00:01:48,579
applications and platforms in production

00:01:44,530 --> 00:01:50,139
today for instance in fact we power all

00:01:48,579 --> 00:01:53,649
our mobile applications with graph QL

00:01:50,139 --> 00:01:55,929
and it's type system the schema it plays

00:01:53,649 --> 00:02:00,130
a huge role in defining just what we can

00:01:55,929 --> 00:02:02,709
do with the data but what I want to talk

00:02:00,130 --> 00:02:06,579
about tonight is how the type system is

00:02:02,709 --> 00:02:08,470
useful in client-side so you know that

00:02:06,579 --> 00:02:10,869
graphical type system defines the

00:02:08,470 --> 00:02:13,420
capabilities of an app server emitting

00:02:10,869 --> 00:02:15,160
data and using this type system we get

00:02:13,420 --> 00:02:17,380
to quarry edit and you know

00:02:15,160 --> 00:02:19,480
two other many cool things with the data

00:02:17,380 --> 00:02:21,580
you have but knowing how graphic your

00:02:19,480 --> 00:02:24,490
types are defined in client-side it can

00:02:21,580 --> 00:02:26,500
be a very incredible powerful platform

00:02:24,490 --> 00:02:29,200
for it building tools that can support

00:02:26,500 --> 00:02:30,550
the product developers and I like to

00:02:29,200 --> 00:02:34,230
introduce some of the tools we've built

00:02:30,550 --> 00:02:37,240
to support native client development and

00:02:34,230 --> 00:02:40,000
these are native client side code

00:02:37,240 --> 00:02:42,180
generation and graphical but in scope of

00:02:40,000 --> 00:02:45,070
Facebook in the scale of Facebook and

00:02:42,180 --> 00:02:47,260
lastly I want to do a little sneak peek

00:02:45,070 --> 00:02:48,880
for you guys to do a graticule

00:02:47,260 --> 00:02:51,570
IDE support that I've been working on

00:02:48,880 --> 00:02:55,180
for the past couple months

00:02:51,570 --> 00:02:59,710
so in meanwhile I like to also address

00:02:55,180 --> 00:03:01,600
oh right here I'd like to address the

00:02:59,710 --> 00:03:03,760
problems we've had operating such a

00:03:01,600 --> 00:03:06,910
large scale and what we did and learn

00:03:03,760 --> 00:03:12,370
from them first of all let's look at the

00:03:06,910 --> 00:03:13,960
client code generation so you you see

00:03:12,370 --> 00:03:16,180
that into this diagram we don't just

00:03:13,960 --> 00:03:19,060
have many requests and applications we

00:03:16,180 --> 00:03:21,370
also have several native devices that

00:03:19,060 --> 00:03:24,550
you have to support and what we learned

00:03:21,370 --> 00:03:26,530
is for each native devices and clients

00:03:24,550 --> 00:03:28,830
it needs a way to understand and model

00:03:26,530 --> 00:03:31,690
the request being sent to the server and

00:03:28,830 --> 00:03:33,459
responses sent back from the server and

00:03:31,690 --> 00:03:36,580
from working with several different

00:03:33,459 --> 00:03:38,560
devices clients and developers we've

00:03:36,580 --> 00:03:41,140
learned that it is very much possible to

00:03:38,560 --> 00:03:43,330
automate this process of generating the

00:03:41,140 --> 00:03:45,820
native code from introspecting the type

00:03:43,330 --> 00:03:47,950
system on the client side this is

00:03:45,820 --> 00:03:50,860
roughly how our tool chain looks like in

00:03:47,950 --> 00:03:52,630
a spool we built a two tailed library

00:03:50,860 --> 00:03:55,239
that powers our native clients and

00:03:52,630 --> 00:03:57,280
development it's job is very simple you

00:03:55,239 --> 00:04:00,400
have our type system the capabilities

00:03:57,280 --> 00:04:03,250
and files that contain graphical queries

00:04:00,400 --> 00:04:05,260
and the tool chain generates files used

00:04:03,250 --> 00:04:07,660
to send out the Cori request and types

00:04:05,260 --> 00:04:11,500
the model each response from the

00:04:07,660 --> 00:04:14,080
execution result and is maybe it's very

00:04:11,500 --> 00:04:16,600
relevant actually to say it is powered

00:04:14,080 --> 00:04:19,450
almost exclusively by craft coaches or a

00:04:16,600 --> 00:04:22,750
reference implementation and just pure

00:04:19,450 --> 00:04:25,900
vanilla JavaScript so having said all

00:04:22,750 --> 00:04:27,880
this right I you might ask me a question

00:04:25,900 --> 00:04:28,720
that says why do we want to do this at

00:04:27,880 --> 00:04:30,070
all right

00:04:28,720 --> 00:04:32,230
we want to model these graphical

00:04:30,070 --> 00:04:33,790
artifacts don't we already know the

00:04:32,230 --> 00:04:37,450
structure of the quarry and the

00:04:33,790 --> 00:04:39,280
responses whatever we receive right so I

00:04:37,450 --> 00:04:41,260
want to do an interactive session kind

00:04:39,280 --> 00:04:44,350
of I want to kind of quick show of hands

00:04:41,260 --> 00:04:46,480
how many of you cannot beat this and is

00:04:44,350 --> 00:04:51,070
our familiar with doing something like

00:04:46,480 --> 00:04:54,610
this yeah like it's this is only a

00:04:51,070 --> 00:04:57,730
natural response to you know this visas

00:04:54,610 --> 00:04:59,770
you send or HTTP requests you get back

00:04:57,730 --> 00:05:02,190
some kind of response and you parse the

00:04:59,770 --> 00:05:05,020
JSON and then you render view with that

00:05:02,190 --> 00:05:07,150
so unsurprisingly this was our first

00:05:05,020 --> 00:05:10,540
approach to so sending a query and

00:05:07,150 --> 00:05:12,640
rendering with the responses and you

00:05:10,540 --> 00:05:14,590
could possibly get this this gets

00:05:12,640 --> 00:05:16,690
quickly out of hand

00:05:14,590 --> 00:05:18,820
because there are many issues to solve

00:05:16,690 --> 00:05:22,000
as a team gets bigger and the product

00:05:18,820 --> 00:05:25,480
skill grows so what if we have a huge

00:05:22,000 --> 00:05:28,060
quarry then we have a logic to go into

00:05:25,480 --> 00:05:30,490
the in this in this case and Friends and

00:05:28,060 --> 00:05:32,470
go get the names and if they have more

00:05:30,490 --> 00:05:34,750
friends then we get more friends it just

00:05:32,470 --> 00:05:36,160
gets out of hand and then what if we

00:05:34,750 --> 00:05:38,950
have more than couple teams working

00:05:36,160 --> 00:05:40,990
together right then we constantly go in

00:05:38,950 --> 00:05:42,880
to merge conflicts you know you solve

00:05:40,990 --> 00:05:44,950
your conflict I resolve my conflict and

00:05:42,880 --> 00:05:48,340
there it's it's not gonna be organized

00:05:44,950 --> 00:05:51,070
so soon after we started all that

00:05:48,340 --> 00:05:52,870
adopting graphical to Facebook we came

00:05:51,070 --> 00:05:55,570
across these questions ourselves and

00:05:52,870 --> 00:05:58,120
realize that you know we may need to

00:05:55,570 --> 00:06:01,300
have a way to intermediately represent

00:05:58,120 --> 00:06:03,280
these quarries and responses so I want

00:06:01,300 --> 00:06:06,040
to look at Allen I want to I want us to

00:06:03,280 --> 00:06:07,900
take a look at our example so this is a

00:06:06,040 --> 00:06:10,479
pretty simple quarry right

00:06:07,900 --> 00:06:12,790
it's a quarry that gets a user with an

00:06:10,479 --> 00:06:18,490
ID and name and list of friends with the

00:06:12,790 --> 00:06:21,640
name and this is how we model our quarry

00:06:18,490 --> 00:06:23,890
response career quests so I'm not

00:06:21,640 --> 00:06:25,870
actually sure what languages that is I'm

00:06:23,890 --> 00:06:29,650
a JavaScript developer so that looks

00:06:25,870 --> 00:06:31,540
terribly like JavaScript but you see how

00:06:29,650 --> 00:06:34,030
the quarry is wrapped in a very thin

00:06:31,540 --> 00:06:37,960
class with some helper method to set the

00:06:34,030 --> 00:06:40,930
arguments if you want directors and then

00:06:37,960 --> 00:06:42,260
you have our execute method to help with

00:06:40,930 --> 00:06:45,440
actually actually sending

00:06:42,260 --> 00:06:49,120
Corie and then when the coil sent to the

00:06:45,440 --> 00:06:51,530
server and in the rendering code it

00:06:49,120 --> 00:06:54,260
executed with the callback when it's

00:06:51,530 --> 00:06:57,260
finished and this simple thin wrapper

00:06:54,260 --> 00:06:59,180
even though very simple it becomes super

00:06:57,260 --> 00:07:02,480
helpful since many other many of our

00:06:59,180 --> 00:07:05,420
queries are reused - in production to

00:07:02,480 --> 00:07:09,430
fetch data for let's say timeline photos

00:07:05,420 --> 00:07:12,980
and the news feed things like that so

00:07:09,430 --> 00:07:15,230
this is roughly how we model our quarry

00:07:12,980 --> 00:07:20,330
request but how do we approach modern

00:07:15,230 --> 00:07:23,570
layout responses and this is like the

00:07:20,330 --> 00:07:25,220
simplest diagram that to illustrate how

00:07:23,570 --> 00:07:27,800
responses are composed from the server

00:07:25,220 --> 00:07:29,330
we have our server and using the custom

00:07:27,800 --> 00:07:31,670
parser that we'll build from the tool

00:07:29,330 --> 00:07:35,570
chain we can model the intermediate

00:07:31,670 --> 00:07:37,520
representations for our responses if you

00:07:35,570 --> 00:07:43,010
think about our type system though and

00:07:37,520 --> 00:07:44,210
how it powers our core is going out what

00:07:43,010 --> 00:07:47,180
makes it it only makes sense to

00:07:44,210 --> 00:07:49,910
translate those types in client-side to

00:07:47,180 --> 00:07:52,880
mimic the kind of introspection of our

00:07:49,910 --> 00:07:58,640
type system right which is a schema so

00:07:52,880 --> 00:08:01,160
naturally we do something like this so

00:07:58,640 --> 00:08:04,730
that's one example quarry or fragment in

00:08:01,160 --> 00:08:06,620
this case and since me field I'm sorry

00:08:04,730 --> 00:08:10,070
since our name field and friends filled

00:08:06,620 --> 00:08:12,050
it with Suns user types oh then we turn

00:08:10,070 --> 00:08:14,780
string and friends returns our list of

00:08:12,050 --> 00:08:17,420
users right so it makes sense to create

00:08:14,780 --> 00:08:20,300
a user model that's used in parsing the

00:08:17,420 --> 00:08:23,600
response of this query fragment and we

00:08:20,300 --> 00:08:25,780
call this a type based model and note

00:08:23,600 --> 00:08:28,040
that even though we're only query for

00:08:25,780 --> 00:08:30,650
name and list of friends and name for

00:08:28,040 --> 00:08:33,410
them we have methods to get other

00:08:30,650 --> 00:08:37,970
information such as current city the age

00:08:33,410 --> 00:08:39,800
and little pets more than one because

00:08:37,970 --> 00:08:42,460
other quarries must have coitus field

00:08:39,800 --> 00:08:46,670
within our universe right and then on

00:08:42,460 --> 00:08:51,410
and making this type like like a source

00:08:46,670 --> 00:08:53,270
of truth the type to go right this

00:08:51,410 --> 00:08:56,030
becomes very problematic on evil over

00:08:53,270 --> 00:08:57,530
time and before I show you why it is

00:08:56,030 --> 00:08:59,510
like to show your new approach you were

00:08:57,530 --> 00:09:03,770
taking to model the responses which is a

00:08:59,510 --> 00:09:08,360
fragment based model and it looks like

00:09:03,770 --> 00:09:10,940
this so you see the same example

00:09:08,360 --> 00:09:13,550
fragment name and Friends and instead of

00:09:10,940 --> 00:09:16,310
trying to know which natural type each

00:09:13,550 --> 00:09:18,560
field returns a fragment based model

00:09:16,310 --> 00:09:21,950
takes a single fragment or query or a

00:09:18,560 --> 00:09:24,380
graphic Ã¹l language and tries to model

00:09:21,950 --> 00:09:27,020
just that you can see there is a class

00:09:24,380 --> 00:09:29,000
of a fragment and there are methods to

00:09:27,020 --> 00:09:30,380
get only the information you've chording

00:09:29,000 --> 00:09:33,650
only other information you need to

00:09:30,380 --> 00:09:36,110
render the view in the original fragment

00:09:33,650 --> 00:09:39,230
and it models the friend

00:09:36,110 --> 00:09:42,020
so in friends and name it's allocating

00:09:39,230 --> 00:09:45,140
it's getting list of friends what it

00:09:42,020 --> 00:09:46,610
tries to model is the friends from the

00:09:45,140 --> 00:09:50,000
list of friends returned there's another

00:09:46,610 --> 00:09:52,250
representation and doing this we

00:09:50,000 --> 00:09:53,960
suddenly separate the concern of having

00:09:52,250 --> 00:09:56,540
to know the return type you get back

00:09:53,960 --> 00:09:57,800
from the quarry or fragments since all

00:09:56,540 --> 00:10:01,790
the information you need would be

00:09:57,800 --> 00:10:04,610
modeled within it and I want to show you

00:10:01,790 --> 00:10:07,610
kind of how they compare to each other

00:10:04,610 --> 00:10:10,070
in in terms of when you're when you're

00:10:07,610 --> 00:10:12,920
when you have you render implementation

00:10:10,070 --> 00:10:16,010
and logics and it tries to fetch the

00:10:12,920 --> 00:10:20,900
information from the responses so same

00:10:16,010 --> 00:10:24,170
exam fragment you have type based model

00:10:20,900 --> 00:10:29,510
and your fragment based model and when

00:10:24,170 --> 00:10:32,660
you try to get name it calls the getname

00:10:29,510 --> 00:10:35,240
method in type based and similarly

00:10:32,660 --> 00:10:38,510
enough it gets name from the friend and

00:10:35,240 --> 00:10:40,690
paste and same for this right we get the

00:10:38,510 --> 00:10:43,640
list of friends by calling its method

00:10:40,690 --> 00:10:46,490
responsible for it and here's where

00:10:43,640 --> 00:10:47,990
where it gets started start get starts

00:10:46,490 --> 00:10:50,540
getting interesting a little bit more

00:10:47,990 --> 00:10:53,450
because note that in order for you to

00:10:50,540 --> 00:10:56,240
get the list of friends since of friend

00:10:53,450 --> 00:10:58,550
is your user you need to access an

00:10:56,240 --> 00:11:00,410
entire object to follow that whereas in

00:10:58,550 --> 00:11:02,150
a fragment based modeling you have

00:11:00,410 --> 00:11:06,320
another intermediate representation for

00:11:02,150 --> 00:11:08,000
the friend and then this just gets a

00:11:06,320 --> 00:11:11,960
name at the end

00:11:08,000 --> 00:11:13,040
so in the example fragment you saw that

00:11:11,960 --> 00:11:15,220
to get friends

00:11:13,040 --> 00:11:19,010
you needed to refer to a user class

00:11:15,220 --> 00:11:20,540
right but what you see here is another

00:11:19,010 --> 00:11:22,970
limitation of the type based models

00:11:20,540 --> 00:11:25,100
which is that in order to operate with

00:11:22,970 --> 00:11:27,620
the type based models you have to build

00:11:25,100 --> 00:11:29,060
one giant library that includes all the

00:11:27,620 --> 00:11:31,310
time models that have implementation

00:11:29,060 --> 00:11:35,300
code refer to this library so one quick

00:11:31,310 --> 00:11:37,970
example is from the example you saw over

00:11:35,300 --> 00:11:41,540
here right what if we wanted to Corre

00:11:37,970 --> 00:11:43,490
Corre or or have asked for page info

00:11:41,540 --> 00:11:46,850
what if we wanted to know the profile

00:11:43,490 --> 00:11:49,790
picture right then just knowing about

00:11:46,850 --> 00:11:52,400
user type is not sufficient you have to

00:11:49,790 --> 00:11:54,560
go into the schema find whatever type

00:11:52,400 --> 00:11:56,600
you want the information arrows and then

00:11:54,560 --> 00:11:58,730
include in your library or just know

00:11:56,600 --> 00:12:00,830
about them and it quickly becomes you

00:11:58,730 --> 00:12:03,890
have to know all the types in your

00:12:00,830 --> 00:12:06,110
system whereas in fragment model by

00:12:03,890 --> 00:12:09,080
using fragment based models each model

00:12:06,110 --> 00:12:11,090
becomes a library of its own and you can

00:12:09,080 --> 00:12:13,610
already see how it becomes a lot modular

00:12:11,090 --> 00:12:20,060
then having one giant library to you

00:12:13,610 --> 00:12:21,650
know for all the models compiled and I

00:12:20,060 --> 00:12:24,890
want to illustrate another problem which

00:12:21,650 --> 00:12:29,060
is so this is an earnest situation right

00:12:24,890 --> 00:12:32,420
it's trying to the highlighter yellow

00:12:29,060 --> 00:12:34,220
highlighted part is that this shows the

00:12:32,420 --> 00:12:37,520
implementation code trying to get the

00:12:34,220 --> 00:12:39,470
list of pets right but in the query or

00:12:37,520 --> 00:12:42,860
fragment you haven't quarry the

00:12:39,470 --> 00:12:46,390
information so I'm showing you this

00:12:42,860 --> 00:12:48,830
because the fragment based model

00:12:46,390 --> 00:12:52,520
definitely avoids this problem of under

00:12:48,830 --> 00:12:55,220
fetching so assuming this code is the

00:12:52,520 --> 00:12:57,350
rendering code the bottom code using

00:12:55,220 --> 00:12:58,820
client-side in pipes pipe based models

00:12:57,350 --> 00:13:00,560
there's no way to catch this error

00:12:58,820 --> 00:13:02,720
unless this code gets into the

00:13:00,560 --> 00:13:03,950
production and runs only to find out

00:13:02,720 --> 00:13:07,310
that we didn't call it for pets

00:13:03,950 --> 00:13:08,990
information and in fragrant based model

00:13:07,310 --> 00:13:10,550
we can catch this bug while the code is

00:13:08,990 --> 00:13:13,460
being compelled to run since we haven't

00:13:10,550 --> 00:13:15,970
generated but get pets method because it

00:13:13,460 --> 00:13:15,970
wasn't worried

00:13:16,550 --> 00:13:23,120
kind of summing up all this I want to

00:13:19,460 --> 00:13:25,490
show you kind of table view of the pros

00:13:23,120 --> 00:13:28,280
and why we chose to use fragment based

00:13:25,490 --> 00:13:31,190
model number of models you have to know

00:13:28,280 --> 00:13:33,440
for type based is maybe multiple it

00:13:31,190 --> 00:13:35,810
doesn't have to be one it could be many

00:13:33,440 --> 00:13:38,000
but in fragment based you have one per

00:13:35,810 --> 00:13:40,610
fragment overfitting and underfitting

00:13:38,000 --> 00:13:42,530
problem it's very very difficult to

00:13:40,610 --> 00:13:44,600
solve when you use type based model but

00:13:42,530 --> 00:13:46,520
in fragment based model you solve

00:13:44,600 --> 00:13:48,470
overfitting by aesthetically analyzing

00:13:46,520 --> 00:13:50,480
your quarry being used and under

00:13:48,470 --> 00:13:53,420
fetching you just come across it when

00:13:50,480 --> 00:13:55,970
you're compiling and talking about

00:13:53,420 --> 00:13:57,740
modularity in pipettes model you have

00:13:55,970 --> 00:13:57,980
one single giant library like I told you

00:13:57,740 --> 00:14:00,170
about

00:13:57,980 --> 00:14:02,810
but in fragment base you have one

00:14:00,170 --> 00:14:08,270
library per each fragment which becomes

00:14:02,810 --> 00:14:13,010
a lot usable yeah excited alright let's

00:14:08,270 --> 00:14:18,920
talk about graphical yeah I love this

00:14:13,010 --> 00:14:21,800
tool by the way graphical is it's helped

00:14:18,920 --> 00:14:23,360
me even me a lot but in facebook we have

00:14:21,800 --> 00:14:26,450
certain limitations and I want to show

00:14:23,360 --> 00:14:31,480
you what they are and what we did to

00:14:26,450 --> 00:14:33,530
solve them well first of all Facebook

00:14:31,480 --> 00:14:38,300
gradual schema is huge

00:14:33,530 --> 00:14:42,290
it is enormous how large it is is it's

00:14:38,300 --> 00:14:46,430
70 megabytes it's so yeah it's this is

00:14:42,290 --> 00:14:50,440
pretty pretty big it's 70 megabytes when

00:14:46,430 --> 00:14:52,910
uncompressed and 200 megabytes for the

00:14:50,440 --> 00:14:55,220
before we open source this syntax we had

00:14:52,910 --> 00:14:59,839
another syntax and for that syntax the

00:14:55,220 --> 00:15:04,010
schema gets 200 megabytes yes this is

00:14:59,839 --> 00:15:06,290
pretty big right and since graphical is

00:15:04,010 --> 00:15:08,120
powered by a graphical type system for

00:15:06,290 --> 00:15:11,420
introspection of it we need this

00:15:08,120 --> 00:15:13,730
information right so to mitigate this

00:15:11,420 --> 00:15:15,500
issue with a couple of things we do one

00:15:13,730 --> 00:15:18,410
thing is we allowed graphical to be

00:15:15,500 --> 00:15:20,330
usable without having the type system we

00:15:18,410 --> 00:15:21,950
can execute the quarry and that that was

00:15:20,330 --> 00:15:25,339
about it and we can run the validation

00:15:21,950 --> 00:15:27,000
in though in the in the execution time

00:15:25,339 --> 00:15:29,030
and there was about it

00:15:27,000 --> 00:15:32,670
but graphical has so many features like

00:15:29,030 --> 00:15:34,800
Piper has validations and linting and

00:15:32,670 --> 00:15:38,520
documentation they all in his schema to

00:15:34,800 --> 00:15:40,860
run so next natural responses

00:15:38,520 --> 00:15:42,930
hey let's catch this right we do the

00:15:40,860 --> 00:15:45,690
server-side caching with the client-side

00:15:42,930 --> 00:15:48,140
caching or using index TV but one

00:15:45,690 --> 00:15:52,650
problem we couldn't solve by doing this

00:15:48,140 --> 00:15:55,710
memorizing is when you're trying to par

00:15:52,650 --> 00:16:00,330
70 megabytes in 200 megabytes on browser

00:15:55,710 --> 00:16:05,100
it freezes and how bad it is is recorded

00:16:00,330 --> 00:16:07,710
or something for this yeah and that's

00:16:05,100 --> 00:16:11,760
not my computer crashing it's a lizard

00:16:07,710 --> 00:16:13,350
browser it's like giving up and I can I

00:16:11,760 --> 00:16:16,110
can show you more for it this goes on

00:16:13,350 --> 00:16:17,390
for 20 seconds so if there was how bad

00:16:16,110 --> 00:16:20,970
it was

00:16:17,390 --> 00:16:22,800
so the solution we're using the

00:16:20,970 --> 00:16:26,220
introduction right now is parsing that

00:16:22,800 --> 00:16:28,470
JSON file incrementally as the HTTP

00:16:26,220 --> 00:16:31,110
stream goes on fills the pieces of it

00:16:28,470 --> 00:16:35,160
and we call this streaming JSON parser

00:16:31,110 --> 00:16:39,050
so the idea is instead of blocking out

00:16:35,160 --> 00:16:41,370
the main thread javascript for parsing

00:16:39,050 --> 00:16:43,380
streaming json parser breaks up into

00:16:41,370 --> 00:16:45,360
work into multiple pieces so that

00:16:43,380 --> 00:16:46,530
parsing continues without having to

00:16:45,360 --> 00:16:49,320
reserve the main threat for the

00:16:46,530 --> 00:16:50,370
considerable amount of time and let's

00:16:49,320 --> 00:16:54,000
just see it in action

00:16:50,370 --> 00:16:56,280
so same schemas loading and kind of

00:16:54,000 --> 00:16:58,740
looking from the cursor blinking that

00:16:56,280 --> 00:17:03,420
it's completely usable immediately

00:16:58,740 --> 00:17:06,030
available for you and so yeah this just

00:17:03,420 --> 00:17:08,250
improves user experience tons right from

00:17:06,030 --> 00:17:13,170
20 seconds to a half second of blinking

00:17:08,250 --> 00:17:16,319
it's it's a it's a win for us but going

00:17:13,170 --> 00:17:18,209
further about that is we only use this

00:17:16,319 --> 00:17:21,060
to invalidate the project cache and

00:17:18,209 --> 00:17:23,699
update just the recent changes so we're

00:17:21,060 --> 00:17:27,780
pulling down the cache and using that to

00:17:23,699 --> 00:17:30,990
power the graphical and then we under in

00:17:27,780 --> 00:17:33,630
the background we run this JSON parser

00:17:30,990 --> 00:17:36,300
to get the schema and parse the schema

00:17:33,630 --> 00:17:39,290
and as soon as it's available we serve

00:17:36,300 --> 00:17:41,690
it up to cache and invalidate it

00:17:39,290 --> 00:17:43,280
fair warning is like doing getting

00:17:41,690 --> 00:17:45,740
trying to get the on ready state change

00:17:43,280 --> 00:17:49,790
and trying to get like some cake does

00:17:45,740 --> 00:17:51,470
per whatever take it it's it becomes 3

00:17:49,790 --> 00:17:52,160
times fluid and actually calling

00:17:51,470 --> 00:17:54,740
json.parse

00:17:52,160 --> 00:17:58,309
but though we knees over here the user

00:17:54,740 --> 00:18:02,600
experiences it's a whole lot better cool

00:17:58,309 --> 00:18:05,150
alright so some of the things

00:18:02,600 --> 00:18:06,440
graphically at Facebook does is to okay

00:18:05,150 --> 00:18:08,780
first of all you just saw deal with a

00:18:06,440 --> 00:18:10,880
huge schema and second OVA provide hooks

00:18:08,780 --> 00:18:13,360
for support for if experimental features

00:18:10,880 --> 00:18:21,980
and what you see over here is

00:18:13,360 --> 00:18:24,650
subscriptions that's my wall post and as

00:18:21,980 --> 00:18:30,650
I type you see the comments being

00:18:24,650 --> 00:18:32,600
updated life and I only want to show

00:18:30,650 --> 00:18:34,400
that you show you this not not to promo

00:18:32,600 --> 00:18:36,230
subscriptions in any way because it's

00:18:34,400 --> 00:18:39,740
still very early in stage and it's still

00:18:36,230 --> 00:18:41,330
experimental feature but if you wanted

00:18:39,740 --> 00:18:43,429
to play with this idea because it's been

00:18:41,330 --> 00:18:44,570
out there and I know some of the open

00:18:43,429 --> 00:18:47,990
source communities are playing with this

00:18:44,570 --> 00:18:49,850
idea graphical tries it's best to be up

00:18:47,990 --> 00:18:52,730
to date with the specification or

00:18:49,850 --> 00:18:54,860
experimental features that graph QL or

00:18:52,730 --> 00:18:58,400
go graphic you expect documentation

00:18:54,860 --> 00:19:07,370
suggests and it's available in graphical

00:18:58,400 --> 00:19:18,760
today all right who loves graphical this

00:19:07,370 --> 00:19:24,799
guy this is such a good gif give sorry I

00:19:18,760 --> 00:19:28,640
I say it for no reason I guess I should

00:19:24,799 --> 00:19:30,559
play it but uh yeah just shows you what

00:19:28,640 --> 00:19:33,679
you can do exactly what you can do with

00:19:30,559 --> 00:19:36,380
the graphical right you can do type or

00:19:33,679 --> 00:19:40,160
it can autocomplete leaves leaf node it

00:19:36,380 --> 00:19:44,750
can lint and validate the quarries as

00:19:40,160 --> 00:19:47,360
you type this is pretty neat right it's

00:19:44,750 --> 00:19:48,960
pretty cool what if you can do this in

00:19:47,360 --> 00:19:51,420
your own ID ID

00:19:48,960 --> 00:19:55,500
what if you have nuclide you have Adam

00:19:51,420 --> 00:19:58,710
you have IntelliJ or something that you

00:19:55,500 --> 00:20:02,010
can work on work with this and have this

00:19:58,710 --> 00:20:04,800
feature so I want to kind of show you a

00:20:02,010 --> 00:20:06,090
little bit of sneak peek and preview of

00:20:04,800 --> 00:20:08,130
what I've been working on for the past

00:20:06,090 --> 00:20:11,580
couple month which is the graphical

00:20:08,130 --> 00:20:15,620
language service and I know a live demos

00:20:11,580 --> 00:20:18,270
are bad or I should do a live demo so

00:20:15,620 --> 00:20:20,040
here it's a I don't know if you can see

00:20:18,270 --> 00:20:22,350
this play it so test a graphical file

00:20:20,040 --> 00:20:24,450
and I have just thought this

00:20:22,350 --> 00:20:29,550
experimental language service I'm

00:20:24,450 --> 00:20:31,110
developing enabled and you can already

00:20:29,550 --> 00:20:33,330
see the syntax highlighting thanks to

00:20:31,110 --> 00:20:35,190
our Robert most all go in the open

00:20:33,330 --> 00:20:36,390
source community he he built this syntax

00:20:35,190 --> 00:20:40,170
highlighter for Adam I'm just

00:20:36,390 --> 00:20:42,570
frantically using it it's amazing yeah

00:20:40,170 --> 00:20:44,790
you already see the lint right over here

00:20:42,570 --> 00:20:49,770
and this is a syntax error that you see

00:20:44,790 --> 00:20:52,970
from the graphical right and since this

00:20:49,770 --> 00:20:55,640
contains a star schema they sloppy that

00:20:52,970 --> 00:20:59,070
that's available you know in open source

00:20:55,640 --> 00:21:02,220
it let's try calling something here Oh

00:20:59,070 --> 00:21:05,940
human I practiced with humans so let's

00:21:02,220 --> 00:21:09,420
go human and I try to quarry what I D

00:21:05,940 --> 00:21:11,880
right and there is an error says well

00:21:09,420 --> 00:21:13,160
you know some kind of ID as a string so

00:21:11,880 --> 00:21:22,110
let me go

00:21:13,160 --> 00:21:23,520
editing our equals to two and we thought

00:21:22,110 --> 00:21:26,330
friends it's know me so let's get some

00:21:23,520 --> 00:21:29,400
friends and it could be a lot better

00:21:26,330 --> 00:21:31,230
without being in the menu but another

00:21:29,400 --> 00:21:33,090
thing we can do it because this is all

00:21:31,230 --> 00:21:35,130
JavaScript this is all reference

00:21:33,090 --> 00:21:39,540
implementation we can autocomplete

00:21:35,130 --> 00:21:45,380
leaves right here it does this pretty

00:21:39,540 --> 00:21:45,380
cool right all right dan was over

00:21:45,540 --> 00:21:56,040
all right I'm excited that you're

00:21:52,140 --> 00:22:01,110
excited because this is I want this to

00:21:56,040 --> 00:22:02,790
be so my goal for this is you know how a

00:22:01,110 --> 00:22:04,980
graphic yo has this whole community of

00:22:02,790 --> 00:22:07,140
you know graphical tools and graphical

00:22:04,980 --> 00:22:09,300
clients and servers I want this to be

00:22:07,140 --> 00:22:12,690
another community like self community so

00:22:09,300 --> 00:22:15,090
that we can gather the language services

00:22:12,690 --> 00:22:18,090
for each ideas and we can share them we

00:22:15,090 --> 00:22:20,460
can improve them together and yeah and

00:22:18,090 --> 00:22:23,910
and what you can do in graphical you can

00:22:20,460 --> 00:22:26,940
do in in just in your idea of your

00:22:23,910 --> 00:22:30,240
choice so that's all I have today -

00:22:26,940 --> 00:22:32,520
these are some links help helpful links

00:22:30,240 --> 00:22:35,790
that you can of take a look but on top

00:22:32,520 --> 00:22:37,200
of is our slack we occasionally hang out

00:22:35,790 --> 00:22:39,330
at these days and we try to be more

00:22:37,200 --> 00:22:43,920
available or ask any questions over

00:22:39,330 --> 00:22:46,680
there graphical link and then if you

00:22:43,920 --> 00:22:48,600
just came across graph QL and if you

00:22:46,680 --> 00:22:50,370
wanted to know more about it learning

00:22:48,600 --> 00:22:54,140
graphic yo.com is an amazing website you

00:22:50,370 --> 00:22:58,080
can go to but last but not the least

00:22:54,140 --> 00:22:59,700
graphical that work and I want to close

00:22:58,080 --> 00:23:00,270
off by saying we don't have all the

00:22:59,700 --> 00:23:03,450
answers

00:23:00,270 --> 00:23:05,400
so these are we can only improve in

00:23:03,450 --> 00:23:09,210
graphical comedian okay no need proof if

00:23:05,400 --> 00:23:11,820
you guys can contribute and support us

00:23:09,210 --> 00:23:14,160
and with the amazing tools and amazing

00:23:11,820 --> 00:23:17,790
servers and all these like mind breaking

00:23:14,160 --> 00:23:19,710
stuff and please reach out to us or any

00:23:17,790 --> 00:23:23,370
of the graphic community people if you

00:23:19,710 --> 00:23:27,180
have any ideas questions or concerns you

00:23:23,370 --> 00:23:30,500
know just improvements and yeah I thank

00:23:27,180 --> 00:23:30,500
you for your time thanks for having me

00:23:35,580 --> 00:23:52,149
all right questions hi thanks for the

00:23:48,009 --> 00:23:55,139
talk um it was wonderful so learn how

00:23:52,149 --> 00:23:59,259
Facebook manages a schema that large

00:23:55,139 --> 00:24:02,109
when you don't have no name spaces or

00:23:59,259 --> 00:24:05,409
really like you can't have name clashes

00:24:02,109 --> 00:24:08,559
so how do you deal with a 200 megabyte

00:24:05,409 --> 00:24:12,519
schema that must be a crazy number of

00:24:08,559 --> 00:24:15,129
types and interfaces and so all right I

00:24:12,519 --> 00:24:16,659
guess the question is Facebook schema is

00:24:15,129 --> 00:24:20,080
pretty huge how do how do we deal with

00:24:16,659 --> 00:24:23,320
that and before answering your question

00:24:20,080 --> 00:24:25,779
I'm gonna just come out and say I have a

00:24:23,320 --> 00:24:28,479
couple of Facebook Graph graticule sort

00:24:25,779 --> 00:24:30,609
of members in this audience and we're

00:24:28,479 --> 00:24:34,149
gonna hang out please raise your hand if

00:24:30,609 --> 00:24:36,399
you are here so you can go ask them the

00:24:34,149 --> 00:24:41,739
questions but I'll try to answer this

00:24:36,399 --> 00:24:44,739
question because so Facebook schema is

00:24:41,739 --> 00:24:46,899
huge and how we manage it is just like

00:24:44,739 --> 00:24:49,029
this just solving as we come across

00:24:46,899 --> 00:24:50,950
right so this probably is specific to

00:24:49,029 --> 00:24:54,669
graphical and projects so we solve it by

00:24:50,950 --> 00:24:57,090
you know doing all this and then when

00:24:54,669 --> 00:25:00,220
we're generating code and running

00:24:57,090 --> 00:25:01,840
services and running servers they also

00:25:00,220 --> 00:25:04,330
have their own problem sets of problems

00:25:01,840 --> 00:25:05,529
because I'm gonna talk about code

00:25:04,330 --> 00:25:09,820
generation because that's what I've been

00:25:05,529 --> 00:25:11,229
working on working for and when we were

00:25:09,820 --> 00:25:12,700
generating code there are some

00:25:11,229 --> 00:25:15,129
considerable amount of time that we

00:25:12,700 --> 00:25:18,249
spend to you know build and compile and

00:25:15,129 --> 00:25:20,499
you know know and parse and visit visit

00:25:18,249 --> 00:25:23,349
using the visitor all those good stuff

00:25:20,499 --> 00:25:27,070
and they actually take more time than

00:25:23,349 --> 00:25:29,379
we'd like it to be so you know it's it's

00:25:27,070 --> 00:25:31,720
really just without content it's hard to

00:25:29,379 --> 00:25:34,299
really answer and that's where the our

00:25:31,720 --> 00:25:37,539
graphical members can help you and I

00:25:34,299 --> 00:25:41,349
guess my short answer is we just solve

00:25:37,539 --> 00:25:42,890
it and manage it as as we go and we also

00:25:41,349 --> 00:25:46,670
understand whether we like

00:25:42,890 --> 00:25:49,580
like the largest schema out there so

00:25:46,670 --> 00:25:51,230
it's it's really about learning the from

00:25:49,580 --> 00:25:53,660
the mistakes maybe we make some mistakes

00:25:51,230 --> 00:25:56,510
learning from the mistakes and really

00:25:53,660 --> 00:25:58,910
developing all these you know I'll say

00:25:56,510 --> 00:26:02,390
best practices or like some things don't

00:25:58,910 --> 00:26:04,100
some decisions we've made too and we

00:26:02,390 --> 00:26:07,700
like to share that we like to talk about

00:26:04,100 --> 00:26:11,630
this like this we'd like to manage it in

00:26:07,700 --> 00:26:12,800
a way that I guess I'm the shorter

00:26:11,630 --> 00:26:16,820
answer is we don't know all the answers

00:26:12,800 --> 00:26:20,060
again well we were just coming cost with

00:26:16,820 --> 00:26:22,460
them and solving them as amiibo I all

00:26:20,060 --> 00:26:29,240
hang around after this so I can answer

00:26:22,460 --> 00:26:31,220
more questions I was just wondering how

00:26:29,240 --> 00:26:32,870
do you get set up with graphical is it

00:26:31,220 --> 00:26:34,940
like a desktop application that you

00:26:32,870 --> 00:26:37,730
download or is it like you'd put you'd

00:26:34,940 --> 00:26:39,800
put it into your into your development

00:26:37,730 --> 00:26:43,130
and it would be like facebook.com slash

00:26:39,800 --> 00:26:47,330
graphical all of those both I can answer

00:26:43,130 --> 00:26:51,160
this question it could be it is right

00:26:47,330 --> 00:26:53,060
now if you go to that link over here oh

00:26:51,160 --> 00:26:57,470
there is our standalone

00:26:53,060 --> 00:27:00,310
I think sloppy enabled like a test

00:26:57,470 --> 00:27:03,080
graphical page you can go to and it's a

00:27:00,310 --> 00:27:05,210
basically in PMPM package you can

00:27:03,080 --> 00:27:06,890
download and you can embed it to your

00:27:05,210 --> 00:27:09,770
applications if you're developing with

00:27:06,890 --> 00:27:12,410
it or if you want to develop with it it

00:27:09,770 --> 00:27:14,150
can also be our I don't see why not camp

00:27:12,410 --> 00:27:17,630
your desktop application and it could

00:27:14,150 --> 00:27:20,360
also be just a tool to bring your schema

00:27:17,630 --> 00:27:22,550
in and fire up localhost in a server

00:27:20,360 --> 00:27:28,490
just local server and start using it

00:27:22,550 --> 00:27:31,480
right away you could be anything all

00:27:28,490 --> 00:27:34,010
right we have time for one more question

00:27:31,480 --> 00:27:36,470
cool so on the topic of like the

00:27:34,010 --> 00:27:38,420
Facebook schema being so large have you

00:27:36,470 --> 00:27:40,160
ever had to like rewrite the schema so I

00:27:38,420 --> 00:27:41,840
know like graph QL is really good like

00:27:40,160 --> 00:27:43,490
where you can just rewrite the resolver

00:27:41,840 --> 00:27:44,750
functions if like your application back

00:27:43,490 --> 00:27:46,010
and changes but what happens if you have

00:27:44,750 --> 00:27:51,100
to like rewrite your schema entirely

00:27:46,010 --> 00:27:54,300
when it's that large a good question so

00:27:51,100 --> 00:27:57,240
the question kind of boils down to

00:27:54,300 --> 00:27:59,100
to all ends the carnival's down to what

00:27:57,240 --> 00:28:01,380
we're doing right now at Facebook to

00:27:59,100 --> 00:28:03,690
because I mentioned briefly there we had

00:28:01,380 --> 00:28:06,600
this legacy syntax and there was like 20

00:28:03,690 --> 00:28:09,240
megabytes it's better now and it's 70 we

00:28:06,600 --> 00:28:10,440
saved like whatever 60% I came to the

00:28:09,240 --> 00:28:13,590
match

00:28:10,440 --> 00:28:18,420
but so we we saved that much but it's

00:28:13,590 --> 00:28:21,150
still large right and then the rewriting

00:28:18,420 --> 00:28:23,070
is only possible when we actually

00:28:21,150 --> 00:28:25,400
migrate so we're in the process of

00:28:23,070 --> 00:28:27,750
migrating ourselves

00:28:25,400 --> 00:28:30,060
Margaret is specific from specifically

00:28:27,750 --> 00:28:32,610
from the legacy syntax that we have to

00:28:30,060 --> 00:28:35,370
the new open source syntax and since the

00:28:32,610 --> 00:28:38,820
code base is huge we are slowly taking

00:28:35,370 --> 00:28:41,280
steps to to get there but after that um

00:28:38,820 --> 00:28:43,260
I think a couple of ideas that we're

00:28:41,280 --> 00:28:47,250
thinking about is one of the things not

00:28:43,260 --> 00:28:50,250
rewrite but maybe no the time to parse

00:28:47,250 --> 00:28:53,490
the JSON and then using like a visitor

00:28:50,250 --> 00:28:56,360
or parser in graphic UJS and we've got

00:28:53,490 --> 00:28:58,710
to do like you know we've got a moniker

00:28:56,360 --> 00:29:01,260
which is like the better way to do it

00:28:58,710 --> 00:29:03,740
right but uh we're playing with a couple

00:29:01,260 --> 00:29:06,630
of ideas we don't have you know the

00:29:03,740 --> 00:29:10,640
exact answer yet but yeah we're just

00:29:06,630 --> 00:29:10,640
hoping to get the right answer for that

00:29:12,770 --> 00:29:19,010
okay let's thank you again for his great

00:29:16,440 --> 00:29:19,010

YouTube URL: https://www.youtube.com/watch?v=7oe3gtCzDTM


