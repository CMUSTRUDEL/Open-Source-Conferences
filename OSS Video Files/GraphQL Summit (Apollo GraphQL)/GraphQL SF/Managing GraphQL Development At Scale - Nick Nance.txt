Title: Managing GraphQL Development At Scale - Nick Nance
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	Credit Karma engineer Nick Nance presents at our GraphQL in Production meetup on 8/25/16.

We're organizing the first-ever GraphQL conf! Register to attend GraphQL Summit in SF this October: http://graphqlsummit.com/

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/

Resources:
ApolloGraphQL - https://www.apollographql.com/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:03,139 --> 00:00:08,809
so our first speaker tonight is Nick

00:00:06,080 --> 00:00:11,240
he's a staff software engineer at Credit

00:00:08,809 --> 00:00:20,990
Karma and he's going to talk about how

00:00:11,240 --> 00:00:23,270
they develop a graph do all at scale all

00:00:20,990 --> 00:00:26,870
right welcome everyone good evening

00:00:23,270 --> 00:00:29,330
so I wanted to start off by just kind of

00:00:26,870 --> 00:00:32,239
getting a sense about the graph QL

00:00:29,330 --> 00:00:35,420
community so how many people actively

00:00:32,239 --> 00:00:37,520
work with graph QL every day or involved

00:00:35,420 --> 00:00:40,820
in some kind of project with it

00:00:37,520 --> 00:00:47,540
pretty good size that's that's cool who

00:00:40,820 --> 00:00:50,000
has it in production yet Wow very nice

00:00:47,540 --> 00:00:53,540
so we don't have it in production yet

00:00:50,000 --> 00:00:58,430
and we're actively we're actively

00:00:53,540 --> 00:01:01,640
building our graph QL platform but I

00:00:58,430 --> 00:01:03,649
still thought it was useful for me to

00:01:01,640 --> 00:01:06,740
kind of share what we've learned through

00:01:03,649 --> 00:01:10,130
the process kind of the value

00:01:06,740 --> 00:01:13,070
proposition that we see for graph QL at

00:01:10,130 --> 00:01:15,770
Credit Karma the tools and processes we

00:01:13,070 --> 00:01:21,110
we use when building our graph QL

00:01:15,770 --> 00:01:23,540
platform and really kind of how we how

00:01:21,110 --> 00:01:26,479
the platform works at run time which is

00:01:23,540 --> 00:01:30,320
using the Apollo server so the value

00:01:26,479 --> 00:01:32,420
proposition for us is is much like what

00:01:30,320 --> 00:01:34,340
I believe probably the value proposition

00:01:32,420 --> 00:01:36,560
is for many people but one of my

00:01:34,340 --> 00:01:41,750
responsibilities at CK is to evaluate

00:01:36,560 --> 00:01:43,670
and improve our tools and platforms for

00:01:41,750 --> 00:01:46,509
building client facing tools

00:01:43,670 --> 00:01:49,880
I'm sorry client facing applications and

00:01:46,509 --> 00:01:53,570
so part of that process we evaluated our

00:01:49,880 --> 00:01:56,570
current rest development tools and our

00:01:53,570 --> 00:02:00,700
rest development processes and found

00:01:56,570 --> 00:02:04,369
that we had quite a few issues with it

00:02:00,700 --> 00:02:07,009
issues that you're probably used to

00:02:04,369 --> 00:02:10,789
seeing if you've done any type of rest

00:02:07,009 --> 00:02:14,000
development with larger scale teams and

00:02:10,789 --> 00:02:15,870
applications so on the left side you've

00:02:14,000 --> 00:02:18,049
got the front-end development team

00:02:15,870 --> 00:02:20,670
is challenged by having to make multiple

00:02:18,049 --> 00:02:23,129
requests in order to get the data that

00:02:20,670 --> 00:02:27,989
they need in order to render pages that

00:02:23,129 --> 00:02:29,580
they need to render you oftentimes hear

00:02:27,989 --> 00:02:32,129
them talking about waiting on the

00:02:29,580 --> 00:02:36,959
backend development teams to build api's

00:02:32,129 --> 00:02:39,090
for them and on the backend side you've

00:02:36,959 --> 00:02:41,489
got the backend teams complaining about

00:02:39,090 --> 00:02:43,260
having to build aggregation services you

00:02:41,489 --> 00:02:45,810
have them complaining about the fact

00:02:43,260 --> 00:02:49,410
that they're having to be concerned with

00:02:45,810 --> 00:02:54,109
the client facing side of the AP is and

00:02:49,410 --> 00:02:57,060
it's kind of mixing the concerns and

00:02:54,109 --> 00:02:57,599
rest kind of like lands in the middle of

00:02:57,060 --> 00:03:01,319
all this

00:02:57,599 --> 00:03:05,450
so we evaluated it and we decided to

00:03:01,319 --> 00:03:07,980
introduce graph QL to the team it's been

00:03:05,450 --> 00:03:11,129
accepted quite well

00:03:07,980 --> 00:03:13,319
so several of the value propositions for

00:03:11,129 --> 00:03:15,870
us and the values that the teams have

00:03:13,319 --> 00:03:17,579
seen from it obviously if you're

00:03:15,870 --> 00:03:20,790
familiar with graph QL it's a client

00:03:17,579 --> 00:03:23,669
facing API platform so from that

00:03:20,790 --> 00:03:26,700
perspective it gives us a layer where we

00:03:23,669 --> 00:03:29,549
can abstract the needs of the client

00:03:26,700 --> 00:03:32,340
away from the server side needs about

00:03:29,549 --> 00:03:35,489
managing the business models and the

00:03:32,340 --> 00:03:37,709
business concerns we use it to do server

00:03:35,489 --> 00:03:40,200
side transformations so one of the

00:03:37,709 --> 00:03:42,419
things that we do if graph QL is we

00:03:40,200 --> 00:03:44,430
transform the data and try to get it

00:03:42,419 --> 00:03:46,859
into a structure that matches as close

00:03:44,430 --> 00:03:50,099
as possible the structure that's needed

00:03:46,859 --> 00:03:52,290
to render the pages render components

00:03:50,099 --> 00:03:55,530
within the application and I'll go over

00:03:52,290 --> 00:03:58,169
some of that in detail and it allows our

00:03:55,530 --> 00:04:02,040
back-end developers to be less concerned

00:03:58,169 --> 00:04:05,180
about the client facing api's and also

00:04:02,040 --> 00:04:09,030
cover kind of how we managed to do that

00:04:05,180 --> 00:04:13,349
so how we use graph QL so this is an

00:04:09,030 --> 00:04:15,629
example of our architecture so graph QL

00:04:13,349 --> 00:04:19,099
for us is a thin transformation and

00:04:15,629 --> 00:04:22,199
aggregation layer where we're a grinning

00:04:19,099 --> 00:04:25,469
micro-services and monolithic services

00:04:22,199 --> 00:04:27,570
so we are in the process of decomposing

00:04:25,469 --> 00:04:28,470
our monolithic application into micro

00:04:27,570 --> 00:04:31,320
services

00:04:28,470 --> 00:04:33,570
as many people are these days and/or are

00:04:31,320 --> 00:04:36,180
ready in microservices and we have a

00:04:33,570 --> 00:04:38,820
variety of micro services that that talk

00:04:36,180 --> 00:04:40,350
both rest and RPC and so that's one of

00:04:38,820 --> 00:04:42,050
the things that the graph QL layer

00:04:40,350 --> 00:04:45,600
really helps with that is to kind of

00:04:42,050 --> 00:04:48,960
manage that layer for us and provide the

00:04:45,600 --> 00:04:51,060
transformations so another way we think

00:04:48,960 --> 00:04:53,040
about using graph QL too is we think

00:04:51,060 --> 00:04:55,740
about it as a self-service platform and

00:04:53,040 --> 00:04:57,870
what I mean by self-service is I'm

00:04:55,740 --> 00:05:00,300
talking about self-service from the

00:04:57,870 --> 00:05:04,230
perspective of the client teams so this

00:05:00,300 --> 00:05:06,780
is a client API platform and we want it

00:05:04,230 --> 00:05:10,800
to be a tool for the client teams to

00:05:06,780 --> 00:05:12,470
build api's with it so based on that one

00:05:10,800 --> 00:05:15,840
of the things that we focus on is a

00:05:12,470 --> 00:05:18,210
platform that really works well for

00:05:15,840 --> 00:05:20,730
giving the right the tools that the

00:05:18,210 --> 00:05:24,840
client teams are familiar with so we use

00:05:20,730 --> 00:05:28,620
node in JavaScript and the node the NPM

00:05:24,840 --> 00:05:30,840
ecosystem and tools because a lot of our

00:05:28,620 --> 00:05:32,730
front-end teams are very familiar with

00:05:30,840 --> 00:05:35,760
that platform and it's something that

00:05:32,730 --> 00:05:37,500
they can build on and I'll get into kind

00:05:35,760 --> 00:05:38,810
of how we separate that out and how that

00:05:37,500 --> 00:05:41,250
works

00:05:38,810 --> 00:05:45,960
built in connectors and web frameworks

00:05:41,250 --> 00:05:47,850
so what we do with this is so I lead the

00:05:45,960 --> 00:05:50,430
platform team the client platform team

00:05:47,850 --> 00:05:52,650
and so what we do is we try to provide a

00:05:50,430 --> 00:05:56,160
platform to the front-end development

00:05:52,650 --> 00:05:58,440
team that really lowers the barrier to

00:05:56,160 --> 00:06:01,080
entry for them so we provide as much of

00:05:58,440 --> 00:06:05,810
the tooling around the platform as we

00:06:01,080 --> 00:06:08,340
can so they can focus on the API and

00:06:05,810 --> 00:06:09,960
part of that includes production logging

00:06:08,340 --> 00:06:11,669
and performance monitoring so we have

00:06:09,960 --> 00:06:13,710
all that built into our platform as well

00:06:11,669 --> 00:06:17,760
so that when it rolls to production we

00:06:13,710 --> 00:06:19,800
can properly monitor the platform so our

00:06:17,760 --> 00:06:22,380
platform looks like this is a fairly

00:06:19,800 --> 00:06:23,880
common architecture for a graph QL

00:06:22,380 --> 00:06:25,620
server so we have our web server

00:06:23,880 --> 00:06:28,350
framework that sits on top that's where

00:06:25,620 --> 00:06:31,410
the requests come in we have the schema

00:06:28,350 --> 00:06:33,660
layer where the schema is defined we

00:06:31,410 --> 00:06:36,539
have a very thin resolvers resolver

00:06:33,660 --> 00:06:39,210
layer where it connects the schema to

00:06:36,539 --> 00:06:39,490
the models and inside of our models we

00:06:39,210 --> 00:06:42,479
have

00:06:39,490 --> 00:06:46,990
our transformation and our aggregation

00:06:42,479 --> 00:06:49,479
logic the connectors are that's just a

00:06:46,990 --> 00:06:52,030
layer that connects up to our internal

00:06:49,479 --> 00:06:54,789
micro-services so it's the layer that

00:06:52,030 --> 00:06:56,740
knows how to talk RPC rest those kinds

00:06:54,789 --> 00:06:59,319
of things and so from this perspective

00:06:56,740 --> 00:07:03,370
the platform team focuses on the gray

00:06:59,319 --> 00:07:05,910
areas that's the part of the platform

00:07:03,370 --> 00:07:09,340
that we provide and it supports the

00:07:05,910 --> 00:07:12,220
front-end team in building out designing

00:07:09,340 --> 00:07:14,050
the schemas and even somewhat getting

00:07:12,220 --> 00:07:18,340
involved in building of the models and

00:07:14,050 --> 00:07:20,229
stuff this allows them to in essence

00:07:18,340 --> 00:07:22,900
provide a self-service platform that

00:07:20,229 --> 00:07:28,690
allows them to kind of build out their

00:07:22,900 --> 00:07:35,620
API themselves so another step of that

00:07:28,690 --> 00:07:38,310
comes with API design so one of the one

00:07:35,620 --> 00:07:43,000
of the things that we've learned from

00:07:38,310 --> 00:07:45,070
building ap is even REST API is that

00:07:43,000 --> 00:07:47,909
it's really important to design them

00:07:45,070 --> 00:07:50,560
upfront and try to get as much

00:07:47,909 --> 00:07:56,469
cross-functional input as possible and

00:07:50,560 --> 00:07:58,630
so when we looked at our rest our arrest

00:07:56,469 --> 00:08:00,370
tools and our rest processes those are

00:07:58,630 --> 00:08:03,550
actually some of the things that we kind

00:08:00,370 --> 00:08:06,849
of kept as we move to graph QL because

00:08:03,550 --> 00:08:09,159
it was a useful and effective approach

00:08:06,849 --> 00:08:13,990
where we were using Ramo to define our

00:08:09,159 --> 00:08:16,229
our API s and they gave us a definition

00:08:13,990 --> 00:08:19,120
language in in which we could talk to

00:08:16,229 --> 00:08:21,099
and communicate about the design of the

00:08:19,120 --> 00:08:23,889
API before anything was actually built

00:08:21,099 --> 00:08:26,770
and so we follow that same process with

00:08:23,889 --> 00:08:29,680
graph QL but we use the graph QL schema

00:08:26,770 --> 00:08:32,469
language um the shorthand notation in

00:08:29,680 --> 00:08:34,990
essence so when we design our schemas

00:08:32,469 --> 00:08:37,419
our schemas are actually stored in a dot

00:08:34,990 --> 00:08:40,630
graph QL file which is just a pure text

00:08:37,419 --> 00:08:42,849
file that gives us the ability to kind

00:08:40,630 --> 00:08:45,940
of open pull requests and manage pull

00:08:42,849 --> 00:08:47,650
requests and allow people to communicate

00:08:45,940 --> 00:08:49,180
about it and cross-functional teams to

00:08:47,650 --> 00:08:51,400
communicate about it because it's not

00:08:49,180 --> 00:08:52,390
code so it's not something that somebody

00:08:51,400 --> 00:08:54,070
has to read

00:08:52,390 --> 00:08:56,500
and learn and understand they can very

00:08:54,070 --> 00:08:58,510
easily read the graph QL schema so when

00:08:56,500 --> 00:09:00,610
those pull requests are open the first

00:08:58,510 --> 00:09:02,830
thing that we do is we run a validation

00:09:00,610 --> 00:09:05,290
step against queries I'll get into some

00:09:02,830 --> 00:09:07,210
details about how we do that in the

00:09:05,290 --> 00:09:09,550
tools that we use but it's important

00:09:07,210 --> 00:09:12,490
from the sense of the pull request

00:09:09,550 --> 00:09:16,270
review process so when schema changes

00:09:12,490 --> 00:09:19,570
are put into place we want to review

00:09:16,270 --> 00:09:21,160
them and we want to know from a as soon

00:09:19,570 --> 00:09:23,590
as possible if we were generating

00:09:21,160 --> 00:09:26,290
braking changes so obviously this is a

00:09:23,590 --> 00:09:29,740
very common problem with aap is you want

00:09:26,290 --> 00:09:31,630
to manage for braking changes and so

00:09:29,740 --> 00:09:34,150
what we try to do is set up the CI

00:09:31,630 --> 00:09:36,370
processes so that at the time that the

00:09:34,150 --> 00:09:38,050
akima requests are put in or the pull

00:09:36,370 --> 00:09:39,250
requests are put in for the schemas we

00:09:38,050 --> 00:09:41,020
know whether we have a breaking change

00:09:39,250 --> 00:09:42,430
or not of course we can go ahead and

00:09:41,020 --> 00:09:44,680
accept that that may be part of the plan

00:09:42,430 --> 00:09:46,750
but we know it as we're reviewing it and

00:09:44,680 --> 00:09:50,350
then we're able to publish the new

00:09:46,750 --> 00:09:53,590
schema changes under a new version and

00:09:50,350 --> 00:09:56,050
I'll also get into that as well so when

00:09:53,590 --> 00:09:59,200
it comes to API designs this is also

00:09:56,050 --> 00:10:03,220
another aspect of what we've brought

00:09:59,200 --> 00:10:05,110
forward with our REST design so this is

00:10:03,220 --> 00:10:08,620
an example component that you'll see in

00:10:05,110 --> 00:10:11,460
our application I'm not sure how many

00:10:08,620 --> 00:10:14,710
people have used our application but

00:10:11,460 --> 00:10:16,510
basically we provide credit reports and

00:10:14,710 --> 00:10:18,640
as a result of that you get a list of

00:10:16,510 --> 00:10:20,320
accounts and if you click on any one of

00:10:18,640 --> 00:10:22,300
those accounts you're going to come to

00:10:20,320 --> 00:10:23,950
an account details page and it's going

00:10:22,300 --> 00:10:26,080
to give you a table that looks something

00:10:23,950 --> 00:10:28,750
like this and the reason why I'm showing

00:10:26,080 --> 00:10:30,430
you this is because it's important to

00:10:28,750 --> 00:10:33,630
understand kind of how we're driving

00:10:30,430 --> 00:10:36,280
this right so this is the data structure

00:10:33,630 --> 00:10:37,720
it's not an exact representation of the

00:10:36,280 --> 00:10:39,280
data structure but it's somewhat of

00:10:37,720 --> 00:10:41,020
representation of the data structure

00:10:39,280 --> 00:10:42,640
that we would send down to the client in

00:10:41,020 --> 00:10:46,540
order to render that component and

00:10:42,640 --> 00:10:48,370
notice how that almost mirrors the axial

00:10:46,540 --> 00:10:50,880
component itself because what we're

00:10:48,370 --> 00:10:53,440
trying to do is minimize as much

00:10:50,880 --> 00:10:55,330
transformation at the client as possible

00:10:53,440 --> 00:10:56,850
because X scatters the transformation

00:10:55,330 --> 00:10:59,320
logic across all of our platforms

00:10:56,850 --> 00:11:03,340
understand we have iOS Android mobile

00:10:59,320 --> 00:11:04,570
web and desktop web and if you're if

00:11:03,340 --> 00:11:05,450
you're trying to manage those

00:11:04,570 --> 00:11:07,670
transformation

00:11:05,450 --> 00:11:09,650
across all those all those platforms you

00:11:07,670 --> 00:11:11,420
can get challenging so we try to get it

00:11:09,650 --> 00:11:16,700
as close as possible to what it's going

00:11:11,420 --> 00:11:19,580
to take to render that component alright

00:11:16,700 --> 00:11:21,530
so I mentioned the graph QL schema and

00:11:19,580 --> 00:11:24,730
the fact that it's in graph QL schema

00:11:21,530 --> 00:11:27,200
language and that their text files well

00:11:24,730 --> 00:11:30,500
so the other aspect of it are the

00:11:27,200 --> 00:11:34,960
queries or also you can think of them as

00:11:30,500 --> 00:11:38,120
operations they're distort queries so we

00:11:34,960 --> 00:11:41,510
also store our queries in the graph QL

00:11:38,120 --> 00:11:44,150
language in dot graph QL files in the

00:11:41,510 --> 00:11:46,790
shorthand and we pull them into the

00:11:44,150 --> 00:11:49,640
server they're published as separate NPM

00:11:46,790 --> 00:11:51,770
packages and I'll get into the the

00:11:49,640 --> 00:11:55,130
reason why we do this but the value that

00:11:51,770 --> 00:11:57,230
comes into we can use this at CI time

00:11:55,130 --> 00:11:59,990
and at the time that the application

00:11:57,230 --> 00:12:01,640
starts up but just imagine that each one

00:11:59,990 --> 00:12:03,830
of these boxes that I mentioning here

00:12:01,640 --> 00:12:05,930
that I'm showing here are all MPM

00:12:03,830 --> 00:12:08,120
packages and they can all be versioned

00:12:05,930 --> 00:12:10,340
if they need to be versioned and we can

00:12:08,120 --> 00:12:12,140
use semantic versioning to control

00:12:10,340 --> 00:12:16,550
breaking changes and things like that

00:12:12,140 --> 00:12:19,760
and so yeah we have a cute little

00:12:16,550 --> 00:12:24,080
picture of a guard here the idea of our

00:12:19,760 --> 00:12:26,870
CI process stepping in place so what

00:12:24,080 --> 00:12:32,930
happens in our CI process in part of the

00:12:26,870 --> 00:12:36,530
graph QL schema CI tooling M we have

00:12:32,930 --> 00:12:38,690
this tool called the graph QL loader and

00:12:36,530 --> 00:12:42,910
what it will do is it'll take the schema

00:12:38,690 --> 00:12:46,250
it'll take a glob of the files that are

00:12:42,910 --> 00:12:50,350
defined for the schema load all those

00:12:46,250 --> 00:12:54,310
files up and then instantiate a graph QL

00:12:50,350 --> 00:12:56,870
schema object from it so it'll parse and

00:12:54,310 --> 00:13:00,200
create a schema object it uses a graph

00:12:56,870 --> 00:13:01,400
QL j/s libraries to do that with but it

00:13:00,200 --> 00:13:04,220
just kind of combines them all together

00:13:01,400 --> 00:13:07,400
and produces a schema object then what

00:13:04,220 --> 00:13:10,280
happens is we use the same loader to

00:13:07,400 --> 00:13:12,980
load up and iterate over each one of the

00:13:10,280 --> 00:13:15,890
queries to validate whether we have

00:13:12,980 --> 00:13:17,860
broken a query related to our schema

00:13:15,890 --> 00:13:21,940
change so we may have room

00:13:17,860 --> 00:13:23,560
moved a given property that now that we

00:13:21,940 --> 00:13:25,060
have a query that's dependent on it and

00:13:23,560 --> 00:13:27,610
we can identify the fact that there's a

00:13:25,060 --> 00:13:31,120
breaking change and this is all done by

00:13:27,610 --> 00:13:34,120
loading the graph QL files so one of the

00:13:31,120 --> 00:13:36,700
advantages one of the values for us is

00:13:34,120 --> 00:13:38,800
that we can load and validate schemas

00:13:36,700 --> 00:13:40,620
without starting the server so we

00:13:38,800 --> 00:13:44,399
literally are doing all this by just

00:13:40,620 --> 00:13:47,529
loading up files iterating over the

00:13:44,399 --> 00:13:49,779
queries and validating that we've got a

00:13:47,529 --> 00:13:52,450
good schema at least as it compares to

00:13:49,779 --> 00:13:54,339
our queries and we haven't started a

00:13:52,450 --> 00:13:56,350
server we in fact we haven't done any

00:13:54,339 --> 00:13:59,740
development yet either we're still in

00:13:56,350 --> 00:14:01,180
fundamentally design stage we don't

00:13:59,740 --> 00:14:03,519
necessarily design all of our queries

00:14:01,180 --> 00:14:05,290
upfront but we can use that to validate

00:14:03,519 --> 00:14:07,839
against it

00:14:05,290 --> 00:14:10,810
this this allows us to quickly detect

00:14:07,839 --> 00:14:13,750
breaking schema changes before we start

00:14:10,810 --> 00:14:17,800
development as I mentioned before and it

00:14:13,750 --> 00:14:20,410
allows us to provide a mock server so we

00:14:17,800 --> 00:14:22,990
have a mechanism where our server can

00:14:20,410 --> 00:14:25,570
come online in mocking mode it can

00:14:22,990 --> 00:14:29,980
totally load up those the graph QL

00:14:25,570 --> 00:14:31,540
schema files turn on the mock and give

00:14:29,980 --> 00:14:34,600
you a mock server and we haven't written

00:14:31,540 --> 00:14:38,610
any code yet and in fact it's all just

00:14:34,600 --> 00:14:41,699
driven by graph QL schema language so

00:14:38,610 --> 00:14:45,660
I'm really excited to announce that

00:14:41,699 --> 00:14:47,740
we're open sourcing these tools

00:14:45,660 --> 00:14:50,079
hopefully you're going to find value in

00:14:47,740 --> 00:14:53,470
using them if you're really interested

00:14:50,079 --> 00:14:57,519
in in developing your graph QL server

00:14:53,470 --> 00:14:59,649
the way we do it's kind of our entry

00:14:57,519 --> 00:15:03,100
into open source for Credit Karma we've

00:14:59,649 --> 00:15:04,810
been kind of out there and involved in

00:15:03,100 --> 00:15:06,399
existing projects but we really haven't

00:15:04,810 --> 00:15:08,529
open sourced our own projects and this

00:15:06,399 --> 00:15:10,480
is a start so if you're really

00:15:08,529 --> 00:15:12,850
interested keep an eye on it hopefully

00:15:10,480 --> 00:15:14,829
it's going to grow we we definitely have

00:15:12,850 --> 00:15:19,690
plans for some more graph QL tools as

00:15:14,829 --> 00:15:21,490
well but the loader is as I explained it

00:15:19,690 --> 00:15:23,320
earlier loads up and creates a schema

00:15:21,490 --> 00:15:26,860
and then we have this validator tool

00:15:23,320 --> 00:15:29,770
that can load queries and compare them

00:15:26,860 --> 00:15:31,510
against a schema and you can run it as a

00:15:29,770 --> 00:15:33,460
co CLI tool or you

00:15:31,510 --> 00:15:37,060
you can run it it's got an API as well

00:15:33,460 --> 00:15:39,190
so you can write Milka tests or unit

00:15:37,060 --> 00:15:40,960
tests against it as well that all

00:15:39,190 --> 00:15:43,860
process by the way since it's running

00:15:40,960 --> 00:15:46,780
using these tools and using those files

00:15:43,860 --> 00:15:48,460
can happen in seconds because there's no

00:15:46,780 --> 00:15:50,380
dependencies that are being loaded the

00:15:48,460 --> 00:15:55,050
server's not having to be mocked out it

00:15:50,380 --> 00:15:58,420
literally is just validating the schema

00:15:55,050 --> 00:16:01,390
all right so another question for the

00:15:58,420 --> 00:16:05,910
group who's familiar with Apollo server

00:16:01,390 --> 00:16:09,820
a few people not quite as many as a

00:16:05,910 --> 00:16:12,220
graph QL but that's cool so Paolo server

00:16:09,820 --> 00:16:14,380
is part of the pall of stack it's

00:16:12,220 --> 00:16:17,680
something that we use for our runtime

00:16:14,380 --> 00:16:21,040
environments so that's how we deliver

00:16:17,680 --> 00:16:23,980
our graph QL platform so our graph QL

00:16:21,040 --> 00:16:29,170
server is built on happy we're a happy

00:16:23,980 --> 00:16:33,790
shop kind of we're happy and we also use

00:16:29,170 --> 00:16:39,550
happy e for our server framework for our

00:16:33,790 --> 00:16:41,260
web framework the Apollo server supports

00:16:39,550 --> 00:16:49,450
several frameworks out-of-the-box

00:16:41,260 --> 00:16:51,820
Express happy connect koi yep and so we

00:16:49,450 --> 00:16:54,520
use the happy plug-in and we use a happy

00:16:51,820 --> 00:16:55,840
plugin and it communicates or uses the

00:16:54,520 --> 00:16:58,530
schema loader the tools that I mentioned

00:16:55,840 --> 00:17:01,300
before to actually load up the schema

00:16:58,530 --> 00:17:03,280
when it starts up at runtime and to load

00:17:01,300 --> 00:17:05,280
up the operations now why is it

00:17:03,280 --> 00:17:08,949
important to load the operations well

00:17:05,280 --> 00:17:10,720
whitelisting query whitelisting another

00:17:08,949 --> 00:17:13,530
function of Apollo server so that's

00:17:10,720 --> 00:17:16,780
another feature of Apollo server is

00:17:13,530 --> 00:17:19,240
being able to run this use this concept

00:17:16,780 --> 00:17:22,420
called the operation store so when when

00:17:19,240 --> 00:17:25,300
our application starts up we use the

00:17:22,420 --> 00:17:30,490
schema loaders to load up the operations

00:17:25,300 --> 00:17:33,280
out of the different client modules will

00:17:30,490 --> 00:17:36,250
parse them and cache the queries into

00:17:33,280 --> 00:17:38,320
the operations store and so this is for

00:17:36,250 --> 00:17:40,060
production runtime only so it

00:17:38,320 --> 00:17:41,770
development you can send any query you

00:17:40,060 --> 00:17:43,950
want to against the server but during

00:17:41,770 --> 00:17:43,950
production

00:17:44,360 --> 00:17:50,090
this creates a query whitelist so the

00:17:47,630 --> 00:17:52,100
the way the client communicates to the

00:17:50,090 --> 00:17:54,710
server is that sense of an operation

00:17:52,100 --> 00:17:56,420
name in a set of variables and those are

00:17:54,710 --> 00:17:58,070
the only only the operations that are

00:17:56,420 --> 00:18:01,730
stored in the operation store will be

00:17:58,070 --> 00:18:03,650
allowed to be executed at runtime help

00:18:01,730 --> 00:18:05,600
prevent denial of service attacks in a

00:18:03,650 --> 00:18:08,030
variety of other things so you have a

00:18:05,600 --> 00:18:11,240
very controlled set of queries and you

00:18:08,030 --> 00:18:18,260
know what you're optimizing your server

00:18:11,240 --> 00:18:19,850
for all right so key takeaways so some

00:18:18,260 --> 00:18:23,120
of the value that we've really seen is

00:18:19,850 --> 00:18:25,130
use tools to detect breaking changes so

00:18:23,120 --> 00:18:28,280
as I mentioned before it's really

00:18:25,130 --> 00:18:31,820
interesting to be able to load a schema

00:18:28,280 --> 00:18:33,860
and load queries and invalidate queries

00:18:31,820 --> 00:18:36,470
against a schema because you can't

00:18:33,860 --> 00:18:38,000
really do that with rest like one of the

00:18:36,470 --> 00:18:40,280
things with rest is you really don't

00:18:38,000 --> 00:18:42,620
know what the clients using from your

00:18:40,280 --> 00:18:45,380
rest service you know what endpoint it's

00:18:42,620 --> 00:18:47,450
hitting but you don't know the you know

00:18:45,380 --> 00:18:51,130
any other piece of information about how

00:18:47,450 --> 00:18:53,630
it's using that and for that endpoint

00:18:51,130 --> 00:18:55,520
with graph qo the advantage there is

00:18:53,630 --> 00:18:57,710
that you've got a query now it may not

00:18:55,520 --> 00:18:59,150
be using all the data you're hoping that

00:18:57,710 --> 00:19:01,790
they're using all they're only asking

00:18:59,150 --> 00:19:04,040
for what they're using for using but at

00:19:01,790 --> 00:19:05,960
least you know that you've got to

00:19:04,040 --> 00:19:07,760
support that query and you know exactly

00:19:05,960 --> 00:19:08,900
what you're trying to support and that

00:19:07,760 --> 00:19:13,420
you don't want to create a breaking

00:19:08,900 --> 00:19:17,150
change use tools detect breaking changes

00:19:13,420 --> 00:19:19,580
this is all part of evolving a schema

00:19:17,150 --> 00:19:23,420
and schemas growing and it taking time

00:19:19,580 --> 00:19:26,240
and building out schemas building out a

00:19:23,420 --> 00:19:28,690
server I highly recommend using Apollo

00:19:26,240 --> 00:19:31,520
server in production there's certainly

00:19:28,690 --> 00:19:34,370
several value-added features to using

00:19:31,520 --> 00:19:39,010
Apollo server in production it is just a

00:19:34,370 --> 00:19:43,040
layer on top of the graph qlj s library

00:19:39,010 --> 00:19:45,110
and consider server-side transformations

00:19:43,040 --> 00:19:47,660
so a lot of times I've heard people talk

00:19:45,110 --> 00:19:49,550
about using graph QL as a way to kind of

00:19:47,660 --> 00:19:52,670
aggregate data together and aggregate

00:19:49,550 --> 00:19:54,990
endpoints and one of the things I'm

00:19:52,670 --> 00:19:58,320
proposing is to use that layer

00:19:54,990 --> 00:20:01,500
get the data transform the data closer

00:19:58,320 --> 00:20:06,120
to the real structure that a client can

00:20:01,500 --> 00:20:09,660
use virtually render components without

00:20:06,120 --> 00:20:11,880
any transformation optimally sometimes

00:20:09,660 --> 00:20:14,250
it's hard to get there in order to cover

00:20:11,880 --> 00:20:15,630
enough surfaces like a variety of

00:20:14,250 --> 00:20:18,120
different kind of surfaces that you

00:20:15,630 --> 00:20:21,390
might have to cover but optimally that's

00:20:18,120 --> 00:20:24,390
what you're going for all right that's

00:20:21,390 --> 00:20:27,809
it so I've got a shameless plug we're

00:20:24,390 --> 00:20:31,200
hiring I'm hiring reach out to me if

00:20:27,809 --> 00:20:42,840
you're interested but yeah question and

00:20:31,200 --> 00:20:45,720
answer any questions thank you you could

00:20:42,840 --> 00:20:47,550
just ask me I'm slack tonight huh I was

00:20:45,720 --> 00:20:49,710
just curious how long it's been since

00:20:47,550 --> 00:20:51,210
you decided to start using graph QL like

00:20:49,710 --> 00:20:55,770
how many months or whatever that you've

00:20:51,210 --> 00:21:00,570
taken to build all this stuff so we

00:20:55,770 --> 00:21:04,040
probably started really focused on it

00:21:00,570 --> 00:21:07,920
about four months ago but we spent a

00:21:04,040 --> 00:21:10,820
large upfront time with a bunch of proof

00:21:07,920 --> 00:21:14,340
of concepts and really low testing and

00:21:10,820 --> 00:21:18,870
evaluating graph QL implementations both

00:21:14,340 --> 00:21:21,900
a node and go in a variety of variety of

00:21:18,870 --> 00:21:25,220
implementations including Scala so like

00:21:21,900 --> 00:21:29,640
we did a lot of evaluation around it and

00:21:25,220 --> 00:21:32,940
really thought through as much of the

00:21:29,640 --> 00:21:35,730
tooling as we could up front so we front

00:21:32,940 --> 00:21:37,260
ended a lot of it with tooling and

00:21:35,730 --> 00:21:39,360
support to really kind of help the

00:21:37,260 --> 00:21:42,720
development process and you know

00:21:39,360 --> 00:21:45,900
evaluating platforms but yeah so we're

00:21:42,720 --> 00:21:47,970
probably so will go into production in

00:21:45,900 --> 00:21:51,870
the next couple of weeks start to get

00:21:47,970 --> 00:21:55,530
real production load and in a few months

00:21:51,870 --> 00:21:58,760
in the next couple of months so we're on

00:21:55,530 --> 00:21:58,760
the verge of kind of getting there

00:22:02,410 --> 00:22:07,970
at first um I'm up on the graphical

00:22:05,660 --> 00:22:09,710
order that's pretty cool thank you Oh a

00:22:07,970 --> 00:22:11,060
soldering when you showing the graph of

00:22:09,710 --> 00:22:12,890
like you have the mona lisa app and you

00:22:11,060 --> 00:22:14,360
have the services yeah and you have like

00:22:12,890 --> 00:22:16,880
a graph KL which is a kind of like a

00:22:14,360 --> 00:22:18,440
layer on top of it so when I was

00:22:16,880 --> 00:22:21,110
wondering if that's like an another

00:22:18,440 --> 00:22:24,950
service or is it why what does this

00:22:21,110 --> 00:22:26,720
decision process into that it is another

00:22:24,950 --> 00:22:28,400
service or it is like another thing that

00:22:26,720 --> 00:22:30,860
wrap around the model is like I just

00:22:28,400 --> 00:22:32,540
want to understand that products so so

00:22:30,860 --> 00:22:34,610
was the I'm not sure I understood the

00:22:32,540 --> 00:22:38,240
question so as a question is it's the

00:22:34,610 --> 00:22:42,290
graph QL service well it's a graph cool

00:22:38,240 --> 00:22:43,940
a standalone thing because from the map

00:22:42,290 --> 00:22:45,950
that you show before it looks like you

00:22:43,940 --> 00:22:47,870
have yeah so it is a standalone it says

00:22:45,950 --> 00:22:50,000
and you have to graph it like a lick

00:22:47,870 --> 00:22:50,210
layer that's okay on top of the whole

00:22:50,000 --> 00:22:52,760
thing

00:22:50,210 --> 00:22:55,430
yeah so it's a standalone service in and

00:22:52,760 --> 00:22:58,160
of itself so it it stands by itself it's

00:22:55,430 --> 00:23:00,050
not a layer on top of any of the other

00:22:58,160 --> 00:23:03,650
micro services okay so i was wondering

00:23:00,050 --> 00:23:05,630
like what was your decision process into

00:23:03,650 --> 00:23:08,090
why i can take it that way and what was

00:23:05,630 --> 00:23:11,180
the pros and cons instead of you know

00:23:08,090 --> 00:23:13,040
you could wrap it around the monolith or

00:23:11,180 --> 00:23:17,420
whatever you know some other ways yeah

00:23:13,040 --> 00:23:19,070
so um you know so ultimately so we want

00:23:17,420 --> 00:23:25,070
all of our clients communicating

00:23:19,070 --> 00:23:26,690
entirely via graph QL so so we we have

00:23:25,070 --> 00:23:28,970
currently our current REST API is

00:23:26,690 --> 00:23:32,570
actually being served by the monolith at

00:23:28,970 --> 00:23:35,360
this point until overtime ultimately we

00:23:32,570 --> 00:23:37,130
want to remove that from the monolith so

00:23:35,360 --> 00:23:40,960
we want all the traffic to come through

00:23:37,130 --> 00:23:44,060
the graph QL server and separate it from

00:23:40,960 --> 00:23:45,380
from the monolith so it does there's a

00:23:44,060 --> 00:23:48,020
little bit of kind of interesting

00:23:45,380 --> 00:23:50,920
connectivity that that occurs there but

00:23:48,020 --> 00:23:53,120
that's that's partly in preparation for

00:23:50,920 --> 00:23:55,100
ultimately having a bunch of micro

00:23:53,120 --> 00:23:57,500
services and understand that like as

00:23:55,100 --> 00:23:59,810
those micro services grow the surface of

00:23:57,500 --> 00:24:01,100
the overall API grows quite a bit and so

00:23:59,810 --> 00:24:03,260
that's why it's really important to kind

00:24:01,100 --> 00:24:06,530
of have it sitting there as an

00:24:03,260 --> 00:24:09,640
aggregation layer sure if that totally

00:24:06,530 --> 00:24:09,640
answered the question Byrne

00:24:11,830 --> 00:24:17,660
based on your experience what you will

00:24:14,900 --> 00:24:22,940
improve ingre fuel what would i improve

00:24:17,660 --> 00:24:25,040
in graph QL oh that's interesting well

00:24:22,940 --> 00:24:28,070
so I haven't really thought of that I

00:24:25,040 --> 00:24:30,350
think for us because we're trying to use

00:24:28,070 --> 00:24:32,960
the graph QL schema language the

00:24:30,350 --> 00:24:34,610
shorthand I think there's a lot of

00:24:32,960 --> 00:24:37,750
improvement that can be done there so I

00:24:34,610 --> 00:24:40,610
just found out like literally just today

00:24:37,750 --> 00:24:45,560
they landed a change where you can

00:24:40,610 --> 00:24:48,290
document descriptions for properties the

00:24:45,560 --> 00:24:50,090
the shorthand notation which you

00:24:48,290 --> 00:24:51,440
couldn't do before and I think there's a

00:24:50,090 --> 00:24:53,420
lot there's a lot that could potentially

00:24:51,440 --> 00:24:55,870
be done with annotations and things like

00:24:53,420 --> 00:24:58,460
that inside of the schema language so

00:24:55,870 --> 00:25:01,670
for us we would really like to be able

00:24:58,460 --> 00:25:04,700
to use a schema language as a way to be

00:25:01,670 --> 00:25:09,890
the source of truth for the schema

00:25:04,700 --> 00:25:12,740
itself and not really have to you know

00:25:09,890 --> 00:25:15,020
use JavaScript to kind of build out the

00:25:12,740 --> 00:25:17,420
schema side I'd like to I'd like the

00:25:15,020 --> 00:25:20,900
schema language to support all the

00:25:17,420 --> 00:25:26,840
features that the JavaScript schema

00:25:20,900 --> 00:25:30,830
builder in essence provides and then

00:25:26,840 --> 00:25:33,740
there's a yeah there's lots of things

00:25:30,830 --> 00:25:38,780
after that but okay we have time for one

00:25:33,740 --> 00:25:40,160
more question okay so I have a complex

00:25:38,780 --> 00:25:44,450
question which I'll try and pack into

00:25:40,160 --> 00:25:46,370
one question okay and that is is the the

00:25:44,450 --> 00:25:48,170
short question is is the API that you're

00:25:46,370 --> 00:25:49,970
exposing via graph QL is it a public API

00:25:48,170 --> 00:25:51,770
where you don't own the client or do you

00:25:49,970 --> 00:25:54,080
always on the client we always on the

00:25:51,770 --> 00:25:57,970
client so that's a very important aspect

00:25:54,080 --> 00:26:01,370
of of this kind of concept to kind of

00:25:57,970 --> 00:26:03,080
try to transform the data into the exact

00:26:01,370 --> 00:26:05,690
structure obviously if you're dealing

00:26:03,080 --> 00:26:07,430
with the public API you want to have a

00:26:05,690 --> 00:26:09,950
more generic solution because this is a

00:26:07,430 --> 00:26:12,440
pretty rigid solution and it works

00:26:09,950 --> 00:26:14,600
really well when you own the clients so

00:26:12,440 --> 00:26:16,610
we don't have a public API so it there

00:26:14,600 --> 00:26:18,680
are certain use cases that that makes

00:26:16,610 --> 00:26:21,040
sense for in certain use cases that it

00:26:18,680 --> 00:26:21,040
doesn't

00:26:22,990 --> 00:26:29,170
all right let's thank Nick again for a

00:26:25,910 --> 00:26:29,170

YouTube URL: https://www.youtube.com/watch?v=XOM8J4LaYFg


