Title: What's Next for Relay.js - Joe Savona
Publication date: 2017-11-16
Playlist: GraphQL SF
Description: 
	At GraphQL San Francisco's first meetup, Facebook's Joe Savona talks about their framework Relay.js, and how it leverages GraphQL to handle data requirements and mutations.

Join GraphQL San Francisco for updates on future events: http://www.meetup.com/GraphQL-SF/
Read our event summary on Medium: https://medium.com/apollo-stack/graphql-in-2016-a-growing-ecosystem-89846d9bb29e#.tis6c7a0r
Captions: 
	00:00:00,000 --> 00:00:05,400
our next speaker is Joseph ona from

00:00:02,700 --> 00:00:07,259
facebook he works on relay the graph

00:00:05,400 --> 00:00:10,440
girl client that Facebook is developing

00:00:07,259 --> 00:00:13,679
for react and he'll be telling us about

00:00:10,440 --> 00:00:15,660
what's next for relay ok so my name is

00:00:13,679 --> 00:00:17,369
Joseph Mona and I'm in software engineer

00:00:15,660 --> 00:00:21,300
at Facebook and I work on the real a

00:00:17,369 --> 00:00:22,619
core team so you may be familiar with

00:00:21,300 --> 00:00:24,269
relay but I'll kind of give a brief

00:00:22,619 --> 00:00:26,580
recap just I just to get everyone

00:00:24,269 --> 00:00:28,740
familiar so really it's a framework that

00:00:26,580 --> 00:00:31,910
we built at Facebook to manage data in

00:00:28,740 --> 00:00:34,260
complex apps and the goal is really to

00:00:31,910 --> 00:00:35,670
simplify the process of you know

00:00:34,260 --> 00:00:37,770
managing all these different data

00:00:35,670 --> 00:00:40,140
requirements fetching data paginate

00:00:37,770 --> 00:00:41,760
immunes all that stuff and we really

00:00:40,140 --> 00:00:45,360
want to allow product developers to

00:00:41,760 --> 00:00:47,789
focus on the product and with relay we

00:00:45,360 --> 00:00:51,270
we set out you know we are big users of

00:00:47,789 --> 00:00:53,070
react obviously we created it and so we

00:00:51,270 --> 00:00:54,600
wanted to keep that mental model of just

00:00:53,070 --> 00:00:57,210
you know component oriented development

00:00:54,600 --> 00:00:59,399
and allow just just the same way that

00:00:57,210 --> 00:01:01,859
react lets us stop worrying about Dom

00:00:59,399 --> 00:01:04,500
manipulation and focus on our UI and its

00:01:01,859 --> 00:01:06,540
design on interactions relay allows us

00:01:04,500 --> 00:01:08,909
to stop worrying about actually fetching

00:01:06,540 --> 00:01:12,689
data and focus on what we do once we

00:01:08,909 --> 00:01:14,820
have the data so i think you know

00:01:12,689 --> 00:01:16,470
there's been a little bit of like maybe

00:01:14,820 --> 00:01:17,759
confusion in the community people kind

00:01:16,470 --> 00:01:19,740
of look at related and everyone kind of

00:01:17,759 --> 00:01:21,810
brings their own up like perspective and

00:01:19,740 --> 00:01:23,520
i think i like hopes when they when they

00:01:21,810 --> 00:01:26,070
see relight they like oh it's the

00:01:23,520 --> 00:01:28,680
graphical client that Facebook uses in

00:01:26,070 --> 00:01:31,409
JavaScript so they have their own idea

00:01:28,680 --> 00:01:34,140
of like maybe what they expect a data

00:01:31,409 --> 00:01:36,329
client to do and so in this kind of in

00:01:34,140 --> 00:01:37,920
this talk I want to focus focus on the

00:01:36,329 --> 00:01:40,229
use cases that we are really targeting

00:01:37,920 --> 00:01:41,880
in order to help you evaluate whether

00:01:40,229 --> 00:01:43,799
relay would be a good fit for you and

00:01:41,880 --> 00:01:45,329
focus on both the use cases that we're

00:01:43,799 --> 00:01:49,200
targeting now and also or think about

00:01:45,329 --> 00:01:51,390
going forward with so the kind of like

00:01:49,200 --> 00:01:53,790
three big ones are fetching data for a

00:01:51,390 --> 00:01:58,020
view that's pretty obvious right data

00:01:53,790 --> 00:02:00,450
client pagination the end mutations but

00:01:58,020 --> 00:02:01,409
last but not least performance so none

00:02:00,450 --> 00:02:03,509
of these things would really be very

00:02:01,409 --> 00:02:05,070
useful if you could not build a large

00:02:03,509 --> 00:02:08,039
app and have it be performance enough

00:02:05,070 --> 00:02:11,280
for users to be happy and so performance

00:02:08,039 --> 00:02:12,360
is a really big goal for us so let's

00:02:11,280 --> 00:02:13,710
start just kinda

00:02:12,360 --> 00:02:15,750
briefly run through these and think

00:02:13,710 --> 00:02:18,120
about how relay how really solves these

00:02:15,750 --> 00:02:20,460
use cases so fetching data for a view

00:02:18,120 --> 00:02:22,680
and are in our experience most products

00:02:20,460 --> 00:02:24,840
want basically one behavior everywhere

00:02:22,680 --> 00:02:26,670
and that's you have some UI you want to

00:02:24,840 --> 00:02:28,770
show it you need a certain amount of

00:02:26,670 --> 00:02:30,330
data before you can even render anything

00:02:28,770 --> 00:02:32,520
and so what you want to do is show a

00:02:30,330 --> 00:02:34,830
loading indicator get all that data and

00:02:32,520 --> 00:02:36,330
then render the entire UI you don't want

00:02:34,830 --> 00:02:37,410
to have like a little bit of text and a

00:02:36,330 --> 00:02:38,580
loading spinner and then a little bit

00:02:37,410 --> 00:02:40,530
more text in a more and I'm not are

00:02:38,580 --> 00:02:42,330
loading spinner you want to just get

00:02:40,530 --> 00:02:43,980
some data as fast as you can and render

00:02:42,330 --> 00:02:45,360
it and then maybe you're going to load

00:02:43,980 --> 00:02:48,120
some additional information after that

00:02:45,360 --> 00:02:51,660
right um but we want the initial render

00:02:48,120 --> 00:02:53,700
to be as fast as possible and so we

00:02:51,660 --> 00:02:55,470
wanted to make that work with react but

00:02:53,700 --> 00:02:57,209
in react our components are split up

00:02:55,470 --> 00:02:59,910
right that's the whole point is we can

00:02:57,209 --> 00:03:02,610
decompose our UI a complex you I into

00:02:59,910 --> 00:03:04,800
small pieces and so we wanted to keep

00:03:02,610 --> 00:03:06,930
that ability to reason locally about our

00:03:04,800 --> 00:03:08,940
application and yet still get this

00:03:06,930 --> 00:03:12,770
effect of all the data is fetched

00:03:08,940 --> 00:03:15,480
immediately and so what we did is to

00:03:12,770 --> 00:03:17,040
extend react components by wrapping them

00:03:15,480 --> 00:03:19,799
in what we call a real a container and

00:03:17,040 --> 00:03:21,810
so basically we co-locate the query and

00:03:19,799 --> 00:03:23,910
the render logic so we can see them

00:03:21,810 --> 00:03:27,000
together and this helps with a lot of

00:03:23,910 --> 00:03:28,769
things so it avoids the problems of over

00:03:27,000 --> 00:03:30,060
fetching where we are actually fetching

00:03:28,769 --> 00:03:32,209
a lot more information from the server

00:03:30,060 --> 00:03:34,920
then we actually need on the client and

00:03:32,209 --> 00:03:36,330
it's not so much systematic in terms of

00:03:34,920 --> 00:03:38,880
tooling detecting which fields are

00:03:36,330 --> 00:03:40,769
actually used but there's render logic

00:03:38,880 --> 00:03:42,360
here there's query right there you can

00:03:40,769 --> 00:03:43,560
look at them and see that I don't need

00:03:42,360 --> 00:03:47,070
that field anymore so we'll just delete

00:03:43,560 --> 00:03:48,269
it it also helps protect against under

00:03:47,070 --> 00:03:50,310
fetching because again we can just look

00:03:48,269 --> 00:03:51,600
and see oh I'm not fetching the list of

00:03:50,310 --> 00:03:54,540
friends so how can I possibly render

00:03:51,600 --> 00:03:56,040
them it also makes it a lot easier to

00:03:54,540 --> 00:03:57,780
edit our application because if I just

00:03:56,040 --> 00:03:59,730
if I need some more information I add it

00:03:57,780 --> 00:04:01,320
to it the the fragment and now relay

00:03:59,730 --> 00:04:04,320
will go and fetch that information for

00:04:01,320 --> 00:04:06,959
me so how that actually works in

00:04:04,320 --> 00:04:09,360
practice is that relay can look at space

00:04:06,959 --> 00:04:11,250
astatically look at the component that

00:04:09,360 --> 00:04:15,000
we're going to render and build a static

00:04:11,250 --> 00:04:18,479
representation of the query send that to

00:04:15,000 --> 00:04:19,919
the server get the data back it

00:04:18,479 --> 00:04:22,440
basically writes it into the cache and

00:04:19,919 --> 00:04:24,900
then vens out props to the components so

00:04:22,440 --> 00:04:26,100
each component as its rendered says hey

00:04:24,900 --> 00:04:27,750
here's my fragment still

00:04:26,100 --> 00:04:30,030
or give me the data for this for this

00:04:27,750 --> 00:04:32,670
fragment gets the data and then renders

00:04:30,030 --> 00:04:36,990
and then their children go on and access

00:04:32,670 --> 00:04:39,420
data from the store so again you know

00:04:36,990 --> 00:04:40,980
kind of really is taking care of a lot

00:04:39,420 --> 00:04:44,180
of things for us and basically this

00:04:40,980 --> 00:04:47,070
entire process is orchestrated by relay

00:04:44,180 --> 00:04:50,190
so the next thing is pagination I mean

00:04:47,070 --> 00:04:52,740
so we all know you lists are ubiquitous

00:04:50,190 --> 00:04:54,570
in you eyes and for performance reasons

00:04:52,740 --> 00:04:56,250
we obviously can't go and just fetch all

00:04:54,570 --> 00:04:59,580
the items in the vast majority of cases

00:04:56,250 --> 00:05:01,230
right and for some things like for

00:04:59,580 --> 00:05:03,510
example the facebook news feed there

00:05:01,230 --> 00:05:05,670
isn't necessary necessarily in actual

00:05:03,510 --> 00:05:07,740
like categorical this is your newsfeed

00:05:05,670 --> 00:05:09,030
at this point in time it's when you

00:05:07,740 --> 00:05:10,920
asked for it we're going to generate a

00:05:09,030 --> 00:05:12,780
certain number of things that you might

00:05:10,920 --> 00:05:14,850
want to see right now but it isn't as if

00:05:12,780 --> 00:05:16,950
there's a my sequel table sitting

00:05:14,850 --> 00:05:22,080
somewhere that has the canonical list of

00:05:16,950 --> 00:05:23,700
your newsfeed so with pagination and and

00:05:22,080 --> 00:05:26,820
Sasha kind of talked a little bit about

00:05:23,700 --> 00:05:29,070
this there's kind of two like high level

00:05:26,820 --> 00:05:30,930
approaches the sort of limit offset

00:05:29,070 --> 00:05:33,360
approach where we say give me ten items

00:05:30,930 --> 00:05:35,250
after zero or ten items after ten and

00:05:33,360 --> 00:05:39,240
then there's the cursor base approached

00:05:35,250 --> 00:05:41,550
cursor based approach and cursors are

00:05:39,240 --> 00:05:44,760
really good for larger tables or that

00:05:41,550 --> 00:05:47,370
sort of algorithmic style ranking ranked

00:05:44,760 --> 00:05:49,320
list where we can basically say each

00:05:47,370 --> 00:05:50,850
item has a cursor and we want more

00:05:49,320 --> 00:05:52,890
information we ask for more information

00:05:50,850 --> 00:05:55,110
starting from that cursor whereas limit

00:05:52,890 --> 00:05:57,480
offset we've got a pc-like scan through

00:05:55,110 --> 00:05:59,400
a very very large table cursors are much

00:05:57,480 --> 00:06:01,580
more performance on the back end and so

00:05:59,400 --> 00:06:04,290
this is why we've typically used them

00:06:01,580 --> 00:06:05,910
and so in relay again we try to have

00:06:04,290 --> 00:06:08,310
like we really focus on building a

00:06:05,910 --> 00:06:10,410
declarative API so the client would

00:06:08,310 --> 00:06:14,100
express that I want to see the first ten

00:06:10,410 --> 00:06:16,410
friends later it might express that it

00:06:14,100 --> 00:06:17,550
wants to see the first 20 friends we

00:06:16,410 --> 00:06:19,260
don't have to think about what we're

00:06:17,550 --> 00:06:22,020
actually sending to the server relay

00:06:19,260 --> 00:06:23,820
takes care of that for us so it says oh

00:06:22,020 --> 00:06:25,680
you want to fetch 20 friends but we

00:06:23,820 --> 00:06:27,900
already have 10 friends so i'll subtract

00:06:25,680 --> 00:06:30,630
that for you so just like react can do

00:06:27,900 --> 00:06:32,490
Dom you know virtual Dom dipping really

00:06:30,630 --> 00:06:33,550
can sort of do virtue of virtual data

00:06:32,490 --> 00:06:35,920
dipping

00:06:33,550 --> 00:06:38,080
and construct the the creative you see

00:06:35,920 --> 00:06:43,600
on the bottom so friends first ten after

00:06:38,080 --> 00:06:45,850
the tenth cursor so the third kind of

00:06:43,600 --> 00:06:50,110
high-level use case is mutations

00:06:45,850 --> 00:06:52,090
basically data updates rights so there's

00:06:50,110 --> 00:06:53,440
a lot of a lot of things to cover with

00:06:52,090 --> 00:06:54,970
mutations and I'm not going to go into

00:06:53,440 --> 00:06:57,580
them because it's worthy of its own talk

00:06:54,970 --> 00:06:59,380
Lainey Kinzel from Facebook gave a great

00:06:57,580 --> 00:07:01,090
talk about how related mutations work

00:06:59,380 --> 00:07:03,550
and that's linked to from the github

00:07:01,090 --> 00:07:05,560
page liar for you there but at a high

00:07:03,550 --> 00:07:07,750
level they kind of fall like a very

00:07:05,560 --> 00:07:10,090
similar flow to queries we have some

00:07:07,750 --> 00:07:13,390
action and some inputs we send them to

00:07:10,090 --> 00:07:15,640
relay relay sends that constructs an

00:07:13,390 --> 00:07:17,560
actual mutation query for us send it to

00:07:15,640 --> 00:07:20,260
the server gets the response back

00:07:17,560 --> 00:07:23,320
updates the cash and then updates any

00:07:20,260 --> 00:07:24,940
affected components so again these relay

00:07:23,320 --> 00:07:26,380
containers are doing the subscription

00:07:24,940 --> 00:07:28,000
for you automatically so they're

00:07:26,380 --> 00:07:29,470
watching the store and if any of their

00:07:28,000 --> 00:07:31,750
data changes they're going to rerender

00:07:29,470 --> 00:07:33,250
automatically and because we react is

00:07:31,750 --> 00:07:35,110
going to is going to batch the updates

00:07:33,250 --> 00:07:37,150
and start from the topmost component

00:07:35,110 --> 00:07:38,800
you'll get a single you know when a

00:07:37,150 --> 00:07:40,690
change happen to the store you get one

00:07:38,800 --> 00:07:43,000
update cascading down unaffected

00:07:40,690 --> 00:07:44,920
components don't rear ender so you sort

00:07:43,000 --> 00:07:48,370
of get a good performance by default

00:07:44,920 --> 00:07:50,110
strategy relay also has things like

00:07:48,370 --> 00:07:52,570
optimistic mutation so sashko talked

00:07:50,110 --> 00:07:54,900
about adding this is coming to Apollo so

00:07:52,570 --> 00:07:57,310
these are available in real late today

00:07:54,900 --> 00:07:59,980
optimistic updates so if you toggle the

00:07:57,310 --> 00:08:02,260
like button we can instantly you know

00:07:59,980 --> 00:08:04,090
toggle the the color but for example the

00:08:02,260 --> 00:08:05,890
like sentence is a more complex thing we

00:08:04,090 --> 00:08:07,420
need that from the server so we'll send

00:08:05,890 --> 00:08:08,710
that to the server get the response back

00:08:07,420 --> 00:08:11,830
and then update with more information

00:08:08,710 --> 00:08:14,080
from the server we also can handle

00:08:11,830 --> 00:08:16,090
things like multiple updates to the same

00:08:14,080 --> 00:08:17,830
object and actually queue them up so

00:08:16,090 --> 00:08:19,390
that we don't get conflicting you know

00:08:17,830 --> 00:08:22,810
race conditions with our network

00:08:19,390 --> 00:08:24,180
requests so a fourth topic and we

00:08:22,810 --> 00:08:27,010
haven't really talked as much about this

00:08:24,180 --> 00:08:28,900
in the impasse talks and I want to focus

00:08:27,010 --> 00:08:32,560
a bit more on this today his performance

00:08:28,900 --> 00:08:35,290
so relay was designed and kind of built

00:08:32,560 --> 00:08:38,380
for real relapse we actually developed

00:08:35,290 --> 00:08:40,960
relay alongside kind of several example

00:08:38,380 --> 00:08:42,880
projects and then integrated integrated

00:08:40,960 --> 00:08:44,219
it quickly into some production

00:08:42,880 --> 00:08:47,550
applications

00:08:44,219 --> 00:08:49,439
and today every substantial diff our

00:08:47,550 --> 00:08:52,139
change that we make to the system is

00:08:49,439 --> 00:08:54,209
profiled on multiple real apps running

00:08:52,139 --> 00:08:56,879
on real devices so we're actually like

00:08:54,209 --> 00:08:59,100
we actually can tell what effect is this

00:08:56,879 --> 00:09:01,110
change going to have and so sometimes we

00:08:59,100 --> 00:09:02,339
actually have to take a regression there

00:09:01,110 --> 00:09:04,740
was a pull request from the community

00:09:02,339 --> 00:09:06,839
that had by minor you know very very

00:09:04,740 --> 00:09:08,370
minor perf regression but it did fix a

00:09:06,839 --> 00:09:10,290
bug and so he said well we have to we

00:09:08,370 --> 00:09:12,360
have to take the hit but other times

00:09:10,290 --> 00:09:14,360
we're able to see that you know we know

00:09:12,360 --> 00:09:17,939
that this change is going to make a real

00:09:14,360 --> 00:09:20,040
real benefit for our applications so

00:09:17,939 --> 00:09:21,600
let's look at a couple of the ways that

00:09:20,040 --> 00:09:24,750
were able to achieve really good

00:09:21,600 --> 00:09:27,620
performance so on the Left we have a

00:09:24,750 --> 00:09:31,019
sample like a very very simple fragment

00:09:27,620 --> 00:09:33,720
fragment on node ID and this relay doc

00:09:31,019 --> 00:09:35,819
UL tag we have a babble plugin that

00:09:33,720 --> 00:09:38,819
analyzes this and transforms this

00:09:35,819 --> 00:09:40,290
fragment so on the right is what it's

00:09:38,819 --> 00:09:41,399
actually produced by this so you'll note

00:09:40,290 --> 00:09:43,829
that it's an immediately invoked

00:09:41,399 --> 00:09:47,220
function this allows you to have local

00:09:43,829 --> 00:09:50,069
scope and it returns a object

00:09:47,220 --> 00:09:53,370
description of the query so again rather

00:09:50,069 --> 00:09:55,709
than parse this at runtime and have to

00:09:53,370 --> 00:09:57,720
like examine a very very complex AST

00:09:55,709 --> 00:09:59,879
with a simple description of the query

00:09:57,720 --> 00:10:01,980
that we can use to read the results

00:09:59,879 --> 00:10:03,750
right there right the response from the

00:10:01,980 --> 00:10:05,430
server into the cache and we have a

00:10:03,750 --> 00:10:08,309
bunch of what we call traversals that

00:10:05,430 --> 00:10:10,709
walk over this data structure to process

00:10:08,309 --> 00:10:13,379
queries so again we're using some static

00:10:10,709 --> 00:10:17,370
compilation in order to optimize what we

00:10:13,379 --> 00:10:19,620
do at runtime you'll also notice sorry

00:10:17,370 --> 00:10:21,269
we only ask for ID but there's actually

00:10:19,620 --> 00:10:23,430
two children here you'll notice that

00:10:21,269 --> 00:10:25,110
we're also querying for type name so

00:10:23,430 --> 00:10:27,809
that's something that relay dynamically

00:10:25,110 --> 00:10:30,600
inserts it says 0 node is an interface I

00:10:27,809 --> 00:10:32,850
don't know statically what concrete type

00:10:30,600 --> 00:10:34,350
the response is going to have but you

00:10:32,850 --> 00:10:37,559
might care about that you might want to

00:10:34,350 --> 00:10:40,079
say if it's if it's a picture do this if

00:10:37,559 --> 00:10:42,000
it's a video do something else and so

00:10:40,079 --> 00:10:43,889
really will automatically insert the

00:10:42,000 --> 00:10:46,170
type name field if we didn't add ID

00:10:43,889 --> 00:10:49,199
really would also add ID for us would

00:10:46,170 --> 00:10:50,519
say is ID a valid field at this type and

00:10:49,199 --> 00:10:53,550
if it is I'm going to query it for you

00:10:50,519 --> 00:10:55,410
so I can better normalize the results so

00:10:53,550 --> 00:10:56,440
again by doing these things statically

00:10:55,410 --> 00:10:58,330
we can optimize

00:10:56,440 --> 00:11:01,630
very much more and make I have a much

00:10:58,330 --> 00:11:04,390
better developer experience another

00:11:01,630 --> 00:11:05,950
thing is the our code if you look at the

00:11:04,390 --> 00:11:07,480
code base you'll see a mix of

00:11:05,950 --> 00:11:10,030
object-oriented functional programming

00:11:07,480 --> 00:11:12,220
immutability mutability caching

00:11:10,030 --> 00:11:13,870
memoization we've really looked at a lot

00:11:12,220 --> 00:11:16,000
of different strategies for optimizing

00:11:13,870 --> 00:11:18,880
the code depending on the actual use

00:11:16,000 --> 00:11:21,220
cases so for example our queries are

00:11:18,880 --> 00:11:24,640
immutable objects and what that means is

00:11:21,220 --> 00:11:27,910
when we dip them against the store we

00:11:24,640 --> 00:11:30,490
get a new object but you'll see that the

00:11:27,910 --> 00:11:32,020
new result is actually referencing items

00:11:30,490 --> 00:11:33,970
back in the query and again if you've

00:11:32,020 --> 00:11:35,740
watched one of Lee's talks about mutable

00:11:33,970 --> 00:11:37,780
jas you'll probably recognize this

00:11:35,740 --> 00:11:39,640
because it's basically how a mutable

00:11:37,780 --> 00:11:42,160
data structures work so we're avoiding

00:11:39,640 --> 00:11:44,140
creating lots of new j/s objects which

00:11:42,160 --> 00:11:49,510
is which reduces pressure on GC and

00:11:44,140 --> 00:11:52,000
improves performance again so here we're

00:11:49,510 --> 00:11:54,490
looking at an example of immutability in

00:11:52,000 --> 00:11:55,720
the the store itself is a mutable object

00:11:54,490 --> 00:11:57,730
so we've actually looked at using

00:11:55,720 --> 00:11:59,230
immutable J's for the store this is the

00:11:57,730 --> 00:12:01,120
question that just came up and it

00:11:59,230 --> 00:12:03,370
actually caused and we actually ran an

00:12:01,120 --> 00:12:05,950
experiment and using immutable J's for

00:12:03,370 --> 00:12:08,170
the store would have caused at least a

00:12:05,950 --> 00:12:10,390
30-percent performance regression on on

00:12:08,170 --> 00:12:12,940
several of our applications and so this

00:12:10,390 --> 00:12:15,280
is an example of where actual profiling

00:12:12,940 --> 00:12:16,480
on real apps and production allows us to

00:12:15,280 --> 00:12:22,000
make better decisions about how we

00:12:16,480 --> 00:12:24,100
architect the the framework so another

00:12:22,000 --> 00:12:26,230
thing is that a wonderful thing we've

00:12:24,100 --> 00:12:28,600
done for performance is look at how we

00:12:26,230 --> 00:12:30,250
schedule the work that relay is doing so

00:12:28,600 --> 00:12:32,200
there's a lot of complex things that are

00:12:30,250 --> 00:12:34,030
happening constructing a query printing

00:12:32,200 --> 00:12:36,850
it sending it to the server processing

00:12:34,030 --> 00:12:38,530
responses but the key thing is that

00:12:36,850 --> 00:12:40,060
everything that relay is doing is is

00:12:38,530 --> 00:12:42,700
technically behind an asynchronous

00:12:40,060 --> 00:12:44,380
interface right I'm going to asking

00:12:42,700 --> 00:12:46,240
fetch some data and give me back a

00:12:44,380 --> 00:12:48,760
result later obviously it's got to go to

00:12:46,240 --> 00:12:50,080
the server so now that our interface is

00:12:48,760 --> 00:12:51,640
asynchronous we have a lot of

00:12:50,080 --> 00:12:54,790
flexibility in how we do that

00:12:51,640 --> 00:12:57,280
asynchronous work and so what we've done

00:12:54,790 --> 00:12:59,589
is chopped up the these like the course

00:12:57,280 --> 00:13:01,990
stages of our processing pipeline into

00:12:59,589 --> 00:13:03,940
tasks and we have a task scheduler for

00:13:01,990 --> 00:13:05,290
how to run them so the top you can see

00:13:03,940 --> 00:13:06,970
we're injecting a scheduler that says

00:13:05,290 --> 00:13:08,800
given a task run it right away

00:13:06,970 --> 00:13:10,750
and this is really really great for

00:13:08,800 --> 00:13:12,310
start-up because everything we have to

00:13:10,750 --> 00:13:15,069
do we just get done is in as fast as

00:13:12,310 --> 00:13:16,000
possible because really we're just

00:13:15,069 --> 00:13:17,139
sitting there with a loading spinner

00:13:16,000 --> 00:13:19,569
there's nothing else that the user could

00:13:17,139 --> 00:13:21,490
be doing once we've shown something no

00:13:19,569 --> 00:13:22,870
we want to be really responsive right if

00:13:21,490 --> 00:13:24,670
the user taps we want to handle that

00:13:22,870 --> 00:13:25,959
right away if there's animations going

00:13:24,670 --> 00:13:28,689
on we don't want to interrupt that and

00:13:25,959 --> 00:13:29,949
so on the bottom you can see using set

00:13:28,689 --> 00:13:32,769
immediate where we're kind of breaking

00:13:29,949 --> 00:13:35,529
breaking things up via the micro task

00:13:32,769 --> 00:13:38,139
queue and even better on the bottom

00:13:35,529 --> 00:13:40,449
using react react natives interaction

00:13:38,139 --> 00:13:42,459
manager which allows us to schedule work

00:13:40,449 --> 00:13:44,350
around animations or gestures that may

00:13:42,459 --> 00:13:46,389
be happening so this way you get a nice

00:13:44,350 --> 00:13:48,069
smooth animation or gesture and at the

00:13:46,389 --> 00:13:53,500
end of that really will continue doing

00:13:48,069 --> 00:13:55,769
its work so a lot of people are using

00:13:53,500 --> 00:13:58,269
relay on the web and open source

00:13:55,769 --> 00:14:00,699
internally relay what's originally built

00:13:58,269 --> 00:14:02,860
for the web but we've predominantly

00:14:00,699 --> 00:14:04,480
using it in react native of course we're

00:14:02,860 --> 00:14:07,899
using on the web too but our primary

00:14:04,480 --> 00:14:10,779
focus is on react native and I think a

00:14:07,899 --> 00:14:12,490
lot of that is that on mobile a single

00:14:10,779 --> 00:14:15,579
round trip together to get our data is

00:14:12,490 --> 00:14:17,860
really important on a 2g network the

00:14:15,579 --> 00:14:20,139
round-trip time can be two seconds or

00:14:17,860 --> 00:14:23,290
more so having a single round trip is

00:14:20,139 --> 00:14:25,029
really really important and so this is

00:14:23,290 --> 00:14:27,160
some examples of where we're using this

00:14:25,029 --> 00:14:29,470
in react native is the group's app and

00:14:27,160 --> 00:14:32,410
the ads manager app so these are two

00:14:29,470 --> 00:14:35,939
apps ads manager is one percent react

00:14:32,410 --> 00:14:39,399
native and relay groups the groups

00:14:35,939 --> 00:14:43,959
actual like feed that's relay and react

00:14:39,399 --> 00:14:46,180
native okay so that's a very very brief

00:14:43,959 --> 00:14:49,120
whirlwind tour of kind of where we are

00:14:46,180 --> 00:14:51,279
and today with relay so all the features

00:14:49,120 --> 00:14:55,449
that I described are built and exist in

00:14:51,279 --> 00:14:57,339
real I today so you know it works well

00:14:55,449 --> 00:15:00,009
for our use cases we have dozens of

00:14:57,339 --> 00:15:04,629
teams using it on public you know public

00:15:00,009 --> 00:15:06,069
products and internal tools and just to

00:15:04,629 --> 00:15:08,170
kind of go over like I think what we

00:15:06,069 --> 00:15:10,059
found really really works about relay

00:15:08,170 --> 00:15:13,660
and what where we get the value from it

00:15:10,059 --> 00:15:16,209
is the co-located query and render being

00:15:13,660 --> 00:15:18,170
able to you know reason locally the

00:15:16,209 --> 00:15:20,180
automatic caching and data fetching

00:15:18,170 --> 00:15:21,860
the automatic component datas of

00:15:20,180 --> 00:15:24,200
subscriptions so not having to worry

00:15:21,860 --> 00:15:26,750
about it like is my component going to

00:15:24,200 --> 00:15:28,730
render correctly when data changes um

00:15:26,750 --> 00:15:30,649
the declarative API aligns with the

00:15:28,730 --> 00:15:32,750
react mental model so developers kind of

00:15:30,649 --> 00:15:35,300
start and we get we still get questions

00:15:32,750 --> 00:15:36,889
today in our internal react native

00:15:35,300 --> 00:15:38,329
support group where people are saying

00:15:36,889 --> 00:15:40,160
react native isn't fetching my data

00:15:38,329 --> 00:15:41,810
correctly or something weirds going on

00:15:40,160 --> 00:15:43,579
with with data and we're and we're like

00:15:41,810 --> 00:15:45,589
actually you mean you meant relay

00:15:43,579 --> 00:15:49,639
because it really does line up really

00:15:45,589 --> 00:15:51,260
well also mutations so again optimistic

00:15:49,639 --> 00:15:53,269
mutations allow us to get these really

00:15:51,260 --> 00:15:54,529
really great responsiveness so user tap

00:15:53,269 --> 00:15:57,740
something and something they see me

00:15:54,529 --> 00:15:59,570
feedback and yet we can have a much more

00:15:57,740 --> 00:16:01,250
complicated process to go and correctly

00:15:59,570 --> 00:16:05,180
update the server and get more data back

00:16:01,250 --> 00:16:07,850
and finally global efficiency so this is

00:16:05,180 --> 00:16:09,680
you know relay as a framework allows us

00:16:07,850 --> 00:16:10,940
to make an improvement in one place and

00:16:09,680 --> 00:16:12,560
see benefits across multiple

00:16:10,940 --> 00:16:16,760
applications and so that's been really

00:16:12,560 --> 00:16:18,380
powerful so I'm probably already running

00:16:16,760 --> 00:16:21,410
out of time and I'll try to make this

00:16:18,380 --> 00:16:25,310
quick but so some of the ideas that

00:16:21,410 --> 00:16:26,990
we're focusing on for the future the

00:16:25,310 --> 00:16:28,760
primary thing is that we're really

00:16:26,990 --> 00:16:30,470
looking at as I said relay was

00:16:28,760 --> 00:16:32,209
originally built for web and as we move

00:16:30,470 --> 00:16:34,670
forward we're looking for we're looking

00:16:32,209 --> 00:16:37,640
at how to completely optimized relay

00:16:34,670 --> 00:16:41,660
toward especially low end mobile devices

00:16:37,640 --> 00:16:42,910
and so the kind of like a few the top

00:16:41,660 --> 00:16:46,480
level things we're looking at there

00:16:42,910 --> 00:16:49,880
static queries first-class pagination

00:16:46,480 --> 00:16:51,320
pagination API integrated garbage

00:16:49,880 --> 00:16:52,940
collection right that we have can

00:16:51,320 --> 00:16:54,350
possibly constrained memory and so we

00:16:52,940 --> 00:16:56,870
don't want to just arbitrarily have the

00:16:54,350 --> 00:17:00,110
cash growing more expressive mutations

00:16:56,870 --> 00:17:01,370
so previous doctor I think sashko and

00:17:00,110 --> 00:17:03,199
previous questions kind of alluded to

00:17:01,370 --> 00:17:05,959
the mutations being a little bit limited

00:17:03,199 --> 00:17:07,280
in relay right now they solve the you

00:17:05,959 --> 00:17:08,600
know the vast majority of our use cases

00:17:07,280 --> 00:17:10,790
today but we want to make that even

00:17:08,600 --> 00:17:12,140
better if we can in the future and then

00:17:10,790 --> 00:17:14,390
finally making the system a bit more

00:17:12,140 --> 00:17:17,449
modular so having you know a clear

00:17:14,390 --> 00:17:19,280
separation of concerns really is kind of

00:17:17,449 --> 00:17:21,049
already architected that way internally

00:17:19,280 --> 00:17:22,939
but it's not really exposed to the user

00:17:21,049 --> 00:17:24,740
into and we want to make it easier to

00:17:22,939 --> 00:17:28,250
kind of put the pieces together in a way

00:17:24,740 --> 00:17:30,950
that makes sense for you so let's start

00:17:28,250 --> 00:17:32,540
with static queries and kind of compare

00:17:30,950 --> 00:17:35,030
them to what we have today which

00:17:32,540 --> 00:17:37,460
dynamic queries so today at Build time

00:17:35,030 --> 00:17:41,230
we transform those real a doc UL tags

00:17:37,460 --> 00:17:44,120
into queries that I as I showed before

00:17:41,230 --> 00:17:46,430
and at runtime we have to actually

00:17:44,120 --> 00:17:47,870
execute that function and do a bunch of

00:17:46,430 --> 00:17:50,720
work to actually construct a queer

00:17:47,870 --> 00:17:52,430
representation for the entire tree we

00:17:50,720 --> 00:17:54,140
then have to take that query object and

00:17:52,430 --> 00:17:55,850
convert it into a string in order to

00:17:54,140 --> 00:17:58,580
send to the server which we you know

00:17:55,850 --> 00:18:00,050
actually upload all of those bytes and

00:17:58,580 --> 00:18:01,490
then we get the response back and

00:18:00,050 --> 00:18:05,240
process it into the store and then we

00:18:01,490 --> 00:18:07,730
can render well what can we do to make

00:18:05,240 --> 00:18:10,550
this better so here is what we're

00:18:07,730 --> 00:18:12,980
looking at in the future well

00:18:10,550 --> 00:18:16,520
transforming real aql tags as we do

00:18:12,980 --> 00:18:18,470
today but statically via some directives

00:18:16,520 --> 00:18:20,300
and extensions basically basically kind

00:18:18,470 --> 00:18:22,640
of extending the graphical syntax via

00:18:20,300 --> 00:18:24,590
directives we're able to express

00:18:22,640 --> 00:18:27,500
everything we need to about a real a

00:18:24,590 --> 00:18:29,540
query statically 100% statically which

00:18:27,500 --> 00:18:32,240
means we can construct the query at

00:18:29,540 --> 00:18:34,370
Build time print it to a string save it

00:18:32,240 --> 00:18:36,080
in a database assignment and ID and then

00:18:34,370 --> 00:18:37,910
at runtime we can just send a simple ID

00:18:36,080 --> 00:18:40,280
and variables up to the server and

00:18:37,910 --> 00:18:42,320
process the response we're also looking

00:18:40,280 --> 00:18:45,260
at a few things where we can basically

00:18:42,320 --> 00:18:47,330
compile and possibly optimize that query

00:18:45,260 --> 00:18:48,800
to make that processing step faster

00:18:47,330 --> 00:18:51,380
because we had more information

00:18:48,800 --> 00:18:53,270
available at at static time an example

00:18:51,380 --> 00:18:54,620
that would be if we if two different

00:18:53,270 --> 00:18:57,290
fragments are both fetching the ID field

00:18:54,620 --> 00:18:59,810
we don't have to process it twice we can

00:18:57,290 --> 00:19:03,370
process it once and we can somebody we

00:18:59,810 --> 00:19:06,890
can kind of compact the query statically

00:19:03,370 --> 00:19:09,500
so pagination and again this came up

00:19:06,890 --> 00:19:11,720
earlier about the kind of relays

00:19:09,500 --> 00:19:14,240
approach to pagination so today we have

00:19:11,720 --> 00:19:17,150
a built-in assumption in the store about

00:19:14,240 --> 00:19:18,770
how connections work and that has some

00:19:17,150 --> 00:19:21,080
advantages so this is the API for

00:19:18,770 --> 00:19:23,120
fetching more information a component

00:19:21,080 --> 00:19:24,440
would call set variables and say hey

00:19:23,120 --> 00:19:25,910
whatever count I had before just

00:19:24,440 --> 00:19:28,220
increase it by 10 and go get me the

00:19:25,910 --> 00:19:29,660
information because really doesn't

00:19:28,220 --> 00:19:32,360
actually know what this count means

00:19:29,660 --> 00:19:33,590
though it has to do it is very magic

00:19:32,360 --> 00:19:35,900
it's going to do that diffing we saw on

00:19:33,590 --> 00:19:39,410
like do first you know first 10 its

00:19:35,900 --> 00:19:40,370
first 20 and kind of figure out the

00:19:39,410 --> 00:19:43,550
difference between what we're fetching

00:19:40,370 --> 00:19:45,350
and what we already have but really

00:19:43,550 --> 00:19:45,639
can't do very many optimizations on this

00:19:45,350 --> 00:19:48,399
because

00:19:45,639 --> 00:19:49,749
no what the variable represents so in

00:19:48,399 --> 00:19:52,809
the future we're looking at a new top

00:19:49,749 --> 00:19:55,899
level API real a connection where we can

00:19:52,809 --> 00:19:57,519
say fetch first n fetch first 20 and

00:19:55,899 --> 00:19:59,709
basically subscribed a list of edges and

00:19:57,519 --> 00:20:01,599
this will allow us to say the store

00:19:59,709 --> 00:20:03,940
internals don't know about connections

00:20:01,599 --> 00:20:05,979
but the real a connection API does so if

00:20:03,940 --> 00:20:07,899
you want limit offset you can build real

00:20:05,979 --> 00:20:10,359
a connection that uses a limit offset

00:20:07,899 --> 00:20:12,190
approach again kind of the plug-in model

00:20:10,359 --> 00:20:14,200
of building a higher level component

00:20:12,190 --> 00:20:17,849
given these low-level pieces that we've

00:20:14,200 --> 00:20:21,190
that we've provided and finally on

00:20:17,849 --> 00:20:22,629
mobile resource management resource

00:20:21,190 --> 00:20:24,700
management and memory is really

00:20:22,629 --> 00:20:27,219
important and a lot of people have asked

00:20:24,700 --> 00:20:29,979
about garbage collection it's pretty

00:20:27,219 --> 00:20:31,450
easy to build a normalized cash it's a

00:20:29,979 --> 00:20:32,679
little bit more challenging to also get

00:20:31,450 --> 00:20:36,489
rid of the data that you don't need

00:20:32,679 --> 00:20:38,829
anymore and so an example this would be

00:20:36,489 --> 00:20:41,679
let's say we've got a feed with some a

00:20:38,829 --> 00:20:43,089
few you know some media items and on the

00:20:41,679 --> 00:20:46,029
Left we have the actual you know

00:20:43,089 --> 00:20:48,399
normalized graph let's say that we

00:20:46,029 --> 00:20:49,809
scroll away and these media items go off

00:20:48,399 --> 00:20:52,779
screen so they're not going to be

00:20:49,809 --> 00:20:55,869
rendered anymore but they were the only

00:20:52,779 --> 00:20:57,669
ones referencing this data so do we want

00:20:55,869 --> 00:20:59,259
to just hang on to it well probably not

00:20:57,669 --> 00:21:00,789
because if we did that then over time we

00:20:59,259 --> 00:21:02,950
just have lots lots of data in the store

00:21:00,789 --> 00:21:04,419
that we don't need anymore and so we've

00:21:02,950 --> 00:21:06,489
were exploring a few different

00:21:04,419 --> 00:21:08,320
architectures for how we can get garbage

00:21:06,489 --> 00:21:10,089
collection built into the store so we

00:21:08,320 --> 00:21:12,429
always have only the data that we need

00:21:10,089 --> 00:21:13,809
while also giving you some controls to

00:21:12,429 --> 00:21:15,429
say well actually I want to prefetch and

00:21:13,809 --> 00:21:17,919
stuff it's like hold on hold on to it

00:21:15,429 --> 00:21:19,149
because I'll need that in a second so

00:21:17,919 --> 00:21:22,299
we're kind of looking at we're looking

00:21:19,149 --> 00:21:24,009
at a bunch of different api's for this a

00:21:22,299 --> 00:21:27,039
few things that I didn't go into as much

00:21:24,009 --> 00:21:30,009
detail but more expressive mutations so

00:21:27,039 --> 00:21:33,700
an example kind of proposed API would

00:21:30,009 --> 00:21:35,579
basically be that you just tell us what

00:21:33,700 --> 00:21:37,869
to do to the store at a low level

00:21:35,579 --> 00:21:39,820
basically you get to just write stuff

00:21:37,869 --> 00:21:41,529
into the store and then we can provide

00:21:39,820 --> 00:21:43,749
higher level abstractions on top of that

00:21:41,529 --> 00:21:45,489
but basically if we give you write

00:21:43,749 --> 00:21:47,679
functions then you can do anything and

00:21:45,489 --> 00:21:50,049
that would be you know that would solve

00:21:47,679 --> 00:21:52,629
pretty much any use case and again as I

00:21:50,049 --> 00:21:53,769
mentioned making things more modular so

00:21:52,629 --> 00:21:56,319
these are some of the ideas that we're

00:21:53,769 --> 00:21:57,849
pursuing there's there's kind of a few

00:21:56,319 --> 00:21:58,400
more things that we'll see how they turn

00:21:57,849 --> 00:21:59,870
out

00:21:58,400 --> 00:22:01,490
but this hopefully gives you an idea of

00:21:59,870 --> 00:22:11,810
where it really is today and where we're

00:22:01,490 --> 00:22:17,780
going so thank you okay we can take one

00:22:11,810 --> 00:22:20,210
question from the audience regarding

00:22:17,780 --> 00:22:24,110
react native I know that you guys were

00:22:20,210 --> 00:22:28,150
exploring like either running relay or

00:22:24,110 --> 00:22:31,190
parts of relay in a web worker or for

00:22:28,150 --> 00:22:33,110
running maybe parts of your leg like

00:22:31,190 --> 00:22:34,460
natively is that something you guys are

00:22:33,110 --> 00:22:37,490
still exploring and is there a plan to

00:22:34,460 --> 00:22:40,670
open sourcing so the question was around

00:22:37,490 --> 00:22:42,890
react native and whether relay was

00:22:40,670 --> 00:22:44,870
exploring you know options for either

00:22:42,890 --> 00:22:48,230
running them in a web worker or running

00:22:44,870 --> 00:22:50,570
natively do yeah so we actually did a

00:22:48,230 --> 00:22:51,590
couple experiments about running ralena

00:22:50,570 --> 00:22:54,170
web worker and that was kind of the idea

00:22:51,590 --> 00:22:56,000
of can we move some of the processing

00:22:54,170 --> 00:22:58,910
off of the the main javascript thread

00:22:56,000 --> 00:23:00,260
and I think today the main the main

00:22:58,910 --> 00:23:02,870
thing that we're exploring is really

00:23:00,260 --> 00:23:06,770
actually not so much moving work off of

00:23:02,870 --> 00:23:09,410
the runtime thread but basically just

00:23:06,770 --> 00:23:11,690
don't do that work at runtime at all and

00:23:09,410 --> 00:23:14,540
just simply make move the vast majority

00:23:11,690 --> 00:23:16,070
processing to static build time and have

00:23:14,540 --> 00:23:18,770
a very very minimal step that runs at

00:23:16,070 --> 00:23:20,480
runtime so if yeah I mean basically

00:23:18,770 --> 00:23:22,730
anything that we do end up using infra

00:23:20,480 --> 00:23:24,350
duction like will obviously open source

00:23:22,730 --> 00:23:27,440
it but that's the main avenue that we're

00:23:24,350 --> 00:23:33,560
pursuing right now yeah okay let's thank

00:23:27,440 --> 00:23:35,930
Joe again sorry actually just briefly

00:23:33,560 --> 00:23:38,600
add to the question we did see that

00:23:35,930 --> 00:23:39,710
using a web worker actually incur a bit

00:23:38,600 --> 00:23:41,840
more memory because we're running

00:23:39,710 --> 00:23:45,250
basically second copy so that was kind

00:23:41,840 --> 00:23:45,250
of part of the trade-off there sorry

00:23:51,840 --> 00:23:53,900

YouTube URL: https://www.youtube.com/watch?v=7TA4T2TJQx0


