Title: Panel - Going Public: Launching and Scaling a GraphQL API for Third Party Developers
Publication date: 2017-11-09
Playlist: GraphQL Summit 2017
Description: 
	This panel at GraphQL Summit 2017 features Tomer Elmalem (Yelp), Garen Torikian (GitHub), Marc-Andre Giroux (GitHub) and MC Lee Byron (Facebook). Learn more: summit.graphql.com

In this panel moderated by GraphQL Summit MC Lee Byron, you’ll hear from the developers behind the GraphQL community’s first public APIs at GitHub, Shopify, and Yelp. They’ll cover how they tackled the challenges of building and launching external APIs with a technology that was still maturing, and the best practices they developed along the way around tooling, schema design, security considerations, documentation, support for GraphQL clients, and API maintenance.
Captions: 
	00:00:03,389 --> 00:00:08,880
so I'm super happy to be able to not

00:00:06,779 --> 00:00:12,599
just be your emcee today but also lead

00:00:08,880 --> 00:00:16,110
our panel for the day the way I want on

00:00:12,599 --> 00:00:17,310
this panel is conversational so many of

00:00:16,110 --> 00:00:18,750
you may have seen panels before you ask

00:00:17,310 --> 00:00:20,280
question everyone goes down the line and

00:00:18,750 --> 00:00:22,110
answers it it's not how we're doing

00:00:20,280 --> 00:00:23,670
things here today we're gonna have an

00:00:22,110 --> 00:00:25,380
active conversation which means I'm

00:00:23,670 --> 00:00:27,540
going to point to one of these fine

00:00:25,380 --> 00:00:30,450
gentlemen up here to kick things off but

00:00:27,540 --> 00:00:32,820
then also guys please I highly encourage

00:00:30,450 --> 00:00:35,430
you interrupt each other jump into the

00:00:32,820 --> 00:00:37,920
conversation also I think I speak for

00:00:35,430 --> 00:00:39,660
everyone here when I say that the best

00:00:37,920 --> 00:00:42,000
part about a panel is getting in here

00:00:39,660 --> 00:00:44,220
story so if something jogs your mind

00:00:42,000 --> 00:00:46,230
about like a cool story that you have

00:00:44,220 --> 00:00:48,210
that that's like fits the theme jump in

00:00:46,230 --> 00:00:51,450
with that with that let's get started

00:00:48,210 --> 00:00:54,270
some introductions so Tomer comers were

00:00:51,450 --> 00:00:57,239
working at Yelp since 2014 and is the

00:00:54,270 --> 00:00:58,800
technical lead for yelps public api's he

00:00:57,239 --> 00:01:00,210
also leads yelps developer blog so if

00:00:58,800 --> 00:01:01,440
you've read any great content he's

00:01:00,210 --> 00:01:03,329
responsible for helping put that

00:01:01,440 --> 00:01:07,530
together and led the development of

00:01:03,329 --> 00:01:09,420
yelps public graphical API Garen is has

00:01:07,530 --> 00:01:11,940
been a technical writer and platform

00:01:09,420 --> 00:01:13,140
engineer at github since 2013 I'm gonna

00:01:11,940 --> 00:01:15,390
bug him about the technical writing the

00:01:13,140 --> 00:01:18,060
parts that's awesome and it's also part

00:01:15,390 --> 00:01:21,119
of the team that led graph QL into

00:01:18,060 --> 00:01:22,619
github and then finally mark Andre spent

00:01:21,119 --> 00:01:24,900
the last two years as an engineer at

00:01:22,619 --> 00:01:27,000
Shopify where he was an early champion

00:01:24,900 --> 00:01:28,440
for graph QL ever since that I think I

00:01:27,000 --> 00:01:30,570
met you at the very first time we talked

00:01:28,440 --> 00:01:33,630
about it now that was crazy and really

00:01:30,570 --> 00:01:36,350
helped build spot of qualified Shopify's

00:01:33,630 --> 00:01:39,600
sorry Shopify the public graphical API

00:01:36,350 --> 00:01:41,850
but just recently he also joined github

00:01:39,600 --> 00:01:45,600
so with that I want to start off with

00:01:41,850 --> 00:01:48,150
our first point of conversation so

00:01:45,600 --> 00:01:50,729
Facebook Graph kills our internal public

00:01:48,150 --> 00:01:52,619
API and when we talk about it to the

00:01:50,729 --> 00:01:53,820
community we usually pitch it as that

00:01:52,619 --> 00:01:57,180
and most of the talks we've heard about

00:01:53,820 --> 00:02:01,229
today have been about building internal

00:01:57,180 --> 00:02:02,970
products on on graph QL but you know

00:02:01,229 --> 00:02:05,490
this panel is all about public API s

00:02:02,970 --> 00:02:07,170
which i think is a new area for all of

00:02:05,490 --> 00:02:09,810
us so that's what I want to talk about

00:02:07,170 --> 00:02:11,280
today but first I want to hear why did

00:02:09,810 --> 00:02:13,290
you think that graph kill is the right

00:02:11,280 --> 00:02:14,840
fit for a public API

00:02:13,290 --> 00:02:17,700
Geron I'm gonna pick on you first

00:02:14,840 --> 00:02:20,220
because github kind of famously

00:02:17,700 --> 00:02:23,430
popularized rest api's like ten years

00:02:20,220 --> 00:02:26,099
ago so you know how did graph QL end up

00:02:23,430 --> 00:02:29,970
becoming part of the story yeah

00:02:26,099 --> 00:02:34,019
it's it's kind of interesting we

00:02:29,970 --> 00:02:35,250
basically took a look at all the data

00:02:34,019 --> 00:02:38,190
all the requests that are going into

00:02:35,250 --> 00:02:40,590
github like 60% of all requests for

00:02:38,190 --> 00:02:42,450
github data comes through the API and a

00:02:40,590 --> 00:02:46,230
vast majority of those requests are read

00:02:42,450 --> 00:02:47,870
request so just from looking simply at

00:02:46,230 --> 00:02:50,129
the numbers and not even thinking about

00:02:47,870 --> 00:02:51,359
the talk that Anne gave not even think

00:02:50,129 --> 00:02:52,980
about clients or anything else just

00:02:51,359 --> 00:02:55,200
think about from an operational

00:02:52,980 --> 00:02:56,400
perspective how we could reduce that

00:02:55,200 --> 00:02:59,790
load or how we could make how could

00:02:56,400 --> 00:03:00,959
serve the data better we didn't start

00:02:59,790 --> 00:03:02,400
off with graph kill we looked at some

00:03:00,959 --> 00:03:04,260
other choices there's like Falkor or no

00:03:02,400 --> 00:03:06,420
data and a whole bunch of other kind of

00:03:04,260 --> 00:03:09,150
things but we kept circle around graph

00:03:06,420 --> 00:03:11,819
QL because the team that's responsible

00:03:09,150 --> 00:03:14,849
for application features we're also

00:03:11,819 --> 00:03:18,000
experiencing kind of their own problems

00:03:14,849 --> 00:03:19,530
with with fetching data and whatnot and

00:03:18,000 --> 00:03:23,220
they wanted to go towards like a more

00:03:19,530 --> 00:03:26,639
kind of react sort of serving views

00:03:23,220 --> 00:03:29,549
model and yeah just again from hearing

00:03:26,639 --> 00:03:32,160
from integrators I think a classic one

00:03:29,549 --> 00:03:33,419
was from the focus on Heroku who if you

00:03:32,160 --> 00:03:35,099
want to get a list of deployments you

00:03:33,419 --> 00:03:36,389
would have to get a list of your

00:03:35,099 --> 00:03:37,590
repositories and then he would have to

00:03:36,389 --> 00:03:38,400
get a list of your deployments and then

00:03:37,590 --> 00:03:40,049
you would have to get a list of your

00:03:38,400 --> 00:03:42,569
deployment statuses which is like three

00:03:40,049 --> 00:03:44,459
separate REST API calls which we can

00:03:42,569 --> 00:03:46,829
just reduce down to one kind of

00:03:44,459 --> 00:03:47,940
roundtrip so yeah if just kind of

00:03:46,829 --> 00:03:51,060
looking at our own numbers looking at

00:03:47,940 --> 00:03:52,709
what people were telling us and yeah we

00:03:51,060 --> 00:03:54,569
built out kind of a smaller feature and

00:03:52,709 --> 00:03:55,949
and it started to work out well so we

00:03:54,569 --> 00:03:59,010
decided to go forward with it this is a

00:03:55,949 --> 00:04:00,299
similar story so Yelp for example is a

00:03:59,010 --> 00:04:01,709
similar story you're seeing people hit

00:04:00,299 --> 00:04:04,680
the API a lot or do you have different

00:04:01,709 --> 00:04:06,239
reasons for looking at graphical we saw

00:04:04,680 --> 00:04:07,980
people hit the API a lot one of the

00:04:06,239 --> 00:04:11,280
reasons I really looked into graphical

00:04:07,980 --> 00:04:14,760
was we released our new infusion API in

00:04:11,280 --> 00:04:16,019
September of 2016 and we built this like

00:04:14,760 --> 00:04:17,099
really nice craft interface we were

00:04:16,019 --> 00:04:18,930
pretty excited about the design behind

00:04:17,099 --> 00:04:20,459
it and almost immediately people like

00:04:18,930 --> 00:04:22,109
well can we get this data and this one

00:04:20,459 --> 00:04:24,630
endpoint and it made me kind of sad

00:04:22,109 --> 00:04:26,200
because I was like man but this looks so

00:04:24,630 --> 00:04:28,210
nice right now

00:04:26,200 --> 00:04:29,980
so graph kill obviously gives you the

00:04:28,210 --> 00:04:32,170
flexibility to do what you want and that

00:04:29,980 --> 00:04:33,520
became really appealing it's impossible

00:04:32,170 --> 00:04:35,740
to guess how people are going to want to

00:04:33,520 --> 00:04:37,480
use your API what data they want inside

00:04:35,740 --> 00:04:40,300
of it so I figured I can leave it into

00:04:37,480 --> 00:04:42,820
the hands of developers awesome

00:04:40,300 --> 00:04:45,070
once you kind of decided that graph kill

00:04:42,820 --> 00:04:46,360
was the right choice how do you sell

00:04:45,070 --> 00:04:48,190
that internally we heard a little bit

00:04:46,360 --> 00:04:50,830
about how to do that for an internal

00:04:48,190 --> 00:04:53,440
product but a public API is like a whole

00:04:50,830 --> 00:04:55,570
other story mark Andre can you tell us a

00:04:53,440 --> 00:04:58,270
little bit about what that was like yeah

00:04:55,570 --> 00:05:00,760
I guess like the really fun thing about

00:04:58,270 --> 00:05:03,460
graph QL is like it lets you really

00:05:00,760 --> 00:05:05,020
define like what your domain is like as

00:05:03,460 --> 00:05:06,790
an interface it doesn't matter like

00:05:05,020 --> 00:05:08,800
we're often to ask questions like Oh

00:05:06,790 --> 00:05:11,169
which databases should you use with

00:05:08,800 --> 00:05:13,360
graph you like that but really like any

00:05:11,169 --> 00:05:15,190
infrastructure you currently have you

00:05:13,360 --> 00:05:18,370
get the chance to like really define

00:05:15,190 --> 00:05:22,419
what the real interface public or

00:05:18,370 --> 00:05:26,020
internal is and really like the fun goal

00:05:22,419 --> 00:05:28,030
for me is can we make the both both of

00:05:26,020 --> 00:05:31,240
them internal and public kind of similar

00:05:28,030 --> 00:05:34,090
and just expose the domain of like

00:05:31,240 --> 00:05:36,880
either github or Yale for Shopify both

00:05:34,090 --> 00:05:39,100
internally and externally and externally

00:05:36,880 --> 00:05:40,570
I guess it's kind of a gamble like

00:05:39,100 --> 00:05:42,490
people who've used graph feel they love

00:05:40,570 --> 00:05:44,080
it they want to use it when it's

00:05:42,490 --> 00:05:46,900
integrators that are currently using

00:05:44,080 --> 00:05:49,090
rest or something else you really got to

00:05:46,900 --> 00:05:49,890
trust that when you try it they're gonna

00:05:49,090 --> 00:05:52,350
love it

00:05:49,890 --> 00:05:55,600
but yeah to answer your question

00:05:52,350 --> 00:05:57,490
internally I think it's usually it

00:05:55,600 --> 00:06:00,100
depends where a decision comes from I

00:05:57,490 --> 00:06:03,250
know back my times at Shopify

00:06:00,100 --> 00:06:04,930
our CEO was super excited by a graph

00:06:03,250 --> 00:06:05,410
tool that helps a lot so that was super

00:06:04,930 --> 00:06:07,720
easy

00:06:05,410 --> 00:06:09,970
I think ghetto was maybe slightly

00:06:07,720 --> 00:06:13,840
different where we're really gonna have

00:06:09,970 --> 00:06:16,150
to build something so cool that devs

00:06:13,840 --> 00:06:19,210
want to use it and increase use that

00:06:16,150 --> 00:06:21,490
usage this way is that the case for the

00:06:19,210 --> 00:06:23,940
rest of you having like support from on

00:06:21,490 --> 00:06:27,100
high or you're shaking your head

00:06:23,940 --> 00:06:27,740
tomotommy how did you go from like craft

00:06:27,100 --> 00:06:29,810
kills an idea

00:06:27,740 --> 00:06:31,940
to actually building this thing out so I

00:06:29,810 --> 00:06:34,310
talked to our VP at the time and he

00:06:31,940 --> 00:06:35,720
seemed interested but not super sold on

00:06:34,310 --> 00:06:36,830
it and I talked to my PA my time was

00:06:35,720 --> 00:06:39,139
kind of the same thing same thing with

00:06:36,830 --> 00:06:40,550
my manager and at some point I was like

00:06:39,139 --> 00:06:42,259
this is really cool I really just want

00:06:40,550 --> 00:06:44,569
to play with it and I kind of built it

00:06:42,259 --> 00:06:45,860
out myself and at some point I was like

00:06:44,569 --> 00:06:47,840
hey I'm getting kind of close to being

00:06:45,860 --> 00:06:53,180
done can we launch this and like a few

00:06:47,840 --> 00:06:53,509
weeks later we just put it out oh it

00:06:53,180 --> 00:06:54,860
worked

00:06:53,509 --> 00:06:58,069
don't know if I'd recommend that for

00:06:54,860 --> 00:06:59,990
everyone but how does that work out you

00:06:58,069 --> 00:07:02,599
just shipped it like people are gonna

00:06:59,990 --> 00:07:04,400
start using it I mean all you have a

00:07:02,599 --> 00:07:06,110
support plan in place how do you get the

00:07:04,400 --> 00:07:08,090
rest of your team on board that's thing

00:07:06,110 --> 00:07:09,889
that you ship by yourself the well I got

00:07:08,090 --> 00:07:11,030
by an before I made a public and I was

00:07:09,889 --> 00:07:12,289
like kind of a critical thing I didn't

00:07:11,030 --> 00:07:13,340
want to just make it live and then have

00:07:12,289 --> 00:07:15,289
it sit there and be like well I don't

00:07:13,340 --> 00:07:17,900
know who's gonna work on this now so I

00:07:15,289 --> 00:07:19,159
started doing demos internally to a lot

00:07:17,900 --> 00:07:20,120
of the engineers to some of the managers

00:07:19,159 --> 00:07:22,580
and they were like this he was pretty

00:07:20,120 --> 00:07:23,990
cool we can put this out as a beta see

00:07:22,580 --> 00:07:25,940
what the feedback is let people play

00:07:23,990 --> 00:07:27,349
with it and so far it's been pretty good

00:07:25,940 --> 00:07:29,360
awesome

00:07:27,349 --> 00:07:31,520
and then as you started to roll these

00:07:29,360 --> 00:07:33,560
public kpi's out what kind of hurdles

00:07:31,520 --> 00:07:37,699
did you hit both technological and

00:07:33,560 --> 00:07:39,770
organizational Garan any thoughts yeah

00:07:37,699 --> 00:07:43,159
it was just telling someone who came by

00:07:39,770 --> 00:07:44,690
the booth earlier that we we hit hurdles

00:07:43,159 --> 00:07:46,190
that we didn't even think of and a lot

00:07:44,690 --> 00:07:48,050
of it was just basically like quickly

00:07:46,190 --> 00:07:51,800
playing catch-up to kind of fix that

00:07:48,050 --> 00:07:53,210
stuff so anything from like properly

00:07:51,800 --> 00:07:54,770
parsing the JSON that people are sending

00:07:53,210 --> 00:07:56,030
us because we had been doing things in

00:07:54,770 --> 00:08:00,080
graphical and hadn't even considered

00:07:56,030 --> 00:08:01,639
like regular curl calls to I don't know

00:08:00,080 --> 00:08:03,349
all sorts of like data integrity issues

00:08:01,639 --> 00:08:09,020
that had been in the app for eight or

00:08:03,349 --> 00:08:11,719
nine years I guess the yeah yeah leave

00:08:09,020 --> 00:08:13,460
it at that much like rambling there's

00:08:11,719 --> 00:08:14,960
lots of you launch it and use fine

00:08:13,460 --> 00:08:15,440
little thing basically yeah something

00:08:14,960 --> 00:08:16,699
along the way

00:08:15,440 --> 00:08:18,919
we were pretty convinced that it was the

00:08:16,699 --> 00:08:20,030
right direction to go yeah it was kind

00:08:18,919 --> 00:08:21,560
of interesting because there wasn't a

00:08:20,030 --> 00:08:23,240
lot of it specifically even for like a

00:08:21,560 --> 00:08:24,830
ruby environment which which github runs

00:08:23,240 --> 00:08:28,190
there wasn't a lot of like gotchas or

00:08:24,830 --> 00:08:30,409
notes or things to look out for which we

00:08:28,190 --> 00:08:32,149
had hit kind of we did like an alpha

00:08:30,409 --> 00:08:35,240
phase for a few months which definitely

00:08:32,149 --> 00:08:37,050
helped shake out a lot of the bugs but

00:08:35,240 --> 00:08:40,589
even a lot of questions on

00:08:37,050 --> 00:08:42,510
how should we design our views or how

00:08:40,589 --> 00:08:44,250
should we shall we always respond with a

00:08:42,510 --> 00:08:45,779
200 if there's an error message like

00:08:44,250 --> 00:08:47,820
stuff like that

00:08:45,779 --> 00:08:50,459
what about organizationally was there

00:08:47,820 --> 00:08:52,050
any kind of hurdles organizationally to

00:08:50,459 --> 00:08:53,399
making this work so you're you're

00:08:52,050 --> 00:08:55,260
shaking here yeah

00:08:53,399 --> 00:08:58,200
something interesting more on the people

00:08:55,260 --> 00:09:00,959
side is depending on the size I guess of

00:08:58,200 --> 00:09:03,570
your team who's gonna work on

00:09:00,959 --> 00:09:05,070
implementing the schema because often

00:09:03,570 --> 00:09:06,779
we're gonna have a graphical team who's

00:09:05,070 --> 00:09:08,040
gonna like building frost rupture I got

00:09:06,779 --> 00:09:10,730
after all is gonna be super

00:09:08,040 --> 00:09:13,200
knowledgeable of a graph cool but really

00:09:10,730 --> 00:09:15,660
when it's time to design a schema I

00:09:13,200 --> 00:09:19,140
think the product teams and the teams

00:09:15,660 --> 00:09:20,970
that are that really know the parts of

00:09:19,140 --> 00:09:23,220
the application are really the best to

00:09:20,970 --> 00:09:26,160
do that so I think a lot of it is

00:09:23,220 --> 00:09:28,230
teaching product teams and providing

00:09:26,160 --> 00:09:29,970
tools to product teams to like build a

00:09:28,230 --> 00:09:31,170
great how do you do that like what do

00:09:29,970 --> 00:09:32,720
you what are you teaching them what's

00:09:31,170 --> 00:09:35,399
that actually look like so I think

00:09:32,720 --> 00:09:35,700
internal talks you've talked about that

00:09:35,399 --> 00:09:38,370
a bit

00:09:35,700 --> 00:09:41,970
just do like spread the word the word so

00:09:38,370 --> 00:09:43,829
people get interested both github and

00:09:41,970 --> 00:09:47,760
back when I was chief I have like great

00:09:43,829 --> 00:09:50,279
Docs for developers because when you

00:09:47,760 --> 00:09:52,410
start building graphical API and your

00:09:50,279 --> 00:09:53,910
whole team wants to build it they're

00:09:52,410 --> 00:09:55,500
gonna have questions and if you're like

00:09:53,910 --> 00:09:58,200
three or four people on a graphical team

00:09:55,500 --> 00:09:59,820
you're gonna get things non-stop so if

00:09:58,200 --> 00:10:02,370
that's what you want to do I'd say like

00:09:59,820 --> 00:10:05,750
prepare amazing Docs so you can just

00:10:02,370 --> 00:10:08,339
link it and yeah that really helped so

00:10:05,750 --> 00:10:10,350
in practice how much do you end up being

00:10:08,339 --> 00:10:11,610
involved with schema design did you get

00:10:10,350 --> 00:10:15,029
to fully push it out to the product

00:10:11,610 --> 00:10:16,500
teams or did you end up still kind of

00:10:15,029 --> 00:10:20,730
hand-holding a lot of it like what was

00:10:16,500 --> 00:10:23,699
the balance like so the goal was to have

00:10:20,730 --> 00:10:25,290
everybody be responsible or else gave us

00:10:23,699 --> 00:10:28,790
but of course at first there was a lot

00:10:25,290 --> 00:10:32,490
of schema reviewing we do a lot of that

00:10:28,790 --> 00:10:34,829
and providing tools like just like this

00:10:32,490 --> 00:10:37,500
schema comparator just like that detects

00:10:34,829 --> 00:10:39,660
like breaking changes to public API so

00:10:37,500 --> 00:10:42,360
maybe we can talk about that a bit later

00:10:39,660 --> 00:10:45,709
but just like great tools and a lot of

00:10:42,360 --> 00:10:47,420
reviewing at first and eventually maybe

00:10:45,709 --> 00:10:48,710
migrated towards

00:10:47,420 --> 00:10:51,500
really similar to what we did at

00:10:48,710 --> 00:10:54,170
Facebook our team basically held schema

00:10:51,500 --> 00:10:55,960
review I think twice a week just anyone

00:10:54,170 --> 00:10:58,430
could come in and just bug us for hours

00:10:55,960 --> 00:11:01,760
to talk through things that worked well

00:10:58,430 --> 00:11:03,200
we also used that time to find sort of

00:11:01,760 --> 00:11:04,970
overlapping pieces that would be the

00:11:03,200 --> 00:11:06,620
same across many different product areas

00:11:04,970 --> 00:11:08,150
so we had this one concept that we

00:11:06,620 --> 00:11:10,460
called text with entities that was

00:11:08,150 --> 00:11:12,350
basically the data version of HTML with

00:11:10,460 --> 00:11:14,060
link tags in it that we wanted to make

00:11:12,350 --> 00:11:15,590
sure we got right so we designed that

00:11:14,060 --> 00:11:17,600
once and then when people came up like

00:11:15,590 --> 00:11:19,610
so how do you HTML on this thing so yeah

00:11:17,600 --> 00:11:21,290
we've already helped another designed

00:11:19,610 --> 00:11:23,000
this you should just reuse it did you

00:11:21,290 --> 00:11:25,010
find similar things like were there

00:11:23,000 --> 00:11:27,560
conventions or or anything like that

00:11:25,010 --> 00:11:29,390
that you get to recycle yeah for for us

00:11:27,560 --> 00:11:30,980
it was a lot of like linting like once

00:11:29,390 --> 00:11:32,240
we solved some one schema problems all

00:11:30,980 --> 00:11:35,840
right let's add a linter for it so we

00:11:32,240 --> 00:11:37,250
never have to again and tests for naming

00:11:35,840 --> 00:11:39,170
conventions and stuff like that like

00:11:37,250 --> 00:11:41,570
that nitty-gritty that we didn't

00:11:39,170 --> 00:11:44,690
anticipate sort of like oh you shouldn't

00:11:41,570 --> 00:11:47,210
call something like foo interface just

00:11:44,690 --> 00:11:50,030
protect against stuff like that yeah

00:11:47,210 --> 00:11:52,250
didn't think Lynn things is great and I

00:11:50,030 --> 00:11:54,230
think above that we can even have just

00:11:52,250 --> 00:11:57,230
like conventions for stuff like should

00:11:54,230 --> 00:11:59,240
you create a mutation called like post

00:11:57,230 --> 00:12:01,460
and if you want to like multiple posts

00:11:59,240 --> 00:12:02,810
you will call like post many times or

00:12:01,460 --> 00:12:05,420
should you create one that's called like

00:12:02,810 --> 00:12:07,910
posts instead that takes like an array

00:12:05,420 --> 00:12:10,520
of IDs maybe and just conventions like

00:12:07,910 --> 00:12:13,940
that so your schemas like consistent

00:12:10,520 --> 00:12:16,820
everywhere and these are kind of more

00:12:13,940 --> 00:12:18,890
hard to like harder to really check with

00:12:16,820 --> 00:12:22,130
tools yeah so that's more like of a

00:12:18,890 --> 00:12:24,380
Doc's thing and education I guess yeah

00:12:22,130 --> 00:12:25,850
that's a hard thing to get right well

00:12:24,380 --> 00:12:27,740
what about the poke reaction I mean the

00:12:25,850 --> 00:12:29,600
thing that makes your projects different

00:12:27,740 --> 00:12:32,210
from everything else is that the whole

00:12:29,600 --> 00:12:34,070
general public gets to use these and you

00:12:32,210 --> 00:12:35,840
also launched relatively early in graph

00:12:34,070 --> 00:12:38,360
kills lifecycle so what was the process

00:12:35,840 --> 00:12:40,490
like of exposing this out to a public

00:12:38,360 --> 00:12:42,290
that may or may not have actually heard

00:12:40,490 --> 00:12:45,650
of graph kill before tell Murray do you

00:12:42,290 --> 00:12:48,020
want to sure so when we made a public

00:12:45,650 --> 00:12:49,430
people seemed very excited I think it's

00:12:48,020 --> 00:12:50,990
something about Yelp Stata makes it

00:12:49,430 --> 00:12:52,820
pretty easy there go away - it's very

00:12:50,990 --> 00:12:55,220
easy for you to say well you can set up

00:12:52,820 --> 00:12:58,360
a query end us find this local bar or

00:12:55,220 --> 00:12:59,980
the stress treant on all my blog posts

00:12:58,360 --> 00:13:02,470
an example documentation I use this one

00:12:59,980 --> 00:13:03,760
restaurant called garaje which is just a

00:13:02,470 --> 00:13:05,470
couple of blocks down the street and I

00:13:03,760 --> 00:13:07,990
think half the feedback we got was how

00:13:05,470 --> 00:13:11,110
great the restaurant was moreso excited

00:13:07,990 --> 00:13:12,850
about people worried about the API but I

00:13:11,110 --> 00:13:14,709
think the fact that people were so

00:13:12,850 --> 00:13:16,870
easily able to relate to the data you

00:13:14,709 --> 00:13:19,390
get out of it made people pretty excited

00:13:16,870 --> 00:13:21,339
about it that's awesome how about you

00:13:19,390 --> 00:13:23,260
guys any sense of people trying to like

00:13:21,339 --> 00:13:24,760
learn this new thing or what do you do

00:13:23,260 --> 00:13:28,120
to help people onto not just new if you

00:13:24,760 --> 00:13:30,399
have any new technology for the API yeah

00:13:28,120 --> 00:13:31,899
I think for us we did github did

00:13:30,399 --> 00:13:32,890
something that we hadn't done before it

00:13:31,899 --> 00:13:34,750
should be set up basically at this

00:13:32,890 --> 00:13:37,630
course forum the same time that we

00:13:34,750 --> 00:13:39,250
launched the graph QL API so we do kind

00:13:37,630 --> 00:13:42,130
of like a weekly the team does like a

00:13:39,250 --> 00:13:43,510
weekly first responder rotation so every

00:13:42,130 --> 00:13:45,160
week a different member of the team goes

00:13:43,510 --> 00:13:46,899
and looks at the forum posts collects

00:13:45,160 --> 00:13:49,149
feedback kind of answers people's

00:13:46,899 --> 00:13:50,560
questions and we've just now after a

00:13:49,149 --> 00:13:51,790
little over a year of launching that

00:13:50,560 --> 00:13:54,040
have gotten to the point where people

00:13:51,790 --> 00:13:57,839
are answering questions for us which is

00:13:54,040 --> 00:14:00,399
the dream so that was definitely useful

00:13:57,839 --> 00:14:03,310
and I think generally reception I think

00:14:00,399 --> 00:14:04,510
we worried that people were up I'm

00:14:03,310 --> 00:14:05,649
personally a big fan of just like

00:14:04,510 --> 00:14:07,720
burning things down and starting over

00:14:05,649 --> 00:14:09,459
when things are better so I think

00:14:07,720 --> 00:14:11,860
generally that the the worry was that

00:14:09,459 --> 00:14:13,750
people were gonna say you know I have to

00:14:11,860 --> 00:14:15,100
reboot I have to learn this whole new

00:14:13,750 --> 00:14:17,829
thing I have to write these new clients

00:14:15,100 --> 00:14:19,209
I have to do like all this parsing of

00:14:17,829 --> 00:14:20,829
like responses and stuff that I don't

00:14:19,209 --> 00:14:23,949
know anything about but on the contrary

00:14:20,829 --> 00:14:25,630
actually people from individuals to like

00:14:23,949 --> 00:14:28,480
companies building on top of the API

00:14:25,630 --> 00:14:30,880
have actually latched on to it pretty

00:14:28,480 --> 00:14:32,500
pretty well pretty helpfully that's cool

00:14:30,880 --> 00:14:35,350
and we're pretty lucky to have like

00:14:32,500 --> 00:14:38,440
these conferences like a polo being

00:14:35,350 --> 00:14:40,180
super involved Facebook doing stuff for

00:14:38,440 --> 00:14:43,660
the community too so I don't feel like

00:14:40,180 --> 00:14:46,120
that way I'll conference yeah yeah that

00:14:43,660 --> 00:14:48,040
helps a lot you mentioned the discourse

00:14:46,120 --> 00:14:49,779
or people asking questions were there

00:14:48,040 --> 00:14:51,010
any kind of common questions that came

00:14:49,779 --> 00:14:53,140
up all the time they just found yourself

00:14:51,010 --> 00:14:54,579
answering over and over again yeah the

00:14:53,140 --> 00:14:56,800
most common question is when is this

00:14:54,579 --> 00:14:58,800
gonna be added so like we don't know we

00:14:56,800 --> 00:15:01,510
want to be able to do this in graph QL

00:14:58,800 --> 00:15:03,250
but no in terms of like authorization or

00:15:01,510 --> 00:15:06,579
any any of that stuff like no people

00:15:03,250 --> 00:15:08,010
generally they generally picked up on it

00:15:06,579 --> 00:15:09,690
definitely helps that

00:15:08,010 --> 00:15:11,700
you know the query language obviously

00:15:09,690 --> 00:15:13,770
doesn't matter how we implement it it's

00:15:11,700 --> 00:15:15,480
the string that they need to pass is

00:15:13,770 --> 00:15:17,790
like the same string they need to pass

00:15:15,480 --> 00:15:20,100
you know more or less to every other API

00:15:17,790 --> 00:15:22,200
so yeah I can't think of anything that

00:15:20,100 --> 00:15:24,480
was just like repetitive or difficult it

00:15:22,200 --> 00:15:26,520
would be like edges and nodes yeah edges

00:15:24,480 --> 00:15:27,620
a nose that's true pagination yes yeah

00:15:26,520 --> 00:15:31,650
that's a good point

00:15:27,620 --> 00:15:33,960
education is hard yeah yeah well so all

00:15:31,650 --> 00:15:36,270
three of these projects were not the

00:15:33,960 --> 00:15:38,760
first api's at these companies there

00:15:36,270 --> 00:15:40,770
were arrests api's before so is the plan

00:15:38,760 --> 00:15:43,650
for these graphical public API is to

00:15:40,770 --> 00:15:44,790
completely replace the REST API or do

00:15:43,650 --> 00:15:47,130
you intend then kind of supporting both

00:15:44,790 --> 00:15:49,980
at the same time what's that story look

00:15:47,130 --> 00:15:52,500
like Tomer for now we're planning to

00:15:49,980 --> 00:15:54,180
support both at the same time we have

00:15:52,500 --> 00:15:55,410
some folks who gave us feedback that

00:15:54,180 --> 00:15:56,580
they didn't want to use graph qo we

00:15:55,410 --> 00:15:58,290
didn't want to force everyone onto it

00:15:56,580 --> 00:16:02,000
and kind of vice-versa some people

00:15:58,290 --> 00:16:03,960
really prefer using graph QL REST API so

00:16:02,000 --> 00:16:06,870
we're planning on supporting on both for

00:16:03,960 --> 00:16:09,450
the time being oh yeah what about you

00:16:06,870 --> 00:16:11,280
folks for us we're already backing rest

00:16:09,450 --> 00:16:13,050
endpoints with graph QL so new features

00:16:11,280 --> 00:16:14,490
as of like a year ago even though we

00:16:13,050 --> 00:16:16,320
have a rest endpoint they're actually

00:16:14,490 --> 00:16:18,240
backed by graph QL behind the scenes so

00:16:16,320 --> 00:16:19,740
yeah we're pretty we're pretty eager

00:16:18,240 --> 00:16:22,770
interesting to know tell us more about

00:16:19,740 --> 00:16:24,120
that so how do you make a rest endpoint

00:16:22,770 --> 00:16:25,950
cuz I think we've heard a lot about the

00:16:24,120 --> 00:16:27,210
other way around like wrapping your rest

00:16:25,950 --> 00:16:28,650
endpoint with graph gala but how do you

00:16:27,210 --> 00:16:33,150
wrap your graph Gailen point with rest

00:16:28,650 --> 00:16:34,290
very very carefully um so basically if

00:16:33,150 --> 00:16:35,670
you imagine like an endpoint right

00:16:34,290 --> 00:16:37,140
you've got your words and then you've

00:16:35,670 --> 00:16:38,730
really got the ID parameters in your

00:16:37,140 --> 00:16:41,670
query so we just take that information

00:16:38,730 --> 00:16:43,080
and we store kind of what it's not

00:16:41,670 --> 00:16:45,570
really like a persistent query or

00:16:43,080 --> 00:16:47,250
anything but it's just a regular string

00:16:45,570 --> 00:16:48,750
of the query and then we plug in the

00:16:47,250 --> 00:16:51,540
variables that people are passing into

00:16:48,750 --> 00:16:53,430
us through rests and then massaging that

00:16:51,540 --> 00:16:57,120
and delivering that back out as a JSON

00:16:53,430 --> 00:17:00,300
blob so whereas previously we would have

00:16:57,120 --> 00:17:01,800
done maybe a lookup of a repository than

00:17:00,300 --> 00:17:03,540
a lookup of a user than a lookup of

00:17:01,800 --> 00:17:05,220
whatever whatever we're taking those

00:17:03,540 --> 00:17:07,440
variables plugging them right into a

00:17:05,220 --> 00:17:09,180
graph QL query running that through the

00:17:07,440 --> 00:17:10,890
same like graphic QL backend and then

00:17:09,180 --> 00:17:12,570
just getting that data back and instead

00:17:10,890 --> 00:17:15,540
of data errors just kind of figuring out

00:17:12,570 --> 00:17:17,910
how to massage that back into like the

00:17:15,540 --> 00:17:19,589
rest of the rest format so yeah we have

00:17:17,910 --> 00:17:20,190
like kind of like a little serializer

00:17:19,589 --> 00:17:21,750
sort

00:17:20,190 --> 00:17:23,460
in thing that's Pelosi you know you're

00:17:21,750 --> 00:17:24,960
not worrying about like two similar

00:17:23,460 --> 00:17:27,090
implementations and said you just have

00:17:24,960 --> 00:17:28,650
this translation layer yeah that's all

00:17:27,090 --> 00:17:30,900
thing but Omer you have like a totally

00:17:28,650 --> 00:17:32,790
different strategy for that right so we

00:17:30,900 --> 00:17:34,200
have the rest of views that do make

00:17:32,790 --> 00:17:35,430
normal internal API calls but I'm kind

00:17:34,200 --> 00:17:37,080
of glad they said that because two days

00:17:35,430 --> 00:17:38,610
ago I started doing this too so we have

00:17:37,080 --> 00:17:43,410
grassed endpoints powered by graph QL

00:17:38,610 --> 00:17:46,650
hello okay yeah we wanted to just limit

00:17:43,410 --> 00:17:48,120
coda codification and data loggers in

00:17:46,650 --> 00:17:49,830
graph QL and there's always inquiries in

00:17:48,120 --> 00:17:52,380
graph QL are all pretty identical to the

00:17:49,830 --> 00:17:54,120
guest data so having the gust endpoints

00:17:52,380 --> 00:17:55,980
just be hard-coded graph kill queries is

00:17:54,120 --> 00:17:56,580
pretty straightforward for us so that

00:17:55,980 --> 00:17:57,690
make sense

00:17:56,580 --> 00:18:00,450
migration that we'd like to started

00:17:57,690 --> 00:18:02,540
looking at so is the long term plan to

00:18:00,450 --> 00:18:05,480
essentially keep rest around via these

00:18:02,540 --> 00:18:07,710
adapters or you shaking your head

00:18:05,480 --> 00:18:10,080
they're gonna go away at some point one

00:18:07,710 --> 00:18:12,210
point when when people when we when we

00:18:10,080 --> 00:18:13,200
have coverage in graph QL probably which

00:18:12,210 --> 00:18:14,610
is not gonna be for another few years

00:18:13,200 --> 00:18:17,010
and then you have to tell people we're

00:18:14,610 --> 00:18:18,180
deprecating the rest api and then we're

00:18:17,010 --> 00:18:20,250
gonna tell people we're not doing bug

00:18:18,180 --> 00:18:21,720
fixes for the api so that that alone is

00:18:20,250 --> 00:18:23,730
gonna be three years but I think

00:18:21,720 --> 00:18:25,170
everyone internally and the feedback

00:18:23,730 --> 00:18:27,150
we've gotten externally is that graph QL

00:18:25,170 --> 00:18:28,650
is actually makes more sense for

00:18:27,150 --> 00:18:30,390
everybody involved so it's interesting

00:18:28,650 --> 00:18:33,000
you found a way to sort of reduce

00:18:30,390 --> 00:18:35,430
internal technical debt while

00:18:33,000 --> 00:18:37,020
maintaining that endpoint for as long as

00:18:35,430 --> 00:18:38,790
you've kind of promised to keep this

00:18:37,020 --> 00:18:40,260
thing up we got schema coverage we get

00:18:38,790 --> 00:18:41,910
features built in graph QL and we get

00:18:40,260 --> 00:18:45,720
clients that don't want to move to graph

00:18:41,910 --> 00:18:47,580
QL yet just using the REST API so I was

00:18:45,720 --> 00:18:49,740
really surprised when I came to get up

00:18:47,580 --> 00:18:51,570
and saw how like so much stuff

00:18:49,740 --> 00:18:54,450
internally was powered by graph ul and

00:18:51,570 --> 00:18:56,610
the whole like rest powered by graphical

00:18:54,450 --> 00:18:58,110
things also great graphical really

00:18:56,610 --> 00:19:00,510
becomes like your one source of truth

00:18:58,110 --> 00:19:02,190
and just makes things so much simpler so

00:19:00,510 --> 00:19:03,720
how does that compare to how you were

00:19:02,190 --> 00:19:05,700
working on things at Shopify's are there

00:19:03,720 --> 00:19:09,090
similar techniques at Shopify or it was

00:19:05,700 --> 00:19:10,560
really similar I

00:19:09,090 --> 00:19:13,440
you can probably talk there's some

00:19:10,560 --> 00:19:16,140
Shopify people in here what's the state

00:19:13,440 --> 00:19:18,780
now well not if I think we had stopped

00:19:16,140 --> 00:19:21,150
working on like official support of REST

00:19:18,780 --> 00:19:23,850
API s and just like hope people would

00:19:21,150 --> 00:19:26,850
switch and like really that's pretty

00:19:23,850 --> 00:19:29,430
crazy it's kind of awesome to me to

00:19:26,850 --> 00:19:31,140
think that you have product developers

00:19:29,430 --> 00:19:33,830
who are wrapping the rest endpoints with

00:19:31,140 --> 00:19:35,419
graph QL and then you have public graph

00:19:33,830 --> 00:19:37,370
api's that are wrapping their graph kill

00:19:35,419 --> 00:19:39,289
with rests at some point somebody's

00:19:37,370 --> 00:19:47,240
gonna like wrap these two or three

00:19:39,289 --> 00:19:48,769
levels deep and risk so another thing I

00:19:47,240 --> 00:19:51,440
want to talk about is documentation I

00:19:48,769 --> 00:19:52,820
think internally we talk a lot about how

00:19:51,440 --> 00:19:55,190
documentation is really important to

00:19:52,820 --> 00:19:57,320
help other engineers within a company

00:19:55,190 --> 00:19:59,750
understand what's going on obviously in

00:19:57,320 --> 00:20:01,580
a public API that problem is even more

00:19:59,750 --> 00:20:04,010
important and then even more difficult

00:20:01,580 --> 00:20:05,450
like tenfold a lot of people have

00:20:04,010 --> 00:20:06,710
already talked before about how graphic

00:20:05,450 --> 00:20:08,510
ale can help you out with documentation

00:20:06,710 --> 00:20:10,370
but I'd love to hear what that actually

00:20:08,510 --> 00:20:12,350
looks like in practice do you just rely

00:20:10,370 --> 00:20:15,500
on graphical do you actually still build

00:20:12,350 --> 00:20:17,059
high-quality documentation what is that

00:20:15,500 --> 00:20:18,919
like Geron I want to go to you because I

00:20:17,059 --> 00:20:21,740
know this is like a personal passion of

00:20:18,919 --> 00:20:24,919
yours yeah I'm gonna make two plugs if I

00:20:21,740 --> 00:20:26,809
may yes one I actually just gave a talk

00:20:24,919 --> 00:20:30,649
about this in September at right the

00:20:26,809 --> 00:20:32,120
docs 2017 and Prague just about how API

00:20:30,649 --> 00:20:34,149
documentation has changed that they

00:20:32,120 --> 00:20:37,250
introduced an introduction of graph QL

00:20:34,149 --> 00:20:38,480
being able to generate Doc's from the

00:20:37,250 --> 00:20:40,760
descriptions of the types and the

00:20:38,480 --> 00:20:42,769
objects and whatnot and the second plug

00:20:40,760 --> 00:20:46,399
is that I actually have a gem called

00:20:42,769 --> 00:20:48,409
graph QL - Doc's which given an IDL file

00:20:46,399 --> 00:20:51,230
will grab all the descriptions and then

00:20:48,409 --> 00:20:53,929
spit out HTML for you and that's what's

00:20:51,230 --> 00:20:57,230
powering developer github comms API

00:20:53,929 --> 00:20:59,600
reference so it's pretty nice internally

00:20:57,230 --> 00:21:01,789
what we do is again like write a test to

00:20:59,600 --> 00:21:04,820
make sure that every single thing is

00:21:01,789 --> 00:21:08,240
documented we're trying to or their

00:21:04,820 --> 00:21:10,909
ideas to kind of move towards even sort

00:21:08,240 --> 00:21:14,600
of like linting that text so making sure

00:21:10,909 --> 00:21:16,460
that something called name doesn't just

00:21:14,600 --> 00:21:18,350
save the name or something like trying

00:21:16,460 --> 00:21:22,130
to get more intelligent reference stocks

00:21:18,350 --> 00:21:23,210
but yeah it's been really helpful oh I

00:21:22,130 --> 00:21:26,179
should also mention we have like a

00:21:23,210 --> 00:21:28,010
process that kicks off every time our

00:21:26,179 --> 00:21:29,830
public schema changes to just regenerate

00:21:28,010 --> 00:21:32,600
the documentation and push that out live

00:21:29,830 --> 00:21:34,880
so people can find the docs through

00:21:32,600 --> 00:21:36,230
graphical but we found that people are

00:21:34,880 --> 00:21:40,789
also finding the docs through the

00:21:36,230 --> 00:21:42,710
website itself yeah in general I think

00:21:40,789 --> 00:21:45,190
it's definitely a vast improvement it

00:21:42,710 --> 00:21:50,580
frees up time for your technical writers

00:21:45,190 --> 00:21:52,750
to concentrate on writing guides and

00:21:50,580 --> 00:21:55,900
yeah basically guides on how to use

00:21:52,750 --> 00:21:58,090
graph QL instead of wasting time trying

00:21:55,900 --> 00:22:00,340
to figure out what the right type is or

00:21:58,090 --> 00:22:02,530
what the right field name is or whether

00:22:00,340 --> 00:22:03,970
something's described accurately or not

00:22:02,530 --> 00:22:06,490
has there been the transfer of ownership

00:22:03,970 --> 00:22:08,260
so technical writers are usually

00:22:06,490 --> 00:22:10,450
responsible for the whole of the

00:22:08,260 --> 00:22:13,780
documentation but now that documentation

00:22:10,450 --> 00:22:15,820
has moved in line into code where your

00:22:13,780 --> 00:22:16,870
developers are working on that so do you

00:22:15,820 --> 00:22:19,120
now have more of a shared responsibility

00:22:16,870 --> 00:22:21,460
or are technical writers contributing

00:22:19,120 --> 00:22:22,930
directly to the codebase yeah I would

00:22:21,460 --> 00:22:24,790
say it I guess shared responsibility is

00:22:22,930 --> 00:22:27,160
more accurate since like the technical

00:22:24,790 --> 00:22:31,180
writers are contributing to the codebase

00:22:27,160 --> 00:22:32,620
as well but it's more also in an ideal

00:22:31,180 --> 00:22:34,830
world developers are also asking the

00:22:32,620 --> 00:22:37,990
writers like how do you describe this

00:22:34,830 --> 00:22:39,160
object this field that for us or for the

00:22:37,990 --> 00:22:41,890
program or whatever makes complete sense

00:22:39,160 --> 00:22:42,790
but you're not really sure how to word

00:22:41,890 --> 00:22:45,730
it so there's definitely like a

00:22:42,790 --> 00:22:48,520
back-and-forth of of how to what string

00:22:45,730 --> 00:22:49,770
description to provide and I think the

00:22:48,520 --> 00:22:51,580
ability also there's like markdown

00:22:49,770 --> 00:22:53,700
capabilities at least in the graphical

00:22:51,580 --> 00:22:56,380
ruby gem which also lets us like link

00:22:53,700 --> 00:22:59,140
amongst other definitions too so that's

00:22:56,380 --> 00:23:01,000
that's pretty neat that's nice Tomer

00:22:59,140 --> 00:23:02,860
what's this look like at Yelp do you you

00:23:01,000 --> 00:23:04,900
have public API documentation did you

00:23:02,860 --> 00:23:08,350
change strategies when graph killer came

00:23:04,900 --> 00:23:10,120
in to being or is it different it's most

00:23:08,350 --> 00:23:11,470
of the same I was pretty worried that we

00:23:10,120 --> 00:23:13,300
put crafty Allah and a lot of people

00:23:11,470 --> 00:23:14,560
wouldn't really understand how use it or

00:23:13,300 --> 00:23:17,560
what it could do compared to the REST

00:23:14,560 --> 00:23:19,000
API so I got a lot of documentation as

00:23:17,560 --> 00:23:21,280
basically as much as I could to explain

00:23:19,000 --> 00:23:23,800
you know high-level craft QL is but also

00:23:21,280 --> 00:23:26,110
how you can use the API and then I

00:23:23,800 --> 00:23:27,550
embedded graphical everywhere so there's

00:23:26,110 --> 00:23:29,890
probably like two or three pre-made

00:23:27,550 --> 00:23:31,330
graphical examples for what I would have

00:23:29,890 --> 00:23:33,820
guessed is the most commonly requested

00:23:31,330 --> 00:23:35,920
patterns for specific graph QL queries

00:23:33,820 --> 00:23:37,600
and each page so that people can quickly

00:23:35,920 --> 00:23:38,350
reference and go execute the query and

00:23:37,600 --> 00:23:41,890
see what it looks like

00:23:38,350 --> 00:23:43,600
I was very uh pretty excited to be able

00:23:41,890 --> 00:23:45,520
to give people like live examples they

00:23:43,600 --> 00:23:47,920
could test that's cool so then they can

00:23:45,520 --> 00:23:49,690
sort of live mess with that and then see

00:23:47,920 --> 00:23:50,400
oh if I change this a little bit I get

00:23:49,690 --> 00:23:53,410
what I need

00:23:50,400 --> 00:23:55,660
yeah we've already mentioned a little

00:23:53,410 --> 00:23:56,290
bit some conventions like ways to do

00:23:55,660 --> 00:23:58,390
pagination

00:23:56,290 --> 00:24:01,030
and but I'd love to hear if there's any

00:23:58,390 --> 00:24:03,580
sort of unique cases of common

00:24:01,030 --> 00:24:05,470
conventions or naming patterns that you

00:24:03,580 --> 00:24:07,360
came to while building your AP is that

00:24:05,470 --> 00:24:08,800
you think are unique or different from

00:24:07,360 --> 00:24:11,950
what else is happening in the community

00:24:08,800 --> 00:24:15,280
I don't think we have anything too

00:24:11,950 --> 00:24:17,380
specific designing the API the graph QL

00:24:15,280 --> 00:24:19,060
API specifically on our side was maybe a

00:24:17,380 --> 00:24:21,100
little easier because we pretty much has

00:24:19,060 --> 00:24:23,500
tried to copy feature parity from the

00:24:21,100 --> 00:24:25,360
ast API so we'd already spent a lot of

00:24:23,500 --> 00:24:26,860
time on how we want responses to be

00:24:25,360 --> 00:24:29,470
structure what we want naming to be what

00:24:26,860 --> 00:24:31,720
the convention should be so we tried to

00:24:29,470 --> 00:24:33,760
keep them pretty much one-to-one any

00:24:31,720 --> 00:24:36,250
mistakes that you made in the process or

00:24:33,760 --> 00:24:37,750
maybe a convention now in retrospect you

00:24:36,250 --> 00:24:38,980
like I wish we had a convention for that

00:24:37,750 --> 00:24:42,270
it's kind of all over the place now

00:24:38,980 --> 00:24:44,770
maybe something I can talk about is um

00:24:42,270 --> 00:24:47,140
maybe coming back to documentation even

00:24:44,770 --> 00:24:48,790
like a lot of documentation for

00:24:47,140 --> 00:24:50,800
graphical comes from the description

00:24:48,790 --> 00:24:53,470
that we have in line but I think another

00:24:50,800 --> 00:24:57,070
part of that this documentation is this

00:24:53,470 --> 00:24:58,810
key myself and that comes into design so

00:24:57,070 --> 00:25:00,790
maybe you can correct me if I'm wrong

00:24:58,810 --> 00:25:03,850
Lee but I think in facebook a lot of the

00:25:00,790 --> 00:25:05,920
fields are inaudible or maybe even all

00:25:03,850 --> 00:25:07,900
of them yeah right now almost every

00:25:05,920 --> 00:25:09,340
field internally is null mostly because

00:25:07,900 --> 00:25:11,740
we actually introduced the concept of

00:25:09,340 --> 00:25:13,600
saying something is not malleable a long

00:25:11,740 --> 00:25:15,190
after we'd build most of it right this

00:25:13,600 --> 00:25:16,510
is a case where we learned like yeah we

00:25:15,190 --> 00:25:18,160
really want the ability to say this will

00:25:16,510 --> 00:25:21,220
never be any yeah so I think like just

00:25:18,160 --> 00:25:23,440
for documentation having the right like

00:25:21,220 --> 00:25:25,750
knowable fields in the right places to

00:25:23,440 --> 00:25:28,480
really show what's possible or not like

00:25:25,750 --> 00:25:30,340
an example is had mutation that has four

00:25:28,480 --> 00:25:32,410
arguments and they're all not able and

00:25:30,340 --> 00:25:34,540
depending on the combination of what's

00:25:32,410 --> 00:25:36,670
passed there's a different behavior and

00:25:34,540 --> 00:25:39,310
you have to document that like in a big

00:25:36,670 --> 00:25:41,980
wall of text and description if you just

00:25:39,310 --> 00:25:43,630
have like either different different

00:25:41,980 --> 00:25:46,300
mutations that are like more strongly

00:25:43,630 --> 00:25:49,060
typed that removes the need for like

00:25:46,300 --> 00:25:51,250
complex documentation and errors so

00:25:49,060 --> 00:25:54,250
that's a big like I guess design thing

00:25:51,250 --> 00:25:56,140
we noticed Shopify and I think we're

00:25:54,250 --> 00:25:59,860
gonna really use that a github to it

00:25:56,140 --> 00:26:03,850
just really have an eye schema and never

00:25:59,860 --> 00:26:07,710
let well not often don't let runtime to

00:26:03,850 --> 00:26:07,710
decide so much as like the schema itself

00:26:09,480 --> 00:26:13,940
any other thoughts on you know lessons

00:26:11,640 --> 00:26:16,530
learned mistakes made in the process

00:26:13,940 --> 00:26:18,059
public api's are hard right so what once

00:26:16,530 --> 00:26:20,250
they're out there you really you can't

00:26:18,059 --> 00:26:21,690
take it back because you can't even get

00:26:20,250 --> 00:26:24,059
a good hole all the people that are

00:26:21,690 --> 00:26:26,429
using it so is that maybe I know

00:26:24,059 --> 00:26:28,290
anything is when you design for a public

00:26:26,429 --> 00:26:30,780
schema that like you said when it's out

00:26:28,290 --> 00:26:33,179
there is there it's always fun to leave

00:26:30,780 --> 00:26:35,100
yourself a bit of space to move if

00:26:33,179 --> 00:26:36,179
things were to change how do you do that

00:26:35,100 --> 00:26:37,980
like how do you make sure you have space

00:26:36,179 --> 00:26:40,470
to move so I think this actually comes

00:26:37,980 --> 00:26:43,080
from Facebook district but to name name

00:26:40,470 --> 00:26:45,390
you feel something's really specific so

00:26:43,080 --> 00:26:48,419
in case things go wrong you can like

00:26:45,390 --> 00:26:51,299
chop it and like deprecated it while you

00:26:48,419 --> 00:26:53,460
have something else that's a trick it's

00:26:51,299 --> 00:26:55,080
not the nicest thing but sometimes we

00:26:53,460 --> 00:26:57,030
got it we found that we end up doing it

00:26:55,080 --> 00:26:59,160
the other way around right sort of like

00:26:57,030 --> 00:27:01,020
we had a handful of cases where someone

00:26:59,160 --> 00:27:02,130
exposed something as a raw list and then

00:27:01,020 --> 00:27:03,809
later is like actually I want to be able

00:27:02,130 --> 00:27:05,940
to paginate over this you have a lot of

00:27:03,809 --> 00:27:08,340
things this isn't one but just for

00:27:05,940 --> 00:27:10,950
naming ease it's going from like friends

00:27:08,340 --> 00:27:12,600
- friends connections you know yeah

00:27:10,950 --> 00:27:14,309
don't use friends use friends connection

00:27:12,600 --> 00:27:15,780
cuz what did you have a lot you're gonna

00:27:14,309 --> 00:27:16,140
blow up your clients yeah that makes

00:27:15,780 --> 00:27:18,900
sense

00:27:16,140 --> 00:27:20,940
another example is having a field that's

00:27:18,900 --> 00:27:23,490
a scaler but you should always think

00:27:20,940 --> 00:27:25,320
could this evolve into like a more

00:27:23,490 --> 00:27:27,600
complex object and it's pretty annoying

00:27:25,320 --> 00:27:30,120
to deprecate - so sometimes just like

00:27:27,600 --> 00:27:32,549
creating extra types to leave you some

00:27:30,120 --> 00:27:34,350
space to add fields later it's pretty

00:27:32,549 --> 00:27:36,480
nice when it's time to deprecate stuff

00:27:34,350 --> 00:27:38,910
yeah so you find yourselves trying to

00:27:36,480 --> 00:27:41,160
think ahead and what changes you might

00:27:38,910 --> 00:27:46,740
Mike might make in the future when

00:27:41,160 --> 00:27:49,169
you're designing the schemas yes like a

00:27:46,740 --> 00:27:50,970
sample yeah we also have an internal

00:27:49,169 --> 00:27:53,010
schema which is kind of like our testbed

00:27:50,970 --> 00:27:54,720
so when we're in the process of

00:27:53,010 --> 00:27:55,490
dogfooding a new feature or something we

00:27:54,720 --> 00:27:59,130
annotate

00:27:55,490 --> 00:28:00,780
our schema as visibility internal which

00:27:59,130 --> 00:28:02,340
allows engineers to kind of make

00:28:00,780 --> 00:28:05,220
breaking changes and do whatever that

00:28:02,340 --> 00:28:07,650
the public will never ever see and then

00:28:05,220 --> 00:28:08,700
when we're ready to even sometimes a

00:28:07,650 --> 00:28:10,860
little bit after the feature of ship

00:28:08,700 --> 00:28:13,470
when we're ready to publicize it we'll

00:28:10,860 --> 00:28:16,740
just remove that that single line and

00:28:13,470 --> 00:28:19,140
it'll be part of the public schema which

00:28:16,740 --> 00:28:21,180
is which is pretty nice I guess I guess

00:28:19,140 --> 00:28:23,970
the only design of design the kind

00:28:21,180 --> 00:28:26,490
of question that I would love to hear

00:28:23,970 --> 00:28:28,740
about from anyone his deprecation how to

00:28:26,490 --> 00:28:30,060
announce to the client you you announce

00:28:28,740 --> 00:28:32,250
the client your deprecating and how do

00:28:30,060 --> 00:28:33,870
you maybe you're looking at the numbers

00:28:32,250 --> 00:28:35,670
which we track we know which fields

00:28:33,870 --> 00:28:37,590
people are calling we know how many

00:28:35,670 --> 00:28:39,150
times they're being called but conveying

00:28:37,590 --> 00:28:41,580
that information or pointing people to

00:28:39,150 --> 00:28:44,630
the new information really only comes in

00:28:41,580 --> 00:28:46,410
through that deprecation reason string

00:28:44,630 --> 00:28:48,570
so that's definitely something that

00:28:46,410 --> 00:28:50,550
we're still this is literally the next

00:28:48,570 --> 00:28:53,220
thing I wanted to talk hell yes of all

00:28:50,550 --> 00:28:54,990
things came over time so it sounds like

00:28:53,220 --> 00:28:56,670
that's still an active conversation yeah

00:28:54,990 --> 00:28:58,530
so where is this something you've given

00:28:56,670 --> 00:29:00,330
a lot of thought to not yet

00:28:58,530 --> 00:29:01,950
no we haven't really got that point I

00:29:00,330 --> 00:29:03,750
mean I guess that's a good thing if

00:29:01,950 --> 00:29:04,440
you're if your skin is like evolving

00:29:03,750 --> 00:29:06,900
such that you're not actually

00:29:04,440 --> 00:29:08,430
deprecating stuff we so when we

00:29:06,900 --> 00:29:09,840
initially introduced deprecation it

00:29:08,430 --> 00:29:11,100
didn't just have reason it also had

00:29:09,840 --> 00:29:15,570
another field that would tell you the

00:29:11,100 --> 00:29:17,160
date at which it would disappear and we

00:29:15,570 --> 00:29:18,960
realized like there was just no way to

00:29:17,160 --> 00:29:20,880
enforce that because like if you say

00:29:18,960 --> 00:29:22,860
like oh this is going away in six months

00:29:20,880 --> 00:29:23,850
and then six months later you still have

00:29:22,860 --> 00:29:26,340
tons of people using it you're like

00:29:23,850 --> 00:29:29,070
nevermind I don't want to break every

00:29:26,340 --> 00:29:30,210
one so it was just useless like that day

00:29:29,070 --> 00:29:33,510
was there and it was just you know

00:29:30,210 --> 00:29:35,460
there's no teeth on that so I think this

00:29:33,510 --> 00:29:37,080
is like an active area that people are

00:29:35,460 --> 00:29:39,570
still thinking about for how do you

00:29:37,080 --> 00:29:42,210
actually communicate that something is

00:29:39,570 --> 00:29:44,310
going away in the future have you had to

00:29:42,210 --> 00:29:45,750
encounter this with you know previous to

00:29:44,310 --> 00:29:48,750
graphical and your public API is when

00:29:45,750 --> 00:29:51,930
you change things so we with the launch

00:29:48,750 --> 00:29:53,280
of our fusion API last September we in

00:29:51,930 --> 00:29:55,350
the process of duplicating our v2 API

00:29:53,280 --> 00:29:58,110
which we've made in like 2011 or

00:29:55,350 --> 00:29:59,910
something so it's a bit of an ongoing

00:29:58,110 --> 00:30:01,740
process we announced a couple months ago

00:29:59,910 --> 00:30:05,550
that is going to get shut down in June

00:30:01,740 --> 00:30:07,710
and we're blog posts tweets emails the

00:30:05,550 --> 00:30:08,970
whole the whole shebang basically just

00:30:07,710 --> 00:30:11,970
making sure that people are very aware

00:30:08,970 --> 00:30:13,250
that the old API shutting down so we're

00:30:11,970 --> 00:30:16,170
trying to be very proactive about

00:30:13,250 --> 00:30:17,970
getting people on to the new API we

00:30:16,170 --> 00:30:20,940
everything is logged so we know who's

00:30:17,970 --> 00:30:22,500
making requests to the v2 API so we send

00:30:20,940 --> 00:30:24,750
out targeted emails to make sure that

00:30:22,500 --> 00:30:26,910
they're aware and are migrating off or

00:30:24,750 --> 00:30:27,240
else it'll just stop working that makes

00:30:26,910 --> 00:30:29,700
sense

00:30:27,240 --> 00:30:31,800
I that relates to things I've seen

00:30:29,700 --> 00:30:33,880
happen at Facebook as well we don't have

00:30:31,800 --> 00:30:35,950
a public graph QL API but after

00:30:33,880 --> 00:30:37,600
is still part of our public API which

00:30:35,950 --> 00:30:39,250
gives us this like field level access

00:30:37,600 --> 00:30:41,200
and I think we've used the exact same

00:30:39,250 --> 00:30:42,760
technique where any developer who's

00:30:41,200 --> 00:30:44,650
still hitting a field that's on the cusp

00:30:42,760 --> 00:30:46,360
of being removed it is just getting

00:30:44,650 --> 00:30:47,590
emailed all the time saying please

00:30:46,360 --> 00:30:50,020
update your app please update your app

00:30:47,590 --> 00:30:51,730
it's gonna break on this day and so we

00:30:50,020 --> 00:30:52,570
can kind of point to a trace of emails

00:30:51,730 --> 00:30:55,419
that they've gotten over the years

00:30:52,570 --> 00:30:56,860
leading up to their app breaking yeah so

00:30:55,419 --> 00:30:58,809
maybe that's the solution want to take

00:30:56,860 --> 00:31:00,400
going forward with deprecation said if

00:30:58,809 --> 00:31:02,470
we can track which app is using the

00:31:00,400 --> 00:31:04,150
deprecated field in what case yeah with

00:31:02,470 --> 00:31:06,070
graphically since you know per field

00:31:04,150 --> 00:31:08,200
who's using what then you have a little

00:31:06,070 --> 00:31:10,090
bit more granularity on being loud about

00:31:08,200 --> 00:31:11,710
it yeah maybe it's something it's more

00:31:10,090 --> 00:31:14,620
difficult with the rest endpoint yeah

00:31:11,710 --> 00:31:16,929
it's basically all about things yeah and

00:31:14,620 --> 00:31:18,370
then again you already mentioned adding

00:31:16,929 --> 00:31:20,049
new things so you mentioned that you

00:31:18,370 --> 00:31:22,720
have an internal schema and a public

00:31:20,049 --> 00:31:25,390
schema is the internal one an explicit

00:31:22,720 --> 00:31:27,990
superset of the public one or as how

00:31:25,390 --> 00:31:30,490
does that work yeah exactly that there's

00:31:27,990 --> 00:31:31,929
you know staff features and other things

00:31:30,490 --> 00:31:33,820
that we will never expose to the public

00:31:31,929 --> 00:31:38,890
billing information that we've built out

00:31:33,820 --> 00:31:40,330
for for github employees that is done in

00:31:38,890 --> 00:31:43,179
graph gala but will just never be part

00:31:40,330 --> 00:31:45,010
of the public schema so yeah it's very

00:31:43,179 --> 00:31:46,330
much a superset and it's very much kind

00:31:45,010 --> 00:31:48,789
of like our testing ground to make sure

00:31:46,330 --> 00:31:51,669
that fields are named correctly they're

00:31:48,789 --> 00:31:54,250
behaving they behave the way we want

00:31:51,669 --> 00:31:56,890
them to behave and they feel the way we

00:31:54,250 --> 00:31:59,860
want them to feel I did

00:31:56,890 --> 00:32:01,299
yeah I did I did just remember talking

00:31:59,860 --> 00:32:02,409
about rest in graph QL one of the other

00:32:01,299 --> 00:32:04,840
things were starting to play around with

00:32:02,409 --> 00:32:06,850
is preview headers which was really big

00:32:04,840 --> 00:32:10,510
in our rest to be three kind of concept

00:32:06,850 --> 00:32:12,549
so in recipe three can be passed along

00:32:10,510 --> 00:32:14,200
and accept header you would be able to

00:32:12,549 --> 00:32:17,710
get more data from an endpoint or be

00:32:14,200 --> 00:32:20,140
able to use a specific endpoint that we

00:32:17,710 --> 00:32:21,820
basically stated we would break without

00:32:20,140 --> 00:32:23,409
future announcement or anything like

00:32:21,820 --> 00:32:24,669
that so we're also starting to play

00:32:23,409 --> 00:32:27,190
around with well what if you sent an

00:32:24,669 --> 00:32:28,809
accept header and you got a schema with

00:32:27,190 --> 00:32:31,000
some additional fields attached to it

00:32:28,809 --> 00:32:33,280
beta schema exactly yeah

00:32:31,000 --> 00:32:35,530
so some kind of like middle ground in

00:32:33,280 --> 00:32:38,559
between like fully fully public and

00:32:35,530 --> 00:32:40,000
fully hidden we don't we have some

00:32:38,559 --> 00:32:41,650
internal stuff working around that but

00:32:40,000 --> 00:32:43,240
but I think that's also like an

00:32:41,650 --> 00:32:44,230
interesting direction like just

00:32:43,240 --> 00:32:44,980
something that we used to do all the

00:32:44,230 --> 00:32:46,539
time of the rest day

00:32:44,980 --> 00:32:48,610
yeah yeah it sounds like there's a

00:32:46,539 --> 00:32:51,370
little bit more there than just its

00:32:48,610 --> 00:32:53,230
internal or its external some of the

00:32:51,370 --> 00:32:54,850
internal stuff is definitely employees

00:32:53,230 --> 00:32:56,380
only some of it is stuff that you're

00:32:54,850 --> 00:32:58,480
working on that you'll eventually make

00:32:56,380 --> 00:33:00,130
public how do you make sure the lines in

00:32:58,480 --> 00:33:01,630
the sand between those things don't get

00:33:00,130 --> 00:33:03,460
foiled and you accidentally exposed

00:33:01,630 --> 00:33:08,289
billing information to the public yeah

00:33:03,460 --> 00:33:10,539
we very carefully we have a bunch of

00:33:08,289 --> 00:33:13,740
tests I guess that's the only that's the

00:33:10,539 --> 00:33:16,840
only sane way to do it where we have

00:33:13,740 --> 00:33:18,519
users and you know mock users that are

00:33:16,840 --> 00:33:21,850
not staff intentionally try to make

00:33:18,519 --> 00:33:23,769
queries that are internal or our staff

00:33:21,850 --> 00:33:27,880
only and those should fail and we

00:33:23,769 --> 00:33:30,279
anticipate that those fail and I'm sorry

00:33:27,880 --> 00:33:33,429
go ahead no no we got also a good idea

00:33:30,279 --> 00:33:35,860
okay good the ice idea of files also

00:33:33,429 --> 00:33:37,779
like that are outputted every time we

00:33:35,860 --> 00:33:39,490
build the new schema and we got like

00:33:37,779 --> 00:33:41,320
that schema compare a thing that like

00:33:39,490 --> 00:33:43,029
clearly says like which field was added

00:33:41,320 --> 00:33:47,500
removed so I think it's pretty easy to

00:33:43,029 --> 00:33:48,760
catch changes there and see it we have a

00:33:47,500 --> 00:33:51,010
really similar thing happening at

00:33:48,760 --> 00:33:52,570
Facebook so we have you know our API is

00:33:51,010 --> 00:33:55,990
for developing products but we have

00:33:52,570 --> 00:33:58,029
products that users can see right the

00:33:55,990 --> 00:33:59,830
Facebook app but we also use graphical

00:33:58,029 --> 00:34:01,149
to power all of our internal tools so we

00:33:59,830 --> 00:34:02,590
have tons of really sensitive

00:34:01,149 --> 00:34:05,649
information exactly that like billing

00:34:02,590 --> 00:34:07,120
information you know that kind of thing

00:34:05,649 --> 00:34:08,859
and we have the same set up so our

00:34:07,120 --> 00:34:11,770
internal one is a superset of our public

00:34:08,859 --> 00:34:12,879
one and we use that same tool so it's

00:34:11,770 --> 00:34:14,710
cool that we've landed on similar

00:34:12,879 --> 00:34:16,270
solutions when you do it when you make a

00:34:14,710 --> 00:34:18,849
diff that's gonna affect the schema will

00:34:16,270 --> 00:34:21,129
actually print in line in your diff or

00:34:18,849 --> 00:34:24,159
in your PR here's the fields and adding

00:34:21,129 --> 00:34:25,480
to each schema and or removed and that

00:34:24,159 --> 00:34:27,099
way you know that you're about to break

00:34:25,480 --> 00:34:29,050
something or that you're about to expose

00:34:27,099 --> 00:34:31,270
something you didn't intend on it works

00:34:29,050 --> 00:34:33,159
well we've also been talking today about

00:34:31,270 --> 00:34:34,210
sort of some of the newer things added

00:34:33,159 --> 00:34:36,339
to graphical like graphical

00:34:34,210 --> 00:34:37,839
subscriptions and live queries are these

00:34:36,339 --> 00:34:40,179
things that you were thinking about

00:34:37,839 --> 00:34:42,159
adding to public api's anytime in the

00:34:40,179 --> 00:34:45,159
future or are you kind of like waiting

00:34:42,159 --> 00:34:48,159
for those to be fleshed out first not on

00:34:45,159 --> 00:34:50,349
our side not in Yelp what about github I

00:34:48,159 --> 00:34:52,149
know it yes in my mind what's that yes

00:34:50,349 --> 00:34:53,950
yes

00:34:52,149 --> 00:34:54,500
like subscriptions are kind of like the

00:34:53,950 --> 00:34:55,790
big

00:34:54,500 --> 00:34:57,500
sort of thing we're looking at we use

00:34:55,790 --> 00:34:58,880
webhooks right now which again runs in

00:34:57,500 --> 00:35:00,950
the same problem that the rest api does

00:34:58,880 --> 00:35:02,060
which is you know if you are paying

00:35:00,950 --> 00:35:04,010
attention to issues that are being

00:35:02,060 --> 00:35:05,960
created we'll just send you a blob of

00:35:04,010 --> 00:35:06,740
information that you might not even care

00:35:05,960 --> 00:35:09,140
about

00:35:06,740 --> 00:35:12,290
so those payloads are we've actually

00:35:09,140 --> 00:35:14,810
several times exceeded I think we have a

00:35:12,290 --> 00:35:16,550
one megabyte limit on our on our JSON

00:35:14,810 --> 00:35:18,050
payloads that we exceed for like really

00:35:16,550 --> 00:35:20,300
large integrators so being able to move

00:35:18,050 --> 00:35:22,070
to subscriptions would be really cool

00:35:20,300 --> 00:35:23,450
just again make the client that's

00:35:22,070 --> 00:35:25,730
interesting usually when we talk about

00:35:23,450 --> 00:35:28,160
subscriptions we end up talking about

00:35:25,730 --> 00:35:31,250
WebSockets or like an open connection to

00:35:28,160 --> 00:35:32,960
a client but you're talking about these

00:35:31,250 --> 00:35:34,460
web hooks which are when something

00:35:32,960 --> 00:35:36,170
happens I'm gonna hit a post endpoint of

00:35:34,460 --> 00:35:37,820
your server so it's it's a totally

00:35:36,170 --> 00:35:39,230
different way about thinking about like

00:35:37,820 --> 00:35:41,120
an event channel but it sounds like it

00:35:39,230 --> 00:35:42,590
makes a lot of sense yeah this is

00:35:41,120 --> 00:35:44,210
something that Shopify has everything is

00:35:42,590 --> 00:35:45,740
there an equivalent of like web hooks or

00:35:44,210 --> 00:35:47,870
something like that Shopify yeah I was

00:35:45,740 --> 00:35:50,840
pretty much the same as web hooks also

00:35:47,870 --> 00:35:52,760
subscriptions are insanely interesting

00:35:50,840 --> 00:35:54,860
for that if you're like

00:35:52,760 --> 00:35:56,270
I mean I'd github we Robert who's the

00:35:54,860 --> 00:35:57,950
maintainer of graphical Ruby has been

00:35:56,270 --> 00:36:00,350
working on a subscription implementation

00:35:57,950 --> 00:36:02,240
there too so like we have that going I'm

00:36:00,350 --> 00:36:05,390
really excited to see how we can use

00:36:02,240 --> 00:36:09,760
that cool so we go for it future

00:36:05,390 --> 00:36:12,200
advancement push API is that's awesome

00:36:09,760 --> 00:36:14,570
so we we talked a little bit about

00:36:12,200 --> 00:36:18,170
internal and external schemas but how

00:36:14,570 --> 00:36:20,360
about just security and authorization in

00:36:18,170 --> 00:36:22,940
general what kind of things are you

00:36:20,360 --> 00:36:24,380
doing below graph kill to make sure that

00:36:22,940 --> 00:36:25,010
the right people can access the right

00:36:24,380 --> 00:36:28,040
information

00:36:25,010 --> 00:36:30,290
Tomer so some of that stuff's been

00:36:28,040 --> 00:36:32,540
pretty hard for us one of the bigger

00:36:30,290 --> 00:36:35,420
things is has been great limiting access

00:36:32,540 --> 00:36:37,100
control it's a lot it's a lot more

00:36:35,420 --> 00:36:39,020
straightforward to count access on our

00:36:37,100 --> 00:36:41,300
guest API because one request is just

00:36:39,020 --> 00:36:43,070
you know one counter against a but with

00:36:41,300 --> 00:36:45,260
the flexibility that graph QL introduces

00:36:43,070 --> 00:36:46,490
it's a lot harder to properly estimate

00:36:45,260 --> 00:36:48,650
the load that somebody could introduce

00:36:46,490 --> 00:36:50,480
on your server so we've been trying to

00:36:48,650 --> 00:36:51,710
figure out a lot of how to properly

00:36:50,480 --> 00:36:53,510
restrict some of that stuff we don't

00:36:51,710 --> 00:36:55,670
want people requesting twenty million

00:36:53,510 --> 00:36:57,290
businesses and one go that's probably

00:36:55,670 --> 00:37:00,980
gonna make some hard DBA and operations

00:36:57,290 --> 00:37:02,150
teams pretty sad so we're trying to kind

00:37:00,980 --> 00:37:03,620
of get your consensus we're sort of

00:37:02,150 --> 00:37:05,750
heading towards a node-based or an

00:37:03,620 --> 00:37:08,030
object-based gate limiting solution

00:37:05,750 --> 00:37:08,610
where every time it effectively works

00:37:08,030 --> 00:37:10,140
out so a we

00:37:08,610 --> 00:37:12,390
we have to make an internal API request

00:37:10,140 --> 00:37:14,460
to load data it counts against the daily

00:37:12,390 --> 00:37:15,870
rate limit so the ascent the incentive

00:37:14,460 --> 00:37:17,190
structure there is also pretty closely

00:37:15,870 --> 00:37:19,320
correlated to the amount of work we have

00:37:17,190 --> 00:37:20,690
to do so that's sort of what we've been

00:37:19,320 --> 00:37:23,460
trying to figure out with that awesome

00:37:20,690 --> 00:37:25,440
what about it at Shopify or github or

00:37:23,460 --> 00:37:27,600
their similar solutions easier or harder

00:37:25,440 --> 00:37:30,120
I've been really interested in rate

00:37:27,600 --> 00:37:32,130
limiting for graph Joe for around now I

00:37:30,120 --> 00:37:34,110
was working a bit at at Shopify and

00:37:32,130 --> 00:37:35,640
github approached really cool too and

00:37:34,110 --> 00:37:37,640
they were both using different

00:37:35,640 --> 00:37:39,000
approaches with which I think are both

00:37:37,640 --> 00:37:41,600
nice

00:37:39,000 --> 00:37:43,800
so I'd Shopify at first we were using

00:37:41,600 --> 00:37:46,170
instead of like rate limiting on number

00:37:43,800 --> 00:37:49,110
of requests like you said it's hard to

00:37:46,170 --> 00:37:50,190
know it's just the number of requests we

00:37:49,110 --> 00:37:51,840
don't know the load is gonna be on

00:37:50,190 --> 00:37:54,150
service route we would use like a bucket

00:37:51,840 --> 00:37:56,760
of server time certain clients were

00:37:54,150 --> 00:37:59,520
allowed and that was kind of a nice

00:37:56,760 --> 00:38:02,570
approximation of how big that graphical

00:37:59,520 --> 00:38:06,150
query is at github if you haven't seen

00:38:02,570 --> 00:38:08,820
github api has a special type on the

00:38:06,150 --> 00:38:11,460
route which tells you the cost of your

00:38:08,820 --> 00:38:13,920
current query and how much left you have

00:38:11,460 --> 00:38:15,750
kind of a new bucket and they statically

00:38:13,920 --> 00:38:17,820
analyze your query to determine it cost

00:38:15,750 --> 00:38:20,520
and the max amount of nodes you can

00:38:17,820 --> 00:38:23,220
query and both are interesting with the

00:38:20,520 --> 00:38:25,500
time approach it's easier for mutations

00:38:23,220 --> 00:38:27,900
because it's hard to find the real cost

00:38:25,500 --> 00:38:30,690
to mutation you don't know what like

00:38:27,900 --> 00:38:32,730
posts will end up doing even just one

00:38:30,690 --> 00:38:34,920
field it doesn't necessarily have the

00:38:32,730 --> 00:38:35,280
same complexity than one other mutation

00:38:34,920 --> 00:38:37,890
field

00:38:35,280 --> 00:38:39,450
so for mutation the time approach was a

00:38:37,890 --> 00:38:41,190
little bit more accurate because it's

00:38:39,450 --> 00:38:42,660
literally just the time a mutation is

00:38:41,190 --> 00:38:44,550
gonna take so I don't know what you

00:38:42,660 --> 00:38:46,650
think Garin yeah we're like cost of

00:38:44,550 --> 00:38:47,940
mutation it's pretty good like I think I

00:38:46,650 --> 00:38:49,470
think the node based approach makes a

00:38:47,940 --> 00:38:52,410
ton of sense I think the the difficulty

00:38:49,470 --> 00:38:54,390
there is figuring out the cost I guess

00:38:52,410 --> 00:38:56,730
like maybe fetching 10 issues and not

00:38:54,390 --> 00:38:57,840
the same as fetching 10 commits right

00:38:56,730 --> 00:39:00,180
now we treat everything with with a

00:38:57,840 --> 00:39:02,460
value of 1 which doesn't feel right but

00:39:00,180 --> 00:39:04,740
yeah I think with some iteration yeah we

00:39:02,460 --> 00:39:06,540
thought about doing like weighted costs

00:39:04,740 --> 00:39:08,640
but that obviously introduces a very

00:39:06,540 --> 00:39:10,410
large amount of complexity yeah and

00:39:08,640 --> 00:39:12,330
these things there is it like how do we

00:39:10,410 --> 00:39:14,010
give someone an estimation of what it

00:39:12,330 --> 00:39:16,470
might actually look like to

00:39:14,010 --> 00:39:17,490
request it's hard to accurately predict

00:39:16,470 --> 00:39:19,560
like how many things are going to come

00:39:17,490 --> 00:39:20,790
back and then based on how many things

00:39:19,560 --> 00:39:21,180
come back what the weight of that will

00:39:20,790 --> 00:39:24,120
be

00:39:21,180 --> 00:39:25,980
so it sounds like a big concern is just

00:39:24,120 --> 00:39:27,750
thinking about how to restrict it's

00:39:25,980 --> 00:39:29,520
potentially very expensive queries but

00:39:27,750 --> 00:39:31,410
without the queries that should be

00:39:29,520 --> 00:39:33,540
reasonably fast to run how do you

00:39:31,410 --> 00:39:35,280
actually make them fast to run so how do

00:39:33,540 --> 00:39:37,680
you make a performance graph QL server

00:39:35,280 --> 00:39:40,590
that can handle really heterogeneous

00:39:37,680 --> 00:39:42,630
public traffic we added a lot of bulk

00:39:40,590 --> 00:39:44,880
endpoints and we have a lot of services

00:39:42,630 --> 00:39:46,860
service caching so our performance team

00:39:44,880 --> 00:39:49,380
built a middleman effectively that's

00:39:46,860 --> 00:39:52,080
called specter and it lets us cache bulk

00:39:49,380 --> 00:39:54,090
bulk endpoints - based on the object ID

00:39:52,080 --> 00:39:56,100
so whenever a graph QL query comes in

00:39:54,090 --> 00:39:58,170
and says I want data for business ID one

00:39:56,100 --> 00:40:00,000
through 15 maybe we have one through

00:39:58,170 --> 00:40:02,970
eight cached and we just have to go for

00:40:00,000 --> 00:40:05,310
9 through 15 into internal API so we get

00:40:02,970 --> 00:40:08,190
to save some time there we've also added

00:40:05,310 --> 00:40:10,140
this idea of quest budgets so we know

00:40:08,190 --> 00:40:11,850
there's a maximum guarantee on overall

00:40:10,140 --> 00:40:13,110
query execution and if we get to a point

00:40:11,850 --> 00:40:15,270
where things start taking too long we

00:40:13,110 --> 00:40:16,830
just kill the quests so we've added a

00:40:15,270 --> 00:40:19,500
lot of like performance and safeguards

00:40:16,830 --> 00:40:22,560
to service request to make sure that we

00:40:19,500 --> 00:40:24,690
can be fast is that different at Shopify

00:40:22,560 --> 00:40:28,440
or github how do you make a performance

00:40:24,690 --> 00:40:29,880
server yeah I will quickly latch on to

00:40:28,440 --> 00:40:31,680
that last comment like if your query

00:40:29,880 --> 00:40:33,300
takes 10 seconds or maybe it's seven

00:40:31,680 --> 00:40:35,460
seconds we just kill it but we basically

00:40:33,300 --> 00:40:38,760
use a graph QL batch which was done by

00:40:35,460 --> 00:40:40,380
the Shopify folks to kind of well maybe

00:40:38,760 --> 00:40:43,770
you can describe a little better but oh

00:40:40,380 --> 00:40:46,380
yeah sure defer yeah graphical match the

00:40:43,770 --> 00:40:48,080
gem written by actually Dylan I don't

00:40:46,380 --> 00:40:51,360
think he's here today I've chopped fire

00:40:48,080 --> 00:40:53,250
it's actually a it's actually based on

00:40:51,360 --> 00:40:55,140
the idea of data loader which I think

00:40:53,250 --> 00:40:59,070
maybe more people from the Jas community

00:40:55,140 --> 00:41:01,620
know basic idea is to be really lazy

00:40:59,070 --> 00:41:04,020
about loading stuff from your database

00:41:01,620 --> 00:41:07,590
for example and like bash these loads

00:41:04,020 --> 00:41:09,810
as one unit instead of executing a

00:41:07,590 --> 00:41:13,950
database query for like every field for

00:41:09,810 --> 00:41:17,130
example but yeah this has been a big

00:41:13,950 --> 00:41:19,170
help but if you just make graph field

00:41:17,130 --> 00:41:22,080
scheme I really naively without sort of

00:41:19,170 --> 00:41:24,300
a data loader thing things can go really

00:41:22,080 --> 00:41:25,260
wrong quickly but with that so I'm

00:41:24,300 --> 00:41:25,920
curious Lee you know you've all worked

00:41:25,260 --> 00:41:29,819
on

00:41:25,920 --> 00:41:31,500
CPI is before the graph KPIs and we

00:41:29,819 --> 00:41:32,549
don't typically talk about this kind of

00:41:31,500 --> 00:41:34,589
problem we're talking about building

00:41:32,549 --> 00:41:35,940
REST API is because I think we often

00:41:34,589 --> 00:41:38,849
think this is the clients problem right

00:41:35,940 --> 00:41:40,770
the client needs 15 different businesses

00:41:38,849 --> 00:41:42,809
from Yelp they're gonna hit the REST API

00:41:40,770 --> 00:41:46,200
15 times or maybe they'll hit the batch

00:41:42,809 --> 00:41:47,099
API if if there have the foresight to do

00:41:46,200 --> 00:41:50,220
that

00:41:47,099 --> 00:41:52,430
have you seen just kind of overall a

00:41:50,220 --> 00:41:55,290
difference in load from your public API

00:41:52,430 --> 00:41:59,010
from moving from rest to graph QL the

00:41:55,290 --> 00:42:00,390
worse or better just different not not

00:41:59,010 --> 00:42:01,950
too much some of the requests have

00:42:00,390 --> 00:42:04,619
gotten faster on graph QL just because

00:42:01,950 --> 00:42:06,089
we would end up adding a lot of like

00:42:04,619 --> 00:42:07,200
extra data into the guest API that

00:42:06,089 --> 00:42:09,869
people might not have cared about

00:42:07,200 --> 00:42:11,069
initially so they go into graphical and

00:42:09,869 --> 00:42:13,920
don't request that extra data

00:42:11,069 --> 00:42:16,260
so overall timings are about the same

00:42:13,920 --> 00:42:17,369
but I think because people don't care

00:42:16,260 --> 00:42:20,760
about as much data they just don't ask

00:42:17,369 --> 00:42:22,109
for as much makes sense cool well we're

00:42:20,760 --> 00:42:23,849
right about out of time I want to thank

00:42:22,109 --> 00:42:25,890
all these gents for answering all of my

00:42:23,849 --> 00:42:26,410
questions please give them a round of

00:42:25,890 --> 00:42:33,300
applause

00:42:26,410 --> 00:42:33,300

YouTube URL: https://www.youtube.com/watch?v=zuutqu2YF3E


