Title: Michael Fix - GraphQL on the Edge: A shield for your app
Publication date: 2017-11-07
Playlist: GraphQL Summit 2017
Description: 
	Michael Fix, Software Engineer at Intuit, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

One of the most important features of GraphQL is that it creates a concrete interface for interacting with your application. This same interface not only protects the data that enters and exits your app, but also gives you a unified method for testing it at every step of development. This talk discusses how to leverage GraphQL as a shield around your application, and presents a unified approach for testing this data access at every step of the development processâ€”from initial unit testing to deployment tests that ensure your app stays up-and-running.

See the slides here: https://t.co/dmNUM71JZ0
Captions: 
	00:00:03,410 --> 00:00:08,390
hi everybody I'm Mike fix I'm a software

00:00:06,230 --> 00:00:11,990
engineer at Intuit working on the graph

00:00:08,390 --> 00:00:14,030
QL api's and my title the title of my

00:00:11,990 --> 00:00:15,469
talk today is graph Q on the edge

00:00:14,030 --> 00:00:17,180
not because I'm talking about the

00:00:15,469 --> 00:00:19,850
cutting edge technology of graph kill

00:00:17,180 --> 00:00:21,830
but more so about the benefits you get

00:00:19,850 --> 00:00:23,810
about pushing graph kill to the very

00:00:21,830 --> 00:00:25,400
edges of your application both in

00:00:23,810 --> 00:00:27,380
protecting the data coming in and out of

00:00:25,400 --> 00:00:30,259
your app and also how that makes it

00:00:27,380 --> 00:00:32,360
really easy to test your applications

00:00:30,259 --> 00:00:34,070
I know testing something that we haven't

00:00:32,360 --> 00:00:41,870
talked much today and then I'm sorry I'm

00:00:34,070 --> 00:00:43,370
even bringing it up so this is what the

00:00:41,870 --> 00:00:44,960
world looks like to us right we have our

00:00:43,370 --> 00:00:47,329
application and then we have the outside

00:00:44,960 --> 00:00:49,370
world that could use our obligation a

00:00:47,329 --> 00:00:51,020
number of ways often unpredictable and

00:00:49,370 --> 00:00:53,420
that's what's so great about graph Keele

00:00:51,020 --> 00:00:56,000
is that it acts as a protective shield

00:00:53,420 --> 00:00:57,530
around your application shielding the

00:00:56,000 --> 00:00:59,270
data that comes in and out of your app

00:00:57,530 --> 00:01:01,609
and making it really easy for you to

00:00:59,270 --> 00:01:04,550
reason about that data but it also gives

00:01:01,609 --> 00:01:05,990
a common interface for you to access the

00:01:04,550 --> 00:01:08,900
data no matter where you're coming from

00:01:05,990 --> 00:01:11,270
no matter what client and this gives us

00:01:08,900 --> 00:01:13,640
a number of benefits in terms of

00:01:11,270 --> 00:01:15,650
validating that data you can normalize

00:01:13,640 --> 00:01:17,540
the data coming from multiple sources so

00:01:15,650 --> 00:01:20,060
that you can always operate it operate

00:01:17,540 --> 00:01:21,740
on it the same way you can sanitize that

00:01:20,060 --> 00:01:23,090
data for bad inputs or stuff that you

00:01:21,740 --> 00:01:27,800
don't want to store in your application

00:01:23,090 --> 00:01:30,350
or defend against unpredictable inputs

00:01:27,800 --> 00:01:32,690
and also verify that that data is

00:01:30,350 --> 00:01:35,330
correct when it's coming and going from

00:01:32,690 --> 00:01:37,130
your application so to take this example

00:01:35,330 --> 00:01:38,870
you have your application and there's a

00:01:37,130 --> 00:01:40,160
number of holes in which the data can

00:01:38,870 --> 00:01:42,410
come into it and you want to defend

00:01:40,160 --> 00:01:44,660
against all these holes like take for

00:01:42,410 --> 00:01:46,490
instance a phone number I can come in in

00:01:44,660 --> 00:01:48,350
a ton of different formats from the

00:01:46,490 --> 00:01:49,700
number different clients and you want to

00:01:48,350 --> 00:01:52,370
always operate on that phone number the

00:01:49,700 --> 00:01:55,400
same way or a script tag that you it's

00:01:52,370 --> 00:01:58,370
clearly something that you don't want to

00:01:55,400 --> 00:02:00,110
use or even a new date I can come in a

00:01:58,370 --> 00:02:01,580
ton of different formats and maybe you

00:02:00,110 --> 00:02:03,200
want to verify that it's a date in the

00:02:01,580 --> 00:02:05,990
past or a date in the future for due

00:02:03,200 --> 00:02:08,360
dates or time stamps with Grant field

00:02:05,990 --> 00:02:10,729
that scalar types you can really

00:02:08,360 --> 00:02:13,730
leverage that type system to do all this

00:02:10,729 --> 00:02:16,010
validation for you so that your your app

00:02:13,730 --> 00:02:16,430
always expects phone numbers to be a ten

00:02:16,010 --> 00:02:19,069
digit

00:02:16,430 --> 00:02:22,340
number with a plus sign in front of it

00:02:19,069 --> 00:02:23,840
you can get rid of and sanitize the data

00:02:22,340 --> 00:02:27,140
that comes in from other sources and

00:02:23,840 --> 00:02:28,670
also verify and validate dates and all

00:02:27,140 --> 00:02:31,280
sorts of different types coming into

00:02:28,670 --> 00:02:33,079
your system so this is something that

00:02:31,280 --> 00:02:37,069
I've been calling graph kill normalized

00:02:33,079 --> 00:02:40,430
types and I started curating a couple of

00:02:37,069 --> 00:02:42,980
these types in JavaScript to handle

00:02:40,430 --> 00:02:45,859
certain of these cases and it's called

00:02:42,980 --> 00:02:48,919
GMT because it's inspired by gin and

00:02:45,859 --> 00:02:50,900
tonics because they're simple they're

00:02:48,919 --> 00:02:54,200
consistent they're reliable they'll

00:02:50,900 --> 00:02:55,069
always be there for you and so we

00:02:54,200 --> 00:02:56,750
already have a couple of these

00:02:55,069 --> 00:02:59,030
implemented in this package go check it

00:02:56,750 --> 00:03:00,560
out please contribute this is definitely

00:02:59,030 --> 00:03:02,840
not a package that I need to own by any

00:03:00,560 --> 00:03:05,689
means but really it's just a number of

00:03:02,840 --> 00:03:07,430
types that we can reuse even across

00:03:05,689 --> 00:03:09,560
applications across different companies

00:03:07,430 --> 00:03:11,450
on across different repos so that we

00:03:09,560 --> 00:03:13,639
never have to re-implement these types

00:03:11,450 --> 00:03:16,700
again and you can see for the future

00:03:13,639 --> 00:03:18,829
imagine protecting its exercise safe on

00:03:16,700 --> 00:03:22,069
the type across all your application or

00:03:18,829 --> 00:03:24,229
a human name type that is locale aware

00:03:22,069 --> 00:03:26,690
and understands how you should really be

00:03:24,229 --> 00:03:28,220
printing someone's name and even after

00:03:26,690 --> 00:03:29,750
brainstorming for just ten minutes you

00:03:28,220 --> 00:03:31,939
can you can really think about a number

00:03:29,750 --> 00:03:34,189
of things where you really only want to

00:03:31,939 --> 00:03:37,040
implement this once and then just reuse

00:03:34,189 --> 00:03:39,530
it for every new application and across

00:03:37,040 --> 00:03:42,560
all your schemas so for example emails

00:03:39,530 --> 00:03:43,639
or CSS colors or URLs or all of these

00:03:42,560 --> 00:03:46,069
sorts of things that you really only

00:03:43,639 --> 00:03:47,840
need to do upon the data coming into

00:03:46,069 --> 00:03:51,650
your application and then never have to

00:03:47,840 --> 00:03:53,569
check it for these things again now that

00:03:51,650 --> 00:03:55,370
we know that our data is safe how do we

00:03:53,569 --> 00:03:57,620
test to make sure that once data is in

00:03:55,370 --> 00:03:59,629
right I'm going to defer to this quote

00:03:57,620 --> 00:04:01,849
by Danny airmail from the Facebook react

00:03:59,629 --> 00:04:03,949
core team test should be ideally be

00:04:01,849 --> 00:04:05,569
written against the public API s and so

00:04:03,949 --> 00:04:07,790
that's the best part about graph QL is

00:04:05,569 --> 00:04:09,889
that graph kill gives you this contract

00:04:07,790 --> 00:04:13,069
that makes it super easy to test because

00:04:09,889 --> 00:04:14,659
you know the minimum and maximum fields

00:04:13,069 --> 00:04:17,269
that you need to test to make sure that

00:04:14,659 --> 00:04:19,130
your API is operating correctly so

00:04:17,269 --> 00:04:21,440
here's an example of just a very simple

00:04:19,130 --> 00:04:24,440
test that you could you could you could

00:04:21,440 --> 00:04:28,130
use just a query and then verify that no

00:04:24,440 --> 00:04:30,409
errors come back even for unit testing

00:04:28,130 --> 00:04:33,139
so for one of our small applications

00:04:30,409 --> 00:04:35,419
before I join into it we use graph tool

00:04:33,139 --> 00:04:37,849
directly in the unit tests with no no

00:04:35,419 --> 00:04:39,979
mocks we just generated the data on that

00:04:37,849 --> 00:04:41,749
first line there executed the graph QL

00:04:39,979 --> 00:04:43,219
query and then asserted that the data

00:04:41,749 --> 00:04:47,059
was there and that there was no errors

00:04:43,219 --> 00:04:50,569
and that really covered a large on

00:04:47,059 --> 00:04:53,360
portion of our schema then even in the

00:04:50,569 --> 00:04:56,209
unit tests and then you can store these

00:04:53,360 --> 00:04:57,800
queries in files and reuse them during

00:04:56,209 --> 00:04:59,509
all sorts of levels of your testing so

00:04:57,800 --> 00:05:02,899
if you're using a continuous deployment

00:04:59,509 --> 00:05:04,939
environment at lambda up now you can

00:05:02,899 --> 00:05:07,459
just continually send these queries to

00:05:04,939 --> 00:05:09,669
your deployments before you alias them

00:05:07,459 --> 00:05:12,619
live or release them to production

00:05:09,669 --> 00:05:15,079
really allowing you to leverage the

00:05:12,619 --> 00:05:18,409
reusability of graph QL so you store the

00:05:15,079 --> 00:05:21,110
query once in a graph QL file you can

00:05:18,409 --> 00:05:23,539
import those into your your clients but

00:05:21,110 --> 00:05:25,669
also import them into your unit test or

00:05:23,539 --> 00:05:27,559
integration test suite and then also

00:05:25,669 --> 00:05:29,449
just use them in your developer workflow

00:05:27,559 --> 00:05:31,189
from the command line when you want to

00:05:29,449 --> 00:05:34,789
test to make sure that you didn't make

00:05:31,189 --> 00:05:36,829
braking changes in your API and so the

00:05:34,789 --> 00:05:40,240
second benefit that gets you is

00:05:36,829 --> 00:05:43,309
data-driven testing basically when you

00:05:40,240 --> 00:05:45,409
all you need is to separate the data

00:05:43,309 --> 00:05:47,479
that you want to send from your actual

00:05:45,409 --> 00:05:49,519
mutation or query so as you see here we

00:05:47,479 --> 00:05:50,929
have a top-level input and then the data

00:05:49,519 --> 00:05:53,689
that we're using for that input is

00:05:50,929 --> 00:05:55,429
completely separate so once you need

00:05:53,689 --> 00:05:57,679
that when you want to test more fields

00:05:55,429 --> 00:05:59,599
you just add more fields to the payload

00:05:57,679 --> 00:06:01,759
and then add more fields to what you're

00:05:59,599 --> 00:06:03,559
reading back to verify that the

00:06:01,759 --> 00:06:05,899
information you're sending is being

00:06:03,559 --> 00:06:09,319
operated on appropriately and this

00:06:05,899 --> 00:06:11,569
really allows you to test really really

00:06:09,319 --> 00:06:13,849
easily and reuse a lot of your testing

00:06:11,569 --> 00:06:15,439
logic and even allowing you to randomize

00:06:13,849 --> 00:06:17,719
some of these inputs when the strings

00:06:15,439 --> 00:06:19,509
don't matter or that the integers are

00:06:17,719 --> 00:06:23,439
sending don't matter and that really

00:06:19,509 --> 00:06:25,879
lets you leverage funds testing as well

00:06:23,439 --> 00:06:28,099
covering as many unexpected use cases

00:06:25,879 --> 00:06:32,269
across your application was really not

00:06:28,099 --> 00:06:33,800
much added logic that's all I have for

00:06:32,269 --> 00:06:36,829
you today thanks and if you want to come

00:06:33,800 --> 00:06:38,869
contact me later there's my email please

00:06:36,829 --> 00:06:42,080
feel free to shoot me an email hit me up

00:06:38,869 --> 00:06:42,180
on Twitter and thank you

00:06:42,080 --> 00:06:48,930
you

00:06:42,180 --> 00:06:48,930

YouTube URL: https://www.youtube.com/watch?v=d0xMqeVhlhQ


