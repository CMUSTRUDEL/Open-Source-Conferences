Title: Lewis Chung - Type Safe Data Access in Your Javascript GraphQL Apps with Codegen
Publication date: 2017-11-07
Playlist: GraphQL Summit 2017
Description: 
	Lewis Chung, Frontend Infrastructure Engineer at Coursera, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

Do you ever worry about whether or not you are handling every edge case in your application’s data access: nullable fields, union types, etc? In this session, you’ll learn how to use apollo-codegen to auto-generate Flow/Typescript types for your GraphQL so that you don’t have to worry anymore!
Captions: 
	00:00:03,620 --> 00:00:09,780
hello graph you'll summit

00:00:06,330 --> 00:00:12,059
my name is Lois trunk and this is me I

00:00:09,780 --> 00:00:14,639
work at a company called Coursera we

00:00:12,059 --> 00:00:17,189
have over 2000 courses on our platform

00:00:14,639 --> 00:00:20,220
from over 150 partner universities from

00:00:17,189 --> 00:00:21,540
around the world and so most of our

00:00:20,220 --> 00:00:22,739
product developers at Coursera spend a

00:00:21,540 --> 00:00:24,960
lot of time building a great course

00:00:22,739 --> 00:00:27,000
experience online but actually that's

00:00:24,960 --> 00:00:28,529
not what I do I'm actually a front-end

00:00:27,000 --> 00:00:30,450
infrastructure engineer at Coursera and

00:00:28,529 --> 00:00:32,130
so I'm focused on how can we actually

00:00:30,450 --> 00:00:34,710
make our product developers more

00:00:32,130 --> 00:00:35,969
productive so something that got me

00:00:34,710 --> 00:00:39,179
really excited when we started diving

00:00:35,969 --> 00:00:41,039
into graph tool itself was hey we have a

00:00:39,179 --> 00:00:43,199
we now have this schema thing that we

00:00:41,039 --> 00:00:44,850
can build tools off of is there a way to

00:00:43,199 --> 00:00:46,890
get to a point where all of our data

00:00:44,850 --> 00:00:49,109
access in our client applications are

00:00:46,890 --> 00:00:50,339
type safe right and so as I was looking

00:00:49,109 --> 00:00:52,620
around I found a project called Apollo

00:00:50,339 --> 00:00:54,749
code gen and I saw that there was

00:00:52,620 --> 00:00:56,309
rudimentary support for fluent

00:00:54,749 --> 00:00:57,629
typescript and so I jumped right into it

00:00:56,309 --> 00:01:00,899
and said could I help out they gladly

00:00:57,629 --> 00:01:02,219
said yes and so I wanted to share with

00:01:00,899 --> 00:01:05,400
you guys why I think you guys should all

00:01:02,219 --> 00:01:06,960
be interested in Apollo code gen so to

00:01:05,400 --> 00:01:07,770
do that I'm gonna go over three things

00:01:06,960 --> 00:01:09,660
today

00:01:07,770 --> 00:01:11,520
what is the pollak again why should you

00:01:09,660 --> 00:01:14,250
use it and how you can actually use it

00:01:11,520 --> 00:01:16,560
so starting with what is Apollo code gen

00:01:14,250 --> 00:01:18,030
well Apollo koujun is a tool that aims

00:01:16,560 --> 00:01:20,970
to bridge type systems using the

00:01:18,030 --> 00:01:23,280
graphical type system as the input type

00:01:20,970 --> 00:01:25,710
system and then it's able to generate

00:01:23,280 --> 00:01:26,700
many different types during many

00:01:25,710 --> 00:01:28,740
different types of physicians for

00:01:26,700 --> 00:01:30,870
different types of stumps and actually

00:01:28,740 --> 00:01:33,120
apollo android and apollo iOS that was

00:01:30,870 --> 00:01:36,210
mentioned earlier today uses this under

00:01:33,120 --> 00:01:37,920
the hood so how is it able to do this

00:01:36,210 --> 00:01:39,510
well actually in your applications

00:01:37,920 --> 00:01:42,120
themselves you have all the information

00:01:39,510 --> 00:01:44,520
you really need to do this to operate

00:01:42,120 --> 00:01:46,560
some fragments that you define are

00:01:44,520 --> 00:01:49,740
specifying what is the shape of the data

00:01:46,560 --> 00:01:51,270
that you're accessing combined that with

00:01:49,740 --> 00:01:52,530
the introspection schema that is

00:01:51,270 --> 00:01:54,390
provided by your graph Gill server

00:01:52,530 --> 00:01:57,840
you know what the types of all those

00:01:54,390 --> 00:01:59,250
fields should be right so what I've

00:01:57,840 --> 00:02:00,930
actually focused on is actually working

00:01:59,250 --> 00:02:04,590
on the flow and typescript targets for

00:02:00,930 --> 00:02:05,910
Apollo code gen and I don't really want

00:02:04,590 --> 00:02:07,770
to go into too much detail about how

00:02:05,910 --> 00:02:09,420
this works under the hood but basically

00:02:07,770 --> 00:02:13,680
if you have queries in your applications

00:02:09,420 --> 00:02:14,909
that look like this we generate a type

00:02:13,680 --> 00:02:16,170
definition file that looks like this

00:02:14,909 --> 00:02:17,690
that you can then use within your

00:02:16,170 --> 00:02:21,630
applique

00:02:17,690 --> 00:02:23,250
right so that's kind of cool but why use

00:02:21,630 --> 00:02:24,840
a poly cogent why I add this tool to my

00:02:23,250 --> 00:02:27,840
application it just gonna make things

00:02:24,840 --> 00:02:30,270
more confusing and I want to kind of

00:02:27,840 --> 00:02:35,150
explain this first by talking a little

00:02:30,270 --> 00:02:38,069
bit about JSON right so on one hand

00:02:35,150 --> 00:02:40,620
we've been using JSON forever right and

00:02:38,069 --> 00:02:41,850
we actually love love JSON actually one

00:02:40,620 --> 00:02:44,190
of the first demos that I saw about

00:02:41,850 --> 00:02:46,709
graph QL was that you could send it JSON

00:02:44,190 --> 00:02:50,100
like document and get JSON back and that

00:02:46,709 --> 00:02:52,230
was awesome but on the other hand we

00:02:50,100 --> 00:02:54,180
lose type information with JSON right we

00:02:52,230 --> 00:02:55,860
lose the village we lose information the

00:02:54,180 --> 00:02:59,100
type relationship information between

00:02:55,860 --> 00:03:00,269
our data objects and so I kind of like

00:02:59,100 --> 00:03:02,280
to think about this as look like you're

00:03:00,269 --> 00:03:04,680
reading an abridged book you kind of

00:03:02,280 --> 00:03:06,000
understand what's going on but you don't

00:03:04,680 --> 00:03:09,480
really understand in a degraded details

00:03:06,000 --> 00:03:10,860
anymore so why is this a problem I think

00:03:09,480 --> 00:03:13,140
this is best demonstrated by going

00:03:10,860 --> 00:03:15,090
through kind of an example let's say

00:03:13,140 --> 00:03:16,860
that I wanted to create an episode hero

00:03:15,090 --> 00:03:18,180
display component that looked something

00:03:16,860 --> 00:03:21,630
like this

00:03:18,180 --> 00:03:24,299
very simple it displays the name of our

00:03:21,630 --> 00:03:29,430
hero per episode and the origin of that

00:03:24,299 --> 00:03:30,720
hero right and there's also like we were

00:03:29,430 --> 00:03:32,880
provided with this magic function that

00:03:30,720 --> 00:03:34,440
somehow does something to this origin

00:03:32,880 --> 00:03:36,360
value that we have and we're just

00:03:34,440 --> 00:03:38,540
expected to use it it takes a string and

00:03:36,360 --> 00:03:41,070
then return something that's renderable

00:03:38,540 --> 00:03:43,200
so to start on this task you might look

00:03:41,070 --> 00:03:44,519
into our resolvers and our schema we see

00:03:43,200 --> 00:03:49,290
this resolver that we want a hero

00:03:44,519 --> 00:03:51,000
resolver and we notice that the input to

00:03:49,290 --> 00:03:52,680
this resolver is an episode in episode

00:03:51,000 --> 00:03:55,019
as a enum right and then it returns a

00:03:52,680 --> 00:03:57,540
character of some sort we might also

00:03:55,019 --> 00:04:00,209
notice that for all the return values

00:03:57,540 --> 00:04:01,530
here they're all human right so we might

00:04:00,209 --> 00:04:02,459
notice that there's this this is there

00:04:01,530 --> 00:04:05,040
might be this relationship between

00:04:02,459 --> 00:04:06,239
characters and humans so we dig into our

00:04:05,040 --> 00:04:08,160
schema and we noticed that there's

00:04:06,239 --> 00:04:09,470
actually a character interface and there

00:04:08,160 --> 00:04:13,170
are two implementations of character

00:04:09,470 --> 00:04:16,200
right so this is cool I'm gonna actually

00:04:13,170 --> 00:04:18,959
go on and start implementing one nice

00:04:16,200 --> 00:04:20,370
look like this so what we might end up

00:04:18,959 --> 00:04:22,560
doing is then writing our kind of you

00:04:20,370 --> 00:04:24,930
writing a quick query to get all the

00:04:22,560 --> 00:04:27,030
information that we need we need the

00:04:24,930 --> 00:04:28,500
name right leia organa and we need her

00:04:27,030 --> 00:04:30,699
origin which is her home planet so we

00:04:28,500 --> 00:04:32,710
write an inline fragment

00:04:30,699 --> 00:04:35,830
with the human type condition and fetch

00:04:32,710 --> 00:04:36,910
the home planet we throw all the

00:04:35,830 --> 00:04:38,380
episodes we know that exist on this

00:04:36,910 --> 00:04:40,419
resolver into this and we get back our

00:04:38,380 --> 00:04:42,280
JSON I'm really cool we kind of

00:04:40,419 --> 00:04:45,130
understand what we're doing here and

00:04:42,280 --> 00:04:47,770
then we write our component right very

00:04:45,130 --> 00:04:49,330
simple there's two things being

00:04:47,770 --> 00:04:51,430
displayed here the named origin and we

00:04:49,330 --> 00:04:55,000
kind of as I said before we passed the

00:04:51,430 --> 00:04:56,710
home planet into this magic function so

00:04:55,000 --> 00:04:58,180
we might even QA this and try everything

00:04:56,710 --> 00:05:00,130
again in production and everything looks

00:04:58,180 --> 00:05:03,280
good so we commit our code deploy it and

00:05:00,130 --> 00:05:06,850
move on but we made a mistake here right

00:05:03,280 --> 00:05:09,250
because in our back end we had actually

00:05:06,850 --> 00:05:11,050
said that something that the this

00:05:09,250 --> 00:05:12,910
resolved returns any sort of character

00:05:11,050 --> 00:05:15,060
right and humans aren't the only kinds

00:05:12,910 --> 00:05:17,470
of characters so if someone came in and

00:05:15,060 --> 00:05:18,210
modified our this resolver to return our

00:05:17,470 --> 00:05:20,560
droid

00:05:18,210 --> 00:05:22,030
this wouldn't be a breaking change of

00:05:20,560 --> 00:05:26,979
any sort but it's something that would

00:05:22,030 --> 00:05:28,240
go unnoticed so and the droid itself

00:05:26,979 --> 00:05:31,389
doesn't have this home planet field

00:05:28,240 --> 00:05:33,250
right so what happens is someone could

00:05:31,389 --> 00:05:35,650
commit this change to the resolver and

00:05:33,250 --> 00:05:37,240
all of a sudden there's a case where

00:05:35,650 --> 00:05:39,970
your clients will now have a runtime

00:05:37,240 --> 00:05:41,800
error right because here at a home

00:05:39,970 --> 00:05:45,700
planet well doesn't exist for the case

00:05:41,800 --> 00:05:47,050
that the hero's a droid so let's rewind

00:05:45,700 --> 00:05:48,610
right and let's let's see what happens

00:05:47,050 --> 00:05:50,620
when we got add a poly cogent to the mix

00:05:48,610 --> 00:05:54,820
so we had originally written in this

00:05:50,620 --> 00:05:56,470
resolver I started this query and if we

00:05:54,820 --> 00:05:58,150
actually run a poly code gen it would

00:05:56,470 --> 00:06:00,160
generate a type of the type signature

00:05:58,150 --> 00:06:02,440
look something like this right and this

00:06:00,160 --> 00:06:04,900
matched very well with the actual query

00:06:02,440 --> 00:06:06,700
that we wrote there are two there are

00:06:04,900 --> 00:06:08,710
two possible types here I'm just human

00:06:06,700 --> 00:06:10,030
Android and humans have a name and since

00:06:08,710 --> 00:06:12,990
we have that in line fragment on human

00:06:10,030 --> 00:06:14,979
we get the home planet field there but

00:06:12,990 --> 00:06:17,550
for joyed itself we only get the name

00:06:14,979 --> 00:06:20,380
field so if we actually then annotate

00:06:17,550 --> 00:06:22,780
our component with this type that we got

00:06:20,380 --> 00:06:24,970
then and we run our type checker right

00:06:22,780 --> 00:06:26,500
then we would actually see right away

00:06:24,970 --> 00:06:29,919
that hey there is an error here right we

00:06:26,500 --> 00:06:32,590
missed this case before and again we

00:06:29,919 --> 00:06:34,240
missed the case where hero itself is a

00:06:32,590 --> 00:06:38,770
droid because there's no home planet

00:06:34,240 --> 00:06:40,060
filled on droid so as we go as we see

00:06:38,770 --> 00:06:41,979
this we can go ahead and fix it and say

00:06:40,060 --> 00:06:43,840
okay actually for the origin for droid

00:06:41,979 --> 00:06:45,330
we want the actual creator so we can

00:06:43,840 --> 00:06:48,370
modify our query to pull that in and

00:06:45,330 --> 00:06:50,800
then rerun a Polock Oh gem to regenerate

00:06:48,370 --> 00:06:52,330
these types right and then we'll notice

00:06:50,800 --> 00:06:54,669
that hey this is a disjoint union that

00:06:52,330 --> 00:06:56,500
we need to handle so we can just go

00:06:54,669 --> 00:06:57,970
ahead and modify our code and so then

00:06:56,500 --> 00:06:59,979
we're handling all the possible cases

00:06:57,970 --> 00:07:03,610
here given the types that were specified

00:06:59,979 --> 00:07:04,630
in a graphical schema and then if we

00:07:03,610 --> 00:07:07,060
were to run the type checker itself

00:07:04,630 --> 00:07:09,250
again we would get no errors right so

00:07:07,060 --> 00:07:11,199
this all happens at the really beginning

00:07:09,250 --> 00:07:13,780
then someone else can come along and add

00:07:11,199 --> 00:07:16,120
this add this new episode where it

00:07:13,780 --> 00:07:18,250
returns a droid hero and it's not a big

00:07:16,120 --> 00:07:20,830
deal right nothing breaks because we're

00:07:18,250 --> 00:07:22,780
good because we have the types defined

00:07:20,830 --> 00:07:25,780
in the schema itself propagating all the

00:07:22,780 --> 00:07:26,830
way to our clients and we satisfied all

00:07:25,780 --> 00:07:29,500
Danny's defined by those type

00:07:26,830 --> 00:07:31,570
definitions so there's another thing

00:07:29,500 --> 00:07:32,440
that I wanted to go over right this is

00:07:31,570 --> 00:07:35,110
the oh that field is an allowable

00:07:32,440 --> 00:07:37,210
problem and this usually crops up in

00:07:35,110 --> 00:07:38,350
your applications when you get a runtime

00:07:37,210 --> 00:07:40,120
error productions that looks something

00:07:38,350 --> 00:07:44,080
like this right cannot read property of

00:07:40,120 --> 00:07:46,600
something of no and I saw this happen

00:07:44,080 --> 00:07:47,860
the first time at Coursera when someone

00:07:46,600 --> 00:07:50,229
wrote what looks like a harmless query

00:07:47,860 --> 00:07:51,460
looks something like this and they wrote

00:07:50,229 --> 00:07:53,740
code that looked like this that looks

00:07:51,460 --> 00:07:55,600
very harmless but what they forgot to do

00:07:53,740 --> 00:07:58,300
was actually check the schema and

00:07:55,600 --> 00:07:59,830
understand that that starship field is

00:07:58,300 --> 00:08:02,349
not marked not null so it's possibly

00:07:59,830 --> 00:08:05,050
knowable right so if you're to actually

00:08:02,349 --> 00:08:06,550
run code gen Apollo code gen you would

00:08:05,050 --> 00:08:10,270
see that the type signature for this

00:08:06,550 --> 00:08:12,099
actually looks like this right so if

00:08:10,270 --> 00:08:15,849
you're then annotate that variable with

00:08:12,099 --> 00:08:18,160
this type you would when you write this

00:08:15,849 --> 00:08:19,450
code here it would and then you bring

00:08:18,160 --> 00:08:21,700
your type checker you would then see

00:08:19,450 --> 00:08:22,660
that the starship itself could be like

00:08:21,700 --> 00:08:27,700
there's something wrong here right you

00:08:22,660 --> 00:08:29,710
need to fix this so this is the benefits

00:08:27,700 --> 00:08:31,599
of kind of having a system that is able

00:08:29,710 --> 00:08:33,729
to generate that's able to bridge

00:08:31,599 --> 00:08:35,589
different types of sums you get all

00:08:33,729 --> 00:08:37,750
these guarantees at compile time rather

00:08:35,589 --> 00:08:40,000
than waiting for a runtime error to

00:08:37,750 --> 00:08:42,130
occur right and another thing that I

00:08:40,000 --> 00:08:43,599
wanted to bring up is that types can

00:08:42,130 --> 00:08:46,060
sometimes be confusing for humans right

00:08:43,599 --> 00:08:48,430
are the tools that we build will always

00:08:46,060 --> 00:08:50,440
get these right because if you only had

00:08:48,430 --> 00:08:51,670
to write it once and test it once but if

00:08:50,440 --> 00:08:54,100
we're trying to read these types and

00:08:51,670 --> 00:08:57,320
understand them we can make mistakes so

00:08:54,100 --> 00:08:59,810
for instance here are four examples of

00:08:57,320 --> 00:09:02,420
different kinds of lists of friends

00:08:59,810 --> 00:09:04,519
right and if you were to use interact

00:09:02,420 --> 00:09:08,180
with these incorrectly then that could

00:09:04,519 --> 00:09:10,100
be another error with no ability and

00:09:08,180 --> 00:09:11,959
actually this is how you'd actually

00:09:10,100 --> 00:09:16,550
convert these to like a kind of like

00:09:11,959 --> 00:09:18,079
flow type definition in this case and so

00:09:16,550 --> 00:09:19,790
if you let the tool do this for you then

00:09:18,079 --> 00:09:20,870
you never have to do this and you can

00:09:19,790 --> 00:09:23,839
always make sure that if you're using

00:09:20,870 --> 00:09:25,399
these types your when you interact with

00:09:23,839 --> 00:09:28,759
this data that you'll always get it

00:09:25,399 --> 00:09:31,910
right so you might be saying that like

00:09:28,759 --> 00:09:33,139
okay I actually reference the graphical

00:09:31,910 --> 00:09:34,490
schema all the time as I'm writing my

00:09:33,139 --> 00:09:36,350
front ends I don't usually make mistakes

00:09:34,490 --> 00:09:38,029
like this and what I want to say is all

00:09:36,350 --> 00:09:40,850
queries can get really complex right

00:09:38,029 --> 00:09:42,589
especially when your apps get big and

00:09:40,850 --> 00:09:44,899
the previous examples I showed really

00:09:42,589 --> 00:09:46,370
just one field or one simple query it's

00:09:44,899 --> 00:09:48,259
very possible to end up with the query

00:09:46,370 --> 00:09:50,360
that looks something like this right and

00:09:48,259 --> 00:09:51,829
every single ones of these fields could

00:09:50,360 --> 00:09:54,130
be a point of failure right a point

00:09:51,829 --> 00:09:57,860
where you or you make a human error and

00:09:54,130 --> 00:09:59,209
so if we're what we can actually do is

00:09:57,860 --> 00:10:01,459
then just make sure that we're using

00:09:59,209 --> 00:10:03,560
generated types right that way we let

00:10:01,459 --> 00:10:05,690
the tools do these decisions for us they

00:10:03,560 --> 00:10:07,100
tell us right away whether or not we're

00:10:05,690 --> 00:10:08,769
doing something wrong and so if we can

00:10:07,100 --> 00:10:13,339
remove that from our mental headspace

00:10:08,769 --> 00:10:15,290
and so how do you actually use a poly

00:10:13,339 --> 00:10:17,110
cogent today and it's actually very

00:10:15,290 --> 00:10:20,209
simple if you're already using a

00:10:17,110 --> 00:10:21,920
language like flow or typescript really

00:10:20,209 --> 00:10:25,010
all it is is three more commands to add

00:10:21,920 --> 00:10:26,870
a poly code gen the three commands are

00:10:25,010 --> 00:10:30,620
globally installed a poly cogent using

00:10:26,870 --> 00:10:32,839
yarn or NPM then we actually need you to

00:10:30,620 --> 00:10:34,399
download your introspection schema so

00:10:32,839 --> 00:10:36,260
that it's available locally a poly

00:10:34,399 --> 00:10:38,930
cogent provides a command to do this for

00:10:36,260 --> 00:10:41,000
you and then there's just a generate

00:10:38,930 --> 00:10:44,209
command for you point you provide a glob

00:10:41,000 --> 00:10:45,949
pattern that points to where your

00:10:44,209 --> 00:10:49,069
graphic UL operations and fragments are

00:10:45,949 --> 00:10:50,510
you point it you point poly cogent to

00:10:49,069 --> 00:10:52,790
where your schema is and then you

00:10:50,510 --> 00:10:55,250
specify the target right so here are

00:10:52,790 --> 00:10:59,209
specified flow if you use typescript

00:10:55,250 --> 00:11:00,290
then you can just specify typescript and

00:10:59,209 --> 00:11:03,079
so if you want more information about

00:11:00,290 --> 00:11:05,389
this or if you want to get some

00:11:03,079 --> 00:11:08,060
information about like where this

00:11:05,389 --> 00:11:10,100
project is going it exists here I'm

00:11:08,060 --> 00:11:10,890
github at a polygraph ql / epaulet

00:11:10,100 --> 00:11:12,060
cogent

00:11:10,890 --> 00:11:13,200
if you have any questions if you want to

00:11:12,060 --> 00:11:17,220
integrate this with your application

00:11:13,200 --> 00:11:18,540
today feel free to come to the Apollo

00:11:17,220 --> 00:11:20,520
graphic you'll slack and join the Apollo

00:11:18,540 --> 00:11:21,840
code in channel and we're super happy to

00:11:20,520 --> 00:11:23,610
answer any questions you might have and

00:11:21,840 --> 00:11:25,200
the last thing I want to mention is that

00:11:23,610 --> 00:11:26,820
Apollo code gen 1 is actually in the

00:11:25,200 --> 00:11:29,130
works right now and we're not at one

00:11:26,820 --> 00:11:31,260
point out yet but we have a lot of cool

00:11:29,130 --> 00:11:33,720
changes that we want to make happen

00:11:31,260 --> 00:11:35,940
before we declare a stable release so if

00:11:33,720 --> 00:11:38,790
you're really interested in that again

00:11:35,940 --> 00:11:40,410
go to the slack channel also it might be

00:11:38,790 --> 00:11:43,620
scary to like use the poly code gen now

00:11:40,410 --> 00:11:45,060
if 1.0 is coming out later I guarantee

00:11:43,620 --> 00:11:46,590
that if we make any braking changes to

00:11:45,060 --> 00:11:50,670
what currently exists we will provide a

00:11:46,590 --> 00:11:51,540
detailed migration guide so that's all I

00:11:50,670 --> 00:11:58,630
got thanks everybody

00:11:51,540 --> 00:11:58,630

YouTube URL: https://www.youtube.com/watch?v=JcMhqrZG7nM


