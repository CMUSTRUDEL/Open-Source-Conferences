Title: Peggy Rayzis - Apollo Client 2.0: More than just GraphQL
Publication date: 2017-11-08
Playlist: GraphQL Summit 2017
Description: 
	Peggy Rayzis, Open Source Engineer at Apollo, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

Wouldn't it be awesome if you could use Apollo to manage all of your data, not just the data coming from your GraphQL server? With the new version of Apollo Client, now you can! In this talk, you'll take a deep dive into the internals of Apollo Client 2.0, including our new modular architecture that allows you to swap out your cache & network stack seamlessly. You'll also learn about how our new architecture enables you to use Apollo Client to manage all of your application's data, including local data & REST data.

See her slides here: http://gqlsummit-more-than-gql.surge.sh/#/
Captions: 
	00:00:03,420 --> 00:00:10,210
alright how's everyone doing today

00:00:05,470 --> 00:00:13,809
pretty good awesome well I love this

00:00:10,210 --> 00:00:16,990
community so much that I took a train

00:00:13,809 --> 00:00:19,600
from Bratislava to Prague a flight from

00:00:16,990 --> 00:00:22,180
Prague to Frankfurt and another flight

00:00:19,600 --> 00:00:24,160
from Frankfurt to San Francisco all

00:00:22,180 --> 00:00:31,150
within the span of 24 hours to hang out

00:00:24,160 --> 00:00:33,190
with that you all today so I am thank

00:00:31,150 --> 00:00:34,750
you so much yeah it's it's been a it's

00:00:33,190 --> 00:00:36,940
been a wild ride but I'm thrilled to be

00:00:34,750 --> 00:00:39,100
here and give a little deep dive into

00:00:36,940 --> 00:00:41,440
Apollo client 2.0 and also what we have

00:00:39,100 --> 00:00:44,559
planned for the future so without

00:00:41,440 --> 00:00:46,719
further ado my name is Peggy raises and

00:00:44,559 --> 00:00:49,239
I am an open source engineer on the

00:00:46,719 --> 00:00:51,250
Apollo team and also the host of our

00:00:49,239 --> 00:00:53,050
latest video series Apollo mission

00:00:51,250 --> 00:00:54,670
briefing which if you haven't seen on

00:00:53,050 --> 00:00:58,420
YouTube you definitely should check it

00:00:54,670 --> 00:01:00,340
out and hit subscribe so our goal is the

00:00:58,420 --> 00:01:03,219
Apollo team is to make building

00:01:00,340 --> 00:01:05,680
applications simpler and faster with

00:01:03,219 --> 00:01:07,270
graph QL and I think this goal has

00:01:05,680 --> 00:01:09,910
really resonated with the community

00:01:07,270 --> 00:01:13,240
we've seen astounding growth over the

00:01:09,910 --> 00:01:16,390
past year resulting in over 2.5 million

00:01:13,240 --> 00:01:18,610
NPM downloads and almost 5,000 stars on

00:01:16,390 --> 00:01:21,310
github for a most popular tool Apollo

00:01:18,610 --> 00:01:24,160
client it is also the most widely used

00:01:21,310 --> 00:01:27,910
graph QL client in the ecosystem today

00:01:24,160 --> 00:01:30,190
and I think one of the reasons we've had

00:01:27,910 --> 00:01:32,860
so much success is because building your

00:01:30,190 --> 00:01:35,820
application with Apollo client removes a

00:01:32,860 --> 00:01:38,260
ton of complexity on the front end and

00:01:35,820 --> 00:01:40,720
really all you have to do is just

00:01:38,260 --> 00:01:44,530
describe exactly the data that you want

00:01:40,720 --> 00:01:46,420
with graph QL and to use that data you

00:01:44,530 --> 00:01:49,840
just bind the query to your component

00:01:46,420 --> 00:01:51,880
and forget about the rest now I'm not

00:01:49,840 --> 00:01:54,190
trying to make a cheap shot on rest here

00:01:51,880 --> 00:01:57,010
what I'm really referring to is all the

00:01:54,190 --> 00:01:58,990
rest of the things associated with data

00:01:57,010 --> 00:02:01,350
management that you don't have to worry

00:01:58,990 --> 00:02:04,360
about so forget about fetching the data

00:02:01,350 --> 00:02:05,620
transforming the response normalizing it

00:02:04,360 --> 00:02:07,600
caching it

00:02:05,620 --> 00:02:09,250
Apollo client does all of that for you

00:02:07,600 --> 00:02:13,570
and that's what we're going to be

00:02:09,250 --> 00:02:15,400
talking about today another thing that I

00:02:13,570 --> 00:02:17,020
want to point out about Apollo client is

00:02:15,400 --> 00:02:18,760
that it's not just react

00:02:17,020 --> 00:02:20,770
developers who can take advantage of all

00:02:18,760 --> 00:02:23,050
the amazing features Apollo client has

00:02:20,770 --> 00:02:25,690
to offer the client is actually

00:02:23,050 --> 00:02:27,640
decoupled from the view layer so angular

00:02:25,690 --> 00:02:30,760
and view developers can also join in on

00:02:27,640 --> 00:02:33,250
the fun and everything I'm about to tell

00:02:30,760 --> 00:02:35,470
you for Apollo client is the same for

00:02:33,250 --> 00:02:37,270
all three frameworks the only difference

00:02:35,470 --> 00:02:41,380
here is really just how you bind your

00:02:37,270 --> 00:02:43,450
queries to your components we talked a

00:02:41,380 --> 00:02:45,010
lot to our community members and one of

00:02:43,450 --> 00:02:47,230
the common themes that we can pull out

00:02:45,010 --> 00:02:49,600
from their experiences working with

00:02:47,230 --> 00:02:53,380
Apollo client is that it allows them to

00:02:49,600 --> 00:02:55,270
do more with way less code and before I

00:02:53,380 --> 00:02:57,640
started working at Apollo I was actually

00:02:55,270 --> 00:03:00,040
an engineer at major league soccer and

00:02:57,640 --> 00:03:03,250
wrote about our experience switching

00:03:00,040 --> 00:03:05,380
from Redux to Apollo and offloading data

00:03:03,250 --> 00:03:07,870
management to Apollo allowed us to

00:03:05,380 --> 00:03:09,730
delete nearly all of our Redux code

00:03:07,870 --> 00:03:12,100
which removed a ton of complexity from

00:03:09,730 --> 00:03:14,170
our application instead of writing

00:03:12,100 --> 00:03:16,330
countless lines of boilerplate we just

00:03:14,170 --> 00:03:19,360
wrote queries and let Apollo take care

00:03:16,330 --> 00:03:21,580
of the rest not only do you have to

00:03:19,360 --> 00:03:23,680
write less data management code you also

00:03:21,580 --> 00:03:27,160
can accomplish complicated features like

00:03:23,680 --> 00:03:29,110
pagination optimistic UI pulling and

00:03:27,160 --> 00:03:33,610
prefetching data with far less code than

00:03:29,110 --> 00:03:35,560
you would normally have to additionally

00:03:33,610 --> 00:03:38,110
one of the best features of Apollo is

00:03:35,560 --> 00:03:40,540
that it caches your data for you let's

00:03:38,110 --> 00:03:43,510
break down what actually happens here so

00:03:40,540 --> 00:03:46,060
from your UI you send a query then

00:03:43,510 --> 00:03:47,800
Apollo processes that query by adding

00:03:46,060 --> 00:03:49,590
fields like type name and omitting any

00:03:47,800 --> 00:03:52,360
fields that are already in the store

00:03:49,590 --> 00:03:54,670
then Apollo fetches the data from your

00:03:52,360 --> 00:03:57,370
graph QL server and then once the data

00:03:54,670 --> 00:03:59,980
comes back apollo normalizes the data

00:03:57,370 --> 00:04:04,630
for you stores it and then pushes the

00:03:59,980 --> 00:04:06,520
result back to your UI so what does it

00:04:04,630 --> 00:04:09,340
actually mean when I say that Apollo

00:04:06,520 --> 00:04:11,440
normalizes your data for you so first

00:04:09,340 --> 00:04:13,330
just picture like a query in your head

00:04:11,440 --> 00:04:15,520
it's all nested and we split each part

00:04:13,330 --> 00:04:18,190
of the query into its own object and

00:04:15,520 --> 00:04:20,650
then we assign it a unique identifier so

00:04:18,190 --> 00:04:23,440
in the example here you can see we have

00:04:20,650 --> 00:04:26,440
like entry 1 and comment one and this

00:04:23,440 --> 00:04:28,660
identifier is used as a pointer between

00:04:26,440 --> 00:04:30,780
child nodes and its parent so you can

00:04:28,660 --> 00:04:33,570
kind of see comment 1 under and

00:04:30,780 --> 00:04:35,250
in the example there so then we store

00:04:33,570 --> 00:04:37,410
each object in a flattened data

00:04:35,250 --> 00:04:38,370
structure and before we send the data

00:04:37,410 --> 00:04:40,320
back to the client

00:04:38,370 --> 00:04:44,910
we then piece together the shape of the

00:04:40,320 --> 00:04:47,160
query and okay this sounds like a lot of

00:04:44,910 --> 00:04:49,110
work why do we do this the reason why is

00:04:47,160 --> 00:04:51,240
because multiple queries can sometimes

00:04:49,110 --> 00:04:54,300
share the same data so in this example

00:04:51,240 --> 00:04:56,700
if we add a comment to entry one we want

00:04:54,300 --> 00:04:59,810
all the other queries you also use entry

00:04:56,700 --> 00:05:03,420
one to update reactively so maybe we're

00:04:59,810 --> 00:05:05,550
pulling the top query or the feed query

00:05:03,420 --> 00:05:07,770
either way we want all references to

00:05:05,550 --> 00:05:12,360
entry one to be updated with the new

00:05:07,770 --> 00:05:14,040
comment count so if we all have these

00:05:12,360 --> 00:05:15,810
great features and our developers are

00:05:14,040 --> 00:05:18,270
really happy working with Apollo client

00:05:15,810 --> 00:05:20,910
why did we decide to release a 2.0

00:05:18,270 --> 00:05:22,650
version my coworker James did a really

00:05:20,910 --> 00:05:24,750
excellent job explaining all the

00:05:22,650 --> 00:05:26,760
motivations to you yesterday so I'm not

00:05:24,750 --> 00:05:28,320
going to go into too much detail but one

00:05:26,760 --> 00:05:31,440
of the main reasons is because we're

00:05:28,320 --> 00:05:33,600
looking to the future of graph QL we

00:05:31,440 --> 00:05:35,460
needed a more modular architecture to

00:05:33,600 --> 00:05:38,340
support things like streaming data and

00:05:35,460 --> 00:05:41,400
resolving from sources beyond a graph QL

00:05:38,340 --> 00:05:43,140
server we're really proud of how we were

00:05:41,400 --> 00:05:45,840
able to achieve that with Apollo quiet

00:05:43,140 --> 00:05:50,790
2.0 well building a smaller faster

00:05:45,840 --> 00:05:52,800
client with minimal breaking changes so

00:05:50,790 --> 00:05:55,260
let's dive into the internals of the

00:05:52,800 --> 00:05:58,770
client even further so first we have our

00:05:55,260 --> 00:06:00,900
cache and in 2.0 you can actually swap

00:05:58,770 --> 00:06:03,690
out the default in-memory cache with a

00:06:00,900 --> 00:06:06,000
custom one if you want the new in-memory

00:06:03,690 --> 00:06:08,400
cache which is our default is also not

00:06:06,000 --> 00:06:09,930
dependent on redux anymore so this will

00:06:08,400 --> 00:06:11,700
allow you to plug in a cache with a

00:06:09,930 --> 00:06:14,070
different state Y state management

00:06:11,700 --> 00:06:17,220
library for example mob X if you really

00:06:14,070 --> 00:06:19,980
want to and we also have our new network

00:06:17,220 --> 00:06:22,380
stack so our new interface for

00:06:19,980 --> 00:06:25,080
customizing the network stack is Apollo

00:06:22,380 --> 00:06:27,600
link and it's a super powerful way to

00:06:25,080 --> 00:06:30,990
hook into the request cycle at any point

00:06:27,600 --> 00:06:33,120
to process or retrieve your data it's

00:06:30,990 --> 00:06:34,920
also powered by observables instead of

00:06:33,120 --> 00:06:37,770
promises so you're no longer tied to

00:06:34,920 --> 00:06:39,690
returning a single value and then

00:06:37,770 --> 00:06:42,150
wrapping that all together on the top

00:06:39,690 --> 00:06:44,400
level itself you have Apollo client

00:06:42,150 --> 00:06:47,120
which is just a thin orchestration layer

00:06:44,400 --> 00:06:51,030
between the network stack and the cash

00:06:47,120 --> 00:06:52,440
in fact we already have an alternative

00:06:51,030 --> 00:06:54,690
cash you can choose from

00:06:52,440 --> 00:06:56,910
it's called Hermes and it's built by an

00:06:54,690 --> 00:07:00,180
McCleod and the amazingly talented team

00:06:56,910 --> 00:07:01,830
at convoy since convoys payloads were

00:07:00,180 --> 00:07:04,470
very large and nested they were

00:07:01,830 --> 00:07:06,510
experiencing slow reads and writes due

00:07:04,470 --> 00:07:09,120
to apollo's normalization process that

00:07:06,510 --> 00:07:11,580
we talked about earlier they opted to

00:07:09,120 --> 00:07:13,770
build a graph based cache instead that

00:07:11,580 --> 00:07:16,080
used references instead of an identity

00:07:13,770 --> 00:07:19,560
map so they didn't have to reconstruct

00:07:16,080 --> 00:07:21,389
the shape of the result each time they

00:07:19,560 --> 00:07:23,639
fetched it which resulted in a

00:07:21,389 --> 00:07:26,340
significant improvement for cache reads

00:07:23,639 --> 00:07:27,930
now I think this story is really cool it

00:07:26,340 --> 00:07:30,090
speaks to the power of the modular

00:07:27,930 --> 00:07:32,220
architecture of Apollo client 2.0 and

00:07:30,090 --> 00:07:34,860
also the strength of our community if

00:07:32,220 --> 00:07:36,479
you have an idea you you really can

00:07:34,860 --> 00:07:38,580
build it and I think we'll see a lot

00:07:36,479 --> 00:07:41,990
more of these custom caches for things

00:07:38,580 --> 00:07:44,610
like local storage and the weeks to come

00:07:41,990 --> 00:07:47,520
so let's circle back to our network

00:07:44,610 --> 00:07:49,410
stack Apollo link and I am super excited

00:07:47,520 --> 00:07:51,690
for link because I really think it's

00:07:49,410 --> 00:07:54,900
going to revolutionize how we use graph

00:07:51,690 --> 00:07:57,479
QL to retrieve and process data and our

00:07:54,900 --> 00:07:59,520
applications you can kind of think of

00:07:57,479 --> 00:08:01,830
links like react components for your

00:07:59,520 --> 00:08:04,560
data because you can compose them and

00:08:01,830 --> 00:08:06,660
chain them together they make it really

00:08:04,560 --> 00:08:08,610
easy to customize the control flow in

00:08:06,660 --> 00:08:12,720
your application because you can hook

00:08:08,610 --> 00:08:14,160
into the request cycle at any point so

00:08:12,720 --> 00:08:17,130
let's take a look at what this looks

00:08:14,160 --> 00:08:18,090
like here we're using an HTTP link to

00:08:17,130 --> 00:08:20,639
retrieve our data

00:08:18,090 --> 00:08:22,680
we're also chaining on a retry link

00:08:20,639 --> 00:08:25,440
which will retry the request on an

00:08:22,680 --> 00:08:27,750
interval if it happens to fail to chain

00:08:25,440 --> 00:08:29,789
them together you use the from method on

00:08:27,750 --> 00:08:32,219
the Apollo link class which takes an

00:08:29,789 --> 00:08:35,729
array of links that then concatenates it

00:08:32,219 --> 00:08:38,459
together so now let's look at a more

00:08:35,729 --> 00:08:41,130
complex example here we're using Apollo

00:08:38,459 --> 00:08:43,169
link split which takes a function and

00:08:41,130 --> 00:08:47,459
then branches the control flow depending

00:08:43,169 --> 00:08:49,500
on the result so here's a pretty simin

00:08:47,459 --> 00:08:52,040
use case here we're looking to see if

00:08:49,500 --> 00:08:55,350
our graph QL operation is a subscription

00:08:52,040 --> 00:08:55,920
so if it is we're using the WebSocket

00:08:55,350 --> 00:08:57,839
link to

00:08:55,920 --> 00:09:00,000
the request over sockets and if it's a

00:08:57,839 --> 00:09:03,120
query or mutation we're then sending the

00:09:00,000 --> 00:09:08,579
request over HTTP using our basic HTTP

00:09:03,120 --> 00:09:10,620
link so links can either be terminating

00:09:08,579 --> 00:09:12,510
which means they retrieve data so that's

00:09:10,620 --> 00:09:14,820
things like our HTTP link and our

00:09:12,510 --> 00:09:17,160
WebSocket link that we saw earlier or

00:09:14,820 --> 00:09:19,079
non terminating that means they process

00:09:17,160 --> 00:09:21,660
data so that's anything like error

00:09:19,079 --> 00:09:23,880
handling middleware or retrying requests

00:09:21,660 --> 00:09:26,040
and the one thing to note is that your

00:09:23,880 --> 00:09:27,930
terminating link always has to be the

00:09:26,040 --> 00:09:29,850
last link in your chain since it's

00:09:27,930 --> 00:09:34,860
responsible for fulfilling some kind of

00:09:29,850 --> 00:09:36,510
result it's really easy to create your

00:09:34,860 --> 00:09:38,760
own link just by passing a request

00:09:36,510 --> 00:09:41,160
request function into the Apollo link

00:09:38,760 --> 00:09:43,620
constructor the function takes the graph

00:09:41,160 --> 00:09:46,199
QL operation and a forward method and

00:09:43,620 --> 00:09:48,029
returns an observable to continue the

00:09:46,199 --> 00:09:51,000
next link in the chain you have to then

00:09:48,029 --> 00:09:53,250
call forward on the operation I also

00:09:51,000 --> 00:09:55,800
want to point out that all links share

00:09:53,250 --> 00:09:57,360
the same context you can also set

00:09:55,800 --> 00:09:59,070
context from within one of your

00:09:57,360 --> 00:10:01,440
components so it's a really great

00:09:59,070 --> 00:10:03,269
communication strategy from components

00:10:01,440 --> 00:10:05,550
to your network stack and then also

00:10:03,269 --> 00:10:07,110
among links in your network stack since

00:10:05,550 --> 00:10:11,610
they all have access to that same

00:10:07,110 --> 00:10:13,920
context so as you can see links are

00:10:11,610 --> 00:10:15,570
really powerful and since they allow you

00:10:13,920 --> 00:10:17,310
to hook into the request cycle at any

00:10:15,570 --> 00:10:18,990
point you can start to get really

00:10:17,310 --> 00:10:21,600
creative with how you're retrieving and

00:10:18,990 --> 00:10:23,550
what you're doing with your data so the

00:10:21,600 --> 00:10:25,199
next section of this talk is actually my

00:10:23,550 --> 00:10:27,029
favorite part and it's gonna feature

00:10:25,199 --> 00:10:29,670
some really experimental stuff that is

00:10:27,029 --> 00:10:31,440
possible because of links and I think

00:10:29,670 --> 00:10:33,209
James kind of already gave you it's he's

00:10:31,440 --> 00:10:34,860
ur of this yesterday but we're gonna

00:10:33,209 --> 00:10:40,589
dive a little deeper so who's ready to

00:10:34,860 --> 00:10:42,390
get weird so remember we had the diagram

00:10:40,589 --> 00:10:45,180
earlier where data was being loaded from

00:10:42,390 --> 00:10:47,160
a graph QL server well what if we could

00:10:45,180 --> 00:10:49,709
switch that data out with I mean

00:10:47,160 --> 00:10:51,600
anything else since Apollo links hook

00:10:49,709 --> 00:10:53,699
into the request cycle at any point as

00:10:51,600 --> 00:10:56,310
long as the data that's coming back is

00:10:53,699 --> 00:10:58,800
JSON or an object you should be able to

00:10:56,310 --> 00:11:03,060
query your source with graph QL and get

00:10:58,800 --> 00:11:05,160
back whatever you want so this opens up

00:11:03,060 --> 00:11:07,980
the door to a really interesting use

00:11:05,160 --> 00:11:09,300
case so what if you could query local

00:11:07,980 --> 00:11:11,490
data in your Apple

00:11:09,300 --> 00:11:13,380
things like network status things like

00:11:11,490 --> 00:11:16,740
routing things that you already use

00:11:13,380 --> 00:11:19,500
Redux or mob x4 and then store it in

00:11:16,740 --> 00:11:21,449
Apollo client this way you get the same

00:11:19,500 --> 00:11:23,160
caching benefit so you get the ease of

00:11:21,449 --> 00:11:24,630
querying and all the awesome features

00:11:23,160 --> 00:11:26,490
that we talked about earlier that

00:11:24,630 --> 00:11:28,800
already come built-in to Apollo client

00:11:26,490 --> 00:11:33,600
without having to setup a second store

00:11:28,800 --> 00:11:35,730
or maintain it yourself it turns out

00:11:33,600 --> 00:11:37,680
that graph QL is a perfect fit for

00:11:35,730 --> 00:11:40,050
expressing what's happening with our

00:11:37,680 --> 00:11:41,550
application state so let's look at an

00:11:40,050 --> 00:11:42,660
example with a network status so we're

00:11:41,550 --> 00:11:43,800
going to be using this example

00:11:42,660 --> 00:11:45,839
throughout the next couple of slides

00:11:43,800 --> 00:11:47,130
it's a pretty common thing you're gonna

00:11:45,839 --> 00:11:49,079
have to do in your application to

00:11:47,130 --> 00:11:53,010
determine whether the users device is

00:11:49,079 --> 00:11:55,470
online or offline and to update this we

00:11:53,010 --> 00:11:57,240
can use a mutation so use this

00:11:55,470 --> 00:11:59,279
information and our components we can

00:11:57,240 --> 00:12:01,560
then write a query to read from the

00:11:59,279 --> 00:12:03,449
store and when that network status

00:12:01,560 --> 00:12:05,160
updates we want all the components who

00:12:03,449 --> 00:12:09,149
query that data to then reactively

00:12:05,160 --> 00:12:11,250
update so not a lot of people know this

00:12:09,149 --> 00:12:14,100
but it turns out you can already query

00:12:11,250 --> 00:12:16,860
and store local data and Apollo just by

00:12:14,100 --> 00:12:18,990
directs directly accessing the cache so

00:12:16,860 --> 00:12:20,970
here in this example we're using the

00:12:18,990 --> 00:12:22,920
network query from the previous slide to

00:12:20,970 --> 00:12:25,620
update Apollo client when the network

00:12:22,920 --> 00:12:27,630
status changes so another component

00:12:25,620 --> 00:12:30,209
which you can see in the top left that's

00:12:27,630 --> 00:12:31,949
that 'get hunt is offline component is

00:12:30,209 --> 00:12:34,019
able to query the information from the

00:12:31,949 --> 00:12:35,699
store and display it which receives

00:12:34,019 --> 00:12:39,839
automatic updates when the network

00:12:35,699 --> 00:12:42,810
status changes so let's break down what

00:12:39,839 --> 00:12:44,790
we just saw in code so to perform the

00:12:42,810 --> 00:12:46,649
initial write you will need to use the

00:12:44,790 --> 00:12:49,019
write query method that you can access

00:12:46,649 --> 00:12:51,449
from the client and to use this method

00:12:49,019 --> 00:12:53,069
we then pass in our query and then the

00:12:51,449 --> 00:12:54,779
data that we want to write to the store

00:12:53,069 --> 00:13:00,120
and you only have to call this method

00:12:54,779 --> 00:13:02,430
once for the initial write to update the

00:13:00,120 --> 00:13:05,130
data in the store we call update query

00:13:02,430 --> 00:13:08,970
which you get from the data prop exposed

00:13:05,130 --> 00:13:10,769
by react Apollo so what you do here you

00:13:08,970 --> 00:13:12,149
just pass in a function that returns the

00:13:10,769 --> 00:13:15,269
data that you want to update the store

00:13:12,149 --> 00:13:17,250
with and this implementation is ok but

00:13:15,269 --> 00:13:19,079
it's it's a little bit clunky we have

00:13:17,250 --> 00:13:21,089
two higher-order components here and

00:13:19,079 --> 00:13:22,200
we're expressing our updates in terms of

00:13:21,089 --> 00:13:24,570
a query and

00:13:22,200 --> 00:13:27,389
of a mutation which seems more intuitive

00:13:24,570 --> 00:13:29,190
and natural so ideally we we want to

00:13:27,389 --> 00:13:31,230
eliminate these barriers and use

00:13:29,190 --> 00:13:36,120
mutations as a more intuitive way to

00:13:31,230 --> 00:13:38,760
update the store it's our priority to

00:13:36,120 --> 00:13:41,519
make sure you're experiencing managing

00:13:38,760 --> 00:13:44,639
local state and Apollo is as easy as

00:13:41,519 --> 00:13:46,440
possible we want it to be as natural as

00:13:44,639 --> 00:13:49,079
describing your state changes with graph

00:13:46,440 --> 00:13:49,740
QL and letting Apollo client take care

00:13:49,079 --> 00:13:52,709
of the rest

00:13:49,740 --> 00:13:55,380
no more action creators or thousands of

00:13:52,709 --> 00:13:59,430
lines of boilerplate just queries and

00:13:55,380 --> 00:14:02,610
mutations so that's why we're announcing

00:13:59,430 --> 00:14:04,079
Apollo link state I am over the moon

00:14:02,610 --> 00:14:06,000
excited about this one

00:14:04,079 --> 00:14:07,410
it will use a client directive to

00:14:06,000 --> 00:14:09,449
specify the fields that should be

00:14:07,410 --> 00:14:10,949
retrieved from the client and you will

00:14:09,449 --> 00:14:13,560
have the ability to specify custom

00:14:10,949 --> 00:14:16,110
resolvers to determine how data will be

00:14:13,560 --> 00:14:19,320
read and written to the cache and it's

00:14:16,110 --> 00:14:22,110
coming really soon so let's take a look

00:14:19,320 --> 00:14:24,029
at what this might look like so setting

00:14:22,110 --> 00:14:26,100
up Apollo link state in your application

00:14:24,029 --> 00:14:29,160
will only require a couple of lines of

00:14:26,100 --> 00:14:31,140
code and all you have to do is pass in a

00:14:29,160 --> 00:14:33,420
resolver map to the link and then

00:14:31,140 --> 00:14:35,820
connect the link to your chain so if

00:14:33,420 --> 00:14:37,440
you've worked with graph QL tools before

00:14:35,820 --> 00:14:39,720
on the server this will look really

00:14:37,440 --> 00:14:41,610
familiar to you and I recommend

00:14:39,720 --> 00:14:44,190
splitting these resolver Maps up by

00:14:41,610 --> 00:14:48,420
feature similar to how you would in the

00:14:44,190 --> 00:14:50,779
redux duck pattern so here's an example

00:14:48,420 --> 00:14:53,310
of what your resolver map will look like

00:14:50,779 --> 00:14:55,890
your resolver functions have the same

00:14:53,310 --> 00:14:58,019
parameters as resolvers on the server so

00:14:55,890 --> 00:15:00,540
your route object to any arguments and

00:14:58,019 --> 00:15:02,640
the context but the key difference here

00:15:00,540 --> 00:15:05,519
is that the cache is automatically added

00:15:02,640 --> 00:15:07,500
to the context for you and to read and

00:15:05,519 --> 00:15:10,769
write data you'll just manipulate that

00:15:07,500 --> 00:15:12,449
cache directly we also want to have some

00:15:10,769 --> 00:15:14,910
sort of default resolver so you don't

00:15:12,449 --> 00:15:16,949
have to specify one each time you want

00:15:14,910 --> 00:15:22,800
to read a property with the same name as

00:15:16,949 --> 00:15:24,930
the field in order to tell Apollo client

00:15:22,800 --> 00:15:26,720
to retrieve the data using your resolver

00:15:24,930 --> 00:15:29,130
map you will need to annotate

00:15:26,720 --> 00:15:31,620
client-side only fields with the client

00:15:29,130 --> 00:15:35,180
directive which is what you see here on

00:15:31,620 --> 00:15:35,180
update network status of thread

00:15:35,820 --> 00:15:39,690
and then from there you just connect

00:15:37,590 --> 00:15:42,170
your component as usual and let Apollo

00:15:39,690 --> 00:15:45,240
client take care of the rest

00:15:42,170 --> 00:15:47,370
so speaking of rest if we can query

00:15:45,240 --> 00:15:49,890
local data and Apollo by using a

00:15:47,370 --> 00:15:52,200
directive what about querying rest data

00:15:49,890 --> 00:15:54,420
as long as the rest endpoint you're

00:15:52,200 --> 00:15:58,290
hitting returns JSON we should be able

00:15:54,420 --> 00:16:00,840
to query it using graph QL and that's

00:15:58,290 --> 00:16:03,720
why we plan on releasing Apollo link

00:16:00,840 --> 00:16:04,770
rest so yeah whenever I see the name of

00:16:03,720 --> 00:16:07,740
this one I feel like it's something

00:16:04,770 --> 00:16:10,050
straight out of horse J ass I mean I I

00:16:07,740 --> 00:16:12,930
promise we're not trolling you here it's

00:16:10,050 --> 00:16:15,690
it's a restaurant and it'll allow you to

00:16:12,930 --> 00:16:20,520
query rest data with graph QL and then

00:16:15,690 --> 00:16:22,770
store the results in Apollo clay the API

00:16:20,520 --> 00:16:25,170
looks pretty similar to Apollo link

00:16:22,770 --> 00:16:27,600
state you'll have a rest link and then

00:16:25,170 --> 00:16:29,730
you'll pass in a map of endpoints you'll

00:16:27,600 --> 00:16:31,830
be able to specify an endpoint if you'd

00:16:29,730 --> 00:16:33,690
like using the context or you can just

00:16:31,830 --> 00:16:35,970
fall back on the default endpoint

00:16:33,690 --> 00:16:37,350
it's a query arrest data you'll just

00:16:35,970 --> 00:16:40,830
annotate the field with the rest

00:16:37,350 --> 00:16:42,510
directive so you're probably sitting

00:16:40,830 --> 00:16:44,490
there wondering why I haven't really

00:16:42,510 --> 00:16:45,510
mentioned schemas or type-checking and

00:16:44,490 --> 00:16:48,060
that's because we're still working that

00:16:45,510 --> 00:16:49,410
piece of it all out so some suggestions

00:16:48,060 --> 00:16:51,540
maybe we'll have some sort of type

00:16:49,410 --> 00:16:53,070
directive that is able to match types or

00:16:51,540 --> 00:16:54,870
maybe we'll move type checking to build

00:16:53,070 --> 00:16:55,560
time kind of like how flow and

00:16:54,870 --> 00:16:57,540
typescript

00:16:55,560 --> 00:17:00,300
are both build time type checkers that

00:16:57,540 --> 00:17:01,620
get stripped out at runtime I don't know

00:17:00,300 --> 00:17:03,480
we're still working on it but anyway I

00:17:01,620 --> 00:17:04,949
think this is going to be huge it's

00:17:03,480 --> 00:17:07,050
really great for front-end developers

00:17:04,949 --> 00:17:08,579
who don't control their back-end or for

00:17:07,050 --> 00:17:10,709
people who just want to experiment with

00:17:08,579 --> 00:17:14,600
Apollo client who aren't quite ready yet

00:17:10,709 --> 00:17:17,760
to build out an entire graph QL server

00:17:14,600 --> 00:17:20,160
so now that Apollo link allows us to

00:17:17,760 --> 00:17:22,380
request data from anywhere we can use

00:17:20,160 --> 00:17:24,630
Apollo client to manage all of our

00:17:22,380 --> 00:17:26,280
applications data and we can use

00:17:24,630 --> 00:17:29,490
directives to tell the client how we

00:17:26,280 --> 00:17:31,320
want our data no more action creators no

00:17:29,490 --> 00:17:34,500
more reducers or maintaining a separate

00:17:31,320 --> 00:17:37,560
store whether it's rest data local data

00:17:34,500 --> 00:17:40,050
or data from a graph QL server Apollo

00:17:37,560 --> 00:17:45,030
client is truly a universal data

00:17:40,050 --> 00:17:46,950
solution and with these new links you'll

00:17:45,030 --> 00:17:48,870
even be able to combine multiple data

00:17:46,950 --> 00:17:50,850
sources in one query

00:17:48,870 --> 00:17:52,830
since directives don't change the shape

00:17:50,850 --> 00:17:54,630
of your data they just determine how you

00:17:52,830 --> 00:17:56,429
get it so it's it's really easy to

00:17:54,630 --> 00:18:00,270
combine them all into one like you see

00:17:56,429 --> 00:18:02,309
here alright so that was like a ton of

00:18:00,270 --> 00:18:03,779
information for 15 minutes but I hope I

00:18:02,309 --> 00:18:06,510
got you really excited about Apollo

00:18:03,779 --> 00:18:08,279
client 2.0 and all the creative ways you

00:18:06,510 --> 00:18:11,159
can use it in your application so let's

00:18:08,279 --> 00:18:13,890
quickly recap Apollo client will enable

00:18:11,159 --> 00:18:17,010
you to accomplish a lot more with less

00:18:13,890 --> 00:18:19,140
code the new modular architecture is

00:18:17,010 --> 00:18:21,270
super flexible and extensible so you can

00:18:19,140 --> 00:18:23,220
tailor your network cache and your

00:18:21,270 --> 00:18:25,590
network stack and your cache to the

00:18:23,220 --> 00:18:27,480
needs of your application and to top it

00:18:25,590 --> 00:18:30,390
all off you'll also be able to use

00:18:27,480 --> 00:18:32,669
Apollo client to query and store any

00:18:30,390 --> 00:18:35,880
kind of data you're no longer limited to

00:18:32,669 --> 00:18:37,950
just a graph QL server so another thing

00:18:35,880 --> 00:18:40,260
that's really cool whether your react an

00:18:37,950 --> 00:18:41,340
angular or a view developer you'll be

00:18:40,260 --> 00:18:44,460
able to benefit from the new

00:18:41,340 --> 00:18:45,570
architecture of Apollo client so let's

00:18:44,460 --> 00:18:49,669
go out and build some cool stuff

00:18:45,570 --> 00:18:49,669

YouTube URL: https://www.youtube.com/watch?v=eHjP2WFt0zU


