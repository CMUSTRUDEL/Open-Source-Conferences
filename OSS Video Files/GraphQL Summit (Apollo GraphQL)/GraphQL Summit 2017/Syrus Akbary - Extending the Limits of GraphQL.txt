Title: Syrus Akbary - Extending the Limits of GraphQL
Publication date: 2017-11-09
Playlist: GraphQL Summit 2017
Description: 
	Syrus Akbary, CTO at Try, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

In this talk I will present the next version of Graphene (2.0), the GraphQL framework for Python, which includes a simpler resolver API and full support for subscriptions. I'll also present a new GraphQL engine able to handle 1 million resolutions per second, beating any other GraphQL engine (js, go, ruby) in the ecosystem.

See his slides: https://speakerdeck.com/syrusakbary/graphene-1
Captions: 
	00:00:03,270 --> 00:00:09,250
hello everyone silicic Valley today I'm

00:00:06,910 --> 00:00:10,900
not talking about graphing but mainly

00:00:09,250 --> 00:00:14,589
about like how we can actually extend

00:00:10,900 --> 00:00:17,170
the limits of graph QL so as a summary I

00:00:14,589 --> 00:00:18,970
will do like three major announcements

00:00:17,170 --> 00:00:22,090
of which I'm like super excited to

00:00:18,970 --> 00:00:23,980
present today first we will I will do an

00:00:22,090 --> 00:00:27,039
overview up with graphene and how we

00:00:23,980 --> 00:00:29,140
devolve all this time and then I will do

00:00:27,039 --> 00:00:31,869
the solar to probably releases that

00:00:29,140 --> 00:00:33,640
we'll see later so let's start with who

00:00:31,869 --> 00:00:36,760
am i i'm CEO Suvari

00:00:33,640 --> 00:00:39,129
I'm currently CTO at Reuters calm but

00:00:36,760 --> 00:00:40,420
mainly probably most of you know me

00:00:39,129 --> 00:00:42,820
because I'm the Builder and main

00:00:40,420 --> 00:00:45,340
contributor of graphene Python I'm the

00:00:42,820 --> 00:00:49,629
graphene ecosystem so let us start with

00:00:45,340 --> 00:00:51,940
cough in Python let's do an overview

00:00:49,629 --> 00:00:54,190
graphene is about two years old now

00:00:51,940 --> 00:00:56,949
actually exactly two years from one

00:00:54,190 --> 00:01:00,070
month old is the most I started

00:00:56,949 --> 00:01:02,230
graphical framework with 2500 stars and

00:01:00,070 --> 00:01:04,780
is used in more than 100 companies in

00:01:02,230 --> 00:01:06,850
production including JAL Mozilla our

00:01:04,780 --> 00:01:09,790
firm dailymotion and try of course try

00:01:06,850 --> 00:01:12,189
this comment one thing that I wanna go

00:01:09,790 --> 00:01:14,140
over is how the tremendous growth the

00:01:12,189 --> 00:01:16,600
graphene has been having the last 10

00:01:14,140 --> 00:01:18,850
months and one surprising thing but

00:01:16,600 --> 00:01:20,590
pleasant surprise was discovering that

00:01:18,850 --> 00:01:24,880
Python 3 actually accomplished for more

00:01:20,590 --> 00:01:27,000
than 50% of all these doors were super

00:01:24,880 --> 00:01:27,000
good

00:01:27,820 --> 00:01:32,920
okay so first major announcement today

00:01:30,369 --> 00:01:35,590
I'm releasing graph in Python 2.0 which

00:01:32,920 --> 00:01:38,979
have a better resolution API a much

00:01:35,590 --> 00:01:40,420
simplified much simpler code base that

00:01:38,979 --> 00:01:42,430
means that actually it's easier to

00:01:40,420 --> 00:01:44,140
contribute and takes full advantage of

00:01:42,430 --> 00:01:46,420
Python free which includes a single

00:01:44,140 --> 00:01:50,170
traitors and class definitions unless

00:01:46,420 --> 00:01:52,000
and last I will do a overview about

00:01:50,170 --> 00:01:54,340
subscriptions of what how we can use it

00:01:52,000 --> 00:01:56,950
in Python 3 so let's start with a better

00:01:54,340 --> 00:01:58,990
resolution API let's imagine we have

00:01:56,950 --> 00:02:01,329
this field in graph tool which is the

00:01:58,990 --> 00:02:03,909
hello field that like take some name as

00:02:01,329 --> 00:02:06,159
an argument and returns a string in

00:02:03,909 --> 00:02:08,380
graphene one point X this is how we will

00:02:06,159 --> 00:02:10,720
need to write the resolvers so basically

00:02:08,380 --> 00:02:13,120
this syntax or this API is super simple

00:02:10,720 --> 00:02:14,930
super super similar or like how we will

00:02:13,120 --> 00:02:17,450
need to do it actually in

00:02:14,930 --> 00:02:19,459
javascript however it was not as

00:02:17,450 --> 00:02:21,620
pleasant to use and I've been thinking

00:02:19,459 --> 00:02:25,040
over how we can simplify and improve the

00:02:21,620 --> 00:02:27,530
way and they the way they API works and

00:02:25,040 --> 00:02:30,140
with graphene 2-point eggs actually the

00:02:27,530 --> 00:02:33,829
resolvers have been simplified a lot the

00:02:30,140 --> 00:02:35,510
context it's going again into into the

00:02:33,829 --> 00:02:38,239
resolver info unnamed

00:02:35,510 --> 00:02:39,980
and all the resolver arguments are

00:02:38,239 --> 00:02:45,980
actually keyboard arguments or of that

00:02:39,980 --> 00:02:48,139
resolver cool so let's go into

00:02:45,980 --> 00:02:49,519
subscriptions which is like one of the

00:02:48,139 --> 00:02:52,489
most challenging things that actually I

00:02:49,519 --> 00:02:54,440
did in graphene so if we wanna start a

00:02:52,489 --> 00:02:55,970
subscription server first of course we

00:02:54,440 --> 00:02:58,310
will need to plug up WebSocket server

00:02:55,970 --> 00:02:59,689
blew up Soviet graphic world server we

00:02:58,310 --> 00:03:01,340
can see that only with three lines of

00:02:59,689 --> 00:03:04,670
code we can have it running in Python

00:03:01,340 --> 00:03:06,709
actually in Python 3.6 and then we'll

00:03:04,670 --> 00:03:08,150
need to create a subscription type the

00:03:06,709 --> 00:03:10,909
subscription type is a normal object

00:03:08,150 --> 00:03:13,609
type which is a little bit more special

00:03:10,909 --> 00:03:15,650
that actually permits to subscribe to

00:03:13,609 --> 00:03:17,930
its fields so in this case taken

00:03:15,650 --> 00:03:19,879
advantage of python 3.6 and it's a sync

00:03:17,930 --> 00:03:22,879
iterators we can see that for example

00:03:19,879 --> 00:03:24,829
you have a field called county that let

00:03:22,879 --> 00:03:28,129
us count from zero to whatever number we

00:03:24,829 --> 00:03:31,220
output and it will weigh a world three

00:03:28,129 --> 00:03:33,560
year it will yield these seconds let's

00:03:31,220 --> 00:03:35,900
say like from zero to ten and we'll wait

00:03:33,560 --> 00:03:38,690
one second between them so we want to do

00:03:35,900 --> 00:03:41,299
that we only need like to write seven

00:03:38,690 --> 00:03:43,879
lines of code using Python three points

00:03:41,299 --> 00:03:46,250
in iterators and we are all done I'm

00:03:43,879 --> 00:03:47,659
gonna do a subscriptions demo real time

00:03:46,250 --> 00:03:50,569
demo let's hope like everything goes

00:03:47,659 --> 00:03:52,489
well but actually you can go into github

00:03:50,569 --> 00:03:54,590
graph twelve Python graph global

00:03:52,489 --> 00:03:58,479
circuits and try it by yourself if you

00:03:54,590 --> 00:03:58,479
have by Python three point six installed

00:04:00,609 --> 00:04:05,290
so now I'm gonna set up everything so

00:04:08,979 --> 00:04:17,109
first I want to show you how the code

00:04:12,590 --> 00:04:17,109
looks once again

00:04:24,660 --> 00:04:30,750
the first same code as I show you before

00:04:28,160 --> 00:04:33,720
probably you can all see it right like

00:04:30,750 --> 00:04:35,280
we have a query type which is a type

00:04:33,720 --> 00:04:36,750
required when we create the schema and

00:04:35,280 --> 00:04:38,760
then this description type the

00:04:36,750 --> 00:04:43,050
subscription type have the count seconds

00:04:38,760 --> 00:04:45,750
but let us say up to what we want to

00:04:43,050 --> 00:04:48,720
wait and then like it will just yield

00:04:45,750 --> 00:04:51,780
these these values and I'm wait one

00:04:48,720 --> 00:04:56,150
second between there so now let me just

00:04:51,780 --> 00:04:56,150
start the server and show it here

00:05:05,460 --> 00:05:21,380
okay so we we go to localhost if that's

00:05:11,190 --> 00:05:21,380
one graph graphical perfect demo time

00:05:24,680 --> 00:05:35,940
sorry okay so in this case we we want to

00:05:34,080 --> 00:05:38,430
like create a subscription and count out

00:05:35,940 --> 00:05:40,230
up to ten seconds if we execute that

00:05:38,430 --> 00:05:42,180
just like using the same syntax that you

00:05:40,230 --> 00:05:46,410
have seen it's gonna make it a little

00:05:42,180 --> 00:05:48,210
bit bigger you will see that here it

00:05:46,410 --> 00:05:50,670
will count up to ten like using

00:05:48,210 --> 00:05:53,670
WebSockets and this simpler API that you

00:05:50,670 --> 00:05:57,990
already seen so that's the demo the data

00:05:53,670 --> 00:06:08,300
demo for subscriptions I'm gonna go back

00:05:57,990 --> 00:06:12,240
to the presentation there we go again

00:06:08,300 --> 00:06:14,490
so a part of graphene 2.0 that I just

00:06:12,240 --> 00:06:16,890
released today and I have like a new

00:06:14,490 --> 00:06:18,260
branding a new website a new logo that

00:06:16,890 --> 00:06:20,670
actually I'm like super excited about

00:06:18,260 --> 00:06:23,130
today I have another major product

00:06:20,670 --> 00:06:25,740
announcement I'm presenting wrapping in

00:06:23,130 --> 00:06:28,410
JavaScript which is the same framework

00:06:25,740 --> 00:06:30,960
the same ideas the same simple syntax

00:06:28,410 --> 00:06:33,780
and easy to use syntax that graph we

00:06:30,960 --> 00:06:36,270
have but in JavaScript so what were the

00:06:33,780 --> 00:06:38,850
goals that I had when creating graph in

00:06:36,270 --> 00:06:40,530
JavaScript first it should lead to very

00:06:38,850 --> 00:06:42,900
easy to read and easy to understand

00:06:40,530 --> 00:06:45,660
schemas and then it should you should

00:06:42,900 --> 00:06:48,510
have like a way to integrate very easily

00:06:45,660 --> 00:06:51,290
with almost any data source starting for

00:06:48,510 --> 00:06:55,380
example with the sequel eyes Orion

00:06:51,290 --> 00:06:57,960
so for knowing or seen like how graphing

00:06:55,380 --> 00:06:59,280
JavaScript actually like how the schemas

00:06:57,960 --> 00:07:00,780
look like in graph in JavaScript is

00:06:59,280 --> 00:07:03,930
essential to do a comparison between

00:07:00,780 --> 00:07:05,880
these two so we want to create a schema

00:07:03,930 --> 00:07:09,030
who have like a type query with a

00:07:05,880 --> 00:07:10,830
helpful on it and this is how we will

00:07:09,030 --> 00:07:13,170
need to type in the scheme and graft

00:07:10,830 --> 00:07:16,590
well JavaScript and we can see how like

00:07:13,170 --> 00:07:18,420
exactly the same a schema is like is we

00:07:16,590 --> 00:07:19,289
can write it with just like half lines

00:07:18,420 --> 00:07:21,539
of code

00:07:19,289 --> 00:07:23,550
so actually ignites the the airport of

00:07:21,539 --> 00:07:26,069
trading a gradually schema much much

00:07:23,550 --> 00:07:28,589
easier for the developer but things gets

00:07:26,069 --> 00:07:30,990
actually like much more funny when you

00:07:28,589 --> 00:07:33,689
go into types that leaner it from

00:07:30,990 --> 00:07:35,999
interfaces so let's say we have like our

00:07:33,689 --> 00:07:37,819
interface we are a website they have two

00:07:35,999 --> 00:07:41,099
kinds of users one is the anonymous user

00:07:37,819 --> 00:07:43,169
another is the register user and both

00:07:41,099 --> 00:07:45,869
share the same fields so actually both

00:07:43,169 --> 00:07:48,719
implement or extending the user base

00:07:45,869 --> 00:07:50,699
interface which have like a ID and a

00:07:48,719 --> 00:07:52,860
name on it in graphical JavaScript this

00:07:50,699 --> 00:07:54,689
will require us to write all this

00:07:52,860 --> 00:07:56,279
boilerplate code and with graphing

00:07:54,689 --> 00:07:59,669
JavaScript actually the code that is

00:07:56,279 --> 00:08:01,589
required to write is much much less code

00:07:59,669 --> 00:08:03,029
one of the cool things our graphing

00:08:01,589 --> 00:08:04,709
javascript is actually implemented in

00:08:03,029 --> 00:08:09,899
typescript so you will have auto

00:08:04,709 --> 00:08:12,389
completion in your IDE I'm also a you

00:08:09,899 --> 00:08:14,490
will have super easily integration with

00:08:12,389 --> 00:08:16,949
almost any data source you can go into

00:08:14,490 --> 00:08:18,779
graph in JavaScript org to check like

00:08:16,949 --> 00:08:20,789
how you can use it and right now there

00:08:18,779 --> 00:08:23,969
are no documentation but I will try to

00:08:20,789 --> 00:08:26,069
solve it by today and you can actually

00:08:23,969 --> 00:08:28,649
start using and I want to like basically

00:08:26,069 --> 00:08:30,689
like put it on the field and like a star

00:08:28,649 --> 00:08:34,680
having people using it and see like how

00:08:30,689 --> 00:08:37,139
we can actually improve it I also have

00:08:34,680 --> 00:08:40,729
another major project announcement the

00:08:37,139 --> 00:08:43,500
third one but for understanding this

00:08:40,729 --> 00:08:45,899
this announcement I think is essential

00:08:43,500 --> 00:08:50,850
to tell a story about like how I came

00:08:45,899 --> 00:08:54,089
into it so it's a story time okay I want

00:08:50,850 --> 00:08:55,949
to start with templates I've been loving

00:08:54,089 --> 00:08:59,100
templates unlike how they work for a

00:08:55,949 --> 00:09:01,139
long time I mean we searching like see

00:08:59,100 --> 00:09:03,180
like which ones will fast which ones

00:09:01,139 --> 00:09:05,069
going slow and actually I launched my

00:09:03,180 --> 00:09:07,350
own template engine for Python pi Jade

00:09:05,069 --> 00:09:09,620
six years ago which if you don't know

00:09:07,350 --> 00:09:11,970
like Jade was a template engine in

00:09:09,620 --> 00:09:14,459
JavaScript that was making much easier

00:09:11,970 --> 00:09:15,990
like write HTML code since then I've

00:09:14,459 --> 00:09:18,990
been experimenting a lot between like

00:09:15,990 --> 00:09:20,910
the in templates between JavaScript and

00:09:18,990 --> 00:09:24,060
Python and I realize that are actually

00:09:20,910 --> 00:09:28,770
like two kinds of templates the ones

00:09:24,060 --> 00:09:31,780
that are fast and the ones that are not

00:09:28,770 --> 00:09:33,970
so let's go very quickly into comparing

00:09:31,780 --> 00:09:35,830
two kind of template systems for Python

00:09:33,970 --> 00:09:37,900
but this applies actually to almost

00:09:35,830 --> 00:09:40,780
template to any templating engine also

00:09:37,900 --> 00:09:43,210
in JavaScript or like in Ruby in almost

00:09:40,780 --> 00:09:45,100
any language so we can see that Django

00:09:43,210 --> 00:09:46,930
is about like 10 to 20 times this lower

00:09:45,100 --> 00:09:49,840
than ginger which is another template

00:09:46,930 --> 00:09:52,480
engine but why for understanding dates

00:09:49,840 --> 00:09:55,750
is essential to do an analysis on all

00:09:52,480 --> 00:09:57,850
the different in an analysis into like

00:09:55,750 --> 00:10:00,970
how the render function works in both

00:09:57,850 --> 00:10:03,040
template engines so we have this

00:10:00,970 --> 00:10:04,150
following template in Django which is

00:10:03,040 --> 00:10:05,740
just checking the value sure is

00:10:04,150 --> 00:10:09,940
authenticated and in this case is

00:10:05,740 --> 00:10:11,200
returning the string like hello if we

00:10:09,940 --> 00:10:13,180
want to render this template with the

00:10:11,200 --> 00:10:15,130
following context let's say the user is

00:10:13,180 --> 00:10:18,820
authenticated and its name is Peter

00:10:15,130 --> 00:10:21,220
Django will actually render in runtime

00:10:18,820 --> 00:10:23,230
and returns hello Peter but we'll run

00:10:21,220 --> 00:10:25,390
everything from the lecture to the

00:10:23,230 --> 00:10:28,450
parser to actually the execution engine

00:10:25,390 --> 00:10:31,390
in runtime and that's super costly and

00:10:28,450 --> 00:10:34,570
here we have ginger tuned with exactly

00:10:31,390 --> 00:10:37,870
the same almost the same syntax but what

00:10:34,570 --> 00:10:40,780
is the difference ginger to pre compile

00:10:37,870 --> 00:10:43,420
this code to actually pure native code

00:10:40,780 --> 00:10:46,480
in this case in Python so you will

00:10:43,420 --> 00:10:48,610
create a Python function not take our

00:10:46,480 --> 00:10:50,620
context variable and it will return a

00:10:48,610 --> 00:10:51,880
string so actually once you generate

00:10:50,620 --> 00:10:54,580
this code the only thing that you need

00:10:51,880 --> 00:10:57,640
to do is just run this function which is

00:10:54,580 --> 00:10:59,680
pure Python it runs in the Python engine

00:10:57,640 --> 00:11:03,310
so actually it's as fast as its it can

00:10:59,680 --> 00:11:05,110
be in Python so both have exactly the

00:11:03,310 --> 00:11:08,260
same results both Django and ginger

00:11:05,110 --> 00:11:09,400
but gene J is 20 times faster so I've

00:11:08,260 --> 00:11:12,640
been thinking lately

00:11:09,400 --> 00:11:17,080
can we actually improve them the speed

00:11:12,640 --> 00:11:19,660
that we worry or or graph 12 schemas can

00:11:17,080 --> 00:11:23,230
we improve the speed there and the short

00:11:19,660 --> 00:11:24,820
answer is yes so today I'm presenting

00:11:23,230 --> 00:11:29,770
cuivre which is the next generation

00:11:24,820 --> 00:11:31,900
graphical engine and for that and for

00:11:29,770 --> 00:11:35,590
that I want to do another analysis into

00:11:31,900 --> 00:11:37,090
how how this engines work and how is

00:11:35,590 --> 00:11:40,570
different from the normal graphical

00:11:37,090 --> 00:11:41,950
engine I guess you can already guess so

00:11:40,570 --> 00:11:44,890
if we want to execute this follow

00:11:41,950 --> 00:11:48,280
query we want to query hello with the

00:11:44,890 --> 00:11:50,530
name that is provided from variables and

00:11:48,280 --> 00:11:52,810
we won I have to get this quarry the

00:11:50,530 --> 00:11:55,330
graphical engine either and I'm talking

00:11:52,810 --> 00:11:58,120
almost in any engine in graphical graph

00:11:55,330 --> 00:12:00,430
QL JavaScript graph QL core which is in

00:11:58,120 --> 00:12:02,800
the one in Python graphical Ruby both

00:12:00,430 --> 00:12:06,760
are executing these queries in runtime

00:12:02,800 --> 00:12:07,510
and actually the result is just like

00:12:06,760 --> 00:12:10,330
hello Peter

00:12:07,510 --> 00:12:13,180
like what we expected however quiver

00:12:10,330 --> 00:12:15,550
when we have exactly the same query what

00:12:13,180 --> 00:12:18,520
is doing is pre compiling this quarry

00:12:15,550 --> 00:12:21,280
into pure native code that means that

00:12:18,520 --> 00:12:24,760
running a graph QL query will be as fast

00:12:21,280 --> 00:12:27,160
as if you write the same query by hand

00:12:24,760 --> 00:12:29,320
like exactly fetching the same

00:12:27,160 --> 00:12:32,380
information but doing it manually that

00:12:29,320 --> 00:12:34,570
means that we will have actually zero

00:12:32,380 --> 00:12:34,780
overhead from the framework but not just

00:12:34,570 --> 00:12:36,640
that

00:12:34,780 --> 00:12:39,310
in the example of Python we can even

00:12:36,640 --> 00:12:41,470
compile this to see and provide you with

00:12:39,310 --> 00:12:43,990
a library that you can just use it and

00:12:41,470 --> 00:12:48,430
it will be being executed in the speed

00:12:43,990 --> 00:12:50,320
of light that's really so here are some

00:12:48,430 --> 00:12:52,450
benchmarks I'm comparing ruptal core

00:12:50,320 --> 00:12:56,050
which is a demain engine for using

00:12:52,450 --> 00:12:58,090
graphical in Python with cleaver in both

00:12:56,050 --> 00:13:00,040
like simple queries hilum nested queries

00:12:58,090 --> 00:13:02,980
or very complex query with fragments

00:13:00,040 --> 00:13:06,640
where quiver is from v to time times

00:13:02,980 --> 00:13:08,650
faster than graph clerk or so given let

00:13:06,640 --> 00:13:11,680
me give you more stats actually that

00:13:08,650 --> 00:13:13,810
means that we can actually do 300,000

00:13:11,680 --> 00:13:15,370
resolutions per second in Python and we

00:13:13,810 --> 00:13:17,860
all know Python is not that super

00:13:15,370 --> 00:13:19,690
performant language and we can have up

00:13:17,860 --> 00:13:22,510
to 1 million resolutions per second

00:13:19,690 --> 00:13:24,340
using pi pi but what are the cool things

00:13:22,510 --> 00:13:26,020
about here this actually these

00:13:24,340 --> 00:13:29,590
principles could be applied to almost

00:13:26,020 --> 00:13:31,510
any interpreted language this can be

00:13:29,590 --> 00:13:34,030
applied in JavaScript or anywhere that

00:13:31,510 --> 00:13:36,310
we want and in general we can see from 5

00:13:34,030 --> 00:13:36,730
to 10 times performance in C Python and

00:13:36,310 --> 00:13:39,280
Ruby

00:13:36,730 --> 00:13:43,210
I'm from 2 to 3 times performance indeed

00:13:39,280 --> 00:13:46,750
enable a indeed a nation based backends

00:13:43,210 --> 00:13:50,110
so pi PI the v8 engine spider monkey or

00:13:46,750 --> 00:13:51,970
even hack quiver is going to be

00:13:50,110 --> 00:13:54,880
available in almost every major language

00:13:51,970 --> 00:13:55,840
starting with Python but it will be

00:13:54,880 --> 00:13:58,600
available

00:13:55,840 --> 00:14:01,150
scrape in Ruby and PHP and if you are

00:13:58,600 --> 00:14:04,630
interested you just have to go into

00:14:01,150 --> 00:14:09,490
graph QL cleaver calm and contact the

00:14:04,630 --> 00:14:12,240
sales team which in this case is me I

00:14:09,490 --> 00:14:14,860
want to finish with this slide

00:14:12,240 --> 00:14:18,430
poor Tata your API is a user interface

00:14:14,860 --> 00:14:20,440
this quote is from kenneth rate which is

00:14:18,430 --> 00:14:22,350
the creative of the request package in

00:14:20,440 --> 00:14:25,300
python and actually is one of the

00:14:22,350 --> 00:14:27,640
packages for libraries with a more the

00:14:25,300 --> 00:14:30,970
most beautiful api for like handling

00:14:27,640 --> 00:14:33,010
HTTP requests I also wanna finish giving

00:14:30,970 --> 00:14:35,680
thanks to almost everyone that like

00:14:33,010 --> 00:14:37,960
collaborated and like push grouping

00:14:35,680 --> 00:14:40,810
forward to put it like where is it right

00:14:37,960 --> 00:14:43,120
now from patty camino i adding Django

00:14:40,810 --> 00:14:45,220
rest framework into into graphene Jagger

00:14:43,120 --> 00:14:48,580
and Jagger Porter for being a very good

00:14:45,220 --> 00:14:50,680
contributor of graphene Django basically

00:14:48,580 --> 00:14:52,870
you can read they are like they did like

00:14:50,680 --> 00:14:55,180
some awesome work and I would like to

00:14:52,870 --> 00:14:58,600
welcome more people into contributing to

00:14:55,180 --> 00:15:00,460
graphene and into it side projects also

00:14:58,600 --> 00:15:02,620
I know we are not doing questions right

00:15:00,460 --> 00:15:04,600
now but if you have any questions you

00:15:02,620 --> 00:15:07,300
can pick me personally also you can

00:15:04,600 --> 00:15:10,210
check my Twitter at Sirius Akbari also

00:15:07,300 --> 00:15:11,740
ie I welcome you to visit graphene dot

00:15:10,210 --> 00:15:13,720
tools where you can see like all the

00:15:11,740 --> 00:15:16,810
different tools from graphene Python

00:15:13,720 --> 00:15:19,310
graph in JavaScript and cleaver and star

00:15:16,810 --> 00:15:26,680
investigating about them thank you

00:15:19,310 --> 00:15:26,680

YouTube URL: https://www.youtube.com/watch?v=LBurKh3eMDc


