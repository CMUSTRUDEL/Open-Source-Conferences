Title: Rob Zhu - GraphQL Subscriptions: Full Stack
Publication date: 2017-11-08
Playlist: GraphQL Summit 2017
Description: 
	Robert Zhu, Software Engineer at Facebook, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

GraphQL Subscriptions is a great choice for building modern, real-time applications. In this talk, we will cover the history, theory, and practice of GraphQL Subscriptions. We will discuss backend architecture and scaling options; everything you need to add GraphQL Subscriptions to your toolbox!

Resources:
Learn more about Summit - https://summit.graphql.com/
Captions: 
	00:00:03,310 --> 00:00:12,460
hello everyone my name is Robert Zoo let

00:00:09,139 --> 00:00:12,460
me get these slides up first

00:00:34,380 --> 00:00:41,700
hey I'm a software engineer at the

00:00:38,520 --> 00:00:45,570
Facebook Boston office where I work on

00:00:41,700 --> 00:00:50,310
graph QL I'm so excited to be here today

00:00:45,570 --> 00:00:52,860
at graph QL summit what an audience what

00:00:50,310 --> 00:00:56,010
a venue I've met so many awesome people

00:00:52,860 --> 00:00:59,220
and I'm hope to meet many more but I

00:00:56,010 --> 00:01:00,930
want to tell a quick story first I love

00:00:59,220 --> 00:01:02,760
visiting San Francisco it's always a

00:01:00,930 --> 00:01:05,250
treat for me because I get to hear the

00:01:02,760 --> 00:01:09,210
most interesting conversations happened

00:01:05,250 --> 00:01:11,790
I was at my hotel last night and I heard

00:01:09,210 --> 00:01:15,750
these two people talking and it occurred

00:01:11,790 --> 00:01:17,310
to me that they worked at a start-up and

00:01:15,750 --> 00:01:19,560
they were talking about how they were

00:01:17,310 --> 00:01:21,990
gonna earn the business of a very

00:01:19,560 --> 00:01:24,390
important client and the first person

00:01:21,990 --> 00:01:27,680
says their existing service provider

00:01:24,390 --> 00:01:29,400
gives them four nines of availability

00:01:27,680 --> 00:01:34,140
how are we going to compete with that

00:01:29,400 --> 00:01:42,000
and his partner says don't worry we're

00:01:34,140 --> 00:01:42,570
gonna give them five eighths I love San

00:01:42,000 --> 00:01:45,350
Francisco

00:01:42,570 --> 00:01:48,539
[Laughter]

00:01:45,350 --> 00:01:53,160
all right Graff kills subscriptions the

00:01:48,539 --> 00:01:56,520
full stack let's go here's a quick run

00:01:53,160 --> 00:01:57,990
through the agenda I have made the

00:01:56,520 --> 00:02:00,450
terrible mistake of preparing an

00:01:57,990 --> 00:02:03,840
interactive demo for all of you so we're

00:02:00,450 --> 00:02:05,580
gonna watch that crash and burn and then

00:02:03,840 --> 00:02:10,770
from that we're going to understand

00:02:05,580 --> 00:02:15,390
subscriptions what they are why you want

00:02:10,770 --> 00:02:16,770
to use them how you use them and then

00:02:15,390 --> 00:02:19,200
we're going to transition over to

00:02:16,770 --> 00:02:21,360
talking about building your own graph QL

00:02:19,200 --> 00:02:23,670
subscription server what are some of the

00:02:21,360 --> 00:02:26,660
considerations that you need to make

00:02:23,670 --> 00:02:29,700
when you're building one of these out

00:02:26,660 --> 00:02:32,099
what are the building blocks one of

00:02:29,700 --> 00:02:35,550
those challenges that we face that at at

00:02:32,099 --> 00:02:37,830
Facebook when we built this we're going

00:02:35,550 --> 00:02:41,160
to compare and contrast subscriptions

00:02:37,830 --> 00:02:43,200
with another reactive graphical

00:02:41,160 --> 00:02:46,830
mechanism that people may have heard of

00:02:43,200 --> 00:02:48,590
called live queries and then at the end

00:02:46,830 --> 00:02:50,700
I'll have a resources

00:02:48,590 --> 00:02:52,260
with links to everything that I've

00:02:50,700 --> 00:02:53,790
covered so you don't have to worry about

00:02:52,260 --> 00:02:59,280
taking pictures of any of the slides as

00:02:53,790 --> 00:03:00,180
I go through them alright so those of

00:02:59,280 --> 00:03:03,930
you who would like to follow along

00:03:00,180 --> 00:03:06,450
please open your browser to graff qtk

00:03:03,930 --> 00:03:08,340
enter your credit card your PIN and your

00:03:06,450 --> 00:03:12,050
mother's maiden name it's all part of

00:03:08,340 --> 00:03:14,580
the demo trust me and I'll give you a

00:03:12,050 --> 00:03:15,390
you know some time to open that up if

00:03:14,580 --> 00:03:18,680
you want to follow along with your

00:03:15,390 --> 00:03:18,680
laptops don't be shy

00:03:38,250 --> 00:03:47,459
we should be seeing the demo now

00:04:02,599 --> 00:04:05,980
Oh default

00:04:19,720 --> 00:04:28,630
okay can everybody see that okay in the

00:04:24,460 --> 00:04:30,190
back all right I've got a thumbs up and

00:04:28,630 --> 00:04:32,950
those of you who wanted to follow along

00:04:30,190 --> 00:04:37,570
I assume that's enough time to open up a

00:04:32,950 --> 00:04:38,530
new browser so this is graphical many of

00:04:37,570 --> 00:04:40,180
you have seen this before

00:04:38,530 --> 00:04:42,880
and I'm just going to start exploring

00:04:40,180 --> 00:04:45,580
the schema using the documentation

00:04:42,880 --> 00:04:47,350
Explorer as usual we'll start with

00:04:45,580 --> 00:04:49,030
queries and when I click through to

00:04:47,350 --> 00:04:51,370
query as I see there is this houses

00:04:49,030 --> 00:04:53,370
route field if I click through here I

00:04:51,370 --> 00:04:57,340
see it returns a collection of houses

00:04:53,370 --> 00:05:00,790
each house has a name an integer count

00:04:57,340 --> 00:05:04,630
of the number of Bannerman and words any

00:05:00,790 --> 00:05:08,230
guesses what this schema represents yes

00:05:04,630 --> 00:05:10,630
I I love Game of Thrones so I couldn't

00:05:08,230 --> 00:05:14,440
help but build this demo around my my

00:05:10,630 --> 00:05:21,610
favorite TV show so let's let's just

00:05:14,440 --> 00:05:31,180
execute some queries all the houses I

00:05:21,610 --> 00:05:33,510
can fetch the name Bannerman count all

00:05:31,180 --> 00:05:33,510
right

00:05:34,060 --> 00:05:39,340
so cool somebody's already begun using

00:05:38,470 --> 00:05:45,610
it thank you

00:05:39,340 --> 00:05:47,680
I we've got the houses and for each

00:05:45,610 --> 00:05:50,980
house I have selected the name field and

00:05:47,680 --> 00:05:55,320
the Bannerman field and I can change my

00:05:50,980 --> 00:05:55,320
mind about this and I can pick out words

00:05:56,280 --> 00:06:01,180
so I there's an interesting story behind

00:05:59,050 --> 00:06:02,740
this this is this is a recent addition

00:06:01,180 --> 00:06:05,860
to this demo because the last time I did

00:06:02,740 --> 00:06:08,110
this people found it thought it would be

00:06:05,860 --> 00:06:13,540
a good idea to script a loop and just

00:06:08,110 --> 00:06:15,910
endlessly hammer this thing so our this

00:06:13,540 --> 00:06:18,960
demo will be dependent on the goodwill

00:06:15,910 --> 00:06:18,960
of the audience

00:06:20,759 --> 00:06:26,919
okay so so we've got this this query

00:06:24,580 --> 00:06:29,979
executing successfully great and we're

00:06:26,919 --> 00:06:32,650
seeing that we can select the fields

00:06:29,979 --> 00:06:34,509
that we want from the client and we know

00:06:32,650 --> 00:06:37,620
that this is one of the existing things

00:06:34,509 --> 00:06:40,000
that makes graph QL awesome

00:06:37,620 --> 00:06:41,259
these numbers have also been changing so

00:06:40,000 --> 00:06:47,949
let's take a quick look at how we did

00:06:41,259 --> 00:06:51,069
that that works because or mutations we

00:06:47,949 --> 00:06:53,710
have this pledge mutation and we can see

00:06:51,069 --> 00:06:57,759
that it takes as a parameter one of

00:06:53,710 --> 00:07:07,719
these values these houses let's go in

00:06:57,759 --> 00:07:10,599
here and execute one of those let's

00:07:07,719 --> 00:07:13,529
pledge the Tyrrell and then we'll also

00:07:10,599 --> 00:07:18,039
fetch the name in the banner minim cool

00:07:13,529 --> 00:07:21,039
so we just saw the mutation we saw that

00:07:18,039 --> 00:07:24,610
the mutation is a combination of a state

00:07:21,039 --> 00:07:26,139
change and a subsequent fetch that's

00:07:24,610 --> 00:07:29,550
very handy because I want to know

00:07:26,139 --> 00:07:29,550
whether and I fledged myself to a loser

00:07:30,659 --> 00:07:46,810
let's switch back to the slides for a

00:07:33,339 --> 00:07:49,689
moment okay what just happened well we

00:07:46,810 --> 00:07:52,569
saw a graphical and when we hit the play

00:07:49,689 --> 00:07:55,060
button we saw a response come back on

00:07:52,569 --> 00:07:56,979
the right side let's go into that in a

00:07:55,060 --> 00:07:59,319
more detail we know that when we hit

00:07:56,979 --> 00:08:03,759
play in the graphical we sent an HTTP

00:07:59,319 --> 00:08:05,379
request to the graphical server and this

00:08:03,759 --> 00:08:08,560
happens demo happens to be rapid running

00:08:05,379 --> 00:08:10,839
in express and when Express gets this

00:08:08,560 --> 00:08:14,319
request it pulls out the graph Gale

00:08:10,839 --> 00:08:16,719
document in the HTTP request and then

00:08:14,319 --> 00:08:18,460
it's subjected to execution with the

00:08:16,719 --> 00:08:21,310
Kraft QL server and this goes through

00:08:18,460 --> 00:08:24,159
three steps the first is that we're

00:08:21,310 --> 00:08:25,539
going to parse the document and when we

00:08:24,159 --> 00:08:27,250
parse it we're going to enforce some

00:08:25,539 --> 00:08:29,409
rules like curly braces need to be

00:08:27,250 --> 00:08:30,810
matched and those rules are defined in

00:08:29,409 --> 00:08:37,950
the graph QL language

00:08:30,810 --> 00:08:40,110
vacation next we can't just specify any

00:08:37,950 --> 00:08:42,719
selection in our document it has to be

00:08:40,110 --> 00:08:45,090
valid with respect to the schema so if I

00:08:42,719 --> 00:08:46,500
had included a field like foo it

00:08:45,090 --> 00:08:51,810
wouldn't make any sense because none of

00:08:46,500 --> 00:08:54,540
the types have that field and if it

00:08:51,810 --> 00:08:56,130
passes validation then we get down to

00:08:54,540 --> 00:08:57,810
execution and that's when we actually

00:08:56,130 --> 00:09:00,000
execute the resolvers associated with

00:08:57,810 --> 00:09:01,380
each of those fields and as those

00:09:00,000 --> 00:09:04,529
resolvers come back we take the

00:09:01,380 --> 00:09:07,080
responses and we assemble it into a JSON

00:09:04,529 --> 00:09:14,820
string and then we send it back to the

00:09:07,080 --> 00:09:15,779
client once it gets to the client we've

00:09:14,820 --> 00:09:20,510
got a response

00:09:15,779 --> 00:09:26,940
we've got JSON what do we do with it now

00:09:20,510 --> 00:09:28,950
well the answer is whatever you want we

00:09:26,940 --> 00:09:30,540
often talk about in terms of sticking

00:09:28,950 --> 00:09:32,940
that JSON response into a store and then

00:09:30,540 --> 00:09:36,230
using that store to trigger some sort of

00:09:32,940 --> 00:09:39,500
update in our dynamic view layer and

00:09:36,230 --> 00:09:42,510
that's a very common end useful use case

00:09:39,500 --> 00:09:44,430
but back here you can really do a lot of

00:09:42,510 --> 00:09:47,120
other things you can write this to a

00:09:44,430 --> 00:09:51,900
file you can kick off another request

00:09:47,120 --> 00:09:54,570
you can start an automated process so I

00:09:51,900 --> 00:09:56,310
I have this slide here because I want to

00:09:54,570 --> 00:09:58,410
emphasize that graph kills useful

00:09:56,310 --> 00:10:02,330
outside of the context of just attaching

00:09:58,410 --> 00:10:02,330
it to some sort of web view layer

00:10:07,890 --> 00:10:13,960
let's observe that query using mutations

00:10:10,450 --> 00:10:18,310
post both followed this request response

00:10:13,960 --> 00:10:20,920
style interaction they're both client

00:10:18,310 --> 00:10:29,740
driven which allows us to fetch exactly

00:10:20,920 --> 00:10:33,310
the data that the client needs but what

00:10:29,740 --> 00:10:37,690
about real-time data how exactly would

00:10:33,310 --> 00:10:42,040
we build an app that displays real-time

00:10:37,690 --> 00:10:45,040
updates and a tricky with request

00:10:42,040 --> 00:10:48,850
response right as we saw from Dan's talk

00:10:45,040 --> 00:10:52,270
earlier we could just pull and that

00:10:48,850 --> 00:10:54,880
might get us quite far actually but we

00:10:52,270 --> 00:11:00,070
may come upon a situation where the

00:10:54,880 --> 00:11:01,720
scale of our app and the nature of the

00:11:00,070 --> 00:11:06,550
request means that we want some sort of

00:11:01,720 --> 00:11:09,150
pushed based solution so let's go back

00:11:06,550 --> 00:11:09,150
to the demo

00:11:28,600 --> 00:11:35,890
in the schema we have a third operation

00:11:32,290 --> 00:11:40,600
down here the subscription and the

00:11:35,890 --> 00:11:43,560
subscription operation type allows us to

00:11:40,600 --> 00:11:45,730
subscribe to real-time data in graph QL

00:11:43,560 --> 00:11:47,590
so if I click through here in the docs

00:11:45,730 --> 00:11:50,050
we can see that there is a power change

00:11:47,590 --> 00:11:53,620
the subscription and we can see that it

00:11:50,050 --> 00:11:55,270
returns a collection of houses so if I

00:11:53,620 --> 00:12:02,380
come over here into the left and I just

00:11:55,270 --> 00:12:05,350
say subscription now I'm good at the

00:12:02,380 --> 00:12:08,170
name and the bannermen count execute

00:12:05,350 --> 00:12:12,550
this thing so I can see these changes

00:12:08,170 --> 00:12:15,970
coming in in real time somebody is

00:12:12,550 --> 00:12:21,430
making sure that gryffindor is the most

00:12:15,970 --> 00:12:22,750
powerful house in westeros but this is

00:12:21,430 --> 00:12:26,200
happening from somebody in the audience

00:12:22,750 --> 00:12:28,870
probably right this is really cool we we

00:12:26,200 --> 00:12:33,610
have just did an interactive demo it's

00:12:28,870 --> 00:12:35,050
pretty cool so we'll check back on this

00:12:33,610 --> 00:12:37,060
at the end I want to see who wins I want

00:12:35,050 --> 00:12:44,860
to see if I anybody can up seat upset

00:12:37,060 --> 00:12:47,410
Gryffindor here yeah so so this

00:12:44,860 --> 00:12:49,180
hopefully this makes sense right before

00:12:47,410 --> 00:12:51,010
what we're used to seeing in graphical

00:12:49,180 --> 00:12:53,260
most of the time as we execute a request

00:12:51,010 --> 00:12:54,670
and we get a single response but what

00:12:53,260 --> 00:12:57,990
we're seeing here is something slightly

00:12:54,670 --> 00:13:00,640
different we're seeing a request

00:12:57,990 --> 00:13:03,760
followed by a stream of responses and

00:13:00,640 --> 00:13:08,130
this stream of responses tells us when

00:13:03,760 --> 00:13:08,130
the state that we care about changed

00:13:09,740 --> 00:13:13,100
let's switch back to the slides and I

00:13:11,420 --> 00:13:14,270
think you should all be able to anybody

00:13:13,100 --> 00:13:30,260
trying to execute one of these in the

00:13:14,270 --> 00:13:34,400
audience yeah all right what do we what

00:13:30,260 --> 00:13:36,740
do we just see here's what the

00:13:34,400 --> 00:13:40,310
specification says about graph kiosk

00:13:36,740 --> 00:13:41,240
subscriptions if the operation is a

00:13:40,310 --> 00:13:44,690
subscription

00:13:41,240 --> 00:13:48,050
the result is an event stream called the

00:13:44,690 --> 00:13:50,300
response stream where each event in the

00:13:48,050 --> 00:13:53,870
event stream is the result of executing

00:13:50,300 --> 00:13:57,110
the operation for each new event on an

00:13:53,870 --> 00:13:58,850
underlying source stream executing a

00:13:57,110 --> 00:14:01,070
subscription creates a persistent

00:13:58,850 --> 00:14:04,090
function on the server that map's an

00:14:01,070 --> 00:14:09,560
underlying source stream to a returned

00:14:04,090 --> 00:14:16,070
response stream I wrote this and I

00:14:09,560 --> 00:14:18,530
apologize but there's some interesting

00:14:16,070 --> 00:14:21,170
concepts here and what I want to do in

00:14:18,530 --> 00:14:23,150
the next couple of slides is unpack what

00:14:21,170 --> 00:14:25,310
this means with a couple of concrete

00:14:23,150 --> 00:14:28,340
examples so that hopefully it will make

00:14:25,310 --> 00:14:31,070
a complete sense for you let's begin

00:14:28,340 --> 00:14:34,280
with this notion of a source stream what

00:14:31,070 --> 00:14:38,480
is it and how exactly do we turn it into

00:14:34,280 --> 00:14:40,340
the response stream I'm gonna begin by

00:14:38,480 --> 00:14:44,000
talking about a concrete event system

00:14:40,340 --> 00:14:49,880
and the example app that we're building

00:14:44,000 --> 00:14:51,260
here is a messaging system the idea is

00:14:49,880 --> 00:14:53,180
that if you have an account and you're

00:14:51,260 --> 00:14:55,250
logged in you can message any other

00:14:53,180 --> 00:14:57,290
logged in user and suppose that we

00:14:55,250 --> 00:14:59,720
decided to build this using a

00:14:57,290 --> 00:15:02,660
microservices architecture and we have

00:14:59,720 --> 00:15:04,250
three micro services we have the account

00:15:02,660 --> 00:15:07,910
management micro service that handles

00:15:04,250 --> 00:15:09,980
account creation and verification we

00:15:07,910 --> 00:15:13,300
have the session service that handles

00:15:09,980 --> 00:15:15,980
user login and issues and auth token and

00:15:13,300 --> 00:15:18,710
then we have the messaging service that

00:15:15,980 --> 00:15:21,670
actually processes sending messages from

00:15:18,710 --> 00:15:21,670
one user to another

00:15:22,490 --> 00:15:28,670
in such a system we might bridge all of

00:15:26,420 --> 00:15:32,330
these microservices together using an

00:15:28,670 --> 00:15:34,520
event bus here's an example when I when

00:15:32,330 --> 00:15:36,200
I create an account the account micro

00:15:34,520 --> 00:15:38,510
service publishes to this event system

00:15:36,200 --> 00:15:39,920
and an account was just created such

00:15:38,510 --> 00:15:43,940
that anybody who is curious about this

00:15:39,920 --> 00:15:45,860
event can subscribe to it and react then

00:15:43,940 --> 00:15:50,080
when that user logs in the session

00:15:45,860 --> 00:15:52,550
service might publish a login event and

00:15:50,080 --> 00:15:53,710
once the users logged in now they're

00:15:52,550 --> 00:15:58,340
free to send messages to other users

00:15:53,710 --> 00:15:59,450
perhaps more than one so this is how

00:15:58,340 --> 00:16:03,290
publishers are going to work in our

00:15:59,450 --> 00:16:06,440
event system now let's say we have an

00:16:03,290 --> 00:16:08,630
interesting requirement when a user logs

00:16:06,440 --> 00:16:10,670
into the session service we notice that

00:16:08,630 --> 00:16:14,180
in some cases accounts are compromised

00:16:10,670 --> 00:16:16,840
surely after we detect we can detect

00:16:14,180 --> 00:16:18,890
logins from vastly different locations

00:16:16,840 --> 00:16:21,230
so we're going to create a new feature

00:16:18,890 --> 00:16:23,840
in our app but we'll call it the alarm

00:16:21,230 --> 00:16:26,090
service and this thing detects

00:16:23,840 --> 00:16:29,500
suspicious login activity and flags the

00:16:26,090 --> 00:16:31,940
account before it can do any damage in

00:16:29,500 --> 00:16:36,230
this case the alarm service is now

00:16:31,940 --> 00:16:38,840
acting as a subscriber when somebody

00:16:36,230 --> 00:16:40,850
logs in the alarm service says hey I'm

00:16:38,840 --> 00:16:44,780
interested in about that login attempt

00:16:40,850 --> 00:16:47,780
and so it subscribes it grabs it off the

00:16:44,780 --> 00:16:49,730
message bus and it looks at it and let's

00:16:47,780 --> 00:16:55,760
say that this login event was I logged

00:16:49,730 --> 00:16:58,760
in from san-francisco but 30 seconds

00:16:55,760 --> 00:17:01,280
later I get another login attempt from

00:16:58,760 --> 00:17:02,810
Singapore and the alarm service may have

00:17:01,280 --> 00:17:06,700
logic that says hey hold on a second

00:17:02,810 --> 00:17:06,700
what's going on let me flag this account

00:17:08,000 --> 00:17:15,199
so that's an example of an event system

00:17:09,909 --> 00:17:16,549
and hopefully that makes sense to

00:17:15,199 --> 00:17:21,140
everybody I don't think this is a this

00:17:16,549 --> 00:17:22,669
is a very complicated example now let's

00:17:21,140 --> 00:17:24,470
just take that entire event system and

00:17:22,669 --> 00:17:28,159
coalesce it into a single box and we put

00:17:24,470 --> 00:17:29,419
up the very top of the diagram now we're

00:17:28,159 --> 00:17:34,070
ready to explain what we saw when we

00:17:29,419 --> 00:17:36,500
executed that subscription instead of

00:17:34,070 --> 00:17:40,460
HTTP requests we know that this is a

00:17:36,500 --> 00:17:44,929
request stream semantics so in this case

00:17:40,460 --> 00:17:46,429
we're sending it over a WebSocket we

00:17:44,929 --> 00:17:49,100
send it to the subscription server and

00:17:46,429 --> 00:17:51,049
the subscription server as before takes

00:17:49,100 --> 00:17:54,049
the graphical document out of the

00:17:51,049 --> 00:17:57,289
request but notice that the document is

00:17:54,049 --> 00:17:59,000
missing a chunk that's because the

00:17:57,289 --> 00:18:06,679
document is only executable in

00:17:59,000 --> 00:18:07,909
association with an event so the other

00:18:06,679 --> 00:18:11,090
thing that the graphical subscription

00:18:07,909 --> 00:18:14,320
server is going to do is inspect this

00:18:11,090 --> 00:18:17,620
document and it's query variables and

00:18:14,320 --> 00:18:20,929
from that derive some set of events or

00:18:17,620 --> 00:18:23,809
from some way to construct the source

00:18:20,929 --> 00:18:26,030
stream so that when the event comes it

00:18:23,809 --> 00:18:29,990
says hey I care about that event give it

00:18:26,030 --> 00:18:32,510
to me and then it has an executable form

00:18:29,990 --> 00:18:37,850
of the document which it can submit for

00:18:32,510 --> 00:18:40,280
parsing validation and execution and if

00:18:37,850 --> 00:18:44,919
all that succeeds then we have a JSON

00:18:40,280 --> 00:18:48,799
response and it goes back to the client

00:18:44,919 --> 00:18:51,650
and the part on the right should look

00:18:48,799 --> 00:18:54,020
very familiar to queries of mutations to

00:18:51,650 --> 00:18:56,570
request response that's not an accident

00:18:54,020 --> 00:19:00,140
that part of the system remains entirely

00:18:56,570 --> 00:19:02,990
stateless and as Dan mentioned the

00:19:00,140 --> 00:19:06,200
evolution of subscriptions is that it

00:19:02,990 --> 00:19:09,220
was incremental it was additive on top

00:19:06,200 --> 00:19:09,220
of the existing system

00:19:11,039 --> 00:19:18,669
now let's take it back to the spec text

00:19:15,120 --> 00:19:20,409
the events the event stream at the top

00:19:18,669 --> 00:19:22,929
was just an example of how you can

00:19:20,409 --> 00:19:26,289
implement a source stream and the

00:19:22,929 --> 00:19:28,179
response stream is down below where

00:19:26,289 --> 00:19:31,230
we're actually using this to send the

00:19:28,179 --> 00:19:33,909
graphical responses down to the client

00:19:31,230 --> 00:19:35,380
so hopefully that demystifies the the

00:19:33,909 --> 00:19:36,669
spec language that we've used to

00:19:35,380 --> 00:19:39,850
describe this I think there's some very

00:19:36,669 --> 00:19:43,770
important things in there and hopefully

00:19:39,850 --> 00:19:43,770
this this this makes it make more sense

00:19:44,309 --> 00:19:47,980
so it's not clear from that from the

00:19:46,450 --> 00:19:49,690
diagram there is the life cycle of a

00:19:47,980 --> 00:19:51,250
subscription and let's just go over that

00:19:49,690 --> 00:19:52,990
really quick we know already that the

00:19:51,250 --> 00:19:57,340
request includes a graphic you'll

00:19:52,990 --> 00:20:00,039
document and the variables but once it

00:19:57,340 --> 00:20:01,960
subscribes on the server we have to

00:20:00,039 --> 00:20:04,450
derive the set of domain specific events

00:20:01,960 --> 00:20:05,860
from the document and the variables in

00:20:04,450 --> 00:20:10,809
other words we have to construct that

00:20:05,860 --> 00:20:13,149
source stream and then we have to

00:20:10,809 --> 00:20:17,260
subscribe to those events on the source

00:20:13,149 --> 00:20:19,390
stream such that whenever an event from

00:20:17,260 --> 00:20:23,370
the source stream occurs we combine it

00:20:19,390 --> 00:20:23,370
with the document and then we execute it

00:20:23,940 --> 00:20:29,440
and of all it all goes according to plan

00:20:28,090 --> 00:20:32,649
then we have a response that we can sign

00:20:29,440 --> 00:20:34,630
back to this to the client so in terms

00:20:32,649 --> 00:20:37,120
of building blocks this means that a

00:20:34,630 --> 00:20:38,799
system that supports graph GL

00:20:37,120 --> 00:20:40,690
subscriptions needs a couple of

00:20:38,799 --> 00:20:43,270
additional components that weren't

00:20:40,690 --> 00:20:46,690
present when the system was stateless

00:20:43,270 --> 00:20:50,890
and only satisfied request response

00:20:46,690 --> 00:20:53,470
style interactions the first is that we

00:20:50,890 --> 00:20:57,279
need to support a persistent streaming

00:20:53,470 --> 00:20:59,919
transport it's no longer sufficient to

00:20:57,279 --> 00:21:05,500
just issue a single request and get back

00:20:59,919 --> 00:21:07,390
a single response second we have to have

00:21:05,500 --> 00:21:08,799
some general-purpose storage because we

00:21:07,390 --> 00:21:12,730
now have state that we need to keep

00:21:08,799 --> 00:21:15,880
track of one example of this state is

00:21:12,730 --> 00:21:18,159
the connection map so who's connected to

00:21:15,880 --> 00:21:21,159
what gateway and how do I send messages

00:21:18,159 --> 00:21:22,299
back to that subscribed client and I

00:21:21,159 --> 00:21:24,790
also keep to have to keep track of the

00:21:22,299 --> 00:21:26,890
subscriber info when somebody subscribes

00:21:24,790 --> 00:21:28,930
who are they what document did they

00:21:26,890 --> 00:21:33,580
subscribe to and what were the variables

00:21:28,930 --> 00:21:36,970
that were included we need an event

00:21:33,580 --> 00:21:40,360
system or some way to construct the

00:21:36,970 --> 00:21:43,510
source stream and lastly we need to be

00:21:40,360 --> 00:21:48,040
able to detect and publish these events

00:21:43,510 --> 00:21:50,920
as we saw from that event system example

00:21:48,040 --> 00:21:53,980
if nothing published there's no way that

00:21:50,920 --> 00:21:56,080
our alarm service would have worked so

00:21:53,980 --> 00:21:58,120
at the moment that the state changes in

00:21:56,080 --> 00:22:00,880
a way that we've identified it as a

00:21:58,120 --> 00:22:09,240
domain-specific event we have to publish

00:22:00,880 --> 00:22:14,020
that fact and that leads me to a warning

00:22:09,240 --> 00:22:15,790
scaling state is hard by and large we

00:22:14,020 --> 00:22:17,230
know how to scale stateless services the

00:22:15,790 --> 00:22:21,670
answer is that we've clone out a bunch

00:22:17,230 --> 00:22:24,580
more but when you have state for example

00:22:21,670 --> 00:22:28,030
all the state that we just described

00:22:24,580 --> 00:22:30,480
them in the past couple slides then you

00:22:28,030 --> 00:22:33,280
have an additional challenge because if

00:22:30,480 --> 00:22:37,840
the node that contains that state goes

00:22:33,280 --> 00:22:40,120
down how does the system react and this

00:22:37,840 --> 00:22:42,490
is not just a technical problem I'm sure

00:22:40,120 --> 00:22:46,000
many of you have heard of the cap

00:22:42,490 --> 00:22:48,700
theorem and when you're trying to scale

00:22:46,000 --> 00:22:50,980
state you now need to understand what

00:22:48,700 --> 00:22:54,370
are the trade-offs that the product

00:22:50,980 --> 00:22:56,940
should make in the event of a network

00:22:54,370 --> 00:22:56,940
partition

00:23:02,430 --> 00:23:07,800
the example the demo that we saw it was

00:23:05,160 --> 00:23:09,810
all running in a single node process so

00:23:07,800 --> 00:23:12,570
let's do a quick exercise and see what

00:23:09,810 --> 00:23:14,190
it looks like to take the single process

00:23:12,570 --> 00:23:15,870
demo the single process subscription

00:23:14,190 --> 00:23:17,340
server and imagine that we wanted to

00:23:15,870 --> 00:23:19,380
remove the rate limit that I had added

00:23:17,340 --> 00:23:21,660
and we want to make it distributed so

00:23:19,380 --> 00:23:22,740
that everybody can you know vote for it

00:23:21,660 --> 00:23:25,770
their favorite house however often they

00:23:22,740 --> 00:23:29,070
want well weren't any more capacity in

00:23:25,770 --> 00:23:31,530
both the single process and distributed

00:23:29,070 --> 00:23:34,530
cases we still need a streaming

00:23:31,530 --> 00:23:36,710
transport and here are some examples of

00:23:34,530 --> 00:23:41,010
what you can use WebSockets

00:23:36,710 --> 00:23:43,260
SSE HTTP long polling and even had a

00:23:41,010 --> 00:23:47,420
great conversation about web hooks

00:23:43,260 --> 00:23:47,420
yesterday that works too

00:23:48,080 --> 00:23:53,070
for connection handling every WebSocket

00:23:51,150 --> 00:23:56,490
connection terminated with that single

00:23:53,070 --> 00:23:58,440
node process but that's not going to cut

00:23:56,490 --> 00:24:02,490
it if we want to deploy this thing at

00:23:58,440 --> 00:24:04,770
scale we need a gateway layer whose job

00:24:02,490 --> 00:24:07,500
it is to terminate these connections and

00:24:04,770 --> 00:24:08,880
to handle these connections in a way

00:24:07,500 --> 00:24:12,960
that is decoupled from the rest of the

00:24:08,880 --> 00:24:15,600
architecture for this force source

00:24:12,960 --> 00:24:17,820
stream if we're continuing to use the

00:24:15,600 --> 00:24:20,700
pub/sub style system as our source

00:24:17,820 --> 00:24:24,170
stream in the single process it's simple

00:24:20,700 --> 00:24:26,910
it's just an event meter in nodejs

00:24:24,170 --> 00:24:29,130
but if we want to go distributed we're

00:24:26,910 --> 00:24:30,990
gonna have to build or we're gonna have

00:24:29,130 --> 00:24:32,250
to add a component that is much better

00:24:30,990 --> 00:24:34,320
at dealing with the state that comes

00:24:32,250 --> 00:24:37,980
with a pub subsystem and we can look to

00:24:34,320 --> 00:24:40,890
Redis Kafka pusher lots of solutions out

00:24:37,980 --> 00:24:43,800
there and then for subscriptions session

00:24:40,890 --> 00:24:46,050
data it suffice in the single process

00:24:43,800 --> 00:24:48,690
case to store this either in memory or

00:24:46,050 --> 00:24:50,700
in a flat file but I'm going to need a

00:24:48,690 --> 00:24:54,800
real database or a cache layer to store

00:24:50,700 --> 00:24:54,800
this information in the distributed case

00:25:00,380 --> 00:25:06,260
all right graph QL subscriptions at

00:25:02,330 --> 00:25:10,400
Facebook you got a preview of this from

00:25:06,260 --> 00:25:11,810
Dan's talk earlier today but if you use

00:25:10,400 --> 00:25:14,030
Facebook you're using graph QL

00:25:11,810 --> 00:25:15,650
subscriptions these are some very

00:25:14,030 --> 00:25:19,040
popular features that are powered by

00:25:15,650 --> 00:25:21,350
graphical subscriptions live likes live

00:25:19,040 --> 00:25:24,680
comments streaming reactions on live

00:25:21,350 --> 00:25:26,600
videos so this should give you an idea

00:25:24,680 --> 00:25:33,320
of the stuff that we've built with this

00:25:26,600 --> 00:25:35,780
system and the current state of it is

00:25:33,320 --> 00:25:39,770
that it's officially part of the

00:25:35,780 --> 00:25:41,720
graphical specification and this was the

00:25:39,770 --> 00:25:44,930
result of a very close collaboration

00:25:41,720 --> 00:25:47,810
between Facebook and members of the

00:25:44,930 --> 00:25:51,110
Apollo team and I couldn't be more proud

00:25:47,810 --> 00:25:53,920
of the outcome it is part of the graph

00:25:51,110 --> 00:25:56,600
kihl-jae s reference implementation

00:25:53,920 --> 00:26:01,120
there is support for it from front-end

00:25:56,600 --> 00:26:03,770
frameworks such as relay and Apollo and

00:26:01,120 --> 00:26:05,930
graph cool is a really cool back-end

00:26:03,770 --> 00:26:14,270
that also supports subscriptions

00:26:05,930 --> 00:26:19,670
out-of-the-box all right now let's talk

00:26:14,270 --> 00:26:23,770
about live queries subscriptions is not

00:26:19,670 --> 00:26:26,090
the only way to do reactive graph QL

00:26:23,770 --> 00:26:30,050
we've talked about this concept of a

00:26:26,090 --> 00:26:33,170
live query for a while now and VI the

00:26:30,050 --> 00:26:37,190
idea is very simple you take an existing

00:26:33,170 --> 00:26:41,120
query and you add an at live directive

00:26:37,190 --> 00:26:43,430
to it send it to the server and instead

00:26:41,120 --> 00:26:44,950
of getting a single response you're

00:26:43,430 --> 00:26:46,880
gonna get a stream of responses that

00:26:44,950 --> 00:26:50,330
simulates what you would have received

00:26:46,880 --> 00:26:53,180
had you pulled that query infinitely

00:26:50,330 --> 00:26:54,290
fast it's just that the server is making

00:26:53,180 --> 00:26:58,340
that operation

00:26:54,290 --> 00:27:00,290
much more efficient so because we have

00:26:58,340 --> 00:27:03,610
these two ways of doing reactive graph

00:27:00,290 --> 00:27:07,040
QL we frequently get this question of

00:27:03,610 --> 00:27:12,940
well what are the differences what

00:27:07,040 --> 00:27:12,940
should I use and I think

00:27:13,190 --> 00:27:19,620
the long answer to that is going to be

00:27:17,010 --> 00:27:22,440
in Rodrigo's talk tomorrow which I

00:27:19,620 --> 00:27:25,280
highly recommend you attend it's going

00:27:22,440 --> 00:27:28,680
to have a lot of really interesting

00:27:25,280 --> 00:27:31,650
details for our journey and building

00:27:28,680 --> 00:27:33,750
live queries and I stole this slide from

00:27:31,650 --> 00:27:36,870
Rodrigo's talk because I think it is so

00:27:33,750 --> 00:27:38,280
good at summarizing the difference the

00:27:36,870 --> 00:27:39,720
difference between subscriptions and

00:27:38,280 --> 00:27:44,400
live queries is the difference between

00:27:39,720 --> 00:27:46,230
observing state and preserving events if

00:27:44,400 --> 00:27:50,490
we have a value that changes over time

00:27:46,230 --> 00:27:53,270
and at t and t plus 1 T plus 2 etc we

00:27:50,490 --> 00:27:56,580
sample the value the difference between

00:27:53,270 --> 00:27:58,680
subscriptions is whether you absorbing

00:27:56,580 --> 00:28:00,960
the state change itself the value itself

00:27:58,680 --> 00:28:03,210
or you an observed you're observing an

00:28:00,960 --> 00:28:08,130
event for example that the value is

00:28:03,210 --> 00:28:12,630
incremented by X okay so for example

00:28:08,130 --> 00:28:19,530
let's say the value at T was 5 and the

00:28:12,630 --> 00:28:22,200
value at T 2 and T 3 was 15 you could

00:28:19,530 --> 00:28:24,810
have made that transition either via a

00:28:22,200 --> 00:28:28,740
subscription that said or an event that

00:28:24,810 --> 00:28:30,270
said the value is incremented by 10 or

00:28:28,740 --> 00:28:32,400
you could have simply observed that the

00:28:30,270 --> 00:28:40,970
state made that change and then deduced

00:28:32,400 --> 00:28:40,970
that the value changed by 10 and

00:28:41,100 --> 00:28:49,289
as I like to say there's there's no

00:28:44,419 --> 00:28:57,169
there's no silver lunch and there is

00:28:49,289 --> 00:28:59,910
also no slide either yeah so this is the

00:28:57,169 --> 00:29:01,320
so here are the trade offs to summarize

00:28:59,910 --> 00:29:04,500
the differences between subscriptions

00:29:01,320 --> 00:29:06,750
and live queries let's begin with the

00:29:04,500 --> 00:29:09,809
requirements that they both require this

00:29:06,750 --> 00:29:11,940
concept of a streaming transport but

00:29:09,809 --> 00:29:13,620
beyond that when you consume these you

00:29:11,940 --> 00:29:18,480
need some sort of reactive API or

00:29:13,620 --> 00:29:20,070
language an example of this is that as

00:29:18,480 --> 00:29:22,530
we as we add this to the specification

00:29:20,070 --> 00:29:24,120
we discovered that a mechanism like an

00:29:22,530 --> 00:29:25,470
async iterator and JavaScript is really

00:29:24,120 --> 00:29:30,330
useful for modeling this kind of thing

00:29:25,470 --> 00:29:32,490
or observables if you like those for

00:29:30,330 --> 00:29:35,250
subscriptions we need something that can

00:29:32,490 --> 00:29:36,510
constitute the source stream and most

00:29:35,250 --> 00:29:40,380
often that is going to be some kind of

00:29:36,510 --> 00:29:44,309
event bust but for live queries we need

00:29:40,380 --> 00:29:46,020
a reactive data layer and the asterisk

00:29:44,309 --> 00:29:48,330
is that this is this is a very

00:29:46,020 --> 00:29:51,360
interesting problem and it requires a

00:29:48,330 --> 00:29:54,960
lot of creative solutions as for

00:29:51,360 --> 00:29:56,220
benefits subscriptions one of

00:29:54,960 --> 00:30:00,570
subscription event triggers you know

00:29:56,220 --> 00:30:02,130
exactly why the data changed whereas you

00:30:00,570 --> 00:30:05,370
may have to reconstruct that information

00:30:02,130 --> 00:30:10,380
by dipping the states in the live query

00:30:05,370 --> 00:30:13,140
case for subscriptions you also have

00:30:10,380 --> 00:30:16,350
fine control over the publish so the the

00:30:13,140 --> 00:30:20,850
end-to-end flow of why did this thing

00:30:16,350 --> 00:30:23,490
trigger is more explicit and on the live

00:30:20,850 --> 00:30:25,650
query side you can theoretically convert

00:30:23,490 --> 00:30:27,870
any existing standing standing query

00:30:25,650 --> 00:30:30,450
into a live query and you can also fall

00:30:27,870 --> 00:30:35,549
back from a live query to polling which

00:30:30,450 --> 00:30:37,559
is very useful and then once you have

00:30:35,549 --> 00:30:40,289
your reactive data layer no other

00:30:37,559 --> 00:30:43,070
server-side changes are required to

00:30:40,289 --> 00:30:43,070
enable live queries

00:30:49,440 --> 00:30:56,560
so that's it here are the resources with

00:30:55,120 --> 00:30:59,620
links to everything that I that I talked

00:30:56,560 --> 00:31:01,600
about I think I'm a little over time but

00:30:59,620 --> 00:31:06,640
the takeaways I wanted to leave you with

00:31:01,600 --> 00:31:08,860
our subscriptions that demo that I

00:31:06,640 --> 00:31:10,960
showed you was built entirely with open

00:31:08,860 --> 00:31:14,110
source components using the Apollo

00:31:10,960 --> 00:31:16,330
client so definitely go check that out

00:31:14,110 --> 00:31:18,660
it's really great work

00:31:16,330 --> 00:31:21,670
check out the specification and

00:31:18,660 --> 00:31:23,050
definitely check out you know services

00:31:21,670 --> 00:31:27,210
like Graff cool that let you get up and

00:31:23,050 --> 00:31:29,410
running with subscriptions very quickly

00:31:27,210 --> 00:31:35,910
okay thank you very much

00:31:29,410 --> 00:31:35,910

YouTube URL: https://www.youtube.com/watch?v=PsjiL6Yl1ag


