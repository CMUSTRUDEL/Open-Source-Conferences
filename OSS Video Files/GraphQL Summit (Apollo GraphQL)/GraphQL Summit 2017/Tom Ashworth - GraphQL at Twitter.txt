Title: Tom Ashworth - GraphQL at Twitter
Publication date: 2017-11-08
Playlist: GraphQL Summit 2017
Description: 
	Tom Ashworth, Software Engineer at Twitter, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

This is the story of how we introduced GraphQL at Twitter, from prototype to a production system serving tens of millions of queries every day. We'll look at the challenges of GraphQL in a massive microservices system with a huge existing API surface area and many clients, as well as how to build a GraphQL service for safety from the start. We'll cover some difficulties you run into at a large company and finally share a little about some exciting Twitter technology that could super-power GraphQL in the future.
Captions: 
	00:00:03,290 --> 00:00:08,029
cool at first I just want to say thank

00:00:06,680 --> 00:00:09,920
you to Lee for doing such a great job

00:00:08,029 --> 00:00:11,630
over the last couple of days as our

00:00:09,920 --> 00:00:14,620
emcee I think we should all give them a

00:00:11,630 --> 00:00:14,620
big round of applause for the job

00:00:17,090 --> 00:00:23,279
so um I'm Tom I work on graph QL in the

00:00:21,210 --> 00:00:25,500
core services team at Twitter where I've

00:00:23,279 --> 00:00:27,930
been for about four years now already

00:00:25,500 --> 00:00:29,760
you might have noticed my accent I work

00:00:27,930 --> 00:00:31,410
in London and to be honest I get a lot

00:00:29,760 --> 00:00:33,750
of trouble at the American border

00:00:31,410 --> 00:00:35,879
because TSA agents don't understand me

00:00:33,750 --> 00:00:37,739
when I say Twitter so a quick

00:00:35,879 --> 00:00:43,800
translation for you for the purposes of

00:00:37,739 --> 00:00:46,170
this talk Twitter equals Twitter because

00:00:43,800 --> 00:00:47,640
it turns out the T's are important so

00:00:46,170 --> 00:00:48,600
just you know just for the rest of the

00:00:47,640 --> 00:00:52,380
talk because I'm going to say to her -

00:00:48,600 --> 00:00:54,750
quite a lot thanks for that um so now

00:00:52,380 --> 00:00:56,430
something just quickly so kind of

00:00:54,750 --> 00:00:57,989
serious business and I realize it in

00:00:56,430 --> 00:01:00,690
speaking at this conference I am the

00:00:57,989 --> 00:01:03,480
next in a large group of men often white

00:01:00,690 --> 00:01:04,920
who have spoken today and yesterday and

00:01:03,480 --> 00:01:06,270
I want to acknowledge and thank the

00:01:04,920 --> 00:01:07,890
conference team for all their work

00:01:06,270 --> 00:01:10,320
trying to fix this I will try to address

00:01:07,890 --> 00:01:12,119
this but it's a community problem and I

00:01:10,320 --> 00:01:13,770
hope we can all work together to make

00:01:12,119 --> 00:01:15,180
sure that the community is as diverse as

00:01:13,770 --> 00:01:18,410
the ideas that have been discussed over

00:01:15,180 --> 00:01:18,410
the last two days

00:01:23,869 --> 00:01:29,420
okay so I have fiftyish slides in 25

00:01:27,289 --> 00:01:33,049
minutes although I'm lust so I could

00:01:29,420 --> 00:01:34,579
keep you all night let's go so at the

00:01:33,049 --> 00:01:36,319
conference we've heard about a huge

00:01:34,579 --> 00:01:37,969
range of amazing things that people are

00:01:36,319 --> 00:01:40,039
doing with graph QL as well as practical

00:01:37,969 --> 00:01:42,439
advice on how to make the technology

00:01:40,039 --> 00:01:43,579
work in your particular situation so in

00:01:42,439 --> 00:01:46,009
this talk I'm not going to blow your

00:01:43,579 --> 00:01:47,420
mind with incredible new applications of

00:01:46,009 --> 00:01:49,250
graph QL because you've seen enough of

00:01:47,420 --> 00:01:51,079
those already instead I'll talk about

00:01:49,250 --> 00:01:52,819
the specific challenges of graph QL at

00:01:51,079 --> 00:01:54,979
Twitter and I'll give you a sense of the

00:01:52,819 --> 00:01:56,750
choices we've made I'll also show you

00:01:54,979 --> 00:01:59,329
how we've implemented subscriptions and

00:01:56,750 --> 00:02:01,579
then look ahead a bit how we plan to

00:01:59,329 --> 00:02:04,670
sustainably grow and develop our graph

00:02:01,579 --> 00:02:06,709
QL API into the future first some

00:02:04,670 --> 00:02:08,539
interactive interactivity with a quick

00:02:06,709 --> 00:02:11,620
survey so hands up if you consider

00:02:08,539 --> 00:02:13,040
yourself a back-end or server engineer

00:02:11,620 --> 00:02:14,599
okay cool

00:02:13,040 --> 00:02:18,319
what about front-end or client side

00:02:14,599 --> 00:02:19,970
engineer oh and what about like full

00:02:18,319 --> 00:02:20,959
stack kind of there's gonna be a few

00:02:19,970 --> 00:02:23,329
people who already put their hands up

00:02:20,959 --> 00:02:25,730
and okay so hands up if you're using

00:02:23,329 --> 00:02:27,290
graph QL in any way as part of a side

00:02:25,730 --> 00:02:29,510
project some experiment you're doing or

00:02:27,290 --> 00:02:31,609
at work cool but it's not everyone and

00:02:29,510 --> 00:02:32,660
that's that's really exciting now keep

00:02:31,609 --> 00:02:34,579
your hand up or I guess they've gone

00:02:32,660 --> 00:02:37,670
down already but if I feel using graph

00:02:34,579 --> 00:02:39,380
QL at work in production yeah

00:02:37,670 --> 00:02:40,760
interesting interesting so maybe people

00:02:39,380 --> 00:02:41,959
who didn't put their hands up yet go

00:02:40,760 --> 00:02:42,920
talk to those people who just brought

00:02:41,959 --> 00:02:46,040
their hands that find out a bit more

00:02:42,920 --> 00:02:47,090
about what you can do and lastly hands

00:02:46,040 --> 00:02:52,480
up if you're using graphic your

00:02:47,090 --> 00:02:54,349
subscriptions in production cool okay um

00:02:52,480 --> 00:02:56,419
thanks thanks a lot for that's really

00:02:54,349 --> 00:02:58,370
interesting so this talk as I said will

00:02:56,419 --> 00:02:59,959
broadly cover three areas the first

00:02:58,370 --> 00:03:01,849
section is about how the Twitter graph

00:02:59,959 --> 00:03:03,919
QL API fits into the large existing

00:03:01,849 --> 00:03:06,019
ecosystem of micro services at Twitter

00:03:03,919 --> 00:03:07,519
then we'll talk about our subscriptions

00:03:06,019 --> 00:03:08,630
architecture which might make an

00:03:07,519 --> 00:03:11,810
interesting comparison to what you just

00:03:08,630 --> 00:03:13,760
heard from Rodrigo about their live

00:03:11,810 --> 00:03:15,380
subscriptions architecture and from Rob

00:03:13,760 --> 00:03:17,630
about Facebook subscriptions

00:03:15,380 --> 00:03:19,419
architecture and lastly we'll look at

00:03:17,630 --> 00:03:21,919
our plan for graph QL in the long term

00:03:19,419 --> 00:03:24,169
so let's start with the Twitter graph QL

00:03:21,919 --> 00:03:27,230
API so Twitter has been experimenting

00:03:24,169 --> 00:03:28,730
with graph QL for over two years and

00:03:27,230 --> 00:03:30,410
it's only really in the last year that

00:03:28,730 --> 00:03:32,780
we've started to drive adoption in

00:03:30,410 --> 00:03:34,370
Twitter light Android iOS and TweetDeck

00:03:32,780 --> 00:03:34,810
clients I used to work on tweet deck so

00:03:34,370 --> 00:03:37,360
that

00:03:34,810 --> 00:03:39,099
why it was first so if you if you've

00:03:37,360 --> 00:03:41,550
used any of these then you probably have

00:03:39,099 --> 00:03:44,500
used Twitter graph QL in some small way

00:03:41,550 --> 00:03:45,069
because it's not 100% yet but we're

00:03:44,500 --> 00:03:47,290
working on it

00:03:45,069 --> 00:03:49,330
Twitter is famously a microservices

00:03:47,290 --> 00:03:50,860
company there's a service for everything

00:03:49,330 --> 00:03:53,500
and there's often multiple new services

00:03:50,860 --> 00:03:55,360
for any new feature we built it's hard

00:03:53,500 --> 00:03:56,349
to be sure exactly how many production

00:03:55,360 --> 00:03:57,940
services there are and though that

00:03:56,349 --> 00:03:59,200
sounds a bit strange but things are

00:03:57,940 --> 00:04:00,730
coming up and going down all the time

00:03:59,200 --> 00:04:02,200
and it's sometimes not clear you know

00:04:00,730 --> 00:04:04,769
which services are deprecated and which

00:04:02,200 --> 00:04:07,330
ones new but I counted the number of

00:04:04,769 --> 00:04:10,530
configuration files for deployments in

00:04:07,330 --> 00:04:12,640
our mono repo and I found over 2000 and

00:04:10,530 --> 00:04:14,590
remember each of these each of these

00:04:12,640 --> 00:04:16,209
circles on the screen is actually a

00:04:14,590 --> 00:04:18,040
cluster of instances of the same service

00:04:16,209 --> 00:04:20,650
sized according to traffic requirements

00:04:18,040 --> 00:04:22,120
so we've got a lot going on most of

00:04:20,650 --> 00:04:27,400
these services fit into one of a couple

00:04:22,120 --> 00:04:30,310
of types Wow this is like this is frozen

00:04:27,400 --> 00:04:33,250
and so the first kind is HTTP services

00:04:30,310 --> 00:04:36,760
Wow I messed up my slide somehow this is

00:04:33,250 --> 00:04:40,150
pretty cool okay um the the first kind

00:04:36,760 --> 00:04:42,910
of service is an HTTP service they

00:04:40,150 --> 00:04:45,130
receive HTTP requests from all of you on

00:04:42,910 --> 00:04:47,440
your phones on the web on Apple TV or

00:04:45,130 --> 00:04:48,850
wherever you're using Twitter each API

00:04:47,440 --> 00:04:51,190
service tends to be responsible for

00:04:48,850 --> 00:04:53,440
handling requests to a few API endpoints

00:04:51,190 --> 00:04:54,630
rendering JSON responses and making

00:04:53,440 --> 00:04:58,600
calls to the next layer

00:04:54,630 --> 00:05:01,870
thrift services which will come up at

00:04:58,600 --> 00:05:05,370
some point Wow oh look at that

00:05:01,870 --> 00:05:07,840
transition speed oh my goodness

00:05:05,370 --> 00:05:08,200
thrift services cool thank you Google

00:05:07,840 --> 00:05:10,630
slides

00:05:08,200 --> 00:05:11,979
loving it and thrift is a remote

00:05:10,630 --> 00:05:14,110
procedure call system that she's

00:05:11,979 --> 00:05:16,060
extensively at Twitter Facebook and many

00:05:14,110 --> 00:05:18,340
other companies each of these services

00:05:16,060 --> 00:05:20,289
exposes an asynchronous typed interface

00:05:18,340 --> 00:05:22,419
that means almost all communication

00:05:20,289 --> 00:05:25,000
between Twitter micro services is

00:05:22,419 --> 00:05:27,430
already already users types they're not

00:05:25,000 --> 00:05:28,660
graph QL types but they are types by the

00:05:27,430 --> 00:05:29,950
way if you're working on a new micro

00:05:28,660 --> 00:05:31,930
services and micro service architecture

00:05:29,950 --> 00:05:33,550
take a look at RPC technologies like

00:05:31,930 --> 00:05:35,440
thrift because they are pretty

00:05:33,550 --> 00:05:37,180
beneficial in a lot of ways and like all

00:05:35,440 --> 00:05:39,310
good ideas this was invented in the 60s

00:05:37,180 --> 00:05:43,240
and you have 50 years worth of work and

00:05:39,310 --> 00:05:44,680
production experience to rely on whoa

00:05:43,240 --> 00:05:48,669
what's going on

00:05:44,680 --> 00:05:49,960
with the slides I hope not all the

00:05:48,669 --> 00:05:54,789
transitions are like this because that

00:05:49,960 --> 00:05:56,380
would be that would be frustrating okay

00:05:54,789 --> 00:05:59,080
here's an example thrift service

00:05:56,380 --> 00:06:01,419
description that simply multiplies two

00:05:59,080 --> 00:06:04,150
numbers you can see that it's just just

00:06:01,419 --> 00:06:06,280
an interface takes naina bian and would

00:06:04,150 --> 00:06:08,710
multiply them and from this interface

00:06:06,280 --> 00:06:10,210
you can generate you can code Jen

00:06:08,710 --> 00:06:12,250
servers and clients to implement the

00:06:10,210 --> 00:06:14,229
interface and by the way this is

00:06:12,250 --> 00:06:16,150
hopefully the only Java you've seen at

00:06:14,229 --> 00:06:20,889
this whole conference and not even sorry

00:06:16,150 --> 00:06:23,110
that I made you look at Java so graph

00:06:20,889 --> 00:06:25,560
Cal fits into this picture as an HTTP

00:06:23,110 --> 00:06:27,759
and thrift service alongside the others

00:06:25,560 --> 00:06:30,009
it uses a range of data sources

00:06:27,759 --> 00:06:33,009
including existing HTTP endpoints and

00:06:30,009 --> 00:06:34,270
other thrift services this is pretty

00:06:33,009 --> 00:06:35,380
similar to the Gateway pattern that

00:06:34,270 --> 00:06:37,449
we've heard a lot about over the last

00:06:35,380 --> 00:06:38,860
couple of days and remember

00:06:37,449 --> 00:06:40,630
communication between all our micro

00:06:38,860 --> 00:06:42,910
services is already typed using thrift

00:06:40,630 --> 00:06:44,199
and that sounds a lot like some of the

00:06:42,910 --> 00:06:46,840
graphic your native patterns that we've

00:06:44,199 --> 00:06:48,699
heard about it as well turns out the

00:06:46,840 --> 00:06:50,530
graph QL community isn't the first to

00:06:48,699 --> 00:06:53,680
find service to service type systems

00:06:50,530 --> 00:06:56,530
useful and because we're a short scholar

00:06:53,680 --> 00:06:58,389
shop we're using the fantastic sangria

00:06:56,530 --> 00:07:00,580
library and I want to give a big shout

00:06:58,389 --> 00:07:02,380
out Olek who couldn't be here today for

00:07:00,580 --> 00:07:03,880
his incredible work on this project

00:07:02,380 --> 00:07:06,250
Thank You Oleg and thank you to the

00:07:03,880 --> 00:07:07,570
wider sangria community in fact I would

00:07:06,250 --> 00:07:09,099
just like to show some love to all the

00:07:07,570 --> 00:07:10,900
open-source maintainer in the graph kale

00:07:09,099 --> 00:07:14,029
community with a big round of applause

00:07:10,900 --> 00:07:14,029
[Applause]

00:07:16,430 --> 00:07:20,760
so let's dive into some of the

00:07:18,540 --> 00:07:22,530
challenges launching graph QL at Twitter

00:07:20,760 --> 00:07:24,960
to start with we're going to talk about

00:07:22,530 --> 00:07:26,580
monitoring and and by the way shout out

00:07:24,960 --> 00:07:29,460
to drew for covering this earlier in his

00:07:26,580 --> 00:07:30,630
lightning talk I was just watching it

00:07:29,460 --> 00:07:32,910
going I don't need to say any of the

00:07:30,630 --> 00:07:34,980
things that are hit in my in my talk so

00:07:32,910 --> 00:07:36,690
Twitter engineers are responsible for

00:07:34,980 --> 00:07:38,940
the on-call monitoring and alerting of

00:07:36,690 --> 00:07:41,640
the services they built most of the time

00:07:38,940 --> 00:07:43,800
API services are monitored primarily

00:07:41,640 --> 00:07:46,740
using a percentage success rate based on

00:07:43,800 --> 00:07:50,010
the number of HTTP 5-xx responses you

00:07:46,740 --> 00:07:52,950
generate in most HTTP services serious

00:07:50,010 --> 00:07:54,260
errors result in a 500 or a 5 or 3 which

00:07:52,950 --> 00:07:56,670
is really easily detectable

00:07:54,260 --> 00:07:58,580
however graph QL is capable of

00:07:56,670 --> 00:08:00,780
representing partial success and

00:07:58,580 --> 00:08:02,790
shouldn't blow up just because one part

00:08:00,780 --> 00:08:04,290
of the request failed this makes

00:08:02,790 --> 00:08:05,970
tracking success rate a little bit

00:08:04,290 --> 00:08:08,130
difficult graph QL will nearly always

00:08:05,970 --> 00:08:10,770
succeed with the 200 even if it didn't

00:08:08,130 --> 00:08:13,140
manage to fetch any data so instead we

00:08:10,770 --> 00:08:14,610
track exceptions per query for every

00:08:13,140 --> 00:08:16,890
graph QL query we track the number

00:08:14,610 --> 00:08:19,290
exceptions generated IRA gated over a

00:08:16,890 --> 00:08:21,000
minute we should see fewer than one or

00:08:19,290 --> 00:08:23,610
two exceptions per several thousand

00:08:21,000 --> 00:08:25,200
queries that then becomes our success

00:08:23,610 --> 00:08:27,030
rate metric and we can build dashboards

00:08:25,200 --> 00:08:28,410
and alerts the page engineers if the

00:08:27,030 --> 00:08:31,410
acceptance per query number gets too

00:08:28,410 --> 00:08:34,020
high we also use graph Gale specific

00:08:31,410 --> 00:08:36,000
defenses to protect the API imagine a

00:08:34,020 --> 00:08:37,919
pathological query case followers of

00:08:36,000 --> 00:08:39,890
followers of followers of followers we

00:08:37,919 --> 00:08:42,300
have two defenses complexity and depth

00:08:39,890 --> 00:08:45,120
first we measure query complexity we

00:08:42,300 --> 00:08:47,580
assign a score or a cost to and work out

00:08:45,120 --> 00:08:49,590
the total cost of the query so fetching

00:08:47,580 --> 00:08:51,210
10 follow IDs cost 10 query points and

00:08:49,590 --> 00:08:52,620
fetching a user's data cost 10 query

00:08:51,210 --> 00:08:55,590
points then fetching your top 10

00:08:52,620 --> 00:08:57,030
followers would cost you 110 this is the

00:08:55,590 --> 00:08:58,410
complexity of the query and we can

00:08:57,030 --> 00:09:00,660
measure it before the query is executed

00:08:58,410 --> 00:09:03,750
and that's really important by choosing

00:09:00,660 --> 00:09:05,790
a maximum complexity we can reject any

00:09:03,750 --> 00:09:08,010
queries that would be too costly for our

00:09:05,790 --> 00:09:09,600
back-end we can also defend against

00:09:08,010 --> 00:09:12,180
malicious queries using query depth

00:09:09,600 --> 00:09:13,980
measurement this is simply a query tree

00:09:12,180 --> 00:09:15,390
height measurement so for example we

00:09:13,980 --> 00:09:17,100
could choose that if you go more than 15

00:09:15,390 --> 00:09:18,900
or 20 followers deep your query is

00:09:17,100 --> 00:09:21,720
rejected it's a pretty blunt tool but it

00:09:18,900 --> 00:09:23,520
can be quite useful but more importantly

00:09:21,720 --> 00:09:25,800
we don't allow arbitrary queries to be

00:09:23,520 --> 00:09:28,140
run in production all queries must have

00:09:25,800 --> 00:09:29,850
been submitted validated and store

00:09:28,140 --> 00:09:32,280
in exchange for an ID before they can be

00:09:29,850 --> 00:09:33,870
used by a client in production we call

00:09:32,280 --> 00:09:34,920
these thought operations although as

00:09:33,870 --> 00:09:37,860
you've heard they're also known as

00:09:34,920 --> 00:09:39,420
persisted queries in the community this

00:09:37,860 --> 00:09:41,640
restriction means attackers can't probe

00:09:39,420 --> 00:09:43,080
our graph QL API or run introspection

00:09:41,640 --> 00:09:45,270
queries against it to find out what data

00:09:43,080 --> 00:09:47,190
is available stood operations were

00:09:45,270 --> 00:09:48,750
around for day one of Twitter graph QL

00:09:47,190 --> 00:09:50,250
because we were fairly sure that as soon

00:09:48,750 --> 00:09:52,020
as a new Twitter API was public

00:09:50,250 --> 00:09:55,170
knowledge we'd get people sniffing at it

00:09:52,020 --> 00:09:56,550
to find vulnerabilities lastly on this

00:09:55,170 --> 00:09:57,630
topic I've seen a lot of discussion in

00:09:56,550 --> 00:09:59,610
the community about how to handle

00:09:57,630 --> 00:10:01,980
authentication and authorization so

00:09:59,610 --> 00:10:03,210
here's how we do it an antagonist it's a

00:10:01,980 --> 00:10:04,710
lot like Toni's talk from earlier so

00:10:03,210 --> 00:10:07,650
thank you Tony for again covering half

00:10:04,710 --> 00:10:10,320
of my slides returning to this diagram I

00:10:07,650 --> 00:10:12,330
want to introduce you to TFE transition

00:10:10,320 --> 00:10:14,970
time how that one worked amazing

00:10:12,330 --> 00:10:16,740
TFE Twitter front end I was gonna do a

00:10:14,970 --> 00:10:19,290
robot dance to like distract you but um

00:10:16,740 --> 00:10:21,180
I imagine TFE as a layer between the

00:10:19,290 --> 00:10:23,130
outside world and all of our services

00:10:21,180 --> 00:10:24,990
inside Twitter technically it functions

00:10:23,130 --> 00:10:27,930
as a reverse proxy api gateway and

00:10:24,990 --> 00:10:30,060
Rueter a large part of TFS job is to

00:10:27,930 --> 00:10:31,230
authenticate incoming requests we

00:10:30,060 --> 00:10:33,120
support a few types of authentication

00:10:31,230 --> 00:10:35,430
and it's impractical for each underlying

00:10:33,120 --> 00:10:37,200
service to support every type so instead

00:10:35,430 --> 00:10:40,020
we use one standard authentication

00:10:37,200 --> 00:10:41,580
scheme between services let's imagine a

00:10:40,020 --> 00:10:44,790
request to API twitter.com that's

00:10:41,580 --> 00:10:46,350
authenticated using a cookie header once

00:10:44,790 --> 00:10:47,880
the request is pass-through TFE the

00:10:46,350 --> 00:10:49,770
original authentication scheme is

00:10:47,880 --> 00:10:52,170
normalized into a bundle that we call

00:10:49,770 --> 00:10:53,580
Twitter identity assertion validating a

00:10:52,170 --> 00:10:55,860
cookie is fairly involved to that work

00:10:53,580 --> 00:10:57,240
is done in TFE TFE then generates a

00:10:55,860 --> 00:10:58,980
bundle of these identity assertion

00:10:57,240 --> 00:11:00,450
headers and passes them on to the

00:10:58,980 --> 00:11:03,540
service that will serve the request in

00:11:00,450 --> 00:11:05,040
our case that's graph QL graph QL then

00:11:03,540 --> 00:11:07,020
just propagates this bundle through to

00:11:05,040 --> 00:11:08,490
other services nobody has to worry about

00:11:07,020 --> 00:11:11,130
the messy details of how to authenticate

00:11:08,490 --> 00:11:13,080
the original incoming requests instead

00:11:11,130 --> 00:11:14,670
we can just do integrity checks on the

00:11:13,080 --> 00:11:16,560
signature to verify that authentication

00:11:14,670 --> 00:11:19,710
happened it was valid and then nobody's

00:11:16,560 --> 00:11:21,030
messed with it since our graph you graph

00:11:19,710 --> 00:11:22,920
kya layer has no opinion about

00:11:21,030 --> 00:11:24,780
authorization either each of the

00:11:22,920 --> 00:11:26,670
underlying services is responsible for

00:11:24,780 --> 00:11:29,480
it and again thanks to Tony for

00:11:26,670 --> 00:11:31,800
explaining this better than I can

00:11:29,480 --> 00:11:33,480
next I want to talk about how we have

00:11:31,800 --> 00:11:35,850
built support for graph QR subscriptions

00:11:33,480 --> 00:11:37,320
at Twitter and have to thank Rob for

00:11:35,850 --> 00:11:38,580
setting me up so well for this part of

00:11:37,320 --> 00:11:39,570
the talk because they're building box I

00:11:38,580 --> 00:11:41,850
will be talking about

00:11:39,570 --> 00:11:43,380
very similar to his and that means I can

00:11:41,850 --> 00:11:46,860
move really fast because you already

00:11:43,380 --> 00:11:47,880
understand it or already um I also want

00:11:46,860 --> 00:11:49,890
to thank Rob for some in-depth

00:11:47,880 --> 00:11:51,450
discussion of Graff kya Europe that

00:11:49,890 --> 00:11:55,860
helps shape and validate our approach to

00:11:51,450 --> 00:11:57,090
this problem so react to Europe react

00:11:55,860 --> 00:11:59,190
Europe a few years ago

00:11:57,090 --> 00:12:01,470
Lanie described Graff your subscriptions

00:11:59,190 --> 00:12:03,150
like this I really like it and I'm going

00:12:01,470 --> 00:12:05,220
to structure the discussion of

00:12:03,150 --> 00:12:06,840
subscriptions around it clients

00:12:05,220 --> 00:12:08,340
subscribe to an event occurring in the

00:12:06,840 --> 00:12:10,560
backend with a graph QL query and

00:12:08,340 --> 00:12:12,270
receive payloads those payloads

00:12:10,560 --> 00:12:15,990
represent the result of running the

00:12:12,270 --> 00:12:17,310
query document against an event our

00:12:15,990 --> 00:12:18,960
subscription system divides the

00:12:17,310 --> 00:12:21,830
functionality in a similar way to this

00:12:18,960 --> 00:12:23,850
quotation events queries and payloads

00:12:21,830 --> 00:12:25,290
we've worked hard to define clear

00:12:23,850 --> 00:12:26,340
boundaries between each and this allows

00:12:25,290 --> 00:12:28,440
us to work on each component

00:12:26,340 --> 00:12:29,670
independently and allows each part of

00:12:28,440 --> 00:12:31,020
the system to hide some of the

00:12:29,670 --> 00:12:33,450
complexity of the others in their

00:12:31,020 --> 00:12:36,090
implementation so first let's talk about

00:12:33,450 --> 00:12:37,980
events Twitter already has an extensive

00:12:36,090 --> 00:12:39,240
pub subsystem with hundreds of thousands

00:12:37,980 --> 00:12:41,100
of different kinds of events flowing

00:12:39,240 --> 00:12:42,780
through it it's called event bus and

00:12:41,100 --> 00:12:44,370
with graph Cal subscriptions we wanted

00:12:42,780 --> 00:12:47,010
to give clients access to this rich

00:12:44,370 --> 00:12:49,890
stream of data event bus is a

00:12:47,010 --> 00:12:51,720
distributed queue system event produces

00:12:49,890 --> 00:12:53,940
a services that publish events to event

00:12:51,720 --> 00:12:55,560
bus and subscribers or services that

00:12:53,940 --> 00:12:58,050
subscribe to event bus in order to

00:12:55,560 --> 00:12:59,520
receive events to expose this data to

00:12:58,050 --> 00:13:02,400
graph QL we built a subscription service

00:12:59,520 --> 00:13:03,810
that subscribes to event bus streams the

00:13:02,400 --> 00:13:06,330
service is separate from the graph QL

00:13:03,810 --> 00:13:07,920
API it's stateful and it scales very

00:13:06,330 --> 00:13:10,650
differently to the to the graph QL API

00:13:07,920 --> 00:13:11,970
and that's why we separated it so we

00:13:10,650 --> 00:13:14,760
have a service that's picking up events

00:13:11,970 --> 00:13:18,180
from event bus next we need to hook

00:13:14,760 --> 00:13:20,310
those events up to queries this is what

00:13:18,180 --> 00:13:21,930
our graph QL API is good at and in our

00:13:20,310 --> 00:13:24,300
subscriptions design we extended the

00:13:21,930 --> 00:13:26,370
graph QL API to execute graph QL queries

00:13:24,300 --> 00:13:29,730
against an event that supplied as part

00:13:26,370 --> 00:13:31,530
of the request that means that it

00:13:29,730 --> 00:13:33,330
receives both a query and an event and

00:13:31,530 --> 00:13:36,150
uses the event as the basis for query

00:13:33,330 --> 00:13:37,230
execution this is actually a thrift

00:13:36,150 --> 00:13:39,240
interface like the one I mentioned

00:13:37,230 --> 00:13:43,830
earlier on meaning we're using graph QL

00:13:39,240 --> 00:13:45,480
over thrift as well as HTTP this JSON

00:13:43,830 --> 00:13:47,850
bundle on the screen is an example of

00:13:45,480 --> 00:13:49,980
something the API might receive it will

00:13:47,850 --> 00:13:52,350
run the query against the event from the

00:13:49,980 --> 00:13:52,820
point of view of the supplied user in

00:13:52,350 --> 00:13:54,290
this

00:13:52,820 --> 00:13:55,760
we keep the graph QL API solely

00:13:54,290 --> 00:13:57,800
concerned with executing graph QL

00:13:55,760 --> 00:14:00,890
queries and because it's stateless it's

00:13:57,800 --> 00:14:02,810
very easy to scale horizontally so when

00:14:00,890 --> 00:14:05,360
an event arrives on an event bus stream

00:14:02,810 --> 00:14:08,680
we call out to the graph QL API service

00:14:05,360 --> 00:14:10,910
for execution whoa

00:14:08,680 --> 00:14:12,500
at this point we're picking up events

00:14:10,910 --> 00:14:14,350
from the event bus and executing them

00:14:12,500 --> 00:14:17,240
using the graph QL API

00:14:14,350 --> 00:14:18,440
protip for giving talks don't edit

00:14:17,240 --> 00:14:20,770
slides just before you're about to go on

00:14:18,440 --> 00:14:22,820
stage because you'll mess up transitions

00:14:20,770 --> 00:14:24,890
next we have to deliver the resulting

00:14:22,820 --> 00:14:26,030
payloads streamed event delivery at

00:14:24,890 --> 00:14:27,260
scale is a very hard problem

00:14:26,030 --> 00:14:29,530
particularly taking into account

00:14:27,260 --> 00:14:33,560
multiple data centers and more generally

00:14:29,530 --> 00:14:35,930
computers inducing how we delivered

00:14:33,560 --> 00:14:37,520
subscription results to clients a new

00:14:35,930 --> 00:14:39,440
pack now emoji on screen was a bad idea

00:14:37,520 --> 00:14:42,410
because it makes me laugh there's not a

00:14:39,440 --> 00:14:43,910
good fit in choosing how we delivered

00:14:42,410 --> 00:14:45,200
subscription results to clients it was

00:14:43,910 --> 00:14:47,480
important that we didn't try to reinvent

00:14:45,200 --> 00:14:49,730
the wheel and we looked for existing

00:14:47,480 --> 00:14:51,380
solutions to the problem so with that in

00:14:49,730 --> 00:14:53,150
mind we chose to build event delivery

00:14:51,380 --> 00:14:54,950
for graph gal subscriptions on top and

00:14:53,150 --> 00:14:57,200
on top of an existing Twitter technology

00:14:54,950 --> 00:14:59,540
called a life pipeline life pipeline is

00:14:57,200 --> 00:15:01,520
a pub/sub system over streaming HTTP

00:14:59,540 --> 00:15:03,830
connections if you've ever seen the

00:15:01,520 --> 00:15:05,720
engagement counts in a tweet change or

00:15:03,830 --> 00:15:07,910
typing indicators in your DMS that's

00:15:05,720 --> 00:15:09,440
powered by life pipeline because this

00:15:07,910 --> 00:15:10,760
system is proven in production we

00:15:09,440 --> 00:15:12,020
decided it was ripe for use for

00:15:10,760 --> 00:15:14,570
delivering the results of graph QL

00:15:12,020 --> 00:15:16,880
subscription queries to our clients in

00:15:14,570 --> 00:15:18,770
the life pipeline model clients listen

00:15:16,880 --> 00:15:20,660
for events on a particular topic and

00:15:18,770 --> 00:15:22,520
event producing systems like those

00:15:20,660 --> 00:15:24,290
handling tweet engagements can push

00:15:22,520 --> 00:15:27,380
events onto a topic by publishing them

00:15:24,290 --> 00:15:28,790
to life pipeline the event is then

00:15:27,380 --> 00:15:33,290
delivered to all clients subscribed

00:15:28,790 --> 00:15:34,970
using the events topic to deliver graph

00:15:33,290 --> 00:15:37,070
to your subscription payloads we use a

00:15:34,970 --> 00:15:39,290
unique live pipeline topic per graph to

00:15:37,070 --> 00:15:41,000
your subscription we combine and hash a

00:15:39,290 --> 00:15:42,830
bunch of data about the subscription to

00:15:41,000 --> 00:15:44,510
create a live pipeline topic and then

00:15:42,830 --> 00:15:47,840
inform the client of that topic so it

00:15:44,510 --> 00:15:49,040
can subscribe using live pipeline when a

00:15:47,840 --> 00:15:51,110
client initiates a graph Gale

00:15:49,040 --> 00:15:52,820
subscription query we've returned a

00:15:51,110 --> 00:15:54,500
status message containing a live

00:15:52,820 --> 00:15:56,240
pipeline topic as part of a graph QL

00:15:54,500 --> 00:15:58,730
Union type field at the root of the

00:15:56,240 --> 00:16:00,320
subscription the client then subscribed

00:15:58,730 --> 00:16:01,760
to this topic with Lite pipeline in

00:16:00,320 --> 00:16:04,880
order to receive subscription payloads

00:16:01,760 --> 00:16:05,960
so the query on your left is actually

00:16:04,880 --> 00:16:08,240
made to our graph curate

00:16:05,960 --> 00:16:09,500
I returns that returns the topic and

00:16:08,240 --> 00:16:13,670
then that is used to connect a live

00:16:09,500 --> 00:16:15,980
pipeline the client then subscribes to

00:16:13,670 --> 00:16:17,690
this topic like this and receives the

00:16:15,980 --> 00:16:21,020
result of the query and you can see that

00:16:17,690 --> 00:16:23,930
this time we have the the tweet type of

00:16:21,020 --> 00:16:26,180
the Union that the root of the result

00:16:23,930 --> 00:16:28,790
and in this way we kept to the spec

00:16:26,180 --> 00:16:30,140
where the responses were always of the

00:16:28,790 --> 00:16:33,170
same type and we didn't have to do any

00:16:30,140 --> 00:16:35,690
out-of-band topic communication so

00:16:33,170 --> 00:16:38,150
putting all together I think this is my

00:16:35,690 --> 00:16:39,610
favorite slide in the whole talk the

00:16:38,150 --> 00:16:42,190
client makes a subscription to

00:16:39,610 --> 00:16:45,170
subscription query to the graph QL API

00:16:42,190 --> 00:16:47,720
the API may contact an event producer to

00:16:45,170 --> 00:16:49,340
tell it that there's a new subscriber it

00:16:47,720 --> 00:16:50,930
will then return the live pipeline topic

00:16:49,340 --> 00:16:52,340
and hopefully that's not behind my face

00:16:50,930 --> 00:16:53,380
it totally as I tried to move it up

00:16:52,340 --> 00:16:55,430
sorry everyone

00:16:53,380 --> 00:16:58,760
which the client then uses for a

00:16:55,430 --> 00:17:00,620
subscription with live pipeline once the

00:16:58,760 --> 00:17:02,030
event producer starts making events the

00:17:00,620 --> 00:17:04,250
subscription service will pick them up

00:17:02,030 --> 00:17:07,700
and execute the original query using the

00:17:04,250 --> 00:17:09,350
API after the API is done its job the

00:17:07,700 --> 00:17:12,140
payload is published to the client

00:17:09,350 --> 00:17:13,339
through life pipeline of course there's

00:17:12,140 --> 00:17:14,480
much more to talk about here but I

00:17:13,339 --> 00:17:16,670
wanted to give you a quick overview of

00:17:14,480 --> 00:17:18,290
our system the system is built to

00:17:16,670 --> 00:17:20,330
deliver thousands of events per second

00:17:18,290 --> 00:17:21,650
to thousands of connected clients I'm

00:17:20,330 --> 00:17:23,330
looking forward to coming back here in

00:17:21,650 --> 00:17:24,950
the future to tell you about how how it

00:17:23,330 --> 00:17:28,220
has developed and what we learn with it

00:17:24,950 --> 00:17:30,380
in production lastly I wanted to touch

00:17:28,220 --> 00:17:33,260
briefly on our vision for the future of

00:17:30,380 --> 00:17:35,240
graph QL at Twitter one of our main

00:17:33,260 --> 00:17:37,160
goals was to make was to help our teams

00:17:35,240 --> 00:17:39,380
build great products and features more

00:17:37,160 --> 00:17:40,970
quickly and more easily as part of this

00:17:39,380 --> 00:17:42,740
we're working to make it easy for new

00:17:40,970 --> 00:17:45,020
data to be made available through graph

00:17:42,740 --> 00:17:47,360
QL without anyone manually editing

00:17:45,020 --> 00:17:48,860
schema code the technology we're using

00:17:47,360 --> 00:17:50,390
to power this at Twitter is called

00:17:48,860 --> 00:17:53,210
Strato and i want to tell you a bit

00:17:50,390 --> 00:17:54,770
about it first though a caveat Strato is

00:17:53,210 --> 00:17:56,480
not open source and is tied very closely

00:17:54,770 --> 00:17:58,940
to twitter so it's not something we'll

00:17:56,480 --> 00:17:59,990
be making open source it's just it's a

00:17:58,940 --> 00:18:01,490
technology it's something we have

00:17:59,990 --> 00:18:02,960
available inside Twitter and it's very

00:18:01,490 --> 00:18:04,700
exciting and interesting and also Maps

00:18:02,960 --> 00:18:05,960
closely to some other ideas that we've

00:18:04,700 --> 00:18:08,540
heard at the conference so I thought it

00:18:05,960 --> 00:18:11,180
was interesting to tell you about Strato

00:18:08,540 --> 00:18:12,560
is a kind of virtual database a virtual

00:18:11,180 --> 00:18:14,630
database also called a federated

00:18:12,560 --> 00:18:16,100
database brings together multiple data

00:18:14,630 --> 00:18:16,840
sources so they can be queried and

00:18:16,100 --> 00:18:19,539
mutated

00:18:16,840 --> 00:18:23,140
normally now that sounds kind of like

00:18:19,539 --> 00:18:25,210
graph QL right philosophically Strato

00:18:23,140 --> 00:18:26,740
and graph QL are very similar strata has

00:18:25,210 --> 00:18:29,559
many of the same benefits without the

00:18:26,740 --> 00:18:30,840
specific focus on building products or

00:18:29,559 --> 00:18:33,370
building client applications actually

00:18:30,840 --> 00:18:35,169
strata has existed at Twitter for a lot

00:18:33,370 --> 00:18:38,289
longer than graph QL and it's the layer

00:18:35,169 --> 00:18:39,850
we're using to power our graph QL API it

00:18:38,289 --> 00:18:41,799
integrates tightly with our existing

00:18:39,850 --> 00:18:44,140
thrift services and combination with

00:18:41,799 --> 00:18:45,789
graph QL gives us end-to-end types from

00:18:44,140 --> 00:18:47,890
that sometimes from the database all the

00:18:45,789 --> 00:18:49,990
way to the client this approach has a

00:18:47,890 --> 00:18:51,510
ton of power and we could give whole

00:18:49,990 --> 00:18:53,980
talks about it

00:18:51,510 --> 00:18:56,529
for example our strata team has made it

00:18:53,980 --> 00:18:58,210
possible to add dated to their catalogue

00:18:56,529 --> 00:19:01,059
with a simple config file and they

00:18:58,210 --> 00:19:02,289
deploy automatic this gives our

00:19:01,059 --> 00:19:04,059
engineers a huge amount of power and

00:19:02,289 --> 00:19:06,580
flexibility by removing the need for

00:19:04,059 --> 00:19:08,020
coordination with other teams this is an

00:19:06,580 --> 00:19:09,669
example strata column that would store

00:19:08,020 --> 00:19:11,770
the birthdays of Twitter users in a

00:19:09,669 --> 00:19:13,750
database the details aren't really

00:19:11,770 --> 00:19:16,539
important but it's just config and

00:19:13,750 --> 00:19:18,429
that's cool a Twitter we've built strata

00:19:16,539 --> 00:19:20,080
powered graph QL which allows data in

00:19:18,429 --> 00:19:21,940
the strata catalog to automatically

00:19:20,080 --> 00:19:25,870
appear in the graph q schema with a

00:19:21,940 --> 00:19:28,390
simple config change so today I've

00:19:25,870 --> 00:19:29,950
talked about Twitter's graph QL API how

00:19:28,390 --> 00:19:32,830
we designed our graph Cal subscription

00:19:29,950 --> 00:19:34,510
system to work at Twitter scale and our

00:19:32,830 --> 00:19:36,789
vision for the future of graph QL at

00:19:34,510 --> 00:19:38,380
Twitter I took there was a super quick

00:19:36,789 --> 00:19:40,120
overview of some of the choices we've

00:19:38,380 --> 00:19:42,039
made in building graph QL and I hope it

00:19:40,120 --> 00:19:45,850
helps inform decisions you make as you

00:19:42,039 --> 00:19:47,140
explore this technology yourselves I'd

00:19:45,850 --> 00:19:49,390
like to finish with a discussion though

00:19:47,140 --> 00:19:51,309
of why I think graph curls exciting in

00:19:49,390 --> 00:19:54,100
the big picture I see graph QL as an

00:19:51,309 --> 00:19:56,590
enabling technology that means it can

00:19:54,100 --> 00:19:59,320
drive radical change in the capabilities

00:19:56,590 --> 00:20:00,880
of a user or culture we all recognize

00:19:59,320 --> 00:20:02,440
this in the huge productivity leaps

00:20:00,880 --> 00:20:03,990
available through graph QL and this kind

00:20:02,440 --> 00:20:06,610
of the reason we're all here

00:20:03,990 --> 00:20:08,230
enabling technologies also lead to rapid

00:20:06,610 --> 00:20:10,289
development of subsequent derivative

00:20:08,230 --> 00:20:12,700
technologies often in diverse fields

00:20:10,289 --> 00:20:14,679
tools like graphical and everything

00:20:12,700 --> 00:20:16,149
Apollo does demonstrates this but I'm

00:20:14,679 --> 00:20:17,529
sure we'll see a huge range of other

00:20:16,149 --> 00:20:19,270
things in the future and I really

00:20:17,529 --> 00:20:22,630
encourage everyone to think outside of

00:20:19,270 --> 00:20:24,159
the just building mobile apps and

00:20:22,630 --> 00:20:25,899
websites and think about applications

00:20:24,159 --> 00:20:29,510
for graph kill in other areas

00:20:25,899 --> 00:20:32,029
in this way I think graph QL expands on

00:20:29,510 --> 00:20:33,980
Stewart Calvin's idea of the adjacent

00:20:32,029 --> 00:20:35,539
possible meaning the graph QL is so

00:20:33,980 --> 00:20:37,429
radically different to what we do now

00:20:35,539 --> 00:20:39,080
that it opens up whole new avenues of

00:20:37,429 --> 00:20:42,020
exploration that were previously closed

00:20:39,080 --> 00:20:44,090
to us the present we have a REST API is

00:20:42,020 --> 00:20:46,490
endpoints HTTP verbs and query

00:20:44,090 --> 00:20:48,370
parameters is one possible permutation

00:20:46,490 --> 00:20:50,750
of the ways our clients can fetch data

00:20:48,370 --> 00:20:52,789
there are others available and we owe it

00:20:50,750 --> 00:20:54,740
to ourselves and our users to explore

00:20:52,789 --> 00:20:56,570
them now that's not to say there aren't

00:20:54,740 --> 00:20:58,340
problems with graph QL it's not done

00:20:56,570 --> 00:20:59,840
it's not a perfect technology by any

00:20:58,340 --> 00:21:02,750
means and the graph Gale community has

00:20:59,840 --> 00:21:04,850
work to do on real issues as with all

00:21:02,750 --> 00:21:08,929
technology it's trade-offs all the way

00:21:04,850 --> 00:21:10,789
down please come talk to me or the other

00:21:08,929 --> 00:21:12,710
Twitter focus at a few rows back if

00:21:10,789 --> 00:21:14,720
you'd like to hear more we'd be happy to

00:21:12,710 --> 00:21:17,299
tell you more about what we do and how

00:21:14,720 --> 00:21:19,820
it's going and I think you should

00:21:17,299 --> 00:21:20,200
probably follow me on Twitter thanks

00:21:19,820 --> 00:21:27,670
very much

00:21:20,200 --> 00:21:27,670

YouTube URL: https://www.youtube.com/watch?v=Baw05hrOUNM


