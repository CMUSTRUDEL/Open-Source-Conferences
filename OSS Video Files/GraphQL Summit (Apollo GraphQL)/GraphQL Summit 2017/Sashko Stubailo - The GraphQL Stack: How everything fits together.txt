Title: Sashko Stubailo - The GraphQL Stack: How everything fits together
Publication date: 2017-11-07
Playlist: GraphQL Summit 2017
Description: 
	Sashko Stubailo, Open Source Engineering Lead at Apollo, gave this talk at GraphQL Summit 2017. Learn more: summit.graphql.com

One of the best things about GraphQL is the diversity of tools available to use for every part of your application development process. From client and server implementations to in-editor plugins to production-ready services, you can find a GraphQL integration for almost anything you're using. But how do they all fit together? In this talk I'll go over the GraphQL landscape and show what full-stack GraphQL looks like.

See the slides: https://www.slideshare.net/sashko1/graphql-across-the-stack-how-everything-fits-together

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Captions: 
	00:00:03,409 --> 00:00:09,469
good morning everyone we pretty much

00:00:06,710 --> 00:00:12,799
said it it's been just a totally amazing

00:00:09,469 --> 00:00:15,770
event so far I can't believe that it's

00:00:12,799 --> 00:00:18,080
only been one year since the first craft

00:00:15,770 --> 00:00:21,620
kill summit last year who came last year

00:00:18,080 --> 00:00:23,090
to graph QL summit one year ago Wow not

00:00:21,620 --> 00:00:27,170
even that many people so most people

00:00:23,090 --> 00:00:28,340
here are new to the summit world but

00:00:27,170 --> 00:00:29,840
there's already so many people using

00:00:28,340 --> 00:00:31,250
graphical and production and trying out

00:00:29,840 --> 00:00:32,899
new things there's so many more

00:00:31,250 --> 00:00:35,769
learnings to share than even there were

00:00:32,899 --> 00:00:39,050
one year ago so I think we pretty much

00:00:35,769 --> 00:00:40,879
pretty much got it I'm here to tell you

00:00:39,050 --> 00:00:42,229
that I do think one of the main benefits

00:00:40,879 --> 00:00:43,809
of graph kill is the fact that you can

00:00:42,229 --> 00:00:45,949
build so many great tools about it and

00:00:43,809 --> 00:00:46,339
hopefully you'll understand why I feel

00:00:45,949 --> 00:00:49,039
that way

00:00:46,339 --> 00:00:51,350
throughout the talk so first of all who

00:00:49,039 --> 00:00:54,170
are we I mean you've seen the Apollo

00:00:51,350 --> 00:00:56,449
logo around we've got a booth but really

00:00:54,170 --> 00:00:59,179
I would say that we're a team and a

00:00:56,449 --> 00:01:01,100
community that really believes in making

00:00:59,179 --> 00:01:02,989
it much easier and more straightforward

00:01:01,100 --> 00:01:04,970
to build applications overall for

00:01:02,989 --> 00:01:07,460
everybody who's trying to develop these

00:01:04,970 --> 00:01:09,229
kinds of applications and I think one

00:01:07,460 --> 00:01:10,490
thing that's I guess different about us

00:01:09,229 --> 00:01:12,829
than all the other companies that have

00:01:10,490 --> 00:01:14,539
that is that we think that graph QL is

00:01:12,829 --> 00:01:16,460
gonna be one of the primary vehicles in

00:01:14,539 --> 00:01:18,530
the near future and the highest leverage

00:01:16,460 --> 00:01:21,079
way to improve that application

00:01:18,530 --> 00:01:22,280
developer experience for people right

00:01:21,079 --> 00:01:23,659
there's a lot of other types of things

00:01:22,280 --> 00:01:26,960
you could focus on you could focus on

00:01:23,659 --> 00:01:28,729
few layers like react or databases but

00:01:26,960 --> 00:01:30,320
right there in the API layer we think

00:01:28,729 --> 00:01:34,609
there's a whole ton of value that has

00:01:30,320 --> 00:01:36,619
yet to be unlocked so why graph QL why

00:01:34,609 --> 00:01:39,229
that particular technology and why api's

00:01:36,619 --> 00:01:42,469
and I think there are pretty much three

00:01:39,229 --> 00:01:45,710
things that stand out to me as the most

00:01:42,469 --> 00:01:47,689
important parts of graph QL that make it

00:01:45,710 --> 00:01:49,880
a technology worth adopting over a lot

00:01:47,689 --> 00:01:51,350
of other similar technologies the first

00:01:49,880 --> 00:01:52,789
thing is that it has a wonderful

00:01:51,350 --> 00:01:55,039
language and this is the first thing

00:01:52,789 --> 00:01:56,659
people see when they think of graph QL I

00:01:55,039 --> 00:01:59,270
guess it's the name the name has query

00:01:56,659 --> 00:02:01,130
language in it it's a great language for

00:01:59,270 --> 00:02:03,140
declaring data requirements for your

00:02:01,130 --> 00:02:05,090
application which is totally decoupled

00:02:03,140 --> 00:02:06,890
from where that data is coming from how

00:02:05,090 --> 00:02:09,140
its fetched what happens to it

00:02:06,890 --> 00:02:11,210
afterwards is just a very abstract way

00:02:09,140 --> 00:02:14,180
to say I would like to have this data

00:02:11,210 --> 00:02:16,460
please on the other hand there's an

00:02:14,180 --> 00:02:17,240
equally powerful abstraction on the

00:02:16,460 --> 00:02:19,310
other side

00:02:17,240 --> 00:02:21,200
let's the server or graph kill epi

00:02:19,310 --> 00:02:23,210
describe what data is available to the

00:02:21,200 --> 00:02:25,370
consumer which is also decoupled both

00:02:23,210 --> 00:02:27,760
from how that data is fetched and where

00:02:25,370 --> 00:02:30,050
it lives in the back end and then

00:02:27,760 --> 00:02:31,760
partially because the two first two

00:02:30,050 --> 00:02:33,590
things enable it and partially I think

00:02:31,760 --> 00:02:35,060
because the community is just so great

00:02:33,590 --> 00:02:37,270
and people have gotten so excited and

00:02:35,060 --> 00:02:39,410
banded together there's a completely

00:02:37,270 --> 00:02:42,260
overwhelming ecosystem of tools they're

00:02:39,410 --> 00:02:44,630
literally thousands of tools on github

00:02:42,260 --> 00:02:46,940
and p.m. other package managers so you

00:02:44,630 --> 00:02:48,950
can now integrate graph kill with pretty

00:02:46,940 --> 00:02:49,910
much anything imaginable you might be

00:02:48,950 --> 00:02:52,610
using whether it's a front-end

00:02:49,910 --> 00:02:56,330
technology your editor your database or

00:02:52,610 --> 00:02:57,380
any other kind of thing and there's one

00:02:56,330 --> 00:03:00,620
thing in particular that I want to focus

00:02:57,380 --> 00:03:01,940
on here and you know if you guys are

00:03:00,620 --> 00:03:04,430
familiar with react you might have heard

00:03:01,940 --> 00:03:06,110
this kind of slogan before which is it's

00:03:04,430 --> 00:03:08,480
important to couple together things that

00:03:06,110 --> 00:03:10,610
are inherently coupled and D couple

00:03:08,480 --> 00:03:12,680
things that shouldn't be coupled and one

00:03:10,610 --> 00:03:15,170
common accident people make is coupling

00:03:12,680 --> 00:03:18,080
together things that just seem to be in

00:03:15,170 --> 00:03:19,250
a similar location so you know for

00:03:18,080 --> 00:03:21,050
example if you write your API with

00:03:19,250 --> 00:03:23,600
endpoints and your servers and control

00:03:21,050 --> 00:03:26,540
of the shape of the data that's returned

00:03:23,600 --> 00:03:28,370
that might be because well the backend

00:03:26,540 --> 00:03:30,890
is where you do data stuff and so that's

00:03:28,370 --> 00:03:32,480
where we put those things but I think a

00:03:30,890 --> 00:03:34,790
really big part of the power of graph QL

00:03:32,480 --> 00:03:36,320
is that it takes those data requirements

00:03:34,790 --> 00:03:38,270
which are actually coupled to how the

00:03:36,320 --> 00:03:40,480
client works and unless the client code

00:03:38,270 --> 00:03:42,530
base specify those requirements so

00:03:40,480 --> 00:03:44,000
instead of having this tightly coupled

00:03:42,530 --> 00:03:45,410
thing across the wire which is the

00:03:44,000 --> 00:03:47,210
client and the data requirements it has

00:03:45,410 --> 00:03:49,400
the coupling across the wire is much

00:03:47,210 --> 00:03:51,170
looser because it's just between those

00:03:49,400 --> 00:03:53,150
requirements and the availability of

00:03:51,170 --> 00:03:55,250
that data you can almost think of it as

00:03:53,150 --> 00:03:56,630
a component like approach to data which

00:03:55,250 --> 00:03:59,000
fits really nicely and that's why a lot

00:03:56,630 --> 00:04:00,860
of us use technologies like react or

00:03:59,000 --> 00:04:02,570
other technologies like view or angular

00:04:00,860 --> 00:04:06,230
that support UI components to work with

00:04:02,570 --> 00:04:09,080
graph QL so basically I would claim that

00:04:06,230 --> 00:04:10,460
graph QL is all about providing the

00:04:09,080 --> 00:04:12,770
correct split of responsibilities

00:04:10,460 --> 00:04:16,489
between the front end and the back end

00:04:12,770 --> 00:04:18,739
parts of your app so it's no secret that

00:04:16,489 --> 00:04:19,850
J's apps can be quite complicated

00:04:18,739 --> 00:04:21,790
there's a whole wealth of different

00:04:19,850 --> 00:04:24,260
front technologies back in technologies

00:04:21,790 --> 00:04:26,960
every company now has to have like at

00:04:24,260 --> 00:04:29,580
least three apps mobile to mobile apps

00:04:26,960 --> 00:04:31,950
and a website sometimes iPads sometimes

00:04:29,580 --> 00:04:32,970
internet-of-things stuff your backends

00:04:31,950 --> 00:04:35,580
are also getting more and more diverse

00:04:32,970 --> 00:04:36,660
and maybe as your company grows you've

00:04:35,580 --> 00:04:39,360
got different teams they need to

00:04:36,660 --> 00:04:41,070
coordinate between each other so why

00:04:39,360 --> 00:04:42,600
does graph QL and Apollo why do they

00:04:41,070 --> 00:04:43,830
help with that question I think it's

00:04:42,600 --> 00:04:47,100
because they make the picture look

00:04:43,830 --> 00:04:49,380
something like this they live in the

00:04:47,100 --> 00:04:51,270
middle between all of your front ends

00:04:49,380 --> 00:04:53,520
and all of your back ends and fill in

00:04:51,270 --> 00:04:56,160
something that nobody really had their

00:04:53,520 --> 00:04:57,990
eye on up until that point because from

00:04:56,160 --> 00:04:59,910
that in perspective the responsibilities

00:04:57,990 --> 00:05:02,310
to provide the data and from the Front's

00:04:59,910 --> 00:05:03,990
perspective you're consuming it but for

00:05:02,310 --> 00:05:05,760
the first time graph QL enables a whole

00:05:03,990 --> 00:05:07,680
world of tools to live in between and

00:05:05,760 --> 00:05:09,150
deal with actually how that data gets

00:05:07,680 --> 00:05:12,660
from point A to point B which it turns

00:05:09,150 --> 00:05:15,150
out can be a lot more powerful and also

00:05:12,660 --> 00:05:16,980
complicated than people might have

00:05:15,150 --> 00:05:19,020
thought especially because client-side

00:05:16,980 --> 00:05:22,440
rendering apps especially in the web

00:05:19,020 --> 00:05:24,720
context is a pretty new thing so where

00:05:22,440 --> 00:05:29,090
are we today with that Apollo and

00:05:24,720 --> 00:05:32,120
graphic L in 2017 is pretty sweet

00:05:29,090 --> 00:05:34,860
like you guys heard yesterday morning

00:05:32,120 --> 00:05:36,900
James announced Apollo client 2.0 and

00:05:34,860 --> 00:05:39,140
has a lot of cool features but the

00:05:36,900 --> 00:05:41,280
really most exciting thing to me is that

00:05:39,140 --> 00:05:44,070
people in the community have already

00:05:41,280 --> 00:05:45,450
jumped on top of that release even

00:05:44,070 --> 00:05:47,550
before was out and started building

00:05:45,450 --> 00:05:50,010
those exciting new features into their

00:05:47,550 --> 00:05:52,590
integrations for angular and view so we

00:05:50,010 --> 00:05:54,420
maintain the react one but there's now

00:05:52,590 --> 00:05:56,340
great real-time updates and server-side

00:05:54,420 --> 00:05:57,690
rendering for view and for angular that

00:05:56,340 --> 00:05:59,580
take advantage of the new flexibility

00:05:57,690 --> 00:06:00,900
that platform to tie nicely into those

00:05:59,580 --> 00:06:03,360
ecosystems which i think is really

00:06:00,900 --> 00:06:05,760
really cool to see and on the server

00:06:03,360 --> 00:06:06,960
it's now easier than ever before to

00:06:05,760 --> 00:06:08,520
write a graph kill server and pretty

00:06:06,960 --> 00:06:11,780
much any programming language you want I

00:06:08,520 --> 00:06:13,710
think when graph Q was first introduced

00:06:11,780 --> 00:06:15,150
people's main complaint was I don't

00:06:13,710 --> 00:06:16,530
really know how to get started writing a

00:06:15,150 --> 00:06:18,750
server but today there were so many

00:06:16,530 --> 00:06:20,670
tutorials so many libraries for every

00:06:18,750 --> 00:06:22,500
single language that that's not really

00:06:20,670 --> 00:06:23,640
an excuse anymore you know you might now

00:06:22,500 --> 00:06:25,260
have the question how do I take my

00:06:23,640 --> 00:06:26,520
server into production but getting a

00:06:25,260 --> 00:06:28,650
graphical query running against your

00:06:26,520 --> 00:06:30,720
data isn't the problem that it once was

00:06:28,650 --> 00:06:32,340
as you have heard even in some talks

00:06:30,720 --> 00:06:33,840
yesterday people suggest the first step

00:06:32,340 --> 00:06:38,190
is building that proof of concept on top

00:06:33,840 --> 00:06:40,680
of your data so essentially there's this

00:06:38,190 --> 00:06:42,889
duality which is really important of the

00:06:40,680 --> 00:06:44,449
client server where the client knows

00:06:42,889 --> 00:06:46,400
the data requirements and their detailed

00:06:44,449 --> 00:06:48,830
and fine-grained and the server is

00:06:46,400 --> 00:06:52,819
flexible and performant and provides

00:06:48,830 --> 00:06:54,860
those capabilities so the second concept

00:06:52,819 --> 00:06:56,750
I want to introduce that is really

00:06:54,860 --> 00:07:00,050
important to me is that a graph QL query

00:06:56,750 --> 00:07:02,599
is a really nice semantic unit of data

00:07:00,050 --> 00:07:05,300
fetching and what does that mean I guess

00:07:02,599 --> 00:07:06,650
it means to me that you now maybe for

00:07:05,300 --> 00:07:09,229
the first time have the ability to

00:07:06,650 --> 00:07:12,080
encode all the data you need for one

00:07:09,229 --> 00:07:14,240
part of your user interface in a single

00:07:12,080 --> 00:07:15,680
place which is one query because if the

00:07:14,240 --> 00:07:18,050
language is often flexible enough that

00:07:15,680 --> 00:07:20,419
you don't need those multiple queries to

00:07:18,050 --> 00:07:21,919
make that happen and from the server's

00:07:20,419 --> 00:07:24,409
perspective that's immensely valuable

00:07:21,919 --> 00:07:25,909
because now what happens is your server

00:07:24,409 --> 00:07:27,650
gets all that information in one go as

00:07:25,909 --> 00:07:29,479
well you no longer have to send a bunch

00:07:27,650 --> 00:07:31,250
of separate endpoint requests you can

00:07:29,479 --> 00:07:33,199
tell exactly where that query is coming

00:07:31,250 --> 00:07:34,729
from and exactly what is needed so for

00:07:33,199 --> 00:07:36,889
example in graph QL it's really easy to

00:07:34,729 --> 00:07:38,870
do something like avoid having multiple

00:07:36,889 --> 00:07:40,580
back-end fetches happen for the same

00:07:38,870 --> 00:07:41,930
data because you know if you're

00:07:40,580 --> 00:07:43,490
rendering a list of comments and you're

00:07:41,930 --> 00:07:44,960
getting an author for each comment and

00:07:43,490 --> 00:07:47,599
they are very overlapping because maybe

00:07:44,960 --> 00:07:48,800
it's a conversation it's pretty easy in

00:07:47,599 --> 00:07:51,349
graph QL today to make sure you only

00:07:48,800 --> 00:07:52,580
fetch you one of those authors once but

00:07:51,349 --> 00:07:54,529
if you are individually loading those

00:07:52,580 --> 00:07:55,759
through separate endpoints it would be

00:07:54,529 --> 00:07:56,990
really hard to predict if you're about

00:07:55,759 --> 00:07:58,129
to fetch the same data or a different

00:07:56,990 --> 00:08:00,319
data you'll probably have to have some

00:07:58,129 --> 00:08:02,870
caching across those requests or build a

00:08:00,319 --> 00:08:05,300
special endpoint so knowing the data

00:08:02,870 --> 00:08:09,500
that you want entirely ahead of time

00:08:05,300 --> 00:08:11,449
makes it very efficient so I want to

00:08:09,500 --> 00:08:13,460
orient my talk today around some of the

00:08:11,449 --> 00:08:15,289
main questions that we hear from people

00:08:13,460 --> 00:08:17,960
who are production izing graph kill

00:08:15,289 --> 00:08:19,819
today so it's easy to get started

00:08:17,960 --> 00:08:21,889
set up a simple client a simple server

00:08:19,819 --> 00:08:23,990
in any language but then people end up

00:08:21,889 --> 00:08:25,039
with some questions of this form and

00:08:23,990 --> 00:08:28,279
these are the ones I want to focus on

00:08:25,039 --> 00:08:30,529
how do I have less resources to load my

00:08:28,279 --> 00:08:31,520
data by caching caching is probably the

00:08:30,529 --> 00:08:33,829
number one thing that everyone asked

00:08:31,520 --> 00:08:36,050
about the second thing is how do I

00:08:33,829 --> 00:08:37,579
understand what's going on how do you

00:08:36,050 --> 00:08:39,289
make your server and your client not

00:08:37,579 --> 00:08:41,539
feel like a black box where you don't

00:08:39,289 --> 00:08:43,760
know what is happening there and the

00:08:41,539 --> 00:08:45,470
third one is how do I make my graph kill

00:08:43,760 --> 00:08:47,660
more modular I heard that I should have

00:08:45,470 --> 00:08:49,070
micro services and that's been great

00:08:47,660 --> 00:08:50,630
because I've decoupled all my stuff and

00:08:49,070 --> 00:08:51,680
I can deploy it separately but now

00:08:50,630 --> 00:08:53,660
you're telling me to go back to that

00:08:51,680 --> 00:08:55,520
world where everything's in one place

00:08:53,660 --> 00:08:56,210
again and I'm not entirely comfortable

00:08:55,520 --> 00:08:59,630
with that

00:08:56,210 --> 00:09:03,500
so let's get into it so let's talk about

00:08:59,630 --> 00:09:05,120
cashing this silly question

00:09:03,500 --> 00:09:10,130
how many people feel like they should be

00:09:05,120 --> 00:09:12,980
cashing their API okay it's like it's

00:09:10,130 --> 00:09:18,589
like most people it's very relatable

00:09:12,980 --> 00:09:20,779
talk so it turns out that when you step

00:09:18,589 --> 00:09:22,010
into the world of graph QL you have to

00:09:20,779 --> 00:09:25,010
take a little bit of a different

00:09:22,010 --> 00:09:27,410
approach because you know there's some

00:09:25,010 --> 00:09:29,120
small questions like okay sometimes HTTP

00:09:27,410 --> 00:09:31,190
caching doesn't support post requests

00:09:29,120 --> 00:09:32,450
and sometimes you send queries with post

00:09:31,190 --> 00:09:33,529
requests that's like a pretty minor

00:09:32,450 --> 00:09:36,770
thing you know they could probably just

00:09:33,529 --> 00:09:38,060
fix that then some larger problems like

00:09:36,770 --> 00:09:39,680
maybe have a greater diversity of

00:09:38,060 --> 00:09:42,110
requests because you have more different

00:09:39,680 --> 00:09:43,820
queries that you might be sending maybe

00:09:42,110 --> 00:09:46,010
it's harder to predict and make that

00:09:43,820 --> 00:09:47,360
query match up with your cache and then

00:09:46,010 --> 00:09:48,830
one thing that's also really interesting

00:09:47,360 --> 00:09:51,020
to me is that graph QL itself is

00:09:48,830 --> 00:09:53,209
transport independent but things like

00:09:51,020 --> 00:09:55,160
HTTP caching are very dependent on that

00:09:53,209 --> 00:09:57,140
transport so you know if you were using

00:09:55,160 --> 00:09:58,700
HTTP and then suddenly you wanted to

00:09:57,140 --> 00:10:01,160
switch to using WebSockets or something

00:09:58,700 --> 00:10:02,480
else to fetch your graph kill data then

00:10:01,160 --> 00:10:04,190
none of your caching setup would work

00:10:02,480 --> 00:10:06,320
anymore which would be kind of a bummer

00:10:04,190 --> 00:10:08,260
because there are different trade-offs

00:10:06,320 --> 00:10:10,430
for different kinds of transports

00:10:08,260 --> 00:10:11,830
especially like binary transports for

00:10:10,430 --> 00:10:14,510
mobile devices or something like that

00:10:11,830 --> 00:10:15,920
but it's not all bad news because

00:10:14,510 --> 00:10:18,140
there's a little bunch of benefits you

00:10:15,920 --> 00:10:19,700
can get from graph QL that you couldn't

00:10:18,140 --> 00:10:22,130
get in the endpoint based world at all

00:10:19,700 --> 00:10:23,360
for example because graph kills is

00:10:22,130 --> 00:10:24,620
fine-grained nature of defining the

00:10:23,360 --> 00:10:26,990
backend you can define your cache

00:10:24,620 --> 00:10:28,130
control in the same way and perhaps you

00:10:26,990 --> 00:10:30,020
could declare that caching information

00:10:28,130 --> 00:10:31,370
alongside your schema and resolvers

00:10:30,020 --> 00:10:35,060
rather than having to worry about it

00:10:31,370 --> 00:10:37,040
separately for each query so just as a

00:10:35,060 --> 00:10:38,510
background one of the things that I

00:10:37,040 --> 00:10:42,920
think is a pretty common way to do

00:10:38,510 --> 00:10:44,270
caching and rest or HTTP api's is to use

00:10:42,920 --> 00:10:47,180
a cache control header and pass

00:10:44,270 --> 00:10:49,190
something like max-age so you say my

00:10:47,180 --> 00:10:51,170
unit of data is this endpoint and here's

00:10:49,190 --> 00:10:53,270
how long I want to live inside my

00:10:51,170 --> 00:10:57,649
caching infrastructure that works pretty

00:10:53,270 --> 00:10:59,240
well so let's go with a couple of ideas

00:10:57,649 --> 00:11:01,850
for how we might want to do caching and

00:10:59,240 --> 00:11:04,010
graph QL so the first most obvious

00:11:01,850 --> 00:11:05,600
question is should I be doing this

00:11:04,010 --> 00:11:06,860
caching inside the server and you might

00:11:05,600 --> 00:11:09,170
have heard about data loader which is

00:11:06,860 --> 00:11:09,649
kind of like a caching solution it's

00:11:09,170 --> 00:11:11,749
primarily

00:11:09,649 --> 00:11:14,240
designed for caching inside a single

00:11:11,749 --> 00:11:15,889
request you know if you do multiple

00:11:14,240 --> 00:11:18,249
fetches to your back-end inside one

00:11:15,889 --> 00:11:19,939
query it can duplicate those very nicely

00:11:18,249 --> 00:11:21,350
but it might get a little bit more

00:11:19,939 --> 00:11:22,399
complicated if you want to do it across

00:11:21,350 --> 00:11:24,709
requests like if you have a

00:11:22,399 --> 00:11:25,970
public-facing website and you don't want

00:11:24,709 --> 00:11:28,730
it to hit the backend every time you go

00:11:25,970 --> 00:11:29,540
to the home page and additionally you

00:11:28,730 --> 00:11:31,100
probably don't want to add any

00:11:29,540 --> 00:11:33,290
complexity to your graphical server

00:11:31,100 --> 00:11:34,550
either because you want to look inside

00:11:33,290 --> 00:11:36,079
there and you want to see a nice clean

00:11:34,550 --> 00:11:37,610
translation layer between your friends

00:11:36,079 --> 00:11:39,980
and your backends you don't want to

00:11:37,610 --> 00:11:42,230
inherit a whole bunch of custom caching

00:11:39,980 --> 00:11:44,809
code and logic so my feeling is that

00:11:42,230 --> 00:11:46,249
caching doesn't belong inside your

00:11:44,809 --> 00:11:48,290
graphical API and I think that's

00:11:46,249 --> 00:11:50,959
something that you might hear from other

00:11:48,290 --> 00:11:52,490
people as well is probably you want to

00:11:50,959 --> 00:11:54,860
do it either above or underneath your

00:11:52,490 --> 00:11:56,720
graphical API either your caching the

00:11:54,860 --> 00:11:59,660
results of that server or your caching

00:11:56,720 --> 00:12:00,980
the requests to the back end and that

00:11:59,660 --> 00:12:03,709
lets you keep the complexity out of

00:12:00,980 --> 00:12:05,480
those resolvers and similar to HTTP

00:12:03,709 --> 00:12:07,639
infrastructure which i think is probably

00:12:05,480 --> 00:12:12,259
a good sign you have a separate layer

00:12:07,639 --> 00:12:15,529
that is doing that caching okay so to me

00:12:12,259 --> 00:12:17,509
what this suggests is there needs to be

00:12:15,529 --> 00:12:19,399
something like a caching layer that

00:12:17,509 --> 00:12:21,050
supports graph QL it supports some of

00:12:19,399 --> 00:12:23,480
those problems that we were talking

00:12:21,050 --> 00:12:26,600
about like post requests fine-grained

00:12:23,480 --> 00:12:28,009
TTLs stuff like that and we also need

00:12:26,600 --> 00:12:29,990
somewhere to put all that complexity

00:12:28,009 --> 00:12:32,899
that we just said we want to remove from

00:12:29,990 --> 00:12:34,129
our graph kill server so today one of

00:12:32,899 --> 00:12:36,769
the first things I want to introduce is

00:12:34,129 --> 00:12:38,629
the concept of a graphical gateway so

00:12:36,769 --> 00:12:40,040
you heard johannes talking yesterday

00:12:38,629 --> 00:12:42,050
about the idea of building a micro

00:12:40,040 --> 00:12:45,019
service with graph QL from from the

00:12:42,050 --> 00:12:47,300
start and this idea is a complimentary

00:12:45,019 --> 00:12:49,160
to that it's the idea of passing your

00:12:47,300 --> 00:12:51,079
graphical requests through a layer that

00:12:49,160 --> 00:12:52,249
handles your infrastructure concerns for

00:12:51,079 --> 00:12:55,040
you so you don't have to worry about

00:12:52,249 --> 00:12:56,990
those being inside the server and you

00:12:55,040 --> 00:13:00,019
might ask where might I get a graphical

00:12:56,990 --> 00:13:01,879
gateway and this is a part where I

00:13:00,019 --> 00:13:03,259
introduce Apollo engine and Apollo

00:13:01,879 --> 00:13:05,929
engine is a product that we announced

00:13:03,259 --> 00:13:08,149
this week which is the first ever graph

00:13:05,929 --> 00:13:10,670
QL specific gateway technology

00:13:08,149 --> 00:13:12,920
it's a infrastructure component that

00:13:10,670 --> 00:13:14,540
sits in between your clients and your

00:13:12,920 --> 00:13:17,149
graph kill servers and does stuff like

00:13:14,540 --> 00:13:19,670
caching tracing and errors if you used

00:13:17,149 --> 00:13:20,809
Apollo optics it's the next version of

00:13:19,670 --> 00:13:23,570
that and it has all those same features

00:13:20,809 --> 00:13:25,670
plus more so now when I'm talking

00:13:23,570 --> 00:13:27,200
about the Gateway component I'll refer

00:13:25,670 --> 00:13:28,970
to some of the things that engine does

00:13:27,200 --> 00:13:30,920
but also a lot of things that it doesn't

00:13:28,970 --> 00:13:32,930
do yet and this is a component that you

00:13:30,920 --> 00:13:34,040
could build yourself or there might be

00:13:32,930 --> 00:13:35,930
other people who start building these

00:13:34,040 --> 00:13:37,640
things as graph QL becomes more and more

00:13:35,930 --> 00:13:38,990
popular but I'm definitely very

00:13:37,640 --> 00:13:41,840
convinced that this component needs to

00:13:38,990 --> 00:13:44,960
exist okay so let's look at graph killer

00:13:41,840 --> 00:13:46,430
result caching in this context so the

00:13:44,960 --> 00:13:48,200
same way that the server provides the

00:13:46,430 --> 00:13:50,120
data capabilities in a fine-grained and

00:13:48,200 --> 00:13:51,560
flexible way I think the server should

00:13:50,120 --> 00:13:53,360
also provide that cache control

00:13:51,560 --> 00:13:56,090
information in the same flexible way and

00:13:53,360 --> 00:13:58,940
then when you get to the Gateway it can

00:13:56,090 --> 00:14:00,650
read those cache controls and do that

00:13:58,940 --> 00:14:04,160
caching the same way that it would with

00:14:00,650 --> 00:14:05,540
those HTTP api's and that means you no

00:14:04,160 --> 00:14:07,520
longer have to have that complicated

00:14:05,540 --> 00:14:09,260
stuff inside every single server it can

00:14:07,520 --> 00:14:10,910
live inside that gateway layer which can

00:14:09,260 --> 00:14:12,590
be implemented once and then on the

00:14:10,910 --> 00:14:13,220
backend you can use Ruby you can use

00:14:12,590 --> 00:14:15,410
Scala

00:14:13,220 --> 00:14:17,810
you can use JavaScript Python anything

00:14:15,410 --> 00:14:19,940
you want and it's not dependent on what

00:14:17,810 --> 00:14:22,370
features that particular library has for

00:14:19,940 --> 00:14:23,510
you so that could actually be a good

00:14:22,370 --> 00:14:25,310
approach even if you're building your

00:14:23,510 --> 00:14:27,140
own infrastructure is to figure out how

00:14:25,310 --> 00:14:31,310
to decouple yourself from a particular

00:14:27,140 --> 00:14:33,170
implementation so the next thing that I

00:14:31,310 --> 00:14:35,390
think is really cool is that it's not

00:14:33,170 --> 00:14:37,130
just a server-side thing right because

00:14:35,390 --> 00:14:38,810
probably a lot of you are using

00:14:37,130 --> 00:14:41,600
something like Apollo client or relay

00:14:38,810 --> 00:14:42,410
which might not feel like it but this is

00:14:41,600 --> 00:14:43,640
another cache

00:14:42,410 --> 00:14:46,790
actually there's caches all the way up

00:14:43,640 --> 00:14:49,280
and down everywhere in your life and so

00:14:46,790 --> 00:14:51,230
if you already have it's true we found

00:14:49,280 --> 00:14:53,150
some caches in between Apollo client and

00:14:51,230 --> 00:14:54,980
the react component so there's like

00:14:53,150 --> 00:14:58,100
three more caches in that layer as well

00:14:54,980 --> 00:15:02,390
I don't know how we became a caching

00:14:58,100 --> 00:15:04,040
company to look into that so if you're

00:15:02,390 --> 00:15:05,570
already using these cache controls to

00:15:04,040 --> 00:15:07,700
explain how data should be cached in

00:15:05,570 --> 00:15:10,010
your API layer why not use the exact

00:15:07,700 --> 00:15:11,270
same cache controls to explain how data

00:15:10,010 --> 00:15:14,120
should be handled in the client layer

00:15:11,270 --> 00:15:15,500
and you know the best part is that graph

00:15:14,120 --> 00:15:16,700
QL is the same language all the way

00:15:15,500 --> 00:15:18,470
through it's the language that you put

00:15:16,700 --> 00:15:20,300
inside your components it's language

00:15:18,470 --> 00:15:23,000
that gets sent over the network it's

00:15:20,300 --> 00:15:25,070
Lane language that gets sent past the

00:15:23,000 --> 00:15:26,570
Gateway everything is graph QL so these

00:15:25,070 --> 00:15:30,920
concepts are available to you all the

00:15:26,570 --> 00:15:32,840
way through so how are we gonna

00:15:30,920 --> 00:15:34,970
accomplish this and it turns out the

00:15:32,840 --> 00:15:37,340
graphical specification has an answer

00:15:34,970 --> 00:15:39,200
for us and the answer is that the graph

00:15:37,340 --> 00:15:42,050
Oh speck has a feature called extensions

00:15:39,200 --> 00:15:44,480
which means that you can have the entire

00:15:42,050 --> 00:15:46,310
graphical specification of specifying

00:15:44,480 --> 00:15:49,820
the query and getting the results in the

00:15:46,310 --> 00:15:51,830
exact shape that you expect but then if

00:15:49,820 --> 00:15:53,480
your server wants to it can provide an

00:15:51,830 --> 00:15:55,610
additional field next to the data and

00:15:53,480 --> 00:15:57,140
error is called extensions and you know

00:15:55,610 --> 00:15:58,370
the client can safely ignore that if it

00:15:57,140 --> 00:16:00,620
doesn't understand what they mean you

00:15:58,370 --> 00:16:01,850
can turn them on and off if you want but

00:16:00,620 --> 00:16:05,780
it lets you add additional data to that

00:16:01,850 --> 00:16:07,850
response and so one of the things that

00:16:05,780 --> 00:16:10,460
makes all this possible this caching

00:16:07,850 --> 00:16:12,380
feature inside a graphical gateway and

00:16:10,460 --> 00:16:14,600
inside engine is the idea of a

00:16:12,380 --> 00:16:17,390
standardized way to do cache control for

00:16:14,600 --> 00:16:19,250
graph QL so this is kind of a new thing

00:16:17,390 --> 00:16:20,360
the Apollo cache control standard you

00:16:19,250 --> 00:16:21,590
guys can check it out and github and

00:16:20,360 --> 00:16:24,110
I'll show you in a second how it works

00:16:21,590 --> 00:16:26,330
but the idea is wouldn't it be cool if

00:16:24,110 --> 00:16:28,310
every graph kil server had a

00:16:26,330 --> 00:16:30,950
standardized way to expose information

00:16:28,310 --> 00:16:32,780
about caching so anybody who's building

00:16:30,950 --> 00:16:34,340
a graph kill client anybody who wants to

00:16:32,780 --> 00:16:36,230
build their own API gateway for graph QL

00:16:34,340 --> 00:16:38,090
could take advantage of that data and

00:16:36,230 --> 00:16:40,130
then all the graph kills server

00:16:38,090 --> 00:16:41,570
implementers have to do is provide that

00:16:40,130 --> 00:16:43,100
information as part of the result and

00:16:41,570 --> 00:16:43,930
then they don't have to worry about what

00:16:43,100 --> 00:16:46,280
happens after that

00:16:43,930 --> 00:16:47,780
so it decouples the idea of building

00:16:46,280 --> 00:16:50,960
that complicated caching infrastructure

00:16:47,780 --> 00:16:52,910
from what the graphic Ewell server

00:16:50,960 --> 00:16:54,110
library implementers might want to be

00:16:52,910 --> 00:16:56,120
spending their time on which is probably

00:16:54,110 --> 00:16:59,480
making it easier and better to build a

00:16:56,120 --> 00:17:00,860
graph kill server so it's pretty simple

00:16:59,480 --> 00:17:02,960
I think the best thing about this spec

00:17:00,860 --> 00:17:05,980
is it's exactly what you would have come

00:17:02,960 --> 00:17:08,480
up with if you did it yourself which is

00:17:05,980 --> 00:17:10,340
you take the max age that I was just

00:17:08,480 --> 00:17:12,230
talking about from rest and you put it

00:17:10,340 --> 00:17:15,770
on the field and then you're basically

00:17:12,230 --> 00:17:17,150
done so you know it's in the extensions

00:17:15,770 --> 00:17:19,550
it's got the path to the part of the

00:17:17,150 --> 00:17:22,370
result it's got that max age and now all

00:17:19,550 --> 00:17:25,340
your proxy or gateway has to do is

00:17:22,370 --> 00:17:27,320
interpret that data and the other thing

00:17:25,340 --> 00:17:29,540
really cool thing is we've also have an

00:17:27,320 --> 00:17:31,790
initial JavaScript implementation of how

00:17:29,540 --> 00:17:33,470
that might work in a graph QL server so

00:17:31,790 --> 00:17:36,590
if you were writing your server with

00:17:33,470 --> 00:17:38,990
JavaScript you can right now try out

00:17:36,590 --> 00:17:40,970
using this cache-control javascript

00:17:38,990 --> 00:17:44,510
package lets you specify cache-control

00:17:40,970 --> 00:17:47,000
information on your types then also on

00:17:44,510 --> 00:17:48,530
fields and even dynamically inside your

00:17:47,000 --> 00:17:50,360
resolvers so all the different ways that

00:17:48,530 --> 00:17:51,190
you can use graphical on the server you

00:17:50,360 --> 00:17:53,650
can now add

00:17:51,190 --> 00:17:55,180
cashing directly there alongside the

00:17:53,650 --> 00:17:56,200
rest of your code so for example you can

00:17:55,180 --> 00:18:00,090
even pass through the caching

00:17:56,200 --> 00:18:03,940
information from your underlying service

00:18:00,090 --> 00:18:05,800
so essentially this is another instance

00:18:03,940 --> 00:18:07,600
for me of that idea of that things

00:18:05,800 --> 00:18:10,030
should be coupled in the right place

00:18:07,600 --> 00:18:12,700
right your graph kill server is the

00:18:10,030 --> 00:18:14,920
thing that knows about how those

00:18:12,700 --> 00:18:16,180
backends work and your resolvers are the

00:18:14,920 --> 00:18:17,950
place where that data is actually called

00:18:16,180 --> 00:18:19,450
so that's where it should happen that's

00:18:17,950 --> 00:18:21,400
where you should be doing your cache

00:18:19,450 --> 00:18:23,950
controlling not on some layer that's

00:18:21,400 --> 00:18:27,160
outside of it so the server should be in

00:18:23,950 --> 00:18:29,050
charge of defining what the caching is

00:18:27,160 --> 00:18:30,280
like but the same time the client should

00:18:29,050 --> 00:18:32,740
be in charge of figuring out what data

00:18:30,280 --> 00:18:34,780
at once and then those two are combined

00:18:32,740 --> 00:18:36,250
to figure out how the actual response is

00:18:34,780 --> 00:18:37,900
cached and it depends both on the

00:18:36,250 --> 00:18:40,840
capabilities exposed by the server and

00:18:37,900 --> 00:18:42,940
on the requests made by the client so

00:18:40,840 --> 00:18:47,020
this to me feels like a really graphical

00:18:42,940 --> 00:18:50,770
focused way to do things so I think the

00:18:47,020 --> 00:18:53,620
first core idea for me here is that as a

00:18:50,770 --> 00:18:55,540
community in order to make things like

00:18:53,620 --> 00:18:58,900
caching work seamlessly between

00:18:55,540 --> 00:19:00,700
different kinds of tools we can take

00:18:58,900 --> 00:19:01,960
advantage of graphic eul's existing

00:19:00,700 --> 00:19:03,400
advantages and figure out how to apply

00:19:01,960 --> 00:19:05,560
the same advantages that we already have

00:19:03,400 --> 00:19:07,480
but two other concepts so not just

00:19:05,560 --> 00:19:09,310
getting the fields and returning the

00:19:07,480 --> 00:19:10,600
data but getting the fields from the

00:19:09,310 --> 00:19:13,840
query and returning cache control

00:19:10,600 --> 00:19:15,100
information for example and again the

00:19:13,840 --> 00:19:17,350
other really exciting thing to me is

00:19:15,100 --> 00:19:19,330
that it's a full-stack approach because

00:19:17,350 --> 00:19:22,000
graphical is that thing that lives all

00:19:19,330 --> 00:19:24,580
the way between way back in the backend

00:19:22,000 --> 00:19:27,670
and then it goes all the way up to your

00:19:24,580 --> 00:19:29,320
actual UI components this thing isn't

00:19:27,670 --> 00:19:30,580
just a one-time-use thing that you use

00:19:29,320 --> 00:19:31,900
for that gateway part of your

00:19:30,580 --> 00:19:36,040
architecture it's something that you can

00:19:31,900 --> 00:19:37,780
use everywhere so you know you know if

00:19:36,040 --> 00:19:39,430
we actually get it right as a community

00:19:37,780 --> 00:19:41,050
if we get all the feedback together and

00:19:39,430 --> 00:19:43,240
figure out the right way to specify when

00:19:41,050 --> 00:19:44,920
graft killed data should expire maybe

00:19:43,240 --> 00:19:47,140
you won't have to write so many reef

00:19:44,920 --> 00:19:49,000
etches or manual pulling inside your

00:19:47,140 --> 00:19:51,940
graphical client anymore and it'll all

00:19:49,000 --> 00:19:54,310
work together pretty seamlessly all

00:19:51,940 --> 00:19:56,320
right so now I want to move into a

00:19:54,310 --> 00:19:59,050
second example out of the three and

00:19:56,320 --> 00:20:01,030
basically apply the exact same concepts

00:19:59,050 --> 00:20:01,980
that I just said but this time to

00:20:01,030 --> 00:20:06,000
another thing so

00:20:01,980 --> 00:20:07,200
very good parallelism so tracing errors

00:20:06,000 --> 00:20:10,679
is all about getting information from

00:20:07,200 --> 00:20:12,120
your server you know the thing on the

00:20:10,679 --> 00:20:14,250
left is bad and the thing on the right

00:20:12,120 --> 00:20:16,799
is good and on the left you see very

00:20:14,250 --> 00:20:18,570
coarse-grained not detailed information

00:20:16,799 --> 00:20:20,070
on the right you see very detailed

00:20:18,570 --> 00:20:21,990
information that gives you a lot of

00:20:20,070 --> 00:20:25,440
useful tips so you probably want the

00:20:21,990 --> 00:20:27,210
thing on the right and that means that

00:20:25,440 --> 00:20:29,010
something that only tracks performance

00:20:27,210 --> 00:20:31,799
information on a per endpoint basis is

00:20:29,010 --> 00:20:33,120
probably not going to work very well and

00:20:31,799 --> 00:20:35,039
to be clear there are a lot of tools

00:20:33,120 --> 00:20:37,289
that will give you something like per

00:20:35,039 --> 00:20:38,700
endpoint information for graph kill

00:20:37,289 --> 00:20:40,230
servers because at the end of the day

00:20:38,700 --> 00:20:41,370
those are just functions so you just

00:20:40,230 --> 00:20:45,570
have to instrument the functions and

00:20:41,370 --> 00:20:47,700
you've got your information and I would

00:20:45,570 --> 00:20:49,919
say you know if I was the the product

00:20:47,700 --> 00:20:52,320
manager product marketer for graph QL I

00:20:49,919 --> 00:20:54,450
could say graph QL is the first API

00:20:52,320 --> 00:20:56,909
technology with fine grained insights

00:20:54,450 --> 00:20:58,919
and analytics built in and when I say

00:20:56,909 --> 00:21:00,929
graph QL actually mean graph QL not like

00:20:58,919 --> 00:21:03,659
engine or some other tool that does this

00:21:00,929 --> 00:21:06,590
thing because this would actually be

00:21:03,659 --> 00:21:09,539
completely impossible without graph QL

00:21:06,590 --> 00:21:11,909
because you've got to have the schema

00:21:09,539 --> 00:21:13,740
because otherwise you don't have a UI to

00:21:11,909 --> 00:21:16,590
display this you don't know what fields

00:21:13,740 --> 00:21:18,870
exist and you've got to have the query

00:21:16,590 --> 00:21:21,600
language because if you don't know what

00:21:18,870 --> 00:21:22,710
field those clients are using then you

00:21:21,600 --> 00:21:24,360
don't know what fields the clients are

00:21:22,710 --> 00:21:26,730
using if you just get an endpoint and

00:21:24,360 --> 00:21:28,830
that returns a thousand fields you it's

00:21:26,730 --> 00:21:30,990
pretty hard to have a display showing

00:21:28,830 --> 00:21:32,549
how often those fields are consumed so I

00:21:30,990 --> 00:21:34,289
think this is a core benefit of graph QL

00:21:32,549 --> 00:21:36,120
is that the server understands what

00:21:34,289 --> 00:21:40,049
fields are being used by the client and

00:21:36,120 --> 00:21:42,600
where and putting that together with the

00:21:40,049 --> 00:21:44,309
performance information aspect now you

00:21:42,600 --> 00:21:45,840
can move basically between information

00:21:44,309 --> 00:21:48,269
about your client and information

00:21:45,840 --> 00:21:49,740
between about your server at will so if

00:21:48,269 --> 00:21:52,080
you know that a particular resolver and

00:21:49,740 --> 00:21:53,820
your server is slow all you have to do

00:21:52,080 --> 00:21:56,100
is find the queries in your client that

00:21:53,820 --> 00:21:58,740
use that resolver and you've found where

00:21:56,100 --> 00:22:01,110
the performance problems are gonna cause

00:21:58,740 --> 00:22:03,240
UI performance problems so now as a

00:22:01,110 --> 00:22:05,730
back-end developer you can understand

00:22:03,240 --> 00:22:07,440
what part of the UI you can improve with

00:22:05,730 --> 00:22:09,779
your performance improvements and as a

00:22:07,440 --> 00:22:12,600
firm developer you can know where those

00:22:09,779 --> 00:22:13,649
problems are coming from and forefront

00:22:12,600 --> 00:22:15,149
of developers there's a particularly

00:22:13,649 --> 00:22:15,810
great advantage which is that

00:22:15,149 --> 00:22:17,460
information

00:22:15,810 --> 00:22:20,130
first time is actually actionable

00:22:17,460 --> 00:22:21,360
because you know before if you had to

00:22:20,130 --> 00:22:23,910
call an end point and the end point is

00:22:21,360 --> 00:22:26,210
slow well then you just file a ticket

00:22:23,910 --> 00:22:29,190
and go home but now it's not that easy

00:22:26,210 --> 00:22:31,140
now what you can actually do is be

00:22:29,190 --> 00:22:34,290
empowered to change the way that your

00:22:31,140 --> 00:22:36,270
API performs based on information about

00:22:34,290 --> 00:22:38,010
perhaps what fields in it are slow so

00:22:36,270 --> 00:22:39,990
you know let's say you're getting an

00:22:38,010 --> 00:22:41,430
activity feed and you have a count and

00:22:39,990 --> 00:22:43,440
you have the individual activities and

00:22:41,430 --> 00:22:45,210
for some reason the total count is very

00:22:43,440 --> 00:22:47,820
slow maybe it's not critical for you to

00:22:45,210 --> 00:22:49,530
get that on the first render and so you

00:22:47,820 --> 00:22:51,810
can actually pop that field out of your

00:22:49,530 --> 00:22:54,000
query or you know if your system

00:22:51,810 --> 00:22:56,010
supports defer put defer directive on it

00:22:54,000 --> 00:22:58,140
and then you can actually get the

00:22:56,010 --> 00:22:59,460
initial data much faster and you should

00:22:58,140 --> 00:23:01,020
still tell the backend people they

00:22:59,460 --> 00:23:02,970
should make it faster but you can

00:23:01,020 --> 00:23:04,500
continue on your on your work and keep

00:23:02,970 --> 00:23:06,150
making your stuff better without being

00:23:04,500 --> 00:23:10,560
blocked which i think is like a core

00:23:06,150 --> 00:23:12,990
graphic you'll thing to do okay so

00:23:10,560 --> 00:23:14,820
looking through this lens before you

00:23:12,990 --> 00:23:16,020
know we have this infrastructure here

00:23:14,820 --> 00:23:18,060
we're doing the caching we've got the

00:23:16,020 --> 00:23:19,670
server and the client what about what

00:23:18,060 --> 00:23:22,500
about stuff like performance tracing and

00:23:19,670 --> 00:23:25,350
all these items have a have a role in

00:23:22,500 --> 00:23:27,840
that as well so the clients job is to

00:23:25,350 --> 00:23:30,120
declare the mapping from graphical

00:23:27,840 --> 00:23:31,710
queries to your UI components if you

00:23:30,120 --> 00:23:33,870
didn't have a graph killed client like

00:23:31,710 --> 00:23:36,450
relay or like Apollo it's pretty hard to

00:23:33,870 --> 00:23:38,460
achieve that declarative situation where

00:23:36,450 --> 00:23:41,160
your graphical queries live right next

00:23:38,460 --> 00:23:42,690
to your UI components and still keep

00:23:41,160 --> 00:23:43,710
your life to be pretty efficient because

00:23:42,690 --> 00:23:45,240
you might end up doing a lot more

00:23:43,710 --> 00:23:46,440
fetches if you don't have that that

00:23:45,240 --> 00:23:49,500
client part so I think it actually does

00:23:46,440 --> 00:23:51,210
enable that aspect of it the server has

00:23:49,500 --> 00:23:53,670
this fine grained way to call backends

00:23:51,210 --> 00:23:55,020
and a natural place to collect that

00:23:53,670 --> 00:23:57,900
performance information which is those

00:23:55,020 --> 00:24:00,660
resolvers and then those things come

00:23:57,900 --> 00:24:02,610
together in the middle where you can

00:24:00,660 --> 00:24:03,900
have a system that combines the

00:24:02,610 --> 00:24:06,600
knowledge about those queries from the

00:24:03,900 --> 00:24:09,030
UI and the traces from the field and the

00:24:06,600 --> 00:24:10,290
server and can do the complicated stuff

00:24:09,030 --> 00:24:12,450
like extracting those metrics

00:24:10,290 --> 00:24:14,580
aggregating them sampling stuff and

00:24:12,450 --> 00:24:16,050
doing all the analysis that you wouldn't

00:24:14,580 --> 00:24:17,850
want to live inside your JavaScript

00:24:16,050 --> 00:24:20,100
process for example or your Ruby process

00:24:17,850 --> 00:24:22,860
and you know if you look at some tracing

00:24:20,100 --> 00:24:23,730
standards like the platform it's the

00:24:22,860 --> 00:24:25,950
things called jÃ¤ger

00:24:23,730 --> 00:24:27,780
from uber they have a similar

00:24:25,950 --> 00:24:29,410
architecture where there's an agent that

00:24:27,780 --> 00:24:31,150
lives outside of your server process

00:24:29,410 --> 00:24:32,860
that does all the data collection

00:24:31,150 --> 00:24:36,630
aggregation because you don't want that

00:24:32,860 --> 00:24:39,790
to be blocking your requests and so

00:24:36,630 --> 00:24:41,920
another nice thing about this is that if

00:24:39,790 --> 00:24:43,270
it's you're going by the previous

00:24:41,920 --> 00:24:45,280
section that I had where that's where

00:24:43,270 --> 00:24:48,130
the caching lives you now have one place

00:24:45,280 --> 00:24:49,930
we're doing both your caching and your

00:24:48,130 --> 00:24:52,870
performance analysis so now maybe you

00:24:49,930 --> 00:24:54,940
can correlate when I'm caching is it

00:24:52,870 --> 00:24:56,680
actually faster I hope so

00:24:54,940 --> 00:24:57,700
how much is my cache being hit and how

00:24:56,680 --> 00:25:00,610
does that correlate with my back in

00:24:57,700 --> 00:25:01,780
performance having those things in the

00:25:00,610 --> 00:25:02,890
same layer and it doesn't matter

00:25:01,780 --> 00:25:04,870
necessarily if they're even the same

00:25:02,890 --> 00:25:06,130
tool or two different tools makes it so

00:25:04,870 --> 00:25:12,160
that you can use those things together

00:25:06,130 --> 00:25:13,690
much more easily and again this time

00:25:12,160 --> 00:25:15,430
with more history we've created a

00:25:13,690 --> 00:25:17,680
specification a couple months ago called

00:25:15,430 --> 00:25:20,410
Apollo tracing my colleague Martin

00:25:17,680 --> 00:25:23,770
designed this and the really cool thing

00:25:20,410 --> 00:25:26,520
about it is it's a way to get

00:25:23,770 --> 00:25:29,470
performance data on a per resolver level

00:25:26,520 --> 00:25:31,150
from any graphical server and this time

00:25:29,470 --> 00:25:33,820
it's actually something you can use

00:25:31,150 --> 00:25:37,480
today so if you're using javascript or

00:25:33,820 --> 00:25:39,490
Scala or Java or Ruby or a lick surf or

00:25:37,480 --> 00:25:42,670
your server you can actually install a

00:25:39,490 --> 00:25:44,980
package today run a graph QL query and

00:25:42,670 --> 00:25:48,010
see timing data in those resolvers like

00:25:44,980 --> 00:25:49,870
right now on your computer and doesn't

00:25:48,010 --> 00:25:51,760
require any services any anything you

00:25:49,870 --> 00:25:53,350
can just run that query from graphical

00:25:51,760 --> 00:25:57,300
and you can right away see what stuff is

00:25:53,350 --> 00:25:59,560
fast and what's slow and that's

00:25:57,300 --> 00:26:01,450
something that I think creates a whole

00:25:59,560 --> 00:26:02,860
new opportunity for a whole world of

00:26:01,450 --> 00:26:05,470
tools to integrate so now you have all

00:26:02,860 --> 00:26:07,300
this information and again it's tied to

00:26:05,470 --> 00:26:08,590
those core graph QL concepts like a

00:26:07,300 --> 00:26:11,050
graph kill query and your graph kill

00:26:08,590 --> 00:26:13,620
schema so you can imagine in your editor

00:26:11,050 --> 00:26:15,850
when you're writing graph kill query

00:26:13,620 --> 00:26:17,170
seeing those performance traces

00:26:15,850 --> 00:26:18,880
alongside the fields that you're writing

00:26:17,170 --> 00:26:21,160
or when you're writing your schema

00:26:18,880 --> 00:26:22,690
having that have a link to where you

00:26:21,160 --> 00:26:25,180
have information about how fast that

00:26:22,690 --> 00:26:27,310
resolver performs or maybe when you're

00:26:25,180 --> 00:26:28,570
doing design inside sketch which is

00:26:27,310 --> 00:26:30,910
something you can now do with graph QL

00:26:28,570 --> 00:26:32,740
maybe inside sketch it tells you

00:26:30,910 --> 00:26:34,450
designer look you might want this design

00:26:32,740 --> 00:26:36,760
but right now that's not going to work

00:26:34,450 --> 00:26:38,560
out too well and basically you can

00:26:36,760 --> 00:26:41,590
short-circuit entire parts of your

00:26:38,560 --> 00:26:43,149
design deployment process because you

00:26:41,590 --> 00:26:44,830
have these core primitives of this

00:26:43,149 --> 00:26:48,759
and the query that you can attach this

00:26:44,830 --> 00:26:51,099
information to so that's the other idea

00:26:48,759 --> 00:26:53,469
here is because all this information

00:26:51,099 --> 00:26:55,389
that you know about your API is attached

00:26:53,469 --> 00:26:58,570
to those core concepts in graphic UL I

00:26:55,389 --> 00:27:01,690
believe that it is graph QL itself which

00:26:58,570 --> 00:27:03,399
enables this type of integration because

00:27:01,690 --> 00:27:05,529
in other types of API is there just

00:27:03,399 --> 00:27:08,440
aren't defined enough concepts to have

00:27:05,529 --> 00:27:10,299
that information be both provided or

00:27:08,440 --> 00:27:13,049
even receive in a standardized fashion

00:27:10,299 --> 00:27:16,419
so I think this is absolutely amazing

00:27:13,049 --> 00:27:22,629
and I've created here a totally for free

00:27:16,419 --> 00:27:25,089
mock-up you can use this without any

00:27:22,629 --> 00:27:28,119
sort of attribution but you could

00:27:25,089 --> 00:27:30,429
definitely you know if you take the

00:27:28,119 --> 00:27:31,629
Friday off after summit you're too tired

00:27:30,429 --> 00:27:34,059
because you just work too much awesome

00:27:31,629 --> 00:27:36,429
graph chill stuff check out that tracing

00:27:34,059 --> 00:27:38,229
standard install it on your server run a

00:27:36,429 --> 00:27:39,700
query and then just write a very simple

00:27:38,229 --> 00:27:41,830
react component that just goes right

00:27:39,700 --> 00:27:44,080
into graphical and displays those little

00:27:41,830 --> 00:27:45,969
trace bars for you and then everyone on

00:27:44,080 --> 00:27:47,379
your team and everyone in the world will

00:27:45,969 --> 00:27:48,909
be able to run those queries and get a

00:27:47,379 --> 00:27:52,869
nice visual display of how fast they

00:27:48,909 --> 00:27:56,279
were anytime I mean that sounds cool so

00:27:52,869 --> 00:28:00,820
I got pretty far into design right but

00:27:56,279 --> 00:28:03,940
there are maybe maybe improvements to be

00:28:00,820 --> 00:28:06,039
made but I will 100% use this tool

00:28:03,940 --> 00:28:09,549
immediately but unfortunately I didn't

00:28:06,039 --> 00:28:10,719
have time to build yet so I think it's

00:28:09,549 --> 00:28:13,059
really cool that the graphical

00:28:10,719 --> 00:28:14,950
specification is robust enough to spawn

00:28:13,059 --> 00:28:16,479
these thousands of companion tools that

00:28:14,950 --> 00:28:18,759
work with every single platform in the

00:28:16,479 --> 00:28:20,289
world you know whenever somebody comes

00:28:18,759 --> 00:28:24,279
to me and they're like can I use graph

00:28:20,289 --> 00:28:26,619
QL I basically never have to say no so I

00:28:24,279 --> 00:28:30,549
think that is one of the core benefits

00:28:26,619 --> 00:28:32,259
of the whole technology and so you know

00:28:30,549 --> 00:28:34,989
we already see people doing stuff like

00:28:32,259 --> 00:28:37,419
coming up with platform specific or tool

00:28:34,989 --> 00:28:39,369
specific ways to do things like extract

00:28:37,419 --> 00:28:40,749
performance information right there are

00:28:39,369 --> 00:28:42,789
already some graphical servers that have

00:28:40,749 --> 00:28:45,429
their own libraries that have a very

00:28:42,789 --> 00:28:47,320
specific format and what we've tried to

00:28:45,429 --> 00:28:49,539
do with Apollo tracing is we actually

00:28:47,320 --> 00:28:51,460
had our own specific format that was

00:28:49,539 --> 00:28:53,200
working for us and we decided to move in

00:28:51,460 --> 00:28:55,779
the direction of having it not be that

00:28:53,200 --> 00:28:56,440
thing so that now people can build tools

00:28:55,779 --> 00:28:58,360
like that

00:28:56,440 --> 00:29:01,060
you and graphical because the most

00:28:58,360 --> 00:29:03,100
important thing is that we don't have a

00:29:01,060 --> 00:29:05,890
whole ton of different standards for

00:29:03,100 --> 00:29:06,910
this stuff it's important that you know

00:29:05,890 --> 00:29:08,740
when you have a tool that works with

00:29:06,910 --> 00:29:11,920
graph QL it works with as much of graph

00:29:08,740 --> 00:29:13,750
QL as possible you know later that will

00:29:11,920 --> 00:29:15,760
include stuff like subscriptions which

00:29:13,750 --> 00:29:16,750
is going to raise new challenges of how

00:29:15,760 --> 00:29:18,250
do you get all these tools to work

00:29:16,750 --> 00:29:20,470
together without an arduous amount of

00:29:18,250 --> 00:29:22,690
configuration all right

00:29:20,470 --> 00:29:24,310
the third example and this one is very

00:29:22,690 --> 00:29:26,350
close to my heart is the idea of schema

00:29:24,310 --> 00:29:27,850
stitching and you guys I was gonna ask

00:29:26,350 --> 00:29:29,290
if people have heard of this before

00:29:27,850 --> 00:29:30,610
but if you were here yesterday you heard

00:29:29,290 --> 00:29:32,410
about it at least three times throughout

00:29:30,610 --> 00:29:34,090
different talks which is really really

00:29:32,410 --> 00:29:35,500
cool because I can see that it's

00:29:34,090 --> 00:29:37,270
becoming a thing that's really catching

00:29:35,500 --> 00:29:40,300
on in a lot of people's minds and that's

00:29:37,270 --> 00:29:43,320
exciting and I think this is another

00:29:40,300 --> 00:29:45,970
instance of that responsibilities

00:29:43,320 --> 00:29:47,650
movement that I was thinking about and I

00:29:45,970 --> 00:29:49,510
think this one is maybe a little bit

00:29:47,650 --> 00:29:51,100
less important because there isn't as

00:29:49,510 --> 00:29:53,290
much of a problem of like different

00:29:51,100 --> 00:29:56,320
versions of clients and servers but

00:29:53,290 --> 00:29:59,770
there's still a case where you have your

00:29:56,320 --> 00:30:01,120
back-end data service which functionally

00:29:59,770 --> 00:30:03,550
has some sort of schema it might be

00:30:01,120 --> 00:30:05,770
written in a type safe language but then

00:30:03,550 --> 00:30:07,660
when you're using today's technologies

00:30:05,770 --> 00:30:10,090
to write a graph kill API you often have

00:30:07,660 --> 00:30:12,010
to describe that again and describing it

00:30:10,090 --> 00:30:14,350
again is actually a good idea because

00:30:12,010 --> 00:30:16,660
you want to think about what your

00:30:14,350 --> 00:30:19,060
client-side API looks like it shouldn't

00:30:16,660 --> 00:30:20,350
necessarily be tied to what the API of

00:30:19,060 --> 00:30:23,110
your back-end looks like in fact it

00:30:20,350 --> 00:30:24,880
probably shouldn't be however I still

00:30:23,110 --> 00:30:27,040
want to make the claim that you're

00:30:24,880 --> 00:30:28,680
probably more equipped to describe that

00:30:27,040 --> 00:30:31,450
API for that portion of your back-end

00:30:28,680 --> 00:30:33,370
closer to where it lives or at the very

00:30:31,450 --> 00:30:35,770
least you might be an organization where

00:30:33,370 --> 00:30:37,810
people own different parts of the data

00:30:35,770 --> 00:30:39,910
so you might have a team that deals with

00:30:37,810 --> 00:30:41,170
user data or payments data and those

00:30:39,910 --> 00:30:42,910
people know a lot more about that data

00:30:41,170 --> 00:30:46,840
model then somebody who might be on a

00:30:42,910 --> 00:30:48,250
separate API team but basically we've

00:30:46,840 --> 00:30:49,810
seen this pattern over and over again

00:30:48,250 --> 00:30:51,130
which is why I'm really excited about

00:30:49,810 --> 00:30:52,810
schema stitching is because I really

00:30:51,130 --> 00:30:54,940
think that it's a good idea to have

00:30:52,810 --> 00:30:56,440
exactly one graphical client in your app

00:30:54,940 --> 00:30:58,000
and it's good to have exactly one

00:30:56,440 --> 00:30:59,530
graphic Yool schema that you're querying

00:30:58,000 --> 00:31:00,520
so you can get all of your data but

00:30:59,530 --> 00:31:02,260
we've heard of a lot of people using

00:31:00,520 --> 00:31:04,540
multiple clients together with multiple

00:31:02,260 --> 00:31:07,120
servers in the same app and so I hope

00:31:04,540 --> 00:31:08,980
that we can live soon in a world where

00:31:07,120 --> 00:31:10,029
something like this is possible where

00:31:08,980 --> 00:31:12,219
you can have exactly one

00:31:10,029 --> 00:31:13,779
Kuehl client and one global schema that

00:31:12,219 --> 00:31:16,599
describes the world of data that you've

00:31:13,779 --> 00:31:18,340
got in your company and then that might

00:31:16,599 --> 00:31:21,219
be split up into multiple servers but

00:31:18,340 --> 00:31:22,210
that's okay because to me from the API

00:31:21,219 --> 00:31:26,139
perspective that's more of an

00:31:22,210 --> 00:31:27,580
implementation detail so this is my

00:31:26,139 --> 00:31:31,629
favorite scheme of stitching example

00:31:27,580 --> 00:31:33,519
that I have used a couple of times but

00:31:31,629 --> 00:31:35,590
basically we use a ticketing system

00:31:33,519 --> 00:31:38,320
called universe for graphic you'll

00:31:35,590 --> 00:31:40,629
summit and thankfully universe has a

00:31:38,320 --> 00:31:42,190
public graph QAPI and you can send it a

00:31:40,629 --> 00:31:43,839
query like the one on the top right

00:31:42,190 --> 00:31:45,070
where you give it the event ID for

00:31:43,839 --> 00:31:46,690
graphic you'll summit you can get the

00:31:45,070 --> 00:31:47,799
name of the event and the name of the

00:31:46,690 --> 00:31:52,899
city that it's in which is San Francisco

00:31:47,799 --> 00:31:55,899
and then a great community member named

00:31:52,899 --> 00:31:58,589
Matt Matt deonna's I don't know if he's

00:31:55,899 --> 00:32:00,700
in this room he probably is somewhere

00:31:58,589 --> 00:32:01,839
created a great API lets you get the

00:32:00,700 --> 00:32:03,759
weather based on the name of the

00:32:01,839 --> 00:32:05,769
location and then you're like well a

00:32:03,759 --> 00:32:07,269
very critical thing for me to do is to

00:32:05,769 --> 00:32:08,739
understand what weather it's gonna be

00:32:07,269 --> 00:32:10,269
when I show up to graph kill some it and

00:32:08,739 --> 00:32:12,999
thankfully with schema stitching you can

00:32:10,269 --> 00:32:14,379
actually combine these two queries so

00:32:12,999 --> 00:32:15,669
that you can pipe that city name

00:32:14,379 --> 00:32:17,499
directly into the argument of that

00:32:15,669 --> 00:32:18,759
location field and get exactly one

00:32:17,499 --> 00:32:22,690
schema that tells the information about

00:32:18,759 --> 00:32:24,669
the event and about the weather and this

00:32:22,690 --> 00:32:26,679
is my NASCAR slide here of just how

00:32:24,669 --> 00:32:28,599
exciting it is as so many people are

00:32:26,679 --> 00:32:30,549
looking into this type of technology and

00:32:28,599 --> 00:32:32,589
type of API construction this is a

00:32:30,549 --> 00:32:34,779
screenshot from johannes has talked

00:32:32,589 --> 00:32:37,690
yesterday about using graphical schema

00:32:34,779 --> 00:32:39,099
stitching jason from IBM had a different

00:32:37,690 --> 00:32:41,379
way of modularizing schemas which is

00:32:39,099 --> 00:32:42,820
also very cool the api's guru guys here

00:32:41,379 --> 00:32:44,529
made a tool called graphic you'll join

00:32:42,820 --> 00:32:46,869
which you can click on the link on when

00:32:44,529 --> 00:32:48,399
you download the slides later we've got

00:32:46,869 --> 00:32:50,200
a library that does it I think this is

00:32:48,399 --> 00:32:52,330
gonna be a big deal so I don't know

00:32:50,200 --> 00:32:54,279
exactly the right way yet that this is

00:32:52,330 --> 00:32:55,479
gonna work but I think making graph kill

00:32:54,279 --> 00:32:58,119
scheme is modular and then combining

00:32:55,479 --> 00:33:03,070
them you should write that in your top

00:32:58,119 --> 00:33:04,929
trends for late 2017 in graph QL so

00:33:03,070 --> 00:33:06,580
essentially the hope here is you can get

00:33:04,929 --> 00:33:07,809
the best of both worlds you can get that

00:33:06,580 --> 00:33:09,909
developer experience of having a

00:33:07,809 --> 00:33:11,440
universal API for your front ends but

00:33:09,909 --> 00:33:14,080
you can still have those modular and

00:33:11,440 --> 00:33:15,700
independently deployed services that you

00:33:14,080 --> 00:33:18,549
want from from a micro service style

00:33:15,700 --> 00:33:20,830
architecture and that means you're

00:33:18,549 --> 00:33:22,869
serving well both the front developers

00:33:20,830 --> 00:33:23,650
and API consumers and the people who are

00:33:22,869 --> 00:33:26,740
building and deploying the

00:33:23,650 --> 00:33:27,850
backends so this is what your

00:33:26,740 --> 00:33:30,250
architecture might look like today if

00:33:27,850 --> 00:33:31,780
you're using graph QL which is really

00:33:30,250 --> 00:33:33,070
awesome by the way I'm not in any way

00:33:31,780 --> 00:33:35,050
advocating that people should start

00:33:33,070 --> 00:33:37,420
changing their api's if this

00:33:35,050 --> 00:33:39,040
architecture works for you that's 100%

00:33:37,420 --> 00:33:40,870
awesome this is all coming from a place

00:33:39,040 --> 00:33:42,400
of people coming to me and asking me

00:33:40,870 --> 00:33:43,870
could I have a different type of

00:33:42,400 --> 00:33:45,130
architecture and this is the same one

00:33:43,870 --> 00:33:47,260
that we use this is the one that

00:33:45,130 --> 00:33:49,680
Facebook uses and they sure have a lot

00:33:47,260 --> 00:33:52,360
of data in there so it works great

00:33:49,680 --> 00:33:53,890
however if you're looking for that

00:33:52,360 --> 00:33:56,250
approach where you can deploy your

00:33:53,890 --> 00:33:58,060
different graph QL services separately

00:33:56,250 --> 00:34:01,000
you could go with something like this

00:33:58,060 --> 00:34:03,940
where you start adding graph QL to your

00:34:01,000 --> 00:34:05,710
back-end services so you're back and

00:34:03,940 --> 00:34:06,940
services speak graph kill your service

00:34:05,710 --> 00:34:08,770
Peaks craft kill your Gateway speak

00:34:06,940 --> 00:34:10,690
scratch kill your client speaks craft QL

00:34:08,770 --> 00:34:12,909
maybe your client can even use graph QL

00:34:10,690 --> 00:34:14,620
to load data from client-side data so

00:34:12,909 --> 00:34:15,669
now you go graph QL everywhere and it's

00:34:14,620 --> 00:34:18,850
all working together and it has a

00:34:15,669 --> 00:34:20,050
unified schema and it's wonderful you

00:34:18,850 --> 00:34:23,080
still have a single codebase though

00:34:20,050 --> 00:34:24,100
which is the server thing which is you

00:34:23,080 --> 00:34:27,570
know has code to stitch all these

00:34:24,100 --> 00:34:30,340
schemas together and so the ideal

00:34:27,570 --> 00:34:33,730
picture for me is a picture that

00:34:30,340 --> 00:34:36,040
actually looks like this because you

00:34:33,730 --> 00:34:38,649
already have this gateway place where

00:34:36,040 --> 00:34:40,270
you're doing the caching you're maybe

00:34:38,649 --> 00:34:42,460
doing some performance analysis using

00:34:40,270 --> 00:34:44,020
those various standards and all that

00:34:42,460 --> 00:34:45,460
stuff would be great if it also tied

00:34:44,020 --> 00:34:47,860
into your various sub schemas that you

00:34:45,460 --> 00:34:49,540
have because maybe you want to cache the

00:34:47,860 --> 00:34:51,460
request those backends separately or

00:34:49,540 --> 00:34:53,230
maybe you want to get finer grained

00:34:51,460 --> 00:34:55,390
performance tracing that shows you which

00:34:53,230 --> 00:34:56,760
back-end each field came from you want

00:34:55,390 --> 00:34:59,620
to aggregate the errors in a certain way

00:34:56,760 --> 00:35:02,650
you can load data you know from graph

00:34:59,620 --> 00:35:05,020
cool and from neo4j and from your custom

00:35:02,650 --> 00:35:07,510
back-end or legacy back-end all the same

00:35:05,020 --> 00:35:11,980
time but still present that as a unified

00:35:07,510 --> 00:35:13,510
API to your consumers and again this can

00:35:11,980 --> 00:35:15,130
be especially useful if you're in a

00:35:13,510 --> 00:35:17,260
world where you're an enterprise

00:35:15,130 --> 00:35:19,510
situation with a lot of different teams

00:35:17,260 --> 00:35:21,250
that have to work somewhat independently

00:35:19,510 --> 00:35:24,670
and you don't want to be blocked on

00:35:21,250 --> 00:35:26,980
somebody reviewing your PRS to some

00:35:24,670 --> 00:35:28,150
schema that they own so I think this is

00:35:26,980 --> 00:35:30,220
going to be a really huge deal for

00:35:28,150 --> 00:35:36,010
companies that need that kind of

00:35:30,220 --> 00:35:37,490
flexibility in their deployment so the

00:35:36,010 --> 00:35:41,030
overarching point for me is that

00:35:37,490 --> 00:35:42,830
I think this duality of the client query

00:35:41,030 --> 00:35:44,930
sending the detailed data requirements

00:35:42,830 --> 00:35:46,310
and detailed is important because the

00:35:44,930 --> 00:35:48,170
fact that you specify every field that

00:35:46,310 --> 00:35:49,550
you're looking for is a critical aspect

00:35:48,170 --> 00:35:52,040
of graphical that can't be overlooked

00:35:49,550 --> 00:35:56,240
and the fact that the server schema is

00:35:52,040 --> 00:35:58,310
both flexible and very performant is

00:35:56,240 --> 00:35:59,510
like the core the core idea of graphical

00:35:58,310 --> 00:36:02,869
and I hope that I've convinced you that

00:35:59,510 --> 00:36:06,320
all the ideas that I was covering before

00:36:02,869 --> 00:36:07,340
fit into this paradigm and all these

00:36:06,320 --> 00:36:09,170
things are going to be continuously

00:36:07,340 --> 00:36:10,550
improving you know all these three

00:36:09,170 --> 00:36:13,820
topics that we came back to you so for

00:36:10,550 --> 00:36:15,380
example you know we might have some of

00:36:13,820 --> 00:36:16,910
these categories with maybe particular

00:36:15,380 --> 00:36:19,880
instances of those things these are the

00:36:16,910 --> 00:36:21,830
ones that I had a hand in building so

00:36:19,880 --> 00:36:24,920
those the ones I put but there's other

00:36:21,830 --> 00:36:26,480
options for all these and then here are

00:36:24,920 --> 00:36:28,310
some of these different capabilities you

00:36:26,480 --> 00:36:31,160
might have and I want to live in a world

00:36:28,310 --> 00:36:33,410
where this grid is completely filled out

00:36:31,160 --> 00:36:36,140
with green checkmarks I can look at

00:36:33,410 --> 00:36:38,030
caching information in my editor I can

00:36:36,140 --> 00:36:39,260
look at errors in my dev tools actually

00:36:38,030 --> 00:36:40,820
you can already do that so I should have

00:36:39,260 --> 00:36:42,710
put a checkmark there

00:36:40,820 --> 00:36:44,300
you know there's schema stitching on the

00:36:42,710 --> 00:36:46,160
client in a sense because you can

00:36:44,300 --> 00:36:47,119
combine your client-side data with your

00:36:46,160 --> 00:36:49,640
server-side data that came from

00:36:47,119 --> 00:36:51,020
graphical so I put a little party popper

00:36:49,640 --> 00:36:53,060
on there because that was just announced

00:36:51,020 --> 00:36:54,350
recently you know I think both really

00:36:53,060 --> 00:36:56,359
modern and Apollo client now I have a

00:36:54,350 --> 00:36:58,550
capability to do that extremely exciting

00:36:56,359 --> 00:36:59,960
so then we can come up with the next

00:36:58,550 --> 00:37:03,380
thing once we have all these things

00:36:59,960 --> 00:37:05,150
fully integrated and you can just keep

00:37:03,380 --> 00:37:07,940
thinking of graph QL as this unified and

00:37:05,150 --> 00:37:09,500
compatible way to do that middle part of

00:37:07,940 --> 00:37:13,400
your app that lives in between your

00:37:09,500 --> 00:37:17,900
clients and your backends and I think

00:37:13,400 --> 00:37:19,220
that's why graph QL you know sometimes I

00:37:17,900 --> 00:37:20,180
think in the past especially we would

00:37:19,220 --> 00:37:22,760
talk to people and they'd be like yeah

00:37:20,180 --> 00:37:25,820
it's a curiosity it's a cool way to do

00:37:22,760 --> 00:37:27,530
some api's I went to a API academics

00:37:25,820 --> 00:37:28,910
conference and they compared it to a lot

00:37:27,530 --> 00:37:31,310
of other things and there are a lot of

00:37:28,910 --> 00:37:32,780
trade-offs but I think that's all

00:37:31,310 --> 00:37:35,660
details because when we talk to people

00:37:32,780 --> 00:37:37,130
who are using graph QL they see it as

00:37:35,660 --> 00:37:38,960
something that changes the whole game of

00:37:37,130 --> 00:37:41,750
how they're developing their application

00:37:38,960 --> 00:37:44,420
and I think we're just at the start of

00:37:41,750 --> 00:37:46,160
that it's only been what two years

00:37:44,420 --> 00:37:48,920
something like that a little bit over

00:37:46,160 --> 00:37:50,640
two years think about what we're gonna

00:37:48,920 --> 00:37:53,070
be doing ten years from now

00:37:50,640 --> 00:37:55,440
and I think it's gonna be very very

00:37:53,070 --> 00:37:58,170
exciting and I can't wait to go there

00:37:55,440 --> 00:38:01,800
with you that's what we're all about at

00:37:58,170 --> 00:38:02,730
Apollo coming back to that is we gone to

00:38:01,800 --> 00:38:04,590
the graphical hypetrain

00:38:02,730 --> 00:38:05,640
pretty early because we felt that it was

00:38:04,590 --> 00:38:07,410
going to be that transformative

00:38:05,640 --> 00:38:09,480
technology that was going to be a

00:38:07,410 --> 00:38:11,910
critical part of what everyone is doing

00:38:09,480 --> 00:38:13,560
and you would really be hampering

00:38:11,910 --> 00:38:15,990
yourself if you weren't using graphical

00:38:13,560 --> 00:38:19,350
especially now you know years in future

00:38:15,990 --> 00:38:21,060
so anyway thank you so much for coming

00:38:19,350 --> 00:38:22,870
listening to me and let's go on this

00:38:21,060 --> 00:38:28,060
journey together and thank you very much

00:38:22,870 --> 00:38:28,060

YouTube URL: https://www.youtube.com/watch?v=ykp6Za9rM58


