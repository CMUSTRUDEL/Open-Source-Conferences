Title: GraphQL and Coursera & their API evolution
Publication date: 2016-11-02
Playlist: GraphQL Summit 2016
Description: 
	Brennan Saeta, Coursera

Coursera’s educational platform has a broad API surface implemented in a standardized, sophisticated HTTP/JSON framework backed by a distributed microservice architecture. However, one of the biggest challenges engineers face is assembling all the data required to render the UI on both web and mobile clients. To radically improve our engineering velocity, we are migrating nearly 100% of our client data access to GraphQL. But we’re doing it WITHOUT throwing away our existing backend APIs, architecture, and tools. This talk will describe our approach to making every Coursera API available via GraphQL, with zero developer overhead. 

Slides: https://building.coursera.org/blog/2016/10/28/graphql-summit/

Learn more about GraphQL Summit:
http://graphqlsummit.com

Join our GraphQL SF meetup to hear more about GraphQL best practices and implementations: 
http://meetup.com/GraphQL-SF/
Captions: 
	00:00:03,780 --> 00:00:09,690
all right thank you all for staying

00:00:07,229 --> 00:00:14,120
awake on in sort of the peak nap time of

00:00:09,690 --> 00:00:16,230
the afternoon today I want to talk about

00:00:14,120 --> 00:00:17,840
Coursera's approach to graph QL and

00:00:16,230 --> 00:00:19,410
actually Coursera's story of adoption

00:00:17,840 --> 00:00:20,730
because I think it's a little bit

00:00:19,410 --> 00:00:22,680
different from most of the stories

00:00:20,730 --> 00:00:24,150
you've heard so far today and and how

00:00:22,680 --> 00:00:25,560
we've how other companies have

00:00:24,150 --> 00:00:27,750
approached graph QL and I think that

00:00:25,560 --> 00:00:30,810
there is a number of lessons that we've

00:00:27,750 --> 00:00:35,489
learned throughout our journey that are

00:00:30,810 --> 00:00:37,530
useful to others so today we're going to

00:00:35,489 --> 00:00:40,859
trace through Coursera's adoption is we

00:00:37,530 --> 00:00:44,039
started from from early days and rest

00:00:40,859 --> 00:00:47,989
api's and and how we've evolved our our

00:00:44,039 --> 00:00:52,499
API frameworks to to graph QL actually

00:00:47,989 --> 00:00:54,030
so imagine you're back in 2012 Coursera

00:00:52,499 --> 00:00:57,719
was just founded by two Stanford

00:00:54,030 --> 00:00:59,429
professors and and with a mission to to

00:00:57,719 --> 00:01:01,769
bring universal access to the world's

00:00:59,429 --> 00:01:03,659
best education so Coursera for those of

00:01:01,769 --> 00:01:06,020
you who aren't familiar of course there

00:01:03,659 --> 00:01:08,130
are partners with the world's best

00:01:06,020 --> 00:01:10,770
institutions for higher learning and

00:01:08,130 --> 00:01:12,810
otherwise and an education in high

00:01:10,770 --> 00:01:14,969
technology we help them take their best

00:01:12,810 --> 00:01:16,590
courses from their best instructors and

00:01:14,969 --> 00:01:19,140
put them online and make them available

00:01:16,590 --> 00:01:22,860
either for free or for very very low

00:01:19,140 --> 00:01:24,960
cost okay and so I started at Coursera

00:01:22,860 --> 00:01:26,789
we were you know actually a very small

00:01:24,960 --> 00:01:29,130
scrappy team sitting around a single

00:01:26,789 --> 00:01:30,299
table we're like half dozen of us and we

00:01:29,130 --> 00:01:33,600
had sort of the basic in course

00:01:30,299 --> 00:01:34,920
experience working okay and we needed we

00:01:33,600 --> 00:01:37,920
were signing up courses and instructors

00:01:34,920 --> 00:01:39,990
and partnering universities like mad and

00:01:37,920 --> 00:01:41,490
and we we quickly discovered a problem

00:01:39,990 --> 00:01:43,140
of hey we need a directory we need a

00:01:41,490 --> 00:01:45,719
catalog for all the courses that we had

00:01:43,140 --> 00:01:46,799
available and our front-end teams like

00:01:45,719 --> 00:01:49,530
guys guys guys guys guys

00:01:46,799 --> 00:01:51,960
JavaScript single page apps they're the

00:01:49,530 --> 00:01:53,429
way of the future let's use jQuery it's

00:01:51,960 --> 00:01:57,600
gonna be great this is the right way to

00:01:53,429 --> 00:01:59,640
build single page apps so myself is the

00:01:57,600 --> 00:02:01,320
back-end engineer like fine what do you

00:01:59,640 --> 00:02:03,539
need they're like just give us JSON

00:02:01,320 --> 00:02:05,969
rest-based API is this is the future

00:02:03,539 --> 00:02:08,550
this is how we build apps so okay fine

00:02:05,969 --> 00:02:10,830
that's what we did our front-end team

00:02:08,550 --> 00:02:13,230
put together a JavaScript based single

00:02:10,830 --> 00:02:15,900
page app and as a back-end team we gave

00:02:13,230 --> 00:02:17,430
them all the JSON they needed and what I

00:02:15,900 --> 00:02:19,769
mean that I mean we gave

00:02:17,430 --> 00:02:22,019
all the JSON we had a fairly small

00:02:19,769 --> 00:02:25,950
catalog and so we made one monolithic

00:02:22,019 --> 00:02:27,989
API that basically was the entire

00:02:25,950 --> 00:02:30,239
catalog all the courses all the

00:02:27,989 --> 00:02:32,549
instructors all the universities and we

00:02:30,239 --> 00:02:35,489
just served it in one one single API

00:02:32,549 --> 00:02:38,099
call it was fast like this was great our

00:02:35,489 --> 00:02:39,840
JavaScript developers could take all the

00:02:38,099 --> 00:02:41,879
data that they needed out of this API

00:02:39,840 --> 00:02:43,620
display whatever pages they want and

00:02:41,879 --> 00:02:44,639
they could iterate very quickly so this

00:02:43,620 --> 00:02:46,829
was our home page

00:02:44,639 --> 00:02:49,079
but that same API powered our catalog

00:02:46,829 --> 00:02:51,030
search page and it was a super snappy

00:02:49,079 --> 00:02:52,560
experience because JavaScript would just

00:02:51,030 --> 00:02:54,450
run really quickly and as you typed in

00:02:52,560 --> 00:02:56,970
queries it auto-completed immediately

00:02:54,450 --> 00:02:59,220
and and this worked really really great

00:02:56,970 --> 00:03:02,459
we're able to iterate on front-end

00:02:59,220 --> 00:03:03,780
products and and development and we we

00:03:02,459 --> 00:03:06,209
were decoupled between front-end and

00:03:03,780 --> 00:03:09,120
back-end and this is actually a really a

00:03:06,209 --> 00:03:13,290
really great technology choice as we

00:03:09,120 --> 00:03:13,819
were getting started at Coursera until

00:03:13,290 --> 00:03:16,379
it wasn't

00:03:13,819 --> 00:03:18,030
we actually fairly quickly ran into a

00:03:16,379 --> 00:03:19,519
number of problems but they're not

00:03:18,030 --> 00:03:23,190
actually the ones that at least I

00:03:19,519 --> 00:03:24,540
initially anticipated I thought that you

00:03:23,190 --> 00:03:26,699
know the scale problem sending the

00:03:24,540 --> 00:03:27,840
entire database essentially in one API

00:03:26,699 --> 00:03:30,930
request I thought that was going to be

00:03:27,840 --> 00:03:32,669
what what Killah so this turns out no it

00:03:30,930 --> 00:03:36,030
was actually the fact that product needs

00:03:32,669 --> 00:03:37,530
change so rapidly at a start-up in a

00:03:36,030 --> 00:03:41,639
company that's innovating very quickly

00:03:37,530 --> 00:03:44,519
and very very quickly we realized that

00:03:41,639 --> 00:03:46,769
the api's that we built just weren't

00:03:44,519 --> 00:03:48,329
flexible enough so let me make this a

00:03:46,769 --> 00:03:50,639
bit more concrete biases by some

00:03:48,329 --> 00:03:52,470
examples we started introducing course

00:03:50,639 --> 00:03:55,620
sequences what we call specializations

00:03:52,470 --> 00:03:57,060
and in our monolithic API you know we

00:03:55,620 --> 00:03:58,859
sort of had to slam it in in this

00:03:57,060 --> 00:04:01,409
sidecar manner because we couldn't

00:03:58,859 --> 00:04:02,849
change the existing monolithic API it

00:04:01,409 --> 00:04:05,879
was dependent upon by too many

00:04:02,849 --> 00:04:08,159
individual JavaScript pages we couldn't

00:04:05,879 --> 00:04:10,949
make a single huge change to refactor at

00:04:08,159 --> 00:04:12,989
how we wanted it and so as we had

00:04:10,949 --> 00:04:15,180
specializations and identity verified

00:04:12,989 --> 00:04:16,650
certificates signature track our premium

00:04:15,180 --> 00:04:18,959
course certificates you know we sort of

00:04:16,650 --> 00:04:21,180
nationally data in on the side and that

00:04:18,959 --> 00:04:23,880
worked ok you know it was hacky but

00:04:21,180 --> 00:04:25,680
worked unfortunately the rubber really

00:04:23,880 --> 00:04:27,719
hit the road when some fundamental

00:04:25,680 --> 00:04:30,539
assumptions of our data model just got

00:04:27,719 --> 00:04:31,169
violated so when we built our quest

00:04:30,539 --> 00:04:33,090
catalog

00:04:31,169 --> 00:04:35,009
assume that every single course was

00:04:33,090 --> 00:04:36,689
gonna come from one and only one

00:04:35,009 --> 00:04:38,310
university partner it may have a couple

00:04:36,689 --> 00:04:40,740
instructors but one and only one

00:04:38,310 --> 00:04:43,169
university partner this was great

00:04:40,740 --> 00:04:44,819
up until two of our university partners

00:04:43,169 --> 00:04:47,610
said hey we want to collaborate on this

00:04:44,819 --> 00:04:49,499
course in real life okay so only one of

00:04:47,610 --> 00:04:52,469
you can be on the course catalog and

00:04:49,499 --> 00:04:56,789
like no no no no and we lost that battle

00:04:52,469 --> 00:04:59,340
real fast um so so you know that that

00:04:56,789 --> 00:05:01,229
really started showing the the frailty

00:04:59,340 --> 00:05:02,939
of this monolithic based API approach

00:05:01,229 --> 00:05:05,689
that that actually was serving us very

00:05:02,939 --> 00:05:08,009
very effectively at the beginning

00:05:05,689 --> 00:05:09,389
additionally as we were growing the size

00:05:08,009 --> 00:05:10,169
of our engineering team growing very

00:05:09,389 --> 00:05:12,080
very rapidly

00:05:10,169 --> 00:05:14,159
we started stepping on each other's toes

00:05:12,080 --> 00:05:16,199
our front-end teams were actually able

00:05:14,159 --> 00:05:17,669
to iterate in parallel they had the same

00:05:16,199 --> 00:05:19,379
data model but they had different pages

00:05:17,669 --> 00:05:21,389
in different view layouts and they could

00:05:19,379 --> 00:05:23,999
innovate as fast as they wanted to but

00:05:21,389 --> 00:05:25,889
on back end when one team wanted to add

00:05:23,999 --> 00:05:27,659
that specialization data and another

00:05:25,889 --> 00:05:29,069
team wanted to add the premium of course

00:05:27,659 --> 00:05:30,509
certificate data you know we started

00:05:29,069 --> 00:05:33,539
getting these merge conflicts and it was

00:05:30,509 --> 00:05:36,300
fairly tricky we sort of figured it out

00:05:33,539 --> 00:05:38,039
but this monolithic approach just didn't

00:05:36,300 --> 00:05:40,259
work so well for a single a single

00:05:38,039 --> 00:05:43,680
engineering team given the nature of

00:05:40,259 --> 00:05:45,960
just one API right then finally

00:05:43,680 --> 00:05:48,870
eventually by the end when we retired

00:05:45,960 --> 00:05:50,250
this sort of architectural pattern that

00:05:48,870 --> 00:05:51,810
number one point that growth in the

00:05:50,250 --> 00:05:53,879
number of course is just totally killing

00:05:51,810 --> 00:05:56,219
us when we started we only had a half

00:05:53,879 --> 00:05:58,050
dozen or a dozen or so courses by the

00:05:56,219 --> 00:06:00,419
end we've had we have over one and a

00:05:58,050 --> 00:06:02,399
half thousand courses and what we found

00:06:00,419 --> 00:06:05,099
is actually we were downloading over a

00:06:02,399 --> 00:06:07,050
megabyte of JSON just to display twelve

00:06:05,099 --> 00:06:11,189
courses on the home page which was

00:06:07,050 --> 00:06:13,499
absolutely absurd and so I guess I want

00:06:11,189 --> 00:06:14,699
to take a step back and and and take

00:06:13,499 --> 00:06:17,520
some lessons from this first

00:06:14,699 --> 00:06:20,999
architectural pattern and the key lesson

00:06:17,520 --> 00:06:23,610
is that scale matters scale matters a

00:06:20,999 --> 00:06:26,639
lot something that works very well for a

00:06:23,610 --> 00:06:28,469
small scale set up will absolutely

00:06:26,639 --> 00:06:31,499
totally fall apart at a larger scale and

00:06:28,469 --> 00:06:33,210
conversely a larger scale tool to be

00:06:31,499 --> 00:06:36,029
inappropriate in a smaller scale setting

00:06:33,210 --> 00:06:38,189
but more importantly scale is a lot more

00:06:36,029 --> 00:06:39,430
subtle than just big and small in fact

00:06:38,189 --> 00:06:41,050
it has a large number of

00:06:39,430 --> 00:06:42,880
mentions so what are some of those

00:06:41,050 --> 00:06:45,450
examples one is queries per second

00:06:42,880 --> 00:06:50,650
of course there had a lot of users

00:06:45,450 --> 00:06:52,360
excuse me let me get this thank you

00:06:50,650 --> 00:06:54,490
one example is cause for a second we had

00:06:52,360 --> 00:06:57,940
a lot of users browsing our homepage we

00:06:54,490 --> 00:07:01,060
had a lot of users uh you know browsing

00:06:57,940 --> 00:07:03,370
the course catalog and we can scale up

00:07:01,060 --> 00:07:06,100
we can scale horizontally scale out and

00:07:03,370 --> 00:07:07,600
that's a fairly easy technique you want

00:07:06,100 --> 00:07:09,750
to use a different technique to handle

00:07:07,600 --> 00:07:11,800
scale of your data set size you know

00:07:09,750 --> 00:07:14,020
you'll want to start sharding and you'll

00:07:11,800 --> 00:07:15,550
want to scale across machines in a

00:07:14,020 --> 00:07:18,760
different sort of architecture and using

00:07:15,550 --> 00:07:20,260
different techniques scale also matters

00:07:18,760 --> 00:07:22,000
in the size of our engineering team and

00:07:20,260 --> 00:07:23,500
so as we scale up our engineering team

00:07:22,000 --> 00:07:25,180
things that worked well at small scale

00:07:23,500 --> 00:07:27,430
you know didn't work as well and so we

00:07:25,180 --> 00:07:28,840
wanted to think about micro services and

00:07:27,430 --> 00:07:30,340
breaking up monoliths that we could all

00:07:28,840 --> 00:07:32,770
work in parallel without stepping on

00:07:30,340 --> 00:07:34,540
each other's toes but all three of these

00:07:32,770 --> 00:07:37,270
dimensions for scale are actually fairly

00:07:34,540 --> 00:07:40,260
easy there's well-worn patterns and how

00:07:37,270 --> 00:07:42,430
you can solve them the hardest one is

00:07:40,260 --> 00:07:44,860
what I would like to call the number of

00:07:42,430 --> 00:07:48,880
types in your ontology and I think this

00:07:44,860 --> 00:07:52,030
is best understood with an example so

00:07:48,880 --> 00:07:53,950
say we have a messaging application and

00:07:52,030 --> 00:07:56,500
you this messaging application you may

00:07:53,950 --> 00:07:58,810
have messages and they may have threads

00:07:56,500 --> 00:08:01,030
you certainly have users you may have

00:07:58,810 --> 00:08:03,310
likes or emojis or reactions or replies

00:08:01,030 --> 00:08:05,590
but fundamentally the number of types in

00:08:03,310 --> 00:08:09,790
your ontology the number of entities or

00:08:05,590 --> 00:08:11,710
things is only a small handful and some

00:08:09,790 --> 00:08:13,750
products some phenomenally amazing

00:08:11,710 --> 00:08:17,440
products have very few types in their

00:08:13,750 --> 00:08:18,940
ontology some other products have a

00:08:17,440 --> 00:08:21,130
large number of types in their ontology

00:08:18,940 --> 00:08:22,930
so at Coursera in addition to having

00:08:21,130 --> 00:08:24,810
courses in specializations and

00:08:22,930 --> 00:08:27,100
instructors and university partners and

00:08:24,810 --> 00:08:29,500
identity verification and course ratings

00:08:27,100 --> 00:08:30,370
we also have necessarily out of course

00:08:29,500 --> 00:08:31,660
experience you've got the whole in

00:08:30,370 --> 00:08:33,160
course experience you've got videos

00:08:31,660 --> 00:08:34,450
you've got in video quizzes you've got

00:08:33,160 --> 00:08:36,130
assessments you've got programming

00:08:34,450 --> 00:08:38,470
assignments you've got forums and you

00:08:36,130 --> 00:08:39,760
have actually underneath all of this the

00:08:38,470 --> 00:08:41,770
authoring experience that our

00:08:39,760 --> 00:08:43,050
instructional teams use to actually put

00:08:41,770 --> 00:08:45,130
these courses on the course platform

00:08:43,050 --> 00:08:46,750
Coursera is actually very much like an

00:08:45,130 --> 00:08:48,670
iceberg that there's so much underneath

00:08:46,750 --> 00:08:50,329
the hood that you don't realize when you

00:08:48,670 --> 00:08:51,799
first approach it and in the

00:08:50,329 --> 00:08:54,319
hypes the number of types in our

00:08:51,799 --> 00:08:58,819
ontology just is absolutely killing us

00:08:54,319 --> 00:09:00,439
at Coursera so we need to figure out how

00:08:58,819 --> 00:09:02,929
we were gonna scale across the number of

00:09:00,439 --> 00:09:04,579
types in our ontology and so front end

00:09:02,929 --> 00:09:06,019
the front end got got got their day in

00:09:04,579 --> 00:09:07,699
the Sun they could say you know jQuery

00:09:06,019 --> 00:09:09,410
was the way to do it and back end now

00:09:07,699 --> 00:09:10,850
now I wanted to put their own mark on

00:09:09,410 --> 00:09:13,339
Coursera's architecture so we're like

00:09:10,850 --> 00:09:14,959
microservices guys those are the future

00:09:13,339 --> 00:09:16,040
that's how we should do everything so

00:09:14,959 --> 00:09:18,259
we're like okay fine we'll move away

00:09:16,040 --> 00:09:19,819
from this Python Django dictionary of

00:09:18,259 --> 00:09:21,290
lists of dictionary of lists of licks

00:09:19,819 --> 00:09:23,569
lists of dictionaries of dictionaries

00:09:21,290 --> 00:09:24,949
we're going to get types and we're gonna

00:09:23,569 --> 00:09:27,350
get micro-services and it's gonna be

00:09:24,949 --> 00:09:29,779
great so what we did is we had you know

00:09:27,350 --> 00:09:32,720
sort of a mini competition where we

00:09:29,779 --> 00:09:35,119
built a go service and go a service in

00:09:32,720 --> 00:09:37,339
Java service in Scala and we eventually

00:09:35,119 --> 00:09:39,129
settled on Scala we really wanted static

00:09:37,339 --> 00:09:41,179
typing to really straighten out our

00:09:39,129 --> 00:09:42,439
dictionaries of lists of dictionaries of

00:09:41,179 --> 00:09:46,040
lists of dictionaries of dictionaries of

00:09:42,439 --> 00:09:48,049
dictionaries and and and we picked play

00:09:46,040 --> 00:09:50,689
because it was a very powerful web

00:09:48,049 --> 00:09:53,449
framework actually backed by formerly

00:09:50,689 --> 00:09:56,480
typesafe now light bend but the company

00:09:53,449 --> 00:09:57,589
behind Scala and it was we thought that

00:09:56,480 --> 00:10:01,669
this was going to be a great choice and

00:09:57,589 --> 00:10:05,449
solve all of our all of our problems in

00:10:01,669 --> 00:10:07,519
reality we were sort of wrong Scala was

00:10:05,449 --> 00:10:10,069
actually a good choice the strong static

00:10:07,519 --> 00:10:12,470
typing discipline definitely did help us

00:10:10,069 --> 00:10:14,540
and you see this reflected in graph QL

00:10:12,470 --> 00:10:16,600
and as we've heard all today that static

00:10:14,540 --> 00:10:18,649
typing is actually really really useful

00:10:16,600 --> 00:10:20,509
but the flexibility of the play

00:10:18,649 --> 00:10:23,329
framework it was actually

00:10:20,509 --> 00:10:25,009
counterproductive we didn't need that

00:10:23,329 --> 00:10:28,519
flexibility to control headers and body

00:10:25,009 --> 00:10:30,470
parsing and and query parameters we

00:10:28,519 --> 00:10:33,019
didn't need all that control to build an

00:10:30,470 --> 00:10:35,540
API in fact we wanted less control we

00:10:33,019 --> 00:10:36,769
wanted something else instead so to

00:10:35,540 --> 00:10:39,259
really understand what we were actually

00:10:36,769 --> 00:10:41,779
looking for you need to think about what

00:10:39,259 --> 00:10:44,689
is the whole purpose of an API when you

00:10:41,779 --> 00:10:47,419
hire an API to do a job what is this job

00:10:44,689 --> 00:10:50,209
and its job is to get data from your

00:10:47,419 --> 00:10:52,249
server to your client that's a primary

00:10:50,209 --> 00:10:55,699
job it's not to be the most developer

00:10:52,249 --> 00:10:58,850
productive system it's not to be you

00:10:55,699 --> 00:11:00,889
know the latest technology trend it's to

00:10:58,850 --> 00:11:02,990
get data from client R from server to

00:11:00,889 --> 00:11:06,230
client

00:11:02,990 --> 00:11:08,570
coursera I'm very proud of has over

00:11:06,230 --> 00:11:11,360
three-quarters of its user population

00:11:08,570 --> 00:11:13,550
outside of the u.s. most of our users

00:11:11,360 --> 00:11:14,690
are accessing despite being a very young

00:11:13,550 --> 00:11:16,820
start most of our users come from

00:11:14,690 --> 00:11:19,220
outside of the US and access the course

00:11:16,820 --> 00:11:21,470
catalog and the course experience on 2g

00:11:19,220 --> 00:11:24,740
3G connections and on mobile phones and

00:11:21,470 --> 00:11:26,120
so as we were analyzing what are the

00:11:24,740 --> 00:11:29,480
performance requirements of our API

00:11:26,120 --> 00:11:32,540
systems we decided on two key

00:11:29,480 --> 00:11:34,160
fundamental bullet points now as we need

00:11:32,540 --> 00:11:35,900
to minimize the amount of data

00:11:34,160 --> 00:11:38,740
transferred across the LAN again these

00:11:35,900 --> 00:11:40,430
are very bandwidth constrained users and

00:11:38,740 --> 00:11:42,050
additionally we need to minimize the

00:11:40,430 --> 00:11:44,720
number of round trips it was completely

00:11:42,050 --> 00:11:46,700
unacceptable for us to make one API

00:11:44,720 --> 00:11:49,850
request to get a list of course IDs and

00:11:46,700 --> 00:11:51,290
then Levin API requests to get the

00:11:49,850 --> 00:11:53,720
corresponding instructors for those

00:11:51,290 --> 00:11:55,880
courses right so we need to minimize the

00:11:53,720 --> 00:11:57,410
data transferred and minimize number of

00:11:55,880 --> 00:11:59,030
round trips and their number of

00:11:57,410 --> 00:12:00,440
nice-to-haves that help with both of

00:11:59,030 --> 00:12:03,890
those two but those two are the

00:12:00,440 --> 00:12:05,510
fundamental key principles that we put

00:12:03,890 --> 00:12:09,320
as our performance baseline for our API

00:12:05,510 --> 00:12:11,020
framework we scratched our heads and we

00:12:09,320 --> 00:12:13,250
thought about that for a while we

00:12:11,020 --> 00:12:16,400
eventually came to the conclusion that

00:12:13,250 --> 00:12:20,800
we had to go in one of two mutually

00:12:16,400 --> 00:12:23,120
exclusive directions the first option is

00:12:20,800 --> 00:12:25,550
what is sort of known as experience

00:12:23,120 --> 00:12:27,020
based api's and there are a number of

00:12:25,550 --> 00:12:28,790
companies that have gotten phenomenally

00:12:27,020 --> 00:12:31,040
good at building experience based api's

00:12:28,790 --> 00:12:33,830
and when I experienced eight based API

00:12:31,040 --> 00:12:36,440
is is you write one API exactly for your

00:12:33,830 --> 00:12:38,810
home page another API exactly for your

00:12:36,440 --> 00:12:40,580
course catalog and browsing page another

00:12:38,810 --> 00:12:43,670
API for your course description page

00:12:40,580 --> 00:12:44,900
another API your partner description

00:12:43,670 --> 00:12:46,910
page and another API for your

00:12:44,900 --> 00:12:48,860
specialization page here's write one API

00:12:46,910 --> 00:12:50,750
for every single experience that you

00:12:48,860 --> 00:12:52,430
have and it's perfectly tailored to

00:12:50,750 --> 00:12:55,010
exactly that experience just the data

00:12:52,430 --> 00:12:58,550
you need and and only that out of you

00:12:55,010 --> 00:13:00,620
need and these these would absolutely

00:12:58,550 --> 00:13:02,230
fit our one round trip and the minimum

00:13:00,620 --> 00:13:05,870
amount of data requirements

00:13:02,230 --> 00:13:08,060
unfortunately well we were a little

00:13:05,870 --> 00:13:10,040
hesitant to take the experience based

00:13:08,060 --> 00:13:13,160
API approach and there are a couple

00:13:10,040 --> 00:13:14,590
reasons for that number one is there

00:13:13,160 --> 00:13:16,470
this sort of lends itself to a

00:13:14,590 --> 00:13:18,720
moderately tight coupling

00:13:16,470 --> 00:13:21,360
between the API implementation and the

00:13:18,720 --> 00:13:22,770
client views and and at Coursera one

00:13:21,360 --> 00:13:24,270
thing that I've learned in my four and a

00:13:22,770 --> 00:13:26,160
half years at Coursera is that we really

00:13:24,270 --> 00:13:28,560
have no idea what we're doing in terms

00:13:26,160 --> 00:13:30,120
of teaching online there's so many so

00:13:28,560 --> 00:13:31,920
much innovation available to us there's

00:13:30,120 --> 00:13:34,140
so many more improvements available to

00:13:31,920 --> 00:13:36,030
us it's a very exciting field but also

00:13:34,140 --> 00:13:38,730
means that stability is not something

00:13:36,030 --> 00:13:40,290
that we can afford and so this tight

00:13:38,730 --> 00:13:42,780
coupling we felt was something that

00:13:40,290 --> 00:13:45,090
might be a little problematic the second

00:13:42,780 --> 00:13:46,590
thing is that Coursera is a very young

00:13:45,090 --> 00:13:48,750
start-up and worse although we're

00:13:46,590 --> 00:13:50,370
growing very rapidly we have very

00:13:48,750 --> 00:13:52,050
limited amount of engineering resources

00:13:50,370 --> 00:13:55,500
and building a new API for every

00:13:52,050 --> 00:13:56,970
experience seemed actually fairly fairly

00:13:55,500 --> 00:14:01,590
resource intensive from an engineering

00:13:56,970 --> 00:14:03,630
standpoint so what's the opposite well

00:14:01,590 --> 00:14:05,520
the opposite is a queryable API instead

00:14:03,630 --> 00:14:08,550
of building one API for every experience

00:14:05,520 --> 00:14:11,220
you build one API period and every

00:14:08,550 --> 00:14:13,650
experience can query your API in

00:14:11,220 --> 00:14:18,180
whatever ways that it needs to to get

00:14:13,650 --> 00:14:19,620
exactly the data required and so we

00:14:18,180 --> 00:14:21,990
thought long and hard and you know what

00:14:19,620 --> 00:14:25,830
is a queryable AI API even look like is

00:14:21,990 --> 00:14:27,750
it even rest anymore and we realized

00:14:25,830 --> 00:14:30,840
that actually what we were really

00:14:27,750 --> 00:14:32,730
thinking of was a database a database

00:14:30,840 --> 00:14:34,590
basically allows you to query it in many

00:14:32,730 --> 00:14:35,910
different ways and you get exactly the

00:14:34,590 --> 00:14:37,230
data you need and only the data you need

00:14:35,910 --> 00:14:40,260
and you generally can do it in one

00:14:37,230 --> 00:14:42,210
roundtrip and so we thought long and

00:14:40,260 --> 00:14:44,640
hard okay so what is this what does the

00:14:42,210 --> 00:14:47,190
database even mean and fundamentally a

00:14:44,640 --> 00:14:49,440
database at least a sequel database and

00:14:47,190 --> 00:14:51,810
and and really a lot of databases since

00:14:49,440 --> 00:14:53,970
then fundamentally comes down to

00:14:51,810 --> 00:14:56,010
relational algebra and for those of you

00:14:53,970 --> 00:14:58,080
don't remember your relational algebra

00:14:56,010 --> 00:15:01,260
from your database classes there's

00:14:58,080 --> 00:15:04,290
basically three key points as relational

00:15:01,260 --> 00:15:08,700
algebra applies to rest or JSON based

00:15:04,290 --> 00:15:10,980
api's so the first is projection so if

00:15:08,700 --> 00:15:12,840
you have a table of courses you can

00:15:10,980 --> 00:15:14,910
write a query in sequel to get just the

00:15:12,840 --> 00:15:17,490
course ID and the course name and you

00:15:14,910 --> 00:15:19,500
can ignore or you don't get a very long

00:15:17,490 --> 00:15:21,510
course of description that may be you

00:15:19,500 --> 00:15:22,770
know very very large okay so that's

00:15:21,510 --> 00:15:24,900
projection you just want to filter the

00:15:22,770 --> 00:15:29,160
fields you get for every row in the

00:15:24,900 --> 00:15:30,329
table selection allows you to filter the

00:15:29,160 --> 00:15:31,980
number of items in your collection

00:15:30,329 --> 00:15:34,230
so if you have a table of courses you

00:15:31,980 --> 00:15:35,790
can get just the courses that have the

00:15:34,230 --> 00:15:37,980
name have machine learning in their

00:15:35,790 --> 00:15:40,139
course title for example okay so this is

00:15:37,980 --> 00:15:43,589
like a search or a filtering this is the

00:15:40,139 --> 00:15:46,499
selection finally and this is probably

00:15:43,589 --> 00:15:49,470
the most sophisticated aspect is is

00:15:46,499 --> 00:15:51,119
joins do you have a table of courses and

00:15:49,470 --> 00:15:52,829
you've got a table of instructors and

00:15:51,119 --> 00:15:54,299
appropriately normalized manner you want

00:15:52,829 --> 00:15:55,829
to be able to join across those so you

00:15:54,299 --> 00:15:57,420
want to get a course and you want to

00:15:55,829 --> 00:16:00,299
also get the instructor in one query

00:15:57,420 --> 00:16:03,389
right and so we thought long and hard

00:16:00,299 --> 00:16:06,089
and so how does relational algebra make

00:16:03,389 --> 00:16:07,559
any sense in terms of rest or json-based

00:16:06,089 --> 00:16:11,730
api's and so this is what we came up

00:16:07,559 --> 00:16:13,259
with now before I go a bit further this

00:16:11,730 --> 00:16:15,869
is all implemented on a framework that

00:16:13,259 --> 00:16:19,439
we call nap time so it's a little

00:16:15,869 --> 00:16:21,360
lightweight rest anyway thank you for

00:16:19,439 --> 00:16:23,879
laughing it's my horrible name choice so

00:16:21,360 --> 00:16:27,089
I appreciate it

00:16:23,879 --> 00:16:29,819
these api's have been live in production

00:16:27,089 --> 00:16:31,319
at Coursera for for almost two years now

00:16:29,819 --> 00:16:33,749
maybe even longer and you can actually

00:16:31,319 --> 00:16:37,350
hit these api's right now if the Wi-Fi

00:16:33,749 --> 00:16:38,579
were to work for you but fortunately we

00:16:37,350 --> 00:16:40,879
don't have to rely on that to play

00:16:38,579 --> 00:16:43,799
around with with Corsairs catalog api's

00:16:40,879 --> 00:16:46,499
so we have the courses endpoints or the

00:16:43,799 --> 00:16:47,790
courses table and and we're going to now

00:16:46,499 --> 00:16:49,049
filter down to just we wanna get a

00:16:47,790 --> 00:16:52,259
single course the machine learning

00:16:49,049 --> 00:16:53,879
course and and this is your query and

00:16:52,259 --> 00:16:56,549
this is the response you get back

00:16:53,879 --> 00:17:00,720
exactly as JSON and so that's how you

00:16:56,549 --> 00:17:03,119
can do selection within a collection now

00:17:00,720 --> 00:17:04,649
we talked about projection and so what

00:17:03,119 --> 00:17:05,850
we call this this is the fields query

00:17:04,649 --> 00:17:07,769
parameter and so you can ask for the

00:17:05,850 --> 00:17:09,779
primary language in addition to this

00:17:07,769 --> 00:17:12,360
minimal representation you get back and

00:17:09,779 --> 00:17:14,519
so you add the fields query parameter

00:17:12,360 --> 00:17:17,189
and you get that exactly mirrored in the

00:17:14,519 --> 00:17:18,179
response very very straightforward so

00:17:17,189 --> 00:17:20,639
you talked about selection and

00:17:18,179 --> 00:17:22,470
projection now let's do the the fun one

00:17:20,639 --> 00:17:24,510
and that is joins and what we call them

00:17:22,470 --> 00:17:28,319
is actually includes so you include a

00:17:24,510 --> 00:17:30,269
related resource so if you have a course

00:17:28,319 --> 00:17:32,730
and you want to also get the instructor

00:17:30,269 --> 00:17:34,500
for that courses instructor I need

00:17:32,730 --> 00:17:36,419
instructor IDs you add the includes

00:17:34,500 --> 00:17:38,669
parameter and in the response you get

00:17:36,419 --> 00:17:42,149
the related instructor in a single API

00:17:38,669 --> 00:17:44,250
call naturally if you think carefully

00:17:42,149 --> 00:17:45,990
this actually has to be fully recursive

00:17:44,250 --> 00:17:47,940
so you need to be able to project across

00:17:45,990 --> 00:17:49,980
the related fields and so this is the

00:17:47,940 --> 00:17:51,600
syntax that we use you can ask for the

00:17:49,980 --> 00:17:53,100
title of the instructor and you get it

00:17:51,600 --> 00:17:55,260
in the response and you realize that

00:17:53,100 --> 00:17:57,210
Andrews most important qualification is

00:17:55,260 --> 00:18:01,110
that he was of course co-founder at

00:17:57,210 --> 00:18:03,360
Coursera so we built us a naptime API

00:18:01,110 --> 00:18:05,580
framework and that powers you know a lot

00:18:03,360 --> 00:18:07,530
of our API is at Coursera we spent a lot

00:18:05,580 --> 00:18:09,180
of time thinking about it and building

00:18:07,530 --> 00:18:11,400
upon it and this is actually what ended

00:18:09,180 --> 00:18:13,140
up happening even though we didn't force

00:18:11,400 --> 00:18:17,160
any of our developers to move away from

00:18:13,140 --> 00:18:19,530
stock the stock play framework api's we

00:18:17,160 --> 00:18:21,120
found that all of them radically

00:18:19,530 --> 00:18:23,850
preferred using nap time so the blue

00:18:21,120 --> 00:18:25,380
line is the rapid adoption of nap time

00:18:23,850 --> 00:18:28,140
with in Coursera by the Coursera

00:18:25,380 --> 00:18:30,870
developer community and you can just see

00:18:28,140 --> 00:18:35,250
a complete stagnation in terms of using

00:18:30,870 --> 00:18:38,490
the play framework and and and we saw

00:18:35,250 --> 00:18:40,020
this success due to a lot of iterations

00:18:38,490 --> 00:18:41,550
you'll notice actually one important

00:18:40,020 --> 00:18:43,860
thing I should point out we started far

00:18:41,550 --> 00:18:46,260
before Facebook started talking publicly

00:18:43,860 --> 00:18:48,210
about graph QL but some of you may have

00:18:46,260 --> 00:18:51,000
noticed that a lot of the same lessons

00:18:48,210 --> 00:18:52,370
you know apply right back and forth and

00:18:51,000 --> 00:18:56,610
that's an important part of our story

00:18:52,370 --> 00:18:59,960
anyway developers adopted nap time in

00:18:56,610 --> 00:19:02,880
droves and and but in order for us to

00:18:59,960 --> 00:19:04,770
support that you know we didn't

00:19:02,880 --> 00:19:07,110
immediately take off we spend a lot of

00:19:04,770 --> 00:19:09,000
time in rating on our api's and we had a

00:19:07,110 --> 00:19:11,160
number of important lessons that we

00:19:09,000 --> 00:19:13,770
learned and so taking a step back from

00:19:11,160 --> 00:19:16,170
our story we learned that you have to

00:19:13,770 --> 00:19:17,880
meet your key performance baseline

00:19:16,170 --> 00:19:20,850
requirements for your API framework

00:19:17,880 --> 00:19:22,770
that's that's table stakes but then

00:19:20,850 --> 00:19:24,570
after that you want to optimize for

00:19:22,770 --> 00:19:26,790
developer productivity this is

00:19:24,570 --> 00:19:28,410
absolutely critical and we learned a lot

00:19:26,790 --> 00:19:30,770
in terms of what is the best way to

00:19:28,410 --> 00:19:36,090
optimize for developer productivity

00:19:30,770 --> 00:19:37,980
first and foremost first and foremost we

00:19:36,090 --> 00:19:41,310
realize that it's incredibly important

00:19:37,980 --> 00:19:44,570
to use static typing it's absolutely not

00:19:41,310 --> 00:19:46,920
possible at Coursera's scale of ontology

00:19:44,570 --> 00:19:49,890
to do everything in a dynamically tight

00:19:46,920 --> 00:19:51,510
manner you need tools to help you help

00:19:49,890 --> 00:19:54,000
developers move from different parts of

00:19:51,510 --> 00:19:54,690
the code base without needing to spend a

00:19:54,000 --> 00:19:56,090
whole bunch of time reading

00:19:54,690 --> 00:19:58,190
documentation

00:19:56,090 --> 00:20:01,130
and so the naptime API framework

00:19:58,190 --> 00:20:02,840
actually catches a huge number of

00:20:01,130 --> 00:20:05,600
potential bugs and in API

00:20:02,840 --> 00:20:07,010
inconsistencies at compile time in

00:20:05,600 --> 00:20:09,140
addition to that in addition to ensuring

00:20:07,010 --> 00:20:11,600
that all the API is look and work and

00:20:09,140 --> 00:20:13,190
behave the same manner so it's not a

00:20:11,600 --> 00:20:16,909
convention but rather enforced by the

00:20:13,190 --> 00:20:18,529
compiler the nap time nap time framework

00:20:16,909 --> 00:20:21,559
also allows you to use arbitrary data

00:20:18,529 --> 00:20:24,289
types or ADT's in as many possible

00:20:21,559 --> 00:20:26,330
places so it's not extremely typed you

00:20:24,289 --> 00:20:29,330
can use arbitrary sophisticated types

00:20:26,330 --> 00:20:30,799
and that was very important now to

00:20:29,330 --> 00:20:32,270
enforce all of these constraints and

00:20:30,799 --> 00:20:35,090
make this all work we actually leverage

00:20:32,270 --> 00:20:37,549
a large number of Scala's advanced

00:20:35,090 --> 00:20:39,830
language features we use macros we use

00:20:37,549 --> 00:20:42,710
path dependent types we use implicit

00:20:39,830 --> 00:20:44,809
type classes but you have to leverage

00:20:42,710 --> 00:20:47,630
these features very very carefully in

00:20:44,809 --> 00:20:49,880
order to not make it impossible for new

00:20:47,630 --> 00:20:51,890
developers to learn your API and so it's

00:20:49,880 --> 00:20:53,149
very important to leverage types but

00:20:51,890 --> 00:20:57,140
it's very important to leverage them

00:20:53,149 --> 00:20:59,299
carefully the other thing that we

00:20:57,140 --> 00:21:03,260
learned is that you shouldn't model

00:20:59,299 --> 00:21:05,960
these collections or these tables as as

00:21:03,260 --> 00:21:08,299
a single sort of blob for each element

00:21:05,960 --> 00:21:10,779
it's very important to leverage things

00:21:08,299 --> 00:21:13,490
as a collection of key value pairs

00:21:10,779 --> 00:21:15,679
everything has an ID and everything has

00:21:13,490 --> 00:21:18,080
a set of fields that correspond to the

00:21:15,679 --> 00:21:19,850
value you'll notice this is very much

00:21:18,080 --> 00:21:22,880
the same thing as what really encourages

00:21:19,850 --> 00:21:24,590
you to adopt with the ID pattern we came

00:21:22,880 --> 00:21:26,240
the exact same conclusion as we were

00:21:24,590 --> 00:21:28,669
building out our nap time API is in

00:21:26,240 --> 00:21:32,450
addition to making the types work a lot

00:21:28,669 --> 00:21:34,279
more nicely it also very much makes it

00:21:32,450 --> 00:21:38,059
easier for developers to reuse code in

00:21:34,279 --> 00:21:41,510
different areas this one was perhaps the

00:21:38,059 --> 00:21:45,500
most surprising of all an opinionated

00:21:41,510 --> 00:21:48,020
framework improves communication what we

00:21:45,500 --> 00:21:50,809
found is that after developers used one

00:21:48,020 --> 00:21:52,880
nap time API they'd learn them all and

00:21:50,809 --> 00:21:54,890
what this meant is that front-end

00:21:52,880 --> 00:21:56,779
engineers would be able to talk to a

00:21:54,890 --> 00:21:58,760
back-end engineer and say hey I need a

00:21:56,779 --> 00:22:00,710
finder with this query parameter that is

00:21:58,760 --> 00:22:02,960
joined to this other resource and in a

00:22:00,710 --> 00:22:06,700
very succinctly straightforward manner

00:22:02,960 --> 00:22:09,220
by having a strong opinion having a

00:22:06,700 --> 00:22:12,100
strict ontology for how you're eight

00:22:09,220 --> 00:22:13,870
guys look and feel and work makes it so

00:22:12,100 --> 00:22:16,120
much more productive to communicate no

00:22:13,870 --> 00:22:17,260
longer where you bike shedding about you

00:22:16,120 --> 00:22:18,700
know where should this should this be a

00:22:17,260 --> 00:22:20,140
query parameter just be a header should

00:22:18,700 --> 00:22:22,360
this be whatever no it's very

00:22:20,140 --> 00:22:25,000
straightforward you'll have a great way

00:22:22,360 --> 00:22:27,100
of doing things and so this is what led

00:22:25,000 --> 00:22:30,940
to nap times radical adoption within

00:22:27,100 --> 00:22:32,650
Coursera now despite saying that nap

00:22:30,940 --> 00:22:35,140
time cured cancer and solved all of the

00:22:32,650 --> 00:22:38,559
world's woes unfortunately a number of

00:22:35,140 --> 00:22:41,039
problems still remained the server-side

00:22:38,559 --> 00:22:43,450
API worked really really well but yeah

00:22:41,039 --> 00:22:45,640
me as a back-end developer I wasn't able

00:22:43,450 --> 00:22:47,409
to really handle the doing the right

00:22:45,640 --> 00:22:48,669
thing by way of our front end developers

00:22:47,409 --> 00:22:50,679
our mobile developers and our web

00:22:48,669 --> 00:22:53,230
developers and so we had a number of

00:22:50,679 --> 00:22:54,970
problems so that flattened

00:22:53,230 --> 00:22:56,230
representation where the related

00:22:54,970 --> 00:22:57,549
resources are flattened in a list

00:22:56,230 --> 00:22:59,440
although it does mean that we can

00:22:57,549 --> 00:23:01,090
potentially eke out slightly better

00:22:59,440 --> 00:23:03,460
network bandwidth optimization in

00:23:01,090 --> 00:23:05,710
practice it was just very difficult for

00:23:03,460 --> 00:23:07,830
clients to then rehydrate back things

00:23:05,710 --> 00:23:10,950
from that flattened representation

00:23:07,830 --> 00:23:13,240
additionally the URLs the URL syntax

00:23:10,950 --> 00:23:15,070
ended up being fairly difficult for

00:23:13,240 --> 00:23:17,860
developers to maintain over time as we

00:23:15,070 --> 00:23:19,360
were evolving api's and products extra

00:23:17,860 --> 00:23:21,039
fields ended up getting left in there

00:23:19,360 --> 00:23:22,780
some developers you know we're very

00:23:21,039 --> 00:23:24,700
confused as to where to add stuff and it

00:23:22,780 --> 00:23:27,510
wasn't it's just very cumbersome and

00:23:24,700 --> 00:23:30,190
finally although nap time captures an

00:23:27,510 --> 00:23:33,100
inhuman firm ation statically at compile

00:23:30,190 --> 00:23:34,720
time with you know its type safe manner

00:23:33,100 --> 00:23:37,179
although we really get very

00:23:34,720 --> 00:23:39,549
sophisticated and detailed schemas from

00:23:37,179 --> 00:23:41,890
our api's we never were able to fully

00:23:39,549 --> 00:23:46,480
invest in a documentation or client-side

00:23:41,890 --> 00:23:49,090
tool naturally when we heard about

00:23:46,480 --> 00:23:52,809
Facebook talking about graph QL and we

00:23:49,090 --> 00:23:54,730
saw a graphical we realized hey this

00:23:52,809 --> 00:23:57,669
actually fits together really really

00:23:54,730 --> 00:23:59,020
well this takes the weaknesses of the

00:23:57,669 --> 00:24:01,270
nap time framework that we use

00:23:59,020 --> 00:24:03,370
internally at Coursera and and couples

00:24:01,270 --> 00:24:05,169
it with an open source project that that

00:24:03,370 --> 00:24:07,390
fills in those weaknesses addresses

00:24:05,169 --> 00:24:09,669
those gaps and is the right way going

00:24:07,390 --> 00:24:11,470
forward and so we saw a graph QL is very

00:24:09,669 --> 00:24:14,380
much on the horizon and very much

00:24:11,470 --> 00:24:15,100
dovetails with the way that we do things

00:24:14,380 --> 00:24:16,900
at Coursera

00:24:15,100 --> 00:24:19,330
so let's actually take a look at how

00:24:16,900 --> 00:24:21,730
close they actually are so this is our

00:24:19,330 --> 00:24:23,080
first query on the courses resource and

00:24:21,730 --> 00:24:26,230
here you can see it translated

00:24:23,080 --> 00:24:28,360
a very natural fashion into graph QL and

00:24:26,230 --> 00:24:30,730
as you add fields they show up

00:24:28,360 --> 00:24:32,649
appropriately nested joins and includes

00:24:30,730 --> 00:24:34,659
again very straightforward and of course

00:24:32,649 --> 00:24:38,080
it works recursively so we realized

00:24:34,659 --> 00:24:40,000
actually instead of trying to dump

00:24:38,080 --> 00:24:43,630
everything that we've already built

00:24:40,000 --> 00:24:45,429
these well over 700 different api's and

00:24:43,630 --> 00:24:46,860
and resources actually each one having

00:24:45,429 --> 00:24:50,559
multiple api's themselves

00:24:46,860 --> 00:24:53,080
why don't we define a bijection to find

00:24:50,559 --> 00:24:55,870
a translation layer between our current

00:24:53,080 --> 00:24:59,169
rests api's rest and JSON API is that we

00:24:55,870 --> 00:25:02,110
use and know and love mostly and graph

00:24:59,169 --> 00:25:03,789
QL the direction that we want to go so

00:25:02,110 --> 00:25:06,309
this is a quick look at our our

00:25:03,789 --> 00:25:09,100
architecture we have an edged here that

00:25:06,309 --> 00:25:11,200
handles das DDoS protection as long as

00:25:09,100 --> 00:25:13,330
you're not dying and routes routes

00:25:11,200 --> 00:25:14,740
requests to to the back-end distributed

00:25:13,330 --> 00:25:16,870
constellation of micro services we've

00:25:14,740 --> 00:25:19,330
got like 50 different micro services

00:25:16,870 --> 00:25:22,960
each handling different subsets of the

00:25:19,330 --> 00:25:25,389
Coursera platform and so this is how

00:25:22,960 --> 00:25:28,870
requests work today and so we're

00:25:25,389 --> 00:25:32,289
introducing this assembler service this

00:25:28,870 --> 00:25:33,820
assembler service requests will come in

00:25:32,289 --> 00:25:35,620
from the edge to your graph QL request

00:25:33,820 --> 00:25:37,179
will come in to assembler and assembler

00:25:35,620 --> 00:25:39,850
will then be able to farm out requests

00:25:37,179 --> 00:25:41,380
to the back-end services now one thing

00:25:39,850 --> 00:25:44,559
that's very important for graph QL is

00:25:41,380 --> 00:25:46,570
that you have one unified schema that

00:25:44,559 --> 00:25:48,220
lets you join across all the arbitrary

00:25:46,570 --> 00:25:50,260
types and so the way this ends up

00:25:48,220 --> 00:25:51,639
working I think it's best illustrated

00:25:50,260 --> 00:25:54,220
through running through an example

00:25:51,639 --> 00:25:55,720
together so let's say we have a graph QL

00:25:54,220 --> 00:25:57,669
query that comes into the assembler

00:25:55,720 --> 00:26:00,460
service and we need to get the users

00:25:57,669 --> 00:26:02,440
profile and the the course title and the

00:26:00,460 --> 00:26:05,080
instructor for all the courses that a

00:26:02,440 --> 00:26:07,210
particular user is enrolled in so the

00:26:05,080 --> 00:26:09,279
assembler will say AHA I'm going to

00:26:07,210 --> 00:26:12,010
query the profile service to get the

00:26:09,279 --> 00:26:14,200
users profile once I've got that that

00:26:12,010 --> 00:26:16,240
then tells me what information I need to

00:26:14,200 --> 00:26:17,889
go query from the enrollment service so

00:26:16,240 --> 00:26:21,639
I can get the list of courses the user

00:26:17,889 --> 00:26:25,289
is enrolled in from there the assembler

00:26:21,639 --> 00:26:28,899
service can actually send a fat query a

00:26:25,289 --> 00:26:31,990
larger subset of the graph QL tree to

00:26:28,899 --> 00:26:35,020
the catalog service to fetch both in one

00:26:31,990 --> 00:26:37,210
request the list of courses and their

00:26:35,020 --> 00:26:39,820
related instructors right so this is a

00:26:37,210 --> 00:26:41,860
distributed graph QL implementation

00:26:39,820 --> 00:26:43,570
where graph QL can be evaluated any

00:26:41,860 --> 00:26:44,710
different point the assembler service

00:26:43,570 --> 00:26:48,010
just handles across the different

00:26:44,710 --> 00:26:49,000
services joining things together the

00:26:48,010 --> 00:26:50,590
other thing that's interesting about

00:26:49,000 --> 00:26:53,230
this is that each of the different

00:26:50,590 --> 00:26:56,140
back-end services exposes their own

00:26:53,230 --> 00:26:58,090
graph QL subset of the graph QL schema

00:26:56,140 --> 00:27:00,640
the assembler service aggregates at all

00:26:58,090 --> 00:27:06,039
at runtime and exposes that one unified

00:27:00,640 --> 00:27:08,279
schema available to all clients the

00:27:06,039 --> 00:27:10,960
other thing you'll note is that because

00:27:08,279 --> 00:27:12,429
everything is just actually adding graph

00:27:10,960 --> 00:27:15,039
QL adding this by Junction layer is

00:27:12,429 --> 00:27:16,840
additive this sets up a incredibly

00:27:15,039 --> 00:27:19,059
smooth transition plan for us at

00:27:16,840 --> 00:27:21,100
Coursera just because graph QL in nap

00:27:19,059 --> 00:27:21,990
time our own internal learnings are so

00:27:21,100 --> 00:27:25,240
close

00:27:21,990 --> 00:27:26,950
so what we're happy what we're doing

00:27:25,240 --> 00:27:29,980
with our clients is they currently use

00:27:26,950 --> 00:27:32,020
the existing rest JSON nap time api's

00:27:29,980 --> 00:27:33,820
and instead we're going piecemeal by

00:27:32,020 --> 00:27:36,370
piecemeal and involving them migrating

00:27:33,820 --> 00:27:38,590
over to graph QL back-end developers

00:27:36,370 --> 00:27:41,770
will absolutely continue to write their

00:27:38,590 --> 00:27:43,059
API Xin nap time and then the backend

00:27:41,770 --> 00:27:44,559
API is that the divet pack and

00:27:43,059 --> 00:27:47,350
developers write can be used either

00:27:44,559 --> 00:27:49,179
directly as rest json api x' or through

00:27:47,350 --> 00:27:51,549
graph QL without any single code

00:27:49,179 --> 00:27:52,870
duplication so not a single back-end

00:27:51,549 --> 00:27:55,149
developer besides myself and my

00:27:52,870 --> 00:27:57,820
colleague brian ever write any code for

00:27:55,149 --> 00:27:59,950
the assembler service every back-end

00:27:57,820 --> 00:28:02,230
service has their own graph QL schema

00:27:59,950 --> 00:28:05,470
and it all gets aggregated dynamically

00:28:02,230 --> 00:28:07,570
at runtime so we have this all working

00:28:05,470 --> 00:28:09,789
together in production this is a

00:28:07,570 --> 00:28:11,590
screenshot from graphical a phenomenal

00:28:09,789 --> 00:28:14,110
tool that of course you all know and

00:28:11,590 --> 00:28:17,380
love and this isn't working against our

00:28:14,110 --> 00:28:19,870
our production schema that has thousands

00:28:17,380 --> 00:28:23,760
upon thousands of types and if you print

00:28:19,870 --> 00:28:26,020
it out is is well over 10,000 lines long

00:28:23,760 --> 00:28:30,070
we're working on migrating a hundred

00:28:26,020 --> 00:28:31,899
percent of our client data access almost

00:28:30,070 --> 00:28:33,399
nearly a hundred percent of our client

00:28:31,899 --> 00:28:36,250
data access to graph QL by the end of

00:28:33,399 --> 00:28:37,690
2017 we're all in on graph QL we are

00:28:36,250 --> 00:28:41,529
convinced that this is the right way to

00:28:37,690 --> 00:28:46,840
be building technology this time in 2016

00:28:41,529 --> 00:28:48,460
and maybe even 2017 so taking a step

00:28:46,840 --> 00:28:50,830
back from this story

00:28:48,460 --> 00:28:52,110
what are the key lessons or rather some

00:28:50,830 --> 00:28:54,610
more key lessons that we've learned

00:28:52,110 --> 00:28:55,900
throughout throughout this journey the

00:28:54,610 --> 00:28:58,810
first is to carefully understand your

00:28:55,900 --> 00:29:01,960
problem we did not appreciate the subtle

00:28:58,810 --> 00:29:03,490
nature of scale at the beginning of our

00:29:01,960 --> 00:29:05,110
journey we didn't realize that the

00:29:03,490 --> 00:29:07,510
solutions that work well for scaling the

00:29:05,110 --> 00:29:10,180
number of engineers don't inherently

00:29:07,510 --> 00:29:12,250
work in scaling the number of types in

00:29:10,180 --> 00:29:13,690
your ontology when we thought that the

00:29:12,250 --> 00:29:15,940
play framework was going to be the right

00:29:13,690 --> 00:29:17,770
solution for us we were only half right

00:29:15,940 --> 00:29:20,050
and so we need you whenever you

00:29:17,770 --> 00:29:22,300
encounter a problem don't just take the

00:29:20,050 --> 00:29:23,650
latest shiny new tool think carefully to

00:29:22,300 --> 00:29:26,470
understand your problem and what's going

00:29:23,650 --> 00:29:28,600
to be the right solution while you're

00:29:26,470 --> 00:29:30,760
thinking thinking carefully through your

00:29:28,600 --> 00:29:32,920
problem it's also very important to look

00:29:30,760 --> 00:29:34,900
to history as much as we you know love

00:29:32,920 --> 00:29:37,960
to make fun of the latest trends and and

00:29:34,900 --> 00:29:40,210
both make fun and use the latest trends

00:29:37,960 --> 00:29:41,650
in technology as it turns out a lot of

00:29:40,210 --> 00:29:43,420
the problems that we encounter have been

00:29:41,650 --> 00:29:45,820
solved before it may be a different form

00:29:43,420 --> 00:29:48,640
and so api's and relational algebra

00:29:45,820 --> 00:29:51,250
actually dovetail very very nicely and

00:29:48,640 --> 00:29:53,260
so it's always important to look to two

00:29:51,250 --> 00:29:56,920
theory to stand on the shoulders of

00:29:53,260 --> 00:29:59,560
giants that have gone before us finally

00:29:56,920 --> 00:30:00,520
and perhaps very very probably one of

00:29:59,560 --> 00:30:02,620
most important things is it's very

00:30:00,520 --> 00:30:04,750
important to plug into the ecosystem we

00:30:02,620 --> 00:30:07,240
were developing nap time on our own and

00:30:04,750 --> 00:30:09,190
we got pretty far but we definitely

00:30:07,240 --> 00:30:12,250
couldn't build anywhere near as complete

00:30:09,190 --> 00:30:13,930
of a solution as we can joining in with

00:30:12,250 --> 00:30:15,730
the rest of the graph QL community and

00:30:13,930 --> 00:30:18,280
so it's very important to plug into the

00:30:15,730 --> 00:30:21,880
ecosystem wherever possible because it's

00:30:18,280 --> 00:30:23,830
much better to work together and so I

00:30:21,880 --> 00:30:26,170
want you all to know that nap time is

00:30:23,830 --> 00:30:27,820
developed in the open we actually are

00:30:26,170 --> 00:30:29,880
we'd send each other pull requests right

00:30:27,820 --> 00:30:33,220
in the open you're welcome to join in

00:30:29,880 --> 00:30:36,670
we'd be happy to have you either use our

00:30:33,220 --> 00:30:38,380
system or contribute back to it we think

00:30:36,670 --> 00:30:40,120
it's a really great system we've spent a

00:30:38,380 --> 00:30:43,000
lot of time optimizing it making it work

00:30:40,120 --> 00:30:44,440
very well of course if you want to take

00:30:43,000 --> 00:30:47,080
the next step if you'd like to join the

00:30:44,440 --> 00:30:48,430
team at Coursera building what we think

00:30:47,080 --> 00:30:50,740
is going to be the the best learning

00:30:48,430 --> 00:30:52,840
platform for education at scale we have

00:30:50,740 --> 00:30:54,430
a lot of really fun challenges and

00:30:52,840 --> 00:30:56,170
problems to work on and we'd love to

00:30:54,430 --> 00:31:00,450
have you join us and join the rest of

00:30:56,170 --> 00:31:00,450

YouTube URL: https://www.youtube.com/watch?v=JC-UJwBKc2Y


