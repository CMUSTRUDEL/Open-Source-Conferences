Title: GraphQL at Shopify
Publication date: 2016-11-04
Playlist: GraphQL Summit 2016
Description: 
	Marc-AndrÃ© Giroux and Dylan Thacker-Smith, Shopify

In this talk, we'll explore how Shopify designed and built its GraphQL API to make it easy for any team to extend and use our GraphQL schema.
 
This includes how we built our own schema definition layer on top of the GraphQL Ruby gem, how we seamlessly included batching and caching in our field definitions, how we approached authorization and authentication as well as how we use the API from mobile clients written in java and swift. 

Slides: https://speakerdeck.com/xuorig/graphql-at-shopify

Learn more about GraphQL Summit:
http://graphqlsummit.com

Join our GraphQL SF meetup to hear more about GraphQL best practices and implementations: 
http://meetup.com/GraphQL-SF/
Captions: 
	00:00:04,559 --> 00:00:06,684
- Alright, good morning everybody.

00:00:06,684 --> 00:00:08,843
That was a really inspiring keynote.

00:00:08,843 --> 00:00:12,342
I'm also really excited about the GraphQL Summit.

00:00:12,342 --> 00:00:16,149
We've seen so many talks about why GraphQL is great,

00:00:16,149 --> 00:00:17,115
why people are using it,

00:00:17,115 --> 00:00:20,417
but we haven't seen that many talks on how people use it,

00:00:20,417 --> 00:00:22,014
and the problems they've had,

00:00:22,014 --> 00:00:25,135
and the actual solutions they found,

00:00:25,135 --> 00:00:26,274
so I'm really excited,

00:00:26,274 --> 00:00:28,312
I already talked to a few people here,

00:00:28,312 --> 00:00:31,688
and we shared problems we encountered in our solutions, so.

00:00:31,688 --> 00:00:34,134
This talk is gonna be like, two parts.

00:00:34,134 --> 00:00:35,982
The first part, I'm gonna talk

00:00:35,982 --> 00:00:38,023
how we build the tools and solutions

00:00:38,023 --> 00:00:40,877
to some problems we had on the server side for GraphQL.

00:00:40,877 --> 00:00:43,814
And Dylan's gonna talk about, on the mobile side,

00:00:43,814 --> 00:00:45,706
kind of the same thing,

00:00:45,706 --> 00:00:49,675
how we built smarter clients for mobile.

00:00:49,675 --> 00:00:51,552
So name's Marc-Andre,

00:00:51,552 --> 00:00:54,710
I'm from the cold Montreal, Canada,

00:00:54,710 --> 00:00:56,881
and I work obviously, at Shopify.

00:00:56,881 --> 00:00:59,186
So Shopify's an ecommerce company,

00:00:59,186 --> 00:01:00,539
we basically make it easy

00:01:00,539 --> 00:01:03,238
for anybody to sell things on the internet,

00:01:03,238 --> 00:01:07,405
and like many companies, we've had and still have REST APIs.

00:01:08,764 --> 00:01:11,661
And we had the same pain points that maybe,

00:01:11,661 --> 00:01:14,584
a lot of you here too, so.

00:01:14,584 --> 00:01:17,278
Our clients were making way too many round trips,

00:01:17,278 --> 00:01:19,803
to get the data they needed.

00:01:19,803 --> 00:01:21,553
They also, I'm sorry.

00:01:23,368 --> 00:01:25,568
Way too many round trips, it was hard to customize

00:01:25,568 --> 00:01:28,719
what the other (mumbles) are getting.

00:01:28,719 --> 00:01:32,780
The way we did field filtering, was a little awkward,

00:01:32,780 --> 00:01:34,785
so we wanted to explore something else.

00:01:34,785 --> 00:01:37,415
And a few months ago, we played with React Native

00:01:37,415 --> 00:01:39,163
a little bit at Shopify,

00:01:39,163 --> 00:01:41,729
and although it wasn't perfect for our use case,

00:01:41,729 --> 00:01:44,057
we kind of discovered GraphQL through it,

00:01:44,057 --> 00:01:45,752
and fast forward to today,

00:01:45,752 --> 00:01:47,818
we've just released our mobile app,

00:01:47,818 --> 00:01:51,473
that's powered entirely by our GraphQL API.

00:01:51,473 --> 00:01:54,738
So me and Dylan, both work on the GraphQL core team,

00:01:54,738 --> 00:01:57,994
and our goal is really to make it easy for any team

00:01:57,994 --> 00:02:01,768
to build their own schema, or extend their existing schemas.

00:02:01,768 --> 00:02:03,103
So, we're getting pretty large,

00:02:03,103 --> 00:02:05,664
we have a lot of developers working on the platform.

00:02:05,664 --> 00:02:08,929
We have many teams that might wanna create a new schema,

00:02:08,929 --> 00:02:11,113
or extend existing schemas.

00:02:11,113 --> 00:02:13,951
And we also wanna make it easy for mobile developers,

00:02:13,951 --> 00:02:17,152
to maybe extend the schemas too.

00:02:17,152 --> 00:02:18,749
So the first thing we tackle is,

00:02:18,749 --> 00:02:20,781
how will we define our schemas

00:02:20,781 --> 00:02:24,918
and execute GraphQL queries, for the Shopify API.

00:02:24,918 --> 00:02:28,379
And first thing we did is, turn to the open source community

00:02:28,379 --> 00:02:32,760
and found a great GraphQL gem, that maybe some of you use.

00:02:32,760 --> 00:02:35,485
And we especially found a great maintainer, Robert,

00:02:35,485 --> 00:02:36,719
so shout out to him,

00:02:36,719 --> 00:02:40,447
he's been really helpful, really responsive.

00:02:40,447 --> 00:02:43,598
So with that gem, it lets you like many other (mumbles)

00:02:43,598 --> 00:02:47,308
define your types, define your fields arguments,

00:02:47,308 --> 00:02:51,018
with a nice little DSL you can see here.

00:02:51,018 --> 00:02:53,258
But keeping in mind our goal was to make it easy

00:02:53,258 --> 00:02:55,381
for really anybody to extend it,

00:02:55,381 --> 00:02:58,131
and we have a gigantic Rails app,

00:02:59,081 --> 00:03:00,434
a monolithic Rails app,

00:03:00,434 --> 00:03:03,221
and our developers, are used to,

00:03:03,221 --> 00:03:05,733
are really used to a certain way of coding,

00:03:05,733 --> 00:03:07,945
and we thought, maybe this was a little too far

00:03:07,945 --> 00:03:09,598
from what we were used too.

00:03:09,598 --> 00:03:11,962
So, what we did was actually build a kind of

00:03:11,962 --> 00:03:15,156
two different abstractions on top of that gem,

00:03:15,156 --> 00:03:18,037
to help us make it even easier.

00:03:18,037 --> 00:03:20,526
So we have the GraphQL gem that we use to execute

00:03:20,526 --> 00:03:24,752
these queries, and define the internal GraphQL types.

00:03:24,752 --> 00:03:28,268
But we also have a, what we call GraphModel on top,

00:03:28,268 --> 00:03:30,473
which helps us define these types,

00:03:30,473 --> 00:03:32,140
with another syntax.

00:03:33,221 --> 00:03:35,679
And GraphQL, which is a layer,

00:03:35,679 --> 00:03:40,047
that really contains more of the Shopify specifics doc.

00:03:40,047 --> 00:03:43,768
So this what our GraphModel layer looks like.

00:03:43,768 --> 00:03:47,197
It's quite similar, it's class based.

00:03:47,197 --> 00:03:50,834
Types are defined using simple symbols instead,

00:03:50,834 --> 00:03:53,508
and we have explicit keyword arches for nulls,

00:03:53,508 --> 00:03:56,707
so it's pretty straight forward too.

00:03:56,707 --> 00:03:58,689
And, we're a Rail shop,

00:03:58,689 --> 00:04:00,645
people are used to ActiveRecord.

00:04:00,645 --> 00:04:02,804
You might have noticed the syntax before,

00:04:02,804 --> 00:04:04,698
kind of looked like ActiveRecord too.

00:04:04,698 --> 00:04:06,596
And we wanted to kinda push it further,

00:04:06,596 --> 00:04:09,079
and really make it easy for anybody.

00:04:09,079 --> 00:04:11,005
So we have like helper methods, like,

00:04:11,005 --> 00:04:14,932
belongs_to, which in the end just defines a normal field,

00:04:14,932 --> 00:04:17,880
but doesn't, you don't have to have knowledge,

00:04:17,880 --> 00:04:21,786
of how to define that, (mumbles) GraphQL syntax.

00:04:21,786 --> 00:04:24,090
We have so many other helpers, like cache_has_many,

00:04:24,090 --> 00:04:26,304
who's gonna take care of, fetching that from them

00:04:26,304 --> 00:04:27,730
cache for example.

00:04:27,730 --> 00:04:29,756
Or a paginated helper, that is gonna help define

00:04:29,756 --> 00:04:32,016
a Relay connection for you.

00:04:32,016 --> 00:04:34,759
So it's been great for helping people,

00:04:34,759 --> 00:04:37,166
just really extend our schemas,

00:04:37,166 --> 00:04:39,772
but naively building a schema using these,

00:04:39,772 --> 00:04:43,511
still result in some problems, sometimes.

00:04:43,511 --> 00:04:45,798
So let's take a look at this query for example.

00:04:45,798 --> 00:04:48,461
I'm gonna go through the execution of that query,

00:04:48,461 --> 00:04:50,645
and just take a look at what kind of calls are made,

00:04:50,645 --> 00:04:52,932
to fulfil that query.

00:04:52,932 --> 00:04:55,642
So for example here, we might have shop here,

00:04:55,642 --> 00:04:58,619
that's gonna select shop for our MySQL.

00:04:58,619 --> 00:05:00,301
We're then gonna fetch products,

00:05:00,301 --> 00:05:01,399
which is also pretty simple,

00:05:01,399 --> 00:05:03,361
as we're just fetching products,

00:05:03,361 --> 00:05:05,745
where shop_id is 1, right?

00:05:05,745 --> 00:05:08,865
But if you go down, to the image resolver here,

00:05:08,865 --> 00:05:10,925
turns out it's gonna be called three times,

00:05:10,925 --> 00:05:13,303
and it's gonna do three queries in MySQL.

00:05:13,303 --> 00:05:15,127
And that's a little awkward,

00:05:15,127 --> 00:05:17,351
it's not necessarily what we want.

00:05:17,351 --> 00:05:18,617
And the reason why it's doing that,

00:05:18,617 --> 00:05:21,034
is, each resolver is actually

00:05:21,870 --> 00:05:23,368
called in different context,

00:05:23,368 --> 00:05:26,715
so maybe, if it was in the context of one controller,

00:05:26,715 --> 00:05:29,016
obviously we would of maybe like preloaded that data,

00:05:29,016 --> 00:05:31,163
so we don't only do one call,

00:05:31,163 --> 00:05:34,436
but our resolvers are actually called in different contexts,

00:05:34,436 --> 00:05:36,578
so each resolver doesn't know,

00:05:36,578 --> 00:05:39,620
how many other images are gonna be loaded.

00:05:39,620 --> 00:05:41,610
So we could've went, with a solution,

00:05:41,610 --> 00:05:43,586
maybe analyzing the query,

00:05:43,586 --> 00:05:45,868
and trying to guess what causes it to be made,

00:05:45,868 --> 00:05:47,254
so we can preload before.

00:05:47,254 --> 00:05:48,661
But it's really complex,

00:05:48,661 --> 00:05:51,412
and maybe we didn't need something like that.

00:05:51,412 --> 00:05:54,884
So we went with the usual solution of batching,

00:05:54,884 --> 00:05:57,228
and we've actually released the gem,

00:05:57,228 --> 00:05:59,505
called graphql-batch,

00:05:59,505 --> 00:06:01,804
which Dylan's the main maintainer,

00:06:01,804 --> 00:06:02,870
and it's really great,

00:06:02,870 --> 00:06:06,330
and its principles are actually quite simple.

00:06:06,330 --> 00:06:08,410
And you might be familiar with the principal,

00:06:08,410 --> 00:06:10,980
if you use the JS server too,

00:06:10,980 --> 00:06:12,473
this famous DataLoader,

00:06:12,473 --> 00:06:15,383
that a lot of people use, library.

00:06:15,383 --> 00:06:16,992
It's pretty much the same principle,

00:06:16,992 --> 00:06:18,544
so the principle is to,

00:06:18,544 --> 00:06:21,390
instead of returning the value right away,

00:06:21,390 --> 00:06:24,895
resolver can actually return a Promise,

00:06:24,895 --> 00:06:26,590
for that value.

00:06:26,590 --> 00:06:29,159
And a loader for example,

00:06:29,159 --> 00:06:30,791
is gonna take the record class,

00:06:30,791 --> 00:06:32,662
maybe it's gonna be product here,

00:06:32,662 --> 00:06:34,240
and an association,

00:06:34,240 --> 00:06:36,759
which was the image we wanted on.

00:06:36,759 --> 00:06:39,216
And, when we load for a particular record,

00:06:39,216 --> 00:06:41,062
we don't actually fetch the image right away,

00:06:41,062 --> 00:06:42,343
we just indicate,

00:06:42,343 --> 00:06:45,914
we're interested in that image at some point.

00:06:45,914 --> 00:06:48,490
So, the same kind of images before,

00:06:48,490 --> 00:06:51,022
instead of returning the values in each resolver,

00:06:51,022 --> 00:06:53,415
we're actually just telling our loader

00:06:53,415 --> 00:06:54,599
that we're interested in

00:06:54,599 --> 00:06:57,297
each of these three products images.

00:06:57,297 --> 00:06:58,847
And inside an actual loader,

00:06:58,847 --> 00:07:00,085
it's pretty simple to,

00:07:00,085 --> 00:07:01,632
we have the load method,

00:07:01,632 --> 00:07:03,103
that we just talked about.

00:07:03,103 --> 00:07:05,952
Caches, remembers and returns the Promise.

00:07:05,952 --> 00:07:07,433
And we have a perform method,

00:07:07,433 --> 00:07:09,198
that's called only once,

00:07:09,198 --> 00:07:10,979
and will actually do the hard work,

00:07:10,979 --> 00:07:13,236
of batching that query.

00:07:13,236 --> 00:07:16,911
This example here, is our Memcache AssociationLoader,

00:07:16,911 --> 00:07:19,802
which is gonna prefetch the images,

00:07:19,802 --> 00:07:21,369
on a certain set of products,

00:07:21,369 --> 00:07:24,684
and fulfil every Promise at once.

00:07:24,684 --> 00:07:27,482
The hard thing here, is when to call perform.

00:07:27,482 --> 00:07:30,617
If you've used DataLoader, you might know the use like,

00:07:30,617 --> 00:07:33,343
you use a little trick that you can do in JS,

00:07:33,343 --> 00:07:35,267
they actually wait for process.(mumbles),

00:07:35,267 --> 00:07:39,005
to (mumbles) their perform, Promise,

00:07:39,005 --> 00:07:41,602
but we're in Ruby, so we couldn't really do that,

00:07:41,602 --> 00:07:44,139
so what ended up happening is,

00:07:44,139 --> 00:07:47,250
we used Promise.rb to return these Promises,

00:07:47,250 --> 00:07:50,355
which is a Promise A+ implementation in Ruby.

00:07:50,355 --> 00:07:52,131
And we use a custom executer,

00:07:52,131 --> 00:07:54,634
so basically, when we get the result,

00:07:54,634 --> 00:07:56,874
from the Ruby gem,

00:07:56,874 --> 00:07:58,484
we actually look for Promises,

00:07:58,484 --> 00:07:59,767
and resolve those.

00:07:59,767 --> 00:08:02,664
So, we actually know, that every possible Promise

00:08:02,664 --> 00:08:03,747
was in queue.

00:08:04,747 --> 00:08:07,144
And we have a nice API for that too,

00:08:07,144 --> 00:08:09,554
so, all that logic's actually hidden behind a

00:08:09,554 --> 00:08:13,726
(mumbles), you can just say, for that field :image,

00:08:13,726 --> 00:08:15,228
just please preload it,

00:08:15,228 --> 00:08:16,822
that should be field :product actually,

00:08:16,822 --> 00:08:18,079
preload images.

00:08:18,079 --> 00:08:19,896
And what that does,

00:08:19,896 --> 00:08:21,456
is basically wrapping,

00:08:21,456 --> 00:08:23,111
the normal resolve (mumbles) field,

00:08:23,111 --> 00:08:25,433
with a prefetch, (mumbles).

00:08:25,433 --> 00:08:27,603
So, before hitting the resolve,

00:08:27,603 --> 00:08:29,410
we're actually waiting for that Promise

00:08:29,410 --> 00:08:30,901
to be fulfilled.

00:08:30,901 --> 00:08:32,480
So, that's been really helpful,

00:08:32,480 --> 00:08:34,927
to hide a complexity behind batching,

00:08:34,927 --> 00:08:37,865
and helping really anybody,

00:08:37,865 --> 00:08:39,682
stop people from basically

00:08:39,682 --> 00:08:42,073
shooting themselves in the foot with these queries.

00:08:42,073 --> 00:08:43,983
So if we take a look, at the same query,

00:08:43,983 --> 00:08:45,909
but with batching this time,

00:08:45,909 --> 00:08:48,081
we're gonna have the same queries,

00:08:48,081 --> 00:08:51,638
except, this time we're actually gonna batch it.

00:08:51,638 --> 00:08:53,450
So this is great.

00:08:53,450 --> 00:08:55,450
We have other thing too,

00:08:56,293 --> 00:08:58,116
for authorization, authentication,

00:08:58,116 --> 00:09:00,416
is another kind of pain points,

00:09:00,416 --> 00:09:03,104
people are often hit, when using GraphQL.

00:09:03,104 --> 00:09:05,610
And one of the solution proposes often having it,

00:09:05,610 --> 00:09:07,386
in resolver itself,

00:09:07,386 --> 00:09:11,983
checking for the user, what they're able to do.

00:09:11,983 --> 00:09:14,128
But we went with something a little different.

00:09:14,128 --> 00:09:16,711
Our API clients, access tokens,

00:09:17,953 --> 00:09:19,712
already have the concept of scopes,

00:09:19,712 --> 00:09:22,281
so resources they're allowed to access,

00:09:22,281 --> 00:09:26,032
and we actually coequated that, with our type definitions.

00:09:26,032 --> 00:09:29,108
So for example, an order type requires access to orders.

00:09:29,108 --> 00:09:32,333
And we can actually say, write,

00:09:32,333 --> 00:09:35,070
if you're allowed to write, or is it read only?

00:09:35,070 --> 00:09:38,541
Or we can even specify, for a particular object,

00:09:38,541 --> 00:09:42,374
is the API client allowed to access this type.

00:09:43,957 --> 00:09:45,366
And we compared that about,

00:09:45,366 --> 00:09:47,231
against an AccessControl object,

00:09:47,231 --> 00:09:49,025
that we pass in the context,

00:09:49,025 --> 00:09:50,334
and that AccessControl object,

00:09:50,334 --> 00:09:53,810
contain everything about the API client,

00:09:53,810 --> 00:09:57,744
its capabilities, what types it can access.

00:09:57,744 --> 00:09:59,096
But there's still,

00:09:59,096 --> 00:10:01,921
stuff that we need to protect ourselves against,

00:10:01,921 --> 00:10:03,895
like evil clients, that might,

00:10:03,895 --> 00:10:07,192
build like really complex queries,

00:10:07,192 --> 00:10:11,624
and use many solutions, for that query complexity,

00:10:11,624 --> 00:10:14,048
calculating a score for each field,

00:10:14,048 --> 00:10:15,698
maybe a MaxDepth,

00:10:15,698 --> 00:10:17,156
but we went with the simple solution,

00:10:17,156 --> 00:10:18,670
of a timeout,

00:10:18,670 --> 00:10:21,147
and we used just Ruby Timeouts class,

00:10:21,147 --> 00:10:24,954
which will raise, after certain amount of time.

00:10:24,954 --> 00:10:27,523
Another thing that clients might (mumbles)

00:10:27,523 --> 00:10:29,990
like, really a lot of queries,

00:10:29,990 --> 00:10:31,411
and we've reused the same thing

00:10:31,411 --> 00:10:33,856
we had with our REST APIs,

00:10:33,856 --> 00:10:36,148
which is simple Throttle.

00:10:36,148 --> 00:10:37,455
It's got a leaky bucket throw,

00:10:37,455 --> 00:10:40,254
which will raise to an API client,

00:10:40,254 --> 00:10:42,222
for a certain key, and the key might be a,

00:10:42,222 --> 00:10:44,845
a shop ID in our API client,

00:10:44,845 --> 00:10:46,436
we're gonna Throttle it.

00:10:46,436 --> 00:10:50,173
So that's helped us, mitigate some of those bad clients.

00:10:50,173 --> 00:10:52,538
But really, the cool thing,

00:10:52,538 --> 00:10:55,559
that I really like about our Shopify (mumbles)

00:10:55,559 --> 00:10:56,925
is really the developer experience,

00:10:56,925 --> 00:11:00,293
around building and extending schemas.

00:11:00,293 --> 00:11:03,938
So, we always checking the IDL of the schema,

00:11:03,938 --> 00:11:05,278
in version control,

00:11:05,278 --> 00:11:07,752
so we can actually really see easily,

00:11:07,752 --> 00:11:11,142
what's been changed on a schema, breaking changes,

00:11:11,142 --> 00:11:12,744
and we enforce that.

00:11:12,744 --> 00:11:16,621
So if we compare the new schema against the old schema,

00:11:16,621 --> 00:11:19,316
and if you change the type, change the field,

00:11:19,316 --> 00:11:22,686
we're gonna ask to rebuild that schema_dump

00:11:22,686 --> 00:11:23,769
and check-in.

00:11:25,144 --> 00:11:28,321
And pay really careful attention,

00:11:28,321 --> 00:11:31,886
to not break the schema for no reason,

00:11:31,886 --> 00:11:33,944
so when you try to generate the new dump,

00:11:33,944 --> 00:11:35,604
if something has changed,

00:11:35,604 --> 00:11:37,130
and it's creating a breaking change,

00:11:37,130 --> 00:11:38,524
we can detect that,

00:11:38,524 --> 00:11:42,552
and instruct, either you wanna really wanna break it,

00:11:42,552 --> 00:11:45,469
or maybe rethink what you just did.

00:11:47,338 --> 00:11:49,009
So, we also have on GitHub,

00:11:49,009 --> 00:11:51,440
we have a bot that's gonna alert our GraphQL team,

00:11:51,440 --> 00:11:53,288
whenever the schema changes.

00:11:53,288 --> 00:11:56,481
That also helps us, maybe help someone is new to GraphQL

00:11:56,481 --> 00:11:59,562
that might have just added a field.

00:11:59,562 --> 00:12:02,504
And we also have a strong of conventions,

00:12:02,504 --> 00:12:04,625
these are just a few examples.

00:12:04,625 --> 00:12:08,085
Our mutation actions, we always prefix

00:12:08,085 --> 00:12:10,429
with the object name instead of the action.

00:12:10,429 --> 00:12:13,807
This is makes it a lot easier for us to find mutations,

00:12:13,807 --> 00:12:15,499
since we have a lot.

00:12:15,499 --> 00:12:18,007
Our mutations return a userErrors,

00:12:18,007 --> 00:12:20,559
for errors that should be shown to the clients,

00:12:20,559 --> 00:12:23,784
and we support the Relay spec always so,

00:12:23,784 --> 00:12:26,873
we have actually a test that will check for these,

00:12:26,873 --> 00:12:30,631
for example, did you forget the client mutation ID

00:12:30,631 --> 00:12:32,203
for a mutation?

00:12:32,203 --> 00:12:36,284
We might instruct you to rename mutations,

00:12:36,284 --> 00:12:38,671
and we have a few other things to be

00:12:38,671 --> 00:12:40,151
like instrumentation.

00:12:40,151 --> 00:12:42,654
Instrumentation is really important for us at Shopify,

00:12:42,654 --> 00:12:44,633
and GraphQL wasn't different,

00:12:44,633 --> 00:12:46,678
so we currently have any errors,

00:12:46,678 --> 00:12:48,231
that (mumbles) we have.

00:12:48,231 --> 00:12:51,636
Query time, clients that were troubled,

00:12:51,636 --> 00:12:53,621
or time outted.

00:12:53,621 --> 00:12:54,454
We really wanna have,

00:12:54,454 --> 00:12:56,671
like more precise instrumentation,

00:12:56,671 --> 00:12:58,285
so we're working with Robert,

00:12:58,285 --> 00:12:59,829
the author of the GraphQL gem.

00:12:59,829 --> 00:13:02,224
So we can have maybe nicer hooks,

00:13:02,224 --> 00:13:05,224
to instrument actual resolver times,

00:13:06,890 --> 00:13:08,245
and things like that.

00:13:08,245 --> 00:13:12,424
So, we also have deprecated field usage tracking,

00:13:12,424 --> 00:13:15,464
so every time a deprecated field is executed,

00:13:15,464 --> 00:13:17,038
we actually log it,

00:13:17,038 --> 00:13:18,700
and we're able to using a tool,

00:13:18,700 --> 00:13:21,340
a little bit like log stash, that we use internally.

00:13:21,340 --> 00:13:23,430
We're able to actually query for these,

00:13:23,430 --> 00:13:24,731
deprecate fields,

00:13:24,731 --> 00:13:26,507
and makes it really easy to know when

00:13:26,507 --> 00:13:30,917
you can safely remove a deprecate field, or not.

00:13:30,917 --> 00:13:34,214
So that was a subset of what we have currently,

00:13:34,214 --> 00:13:36,196
on server-side,

00:13:36,196 --> 00:13:37,117
and there's so much more,

00:13:37,117 --> 00:13:39,266
so feel free to come talk to us after,

00:13:39,266 --> 00:13:41,403
but for now, I'm gonna let Dylan come talk

00:13:41,403 --> 00:13:43,916
about what we did, with our mobile clients.

00:13:43,916 --> 00:13:45,368
So please welcome Dylan.

00:13:45,368 --> 00:13:48,368
(audience applause)

00:13:52,609 --> 00:13:54,440
- Alright, so, first I'm gonna give some

00:13:54,440 --> 00:13:56,667
background on what we're actually building,

00:13:56,667 --> 00:13:59,577
and help you understand why we built what we built,

00:13:59,577 --> 00:14:01,278
and how we got there.

00:14:01,278 --> 00:14:04,038
I'll talk about how we use code generation,

00:14:04,038 --> 00:14:07,229
in order to build the clients that we built.

00:14:07,229 --> 00:14:08,947
And also talk about,

00:14:08,947 --> 00:14:10,394
about how we do caching,

00:14:10,394 --> 00:14:11,849
and more importantly,

00:14:11,849 --> 00:14:14,298
how do we keep data consistent across the app,

00:14:14,298 --> 00:14:15,631
when it changes.

00:14:16,773 --> 00:14:19,854
We were rebuilding the mobile Shopify app.

00:14:19,854 --> 00:14:21,996
We were told, we needed to rebuild it,

00:14:21,996 --> 00:14:25,525
so it could provide a full Shopify Admin experience,

00:14:25,525 --> 00:14:28,587
rather than a limited companion app.

00:14:28,587 --> 00:14:30,004
So we decided to,

00:14:31,006 --> 00:14:35,100
make sure that it was also fast, on slower networks,

00:14:35,100 --> 00:14:37,240
so we changed the text stack as well,

00:14:37,240 --> 00:14:38,400
and we looked at GraphQL

00:14:38,400 --> 00:14:41,733
as a way of reducing the response sizes.

00:14:42,588 --> 00:14:46,228
We managed to ship it, in time for our deadline,

00:14:46,228 --> 00:14:47,550
which for us was,

00:14:47,550 --> 00:14:49,454
because we'd wanted our merchants to have it

00:14:49,454 --> 00:14:53,188
before they were busy with the holiday season.

00:14:53,188 --> 00:14:56,688
We started by building it in React-Native,

00:14:58,007 --> 00:15:00,489
we found it very quick to build out the app,

00:15:00,489 --> 00:15:03,247
but we had some troubles with making sure

00:15:03,247 --> 00:15:04,181
we could polish it,

00:15:04,181 --> 00:15:06,344
and get it to the quality that we wanted.

00:15:06,344 --> 00:15:08,429
So we ended up, deciding that,

00:15:08,429 --> 00:15:10,465
since this was a mission critical app,

00:15:10,465 --> 00:15:12,348
and we weren't sure if we could get

00:15:12,348 --> 00:15:14,737
the quality we wanted, in the time we wanted,

00:15:14,737 --> 00:15:19,194
we ended up going with native mobile (mumbles).

00:15:19,194 --> 00:15:21,990
So that meant writing Java and Swift,

00:15:21,990 --> 00:15:25,485
and also meant, we had to leave behind relay,

00:15:25,485 --> 00:15:29,120
which is in JavaScript, unfortunately.

00:15:29,120 --> 00:15:30,955
It was a hard decision, but,

00:15:30,955 --> 00:15:33,705
let's see what type of goals we had

00:15:33,705 --> 00:15:37,404
with building the new GraphQL clients.

00:15:37,404 --> 00:15:38,977
We wanted to keep it simple.

00:15:38,977 --> 00:15:41,154
At this point, I'd already worked on

00:15:41,154 --> 00:15:42,896
building out the server side,

00:15:42,896 --> 00:15:44,242
so we had something there,

00:15:44,242 --> 00:15:46,152
but we needed something on the client to query it,

00:15:46,152 --> 00:15:48,635
we didn't just want to specify,

00:15:48,635 --> 00:15:49,819
literal strings,

00:15:49,819 --> 00:15:51,453
which would be ugly,

00:15:51,453 --> 00:15:54,370
or deal with the raw JSON directly.

00:15:55,717 --> 00:15:58,065
We also wanted it to be easy to understand,

00:15:58,065 --> 00:16:00,317
for our mobile developers.

00:16:00,317 --> 00:16:03,742
They're the targets, they're the ones actually using this.

00:16:03,742 --> 00:16:06,023
So we want to embrace with their use too,

00:16:06,023 --> 00:16:10,071
which is a static type system, and IDEs.

00:16:10,071 --> 00:16:12,850
So we wanted to fit in well with that,

00:16:12,850 --> 00:16:15,162
and we want to think of what's going to happen,

00:16:15,162 --> 00:16:17,746
after we actually ship the app.

00:16:17,746 --> 00:16:20,758
We need to make sure we can, evolve the schema,

00:16:20,758 --> 00:16:24,065
and we want to be able to add to this over time.

00:16:24,065 --> 00:16:25,856
This initial release is just the point

00:16:25,856 --> 00:16:29,792
where we can replace the companion app we had before.

00:16:29,792 --> 00:16:32,613
And for our (mumbles), decoupling the code,

00:16:32,613 --> 00:16:36,780
so using components so we can easily add components to it.

00:16:38,123 --> 00:16:39,967
In order to do all this,

00:16:39,967 --> 00:16:42,329
we realised that a GraphQL Schema

00:16:42,329 --> 00:16:44,297
was the killer feature for this.

00:16:44,297 --> 00:16:46,732
This is what, I think Facebook

00:16:46,732 --> 00:16:48,886
really developed this schema for,

00:16:48,886 --> 00:16:52,292
they wanted it to integrate well, with static type system.

00:16:52,292 --> 00:16:54,093
So we use that for code generation,

00:16:54,093 --> 00:16:56,869
we built code for building a query,

00:16:56,869 --> 00:16:59,700
and for the response classes.

00:16:59,700 --> 00:17:01,454
And we want to make it easy to use,

00:17:01,454 --> 00:17:03,253
so we have a script that

00:17:03,253 --> 00:17:06,045
doesn't require any arguments to use,

00:17:06,045 --> 00:17:08,724
and that only has to be around in order to take advantage

00:17:08,724 --> 00:17:11,391
of anything added to the server.

00:17:13,785 --> 00:17:17,414
So let's look at what the code generator produces for us,

00:17:17,414 --> 00:17:20,421
starting with the query builders.

00:17:20,421 --> 00:17:21,900
On the left you can see the code,

00:17:21,900 --> 00:17:23,283
for building the query,

00:17:23,283 --> 00:17:27,757
and on the right, the query it actually produces.

00:17:27,757 --> 00:17:29,523
Notice the similarity between that.

00:17:29,523 --> 00:17:31,090
That's on purpose.

00:17:31,090 --> 00:17:34,196
We use the builder pattern, to implement this,

00:17:34,196 --> 00:17:36,884
where we add fields by calling methods,

00:17:36,884 --> 00:17:38,777
which are (mumbles) by the returning

00:17:38,777 --> 00:17:40,631
the object they're called on.

00:17:40,631 --> 00:17:43,133
And we use closures, to specify,

00:17:43,133 --> 00:17:44,716
subfields on those.

00:17:45,606 --> 00:17:47,400
We use literal values,

00:17:47,400 --> 00:17:50,662
in order to specify any arguments,

00:17:50,662 --> 00:17:53,425
which are provided when we're building the query.

00:17:53,425 --> 00:17:57,317
So the query is actually built (mumbles) time.

00:17:57,317 --> 00:17:59,474
We have a similar API for Java,

00:17:59,474 --> 00:18:00,807
and at the time,

00:18:01,715 --> 00:18:04,429
we thought it was going to be hard

00:18:04,429 --> 00:18:06,428
to provide this because,

00:18:06,428 --> 00:18:08,948
Java 8 had lambda expressions,

00:18:08,948 --> 00:18:11,889
but there was no support for that on Android.

00:18:11,889 --> 00:18:13,809
But we found out we could use retrolambda,

00:18:13,809 --> 00:18:17,392
to backport this to older versions of Java.

00:18:18,352 --> 00:18:20,198
Now there's an Android toolchain,

00:18:20,198 --> 00:18:24,008
which might adopt when it's more mature, called Jack,

00:18:24,008 --> 00:18:27,091
which also provides support for this.

00:18:27,944 --> 00:18:30,464
Normally, it seems like fragents are used for

00:18:30,464 --> 00:18:33,546
composing queries, letting components

00:18:33,546 --> 00:18:36,153
specify what they want,

00:18:36,153 --> 00:18:38,382
so they can keep their data dependencies

00:18:38,382 --> 00:18:39,843
close to their data use.

00:18:39,843 --> 00:18:41,835
We took a much simpler approach.

00:18:41,835 --> 00:18:45,285
Instead, we just have a function that takes in,

00:18:45,285 --> 00:18:46,880
query builder object,

00:18:46,880 --> 00:18:48,477
and we can put that on the component,

00:18:48,477 --> 00:18:50,951
and it can specify what it wants.

00:18:50,951 --> 00:18:53,755
And we don't have to have anymore support for it,

00:18:53,755 --> 00:18:56,488
or explain anything to our developers,

00:18:56,488 --> 00:19:00,325
because they know how to do function calls.

00:19:00,325 --> 00:19:03,380
We do use fragments, inline fragments,

00:19:03,380 --> 00:19:06,734
in order to specify what fields we want,

00:19:06,734 --> 00:19:08,359
on a specific object type,

00:19:08,359 --> 00:19:10,246
when we're dealing with an interface.

00:19:10,246 --> 00:19:12,227
In this case, an event is an interface,

00:19:12,227 --> 00:19:16,255
and type name is automatically querying on that,

00:19:16,255 --> 00:19:19,912
which we'll use in the response classes.

00:19:19,912 --> 00:19:22,390
We also automatically query IDE,

00:19:22,390 --> 00:19:23,789
which you'll see that we use

00:19:23,789 --> 00:19:26,289
in the data consistency layer.

00:19:27,352 --> 00:19:32,028
By generating these type specific query builder classes,

00:19:32,028 --> 00:19:34,759
and methods for each field,

00:19:34,759 --> 00:19:36,548
we integrate well with the IDE,

00:19:36,548 --> 00:19:39,207
because we can actually check these,

00:19:39,207 --> 00:19:41,888
at compile time, by just compiling the code,

00:19:41,888 --> 00:19:44,995
and the IDEs since can check for compiler errors,

00:19:44,995 --> 00:19:47,416
can highlight any errors for us.

00:19:47,416 --> 00:19:49,900
We also get auto-completion for free,

00:19:49,900 --> 00:19:52,274
and by generating documentation,

00:19:52,274 --> 00:19:54,985
we can surface that in the IDE.

00:19:54,985 --> 00:19:57,173
We also have deprecated field use,

00:19:57,173 --> 00:19:59,673
by using annotations for that.

00:20:00,522 --> 00:20:02,049
So we kept things simple,

00:20:02,049 --> 00:20:04,465
by leaving out some GraphQL features,

00:20:04,465 --> 00:20:07,123
and by intergrating with the type system,

00:20:07,123 --> 00:20:09,834
we were also able to get all the IDE features,

00:20:09,834 --> 00:20:12,690
without having to implement an IDE plugin,

00:20:12,690 --> 00:20:14,440
just to provide that.

00:20:16,000 --> 00:20:18,428
We also were still able to do

00:20:18,428 --> 00:20:20,889
the loose coupling that we wanted,

00:20:20,889 --> 00:20:23,094
even without these features,

00:20:23,094 --> 00:20:26,206
and as the schema changes, we just run a script,

00:20:26,206 --> 00:20:27,722
and we can adapt to that.

00:20:27,722 --> 00:20:30,349
And notibly, in order to remove the fields,

00:20:30,349 --> 00:20:31,709
since we evolve the schema,

00:20:31,709 --> 00:20:33,468
we can just mark them as deprecated,

00:20:33,468 --> 00:20:34,966
and when they run that script,

00:20:34,966 --> 00:20:37,602
they'll get some warnings for deprecated field use,

00:20:37,602 --> 00:20:39,935
and can easily address them.

00:20:41,050 --> 00:20:42,756
Let's look at the response classes,

00:20:42,756 --> 00:20:46,256
because we don't wanna deal with raw JSON.

00:20:47,842 --> 00:20:50,069
Instead, what we get to deal with,

00:20:50,069 --> 00:20:52,161
is something much more pleasant.

00:20:52,161 --> 00:20:53,403
These response objects,

00:20:53,403 --> 00:20:57,020
are already validated when they're constructed.

00:20:57,020 --> 00:20:59,467
They all deserialize the fields,

00:20:59,467 --> 00:21:01,307
and provide access or methods,

00:21:01,307 --> 00:21:04,833
so that we can leverage the type system,

00:21:04,833 --> 00:21:06,697
notably dealing with nulls

00:21:06,697 --> 00:21:08,462
is a common pain point,

00:21:08,462 --> 00:21:10,402
so we use Swift optional types,

00:21:10,402 --> 00:21:13,274
which allow us to, be forced to check for null,

00:21:13,274 --> 00:21:16,492
where necessary, for nullable fields.

00:21:16,492 --> 00:21:19,661
And for non null fields, we don't have to be concerned with

00:21:19,661 --> 00:21:21,454
can this thing be null or not,

00:21:21,454 --> 00:21:24,636
that's all encoded in the scheme for us.

00:21:24,636 --> 00:21:25,768
We found this so convenient,

00:21:25,768 --> 00:21:28,111
we decided to replace the model error,

00:21:28,111 --> 00:21:29,568
and for this app it made sense.

00:21:29,568 --> 00:21:33,121
We wanted to keep as much logic as we could, on the server,

00:21:33,121 --> 00:21:35,016
and that way, we didn't have to worry about

00:21:35,016 --> 00:21:37,858
avoiding code duplication.

00:21:37,858 --> 00:21:40,191
And notably we can leverage,

00:21:41,573 --> 00:21:43,780
all that code that's already written on the server

00:21:43,780 --> 00:21:46,530
and allow it to change over time.

00:21:47,438 --> 00:21:50,084
Since we wanted our response objects to be convenienced,

00:21:50,084 --> 00:21:52,387
that also meant looking at custom scalars.

00:21:52,387 --> 00:21:54,860
We didn't want to deal with, the string as it's encoded

00:21:54,860 --> 00:21:59,027
in the JSON response, where money or daytime types.

00:22:00,503 --> 00:22:02,890
So instead we took, approach of

00:22:02,890 --> 00:22:06,279
keeping our GraphQL code generator generic,

00:22:06,279 --> 00:22:08,486
so it'll work on any schema,

00:22:08,486 --> 00:22:12,841
but providing a way for it to be used, where

00:22:12,841 --> 00:22:15,380
custom scalars can be,

00:22:15,380 --> 00:22:16,990
we can pass them something,

00:22:16,990 --> 00:22:19,805
that can specify how to generate code for it.

00:22:19,805 --> 00:22:21,733
So in this case, we specify what types

00:22:21,733 --> 00:22:22,823
to actually use for it,

00:22:22,823 --> 00:22:26,974
and how to serialize and deserialize it.

00:22:26,974 --> 00:22:30,760
So our update schema script is what adapts,

00:22:30,760 --> 00:22:33,089
to our specific case,

00:22:33,089 --> 00:22:35,074
for that application,

00:22:35,074 --> 00:22:37,819
whereas the code generator is separate from that,

00:22:37,819 --> 00:22:42,539
and ideally we can open source it in the future.

00:22:42,539 --> 00:22:44,681
Another thing we have to address is,

00:22:44,681 --> 00:22:47,114
the fact that we don't know all the types

00:22:47,114 --> 00:22:48,739
that are ever going to be there.

00:22:48,739 --> 00:22:52,187
We generate code, and we're going to ship the app,

00:22:52,187 --> 00:22:54,747
and people are going to run with all the versions.

00:22:54,747 --> 00:22:56,838
So that means you have to deal with the known values,

00:22:56,838 --> 00:23:00,644
that we don't know about when the code is generated.

00:23:00,644 --> 00:23:03,546
To address that, we generate an unknown value,

00:23:03,546 --> 00:23:07,802
and add it to the unknown type, for the language,

00:23:07,802 --> 00:23:09,313
like Swift or Java.

00:23:09,313 --> 00:23:12,373
And, in the case of exhaustive switch statements,

00:23:12,373 --> 00:23:15,635
we can be forced to actually have a case for that,

00:23:15,635 --> 00:23:18,369
as well as being forced to handle all the known cases

00:23:18,369 --> 00:23:22,536
if we choose to, use an exhaustive switch statement.

00:23:24,312 --> 00:23:26,252
For interface fields,

00:23:26,252 --> 00:23:28,376
we return the object type,

00:23:28,376 --> 00:23:30,374
for the actual object,

00:23:30,374 --> 00:23:34,303
and make sure that it implements the interface.

00:23:34,303 --> 00:23:36,287
But that means using the type name,

00:23:36,287 --> 00:23:38,878
and making sure that, we can actually match that,

00:23:38,878 --> 00:23:41,936
with a corresponding response class.

00:23:41,936 --> 00:23:45,032
So we have to deal with the unknown case again.

00:23:45,032 --> 00:23:49,199
So we generate an unknown class, for each interface type,

00:23:50,064 --> 00:23:52,819
so in this example for events,

00:23:52,819 --> 00:23:55,086
we have unknown events class,

00:23:55,086 --> 00:23:57,865
and that implements the event interface,

00:23:57,865 --> 00:24:01,175
and that way we can fall back to using the common methods,

00:24:01,175 --> 00:24:04,175
on common fields on, that interface.

00:24:08,316 --> 00:24:10,962
So in summary for the response classes,

00:24:10,962 --> 00:24:12,170
we simplified things,

00:24:12,170 --> 00:24:14,891
by avoiding a hand written model layer.

00:24:14,891 --> 00:24:17,277
We integrated well with the type system,

00:24:17,277 --> 00:24:20,444
and we left room for schema evolution.

00:24:21,585 --> 00:24:22,908
And in addition to that,

00:24:22,908 --> 00:24:25,323
we left room for the business logic to change,

00:24:25,323 --> 00:24:27,187
without having inaccuracies,

00:24:27,187 --> 00:24:30,978
by just being able to add fields to the schema,

00:24:30,978 --> 00:24:33,061
that are computed fields.

00:24:33,915 --> 00:24:37,573
And we use that liberally, to keep code,

00:24:37,573 --> 00:24:41,740
that we've classified as business logic out of the client.

00:24:42,892 --> 00:24:46,444
So, let's end by talking about how we cache things,

00:24:46,444 --> 00:24:50,513
and keep data consistent across the app.

00:24:50,513 --> 00:24:53,300
For caching, we cache whole responses,

00:24:53,300 --> 00:24:56,011
and we key that based on the query string,

00:24:56,011 --> 00:24:58,094
and persist that to disk.

00:24:59,261 --> 00:25:01,404
That way, when the app is reopened,

00:25:01,404 --> 00:25:03,794
we're able to quickly render something,

00:25:03,794 --> 00:25:05,670
and if that data's changed,

00:25:05,670 --> 00:25:07,453
we still actually send that query,

00:25:07,453 --> 00:25:11,399
so we can get back the response and change the view,

00:25:11,399 --> 00:25:15,066
with the actual data that we've just gotten.

00:25:16,160 --> 00:25:18,935
So we have to handle both of those responses,

00:25:18,935 --> 00:25:21,036
and we have a handle relay query method,

00:25:21,036 --> 00:25:24,054
that's defined on a relayable object,

00:25:24,054 --> 00:25:25,805
which is an interface.

00:25:25,805 --> 00:25:28,314
And we pass that relayable object,

00:25:28,314 --> 00:25:31,147
to the method query, for the data.

00:25:33,227 --> 00:25:38,160
So that handler method, would get called multiple times.

00:25:38,160 --> 00:25:41,319
And we also keep that relayable object around,

00:25:41,319 --> 00:25:44,238
in a list of active queries,

00:25:44,238 --> 00:25:46,198
which represent all the parts of the app

00:25:46,198 --> 00:25:49,534
that'll need to be, updated when data changes,

00:25:49,534 --> 00:25:50,990
And we have a weak reference,

00:25:50,990 --> 00:25:54,006
in order to clean up that list of active queries,

00:25:54,006 --> 00:25:55,816
when anything in it,

00:25:55,816 --> 00:25:59,983
no longer is there to update when the views gone away.

00:26:01,121 --> 00:26:03,018
When a mutation happens,

00:26:03,018 --> 00:26:04,938
we wanna update the whole app,

00:26:04,938 --> 00:26:09,408
so that we can see that change represented elsewhere,

00:26:09,408 --> 00:26:13,361
and even as they navigate through the app.

00:26:13,361 --> 00:26:15,511
So what we do, is we find all the nodes,

00:26:15,511 --> 00:26:17,460
on the mutation payload,

00:26:17,460 --> 00:26:22,193
and match that against nodes in the active query objects.

00:26:22,193 --> 00:26:25,598
In order to find everything that needs to be updated,

00:26:25,598 --> 00:26:29,311
and we match those by just comparing the IDs.

00:26:29,311 --> 00:26:31,527
We deep merge the fields from the payload node,

00:26:31,527 --> 00:26:33,814
onto the active query node,

00:26:33,814 --> 00:26:37,293
and then call that handleRelayQuery method,

00:26:37,293 --> 00:26:39,626
in order to update the view.

00:26:41,061 --> 00:26:42,982
Optimistic updates are similar,

00:26:42,982 --> 00:26:45,669
in that they target a specific node,

00:26:45,669 --> 00:26:48,113
and specify what action to perform on it,

00:26:48,113 --> 00:26:52,319
like deleting it, or we might do an update.

00:26:52,319 --> 00:26:54,545
For the updates, we use the response class,

00:26:54,545 --> 00:26:56,466
in order to specify that,

00:26:56,466 --> 00:26:57,767
and have setter methods,

00:26:57,767 --> 00:27:01,100
so we can specify what changes on those.

00:27:04,706 --> 00:27:06,569
When the response actually comes back,

00:27:06,569 --> 00:27:08,818
we wanna rollback the optimistic update,

00:27:08,818 --> 00:27:11,726
because we don't wanna assume that that actually happened,

00:27:11,726 --> 00:27:14,472
it's just a present what we think will happen,

00:27:14,472 --> 00:27:17,639
before the actual response comes back.

00:27:20,160 --> 00:27:21,236
So we kept things simple,

00:27:21,236 --> 00:27:23,804
we just had the whole response caching,

00:27:23,804 --> 00:27:28,639
and we use type checking, for optimistic updates,

00:27:28,639 --> 00:27:30,899
and I think we've built something for the long term,

00:27:30,899 --> 00:27:33,594
by making sure that we have data consistency,

00:27:33,594 --> 00:27:35,370
without coupling, which means,

00:27:35,370 --> 00:27:37,297
when we do a mutation, we don't say,

00:27:37,297 --> 00:27:39,330
here's all the things that needs update,

00:27:39,330 --> 00:27:44,268
we just do the mutation, and let the updates propagate.

00:27:44,268 --> 00:27:46,085
If this talk has been interesting to you,

00:27:46,085 --> 00:27:49,056
you can follow our work on our engineering blog,

00:27:49,056 --> 00:27:51,386
and as pointed out that,

00:27:51,386 --> 00:27:53,941
some people are hiring GraphQL devs and,

00:27:53,941 --> 00:27:57,205
I could certainly use some help,

00:27:57,205 --> 00:27:59,797
and hopefully I can open source some things

00:27:59,797 --> 00:28:01,921
we've been working on here.

00:28:01,921 --> 00:28:04,923
At least the generic parts of it.

00:28:04,923 --> 00:28:06,095
Thank you.

00:28:06,095 --> 00:28:09,095

YouTube URL: https://www.youtube.com/watch?v=Wlu_PWCjc6Y


