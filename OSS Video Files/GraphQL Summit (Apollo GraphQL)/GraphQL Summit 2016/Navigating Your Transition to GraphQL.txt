Title: Navigating Your Transition to GraphQL
Publication date: 2016-11-02
Playlist: GraphQL Summit 2016
Description: 
	Sashko Stubailo and Danielle Man, Apollo 

We've seen countless examples of how GraphQL makes it easier to organize, maintain, and use APIs. If you’re building with it today, over a year after it was initially released, you can benefit from the experience of many teams that came before you. You can also leverage the wide array of tools built by the community to make it easier to adopt GraphQL alongside technologies you’re already using. In this talk, we’ve distilled lessons and architectural patterns from top companies, the open source community, and our own production apps to help you embark on your GraphQL journey.

Slides: http://www.slideshare.net/sashko1/navigating-your-transition-to-graphql-with-graphql-first-development

Learn more about GraphQL Summit:
http://graphqlsummit.com

Get insights into your GraphQL apps with a free trial of Apollo Optics: 
http://www.apollodata.com/optics

Join our GraphQL SF meetup to hear more about GraphQL best practices and implementations: 
http://meetup.com/GraphQL-SF/
Captions: 
	00:00:03,710 --> 00:00:08,000
great thank you everyone for coming I'm

00:00:06,290 --> 00:00:10,880
so excited to be a part of this

00:00:08,000 --> 00:00:13,400
first-ever graphical conference we never

00:00:10,880 --> 00:00:14,810
thought back when we're starting to

00:00:13,400 --> 00:00:18,199
graph Kilda this would be happening so

00:00:14,810 --> 00:00:19,850
soon so thank you all for being here so

00:00:18,199 --> 00:00:21,830
our talk is called navigating your

00:00:19,850 --> 00:00:24,380
transition to graph QL and basically

00:00:21,830 --> 00:00:25,970
it's about what we've learned from

00:00:24,380 --> 00:00:27,770
talking to a whole ton of people about

00:00:25,970 --> 00:00:30,230
them using graphical and what we learned

00:00:27,770 --> 00:00:32,809
from our own apps and an approach that

00:00:30,230 --> 00:00:34,879
we're discovering and you know maybe

00:00:32,809 --> 00:00:38,600
naming calling it called graph kill

00:00:34,879 --> 00:00:40,970
first so start with who are we so we're

00:00:38,600 --> 00:00:42,950
the Apollo team we're excited to build

00:00:40,970 --> 00:00:44,090
and maintain tools for the graphical

00:00:42,950 --> 00:00:46,489
community so you might have heard about

00:00:44,090 --> 00:00:47,149
optics already or Apollo client or some

00:00:46,489 --> 00:00:48,950
of these things we're going to talk

00:00:47,149 --> 00:00:50,600
about later today we're super excited

00:00:48,950 --> 00:00:53,360
specifically about the developer

00:00:50,600 --> 00:00:54,620
experience enabled by graph QL we think

00:00:53,360 --> 00:00:56,420
that not only is it a great and

00:00:54,620 --> 00:00:58,399
efficient way of getting data in your

00:00:56,420 --> 00:00:59,780
application but the most important thing

00:00:58,399 --> 00:01:02,360
is how it allows you to scale your

00:00:59,780 --> 00:01:04,159
development team and build apps faster

00:01:02,360 --> 00:01:05,990
than you ever could before

00:01:04,159 --> 00:01:07,790
we've gone from zero to graph QL in two

00:01:05,990 --> 00:01:09,770
different apps one was incremental e

00:01:07,790 --> 00:01:11,720
application that we built before graph

00:01:09,770 --> 00:01:14,119
kill existed and we migrated some of our

00:01:11,720 --> 00:01:15,710
data loading to graph Q on that then we

00:01:14,119 --> 00:01:17,510
also built a new app from scratch using

00:01:15,710 --> 00:01:19,549
graph QL with a really different

00:01:17,510 --> 00:01:24,380
exciting workflow that we've been coming

00:01:19,549 --> 00:01:26,450
up with so we'll hear about that and we

00:01:24,380 --> 00:01:27,920
also like to build apps and features and

00:01:26,450 --> 00:01:31,010
open source projects that enable a

00:01:27,920 --> 00:01:33,080
better graphic you workflow and so I

00:01:31,010 --> 00:01:35,390
will tell you a little about that in the

00:01:33,080 --> 00:01:37,400
present team so let's look back a little

00:01:35,390 --> 00:01:39,380
bit at you know how we got here in the

00:01:37,400 --> 00:01:40,930
graphical community so in 2012 graph

00:01:39,380 --> 00:01:44,689
kill was initially released at Facebook

00:01:40,930 --> 00:01:45,500
used in the native iOS application we

00:01:44,689 --> 00:01:47,720
hear about that later

00:01:45,500 --> 00:01:50,630
in July 2015 it was announced an open

00:01:47,720 --> 00:01:52,520
source that react Europe and that was

00:01:50,630 --> 00:01:53,869
really cool and less than a or a little

00:01:52,520 --> 00:01:55,610
bit more than a year later in September

00:01:53,869 --> 00:01:57,380
just recently it was announced we

00:01:55,610 --> 00:01:59,119
production ready and we got a great new

00:01:57,380 --> 00:02:00,680
website and great new documentation and

00:01:59,119 --> 00:02:03,200
the awesome announcement from github

00:02:00,680 --> 00:02:04,820
about the public API and so where do we

00:02:03,200 --> 00:02:06,320
go from there in the future what is

00:02:04,820 --> 00:02:07,790
there more to be done in the graphical

00:02:06,320 --> 00:02:09,920
community after all these awesome events

00:02:07,790 --> 00:02:12,230
so we think the answer is even better

00:02:09,920 --> 00:02:13,639
tools better best practices that

00:02:12,230 --> 00:02:15,379
everyone can agree on in a more

00:02:13,639 --> 00:02:16,290
efficient workflow for building your

00:02:15,379 --> 00:02:19,290
applications

00:02:16,290 --> 00:02:20,340
so we've been hearing about how a lot of

00:02:19,290 --> 00:02:21,659
people build their apps and we've

00:02:20,340 --> 00:02:23,970
started condensing this into what we

00:02:21,659 --> 00:02:26,120
call a graphic you'll first development

00:02:23,970 --> 00:02:28,409
workflow this doesn't necessarily mean

00:02:26,120 --> 00:02:29,579
first chronologically because you might

00:02:28,409 --> 00:02:31,799
have an existing app with an existing

00:02:29,579 --> 00:02:33,000
back-end but this means first as in the

00:02:31,799 --> 00:02:35,849
first thing you think about is your

00:02:33,000 --> 00:02:37,079
graphic you'll schema so you know like

00:02:35,849 --> 00:02:38,190
our presentation we're going to start

00:02:37,079 --> 00:02:40,170
with talking about how you might design

00:02:38,190 --> 00:02:41,280
a graph kill scheme of your API and some

00:02:40,170 --> 00:02:44,790
of the decisions you have to make there

00:02:41,280 --> 00:02:46,590
how you can use the graph QL schema you

00:02:44,790 --> 00:02:49,079
come up with has a contract to design

00:02:46,590 --> 00:02:51,420
your UI in your back-end in parallel and

00:02:49,079 --> 00:02:52,829
then later how you can take advantage of

00:02:51,420 --> 00:02:55,109
some of the advanced features of

00:02:52,829 --> 00:02:56,970
graphical to run in production and get

00:02:55,109 --> 00:03:00,120
more insights into how your back-end is

00:02:56,970 --> 00:03:03,599
working so let's start with designing

00:03:00,120 --> 00:03:04,950
your schema so how many of you guys have

00:03:03,599 --> 00:03:08,400
seen a diagram that looks like this

00:03:04,950 --> 00:03:11,010
before there you go so if you think back

00:03:08,400 --> 00:03:12,780
to when you were building your apps with

00:03:11,010 --> 00:03:14,280
maybe PHP and my sequel or something

00:03:12,780 --> 00:03:16,409
like that the first thing you would do

00:03:14,280 --> 00:03:18,450
is you would sit down and draw a bunch

00:03:16,409 --> 00:03:20,549
of boxes of errors between them foreign

00:03:18,450 --> 00:03:23,359
keys rows relationships it's really

00:03:20,549 --> 00:03:26,040
great time I think the problem is that

00:03:23,359 --> 00:03:28,049
this database schema is not always as

00:03:26,040 --> 00:03:29,099
relevant in today's world because the

00:03:28,049 --> 00:03:30,269
front-end developers are no longer

00:03:29,099 --> 00:03:31,799
interacting with the database directly

00:03:30,269 --> 00:03:33,180
they're interacting with it through some

00:03:31,799 --> 00:03:35,370
sort of API which might not have the

00:03:33,180 --> 00:03:38,010
same fields and applications are getting

00:03:35,370 --> 00:03:39,150
more complex not all of those fields are

00:03:38,010 --> 00:03:41,220
in the same database some of them might

00:03:39,150 --> 00:03:42,780
be in MongoDB or they might be in an

00:03:41,220 --> 00:03:44,849
externally tagged somewhere and so

00:03:42,780 --> 00:03:46,379
that's we need a new way to do diagrams

00:03:44,849 --> 00:03:49,349
like this that are relevant to the

00:03:46,379 --> 00:03:51,780
modern age and that's where the graph QL

00:03:49,349 --> 00:03:54,239
schema comes in so it's really cool that

00:03:51,780 --> 00:03:56,250
graph QL includes the totally back-end

00:03:54,239 --> 00:03:57,870
agnostic and language agnostic way to

00:03:56,250 --> 00:03:59,519
describe your schema so you can sit down

00:03:57,870 --> 00:04:01,199
I've seen our services team having

00:03:59,519 --> 00:04:03,299
meetings where they have text like the

00:04:01,199 --> 00:04:05,370
text like this up on the projector and

00:04:03,299 --> 00:04:06,629
they're discussing what is going to be

00:04:05,370 --> 00:04:08,099
the communication between their front

00:04:06,629 --> 00:04:09,359
and their back end it's great because

00:04:08,099 --> 00:04:11,400
you can even declare relationship

00:04:09,359 --> 00:04:12,780
relationships between objects that are

00:04:11,400 --> 00:04:15,299
in different backends and different data

00:04:12,780 --> 00:04:16,829
sources or databases and you can start

00:04:15,299 --> 00:04:18,539
doing this design even if you have an

00:04:16,829 --> 00:04:19,859
existing back-end already you can get

00:04:18,539 --> 00:04:21,180
the API you've always wanted to sit down

00:04:19,859 --> 00:04:23,159
and think well here's what I have in my

00:04:21,180 --> 00:04:25,889
REST API or my database but what fields

00:04:23,159 --> 00:04:27,360
do I really want and if you do it right

00:04:25,889 --> 00:04:29,460
you'll end up with situation looks like

00:04:27,360 --> 00:04:30,120
this where you have all your consumers

00:04:29,460 --> 00:04:32,120
on one side

00:04:30,120 --> 00:04:34,169
your mobile app your external API

00:04:32,120 --> 00:04:37,230
consumers represented by this cloud

00:04:34,169 --> 00:04:39,150
server thing and some desktop apps maybe

00:04:37,230 --> 00:04:40,199
but you have all these different clients

00:04:39,150 --> 00:04:41,310
that are being developed and then you

00:04:40,199 --> 00:04:43,110
have all these different backends that

00:04:41,310 --> 00:04:44,400
they're talking to like your Rails

00:04:43,110 --> 00:04:47,220
monolith that you're trying to get rid

00:04:44,400 --> 00:04:51,449
of or your salesforce external API or

00:04:47,220 --> 00:04:53,100
you know people people understand or

00:04:51,449 --> 00:04:54,930
maybe some databases that you're working

00:04:53,100 --> 00:04:57,000
with but the idea is that you can

00:04:54,930 --> 00:04:58,260
develop each side in isolation without

00:04:57,000 --> 00:05:00,030
having to worry about where the data is

00:04:58,260 --> 00:05:01,560
coming from and the back and people can

00:05:00,030 --> 00:05:03,540
safely optimize their app without

00:05:01,560 --> 00:05:04,979
breaking anything on the front and so

00:05:03,540 --> 00:05:06,570
now Danielle will tell you how we took

00:05:04,979 --> 00:05:08,040
advantage of this schema first approach

00:05:06,570 --> 00:05:11,370
to design in some of our own production

00:05:08,040 --> 00:05:13,080
apps yeah great so in his introduction

00:05:11,370 --> 00:05:15,419
sashko mentioned that we've gone from

00:05:13,080 --> 00:05:17,880
zero graph QL to some graph QL into

00:05:15,419 --> 00:05:19,260
production apps and the first one I want

00:05:17,880 --> 00:05:21,450
to tell you guys the story of is how we

00:05:19,260 --> 00:05:23,280
did that interact Alok C so our app

00:05:21,450 --> 00:05:26,130
galaxy which you're looking at a screen

00:05:23,280 --> 00:05:28,320
shot of right here is a hosting platform

00:05:26,130 --> 00:05:30,270
for meteor apps and so what you see

00:05:28,320 --> 00:05:31,710
right here is that you can deploy an app

00:05:30,270 --> 00:05:33,750
to meteor and then you can log into our

00:05:31,710 --> 00:05:35,280
galaxy console and monitor the

00:05:33,750 --> 00:05:37,169
containers that are being used to run

00:05:35,280 --> 00:05:40,050
that up and so here you can see a list

00:05:37,169 --> 00:05:41,610
of containers each row there is

00:05:40,050 --> 00:05:46,620
representing a container that's working

00:05:41,610 --> 00:05:48,900
to towards running wwe.com and when we

00:05:46,620 --> 00:05:51,810
originally built galaxy it was built 100

00:05:48,900 --> 00:05:53,729
percent on meteor and react and so when

00:05:51,810 --> 00:05:56,310
we implemented this page it was

00:05:53,729 --> 00:05:58,830
extremely data UI intensive because for

00:05:56,310 --> 00:06:01,110
each of those charts um they're live

00:05:58,830 --> 00:06:03,990
updating with data from Amazon DynamoDB

00:06:01,110 --> 00:06:06,510
and from MongoDB coming together at the

00:06:03,990 --> 00:06:08,370
same time and so when we started getting

00:06:06,510 --> 00:06:10,260
excited about graph QL we saw this as

00:06:08,370 --> 00:06:13,440
the perfect opportunity to incrementally

00:06:10,260 --> 00:06:15,150
adopt it into our own app and we saw it

00:06:13,440 --> 00:06:17,250
sort of as an opportunity to redesign

00:06:15,150 --> 00:06:20,400
the data layer specifically for this

00:06:17,250 --> 00:06:21,630
page which was one of the one of the

00:06:20,400 --> 00:06:24,270
pages that users had the most

00:06:21,630 --> 00:06:26,280
performance issues with and so we were

00:06:24,270 --> 00:06:29,400
able to you can imagine if you have like

00:06:26,280 --> 00:06:31,349
20 containers like WWE comm des and each

00:06:29,400 --> 00:06:33,419
one has three graphs that are live

00:06:31,349 --> 00:06:35,789
updating and you can imagine that

00:06:33,419 --> 00:06:37,560
combining all of those queries and all

00:06:35,789 --> 00:06:41,820
of those individual connections to be

00:06:37,560 --> 00:06:43,260
together and was a huge performance was

00:06:41,820 --> 00:06:45,570
a huge performance upgrade for

00:06:43,260 --> 00:06:48,060
and also on the front end as a friend

00:06:45,570 --> 00:06:50,820
and developers I am it was much easier

00:06:48,060 --> 00:06:52,140
to interact with the graphic ul API then

00:06:50,820 --> 00:06:54,330
it was we were able to significantly

00:06:52,140 --> 00:06:56,700
simplify the code that we had in our own

00:06:54,330 --> 00:06:59,510
front-end and so here I just have a

00:06:56,700 --> 00:07:02,910
quick system diagram of what our galaxy

00:06:59,510 --> 00:07:04,740
architecture looks like we have our

00:07:02,910 --> 00:07:06,660
client which talks to our galaxy server

00:07:04,740 --> 00:07:09,300
which gets data from elasticsearch

00:07:06,660 --> 00:07:12,890
MongoDB and Amazon DynamoDB and we were

00:07:09,300 --> 00:07:15,840
able to instrument our server to combine

00:07:12,890 --> 00:07:18,060
MongoDB and DynamoDB data together and

00:07:15,840 --> 00:07:20,160
so all our client had to do is request

00:07:18,060 --> 00:07:21,870
it we didn't have to get those things

00:07:20,160 --> 00:07:23,640
separately from the client um there's a

00:07:21,870 --> 00:07:26,640
really big performance upgrade for us

00:07:23,640 --> 00:07:29,730
and the second app that I want to tell

00:07:26,640 --> 00:07:31,590
you guys about is optics and so our CEO

00:07:29,730 --> 00:07:33,450
this morning Jeff he I told you a little

00:07:31,590 --> 00:07:35,340
bit about optics in his kina it's

00:07:33,450 --> 00:07:37,770
basically a performance monitoring tool

00:07:35,340 --> 00:07:39,870
for graphical but the story I want to

00:07:37,770 --> 00:07:43,830
tell you here is that we got to build

00:07:39,870 --> 00:07:46,470
this app from zero to 100% production

00:07:43,830 --> 00:07:48,510
ready solely using graph QL so this was

00:07:46,470 --> 00:07:51,950
the first app that we got to design with

00:07:48,510 --> 00:07:55,260
graph fuel graph QL from the beginning

00:07:51,950 --> 00:07:57,330
and using the graphical first approach

00:07:55,260 --> 00:07:59,730
that sashko mentioned the very first

00:07:57,330 --> 00:08:02,610
step that we did to do this was we

00:07:59,730 --> 00:08:05,400
define a schema contract and because

00:08:02,610 --> 00:08:07,320
graph QL schema is so strongly typed and

00:08:05,400 --> 00:08:09,450
that enabled great things for our

00:08:07,320 --> 00:08:14,010
development including it helped us

00:08:09,450 --> 00:08:15,480
parallelize our development but one of

00:08:14,010 --> 00:08:16,860
the interesting things that we came

00:08:15,480 --> 00:08:18,540
across when designing this schema

00:08:16,860 --> 00:08:21,090
contract and taking that as the first

00:08:18,540 --> 00:08:23,580
step as we came across the question of

00:08:21,090 --> 00:08:25,620
who really owns the schema like who do

00:08:23,580 --> 00:08:26,670
we when we designed our schema we

00:08:25,620 --> 00:08:28,500
brought our front-end and our back-end

00:08:26,670 --> 00:08:29,850
team together and we sat in a room for a

00:08:28,500 --> 00:08:32,430
long time and we went over a lot of

00:08:29,850 --> 00:08:34,920
different iterations of our schema but

00:08:32,430 --> 00:08:37,320
we had this conflict that we had to

00:08:34,920 --> 00:08:39,000
resolve internally of does the schema

00:08:37,320 --> 00:08:40,290
get owned by the back-end developers or

00:08:39,000 --> 00:08:41,970
does the schema get owned by the front

00:08:40,290 --> 00:08:43,620
end developers because if you're a

00:08:41,970 --> 00:08:47,190
back-end developer and you're designing

00:08:43,620 --> 00:08:48,690
a generic API you want your API to be

00:08:47,190 --> 00:08:50,280
able to service all sorts of different

00:08:48,690 --> 00:08:52,110
features all sorts of different apps

00:08:50,280 --> 00:08:52,810
with all sorts of different features

00:08:52,110 --> 00:08:54,970
that you might

00:08:52,810 --> 00:08:57,580
no yet and you don't want to overfit

00:08:54,970 --> 00:08:59,800
your schema and API designed to but only

00:08:57,580 --> 00:09:01,180
a specific set of features and the

00:08:59,800 --> 00:09:03,160
previous talk just talked a little bit

00:09:01,180 --> 00:09:05,860
about that actually but if your

00:09:03,160 --> 00:09:08,650
front-end developer like I have you want

00:09:05,860 --> 00:09:10,360
to be able to just query your schema for

00:09:08,650 --> 00:09:13,210
exactly what your components need and

00:09:10,360 --> 00:09:15,100
take those take those values and render

00:09:13,210 --> 00:09:16,690
them initially so you want all your

00:09:15,100 --> 00:09:20,410
computed values to live on the server

00:09:16,690 --> 00:09:23,230
you don't want to have to ever repeat

00:09:20,410 --> 00:09:26,380
computed value computations on separate

00:09:23,230 --> 00:09:27,820
clients that you might have and so this

00:09:26,380 --> 00:09:30,160
is a question that you're going to have

00:09:27,820 --> 00:09:32,620
to address if you do schema first sign

00:09:30,160 --> 00:09:34,570
as well and where we fell on this

00:09:32,620 --> 00:09:36,790
spectrum is somewhere in the middle a

00:09:34,570 --> 00:09:38,620
little bit skewed towards front-end

00:09:36,790 --> 00:09:40,540
schema design because our schema was

00:09:38,620 --> 00:09:42,370
designed specifically for optics but our

00:09:40,540 --> 00:09:44,560
back-end engineer's constantly advocated

00:09:42,370 --> 00:09:47,800
for those previous things so so here in

00:09:44,560 --> 00:09:49,360
the middle um great so once you finish

00:09:47,800 --> 00:09:51,010
designing your schema and you've created

00:09:49,360 --> 00:09:53,140
this contract between the front-end in

00:09:51,010 --> 00:09:54,700
the backend and you're going to want to

00:09:53,140 --> 00:09:56,200
streamline your workflow and you can

00:09:54,700 --> 00:09:58,300
really take advantage of the graphical

00:09:56,200 --> 00:10:01,420
abstraction layer here to decouple your

00:09:58,300 --> 00:10:03,400
development so you might be used to

00:10:01,420 --> 00:10:05,560
seeing a development process that looks

00:10:03,400 --> 00:10:08,110
something like this where initial

00:10:05,560 --> 00:10:11,530
product designs are initial product

00:10:08,110 --> 00:10:13,210
ideas are created and product specs and

00:10:11,530 --> 00:10:14,980
that they're handed off to designers who

00:10:13,210 --> 00:10:16,960
then go and create wireframes and

00:10:14,980 --> 00:10:19,210
mock-ups which are then handed to the

00:10:16,960 --> 00:10:22,810
engineers it's everything happens in a

00:10:19,210 --> 00:10:24,600
series and in reality you end up wanting

00:10:22,810 --> 00:10:26,830
to do this quicker so you get something

00:10:24,600 --> 00:10:28,830
that looks a little bit like this where

00:10:26,830 --> 00:10:32,500
everyone's trying to work together but

00:10:28,830 --> 00:10:34,030
it's all a mess and what you really want

00:10:32,500 --> 00:10:35,740
is something like this where every team

00:10:34,030 --> 00:10:38,350
can work together in parallel happily

00:10:35,740 --> 00:10:41,320
and what we found was that because of

00:10:38,350 --> 00:10:42,820
the strongly-typed schema contract we

00:10:41,320 --> 00:10:44,800
were able to actually basically achieve

00:10:42,820 --> 00:10:46,420
this while working on optics because our

00:10:44,800 --> 00:10:48,160
back-end had a spec to work too as soon

00:10:46,420 --> 00:10:50,110
as we finished our initial schema design

00:10:48,160 --> 00:10:54,610
and our front-end knew exactly what data

00:10:50,110 --> 00:10:56,320
to expect and so as a front-end engineer

00:10:54,610 --> 00:10:57,970
have more perspective on the front-end

00:10:56,320 --> 00:10:59,569
side but if you are going to start

00:10:57,970 --> 00:11:01,129
building enough in

00:10:59,569 --> 00:11:03,889
whether you don't have a back-end yet

00:11:01,129 --> 00:11:05,480
the first thing you need to do is Moxon

00:11:03,889 --> 00:11:08,569
data before you can even start building

00:11:05,480 --> 00:11:11,300
any components and if you are used to

00:11:08,569 --> 00:11:12,920
building restful applications or if your

00:11:11,300 --> 00:11:15,079
application is restful and you've had to

00:11:12,920 --> 00:11:16,670
mock data for it usually what that's

00:11:15,079 --> 00:11:18,709
ended up being is your mock your data

00:11:16,670 --> 00:11:21,499
per endpoint but what ends up happening

00:11:18,709 --> 00:11:24,470
is if you change any line in your

00:11:21,499 --> 00:11:25,939
database you then need to go and rewrite

00:11:24,470 --> 00:11:28,370
all the different mocks that you've

00:11:25,939 --> 00:11:31,370
created for the different queries or

00:11:28,370 --> 00:11:32,899
endpoints you have to go and rewrite all

00:11:31,370 --> 00:11:34,189
the different marks that you've created

00:11:32,899 --> 00:11:36,980
for all the different endpoints that

00:11:34,189 --> 00:11:38,720
might use that field in the database and

00:11:36,980 --> 00:11:40,939
what we think is really cool about graph

00:11:38,720 --> 00:11:43,309
QL marking is it doesn't happen on a per

00:11:40,939 --> 00:11:46,579
endpoint standpoint but rather it

00:11:43,309 --> 00:11:48,680
happens on a per resolver basis and so

00:11:46,579 --> 00:11:50,569
if you decide to change something about

00:11:48,680 --> 00:11:52,730
how your schema works like you decide to

00:11:50,569 --> 00:11:54,740
change a field to remove it to add

00:11:52,730 --> 00:11:56,569
something it's really simple all you

00:11:54,740 --> 00:11:58,249
have to do is update one resolver while

00:11:56,569 --> 00:12:02,329
you're mocking your data it turns out to

00:11:58,249 --> 00:12:04,699
be much more easy and so at MDG when we

00:12:02,329 --> 00:12:07,069
were building optics we did component

00:12:04,699 --> 00:12:08,120
first development and what that means is

00:12:07,069 --> 00:12:11,179
you start from the smallest components

00:12:08,120 --> 00:12:13,040
and you use mocking tools and component

00:12:11,179 --> 00:12:14,839
building tools to create components one

00:12:13,040 --> 00:12:16,939
at a time and then eventually build up

00:12:14,839 --> 00:12:18,110
to larger layouts and this is how we

00:12:16,939 --> 00:12:24,350
developed optics

00:12:18,110 --> 00:12:26,540
so transition optics mm-hmm and briefly

00:12:24,350 --> 00:12:28,100
I just wanted to show you we developed

00:12:26,540 --> 00:12:29,749
each component individually so this is

00:12:28,100 --> 00:12:31,189
actually all data that we were able to

00:12:29,749 --> 00:12:33,350
mock using tools that our open source

00:12:31,189 --> 00:12:35,389
team made and we brought these all

00:12:33,350 --> 00:12:38,449
together to create our final product at

00:12:35,389 --> 00:12:39,800
the end at the flip of a switch in our

00:12:38,449 --> 00:12:42,769
experience with using this graphic

00:12:39,800 --> 00:12:44,089
you'll first approach well I just wanted

00:12:42,769 --> 00:12:47,120
to tell you the three good things out of

00:12:44,089 --> 00:12:49,939
it we were painlessly painlessly adapted

00:12:47,120 --> 00:12:51,679
to schema changes we were able to

00:12:49,939 --> 00:12:53,629
connect our back-end to our front-end in

00:12:51,679 --> 00:12:56,179
less than two days after developing them

00:12:53,629 --> 00:12:58,670
separately for weeks and we were able to

00:12:56,179 --> 00:13:00,800
develop the entire optics at production

00:12:58,670 --> 00:13:02,660
ready in less than three months which we

00:13:00,800 --> 00:13:04,790
think is very impressive and I will hand

00:13:02,660 --> 00:13:06,379
it back to sashka to talk about the open

00:13:04,790 --> 00:13:08,870
source tools that enabled us to do so

00:13:06,379 --> 00:13:10,309
yeah so like I said it took us a while

00:13:08,870 --> 00:13:11,420
to connect all the pieces but we

00:13:10,309 --> 00:13:12,170
realized what we're really doing is

00:13:11,420 --> 00:13:14,620
building tools

00:13:12,170 --> 00:13:16,970
enable this graphical first workflow and

00:13:14,620 --> 00:13:18,350
aptly named one of the first tools we

00:13:16,970 --> 00:13:21,350
developed was called graph tool tools

00:13:18,350 --> 00:13:24,649
and this is an open-source package you

00:13:21,350 --> 00:13:26,029
can get on github on NPM lets you use

00:13:24,649 --> 00:13:28,190
that wonderful graphical schema language

00:13:26,029 --> 00:13:30,529
we talked about and use it to actually

00:13:28,190 --> 00:13:31,880
implement your graphical server so you

00:13:30,529 --> 00:13:33,920
can see there's a very short code

00:13:31,880 --> 00:13:35,060
snippet here but these several lines of

00:13:33,920 --> 00:13:36,800
code are the only thing you need to do

00:13:35,060 --> 00:13:38,720
to actually create a working graph QL

00:13:36,800 --> 00:13:41,269
schema using the graphical tools package

00:13:38,720 --> 00:13:43,850
so you see here we just define a couple

00:13:41,269 --> 00:13:45,560
of objects for our back-end we use the

00:13:43,850 --> 00:13:46,730
graphical schema language to do the type

00:13:45,560 --> 00:13:48,740
definitions and then the only thing

00:13:46,730 --> 00:13:50,149
that's left to fill in are the resolvers

00:13:48,740 --> 00:13:51,860
in this case one resolver to return our

00:13:50,149 --> 00:13:53,630
array of data and then this make

00:13:51,860 --> 00:13:55,459
executive well schema function that's

00:13:53,630 --> 00:13:56,570
exported by graphic you'll tools is the

00:13:55,459 --> 00:13:58,579
thing that puts it all together into a

00:13:56,570 --> 00:14:00,560
working graphical schema that you didn't

00:13:58,579 --> 00:14:02,690
have to write any of those sometimes

00:14:00,560 --> 00:14:05,870
large graphical j/s objects that you can

00:14:02,690 --> 00:14:07,160
import from that package and I just want

00:14:05,870 --> 00:14:08,329
to mention you know to start with it's

00:14:07,160 --> 00:14:09,649
that none of the stuff would have been

00:14:08,329 --> 00:14:11,000
possible without all the awesome

00:14:09,649 --> 00:14:12,529
open-source community that we've been

00:14:11,000 --> 00:14:13,910
working with there been a whole bunch of

00:14:12,529 --> 00:14:15,440
great people continuing to these

00:14:13,910 --> 00:14:17,180
packages finding out new ways to use

00:14:15,440 --> 00:14:19,250
them and we'll get to that a little bit

00:14:17,180 --> 00:14:21,170
later the other really cool feature of

00:14:19,250 --> 00:14:23,959
graphical tools as you just heard about

00:14:21,170 --> 00:14:26,060
is mocking so you know if you can

00:14:23,959 --> 00:14:28,130
implement a graphical server by just

00:14:26,060 --> 00:14:28,970
using the schema language well what if

00:14:28,130 --> 00:14:30,500
you could just skip the whole

00:14:28,970 --> 00:14:33,380
implementation part entirely and just

00:14:30,500 --> 00:14:36,560
have a fake back-end and so at a most

00:14:33,380 --> 00:14:38,089
basic level the mock functions feature

00:14:36,560 --> 00:14:39,680
of graphical tools enables you to do

00:14:38,089 --> 00:14:41,000
this because graph kill strongly typed

00:14:39,680 --> 00:14:41,540
and you know which type each field is

00:14:41,000 --> 00:14:43,250
returning

00:14:41,540 --> 00:14:45,529
you basically have to write very little

00:14:43,250 --> 00:14:47,110
code to actually mock that data so this

00:14:45,529 --> 00:14:49,790
is a really simple case where you just

00:14:47,110 --> 00:14:52,070
call add mock functions to schema with

00:14:49,790 --> 00:14:53,779
no extra options and you can see it just

00:14:52,070 --> 00:14:56,060
returns hello world for every string in

00:14:53,779 --> 00:14:57,800
your query which makes sense for a start

00:14:56,060 --> 00:14:59,060
but you can then incrementally customize

00:14:57,800 --> 00:15:01,160
it you can go to our Doc's and check it

00:14:59,060 --> 00:15:02,870
out to return different types of data

00:15:01,160 --> 00:15:04,730
for different types in your back-end

00:15:02,870 --> 00:15:06,560
schema and so we thought that was really

00:15:04,730 --> 00:15:07,790
cool thing and we used that for both of

00:15:06,560 --> 00:15:09,589
our apps while we were developing

00:15:07,790 --> 00:15:12,410
component first and mocking out the

00:15:09,589 --> 00:15:14,510
backend and so I wanted to focus on some

00:15:12,410 --> 00:15:17,269
other ways that people have you know

00:15:14,510 --> 00:15:19,220
came up with to use this package so Nick

00:15:17,269 --> 00:15:21,500
Nance is over here right in front of me

00:15:19,220 --> 00:15:24,380
is he gave a great talk at one of our

00:15:21,500 --> 00:15:25,390
San Francisco meetups about how to use

00:15:24,380 --> 00:15:28,090
this schema for

00:15:25,390 --> 00:15:30,100
approach of having the graphical schema

00:15:28,090 --> 00:15:31,570
materialized as a string lets you easily

00:15:30,100 --> 00:15:33,220
load that schema without running any

00:15:31,570 --> 00:15:34,810
code it lets you easily detect breaking

00:15:33,220 --> 00:15:36,310
changes and review changes that schema

00:15:34,810 --> 00:15:38,230
like you've heard in previous talks as

00:15:36,310 --> 00:15:39,310
well so that was really cool and it was

00:15:38,230 --> 00:15:40,540
really awesome to see people in the

00:15:39,310 --> 00:15:42,580
community like I mentioned come together

00:15:40,540 --> 00:15:44,080
to develop new features for that mocking

00:15:42,580 --> 00:15:45,850
for example in this case something that

00:15:44,080 --> 00:15:47,230
would automatically select one of the

00:15:45,850 --> 00:15:49,180
available types from a union or

00:15:47,230 --> 00:15:50,320
interface for that mock so we're excited

00:15:49,180 --> 00:15:52,720
to see where this stuff goes in the

00:15:50,320 --> 00:15:53,890
future okay so now that you've

00:15:52,720 --> 00:15:55,810
implemented your back-end

00:15:53,890 --> 00:15:56,980
you've implemented a schema and you made

00:15:55,810 --> 00:15:58,960
you mock some stuff out you need to

00:15:56,980 --> 00:16:01,140
actually connect that data to your UI

00:15:58,960 --> 00:16:04,180
and get that out of the back end and

00:16:01,140 --> 00:16:06,040
graph dual queries are the wonderful

00:16:04,180 --> 00:16:07,990
feature in graph QL you know that we all

00:16:06,040 --> 00:16:10,900
know love that lets you do that which is

00:16:07,990 --> 00:16:12,190
the second thing after the schema so you

00:16:10,900 --> 00:16:13,300
know just going into a really short

00:16:12,190 --> 00:16:14,860
amount of background on the graphic

00:16:13,300 --> 00:16:17,140
you'll clients or different approaches

00:16:14,860 --> 00:16:18,610
to graphical clients the simplest thing

00:16:17,140 --> 00:16:22,420
you can do with graph QL is you can just

00:16:18,610 --> 00:16:24,760
send a regular HTTP fetch get request so

00:16:22,420 --> 00:16:26,860
very simple very easy to understand the

00:16:24,760 --> 00:16:28,420
problem is as your UI gets larger you

00:16:26,860 --> 00:16:30,880
might run into some consistency issues

00:16:28,420 --> 00:16:32,110
you might end up loading data more often

00:16:30,880 --> 00:16:34,480
than you actually need to so you might

00:16:32,110 --> 00:16:36,580
want the client that does some caching

00:16:34,480 --> 00:16:38,080
so well it takes a little bit of effort

00:16:36,580 --> 00:16:40,570
to learn how to use that client it's not

00:16:38,080 --> 00:16:42,310
as simple as just sending a request

00:16:40,570 --> 00:16:44,350
it's then really easy to update your UI

00:16:42,310 --> 00:16:46,450
after you do some mutations or use graph

00:16:44,350 --> 00:16:47,800
kill subscriptions you can manage all of

00:16:46,450 --> 00:16:49,210
your data in one place and track the

00:16:47,800 --> 00:16:51,010
data flow very easily like you're used

00:16:49,210 --> 00:16:52,360
to with redux for example and you have

00:16:51,010 --> 00:16:53,620
great developer tools that integrate

00:16:52,360 --> 00:16:54,820
with these clients to help you

00:16:53,620 --> 00:16:57,250
understand what is going on in your app

00:16:54,820 --> 00:16:59,440
and so I want to go into you know on the

00:16:57,250 --> 00:17:01,240
Apollo team what was important for us

00:16:59,440 --> 00:17:04,209
when working on a client that would

00:17:01,240 --> 00:17:05,770
enable ourselves and everyone else to

00:17:04,209 --> 00:17:07,920
take this graph kill first approach to

00:17:05,770 --> 00:17:09,730
development so some of the things we

00:17:07,920 --> 00:17:11,800
identified that were really important to

00:17:09,730 --> 00:17:14,260
us were that it was compatible with a

00:17:11,800 --> 00:17:15,339
whole host of technologies so like we

00:17:14,260 --> 00:17:16,540
said it's really important to us that

00:17:15,339 --> 00:17:18,400
people can start converting their

00:17:16,540 --> 00:17:20,350
existing API to graph QL incrementally

00:17:18,400 --> 00:17:21,610
like what we had to do and that means

00:17:20,350 --> 00:17:23,560
that you don't always get to make all

00:17:21,610 --> 00:17:25,480
the decisions for your client or server

00:17:23,560 --> 00:17:26,740
side architecture and so it's important

00:17:25,480 --> 00:17:27,579
like if you're using V ducts and you're

00:17:26,740 --> 00:17:28,930
using that to manage all your

00:17:27,579 --> 00:17:30,610
client-side data

00:17:28,930 --> 00:17:32,230
well actually I'm curious how many of

00:17:30,610 --> 00:17:34,720
you today are using Redux and some of

00:17:32,230 --> 00:17:36,220
your apps Wow

00:17:34,720 --> 00:17:38,349
yeah that's maybe like a third of the

00:17:36,220 --> 00:17:39,729
people here which is which is exciting

00:17:38,349 --> 00:17:41,049
but if you're using something like Redux

00:17:39,729 --> 00:17:43,330
you don't want to throw that all away

00:17:41,049 --> 00:17:45,519
and lose all the benefits just because

00:17:43,330 --> 00:17:47,289
you're trying to use graph QL and same

00:17:45,519 --> 00:17:48,369
for the backend some backends have

00:17:47,289 --> 00:17:50,979
different ways of doing stuff like

00:17:48,369 --> 00:17:52,269
pagination or you know identifying

00:17:50,979 --> 00:17:54,159
objects and so we wanted to make sure

00:17:52,269 --> 00:17:55,509
that your client didn't require you to

00:17:54,159 --> 00:17:56,950
use a certain approach to a schema and

00:17:55,509 --> 00:17:58,599
the last thing was really need to make

00:17:56,950 --> 00:18:00,909
sure that we could enable a component

00:17:58,599 --> 00:18:02,169
first design approach not just for

00:18:00,909 --> 00:18:03,669
designing the components but then for

00:18:02,169 --> 00:18:05,859
incorporating it into your UI so you

00:18:03,669 --> 00:18:07,989
could start with just one component on

00:18:05,859 --> 00:18:09,669
your page or two and incremental move

00:18:07,989 --> 00:18:12,159
your entire app to graph QL so you could

00:18:09,669 --> 00:18:13,839
get all those benefits so this is just

00:18:12,159 --> 00:18:15,219
about making it easy to get started with

00:18:13,839 --> 00:18:17,409
graphical and use it in your app whether

00:18:15,219 --> 00:18:19,539
it's new or incremental and the other

00:18:17,409 --> 00:18:21,099
thing is as you've heard in great detail

00:18:19,539 --> 00:18:23,259
from Joseph's own Anna's talk earlier

00:18:21,099 --> 00:18:25,779
today it's very important to be able to

00:18:23,259 --> 00:18:26,859
have your queries be static then what do

00:18:25,779 --> 00:18:29,139
static queries really mean

00:18:26,859 --> 00:18:31,869
so it was diagram that I'm really proud

00:18:29,139 --> 00:18:33,429
of here but basically the idea is you

00:18:31,869 --> 00:18:35,049
should be able to take all of your data

00:18:33,429 --> 00:18:36,279
requirements of your application and

00:18:35,049 --> 00:18:37,479
without actually running your

00:18:36,279 --> 00:18:40,089
application code you need to be able to

00:18:37,479 --> 00:18:41,950
pull them apart so that regardless of

00:18:40,089 --> 00:18:43,929
what module system you're using

00:18:41,950 --> 00:18:45,700
what like version of JavaScript you

00:18:43,929 --> 00:18:47,139
might be using you can identify all the

00:18:45,700 --> 00:18:49,210
queries in your your I super easily and

00:18:47,139 --> 00:18:50,859
then you can predict what queries will

00:18:49,210 --> 00:18:52,330
be sent to the server you can analyze

00:18:50,859 --> 00:18:54,279
all the data requirements and validate

00:18:52,330 --> 00:18:55,779
them at Build time and you can notify

00:18:54,279 --> 00:18:58,179
the server about what queries it should

00:18:55,779 --> 00:18:59,469
expect to receive via this mechanism of

00:18:58,179 --> 00:19:01,330
persisted queries that has been talked

00:18:59,469 --> 00:19:02,889
about a lot so that your server only

00:19:01,330 --> 00:19:04,690
accepts the queries that your client is

00:19:02,889 --> 00:19:07,029
intending to send which can also help

00:19:04,690 --> 00:19:10,509
with stuff like performance security etc

00:19:07,029 --> 00:19:12,039
so that was really important to us and

00:19:10,509 --> 00:19:14,109
the other really cool thing you get when

00:19:12,039 --> 00:19:15,549
you're focusing on how to get the most

00:19:14,109 --> 00:19:17,950
advantage out of graph cold queries is

00:19:15,549 --> 00:19:20,559
we can combine the strongly typed nature

00:19:17,950 --> 00:19:22,509
of the graphical schema and the great

00:19:20,559 --> 00:19:24,519
structure of graphical queries to get

00:19:22,509 --> 00:19:26,379
code generation for the result types in

00:19:24,519 --> 00:19:28,450
your app so you've also heard about this

00:19:26,379 --> 00:19:30,609
a little bit in other presentations but

00:19:28,450 --> 00:19:32,440
today we have a package called Apollo

00:19:30,609 --> 00:19:34,179
iOS which has a really great integration

00:19:32,440 --> 00:19:36,580
with Xcode for example so you can have

00:19:34,179 --> 00:19:39,190
your graph Joule query open on one side

00:19:36,580 --> 00:19:41,109
of your Xcode window and you can have

00:19:39,190 --> 00:19:43,389
your Swift code open on the other side

00:19:41,109 --> 00:19:45,009
you can make a change to your graph kill

00:19:43,389 --> 00:19:47,169
fragment and then immediately after

00:19:45,009 --> 00:19:48,519
rebuild start typing and get Auto

00:19:47,169 --> 00:19:50,919
completion on the other side and Swift

00:19:48,519 --> 00:19:51,580
and so it's really cool because even

00:19:50,919 --> 00:19:53,860
though you're not

00:19:51,580 --> 00:19:56,499
typing your query in in actual Swift

00:19:53,860 --> 00:19:57,940
language the developer tools make it so

00:19:56,499 --> 00:19:59,649
that we can share this graph jewel query

00:19:57,940 --> 00:20:02,649
language everywhere while still getting

00:19:59,649 --> 00:20:04,110
the same advantages of native native

00:20:02,649 --> 00:20:06,279
tooling for that particular environment

00:20:04,110 --> 00:20:07,960
and so there's great people in the

00:20:06,279 --> 00:20:10,029
community already working on typescript

00:20:07,960 --> 00:20:11,769
and flow code generation for query

00:20:10,029 --> 00:20:14,619
results so that's really cool if you go

00:20:11,769 --> 00:20:16,450
to the Apollo code gen repository I've

00:20:14,619 --> 00:20:18,100
listed here you'll see Robyn Ricard

00:20:16,450 --> 00:20:20,289
working on it a really great guy I've

00:20:18,100 --> 00:20:21,549
been contributing tons of stuff but we

00:20:20,289 --> 00:20:24,009
hope to eventually have support for all

00:20:21,549 --> 00:20:26,679
kinds of languages like Java for example

00:20:24,009 --> 00:20:30,159
or Objective C so please check that out

00:20:26,679 --> 00:20:31,330
and so building on all this stuff that

00:20:30,159 --> 00:20:32,710
I've been talking about today and all

00:20:31,330 --> 00:20:35,080
the best practices that you guys have

00:20:32,710 --> 00:20:36,909
heard about with graphical clients we're

00:20:35,080 --> 00:20:39,190
really excited that we've released a new

00:20:36,909 --> 00:20:40,720
version of Apollo client yesterday we're

00:20:39,190 --> 00:20:42,429
working really hard to get something

00:20:40,720 --> 00:20:44,619
that we thought really embodied all of

00:20:42,429 --> 00:20:45,820
these concepts so you can go to the

00:20:44,619 --> 00:20:47,739
website and check out all the features

00:20:45,820 --> 00:20:49,570
in detail there's code snippets on there

00:20:47,739 --> 00:20:51,309
about how easy it is to get started with

00:20:49,570 --> 00:20:54,489
this and then do more powerful stuff

00:20:51,309 --> 00:20:56,830
with it at dev holiday comm it took over

00:20:54,489 --> 00:20:58,359
a hundred contributors many months to

00:20:56,830 --> 00:20:59,619
get to this point in Apollo client

00:20:58,359 --> 00:21:01,450
development whether that's working on

00:20:59,619 --> 00:21:04,299
documentation or integrations for

00:21:01,450 --> 00:21:05,889
various UI frameworks or building better

00:21:04,299 --> 00:21:08,649
caching and we're excited to keep

00:21:05,889 --> 00:21:10,179
working on that and so what does Apollo

00:21:08,649 --> 00:21:12,159
client all about well it's about all the

00:21:10,179 --> 00:21:14,769
things I just talked about it's about

00:21:12,159 --> 00:21:16,570
being 100% compatible with graph QL so

00:21:14,769 --> 00:21:18,159
if you can type it in graphical you can

00:21:16,570 --> 00:21:19,179
type it into your UI code it's about

00:21:18,159 --> 00:21:20,769
having all the features that you expect

00:21:19,179 --> 00:21:23,109
from a data management system like

00:21:20,769 --> 00:21:24,999
queries mutations fragment pool location

00:21:23,109 --> 00:21:26,529
pagination and everything else it's

00:21:24,999 --> 00:21:28,840
about being really friendly to developer

00:21:26,529 --> 00:21:30,340
tools so both static queries so that you

00:21:28,840 --> 00:21:32,139
can analyze your data requirements ahead

00:21:30,340 --> 00:21:34,149
of time but also something like Redux

00:21:32,139 --> 00:21:36,580
dev tools so you can see how your data

00:21:34,149 --> 00:21:39,220
is changing on your client in your in

00:21:36,580 --> 00:21:41,859
your chrome window it's compatible with

00:21:39,220 --> 00:21:43,179
basically every popular view layer out

00:21:41,859 --> 00:21:45,070
there and because the communities

00:21:43,179 --> 00:21:46,720
building more integrations all the time

00:21:45,070 --> 00:21:49,029
and it's something that can grow with

00:21:46,720 --> 00:21:50,580
the needs of your app so as you discover

00:21:49,029 --> 00:21:52,600
new requirements for your graph QL

00:21:50,580 --> 00:21:54,369
client or server or something like that

00:21:52,600 --> 00:21:55,779
you can always make Apollo client work

00:21:54,369 --> 00:21:57,489
with it because it has tons of different

00:21:55,779 --> 00:22:00,100
extension points that let you build a

00:21:57,489 --> 00:22:02,200
graphical client that you want and the

00:22:00,100 --> 00:22:03,700
really cool thing is we've gotten to the

00:22:02,200 --> 00:22:05,020
point where you understand a lot of

00:22:03,700 --> 00:22:06,220
these different best practices for

00:22:05,020 --> 00:22:08,470
after all and how you can connect that

00:22:06,220 --> 00:22:10,060
to your UI and so we can move into the

00:22:08,470 --> 00:22:12,490
future and two features that I'm really

00:22:10,060 --> 00:22:14,500
excited about in 0.5 are graphical

00:22:12,490 --> 00:22:16,030
subscriptions which are the first step

00:22:14,500 --> 00:22:18,280
towards having real time data and graph

00:22:16,030 --> 00:22:20,020
QL apps and we're really excited to work

00:22:18,280 --> 00:22:22,420
with people like the author of sangria

00:22:20,020 --> 00:22:24,130
to get subscriptions on the server the

00:22:22,420 --> 00:22:25,480
people at scaffold and graph cools to

00:22:24,130 --> 00:22:27,940
get subscriptions and serve back into

00:22:25,480 --> 00:22:29,710
the service implementations so that you

00:22:27,940 --> 00:22:31,150
can connect to a graph dual server and

00:22:29,710 --> 00:22:33,100
expect the subscriptions will just work

00:22:31,150 --> 00:22:34,930
rather than having it be something that

00:22:33,100 --> 00:22:37,150
feels more like an experiment and the

00:22:34,930 --> 00:22:39,160
other cool thing that personally I'm

00:22:37,150 --> 00:22:40,600
really excited about is this thing we're

00:22:39,160 --> 00:22:42,730
calling customers Alvers which let you

00:22:40,600 --> 00:22:44,290
extend your scheme on the client by

00:22:42,730 --> 00:22:46,030
writing resolver functions directly in

00:22:44,290 --> 00:22:48,070
your UI code that will let you do stuff

00:22:46,030 --> 00:22:49,360
like tell your cache that it might be

00:22:48,070 --> 00:22:51,010
able to find some data in a different

00:22:49,360 --> 00:22:52,420
place than where expected or maybe you

00:22:51,010 --> 00:22:54,550
do computed fields in the client or

00:22:52,420 --> 00:22:55,510
something of that nature like you might

00:22:54,550 --> 00:22:57,520
have heard there might be a tension

00:22:55,510 --> 00:22:58,540
between what your server-side the fields

00:22:57,520 --> 00:22:59,320
are and what you actually wanted to

00:22:58,540 --> 00:23:03,040
client so you should be able to

00:22:59,320 --> 00:23:05,110
implement that on top of that schema so

00:23:03,040 --> 00:23:07,120
just to you know wrap up some

00:23:05,110 --> 00:23:09,310
conclusions I think it's a good idea to

00:23:07,120 --> 00:23:10,510
in a production app use a caching draft

00:23:09,310 --> 00:23:12,070
field client that gives you some UI

00:23:10,510 --> 00:23:13,750
consistency and lets you avoid loading

00:23:12,070 --> 00:23:15,460
day you already have I think it's very

00:23:13,750 --> 00:23:17,830
important to think about incremental

00:23:15,460 --> 00:23:19,750
adoption and compatibility because you

00:23:17,830 --> 00:23:22,210
might have to work with existing apps

00:23:19,750 --> 00:23:23,800
that you built before graph QL or maybe

00:23:22,210 --> 00:23:25,840
your technology choices might change in

00:23:23,800 --> 00:23:28,300
the future and it's super critical to

00:23:25,840 --> 00:23:29,620
have something that supports static

00:23:28,300 --> 00:23:31,540
queries that you can analyze to have

00:23:29,620 --> 00:23:35,290
better performance developer tools and

00:23:31,540 --> 00:23:38,140
server insights so now that you've you

00:23:35,290 --> 00:23:40,270
know designed your schema mock your data

00:23:38,140 --> 00:23:41,500
bill your UI with a component first

00:23:40,270 --> 00:23:43,780
approach using all these graphical

00:23:41,500 --> 00:23:45,880
queries the next step is finding out

00:23:43,780 --> 00:23:48,190
what benefits can we get from graph QL

00:23:45,880 --> 00:23:50,980
while running in production and so back

00:23:48,190 --> 00:23:52,990
to Danielle for that yeah and so can I

00:23:50,980 --> 00:23:55,450
see a quick show of hands of who has a

00:23:52,990 --> 00:23:56,530
performance a higher production product

00:23:55,450 --> 00:24:00,190
that you've instrumented with a

00:23:56,530 --> 00:24:01,720
performance monitoring tool yeah so I

00:24:00,190 --> 00:24:05,260
hope that that is most people with

00:24:01,720 --> 00:24:06,670
production products um so I mean so

00:24:05,260 --> 00:24:08,200
performance monitoring is extremely

00:24:06,670 --> 00:24:10,570
important with any production product

00:24:08,200 --> 00:24:12,570
because you need to be able to maintain

00:24:10,570 --> 00:24:15,190
reliability you need to be able to

00:24:12,570 --> 00:24:18,130
monitor when you deploy a large change

00:24:15,190 --> 00:24:21,790
deploy a large change or when your

00:24:18,130 --> 00:24:23,440
customer number grows and scales and if

00:24:21,790 --> 00:24:25,480
you've instrumented any performance

00:24:23,440 --> 00:24:27,460
monitoring tools in a restful app that

00:24:25,480 --> 00:24:30,370
you might have you might be used to

00:24:27,460 --> 00:24:32,650
measuring things such as how many times

00:24:30,370 --> 00:24:36,250
does this rest endpoint get calls by

00:24:32,650 --> 00:24:37,840
which clients or how long does my client

00:24:36,250 --> 00:24:39,610
have to wait to get some response from

00:24:37,840 --> 00:24:42,490
this rest endpoint and to get the JSON

00:24:39,610 --> 00:24:45,220
blob back or potentially even how does

00:24:42,490 --> 00:24:47,920
my server CPU load change over time

00:24:45,220 --> 00:24:49,990
maybe per time of day or you can monitor

00:24:47,920 --> 00:24:51,310
this during specific deploys like

00:24:49,990 --> 00:24:54,370
there's a whole bunch of things that

00:24:51,310 --> 00:24:55,690
you're probably used to using or used to

00:24:54,370 --> 00:24:59,020
measuring with any performance

00:24:55,690 --> 00:25:01,900
monitoring tool well one of our favorite

00:24:59,020 --> 00:25:03,610
things about graph QL is that um because

00:25:01,900 --> 00:25:05,800
it's so much more transparent as a data

00:25:03,610 --> 00:25:07,720
layer than things that existed before it

00:25:05,800 --> 00:25:09,160
actually enables you to ask a bunch of

00:25:07,720 --> 00:25:12,340
questions that you've never been able to

00:25:09,160 --> 00:25:15,070
ask before and one of these questions is

00:25:12,340 --> 00:25:18,010
for example exactly which fields in

00:25:15,070 --> 00:25:20,020
which queries are being requested and so

00:25:18,010 --> 00:25:22,510
with this you can ask questions such as

00:25:20,020 --> 00:25:24,580
do I have unused fields maybe that miss

00:25:22,510 --> 00:25:26,800
that my server is giving that my clients

00:25:24,580 --> 00:25:28,690
aren't taking or what exactly are my

00:25:26,800 --> 00:25:30,190
clients asking for like maybe I can make

00:25:28,690 --> 00:25:32,920
this feels more performant because I

00:25:30,190 --> 00:25:34,390
know they're more popular another thing

00:25:32,920 --> 00:25:35,740
you can do is you can measure fueled

00:25:34,390 --> 00:25:37,210
resolve our performance which you

00:25:35,740 --> 00:25:39,640
weren't able to do before and so

00:25:37,210 --> 00:25:41,610
questions you can ask here or do I have

00:25:39,640 --> 00:25:45,370
performance hotspots at the field level

00:25:41,610 --> 00:25:46,900
and we actually did measure these things

00:25:45,370 --> 00:25:48,580
in galaxy that was one of the first

00:25:46,900 --> 00:25:51,640
things we did and in the next slide I'll

00:25:48,580 --> 00:25:53,800
I'll show you a cool demo of how we

00:25:51,640 --> 00:25:56,650
manage to make galaxy performance better

00:25:53,800 --> 00:25:58,390
by doing this another thing you can do

00:25:56,650 --> 00:26:00,970
is you can set you can detect breaking

00:25:58,390 --> 00:26:03,040
schema changes and so you can detect

00:26:00,970 --> 00:26:05,320
build failures and stuff for example

00:26:03,040 --> 00:26:07,450
because you define this schema so maybe

00:26:05,320 --> 00:26:09,040
you change something in your schema and

00:26:07,450 --> 00:26:10,780
you push it and you have a travesty I

00:26:09,040 --> 00:26:13,030
integration that automatically detects

00:26:10,780 --> 00:26:14,500
build failures because it knows that you

00:26:13,030 --> 00:26:15,820
have clients on the front end who are

00:26:14,500 --> 00:26:18,460
making queries that will no long

00:26:15,820 --> 00:26:22,180
work or you can detect back in changes

00:26:18,460 --> 00:26:23,890
um sorry yes it knows that you have

00:26:22,180 --> 00:26:25,150
clients on the front end that might try

00:26:23,890 --> 00:26:26,830
to make a career that no longer works

00:26:25,150 --> 00:26:28,720
there's a whole plethora of questions

00:26:26,830 --> 00:26:31,330
that you can ask this is just a tip of

00:26:28,720 --> 00:26:32,980
the iceberg and so I wanted to give you

00:26:31,330 --> 00:26:35,310
guys an example of how we instrumented

00:26:32,980 --> 00:26:37,900
some performance monitoring in galaxies

00:26:35,310 --> 00:26:39,370
so don't worry too much about the tiny

00:26:37,900 --> 00:26:41,500
text here basically what you're looking

00:26:39,370 --> 00:26:43,930
at is a fields resolve our trace view

00:26:41,500 --> 00:26:46,150
and so what you're seeing here is the

00:26:43,930 --> 00:26:47,500
resolver timing for a specific query

00:26:46,150 --> 00:26:49,600
that we were making in galaxy it's

00:26:47,500 --> 00:26:51,460
actually the query that fed that data

00:26:49,600 --> 00:26:54,040
intensive containers page the first time

00:26:51,460 --> 00:26:55,540
we tried to switch to graph QL and for

00:26:54,040 --> 00:26:57,340
every repeated pattern here you can

00:26:55,540 --> 00:27:00,640
basically see that we were making

00:26:57,340 --> 00:27:01,900
queries in series and we looked at this

00:27:00,640 --> 00:27:03,100
in the first thing we thought was man

00:27:01,900 --> 00:27:05,650
that's really inefficient

00:27:03,100 --> 00:27:07,660
let's try realize that and so that's

00:27:05,650 --> 00:27:09,190
exactly what we did and so you can see

00:27:07,660 --> 00:27:11,080
the repeated patterns again but now

00:27:09,190 --> 00:27:12,670
they're all happening in parallel and we

00:27:11,080 --> 00:27:15,040
were able to improve the performance of

00:27:12,670 --> 00:27:16,570
this query from 500 milliseconds to 300

00:27:15,040 --> 00:27:19,570
milliseconds simply because we

00:27:16,570 --> 00:27:22,060
instrumented a monitoring tool and so

00:27:19,570 --> 00:27:23,860
that's the whole idea behind optics the

00:27:22,060 --> 00:27:26,080
product that was announced this morning

00:27:23,860 --> 00:27:28,330
is that you can do such things and

00:27:26,080 --> 00:27:29,950
answer such questions with graph QL that

00:27:28,330 --> 00:27:31,210
you weren't able to answer before or

00:27:29,950 --> 00:27:33,060
that you're not able to answer with

00:27:31,210 --> 00:27:35,230
existing performance monitoring tools

00:27:33,060 --> 00:27:36,700
and so if you guys are interested in

00:27:35,230 --> 00:27:39,010
learning any more about optics we have a

00:27:36,700 --> 00:27:42,010
great page up now Apollo datacom slash

00:27:39,010 --> 00:27:44,080
optics and just to give you a quick

00:27:42,010 --> 00:27:45,940
overview of the things it does it can

00:27:44,080 --> 00:27:46,150
show you execution traces it can show

00:27:45,940 --> 00:27:48,910
you

00:27:46,150 --> 00:27:51,910
latency duration for different fields in

00:27:48,910 --> 00:27:54,220
in your schema and it can also also show

00:27:51,910 --> 00:27:56,650
you how much field usage each field in

00:27:54,220 --> 00:27:59,110
your schema gets and there are many many

00:27:56,650 --> 00:28:02,860
more things to come so I'll hand it back

00:27:59,110 --> 00:28:04,330
to sashko to conclude yep so calling

00:28:02,860 --> 00:28:06,760
back to the slide we had with the three

00:28:04,330 --> 00:28:08,560
columns this is basically all the steps

00:28:06,760 --> 00:28:10,660
that we've identified so far in our

00:28:08,560 --> 00:28:12,280
graphic you'll first journey first step

00:28:10,660 --> 00:28:13,180
was coming together design our schema

00:28:12,280 --> 00:28:16,030
with some of the different trade-offs

00:28:13,180 --> 00:28:18,190
between front and back end concerns the

00:28:16,030 --> 00:28:19,900
next step was implementing our UI and

00:28:18,190 --> 00:28:20,890
our back-end in parallel and there were

00:28:19,900 --> 00:28:23,020
definitely a lot of things we learned

00:28:20,890 --> 00:28:24,460
about implementing components when

00:28:23,020 --> 00:28:27,670
graphical and how to use mocking there

00:28:24,460 --> 00:28:29,440
and then the last step was asking

00:28:27,670 --> 00:28:31,389
questions about our server that we

00:28:29,440 --> 00:28:32,799
could never ask before the rest api but

00:28:31,389 --> 00:28:34,629
now that we had all this understanding

00:28:32,799 --> 00:28:38,019
at the field level of a graphical query

00:28:34,629 --> 00:28:40,179
we got all these new answers and that's

00:28:38,019 --> 00:28:42,129
our presentation so we hope you guys

00:28:40,179 --> 00:28:43,779
learned a lot from our experience and

00:28:42,129 --> 00:28:45,399
again huge thanks to the open source

00:28:43,779 --> 00:28:46,840
community with that whom like all of

00:28:45,399 --> 00:28:49,179
this great graph kill stuff wouldn't be

00:28:46,840 --> 00:28:50,710
possible all these tools that were

00:28:49,179 --> 00:28:52,179
working on collaborating with people I

00:28:50,710 --> 00:28:54,309
think it's going to be really really

00:28:52,179 --> 00:28:56,080
awesome and get even better into next

00:28:54,309 --> 00:28:57,759
year and if you know anybody who wants

00:28:56,080 --> 00:28:59,470
to work on graph QL technology full time

00:28:57,759 --> 00:29:01,179
we're hiring right now we desperately

00:28:59,470 --> 00:29:03,519
need more people that more of these

00:29:01,179 --> 00:29:06,250
features we like to products like optics

00:29:03,519 --> 00:29:08,580
and tools like Apollo client so thank

00:29:06,250 --> 00:29:08,580

YouTube URL: https://www.youtube.com/watch?v=RCIRZr0RRt8


