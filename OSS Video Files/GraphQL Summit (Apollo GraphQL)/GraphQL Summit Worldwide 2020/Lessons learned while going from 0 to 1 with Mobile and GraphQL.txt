Title: Lessons learned while going from 0 to 1 with Mobile and GraphQL
Publication date: 2020-08-05
Playlist: GraphQL Summit Worldwide 2020
Description: 
	By Kamilah Taylor, Engineer at Gusto
Captions: 
	00:00:00,050 --> 00:00:03,409
[Music]

00:00:06,319 --> 00:00:09,120
hi

00:00:07,200 --> 00:00:10,480
my name is camila taylor and i'm an

00:00:09,120 --> 00:00:12,240
engineer at gusto

00:00:10,480 --> 00:00:13,920
the people platform that provides

00:00:12,240 --> 00:00:15,679
payroll and benefits for small

00:00:13,920 --> 00:00:17,359
businesses

00:00:15,679 --> 00:00:18,720
today i'm going to talk about some

00:00:17,359 --> 00:00:21,119
lessons i've learned

00:00:18,720 --> 00:00:23,920
while going from zero to one with mobile

00:00:21,119 --> 00:00:23,920
and graphql

00:00:25,680 --> 00:00:31,920
but first a little bit about me

00:00:28,960 --> 00:00:33,920
i was born on the tiny island of jamaica

00:00:31,920 --> 00:00:36,000
which usually leaves people thinking

00:00:33,920 --> 00:00:38,399
this

00:00:36,000 --> 00:00:40,719
ironic since i'm the world's slowest

00:00:38,399 --> 00:00:40,719
runner

00:00:41,840 --> 00:00:45,920
my reality is that i grew up as a shy

00:00:44,239 --> 00:00:49,600
kid with a love of legos

00:00:45,920 --> 00:00:51,199
books and robots my love of robots got

00:00:49,600 --> 00:00:53,280
me into computer science

00:00:51,199 --> 00:00:55,520
followed me into grad school it was my

00:00:53,280 --> 00:00:57,440
entry point into software engineering

00:00:55,520 --> 00:01:00,640
before i moved to silicon valley and got

00:00:57,440 --> 00:01:00,640
into the world of mobile

00:01:02,399 --> 00:01:05,600
fast forward in time and i found myself

00:01:04,960 --> 00:01:07,680
last fall

00:01:05,600 --> 00:01:08,960
in the situation that many watching this

00:01:07,680 --> 00:01:13,840
may have found themselves

00:01:08,960 --> 00:01:16,240
in sometimes you want to build an app

00:01:13,840 --> 00:01:17,680
you may be also lucky enough to need

00:01:16,240 --> 00:01:20,240
graphql

00:01:17,680 --> 00:01:22,640
huh you haven't used graphql before

00:01:20,240 --> 00:01:25,040
that's fine we'll learn that too

00:01:22,640 --> 00:01:26,880
oh uh your understanding of what the

00:01:25,040 --> 00:01:28,240
schema should be is changing and we're

00:01:26,880 --> 00:01:31,200
adding new features

00:01:28,240 --> 00:01:32,720
no problem if you've found yourself in

00:01:31,200 --> 00:01:36,799
such a situation

00:01:32,720 --> 00:01:36,799
you probably identify with this

00:01:39,360 --> 00:01:43,920
this is fine everyone has to start

00:01:42,479 --> 00:01:46,000
somewhere

00:01:43,920 --> 00:01:48,399
for us when we started working on this

00:01:46,000 --> 00:01:48,799
app there were three main questions that

00:01:48,399 --> 00:01:51,680
we

00:01:48,799 --> 00:01:55,840
and our wider team had and that we have

00:01:51,680 --> 00:01:55,840
continuously asked ourselves

00:01:55,920 --> 00:02:01,360
the first of these questions so

00:01:59,119 --> 00:02:03,360
i'm using apollo ios in my app in

00:02:01,360 --> 00:02:08,319
addition to my networking stack

00:02:03,360 --> 00:02:12,640
what goes where this schema is evolving

00:02:08,319 --> 00:02:12,640
how do we keep up in a not painful way

00:02:13,280 --> 00:02:16,720
so you're telling me that the

00:02:14,800 --> 00:02:18,239
engineering team now has to think about

00:02:16,720 --> 00:02:22,959
multiple clients

00:02:18,239 --> 00:02:25,360
what does that look like

00:02:22,959 --> 00:02:26,239
over time we worked out some answers for

00:02:25,360 --> 00:02:28,319
these

00:02:26,239 --> 00:02:30,400
and to be honest there's a lot we're

00:02:28,319 --> 00:02:32,400
still working on

00:02:30,400 --> 00:02:37,840
but today i'd like to talk about some of

00:02:32,400 --> 00:02:37,840
the solutions we've already found

00:02:38,480 --> 00:02:42,480
we were in a world of trying to figure

00:02:40,720 --> 00:02:44,720
out what goes where

00:02:42,480 --> 00:02:45,599
because we already knew that we wanted a

00:02:44,720 --> 00:02:47,760
modular app

00:02:45,599 --> 00:02:51,840
architecture and that we also wanted to

00:02:47,760 --> 00:02:51,840
use apollo ios

00:02:52,959 --> 00:02:57,200
for a little context here the problem

00:02:55,120 --> 00:02:59,840
with the monolith ios app is generally

00:02:57,200 --> 00:02:59,840
well known

00:03:00,560 --> 00:03:04,720
swift code bases get large and

00:03:02,840 --> 00:03:08,000
unmanageable

00:03:04,720 --> 00:03:08,000
compile times increase

00:03:08,480 --> 00:03:12,000
libraries get tightly coupled to the

00:03:10,319 --> 00:03:14,159
code

00:03:12,000 --> 00:03:18,560
and the team starts to experience a lot

00:03:14,159 --> 00:03:20,400
of merge conflicts

00:03:18,560 --> 00:03:23,599
so we started with these guiding

00:03:20,400 --> 00:03:27,200
architecture principles

00:03:23,599 --> 00:03:30,840
we'll have a modular app we'll try and

00:03:27,200 --> 00:03:32,400
enforce boundaries between modules where

00:03:30,840 --> 00:03:35,120
appropriate

00:03:32,400 --> 00:03:38,640
will practice encapsulation especially

00:03:35,120 --> 00:03:40,720
for external dependencies

00:03:38,640 --> 00:03:42,480
and we'll use the coordinator pattern

00:03:40,720 --> 00:03:44,640
for navigation

00:03:42,480 --> 00:03:45,680
something that we won't go into too much

00:03:44,640 --> 00:03:49,200
in this talk

00:03:45,680 --> 00:03:49,200
but it's still helpful context

00:03:51,519 --> 00:03:56,159
we started with our main framework

00:03:53,840 --> 00:03:57,920
called home in this diagram

00:03:56,159 --> 00:03:59,760
and started adding frameworks for our

00:03:57,920 --> 00:04:02,080
main features

00:03:59,760 --> 00:04:03,760
at first this was just one feature

00:04:02,080 --> 00:04:06,080
framework but we knew where we were

00:04:03,760 --> 00:04:06,080
heading

00:04:08,480 --> 00:04:13,360
our main home framework has to handle

00:04:11,040 --> 00:04:15,680
setting up the network stack

00:04:13,360 --> 00:04:17,919
at first it was the only framework

00:04:15,680 --> 00:04:19,919
interacting with a networking layer

00:04:17,919 --> 00:04:22,479
since it initiated the authentication

00:04:19,919 --> 00:04:23,040
flow but as we started looking towards

00:04:22,479 --> 00:04:25,199
our first

00:04:23,040 --> 00:04:26,479
feature framework we started wondering

00:04:25,199 --> 00:04:27,680
how we were going to honor our

00:04:26,479 --> 00:04:31,360
architecture principles

00:04:27,680 --> 00:04:31,360
and also pull in the apollo client

00:04:34,080 --> 00:04:39,120
the problem we were facing is that we

00:04:36,880 --> 00:04:41,360
were looking at a future where we'd have

00:04:39,120 --> 00:04:43,280
multiple feature frameworks and we

00:04:41,360 --> 00:04:43,759
needed all of them to access the data

00:04:43,280 --> 00:04:46,320
layer

00:04:43,759 --> 00:04:49,840
without creating a dependency on apollo

00:04:46,320 --> 00:04:49,840
for every feature framework

00:04:52,320 --> 00:04:57,280
our solution was something that we call

00:04:54,479 --> 00:05:00,160
the data service layer

00:04:57,280 --> 00:05:01,680
here you can see that our main framework

00:05:00,160 --> 00:05:03,520
is still doing the work of sewing

00:05:01,680 --> 00:05:06,400
everything together

00:05:03,520 --> 00:05:07,440
so it talks to authentication gusto

00:05:06,400 --> 00:05:11,199
network manager

00:05:07,440 --> 00:05:13,120
and app data service the great thing

00:05:11,199 --> 00:05:14,960
is that all of her feature frameworks

00:05:13,120 --> 00:05:16,560
simply talk to the app data service when

00:05:14,960 --> 00:05:19,600
they want to request data

00:05:16,560 --> 00:05:21,600
from the network or from the cache

00:05:19,600 --> 00:05:22,960
the app data service and gusto network

00:05:21,600 --> 00:05:25,759
manager have

00:05:22,960 --> 00:05:29,280
the explicit dependencies on apollo but

00:05:25,759 --> 00:05:29,280
our feature frameworks do not

00:05:31,600 --> 00:05:35,199
this was a huge win for us

00:05:35,360 --> 00:05:40,240
we were able to break up our code base

00:05:37,440 --> 00:05:40,240
into modules

00:05:40,800 --> 00:05:46,000
we separated our infrastructure layer

00:05:42,960 --> 00:05:48,320
from our feature layer

00:05:46,000 --> 00:05:50,400
and we set ourselves up to be able to

00:05:48,320 --> 00:05:51,520
pull some of our infrastructure layer

00:05:50,400 --> 00:05:55,600
modules

00:05:51,520 --> 00:05:57,680
out completely as shareable libraries

00:05:55,600 --> 00:06:01,120
let's take a closer look at what's going

00:05:57,680 --> 00:06:01,120
on with the app data service

00:06:03,199 --> 00:06:08,080
app data service is doing most of the

00:06:05,360 --> 00:06:10,639
heavy lifting with apollo

00:06:08,080 --> 00:06:12,639
it not only contains the apollo client

00:06:10,639 --> 00:06:16,000
but also the graphql files

00:06:12,639 --> 00:06:18,160
and the generated graphql models

00:06:16,000 --> 00:06:20,080
because it still needs to run on the

00:06:18,160 --> 00:06:22,000
networking stack that we'd initialized

00:06:20,080 --> 00:06:23,280
it does have a connection to gusto

00:06:22,000 --> 00:06:26,800
network manager

00:06:23,280 --> 00:06:29,280
through the network transport delegate

00:06:26,800 --> 00:06:31,520
we've also added wrappers around methods

00:06:29,280 --> 00:06:35,199
like fetch perform and watch

00:06:31,520 --> 00:06:37,600
that the rest of our app will need

00:06:35,199 --> 00:06:40,479
on the right our feature frameworks are

00:06:37,600 --> 00:06:43,600
able to interact with the graphql models

00:06:40,479 --> 00:06:46,800
make requests and mutations all without

00:06:43,600 --> 00:06:48,800
having an explicit dependency on apollo

00:06:46,800 --> 00:06:52,800
knowledge of the apollo client or

00:06:48,800 --> 00:06:52,800
knowledge of how any of it was set up

00:06:56,560 --> 00:06:59,840
encapsulation was a really important

00:06:58,880 --> 00:07:03,840
guiding principle

00:06:59,840 --> 00:07:03,840
and this definitely wins this for us

00:07:04,000 --> 00:07:08,080
for feature frameworks never need to

00:07:05,919 --> 00:07:10,400
know that apollo is even running under

00:07:08,080 --> 00:07:10,400
the hood

00:07:10,800 --> 00:07:13,840
we also centralize how everyone

00:07:12,880 --> 00:07:17,360
interfaces with

00:07:13,840 --> 00:07:19,280
data layer and

00:07:17,360 --> 00:07:21,039
we hide some of the details of what the

00:07:19,280 --> 00:07:24,960
network manager is doing

00:07:21,039 --> 00:07:24,960
from the feature frameworks completely

00:07:26,800 --> 00:07:30,080
we were able to use our modular app

00:07:29,360 --> 00:07:31,759
architecture

00:07:30,080 --> 00:07:33,280
to encapsulate and create those

00:07:31,759 --> 00:07:35,759
boundaries we see

00:07:33,280 --> 00:07:38,319
around apollo and around our data layer

00:07:35,759 --> 00:07:38,319
in general

00:07:41,039 --> 00:07:44,639
our next hurdle was something we really

00:07:43,520 --> 00:07:46,160
only experienced

00:07:44,639 --> 00:07:48,879
once we were some months into

00:07:46,160 --> 00:07:49,680
development and that was what it meant

00:07:48,879 --> 00:07:51,840
to have

00:07:49,680 --> 00:07:54,319
active app development with an evolving

00:07:51,840 --> 00:07:54,319
schema

00:07:55,840 --> 00:07:59,440
our life became build the app to find

00:07:58,800 --> 00:08:02,479
the schema

00:07:59,440 --> 00:08:04,720
build app repeat etc

00:08:02,479 --> 00:08:06,319
add in some early experiments with mock

00:08:04,720 --> 00:08:09,199
data while we were waiting

00:08:06,319 --> 00:08:10,960
on standing up the schema and some

00:08:09,199 --> 00:08:12,319
realizations of how the schema should

00:08:10,960 --> 00:08:14,960
have been defined

00:08:12,319 --> 00:08:18,160
and then throw in some new use cases and

00:08:14,960 --> 00:08:21,039
business requirements just for fun

00:08:18,160 --> 00:08:21,039
then you get this

00:08:24,160 --> 00:08:27,360
the problem we started facing is that

00:08:26,639 --> 00:08:29,440
over time

00:08:27,360 --> 00:08:30,800
our understanding of what we wanted the

00:08:29,440 --> 00:08:33,760
schema structure to be

00:08:30,800 --> 00:08:35,039
changed and with active feature

00:08:33,760 --> 00:08:41,680
development

00:08:35,039 --> 00:08:44,240
sometimes the schema had to be updated

00:08:41,680 --> 00:08:45,920
we knew that we wanted to use mbvm and

00:08:44,240 --> 00:08:47,920
the coordinator pattern

00:08:45,920 --> 00:08:49,760
and once we started using these patterns

00:08:47,920 --> 00:08:51,440
we realized that we could further

00:08:49,760 --> 00:08:54,800
localize knowledge

00:08:51,440 --> 00:08:56,959
and access to the data layer

00:08:54,800 --> 00:08:59,440
let's look at what this looks like in

00:08:56,959 --> 00:08:59,440
practice

00:09:00,720 --> 00:09:04,080
over in data service lan we define our

00:09:03,279 --> 00:09:07,440
queries

00:09:04,080 --> 00:09:08,160
such as employee query have or generated

00:09:07,440 --> 00:09:11,279
models

00:09:08,160 --> 00:09:13,440
such as employee.graphql.swift and our

00:09:11,279 --> 00:09:14,240
fetch method that obfuscates the apollo

00:09:13,440 --> 00:09:16,399
client

00:09:14,240 --> 00:09:18,959
and also handles things like the cash

00:09:16,399 --> 00:09:21,760
policy

00:09:18,959 --> 00:09:23,279
over in feature framework land our

00:09:21,760 --> 00:09:24,959
profile view controller

00:09:23,279 --> 00:09:26,320
wants to load data that would be

00:09:24,959 --> 00:09:30,000
returned from the

00:09:26,320 --> 00:09:32,320
employee query we have a review model

00:09:30,000 --> 00:09:33,440
make the request to to the data service

00:09:32,320 --> 00:09:35,440
for data

00:09:33,440 --> 00:09:37,360
in this case we'd like to get employee

00:09:35,440 --> 00:09:40,160
details

00:09:37,360 --> 00:09:41,120
get employee details then goes to app

00:09:40,160 --> 00:09:46,000
data service

00:09:41,120 --> 00:09:48,320
calls fetch and gets that raw value back

00:09:46,000 --> 00:09:50,320
at this point our view model parses the

00:09:48,320 --> 00:09:52,320
data and pulls it out into fields the

00:09:50,320 --> 00:09:56,480
view controller will actually care about

00:09:52,320 --> 00:09:58,640
like full name which becomes a string

00:09:56,480 --> 00:10:01,200
and then passes these purse values back

00:09:58,640 --> 00:10:03,920
to the view controller

00:10:01,200 --> 00:10:05,279
this leaves or view controller ignorant

00:10:03,920 --> 00:10:09,200
of graphql

00:10:05,279 --> 00:10:09,200
and what the shape of the queries are

00:10:12,399 --> 00:10:16,839
this was another big win for

00:10:13,920 --> 00:10:19,839
encapsulation and boundaries and

00:10:16,839 --> 00:10:19,839
decoupling

00:10:19,920 --> 00:10:23,279
within our feature frameworks usually

00:10:22,000 --> 00:10:25,040
only our view models

00:10:23,279 --> 00:10:28,720
interact with their data layer and have

00:10:25,040 --> 00:10:28,720
knowledge of the graphql models

00:10:28,959 --> 00:10:33,519
our coordinators also occasionally

00:10:31,200 --> 00:10:35,120
interacts with the data service

00:10:33,519 --> 00:10:38,880
usually when they're handling a flow

00:10:35,120 --> 00:10:38,880
that's spread across multiple views

00:10:39,200 --> 00:10:47,600
this brings us part of the way but there

00:10:41,360 --> 00:10:50,560
was still more we had to learn

00:10:47,600 --> 00:10:52,000
our next approach adding extensions to

00:10:50,560 --> 00:10:55,839
our graphql models

00:10:52,000 --> 00:10:55,839
grew from the following situation

00:10:56,240 --> 00:11:00,399
graphql generated models end up with

00:10:59,040 --> 00:11:02,720
deeply nested types

00:11:00,399 --> 00:11:04,320
that reveal the exact shape of the query

00:11:02,720 --> 00:11:06,640
each time we need to interact with the

00:11:04,320 --> 00:11:06,640
model

00:11:08,480 --> 00:11:13,839
this means that when the schema evolves

00:11:11,279 --> 00:11:16,160
perhaps moving the fields around

00:11:13,839 --> 00:11:18,000
we end up with having to change that in

00:11:16,160 --> 00:11:21,680
every view model or coordinator that

00:11:18,000 --> 00:11:24,320
interacts with that model data

00:11:21,680 --> 00:11:25,920
we had some really tedious refactors

00:11:24,320 --> 00:11:29,519
that happened when

00:11:25,920 --> 00:11:32,160
that started to happen and this is how

00:11:29,519 --> 00:11:35,360
we started working on

00:11:32,160 --> 00:11:35,360
using extensions

00:11:35,440 --> 00:11:39,120
here in our sample query called feature

00:11:37,760 --> 00:11:42,800
query

00:11:39,120 --> 00:11:44,800
you can see a typical nesting of fields

00:11:42,800 --> 00:11:46,560
to get to current enrollment you have to

00:11:44,800 --> 00:11:48,959
go through employee then feature than

00:11:46,560 --> 00:11:50,880
current enrollment

00:11:48,959 --> 00:11:52,560
over in the view model you can see what

00:11:50,880 --> 00:11:54,320
it looks like when your app needs to

00:11:52,560 --> 00:11:56,880
access current enrollment

00:11:54,320 --> 00:11:56,880
go and

00:11:59,320 --> 00:12:02,320
featureddata.employee.feature.currentenrollment

00:12:02,560 --> 00:12:06,000
you can imagine that if we moved current

00:12:04,639 --> 00:12:07,920
enrollment one level down

00:12:06,000 --> 00:12:09,040
or moved it out from being nested under

00:12:07,920 --> 00:12:10,800
future

00:12:09,040 --> 00:12:12,480
we'd have to change the call site not

00:12:10,800 --> 00:12:14,399
just in future view model but

00:12:12,480 --> 00:12:16,510
everywhere that interacted with that

00:12:14,399 --> 00:12:18,560
model

00:12:16,510 --> 00:12:22,320
[Music]

00:12:18,560 --> 00:12:24,560
enter the magic of swift extensions

00:12:22,320 --> 00:12:26,279
when we add an extension to that graphql

00:12:24,560 --> 00:12:29,279
generated model

00:12:26,279 --> 00:12:29,839
featurequery.data we can encapsulate the

00:12:29,279 --> 00:12:32,079
logic

00:12:29,839 --> 00:12:32,880
around where in the tree this value

00:12:32,079 --> 00:12:34,800
lives

00:12:32,880 --> 00:12:36,880
and the rest of your app never needs to

00:12:34,800 --> 00:12:38,880
know

00:12:36,880 --> 00:12:41,480
here we've defined a current enrollment

00:12:38,880 --> 00:12:43,600
variable that returns

00:12:41,480 --> 00:12:46,680
employee.feature.currentenrollment and

00:12:43,600 --> 00:12:49,440
now the viewmodel can just call

00:12:46,680 --> 00:12:52,399
featuredata.currentenrollment

00:12:49,440 --> 00:12:54,079
this means that when the schema changes

00:12:52,399 --> 00:12:56,000
we can make the change

00:12:54,079 --> 00:12:58,000
just at the extension layer and

00:12:56,000 --> 00:13:00,959
hopefully nowhere else has to change

00:12:58,000 --> 00:13:02,480
and if it does because an underlying

00:13:00,959 --> 00:13:07,839
type has changed

00:13:02,480 --> 00:13:07,839
the fallout is reduced

00:13:09,440 --> 00:13:13,680
we've handled schema evolution by

00:13:11,839 --> 00:13:17,279
limiting access to the data layer

00:13:13,680 --> 00:13:19,120
using patterns like mbvm and we decouple

00:13:17,279 --> 00:13:21,040
the code from the shape of the schema

00:13:19,120 --> 00:13:21,860
by using swift's extensions where

00:13:21,040 --> 00:13:25,009
appropriate

00:13:21,860 --> 00:13:25,009
[Music]

00:13:27,920 --> 00:13:35,839
oh no i think this is

00:13:32,839 --> 00:13:35,839
okay

00:13:36,160 --> 00:13:41,279
and finally software engineering is a

00:13:38,720 --> 00:13:43,440
team sport

00:13:41,279 --> 00:13:49,160
moving to a world of multiple clients

00:13:43,440 --> 00:13:50,399
can be different

00:13:49,160 --> 00:13:55,360
[Music]

00:13:50,399 --> 00:13:56,399
okay the team was used to designing apis

00:13:55,360 --> 00:13:58,480
for a web client

00:13:56,399 --> 00:14:00,240
that lived at the back end but now we

00:13:58,480 --> 00:14:01,760
have to figure out how to design not

00:14:00,240 --> 00:14:04,000
just for multiple clients

00:14:01,760 --> 00:14:06,000
but for a mobile app that has its own

00:14:04,000 --> 00:14:07,839
release cycle

00:14:06,000 --> 00:14:11,360
we've come up with a couple of solutions

00:14:07,839 --> 00:14:11,360
that have worked for us so far

00:14:13,199 --> 00:14:16,480
the biggest lesson was that we started

00:14:15,120 --> 00:14:20,160
to design the schemas

00:14:16,480 --> 00:14:20,160
to encapsulate business logic

00:14:20,639 --> 00:14:26,320
this example is similar to something

00:14:22,560 --> 00:14:28,800
that jumped out at us as incorrect

00:14:26,320 --> 00:14:30,800
imagine we're only allowing employee to

00:14:28,800 --> 00:14:32,720
add five bank accounts

00:14:30,800 --> 00:14:35,680
of course we don't want to hardcode the

00:14:32,720 --> 00:14:38,000
max number of counts on each client

00:14:35,680 --> 00:14:41,040
which we've done here by having this

00:14:38,000 --> 00:14:43,440
this type of logic check

00:14:41,040 --> 00:14:44,880
because the schema can be so flexible

00:14:43,440 --> 00:14:47,040
you may be tempted

00:14:44,880 --> 00:14:49,519
to then just add all the fields that you

00:14:47,040 --> 00:14:49,519
may need

00:14:50,160 --> 00:14:55,760
so then you add an extra field for that

00:14:52,800 --> 00:14:57,839
maximum number of bank accounts

00:14:55,760 --> 00:14:58,880
but if the client still needs to combine

00:14:57,839 --> 00:15:00,720
multiple fields

00:14:58,880 --> 00:15:02,480
to know if they need to show a screen or

00:15:00,720 --> 00:15:05,120
disable a button

00:15:02,480 --> 00:15:07,839
then we've again left business logic

00:15:05,120 --> 00:15:09,760
being implemented on multiple clients

00:15:07,839 --> 00:15:13,400
you can imagine that all of your clients

00:15:09,760 --> 00:15:14,560
will have this logic check

00:15:13,400 --> 00:15:16,720
[Music]

00:15:14,560 --> 00:15:17,600
even better is if we could move that

00:15:16,720 --> 00:15:20,800
logic behind

00:15:17,600 --> 00:15:23,040
one field in a schema now

00:15:20,800 --> 00:15:24,000
with the new can add new bank account

00:15:23,040 --> 00:15:26,079
flag

00:15:24,000 --> 00:15:29,680
you've only had to handle this logic

00:15:26,079 --> 00:15:31,759
once for all of your clients

00:15:29,680 --> 00:15:33,120
we've found over time many instances

00:15:31,759 --> 00:15:34,720
like this where we can move

00:15:33,120 --> 00:15:37,680
more the business logic behind the

00:15:34,720 --> 00:15:39,360
schema reducing the amount of times

00:15:37,680 --> 00:15:41,759
you're implementing something

00:15:39,360 --> 00:15:43,839
and making it easier to dynamically

00:15:41,759 --> 00:15:46,880
change this

00:15:43,839 --> 00:15:49,440
imagine you've removed having a max

00:15:46,880 --> 00:15:51,120
limit to the number of bank accounts

00:15:49,440 --> 00:15:52,560
if you are returning that as a value

00:15:51,120 --> 00:15:53,839
there's no clean way to make that

00:15:52,560 --> 00:15:56,160
transition without first

00:15:53,839 --> 00:15:57,040
updating your mobile clients but in this

00:15:56,160 --> 00:15:59,279
example

00:15:57,040 --> 00:16:02,959
you can just set can add new bank

00:15:59,279 --> 00:16:02,959
account to always return true

00:16:05,040 --> 00:16:10,320
there's a lot more we've been working on

00:16:06,959 --> 00:16:10,320
as we evolve our schema

00:16:10,959 --> 00:16:14,079
you may have copy that you've thought of

00:16:12,880 --> 00:16:16,560
as client-side

00:16:14,079 --> 00:16:17,680
localized strings that actually rely on

00:16:16,560 --> 00:16:23,440
a business value

00:16:17,680 --> 00:16:25,279
to still convey a true true sentiment

00:16:23,440 --> 00:16:27,519
by adding these business values that

00:16:25,279 --> 00:16:29,600
could change over time to our schema

00:16:27,519 --> 00:16:31,360
you've gained more flexibility to update

00:16:29,600 --> 00:16:36,880
these business values over time

00:16:31,360 --> 00:16:39,120
without requiring a client update

00:16:36,880 --> 00:16:41,839
over time we started to use graphql

00:16:39,120 --> 00:16:45,279
interfaces and enums more

00:16:41,839 --> 00:16:47,199
interfaces allow us to start ensuring

00:16:45,279 --> 00:16:49,440
that we only expose the right set of

00:16:47,199 --> 00:16:51,279
data at the right place

00:16:49,440 --> 00:16:54,079
if we have a list view where the

00:16:51,279 --> 00:16:56,959
elements are all a different type

00:16:54,079 --> 00:16:58,480
but have some common characteristics we

00:16:56,959 --> 00:17:00,560
could still figure out the common parts

00:16:58,480 --> 00:17:02,320
and extract those to the interface

00:17:00,560 --> 00:17:04,959
leaving our list view to be a list of

00:17:02,320 --> 00:17:07,039
the same elements and only making type

00:17:04,959 --> 00:17:10,720
specific calls at the detail level

00:17:07,039 --> 00:17:10,720
when tapping into the elements

00:17:11,039 --> 00:17:14,079
we partner with the rest of the

00:17:12,400 --> 00:17:16,880
engineering team a lot to coordinate

00:17:14,079 --> 00:17:16,880
deprecations

00:17:17,199 --> 00:17:21,120
and we've also been working on how we

00:17:18,799 --> 00:17:23,039
can in general just design our schemas

00:17:21,120 --> 00:17:24,559
to be product backwards compatible where

00:17:23,039 --> 00:17:26,720
possible

00:17:24,559 --> 00:17:29,200
our mobile clients may be older but if

00:17:26,720 --> 00:17:30,000
they can seamlessly consume updates to

00:17:29,200 --> 00:17:32,080
our schema

00:17:30,000 --> 00:17:34,640
without needing to be force updated then

00:17:32,080 --> 00:17:34,640
move one

00:17:37,120 --> 00:17:41,440
we've embraced the multiple client world

00:17:39,200 --> 00:17:43,200
by designing our graphql apis to

00:17:41,440 --> 00:17:46,080
encapsulate business logic

00:17:43,200 --> 00:17:47,679
the product backwards compatible and

00:17:46,080 --> 00:17:51,039
we've partnered cross-functionally

00:17:47,679 --> 00:17:51,039
across engineering teams

00:17:52,559 --> 00:17:55,679
so we have some answers to those

00:17:54,160 --> 00:17:58,240
questions that we've been asking

00:17:55,679 --> 00:17:58,240
ourselves

00:17:59,120 --> 00:18:03,919
apollo ios lives in a data service layer

00:18:02,080 --> 00:18:05,360
and feature frameworks interact with the

00:18:03,919 --> 00:18:06,640
data service

00:18:05,360 --> 00:18:09,360
through their view models and

00:18:06,640 --> 00:18:09,360
coordinators

00:18:10,320 --> 00:18:14,559
we decouple as much of the app as

00:18:12,480 --> 00:18:18,640
possible from the shape of the schema

00:18:14,559 --> 00:18:18,640
to handle schema evolution gracefully

00:18:19,520 --> 00:18:23,520
and we've embraced the multiple client

00:18:21,520 --> 00:18:26,640
life and designed this schema

00:18:23,520 --> 00:18:30,240
to be to encapsulate business logic and

00:18:26,640 --> 00:18:30,240
be product backwards compatible

00:18:31,520 --> 00:18:37,520
this had us feeling like this

00:18:34,880 --> 00:18:38,000
and let's be real who else but usain

00:18:37,520 --> 00:18:43,520
bolt

00:18:38,000 --> 00:18:45,360
could express victory like this

00:18:43,520 --> 00:18:47,200
thank you for joining me on this journey

00:18:45,360 --> 00:18:48,000
as i share some lessons we've learned at

00:18:47,200 --> 00:18:51,200
gusto

00:18:48,000 --> 00:18:53,600
with mobile and apollo ios

00:18:51,200 --> 00:18:55,760
uh yeah so thank you for joining joining

00:18:53,600 --> 00:18:57,440
today as we took a little bit of a

00:18:55,760 --> 00:18:58,160
journey through some of the lessons that

00:18:57,440 --> 00:19:00,480
we learned

00:18:58,160 --> 00:19:02,000
uh going from zero to one with mobile

00:19:00,480 --> 00:19:04,240
and graphql

00:19:02,000 --> 00:19:05,440
uh we have a couple of questions that

00:19:04,240 --> 00:19:08,559
have come in and so

00:19:05,440 --> 00:19:11,360
i'll pick some of them uh

00:19:08,559 --> 00:19:12,480
so we have a really interesting question

00:19:11,360 --> 00:19:15,919
um

00:19:12,480 --> 00:19:16,640
from kurt kemple uh do you share queries

00:19:15,919 --> 00:19:19,919
across

00:19:16,640 --> 00:19:23,360
apps if so how uh

00:19:19,919 --> 00:19:26,720
so for that i'm uh let's see

00:19:23,360 --> 00:19:29,679
do we share queries across apps uh

00:19:26,720 --> 00:19:30,720
we do not share the exact shape of the

00:19:29,679 --> 00:19:33,919
queries we just

00:19:30,720 --> 00:19:35,360
uh but often across say like our ios and

00:19:33,919 --> 00:19:37,360
android app we do

00:19:35,360 --> 00:19:39,360
map and have like the same queries we're

00:19:37,360 --> 00:19:39,919
just like me but we are redefining them

00:19:39,360 --> 00:19:43,120
in each

00:19:39,919 --> 00:19:45,520
in each code base uh we sync up

00:19:43,120 --> 00:19:47,120
across the two teams pretty regularly

00:19:45,520 --> 00:19:49,679
just to make sure that we're all

00:19:47,120 --> 00:19:51,520
that we're um that we're querying for

00:19:49,679 --> 00:19:52,000
the same shape of the queries and

00:19:51,520 --> 00:19:54,720
usually

00:19:52,000 --> 00:19:56,960
it should be it should be pretty clear

00:19:54,720 --> 00:19:57,840
based on the designs and what data you

00:19:56,960 --> 00:19:59,600
need that we

00:19:57,840 --> 00:20:01,200
that we are sort of mapping that

00:19:59,600 --> 00:20:04,240
parallelly

00:20:01,200 --> 00:20:05,760
uh across mobile and web

00:20:04,240 --> 00:20:06,960
sometimes the shapes of the queries are

00:20:05,760 --> 00:20:08,159
a little bit more different but i think

00:20:06,960 --> 00:20:09,919
that just makes sense

00:20:08,159 --> 00:20:11,919
uh those those clients are a little bit

00:20:09,919 --> 00:20:15,520
more different than our

00:20:11,919 --> 00:20:19,039
mobile apps uh

00:20:15,520 --> 00:20:21,360
we have another okay

00:20:19,039 --> 00:20:23,039
so what was the frequency this is a

00:20:21,360 --> 00:20:24,559
question from gabby zoo

00:20:23,039 --> 00:20:26,799
what was the frequency of breaking

00:20:24,559 --> 00:20:28,320
changes and how did you solve app

00:20:26,799 --> 00:20:31,200
versioning when this schema

00:20:28,320 --> 00:20:33,200
would break yeah so we definitely had a

00:20:31,200 --> 00:20:34,000
little bit of a rude awakening the first

00:20:33,200 --> 00:20:36,000
time we experienced

00:20:34,000 --> 00:20:37,360
one of these breaking changes and i

00:20:36,000 --> 00:20:38,480
think this is something that we're still

00:20:37,360 --> 00:20:41,840
going to be

00:20:38,480 --> 00:20:42,559
learning about over time uh we have

00:20:41,840 --> 00:20:44,880
tried to

00:20:42,559 --> 00:20:46,240
try to reduce that when we have solved

00:20:44,880 --> 00:20:48,480
this in a couple of ways

00:20:46,240 --> 00:20:49,440
one is i think just like really strongly

00:20:48,480 --> 00:20:52,159
communicating

00:20:49,440 --> 00:20:54,320
on what is going to end up being a

00:20:52,159 --> 00:20:57,679
breaking change we are trying to work

00:20:54,320 --> 00:20:59,919
and on having more tooling to catch

00:20:57,679 --> 00:21:03,440
those before them and then we go through

00:20:59,919 --> 00:21:05,120
a deprecation process basically so

00:21:03,440 --> 00:21:07,360
if there is something that really does

00:21:05,120 --> 00:21:10,000
need to be a breaking change

00:21:07,360 --> 00:21:11,120
we deprecate the field that way when the

00:21:10,000 --> 00:21:13,200
mobile clients

00:21:11,120 --> 00:21:15,440
hold the latest schema they see that

00:21:13,200 --> 00:21:17,520
these fields are deprecated

00:21:15,440 --> 00:21:18,960
um we usually sync with the team or

00:21:17,520 --> 00:21:20,080
whoever whoever it is that wants to

00:21:18,960 --> 00:21:21,679
deprecate that field

00:21:20,080 --> 00:21:23,679
uh to figure out like what their

00:21:21,679 --> 00:21:25,679
timeline is for when they want to move

00:21:23,679 --> 00:21:26,799
over to the old one we switched the new

00:21:25,679 --> 00:21:29,760
one

00:21:26,799 --> 00:21:31,760
uh and then our plan here is that just

00:21:29,760 --> 00:21:32,880
depending on the nature of the braking

00:21:31,760 --> 00:21:35,360
change

00:21:32,880 --> 00:21:36,559
uh we will see like how much traffic

00:21:35,360 --> 00:21:38,799
we're comfortable with

00:21:36,559 --> 00:21:40,480
uh coming coming against the older

00:21:38,799 --> 00:21:44,480
version of the app we did add an

00:21:40,480 --> 00:21:47,520
extra query uh this query uh will

00:21:44,480 --> 00:21:50,080
return what the minimum supported

00:21:47,520 --> 00:21:51,120
version of the app is and so when we are

00:21:50,080 --> 00:21:52,720
finally ready to

00:21:51,120 --> 00:21:54,400
be able to make that breaking change

00:21:52,720 --> 00:21:57,679
what we'll do is uh

00:21:54,400 --> 00:21:59,200
bump that minimum version and then once

00:21:57,679 --> 00:22:02,400
we've got the minimum version

00:21:59,200 --> 00:22:02,799
then uh teams can safely remove remove

00:22:02,400 --> 00:22:06,240
the

00:22:02,799 --> 00:22:06,240
old parts of the schema

00:22:08,080 --> 00:22:14,240
let's see uh do we have let's see

00:22:12,480 --> 00:22:16,320
wow we have lots of questions all right

00:22:14,240 --> 00:22:18,480
lots of questions

00:22:16,320 --> 00:22:20,159
uh let's see at what point did you start

00:22:18,480 --> 00:22:21,760
working with the back end team about the

00:22:20,159 --> 00:22:24,400
structure of the schema

00:22:21,760 --> 00:22:25,679
uh definitely from the beginning so we

00:22:24,400 --> 00:22:28,240
actually started

00:22:25,679 --> 00:22:30,480
on on our specific projects uh the

00:22:28,240 --> 00:22:34,000
mobile team actually started building

00:22:30,480 --> 00:22:34,559
a lot of the schema first um for part of

00:22:34,000 --> 00:22:36,799
the app

00:22:34,559 --> 00:22:37,600
uh and then there were other parts of

00:22:36,799 --> 00:22:39,440
the team that was

00:22:37,600 --> 00:22:40,640
doing more back-end things it took over

00:22:39,440 --> 00:22:43,440
some of that

00:22:40,640 --> 00:22:44,720
and we're building out new features but

00:22:43,440 --> 00:22:46,640
this is a pretty like

00:22:44,720 --> 00:22:47,919
regular thing i think over time we

00:22:46,640 --> 00:22:51,200
realized more and more

00:22:47,919 --> 00:22:53,200
that the teams needed to be involved

00:22:51,200 --> 00:22:54,960
a little bit more as we designed the

00:22:53,200 --> 00:22:56,640
schemas because you think about

00:22:54,960 --> 00:23:00,000
different uh concerns

00:22:56,640 --> 00:23:00,880
on mobile versus web and once both teams

00:23:00,000 --> 00:23:03,039
were there

00:23:00,880 --> 00:23:05,039
together that's usually when we would

00:23:03,039 --> 00:23:06,880
surface of things where it's like oh

00:23:05,039 --> 00:23:08,159
this is like logic that we're repeating

00:23:06,880 --> 00:23:09,840
across multiple clients

00:23:08,159 --> 00:23:11,760
maybe this is something that we can move

00:23:09,840 --> 00:23:12,559
into the schema behind the schema

00:23:11,760 --> 00:23:16,000
instead of like

00:23:12,559 --> 00:23:17,760
repeating this across so

00:23:16,000 --> 00:23:19,360
i would say pretty early on a couple a

00:23:17,760 --> 00:23:23,280
couple of months in is really when we

00:23:19,360 --> 00:23:26,320
started to like notice this uh let's see

00:23:23,280 --> 00:23:29,520
the hardest thing for you to wrap around

00:23:26,320 --> 00:23:32,799
with graphql uh

00:23:29,520 --> 00:23:34,320
i think um i know that early on i think

00:23:32,799 --> 00:23:37,280
it was a little unclear to us

00:23:34,320 --> 00:23:37,760
like how to use fragments um at least

00:23:37,280 --> 00:23:39,360
for me

00:23:37,760 --> 00:23:41,279
i know that was something that it took

00:23:39,360 --> 00:23:42,480
me a little a little while to wrap my

00:23:41,279 --> 00:23:45,840
head around and where

00:23:42,480 --> 00:23:47,840
where are those fragments to find uh

00:23:45,840 --> 00:23:50,240
yeah it would be probably at least one

00:23:47,840 --> 00:23:54,320
of the things on top of my head

00:23:50,240 --> 00:23:55,600
and let's see when using apollo ios

00:23:54,320 --> 00:23:58,080
he suffered from null checking

00:23:55,600 --> 00:23:58,799
everything yeah or what's your strategy

00:23:58,080 --> 00:24:01,840
to determine

00:23:58,799 --> 00:24:04,480
nullability for object fields yeah

00:24:01,840 --> 00:24:04,880
we definitely end up with a lot of null

00:24:04,480 --> 00:24:08,720
checks

00:24:04,880 --> 00:24:12,080
for for places it depends on the field

00:24:08,720 --> 00:24:12,400
we do unwrap for some things if there's

00:24:12,080 --> 00:24:16,240
a

00:24:12,400 --> 00:24:17,679
if there's a good understanding of um

00:24:16,240 --> 00:24:19,919
okay i guess there's two types of null

00:24:17,679 --> 00:24:23,679
checks one is in this field

00:24:19,919 --> 00:24:26,080
is null is there a really good

00:24:23,679 --> 00:24:27,600
uh value for us to fall back to in that

00:24:26,080 --> 00:24:30,000
case it's usually when we define those

00:24:27,600 --> 00:24:31,600
in the extensions that i mentioned

00:24:30,000 --> 00:24:33,760
uh but then there are others where like

00:24:31,600 --> 00:24:34,799
if this is null then like something has

00:24:33,760 --> 00:24:36,720
actually gone wrong

00:24:34,799 --> 00:24:38,159
right like the the query has not gone

00:24:36,720 --> 00:24:39,760
through and then we like pass that

00:24:38,159 --> 00:24:42,240
through our like error checking

00:24:39,760 --> 00:24:44,720
layer and maybe try and re retry the

00:24:42,240 --> 00:24:44,720
query

00:24:44,960 --> 00:24:48,960
cool and uh i think do we give you time

00:24:48,400 --> 00:24:52,000
for more

00:24:48,960 --> 00:24:52,640
okay one more question uh so this is a

00:24:52,000 --> 00:24:55,279
question

00:24:52,640 --> 00:24:57,279
from mike cohen when you move the

00:24:55,279 --> 00:24:58,320
minimums give a version forward for your

00:24:57,279 --> 00:25:00,559
api

00:24:58,320 --> 00:25:01,679
uh what is experience for users of the

00:25:00,559 --> 00:25:03,840
affected mobile

00:25:01,679 --> 00:25:05,600
applications so they will not be able to

00:25:03,840 --> 00:25:07,360
like get into the app it's a very first

00:25:05,600 --> 00:25:10,080
query that we make

00:25:07,360 --> 00:25:10,880
uh and it will basically we'll should we

00:25:10,080 --> 00:25:14,159
show an alert

00:25:10,880 --> 00:25:16,080
like on on launch that says uh

00:25:14,159 --> 00:25:17,520
that year you're not on the minimum

00:25:16,080 --> 00:25:18,799
version and you need to update from the

00:25:17,520 --> 00:25:20,799
app store

00:25:18,799 --> 00:25:22,240
uh and that's just it's the only way to

00:25:20,799 --> 00:25:28,080
to block on

00:25:22,240 --> 00:25:30,720
querying an old version of the schema

00:25:28,080 --> 00:25:31,120
all right uh so i think that's all we

00:25:30,720 --> 00:25:34,320
have

00:25:31,120 --> 00:25:37,679
time for today uh so yeah thank you for

00:25:34,320 --> 00:25:43,840
for watching i talked today and uh and

00:25:37,679 --> 00:25:43,840
enjoy the rest of the conference

00:25:43,930 --> 00:25:50,559
[Music]

00:25:48,480 --> 00:25:50,559

YouTube URL: https://www.youtube.com/watch?v=NLEk_EOjAn4


