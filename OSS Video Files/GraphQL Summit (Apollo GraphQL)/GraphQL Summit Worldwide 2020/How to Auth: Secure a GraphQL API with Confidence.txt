Title: How to Auth: Secure a GraphQL API with Confidence
Publication date: 2020-08-11
Playlist: GraphQL Summit Worldwide 2020
Description: 
	Learn how to implement authentication and authorization using Apollo with Mandi Wise, Owner at 8-Bit Press.

Resources:
Explore the Apollo docs - https://www.apollographql.com/docs/
Explore authentication & authorization - https://www.apollographql.com/docs/apollo-server/security/authentication/
Learn about Apollo server - https://www.apollographql.com/docs/apollo-server/
Captions: 
	00:00:03,000 --> 00:00:06,089
[Music]

00:00:07,040 --> 00:00:10,000
okay here we go

00:00:08,160 --> 00:00:12,000
i'd like to begin by thanking everyone

00:00:10,000 --> 00:00:13,920
for joining me for this talk today

00:00:12,000 --> 00:00:15,679
and before we jump in i'll share a bit

00:00:13,920 --> 00:00:17,119
of my background so again my name is

00:00:15,679 --> 00:00:19,279
mandy and i've been developing with

00:00:17,119 --> 00:00:20,800
graphql since 2017

00:00:19,279 --> 00:00:22,720
and i started teaching other people how

00:00:20,800 --> 00:00:25,119
to use graphql shortly after that at a

00:00:22,720 --> 00:00:26,800
tech and design school i used to work at

00:00:25,119 --> 00:00:28,400
last year i decided i wanted to

00:00:26,800 --> 00:00:30,320
consolidate everything i had learned

00:00:28,400 --> 00:00:31,439
about building graphql apis over the

00:00:30,320 --> 00:00:33,440
years into a book

00:00:31,439 --> 00:00:34,559
and i called that book advanced graphql

00:00:33,440 --> 00:00:36,880
with apollo and react and i

00:00:34,559 --> 00:00:39,120
self-published it earlier this year

00:00:36,880 --> 00:00:41,120
now today i'm going to give you a quick

00:00:39,120 --> 00:00:43,600
rundown of how you can handle auth with

00:00:41,120 --> 00:00:45,760
your graphql api

00:00:43,600 --> 00:00:47,440
and my intention for this talk is to

00:00:45,760 --> 00:00:48,879
give you an overview of how we can

00:00:47,440 --> 00:00:51,760
handle authenticating and

00:00:48,879 --> 00:00:53,520
authorizing users with graphql apis and

00:00:51,760 --> 00:00:55,120
specifically i'm going to show you how

00:00:53,520 --> 00:00:55,920
this can be accomplished using various

00:00:55,120 --> 00:00:58,160
libraries

00:00:55,920 --> 00:00:59,760
including apollo server and we'll even

00:00:58,160 --> 00:01:02,960
talk a little bit at the end about how

00:00:59,760 --> 00:01:05,280
this works with apollo federation 2.

00:01:02,960 --> 00:01:07,119
now before we dive in it's important

00:01:05,280 --> 00:01:07,760
that we clarify what we mean when we

00:01:07,119 --> 00:01:11,119
talk about

00:01:07,760 --> 00:01:13,520
auth and there are two sides to this so

00:01:11,119 --> 00:01:15,600
first we have authentication which helps

00:01:13,520 --> 00:01:16,720
us identify that a user is who they say

00:01:15,600 --> 00:01:19,119
they are

00:01:16,720 --> 00:01:20,720
and once authenticated we want to make

00:01:19,119 --> 00:01:22,000
sure that users are only doing the

00:01:20,720 --> 00:01:22,799
things that they're allowed to do with

00:01:22,000 --> 00:01:24,320
our api

00:01:22,799 --> 00:01:26,799
given their assigned roles groups or

00:01:24,320 --> 00:01:29,119
permissions and this is what we refer to

00:01:26,799 --> 00:01:31,200
when we talk about authorization

00:01:29,119 --> 00:01:32,799
now a good place to start when deciding

00:01:31,200 --> 00:01:34,000
how we're going to handle auth with a

00:01:32,799 --> 00:01:35,759
graphql api

00:01:34,000 --> 00:01:37,439
would be to go to the graphql spec

00:01:35,759 --> 00:01:39,280
itself to see what it has to say about

00:01:37,439 --> 00:01:41,439
how we should best move forward

00:01:39,280 --> 00:01:43,119
and on the topic of auth the spec has

00:01:41,439 --> 00:01:45,520
this to say

00:01:43,119 --> 00:01:47,200
or perhaps more accurately it doesn't

00:01:45,520 --> 00:01:49,680
say anything specific about

00:01:47,200 --> 00:01:51,200
authentication or authorization at all

00:01:49,680 --> 00:01:52,960
so since we're choosing our own

00:01:51,200 --> 00:01:53,600
adventure here because there's no spec

00:01:52,960 --> 00:01:55,360
mandated

00:01:53,600 --> 00:01:56,799
mandated way to manage auth with a

00:01:55,360 --> 00:01:58,560
graphql api

00:01:56,799 --> 00:02:00,479
we can instead draw from a collection of

00:01:58,560 --> 00:02:02,000
tools and battle tested practices that

00:02:00,479 --> 00:02:03,680
have emerged over the years

00:02:02,000 --> 00:02:06,960
that will help guide us towards locking

00:02:03,680 --> 00:02:10,080
down our graphql api with confidence

00:02:06,960 --> 00:02:11,599
so let's start with authentication i

00:02:10,080 --> 00:02:13,520
find that a demo is often worth a

00:02:11,599 --> 00:02:14,560
thousand slides so i'm going to quickly

00:02:13,520 --> 00:02:15,760
set the scene here

00:02:14,560 --> 00:02:17,520
and then take you through some code

00:02:15,760 --> 00:02:20,640
examples so we can see some of these

00:02:17,520 --> 00:02:23,200
concepts in live action

00:02:20,640 --> 00:02:26,000
so first of all we're not going to lock

00:02:23,200 --> 00:02:27,440
down our entire graphql api endpoint

00:02:26,000 --> 00:02:29,760
we're typically going to want to

00:02:27,440 --> 00:02:32,160
authorize user access to our api on a

00:02:29,760 --> 00:02:33,920
per query or permutation basis

00:02:32,160 --> 00:02:36,000
and perhaps may even want to manage

00:02:33,920 --> 00:02:37,519
access more granularly on a per field

00:02:36,000 --> 00:02:39,280
level

00:02:37,519 --> 00:02:41,440
our second assumption is that we're

00:02:39,280 --> 00:02:43,519
going to use token based authentication

00:02:41,440 --> 00:02:44,480
and specifically we'll use a json web

00:02:43,519 --> 00:02:46,640
token or

00:02:44,480 --> 00:02:48,000
jot for short but you could use a

00:02:46,640 --> 00:02:50,080
similar approach with other kinds of

00:02:48,000 --> 00:02:52,160
tokens too

00:02:50,080 --> 00:02:54,080
finally we're going to use express with

00:02:52,160 --> 00:02:55,840
apollo server because it will simplify

00:02:54,080 --> 00:02:58,000
the jot handling and verification

00:02:55,840 --> 00:03:00,159
process with some ready-made middleware

00:02:58,000 --> 00:03:02,480
but it's not explicitly necessary to use

00:03:00,159 --> 00:03:04,319
express or any specific kind

00:03:02,480 --> 00:03:06,319
or any specific kind of node middleware

00:03:04,319 --> 00:03:08,480
to do this

00:03:06,319 --> 00:03:10,879
now one last thing before we jump into

00:03:08,480 --> 00:03:12,879
the demo if you're new to jots a typical

00:03:10,879 --> 00:03:14,000
json web token will look something like

00:03:12,879 --> 00:03:15,760
this

00:03:14,000 --> 00:03:17,440
and if you look closely at the string of

00:03:15,760 --> 00:03:19,120
characters you'll see that it consists

00:03:17,440 --> 00:03:20,480
of three parts that are delimited by

00:03:19,120 --> 00:03:22,640
periods

00:03:20,480 --> 00:03:24,640
first we have the header and the header

00:03:22,640 --> 00:03:27,760
will typically contain the token type

00:03:24,640 --> 00:03:29,920
and the algorithm used to sign the token

00:03:27,760 --> 00:03:31,280
in the middle we have the payload and

00:03:29,920 --> 00:03:31,840
here we'll find claims about a

00:03:31,280 --> 00:03:34,000
particular

00:03:31,840 --> 00:03:36,400
entity and the entity that we're dealing

00:03:34,000 --> 00:03:38,400
with in our case will be a user

00:03:36,400 --> 00:03:40,480
now the jot specification has some

00:03:38,400 --> 00:03:42,400
predefined registered claims and we can

00:03:40,480 --> 00:03:43,760
see examples of those here in the form

00:03:42,400 --> 00:03:46,000
of the issue.time

00:03:43,760 --> 00:03:48,159
the expiration time and the subject

00:03:46,000 --> 00:03:49,680
claim which for us refers to the user's

00:03:48,159 --> 00:03:51,840
unique id

00:03:49,680 --> 00:03:53,439
and we can also add some custom claims

00:03:51,840 --> 00:03:55,040
of our own to a jaw in the form of

00:03:53,439 --> 00:03:56,560
public or private claims

00:03:55,040 --> 00:03:58,400
and we're going to add a private claim

00:03:56,560 --> 00:04:01,680
to our dot which will name space using

00:03:58,400 --> 00:04:03,920
the url of our graphql api

00:04:01,680 --> 00:04:05,760
lastly we have the signature and this

00:04:03,920 --> 00:04:07,360
part of the token helps us verify that

00:04:05,760 --> 00:04:09,280
no information was changed during the

00:04:07,360 --> 00:04:10,400
token's transmission by hashing together

00:04:09,280 --> 00:04:12,640
the token header

00:04:10,400 --> 00:04:14,080
its payload and a secret and we can see

00:04:12,640 --> 00:04:17,040
an example of how that might be

00:04:14,080 --> 00:04:19,359
implemented here in pseudocode

00:04:17,040 --> 00:04:20,400
now as a final note even though a jot

00:04:19,359 --> 00:04:23,040
may look encrypted

00:04:20,400 --> 00:04:25,120
it's just base64 encoded to make it as

00:04:23,040 --> 00:04:26,960
compact as possible for transmission

00:04:25,120 --> 00:04:29,360
which means all the information inside

00:04:26,960 --> 00:04:31,440
can be just as easily decoded again

00:04:29,360 --> 00:04:33,280
so it's important not to put any secret

00:04:31,440 --> 00:04:35,759
information inside of the jot header or

00:04:33,280 --> 00:04:37,280
payload

00:04:35,759 --> 00:04:39,199
all right we're ready to jump into our

00:04:37,280 --> 00:04:41,120
demo so

00:04:39,199 --> 00:04:43,120
jumping into vs code you can see here

00:04:41,120 --> 00:04:45,199
that we have a very basic apollo server

00:04:43,120 --> 00:04:47,199
setup using express

00:04:45,199 --> 00:04:48,960
and in our type definitions we have a

00:04:47,199 --> 00:04:49,680
single object type defined here called

00:04:48,960 --> 00:04:51,440
user

00:04:49,680 --> 00:04:53,919
along with a corresponding query to get

00:04:51,440 --> 00:04:56,320
a single user by their id

00:04:53,919 --> 00:04:58,240
and in our resolvers we can see that

00:04:56,320 --> 00:04:59,840
we're pulling some mock data from a file

00:04:58,240 --> 00:05:02,080
called data js

00:04:59,840 --> 00:05:03,680
and in that file we have two different

00:05:02,080 --> 00:05:05,680
users and each of them have different

00:05:03,680 --> 00:05:07,680
roles and permissions assigned to them

00:05:05,680 --> 00:05:09,440
and of course for demonstration purposes

00:05:07,680 --> 00:05:10,960
only we have their passwords hard coded

00:05:09,440 --> 00:05:13,360
here in clear text

00:05:10,960 --> 00:05:15,039
now our first step is going to be to add

00:05:13,360 --> 00:05:15,759
some jot checking middleware to our

00:05:15,039 --> 00:05:17,759
server

00:05:15,759 --> 00:05:19,360
and for that we can use a package called

00:05:17,759 --> 00:05:21,840
expressjock which i have already

00:05:19,360 --> 00:05:21,840
installed

00:05:23,280 --> 00:05:28,240
so if we go ahead and run our first step

00:05:25,919 --> 00:05:28,240
here

00:05:30,240 --> 00:05:34,320
i'll highlight the code so we can see

00:05:31,919 --> 00:05:35,759
what changed so for this step

00:05:34,320 --> 00:05:38,080
we can see that we've now imported the

00:05:35,759 --> 00:05:40,080
middleware and we call that expressjot

00:05:38,080 --> 00:05:41,039
function and pass in a secret string to

00:05:40,080 --> 00:05:42,800
sign the draw

00:05:41,039 --> 00:05:44,479
and again for demonstration purposes

00:05:42,800 --> 00:05:45,919
only we're adding the sensitive value

00:05:44,479 --> 00:05:47,520
directly into the file

00:05:45,919 --> 00:05:50,000
but typically we would store something

00:05:47,520 --> 00:05:52,240
like this in an environment variable

00:05:50,000 --> 00:05:53,919
we also specify the signing algorithm to

00:05:52,240 --> 00:05:55,680
be hs256

00:05:53,919 --> 00:05:56,960
which is a symmetric signing algorithm

00:05:55,680 --> 00:05:57,600
meaning that we'll need to use this

00:05:56,960 --> 00:05:59,520
secret

00:05:57,600 --> 00:06:01,600
both when we create a user's jot and

00:05:59,520 --> 00:06:03,600
when we verify it

00:06:01,600 --> 00:06:05,360
and lastly we set the credentials

00:06:03,600 --> 00:06:07,039
required option to false so express

00:06:05,360 --> 00:06:08,080
won't throw an error if a jot hasn't

00:06:07,039 --> 00:06:09,680
been included

00:06:08,080 --> 00:06:11,199
which would be the case when a user

00:06:09,680 --> 00:06:13,199
initially logs in

00:06:11,199 --> 00:06:15,440
or potentially when graphql playground

00:06:13,199 --> 00:06:16,880
pulls for schema updates

00:06:15,440 --> 00:06:18,960
and if you're wondering what kind of

00:06:16,880 --> 00:06:20,880
magic is happening under the hood here

00:06:18,960 --> 00:06:22,240
the middleware we just added to express

00:06:20,880 --> 00:06:23,919
will get the token from the

00:06:22,240 --> 00:06:24,880
authorization header of an incoming

00:06:23,919 --> 00:06:27,440
request

00:06:24,880 --> 00:06:29,759
decode it and then add it to the request

00:06:27,440 --> 00:06:32,319
object as a user property

00:06:29,759 --> 00:06:35,600
okay we're ready for step two now so

00:06:32,319 --> 00:06:38,960
i'll go ahead and add that code

00:06:35,600 --> 00:06:38,960
and if we scroll down

00:06:39,280 --> 00:06:43,360
i'll highlight the code changes and we

00:06:41,520 --> 00:06:46,000
can see that we're now taking advantage

00:06:43,360 --> 00:06:47,759
of apollo servers context option

00:06:46,000 --> 00:06:50,160
so once the middleware has added the

00:06:47,759 --> 00:06:52,240
decoded token to the request object

00:06:50,160 --> 00:06:53,919
we can use apollo servers context to

00:06:52,240 --> 00:06:55,039
pass this data down the graph to the

00:06:53,919 --> 00:06:56,880
resolvers

00:06:55,039 --> 00:06:59,680
and it's a common practice to add

00:06:56,880 --> 00:07:01,360
decoded tokens to apollo servers context

00:06:59,680 --> 00:07:03,120
because this object is conveniently

00:07:01,360 --> 00:07:05,360
available in every resolver

00:07:03,120 --> 00:07:06,880
and it's recreated with every request so

00:07:05,360 --> 00:07:08,240
we won't have to worry about tokens

00:07:06,880 --> 00:07:11,039
going stale

00:07:08,240 --> 00:07:11,919
so here we check for the user object in

00:07:11,039 --> 00:07:14,000
the request

00:07:11,919 --> 00:07:15,280
and add it to the apollo server context

00:07:14,000 --> 00:07:17,280
if it exists

00:07:15,280 --> 00:07:18,960
otherwise we just set user to null

00:07:17,280 --> 00:07:20,880
because we don't want to error out if a

00:07:18,960 --> 00:07:23,039
token isn't available

00:07:20,880 --> 00:07:25,440
so now that we can handle an incoming

00:07:23,039 --> 00:07:27,199
token we need a way to create one in the

00:07:25,440 --> 00:07:29,680
first place when a user wants to log

00:07:27,199 --> 00:07:30,960
in and this actually brings us to a very

00:07:29,680 --> 00:07:32,880
big question

00:07:30,960 --> 00:07:34,800
should authentication be handled within

00:07:32,880 --> 00:07:37,360
the graphql server itself

00:07:34,800 --> 00:07:39,120
or is this out of band now some people

00:07:37,360 --> 00:07:41,360
say we should leave authentication

00:07:39,120 --> 00:07:43,360
entirely out of the schema in other

00:07:41,360 --> 00:07:46,400
words we shouldn't have login or

00:07:43,360 --> 00:07:48,080
logout mutations and that would mean we

00:07:46,400 --> 00:07:49,520
just have the decoded token data

00:07:48,080 --> 00:07:51,919
available in the context

00:07:49,520 --> 00:07:53,360
and we leave it at that and i would say

00:07:51,919 --> 00:07:54,960
in practice there's a very high

00:07:53,360 --> 00:07:57,199
likelihood that you would want to use

00:07:54,960 --> 00:07:59,440
some kind of dedicated auth service

00:07:57,199 --> 00:08:01,039
and perhaps even use something like off0

00:07:59,440 --> 00:08:02,000
to manage your app's authentication

00:08:01,039 --> 00:08:04,160
needs

00:08:02,000 --> 00:08:06,080
but to keep things simple let's

00:08:04,160 --> 00:08:07,919
implement a login mutation here so we

00:08:06,080 --> 00:08:09,039
can get a sense of how the job would be

00:08:07,919 --> 00:08:12,479
created

00:08:09,039 --> 00:08:14,319
so we'll move on to our third step

00:08:12,479 --> 00:08:17,039
and i'm going to jump over to our type

00:08:14,319 --> 00:08:17,039
definitions

00:08:17,520 --> 00:08:22,240
and now that the code has been added we

00:08:19,680 --> 00:08:23,840
can see that we now have a mutation here

00:08:22,240 --> 00:08:26,479
for logging a user in

00:08:23,840 --> 00:08:27,840
and that mutation takes an email and a

00:08:26,479 --> 00:08:29,120
password as arguments

00:08:27,840 --> 00:08:30,879
because we're just going to use

00:08:29,120 --> 00:08:31,919
password-based authentication for this

00:08:30,879 --> 00:08:33,839
api

00:08:31,919 --> 00:08:35,200
you'll see that our login mutation also

00:08:33,839 --> 00:08:37,200
returns a string type

00:08:35,200 --> 00:08:38,880
and that string is going to be the json

00:08:37,200 --> 00:08:40,719
web token that we create inside of the

00:08:38,880 --> 00:08:43,919
resolver

00:08:40,719 --> 00:08:45,519
now moving on to our resolvers

00:08:43,919 --> 00:08:47,440
we'll take a look at what just changed

00:08:45,519 --> 00:08:50,720
here

00:08:47,440 --> 00:08:52,720
and you'll see that to log user in

00:08:50,720 --> 00:08:54,640
we find the user in our database whose

00:08:52,720 --> 00:08:55,519
email and password match the incoming

00:08:54,640 --> 00:08:57,200
arguments

00:08:55,519 --> 00:08:59,120
and then we use the json web token

00:08:57,200 --> 00:08:59,920
package to create and sign a jot for

00:08:59,120 --> 00:09:02,320
them

00:08:59,920 --> 00:09:03,279
and the first argument we pass into the

00:09:02,320 --> 00:09:04,959
sign method

00:09:03,279 --> 00:09:06,560
is an object containing the jot

00:09:04,959 --> 00:09:08,160
information we want to add to the

00:09:06,560 --> 00:09:09,920
payload of the token

00:09:08,160 --> 00:09:12,080
and because we're adding some custom

00:09:09,920 --> 00:09:14,240
info as a private claim to this token

00:09:12,080 --> 00:09:16,320
again we name space it using the url of

00:09:14,240 --> 00:09:17,920
the graphql api as a property

00:09:16,320 --> 00:09:20,160
with the user's permissions and roles

00:09:17,920 --> 00:09:22,160
inside of an object as a value

00:09:20,160 --> 00:09:24,160
as a second argument to the sign method

00:09:22,160 --> 00:09:26,880
we also have to pass in the same secret

00:09:24,160 --> 00:09:29,279
that we used before to verify our tokens

00:09:26,880 --> 00:09:31,120
and as a third option we can also pass

00:09:29,279 --> 00:09:33,040
in some additional data such as the

00:09:31,120 --> 00:09:36,000
unique subject value for the token

00:09:33,040 --> 00:09:37,040
which again is the user's id and a token

00:09:36,000 --> 00:09:39,680
expiration time

00:09:37,040 --> 00:09:40,240
and the signing algorithm we want to use

00:09:39,680 --> 00:09:42,560
all right

00:09:40,240 --> 00:09:44,640
we have one last step to run before we

00:09:42,560 --> 00:09:46,880
can try out our api

00:09:44,640 --> 00:09:48,399
so i'm going to hop back over to our

00:09:46,880 --> 00:09:51,360
type definitions

00:09:48,399 --> 00:09:52,880
and we can see here that we've now also

00:09:51,360 --> 00:09:54,959
added a viewer query

00:09:52,880 --> 00:09:56,560
and this query is going to allow us to

00:09:54,959 --> 00:09:57,519
retrieve an authenticated user's

00:09:56,560 --> 00:10:00,240
information

00:09:57,519 --> 00:10:01,600
based on the data in their token and as

00:10:00,240 --> 00:10:03,600
a little sidebar here

00:10:01,600 --> 00:10:05,360
it's a good practice to expose a viewer

00:10:03,600 --> 00:10:07,200
query that acts like an entry point for

00:10:05,360 --> 00:10:08,399
what authenticated users can do with

00:10:07,200 --> 00:10:10,079
your api

00:10:08,399 --> 00:10:12,399
and if we were to fully realize that

00:10:10,079 --> 00:10:14,399
here we could add a viewer object type

00:10:12,399 --> 00:10:15,040
to use as the return type for the viewer

00:10:14,399 --> 00:10:17,440
query

00:10:15,040 --> 00:10:18,079
instead of using the user type and then

00:10:17,440 --> 00:10:20,160
expose

00:10:18,079 --> 00:10:22,320
fields on that type that allow an

00:10:20,160 --> 00:10:23,440
authenticated user to query for relevant

00:10:22,320 --> 00:10:25,600
data

00:10:23,440 --> 00:10:27,440
now that's a bit out of scope for what

00:10:25,600 --> 00:10:29,440
we're doing here today but i encourage

00:10:27,440 --> 00:10:32,560
you to take a look at the github graphql

00:10:29,440 --> 00:10:37,440
api for a working implementation of this

00:10:32,560 --> 00:10:37,440
now lastly over in our resolvers

00:10:37,519 --> 00:10:41,760
we can see that in the resolver for this

00:10:39,360 --> 00:10:42,880
query we get the currently authenticated

00:10:41,760 --> 00:10:44,880
user's information

00:10:42,880 --> 00:10:47,200
by using their id value which is

00:10:44,880 --> 00:10:47,680
available in the subclaim of the decoded

00:10:47,200 --> 00:10:50,640
token

00:10:47,680 --> 00:10:51,680
in the context object parameter so with

00:10:50,640 --> 00:10:54,160
this code in place

00:10:51,680 --> 00:10:57,040
we're ready to try out our api so let's

00:10:54,160 --> 00:10:59,680
hop over to graphql playground

00:10:57,040 --> 00:11:01,920
and in graphql playground you can see

00:10:59,680 --> 00:11:03,839
that i've set up a login mutation to log

00:11:01,920 --> 00:11:06,720
in our neil armstrong user

00:11:03,839 --> 00:11:08,880
so if we go ahead and run that mutation

00:11:06,720 --> 00:11:11,760
we can see that we do in fact get back a

00:11:08,880 --> 00:11:15,600
json web token in the response

00:11:11,760 --> 00:11:18,480
so i can go ahead and grab that token

00:11:15,600 --> 00:11:19,279
copy it and hop over to a viewer query

00:11:18,480 --> 00:11:21,839
here

00:11:19,279 --> 00:11:22,800
and in the http headers panel here i'm

00:11:21,839 --> 00:11:25,920
going to add an

00:11:22,800 --> 00:11:25,920
authorization header

00:11:26,320 --> 00:11:29,839
and i'm going to set its value to be a

00:11:28,320 --> 00:11:31,760
string

00:11:29,839 --> 00:11:34,000
which starts with the word bearer has a

00:11:31,760 --> 00:11:34,959
space and then is preceded by the json

00:11:34,000 --> 00:11:37,040
web token

00:11:34,959 --> 00:11:39,440
and we can go ahead and run that query

00:11:37,040 --> 00:11:41,360
and we see that as we expect we get back

00:11:39,440 --> 00:11:43,200
the neil armstrong user

00:11:41,360 --> 00:11:45,200
all right this is looking pretty good as

00:11:43,200 --> 00:11:46,880
far as logging in users go

00:11:45,200 --> 00:11:48,399
but before we can finish locking down

00:11:46,880 --> 00:11:50,480
our graphql api

00:11:48,399 --> 00:11:51,680
we need to understand a few things about

00:11:50,480 --> 00:11:53,279
authorization

00:11:51,680 --> 00:11:55,600
because while we now have a way to

00:11:53,279 --> 00:11:57,760
identify users based on their tokens

00:11:55,600 --> 00:12:00,720
we still don't have any mechanism to

00:11:57,760 --> 00:12:03,920
limit api access to authenticated users

00:12:00,720 --> 00:12:06,560
and this is where authorization comes in

00:12:03,920 --> 00:12:08,560
now the most basic level authorization

00:12:06,560 --> 00:12:10,560
is letting users run queries based on

00:12:08,560 --> 00:12:12,079
whether or not they're authenticated

00:12:10,560 --> 00:12:13,600
and we're going to do this but we're

00:12:12,079 --> 00:12:15,440
also going to add finer grind

00:12:13,600 --> 00:12:17,279
authorization to our queries based on

00:12:15,440 --> 00:12:18,720
the permissions in the logged in user's

00:12:17,279 --> 00:12:20,480
jot

00:12:18,720 --> 00:12:22,399
now when adding authorization to a

00:12:20,480 --> 00:12:23,760
graphql api we have a few different

00:12:22,399 --> 00:12:25,040
options at hand

00:12:23,760 --> 00:12:27,120
we could directly check the

00:12:25,040 --> 00:12:28,639
authenticated user's id and permissions

00:12:27,120 --> 00:12:30,880
inside of each resolver

00:12:28,639 --> 00:12:33,680
but this wouldn't be very dry so let's

00:12:30,880 --> 00:12:36,160
just count that option as off the table

00:12:33,680 --> 00:12:37,040
instead one popular option for adding

00:12:36,160 --> 00:12:38,880
authorization

00:12:37,040 --> 00:12:40,639
involves adding custom schema directives

00:12:38,880 --> 00:12:41,839
to control access to various types and

00:12:40,639 --> 00:12:43,920
fields

00:12:41,839 --> 00:12:46,079
alternatively we could use a package

00:12:43,920 --> 00:12:47,839
like graphql auth to wrap our resolver

00:12:46,079 --> 00:12:49,040
functions explicitly with permission

00:12:47,839 --> 00:12:51,120
checks

00:12:49,040 --> 00:12:52,720
or we could use a package like graphql

00:12:51,120 --> 00:12:54,560
shield to completely abstract the

00:12:52,720 --> 00:12:55,279
authorization rules into a middleware

00:12:54,560 --> 00:12:57,519
layer

00:12:55,279 --> 00:12:58,639
and for our api today this is what we're

00:12:57,519 --> 00:13:01,600
going to choose

00:12:58,639 --> 00:13:03,279
now i'll jump back over to vs code here

00:13:01,600 --> 00:13:06,320
and the first thing we're going to do

00:13:03,279 --> 00:13:08,079
is run our next step and when this code

00:13:06,320 --> 00:13:10,320
is added we'll see that we now have a

00:13:08,079 --> 00:13:12,880
new file called permissions.js

00:13:10,320 --> 00:13:13,360
and this file is going to be where we

00:13:12,880 --> 00:13:15,200
manage

00:13:13,360 --> 00:13:16,880
all of the authorization rules for our

00:13:15,200 --> 00:13:18,880
api

00:13:16,880 --> 00:13:20,399
and before we import and use anything

00:13:18,880 --> 00:13:21,600
from graphql shield which i've

00:13:20,399 --> 00:13:22,959
pre-installed

00:13:21,600 --> 00:13:24,800
you'll see that we've created a little

00:13:22,959 --> 00:13:26,800
helper function here that we'll use to

00:13:24,800 --> 00:13:29,120
check if a decoded user token has a

00:13:26,800 --> 00:13:32,320
particular permission applied

00:13:29,120 --> 00:13:34,560
and if i go ahead and run our next step

00:13:32,320 --> 00:13:35,839
you'll see that we import a few things

00:13:34,560 --> 00:13:37,200
from graphql shield

00:13:35,839 --> 00:13:39,519
that are going to help us apply

00:13:37,200 --> 00:13:41,279
authorization rules to our schema

00:13:39,519 --> 00:13:42,720
and first we're going to focus on the

00:13:41,279 --> 00:13:44,399
role function which has the same

00:13:42,720 --> 00:13:45,120
parameters as a typical resolver

00:13:44,399 --> 00:13:47,600
function

00:13:45,120 --> 00:13:49,199
including the context and we're going to

00:13:47,600 --> 00:13:51,600
use this rule function to

00:13:49,199 --> 00:13:52,240
not surprisingly create an authorization

00:13:51,600 --> 00:13:54,320
role

00:13:52,240 --> 00:13:55,839
and the first one that we create here

00:13:54,320 --> 00:13:57,680
allows us to check if the user is

00:13:55,839 --> 00:14:00,639
authenticated by verifying that the

00:13:57,680 --> 00:14:02,480
decoded jot is present in the context

00:14:00,639 --> 00:14:04,160
and how this rule function works is that

00:14:02,480 --> 00:14:07,120
if we return false from the rule

00:14:04,160 --> 00:14:09,519
then the authorization will be denied so

00:14:07,120 --> 00:14:11,279
now we can add some more complex rules

00:14:09,519 --> 00:14:14,079
that will help us check if particular

00:14:11,279 --> 00:14:16,240
permissions have been assigned to a user

00:14:14,079 --> 00:14:18,399
and if i scroll down here you'll see

00:14:16,240 --> 00:14:20,800
that the can read any user and can

00:14:18,399 --> 00:14:22,240
read own user rules each check for their

00:14:20,800 --> 00:14:24,800
corresponding permissions

00:14:22,240 --> 00:14:26,720
and return false if they don't exist and

00:14:24,800 --> 00:14:28,560
we also have the is reading own user

00:14:26,720 --> 00:14:30,560
role which verifies that the id

00:14:28,560 --> 00:14:33,440
of the user requested from the query

00:14:30,560 --> 00:14:35,120
matches the id of the authenticated user

00:14:33,440 --> 00:14:37,600
now we're ready to add the final bit of

00:14:35,120 --> 00:14:40,399
code to this permissions.js file

00:14:37,600 --> 00:14:42,079
and when we do you'll see that we now

00:14:40,399 --> 00:14:44,399
call the shield function

00:14:42,079 --> 00:14:46,720
and into this function we pass an object

00:14:44,399 --> 00:14:48,880
whose shape mirrors our resolvers

00:14:46,720 --> 00:14:50,959
so for the viewer query we only require

00:14:48,880 --> 00:14:51,760
that a user is authenticated to run that

00:14:50,959 --> 00:14:53,920
query

00:14:51,760 --> 00:14:56,160
but for the user query we employ the

00:14:53,920 --> 00:14:57,199
logical and and or functions provided by

00:14:56,160 --> 00:14:59,120
graphql shield

00:14:57,199 --> 00:15:00,240
to check a more complex configuration of

00:14:59,120 --> 00:15:02,560
rules

00:15:00,240 --> 00:15:03,760
so for this case we allow a user to run

00:15:02,560 --> 00:15:05,680
the user query

00:15:03,760 --> 00:15:07,440
if they're requesting their own user and

00:15:05,680 --> 00:15:08,399
have the read own user permission

00:15:07,440 --> 00:15:10,639
assigned to them

00:15:08,399 --> 00:15:12,000
or alternatively they can view any user

00:15:10,639 --> 00:15:14,959
if they have the read any user

00:15:12,000 --> 00:15:16,000
permission assigned to them now last but

00:15:14,959 --> 00:15:17,920
not least

00:15:16,000 --> 00:15:19,360
we have some updates we need to make to

00:15:17,920 --> 00:15:21,040
our index.js file

00:15:19,360 --> 00:15:25,600
to actually add these permissions as

00:15:21,040 --> 00:15:27,680
middleware so when we run those changes

00:15:25,600 --> 00:15:29,040
you'll see that we now must import a few

00:15:27,680 --> 00:15:30,720
new things into this file

00:15:29,040 --> 00:15:32,320
most notably the apply middleware

00:15:30,720 --> 00:15:33,040
function from the graphql middleware

00:15:32,320 --> 00:15:34,639
package

00:15:33,040 --> 00:15:37,519
as well as the permission rules we just

00:15:34,639 --> 00:15:39,199
created and if i scroll down

00:15:37,519 --> 00:15:41,360
you'll see that we've also updated our

00:15:39,199 --> 00:15:43,199
apollo server config so that instead of

00:15:41,360 --> 00:15:44,000
passing in the type devs and resolvers

00:15:43,199 --> 00:15:46,399
directly

00:15:44,000 --> 00:15:47,759
we use the schema option instead and set

00:15:46,399 --> 00:15:48,959
it to the value of calling apply

00:15:47,759 --> 00:15:51,360
middleware and applying those

00:15:48,959 --> 00:15:53,440
permissions to our schema

00:15:51,360 --> 00:15:56,399
with this code in place we're now ready

00:15:53,440 --> 00:15:58,480
to jump back over to graphql playground

00:15:56,399 --> 00:16:00,079
and if i grab the authorization header

00:15:58,480 --> 00:16:02,399
that i used for my viewer query

00:16:00,079 --> 00:16:04,399
i can paste it into the http headers

00:16:02,399 --> 00:16:07,199
panel for the user query

00:16:04,399 --> 00:16:08,079
and if i run the query using the id of

00:16:07,199 --> 00:16:10,639
the currently

00:16:08,079 --> 00:16:12,480
authenticated user you'll see that we

00:16:10,639 --> 00:16:14,160
get back the neil armstrong user

00:16:12,480 --> 00:16:17,600
information as expected

00:16:14,160 --> 00:16:19,440
however if i run the query using the id

00:16:17,600 --> 00:16:21,199
of a different user

00:16:19,440 --> 00:16:22,800
we get back a not authorized error

00:16:21,199 --> 00:16:24,560
message as we might expect

00:16:22,800 --> 00:16:26,160
because this user does not have the

00:16:24,560 --> 00:16:27,839
appropriate privileges to view any

00:16:26,160 --> 00:16:30,000
user's account

00:16:27,839 --> 00:16:31,759
and that's it in just a few short

00:16:30,000 --> 00:16:33,839
minutes we've now successfully added

00:16:31,759 --> 00:16:37,600
both authentication and authorization to

00:16:33,839 --> 00:16:39,680
our graphql api

00:16:37,600 --> 00:16:40,639
so to wrap up i'll jump back over to my

00:16:39,680 --> 00:16:42,399
slides here

00:16:40,639 --> 00:16:44,079
and before we conclude i'd like to

00:16:42,399 --> 00:16:45,600
briefly touch on how we could approach

00:16:44,079 --> 00:16:47,120
handling auth when dealing with a

00:16:45,600 --> 00:16:49,199
federated data graph

00:16:47,120 --> 00:16:50,880
and the good news is that everything we

00:16:49,199 --> 00:16:52,560
just covered can be applied to the

00:16:50,880 --> 00:16:54,480
apollo server that you configure at the

00:16:52,560 --> 00:16:56,560
gateway level of your api

00:16:54,480 --> 00:16:58,240
so in other words you can extract the

00:16:56,560 --> 00:17:00,079
token from the request and apply it to

00:16:58,240 --> 00:17:00,800
the apollo server context just as we

00:17:00,079 --> 00:17:03,120
have

00:17:00,800 --> 00:17:05,120
and we only need to do a small amount of

00:17:03,120 --> 00:17:06,959
additional configuration to pass that

00:17:05,120 --> 00:17:08,959
incoming token data along to any

00:17:06,959 --> 00:17:10,880
implementing services

00:17:08,959 --> 00:17:12,880
so to do this when configuring the

00:17:10,880 --> 00:17:15,439
gateway we can make use of the build

00:17:12,880 --> 00:17:17,280
service option to extract the decoded

00:17:15,439 --> 00:17:18,160
user token from the gateway api's

00:17:17,280 --> 00:17:19,919
context

00:17:18,160 --> 00:17:22,880
and then forward it on in the headers of

00:17:19,919 --> 00:17:24,880
the request to the implementing services

00:17:22,880 --> 00:17:26,640
then in the apollo server constructor

00:17:24,880 --> 00:17:28,640
for the implementing service

00:17:26,640 --> 00:17:29,840
we can once again extract the user from

00:17:28,640 --> 00:17:31,520
the request headers

00:17:29,840 --> 00:17:32,880
and add it to the context for that

00:17:31,520 --> 00:17:34,400
apollo server

00:17:32,880 --> 00:17:36,000
and we don't need to worry about

00:17:34,400 --> 00:17:37,280
verifying the jot again here because

00:17:36,000 --> 00:17:40,559
that would have already been done at the

00:17:37,280 --> 00:17:43,039
gateway level of the api

00:17:40,559 --> 00:17:45,120
okay so that was a bit of a whirlwind

00:17:43,039 --> 00:17:47,440
tour of handling authentication and

00:17:45,120 --> 00:17:49,120
authorization of a graphql api's queries

00:17:47,440 --> 00:17:51,280
using apollo server

00:17:49,120 --> 00:17:52,880
and specifically we saw how we can

00:17:51,280 --> 00:17:54,400
handle incoming tokens

00:17:52,880 --> 00:17:55,919
and apply them to the apollo server

00:17:54,400 --> 00:17:58,080
context we

00:17:55,919 --> 00:17:59,760
also learned that a viewer query can act

00:17:58,080 --> 00:18:01,760
as an entry point for authenticated

00:17:59,760 --> 00:18:03,280
users in your api

00:18:01,760 --> 00:18:05,120
we also saw how we can keep

00:18:03,280 --> 00:18:07,200
authorization checks directly out of

00:18:05,120 --> 00:18:08,400
resolver functions to keep this layer as

00:18:07,200 --> 00:18:10,400
thin as possible

00:18:08,400 --> 00:18:12,240
and abstract those permission checks

00:18:10,400 --> 00:18:14,720
into a middleware layer

00:18:12,240 --> 00:18:15,679
and lastly we got a sneak peek of how we

00:18:14,720 --> 00:18:18,480
can forward an

00:18:15,679 --> 00:18:19,600
incoming token from a gateway api onto

00:18:18,480 --> 00:18:21,280
an implementing service

00:18:19,600 --> 00:18:23,280
using the build service option in the

00:18:21,280 --> 00:18:24,880
gateway config

00:18:23,280 --> 00:18:26,799
now if you'd like to see the complete

00:18:24,880 --> 00:18:28,960
code for this presentation you can find

00:18:26,799 --> 00:18:30,160
it in the first repo listed here

00:18:28,960 --> 00:18:32,080
and if you'd like to see a more

00:18:30,160 --> 00:18:33,600
extensive example of how to add auth

00:18:32,080 --> 00:18:35,200
with apollo federation

00:18:33,600 --> 00:18:36,799
i'd recommend checking out the second

00:18:35,200 --> 00:18:39,120
repo link and

00:18:36,799 --> 00:18:41,120
finally you can see an example of how to

00:18:39,120 --> 00:18:43,280
handle auth with a graphql api

00:18:41,120 --> 00:18:44,960
using passwordless authentication and a

00:18:43,280 --> 00:18:48,160
decentralized identity token

00:18:44,960 --> 00:18:49,760
in the third repo okay so thanks again

00:18:48,160 --> 00:18:53,039
so much to everyone for coming today and

00:18:49,760 --> 00:18:55,520
i'd be happy to take some questions now

00:18:53,039 --> 00:18:57,520
hi everyone i have some time to take a

00:18:55,520 --> 00:19:00,320
few questions now

00:18:57,520 --> 00:19:01,600
so i see if you've come in here um the

00:19:00,320 --> 00:19:04,400
first one i'll tackle

00:19:01,600 --> 00:19:05,200
is in the login mutation uh what if i

00:19:04,400 --> 00:19:08,320
need to

00:19:05,200 --> 00:19:09,200
redirect a user so that one came in from

00:19:08,320 --> 00:19:12,880
twitch

00:19:09,200 --> 00:19:15,679
and to that i would say if you need to

00:19:12,880 --> 00:19:16,799
redirect a user after a login mutation

00:19:15,679 --> 00:19:17,919
then this is likely something you're

00:19:16,799 --> 00:19:20,320
going to want to handle

00:19:17,919 --> 00:19:22,400
uh client-side after the mutation has

00:19:20,320 --> 00:19:25,120
successfully completed so

00:19:22,400 --> 00:19:26,799
that's going to be completely dependent

00:19:25,120 --> 00:19:28,960
on your specific use case with what

00:19:26,799 --> 00:19:32,640
you're doing with your client

00:19:28,960 --> 00:19:35,200
um we have another question here

00:19:32,640 --> 00:19:37,039
when it comes to auth is it better to

00:19:35,200 --> 00:19:38,880
lock down the whole api

00:19:37,039 --> 00:19:41,039
and have users hit a different endpoint

00:19:38,880 --> 00:19:43,520
to log in or do you think

00:19:41,039 --> 00:19:45,120
it's fine to have a public mutation and

00:19:43,520 --> 00:19:48,160
this question came in from kurt

00:19:45,120 --> 00:19:51,760
so again i'm going to say it depends

00:19:48,160 --> 00:19:52,320
um but i would say what i've typically

00:19:51,760 --> 00:19:55,280
seen

00:19:52,320 --> 00:19:57,600
with respect to login mutations is that

00:19:55,280 --> 00:19:59,360
these mutations have been public

00:19:57,600 --> 00:20:00,799
but i would qualify that with also

00:19:59,360 --> 00:20:02,559
saying that when i'm

00:20:00,799 --> 00:20:04,000
adding authentication and authorization

00:20:02,559 --> 00:20:06,880
to a graphql api

00:20:04,000 --> 00:20:07,440
i am most typically using a third-party

00:20:06,880 --> 00:20:10,559
service

00:20:07,440 --> 00:20:12,400
like all ceara for instance uh to handle

00:20:10,559 --> 00:20:14,159
all of those authentication concerns

00:20:12,400 --> 00:20:16,000
completely outside the context of the

00:20:14,159 --> 00:20:19,280
graphql api

00:20:16,000 --> 00:20:21,039
and then i control access to the api

00:20:19,280 --> 00:20:22,720
using middleware like graphql shield

00:20:21,039 --> 00:20:24,240
like you saw in the talk

00:20:22,720 --> 00:20:26,640
to then parse those permissions and

00:20:24,240 --> 00:20:28,080
roles as needed throughout the schema on

00:20:26,640 --> 00:20:31,679
a per field

00:20:28,080 --> 00:20:31,679
or per type basis

00:20:32,159 --> 00:20:36,000
all right so we have another question

00:20:34,559 --> 00:20:38,320
here from kurt which is

00:20:36,000 --> 00:20:39,280
uh what are your thoughts about allowing

00:20:38,320 --> 00:20:42,720
introspection

00:20:39,280 --> 00:20:45,120
of auth graphql apis so i would say

00:20:42,720 --> 00:20:45,760
it's probably almost certainly a good

00:20:45,120 --> 00:20:48,799
idea to

00:20:45,760 --> 00:20:51,200
shut off introspection in production so

00:20:48,799 --> 00:20:53,840
um yeah if at all possible leave

00:20:51,200 --> 00:20:56,960
introspection off

00:20:53,840 --> 00:21:01,280
um let's see what else we have for

00:20:56,960 --> 00:21:04,640
questions here uh

00:21:01,280 --> 00:21:04,640
over to twitch

00:21:08,640 --> 00:21:14,240
uh let's see so here's a

00:21:12,000 --> 00:21:16,720
an interesting one from arvel what do

00:21:14,240 --> 00:21:18,559
you consider to be the key advantages of

00:21:16,720 --> 00:21:21,679
using graphql shield

00:21:18,559 --> 00:21:25,440
over using auth directives and

00:21:21,679 --> 00:21:26,880
i would say um and this is a

00:21:25,440 --> 00:21:28,960
perhaps a matter of personal preference

00:21:26,880 --> 00:21:32,720
but i really like when

00:21:28,960 --> 00:21:34,960
the authorization rules are abstracted

00:21:32,720 --> 00:21:36,400
uh away from the schema and like

00:21:34,960 --> 00:21:37,679
completely away from the type

00:21:36,400 --> 00:21:40,159
definitions so that they

00:21:37,679 --> 00:21:41,919
can be handily separately in their own

00:21:40,159 --> 00:21:43,919
layer so

00:21:41,919 --> 00:21:45,840
perhaps if you are building a schema

00:21:43,919 --> 00:21:48,080
where you feel like it's okay

00:21:45,840 --> 00:21:49,919
to have those kinds of authorization

00:21:48,080 --> 00:21:50,960
rules uh intermingling directly with

00:21:49,919 --> 00:21:52,080
your scheme in the form of those

00:21:50,960 --> 00:21:54,640
directives

00:21:52,080 --> 00:21:55,440
that's fine but for me personally i like

00:21:54,640 --> 00:21:57,919
to have

00:21:55,440 --> 00:22:01,840
all of my authorization roles completely

00:21:57,919 --> 00:22:03,440
abstracted away into a separate layer

00:22:01,840 --> 00:22:06,320
let's see what else we have for

00:22:03,440 --> 00:22:06,320
questions here

00:22:11,679 --> 00:22:18,559
so here's a question from cindy uh how

00:22:15,200 --> 00:22:21,200
does field level auth look like uh do

00:22:18,559 --> 00:22:25,600
you recommend responding with a per

00:22:21,200 --> 00:22:28,240
field error so that will depend on

00:22:25,600 --> 00:22:30,000
what route you take with respect to

00:22:28,240 --> 00:22:31,520
handling authorization rules in your

00:22:30,000 --> 00:22:34,960
schema

00:22:31,520 --> 00:22:39,120
with graphql shields as was demoed in

00:22:34,960 --> 00:22:41,440
the uh the presentation there

00:22:39,120 --> 00:22:42,640
they kind of take an all-or-nothing

00:22:41,440 --> 00:22:45,280
approach to

00:22:42,640 --> 00:22:46,960
delivering an error to a user so if uh

00:22:45,280 --> 00:22:48,159
some kind of error occurs you get a

00:22:46,960 --> 00:22:51,200
generalized

00:22:48,159 --> 00:22:53,919
not authorized message um

00:22:51,200 --> 00:22:56,080
so it's i guess a bit ham-handed in that

00:22:53,919 --> 00:22:58,080
sense you can customize the error

00:22:56,080 --> 00:22:59,120
uh there is some mechanism in the api to

00:22:58,080 --> 00:23:01,280
do that

00:22:59,120 --> 00:23:02,799
uh but it is uh kind of

00:23:01,280 --> 00:23:05,760
one-size-fits-all in terms of

00:23:02,799 --> 00:23:07,600
delivering people errors so um again if

00:23:05,760 --> 00:23:08,799
you need more granular reporting as to

00:23:07,600 --> 00:23:11,039
like what kind of

00:23:08,799 --> 00:23:11,919
uh authorization error might have been

00:23:11,039 --> 00:23:14,080
triggered uh

00:23:11,919 --> 00:23:17,440
in your in your query then you might

00:23:14,080 --> 00:23:20,880
want to take a different approach there

00:23:17,440 --> 00:23:24,640
um let's see what other

00:23:20,880 --> 00:23:24,640
questions can we tackle here

00:23:27,120 --> 00:23:30,590
[Music]

00:23:32,799 --> 00:23:36,240
so there's another question from kurt

00:23:35,360 --> 00:23:39,039
here

00:23:36,240 --> 00:23:41,039
what do you think about using scopes for

00:23:39,039 --> 00:23:44,080
finer grained authorization

00:23:41,039 --> 00:23:45,120
and yes again that's from kurt and i

00:23:44,080 --> 00:23:47,600
would say

00:23:45,120 --> 00:23:50,240
that depends on your use case as well

00:23:47,600 --> 00:23:53,200
and just how you need to build out uh

00:23:50,240 --> 00:23:54,960
permissions and uh roles and groups and

00:23:53,200 --> 00:23:55,679
whatever else you might need to account

00:23:54,960 --> 00:23:59,200
for on

00:23:55,679 --> 00:24:01,200
the uh the authorization side of your

00:23:59,200 --> 00:24:04,159
authentication service so

00:24:01,200 --> 00:24:05,440
uh again it's i find it a bit tricky to

00:24:04,159 --> 00:24:08,480
answer that question

00:24:05,440 --> 00:24:12,240
in a generalized way so i'll

00:24:08,480 --> 00:24:17,279
say it depends for that one as well

00:24:12,240 --> 00:24:17,279
um let's see

00:24:17,360 --> 00:24:22,480
let's do one final question here

00:24:20,830 --> 00:24:23,070
[Music]

00:24:22,480 --> 00:24:26,000
um

00:24:23,070 --> 00:24:28,159
[Music]

00:24:26,000 --> 00:24:29,039
so i have a question here uh and i

00:24:28,159 --> 00:24:30,960
apologize if i

00:24:29,039 --> 00:24:32,799
mispronounced the name but i think it's

00:24:30,960 --> 00:24:35,279
from reagan

00:24:32,799 --> 00:24:36,320
and the question is at the initial load

00:24:35,279 --> 00:24:39,679
of playground

00:24:36,320 --> 00:24:43,679
how does the system allow for mutations

00:24:39,679 --> 00:24:43,679
with a token so

00:24:43,919 --> 00:24:47,600
as far as the example goes that i showed

00:24:46,240 --> 00:24:48,799
in the presentation that's something

00:24:47,600 --> 00:24:52,640
that needs to be

00:24:48,799 --> 00:24:54,640
manually added into the uh

00:24:52,640 --> 00:24:56,880
the authorization header in the http

00:24:54,640 --> 00:24:59,919
headers of graphql playground

00:24:56,880 --> 00:25:00,480
um okay so that's about all the time i

00:24:59,919 --> 00:25:01,840
have

00:25:00,480 --> 00:25:15,840
uh so we'll have to wrap it up here

00:25:01,840 --> 00:25:15,840
thanks so much everyone

00:25:17,600 --> 00:25:19,679

YouTube URL: https://www.youtube.com/watch?v=dBuU61ABEDs


