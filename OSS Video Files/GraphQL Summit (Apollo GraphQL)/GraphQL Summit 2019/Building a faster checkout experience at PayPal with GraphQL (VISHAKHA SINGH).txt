Title: Building a faster checkout experience at PayPal with GraphQL (VISHAKHA SINGH)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	At PayPal, we are rebuilding our checkout experience from the ground up. The most important and logical problem we are solving is to make the experience super fast. Come hear our story on how we leveraged GraphQL server to efficiently present varied regional payment experiences to people all around the globe.
Captions: 
	00:00:02,270 --> 00:00:10,250
hi everyone before I start I wanted to

00:00:07,700 --> 00:00:14,330
ask a question to you all guys in the

00:00:10,250 --> 00:00:18,080
audience how many of you have used

00:00:14,330 --> 00:00:21,500
PayPal to pay for things on websites in

00:00:18,080 --> 00:00:23,600
recent times Wow

00:00:21,500 --> 00:00:28,700
in recent times I mean of back a few

00:00:23,600 --> 00:00:32,200
months alright my name is Lou Shaka and

00:00:28,700 --> 00:00:35,269
I would be talking about how we build

00:00:32,200 --> 00:00:40,300
faster checkout experience at PayPal

00:00:35,269 --> 00:00:43,399
using graph QL wow that's a lot of

00:00:40,300 --> 00:00:46,789
buttons on the screen some of them looks

00:00:43,399 --> 00:00:49,309
they look fairly 90s and I cringe add

00:00:46,789 --> 00:00:51,469
them every time I look at them this is

00:00:49,309 --> 00:00:53,929
the state we are coming from this is a

00:00:51,469 --> 00:00:57,339
few years back some of them were created

00:00:53,929 --> 00:00:59,510
by us some of them were created by

00:00:57,339 --> 00:01:01,159
merchants hoping to customize their

00:00:59,510 --> 00:01:02,510
checkout experience and some of them

00:01:01,159 --> 00:01:08,240
should have never seen the light of the

00:01:02,510 --> 00:01:11,690
day and this is where we are at now so

00:01:08,240 --> 00:01:15,170
we re architected our entire PayPal

00:01:11,690 --> 00:01:19,790
checkout integrations three years back

00:01:15,170 --> 00:01:21,740
and what we basically did was open

00:01:19,790 --> 00:01:25,070
sourced the frameworks or the libraries

00:01:21,740 --> 00:01:28,820
which powers this we create a truly

00:01:25,070 --> 00:01:31,550
cross component cross domain components

00:01:28,820 --> 00:01:33,710
and open source them so what's basically

00:01:31,550 --> 00:01:35,810
happening now is that we create all of

00:01:33,710 --> 00:01:38,270
all of our payment buttons inside an

00:01:35,810 --> 00:01:41,330
iframe so if you want to check those out

00:01:38,270 --> 00:01:44,180
you can check that on on github on these

00:01:41,330 --> 00:01:47,120
two different repos so I'm not going to

00:01:44,180 --> 00:01:48,680
be talking about constant branding brand

00:01:47,120 --> 00:01:51,110
versioning and all of that here because

00:01:48,680 --> 00:01:52,850
that's pretty obvious right like if you

00:01:51,110 --> 00:01:54,920
get to create your own payment buttons

00:01:52,850 --> 00:01:57,080
on the merchants website that gets you

00:01:54,920 --> 00:01:59,780
all of that but the one of the major

00:01:57,080 --> 00:02:02,510
advantages of doing this was that it got

00:01:59,780 --> 00:02:04,970
us pixel perfection so no matter how no

00:02:02,510 --> 00:02:07,310
matter what devices you are on you're

00:02:04,970 --> 00:02:10,359
gonna see those crisp images every time

00:02:07,310 --> 00:02:13,129
and also we created several other

00:02:10,359 --> 00:02:14,569
flavors of these PayPal buttons so the

00:02:13,129 --> 00:02:17,030
merchants could pick in

00:02:14,569 --> 00:02:19,159
choose whichever they wanted and having

00:02:17,030 --> 00:02:21,769
consistent checkout experience and

00:02:19,159 --> 00:02:24,049
obviously all of this since they were

00:02:21,769 --> 00:02:26,329
inside an iframe were sandbox from the

00:02:24,049 --> 00:02:28,219
rest of the merchant side so we no more

00:02:26,329 --> 00:02:30,799
had to worry about all those style

00:02:28,219 --> 00:02:34,040
sheets breaking us or we breaking them

00:02:30,799 --> 00:02:36,650
in that matter a also few years back we

00:02:34,040 --> 00:02:39,349
tried to create this another we write a

00:02:36,650 --> 00:02:41,540
lot of J's code every now and then so we

00:02:39,349 --> 00:02:43,310
created this another a library called

00:02:41,540 --> 00:02:45,049
button J's which created buttons

00:02:43,310 --> 00:02:47,209
directly on the merch inside and that

00:02:45,049 --> 00:02:48,859
was a nightmare because we were breaking

00:02:47,209 --> 00:02:53,319
them and they were breaking us all the

00:02:48,859 --> 00:02:56,120
time so what do we do we create

00:02:53,319 --> 00:02:58,000
JavaScript payments SDKs for the

00:02:56,120 --> 00:03:02,090
merchants to drop on their websites

00:02:58,000 --> 00:03:04,340
these payments SDKs are web pack bundles

00:03:02,090 --> 00:03:08,629
all the code which is required to create

00:03:04,340 --> 00:03:10,400
buttons and to require for the check on

00:03:08,629 --> 00:03:12,859
experience web pack bundles all of this

00:03:10,400 --> 00:03:15,169
and ships it back to the user so once a

00:03:12,859 --> 00:03:17,150
merchant integrates with us they get

00:03:15,169 --> 00:03:19,459
this PayPal button you click on it go

00:03:17,150 --> 00:03:23,030
through the login flow pay for yourself

00:03:19,459 --> 00:03:24,979
and come back to the merchant side these

00:03:23,030 --> 00:03:27,409
are the these are the few lines of code

00:03:24,979 --> 00:03:29,239
you need to actually integrate with us

00:03:27,409 --> 00:03:32,180
if you look at the top of the snippet on

00:03:29,239 --> 00:03:35,689
the first script tag you would see this

00:03:32,180 --> 00:03:38,299
URL which gets you all of this code so

00:03:35,689 --> 00:03:43,489
we are shipping massive amounts of codes

00:03:38,299 --> 00:03:45,759
in less than 200 milliseconds and we get

00:03:43,489 --> 00:03:50,239
close to 100 million requests per day

00:03:45,759 --> 00:03:52,699
now I know that is a lot of lot of tied

00:03:50,239 --> 00:03:55,939
bundling in a very short period of time

00:03:52,699 --> 00:03:58,819
I promise graph QL to you guys and this

00:03:55,939 --> 00:04:01,009
is where we get started with it so how

00:03:58,819 --> 00:04:03,680
are we achieving that 200 milliseconds

00:04:01,009 --> 00:04:10,280
of response time obviously through graph

00:04:03,680 --> 00:04:13,519
here before we deep that's a lot before

00:04:10,280 --> 00:04:16,909
we deep down fur we dive further into

00:04:13,519 --> 00:04:18,650
the schema design for all of that I

00:04:16,909 --> 00:04:19,459
would want to give you a little bit of

00:04:18,650 --> 00:04:23,150
history here

00:04:19,459 --> 00:04:25,659
we had a REST API I like how I'm saying

00:04:23,150 --> 00:04:28,010
had a REST API anyway we had a REST API

00:04:25,659 --> 00:04:30,020
for determining

00:04:28,010 --> 00:04:32,450
the eligible payment methods now this is

00:04:30,020 --> 00:04:34,490
required since we want to know what all

00:04:32,450 --> 00:04:37,970
do we actually want to render back on

00:04:34,490 --> 00:04:40,970
the merchants website so it was doing

00:04:37,970 --> 00:04:42,890
its job some of the code was scattered

00:04:40,970 --> 00:04:44,900
on the client side some of the some of

00:04:42,890 --> 00:04:48,050
the code which was still on rest was all

00:04:44,900 --> 00:04:50,270
controlled by config it required push

00:04:48,050 --> 00:04:52,880
changes restart of the apps and all

00:04:50,270 --> 00:04:55,160
sorts of things as our collaborations

00:04:52,880 --> 00:04:57,260
with different payment methods across

00:04:55,160 --> 00:04:58,670
the globe were increasing it was a

00:04:57,260 --> 00:05:02,000
perfect excuse

00:04:58,670 --> 00:05:05,360
perfect excuse to actually migrate

00:05:02,000 --> 00:05:08,240
towards craft UL if you look at this

00:05:05,360 --> 00:05:10,010
schema you would see the funding

00:05:08,240 --> 00:05:11,600
eligibility on the right side on the

00:05:10,010 --> 00:05:13,940
snippet you would see the funding

00:05:11,600 --> 00:05:14,300
eligibility feel declared at the root

00:05:13,940 --> 00:05:17,480
level

00:05:14,300 --> 00:05:20,180
now this accepts a bunch of inputs these

00:05:17,480 --> 00:05:23,000
inputs are a combination of merchants

00:05:20,180 --> 00:05:24,980
information and the users information we

00:05:23,000 --> 00:05:26,870
get all the merchant information from

00:05:24,980 --> 00:05:30,260
the integration script remember we saw

00:05:26,870 --> 00:05:32,180
saw that in a few slides before and we

00:05:30,260 --> 00:05:33,800
get all the user information from

00:05:32,180 --> 00:05:35,960
whatever we can collect from the user's

00:05:33,800 --> 00:05:39,350
browser including the buyer country

00:05:35,960 --> 00:05:41,600
local IP address cookies etc so the

00:05:39,350 --> 00:05:44,810
first level has funding eligibility in

00:05:41,600 --> 00:05:47,300
the schema definition the second one the

00:05:44,810 --> 00:05:49,610
second is are all these payment methods

00:05:47,300 --> 00:05:51,650
so it's an exhaustive list we have we

00:05:49,610 --> 00:05:54,200
currently have it at least 20 different

00:05:51,650 --> 00:05:57,650
payment methods we offer today across

00:05:54,200 --> 00:06:01,850
the globe wherever you are from and the

00:05:57,650 --> 00:06:04,430
third level has all these descriptor

00:06:01,850 --> 00:06:06,860
fields for for these payment methods

00:06:04,430 --> 00:06:08,540
first one being eligible which actually

00:06:06,860 --> 00:06:11,180
tells you whether this particular

00:06:08,540 --> 00:06:14,630
payment method was eligible or not the

00:06:11,180 --> 00:06:17,420
reasons behind it so we not only send

00:06:14,630 --> 00:06:19,760
reasons for why a particular payment

00:06:17,420 --> 00:06:21,980
method was not eligible but also because

00:06:19,760 --> 00:06:25,040
why it was eligible I would be talking

00:06:21,980 --> 00:06:26,660
about this particular field in our in

00:06:25,040 --> 00:06:29,210
the following slides on how it helps us

00:06:26,660 --> 00:06:31,010
in analytics we also have this field

00:06:29,210 --> 00:06:33,710
call recommended which tells you about

00:06:31,010 --> 00:06:36,350
whether why a particular payment method

00:06:33,710 --> 00:06:38,480
is recommended over others and certain

00:06:36,350 --> 00:06:39,409
it also carries certain conceptual

00:06:38,480 --> 00:06:45,679
information for

00:06:39,409 --> 00:06:47,719
payment method so we have resolver

00:06:45,679 --> 00:06:50,860
functions for all of these different

00:06:47,719 --> 00:06:53,569
payment methods a resolver is a function

00:06:50,860 --> 00:06:55,759
for some of you guys who who may not

00:06:53,569 --> 00:06:58,039
know a resolver is the function that

00:06:55,759 --> 00:06:59,839
fetches data for the field so every

00:06:58,039 --> 00:07:01,729
field you are seeing in this query is

00:06:59,839 --> 00:07:04,459
backed up by a resolver function and

00:07:01,729 --> 00:07:07,699
kept get information from any resource

00:07:04,459 --> 00:07:09,379
you want to so we implemented a resolver

00:07:07,699 --> 00:07:11,959
functions for each of these payment

00:07:09,379 --> 00:07:14,419
methods which were executed parallel we

00:07:11,959 --> 00:07:17,449
all know that a query in in graph QL is

00:07:14,419 --> 00:07:21,889
executed in a top-down breadth-first

00:07:17,449 --> 00:07:24,139
fashion this very out of the walks for

00:07:21,889 --> 00:07:25,759
functionality is what we leverage so

00:07:24,139 --> 00:07:27,949
since these resolver functions were

00:07:25,759 --> 00:07:30,439
being executed in parallel all the

00:07:27,949 --> 00:07:34,429
respective downstream api services were

00:07:30,439 --> 00:07:37,699
executed in pallor as well so the entire

00:07:34,429 --> 00:07:40,719
response time the graph QL query API was

00:07:37,699 --> 00:07:44,119
gonna take was approximately going to be

00:07:40,719 --> 00:07:46,639
the latency of that particle one of the

00:07:44,119 --> 00:07:48,679
payment methods which took the maximum

00:07:46,639 --> 00:07:52,819
amount of time to get a response back

00:07:48,679 --> 00:07:55,550
that was definitely a huge performance

00:07:52,819 --> 00:07:59,149
increase from when we had REST API x'

00:07:55,550 --> 00:08:02,360
and also of course different clients can

00:07:59,149 --> 00:08:04,699
choose to request for different payment

00:08:02,360 --> 00:08:07,249
methods not necessarily all so in this

00:08:04,699 --> 00:08:09,979
case the clients were in real control of

00:08:07,249 --> 00:08:11,479
the data they had to choose in our case

00:08:09,979 --> 00:08:13,369
we could pick and choose whatever

00:08:11,479 --> 00:08:16,039
payment methods we wanted for that

00:08:13,369 --> 00:08:21,979
particular application and leave out the

00:08:16,039 --> 00:08:23,659
rest the next implementation we did was

00:08:21,979 --> 00:08:25,610
that all of a resolver function for the

00:08:23,659 --> 00:08:28,009
payment methods were had separate

00:08:25,610 --> 00:08:29,959
implementation details now that meant

00:08:28,009 --> 00:08:33,559
that they were isolated to each other

00:08:29,959 --> 00:08:36,019
that they we for a lot of different

00:08:33,559 --> 00:08:38,180
teams to inner source and collaborate

00:08:36,019 --> 00:08:40,069
with each other a real-time example

00:08:38,180 --> 00:08:42,379
would be the recently had a team from

00:08:40,069 --> 00:08:44,149
Singapore who wanted to add their own

00:08:42,379 --> 00:08:46,519
payment method in this schema definition

00:08:44,149 --> 00:08:49,680
and do their own implementation they

00:08:46,519 --> 00:08:53,040
could do it in seamlessly without vibra

00:08:49,680 --> 00:08:56,160
kingdom or they breaking us we have also

00:08:53,040 --> 00:08:58,050
employed a lot of different caching for

00:08:56,160 --> 00:08:59,820
similar a Piazza cross resolver

00:08:58,050 --> 00:09:01,580
functions which I would be talking about

00:08:59,820 --> 00:09:07,050
in the next slides

00:09:01,580 --> 00:09:10,410
so in summary with all the sandboxing we

00:09:07,050 --> 00:09:14,360
do by putting buttons in an iframe and

00:09:10,410 --> 00:09:16,920
by call by having a graphical server for

00:09:14,360 --> 00:09:21,450
determining the eligible payment methods

00:09:16,920 --> 00:09:23,339
we we open doors for different various

00:09:21,450 --> 00:09:25,830
other payment methods across the globe

00:09:23,339 --> 00:09:27,200
as such that the merchants do not need

00:09:25,830 --> 00:09:30,570
to reintegrate with us

00:09:27,200 --> 00:09:33,180
also the entire schema definition the

00:09:30,570 --> 00:09:34,680
design is pretty scalable so if you want

00:09:33,180 --> 00:09:37,850
to add more payment methods we can

00:09:34,680 --> 00:09:40,649
anytime without showing anybody else

00:09:37,850 --> 00:09:42,660
also we through this we are able to

00:09:40,649 --> 00:09:45,270
provide meaningful and impactful

00:09:42,660 --> 00:09:48,570
checkout recheck our experiences to

00:09:45,270 --> 00:09:51,360
regional payment methods these are a few

00:09:48,570 --> 00:09:54,089
examples of our payment stacks in

00:09:51,360 --> 00:09:56,279
Netherland or in Germany so for each of

00:09:54,089 --> 00:09:58,440
these the merchants did not have to

00:09:56,279 --> 00:10:00,420
reintegrate with us and if tomorrow we

00:09:58,440 --> 00:10:03,709
want to add a few more payment buttons

00:10:00,420 --> 00:10:06,060
here we can do it seamlessly

00:10:03,709 --> 00:10:08,040
optimizations let's also talk about a

00:10:06,060 --> 00:10:11,640
few more optimizations we did add a

00:10:08,040 --> 00:10:13,470
graph QL server two basic things most of

00:10:11,640 --> 00:10:17,520
you would have heard about the Malaysian

00:10:13,470 --> 00:10:21,300
and cashing memoization is just another

00:10:17,520 --> 00:10:22,980
type of caching one can do to cache

00:10:21,300 --> 00:10:25,410
their stuff in the context of that

00:10:22,980 --> 00:10:29,279
function and the function here was the

00:10:25,410 --> 00:10:31,620
actual request lifecycle so here you are

00:10:29,279 --> 00:10:34,529
you're actually seeing pretty much the

00:10:31,620 --> 00:10:36,900
code we used to memorize our stuff at

00:10:34,529 --> 00:10:43,290
our servers for for this particular

00:10:36,900 --> 00:10:45,510
instance so we what we do is validate we

00:10:43,290 --> 00:10:47,490
validate or check a bunch of inputs make

00:10:45,510 --> 00:10:49,529
sure they're all right and create a

00:10:47,490 --> 00:10:50,760
cache based off the function name so the

00:10:49,529 --> 00:10:54,329
function here is going to be the

00:10:50,760 --> 00:10:56,010
downstream API service and the and we

00:10:54,329 --> 00:10:58,230
create that cache key using the function

00:10:56,010 --> 00:10:59,970
name and the bunch of inputs here this

00:10:58,230 --> 00:11:01,709
cache key we attach it to the wreck

00:10:59,970 --> 00:11:02,810
object this is the node server so we

00:11:01,709 --> 00:11:05,270
attach it to the wreck

00:11:02,810 --> 00:11:08,240
object and this information for that

00:11:05,270 --> 00:11:11,830
particular downstream API service hangs

00:11:08,240 --> 00:11:14,540
off in the entire request lifecycle so

00:11:11,830 --> 00:11:18,590
what that typically means is that for a

00:11:14,540 --> 00:11:20,060
particular call to our servers let's say

00:11:18,590 --> 00:11:22,370
we have five different resolver

00:11:20,060 --> 00:11:25,060
functions and five of them out of those

00:11:22,370 --> 00:11:27,380
five two of them have similar api's

00:11:25,060 --> 00:11:29,779
combination of similar API as they might

00:11:27,380 --> 00:11:31,580
be calling in that case we can use this

00:11:29,779 --> 00:11:35,060
particular code to make sure we're not

00:11:31,580 --> 00:11:39,820
calling that API more than once then

00:11:35,060 --> 00:11:44,320
next off is caching after our first

00:11:39,820 --> 00:11:47,839
release of all of after first release we

00:11:44,320 --> 00:11:50,420
recognized a few specific ApS who we

00:11:47,839 --> 00:11:53,029
knew their responses are got is

00:11:50,420 --> 00:11:56,420
generally persist for a few hours and

00:11:53,029 --> 00:12:00,589
for some for even a few days so at

00:11:56,420 --> 00:12:02,900
PayPal we have Redis men cache storage

00:12:00,589 --> 00:12:07,400
like structures it's called me fly so

00:12:02,900 --> 00:12:09,620
what we did was for certain AP as we

00:12:07,400 --> 00:12:13,550
started persisting all of that

00:12:09,620 --> 00:12:15,320
information in the cache we can

00:12:13,550 --> 00:12:17,540
visualize it this way so far let's say

00:12:15,320 --> 00:12:20,750
there is a there's a website and that

00:12:17,540 --> 00:12:22,940
website gets a request and we we know

00:12:20,750 --> 00:12:25,010
that this this website is backed up by a

00:12:22,940 --> 00:12:26,630
merchant a constant merchant that's not

00:12:25,010 --> 00:12:29,270
gonna change their account information

00:12:26,630 --> 00:12:31,430
is not gonna change so we create a cache

00:12:29,270 --> 00:12:34,250
of that particular merchants account

00:12:31,430 --> 00:12:36,260
information so that angry and so that

00:12:34,250 --> 00:12:39,530
any subsequent requests which this

00:12:36,260 --> 00:12:42,200
website gets we get all of that

00:12:39,530 --> 00:12:44,210
information off of that cache this again

00:12:42,200 --> 00:12:47,150
saved us a lot of milliseconds because

00:12:44,210 --> 00:12:53,390
sometimes the lucca for these merchants

00:12:47,150 --> 00:12:55,240
the information is quite high next up

00:12:53,390 --> 00:12:57,440
powers powerful insights why

00:12:55,240 --> 00:12:58,970
instrumentation why would you want to

00:12:57,440 --> 00:13:00,560
instrument your API because you want to

00:12:58,970 --> 00:13:02,720
know if it's lacking somewhere how it's

00:13:00,560 --> 00:13:05,990
performing and things like that in REST

00:13:02,720 --> 00:13:08,420
API is you can only do so much you can

00:13:05,990 --> 00:13:11,660
know how many times a particular API was

00:13:08,420 --> 00:13:14,089
called in but you would never know the

00:13:11,660 --> 00:13:15,830
number of times or how a particular

00:13:14,089 --> 00:13:16,790
field of a particular resource is being

00:13:15,830 --> 00:13:20,870
utilize

00:13:16,790 --> 00:13:24,470
we can do all of that through Apollo

00:13:20,870 --> 00:13:27,020
servers if you if you're running up on a

00:13:24,470 --> 00:13:30,110
server you can enable this flag tracing

00:13:27,020 --> 00:13:32,630
flag which gives you detailed granular

00:13:30,110 --> 00:13:36,140
information on all the different

00:13:32,630 --> 00:13:37,940
resolver functions how they're doing how

00:13:36,140 --> 00:13:41,300
much time did it take to resolve each of

00:13:37,940 --> 00:13:44,450
them per field and how many of them get

00:13:41,300 --> 00:13:46,280
executed for a period of time so we use

00:13:44,450 --> 00:13:48,500
that flag to pipe all of that

00:13:46,280 --> 00:13:52,700
information on tools like drew fauna and

00:13:48,500 --> 00:13:54,950
the this is a real - real time -

00:13:52,700 --> 00:13:57,170
snippets from the tool but the first one

00:13:54,950 --> 00:14:00,020
you is which you see is the resolve a

00:13:57,170 --> 00:14:02,480
duration and I don't know if you can see

00:14:00,020 --> 00:14:04,640
but the line each of the information on

00:14:02,480 --> 00:14:07,100
that table say is funding eligibility

00:14:04,640 --> 00:14:08,450
underscore the payment method and there

00:14:07,100 --> 00:14:10,190
are different fields and the next one

00:14:08,450 --> 00:14:13,760
you see is a resolved account the number

00:14:10,190 --> 00:14:16,210
of resolvers which are being executed on

00:14:13,760 --> 00:14:19,310
an average so this gives us and a very

00:14:16,210 --> 00:14:21,770
powerful insight on how i resolvers are

00:14:19,310 --> 00:14:22,490
doing and which particular resolver is

00:14:21,770 --> 00:14:24,770
slowing us down

00:14:22,490 --> 00:14:27,170
this helps us catch all those bad

00:14:24,770 --> 00:14:29,960
downstream api services and rectify them

00:14:27,170 --> 00:14:32,060
if possible remember we were talking

00:14:29,960 --> 00:14:34,280
about the reasons field as well in our

00:14:32,060 --> 00:14:37,160
schema definition so that reasons field

00:14:34,280 --> 00:14:39,200
returns us an array of strings those

00:14:37,160 --> 00:14:41,810
strings are the actual reasons why a

00:14:39,200 --> 00:14:44,600
particular payment method was eligible

00:14:41,810 --> 00:14:47,300
or not at one particular time we are

00:14:44,600 --> 00:14:49,700
running a lot of different experiments

00:14:47,300 --> 00:14:51,920
for a payment method we call a lot of

00:14:49,700 --> 00:14:54,080
different ApS for the same payment

00:14:51,920 --> 00:14:57,230
method so our data analytics team can

00:14:54,080 --> 00:14:59,210
pipe that information and see how we are

00:14:57,230 --> 00:15:01,520
performing how our X a B tests are

00:14:59,210 --> 00:15:04,130
performing and things like that and we

00:15:01,520 --> 00:15:07,340
do not we have specific hooks for that

00:15:04,130 --> 00:15:09,350
and we do not flush that information

00:15:07,340 --> 00:15:14,560
black to the back to the client so it's

00:15:09,350 --> 00:15:17,420
a internal field through our experience

00:15:14,560 --> 00:15:19,870
throughout releasing different phase

00:15:17,420 --> 00:15:24,230
different phases in the graphical server

00:15:19,870 --> 00:15:26,240
we had we identified four major benefits

00:15:24,230 --> 00:15:28,650
out of it one was obviously the

00:15:26,240 --> 00:15:30,120
performance

00:15:28,650 --> 00:15:32,490
the graphical this this graphical

00:15:30,120 --> 00:15:35,280
decisioning layer is on hot hot render

00:15:32,490 --> 00:15:37,830
path of rendering our entire checkout

00:15:35,280 --> 00:15:40,440
experience and we were able to achieve

00:15:37,830 --> 00:15:44,310
that under 200 milliseconds so are

00:15:40,440 --> 00:15:48,080
several benefits out-of-the-box from

00:15:44,310 --> 00:15:50,040
using graph QL on your servers helped us

00:15:48,080 --> 00:15:51,830
monumentally in increasing our

00:15:50,040 --> 00:15:57,090
performance in speed

00:15:51,830 --> 00:15:59,420
next was devic spear ins Danielle talked

00:15:57,090 --> 00:16:01,710
about dev experience in graph QL

00:15:59,420 --> 00:16:04,050
yesterday and I would totally want to

00:16:01,710 --> 00:16:07,610
corroborate on that picking up

00:16:04,050 --> 00:16:11,250
understanding graph QL is super easy and

00:16:07,610 --> 00:16:13,080
because of this a lot of my team are our

00:16:11,250 --> 00:16:15,720
sister teams all of them were able to

00:16:13,080 --> 00:16:17,820
understand it pretty quickly and

00:16:15,720 --> 00:16:20,730
contribute and migrate a lot of our API

00:16:17,820 --> 00:16:24,150
is on the graph QL so the adoption was

00:16:20,730 --> 00:16:26,820
fairly smooth the next benefit was

00:16:24,150 --> 00:16:29,310
flexibility the client applications

00:16:26,820 --> 00:16:31,680
which ever were consuming this

00:16:29,310 --> 00:16:34,410
particular graph QL decisioning layer

00:16:31,680 --> 00:16:37,500
they had the flexibility to choose what

00:16:34,410 --> 00:16:39,660
they want and leave out the rest so this

00:16:37,500 --> 00:16:43,020
was pretty this wasn't easy win for us

00:16:39,660 --> 00:16:45,000
because this way we this way it was

00:16:43,020 --> 00:16:46,620
directly controlling the size and the

00:16:45,000 --> 00:16:52,110
shape of the data we were shipping back

00:16:46,620 --> 00:16:54,270
to the users browser so this was a an

00:16:52,110 --> 00:16:57,660
out-of-the-box feature which was

00:16:54,270 --> 00:17:00,090
definitely a win win for us and the

00:16:57,660 --> 00:17:03,210
fourth most important benefit was

00:17:00,090 --> 00:17:06,930
evolution evolution of your API how you

00:17:03,210 --> 00:17:08,790
could do it so confidently so you didn't

00:17:06,930 --> 00:17:11,010
have you don't have to we didn't have to

00:17:08,790 --> 00:17:13,680
worry about creating major versions

00:17:11,010 --> 00:17:15,690
anymore bumping into major versions or

00:17:13,680 --> 00:17:17,640
the need to keep maintaining our

00:17:15,690 --> 00:17:21,330
previous versions we could make

00:17:17,640 --> 00:17:24,480
incremental changes on the api's and

00:17:21,330 --> 00:17:27,540
then adopt that in in companies with

00:17:24,480 --> 00:17:30,750
complex processes such as ours we've

00:17:27,540 --> 00:17:34,740
seen that the teams are much likely to

00:17:30,750 --> 00:17:37,290
adapt to small bits of changes those

00:17:34,740 --> 00:17:39,870
incremental changes then really big

00:17:37,290 --> 00:17:40,410
changes and that is one of the adoption

00:17:39,870 --> 00:17:42,930
migrated

00:17:40,410 --> 00:17:45,990
strategy is being employed even for

00:17:42,930 --> 00:17:48,060
these releases we coded whatever we had

00:17:45,990 --> 00:17:51,120
to on the graph QL servers and then

00:17:48,060 --> 00:17:53,640
started migrating bit populations bit by

00:17:51,120 --> 00:17:55,380
bit so we had a small population which

00:17:53,640 --> 00:17:57,210
was calling the graphical server and the

00:17:55,380 --> 00:18:00,150
rest of the population was still falling

00:17:57,210 --> 00:18:02,580
back on our on the rest api's and once

00:18:00,150 --> 00:18:04,410
we realized that our api's are doing

00:18:02,580 --> 00:18:06,420
well the graph QL is doing well is

00:18:04,410 --> 00:18:09,930
pretty stable through all the powerful

00:18:06,420 --> 00:18:13,890
insights we were able to migrate all of

00:18:09,930 --> 00:18:16,020
that completely also since you have

00:18:13,890 --> 00:18:18,630
granular information on all these

00:18:16,020 --> 00:18:20,340
different fees how it's being used you

00:18:18,630 --> 00:18:22,700
know what fields are being used and what

00:18:20,340 --> 00:18:25,500
is not so you can very confidently

00:18:22,700 --> 00:18:28,230
deprecate a particular fields using the

00:18:25,500 --> 00:18:31,500
deprecated excuse me

00:18:28,230 --> 00:18:34,410
deprecated directive and let the clients

00:18:31,500 --> 00:18:39,150
know that the particular field is

00:18:34,410 --> 00:18:42,870
deprecated so these are the experiences

00:18:39,150 --> 00:18:45,270
we've had by implementing and move

00:18:42,870 --> 00:18:48,780
migrating our entire decisioning layer

00:18:45,270 --> 00:18:52,740
at a graphical server this is a very

00:18:48,780 --> 00:18:55,530
small picture of what we are doing at

00:18:52,740 --> 00:18:58,950
PayPal with respect to graph QL if you

00:18:55,530 --> 00:19:01,500
want to come work with graph QL react

00:18:58,950 --> 00:19:04,430
gatsby or other funk funk tech please

00:19:01,500 --> 00:19:09,180
come and chat with me and you can also

00:19:04,430 --> 00:19:11,040
check out this URL to know about to know

00:19:09,180 --> 00:19:14,730
more about what fun stuff we're doing at

00:19:11,040 --> 00:19:16,530
v-power paypal is hiring and i would

00:19:14,730 --> 00:19:20,010
also like to give a big shout out to

00:19:16,530 --> 00:19:22,080
daniel and mark who've been providing me

00:19:20,010 --> 00:19:24,810
with their invaluable insights they work

00:19:22,080 --> 00:19:28,380
with me and have been providing their

00:19:24,810 --> 00:19:30,660
constant mentorship on whatever I'm

00:19:28,380 --> 00:19:36,519
doing at PayPal today thank you

00:19:30,660 --> 00:19:36,519

YouTube URL: https://www.youtube.com/watch?v=JneBBbDWiVs


