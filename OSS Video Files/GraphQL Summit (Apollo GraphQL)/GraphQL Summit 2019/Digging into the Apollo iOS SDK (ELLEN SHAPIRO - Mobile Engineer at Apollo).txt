Title: Digging into the Apollo iOS SDK (ELLEN SHAPIRO - Mobile Engineer at Apollo)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Learn about the what and why of recent updates to ApolloGraphQLâ€™s Swift iOS SDK, including integrating with Swift Package Manager, and get a preview of our updated code generation process.
Captions: 
	00:00:01,570 --> 00:00:06,770
Jack Jack Jack cut hello good morning

00:00:04,210 --> 00:00:08,719
thank you all for joining I know you've

00:00:06,770 --> 00:00:10,820
all been looking at a lot of typescript

00:00:08,719 --> 00:00:13,879
so for a change of space you'll get a

00:00:10,820 --> 00:00:15,259
little bit of swift today so Peggy gave

00:00:13,879 --> 00:00:17,420
me the official introduction I'm gonna

00:00:15,259 --> 00:00:20,300
give myself an unofficial introduction

00:00:17,420 --> 00:00:21,920
hi I'm Ellen Shapiro and in June I

00:00:20,300 --> 00:00:24,920
joined Paulo as a mobile engineer

00:00:21,920 --> 00:00:27,200
focused on the iOS SDK I am an iPhone

00:00:24,920 --> 00:00:29,510
and Android developer this year marks a

00:00:27,200 --> 00:00:31,460
decade since I started building apps for

00:00:29,510 --> 00:00:33,469
both platforms with extremely little

00:00:31,460 --> 00:00:36,140
idea of what the hell I was doing I have

00:00:33,469 --> 00:00:37,969
a somewhat better idea now but getting

00:00:36,140 --> 00:00:40,760
to that decade marker makes me feel both

00:00:37,969 --> 00:00:42,739
very proud and really old because a

00:00:40,760 --> 00:00:45,140
decade working on anything tech is

00:00:42,739 --> 00:00:47,179
considered essentially forever I've

00:00:45,140 --> 00:00:49,280
built a ton of apps over the years but

00:00:47,179 --> 00:00:51,890
I've only had an opportunity to work on

00:00:49,280 --> 00:00:54,649
tooling and SDKs a little bit until now

00:00:51,890 --> 00:00:56,510
I also do a decent amount of public

00:00:54,649 --> 00:00:58,879
speaking at conferences for both iOS and

00:00:56,510 --> 00:01:00,649
Android developers and over the last two

00:00:58,879 --> 00:01:03,440
years in particular I started to hear a

00:01:00,649 --> 00:01:05,300
lot about graph QL and one of the things

00:01:03,440 --> 00:01:07,460
that jumped out at me immediately as a

00:01:05,300 --> 00:01:10,780
mobile developer was how it had the

00:01:07,460 --> 00:01:13,370
potential to make and to evolve an API

00:01:10,780 --> 00:01:15,620
to iterate on designs to make that whole

00:01:13,370 --> 00:01:18,620
process a whole lot easier than it was

00:01:15,620 --> 00:01:20,690
with rest requests and I was really

00:01:18,620 --> 00:01:23,780
interested in working more with graph QL

00:01:20,690 --> 00:01:26,420
and not too long after this I saw a job

00:01:23,780 --> 00:01:28,310
listing to come work on the iOS SDK in

00:01:26,420 --> 00:01:29,900
Apollo and the engineering team was

00:01:28,310 --> 00:01:31,910
largely remote cuz as Peggy said I was

00:01:29,900 --> 00:01:32,840
actually living in the Netherlands at

00:01:31,910 --> 00:01:35,390
the time I was actually living in

00:01:32,840 --> 00:01:37,970
Nijmegen but I forgive by because so

00:01:35,390 --> 00:01:39,350
it's really hard to pronounce that but I

00:01:37,970 --> 00:01:41,960
was I was really enjoying the good life

00:01:39,350 --> 00:01:43,790
of syrup waffles and cycling and

00:01:41,960 --> 00:01:46,100
staggering really strong Belgian beer

00:01:43,790 --> 00:01:49,430
and it turned out that the guy who

00:01:46,100 --> 00:01:51,680
originally wrote the iOS SDK Bakhtin

00:01:49,430 --> 00:01:53,810
Walraven actually lived in Amsterdam so

00:01:51,680 --> 00:01:56,270
it would be relatively easy for me to

00:01:53,810 --> 00:01:58,130
work with him to find out exactly where

00:01:56,270 --> 00:02:01,730
things needed some serious work in the

00:01:58,130 --> 00:02:04,850
existing SDK so in June I started

00:02:01,730 --> 00:02:07,010
digging into the iOS SDK and I learned

00:02:04,850 --> 00:02:09,170
that in addition to the work I already

00:02:07,010 --> 00:02:10,729
knew it was doing taking graph QL

00:02:09,170 --> 00:02:13,160
queries and using them to generate

00:02:10,729 --> 00:02:14,440
Network and parsing code it also does

00:02:13,160 --> 00:02:16,210
some significant work

00:02:14,440 --> 00:02:18,490
with cashing in order to keep

00:02:16,210 --> 00:02:21,250
unnecessary Network calls to a minimum

00:02:18,490 --> 00:02:23,890
so it was a little bit rough working

00:02:21,250 --> 00:02:25,630
with the iOS SDK at first Martin had

00:02:23,890 --> 00:02:28,270
moved on to bigger and better things at

00:02:25,630 --> 00:02:29,740
Apollo and while Apollo's Android SDK

00:02:28,270 --> 00:02:32,110
had really been embraced by the

00:02:29,740 --> 00:02:33,580
community and moved significantly

00:02:32,110 --> 00:02:36,220
forward by the open-source community

00:02:33,580 --> 00:02:39,310
since it was originally built the iOS

00:02:36,220 --> 00:02:41,320
repo was a little bit less active well

00:02:39,310 --> 00:02:44,020
not entirely less active as there were

00:02:41,320 --> 00:02:45,610
at least of May as of May first which

00:02:44,020 --> 00:02:47,200
was the last Wayback Machine snapshot I

00:02:45,610 --> 00:02:48,760
could find it from before I started

00:02:47,200 --> 00:02:51,970
there were over a hundred and fifty

00:02:48,760 --> 00:02:53,920
issues and 33 open PRS and seeing those

00:02:51,970 --> 00:02:57,040
numbers when I started was a little bit

00:02:53,920 --> 00:02:59,140
frightning if I want to be honest but I

00:02:57,040 --> 00:03:00,760
knew that if I was able to work with

00:02:59,140 --> 00:03:03,610
more time to figure out what was going

00:03:00,760 --> 00:03:05,530
on I'd really be able to take a machete

00:03:03,610 --> 00:03:08,590
to the backlog and move things forward

00:03:05,530 --> 00:03:10,000
really quickly and despite the fact that

00:03:08,590 --> 00:03:11,980
I had to take a couple of weeks off to

00:03:10,000 --> 00:03:14,260
move back to the United States which

00:03:11,980 --> 00:03:15,850
involved taking five enormous duffel

00:03:14,260 --> 00:03:18,340
bags to roll aboard suitcases to

00:03:15,850 --> 00:03:20,680
backpacks and one extremely displeased

00:03:18,340 --> 00:03:22,750
cat on an international flight we have

00:03:20,680 --> 00:03:25,510
now managed to hack the issue list as of

00:03:22,750 --> 00:03:27,850
last night to a third of what it was six

00:03:25,510 --> 00:03:34,660
months ago and the list of open PRS to

00:03:27,850 --> 00:03:36,850
what I am super proud of this but I want

00:03:34,660 --> 00:03:38,230
to talk about what has changed pretty

00:03:36,850 --> 00:03:40,570
significantly in the last few months

00:03:38,230 --> 00:03:42,490
particularly in the context of hacking

00:03:40,570 --> 00:03:45,100
through the backlog because sifting

00:03:42,490 --> 00:03:46,720
through the issue pile I immediately saw

00:03:45,100 --> 00:03:48,790
that an enormous stumbling point for

00:03:46,720 --> 00:03:50,739
pretty much everyone was simply getting

00:03:48,790 --> 00:03:53,020
started with the library because it was

00:03:50,739 --> 00:03:55,209
a considerably more complex proposition

00:03:53,020 --> 00:03:57,910
than adding a number of other libraries

00:03:55,209 --> 00:04:00,100
in iOS usually you'd pick a dependency

00:03:57,910 --> 00:04:01,810
manager cocoa pods Carthage or Swift

00:04:00,100 --> 00:04:03,700
package manager and then you'd basically

00:04:01,810 --> 00:04:06,580
be done and ready to use the library

00:04:03,700 --> 00:04:08,860
with what we're doing in the Apollo iOS

00:04:06,580 --> 00:04:10,690
library that's kind of not possible and

00:04:08,860 --> 00:04:12,400
it's mostly because we use the library

00:04:10,690 --> 00:04:14,650
to generate a bunch of model and parsing

00:04:12,400 --> 00:04:16,419
code for you our code generation library

00:04:14,650 --> 00:04:17,770
takes a look at a combination of the

00:04:16,419 --> 00:04:19,989
schema you've got from your back-end

00:04:17,770 --> 00:04:21,760
which defines the world of what is

00:04:19,989 --> 00:04:23,020
possible the queries you've written

00:04:21,760 --> 00:04:25,330
locally which define what you're

00:04:23,020 --> 00:04:27,310
actually asking for and after checking

00:04:25,330 --> 00:04:28,300
that what you're asking for is in fact

00:04:27,310 --> 00:04:29,830
possible

00:04:28,300 --> 00:04:31,960
applies some magic to combine all of

00:04:29,830 --> 00:04:34,690
that information and create Swift code

00:04:31,960 --> 00:04:36,370
and the huge benefit of all this is that

00:04:34,690 --> 00:04:38,680
you get type safety from end to end

00:04:36,370 --> 00:04:40,599
throughout your entire stack is a

00:04:38,680 --> 00:04:42,340
parameter for a query declared in your

00:04:40,599 --> 00:04:44,919
schema as a string then the code

00:04:42,340 --> 00:04:47,500
generated will enforce this at compile

00:04:44,919 --> 00:04:49,900
time and fail loud and hard and quickly

00:04:47,500 --> 00:04:51,400
when you try to pass it an integer so

00:04:49,900 --> 00:04:53,680
this is an enormous benefit of the

00:04:51,400 --> 00:04:55,300
Apollo SDK but there's some stuff that

00:04:53,680 --> 00:04:57,069
our code generation library needs to

00:04:55,300 --> 00:04:59,169
know in order to make all of this work

00:04:57,069 --> 00:05:01,360
so what schema should be used to

00:04:59,169 --> 00:05:03,009
generate the code what are the queries

00:05:01,360 --> 00:05:04,690
that need to be added to that schema in

00:05:03,009 --> 00:05:06,430
order to that generate the code what

00:05:04,690 --> 00:05:08,620
should be done when we're actually with

00:05:06,430 --> 00:05:10,330
the code that we generated and then any

00:05:08,620 --> 00:05:12,940
other options that the koujun library

00:05:10,330 --> 00:05:14,259
can potentially handle it is basically

00:05:12,940 --> 00:05:16,330
impossible to do all this without

00:05:14,259 --> 00:05:17,740
setting up a run script build phase in

00:05:16,330 --> 00:05:20,620
order to pass all of this information

00:05:17,740 --> 00:05:22,090
along to the code gen library so setting

00:05:20,620 --> 00:05:24,099
that up is kind of annoying but it

00:05:22,090 --> 00:05:26,379
wasn't the biggest problem the biggest

00:05:24,099 --> 00:05:28,240
issues came after setting up the run

00:05:26,379 --> 00:05:30,009
script build phase because the code

00:05:28,240 --> 00:05:33,130
generation library is written entirely

00:05:30,009 --> 00:05:35,440
anode and typescript and for a lot of

00:05:33,130 --> 00:05:37,300
iOS developers if you even mention the

00:05:35,440 --> 00:05:39,130
word JavaScript or anything related to

00:05:37,300 --> 00:05:41,039
it they will run for the hills with

00:05:39,130 --> 00:05:44,080
their fingers in the air screaming

00:05:41,039 --> 00:05:46,750
because there's some defensive instinct

00:05:44,080 --> 00:05:48,819
there a lot of us have deep scars from

00:05:46,750 --> 00:05:51,370
working with cross-platform JavaScript

00:05:48,819 --> 00:05:53,650
frameworks over the last decade and I I

00:05:51,370 --> 00:05:55,330
include myself in that phrase but it's

00:05:53,650 --> 00:05:58,060
also because if you are not working with

00:05:55,330 --> 00:06:00,400
node or NPM on a daily basis getting it

00:05:58,060 --> 00:06:02,529
set up can be a total nightmare for

00:06:00,400 --> 00:06:04,960
instance if you try to install iOS

00:06:02,529 --> 00:06:06,729
previously you'd go through the standard

00:06:04,960 --> 00:06:08,710
dependency installation process for your

00:06:06,729 --> 00:06:09,879
package manager then you'd add the build

00:06:08,710 --> 00:06:11,319
script and as you work through the

00:06:09,879 --> 00:06:13,330
instructions you'd see you had to run

00:06:11,319 --> 00:06:15,099
NPM install Apollo but if you didn't

00:06:13,330 --> 00:06:17,020
have n PM installed then you need to use

00:06:15,099 --> 00:06:18,490
homebrew to install NPM and then if you

00:06:17,020 --> 00:06:20,169
didn't have homebrew ins installed you

00:06:18,490 --> 00:06:22,210
need to figure out how to install it the

00:06:20,169 --> 00:06:24,340
whole thing was extremely frustrating

00:06:22,210 --> 00:06:26,409
another path we saw that developers who

00:06:24,340 --> 00:06:27,819
did have NPM installed they would be

00:06:26,409 --> 00:06:30,340
able to get through the first three

00:06:27,819 --> 00:06:31,629
steps but then they wouldn't really be

00:06:30,340 --> 00:06:33,969
sure whether they had the correct

00:06:31,629 --> 00:06:36,250
version of the CLI for the current SDK

00:06:33,969 --> 00:06:38,259
they would run into weird issues

00:06:36,250 --> 00:06:41,320
depending on whether they had used NPM

00:06:38,259 --> 00:06:41,980
install or NPM install - gee and again

00:06:41,320 --> 00:06:43,510
we'd get

00:06:41,980 --> 00:06:45,070
really really frustrating and people

00:06:43,510 --> 00:06:47,860
would often give up at this point and

00:06:45,070 --> 00:06:49,900
seeing this whole process we knew we

00:06:47,860 --> 00:06:51,550
really needed to eliminate this huge

00:06:49,900 --> 00:06:54,310
source of frustration for iOS developers

00:06:51,550 --> 00:06:56,140
and the solution that we eventually came

00:06:54,310 --> 00:06:58,510
up with was essentially to cut NPM out

00:06:56,140 --> 00:07:00,400
of the process entirely so our tooling

00:06:58,510 --> 00:07:02,680
team recently added a new job to our

00:07:00,400 --> 00:07:04,930
continuous integration server which is

00:07:02,680 --> 00:07:07,480
called build CLI and it builds a tarball

00:07:04,930 --> 00:07:10,150
on every commit to master that includes

00:07:07,480 --> 00:07:12,190
a full node runtime along with all of

00:07:10,150 --> 00:07:15,610
the dependencies necessary to run the

00:07:12,190 --> 00:07:17,230
apollo CLI now after some changes -

00:07:15,610 --> 00:07:19,690
under the hood scripts that come with

00:07:17,230 --> 00:07:21,910
the iOS SDK this process is a lot more

00:07:19,690 --> 00:07:23,770
straightforward you follow the same

00:07:21,910 --> 00:07:25,210
first couple of steps installing the

00:07:23,770 --> 00:07:27,310
dependency and then adding a build

00:07:25,210 --> 00:07:29,620
script this time one that calls this new

00:07:27,310 --> 00:07:31,180
included script then that updated build

00:07:29,620 --> 00:07:32,440
script will automatically check to see

00:07:31,180 --> 00:07:35,560
if the tarball needs to be downloaded

00:07:32,440 --> 00:07:36,550
and/or unzipped do whichever of those it

00:07:35,560 --> 00:07:39,040
needs to

00:07:36,550 --> 00:07:41,230
we're both and get you something that

00:07:39,040 --> 00:07:43,720
runs out of the box without ever having

00:07:41,230 --> 00:07:45,670
to worry about node or NPM and you can

00:07:43,720 --> 00:07:47,980
use our library for its intended purpose

00:07:45,670 --> 00:07:50,440
without further delay so this has been

00:07:47,980 --> 00:07:52,930
really really great because it means iOS

00:07:50,440 --> 00:07:54,970
developers don't have to deal with NPM

00:07:52,930 --> 00:07:57,250
and typescript silliness and everyone

00:07:54,970 --> 00:07:59,770
using the default setup has exactly the

00:07:57,250 --> 00:08:01,570
same setup in terms of dependencies CLI

00:07:59,770 --> 00:08:03,820
version and node version for a

00:08:01,570 --> 00:08:06,970
particular version of the iOS SDK which

00:08:03,820 --> 00:08:08,620
makes debugging problems a lot easier so

00:08:06,970 --> 00:08:11,770
that's the biggest thing that's changed

00:08:08,620 --> 00:08:14,260
it's also become clear that we had to do

00:08:11,770 --> 00:08:15,580
a better job of explaining some of the

00:08:14,260 --> 00:08:18,490
harder things to understand about how

00:08:15,580 --> 00:08:20,350
our library works for example something

00:08:18,490 --> 00:08:22,540
in the issues which seemed to trip up a

00:08:20,350 --> 00:08:23,950
ton of people is the way that the SDK

00:08:22,540 --> 00:08:26,770
uses double optionals

00:08:23,950 --> 00:08:29,200
particularly an input objects so for

00:08:26,770 --> 00:08:31,240
example in the Star Wars schema that we

00:08:29,200 --> 00:08:33,280
use as a testbed for a lot of our work

00:08:31,240 --> 00:08:35,710
there's an input object called a review

00:08:33,280 --> 00:08:37,210
input which allows you to add a review

00:08:35,710 --> 00:08:39,490
for a particular episode of Star Wars

00:08:37,210 --> 00:08:41,349
with some stars and some condom tere and

00:08:39,490 --> 00:08:43,720
maybe even your favorite color and when

00:08:41,349 --> 00:08:45,940
people see this type as the parameter

00:08:43,720 --> 00:08:47,740
for commentary they can get really

00:08:45,940 --> 00:08:49,270
confused is it an optional of an

00:08:47,740 --> 00:08:50,590
optional why not just write it with two

00:08:49,270 --> 00:08:52,510
question marks to make it clear how

00:08:50,590 --> 00:08:54,760
incredulous we are that this even exists

00:08:52,510 --> 00:08:56,050
but the thing that I found it this is

00:08:54,760 --> 00:08:58,540
easier to think of

00:08:56,050 --> 00:09:00,490
as an optional optional string a nested

00:08:58,540 --> 00:09:02,170
optional because then you can look at

00:09:00,490 --> 00:09:04,870
what's happening with the two optionals

00:09:02,170 --> 00:09:07,540
separately the outter optional tells us

00:09:04,870 --> 00:09:09,700
whether any value at all is even being

00:09:07,540 --> 00:09:11,950
included for a particular parameter the

00:09:09,700 --> 00:09:14,230
inter optional tells us that a value was

00:09:11,950 --> 00:09:16,930
in fact included but we're not sure if

00:09:14,230 --> 00:09:19,240
it's a typed value or nil so why is it

00:09:16,930 --> 00:09:21,010
generated like this it helps to look a

00:09:19,240 --> 00:09:24,399
little bit at the JSON for this object

00:09:21,010 --> 00:09:26,920
in the schema for the input object three

00:09:24,399 --> 00:09:28,480
parameters described the first field is

00:09:26,920 --> 00:09:30,820
the number of stars an important thing

00:09:28,480 --> 00:09:33,970
to note is that it's non null with a

00:09:30,820 --> 00:09:36,339
scalar type of int and it means that it

00:09:33,970 --> 00:09:38,529
has to be present and non null and of

00:09:36,339 --> 00:09:40,810
type int so when code is generated that

00:09:38,529 --> 00:09:42,519
field is set up in Swift as an int

00:09:40,810 --> 00:09:44,110
parameter that part is pretty

00:09:42,519 --> 00:09:46,240
straightforward what's less

00:09:44,110 --> 00:09:48,339
straightforward is the other two fields

00:09:46,240 --> 00:09:49,660
their types are a scalar and an input

00:09:48,339 --> 00:09:51,850
object and there's no nested type

00:09:49,660 --> 00:09:53,170
information so why aren't they generated

00:09:51,850 --> 00:09:55,720
as non null input types

00:09:53,170 --> 00:09:58,000
well because graph QL ZAR nothing fields

00:09:55,720 --> 00:09:59,740
are nullable I to fall now you would

00:09:58,000 --> 00:10:01,390
think that this would simply create a

00:09:59,740 --> 00:10:03,339
single optional and it does when you're

00:10:01,390 --> 00:10:05,589
parsing objects returned from the server

00:10:03,339 --> 00:10:07,240
but when you're sending objects to the

00:10:05,589 --> 00:10:09,010
server it's important to understand that

00:10:07,240 --> 00:10:11,500
not only does a nullable field not to

00:10:09,010 --> 00:10:14,380
have to have any value it also doesn't

00:10:11,500 --> 00:10:16,149
even have to be present in the data that

00:10:14,380 --> 00:10:18,160
you send to the server and so the

00:10:16,149 --> 00:10:19,420
generated initializer uses a double

00:10:18,160 --> 00:10:20,980
optional for the corresponding

00:10:19,420 --> 00:10:22,779
parameters for these two fields in the

00:10:20,980 --> 00:10:24,700
initializer so what does this look like

00:10:22,779 --> 00:10:26,140
when you actually go to send data well

00:10:24,700 --> 00:10:28,420
it depends on how you use that

00:10:26,140 --> 00:10:30,279
initializer if you use the default

00:10:28,420 --> 00:10:33,070
values of nil for both double optional

00:10:30,279 --> 00:10:36,310
parameters only the value of stars will

00:10:33,070 --> 00:10:37,660
be set if you pass in a raw string some

00:10:36,310 --> 00:10:39,339
magic happens under the hood of the

00:10:37,660 --> 00:10:41,350
Swift compiler to say AHA ultimately

00:10:39,339 --> 00:10:42,940
this wants to be a string here you have

00:10:41,350 --> 00:10:44,529
a string literal at double ret unwraps

00:10:42,940 --> 00:10:46,000
and says yes there is a value here it is

00:10:44,529 --> 00:10:46,510
of a type spring and you could send it

00:10:46,000 --> 00:10:49,060
to the server

00:10:46,510 --> 00:10:51,100
now when you pass nil directly to that

00:10:49,060 --> 00:10:53,380
parameter you still only get the stars

00:10:51,100 --> 00:10:55,300
going to the server similarly to the

00:10:53,380 --> 00:10:57,610
first implementation where you got that

00:10:55,300 --> 00:10:59,860
default value value of nil now this

00:10:57,610 --> 00:11:02,350
trips a ton of people up because they

00:10:59,860 --> 00:11:04,120
think if they pass nil to commentary

00:11:02,350 --> 00:11:06,130
that null should be sent to the server

00:11:04,120 --> 00:11:07,360
but because there's a double optional

00:11:06,130 --> 00:11:09,910
there you actually have to tell your

00:11:07,360 --> 00:11:12,910
input object to actively sell send notes

00:11:09,910 --> 00:11:15,700
the server bypassing a value of some nil

00:11:12,910 --> 00:11:18,280
this sells the compiler hey there is a

00:11:15,700 --> 00:11:20,710
value I want the server to know about it

00:11:18,280 --> 00:11:23,170
is just null and that's not that

00:11:20,710 --> 00:11:24,910
complicated but it's just a little bit

00:11:23,170 --> 00:11:27,850
against what some developers are

00:11:24,910 --> 00:11:29,140
expecting out of the box speaking of

00:11:27,850 --> 00:11:31,030
which another thing we could probably do

00:11:29,140 --> 00:11:33,310
a better job of explaining is our

00:11:31,030 --> 00:11:35,920
approach to caching this is actually a

00:11:33,310 --> 00:11:37,510
huge feature of what we do but not a lot

00:11:35,920 --> 00:11:38,950
of people understand how it helps them

00:11:37,510 --> 00:11:42,040
and there are some misunderstandings

00:11:38,950 --> 00:11:43,630
about what gets cached and how the first

00:11:42,040 --> 00:11:45,610
thing to grok is that we're using a

00:11:43,630 --> 00:11:47,890
protocol called normalized cache to

00:11:45,610 --> 00:11:49,780
store things in the cache normalization

00:11:47,890 --> 00:11:51,400
is a fancy way of saying being able to

00:11:49,780 --> 00:11:53,230
take different objects return from

00:11:51,400 --> 00:11:55,420
different network calls and realize that

00:11:53,230 --> 00:11:56,980
they are the same thing at a really

00:11:55,420 --> 00:11:58,930
critical question when you're dealing

00:11:56,980 --> 00:12:01,240
with cache normalization is figuring out

00:11:58,930 --> 00:12:03,430
what to use to normalize that response

00:12:01,240 --> 00:12:05,290
how are these things actually related

00:12:03,430 --> 00:12:07,480
and by default we use something fairly

00:12:05,290 --> 00:12:08,920
simple we actually use the path of the

00:12:07,480 --> 00:12:10,930
query itself which allows you to make a

00:12:08,920 --> 00:12:12,580
few assumptions so let's take the

00:12:10,930 --> 00:12:13,960
example of two wars against our Star

00:12:12,580 --> 00:12:16,480
Wars simple sneaky mode one just getting

00:12:13,960 --> 00:12:18,430
the hero of a particular episode and

00:12:16,480 --> 00:12:20,470
another getting the hero's name and

00:12:18,430 --> 00:12:22,330
their graph QL ID if you start from an

00:12:20,470 --> 00:12:24,820
empty cache and you initially make a

00:12:22,330 --> 00:12:26,410
hero named query the result of X query

00:12:24,820 --> 00:12:28,840
will get stored using a cache key that

00:12:26,410 --> 00:12:30,640
fills in any variables in the cache then

00:12:28,840 --> 00:12:32,740
if you use a hero name with ID query

00:12:30,640 --> 00:12:35,350
cache looked at the path for the search

00:12:32,740 --> 00:12:37,330
key for the name key you can see that

00:12:35,350 --> 00:12:38,860
the paths are identical so the query can

00:12:37,330 --> 00:12:40,540
get the value from the cache to fulfill

00:12:38,860 --> 00:12:43,060
this property without having to go to

00:12:40,540 --> 00:12:44,620
the network however since when the query

00:12:43,060 --> 00:12:47,380
starts to look for a key with the path

00:12:44,620 --> 00:12:49,180
to the ID field it doesn't find it and

00:12:47,380 --> 00:12:51,670
one thing to be aware of in the iOS

00:12:49,180 --> 00:12:53,920
implementation in particular is that if

00:12:51,670 --> 00:12:56,110
not all of the properties can be found

00:12:53,920 --> 00:12:58,180
in the cache for a particular query that

00:12:56,110 --> 00:13:00,490
causes a cache miss for the entire query

00:12:58,180 --> 00:13:01,600
no partial results will be returned from

00:13:00,490 --> 00:13:03,940
the cache for that query

00:13:01,600 --> 00:13:06,100
now this can differ out-of-the-box with

00:13:03,940 --> 00:13:08,590
what people are expecting particularly

00:13:06,100 --> 00:13:10,540
if they are using a graph QL ID to

00:13:08,590 --> 00:13:12,790
uniquely identify their objects they

00:13:10,540 --> 00:13:14,410
expect that the identifier would be the

00:13:12,790 --> 00:13:17,110
cache key for their object by default

00:13:14,410 --> 00:13:18,970
however we've seen that a really big

00:13:17,110 --> 00:13:21,190
percentage of users need to use other

00:13:18,970 --> 00:13:23,020
things to uniquely identify their

00:13:21,190 --> 00:13:23,920
objects particularly if you're adding

00:13:23,020 --> 00:13:26,230
graph QL

00:13:23,920 --> 00:13:28,300
to an older database where there's some

00:13:26,230 --> 00:13:30,580
kind of additional identifier like the

00:13:28,300 --> 00:13:32,980
ISBN for books or even a combination of

00:13:30,580 --> 00:13:35,230
the ISBN and a generated UUID from a pre

00:13:32,980 --> 00:13:37,750
graph QL version of your server there's

00:13:35,230 --> 00:13:39,880
no way right now for us to know that in

00:13:37,750 --> 00:13:41,950
advance so it's really hard for us to

00:13:39,880 --> 00:13:43,540
normalize queries automatically if we

00:13:41,950 --> 00:13:46,990
don't know how to disambiguate those

00:13:43,540 --> 00:13:48,790
objects so we provide a cache key for

00:13:46,990 --> 00:13:50,470
object property on apollo client and

00:13:48,790 --> 00:13:55,450
apollo store which is actually a

00:13:50,470 --> 00:13:57,400
function that takes an unparticle queue

00:13:55,450 --> 00:13:59,620
late a cache key that's also a JSON

00:13:57,400 --> 00:14:02,230
object the simplest implementation of

00:13:59,620 --> 00:14:04,120
this checks the graph QL identifier on a

00:14:02,230 --> 00:14:05,650
particular object if it's there I can

00:14:04,120 --> 00:14:07,650
look for the object with that identifier

00:14:05,650 --> 00:14:10,410
if not it falls back to the query path

00:14:07,650 --> 00:14:13,000
one thing to watch out for here is

00:14:10,410 --> 00:14:14,860
potential identifier overlap across

00:14:13,000 --> 00:14:16,660
objects which means that you'd want to

00:14:14,860 --> 00:14:18,970
check a combination of the identifier

00:14:16,660 --> 00:14:21,279
and the type name which all queries on

00:14:18,970 --> 00:14:23,650
iOS request in order to help with type

00:14:21,279 --> 00:14:26,770
safety and you can return these as an

00:14:23,650 --> 00:14:28,120
array to use as your cache key or you

00:14:26,770 --> 00:14:29,529
could cast both of these values to

00:14:28,120 --> 00:14:32,020
string and concatenate them to use a

00:14:29,529 --> 00:14:33,580
single string as your cache key and the

00:14:32,020 --> 00:14:35,200
nice thing about this flexibility is

00:14:33,580 --> 00:14:37,540
that if you're not using your graph QL

00:14:35,200 --> 00:14:39,100
ideas your identifier you only need to

00:14:37,540 --> 00:14:40,690
swap out whatever properties you're

00:14:39,100 --> 00:14:43,000
checking for and sticking into the array

00:14:40,690 --> 00:14:45,070
and/or concatenative and you'll be able

00:14:43,000 --> 00:14:47,560
to get uniquely identifiable objects

00:14:45,070 --> 00:14:50,200
from anything now one thing to be aware

00:14:47,560 --> 00:14:52,390
of is that by default all of the caching

00:14:50,200 --> 00:14:54,220
that we're doing takes place in memory

00:14:52,390 --> 00:14:56,589
with the help of an included class

00:14:54,220 --> 00:14:58,779
called the in-memory normalized cache

00:14:56,589 --> 00:15:00,940
this is automatically created for you by

00:14:58,779 --> 00:15:03,640
default under the hood when an instance

00:15:00,940 --> 00:15:05,020
of Apollo client is created there are

00:15:03,640 --> 00:15:06,310
some instances where developers wanted

00:15:05,020 --> 00:15:08,860
to make sure not everything was cached

00:15:06,310 --> 00:15:10,150
in memory and this is where the first of

00:15:08,860 --> 00:15:12,940
the supplementary libraries I'm going to

00:15:10,150 --> 00:15:14,440
talk about today comes in sweet I'm glad

00:15:12,940 --> 00:15:15,220
that that totally has both words on

00:15:14,440 --> 00:15:17,680
there

00:15:15,220 --> 00:15:19,720
Airbnb engineers wanted to use sequel

00:15:17,680 --> 00:15:21,880
Lite for their caching layers and so

00:15:19,720 --> 00:15:24,070
they contributed a supplementary library

00:15:21,880 --> 00:15:26,920
for sequel Lite caching and it's called

00:15:24,070 --> 00:15:28,870
Apollo sequel Lite and it really only

00:15:26,920 --> 00:15:31,120
differs from the in-memory cache in

00:15:28,870 --> 00:15:33,160
terms of where cache results are stored

00:15:31,120 --> 00:15:35,350
in a sequel Lite cache instead of

00:15:33,160 --> 00:15:37,130
directly in memory and this wasn't the

00:15:35,350 --> 00:15:38,149
only thing that's been added by the

00:15:37,130 --> 00:15:39,890
there were developers who were

00:15:38,149 --> 00:15:41,360
interested in supporting subscriptions

00:15:39,890 --> 00:15:43,190
or a way to have the server

00:15:41,360 --> 00:15:44,930
automatically update your client if the

00:15:43,190 --> 00:15:46,430
data behind a given query changed

00:15:44,930 --> 00:15:48,860
automatically if you're here for the

00:15:46,430 --> 00:15:51,140
last talk you saw an example of that

00:15:48,860 --> 00:15:52,820
with the with the craft UL gameshow so

00:15:51,140 --> 00:15:54,500
for instance if you have a list of

00:15:52,820 --> 00:15:55,459
reviews of episodes of Star Wars you

00:15:54,500 --> 00:15:57,740
might want to be notified immediately

00:15:55,459 --> 00:15:59,620
when you get a new review that's added

00:15:57,740 --> 00:16:01,760
to the list so you can display it and

00:15:59,620 --> 00:16:03,970
under the hood this is most often

00:16:01,760 --> 00:16:06,560
accomplished using WebSockets and

00:16:03,970 --> 00:16:08,420
several community members got together

00:16:06,560 --> 00:16:10,790
and worked on an Apollo WebSocket

00:16:08,420 --> 00:16:13,640
implementation which uses leading iOS

00:16:10,790 --> 00:16:15,770
WebSocket libraries starscream to handle

00:16:13,640 --> 00:16:18,020
all of the socket connections and only

00:16:15,770 --> 00:16:19,839
focuses on how to handle the data coming

00:16:18,020 --> 00:16:22,339
back and forth over that connection and

00:16:19,839 --> 00:16:24,020
basic handling for this looks very much

00:16:22,339 --> 00:16:26,779
like the handling for other queries and

00:16:24,020 --> 00:16:28,100
mutations you get the result and then

00:16:26,779 --> 00:16:29,570
you switch on it if it's a networking

00:16:28,100 --> 00:16:32,209
failure it'll go down to the failure

00:16:29,570 --> 00:16:33,830
case if it you get a response back from

00:16:32,209 --> 00:16:35,680
the server then you need to check

00:16:33,830 --> 00:16:38,570
whether that response contains a result

00:16:35,680 --> 00:16:39,980
an error from your graph QL server or

00:16:38,570 --> 00:16:42,800
both and handle these things

00:16:39,980 --> 00:16:44,600
appropriately the main difference is

00:16:42,800 --> 00:16:46,610
that you have no idea how many times

00:16:44,600 --> 00:16:48,380
this closure is going to be called so

00:16:46,610 --> 00:16:49,790
you need to do a little bit more setup

00:16:48,380 --> 00:16:51,320
work to make sure you don't wind up

00:16:49,790 --> 00:16:53,329
calling things that don't exist anymore

00:16:51,320 --> 00:16:54,860
first you'll need to make sure that you

00:16:53,329 --> 00:16:56,839
have something which is hanging on to

00:16:54,860 --> 00:16:58,490
your subscription then you'll want to

00:16:56,839 --> 00:17:00,320
make sure that you're not creating a

00:16:58,490 --> 00:17:02,089
retain cycle before doing any of your

00:17:00,320 --> 00:17:04,130
handling and bail itself has been D

00:17:02,089 --> 00:17:06,170
allocated then you'll do your normal

00:17:04,130 --> 00:17:08,600
handling and then finally you'll have to

00:17:06,170 --> 00:17:10,610
make sure that whatever is hanging on to

00:17:08,600 --> 00:17:12,050
your subscription actually cancels that

00:17:10,610 --> 00:17:14,600
subscription whenever it gets D

00:17:12,050 --> 00:17:17,569
allocated so these are all of the things

00:17:14,600 --> 00:17:20,480
that the iOS SDK is doing right now but

00:17:17,569 --> 00:17:22,339
you may be thinking well that sounds

00:17:20,480 --> 00:17:27,770
nice but what are you doing to really

00:17:22,339 --> 00:17:29,900
push the SDK forward I love that cat so

00:17:27,770 --> 00:17:33,290
I want to talk a little bit about future

00:17:29,900 --> 00:17:35,600
of the iOS SDK because I want to give a

00:17:33,290 --> 00:17:37,760
small preview of the things that are

00:17:35,600 --> 00:17:40,130
coming up the pike with varying degrees

00:17:37,760 --> 00:17:41,960
of certainty there are a few things

00:17:40,130 --> 00:17:45,559
they're coming sooner rather than later

00:17:41,960 --> 00:17:47,840
and also with a lot more certainty and a

00:17:45,559 --> 00:17:49,669
lot of the stuff came from the developer

00:17:47,840 --> 00:17:50,210
survey that we ran in late August and

00:17:49,669 --> 00:17:52,640
early

00:17:50,210 --> 00:17:54,919
September because while we find out a

00:17:52,640 --> 00:17:56,600
lot of useful information from some

00:17:54,919 --> 00:17:58,909
basic multiple choice questions and

00:17:56,600 --> 00:18:00,799
surveys about some of the ideas one

00:17:58,909 --> 00:18:03,169
thing really jumped out in the freeform

00:18:00,799 --> 00:18:04,909
responses to a few of our questions when

00:18:03,169 --> 00:18:07,159
we asked both what was the thing people

00:18:04,909 --> 00:18:08,809
were having the most trouble with and

00:18:07,159 --> 00:18:11,570
what we could do to make their lives

00:18:08,809 --> 00:18:13,399
easier we found in an enormous number of

00:18:11,570 --> 00:18:15,110
responses pointing to the fact that our

00:18:13,399 --> 00:18:17,179
documentation really needed to get

00:18:15,110 --> 00:18:19,279
beefed up particularly around the more

00:18:17,179 --> 00:18:20,750
advanced features of the library and so

00:18:19,279 --> 00:18:22,399
the past few weeks I've tried really

00:18:20,750 --> 00:18:24,590
hard to focus on getting better

00:18:22,399 --> 00:18:26,090
documentation together we now have full

00:18:24,590 --> 00:18:27,590
documentation for how to use WebSockets

00:18:26,090 --> 00:18:29,120
and I've tried really hard to make the

00:18:27,590 --> 00:18:31,490
caching documentation in particular

00:18:29,120 --> 00:18:32,299
better but documentation only goes so

00:18:31,490 --> 00:18:33,890
far

00:18:32,299 --> 00:18:35,720
I'm also going to be working on a much

00:18:33,890 --> 00:18:37,730
more comprehensive tutorial and sample

00:18:35,720 --> 00:18:39,140
app we have a pretty basic starter

00:18:37,730 --> 00:18:41,090
application people can play with at the

00:18:39,140 --> 00:18:42,620
moment but we found it doesn't cover a

00:18:41,090 --> 00:18:44,899
lot of the cases where people have been

00:18:42,620 --> 00:18:46,010
having problems this is basically the

00:18:44,899 --> 00:18:48,500
project that I'm going to be working on

00:18:46,010 --> 00:18:50,990
after summit now within this survey I

00:18:48,500 --> 00:18:53,600
also took the opportunity to share some

00:18:50,990 --> 00:18:54,559
of my ideas about the library and where

00:18:53,600 --> 00:18:56,720
I want it to be going in the future

00:18:54,559 --> 00:18:58,309
because I want to make sure I'm at least

00:18:56,720 --> 00:19:00,020
roughly on the same page as the

00:18:58,309 --> 00:19:03,440
community in terms of what I wanted to

00:19:00,020 --> 00:19:05,960
do so I made a scale ranging from lol no

00:19:03,440 --> 00:19:07,279
to great idea to gauge interest in the

00:19:05,960 --> 00:19:09,440
ideas and I got some pretty good

00:19:07,279 --> 00:19:11,630
responses on a couple of them one of the

00:19:09,440 --> 00:19:13,730
strongest responses was to asking if we

00:19:11,630 --> 00:19:15,440
should use Swift's built-in codable

00:19:13,730 --> 00:19:16,580
conformance instead of custom JSON

00:19:15,440 --> 00:19:18,679
parsing that we're using at the moment

00:19:16,580 --> 00:19:20,539
so I think this would be advantageous

00:19:18,679 --> 00:19:22,130
since there are a lot of convenient

00:19:20,539 --> 00:19:23,809
things you can do with objects that

00:19:22,130 --> 00:19:25,820
conform to this protocol but beyond

00:19:23,809 --> 00:19:28,760
parsing and our users were

00:19:25,820 --> 00:19:31,279
overwhelmingly in favor of this idea we

00:19:28,760 --> 00:19:32,169
got 0 lol nodes I was very excited about

00:19:31,279 --> 00:19:35,029
that

00:19:32,169 --> 00:19:36,679
related to this both I personally and

00:19:35,029 --> 00:19:38,990
several other people interested in

00:19:36,679 --> 00:19:41,120
contributing to our code generation have

00:19:38,990 --> 00:19:43,220
found that trying to adjust typescript

00:19:41,120 --> 00:19:45,649
code that generates Swift code is

00:19:43,220 --> 00:19:47,750
unnecessarily difficult especially in

00:19:45,649 --> 00:19:50,149
terms of figuring out exactly how types

00:19:47,750 --> 00:19:51,380
turps type systems work so codable

00:19:50,149 --> 00:19:53,510
support is actually going to wind up

00:19:51,380 --> 00:19:55,309
being part of a larger project which is

00:19:53,510 --> 00:19:57,710
moving our swift code generation to

00:19:55,309 --> 00:19:59,210
swift now I will note that at least for

00:19:57,710 --> 00:20:01,429
now we're going to keep the parsing of

00:19:59,210 --> 00:20:03,380
schema and validation of queries we've

00:20:01,429 --> 00:20:03,710
already got going in typescript but

00:20:03,380 --> 00:20:05,929
we're going to

00:20:03,710 --> 00:20:07,789
move the actual generation of swift code

00:20:05,929 --> 00:20:10,399
to Swift this is going to make it a lot

00:20:07,789 --> 00:20:11,899
easier for iOS developers to understand

00:20:10,399 --> 00:20:13,880
and potentially fix the code that's

00:20:11,899 --> 00:20:15,830
generating their model objects and

00:20:13,880 --> 00:20:19,010
parsing and also remove some of the

00:20:15,830 --> 00:20:22,610
tighter coupling between the typescript

00:20:19,010 --> 00:20:24,260
CLI and the Apollo iOS SDK with the

00:20:22,610 --> 00:20:26,029
improved ease of development that comes

00:20:24,260 --> 00:20:28,190
from both not having to switch between

00:20:26,029 --> 00:20:30,169
languages and not having to switch

00:20:28,190 --> 00:20:32,029
between repos in order to build this I'm

00:20:30,169 --> 00:20:34,159
planning to add several features that

00:20:32,029 --> 00:20:35,539
have long been requested specifically

00:20:34,159 --> 00:20:37,880
the codable conformance that I talked

00:20:35,539 --> 00:20:39,289
about earlier we also heard from a lot

00:20:37,880 --> 00:20:41,120
of folks that it would be really helpful

00:20:39,289 --> 00:20:43,940
for the generated objects to conform to

00:20:41,120 --> 00:20:46,100
equatable so iOS 13 added some new

00:20:43,940 --> 00:20:47,870
diffing mechanisms that are a huge

00:20:46,100 --> 00:20:49,940
improvement over what already existed

00:20:47,870 --> 00:20:52,220
and which are a really critical part of

00:20:49,940 --> 00:20:53,690
getting Swift UI to work a huge piece of

00:20:52,220 --> 00:20:55,669
these and other different mechanisms

00:20:53,690 --> 00:20:57,679
rely on objects conforming to the

00:20:55,669 --> 00:20:58,820
equatable and hashable protocols so

00:20:57,679 --> 00:21:01,370
we're planning to add support for that

00:20:58,820 --> 00:21:03,080
to these exciting two to be able to

00:21:01,370 --> 00:21:05,299
support these exciting new tools and

00:21:03,080 --> 00:21:07,190
toys we're also looking to solve some

00:21:05,299 --> 00:21:09,440
problems involving regeneration of code

00:21:07,190 --> 00:21:11,630
by generating the list of file inputs

00:21:09,440 --> 00:21:14,059
and outputs right now if you don't pre

00:21:11,630 --> 00:21:16,279
specify your input and output v files

00:21:14,059 --> 00:21:17,870
manually the build script can cause

00:21:16,279 --> 00:21:19,640
rebuild loops when working with things

00:21:17,870 --> 00:21:22,130
that get rebuilt when any file changes

00:21:19,640 --> 00:21:24,770
such as Swift UI or IB designer Bowls

00:21:22,130 --> 00:21:26,299
with a generated file list we'd be able

00:21:24,770 --> 00:21:28,039
to have you set that up once and then

00:21:26,299 --> 00:21:30,140
allow code generation to take care of

00:21:28,039 --> 00:21:32,360
creating the updated file lists for you

00:21:30,140 --> 00:21:35,299
I'm also particularly excited about

00:21:32,360 --> 00:21:37,370
implementing fragments as protocols the

00:21:35,299 --> 00:21:39,440
nested types currently generated by

00:21:37,370 --> 00:21:41,390
koujun are not the same objects even if

00:21:39,440 --> 00:21:42,919
they contain the same properties now

00:21:41,390 --> 00:21:45,230
this is really helpful for ensuring that

00:21:42,919 --> 00:21:47,450
all of the returned objects contain only

00:21:45,230 --> 00:21:49,010
the requested properties and not all of

00:21:47,450 --> 00:21:50,480
the possible properties of a type which

00:21:49,010 --> 00:21:52,580
may not have even been requested

00:21:50,480 --> 00:21:54,020
however with fragments it's a little bit

00:21:52,580 --> 00:21:56,179
annoying because it means you have to

00:21:54,020 --> 00:21:58,309
specify exactly which call you're using

00:21:56,179 --> 00:22:00,289
before handing things off to your eye

00:21:58,309 --> 00:22:02,480
since the objects returned by each call

00:22:00,289 --> 00:22:04,399
are different but if multiple calls use

00:22:02,480 --> 00:22:06,289
the same fragment they should contain

00:22:04,399 --> 00:22:08,210
the same information that's why

00:22:06,289 --> 00:22:10,039
representing fragments as protocols is

00:22:08,210 --> 00:22:12,169
really exciting for me because it will

00:22:10,039 --> 00:22:14,570
allow you to pass in any type conforming

00:22:12,169 --> 00:22:16,460
to the protocol in a types in a fashion

00:22:14,570 --> 00:22:17,360
without having to specify which call

00:22:16,460 --> 00:22:19,340
that it's coming from

00:22:17,360 --> 00:22:20,990
so I'm psyched about that more

00:22:19,340 --> 00:22:22,580
ambitiously I'd like to essentially

00:22:20,990 --> 00:22:23,750
deprecated the entire part of this talk

00:22:22,580 --> 00:22:25,370
about double optionals

00:22:23,750 --> 00:22:26,900
by adding an enum type that I'm

00:22:25,370 --> 00:22:29,150
tentatively calling a graph to UL

00:22:26,900 --> 00:22:31,430
optional that more clearly outlines the

00:22:29,150 --> 00:22:34,310
possibilities of what needs to be sent

00:22:31,430 --> 00:22:36,830
to the server I also love to add some

00:22:34,310 --> 00:22:39,200
automatic conformance to the Swift 5.1

00:22:36,830 --> 00:22:41,270
identifiable protocol since this is also

00:22:39,200 --> 00:22:43,640
a huge help for dipping in swift UI and

00:22:41,270 --> 00:22:45,620
may have some benefits to us from a

00:22:43,640 --> 00:22:47,060
caching standpoint as well particularly

00:22:45,620 --> 00:22:49,130
for these last two bullet points there

00:22:47,060 --> 00:22:50,690
are some things I'm still working on in

00:22:49,130 --> 00:22:53,030
terms of implementation so these may be

00:22:50,690 --> 00:22:54,410
subject to change so these are things

00:22:53,030 --> 00:22:56,180
that I plan to be working on for the

00:22:54,410 --> 00:22:57,500
next three or three or so months but I

00:22:56,180 --> 00:23:00,830
also want to talk about a few plans that

00:22:57,500 --> 00:23:03,530
I have that are way longer-term these

00:23:00,830 --> 00:23:05,510
are a little fuzzier but I want to share

00:23:03,530 --> 00:23:08,180
some of these goals and then talk about

00:23:05,510 --> 00:23:09,500
why I'm sharing them the first thing is

00:23:08,180 --> 00:23:12,290
that I want to better validate that a

00:23:09,500 --> 00:23:14,360
particular version of our SDK works with

00:23:12,290 --> 00:23:15,920
all three major package managers I've

00:23:14,360 --> 00:23:18,050
already added some dummy checks for this

00:23:15,920 --> 00:23:20,000
but they're all manual so I'm planning

00:23:18,050 --> 00:23:21,500
to get a dependency manager test suite

00:23:20,000 --> 00:23:24,290
up and running with examples of the app

00:23:21,500 --> 00:23:25,850
built with cocoa pods Carthage and a

00:23:24,290 --> 00:23:27,770
swift macit package manager that I can

00:23:25,850 --> 00:23:29,870
actually test new versions again against

00:23:27,770 --> 00:23:31,340
and make sure that no nobody

00:23:29,870 --> 00:23:33,440
accidentally breaks your favorite

00:23:31,340 --> 00:23:35,420
package manager another thing I want to

00:23:33,440 --> 00:23:37,250
look at in long term is how we can

00:23:35,420 --> 00:23:39,170
improve the usability and performance of

00:23:37,250 --> 00:23:40,480
our caching strategy particularly when

00:23:39,170 --> 00:23:42,830
it comes to cache eviction and

00:23:40,480 --> 00:23:45,230
expiration which is essentially handled

00:23:42,830 --> 00:23:47,330
manually at the moment this has a

00:23:45,230 --> 00:23:48,920
possibility of getting moved up to

00:23:47,330 --> 00:23:51,590
coincide with the code January right but

00:23:48,920 --> 00:23:54,020
I'm attempting to not break - too many

00:23:51,590 --> 00:23:56,240
things at the same time so we'll see how

00:23:54,020 --> 00:23:57,770
that goes another thing I want to do in

00:23:56,240 --> 00:23:59,570
the longer term is add more

00:23:57,770 --> 00:24:01,820
supplementary libraries to help better

00:23:59,570 --> 00:24:04,010
integrate with popular libraries this

00:24:01,820 --> 00:24:05,990
was one of the ideas that I suggested in

00:24:04,010 --> 00:24:08,360
the developer survey because it turns

00:24:05,990 --> 00:24:10,250
out that concurrency is really really

00:24:08,360 --> 00:24:12,260
hard it's hard to do many things at the

00:24:10,250 --> 00:24:14,630
same time and have it all work out

00:24:12,260 --> 00:24:16,760
correctly including typing but

00:24:14,630 --> 00:24:18,830
especially also including working with

00:24:16,760 --> 00:24:20,540
networking and caching and people are

00:24:18,830 --> 00:24:22,640
pretty enthusiastic about this idea I

00:24:20,540 --> 00:24:24,860
got a tiny glimmer of lol nose and a lot

00:24:22,640 --> 00:24:26,210
of great ideas and I want to emphasize

00:24:24,860 --> 00:24:28,100
that the list of things that I want to

00:24:26,210 --> 00:24:30,190
do this for is very highly subject to

00:24:28,100 --> 00:24:32,139
change but particularly if you're

00:24:30,190 --> 00:24:33,580
interested in our X Swift I would love

00:24:32,139 --> 00:24:36,340
to talk to you about a partnership on

00:24:33,580 --> 00:24:38,409
this because ultimately a huge part of

00:24:36,340 --> 00:24:40,419
the reason that I am sharing these

00:24:38,409 --> 00:24:42,580
longer-term goals with you is that I am

00:24:40,419 --> 00:24:44,590
only one person and the future of this

00:24:42,580 --> 00:24:46,870
library should not just be about what I

00:24:44,590 --> 00:24:49,450
can do personally I want it to be about

00:24:46,870 --> 00:24:51,789
what you as the community want and what

00:24:49,450 --> 00:24:53,649
we can all build together and also for

00:24:51,789 --> 00:24:55,809
real I would love to get some help to

00:24:53,649 --> 00:24:58,269
get some of these bigger ideas out of

00:24:55,809 --> 00:25:00,100
the starting blocks faster so I recently

00:24:58,269 --> 00:25:02,620
updated the contributor guide for the

00:25:00,100 --> 00:25:04,480
iOS repo if you're interested read it

00:25:02,620 --> 00:25:06,519
hit me up with any questions and with

00:25:04,480 --> 00:25:07,690
that we have reached the portion of the

00:25:06,519 --> 00:25:09,970
talk where I realize I've gone through

00:25:07,690 --> 00:25:11,470
169 slides in 25 minutes

00:25:09,970 --> 00:25:12,549
I should probably remind you of a few

00:25:11,470 --> 00:25:15,190
things I'd like for you to take away

00:25:12,549 --> 00:25:17,769
from this talk if you tried to use

00:25:15,190 --> 00:25:19,470
Apollo iOS before and got frustrated

00:25:17,769 --> 00:25:22,059
check out the new set up it is

00:25:19,470 --> 00:25:23,620
considerably simpler than it was if

00:25:22,059 --> 00:25:26,740
you're just getting started now I

00:25:23,620 --> 00:25:28,690
commend your timing you should also

00:25:26,740 --> 00:25:30,159
check out our updated documentation I

00:25:28,690 --> 00:25:31,450
have tried to plug the biggest holes but

00:25:30,159 --> 00:25:33,370
if there's anything that you're having

00:25:31,450 --> 00:25:35,200
trouble understanding please either

00:25:33,370 --> 00:25:36,450
reach out to me or open an issue and I

00:25:35,200 --> 00:25:38,289
will try to get that addressed in

00:25:36,450 --> 00:25:39,909
addition there's going to be a new

00:25:38,289 --> 00:25:41,769
sample application and step-by-step

00:25:39,909 --> 00:25:43,750
tutorial coming soon for Apollo iOS

00:25:41,769 --> 00:25:45,490
please keep an eye out for that there's

00:25:43,750 --> 00:25:46,809
also going to be some major updates to

00:25:45,490 --> 00:25:49,389
our code generation that will move a

00:25:46,809 --> 00:25:51,129
huge chunk of stuff to Swift if you're

00:25:49,389 --> 00:25:53,019
interested in seeing more details about

00:25:51,129 --> 00:25:55,389
what's coming up there's an official

00:25:53,019 --> 00:25:57,730
roadmap document that's in markdown that

00:25:55,389 --> 00:25:59,970
I plan to update every month or so with

00:25:57,730 --> 00:26:02,379
where things are going at the moment and

00:25:59,970 --> 00:26:04,179
finally I would love any help I can get

00:26:02,379 --> 00:26:05,559
even if it's just telling me exactly

00:26:04,179 --> 00:26:07,269
where some documentation needs to be

00:26:05,559 --> 00:26:08,980
improved remember that if it's making

00:26:07,269 --> 00:26:10,659
you nuts it's almost certainly making

00:26:08,980 --> 00:26:12,820
somebody else nuts and the whole

00:26:10,659 --> 00:26:15,730
community benefits when you contribute

00:26:12,820 --> 00:26:17,110
feedback and fixes to the main repo so I

00:26:15,730 --> 00:26:18,940
wanted to thank you all for coming I'm

00:26:17,110 --> 00:26:20,919
gonna be in the Apollo lounge for

00:26:18,940 --> 00:26:23,289
questions during breaks today come find

00:26:20,919 --> 00:26:26,080
me and say hi I'm gonna stick around for

00:26:23,289 --> 00:26:27,789
Q&A for a couple of minutes favorite

00:26:26,080 --> 00:26:29,080
question gets a nice free copy of this

00:26:27,789 --> 00:26:31,000
book called living by the code that I

00:26:29,080 --> 00:26:32,289
got interviewed for but there's like 40

00:26:31,000 --> 00:26:36,690
other people interviewed in it so it's

00:26:32,289 --> 00:26:36,690
not just about me thank you all so much

00:26:40,980 --> 00:26:45,429
we're not hello raise your hand if

00:26:43,750 --> 00:26:48,490
you've got a question is there a

00:26:45,429 --> 00:26:55,870
microphone here oh yeah there is a mic

00:26:48,490 --> 00:26:59,380
check all right all right

00:26:55,870 --> 00:27:03,179
apparently no one has questions all

00:26:59,380 --> 00:27:03,179
right got one question down here yeah

00:27:14,429 --> 00:27:22,179
hello hello I'm Jim Isaac's from Netflix

00:27:19,299 --> 00:27:26,549
I was wondering what you think about the

00:27:22,179 --> 00:27:29,440
code Jen in terms of how everything is

00:27:26,549 --> 00:27:31,419
coupled to a query and if that's ever

00:27:29,440 --> 00:27:35,519
gonna be optional and a new version of

00:27:31,419 --> 00:27:37,749
it that's a good question and I think

00:27:35,519 --> 00:27:39,369
it's something that I don't think I

00:27:37,749 --> 00:27:43,269
really understood well until I got more

00:27:39,369 --> 00:27:45,159
involved in the the iOS SDK because in

00:27:43,269 --> 00:27:47,019
in the schema you you're able to define

00:27:45,159 --> 00:27:48,519
a full type you're able to say okay this

00:27:47,019 --> 00:27:52,509
is like everything that could possibly

00:27:48,519 --> 00:27:54,579
ever happen with a with a user for

00:27:52,509 --> 00:27:57,129
instance and one of the things that you

00:27:54,579 --> 00:28:01,419
can do with graph QL is you can create a

00:27:57,129 --> 00:28:04,749
request that actually includes includes

00:28:01,419 --> 00:28:07,209
only optional properties but doesn't

00:28:04,749 --> 00:28:08,649
include non optional properties so the

00:28:07,209 --> 00:28:12,099
reason that we're generating these

00:28:08,649 --> 00:28:14,739
queries in a way that allows you to are

00:28:12,099 --> 00:28:19,149
in the way where they're all using that

00:28:14,739 --> 00:28:21,429
that sort of nested system is that that

00:28:19,149 --> 00:28:23,039
allows us to say very safely these are

00:28:21,429 --> 00:28:25,929
the only things that you can get back

00:28:23,039 --> 00:28:27,339
from this particular query we're not

00:28:25,929 --> 00:28:29,349
going to even give you the opportunity

00:28:27,339 --> 00:28:33,399
to try to ask for a property that's not

00:28:29,349 --> 00:28:35,289
there and as far as I know that's not

00:28:33,399 --> 00:28:37,179
something we plan on changing but I

00:28:35,289 --> 00:28:38,469
think it's something where that was one

00:28:37,179 --> 00:28:40,269
of the things that was really hard for

00:28:38,469 --> 00:28:42,519
me to wrap my head around when I first

00:28:40,269 --> 00:28:44,649
started in terms of why that was

00:28:42,519 --> 00:28:48,099
happening but I think as I learned more

00:28:44,649 --> 00:28:50,829
about sort of what the limitations are

00:28:48,099 --> 00:28:52,809
around graph QL that's why we're Jenny

00:28:50,829 --> 00:28:55,749
generating it in that nested way so that

00:28:52,809 --> 00:28:57,159
essentially we're we're trying to make

00:28:55,749 --> 00:28:58,749
sure we're not like accidentally tying

00:28:57,159 --> 00:29:00,009
people's shoelaces together so they trip

00:28:58,749 --> 00:29:01,389
and fall on their face we want to make

00:29:00,009 --> 00:29:03,579
sure that you can only ask for

00:29:01,389 --> 00:29:06,729
properties that are actually there does

00:29:03,579 --> 00:29:10,320
that make sense thank you very much yeah

00:29:06,729 --> 00:29:10,320
one more question over there do you want

00:29:13,080 --> 00:29:17,019
okay apparently we're getting kicked out

00:29:15,519 --> 00:29:18,879
of the room everybody thank you for

00:29:17,019 --> 00:29:20,710
coming I'm gonna lie I would come find

00:29:18,879 --> 00:29:22,749
me like right over here if you're

00:29:20,710 --> 00:29:25,769
interested in more questions thank you

00:29:22,749 --> 00:29:25,769

YouTube URL: https://www.youtube.com/watch?v=TDkbZjLPGgM


