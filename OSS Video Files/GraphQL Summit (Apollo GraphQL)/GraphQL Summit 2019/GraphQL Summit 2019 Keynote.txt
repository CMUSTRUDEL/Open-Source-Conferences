Title: GraphQL Summit 2019 Keynote
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	Matt Debergalis, CTO and Co-Founder of Apollo, kicks off GraphQL Summit with a recap of the recent architectural advances in GraphQL, the various approaches companies are taking to adopt it, and what’s next for the technology.

The keynote explores the new layer of the tech stack called the “data graph” that maps all of a company’s data in one place. The data graph is driving extraordinary adoption of GraphQL and Matt explains how companies like PayPal, Audi, New York Times, and Priceline are using it for their most valuable products and business critical applications.

Matt also gives an overview of the latest advances in the Apollo Platform— from the open source implementation to Apollo’s managed cloud service, Graph Manager.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Captions: 
	00:00:01,020 --> 00:00:06,029
good morning everyone welcome thank you

00:00:03,360 --> 00:00:10,500
for coming I'm excited to be here it's

00:00:06,029 --> 00:00:13,200
amazing - this is ludicrous we've all

00:00:10,500 --> 00:00:16,139
come so far I'm the co-founder and CTO

00:00:13,200 --> 00:00:18,810
of Apollo if you're not familiar with us

00:00:16,139 --> 00:00:20,760
our mission is to advance graph QL and

00:00:18,810 --> 00:00:23,369
bring it to every developer on the

00:00:20,760 --> 00:00:25,410
planet we think it's a transformative

00:00:23,369 --> 00:00:28,830
generational technology that brings

00:00:25,410 --> 00:00:31,380
extraordinary benefits to app developers

00:00:28,830 --> 00:00:33,180
and to teams and companies that care

00:00:31,380 --> 00:00:36,000
deeply about their users and the

00:00:33,180 --> 00:00:38,370
experience they have and my message

00:00:36,000 --> 00:00:42,140
today is simple as Peggy said graph QL

00:00:38,370 --> 00:00:45,420
is mature and graph QL is approachable

00:00:42,140 --> 00:00:47,730
companies are adopting it rapidly I

00:00:45,420 --> 00:00:49,320
might add and not just on the margins

00:00:47,730 --> 00:00:51,480
but in their most valuable products and

00:00:49,320 --> 00:00:53,430
business critical applications they're

00:00:51,480 --> 00:00:55,620
making a big bet on the technology to be

00:00:53,430 --> 00:00:59,610
sure but also on a broader graphed

00:00:55,620 --> 00:01:01,680
strategy and thanks to this momentum the

00:00:59,610 --> 00:01:03,660
graphical community has made great

00:01:01,680 --> 00:01:05,970
progress I think on many of the most

00:01:03,660 --> 00:01:08,610
important questions we faced over the

00:01:05,970 --> 00:01:12,150
last year it's really been a fantastic

00:01:08,610 --> 00:01:13,850
year for the movement and so what I

00:01:12,150 --> 00:01:16,380
wanted to do today is share an

00:01:13,850 --> 00:01:18,600
architectural level what's become clear

00:01:16,380 --> 00:01:21,240
over the last year that has me so

00:01:18,600 --> 00:01:23,630
excited about graph QL and leaves me

00:01:21,240 --> 00:01:25,979
feeling so confident about its future

00:01:23,630 --> 00:01:28,950
so I prepare to talk about a few major

00:01:25,979 --> 00:01:31,140
architectural advances and in practical

00:01:28,950 --> 00:01:33,000
terms why they're important and what

00:01:31,140 --> 00:01:36,390
they mean for teams at each stage of

00:01:33,000 --> 00:01:39,479
graph QL adoption so if you like boxes

00:01:36,390 --> 00:01:43,140
and arrows let me start with the core

00:01:39,479 --> 00:01:44,850
idea of the data graph to explain this

00:01:43,140 --> 00:01:47,100
and to understand the rise of graph QL

00:01:44,850 --> 00:01:50,189
itself let's look at app development

00:01:47,100 --> 00:01:51,930
today pretty much every company feels

00:01:50,189 --> 00:01:52,890
the pressure to build great user

00:01:51,930 --> 00:01:56,070
experience

00:01:52,890 --> 00:01:59,040
it comes from users and customers right

00:01:56,070 --> 00:02:02,220
who expect modern immersive data rich

00:01:59,040 --> 00:02:04,320
features a modern ecommerce experience

00:02:02,220 --> 00:02:06,960
for example can't just be a list of

00:02:04,320 --> 00:02:09,389
products on the screen anymore it also

00:02:06,960 --> 00:02:11,879
needs recommendations reviews

00:02:09,389 --> 00:02:13,400
personalization thoughtful cross-selling

00:02:11,879 --> 00:02:15,769
real-time inventory and

00:02:13,400 --> 00:02:17,180
pricing and so on these are just the

00:02:15,769 --> 00:02:19,040
table stakes to have the kind of

00:02:17,180 --> 00:02:22,819
experience in the kind of application

00:02:19,040 --> 00:02:25,280
that people now expect and more than

00:02:22,819 --> 00:02:28,129
that users want to use these apps on a

00:02:25,280 --> 00:02:29,720
dizzying array of platforms so it's not

00:02:28,129 --> 00:02:34,250
just web and mobile anymore

00:02:29,720 --> 00:02:36,530
IOT the watch voice carplay something

00:02:34,250 --> 00:02:38,780
coming next month and all with a

00:02:36,530 --> 00:02:43,370
seamless overall experience across each

00:02:38,780 --> 00:02:46,639
of them and so the big challenge what's

00:02:43,370 --> 00:02:49,670
really hardest about app dev is writing

00:02:46,639 --> 00:02:53,060
is wiring all that data to all those

00:02:49,670 --> 00:02:54,920
screens the days of a big database or a

00:02:53,060 --> 00:02:58,129
simple back-end powering one front end

00:02:54,920 --> 00:03:00,709
or long gone and so to solve this you

00:02:58,129 --> 00:03:02,269
end up writing a lot of code right and

00:03:00,709 --> 00:03:05,000
whether it's state management and data

00:03:02,269 --> 00:03:06,980
fetching code and your clients or

00:03:05,000 --> 00:03:09,049
whether it's feature api's that are

00:03:06,980 --> 00:03:11,599
tuned for a particular screen that live

00:03:09,049 --> 00:03:13,189
inside your services or maybe it's a

00:03:11,599 --> 00:03:14,810
back-end for front-end that assembles

00:03:13,189 --> 00:03:16,280
data from multiple backends and

00:03:14,810 --> 00:03:18,109
transforms it into something more

00:03:16,280 --> 00:03:20,359
suitable for a particular client

00:03:18,109 --> 00:03:22,609
whatever it is you're doing you're

00:03:20,359 --> 00:03:26,000
writing a ton of special-purpose feature

00:03:22,609 --> 00:03:27,859
specific code and worse yet it's one of

00:03:26,000 --> 00:03:30,319
those m-by-n problems you know what I

00:03:27,859 --> 00:03:33,760
mean every app and every service just

00:03:30,319 --> 00:03:36,319
digs you deeper and deeper into the hole

00:03:33,760 --> 00:03:38,000
that data code is the slow and

00:03:36,319 --> 00:03:40,040
frustrating part of app dev it's what

00:03:38,000 --> 00:03:41,930
limits the kind of user experiences

00:03:40,040 --> 00:03:44,440
teams are realistically able to ship in

00:03:41,930 --> 00:03:48,109
a world of deadlines and constraints and

00:03:44,440 --> 00:03:49,940
frankly it's just an unwelcome detour we

00:03:48,109 --> 00:03:53,810
signed up to make great user experience

00:03:49,940 --> 00:03:56,299
not to do this stuff so the way out is

00:03:53,810 --> 00:04:01,099
the data graph it's a new layer of the

00:03:56,299 --> 00:04:02,299
stack the decouples apps from data and

00:04:01,099 --> 00:04:04,180
it gets you out of the business of

00:04:02,299 --> 00:04:07,040
building all that brutal plumbing and

00:04:04,180 --> 00:04:11,120
graph QL of course is the language of

00:04:07,040 --> 00:04:14,709
that graph services describe their

00:04:11,120 --> 00:04:16,880
capabilities as graph QL schema

00:04:14,709 --> 00:04:19,430
applications describe what they need

00:04:16,880 --> 00:04:23,120
their requirements as graphical queries

00:04:19,430 --> 00:04:25,340
and the graph is a rendezvous point or a

00:04:23,120 --> 00:04:26,139
marketplace that connects the two

00:04:25,340 --> 00:04:29,469
together

00:04:26,139 --> 00:04:32,039
and this this architecture is what's

00:04:29,469 --> 00:04:34,569
driving graph fuels extraordinary growth

00:04:32,039 --> 00:04:37,300
when most people talk about adopting

00:04:34,569 --> 00:04:40,419
graph QL this is the thing they mean a

00:04:37,300 --> 00:04:42,400
data graph it's the architecture that

00:04:40,419 --> 00:04:44,830
best allows teams with existing data and

00:04:42,400 --> 00:04:49,120
existing apps to get on the graph QL

00:04:44,830 --> 00:04:51,090
train and enjoy its benefits and that's

00:04:49,120 --> 00:04:53,620
exactly what so many teams are doing

00:04:51,090 --> 00:04:55,479
companies of every size and every kind

00:04:53,620 --> 00:04:57,159
of market are putting a data graph into

00:04:55,479 --> 00:05:01,139
their stack and putting their most

00:04:57,159 --> 00:05:03,250
important applications on that graph

00:05:01,139 --> 00:05:05,349
PayPal for example has made a huge

00:05:03,250 --> 00:05:08,789
commitment to the graph they have over

00:05:05,349 --> 00:05:11,110
50 products now relying on a data graph

00:05:08,789 --> 00:05:13,270
replacing tightly coupled handwritten

00:05:11,110 --> 00:05:16,000
back-end for friends with graphical

00:05:13,270 --> 00:05:18,610
schemas and queries taking advantage of

00:05:16,000 --> 00:05:21,930
graph fuels great tooling to ship faster

00:05:18,610 --> 00:05:21,930
and improve the developer experience

00:05:22,289 --> 00:05:26,379
nerd wallet just rolled out their first

00:05:24,669 --> 00:05:28,900
graph to support their shopping and

00:05:26,379 --> 00:05:31,750
rewards platform the graph replaced

00:05:28,900 --> 00:05:33,550
one-off api's and SDKs and it allowed

00:05:31,750 --> 00:05:35,979
their teams to collaborate on cross

00:05:33,550 --> 00:05:37,900
product features that were difficult to

00:05:35,979 --> 00:05:41,469
build with their previous siloed

00:05:37,900 --> 00:05:43,270
architecture so what is it about the

00:05:41,469 --> 00:05:45,219
data graph that makes it suitable why

00:05:43,270 --> 00:05:49,149
this particular approach and what's

00:05:45,219 --> 00:05:51,849
allowed it to grow so quickly well for

00:05:49,149 --> 00:05:55,930
one it's really good it's just a better

00:05:51,849 --> 00:05:58,529
way to do api's first it puts all your

00:05:55,930 --> 00:06:00,460
data in one place with always up-to-date

00:05:58,529 --> 00:06:02,349
documentation and it gives every

00:06:00,460 --> 00:06:06,750
developer a single consistent way to

00:06:02,349 --> 00:06:10,060
discover and access that data to it

00:06:06,750 --> 00:06:12,520
decouples your apps from your services

00:06:10,060 --> 00:06:14,050
allowing each to evolve in their own

00:06:12,520 --> 00:06:16,360
best way without any costly

00:06:14,050 --> 00:06:22,599
entanglements we're having to navigate

00:06:16,360 --> 00:06:25,270
conflicting priorities and three it lets

00:06:22,599 --> 00:06:27,639
us build great experience faster not

00:06:25,270 --> 00:06:29,680
just with less code but like PayPal and

00:06:27,639 --> 00:06:31,960
many others are finding because of great

00:06:29,680 --> 00:06:36,699
tools that enable teams to be more

00:06:31,960 --> 00:06:38,169
productive than ever but it's not good

00:06:36,699 --> 00:06:40,479
enough to be good

00:06:38,169 --> 00:06:43,539
for a technology to spread quickly it

00:06:40,479 --> 00:06:45,069
also has to be approachable and that's

00:06:43,539 --> 00:06:47,680
the really big benefit of this

00:06:45,069 --> 00:06:49,930
architecture it encourages an

00:06:47,680 --> 00:06:52,900
incremental approach that lets a single

00:06:49,930 --> 00:06:54,879
team get immediate benefits while laying

00:06:52,900 --> 00:06:58,389
the foundation for something that will

00:06:54,879 --> 00:07:00,219
grow over time so in particular a

00:06:58,389 --> 00:07:02,199
product engineering team can build a

00:07:00,219 --> 00:07:04,479
simple graph all on their own as many of

00:07:02,199 --> 00:07:06,789
you have enough to support a first

00:07:04,479 --> 00:07:09,340
product feature and get that graph all

00:07:06,789 --> 00:07:12,400
the way into production in just a sprint

00:07:09,340 --> 00:07:14,740
or two you don't need any changes to the

00:07:12,400 --> 00:07:16,870
backend or help from the team that owns

00:07:14,740 --> 00:07:19,150
it and you don't need to convert your

00:07:16,870 --> 00:07:21,669
whole app at once it's it's better

00:07:19,150 --> 00:07:26,259
really just to start with one screen or

00:07:21,669 --> 00:07:28,629
one component adding more data to that

00:07:26,259 --> 00:07:31,509
foundation is easy you can talk to

00:07:28,629 --> 00:07:35,469
anything rest of course thrift G RPC

00:07:31,509 --> 00:07:38,349
soap XML RPC whatever you've got with

00:07:35,469 --> 00:07:40,509
zero change we're working with teams

00:07:38,349 --> 00:07:42,969
that are integrating mainframe data into

00:07:40,509 --> 00:07:44,830
their graph QL and they do it because

00:07:42,969 --> 00:07:46,960
the data graph lets them build

00:07:44,830 --> 00:07:48,729
extraordinary experiences on top of

00:07:46,960 --> 00:07:51,490
something that was too cumbersome before

00:07:48,729 --> 00:07:55,509
and each thing you connect into the

00:07:51,490 --> 00:07:56,889
graph adds more and more value as you do

00:07:55,509 --> 00:08:00,219
that it's very natural to add more

00:07:56,889 --> 00:08:02,169
applications the adjacent native mobile

00:08:00,219 --> 00:08:05,560
app perhaps to the first desktop app

00:08:02,169 --> 00:08:08,139
that you built and as you add the third

00:08:05,560 --> 00:08:10,439
the fourth the fifth application the

00:08:08,139 --> 00:08:13,539
value of the graph grows and grows and

00:08:10,439 --> 00:08:15,250
often you can simply replace entire

00:08:13,539 --> 00:08:16,659
backends for front ends with just

00:08:15,250 --> 00:08:21,490
queries because the data is already

00:08:16,659 --> 00:08:24,339
there there's a virtuous cycle here a

00:08:21,490 --> 00:08:26,439
literal Network effect to the graph and

00:08:24,339 --> 00:08:29,800
what I think is especially interesting

00:08:26,439 --> 00:08:33,940
is that the graph is really a product in

00:08:29,800 --> 00:08:36,430
its own right it's not just a better

00:08:33,940 --> 00:08:38,640
query language or some technical change

00:08:36,430 --> 00:08:40,839
to how data moves around the network

00:08:38,640 --> 00:08:42,760
it's a fundamental and essential

00:08:40,839 --> 00:08:45,910
building block for the modern stack

00:08:42,760 --> 00:08:47,920
centered around a schema the catalog of

00:08:45,910 --> 00:08:49,720
all your data and the tools and

00:08:47,920 --> 00:08:50,630
techniques we use to manage and access

00:08:49,720 --> 00:08:53,420
that data

00:08:50,630 --> 00:08:55,190
that schema is what makes the data graph

00:08:53,420 --> 00:08:57,589
different from rest and other API

00:08:55,190 --> 00:08:59,930
technologies more than being about the

00:08:57,589 --> 00:09:02,300
details of how to fetch it it's really

00:08:59,930 --> 00:09:05,089
about the data itself and making that

00:09:02,300 --> 00:09:08,149
data more useful accessible meaningful

00:09:05,089 --> 00:09:09,740
and valuable and so I encourage you to

00:09:08,149 --> 00:09:12,649
think about the graph this way as a

00:09:09,740 --> 00:09:14,839
product even at the earliest stages when

00:09:12,649 --> 00:09:19,370
it's the first few engineers building

00:09:14,839 --> 00:09:20,810
that first schema so the data graph

00:09:19,370 --> 00:09:24,470
architecture is valuable and

00:09:20,810 --> 00:09:26,329
approachable it's also mature about a

00:09:24,470 --> 00:09:29,170
year ago we wrote a set of 10 principles

00:09:26,329 --> 00:09:31,459
that document the essential concepts and

00:09:29,170 --> 00:09:35,420
methodology behind building a proper

00:09:31,459 --> 00:09:37,250
graph they're not my ideas they reflect

00:09:35,420 --> 00:09:38,839
what I've seen works best at hundreds of

00:09:37,250 --> 00:09:41,149
companies who've built out a data graph

00:09:38,839 --> 00:09:42,649
and since we first wrote these we've

00:09:41,149 --> 00:09:44,540
become more and more confident that

00:09:42,649 --> 00:09:46,190
they'll serve as a helpful guide and

00:09:44,540 --> 00:09:50,690
roadmap for teams building out a graph

00:09:46,190 --> 00:09:52,339
themselves they cover three main areas a

00:09:50,690 --> 00:09:54,199
set of principles that define the

00:09:52,339 --> 00:09:57,620
overall shape and structure of the graph

00:09:54,199 --> 00:10:00,160
a set of principles that lay out an

00:09:57,620 --> 00:10:03,290
agile development process for the graph

00:10:00,160 --> 00:10:05,569
and a set of principles that cover how

00:10:03,290 --> 00:10:06,589
to operate the graph and integrate it

00:10:05,569 --> 00:10:10,339
with the rest of your production

00:10:06,589 --> 00:10:12,380
environment I urge you to read these and

00:10:10,339 --> 00:10:14,000
share with your team they'll help you

00:10:12,380 --> 00:10:16,310
get the most out of your investment in

00:10:14,000 --> 00:10:20,329
the graph and from the tools and systems

00:10:16,310 --> 00:10:22,730
that support it these principles also

00:10:20,329 --> 00:10:26,300
frame some important differences between

00:10:22,730 --> 00:10:28,519
graph QL api's and traditional api's for

00:10:26,300 --> 00:10:30,800
example often we're used to thinking

00:10:28,519 --> 00:10:34,100
about api's as being the perfect normal

00:10:30,800 --> 00:10:36,230
representation of our data we spend a

00:10:34,100 --> 00:10:37,819
long time on them in large part because

00:10:36,230 --> 00:10:40,519
they're really hard to change once

00:10:37,819 --> 00:10:42,709
they're in the field but the data graph

00:10:40,519 --> 00:10:45,199
isn't like that instead we found over

00:10:42,709 --> 00:10:47,630
and again that it's better to adopt a

00:10:45,199 --> 00:10:49,209
demand oriented schema that's designed

00:10:47,630 --> 00:10:51,470
for how clients want the data and

00:10:49,209 --> 00:10:53,990
instead of a waterfall approach to

00:10:51,470 --> 00:10:56,930
design what works far better is an

00:10:53,990 --> 00:10:58,699
iterative approach the team is getting

00:10:56,930 --> 00:11:01,130
the most from their graph approach it

00:10:58,699 --> 00:11:03,380
like product development they ship early

00:11:01,130 --> 00:11:03,900
and often thinking in terms of a

00:11:03,380 --> 00:11:06,750
continued

00:11:03,900 --> 00:11:09,570
a sloop from design to build to ship to

00:11:06,750 --> 00:11:11,040
learning and back to design and rather

00:11:09,570 --> 00:11:13,110
than focusing on getting the graph

00:11:11,040 --> 00:11:15,210
exactly right the first time which

00:11:13,110 --> 00:11:17,490
doesn't work that well what you actually

00:11:15,210 --> 00:11:20,040
want is to optimize and accelerate that

00:11:17,490 --> 00:11:22,440
cycle time until you're able to iterate

00:11:20,040 --> 00:11:26,460
on the graph at the same speed that you

00:11:22,440 --> 00:11:28,170
iterate on products and the graph

00:11:26,460 --> 00:11:31,020
complete with the right tooling lets us

00:11:28,170 --> 00:11:33,800
do exactly that let me show you an

00:11:31,020 --> 00:11:36,150
example of how this works with Apollo

00:11:33,800 --> 00:11:38,640
Apollo is more than just a graph QL

00:11:36,150 --> 00:11:40,590
server it also includes components like

00:11:38,640 --> 00:11:42,300
a central schema registry that acts as a

00:11:40,590 --> 00:11:45,840
source of truth for what's in the graph

00:11:42,300 --> 00:11:48,480
and a system for capturing metrics about

00:11:45,840 --> 00:11:50,790
how the graph is used these are a

00:11:48,480 --> 00:11:54,960
co-equal part of the graph alongside

00:11:50,790 --> 00:11:58,320
that server and one thing they let us do

00:11:54,960 --> 00:12:01,230
is schema change validation the idea is

00:11:58,320 --> 00:12:03,270
really simple from CI we can take a

00:12:01,230 --> 00:12:05,820
proposed update to the graph the

00:12:03,270 --> 00:12:08,030
registry lets us compute a diff against

00:12:05,820 --> 00:12:10,710
some previous version of the schema and

00:12:08,030 --> 00:12:12,750
then we validate each of those changes

00:12:10,710 --> 00:12:15,810
against the actual known production

00:12:12,750 --> 00:12:17,460
traffic against the graph and because

00:12:15,810 --> 00:12:19,350
graph kill is statically typed and

00:12:17,460 --> 00:12:21,060
because clients express their specific

00:12:19,350 --> 00:12:24,060
data requirements in the form of queries

00:12:21,060 --> 00:12:27,240
we can do that algebra statically at

00:12:24,060 --> 00:12:29,040
Build time and so the upshot is we can

00:12:27,240 --> 00:12:30,810
validate changes even against

00:12:29,040 --> 00:12:33,390
applications for which we don't readily

00:12:30,810 --> 00:12:35,790
have access to their code like older

00:12:33,390 --> 00:12:37,770
versions of a mobile app or an ad-hoc

00:12:35,790 --> 00:12:40,890
script written by the marketing team

00:12:37,770 --> 00:12:43,230
that queries your graph and you will by

00:12:40,890 --> 00:12:46,530
the way have ad-hoc scripts written by

00:12:43,230 --> 00:12:49,140
the marketing team and we don't just get

00:12:46,530 --> 00:12:51,810
a list of queries or fields that don't

00:12:49,140 --> 00:12:54,390
work we get an actual manifest of

00:12:51,810 --> 00:12:58,110
registered clients adversely affected by

00:12:54,390 --> 00:12:59,610
the change without a ton of work this

00:12:58,110 --> 00:13:01,740
kind of thing isn't really possible with

00:12:59,610 --> 00:13:03,510
legacy ap is when something hits a rest

00:13:01,740 --> 00:13:05,880
endpoint you really have no way to know

00:13:03,510 --> 00:13:09,060
how that data is being used what the

00:13:05,880 --> 00:13:10,830
intent was and what makes it possible to

00:13:09,060 --> 00:13:13,860
do this with the data graph are these

00:13:10,830 --> 00:13:17,280
components it's a critical point the

00:13:13,860 --> 00:13:18,930
graph is more than just some resolvers

00:13:17,280 --> 00:13:21,300
it's a catalogue of what data is

00:13:18,930 --> 00:13:23,610
available what clients are using the

00:13:21,300 --> 00:13:26,490
graph structured logs of how they

00:13:23,610 --> 00:13:29,250
consume it a historical record of how

00:13:26,490 --> 00:13:30,630
changes over time and a set of workflows

00:13:29,250 --> 00:13:32,280
that are built on these like schema

00:13:30,630 --> 00:13:36,390
change validation and others that you'll

00:13:32,280 --> 00:13:38,250
see during the conference we call this

00:13:36,390 --> 00:13:40,590
stuff the graph manager and you'll need

00:13:38,250 --> 00:13:41,850
one whether you use one built in with

00:13:40,590 --> 00:13:44,670
Apollo or build something like this

00:13:41,850 --> 00:13:46,590
yourself these tools and workflows are

00:13:44,670 --> 00:13:49,550
an essential element of the graph and

00:13:46,590 --> 00:13:51,990
we're a lot of its biggest value lies

00:13:49,550 --> 00:13:54,960
okay so we have a clear architecture and

00:13:51,990 --> 00:13:57,780
the tools to support it the last most

00:13:54,960 --> 00:13:59,400
important thing is the talent products

00:13:57,780 --> 00:14:03,470
have owners right someone has to own

00:13:59,400 --> 00:14:06,570
this thing so there's a new role a

00:14:03,470 --> 00:14:08,910
really interesting job I think that we

00:14:06,570 --> 00:14:11,160
keep seeing come up in companies that

00:14:08,910 --> 00:14:14,280
are adopting the graph it's the data

00:14:11,160 --> 00:14:16,440
graph champion it's the people that take

00:14:14,280 --> 00:14:18,450
responsibility for the graph as a

00:14:16,440 --> 00:14:22,380
product and come to work to make it a

00:14:18,450 --> 00:14:23,760
success early on this may be too silly a

00:14:22,380 --> 00:14:26,310
distinction right it's the team that

00:14:23,760 --> 00:14:27,480
wrote the server but remember I said

00:14:26,310 --> 00:14:29,130
earlier it's helpful to think of the

00:14:27,480 --> 00:14:30,990
graph as a product and so even at the

00:14:29,130 --> 00:14:33,390
start we can talk about some of the

00:14:30,990 --> 00:14:37,650
responsibilities that start to emerge

00:14:33,390 --> 00:14:39,120
and define this role first one's pretty

00:14:37,650 --> 00:14:41,160
straightforward it's the team that deals

00:14:39,120 --> 00:14:43,610
with the infrastructure your tools your

00:14:41,160 --> 00:14:46,290
gateways editor integrations and so on

00:14:43,610 --> 00:14:47,940
it's worth carving out the time to do

00:14:46,290 --> 00:14:49,770
this especially as the graph grows

00:14:47,940 --> 00:14:51,360
because many of the people working with

00:14:49,770 --> 00:14:53,580
the graph won't be as familiar with

00:14:51,360 --> 00:14:57,960
graphical tools and how valuable they

00:14:53,580 --> 00:15:00,060
are the second more interesting one I

00:14:57,960 --> 00:15:02,700
think is responsibility for the overall

00:15:00,060 --> 00:15:05,790
health of the graph part of this is

00:15:02,700 --> 00:15:08,310
establishing conventions patterns styles

00:15:05,790 --> 00:15:10,670
and so on ensuring that the whole graph

00:15:08,310 --> 00:15:13,250
feels consistent across all its parts

00:15:10,670 --> 00:15:15,810
design like a product would be designed

00:15:13,250 --> 00:15:18,450
and a really interesting part of this is

00:15:15,810 --> 00:15:20,580
metrics I've noticed a lot of teams

00:15:18,450 --> 00:15:23,130
starting to think carefully about what

00:15:20,580 --> 00:15:25,589
to measure and how to set goals for

00:15:23,130 --> 00:15:28,740
their data graph you might start with

00:15:25,589 --> 00:15:30,330
performance availability metrics but you

00:15:28,740 --> 00:15:32,250
can go much further

00:15:30,330 --> 00:15:34,500
at Apollo we're starting to borrow ideas

00:15:32,250 --> 00:15:37,920
from product teams and give our graph

00:15:34,500 --> 00:15:39,570
owners adoption and growth metrics it's

00:15:37,920 --> 00:15:41,370
interesting because the graph captures

00:15:39,570 --> 00:15:42,870
intent you can do some really

00:15:41,370 --> 00:15:44,850
interesting things here going beyond

00:15:42,870 --> 00:15:46,350
technical measures to track the real

00:15:44,850 --> 00:15:50,340
value of what you've built into the

00:15:46,350 --> 00:15:52,440
graph and finally and I think this is

00:15:50,340 --> 00:15:53,880
really cool the graph champion ends up

00:15:52,440 --> 00:15:57,090
spending a lot of time helping other

00:15:53,880 --> 00:15:59,570
teams be successful the data graph team

00:15:57,090 --> 00:16:01,440
at Expedia is a great example of this

00:15:59,570 --> 00:16:04,080
Expedia has jumped a hundred percent

00:16:01,440 --> 00:16:06,270
into the graph if you book travel hotel

00:16:04,080 --> 00:16:08,850
flights on Expedia you're using an

00:16:06,270 --> 00:16:10,110
Expedia wide data graph the dozens of

00:16:08,850 --> 00:16:12,690
engineering organizations are

00:16:10,110 --> 00:16:14,310
contributing to and what's happened is

00:16:12,690 --> 00:16:16,410
that the team that initially implemented

00:16:14,310 --> 00:16:19,200
the graph now finds if they spend much

00:16:16,410 --> 00:16:21,150
of their time helping others and they

00:16:19,200 --> 00:16:23,550
found there's a whole art and discipline

00:16:21,150 --> 00:16:25,140
to this task one thing they've learned

00:16:23,550 --> 00:16:28,560
for example is that instead of being

00:16:25,140 --> 00:16:29,970
gatekeepers for the perfect schema it's

00:16:28,560 --> 00:16:32,340
better to help teams get on the graph

00:16:29,970 --> 00:16:34,200
quickly and then give them the tools

00:16:32,340 --> 00:16:36,570
they need to iterate their way to a

00:16:34,200 --> 00:16:39,150
better design to teach a man to fish

00:16:36,570 --> 00:16:41,850
sort of thing and so you can see how all

00:16:39,150 --> 00:16:43,680
this ties together you make sure the

00:16:41,850 --> 00:16:46,830
tools are in place to support an agile

00:16:43,680 --> 00:16:49,650
iterative process be clear about what

00:16:46,830 --> 00:16:51,630
good looks like and then help teams help

00:16:49,650 --> 00:16:53,240
guide teams to get there empowering them

00:16:51,630 --> 00:16:55,500
to be graph developers themselves

00:16:53,240 --> 00:16:57,360
without getting too much in the way and

00:16:55,500 --> 00:17:00,810
letting the graph grow and spread across

00:16:57,360 --> 00:17:02,850
the organization does this sound

00:17:00,810 --> 00:17:06,720
familiar how many people here are doing

00:17:02,850 --> 00:17:10,350
some part of this today how many want to

00:17:06,720 --> 00:17:13,650
do more of this yeah I I think it's a

00:17:10,350 --> 00:17:15,510
cool job awesome so before moving on let

00:17:13,650 --> 00:17:17,280
me reiterate the key point here the

00:17:15,510 --> 00:17:19,140
growth of graph QL is tied to the need

00:17:17,280 --> 00:17:21,630
for a data graph I want to be really

00:17:19,140 --> 00:17:23,580
explicit about this and it's an

00:17:21,630 --> 00:17:25,380
approachable and mature architecture

00:17:23,580 --> 00:17:29,550
that will serve you and your team's well

00:17:25,380 --> 00:17:31,920
I talked to earlier about the network

00:17:29,550 --> 00:17:34,170
effect of the graph and how over time it

00:17:31,920 --> 00:17:36,330
can and will expand and so this brings

00:17:34,170 --> 00:17:38,310
me that the second major development how

00:17:36,330 --> 00:17:40,740
to effectively manage and expand and

00:17:38,310 --> 00:17:43,620
graph particularly as it grows into a

00:17:40,740 --> 00:17:48,030
shared resource that multiple teams use

00:17:43,620 --> 00:17:50,730
and depend on here's the issue for most

00:17:48,030 --> 00:17:51,450
teams at some point a monolith doesn't

00:17:50,730 --> 00:17:54,480
make sense

00:17:51,450 --> 00:17:56,880
whether for collaboration modularity

00:17:54,480 --> 00:17:58,950
fault isolation or to accommodate

00:17:56,880 --> 00:18:02,220
diverse technical stacks scaling

00:17:58,950 --> 00:18:04,350
whatever it is teams want a story for

00:18:02,220 --> 00:18:07,290
how to implement a graph in separable

00:18:04,350 --> 00:18:09,090
parts it's by far the most frequent

00:18:07,290 --> 00:18:10,950
question that I've heard from Apollo

00:18:09,090 --> 00:18:14,550
developers who are delighted with the

00:18:10,950 --> 00:18:19,650
graph but aren't sure if or how to scale

00:18:14,550 --> 00:18:21,600
it up what we want is fairly clear a

00:18:19,650 --> 00:18:23,460
federated architecture that allows

00:18:21,600 --> 00:18:25,740
multiple teams to build a single graph

00:18:23,460 --> 00:18:28,950
from separate parts but the reality is

00:18:25,740 --> 00:18:31,460
that's hard in the past stitching

00:18:28,950 --> 00:18:34,620
multiple schemas together like this

00:18:31,460 --> 00:18:36,960
required a lot of code it's not the kind

00:18:34,620 --> 00:18:39,809
of code you want to be writing it's code

00:18:36,960 --> 00:18:42,270
that joins pieces of data and really

00:18:39,809 --> 00:18:44,070
intricate and hard to debug ways there's

00:18:42,270 --> 00:18:45,300
operational issues like how do you

00:18:44,070 --> 00:18:47,460
coordinate the Gateway and the

00:18:45,300 --> 00:18:49,890
underlying services so that they move

00:18:47,460 --> 00:18:51,179
forward and sync it's difficult to

00:18:49,890 --> 00:18:52,620
understand the behavior of a

00:18:51,179 --> 00:18:55,170
hand-written system like this at runtime

00:18:52,620 --> 00:18:56,940
and you don't get a lot of the benefits

00:18:55,170 --> 00:18:59,280
of graph QL like strong end-to-end

00:18:56,940 --> 00:19:02,940
typing static analysis during

00:18:59,280 --> 00:19:04,380
development and so forth so working

00:19:02,940 --> 00:19:06,900
closely with many teams that went down

00:19:04,380 --> 00:19:10,679
this path this summer we released Apollo

00:19:06,900 --> 00:19:13,860
Federation a specification for how to

00:19:10,679 --> 00:19:16,860
compose multiple graphs together into

00:19:13,860 --> 00:19:20,300
one and it addresses the three concerns

00:19:16,860 --> 00:19:23,520
we heard over and again from teams

00:19:20,300 --> 00:19:26,550
number one it gets you proper separation

00:19:23,520 --> 00:19:28,530
of concerns Federation allows you to

00:19:26,550 --> 00:19:30,720
build the graph and completely isolated

00:19:28,530 --> 00:19:33,030
pieces each responsible for one part of

00:19:30,720 --> 00:19:36,750
the graph without complex entanglements

00:19:33,030 --> 00:19:39,000
between them two it's a declarative

00:19:36,750 --> 00:19:43,770
architecture you don't have to write

00:19:39,000 --> 00:19:45,360
code and three it's just graph QL its

00:19:43,770 --> 00:19:47,010
standard compliant you don't have to

00:19:45,360 --> 00:19:50,460
rewrite your apps doesn't break your

00:19:47,010 --> 00:19:53,730
tools and this isn't just for really

00:19:50,460 --> 00:19:56,190
large companies Federation is really a

00:19:53,730 --> 00:19:57,040
model for team collaboration at every

00:19:56,190 --> 00:19:59,380
scale

00:19:57,040 --> 00:20:00,670
no tell an office and property

00:19:59,380 --> 00:20:03,670
management company at a New York City

00:20:00,670 --> 00:20:05,500
runs a federated graph it brings

00:20:03,670 --> 00:20:08,530
together every team each with its own

00:20:05,500 --> 00:20:10,660
product deliverables in roadmap covering

00:20:08,530 --> 00:20:12,850
everything from core building data to

00:20:10,660 --> 00:20:14,670
ticketing and support to their supply

00:20:12,850 --> 00:20:17,830
chain management to their sales team

00:20:14,670 --> 00:20:20,350
each team owns its piece and ships its

00:20:17,830 --> 00:20:22,180
products but all brought together into a

00:20:20,350 --> 00:20:26,340
single graph that makes it easy to

00:20:22,180 --> 00:20:26,340
navigate all of know tells data as one

00:20:26,610 --> 00:20:30,880
at a technical level Federation is just

00:20:29,260 --> 00:20:32,980
a way to compose schemas and query

00:20:30,880 --> 00:20:36,970
across them let's look at an example

00:20:32,980 --> 00:20:38,920
schema with products and reviews what

00:20:36,970 --> 00:20:41,590
Federation lets us do is implement that

00:20:38,920 --> 00:20:43,630
schema in pieces like this one team

00:20:41,590 --> 00:20:47,320
handling products the other team

00:20:43,630 --> 00:20:49,600
handling reviews but the better way to

00:20:47,320 --> 00:20:52,170
look at it is this Federation lets two

00:20:49,600 --> 00:20:55,660
teams working completely independently

00:20:52,170 --> 00:20:57,610
collaborate on a single shared graph and

00:20:55,660 --> 00:20:59,320
all the big ideas of Federation are on

00:20:57,610 --> 00:21:01,780
this screen we have proper separation of

00:20:59,320 --> 00:21:02,830
concerns the review and product services

00:21:01,780 --> 00:21:04,660
written in completely different

00:21:02,830 --> 00:21:08,470
technologies can reference and extend

00:21:04,660 --> 00:21:10,000
each other without making the relevant

00:21:08,470 --> 00:21:13,780
code scattered across more than one

00:21:10,000 --> 00:21:15,330
place it's declarative there's no code

00:21:13,780 --> 00:21:19,450
to stitch these schemas together

00:21:15,330 --> 00:21:21,460
Federation instead uses keys and strong

00:21:19,450 --> 00:21:25,000
typing to allow static validation of how

00:21:21,460 --> 00:21:28,240
the scheme is composed together and it's

00:21:25,000 --> 00:21:30,940
just graph QL these services on the Left

00:21:28,240 --> 00:21:34,060
are standalone you can develop test and

00:21:30,940 --> 00:21:36,700
run each of them in isolation and also

00:21:34,060 --> 00:21:39,940
the graph you get that's graph QL - it

00:21:36,700 --> 00:21:42,010
looks right like a person designed it it

00:21:39,940 --> 00:21:44,530
doesn't expose the service boundaries to

00:21:42,010 --> 00:21:48,540
the clients and the clients and the

00:21:44,530 --> 00:21:50,980
tools can work with it unmodified and

00:21:48,540 --> 00:21:52,510
here again it's the tools and the

00:21:50,980 --> 00:21:55,480
workflows that really make this stuff

00:21:52,510 --> 00:21:57,070
come alive in Apollo's implementation of

00:21:55,480 --> 00:21:58,900
Federation the graph manager tracks

00:21:57,070 --> 00:22:01,360
schemas for each service that makes up

00:21:58,900 --> 00:22:03,550
the graph so when you deploy a new

00:22:01,360 --> 00:22:06,490
version of a service you also push that

00:22:03,550 --> 00:22:09,130
definition to the graph manager it runs

00:22:06,490 --> 00:22:10,240
the composition algorithm computes a new

00:22:09,130 --> 00:22:11,830
schema

00:22:10,240 --> 00:22:14,290
pushes that to the running gateway

00:22:11,830 --> 00:22:17,320
potentially after a review or approval

00:22:14,290 --> 00:22:19,180
step and then the Gateway exposes that

00:22:17,320 --> 00:22:20,710
new graph and smoothly transitions over

00:22:19,180 --> 00:22:23,290
to it without any interruption to your

00:22:20,710 --> 00:22:25,390
clients so there's no need to change or

00:22:23,290 --> 00:22:25,750
restart or even give teams access to the

00:22:25,390 --> 00:22:28,500
Gateway

00:22:25,750 --> 00:22:31,690
it's just shared infrastructure at

00:22:28,500 --> 00:22:33,070
runtime the Gateway executes incoming

00:22:31,690 --> 00:22:36,550
queries by splitting them across

00:22:33,070 --> 00:22:39,850
underlying services and to do that it

00:22:36,550 --> 00:22:42,160
first constructs a query plan every

00:22:39,850 --> 00:22:43,750
query has one it's the recipe that the

00:22:42,160 --> 00:22:45,970
Gateway is going to use to fetch from

00:22:43,750 --> 00:22:48,250
the underlying services what order and

00:22:45,970 --> 00:22:50,080
parallel or serial which keys is it

00:22:48,250 --> 00:22:53,800
going to use how does it do joins and so

00:22:50,080 --> 00:22:56,500
on and akin to a database the query plan

00:22:53,800 --> 00:22:59,710
is something you can look at so it gets

00:22:56,500 --> 00:23:01,420
logged and you can use it to diagnose

00:22:59,710 --> 00:23:03,130
how the graph works and understand

00:23:01,420 --> 00:23:07,300
problems and performance issues in

00:23:03,130 --> 00:23:09,130
production schema change validation

00:23:07,300 --> 00:23:11,350
works too and now it's it's kind of the

00:23:09,130 --> 00:23:13,510
Holy Grail one team can validate a

00:23:11,350 --> 00:23:16,090
change that they want to make to just

00:23:13,510 --> 00:23:18,430
their service the graph manager takes

00:23:16,090 --> 00:23:20,740
that proposed change composes it with

00:23:18,430 --> 00:23:22,630
the balance of the graph generates a DIF

00:23:20,740 --> 00:23:24,790
validates each piece of that diff

00:23:22,630 --> 00:23:26,920
against the known production traffic and

00:23:24,790 --> 00:23:29,680
what we end up with is a list of clients

00:23:26,920 --> 00:23:32,740
that would be affected adversely by the

00:23:29,680 --> 00:23:34,420
proposed change it lets each team go at

00:23:32,740 --> 00:23:36,310
their own pace to support their own work

00:23:34,420 --> 00:23:38,950
with the safety belt of knowing that

00:23:36,310 --> 00:23:43,330
every use of their data is safely

00:23:38,950 --> 00:23:45,430
confirmed against each change like graph

00:23:43,330 --> 00:23:46,870
qo itself Federation's of speck it's a

00:23:45,430 --> 00:23:49,180
set of conventions that anything can

00:23:46,870 --> 00:23:50,740
implement in just a few months after we

00:23:49,180 --> 00:23:53,860
published it what's really exciting to

00:23:50,740 --> 00:23:56,770
me is the community momentum behind

00:23:53,860 --> 00:23:58,900
Federation a ton of servers including

00:23:56,770 --> 00:24:01,930
popular projects like graphical Java and

00:23:58,900 --> 00:24:03,730
graphical Ruby now support this so you

00:24:01,930 --> 00:24:05,320
can mix and match these into a single

00:24:03,730 --> 00:24:07,270
graph as we do ourselves at Apollo

00:24:05,320 --> 00:24:12,340
combining Kotlin and typescript services

00:24:07,270 --> 00:24:15,250
into one graph for our own API and it's

00:24:12,340 --> 00:24:18,370
not just languages graphical native

00:24:15,250 --> 00:24:20,110
databases to have added support and I'm

00:24:18,370 --> 00:24:22,240
excited to share that both the D graph

00:24:20,110 --> 00:24:23,890
and fauna databases now implement the

00:24:22,240 --> 00:24:25,720
Federation specification

00:24:23,890 --> 00:24:27,549
and can be plugged directly into a data

00:24:25,720 --> 00:24:30,850
graph alongside traditional graph QL

00:24:27,549 --> 00:24:33,730
servers like we saw before and that

00:24:30,850 --> 00:24:35,289
opens some interesting doors perhaps

00:24:33,730 --> 00:24:37,480
something like reviews that I talked

00:24:35,289 --> 00:24:39,640
about earlier is a good fit for a native

00:24:37,480 --> 00:24:41,919
database implementation taking advantage

00:24:39,640 --> 00:24:45,940
of built-in searching or aggregation

00:24:41,919 --> 00:24:47,649
capabilities or consider building a new

00:24:45,940 --> 00:24:50,080
application when you already have a data

00:24:47,649 --> 00:24:52,360
graph often applications have just a

00:24:50,080 --> 00:24:55,390
little bit of data that's specific to

00:24:52,360 --> 00:24:57,309
that one app with a federation where

00:24:55,390 --> 00:24:58,990
database expending the graph with say

00:24:57,309 --> 00:25:01,899
one or two extra types in a couple

00:24:58,990 --> 00:25:05,139
fields you might end up running in no

00:25:01,899 --> 00:25:06,460
time at all so we're super excited to

00:25:05,139 --> 00:25:10,330
work with anyone to help implement

00:25:06,460 --> 00:25:11,769
apollo federation and we're also happy

00:25:10,330 --> 00:25:14,620
to help teams with graphs make the

00:25:11,769 --> 00:25:16,240
transition for those of you thinking

00:25:14,620 --> 00:25:19,870
about expansion we have two Talk's today

00:25:16,240 --> 00:25:22,029
that i encourage you to attend first jim

00:25:19,870 --> 00:25:23,740
gust and dan burner from Expedia will

00:25:22,029 --> 00:25:25,929
share how they built out their Expedia

00:25:23,740 --> 00:25:27,820
graph and how they use stitching and how

00:25:25,929 --> 00:25:29,880
Federation to manage its expansion

00:25:27,820 --> 00:25:32,649
across the org

00:25:29,880 --> 00:25:34,240
later Jeff Hampton from Apollo will

00:25:32,649 --> 00:25:36,340
offer a hands-on look at the core

00:25:34,240 --> 00:25:38,380
concepts behind Federation and how you

00:25:36,340 --> 00:25:44,110
can use them to implement modular

00:25:38,380 --> 00:25:45,940
schemas the third development I want to

00:25:44,110 --> 00:25:48,700
look at is on the consumption side the

00:25:45,940 --> 00:25:50,799
modern client stack that's emerged for

00:25:48,700 --> 00:25:52,659
the lion's share of teams this is where

00:25:50,799 --> 00:25:54,909
you first encounter graph QL and it's

00:25:52,659 --> 00:25:56,500
amazing benefits and quite a bit has

00:25:54,909 --> 00:26:00,370
changed over the last year that you can

00:25:56,500 --> 00:26:03,070
take advantage of I want to focus on

00:26:00,370 --> 00:26:05,740
react here Apollo has grown up alongside

00:26:03,070 --> 00:26:07,779
react and for most app developers it's

00:26:05,740 --> 00:26:11,110
those two technologies that make the

00:26:07,779 --> 00:26:13,000
core of your client architecture the

00:26:11,110 --> 00:26:15,330
idea is pretty compelling right react

00:26:13,000 --> 00:26:17,710
handles the UI Apollo handles the data

00:26:15,330 --> 00:26:20,440
they're both declarative technologies

00:26:17,710 --> 00:26:22,720
you express intent instead of writing a

00:26:20,440 --> 00:26:24,789
bunch of boilerplate we used to write

00:26:22,720 --> 00:26:28,860
code to manage the Dom but no more and

00:26:24,789 --> 00:26:31,240
same for Apollo and managing your data

00:26:28,860 --> 00:26:32,610
the combination is matured in the last

00:26:31,240 --> 00:26:36,070
year a couple things have happened

00:26:32,610 --> 00:26:37,809
number one is hooks Apollo's gone

00:26:36,070 --> 00:26:40,389
through a series of interfaces to react

00:26:37,809 --> 00:26:43,330
from hoc x' to query components and now

00:26:40,389 --> 00:26:45,999
hooks and hooks gives us by far the

00:26:43,330 --> 00:26:48,909
cleanest and most satisfying api for

00:26:45,999 --> 00:26:50,919
integrating the two it allows a really

00:26:48,909 --> 00:26:53,289
natural and pleasing way to staple a

00:26:50,919 --> 00:26:54,820
query to a component representing its

00:26:53,289 --> 00:26:58,210
data requirements in a concise and

00:26:54,820 --> 00:27:00,129
composable way hooks support recently

00:26:58,210 --> 00:27:01,749
got added to Apollo client and we

00:27:00,129 --> 00:27:06,099
strongly encourage you to adopt this

00:27:01,749 --> 00:27:09,909
pattern in your applications the other

00:27:06,099 --> 00:27:11,679
development of course is typescript we

00:27:09,909 --> 00:27:13,619
found it exceptionally valuable at

00:27:11,679 --> 00:27:17,529
Apollo as many others have as well

00:27:13,619 --> 00:27:20,139
modern react plus Apollo Plus typescript

00:27:17,529 --> 00:27:23,739
gives you strong end to end typing

00:27:20,139 --> 00:27:26,159
across the entire stack from your

00:27:23,739 --> 00:27:28,539
database all the way through your UI and

00:27:26,159 --> 00:27:30,159
that combination with all the parts

00:27:28,539 --> 00:27:32,849
working together is really

00:27:30,159 --> 00:27:35,859
transformative for app development

00:27:32,849 --> 00:27:37,629
here's one example in Apollo when you

00:27:35,859 --> 00:27:39,999
write a query like this one on the left

00:27:37,629 --> 00:27:41,859
for the users information it

00:27:39,999 --> 00:27:44,320
automatically generates a typescript

00:27:41,859 --> 00:27:45,879
interface for that query pulling in the

00:27:44,320 --> 00:27:48,609
schema from the registry to get the

00:27:45,879 --> 00:27:50,619
types and the doc strings so now your

00:27:48,609 --> 00:27:53,859
editor and your compiler have your back

00:27:50,619 --> 00:27:56,139
is you write client code so in this case

00:27:53,859 --> 00:27:57,729
it makes sure that you never forget to

00:27:56,139 --> 00:27:59,859
check for a null display name before

00:27:57,729 --> 00:28:01,629
using it and it protects you if the

00:27:59,859 --> 00:28:04,599
schema change is later on to a now knows

00:28:01,629 --> 00:28:06,159
in a field you've been using these are

00:28:04,599 --> 00:28:08,679
the kind of bugs that you lose days

00:28:06,159 --> 00:28:13,570
trying to hunt down and they just go

00:28:08,679 --> 00:28:15,759
away with these modern tools another

00:28:13,570 --> 00:28:19,210
example Apollo client isn't just for

00:28:15,759 --> 00:28:20,979
remote data there's an elegant model

00:28:19,210 --> 00:28:21,639
where you can compose schemas on the

00:28:20,979 --> 00:28:24,369
client

00:28:21,639 --> 00:28:27,879
much like we saw with Federation to

00:28:24,369 --> 00:28:30,519
represent local state as well we brought

00:28:27,879 --> 00:28:33,330
that idea into Apollo client core in 2.6

00:28:30,519 --> 00:28:36,339
and again I recommend adopting it and

00:28:33,330 --> 00:28:40,149
the cool thing here is the tools know

00:28:36,339 --> 00:28:42,909
this schema so autocomplete linting

00:28:40,149 --> 00:28:46,419
typescript interfaces all that stuff

00:28:42,909 --> 00:28:49,119
reflects the composed schema that's

00:28:46,419 --> 00:28:51,010
specific to your client and it captures

00:28:49,119 --> 00:28:53,600
all the data in your app

00:28:51,010 --> 00:28:55,490
strong end-to-end types for all your

00:28:53,600 --> 00:28:57,950
data including local state all

00:28:55,490 --> 00:29:02,809
implemented in a simple declarative code

00:28:57,950 --> 00:29:05,750
based on a common API and the best news

00:29:02,809 --> 00:29:07,490
is this is all approachable you don't

00:29:05,750 --> 00:29:09,919
have to rewrite your client or have a

00:29:07,490 --> 00:29:12,919
huge flag day to take advantage of it

00:29:09,919 --> 00:29:14,809
right after this talk Bri Bunge is going

00:29:12,919 --> 00:29:18,080
to show you how Airbnb is incrementally

00:29:14,809 --> 00:29:19,880
adopting these ideas going to typescript

00:29:18,080 --> 00:29:23,950
connecting Redux to the graph moving

00:29:19,880 --> 00:29:23,950
components over to local state and so on

00:29:24,909 --> 00:29:29,059
Airbnb I think is a great proof point

00:29:27,559 --> 00:29:31,549
for the value of this modern stack

00:29:29,059 --> 00:29:34,520
they've pushed this technology as far as

00:29:31,549 --> 00:29:36,860
anyone and in my mind there's nobody

00:29:34,520 --> 00:29:39,950
that values world class user experience

00:29:36,860 --> 00:29:44,200
and development velocity more than they

00:29:39,950 --> 00:29:46,610
do they've been a great partner of ours

00:29:44,200 --> 00:29:47,990
so what does a poll client really do for

00:29:46,610 --> 00:29:51,740
them and what do they get out of it

00:29:47,990 --> 00:29:52,669
exactly to talk about that let me zoom

00:29:51,740 --> 00:29:55,309
out for a second

00:29:52,669 --> 00:29:58,520
what is the client really the heart of

00:29:55,309 --> 00:30:01,970
Apollo client is its cache which holds

00:29:58,520 --> 00:30:04,399
all your application data and there's

00:30:01,970 --> 00:30:06,860
api's and plugins that connect that cash

00:30:04,399 --> 00:30:10,820
to your components your local state the

00:30:06,860 --> 00:30:13,399
network and so on it's the cache that

00:30:10,820 --> 00:30:15,529
makes the client really valuable it acts

00:30:13,399 --> 00:30:17,899
like an air traffic controller for all

00:30:15,529 --> 00:30:19,850
of your app data and it's especially

00:30:17,899 --> 00:30:22,700
useful for the kind of complex you is

00:30:19,850 --> 00:30:24,830
that modern clients have it lets you

00:30:22,700 --> 00:30:26,960
compose components in any combination on

00:30:24,830 --> 00:30:28,909
the screen making sure all the parts of

00:30:26,960 --> 00:30:31,220
your screen are always consistent with

00:30:28,909 --> 00:30:33,770
the data that they show it avoids

00:30:31,220 --> 00:30:35,990
unnecessary fetches over the network so

00:30:33,770 --> 00:30:38,090
users can have a smooth fast experience

00:30:35,990 --> 00:30:41,870
as they navigate between different parts

00:30:38,090 --> 00:30:44,809
of the application all that stuff is

00:30:41,870 --> 00:30:46,580
hard to test hard to debug code you used

00:30:44,809 --> 00:30:49,340
to have to write by hand to have that

00:30:46,580 --> 00:30:53,179
really delicious app experience for

00:30:49,340 --> 00:30:54,860
every piece of the app but as you roll

00:30:53,179 --> 00:30:56,570
this out across large apps you of course

00:30:54,860 --> 00:30:59,179
you run into limits and working with

00:30:56,570 --> 00:31:01,130
Airbnb and others we found cases where

00:30:59,179 --> 00:31:04,419
you had to think too much about how

00:31:01,130 --> 00:31:09,549
Apollo is doing its job and not

00:31:04,419 --> 00:31:12,340
what you wanted your app to do consider

00:31:09,549 --> 00:31:14,350
search this is an interesting case to me

00:31:12,340 --> 00:31:15,909
where that cache machinery maybe isn't

00:31:14,350 --> 00:31:17,799
as helpful out of the box

00:31:15,909 --> 00:31:20,070
typically with search we're fetching

00:31:17,799 --> 00:31:24,070
just a little bit of data a few fields

00:31:20,070 --> 00:31:26,590
about a lot of objects that data is not

00:31:24,070 --> 00:31:28,509
likely to change over time I've never

00:31:26,590 --> 00:31:32,080
seen a search interface that changes

00:31:28,509 --> 00:31:33,549
data underneath you and it doesn't need

00:31:32,080 --> 00:31:36,700
to be kept in sync with other parts of

00:31:33,549 --> 00:31:38,320
the UI and once the user navigates away

00:31:36,700 --> 00:31:40,749
from search we don't really need to keep

00:31:38,320 --> 00:31:42,720
it around the whole point of search is

00:31:40,749 --> 00:31:45,850
to get people where they are going so

00:31:42,720 --> 00:31:47,830
the cost of normalizing all these small

00:31:45,850 --> 00:31:49,659
objects and storing them and the cache

00:31:47,830 --> 00:31:51,759
doesn't really pencil out here and

00:31:49,659 --> 00:31:53,649
that's a good example of the kind of

00:31:51,759 --> 00:31:57,549
pattern we've wanted to improve an

00:31:53,649 --> 00:32:00,489
Apollo for your app to be good search

00:31:57,549 --> 00:32:02,259
has to be good too and we want Apollo to

00:32:00,489 --> 00:32:04,749
help with that letting the client do the

00:32:02,259 --> 00:32:08,109
work for you so you can focus on the

00:32:04,749 --> 00:32:10,720
important stuff so I'm really excited to

00:32:08,109 --> 00:32:12,309
announce the first beta of this the pert

00:32:10,720 --> 00:32:16,029
excuse me the first beta released this

00:32:12,309 --> 00:32:18,220
week of Apollo client 3 it's all about

00:32:16,029 --> 00:32:20,739
better management of how you keep data

00:32:18,220 --> 00:32:22,659
around built on a new implementation of

00:32:20,739 --> 00:32:24,789
the core cache that consolidates these

00:32:22,659 --> 00:32:27,730
sort of use cases into a unified

00:32:24,789 --> 00:32:29,859
programming model it has built-in

00:32:27,730 --> 00:32:32,769
patterns for things like pagination they

00:32:29,859 --> 00:32:35,259
come up over and over again but also

00:32:32,769 --> 00:32:37,929
comes with the fine-grained controls you

00:32:35,259 --> 00:32:41,350
need to manage these edge cases like

00:32:37,929 --> 00:32:43,269
search many here will be happy to hear

00:32:41,350 --> 00:32:45,549
for example that a poll client 3 now

00:32:43,269 --> 00:32:50,470
gives you control over data eviction and

00:32:45,549 --> 00:32:52,409
garbage collection in the cache and lest

00:32:50,470 --> 00:32:55,299
you think that this comes at a high cost

00:32:52,409 --> 00:32:57,789
it doesn't we were able to do this with

00:32:55,299 --> 00:32:59,739
a smaller and faster client optimizing

00:32:57,789 --> 00:33:01,690
as we brought these ideas into core and

00:32:59,739 --> 00:33:06,279
structuring Apollo to let you import

00:33:01,690 --> 00:33:08,679
just the parts you need so as I

00:33:06,279 --> 00:33:10,299
mentioned stick around for Bri at Airbnb

00:33:08,679 --> 00:33:12,159
and for those interested in the details

00:33:10,299 --> 00:33:14,980
of what's new and Apollo client 3 and

00:33:12,159 --> 00:33:16,749
how you can make the transition later

00:33:14,980 --> 00:33:17,890
today Ben Newman lead architect for

00:33:16,749 --> 00:33:20,170
Apollo client will

00:33:17,890 --> 00:33:26,950
do a deep dive into the new cache and

00:33:20,170 --> 00:33:29,820
the patterns that that enables so let me

00:33:26,950 --> 00:33:33,940
summarize graph QL is mature and

00:33:29,820 --> 00:33:38,020
approachable and here's some key ideas

00:33:33,940 --> 00:33:40,800
for success build the data graph treat

00:33:38,020 --> 00:33:44,020
it like a product from the beginning

00:33:40,800 --> 00:33:48,300
start small adopt an incremental

00:33:44,020 --> 00:33:48,300
approach but think big it's gonna grow

00:33:48,750 --> 00:33:54,280
figure out who the graph champion is

00:33:51,400 --> 00:33:55,810
going to be if that's you think about

00:33:54,280 --> 00:33:57,640
how you can leverage your graph skills

00:33:55,810 --> 00:33:59,860
across your whole team and how you're

00:33:57,640 --> 00:34:04,420
gonna measure the health and success of

00:33:59,860 --> 00:34:06,460
your work take advantage of the tools

00:34:04,420 --> 00:34:08,710
and technologies that's where a lot of

00:34:06,460 --> 00:34:11,290
the value is and you're gonna see a ton

00:34:08,710 --> 00:34:12,820
of examples today on tomorrow so find

00:34:11,290 --> 00:34:16,840
the ones that make sense for you and

00:34:12,820 --> 00:34:18,520
bring them back to your team and follow

00:34:16,840 --> 00:34:21,060
the principles and best practices that

00:34:18,520 --> 00:34:23,230
we've found worked best for data graphs

00:34:21,060 --> 00:34:25,210
learn from your colleagues learn from

00:34:23,230 --> 00:34:27,340
your conference attendees share what's

00:34:25,210 --> 00:34:31,750
worked for you these things will serve

00:34:27,340 --> 00:34:33,669
you well no matter where you are in your

00:34:31,750 --> 00:34:36,790
journey there's a clear approachable

00:34:33,669 --> 00:34:39,040
next step a path forward and we're here

00:34:36,790 --> 00:34:41,110
to help it's why we put on the

00:34:39,040 --> 00:34:43,270
conference it's what's behind our

00:34:41,110 --> 00:34:45,250
commitment to open source our graph

00:34:43,270 --> 00:34:48,370
manager tools and our commercial

00:34:45,250 --> 00:34:49,570
services to help teams at every stage so

00:34:48,370 --> 00:34:51,669
here at the conference we've put

00:34:49,570 --> 00:34:53,770
together a road map to the data graph

00:34:51,669 --> 00:34:56,020
series of talks full of concrete

00:34:53,770 --> 00:34:59,080
practical guidance for each step of the

00:34:56,020 --> 00:35:01,540
journey for teams just getting started

00:34:59,080 --> 00:35:03,670
the main thing is getting your data into

00:35:01,540 --> 00:35:05,800
a graph and seeing that end-to-end

00:35:03,670 --> 00:35:07,870
developer experience for the first time

00:35:05,800 --> 00:35:10,120
that that allows and later this morning

00:35:07,870 --> 00:35:12,940
Danielle Mann will show you exactly what

00:35:10,120 --> 00:35:15,130
that looks like if you're putting

00:35:12,940 --> 00:35:16,990
features into production Michael Watson

00:35:15,130 --> 00:35:19,030
a solution architect at Apollo will

00:35:16,990 --> 00:35:21,130
present do's and don'ts for your schema

00:35:19,030 --> 00:35:22,840
covering topics like how to make sure

00:35:21,130 --> 00:35:27,310
you have a demand oriented graph that

00:35:22,840 --> 00:35:29,290
matches the needs of the client tomorrow

00:35:27,310 --> 00:35:30,630
for teams looking to adopt and

00:35:29,290 --> 00:35:32,700
accelerate

00:35:30,630 --> 00:35:34,620
they're agile graph development Evans

00:35:32,700 --> 00:35:36,150
Hauser an engineer on our graph manager

00:35:34,620 --> 00:35:38,130
team will show you how to implement

00:35:36,150 --> 00:35:39,630
field rollover and some of the other

00:35:38,130 --> 00:35:44,580
techniques that are made possible with

00:35:39,630 --> 00:35:46,770
the data graph and finally for teams

00:35:44,580 --> 00:35:50,070
running a stitching gateway or if you're

00:35:46,770 --> 00:35:51,510
interested in Federation atoms ions lead

00:35:50,070 --> 00:35:52,980
of our infrastructure team at Apollo

00:35:51,510 --> 00:35:55,770
we'll walk through how we incrementally

00:35:52,980 --> 00:35:57,780
transition to our own API to Federation

00:35:55,770 --> 00:36:00,050
with concrete guidance along the way for

00:35:57,780 --> 00:36:00,050
you

00:36:03,680 --> 00:36:10,350
we started this Apollo effort because we

00:36:06,780 --> 00:36:12,240
saw the potential of graph QL were

00:36:10,350 --> 00:36:17,640
dedicated to the vision that every

00:36:12,240 --> 00:36:19,950
developer should have a graph you know

00:36:17,640 --> 00:36:23,400
the Apollo name has a special meaning

00:36:19,950 --> 00:36:27,060
for me 50 years ago we sent this thing

00:36:23,400 --> 00:36:29,300
to the moon and I think for many of us

00:36:27,060 --> 00:36:31,860
who practice the engineering craft

00:36:29,300 --> 00:36:35,720
Apollo represents the finest sort of

00:36:31,860 --> 00:36:42,170
effort brilliant technical design

00:36:35,720 --> 00:36:45,890
phenomenal execution zero scope creep a

00:36:42,170 --> 00:36:49,170
relentless focus on the key objective

00:36:45,890 --> 00:36:51,930
but most of all it was a staggering

00:36:49,170 --> 00:36:55,490
accomplishment that brought us all

00:36:51,930 --> 00:37:00,120
together brought out the best in us and

00:36:55,490 --> 00:37:03,180
changed the world forever and that's how

00:37:00,120 --> 00:37:06,210
I think about this community graph QL is

00:37:03,180 --> 00:37:08,310
not some small thing it's a rare

00:37:06,210 --> 00:37:11,480
opportunity I think to improve in a

00:37:08,310 --> 00:37:15,720
fundamental way how we write software

00:37:11,480 --> 00:37:19,800
create new experiences and welcome more

00:37:15,720 --> 00:37:21,800
people to our trade and as I think about

00:37:19,800 --> 00:37:24,030
the years to come it seems to me that

00:37:21,800 --> 00:37:27,660
we're all gonna look back on this moment

00:37:24,030 --> 00:37:30,450
as a really special time when all of us

00:37:27,660 --> 00:37:32,510
who saw it a bit early made a big bet

00:37:30,450 --> 00:37:39,330
together on something important and

00:37:32,510 --> 00:37:40,980
promising so let's not forget that learn

00:37:39,330 --> 00:37:44,040
and share as much as you can at this

00:37:40,980 --> 00:37:44,400
conference please come talk to me I'm

00:37:44,040 --> 00:37:47,760
real

00:37:44,400 --> 00:37:50,339
eager to learn from you but let's also

00:37:47,760 --> 00:37:53,400
not forget also just to take a moment to

00:37:50,339 --> 00:37:56,970
appreciate what we've done and who we've

00:37:53,400 --> 00:38:01,230
done it with and how far we'll all go

00:37:56,970 --> 00:38:02,820
working together thank you enjoy the

00:38:01,230 --> 00:38:07,469
conference

00:38:02,820 --> 00:38:07,469

YouTube URL: https://www.youtube.com/watch?v=EDqw-sGVq3k


