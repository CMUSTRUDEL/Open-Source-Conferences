Title: Migrating to Apollo + GraphQL at Airbnb (BRIE BUNGE - Software Engineer at Airbnb)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	You've heard that Apollo & GraphQL are amazing technologies that can help your organization build faster. But, what about all of the existing code that relies on REST endpoints? In this talk, we'll show how we migrated to Apollo at Airbnb. We'll cover our use of TypeScript, incrementally adopting GraphQL in our React + Redux codebase, and lessons learned along the way to help you make a similar transition at your organization.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Captions: 
	00:00:02,670 --> 00:00:08,260
hello grouchy all summit and everyone on

00:00:05,470 --> 00:00:10,900
the livestream Matt just shared with us

00:00:08,260 --> 00:00:12,610
the modern client stack suppose you're

00:00:10,900 --> 00:00:14,650
at the point where you're convinced that

00:00:12,610 --> 00:00:17,380
graph QL and Apollo are right for you as

00:00:14,650 --> 00:00:19,150
you should be but you're looking at your

00:00:17,380 --> 00:00:22,450
codebase and wondering how to get from

00:00:19,150 --> 00:00:24,370
point A to point B my name is Bree Bunge

00:00:22,450 --> 00:00:26,890
and I'm a front-end software engineer at

00:00:24,370 --> 00:00:29,050
Airbnb I'd like to share with you some

00:00:26,890 --> 00:00:30,790
on-the-ground tactical tips for

00:00:29,050 --> 00:00:33,520
migrating to Apollo and graph QL at

00:00:30,790 --> 00:00:38,380
scale incrementally and without

00:00:33,520 --> 00:00:40,450
regressions changing the underlying data

00:00:38,380 --> 00:00:42,520
fetching infrastructure of a large code

00:00:40,450 --> 00:00:44,350
base is challenging there's a lot of

00:00:42,520 --> 00:00:46,410
code to migrate and users who would be

00:00:44,350 --> 00:00:48,520
affected if anything were to go wrong

00:00:46,410 --> 00:00:51,040
we've been through the migration process

00:00:48,520 --> 00:00:53,020
on several teams at Airbnb and collected

00:00:51,040 --> 00:00:54,550
lessons along the way that we hope to

00:00:53,020 --> 00:00:56,170
share with you in case you are

00:00:54,550 --> 00:01:00,850
navigating a similar situation at your

00:00:56,170 --> 00:01:03,520
organization first we'll recap the

00:01:00,850 --> 00:01:07,659
progress we've made adopting graph QL at

00:01:03,520 --> 00:01:11,380
Airbnb strategies we've used for

00:01:07,659 --> 00:01:14,009
migrating and exciting projects in the

00:01:11,380 --> 00:01:18,310
works that leverage Apollo and graph QL

00:01:14,009 --> 00:01:21,189
at last year's graph GL summit Adam nary

00:01:18,310 --> 00:01:22,990
shout out in the audience there shared

00:01:21,189 --> 00:01:25,380
how we're using Apollo engraft QL to be

00:01:22,990 --> 00:01:27,579
ridiculously productive on the front end

00:01:25,380 --> 00:01:29,409
we've made a lot of progress since last

00:01:27,579 --> 00:01:33,609
year to bring these benefits to more and

00:01:29,409 --> 00:01:35,350
more teams this year a small scrappy

00:01:33,609 --> 00:01:37,209
team of engineers from across product

00:01:35,350 --> 00:01:39,249
and infrastructure banded together to

00:01:37,209 --> 00:01:42,759
rewrite our mobile web experience as a

00:01:39,249 --> 00:01:44,859
PWA or progressive web application the

00:01:42,759 --> 00:01:47,439
new experience drove enormous gains in

00:01:44,859 --> 00:01:49,539
page load time and provided a much more

00:01:47,439 --> 00:01:52,389
intuitive experience for the user we

00:01:49,539 --> 00:01:56,979
also used it as an opportunity to roll

00:01:52,389 --> 00:01:59,319
out more graph QL as sections of the

00:01:56,979 --> 00:02:00,819
experience were migrated to graph QL we

00:01:59,319 --> 00:02:03,969
saw a steady increase in production

00:02:00,819 --> 00:02:06,159
traffic to our graph QL Gateway mobile

00:02:03,969 --> 00:02:08,440
web was a driving force here but we also

00:02:06,159 --> 00:02:11,290
saw adoption across our host tools on

00:02:08,440 --> 00:02:13,120
desktop iOS and Android engineers are

00:02:11,290 --> 00:02:15,420
working on rollouts for their platforms

00:02:13,120 --> 00:02:15,420
as well

00:02:16,020 --> 00:02:21,370
today around five point eight percent of

00:02:19,180 --> 00:02:24,070
all production traffic on Airbnb is

00:02:21,370 --> 00:02:25,690
going using graph QL and that number

00:02:24,070 --> 00:02:30,220
will likely exceed ten percent by the

00:02:25,690 --> 00:02:32,560
end of the year among the first product

00:02:30,220 --> 00:02:35,920
surfaces to have might been migrated our

00:02:32,560 --> 00:02:39,970
search our product detail page and the

00:02:35,920 --> 00:02:42,490
booking flow work has already begun on a

00:02:39,970 --> 00:02:44,500
single guest platform with tooling to

00:02:42,490 --> 00:02:49,750
drive productivity across seven product

00:02:44,500 --> 00:02:52,210
surfaces in the guest flow that's

00:02:49,750 --> 00:02:54,550
awesome progress but how did we get

00:02:52,210 --> 00:02:59,620
there let's look at some migration

00:02:54,550 --> 00:03:01,150
strategies we've used the most common

00:02:59,620 --> 00:03:03,580
text app were coming from for these

00:03:01,150 --> 00:03:06,880
migrations is a combination of rest

00:03:03,580 --> 00:03:08,230
endpoints react and redux and the amount

00:03:06,880 --> 00:03:10,840
of code and projects we've migrated

00:03:08,230 --> 00:03:15,310
ranges anywhere from 30,000 to 90,000

00:03:10,840 --> 00:03:20,950
lines what we'd like to use instead is

00:03:15,310 --> 00:03:23,850
react paired with graph QL and Apollo we

00:03:20,950 --> 00:03:26,170
have a few options on how to get there

00:03:23,850 --> 00:03:28,600
the first is that we could rewrite our

00:03:26,170 --> 00:03:32,920
app from scratch this sounds awesome

00:03:28,600 --> 00:03:35,050
right it's always so tempting but it's

00:03:32,920 --> 00:03:37,390
rare that we get the chance but we have

00:03:35,050 --> 00:03:39,209
been lucky in some cases timing it with

00:03:37,390 --> 00:03:41,620
redesigns or the start of a new project

00:03:39,209 --> 00:03:44,170
however it's not always an option given

00:03:41,620 --> 00:03:46,000
time and resources plus the

00:03:44,170 --> 00:03:47,860
institutional knowledge encoded in a

00:03:46,000 --> 00:03:52,510
large app takes a lot of time to get

00:03:47,860 --> 00:03:54,670
right and unwind instead we could stop

00:03:52,510 --> 00:03:57,790
and refactor our app and we've seen this

00:03:54,670 --> 00:03:59,200
work well on small or solo teams the

00:03:57,790 --> 00:04:01,209
risk though is that it's painful to

00:03:59,200 --> 00:04:02,590
reconcile a long live fork or feature

00:04:01,209 --> 00:04:04,420
branch when there are many developers

00:04:02,590 --> 00:04:06,640
actively working in their repository and

00:04:04,420 --> 00:04:08,530
the more changes we make in isolation

00:04:06,640 --> 00:04:12,700
means the more place for bugs to hide

00:04:08,530 --> 00:04:15,400
and we don't want that the final option

00:04:12,700 --> 00:04:16,900
we've used is an incremental approach we

00:04:15,400 --> 00:04:18,669
found this to be the safest and most

00:04:16,900 --> 00:04:21,190
feasible option in most circumstances

00:04:18,669 --> 00:04:23,620
given a large team and a large

00:04:21,190 --> 00:04:27,340
pre-existing codebase so let's delve

00:04:23,620 --> 00:04:28,510
more into how this has worked we'll

00:04:27,340 --> 00:04:31,120
break down the process

00:04:28,510 --> 00:04:33,850
the five stages our goal at each stage

00:04:31,120 --> 00:04:36,250
is to have a shippable fully functional

00:04:33,850 --> 00:04:39,880
regression free version of our app along

00:04:36,250 --> 00:04:43,390
the way before we begin some

00:04:39,880 --> 00:04:46,000
prerequisites will want a graph QL and

00:04:43,390 --> 00:04:48,250
point on the back end I won't cover how

00:04:46,000 --> 00:04:49,690
Airbnb moved to graph QL on the back end

00:04:48,250 --> 00:04:51,850
but you can check out this medium post

00:04:49,690 --> 00:04:56,500
on the Airbnb engineering blog if you're

00:04:51,850 --> 00:04:58,120
interested in learning more the second

00:04:56,500 --> 00:05:00,040
is that we wanted to use typescript on

00:04:58,120 --> 00:05:01,840
the front end because we can generate

00:05:00,040 --> 00:05:04,090
typescript types for our queries

00:05:01,840 --> 00:05:05,740
directly from the schema which is a

00:05:04,090 --> 00:05:08,530
single source of truth between the back

00:05:05,740 --> 00:05:10,870
end and the front end we saw typescript

00:05:08,530 --> 00:05:12,840
as an absolute must in order to take

00:05:10,870 --> 00:05:15,100
advantage of end-to-end type safety

00:05:12,840 --> 00:05:18,040
development is faster and we have more

00:05:15,100 --> 00:05:19,540
confidence in what we're building we run

00:05:18,040 --> 00:05:20,950
a customized code generation command

00:05:19,540 --> 00:05:23,560
internally but this is what you'd run as

00:05:20,950 --> 00:05:25,300
part of a Apollo's tooling this example

00:05:23,560 --> 00:05:27,190
shows a graph QL query along with the

00:05:25,300 --> 00:05:31,810
typescript type that gets generated by

00:05:27,190 --> 00:05:33,250
Apollo's tools this is we'll use this

00:05:31,810 --> 00:05:34,960
type in our code to make sure we're

00:05:33,250 --> 00:05:38,800
using the right values and have all of

00:05:34,960 --> 00:05:40,180
the necessary null checks typescript is

00:05:38,800 --> 00:05:42,400
now the official language for web

00:05:40,180 --> 00:05:43,990
development at Airbnb and over half of

00:05:42,400 --> 00:05:47,110
our 3 million line code base has been

00:05:43,990 --> 00:05:49,120
migrated so far if you're interested in

00:05:47,110 --> 00:05:51,190
learning more about our process you can

00:05:49,120 --> 00:05:54,280
check out this graph QL there dis J's

00:05:51,190 --> 00:05:55,990
cough talk from earlier this year when

00:05:54,280 --> 00:05:58,270
we're introducing grep evil and Apollo

00:05:55,990 --> 00:06:00,430
to our projects we first run an internal

00:05:58,270 --> 00:06:02,530
migration tool to convert our code from

00:06:00,430 --> 00:06:04,270
Java Script to typescript first and this

00:06:02,530 --> 00:06:09,550
talk covers that tool in a bit more

00:06:04,270 --> 00:06:11,350
depth as well with a graphical endpoint

00:06:09,550 --> 00:06:13,600
on the backend and typescript in place

00:06:11,350 --> 00:06:17,350
we need to swap out our rest requests

00:06:13,600 --> 00:06:19,720
for a graph QL request as a side note I

00:06:17,350 --> 00:06:21,430
will note that Paulo link rest is an

00:06:19,720 --> 00:06:22,960
option that allows you to use a rest

00:06:21,430 --> 00:06:25,510
endpoint with Apollo's front-end

00:06:22,960 --> 00:06:27,280
libraries we prefer to graph QL endpoint

00:06:25,510 --> 00:06:29,530
though in order to get typescript type

00:06:27,280 --> 00:06:31,960
generation and a smaller response sizes

00:06:29,530 --> 00:06:33,550
via field selection but you might

00:06:31,960 --> 00:06:38,140
consider it if exposing a graphical

00:06:33,550 --> 00:06:40,330
endpoint is simply not an option the

00:06:38,140 --> 00:06:41,650
goal at this stage is to verify that our

00:06:40,330 --> 00:06:43,750
front-end back-end integration

00:06:41,650 --> 00:06:45,940
working as expected and to generate

00:06:43,750 --> 00:06:47,919
typescript types we won't make any

00:06:45,940 --> 00:06:49,720
changes to our react components or

00:06:47,919 --> 00:06:52,539
change the shape of the API response

00:06:49,720 --> 00:06:54,820
this stage is just intended to affect

00:06:52,539 --> 00:06:57,000
where we get our data from not how it's

00:06:54,820 --> 00:06:59,560
used

00:06:57,000 --> 00:07:01,810
let's use our homes checkout flow as an

00:06:59,560 --> 00:07:03,669
example there is an endpoint for

00:07:01,810 --> 00:07:06,729
creating a reservation that has been

00:07:03,669 --> 00:07:08,350
exposed as a graphic UL mutation we make

00:07:06,729 --> 00:07:09,970
our request using the Apollo client

00:07:08,350 --> 00:07:12,039
directly at the same point in the code

00:07:09,970 --> 00:07:16,090
where we were previously making our post

00:07:12,039 --> 00:07:18,039
request the first thing to note here is

00:07:16,090 --> 00:07:20,320
that we said we're going to keep the API

00:07:18,039 --> 00:07:22,030
shape the same so we need to construct a

00:07:20,320 --> 00:07:24,010
graph QL mutation that corresponds to

00:07:22,030 --> 00:07:26,380
the data that we were previously getting

00:07:24,010 --> 00:07:29,320
back from our rest endpoint let's see

00:07:26,380 --> 00:07:33,760
what that response looks like oh that's

00:07:29,320 --> 00:07:34,870
uh that's a lot of JSON which well we we

00:07:33,760 --> 00:07:39,880
definitely have some opportunities here

00:07:34,870 --> 00:07:41,889
as far as over fetching for now though

00:07:39,880 --> 00:07:44,320
our goal is to construct a graph QL

00:07:41,889 --> 00:07:46,780
query that corresponds to this data we

00:07:44,320 --> 00:07:48,130
could try to eliminate fields now but

00:07:46,780 --> 00:07:49,720
will likely break something because

00:07:48,130 --> 00:07:53,470
we're not sure which fields are actually

00:07:49,720 --> 00:07:55,330
in use graph QL requires explicitly

00:07:53,470 --> 00:07:58,210
declaring which fields we need from the

00:07:55,330 --> 00:08:00,280
API so we'll need to exhaustively list

00:07:58,210 --> 00:08:03,060
out every one of these fields from our

00:08:00,280 --> 00:08:05,860
graph QL schema to match that response

00:08:03,060 --> 00:08:08,440
doing this by hand would be tedious and

00:08:05,860 --> 00:08:10,930
error-prone fortunately we can leverage

00:08:08,440 --> 00:08:14,080
the graph QL schema itself to help us

00:08:10,930 --> 00:08:16,030
out another place where we've seen the

00:08:14,080 --> 00:08:17,530
graph QL schema in use is the graph

00:08:16,030 --> 00:08:19,060
field playground which is an awesome

00:08:17,530 --> 00:08:21,090
developer tool that makes use of this

00:08:19,060 --> 00:08:23,740
schema for autocomplete and tooltips

00:08:21,090 --> 00:08:26,949
it's very helpful when you're authoring

00:08:23,740 --> 00:08:29,229
a query behind the scenes the playground

00:08:26,949 --> 00:08:30,849
issues this introspection query against

00:08:29,229 --> 00:08:33,029
the graphical server to get information

00:08:30,849 --> 00:08:35,620
back about the fields that are available

00:08:33,029 --> 00:08:37,870
we can use this information for our

00:08:35,620 --> 00:08:39,520
purposes to recursively unpack the

00:08:37,870 --> 00:08:41,140
schema because what we're trying to do

00:08:39,520 --> 00:08:44,910
is like a programmatic version of Auto

00:08:41,140 --> 00:08:46,900
completing at every level along the way

00:08:44,910 --> 00:08:48,970
another thing we'll keep in mind is a

00:08:46,900 --> 00:08:51,760
lesser-known feature of graph QL that

00:08:48,970 --> 00:08:53,980
you might find helpful graph QL aliasing

00:08:51,760 --> 00:08:55,490
lets you arbitrarily rename fields in a

00:08:53,980 --> 00:08:58,190
query we found the

00:08:55,490 --> 00:09:00,620
because our rest endpoint exposed fields

00:08:58,190 --> 00:09:03,140
as snake case and our graph QL endpoint

00:09:00,620 --> 00:09:05,149
exposed them as camel case so we could

00:09:03,140 --> 00:09:07,220
use aliasing to actually convert the

00:09:05,149 --> 00:09:09,050
case as part of our query and this would

00:09:07,220 --> 00:09:13,520
get carried over into the generated type

00:09:09,050 --> 00:09:15,290
script types as well with these ideas in

00:09:13,520 --> 00:09:18,589
mind we wrote a script to generate an

00:09:15,290 --> 00:09:19,399
epic 660 line mutation for the Holmes

00:09:18,589 --> 00:09:21,110
check out flow

00:09:19,399 --> 00:09:22,490
here's a link to adjust with the

00:09:21,110 --> 00:09:26,959
approach if you're curious more about

00:09:22,490 --> 00:09:28,760
how this works we then run Apollo code

00:09:26,959 --> 00:09:32,029
gen to generate tight script types for

00:09:28,760 --> 00:09:34,850
this mutation this is incredible we get

00:09:32,029 --> 00:09:37,370
a thousand lines of type straight from

00:09:34,850 --> 00:09:39,500
the schema this is such a dream compared

00:09:37,370 --> 00:09:41,450
to how we do it before we would look at

00:09:39,500 --> 00:09:43,130
the response write up the type by hand

00:09:41,450 --> 00:09:44,930
it would have mistakes that would get

00:09:43,130 --> 00:09:50,870
out of date very quickly if the backend

00:09:44,930 --> 00:09:52,370
changed so this is just a dream another

00:09:50,870 --> 00:09:54,740
thing to notice here is these adapt

00:09:52,370 --> 00:09:56,720
functions there were slight differences

00:09:54,740 --> 00:09:58,820
in our request and response formats on

00:09:56,720 --> 00:10:00,680
the back end so we created adapters on

00:09:58,820 --> 00:10:02,600
the front end adapter here doesn't mean

00:10:00,680 --> 00:10:04,610
anything graph QL specific it's just a

00:10:02,600 --> 00:10:06,740
utility function that transforms or

00:10:04,610 --> 00:10:09,350
adapts an object from one format to

00:10:06,740 --> 00:10:11,510
another for the inputs we made sure that

00:10:09,350 --> 00:10:14,660
the adapted request matched with the

00:10:11,510 --> 00:10:16,760
graph QL endpoint expected and for the

00:10:14,660 --> 00:10:18,950
outputs we made a request to both the

00:10:16,760 --> 00:10:21,380
rest and graphical endpoints and

00:10:18,950 --> 00:10:23,390
recursively diff the adapted version of

00:10:21,380 --> 00:10:27,279
their response to make sure it exactly

00:10:23,390 --> 00:10:27,279
matched what we were receiving before

00:10:27,880 --> 00:10:32,690
these adapters will be removed at a

00:10:30,560 --> 00:10:34,550
later stage but the intention for now is

00:10:32,690 --> 00:10:40,850
to keep all of the codes surrounding

00:10:34,550 --> 00:10:42,800
this API call the same at each stage we

00:10:40,850 --> 00:10:47,680
have a shippable app so we can pause

00:10:42,800 --> 00:10:47,680
here ship it and our app will still work

00:10:48,130 --> 00:10:52,100
the next thing we'll want to do is

00:10:50,360 --> 00:10:55,130
propagate our shiny new type script

00:10:52,100 --> 00:10:56,540
types throughout our code and the goal

00:10:55,130 --> 00:10:58,700
of this is to make sure that the

00:10:56,540 --> 00:11:00,410
generated types to use the generated

00:10:58,700 --> 00:11:02,110
types because they increase confidence

00:11:00,410 --> 00:11:04,640
at later stages in the migration process

00:11:02,110 --> 00:11:06,800
will get compiler errors when things

00:11:04,640 --> 00:11:08,579
don't line up we're not going to touch

00:11:06,800 --> 00:11:12,569
any runtime behavior here

00:11:08,579 --> 00:11:14,489
only editing the types we go through our

00:11:12,569 --> 00:11:16,410
code and replace all occurrences where

00:11:14,489 --> 00:11:18,600
we had in any type or no type or a

00:11:16,410 --> 00:11:22,799
manually created one with the generated

00:11:18,600 --> 00:11:25,290
type from Apollo as awesome as these

00:11:22,799 --> 00:11:27,600
types are a common issue we've run into

00:11:25,290 --> 00:11:31,980
is having to do deep no checks like this

00:11:27,600 --> 00:11:33,689
one thankfully there's a NPM package

00:11:31,980 --> 00:11:36,689
with a babel plugin you can use called

00:11:33,689 --> 00:11:39,389
idx that lets us express this idea idea

00:11:36,689 --> 00:11:43,709
much more concisely while still being

00:11:39,389 --> 00:11:45,600
fully type safe and idx is just a

00:11:43,709 --> 00:11:47,369
stopgap until a JavaScript supports

00:11:45,600 --> 00:11:50,639
optional chaining which is currently a

00:11:47,369 --> 00:11:52,170
stage 3 tc39 proposal and will be

00:11:50,639 --> 00:11:54,720
included with the next version of

00:11:52,170 --> 00:12:00,600
typescript we can't wait because it lets

00:11:54,720 --> 00:12:02,790
you write code like this instead before

00:12:00,600 --> 00:12:05,399
we were using the Apollo client directly

00:12:02,790 --> 00:12:07,529
to make our API request now let's make

00:12:05,399 --> 00:12:11,279
our code more idiomatic by using the

00:12:07,529 --> 00:12:18,119
react HSCs exported by apollo oh did I

00:12:11,279 --> 00:12:20,489
say HSC I meant hooks hook hoc anyway

00:12:18,119 --> 00:12:22,499
the the recent Apollo react hooks

00:12:20,489 --> 00:12:24,899
package gives us some new functions to

00:12:22,499 --> 00:12:26,730
use we love hooks at Airbnb because

00:12:24,899 --> 00:12:28,559
they're easier to reason about there's

00:12:26,730 --> 00:12:31,049
less boilerplate and they work better

00:12:28,559 --> 00:12:32,579
with typescript we're still using Apollo

00:12:31,049 --> 00:12:37,649
hoc s right now but we're actively

00:12:32,579 --> 00:12:39,389
upgrading to use hooks at this stage our

00:12:37,649 --> 00:12:41,069
app is using the Apollo client but we're

00:12:39,389 --> 00:12:42,739
still firing Redux actions and

00:12:41,069 --> 00:12:44,009
components are using the Redux store

00:12:42,739 --> 00:12:45,660
Apollo

00:12:44,009 --> 00:12:47,759
takes care of data fetching with loading

00:12:45,660 --> 00:12:51,829
and error states so we can wean

00:12:47,759 --> 00:12:51,829
ourselves off of redux for this purpose

00:12:52,129 --> 00:12:57,660
we refactor our app to use Apollo's HFCS

00:12:55,889 --> 00:12:59,429
or hooks instead and update our

00:12:57,660 --> 00:13:02,669
components to use data from the Apollo

00:12:59,429 --> 00:13:04,470
cache rather than the Redux store we

00:13:02,669 --> 00:13:06,269
need to keep the redux store around for

00:13:04,470 --> 00:13:07,889
now though because it still store some

00:13:06,269 --> 00:13:13,679
information not yet in the apollo cache

00:13:07,889 --> 00:13:15,600
but its role has been diminished one of

00:13:13,679 --> 00:13:17,789
the benefits of graph QL is reducing

00:13:15,600 --> 00:13:20,459
over fetching because clients specify

00:13:17,789 --> 00:13:22,350
exactly the fields they need we missed

00:13:20,459 --> 00:13:24,270
out on that with our mega query

00:13:22,350 --> 00:13:28,500
so let's fix that by introducing more

00:13:24,270 --> 00:13:30,270
granular query fragments at this stage

00:13:28,500 --> 00:13:31,950
our query lives in our top-level app

00:13:30,270 --> 00:13:34,740
component as represented by this little

00:13:31,950 --> 00:13:36,510
graph QL logo it contains all fields

00:13:34,740 --> 00:13:39,090
required by all components all the way

00:13:36,510 --> 00:13:40,770
down the tree but the best practice is

00:13:39,090 --> 00:13:43,080
for components to specify their own

00:13:40,770 --> 00:13:44,940
query fragments because it collocates

00:13:43,080 --> 00:13:48,060
the data needs with the code that

00:13:44,940 --> 00:13:49,920
actually uses the data it reduces over

00:13:48,060 --> 00:13:53,690
fetching and promotes code reuse because

00:13:49,920 --> 00:13:53,690
fragments can be shared across queries

00:13:53,750 --> 00:13:58,680
we start at the leaves these are the

00:13:57,090 --> 00:14:00,720
components closest to what ultimately

00:13:58,680 --> 00:14:02,040
gets rendered so we can trace through it

00:14:00,720 --> 00:14:04,290
and determine what fields are actually

00:14:02,040 --> 00:14:07,560
in use and add them to its query

00:14:04,290 --> 00:14:09,900
fragment we rerun cogent to get types

00:14:07,560 --> 00:14:12,750
for our new fragment and use these types

00:14:09,900 --> 00:14:14,250
in the subtree of the code we can

00:14:12,750 --> 00:14:16,530
actually use typescript to help guide us

00:14:14,250 --> 00:14:18,420
here because if we've missed a field in

00:14:16,530 --> 00:14:19,860
our fragment we'll get a typescript

00:14:18,420 --> 00:14:22,040
error at the uses site where it's

00:14:19,860 --> 00:14:22,040
missing

00:14:22,430 --> 00:14:26,880
we then compose this fragment up until

00:14:25,260 --> 00:14:28,730
its parent component and one level

00:14:26,880 --> 00:14:31,590
further up back into the app component

00:14:28,730 --> 00:14:32,100
this is a gradual change so we're not

00:14:31,590 --> 00:14:34,170
done yet

00:14:32,100 --> 00:14:35,760
but we have a fully working app and can

00:14:34,170 --> 00:14:39,960
verify the changes we've just made in

00:14:35,760 --> 00:14:41,840
isolation we rinse and repeat this

00:14:39,960 --> 00:14:44,820
process until our whole tree is covered

00:14:41,840 --> 00:14:46,530
before the app had an omniscient query

00:14:44,820 --> 00:14:48,690
that knew about all the data used by all

00:14:46,530 --> 00:14:50,520
the components in the tree but now our

00:14:48,690 --> 00:14:53,280
top level query is simply a composition

00:14:50,520 --> 00:14:55,170
made up of its child fragments because

00:14:53,280 --> 00:14:57,150
the fragments are declared in close

00:14:55,170 --> 00:14:58,680
proximity to where they're actually used

00:14:57,150 --> 00:15:04,770
we can be confident that we're only

00:14:58,680 --> 00:15:06,510
fetching the data we need once all

00:15:04,770 --> 00:15:08,580
components have been migrated to Apollo

00:15:06,510 --> 00:15:12,870
we can consider what to do about the

00:15:08,580 --> 00:15:14,490
remaining Redux state we found that any

00:15:12,870 --> 00:15:16,650
state we were storing in Redux could be

00:15:14,490 --> 00:15:19,530
sufficiently managed by Apollo for API

00:15:16,650 --> 00:15:21,540
data and reacts local state or context

00:15:19,530 --> 00:15:23,910
for client data while considering

00:15:21,540 --> 00:15:27,030
Apollo's the client local resolvers for

00:15:23,910 --> 00:15:28,530
more complex client data use cases this

00:15:27,030 --> 00:15:31,020
gives us consistent mental model for

00:15:28,530 --> 00:15:32,670
handling client data we use reactant

00:15:31,020 --> 00:15:34,920
Apollo for all state rather than

00:15:32,670 --> 00:15:35,870
fragmentation between react Apollo and

00:15:34,920 --> 00:15:38,279
Rita

00:15:35,870 --> 00:15:39,870
moreover we found that we wrote quite a

00:15:38,279 --> 00:15:41,190
bit of boilerplate when using redux for

00:15:39,870 --> 00:15:43,860
things that Apollo just handled out of

00:15:41,190 --> 00:15:45,390
the box so we could delete substantial

00:15:43,860 --> 00:15:47,580
amounts of code when migrating to Apollo

00:15:45,390 --> 00:15:48,810
and Apollo and 'old caching more

00:15:47,580 --> 00:15:53,880
effectively than our hand world

00:15:48,810 --> 00:15:55,440
solutions did anyways with all of these

00:15:53,880 --> 00:15:57,839
stages complete we end up with our

00:15:55,440 --> 00:15:59,430
desired result of an Apollo and graph QL

00:15:57,839 --> 00:16:02,730
powered app that's a hundred percent

00:15:59,430 --> 00:16:04,200
type safe with no over fetching and we

00:16:02,730 --> 00:16:10,560
kept the site up and running throughout

00:16:04,200 --> 00:16:13,200
each stage of our migration journey with

00:16:10,560 --> 00:16:15,150
graph QL powering more of our code there

00:16:13,200 --> 00:16:17,460
are exciting projects that were actively

00:16:15,150 --> 00:16:20,070
pursuing to take advantage of this new

00:16:17,460 --> 00:16:24,839
data fetching layer I'd like to share

00:16:20,070 --> 00:16:27,300
two of them with you today the first is

00:16:24,839 --> 00:16:29,550
service worker query prefetching the

00:16:27,300 --> 00:16:32,160
goal is to kick off the graphical query

00:16:29,550 --> 00:16:34,610
request as early as possible so users

00:16:32,160 --> 00:16:37,080
see the page rendered with data sooner

00:16:34,610 --> 00:16:38,640
shout out to Kelly Riggins who is

00:16:37,080 --> 00:16:40,500
leading the charge on our mobile web

00:16:38,640 --> 00:16:44,279
service worker implementation and is

00:16:40,500 --> 00:16:46,260
pursuing this novel idea here's a

00:16:44,279 --> 00:16:49,140
side-by-side comparison of a server-side

00:16:46,260 --> 00:16:51,209
rendered page on the top and a page

00:16:49,140 --> 00:16:53,670
loaded via serviceworker on the bottom

00:16:51,209 --> 00:16:55,529
if we don't have a service worker our

00:16:53,670 --> 00:16:58,170
pages are server-side rendered there's a

00:16:55,529 --> 00:17:01,260
long gap between the page while the page

00:16:58,170 --> 00:17:02,610
is loading before we see content with

00:17:01,260 --> 00:17:04,800
serviceworker on the other hand an

00:17:02,610 --> 00:17:06,689
application shell shows up right away

00:17:04,800 --> 00:17:08,970
and allows the user to get oriented to

00:17:06,689 --> 00:17:11,189
the page while the content is coming in

00:17:08,970 --> 00:17:15,030
and the page loads faster because more

00:17:11,189 --> 00:17:17,429
of our JavaScript is cached here is a

00:17:15,030 --> 00:17:21,179
profile of a request filled by a

00:17:17,429 --> 00:17:23,010
server-side rendering we start with the

00:17:21,179 --> 00:17:24,510
server request this is when the

00:17:23,010 --> 00:17:26,540
server-side rendering happens and our

00:17:24,510 --> 00:17:29,070
graph uol request is made on the server

00:17:26,540 --> 00:17:31,770
then we parse the HTML and download our

00:17:29,070 --> 00:17:33,960
JavaScript at this point the page

00:17:31,770 --> 00:17:36,300
becomes visible using the HTML that was

00:17:33,960 --> 00:17:38,429
rendered on the server and once reacts

00:17:36,300 --> 00:17:42,840
hydration completes our page becomes

00:17:38,429 --> 00:17:44,640
interactive here's a profile of a

00:17:42,840 --> 00:17:47,300
request fulfilled by the serviceworker

00:17:44,640 --> 00:17:47,300
app shell

00:17:47,660 --> 00:17:52,500
the serviceworker immediately fulfills

00:17:50,280 --> 00:17:54,090
the request javascript is loaded from

00:17:52,500 --> 00:17:56,460
the cache and we start some

00:17:54,090 --> 00:17:59,160
initialization the shell becomes visible

00:17:56,460 --> 00:18:01,890
react hydrates then our graph QL request

00:17:59,160 --> 00:18:03,870
begins the user sees a loading state

00:18:01,890 --> 00:18:07,890
until they request completes then our

00:18:03,870 --> 00:18:10,049
page is interactive there's a gap here

00:18:07,890 --> 00:18:12,000
though between when the service workers

00:18:10,049 --> 00:18:14,820
started fulfilling the request and when

00:18:12,000 --> 00:18:16,650
the graph QL requests began there's a

00:18:14,820 --> 00:18:21,059
significant optimization opportunity

00:18:16,650 --> 00:18:23,160
here we could register our queries at

00:18:21,059 --> 00:18:26,010
the route level instead of at the

00:18:23,160 --> 00:18:27,690
component level then the service worker

00:18:26,010 --> 00:18:30,330
could kick off the graph ul request

00:18:27,690 --> 00:18:32,910
right away because it decouples the

00:18:30,330 --> 00:18:35,280
react rendering from when we can read

00:18:32,910 --> 00:18:36,840
the query in this particular instance

00:18:35,280 --> 00:18:39,299
that would have saved us 400

00:18:36,840 --> 00:18:40,590
milliseconds this means the user would

00:18:39,299 --> 00:18:44,190
have been able to interact with this

00:18:40,590 --> 00:18:46,320
page 23% sooner and that request that

00:18:44,190 --> 00:18:49,080
effect size is even larger for slower

00:18:46,320 --> 00:18:51,950
devices we tried this with 6x CPU slowed

00:18:49,080 --> 00:18:55,410
down and we can see the page 50% sooner

00:18:51,950 --> 00:18:56,880
this performance when is huge and with

00:18:55,410 --> 00:18:59,490
this primitive of being able to load

00:18:56,880 --> 00:19:01,590
data just given the URL we can do other

00:18:59,490 --> 00:19:03,960
fancy things like preload data for any

00:19:01,590 --> 00:19:08,940
link on the page and all of this is

00:19:03,960 --> 00:19:10,890
happening off of the main thread another

00:19:08,940 --> 00:19:13,350
project we're pursuing is a unified

00:19:10,890 --> 00:19:15,000
schema and shout out to Arun in the

00:19:13,350 --> 00:19:16,410
audience who's been building out the

00:19:15,000 --> 00:19:20,549
system and piloting it on the trip

00:19:16,410 --> 00:19:22,770
planning team to understand the problem

00:19:20,549 --> 00:19:24,150
this project is solving let's first look

00:19:22,770 --> 00:19:27,090
at Airbnb a service-oriented

00:19:24,150 --> 00:19:28,850
architecture our back-end services are

00:19:27,090 --> 00:19:33,059
broken down into three main categories

00:19:28,850 --> 00:19:34,980
data derived data and presentation data

00:19:33,059 --> 00:19:37,440
services encapsulated data model like a

00:19:34,980 --> 00:19:39,270
listing or a user and derive data

00:19:37,440 --> 00:19:41,549
services combined information from

00:19:39,270 --> 00:19:43,740
multiple data sources for example a

00:19:41,549 --> 00:19:47,280
listing card combines user and review

00:19:43,740 --> 00:19:48,980
data presentation services encapsulate

00:19:47,280 --> 00:19:51,900
the logic of an end-user experience

00:19:48,980 --> 00:19:54,679
class call presentation services to get

00:19:51,900 --> 00:19:57,090
the data needed to render the page

00:19:54,679 --> 00:19:59,030
currently our graphical schema is

00:19:57,090 --> 00:20:02,220
service centric

00:19:59,030 --> 00:20:04,830
all of the top-level keys correspond to

00:20:02,220 --> 00:20:06,450
presentation services this was a

00:20:04,830 --> 00:20:08,010
concession we made so that graph QL

00:20:06,450 --> 00:20:09,720
would be more compatible with our

00:20:08,010 --> 00:20:12,750
particular service oriented architecture

00:20:09,720 --> 00:20:14,430
strategy though now that graph feels

00:20:12,750 --> 00:20:16,410
gained more traction internally we're

00:20:14,430 --> 00:20:21,630
revisiting this design to make it more

00:20:16,410 --> 00:20:23,430
data centric the new schema would expose

00:20:21,630 --> 00:20:25,230
a unified graph that is more sensible

00:20:23,430 --> 00:20:27,240
for clients and would enable better

00:20:25,230 --> 00:20:30,650
client-side cache utilization because

00:20:27,240 --> 00:20:33,270
more entities are shared across queries

00:20:30,650 --> 00:20:35,190
the same services are used behind the

00:20:33,270 --> 00:20:39,510
scenes but it's more left as an

00:20:35,190 --> 00:20:42,120
implementation detail to make this

00:20:39,510 --> 00:20:43,770
happen our data centric schema federates

00:20:42,120 --> 00:20:46,080
out to services that hydrate the data

00:20:43,770 --> 00:20:47,820
requested by the client the data

00:20:46,080 --> 00:20:50,880
hydration code defines how to load

00:20:47,820 --> 00:20:52,770
objects by their ID centralizing our

00:20:50,880 --> 00:20:55,080
hydration logic reduces the amount of

00:20:52,770 --> 00:20:57,290
code that we saw duplicated across many

00:20:55,080 --> 00:20:59,700
of these different presentation services

00:20:57,290 --> 00:21:04,080
moreover we can improve data fetching of

00:20:59,700 --> 00:21:05,760
efficiency there were cases where the

00:21:04,080 --> 00:21:08,010
same data was being loaded at various

00:21:05,760 --> 00:21:10,680
levels in our presentation level layer

00:21:08,010 --> 00:21:13,830
this is an example trace from a query

00:21:10,680 --> 00:21:17,040
made by our product detail page each bar

00:21:13,830 --> 00:21:19,620
here represents a service call and the

00:21:17,040 --> 00:21:24,450
ten purple bars represent redundant data

00:21:19,620 --> 00:21:26,580
fetching for the exact same listing we

00:21:24,450 --> 00:21:28,650
can reduce data fetching in efficiency

00:21:26,580 --> 00:21:31,290
by batching and caching requests at the

00:21:28,650 --> 00:21:32,760
centralized hydration layer that would

00:21:31,290 --> 00:21:38,430
have meant only hydrating that listing

00:21:32,760 --> 00:21:40,140
data once this work is in beta but we're

00:21:38,430 --> 00:21:41,910
encouraged by our early results and have

00:21:40,140 --> 00:21:45,350
certainly will will certainly have more

00:21:41,910 --> 00:21:45,350
to share by the next graph you'll summit

00:21:45,740 --> 00:21:52,890
I'd like to leave you with a few key

00:21:48,300 --> 00:21:54,870
takeaways when Apollo is paired with

00:21:52,890 --> 00:21:56,640
typescript you can build and migrate

00:21:54,870 --> 00:21:59,990
code with significantly more confidence

00:21:56,640 --> 00:21:59,990
that nothing broke along the way

00:22:00,410 --> 00:22:04,740
consider the options and decide whether

00:22:02,820 --> 00:22:07,110
an incremental adoption strategy is the

00:22:04,740 --> 00:22:08,940
best approach for your situation if you

00:22:07,110 --> 00:22:10,759
need to change a large pre-existing code

00:22:08,940 --> 00:22:15,440
base and keep it up and running it

00:22:10,759 --> 00:22:17,419
step along the way finally Apollo and

00:22:15,440 --> 00:22:19,639
graph QL are a client data foundation on

00:22:17,419 --> 00:22:20,899
which you can do amazing things and I

00:22:19,639 --> 00:22:25,129
can't wait to see what you all build

00:22:20,899 --> 00:22:27,109
next please come find me or any of the

00:22:25,129 --> 00:22:28,729
other Airbnb engineers here who would

00:22:27,109 --> 00:22:29,089
love to talk with you more about any of

00:22:28,729 --> 00:22:30,630
this

00:22:29,089 --> 00:22:34,909
thank you so much

00:22:30,630 --> 00:22:34,909

YouTube URL: https://www.youtube.com/watch?v=pywcFELoU8E


