Title: The architecture of Federation
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	As an organizationâ€™s data graph grows, Jeff Hampton, Solutions Architect at Apollo, explains how to use Apollo Federation to improve efficiency and scale GraphQL.

Apollo Federation is a new architecture for GraphQL, where you can now divide the implementation of a data graph across distinct, composable services. With this approach, different teams can collaborate across a single graph whose implementation is loosely-coupled.  

Jeff will cover the architectural principles behind federation and show how you can implement a well designed and structured data graph using Apollo.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:01,649 --> 00:00:05,859
fantastic we're gonna talk about the

00:00:03,520 --> 00:00:07,660
architecture of Federation so we're

00:00:05,859 --> 00:00:11,730
gonna spend the next 25 minutes or so I

00:00:07,660 --> 00:00:13,570
promise it's not all talking in slides

00:00:11,730 --> 00:00:16,960
first things first

00:00:13,570 --> 00:00:17,529
my clicker is not working yep okay first

00:00:16,960 --> 00:00:21,279
things first

00:00:17,529 --> 00:00:24,009
thank you some of you some of us have

00:00:21,279 --> 00:00:26,109
travelled a long way we're away from our

00:00:24,009 --> 00:00:29,529
friends our family maybe our kids and

00:00:26,109 --> 00:00:31,150
our parents so if someone hasn't told

00:00:29,529 --> 00:00:34,720
you today thank you for spending your

00:00:31,150 --> 00:00:36,850
time with us investing your time it

00:00:34,720 --> 00:00:39,130
doesn't go unnoticed and part of the

00:00:36,850 --> 00:00:42,280
reason that I joined Apollo is that

00:00:39,130 --> 00:00:46,540
consideration so my name is Jeff Hampton

00:00:42,280 --> 00:00:49,540
I'm a salty old tech engineer but in the

00:00:46,540 --> 00:00:51,460
business 20 years or so I survived

00:00:49,540 --> 00:00:54,790
corporate IT I had a blackberry strapped

00:00:51,460 --> 00:00:58,330
to my underwear did some Microsoft

00:00:54,790 --> 00:01:00,010
sequel DBA work and then true story got

00:00:58,330 --> 00:01:03,370
a couple of tattoos got a MacBook and

00:01:00,010 --> 00:01:07,270
then started doing web and then react

00:01:03,370 --> 00:01:09,880
native last few years though I had an

00:01:07,270 --> 00:01:12,249
opportunity to shift a little more to

00:01:09,880 --> 00:01:14,920
thinking about patterns solid design

00:01:12,249 --> 00:01:16,689
principles functional programming which

00:01:14,920 --> 00:01:19,210
some of you may have strongly held

00:01:16,689 --> 00:01:20,770
opinions about and functional reactive

00:01:19,210 --> 00:01:23,829
which some of you may have even strongly

00:01:20,770 --> 00:01:26,140
stronger opinions about but generally

00:01:23,829 --> 00:01:31,060
I'm a Solutions Architect here at Apollo

00:01:26,140 --> 00:01:31,899
because I like things that work so today

00:01:31,060 --> 00:01:34,719
we're going to be talking about

00:01:31,899 --> 00:01:37,020
Federation when this talk is a spiritual

00:01:34,719 --> 00:01:39,999
successor to Mass keynote this morning

00:01:37,020 --> 00:01:41,920
he did a great job for teeing up this

00:01:39,999 --> 00:01:44,409
talk so thank you Matt I appreciate that

00:01:41,920 --> 00:01:48,159
I'm excited to cover the topic with you

00:01:44,409 --> 00:01:49,509
all today but first raise your hand

00:01:48,159 --> 00:01:51,729
we're gonna stretch for a second because

00:01:49,509 --> 00:01:53,079
it's three o'clock and we're tired raise

00:01:51,729 --> 00:01:56,039
your hand if you don't know what I'm

00:01:53,079 --> 00:01:58,509
talking about when I say Federation

00:01:56,039 --> 00:01:59,109
raise both hands if you do know what I'm

00:01:58,509 --> 00:02:02,009
talking about

00:01:59,109 --> 00:02:04,889
I say Federation okay thank you all I

00:02:02,009 --> 00:02:08,170
appreciate that

00:02:04,889 --> 00:02:10,000
so what is Federation it is a

00:02:08,170 --> 00:02:11,799
declarative model for graph composition

00:02:10,000 --> 00:02:14,500
of loosely coupled downstream graph QL

00:02:11,799 --> 00:02:14,770
services that enable static composition

00:02:14,500 --> 00:02:17,170
and

00:02:14,770 --> 00:02:20,970
validation of unified graph using query

00:02:17,170 --> 00:02:20,970
plans to resolve downstream operations

00:02:21,750 --> 00:02:27,760
that's tough so instead we're gonna

00:02:25,330 --> 00:02:31,300
spend the next 20 minutes or so walking

00:02:27,760 --> 00:02:33,040
through each of these statements and by

00:02:31,300 --> 00:02:36,070
the end I promise this this will not

00:02:33,040 --> 00:02:37,300
just be a bunch of jargon let's talk

00:02:36,070 --> 00:02:38,800
about what we're not covering really

00:02:37,300 --> 00:02:39,220
quickly there are some great speakers

00:02:38,800 --> 00:02:40,870
here

00:02:39,220 --> 00:02:44,460
I'm honored this is my first time

00:02:40,870 --> 00:02:46,750
speaking last year I was in the audience

00:02:44,460 --> 00:02:49,330
I'm not talking about scaling or

00:02:46,750 --> 00:02:51,280
operationalizing I'm not talking about

00:02:49,330 --> 00:02:52,840
Apollo's own journey moving from

00:02:51,280 --> 00:02:54,280
stitching to Federation Adams gonna be

00:02:52,840 --> 00:02:56,770
covering that tomorrow it's a great talk

00:02:54,280 --> 00:02:58,210
and I'm not gonna cover a cover every

00:02:56,770 --> 00:03:01,120
feature in detail we're not going to

00:02:58,210 --> 00:03:02,760
cover like heavy optimization I really

00:03:01,120 --> 00:03:05,770
want to make sure that we all walk away

00:03:02,760 --> 00:03:08,980
with a firm understanding of the why and

00:03:05,770 --> 00:03:10,720
how of Federation so this is a talk in

00:03:08,980 --> 00:03:14,110
three parts we're gonna talk about

00:03:10,720 --> 00:03:17,950
motivation the design and the

00:03:14,110 --> 00:03:21,490
implementation of Federation so let's

00:03:17,950 --> 00:03:23,290
frame the problem graph QL is a great

00:03:21,490 --> 00:03:24,850
technology we're all at a graph QL

00:03:23,290 --> 00:03:27,910
conference right we're all excited about

00:03:24,850 --> 00:03:31,090
it and it works for teams of all sizes

00:03:27,910 --> 00:03:33,160
in all industries all lines of business

00:03:31,090 --> 00:03:34,840
I personally believe it's a

00:03:33,160 --> 00:03:37,630
transformative technology for teams and

00:03:34,840 --> 00:03:40,360
organizations and once a team chooses

00:03:37,630 --> 00:03:41,950
graph QL it can spread from product to

00:03:40,360 --> 00:03:46,900
product and team to team pretty quickly

00:03:41,950 --> 00:03:49,690
the velocity the tooling now Apollo her

00:03:46,900 --> 00:03:51,990
to trend developing as teams got excited

00:03:49,690 --> 00:03:57,630
about graph QL and adoption increases

00:03:51,990 --> 00:03:59,800
the graph can scale to a monolith right

00:03:57,630 --> 00:04:02,260
so the graph is getting larger and

00:03:59,800 --> 00:04:04,450
richer but it can suffer from the same

00:04:02,260 --> 00:04:07,600
challenges that monolithic architectures

00:04:04,450 --> 00:04:10,300
have slower development may be more

00:04:07,600 --> 00:04:11,770
difficult tooling causing friction among

00:04:10,300 --> 00:04:16,359
teams maybe you're sitting waiting for a

00:04:11,770 --> 00:04:18,489
PR for a long period of time so an

00:04:16,359 --> 00:04:21,669
obvious solution here is to break your

00:04:18,489 --> 00:04:23,979
graph into smaller pieces there is a

00:04:21,669 --> 00:04:27,640
possible solution in schema stitching

00:04:23,979 --> 00:04:28,690
and one that we used ourselves combining

00:04:27,640 --> 00:04:31,510
several graphs means that you

00:04:28,690 --> 00:04:33,220
to ensure they can coexist you might

00:04:31,510 --> 00:04:36,490
also need to name space fields because

00:04:33,220 --> 00:04:38,410
now you have tied collisions you might

00:04:36,490 --> 00:04:42,580
need to calculate some fields I don't

00:04:38,410 --> 00:04:44,950
have a good place to put this logic you

00:04:42,580 --> 00:04:46,450
you might have run time logic baked into

00:04:44,950 --> 00:04:47,590
the Gateway to do all of this and that

00:04:46,450 --> 00:04:50,290
run time logic is going to end up

00:04:47,590 --> 00:04:52,440
costing you it's harder to validate the

00:04:50,290 --> 00:04:54,460
CPU cost there's an integration cost and

00:04:52,440 --> 00:04:56,200
ultimately it's a brittle architecture

00:04:54,460 --> 00:05:01,210
something that we discovered ourselves

00:04:56,200 --> 00:05:04,360
we heard from our customers so Apollo

00:05:01,210 --> 00:05:06,340
listened to our customers and got back

00:05:04,360 --> 00:05:08,800
to first principles and if you have not

00:05:06,340 --> 00:05:10,270
read principal graph qaul i highly

00:05:08,800 --> 00:05:12,150
recommend it

00:05:10,270 --> 00:05:16,450
I read it when I was at Sony and I said

00:05:12,150 --> 00:05:17,620
yes right somebody sat down since I

00:05:16,450 --> 00:05:20,130
haven't read something like this since

00:05:17,620 --> 00:05:22,420
the agile manifesto it's fantastic

00:05:20,130 --> 00:05:25,420
somebody has an opinion and it seems

00:05:22,420 --> 00:05:26,500
pretty reasonable in fact it feels right

00:05:25,420 --> 00:05:29,020
to have a single graph for an

00:05:26,500 --> 00:05:31,240
organization and to have a federated

00:05:29,020 --> 00:05:32,740
implementation so a principled

00:05:31,240 --> 00:05:35,410
implementation has important

00:05:32,740 --> 00:05:37,150
characteristics and all of this

00:05:35,410 --> 00:05:39,610
principles in Federation and

00:05:37,150 --> 00:05:41,170
architecture may have you wondering is

00:05:39,610 --> 00:05:44,650
this for me

00:05:41,170 --> 00:05:46,630
this sounds like we're gonna dedicate a

00:05:44,650 --> 00:05:49,590
whole conference to okay this sounds

00:05:46,630 --> 00:05:52,720
like hype you aren't gonna need it

00:05:49,590 --> 00:05:57,640
right yeah Denis is you aren't gonna

00:05:52,720 --> 00:05:58,990
need it I learned that recently raise

00:05:57,640 --> 00:06:03,010
your hand if you have more than one

00:05:58,990 --> 00:06:04,810
graph today raise your hand if the graph

00:06:03,010 --> 00:06:08,800
you have you'd like to be able to

00:06:04,810 --> 00:06:09,850
refactor safely raise your hand if

00:06:08,800 --> 00:06:11,370
different parts of your graph have

00:06:09,850 --> 00:06:14,100
different security requirements

00:06:11,370 --> 00:06:17,380
different performance characteristics

00:06:14,100 --> 00:06:19,630
different CI CD pipelines do you want to

00:06:17,380 --> 00:06:22,410
add more teams do you want to maintain

00:06:19,630 --> 00:06:22,410
their velocity

00:06:25,179 --> 00:06:31,219
you can build a graph service by service

00:06:28,419 --> 00:06:35,029
adoption is incremental and using

00:06:31,219 --> 00:06:37,639
Federation and its design the adoption

00:06:35,029 --> 00:06:40,399
is simple and straightforward and I'll

00:06:37,639 --> 00:06:44,569
show you I'm not afraid to do it on

00:06:40,399 --> 00:06:45,979
stage it has good language support matt

00:06:44,569 --> 00:06:48,439
talked talked about this this morning

00:06:45,979 --> 00:06:50,089
but it's not just about this team

00:06:48,439 --> 00:06:52,759
prefers java and that team prefers

00:06:50,089 --> 00:06:54,649
typescript it's also you have invested

00:06:52,759 --> 00:06:57,409
as a business in this team that does

00:06:54,649 --> 00:06:59,209
java and this team that does javascript

00:06:57,409 --> 00:07:03,379
and and they all eat lunch together they

00:06:59,209 --> 00:07:05,569
still get along right it's great and

00:07:03,379 --> 00:07:07,759
there is a clear path to scale and if

00:07:05,569 --> 00:07:11,299
adoption is that simple and you can

00:07:07,759 --> 00:07:12,799
start today then we won't have to have

00:07:11,299 --> 00:07:15,469
when that scaling event comes when that

00:07:12,799 --> 00:07:17,569
capital injection comes when a new line

00:07:15,469 --> 00:07:19,189
of business opens up planning today

00:07:17,569 --> 00:07:22,789
implementation today will make that path

00:07:19,189 --> 00:07:26,119
clear for you so this all sounds good

00:07:22,789 --> 00:07:27,409
how does it actually work so the design

00:07:26,119 --> 00:07:30,829
of Federation is different from schema

00:07:27,409 --> 00:07:33,499
stitching and addresses scaling in a

00:07:30,829 --> 00:07:35,539
principled way again and there are some

00:07:33,499 --> 00:07:38,269
important characteristics remember this

00:07:35,539 --> 00:07:41,719
statement a declarative model for graph

00:07:38,269 --> 00:07:44,089
compositions so what does that really

00:07:41,719 --> 00:07:46,309
mean the Federation specification is

00:07:44,089 --> 00:07:48,559
built on the same SDL that we all know

00:07:46,309 --> 00:07:50,749
and love it is valid graph QL syntax

00:07:48,559 --> 00:07:53,629
which means you get all the benefits of

00:07:50,749 --> 00:07:56,359
graph QL out-of-the-box things like

00:07:53,629 --> 00:07:58,429
static composition static validation I

00:07:56,359 --> 00:08:00,079
can take these individual schemas pull

00:07:58,429 --> 00:08:00,679
them all together and revalidate that

00:08:00,079 --> 00:08:02,569
schema

00:08:00,679 --> 00:08:06,529
make sure that it actually will compose

00:08:02,569 --> 00:08:08,479
properly static composition means that

00:08:06,529 --> 00:08:10,939
as I push each individual schema and

00:08:08,479 --> 00:08:12,529
compose those things together for those

00:08:10,939 --> 00:08:14,179
who are DevOps focused in the world I

00:08:12,529 --> 00:08:17,739
can produce an artifact that I know is

00:08:14,179 --> 00:08:19,909
deployable and repeatedly deploy and

00:08:17,739 --> 00:08:23,929
hopefully that means fewer page or duty

00:08:19,909 --> 00:08:26,109
notifications write that ahead of time

00:08:23,929 --> 00:08:28,549
processing also extends to things like

00:08:26,109 --> 00:08:30,529
perhaps optimizations and query plans

00:08:28,549 --> 00:08:32,329
ahead of time I'm going to need to find

00:08:30,529 --> 00:08:34,490
a way to get to that service as quickly

00:08:32,329 --> 00:08:36,800
as possible if I can analyze how my

00:08:34,490 --> 00:08:37,690
graph is my composed graph changes over

00:08:36,800 --> 00:08:39,370
time

00:08:37,690 --> 00:08:42,460
and what those individual tracing paths

00:08:39,370 --> 00:08:44,080
look like I can now do analysis across

00:08:42,460 --> 00:08:46,090
the entire organization and optimize

00:08:44,080 --> 00:08:46,570
across the entire organization maybe I

00:08:46,090 --> 00:08:48,220
do

00:08:46,570 --> 00:08:50,170
move this service or this particular

00:08:48,220 --> 00:08:53,200
type from this service into that service

00:08:50,170 --> 00:09:00,750
because I'm geographically closer to the

00:08:53,200 --> 00:09:00,750
resource that I be it's loosely coupled

00:09:01,710 --> 00:09:06,730
so we're talking about separation of

00:09:03,700 --> 00:09:08,320
concerns and as engineers we tend to

00:09:06,730 --> 00:09:10,210
talk a lot about separation concerns and

00:09:08,320 --> 00:09:12,160
again may have some strongly held

00:09:10,210 --> 00:09:14,230
opinions about those and usually we're

00:09:12,160 --> 00:09:16,090
talking about isolating logic or

00:09:14,230 --> 00:09:19,210
co-locating functionality of some kind

00:09:16,090 --> 00:09:22,630
and yes Federation does allow for this

00:09:19,210 --> 00:09:24,720
in multiple languages but I believe that

00:09:22,630 --> 00:09:27,820
it goes farther separation of concerns

00:09:24,720 --> 00:09:29,610
extends to allowing teams to prioritize

00:09:27,820 --> 00:09:33,070
independence and collaboration over

00:09:29,610 --> 00:09:35,590
arbitrary constraints a process PRS

00:09:33,070 --> 00:09:37,420
waiting for those things organizations

00:09:35,590 --> 00:09:39,400
can focus on aligning human and machine

00:09:37,420 --> 00:09:41,320
resources instead of concentrating those

00:09:39,400 --> 00:09:43,870
resources based on technology and time

00:09:41,320 --> 00:09:45,580
constraints in other words I can't I

00:09:43,870 --> 00:09:48,190
can't make those changes the team that

00:09:45,580 --> 00:09:51,910
does the java graph QL server is busy

00:09:48,190 --> 00:09:53,800
right Federation allows for better and

00:09:51,910 --> 00:09:55,240
stronger architectural choices instead

00:09:53,800 --> 00:09:57,780
of making the concessions associated

00:09:55,240 --> 00:10:01,720
with monolith or with schema stitching

00:09:57,780 --> 00:10:02,950
speaking of schema stitching I think the

00:10:01,720 --> 00:10:04,450
hardest part of moving from schema

00:10:02,950 --> 00:10:05,800
stitching is to pull the logic back out

00:10:04,450 --> 00:10:07,300
of that gateway and put it back into the

00:10:05,800 --> 00:10:09,630
services and back into the team's hands

00:10:07,300 --> 00:10:09,630
where it belongs

00:10:14,500 --> 00:10:23,280
and back up one going back up to static

00:10:21,550 --> 00:10:26,980
composition and validation

00:10:23,280 --> 00:10:29,350
it's just graph QL right we're just

00:10:26,980 --> 00:10:31,480
using STL primitives we can statically

00:10:29,350 --> 00:10:32,080
compose we're gonna look at that in just

00:10:31,480 --> 00:10:35,020
a moment

00:10:32,080 --> 00:10:37,270
this is all pretty sweet but the

00:10:35,020 --> 00:10:40,950
favorite my favorite code is the stuff I

00:10:37,270 --> 00:10:44,950
didn't write that also has test coverage

00:10:40,950 --> 00:10:47,590
right the killer feature about

00:10:44,950 --> 00:10:50,530
Federation isn't what is there it's what

00:10:47,590 --> 00:10:53,080
is not there it is not re engineering

00:10:50,530 --> 00:10:55,540
client applications it is not changing

00:10:53,080 --> 00:10:56,800
your tooling it is not having a thick

00:10:55,540 --> 00:10:59,680
gateway that you need to scale

00:10:56,800 --> 00:11:04,270
independently that has variable CPU cost

00:10:59,680 --> 00:11:06,400
right it's just graph QL to your

00:11:04,270 --> 00:11:07,480
consumers that graph is going to look

00:11:06,400 --> 00:11:12,310
the same we're gonna see that in

00:11:07,480 --> 00:11:13,860
playground in just a few minutes let's

00:11:12,310 --> 00:11:16,450
talk about the basics really quickly

00:11:13,860 --> 00:11:20,680
it's one of the few we're almost done

00:11:16,450 --> 00:11:23,500
with graphs I promise almost stat so

00:11:20,680 --> 00:11:26,440
first each graph QL service can extend

00:11:23,500 --> 00:11:29,380
another service adding richness so in

00:11:26,440 --> 00:11:31,480
this case we have users defined in the

00:11:29,380 --> 00:11:34,780
account service and I have some reviews

00:11:31,480 --> 00:11:36,970
I really want the reviews team who knows

00:11:34,780 --> 00:11:39,760
how to query that database and add that

00:11:36,970 --> 00:11:43,330
information to the user right once that

00:11:39,760 --> 00:11:45,850
happens I need to compose that make sure

00:11:43,330 --> 00:11:49,440
that it's valid step two if you're using

00:11:45,850 --> 00:11:52,030
the graph manager this is done in

00:11:49,440 --> 00:11:54,280
statically ahead of time is stored in

00:11:52,030 --> 00:11:56,500
registry that's Alyssa's stored and we

00:11:54,280 --> 00:12:00,700
know that it's a valid and composed a

00:11:56,500 --> 00:12:02,440
graph stop turning my head and now

00:12:00,700 --> 00:12:05,980
finally the Gateway is only concerned

00:12:02,440 --> 00:12:12,850
with planning the query and executing

00:12:05,980 --> 00:12:14,320
that operation so implementation in

00:12:12,850 --> 00:12:15,760
order to make this work we're going to

00:12:14,320 --> 00:12:18,450
need a few things we're going to need

00:12:15,760 --> 00:12:21,370
two reference types from other services

00:12:18,450 --> 00:12:24,070
extend those types to add richness and

00:12:21,370 --> 00:12:25,540
then be able to plan a query so that a

00:12:24,070 --> 00:12:27,640
given operation that's coming in I know

00:12:25,540 --> 00:12:28,390
what services to talk to I know what

00:12:27,640 --> 00:12:31,210
each of those services

00:12:28,390 --> 00:12:36,040
provides so let's look back at this

00:12:31,210 --> 00:12:38,260
again what I need is on my user type I

00:12:36,040 --> 00:12:40,360
need a way to identify it and for those

00:12:38,260 --> 00:12:42,430
who have done a bit of database design

00:12:40,360 --> 00:12:43,740
this should look fairly familiar I need

00:12:42,430 --> 00:12:46,480
to define a key

00:12:43,740 --> 00:12:51,400
it's an algebraic way to identify that

00:12:46,480 --> 00:12:53,200
particular entity within the graph now

00:12:51,400 --> 00:12:56,220
that I have an entity I can extend that

00:12:53,200 --> 00:12:56,220
entity with additional information

00:13:00,420 --> 00:13:05,350
keynote is starting to be difficult just

00:13:02,470 --> 00:13:07,840
going to use my finger so in the review

00:13:05,350 --> 00:13:11,320
service I can add my reviews to the user

00:13:07,840 --> 00:13:12,880
entity there's a little extra syntax

00:13:11,320 --> 00:13:15,220
there we're going to cover that in a

00:13:12,880 --> 00:13:16,390
demonstration but once this is all

00:13:15,220 --> 00:13:19,720
composed together what does it actually

00:13:16,390 --> 00:13:23,370
look like when you view this schema in

00:13:19,720 --> 00:13:26,050
playground it is a single unified graph

00:13:23,370 --> 00:13:30,610
so we now have our single unified graph

00:13:26,050 --> 00:13:34,780
that is federated in implementation what

00:13:30,610 --> 00:13:38,110
about that query plan let's say that we

00:13:34,780 --> 00:13:39,550
have this operation with the same schema

00:13:38,110 --> 00:13:41,230
that we've been talking about so I'm

00:13:39,550 --> 00:13:43,990
gonna look up me I have some kind of

00:13:41,230 --> 00:13:46,630
token I need a name username and I'm

00:13:43,990 --> 00:13:49,000
gonna go grab those reviews so send that

00:13:46,630 --> 00:13:52,330
off to the gateway gateway knows well

00:13:49,000 --> 00:13:53,680
the me query and the user type that

00:13:52,330 --> 00:13:56,620
entity is defined over in the account

00:13:53,680 --> 00:13:58,210
service let me go fetch that first once

00:13:56,620 --> 00:14:00,160
that comes back you can take that user

00:13:58,210 --> 00:14:02,800
pass it to the review service the user

00:14:00,160 --> 00:14:04,390
says the review service sorry says thank

00:14:02,800 --> 00:14:07,950
you for the user let me give you back

00:14:04,390 --> 00:14:10,530
some reviews and at that point it's just

00:14:07,950 --> 00:14:14,370
recombining each of those objects

00:14:10,530 --> 00:14:14,370
serializing and sending it out the door

00:14:16,290 --> 00:14:19,500
demo time

00:14:21,510 --> 00:14:29,610
and I have paper notes because I'm a

00:14:26,590 --> 00:14:29,610
salty old engineer

00:14:36,160 --> 00:14:45,509
let's start here can you all see in the

00:14:39,130 --> 00:14:49,769
back raise your hand if you cannot what

00:14:45,509 --> 00:14:51,790
I'll give you one more one more bump up

00:14:49,769 --> 00:15:00,639
let's do the same thing quickly

00:14:51,790 --> 00:15:02,050
this is playground is it ok ok so let's

00:15:00,639 --> 00:15:04,240
take a look at that user entity again

00:15:02,050 --> 00:15:07,360
this is what I've shown you a few times

00:15:04,240 --> 00:15:09,190
now that key syntax for those who aren't

00:15:07,360 --> 00:15:13,329
doing Federation today should start to

00:15:09,190 --> 00:15:14,949
feel a little less strange key directive

00:15:13,329 --> 00:15:17,550
is simply defining the field that I'm

00:15:14,949 --> 00:15:20,589
going to use to identify that user and

00:15:17,550 --> 00:15:22,540
in fact let's talk to just the account

00:15:20,589 --> 00:15:25,870
service itself so each of these services

00:15:22,540 --> 00:15:28,959
is a bonafide graph QL service so I can

00:15:25,870 --> 00:15:37,870
execute this operation I promise this is

00:15:28,959 --> 00:15:40,509
real here look I'll refresh every ok so

00:15:37,870 --> 00:15:43,689
that's just the account service let's go

00:15:40,509 --> 00:15:49,779
back and let's take a look at review

00:15:43,689 --> 00:15:51,850
quickly so I need to refine need to

00:15:49,779 --> 00:15:54,699
define a review entity again I need some

00:15:51,850 --> 00:15:57,430
way to locate that entity within the

00:15:54,699 --> 00:16:01,899
graph so now I have a key I'm using ID

00:15:57,430 --> 00:16:04,089
again not creative the body of that

00:16:01,899 --> 00:16:08,110
review and now you notice that I'm going

00:16:04,089 --> 00:16:10,300
to reference back to the user so because

00:16:08,110 --> 00:16:11,829
I know that a user entity exists within

00:16:10,300 --> 00:16:13,389
my graph it was defined in the account

00:16:11,829 --> 00:16:16,120
service now I can reference that here

00:16:13,389 --> 00:16:18,850
and include it we're gonna see what

00:16:16,120 --> 00:16:20,259
happens when you begin to have what

00:16:18,850 --> 00:16:23,740
appeared to be circular references here

00:16:20,259 --> 00:16:26,230
in just a moment but more importantly my

00:16:23,740 --> 00:16:29,259
review service is is concerned with

00:16:26,230 --> 00:16:33,519
providing reviews so here I can extend

00:16:29,259 --> 00:16:35,139
the user type I match that signature so

00:16:33,519 --> 00:16:37,209
now the review service knows that there

00:16:35,139 --> 00:16:40,300
is a user and that these things exist

00:16:37,209 --> 00:16:41,889
external to this service and then says

00:16:40,300 --> 00:16:45,670
ok great when you're looking for reviews

00:16:41,889 --> 00:16:47,770
a guy I know exactly what to do let's

00:16:45,670 --> 00:16:51,660
look at the user service

00:16:47,770 --> 00:16:58,090
have a single review body says love it

00:16:51,660 --> 00:17:01,560
they like that one now what is it what's

00:16:58,090 --> 00:17:01,560
going to happen if we have often

00:17:01,620 --> 00:17:12,490
actually have an ID there can I add

00:17:07,060 --> 00:17:15,640
username I can so in in this somewhat

00:17:12,490 --> 00:17:18,070
contrived example but real example the

00:17:15,640 --> 00:17:19,870
review service does know that a given

00:17:18,070 --> 00:17:22,480
user ID and a given user name provided

00:17:19,870 --> 00:17:23,680
that review right the review services

00:17:22,480 --> 00:17:25,810
concerned with capturing that

00:17:23,680 --> 00:17:27,610
information now the account service has

00:17:25,810 --> 00:17:29,470
the full-blown user they have big gut

00:17:27,610 --> 00:17:31,030
you know billing information and all

00:17:29,470 --> 00:17:33,450
that other stuff let's say but in my

00:17:31,030 --> 00:17:37,780
review service I actually know about

00:17:33,450 --> 00:17:40,950
little tiny pieces of a user and then

00:17:37,780 --> 00:17:44,100
sure enough I can actually show here

00:17:40,950 --> 00:17:46,990
that I have an author and I can provide

00:17:44,100 --> 00:17:48,520
username I know how to do that it's

00:17:46,990 --> 00:17:53,260
gonna save me a round trip here in a

00:17:48,520 --> 00:17:54,970
second so I'd shown you a static version

00:17:53,260 --> 00:18:02,500
of this before but let's let's look at

00:17:54,970 --> 00:18:06,430
the full-blown schema now there's my

00:18:02,500 --> 00:18:07,780
user type it's no fancy entity syntax

00:18:06,430 --> 00:18:09,970
there's nothing that it would break a

00:18:07,780 --> 00:18:12,160
client that iOS app that you released

00:18:09,970 --> 00:18:15,570
last year that you're still waiting for

00:18:12,160 --> 00:18:19,210
approval to good update after iOS 13

00:18:15,570 --> 00:18:21,160
that things not going to break you've

00:18:19,210 --> 00:18:23,260
added reviews on to this type for

00:18:21,160 --> 00:18:24,370
instance but the federated graph is not

00:18:23,260 --> 00:18:26,500
going to break those clients that are

00:18:24,370 --> 00:18:27,310
out of the field you can see that

00:18:26,500 --> 00:18:31,450
there's a user name

00:18:27,310 --> 00:18:32,890
I see the review type and it knows that

00:18:31,450 --> 00:18:35,560
there's an author that refers to the

00:18:32,890 --> 00:18:40,450
user I've got a few others there are two

00:18:35,560 --> 00:18:41,980
other services participating here so

00:18:40,450 --> 00:18:43,750
let's start to execute some queries and

00:18:41,980 --> 00:18:49,080
let's see a query plan now for those who

00:18:43,750 --> 00:18:51,780
have used the experimental query plan I

00:18:49,080 --> 00:18:55,560
hacked in something different for today

00:18:51,780 --> 00:19:00,429
because I'm old and I like diagrams and

00:18:55,560 --> 00:19:02,660
I was tired of reading JSON by hand

00:19:00,429 --> 00:19:06,710
so first things first let's see what

00:19:02,660 --> 00:19:10,330
happens when we ask the Gateway when I

00:19:06,710 --> 00:19:12,470
go to fetch me what are you gonna go do

00:19:10,330 --> 00:19:16,520
well I'm gonna go to the account service

00:19:12,470 --> 00:19:20,690
I'm gonna go fetch me it's pretty

00:19:16,520 --> 00:19:24,100
straightforward now let's go ahead and

00:19:20,690 --> 00:19:24,100
make sure this is valid syntax

00:19:24,919 --> 00:19:32,419
I want the review associated with that

00:19:28,610 --> 00:19:33,919
user reviews so now I know I have a

00:19:32,419 --> 00:19:35,330
sequence of operations I'm going to need

00:19:33,919 --> 00:19:37,220
to perform I'm going to go to the

00:19:35,330 --> 00:19:38,720
account service I'm going to fetch the

00:19:37,220 --> 00:19:41,270
me portion of that query I'm going to

00:19:38,720 --> 00:19:44,030
collect the result of that query I'm

00:19:41,270 --> 00:19:50,929
going to use it as input and fetch from

00:19:44,030 --> 00:19:53,690
the review service pretty sweet I want

00:19:50,929 --> 00:19:55,549
to go ahead and pull author and remember

00:19:53,690 --> 00:19:58,190
that user name I had an optimization I

00:19:55,549 --> 00:20:00,830
actually can provide user name from the

00:19:58,190 --> 00:20:03,200
review service so this doesn't look any

00:20:00,830 --> 00:20:05,660
different the plan itself doesn't look

00:20:03,200 --> 00:20:09,919
any different the result now includes

00:20:05,660 --> 00:20:14,480
user name but the query plan sequence go

00:20:09,919 --> 00:20:18,320
and fetch my account collect me return

00:20:14,480 --> 00:20:20,419
my reviews now what happens if we add in

00:20:18,320 --> 00:20:25,549
a name because review doesn't actually

00:20:20,419 --> 00:20:28,549
know about name Brenda go fetch my

00:20:25,549 --> 00:20:30,200
accounts collect the value fetch my

00:20:28,549 --> 00:20:32,720
reviews and for each one of those

00:20:30,200 --> 00:20:34,220
reviews I need to resolve author I'm

00:20:32,720 --> 00:20:35,990
gonna use that as an input back to the

00:20:34,220 --> 00:20:38,270
account service and then it will go and

00:20:35,990 --> 00:20:39,470
fetch the name for each one of those you

00:20:38,270 --> 00:20:40,760
might want to talk to the reviews team

00:20:39,470 --> 00:20:42,830
and safely see if they want to store

00:20:40,760 --> 00:20:45,890
that over there or maybe don't include

00:20:42,830 --> 00:20:47,840
that on the UI because really all we

00:20:45,890 --> 00:20:48,950
really needed for the reviews is we just

00:20:47,840 --> 00:20:50,540
need to show the user name and then

00:20:48,950 --> 00:20:52,700
we'll link to their user profile right

00:20:50,540 --> 00:20:53,990
I've saved myself a hop here I don't

00:20:52,700 --> 00:20:57,340
have to go back to the account service

00:20:53,990 --> 00:20:57,340
it's pretty handy

00:21:01,010 --> 00:21:06,960
so I also have some products and in this

00:21:05,340 --> 00:21:09,929
particular example the product service

00:21:06,960 --> 00:21:13,230
has a furniture implementation so

00:21:09,929 --> 00:21:15,570
product is is an interface and there's a

00:21:13,230 --> 00:21:18,360
furniture concrete implementation there

00:21:15,570 --> 00:21:20,659
in fact let's let's look quickly at what

00:21:18,360 --> 00:21:24,480
this is actually going to look like so I

00:21:20,659 --> 00:21:29,820
do have tables couches chairs and

00:21:24,480 --> 00:21:32,700
apparently books so let's go ahead and

00:21:29,820 --> 00:21:34,110
see what happens now when I say ok for

00:21:32,700 --> 00:21:43,200
each one of those reviews what product

00:21:34,110 --> 00:21:47,220
is that about not able to resolve there

00:21:43,200 --> 00:21:51,210
is no product on review told you I

00:21:47,220 --> 00:21:54,860
wasn't afraid to run this demo let's see

00:21:51,210 --> 00:21:54,860
I know that I have a review entity oh

00:21:55,190 --> 00:22:00,169
right silly me

00:22:01,250 --> 00:22:04,400
let's make sure it composes remember

00:22:02,960 --> 00:22:05,870
static composition when the Gateway

00:22:04,400 --> 00:22:08,710
starts up it actually can tell me

00:22:05,870 --> 00:22:08,710
whether or not that's there

00:22:14,290 --> 00:22:18,490
now the query plan same sequence as

00:22:16,900 --> 00:22:20,620
before I'm going to go ahead and collect

00:22:18,490 --> 00:22:21,850
me I'm gonna fetch the reviews I'm gonna

00:22:20,620 --> 00:22:23,650
take the reviews and the products I'm

00:22:21,850 --> 00:22:26,680
gonna go fetch my products I know what

00:22:23,650 --> 00:22:29,860
that is now these have all been serial

00:22:26,680 --> 00:22:32,860
operations and it you might be wondering

00:22:29,860 --> 00:22:35,860
is every operation that I ever send

00:22:32,860 --> 00:22:37,120
going to be some serial nightmare where

00:22:35,860 --> 00:22:42,750
by the time I get to the very end the

00:22:37,120 --> 00:22:48,190
client has timed out answer is No oops I

00:22:42,750 --> 00:22:51,360
don't need the definition of book so if

00:22:48,190 --> 00:22:53,800
you're gonna clap at building a dynamic

00:22:51,360 --> 00:22:56,560
query plan visualizer in the last couple

00:22:53,800 --> 00:23:03,550
of days now would be the time just just

00:22:56,560 --> 00:23:07,570
on I'm not you probably to ask for that

00:23:03,550 --> 00:23:09,700
sort of thing these days the query

00:23:07,570 --> 00:23:11,620
planner is smart enough today already

00:23:09,700 --> 00:23:13,210
to understand that I'm going to go ahead

00:23:11,620 --> 00:23:14,620
and fetch these reviews and for each one

00:23:13,210 --> 00:23:16,150
of these reviews I can actually hit two

00:23:14,620 --> 00:23:18,040
different services in parallel one of

00:23:16,150 --> 00:23:19,630
the services is concerned with returning

00:23:18,040 --> 00:23:21,160
the furniture concrete type

00:23:19,630 --> 00:23:24,820
implementation but since the book

00:23:21,160 --> 00:23:26,560
service also is a product I can go ahead

00:23:24,820 --> 00:23:28,270
and fetch those in parallel and I can do

00:23:26,560 --> 00:23:30,220
that because what I need to do that is

00:23:28,270 --> 00:23:35,130
the review because the review has the

00:23:30,220 --> 00:23:35,130
connection to the entity the product

00:23:36,180 --> 00:23:40,330
once I make this prettier I'll go ahead

00:23:38,710 --> 00:23:42,520
and submit a PR so for those of you who

00:23:40,330 --> 00:23:45,160
do use the query planner on a regular

00:23:42,520 --> 00:23:47,550
basis I promise I'm not trying to keep

00:23:45,160 --> 00:23:47,550
it for myself

00:23:58,870 --> 00:24:04,300
so what is the architecture of

00:24:00,250 --> 00:24:05,920
Federation what is Federation it's a

00:24:04,300 --> 00:24:08,410
declarative model for graph composition

00:24:05,920 --> 00:24:11,530
of loosely coupled downstream graph QL

00:24:08,410 --> 00:24:14,800
services that enable static composition

00:24:11,530 --> 00:24:16,600
and validation of a unified graph using

00:24:14,800 --> 00:24:21,040
query plans to resolve downstream

00:24:16,600 --> 00:24:23,830
operations I hope this makes a lot more

00:24:21,040 --> 00:24:26,140
sense now so when I was building this

00:24:23,830 --> 00:24:27,640
talk I started with this and then I

00:24:26,140 --> 00:24:32,890
worked through my demo and then it made

00:24:27,640 --> 00:24:35,560
it made a lot more sense then to again

00:24:32,890 --> 00:24:38,280
thank you thank you for being here find

00:24:35,560 --> 00:24:40,870
me on Twitter find me on github find me

00:24:38,280 --> 00:24:43,180
here I'll be around

00:24:40,870 --> 00:24:45,130
I'd love to talk to you about all things

00:24:43,180 --> 00:24:46,750
architecture code if you're into that

00:24:45,130 --> 00:24:48,340
sort of thing

00:24:46,750 --> 00:24:51,400
we have some feedback forms in the back

00:24:48,340 --> 00:24:54,060
and I will see you all on the internet

00:24:51,400 --> 00:24:54,060
thank you so much

00:24:55,520 --> 00:24:58,819

YouTube URL: https://www.youtube.com/watch?v=LKQKn1oFXJU


