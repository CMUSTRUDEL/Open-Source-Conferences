Title: Sorting and filtering in GraphQL (JÉRÉMIE ASTORI - Software Engineer at CloudHealth by VMware)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	GraphQL lets you select fields out of the box. Relay and Apollo introduce standard patterns for paginating results. There are however no obvious patterns for sorting and filtering results. Allow me to present a few reusable solutions.

Resources:
ApolloGraphQL - https://www.apollographql.com/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:00,819 --> 00:00:05,539
thank you and thank you very much for

00:00:02,900 --> 00:00:07,339
being here today it's a really packed

00:00:05,539 --> 00:00:10,070
room right now this is not stressful at

00:00:07,339 --> 00:00:14,840
all so I'll do my best not to look so

00:00:10,070 --> 00:00:19,070
stressed okay so some time ago I was

00:00:14,840 --> 00:00:20,990
working on a UI that had that was

00:00:19,070 --> 00:00:24,289
displaying a bunch of data on the page

00:00:20,990 --> 00:00:27,830
that I was coming from a graph QL

00:00:24,289 --> 00:00:29,570
back-end and that data was paginate it

00:00:27,830 --> 00:00:32,960
and it was paginating following the

00:00:29,570 --> 00:00:36,230
relay spec so came a time where I needed

00:00:32,960 --> 00:00:38,930
to add a feature to sort to let the user

00:00:36,230 --> 00:00:42,950
solve that data based on the fields that

00:00:38,930 --> 00:00:45,950
they wanted to sort off so I figured

00:00:42,950 --> 00:00:48,620
graph QL the graphical specs lets me

00:00:45,950 --> 00:00:52,430
select fields in a data set it lets me

00:00:48,620 --> 00:00:54,710
join data sets also the relay spec lets

00:00:52,430 --> 00:00:57,079
me paginate data so that sounds familiar

00:00:54,710 --> 00:01:01,100
I should probably be able to find a way

00:00:57,079 --> 00:01:05,119
to sort and filter or a way to do that

00:01:01,100 --> 00:01:07,340
and sure enough lis by run commented

00:01:05,119 --> 00:01:09,020
that graph QL does not support that it's

00:01:07,340 --> 00:01:12,229
now it's rightfully not the place to do

00:01:09,020 --> 00:01:15,049
that and if you do that most systems use

00:01:12,229 --> 00:01:19,100
field arguments and they do the problem

00:01:15,049 --> 00:01:21,710
is they all do it differently so hi I'm

00:01:19,100 --> 00:01:24,500
Jeremy I work for cloud health by VMware

00:01:21,710 --> 00:01:26,180
and before that I was working at w3c

00:01:24,500 --> 00:01:30,259
which would explain to you why I'm here

00:01:26,180 --> 00:01:32,750
on stage talking about standards so I

00:01:30,259 --> 00:01:37,009
was looking for a good example to give

00:01:32,750 --> 00:01:38,869
to illustrate my patterns and last time

00:01:37,009 --> 00:01:42,229
I gave a graphical talk it was about

00:01:38,869 --> 00:01:45,920
beers and breweries I really quickly

00:01:42,229 --> 00:01:48,500
that not being a fan of IPAs in the US

00:01:45,920 --> 00:01:50,780
will not give you many friends so I

00:01:48,500 --> 00:01:53,659
decided to find another inspiration I

00:01:50,780 --> 00:01:55,159
asked Google hey what kind of movies do

00:01:53,659 --> 00:01:57,470
you recommend surprisingly

00:01:55,159 --> 00:02:00,530
the first result was movies with the

00:01:57,470 --> 00:02:03,259
rock which was also mentioned so very

00:02:00,530 --> 00:02:06,140
surprising but I figure and we're going

00:02:03,259 --> 00:02:09,109
to sort and filter movies featuring the

00:02:06,140 --> 00:02:11,029
rock and we're going to do that so this

00:02:09,109 --> 00:02:13,939
is a this is what you would get

00:02:11,029 --> 00:02:14,450
initially and unsorted and unsorted so

00:02:13,939 --> 00:02:16,959
why

00:02:14,450 --> 00:02:21,260
doing this I'm trying to present a

00:02:16,959 --> 00:02:24,830
concise yet generic pattern for sorting

00:02:21,260 --> 00:02:27,410
and filtering so keep that in mind so

00:02:24,830 --> 00:02:29,510
we're gonna add a field argument like

00:02:27,410 --> 00:02:33,680
Lee mentioned you recommended that

00:02:29,510 --> 00:02:36,110
accepts both field and order the order

00:02:33,680 --> 00:02:39,290
itself is optional

00:02:36,110 --> 00:02:41,540
it defaults to ascending and you know it

00:02:39,290 --> 00:02:44,239
just works problem is that's not enough

00:02:41,540 --> 00:02:47,390
I want to support multiple levels of

00:02:44,239 --> 00:02:51,019
sorting also known as merge sort and for

00:02:47,390 --> 00:02:53,150
that we can use one of we can use a get

00:02:51,019 --> 00:02:56,599
a very convenient capability of graph QL

00:02:53,150 --> 00:02:58,940
which says that if as an input to a list

00:02:56,599 --> 00:03:01,910
type is not a list then the result of

00:02:58,940 --> 00:03:03,950
input coercion is a list of a size one

00:03:01,910 --> 00:03:06,440
where the single item is the provided

00:03:03,950 --> 00:03:11,090
value what does that mean it means that

00:03:06,440 --> 00:03:15,319
if I accept a list of values I can pass

00:03:11,090 --> 00:03:18,620
a list obviously I can pass at least one

00:03:15,319 --> 00:03:20,720
value or I can pass a single value and I

00:03:18,620 --> 00:03:22,670
will be coerced into a list of that

00:03:20,720 --> 00:03:24,109
value that's very convenient because now

00:03:22,670 --> 00:03:27,290
we can do this we can pass multiple

00:03:24,109 --> 00:03:29,510
values without having to change the

00:03:27,290 --> 00:03:32,420
queries that we wrote earlier so passing

00:03:29,510 --> 00:03:36,829
just a single work and as we can see

00:03:32,420 --> 00:03:38,989
here we have we have that list that it

00:03:36,829 --> 00:03:42,950
ordered exactly what we like we want all

00:03:38,989 --> 00:03:45,410
movies are sorted by really release year

00:03:42,950 --> 00:03:47,989
and for mood for the four movies that

00:03:45,410 --> 00:03:51,200
were released during the same year its

00:03:47,989 --> 00:03:52,940
although that's a basically what what

00:03:51,200 --> 00:03:54,350
does the scheme I look like a schema is

00:03:52,940 --> 00:03:57,380
pretty straight forward I'm not going to

00:03:54,350 --> 00:04:02,510
go into details but the things to note

00:03:57,380 --> 00:04:04,760
are that the sort input is a list like I

00:04:02,510 --> 00:04:06,709
mentioned and the other thing is field

00:04:04,760 --> 00:04:09,139
is not a string you don't adjust a

00:04:06,709 --> 00:04:14,060
string with the title in it you pass an

00:04:09,139 --> 00:04:17,209
enum that leads to a more verbose schema

00:04:14,060 --> 00:04:19,370
but first of all you can give that for

00:04:17,209 --> 00:04:21,739
your implementation to him to take care

00:04:19,370 --> 00:04:25,460
of so you don't have to worry about the

00:04:21,739 --> 00:04:27,860
about the extra velocity and also that

00:04:25,460 --> 00:04:28,250
gives you more control more fine-grained

00:04:27,860 --> 00:04:32,750
control

00:04:28,250 --> 00:04:35,210
/ what you want what you want to expose

00:04:32,750 --> 00:04:39,110
as a soluble field so for example you

00:04:35,210 --> 00:04:40,910
could say that users can only sort

00:04:39,110 --> 00:04:43,700
fields that have a corresponding

00:04:40,910 --> 00:04:47,210
database index right so that way I can

00:04:43,700 --> 00:04:49,460
do that through the enum type all right

00:04:47,210 --> 00:04:51,680
what about filtering filtering will

00:04:49,460 --> 00:04:55,520
follow something very similar we pass a

00:04:51,680 --> 00:04:59,780
field argument here I pass a nested

00:04:55,520 --> 00:05:02,540
object that takes a field and a parade R

00:04:59,780 --> 00:05:04,820
and a value a bunch of systems out there

00:05:02,540 --> 00:05:08,330
into it differently some Prisma for

00:05:04,820 --> 00:05:11,660
example except a key value pair where

00:05:08,330 --> 00:05:15,740
the key is a concatenation of field and

00:05:11,660 --> 00:05:19,250
operator graphic will compose does a

00:05:15,740 --> 00:05:22,370
couple different ways but here I'm

00:05:19,250 --> 00:05:25,310
trying not to be confusing just have one

00:05:22,370 --> 00:05:29,570
way to do it and does it so I'm trying

00:05:25,310 --> 00:05:31,780
to to get a list of all the movies from

00:05:29,570 --> 00:05:34,220
the Fast and Furious franchise here I'm

00:05:31,780 --> 00:05:36,979
missing some why am I missing some

00:05:34,220 --> 00:05:39,020
because some do not have the word fast

00:05:36,979 --> 00:05:40,460
they have the word fierce and so I'm

00:05:39,020 --> 00:05:42,500
going to have two words they have the

00:05:40,460 --> 00:05:46,160
word fast so I could do this which is

00:05:42,500 --> 00:05:49,880
what gets B does I could pass a list of

00:05:46,160 --> 00:05:52,520
value lists of value sorry that should

00:05:49,880 --> 00:05:55,669
that would match my criteria the problem

00:05:52,520 --> 00:05:58,430
is if I just show you that it unclear to

00:05:55,669 --> 00:06:01,400
me I'm trying to get a list of movies

00:05:58,430 --> 00:06:04,490
whose title contains fast and furious or

00:06:01,400 --> 00:06:07,190
whose title contains the words fast or

00:06:04,490 --> 00:06:09,590
showing us so it's it's slightly

00:06:07,190 --> 00:06:11,930
confusing it's the intent is not very

00:06:09,590 --> 00:06:15,860
clear so I prefer to go for something a

00:06:11,930 --> 00:06:18,520
little more both but also more explicit

00:06:15,860 --> 00:06:21,590
there is no room for confusion here

00:06:18,520 --> 00:06:22,850
alright for my last example I'm gonna

00:06:21,590 --> 00:06:26,660
I'm gonna

00:06:22,850 --> 00:06:29,150
I want several lists of all recent

00:06:26,660 --> 00:06:31,850
movies within the last two years or

00:06:29,150 --> 00:06:34,160
recent movies by the rock where with the

00:06:31,850 --> 00:06:37,039
rock where Dwayne Johnson is not upset

00:06:34,160 --> 00:06:39,820
what do I mean by that well it's very

00:06:37,039 --> 00:06:42,270
straightforward twin Johnson is upset

00:06:39,820 --> 00:06:45,600
twin Johnson is not upset

00:06:42,270 --> 00:06:49,979
he's very upset and here is very

00:06:45,600 --> 00:06:52,979
confused but he's not upset so there we

00:06:49,979 --> 00:06:54,840
have it it's the same query it's very

00:06:52,979 --> 00:06:59,400
similar-looking query as we saw earlier

00:06:54,840 --> 00:07:03,360
I have an end operator a lot of systems

00:06:59,400 --> 00:07:06,389
will let you pass directly multiple keys

00:07:03,360 --> 00:07:09,090
without the an operator but that has

00:07:06,389 --> 00:07:11,970
some problems again it's confusing you

00:07:09,090 --> 00:07:14,250
don't really know the intent if you just

00:07:11,970 --> 00:07:17,310
look at the query and also what happens

00:07:14,250 --> 00:07:21,660
if I want to list movies that were

00:07:17,310 --> 00:07:25,320
released between 2010 and 2015 I either

00:07:21,660 --> 00:07:28,349
have to to add to include a new operator

00:07:25,320 --> 00:07:30,000
that is very specific and again we're

00:07:28,349 --> 00:07:32,789
trying to go for something very generic

00:07:30,000 --> 00:07:35,789
here or you have to do something key

00:07:32,789 --> 00:07:39,240
like pass multiple raters within the

00:07:35,789 --> 00:07:40,979
same object so instead I'm going for an

00:07:39,240 --> 00:07:43,289
explicit and operator and I'm adding a

00:07:40,979 --> 00:07:47,909
constraint which is a back end and force

00:07:43,289 --> 00:07:51,570
constraint which is that all objects

00:07:47,909 --> 00:07:53,759
within the feature type must have an era

00:07:51,570 --> 00:07:57,960
T of one maximum so you cannot have more

00:07:53,759 --> 00:08:00,630
than one key operator of value pair and

00:07:57,960 --> 00:08:02,900
again it's all about not being confusing

00:08:00,630 --> 00:08:05,150
and being very explicit in your own time

00:08:02,900 --> 00:08:08,520
so what does this key might look like

00:08:05,150 --> 00:08:10,169
again it's it's very straightforward the

00:08:08,520 --> 00:08:14,460
main difference with what we saw earlier

00:08:10,169 --> 00:08:16,500
is that we don't accept a list of inputs

00:08:14,460 --> 00:08:19,949
we just accept a single input and that

00:08:16,500 --> 00:08:23,880
input is recursive because of the the

00:08:19,949 --> 00:08:27,120
end and/or logical operators and we can

00:08:23,880 --> 00:08:30,599
also see that there is a bunch of extra

00:08:27,120 --> 00:08:32,310
inputs extra types it's pretty verbose

00:08:30,599 --> 00:08:35,190
on the schema you don't want to do that

00:08:32,310 --> 00:08:38,880
by hand ideally you have all of that

00:08:35,190 --> 00:08:42,599
gets generated for you so I can we take

00:08:38,880 --> 00:08:45,120
away from this I mentioned a few systems

00:08:42,599 --> 00:08:48,149
I mentioned graphical compose I

00:08:45,120 --> 00:08:50,180
mentioned Prisma I mentioned Gatsby I'm

00:08:48,149 --> 00:08:52,709
sure there are many other tools

00:08:50,180 --> 00:08:55,949
libraries technologies implementations

00:08:52,709 --> 00:08:56,640
that support field installing they all

00:08:55,949 --> 00:08:59,760
have the same

00:08:56,640 --> 00:09:02,070
problem they all implement a different

00:08:59,760 --> 00:09:04,800
format so if you've used any of those

00:09:02,070 --> 00:09:06,600
systems you know that if you expose

00:09:04,800 --> 00:09:08,330
something in one technology it's going

00:09:06,600 --> 00:09:13,200
to look different in another technology

00:09:08,330 --> 00:09:16,590
so instead I want to suggest a more

00:09:13,200 --> 00:09:21,810
in-depth approach that we can we can

00:09:16,590 --> 00:09:25,290
build a step out from all right so for

00:09:21,810 --> 00:09:28,050
those of you who read xkcd what you just

00:09:25,290 --> 00:09:30,840
heard might sound familiar to you I'm on

00:09:28,050 --> 00:09:34,230
stage talking about a universal better

00:09:30,840 --> 00:09:35,820
way to do something and I'm just adding

00:09:34,230 --> 00:09:38,520
one to the pool right I'm not doing

00:09:35,820 --> 00:09:40,110
anything more than actually I'm even

00:09:38,520 --> 00:09:42,090
doing less than what others have done

00:09:40,110 --> 00:09:43,920
because all of those technologies have

00:09:42,090 --> 00:09:47,150
an implementation and I don't even have

00:09:43,920 --> 00:09:50,120
one I just have words on a screen right

00:09:47,150 --> 00:09:52,770
so what can we do about this

00:09:50,120 --> 00:09:54,870
we know that graph QL has a few specs

00:09:52,770 --> 00:09:56,790
there is the graph QL spec by Facebook

00:09:54,870 --> 00:09:59,850
there is the relay expect by Facebook

00:09:56,790 --> 00:10:02,610
and we also know that Facebook is not

00:09:59,850 --> 00:10:05,520
the only owner of specs Federation is

00:10:02,610 --> 00:10:08,910
aspect by Apatow I believe that we can

00:10:05,520 --> 00:10:10,830
come we can come up with a spec or a set

00:10:08,910 --> 00:10:13,230
of specs for filtering and sorting that

00:10:10,830 --> 00:10:16,170
would solve the same problems that say

00:10:13,230 --> 00:10:18,360
real a salt for pagination and we don't

00:10:16,170 --> 00:10:20,360
have to do it in a vacuum either all of

00:10:18,360 --> 00:10:22,890
the examples that I've shown so far

00:10:20,360 --> 00:10:26,490
compatible with real a this is a really

00:10:22,890 --> 00:10:28,050
compliant query that would support

00:10:26,490 --> 00:10:29,700
sorting and filtering and in fact I'm

00:10:28,050 --> 00:10:32,250
sure this is no news to you you probably

00:10:29,700 --> 00:10:34,320
have that in your own systems I'm sure

00:10:32,250 --> 00:10:35,820
have the room here as implemented

00:10:34,320 --> 00:10:38,910
filtering and sorting one way or another

00:10:35,820 --> 00:10:42,420
and it looks more or less like this not

00:10:38,910 --> 00:10:43,950
exactly like this but it does work we

00:10:42,420 --> 00:10:49,380
should be able to have the same

00:10:43,950 --> 00:10:51,510
everywhere so if you are interested in

00:10:49,380 --> 00:10:54,540
this topic I know that standards are a

00:10:51,510 --> 00:10:58,370
very sexy topic so if you're interested

00:10:54,540 --> 00:11:01,170
bias or if you maintain your own library

00:10:58,370 --> 00:11:02,730
that has to point for filtering and

00:11:01,170 --> 00:11:04,410
sorting or if you maintain a library

00:11:02,730 --> 00:11:06,300
that does not yet have support for

00:11:04,410 --> 00:11:07,710
filtering and sorting come talk to me at

00:11:06,300 --> 00:11:10,080
the end I would love to find a way where

00:11:07,710 --> 00:11:10,410
we can work on something together and

00:11:10,080 --> 00:11:13,740
come

00:11:10,410 --> 00:11:14,790
with a speck even if even if at the

00:11:13,740 --> 00:11:17,370
beginning we only have two

00:11:14,790 --> 00:11:20,250
implementations of that speck that would

00:11:17,370 --> 00:11:22,500
be twice as much as much as what we have

00:11:20,250 --> 00:11:25,920
already so I think that would be a win

00:11:22,500 --> 00:11:26,990
and then we can build up so I got thank

00:11:25,920 --> 00:11:31,450
you very much

00:11:26,990 --> 00:11:31,450

YouTube URL: https://www.youtube.com/watch?v=dDxUu-K2qdE


