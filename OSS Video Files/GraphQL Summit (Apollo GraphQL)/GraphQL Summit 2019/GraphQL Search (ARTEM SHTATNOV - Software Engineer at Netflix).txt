Title: GraphQL Search (ARTEM SHTATNOV - Software Engineer at Netflix)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Learn how we are able to search across our graph by leveraging existing graph edges to automatically build and maintain search indices.
Captions: 
	00:00:03,339 --> 00:00:15,280
so how many people have played an escape

00:00:07,819 --> 00:00:15,280
room game before that's quite a few so

00:00:17,350 --> 00:00:23,570
in the game you need to find clues under

00:00:20,390 --> 00:00:24,980
rugs behind cabinets and every like milk

00:00:23,570 --> 00:00:27,109
and cranny that the game designers could

00:00:24,980 --> 00:00:31,160
think of once you find all these clues

00:00:27,109 --> 00:00:36,889
you need to combine them in order to

00:00:31,160 --> 00:00:42,859
escape and now imagine all the clues are

00:00:36,889 --> 00:00:45,530
placed on a single table in front of you

00:00:42,859 --> 00:00:45,889
and the exact sequence you need to use

00:00:45,530 --> 00:00:49,129
them

00:00:45,889 --> 00:00:52,819
you'd probably escape a lot faster the

00:00:49,129 --> 00:00:58,760
hard and time-consuming part is the

00:00:52,819 --> 00:01:01,729
search on my team at Netflix we faced

00:00:58,760 --> 00:01:03,589
this exact problem how do we quickly

00:01:01,729 --> 00:01:11,000
search across data spread across

00:01:03,589 --> 00:01:13,939
multiple data sources so I will walk you

00:01:11,000 --> 00:01:18,229
through how we use correct QL to build

00:01:13,939 --> 00:01:21,859
our search index and how we and how we

00:01:18,229 --> 00:01:24,380
keep this index up to date I will then

00:01:21,859 --> 00:01:28,250
show how this fits into our data flow

00:01:24,380 --> 00:01:32,689
and share sample learnings from using

00:01:28,250 --> 00:01:37,369
the graph QL for search over the past

00:01:32,689 --> 00:01:41,770
half year but first let's talk a bit

00:01:37,369 --> 00:01:45,950
about what my team does so I work on the

00:01:41,770 --> 00:01:48,350
marketing technology team at Netflix and

00:01:45,950 --> 00:01:53,740
our goal is from both Netflix content

00:01:48,350 --> 00:01:57,499
across the globe we have thousands of

00:01:53,740 --> 00:02:01,340
shows up on the service we operate in

00:01:57,499 --> 00:02:06,619
over 190 countries and we support around

00:02:01,340 --> 00:02:11,650
30 languages for each of these shows

00:02:06,619 --> 00:02:13,690
countries and languages we need to find

00:02:11,650 --> 00:02:15,700
the right

00:02:13,690 --> 00:02:20,560
creative which resonates with each

00:02:15,700 --> 00:02:23,920
viewer my team builds the tools to

00:02:20,560 --> 00:02:32,080
produce it and distribute these

00:02:23,920 --> 00:02:35,160
marketing creatives at scale so we use

00:02:32,080 --> 00:02:39,460
craft qaul to pull together all of our

00:02:35,160 --> 00:02:43,330
data and here's a sample at the very

00:02:39,460 --> 00:02:45,430
core we have a creative service which

00:02:43,330 --> 00:02:49,030
keeps track of all the creatives that we

00:02:45,430 --> 00:02:52,330
build we enhance each of these with

00:02:49,030 --> 00:02:57,340
information on the show it promotes and

00:02:52,330 --> 00:03:01,780
we further enhance the show with how

00:02:57,340 --> 00:03:06,070
popular it is in every country we also

00:03:01,780 --> 00:03:09,400
like allow our marketing team to comment

00:03:06,070 --> 00:03:14,200
on these traders despite all this data

00:03:09,400 --> 00:03:15,850
coming from many sources graph queue all

00:03:14,200 --> 00:03:19,030
makes it very easy to pull together all

00:03:15,850 --> 00:03:28,660
this data for a single creative but we

00:03:19,030 --> 00:03:33,520
have quite a few if we build only a few

00:03:28,660 --> 00:03:36,640
variations for each show country and

00:03:33,520 --> 00:03:40,390
language we have over 15 million total

00:03:36,640 --> 00:03:42,370
creative variations we need a proper

00:03:40,390 --> 00:03:46,150
search to be able to keep track of all

00:03:42,370 --> 00:03:50,800
this data so how do we index our search

00:03:46,150 --> 00:03:57,970
database because we use carafe queue all

00:03:50,800 --> 00:04:02,170
we can simply iterate over all the

00:03:57,970 --> 00:04:05,080
creatives in our database call craft

00:04:02,170 --> 00:04:06,910
queue all to get the necessary data for

00:04:05,080 --> 00:04:12,489
each of these and put the results into

00:04:06,910 --> 00:04:14,290
the elastic search so once our all of

00:04:12,489 --> 00:04:17,049
our data has been indexed we can do

00:04:14,290 --> 00:04:21,640
quite a bit with it we can sort group

00:04:17,049 --> 00:04:26,100
and filter on arbitrary fields we can

00:04:21,640 --> 00:04:26,100
provide provides provides

00:04:26,270 --> 00:04:32,520
provides suggestions to the user as they

00:04:29,280 --> 00:04:36,450
entered their query where we can show

00:04:32,520 --> 00:04:40,050
fast let's see to quickly filter by we

00:04:36,450 --> 00:04:43,250
can progressively load our data to

00:04:40,050 --> 00:04:47,610
provide it hey infinite the scroll

00:04:43,250 --> 00:04:49,290
experience and best of all the data

00:04:47,610 --> 00:04:53,970
comes back significantly faster since

00:04:49,290 --> 00:04:56,610
everything has been cached but we can't

00:04:53,970 --> 00:05:01,710
just index or data one time we have to

00:04:56,610 --> 00:05:05,910
keep the index up-to-date but as things

00:05:01,710 --> 00:05:09,180
like change so how do we do this we

00:05:05,910 --> 00:05:11,460
already have Kafka event emitted from

00:05:09,180 --> 00:05:14,190
our back-end when something changes so

00:05:11,460 --> 00:05:16,860
the first step is to listen to those

00:05:14,190 --> 00:05:19,350
like change events we can here change

00:05:16,860 --> 00:05:23,180
event for the creative for the show for

00:05:19,350 --> 00:05:25,740
the title look ranking work with the

00:05:23,180 --> 00:05:28,500
comments but for now we can focus on

00:05:25,740 --> 00:05:31,890
what happens if we hear a title we're

00:05:28,500 --> 00:05:36,110
ranking by change event we need to

00:05:31,890 --> 00:05:39,690
determine which creatives to be honest

00:05:36,110 --> 00:05:43,620
so we already know that title the

00:05:39,690 --> 00:05:48,570
ranking is for a show and creatives

00:05:43,620 --> 00:05:51,620
promote shows so we can write some code

00:05:48,570 --> 00:05:54,210
to make this work and we can hard code

00:05:51,620 --> 00:05:56,280
all of these the rules as well but we

00:05:54,210 --> 00:05:58,740
don't have to keep these rules about

00:05:56,280 --> 00:06:01,560
today but as our schemas the change or

00:05:58,740 --> 00:06:05,430
as we build the new indices fortunately

00:06:01,560 --> 00:06:06,600
we don't have to correct can you all

00:06:05,430 --> 00:06:10,650
like already defines all the

00:06:06,600 --> 00:06:12,420
relationships among our data and we can

00:06:10,650 --> 00:06:17,070
use these relationships to keep our

00:06:12,420 --> 00:06:21,300
index up-to-date so here's a graphical

00:06:17,070 --> 00:06:25,560
representation of our original query so

00:06:21,300 --> 00:06:27,630
what do we do to build it to build it to

00:06:25,560 --> 00:06:28,950
build or like search in Dexter once we

00:06:27,630 --> 00:06:33,450
here like a change event for the title

00:06:28,950 --> 00:06:36,750
ranking so the first thing we do is we

00:06:33,450 --> 00:06:38,380
do a fan-out operation basically asking

00:06:36,750 --> 00:06:39,970
correct

00:06:38,380 --> 00:06:42,010
you all to provide us with all the show

00:06:39,970 --> 00:06:44,710
IDs that are connected to this change

00:06:42,010 --> 00:06:48,040
title ranking and once we have these

00:06:44,710 --> 00:06:50,230
like show IDs we can search our our

00:06:48,040 --> 00:06:52,270
database of creatives to find all the

00:06:50,230 --> 00:07:00,120
ones that actually reference these

00:06:52,270 --> 00:07:03,310
values the creatives we find are the

00:07:00,120 --> 00:07:04,360
heart exact wants me to be index and we

00:07:03,310 --> 00:07:09,610
can reenacts them using the same

00:07:04,360 --> 00:07:12,340
pipeline we used to index them in the

00:07:09,610 --> 00:07:14,290
first place so this approach actually

00:07:12,340 --> 00:07:15,630
works for much more complex data like as

00:07:14,290 --> 00:07:19,240
well

00:07:15,630 --> 00:07:22,420
the original fan-out the operation only

00:07:19,240 --> 00:07:26,110
needs to go up one level from the change

00:07:22,420 --> 00:07:30,610
vertex to his parent we don't have to do

00:07:26,110 --> 00:07:33,640
a full carafe search to find out find

00:07:30,610 --> 00:07:36,490
out what changed because only that

00:07:33,640 --> 00:07:39,640
vertex it as media the edges could have

00:07:36,490 --> 00:07:43,240
changed the fan-out operation in

00:07:39,640 --> 00:07:44,710
combination with the search gives us

00:07:43,240 --> 00:07:49,840
enough information to be able to keep

00:07:44,710 --> 00:07:54,370
our index up-to-date so how does this

00:07:49,840 --> 00:07:56,980
fit into our data flow before indexing

00:07:54,370 --> 00:08:00,730
our data our browser application would

00:07:56,980 --> 00:08:02,500
call our graph QL server directly and

00:08:00,730 --> 00:08:03,970
the server would go through the time

00:08:02,500 --> 00:08:10,680
consuming process of calling each one of

00:08:03,970 --> 00:08:13,210
the services after indexing our data our

00:08:10,680 --> 00:08:18,070
server only needs to call the services

00:08:13,210 --> 00:08:26,620
when something changes and it caches the

00:08:18,070 --> 00:08:29,080
results into elasticsearch the browser

00:08:26,620 --> 00:08:38,050
can call our search database directly to

00:08:29,080 --> 00:08:44,460
get like exact rows it it needs and get

00:08:38,050 --> 00:08:44,460
them much faster we can actually

00:08:45,029 --> 00:08:49,690
how abstract away the search database

00:08:47,440 --> 00:08:53,950
from them from the browser completely by

00:08:49,690 --> 00:08:55,420
putting it behind graph queue all using

00:08:53,950 --> 00:08:59,320
this pattern when the browser calls

00:08:55,420 --> 00:09:03,640
carafe queue all and it requests data

00:08:59,320 --> 00:09:05,649
that has already been indexed we can

00:09:03,640 --> 00:09:08,920
provide it with robust search

00:09:05,649 --> 00:09:11,110
functionality if data hasn't been

00:09:08,920 --> 00:09:19,149
indexed it can fall back to calling the

00:09:11,110 --> 00:09:21,510
services directly so this pattern in

00:09:19,149 --> 00:09:23,579
combination of the fact that we can

00:09:21,510 --> 00:09:26,769
automatically keep our search index

00:09:23,579 --> 00:09:29,740
up-to-date basically turn search it into

00:09:26,769 --> 00:09:34,390
a plugin that you can enable on your

00:09:29,740 --> 00:09:38,350
correct Kuehl server with me minimal

00:09:34,390 --> 00:09:39,820
configuration so what kind of

00:09:38,350 --> 00:09:43,390
configuration do we have to do and what

00:09:39,820 --> 00:09:45,730
do we learn from it so the first thing

00:09:43,390 --> 00:09:50,769
you do is connect all our search indexer

00:09:45,730 --> 00:09:54,130
to a graph QL server and that server

00:09:50,769 --> 00:09:56,610
needs to have bi-directional edges this

00:09:54,130 --> 00:10:00,399
means if we build a resolver from the

00:09:56,610 --> 00:10:02,339
creative to the show we also need to

00:10:00,399 --> 00:10:07,149
build one from the show to the creative

00:10:02,339 --> 00:10:08,620
this by directionality allows our search

00:10:07,149 --> 00:10:10,570
and excerpt to find a path from the

00:10:08,620 --> 00:10:15,519
changed vertex to the document it needs

00:10:10,570 --> 00:10:18,579
to be index we also need to listen to

00:10:15,519 --> 00:10:20,019
change events so we use Kafka so we

00:10:18,579 --> 00:10:22,540
built a simple Kafka consumer for these

00:10:20,019 --> 00:10:25,149
and finally we need to connect it to

00:10:22,540 --> 00:10:31,589
some kind of search database and we use

00:10:25,149 --> 00:10:31,589
the elastic search

00:10:34,720 --> 00:10:40,760
so so this whole process wasn't too

00:10:38,510 --> 00:10:43,040
complex and it only took a couple of

00:10:40,760 --> 00:10:45,260
hours to hook everything up but this is

00:10:43,040 --> 00:10:48,740
of course the after we built up our

00:10:45,260 --> 00:10:50,480
search indexer which took several weeks

00:10:48,740 --> 00:10:54,740
but this is a piece of code that can be

00:10:50,480 --> 00:10:58,760
reused by any number of teams regardless

00:10:54,740 --> 00:11:03,140
of what kind of data they have so after

00:10:58,760 --> 00:11:04,280
we set things up how do you tell it to

00:11:03,140 --> 00:11:06,650
index something

00:11:04,280 --> 00:11:16,790
so the first step is youth of defining

00:11:06,650 --> 00:11:19,280
graph QL query and that's it the query

00:11:16,790 --> 00:11:22,130
defines exactly which fields you want to

00:11:19,280 --> 00:11:27,140
index and also gives you the ability to

00:11:22,130 --> 00:11:30,260
pull in data for those fields the

00:11:27,140 --> 00:11:31,700
relationships the inner upper half give

00:11:30,260 --> 00:11:36,350
us enough information to be able to keep

00:11:31,700 --> 00:11:38,840
our index up to date so basically the

00:11:36,350 --> 00:11:45,020
code that we wrote at the beginning of

00:11:38,840 --> 00:11:46,430
this year what was enough for us to keep

00:11:45,020 --> 00:11:48,560
our indices up the deity

00:11:46,430 --> 00:11:52,310
even as our schemas the change or as we

00:11:48,560 --> 00:11:55,550
built like new indices so how about

00:11:52,310 --> 00:11:59,600
performance well let's take a look at

00:11:55,550 --> 00:12:01,430
each of the components for it the change

00:11:59,600 --> 00:12:04,220
events we use Kafka and this has a

00:12:01,430 --> 00:12:07,190
couple milliseconds each time a change

00:12:04,220 --> 00:12:09,410
happens for the fan-out operation we

00:12:07,190 --> 00:12:11,810
need to make a query against our graph

00:12:09,410 --> 00:12:14,180
QL server but this is pretty fast

00:12:11,810 --> 00:12:16,700
because we're only expanding out one

00:12:14,180 --> 00:12:18,200
vertex and because our vertices are

00:12:16,700 --> 00:12:20,750
actually connected by foreign keys

00:12:18,200 --> 00:12:25,580
making them really easy to traverse

00:12:20,750 --> 00:12:26,780
between the search operation is actually

00:12:25,580 --> 00:12:30,190
really fast too

00:12:26,780 --> 00:12:32,810
because we are searching by the vertex

00:12:30,190 --> 00:12:36,850
IDs an elastic search has already built

00:12:32,810 --> 00:12:39,290
up an inverted index on these IDs

00:12:36,850 --> 00:12:41,540
finally the operation to rebuild your

00:12:39,290 --> 00:12:45,550
document could take some time depending

00:12:41,540 --> 00:12:46,660
on how complex your correct QL query is

00:12:45,550 --> 00:12:49,420
but this look shouldn't be too much of

00:12:46,660 --> 00:12:54,450
concern because we're because we're only

00:12:49,420 --> 00:12:57,940
ever rebuilding a small number of the

00:12:54,450 --> 00:13:00,610
documents like at a time after using

00:12:57,940 --> 00:13:03,160
this in production for for about half a

00:13:00,610 --> 00:13:12,430
year we have seen in mixing time so of

00:13:03,160 --> 00:13:14,380
under half a second if you want to learn

00:13:12,430 --> 00:13:15,850
more I'm writing a post next week on a

00:13:14,380 --> 00:13:20,440
Netflix tech blog we've significantly

00:13:15,850 --> 00:13:23,890
more technical details so like in

00:13:20,440 --> 00:13:25,300
conclusion after adopting correct cue

00:13:23,890 --> 00:13:27,220
all to build and maintain you know our

00:13:25,300 --> 00:13:29,560
search index we have been able to

00:13:27,220 --> 00:13:36,089
provide our users with robust search

00:13:29,560 --> 00:13:38,230
functionality and faster page loads we

00:13:36,089 --> 00:13:43,029
didn't have to do too much refactoring

00:13:38,230 --> 00:13:47,019
on the client side because the data came

00:13:43,029 --> 00:13:48,670
back in the exact same shape and best of

00:13:47,019 --> 00:13:51,070
all this was all driven by configuration

00:13:48,670 --> 00:13:55,590
we didn't have to to write like I need

00:13:51,070 --> 00:13:56,940
custom code thank you

00:13:55,590 --> 00:13:58,260
[Applause]

00:13:56,940 --> 00:14:02,240
[Music]

00:13:58,260 --> 00:14:02,240

YouTube URL: https://www.youtube.com/watch?v=04l8eLrGNSw


