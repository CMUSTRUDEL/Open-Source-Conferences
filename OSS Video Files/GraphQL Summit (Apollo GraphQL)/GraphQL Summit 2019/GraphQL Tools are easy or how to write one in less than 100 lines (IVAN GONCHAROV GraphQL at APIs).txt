Title: GraphQL Tools are easy or how to write one in less than 100 lines (IVAN GONCHAROV GraphQL at APIs)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Itâ€™s an exciting time for the GraphQL ecosystem. New tools appear almost every day and you may have a few ideas for your own. But working with queries and the type system looks scary at first. In my talk, I will prove the opposite and demonstrate how you can write a useful tool in 100 lines of code.
Captions: 
	00:00:01,350 --> 00:00:07,180
hi my name is the one and thanks for

00:00:05,500 --> 00:00:11,290
nice introduction so basically I can

00:00:07,180 --> 00:00:13,150
skip first couple White's white from the

00:00:11,290 --> 00:00:16,689
was started from the last month for work

00:00:13,150 --> 00:00:18,130
and graphic Aid Foundation and I want to

00:00:16,689 --> 00:00:21,100
start with stock I only have 15 minutes

00:00:18,130 --> 00:00:23,130
so I will start from the bean from from

00:00:21,100 --> 00:00:26,650
a story from my own personal experience

00:00:23,130 --> 00:00:28,570
back in 2016 I was just learning graph

00:00:26,650 --> 00:00:33,820
GL and decided to do something cool with

00:00:28,570 --> 00:00:36,430
it so together with my friend Roman we

00:00:33,820 --> 00:00:39,760
spend two month working on we stood

00:00:36,430 --> 00:00:42,370
called graph QL Voyager and basically it

00:00:39,760 --> 00:00:45,280
allows you to represent any graphical

00:00:42,370 --> 00:00:47,980
API is interactive graph you can zoom in

00:00:45,280 --> 00:00:51,640
you can select fields and see how

00:00:47,980 --> 00:00:53,350
different types are connected but the

00:00:51,640 --> 00:00:55,780
biggest inside the head from this

00:00:53,350 --> 00:00:58,440
project is how little time we spend on

00:00:55,780 --> 00:01:00,820
figure out graph clear awaited stuff

00:00:58,440 --> 00:01:03,460
compare it with like for example three

00:01:00,820 --> 00:01:05,680
weeks we spent choosing the right Y body

00:01:03,460 --> 00:01:08,110
to draw a graph or like two weeks

00:01:05,680 --> 00:01:11,140
writing reductive all year paid and we

00:01:08,110 --> 00:01:13,120
spent only one week on figure out girly

00:01:11,140 --> 00:01:16,050
stuff and it was our first graphical

00:01:13,120 --> 00:01:18,460
project our first graphical tool so

00:01:16,050 --> 00:01:22,110
initially I just wanted to share with

00:01:18,460 --> 00:01:24,880
experience as a talk in more details and

00:01:22,110 --> 00:01:28,630
initial name for a stock was graphical

00:01:24,880 --> 00:01:29,380
to say easy but you know when you submit

00:01:28,630 --> 00:01:30,850
abstract

00:01:29,380 --> 00:01:33,940
the conference you want to impress

00:01:30,850 --> 00:01:37,150
organizers so yet so you promised stuff

00:01:33,940 --> 00:01:40,380
like writing a useful to an OS 100 twice

00:01:37,150 --> 00:01:46,390
of code so let's start from be useful

00:01:40,380 --> 00:01:49,330
and try to remain try to think what type

00:01:46,390 --> 00:01:53,470
of tools were using in our everyday work

00:01:49,330 --> 00:01:56,740
force and as you can see for LinkedIn

00:01:53,470 --> 00:01:59,140
mocking and profiling

00:01:56,740 --> 00:02:02,100
are already covered by system tools but

00:01:59,140 --> 00:02:06,100
I never saw it too for that matter

00:02:02,100 --> 00:02:08,979
coverage of graphical APs so what do I

00:02:06,100 --> 00:02:11,620
mean by coverage on the Left we have a

00:02:08,979 --> 00:02:13,930
query and on the right we have schema in

00:02:11,620 --> 00:02:17,060
HDL format

00:02:13,930 --> 00:02:20,810
so we can match feels inquiry to fusion

00:02:17,060 --> 00:02:23,920
SDL so for example person from query

00:02:20,810 --> 00:02:28,130
root type or Humboldt from person type a

00:02:23,920 --> 00:02:32,270
resident from planet type and finally

00:02:28,130 --> 00:02:35,000
name from person type as a result only

00:02:32,270 --> 00:02:38,600
fields that were used inside queries

00:02:35,000 --> 00:02:41,360
should be highlighted and now let's hook

00:02:38,600 --> 00:02:45,140
as the entire set up we will write a

00:02:41,360 --> 00:02:48,020
generic proxy server and any graph calc

00:02:45,140 --> 00:02:50,810
one can connect to it for example you

00:02:48,020 --> 00:02:56,750
tested your mobile application or your

00:02:50,810 --> 00:02:59,209
website when client sent query our to

00:02:56,750 --> 00:03:02,240
analyze it infuse in coverage map with

00:02:59,209 --> 00:03:04,910
combination of type name and field name

00:03:02,240 --> 00:03:09,350
for every field that was used inside

00:03:04,910 --> 00:03:11,600
query and then our proxy will simply for

00:03:09,350 --> 00:03:15,110
that request to original server and

00:03:11,600 --> 00:03:18,459
forward response back when concept

00:03:15,110 --> 00:03:21,200
subsequent queries process is repeated

00:03:18,459 --> 00:03:23,540
it's important to note that we are going

00:03:21,200 --> 00:03:27,140
to accommodate coverage info so as a

00:03:23,540 --> 00:03:30,790
result we will get coverage not just for

00:03:27,140 --> 00:03:35,330
single request but for entire session

00:03:30,790 --> 00:03:37,430
so what's builded we will start by

00:03:35,330 --> 00:03:39,380
drafting our implementation so let's

00:03:37,430 --> 00:03:42,350
define a global variable for seven

00:03:39,380 --> 00:03:43,940
coverage info also what's assumed we

00:03:42,350 --> 00:03:46,730
have a function which is called for

00:03:43,940 --> 00:03:49,700
every request and it accept query as an

00:03:46,730 --> 00:03:53,269
argument for simplicity sake let's keep

00:03:49,700 --> 00:03:56,690
boilerplate code of how this function is

00:03:53,269 --> 00:03:58,790
code so our proxy receive a query and

00:03:56,690 --> 00:04:02,330
pass it to the function from previous

00:03:58,790 --> 00:04:05,989
white our first task is to extract all

00:04:02,330 --> 00:04:09,080
field names from query string hopefully

00:04:05,989 --> 00:04:11,060
graph hedges comes with part function it

00:04:09,080 --> 00:04:14,540
accepts query string and the return

00:04:11,060 --> 00:04:19,190
respondent is T on the left you can see

00:04:14,540 --> 00:04:23,020
very simple query and on the right there

00:04:19,190 --> 00:04:26,840
is only part of the correspondent I see

00:04:23,020 --> 00:04:27,530
IC has object for every field as defined

00:04:26,840 --> 00:04:30,860
by can't

00:04:27,530 --> 00:04:34,700
operty and among other things a campaign

00:04:30,860 --> 00:04:38,419
name of a thin field as you see Isis

00:04:34,700 --> 00:04:42,080
very verbose and it may look scary when

00:04:38,419 --> 00:04:44,210
you start working with it but don't

00:04:42,080 --> 00:04:46,720
worry you don't need to manually write

00:04:44,210 --> 00:04:50,060
code to traverse the entire IC and

00:04:46,720 --> 00:04:53,780
extract all field names graph key LJ's

00:04:50,060 --> 00:04:57,080
comes with another handy function called

00:04:53,780 --> 00:04:59,960
visit the code with Isis the first

00:04:57,080 --> 00:05:04,010
argument and object visco but for each

00:04:59,960 --> 00:05:06,740
kind of node we want to visit so here we

00:05:04,010 --> 00:05:09,230
want to be code for a refute our code

00:05:06,740 --> 00:05:12,980
back receive field not and it's super

00:05:09,230 --> 00:05:16,070
easy to extract field names from it but

00:05:12,980 --> 00:05:20,360
what about type and most specifically

00:05:16,070 --> 00:05:22,960
type name as you know we only specify

00:05:20,360 --> 00:05:26,270
field names inside query string and

00:05:22,960 --> 00:05:30,470
graphical several figures out much in

00:05:26,270 --> 00:05:33,020
types during execution so inside the

00:05:30,470 --> 00:05:36,800
query we don't have type names so I see

00:05:33,020 --> 00:05:39,820
obviously doesn't have it either so how

00:05:36,800 --> 00:05:42,530
how do we get type name here

00:05:39,820 --> 00:05:45,320
graphed here has introspection mechanism

00:05:42,530 --> 00:05:47,600
which is similar to refraction method is

00:05:45,320 --> 00:05:50,300
some programming languages you can send

00:05:47,600 --> 00:05:53,180
special query starting with underscore

00:05:50,300 --> 00:05:55,760
underscore schema field and you will

00:05:53,180 --> 00:05:58,039
receive the complete information about

00:05:55,760 --> 00:06:01,850
zero type system which will help us to

00:05:58,039 --> 00:06:04,130
much field to their respective types so

00:06:01,850 --> 00:06:06,229
we need to send an inspection query to

00:06:04,130 --> 00:06:10,760
original server before starting our

00:06:06,229 --> 00:06:14,240
proxy but we even don't have to write it

00:06:10,760 --> 00:06:17,539
graph changes exports it as a constant

00:06:14,240 --> 00:06:19,430
once we get response we pass it to build

00:06:17,539 --> 00:06:22,180
coin schema which transform

00:06:19,430 --> 00:06:27,080
introspection is a special schema object

00:06:22,180 --> 00:06:30,100
then we pass it to our run server so now

00:06:27,080 --> 00:06:33,590
on request function get with schema

00:06:30,100 --> 00:06:36,530
object s1 argument one more argument

00:06:33,590 --> 00:06:40,190
let's make our visitor callback aware

00:06:36,530 --> 00:06:41,360
for this we can use visit with type in

00:06:40,190 --> 00:06:43,909
for wrapper

00:06:41,360 --> 00:06:47,000
which accept special type infrastructure

00:06:43,909 --> 00:06:49,699
as first argument which in turn we build

00:06:47,000 --> 00:06:54,740
out of schema and this is the most

00:06:49,699 --> 00:06:59,080
complex part of our tool then we finally

00:06:54,740 --> 00:07:03,289
can get type name using get parent type

00:06:59,080 --> 00:07:07,189
method on type info and this is the last

00:07:03,289 --> 00:07:09,889
step we just combine field name with

00:07:07,189 --> 00:07:14,090
type name and save it to our coverage

00:07:09,889 --> 00:07:17,210
map and that's it on with white you can

00:07:14,090 --> 00:07:20,150
see the code we just wrote but as I

00:07:17,210 --> 00:07:23,210
mentioned earlier we need some extra

00:07:20,150 --> 00:07:26,360
stuff white is setting up graphical

00:07:23,210 --> 00:07:29,840
server and doing error handling and

00:07:26,360 --> 00:07:32,060
printing some output to the console so

00:07:29,840 --> 00:07:37,189
actual code is bigger but I still

00:07:32,060 --> 00:07:41,330
managed to fit it into 50 wines so as

00:07:37,189 --> 00:07:44,060
you have a 49 lines of code left and

00:07:41,330 --> 00:07:47,000
what's here and what's paint them to

00:07:44,060 --> 00:07:50,960
represent coverage on a graph not as

00:07:47,000 --> 00:07:54,770
boring HDL but using graphical Voyager I

00:07:50,960 --> 00:07:57,949
showed you before here's a complete

00:07:54,770 --> 00:07:59,990
program listing and it fits it's less

00:07:57,949 --> 00:08:04,219
than hundred wines with everything with

00:07:59,990 --> 00:08:06,289
HTML Javascript and CSS so it's demo

00:08:04,219 --> 00:08:11,659
time but a slight need talk so I

00:08:06,289 --> 00:08:14,889
pre-recorded the div so we start by

00:08:11,659 --> 00:08:18,349
running with two and specifying our

00:08:14,889 --> 00:08:20,449
original graphical server and you have

00:08:18,349 --> 00:08:23,719
to link so one is to graph kill Roger

00:08:20,449 --> 00:08:25,639
and right now it's like just simple

00:08:23,719 --> 00:08:27,800
watcher everything is white all fused

00:08:25,639 --> 00:08:30,110
white and we focus on the person type

00:08:27,800 --> 00:08:32,449
and we run acquire II and we Squire ask

00:08:30,110 --> 00:08:36,229
for name a birthday and name a birthday

00:08:32,449 --> 00:08:39,890
became green when we add one more field

00:08:36,229 --> 00:08:42,289
I Corr and I Corr become green and when

00:08:39,890 --> 00:08:45,170
we do something more complex we ask for

00:08:42,289 --> 00:08:48,800
connected type pointer type and ask for

00:08:45,170 --> 00:08:51,649
name geometry and gravity and home will

00:08:48,800 --> 00:08:54,400
become green but also named Janet and

00:08:51,649 --> 00:09:06,530
gravity became green

00:08:54,400 --> 00:09:11,240
yeah yeah it's pretty cordage if but I

00:09:06,530 --> 00:09:14,170
publish yeah but yeah like some people

00:09:11,240 --> 00:09:17,240
do wife coding on the stage I'm like

00:09:14,170 --> 00:09:21,290
don't even throw in but periodic but I

00:09:17,240 --> 00:09:23,330
sure the source code on github and you

00:09:21,290 --> 00:09:26,570
can also install it as an paint package

00:09:23,330 --> 00:09:28,970
and to run it just like type graphical

00:09:26,570 --> 00:09:32,390
coverage and your router a server and

00:09:28,970 --> 00:09:38,210
you will get two links to one to Voyager

00:09:32,390 --> 00:09:39,440
and another to graphical and in Auto we

00:09:38,210 --> 00:09:43,520
use only a couple things

00:09:39,440 --> 00:09:45,230
export exported by graph changes but the

00:09:43,520 --> 00:09:48,280
same as from writing hundreds if not

00:09:45,230 --> 00:09:51,710
thousands wise wines of code ourselves

00:09:48,280 --> 00:09:54,950
so here is like in the J's file of

00:09:51,710 --> 00:09:57,910
graphical J's so you can see we only

00:09:54,950 --> 00:10:02,060
scratched the surface of his why barrier

00:09:57,910 --> 00:10:04,730
and if you count it it exports 156

00:10:02,060 --> 00:10:09,950
functions thirteen classes twenty-nine

00:10:04,730 --> 00:10:13,130
concert and 159th type definition info

00:10:09,950 --> 00:10:15,620
in typescript so it's not only a

00:10:13,130 --> 00:10:17,900
reference implementation of graph GL but

00:10:15,620 --> 00:10:20,540
also a huge set of reusable component

00:10:17,900 --> 00:10:24,440
for graphical to link and the same is

00:10:20,540 --> 00:10:26,630
true for most of as a graphical

00:10:24,440 --> 00:10:29,120
implementation in other languages they

00:10:26,630 --> 00:10:32,300
also export path parts functional the

00:10:29,120 --> 00:10:35,510
also expose Bitcoin schema and other

00:10:32,300 --> 00:10:38,840
functions so here is the main point of

00:10:35,510 --> 00:10:41,990
entire talk graphical tooling is easy to

00:10:38,840 --> 00:10:45,020
write and it's explained why we have

00:10:41,990 --> 00:10:47,150
such great system around graphical and

00:10:45,020 --> 00:10:50,600
new tools are released on weekly basis

00:10:47,150 --> 00:10:53,120
but if for some reason you don't find

00:10:50,600 --> 00:10:55,310
the right tool for a job you can always

00:10:53,120 --> 00:10:58,670
create your own even if it takes you

00:10:55,310 --> 00:10:59,270
more than hundred lines of code thank

00:10:58,670 --> 00:11:03,190
you

00:10:59,270 --> 00:11:03,190

YouTube URL: https://www.youtube.com/watch?v=sq7Sz1W21ek


