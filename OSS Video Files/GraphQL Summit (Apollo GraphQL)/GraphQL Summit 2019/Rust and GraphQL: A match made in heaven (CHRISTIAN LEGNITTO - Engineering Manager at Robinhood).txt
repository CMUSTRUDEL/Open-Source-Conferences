Title: Rust and GraphQL: A match made in heaven (CHRISTIAN LEGNITTO - Engineering Manager at Robinhood)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	Rust = awesome. GraphQL = awesome. GraphQL + Rust = 2awesome. Rust has some unique features that make it ideally suited for building GraphQL clients and servers. Learn why you should rewrite (mostly) everything in Rust!
Captions: 
	00:00:01,779 --> 00:00:08,269
thank you thank you very much for having

00:00:06,140 --> 00:00:10,730
me I'm super stoked to be here at the

00:00:08,269 --> 00:00:13,610
graph QL summit Thank You Apollo for

00:00:10,730 --> 00:00:16,219
inviting me yes I'm going to be talking

00:00:13,610 --> 00:00:19,220
about graph QL and rust I think it's a

00:00:16,219 --> 00:00:21,410
match made in heaven to be clear this is

00:00:19,220 --> 00:00:23,600
rust the programming language not the

00:00:21,410 --> 00:00:25,460
video game so I know people get that

00:00:23,600 --> 00:00:28,820
confused sometimes

00:00:25,460 --> 00:00:30,650
but yeah first a little bit about me I'm

00:00:28,820 --> 00:00:32,719
an engineering manager at Robin Hood I

00:00:30,650 --> 00:00:35,120
manage our business automation teams so

00:00:32,719 --> 00:00:37,280
what we do is try to automate humans and

00:00:35,120 --> 00:00:40,280
machines to make it so robin hood isn't

00:00:37,280 --> 00:00:43,429
this big brokerage with a ton of humans

00:00:40,280 --> 00:00:45,050
faxing things back and forth but before

00:00:43,429 --> 00:00:47,120
that I was actually retired surfing

00:00:45,050 --> 00:00:48,679
around for three years and picked up

00:00:47,120 --> 00:00:51,319
rust on the side because I've been

00:00:48,679 --> 00:00:53,809
managing for a while and kind of missed

00:00:51,319 --> 00:00:54,920
programming and rust seemed like a good

00:00:53,809 --> 00:00:58,429
thing to learn I'll be talking about

00:00:54,920 --> 00:01:04,250
that before that was at Facebook Mozilla

00:00:58,429 --> 00:01:06,320
and Apple I really love graph QL and I

00:01:04,250 --> 00:01:10,750
really love rust so apologies if this

00:01:06,320 --> 00:01:13,700
comes off as like a rust fanboy I

00:01:10,750 --> 00:01:15,410
maintain juniper which is the rust oh

00:01:13,700 --> 00:01:20,140
this is not going forward sorry about

00:01:15,410 --> 00:01:20,140
this let me fix my slides

00:01:25,890 --> 00:01:31,570
area

00:01:27,130 --> 00:01:34,390
sorry about that so I maintained juniper

00:01:31,570 --> 00:01:39,160
this is a rust server-side graph QL

00:01:34,390 --> 00:01:41,110
library my other claim to fame with

00:01:39,160 --> 00:01:43,360
graph QL is I was in the room when graph

00:01:41,110 --> 00:01:44,680
QL was invented at Facebook which is

00:01:43,360 --> 00:01:47,140
pretty exciting I was part of the team

00:01:44,680 --> 00:01:50,560
that rewrote our mobile apps and kind of

00:01:47,140 --> 00:01:53,830
got our act together on mobile but I had

00:01:50,560 --> 00:01:57,910
nothing to do with it so I take no

00:01:53,830 --> 00:02:00,160
credit with graph QL whatsoever I also

00:01:57,910 --> 00:02:01,960
work at Robin Hood with Lee Byron who is

00:02:00,160 --> 00:02:03,820
the co-creator of graph QL and he is

00:02:01,960 --> 00:02:05,950
gracing us with his presence right here

00:02:03,820 --> 00:02:08,170
in the front row supporting me so thanks

00:02:05,950 --> 00:02:11,590
Lee I believe he's also the head of the

00:02:08,170 --> 00:02:14,410
graph QL foundation is that true yes

00:02:11,590 --> 00:02:16,600
so there's a lot of graphical stuff in

00:02:14,410 --> 00:02:18,730
my world and you could too we're hiring

00:02:16,600 --> 00:02:23,370
as a manager I think I'm legally

00:02:18,730 --> 00:02:27,550
obligated to say this ok so what is rust

00:02:23,370 --> 00:02:29,530
so on the website the rust language team

00:02:27,550 --> 00:02:32,260
says it is a language empowering

00:02:29,530 --> 00:02:34,630
everyone to build reliable and efficient

00:02:32,260 --> 00:02:36,310
software and that sounds really great to

00:02:34,630 --> 00:02:39,120
me because I like reliable and not like

00:02:36,310 --> 00:02:43,239
efficient software hopefully you do too

00:02:39,120 --> 00:02:44,470
but why would you use rust the first

00:02:43,239 --> 00:02:47,230
thing I think that's really compelling

00:02:44,470 --> 00:02:50,320
to me is performance so rust is just

00:02:47,230 --> 00:02:53,530
ridiculously blazingly fast and memory

00:02:50,320 --> 00:02:55,330
efficient it has no runtime and no

00:02:53,530 --> 00:02:56,380
garbage collector so when you're putting

00:02:55,330 --> 00:02:58,450
rust in production

00:02:56,380 --> 00:03:00,190
you're not tweaking a garbage collector

00:02:58,450 --> 00:03:03,370
you're not doing a bunch of that sort of

00:03:00,190 --> 00:03:07,420
stuff you're not dealing with runtime

00:03:03,370 --> 00:03:09,520
abstractions that are high cost you only

00:03:07,420 --> 00:03:12,250
pay for the abstractions that you use

00:03:09,520 --> 00:03:14,530
so generally rust is going to be as fast

00:03:12,250 --> 00:03:16,420
as like C or C++ and it has some

00:03:14,530 --> 00:03:18,100
additional nice features on top of it I

00:03:16,420 --> 00:03:21,430
don't know about you but I don't trust

00:03:18,100 --> 00:03:26,130
myself to write C or C++ period let

00:03:21,430 --> 00:03:26,130
alone accepting stuff from the internet

00:03:26,810 --> 00:03:29,510
I don't know if folks have seen this

00:03:28,340 --> 00:03:32,480
before this is the tech and power

00:03:29,510 --> 00:03:34,250
benchmarks they may be true that maybe

00:03:32,480 --> 00:03:36,890
not true benchmarks are always taken

00:03:34,250 --> 00:03:39,620
with a giant grain of salt but for most

00:03:36,890 --> 00:03:42,739
of these rust is in the top five if not

00:03:39,620 --> 00:03:46,010
the top one and this particular one

00:03:42,739 --> 00:03:49,550
these two purple bars on the top are two

00:03:46,010 --> 00:03:51,980
different rust frameworks and you can

00:03:49,550 --> 00:03:53,540
see there's a lot going on in these

00:03:51,980 --> 00:03:54,319
slides but these are this is the

00:03:53,540 --> 00:03:56,510
languages

00:03:54,319 --> 00:03:58,700
the top two are rust and the sea and

00:03:56,510 --> 00:04:03,410
there's go and Java and C++ code Java

00:03:58,700 --> 00:04:06,290
C++ and so in production on the server

00:04:03,410 --> 00:04:08,060
side people are often seen rust be ten

00:04:06,290 --> 00:04:11,200
or a hundred times faster than

00:04:08,060 --> 00:04:15,410
comparable code written in node or

00:04:11,200 --> 00:04:17,120
Python or Ruby or and of course the gap

00:04:15,410 --> 00:04:20,540
is smaller verse first of things like

00:04:17,120 --> 00:04:22,760
Java or go and things like that so it is

00:04:20,540 --> 00:04:24,410
not absurd to write something Russ and

00:04:22,760 --> 00:04:26,240
the first time it is much faster than

00:04:24,410 --> 00:04:28,790
you could ever imagine in your normal

00:04:26,240 --> 00:04:31,820
language and to me that just blows my

00:04:28,790 --> 00:04:34,729
mind quite honestly because there's no

00:04:31,820 --> 00:04:37,820
garbage collection because memory is

00:04:34,729 --> 00:04:43,370
manually managed typically rust also

00:04:37,820 --> 00:04:44,360
uses one to ten times less memory so

00:04:43,370 --> 00:04:47,270
even if you're doing something that's

00:04:44,360 --> 00:04:51,050
CPU gham that maybe when the Java JIT

00:04:47,270 --> 00:04:53,690
kicks in and and it's one for one and

00:04:51,050 --> 00:04:56,060
speed usually rusts memory is a lot

00:04:53,690 --> 00:04:57,650
lower and as the industry moves to

00:04:56,060 --> 00:04:59,720
things like server lists this becomes

00:04:57,650 --> 00:05:01,520
more and more important you need things

00:04:59,720 --> 00:05:04,190
to be fast and you have memory overhead

00:05:01,520 --> 00:05:08,539
and you'll obviously want to use eschews

00:05:04,190 --> 00:05:11,440
resources as possible so that's okay

00:05:08,539 --> 00:05:14,780
like sees that fast C++ is that fast

00:05:11,440 --> 00:05:18,680
other language are what is an benefit of

00:05:14,780 --> 00:05:20,630
rust over those I rest also is reliable

00:05:18,680 --> 00:05:22,520
so it has a type system that prevents

00:05:20,630 --> 00:05:26,060
bugs the type system is very similar to

00:05:22,520 --> 00:05:28,070
typescript if you've used it generics

00:05:26,060 --> 00:05:29,720
all these sorts of stuff it guarantees

00:05:28,070 --> 00:05:34,760
memory safety and thread safety

00:05:29,720 --> 00:05:37,610
so going multiple threads distributing

00:05:34,760 --> 00:05:39,319
computation is pretty safe in rust in

00:05:37,610 --> 00:05:41,270
C++ I don't know about you

00:05:39,319 --> 00:05:44,619
but I would not trust myself to do

00:05:41,270 --> 00:05:47,629
threads and memory stuff in the C++ just

00:05:44,619 --> 00:05:49,460
just asking for security bugs asking for

00:05:47,629 --> 00:05:51,349
crashes and things like that and and

00:05:49,460 --> 00:05:54,199
rust gives you some tools to make that a

00:05:51,349 --> 00:05:56,149
lot more safe variables are immutable by

00:05:54,199 --> 00:05:58,610
default if you've ever used immutable

00:05:56,149 --> 00:06:00,289
dot J s and JavaScript you kind of know

00:05:58,610 --> 00:06:02,659
the benefits of that this is another

00:06:00,289 --> 00:06:04,909
foot gun rust takes away from you and

00:06:02,659 --> 00:06:06,889
kind of does best practices by default

00:06:04,909 --> 00:06:08,779
in the language and one of the things I

00:06:06,889 --> 00:06:12,439
really like is rust makes air handling

00:06:08,779 --> 00:06:14,809
explicit you have to handle the case or

00:06:12,439 --> 00:06:17,119
you have to explicitly say I do not care

00:06:14,809 --> 00:06:19,819
about these air cases so in other

00:06:17,119 --> 00:06:22,279
languages for example if you get a path

00:06:19,819 --> 00:06:25,069
back from the operating system a path is

00:06:22,279 --> 00:06:27,770
just a string right well strings can be

00:06:25,069 --> 00:06:29,539
encoded in different ways and on some

00:06:27,770 --> 00:06:31,399
operating systems like Windows you can

00:06:29,539 --> 00:06:33,619
have different character sets that maybe

00:06:31,399 --> 00:06:38,089
don't map to Russ Natives string type

00:06:33,619 --> 00:06:41,119
for 99.9999% of the people we don't care

00:06:38,089 --> 00:06:41,569
about that but that point 1% may care

00:06:41,119 --> 00:06:44,509
about it

00:06:41,569 --> 00:06:46,069
so in rust you explicitly have to say do

00:06:44,509 --> 00:06:48,439
I care about this case if not just

00:06:46,069 --> 00:06:50,240
soldier on if I do care about this case

00:06:48,439 --> 00:06:52,279
handle the error but you have to

00:06:50,240 --> 00:06:56,149
cognitively do it the system just

00:06:52,279 --> 00:06:57,469
doesn't handle it for you and then for

00:06:56,149 --> 00:07:01,399
me it's really important that rust is

00:06:57,469 --> 00:07:03,469
practical and they're Mozilla created

00:07:01,399 --> 00:07:04,789
rust because they had a practical need

00:07:03,469 --> 00:07:06,319
and they want to put in production it's

00:07:04,789 --> 00:07:08,389
not some research language that's in

00:07:06,319 --> 00:07:11,269
ivory tower research it is made to

00:07:08,389 --> 00:07:13,490
integrate with the real world and other

00:07:11,269 --> 00:07:15,610
languages that may not be the case so

00:07:13,490 --> 00:07:17,809
one I think is really nice about rust

00:07:15,610 --> 00:07:19,430
similarly with go it has single binary

00:07:17,809 --> 00:07:21,740
deployments you don't need to bring a

00:07:19,430 --> 00:07:22,309
JVM you don't have to bundle and all

00:07:21,740 --> 00:07:23,899
this sort of stuff

00:07:22,309 --> 00:07:26,680
you build a binary and you can put it in

00:07:23,899 --> 00:07:29,389
docker and things like that and run it

00:07:26,680 --> 00:07:31,399
another thing I love about rust is rust

00:07:29,389 --> 00:07:33,769
can act like C to integrate with other

00:07:31,399 --> 00:07:36,349
languages so almost every language has

00:07:33,769 --> 00:07:39,529
to in talk to C have some extension

00:07:36,349 --> 00:07:41,569
point in Python numpy a lot of the stuff

00:07:39,529 --> 00:07:44,959
underneath is written in C to make it

00:07:41,569 --> 00:07:46,550
fast very often in nodejs let's say

00:07:44,959 --> 00:07:49,370
you're doing image resizing you're using

00:07:46,550 --> 00:07:52,039
the very popular sharp NPM package

00:07:49,370 --> 00:07:52,439
that's actually implemented in C++ under

00:07:52,039 --> 00:07:58,409
the hood

00:07:52,439 --> 00:07:59,909
and so node Python the JVM all these

00:07:58,409 --> 00:08:03,479
other languages usually have an

00:07:59,909 --> 00:08:05,909
interface to include C code and call it

00:08:03,479 --> 00:08:08,550
and call back and forth and because Russ

00:08:05,909 --> 00:08:11,279
can act like C you can write a high

00:08:08,550 --> 00:08:12,809
quality library in rust and bring it to

00:08:11,279 --> 00:08:14,669
your existing service written another

00:08:12,809 --> 00:08:17,249
language and get the benefits of the

00:08:14,669 --> 00:08:18,719
rust in that very small language domain

00:08:17,249 --> 00:08:22,649
you don't have to rewrite the world and

00:08:18,719 --> 00:08:24,269
that's very practical and I think it's

00:08:22,649 --> 00:08:26,399
very hard to get adoption for a language

00:08:24,269 --> 00:08:29,519
even if it's 10 times better if you have

00:08:26,399 --> 00:08:31,949
a ton of code already existing so this

00:08:29,519 --> 00:08:33,300
is critical for Russ actually being used

00:08:31,949 --> 00:08:36,569
and we're seeing it being used more and

00:08:33,300 --> 00:08:38,399
more and for me I'm lazy when I was

00:08:36,569 --> 00:08:41,759
surfing in Mexico and waiting for good

00:08:38,399 --> 00:08:44,850
waves um you know I thought about what I

00:08:41,759 --> 00:08:46,800
wanted to learn and Russ kind of ran

00:08:44,850 --> 00:08:49,410
everywhere it runs on Windows it runs on

00:08:46,800 --> 00:08:51,089
Linux runs on iOS it runs on Android you

00:08:49,410 --> 00:08:53,250
can even compile it for the web and run

00:08:51,089 --> 00:08:55,589
it in the browser via web assembly and

00:08:53,250 --> 00:08:56,910
this seems pretty cool that potentially

00:08:55,589 --> 00:08:59,279
down the road you can learn one language

00:08:56,910 --> 00:09:00,990
and regardless of where you're working

00:08:59,279 --> 00:09:03,209
or what problem domain you're working in

00:09:00,990 --> 00:09:06,959
your skills might actually be relevant

00:09:03,209 --> 00:09:08,639
and help and something I think is really

00:09:06,959 --> 00:09:11,189
important is the Russ community is

00:09:08,639 --> 00:09:13,470
welcoming it has a great community has a

00:09:11,189 --> 00:09:16,230
code of conduct that people adhere to

00:09:13,470 --> 00:09:18,930
the documentation is amazing and human

00:09:16,230 --> 00:09:21,449
friendly a lot of the rust core

00:09:18,930 --> 00:09:23,100
developers are hard core C++ people who

00:09:21,449 --> 00:09:26,130
have worked on Firefox worked at

00:09:23,100 --> 00:09:29,160
Facebook worked at Google and the C++

00:09:26,130 --> 00:09:31,199
community does some amazing things but

00:09:29,160 --> 00:09:32,730
they're also kind of like oh if you have

00:09:31,199 --> 00:09:34,889
that bug that just means you're not a

00:09:32,730 --> 00:09:38,160
good C++ programmer and there's this

00:09:34,889 --> 00:09:39,240
kind of gatekeeping and rust is like we

00:09:38,160 --> 00:09:41,399
know we're not good

00:09:39,240 --> 00:09:42,689
we know the compilers are good like

00:09:41,399 --> 00:09:43,829
let's trust in the machines and we're

00:09:42,689 --> 00:09:45,059
all just kind of trying to figure it out

00:09:43,829 --> 00:09:47,970
so there's not a chip on people's

00:09:45,059 --> 00:09:49,769
shoulders the compiler errors are very

00:09:47,970 --> 00:09:53,100
useful and very informative very similar

00:09:49,769 --> 00:09:54,839
to Elm if you've ever used Elm and rust

00:09:53,100 --> 00:09:57,689
encourages open source contributions so

00:09:54,839 --> 00:10:02,459
all the rest language stuff is in github

00:09:57,689 --> 00:10:04,540
in PRS all the organizational changes

00:10:02,459 --> 00:10:05,830
happen in the open so

00:10:04,540 --> 00:10:07,330
that's really cool that you as a

00:10:05,830 --> 00:10:09,130
community member are on the same footing

00:10:07,330 --> 00:10:10,900
as people maybe at Mozilla or other

00:10:09,130 --> 00:10:16,690
companies that are heavily involved and

00:10:10,900 --> 00:10:18,340
you trust wears rust use I don't need to

00:10:16,690 --> 00:10:20,290
pontificate about how much I like it or

00:10:18,340 --> 00:10:21,370
don't need to do quotes I think the

00:10:20,290 --> 00:10:23,620
proof is in the pudding of people

00:10:21,370 --> 00:10:25,780
actually using rust so large parts of

00:10:23,620 --> 00:10:30,010
Firefox are written in rust this is why

00:10:25,780 --> 00:10:32,410
it was designed as a language and AWS is

00:10:30,010 --> 00:10:35,100
lambda VM rust so if you're running code

00:10:32,410 --> 00:10:37,780
on lambda it's running on top of rust

00:10:35,100 --> 00:10:39,400
face mercurial server all server which

00:10:37,780 --> 00:10:43,030
is critical right that goes down if that

00:10:39,400 --> 00:10:45,130
has correctness bugs like game over

00:10:43,030 --> 00:10:46,630
then you libros stuff cloud fair chrome

00:10:45,130 --> 00:10:49,350
OS so rust is starting to creep in

00:10:46,630 --> 00:10:52,060
everywhere where speed correctness and

00:10:49,350 --> 00:10:55,470
safety is necessary and I would argue

00:10:52,060 --> 00:10:58,120
you want those three things all the time

00:10:55,470 --> 00:11:01,030
okay so why not rest steep learning

00:10:58,120 --> 00:11:02,740
curve not gonna lie I'm not I don't

00:11:01,030 --> 00:11:05,070
assistant program background and it was

00:11:02,740 --> 00:11:07,810
pretty steep for me very small ecosystem

00:11:05,070 --> 00:11:10,630
frequently you will try to do something

00:11:07,810 --> 00:11:12,190
a library will not be there but when it

00:11:10,630 --> 00:11:14,350
is there is generally high quality and

00:11:12,190 --> 00:11:16,150
then long compile times it's a compiled

00:11:14,350 --> 00:11:18,370
time language it's not as fast as go

00:11:16,150 --> 00:11:20,380
when you compile it and that's a huge

00:11:18,370 --> 00:11:22,810
bummer when you're writing so I think

00:11:20,380 --> 00:11:26,290
those are the biggest three okay that

00:11:22,810 --> 00:11:27,700
was enough rust evangelizing I think

00:11:26,290 --> 00:11:31,140
it's compelling you may not but I think

00:11:27,700 --> 00:11:33,400
with graph QL and rust it is materially

00:11:31,140 --> 00:11:35,110
compelling so I'm gonna talk about those

00:11:33,400 --> 00:11:36,400
interactions and we'll just basically be

00:11:35,110 --> 00:11:40,420
stepping through code for the most of

00:11:36,400 --> 00:11:42,100
time we'll see how we do on time so like

00:11:40,420 --> 00:11:43,960
I said I maintain the raspy rust graph

00:11:42,100 --> 00:11:45,700
geoserver library juniper so you can

00:11:43,960 --> 00:11:46,900
grab my slides and click there later all

00:11:45,700 --> 00:11:49,870
these examples are gonna be using

00:11:46,900 --> 00:11:53,110
juniper can you see this okay yeah okay

00:11:49,870 --> 00:11:54,730
so on the left is the graphical schema

00:11:53,110 --> 00:11:57,400
we're going to be doing and on the right

00:11:54,730 --> 00:11:59,230
is rust so hopefully you folks are

00:11:57,400 --> 00:12:02,380
familiar with graph QL this is us

00:11:59,230 --> 00:12:05,050
defining a person object and some fields

00:12:02,380 --> 00:12:07,480
emails a string that's non null wool age

00:12:05,050 --> 00:12:08,740
is an int that's not malleable how do we

00:12:07,480 --> 00:12:13,480
do that in rust it looks basically

00:12:08,740 --> 00:12:17,050
exactly the same way so Russ objects are

00:12:13,480 --> 00:12:17,870
called structs we say it's a person says

00:12:17,050 --> 00:12:20,720
email say

00:12:17,870 --> 00:12:23,300
a string and probably I should have done

00:12:20,720 --> 00:12:25,130
it unsigned int here again Russ is a bit

00:12:23,300 --> 00:12:27,260
low level so you can't just say int or

00:12:25,130 --> 00:12:29,750
number you have to actually say the size

00:12:27,260 --> 00:12:31,130
of what you're doing but that's just

00:12:29,750 --> 00:12:33,710
pure rust there's nothing graphic you

00:12:31,130 --> 00:12:35,360
all about that how do we how do we like

00:12:33,710 --> 00:12:38,750
convert it to this graph TL schema how

00:12:35,360 --> 00:12:42,200
do we make it graph you all aware which

00:12:38,750 --> 00:12:43,730
unit per is is all you need to do it's

00:12:42,200 --> 00:12:46,580
basically just a simple annotation

00:12:43,730 --> 00:12:49,040
that's like derived graph QL object and

00:12:46,580 --> 00:12:51,140
that attaches all the graph QL machinery

00:12:49,040 --> 00:12:54,140
on this particular object on this

00:12:51,140 --> 00:12:58,310
particular struct so when you query for

00:12:54,140 --> 00:13:01,580
person email it will use the the

00:12:58,310 --> 00:13:03,260
attribute in that object pretty

00:13:01,580 --> 00:13:04,670
straightforward now let's say we have

00:13:03,260 --> 00:13:06,350
something like password hash that we

00:13:04,670 --> 00:13:10,160
don't want our clients to be able to

00:13:06,350 --> 00:13:13,160
query juniper has a way to say skip it

00:13:10,160 --> 00:13:14,660
so this is very intuitive very quick not

00:13:13,160 --> 00:13:17,600
a ton of boilerplate just really get to

00:13:14,660 --> 00:13:19,580
to the point and this is not a DSL this

00:13:17,600 --> 00:13:23,240
is just standard rust these attributes

00:13:19,580 --> 00:13:24,589
and all the stuff is standard rust okay

00:13:23,240 --> 00:13:26,450
but you just can't just have an object

00:13:24,589 --> 00:13:27,800
you have to hold whole schema in order

00:13:26,450 --> 00:13:30,490
to create it so let's walk through a

00:13:27,800 --> 00:13:32,690
schema and graph QL and a schema in rust

00:13:30,490 --> 00:13:35,660
so we have our personal object from the

00:13:32,690 --> 00:13:38,720
previous slide we have to have a top

00:13:35,660 --> 00:13:40,339
level query so let's do this we're gonna

00:13:38,720 --> 00:13:45,860
have everyone field and that's gonna

00:13:40,339 --> 00:13:47,390
have a list of persons and in Gretton

00:13:45,860 --> 00:13:48,680
rust it's basically exactly the same the

00:13:47,390 --> 00:13:51,740
query is just an object it's one of the

00:13:48,680 --> 00:13:53,779
nice things about graph QL so in rust it

00:13:51,740 --> 00:13:56,209
does have a raise but they're they're

00:13:53,779 --> 00:13:57,980
kind of wonky so you come out this is a

00:13:56,209 --> 00:14:01,910
vector which is basically just like an

00:13:57,980 --> 00:14:03,620
array that can go big in small and you

00:14:01,910 --> 00:14:07,459
can see in this slide rust has generics

00:14:03,620 --> 00:14:10,160
so vector is a container and the type in

00:14:07,459 --> 00:14:12,170
the vector is a person very similar to

00:14:10,160 --> 00:14:15,260
typescript and and other languages of

00:14:12,170 --> 00:14:16,970
generics in this particular example we

00:14:15,260 --> 00:14:19,339
do not have a mutation so that's just an

00:14:16,970 --> 00:14:22,040
empty object in graph QL in rust we have

00:14:19,339 --> 00:14:23,300
a nice type thing that you can say this

00:14:22,040 --> 00:14:25,130
is empty to make sure you don't

00:14:23,300 --> 00:14:25,520
accidentally add fields or stuff on to

00:14:25,130 --> 00:14:28,220
it

00:14:25,520 --> 00:14:29,870
and then you take the query the quick

00:14:28,220 --> 00:14:32,420
take the mutation put them together and

00:14:29,870 --> 00:14:35,000
that's your schema and that's how you do

00:14:32,420 --> 00:14:36,680
it and rust with juniper so very

00:14:35,000 --> 00:14:39,380
straightforward looks very similar to

00:14:36,680 --> 00:14:41,899
the graphical schema and it's pretty

00:14:39,380 --> 00:14:44,390
insane that this is all you need to do

00:14:41,899 --> 00:14:46,279
that this is a low-level system language

00:14:44,390 --> 00:14:47,990
supposedly and this looks very

00:14:46,279 --> 00:14:54,050
high-level and almost like Python and

00:14:47,990 --> 00:14:55,220
very similar to draft you all but that's

00:14:54,050 --> 00:14:56,140
not telling us too much the graphical

00:14:55,220 --> 00:14:58,010
has this great feature called

00:14:56,140 --> 00:14:59,410
descriptions I hope people know of

00:14:58,010 --> 00:15:02,330
because everything in graph QL is

00:14:59,410 --> 00:15:04,790
introspective you know you want to say

00:15:02,330 --> 00:15:06,200
what is the email what is age maybe

00:15:04,790 --> 00:15:07,670
they're straightforward here but but it

00:15:06,200 --> 00:15:09,200
might change in the future so in graph

00:15:07,670 --> 00:15:11,180
QL you can do this with string literals

00:15:09,200 --> 00:15:12,620
on the left you can say Oh a person in

00:15:11,180 --> 00:15:14,480
our system this is the email they used

00:15:12,620 --> 00:15:18,320
to register and the self-reported age

00:15:14,480 --> 00:15:19,940
how you do that in rust are comments so

00:15:18,320 --> 00:15:22,070
rust has multiple types of con up

00:15:19,940 --> 00:15:23,930
comments the first one is just your

00:15:22,070 --> 00:15:27,560
standard two slashes that's just like a

00:15:23,930 --> 00:15:30,020
normal comment but three slashes are

00:15:27,560 --> 00:15:33,560
duck comments so you may be familiar

00:15:30,020 --> 00:15:35,120
with these from Java and things of that

00:15:33,560 --> 00:15:38,899
nature this is built into the rust

00:15:35,120 --> 00:15:41,209
language so anyone not familiar with

00:15:38,899 --> 00:15:42,620
graph QL not familiar anyone familiar

00:15:41,209 --> 00:15:44,410
with rust would know exactly what that

00:15:42,620 --> 00:15:46,670
is and would know intuitively how to add

00:15:44,410 --> 00:15:49,779
comments which would then show up in

00:15:46,670 --> 00:15:49,779
your graph QL schema

00:15:50,029 --> 00:15:55,250
this is a good time to introduce cargo

00:15:51,800 --> 00:15:56,930
so cargo is like NPM but better for rust

00:15:55,250 --> 00:15:59,029
so when you download rust cargo is your

00:15:56,930 --> 00:16:02,060
main way to like start builds and add

00:15:59,029 --> 00:16:04,490
dependencies and and run tests and all

00:16:02,060 --> 00:16:06,170
that sort of stuff and carbo has this

00:16:04,490 --> 00:16:09,140
cool feature that you can run cargo dock

00:16:06,170 --> 00:16:11,480
on your rust project and it will take

00:16:09,140 --> 00:16:13,579
these dock comments that are littered

00:16:11,480 --> 00:16:16,940
throughout your screen or your code and

00:16:13,579 --> 00:16:19,190
will generate documentation for you so

00:16:16,940 --> 00:16:21,649
you get this nice documentation that has

00:16:19,190 --> 00:16:23,420
all these links this is all local you

00:16:21,649 --> 00:16:25,130
get all your comments in line and you

00:16:23,420 --> 00:16:28,149
can see there's this trait

00:16:25,130 --> 00:16:31,940
implementation traits are like

00:16:28,149 --> 00:16:33,380
interfaces in other languages kind of

00:16:31,940 --> 00:16:35,510
like functions you can attach to an

00:16:33,380 --> 00:16:37,520
object and you can see because we

00:16:35,510 --> 00:16:39,290
annotate it with that graph QL object

00:16:37,520 --> 00:16:41,690
thing that okay yeah

00:16:39,290 --> 00:16:43,670
has an email it has an age but ass Allah

00:16:41,690 --> 00:16:45,649
also has all this gobbledygook this

00:16:43,670 --> 00:16:47,959
graphical type and that's the magic that

00:16:45,649 --> 00:16:49,100
does it behind the scenes I'm not gonna

00:16:47,959 --> 00:16:54,529
go over this gobbledygook because it's

00:16:49,100 --> 00:16:56,000
not a a rust training presentation you

00:16:54,529 --> 00:16:57,589
can do cool things because this is in

00:16:56,000 --> 00:16:59,540
the language you can do that anyway in

00:16:57,589 --> 00:17:00,829
other languages you can extract comments

00:16:59,540 --> 00:17:02,149
and make documentation but this isn't

00:17:00,829 --> 00:17:04,309
the language this is an every rust

00:17:02,149 --> 00:17:07,069
project and it ties into all the other

00:17:04,309 --> 00:17:09,740
nice infrastructure in rust so you can

00:17:07,069 --> 00:17:10,130
say okay I want to actually deny missing

00:17:09,740 --> 00:17:12,709
dogs

00:17:10,130 --> 00:17:15,470
I want my code to not even compile if it

00:17:12,709 --> 00:17:16,790
doesn't have documentation and you get

00:17:15,470 --> 00:17:19,100
you would get stuff like this you're

00:17:16,790 --> 00:17:22,750
missing documentation for a struct where

00:17:19,100 --> 00:17:24,919
it is exactly where it is and underlined

00:17:22,750 --> 00:17:28,760
so this is really great this helps your

00:17:24,919 --> 00:17:30,230
your your code scale rust error messages

00:17:28,760 --> 00:17:32,000
are out of this world but what's nice

00:17:30,230 --> 00:17:35,210
this happens that compiled time out of

00:17:32,000 --> 00:17:36,410
the box you don't have to add stuff on

00:17:35,210 --> 00:17:37,760
it you don't have to add linters you

00:17:36,410 --> 00:17:40,490
don't have to add a separate test for

00:17:37,760 --> 00:17:42,530
this it's just in rust and that blows my

00:17:40,490 --> 00:17:46,580
mind

00:17:42,530 --> 00:17:47,809
rust took first class like comments

00:17:46,580 --> 00:17:49,340
those first class citizens in the

00:17:47,809 --> 00:17:51,830
language so a couple of things to point

00:17:49,340 --> 00:17:55,159
let's say we we put this dot comment on

00:17:51,830 --> 00:17:56,630
top of our person to show an example of

00:17:55,159 --> 00:17:58,400
how to use it well the first thing is we

00:17:56,630 --> 00:18:00,950
have the backticks everyone kind of does

00:17:58,400 --> 00:18:02,690
that does markdown I think naturally now

00:18:00,950 --> 00:18:05,720
with github and with all this sort of

00:18:02,690 --> 00:18:07,580
stuff it's table stakes Russ supports

00:18:05,720 --> 00:18:09,290
markdown in comments natively so if you

00:18:07,580 --> 00:18:11,090
do markdown when you do that cargo doc

00:18:09,290 --> 00:18:14,840
you'll get all your nice formatting all

00:18:11,090 --> 00:18:16,309
that sort of stuff usually you put a

00:18:14,840 --> 00:18:18,380
nice example especially if you're doing

00:18:16,309 --> 00:18:20,540
a library for other consumers like hey

00:18:18,380 --> 00:18:21,650
here's how to use my library do this

00:18:20,540 --> 00:18:23,330
maybe don't do that

00:18:21,650 --> 00:18:25,880
Russ kind of takes it to the next

00:18:23,330 --> 00:18:28,370
extreme and will extract code in

00:18:25,880 --> 00:18:31,700
comments and run them as tests with your

00:18:28,370 --> 00:18:33,470
tests and that prevents your examples in

00:18:31,700 --> 00:18:35,929
your documentation from getting out of

00:18:33,470 --> 00:18:41,150
sync with the actual implementation so

00:18:35,929 --> 00:18:44,480
if later I made the age which is here 42

00:18:41,150 --> 00:18:48,140
later I made that a unsigned int and or

00:18:44,480 --> 00:18:48,909
passed in a string it would fail at

00:18:48,140 --> 00:18:51,290
compile time

00:18:48,909 --> 00:18:52,450
so yeah card would test runs code and

00:18:51,290 --> 00:18:53,590
doc says test

00:18:52,450 --> 00:18:56,050
is really great there's a couple

00:18:53,590 --> 00:18:57,820
projects I think for JavaScript Java

00:18:56,050 --> 00:18:59,470
that extracts stuff and then we'll run

00:18:57,820 --> 00:19:01,360
them but I don't have to deal with it

00:18:59,470 --> 00:19:02,800
and I just know in every time I'm

00:19:01,360 --> 00:19:07,420
writing rust it'll just do the right

00:19:02,800 --> 00:19:09,610
thing okay I'm writing on time so I'm

00:19:07,420 --> 00:19:13,690
gonna blast through the sort of stuff so

00:19:09,610 --> 00:19:14,950
let's say we want to add a UUID we want

00:19:13,690 --> 00:19:16,950
to tell people to not use the email

00:19:14,950 --> 00:19:19,360
anymore graph QL has this great feature

00:19:16,950 --> 00:19:21,370
deprecated you can say don't use this

00:19:19,360 --> 00:19:24,400
field we have the same exact thing on

00:19:21,370 --> 00:19:27,640
rust this is built in the rust almost

00:19:24,400 --> 00:19:29,260
the same so you can do this not only in

00:19:27,640 --> 00:19:31,570
context of graph tool as well as in the

00:19:29,260 --> 00:19:32,830
context of your rust code and simile is

00:19:31,570 --> 00:19:34,450
in graph QL you can actually give the

00:19:32,830 --> 00:19:37,390
reason why you can say hey like don't

00:19:34,450 --> 00:19:42,220
use email use you do ID and rust same

00:19:37,390 --> 00:19:44,170
thing its deprecated use UUID and again

00:19:42,220 --> 00:19:48,280
because it's all built in rust you can

00:19:44,170 --> 00:19:50,770
do similar things like don't let my code

00:19:48,280 --> 00:19:52,390
use this deprecated thing and you can

00:19:50,770 --> 00:19:54,940
poke holes in it and say okay don't let

00:19:52,390 --> 00:19:56,890
anyone use this deprecated thing but for

00:19:54,940 --> 00:19:58,660
my graph to on point I'll let people use

00:19:56,890 --> 00:20:00,850
it and you can really pick and choose

00:19:58,660 --> 00:20:04,630
and move your code base forward and it's

00:20:00,850 --> 00:20:07,450
built into rust all right let's go

00:20:04,630 --> 00:20:10,330
through what a more complicated example

00:20:07,450 --> 00:20:13,540
looks like so we had of our person but

00:20:10,330 --> 00:20:19,630
we're now adding a can vote bool filled

00:20:13,540 --> 00:20:22,330
in graph QL so we have to kind of expand

00:20:19,630 --> 00:20:24,700
what that annotation graphical object

00:20:22,330 --> 00:20:27,310
was doing so what we do is we say hey

00:20:24,700 --> 00:20:29,410
this is now a Juniper object and this is

00:20:27,310 --> 00:20:31,060
an implementation for a person and we

00:20:29,410 --> 00:20:32,890
say okay here's an email it's now a

00:20:31,060 --> 00:20:34,240
function call and now we can do anything

00:20:32,890 --> 00:20:36,100
we want here we're just returning the

00:20:34,240 --> 00:20:37,690
email here we're just return the age

00:20:36,100 --> 00:20:39,070
here we're actually doing some

00:20:37,690 --> 00:20:41,590
calculations in some code this should

00:20:39,070 --> 00:20:43,600
look very familiar if you're if you've

00:20:41,590 --> 00:20:46,480
used other languages server-side

00:20:43,600 --> 00:20:48,250
language with graph QL and I think

00:20:46,480 --> 00:20:49,900
that's sort of the magic here is you get

00:20:48,250 --> 00:20:52,180
all these crazy improvements you get all

00:20:49,900 --> 00:20:54,610
these benefits and it doesn't really

00:20:52,180 --> 00:20:56,080
hurt you as a developer it still feels

00:20:54,610 --> 00:20:59,100
like you're writing Python or you're

00:20:56,080 --> 00:20:59,100
writing a JavaScript code

00:21:00,570 --> 00:21:05,550
okay let's say we add a age label for so

00:21:02,910 --> 00:21:11,040
if your age is a certain range we want

00:21:05,550 --> 00:21:13,620
to return a specific string in this case

00:21:11,040 --> 00:21:16,440
we're returning a result so like I said

00:21:13,620 --> 00:21:19,560
rust has good errors and so we're saying

00:21:16,440 --> 00:21:20,700
this could fail and whenever we return

00:21:19,560 --> 00:21:25,070
something from this function we have to

00:21:20,700 --> 00:21:28,020
say is that case a success case which is

00:21:25,070 --> 00:21:30,960
which is which we denote with okay

00:21:28,020 --> 00:21:35,310
or is that case a failure case which we

00:21:30,960 --> 00:21:38,040
denote with error and because we're

00:21:35,310 --> 00:21:39,840
matching on different values okay if

00:21:38,040 --> 00:21:41,610
it's zero through one do this if it's

00:21:39,840 --> 00:21:43,680
three to four do that we have to match

00:21:41,610 --> 00:21:45,390
all values otherwise rust would not

00:21:43,680 --> 00:21:47,160
compile so we have to handle the case

00:21:45,390 --> 00:21:49,380
where we don't know

00:21:47,160 --> 00:21:51,660
so rust just like makes us handle that

00:21:49,380 --> 00:21:55,530
and decide what to do and decide if that

00:21:51,660 --> 00:21:59,190
is a failure case or a or a success case

00:21:55,530 --> 00:22:01,110
and Juniper just like any standard

00:21:59,190 --> 00:22:02,700
back-end stuff when you query it it

00:22:01,110 --> 00:22:04,260
returns the data that it can fetch but

00:22:02,700 --> 00:22:05,520
also returns the errors automatically

00:22:04,260 --> 00:22:07,520
all that plumbing that's just handled

00:22:05,520 --> 00:22:09,960
for you

00:22:07,520 --> 00:22:12,150
rust Maps very closely to graph QL

00:22:09,960 --> 00:22:13,620
schema so we have enums we have

00:22:12,150 --> 00:22:16,020
interfaces we have traits we have all

00:22:13,620 --> 00:22:17,430
this sort of stuff very straightforward

00:22:16,020 --> 00:22:20,820
and there's always an escape valve if

00:22:17,430 --> 00:22:22,740
the Juniper auto stuff of ok it'll take

00:22:20,820 --> 00:22:23,970
terrible twos and it'll just capitalize

00:22:22,740 --> 00:22:25,380
it but if you want it to be terrible

00:22:23,970 --> 00:22:29,730
underscore tubes you can you can

00:22:25,380 --> 00:22:31,710
override it very quickly n plus one in

00:22:29,730 --> 00:22:33,540
graph QL is a thing it's still a thing

00:22:31,710 --> 00:22:35,820
in rust it's just inherent in the

00:22:33,540 --> 00:22:37,200
problem space graph juniper the library

00:22:35,820 --> 00:22:39,680
gives you a look Eady and it's up to you

00:22:37,200 --> 00:22:41,310
how to use it we do have a data loader

00:22:39,680 --> 00:22:43,650
thing in rust

00:22:41,310 --> 00:22:44,940
we have eager loading so if you want to

00:22:43,650 --> 00:22:48,120
load everything up front and pass it

00:22:44,940 --> 00:22:50,640
through you can use that we have ways to

00:22:48,120 --> 00:22:53,520
go from your graph QL code or sorry your

00:22:50,640 --> 00:22:55,110
rust code to your schema so if you want

00:22:53,520 --> 00:22:56,550
to use other tools like Apollo you can

00:22:55,110 --> 00:22:59,490
have a nice schema keep your source of

00:22:56,550 --> 00:23:01,920
truth in rust and just just print out

00:22:59,490 --> 00:23:03,870
the schema or you can have a schema

00:23:01,920 --> 00:23:05,190
language and generate all this juniper

00:23:03,870 --> 00:23:07,290
boilerplate you can go the other way and

00:23:05,190 --> 00:23:09,120
there's a product for that you can run

00:23:07,290 --> 00:23:10,390
graft you all you can have a client it

00:23:09,120 --> 00:23:12,549
can run

00:23:10,390 --> 00:23:13,750
in the browser by webassembly or if you

00:23:12,549 --> 00:23:16,539
just need to write to Lee on top of

00:23:13,750 --> 00:23:18,669
graph QL there's a parser for further

00:23:16,539 --> 00:23:20,559
reading the Russ book is very good it's

00:23:18,669 --> 00:23:22,779
free it's online and it's very newbie

00:23:20,559 --> 00:23:25,029
friendly the Juniper book for graph QL

00:23:22,779 --> 00:23:27,549
is a work in progress but it's pretty

00:23:25,029 --> 00:23:30,490
pretty good and we have an end to an

00:23:27,549 --> 00:23:32,350
example of using rust with graph QL with

00:23:30,490 --> 00:23:34,779
the database and if you need help please

00:23:32,350 --> 00:23:36,600
contact me on Twitter I'm very

00:23:34,779 --> 00:23:38,650
passionate about graph QL and rust

00:23:36,600 --> 00:23:43,979
that's all I got thank you very much

00:23:38,650 --> 00:23:43,979

YouTube URL: https://www.youtube.com/watch?v=QXJ0wKBLt-8


