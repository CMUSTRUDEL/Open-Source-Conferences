Title: Apollo GraphQL Server per field caching mechanism for an object based database (BOÅ TJAN CIGAN)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	GraphQL offers loads of possibilities, one of them is directives. We can use directives to apply a server side per field caching mechanism which allows us to fetch less data at each request if we are using an object based database.
Captions: 
	00:00:04,250 --> 00:00:12,540
okay so thanks for having me thank you

00:00:08,820 --> 00:00:13,710
for this wonderful introduction and even

00:00:12,540 --> 00:00:16,830
though you've mentioned a lot of my

00:00:13,710 --> 00:00:18,750
accolades I'm still quite nervous to be

00:00:16,830 --> 00:00:20,730
here because the names before me are

00:00:18,750 --> 00:00:24,449
more famous than me so everybody knows

00:00:20,730 --> 00:00:26,580
Netflix right plus I'm gonna do

00:00:24,449 --> 00:00:30,929
something like real weird before I start

00:00:26,580 --> 00:00:34,530
start talking so for me you guys here

00:00:30,929 --> 00:00:36,870
are rockstars because because of you the

00:00:34,530 --> 00:00:38,850
gravity our community even exists and is

00:00:36,870 --> 00:00:41,730
spreading and my head is like exploding

00:00:38,850 --> 00:00:45,180
with new ideas just because of the past

00:00:41,730 --> 00:00:57,410
few days so I'm just gonna do a quick

00:00:45,180 --> 00:01:01,550
photo so smile okay now to the fun stuff

00:00:57,410 --> 00:01:04,080
so yeah I said we're doing caching on a

00:01:01,550 --> 00:01:06,450
quite different level than most of the

00:01:04,080 --> 00:01:08,580
talks I've heard before mine so we're

00:01:06,450 --> 00:01:11,520
doing a per field caching mechanism

00:01:08,580 --> 00:01:14,610
which is quite a fun and novel idea I

00:01:11,520 --> 00:01:16,860
guess and I need to ask you a question

00:01:14,610 --> 00:01:22,970
so how many people here are having

00:01:16,860 --> 00:01:26,100
trouble with caching well some some so

00:01:22,970 --> 00:01:27,900
not that many which means that the

00:01:26,100 --> 00:01:31,259
caching techniques are improving and we

00:01:27,900 --> 00:01:34,710
are getting new ideas and before I get

00:01:31,259 --> 00:01:38,790
into the caching mechanism on its own I

00:01:34,710 --> 00:01:40,490
need to explain where I'm from so I'm

00:01:38,790 --> 00:01:43,380
from this lovely city called uh Brianna

00:01:40,490 --> 00:01:45,180
our company is based in Europe we do a

00:01:43,380 --> 00:01:47,189
lot of software development but we also

00:01:45,180 --> 00:01:49,110
do business intelligence so we're a

00:01:47,189 --> 00:01:52,560
little bit of both quite a unique and

00:01:49,110 --> 00:01:55,229
fun combination and the project we were

00:01:52,560 --> 00:01:58,920
working on so the backstory that led to

00:01:55,229 --> 00:02:01,530
this idea of course is microservices so

00:01:58,920 --> 00:02:05,159
two years ago when we started thinking

00:02:01,530 --> 00:02:06,930
about building an app everything was

00:02:05,159 --> 00:02:08,340
based on micro services and we decided

00:02:06,930 --> 00:02:10,080
to go into micro services as well

00:02:08,340 --> 00:02:13,060
because it's the new hipster trend and

00:02:10,080 --> 00:02:17,659
why not use it and

00:02:13,060 --> 00:02:19,519
well this led to so the project we were

00:02:17,659 --> 00:02:23,480
doing was connected to the post office

00:02:19,519 --> 00:02:27,310
of Slovenia and the idea was to get all

00:02:23,480 --> 00:02:30,709
of their apps into one big ecosystem

00:02:27,310 --> 00:02:32,959
more just like the apps you're using at

00:02:30,709 --> 00:02:34,069
Google so single sign-in and all the

00:02:32,959 --> 00:02:36,139
rest of the stuff that comes with that

00:02:34,069 --> 00:02:39,739
and we started with an application

00:02:36,139 --> 00:02:42,170
called ez Docs which with the underlying

00:02:39,739 --> 00:02:45,919
ecosystem is comprised of like 20 plus

00:02:42,170 --> 00:02:48,950
micro services and 10 databases so we

00:02:45,919 --> 00:02:53,689
put this on openshift and then we

00:02:48,950 --> 00:02:56,629
gradually went into production and what

00:02:53,689 --> 00:03:00,680
happened was is we were like getting

00:02:56,629 --> 00:03:04,959
this insane network traffic load plus

00:03:00,680 --> 00:03:08,090
insane database loads and the most

00:03:04,959 --> 00:03:12,349
depressing thing for me was when it's 2

00:03:08,090 --> 00:03:14,719
a.m. I got a phone call from the dev ops

00:03:12,349 --> 00:03:18,709
people which usually don't sleep at all

00:03:14,719 --> 00:03:20,720
and they said to me well there's really

00:03:18,709 --> 00:03:23,620
a lot of stuff going on so I keep

00:03:20,720 --> 00:03:26,209
increasing the resources you have and

00:03:23,620 --> 00:03:29,629
what are you guys running is is it a

00:03:26,209 --> 00:03:33,109
spaceship or what and I said ok we'll

00:03:29,629 --> 00:03:34,609
look into it and now I have another

00:03:33,109 --> 00:03:36,379
question for you because the next two

00:03:34,609 --> 00:03:38,419
slides are totally dependent upon how

00:03:36,379 --> 00:03:40,370
much people know this thing but I'm

00:03:38,419 --> 00:03:49,069
guessing you do how many have seen Back

00:03:40,370 --> 00:03:52,459
to the Future so the thing is that when

00:03:49,069 --> 00:03:56,479
I was thinking about how to reduce these

00:03:52,459 --> 00:04:00,739
problems we're having is the idea kind

00:03:56,479 --> 00:04:02,299
of came at a weird moment so usually

00:04:00,739 --> 00:04:04,129
when people get ideas it's like in

00:04:02,299 --> 00:04:08,239
different places but in my case it was

00:04:04,129 --> 00:04:12,139
under the flour true story and it was

00:04:08,239 --> 00:04:14,180
kind of like an epiphany dog heading

00:04:12,139 --> 00:04:15,859
back to the future when he had that idea

00:04:14,180 --> 00:04:19,190
for the flux capacitor when he hit his

00:04:15,859 --> 00:04:20,930
head I didn't hit my head but it just

00:04:19,190 --> 00:04:23,330
kind of came to me so why couldn't we

00:04:20,930 --> 00:04:25,440
because a lot of our requests that were

00:04:23,330 --> 00:04:27,600
coming in were fetching

00:04:25,440 --> 00:04:30,840
different fields because our API is were

00:04:27,600 --> 00:04:34,320
public and I was kind of wondering could

00:04:30,840 --> 00:04:39,210
we try to cash stuff in a different way

00:04:34,320 --> 00:04:41,100
so using cash Inc on fields and then we

00:04:39,210 --> 00:04:43,380
decided ok we are using the Apollo

00:04:41,100 --> 00:04:47,880
server and they have this wonderful

00:04:43,380 --> 00:04:51,270
support for directives and we decided to

00:04:47,880 --> 00:04:53,450
actually test this stuff out so the idea

00:04:51,270 --> 00:04:56,940
on paper sounded great

00:04:53,450 --> 00:04:59,220
so put your fields put your directives

00:04:56,940 --> 00:05:03,390
on the fields test it out

00:04:59,220 --> 00:05:06,630
and the thing was that we kind of needed

00:05:03,390 --> 00:05:09,650
to dig in a bit deeper so raise your

00:05:06,630 --> 00:05:14,220
hands if anyone has actually kind of

00:05:09,650 --> 00:05:20,640
driven a bit bit a deeper into the info

00:05:14,220 --> 00:05:22,590
object or the ast a few hands so it's

00:05:20,640 --> 00:05:25,740
kind of like going deep down the rabbit

00:05:22,590 --> 00:05:28,380
hole because it's like this community

00:05:25,740 --> 00:05:31,650
one just object that gives you a lot of

00:05:28,380 --> 00:05:33,330
information on the schema itself and we

00:05:31,650 --> 00:05:34,800
actually needed this information so if

00:05:33,330 --> 00:05:37,800
we want to do a per filled caching

00:05:34,800 --> 00:05:41,220
mechanism we need to get the fields that

00:05:37,800 --> 00:05:44,010
are being fetched and the first

00:05:41,220 --> 00:05:46,440
prototype was kind of bored on a white

00:05:44,010 --> 00:05:48,810
board so there's a lot of gibberish

00:05:46,440 --> 00:05:51,350
going on around here we were kind of

00:05:48,810 --> 00:05:54,840
planning stuff out how to do stuff is it

00:05:51,350 --> 00:05:58,350
even feasible to go into this and we

00:05:54,840 --> 00:06:00,540
kind of said okay let's do it so the

00:05:58,350 --> 00:06:03,690
solution was before actually triggering

00:06:00,540 --> 00:06:05,790
the resolver let's check which fields we

00:06:03,690 --> 00:06:08,610
are fetching and checking in with an

00:06:05,790 --> 00:06:10,920
existing cache so we used Redis for our

00:06:08,610 --> 00:06:11,490
implementation and then when this is

00:06:10,920 --> 00:06:14,040
done

00:06:11,490 --> 00:06:18,180
send the fields we need to fetch to the

00:06:14,040 --> 00:06:21,750
resolver and then the resolver goes and

00:06:18,180 --> 00:06:24,480
fetches the data it needs and stuff

00:06:21,750 --> 00:06:26,130
happens so there's a simple query here

00:06:24,480 --> 00:06:30,420
for instance we are fetching a user by

00:06:26,130 --> 00:06:32,070
ID and we are fetching some fields and

00:06:30,420 --> 00:06:35,190
the fields that are cached here are

00:06:32,070 --> 00:06:36,690
named and bar so let's imagine that this

00:06:35,190 --> 00:06:37,689
request is happening for the first time

00:06:36,690 --> 00:06:39,399
so what

00:06:37,689 --> 00:06:42,639
going to happen is that we are going to

00:06:39,399 --> 00:06:47,139
be fetching all the data for the first

00:06:42,639 --> 00:06:50,799
time right and what happened as what

00:06:47,139 --> 00:06:53,409
happens afterwards is we check if a key

00:06:50,799 --> 00:06:55,809
with user and ID exists in Redis it

00:06:53,409 --> 00:06:59,229
doesn't which means that we don't have a

00:06:55,809 --> 00:07:02,110
cached object yet then we fetch the

00:06:59,229 --> 00:07:04,269
fields from our services we get them we

00:07:02,110 --> 00:07:07,179
store them in Redis would return the

00:07:04,269 --> 00:07:07,389
data to the client and that's basically

00:07:07,179 --> 00:07:10,779
it

00:07:07,389 --> 00:07:13,959
and then afterwards let's say that

00:07:10,779 --> 00:07:16,569
another request happens that is like an

00:07:13,959 --> 00:07:18,579
insanely good scenario for us so we are

00:07:16,569 --> 00:07:21,300
fetching two fields that are already in

00:07:18,579 --> 00:07:24,189
the cache itself for a specific user

00:07:21,300 --> 00:07:27,579
what happens now is we going to read

00:07:24,189 --> 00:07:29,469
this the cache exists it hasn't expired

00:07:27,579 --> 00:07:33,189
so this is the most optimal scenario

00:07:29,469 --> 00:07:35,199
that exists and this means that we won't

00:07:33,189 --> 00:07:37,959
be fetching any data from our services

00:07:35,199 --> 00:07:42,279
at all and we just returned this data to

00:07:37,959 --> 00:07:45,639
the client and with this like really

00:07:42,279 --> 00:07:48,789
small idea we managed to reduce our

00:07:45,639 --> 00:07:51,909
network traffic or DB load cut lower our

00:07:48,789 --> 00:07:54,369
service calls were decreased and we kind

00:07:51,909 --> 00:07:56,649
of find out okay we use for our

00:07:54,369 --> 00:07:58,949
micro services but this can basically be

00:07:56,649 --> 00:08:01,479
used with any database layer because

00:07:58,949 --> 00:08:03,399
most of all we're fetching fields I'm

00:08:01,479 --> 00:08:07,269
not saying that this applies to every

00:08:03,399 --> 00:08:08,979
case author but we are going potentially

00:08:07,269 --> 00:08:13,329
be testing it with other databases as

00:08:08,979 --> 00:08:15,869
well and what are we doing right now

00:08:13,329 --> 00:08:18,819
with this is we are going to test

00:08:15,869 --> 00:08:20,860
machine learning in production so we get

00:08:18,819 --> 00:08:25,329
like a bunch of requests to our server

00:08:20,860 --> 00:08:28,989
and we are kind of trying to use machine

00:08:25,329 --> 00:08:30,849
learning to predict what the data going

00:08:28,989 --> 00:08:33,459
to be in advance that our users will be

00:08:30,849 --> 00:08:35,620
querying and with that we can actually

00:08:33,459 --> 00:08:39,309
try to do a dynamic caching mechanism

00:08:35,620 --> 00:08:41,259
for our fields in advance and this all

00:08:39,309 --> 00:08:43,899
could be done without reloading the

00:08:41,259 --> 00:08:47,290
server because you don't need to reload

00:08:43,899 --> 00:08:49,839
the schema in order to get the caching

00:08:47,290 --> 00:08:51,310
time for all of your fields we're also

00:08:49,839 --> 00:08:56,079
trying out Federation

00:08:51,310 --> 00:08:59,410
and basically we haven't covered all the

00:08:56,079 --> 00:09:00,910
cases the community has because a lot of

00:08:59,410 --> 00:09:03,370
the schemas between different companies

00:09:00,910 --> 00:09:06,519
is different that's why we're kind of

00:09:03,370 --> 00:09:08,769
asking for your support so I already got

00:09:06,519 --> 00:09:11,350
a question how do you solve interfaces

00:09:08,769 --> 00:09:14,310
and unions and I said okay we don't have

00:09:11,350 --> 00:09:20,589
interfaces in unions in our schema so

00:09:14,310 --> 00:09:22,000
let's try to solve that problem so we're

00:09:20,589 --> 00:09:23,709
trying to release this thing into the

00:09:22,000 --> 00:09:25,959
community of course it's going to be an

00:09:23,709 --> 00:09:30,339
NPM package first because we're doing

00:09:25,959 --> 00:09:33,189
Apollo but I encourage you to visit the

00:09:30,339 --> 00:09:34,870
site it's just a simple landing page you

00:09:33,189 --> 00:09:38,050
can leave your email address if you want

00:09:34,870 --> 00:09:40,629
to to be notified when we release it but

00:09:38,050 --> 00:09:43,480
if you're skeptical about leaving your

00:09:40,629 --> 00:09:48,069
email address I certainly am sometimes

00:09:43,480 --> 00:09:51,670
you can also follow me on Twitter to see

00:09:48,069 --> 00:09:54,670
when this thing is released and before I

00:09:51,670 --> 00:09:58,959
finish up this talk I'd also like to

00:09:54,670 --> 00:10:02,889
thank my fellow engineer Marco he isn't

00:09:58,959 --> 00:10:04,750
here today but he was quite quite a wild

00:10:02,889 --> 00:10:06,639
animal when he was researching the info

00:10:04,750 --> 00:10:10,389
object so without him none of this would

00:10:06,639 --> 00:10:12,490
practically exist and also none of this

00:10:10,389 --> 00:10:14,800
would also exist if result didn't

00:10:12,490 --> 00:10:16,059
encourage us to follow new ideas so when

00:10:14,800 --> 00:10:18,430
I proposed this idea there were

00:10:16,059 --> 00:10:20,410
immediately okay let's go into it even

00:10:18,430 --> 00:10:22,899
if it doesn't do anything

00:10:20,410 --> 00:10:26,139
and of course Apollo in the community

00:10:22,899 --> 00:10:29,829
itself without them none of us would be

00:10:26,139 --> 00:10:32,680
here and if you need more info again

00:10:29,829 --> 00:10:34,059
I'll be posting a few medium articles in

00:10:32,680 --> 00:10:37,269
detail how this thing works

00:10:34,059 --> 00:10:41,199
I didn't want to go all into technical

00:10:37,269 --> 00:10:42,759
details here plus you can also do your

00:10:41,199 --> 00:10:45,329
own implementations in the mean time

00:10:42,759 --> 00:10:49,569
because it's a really simple thing to do

00:10:45,329 --> 00:10:52,809
and again if you're hoping for a secret

00:10:49,569 --> 00:10:56,140
ending like in the Marvel movies there

00:10:52,809 --> 00:10:59,220
isn't one so that's all

00:10:56,140 --> 00:10:59,220

YouTube URL: https://www.youtube.com/watch?v=yPLCpvUyRX8


