Title: Game Of Types: A Song Of GraphQL And TypeScript (STEVEN MUSUMECHE)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	Treating our GraphQL schema as the single source of truth for our types and generating TypeScript definitions from it, we diminish the risk of duplication and divergence between the two type systems.
Captions: 
	00:00:04,400 --> 00:00:08,670
all right hello everyone thanks for

00:00:06,930 --> 00:00:10,860
coming I know it's it's the end of the

00:00:08,670 --> 00:00:13,380
day and you're probably dragging as much

00:00:10,860 --> 00:00:15,210
as I am before I start I want to get a

00:00:13,380 --> 00:00:17,490
quick show of hands who in here has

00:00:15,210 --> 00:00:20,520
actually like written a project with

00:00:17,490 --> 00:00:23,420
typescript a lot okay

00:00:20,520 --> 00:00:27,539
what about typescript Plus graph you out

00:00:23,420 --> 00:00:29,580
right not quite as many awesome

00:00:27,539 --> 00:00:33,659
okay so let's talk a little bit about

00:00:29,580 --> 00:00:36,499
graph QL NPM recently did a survey and

00:00:33,659 --> 00:00:40,190
they found that 23% of all developers

00:00:36,499 --> 00:00:42,690
are using graph QL and projects today

00:00:40,190 --> 00:00:46,229
that's a huge number for a tech that was

00:00:42,690 --> 00:00:48,929
really only released four years ago even

00:00:46,229 --> 00:00:50,760
more impressive nearly half of

00:00:48,929 --> 00:00:56,129
developers are considering using it this

00:00:50,760 --> 00:00:58,409
year this is explosive growth the most

00:00:56,129 --> 00:01:00,449
recent state of JavaScript survey showed

00:00:58,409 --> 00:01:03,809
us this change in graph QL popularity

00:01:00,449 --> 00:01:07,710
over time you can see that awareness

00:01:03,809 --> 00:01:10,020
increased significantly developers

00:01:07,710 --> 00:01:13,799
interested in learning learning it grew

00:01:10,020 --> 00:01:16,020
by more than 40 percent and developers

00:01:13,799 --> 00:01:17,880
that have used it and loved it have

00:01:16,020 --> 00:01:19,380
quadrupled and that's probably not a

00:01:17,880 --> 00:01:22,560
surprise because we're at a graph QL

00:01:19,380 --> 00:01:25,979
conference here so let's talk about

00:01:22,560 --> 00:01:27,869
typescript that same NPM survey found

00:01:25,979 --> 00:01:30,240
that a third of users in the JavaScript

00:01:27,869 --> 00:01:33,329
community are writing typescript some

00:01:30,240 --> 00:01:36,240
are part of the time that's a third of

00:01:33,329 --> 00:01:38,820
users running like a totally new flavor

00:01:36,240 --> 00:01:40,979
of JavaScript that's to me very

00:01:38,820 --> 00:01:43,920
remarkable and it should make us sit up

00:01:40,979 --> 00:01:46,590
and take notice so what is typescript

00:01:43,920 --> 00:01:48,539
it's essentially a statically typed

00:01:46,590 --> 00:01:51,479
programming language that compiles down

00:01:48,539 --> 00:01:54,329
to JavaScript typescript is what you

00:01:51,479 --> 00:01:55,740
write in this top example and it outputs

00:01:54,329 --> 00:01:56,969
the JavaScript that you see in the

00:01:55,740 --> 00:01:59,670
bottom example and that's what actually

00:01:56,969 --> 00:02:04,280
runs it's an open source project backed

00:01:59,670 --> 00:02:06,840
by Microsoft so what do we mean by

00:02:04,280 --> 00:02:09,179
statically typed statically typed is

00:02:06,840 --> 00:02:12,540
just when a language determines the type

00:02:09,179 --> 00:02:16,700
information these are a few examples of

00:02:12,540 --> 00:02:19,830
languages that are in each part

00:02:16,700 --> 00:02:22,140
which one is better is sort of a hot

00:02:19,830 --> 00:02:23,760
topic they both have advantages and

00:02:22,140 --> 00:02:27,870
disadvantages I wouldn't say one is

00:02:23,760 --> 00:02:29,550
better than the other but one

00:02:27,870 --> 00:02:32,940
implication of this is when errors are

00:02:29,550 --> 00:02:36,240
discovered is it at run time or is it at

00:02:32,940 --> 00:02:41,790
compile time compile time errors are

00:02:36,240 --> 00:02:44,010
much better for users so error handling

00:02:41,790 --> 00:02:46,830
error handling is better in statically

00:02:44,010 --> 00:02:48,330
typed languages but what else I can say

00:02:46,830 --> 00:02:50,120
after using both languages for a while

00:02:48,330 --> 00:02:52,980
in large projects I can't imagine

00:02:50,120 --> 00:02:56,870
writing a large project in JavaScript I

00:02:52,980 --> 00:03:00,300
would go for typescript 100% of the time

00:02:56,870 --> 00:03:03,780
static type languages have to prove in

00:03:00,300 --> 00:03:05,550
ability to enhance code quality large

00:03:03,780 --> 00:03:07,650
teams at companies like Google Microsoft

00:03:05,550 --> 00:03:11,580
Facebook have come to this conclusion

00:03:07,650 --> 00:03:14,120
over time static typing eases

00:03:11,580 --> 00:03:18,120
refactoring they increase your agility

00:03:14,120 --> 00:03:21,090
when you're doing renames refactoring

00:03:18,120 --> 00:03:23,310
you saw before the compiler catches

00:03:21,090 --> 00:03:27,209
errors as you type instead of having

00:03:23,310 --> 00:03:28,890
things fail at runtime there also one of

00:03:27,209 --> 00:03:30,840
the best forms of documentation you can

00:03:28,890 --> 00:03:34,019
have it forces you to think about the

00:03:30,840 --> 00:03:37,230
shape of your data upfront and document

00:03:34,019 --> 00:03:42,140
how it works the function signature is

00:03:37,230 --> 00:03:42,140
like a theorem and the body is the proof

00:03:42,350 --> 00:03:46,730
here's a simple react component

00:03:50,950 --> 00:03:57,680
any consumers of this component can see

00:03:54,440 --> 00:04:00,220
what props it accepts and it's enforced

00:03:57,680 --> 00:04:00,220
by the compiler

00:04:01,030 --> 00:04:06,290
finally static type languages enable IDE

00:04:04,400 --> 00:04:09,310
use to provide a rich environment for

00:04:06,290 --> 00:04:12,770
spotting common errors as you type

00:04:09,310 --> 00:04:20,209
here's an example showing autocomplete

00:04:12,770 --> 00:04:22,190
as well as renaming it's also important

00:04:20,209 --> 00:04:35,330
to note that this works across files in

00:04:22,190 --> 00:04:38,420
your project and here you'll see how

00:04:35,330 --> 00:04:39,950
I'll rename the MSRP field and at the

00:04:38,420 --> 00:04:47,360
same time it will update the interface

00:04:39,950 --> 00:04:49,370
for product so going back to the state

00:04:47,360 --> 00:04:52,970
of JavaScript survey you can see type

00:04:49,370 --> 00:04:54,350
scripts popularity over time developers

00:04:52,970 --> 00:04:58,190
who have used it and loved it has more

00:04:54,350 --> 00:04:59,900
than doubled and the number of devs that

00:04:58,190 --> 00:05:06,110
are not interested at all has been cut

00:04:59,900 --> 00:05:07,730
in more than half among developers who

00:05:06,110 --> 00:05:11,090
like to use both these are the most

00:05:07,730 --> 00:05:13,520
liked aspects of the languages and you

00:05:11,090 --> 00:05:15,680
can see that those users like them

00:05:13,520 --> 00:05:18,010
because they unlock the ability for us

00:05:15,680 --> 00:05:21,520
to create powerful developer tooling and

00:05:18,010 --> 00:05:23,960
strongly-typed less error-prone code and

00:05:21,520 --> 00:05:26,300
today's talk we're going to focus on

00:05:23,960 --> 00:05:28,550
developer tooling that works at the

00:05:26,300 --> 00:05:32,840
intersection between graph UO and

00:05:28,550 --> 00:05:34,520
typescript before we go on just a little

00:05:32,840 --> 00:05:36,620
about me I've been a professional

00:05:34,520 --> 00:05:39,020
developer for over 20 years I work

00:05:36,620 --> 00:05:41,860
remotely from Lafayette Louisiana

00:05:39,020 --> 00:05:43,820
I started primarily as a PHP developer

00:05:41,860 --> 00:05:47,090
eventually moving to the full stack

00:05:43,820 --> 00:05:51,140
JavaScript ecosystem and I now focus on

00:05:47,090 --> 00:05:53,090
that at formidable labs formidable as a

00:05:51,140 --> 00:05:55,160
software consultancy that focuses on

00:05:53,090 --> 00:05:57,530
that same ecosystem we work with

00:05:55,160 --> 00:06:01,130
companies of all sizes from startups to

00:05:57,530 --> 00:06:02,800
Fortune 100's we have many popular open

00:06:01,130 --> 00:06:04,870
source libraries if you

00:06:02,800 --> 00:06:05,740
anything here that that you like that

00:06:04,870 --> 00:06:08,080
you think we could help your company

00:06:05,740 --> 00:06:11,849
with please come talk to me and also

00:06:08,080 --> 00:06:11,849
we're hiring we're almost always hiring

00:06:12,300 --> 00:06:16,979
so when I was kind of come up with the

00:06:14,889 --> 00:06:19,060
idea for this presentation I wanted to

00:06:16,979 --> 00:06:21,729
come up with like an example application

00:06:19,060 --> 00:06:24,310
I could use to demonstrate the sort of

00:06:21,729 --> 00:06:25,770
the philosophy the technique here first

00:06:24,310 --> 00:06:29,919
thing I thought it was like a to-do app

00:06:25,770 --> 00:06:31,840
well that's really boring at the time I

00:06:29,919 --> 00:06:34,120
was working on this game of Thrones was

00:06:31,840 --> 00:06:35,680
like in its final season and I really

00:06:34,120 --> 00:06:37,330
loved that show

00:06:35,680 --> 00:06:38,650
so I said okay let's do something with

00:06:37,330 --> 00:06:41,590
that let's build a character Explorer

00:06:38,650 --> 00:06:43,900
using typescript and graphic evil I'm

00:06:41,590 --> 00:06:45,669
not going to show all of the code for

00:06:43,900 --> 00:06:47,800
the app just the important pieces and

00:06:45,669 --> 00:06:49,780
we'll take two passes at it first we'll

00:06:47,800 --> 00:06:52,419
kind of right at naive implementation

00:06:49,780 --> 00:06:56,770
and then we'll come back and try to make

00:06:52,419 --> 00:07:00,400
it better so before we go on who-who

00:06:56,770 --> 00:07:09,219
else watch Game of Thrones what do you

00:07:00,400 --> 00:07:12,250
think of the ending I don't know all

00:07:09,219 --> 00:07:13,840
right so let's go to the server before

00:07:12,250 --> 00:07:15,580
we get to the typescript specific stuff

00:07:13,840 --> 00:07:18,400
I want to give a high-level overview of

00:07:15,580 --> 00:07:21,729
how a graph QL server works for those

00:07:18,400 --> 00:07:23,949
that haven't done that before I find

00:07:21,729 --> 00:07:25,630
that a lot of times people only work on

00:07:23,949 --> 00:07:26,979
the client side of things so if you

00:07:25,630 --> 00:07:29,889
already know the server side stuff this

00:07:26,979 --> 00:07:31,690
will be a refresher for you

00:07:29,889 --> 00:07:34,289
you essentially need to provide a graph

00:07:31,690 --> 00:07:36,969
you'll server with three things a schema

00:07:34,289 --> 00:07:38,560
resolvers and context these are the

00:07:36,969 --> 00:07:40,719
three main building blocks of every

00:07:38,560 --> 00:07:43,440
graph QL server and we'll look at each

00:07:40,719 --> 00:07:46,300
of these in a little little more detail

00:07:43,440 --> 00:07:48,039
so the schema is the core of everything

00:07:46,300 --> 00:07:51,879
this is where you define the operations

00:07:48,039 --> 00:07:53,590
that your application supports here's a

00:07:51,879 --> 00:07:55,479
schema we're going to work with for the

00:07:53,590 --> 00:07:58,349
rest of this talk I'll pause for a

00:07:55,479 --> 00:07:58,349
minute so you can read it

00:08:06,810 --> 00:08:12,700
so let me highlight a few things here so

00:08:09,850 --> 00:08:14,230
our main entity is a character and we

00:08:12,700 --> 00:08:16,950
have these two queries that return a

00:08:14,230 --> 00:08:20,170
list of characters or a single character

00:08:16,950 --> 00:08:24,730
each character can have appeared in many

00:08:20,170 --> 00:08:26,560
of these TV season entities and a

00:08:24,730 --> 00:08:28,030
character can as can also have

00:08:26,560 --> 00:08:31,570
allegiances to many of these house

00:08:28,030 --> 00:08:36,010
entities and finally another query that

00:08:31,570 --> 00:08:37,990
returns a list of houses so let's move

00:08:36,010 --> 00:08:39,370
on to the resolvers a graph from graph

00:08:37,990 --> 00:08:41,530
QL resolver is just a function that

00:08:39,370 --> 00:08:43,479
returns something they're written for

00:08:41,530 --> 00:08:47,620
all your queries mutations you can write

00:08:43,479 --> 00:08:50,110
them for fields and more here's how a

00:08:47,620 --> 00:08:52,150
resolver is structured you essentially

00:08:50,110 --> 00:08:57,130
provide an object with a key for each

00:08:52,150 --> 00:09:01,180
type and your schema inside of that key

00:08:57,130 --> 00:09:02,890
the object is a resolver map so this is

00:09:01,180 --> 00:09:05,710
an example of a resolver map for the

00:09:02,890 --> 00:09:09,610
query key notice that there's an entry

00:09:05,710 --> 00:09:11,710
for each query in the schema and each

00:09:09,610 --> 00:09:15,280
one of those entries is a resolver

00:09:11,710 --> 00:09:17,770
function this is the shape for all

00:09:15,280 --> 00:09:19,780
resolver functions you might not use all

00:09:17,770 --> 00:09:22,839
four parameters every time but they're

00:09:19,780 --> 00:09:25,180
available if you need them the parent

00:09:22,839 --> 00:09:26,890
contains the the root element or the

00:09:25,180 --> 00:09:30,160
parent element depending on where you

00:09:26,890 --> 00:09:31,600
are in the in the schema in this case

00:09:30,160 --> 00:09:33,940
it's the root because this is at the

00:09:31,600 --> 00:09:36,430
query level but if you were writing a

00:09:33,940 --> 00:09:38,650
resolver for a field under the character

00:09:36,430 --> 00:09:39,940
for example then it would then the

00:09:38,650 --> 00:09:44,770
parent would represent the character

00:09:39,940 --> 00:09:48,850
entity this is the arguments for the

00:09:44,770 --> 00:09:51,490
query or mutation if they exist context

00:09:48,850 --> 00:09:53,710
is an object Chimay shared among all

00:09:51,490 --> 00:09:55,230
resolvers of a specific execution and

00:09:53,710 --> 00:09:58,930
we'll discuss that in a minute

00:09:55,230 --> 00:10:02,470
info is only used in advanced cases and

00:09:58,930 --> 00:10:06,600
then we have a return type and here here

00:10:02,470 --> 00:10:06,600
is how that all lines up with our schema

00:10:11,879 --> 00:10:16,899
so context is a third major building

00:10:14,529 --> 00:10:19,240
block like I mentioned it's an object

00:10:16,899 --> 00:10:21,309
shared by all the resolvers it can be

00:10:19,240 --> 00:10:24,279
anything you want and its newly created

00:10:21,309 --> 00:10:26,589
on each call it's useful for keeping

00:10:24,279 --> 00:10:29,800
data like you see here authentication

00:10:26,589 --> 00:10:32,439
information the current user a database

00:10:29,800 --> 00:10:34,869
connection and it's specific to your

00:10:32,439 --> 00:10:37,230
application so whatever you need it to

00:10:34,869 --> 00:10:39,639
be is what it is

00:10:37,230 --> 00:10:41,529
so just to recap these are the three

00:10:39,639 --> 00:10:45,790
fundamental pieces of a graphic uo

00:10:41,529 --> 00:10:48,970
server so let's look at some resolver

00:10:45,790 --> 00:10:49,959
code this is just a subset I removed a

00:10:48,970 --> 00:10:52,660
lot of it

00:10:49,959 --> 00:10:57,040
but let's see how we can define types

00:10:52,660 --> 00:10:59,170
for it first we have our top-level

00:10:57,040 --> 00:11:01,240
resolver object that has an entry for

00:10:59,170 --> 00:11:06,279
each of our entities which you can see

00:11:01,240 --> 00:11:09,779
underlined in green each one of those is

00:11:06,279 --> 00:11:12,369
a resolver map also underlined in green

00:11:09,779 --> 00:11:14,170
we're using an index signature here

00:11:12,369 --> 00:11:20,439
because our resolver maps can have many

00:11:14,170 --> 00:11:22,240
fields those fields contain resolver

00:11:20,439 --> 00:11:24,749
functions and they just need to match

00:11:22,240 --> 00:11:27,100
this function signature

00:11:24,749 --> 00:11:31,240
notice how the parent or the root

00:11:27,100 --> 00:11:33,339
element there is any in some cases we

00:11:31,240 --> 00:11:34,660
want that first argument of our resolver

00:11:33,339 --> 00:11:37,509
function to be more specific than that

00:11:34,660 --> 00:11:39,490
in this example we know that the parent

00:11:37,509 --> 00:11:42,670
of the appeared in field is a character

00:11:39,490 --> 00:11:45,779
so we can add a manual type different

00:11:42,670 --> 00:11:48,279
type definition there to improve safety

00:11:45,779 --> 00:11:52,869
so this is pretty cool we have mostly

00:11:48,279 --> 00:11:54,999
typesafe resolvers now let's make a web

00:11:52,869 --> 00:11:55,569
app to consume our new graph cue ball

00:11:54,999 --> 00:11:58,420
API

00:11:55,569 --> 00:12:00,009
I used create react app to bootstrap the

00:11:58,420 --> 00:12:03,399
front-end but I'm not going to go into

00:12:00,009 --> 00:12:06,699
details or show that a graph QL client

00:12:03,399 --> 00:12:08,379
library like Apollo is not necessary but

00:12:06,699 --> 00:12:10,990
but it helps especially with caching and

00:12:08,379 --> 00:12:12,579
batching and things like that in our

00:12:10,990 --> 00:12:15,420
examples I'm going to use a library from

00:12:12,579 --> 00:12:15,420
formidable called

00:12:16,100 --> 00:12:20,280
Oracle is a lightweight powerful and

00:12:18,660 --> 00:12:23,550
easy-to-use alternative to other graph

00:12:20,280 --> 00:12:25,380
Google clients it's small which really

00:12:23,550 --> 00:12:27,870
helps with performance there's no

00:12:25,380 --> 00:12:30,090
complex configuration or large API

00:12:27,870 --> 00:12:32,370
overhead it's built around the concept

00:12:30,090 --> 00:12:35,220
of exchanges which is similar to like

00:12:32,370 --> 00:12:36,690
middleware in redux allows you to

00:12:35,220 --> 00:12:38,520
customize your data layer to suit your

00:12:36,690 --> 00:12:43,170
needs for example different caching

00:12:38,520 --> 00:12:45,900
strategies custom developer tools etc it

00:12:43,170 --> 00:12:49,290
works very very similarly to other apply

00:12:45,900 --> 00:12:53,490
brer ease like Apollo you wrap your app

00:12:49,290 --> 00:12:55,710
with Oracle's provider component this

00:12:53,490 --> 00:12:57,570
provider holds the client that is used

00:12:55,710 --> 00:12:59,670
to manage data requests the cache and

00:12:57,570 --> 00:13:02,280
everything else it's the heart of Urkel

00:12:59,670 --> 00:13:04,110
and holds all of the core logic every

00:13:02,280 --> 00:13:06,210
component underneath the provider now

00:13:04,110 --> 00:13:07,710
has access to the client and will use it

00:13:06,210 --> 00:13:12,840
when it needs to make graph Cobell

00:13:07,710 --> 00:13:14,540
requests oracle comes with hooks that

00:13:12,840 --> 00:13:17,130
can be used to declaratively

00:13:14,540 --> 00:13:20,010
declaratively fetch data from your graph

00:13:17,130 --> 00:13:24,300
QL server here's an example component

00:13:20,010 --> 00:13:26,040
that uses the used query hook when this

00:13:24,300 --> 00:13:28,700
component is mounted it will send the

00:13:26,040 --> 00:13:31,230
query in variables to your graph QL API

00:13:28,700 --> 00:13:33,180
we then get a few variables to tell us

00:13:31,230 --> 00:13:38,970
about the state of that request like

00:13:33,180 --> 00:13:40,920
fetching error and data that should be

00:13:38,970 --> 00:13:42,600
enough about our coal to get us started

00:13:40,920 --> 00:13:45,780
so we can now write a react component

00:13:42,600 --> 00:13:47,580
that renders a list of characters when

00:13:45,780 --> 00:13:50,030
I'm working on a component the workflow

00:13:47,580 --> 00:13:52,620
I like to use is to start with the query

00:13:50,030 --> 00:13:55,820
so I know exactly what data my component

00:13:52,620 --> 00:13:55,820
needs before I write any code

00:14:00,500 --> 00:14:08,520
sorry this is the the queer we're going

00:14:04,680 --> 00:14:10,970
to use in our in our component and it

00:14:08,520 --> 00:14:13,350
should give us all the data that we need

00:14:10,970 --> 00:14:18,240
so now let's use that query in our

00:14:13,350 --> 00:14:19,800
component react hooks are great so let's

00:14:18,240 --> 00:14:22,529
use the use query hook that we just

00:14:19,800 --> 00:14:25,770
learned about you can see how simple and

00:14:22,529 --> 00:14:28,950
declarative it is first we display a

00:14:25,770 --> 00:14:32,779
loading state and then standard react

00:14:28,950 --> 00:14:35,240
syntax to loop over the data and render

00:14:32,779 --> 00:14:37,649
now let's check out the type definitions

00:14:35,240 --> 00:14:42,330
fetching is already typed by Oracle as a

00:14:37,649 --> 00:14:44,520
boolean however data is not we need to

00:14:42,330 --> 00:14:46,950
define an a type script interface which

00:14:44,520 --> 00:14:48,990
matches the query that we wrote in the

00:14:46,950 --> 00:14:52,320
previous slide and then pass it as a

00:14:48,990 --> 00:14:54,209
generic to the used query hook and the

00:14:52,320 --> 00:14:57,779
query variables unfortunately there's

00:14:54,209 --> 00:14:59,880
not much type safety here but we have a

00:14:57,779 --> 00:15:03,270
mostly say type safe component which is

00:14:59,880 --> 00:15:05,160
pretty great this was our our first

00:15:03,270 --> 00:15:07,560
attempt in it and I think it's it's

00:15:05,160 --> 00:15:11,070
pretty great we have a type safe server

00:15:07,560 --> 00:15:14,940
and client application but there are a

00:15:11,070 --> 00:15:16,860
few problems with this approach it was

00:15:14,940 --> 00:15:18,810
really tedious to manually type the

00:15:16,860 --> 00:15:21,500
resolvers and there was a lot of

00:15:18,810 --> 00:15:21,500
duplication

00:15:25,880 --> 00:15:29,430
so let's go back to the server resolver

00:15:28,290 --> 00:15:31,020
type again and compare it with the

00:15:29,430 --> 00:15:33,420
schema now look at all the manual

00:15:31,020 --> 00:15:36,270
duplication we have here the entities

00:15:33,420 --> 00:15:39,300
are duplicated the resolver object is

00:15:36,270 --> 00:15:40,980
duplicated and our resolver map and

00:15:39,300 --> 00:15:42,780
resolver function arguments are typed

00:15:40,980 --> 00:15:46,500
with any it doesn't give us much type

00:15:42,780 --> 00:15:48,870
much confidence let's go back to our

00:15:46,500 --> 00:15:50,880
front-end types again and compare that

00:15:48,870 --> 00:15:54,060
with the schema we see more of the same

00:15:50,880 --> 00:15:56,340
here the query name and return type are

00:15:54,060 --> 00:15:59,430
duplicated the character entity is

00:15:56,340 --> 00:16:02,100
duplicated parts of the TV season are

00:15:59,430 --> 00:16:05,700
and are duplicated and same with the

00:16:02,100 --> 00:16:07,830
allegiance entity and here's another

00:16:05,700 --> 00:16:11,790
problem what happens if we make a change

00:16:07,830 --> 00:16:13,800
to the graph QL schema let's change the

00:16:11,790 --> 00:16:18,570
name field here on the character entity

00:16:13,800 --> 00:16:21,150
to be optional those types that we wrote

00:16:18,570 --> 00:16:23,700
in our resolver and on our queries are

00:16:21,150 --> 00:16:24,930
now wrong but typescript won't throw an

00:16:23,700 --> 00:16:28,650
error because it doesn't even know about

00:16:24,930 --> 00:16:31,670
them the user gets a runtime error which

00:16:28,650 --> 00:16:31,670
is bad

00:16:32,150 --> 00:16:38,490
so type safe code isn't enough what we

00:16:35,880 --> 00:16:41,790
really need is type safe code based on a

00:16:38,490 --> 00:16:43,890
single source of truth we need one place

00:16:41,790 --> 00:16:46,770
to define our types that works across

00:16:43,890 --> 00:16:49,500
our stack and I contend that the graph

00:16:46,770 --> 00:16:51,680
QL schema should be that single source

00:16:49,500 --> 00:16:51,680
of truth

00:16:52,820 --> 00:16:56,670
that's all well and good but how can we

00:16:54,870 --> 00:17:00,510
actually accomplish that in an automated

00:16:56,670 --> 00:17:03,060
way graph QL code generator is an

00:17:00,510 --> 00:17:05,040
amazing CLI tool that understands your

00:17:03,060 --> 00:17:07,530
schema and can generate types and code

00:17:05,040 --> 00:17:09,209
for you it's really great you've

00:17:07,530 --> 00:17:09,770
probably heard it mentioned at previous

00:17:09,209 --> 00:17:14,550
talks today

00:17:09,770 --> 00:17:16,199
and lots of people are taking notice so

00:17:14,550 --> 00:17:18,150
let's start by going back to our

00:17:16,199 --> 00:17:23,069
resolver and changing it to use the

00:17:18,150 --> 00:17:26,069
generated types here's an example

00:17:23,069 --> 00:17:27,209
example configuration for the tool don't

00:17:26,069 --> 00:17:29,720
worry about all the options I'm just

00:17:27,209 --> 00:17:32,550
going to point out a couple of things

00:17:29,720 --> 00:17:36,660
this field tells the tool where to find

00:17:32,550 --> 00:17:38,520
your graph ul schema and this field will

00:17:36,660 --> 00:17:42,179
tell the tool where to actually output

00:17:38,520 --> 00:17:44,160
the generated code here's an example of

00:17:42,179 --> 00:17:45,540
some output that you'll get it's not

00:17:44,160 --> 00:17:47,760
important to understand all of this

00:17:45,540 --> 00:17:50,840
stuff but I wanted to show you what it

00:17:47,760 --> 00:18:00,960
generates to prove that it's not magic

00:17:50,840 --> 00:18:05,130
here are our entities resolvers details

00:18:00,960 --> 00:18:07,260
about the query resolvers and then

00:18:05,130 --> 00:18:12,500
details about the get characters query

00:18:07,260 --> 00:18:12,500
the parameters and the return type

00:18:13,400 --> 00:18:18,180
so let's update our resolver so user

00:18:15,780 --> 00:18:26,520
generated type style so you remember

00:18:18,180 --> 00:18:27,990
this not great I love her so we can

00:18:26,520 --> 00:18:30,960
remove all of the manual duplicated

00:18:27,990 --> 00:18:33,030
types the only thing we're using is this

00:18:30,960 --> 00:18:35,340
one imported interface from the

00:18:33,030 --> 00:18:38,970
generated code but everything is still

00:18:35,340 --> 00:18:41,360
fully typed context arguments and return

00:18:38,970 --> 00:18:41,360
value

00:18:52,890 --> 00:18:57,000
now let's make a change to the schema by

00:18:55,470 --> 00:19:03,870
removing the sort Direction parameter

00:18:57,000 --> 00:19:05,429
here to me this is the coolest part we

00:19:03,870 --> 00:19:07,530
immediately get a helpful type script

00:19:05,429 --> 00:19:09,090
error showing us the places in our code

00:19:07,530 --> 00:19:11,340
that need to be updated for that schema

00:19:09,090 --> 00:19:13,140
change the user won't ever see this

00:19:11,340 --> 00:19:16,500
error because we fixed it at compile

00:19:13,140 --> 00:19:18,980
time and as I mentioned before compiler

00:19:16,500 --> 00:19:23,100
errors are better than runtime errors

00:19:18,980 --> 00:19:26,549
Littlefinger agrees so let's go back to

00:19:23,100 --> 00:19:28,950
the front end app now so we're gonna

00:19:26,549 --> 00:19:30,750
look at config again you don't need to

00:19:28,950 --> 00:19:31,950
understand all the pieces of it I just

00:19:30,750 --> 00:19:34,440
want to point out a few things

00:19:31,950 --> 00:19:36,179
so this documents field is where you

00:19:34,440 --> 00:19:40,740
tell the tool where to find all of your

00:19:36,179 --> 00:19:42,450
queries and mutations this is the file

00:19:40,740 --> 00:19:44,490
that it's going to generate and then

00:19:42,450 --> 00:19:47,970
finally it has a plug-in system that

00:19:44,490 --> 00:19:52,500
supports many popular clients including

00:19:47,970 --> 00:19:54,419
Arkell Apollo what this what this

00:19:52,500 --> 00:19:56,190
plug-in does is it not only generates

00:19:54,419 --> 00:19:58,710
types that work in Oracle it actually

00:19:56,190 --> 00:20:03,240
generates components and hooks like

00:19:58,710 --> 00:20:05,130
fully functional react components so

00:20:03,240 --> 00:20:06,540
here's a snippet of the output again

00:20:05,130 --> 00:20:07,799
it's not important to understand all

00:20:06,540 --> 00:20:10,230
this stuff I just wanted to show you

00:20:07,799 --> 00:20:12,419
what it generates but the most important

00:20:10,230 --> 00:20:18,840
part is this react hook that it

00:20:12,419 --> 00:20:20,610
generated used character list query so

00:20:18,840 --> 00:20:24,600
let's update our component so this is

00:20:20,610 --> 00:20:26,990
what we had before and this is what we

00:20:24,600 --> 00:20:26,990
have now

00:20:27,020 --> 00:20:34,720
we are only using that single generated

00:20:29,600 --> 00:20:37,160
hook but everything is still fully typed

00:20:34,720 --> 00:20:40,809
check out all of the intellisense we get

00:20:37,160 --> 00:20:40,809
from this single import

00:20:54,550 --> 00:21:02,770
let's make that same schema change again

00:20:56,620 --> 00:21:04,300
and see how it affects the client we see

00:21:02,770 --> 00:21:06,550
again we immediately get a helpful type

00:21:04,300 --> 00:21:08,760
script error showing us the places in

00:21:06,550 --> 00:21:11,080
our code that needs to be updated and

00:21:08,760 --> 00:21:15,580
again the user won't ever see this error

00:21:11,080 --> 00:21:17,530
because we fixed it at compile time so

00:21:15,580 --> 00:21:20,290
whatever you accomplished we now have a

00:21:17,530 --> 00:21:23,230
fully typesafe client and server but

00:21:20,290 --> 00:21:25,420
most importantly it will stay in sync as

00:21:23,230 --> 00:21:29,860
we update our schema queries and

00:21:25,420 --> 00:21:32,220
mutations in our first attempt we did

00:21:29,860 --> 00:21:35,440
pretty well but there were some problems

00:21:32,220 --> 00:21:39,460
but our final approach solved nearly all

00:21:35,440 --> 00:21:41,800
of these problems before I finish I

00:21:39,460 --> 00:21:44,260
wanted to say a moment about this

00:21:41,800 --> 00:21:46,840
project open source powers so much of

00:21:44,260 --> 00:21:48,970
the world today and maintainer x' often

00:21:46,840 --> 00:21:50,800
end up burnout and unappreciated so I

00:21:48,970 --> 00:21:53,020
wanted to give a public shout out to doe

00:21:50,800 --> 00:21:56,290
tan for all the work he does on this

00:21:53,020 --> 00:21:58,330
tool thanks for coming if you'd like to

00:21:56,290 --> 00:22:00,130
chat about anything please introduce

00:21:58,330 --> 00:22:05,049
yourself

00:22:00,130 --> 00:22:05,049

YouTube URL: https://www.youtube.com/watch?v=AgJ1n75ibCo


