Title: What About the Database? How to Write Efficient Queries for GraphQL Resolvers (RYAN CHENKIE)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	When writing GraphQL servers, we often place a lot of emphasis on how to craft good resolvers. However, we don't often think about how to create good database queries to furnish the data for those resolvers. Let's look at how it's easy to fall into the trap of writing inefficient database queries and how we can use GraphQL itself to solve this problem.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:01,900 --> 00:00:05,899
thank you thank you so much it's really

00:00:03,980 --> 00:00:08,870
good to be here this is uh number three

00:00:05,899 --> 00:00:10,850
for me in terms of graph GL some it's

00:00:08,870 --> 00:00:12,920
third year in a row I'm really excited

00:00:10,850 --> 00:00:15,020
to be here again and I want to talk to

00:00:12,920 --> 00:00:17,150
you today about the database layer this

00:00:15,020 --> 00:00:18,880
is going to be a talk that hopefully

00:00:17,150 --> 00:00:22,430
complements wills talk that he just gave

00:00:18,880 --> 00:00:25,280
to maybe give us all some ideas around

00:00:22,430 --> 00:00:27,380
what we might do if we have control of

00:00:25,280 --> 00:00:29,869
our database if that's something that's

00:00:27,380 --> 00:00:31,940
in our hands and we're able to maybe use

00:00:29,869 --> 00:00:34,610
that info object that will was talking

00:00:31,940 --> 00:00:37,489
about to make more efficient queries

00:00:34,610 --> 00:00:39,590
that's the the idea today so as Jake

00:00:37,489 --> 00:00:41,809
mentioned my name is Ryan chengqi I'm a

00:00:39,590 --> 00:00:43,880
full-stack developer do a lot of work as

00:00:41,809 --> 00:00:46,280
a consultant building applications for

00:00:43,880 --> 00:00:49,460
companies I'm doing a lot of react and

00:00:46,280 --> 00:00:51,469
angular node and of course graph QL and

00:00:49,460 --> 00:00:53,629
I do a lot of stuff with Google for

00:00:51,469 --> 00:00:57,320
their developer experts program as well

00:00:53,629 --> 00:00:59,840
so question why do we all love graph QL

00:00:57,320 --> 00:01:01,879
I mean everyone's got their own reasons

00:00:59,840 --> 00:01:04,900
but some of the typical ones might be

00:01:01,879 --> 00:01:07,369
things like discoverability if you are a

00:01:04,900 --> 00:01:10,880
you're developing a client application

00:01:07,369 --> 00:01:12,500
right we can peer into the graph QL API

00:01:10,880 --> 00:01:14,630
that we're calling into and see what's

00:01:12,500 --> 00:01:16,340
available we've got these client server

00:01:14,630 --> 00:01:18,680
contracts the server is able to say I

00:01:16,340 --> 00:01:20,390
have these things and the client is able

00:01:18,680 --> 00:01:21,860
to say I want these things and they're

00:01:20,390 --> 00:01:24,710
able to communicate with one another to

00:01:21,860 --> 00:01:26,180
ensure that what the application client

00:01:24,710 --> 00:01:28,520
application wants is something the

00:01:26,180 --> 00:01:30,049
server can give back and I think another

00:01:28,520 --> 00:01:31,970
one that we all love would be the

00:01:30,049 --> 00:01:34,729
efficiencies that we can get with graph

00:01:31,970 --> 00:01:37,549
QL so things like not needing to make

00:01:34,729 --> 00:01:39,439
multiple round-trip requests not over

00:01:37,549 --> 00:01:42,020
fetching getting back only the fields

00:01:39,439 --> 00:01:43,579
that we want that sort of thing and it's

00:01:42,020 --> 00:01:47,299
that last one that I would like to touch

00:01:43,579 --> 00:01:50,720
on today to see how we can maybe make

00:01:47,299 --> 00:01:54,439
things more efficient so when we make a

00:01:50,720 --> 00:01:55,909
query with graph QL as we probably know

00:01:54,439 --> 00:01:58,759
it resolves with exactly the data we

00:01:55,909 --> 00:02:01,130
want we ask for a certain set of fields

00:01:58,759 --> 00:02:02,750
and we might get back we'll need those

00:02:01,130 --> 00:02:05,329
fields and we shouldn't get back only

00:02:02,750 --> 00:02:08,030
those fields but what about the database

00:02:05,329 --> 00:02:09,469
now depending on how our resolvers are

00:02:08,030 --> 00:02:11,930
set up which kind of data sources

00:02:09,469 --> 00:02:13,730
they're calling into it's maybe not

00:02:11,930 --> 00:02:16,099
always the case that we automatic

00:02:13,730 --> 00:02:18,200
we get only the fields that we asked for

00:02:16,099 --> 00:02:22,220
from the query so we might get these

00:02:18,200 --> 00:02:24,620
efficiencies from the client layer to

00:02:22,220 --> 00:02:27,500
get back only that data that we want but

00:02:24,620 --> 00:02:29,299
our back-end things might be more might

00:02:27,500 --> 00:02:30,860
be inefficient in some ways so the

00:02:29,299 --> 00:02:32,930
question is then how can we use graph QL

00:02:30,860 --> 00:02:35,810
to improve our database queries

00:02:32,930 --> 00:02:38,599
themselves there's a few use cases that

00:02:35,810 --> 00:02:40,819
I want to kind of go over so caveat here

00:02:38,599 --> 00:02:42,799
these are kind of bare-bones

00:02:40,819 --> 00:02:45,260
use cases these are things that are not

00:02:42,799 --> 00:02:46,760
super well fleshed out the code examples

00:02:45,260 --> 00:02:49,489
here you probably don't want to go put

00:02:46,760 --> 00:02:51,170
into production right away but they show

00:02:49,489 --> 00:02:53,690
us they give us a really good glimpse of

00:02:51,170 --> 00:02:56,030
how things are gonna sort of work under

00:02:53,690 --> 00:02:57,680
the hood if we have control over our

00:02:56,030 --> 00:02:59,720
graph DL server and more importantly

00:02:57,680 --> 00:03:01,250
control over our database so the first

00:02:59,720 --> 00:03:03,920
one we'll talk about it would be scope

00:03:01,250 --> 00:03:05,900
selections so that would be taking the

00:03:03,920 --> 00:03:09,140
information from the graph QL query

00:03:05,900 --> 00:03:11,299
itself and using that to inform our

00:03:09,140 --> 00:03:13,760
database which fields it should give

00:03:11,299 --> 00:03:16,730
back we'll talk about sorts and limits

00:03:13,760 --> 00:03:18,919
for sub selections so basically passing

00:03:16,730 --> 00:03:23,030
arguments into kind of a sub selection

00:03:18,919 --> 00:03:24,889
of a query we'll talk about the info so

00:03:23,030 --> 00:03:27,620
how we might intersect auth info from

00:03:24,889 --> 00:03:29,630
something like a JSON web token to build

00:03:27,620 --> 00:03:31,910
out a query for our database that's a

00:03:29,630 --> 00:03:34,370
little bit more efficient in terms of

00:03:31,910 --> 00:03:36,650
how a developer might interact with it

00:03:34,370 --> 00:03:37,579
for example and then the last one which

00:03:36,650 --> 00:03:39,950
is kind of interesting would be

00:03:37,579 --> 00:03:43,130
protection from deeply nested queries so

00:03:39,950 --> 00:03:46,310
if you've got any data that is self or

00:03:43,130 --> 00:03:47,959
maybe say two kinds of data that

00:03:46,310 --> 00:03:50,870
reference one another in a circular

00:03:47,959 --> 00:03:53,989
fashion how we can how we can protect

00:03:50,870 --> 00:03:55,130
ourselves from deeply nested queries so

00:03:53,989 --> 00:03:58,489
note on these examples we're using

00:03:55,130 --> 00:04:00,799
MongoDB here for example but it's

00:03:58,489 --> 00:04:04,340
applicable anywhere this is just kind of

00:04:00,799 --> 00:04:06,139
my database of preference and it's one

00:04:04,340 --> 00:04:08,209
that's good for sharing examples but the

00:04:06,139 --> 00:04:12,169
same concepts can be maps basically to

00:04:08,209 --> 00:04:15,019
whatever you are using so it is all

00:04:12,169 --> 00:04:18,070
about the ast the abstract syntax tree

00:04:15,019 --> 00:04:22,250
so this is a big topic lots of different

00:04:18,070 --> 00:04:24,740
ways to apply a STS to computing lots of

00:04:22,250 --> 00:04:27,200
you know it's a it's a very very rich

00:04:24,740 --> 00:04:28,940
topic we won't go too much into it

00:04:27,200 --> 00:04:30,590
since she had say this that there's code

00:04:28,940 --> 00:04:32,600
for humans there's code for us to

00:04:30,590 --> 00:04:35,480
understand but then there's code for

00:04:32,600 --> 00:04:36,320
computers or maybe programs is the

00:04:35,480 --> 00:04:38,360
better way to put it

00:04:36,320 --> 00:04:40,940
to understand and it's an example of

00:04:38,360 --> 00:04:42,980
that here's a graphical query we

00:04:40,940 --> 00:04:45,290
probably are familiar with what this

00:04:42,980 --> 00:04:47,600
does asking for a books resource getting

00:04:45,290 --> 00:04:50,000
three fields from it

00:04:47,600 --> 00:04:51,740
what graph QL wants to do though is it

00:04:50,000 --> 00:04:53,690
wants to take something more like this

00:04:51,740 --> 00:04:56,210
something that is way more fleshed out

00:04:53,690 --> 00:04:59,480
with much more information about that

00:04:56,210 --> 00:05:02,330
query so what you can see here is that

00:04:59,480 --> 00:05:06,410
it's a giant object essentially with

00:05:02,330 --> 00:05:09,470
lots of different fields that inform

00:05:06,410 --> 00:05:12,920
what that query represents so things

00:05:09,470 --> 00:05:15,320
like you know a field itself with a

00:05:12,920 --> 00:05:18,290
certain kind and a certain value for

00:05:15,320 --> 00:05:20,570
that a set of selections that would be

00:05:18,290 --> 00:05:21,920
found on that field that is been queried

00:05:20,570 --> 00:05:24,740
before and so this is something that can

00:05:21,920 --> 00:05:26,540
be better understood by graph QL so we

00:05:24,740 --> 00:05:28,520
take that graph kill query we translate

00:05:26,540 --> 00:05:30,440
it into something that the computer or

00:05:28,520 --> 00:05:33,380
the program can understand that

00:05:30,440 --> 00:05:34,960
something is the ast so abstract because

00:05:33,380 --> 00:05:36,710
it can be anything

00:05:34,960 --> 00:05:39,320
syntax because it has to do with

00:05:36,710 --> 00:05:40,940
programming syntax and tree because it's

00:05:39,320 --> 00:05:43,190
a essentially just a giant tree

00:05:40,940 --> 00:05:46,700
structure so it's a big object with many

00:05:43,190 --> 00:05:48,470
layers of nested objects within so es

00:05:46,700 --> 00:05:50,000
T's are useful for us here because we

00:05:48,470 --> 00:05:51,410
can sort of extend graph Kiehl's

00:05:50,000 --> 00:05:54,440
capabilities we can do this

00:05:51,410 --> 00:05:56,240
programmatically so we can you know we

00:05:54,440 --> 00:05:58,130
can traverse over this ast we can pull

00:05:56,240 --> 00:06:01,640
information from it we can augment a

00:05:58,130 --> 00:06:04,640
query programmatically and that's kind

00:06:01,640 --> 00:06:06,440
of what we want to do here so the

00:06:04,640 --> 00:06:08,450
question is this then how can we

00:06:06,440 --> 00:06:10,400
interactive it and if you were in the

00:06:08,450 --> 00:06:12,710
last talk you saw that we'll two lists

00:06:10,400 --> 00:06:14,990
we've got this fourth argument here

00:06:12,710 --> 00:06:17,090
you know our resolvers so we've got this

00:06:14,990 --> 00:06:21,320
info arguments which is where we would

00:06:17,090 --> 00:06:23,090
find the graph QL ast and so many very

00:06:21,320 --> 00:06:25,280
useful pieces of information on it we'll

00:06:23,090 --> 00:06:28,280
touched on some the ones that will sort

00:06:25,280 --> 00:06:30,710
of look at for our purposes today will

00:06:28,280 --> 00:06:33,680
be these guys field note selection sets

00:06:30,710 --> 00:06:36,710
and selections so this will be stuff it

00:06:33,680 --> 00:06:38,930
might be at a first pass relevant to you

00:06:36,710 --> 00:06:40,430
as a developer if you want to interact

00:06:38,930 --> 00:06:41,720
with the ASD and

00:06:40,430 --> 00:06:45,590
this is kind of how things map together

00:06:41,720 --> 00:06:48,500
right we've got books mapping to this

00:06:45,590 --> 00:06:51,080
first field note here which has a it has

00:06:48,500 --> 00:06:53,210
a kind of value of name and has a value

00:06:51,080 --> 00:06:54,979
of books on there we've got a set of

00:06:53,210 --> 00:06:58,000
selections underneath and so these

00:06:54,979 --> 00:07:01,970
things map together here within the ASD

00:06:58,000 --> 00:07:04,130
so lots more information is out there

00:07:01,970 --> 00:07:05,509
about a STS I'd recommend some resources

00:07:04,130 --> 00:07:08,060
here I just put them in some bit ly

00:07:05,509 --> 00:07:11,720
links for you to grab some nice articles

00:07:08,060 --> 00:07:14,270
that are particular to the graph QL ast

00:07:11,720 --> 00:07:17,360
but ast is in general a very very

00:07:14,270 --> 00:07:18,260
wide-ranging topic okay so let's look at

00:07:17,360 --> 00:07:21,260
some examples

00:07:18,260 --> 00:07:24,350
scope selections to start out with so

00:07:21,260 --> 00:07:25,789
let's say we make a query from our front

00:07:24,350 --> 00:07:28,010
ends we want to get back those three

00:07:25,789 --> 00:07:30,169
fields title author and publish date

00:07:28,010 --> 00:07:32,479
well this is what we get back we expect

00:07:30,169 --> 00:07:35,389
to get back only those fields that we

00:07:32,479 --> 00:07:37,400
query for but maybe this is what the

00:07:35,389 --> 00:07:39,470
database gives back to the graphical

00:07:37,400 --> 00:07:42,080
server before giving that information

00:07:39,470 --> 00:07:44,150
back to the client right so here we've

00:07:42,080 --> 00:07:48,800
got you know not such a big deal to

00:07:44,150 --> 00:07:50,539
records seven fields on each but if you

00:07:48,800 --> 00:07:52,639
are really using to its full

00:07:50,539 --> 00:07:53,120
capabilities this can be way bigger I

00:07:52,639 --> 00:07:56,630
think

00:07:53,120 --> 00:07:59,570
document sizes in are capped at 16

00:07:56,630 --> 00:08:01,180
megabytes per document which I don't

00:07:59,570 --> 00:08:04,090
know that's a little bit while to use

00:08:01,180 --> 00:08:07,039
document at that size but the point is

00:08:04,090 --> 00:08:08,840
we could have a set of in from set of

00:08:07,039 --> 00:08:11,180
data that's way bigger than we actually

00:08:08,840 --> 00:08:14,810
need pass back from our database so

00:08:11,180 --> 00:08:17,570
let's use the graph QL ast to only get

00:08:14,810 --> 00:08:20,030
the data that we want from the database

00:08:17,570 --> 00:08:22,340
so what we want to do essentially is

00:08:20,030 --> 00:08:24,580
take this query here books with those

00:08:22,340 --> 00:08:26,510
three fields we want to turn it into

00:08:24,580 --> 00:08:29,389
something that looks a little bit like

00:08:26,510 --> 00:08:31,880
this I'm using a library called Mongoose

00:08:29,389 --> 00:08:33,919
sits on top of gives a nice API

00:08:31,880 --> 00:08:37,159
for making queries and that sort of

00:08:33,919 --> 00:08:39,140
thing and we want to select only those

00:08:37,159 --> 00:08:41,750
fields that we've actually query for

00:08:39,140 --> 00:08:44,959
from the client and really all that

00:08:41,750 --> 00:08:47,000
comes down to is turning whatever those

00:08:44,959 --> 00:08:49,250
selections from our client query are

00:08:47,000 --> 00:08:52,820
into a string that we can shuffle off

00:08:49,250 --> 00:08:54,420
into our database call so we might have

00:08:52,820 --> 00:08:56,730
a function that looks a little bit like

00:08:54,420 --> 00:08:58,440
something like get query selections and

00:08:56,730 --> 00:09:00,870
it's gonna operate on that field nodes

00:08:58,440 --> 00:09:03,630
key and just kind of map over it

00:09:00,870 --> 00:09:05,850
take the selections flatten it get the

00:09:03,630 --> 00:09:07,440
value et cetera very quick and dirty way

00:09:05,850 --> 00:09:09,270
of doing this there's many more

00:09:07,440 --> 00:09:11,010
contingencies that you would need things

00:09:09,270 --> 00:09:13,500
like what about if you have sub

00:09:11,010 --> 00:09:15,390
selections that go deeper right so but

00:09:13,500 --> 00:09:19,950
this is a very kind of rudimentary way

00:09:15,390 --> 00:09:21,810
of putting together that string so then

00:09:19,950 --> 00:09:24,150
what you do is in your resolver you can

00:09:21,810 --> 00:09:27,000
just say let's get those selections from

00:09:24,150 --> 00:09:29,250
that info object and then in that get

00:09:27,000 --> 00:09:30,720
books call which delegates to a database

00:09:29,250 --> 00:09:33,120
call we could just pass in those

00:09:30,720 --> 00:09:34,890
selections and what we've got is this

00:09:33,120 --> 00:09:37,740
string that just has title author and

00:09:34,890 --> 00:09:40,710
publish date so this is a good way to

00:09:37,740 --> 00:09:43,560
take the info that you already got from

00:09:40,710 --> 00:09:47,820
your query and use that to inform your

00:09:43,560 --> 00:09:52,260
database call itself okay let's talk

00:09:47,820 --> 00:09:55,110
about sorts and limits specifically from

00:09:52,260 --> 00:09:57,420
sub selections so we can get arguments

00:09:55,110 --> 00:09:59,640
right from a graphical query if our

00:09:57,420 --> 00:10:01,620
schema is set up such that we accept

00:09:59,640 --> 00:10:03,870
arguments in a certain field for example

00:10:01,620 --> 00:10:05,730
we can do something like this right we

00:10:03,870 --> 00:10:08,190
got contacts we can say have this

00:10:05,730 --> 00:10:09,660
argument of limits only give us 10 that

00:10:08,190 --> 00:10:12,360
you know that would be a it would be

00:10:09,660 --> 00:10:15,209
easy in this case to grab that arguments

00:10:12,360 --> 00:10:16,830
it's on that second argument there you

00:10:15,209 --> 00:10:19,890
know we'll call the params also called

00:10:16,830 --> 00:10:21,300
args you can get that right away you

00:10:19,890 --> 00:10:23,700
would have this object with a limit of

00:10:21,300 --> 00:10:27,000
10 however if you were to do something

00:10:23,700 --> 00:10:28,890
like this where you want to set a limit

00:10:27,000 --> 00:10:31,230
on that sub-selection

00:10:28,890 --> 00:10:34,320
well you're not going to be able to get

00:10:31,230 --> 00:10:36,779
that information in that second argument

00:10:34,320 --> 00:10:39,029
like we did just previously it's gonna

00:10:36,779 --> 00:10:40,860
be an empty object in this case so what

00:10:39,029 --> 00:10:42,270
do we do well lots of different ways you

00:10:40,860 --> 00:10:45,150
can set up your resolvers - maybe

00:10:42,270 --> 00:10:47,400
interact with one another but if we have

00:10:45,150 --> 00:10:50,760
access to that ast we could for example

00:10:47,400 --> 00:10:53,910
map over what's in there and take the

00:10:50,760 --> 00:10:57,540
arguments so because the ast has very

00:10:53,910 --> 00:10:59,850
specific info about what what each piece

00:10:57,540 --> 00:11:01,800
of the query is we can look for anything

00:10:59,850 --> 00:11:04,800
in this last line here where we're

00:11:01,800 --> 00:11:06,959
filtering with a kind that is equal to

00:11:04,800 --> 00:11:07,709
arguments again quick and dirty way of

00:11:06,959 --> 00:11:10,470
doing this

00:11:07,709 --> 00:11:13,829
glosses over a lot of detail but you can

00:11:10,470 --> 00:11:15,749
get those arguments like this maybe we

00:11:13,829 --> 00:11:17,519
set up another function where we say we

00:11:15,749 --> 00:11:19,410
want to get the limit and so we look

00:11:17,519 --> 00:11:22,649
over those raw arguments that are passed

00:11:19,410 --> 00:11:25,259
into that sub-query and we look for

00:11:22,649 --> 00:11:27,600
anything with a value of limit we pass

00:11:25,259 --> 00:11:30,119
that back and now we've got something

00:11:27,600 --> 00:11:34,259
that we can send to our database query

00:11:30,119 --> 00:11:37,980
to get that data with just a limit of 10

00:11:34,259 --> 00:11:40,100
for example so a good way to limit the

00:11:37,980 --> 00:11:44,819
amount of data that's going to come back

00:11:40,100 --> 00:11:46,829
ok intersecting with auth information so

00:11:44,819 --> 00:11:48,829
this one's interesting because there's

00:11:46,829 --> 00:11:50,790
different ways to set up your

00:11:48,829 --> 00:11:52,559
application obviously there's different

00:11:50,790 --> 00:11:55,889
ways to set up your database as it

00:11:52,559 --> 00:11:58,129
pertains to your use case a common one

00:11:55,889 --> 00:12:00,899
that I'm seeing is if you've got like a

00:11:58,129 --> 00:12:02,790
multi maybe maybe wouldn't call it a

00:12:00,899 --> 00:12:04,850
multi tenant to that but if you've got

00:12:02,790 --> 00:12:07,619
an application that has many different

00:12:04,850 --> 00:12:08,730
users in it that are each unto

00:12:07,619 --> 00:12:11,339
themselves in different organizations

00:12:08,730 --> 00:12:13,290
you got a couple options you can set up

00:12:11,339 --> 00:12:16,439
maybe a different database for each

00:12:13,290 --> 00:12:17,939
canon's for a lot of organizations

00:12:16,439 --> 00:12:19,819
that's a little bit overkill maybe they

00:12:17,939 --> 00:12:22,410
just want to have like one database

00:12:19,819 --> 00:12:24,839
blood separate the data based on keys

00:12:22,410 --> 00:12:28,040
and based on like IDs for each tenant

00:12:24,839 --> 00:12:32,129
and that's something that we can use

00:12:28,040 --> 00:12:34,980
graph QLS tools to help us maybe get a

00:12:32,129 --> 00:12:38,009
good layer to to help restrict calls to

00:12:34,980 --> 00:12:40,709
just the clients that are asking for the

00:12:38,009 --> 00:12:42,660
data so we don't always need to use a

00:12:40,709 --> 00:12:45,300
STS when we're doing stuff there's other

00:12:42,660 --> 00:12:47,040
tools within our graph QL resolvers and

00:12:45,300 --> 00:12:50,429
in this case we might just want to use

00:12:47,040 --> 00:12:53,009
that second argument so taking arguments

00:12:50,429 --> 00:12:55,290
and we might also want to use context

00:12:53,009 --> 00:12:58,470
graph QL gives us that third one called

00:12:55,290 --> 00:13:00,299
context and if we're using JSON web

00:12:58,470 --> 00:13:02,459
tokens I've spoken about this in

00:13:00,299 --> 00:13:04,589
previous years how to kind of tie

00:13:02,459 --> 00:13:08,189
together maybe an authorization layer to

00:13:04,589 --> 00:13:10,589
your graph QL server one way to do

00:13:08,189 --> 00:13:12,959
authorizations to use JSON web tokens in

00:13:10,589 --> 00:13:14,819
this example here I've got a token

00:13:12,959 --> 00:13:16,350
that's got a payload with a client ID in

00:13:14,819 --> 00:13:18,809
it and so that client ID

00:13:16,350 --> 00:13:21,960
perhaps that is like you know belonging

00:13:18,809 --> 00:13:24,330
to a specific organization or

00:13:21,960 --> 00:13:25,950
that is within your application maybe

00:13:24,330 --> 00:13:27,690
you've got users underneath that

00:13:25,950 --> 00:13:30,060
organization that each have their own

00:13:27,690 --> 00:13:33,150
sets of data access but maybe this one's

00:13:30,060 --> 00:13:36,300
just for particular organization what we

00:13:33,150 --> 00:13:39,210
can do is we can do this actually in the

00:13:36,300 --> 00:13:42,120
kind of server setup phase is we can set

00:13:39,210 --> 00:13:44,490
up some context to grab that client ID

00:13:42,120 --> 00:13:48,300
from the token and make that available

00:13:44,490 --> 00:13:50,880
on our context so what we're doing here

00:13:48,300 --> 00:13:52,170
we've got this get client ID function

00:13:50,880 --> 00:13:54,390
that's gonna take that authorization

00:13:52,170 --> 00:13:57,210
header and it's gonna do some things

00:13:54,390 --> 00:13:59,880
like verify that it's valid it's going

00:13:57,210 --> 00:14:02,220
to then decode the payload and get that

00:13:59,880 --> 00:14:04,440
client ID and if you're a bit unfamiliar

00:14:02,220 --> 00:14:05,940
with JSON web tokens and you're worried

00:14:04,440 --> 00:14:08,430
that maybe you know someone can come

00:14:05,940 --> 00:14:10,560
along and change that client ID and try

00:14:08,430 --> 00:14:13,050
to spoof themselves as another user or

00:14:10,560 --> 00:14:14,670
another organization as long as we're

00:14:13,050 --> 00:14:17,100
verifying the token with a strong seeker

00:14:14,670 --> 00:14:19,860
secret were safe because anytime someone

00:14:17,100 --> 00:14:21,450
goes to change the information that's in

00:14:19,860 --> 00:14:23,790
here it's going to invalidate the token

00:14:21,450 --> 00:14:26,850
so we're safe in that regard and this

00:14:23,790 --> 00:14:29,340
helps for us to have a nice stateless

00:14:26,850 --> 00:14:31,020
setup within our application because we

00:14:29,340 --> 00:14:33,270
can just trust that information that's

00:14:31,020 --> 00:14:35,280
coming in from the token and then we can

00:14:33,270 --> 00:14:38,580
delegate to an a to a database called

00:14:35,280 --> 00:14:41,700
and pass that information along so

00:14:38,580 --> 00:14:42,810
here's kind of a contrived example if

00:14:41,700 --> 00:14:46,140
you will of how you might put this

00:14:42,810 --> 00:14:48,540
together maybe we've got some resolver

00:14:46,140 --> 00:14:50,610
that takes an argument called starts

00:14:48,540 --> 00:14:52,410
with so maybe we want to look up some

00:14:50,610 --> 00:14:54,840
data that starts with a certain value

00:14:52,410 --> 00:14:58,680
right and we want to intersect that with

00:14:54,840 --> 00:15:01,110
what that user is allowed to get to well

00:14:58,680 --> 00:15:04,320
we could take you know we could take

00:15:01,110 --> 00:15:06,390
this this starts with argument put it on

00:15:04,320 --> 00:15:08,880
a message maybe we use the regex

00:15:06,390 --> 00:15:10,080
operator there with definitely

00:15:08,880 --> 00:15:11,490
wouldn't recommend doing it like I've

00:15:10,080 --> 00:15:13,110
got it here because you want to make

00:15:11,490 --> 00:15:15,870
sure that you're not allowing the client

00:15:13,110 --> 00:15:18,840
to put certain things into a query to

00:15:15,870 --> 00:15:21,290
have kind of no sequel injections but

00:15:18,840 --> 00:15:23,640
this demonstrates how you could do it

00:15:21,290 --> 00:15:25,980
you would kind of then make a scoped

00:15:23,640 --> 00:15:27,720
query you take that query along with

00:15:25,980 --> 00:15:30,030
your client ID put that together in a

00:15:27,720 --> 00:15:31,800
single object and then shuffle that off

00:15:30,030 --> 00:15:34,680
to your database call and that's your

00:15:31,800 --> 00:15:35,459
query so this last one we'll talk about

00:15:34,680 --> 00:15:36,990
this

00:15:35,459 --> 00:15:39,600
pending against deeply nested queries is

00:15:36,990 --> 00:15:42,300
pretty interesting there's a really good

00:15:39,600 --> 00:15:45,629
article put together by max Steinberg

00:15:42,300 --> 00:15:47,069
he's a developer that's started a

00:15:45,629 --> 00:15:49,619
company called spectrum you might be

00:15:47,069 --> 00:15:52,050
familiar with him he put together this

00:15:49,619 --> 00:15:55,019
article talking about things they needed

00:15:52,050 --> 00:15:57,089
to do or that they came across that they

00:15:55,019 --> 00:15:59,999
wanted to kind of defend against with

00:15:57,089 --> 00:16:04,619
their graph QL API and one of them is

00:15:59,999 --> 00:16:06,540
that they had data in their API that was

00:16:04,619 --> 00:16:09,480
kind of self referential with other

00:16:06,540 --> 00:16:12,569
things so you might have like for

00:16:09,480 --> 00:16:15,209
example I said a posts that have an

00:16:12,569 --> 00:16:17,189
author and those authors have posts and

00:16:15,209 --> 00:16:19,439
then those posts have authors and it

00:16:17,189 --> 00:16:22,290
just goes deeply nested like that

00:16:19,439 --> 00:16:24,629
meaning that it could be a perfectly

00:16:22,290 --> 00:16:27,809
valid call for somebody to make it Cori

00:16:24,629 --> 00:16:29,879
like this that just goes post authors

00:16:27,809 --> 00:16:33,689
post authors all the way down ad

00:16:29,879 --> 00:16:35,329
infinitum and that is not a great thing

00:16:33,689 --> 00:16:39,029
because you can have somebody

00:16:35,329 --> 00:16:42,449
essentially DDoS your your API at this

00:16:39,029 --> 00:16:46,220
point because the more lookups you have

00:16:42,449 --> 00:16:48,170
to do when this Cori comes in the more

00:16:46,220 --> 00:16:52,559
computational power you'll have to

00:16:48,170 --> 00:16:55,470
extend them so what can we do well we

00:16:52,559 --> 00:16:59,279
can use the ast to see how deep that

00:16:55,470 --> 00:17:03,420
selection set is so what we've got here

00:16:59,279 --> 00:17:06,720
is a nice little function that is

00:17:03,420 --> 00:17:09,059
recursive and it's going to take in the

00:17:06,720 --> 00:17:10,709
node that we're currently on its gonna

00:17:09,059 --> 00:17:13,409
keep track of a current depth and it's

00:17:10,709 --> 00:17:16,199
gonna see if we are exceeding a certain

00:17:13,409 --> 00:17:18,870
depth the way that we might use it then

00:17:16,199 --> 00:17:20,760
is we might have something like this we

00:17:18,870 --> 00:17:23,760
would get our selection depth based on

00:17:20,760 --> 00:17:25,439
our info arguments and then if that

00:17:23,760 --> 00:17:27,419
selection depth is greater than a

00:17:25,439 --> 00:17:30,570
certain amount that we want to allow we

00:17:27,419 --> 00:17:32,669
can air route this is um kind of what

00:17:30,570 --> 00:17:34,740
this library does actually graph you all

00:17:32,669 --> 00:17:37,500
depth limits and so this is a library

00:17:34,740 --> 00:17:40,289
that's ready to go for you it covers way

00:17:37,500 --> 00:17:42,750
more of the details that you would need

00:17:40,289 --> 00:17:44,980
to cover and this is something you can

00:17:42,750 --> 00:17:48,250
just plug right into your

00:17:44,980 --> 00:17:50,680
your schema setup level you can specify

00:17:48,250 --> 00:17:52,540
a depth limit you don't want you know

00:17:50,680 --> 00:17:54,430
your data to be query beyond ten layers

00:17:52,540 --> 00:17:56,020
deep for example and that's gonna be

00:17:54,430 --> 00:17:59,980
really useful for you to protect against

00:17:56,020 --> 00:18:03,760
that so we have got a few ways here

00:17:59,980 --> 00:18:06,640
maybe ideas of how you might make your

00:18:03,760 --> 00:18:09,190
database queries more efficient but

00:18:06,640 --> 00:18:10,930
there are some limitations one of them

00:18:09,190 --> 00:18:14,530
that I can think of is that at this

00:18:10,930 --> 00:18:15,940
point you're kind of coupling to excuse

00:18:14,530 --> 00:18:18,040
me coupling to the database layer

00:18:15,940 --> 00:18:20,230
coupling graph QL to your database in

00:18:18,040 --> 00:18:21,940
some way if you've got full control over

00:18:20,230 --> 00:18:23,470
your database and things aren't changing

00:18:21,940 --> 00:18:25,390
that much you know this might not be

00:18:23,470 --> 00:18:27,910
such a bad thing but it does introduce

00:18:25,390 --> 00:18:29,380
this dependency that you've got where it

00:18:27,910 --> 00:18:32,290
might be hard to break away from at

00:18:29,380 --> 00:18:33,820
later points and another limitation is

00:18:32,290 --> 00:18:36,250
you might not actually have full control

00:18:33,820 --> 00:18:38,440
over your database maybe you've got to

00:18:36,250 --> 00:18:40,420
Angel resolver make the call to another

00:18:38,440 --> 00:18:42,280
API maybe you don't have that much

00:18:40,420 --> 00:18:45,610
control over your database to begin with

00:18:42,280 --> 00:18:47,530
that can make things challenging so

00:18:45,610 --> 00:18:50,710
who's doing this in practice

00:18:47,530 --> 00:18:53,020
I don't know that super in-depth details

00:18:50,710 --> 00:18:56,560
about who would be doing this in

00:18:53,020 --> 00:18:58,510
particular but I know that Tom my here

00:18:56,560 --> 00:19:01,450
is gonna talk to you next about how

00:18:58,510 --> 00:19:02,940
Hazara uses some of these principles to

00:19:01,450 --> 00:19:06,310
construct relate efficient queries

00:19:02,940 --> 00:19:08,020
particularly with Postgres so he's going

00:19:06,310 --> 00:19:09,490
to talk to you about that next and then

00:19:08,020 --> 00:19:12,430
a lot of the ideas that I took here are

00:19:09,490 --> 00:19:15,190
actually from this library graph

00:19:12,430 --> 00:19:17,140
QL starter this is this library does a

00:19:15,190 --> 00:19:20,260
lot it's kind of like it's got things to

00:19:17,140 --> 00:19:22,060
auto generate code but it also takes a

00:19:20,260 --> 00:19:24,520
lot of the things that I talked about to

00:19:22,060 --> 00:19:26,890
construct way more efficient queries for

00:19:24,520 --> 00:19:29,170
MongoDB so I have a look at that that's

00:19:26,890 --> 00:19:33,310
a really good library to get some more

00:19:29,170 --> 00:19:34,720
inspiration from okay so I'm almost done

00:19:33,310 --> 00:19:37,090
it's a little bit early but I've got

00:19:34,720 --> 00:19:40,690
some treats for you before I go so it's

00:19:37,090 --> 00:19:42,940
Halloween the this the first one slides

00:19:40,690 --> 00:19:45,100
in code so you want to take a picture of

00:19:42,940 --> 00:19:48,840
this slide here this is where you would

00:19:45,100 --> 00:19:50,680
find firstly the slides secondly

00:19:48,840 --> 00:19:53,230
basically a project that's ready to go

00:19:50,680 --> 00:19:55,960
with examples of how you would do each

00:19:53,230 --> 00:19:58,330
of these things so check that out the

00:19:55,960 --> 00:20:00,659
second one is I've got this too

00:19:58,330 --> 00:20:04,330
site that I put together some time ago

00:20:00,659 --> 00:20:06,820
called try gql calm and it's kind of

00:20:04,330 --> 00:20:09,010
like an interactive tutorial takes you

00:20:06,820 --> 00:20:11,320
through the basics of graph QL so if you

00:20:09,010 --> 00:20:12,460
got colleagues that's having touch

00:20:11,320 --> 00:20:14,980
graphic you all at all it's a good

00:20:12,460 --> 00:20:16,600
starting point for them but it's fun to

00:20:14,980 --> 00:20:20,700
do even if your experience with graph QL

00:20:16,600 --> 00:20:23,830
- next one is something that I guess

00:20:20,700 --> 00:20:25,450
launches right now because I haven't

00:20:23,830 --> 00:20:26,470
really made super big announcements

00:20:25,450 --> 00:20:29,190
about it yet but something called graph

00:20:26,470 --> 00:20:31,210
collective and graph collective is

00:20:29,190 --> 00:20:33,429
basically a site that I'm putting

00:20:31,210 --> 00:20:36,610
together that is going to feature or

00:20:33,429 --> 00:20:37,870
does feature because it's here now lots

00:20:36,610 --> 00:20:40,440
of different folks within the graph QL

00:20:37,870 --> 00:20:44,230
community telling their stories about

00:20:40,440 --> 00:20:46,929
why they use graph QL what benefits they

00:20:44,230 --> 00:20:49,090
get from it's why developers tend to

00:20:46,929 --> 00:20:52,269
love it in general and so the hope here

00:20:49,090 --> 00:20:54,100
is that if your company maybe is on the

00:20:52,269 --> 00:20:56,950
fence about graph QL maybe if they're

00:20:54,100 --> 00:20:59,529
not so sure about it this will serve as

00:20:56,950 --> 00:21:02,139
a kind of a case study point where you

00:20:59,529 --> 00:21:04,990
can have maybe your your manager or your

00:21:02,139 --> 00:21:07,029
managers manager go and look to see why

00:21:04,990 --> 00:21:08,769
graph QL is beneficial and some of the

00:21:07,029 --> 00:21:11,799
success stories that exist in the

00:21:08,769 --> 00:21:13,990
community so I'd be super super stoked

00:21:11,799 --> 00:21:16,510
if you could all go to graph collective

00:21:13,990 --> 00:21:18,519
dot IO and that's gonna redirect you for

00:21:16,510 --> 00:21:22,419
now to YouTube where you can subscribe

00:21:18,519 --> 00:21:24,490
to the channel and also if you want to

00:21:22,419 --> 00:21:27,190
follow on Twitter it's at graph

00:21:24,490 --> 00:21:29,230
collective there so yeah I'd be super

00:21:27,190 --> 00:21:32,230
stoked if you guys kids check that out

00:21:29,230 --> 00:21:34,000
and pass it around but that's it so

00:21:32,230 --> 00:21:34,870
thanks so much for having me today

00:21:34,000 --> 00:21:38,250
and I'll be around

00:21:34,870 --> 00:21:38,250

YouTube URL: https://www.youtube.com/watch?v=XIlPRypoNOg


