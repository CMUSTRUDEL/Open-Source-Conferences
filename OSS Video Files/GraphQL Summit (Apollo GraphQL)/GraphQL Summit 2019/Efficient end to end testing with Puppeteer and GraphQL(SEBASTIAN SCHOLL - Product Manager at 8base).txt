Title: Efficient end to end testing with Puppeteer and GraphQL(SEBASTIAN SCHOLL - Product Manager at 8base)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Learn how to speed up client-side end-to-end tests by automatically recording server responses and using the snapshots to speed-up subsequent test runs.
Captions: 
	00:00:01,260 --> 00:00:04,500
all right so once again thank you guys

00:00:03,300 --> 00:00:06,089
all for coming

00:00:04,500 --> 00:00:08,969
my name is fashion and it's a pleasure

00:00:06,089 --> 00:00:10,379
to be here so in this talk while kind of

00:00:08,969 --> 00:00:11,820
preparing for it I was thinking because

00:00:10,379 --> 00:00:13,469
I like watching talks like how can I

00:00:11,820 --> 00:00:15,389
make a really inspiring awesome talk

00:00:13,469 --> 00:00:18,480
about Indian testing with puppeteer in

00:00:15,389 --> 00:00:20,490
graph QL snapshots then I thought that

00:00:18,480 --> 00:00:22,349
that's probably a pretty bad bet so I

00:00:20,490 --> 00:00:23,390
thought that how instead can we just

00:00:22,349 --> 00:00:25,560
make this as useful as possible

00:00:23,390 --> 00:00:26,730
something and make it something that you

00:00:25,560 --> 00:00:28,199
might actually want to implement and the

00:00:26,730 --> 00:00:31,199
applications you're building especially

00:00:28,199 --> 00:00:33,210
if you are doing and then testing so

00:00:31,199 --> 00:00:34,469
four stops a little bit about me my name

00:00:33,210 --> 00:00:36,210
is Sebastian Scholl and I'm the product

00:00:34,469 --> 00:00:38,969
manager at eat base pretty much I spend

00:00:36,210 --> 00:00:41,489
my days doing product feature design

00:00:38,969 --> 00:00:42,480
work on the Frog roadmap and then

00:00:41,489 --> 00:00:44,699
communicating with our engineer

00:00:42,480 --> 00:00:46,800
engineering teams a lot different

00:00:44,699 --> 00:00:50,340
initiatives that the business team needs

00:00:46,800 --> 00:00:51,390
have explained to them and kind of one

00:00:50,340 --> 00:00:53,340
things I liked you a lot is I like to

00:00:51,390 --> 00:00:55,320
blog so if you find me on medium or

00:00:53,340 --> 00:00:58,980
Twitter or LinkedIn I do a lot of

00:00:55,320 --> 00:01:00,660
article work so I love that one of the

00:00:58,980 --> 00:01:02,010
big things that happens in our

00:01:00,660 --> 00:01:04,199
development cycle I'm sure all of your

00:01:02,010 --> 00:01:06,270
guys development cycles is you run into

00:01:04,199 --> 00:01:07,140
tons of bottlenecks and really I kind of

00:01:06,270 --> 00:01:09,030
like to think about bottom line because

00:01:07,140 --> 00:01:11,520
anything that happens from when you have

00:01:09,030 --> 00:01:13,530
the idea to when you deploy the idea any

00:01:11,520 --> 00:01:15,060
writing code having to talk to someone

00:01:13,530 --> 00:01:17,970
paired program I mean everything that

00:01:15,060 --> 00:01:19,950
slows down or potentially makes any type

00:01:17,970 --> 00:01:21,690
of blip in the in the progress that

00:01:19,950 --> 00:01:22,740
you're making towards the outcome you

00:01:21,690 --> 00:01:24,060
can kind of think of a bottleneck and

00:01:22,740 --> 00:01:25,920
then that allows you to think of well

00:01:24,060 --> 00:01:27,210
how do we make this faster how do we

00:01:25,920 --> 00:01:29,580
improve this how can we make the

00:01:27,210 --> 00:01:32,700
turnaround happen and one of the things

00:01:29,580 --> 00:01:34,560
that we were running into at eighth base

00:01:32,700 --> 00:01:36,660
was that when we were doing in doing

00:01:34,560 --> 00:01:39,060
testing it was becoming a real

00:01:36,660 --> 00:01:41,610
bottleneck for us essentially ended test

00:01:39,060 --> 00:01:43,230
took the longest amount of time the X we

00:01:41,610 --> 00:01:46,500
belong some time to execute they're the

00:01:43,230 --> 00:01:49,590
most expensive since we were using eight

00:01:46,500 --> 00:01:50,850
of us lambda as a as an API we were

00:01:49,590 --> 00:01:52,650
having to do live calls to the server

00:01:50,850 --> 00:01:55,260
which was taking time and costing us

00:01:52,650 --> 00:01:57,660
money and then a lot of times these

00:01:55,260 --> 00:01:59,190
tests were failing for non client-side

00:01:57,660 --> 00:02:01,590
reasons so remember we were doing

00:01:59,190 --> 00:02:03,000
testing on the client-side so sometimes

00:02:01,590 --> 00:02:04,740
it was a blip in the server-side but

00:02:03,000 --> 00:02:06,120
that didn't really make the test the

00:02:04,740 --> 00:02:07,230
test would fail but it wasn't really

00:02:06,120 --> 00:02:09,030
what we were testing so then we'd have

00:02:07,230 --> 00:02:11,489
to rerun the sweet and reembarked on the

00:02:09,030 --> 00:02:13,230
process and so we started thinking of

00:02:11,489 --> 00:02:14,880
ways okay well how can we improve this

00:02:13,230 --> 00:02:16,440
process right how can we make

00:02:14,880 --> 00:02:18,960
get Cheaper by not actually having to

00:02:16,440 --> 00:02:21,120
get there were send API calls to the

00:02:18,960 --> 00:02:24,360
server how can we test for all basic

00:02:21,120 --> 00:02:26,280
user scenarios how can we run different

00:02:24,360 --> 00:02:28,230
types of tests based on the different

00:02:26,280 --> 00:02:29,550
points in our CI flow right because for

00:02:28,230 --> 00:02:31,830
example if we're just doing a feature

00:02:29,550 --> 00:02:33,240
branch we want the test to run but maybe

00:02:31,830 --> 00:02:35,550
we can run those ones faster than if

00:02:33,240 --> 00:02:37,260
we're doing a deploy to our master

00:02:35,550 --> 00:02:39,480
branch or merged a master branch and

00:02:37,260 --> 00:02:42,630
kind of splicing up our workflows there

00:02:39,480 --> 00:02:45,480
and so what we came up with was the

00:02:42,630 --> 00:02:46,860
solution using just and puppeteer now

00:02:45,480 --> 00:02:49,920
proof from there with puppeteer it's

00:02:46,860 --> 00:02:51,930
pretty much a high level browser API or

00:02:49,920 --> 00:02:53,550
a headless chrome API that you can use

00:02:51,930 --> 00:02:55,950
for a lot of different things but we

00:02:53,550 --> 00:02:59,130
were ended up using it for doing our

00:02:55,950 --> 00:03:00,870
tests or helping us execute our tests

00:02:59,130 --> 00:03:05,220
with jest and what we essentially

00:03:00,870 --> 00:03:07,890
designed was a gest tool that would hook

00:03:05,220 --> 00:03:10,170
into a few different events when we're

00:03:07,890 --> 00:03:11,700
running our tests capture graphical

00:03:10,170 --> 00:03:14,160
snapshots and then reuse those in the

00:03:11,700 --> 00:03:16,650
future and so we'll show kind of how

00:03:14,160 --> 00:03:18,960
that works and so what's happening when

00:03:16,650 --> 00:03:20,340
we use this okay well we're adding page

00:03:18,960 --> 00:03:23,460
event listeners to the request response

00:03:20,340 --> 00:03:24,750
and close events when a cool request is

00:03:23,460 --> 00:03:27,690
made it tracks it as something that's

00:03:24,750 --> 00:03:30,360
gonna have to be recorded later when a

00:03:27,690 --> 00:03:32,040
response is received it takes that

00:03:30,360 --> 00:03:33,450
request it takes that response and it

00:03:32,040 --> 00:03:35,520
makes kind of this little snapshot file

00:03:33,450 --> 00:03:37,560
that you can see on the right-hand side

00:03:35,520 --> 00:03:39,600
which is showing the operation name the

00:03:37,560 --> 00:03:40,860
variables the actual graphical query and

00:03:39,600 --> 00:03:43,560
then the response that we got back from

00:03:40,860 --> 00:03:45,810
it and then once we close that browser

00:03:43,560 --> 00:03:48,540
that's when it actually saves all those

00:03:45,810 --> 00:03:50,100
files right and then we can reuse those

00:03:48,540 --> 00:03:54,720
in the future to make our test run

00:03:50,100 --> 00:03:57,900
faster and more reliably so let's jump

00:03:54,720 --> 00:03:59,510
in and look at it really quickly so if I

00:03:57,900 --> 00:04:01,980
go over vs code I have this

00:03:59,510 --> 00:04:03,420
embarrassingly simple react app that

00:04:01,980 --> 00:04:06,030
we're gonna test pretty much all it does

00:04:03,420 --> 00:04:09,180
is queries our server and displays the

00:04:06,030 --> 00:04:10,860
company name on the page and if we go

00:04:09,180 --> 00:04:12,750
over to this index test that we have

00:04:10,860 --> 00:04:15,630
right here we see that we wrote a test

00:04:12,750 --> 00:04:17,850
we pass it to jest and then this

00:04:15,630 --> 00:04:22,350
decorates it or adds the event listeners

00:04:17,850 --> 00:04:24,690
to actually use the snapshots that we

00:04:22,350 --> 00:04:26,070
that we have and I think that we have

00:04:24,690 --> 00:04:26,980
good Wi-Fi right now because we've said

00:04:26,070 --> 00:04:29,350
we were avid I'm going to get

00:04:26,980 --> 00:04:31,480
chance I'm going to delete this MOX file

00:04:29,350 --> 00:04:31,930
right here hopefully I don't complete my

00:04:31,480 --> 00:04:35,980
test

00:04:31,930 --> 00:04:37,680
hmm and move that to the trash cool so

00:04:35,980 --> 00:04:40,320
then I'm gonna do is I'm gonna first

00:04:37,680 --> 00:04:42,820
let's actually first just run this

00:04:40,320 --> 00:04:46,180
normally so we can see that hey we're

00:04:42,820 --> 00:04:48,490
gonna run this test and it should run

00:04:46,180 --> 00:04:51,790
successfully but of course now I'm on

00:04:48,490 --> 00:04:54,310
stage so it won't cool and okay so let's

00:04:51,790 --> 00:04:55,840
try it one more time instance to what

00:04:54,310 --> 00:04:58,930
this is doing is running this test which

00:04:55,840 --> 00:05:01,600
is gonna go get the the browser or get

00:04:58,930 --> 00:05:03,130
the page and yeah it's not it's not

00:05:01,600 --> 00:05:04,180
running okay so let's try to update it

00:05:03,130 --> 00:05:04,500
let's see if we can get it to work this

00:05:04,180 --> 00:05:07,480
time

00:05:04,500 --> 00:05:08,770
so what I'm running now is I'm say k now

00:05:07,480 --> 00:05:12,010
when you run it and it makes that

00:05:08,770 --> 00:05:16,590
request actually save the snapshot right

00:05:12,010 --> 00:05:20,530
so it will add it to this directory here

00:05:16,590 --> 00:05:23,620
so funny I ran out two minutes ago okay

00:05:20,530 --> 00:05:29,230
one more try and then I'm gonna put my

00:05:23,620 --> 00:05:30,580
head down and move on alright so for

00:05:29,230 --> 00:05:32,470
some reason guys sorry is not working

00:05:30,580 --> 00:05:34,840
but essentially what was supposed to

00:05:32,470 --> 00:05:36,910
happen right so what's supposed to

00:05:34,840 --> 00:05:40,750
happen is that when we send that request

00:05:36,910 --> 00:05:44,080
that request event listener triggers it

00:05:40,750 --> 00:05:45,550
captures the query that we sent with all

00:05:44,080 --> 00:05:48,430
the parameters and the operation name

00:05:45,550 --> 00:05:50,760
then it stores it in a file or a folder

00:05:48,430 --> 00:05:53,500
right here which our request mocks and

00:05:50,760 --> 00:05:54,790
this is great because then whenever we

00:05:53,500 --> 00:05:56,500
are running on in the future we don't

00:05:54,790 --> 00:05:58,510
actually have to ping our server we can

00:05:56,500 --> 00:06:00,280
just look locally and it's almost like

00:05:58,510 --> 00:06:01,900
this perfect little thing that will then

00:06:00,280 --> 00:06:02,260
look to see if we already have done that

00:06:01,900 --> 00:06:04,270
before

00:06:02,260 --> 00:06:05,590
and use it in the future and running

00:06:04,270 --> 00:06:07,360
that update command whenever you know

00:06:05,590 --> 00:06:09,280
that hey we need to update or we want to

00:06:07,360 --> 00:06:11,290
run these things live it's gonna use the

00:06:09,280 --> 00:06:16,630
live server to update all those commands

00:06:11,290 --> 00:06:18,820
or only the new ones right so you know

00:06:16,630 --> 00:06:20,500
right now we have one test that we were

00:06:18,820 --> 00:06:24,160
looking at just to put our name on the

00:06:20,500 --> 00:06:26,140
screen however at a pace we have like

00:06:24,160 --> 00:06:27,760
over 200 client-side tests that we're

00:06:26,140 --> 00:06:29,260
that we're running right and we're

00:06:27,760 --> 00:06:31,720
running those multiple times every time

00:06:29,260 --> 00:06:33,900
we're pushing our new feature so for us

00:06:31,720 --> 00:06:36,340
we were looking at okay well how can we

00:06:33,900 --> 00:06:37,810
how do we break this up and we decided

00:06:36,340 --> 00:06:40,270
hey we're only gonna use recorded

00:06:37,810 --> 00:06:42,490
request mocks when we're doing merger

00:06:40,270 --> 00:06:43,960
in local checking then we're gonna

00:06:42,490 --> 00:06:45,850
update and record them when we're doing

00:06:43,960 --> 00:06:48,460
new tests and after server-side updates

00:06:45,850 --> 00:06:50,050
and then on the real server we're gonna

00:06:48,460 --> 00:06:51,280
run you know the full suite with live

00:06:50,050 --> 00:06:54,280
whenever we're gonna actually do a full

00:06:51,280 --> 00:06:56,470
push and we were getting a lot of way

00:06:54,280 --> 00:06:58,930
better results using this you know what

00:06:56,470 --> 00:07:02,440
was great was we saw not only a 2.5

00:06:58,930 --> 00:07:04,570
times performance boost in in running

00:07:02,440 --> 00:07:06,910
our test Suites but also we weren't

00:07:04,570 --> 00:07:08,500
getting charged for most of the requests

00:07:06,910 --> 00:07:12,280
that we were making priorly right so

00:07:08,500 --> 00:07:14,080
there's a great saving cost there so if

00:07:12,280 --> 00:07:16,510
we revisited those goals that we had

00:07:14,080 --> 00:07:18,520
earlier we can see that hey now we are

00:07:16,510 --> 00:07:21,130
running in tests on all those merge

00:07:18,520 --> 00:07:22,720
requests great we reduced the cost of

00:07:21,130 --> 00:07:24,520
running our tests because we're not

00:07:22,720 --> 00:07:27,340
making those API calls as frequently or

00:07:24,520 --> 00:07:29,980
only to update them and then also we are

00:07:27,340 --> 00:07:32,800
reducing the occurrences of failed runs

00:07:29,980 --> 00:07:35,230
for non client reasons right which is a

00:07:32,800 --> 00:07:37,630
really great thing and then when it

00:07:35,230 --> 00:07:39,960
comes to basement when it comes to any

00:07:37,630 --> 00:07:42,130
tests are all basic user scenarios

00:07:39,960 --> 00:07:43,420
pretty much I really wish that I had

00:07:42,130 --> 00:07:44,560
like some awesome plugin to share with

00:07:43,420 --> 00:07:47,470
you guys that would write your test for

00:07:44,560 --> 00:07:48,880
you but you guys all have to do that and

00:07:47,470 --> 00:07:49,420
it's a pain in the ass it's like going

00:07:48,880 --> 00:07:52,750
to the gym

00:07:49,420 --> 00:07:54,100
however you know if you do it you're

00:07:52,750 --> 00:07:56,560
gonna have a much more stable service

00:07:54,100 --> 00:07:57,940
and something much more reliable to push

00:07:56,560 --> 00:08:02,020
out to people that you're confident

00:07:57,940 --> 00:08:04,210
every time so if you want to check out

00:08:02,020 --> 00:08:09,490
that plug-in it's yours

00:08:04,210 --> 00:08:10,560
it's at this repo on github and thank

00:08:09,490 --> 00:08:15,660
you that's it

00:08:10,560 --> 00:08:15,660

YouTube URL: https://www.youtube.com/watch?v=hwfi5gEYGb8


