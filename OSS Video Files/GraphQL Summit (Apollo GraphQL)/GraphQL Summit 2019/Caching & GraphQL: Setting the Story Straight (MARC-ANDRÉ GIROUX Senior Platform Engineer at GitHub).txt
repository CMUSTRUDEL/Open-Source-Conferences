Title: Caching & GraphQL: Setting the Story Straight (MARC-ANDRÃ‰ GIROUX Senior Platform Engineer at GitHub)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	Put the words caching and GraphQL in the same sentence, and without a doubt you've got a debate going. It's time to debunk some myths, shine some light and explore the world of caching & GraphQL together.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:01,910 --> 00:00:07,760
thanks for showing up I know it's late

00:00:04,130 --> 00:00:11,209
there's two more talks on graph QL great

00:00:07,760 --> 00:00:12,530
day today lots of great Docs great talks

00:00:11,209 --> 00:00:14,749
on caching too

00:00:12,530 --> 00:00:16,610
here's another one it's gonna be a

00:00:14,749 --> 00:00:19,760
little different though we're gonna talk

00:00:16,610 --> 00:00:22,010
about more of the philosophy and kind of

00:00:19,760 --> 00:00:24,080
trade-offs behind graph feel and caching

00:00:22,010 --> 00:00:26,210
what kind of things we hear about

00:00:24,080 --> 00:00:32,029
caching and graph get out there and try

00:00:26,210 --> 00:00:34,810
to sort out this mess sorry

00:00:32,029 --> 00:00:34,810
clicker problems

00:00:42,660 --> 00:00:49,030
okay perfect so my name is my family I

00:00:46,180 --> 00:00:50,880
work on the API team at github and Zack

00:00:49,030 --> 00:00:53,770
actually my fourth graphical summit

00:00:50,880 --> 00:00:55,180
usually I gave some talks on how we do

00:00:53,770 --> 00:00:57,640
thing is get up but today's gonna be a

00:00:55,180 --> 00:01:00,309
little a little bit different but it

00:00:57,640 --> 00:01:03,250
should be good still I've been working

00:01:00,309 --> 00:01:05,520
hard the past year or two I've been

00:01:03,250 --> 00:01:08,410
working on bridging this gap we have

00:01:05,520 --> 00:01:10,840
between the graphical community and the

00:01:08,410 --> 00:01:13,119
rest of the API community so I've been

00:01:10,840 --> 00:01:16,350
kind of active on Twitter looking at

00:01:13,119 --> 00:01:18,490
some rants I see some battles between

00:01:16,350 --> 00:01:21,759
passionate graphical developers and the

00:01:18,490 --> 00:01:24,160
rest of the API community and we have a

00:01:21,759 --> 00:01:27,190
lot to learn as the graphical community

00:01:24,160 --> 00:01:31,060
from other API styles what issues they

00:01:27,190 --> 00:01:32,710
faced over many many years so I

00:01:31,060 --> 00:01:35,259
definitely learned a lot of things from

00:01:32,710 --> 00:01:40,000
there but there's also some none

00:01:35,259 --> 00:01:43,240
alongside of that that's something I saw

00:01:40,000 --> 00:01:45,509
a lot and fast maybe like even four

00:01:43,240 --> 00:01:49,509
years since grad school was announced

00:01:45,509 --> 00:01:51,340
Statesmen statement like this not many

00:01:49,509 --> 00:01:56,890
details about it just statements like

00:01:51,340 --> 00:01:59,350
this you can't cash graph QL sometimes

00:01:56,890 --> 00:02:01,720
you wonder why people are so opinionated

00:01:59,350 --> 00:02:04,390
about some of these things so I really

00:02:01,720 --> 00:02:06,940
decided to look into it further try to

00:02:04,390 --> 00:02:08,560
see whether these people mean when they

00:02:06,940 --> 00:02:10,980
say you can't cash graph q all right

00:02:08,560 --> 00:02:13,870
because we saw many talks on it

00:02:10,980 --> 00:02:16,569
announcements from a polo on caching on

00:02:13,870 --> 00:02:18,670
a client got a little server so many

00:02:16,569 --> 00:02:20,980
different ways to cache so where do

00:02:18,670 --> 00:02:23,290
these statements even come from so I

00:02:20,980 --> 00:02:25,959
hope this talk is kind of a toolkit for

00:02:23,290 --> 00:02:27,910
you if you're excited about graph QL at

00:02:25,959 --> 00:02:31,810
your company or talk about it publicly

00:02:27,910 --> 00:02:36,520
on how to face these statements and find

00:02:31,810 --> 00:02:38,260
the truth on their assessments so one

00:02:36,520 --> 00:02:42,610
thing we hear a lot is you can't do

00:02:38,260 --> 00:02:45,220
server-side caching with graph QL and to

00:02:42,610 --> 00:02:47,080
kind of deep go deeper into that I tried

00:02:45,220 --> 00:02:49,060
writing some caching server side see if

00:02:47,080 --> 00:02:50,970
that was actually impossible and

00:02:49,060 --> 00:02:53,349
something would attack me when I tried

00:02:50,970 --> 00:02:53,980
this is graphical Ruby my favorite

00:02:53,349 --> 00:02:56,769
graphical

00:02:53,980 --> 00:02:59,890
implementation there's a name resolver

00:02:56,769 --> 00:03:04,810
here and I tried cashing name and turned

00:02:59,890 --> 00:03:07,629
out it worked so we can actually cache

00:03:04,810 --> 00:03:09,640
graphical a service ID in fact on the

00:03:07,629 --> 00:03:11,319
server side in our resolvers we can do

00:03:09,640 --> 00:03:13,330
anything we want at this point right

00:03:11,319 --> 00:03:15,819
it's just it's just code we can do

00:03:13,330 --> 00:03:18,519
whatever we want so at the application

00:03:15,819 --> 00:03:19,930
side a server side there's many great

00:03:18,519 --> 00:03:22,690
ways to cache and usually that's going

00:03:19,930 --> 00:03:24,489
to be dictated by how your existing

00:03:22,690 --> 00:03:28,239
caching system the company you work

00:03:24,489 --> 00:03:30,549
works so maybe I thought it's it's

00:03:28,239 --> 00:03:33,640
probably the clients it's probably

00:03:30,549 --> 00:03:35,890
clients that can cache but as I said

00:03:33,640 --> 00:03:38,019
earlier quickly you realize in fact

00:03:35,890 --> 00:03:41,170
there's so many all these clients have

00:03:38,019 --> 00:03:43,209
amazing normalized caches what you

00:03:41,170 --> 00:03:45,430
discover when you poke these people is

00:03:43,209 --> 00:03:47,769
what they're talking about is its HTTP

00:03:45,430 --> 00:03:49,180
caching so they know you can cache on

00:03:47,769 --> 00:03:51,730
the server side they know you can cache

00:03:49,180 --> 00:03:54,700
in a client side but it's the great HTTP

00:03:51,730 --> 00:03:58,180
specification that involves caching that

00:03:54,700 --> 00:04:00,819
graphical completely routes to kind of

00:03:58,180 --> 00:04:04,840
understand what do you mean by that

00:04:00,819 --> 00:04:08,169
I thought we'd maybe like go a little do

00:04:04,840 --> 00:04:10,900
a little prime on HTTP caching so HTTP

00:04:08,169 --> 00:04:13,410
caching has two main concepts one is

00:04:10,900 --> 00:04:17,590
freshness the other one is validation

00:04:13,410 --> 00:04:19,750
freshness is a way for a server to give

00:04:17,590 --> 00:04:22,419
a resource to a client and instruct the

00:04:19,750 --> 00:04:25,210
client you can keep this resource for X

00:04:22,419 --> 00:04:26,860
amount of seconds before that is useless

00:04:25,210 --> 00:04:29,889
as probably you probably have the right

00:04:26,860 --> 00:04:31,710
version of the resource in practice this

00:04:29,889 --> 00:04:35,050
is usually done through the HTTP header

00:04:31,710 --> 00:04:38,560
cache control here with a max age of 60

00:04:35,050 --> 00:04:40,840
seconds in this example validation is a

00:04:38,560 --> 00:04:44,200
little different at the end of the 60

00:04:40,840 --> 00:04:45,580
seconds if the client decides oh this

00:04:44,200 --> 00:04:47,830
resource is probably stale I'm going to

00:04:45,580 --> 00:04:49,240
request it again from a server well

00:04:47,830 --> 00:04:52,090
there's a way for the server to say

00:04:49,240 --> 00:04:53,770
actually you already have the valid

00:04:52,090 --> 00:04:55,270
version of the resource I don't actually

00:04:53,770 --> 00:04:58,630
need to send it again and that's

00:04:55,270 --> 00:05:00,520
validation practically this is actually

00:04:58,630 --> 00:05:02,620
done through the last modified header

00:05:00,520 --> 00:05:05,340
and the e-tag header on the server side

00:05:02,620 --> 00:05:07,360
last modified is simply a date and time

00:05:05,340 --> 00:05:10,240
at which the reach

00:05:07,360 --> 00:05:12,819
was last modified and etag is kind of a

00:05:10,240 --> 00:05:16,090
it's kind of a token that indicates the

00:05:12,819 --> 00:05:18,879
state of that particular resource the

00:05:16,090 --> 00:05:20,710
client can then use these values for

00:05:18,879 --> 00:05:24,219
example if with a if modified since

00:05:20,710 --> 00:05:25,900
header passing the date and avoiding

00:05:24,219 --> 00:05:28,389
reef etching is the if the resource

00:05:25,900 --> 00:05:30,069
hasn't been modified since with the

00:05:28,389 --> 00:05:32,439
e-tag you get kind of an equivalent

00:05:30,069 --> 00:05:34,689
header it can be used if non-match if

00:05:32,439 --> 00:05:37,449
that tag changed for the resource and a

00:05:34,689 --> 00:05:39,009
server-side I actually wanted back but

00:05:37,449 --> 00:05:40,599
if it's the same that I already have

00:05:39,009 --> 00:05:43,330
I'll just don't send me anything I'll

00:05:40,599 --> 00:05:45,490
keep so these are actually pretty great

00:05:43,330 --> 00:05:47,560
concepts that are used they're very

00:05:45,490 --> 00:05:49,389
important for example for assets that

00:05:47,560 --> 00:05:51,909
browse to downloads very important it's

00:05:49,389 --> 00:05:54,699
kind of a foundation of the web so I

00:05:51,909 --> 00:05:57,669
agreed before you it'd be pretty sad if

00:05:54,699 --> 00:06:00,159
we couldn't use it graphically but is

00:05:57,669 --> 00:06:01,900
that actually true can't can a graphical

00:06:00,159 --> 00:06:07,659
query like this actually not use any of

00:06:01,900 --> 00:06:09,849
these mechanisms well we can actually we

00:06:07,659 --> 00:06:12,699
can set a cache control header on a

00:06:09,849 --> 00:06:15,039
graphical query right except while we

00:06:12,699 --> 00:06:18,099
were usually used to resources as being

00:06:15,039 --> 00:06:20,889
like one user or like one product or one

00:06:18,099 --> 00:06:24,279
friend the resources we play with with

00:06:20,889 --> 00:06:25,779
graphical our query documents right one

00:06:24,279 --> 00:06:28,449
query document is kind of a resource

00:06:25,779 --> 00:06:30,759
here which means we can totally attach

00:06:28,449 --> 00:06:33,490
cache control headers to it and exactly

00:06:30,759 --> 00:06:36,610
in this example here I'm querying if you

00:06:33,490 --> 00:06:38,050
were to name friends and maybe the

00:06:36,610 --> 00:06:39,180
server says you can actually keep that

00:06:38,050 --> 00:06:42,879
for an hour

00:06:39,180 --> 00:06:45,159
same thing with last modified the field

00:06:42,879 --> 00:06:48,339
with the value of last modified that's

00:06:45,159 --> 00:06:50,500
the smallest here can generally be done

00:06:48,339 --> 00:06:54,069
to the whole query here meaning we can

00:06:50,500 --> 00:06:55,990
attach that to a query document as you

00:06:54,069 --> 00:06:59,680
can see we can also use an e-tag we can

00:06:55,990 --> 00:07:02,620
compile an e-tag entity tag for a whole

00:06:59,680 --> 00:07:04,599
query saying this query has that value

00:07:02,620 --> 00:07:08,080
and a client could use that to avoid

00:07:04,599 --> 00:07:11,199
refactoring something it already has in

00:07:08,080 --> 00:07:13,240
fact in my researchers I saw that a poll

00:07:11,199 --> 00:07:15,759
server already lets you do that unless

00:07:13,240 --> 00:07:18,389
you annotate your schema even down to

00:07:15,759 --> 00:07:20,450
certain fields and then at runtime the

00:07:18,389 --> 00:07:23,960
HTTP server running

00:07:20,450 --> 00:07:25,880
graphical engine will actually return to

00:07:23,960 --> 00:07:27,080
cache control header according to all

00:07:25,880 --> 00:07:31,700
these annotations you had in

00:07:27,080 --> 00:07:33,650
declaratives there but even though

00:07:31,700 --> 00:07:35,240
that's possible in theory the haters

00:07:33,650 --> 00:07:37,490
will say you can't actually use that

00:07:35,240 --> 00:07:41,170
because graphical uses the post HTTP

00:07:37,490 --> 00:07:45,020
verb and you can't generally cache posts

00:07:41,170 --> 00:07:46,640
but that's a myth also right in fact the

00:07:45,020 --> 00:07:49,070
graphical specification doesn't tell us

00:07:46,640 --> 00:07:51,710
anything about which verb or even tell

00:07:49,070 --> 00:07:53,570
us to use HTTP in the first place we can

00:07:51,710 --> 00:07:55,820
actually use any transport mechanism any

00:07:53,570 --> 00:07:58,850
protocol we want so why don't we use

00:07:55,820 --> 00:08:00,890
just get like this with a query in a

00:07:58,850 --> 00:08:04,100
query parameter and simply use these

00:08:00,890 --> 00:08:05,480
cache control headers freely there's

00:08:04,100 --> 00:08:08,570
another thing that will come back at you

00:08:05,480 --> 00:08:11,690
with they'll say well get parameters

00:08:08,570 --> 00:08:15,400
actually have size limits so if you have

00:08:11,690 --> 00:08:18,730
a giant query that might not work

00:08:15,400 --> 00:08:21,020
that's where persistent queries come if

00:08:18,730 --> 00:08:24,710
you haven't heard of persistent queries

00:08:21,020 --> 00:08:28,180
yet they're a pretty neat concept so we

00:08:24,710 --> 00:08:28,180
have a client and server here and

00:08:28,660 --> 00:08:33,830
usually the client will send a graphical

00:08:32,090 --> 00:08:35,900
document like this and expect to get

00:08:33,830 --> 00:08:39,890
back the response that's kind of our

00:08:35,900 --> 00:08:42,350
standard graphical cycle with persistent

00:08:39,890 --> 00:08:44,750
queries we kind of change this instead

00:08:42,350 --> 00:08:46,460
of sending the cool query and expecting

00:08:44,750 --> 00:08:48,980
a response right away we have a first

00:08:46,460 --> 00:08:52,040
step where a client will register a

00:08:48,980 --> 00:08:55,310
particular query with the server the

00:08:52,040 --> 00:08:57,230
server can then say okay I got it

00:08:55,310 --> 00:09:00,320
this query you're gonna use this query

00:08:57,230 --> 00:09:02,840
later just take this identifier or even

00:09:00,320 --> 00:09:05,240
URL that you can simply call next time

00:09:02,840 --> 00:09:08,060
instead of passing the whole query this

00:09:05,240 --> 00:09:09,530
gives us a few really awesome thing the

00:09:08,060 --> 00:09:11,300
first thing is if you have queries that

00:09:09,530 --> 00:09:13,850
are so large that don't fit in a get

00:09:11,300 --> 00:09:16,310
query parameter well you actually save

00:09:13,850 --> 00:09:17,750
these bytes over the wire every time you

00:09:16,310 --> 00:09:20,390
call it right because right now it's

00:09:17,750 --> 00:09:23,060
just a new URL and the server holds the

00:09:20,390 --> 00:09:25,600
whole query document the other thing is

00:09:23,060 --> 00:09:27,740
you skip validation any analysis

00:09:25,600 --> 00:09:31,250
anything you run on a query document

00:09:27,740 --> 00:09:35,080
every time well at query registration

00:09:31,250 --> 00:09:38,060
time you can actually do that

00:09:35,080 --> 00:09:40,430
finally it actually let's just use HTTP

00:09:38,060 --> 00:09:42,530
caching because basically here we're

00:09:40,430 --> 00:09:44,300
using just an HTTP API right we're just

00:09:42,530 --> 00:09:48,890
calling a resource and expecting back a

00:09:44,300 --> 00:09:50,750
response so at this point maybe we'll

00:09:48,890 --> 00:09:53,390
even get laughed at why don't you just

00:09:50,750 --> 00:09:55,520
use a standard HTTP API instead of using

00:09:53,390 --> 00:09:58,880
graph QL you're just calling endpoints

00:09:55,520 --> 00:09:59,630
at this point but it's more nuanced than

00:09:58,880 --> 00:10:02,090
that right

00:09:59,630 --> 00:10:05,600
we're not exactly just using an HTTP API

00:10:02,090 --> 00:10:07,730
we're using it in a way where clients

00:10:05,600 --> 00:10:10,850
actually generated their server-side

00:10:07,730 --> 00:10:12,710
resources which allows possibly

00:10:10,850 --> 00:10:14,180
thousands of different clients to

00:10:12,710 --> 00:10:18,110
register their own little custom

00:10:14,180 --> 00:10:21,260
endpoints which is a thing that back in

00:10:18,110 --> 00:10:23,180
the days and even today people have to

00:10:21,260 --> 00:10:25,160
do right create a bunch of little custom

00:10:23,180 --> 00:10:26,990
endpoints for each client use special

00:10:25,160 --> 00:10:30,200
query parameters to define custom

00:10:26,990 --> 00:10:33,170
responses so that thing is happening in

00:10:30,200 --> 00:10:35,690
typical HTTP endpoints except this time

00:10:33,170 --> 00:10:38,990
we're actually redefining that border

00:10:35,690 --> 00:10:41,180
where the server teams don't have to

00:10:38,990 --> 00:10:43,910
respond to every single use case write a

00:10:41,180 --> 00:10:49,100
new endpoint manage the complexity it's

00:10:43,910 --> 00:10:50,980
actually driven by the clients however I

00:10:49,100 --> 00:10:53,120
have some bad news it's true that

00:10:50,980 --> 00:10:55,310
graphical is actually kind of hard to

00:10:53,120 --> 00:10:57,230
cache even though we can use HTTP

00:10:55,310 --> 00:11:00,740
caching we can use server-side caching

00:10:57,230 --> 00:11:02,750
and we can use client-side caching that

00:11:00,740 --> 00:11:03,860
example might make it a little bit more

00:11:02,750 --> 00:11:06,410
clear

00:11:03,860 --> 00:11:08,810
we had the cache control header to a

00:11:06,410 --> 00:11:11,300
query document before and that's all

00:11:08,810 --> 00:11:13,250
good we can cache for an hour maybe

00:11:11,300 --> 00:11:16,400
friends don't change often and the name

00:11:13,250 --> 00:11:18,080
of the or doesn't either if the same

00:11:16,400 --> 00:11:22,370
client then requests maybe on another

00:11:18,080 --> 00:11:24,620
page or later and on the page the same

00:11:22,370 --> 00:11:26,920
kind of query but this time actually I

00:11:24,620 --> 00:11:30,530
want not only the friends but the events

00:11:26,920 --> 00:11:33,470
in that case events is something that is

00:11:30,530 --> 00:11:35,270
actually quite volatile maybe events are

00:11:33,470 --> 00:11:38,210
getting updated frequently maybe new

00:11:35,270 --> 00:11:39,650
events are added which means the cache

00:11:38,210 --> 00:11:41,750
control header can't say one-hour

00:11:39,650 --> 00:11:44,210
anymore because we're expecting events

00:11:41,750 --> 00:11:45,230
to change maybe now we're back to 60

00:11:44,210 --> 00:11:47,570
seconds

00:11:45,230 --> 00:11:49,670
but it's kind of sad right because the

00:11:47,570 --> 00:11:51,770
friends the name they basically never

00:11:49,670 --> 00:11:53,990
change and just because we requested a

00:11:51,770 --> 00:11:57,590
little bit more data now we're paying

00:11:53,990 --> 00:11:59,900
the cost for everything same thing with

00:11:57,590 --> 00:12:02,150
etags this query could be represented

00:11:59,900 --> 00:12:04,910
when e tag could be cached for many

00:12:02,150 --> 00:12:06,800
clients to use but we add simply a

00:12:04,910 --> 00:12:09,110
little field and the whole thing needs

00:12:06,800 --> 00:12:11,960
to change it can't have the same cache

00:12:09,110 --> 00:12:14,270
key and a good example of that is even

00:12:11,960 --> 00:12:17,450
white spaces could cause such issues so

00:12:14,270 --> 00:12:19,910
smart graphical caches usually normalize

00:12:17,450 --> 00:12:23,020
that remove white spaces but definitely

00:12:19,910 --> 00:12:25,820
adding a feel here would break our cache

00:12:23,020 --> 00:12:27,980
but the real question here is that is

00:12:25,820 --> 00:12:30,680
this actually really specific to graph

00:12:27,980 --> 00:12:34,430
QL is it the fact that it's named graph

00:12:30,680 --> 00:12:38,150
do all that we can't cash and not really

00:12:34,430 --> 00:12:40,370
write the the real thing is that we're

00:12:38,150 --> 00:12:42,050
using different API styles and API

00:12:40,370 --> 00:12:45,650
styles make different trade-offs and

00:12:42,050 --> 00:12:48,680
there's kind of a customization to

00:12:45,650 --> 00:12:51,860
optimization spectrum and every API

00:12:48,680 --> 00:12:54,110
style falls differently on that the more

00:12:51,860 --> 00:12:56,600
optimized API styles are usually the

00:12:54,110 --> 00:12:58,460
ways your there is to cache right

00:12:56,600 --> 00:13:00,830
because they have one single way of

00:12:58,460 --> 00:13:02,660
doing things without much flexibility

00:13:00,830 --> 00:13:07,010
and you can cache that for a lot of

00:13:02,660 --> 00:13:09,710
clients so your typical RPC maybe even G

00:13:07,010 --> 00:13:12,230
RPC is usually very optimized for these

00:13:09,710 --> 00:13:14,540
kind of things then you'll have rest if

00:13:12,230 --> 00:13:15,650
you have a very fine-grained rest with

00:13:14,540 --> 00:13:17,420
hypermedia

00:13:15,650 --> 00:13:20,990
linking to other resources generally

00:13:17,420 --> 00:13:23,150
very good in terms of cache ability but

00:13:20,990 --> 00:13:25,400
then we dive into more flexibility right

00:13:23,150 --> 00:13:27,080
which is absolutely great for the

00:13:25,400 --> 00:13:29,810
reasons we hear a lot when we talk about

00:13:27,080 --> 00:13:32,060
graph QL you have things like response

00:13:29,810 --> 00:13:34,730
partials we talked about the law earlier

00:13:32,060 --> 00:13:37,250
about the custom endpoints trying to fit

00:13:34,730 --> 00:13:39,290
different use cases which every time you

00:13:37,250 --> 00:13:41,690
add one every time you add one query

00:13:39,290 --> 00:13:44,630
parameter you're making caching a little

00:13:41,690 --> 00:13:47,330
bit harder to do then you even have

00:13:44,630 --> 00:13:49,550
things like complex field filters even

00:13:47,330 --> 00:13:52,300
kind of reinventing graph QL within a

00:13:49,550 --> 00:13:55,040
query parameter on an endpoint sometimes

00:13:52,300 --> 00:13:57,170
finally we have graph QR which takes a

00:13:55,040 --> 00:13:58,399
strong stance on a flexibility side

00:13:57,170 --> 00:14:00,829
right

00:13:58,399 --> 00:14:03,800
and there's many other examples this is

00:14:00,829 --> 00:14:05,720
old data which is quite a flexible

00:14:03,800 --> 00:14:08,720
approach it's not necessarily very easy

00:14:05,720 --> 00:14:13,309
to catch either JSON API specification

00:14:08,720 --> 00:14:15,889
for HTTP API is Jason allows you to

00:14:13,309 --> 00:14:17,839
include nested resources filter on

00:14:15,889 --> 00:14:21,050
fields you select very close to graph

00:14:17,839 --> 00:14:23,779
you alright which also makes caching a

00:14:21,050 --> 00:14:25,850
bit less efficient in these cases even

00:14:23,779 --> 00:14:28,009
have some certain rest aisles which

00:14:25,850 --> 00:14:31,519
allow you to embed different resources

00:14:28,009 --> 00:14:33,379
on certain resources meaning the more

00:14:31,519 --> 00:14:36,519
different embeds you have the more

00:14:33,379 --> 00:14:39,470
things can change and dilute your cache

00:14:36,519 --> 00:14:42,079
so there is one thing that makes it

00:14:39,470 --> 00:14:44,749
harder to cache graph QL but it's

00:14:42,079 --> 00:14:49,490
actually a thing in any API that wants

00:14:44,749 --> 00:14:51,589
to be flexible and does graphic you all

00:14:49,490 --> 00:14:53,809
know about this trade-off I of course

00:14:51,589 --> 00:14:56,269
that's the whole point right we wanted

00:14:53,809 --> 00:14:58,160
flexibility so we gave a whale a few

00:14:56,269 --> 00:15:00,860
things but it doesn't mean we just can't

00:14:58,160 --> 00:15:02,959
cash this means we've left a bit of the

00:15:00,860 --> 00:15:06,649
cache power on the side to have more of

00:15:02,959 --> 00:15:09,499
that flexibility so at this point your

00:15:06,649 --> 00:15:12,379
haters might try other techniques they

00:15:09,499 --> 00:15:14,480
might say well still all the proxy

00:15:12,379 --> 00:15:16,610
middleware public caches that they

00:15:14,480 --> 00:15:18,139
should be gives us your with all these

00:15:16,610 --> 00:15:19,759
flexibility you're just gonna ruin it

00:15:18,139 --> 00:15:22,579
for everyone you're you're just gonna

00:15:19,759 --> 00:15:24,110
destroy the internet and this one

00:15:22,579 --> 00:15:27,290
shocked me at first I was like maybe

00:15:24,110 --> 00:15:31,579
maybe they're right so I went in the

00:15:27,290 --> 00:15:35,870
ancient texts of the HTTP spec and I

00:15:31,579 --> 00:15:38,709
found something pretty funny public

00:15:35,870 --> 00:15:41,649
caches proxy caches on the Internet

00:15:38,709 --> 00:15:43,999
can't cash anything that contains the

00:15:41,649 --> 00:15:45,470
authorization header which makes sense

00:15:43,999 --> 00:15:49,160
because you don't want a public cache to

00:15:45,470 --> 00:15:51,769
cache user specific stuff but weirdly

00:15:49,160 --> 00:15:53,509
enough that's never something any of the

00:15:51,769 --> 00:15:55,160
people you see on Twitter saying you

00:15:53,509 --> 00:15:58,540
can't catch a graphic you'll talk about

00:15:55,160 --> 00:16:01,100
a lot of us have authorized api's and

00:15:58,540 --> 00:16:02,749
Facebook who invented graph QL had an

00:16:01,100 --> 00:16:06,319
authorized API which makes a lot of

00:16:02,749 --> 00:16:08,929
sense so that small little snippet of

00:16:06,319 --> 00:16:10,850
text is quite useful if you have an

00:16:08,929 --> 00:16:11,990
authorized API are happy with graph yuo

00:16:10,850 --> 00:16:14,480
and you hear things like

00:16:11,990 --> 00:16:20,480
you're breaking the internet you can use

00:16:14,480 --> 00:16:22,130
that so we can't cache service I'd graph

00:16:20,480 --> 00:16:24,410
drill that's not true

00:16:22,130 --> 00:16:27,410
we can't cache client side graph fuel

00:16:24,410 --> 00:16:29,180
that's not true either we can't use HTTP

00:16:27,410 --> 00:16:29,830
caching we've got killed that's not true

00:16:29,180 --> 00:16:33,350
either

00:16:29,830 --> 00:16:37,010
in fact graphical is cacheable it is

00:16:33,350 --> 00:16:39,110
very cacheable and caching with

00:16:37,010 --> 00:16:41,990
graphical can be a little less effective

00:16:39,110 --> 00:16:43,910
than we highly optimized api's as we saw

00:16:41,990 --> 00:16:46,940
because of that flexibility it provides

00:16:43,910 --> 00:16:49,970
and that flexibility is what allows us

00:16:46,940 --> 00:16:52,850
to support thousands of clients at

00:16:49,970 --> 00:16:56,170
github a lot a lot of use cases that we

00:16:52,850 --> 00:16:58,790
would need to tweak REST API endpoints

00:16:56,170 --> 00:17:01,640
create new endpoints create one of these

00:16:58,790 --> 00:17:03,590
query parameter filters we can do with

00:17:01,640 --> 00:17:06,860
graph tool at the low cost on the server

00:17:03,590 --> 00:17:09,110
side so it's not a mistake that graph

00:17:06,860 --> 00:17:11,420
gopher got like oh we forgot about

00:17:09,110 --> 00:17:15,380
caching removed everything it's actually

00:17:11,420 --> 00:17:18,200
a trade-off we're making and this brings

00:17:15,380 --> 00:17:20,330
me to nuance trade-offs and context

00:17:18,200 --> 00:17:22,880
which I think in all of these

00:17:20,330 --> 00:17:24,920
discussions a lot of things we read and

00:17:22,880 --> 00:17:26,750
that's not only on the the rest of the

00:17:24,920 --> 00:17:30,140
API community that's also in our

00:17:26,750 --> 00:17:32,810
community a lot of posts we read they

00:17:30,140 --> 00:17:34,250
lack these three words often because

00:17:32,810 --> 00:17:36,500
graphical is not necessarily the

00:17:34,250 --> 00:17:38,960
greatest thing for everything but it

00:17:36,500 --> 00:17:41,960
works very well at certain use cases and

00:17:38,960 --> 00:17:44,180
we can acknowledge that maybe it's not

00:17:41,960 --> 00:17:46,280
the most cashable thing ever but we can

00:17:44,180 --> 00:17:49,760
pragmatically use caching what it helps

00:17:46,280 --> 00:17:52,220
us so graphical might not be a sweet

00:17:49,760 --> 00:17:54,970
spot for any static public

00:17:52,220 --> 00:17:57,590
unauthenticated use cases if you have a

00:17:54,970 --> 00:17:58,040
JavaScript asset you want to serve for

00:17:57,590 --> 00:17:59,960
your browser

00:17:58,040 --> 00:18:02,090
maybe graphical is not the best choice

00:17:59,960 --> 00:18:06,050
but I don't see many people doing that

00:18:02,090 --> 00:18:09,860
so far if you have an authenticated API

00:18:06,050 --> 00:18:12,080
with volatile data that you can't even

00:18:09,860 --> 00:18:15,290
cache for more than a few seconds anyway

00:18:12,080 --> 00:18:16,700
and you enjoy graph QL and it makes your

00:18:15,290 --> 00:18:18,500
client-side experience better

00:18:16,700 --> 00:18:22,100
it lets you handle many use cases

00:18:18,500 --> 00:18:23,840
server-side well consider the trade-off

00:18:22,100 --> 00:18:27,140
we talked about but

00:18:23,840 --> 00:18:28,790
don't worry too much that's it for me

00:18:27,140 --> 00:18:32,829
thanks

00:18:28,790 --> 00:18:32,829

YouTube URL: https://www.youtube.com/watch?v=CV3puKM_G14


