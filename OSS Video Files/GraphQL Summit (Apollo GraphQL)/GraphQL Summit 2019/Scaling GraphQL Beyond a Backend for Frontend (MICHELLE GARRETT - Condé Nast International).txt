Title: Scaling GraphQL Beyond a Backend for Frontend (MICHELLE GARRETT - CondÃ© Nast International)
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	How do you scale your GraphQL API beyond a single consumer? This talk will discuss transitioning a client-specific GraphQL layer into a universal graph for multiple consumers.
Captions: 
	00:00:01,030 --> 00:00:07,540
hi everyone and welcome to my talk about

00:00:05,040 --> 00:00:13,230
scaling graph QL beyond to back-end for

00:00:07,540 --> 00:00:16,450
front-end let's go to the next slide

00:00:13,230 --> 00:00:20,560
here we go alright so this is a talk

00:00:16,450 --> 00:00:22,810
about scaling a graph QL API we're going

00:00:20,560 --> 00:00:25,900
to be talking about how a graph QL API

00:00:22,810 --> 00:00:27,640
might mature after Euro 2 and production

00:00:25,900 --> 00:00:30,880
and I'm gonna be telling you a story

00:00:27,640 --> 00:00:33,040
about a graph QL BFF that I built with

00:00:30,880 --> 00:00:42,579
my team at Canaan asked and what happens

00:00:33,040 --> 00:00:44,440
with okay so I want to talk about this

00:00:42,579 --> 00:00:46,600
because I think that at this point in

00:00:44,440 --> 00:00:47,920
graph 2 l's popularity there are other

00:00:46,600 --> 00:00:50,170
teams around the world who have built

00:00:47,920 --> 00:00:51,820
graph 2 you are BFFs and wondering what

00:00:50,170 --> 00:00:52,840
to do with them next so I'm going to be

00:00:51,820 --> 00:00:54,820
talking about the evolution about

00:00:52,840 --> 00:00:57,760
architecture and the challenges that we

00:00:54,820 --> 00:01:01,199
experienced so here's what I'm gonna be

00:00:57,760 --> 00:01:04,869
talking about first of all what is a BFF

00:01:01,199 --> 00:01:07,570
secondly how and why we built one how

00:01:04,869 --> 00:01:09,490
and why we scaled it where we're gonna

00:01:07,570 --> 00:01:13,270
go with that and ultimately what we

00:01:09,490 --> 00:01:15,820
learned from this entire process so Who

00:01:13,270 --> 00:01:18,460
am I I'm Michelle that is a photo of me

00:01:15,820 --> 00:01:21,070
I work at Conde Nast in London I have a

00:01:18,460 --> 00:01:23,320
very confusing Australian British accent

00:01:21,070 --> 00:01:27,100
but I was born in Fremont so feel like

00:01:23,320 --> 00:01:29,259
I'm local you know if you want to tweet

00:01:27,100 --> 00:01:33,310
me about graft you're BFFs you can do so

00:01:29,259 --> 00:01:34,840
right though so what is a BFF you might

00:01:33,310 --> 00:01:37,450
already know but I'm gonna tell you

00:01:34,840 --> 00:01:40,030
so BFF stands for backend for front-end

00:01:37,450 --> 00:01:42,670
it's a software design pattern for

00:01:40,030 --> 00:01:45,850
internal api's that was popularized by

00:01:42,670 --> 00:01:48,579
SoundCloud and by internal API I'm

00:01:45,850 --> 00:01:50,890
talking about an API that is internal to

00:01:48,579 --> 00:01:52,840
an organization rather than publish as a

00:01:50,890 --> 00:01:55,780
third party API for the public to use

00:01:52,840 --> 00:01:58,270
and I want to talk about the model that

00:01:55,780 --> 00:02:01,750
the BFF design pattern is offering an

00:01:58,270 --> 00:02:03,610
alternative to so the most common

00:02:01,750 --> 00:02:06,520
alternative to a back-end for front-end

00:02:03,610 --> 00:02:08,709
is the one-size-fits-all API it's a

00:02:06,520 --> 00:02:11,170
monolithic API that is shared between

00:02:08,709 --> 00:02:13,599
multiple applications or front-ends

00:02:11,170 --> 00:02:14,010
inside of an organization it probably

00:02:13,599 --> 00:02:15,930
wrapped

00:02:14,010 --> 00:02:19,290
the main data sources that are used by

00:02:15,930 --> 00:02:20,909
applications in that company and it

00:02:19,290 --> 00:02:23,700
might look like this where you have

00:02:20,909 --> 00:02:27,209
multiple different applications sharing

00:02:23,700 --> 00:02:29,790
the same API these applications might

00:02:27,209 --> 00:02:32,790
have different user experiences or use

00:02:29,790 --> 00:02:35,519
different pots of that shed API but

00:02:32,790 --> 00:02:37,049
because it's a one-size-fits-all API it

00:02:35,519 --> 00:02:40,470
needs to serve all of these clients

00:02:37,049 --> 00:02:41,970
equally it is often a monolith and it's

00:02:40,470 --> 00:02:46,709
the common denominator between all of

00:02:41,970 --> 00:02:49,140
these platforms so it's not necessarily

00:02:46,709 --> 00:02:51,150
a bad idea to share an API between

00:02:49,140 --> 00:02:52,910
applications but there are some common

00:02:51,150 --> 00:02:55,319
pain points in this scenario

00:02:52,910 --> 00:02:58,290
specifically especially if you're using

00:02:55,319 --> 00:03:00,660
rest firstly different clients needs

00:02:58,290 --> 00:03:02,849
different sets of data and it's almost

00:03:00,660 --> 00:03:05,790
impossible for a one-size-fits-all API

00:03:02,849 --> 00:03:07,709
to serve all of these different needs it

00:03:05,790 --> 00:03:10,349
could not provide the perfect endpoint

00:03:07,709 --> 00:03:11,849
for every client and if it tries the

00:03:10,349 --> 00:03:15,450
monolith is probably going to become

00:03:11,849 --> 00:03:17,459
quite unruly so the Shadow API also

00:03:15,450 --> 00:03:19,889
becomes a bottleneck when trying to roll

00:03:17,459 --> 00:03:22,079
out new features every time a new

00:03:19,889 --> 00:03:23,940
feature is required the front-end team

00:03:22,079 --> 00:03:26,430
has to coordinate with the API team

00:03:23,940 --> 00:03:29,160
which is responsible for the API and

00:03:26,430 --> 00:03:31,169
that API team might have to balance the

00:03:29,160 --> 00:03:32,970
priorities of multiple different clients

00:03:31,169 --> 00:03:36,959
and your future requests might not be

00:03:32,970 --> 00:03:38,700
the top of that list this is where the

00:03:36,959 --> 00:03:41,280
back-end for front-end pattern comes in

00:03:38,700 --> 00:03:44,790
in order to solve the pain points of

00:03:41,280 --> 00:03:47,190
having one API and many consumers the

00:03:44,790 --> 00:03:50,819
BFF pattern recommends building one API

00:03:47,190 --> 00:03:52,530
peruse your experience or per client so

00:03:50,819 --> 00:03:55,260
that means each front-end has its own

00:03:52,530 --> 00:03:59,370
custom API that is built and maintained

00:03:55,260 --> 00:04:01,530
by the same team as the front-end so it

00:03:59,370 --> 00:04:04,230
might look like this a BFF is created as

00:04:01,530 --> 00:04:07,470
an interface between each client and a

00:04:04,230 --> 00:04:09,959
shed Apio data data source that the FF

00:04:07,470 --> 00:04:12,120
implements API logic that is specific to

00:04:09,959 --> 00:04:14,910
that particular client it's essentially

00:04:12,120 --> 00:04:18,180
a translation layer that transforms the

00:04:14,910 --> 00:04:22,740
data into a way that specifically suits

00:04:18,180 --> 00:04:25,480
the needs of that UI clients might be

00:04:22,740 --> 00:04:28,330
using multiple UI api is in which

00:04:25,480 --> 00:04:30,750
case the BFS would act as a kind of API

00:04:28,330 --> 00:04:33,400
gateway defined for a single application

00:04:30,750 --> 00:04:35,020
it'll perform the task of aggregating

00:04:33,400 --> 00:04:37,600
and combining the data from a set of

00:04:35,020 --> 00:04:41,010
api's into a common format that is that

00:04:37,600 --> 00:04:44,770
is convenient for that client

00:04:41,010 --> 00:04:46,780
so what are the benefits of this firstly

00:04:44,770 --> 00:04:48,730
it's easier to adopt your back-end for

00:04:46,780 --> 00:04:51,460
front-end api as you a requirements

00:04:48,730 --> 00:04:53,530
change as a front-end developer instead

00:04:51,460 --> 00:04:56,530
of waiting for the api team to implement

00:04:53,530 --> 00:04:58,210
your new set of data or set up a new

00:04:56,530 --> 00:05:01,390
endpoint you can just go ahead and do

00:04:58,210 --> 00:05:03,790
that yourself it also simplifies the

00:05:01,390 --> 00:05:06,490
process of lining up server and client

00:05:03,790 --> 00:05:09,280
releases now that one team manages both

00:05:06,490 --> 00:05:10,960
the UI and the API there's no longer

00:05:09,280 --> 00:05:12,820
coordination that has to take place

00:05:10,960 --> 00:05:18,580
between the front-end and the backend

00:05:12,820 --> 00:05:20,950
team sadly because this BFF is focused

00:05:18,580 --> 00:05:22,780
on the needs of one application it's

00:05:20,950 --> 00:05:24,040
inevitably going to be smaller and more

00:05:22,780 --> 00:05:26,050
manageable than a shared

00:05:24,040 --> 00:05:28,420
one-size-fits-all API it's going to be

00:05:26,050 --> 00:05:30,690
easier to understand and navigate and

00:05:28,420 --> 00:05:32,350
probably have smaller payloads and

00:05:30,690 --> 00:05:35,050
finally you're able to aggregate

00:05:32,350 --> 00:05:37,090
multiple calls to downstream api's into

00:05:35,050 --> 00:05:40,860
a single call to the BFF which is

00:05:37,090 --> 00:05:43,660
simpler and probably a more performant

00:05:40,860 --> 00:05:45,790
so you might be thinking that a lot of

00:05:43,660 --> 00:05:49,900
those benefits sound familiar to you as

00:05:45,790 --> 00:05:53,350
graph QL enthusiasts the BFF pattern was

00:05:49,900 --> 00:05:55,270
created before graph QL but as you might

00:05:53,350 --> 00:05:57,070
be thinking a lot of the benefits that I

00:05:55,270 --> 00:06:01,120
just mentioned actually come for free

00:05:57,070 --> 00:06:03,190
with graph QL for example just as a BFF

00:06:01,120 --> 00:06:05,860
provides only the data needed by a

00:06:03,190 --> 00:06:07,720
client graph QL allows clients the

00:06:05,860 --> 00:06:11,620
flexibility to define their own data

00:06:07,720 --> 00:06:13,750
needs both the BFF pattern and graph QL

00:06:11,620 --> 00:06:16,690
addressed the problem of over fetching

00:06:13,750 --> 00:06:18,430
from an API and Berthe BFF and graph QL

00:06:16,690 --> 00:06:20,410
allow you to aggregate multiple data

00:06:18,430 --> 00:06:22,950
sources into a single interface for the

00:06:20,410 --> 00:06:22,950
application

00:06:23,460 --> 00:06:29,350
so there's definitely alerted ground

00:06:25,720 --> 00:06:32,760
between graph QL and the BFF patent but

00:06:29,350 --> 00:06:35,320
graph QL is not equivalent to a BFF API

00:06:32,760 --> 00:06:37,270
back-end for front-end is a design

00:06:35,320 --> 00:06:39,310
pattern that might leverage either rest

00:06:37,270 --> 00:06:41,650
or graph QL

00:06:39,310 --> 00:06:45,280
and not all graphical api's are designed

00:06:41,650 --> 00:06:47,320
as BFFs but I do think that because of

00:06:45,280 --> 00:06:49,480
this shared ground between the two

00:06:47,320 --> 00:06:53,320
concepts graph QL is a natural fit for

00:06:49,480 --> 00:06:57,250
building a BFF API in 2019 and in my

00:06:53,320 --> 00:06:58,600
experience it's also quite common so

00:06:57,250 --> 00:07:00,820
I've heard of many teams introducing

00:06:58,600 --> 00:07:04,060
graph QL to their company or project in

00:07:00,820 --> 00:07:07,090
the form of the BFF the BFF will often

00:07:04,060 --> 00:07:09,430
wrap legacy api's aggregate multiple

00:07:07,090 --> 00:07:11,800
data sources ease the transition to

00:07:09,430 --> 00:07:15,370
micro services or help with migrations

00:07:11,800 --> 00:07:17,470
between api's and i think that a BFF is

00:07:15,370 --> 00:07:20,410
a low-stakes way to introduce graph QL

00:07:17,470 --> 00:07:22,450
to an organization this is because its

00:07:20,410 --> 00:07:24,490
surface area is limited to just one

00:07:22,450 --> 00:07:26,320
application and it does not require you

00:07:24,490 --> 00:07:28,360
to actually rewrite any of the

00:07:26,320 --> 00:07:30,550
downstream api's themselves in graph QL

00:07:28,360 --> 00:07:37,240
so it's a good way to try out graph QL

00:07:30,550 --> 00:07:39,310
and experiment with it so I'm gonna tell

00:07:37,240 --> 00:07:41,320
you about the graph QL BFF that I built

00:07:39,310 --> 00:07:43,240
with my team at Conde Nast I'll tell you

00:07:41,320 --> 00:07:45,010
why we started out and later and I'll

00:07:43,240 --> 00:07:47,920
tell you where this API has ended up

00:07:45,010 --> 00:07:50,860
after Euro 2 and production if you have

00:07:47,920 --> 00:07:52,330
a graph QL BFF and you're wondering what

00:07:50,860 --> 00:07:56,080
to do with it hopefully some of this

00:07:52,330 --> 00:07:58,990
will resonate with you the first in

00:07:56,080 --> 00:08:00,670
context I work for Conde Nast which if

00:07:58,990 --> 00:08:03,460
you've never heard of it before is a

00:08:00,670 --> 00:08:04,660
publishing company we publish the

00:08:03,460 --> 00:08:08,800
magazine brands that you've probably

00:08:04,660 --> 00:08:12,870
heard of such as Vogue and GQ and GQ is

00:08:08,800 --> 00:08:12,870
not a magazine about graph QL

00:08:14,090 --> 00:08:21,630
fact although I am loving so for three

00:08:20,370 --> 00:08:24,030
years I've been working on the team that

00:08:21,630 --> 00:08:26,610
builds the international websites for

00:08:24,030 --> 00:08:31,200
Vogue and GQ magazine which all served

00:08:26,610 --> 00:08:33,210
by a single platform and these sites are

00:08:31,200 --> 00:08:36,270
currently fully powered by a graph QL

00:08:33,210 --> 00:08:39,200
API in production 100% and have been

00:08:36,270 --> 00:08:39,200
since early 2018

00:08:39,770 --> 00:08:44,250
most of the content for our websites

00:08:42,180 --> 00:08:46,610
comes from an internally built content

00:08:44,250 --> 00:08:50,220
management system called co-pilot

00:08:46,610 --> 00:08:52,320
copilot has a REST API that allows you

00:08:50,220 --> 00:08:56,070
to request data for content such as

00:08:52,320 --> 00:09:00,990
articles galleries etc and of course our

00:08:56,070 --> 00:09:03,510
websites use this REST API before graph

00:09:00,990 --> 00:09:05,430
QL our API architecture in a very

00:09:03,510 --> 00:09:08,310
simplified diagram used to look like

00:09:05,430 --> 00:09:10,290
this so our web application which is

00:09:08,310 --> 00:09:12,750
written in react used to speak pretty

00:09:10,290 --> 00:09:15,720
much directly to multiple REST API is

00:09:12,750 --> 00:09:21,000
the most important being the REST API

00:09:15,720 --> 00:09:22,860
for our CMS copilot early last year we

00:09:21,000 --> 00:09:26,220
introduced brock UL to our project in

00:09:22,860 --> 00:09:28,290
the form of a BFF api we wrapped all of

00:09:26,220 --> 00:09:30,180
the REST API is with the that we used in

00:09:28,290 --> 00:09:34,260
a graph QL layer that our react

00:09:30,180 --> 00:09:36,870
application now queries directly we

00:09:34,260 --> 00:09:38,940
introduced graph QL to solve many of the

00:09:36,870 --> 00:09:41,250
same problems that everyone else has

00:09:38,940 --> 00:09:43,230
introduced graph QL form but the most

00:09:41,250 --> 00:09:45,420
important impact of it was that it

00:09:43,230 --> 00:09:46,980
vastly improved the happiness of pretty

00:09:45,420 --> 00:09:49,350
much all the developers that worked in

00:09:46,980 --> 00:09:51,510
our code base it gave us a single

00:09:49,350 --> 00:09:53,670
interface to fetch data for our UI

00:09:51,510 --> 00:09:56,250
even though we use multiple downstream

00:09:53,670 --> 00:09:58,320
api's and now we can seamlessly combine

00:09:56,250 --> 00:10:00,450
content data with data from some other

00:09:58,320 --> 00:10:03,450
API is like recommendations or

00:10:00,450 --> 00:10:08,460
configuration and honestly it was pretty

00:10:03,450 --> 00:10:10,380
joyous and we were very pleased it took

00:10:08,460 --> 00:10:13,140
us about three months to switch fully

00:10:10,380 --> 00:10:15,870
over to graph QL we integrated our new

00:10:13,140 --> 00:10:18,030
BFF API incrementally literally

00:10:15,870 --> 00:10:20,010
switching over the data source page by

00:10:18,030 --> 00:10:22,860
page so we started with a category page

00:10:20,010 --> 00:10:25,350
and ended up with the home page and that

00:10:22,860 --> 00:10:28,200
was about three months

00:10:25,350 --> 00:10:30,780
and how do we feel about this well we

00:10:28,200 --> 00:10:32,580
loved on your graph QL API it was a

00:10:30,780 --> 00:10:34,950
really successful development in our

00:10:32,580 --> 00:10:35,790
architecture that made everyone working

00:10:34,950 --> 00:10:38,070
the codebase

00:10:35,790 --> 00:10:40,830
really happy and it encouraged us to

00:10:38,070 --> 00:10:42,720
clean up a little our tech debt actually

00:10:40,830 --> 00:10:44,370
we started censoring the word graph QL

00:10:42,720 --> 00:10:45,960
and our product demos because we kept

00:10:44,370 --> 00:10:49,050
talking about it so much everyone was so

00:10:45,960 --> 00:10:50,640
sick of us talking about graph QL but

00:10:49,050 --> 00:10:52,350
just a foreshadow the next section of my

00:10:50,640 --> 00:10:54,720
talk I will say that we always had a

00:10:52,350 --> 00:10:56,730
slight feeling that someday the schema

00:10:54,720 --> 00:10:58,680
that we had built might be useful beyond

00:10:56,730 --> 00:11:01,020
the confines of just our application and

00:10:58,680 --> 00:11:05,030
so we kept this in the back of our mind

00:11:01,020 --> 00:11:07,170
as we were designing our initial schema

00:11:05,030 --> 00:11:09,240
so I want to stop here and talk about

00:11:07,170 --> 00:11:13,110
one of the most common concerns with

00:11:09,240 --> 00:11:15,330
bffs which is duplication already

00:11:13,110 --> 00:11:17,580
there's some risk of duplication in the

00:11:15,330 --> 00:11:19,860
BFF situation that I've just described

00:11:17,580 --> 00:11:22,110
because we're essentially re

00:11:19,860 --> 00:11:26,460
implementing a shared content API in

00:11:22,110 --> 00:11:28,560
graph QL so if another team wrapped the

00:11:26,460 --> 00:11:30,960
same API in graph QL or if they build

00:11:28,560 --> 00:11:34,890
their own BFF then our BFFs would look

00:11:30,960 --> 00:11:37,350
pretty similar and as developers we are

00:11:34,890 --> 00:11:40,770
naturally adverse to do to duplication

00:11:37,350 --> 00:11:43,800
we're obsessed sometimes to a fault with

00:11:40,770 --> 00:11:47,010
making everything as dry as possible so

00:11:43,800 --> 00:11:49,800
if many of us the BFF pattern might feel

00:11:47,010 --> 00:11:53,160
counterintuitive but duplication is

00:11:49,800 --> 00:11:55,260
inherent to the BFF pattern so Sam

00:11:53,160 --> 00:11:57,630
Newman who wrote an iconic blog post

00:11:55,260 --> 00:12:01,050
about the BFF pattern he has this to say

00:11:57,630 --> 00:12:03,420
about duplication one of the concerns of

00:12:01,050 --> 00:12:05,190
having a single BFF per user interface

00:12:03,420 --> 00:12:07,860
is that you can end up with lots of

00:12:05,190 --> 00:12:10,050
duplication between the BFFs themselves

00:12:07,860 --> 00:12:12,390
they may end up performing the same

00:12:10,050 --> 00:12:14,100
types of aggregation or have the same or

00:12:12,390 --> 00:12:16,890
similar code for interfacing with

00:12:14,100 --> 00:12:18,330
downstream services some people react to

00:12:16,890 --> 00:12:19,970
this by wanting to merge these back

00:12:18,330 --> 00:12:23,400
together and have a general-purpose

00:12:19,970 --> 00:12:25,320
aggregating edge api service but this

00:12:23,400 --> 00:12:26,550
model has proven time and time again to

00:12:25,320 --> 00:12:30,480
lead to highly blurred curve with

00:12:26,550 --> 00:12:33,660
multiple concerns squash together and

00:12:30,480 --> 00:12:36,110
now to be more philosophical I really

00:12:33,660 --> 00:12:38,490
like this quote from Sandi Metz

00:12:36,110 --> 00:12:39,390
duplication is cheaper than the wrong

00:12:38,490 --> 00:12:42,210
abstract

00:12:39,390 --> 00:12:44,580
I believe that when we design code and

00:12:42,210 --> 00:12:46,730
services which always start from a place

00:12:44,580 --> 00:12:49,020
of duplication wherever possible and

00:12:46,730 --> 00:12:50,700
optimize later down the line once we

00:12:49,020 --> 00:12:53,310
validated the actual need for a

00:12:50,700 --> 00:12:55,140
particular abstraction and I'm talking

00:12:53,310 --> 00:12:57,480
about this philosophy because on our

00:12:55,140 --> 00:13:01,080
graph QL BFF journey we did ultimately

00:12:57,480 --> 00:13:02,820
create an abstraction that was trying to

00:13:01,080 --> 00:13:05,940
fix some of the duplication that was

00:13:02,820 --> 00:13:08,400
inherent to our BFF but I don't suggest

00:13:05,940 --> 00:13:10,710
you do this without really questioning

00:13:08,400 --> 00:13:13,250
first if your abstraction is really

00:13:10,710 --> 00:13:16,350
necessary or if it is the right one

00:13:13,250 --> 00:13:18,660
don't create a shed micro-service before

00:13:16,350 --> 00:13:20,700
you need one or before you're sure that

00:13:18,660 --> 00:13:24,240
that is the correct micro-service to

00:13:20,700 --> 00:13:27,150
build so with this in mind I'm going to

00:13:24,240 --> 00:13:32,040
talk about how we scaled our API at

00:13:27,150 --> 00:13:34,050
Conde Nast so when the question came up

00:13:32,040 --> 00:13:36,420
earlier this year of what was next for

00:13:34,050 --> 00:13:38,160
our graphic UL architecture we had been

00:13:36,420 --> 00:13:42,570
using our graphical API in production

00:13:38,160 --> 00:13:44,760
for just over a year we were using our

00:13:42,570 --> 00:13:47,580
API to power our platform serving 18

00:13:44,760 --> 00:13:50,400
different websites in 9 countries across

00:13:47,580 --> 00:13:52,500
the world and our graph QL API serves

00:13:50,400 --> 00:13:57,510
around 200 million users each month

00:13:52,500 --> 00:13:59,580
which is a very big number so when we

00:13:57,510 --> 00:14:04,110
first introduced graph QL we were kind

00:13:59,580 --> 00:14:07,170
of rebels even just in 2018 graph QL was

00:14:04,110 --> 00:14:10,710
not as popular as it is now what we were

00:14:07,170 --> 00:14:12,630
doing was considered experimental and we

00:14:10,710 --> 00:14:15,960
really had to prove the technical value

00:14:12,630 --> 00:14:17,520
of what we were doing internally we had

00:14:15,960 --> 00:14:19,500
to fight against the perception that we

00:14:17,520 --> 00:14:21,810
were introducing a new technology for

00:14:19,500 --> 00:14:26,130
vanity reasons that didn't deliver any

00:14:21,810 --> 00:14:28,950
actual business value but now in 2019

00:14:26,130 --> 00:14:30,990
it's a very different world we've had

00:14:28,950 --> 00:14:33,180
our API very successfully in production

00:14:30,990 --> 00:14:35,760
for over a year and graph QL is

00:14:33,180 --> 00:14:38,790
increasing in popularity every developer

00:14:35,760 --> 00:14:40,290
wants to work with a graph QL API and we

00:14:38,790 --> 00:14:42,210
started hearing from other engineering

00:14:40,290 --> 00:14:43,980
teams at Conde that they were thinking

00:14:42,210 --> 00:14:48,870
of introducing graph QL to their

00:14:43,980 --> 00:14:51,939
projects so we dropped the rest content

00:14:48,870 --> 00:14:54,759
API that we used in graph QL

00:14:51,939 --> 00:14:57,039
and we had spent a year designing a

00:14:54,759 --> 00:14:59,619
schema that we loved and enjoyed using

00:14:57,039 --> 00:15:02,799
and validating it in production and

00:14:59,619 --> 00:15:04,149
iterating on it and it seemed a shame to

00:15:02,799 --> 00:15:06,579
keep this to ourselves

00:15:04,149 --> 00:15:08,499
other teams within the business was

00:15:06,579 --> 00:15:10,779
still using the REST API that we had

00:15:08,499 --> 00:15:12,369
found difficult to work with and then

00:15:10,779 --> 00:15:14,499
there was even another team that was

00:15:12,369 --> 00:15:17,079
building that urn graph QL Rafah around

00:15:14,499 --> 00:15:20,589
the exact same REST API producing an

00:15:17,079 --> 00:15:22,299
eerily similar schema so with this in

00:15:20,589 --> 00:15:24,369
mind it came time to think about

00:15:22,299 --> 00:15:26,559
actually abstracting out the part of our

00:15:24,369 --> 00:15:30,669
BFF that would be useful to other people

00:15:26,559 --> 00:15:34,599
so this is the change that we made to

00:15:30,669 --> 00:15:37,869
our architecture so we decided to split

00:15:34,599 --> 00:15:41,589
our API into two a core content API and

00:15:37,869 --> 00:15:43,509
the BFF so it was clear to us that the

00:15:41,589 --> 00:15:46,059
content related fields in our schema

00:15:43,509 --> 00:15:48,489
would be useful to other teams so we

00:15:46,059 --> 00:15:51,129
decided to create our own core content

00:15:48,489 --> 00:15:54,189
API making graph QL first classes and

00:15:51,129 --> 00:15:56,879
for anyone using the content management

00:15:54,189 --> 00:15:59,079
system and needing to get data from it

00:15:56,879 --> 00:16:01,839
we'd already written a schema and

00:15:59,079 --> 00:16:03,159
resolvers to wrap this API but now we

00:16:01,839 --> 00:16:06,459
wanted to make this available for other

00:16:03,159 --> 00:16:08,049
teams to use as well but we still felt

00:16:06,459 --> 00:16:11,889
like there was a need for the BFF

00:16:08,049 --> 00:16:14,589
because the core content it API could

00:16:11,889 --> 00:16:17,229
not serve all of the API needs of our

00:16:14,589 --> 00:16:18,999
react application alone there are some

00:16:17,229 --> 00:16:21,369
parts to our schema that are not content

00:16:18,999 --> 00:16:23,279
related and they're kind of specific to

00:16:21,369 --> 00:16:26,529
our application some things like

00:16:23,279 --> 00:16:29,709
configuration and integrations with some

00:16:26,529 --> 00:16:31,119
other third party API s and so we

00:16:29,709 --> 00:16:33,489
decided that resolved us for this part

00:16:31,119 --> 00:16:40,119
of the schema would remain inside the

00:16:33,489 --> 00:16:42,099
BFF for now a big part of this dream was

00:16:40,119 --> 00:16:45,309
that we would be consuming graph QL all

00:16:42,099 --> 00:16:47,409
the way down so instead of carrying the

00:16:45,309 --> 00:16:48,099
complexity of wrapping a rest content

00:16:47,409 --> 00:16:50,769
API

00:16:48,099 --> 00:16:52,989
inside of our BFF we could actually just

00:16:50,769 --> 00:16:55,409
consume pure organic graph QL

00:16:52,989 --> 00:16:59,079
direct-from-the-source all the way down

00:16:55,409 --> 00:17:00,699
and here's what our architecture looked

00:16:59,079 --> 00:17:04,710
like before we split the content API

00:17:00,699 --> 00:17:07,950
into its own graph QL service and

00:17:04,710 --> 00:17:10,950
the change that took place now our graph

00:17:07,950 --> 00:17:14,670
QL BFF will actually consume a graph QL

00:17:10,950 --> 00:17:16,920
content API directly and the logic

00:17:14,670 --> 00:17:18,720
required to wrap that REST API is

00:17:16,920 --> 00:17:21,150
therefore moved into its own micro

00:17:18,720 --> 00:17:26,790
service and the BFF will just consume

00:17:21,150 --> 00:17:28,500
graph QL that graph QL micro service can

00:17:26,790 --> 00:17:30,810
now be used by other applications in

00:17:28,500 --> 00:17:33,270
place of the REST API it's now being

00:17:30,810 --> 00:17:35,880
elevated to the status of being a

00:17:33,270 --> 00:17:41,430
published graph QL API for the content

00:17:35,880 --> 00:17:43,710
management system itself so splitting

00:17:41,430 --> 00:17:45,270
out part of our BFF into its own micro

00:17:43,710 --> 00:17:47,970
service it was a challenge all of its

00:17:45,270 --> 00:17:49,650
own and as a developer it is a rare

00:17:47,970 --> 00:17:52,230
opportunity that you're given the time

00:17:49,650 --> 00:17:55,140
and space to really improve on something

00:17:52,230 --> 00:17:56,880
that you've already built and the

00:17:55,140 --> 00:17:58,530
challenge this time around was to take

00:17:56,880 --> 00:18:00,870
the schema that we'd already used in

00:17:58,530 --> 00:18:02,310
production and make sure it was generic

00:18:00,870 --> 00:18:07,530
enough that it could be used by other

00:18:02,310 --> 00:18:09,450
applications and although this new graph

00:18:07,530 --> 00:18:11,490
QL micro service is representing pretty

00:18:09,450 --> 00:18:13,560
much the same content data as what was

00:18:11,490 --> 00:18:15,360
in the BFF we now have the license to

00:18:13,560 --> 00:18:18,240
make improvements with hindsight in mind

00:18:15,360 --> 00:18:20,160
we can take all the learnings and pain

00:18:18,240 --> 00:18:21,930
points of using our schema in production

00:18:20,160 --> 00:18:23,190
for over a year and actually build

00:18:21,930 --> 00:18:26,870
something better to be used by other

00:18:23,190 --> 00:18:26,870
people and clean up all that tech done

00:18:27,380 --> 00:18:32,700
so now for the final challenge which is

00:18:30,120 --> 00:18:35,220
to integrate this new and improved

00:18:32,700 --> 00:18:39,540
content API back into the production

00:18:35,220 --> 00:18:41,930
application so as a reminder here's what

00:18:39,540 --> 00:18:45,600
our application architecture looks like

00:18:41,930 --> 00:18:48,810
the graph QL content API although it may

00:18:45,600 --> 00:18:51,270
replace parts of the BFF schema the BFF

00:18:48,810 --> 00:18:54,180
is still the graph QL point of entry for

00:18:51,270 --> 00:18:55,890
our application so there's still data

00:18:54,180 --> 00:18:56,580
from other sources that's represented in

00:18:55,890 --> 00:18:58,470
the BFF

00:18:56,580 --> 00:19:02,880
so all queries still have to go through

00:18:58,470 --> 00:19:04,530
the BFF and here's what we want in order

00:19:02,880 --> 00:19:06,750
to integrate with this new micro service

00:19:04,530 --> 00:19:08,610
we need a way to forward or proxy

00:19:06,750 --> 00:19:11,570
content queries through to our new

00:19:08,610 --> 00:19:13,530
content API via the BFF layer and

00:19:11,570 --> 00:19:15,420
because we need to do this with as

00:19:13,530 --> 00:19:17,639
little impact to our production websites

00:19:15,420 --> 00:19:22,109
as possible we need the ability to enter

00:19:17,639 --> 00:19:23,789
with this new API incrementally so we

00:19:22,109 --> 00:19:27,869
have a couple of options the first of

00:19:23,789 --> 00:19:30,119
course is a polar Federation and we

00:19:27,869 --> 00:19:31,469
think Federation is very exciting and we

00:19:30,119 --> 00:19:33,149
really want to use it but when we

00:19:31,469 --> 00:19:34,889
started prototyping with it we realized

00:19:33,149 --> 00:19:37,349
that it would probably suit us better if

00:19:34,889 --> 00:19:39,299
we were already working with a gateway

00:19:37,349 --> 00:19:40,859
architecture which is not really where

00:19:39,299 --> 00:19:43,649
we're at right now while we still have

00:19:40,859 --> 00:19:45,809
the BFF schema we don't have a clean-cut

00:19:43,649 --> 00:19:48,929
model of micro services that can be

00:19:45,809 --> 00:19:50,639
aggregated into a single gate way what

00:19:48,929 --> 00:19:52,769
we do have is a bit of a hodgepodge of

00:19:50,639 --> 00:19:54,479
different rest and graph QL api's that

00:19:52,769 --> 00:19:57,359
are only aggregated for a single

00:19:54,479 --> 00:19:58,919
application our content API is also for

00:19:57,359 --> 00:20:02,089
use by other teams so we can't just

00:19:58,919 --> 00:20:05,009
selfishly federated into our own gateway

00:20:02,089 --> 00:20:06,509
so we think we need to make a few more

00:20:05,009 --> 00:20:08,249
architectural shifts before we can use

00:20:06,509 --> 00:20:12,719
Federation we would like to get that

00:20:08,249 --> 00:20:15,419
soon and use it at some point schema

00:20:12,719 --> 00:20:16,979
stitching is a little more minimal maybe

00:20:15,419 --> 00:20:19,440
more along the lines of what we need in

00:20:16,979 --> 00:20:21,329
the immediate term but the API is being

00:20:19,440 --> 00:20:23,940
deprecated and we don't really want to

00:20:21,329 --> 00:20:26,509
invest too much in this paradigm we'd

00:20:23,940 --> 00:20:29,099
rather just go all out with Federation

00:20:26,509 --> 00:20:31,919
so we ultimately ultimately went with

00:20:29,099 --> 00:20:34,109
for our first pulse at this with schema

00:20:31,919 --> 00:20:35,879
delegation which is sort of half way to

00:20:34,109 --> 00:20:37,349
schema stitching what queries are

00:20:35,879 --> 00:20:41,639
proxied through but we don't actually

00:20:37,349 --> 00:20:43,769
merge our schemas so in this diagram

00:20:41,639 --> 00:20:46,799
you'll see the content graph QL micro

00:20:43,769 --> 00:20:48,629
service is a remote schema and we

00:20:46,799 --> 00:20:50,999
delegate all content queries that are

00:20:48,629 --> 00:20:54,119
made to our BFF schema through to this

00:20:50,999 --> 00:20:56,519
micro service to be resolved and this

00:20:54,119 --> 00:20:58,979
option is a little messy for various

00:20:56,519 --> 00:21:01,259
reasons but this approach go to sporting

00:20:58,979 --> 00:21:03,539
out content queries through to our new

00:21:01,259 --> 00:21:05,729
API with minimal effort and minimal code

00:21:03,539 --> 00:21:07,529
changes we're also able to do it

00:21:05,729 --> 00:21:10,950
iteratively switching over to the new

00:21:07,529 --> 00:21:13,349
content API type by type we really

00:21:10,950 --> 00:21:15,779
wanted a low-key way to get started

00:21:13,349 --> 00:21:18,209
querying this new API without having to

00:21:15,779 --> 00:21:19,889
react any further so we're thinking of

00:21:18,209 --> 00:21:21,719
it as an MVP approach that we're going

00:21:19,889 --> 00:21:25,940
to evolve and ultimately replace with

00:21:21,719 --> 00:21:29,969
something better so what's next beyond

00:21:25,940 --> 00:21:31,290
MVP so thinking back to what I said

00:21:29,969 --> 00:21:33,660
earlier about the similar

00:21:31,290 --> 00:21:35,730
between graph QL and the backend for

00:21:33,660 --> 00:21:40,170
front-end Paden here's what I think now

00:21:35,730 --> 00:21:42,530
about BFFs and grass QL graph QL is not

00:21:40,170 --> 00:21:45,360
a like-for-like replacement for a BFF

00:21:42,530 --> 00:21:47,340
but I think that it solves enough of the

00:21:45,360 --> 00:21:49,770
same problems that if you evolve your

00:21:47,340 --> 00:21:52,200
architecture towards consuming pure

00:21:49,770 --> 00:21:56,220
graphical micro services you might find

00:21:52,200 --> 00:21:57,990
that you do look actually need a BFF so

00:21:56,220 --> 00:21:59,370
with that in mind personally I'd really

00:21:57,990 --> 00:22:01,770
love to see how architecture move

00:21:59,370 --> 00:22:03,960
towards more of a gateway model once

00:22:01,770 --> 00:22:05,790
we've finished integrating and

00:22:03,960 --> 00:22:08,100
validating our first graph QL micro

00:22:05,790 --> 00:22:10,050
service I'd like us to gradually split

00:22:08,100 --> 00:22:13,530
out more areas about BFF schema and

00:22:10,050 --> 00:22:15,540
convert these interests into services so

00:22:13,530 --> 00:22:17,280
the rest recommendations API that we

00:22:15,540 --> 00:22:19,620
wrap could become a graph QL

00:22:17,280 --> 00:22:23,310
recommendation service and the same with

00:22:19,620 --> 00:22:24,990
configuration and so on I'd altum Utley

00:22:23,310 --> 00:22:27,450
like to get to a point where we could

00:22:24,990 --> 00:22:29,520
remove the existing BFF and speak

00:22:27,450 --> 00:22:29,970
directly to a single Universal conde

00:22:29,520 --> 00:22:32,970
nast

00:22:29,970 --> 00:22:35,160
data graph and if we have the ability to

00:22:32,970 --> 00:22:37,200
get all of that application data by a

00:22:35,160 --> 00:22:40,110
pure graph QL from a single endpoint

00:22:37,200 --> 00:22:41,940
there's no need to keep our BFF I think

00:22:40,110 --> 00:22:44,310
it's going to be useful while we convert

00:22:41,940 --> 00:22:47,250
the wide organization to building api's

00:22:44,310 --> 00:22:51,210
graph QL first but ultimately I think we

00:22:47,250 --> 00:22:53,400
will grow out of this pattern I don't

00:22:51,210 --> 00:22:55,890
want to brush this process I want to be

00:22:53,400 --> 00:22:58,080
as thoughtful as possible about how we

00:22:55,890 --> 00:23:00,120
scale our graph to our architecture and

00:22:58,080 --> 00:23:05,460
I'd like to continue validating all of

00:23:00,120 --> 00:23:06,840
our abstractions before we make them so

00:23:05,460 --> 00:23:10,770
what did I learn throughout this whole

00:23:06,840 --> 00:23:14,070
process festival I really believe in

00:23:10,770 --> 00:23:15,330
focusing on incremental change people

00:23:14,070 --> 00:23:17,280
keep talking about this today and I

00:23:15,330 --> 00:23:18,780
really believe in this we've done this

00:23:17,280 --> 00:23:21,480
throughout our entire journey with graph

00:23:18,780 --> 00:23:24,180
QL and you may dream of having a

00:23:21,480 --> 00:23:26,940
gorgeous graph QL gateway of micro

00:23:24,180 --> 00:23:28,460
services but if you're evolving the

00:23:26,940 --> 00:23:30,980
architecture of a production application

00:23:28,460 --> 00:23:34,140
you really need to stall it smaller a

00:23:30,980 --> 00:23:35,340
Big Bang release is risky and if you

00:23:34,140 --> 00:23:37,410
build something for too long and

00:23:35,340 --> 00:23:38,390
isolation then you might build the wrong

00:23:37,410 --> 00:23:40,890
thing

00:23:38,390 --> 00:23:42,690
think about smaller areas of your schema

00:23:40,890 --> 00:23:44,790
that you can optimize or pull out as a

00:23:42,690 --> 00:23:49,200
micro service before you Rio protect

00:23:44,790 --> 00:23:52,320
everything unrelated to this during

00:23:49,200 --> 00:23:53,940
optimized to le we could have built our

00:23:52,320 --> 00:23:56,430
content API as a generic

00:23:53,940 --> 00:23:57,780
organization-wide API in the first place

00:23:56,430 --> 00:23:59,400
but we built it fast just for our

00:23:57,780 --> 00:24:02,430
application and I think that that

00:23:59,400 --> 00:24:04,800
ultimately made it a better API because

00:24:02,430 --> 00:24:07,770
by the time that we went to design a

00:24:04,800 --> 00:24:10,140
replacement for the REST API we had a

00:24:07,770 --> 00:24:13,230
year of learnings and product experience

00:24:10,140 --> 00:24:15,300
to inform us we were also able to take

00:24:13,230 --> 00:24:16,980
more risks in that process because we

00:24:15,300 --> 00:24:19,440
didn't yet have the burden of supporting

00:24:16,980 --> 00:24:21,830
other clients with a published API we

00:24:19,440 --> 00:24:24,120
would have to maintain breaking changes

00:24:21,830 --> 00:24:26,250
premature optimization really slows down

00:24:24,120 --> 00:24:28,800
a project it lessens your ability to be

00:24:26,250 --> 00:24:30,270
agile and respond to change so before

00:24:28,800 --> 00:24:32,490
you go to build your ultimate perfect

00:24:30,270 --> 00:24:38,520
schema think about using it for just one

00:24:32,490 --> 00:24:39,870
application first and that's why I have

00:24:38,520 --> 00:24:42,240
there are so many other challenges that

00:24:39,870 --> 00:24:44,070
I would love to chat about but I don't

00:24:42,240 --> 00:24:45,810
have the time so if you want to come

00:24:44,070 --> 00:24:47,520
talk to me about your graph QL BFF I

00:24:45,810 --> 00:24:49,600
would love to hear all about it and

00:24:47,520 --> 00:24:52,810
that's all thanks for having me

00:24:49,600 --> 00:24:52,810

YouTube URL: https://www.youtube.com/watch?v=vfYcsgQBTU0


