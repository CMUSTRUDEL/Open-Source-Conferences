Title: Fine Tuning Apollo Client Caching for Your Data Graph (Ben Newman, Apollo Client Architect at Apollo
Publication date: 2019-11-02
Playlist: GraphQL Summit 2019
Description: 
	Learn how to customize the Apollo Client cache to suit your weirdest data modeling and reactivity needs, using the all-new cache API in Apollo Client 3.0.

While cache normalization is essential for reactive updates in a single-page application, and Apollo Client provides powerful default normalization behavior, not all parts of all applications need to remain up-to-date at all times, and common patterns like pagination can benefit from custom normalization implementations. 

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:01,570 --> 00:00:07,819
[Applause]

00:00:05,410 --> 00:00:11,780
thanks everyone this is without a doubt

00:00:07,819 --> 00:00:14,719
the largest spoken in front of and mad

00:00:11,780 --> 00:00:16,400
respect for a live coding talk that

00:00:14,719 --> 00:00:20,510
stays within the time limits that was

00:00:16,400 --> 00:00:23,960
awesome shitty this talk is all about

00:00:20,510 --> 00:00:26,230
Apollo client caching and how it's

00:00:23,960 --> 00:00:30,020
changing in our next major version I'm

00:00:26,230 --> 00:00:31,460
Ben Newman sort of made up this title

00:00:30,020 --> 00:00:33,590
for the sake of the talk

00:00:31,460 --> 00:00:36,890
Apollo client architect I worked at

00:00:33,590 --> 00:00:40,760
Apollo you can find me online I look

00:00:36,890 --> 00:00:43,520
like that Benjamin with with no I at the

00:00:40,760 --> 00:00:45,860
end like flicker is my handle on these

00:00:43,520 --> 00:00:50,870
social networks my favorite which is

00:00:45,860 --> 00:00:53,410
github of course I have tweeted a link

00:00:50,870 --> 00:00:56,239
to these slides which are slight comm

00:00:53,410 --> 00:00:58,430
deck if you want to find them later

00:00:56,239 --> 00:01:04,820
though I will say the mobile formatting

00:00:58,430 --> 00:01:06,530
is not great alright so a trick that I

00:01:04,820 --> 00:01:10,130
like to play on myself when I'm

00:01:06,530 --> 00:01:12,490
preparing a talk like this is to start

00:01:10,130 --> 00:01:15,679
by writing an excessively flowery

00:01:12,490 --> 00:01:18,770
extended metaphor as the introduction

00:01:15,679 --> 00:01:20,689
and then once I have filled in the rest

00:01:18,770 --> 00:01:23,780
of the slides with actual

00:01:20,689 --> 00:01:26,209
non-metaphorical content I'll go back to

00:01:23,780 --> 00:01:27,979
the introductory slides and thank them

00:01:26,209 --> 00:01:33,520
for their service and delete them from

00:01:27,979 --> 00:01:36,829
the deck so if you're curious about how

00:01:33,520 --> 00:01:39,859
boating and navigation technologies in

00:01:36,829 --> 00:01:42,170
the civilization computer games relate

00:01:39,859 --> 00:01:43,969
to Apollo client 3.0 be happy to waste

00:01:42,170 --> 00:01:47,060
your time with that explanation later

00:01:43,969 --> 00:01:48,799
but that is all in service of explaining

00:01:47,060 --> 00:01:50,709
why this beautiful screenshot from

00:01:48,799 --> 00:01:53,149
civilization 6 is still in the deck

00:01:50,709 --> 00:01:55,249
which I have lightly remixed by

00:01:53,149 --> 00:01:57,200
superimposing the real question that I

00:01:55,249 --> 00:02:01,310
want to ask to kick things off which is

00:01:57,200 --> 00:02:06,799
what is or should be the job of a graph

00:02:01,310 --> 00:02:09,470
QL client we Apollo call ourselves the

00:02:06,799 --> 00:02:11,870
data graph company in case you didn't

00:02:09,470 --> 00:02:14,000
know rather than the graph QL company

00:02:11,870 --> 00:02:17,420
for a good reason

00:02:14,000 --> 00:02:19,610
because the truth that we are trying to

00:02:17,420 --> 00:02:21,880
bring into the world is that your

00:02:19,610 --> 00:02:24,890
organization your team should have a

00:02:21,880 --> 00:02:27,560
single canonical data graph might be

00:02:24,890 --> 00:02:29,390
sprawling it might be federated multiple

00:02:27,560 --> 00:02:32,360
teams might work on it independently but

00:02:29,390 --> 00:02:34,610
it's logically unified by an evolving

00:02:32,360 --> 00:02:36,590
schema and that's what's really

00:02:34,610 --> 00:02:39,709
important the job of a client

00:02:36,590 --> 00:02:43,070
application in this context then is to

00:02:39,709 --> 00:02:45,230
replicate just a subset of that real

00:02:43,070 --> 00:02:46,610
data graph on the client of course it's

00:02:45,230 --> 00:02:49,760
not going to be the whole thing probably

00:02:46,610 --> 00:02:51,950
but it needs to have all of the same you

00:02:49,760 --> 00:02:54,709
know relationships and constraints that

00:02:51,950 --> 00:02:58,430
matter for your application and its

00:02:54,709 --> 00:03:00,890
business logic so just to drive this

00:02:58,430 --> 00:03:04,100
point even for their home everything

00:03:00,890 --> 00:03:05,959
we're doing here everything we're doing

00:03:04,100 --> 00:03:08,360
to help each other build better apps

00:03:05,959 --> 00:03:10,340
would still make sense I think if the

00:03:08,360 --> 00:03:12,860
community for some reason fell out of

00:03:10,340 --> 00:03:16,010
love with the graph QL query language

00:03:12,860 --> 00:03:18,950
it's not really the core of what the

00:03:16,010 --> 00:03:21,730
Palo client is about to be clear I don't

00:03:18,950 --> 00:03:25,070
think this is a very likely scenario but

00:03:21,730 --> 00:03:26,630
neo4j is is here they've come to all of

00:03:25,070 --> 00:03:30,500
the graph QL summits anyone in the

00:03:26,630 --> 00:03:32,810
audience from neo4j all right I can say

00:03:30,500 --> 00:03:34,910
whatever it was cool they have an

00:03:32,810 --> 00:03:37,250
awesome product which is a literal graph

00:03:34,910 --> 00:03:39,500
database right and they also have you

00:03:37,250 --> 00:03:43,220
know their own graph query language

00:03:39,500 --> 00:03:45,230
which get this they are calling gql so

00:03:43,220 --> 00:03:47,720
while I think that is a touch confusing

00:03:45,230 --> 00:03:49,730
I don't find it threatening in the

00:03:47,720 --> 00:03:51,920
slightest because I would be very

00:03:49,730 --> 00:03:54,260
excited about a possibly distant future

00:03:51,920 --> 00:03:55,910
where there's a healthy combination of

00:03:54,260 --> 00:03:59,000
cooperating query languages on the

00:03:55,910 --> 00:04:02,239
client that mutually benefit from the

00:03:59,000 --> 00:04:03,769
same client-side data graph right and so

00:04:02,239 --> 00:04:05,810
what that means in my mind is that this

00:04:03,769 --> 00:04:07,670
client-side data graph should be

00:04:05,810 --> 00:04:10,640
independent of the query language that

00:04:07,670 --> 00:04:12,079
you use to request data from the real

00:04:10,640 --> 00:04:14,810
data graph in the cloud or in your

00:04:12,079 --> 00:04:17,150
servers or wherever it lives so what

00:04:14,810 --> 00:04:19,340
does a palo client 3.0 our next major

00:04:17,150 --> 00:04:22,570
version all about it's about giving you

00:04:19,340 --> 00:04:26,330
the tools to maintain a coherent

00:04:22,570 --> 00:04:27,290
efficiently reactive client-side data

00:04:26,330 --> 00:04:29,930
graph that doesn't have

00:04:27,290 --> 00:04:33,050
a lot of data fetching logic written by

00:04:29,930 --> 00:04:35,270
hand we have borrowed some concepts that

00:04:33,050 --> 00:04:38,150
were already introduced this past year

00:04:35,270 --> 00:04:40,850
by Apollo Federation like composite key

00:04:38,150 --> 00:04:42,850
entity identity that doesn't mean a

00:04:40,850 --> 00:04:45,140
whole lot we'll get into details later

00:04:42,850 --> 00:04:47,330
and we've got some powerful new tools

00:04:45,140 --> 00:04:51,740
like garbage collection and declarative

00:04:47,330 --> 00:04:53,510
API for managing cached field values so

00:04:51,740 --> 00:04:57,200
back when I was going to talk about

00:04:53,510 --> 00:04:59,450
boats this itinerary was even then kind

00:04:57,200 --> 00:05:01,550
of a week joke we've already talked

00:04:59,450 --> 00:05:03,380
about the job of the graph QL client the

00:05:01,550 --> 00:05:06,620
meat of the talk is going to be what's

00:05:03,380 --> 00:05:08,600
new in Apollo coin 3.0 and I talked

00:05:06,620 --> 00:05:11,240
about how there's now just one at Apollo

00:05:08,600 --> 00:05:13,040
slash client package we have cash

00:05:11,240 --> 00:05:15,110
eviction and garbage collection examples

00:05:13,040 --> 00:05:17,840
to go through and a unified declarative

00:05:15,110 --> 00:05:20,330
configuration API there will be an

00:05:17,840 --> 00:05:21,890
in-depth pagination example and if I

00:05:20,330 --> 00:05:22,760
don't run out of time I'd love to tell

00:05:21,890 --> 00:05:24,830
you about some of the underlying

00:05:22,760 --> 00:05:27,100
technologies although you know because

00:05:24,830 --> 00:05:29,930
their underlying maybe we can skip that

00:05:27,100 --> 00:05:31,490
and at the very end a couple Floyds

00:05:29,930 --> 00:05:35,300
about how to get started and where to

00:05:31,490 --> 00:05:40,880
find the documentation so yeah what's

00:05:35,300 --> 00:05:43,940
new so the first big change may seem

00:05:40,880 --> 00:05:46,070
like a cosmetic change we have taken a

00:05:43,940 --> 00:05:49,340
bunch of our existing separate packages

00:05:46,070 --> 00:05:51,200
and combined them into just one new

00:05:49,340 --> 00:05:53,120
package and the great thing about it

00:05:51,200 --> 00:05:54,830
being a new package is it has no version

00:05:53,120 --> 00:05:56,930
history we don't even have to like bump

00:05:54,830 --> 00:05:59,240
the major version although it will start

00:05:56,930 --> 00:06:00,800
with 3.0 and if you look at this list

00:05:59,240 --> 00:06:03,140
you know some of them may be slightly as

00:06:00,800 --> 00:06:05,240
surprising like why are we merging react

00:06:03,140 --> 00:06:08,390
hooks into Apollo client or a graph QL

00:06:05,240 --> 00:06:12,200
tag don't those kind of stand on their

00:06:08,390 --> 00:06:15,830
own well we decided no let me show you

00:06:12,200 --> 00:06:18,310
just quickly what that means you know

00:06:15,830 --> 00:06:21,370
here's how you would set up a very basic

00:06:18,310 --> 00:06:23,330
react based Apollo client based app

00:06:21,370 --> 00:06:25,210
importing react and then importing

00:06:23,330 --> 00:06:29,150
everything from Apollo client and

00:06:25,210 --> 00:06:30,920
creating the client using gql to parse

00:06:29,150 --> 00:06:34,490
your query or maybe you have a compile

00:06:30,920 --> 00:06:36,020
time build plug-in that replaces that

00:06:34,490 --> 00:06:38,490
with the

00:06:36,020 --> 00:06:41,970
abstract syntax tree in lines and then

00:06:38,490 --> 00:06:45,690
the rest is just react so that's it and

00:06:41,970 --> 00:06:47,430
let's focus on this part we think that

00:06:45,690 --> 00:06:49,350
importing everything from this one

00:06:47,430 --> 00:06:53,130
package will well we know that it

00:06:49,350 --> 00:06:54,900
greatly simplifies our job of developing

00:06:53,130 --> 00:06:57,000
the package but it also simplifies

00:06:54,900 --> 00:06:58,320
package installation and versioning

00:06:57,000 --> 00:07:01,560
there's no guesswork about which

00:06:58,320 --> 00:07:03,120
packages export what believe it or not

00:07:01,560 --> 00:07:05,220
it enables better dead code elimination

00:07:03,120 --> 00:07:06,960
and tree shaking especially within the

00:07:05,220 --> 00:07:10,590
library so that what we ship is smaller

00:07:06,960 --> 00:07:12,870
but also in your applications and if you

00:07:10,590 --> 00:07:15,030
don't believe us on that point there's a

00:07:12,870 --> 00:07:16,860
link here with some you know example

00:07:15,030 --> 00:07:19,500
apps that show how we think you should

00:07:16,860 --> 00:07:21,800
be bundling things and prove that you

00:07:19,500 --> 00:07:25,230
know tree shaking actually will work

00:07:21,800 --> 00:07:28,290
okay so that's one package to rule them

00:07:25,230 --> 00:07:30,540
all let's move on to cash eviction and

00:07:28,290 --> 00:07:33,830
garbage collection I think it's safe to

00:07:30,540 --> 00:07:36,210
say that these are the most important /

00:07:33,830 --> 00:07:39,230
embarrassing missing features in Apollo

00:07:36,210 --> 00:07:42,270
client if you you know take nothing away

00:07:39,230 --> 00:07:44,310
from this talk besides this these are

00:07:42,270 --> 00:07:46,380
you know worth studying and trying out

00:07:44,310 --> 00:07:48,480
in your own applications I want to make

00:07:46,380 --> 00:07:50,700
a perhaps fine distinction that this is

00:07:48,480 --> 00:07:52,470
a tracing garbage collector as opposed

00:07:50,700 --> 00:07:54,600
to a reference counting garbage

00:07:52,470 --> 00:07:57,000
collector and I'll try to motivate why

00:07:54,600 --> 00:08:01,080
that is but it's mostly for performance

00:07:57,000 --> 00:08:02,430
reasons there's a feature where if you

00:08:01,080 --> 00:08:04,680
you know really want to prevent a

00:08:02,430 --> 00:08:08,070
certain ID and all of the things that it

00:08:04,680 --> 00:08:09,630
you know references from being removed

00:08:08,070 --> 00:08:12,690
by garbage collection you can explicitly

00:08:09,630 --> 00:08:15,840
retain it and I also want to shout out

00:08:12,690 --> 00:08:19,020
to the other Apollo client Apollo cache

00:08:15,840 --> 00:08:21,990
implementation Hermes from which I took

00:08:19,020 --> 00:08:26,669
a bunch of inspiration especially when

00:08:21,990 --> 00:08:28,770
implementing garbage collection so how

00:08:26,669 --> 00:08:30,870
does it work by the way I'm using this

00:08:28,770 --> 00:08:34,140
sort of teal and indigo color scheme

00:08:30,870 --> 00:08:35,700
with teal slides as like you know topic

00:08:34,140 --> 00:08:38,400
high level description slides and then

00:08:35,700 --> 00:08:40,440
the the indigo darker slides are like in

00:08:38,400 --> 00:08:42,120
the weeds so if you zone out here and

00:08:40,440 --> 00:08:44,550
then you see the screen kind of change

00:08:42,120 --> 00:08:46,380
color oh it wants maybe you start paying

00:08:44,550 --> 00:08:48,350
attention again because that means we've

00:08:46,380 --> 00:08:54,240
moved on to a new topic

00:08:48,350 --> 00:08:56,160
all right I hope this is visible okay so

00:08:54,240 --> 00:08:57,810
suppose you have a query where you're

00:08:56,160 --> 00:09:00,180
fetching your favorite book and you're

00:08:57,810 --> 00:09:02,519
gonna cash it on the client so at some

00:09:00,180 --> 00:09:05,720
point in the pipeline whether you write

00:09:02,519 --> 00:09:07,649
this explicitly or it happens for you

00:09:05,720 --> 00:09:09,389
because the cash does it

00:09:07,649 --> 00:09:12,569
you're gonna write the first book into

00:09:09,389 --> 00:09:13,889
the cache Fahrenheit 451 might have been

00:09:12,569 --> 00:09:17,250
your favorite book when you were a

00:09:13,889 --> 00:09:18,540
teenager and then these aren't actually

00:09:17,250 --> 00:09:20,129
my favorite book so it's just sort of in

00:09:18,540 --> 00:09:21,839
and books that have numbers in their

00:09:20,129 --> 00:09:24,750
titles mood when I was working with

00:09:21,839 --> 00:09:28,829
Lloyds if you end up replacing that

00:09:24,750 --> 00:09:33,860
favorite book with another book say 2666

00:09:28,829 --> 00:09:36,389
by Roberto Bologna then the same query

00:09:33,860 --> 00:09:39,060
maybe getting ahead of myself what does

00:09:36,389 --> 00:09:40,800
the cache look like now the cache has a

00:09:39,060 --> 00:09:43,339
method called extract which you can use

00:09:40,800 --> 00:09:46,829
to just get sort of a JSON serializable

00:09:43,339 --> 00:09:49,230
version or snapshot of the contents of

00:09:46,829 --> 00:09:52,620
the cache so this is some code that I

00:09:49,230 --> 00:09:52,980
took from one of our tests that's not

00:09:52,620 --> 00:09:55,500
all

00:09:52,980 --> 00:09:57,839
after we've written both books we have

00:09:55,500 --> 00:09:59,670
the root query and then we have as

00:09:57,839 --> 00:10:01,649
normalized entity objects both of the

00:09:59,670 --> 00:10:06,389
books and then both of the authors right

00:10:01,649 --> 00:10:09,360
but the same query can no longer read

00:10:06,389 --> 00:10:11,129
for and fight Fahrenheit 451 or Ray

00:10:09,360 --> 00:10:14,100
Bradbury out of the cache because all

00:10:11,129 --> 00:10:17,519
it's going to find is 2666 and Roberto

00:10:14,100 --> 00:10:20,309
Bologna in fact the old data is now in

00:10:17,519 --> 00:10:22,199
some sense unreachable unless we happen

00:10:20,309 --> 00:10:23,639
to remember the IDS so this is a little

00:10:22,199 --> 00:10:25,500
bit different from automatic garbage

00:10:23,639 --> 00:10:27,689
collection in a programming language

00:10:25,500 --> 00:10:29,819
language like JavaScript where you know

00:10:27,689 --> 00:10:31,439
when an object becomes unreachable

00:10:29,819 --> 00:10:34,980
that's that's really the end of its

00:10:31,439 --> 00:10:38,220
story it is possible to you know re

00:10:34,980 --> 00:10:40,319
manufacture these ID strings so garbage

00:10:38,220 --> 00:10:45,449
collection here is not always completely

00:10:40,319 --> 00:10:48,180
safe or sound and that's why I'll get to

00:10:45,449 --> 00:10:50,399
the retainment API in a second but let's

00:10:48,180 --> 00:10:52,949
just focus for right now on what happens

00:10:50,399 --> 00:10:54,329
when you called a cache GC method and I

00:10:52,949 --> 00:10:56,189
want to stress that this is a method of

00:10:54,329 --> 00:10:57,720
the cache it's not a method that we

00:10:56,189 --> 00:11:01,930
could have implemented on the Apollo

00:10:57,720 --> 00:11:05,320
client object so

00:11:01,930 --> 00:11:07,570
it starts from the root query and it

00:11:05,320 --> 00:11:10,149
fans out following all of the references

00:11:07,570 --> 00:11:13,089
that it finds there and in this case the

00:11:10,149 --> 00:11:15,520
only reference that it finds is for 2666

00:11:13,089 --> 00:11:18,070
the book which also has a reference to

00:11:15,520 --> 00:11:22,600
its author but at no point is Fahrenheit

00:11:18,070 --> 00:11:25,240
451 or Ray Bradbury involved so then

00:11:22,600 --> 00:11:29,050
it's able to delete Fahrenheit 451 just

00:11:25,240 --> 00:11:31,600
burn it with fire and the cache gets a

00:11:29,050 --> 00:11:35,260
little smaller which is cool maybe a lot

00:11:31,600 --> 00:11:37,300
smaller so you know if you really wanted

00:11:35,260 --> 00:11:39,190
to keep the object for Ray Bradbury in

00:11:37,300 --> 00:11:44,410
the cache but didn't care about his

00:11:39,190 --> 00:11:45,520
books you could retain him by ID and you

00:11:44,410 --> 00:11:48,700
know we would still be able to get rid

00:11:45,520 --> 00:11:51,610
of Fahrenheit 451 but Ray Bradbury would

00:11:48,700 --> 00:11:54,850
stick around the opposite of retain is

00:11:51,610 --> 00:11:56,890
release and you don't really have to

00:11:54,850 --> 00:11:59,500
think about this API very much because

00:11:56,890 --> 00:12:03,520
top-level IDs like route query are

00:11:59,500 --> 00:12:06,339
automatically retained okay so that was

00:12:03,520 --> 00:12:09,089
garbage collection by comparison cache

00:12:06,339 --> 00:12:11,680
eviction is a two bullet plant slide

00:12:09,089 --> 00:12:14,950
calling cache evict with an ID

00:12:11,680 --> 00:12:17,020
immediately removes any object with that

00:12:14,950 --> 00:12:18,670
ID regardless of whether it's been

00:12:17,020 --> 00:12:23,260
retained so this is you know a fairly

00:12:18,670 --> 00:12:26,560
power to Lee kind of API and eviction

00:12:23,260 --> 00:12:29,020
and garbage collection are two great

00:12:26,560 --> 00:12:32,350
tastes that taste great together because

00:12:29,020 --> 00:12:34,510
any data that was only reachable from an

00:12:32,350 --> 00:12:36,100
entity that you just evicted can be

00:12:34,510 --> 00:12:38,500
automatically collected by calling

00:12:36,100 --> 00:12:40,870
cached GC so you probably want to do one

00:12:38,500 --> 00:12:42,390
after the other although that does not

00:12:40,870 --> 00:12:45,790
happen automatically

00:12:42,390 --> 00:12:47,100
okay so that was cache fiction and

00:12:45,790 --> 00:12:52,089
garbage collection

00:12:47,100 --> 00:12:54,430
so in preface to the next sequence of

00:12:52,089 --> 00:12:56,410
slides I want to sort of define my terms

00:12:54,430 --> 00:12:59,470
here when we talk about a declarative

00:12:56,410 --> 00:13:02,410
cache configuration API

00:12:59,470 --> 00:13:04,750
I hope the only word in in those in that

00:13:02,410 --> 00:13:07,529
phrase that is challenging is the word

00:13:04,750 --> 00:13:10,089
declarative so what do I mean by that

00:13:07,529 --> 00:13:12,190
all things considered when you're

00:13:10,089 --> 00:13:15,020
programming I would say it's better to

00:13:12,190 --> 00:13:17,630
tell a computer somehow

00:13:15,020 --> 00:13:21,320
you want to achieve in just one place

00:13:17,630 --> 00:13:23,510
rather than specifying how to achieve it

00:13:21,320 --> 00:13:24,890
like writing a bunch of code in lots of

00:13:23,510 --> 00:13:27,649
different places which might be

00:13:24,890 --> 00:13:29,810
inconsistent with each other why is that

00:13:27,649 --> 00:13:31,399
important well I mean this is the basic

00:13:29,810 --> 00:13:33,290
insight of what we call declarative

00:13:31,399 --> 00:13:35,390
programming you declare your intentions

00:13:33,290 --> 00:13:37,490
as simply as you can and then you trust

00:13:35,390 --> 00:13:41,560
the computer to find the best way of

00:13:37,490 --> 00:13:44,390
satisfying them you can imagine an

00:13:41,560 --> 00:13:46,730
intergalactic spaceship captain you know

00:13:44,390 --> 00:13:49,399
setting a course for the Alpha sector

00:13:46,730 --> 00:13:50,660
and then saying the word engage well you

00:13:49,399 --> 00:13:52,610
know that's declarative programming

00:13:50,660 --> 00:13:54,500
because when you're travelling faster

00:13:52,610 --> 00:13:55,250
than the speed of light you can't play

00:13:54,500 --> 00:13:57,740
it by ear

00:13:55,250 --> 00:13:59,959
right there's literally no time to react

00:13:57,740 --> 00:14:01,550
to objects or you know whole planets

00:13:59,959 --> 00:14:04,640
that might be in your path so you just

00:14:01,550 --> 00:14:07,580
you have to trust the computer and I

00:14:04,640 --> 00:14:10,700
don't mean that this is like a do what I

00:14:07,580 --> 00:14:12,649
mean interface rather than do what I say

00:14:10,700 --> 00:14:14,209
you still have to be fairly precise and

00:14:12,649 --> 00:14:15,380
how you describe what you want you may

00:14:14,209 --> 00:14:18,830
have to write it down in a

00:14:15,380 --> 00:14:20,810
machine-readable format but you're

00:14:18,830 --> 00:14:23,959
expressing your intention right instead

00:14:20,810 --> 00:14:24,709
of your idea about how something should

00:14:23,959 --> 00:14:27,380
be accomplished

00:14:24,709 --> 00:14:30,829
so that's declarative programming okay

00:14:27,380 --> 00:14:32,000
so as a quick example of this most of

00:14:30,829 --> 00:14:33,560
the rest of what we're going to be

00:14:32,000 --> 00:14:35,470
talking about our options that you can

00:14:33,560 --> 00:14:38,750
pass into the in-memory cache

00:14:35,470 --> 00:14:43,040
constructor so a relatively simple one

00:14:38,750 --> 00:14:45,170
is the possible types option so as you

00:14:43,040 --> 00:14:48,440
may know query fragments can have type

00:14:45,170 --> 00:14:49,850
conditions like this where you're

00:14:48,440 --> 00:14:53,089
getting characters from the Star Wars

00:14:49,850 --> 00:14:56,649
API and you want the names for all the

00:14:53,089 --> 00:14:59,089
characters and the sides for Jedi

00:14:56,649 --> 00:15:01,220
characters and the model for droid

00:14:59,089 --> 00:15:04,160
characters both Jedi Android are

00:15:01,220 --> 00:15:05,839
subtypes of character but you know a

00:15:04,160 --> 00:15:09,100
Jedi is not a droid and vice versa and

00:15:05,839 --> 00:15:09,100
they had different different properties

00:15:10,480 --> 00:15:15,020
it doesn't actually happen all that

00:15:13,310 --> 00:15:16,250
often compared to the total number of

00:15:15,020 --> 00:15:18,440
types that you'll have in your schema

00:15:16,250 --> 00:15:21,380
that you have subtype relationships

00:15:18,440 --> 00:15:23,660
between different types but if you have

00:15:21,380 --> 00:15:26,600
interfaces they can be extended by

00:15:23,660 --> 00:15:28,880
subtypes Union types can have member

00:15:26,600 --> 00:15:30,889
types and it's also of course possible

00:15:28,880 --> 00:15:32,810
to have like sub sub types unions of

00:15:30,889 --> 00:15:35,839
interface types unions of unions so it

00:15:32,810 --> 00:15:38,120
can get pretty hairy and Apollo client

00:15:35,839 --> 00:15:40,880
really doesn't know anything about these

00:15:38,120 --> 00:15:42,220
relationships unless it is told about

00:15:40,880 --> 00:15:45,949
them by you

00:15:42,220 --> 00:15:47,089
so previously how would you do this

00:15:45,949 --> 00:15:49,519
well we didn't have the possible types

00:15:47,089 --> 00:15:53,300
option so what you do is you would issue

00:15:49,519 --> 00:15:55,160
a schema introspection query which looks

00:15:53,300 --> 00:15:59,000
like this and although you know

00:15:55,160 --> 00:16:02,110
relatively innocuous at first glance you

00:15:59,000 --> 00:16:04,910
would dump the output into a file and

00:16:02,110 --> 00:16:08,149
wrap that output with what we called the

00:16:04,910 --> 00:16:09,769
introspection fragment mattre this is

00:16:08,149 --> 00:16:13,959
how you did it I want to spend any more

00:16:09,769 --> 00:16:17,240
time on this because it's embarrassing

00:16:13,959 --> 00:16:20,420
so for the Star Wars API this this is

00:16:17,240 --> 00:16:22,519
what that introspection query looks like

00:16:20,420 --> 00:16:24,490
and you'll notice that although each of

00:16:22,519 --> 00:16:26,380
these types does have a possible types

00:16:24,490 --> 00:16:29,120
field on it

00:16:26,380 --> 00:16:31,160
most of them virtually all of them are

00:16:29,120 --> 00:16:32,810
null and we don't care about those that

00:16:31,160 --> 00:16:35,870
just means you know this type doesn't

00:16:32,810 --> 00:16:37,880
have any subtypes so I think we can do

00:16:35,870 --> 00:16:40,160
better right you want to write down just

00:16:37,880 --> 00:16:43,670
what you mean what you want and not you

00:16:40,160 --> 00:16:45,529
know a whole bunch of other junk public

00:16:43,670 --> 00:16:48,529
clients 3.0 allows you to provide just

00:16:45,529 --> 00:16:52,430
that necessary information so we've got

00:16:48,529 --> 00:16:56,079
this possible types objects the keys are

00:16:52,430 --> 00:16:58,550
the super types and then the arrays are

00:16:56,079 --> 00:17:01,009
strings that are the names of subtypes

00:16:58,550 --> 00:17:03,500
and you can go multiple levels deep like

00:17:01,009 --> 00:17:05,179
you know a snake could be a Viper or a

00:17:03,500 --> 00:17:09,049
Python and then a Python could be a ball

00:17:05,179 --> 00:17:10,730
python or a reticulated python saw a guy

00:17:09,049 --> 00:17:13,130
working on an app that had a bunch of

00:17:10,730 --> 00:17:17,270
snakes in it earlier so I wanted to make

00:17:13,130 --> 00:17:19,990
this example a little spicier and I

00:17:17,270 --> 00:17:21,559
think it's easy to generate this either

00:17:19,990 --> 00:17:23,659
manually when you're first getting

00:17:21,559 --> 00:17:26,600
started or programmatically you can

00:17:23,659 --> 00:17:28,640
still extract it from the introspection

00:17:26,600 --> 00:17:31,070
query result but you don't have to

00:17:28,640 --> 00:17:35,900
bundle all of the extra stuff into your

00:17:31,070 --> 00:17:38,419
client application alright so possible

00:17:35,900 --> 00:17:39,760
types is a top-level key in the

00:17:38,419 --> 00:17:42,810
in-memory cache comes

00:17:39,760 --> 00:17:46,990
Proctor options type policies are

00:17:42,810 --> 00:17:50,980
another top-level key we promised in our

00:17:46,990 --> 00:17:53,130
blog post like what's next section when

00:17:50,980 --> 00:17:55,660
we were announcing 2.6 that we would be

00:17:53,130 --> 00:17:57,550
removing or consolidating several API is

00:17:55,660 --> 00:18:00,760
like data ID from object and the

00:17:57,550 --> 00:18:01,590
connection directive and that's exactly

00:18:00,760 --> 00:18:04,480
what we've done

00:18:01,590 --> 00:18:06,040
so type policies is an object that's

00:18:04,480 --> 00:18:08,290
passed to the in-memory cache

00:18:06,040 --> 00:18:10,780
constructor via the type policies option

00:18:08,290 --> 00:18:14,410
each key corresponds to a type name and

00:18:10,780 --> 00:18:16,180
each value is a type policy object

00:18:14,410 --> 00:18:18,910
that's just an interface it's not like a

00:18:16,180 --> 00:18:21,190
special class it provides configuration

00:18:18,910 --> 00:18:22,840
for that type the configuration is

00:18:21,190 --> 00:18:24,280
always optional most types can get by

00:18:22,840 --> 00:18:26,500
with the default behavior after all

00:18:24,280 --> 00:18:28,780
that's what you're doing today and

00:18:26,500 --> 00:18:31,000
because configuration coincides with

00:18:28,780 --> 00:18:33,220
cache creation that means that these

00:18:31,000 --> 00:18:35,650
rules are enforced for the entire

00:18:33,220 --> 00:18:39,370
lifetime at the cache so you don't have

00:18:35,650 --> 00:18:41,880
to think about you know when you express

00:18:39,370 --> 00:18:45,580
this configuration and when it becomes

00:18:41,880 --> 00:18:48,280
effective okay so I use the phrase

00:18:45,580 --> 00:18:50,640
entity identity earlier maybe you

00:18:48,280 --> 00:18:54,190
remember it could be because it rhymes

00:18:50,640 --> 00:18:57,760
this is the idea that basically you want

00:18:54,190 --> 00:18:59,980
to write down the primary keys of the

00:18:57,760 --> 00:19:03,580
objects that are in your data graph the

00:18:59,980 --> 00:19:06,070
Apollo client to point whatever way was

00:19:03,580 --> 00:19:09,310
to pass in a data ID from object

00:19:06,070 --> 00:19:12,120
function where you could have a series

00:19:09,310 --> 00:19:14,500
of exceptions to the default behavior

00:19:12,120 --> 00:19:17,260
often with a switch statement on the

00:19:14,500 --> 00:19:18,490
type name and by default if we fall

00:19:17,260 --> 00:19:20,740
through all the way up to the default

00:19:18,490 --> 00:19:23,170
case the switch statement the ID

00:19:20,740 --> 00:19:26,950
includes the type name and either the ID

00:19:23,170 --> 00:19:30,430
or underscore ID field you can tell that

00:19:26,950 --> 00:19:32,800
we sort of had MongoDB in mind so the

00:19:30,430 --> 00:19:35,170
Apollo Federation way just as a slight

00:19:32,800 --> 00:19:37,690
detour as you've seen in some other

00:19:35,170 --> 00:19:40,720
slides is to express that information

00:19:37,690 --> 00:19:44,290
using the key directive each of those

00:19:40,720 --> 00:19:48,280
strings is selection set syntax like

00:19:44,290 --> 00:19:50,440
from graph QL query syntax and I just

00:19:48,280 --> 00:19:52,060
want to stress that this this is schema

00:19:50,440 --> 00:19:53,350
syntax so it's not directly applicable

00:19:52,060 --> 00:19:55,960
to the client but

00:19:53,350 --> 00:19:57,700
I took it as an inspiration for what

00:19:55,960 --> 00:20:01,960
we're doing on the client so the Apollo

00:19:57,700 --> 00:20:04,270
client 3.0 way is closer to the

00:20:01,960 --> 00:20:08,020
Federation way than the public line to

00:20:04,270 --> 00:20:09,370
way you have these keys which are the

00:20:08,020 --> 00:20:11,980
types that you're trying to configure

00:20:09,370 --> 00:20:15,490
and you know if you don't want the

00:20:11,980 --> 00:20:17,400
default behavior then you can say that a

00:20:15,490 --> 00:20:20,530
product is uniquely identified by its

00:20:17,400 --> 00:20:22,929
UPC code or a book is uniquely

00:20:20,530 --> 00:20:25,150
identified I mean hopefully by its ISBN

00:20:22,929 --> 00:20:27,340
number right but also maybe if you don't

00:20:25,150 --> 00:20:32,260
have that information by its title and

00:20:27,340 --> 00:20:34,570
its author's name and the nested array

00:20:32,260 --> 00:20:38,380
syntax here is meant to resemble nested

00:20:34,570 --> 00:20:41,230
selection sets so that name in square

00:20:38,380 --> 00:20:45,340
brackets applies to the previous key the

00:20:41,230 --> 00:20:46,929
author we might introduce a parsing step

00:20:45,340 --> 00:20:48,789
here so you can just provide a string

00:20:46,929 --> 00:20:51,159
that looks exactly like the Federation

00:20:48,789 --> 00:20:54,250
version but it seemed like a good place

00:20:51,159 --> 00:20:56,530
to start so behind the scenes a typical

00:20:54,250 --> 00:21:02,440
book ID might look like this for

00:20:56,530 --> 00:21:08,100
Fahrenheit 451 all right so what

00:21:02,440 --> 00:21:08,100
problems do I think this new API solve

00:21:08,370 --> 00:21:16,960
yeah okay field names are reliably

00:21:12,340 --> 00:21:19,240
included along with their values so you

00:21:16,960 --> 00:21:20,799
know title and name and author are part

00:21:19,240 --> 00:21:23,799
of the key so there's no ambiguity about

00:21:20,799 --> 00:21:24,880
which values are which that would be

00:21:23,799 --> 00:21:26,860
kind of annoying if you were writing

00:21:24,880 --> 00:21:29,679
that by hand and the data ID from object

00:21:26,860 --> 00:21:33,549
function but you're not the order of the

00:21:29,679 --> 00:21:36,159
fields is fixed by the same order found

00:21:33,549 --> 00:21:38,140
in the key fields array rather than by

00:21:36,159 --> 00:21:39,549
like you know object property creation

00:21:38,140 --> 00:21:41,789
order so we no longer need to do the

00:21:39,549 --> 00:21:44,559
sort of stable json stringify

00:21:41,789 --> 00:21:46,360
shenanigans you don't waste any time

00:21:44,559 --> 00:21:48,100
executing logic for unrelated types

00:21:46,360 --> 00:21:51,669
because you know either your type has a

00:21:48,100 --> 00:21:56,500
key fields property or not not an opaque

00:21:51,669 --> 00:21:58,390
function like data ID from object so the

00:21:56,500 --> 00:22:01,030
client has an opportunity to sort of

00:21:58,390 --> 00:22:03,220
inspect this configuration and warn

00:22:01,030 --> 00:22:05,049
about any missing key fields and

00:22:03,220 --> 00:22:06,990
that comeback in your responses you may

00:22:05,049 --> 00:22:10,299
want to add those fields to your query

00:22:06,990 --> 00:22:12,159
so this is this is a very fine point but

00:22:10,299 --> 00:22:14,950
it's never confused by a query field

00:22:12,159 --> 00:22:17,020
aliasing right the names in the key

00:22:14,950 --> 00:22:19,900
fields array or just always the actual

00:22:17,020 --> 00:22:22,120
schema field names even if you happen to

00:22:19,900 --> 00:22:23,380
rename those fields using aliases so you

00:22:22,120 --> 00:22:25,030
just you don't have to think about that

00:22:23,380 --> 00:22:29,049
you don't have to stop yourself from

00:22:25,030 --> 00:22:31,120
using aliases for primary keys and this

00:22:29,049 --> 00:22:32,830
configuration maybe most importantly can

00:22:31,120 --> 00:22:35,140
be pretty easily code generated from

00:22:32,830 --> 00:22:37,620
your schema which means that you might

00:22:35,140 --> 00:22:39,940
not even have to write it by hand I

00:22:37,620 --> 00:22:42,280
would say since we're talking about

00:22:39,940 --> 00:22:46,140
normalization and entity identity that

00:22:42,280 --> 00:22:49,630
not all entities or not all objects have

00:22:46,140 --> 00:22:52,120
real identities so it is possible to

00:22:49,630 --> 00:22:56,950
disable normalization now in a public

00:22:52,120 --> 00:22:59,770
Alliant 3.0 Matt had an example earlier

00:22:56,950 --> 00:23:01,900
search results the key bit here is that

00:22:59,770 --> 00:23:03,159
you just passed false for key fields to

00:23:01,900 --> 00:23:05,230
say that something should not be

00:23:03,159 --> 00:23:10,890
normalized and that disables the default

00:23:05,230 --> 00:23:14,049
behavior of using ID and I skip on to

00:23:10,890 --> 00:23:17,500
the next section since we are close on

00:23:14,049 --> 00:23:19,539
time and coming up on lunch so fields of

00:23:17,500 --> 00:23:21,929
course are the properties of entity

00:23:19,539 --> 00:23:25,720
objects like the title of a book object

00:23:21,929 --> 00:23:28,659
however in graph QL query fields can

00:23:25,720 --> 00:23:31,270
have arguments right so a fields value

00:23:28,659 --> 00:23:33,390
might not always be unique with uniquely

00:23:31,270 --> 00:23:35,650
identified just by the name of the field

00:23:33,390 --> 00:23:37,780
so the cache might need to store

00:23:35,650 --> 00:23:39,820
multiple distinct values for a single

00:23:37,780 --> 00:23:42,549
field depending on the values of the

00:23:39,820 --> 00:23:45,490
arguments that were used so it turns out

00:23:42,549 --> 00:23:50,530
that fields also have identity sort of

00:23:45,490 --> 00:23:53,350
in the same sense as entities this is an

00:23:50,530 --> 00:23:55,480
example of a feed query you know maybe

00:23:53,350 --> 00:23:58,390
inspired by Facebook's use cases for

00:23:55,480 --> 00:24:00,039
graph QL by default the cache will store

00:23:58,390 --> 00:24:02,320
a separate value for each unique

00:24:00,039 --> 00:24:04,809
combination of arguments because it just

00:24:02,320 --> 00:24:06,640
doesn't know what those arguments mean

00:24:04,809 --> 00:24:08,140
or which ones might be important it was

00:24:06,640 --> 00:24:09,970
a pretty good default behavior but it

00:24:08,140 --> 00:24:11,850
becomes problematic for arguments like

00:24:09,970 --> 00:24:14,080
offset and limit and so those arguments

00:24:11,850 --> 00:24:16,140
aren't really is supposed to alter the

00:24:14,080 --> 00:24:19,170
underlying data they just kind of felt

00:24:16,140 --> 00:24:20,850
so the traditional way of accomplishing

00:24:19,170 --> 00:24:22,110
this has been to use the connection

00:24:20,850 --> 00:24:24,570
directive which is something that we

00:24:22,110 --> 00:24:26,490
Carter bolted in from relay in a public

00:24:24,570 --> 00:24:28,470
line at one point six you can see that

00:24:26,490 --> 00:24:32,640
it's saying the we only care about the

00:24:28,470 --> 00:24:36,750
type argument I'm whatever the fourth

00:24:32,640 --> 00:24:39,450
line there and you know that was a way

00:24:36,750 --> 00:24:42,390
of telling the client which feed fields

00:24:39,450 --> 00:24:44,820
are important and it solves the problem

00:24:42,390 --> 00:24:46,860
for sure but it's kind of repetitive

00:24:44,820 --> 00:24:48,030
right because this is query syntax so

00:24:46,860 --> 00:24:50,610
you're gonna have to write the same

00:24:48,030 --> 00:24:52,950
thing in every query where you need this

00:24:50,610 --> 00:24:54,330
behavior right and then those different

00:24:52,950 --> 00:24:56,010
connection directives can be

00:24:54,330 --> 00:24:59,700
inconsistent with each other which leads

00:24:56,010 --> 00:25:03,690
to duplication and inconsistencies in

00:24:59,700 --> 00:25:05,910
the cache things fall apart so Apollo

00:25:03,690 --> 00:25:08,340
clients you point out allows specifying

00:25:05,910 --> 00:25:10,130
key arguments in one place again when

00:25:08,340 --> 00:25:13,350
you first create the end memory cache

00:25:10,130 --> 00:25:15,360
like key fields it's an array of strings

00:25:13,350 --> 00:25:17,820
it's always just an array of strings and

00:25:15,360 --> 00:25:20,250
never nested and it's called key args

00:25:17,820 --> 00:25:21,630
instead of key fields so once you

00:25:20,250 --> 00:25:23,580
provide this information to the cache

00:25:21,630 --> 00:25:26,280
you never have to repeat it anywhere

00:25:23,580 --> 00:25:28,800
else because it'll be uniformly applied

00:25:26,280 --> 00:25:31,440
to every query that asks for the feed

00:25:28,800 --> 00:25:33,060
field within the query object you'll

00:25:31,440 --> 00:25:36,860
note that we're sort of inside of a type

00:25:33,060 --> 00:25:42,450
policy for the route query object here

00:25:36,860 --> 00:25:44,460
okay so I'm gonna cover the rest of this

00:25:42,450 --> 00:25:46,350
vertical somewhat quickly because the

00:25:44,460 --> 00:25:50,160
next example actually goes into more

00:25:46,350 --> 00:25:53,670
depth in addition to key args you can

00:25:50,160 --> 00:25:55,500
specify what happens when you read a

00:25:53,670 --> 00:25:59,930
field and what happens when new data

00:25:55,500 --> 00:25:59,930
comes in to the cache for that field

00:26:00,050 --> 00:26:02,790
yeah

00:26:01,230 --> 00:26:05,610
so those functions are called read and

00:26:02,790 --> 00:26:07,470
merge they look something like this and

00:26:05,610 --> 00:26:10,830
this is all going to become quite a bit

00:26:07,470 --> 00:26:13,380
clearer once we look at a public line

00:26:10,830 --> 00:26:16,140
3-play knows brand new treatment of the

00:26:13,380 --> 00:26:18,060
important pattern of pagination which is

00:26:16,140 --> 00:26:20,370
of course the pattern of requesting

00:26:18,060 --> 00:26:23,490
large lists of data in multiple smaller

00:26:20,370 --> 00:26:25,110
chunks or pages currently achieved with

00:26:23,490 --> 00:26:27,830
the connection directive the fetch more

00:26:25,110 --> 00:26:29,730
function and it's a big query option

00:26:27,830 --> 00:26:32,250
public client 3.0

00:26:29,730 --> 00:26:34,860
has a new solution you just saw very

00:26:32,250 --> 00:26:38,070
quickly the necessary ingredients so

00:26:34,860 --> 00:26:40,100
here's a react Apollo query where we're

00:26:38,070 --> 00:26:42,299
using fetch more and update query and

00:26:40,100 --> 00:26:45,450
concatenating together the books as you

00:26:42,299 --> 00:26:48,630
can see on line 16 otherwise they would

00:26:45,450 --> 00:26:51,510
just sort of overwrite the old books I'm

00:26:48,630 --> 00:26:53,429
going to focus on this function because

00:26:51,510 --> 00:26:55,380
this code would need to be repeated

00:26:53,429 --> 00:26:58,169
anywhere in your application where books

00:26:55,380 --> 00:27:01,710
are consumed and in a public land 3.0

00:26:58,169 --> 00:27:04,230
you can actually just delete this code

00:27:01,710 --> 00:27:07,980
and then you don't have to deal with its

00:27:04,230 --> 00:27:09,360
subtle bugs if we wanted to do something

00:27:07,980 --> 00:27:10,769
more complicated than what it's doing

00:27:09,360 --> 00:27:12,419
we'd have to repeat that you know

00:27:10,769 --> 00:27:13,529
complicated code everywhere and maybe

00:27:12,419 --> 00:27:15,179
it's just not worth it maybe you don't

00:27:13,529 --> 00:27:18,659
go to the trouble of getting things

00:27:15,179 --> 00:27:19,889
exactly right and that's a shame so with

00:27:18,659 --> 00:27:21,570
the public client through Play know as I

00:27:19,889 --> 00:27:25,110
said we can delete this and use a custom

00:27:21,570 --> 00:27:28,470
merge function instead so what should we

00:27:25,110 --> 00:27:31,710
put in our query books field policy well

00:27:28,470 --> 00:27:33,510
first of all if you're gonna do this you

00:27:31,710 --> 00:27:35,820
want to just sort of take full control

00:27:33,510 --> 00:27:37,350
over the interpretation of arguments so

00:27:35,820 --> 00:27:39,120
just like we could pass false for key

00:27:37,350 --> 00:27:41,190
fields you want to pass false for key

00:27:39,120 --> 00:27:43,080
args and then it'll just the cache will

00:27:41,190 --> 00:27:45,120
store a single value for this field

00:27:43,080 --> 00:27:47,100
within each parent object rather than

00:27:45,120 --> 00:27:50,250
having different flavors of the same

00:27:47,100 --> 00:27:51,929
field but you're not giving up your

00:27:50,250 --> 00:27:53,880
ability to interpret the arguments

00:27:51,929 --> 00:27:56,130
because in fact that's what the merge

00:27:53,880 --> 00:27:59,519
and read functions are for so merge will

00:27:56,130 --> 00:28:02,639
be called whenever there is incoming

00:27:59,519 --> 00:28:04,769
data for the field the very first time

00:28:02,639 --> 00:28:06,570
the existing data will be undefined so

00:28:04,769 --> 00:28:07,740
you want to deal with that case but if

00:28:06,570 --> 00:28:10,169
we want to just do exactly the same

00:28:07,740 --> 00:28:12,510
thing that the update query function was

00:28:10,169 --> 00:28:15,389
doing you know that's a one-liner and

00:28:12,510 --> 00:28:18,360
then the read field can slice that

00:28:15,389 --> 00:28:21,059
existing data using the offset and limit

00:28:18,360 --> 00:28:23,130
and that's great you know

00:28:21,059 --> 00:28:25,169
these functions are already working

00:28:23,130 --> 00:28:29,639
together to do exactly what update query

00:28:25,169 --> 00:28:31,590
was doing but it also has the same bugs

00:28:29,639 --> 00:28:34,470
that the update query function had so

00:28:31,590 --> 00:28:37,350
just for example you might want to guard

00:28:34,470 --> 00:28:40,450
against the case when the existing data

00:28:37,350 --> 00:28:42,430
in the read function is undefined and

00:28:40,450 --> 00:28:44,410
to find in that case which the cash will

00:28:42,430 --> 00:28:46,000
handle gracefully and in the merge

00:28:44,410 --> 00:28:48,040
function you might not want to assume

00:28:46,000 --> 00:28:50,530
that the incoming data will always just

00:28:48,040 --> 00:28:53,080
be the immediately next page in the list

00:28:50,530 --> 00:28:56,380
so we can do a better job of handling

00:28:53,080 --> 00:28:58,300
offset and limit which we could do by

00:28:56,380 --> 00:29:01,060
making a copy of the existing data and

00:28:58,300 --> 00:29:03,250
then sort of writing the new data into

00:29:01,060 --> 00:29:06,940
the actual positions that are specified

00:29:03,250 --> 00:29:08,860
by the offset and limit arguments all

00:29:06,940 --> 00:29:10,450
right so this code is already a bit more

00:29:08,860 --> 00:29:12,190
complicated like you wouldn't want to

00:29:10,450 --> 00:29:14,110
have been writing this everywhere you

00:29:12,190 --> 00:29:16,780
wrote an update query function but you

00:29:14,110 --> 00:29:19,120
only have to get it right once which is

00:29:16,780 --> 00:29:23,020
you know the whole virtue of this new

00:29:19,120 --> 00:29:25,060
cache configuration API so once per

00:29:23,020 --> 00:29:27,670
in-memory cache is definitely an

00:29:25,060 --> 00:29:30,210
improvement but what if I told you you

00:29:27,670 --> 00:29:35,530
only had to write this code once ever

00:29:30,210 --> 00:29:37,510
period right nothing about this code is

00:29:35,530 --> 00:29:39,040
specific to books we could take all of

00:29:37,510 --> 00:29:40,570
this logic and wrap it up in a helper

00:29:39,040 --> 00:29:42,850
function and then that's the code that

00:29:40,570 --> 00:29:44,830
you have to write reusability for the

00:29:42,850 --> 00:29:46,810
when and here's the offset limit

00:29:44,830 --> 00:29:48,910
paginate it field helper function in all

00:29:46,810 --> 00:29:51,430
of its glory it just returns a field

00:29:48,910 --> 00:29:53,230
policy which is unrelated to the name of

00:29:51,430 --> 00:29:55,630
the field so it works for anything that

00:29:53,230 --> 00:29:59,500
has the same pagination behavior based

00:29:55,630 --> 00:30:01,930
on offsets and limits pagination is a

00:29:59,500 --> 00:30:04,390
notoriously tricky you know you might be

00:30:01,930 --> 00:30:08,230
using cursors trying to deduplicate or

00:30:04,390 --> 00:30:12,940
sort or merge etc but you can do all of

00:30:08,230 --> 00:30:15,700
that with this API so one more thing if

00:30:12,940 --> 00:30:17,620
we also have a route book field in the

00:30:15,700 --> 00:30:20,170
query that maybe reads books by their

00:30:17,620 --> 00:30:23,190
ISBN number it's possible to define just

00:30:20,170 --> 00:30:25,390
a one-off read function for that field

00:30:23,190 --> 00:30:29,290
so that you don't actually have to

00:30:25,390 --> 00:30:32,080
request that field from the server if

00:30:29,290 --> 00:30:34,300
it's already somewhere in the cache and

00:30:32,080 --> 00:30:35,950
this is such a common pattern that

00:30:34,300 --> 00:30:39,430
there's even a shorthand syntax for it

00:30:35,950 --> 00:30:41,290
using shorthand methods syntax this kind

00:30:39,430 --> 00:30:43,450
of replaces the old cache redirects API

00:30:41,290 --> 00:30:46,060
if you were ever forced to understand

00:30:43,450 --> 00:30:47,470
what that meant and we're so happy with

00:30:46,060 --> 00:30:48,850
the results that we've just completely

00:30:47,470 --> 00:30:50,710
removed cache redirects from the cache

00:30:48,850 --> 00:30:51,780
it's not there's no there's no graceful

00:30:50,710 --> 00:30:55,290
deck

00:30:51,780 --> 00:30:56,540
deprecation story there that's the

00:30:55,290 --> 00:30:59,580
shorter sentence

00:30:56,540 --> 00:31:01,470
great so field policy functions or I

00:30:59,580 --> 00:31:04,020
hope you can tell good for a lot more

00:31:01,470 --> 00:31:05,190
than just pagination in fact you in a

00:31:04,020 --> 00:31:07,170
read function you don't even have to

00:31:05,190 --> 00:31:10,920
look at the existing data you can return

00:31:07,170 --> 00:31:12,990
whatever you want and if you're familiar

00:31:10,920 --> 00:31:14,610
with how local state works an Apollo

00:31:12,990 --> 00:31:17,310
client you may be wondering wait does

00:31:14,610 --> 00:31:18,900
this does this maybe replace local state

00:31:17,310 --> 00:31:20,850
and this is the kind of possibility that

00:31:18,900 --> 00:31:24,120
really makes a web developer like me

00:31:20,850 --> 00:31:26,220
salivate let's just remember that with

00:31:24,120 --> 00:31:28,170
local state if you use the client

00:31:26,220 --> 00:31:30,270
directive on a query field what that

00:31:28,170 --> 00:31:33,030
means is that the client will read it

00:31:30,270 --> 00:31:34,320
from the cache right even if you don't

00:31:33,030 --> 00:31:35,730
have a resolver function if there's no

00:31:34,320 --> 00:31:38,370
custom behavior it'll just come from

00:31:35,730 --> 00:31:40,650
straight from the cache so if the cache

00:31:38,370 --> 00:31:42,660
has a read function for that field then

00:31:40,650 --> 00:31:45,570
you can put the same resolver logic in

00:31:42,660 --> 00:31:47,190
that read function so if you can define

00:31:45,570 --> 00:31:49,230
arbitrary field read functions you might

00:31:47,190 --> 00:31:51,150
not even need to define a local state

00:31:49,230 --> 00:31:53,640
resolver function so could we just

00:31:51,150 --> 00:31:55,980
delete the local state implementation

00:31:53,640 --> 00:31:58,710
and I just I mean this is so tantalizing

00:31:55,980 --> 00:32:01,050
right because the amount of code in that

00:31:58,710 --> 00:32:02,760
implementation is enough to pay for all

00:32:01,050 --> 00:32:04,770
of the new features that we've added in

00:32:02,760 --> 00:32:07,640
a public way 3.0 so they're like the net

00:32:04,770 --> 00:32:11,070
increase in bundle size is close to zero

00:32:07,640 --> 00:32:14,520
and if you don't care about that as much

00:32:11,070 --> 00:32:16,110
as me that's okay but it's something I

00:32:14,520 --> 00:32:17,730
would really love to see one thing

00:32:16,110 --> 00:32:19,860
that's holding that back though is that

00:32:17,730 --> 00:32:22,230
lead functions are synchronous so in

00:32:19,860 --> 00:32:23,970
order to deliver asynchronous results we

00:32:22,230 --> 00:32:27,150
need to have some sort of react hook C

00:32:23,970 --> 00:32:28,800
style way of invalidating their results

00:32:27,150 --> 00:32:30,630
or letting them and validate their their

00:32:28,800 --> 00:32:32,880
own results which is definitely a to do

00:32:30,630 --> 00:32:34,320
but for now you'll need to stick to

00:32:32,880 --> 00:32:38,790
synchronous stuff in these read

00:32:34,320 --> 00:32:39,990
functions okay we are out of time so as

00:32:38,790 --> 00:32:41,610
predicted I'm not going to tell you

00:32:39,990 --> 00:32:43,110
about how the entity cache is an

00:32:41,610 --> 00:32:46,380
immutable data structure that's very

00:32:43,110 --> 00:32:48,060
easy to snapshot but has a lot of

00:32:46,380 --> 00:32:50,580
benefits and I'd love to talk about how

00:32:48,060 --> 00:32:52,950
we made that efficient how do you get

00:32:50,580 --> 00:32:55,890
started well you can just NPM install

00:32:52,950 --> 00:32:57,750
Apollo client at beta and then try to

00:32:55,890 --> 00:33:00,360
start using the new exports rather than

00:32:57,750 --> 00:33:02,490
the 2.0 exports once you've finished

00:33:00,360 --> 00:33:04,560
that you know admittedly burdensome task

00:33:02,490 --> 00:33:05,710
I hope you feel like every change was

00:33:04,560 --> 00:33:09,630
worthwhile you

00:33:05,710 --> 00:33:09,630
just remove all those other packages

00:33:09,720 --> 00:33:14,470
feel free to click on through to the

00:33:12,220 --> 00:33:17,169
release 3.0 a pull request for like the

00:33:14,470 --> 00:33:18,700
most vertical record of you know all the

00:33:17,169 --> 00:33:21,039
action that's going into this release

00:33:18,700 --> 00:33:22,899
again it is a beta release I think for

00:33:21,039 --> 00:33:25,270
the public line 2.0 we've made a bunch

00:33:22,899 --> 00:33:27,700
of changes and announced it summit that

00:33:25,270 --> 00:33:28,899
it was you know ready and then a lot of

00:33:27,700 --> 00:33:30,220
people found out that it was actually

00:33:28,899 --> 00:33:31,539
kind of difficult to accommodate those

00:33:30,220 --> 00:33:33,730
changes and we don't want to repeat that

00:33:31,539 --> 00:33:38,190
so we look forward to your feedback on

00:33:33,730 --> 00:33:41,080
the beta documentation we have some

00:33:38,190 --> 00:33:44,320
those are some links to the pages that

00:33:41,080 --> 00:33:46,210
are in especially good shape and it's a

00:33:44,320 --> 00:33:48,610
work in progress as always but it's a

00:33:46,210 --> 00:33:50,860
little less incomplete than ever before

00:33:48,610 --> 00:33:54,070
thanks to some crucial new hires on our

00:33:50,860 --> 00:34:02,110
documentation team this guy Steven

00:33:54,070 --> 00:34:05,250
Barlow great has has changed my my work

00:34:02,110 --> 00:34:07,480
life more than any other single person

00:34:05,250 --> 00:34:09,700
alright I'm just gonna leave this slide

00:34:07,480 --> 00:34:11,169
up as my last slide this is a cheat

00:34:09,700 --> 00:34:13,599
sheet for all of the existing features

00:34:11,169 --> 00:34:16,060
that we've either removed or deprecated

00:34:13,599 --> 00:34:18,099
or made avoidable or consolidated and

00:34:16,060 --> 00:34:19,389
what the replacement is of course if I

00:34:18,099 --> 00:34:20,710
put this up at the very beginning none

00:34:19,389 --> 00:34:22,599
of it would make sense but I hope that

00:34:20,710 --> 00:34:24,940
I've explained each one of those things

00:34:22,599 --> 00:34:27,550
in enough detail that this is a useful

00:34:24,940 --> 00:34:29,230
resource and I would say that all of

00:34:27,550 --> 00:34:31,330
these replacements are superior to what

00:34:29,230 --> 00:34:34,480
they replace because they're declarative

00:34:31,330 --> 00:34:35,889
and they're non repetitive and they're

00:34:34,480 --> 00:34:39,190
consistently applied throughout the

00:34:35,889 --> 00:34:43,020
lifetime of the cache all right you got

00:34:39,190 --> 00:34:43,020
that let's do this

00:34:43,699 --> 00:34:47,079

YouTube URL: https://www.youtube.com/watch?v=n_j8QckQN5I


