Title: GitLab: down the GraphQL rabbit hole (ILLYA KLYMOV - Senior Frontend Engineer at GitLab)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	GitLab is on its way to GraphQL General Availability in early 2020. This journey raises multiple challenges from "classical" security to overall question how to provide best developer experience migrating huge existing codebase on new rails :). We are going to share both our own answers
Captions: 
	00:00:05,109 --> 00:00:10,400
hi there and we are ready for the next

00:00:07,879 --> 00:00:12,830
round of graphical summit talks we are

00:00:10,400 --> 00:00:22,010
going to speak about our graphical

00:00:12,830 --> 00:00:24,289
migration at github so far she is a part

00:00:22,010 --> 00:00:27,230
of gitlab special is the knowledge group

00:00:24,289 --> 00:00:29,750
and the create stage in gitlab the teams

00:00:27,230 --> 00:00:32,330
are separated by devop stages and create

00:00:29,750 --> 00:00:35,120
stage is responsible for actually

00:00:32,330 --> 00:00:36,980
creating things everything you create

00:00:35,120 --> 00:00:40,340
inside the gate lab starting from the

00:00:36,980 --> 00:00:43,250
code with web IDE source code entries

00:00:40,340 --> 00:00:45,530
are whatever is headed by system and as

00:00:43,250 --> 00:00:47,720
the knowledge group Wells the main

00:00:45,530 --> 00:00:50,200
responsibilities is something like to

00:00:47,720 --> 00:00:53,960
boldly go where no man has gone before

00:00:50,200 --> 00:00:56,030
so for it's obvious that knowledge group

00:00:53,960 --> 00:00:58,820
was one of the first early adopters of

00:00:56,030 --> 00:01:01,340
graphical indeed lab and let me

00:00:58,820 --> 00:01:04,400
introduce Ilya he is working for manage

00:01:01,340 --> 00:01:06,500
stage and manage is responsible mainly

00:01:04,400 --> 00:01:09,350
for gaining visibility and insights

00:01:06,500 --> 00:01:11,540
about how business is performing they

00:01:09,350 --> 00:01:14,630
deal with a lot of stuff starting with a

00:01:11,540 --> 00:01:17,840
letter like analytics authorization

00:01:14,630 --> 00:01:21,770
audit and in case of Ilya it's also

00:01:17,840 --> 00:01:24,860
arguing about different stuff manage

00:01:21,770 --> 00:01:26,810
stage has a lot of legacy code it's not

00:01:24,860 --> 00:01:28,990
that modern yet probably it's one of the

00:01:26,810 --> 00:01:33,050
reasons why he loves arguing so much

00:01:28,990 --> 00:01:35,800
yeah so before we start the story of

00:01:33,050 --> 00:01:39,140
graphical journey on get in get lab

00:01:35,800 --> 00:01:41,840
let's say that our technological stack

00:01:39,140 --> 00:01:44,270
is not mainstream compared to the things

00:01:41,840 --> 00:01:48,020
you usually hear from the stage we are

00:01:44,270 --> 00:01:50,990
not using react we peek at view due to

00:01:48,020 --> 00:01:54,200
its ability to gradually proof our kata

00:01:50,990 --> 00:01:57,200
base and within that big typescript we

00:01:54,200 --> 00:01:59,360
have a child trauma gitlab was written

00:01:57,200 --> 00:02:03,290
with CoffeeScript long long ago

00:01:59,360 --> 00:02:07,280
CoffeeScript diet and it's hard to pick

00:02:03,290 --> 00:02:09,110
something else to replace it so we are

00:02:07,280 --> 00:02:11,569
stick with JavaScript and the story of

00:02:09,110 --> 00:02:14,490
graph QL indeed laps torture to almost

00:02:11,569 --> 00:02:16,710
three years ago when we decided that we

00:02:14,490 --> 00:02:18,990
definitely needed graph QL discussed the

00:02:16,710 --> 00:02:21,300
plan how we are going to replace the API

00:02:18,990 --> 00:02:24,300
vis graphical entry and to beat the rest

00:02:21,300 --> 00:02:29,790
to build the rest of the rest of the

00:02:24,300 --> 00:02:31,920
rest of the top of it now months ago the

00:02:29,790 --> 00:02:35,730
first issue about refactoring large

00:02:31,920 --> 00:02:38,220
request widget was created and at first

00:02:35,730 --> 00:02:40,380
glance you can think like but this is

00:02:38,220 --> 00:02:44,250
pretty much trivial it's just some data

00:02:40,380 --> 00:02:46,830
and merge button but github is a

00:02:44,250 --> 00:02:49,890
complete DevOps application so this

00:02:46,830 --> 00:02:51,950
merge request widget can have up to 20

00:02:49,890 --> 00:02:55,470
different states depending on pipelines

00:02:51,950 --> 00:02:57,360
user permissions project settings and so

00:02:55,470 --> 00:02:59,970
on it's really complex

00:02:57,360 --> 00:03:02,250
both on the front-end and back-end parts

00:02:59,970 --> 00:03:05,730
that's why it was a perfect candidate

00:03:02,250 --> 00:03:10,470
for a factoring to craft Cal 10 months

00:03:05,730 --> 00:03:14,130
later the merge request rigid endpoint

00:03:10,470 --> 00:03:16,260
was merged into the codebase well this

00:03:14,130 --> 00:03:18,480
is not because we are so slow developers

00:03:16,260 --> 00:03:20,460
you maybe remember the duck times of

00:03:18,480 --> 00:03:22,740
graph QL community when people they are

00:03:20,460 --> 00:03:27,210
consult and discussing about patterns

00:03:22,740 --> 00:03:29,670
permissions from Facebook but ten months

00:03:27,210 --> 00:03:32,340
is definitely a long term for a business

00:03:29,670 --> 00:03:34,980
so we had changed the requirements we

00:03:32,340 --> 00:03:37,530
had changed our priorities so the merge

00:03:34,980 --> 00:03:40,190
request widget actually is still not

00:03:37,530 --> 00:03:43,740
using graph QL at least for now

00:03:40,190 --> 00:03:45,540
but the merchant the merchant and Point

00:03:43,740 --> 00:03:47,370
Park established the graphical

00:03:45,540 --> 00:03:50,300
infrastructure which is still used in

00:03:47,370 --> 00:03:53,430
gitlab so it was an achievement anyway

00:03:50,300 --> 00:03:56,250
in December 2018

00:03:53,430 --> 00:03:59,460
soon after I've joined gillip the first

00:03:56,250 --> 00:04:01,860
graph QL feature was finally merged to

00:03:59,460 --> 00:04:04,830
master and I swear this is just a

00:04:01,860 --> 00:04:07,740
coincidence I didn't develop it and soon

00:04:04,830 --> 00:04:10,860
after this the concept of general

00:04:07,740 --> 00:04:14,070
availability of graph QL in JavaScript

00:04:10,860 --> 00:04:16,230
was actually decided featuring

00:04:14,070 --> 00:04:18,590
throughput performance developer

00:04:16,230 --> 00:04:21,410
experience and API maintained

00:04:18,590 --> 00:04:25,639
tea yeah these free things were our like

00:04:21,410 --> 00:04:28,430
primary targets and in the January this

00:04:25,639 --> 00:04:31,370
year finally we remove the feature flag

00:04:28,430 --> 00:04:34,310
from graph KL indicating its general

00:04:31,370 --> 00:04:37,250
availability but graph QL is still young

00:04:34,310 --> 00:04:40,580
and hot in gitlab we had only three or

00:04:37,250 --> 00:04:43,400
four entry entities in our graph QL API

00:04:40,580 --> 00:04:46,400
like project group the most complex one

00:04:43,400 --> 00:04:48,620
just searching mutations and our front

00:04:46,400 --> 00:04:52,340
end is also not heavy user of graphical

00:04:48,620 --> 00:04:56,990
yet we have like approximately 20

00:04:52,340 --> 00:05:00,139
queries in our code base so at the

00:04:56,990 --> 00:05:04,550
moment I was assigned my first craft KL

00:05:00,139 --> 00:05:07,460
related issue API was already generally

00:05:04,550 --> 00:05:08,650
available so I expected this to be just

00:05:07,460 --> 00:05:12,169
a walk in the park

00:05:08,650 --> 00:05:15,260
it's easy and what front-end developer

00:05:12,169 --> 00:05:19,039
does first when we have a graphical

00:05:15,260 --> 00:05:21,199
issue of course I need vs code plug-in

00:05:19,039 --> 00:05:23,660
because I want to have an auto

00:05:21,199 --> 00:05:26,870
completion I want to have all checks of

00:05:23,660 --> 00:05:29,870
my queries and I have I want to have all

00:05:26,870 --> 00:05:32,180
the benefits from a paulo plugin and i

00:05:29,870 --> 00:05:35,330
need to download schema to fit it to the

00:05:32,180 --> 00:05:38,110
plugin and i'm okay this is easy it's

00:05:35,330 --> 00:05:42,710
just introspection query and i'm getting

00:05:38,110 --> 00:05:46,310
500 error on introspection query well I

00:05:42,710 --> 00:05:48,950
believe I can explain that the reason

00:05:46,310 --> 00:05:52,160
how we are treating the graph QL from

00:05:48,950 --> 00:05:55,460
back and perspective in gitlab is well

00:05:52,160 --> 00:05:59,150
it's yet another HTTP endpoint which is

00:05:55,460 --> 00:06:01,669
a part of our public API we have another

00:05:59,150 --> 00:06:03,979
HTTP endpoints which are not available

00:06:01,669 --> 00:06:06,919
to the public API but they are consumed

00:06:03,979 --> 00:06:08,930
by our front-end part and the difference

00:06:06,919 --> 00:06:11,690
is that front-end is performing

00:06:08,930 --> 00:06:15,680
authorization using cookie and obviously

00:06:11,690 --> 00:06:18,289
CSRF token and for other users and

00:06:15,680 --> 00:06:21,560
consumers of our API we are expecting to

00:06:18,289 --> 00:06:24,530
have token authorization so actually

00:06:21,560 --> 00:06:27,470
CSRF token was the main issue for some

00:06:24,530 --> 00:06:30,050
weird reason our back-end engineer

00:06:27,470 --> 00:06:32,390
expected me to pass CSRF talking with

00:06:30,050 --> 00:06:35,420
introspection query like we did and

00:06:32,390 --> 00:06:38,060
cookie based scenario luckily it was

00:06:35,420 --> 00:06:40,940
soon okay not soon three weeks later it

00:06:38,060 --> 00:06:44,570
was fixed and I could continue with my

00:06:40,940 --> 00:06:46,700
issue yeah all of this sounds quite an

00:06:44,570 --> 00:06:49,300
illogical it really highlights an

00:06:46,700 --> 00:06:53,300
important change how we are treating our

00:06:49,300 --> 00:06:56,210
front-end normal we have a kind of

00:06:53,300 --> 00:06:59,030
privileged API consumer like front-end

00:06:56,210 --> 00:07:01,870
but both front-end our other impaired

00:06:59,030 --> 00:07:04,880
clients are all using the same endpoint

00:07:01,870 --> 00:07:07,520
everyone is now equal of course

00:07:04,880 --> 00:07:09,500
depending on type of authentication or

00:07:07,520 --> 00:07:12,650
authorization we can assign different

00:07:09,500 --> 00:07:15,350
limits but still the endpoint is the

00:07:12,650 --> 00:07:18,200
same and from the front-end perspective

00:07:15,350 --> 00:07:21,980
it makes our work easier because it's

00:07:18,200 --> 00:07:26,090
easier to debug cases like my query is

00:07:21,980 --> 00:07:28,880
not performing well every time I hear

00:07:26,090 --> 00:07:32,210
like something will make my life easier

00:07:28,880 --> 00:07:35,419
I become concerned when we are speaking

00:07:32,210 --> 00:07:37,610
about multiple HTTP endpoints I have a

00:07:35,419 --> 00:07:40,160
clear understanding how I can lock

00:07:37,610 --> 00:07:44,419
queries to the specific endpoint how I

00:07:40,160 --> 00:07:48,560
can analyze them and even more if things

00:07:44,419 --> 00:07:51,140
go nuts for example if HTTP endpoint is

00:07:48,560 --> 00:07:54,560
abused for denial of service attack by

00:07:51,140 --> 00:07:56,630
cross gitlab or for sending spam we had

00:07:54,560 --> 00:08:00,320
such cases even like three months ago

00:07:56,630 --> 00:08:02,600
I'm I'm capable of terminating all

00:08:00,320 --> 00:08:05,620
queries to this endpoint on our load

00:08:02,600 --> 00:08:08,360
balancer level while this is

00:08:05,620 --> 00:08:11,180
theoretically possible for graphical and

00:08:08,360 --> 00:08:13,669
point we need to support parsing

00:08:11,180 --> 00:08:15,860
underlying queries on our load balancing

00:08:13,669 --> 00:08:18,680
part and this is not a trivial solution

00:08:15,860 --> 00:08:21,380
still yet to be developed and speaking

00:08:18,680 --> 00:08:24,050
about matrix there is one every graph QL

00:08:21,380 --> 00:08:26,270
developers deal with even if they never

00:08:24,050 --> 00:08:28,230
touch back-end code and I'm speaking

00:08:26,270 --> 00:08:30,690
about query complexity

00:08:28,230 --> 00:08:33,510
at lead lap if you have a graphical

00:08:30,690 --> 00:08:37,710
request it can fetch data from different

00:08:33,510 --> 00:08:41,220
data sources it can use our database but

00:08:37,710 --> 00:08:46,610
also it can use get Li and get Li is our

00:08:41,220 --> 00:08:49,050
front proxy for all get related queries

00:08:46,610 --> 00:08:51,660
consuming any get related queries

00:08:49,050 --> 00:08:54,330
required a possible cost to the file

00:08:51,660 --> 00:08:56,430
system sometimes it is very heavy so

00:08:54,330 --> 00:08:58,500
each time you are querying the gotelli

00:08:56,430 --> 00:09:00,930
related field our query complexity is

00:08:58,500 --> 00:09:04,260
multiplied by 2 for this field but

00:09:00,930 --> 00:09:07,170
that's not that simple even if we are

00:09:04,260 --> 00:09:10,890
speaking just about database queries not

00:09:07,170 --> 00:09:12,990
everything is equal for example for

00:09:10,890 --> 00:09:15,390
issue suggestions we are building a very

00:09:12,990 --> 00:09:19,290
complex and heavy query for database

00:09:15,390 --> 00:09:22,530
including like like like like so the

00:09:19,290 --> 00:09:26,010
problem is that in github implementation

00:09:22,530 --> 00:09:27,690
the resolver determine the complexity so

00:09:26,010 --> 00:09:29,780
we are passing the arguments to the

00:09:27,690 --> 00:09:33,510
resolver and it's up to resolver to

00:09:29,780 --> 00:09:37,470
identify how complex it thinks the query

00:09:33,510 --> 00:09:40,470
will be with the architecture queries

00:09:37,470 --> 00:09:42,870
close to components sometimes we have a

00:09:40,470 --> 00:09:45,780
scenario when simultaneous queries

00:09:42,870 --> 00:09:48,630
around at the moment and of course we

00:09:45,780 --> 00:09:50,940
have an Apollo link batch library to

00:09:48,630 --> 00:09:54,960
batch all them to the single HTTP

00:09:50,940 --> 00:09:56,910
request or we can exclude some requests

00:09:54,960 --> 00:10:00,150
if it's really heavy and it's triggering

00:09:56,910 --> 00:10:02,670
query complexity but I'm highly

00:10:00,150 --> 00:10:05,220
concerned about the moment when we have

00:10:02,670 --> 00:10:08,100
an unpredictable environment where user

00:10:05,220 --> 00:10:10,020
actions define how many queries do we

00:10:08,100 --> 00:10:12,810
have at the moment and we have no idea

00:10:10,020 --> 00:10:14,910
should we batch all of them should we

00:10:12,810 --> 00:10:20,550
exclude some query so maybe we shouldn't

00:10:14,910 --> 00:10:23,100
just use batching at all well the real

00:10:20,550 --> 00:10:25,350
solution of course is to share the

00:10:23,100 --> 00:10:27,780
complexity calculation between front-end

00:10:25,350 --> 00:10:29,850
and back-end but since we are delegating

00:10:27,780 --> 00:10:31,880
the complexity estimation and back into

00:10:29,850 --> 00:10:34,260
the resolver it's close to impossible

00:10:31,880 --> 00:10:37,530
another possible solution to this

00:10:34,260 --> 00:10:40,339
problem is to capture the file at a

00:10:37,530 --> 00:10:43,309
batch requests on the link level

00:10:40,339 --> 00:10:45,709
understand consuming error code and

00:10:43,309 --> 00:10:49,100
messages that this bad fella due to

00:10:45,709 --> 00:10:51,740
complexity reasons and to retry all that

00:10:49,100 --> 00:10:54,439
queries separately without any batching

00:10:51,740 --> 00:10:57,769
but this solution is also yet to be

00:10:54,439 --> 00:11:01,970
developed well I'm happy we are speaking

00:10:57,769 --> 00:11:05,689
about the concept about graph QL queries

00:11:01,970 --> 00:11:08,569
cobalt components frankly in gillip

00:11:05,689 --> 00:11:11,569
ecosystem we were using few acts maybe

00:11:08,569 --> 00:11:15,680
who is not familiar with view it's a

00:11:11,569 --> 00:11:18,439
view alternative for redux and well I do

00:11:15,680 --> 00:11:22,730
not like your eggs I do not like Redux

00:11:18,439 --> 00:11:26,420
for its verbosity but there is one thing

00:11:22,730 --> 00:11:28,490
I should admit it's testable we can

00:11:26,420 --> 00:11:30,829
easily test the component both to

00:11:28,490 --> 00:11:33,439
vicster by mocking entire store if I

00:11:30,829 --> 00:11:36,649
need to test the component and if I need

00:11:33,439 --> 00:11:38,899
to test the storage ik I can easily use

00:11:36,649 --> 00:11:40,879
mutations unfortunately compared to

00:11:38,899 --> 00:11:43,399
Redux we do not have pure functions

00:11:40,879 --> 00:11:45,949
there the mutating state but they are

00:11:43,399 --> 00:11:48,980
required to be synchronous and have no

00:11:45,949 --> 00:11:51,079
side effects so pretty easy to test and

00:11:48,980 --> 00:11:52,910
for actions which are actually

00:11:51,079 --> 00:11:55,040
performing side effects well I need to

00:11:52,910 --> 00:11:57,769
provide some marks but it works

00:11:55,040 --> 00:12:00,410
and it's easy as understandable what

00:11:57,769 --> 00:12:02,209
about the power with via Paulo plugin

00:12:00,410 --> 00:12:04,459
we're using at github we are doing

00:12:02,209 --> 00:12:07,399
pretty much the same we are replacing

00:12:04,459 --> 00:12:10,370
the whole view Apollo instance we are

00:12:07,399 --> 00:12:13,999
asserting that proper queries were run

00:12:10,370 --> 00:12:15,290
with proper variables but the thing and

00:12:13,999 --> 00:12:17,990
we're mocking the response by the

00:12:15,290 --> 00:12:21,800
thinnest Apollo has much more magic

00:12:17,990 --> 00:12:24,139
underneath than views and sometimes some

00:12:21,800 --> 00:12:27,439
components could expect that cache

00:12:24,139 --> 00:12:31,569
change should be triggered and component

00:12:27,439 --> 00:12:33,889
should be changed properly in react

00:12:31,569 --> 00:12:37,540
luckily they have a react testing

00:12:33,889 --> 00:12:39,620
library that exposes mock provider but

00:12:37,540 --> 00:12:42,620
unfortunately we don't have any

00:12:39,620 --> 00:12:43,730
alternative of mock provider for view so

00:12:42,620 --> 00:12:47,359
far

00:12:43,730 --> 00:12:50,119
yeah well while this is set I have even

00:12:47,359 --> 00:12:53,629
more interesting and a bit rhetorical

00:12:50,119 --> 00:12:55,999
question for you how many developers do

00:12:53,629 --> 00:12:59,660
you think we need to provide a unique ID

00:12:55,999 --> 00:13:02,199
for graph QL response the current answer

00:12:59,660 --> 00:13:04,519
is well just one but it takes some time

00:13:02,199 --> 00:13:07,339
let me explain what we are speaking

00:13:04,519 --> 00:13:09,819
about well let me explain and this is a

00:13:07,339 --> 00:13:12,529
really spooky story about unique IDs

00:13:09,819 --> 00:13:14,299
this is design management application

00:13:12,529 --> 00:13:16,819
and I'm the main front-end developer

00:13:14,299 --> 00:13:19,069
responsible for this design management

00:13:16,819 --> 00:13:21,649
is all about uploading images and

00:13:19,069 --> 00:13:25,489
creating discussions on different part

00:13:21,649 --> 00:13:27,769
of these images and one good feature

00:13:25,489 --> 00:13:30,889
here is we're using it so we you can

00:13:27,769 --> 00:13:32,839
have versions of a single design imagine

00:13:30,889 --> 00:13:35,660
your designer provided you with some

00:13:32,839 --> 00:13:40,339
kind of design and you upload this to

00:13:35,660 --> 00:13:40,910
the page but then a designer is like in

00:13:40,339 --> 00:13:44,029
five days

00:13:40,910 --> 00:13:45,559
oh it's cropped in the wrong way you

00:13:44,029 --> 00:13:48,709
should have a different one so you're

00:13:45,559 --> 00:13:50,449
applauding the right cropped image you

00:13:48,709 --> 00:13:52,759
check the version is good you open the

00:13:50,449 --> 00:13:56,569
image to see if it's fine and hello

00:13:52,759 --> 00:13:58,519
Steve well so why do we have Steve

00:13:56,569 --> 00:14:00,919
picture for version although it's

00:13:58,519 --> 00:14:04,100
expected to be built ah

00:14:00,919 --> 00:14:07,489
once again I have an explanation the

00:14:04,100 --> 00:14:09,470
reason is that how we treat your data

00:14:07,489 --> 00:14:10,399
when you're uploading the designing

00:14:09,470 --> 00:14:12,529
gitlab

00:14:10,399 --> 00:14:16,069
you are not just doing and applaud to

00:14:12,529 --> 00:14:18,679
some fancy cloud storage yo you should

00:14:16,069 --> 00:14:22,069
own your data so what actually happens

00:14:18,679 --> 00:14:25,069
underneath you are making a commit to

00:14:22,069 --> 00:14:28,189
your own repository using get large file

00:14:25,069 --> 00:14:30,019
storage neat LFS and they're all images

00:14:28,189 --> 00:14:32,389
connected to your repository are

00:14:30,019 --> 00:14:34,730
uploaded and stored there get lab

00:14:32,389 --> 00:14:37,220
doesn't own the data so way you can

00:14:34,730 --> 00:14:40,009
clone your repository and you will have

00:14:37,220 --> 00:14:42,589
your issue images and we are just

00:14:40,009 --> 00:14:45,769
drawing metadata and since we are using

00:14:42,589 --> 00:14:46,030
git for storing images we obviously have

00:14:45,769 --> 00:14:48,850
an

00:14:46,030 --> 00:14:52,060
d for each image provided by git and is

00:14:48,850 --> 00:14:55,030
guaranteed to be unique but as you

00:14:52,060 --> 00:14:57,820
remember get calls are very expensive

00:14:55,030 --> 00:15:01,360
compared to the today's calls so and

00:14:57,820 --> 00:15:05,080
each issue can expand include like 10

00:15:01,360 --> 00:15:07,120
designs maybe 100 design in that ways

00:15:05,080 --> 00:15:11,140
the things could very quickly go doomed

00:15:07,120 --> 00:15:13,330
so instead of providing Creole ID our

00:15:11,140 --> 00:15:17,290
baguette is hand crafting some kind of

00:15:13,330 --> 00:15:20,050
fake ID based on metadata and it

00:15:17,290 --> 00:15:23,110
wouldn't be an issue if we had REST API

00:15:20,050 --> 00:15:26,290
because in this case we could provide

00:15:23,110 --> 00:15:29,050
version number in every single endpoint

00:15:26,290 --> 00:15:30,970
and also an ID and the combination of

00:15:29,050 --> 00:15:33,940
two of them would create a unique

00:15:30,970 --> 00:15:36,550
identifier but with a default caching

00:15:33,940 --> 00:15:39,430
strategy of Apollo client we have the

00:15:36,550 --> 00:15:43,990
same IDs here that's why a poet read

00:15:39,430 --> 00:15:46,480
them is the same well in order to fix

00:15:43,990 --> 00:15:48,940
this at least for front-end site while

00:15:46,480 --> 00:15:52,210
we're waiting for back-end we need to

00:15:48,940 --> 00:15:54,400
jump in and interfere with how Apple is

00:15:52,210 --> 00:15:57,490
calculating caches for our type name

00:15:54,400 --> 00:16:00,190
design they think we'll look at bit

00:15:57,490 --> 00:16:06,010
nicer with the recent release of Apollo

00:16:00,190 --> 00:16:07,110
client free but well I don't like it at

00:16:06,010 --> 00:16:10,750
all

00:16:07,110 --> 00:16:12,850
I'm feel really ashamed now because

00:16:10,750 --> 00:16:17,490
guess who is the author of this piece of

00:16:12,850 --> 00:16:22,930
code and guess who will reuse it ok but

00:16:17,490 --> 00:16:26,620
yet speaking about this this hack is not

00:16:22,930 --> 00:16:29,290
even perfect even so it looks ugly it

00:16:26,620 --> 00:16:31,630
doesn't work 100% of time because with

00:16:29,290 --> 00:16:35,110
our strategy of applauding multiple

00:16:31,630 --> 00:16:36,880
designs we still can have an invariant

00:16:35,110 --> 00:16:39,730
error from Apollo because we rely

00:16:36,880 --> 00:16:42,760
heavily on optimistic responses oh yeah

00:16:39,730 --> 00:16:43,450
we already remembered Steve today so how

00:16:42,760 --> 00:16:49,270
does it sound

00:16:43,450 --> 00:16:52,240
there is one more thing so

00:16:49,270 --> 00:16:54,330
this is optimistic response for one of

00:16:52,240 --> 00:16:57,870
the mutations of design management and

00:16:54,330 --> 00:17:01,029
while it looks simple and understandable

00:16:57,870 --> 00:17:04,600
it's a real disaster to write all these

00:17:01,029 --> 00:17:06,490
by hand while we have Apollo and the

00:17:04,600 --> 00:17:11,079
main idea of Apollo is actually to infer

00:17:06,490 --> 00:17:13,750
these things yeah I reason why we need

00:17:11,079 --> 00:17:15,670
to write so much code because all that

00:17:13,750 --> 00:17:19,780
unknown nullable fails and they're

00:17:15,670 --> 00:17:22,959
required well I really love how Apollo

00:17:19,780 --> 00:17:25,300
approach to the magic I really love the

00:17:22,959 --> 00:17:27,309
code again Apollo provides but I feel

00:17:25,300 --> 00:17:30,550
like this is a great opportunity for

00:17:27,309 --> 00:17:33,940
code generation also please give me some

00:17:30,550 --> 00:17:37,030
tool which will help me to generate

00:17:33,940 --> 00:17:42,040
these base it on the schema which we

00:17:37,030 --> 00:17:44,380
already parsing and to impress to enrich

00:17:42,040 --> 00:17:46,600
it with the data which is required by my

00:17:44,380 --> 00:17:47,320
business logic current Isis is not

00:17:46,600 --> 00:17:49,330
possible

00:17:47,320 --> 00:17:52,600
additionally remember we are not using

00:17:49,330 --> 00:17:55,360
typescript we have no way to guarantee

00:17:52,600 --> 00:17:57,760
right now that this optimistic response

00:17:55,360 --> 00:18:01,179
is kept in sync with the backend schema

00:17:57,760 --> 00:18:04,990
and obviously this leads to the errors

00:18:01,179 --> 00:18:08,170
and well errors are inevitable in our

00:18:04,990 --> 00:18:10,240
life and our developers live the

00:18:08,170 --> 00:18:12,700
question is not how you're avoiding them

00:18:10,240 --> 00:18:14,500
but how you're handling them and another

00:18:12,700 --> 00:18:16,660
spooky moment and error handling

00:18:14,500 --> 00:18:19,720
etiquette lab is pretty much

00:18:16,660 --> 00:18:22,630
minimalistic right now usually I just

00:18:19,720 --> 00:18:24,520
have 500 internal server error and I

00:18:22,630 --> 00:18:27,280
need to dive deep into development log

00:18:24,520 --> 00:18:30,010
to understand what's going on here but

00:18:27,280 --> 00:18:33,040
we have a bigger issue because there is

00:18:30,010 --> 00:18:36,070
a graphical spec defining that errors

00:18:33,040 --> 00:18:39,309
should be handled on the top level yeah

00:18:36,070 --> 00:18:41,050
and we have an outer of graphical Ruby

00:18:39,309 --> 00:18:43,510
the game we are using for creating that

00:18:41,050 --> 00:18:46,600
and he has his own opinion how we should

00:18:43,510 --> 00:18:49,059
handle errors he's insisting that

00:18:46,600 --> 00:18:51,309
especially for mutations you should

00:18:49,059 --> 00:18:53,860
handle errors as a part of schema

00:18:51,309 --> 00:18:56,410
providing additional errors not the top

00:18:53,860 --> 00:18:59,919
level errors he's making two major

00:18:56,410 --> 00:19:01,660
points first for some reason really

00:18:59,919 --> 00:19:04,080
unknown to me at the MoMA

00:19:01,660 --> 00:19:06,220
the graphical spec from my facebook

00:19:04,080 --> 00:19:10,210
explicitly states that there could be

00:19:06,220 --> 00:19:12,310
only one error for field so there is no

00:19:10,210 --> 00:19:15,400
limitations in data structure just plain

00:19:12,310 --> 00:19:17,560
array but for some reason it is and it's

00:19:15,400 --> 00:19:19,690
normal fulfilled how multiple for

00:19:17,560 --> 00:19:22,750
example validation errors that's why it

00:19:19,690 --> 00:19:24,970
seems weird and another thing that when

00:19:22,750 --> 00:19:27,880
you have error bound to the field and

00:19:24,970 --> 00:19:30,460
the field is not nullable this error is

00:19:27,880 --> 00:19:32,920
bubbling up to till the first nullable

00:19:30,460 --> 00:19:34,540
field well as JavaScript developer I

00:19:32,920 --> 00:19:39,220
don't understand why they do not love

00:19:34,540 --> 00:19:41,170
bubbling we do but as a grunt as a ruby

00:19:39,220 --> 00:19:45,160
developers it seems they're not so happy

00:19:41,170 --> 00:19:47,860
about that and as a result at gitlab we

00:19:45,160 --> 00:19:51,280
have some kind of lovely mix of errors

00:19:47,860 --> 00:19:53,740
thrown on the top level and errors as

00:19:51,280 --> 00:19:56,290
field and this makes me really unhappy

00:19:53,740 --> 00:19:58,690
as a front-end developer why because

00:19:56,290 --> 00:20:01,600
apollo client and none of other clients

00:19:58,690 --> 00:20:03,940
as long as I know threads error as

00:20:01,600 --> 00:20:06,550
filled as an actual error that's why I

00:20:03,940 --> 00:20:08,740
can't rely on Apollo client error

00:20:06,550 --> 00:20:11,200
handling yeah

00:20:08,740 --> 00:20:13,630
just time a bit more morning from me the

00:20:11,200 --> 00:20:16,600
type checking there is a Fantasyland

00:20:13,630 --> 00:20:20,980
when everything is perfect and there is

00:20:16,600 --> 00:20:25,000
a real world of gitlab well and I feel a

00:20:20,980 --> 00:20:28,630
bit jealous why the type 2 team did a

00:20:25,000 --> 00:20:30,370
great job allowing people like us who

00:20:28,630 --> 00:20:33,310
are not capable of switching to

00:20:30,370 --> 00:20:36,940
typescript to type-check our JavaScript

00:20:33,310 --> 00:20:39,100
files using GS doc you're you're capable

00:20:36,940 --> 00:20:40,480
to leveraging almost all power of

00:20:39,100 --> 00:20:44,410
typescript type-checking

00:20:40,480 --> 00:20:48,100
without doing actual migration but there

00:20:44,410 --> 00:20:50,620
is now tooling available not in the app

00:20:48,100 --> 00:20:52,810
our ecosystem neither in entire graph

00:20:50,620 --> 00:20:57,960
Caracas system which is capable to

00:20:52,810 --> 00:21:01,300
generate type definitions with GS doc so

00:20:57,960 --> 00:21:04,480
what do we have for a conclusion

00:21:01,300 --> 00:21:06,640
first of all even so it's a spooky story

00:21:04,480 --> 00:21:09,190
I can say that craft ale and the polis

00:21:06,640 --> 00:21:11,980
tech allows you to make a gradual

00:21:09,190 --> 00:21:14,140
migration really smoothly improving the

00:21:11,980 --> 00:21:15,640
developer experience especially on the

00:21:14,140 --> 00:21:17,110
front and side because I'm front-end

00:21:15,640 --> 00:21:19,150
engineer and I can speak for our

00:21:17,110 --> 00:21:21,610
back-end engineers and I hope they won't

00:21:19,150 --> 00:21:25,060
catch me out of the door to say about

00:21:21,610 --> 00:21:29,200
the vert developer experience also it's

00:21:25,060 --> 00:21:31,690
increasing throughput and as well I'm

00:21:29,200 --> 00:21:34,780
speaking for front-end code it's really

00:21:31,690 --> 00:21:36,120
maintainable is it readable and it's

00:21:34,780 --> 00:21:39,370
just easier to work with

00:21:36,120 --> 00:21:42,130
well it seems I'm not just a guy who is

00:21:39,370 --> 00:21:45,250
complaining about the things I'm also

00:21:42,130 --> 00:21:47,530
the guy who likes to put the Asterix to

00:21:45,250 --> 00:21:50,590
your guidelines yeah another a asterisks

00:21:47,530 --> 00:21:52,870
yeah so well yes we have a developer

00:21:50,590 --> 00:21:55,090
experience of course compared to rest is

00:21:52,870 --> 00:21:57,460
great but I'm still jealous it's not as

00:21:55,090 --> 00:22:00,220
great as react with staff have a room to

00:21:57,460 --> 00:22:02,560
improve for view community well

00:22:00,220 --> 00:22:04,500
regarding developer performance and

00:22:02,560 --> 00:22:07,510
throughput I spent three days

00:22:04,500 --> 00:22:09,790
researching our metrics and belief as

00:22:07,510 --> 00:22:11,590
are my team bound to metrics we are

00:22:09,790 --> 00:22:14,170
gathering a lot of different performance

00:22:11,590 --> 00:22:18,820
metrics in gitlab to prove that graph

00:22:14,170 --> 00:22:21,520
curve helps us to perform faster the

00:22:18,820 --> 00:22:25,900
main question is I could neither confirm

00:22:21,520 --> 00:22:28,810
it nor deny right now it seems that the

00:22:25,900 --> 00:22:30,820
mathematical statistical methods clearly

00:22:28,810 --> 00:22:32,740
says that we need more take have to

00:22:30,820 --> 00:22:35,410
evaluate it and that we are currently

00:22:32,740 --> 00:22:37,300
just establishing the platform and of

00:22:35,410 --> 00:22:38,560
course we spend some more data for

00:22:37,300 --> 00:22:40,900
things we've never done before right

00:22:38,560 --> 00:22:43,240
like writing code resolvers and dealing

00:22:40,900 --> 00:22:44,410
with weird problems and well

00:22:43,240 --> 00:22:47,560
maintainability

00:22:44,410 --> 00:22:49,480
my main concern actually well the

00:22:47,560 --> 00:22:51,610
maintainability of our graphical

00:22:49,480 --> 00:22:54,880
solution greatly depends on our Oracle

00:22:51,610 --> 00:22:57,760
skills white as you see there are still

00:22:54,880 --> 00:23:00,850
some lines which are not toast is so

00:22:57,760 --> 00:23:03,250
obvious for us like error handling like

00:23:00,850 --> 00:23:06,610
type checking and actually there are a

00:23:03,250 --> 00:23:09,490
lot of more and if we pick a runway

00:23:06,610 --> 00:23:12,680
which will not be adopted by community

00:23:09,490 --> 00:23:15,950
right now we just will end with this

00:23:12,680 --> 00:23:18,800
legacy just the graphical flavor so

00:23:15,950 --> 00:23:20,870
that's why it is really important to for

00:23:18,800 --> 00:23:24,050
us and I'm really happy to be here

00:23:20,870 --> 00:23:26,990
because discussing the graphical future

00:23:24,050 --> 00:23:29,510
and graph QL with entire users and

00:23:26,990 --> 00:23:32,600
entire people who are moving graphical

00:23:29,510 --> 00:23:34,520
forward probably will help me and will

00:23:32,600 --> 00:23:37,310
help l'Italia and will help get laughs

00:23:34,520 --> 00:23:39,620
to make right choice and to show you

00:23:37,310 --> 00:23:44,740
have a bright future of graph QL in

00:23:39,620 --> 00:23:47,150
entire system and ad develop specially

00:23:44,740 --> 00:23:50,119
thank you yeah thank you

00:23:47,150 --> 00:23:50,119

YouTube URL: https://www.youtube.com/watch?v=mCKRJxvMnf0


