Title: LinkedIn's Economic Graph on GraphQL (GOPAL HOLLA - Staff Software Engineer at LinkedIn Corporation)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	LinkedIn is leveraging GraphQL to enable easier addition and access of entities in the Economic Graph for first party products. The talk will present LinkedInâ€™s vision for modelling entities (like member, activity, company etc.), defining privacy rules and enabling a consistent access experience across online, nearline and offline environments.
Captions: 
	00:00:01,140 --> 00:00:06,090
so good morning everyone here my name is

00:00:03,750 --> 00:00:07,140
Gopal has Jesse introduced me and I'm

00:00:06,090 --> 00:00:09,900
here today to talk to you about

00:00:07,140 --> 00:00:13,139
Lincoln's journey of making its economic

00:00:09,900 --> 00:00:14,820
graph accessible by a graph QL before we

00:00:13,139 --> 00:00:16,530
start talking about how we made it

00:00:14,820 --> 00:00:18,960
accessible let's talk about what the

00:00:16,530 --> 00:00:20,840
economic graph is if you go in

00:00:18,960 --> 00:00:24,360
linkedin.com and load up your profile

00:00:20,840 --> 00:00:26,400
it's a it's a graph that shows up with a

00:00:24,360 --> 00:00:28,170
bunch of interconnectedness for example

00:00:26,400 --> 00:00:30,240
you are a member on LinkedIn you have

00:00:28,170 --> 00:00:33,210
had a few jobs you've worked at a few

00:00:30,240 --> 00:00:34,740
companies the logo show up so this is

00:00:33,210 --> 00:00:36,450
essentially the economic graph a bunch

00:00:34,740 --> 00:00:39,420
of entities that we are putting together

00:00:36,450 --> 00:00:41,489
to provide a product so you can imagine

00:00:39,420 --> 00:00:44,700
that there are individual entities like

00:00:41,489 --> 00:00:45,600
member like job company and things like

00:00:44,700 --> 00:00:47,489
that and there's a lot of

00:00:45,600 --> 00:00:49,560
interconnectedness between them members

00:00:47,489 --> 00:00:52,530
go to certain schools jobs require

00:00:49,560 --> 00:00:54,450
certain skills etc so essentially the

00:00:52,530 --> 00:00:56,309
economic graph is a digital

00:00:54,450 --> 00:00:59,700
representation of the global economy and

00:00:56,309 --> 00:01:02,399
we have some impressive numbers 645

00:00:59,700 --> 00:01:04,680
million members 35k skills 30 million

00:01:02,399 --> 00:01:05,940
companies 20 million open jobs and 90 K

00:01:04,680 --> 00:01:07,200
schools and there's a lot of

00:01:05,940 --> 00:01:09,330
interconnectedness between these

00:01:07,200 --> 00:01:10,830
entities a lot of products use the

00:01:09,330 --> 00:01:15,120
center connectedness to deliver some

00:01:10,830 --> 00:01:16,680
value so how do we today serve out the

00:01:15,120 --> 00:01:18,360
economic graph so let's look at our

00:01:16,680 --> 00:01:20,520
current tech stack before we look at how

00:01:18,360 --> 00:01:23,580
graph QL can help us so we have all of

00:01:20,520 --> 00:01:25,920
these entities all of them are served in

00:01:23,580 --> 00:01:27,650
isolation so each there is a back-end

00:01:25,920 --> 00:01:30,060
service serving each of these entities

00:01:27,650 --> 00:01:32,450
these back-end services have certain

00:01:30,060 --> 00:01:34,560
rules they cannot make sideways calls

00:01:32,450 --> 00:01:36,570
they don't talk to each other someone

00:01:34,560 --> 00:01:39,330
else has to put them together they

00:01:36,570 --> 00:01:41,670
enforce data access policies so members

00:01:39,330 --> 00:01:43,799
have settings on the on linkedin.com

00:01:41,670 --> 00:01:45,360
they say my last name should not be

00:01:43,799 --> 00:01:47,100
visible to non connections and things

00:01:45,360 --> 00:01:48,689
like that so we have to enforce those

00:01:47,100 --> 00:01:51,360
data access policies before we return

00:01:48,689 --> 00:01:54,030
the data also they manage the data

00:01:51,360 --> 00:01:56,100
lifecycle if a member is added member

00:01:54,030 --> 00:01:57,990
leaves the platform there are a bunch of

00:01:56,100 --> 00:01:59,520
actions you have to take like deleting

00:01:57,990 --> 00:02:00,750
the Articles they've returned and things

00:01:59,520 --> 00:02:04,509
like that

00:02:00,750 --> 00:02:06,490
so but when you go on linkedin.com you

00:02:04,509 --> 00:02:08,709
still see a connected graph so who puts

00:02:06,490 --> 00:02:10,840
these back-end services together we have

00:02:08,709 --> 00:02:13,060
a bunch of what we call meteor services

00:02:10,840 --> 00:02:14,560
that put these entities together and

00:02:13,060 --> 00:02:16,989
present them to front-end api's which

00:02:14,560 --> 00:02:18,790
you eventually see on the UI so these

00:02:16,989 --> 00:02:20,680
material services join all of these

00:02:18,790 --> 00:02:22,510
entities together and not only do they

00:02:20,680 --> 00:02:25,000
join they might have to enforce some

00:02:22,510 --> 00:02:26,519
more privacy rules some data consistency

00:02:25,000 --> 00:02:29,709
rules and things like that

00:02:26,519 --> 00:02:30,730
what's more we have near line streaming

00:02:29,709 --> 00:02:33,430
infrastructure and offline

00:02:30,730 --> 00:02:35,440
infrastructure that follows pretty much

00:02:33,430 --> 00:02:37,000
the same template they they have some

00:02:35,440 --> 00:02:39,040
products that need to deliver value they

00:02:37,000 --> 00:02:41,590
have to put entities together so they do

00:02:39,040 --> 00:02:44,440
and they also enforce some data

00:02:41,590 --> 00:02:46,450
consistency and privacy rules so you can

00:02:44,440 --> 00:02:50,620
imagine that the code across these

00:02:46,450 --> 00:02:52,030
platforms is kind of distributed do you

00:02:50,620 --> 00:02:53,829
have the same code perhaps written in

00:02:52,030 --> 00:02:55,599
two places privacy rules have to be kept

00:02:53,829 --> 00:02:59,829
consistent between these two places and

00:02:55,599 --> 00:03:02,140
a lot of code might get repeated so we

00:02:59,829 --> 00:03:03,459
went in search of what would be an ideal

00:03:02,140 --> 00:03:05,859
solution from there we are

00:03:03,459 --> 00:03:07,359
the first thing we wanted was traversal

00:03:05,859 --> 00:03:10,840
as a first-class citizen we have a graph

00:03:07,359 --> 00:03:13,030
we want to traverse it second we want it

00:03:10,840 --> 00:03:14,859
to be expressive writing procedural code

00:03:13,030 --> 00:03:16,750
imperative code is really expressive you

00:03:14,859 --> 00:03:19,090
can come up with an API for doing pretty

00:03:16,750 --> 00:03:21,239
much anything so whatever solution we

00:03:19,090 --> 00:03:23,410
choose must retain that expressiveness

00:03:21,239 --> 00:03:24,970
third we already have world-class

00:03:23,410 --> 00:03:26,739
infrastructure we didn't want to build

00:03:24,970 --> 00:03:28,569
new infrastructure so we want that

00:03:26,739 --> 00:03:31,810
solution to easily integrate with

00:03:28,569 --> 00:03:34,329
whatever we have for since we have all

00:03:31,810 --> 00:03:35,769
of these platforms and we want the same

00:03:34,329 --> 00:03:37,810
code to be executed across a lot of

00:03:35,769 --> 00:03:39,930
these platforms we want whatever

00:03:37,810 --> 00:03:42,549
solution we choose to be portable

00:03:39,930 --> 00:03:44,829
finally it should be easy to use which

00:03:42,549 --> 00:03:45,970
means that if you see a query if you see

00:03:44,829 --> 00:03:48,060
some code it should be easy to

00:03:45,970 --> 00:03:50,530
understand extend maintain etcetera

00:03:48,060 --> 00:03:52,630
turns out that graph cal satisfies all

00:03:50,530 --> 00:03:54,639
of these requirements traversal is a

00:03:52,630 --> 00:03:56,319
first-class citizen with some open

00:03:54,639 --> 00:03:58,480
credit extensions where we use their

00:03:56,319 --> 00:04:01,419
operators it's as expressive as a REST

00:03:58,480 --> 00:04:02,829
API it's a specification so we are free

00:04:01,419 --> 00:04:05,290
to implement it however you like

00:04:02,829 --> 00:04:07,389
integrated with our systems it's also

00:04:05,290 --> 00:04:08,739
declarative which means it's portable we

00:04:07,389 --> 00:04:11,079
can port it to any platform and that

00:04:08,739 --> 00:04:13,090
platform can do whatever is specific to

00:04:11,079 --> 00:04:14,319
that platform finally it's quite easy to

00:04:13,090 --> 00:04:16,799
use if you see a graphic

00:04:14,319 --> 00:04:19,780
you know exactly what it's trying to say

00:04:16,799 --> 00:04:21,729
so what we do is we use graph QL with

00:04:19,780 --> 00:04:23,979
open card extensions and we use it

00:04:21,729 --> 00:04:26,080
currently for writing our queries and

00:04:23,979 --> 00:04:27,490
for also modeling our data access

00:04:26,080 --> 00:04:29,560
policies and we'll come to this this is

00:04:27,490 --> 00:04:34,570
the interesting part of modeling how

00:04:29,560 --> 00:04:36,780
data can be fetched and you know not we

00:04:34,570 --> 00:04:38,770
don't show data that we shouldn't show

00:04:36,780 --> 00:04:40,930
so let's work with the use case

00:04:38,770 --> 00:04:42,460
throughout this presentation it's a

00:04:40,930 --> 00:04:44,620
simple enough use case we want to fetch

00:04:42,460 --> 00:04:46,270
a particular members first name we want

00:04:44,620 --> 00:04:47,620
to fetch all the positions they've held

00:04:46,270 --> 00:04:49,660
the titles of the positions they've had

00:04:47,620 --> 00:04:50,520
and we want to respect the settings of

00:04:49,660 --> 00:04:53,500
the member

00:04:50,520 --> 00:04:55,750
so before we start writing queries let's

00:04:53,500 --> 00:04:57,520
look a bit more at how we model our

00:04:55,750 --> 00:04:59,560
graphical types that's when we can start

00:04:57,520 --> 00:05:01,660
writing queries so today at LinkedIn we

00:04:59,560 --> 00:05:05,530
use rest Lee and Pegasus we use Pegasus

00:05:01,660 --> 00:05:07,509
for modeling and the Pegasus is Express

00:05:05,530 --> 00:05:09,130
very expressive has a lot of types and

00:05:07,509 --> 00:05:11,530
LinkedIn engineers are used to writing

00:05:09,130 --> 00:05:13,150
models and Pegasus are platforms are

00:05:11,530 --> 00:05:15,460
used to Pegasus so we didn't want to

00:05:13,150 --> 00:05:17,590
change that so where do we go from there

00:05:15,460 --> 00:05:19,630
what we did was we wrote a function that

00:05:17,590 --> 00:05:21,760
takes in a bunch of Pegasus types and

00:05:19,630 --> 00:05:23,349
converts them to graphical types there

00:05:21,760 --> 00:05:25,990
are a few challenges with this like

00:05:23,349 --> 00:05:28,330
handling namespaces handling some type

00:05:25,990 --> 00:05:31,030
gaps for example Pegasus has Maps graph

00:05:28,330 --> 00:05:35,349
care dozen things like that but largely

00:05:31,030 --> 00:05:38,349
this this works so to go through our use

00:05:35,349 --> 00:05:40,870
case let's model a few entities let's

00:05:38,349 --> 00:05:43,389
start with a member a member is simple

00:05:40,870 --> 00:05:45,220
in this case the member has a unique ID

00:05:43,389 --> 00:05:47,080
they have a first name they have a last

00:05:45,220 --> 00:05:49,659
name and you can see that the output

00:05:47,080 --> 00:05:52,720
graph key on the right is pretty much

00:05:49,659 --> 00:05:54,250
similar it's just saying that things are

00:05:52,720 --> 00:05:56,020
required or optional and things like

00:05:54,250 --> 00:05:58,990
that but there's an ID that's the first

00:05:56,020 --> 00:06:00,970
name and there's a last name this model

00:05:58,990 --> 00:06:02,590
is a little bit more interesting we have

00:06:00,970 --> 00:06:05,110
a model for a position or a position

00:06:02,590 --> 00:06:05,919
that a member has held it also contains

00:06:05,110 --> 00:06:07,539
a unique ID

00:06:05,919 --> 00:06:09,250
it contains the title string and

00:06:07,539 --> 00:06:11,320
interestingly enough it contains a

00:06:09,250 --> 00:06:14,139
reference to the member which in the

00:06:11,320 --> 00:06:16,659
Pegasus model which is on the Left it's

00:06:14,139 --> 00:06:18,520
a long it's just a reference but we have

00:06:16,659 --> 00:06:21,610
annotated it we have said that it's

00:06:18,520 --> 00:06:23,219
relation name is position it's entity

00:06:21,610 --> 00:06:26,110
that it's related to is member and

00:06:23,219 --> 00:06:28,010
cardinality is many which means that one

00:06:26,110 --> 00:06:29,720
member can hold many

00:06:28,010 --> 00:06:32,780
so some interesting things happen on the

00:06:29,720 --> 00:06:34,730
right one is that in position member is

00:06:32,780 --> 00:06:36,260
no longer a long it got resolved to the

00:06:34,730 --> 00:06:38,900
actual entity which means we can now

00:06:36,260 --> 00:06:40,700
Traverse from position to member also we

00:06:38,900 --> 00:06:42,290
inserted a reverse edge into member so

00:06:40,700 --> 00:06:43,910
that we can traverse from member to

00:06:42,290 --> 00:06:45,290
their positions and you can see that

00:06:43,910 --> 00:06:48,710
it's an array of positions because a

00:06:45,290 --> 00:06:50,270
member can hold many positions the final

00:06:48,710 --> 00:06:53,540
two models that we are going to look at

00:06:50,270 --> 00:06:54,770
is member settings let's say that the

00:06:53,540 --> 00:06:57,890
member has a setting called truncate

00:06:54,770 --> 00:07:00,169
first name which is a boolean and what

00:06:57,890 --> 00:07:03,410
we do is we then insert that settings as

00:07:00,169 --> 00:07:05,419
a type into member and you get the final

00:07:03,410 --> 00:07:07,340
member type which contains an idea first

00:07:05,419 --> 00:07:09,410
name a last name the settings that they

00:07:07,340 --> 00:07:11,240
have and the positions so we are well

00:07:09,410 --> 00:07:14,630
set up to now talk about queries and

00:07:11,240 --> 00:07:16,790
data access policies let's look at our

00:07:14,630 --> 00:07:18,350
user query what we said was we wanted to

00:07:16,790 --> 00:07:19,790
fetch our particular members first name

00:07:18,350 --> 00:07:22,130
we want to fetch all the titles they've

00:07:19,790 --> 00:07:24,380
held but we want to make sure that their

00:07:22,130 --> 00:07:26,120
settings are on earth the user query is

00:07:24,380 --> 00:07:29,510
quite simple to write you have a profile

00:07:26,120 --> 00:07:31,910
you want the member whose ID is some

00:07:29,510 --> 00:07:33,790
member ID and you want their first name

00:07:31,910 --> 00:07:35,810
that positions and the tackler

00:07:33,790 --> 00:07:37,970
now let's look at the data access

00:07:35,810 --> 00:07:40,820
policies how do we respect the members

00:07:37,970 --> 00:07:42,560
first-name settings what we do is we

00:07:40,820 --> 00:07:44,810
model data access policies as user

00:07:42,560 --> 00:07:46,280
defined functions but these are pure

00:07:44,810 --> 00:07:48,260
functions that declare their inputs

00:07:46,280 --> 00:07:50,180
through graph QL what does that mean

00:07:48,260 --> 00:07:52,490
let's look at the first name access

00:07:50,180 --> 00:07:54,169
policy that we want to use we want to

00:07:52,490 --> 00:07:56,510
show the full name if the member is

00:07:54,169 --> 00:07:58,130
viewing their own profile or the member

00:07:56,510 --> 00:08:00,380
has said it's okay to show that full

00:07:58,130 --> 00:08:01,880
full first name if neither of this is

00:08:00,380 --> 00:08:04,370
true we want to truncate it to just the

00:08:01,880 --> 00:08:07,310
first letter so how do we express the

00:08:04,370 --> 00:08:08,600
input to this user-defined function it

00:08:07,310 --> 00:08:11,060
turns out that we can express it by a

00:08:08,600 --> 00:08:12,919
graph QL so if you look at the graphical

00:08:11,060 --> 00:08:14,650
query on the right it's saying exactly

00:08:12,919 --> 00:08:18,410
what we said in English it is saying

00:08:14,650 --> 00:08:19,970
show the members first name if the ID is

00:08:18,410 --> 00:08:21,620
the same as viewer ID which means the

00:08:19,970 --> 00:08:23,990
member is viewing their own profile or

00:08:21,620 --> 00:08:26,630
if their settings say that it's okay to

00:08:23,990 --> 00:08:28,669
not truncate that first name so this UDF

00:08:26,630 --> 00:08:30,650
is using this graphical query as input

00:08:28,669 --> 00:08:33,289
now let's look at the UDF itself it's a

00:08:30,650 --> 00:08:35,030
pure function it's receiving the raw

00:08:33,289 --> 00:08:37,130
value of the first name and it's

00:08:35,030 --> 00:08:38,870
receiving the access policy result that

00:08:37,130 --> 00:08:40,760
it just defined putting these two

00:08:38,870 --> 00:08:41,180
together it can determine whether the

00:08:40,760 --> 00:08:42,740
first name

00:08:41,180 --> 00:08:45,649
should be shown or it should be

00:08:42,740 --> 00:08:47,600
truncated so the code in the actual UDF

00:08:45,649 --> 00:08:49,040
is quite simple it says does the access

00:08:47,600 --> 00:08:50,899
policy result contain a key called

00:08:49,040 --> 00:08:55,460
first-name if it does return the

00:08:50,899 --> 00:08:57,380
first-name Aziz if not truncated so we

00:08:55,460 --> 00:08:58,730
have now defined models we have defined

00:08:57,380 --> 00:09:00,589
queries we have defined data access

00:08:58,730 --> 00:09:03,529
policies how do we go about executing

00:09:00,589 --> 00:09:06,080
this query so executing the query sticks

00:09:03,529 --> 00:09:08,480
a bit of putting a lot of stuff together

00:09:06,080 --> 00:09:10,250
for one we want to merge the user query

00:09:08,480 --> 00:09:11,390
with the data access input policies

00:09:10,250 --> 00:09:13,070
because there are a lot more

00:09:11,390 --> 00:09:15,320
opportunities for optimization in that

00:09:13,070 --> 00:09:17,450
case we want to optimize the queries one

00:09:15,320 --> 00:09:20,450
once we put them together third we have

00:09:17,450 --> 00:09:22,010
a lot of disparate sources for example

00:09:20,450 --> 00:09:24,080
we have our in-house document store

00:09:22,010 --> 00:09:26,209
called espresso we have a bunch of REST

00:09:24,080 --> 00:09:28,399
API so that source of truth data we have

00:09:26,209 --> 00:09:30,800
other systems like Venice which store

00:09:28,399 --> 00:09:32,209
derived data etc so we want to be able

00:09:30,800 --> 00:09:35,050
to fetch from all of these derived

00:09:32,209 --> 00:09:37,310
sources so what do we use for executing

00:09:35,050 --> 00:09:39,080
here's where Apache calcite comes in

00:09:37,310 --> 00:09:42,529
Apache calcite is a open source Apache

00:09:39,080 --> 00:09:44,810
project which basically is a sequel

00:09:42,529 --> 00:09:47,060
database kind of engine where you plug

00:09:44,810 --> 00:09:48,320
in your own adapters so how does this

00:09:47,060 --> 00:09:49,730
work it provides an abstract

00:09:48,320 --> 00:09:51,980
representation of your queries called a

00:09:49,730 --> 00:09:55,130
query tree it provides a query optimizer

00:09:51,980 --> 00:09:57,560
it also provides some execution engine

00:09:55,130 --> 00:09:59,750
artifacts like it it knows how to filter

00:09:57,560 --> 00:10:01,520
it knows how to project it knows how to

00:09:59,750 --> 00:10:04,490
sort a granade and things like this

00:10:01,520 --> 00:10:06,050
finally it also provides the ability to

00:10:04,490 --> 00:10:07,790
put in pluggable adapters you want to

00:10:06,050 --> 00:10:10,459
talk to your own store sure write an

00:10:07,790 --> 00:10:12,790
adapter to do it and it works it's just

00:10:10,459 --> 00:10:15,620
an interface that you have to conform to

00:10:12,790 --> 00:10:17,510
so now let's go through the cycle of

00:10:15,620 --> 00:10:19,339
executing the user query that we just

00:10:17,510 --> 00:10:21,589
got so first thing we need to do is

00:10:19,339 --> 00:10:24,110
parse that graphical query into what

00:10:21,589 --> 00:10:25,970
apache calcite will understand so what

00:10:24,110 --> 00:10:28,190
we want to do is take a graphical query

00:10:25,970 --> 00:10:30,079
that comes in and put it into the apache

00:10:28,190 --> 00:10:32,089
calcite representation so we'll go

00:10:30,079 --> 00:10:33,500
through this exercise for the query and

00:10:32,089 --> 00:10:36,529
the data access policies because both of

00:10:33,500 --> 00:10:39,050
them are graphical queries so how does

00:10:36,529 --> 00:10:42,170
the query tree for the user query look

00:10:39,050 --> 00:10:45,290
like so the this query tree is quite

00:10:42,170 --> 00:10:46,550
simple it says scan member use a filter

00:10:45,290 --> 00:10:49,310
on member because we have asked for a

00:10:46,550 --> 00:10:51,230
particular member project the ID and the

00:10:49,310 --> 00:10:52,970
first name though the query only asks

00:10:51,230 --> 00:10:54,610
for first name it turns out that we need

00:10:52,970 --> 00:10:58,339
the ID to do some joint

00:10:54,610 --> 00:10:59,839
then we also scan positions and we

00:10:58,339 --> 00:11:01,430
project the title and the member and

00:10:59,839 --> 00:11:02,959
again we need member because it turns

00:11:01,430 --> 00:11:05,269
out we need to join them together and

00:11:02,959 --> 00:11:07,550
finally we do a left outer join of the

00:11:05,269 --> 00:11:10,490
members ID with the position dot member

00:11:07,550 --> 00:11:13,209
so simple enough the data access policy

00:11:10,490 --> 00:11:16,190
is even simpler it says scan member and

00:11:13,209 --> 00:11:18,259
there's a bunch of conditions which

00:11:16,190 --> 00:11:20,449
which is the data access policy and

00:11:18,259 --> 00:11:22,310
project the first name so now we have to

00:11:20,449 --> 00:11:25,250
query trees independently for the user

00:11:22,310 --> 00:11:27,110
query and the data access policy now we

00:11:25,250 --> 00:11:28,630
need to put them together so that we can

00:11:27,110 --> 00:11:31,100
optimize it and look for opportunities

00:11:28,630 --> 00:11:33,769
do not make the same downstream calls

00:11:31,100 --> 00:11:36,529
again and again so here's what we start

00:11:33,769 --> 00:11:38,720
with there these these queries are

00:11:36,529 --> 00:11:41,170
unchanged on the left is the user query

00:11:38,720 --> 00:11:43,730
on the right is the data access policy

00:11:41,170 --> 00:11:45,560
we want to put them together the first

00:11:43,730 --> 00:11:48,139
thing that happens is the data access

00:11:45,560 --> 00:11:50,180
policy gets an extra projection it

00:11:48,139 --> 00:11:52,339
didn't have an ID projection but we just

00:11:50,180 --> 00:11:54,380
put in one because it we want to join it

00:11:52,339 --> 00:11:57,680
with this can of member that already

00:11:54,380 --> 00:11:59,630
exists and how does that work we just do

00:11:57,680 --> 00:12:01,699
a left outer join now what happens is

00:11:59,630 --> 00:12:04,040
the query result that comes out will

00:12:01,699 --> 00:12:06,199
contain both the raw first name and the

00:12:04,040 --> 00:12:09,079
first name that came out as a fault as a

00:12:06,199 --> 00:12:10,730
result of the access policy so the scan

00:12:09,079 --> 00:12:12,350
of member on the right may or may not

00:12:10,730 --> 00:12:14,839
have the first name depending on what

00:12:12,350 --> 00:12:17,240
the data access policy said so now we

00:12:14,839 --> 00:12:20,690
have a one giant merged query and we

00:12:17,240 --> 00:12:21,680
have to go ahead and execute it so this

00:12:20,690 --> 00:12:23,660
is a lot happening on this slide so

00:12:21,680 --> 00:12:26,959
we'll break this down and see what

00:12:23,660 --> 00:12:28,730
exactly we do to execute stuff the first

00:12:26,959 --> 00:12:31,250
thing we do is we push down filter

00:12:28,730 --> 00:12:33,980
predicates it turns out that we know

00:12:31,250 --> 00:12:37,040
that we want to scan a particular member

00:12:33,980 --> 00:12:39,589
and we also know that member has been

00:12:37,040 --> 00:12:41,810
joined with another member which is a

00:12:39,589 --> 00:12:43,819
self join and we know member dot ID

00:12:41,810 --> 00:12:46,310
equal to m2 dot ID this means that

00:12:43,819 --> 00:12:48,589
whatever filters exist on member dot ID

00:12:46,310 --> 00:12:51,470
the same filters can be transported to

00:12:48,589 --> 00:12:53,240
member to dot ID so we do that why do we

00:12:51,470 --> 00:12:54,980
do this it's because most of our

00:12:53,240 --> 00:12:56,689
backends are key value stores they want

00:12:54,980 --> 00:13:00,649
a key so that they can look up a value

00:12:56,689 --> 00:13:03,139
the previous query that we had for the

00:13:00,649 --> 00:13:05,689
data access policy just said for every

00:13:03,139 --> 00:13:06,720
member here is the policy but key value

00:13:05,689 --> 00:13:08,819
stores want

00:13:06,720 --> 00:13:11,040
single member so we added an extra

00:13:08,819 --> 00:13:14,519
filter they're saying ID equal to member

00:13:11,040 --> 00:13:15,959
ID and the data access policy we can do

00:13:14,519 --> 00:13:18,600
the same thing for position we are going

00:13:15,959 --> 00:13:20,430
to arrest API without filters the rest

00:13:18,600 --> 00:13:22,410
api cannot return as all the positions

00:13:20,430 --> 00:13:24,060
that's that's not feasible so what we

00:13:22,410 --> 00:13:25,560
did was we looked at the join condition

00:13:24,060 --> 00:13:27,180
the join condition says member ID equal

00:13:25,560 --> 00:13:29,459
to position member and we push that

00:13:27,180 --> 00:13:31,139
filter predicate down this is a simple

00:13:29,459 --> 00:13:32,699
enough query the the filters are

00:13:31,139 --> 00:13:34,800
available statically you can move them

00:13:32,699 --> 00:13:36,899
during planning time it happens it so

00:13:34,800 --> 00:13:38,490
happens that there are queries where

00:13:36,899 --> 00:13:39,779
these filters are not available at

00:13:38,490 --> 00:13:42,870
planning time which means that you have

00:13:39,779 --> 00:13:44,699
to query a certain part of finish a part

00:13:42,870 --> 00:13:45,870
of the query before you can transmit

00:13:44,699 --> 00:13:48,839
those filters to other parts of the

00:13:45,870 --> 00:13:51,120
query we can do that too so you can if

00:13:48,839 --> 00:13:52,709
this member ID was not available if you

00:13:51,120 --> 00:13:54,810
were looking up a member by first name

00:13:52,709 --> 00:13:56,699
instead we could actually go down to a

00:13:54,810 --> 00:13:58,889
search index that gives us all the

00:13:56,699 --> 00:14:01,379
members fetch their IDs and then insert

00:13:58,889 --> 00:14:02,939
them on wherever they're required but

00:14:01,379 --> 00:14:06,389
this is a simple enough query and we can

00:14:02,939 --> 00:14:09,029
move them at planning time once we have

00:14:06,389 --> 00:14:11,519
moved all of these queries all of these

00:14:09,029 --> 00:14:15,420
filters in we are now ready to fetch

00:14:11,519 --> 00:14:17,459
whatever we want so what we can get data

00:14:15,420 --> 00:14:21,750
from the rest endpoint we can get data

00:14:17,459 --> 00:14:24,149
from our espresso an espresso document

00:14:21,750 --> 00:14:26,189
store but we are querying member twice

00:14:24,149 --> 00:14:27,360
and with the same ID so it doesn't it

00:14:26,189 --> 00:14:29,040
doesn't make sense for us to go to

00:14:27,360 --> 00:14:31,110
espresso and ask it again and again for

00:14:29,040 --> 00:14:33,360
the same member ID so we insert a per

00:14:31,110 --> 00:14:35,189
query cache that knows what we have

00:14:33,360 --> 00:14:38,009
already asked for and jessa

00:14:35,189 --> 00:14:40,379
returns that data as 'is this query

00:14:38,009 --> 00:14:42,569
cache is only for a single query if you

00:14:40,379 --> 00:14:44,399
make this query again the cache will be

00:14:42,569 --> 00:14:46,589
removed and there will be another cache

00:14:44,399 --> 00:14:48,569
that comes in just for that query so we

00:14:46,589 --> 00:14:50,129
can retain read after write consistency

00:14:48,569 --> 00:14:52,170
if you change your profile on LinkedIn

00:14:50,129 --> 00:14:53,519
com you want to see the latest thing you

00:14:52,170 --> 00:14:58,740
don't want to see some cached version of

00:14:53,519 --> 00:15:01,529
it after we execute all of this stuff we

00:14:58,740 --> 00:15:04,170
have an output and the result set which

00:15:01,529 --> 00:15:06,180
is a common construct in sequel looks

00:15:04,170 --> 00:15:08,550
like what is on the top it's returning

00:15:06,180 --> 00:15:10,410
the ID of the member the first name of

00:15:08,550 --> 00:15:12,540
the member the idea of the member again

00:15:10,410 --> 00:15:16,160
first name of the member again and then

00:15:12,540 --> 00:15:18,860
the title and the members ID

00:15:16,160 --> 00:15:20,360
so it we have a bunch of resultset

00:15:18,860 --> 00:15:21,200
that's not how we want to present it to

00:15:20,360 --> 00:15:22,430
our clients because they made a

00:15:21,200 --> 00:15:23,990
graphical query they're expecting a

00:15:22,430 --> 00:15:26,510
graphical response so we need to do some

00:15:23,990 --> 00:15:28,820
post-processing also we need to apply

00:15:26,510 --> 00:15:30,740
those data access policies that we just

00:15:28,820 --> 00:15:31,280
put into the query so how does that

00:15:30,740 --> 00:15:35,120
happen

00:15:31,280 --> 00:15:38,690
so on the left is all of the data that

00:15:35,120 --> 00:15:40,340
we got out from the query imagine that

00:15:38,690 --> 00:15:42,500
there is a member whose first name is

00:15:40,340 --> 00:15:44,780
Jane and they've held three positions

00:15:42,500 --> 00:15:46,880
which is Swee senior Swee and stuffs we

00:15:44,780 --> 00:15:49,700
it turns out that the result set has

00:15:46,880 --> 00:15:52,610
three rows as output because it's a

00:15:49,700 --> 00:15:54,440
cartesian product but most of it the

00:15:52,610 --> 00:15:56,660
first four columns are always the same

00:15:54,440 --> 00:15:58,640
and the fifth column changes it turns

00:15:56,660 --> 00:16:00,140
out that we can collect this into a

00:15:58,640 --> 00:16:01,760
response that looks like a graphical

00:16:00,140 --> 00:16:04,310
query because we know that the first

00:16:01,760 --> 00:16:06,950
four columns don't change so once we

00:16:04,310 --> 00:16:08,720
collect this on the right is what it

00:16:06,950 --> 00:16:10,850
looks like there is a member whose first

00:16:08,720 --> 00:16:12,410
name has been populated who the access

00:16:10,850 --> 00:16:14,060
policy result is also available so this

00:16:12,410 --> 00:16:15,980
is not yet ready to send down to the

00:16:14,060 --> 00:16:18,800
client and then we have all the

00:16:15,980 --> 00:16:21,230
positions that they've had so now we

00:16:18,800 --> 00:16:22,550
need to apply our access policies so we

00:16:21,230 --> 00:16:26,030
have the access policy result this is

00:16:22,550 --> 00:16:27,620
exactly what are you DF asked for so we

00:16:26,030 --> 00:16:29,450
deliver that access policy result and

00:16:27,620 --> 00:16:31,460
the raw value of the first name which is

00:16:29,450 --> 00:16:33,620
Jane to this function so in this example

00:16:31,460 --> 00:16:35,330
the member is viewing their own profile

00:16:33,620 --> 00:16:37,520
member ID equal to V or ID equal to one

00:16:35,330 --> 00:16:39,440
so it turns out that the member can look

00:16:37,520 --> 00:16:40,850
at their own first-name the one of the

00:16:39,440 --> 00:16:42,710
conditions was members allowed to look

00:16:40,850 --> 00:16:45,230
at their own first-name so what happens

00:16:42,710 --> 00:16:47,240
when this UDF receives the access policy

00:16:45,230 --> 00:16:49,790
result is it can see that first name

00:16:47,240 --> 00:16:51,440
exists in this access policy raiser so

00:16:49,790 --> 00:16:53,420
it just returns the first-name Aziz and

00:16:51,440 --> 00:16:56,390
we have the output and we can send this

00:16:53,420 --> 00:16:58,550
back to the client let us look at

00:16:56,390 --> 00:17:00,500
another example the other example is

00:16:58,550 --> 00:17:03,620
that someone else is viewing the member

00:17:00,500 --> 00:17:05,209
member ID is 1v or IDs two and the

00:17:03,620 --> 00:17:07,970
member has asked for their first name to

00:17:05,209 --> 00:17:09,589
be truncated so the output from the

00:17:07,970 --> 00:17:12,350
result set is slightly different you'll

00:17:09,589 --> 00:17:14,630
notice that the fourth column is now

00:17:12,350 --> 00:17:16,910
null because the conditions fail neither

00:17:14,630 --> 00:17:19,130
was the member viewing themselves nor

00:17:16,910 --> 00:17:21,680
were they allowing us to show the first

00:17:19,130 --> 00:17:24,050
name on truncated so it turns out that

00:17:21,680 --> 00:17:25,790
the when we collect the response the

00:17:24,050 --> 00:17:27,560
first name access policy result does not

00:17:25,790 --> 00:17:30,050
contain the first name anymore

00:17:27,560 --> 00:17:32,150
and the UDF now knows what to do it

00:17:30,050 --> 00:17:34,070
knows that the first name does not exist

00:17:32,150 --> 00:17:35,990
in the access policy result so it just

00:17:34,070 --> 00:17:39,140
truncates the first name and here's the

00:17:35,990 --> 00:17:42,470
output you get first name just j' right

00:17:39,140 --> 00:17:44,480
so we do all of this post-processing so

00:17:42,470 --> 00:17:46,460
that and there is a bunch of things that

00:17:44,480 --> 00:17:49,040
we can do each of these fields that we

00:17:46,460 --> 00:17:50,660
have first name last name etc can have

00:17:49,040 --> 00:17:53,810
their own data access policies and we

00:17:50,660 --> 00:17:55,190
merge them and it also the good thing

00:17:53,810 --> 00:17:57,200
about this is since graph kol you

00:17:55,190 --> 00:17:59,120
project exactly what you want you don't

00:17:57,200 --> 00:18:01,010
apply data access policies on the things

00:17:59,120 --> 00:18:03,140
that you didn't project so this

00:18:01,010 --> 00:18:04,970
naturally lends to what we want to do

00:18:03,140 --> 00:18:08,140
which is don't call things that we don't

00:18:04,970 --> 00:18:11,690
want to look at the third thing is that

00:18:08,140 --> 00:18:13,250
this sort of construct can be used for a

00:18:11,690 --> 00:18:15,620
variety of different things here we are

00:18:13,250 --> 00:18:18,050
using for data access policies we also

00:18:15,620 --> 00:18:19,700
use it for derived data for example the

00:18:18,050 --> 00:18:21,200
member might contain a full name we

00:18:19,700 --> 00:18:23,360
don't want all of our clients trying to

00:18:21,200 --> 00:18:25,280
compute a full name instead we offer it

00:18:23,360 --> 00:18:26,990
to compute it for them and it turns out

00:18:25,280 --> 00:18:28,700
that it can be modeled exactly the same

00:18:26,990 --> 00:18:30,380
way you have a graphical query that says

00:18:28,700 --> 00:18:32,030
give me the first-name and lastname and

00:18:30,380 --> 00:18:35,180
AUD of that concatenates them together

00:18:32,030 --> 00:18:36,800
so all of this derived data data access

00:18:35,180 --> 00:18:40,370
policy result you can express that

00:18:36,800 --> 00:18:41,960
through graphical queries and a UDF so

00:18:40,370 --> 00:18:43,340
now we come to the question of

00:18:41,960 --> 00:18:46,400
portability we have all of these

00:18:43,340 --> 00:18:49,640
Nearline and offline infrastructure that

00:18:46,400 --> 00:18:51,890
needs all of this data so we are working

00:18:49,640 --> 00:18:54,440
on making the UDF themselves portable

00:18:51,890 --> 00:18:56,390
because each of these platforms has

00:18:54,440 --> 00:18:57,890
their own requirements of how what

00:18:56,390 --> 00:19:00,710
format the data should be delivered in

00:18:57,890 --> 00:19:03,220
what's performant etc but it week today

00:19:00,710 --> 00:19:05,210
we can convert some graphical queries to

00:19:03,220 --> 00:19:07,490
sequel and spark sequence so what

00:19:05,210 --> 00:19:09,740
happens is somebody defines a query and

00:19:07,490 --> 00:19:11,540
all the data access policies and we can

00:19:09,740 --> 00:19:14,080
convert that into spark sequel and run

00:19:11,540 --> 00:19:17,690
it on spark and all through this

00:19:14,080 --> 00:19:20,270
exercise the people who define these

00:19:17,690 --> 00:19:21,980
entities member company they only have

00:19:20,270 --> 00:19:23,720
to write code for their UDF's they write

00:19:21,980 --> 00:19:25,430
no other code they just provide us some

00:19:23,720 --> 00:19:27,500
models and some data access policies

00:19:25,430 --> 00:19:30,260
expressed as graphical queries and a

00:19:27,500 --> 00:19:31,970
bunch of pure functions and we know how

00:19:30,260 --> 00:19:34,010
to put this graph together make it

00:19:31,970 --> 00:19:36,320
privacy compliant out of the box compute

00:19:34,010 --> 00:19:40,730
derive data etcetera so the amount of

00:19:36,320 --> 00:19:43,130
code that is rewritten or duplicated is

00:19:40,730 --> 00:19:45,320
is almost non-existent and these graph

00:19:43,130 --> 00:19:47,090
these graphical queries and these UDF's

00:19:45,320 --> 00:19:49,190
work on all platforms so you don't have

00:19:47,090 --> 00:19:51,320
to write the same thing across platforms

00:19:49,190 --> 00:19:56,600
worried about keeping these platforms

00:19:51,320 --> 00:19:58,250
and sync etc so calcite is also is a

00:19:56,600 --> 00:20:00,380
helper for all of this because calcite

00:19:58,250 --> 00:20:02,990
square a tree representation is very

00:20:00,380 --> 00:20:05,240
very abstract so you can turn that into

00:20:02,990 --> 00:20:07,700
any declarative language that you want

00:20:05,240 --> 00:20:10,280
so here's how we are extending to near

00:20:07,700 --> 00:20:12,110
line and off line so that's it from me

00:20:10,280 --> 00:20:14,510
you can talk to me after this

00:20:12,110 --> 00:20:17,030
presentation or that there's my vanity

00:20:14,510 --> 00:20:19,370
name on LinkedIn Viji khol la we are

00:20:17,030 --> 00:20:20,690
also hiring so you can look us up and if

00:20:19,370 --> 00:20:23,000
you're interested we'd be happy to talk

00:20:20,690 --> 00:20:27,019
to you thank you so much

00:20:23,000 --> 00:20:27,019

YouTube URL: https://www.youtube.com/watch?v=C5t3QYch1Tk


