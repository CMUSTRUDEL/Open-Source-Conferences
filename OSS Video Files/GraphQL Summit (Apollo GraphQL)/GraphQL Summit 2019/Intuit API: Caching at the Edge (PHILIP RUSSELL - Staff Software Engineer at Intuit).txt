Title: Intuit API: Caching at the Edge (PHILIP RUSSELL - Staff Software Engineer at Intuit)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Learn how Intuit uses GraphQL Service Orchestration and Caching to handle hundreds of services and serve millions of Customers.
Captions: 
	00:00:04,349 --> 00:00:08,010
all right so first of all thanks

00:00:06,430 --> 00:00:11,080
everyone for making it at 9:00 a.m.

00:00:08,010 --> 00:00:13,690
that's a challenge for some people so

00:00:11,080 --> 00:00:15,070
thank you very much like jig said my

00:00:13,690 --> 00:00:16,570
name is Phil Russell I'm gonna be

00:00:15,070 --> 00:00:19,540
talking about essentially a caching

00:00:16,570 --> 00:00:21,370
scheme that's implemented in into it's

00:00:19,540 --> 00:00:25,630
kind of custom that graphic you

00:00:21,370 --> 00:00:27,520
Orchestrator and bit about me so I'm a

00:00:25,630 --> 00:00:30,370
staff software engineer at into its I

00:00:27,520 --> 00:00:31,750
work in services API infrastructure as

00:00:30,370 --> 00:00:33,760
far as stuff that I like it's you know

00:00:31,750 --> 00:00:35,829
compilers language API frameworks and

00:00:33,760 --> 00:00:37,660
distributed systems so it turns out the

00:00:35,829 --> 00:00:40,890
graph QL is actually a really good kind

00:00:37,660 --> 00:00:42,850
of center point for all of those right

00:00:40,890 --> 00:00:44,230
okay so what are we gonna be talking

00:00:42,850 --> 00:00:46,690
about today we're gonna be talking about

00:00:44,230 --> 00:00:47,980
graph QL it into it specifically we're

00:00:46,690 --> 00:00:50,409
gonna be talking about like I said a

00:00:47,980 --> 00:00:53,800
caching scheme that kind of supports our

00:00:50,409 --> 00:00:54,819
you know larger scale use cases we're

00:00:53,800 --> 00:00:56,800
gonna be talking about control

00:00:54,819 --> 00:00:57,999
mechanisms for that cache and then we're

00:00:56,800 --> 00:01:00,190
gonna be talking a little bit about

00:00:57,999 --> 00:01:04,269
eventing and caches and kind of some

00:01:00,190 --> 00:01:08,290
challenges they're in right so section

00:01:04,269 --> 00:01:10,149
one okay so what goes on it into it well

00:01:08,290 --> 00:01:11,950
one of the things that when you kind of

00:01:10,149 --> 00:01:13,450
search around for graph QL you know

00:01:11,950 --> 00:01:14,110
especially on the tutorials and things

00:01:13,450 --> 00:01:16,000
like that

00:01:14,110 --> 00:01:18,729
you kinda end up with like you know I

00:01:16,000 --> 00:01:20,289
have my schema I have twenty types you

00:01:18,729 --> 00:01:22,750
know I have like four services that I

00:01:20,289 --> 00:01:25,180
talk to and everything's nice and you

00:01:22,750 --> 00:01:26,560
know well formulated and I can you can

00:01:25,180 --> 00:01:28,810
actually like trace the traffic through

00:01:26,560 --> 00:01:31,359
that entire example right it doesn't

00:01:28,810 --> 00:01:33,159
really work that way it into it so we

00:01:31,359 --> 00:01:35,680
have eight eighteen hundred addressable

00:01:33,159 --> 00:01:36,939
entities we have ten thousand expanded

00:01:35,680 --> 00:01:39,039
types you know along like the

00:01:36,939 --> 00:01:41,320
connections and edges and things like

00:01:39,039 --> 00:01:43,030
that we have over a billion requests per

00:01:41,320 --> 00:01:45,850
day hundred product teams you know

00:01:43,030 --> 00:01:47,679
thousand different services so we kind

00:01:45,850 --> 00:01:49,659
of get into this problem of well you

00:01:47,679 --> 00:01:51,520
know I want to go and build you know

00:01:49,659 --> 00:01:53,380
some great new product and we have these

00:01:51,520 --> 00:01:55,960
tons and tons of services that do great

00:01:53,380 --> 00:01:58,119
things how do I actually go and tie them

00:01:55,960 --> 00:02:00,460
all together right in kind of a sane way

00:01:58,119 --> 00:02:04,299
right and that's where graphic you all

00:02:00,460 --> 00:02:08,110
kind of enters the picture so this is

00:02:04,299 --> 00:02:09,759
your classic graphical gateway picture

00:02:08,110 --> 00:02:11,800
and like I said really

00:02:09,759 --> 00:02:13,130
what goes on is we have for the past

00:02:11,800 --> 00:02:16,250
five years we've been running

00:02:13,130 --> 00:02:17,870
a custom graph DL gateway and then I'm

00:02:16,250 --> 00:02:19,190
gonna go and talking basically about the

00:02:17,870 --> 00:02:20,300
caching layer in a little bit but I just

00:02:19,190 --> 00:02:22,310
want to make sure that everyone's kinda

00:02:20,300 --> 00:02:24,560
on the same page about what a good first

00:02:22,310 --> 00:02:26,270
step looks like right so we basically

00:02:24,560 --> 00:02:28,010
just have a request come in and we go to

00:02:26,270 --> 00:02:30,920
the gateway the Gateway basically

00:02:28,010 --> 00:02:32,780
figures out you know here's type X it

00:02:30,920 --> 00:02:34,490
goes to service Y and this goes on for

00:02:32,780 --> 00:02:37,010
however many services that you want to

00:02:34,490 --> 00:02:38,870
tie together from your query right so if

00:02:37,010 --> 00:02:40,790
you're familiar at all with you know

00:02:38,870 --> 00:02:43,190
Apollo Gateway or how that works you

00:02:40,790 --> 00:02:46,070
know you've seen that then same idea

00:02:43,190 --> 00:02:50,360
right and yes it does say best service

00:02:46,070 --> 00:02:53,840
I'm not gonna talk about that part okay

00:02:50,360 --> 00:02:55,970
so problems at scale right so again this

00:02:53,840 --> 00:02:59,810
goes back to uh I don't think I rid of

00:02:55,970 --> 00:03:01,460
my whatever that's fine I had a nice

00:02:59,810 --> 00:03:02,750
little emoji of right in the middle that

00:03:01,460 --> 00:03:04,610
kind of look cool and then for some

00:03:02,750 --> 00:03:05,810
reason Google Docs decided to get rid of

00:03:04,610 --> 00:03:08,540
that so what can you do

00:03:05,810 --> 00:03:10,280
okay so you know assume you have like a

00:03:08,540 --> 00:03:12,410
hundred different services right and

00:03:10,280 --> 00:03:14,750
then assuming some access control your

00:03:12,410 --> 00:03:17,000
some client you go and make a query you

00:03:14,750 --> 00:03:18,500
can go hit all hundred of them right so

00:03:17,000 --> 00:03:20,480
again if we going back to our previous

00:03:18,500 --> 00:03:22,070
slide that's gonna go and funnel through

00:03:20,480 --> 00:03:24,770
this graphical gateway so you can

00:03:22,070 --> 00:03:26,450
imagine you know you get like a million

00:03:24,770 --> 00:03:27,200
different queries doing all this bad

00:03:26,450 --> 00:03:31,640
things can happen

00:03:27,200 --> 00:03:32,690
so specifically bad things n plus one so

00:03:31,640 --> 00:03:35,030
if you're not familiar with that

00:03:32,690 --> 00:03:37,010
basically what it means is that every

00:03:35,030 --> 00:03:39,170
single type in your query shards off to

00:03:37,010 --> 00:03:40,820
a different service right and then you

00:03:39,170 --> 00:03:42,800
have problems because at that point it

00:03:40,820 --> 00:03:45,530
just basically comes it's sort of like

00:03:42,800 --> 00:03:47,330
how a stampeding cache kind of works but

00:03:45,530 --> 00:03:48,800
it for services or they just keep

00:03:47,330 --> 00:03:50,230
rotating around and around and around

00:03:48,800 --> 00:03:53,120
across your different services

00:03:50,230 --> 00:03:57,080
everything goes down this is it happened

00:03:53,120 --> 00:03:58,570
right I've been in the calls so it is it

00:03:57,080 --> 00:04:01,160
is definitely a real thing okay

00:03:58,570 --> 00:04:02,750
so solution one how do you how do you

00:04:01,160 --> 00:04:04,940
kind of mitigate these things right so a

00:04:02,750 --> 00:04:07,400
solution one is well you basically do

00:04:04,940 --> 00:04:10,040
graph compaction on the different types

00:04:07,400 --> 00:04:12,920
and you say let's collate all the common

00:04:10,040 --> 00:04:14,690
sub fields or sub components to the same

00:04:12,920 --> 00:04:17,239
service that we know will map to that

00:04:14,690 --> 00:04:19,489
right so if you're not you haven't

00:04:17,239 --> 00:04:20,720
really seen that basically it means you

00:04:19,489 --> 00:04:23,120
know you can kind of regard it as

00:04:20,720 --> 00:04:25,460
everything inside of a graphical request

00:04:23,120 --> 00:04:26,990
it's a tree so you say you know

00:04:25,460 --> 00:04:29,120
this portion is gonna go to this service

00:04:26,990 --> 00:04:30,979
this portion to go to this service so

00:04:29,120 --> 00:04:35,000
you basically compact along those lines

00:04:30,979 --> 00:04:37,580
right solution to cash everything right

00:04:35,000 --> 00:04:38,750
it's kind of a brute force solution but

00:04:37,580 --> 00:04:41,600
actually it works pretty well in

00:04:38,750 --> 00:04:45,500
practice right so mitigate effects of n

00:04:41,600 --> 00:04:46,970
plus 1 so kind of our first app that

00:04:45,500 --> 00:04:49,370
that can ends up looking like this

00:04:46,970 --> 00:04:52,000
right what we say yeah let's just cash

00:04:49,370 --> 00:04:54,800
at the service level right all's well

00:04:52,000 --> 00:04:56,600
well but there's still problems because

00:04:54,800 --> 00:04:57,770
you know this this works if you have

00:04:56,600 --> 00:04:59,990
three different services going

00:04:57,770 --> 00:05:03,740
downstream doesn't really tend to work

00:04:59,990 --> 00:05:07,910
so hot if you have you know 100 ok so

00:05:03,740 --> 00:05:08,960
and we'll get Y so again hundred

00:05:07,910 --> 00:05:12,110
different services hundred different

00:05:08,960 --> 00:05:13,759
caching layers at into its scales

00:05:12,110 --> 00:05:15,710
specifically that causes a lot of

00:05:13,759 --> 00:05:18,020
developer friction because we allow you

00:05:15,710 --> 00:05:20,210
to create services right we say here's

00:05:18,020 --> 00:05:22,849
this automated pattern to go create

00:05:20,210 --> 00:05:24,050
different services well by the way if

00:05:22,849 --> 00:05:25,639
you want to go and plug in our graphic

00:05:24,050 --> 00:05:27,500
you all you know orchestrators and you

00:05:25,639 --> 00:05:29,449
got to go and set up your own caching

00:05:27,500 --> 00:05:32,120
layer well that turns out to be kind of

00:05:29,449 --> 00:05:34,880
a high friction barrier that a lot of

00:05:32,120 --> 00:05:36,620
teams don't want to deal with there's no

00:05:34,880 --> 00:05:38,210
way to coordinate any of this right so

00:05:36,620 --> 00:05:40,099
you're just gonna have duplicate data

00:05:38,210 --> 00:05:41,900
floating around in different caches

00:05:40,099 --> 00:05:44,720
there's gonna basically gonna have no

00:05:41,900 --> 00:05:46,849
one copy from a minute over here and one

00:05:44,720 --> 00:05:48,979
copy of it from 30 seconds over here how

00:05:46,849 --> 00:05:50,210
do you reconcile all this it gets in

00:05:48,979 --> 00:05:51,770
because you know at that point there's

00:05:50,210 --> 00:05:53,810
no source of truth except for going down

00:05:51,770 --> 00:05:55,280
to the data provider again that point

00:05:53,810 --> 00:05:59,240
why are you really cashing in this way

00:05:55,280 --> 00:06:00,889
anyway right so how to solve cache at

00:05:59,240 --> 00:06:03,680
the edge kind of the point of this talk

00:06:00,889 --> 00:06:04,909
or at least my title but really you

00:06:03,680 --> 00:06:06,919
should kind of think of this as you know

00:06:04,909 --> 00:06:10,849
let's go and try to get a common data

00:06:06,919 --> 00:06:14,479
layer or at least a common l1 cache okay

00:06:10,849 --> 00:06:16,099
so that's what light-blue is here so if

00:06:14,479 --> 00:06:19,940
we go back to how you know basically

00:06:16,099 --> 00:06:22,820
caching or sorry l1 l2 cache works

00:06:19,940 --> 00:06:25,099
inside of a wes's so we can kind of

00:06:22,820 --> 00:06:27,139
think of this caching layer for everyone

00:06:25,099 --> 00:06:29,870
it's kind of our l1 and then basically

00:06:27,139 --> 00:06:32,449
the the service specific caches our l2

00:06:29,870 --> 00:06:33,770
right so in this picture we haven't

00:06:32,449 --> 00:06:36,289
gotten rid of the service specific

00:06:33,770 --> 00:06:37,760
caches but we are pushing and common

00:06:36,289 --> 00:06:39,289
data layer over to the Gateway and

00:06:37,760 --> 00:06:41,719
that's basically the

00:06:39,289 --> 00:06:43,789
source of truth for most of the system

00:06:41,719 --> 00:06:46,460
right so if a client basically if you're

00:06:43,789 --> 00:06:47,779
just uh you know another downstream

00:06:46,460 --> 00:06:49,219
service and you want to say I want to

00:06:47,779 --> 00:06:50,539
set up you don't have to go and build

00:06:49,219 --> 00:06:52,699
and know their cache if you don't want

00:06:50,539 --> 00:06:54,499
to you can basically just cache it the

00:06:52,699 --> 00:06:59,779
edge in this case the edge being the

00:06:54,499 --> 00:07:01,369
gateway right so oh and another point if

00:06:59,779 --> 00:07:02,449
you add intrinsic functions inside of

00:07:01,369 --> 00:07:04,819
this light blue if you know what those

00:07:02,449 --> 00:07:09,199
are you have a data grid for man's

00:07:04,819 --> 00:07:10,819
version anyway okay so caching at the

00:07:09,199 --> 00:07:12,169
edge right so this is kind of covers why

00:07:10,819 --> 00:07:14,149
already went through but we're gonna

00:07:12,169 --> 00:07:16,219
lean into some other things so basically

00:07:14,149 --> 00:07:19,430
our request response caching just isn't

00:07:16,219 --> 00:07:21,319
really good enough so for example let's

00:07:19,430 --> 00:07:24,469
say that you know query one goes off to

00:07:21,319 --> 00:07:26,389
one and two query 2 goes off to service

00:07:24,469 --> 00:07:27,949
is one and three we're gonna get a lot

00:07:26,389 --> 00:07:30,979
of duplicate data evening in the side of

00:07:27,949 --> 00:07:32,689
the common caching tier right which does

00:07:30,979 --> 00:07:35,360
matter at scale when you're making you

00:07:32,689 --> 00:07:36,559
know billion requests over a day because

00:07:35,360 --> 00:07:40,669
basically you're just gonna fill up your

00:07:36,559 --> 00:07:42,080
entire memory buffers right so so we

00:07:40,669 --> 00:07:44,389
want to ask is there a way to store and

00:07:42,080 --> 00:07:45,800
find common components um and that's

00:07:44,389 --> 00:07:47,749
kind of what we're gonna cover in the

00:07:45,800 --> 00:07:54,139
next big section which is overlapping

00:07:47,749 --> 00:07:56,709
response caching all right okay so basic

00:07:54,139 --> 00:07:59,719
idea how does this really work right so

00:07:56,709 --> 00:08:01,849
I'm gonna use a Star Wars API as a

00:07:59,719 --> 00:08:05,959
motivating example and I'm gonna enhance

00:08:01,849 --> 00:08:07,490
it later on in a much nicer way so well

00:08:05,959 --> 00:08:08,839
you know let's kind of like look at

00:08:07,490 --> 00:08:10,789
these two queries right so we have one

00:08:08,839 --> 00:08:13,879
query that comes in it basically asks

00:08:10,789 --> 00:08:16,129
for you know some set of character

00:08:13,879 --> 00:08:17,659
information we have another query that

00:08:16,129 --> 00:08:19,399
comes in that asked for essentially the

00:08:17,659 --> 00:08:21,409
same or a subset of that carrot

00:08:19,399 --> 00:08:23,180
character information right and

00:08:21,409 --> 00:08:25,159
basically we just did this naive request

00:08:23,180 --> 00:08:27,199
response caching we would basically

00:08:25,159 --> 00:08:29,749
create duplicate entries everywhere

00:08:27,199 --> 00:08:32,300
right so what we want that is to say hey

00:08:29,749 --> 00:08:35,409
look this component is the same across

00:08:32,300 --> 00:08:37,939
everything I just want to pull that data

00:08:35,409 --> 00:08:40,099
right from the cache for this component

00:08:37,939 --> 00:08:43,159
and insert it into my response for query

00:08:40,099 --> 00:08:46,040
to write or however many queries this

00:08:43,159 --> 00:08:48,019
goes along alright well that sounds

00:08:46,040 --> 00:08:50,120
great but you know whenever we will go

00:08:48,019 --> 00:08:50,850
in cache stuff we need to have keys and

00:08:50,120 --> 00:08:52,680
we need to be able to

00:08:50,850 --> 00:08:53,970
do an apples-to-apples comparison to

00:08:52,680 --> 00:08:58,709
actually go and figure all this out

00:08:53,970 --> 00:09:01,620
right so how do we do that basically an

00:08:58,709 --> 00:09:04,380
object ID right this is just kind of two

00:09:01,620 --> 00:09:07,380
core properties which is that it is the

00:09:04,380 --> 00:09:10,350
same across a request for whatever is a

00:09:07,380 --> 00:09:12,360
basically object inside of the the

00:09:10,350 --> 00:09:14,759
request graph and it needs to be

00:09:12,360 --> 00:09:17,009
globally unique ID across the entire

00:09:14,759 --> 00:09:19,500
system so what does that mean basically

00:09:17,009 --> 00:09:22,199
means that if you go and if I go and ask

00:09:19,500 --> 00:09:24,180
for you know some character with this

00:09:22,199 --> 00:09:26,759
name and you asked for the same guy it's

00:09:24,180 --> 00:09:28,440
gonna have the same object ID right so

00:09:26,759 --> 00:09:30,600
that way that we can actually no I'm

00:09:28,440 --> 00:09:31,620
gonna map you know this character and

00:09:30,600 --> 00:09:35,660
this character and it's gonna be the

00:09:31,620 --> 00:09:38,100
same inside of the cache so actual

00:09:35,660 --> 00:09:40,290
formula is basically this it's basically

00:09:38,100 --> 00:09:43,290
a hash of a domain a type and

00:09:40,290 --> 00:09:45,389
essentially a local object ID domain is

00:09:43,290 --> 00:09:47,880
basically just a set of types you can

00:09:45,389 --> 00:09:50,399
kind of think of it as you know the Star

00:09:47,880 --> 00:09:52,529
Wars API slash characters is you know

00:09:50,399 --> 00:09:54,630
Star Wars API Z domain right and then

00:09:52,529 --> 00:10:00,029
inside of that characters is a type so

00:09:54,630 --> 00:10:01,829
there you go okay so conceptually

00:10:00,029 --> 00:10:03,839
speaking not actually really but

00:10:01,829 --> 00:10:07,170
conceptually speaking this is kind of

00:10:03,839 --> 00:10:09,660
what goes on right so basically angling

00:10:07,170 --> 00:10:12,269
down on the left is query 1 and angling

00:10:09,660 --> 00:10:13,350
down on the right is query 2 we can kind

00:10:12,269 --> 00:10:14,970
of split this up into a bunch of

00:10:13,350 --> 00:10:17,699
different sub components and essentially

00:10:14,970 --> 00:10:19,800
assign keys how do we do that we

00:10:17,699 --> 00:10:21,899
basically pars the different queries and

00:10:19,800 --> 00:10:23,310
do their AST form and then we basically

00:10:21,899 --> 00:10:24,930
use a visitor to go and decorate

00:10:23,310 --> 00:10:27,540
everything we can we compute it using

00:10:24,930 --> 00:10:30,420
that at a hash function or a certain a

00:10:27,540 --> 00:10:32,009
hash option is einman function that I

00:10:30,420 --> 00:10:34,170
basically covered in the previous slide

00:10:32,009 --> 00:10:36,120
alright the other thing that's very

00:10:34,170 --> 00:10:38,839
important you got to store each of these

00:10:36,120 --> 00:10:41,579
things inside of this run time table

00:10:38,839 --> 00:10:42,959
like I said we've run our own custom

00:10:41,579 --> 00:10:45,180
Orchestrator so we can do that sort of

00:10:42,959 --> 00:10:48,509
thing I don't know if any of the like

00:10:45,180 --> 00:10:51,000
Apollo server does that but anyway so

00:10:48,509 --> 00:10:53,009
point is that we have a common component

00:10:51,000 --> 00:10:55,410
here at the very bottom in dark blue

00:10:53,009 --> 00:10:58,939
same key right apples to apples

00:10:55,410 --> 00:11:01,920
comparisons it's very important later

00:10:58,939 --> 00:11:02,970
okay so I'm gonna go kind of go through

00:11:01,920 --> 00:11:04,440
this quickly what

00:11:02,970 --> 00:11:06,630
this is essentially the entire flow

00:11:04,440 --> 00:11:09,600
across the different queries right so I

00:11:06,630 --> 00:11:11,100
go and make you know a query for or

00:11:09,600 --> 00:11:13,230
basically what we talked about here

00:11:11,100 --> 00:11:15,840
angling down let's say I asked for all

00:11:13,230 --> 00:11:17,850
the characters in a new hope basically

00:11:15,840 --> 00:11:20,430
we go and parse things we assign the

00:11:17,850 --> 00:11:22,260
object IDs we do a lookup we get a cache

00:11:20,430 --> 00:11:24,090
miss right there's nothing in there we

00:11:22,260 --> 00:11:25,830
don't know we can't find it so we go to

00:11:24,090 --> 00:11:27,480
the character service and then we go in

00:11:25,830 --> 00:11:30,030
store or the characters and the queries

00:11:27,480 --> 00:11:32,100
oh sorry we sort the information plus

00:11:30,030 --> 00:11:33,920
the original query that originated from

00:11:32,100 --> 00:11:35,760
which will become very important later

00:11:33,920 --> 00:11:38,310
okay that's great

00:11:35,760 --> 00:11:40,830
so now query two comes in we basically

00:11:38,310 --> 00:11:43,950
say I want some of the characters or a

00:11:40,830 --> 00:11:46,920
character from a new hope we the exact

00:11:43,950 --> 00:11:49,110
same thing as in the the first query and

00:11:46,920 --> 00:11:51,630
at this point we get a hit because at

00:11:49,110 --> 00:11:53,010
some subset of the information or so

00:11:51,630 --> 00:11:54,240
actually super so the information that

00:11:53,010 --> 00:11:57,060
we're asking for is in a site cache

00:11:54,240 --> 00:12:00,000
right and critically which we'll cover

00:11:57,060 --> 00:12:04,070
in gory detail this can either be by a

00:12:00,000 --> 00:12:07,680
primary key or a secondary key right

00:12:04,070 --> 00:12:10,290
okay so how do the direct lookups work

00:12:07,680 --> 00:12:12,210
so a direct lookup is basically you're

00:12:10,290 --> 00:12:14,250
asking for you know let's in this case

00:12:12,210 --> 00:12:16,080
let's say a person from the Star Wars

00:12:14,250 --> 00:12:19,140
API and you're basically just saying you

00:12:16,080 --> 00:12:21,530
know your your object ID is this right

00:12:19,140 --> 00:12:23,970
so it's just a direct reference right

00:12:21,530 --> 00:12:25,620
this is pretty easy as far as how it

00:12:23,970 --> 00:12:27,990
works in the cache is just essentially a

00:12:25,620 --> 00:12:29,730
key value set right there so if you were

00:12:27,990 --> 00:12:33,600
back in this one cache D it's just set

00:12:29,730 --> 00:12:34,500
key value right pretty simple so this

00:12:33,600 --> 00:12:37,290
works with you know there's single

00:12:34,500 --> 00:12:39,720
object case but you know those were

00:12:37,290 --> 00:12:42,210
really simple kind of boring queries but

00:12:39,720 --> 00:12:45,750
it's like get me one thing well that's

00:12:42,210 --> 00:12:47,700
great but you know we want like actual

00:12:45,750 --> 00:12:49,980
queries like let's chain things together

00:12:47,700 --> 00:12:51,330
into a tree let's go and you know ask

00:12:49,980 --> 00:12:55,440
for everything that belongs to something

00:12:51,330 --> 00:12:56,850
else that's filter right and again this

00:12:55,440 --> 00:12:58,740
is the primary key K so it's kind of

00:12:56,850 --> 00:13:00,990
visualized so you know we go and

00:12:58,740 --> 00:13:03,300
basically map you know Han Solo and

00:13:00,990 --> 00:13:04,890
Darth Vader to these IDs the other point

00:13:03,300 --> 00:13:07,560
that that is good to keep in mind about

00:13:04,890 --> 00:13:09,780
this is that these form kind of a a leaf

00:13:07,560 --> 00:13:13,180
node in the graph and cache concept

00:13:09,780 --> 00:13:15,580
which I'll cover a little bit

00:13:13,180 --> 00:13:17,680
okay more complicated queries this is

00:13:15,580 --> 00:13:19,390
things actually care about right it's

00:13:17,680 --> 00:13:20,680
like I said I mean we never really asked

00:13:19,390 --> 00:13:23,290
for like here just giving me this guy

00:13:20,680 --> 00:13:24,760
right we asked about I had this film

00:13:23,290 --> 00:13:25,960
give me all the characters give me their

00:13:24,760 --> 00:13:28,000
homeworlds give me this give me that

00:13:25,960 --> 00:13:32,260
right obviously want compound

00:13:28,000 --> 00:13:33,460
connections right and if you kind of go

00:13:32,260 --> 00:13:37,000
through this there's really only in kind

00:13:33,460 --> 00:13:39,100
of four cases that can cover sorry three

00:13:37,000 --> 00:13:41,260
additional cases I can cover all of this

00:13:39,100 --> 00:13:43,630
where we say I want to select you know

00:13:41,260 --> 00:13:46,000
some information by a foreign key in

00:13:43,630 --> 00:13:47,410
this case we'll say you know parent key

00:13:46,000 --> 00:13:50,260
which is kind of a pointer up in the

00:13:47,410 --> 00:13:53,860
tree I want to select you know where my

00:13:50,260 --> 00:13:56,050
where my ID is in the set well I want to

00:13:53,860 --> 00:13:59,590
set where another foreign key is in a

00:13:56,050 --> 00:14:00,970
set right it may not be too obvious just

00:13:59,590 --> 00:14:02,590
kind of looking at it from left right

00:14:00,970 --> 00:14:04,720
but if you actually go in pars the

00:14:02,590 --> 00:14:06,280
semantics of how these things work

00:14:04,720 --> 00:14:07,990
behind the scenes they kind of map onto

00:14:06,280 --> 00:14:08,980
those cases and it turns out that's

00:14:07,990 --> 00:14:11,710
actually a really good thing because

00:14:08,980 --> 00:14:15,310
that sets us up for how secondary keys

00:14:11,710 --> 00:14:17,140
work right other point parent key is the

00:14:15,310 --> 00:14:18,550
kind of the microsites stuff it's the

00:14:17,140 --> 00:14:20,740
pointer to the parent in the graph which

00:14:18,550 --> 00:14:25,540
would become very important and a little

00:14:20,740 --> 00:14:28,600
bit okay so we're gonna start our

00:14:25,540 --> 00:14:31,750
secondary keys and just a review primary

00:14:28,600 --> 00:14:34,300
key is easy set key value secondary keys

00:14:31,750 --> 00:14:36,700
or where the magic happens because they

00:14:34,300 --> 00:14:39,640
allow us to essentially store trees in

00:14:36,700 --> 00:14:41,380
memory right so our cases are you know

00:14:39,640 --> 00:14:43,960
essentially equals equals foreign key

00:14:41,380 --> 00:14:46,210
and a foreign key set and a primary key

00:14:43,960 --> 00:14:47,890
set and we can cover them all using this

00:14:46,210 --> 00:14:50,590
kind of the same notation or the same

00:14:47,890 --> 00:14:52,870
secondary key function right so

00:14:50,590 --> 00:14:56,620
secondary key is computed as a hash of

00:14:52,870 --> 00:14:58,060
the type of the sub or the the thing

00:14:56,620 --> 00:15:01,120
you're looking at in this case character

00:14:58,060 --> 00:15:03,820
the actual field name in this case would

00:15:01,120 --> 00:15:06,790
be you know parent key and then the

00:15:03,820 --> 00:15:09,760
field value which is basically the you

00:15:06,790 --> 00:15:11,020
know in this case would be going ABCD

00:15:09,760 --> 00:15:13,300
for a new hope or something like that

00:15:11,020 --> 00:15:15,700
right so in this kind of gives you know

00:15:13,300 --> 00:15:17,170
the semantics of that so kind of

00:15:15,700 --> 00:15:18,700
ignoring that part how does this

00:15:17,170 --> 00:15:20,470
actually end up looking inside of the

00:15:18,700 --> 00:15:23,200
cache well we see that on the right

00:15:20,470 --> 00:15:26,910
because we can see we stored you know

00:15:23,200 --> 00:15:28,950
the film object itself key to ABCD

00:15:26,910 --> 00:15:31,410
that was just a direct assignment right

00:15:28,950 --> 00:15:33,390
and then we go in and then on top of

00:15:31,410 --> 00:15:35,460
that besides these kind of low-level

00:15:33,390 --> 00:15:37,260
objects with you know Luke Skywalker or

00:15:35,460 --> 00:15:40,170
character and Darth Vader's a character

00:15:37,260 --> 00:15:42,930
we also have this secondary key set

00:15:40,170 --> 00:15:46,350
right here and that's pointing to two

00:15:42,930 --> 00:15:48,660
other IDs right so that's basically how

00:15:46,350 --> 00:15:50,070
things all tie together because that's

00:15:48,660 --> 00:15:52,740
why we can say okay

00:15:50,070 --> 00:15:55,860
well you know if you if we can compute

00:15:52,740 --> 00:15:58,050
later that you map onto this the

00:15:55,860 --> 00:16:00,360
secondary key then we can go and pull

00:15:58,050 --> 00:16:05,100
your IDs from cache and find your entry

00:16:00,360 --> 00:16:05,460
right so we'll go into an example of

00:16:05,100 --> 00:16:09,480
that

00:16:05,460 --> 00:16:12,120
so query one I select characters for my

00:16:09,480 --> 00:16:14,970
parent keegels ABCD a new hope something

00:16:12,120 --> 00:16:16,560
like that so we get a cache miss but the

00:16:14,970 --> 00:16:19,620
data response is basically like this

00:16:16,560 --> 00:16:21,990
right that's just some some kind of JSON

00:16:19,620 --> 00:16:24,080
here you know we have Luke Skywalker we

00:16:21,990 --> 00:16:27,600
have Darth Vader here's their object IDs

00:16:24,080 --> 00:16:30,390
critically here's their parent key right

00:16:27,600 --> 00:16:33,270
so basically we do this automatically

00:16:30,390 --> 00:16:36,270
inside of an SDK we just say always

00:16:33,270 --> 00:16:38,670
return parent key to just orthos and

00:16:36,270 --> 00:16:40,920
then at that point I can create those

00:16:38,670 --> 00:16:42,930
three entries right I can say here's

00:16:40,920 --> 00:16:44,550
Luke Skywalker one two three four here's

00:16:42,930 --> 00:16:47,250
Darth Vader or five six seven eight and

00:16:44,550 --> 00:16:48,900
then I can compute the secondary key set

00:16:47,250 --> 00:16:52,170
and map one you know and those two keys

00:16:48,900 --> 00:16:54,990
inside of it right so at that point what

00:16:52,170 --> 00:16:57,210
I can say is here's query to select from

00:16:54,990 --> 00:17:00,960
characters where is object ID is this

00:16:57,210 --> 00:17:03,510
right so that's Luke Skywalker I can get

00:17:00,960 --> 00:17:05,760
you know select where it's Darth Vader I

00:17:03,510 --> 00:17:07,500
get a hit I get a hit I can select where

00:17:05,760 --> 00:17:09,810
the object II is in either of those I

00:17:07,500 --> 00:17:11,490
can ask for sets now right and then I

00:17:09,810 --> 00:17:14,160
can also say select where characters

00:17:11,490 --> 00:17:17,490
where their parent key equals new hope I

00:17:14,160 --> 00:17:20,069
get a hit all right so this is basically

00:17:17,490 --> 00:17:23,339
what what really makes it all work is

00:17:20,069 --> 00:17:25,439
the fact that you can ask for several

00:17:23,339 --> 00:17:32,490
different versions of the information

00:17:25,439 --> 00:17:36,200
subsets and it's all there right so okay

00:17:32,490 --> 00:17:37,629
so how does that look like so

00:17:36,200 --> 00:17:40,669
this is where this is where it gets fun

00:17:37,629 --> 00:17:43,549
so I don't really like the Star Wars API

00:17:40,669 --> 00:17:45,169
is like a talking point because I feel

00:17:43,549 --> 00:17:47,059
it's like a little you know contrived I

00:17:45,169 --> 00:17:48,830
mean it's nice so we're gonna go ahead

00:17:47,059 --> 00:17:50,509
and extend it and we're gonna do it with

00:17:48,830 --> 00:17:53,119
something that into it actually deals

00:17:50,509 --> 00:17:55,999
with which is credit reports for turbo

00:17:53,119 --> 00:17:57,619
so you know we have a Paolo Federation

00:17:55,999 --> 00:17:59,720
now we have a Paolo gateway we can bolt

00:17:57,619 --> 00:18:02,359
on extra fields so imagine there's some

00:17:59,720 --> 00:18:04,609
new snow some extended Star Wars API

00:18:02,359 --> 00:18:08,509
schema with credit reports for the

00:18:04,609 --> 00:18:12,019
characters right so you know a little a

00:18:08,509 --> 00:18:13,460
little dorky but whatever and then as as

00:18:12,019 --> 00:18:15,559
our architect kind of put it well maybe

00:18:13,460 --> 00:18:17,509
it's there midi-chlorian count right

00:18:15,559 --> 00:18:20,119
something like that and the point is

00:18:17,509 --> 00:18:23,059
because this is this was an actual

00:18:20,119 --> 00:18:24,710
motivating engineering problem which is

00:18:23,059 --> 00:18:26,690
that you know to get credit reports you

00:18:24,710 --> 00:18:29,330
should go to TransUnion Experian whoever

00:18:26,690 --> 00:18:31,639
at point is that it's a it's a

00:18:29,330 --> 00:18:34,159
third-party service round trip can be

00:18:31,639 --> 00:18:36,230
taking a long time you know 15 seconds

00:18:34,159 --> 00:18:37,820
more and it doesn't really change that

00:18:36,230 --> 00:18:40,129
often it you know it only changes like

00:18:37,820 --> 00:18:41,749
what once a month so what's the point of

00:18:40,129 --> 00:18:43,309
kind of doing it every single time that

00:18:41,749 --> 00:18:45,529
someone asks for the credit report well

00:18:43,309 --> 00:18:47,989
there isn't right so instead what we'd

00:18:45,529 --> 00:18:50,029
like to do is just get it go and cash it

00:18:47,989 --> 00:18:52,159
for a long time and save the cost in

00:18:50,029 --> 00:18:55,129
terms of latency and everything else

00:18:52,159 --> 00:18:58,009
right so in our contrived example of

00:18:55,129 --> 00:19:00,499
this we say here let's have the credit

00:18:58,009 --> 00:19:03,200
reports for you know Owen and Beru and

00:19:00,499 --> 00:19:04,549
then we're going to basically build what

00:19:03,200 --> 00:19:06,679
that looks like inside of the object

00:19:04,549 --> 00:19:09,859
cache right and you can conceptually

00:19:06,679 --> 00:19:12,080
just see it as a two-tier tree at the

00:19:09,859 --> 00:19:14,450
men then everything that has a primary

00:19:12,080 --> 00:19:16,519
key which is a direct object ID is

00:19:14,450 --> 00:19:19,609
stored inside of the table so you know

00:19:16,519 --> 00:19:22,039
Owen has Peking Wan brew as PK - those

00:19:19,609 --> 00:19:24,919
are characters and then PK is three

00:19:22,039 --> 00:19:27,499
through six our credit reports right for

00:19:24,919 --> 00:19:30,590
them right and then basically there's

00:19:27,499 --> 00:19:33,590
actually three different secondary key

00:19:30,590 --> 00:19:36,409
sets held here so we have basically

00:19:33,590 --> 00:19:38,749
between so PK 1 + PK 2 are in the first

00:19:36,409 --> 00:19:40,759
one and then the rest on the other right

00:19:38,749 --> 00:19:42,859
the point is that whether is we're

00:19:40,759 --> 00:19:46,609
really doing is it's kind of storing the

00:19:42,859 --> 00:19:49,070
entire graph a request graph inside of

00:19:46,609 --> 00:19:51,919
the cache right across different

00:19:49,070 --> 00:19:53,899
queries right and at this point we can

00:19:51,919 --> 00:19:55,730
basically start doing stuff like I

00:19:53,899 --> 00:19:57,380
showed a little earlier which is I can

00:19:55,730 --> 00:19:59,809
start making several different versions

00:19:57,380 --> 00:20:01,970
of the same queries and ask for the

00:19:59,809 --> 00:20:07,130
different sub pieces of the data and

00:20:01,970 --> 00:20:09,769
it's all there right okay

00:20:07,130 --> 00:20:13,580
comparing queries across requests so how

00:20:09,769 --> 00:20:14,480
does this work so going back to so Star

00:20:13,580 --> 00:20:17,149
Wars API

00:20:14,480 --> 00:20:19,250
you know vanilla version so we asked for

00:20:17,149 --> 00:20:21,559
our kind of like our big chunk of data

00:20:19,250 --> 00:20:23,509
right we say for a new hope I want you

00:20:21,559 --> 00:20:26,029
know planets and characters and and

00:20:23,509 --> 00:20:29,000
whatever and then basically we we just

00:20:26,029 --> 00:20:31,039
asked for I just want the characters

00:20:29,000 --> 00:20:35,620
right so at this point we can determine

00:20:31,039 --> 00:20:37,610
is sorry at this point after having

00:20:35,620 --> 00:20:40,429
shown with the structure that I showed

00:20:37,610 --> 00:20:43,279
you previously and storing the original

00:20:40,429 --> 00:20:45,529
query that originated that structure

00:20:43,279 --> 00:20:49,759
very important point we can do a

00:20:45,529 --> 00:20:51,230
basically set comparisons right so if

00:20:49,759 --> 00:20:53,360
you take all these fields and you

00:20:51,230 --> 00:20:55,009
basically just say you know what I don't

00:20:53,360 --> 00:20:56,929
really care about objects I just care

00:20:55,009 --> 00:20:58,490
about you know film dot playing a

00:20:56,929 --> 00:21:02,149
connection that total count you know

00:20:58,490 --> 00:21:02,809
film character connection of characters

00:21:02,149 --> 00:21:04,309
that name

00:21:02,809 --> 00:21:06,830
you basically just look at them kind of

00:21:04,309 --> 00:21:08,600
like as strings really right and it

00:21:06,830 --> 00:21:10,220
works fine because it you know it's

00:21:08,600 --> 00:21:12,049
basically just a canonicalize mapping of

00:21:10,220 --> 00:21:14,720
all these different things so you say

00:21:12,049 --> 00:21:16,940
okay fine you asked for you know this

00:21:14,720 --> 00:21:18,740
set of information over here you asked

00:21:16,940 --> 00:21:20,360
for this set of information is what

00:21:18,740 --> 00:21:23,230
you're asking for over here a subset of

00:21:20,360 --> 00:21:27,289
this well then it's safe to return right

00:21:23,230 --> 00:21:28,399
so so again we must act we have to store

00:21:27,289 --> 00:21:31,159
the original query for this to actually

00:21:28,399 --> 00:21:33,950
work and then we really get a lot of

00:21:31,159 --> 00:21:35,570
cash and increased cash utilization from

00:21:33,950 --> 00:21:37,789
this right you can ask for any

00:21:35,570 --> 00:21:40,519
combination of the image got the

00:21:37,789 --> 00:21:42,350
information from the stored query inside

00:21:40,519 --> 00:21:44,870
of other queries right and this can go

00:21:42,350 --> 00:21:49,159
as long as it's held in the cache by CTL

00:21:44,870 --> 00:21:51,139
so now another point is so let's say you

00:21:49,159 --> 00:21:53,029
ask for a super set instead I guess

00:21:51,139 --> 00:21:55,220
we're talking about subsets well super

00:21:53,029 --> 00:21:58,250
set actually goes and says well it's not

00:21:55,220 --> 00:21:59,629
safe to go in and return data so I'm

00:21:58,250 --> 00:22:01,570
gonna go down to the downstream of

00:21:59,629 --> 00:22:03,909
service get that super set of data

00:22:01,570 --> 00:22:05,200
and then remap all the entries right so

00:22:03,909 --> 00:22:06,460
at that point it's basically whoever

00:22:05,200 --> 00:22:10,749
he's asking for the most information

00:22:06,460 --> 00:22:11,979
wins right and then another sticking

00:22:10,749 --> 00:22:14,379
point so if you're asking for additional

00:22:11,979 --> 00:22:15,369
input variables well basically you kind

00:22:14,379 --> 00:22:16,929
of have to do the same thing that you

00:22:15,369 --> 00:22:19,450
did with fields you have to sort them

00:22:16,929 --> 00:22:21,429
you have to canonicalize them store them

00:22:19,450 --> 00:22:23,559
alongside with a really original query

00:22:21,429 --> 00:22:25,749
and then basically do this additional

00:22:23,559 --> 00:22:27,580
sub comparison across the input

00:22:25,749 --> 00:22:29,679
variables because again we have to say

00:22:27,580 --> 00:22:32,259
you can only return stored data if it's

00:22:29,679 --> 00:22:34,929
safe to do so and you can't really say

00:22:32,259 --> 00:22:36,489
well if you asked for you know it's like

00:22:34,929 --> 00:22:38,649
it's basically function comparisons

00:22:36,489 --> 00:22:40,690
right if I went and asked for you know

00:22:38,649 --> 00:22:42,220
some permutation of the input and you

00:22:40,690 --> 00:22:43,989
asked for another one and we sort them

00:22:42,220 --> 00:22:45,489
and they're not the same thing well then

00:22:43,989 --> 00:22:50,109
it's not safe to return data from those

00:22:45,489 --> 00:22:54,070
two all right so okay so that's the

00:22:50,109 --> 00:22:55,779
scheme right and now we're gonna talk

00:22:54,070 --> 00:22:59,320
about how this works across an entire

00:22:55,779 --> 00:23:02,019
system right so basically we have some

00:22:59,320 --> 00:23:04,149
additional kind of mechanisms for making

00:23:02,019 --> 00:23:06,309
sure that different data services and

00:23:04,149 --> 00:23:08,019
clients have control over whether these

00:23:06,309 --> 00:23:10,720
things really want things cached or not

00:23:08,019 --> 00:23:13,960
right so basically just use a cache

00:23:10,720 --> 00:23:15,340
control so you know basically if you're

00:23:13,960 --> 00:23:17,679
the client you can say I don't want

00:23:15,340 --> 00:23:19,330
things cached this actually happens in

00:23:17,679 --> 00:23:21,999
our credit report example because a lot

00:23:19,330 --> 00:23:24,159
of time with what the different services

00:23:21,999 --> 00:23:26,889
end up doing is saying you know what

00:23:24,159 --> 00:23:29,019
yeah the data is in the cache but I just

00:23:26,889 --> 00:23:31,149
want to make sure you know randomly that

00:23:29,019 --> 00:23:32,769
this is the latest and greatest so I'm

00:23:31,149 --> 00:23:35,349
just gonna you know basically flip a

00:23:32,769 --> 00:23:38,259
coin and go and get the latest and

00:23:35,349 --> 00:23:39,909
greatest data right and then if you're a

00:23:38,259 --> 00:23:42,429
data service provider you can say I

00:23:39,909 --> 00:23:44,109
don't want this data stored or I wanted

00:23:42,429 --> 00:23:47,320
to store it for you know this amount of

00:23:44,109 --> 00:23:49,359
time and then zero kind of you know ends

00:23:47,320 --> 00:23:50,710
up getting abused as like evict from

00:23:49,359 --> 00:23:51,999
cache because we actually go and look at

00:23:50,710 --> 00:23:56,169
the cache control spec there's not

00:23:51,999 --> 00:24:02,080
really a an addicted ism so you know you

00:23:56,169 --> 00:24:03,820
can do that okay so this is kind of like

00:24:02,080 --> 00:24:05,739
future state this actually isn't really

00:24:03,820 --> 00:24:07,179
a thing yet I just want to touch upon

00:24:05,739 --> 00:24:09,190
this because it's kind of important when

00:24:07,179 --> 00:24:11,049
you're talking about caching and

00:24:09,190 --> 00:24:14,139
especially data consistency in a large

00:24:11,049 --> 00:24:15,220
system so really well being talking

00:24:14,139 --> 00:24:17,590
about so far is kind of

00:24:15,220 --> 00:24:19,150
request/response caching right so you

00:24:17,590 --> 00:24:20,590
know we basically made a bunch of

00:24:19,150 --> 00:24:23,250
different requests across different

00:24:20,590 --> 00:24:25,840
queries we went and set up our scheme

00:24:23,250 --> 00:24:27,760
and then we can basically say you know

00:24:25,840 --> 00:24:30,250
as a service provider can either a

00:24:27,760 --> 00:24:32,409
Victoire set or whatever great well

00:24:30,250 --> 00:24:35,440
really what we'd like to do is say you

00:24:32,409 --> 00:24:36,880
know what forget this because that

00:24:35,440 --> 00:24:38,980
basically happens all over here in terms

00:24:36,880 --> 00:24:41,230
of requests well I really like to do is

00:24:38,980 --> 00:24:43,120
say I'm a data provider

00:24:41,230 --> 00:24:45,549
I have events I'm gonna put them on a

00:24:43,120 --> 00:24:48,490
bus and then I want that put up on the

00:24:45,549 --> 00:24:50,230
on the caching tier right and then that

00:24:48,490 --> 00:24:53,890
really turns it more and more into this

00:24:50,230 --> 00:24:55,059
kind of data grid concept right so you

00:24:53,890 --> 00:24:56,919
know this kind of brings up a lot of

00:24:55,059 --> 00:24:58,450
problems because you could have tons and

00:24:56,919 --> 00:24:59,830
tons and tons of events actually more

00:24:58,450 --> 00:25:02,230
you can have more events and you can

00:24:59,830 --> 00:25:04,690
have requests in a lot of different

00:25:02,230 --> 00:25:07,390
cases alright because data changes you

00:25:04,690 --> 00:25:09,940
know a lot in certain services so how do

00:25:07,390 --> 00:25:11,919
you really deal with that and again this

00:25:09,940 --> 00:25:13,360
is kind of future like we know we were

00:25:11,919 --> 00:25:14,470
kind of figuring this out but

00:25:13,360 --> 00:25:17,559
essentially can kind of begin to this

00:25:14,470 --> 00:25:19,780
notion of you know hey you got a support

00:25:17,559 --> 00:25:21,940
basically standard interfaces across the

00:25:19,780 --> 00:25:23,559
stack and really at that point because

00:25:21,940 --> 00:25:25,000
the kind of sane way to do that is to

00:25:23,559 --> 00:25:26,679
use code Jim right

00:25:25,000 --> 00:25:29,679
you basically have to say the interfaces

00:25:26,679 --> 00:25:32,770
for for data ingestion the interfaces

00:25:29,679 --> 00:25:35,049
for at every tier essentially was the

00:25:32,770 --> 00:25:36,760
API layer or data Lake whatever if

00:25:35,049 --> 00:25:39,490
they're the same then you kind of avoid

00:25:36,760 --> 00:25:40,900
a lot of problems right and then the

00:25:39,490 --> 00:25:45,010
other thing is we basically get in this

00:25:40,900 --> 00:25:46,809
notion of kind of data snapshots where

00:25:45,010 --> 00:25:48,130
we say yes you had you know all these

00:25:46,809 --> 00:25:50,080
different events and they did all these

00:25:48,130 --> 00:25:51,820
different transforms but we can

00:25:50,080 --> 00:25:54,610
basically aggregate what that looks like

00:25:51,820 --> 00:25:56,770
within a snapshot of 10 milliseconds or

00:25:54,610 --> 00:25:58,630
so and then basically that gets what

00:25:56,770 --> 00:26:01,030
that's what gets pushed to the data tier

00:25:58,630 --> 00:26:03,190
right so you may not really be getting

00:26:01,030 --> 00:26:05,830
the latest and greatest we don't get

00:26:03,190 --> 00:26:07,570
good enough for your purposes inside of

00:26:05,830 --> 00:26:09,669
the data tier and then you can always

00:26:07,570 --> 00:26:14,799
essential you set up your mechanisms for

00:26:09,669 --> 00:26:17,559
people to bypass ok ok so let's sum up

00:26:14,799 --> 00:26:20,350
main points right so basically this this

00:26:17,559 --> 00:26:22,390
is about object IDs that are being used

00:26:20,350 --> 00:26:26,110
for this this comparison across

00:26:22,390 --> 00:26:28,480
different requests you know basically a

00:26:26,110 --> 00:26:28,790
primary key selection is very easy it's

00:26:28,480 --> 00:26:32,750
basic

00:26:28,790 --> 00:26:34,070
just a hash-table get and then if we

00:26:32,750 --> 00:26:37,520
want to do something more complicated

00:26:34,070 --> 00:26:39,410
like an actual query where we say you

00:26:37,520 --> 00:26:42,050
know let's go check against a foreign

00:26:39,410 --> 00:26:43,940
key or let's use in clauses then we have

00:26:42,050 --> 00:26:46,700
to construct these secondary key sets

00:26:43,940 --> 00:26:48,680
right so really with this forms like I

00:26:46,700 --> 00:26:50,600
said is a encash shadowgraph

00:26:48,680 --> 00:26:52,100
I'm comprising all the different

00:26:50,600 --> 00:26:54,800
relationships of the levels of the tree

00:26:52,100 --> 00:26:56,870
and then common components can be served

00:26:54,800 --> 00:26:59,870
from the cache and when essentially we

00:26:56,870 --> 00:27:02,330
say we're gonna compact everything into

00:26:59,870 --> 00:27:05,330
and the other side of the graph and the

00:27:02,330 --> 00:27:07,760
cache and then basically we use subset

00:27:05,330 --> 00:27:18,380
comparisons to go and compare different

00:27:07,760 --> 00:27:21,290
queries so there you go Thank You Phil

00:27:18,380 --> 00:27:22,970
Thank You Phil yeah yeah I think it

00:27:21,290 --> 00:27:23,930
takes oh it takes a lot of work and a

00:27:22,970 --> 00:27:26,180
lot of preparation to talk about

00:27:23,930 --> 00:27:27,170
something as hard as cache so it's

00:27:26,180 --> 00:27:29,090
really cool it's really cool the work

00:27:27,170 --> 00:27:31,010
you've done especially the visitor

00:27:29,090 --> 00:27:33,980
pattern you know traversing through the

00:27:31,010 --> 00:27:35,600
AST for object IDs is both really clever

00:27:33,980 --> 00:27:38,000
and really good use of the visitor

00:27:35,600 --> 00:27:40,940
pattern so that's great so also be

00:27:38,000 --> 00:27:42,560
hosting or hosting a roundtable at noon

00:27:40,940 --> 00:27:43,940
on cache tanks with Vinny got any

00:27:42,560 --> 00:27:46,730
questions or anything like that let's

00:27:43,940 --> 00:27:49,730
come ask yeah come see him at come see

00:27:46,730 --> 00:27:53,990
me at lunch thanks Bill yep

00:27:49,730 --> 00:27:55,550
yeah so up next also just as a quick

00:27:53,990 --> 00:27:58,000
note we are running a couple minutes

00:27:55,550 --> 00:28:00,110
behind in this room on purpose just

00:27:58,000 --> 00:28:01,640
because it takes a lot of time to get

00:28:00,110 --> 00:28:02,660
back and forth between the rooms and the

00:28:01,640 --> 00:28:04,430
building so if you're coming to this

00:28:02,660 --> 00:28:07,340
room you know we are starting a couple

00:28:04,430 --> 00:28:08,450
minutes late we do know but yeah up next

00:28:07,340 --> 00:28:11,180
we have somebody here to talk about

00:28:08,450 --> 00:28:14,840
another deep dive we're talking about

00:28:11,180 --> 00:28:16,910
Kotlin and how graph q on Kotlin can

00:28:14,840 --> 00:28:19,970
work together he's an architect at

00:28:16,910 --> 00:28:21,470
PayPal he codes in seven languages I'm

00:28:19,970 --> 00:28:22,880
assuming one of which is Kotlin and

00:28:21,470 --> 00:28:24,830
considering you're talking about it and

00:28:22,880 --> 00:28:26,630
he's been a software engineer for almost

00:28:24,830 --> 00:28:30,590
half of his life I think the exact

00:28:26,630 --> 00:28:33,320
number was 42% of his alive forty two

00:28:30,590 --> 00:28:34,760
point nine three very very precise but

00:28:33,320 --> 00:28:37,100
yeah forty two point nine three percent

00:28:34,760 --> 00:28:41,030
of his life he has been a software

00:28:37,100 --> 00:28:42,080
engineer yeah and I hope you enjoy his

00:28:41,030 --> 00:28:48,860
talk give a

00:28:42,080 --> 00:28:51,830
get run applause for Rohit huh

00:28:48,860 --> 00:28:54,590
happy Halloween folks everybody so see

00:28:51,830 --> 00:28:55,940
yesterday I couldn't find my wife's

00:28:54,590 --> 00:28:58,810
lipstick otherwise I would have that

00:28:55,940 --> 00:28:58,810

YouTube URL: https://www.youtube.com/watch?v=zhhxEr5mrWA


