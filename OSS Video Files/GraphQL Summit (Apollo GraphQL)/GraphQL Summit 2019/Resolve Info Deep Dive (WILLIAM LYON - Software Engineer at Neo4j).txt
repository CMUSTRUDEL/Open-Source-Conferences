Title: Resolve Info Deep Dive (WILLIAM LYON - Software Engineer at Neo4j)
Publication date: 2019-11-03
Playlist: GraphQL Summit 2019
Description: 
	Each GraphQL resolver is passed an object called the resolve info argument. This object contains information about the schema and query and can be used to construct database queries at runtime inside the resolver.
Captions: 
	00:00:03,020 --> 00:00:07,410
cool

00:00:04,470 --> 00:00:10,740
hi everyone so this talk is going to be

00:00:07,410 --> 00:00:13,950
a deep dive into the graph QL resolve

00:00:10,740 --> 00:00:15,420
info object and specifically in the

00:00:13,950 --> 00:00:18,270
context of how we can use it to help

00:00:15,420 --> 00:00:21,240
build efficient data fetching queries

00:00:18,270 --> 00:00:22,740
specifically from a database so my

00:00:21,240 --> 00:00:25,070
name's will I worked for a company

00:00:22,740 --> 00:00:28,590
called neo4j which is a graph database

00:00:25,070 --> 00:00:32,160
anyone using near 4j show hands a few

00:00:28,590 --> 00:00:34,290
folks okay cool so I work on a team at

00:00:32,160 --> 00:00:36,300
near 4j called the near 4j labs team so

00:00:34,290 --> 00:00:38,040
I don't work on the core database

00:00:36,300 --> 00:00:40,770
instead I work on tooling and

00:00:38,040 --> 00:00:43,469
integrations around the database one of

00:00:40,770 --> 00:00:44,460
which is our graph QL integration which

00:00:43,469 --> 00:00:47,340
is what I'm going to talk a little bit

00:00:44,460 --> 00:00:50,340
about today so here's a little bit about

00:00:47,340 --> 00:00:52,739
near 4j that this talk is not about near

00:00:50,340 --> 00:00:55,230
4j it's just sort of helpful to

00:00:52,739 --> 00:00:57,780
understand some of these concepts as we

00:00:55,230 --> 00:00:59,609
dig into some examples here so near 4j

00:00:57,780 --> 00:01:03,410
is a graph database so what that means

00:00:59,609 --> 00:01:05,339
is the data model unlike tables or

00:01:03,410 --> 00:01:08,610
documents the data model for the

00:01:05,339 --> 00:01:10,380
database is a graph specifically we call

00:01:08,610 --> 00:01:12,689
this the labeled property graph model

00:01:10,380 --> 00:01:16,740
and we use a query language called

00:01:12,689 --> 00:01:18,630
cipher to query the data in near for J

00:01:16,740 --> 00:01:21,689
you can think of cypher as kind of like

00:01:18,630 --> 00:01:25,470
sequel but for graphs here's here's an

00:01:21,689 --> 00:01:27,270
example if I can zoom in on that yeah so

00:01:25,470 --> 00:01:29,579
up in the upper right there there's an

00:01:27,270 --> 00:01:31,170
example of a cypher query and basically

00:01:29,579 --> 00:01:34,200
with cypher you're sort of drawing this

00:01:31,170 --> 00:01:36,720
ASCII art notation for expressing a

00:01:34,200 --> 00:01:39,210
graph traversal which we'll we'll see a

00:01:36,720 --> 00:01:40,619
little example this later so primarily

00:01:39,210 --> 00:01:42,380
just just think of near for J as a

00:01:40,619 --> 00:01:45,600
database where the data model is a graph

00:01:42,380 --> 00:01:47,520
and among some of the other interesting

00:01:45,600 --> 00:01:50,909
integrations and tooling we have for Nia

00:01:47,520 --> 00:01:53,850
for J is our graph QL integration and

00:01:50,909 --> 00:01:56,070
specifically near for J graph QL J s

00:01:53,850 --> 00:01:57,869
which is this JavaScript library the

00:01:56,070 --> 00:02:01,170
goal of which is to make it easy to

00:01:57,869 --> 00:02:03,180
build graphical api's on top of near for

00:02:01,170 --> 00:02:05,610
j so i want to make an important

00:02:03,180 --> 00:02:08,280
distinction here when we're talking

00:02:05,610 --> 00:02:10,319
about using graph QL with neo4j we're

00:02:08,280 --> 00:02:13,080
not talking about querying the database

00:02:10,319 --> 00:02:14,730
directly with graph QL and graph QL is

00:02:13,080 --> 00:02:16,739
is not really a database

00:02:14,730 --> 00:02:19,080
language it's it's a tool for building

00:02:16,739 --> 00:02:21,209
and querying api's so the goal of this

00:02:19,080 --> 00:02:23,400
library is to make it easy to build that

00:02:21,209 --> 00:02:26,519
layer between your client and the

00:02:23,400 --> 00:02:29,040
database and we do this by taking

00:02:26,519 --> 00:02:31,349
graphic you'll type definitions to drive

00:02:29,040 --> 00:02:34,549
the database model generating a

00:02:31,349 --> 00:02:37,980
graphical API auto-generating mutations

00:02:34,549 --> 00:02:39,120
inquiries and resolvers for for data

00:02:37,980 --> 00:02:41,370
fetching so you don't have to write

00:02:39,120 --> 00:02:43,410
boilerplate data fetching code and then

00:02:41,370 --> 00:02:45,510
also being sort of as extensive as

00:02:43,410 --> 00:02:49,019
possible so you can have custom logic in

00:02:45,510 --> 00:02:50,610
that layer as well so we we bundle this

00:02:49,019 --> 00:02:52,920
up in what we call grand stack which is

00:02:50,610 --> 00:02:54,870
graph QL react apollo near forge a

00:02:52,920 --> 00:02:56,160
database which is this sort of full

00:02:54,870 --> 00:02:58,410
stack framework just showing how all the

00:02:56,160 --> 00:03:00,150
pieces fit together so if you hear

00:02:58,410 --> 00:03:03,840
anyone talking about grand stack this is

00:03:00,150 --> 00:03:06,480
this is what they're talking about so to

00:03:03,840 --> 00:03:10,890
near-50 graph guild GS there's basically

00:03:06,480 --> 00:03:14,609
two main jobs that this library is doing

00:03:10,890 --> 00:03:17,670
one is schema augmentation so this is

00:03:14,609 --> 00:03:20,880
taking your type definitions or taking

00:03:17,670 --> 00:03:24,030
an already existing executable graph QL

00:03:20,880 --> 00:03:26,959
schema and adding the query and mutation

00:03:24,030 --> 00:03:30,930
types adding filtering ordering

00:03:26,959 --> 00:03:34,380
pagination input types for this also

00:03:30,930 --> 00:03:37,349
exposing the native database types like

00:03:34,380 --> 00:03:39,209
the the date time the spatial things so

00:03:37,349 --> 00:03:41,609
that's one piece and then the other

00:03:39,209 --> 00:03:45,000
piece is what we can call graph QL

00:03:41,609 --> 00:03:47,190
transpilation so this is basically when

00:03:45,000 --> 00:03:50,160
you issue a graphic you'll request our

00:03:47,190 --> 00:03:53,069
integration translates that graph QL

00:03:50,160 --> 00:03:55,590
query into a single cipher query so to a

00:03:53,069 --> 00:03:57,690
single database query so that you can

00:03:55,590 --> 00:04:00,239
resolve that entire graphical request in

00:03:57,690 --> 00:04:01,680
one round-trip to the database that

00:04:00,239 --> 00:04:04,799
query then gets optimized by the

00:04:01,680 --> 00:04:06,480
databases execution engine and this is

00:04:04,799 --> 00:04:08,250
good that this addresses what's known as

00:04:06,480 --> 00:04:11,010
the n plus one query problem if you've

00:04:08,250 --> 00:04:12,989
ever sort of had that problem with graph

00:04:11,010 --> 00:04:16,109
QL where you're sending multiple round

00:04:12,989 --> 00:04:19,440
trips to the database so this is the

00:04:16,109 --> 00:04:22,530
focus of this talk is on sort of how we

00:04:19,440 --> 00:04:26,340
use the graph kill resolve info object

00:04:22,530 --> 00:04:28,080
to make this graph QL transpilation

00:04:26,340 --> 00:04:31,360
happen

00:04:28,080 --> 00:04:34,090
so I'm not here to convince you that a

00:04:31,360 --> 00:04:36,370
graph database is the best back-end for

00:04:34,090 --> 00:04:38,260
a graphical API that that's kind of

00:04:36,370 --> 00:04:41,380
beside the point even though there are

00:04:38,260 --> 00:04:44,440
some pretty neat symbiotic benefits of

00:04:41,380 --> 00:04:46,419
having a graph model in your API and in

00:04:44,440 --> 00:04:48,669
the database but again that that's not

00:04:46,419 --> 00:04:51,190
what this talk is about instead what I

00:04:48,669 --> 00:04:54,370
want to do is convince you that this

00:04:51,190 --> 00:04:56,760
graph QL resolve info object is not

00:04:54,370 --> 00:04:58,900
scary this is something that is

00:04:56,760 --> 00:05:02,229
accessible there's tooling around this

00:04:58,900 --> 00:05:04,540
and we can use it to make more efficient

00:05:02,229 --> 00:05:08,530
resolvers and more efficient graph QL

00:05:04,540 --> 00:05:10,530
api's so that's my goal today so first

00:05:08,530 --> 00:05:15,280
let's take a look at kind of a

00:05:10,530 --> 00:05:18,220
motivating example here so I thought it

00:05:15,280 --> 00:05:22,090
would be fun to have a graph QL API for

00:05:18,220 --> 00:05:25,000
the graphic QL summit schedule so I

00:05:22,090 --> 00:05:27,460
scraped the summit schedule page and

00:05:25,000 --> 00:05:30,010
loaded that data into near 4j

00:05:27,460 --> 00:05:33,520
so we're modeling you can see this in in

00:05:30,010 --> 00:05:36,550
the middle here we're modeling sessions

00:05:33,520 --> 00:05:39,160
as nodes speakers are presenting session

00:05:36,550 --> 00:05:41,979
sessions are in a room we have the theme

00:05:39,160 --> 00:05:43,900
the track of the session who the

00:05:41,979 --> 00:05:46,750
presenter works for so this is all

00:05:43,900 --> 00:05:50,320
modeled in India for J as a graph and

00:05:46,750 --> 00:05:53,050
then we expose a graphical API on top of

00:05:50,320 --> 00:05:55,840
that and the code for this is you can

00:05:53,050 --> 00:05:57,550
find it at bitly slash summit graph it's

00:05:55,840 --> 00:05:59,169
also running online so you can you can

00:05:57,550 --> 00:06:02,169
query this now if you want to find what

00:05:59,169 --> 00:06:03,930
the next talk you should go to is summit

00:06:02,169 --> 00:06:06,610
graph grants Takeo

00:06:03,930 --> 00:06:11,289
and let me let me just sort of zoom in

00:06:06,610 --> 00:06:13,560
on this query so here let's just do this

00:06:11,289 --> 00:06:23,229
live why not

00:06:13,560 --> 00:06:25,660
so summit graph grant stock IO so here

00:06:23,229 --> 00:06:26,950
this is graph Gale playground how many

00:06:25,660 --> 00:06:28,780
people have used graph gala playgrounds

00:06:26,950 --> 00:06:32,620
this should be pretty pretty familiar to

00:06:28,780 --> 00:06:36,099
folks so if we look here and the docs we

00:06:32,620 --> 00:06:38,950
can explore we can explore the schema

00:06:36,099 --> 00:06:40,990
and we can see here we have entry points

00:06:38,950 --> 00:06:44,440
in our query type that matches

00:06:40,990 --> 00:06:46,180
the types or the the node labels as we

00:06:44,440 --> 00:06:50,259
call them in the property graph in our

00:06:46,180 --> 00:06:52,840
database data model so I have speakers

00:06:50,259 --> 00:06:54,069
companies rooms as my entry points and

00:06:52,840 --> 00:06:55,780
then I have all these mutations for

00:06:54,069 --> 00:06:58,419
adding data as well and I have a bunch

00:06:55,780 --> 00:07:00,819
of filtering and ordering and pagination

00:06:58,419 --> 00:07:03,759
things here so this query here I'm

00:07:00,819 --> 00:07:06,069
starting with sessions filtering for

00:07:03,759 --> 00:07:08,620
sessions where the abstract contains the

00:07:06,069 --> 00:07:10,210
word resolver grabbing some fields

00:07:08,620 --> 00:07:11,940
traversing the graph a little bit who

00:07:10,210 --> 00:07:15,009
who's the presenter who do they work for

00:07:11,940 --> 00:07:20,250
and then we have this recommended field

00:07:15,009 --> 00:07:29,280
here and we get an air that's not good

00:07:20,250 --> 00:07:31,240
let's try it locally okay cool so

00:07:29,280 --> 00:07:35,289
locally it works I don't know what's up

00:07:31,240 --> 00:07:38,139
with that hosted one but same query and

00:07:35,289 --> 00:07:39,639
we can see we get back some sessions and

00:07:38,139 --> 00:07:42,039
some of the fields we requested on those

00:07:39,639 --> 00:07:44,949
we get back some recommended sessions so

00:07:42,039 --> 00:07:47,560
this is the session where now graph QL

00:07:44,949 --> 00:07:49,000
resolve info deep dive if you like this

00:07:47,560 --> 00:07:51,520
one here's some other sessions you might

00:07:49,000 --> 00:07:54,400
be interested in so that's the the

00:07:51,520 --> 00:07:57,039
graphical API that we built that uses

00:07:54,400 --> 00:08:01,000
the integration that we're talking about

00:07:57,039 --> 00:08:05,250
today we can we can also query this in

00:08:01,000 --> 00:08:07,960
the database so here's a screen shot of

00:08:05,250 --> 00:08:10,509
near forge a browser this is like the

00:08:07,960 --> 00:08:12,759
the query workbench for near forge a so

00:08:10,509 --> 00:08:16,630
we write cipher queries at the top and

00:08:12,759 --> 00:08:19,389
then we get results visualized either as

00:08:16,630 --> 00:08:22,120
a graph here or as a table so this is

00:08:19,389 --> 00:08:24,340
sort of the equivalent cipher query for

00:08:22,120 --> 00:08:26,979
that graph QL query that we just wrote

00:08:24,340 --> 00:08:28,659
so find sessions where the abstract

00:08:26,979 --> 00:08:31,570
contains resolver then traverse the

00:08:28,659 --> 00:08:34,450
graph a bit to find okay who's who are

00:08:31,570 --> 00:08:37,060
the speakers who do they work for what's

00:08:34,450 --> 00:08:39,760
the theme what's the track and so on so

00:08:37,060 --> 00:08:43,000
you can see there's there's a fairly

00:08:39,760 --> 00:08:45,850
tight match there between our graph QL

00:08:43,000 --> 00:08:47,380
query and querying the database although

00:08:45,850 --> 00:08:50,920
it looks a bit different because it's

00:08:47,380 --> 00:08:54,130
it's a database query language so ok so

00:08:50,920 --> 00:08:57,840
how did we build that graphical API

00:08:54,130 --> 00:09:00,460
well here's here's the code and

00:08:57,840 --> 00:09:02,200
basically all this is on the left sorry

00:09:00,460 --> 00:09:03,700
this is this is kind of small but I just

00:09:02,200 --> 00:09:06,430
want to get all it on the screen there

00:09:03,700 --> 00:09:08,920
on the left is our graphic you'll type

00:09:06,430 --> 00:09:11,320
definitions so we're defining a speaker

00:09:08,920 --> 00:09:13,510
type a session type the session has

00:09:11,320 --> 00:09:17,160
title and abstract we're defining how

00:09:13,510 --> 00:09:19,480
these things are connected and and so on

00:09:17,160 --> 00:09:23,230
we'll come back to that that type

00:09:19,480 --> 00:09:25,390
definition file in a second here but on

00:09:23,230 --> 00:09:28,200
the right this is all of the graphical

00:09:25,390 --> 00:09:31,810
server code for this example so we're

00:09:28,200 --> 00:09:33,700
pulling in Apollo server how many people

00:09:31,810 --> 00:09:36,670
are using Apollo server just curious

00:09:33,700 --> 00:09:38,760
okay good amount we're pulling in the

00:09:36,670 --> 00:09:41,100
the JavaScript near forge a driver and

00:09:38,760 --> 00:09:42,940
from this near of geographical j/s

00:09:41,100 --> 00:09:45,250
library we're pulling in this make

00:09:42,940 --> 00:09:47,290
augmented schema function and we're

00:09:45,250 --> 00:09:49,000
passing that just our type definitions

00:09:47,290 --> 00:09:51,400
and then we we just create a driver

00:09:49,000 --> 00:09:53,800
instance and we spend a papalo server to

00:09:51,400 --> 00:09:55,720
serve our graphical api and there's

00:09:53,800 --> 00:09:57,910
there's something missing here if you've

00:09:55,720 --> 00:10:00,280
used Apollo server to build graphical

00:09:57,910 --> 00:10:02,740
API just before and that's our resolvers

00:10:00,280 --> 00:10:04,090
so we didn't write any resolvers here

00:10:02,740 --> 00:10:05,830
all we did was write our type

00:10:04,090 --> 00:10:09,250
definitions and this new york

00:10:05,830 --> 00:10:11,500
geographical j/s library is giving us an

00:10:09,250 --> 00:10:14,230
executable schema that's generating and

00:10:11,500 --> 00:10:16,240
attaching resolvers that's backing those

00:10:14,230 --> 00:10:18,790
queries and mutations that we saw in

00:10:16,240 --> 00:10:22,090
playground so there's some some magic

00:10:18,790 --> 00:10:24,880
going on there but by the code is here

00:10:22,090 --> 00:10:28,030
if you want to check that out but where

00:10:24,880 --> 00:10:29,860
is this magic coming from so the magic

00:10:28,030 --> 00:10:32,590
is largely powered by the graphical

00:10:29,860 --> 00:10:35,350
resolve info object so I want to talk

00:10:32,590 --> 00:10:39,660
about how we can use that to build more

00:10:35,350 --> 00:10:41,890
efficient graph QL api's so first of all

00:10:39,660 --> 00:10:44,590
let's take a step back and talk about

00:10:41,890 --> 00:10:46,420
resolvers so what is a resolver well

00:10:44,590 --> 00:10:48,250
neither of these things or resolver is

00:10:46,420 --> 00:10:50,500
that that's not very helpful these are

00:10:48,250 --> 00:10:52,360
our type definitions again and then our

00:10:50,500 --> 00:10:54,970
graphical query just to remind ourselves

00:10:52,360 --> 00:10:57,040
that we're querying for sessions

00:10:54,970 --> 00:10:59,350
traversing that that data graph a little

00:10:57,040 --> 00:11:03,000
bit to find speakers what room it's in

00:10:59,350 --> 00:11:05,800
recommended sessions and so on and so

00:11:03,000 --> 00:11:07,250
resolvers those are the functions that

00:11:05,800 --> 00:11:09,410
define how to

00:11:07,250 --> 00:11:12,590
that data from the data layer right if

00:11:09,410 --> 00:11:15,140
it's calling out to another API if it's

00:11:12,590 --> 00:11:17,720
calling a database if it's reading from

00:11:15,140 --> 00:11:20,000
a flat file what whatever it is the

00:11:17,720 --> 00:11:23,960
resolver is the function that has the

00:11:20,000 --> 00:11:28,390
logic for fetching that data and in the

00:11:23,960 --> 00:11:33,170
resolver were passed four arguments so

00:11:28,390 --> 00:11:36,440
the parent in the the route entry point

00:11:33,170 --> 00:11:38,240
this is this is always null but then

00:11:36,440 --> 00:11:39,830
because resolvers are called in a nested

00:11:38,240 --> 00:11:41,930
fashion basically whatever we've

00:11:39,830 --> 00:11:45,080
resolved for the parents is passed in

00:11:41,930 --> 00:11:46,790
their any field arguments are passed in

00:11:45,080 --> 00:11:49,040
so many arguments for the field that

00:11:46,790 --> 00:11:52,100
we're currently resolving are passed in

00:11:49,040 --> 00:11:54,920
that argument every resolver is also

00:11:52,100 --> 00:11:56,960
passed a context object this is where we

00:11:54,920 --> 00:12:01,610
do things like stash database

00:11:56,960 --> 00:12:04,250
connections or API instances for our ORM

00:12:01,610 --> 00:12:06,110
maybe things like that and then the

00:12:04,250 --> 00:12:11,750
fourth argument is our friend the

00:12:06,110 --> 00:12:16,790
graphical resolve info object so here's

00:12:11,750 --> 00:12:20,330
using kind of a fake database thing what

00:12:16,790 --> 00:12:22,520
our resolvers might look like for this

00:12:20,330 --> 00:12:25,940
graph QL summit schedule graph that I

00:12:22,520 --> 00:12:27,830
showed so we have a session query

00:12:25,940 --> 00:12:30,740
resolver that's that's our route it's

00:12:27,830 --> 00:12:32,920
doing some look up to find sessions by

00:12:30,740 --> 00:12:35,900
some search term that it's grabbing from

00:12:32,920 --> 00:12:37,460
the params objects that's our search

00:12:35,900 --> 00:12:39,470
string we typed in resolver whatever

00:12:37,460 --> 00:12:41,210
we're searching for and then in a nested

00:12:39,470 --> 00:12:43,880
fashion the other resolvers are called

00:12:41,210 --> 00:12:46,940
so for session we want to know the room

00:12:43,880 --> 00:12:48,860
so our fake DB has some way to figure

00:12:46,940 --> 00:12:50,810
out the room given a session ID that we

00:12:48,860 --> 00:12:52,700
grabbed out of out of the parent object

00:12:50,810 --> 00:12:55,400
and we do that for the theme and

00:12:52,700 --> 00:12:57,110
recommend it also so this is this is a

00:12:55,400 --> 00:12:59,780
great example of that in +1 query

00:12:57,110 --> 00:13:02,660
problem where we're we're not going back

00:12:59,780 --> 00:13:05,390
to the database multiple times to fetch

00:13:02,660 --> 00:13:07,220
different pieces of data that's that's

00:13:05,390 --> 00:13:08,870
not good there's workarounds for this

00:13:07,220 --> 00:13:11,180
right so the data loader patter and that

00:13:08,870 --> 00:13:13,040
can give us some batching but what if we

00:13:11,180 --> 00:13:15,410
could just generate one database query

00:13:13,040 --> 00:13:16,280
at the root level to resolve everything

00:13:15,410 --> 00:13:18,350
we need

00:13:16,280 --> 00:13:20,970
also just pointing out here that this

00:13:18,350 --> 00:13:22,410
info the graphical resolve info object

00:13:20,970 --> 00:13:25,829
has passed to each one of these

00:13:22,410 --> 00:13:28,589
resolvers okay so what is what is this

00:13:25,829 --> 00:13:33,680
graph QL resolve info thing that we've

00:13:28,589 --> 00:13:36,930
been talking around well there are nine

00:13:33,680 --> 00:13:39,240
ten maybe ten fields on it

00:13:36,930 --> 00:13:40,980
this slide is I'm sure very hard to read

00:13:39,240 --> 00:13:44,670
but I want to go through this just

00:13:40,980 --> 00:13:48,120
really quickly so we have the name of

00:13:44,670 --> 00:13:49,829
the current field being resolved and

00:13:48,120 --> 00:13:53,490
remember this is passed into every

00:13:49,829 --> 00:13:56,339
resolver right so the name of every of

00:13:53,490 --> 00:13:58,889
the field being resolved we have an

00:13:56,339 --> 00:14:01,170
array representation of the remaining

00:13:58,889 --> 00:14:02,939
selection set so the selection set those

00:14:01,170 --> 00:14:06,660
are the fields in my query that I've

00:14:02,939 --> 00:14:08,759
said I want to be returned we have the

00:14:06,660 --> 00:14:11,399
graph QL type of the field that's

00:14:08,759 --> 00:14:14,100
currently being resolved and also of the

00:14:11,399 --> 00:14:15,870
parents we have the path so what are

00:14:14,100 --> 00:14:19,589
what are the fields that we've traversed

00:14:15,870 --> 00:14:22,139
so far to get to this point for the

00:14:19,589 --> 00:14:24,540
field that we're resolving we have a

00:14:22,139 --> 00:14:29,009
representation of the entire executable

00:14:24,540 --> 00:14:30,839
of graph QL schema we have a map of any

00:14:29,009 --> 00:14:33,569
any of the query fragments that we're

00:14:30,839 --> 00:14:35,160
using we have the route value which is

00:14:33,569 --> 00:14:37,740
whatever we chose to pass in to the

00:14:35,160 --> 00:14:41,279
graphical execution function we have an

00:14:37,740 --> 00:14:44,309
ast of of the full query and then we

00:14:41,279 --> 00:14:46,649
have any graph QL variables that we've

00:14:44,309 --> 00:14:50,339
passed in so all of these things are

00:14:46,649 --> 00:14:52,199
available to us inside our resolvers so

00:14:50,339 --> 00:14:56,089
what are some ways that we can use those

00:14:52,199 --> 00:15:00,120
to to make efficient graphical api's

00:14:56,089 --> 00:15:01,829
well there's three things in our

00:15:00,120 --> 00:15:03,569
integration anyway that we found very

00:15:01,829 --> 00:15:06,809
useful I think some of these concepts

00:15:03,569 --> 00:15:09,629
can be generalized as well so the first

00:15:06,809 --> 00:15:11,970
is finding the nested selection set of a

00:15:09,629 --> 00:15:14,279
query so at the root

00:15:11,970 --> 00:15:16,980
looking ahead essentially what are all

00:15:14,279 --> 00:15:20,670
of the fields in a nested fashion that

00:15:16,980 --> 00:15:22,949
are requested by this graph QL query why

00:15:20,670 --> 00:15:25,439
is that useful well if I can find that

00:15:22,949 --> 00:15:27,990
then I can generate a single database

00:15:25,439 --> 00:15:31,230
query rather it's ciphered sequel

00:15:27,990 --> 00:15:32,790
whatever from the root level to fetch

00:15:31,230 --> 00:15:33,660
all of the data from my database that I

00:15:32,790 --> 00:15:36,920
need to

00:15:33,660 --> 00:15:40,200
resolve this single graph QL query and

00:15:36,920 --> 00:15:42,330
then we also use it to implement graph

00:15:40,200 --> 00:15:45,780
QL schema directives specifically one

00:15:42,330 --> 00:15:47,160
called cipher and relation and this this

00:15:45,780 --> 00:15:48,780
might seem a little odd to you that we

00:15:47,160 --> 00:15:51,930
do it this way but we'll we'll talk

00:15:48,780 --> 00:15:54,390
about that in a second so first of all

00:15:51,930 --> 00:15:56,730
let's take a look at at our query again

00:15:54,390 --> 00:15:58,070
so we're looking for sessions we're

00:15:56,730 --> 00:16:01,580
filtering by some search string

00:15:58,070 --> 00:16:06,270
traversing out from those sessions a bit

00:16:01,580 --> 00:16:10,380
so how can we find the nested selection

00:16:06,270 --> 00:16:12,300
set using the resolve info object so I'm

00:16:10,380 --> 00:16:16,890
not going to show you the code that we

00:16:12,300 --> 00:16:18,360
use to do this because it has a few few

00:16:16,890 --> 00:16:19,050
considerations that are not relevant

00:16:18,360 --> 00:16:22,220
here

00:16:19,050 --> 00:16:25,350
but fortunately bin G from graph file

00:16:22,220 --> 00:16:29,250
has us covered with the graph QL parse

00:16:25,350 --> 00:16:32,550
resolve info library so basically what

00:16:29,250 --> 00:16:38,340
what this does is it can take a resolve

00:16:32,550 --> 00:16:41,640
info object and give us the parsed

00:16:38,340 --> 00:16:45,350
version which includes the nested

00:16:41,640 --> 00:16:48,810
selection set so I can pass this library

00:16:45,350 --> 00:16:50,190
my resolved info in the resolver and I

00:16:48,810 --> 00:16:52,200
get back all of the fields being

00:16:50,190 --> 00:16:55,110
requested and and some metadata about

00:16:52,200 --> 00:16:57,180
the fields as well so if I have that

00:16:55,110 --> 00:16:59,280
that means that I can then iterate over

00:16:57,180 --> 00:17:01,920
that and generate a single database

00:16:59,280 --> 00:17:04,740
query again whether it's cipher sequel

00:17:01,920 --> 00:17:08,640
or or whatever here's what that looks

00:17:04,740 --> 00:17:11,640
like in cipher and this this looks very

00:17:08,640 --> 00:17:14,240
similar to the database query that we

00:17:11,640 --> 00:17:17,010
wrote by hand when we were searching for

00:17:14,240 --> 00:17:19,290
for sessions and and traversing out and

00:17:17,010 --> 00:17:22,980
returning a graph I just mentioned this

00:17:19,290 --> 00:17:24,000
is not what an actual generated query

00:17:22,980 --> 00:17:25,080
looks like they look a bit different

00:17:24,000 --> 00:17:26,310
because they're they're machine

00:17:25,080 --> 00:17:28,260
generated this is sort of the

00:17:26,310 --> 00:17:29,850
handwritten version of that but but what

00:17:28,260 --> 00:17:31,260
I want to point out here is in the

00:17:29,850 --> 00:17:33,330
return but previously we were just

00:17:31,260 --> 00:17:35,760
returning the graph object we matched on

00:17:33,330 --> 00:17:38,940
here we're doing sort of a map

00:17:35,760 --> 00:17:40,890
projection to return only the fields

00:17:38,940 --> 00:17:44,100
that we've requested in the graph QL

00:17:40,890 --> 00:17:46,860
query and we get back this this map

00:17:44,100 --> 00:17:49,620
essentially which we can just return

00:17:46,860 --> 00:17:53,250
from our roots level resolver and that

00:17:49,620 --> 00:17:55,679
handles the entire graph QL query in one

00:17:53,250 --> 00:17:57,480
one database query which is quite nice

00:17:55,679 --> 00:17:59,420
quite efficient we don't have to worry

00:17:57,480 --> 00:18:02,760
about this n plus one problem

00:17:59,420 --> 00:18:05,940
so that's finding the selection set and

00:18:02,760 --> 00:18:07,620
generating a single database query the

00:18:05,940 --> 00:18:12,270
next piece that we want to think about

00:18:07,620 --> 00:18:15,000
is custom logic so kind of what we've

00:18:12,270 --> 00:18:18,179
talked about so far are these basic crud

00:18:15,000 --> 00:18:19,850
operations right so querying data in the

00:18:18,179 --> 00:18:23,460
database creating data in the database

00:18:19,850 --> 00:18:25,350
but what about more sort of data

00:18:23,460 --> 00:18:27,480
intensive more custom things and

00:18:25,350 --> 00:18:30,270
specifically what about our recommended

00:18:27,480 --> 00:18:33,299
field remember we in that example we saw

00:18:30,270 --> 00:18:36,450
that okay once we're at a session can we

00:18:33,299 --> 00:18:39,840
find similar sessions that a user might

00:18:36,450 --> 00:18:42,900
be interested in so there are two schema

00:18:39,840 --> 00:18:46,049
directives that we introduced in our

00:18:42,900 --> 00:18:49,740
near 48 graphic you ljs library one is

00:18:46,049 --> 00:18:52,710
the relation directive so we use this to

00:18:49,740 --> 00:18:55,590
basically keep track of metadata about

00:18:52,710 --> 00:18:57,210
the property graph model that doesn't

00:18:55,590 --> 00:19:00,480
really have a great place to fit in the

00:18:57,210 --> 00:19:04,200
type definitions so the property graph

00:19:00,480 --> 00:19:07,200
model every relationship has a type and

00:19:04,200 --> 00:19:08,880
a direction so we use this relation

00:19:07,200 --> 00:19:10,290
directive to sort of encode that

00:19:08,880 --> 00:19:11,549
information what do you want to call

00:19:10,290 --> 00:19:14,510
this relationship and what direction

00:19:11,549 --> 00:19:18,000
should it go in and then the other

00:19:14,510 --> 00:19:19,980
directive that we add is a cypher

00:19:18,000 --> 00:19:22,860
directive so what this allows us to do

00:19:19,980 --> 00:19:24,960
is essentially annotate our type

00:19:22,860 --> 00:19:27,600
definitions with a cypher query to

00:19:24,960 --> 00:19:30,929
define a computed field so here we're

00:19:27,600 --> 00:19:33,179
defining the recommended field which

00:19:30,929 --> 00:19:34,980
then maps to the cypher query which this

00:19:33,179 --> 00:19:38,429
is essentially just saying traverse out

00:19:34,980 --> 00:19:41,730
from this session find sessions that

00:19:38,429 --> 00:19:44,270
have overlapping tracks or themes and

00:19:41,730 --> 00:19:46,260
give me an aggregation account on those

00:19:44,270 --> 00:19:49,260
those are probably going to be more

00:19:46,260 --> 00:19:51,660
relevant for for my user so it allows us

00:19:49,260 --> 00:19:53,820
to define this sort of custom logic in

00:19:51,660 --> 00:19:55,200
computed fields but again we still don't

00:19:53,820 --> 00:19:57,419
have to write resolvers we just sort of

00:19:55,200 --> 00:19:59,650
annotates are our type definitions and

00:19:57,419 --> 00:20:02,560
that query runs as

00:19:59,650 --> 00:20:04,870
a sub-query within our one generated

00:20:02,560 --> 00:20:07,170
database query so we're still making

00:20:04,870 --> 00:20:10,200
just one database query one round trip

00:20:07,170 --> 00:20:17,350
but we just inject that as a sub query

00:20:10,200 --> 00:20:19,450
from the graph QL schema and here now is

00:20:17,350 --> 00:20:22,330
what that looks like now in our response

00:20:19,450 --> 00:20:25,240
we have this recommended field which has

00:20:22,330 --> 00:20:26,350
the title of the talks that if you're

00:20:25,240 --> 00:20:30,730
interested in this session you might be

00:20:26,350 --> 00:20:32,410
interested in in the next one as well so

00:20:30,730 --> 00:20:34,540
that may seem like kind of a weird way

00:20:32,410 --> 00:20:36,340
to implement schema directives if you've

00:20:34,540 --> 00:20:38,740
done that before

00:20:36,340 --> 00:20:41,530
and it's probably not the way you want

00:20:38,740 --> 00:20:43,240
to implement schema directives unless it

00:20:41,530 --> 00:20:45,100
directly impacts the way that you're

00:20:43,240 --> 00:20:49,960
sort of generating your your data

00:20:45,100 --> 00:20:52,030
fetching logic instead there are some

00:20:49,960 --> 00:20:55,240
features in graph QL tools from Apollo

00:20:52,030 --> 00:20:58,120
that allow you to implement schema

00:20:55,240 --> 00:21:01,210
directives we use this also for our

00:20:58,120 --> 00:21:03,880
authorization schema directives so you

00:21:01,210 --> 00:21:08,370
can also add you know protected fields

00:21:03,880 --> 00:21:12,520
based on on roles and scopes as well

00:21:08,370 --> 00:21:17,050
cool so that was kind of a dive into

00:21:12,520 --> 00:21:20,170
this resolved info object hopefully I

00:21:17,050 --> 00:21:21,700
convinced you that it's not super scary

00:21:20,170 --> 00:21:25,920
it's something that you can actually

00:21:21,700 --> 00:21:29,310
make you love for making efficient

00:21:25,920 --> 00:21:31,360
graphical api's and specifically

00:21:29,310 --> 00:21:33,600
reminder these are the things we talked

00:21:31,360 --> 00:21:36,070
about fighting the nested selection sets

00:21:33,600 --> 00:21:39,160
generating a single database query from

00:21:36,070 --> 00:21:42,520
that and implementing schema directives

00:21:39,160 --> 00:21:45,820
as well so I want to leave you with just

00:21:42,520 --> 00:21:48,750
a few resources for learning more

00:21:45,820 --> 00:21:52,030
information about this kind of stuff

00:21:48,750 --> 00:21:55,720
first one there is a blog post that

00:21:52,030 --> 00:21:58,230
Prisma wrote a while ago demystifying

00:21:55,720 --> 00:22:02,740
the info argument in graphical resolvers

00:21:58,230 --> 00:22:04,420
that walks through what's in there in a

00:22:02,740 --> 00:22:06,970
bit more detail than what I did today

00:22:04,420 --> 00:22:09,730
has some examples so that's that's a

00:22:06,970 --> 00:22:11,950
good resource also Eric Berry gave a

00:22:09,730 --> 00:22:14,140
great talk a couple years ago graphical

00:22:11,950 --> 00:22:17,350
somewhat graphical under the hood

00:22:14,140 --> 00:22:19,420
that talks about sort of how this this

00:22:17,350 --> 00:22:22,450
execution stuff works in graphic well

00:22:19,420 --> 00:22:24,820
that's that's a good resource if you're

00:22:22,450 --> 00:22:26,470
interested in learning more about the

00:22:24,820 --> 00:22:29,170
near forge a graphical integrations we

00:22:26,470 --> 00:22:30,310
just had a online conference and I think

00:22:29,170 --> 00:22:32,410
we had eight talks that were

00:22:30,310 --> 00:22:34,920
specifically about our graphical

00:22:32,410 --> 00:22:37,030
integration including some from

00:22:34,920 --> 00:22:38,430
customers like Under Armour talking

00:22:37,030 --> 00:22:41,440
about how they use it to build things

00:22:38,430 --> 00:22:42,310
others for more technical deep dives and

00:22:41,440 --> 00:22:45,160
into how it works

00:22:42,310 --> 00:22:47,170
so check that out if that's interesting

00:22:45,160 --> 00:22:48,880
as Jake mentioned I I'm working on a

00:22:47,170 --> 00:22:51,490
book called full stack graph QL

00:22:48,880 --> 00:22:53,170
published by Manning I'm sure my

00:22:51,490 --> 00:22:56,290
publisher would be very upset if I

00:22:53,170 --> 00:22:58,960
failed to mention that today it's out

00:22:56,290 --> 00:23:01,990
now in early release so I think like the

00:22:58,960 --> 00:23:06,430
first third of the book is out now

00:23:01,990 --> 00:23:08,140
there's a discount code CTW gql 19 and

00:23:06,430 --> 00:23:09,970
that's good not that's good actually for

00:23:08,140 --> 00:23:13,000
any Manning products not just for this

00:23:09,970 --> 00:23:15,400
book so feel free to check that out

00:23:13,000 --> 00:23:17,860
there's some other resources pointing in

00:23:15,400 --> 00:23:20,260
here as well that I'll just leave sort

00:23:17,860 --> 00:23:22,060
of for your interest as you get the

00:23:20,260 --> 00:23:25,860
slides but the last thing I want to

00:23:22,060 --> 00:23:29,020
mention is at lunch today I'm hosting a

00:23:25,860 --> 00:23:33,010
topic table using graph QL with a graph

00:23:29,020 --> 00:23:35,050
database so that's at 12:30 if you're

00:23:33,010 --> 00:23:38,320
interested in chatting more come to that

00:23:35,050 --> 00:23:40,900
or come to our booth we have a booth

00:23:38,320 --> 00:23:43,660
downstairs just look for a spooky

00:23:40,900 --> 00:23:45,790
skeleton and some spider webs and you'll

00:23:43,660 --> 00:23:48,040
find us and some of my colleagues are

00:23:45,790 --> 00:23:49,660
over there as well that can give you

00:23:48,040 --> 00:23:51,190
some more information and chat with you

00:23:49,660 --> 00:23:54,670
about this stuff so the slides are

00:23:51,190 --> 00:23:56,020
available bitly slash resolve info and

00:23:54,670 --> 00:23:58,780
I'll post them on Twitter too if you

00:23:56,020 --> 00:24:00,850
want to to look for that other than that

00:23:58,780 --> 00:24:05,230
that's all I have

00:24:00,850 --> 00:24:05,230

YouTube URL: https://www.youtube.com/watch?v=eqbyUK4v_jA


