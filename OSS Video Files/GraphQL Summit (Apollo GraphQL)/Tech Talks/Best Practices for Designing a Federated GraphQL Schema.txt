Title: Best Practices for Designing a Federated GraphQL Schema
Publication date: 2021-06-16
Playlist: Tech Talks
Description: 
	In this talk by Mandi Wise, we learn how to build a GraphQL schema that prioritizes developer ergonomics and how to use observability to make informed choices about evolving it safely. 

Resources:
Create an Apollo Studio account - https://utm.guru/udsAj
Check out the Apollo docs - https://utm.guru/udsAl
Review the Build a Schema doc - https://utm.guru/udsAg
Check out the Federated Schema Design Best Practices chapter in the GraphQL at Enterprise Scale E-book - https://utm.guru/udsAo
Captions: 
	00:00:00,160 --> 00:00:07,200
okay i think we're gonna get going now

00:00:03,439 --> 00:00:09,120
um so i'd like to start by saying

00:00:07,200 --> 00:00:11,280
hello to everyone thank you so much for

00:00:09,120 --> 00:00:13,040
joining us for this webinar today

00:00:11,280 --> 00:00:14,880
my name is mandy wise and i'm a

00:00:13,040 --> 00:00:16,560
solutions architect at apollo

00:00:14,880 --> 00:00:18,400
and that means that i spend a good

00:00:16,560 --> 00:00:20,480
portion of my time helping our

00:00:18,400 --> 00:00:22,560
enterprise customers migrate to and get

00:00:20,480 --> 00:00:24,240
up and running with apollo federation

00:00:22,560 --> 00:00:25,920
and a good portion of that work has to

00:00:24,240 --> 00:00:28,000
do with schema design

00:00:25,920 --> 00:00:29,119
so today i'm really excited to have the

00:00:28,000 --> 00:00:31,119
chance to talk to you

00:00:29,119 --> 00:00:32,719
about some schema design best practices

00:00:31,119 --> 00:00:35,760
to keep in mind when you're adopting a

00:00:32,719 --> 00:00:35,760
federated data graph

00:00:37,760 --> 00:00:43,120
now before we jump into the content we

00:00:40,480 --> 00:00:45,520
have a few housekeeping items

00:00:43,120 --> 00:00:46,640
so the first is about the q a portion of

00:00:45,520 --> 00:00:48,320
today's session

00:00:46,640 --> 00:00:49,840
uh if you have questions along the way

00:00:48,320 --> 00:00:52,160
then you can drop them in the q

00:00:49,840 --> 00:00:53,920
a box in zoom and we'll save some time

00:00:52,160 --> 00:00:55,760
at the end to answer as many of the

00:00:53,920 --> 00:00:58,000
questions as we can

00:00:55,760 --> 00:01:00,079
and in terms of what questions would be

00:00:58,000 --> 00:01:02,320
best suited for this webinar format

00:01:00,079 --> 00:01:04,400
it would be best to stick to general

00:01:02,320 --> 00:01:06,080
questions about federated schema design

00:01:04,400 --> 00:01:07,680
and especially in relation to the best

00:01:06,080 --> 00:01:08,479
practices that we're going to talk about

00:01:07,680 --> 00:01:10,479
today

00:01:08,479 --> 00:01:12,080
rather than super specific questions

00:01:10,479 --> 00:01:15,280
about your schema

00:01:12,080 --> 00:01:18,000
or your specific architecture or any

00:01:15,280 --> 00:01:20,240
really specific debugging questions so

00:01:18,000 --> 00:01:22,400
if you need to drop a code snippet into

00:01:20,240 --> 00:01:24,080
the q a to ask your question or provide

00:01:22,400 --> 00:01:26,080
extensive architectural details for

00:01:24,080 --> 00:01:28,320
context then i would encourage you to

00:01:26,080 --> 00:01:29,439
instead post those questions on apollo's

00:01:28,320 --> 00:01:32,000
new forum

00:01:29,439 --> 00:01:33,360
at community.apollographql.com because

00:01:32,000 --> 00:01:33,759
that's probably going to be a much

00:01:33,360 --> 00:01:35,200
better

00:01:33,759 --> 00:01:37,280
medium for having those kinds of

00:01:35,200 --> 00:01:39,840
in-depth discussions

00:01:37,280 --> 00:01:41,520
the second house keeping item is that

00:01:39,840 --> 00:01:42,640
we'd really appreciate your feedback

00:01:41,520 --> 00:01:44,880
after the session

00:01:42,640 --> 00:01:46,479
and we'd like to know what topics you're

00:01:44,880 --> 00:01:46,880
interested in for future sessions as

00:01:46,479 --> 00:01:48,960
well

00:01:46,880 --> 00:01:52,079
so please take a few moments to fill out

00:01:48,960 --> 00:01:54,399
the post post event survey if you can

00:01:52,079 --> 00:01:56,399
and lastly we have a product update

00:01:54,399 --> 00:01:59,040
event coming up on june 24th

00:01:56,399 --> 00:02:00,320
so if you'd like to know more about all

00:01:59,040 --> 00:02:01,600
of the exciting things in store for

00:02:00,320 --> 00:02:02,960
apollo federation

00:02:01,600 --> 00:02:04,640
uh then you can use the link that we

00:02:02,960 --> 00:02:07,360
drop into the chat to sign up for that

00:02:04,640 --> 00:02:07,360
event as well

00:02:07,600 --> 00:02:11,039
okay onward to schema design best

00:02:10,239 --> 00:02:13,040
practices

00:02:11,039 --> 00:02:14,640
uh the best practices that we'll discuss

00:02:13,040 --> 00:02:17,280
today have been organized into

00:02:14,640 --> 00:02:18,720
several high-level categories and some

00:02:17,280 --> 00:02:20,959
of the best practices

00:02:18,720 --> 00:02:22,879
are federation specific and some are

00:02:20,959 --> 00:02:24,879
applicable to both federated and

00:02:22,879 --> 00:02:26,959
non-federated graphql apis and i think

00:02:24,879 --> 00:02:37,840
it's always helpful to have a refresher

00:02:26,959 --> 00:02:37,840
on these

00:02:42,879 --> 00:02:45,920
and they're certainly open for

00:02:49,200 --> 00:02:54,879
adoption of apollo federation for our

00:02:51,840 --> 00:02:54,879
enterprise customers

00:02:55,519 --> 00:03:00,560
okay so for our first best practice

00:02:58,560 --> 00:03:02,080
uh the first step toward designing a

00:03:00,560 --> 00:03:04,560
federated graphql api

00:03:02,080 --> 00:03:05,200
is to start thinking in entities and

00:03:04,560 --> 00:03:07,360
before

00:03:05,200 --> 00:03:09,280
exploring this best practice in depth

00:03:07,360 --> 00:03:09,680
i'd like to do some quick level setting

00:03:09,280 --> 00:03:11,680
around

00:03:09,680 --> 00:03:14,080
how apollo federation works at a high

00:03:11,680 --> 00:03:16,239
level and to do that i'd love to know

00:03:14,080 --> 00:03:18,959
more about who here today is currently

00:03:16,239 --> 00:03:21,760
using or considering federation so let's

00:03:18,959 --> 00:03:21,760
do a quick poll

00:03:24,239 --> 00:03:28,799
so we've got some options here for uh

00:03:27,519 --> 00:03:29,920
whether you're using federation with

00:03:28,799 --> 00:03:34,159
managed federation

00:03:29,920 --> 00:03:34,159
without managed federation or no

00:03:35,280 --> 00:03:47,840
i'll give everyone a few more seconds to

00:03:37,760 --> 00:03:47,840
answer the poll

00:03:56,560 --> 00:04:01,840
we should have results shortly

00:04:03,680 --> 00:04:10,000
okay so the results are in and we

00:04:06,879 --> 00:04:10,560
have 32 percent of the participants

00:04:10,000 --> 00:04:14,080
today

00:04:10,560 --> 00:04:16,639
are using managed federation 16

00:04:14,080 --> 00:04:17,519
uh are not and it looks like we have 52

00:04:16,639 --> 00:04:20,560
percent

00:04:17,519 --> 00:04:22,720
who are new to federation okay cool that

00:04:20,560 --> 00:04:24,880
is definitely useful context for me to

00:04:22,720 --> 00:04:28,639
have as we move forward

00:04:24,880 --> 00:04:29,360
and uh so the slides that follow here

00:04:28,639 --> 00:04:30,639
are going to be really helpful

00:04:29,360 --> 00:04:32,400
especially for those who are newer to

00:04:30,639 --> 00:04:34,080
federation so if you're newer to how

00:04:32,400 --> 00:04:36,240
apollo federation works

00:04:34,080 --> 00:04:37,680
let's do a quick overview of some key

00:04:36,240 --> 00:04:39,759
concepts

00:04:37,680 --> 00:04:41,280
so federation allows teams to embrace

00:04:39,759 --> 00:04:42,560
separation of concerns

00:04:41,280 --> 00:04:43,919
so that they can work on different

00:04:42,560 --> 00:04:45,199
products and features that are powered

00:04:43,919 --> 00:04:46,720
by a single data graph

00:04:45,199 --> 00:04:48,479
and they can do this work without

00:04:46,720 --> 00:04:50,479
stepping on each other's toes

00:04:48,479 --> 00:04:52,479
and splitting subgraphs by concern is

00:04:50,479 --> 00:04:54,080
key here because it differs from other

00:04:52,479 --> 00:04:55,680
approaches to designing distributed

00:04:54,080 --> 00:04:57,360
graphql architectures where

00:04:55,680 --> 00:04:59,360
the boundaries between your different

00:04:57,360 --> 00:05:01,440
subgraphs are often

00:04:59,360 --> 00:05:02,639
delineated explicitly by types in the

00:05:01,440 --> 00:05:04,960
schema

00:05:02,639 --> 00:05:06,400
and on top of that an apollo gateway

00:05:04,960 --> 00:05:08,160
takes a declarative approach to

00:05:06,400 --> 00:05:10,720
composing your subgraphs together

00:05:08,160 --> 00:05:12,000
and it handles query planning for you so

00:05:10,720 --> 00:05:13,360
you don't have to deal with the

00:05:12,000 --> 00:05:16,560
imperative pain points of other

00:05:13,360 --> 00:05:19,520
approaches to graphql consolidation

00:05:16,560 --> 00:05:21,199
so that means that back-end teams can

00:05:19,520 --> 00:05:22,000
independently manage their portions of

00:05:21,199 --> 00:05:24,240
the data graph

00:05:22,000 --> 00:05:26,400
while still exposing a single graphql

00:05:24,240 --> 00:05:28,880
endpoint to client developers

00:05:26,400 --> 00:05:30,160
so with this kind of distributed graphql

00:05:28,880 --> 00:05:31,919
architecture in mind

00:05:30,160 --> 00:05:34,240
one of the most important concepts in

00:05:31,919 --> 00:05:36,720
federation is that of an entity

00:05:34,240 --> 00:05:38,400
and in apollo federation an entity is an

00:05:36,720 --> 00:05:40,880
object or an interface type that you

00:05:38,400 --> 00:05:42,400
define canonically in one subgraph

00:05:40,880 --> 00:05:44,160
and then you reference and extend in

00:05:42,400 --> 00:05:46,240
other subgraphs so

00:05:44,160 --> 00:05:47,280
by serving as extension points between

00:05:46,240 --> 00:05:49,120
your subgraphs

00:05:47,280 --> 00:05:50,800
these entities end up acting as the

00:05:49,120 --> 00:05:51,360
building blocks of your federated data

00:05:50,800 --> 00:05:53,199
graph

00:05:51,360 --> 00:05:54,800
and are ultimately what allow you to

00:05:53,199 --> 00:05:56,560
separate your subgraphs by concern

00:05:54,800 --> 00:05:59,440
instead of type

00:05:56,560 --> 00:06:00,400
so how do we make an entity well

00:05:59,440 --> 00:06:02,720
designating

00:06:00,400 --> 00:06:03,520
any object type as an entity is as easy

00:06:02,720 --> 00:06:05,280
as adding the

00:06:03,520 --> 00:06:06,880
key directive to its definition in the

00:06:05,280 --> 00:06:08,880
subgraph schema

00:06:06,880 --> 00:06:11,680
and the add key directive that we see

00:06:08,880 --> 00:06:13,919
here defines the entity's primary key

00:06:11,680 --> 00:06:16,080
which consists of one or more of the

00:06:13,919 --> 00:06:16,880
types fields that can uniquely identify

00:06:16,080 --> 00:06:19,680
the object

00:06:16,880 --> 00:06:20,080
that it represents and in this example

00:06:19,680 --> 00:06:21,600
here

00:06:20,080 --> 00:06:24,080
we can see that the product entity's

00:06:21,600 --> 00:06:26,880
primary key would be its upc field

00:06:24,080 --> 00:06:27,840
so in other words setting the upc field

00:06:26,880 --> 00:06:29,600
as the key

00:06:27,840 --> 00:06:31,440
means that other subgraphs that want to

00:06:29,600 --> 00:06:34,000
use this entity will need to know at

00:06:31,440 --> 00:06:36,400
least that value for any product

00:06:34,000 --> 00:06:37,520
so when used in other subgraphs you can

00:06:36,400 --> 00:06:39,440
think of the upc

00:06:37,520 --> 00:06:41,520
as acting like a foreign key so the

00:06:39,440 --> 00:06:43,680
apollo gateways query planner can use

00:06:41,520 --> 00:06:45,360
the entity's key to identify a given

00:06:43,680 --> 00:06:47,919
instance of the type

00:06:45,360 --> 00:06:50,240
and ideally the keys that we define are

00:06:47,919 --> 00:06:51,039
in fact values that uniquely identify a

00:06:50,240 --> 00:06:53,039
resource

00:06:51,039 --> 00:06:54,639
so in other words we want to avoid

00:06:53,039 --> 00:06:55,520
scenarios where they are used to

00:06:54,639 --> 00:06:57,840
arbitrarily

00:06:55,520 --> 00:07:02,000
pass around dynamic field data through

00:06:57,840 --> 00:07:04,240
query execution between your subgraphs

00:07:02,000 --> 00:07:05,840
so once you define an entity in a

00:07:04,240 --> 00:07:07,919
subgraph that's where things start to

00:07:05,840 --> 00:07:10,319
get really interesting with federation

00:07:07,919 --> 00:07:11,360
so after you define an entity in one

00:07:10,319 --> 00:07:13,280
subgraph

00:07:11,360 --> 00:07:14,639
other subgraphs can then reference that

00:07:13,280 --> 00:07:16,720
entity so

00:07:14,639 --> 00:07:18,720
in practice that means that once the

00:07:16,720 --> 00:07:19,360
product subgraph defines the product

00:07:18,720 --> 00:07:21,840
entity

00:07:19,360 --> 00:07:24,000
a review subgraph can then add a product

00:07:21,840 --> 00:07:27,120
field with a return type of product

00:07:24,000 --> 00:07:29,440
to its review type as we see here and

00:07:27,120 --> 00:07:30,639
because the product entity is defined in

00:07:29,440 --> 00:07:32,639
another subgraph

00:07:30,639 --> 00:07:34,560
the review subgraph needs to define a

00:07:32,639 --> 00:07:35,520
stub of that type to make its own schema

00:07:34,560 --> 00:07:37,599
valid

00:07:35,520 --> 00:07:39,440
and the stub includes just enough

00:07:37,599 --> 00:07:41,199
information for the service to know how

00:07:39,440 --> 00:07:43,440
to interact with a product

00:07:41,199 --> 00:07:44,560
and in our case again it's that upc key

00:07:43,440 --> 00:07:47,680
field

00:07:44,560 --> 00:07:49,599
and note that the upc of ubc field must

00:07:47,680 --> 00:07:51,599
be annotated with federation's ad

00:07:49,599 --> 00:07:54,319
external directive here to indicate that

00:07:51,599 --> 00:07:56,479
the field originates in another service

00:07:54,319 --> 00:07:58,319
and also note that because we want to

00:07:56,479 --> 00:08:00,000
use spec compliant graphql we're going

00:07:58,319 --> 00:08:02,319
to use the extend keyword here

00:08:00,000 --> 00:08:04,080
to indicate that the product type is an

00:08:02,319 --> 00:08:06,879
object type that's already defined in

00:08:04,080 --> 00:08:06,879
another subgraph

00:08:07,360 --> 00:08:11,440
and we aren't limited to simply

00:08:09,599 --> 00:08:13,199
referencing the product entity in the

00:08:11,440 --> 00:08:16,240
review subgraph either

00:08:13,199 --> 00:08:17,919
so we can also extend an entity with

00:08:16,240 --> 00:08:20,000
additional fields that are defined by

00:08:17,919 --> 00:08:22,720
the review subgraph itself

00:08:20,000 --> 00:08:25,120
and when a service extends an entity the

00:08:22,720 --> 00:08:27,680
entity's originating subgraph is not

00:08:25,120 --> 00:08:29,360
aware of the added fields

00:08:27,680 --> 00:08:31,360
only the extending subgraph and the

00:08:29,360 --> 00:08:33,519
gateway will know about these fields

00:08:31,360 --> 00:08:35,599
so let's say that we want to add a

00:08:33,519 --> 00:08:37,279
reviews field to the product entity that

00:08:35,599 --> 00:08:38,560
will hold a list of reviews for the

00:08:37,279 --> 00:08:40,560
product

00:08:38,560 --> 00:08:42,399
the product entity as we've seen

00:08:40,560 --> 00:08:44,399
originates in the product subgraph but

00:08:42,399 --> 00:08:45,760
it makes much more sense for the review

00:08:44,399 --> 00:08:47,839
service to resolve the

00:08:45,760 --> 00:08:50,560
reviews field for a product because it

00:08:47,839 --> 00:08:53,600
actually has direct access to this data

00:08:50,560 --> 00:08:54,480
so to handle this case we can extend the

00:08:53,600 --> 00:08:56,720
product

00:08:54,480 --> 00:08:57,600
entity in the review subgraph as we see

00:08:56,720 --> 00:09:00,080
here

00:08:57,600 --> 00:09:01,279
and for the new reviews field note that

00:09:00,080 --> 00:09:03,120
we don't include an

00:09:01,279 --> 00:09:05,279
external directive on it because this

00:09:03,120 --> 00:09:07,120
field actually does originate interview

00:09:05,279 --> 00:09:09,040
subgraph in this case

00:09:07,120 --> 00:09:11,680
so through this process of entity

00:09:09,040 --> 00:09:13,279
definition and referencing and extension

00:09:11,680 --> 00:09:15,200
we can see one of apollo federation's

00:09:13,279 --> 00:09:16,800
superpowers and how it enables us to

00:09:15,200 --> 00:09:19,200
split a graphql schema

00:09:16,800 --> 00:09:20,160
based on that more logical separation of

00:09:19,200 --> 00:09:22,399
concern

00:09:20,160 --> 00:09:24,160
and it gives developers an intuitive way

00:09:22,399 --> 00:09:26,720
to interact types that are defined in

00:09:24,160 --> 00:09:29,279
other subgraphs

00:09:26,720 --> 00:09:30,480
so when you're embarking on a new

00:09:29,279 --> 00:09:32,320
federation project

00:09:30,480 --> 00:09:34,480
or you're adding new subgraphs to an

00:09:32,320 --> 00:09:36,560
existing federated data graph

00:09:34,480 --> 00:09:38,399
it's important to evaluate what types

00:09:36,560 --> 00:09:40,240
exist in your graph that suggest that

00:09:38,399 --> 00:09:41,200
they will naturally play this entity

00:09:40,240 --> 00:09:44,000
role

00:09:41,200 --> 00:09:44,480
and entities also help us make decisions

00:09:44,000 --> 00:09:46,800
about

00:09:44,480 --> 00:09:47,760
where subgraph boundaries may be drawn

00:09:46,800 --> 00:09:49,920
as well

00:09:47,760 --> 00:09:51,360
and if your spidey senses are up now and

00:09:49,920 --> 00:09:53,200
you find yourself wondering

00:09:51,360 --> 00:09:54,959
how do decoupled teams reference

00:09:53,200 --> 00:09:55,839
entities that are owned in other teams

00:09:54,959 --> 00:09:58,000
subgraphs and

00:09:55,839 --> 00:10:00,160
in a way that doesn't break down into a

00:09:58,000 --> 00:10:00,880
completely chaotic free-for-all breaking

00:10:00,160 --> 00:10:02,800
changes

00:10:00,880 --> 00:10:05,279
then i have an answer for that and that

00:10:02,800 --> 00:10:06,720
answer is to use a schema registry such

00:10:05,279 --> 00:10:08,079
as apollo studio

00:10:06,720 --> 00:10:11,120
that will help you sleep at night

00:10:08,079 --> 00:10:13,040
knowing that one team's proposed changes

00:10:11,120 --> 00:10:15,200
uh to the data graph won't break

00:10:13,040 --> 00:10:16,800
composition for everyone else

00:10:15,200 --> 00:10:18,640
so in other words it's going to put some

00:10:16,800 --> 00:10:20,800
guardrails in place around

00:10:18,640 --> 00:10:20,800
how

00:10:23,120 --> 00:10:25,519
data

00:10:26,240 --> 00:10:31,680
right across your teams now before we

00:10:29,839 --> 00:10:33,200
jump into the remaining best practices

00:10:31,680 --> 00:10:34,560
i'd love to know a little bit more about

00:10:33,200 --> 00:10:35,519
what's motivated your interest in

00:10:34,560 --> 00:10:38,880
federation

00:10:35,519 --> 00:10:38,880
so let's do one more poll

00:10:40,000 --> 00:10:43,360
okay so the question is what motivated

00:10:42,640 --> 00:10:46,160
your interest

00:10:43,360 --> 00:10:46,880
in adopting apollo federation and uh you

00:10:46,160 --> 00:10:48,240
may be

00:10:46,880 --> 00:10:50,079
coming from a background of having a

00:10:48,240 --> 00:10:51,440
monolithic graphql api that's

00:10:50,079 --> 00:10:54,959
challenging to iterate

00:10:51,440 --> 00:10:56,880
uh you may be replacing a bff strategy

00:10:54,959 --> 00:10:58,560
uh you may be consolidating multiple

00:10:56,880 --> 00:11:00,320
existing graphql apis

00:10:58,560 --> 00:11:03,040
into one perhaps you're starting

00:11:00,320 --> 00:11:04,320
greenfield with a federated graphql api

00:11:03,040 --> 00:11:06,640
in front of your micro service

00:11:04,320 --> 00:11:08,720
architecture or something else

00:11:06,640 --> 00:11:10,640
or you're not quite ready to adopt

00:11:08,720 --> 00:11:13,120
apollo federation yet

00:11:10,640 --> 00:11:14,000
so we'll just give a few more moments

00:11:13,120 --> 00:11:15,920
for people to

00:11:14,000 --> 00:11:29,839
respond and then we can take a quick

00:11:15,920 --> 00:11:29,839
peek at the results

00:11:40,880 --> 00:11:45,360
those results should be coming in

00:11:42,399 --> 00:11:45,360
shortly

00:11:46,079 --> 00:11:51,519
okay and they're in so it looks like

00:11:49,040 --> 00:11:54,160
we've got a pretty good split here

00:11:51,519 --> 00:11:55,120
people coming from monoliths some from

00:11:54,160 --> 00:11:57,680
bffs

00:11:55,120 --> 00:11:58,240
uh definitely a few people uh coming

00:11:57,680 --> 00:12:01,440
from

00:11:58,240 --> 00:12:03,200
having multiple graphql apis and uh

00:12:01,440 --> 00:12:04,880
wanting to to tame that beast with some

00:12:03,200 --> 00:12:06,320
graphql consolidation driven by

00:12:04,880 --> 00:12:08,959
federation

00:12:06,320 --> 00:12:10,000
um and also quite a few people here who

00:12:08,959 --> 00:12:13,040
are starting greenfield

00:12:10,000 --> 00:12:14,800
as well so that's that's great this is a

00:12:13,040 --> 00:12:16,160
really good distribution and very much

00:12:14,800 --> 00:12:17,360
reflective of

00:12:16,160 --> 00:12:20,240
what we see with our enterprise

00:12:17,360 --> 00:12:20,240
customers as well

00:12:21,360 --> 00:12:25,200
okay so whatever your reason for

00:12:24,480 --> 00:12:27,839
considering

00:12:25,200 --> 00:12:29,200
apollo federation and feeling the need

00:12:27,839 --> 00:12:30,800
that it's time to do some graphical

00:12:29,200 --> 00:12:32,959
consolidation

00:12:30,800 --> 00:12:34,399
when companies decide to consolidate

00:12:32,959 --> 00:12:37,600
their data graph

00:12:34,399 --> 00:12:40,399
uh from what i've seen this move is

00:12:37,600 --> 00:12:42,480
often motivated in part by a desire to

00:12:40,399 --> 00:12:44,560
simplify how clients access the data

00:12:42,480 --> 00:12:46,399
they need from a graphql api

00:12:44,560 --> 00:12:47,760
that's backed by a distributed service

00:12:46,399 --> 00:12:50,079
architecture

00:12:47,760 --> 00:12:52,480
so they may be coming from a world where

00:12:50,079 --> 00:12:54,480
they had back-ends for front-ends or

00:12:52,480 --> 00:12:57,200
multiple graphql apis in use as we've

00:12:54,480 --> 00:12:59,279
seen and they want to consolidate and

00:12:57,200 --> 00:13:00,639
streamline their apis behind a single

00:12:59,279 --> 00:13:03,040
endpoint for clients

00:13:00,639 --> 00:13:04,480
but without introducing the bottleneck

00:13:03,040 --> 00:13:06,880
or constraints of a traditional

00:13:04,480 --> 00:13:10,000
monolithic graphql api

00:13:06,880 --> 00:13:12,160
so with that client focus when designing

00:13:10,000 --> 00:13:14,240
and evolving schemas for federated data

00:13:12,160 --> 00:13:16,320
graphs we want to make sure that

00:13:14,240 --> 00:13:17,920
we're keeping in mind the kinds of

00:13:16,320 --> 00:13:19,360
product experiences we're trying to

00:13:17,920 --> 00:13:21,200
drive via the graph

00:13:19,360 --> 00:13:22,480
as well as how to best support client

00:13:21,200 --> 00:13:25,279
developers who will bring those

00:13:22,480 --> 00:13:27,680
experiences to life for end users

00:13:25,279 --> 00:13:29,360
so when migrating to apollo federation

00:13:27,680 --> 00:13:31,360
it's often the case that there are

00:13:29,360 --> 00:13:34,000
more than one client applications

00:13:31,360 --> 00:13:35,360
consuming any non-federated graphql apis

00:13:34,000 --> 00:13:36,720
that the company

00:13:35,360 --> 00:13:38,880
has already developed and put into

00:13:36,720 --> 00:13:41,040
production so

00:13:38,880 --> 00:13:42,880
if you already have measures in place to

00:13:41,040 --> 00:13:44,320
collaborate with client teams on schema

00:13:42,880 --> 00:13:47,760
evolution then that's

00:13:44,320 --> 00:13:49,920
amazing but if not have no fear this

00:13:47,760 --> 00:13:51,360
would be a really great time to adopt

00:13:49,920 --> 00:13:53,440
that practice

00:13:51,360 --> 00:13:55,440
so in general client teams should be

00:13:53,440 --> 00:13:58,240
consulted early in the schema design

00:13:55,440 --> 00:13:58,639
process as well as on an ongoing basis

00:13:58,240 --> 00:14:00,480
and

00:13:58,639 --> 00:14:02,320
client teams should really just drive

00:14:00,480 --> 00:14:04,160
these discussions wherever possible

00:14:02,320 --> 00:14:06,160
so rather than simply asking for

00:14:04,160 --> 00:14:08,560
feedback from client developers

00:14:06,160 --> 00:14:10,160
ask them to explain what data they need

00:14:08,560 --> 00:14:10,880
to render a particular view in their

00:14:10,160 --> 00:14:12,639
application

00:14:10,880 --> 00:14:14,959
and what the ideal shape of that data

00:14:12,639 --> 00:14:16,000
would be and it's then the job of the

00:14:14,959 --> 00:14:18,560
schema designers and

00:14:16,000 --> 00:14:19,839
owners to aggregate this feedback across

00:14:18,560 --> 00:14:21,600
the different client teams

00:14:19,839 --> 00:14:23,279
and reconcile it against the broader

00:14:21,600 --> 00:14:24,399
experiences you want to drive via your

00:14:23,279 --> 00:14:26,079
data graph

00:14:24,399 --> 00:14:27,760
as well as of course what's technically

00:14:26,079 --> 00:14:28,880
possible in relation to your backing

00:14:27,760 --> 00:14:31,760
data sources

00:14:28,880 --> 00:14:34,240
and the schema governance measures that

00:14:31,760 --> 00:14:36,720
your company has in place

00:14:34,240 --> 00:14:38,320
and as you're working on your schema be

00:14:36,720 --> 00:14:40,160
sure to take advantage of the fact that

00:14:38,320 --> 00:14:42,399
federation allows you to

00:14:40,160 --> 00:14:44,560
to design your schema in a way that

00:14:42,399 --> 00:14:46,399
expresses the natural relationships

00:14:44,560 --> 00:14:48,959
between the types in your graph

00:14:46,399 --> 00:14:51,519
so for example without federation you

00:14:48,959 --> 00:14:54,320
may have seen foreign key like fields

00:14:51,519 --> 00:14:56,639
as being a requirement for a subgraph

00:14:54,320 --> 00:14:58,399
schema to join the nodes of a data graph

00:14:56,639 --> 00:14:59,760
when those subgraphs are split by type

00:14:58,399 --> 00:15:02,240
alone

00:14:59,760 --> 00:15:04,320
but with federation as we've seen our

00:15:02,240 --> 00:15:06,240
view subgraph can represent a truer

00:15:04,320 --> 00:15:08,320
subset of the complete data graph

00:15:06,240 --> 00:15:12,079
by using those entity references and

00:15:08,320 --> 00:15:15,839
extensions that we explored

00:15:12,079 --> 00:15:17,440
now on to our third best practice um

00:15:15,839 --> 00:15:19,839
this is very much related to the

00:15:17,440 --> 00:15:20,800
practice of demand-oriented schema

00:15:19,839 --> 00:15:22,639
design

00:15:20,800 --> 00:15:24,240
um and there's a really strong

00:15:22,639 --> 00:15:26,079
imperative uh

00:15:24,240 --> 00:15:28,639
as a schema design best practice with

00:15:26,079 --> 00:15:29,839
graphql to prioritize the expressiveness

00:15:28,639 --> 00:15:32,720
of your schema

00:15:29,839 --> 00:15:33,839
and by this i mean that a good graphql

00:15:32,720 --> 00:15:35,600
schema will convey

00:15:33,839 --> 00:15:37,199
meaning about the underlying nodes in

00:15:35,600 --> 00:15:39,440
your data graph as well as the

00:15:37,199 --> 00:15:41,839
relationships between those nodes

00:15:39,440 --> 00:15:42,880
and there are many dimensions to schema

00:15:41,839 --> 00:15:44,560
expressiveness and

00:15:42,880 --> 00:15:46,000
i would say in many ways it underpins

00:15:44,560 --> 00:15:47,360
most of the best practices that we're

00:15:46,000 --> 00:15:49,680
talking about here

00:15:47,360 --> 00:15:51,839
but i'm going to focus on some very

00:15:49,680 --> 00:15:52,720
specific tactical concerns in relation

00:15:51,839 --> 00:15:56,240
to how your

00:15:52,720 --> 00:15:58,240
how you write your schema so

00:15:56,240 --> 00:16:00,000
being consistent about how you name

00:15:58,240 --> 00:16:02,000
things may go without saying

00:16:00,000 --> 00:16:03,759
but it's even more important when

00:16:02,000 --> 00:16:05,600
composing schemas from multiple

00:16:03,759 --> 00:16:07,600
subgraphs into a single federated

00:16:05,600 --> 00:16:10,800
graphql api

00:16:07,600 --> 00:16:12,240
so for example mismatches between field

00:16:10,800 --> 00:16:12,959
naming approaches from different

00:16:12,240 --> 00:16:14,880
subgraphs

00:16:12,959 --> 00:16:17,040
won't provide a very consistent or

00:16:14,880 --> 00:16:19,600
intuitive experience for clients

00:16:17,040 --> 00:16:21,680
and the outset of a migration project to

00:16:19,600 --> 00:16:22,000
a federated data graph is a good time to

00:16:21,680 --> 00:16:24,000
take

00:16:22,000 --> 00:16:25,199
stock of what naming conventions are

00:16:24,000 --> 00:16:27,120
currently used

00:16:25,199 --> 00:16:29,199
in your existing graphql schemas within

00:16:27,120 --> 00:16:30,480
your company and then determine what

00:16:29,199 --> 00:16:32,720
conventions

00:16:30,480 --> 00:16:33,600
will become standardized and then

00:16:32,720 --> 00:16:35,839
onboard

00:16:33,600 --> 00:16:38,880
subgraph teams to those conventions and

00:16:35,839 --> 00:16:41,360
plan for field deprecations as needed

00:16:38,880 --> 00:16:43,440
and good schema governance practices are

00:16:41,360 --> 00:16:44,399
really key here to maintaining schema

00:16:43,440 --> 00:16:46,240
expressiveness

00:16:44,399 --> 00:16:48,320
as more and more teams are onboarded to

00:16:46,240 --> 00:16:51,040
the graph and more and more teams begin

00:16:48,320 --> 00:16:53,680
consuming the graph

00:16:51,040 --> 00:16:55,600
okay so as we've discussed a graphql

00:16:53,680 --> 00:16:56,399
schema should be designed around product

00:16:55,600 --> 00:16:59,120
requirements

00:16:56,399 --> 00:17:00,480
and ideally the fields that are added to

00:16:59,120 --> 00:17:02,160
added to your schema

00:17:00,480 --> 00:17:03,519
to support those requirements will be

00:17:02,160 --> 00:17:05,679
single purpose

00:17:03,519 --> 00:17:07,600
so in practice this means having more

00:17:05,679 --> 00:17:08,160
specific finer grained mutations and

00:17:07,600 --> 00:17:10,400
queries

00:17:08,160 --> 00:17:11,600
and of course also having guidelines and

00:17:10,400 --> 00:17:13,919
trainings in place

00:17:11,600 --> 00:17:15,600
for api contributors to understand how

00:17:13,919 --> 00:17:17,600
to design these kinds of fields for

00:17:15,600 --> 00:17:20,319
their sub graphs

00:17:17,600 --> 00:17:22,480
so as an example this query would create

00:17:20,319 --> 00:17:22,880
ambiguity for clients about what would

00:17:22,480 --> 00:17:25,280
happen

00:17:22,880 --> 00:17:26,880
if neither the id or the username

00:17:25,280 --> 00:17:28,880
arguments were submitted

00:17:26,880 --> 00:17:31,120
with this query because if we want this

00:17:28,880 --> 00:17:33,600
query to be general purpose

00:17:31,120 --> 00:17:35,440
to fetch a user by either argument then

00:17:33,600 --> 00:17:39,200
we can't make any of those arguments

00:17:35,440 --> 00:17:41,280
non-null if we want it to remain generic

00:17:39,200 --> 00:17:43,280
so having two different queries with

00:17:41,280 --> 00:17:45,120
null non-nullable arguments would

00:17:43,280 --> 00:17:46,720
provide a more predictable experience

00:17:45,120 --> 00:17:48,880
for clients

00:17:46,720 --> 00:17:50,480
and this fine grained approach also

00:17:48,880 --> 00:17:52,960
applies to mutations

00:17:50,480 --> 00:17:54,880
so rather than having a single update a

00:17:52,960 --> 00:17:56,480
camp mutation to rule them all

00:17:54,880 --> 00:17:57,919
we can instead implement more

00:17:56,480 --> 00:17:59,679
purpose-built mutations

00:17:57,919 --> 00:18:01,600
when these values are updated

00:17:59,679 --> 00:18:04,320
independently by clients

00:18:01,600 --> 00:18:05,919
and one caveat here is that if any of

00:18:04,320 --> 00:18:08,400
the values needed to be updated

00:18:05,919 --> 00:18:10,480
simultaneously or not at all

00:18:08,400 --> 00:18:12,160
then it would make more sense to bundle

00:18:10,480 --> 00:18:13,039
these updates into a coarser grain

00:18:12,160 --> 00:18:15,760
mutation

00:18:13,039 --> 00:18:17,760
but apart from this opting for finer

00:18:15,760 --> 00:18:18,640
grain mutations helps us avoid the same

00:18:17,760 --> 00:18:21,280
pitfalls as

00:18:18,640 --> 00:18:23,280
finer grained queries do and it saves

00:18:21,280 --> 00:18:24,960
you from having to do extra validation

00:18:23,280 --> 00:18:27,919
work at runtime to determine

00:18:24,960 --> 00:18:29,760
uh that the submitted arguments in the

00:18:27,919 --> 00:18:33,440
operation will actually lead to a

00:18:29,760 --> 00:18:33,440
logical outcome for the mutation

00:18:34,080 --> 00:18:39,120
okay so as my last tactical point around

00:18:37,039 --> 00:18:40,960
schema expressiveness

00:18:39,120 --> 00:18:42,559
this is something that i often see as a

00:18:40,960 --> 00:18:44,880
backlog item but

00:18:42,559 --> 00:18:46,559
prioritizing it can go a long way in

00:18:44,880 --> 00:18:48,400
empowering client developers to

00:18:46,559 --> 00:18:50,080
understand the intentions

00:18:48,400 --> 00:18:52,720
and the full potential of the fields

00:18:50,080 --> 00:18:53,760
added to a schema and this is to add

00:18:52,720 --> 00:18:56,320
documentation

00:18:53,760 --> 00:18:57,360
to your various schema components and

00:18:56,320 --> 00:18:59,520
the imperative

00:18:57,360 --> 00:19:01,120
to better express the intentions of your

00:18:59,520 --> 00:19:03,360
schema through documentation

00:19:01,120 --> 00:19:04,240
is codified in the graphql specification

00:19:03,360 --> 00:19:06,400
itself

00:19:04,240 --> 00:19:08,320
and the spec states that documentation

00:19:06,400 --> 00:19:09,120
is a first-class feature of graphql-type

00:19:08,320 --> 00:19:11,120
systems

00:19:09,120 --> 00:19:12,880
and it goes further to say that all

00:19:11,120 --> 00:19:14,000
types fields and arguments and other

00:19:12,880 --> 00:19:16,799
definitions that

00:19:14,000 --> 00:19:18,559
can be described should have a

00:19:16,799 --> 00:19:21,440
description included with them

00:19:18,559 --> 00:19:22,240
unless they're entirely self-descriptive

00:19:21,440 --> 00:19:24,240
so

00:19:22,240 --> 00:19:25,919
just as with naming conventions i would

00:19:24,240 --> 00:19:27,919
say it's important to establish

00:19:25,919 --> 00:19:28,559
standards for documentation across a

00:19:27,919 --> 00:19:30,880
federated

00:19:28,559 --> 00:19:33,679
federated data graph from its inception

00:19:30,880 --> 00:19:35,840
to ensure consistency for api consumers

00:19:33,679 --> 00:19:37,679
and again having governance measures in

00:19:35,840 --> 00:19:41,600
place to support these documentation

00:19:37,679 --> 00:19:41,600
standards is also a really good idea

00:19:42,240 --> 00:19:46,799
okay so for our fourth best practice

00:19:44,960 --> 00:19:47,760
we're going to move on to the topic of

00:19:46,799 --> 00:19:49,919
nullability

00:19:47,760 --> 00:19:52,000
and this is an interesting one because

00:19:49,919 --> 00:19:53,440
depending on what parts of a schema

00:19:52,000 --> 00:19:55,360
we're talking about

00:19:53,440 --> 00:19:56,880
non-null fields can help us guard

00:19:55,360 --> 00:19:57,919
against breaking changes in some

00:19:56,880 --> 00:20:00,080
instances

00:19:57,919 --> 00:20:01,919
but can also increase the likelihood of

00:20:00,080 --> 00:20:04,480
breaking changes in the future for

00:20:01,919 --> 00:20:05,520
other cases and as always with

00:20:04,480 --> 00:20:06,799
federation

00:20:05,520 --> 00:20:08,880
we want to think about what the

00:20:06,799 --> 00:20:10,480
ramifications of these nullability

00:20:08,880 --> 00:20:13,360
related decisions

00:20:10,480 --> 00:20:14,799
are because they can become slightly

00:20:13,360 --> 00:20:18,080
more complex when we're thinking about

00:20:14,799 --> 00:20:18,080
them on a distributed scale

00:20:18,720 --> 00:20:22,159
so it's a fact that nominal fields uh

00:20:21,679 --> 00:20:24,559
can make

00:20:22,159 --> 00:20:26,240
results more predictable for clients but

00:20:24,559 --> 00:20:26,799
they have the trade-off that including

00:20:26,240 --> 00:20:29,760
them

00:20:26,799 --> 00:20:30,799
um whether it's whether it's a field or

00:20:29,760 --> 00:20:33,280
an argument

00:20:30,799 --> 00:20:35,120
uh as not all in your schema can make

00:20:33,280 --> 00:20:36,240
that schema harder to evolve in the

00:20:35,120 --> 00:20:38,880
future

00:20:36,240 --> 00:20:39,440
so as an example if a nominal email

00:20:38,880 --> 00:20:41,440
field

00:20:39,440 --> 00:20:43,039
on a user type is converted to a

00:20:41,440 --> 00:20:45,440
nullable field

00:20:43,039 --> 00:20:46,480
will the clients that use that field be

00:20:45,440 --> 00:20:49,760
prepared to

00:20:46,480 --> 00:20:51,280
handle that potentially null value uh if

00:20:49,760 --> 00:20:53,120
once that update has been made to the

00:20:51,280 --> 00:20:55,679
schema and

00:20:53,120 --> 00:20:57,679
conversely if the schema changes in a

00:20:55,679 --> 00:20:59,760
way that a client is suddenly expected

00:20:57,679 --> 00:21:01,120
to send a previously nullable argument

00:20:59,760 --> 00:21:02,960
with an operation

00:21:01,120 --> 00:21:04,480
then this may also result in a breaking

00:21:02,960 --> 00:21:06,080
change for them if they're not prepared

00:21:04,480 --> 00:21:08,559
to do so

00:21:06,080 --> 00:21:10,480
so we can see how it's important to make

00:21:08,559 --> 00:21:12,480
informed decisions about nullability

00:21:10,480 --> 00:21:13,440
when initially designing a subgraph

00:21:12,480 --> 00:21:15,440
schema

00:21:13,440 --> 00:21:16,960
but you're inevitably going to be faced

00:21:15,440 --> 00:21:18,720
with making a breaking change of this

00:21:16,960 --> 00:21:21,200
nature as your schema evolves

00:21:18,720 --> 00:21:22,159
but that's okay no need to despair

00:21:21,200 --> 00:21:24,320
because

00:21:22,159 --> 00:21:26,080
uh when that happens your graphql

00:21:24,320 --> 00:21:27,039
observability tools such as apollo

00:21:26,080 --> 00:21:28,960
studio

00:21:27,039 --> 00:21:30,080
give you insight into how those fields

00:21:28,960 --> 00:21:32,159
are currently

00:21:30,080 --> 00:21:33,360
used in different operations and across

00:21:32,159 --> 00:21:35,280
different clients

00:21:33,360 --> 00:21:38,000
so you can make these updates in a safe

00:21:35,280 --> 00:21:40,640
and informed way

00:21:38,000 --> 00:21:41,039
and another important consideration is

00:21:40,640 --> 00:21:42,960
how

00:21:41,039 --> 00:21:44,159
non-null arguments and input fields on

00:21:42,960 --> 00:21:46,000
mutations can

00:21:44,159 --> 00:21:47,440
help you avoid breaking change scenarios

00:21:46,000 --> 00:21:49,200
in the future too

00:21:47,440 --> 00:21:50,880
however this is typically going to

00:21:49,200 --> 00:21:53,760
require that you design fire

00:21:50,880 --> 00:21:55,679
finer grain mutations and avoid using

00:21:53,760 --> 00:21:58,799
those everything but the kitchen stink

00:21:55,679 --> 00:22:00,159
sinks style inputs as arguments

00:21:58,799 --> 00:22:02,000
that are filled with all kinds of

00:22:00,159 --> 00:22:05,280
different nullable fields to account for

00:22:02,000 --> 00:22:07,200
all possible use cases but as a bonus

00:22:05,280 --> 00:22:08,799
when you use those finer grain mutations

00:22:07,200 --> 00:22:10,400
as we've discussed

00:22:08,799 --> 00:22:12,240
this helps make your schema more

00:22:10,400 --> 00:22:15,440
expressive and more predictable and

00:22:12,240 --> 00:22:15,440
understandable for clients

00:22:15,919 --> 00:22:20,720
now when adding fields to a schema that

00:22:19,200 --> 00:22:22,559
are resolved with data from

00:22:20,720 --> 00:22:24,480
third-party data sources the

00:22:22,559 --> 00:22:25,520
conventional advice is to make these

00:22:24,480 --> 00:22:27,440
fields nullable

00:22:25,520 --> 00:22:30,000
given the potential for a request to

00:22:27,440 --> 00:22:31,919
fail or for the data source to make

00:22:30,000 --> 00:22:34,320
breaking changes without warning

00:22:31,919 --> 00:22:35,600
and a federated data graph adds an

00:22:34,320 --> 00:22:37,120
interesting dimension to these

00:22:35,600 --> 00:22:39,919
considerations given that

00:22:37,120 --> 00:22:41,520
many of the entities in the graph may be

00:22:39,919 --> 00:22:44,080
backed by data sources

00:22:41,520 --> 00:22:46,400
that are not immediately adjacent to a

00:22:44,080 --> 00:22:47,840
subgraph service or within their direct

00:22:46,400 --> 00:22:50,400
sphere of control

00:22:47,840 --> 00:22:52,159
so the matter of whether you should make

00:22:50,400 --> 00:22:54,159
referenced entities nullable in a

00:22:52,159 --> 00:22:56,240
subgraph schema will depend on your

00:22:54,159 --> 00:22:58,480
company's existing architecture

00:22:56,240 --> 00:23:00,240
as well as its internal slas and it's

00:22:58,480 --> 00:23:03,440
likely going to need to be addressed on

00:23:00,240 --> 00:23:03,440
a case-by-case basis

00:23:03,840 --> 00:23:08,000
okay so on to best practice number five

00:23:06,720 --> 00:23:11,679
which is about

00:23:08,000 --> 00:23:14,080
abstract types and uh the graphql spec

00:23:11,679 --> 00:23:15,760
currently offers two different abstract

00:23:14,080 --> 00:23:18,640
types in its type system

00:23:15,760 --> 00:23:20,720
and those are interfaces and unions and

00:23:18,640 --> 00:23:22,159
interfaces and unions are really

00:23:20,720 --> 00:23:24,000
powerful tools to express

00:23:22,159 --> 00:23:25,200
relationships between the types in a

00:23:24,000 --> 00:23:26,880
schema

00:23:25,200 --> 00:23:29,600
but when you're adding these types to a

00:23:26,880 --> 00:23:31,360
schema and especially a federated schema

00:23:29,600 --> 00:23:33,280
it's important to do so with a

00:23:31,360 --> 00:23:35,360
clear-eyed understanding of the

00:23:33,280 --> 00:23:37,840
longer-term implications of managing

00:23:35,360 --> 00:23:37,840
these types

00:23:38,080 --> 00:23:41,200
so a common new use of interfaces that i

00:23:40,880 --> 00:23:43,760
see

00:23:41,200 --> 00:23:45,919
all the time is to use them simply to

00:23:43,760 --> 00:23:48,159
express a contract for shared fields

00:23:45,919 --> 00:23:51,120
between types and that's all

00:23:48,159 --> 00:23:52,159
so ultimately they should be reserved

00:23:51,120 --> 00:23:54,159
for when you really

00:23:52,159 --> 00:23:55,760
when you need to return an object or a

00:23:54,159 --> 00:23:57,520
set of objects from a field

00:23:55,760 --> 00:23:59,440
and those objects may represent a

00:23:57,520 --> 00:24:01,039
variety of different types with some

00:23:59,440 --> 00:24:02,960
fields in common

00:24:01,039 --> 00:24:05,200
and this is my number one pro tip for

00:24:02,960 --> 00:24:07,600
interface usage in any kind of graphql

00:24:05,200 --> 00:24:10,720
schema whether it's federated or not

00:24:07,600 --> 00:24:11,679
and that the tip is going to be is if

00:24:10,720 --> 00:24:13,600
that interface

00:24:11,679 --> 00:24:15,279
isn't being used as an output type

00:24:13,600 --> 00:24:18,000
anywhere in your schema then there's a

00:24:15,279 --> 00:24:20,960
good chance that you don't need it

00:24:18,000 --> 00:24:21,679
so for example in this schema the family

00:24:20,960 --> 00:24:23,679
pets query

00:24:21,679 --> 00:24:25,520
returns a list of cats and dogs with a

00:24:23,679 --> 00:24:26,159
guarantee that the breed field will be

00:24:25,520 --> 00:24:29,120
implemented

00:24:26,159 --> 00:24:31,039
on both the cat and dog types and a

00:24:29,120 --> 00:24:33,919
client can then query these

00:24:31,039 --> 00:24:34,240
types shared fields as usual or they can

00:24:33,919 --> 00:24:35,919
use

00:24:34,240 --> 00:24:37,679
inline fragments for the cat and dog

00:24:35,919 --> 00:24:39,120
types to fetch their type specific

00:24:37,679 --> 00:24:41,520
fields

00:24:39,120 --> 00:24:42,880
and if there was no use case for ever

00:24:41,520 --> 00:24:45,200
querying both cats and dogs

00:24:42,880 --> 00:24:45,679
simultaneously to return both types from

00:24:45,200 --> 00:24:47,760
a single

00:24:45,679 --> 00:24:49,679
operation like this then the pet

00:24:47,760 --> 00:24:51,279
interface wouldn't serve any notable

00:24:49,679 --> 00:24:53,120
purpose in this schema

00:24:51,279 --> 00:24:54,320
instead it's just going to add overhead

00:24:53,120 --> 00:24:56,400
to your schema maintenance

00:24:54,320 --> 00:24:58,400
by requiring that the cat and dog types

00:24:56,400 --> 00:24:59,200
continue to adhere to this interface as

00:24:58,400 --> 00:25:01,760
they evolve

00:24:59,200 --> 00:25:05,200
but with no functional reason as to why

00:25:01,760 --> 00:25:07,679
they should continue conforming to pet

00:25:05,200 --> 00:25:08,480
so building on this interfaces and

00:25:07,679 --> 00:25:10,080
unions

00:25:08,480 --> 00:25:11,600
should be added to a schema and

00:25:10,080 --> 00:25:12,559
subsequently evolved with careful

00:25:11,600 --> 00:25:14,480
consideration

00:25:12,559 --> 00:25:16,880
because subtle breaking changes can

00:25:14,480 --> 00:25:17,600
occur for api consumers that rely on

00:25:16,880 --> 00:25:19,120
them

00:25:17,600 --> 00:25:21,200
and again this is important for

00:25:19,120 --> 00:25:22,960
non-federated apis but even more

00:25:21,200 --> 00:25:24,799
important with federation because of the

00:25:22,960 --> 00:25:26,799
complexity that you can introduce

00:25:24,799 --> 00:25:28,799
when related concrete types cross

00:25:26,799 --> 00:25:31,520
subgraph boundaries

00:25:28,799 --> 00:25:33,760
so for example a new goldfish type may

00:25:31,520 --> 00:25:35,360
implement the pet interface in a later

00:25:33,760 --> 00:25:37,360
iteration of your schema

00:25:35,360 --> 00:25:39,360
and the previous get family pet

00:25:37,360 --> 00:25:39,760
operation may now return results that

00:25:39,360 --> 00:25:42,240
include

00:25:39,760 --> 00:25:44,000
goldfish but the client's user interface

00:25:42,240 --> 00:25:47,200
may have only been tailored to handle

00:25:44,000 --> 00:25:49,039
results for cats and dogs so without a

00:25:47,200 --> 00:25:51,520
new inline fragment in the operation

00:25:49,039 --> 00:25:53,120
document to handle the goldfish type

00:25:51,520 --> 00:25:54,880
there would be no way to retrieve its

00:25:53,120 --> 00:25:56,240
lifespan field value and this may be

00:25:54,880 --> 00:25:58,480
really important information

00:25:56,240 --> 00:25:59,760
as far as the the client user interface

00:25:58,480 --> 00:26:02,159
is concerned

00:25:59,760 --> 00:26:03,760
so as we can see it's important to

00:26:02,159 --> 00:26:04,559
communicate these changes to client

00:26:03,760 --> 00:26:06,480
developers

00:26:04,559 --> 00:26:08,159
in advance and it's also incumbent on

00:26:06,480 --> 00:26:08,720
client developers to treat fields that

00:26:08,159 --> 00:26:10,960
return

00:26:08,720 --> 00:26:12,159
abstract types with extra care to guard

00:26:10,960 --> 00:26:14,559
against these kinds of potential

00:26:12,159 --> 00:26:17,600
breaking changes

00:26:14,559 --> 00:26:20,400
so as a final consideration when using

00:26:17,600 --> 00:26:22,559
abstract types with federation

00:26:20,400 --> 00:26:24,400
this can be a little bit of a tricky

00:26:22,559 --> 00:26:25,840
matter to resolve when they're reused

00:26:24,400 --> 00:26:26,640
across different subgraphs in your

00:26:25,840 --> 00:26:29,279
schema

00:26:26,640 --> 00:26:31,279
and long story short the resolve type

00:26:29,279 --> 00:26:31,679
resolver will need to be able to resolve

00:26:31,279 --> 00:26:33,919
on

00:26:31,679 --> 00:26:35,600
all concrete types for a given abstract

00:26:33,919 --> 00:26:36,559
type within the context of a single

00:26:35,600 --> 00:26:38,400
subgraph

00:26:36,559 --> 00:26:40,240
so this is important to keep in mind

00:26:38,400 --> 00:26:42,320
when designing your schema if you have

00:26:40,240 --> 00:26:45,279
some complex use cases for interfaces

00:26:42,320 --> 00:26:45,279
and unions in mind

00:26:45,679 --> 00:26:49,760
all right so for our sixth best practice

00:26:48,240 --> 00:26:52,559
we want to think about

00:26:49,760 --> 00:26:53,919
uh what process we'll use to safely

00:26:52,559 --> 00:26:56,080
retire fields from

00:26:53,919 --> 00:26:58,559
from a federated data graph once they're

00:26:56,080 --> 00:27:00,720
no longer needed or supported

00:26:58,559 --> 00:27:02,880
and your current strategy for this may

00:27:00,720 --> 00:27:04,799
be to never actually remove

00:27:02,880 --> 00:27:06,720
any deprecated fields because you're not

00:27:04,799 --> 00:27:09,120
sure when it would be safe to do so

00:27:06,720 --> 00:27:10,559
which may be sustainable for a while but

00:27:09,120 --> 00:27:12,880
over the longer term it's going to

00:27:10,559 --> 00:27:15,600
create a lot of noise in your graph

00:27:12,880 --> 00:27:16,480
so as a remedy your internal schema

00:27:15,600 --> 00:27:18,559
governance group

00:27:16,480 --> 00:27:20,720
should outline a company-wide field

00:27:18,559 --> 00:27:22,559
rollover strategy to gracefully handle

00:27:20,720 --> 00:27:23,919
type and field deprecations throughout

00:27:22,559 --> 00:27:26,480
the unified graph

00:27:23,919 --> 00:27:28,640
and doing so is going to require clear

00:27:26,480 --> 00:27:30,480
communication with api consumers

00:27:28,640 --> 00:27:32,640
as well as visibility on how they're

00:27:30,480 --> 00:27:35,679
querying your graph

00:27:32,640 --> 00:27:37,360
so as a first step the at deprecated

00:27:35,679 --> 00:27:38,960
directive which is defined in the

00:27:37,360 --> 00:27:40,799
graphql specification

00:27:38,960 --> 00:27:43,360
should be applied when deprecating

00:27:40,799 --> 00:27:45,520
fields or enum values in your schema

00:27:43,360 --> 00:27:47,679
and the directive single reason argument

00:27:45,520 --> 00:27:49,200
can also provide the api consumer some

00:27:47,679 --> 00:27:51,200
direction about what they should do

00:27:49,200 --> 00:27:52,799
instead of using that deprecated field

00:27:51,200 --> 00:27:54,240
or enum value

00:27:52,799 --> 00:27:56,640
and i should also mention that the add

00:27:54,240 --> 00:27:58,960
deprecated directive is fully supported

00:27:56,640 --> 00:28:01,520
by your apollo server based subgraphs

00:27:58,960 --> 00:28:03,440
so you can use it just as you would for

00:28:01,520 --> 00:28:06,000
a non-federated graphql api that you

00:28:03,440 --> 00:28:08,240
build with apollo server

00:28:06,000 --> 00:28:10,000
now just as an example to illustrate

00:28:08,240 --> 00:28:12,320
that point here we can see that we

00:28:10,000 --> 00:28:14,320
indicate that a top products query has

00:28:12,320 --> 00:28:15,120
been deprecated in favor of a products

00:28:14,320 --> 00:28:16,960
query

00:28:15,120 --> 00:28:18,720
and we do give the developer a little

00:28:16,960 --> 00:28:20,080
bit of extra information about what they

00:28:18,720 --> 00:28:21,840
should use instead of that top

00:28:20,080 --> 00:28:24,640
products query in the reason argument

00:28:21,840 --> 00:28:24,640
for the directive

00:28:24,960 --> 00:28:30,159
now after a subgraph schema has been

00:28:27,760 --> 00:28:31,840
updated with new deprecated directives

00:28:30,159 --> 00:28:34,799
it's important to communicate the

00:28:31,840 --> 00:28:37,840
deprecations beyond the sdl as well

00:28:34,799 --> 00:28:40,880
and having a dedicated slack channel or

00:28:37,840 --> 00:28:43,039
a channel in microsoft teams or

00:28:40,880 --> 00:28:44,880
space in a team meeting may serve as an

00:28:43,039 --> 00:28:45,679
appropriate communication channel for

00:28:44,880 --> 00:28:48,399
reeling

00:28:45,679 --> 00:28:50,240
these notices um and they when you share

00:28:48,399 --> 00:28:52,000
this information you should also

00:28:50,240 --> 00:28:53,840
share some information about uh

00:28:52,000 --> 00:28:55,120
additional migration instructions that

00:28:53,840 --> 00:28:56,399
are going to be beneficial to client

00:28:55,120 --> 00:28:58,799
developers

00:28:56,399 --> 00:29:00,159
but even after all this asynchronous and

00:28:58,799 --> 00:29:01,760
synchronous communication

00:29:00,159 --> 00:29:03,760
uh there's still an important question

00:29:01,760 --> 00:29:05,840
that remains which is when will it be

00:29:03,760 --> 00:29:08,000
safe to remove the deprecated fields

00:29:05,840 --> 00:29:10,080
from the subgraph

00:29:08,000 --> 00:29:11,840
and to answer that question with any

00:29:10,080 --> 00:29:13,840
certainty that you won't cause breaking

00:29:11,840 --> 00:29:15,440
changes to client applications

00:29:13,840 --> 00:29:17,279
you're going to want to lean on your

00:29:15,440 --> 00:29:19,279
observability tooling again

00:29:17,279 --> 00:29:21,360
and specifically we can see some

00:29:19,279 --> 00:29:23,279
operation tracing data from apollo

00:29:21,360 --> 00:29:24,480
studio here and how it can provide you

00:29:23,279 --> 00:29:26,880
with insight into

00:29:24,480 --> 00:29:28,559
what clients may still be using in terms

00:29:26,880 --> 00:29:30,640
of the operations they're running

00:29:28,559 --> 00:29:31,679
that may include deprecated fields so

00:29:30,640 --> 00:29:34,159
you can

00:29:31,679 --> 00:29:36,240
action appropriate follow-ups as needed

00:29:34,159 --> 00:29:38,240
and you'll know when it's safe

00:29:36,240 --> 00:29:41,200
and it's a good time to actually remove

00:29:38,240 --> 00:29:44,159
that field

00:29:41,200 --> 00:29:46,320
okay so on to our seventh and final best

00:29:44,159 --> 00:29:47,360
practice for today

00:29:46,320 --> 00:29:49,440
we're going to talk a little bit about

00:29:47,360 --> 00:29:50,799
cross-cutting concerns when we're

00:29:49,440 --> 00:29:53,200
dealing with federation

00:29:50,799 --> 00:29:54,000
and there's a very good question we

00:29:53,200 --> 00:29:55,520
might ask here which

00:29:54,000 --> 00:29:57,279
is what kind of cross-cutting concerns

00:29:55,520 --> 00:29:59,600
are we talking about

00:29:57,279 --> 00:30:00,320
so sometimes with a federated graphql

00:29:59,600 --> 00:30:02,399
api

00:30:00,320 --> 00:30:04,480
subgraphs may need to share ownership of

00:30:02,399 --> 00:30:06,799
certain types rather than assigning that

00:30:04,480 --> 00:30:09,120
type to a particular subgraph

00:30:06,799 --> 00:30:11,039
and we may need to do that for cases

00:30:09,120 --> 00:30:12,880
where we want to have identical object

00:30:11,039 --> 00:30:14,240
types across graphs for our pagination

00:30:12,880 --> 00:30:16,960
fields

00:30:14,240 --> 00:30:18,159
so to illustrate that that this example

00:30:16,960 --> 00:30:20,559
here

00:30:18,159 --> 00:30:21,600
if you're implementing relay style

00:30:20,559 --> 00:30:24,320
pagination

00:30:21,600 --> 00:30:26,240
you'll need to have a page info object

00:30:24,320 --> 00:30:28,000
for each of the subgraphs where you

00:30:26,240 --> 00:30:29,360
apply pagination fields based on that

00:30:28,000 --> 00:30:32,000
relay spec

00:30:29,360 --> 00:30:33,919
and luckily we can share object types

00:30:32,000 --> 00:30:35,039
like this across subgraphs with apollo

00:30:33,919 --> 00:30:37,679
federation

00:30:35,039 --> 00:30:39,039
and we can also share scalars interfaces

00:30:37,679 --> 00:30:41,200
enums and inputs too

00:30:39,039 --> 00:30:42,640
and when we do that we call these things

00:30:41,200 --> 00:30:44,720
value types

00:30:42,640 --> 00:30:47,200
and there are nuanced differences in how

00:30:44,720 --> 00:30:48,799
these value types may actually be shared

00:30:47,200 --> 00:30:50,480
across subgraph schemas

00:30:48,799 --> 00:30:52,720
and you can head over to the apollo

00:30:50,480 --> 00:30:54,960
federation docs for more information

00:30:52,720 --> 00:30:55,760
about all the different criteria you

00:30:54,960 --> 00:30:57,600
want to consider

00:30:55,760 --> 00:30:58,880
for each type of type when you're

00:30:57,600 --> 00:31:01,440
sharing them but

00:30:58,880 --> 00:31:02,399
as a general rule where subgraphs share

00:31:01,440 --> 00:31:04,480
value types

00:31:02,399 --> 00:31:05,919
then those types must be identical in

00:31:04,480 --> 00:31:08,320
name and contents

00:31:05,919 --> 00:31:09,519
otherwise compositions or errors will

00:31:08,320 --> 00:31:11,360
occur

00:31:09,519 --> 00:31:13,200
and it's a good idea to make sure that

00:31:11,360 --> 00:31:15,600
the their behavior is logically

00:31:13,200 --> 00:31:17,760
consistent as well across the subgraphs

00:31:15,600 --> 00:31:20,159
where they're defined and resolved and

00:31:17,760 --> 00:31:21,919
there's no way for us to test

00:31:20,159 --> 00:31:23,679
through composition for logical

00:31:21,919 --> 00:31:25,039
consistency of these value types

00:31:23,679 --> 00:31:26,720
implementations but

00:31:25,039 --> 00:31:27,840
for the sanity of your client developers

00:31:26,720 --> 00:31:29,279
this is something that you're going to

00:31:27,840 --> 00:31:30,559
want to make sure you're taking care of

00:31:29,279 --> 00:31:33,760
on your end

00:31:30,559 --> 00:31:35,519
and based on these criteria uh i think

00:31:33,760 --> 00:31:37,760
that the page info type here

00:31:35,519 --> 00:31:39,519
is ultimately a really good example of

00:31:37,760 --> 00:31:40,080
something that should be a shared value

00:31:39,519 --> 00:31:41,519
type

00:31:40,080 --> 00:31:44,080
because it's not something that's going

00:31:41,519 --> 00:31:45,840
to change very often if ever

00:31:44,080 --> 00:31:47,200
and this also doesn't represent a

00:31:45,840 --> 00:31:49,519
uniquely identified

00:31:47,200 --> 00:31:50,960
identifiable resource that needs to be

00:31:49,519 --> 00:31:52,720
owned by one subgraph and then

00:31:50,960 --> 00:31:54,240
potentially referenced elsewhere because

00:31:52,720 --> 00:31:56,720
in that case it should really just be an

00:31:54,240 --> 00:31:56,720
entity

00:31:57,039 --> 00:32:02,399
so custom directives may also be shared

00:32:00,799 --> 00:32:03,840
and when we're talking about sharing

00:32:02,399 --> 00:32:05,120
custom directives we need to think about

00:32:03,840 --> 00:32:06,080
the two different kinds of directives

00:32:05,120 --> 00:32:08,320
that we're dealing with

00:32:06,080 --> 00:32:09,279
so first is type system or schema

00:32:08,320 --> 00:32:10,960
directives

00:32:09,279 --> 00:32:12,880
and these are the directives that you

00:32:10,960 --> 00:32:15,039
use to annotate your schema

00:32:12,880 --> 00:32:17,840
and these kinds of directives may be

00:32:15,039 --> 00:32:18,960
handled on a service by service basis

00:32:17,840 --> 00:32:22,080
because they're stripped from the

00:32:18,960 --> 00:32:23,760
gateway schema executable directives on

00:32:22,080 --> 00:32:25,120
the other hand or you may also refer to

00:32:23,760 --> 00:32:27,039
them as query directives

00:32:25,120 --> 00:32:28,559
are those directives that we use to

00:32:27,039 --> 00:32:30,880
annotate our operations

00:32:28,559 --> 00:32:32,320
so a good example of this would be the

00:32:30,880 --> 00:32:33,519
built-in ad skip or add include

00:32:32,320 --> 00:32:36,000
directives

00:32:33,519 --> 00:32:37,760
and these directives must be defined in

00:32:36,000 --> 00:32:38,960
the schemas of all subgraphs in your

00:32:37,760 --> 00:32:41,039
federated data graph

00:32:38,960 --> 00:32:42,399
and with the same locations arguments

00:32:41,039 --> 00:32:45,039
and argument types

00:32:42,399 --> 00:32:45,600
otherwise composition errors will occur

00:32:45,039 --> 00:32:47,840
and

00:32:45,600 --> 00:32:49,519
further and similar to the value types

00:32:47,840 --> 00:32:51,760
that we just discussed

00:32:49,519 --> 00:32:54,000
all subgraphs should use the same logic

00:32:51,760 --> 00:32:54,640
to handling executable directives as

00:32:54,000 --> 00:32:56,720
well

00:32:54,640 --> 00:32:58,000
so that you can avoid any ambiguity for

00:32:56,720 --> 00:33:01,600
clients that are applying those

00:32:58,000 --> 00:33:03,600
directives to their operations

00:33:01,600 --> 00:33:05,200
so what does all of this mean in terms

00:33:03,600 --> 00:33:07,360
of deployment well

00:33:05,200 --> 00:33:09,440
it means that if you change a value type

00:33:07,360 --> 00:33:11,440
definition or an executable directive

00:33:09,440 --> 00:33:13,200
definition uh you're going to need to

00:33:11,440 --> 00:33:14,559
make that change simultaneously across

00:33:13,200 --> 00:33:17,600
the subgraphs that define

00:33:14,559 --> 00:33:19,600
those uh schema components so you'll

00:33:17,600 --> 00:33:20,159
want to carefully evaluate the potential

00:33:19,600 --> 00:33:23,600
long-term

00:33:20,159 --> 00:33:25,519
impact and complexity of of introducing

00:33:23,600 --> 00:33:27,600
any cross-cutting concerns into your

00:33:25,519 --> 00:33:29,919
federated graphql api

00:33:27,600 --> 00:33:31,440
and there may be uh some different

00:33:29,919 --> 00:33:33,519
approaches to handling uh

00:33:31,440 --> 00:33:34,799
type ownership and directive ownership

00:33:33,519 --> 00:33:36,799
in the future with federation

00:33:34,799 --> 00:33:38,720
so i would encourage you to stay tuned

00:33:36,799 --> 00:33:39,360
to future product updates and webinars

00:33:38,720 --> 00:33:42,240
for info

00:33:39,360 --> 00:33:42,559
as that becomes avail available but for

00:33:42,240 --> 00:33:44,559
now

00:33:42,559 --> 00:33:46,080
you want to have a plan for how to

00:33:44,559 --> 00:33:48,640
handle these changes

00:33:46,080 --> 00:33:50,799
as they arise and perhaps opt not to use

00:33:48,640 --> 00:33:52,159
shared value types

00:33:50,799 --> 00:33:54,720
when you're dealing with a type that

00:33:52,159 --> 00:33:56,720
needs to be updated at a high velocity

00:33:54,720 --> 00:33:58,720
or perhaps at different velocities

00:33:56,720 --> 00:33:59,440
across different subgraphs because in

00:33:58,720 --> 00:34:00,960
those cases

00:33:59,440 --> 00:34:02,960
something like subgraph level name

00:34:00,960 --> 00:34:04,960
spacing may be better or again

00:34:02,960 --> 00:34:06,720
in some instances it might actually make

00:34:04,960 --> 00:34:10,800
more sense to make a particular type an

00:34:06,720 --> 00:34:10,800
entity if it's an object or an interface

00:34:11,040 --> 00:34:16,240
okay so summing up

00:34:14,079 --> 00:34:18,240
i'd like to tie together some of the key

00:34:16,240 --> 00:34:20,000
thing key themes that have emerged

00:34:18,240 --> 00:34:21,679
across the best practices that we've

00:34:20,000 --> 00:34:25,119
explored today

00:34:21,679 --> 00:34:27,280
so as we've seen today virtually

00:34:25,119 --> 00:34:29,599
all general graphql schema design best

00:34:27,280 --> 00:34:30,159
practices apply to federated data graphs

00:34:29,599 --> 00:34:31,919
too

00:34:30,159 --> 00:34:33,760
but you just have to think about them on

00:34:31,919 --> 00:34:36,800
a larger and more distributed and

00:34:33,760 --> 00:34:39,359
potentially more complex scale

00:34:36,800 --> 00:34:40,000
the second key point is that governance

00:34:39,359 --> 00:34:42,079
standards

00:34:40,000 --> 00:34:44,399
and the way you enforce those standards

00:34:42,079 --> 00:34:46,560
is key to ensuring that entropy doesn't

00:34:44,399 --> 00:34:48,320
have its way with your schema over time

00:34:46,560 --> 00:34:50,560
and that you continue to evolve your

00:34:48,320 --> 00:34:54,320
schema in a way that enhances usability

00:34:50,560 --> 00:34:57,040
and predictability for client developers

00:34:54,320 --> 00:34:57,520
third communication between subgraph

00:34:57,040 --> 00:35:00,160
teams

00:34:57,520 --> 00:35:02,560
and with client teams is also so so

00:35:00,160 --> 00:35:04,400
important as the schema evolves so

00:35:02,560 --> 00:35:06,720
having automated ways to do this through

00:35:04,400 --> 00:35:08,480
a schema registry and slack or teams

00:35:06,720 --> 00:35:10,320
notifications is a must

00:35:08,480 --> 00:35:12,000
but also having dedicated space for

00:35:10,320 --> 00:35:12,960
synchronous team communication about

00:35:12,000 --> 00:35:16,079
schema updates

00:35:12,960 --> 00:35:19,200
is also really important too

00:35:16,079 --> 00:35:20,240
and lastly as subgraph owners propose

00:35:19,200 --> 00:35:22,320
schema changes

00:35:20,240 --> 00:35:23,839
a schema registry and your observability

00:35:22,320 --> 00:35:25,680
tooling such as apollo studio

00:35:23,839 --> 00:35:28,000
can give you immediate insight into

00:35:25,680 --> 00:35:30,640
whether those changes can be done safely

00:35:28,000 --> 00:35:31,839
and not cause breaking changes for uh

00:35:30,640 --> 00:35:33,520
other subgraphs

00:35:31,839 --> 00:35:35,599
or for client applications that are

00:35:33,520 --> 00:35:38,880
currently running operations against the

00:35:35,599 --> 00:35:42,240
graph in production environments

00:35:38,880 --> 00:35:42,640
okay so if you have enjoyed the content

00:35:42,240 --> 00:35:45,440
in

00:35:42,640 --> 00:35:48,000
this webinar today i'd encourage you to

00:35:45,440 --> 00:35:48,480
take a look at our graphql at enterprise

00:35:48,000 --> 00:35:50,320
scale

00:35:48,480 --> 00:35:51,599
guide it's a pdf that you can download

00:35:50,320 --> 00:35:53,440
for free and

00:35:51,599 --> 00:35:55,280
chapter four of that guide currently

00:35:53,440 --> 00:35:56,960
contains uh a good portion of the

00:35:55,280 --> 00:35:59,359
content that we've covered today and

00:35:56,960 --> 00:36:01,040
is specifically focused on the topic of

00:35:59,359 --> 00:36:03,599
schema design best practices in

00:36:01,040 --> 00:36:06,320
federation as well

00:36:03,599 --> 00:36:08,480
and with that i'd be happy to take some

00:36:06,320 --> 00:36:12,800
questions now

00:36:08,480 --> 00:36:15,680
i'm just going to stop my screen share

00:36:12,800 --> 00:36:16,079
just take me a moment and then i can

00:36:15,680 --> 00:36:18,480
jump

00:36:16,079 --> 00:36:19,280
into the q a box here and just as a

00:36:18,480 --> 00:36:22,000
reminder

00:36:19,280 --> 00:36:23,680
um we're going to try to focus the

00:36:22,000 --> 00:36:26,480
questions as much as

00:36:23,680 --> 00:36:26,960
on the the webinar content as possible

00:36:26,480 --> 00:36:29,280
and

00:36:26,960 --> 00:36:30,960
uh probably keep it pretty high level uh

00:36:29,280 --> 00:36:32,800
so if i don't get to your question

00:36:30,960 --> 00:36:34,240
because it's uh perhaps maybe a little

00:36:32,800 --> 00:36:37,200
bit too specific for this

00:36:34,240 --> 00:36:38,839
uh this context again i'd encourage you

00:36:37,200 --> 00:36:42,720
to head over to

00:36:38,839 --> 00:36:45,440
community.apology and you can post your

00:36:42,720 --> 00:36:47,040
specific schema design question with

00:36:45,440 --> 00:36:48,400
code snippets and any additional

00:36:47,040 --> 00:36:50,640
architectural details you need to

00:36:48,400 --> 00:36:55,839
provide there

00:36:50,640 --> 00:36:55,839
so jump into the q a

00:36:56,640 --> 00:37:03,520
and let's see

00:37:01,040 --> 00:37:04,400
if i start today without apollo

00:37:03,520 --> 00:37:07,119
federation

00:37:04,400 --> 00:37:09,040
with a unique schema is it possible and

00:37:07,119 --> 00:37:12,400
easy to break

00:37:09,040 --> 00:37:13,200
into federated schemas afterwards so

00:37:12,400 --> 00:37:17,119
this question

00:37:13,200 --> 00:37:20,000
is from paulo so

00:37:17,119 --> 00:37:21,040
to answer your question i'd say yes i

00:37:20,000 --> 00:37:22,000
mean there's always going to be a

00:37:21,040 --> 00:37:25,680
migration process

00:37:22,000 --> 00:37:27,920
involved but if you have the intention

00:37:25,680 --> 00:37:29,359
to move towards federation from a

00:37:27,920 --> 00:37:32,720
monolithic graphql

00:37:29,359 --> 00:37:34,400
api down the road um you can certainly

00:37:32,720 --> 00:37:36,160
do so with some of the schema design

00:37:34,400 --> 00:37:38,960
best practices that i've mentioned

00:37:36,160 --> 00:37:40,160
in mind in terms of especially like

00:37:38,960 --> 00:37:43,119
things you might want to think about

00:37:40,160 --> 00:37:44,000
are uh nullability and how you're

00:37:43,119 --> 00:37:46,560
implementing

00:37:44,000 --> 00:37:47,760
abstract types throughout your schema

00:37:46,560 --> 00:37:49,680
you may even

00:37:47,760 --> 00:37:51,280
have it on your radar which types in

00:37:49,680 --> 00:37:52,960
your monolithic graphql

00:37:51,280 --> 00:37:55,280
api may lend themselves to becoming

00:37:52,960 --> 00:37:58,400
entities as well in the future so

00:37:55,280 --> 00:37:59,119
um yes 100 this is a very common path

00:37:58,400 --> 00:38:00,480
that we see

00:37:59,119 --> 00:38:02,160
with our enterprise customers where

00:38:00,480 --> 00:38:02,960
they're taking that model as a graphql

00:38:02,160 --> 00:38:05,359
api

00:38:02,960 --> 00:38:07,280
and they want to start federating it and

00:38:05,359 --> 00:38:08,480
a really common approach that we see in

00:38:07,280 --> 00:38:10,960
doing that

00:38:08,480 --> 00:38:12,320
is to take a strangler fig approach uh

00:38:10,960 --> 00:38:14,000
where you

00:38:12,320 --> 00:38:15,520
uh start with your monolithic graphql

00:38:14,000 --> 00:38:17,520
api and you begin

00:38:15,520 --> 00:38:19,040
breaking off sub graphs one and one at a

00:38:17,520 --> 00:38:21,200
time so rather than trying to approach

00:38:19,040 --> 00:38:23,520
it as some kind of big bang rewrite

00:38:21,200 --> 00:38:25,520
um you maybe break off your first

00:38:23,520 --> 00:38:27,119
subgraph service that corresponds to

00:38:25,520 --> 00:38:28,640
some micro service or cluster

00:38:27,119 --> 00:38:30,880
microservices where you want to manage

00:38:28,640 --> 00:38:34,000
that schema a little bit closer to it

00:38:30,880 --> 00:38:34,480
um and you just do that do that one at a

00:38:34,000 --> 00:38:36,720
time

00:38:34,480 --> 00:38:38,560
your monolithic graphql api effectively

00:38:36,720 --> 00:38:40,240
acts as your first subgraph service

00:38:38,560 --> 00:38:41,839
and you just continue breaking off more

00:38:40,240 --> 00:38:43,920
and more subgraphs from there until

00:38:41,839 --> 00:38:44,320
eventually the model of the graphql api

00:38:43,920 --> 00:38:46,560
has

00:38:44,320 --> 00:38:50,160
ceased to exist because everything is

00:38:46,560 --> 00:38:55,040
being redistributed across subgraphs

00:38:50,160 --> 00:38:55,040
okay so

00:38:56,960 --> 00:39:00,000
the next question is does federation

00:38:59,440 --> 00:39:02,640
help with

00:39:00,000 --> 00:39:03,920
making it easy to handle namespace

00:39:02,640 --> 00:39:08,240
collisions across

00:39:03,920 --> 00:39:10,720
other subgraphs so

00:39:08,240 --> 00:39:12,400
with this question um i mean there's

00:39:10,720 --> 00:39:12,800
there's a few different dimensions to

00:39:12,400 --> 00:39:17,359
this

00:39:12,800 --> 00:39:19,680
so in terms of namespace collisions um

00:39:17,359 --> 00:39:20,640
we can think of two different scenarios

00:39:19,680 --> 00:39:23,599
i think here so

00:39:20,640 --> 00:39:25,359
potentially could be a value type or

00:39:23,599 --> 00:39:26,960
something that's not a value type that

00:39:25,359 --> 00:39:28,320
perhaps may need to be turned into a

00:39:26,960 --> 00:39:32,640
value type in the future

00:39:28,320 --> 00:39:34,720
so i uh just building off of what i i

00:39:32,640 --> 00:39:37,119
pointed out in the the cross-cutting

00:39:34,720 --> 00:39:38,160
concerns uh best practice section of the

00:39:37,119 --> 00:39:42,320
webinar

00:39:38,160 --> 00:39:44,640
um if you make a change to a value type

00:39:42,320 --> 00:39:46,400
in one of your subgraphs and that change

00:39:44,640 --> 00:39:48,480
hasn't been coordinated across all the

00:39:46,400 --> 00:39:51,760
subgraphs that implement that value type

00:39:48,480 --> 00:39:53,200
then using managed federation with a

00:39:51,760 --> 00:39:56,240
schema registry

00:39:53,200 --> 00:39:57,040
will 100 percent give you a user

00:39:56,240 --> 00:40:00,240
interface

00:39:57,040 --> 00:40:00,960
for um realizing what kind of

00:40:00,240 --> 00:40:02,960
compositions

00:40:00,960 --> 00:40:04,240
errors have occurred and giving you a

00:40:02,960 --> 00:40:05,680
path forward for

00:40:04,240 --> 00:40:07,119
uh how you want to handle those

00:40:05,680 --> 00:40:08,720
composition errors so it's going to give

00:40:07,119 --> 00:40:10,079
you some visibility on that

00:40:08,720 --> 00:40:12,000
you're certainly going to get some

00:40:10,079 --> 00:40:13,839
feedback even without managed federation

00:40:12,000 --> 00:40:15,119
as you try to compose your schema with

00:40:13,839 --> 00:40:17,119
value types that aren't consistent

00:40:15,119 --> 00:40:19,520
you'll get some feedback uh

00:40:17,119 --> 00:40:21,440
from that as well for say for instance

00:40:19,520 --> 00:40:24,240
if you're using the rover cli

00:40:21,440 --> 00:40:25,760
but i think for uh if you have scenarios

00:40:24,240 --> 00:40:27,440
where you think that this is going to be

00:40:25,760 --> 00:40:29,200
an issue i'd definitely encourage you to

00:40:27,440 --> 00:40:32,960
take a look at what managed federation

00:40:29,200 --> 00:40:32,960
and a schema registry can do for you

00:40:33,599 --> 00:40:39,760
um okay so moving on to the next

00:40:38,079 --> 00:40:41,200
question this is a bit of a longer one

00:40:39,760 --> 00:40:43,440
so i'm just gonna give it a quick read

00:40:41,200 --> 00:40:43,440
here

00:40:45,599 --> 00:40:51,760
okay so if both services or subgraphs

00:40:49,200 --> 00:40:53,760
have a connection to the same database

00:40:51,760 --> 00:40:55,119
for example if in the review service i

00:40:53,760 --> 00:40:57,839
would query to

00:40:55,119 --> 00:40:58,640
get product and return it it would go to

00:40:57,839 --> 00:41:01,280
the resolve

00:40:58,640 --> 00:41:02,160
reference in the product subgraph even

00:41:01,280 --> 00:41:04,480
if

00:41:02,160 --> 00:41:06,079
we provide the whole product object as i

00:41:04,480 --> 00:41:07,440
understood the only way to prevent this

00:41:06,079 --> 00:41:08,880
has something to do with the app

00:41:07,440 --> 00:41:11,839
provides directive

00:41:08,880 --> 00:41:13,280
could you elaborate that and give some

00:41:11,839 --> 00:41:16,400
examples

00:41:13,280 --> 00:41:18,079
um so yeah it sounds like provides is

00:41:16,400 --> 00:41:19,839
definitely going to be the answer here

00:41:18,079 --> 00:41:22,160
so the app provides directive

00:41:19,839 --> 00:41:23,119
this is this is particularly useful

00:41:22,160 --> 00:41:26,400
actually where you have

00:41:23,119 --> 00:41:28,160
two different uh data stores

00:41:26,400 --> 00:41:30,400
and some of your data has been

00:41:28,160 --> 00:41:31,440
denormalized across those two different

00:41:30,400 --> 00:41:36,079
data stores

00:41:31,440 --> 00:41:37,520
and you want to save network hops

00:41:36,079 --> 00:41:38,880
where they might not be necessary

00:41:37,520 --> 00:41:40,160
because say the review service can

00:41:38,880 --> 00:41:42,160
actually provide more data

00:41:40,160 --> 00:41:43,440
about a given product than just it than

00:41:42,160 --> 00:41:45,200
just its id

00:41:43,440 --> 00:41:47,200
so in that case you could use the app

00:41:45,200 --> 00:41:49,760
provides directive to say hey my

00:41:47,200 --> 00:41:51,200
my review service knows more about the

00:41:49,760 --> 00:41:53,040
product than just the key i want to

00:41:51,200 --> 00:41:54,720
provide these additional fields

00:41:53,040 --> 00:41:56,560
if they're queried for and that can in

00:41:54,720 --> 00:41:58,480
fact helps help you save

00:41:56,560 --> 00:42:03,200
a network hop back over to the product

00:41:58,480 --> 00:42:06,730
service to get that additional data

00:42:03,200 --> 00:42:09,040
okay um

00:42:06,730 --> 00:42:12,000
[Music]

00:42:09,040 --> 00:42:12,800
okay so the next question is my team is

00:42:12,000 --> 00:42:15,520
considering

00:42:12,800 --> 00:42:16,480
publishing a subset of our api as a

00:42:15,520 --> 00:42:18,480
product

00:42:16,480 --> 00:42:20,640
does apollo federation facilitate

00:42:18,480 --> 00:42:22,240
configuring and controlling endpoints as

00:42:20,640 --> 00:42:24,800
public or private

00:42:22,240 --> 00:42:25,520
if we aren't using multiple data stores

00:42:24,800 --> 00:42:27,359
would using

00:42:25,520 --> 00:42:30,720
federation to accomplish this be

00:42:27,359 --> 00:42:34,560
overkill assuming it's possible at all

00:42:30,720 --> 00:42:36,319
um so given the amount of context i have

00:42:34,560 --> 00:42:39,599
in this question

00:42:36,319 --> 00:42:41,680
um i i would say

00:42:39,599 --> 00:42:43,119
that uh one thing that you might be

00:42:41,680 --> 00:42:45,440
interested in that's in our

00:42:43,119 --> 00:42:47,440
that's on our product roadmap is the

00:42:45,440 --> 00:42:49,119
idea of being able to

00:42:47,440 --> 00:42:51,200
uh have different contracts available

00:42:49,119 --> 00:42:54,160
for your schemas so depending on who

00:42:51,200 --> 00:42:57,119
the api consumer is you may be able to

00:42:54,160 --> 00:42:58,960
expose different subsets of your schema

00:42:57,119 --> 00:43:01,200
to them based on some contract that you

00:42:58,960 --> 00:43:03,200
define and this is a little bit outside

00:43:01,200 --> 00:43:05,839
the scope of the schema design best

00:43:03,200 --> 00:43:07,920
practices content for today but i would

00:43:05,839 --> 00:43:10,560
definitely encourage you to sign up for

00:43:07,920 --> 00:43:12,560
upcoming product update webinars because

00:43:10,560 --> 00:43:14,480
that would be the best place to get more

00:43:12,560 --> 00:43:15,599
information about those features as they

00:43:14,480 --> 00:43:17,040
become available

00:43:15,599 --> 00:43:19,359
and that's specifically going to be

00:43:17,040 --> 00:43:20,480
related to uh managed federation and

00:43:19,359 --> 00:43:23,599
apollo studio

00:43:20,480 --> 00:43:23,599
where you would implement that

00:43:24,839 --> 00:43:33,040
okay um

00:43:28,800 --> 00:43:35,920
let's see so for our next question here

00:43:33,040 --> 00:43:36,640
uh so the question is would love to know

00:43:35,920 --> 00:43:39,520
if there's

00:43:36,640 --> 00:43:40,000
any examples you've seen or heard of for

00:43:39,520 --> 00:43:42,720
schema

00:43:40,000 --> 00:43:43,280
governance at scale at companies for

00:43:42,720 --> 00:43:46,319
example

00:43:43,280 --> 00:43:50,000
how to ensure sub-graphs aren't defined

00:43:46,319 --> 00:43:52,640
defining poorly named entity types

00:43:50,000 --> 00:43:53,200
a single monorepo of schema types that

00:43:52,640 --> 00:43:55,280
can be

00:43:53,200 --> 00:43:57,280
pr reviewed and forced versus

00:43:55,280 --> 00:43:58,240
multi-schema repos across the company

00:43:57,280 --> 00:44:00,960
and how to

00:43:58,240 --> 00:44:02,160
enforce slash review those schemas npr

00:44:00,960 --> 00:44:04,640
so

00:44:02,160 --> 00:44:05,920
for this what i would recommend again is

00:44:04,640 --> 00:44:08,960
go check out that

00:44:05,920 --> 00:44:10,400
graphql at enterprise scale

00:44:08,960 --> 00:44:12,800
ebook that i mentioned that's free for

00:44:10,400 --> 00:44:16,400
download at apollographql.com

00:44:12,800 --> 00:44:17,760
guide um currently it's in uh pdf format

00:44:16,400 --> 00:44:19,119
which you can download there we'll also

00:44:17,760 --> 00:44:20,560
be shifting a lot of that content over

00:44:19,119 --> 00:44:22,000
to our docs as well in the very near

00:44:20,560 --> 00:44:24,400
future so stay tuned for that

00:44:22,000 --> 00:44:25,599
but in that guide the most recent

00:44:24,400 --> 00:44:29,119
chapter is on

00:44:25,599 --> 00:44:31,119
uh graph administration and towards the

00:44:29,119 --> 00:44:32,960
end of that chapter there's a section on

00:44:31,119 --> 00:44:33,680
schema governance where we give you some

00:44:32,960 --> 00:44:35,599
tips on

00:44:33,680 --> 00:44:37,520
how you can implement governance

00:44:35,599 --> 00:44:38,079
practices for your federated data graph

00:44:37,520 --> 00:44:40,160
so

00:44:38,079 --> 00:44:41,760
for that i definitely encourage you to

00:44:40,160 --> 00:44:43,920
go take a look at our

00:44:41,760 --> 00:44:47,040
guide for some detailed information on

00:44:43,920 --> 00:44:47,040
how you can approach that

00:44:49,280 --> 00:44:53,359
um okay so

00:44:54,640 --> 00:44:58,000
for our next question

00:44:59,680 --> 00:45:04,000
um so there's a question here about will

00:45:01,599 --> 00:45:06,079
you be sharing the slide deck with us

00:45:04,000 --> 00:45:08,880
is everything being said here already

00:45:06,079 --> 00:45:11,200
available in a document of some sort

00:45:08,880 --> 00:45:13,440
and yes again just to reiterate chapter

00:45:11,200 --> 00:45:14,160
four of the graphql enterprise scale

00:45:13,440 --> 00:45:16,960
guide

00:45:14,160 --> 00:45:18,640
uh we'll cover all of the content that

00:45:16,960 --> 00:45:20,160
we explored in the webinar today and

00:45:18,640 --> 00:45:21,200
then we'll also be sharing a recording

00:45:20,160 --> 00:45:24,800
of the webinar too

00:45:21,200 --> 00:45:24,800
uh so you can have that as a resource

00:45:29,119 --> 00:45:35,280
um so we have another question about

00:45:33,200 --> 00:45:37,440
graph governance here as well which is

00:45:35,280 --> 00:45:39,520
uh who do you recommend owns the

00:45:37,440 --> 00:45:41,280
governance of the graph schema

00:45:39,520 --> 00:45:44,000
consistency

00:45:41,280 --> 00:45:45,599
so i'm going to give a classic uh

00:45:44,000 --> 00:45:46,640
developer answer which is that it

00:45:45,599 --> 00:45:49,280
depends

00:45:46,640 --> 00:45:49,680
um it's going to depend very much on

00:45:49,280 --> 00:45:52,800
your

00:45:49,680 --> 00:45:56,079
uh your specific context um and

00:45:52,800 --> 00:45:59,040
and your specific organization so again

00:45:56,079 --> 00:46:00,240
in the uh the graphical enterprise scale

00:45:59,040 --> 00:46:03,599
guide that i've mentioned

00:46:00,240 --> 00:46:04,720
um in that uh final section of the most

00:46:03,599 --> 00:46:07,520
recent chapter

00:46:04,720 --> 00:46:09,599
we go into governance in detail and we

00:46:07,520 --> 00:46:10,640
provide examples of who you might

00:46:09,599 --> 00:46:13,440
include

00:46:10,640 --> 00:46:14,079
in your graphql governance group that

00:46:13,440 --> 00:46:16,640
helps guide

00:46:14,079 --> 00:46:17,599
the direction of your federated uh

00:46:16,640 --> 00:46:20,160
schema design

00:46:17,599 --> 00:46:22,000
as time goes on and how that evolves um

00:46:20,160 --> 00:46:23,680
so there's a variety

00:46:22,000 --> 00:46:24,960
of different stakeholders that you may

00:46:23,680 --> 00:46:25,839
want to involve in that you're certainly

00:46:24,960 --> 00:46:27,680
going to have want to have

00:46:25,839 --> 00:46:28,880
representation from

00:46:27,680 --> 00:46:31,200
people who work closely to your

00:46:28,880 --> 00:46:32,720
different subgraphs you're going to want

00:46:31,200 --> 00:46:35,599
to have representation from

00:46:32,720 --> 00:46:37,200
a devops level an architectural level

00:46:35,599 --> 00:46:40,079
you're also going to want to

00:46:37,200 --> 00:46:41,520
absolutely include representation from

00:46:40,079 --> 00:46:44,640
client teams too

00:46:41,520 --> 00:46:47,359
um because uh graphql is

00:46:44,640 --> 00:46:47,920
an api that's a way of building apis

00:46:47,359 --> 00:46:50,480
that's uh

00:46:47,920 --> 00:46:51,920
very much motivated by the spirit of uh

00:46:50,480 --> 00:46:53,599
doing so in a way that helps us

00:46:51,920 --> 00:46:55,200
uh suit client needs so we want to have

00:46:53,599 --> 00:46:56,880
those client needs and those product

00:46:55,200 --> 00:46:58,640
requirements in mind as we're evolving

00:46:56,880 --> 00:47:00,560
our schema in the future so

00:46:58,640 --> 00:47:02,079
again i would encourage you to take a

00:47:00,560 --> 00:47:04,560
look at the

00:47:02,079 --> 00:47:06,480
graphql enterprise scale guide for more

00:47:04,560 --> 00:47:09,040
specific implementation details on that

00:47:06,480 --> 00:47:10,800
but those are just kind of a few

00:47:09,040 --> 00:47:12,240
quick tips of things that you can think

00:47:10,800 --> 00:47:14,240
of when structuring your

00:47:12,240 --> 00:47:16,560
structuring your data graph governance

00:47:14,240 --> 00:47:16,560
group

00:47:18,160 --> 00:47:29,040
um okay

00:47:25,440 --> 00:47:29,599
so let's see what questions we can

00:47:29,040 --> 00:47:38,079
answer

00:47:29,599 --> 00:47:40,640
next here

00:47:38,079 --> 00:47:41,520
so we have a question here about whether

00:47:40,640 --> 00:47:44,240
a schema

00:47:41,520 --> 00:47:46,400
governance check can be done locally

00:47:44,240 --> 00:47:48,000
before hitting the pipeline

00:47:46,400 --> 00:47:50,319
i'm trying to make sure i'm not adding

00:47:48,000 --> 00:47:52,640
an already existing attribute name to

00:47:50,319 --> 00:47:53,680
my sub graph prior to the schema

00:47:52,640 --> 00:47:57,040
governance check

00:47:53,680 --> 00:47:59,359
check done in a pipeline so for this

00:47:57,040 --> 00:48:00,960
i definitely encourage you to take a

00:47:59,359 --> 00:48:04,319
look at

00:48:00,960 --> 00:48:07,599
the rover cli so the rubber cli can be

00:48:04,319 --> 00:48:09,760
integrated very nicely into a ci cd

00:48:07,599 --> 00:48:12,720
environment but you can also

00:48:09,760 --> 00:48:13,599
use that cli of course uh locally and

00:48:12,720 --> 00:48:16,079
you can run

00:48:13,599 --> 00:48:18,000
checks against your federated data graph

00:48:16,079 --> 00:48:21,200
as you iterate a subgraph schema

00:48:18,000 --> 00:48:22,160
to ensure that um as as you're evolving

00:48:21,200 --> 00:48:23,680
that schema

00:48:22,160 --> 00:48:25,839
locally and development that that's

00:48:23,680 --> 00:48:28,640
actually going to uh compose

00:48:25,839 --> 00:48:29,760
into your schema before you initiate uh

00:48:28,640 --> 00:48:31,440
some kind of check throughout it

00:48:29,760 --> 00:48:33,280
throughout a ci cd process and then

00:48:31,440 --> 00:48:35,920
attempt to publish that schema so

00:48:33,280 --> 00:48:36,559
definitely take a look at the rover docs

00:48:35,920 --> 00:48:40,559
for

00:48:36,559 --> 00:48:40,559
information on how to use that cli

00:48:43,440 --> 00:48:49,839
um let's see for our next question

00:48:46,839 --> 00:48:49,839
here

00:48:52,319 --> 00:48:55,359
let's take a look

00:49:00,880 --> 00:49:07,760
um okay so we have a question here about

00:49:05,359 --> 00:49:09,359
should common directives be duplicated

00:49:07,760 --> 00:49:11,760
across all services

00:49:09,359 --> 00:49:13,760
or can they be referenced with something

00:49:11,760 --> 00:49:16,079
like add external

00:49:13,760 --> 00:49:17,359
um so add external isn't going to come

00:49:16,079 --> 00:49:20,800
into play here

00:49:17,359 --> 00:49:22,160
for custom directives and

00:49:20,800 --> 00:49:24,640
for custom directives again you're going

00:49:22,160 --> 00:49:27,920
to want to consider the two potential

00:49:24,640 --> 00:49:30,240
use cases for custom directives which is

00:49:27,920 --> 00:49:31,920
um uh whether or not you want to

00:49:30,240 --> 00:49:33,119
implement a type system directive or

00:49:31,920 --> 00:49:34,960
schema directive

00:49:33,119 --> 00:49:37,680
or if you want to implement an

00:49:34,960 --> 00:49:40,960
executable slash query directive

00:49:37,680 --> 00:49:43,359
so for the type system directives

00:49:40,960 --> 00:49:44,400
i mean you can duplicate them across

00:49:43,359 --> 00:49:46,240
your services

00:49:44,400 --> 00:49:47,760
as much as you need to use them within a

00:49:46,240 --> 00:49:50,319
specific subgraph

00:49:47,760 --> 00:49:51,920
services schema and there's no need to

00:49:50,319 --> 00:49:54,240
duplicate those

00:49:51,920 --> 00:49:56,960
for a subgraph schema where it doesn't

00:49:54,240 --> 00:49:58,559
actually need to be used

00:49:56,960 --> 00:49:59,920
query directives or executable

00:49:58,559 --> 00:50:01,920
directives on the other hand are

00:49:59,920 --> 00:50:03,920
something that you will need to

00:50:01,920 --> 00:50:05,599
implement consistently across all of

00:50:03,920 --> 00:50:09,280
your different services

00:50:05,599 --> 00:50:09,920
so um yeah i definitely encourage you to

00:50:09,280 --> 00:50:11,599
take a look

00:50:09,920 --> 00:50:13,440
at the apollo federation of apollo

00:50:11,599 --> 00:50:15,200
gateway docks for specific directions

00:50:13,440 --> 00:50:16,000
around this but again with executable

00:50:15,200 --> 00:50:17,440
directives

00:50:16,000 --> 00:50:19,760
um these are things that are going to

00:50:17,440 --> 00:50:21,520
need to be uh implemented consistently

00:50:19,760 --> 00:50:26,079
across all subgraphs so in that case

00:50:21,520 --> 00:50:29,520
that's that's a requirement

00:50:26,079 --> 00:50:29,520
um let's see

00:50:32,960 --> 00:50:40,079
all right so we have a question here

00:50:37,040 --> 00:50:42,559
that is uh what is the best practice

00:50:40,079 --> 00:50:44,800
for when you need to communicate between

00:50:42,559 --> 00:50:47,280
two federated services

00:50:44,800 --> 00:50:48,640
for instance service one is dependent on

00:50:47,280 --> 00:50:51,760
service two

00:50:48,640 --> 00:50:55,200
do we query service two by federation

00:50:51,760 --> 00:50:57,040
or directly to the service um

00:50:55,200 --> 00:50:58,800
so we are in the middle of refactoring a

00:50:57,040 --> 00:51:00,640
monolith into federated schemas however

00:50:58,800 --> 00:51:02,559
we still have dependencies between these

00:51:00,640 --> 00:51:05,920
services so

00:51:02,559 --> 00:51:07,599
um definitely

00:51:05,920 --> 00:51:09,280
uh some additional context i think would

00:51:07,599 --> 00:51:11,599
help focus the answer to this

00:51:09,280 --> 00:51:13,680
question but i think i can answer it in

00:51:11,599 --> 00:51:17,200
two generalized ways so

00:51:13,680 --> 00:51:21,119
uh the first is um i think it would

00:51:17,200 --> 00:51:23,280
depend on the nature of uh

00:51:21,119 --> 00:51:24,960
what you're querying so query planning

00:51:23,280 --> 00:51:27,520
with federation can definitely help

00:51:24,960 --> 00:51:29,119
coordinate uh

00:51:27,520 --> 00:51:30,720
taking different responses from your

00:51:29,119 --> 00:51:32,559
different subgraph services

00:51:30,720 --> 00:51:34,240
and then of course aggregating those uh

00:51:32,559 --> 00:51:35,280
back together at the gateway level and

00:51:34,240 --> 00:51:37,520
then sending them

00:51:35,280 --> 00:51:39,359
uh back to the client that requested

00:51:37,520 --> 00:51:40,640
that data as a cohesive response so in

00:51:39,359 --> 00:51:44,079
those instances

00:51:40,640 --> 00:51:45,119
there's no need for uh needing to do any

00:51:44,079 --> 00:51:47,200
kind of manual

00:51:45,119 --> 00:51:48,640
querying of your multiple services and

00:51:47,200 --> 00:51:50,559
then um

00:51:48,640 --> 00:51:52,559
putting those pieces back together to

00:51:50,559 --> 00:51:55,200
send back to your client

00:51:52,559 --> 00:51:56,480
um another direction that you could

00:51:55,200 --> 00:51:57,839
potentially interpret this question i

00:51:56,480 --> 00:52:00,480
think is

00:51:57,839 --> 00:52:01,760
um when you're handling something kind

00:52:00,480 --> 00:52:03,200
of like along the lines of like a

00:52:01,760 --> 00:52:06,319
distributed transaction

00:52:03,200 --> 00:52:07,040
so where something happens in one

00:52:06,319 --> 00:52:08,640
service

00:52:07,040 --> 00:52:10,240
and then in response to that thing

00:52:08,640 --> 00:52:10,800
happening you need something else to

00:52:10,240 --> 00:52:13,839
happen

00:52:10,800 --> 00:52:15,359
in some other service so here i would

00:52:13,839 --> 00:52:18,480
say

00:52:15,359 --> 00:52:20,800
the same same rules apply as

00:52:18,480 --> 00:52:22,000
uh you typically would for any tip as

00:52:20,800 --> 00:52:24,240
you would typically apply for any

00:52:22,000 --> 00:52:27,359
microservice architecture

00:52:24,240 --> 00:52:29,760
so in those instances you need to

00:52:27,359 --> 00:52:30,640
make a decision i've seen this go both

00:52:29,760 --> 00:52:33,760
ways where

00:52:30,640 --> 00:52:36,960
i have i have seen um one service

00:52:33,760 --> 00:52:39,359
actually uh using a graphql client to

00:52:36,960 --> 00:52:40,079
run a mutation against another service

00:52:39,359 --> 00:52:42,160
uh

00:52:40,079 --> 00:52:43,440
and doing this like more or less on a

00:52:42,160 --> 00:52:44,800
one-off basis like

00:52:43,440 --> 00:52:46,160
if this is something that becomes like a

00:52:44,800 --> 00:52:47,359
common pattern within your graph i think

00:52:46,160 --> 00:52:49,040
you're going to want to explore other

00:52:47,359 --> 00:52:51,359
architectural options and

00:52:49,040 --> 00:52:52,160
that other architectural option that i

00:52:51,359 --> 00:52:54,160
often see

00:52:52,160 --> 00:52:56,079
is that you end up embracing more of an

00:52:54,160 --> 00:52:56,960
event-driven architecture and you look

00:52:56,079 --> 00:52:59,200
at using

00:52:56,960 --> 00:53:00,800
sega's to coordinate communication

00:52:59,200 --> 00:53:02,079
between your different services and

00:53:00,800 --> 00:53:03,680
rather than pulling that down to the

00:53:02,079 --> 00:53:05,359
graphql level that's something you left

00:53:03,680 --> 00:53:07,119
out a little bit higher and you use some

00:53:05,359 --> 00:53:08,079
kind of event-driven system to help

00:53:07,119 --> 00:53:10,079
support

00:53:08,079 --> 00:53:11,119
that kind of inter-service communication

00:53:10,079 --> 00:53:12,559
so again

00:53:11,119 --> 00:53:14,000
the same rules that you would typically

00:53:12,559 --> 00:53:15,280
apply to any kind of microservice

00:53:14,000 --> 00:53:16,880
architecture in relation to

00:53:15,280 --> 00:53:18,240
inter-service communication are

00:53:16,880 --> 00:53:21,760
almost certainly going to apply when

00:53:18,240 --> 00:53:21,760
you're dealing with federation as well

00:53:23,119 --> 00:53:29,839
okay so we have a question

00:53:27,359 --> 00:53:32,160
here does apollo studio work with

00:53:29,839 --> 00:53:33,839
non-managed federation and

00:53:32,160 --> 00:53:35,040
to answer that question i think it's

00:53:33,839 --> 00:53:36,800
going to depend what exactly you want to

00:53:35,040 --> 00:53:38,559
do with apollo studios so if you want to

00:53:36,800 --> 00:53:42,000
use the schema registry

00:53:38,559 --> 00:53:43,520
and the tracing uh features that are

00:53:42,000 --> 00:53:45,760
built into apollo studio

00:53:43,520 --> 00:53:47,119
you're uh definitely going to be using

00:53:45,760 --> 00:53:48,640
managed federation for that because

00:53:47,119 --> 00:53:50,640
you're going to be registering your

00:53:48,640 --> 00:53:52,240
schema with apollo studio that's

00:53:50,640 --> 00:53:54,000
part of what the managed portion of

00:53:52,240 --> 00:53:57,200
manage federation is

00:53:54,000 --> 00:53:58,480
um but if you want to use features of

00:53:57,200 --> 00:54:00,960
apollo studio

00:53:58,480 --> 00:54:01,920
such as the apollo studio explorer um as

00:54:00,960 --> 00:54:04,079
an alternative to

00:54:01,920 --> 00:54:05,359
using other graphql gui such as uh

00:54:04,079 --> 00:54:08,160
graphical playground

00:54:05,359 --> 00:54:08,880
then you don't need to use managed

00:54:08,160 --> 00:54:11,359
federation

00:54:08,880 --> 00:54:11,920
for that you can very easily hook that

00:54:11,359 --> 00:54:13,520
up to

00:54:11,920 --> 00:54:15,520
uh to a data graph that's running in

00:54:13,520 --> 00:54:17,359
your local development environment

00:54:15,520 --> 00:54:20,960
and use that feature as a development

00:54:17,359 --> 00:54:20,960
graph rather than a deployed graph

00:54:22,839 --> 00:54:31,040
um okay

00:54:26,480 --> 00:54:32,960
so we have tons of questions here uh we

00:54:31,040 --> 00:54:35,920
only have a few minutes left

00:54:32,960 --> 00:54:37,760
um i'm gonna do my best to get through

00:54:35,920 --> 00:54:38,000
as many as possible in the few minutes

00:54:37,760 --> 00:54:40,640
that

00:54:38,000 --> 00:54:43,400
we have remaining and then again i

00:54:40,640 --> 00:54:44,640
definitely encourage you to head over to

00:54:43,400 --> 00:54:46,319
community.apollographql.com

00:54:44,640 --> 00:54:48,079
where you can post any other additional

00:54:46,319 --> 00:54:52,160
questions that you may have

00:54:48,079 --> 00:54:54,000
um so

00:54:52,160 --> 00:54:56,240
we have a question here in the earlier

00:54:54,000 --> 00:54:58,160
example how is product data resolved

00:54:56,240 --> 00:55:00,480
under the review entity

00:54:58,160 --> 00:55:02,480
so is the resolver implemented in the

00:55:00,480 --> 00:55:04,799
review subgraph or the product subgraph

00:55:02,480 --> 00:55:05,680
and the answer to that question uh is

00:55:04,799 --> 00:55:09,680
both

00:55:05,680 --> 00:55:12,480
so um in the context of

00:55:09,680 --> 00:55:13,200
your uh your review service it needs to

00:55:12,480 --> 00:55:14,799
know

00:55:13,200 --> 00:55:16,400
it needs to be able to return something

00:55:14,799 --> 00:55:19,119
from product resolver

00:55:16,400 --> 00:55:20,880
and that product resolver is really it's

00:55:19,119 --> 00:55:24,000
just going to be a representation

00:55:20,880 --> 00:55:26,079
of that entity so it'll be the type name

00:55:24,000 --> 00:55:28,079
and then the corresponding uh type name

00:55:26,079 --> 00:55:30,720
product in this case is the value

00:55:28,079 --> 00:55:32,160
and it's also any key data that you need

00:55:30,720 --> 00:55:33,760
to include so in the product example

00:55:32,160 --> 00:55:35,359
you'd include the upc field which

00:55:33,760 --> 00:55:38,160
presumably the review service has

00:55:35,359 --> 00:55:39,680
access to as well as that value and that

00:55:38,160 --> 00:55:40,880
is what you'll ultimately return in that

00:55:39,680 --> 00:55:42,480
resolver

00:55:40,880 --> 00:55:43,920
send that data to the gateway and then

00:55:42,480 --> 00:55:46,640
the gateway is going to handle

00:55:43,920 --> 00:55:48,240
um actually resolving the full products

00:55:46,640 --> 00:55:50,799
as needed for that query

00:55:48,240 --> 00:55:52,559
it's going to be on the products service

00:55:50,799 --> 00:55:54,559
to fill in all the additional details

00:55:52,559 --> 00:55:55,920
that may be needed for a given product

00:55:54,559 --> 00:55:57,200
to resolve that query

00:55:55,920 --> 00:55:59,920
and to do that you're going to use

00:55:57,200 --> 00:56:02,880
what's known as a reference resolver

00:55:59,920 --> 00:56:04,559
so that's how the pieces work at a high

00:56:02,880 --> 00:56:06,559
level i definitely encourage you to take

00:56:04,559 --> 00:56:09,040
a look at the apollo federation docs

00:56:06,559 --> 00:56:11,040
for more information on exactly how all

00:56:09,040 --> 00:56:12,400
those different pieces fit together

00:56:11,040 --> 00:56:15,359
but at the end of the day you're just

00:56:12,400 --> 00:56:18,240
writing a couple basic resolvers in the

00:56:15,359 --> 00:56:18,720
reviews service and the product service

00:56:18,240 --> 00:56:19,599
um

00:56:18,720 --> 00:56:20,720
and you just want to make sure that

00:56:19,599 --> 00:56:22,640
you're implementing that reference

00:56:20,720 --> 00:56:24,559
resolver and the product service to

00:56:22,640 --> 00:56:26,640
resolve any entities queries that are

00:56:24,559 --> 00:56:30,240
sent its way

00:56:26,640 --> 00:56:32,400
um okay

00:56:30,240 --> 00:56:32,400
see

00:56:33,280 --> 00:56:35,599
um

00:56:40,400 --> 00:56:44,880
what other question can we cover off

00:56:42,799 --> 00:56:45,200
before we wrap up i think we've got time

00:56:44,880 --> 00:56:49,200
for

00:56:45,200 --> 00:56:52,319
one more um

00:56:49,200 --> 00:56:55,440
so uh here's a really good one are the

00:56:52,319 --> 00:56:57,520
at key and at external uh specific

00:56:55,440 --> 00:56:58,400
directives from apollo or is it part of

00:56:57,520 --> 00:57:00,960
the specs

00:56:58,400 --> 00:57:02,559
so in case apollo federation is

00:57:00,960 --> 00:57:03,440
non-standard how are you planning

00:57:02,559 --> 00:57:04,960
coverage

00:57:03,440 --> 00:57:06,559
uh how are you planning to converge with

00:57:04,960 --> 00:57:08,960
the graphql working group

00:57:06,559 --> 00:57:10,160
so this is a really great question um

00:57:08,960 --> 00:57:12,559
because when you're looking at

00:57:10,160 --> 00:57:14,960
implementing apollo federation

00:57:12,559 --> 00:57:16,400
um and you have your subgraph scheme and

00:57:14,960 --> 00:57:18,559
we saw snippets of what a subthe graph

00:57:16,400 --> 00:57:20,640
schema may look like with the at key and

00:57:18,559 --> 00:57:21,839
add external directives added to it

00:57:20,640 --> 00:57:24,079
you'll obviously you're going to need

00:57:21,839 --> 00:57:26,000
definitions of those directives

00:57:24,079 --> 00:57:28,079
somewhere in your schema so if you're

00:57:26,000 --> 00:57:31,200
using apollo server as your sub

00:57:28,079 --> 00:57:31,839
graph uh the uh the apollo federation

00:57:31,200 --> 00:57:33,760
library

00:57:31,839 --> 00:57:36,079
exposes a build federated schema

00:57:33,760 --> 00:57:38,480
function which you can use to wrap your

00:57:36,079 --> 00:57:40,480
type defs and your resolvers that you

00:57:38,480 --> 00:57:42,079
designed for that schema and that's

00:57:40,480 --> 00:57:43,839
automatically going to apply

00:57:42,079 --> 00:57:45,520
all of the federation specific

00:57:43,839 --> 00:57:46,400
decorations you need to add to your

00:57:45,520 --> 00:57:48,880
schema

00:57:46,400 --> 00:57:49,440
per the apollo federation spec which is

00:57:48,880 --> 00:57:52,559
listed

00:57:49,440 --> 00:57:56,480
in our documentation if you're

00:57:52,559 --> 00:57:59,280
not using apollo server as your

00:57:56,480 --> 00:58:01,359
as your subgraph graphql server that's

00:57:59,280 --> 00:58:04,400
fine because the federation spec is open

00:58:01,359 --> 00:58:06,720
so graphql servers can add support for

00:58:04,400 --> 00:58:09,280
apollo federation as well by

00:58:06,720 --> 00:58:11,200
implementing the apollo federation spec

00:58:09,280 --> 00:58:13,040
so basically that necessitates that if

00:58:11,200 --> 00:58:13,760
you want to use that alternative graphql

00:58:13,040 --> 00:58:16,160
server

00:58:13,760 --> 00:58:17,760
as your subgraph and have access to

00:58:16,160 --> 00:58:20,559
things such as entities

00:58:17,760 --> 00:58:22,400
um to interact with within that schema

00:58:20,559 --> 00:58:24,400
then that graphql server can

00:58:22,400 --> 00:58:26,160
implement that apollo federation spec by

00:58:24,400 --> 00:58:29,280
adding those necessary uh

00:58:26,160 --> 00:58:30,319
directives and uh there's uh some types

00:58:29,280 --> 00:58:32,559
that need to be added

00:58:30,319 --> 00:58:34,400
as well as a couple of uh fields on the

00:58:32,559 --> 00:58:37,359
root query type

00:58:34,400 --> 00:58:37,760
and that will give you support uh in in

00:58:37,359 --> 00:58:40,480
the

00:58:37,760 --> 00:58:41,280
uh the subgraph for it being composed

00:58:40,480 --> 00:58:44,160
into the

00:58:41,280 --> 00:58:45,440
uh broader federated data graph and also

00:58:44,160 --> 00:58:47,359
having support for

00:58:45,440 --> 00:58:49,440
uh responding to entity queries and

00:58:47,359 --> 00:58:52,480
things of that nature

00:58:49,440 --> 00:58:54,000
okay so there are still tons of

00:58:52,480 --> 00:58:55,920
questions in here i

00:58:54,000 --> 00:58:58,160
really appreciate everyone showing up

00:58:55,920 --> 00:59:00,079
for today's webinar and being so engaged

00:58:58,160 --> 00:59:00,720
and providing so many amazing questions

00:59:00,079 --> 00:59:02,240
for us

00:59:00,720 --> 00:59:03,359
i wish i could have had time to answer

00:59:02,240 --> 00:59:05,280
them all i think we could have spent a

00:59:03,359 --> 00:59:06,079
full two hours on just the questions

00:59:05,280 --> 00:59:08,559
alone

00:59:06,079 --> 00:59:10,240
um but as i mentioned the apollo forums

00:59:08,559 --> 00:59:11,359
are a great place to post these

00:59:10,240 --> 00:59:13,599
questions

00:59:11,359 --> 00:59:16,240
you can also find me on twitter at mandy

00:59:13,599 --> 00:59:17,280
wise and i'd be happy to engage there as

00:59:16,240 --> 00:59:19,040
well

00:59:17,280 --> 00:59:21,200
and again i'd just like to say thank you

00:59:19,040 --> 00:59:23,839
so much for joining us today for this

00:59:21,200 --> 00:59:24,640
webinar and uh you can look forward to

00:59:23,839 --> 00:59:27,599
receiving

00:59:24,640 --> 00:59:28,960
a copy of the recording in your inbox

00:59:27,599 --> 00:59:31,359
shortly

00:59:28,960 --> 00:59:33,839
so thank you so much everyone and have a

00:59:31,359 --> 00:59:33,839

YouTube URL: https://www.youtube.com/watch?v=xYb32CFsY8U


