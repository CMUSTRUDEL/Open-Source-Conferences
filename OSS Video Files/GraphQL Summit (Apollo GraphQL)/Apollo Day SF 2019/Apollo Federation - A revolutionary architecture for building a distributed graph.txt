Title: Apollo Federation - A revolutionary architecture for building a distributed graph
Publication date: 2019-06-11
Playlist: Apollo Day SF 2019
Description: 
	A hands-on Apollo Federation demo followed by a Q&A session led by James Baxley III, Engineering Manager at Apollo

Resources:

Checkout the Apollo docs - https://www.apollographql.com/docs/
Explore migrating from schema stitching to federation - https://www.apollographql.com/docs/federation/migrating-from-stitching/
Captions: 
	00:00:00,470 --> 00:00:04,910
so I'm James I also have a little bit of

00:00:03,470 --> 00:00:06,500
a space-themed here to my slides today

00:00:04,910 --> 00:00:09,259
because there Apollo it's kind of like

00:00:06,500 --> 00:00:10,730
part of our rules as a company there but

00:00:09,259 --> 00:00:13,489
yeah I I'm an engineering manager here

00:00:10,730 --> 00:00:16,309
at Apollo I lead our open source team

00:00:13,489 --> 00:00:18,200
and our solutions team which is a little

00:00:16,309 --> 00:00:20,120
bit of an odd combination for a lot of

00:00:18,200 --> 00:00:22,010
companies to have both your open source

00:00:20,120 --> 00:00:24,140
that you can have that directly with

00:00:22,010 --> 00:00:26,120
your solutions team and the solution

00:00:24,140 --> 00:00:28,100
team being the people who help customers

00:00:26,120 --> 00:00:30,560
in their adoption path of a given set of

00:00:28,100 --> 00:00:32,390
technology the reason I Apollo why those

00:00:30,560 --> 00:00:34,070
two things are together and why they're

00:00:32,390 --> 00:00:36,170
really even kind of the same team is

00:00:34,070 --> 00:00:38,149
because we want to work directly with

00:00:36,170 --> 00:00:40,280
customers to build the right underlying

00:00:38,149 --> 00:00:42,140
technology this isn't a situation where

00:00:40,280 --> 00:00:43,249
we build something in a lab and then

00:00:42,140 --> 00:00:44,960
send it to you and you give us feedback

00:00:43,249 --> 00:00:46,789
and then like it goes to this whole

00:00:44,960 --> 00:00:48,379
products like goal we want the engineers

00:00:46,789 --> 00:00:50,629
on our team that are writing the IND

00:00:48,379 --> 00:00:53,210
underlying API is that you use day in

00:00:50,629 --> 00:00:55,670
and day out in that awesome graphical

00:00:53,210 --> 00:00:56,870
developer experience to be very close to

00:00:55,670 --> 00:00:58,819
the two members who actually running

00:00:56,870 --> 00:01:00,260
into it day in and day out if it's a

00:00:58,819 --> 00:01:01,999
pain to do the kind of work that you

00:01:00,260 --> 00:01:03,920
need to do every day we want our

00:01:01,999 --> 00:01:05,780
engineering team to know that to be part

00:01:03,920 --> 00:01:08,210
of your team which is why we have them

00:01:05,780 --> 00:01:09,860
together so it gives me an amazing

00:01:08,210 --> 00:01:11,480
opportunity it's really been quite an

00:01:09,860 --> 00:01:13,400
incredible experience for me and for the

00:01:11,480 --> 00:01:15,830
teams people to work with customers like

00:01:13,400 --> 00:01:18,140
yourself having you here today it's just

00:01:15,830 --> 00:01:20,030
a further excitement thing for us we

00:01:18,140 --> 00:01:21,320
want to say like hey what do you think

00:01:20,030 --> 00:01:23,360
about this what do you thing about that

00:01:21,320 --> 00:01:25,670
is this a mess for you and to hear those

00:01:23,360 --> 00:01:28,040
kind of things so I have an hour with

00:01:25,670 --> 00:01:29,750
you today which is a lot of time to do a

00:01:28,040 --> 00:01:31,670
talk and what I really want to do is

00:01:29,750 --> 00:01:34,040
have this more of a conversation for you

00:01:31,670 --> 00:01:35,420
to ask questions to give feedback and

00:01:34,040 --> 00:01:37,340
really just to be like what's going on

00:01:35,420 --> 00:01:38,570
here because it's gonna help us to build

00:01:37,340 --> 00:01:42,200
the right things hopefully to find a

00:01:38,570 --> 00:01:43,760
good fair for what you need what I want

00:01:42,200 --> 00:01:45,110
to talk about the needs today is kind of

00:01:43,760 --> 00:01:45,740
that third step that Matt was talking

00:01:45,110 --> 00:01:47,420
about earlier

00:01:45,740 --> 00:01:49,100
so once craft kill has been going on

00:01:47,420 --> 00:01:50,720
really success that your company you

00:01:49,100 --> 00:01:52,430
started to be able to have some control

00:01:50,720 --> 00:01:54,290
over what's happening you feel confident

00:01:52,430 --> 00:01:56,270
in rolling it out you want to be able to

00:01:54,290 --> 00:01:58,370
give this to everybody you want to

00:01:56,270 --> 00:02:00,440
expand your orgs ability to add to the

00:01:58,370 --> 00:02:01,760
graph to make changes to it and if you

00:02:00,440 --> 00:02:04,520
really comfort about how you can scale

00:02:01,760 --> 00:02:06,170
your overall data graph usage like Matt

00:02:04,520 --> 00:02:07,940
was saying more and more clients just

00:02:06,170 --> 00:02:09,380
start picking it up because it's that

00:02:07,940 --> 00:02:11,300
great when you get the kind of tools

00:02:09,380 --> 00:02:12,970
that Danielle showed everybody's gonna

00:02:11,300 --> 00:02:14,290
want to get that

00:02:12,970 --> 00:02:16,810
how do you as the people who are

00:02:14,290 --> 00:02:20,200
providing the Stata graph actually scale

00:02:16,810 --> 00:02:22,240
that to five teams ten teams 100 teams

00:02:20,200 --> 00:02:23,710
across York when you have a hundred

00:02:22,240 --> 00:02:25,060
engineers working all together on the

00:02:23,710 --> 00:02:29,680
same data graph what does that actually

00:02:25,060 --> 00:02:30,880
look like so how many of you have

00:02:29,680 --> 00:02:33,280
actually seen the principle of graph QL

00:02:30,880 --> 00:02:35,500
website or heard about it great this is

00:02:33,280 --> 00:02:37,510
awesome okay so principle graph QL is

00:02:35,500 --> 00:02:40,690
something that our founders wrote as a

00:02:37,510 --> 00:02:42,970
way to be a road map for your successful

00:02:40,690 --> 00:02:45,250
adoption of a data graph you can think

00:02:42,970 --> 00:02:46,750
of as a road map for your adoption and a

00:02:45,250 --> 00:02:48,760
road map for the kind of tools that we

00:02:46,750 --> 00:02:50,890
want to be able to build you so that you

00:02:48,760 --> 00:02:51,820
can adopt this successfully so I don't

00:02:50,890 --> 00:02:54,430
go too much into this but it's

00:02:51,820 --> 00:02:56,200
definitely worth read but what I want to

00:02:54,430 --> 00:02:58,780
talk about today is kind of the first

00:02:56,200 --> 00:03:00,220
two principles so the first thing when

00:02:58,780 --> 00:03:02,410
you hit the site you get this idea of a

00:03:00,220 --> 00:03:03,880
1 graph which again Matt and Daniel were

00:03:02,410 --> 00:03:06,130
talking a little bit about but what does

00:03:03,880 --> 00:03:07,870
that really mean all right so the idea

00:03:06,130 --> 00:03:09,820
here is that one of the problems with

00:03:07,870 --> 00:03:11,260
rests is that it's procedural Matt

00:03:09,820 --> 00:03:13,660
showed that web of all these different

00:03:11,260 --> 00:03:15,160
systems connected together so it's

00:03:13,660 --> 00:03:17,080
really hard for client developers to

00:03:15,160 --> 00:03:18,610
know where they should get data from how

00:03:17,080 --> 00:03:20,410
they should really relate that to other

00:03:18,610 --> 00:03:22,690
services it's kinda like one of the core

00:03:20,410 --> 00:03:24,130
tenets of graph QL right so one of our

00:03:22,690 --> 00:03:26,200
core principles in fact our first

00:03:24,130 --> 00:03:28,720
primary principle that you should have

00:03:26,200 --> 00:03:29,920
one graph for your clients they should

00:03:28,720 --> 00:03:33,400
be able to think about your product in

00:03:29,920 --> 00:03:35,290
one cohesive form within the immediate

00:03:33,400 --> 00:03:36,760
next point is that you should federates

00:03:35,290 --> 00:03:38,830
at graph which is like what does that

00:03:36,760 --> 00:03:40,270
even mean first of all and second it

00:03:38,830 --> 00:03:41,530
feels like it's directly against the

00:03:40,270 --> 00:03:43,570
point of the first thing if I'm supposed

00:03:41,530 --> 00:03:45,100
to have one then you're telling me the

00:03:43,570 --> 00:03:46,750
next point I should have many of these

00:03:45,100 --> 00:03:48,970
things how do i reconcile that what does

00:03:46,750 --> 00:03:50,560
it actually look like so the idea with

00:03:48,970 --> 00:03:52,300
schema Federation and a federated

00:03:50,560 --> 00:03:53,739
implementation of graph is that even

00:03:52,300 --> 00:03:57,100
though there's only one graph for your

00:03:53,739 --> 00:03:58,660
consumers your people building the iOS

00:03:57,100 --> 00:04:01,180
app and the Android app and the web apps

00:03:58,660 --> 00:04:03,190
the actual implementation how that craft

00:04:01,180 --> 00:04:05,650
gets formed should be split across the

00:04:03,190 --> 00:04:09,250
teams that have the domain expertise the

00:04:05,650 --> 00:04:11,800
technology and the experience to build

00:04:09,250 --> 00:04:14,560
the right kind of services to supply

00:04:11,800 --> 00:04:17,769
that overall graph so we'll actually get

00:04:14,560 --> 00:04:18,820
into what this actually means and Matt

00:04:17,769 --> 00:04:20,080
mentioned I'm going to be going over a

00:04:18,820 --> 00:04:22,270
Polly Federation which is something that

00:04:20,080 --> 00:04:23,350
we're open sourcing next week so stay

00:04:22,270 --> 00:04:25,690
tuned for that outside we go

00:04:23,350 --> 00:04:29,140
to give you a sneak peek about today so

00:04:25,690 --> 00:04:31,110
Apollo Federation is a an architecture

00:04:29,140 --> 00:04:33,670
for implementing a distributed graph

00:04:31,110 --> 00:04:36,040
there's two parts of that one is that

00:04:33,670 --> 00:04:38,590
you have microservices that are what we

00:04:36,040 --> 00:04:40,720
call a federated service and these are

00:04:38,590 --> 00:04:42,970
partial sub schemas they're independent

00:04:40,720 --> 00:04:45,250
services that form a bit of the overall

00:04:42,970 --> 00:04:47,530
graph that may be a review service or a

00:04:45,250 --> 00:04:49,030
user service or even like an inventory

00:04:47,530 --> 00:04:50,890
service that really only does one thing

00:04:49,030 --> 00:04:54,430
but it does it really well and it can

00:04:50,890 --> 00:04:56,770
scale really well and then you have a

00:04:54,430 --> 00:04:58,510
gateway a way to plug all these sub

00:04:56,770 --> 00:05:02,200
schemas and all these parts together

00:04:58,510 --> 00:05:04,660
into that single one graph so Federation

00:05:02,200 --> 00:05:06,580
is the micro services that federated

00:05:04,660 --> 00:05:08,650
services and then the one graph gets

00:05:06,580 --> 00:05:11,320
composed all from this idea of a single

00:05:08,650 --> 00:05:12,670
gateway so architectural II your clients

00:05:11,320 --> 00:05:15,550
still hit one end point they still hit

00:05:12,670 --> 00:05:17,950
one API they still hit one graph and

00:05:15,550 --> 00:05:20,680
then that work is split apart and is

00:05:17,950 --> 00:05:21,790
transitioned into those sub services I'm

00:05:20,680 --> 00:05:25,720
not going to show you what that looks

00:05:21,790 --> 00:05:27,190
like today so we're gonna build one

00:05:25,720 --> 00:05:28,990
graph so I thought it could be helpful

00:05:27,190 --> 00:05:30,700
as we walk through this especially as we

00:05:28,990 --> 00:05:32,860
could get into questions to have a

00:05:30,700 --> 00:05:36,330
single kind of pretty simplistic graph

00:05:32,860 --> 00:05:38,650
to talk through so we got three types

00:05:36,330 --> 00:05:41,320
really simple pretty easy to understand

00:05:38,650 --> 00:05:43,960
here we have a user type you have a

00:05:41,320 --> 00:05:45,100
product type and we have reviews alright

00:05:43,960 --> 00:05:49,630
this could be any product out there

00:05:45,100 --> 00:05:52,270
right users have reviews reviews have an

00:05:49,630 --> 00:05:54,040
author products have reviews and a

00:05:52,270 --> 00:05:56,050
review is about a product right so this

00:05:54,040 --> 00:05:57,940
is actual graph this isn't like a

00:05:56,050 --> 00:05:59,680
point-to-point kind of procedural kind

00:05:57,940 --> 00:06:02,520
of situation we've built out a data

00:05:59,680 --> 00:06:05,110
graph where does all this data come from

00:06:02,520 --> 00:06:07,780
so you may have existing rest services

00:06:05,110 --> 00:06:09,340
you may have third-party systems or

00:06:07,780 --> 00:06:11,560
things that we are really passionate

00:06:09,340 --> 00:06:13,990
about here at Apollo is that all of this

00:06:11,560 --> 00:06:16,840
work needs to be incremental you really

00:06:13,990 --> 00:06:18,190
can't take a stop everything and rebuild

00:06:16,840 --> 00:06:19,900
everything in the new technology every

00:06:18,190 --> 00:06:21,310
time it comes out but more than that is

00:06:19,900 --> 00:06:23,500
you need to keep iterating on what you

00:06:21,310 --> 00:06:24,940
currently have for your customers right

00:06:23,500 --> 00:06:27,370
like you said earlier the customers most

00:06:24,940 --> 00:06:29,500
important thing here so in this graph

00:06:27,370 --> 00:06:30,790
I'm getting data from at least four

00:06:29,500 --> 00:06:31,470
different services probably more than

00:06:30,790 --> 00:06:34,410
that

00:06:31,470 --> 00:06:36,690
I have my account system I have my

00:06:34,410 --> 00:06:38,610
reviews database my review service I

00:06:36,690 --> 00:06:40,170
have some products this may even be

00:06:38,610 --> 00:06:42,210
third party right this could be Amazon's

00:06:40,170 --> 00:06:44,970
API that I'm building something on top

00:06:42,210 --> 00:06:47,010
of and I may have an inventory service

00:06:44,970 --> 00:06:48,780
and this could take information from the

00:06:47,010 --> 00:06:50,820
product service and give me back like is

00:06:48,780 --> 00:06:54,110
this in stock which could be some wholly

00:06:50,820 --> 00:06:56,700
other system it could be an on-prem like

00:06:54,110 --> 00:06:58,140
accounting system that is a pain to deal

00:06:56,700 --> 00:06:59,700
with and pain to get in but that's

00:06:58,140 --> 00:07:00,990
actually what my product needs that's

00:06:59,700 --> 00:07:05,880
the graph that I want to be able to

00:07:00,990 --> 00:07:08,370
shape and use with my company so one way

00:07:05,880 --> 00:07:11,640
to think about this is well I have my

00:07:08,370 --> 00:07:13,110
user have a product and I have a review

00:07:11,640 --> 00:07:14,430
and those are kind of like the

00:07:13,110 --> 00:07:17,430
distinction point so this is how I want

00:07:14,430 --> 00:07:19,560
to break apart all of my work I have a

00:07:17,430 --> 00:07:22,320
team that like adds things users and

00:07:19,560 --> 00:07:23,760
products and reviews and this is how a

00:07:22,320 --> 00:07:25,620
lot of people start touch if they start

00:07:23,760 --> 00:07:27,000
very early and kind of that first screen

00:07:25,620 --> 00:07:29,430
is you build everything out kind of all

00:07:27,000 --> 00:07:31,020
together like this but if you start to

00:07:29,430 --> 00:07:32,790
grow and your schema grows and grows and

00:07:31,020 --> 00:07:34,230
grows it gets a lot harder to manage

00:07:32,790 --> 00:07:36,480
that because that's not actually how

00:07:34,230 --> 00:07:38,730
those services work that's not how that

00:07:36,480 --> 00:07:40,890
data is stored it's not how your your

00:07:38,730 --> 00:07:43,169
domain expertise is built within your

00:07:40,890 --> 00:07:45,210
company or realistically is you have

00:07:43,169 --> 00:07:46,710
someone who's responsible for access

00:07:45,210 --> 00:07:49,080
control and accounts right like an

00:07:46,710 --> 00:07:51,000
active service then you have someone or

00:07:49,080 --> 00:07:52,950
a team that is responsible for the

00:07:51,000 --> 00:07:54,750
actual main products and this has again

00:07:52,950 --> 00:07:55,860
its own they may be in a different

00:07:54,750 --> 00:07:57,240
language may have its own different

00:07:55,860 --> 00:08:00,840
database because it is optimized for

00:07:57,240 --> 00:08:02,340
quite a lot of just raw information and

00:08:00,840 --> 00:08:05,340
then you have a review service and this

00:08:02,340 --> 00:08:06,750
could be tied into other third-party

00:08:05,340 --> 00:08:09,540
review services it could connect to a

00:08:06,750 --> 00:08:11,250
whole web of other different systems but

00:08:09,540 --> 00:08:13,350
fundamentally reviews are kind of still

00:08:11,250 --> 00:08:15,270
their own thing it's just that they also

00:08:13,350 --> 00:08:17,760
relate to other parts of the graph they

00:08:15,270 --> 00:08:19,860
extend a concept of a user and of a

00:08:17,760 --> 00:08:22,080
product so when you start to split apart

00:08:19,860 --> 00:08:23,250
your services and even if you do this in

00:08:22,080 --> 00:08:25,440
the beginning with things like skin

00:08:23,250 --> 00:08:27,510
modules and Apollo server you want to be

00:08:25,440 --> 00:08:30,270
able to group not by type which isn't

00:08:27,510 --> 00:08:31,860
really the right boundary for teams you

00:08:30,270 --> 00:08:33,630
wanna be able to group by the domain

00:08:31,860 --> 00:08:38,760
expertise the separation concerns around

00:08:33,630 --> 00:08:40,140
what you're actually doing as a team and

00:08:38,760 --> 00:08:41,310
we actually tried this before who in

00:08:40,140 --> 00:08:42,370
here has that experience with schema

00:08:41,310 --> 00:08:44,410
stitching

00:08:42,370 --> 00:08:47,320
who in here has enjoyed their experience

00:08:44,410 --> 00:08:48,100
two schemes touching one or two hands

00:08:47,320 --> 00:08:52,810
all right that's more than we normally

00:08:48,100 --> 00:08:55,300
get so schema stitching was really kind

00:08:52,810 --> 00:08:56,980
of a hackathon kind of crazy idea that

00:08:55,300 --> 00:08:58,210
we put together at Apollo because we

00:08:56,980 --> 00:09:00,490
found a lot of teams running into this

00:08:58,210 --> 00:09:03,700
issue so we put this out there but as

00:09:00,490 --> 00:09:04,840
open-source goes up thank you I'll be

00:09:03,700 --> 00:09:06,130
great actually

00:09:04,840 --> 00:09:13,450
I have an hour's so the water would be

00:09:06,130 --> 00:09:15,010
great great in New York I kept putting

00:09:13,450 --> 00:09:16,300
my hand in my pocket as a nervous tic

00:09:15,010 --> 00:09:17,860
and I wouldn't move the mic every time

00:09:16,300 --> 00:09:19,930
so I'm trying not to do that today we'll

00:09:17,860 --> 00:09:21,160
see if I can make it yeah so we had

00:09:19,930 --> 00:09:22,540
schema stitching it was this crazy idea

00:09:21,160 --> 00:09:24,790
that we put out but as open source

00:09:22,540 --> 00:09:26,920
happens and Matt showed that like growth

00:09:24,790 --> 00:09:27,760
trend for open source everyone took this

00:09:26,920 --> 00:09:29,310
is something they should put into

00:09:27,760 --> 00:09:32,950
production right away and we were like

00:09:29,310 --> 00:09:35,260
okay this is great we will do our best

00:09:32,950 --> 00:09:36,550
to support this so we started talking

00:09:35,260 --> 00:09:38,440
with teams like what's working what's

00:09:36,550 --> 00:09:39,760
not working we heard the same issues

00:09:38,440 --> 00:09:42,460
over and over again

00:09:39,760 --> 00:09:44,620
this was a start in the right separation

00:09:42,460 --> 00:09:46,390
concerns but it was really brittle I had

00:09:44,620 --> 00:09:49,060
to make changes to my individual service

00:09:46,390 --> 00:09:51,820
and also to a gateway I had to have this

00:09:49,060 --> 00:09:53,680
like parts of my graph that I'd actually

00:09:51,820 --> 00:09:55,360
don't want people to use like I don't

00:09:53,680 --> 00:09:56,920
want in clients trying to get an author

00:09:55,360 --> 00:09:58,510
ID that's really just something I want

00:09:56,920 --> 00:10:00,400
to use to fetch an author for another

00:09:58,510 --> 00:10:01,990
service so every time I want to make a

00:10:00,400 --> 00:10:03,880
change to the graph of schema searching

00:10:01,990 --> 00:10:05,620
I've got to touch multiple places I've

00:10:03,880 --> 00:10:08,800
got to write these resolvers and there's

00:10:05,620 --> 00:10:10,360
just a lot of just gross code that gets

00:10:08,800 --> 00:10:12,640
really brittle and kind of hard to

00:10:10,360 --> 00:10:14,350
iterate on so ultimately even though I

00:10:12,640 --> 00:10:15,790
have a federated graph I'm losing all

00:10:14,350 --> 00:10:17,680
the benefits around the productivity

00:10:15,790 --> 00:10:19,360
that Kraft kale can bring my client team

00:10:17,680 --> 00:10:20,290
is happy but I can't keep up with them

00:10:19,360 --> 00:10:21,430
anymore because we're trying to

00:10:20,290 --> 00:10:23,950
coordinate between all these different

00:10:21,430 --> 00:10:28,060
teams what's actually happening to our

00:10:23,950 --> 00:10:29,620
overall graph so we took a step back and

00:10:28,060 --> 00:10:31,300
we started to reach out to customers and

00:10:29,620 --> 00:10:33,610
say like what what ultimately do you

00:10:31,300 --> 00:10:35,170
really want and again this is where the

00:10:33,610 --> 00:10:37,420
benefit of us working with people like

00:10:35,170 --> 00:10:38,770
you and you giving us feedback is we can

00:10:37,420 --> 00:10:40,570
hopefully ultimately come to a better

00:10:38,770 --> 00:10:43,060
solution for all of us something that

00:10:40,570 --> 00:10:45,070
makes the developer experience great

00:10:43,060 --> 00:10:47,530
allows you to build really incredible

00:10:45,070 --> 00:10:50,620
products and what we've come up with is

00:10:47,530 --> 00:10:53,050
this idea of a schema Federation so

00:10:50,620 --> 00:10:54,310
instead of trying to work services

00:10:53,050 --> 00:10:56,270
together what you really want to be able

00:10:54,310 --> 00:10:58,790
to do is as a service owner

00:10:56,270 --> 00:11:00,680
I want to be able to compose an overall

00:10:58,790 --> 00:11:03,110
change to the graph I don't have

00:11:00,680 --> 00:11:05,420
complete autonomy and how I can add

00:11:03,110 --> 00:11:07,100
things I can add features to client if I

00:11:05,420 --> 00:11:08,990
get a request from the iOS team I want

00:11:07,100 --> 00:11:10,820
to be able to add in reviews without

00:11:08,990 --> 00:11:12,709
having to talk to three other teams and

00:11:10,820 --> 00:11:13,730
redeploy my gateway and who knows if

00:11:12,709 --> 00:11:15,740
it's gonna break because I don't know if

00:11:13,730 --> 00:11:17,290
I got that code right some other service

00:11:15,740 --> 00:11:19,190
change during all this kind of happen

00:11:17,290 --> 00:11:22,070
ultimately you wanna be able to make a

00:11:19,190 --> 00:11:23,690
single composed change and I'm gonna a

00:11:22,070 --> 00:11:25,850
couple demos here I'll walk through what

00:11:23,690 --> 00:11:27,140
is actually happening here but the core

00:11:25,850 --> 00:11:30,410
concept is that each service kind of

00:11:27,140 --> 00:11:32,510
owns what they want to be able to do so

00:11:30,410 --> 00:11:34,070
it's pretty easy to start with let's say

00:11:32,510 --> 00:11:37,100
that I start with a service that has a

00:11:34,070 --> 00:11:39,050
user type there's a way to get access to

00:11:37,100 --> 00:11:40,910
that from a root field called me my

00:11:39,050 --> 00:11:41,839
pretty common pattern used to relay or

00:11:40,910 --> 00:11:44,839
some like that it may be called viewer

00:11:41,839 --> 00:11:46,610
the idea is that with a single addition

00:11:44,839 --> 00:11:50,000
with a directive that we call a key

00:11:46,610 --> 00:11:52,910
directive I can start to expose the user

00:11:50,000 --> 00:11:54,860
to other services in the graph so now my

00:11:52,910 --> 00:11:56,779
review service can do things with that

00:11:54,860 --> 00:11:58,790
user and again I'll show you what this

00:11:56,779 --> 00:12:01,190
actually looks like but the core thing

00:11:58,790 --> 00:12:03,260
here is that an individual service can

00:12:01,190 --> 00:12:05,180
change the fundamental makeup of the

00:12:03,260 --> 00:12:06,890
graph with as simple as a one-line code

00:12:05,180 --> 00:12:11,240
change and it's really really powerful

00:12:06,890 --> 00:12:13,490
when you do that so looking back at that

00:12:11,240 --> 00:12:16,670
overall original schema from a couple

00:12:13,490 --> 00:12:18,110
slides ago those three types the actual

00:12:16,670 --> 00:12:19,430
break down into services probably looks

00:12:18,110 --> 00:12:21,079
something a little bit like this if

00:12:19,430 --> 00:12:22,610
you're trying to build out that kind of

00:12:21,079 --> 00:12:25,220
responsibility at service-oriented

00:12:22,610 --> 00:12:27,620
architecture you have a product team

00:12:25,220 --> 00:12:29,930
they own the information all the

00:12:27,620 --> 00:12:31,940
products the price of it and then a

00:12:29,930 --> 00:12:33,380
user's recent purchases because they

00:12:31,940 --> 00:12:36,320
keep that relationship it's not foreign

00:12:33,380 --> 00:12:37,910
key to users an inventory service which

00:12:36,320 --> 00:12:39,709
is a third party service where I can

00:12:37,910 --> 00:12:40,850
take information about the product and

00:12:39,709 --> 00:12:41,959
determine if it's in stock or not

00:12:40,850 --> 00:12:45,079
because I don't actually own all that

00:12:41,959 --> 00:12:46,490
that's a whole mess of old code I have

00:12:45,079 --> 00:12:48,860
an account service which again does my

00:12:46,490 --> 00:12:50,420
user and then I have a review service so

00:12:48,860 --> 00:12:52,490
you can see that in practice those three

00:12:50,420 --> 00:12:54,230
types have a lot more people touching

00:12:52,490 --> 00:12:56,209
them than you think with you were just

00:12:54,230 --> 00:12:57,560
looking at the individual types so you

00:12:56,209 --> 00:12:59,899
really need to be able to have ownership

00:12:57,560 --> 00:13:04,279
by the individual teams to have that

00:12:59,899 --> 00:13:04,850
domain information so given a schema

00:13:04,279 --> 00:13:06,860
like that

00:13:04,850 --> 00:13:08,360
what should you actually do there right

00:13:06,860 --> 00:13:10,010
you wouldn't usually be able to use the

00:13:08,360 --> 00:13:11,600
schema clients in the old

00:13:10,010 --> 00:13:13,550
ask for what they want without having to

00:13:11,600 --> 00:13:15,020
figure out how things are laying they

00:13:13,550 --> 00:13:18,140
don't have to ask for author ID your

00:13:15,020 --> 00:13:20,510
product ID the client says I want to get

00:13:18,140 --> 00:13:22,070
a myself who's logged in my user name

00:13:20,510 --> 00:13:23,930
and any reviews that I wrote because

00:13:22,070 --> 00:13:25,700
that's what my app needs to build a

00:13:23,930 --> 00:13:27,710
great user experience so I wanna be able

00:13:25,700 --> 00:13:29,180
to write the query here on the left but

00:13:27,710 --> 00:13:30,980
because the way that my services are

00:13:29,180 --> 00:13:33,440
separated the way that I've composed the

00:13:30,980 --> 00:13:35,240
schema because of the expertise of those

00:13:33,440 --> 00:13:36,860
teams what I actually want to be able to

00:13:35,240 --> 00:13:39,350
do is first go to the account service

00:13:36,860 --> 00:13:41,300
and see who I am and then from that I

00:13:39,350 --> 00:13:43,850
want to tell the review service who I am

00:13:41,300 --> 00:13:45,020
and fetch all of my reviews so that's

00:13:43,850 --> 00:13:46,370
where that gateway piece I talked about

00:13:45,020 --> 00:13:48,410
earlier comes into place and that's

00:13:46,370 --> 00:13:49,880
where we take this query we break it

00:13:48,410 --> 00:13:51,770
apart we actually fetch from the

00:13:49,880 --> 00:13:55,280
underlying services the work that we

00:13:51,770 --> 00:13:57,200
need so hopefully the demo gods will be

00:13:55,280 --> 00:14:01,370
with me today as we will get into some

00:13:57,200 --> 00:14:03,800
demos with this all right so I have got

00:14:01,370 --> 00:14:06,740
Kuehl playground loaded up here everyone

00:14:03,800 --> 00:14:08,210
familiar with this great so I'm just

00:14:06,740 --> 00:14:10,640
gonna come out and and write a query

00:14:08,210 --> 00:14:14,240
here so again I'm just gonna go directly

00:14:10,640 --> 00:14:18,890
into loading a single service that house

00:14:14,240 --> 00:14:20,360
is gone this is there is okay so there

00:14:18,890 --> 00:14:21,800
we go it worked it's it's a live running

00:14:20,360 --> 00:14:24,200
graph this is on code sandbox I promise

00:14:21,800 --> 00:14:26,840
this isn't you trying to fake anything

00:14:24,200 --> 00:14:29,900
for you so I've gone to a single service

00:14:26,840 --> 00:14:34,390
I fetched some data now I really want to

00:14:29,900 --> 00:14:39,110
be able to come beyond this and load in

00:14:34,390 --> 00:14:40,430
the reviews go fetch this right so far

00:14:39,110 --> 00:14:42,560
so good

00:14:40,430 --> 00:14:44,060
let's look at the services actually make

00:14:42,560 --> 00:14:47,270
up this schema so if I look at the

00:14:44,060 --> 00:14:48,980
schema here I have the user like we

00:14:47,270 --> 00:14:50,840
talked about I have the user who has

00:14:48,980 --> 00:14:52,790
reviews or reviews how's these feel so

00:14:50,840 --> 00:14:55,070
again as a client this looks just like

00:14:52,790 --> 00:14:56,630
the schema that I had yesterday that was

00:14:55,070 --> 00:14:58,490
stitch together or wasn't monolith

00:14:56,630 --> 00:15:01,370
there's no changes to what I've been

00:14:58,490 --> 00:15:03,970
using but the actual breakdown of this

00:15:01,370 --> 00:15:06,410
is very different for the service owners

00:15:03,970 --> 00:15:08,660
instead I have a single service here for

00:15:06,410 --> 00:15:11,630
accounts and this service does two

00:15:08,660 --> 00:15:13,820
things it creates a type and it gives

00:15:11,630 --> 00:15:14,900
clients access to that type of the root

00:15:13,820 --> 00:15:17,660
field

00:15:14,900 --> 00:15:20,210
so I've created a user plate and I've

00:15:17,660 --> 00:15:22,520
given access to it and then I have a

00:15:20,210 --> 00:15:26,420
review service and that a review service

00:15:22,520 --> 00:15:28,130
takes that user and extends it so now

00:15:26,420 --> 00:15:30,080
we're starting to work together on the

00:15:28,130 --> 00:15:31,610
shared ownership of a type it isn't just

00:15:30,080 --> 00:15:33,589
that the user service owns user type

00:15:31,610 --> 00:15:36,350
it's that collectively we all own the

00:15:33,589 --> 00:15:38,360
user type so I can do that from this

00:15:36,350 --> 00:15:40,580
service with Federation I can extend a

00:15:38,360 --> 00:15:44,270
type that another service owns and I can

00:15:40,580 --> 00:15:47,450
directly add my own feel to it so that

00:15:44,270 --> 00:15:49,790
three slide change where I showed you

00:15:47,450 --> 00:15:50,960
like you have to add gateway code and

00:15:49,790 --> 00:15:52,910
stitching code almost got stuff together

00:15:50,960 --> 00:15:54,980
now is as easy as just adding a new

00:15:52,910 --> 00:15:57,140
field to a tight and that forms the

00:15:54,980 --> 00:16:01,510
overall part but if I go back to the

00:15:57,140 --> 00:16:03,710
account service its view of a user

00:16:01,510 --> 00:16:07,250
doesn't have any of this information I'm

00:16:03,710 --> 00:16:08,779
gonna make this bigger a user to the

00:16:07,250 --> 00:16:12,950
account services just naming user name

00:16:08,779 --> 00:16:15,830
because it's only part of the story but

00:16:12,950 --> 00:16:17,779
when I query everything it all comes

00:16:15,830 --> 00:16:18,890
back together it's one service so what's

00:16:17,779 --> 00:16:21,110
actually happening under the hood here

00:16:18,890 --> 00:16:22,310
well I talked about a query planning

00:16:21,110 --> 00:16:22,790
idea that I need to split this work

00:16:22,310 --> 00:16:25,790
apart

00:16:22,790 --> 00:16:27,800
so let's actually take a look at this so

00:16:25,790 --> 00:16:29,930
part of the Federation release just like

00:16:27,800 --> 00:16:31,160
when graphical came out with graph QL it

00:16:29,930 --> 00:16:33,110
was one of the key thoughts of how you

00:16:31,160 --> 00:16:35,300
can teach this to your team like look we

00:16:33,110 --> 00:16:37,400
know that learning graph QL is is a cost

00:16:35,300 --> 00:16:39,260
to you it's a cost that has a huge

00:16:37,400 --> 00:16:40,640
benefits and it pays for itself but the

00:16:39,260 --> 00:16:41,839
tooling is a big part of that story for

00:16:40,640 --> 00:16:44,930
you to help to understand what that is

00:16:41,839 --> 00:16:47,300
so part of Apollo is always trying to

00:16:44,930 --> 00:16:48,709
provide the right tools for you so in

00:16:47,300 --> 00:16:51,709
this case for the open source release we

00:16:48,709 --> 00:16:53,150
have a query planner so whenever I do a

00:16:51,709 --> 00:16:54,680
fetch against a federated service now I

00:16:53,150 --> 00:16:56,660
can actually see what the Gateway is

00:16:54,680 --> 00:16:59,390
doing I can see how it's breaking apart

00:16:56,660 --> 00:17:02,000
this work so its first going to the

00:16:59,390 --> 00:17:03,860
account service which I showed so I can

00:17:02,000 --> 00:17:05,839
actually find the username because

00:17:03,860 --> 00:17:07,040
that's what I fetch for as a client but

00:17:05,839 --> 00:17:09,530
in order to get the information from the

00:17:07,040 --> 00:17:11,120
review service I need to get the ID and

00:17:09,530 --> 00:17:13,370
the type so I can know who I'm actually

00:17:11,120 --> 00:17:16,610
referencing what user this is and then

00:17:13,370 --> 00:17:18,350
it's the user type and then on the me

00:17:16,610 --> 00:17:21,079
field because this is where I'm starting

00:17:18,350 --> 00:17:23,780
to do my work on this return type I need

00:17:21,079 --> 00:17:26,420
to go to the review service with that

00:17:23,780 --> 00:17:27,620
information that that foreign key right

00:17:26,420 --> 00:17:28,340
I mean this is this is kind of database

00:17:27,620 --> 00:17:29,750
stuff here

00:17:28,340 --> 00:17:31,850
where I have a foreign key and a primary

00:17:29,750 --> 00:17:33,920
key the users primary key is the ID and

00:17:31,850 --> 00:17:37,130
the reviews has a foreign key to find

00:17:33,920 --> 00:17:39,950
that information so then on the review

00:17:37,130 --> 00:17:41,300
service I can fetch this I can pull in

00:17:39,950 --> 00:17:43,760
the body from all the reviews on that

00:17:41,300 --> 00:17:45,770
user all without you having to write any

00:17:43,760 --> 00:17:49,130
manual code at the gateway and in fact

00:17:45,770 --> 00:17:50,330
the Gateway is this this is it this is

00:17:49,130 --> 00:17:52,970
all the Gateway is there's no other

00:17:50,330 --> 00:17:55,430
imports I give my gateway a list of all

00:17:52,970 --> 00:17:58,430
the services these are all my federated

00:17:55,430 --> 00:18:01,670
services and I come together in form a

00:17:58,430 --> 00:18:03,860
single graph for my clients to consume

00:18:01,670 --> 00:18:07,160
and it really it's it's that easy it's

00:18:03,860 --> 00:18:10,250
that clean individual services don't

00:18:07,160 --> 00:18:12,350
have the additional information they're

00:18:10,250 --> 00:18:13,910
built in isolation and in fact if I go

00:18:12,350 --> 00:18:16,430
to the review service you notice it

00:18:13,910 --> 00:18:19,100
doesn't add any entry points it's only

00:18:16,430 --> 00:18:21,440
there to augment the part of my graph

00:18:19,100 --> 00:18:23,120
that it has information about it doesn't

00:18:21,440 --> 00:18:25,190
need a new field called reviews for user

00:18:23,120 --> 00:18:27,050
which then confuses my client developers

00:18:25,190 --> 00:18:28,340
is like well I'm already at the user I

00:18:27,050 --> 00:18:29,900
need to get their reviews do I have to

00:18:28,340 --> 00:18:31,190
go back to the root and how do I make

00:18:29,900 --> 00:18:32,870
all this work no no you don't want that

00:18:31,190 --> 00:18:36,740
you wanted to actually fall in that full

00:18:32,870 --> 00:18:42,880
graph but if I look at what's this let's

00:18:36,740 --> 00:18:42,880
see love the browser in here this graph

00:18:42,940 --> 00:18:49,880
there is no root field here I don't have

00:18:46,610 --> 00:18:51,830
an entry point for reviews I just have

00:18:49,880 --> 00:18:53,660
this idea of a review and the user and

00:18:51,830 --> 00:18:55,130
product so this service is just

00:18:53,660 --> 00:18:57,380
augmenting that graph it's just

00:18:55,130 --> 00:19:01,160
contributing to the overall data graph

00:18:57,380 --> 00:19:07,220
here okay let's take a quick pause

00:19:01,160 --> 00:19:09,200
questions so far all right got a few

00:19:07,220 --> 00:19:13,600
here we go we're getting microphones

00:19:09,200 --> 00:19:13,600
coming out I'll let y'all choose

00:19:16,559 --> 00:19:22,390
my name is Darrell just curious if you

00:19:19,720 --> 00:19:24,940
guys were able to quantitate if there's

00:19:22,390 --> 00:19:26,800
any kind of like cost for having this

00:19:24,940 --> 00:19:29,650
federated model and a very large large

00:19:26,800 --> 00:19:31,150
data graph yes the question is I would

00:19:29,650 --> 00:19:33,550
quantitatively have an idea of what the

00:19:31,150 --> 00:19:36,700
cost is to have a data graph this this

00:19:33,550 --> 00:19:37,960
large right what do you mean by that

00:19:36,700 --> 00:19:40,390
I guess can you walk me through a little

00:19:37,960 --> 00:19:41,890
bit more of when you talk about a cost

00:19:40,390 --> 00:19:44,980
of a data graph what are you looking for

00:19:41,890 --> 00:19:48,010
there sir no problem can we expand a

00:19:44,980 --> 00:19:50,110
little bit so for a large organization

00:19:48,010 --> 00:19:51,970
you said basically different teams are

00:19:50,110 --> 00:19:54,100
going to be doing things so let's just

00:19:51,970 --> 00:19:57,580
say as each team they're gonna have very

00:19:54,100 --> 00:19:58,780
huge data graphs in production right so

00:19:57,580 --> 00:20:00,370
I'm assuming that this is like an

00:19:58,780 --> 00:20:02,410
abstraction layer that kind of puts

00:20:00,370 --> 00:20:04,570
everything back together so there's got

00:20:02,410 --> 00:20:06,700
to be some kind of latency or I guess

00:20:04,570 --> 00:20:09,429
speed cost right have you guys kind of

00:20:06,700 --> 00:20:10,990
quantitative that yeah so so further the

00:20:09,429 --> 00:20:12,490
question is what is the actual cost

00:20:10,990 --> 00:20:13,960
between those services as you

00:20:12,490 --> 00:20:16,210
orchestrate this work essentially right

00:20:13,960 --> 00:20:17,350
you know it's at this point it's not

00:20:16,210 --> 00:20:20,710
something that we have hard numbers on

00:20:17,350 --> 00:20:21,730
because we're waiting for the ecosystem

00:20:20,710 --> 00:20:23,800
to try it out

00:20:21,730 --> 00:20:25,090
so we you know one of things that we

00:20:23,800 --> 00:20:27,100
really don't want to do is do any kind

00:20:25,090 --> 00:20:28,840
of premature optimizations what this can

00:20:27,100 --> 00:20:30,429
look like and the query planner does

00:20:28,840 --> 00:20:32,050
things like caching the query plan and I

00:20:30,429 --> 00:20:33,400
can show you and a little bit later the

00:20:32,050 --> 00:20:34,960
slide how you can actually optimize the

00:20:33,400 --> 00:20:36,460
query plan from an individual service so

00:20:34,960 --> 00:20:38,559
there's different polls and levers that

00:20:36,460 --> 00:20:40,059
you can do or if the most part if you're

00:20:38,559 --> 00:20:41,890
building your graph on top of existing

00:20:40,059 --> 00:20:42,900
underlying services this really isn't

00:20:41,890 --> 00:20:45,190
going to be that big of a difference

00:20:42,900 --> 00:20:47,530
it's still the orchestration of

00:20:45,190 --> 00:20:48,790
downstream data calls just organizing

00:20:47,530 --> 00:20:55,179
the way that helps your team scale

00:20:48,790 --> 00:20:57,040
faster other questions at some point

00:20:55,179 --> 00:20:59,320
you're gonna explain what the directives

00:20:57,040 --> 00:21:01,390
mean but like I can wait for that if

00:20:59,320 --> 00:21:05,250
that's later in the talk yes I

00:21:01,390 --> 00:21:05,250
definitely explain the directives okay

00:21:06,300 --> 00:21:11,980
at coding time how do you validate in in

00:21:10,179 --> 00:21:13,510
writing code for one service how do you

00:21:11,980 --> 00:21:15,179
validate that it uses the correct types

00:21:13,510 --> 00:21:18,220
from the others are those imported like

00:21:15,179 --> 00:21:20,470
node modules or something yeah yeah so

00:21:18,220 --> 00:21:22,330
the question is as I write the service

00:21:20,470 --> 00:21:24,520
how do I know that the user type even

00:21:22,330 --> 00:21:25,270
exists and if it does what fields are on

00:21:24,520 --> 00:21:28,540
it and how can I

00:21:25,270 --> 00:21:31,120
use that so if I look here you can see

00:21:28,540 --> 00:21:33,460
this external directive so this is part

00:21:31,120 --> 00:21:35,890
of this so each individual service has

00:21:33,460 --> 00:21:37,360
to say this is what I think the overall

00:21:35,890 --> 00:21:39,850
graph looks like from this other service

00:21:37,360 --> 00:21:42,430
so as the review service I think that

00:21:39,850 --> 00:21:44,620
there is an ID attached to a user and

00:21:42,430 --> 00:21:45,760
then it's a non nullable ID type and

00:21:44,620 --> 00:21:47,320
there's tooling that comes along with

00:21:45,760 --> 00:21:48,760
whether it's the CLI or the vs code

00:21:47,320 --> 00:21:50,650
extension that will give you that kind

00:21:48,760 --> 00:21:52,030
of complete type-ahead but for the

00:21:50,650 --> 00:21:54,340
service development experience as well

00:21:52,030 --> 00:21:56,320
so you have the full graph at your

00:21:54,340 --> 00:21:58,000
fingertips as you write it but more than

00:21:56,320 --> 00:22:00,610
though we can we can start to statically

00:21:58,000 --> 00:22:03,610
establish these dependencies so if the

00:22:00,610 --> 00:22:05,860
user service changes its concept of an

00:22:03,610 --> 00:22:08,200
ID maybe makes it nullable or maybe it

00:22:05,860 --> 00:22:10,090
makes it a string then I need to fail

00:22:08,200 --> 00:22:12,040
validation for that overall graph

00:22:10,090 --> 00:22:13,090
because now teams are working with

00:22:12,040 --> 00:22:14,740
different assumptions which can be

00:22:13,090 --> 00:22:16,630
really really dangerous so part of the

00:22:14,740 --> 00:22:18,070
reasons why we use directives and we

00:22:16,630 --> 00:22:20,110
have this stuff as part of the graphical

00:22:18,070 --> 00:22:22,390
language is just like Matt was showing

00:22:20,110 --> 00:22:24,160
that overall service check when you

00:22:22,390 --> 00:22:25,690
change your schema we can do the same

00:22:24,160 --> 00:22:26,770
kind of process for when you compose

00:22:25,690 --> 00:22:28,480
your schema to make sure you're building

00:22:26,770 --> 00:22:30,960
the correct graph that works all the

00:22:28,480 --> 00:22:30,960
other services

00:22:42,100 --> 00:22:45,850
yeah so question is what do you do about

00:22:43,870 --> 00:22:47,680
conflict checking so conflicts are

00:22:45,850 --> 00:22:48,970
actually part of the model here and the

00:22:47,680 --> 00:22:51,430
reason why they're part of the model is

00:22:48,970 --> 00:22:52,780
services responsibilities of services

00:22:51,430 --> 00:22:56,680
can change you need be able to migrate

00:22:52,780 --> 00:22:58,210
types and fields across systems so you

00:22:56,680 --> 00:22:59,950
need to be able to have support for

00:22:58,210 --> 00:23:02,050
essentially a kind of last service wins

00:22:59,950 --> 00:23:03,220
model but you do need to know that when

00:23:02,050 --> 00:23:05,860
you're doing it you're going to be

00:23:03,220 --> 00:23:07,690
overriding some other services work now

00:23:05,860 --> 00:23:10,390
where conflicts do come into play is if

00:23:07,690 --> 00:23:12,700
I think you're returning a user but I'm

00:23:10,390 --> 00:23:15,550
returning a protected user or there's a

00:23:12,700 --> 00:23:17,170
type clash that's gonna impact my in

00:23:15,550 --> 00:23:18,430
client so that's kind of the kind of

00:23:17,170 --> 00:23:20,740
collision detection you get that will

00:23:18,430 --> 00:23:22,420
fail a bill for instance but the actual

00:23:20,740 --> 00:23:24,670
service ownership there's a leaves

00:23:22,420 --> 00:23:26,710
complete flexibility to teams on how

00:23:24,670 --> 00:23:29,920
they want to orchestrate that ownership

00:23:26,710 --> 00:23:33,670
of those different fields I have a

00:23:29,920 --> 00:23:34,930
question over the dam so going back to

00:23:33,670 --> 00:23:38,100
Dennis yet Danielle's talked a little

00:23:34,930 --> 00:23:40,180
bit around the developer experience yep

00:23:38,100 --> 00:23:41,230
let's say you're a client developer and

00:23:40,180 --> 00:23:42,670
you're requesting a field you have no

00:23:41,230 --> 00:23:44,830
transparency which actual service owns

00:23:42,670 --> 00:23:47,470
this and there's a issue with it how do

00:23:44,830 --> 00:23:48,880
you like organizationally know who to go

00:23:47,470 --> 00:23:50,920
talk to which team owns that particular

00:23:48,880 --> 00:23:53,380
field yep that's a great question so

00:23:50,920 --> 00:23:55,270
question is as a client developer if

00:23:53,380 --> 00:23:56,500
part of my graph starts breaking who do

00:23:55,270 --> 00:23:57,730
I gotta talk to because previously was

00:23:56,500 --> 00:23:59,740
just one team right it's just this one

00:23:57,730 --> 00:24:02,710
model the service I could say hey the

00:23:59,740 --> 00:24:04,900
gun killer API is broken part of the

00:24:02,710 --> 00:24:06,850
Pala platform allows each individual

00:24:04,900 --> 00:24:08,830
service to have its own identity so this

00:24:06,850 --> 00:24:10,090
is a service name being able to connect

00:24:08,830 --> 00:24:12,610
it back to the team that actually owns

00:24:10,090 --> 00:24:14,680
it so when you get into errors whether

00:24:12,610 --> 00:24:16,630
it's an error or even just slowness

00:24:14,680 --> 00:24:18,970
being able to target that with something

00:24:16,630 --> 00:24:21,340
like Apollo Engine and looking in the UI

00:24:18,970 --> 00:24:23,410
and say this field is slow on this query

00:24:21,340 --> 00:24:25,390
because this service is that fault or

00:24:23,410 --> 00:24:27,550
this service has an error so part of

00:24:25,390 --> 00:24:29,680
building able to build this overall calm

00:24:27,550 --> 00:24:31,870
composed graph means you need to know

00:24:29,680 --> 00:24:33,820
who composes the parts so that's all

00:24:31,870 --> 00:24:38,680
built into the apollo platform with

00:24:33,820 --> 00:24:40,540
Federation support so building on top of

00:24:38,680 --> 00:24:43,480
that let's say the review service goes

00:24:40,540 --> 00:24:45,940
down and their reviews fail to return I

00:24:43,480 --> 00:24:48,730
see here that the reviews is a noble

00:24:45,940 --> 00:24:50,500
field so in that case the Gateway simple

00:24:48,730 --> 00:24:53,860
just return null but does that mean

00:24:50,500 --> 00:24:55,020
every linked field must be unknowable

00:24:53,860 --> 00:24:56,550
because then if you

00:24:55,020 --> 00:24:58,410
if you have an unknowable field and it

00:24:56,550 --> 00:25:01,530
fails to retrieve that and it fails the

00:24:58,410 --> 00:25:03,270
entire query yep so question is do

00:25:01,530 --> 00:25:05,040
linkages have to be nullable and the

00:25:03,270 --> 00:25:06,630
answer's no ultimately this still needs

00:25:05,040 --> 00:25:08,400
to be the graph that you would build if

00:25:06,630 --> 00:25:09,630
it was a single monolithic schema what

00:25:08,400 --> 00:25:10,980
that does mean just like it was a

00:25:09,630 --> 00:25:13,950
monolithic schema is that if my

00:25:10,980 --> 00:25:15,360
non-noble field fails because what maybe

00:25:13,950 --> 00:25:17,160
it's my rest in point or my database

00:25:15,360 --> 00:25:19,170
that's out or maybe it's the federated

00:25:17,160 --> 00:25:20,309
service ultimately that has to bubble up

00:25:19,170 --> 00:25:22,950
because that has critical UI

00:25:20,309 --> 00:25:24,540
implications but one of our core

00:25:22,950 --> 00:25:26,580
principles here is that Federation is

00:25:24,540 --> 00:25:28,860
still just graph QL you have complete

00:25:26,580 --> 00:25:31,590
freedom whether it's interfaces or

00:25:28,860 --> 00:25:32,850
unions or null ability or input types to

00:25:31,590 --> 00:25:34,920
still build a kind of graph that you

00:25:32,850 --> 00:25:35,700
want to build as one service federated

00:25:34,920 --> 00:25:38,760
across the board

00:25:35,700 --> 00:25:40,230
let's go to John in the back I'm sorry

00:25:38,760 --> 00:25:42,840
we already Evan like here we'll get you

00:25:40,230 --> 00:25:44,850
next time Kirsten yeah actually in the

00:25:42,840 --> 00:25:46,740
quarry you fade out if I have a use case

00:25:44,850 --> 00:25:49,080
where I'm coding for the same data more

00:25:46,740 --> 00:25:50,490
than once and that's the gateway you

00:25:49,080 --> 00:25:52,620
dupe the request or it is going to send

00:25:50,490 --> 00:25:54,240
the multiple if the question is what do

00:25:52,620 --> 00:25:56,460
you do with do you do deduplication as

00:25:54,240 --> 00:25:59,760
you request multiple things at once so

00:25:56,460 --> 00:26:02,130
that the way that it works is the

00:25:59,760 --> 00:26:04,860
Gateway will try and eagerly find as

00:26:02,130 --> 00:26:08,520
much as it can on a per service so if I

00:26:04,860 --> 00:26:09,900
go back to that query plan and we look

00:26:08,520 --> 00:26:12,390
at it here and we start to separate out

00:26:09,900 --> 00:26:14,220
this work the query planner has full

00:26:12,390 --> 00:26:15,870
knowledge of what services provide which

00:26:14,220 --> 00:26:19,140
fields so if I were to make another

00:26:15,870 --> 00:26:21,390
request to reviews but I was alias it

00:26:19,140 --> 00:26:22,980
for something for instance the query

00:26:21,390 --> 00:26:24,240
planner is going to eagerly collect all

00:26:22,980 --> 00:26:25,350
of that and batch it and send it

00:26:24,240 --> 00:26:27,270
together as one request of that

00:26:25,350 --> 00:26:29,040
underlying service and that underlying

00:26:27,270 --> 00:26:30,510
service can still implement its own data

00:26:29,040 --> 00:26:38,870
loader or datasource tile patching

00:26:30,510 --> 00:26:38,870
within that what's that

00:26:42,850 --> 00:26:48,260
um so question is this is always gonna

00:26:45,409 --> 00:26:49,880
do as long as the Gateway can fulfill

00:26:48,260 --> 00:26:51,409
all the requirements from a single

00:26:49,880 --> 00:26:52,460
service it's gonna go to that single

00:26:51,409 --> 00:26:54,740
service and actually show you how you

00:26:52,460 --> 00:26:59,570
can hint and give further optimizations

00:26:54,740 --> 00:27:01,700
from that in a little bit hey James I'm

00:26:59,570 --> 00:27:04,549
curious about where that route type did

00:27:01,700 --> 00:27:06,919
go does this in this model here does the

00:27:04,549 --> 00:27:08,809
entry point also get federated for

00:27:06,919 --> 00:27:10,760
example if you did want our reviews for

00:27:08,809 --> 00:27:12,559
user would you define that on the review

00:27:10,760 --> 00:27:15,049
service or is there another service that

00:27:12,559 --> 00:27:16,940
handles all the entry points yep so each

00:27:15,049 --> 00:27:19,850
service can add its own things to the

00:27:16,940 --> 00:27:22,639
entry points so if I wanted to add a

00:27:19,850 --> 00:27:28,309
reviews for user then I would be able to

00:27:22,639 --> 00:27:33,950
extend the query type and add a reviews

00:27:28,309 --> 00:27:35,870
for user field that returns back a array

00:27:33,950 --> 00:27:37,159
of reviews and this is going to get

00:27:35,870 --> 00:27:39,110
stitched together and merge together to

00:27:37,159 --> 00:27:42,340
the overall route so whether it's

00:27:39,110 --> 00:27:43,970
mutation or query or in the next version

00:27:42,340 --> 00:27:46,610
subscriptions which aren't supported

00:27:43,970 --> 00:27:48,860
currently each service again has full

00:27:46,610 --> 00:27:55,580
responsibility on what exposes to the in

00:27:48,860 --> 00:27:57,830
client's hi do resolvers need to have

00:27:55,580 --> 00:28:00,190
extrinsic information about what key

00:27:57,830 --> 00:28:03,139
you're using to stitch together these

00:28:00,190 --> 00:28:04,880
extended families of types yep the

00:28:03,139 --> 00:28:06,289
question is how do resolvers know about

00:28:04,880 --> 00:28:07,340
how to feed in the stitching so I'm

00:28:06,289 --> 00:28:08,779
gonna take this and actually go back

00:28:07,340 --> 00:28:09,950
into the demo so we'll pick up more

00:28:08,779 --> 00:28:11,179
questions afterwards but thank you

00:28:09,950 --> 00:28:13,610
that's a great segue for the next part

00:28:11,179 --> 00:28:18,080
of the demo it's almost like we told you

00:28:13,610 --> 00:28:19,279
but we didn't that well so you see these

00:28:18,080 --> 00:28:21,409
key directives so I mentioned I was

00:28:19,279 --> 00:28:25,250
gonna explain directives here so these

00:28:21,409 --> 00:28:27,950
are very much primary keys right this is

00:28:25,250 --> 00:28:30,860
that in my database given an IDE I can

00:28:27,950 --> 00:28:33,260
give you back a user and then the review

00:28:30,860 --> 00:28:35,840
or the user service has the same kind of

00:28:33,260 --> 00:28:38,210
thing give it an ID for a user I can

00:28:35,840 --> 00:28:41,720
find that user so the way that it works

00:28:38,210 --> 00:28:45,519
as I go from service to service if the

00:28:41,720 --> 00:28:47,960
review service wants to return a user

00:28:45,519 --> 00:28:51,170
then the one requirement there is that

00:28:47,960 --> 00:28:53,300
it has to return a primary key from

00:28:51,170 --> 00:28:55,700
that user so that it can be fetched from

00:28:53,300 --> 00:28:58,490
the user service so then the resolver

00:28:55,700 --> 00:28:59,750
that will then load that and Apollo

00:28:58,490 --> 00:29:02,930
server actually implements something

00:28:59,750 --> 00:29:06,050
called let's see I think it's in the

00:29:02,930 --> 00:29:07,310
accounts we have resolve objects which

00:29:06,050 --> 00:29:09,020
lets you take some of that information

00:29:07,310 --> 00:29:11,090
there's also resolve reference or so a

00:29:09,020 --> 00:29:12,530
little bit later and let you take that

00:29:11,090 --> 00:29:14,930
information from another service and

00:29:12,530 --> 00:29:16,640
turn that into the user so it allows you

00:29:14,930 --> 00:29:19,190
to do kind of batch fetches of just the

00:29:16,640 --> 00:29:22,540
actual primary key reference that you

00:29:19,190 --> 00:29:24,290
need to be able to use to fetch it so

00:29:22,540 --> 00:29:25,520
individual services get that

00:29:24,290 --> 00:29:29,480
relationship and that becomes really

00:29:25,520 --> 00:29:32,600
important when you extend types so as I

00:29:29,480 --> 00:29:34,820
extend the user type what I had the key

00:29:32,600 --> 00:29:37,310
directive here and what this has to do

00:29:34,820 --> 00:29:39,320
two things one is that it has to match a

00:29:37,310 --> 00:29:41,180
key directive for the user type because

00:29:39,320 --> 00:29:43,190
that foreign key - primary key

00:29:41,180 --> 00:29:45,380
relationship has to exist if the user

00:29:43,190 --> 00:29:47,720
service has no idea about an ID field

00:29:45,380 --> 00:29:51,140
then they're not actually linked in that

00:29:47,720 --> 00:29:53,990
way and then beyond that it means that

00:29:51,140 --> 00:29:57,320
in order to load the reviews for a user

00:29:53,990 --> 00:29:59,150
my service needs to know the ID field of

00:29:57,320 --> 00:30:02,030
users that becomes my foreign key that

00:29:59,150 --> 00:30:05,980
my resolvers need access to so when I

00:30:02,030 --> 00:30:10,550
load for instance the reviews resolver I

00:30:05,980 --> 00:30:12,680
have the user ID because that's what the

00:30:10,550 --> 00:30:15,230
query planner and the Gateway sent to my

00:30:12,680 --> 00:30:19,490
underlying service and actually show you

00:30:15,230 --> 00:30:21,410
what this looks like so if we go back

00:30:19,490 --> 00:30:27,770
out here I'm gonna make this a little

00:30:21,410 --> 00:30:28,640
bit a little bit larger okay so this is

00:30:27,770 --> 00:30:30,560
printing out a whole bunch of stuff so

00:30:28,640 --> 00:30:32,710
what I've got set up here is a simple

00:30:30,560 --> 00:30:35,030
logger - any request that comes in to

00:30:32,710 --> 00:30:36,350
this graphical service is going to get

00:30:35,030 --> 00:30:38,150
printed out with the console where it's

00:30:36,350 --> 00:30:40,220
a pretty pretty simple stuff here so I'm

00:30:38,150 --> 00:30:41,450
gonna go back to the gateway and again

00:30:40,220 --> 00:30:44,750
I'm just gonna come in here I'm going to

00:30:41,450 --> 00:30:47,240
fetch the reviews so I fetch it I have

00:30:44,750 --> 00:30:49,250
reviews there and if I go to the review

00:30:47,240 --> 00:30:53,030
service I now have some more information

00:30:49,250 --> 00:30:55,940
here I have this representations thing

00:30:53,030 --> 00:30:57,200
and this entity's query and this is part

00:30:55,940 --> 00:30:59,720
of that Federation inspect I'll show a

00:30:57,200 --> 00:31:01,310
little bit a little while ago that is

00:30:59,720 --> 00:31:02,260
how a service becomes a federated

00:31:01,310 --> 00:31:03,880
service

00:31:02,260 --> 00:31:06,280
so who's in here's familiar with the

00:31:03,880 --> 00:31:09,400
node concept from relay but note

00:31:06,280 --> 00:31:11,770
interface a couple people here so the

00:31:09,400 --> 00:31:13,660
basic premise there is an object

00:31:11,770 --> 00:31:16,300
identity if I have an ID then I can

00:31:13,660 --> 00:31:18,640
enter into that spot of the graph if I

00:31:16,300 --> 00:31:20,650
have a user ID I can get into it so the

00:31:18,640 --> 00:31:22,140
relay spec kind of says you need a route

00:31:20,650 --> 00:31:24,010
field called node where you can do this

00:31:22,140 --> 00:31:25,600
what we've done is we've taken that a

00:31:24,010 --> 00:31:28,750
step farther we've built that into how

00:31:25,600 --> 00:31:31,450
you build services from from day one and

00:31:28,750 --> 00:31:34,150
we have an entry point for the Gateway

00:31:31,450 --> 00:31:36,670
to say I have a representation of a user

00:31:34,150 --> 00:31:39,250
it looks like this there's an ID of one

00:31:36,670 --> 00:31:41,110
and it's the user type and from that I

00:31:39,250 --> 00:31:43,210
want to be able to select on your view

00:31:41,110 --> 00:31:45,640
of the user because as a review service

00:31:43,210 --> 00:31:47,410
I have my own view of the user so the

00:31:45,640 --> 00:31:49,930
Gateway will orchestrate a fetch to the

00:31:47,410 --> 00:31:51,610
sub service that looks just like this so

00:31:49,930 --> 00:31:53,230
it's not magic here it's just breaking

00:31:51,610 --> 00:31:54,820
apart those queries from that query plan

00:31:53,230 --> 00:31:56,800
and turning it into work that can be

00:31:54,820 --> 00:31:59,800
done at the gateway level then the

00:31:56,800 --> 00:32:04,120
resolver gets the user ID as part of how

00:31:59,800 --> 00:32:06,510
it can Lotus information further

00:32:04,120 --> 00:32:06,510
questions

00:32:14,090 --> 00:32:19,160
Terk you say it's the micro kick right

00:32:16,200 --> 00:32:21,330
here no you're good oh how the

00:32:19,160 --> 00:32:24,090
duplicates will be handle once the

00:32:21,330 --> 00:32:26,040
gateways grew sufficiently large let's

00:32:24,090 --> 00:32:31,770
say the user our reviews we may

00:32:26,040 --> 00:32:33,090
available in different domain so how do

00:32:31,770 --> 00:32:34,380
you resolve duplicates across the

00:32:33,090 --> 00:32:35,790
different surfaces so like one service

00:32:34,380 --> 00:32:38,760
may also try and add reviews or

00:32:35,790 --> 00:32:41,130
something like that yeah so part of it

00:32:38,760 --> 00:32:43,860
is the platform has the Pala platform

00:32:41,130 --> 00:32:46,230
has a validation tool set as part of it

00:32:43,860 --> 00:32:48,660
so before you ever go into any kind of

00:32:46,230 --> 00:32:50,430
deployed environment you would say this

00:32:48,660 --> 00:32:52,590
is the change that I intend to make the

00:32:50,430 --> 00:32:54,840
graph and if there's a collision there

00:32:52,590 --> 00:32:56,400
it will prevent you from doing that

00:32:54,840 --> 00:32:57,840
beyond that the Gateway will also

00:32:56,400 --> 00:32:59,250
prevent you from having these kind of

00:32:57,840 --> 00:33:00,900
collisions actually exist so that

00:32:59,250 --> 00:33:03,510
gateway won't be able to form a compose

00:33:00,900 --> 00:33:06,360
schema if there is ambiguity and how it

00:33:03,510 --> 00:33:08,580
should do its work beyond that though

00:33:06,360 --> 00:33:10,410
services can actually have some level of

00:33:08,580 --> 00:33:11,700
overlap between fields because data

00:33:10,410 --> 00:33:13,980
isn't necessarily this like straight

00:33:11,700 --> 00:33:16,230
line between services so you have this

00:33:13,980 --> 00:33:17,730
tool called provides which I'll show you

00:33:16,230 --> 00:33:19,140
in the next demo that actually allows

00:33:17,730 --> 00:33:20,640
you to have overlap between those

00:33:19,140 --> 00:33:22,020
services and you can tell the query

00:33:20,640 --> 00:33:31,320
planner those efficient way to get at

00:33:22,020 --> 00:33:32,550
that data other questions okay let's get

00:33:31,320 --> 00:33:37,290
back to it so far that didn't worked out

00:33:32,550 --> 00:33:39,390
pretty well I like it alright so now you

00:33:37,290 --> 00:33:41,130
have this composed graph and teams are

00:33:39,390 --> 00:33:44,190
great because they're working in

00:33:41,130 --> 00:33:47,340
isolation they're able to independently

00:33:44,190 --> 00:33:49,080
add to the graph remove things from the

00:33:47,340 --> 00:33:50,310
graph they have validation as part of

00:33:49,080 --> 00:33:51,870
this so they know that if they

00:33:50,310 --> 00:33:53,370
deprecated a field or remove a field

00:33:51,870 --> 00:33:54,870
it's not gonna break any clients like

00:33:53,370 --> 00:33:56,640
Matt was showing earlier again this is

00:33:54,870 --> 00:33:58,980
all just a layer on top of the graph

00:33:56,640 --> 00:34:02,610
kill you know and love it's a layer on

00:33:58,980 --> 00:34:03,570
top of the overall Apollo platform but

00:34:02,610 --> 00:34:05,010
then you want to start to actually

00:34:03,570 --> 00:34:07,110
optimize what this experience looks like

00:34:05,010 --> 00:34:08,850
and you want to start to expand what it

00:34:07,110 --> 00:34:12,150
means to be a part of the overall data

00:34:08,850 --> 00:34:13,980
graph so Apollo Federation has two ways

00:34:12,150 --> 00:34:16,080
to do this two different kinds of query

00:34:13,980 --> 00:34:17,850
hints but you can provide to the Gateway

00:34:16,080 --> 00:34:19,320
again these are all done through

00:34:17,850 --> 00:34:21,720
directives because this is all just

00:34:19,320 --> 00:34:23,250
graph you well this isn't a new syntax

00:34:21,720 --> 00:34:24,900
to learn it's not a new library that you

00:34:23,250 --> 00:34:26,310
have to pick up it's just the graph you

00:34:24,900 --> 00:34:27,720
all that you've already learned

00:34:26,310 --> 00:34:31,530
using in a way that helps you to build

00:34:27,720 --> 00:34:34,950
an overall composed schema so we're

00:34:31,530 --> 00:34:37,940
gonna start with provides here so my

00:34:34,950 --> 00:34:40,020
review service also stores the username

00:34:37,940 --> 00:34:41,820
along with an ID because I've

00:34:40,020 --> 00:34:43,920
denormalize that data it's part of how

00:34:41,820 --> 00:34:45,750
my service works this is a pretty common

00:34:43,920 --> 00:34:47,520
situation right like I have some level

00:34:45,750 --> 00:34:49,350
of denormalization across all of my

00:34:47,520 --> 00:34:52,980
services because it's never that hard

00:34:49,350 --> 00:34:55,830
edge between services so if I'm gonna

00:34:52,980 --> 00:34:58,170
actually ask for the username field and

00:34:55,830 --> 00:35:00,020
that's all that I'm gonna ask for when

00:34:58,170 --> 00:35:02,010
I'm already looking at a review that

00:35:00,020 --> 00:35:03,300
service really need to be able to say

00:35:02,010 --> 00:35:04,830
hey you don't need to go to the account

00:35:03,300 --> 00:35:06,570
service that's extra work that you just

00:35:04,830 --> 00:35:08,700
don't have to do because I already have

00:35:06,570 --> 00:35:10,740
that information for you it's ready to

00:35:08,700 --> 00:35:13,620
go here just select it directly so with

00:35:10,740 --> 00:35:15,690
the provides directive you can hint at

00:35:13,620 --> 00:35:18,480
the query planner to say I have these

00:35:15,690 --> 00:35:20,850
additional fields one thing I haven't

00:35:18,480 --> 00:35:22,080
talked about yet is you see this fields

00:35:20,850 --> 00:35:23,940
fields fields as part of all these

00:35:22,080 --> 00:35:26,550
directives and it looks like right now

00:35:23,940 --> 00:35:29,100
it's just a single word right like it's

00:35:26,550 --> 00:35:31,410
a single key what this actually is what

00:35:29,100 --> 00:35:34,200
we call a field set and a field set is

00:35:31,410 --> 00:35:38,940
just like a graphical selection set if

00:35:34,200 --> 00:35:41,880
we look at a selection set it's this

00:35:38,940 --> 00:35:44,340
part so a field set is the selection set

00:35:41,880 --> 00:35:46,910
without the wrapping brackets and the

00:35:44,340 --> 00:35:51,360
reason why that is important is because

00:35:46,910 --> 00:35:52,230
this service is looking at the user it's

00:35:51,360 --> 00:35:54,300
saying that I'm gonna give you back a

00:35:52,230 --> 00:35:56,730
user but more importantly what it's

00:35:54,300 --> 00:35:58,320
saying is that on the user type I have

00:35:56,730 --> 00:36:00,720
this fuel called user name that I

00:35:58,320 --> 00:36:02,850
already have I may have multiple fields

00:36:00,720 --> 00:36:04,950
I may have user name and ID

00:36:02,850 --> 00:36:07,410
I may have user name and Dame I may even

00:36:04,950 --> 00:36:09,900
have user name and another type that's

00:36:07,410 --> 00:36:12,060
on the user type like friends I may

00:36:09,900 --> 00:36:13,740
store the reviews of your friends so I

00:36:12,060 --> 00:36:17,610
can actually write in these field sets

00:36:13,740 --> 00:36:20,220
full selection sets of that type so this

00:36:17,610 --> 00:36:21,870
is just graph QL within graph QL it's a

00:36:20,220 --> 00:36:25,110
little bit meta here where I can write

00:36:21,870 --> 00:36:27,330
fragments to show how I can relate types

00:36:25,110 --> 00:36:29,070
to other parts of types so this user

00:36:27,330 --> 00:36:31,560
name field here isn't just a single

00:36:29,070 --> 00:36:34,830
field it can be multiple which is how

00:36:31,560 --> 00:36:37,080
you can do something like requires so

00:36:34,830 --> 00:36:37,950
requires let you do a concept of a

00:36:37,080 --> 00:36:41,430
computed

00:36:37,950 --> 00:36:42,839
old across services so typically you

00:36:41,430 --> 00:36:44,460
have to co-locate this stuff because you

00:36:42,839 --> 00:36:46,560
need to be able to say well on the

00:36:44,460 --> 00:36:49,230
inventory service but I really need the

00:36:46,560 --> 00:36:50,460
size and the weight and my end users

00:36:49,230 --> 00:36:51,810
don't have that because they're still

00:36:50,460 --> 00:36:53,490
fetching the product they don't know the

00:36:51,810 --> 00:36:54,660
size and the weight yet so in order to

00:36:53,490 --> 00:36:56,430
get the shipping estimate I first have

00:36:54,660 --> 00:36:57,750
to fetch the size and the weight and I

00:36:56,430 --> 00:36:59,070
got to bring it down the client and then

00:36:57,750 --> 00:37:00,630
I got to go back and have a route feel

00:36:59,070 --> 00:37:01,950
that says okay give the shipping

00:37:00,630 --> 00:37:04,200
estimate and computer from these two

00:37:01,950 --> 00:37:05,880
fields what the inventory service really

00:37:04,200 --> 00:37:07,079
wants to be able to do is say if you

00:37:05,880 --> 00:37:08,940
want the shipping estimate

00:37:07,079 --> 00:37:10,140
I need the size and the weight from a

00:37:08,940 --> 00:37:12,750
product that you are currently looking

00:37:10,140 --> 00:37:14,609
at whether you came from the reviews and

00:37:12,750 --> 00:37:16,530
products or from a top level like top

00:37:14,609 --> 00:37:18,150
product something like that ultimately

00:37:16,530 --> 00:37:21,359
the inventory service needs additional

00:37:18,150 --> 00:37:24,599
information beyond just the primary key

00:37:21,359 --> 00:37:27,180
of that product so what this does is the

00:37:24,599 --> 00:37:28,470
query planner then will add these fields

00:37:27,180 --> 00:37:31,320
to its work and I'll show you in the

00:37:28,470 --> 00:37:33,869
actual query plan view but the resolver

00:37:31,320 --> 00:37:35,730
now has that information so this isn't a

00:37:33,869 --> 00:37:37,890
service that's completely detached from

00:37:35,730 --> 00:37:39,960
the product service and it's it's

00:37:37,890 --> 00:37:41,730
extending that type and it's requiring

00:37:39,960 --> 00:37:43,710
additional parts of that product service

00:37:41,730 --> 00:37:45,960
in order to do the work that it needs to

00:37:43,710 --> 00:37:47,609
do and so that's how you can hint

00:37:45,960 --> 00:37:49,890
between services for additional computed

00:37:47,609 --> 00:37:54,359
fields so let's take a look what that

00:37:49,890 --> 00:37:57,839
looks like okay so we'll go into

00:37:54,359 --> 00:38:00,720
something like top products and products

00:37:57,839 --> 00:38:02,400
have names and they have price and I'm

00:38:00,720 --> 00:38:03,990
going to load it here and sure enough

00:38:02,400 --> 00:38:05,819
we're only going to one service because

00:38:03,990 --> 00:38:09,510
once there was good fulfill all this

00:38:05,819 --> 00:38:10,589
information this is great right but

00:38:09,510 --> 00:38:14,550
let's say that I want the shipping

00:38:10,589 --> 00:38:16,470
estimate here so the shipping estimate

00:38:14,550 --> 00:38:19,609
comes in and a couple different values

00:38:16,470 --> 00:38:24,810
here but let's look at the query planner

00:38:19,609 --> 00:38:27,869
so if you notice in here I asked for the

00:38:24,810 --> 00:38:29,730
weight but the end user never asked for

00:38:27,869 --> 00:38:31,410
the weight this isn't an ID it's not

00:38:29,730 --> 00:38:32,760
part of how you fetch this product the

00:38:31,410 --> 00:38:34,410
query planner has actually added those

00:38:32,760 --> 00:38:36,660
additional fields as part of the query

00:38:34,410 --> 00:38:40,380
plan to go to that underlying product

00:38:36,660 --> 00:38:41,609
service so now when I fetch from that

00:38:40,380 --> 00:38:44,280
product service to fetch the shipping

00:38:41,609 --> 00:38:46,380
estimate the input to that resolver has

00:38:44,280 --> 00:38:47,970
all this additional information and in

00:38:46,380 --> 00:38:50,130
fact I can get rid of everything here

00:38:47,970 --> 00:38:51,030
and I can just load from the shipping

00:38:50,130 --> 00:38:52,680
service

00:38:51,030 --> 00:38:54,120
I still have to go to the product

00:38:52,680 --> 00:38:56,490
service to get that first set of

00:38:54,120 --> 00:38:57,810
information I need that the four and are

00:38:56,490 --> 00:38:59,520
the primary key of it so I can relay

00:38:57,810 --> 00:39:01,170
that to my service and I need that

00:38:59,520 --> 00:39:03,390
additional work and then I can just

00:39:01,170 --> 00:39:05,550
Spach the shipping estimate because

00:39:03,390 --> 00:39:07,200
that's all that I need so with that I've

00:39:05,550 --> 00:39:08,910
been able to hint to the query planner

00:39:07,200 --> 00:39:10,620
of the additional work that needs to be

00:39:08,910 --> 00:39:13,110
done because of the service boundaries

00:39:10,620 --> 00:39:14,460
without impacting my clients again right

00:39:13,110 --> 00:39:15,930
like you don't part a graph kill the

00:39:14,460 --> 00:39:16,710
benefit here is you don't have to over

00:39:15,930 --> 00:39:18,180
fetch you don't to do all this

00:39:16,710 --> 00:39:19,260
additional work because you don't need

00:39:18,180 --> 00:39:20,880
that on a client it's just gonna be

00:39:19,260 --> 00:39:22,110
confusing it's gonna get caught up

00:39:20,880 --> 00:39:23,250
you're gonna have all these prop tight

00:39:22,110 --> 00:39:26,400
mess if you don't need something like

00:39:23,250 --> 00:39:30,180
Apollo you really want that work to be

00:39:26,400 --> 00:39:32,070
done at your graph layer itself and the

00:39:30,180 --> 00:39:36,960
other side the other kind of query

00:39:32,070 --> 00:39:38,520
hinting is provides so again I have this

00:39:36,960 --> 00:39:41,160
denormalized data I have a review

00:39:38,520 --> 00:39:43,170
service that also has the user name so I

00:39:41,160 --> 00:39:47,730
can go back to the Gateway and if I ask

00:39:43,170 --> 00:39:53,490
for their reviews and I just asked for

00:39:47,730 --> 00:39:55,560
the author's user name so all that data

00:39:53,490 --> 00:39:56,730
comes back I can go to the account

00:39:55,560 --> 00:39:58,680
service to first find out who I am

00:39:56,730 --> 00:40:01,020
because that's like it's part of my

00:39:58,680 --> 00:40:03,090
overall graph query but then I can on

00:40:01,020 --> 00:40:05,970
the review service I can additionally

00:40:03,090 --> 00:40:07,560
ask for fuels on the user type so now

00:40:05,970 --> 00:40:09,240
I've bypassed having to go to the

00:40:07,560 --> 00:40:10,530
account service again I don't have to

00:40:09,240 --> 00:40:12,210
make that extra dependency that extra

00:40:10,530 --> 00:40:13,800
round-trip all because that service was

00:40:12,210 --> 00:40:16,380
able to tell the query planner it has

00:40:13,800 --> 00:40:19,590
all that information but if it doesn't

00:40:16,380 --> 00:40:21,600
have all that information and I got to

00:40:19,590 --> 00:40:22,620
go back to the account service again and

00:40:21,600 --> 00:40:24,680
I got to fetch that additional

00:40:22,620 --> 00:40:27,120
information so again this is all done

00:40:24,680 --> 00:40:28,110
transparent to you as service owner you

00:40:27,120 --> 00:40:30,090
don't have to worry about this

00:40:28,110 --> 00:40:31,710
relationship you use the directives to

00:40:30,090 --> 00:40:33,990
define the capabilities of your graph

00:40:31,710 --> 00:40:36,270
and together that's gonna form an

00:40:33,990 --> 00:40:37,920
overall composition that the Gateway is

00:40:36,270 --> 00:40:41,400
gonna be able to use to break apart and

00:40:37,920 --> 00:40:44,120
load all the stuff together so let's get

00:40:41,400 --> 00:40:44,120
into questions here

00:40:53,450 --> 00:41:12,690
yeah I'll repeat your question - you're

00:41:11,460 --> 00:41:15,200
basically gonna have to duplicate a lot

00:41:12,690 --> 00:41:19,590
of field definitions between your

00:41:15,200 --> 00:41:21,480
provides directive and your schema and

00:41:19,590 --> 00:41:24,410
and the fields that are there I guess

00:41:21,480 --> 00:41:26,820
I'm curious why can't that be implied

00:41:24,410 --> 00:41:28,350
somehow so what's what's the root of

00:41:26,820 --> 00:41:31,020
that design decision yeah absolutely so

00:41:28,350 --> 00:41:32,160
the question is if I start to provide a

00:41:31,020 --> 00:41:33,570
lot of field so if I have a lot of

00:41:32,160 --> 00:41:35,220
overlap here that I'm gonna end up

00:41:33,570 --> 00:41:37,410
having to do a lot of work and my schema

00:41:35,220 --> 00:41:38,490
here to replicate these services across

00:41:37,410 --> 00:41:41,220
the boundaries why can't it be an

00:41:38,490 --> 00:41:42,210
implicit provision and even the Gateway

00:41:41,220 --> 00:41:43,830
could potentially do some of that

00:41:42,210 --> 00:41:45,300
orchestration work right you could say

00:41:43,830 --> 00:41:46,290
well I didn't get any value back for

00:41:45,300 --> 00:41:49,140
this let me go and fetch those

00:41:46,290 --> 00:41:50,850
underlying service so the reason why we

00:41:49,140 --> 00:41:52,500
have these external directives as part

00:41:50,850 --> 00:41:54,450
of the model here

00:41:52,500 --> 00:41:56,700
the biggest reason honestly is

00:41:54,450 --> 00:41:58,080
validation we want you to be able to

00:41:56,700 --> 00:42:00,210
know what those assumptions look like

00:41:58,080 --> 00:42:02,130
across the services so when you return

00:42:00,210 --> 00:42:03,480
to username what does your service

00:42:02,130 --> 00:42:05,520
actually think that a username is

00:42:03,480 --> 00:42:07,680
because it could be a string to you but

00:42:05,520 --> 00:42:09,720
it could be a scalar to another part of

00:42:07,680 --> 00:42:10,980
the graph which then forms a graph that

00:42:09,720 --> 00:42:12,120
the client just doesn't understand

00:42:10,980 --> 00:42:15,030
because there's two different kinds of

00:42:12,120 --> 00:42:17,520
username so implicitly when I add a key

00:42:15,030 --> 00:42:20,460
directive to a type on a service then

00:42:17,520 --> 00:42:22,740
implicitly whenever I return a type from

00:42:20,460 --> 00:42:25,710
another service in this case user it's

00:42:22,740 --> 00:42:27,120
gonna return the ID field or the primary

00:42:25,710 --> 00:42:28,470
key here is part of that so that is the

00:42:27,120 --> 00:42:30,360
implicit return otherwise you have to

00:42:28,470 --> 00:42:31,920
duplicate that everywhere but what we

00:42:30,360 --> 00:42:33,780
found so far in practice and again this

00:42:31,920 --> 00:42:35,550
is where we'd love to work with you

00:42:33,780 --> 00:42:38,070
didn't understand what your needs here

00:42:35,550 --> 00:42:40,860
are is that fields tend to not provide

00:42:38,070 --> 00:42:42,810
the entire overlap they provide a few

00:42:40,860 --> 00:42:44,100
additional fields and you want to have

00:42:42,810 --> 00:42:45,480
that listed here you want to be able to

00:42:44,100 --> 00:42:46,920
get that validation you want to be able

00:42:45,480 --> 00:42:48,540
to run it locally without having to run

00:42:46,920 --> 00:42:50,760
the overall graph so having this

00:42:48,540 --> 00:42:52,110
duplication allows you to have the local

00:42:50,760 --> 00:42:54,120
development experience the validation

00:42:52,110 --> 00:42:55,230
experience and ultimately just make sure

00:42:54,120 --> 00:42:56,060
that what you're returning is the

00:42:55,230 --> 00:42:58,670
correct overall

00:42:56,060 --> 00:43:00,650
can I ask one what they call odd so with

00:42:58,670 --> 00:43:02,540
with username specifically as this

00:43:00,650 --> 00:43:04,790
example I guess I'm just curious about

00:43:02,540 --> 00:43:07,010
the design decision about specifying

00:43:04,790 --> 00:43:09,310
username and you provides versus adding

00:43:07,010 --> 00:43:12,560
an annotation on username in that extend

00:43:09,310 --> 00:43:15,230
it just out here yeah yeah absolutely so

00:43:12,560 --> 00:43:16,760
the reason why you do it on the

00:43:15,230 --> 00:43:20,600
individual field level is I may have

00:43:16,760 --> 00:43:21,980
another type that is an admin review not

00:43:20,600 --> 00:43:24,410
an atom review there's an atom in here

00:43:21,980 --> 00:43:26,840
you can give you a review later so I

00:43:24,410 --> 00:43:28,940
have an admin review and that type may

00:43:26,840 --> 00:43:30,770
have an author which is a user but

00:43:28,940 --> 00:43:31,910
because the way my data is normalized I

00:43:30,770 --> 00:43:33,200
don't actually have the username for

00:43:31,910 --> 00:43:33,380
this because it wasn't the one who did

00:43:33,200 --> 00:43:35,510
it

00:43:33,380 --> 00:43:37,610
so each type has to determine its own

00:43:35,510 --> 00:43:42,680
provides capabilities at that field

00:43:37,610 --> 00:43:44,900
level that make sense yeah thanks other

00:43:42,680 --> 00:43:46,580
questions about anything here not just

00:43:44,900 --> 00:43:48,860
provides and requires but about the

00:43:46,580 --> 00:43:53,660
model at whole at all or how you build

00:43:48,860 --> 00:43:55,490
up these things together so I think I

00:43:53,660 --> 00:43:56,870
think this is supported but I just

00:43:55,490 --> 00:43:59,210
wanted to check so let's see if you have

00:43:56,870 --> 00:44:00,710
if I'm a requesting review at the level

00:43:59,210 --> 00:44:03,710
the first level and then I'm the coolest

00:44:00,710 --> 00:44:05,690
in review at the 6th level even within

00:44:03,710 --> 00:44:07,220
the graph yep so what data loader is

00:44:05,690 --> 00:44:10,730
providing us in a single monolithic

00:44:07,220 --> 00:44:13,010
architecture is is that let's see if

00:44:10,730 --> 00:44:15,860
there's a repeated ID it will only be we

00:44:13,010 --> 00:44:17,600
will take it from the map there's the

00:44:15,860 --> 00:44:18,920
query planner planner handle that

00:44:17,600 --> 00:44:21,110
because you don't you can't actually

00:44:18,920 --> 00:44:23,510
execute the sixth level until you have

00:44:21,110 --> 00:44:26,420
executed the fourth level right the top

00:44:23,510 --> 00:44:28,070
four levels yep so the question is if I

00:44:26,420 --> 00:44:29,690
were to write something like this and I

00:44:28,070 --> 00:44:31,880
get to an author and I love their

00:44:29,690 --> 00:44:36,440
reviews and then an author and I love

00:44:31,880 --> 00:44:37,850
the reviews going and then I won't

00:44:36,440 --> 00:44:39,140
actually load that information right so

00:44:37,850 --> 00:44:40,760
in a monolithic schema if you use a

00:44:39,140 --> 00:44:42,530
pattern like data loader this all

00:44:40,760 --> 00:44:45,290
happens over the course of the same

00:44:42,530 --> 00:44:47,210
request and so I can batch the work to

00:44:45,290 --> 00:44:48,290
look up some of these dependencies not

00:44:47,210 --> 00:44:50,450
all of them because there may be an

00:44:48,290 --> 00:44:51,800
actual like dependency tree but

00:44:50,450 --> 00:44:53,690
especially if there's other sibling

00:44:51,800 --> 00:44:56,060
fields and I can batch and load all that

00:44:53,690 --> 00:44:57,830
together so the way that works is the

00:44:56,060 --> 00:45:00,950
query planner is as long as there's not

00:44:57,830 --> 00:45:02,210
a breakage in the service chain as long

00:45:00,950 --> 00:45:03,800
as the single service can load all of

00:45:02,210 --> 00:45:05,990
that but you can still use something

00:45:03,800 --> 00:45:08,119
like day loader at that service level

00:45:05,990 --> 00:45:09,289
so you can still you can send this to it

00:45:08,119 --> 00:45:11,450
you can still use data loader if there

00:45:09,289 --> 00:45:12,980
but when there becomes dependencies in

00:45:11,450 --> 00:45:14,329
the chain then you have to do the

00:45:12,980 --> 00:45:16,759
orchestration between the different

00:45:14,329 --> 00:45:18,680
services load that up so what that gives

00:45:16,759 --> 00:45:20,180
you the opportunity to do by default no

00:45:18,680 --> 00:45:22,099
we don't have there's not a data loader

00:45:20,180 --> 00:45:24,579
at the service level because otherwise

00:45:22,099 --> 00:45:28,369
you'd have to have a entry point for

00:45:24,579 --> 00:45:30,500
every additional potential like review

00:45:28,369 --> 00:45:33,049
reviews user users that kind of thing in

00:45:30,500 --> 00:45:34,759
order to do that batching instead the

00:45:33,049 --> 00:45:37,190
representations can take an array of

00:45:34,759 --> 00:45:38,930
entities so we can send all the

00:45:37,190 --> 00:45:41,000
different tight times that you request

00:45:38,930 --> 00:45:42,710
the user all together to the underlying

00:45:41,000 --> 00:45:44,809
service and then you can do the data

00:45:42,710 --> 00:46:00,279
loading at that service how you want to

00:45:44,809 --> 00:46:00,279
and then yes are good yep

00:46:09,160 --> 00:46:13,970
yep yeah so that's why we push all of

00:46:12,590 --> 00:46:15,980
the underlined that's why we don't do

00:46:13,970 --> 00:46:17,780
data loading at the gateway level itself

00:46:15,980 --> 00:46:19,750
because there is an issue that that

00:46:17,780 --> 00:46:21,830
consistency consistency can break down

00:46:19,750 --> 00:46:22,670
that being said one of the things that

00:46:21,830 --> 00:46:24,290
we really want to work with the

00:46:22,670 --> 00:46:26,750
community on is what does it look like

00:46:24,290 --> 00:46:29,119
to give caching information metadata

00:46:26,750 --> 00:46:31,010
from the underlying services to say you

00:46:29,119 --> 00:46:33,440
fetch this review this ID is going to be

00:46:31,010 --> 00:46:35,600
stable for the next five seconds thirty

00:46:33,440 --> 00:46:38,150
minutes our and to form an overall

00:46:35,600 --> 00:46:41,869
collective cache at the top level of the

00:46:38,150 --> 00:46:44,240
query beyond that part of the Gateway

00:46:41,869 --> 00:46:46,490
API allows you to customize how you

00:46:44,240 --> 00:46:48,020
fetch from underlying services so if you

00:46:46,490 --> 00:46:50,180
have advanced features or if you have

00:46:48,020 --> 00:46:51,830
the ability to customize that Apollo is

00:46:50,180 --> 00:46:53,630
always about providing the right

00:46:51,830 --> 00:46:55,220
underlying API is for you to be able to

00:46:53,630 --> 00:46:56,810
do what you want to be able to do so

00:46:55,220 --> 00:46:58,970
there's a whole build service API here

00:46:56,810 --> 00:47:01,130
that lets you customize that transport

00:46:58,970 --> 00:47:02,660
level to the underlying service so you

00:47:01,130 --> 00:47:04,580
can implement batching there or you can

00:47:02,660 --> 00:47:13,190
use even a whole different transport if

00:47:04,580 --> 00:47:16,550
you want to all right so correct me if

00:47:13,190 --> 00:47:20,000
I'm wrong so looks like the review type

00:47:16,550 --> 00:47:22,130
if you can go back to the review type so

00:47:20,000 --> 00:47:24,230
the review type the review back back end

00:47:22,130 --> 00:47:26,480
supposed to return the user name so that

00:47:24,230 --> 00:47:29,119
you can connects to the user back-end is

00:47:26,480 --> 00:47:32,210
that user graph is that right so it

00:47:29,119 --> 00:47:34,160
returns the user ID here as the key so

00:47:32,210 --> 00:47:37,640
it can it connect to the account service

00:47:34,160 --> 00:47:39,230
but who provides that username so in

00:47:37,640 --> 00:47:41,690
this case it's saying that the review

00:47:39,230 --> 00:47:43,430
service can additionally also give you

00:47:41,690 --> 00:47:44,869
back the username so in this case the

00:47:43,430 --> 00:47:46,970
review service would additionally

00:47:44,869 --> 00:47:48,950
provide that but it would be used to go

00:47:46,970 --> 00:47:50,780
to the reviews or to the account service

00:47:48,950 --> 00:47:53,030
it be used instead of going to the

00:47:50,780 --> 00:47:55,850
account service got it so have we

00:47:53,030 --> 00:47:58,040
thought about since the review service

00:47:55,850 --> 00:48:00,710
will potentially return the username

00:47:58,040 --> 00:48:02,510
that we thought about maybe between the

00:48:00,710 --> 00:48:05,510
username that the review service

00:48:02,510 --> 00:48:07,550
returned and what the user graph can

00:48:05,510 --> 00:48:09,260
potentially fetch by the username there

00:48:07,550 --> 00:48:11,900
could be some data massaging happening

00:48:09,260 --> 00:48:13,080
that you might need to pass in anonymous

00:48:11,900 --> 00:48:14,790
function

00:48:13,080 --> 00:48:16,230
to transform their username into

00:48:14,790 --> 00:48:19,530
something that a user back in the

00:48:16,230 --> 00:48:21,660
chemists and so if I understand your

00:48:19,530 --> 00:48:24,180
kind of question here is that the

00:48:21,660 --> 00:48:25,790
account service may have a different at

00:48:24,180 --> 00:48:29,430
that point in time it may return back at

00:48:25,790 --> 00:48:32,700
user name on India account service mine

00:48:29,430 --> 00:48:34,230
is always underscore some user but then

00:48:32,700 --> 00:48:35,460
you have to take out a on the score in

00:48:34,230 --> 00:48:39,060
order for the user back-end to

00:48:35,460 --> 00:48:40,680
understand right yeah so the way that we

00:48:39,060 --> 00:48:43,980
the way that it's set up here is that

00:48:40,680 --> 00:48:45,870
the individual services they need to

00:48:43,980 --> 00:48:48,000
return back the kind of data that they

00:48:45,870 --> 00:48:50,250
so a string in this case right so could

00:48:48,000 --> 00:48:51,630
have an underscore it could not which

00:48:50,250 --> 00:48:54,150
would be the same thing as if it was in

00:48:51,630 --> 00:48:56,250
a single monolithic schema a field from

00:48:54,150 --> 00:49:00,030
a review going into an author may have

00:48:56,250 --> 00:49:01,860
it as a non underscored or if field from

00:49:00,030 --> 00:49:04,290
a from the admin may have it as an

00:49:01,860 --> 00:49:05,970
underscore so ultimately those decisions

00:49:04,290 --> 00:49:07,620
are still part of the responsibility of

00:49:05,970 --> 00:49:09,540
the team to figure out that relationship

00:49:07,620 --> 00:49:11,310
we're not trying to abstract and build

00:49:09,540 --> 00:49:12,690
on top of everything this is really

00:49:11,310 --> 00:49:14,070
trying to keep the core graph killed

00:49:12,690 --> 00:49:15,750
primitives but just give you a Bill

00:49:14,070 --> 00:49:17,160
ability to scale that across different

00:49:15,750 --> 00:49:18,420
teams so it's still something that you

00:49:17,160 --> 00:49:19,830
have to communicate and talk with your

00:49:18,420 --> 00:49:23,940
team as you're building out what this

00:49:19,830 --> 00:49:25,860
data looks like how does how does

00:49:23,940 --> 00:49:31,470
education and removing the field work

00:49:25,860 --> 00:49:34,260
what's that yep so how does deprecation

00:49:31,470 --> 00:49:36,120
or removing a field work so in current

00:49:34,260 --> 00:49:38,310
graph QL when you deprecated a feel the

00:49:36,120 --> 00:49:40,470
intention there is to tell clients stop

00:49:38,310 --> 00:49:41,730
querying it right or if you're if you

00:49:40,470 --> 00:49:44,190
remove a field then you're saying a

00:49:41,730 --> 00:49:46,560
client can no longer query this kind of

00:49:44,190 --> 00:49:48,300
thing now with a federated world you

00:49:46,560 --> 00:49:49,860
have an additional customer of your

00:49:48,300 --> 00:49:51,810
graph because you have a partial graph

00:49:49,860 --> 00:49:53,880
so you have other services that may

00:49:51,810 --> 00:49:55,950
require those other parts of the field

00:49:53,880 --> 00:49:58,650
so let's say in that shipping estimate I

00:49:55,950 --> 00:50:02,730
deprecated the weight field and instead

00:49:58,650 --> 00:50:04,710
I have a new one called size instead of

00:50:02,730 --> 00:50:06,330
weight so I would deprecated that and

00:50:04,710 --> 00:50:07,950
then the next time that I was in my

00:50:06,330 --> 00:50:09,870
editor or making a change to the review

00:50:07,950 --> 00:50:11,670
service I would get a warning as a part

00:50:09,870 --> 00:50:14,670
of the Apollo platform it says you're

00:50:11,670 --> 00:50:16,320
using a field in your requires directive

00:50:14,670 --> 00:50:18,930
that has been deprecated from another

00:50:16,320 --> 00:50:20,820
service and beyond that if that review

00:50:18,930 --> 00:50:22,620
service tried to remove that field even

00:50:20,820 --> 00:50:24,630
if a client has never requested it

00:50:22,620 --> 00:50:25,770
because it's linked independently by

00:50:24,630 --> 00:50:28,109
another service

00:50:25,770 --> 00:50:29,520
it throws a bill error at like CI time

00:50:28,109 --> 00:50:31,650
and says you're gonna break another

00:50:29,520 --> 00:50:34,500
service so now that coordination isn't

00:50:31,650 --> 00:50:36,300
just clients to overall graph its client

00:50:34,500 --> 00:50:38,310
overall graph and service the service

00:50:36,300 --> 00:50:39,960
and we're you still use the graphical

00:50:38,310 --> 00:50:41,550
type system the deprecation system in

00:50:39,960 --> 00:50:50,040
order to make those kind of sweeping

00:50:41,550 --> 00:50:52,290
evolution changes hi so do you mind

00:50:50,040 --> 00:50:54,990
coming back to that reviews yeah so in

00:50:52,290 --> 00:50:58,710
this case reviews on that extend type

00:50:54,990 --> 00:51:02,010
user does the reviews resolver here

00:50:58,710 --> 00:51:04,589
depend on ID and username um it just

00:51:02,010 --> 00:51:06,240
depends on ID and where does that get

00:51:04,589 --> 00:51:08,700
that which part of which directive

00:51:06,240 --> 00:51:10,980
declares that reviews needs ID so it's

00:51:08,700 --> 00:51:13,530
it's this one here but this is saying is

00:51:10,980 --> 00:51:16,680
that any field that I add to the user

00:51:13,530 --> 00:51:19,260
type as the review service I need the ID

00:51:16,680 --> 00:51:21,960
of the user in order to fetch that got

00:51:19,260 --> 00:51:24,150
it and then this is saying that if I

00:51:21,960 --> 00:51:26,310
have a user already and I already have

00:51:24,150 --> 00:51:28,349
that user ID I'm gonna give you back an

00:51:26,310 --> 00:51:29,609
ID so that you can then go into the rest

00:51:28,349 --> 00:51:31,410
the user from another part of the graph

00:51:29,609 --> 00:51:33,720
and one thing that's key here is you

00:51:31,410 --> 00:51:35,460
don't have to you don't have to do

00:51:33,720 --> 00:51:36,990
anything to return a type so I could

00:51:35,460 --> 00:51:38,670
remove this completely in fact I'm doing

00:51:36,990 --> 00:51:41,339
it here for product so I could not

00:51:38,670 --> 00:51:43,530
extend this at all and my service can

00:51:41,339 --> 00:51:45,660
still participate in that federated

00:51:43,530 --> 00:51:47,040
graph by just returning what a product

00:51:45,660 --> 00:51:50,190
is and this is going to use the primary

00:51:47,040 --> 00:51:52,560
key of the product from the base service

00:51:50,190 --> 00:51:53,970
that says a product needs a UPC or an ID

00:51:52,560 --> 00:51:58,010
and it's gonna return that information

00:51:53,970 --> 00:51:58,010
back to that product service

00:52:02,850 --> 00:52:11,520
case of a using it from a like a third

00:52:08,430 --> 00:52:15,300
party like another company will provide

00:52:11,520 --> 00:52:16,740
a section of a data graph and that you

00:52:15,300 --> 00:52:19,770
know you want to use it your company and

00:52:16,740 --> 00:52:22,200
extend it and so on and the deprecated

00:52:19,770 --> 00:52:24,750
field seems like a you know a great that

00:52:22,200 --> 00:52:26,850
have metadata message to you know when

00:52:24,750 --> 00:52:28,260
it's not within the same company it's to

00:52:26,850 --> 00:52:30,870
that message wonder if there's other

00:52:28,260 --> 00:52:33,210
tools if you thought about these use

00:52:30,870 --> 00:52:36,390
cases other tools to help support that

00:52:33,210 --> 00:52:38,070
type of communication yes the question

00:52:36,390 --> 00:52:39,510
let's say that I'm extending a third

00:52:38,070 --> 00:52:42,750
party graft and I'm starting to do

00:52:39,510 --> 00:52:44,580
essentially composition across orgs well

00:52:42,750 --> 00:52:46,140
to be one totally transparent the first

00:52:44,580 --> 00:52:48,090
version of this is really intended to be

00:52:46,140 --> 00:52:49,650
used within your org there's nothing

00:52:48,090 --> 00:52:51,240
that prohibits in fact the whole goal of

00:52:49,650 --> 00:52:53,040
the models be able to expand beyond that

00:52:51,240 --> 00:52:55,200
but like you said it really becomes a

00:52:53,040 --> 00:52:56,580
tooling story at that point so one of

00:52:55,200 --> 00:52:58,920
things that the Apollo platform provides

00:52:56,580 --> 00:53:00,510
is a whole tooling story around the

00:52:58,920 --> 00:53:03,150
clients that are requesting your graph

00:53:00,510 --> 00:53:06,780
and and it can say well this is my iOS

00:53:03,150 --> 00:53:10,380
client or this is my web client but that

00:53:06,780 --> 00:53:12,900
extends to services as well so you can

00:53:10,380 --> 00:53:15,450
start to say that as I as I provide a

00:53:12,900 --> 00:53:17,850
third party access point into my graph I

00:53:15,450 --> 00:53:19,860
can say hey you can use Confederate my

00:53:17,850 --> 00:53:21,960
graph my part up give you and you can

00:53:19,860 --> 00:53:23,340
use it so let's get up for instance the

00:53:21,960 --> 00:53:24,960
idea there is that github would use the

00:53:23,340 --> 00:53:27,290
tooling that would tell them if I'm

00:53:24,960 --> 00:53:30,540
gonna remove this field I will now break

00:53:27,290 --> 00:53:32,520
X company and why company's composition

00:53:30,540 --> 00:53:33,690
story because it's a dependency because

00:53:32,520 --> 00:53:36,570
it's connecting there because they've

00:53:33,690 --> 00:53:38,190
been sending traffic my way to use those

00:53:36,570 --> 00:53:40,380
fields because ultimately it comes down

00:53:38,190 --> 00:53:42,180
to usage if your company never actually

00:53:40,380 --> 00:53:44,430
use the thing that you're extending then

00:53:42,180 --> 00:53:46,320
its github prerogative to be able to

00:53:44,430 --> 00:53:47,940
remove that safely because it's not some

00:53:46,320 --> 00:53:49,260
it's being used in their API but they've

00:53:47,940 --> 00:53:51,330
got to understand that metadata about

00:53:49,260 --> 00:53:53,010
how not just the graph is being queried

00:53:51,330 --> 00:53:54,450
but how services are dependent on it

00:53:53,010 --> 00:53:56,010
so there's tooling built into the Apollo

00:53:54,450 --> 00:53:57,780
platform to let you do that internally

00:53:56,010 --> 00:53:59,370
within your org because sometimes that

00:53:57,780 --> 00:54:01,830
can be a farther distance than your

00:53:59,370 --> 00:54:02,640
third party relationship right and you

00:54:01,830 --> 00:54:04,350
really wanna be able to make that work

00:54:02,640 --> 00:54:06,390
really easy if not having to go to

00:54:04,350 --> 00:54:07,470
building C and find that person and

00:54:06,390 --> 00:54:09,120
slack them and try and figure out what's

00:54:07,470 --> 00:54:10,890
going on you need to tooling to help you

00:54:09,120 --> 00:54:13,950
do that as part of your actual process

00:54:10,890 --> 00:54:15,060
for shipping code let's do one more and

00:54:13,950 --> 00:54:15,780
then I have a couple more slides before

00:54:15,060 --> 00:54:20,970
we

00:54:15,780 --> 00:54:23,970
shop here so I have a question how does

00:54:20,970 --> 00:54:26,430
this works with authentication so maybe

00:54:23,970 --> 00:54:29,040
I won one graph to be private or maybe

00:54:26,430 --> 00:54:30,630
just the user has log out and they do

00:54:29,040 --> 00:54:32,820
they don't need to have that information

00:54:30,630 --> 00:54:35,130
anymore how does this work so how can

00:54:32,820 --> 00:54:36,630
you pass the header other than just

00:54:35,130 --> 00:54:38,580
adding more overhead to like more

00:54:36,630 --> 00:54:41,400
authentication servers to like is this

00:54:38,580 --> 00:54:43,230
user valid is the user logins yeah

00:54:41,400 --> 00:54:44,700
absolutely so the question is about

00:54:43,230 --> 00:54:47,160
authentication how does that work on a

00:54:44,700 --> 00:54:48,780
federated graph so there's a couple

00:54:47,160 --> 00:54:50,730
things here one is that the there's two

00:54:48,780 --> 00:54:53,130
forms of kind of standard authentication

00:54:50,730 --> 00:54:55,440
that graph services can do or typically

00:54:53,130 --> 00:54:57,360
do I would say one is that there is kind

00:54:55,440 --> 00:54:59,010
of this overall authentication set that

00:54:57,360 --> 00:55:01,260
happens really before you ever even

00:54:59,010 --> 00:55:02,940
start execution we're given a header I

00:55:01,260 --> 00:55:04,560
can turn that into a user ID

00:55:02,940 --> 00:55:05,910
I'll put maybe put that on the context

00:55:04,560 --> 00:55:07,860
that way fields can know about it right

00:55:05,910 --> 00:55:09,600
and then there's another one that's more

00:55:07,860 --> 00:55:12,720
authorization based where each

00:55:09,600 --> 00:55:14,130
individual resolver needs to know who's

00:55:12,720 --> 00:55:16,020
accessing it an additional scope

00:55:14,130 --> 00:55:18,240
information or to determine if they need

00:55:16,020 --> 00:55:20,790
to return null there to stop executions

00:55:18,240 --> 00:55:22,830
going farther right so ultimately you do

00:55:20,790 --> 00:55:26,250
the same thing in Federation the gateway

00:55:22,830 --> 00:55:27,930
has the ability to do authorization and

00:55:26,250 --> 00:55:29,970
authentication so you can take the

00:55:27,930 --> 00:55:31,830
header and convert it into a user ID and

00:55:29,970 --> 00:55:33,030
then you can attach that user ID as part

00:55:31,830 --> 00:55:35,190
of the header to your underlying

00:55:33,030 --> 00:55:37,680
services so they can essentially pick up

00:55:35,190 --> 00:55:39,720
parts of the context from that request

00:55:37,680 --> 00:55:41,820
whether it's sent as a header or as

00:55:39,720 --> 00:55:45,270
additional extension data between those

00:55:41,820 --> 00:55:47,160
services so the for instance the review

00:55:45,270 --> 00:55:49,770
service may be able to pick up the user

00:55:47,160 --> 00:55:51,900
ID that comes from the Gateway and know

00:55:49,770 --> 00:55:54,150
which users logged in are using it or in

00:55:51,900 --> 00:55:56,610
the lack of presence of that they won't

00:55:54,150 --> 00:55:58,440
be able to return any reviews but

00:55:56,610 --> 00:56:00,510
because that service linkage is set up

00:55:58,440 --> 00:56:03,060
to be nested as part of a user type

00:56:00,510 --> 00:56:05,310
there the user service still ultimately

00:56:03,060 --> 00:56:07,200
makes decision on do they have a user or

00:56:05,310 --> 00:56:08,790
do they don't and if they aren't logged

00:56:07,200 --> 00:56:09,960
in that it's not gonna return a user so

00:56:08,790 --> 00:56:11,880
it's not going to go into the underlying

00:56:09,960 --> 00:56:13,260
reviews type keeping that boundary is

00:56:11,880 --> 00:56:15,420
still the same as it was a monolithic

00:56:13,260 --> 00:56:17,010
schema so that's a long-winded way of

00:56:15,420 --> 00:56:19,440
saying it's the same way you do it now

00:56:17,010 --> 00:56:20,580
you just have more control over what you

00:56:19,440 --> 00:56:22,470
send back and forth between these

00:56:20,580 --> 00:56:26,250
services but effectively act within your

00:56:22,470 --> 00:56:28,210
private data graph network cool all

00:56:26,250 --> 00:56:30,579
right so I have a couple more slides

00:56:28,210 --> 00:56:32,890
so what we talked about here is really

00:56:30,579 --> 00:56:34,420
great but what does actually mean for my

00:56:32,890 --> 00:56:35,559
day-to-day life how does actually gonna

00:56:34,420 --> 00:56:37,990
work for my developers who are building

00:56:35,559 --> 00:56:41,319
it and we have a really firm belief here

00:56:37,990 --> 00:56:43,900
that Federation is a layer on top of how

00:56:41,319 --> 00:56:46,480
you do graph QL it isn't its own thing

00:56:43,900 --> 00:56:47,920
it isn't its own textbook to learn

00:56:46,480 --> 00:56:50,470
although you know there's plenty still

00:56:47,920 --> 00:56:51,880
to come about learning it ultimately the

00:56:50,470 --> 00:56:52,720
reason why I won't you have one graph is

00:56:51,880 --> 00:56:55,300
because you want to have all the

00:56:52,720 --> 00:56:58,240
platform benefits so Apollo Federation

00:56:55,300 --> 00:56:59,440
is platform ready from day 1 vs code for

00:56:58,240 --> 00:57:01,359
your client developers so it'll look the

00:56:59,440 --> 00:57:03,490
same client check is gonna be able to

00:57:01,359 --> 00:57:04,630
still make sure that you're not using

00:57:03,490 --> 00:57:06,430
you're not removing heels that are

00:57:04,630 --> 00:57:07,960
breaking clients it's just for each of

00:57:06,430 --> 00:57:09,819
these phase you get this additional

00:57:07,960 --> 00:57:11,650
layer on top of it maybe it's not just

00:57:09,819 --> 00:57:14,380
the timing information but maybe it's

00:57:11,650 --> 00:57:16,540
what service it comes in or as you start

00:57:14,380 --> 00:57:18,309
to write out your SDL it's what services

00:57:16,540 --> 00:57:19,990
do you need to get autocomplete from all

00:57:18,309 --> 00:57:24,430
this is built into how you build

00:57:19,990 --> 00:57:26,230
products using Apollo currently and

00:57:24,430 --> 00:57:27,520
ultimately what we're trying to do here

00:57:26,230 --> 00:57:28,780
and the reason why we want to talk to

00:57:27,520 --> 00:57:30,849
you and while these questions have been

00:57:28,780 --> 00:57:32,170
phenomenal and I'll be out here if you

00:57:30,849 --> 00:57:34,960
want to ask more please come and find me

00:57:32,170 --> 00:57:37,000
is we're here to build the right kind of

00:57:34,960 --> 00:57:38,589
tools to help you build a company that

00:57:37,000 --> 00:57:39,940
you want to be able to build we think

00:57:38,589 --> 00:57:41,530
that Federation is a really next

00:57:39,940 --> 00:57:44,230
critical step in the evolution of graph

00:57:41,530 --> 00:57:46,329
QL to help teams of all sizes be able to

00:57:44,230 --> 00:57:48,010
build a single graph without getting

00:57:46,329 --> 00:57:49,119
bottlenecked and stuck in the

00:57:48,010 --> 00:57:51,369
coordination of trying to orchestrate

00:57:49,119 --> 00:57:53,829
people we really think this is a really

00:57:51,369 --> 00:57:55,240
big addition to building one graph with

00:57:53,829 --> 00:57:57,369
many services so that you can build the

00:57:55,240 --> 00:57:58,990
kind of thing you need but ultimately we

00:57:57,369 --> 00:58:00,880
need your feedback the reason why this

00:57:58,990 --> 00:58:02,589
is all going open-source next week is

00:58:00,880 --> 00:58:04,569
because we want the community to own

00:58:02,589 --> 00:58:06,520
this just like graph QL is open source

00:58:04,569 --> 00:58:08,109
it's a spec we need to know if this is

00:58:06,520 --> 00:58:09,339
the right situation what are we missing

00:58:08,109 --> 00:58:11,290
here because I'm sure we're missing a

00:58:09,339 --> 00:58:13,119
lot what are the use cases you have that

00:58:11,290 --> 00:58:14,619
don't fit into this model please work

00:58:13,119 --> 00:58:16,599
with us please work with our team to

00:58:14,619 --> 00:58:18,730
help build this out and make it a much

00:58:16,599 --> 00:58:20,260
better way to federate your schema and

00:58:18,730 --> 00:58:24,520
be able to build one graph for all your

00:58:20,260 --> 00:58:25,780
services been a pleasure I hope that you

00:58:24,520 --> 00:58:27,280
enjoyed this as much as I enjoyed giving

00:58:25,780 --> 00:58:28,780
it it's always a blast to see people

00:58:27,280 --> 00:58:31,960
questions were awesome

00:58:28,780 --> 00:58:33,440
ultimately thank you and I'm J Baxley

00:58:31,960 --> 00:58:34,550
the third III

00:58:33,440 --> 00:58:38,050
kind of everywhere so if you want to

00:58:34,550 --> 00:58:38,050
chat please let me know thank you

00:58:38,460 --> 00:58:41,670

YouTube URL: https://www.youtube.com/watch?v=lRI0HfXBAm8


