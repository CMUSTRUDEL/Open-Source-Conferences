Title: GraphQL SDL First Products  - Chris Biscardi
Publication date: 2018-02-21
Playlist: GraphQL SF: Real World GraphQL
Description: 
	At GraphQL SF 2/15/18, Chris Biscardi speaks about SDL First Products. This is a condensed version of his talk at qcon: https://qconlondon.com/london2018/presentation/parallelizing-product-development-graphql We ran into some technical issues, so be sure to check out his full length talk. 

Follow us on Twitter to get notified about future meetups: https://twitter.com/apollographql

ðŸ‘‰Full Description

In this talk we'll take a look at how the GraphQL SDL can be used to decouple client and server implementations and why that matters. We'll cover a set of tools that are "Schema First", including Prisma and Apollo, as well as dive into how the SDL can be used to communicate across teams.

ðŸ‘‰Interested in Speaking?

We'd love to hear from you! Please message https://twitter.com/evanshauser
Captions: 
	00:00:02,740 --> 00:00:09,090
the name of the talk is STL first

00:00:06,580 --> 00:00:11,080
products and the subtitle is

00:00:09,090 --> 00:00:13,360
parallelizing product development with

00:00:11,080 --> 00:00:16,689
graph QL and what I really want you to

00:00:13,360 --> 00:00:19,390
get from this talk is not just that

00:00:16,689 --> 00:00:20,950
graph QL is a nice tool to solve

00:00:19,390 --> 00:00:22,960
technical problems so there's also a

00:00:20,950 --> 00:00:26,110
nice tool to solve social problems in

00:00:22,960 --> 00:00:28,660
terms of communication between a front

00:00:26,110 --> 00:00:30,670
end and a back end team and this isn't

00:00:28,660 --> 00:00:32,320
limited to just like your monolith and

00:00:30,670 --> 00:00:36,700
you have your ruby on rails or Django

00:00:32,320 --> 00:00:39,820
application this is you can use the SDL

00:00:36,700 --> 00:00:42,700
as the point of communication for an

00:00:39,820 --> 00:00:43,930
entire micro service back-end going

00:00:42,700 --> 00:00:45,370
through a graph QL gateway to a

00:00:43,930 --> 00:00:48,520
front-end that also uses the

00:00:45,370 --> 00:00:50,469
introspection result and you decouple

00:00:48,520 --> 00:00:52,000
sort of the implementation of the back

00:00:50,469 --> 00:00:55,510
end from the implementation of the front

00:00:52,000 --> 00:00:57,910
end if you use the SDL in this way you

00:00:55,510 --> 00:00:59,379
can do things like when a nice new go

00:00:57,910 --> 00:01:01,559
library comes out and you don't want to

00:00:59,379 --> 00:01:05,350
use JavaScript anymore you can switch to

00:01:01,559 --> 00:01:07,690
this golang library without really

00:01:05,350 --> 00:01:09,640
needing to bother anybody you already

00:01:07,690 --> 00:01:12,580
have a spec for what the API should do

00:01:09,640 --> 00:01:14,350
this is significantly more difficult if

00:01:12,580 --> 00:01:18,820
you're trying to switch on say like a

00:01:14,350 --> 00:01:21,250
REST API right you got some magic going

00:01:18,820 --> 00:01:22,750
on in your rest generation of the URLs

00:01:21,250 --> 00:01:24,670
and you have to match all of the magic

00:01:22,750 --> 00:01:27,490
and it doesn't really work out but since

00:01:24,670 --> 00:01:30,850
graph QL is so well typed it works out

00:01:27,490 --> 00:01:31,689
quite nicely so I'm Chris I work at

00:01:30,850 --> 00:01:33,820
honeycomb dot IO

00:01:31,689 --> 00:01:35,200
it's an observability product if you're

00:01:33,820 --> 00:01:37,780
interested in that sort of thing

00:01:35,200 --> 00:01:40,540
talk to me later because it's cool I

00:01:37,780 --> 00:01:42,310
basically run on coffee and I am at

00:01:40,540 --> 00:01:47,770
Christmas cardi on Twitter or buscar'

00:01:42,310 --> 00:01:49,479
chime basically anywhere else so this

00:01:47,770 --> 00:01:53,229
would normally be a slide of the blog

00:01:49,479 --> 00:01:57,009
schema who here is familiar with the

00:01:53,229 --> 00:01:59,380
actual schema definition language cool

00:01:57,009 --> 00:02:00,460
that's about half people I'm gonna

00:01:59,380 --> 00:02:02,020
assume that there's a bunch of people on

00:02:00,460 --> 00:02:04,540
the stream that are not familiar with it

00:02:02,020 --> 00:02:08,429
or about the same I'm gonna talk about

00:02:04,540 --> 00:02:12,340
it basically in a in a schema definition

00:02:08,429 --> 00:02:14,169
file or whatever doc graph QL file you

00:02:12,340 --> 00:02:15,750
can specify things in much the way that

00:02:14,169 --> 00:02:18,690
you can specify them with proto Bob

00:02:15,750 --> 00:02:21,300
avro or any of these numerous other more

00:02:18,690 --> 00:02:24,030
common data formats basically goes

00:02:21,300 --> 00:02:25,560
something like type name of the type

00:02:24,030 --> 00:02:27,930
which in this case would be like a post

00:02:25,560 --> 00:02:30,540
or a blog and then what looks like a

00:02:27,930 --> 00:02:32,400
JSON object with keys that are

00:02:30,540 --> 00:02:35,040
effectively strings without the quotes

00:02:32,400 --> 00:02:40,200
and values that are effectively strings

00:02:35,040 --> 00:02:43,920
with a couple extra tidbits you get your

00:02:40,200 --> 00:02:45,780
strings your intz your bools things like

00:02:43,920 --> 00:02:47,700
that if you're using a special kind of

00:02:45,780 --> 00:02:50,430
server you can get things like date/time

00:02:47,700 --> 00:02:52,980
you can define your own scalars which

00:02:50,430 --> 00:02:56,430
means that if you want a specific brand

00:02:52,980 --> 00:02:58,470
of date/time or a specific so you have

00:02:56,430 --> 00:02:59,970
really really really large integers or

00:02:58,470 --> 00:03:01,140
something like that right you need to

00:02:59,970 --> 00:03:04,020
pass them down as a string you can

00:03:01,140 --> 00:03:05,730
create a new scalar for that tell your

00:03:04,020 --> 00:03:07,980
graph QL API that hey this is going to

00:03:05,730 --> 00:03:10,170
be one of these big imps and then your

00:03:07,980 --> 00:03:15,959
client can treat it as a string instead

00:03:10,170 --> 00:03:17,010
of losing a ton of accuracy right the

00:03:15,959 --> 00:03:18,510
other thing I want to mention is

00:03:17,010 --> 00:03:20,299
directives which you already heard about

00:03:18,510 --> 00:03:23,489
before as somebody asked about them

00:03:20,299 --> 00:03:25,170
these are sort of like an in-between

00:03:23,489 --> 00:03:27,600
world a thing in the graph Yale world

00:03:25,170 --> 00:03:30,750
where they're there and you can define

00:03:27,600 --> 00:03:32,370
your own ones but only kinda and only

00:03:30,750 --> 00:03:34,200
certain servers support certain ones and

00:03:32,370 --> 00:03:36,000
things like that

00:03:34,200 --> 00:03:38,580
the two that are defined in the spec or

00:03:36,000 --> 00:03:39,989
skip and include there's a bunch of

00:03:38,580 --> 00:03:42,230
other ones he was talking about some

00:03:39,989 --> 00:03:45,540
caching or some roles things like that

00:03:42,230 --> 00:03:50,250
you can also use them to declare default

00:03:45,540 --> 00:03:51,420
values as one possible use case so the

00:03:50,250 --> 00:03:52,920
first scenario that I want to talk about

00:03:51,420 --> 00:03:55,470
or and probably the only scenario that

00:03:52,920 --> 00:03:58,140
all have time to talk about is building

00:03:55,470 --> 00:04:00,269
a new product and when I say building a

00:03:58,140 --> 00:04:03,420
new product I don't just mean brand new

00:04:00,269 --> 00:04:05,370
greenfield project I also mean hey we

00:04:03,420 --> 00:04:07,560
have this Ruby on Rails monolith or we

00:04:05,370 --> 00:04:10,590
have this there was one specific time

00:04:07,560 --> 00:04:12,769
where I was working with docker and we

00:04:10,590 --> 00:04:16,140
had to rewrite the entire docker hub a

00:04:12,769 --> 00:04:18,150
docker hub at the time was to separate

00:04:16,140 --> 00:04:20,400
Python Django applications that were

00:04:18,150 --> 00:04:22,849
hosted on two different URLs that were

00:04:20,400 --> 00:04:25,410
rendering pages they didn't really have

00:04:22,849 --> 00:04:26,640
any cohesive JavaScript on the front end

00:04:25,410 --> 00:04:28,910
and we had to take that we need to break

00:04:26,640 --> 00:04:32,270
it up into a set of API

00:04:28,910 --> 00:04:35,180
and a universal react front-end so when

00:04:32,270 --> 00:04:37,250
I say new product I mean large amount of

00:04:35,180 --> 00:04:40,790
work I don't necessarily mean something

00:04:37,250 --> 00:04:42,380
that you are doing Greenfield and when I

00:04:40,790 --> 00:04:44,270
talk about this I'm gonna use a

00:04:42,380 --> 00:04:48,650
technology called Prisma that came out

00:04:44,270 --> 00:04:51,740
recently I really like Prisma because

00:04:48,650 --> 00:04:53,570
it's SDL first the thing that you do is

00:04:51,740 --> 00:04:56,510
you write the data model as a graph QL

00:04:53,570 --> 00:04:58,700
schema file and as a result of that you

00:04:56,510 --> 00:05:00,890
get all of these generated things that

00:04:58,700 --> 00:05:04,540
you can query generated things that you

00:05:00,890 --> 00:05:07,970
can mutate you have to spend less time

00:05:04,540 --> 00:05:09,800
actively implementing the graph QL API

00:05:07,970 --> 00:05:12,800
and more time thinking about your data

00:05:09,800 --> 00:05:14,480
and how it works and communicating hey

00:05:12,800 --> 00:05:16,250
the front end needs something new we

00:05:14,480 --> 00:05:17,900
need to add a PR to the data model

00:05:16,250 --> 00:05:20,600
instead of write a whole bunch of sequel

00:05:17,900 --> 00:05:26,270
migrations which your front-end team may

00:05:20,600 --> 00:05:27,740
or may not be able to do this is

00:05:26,270 --> 00:05:30,500
normally where I would talk about and

00:05:27,740 --> 00:05:34,150
show a slide of the console output of

00:05:30,500 --> 00:05:36,200
initializing a new product with Prisma

00:05:34,150 --> 00:05:39,440
I'll go through it fairly quickly

00:05:36,200 --> 00:05:42,920
it's Prisma in it you can add it as a

00:05:39,440 --> 00:05:44,780
global there are two options one of them

00:05:42,920 --> 00:05:46,460
is a database only option which is very

00:05:44,780 --> 00:05:50,300
simple it comes with about three files

00:05:46,460 --> 00:05:51,290
and just the schema graph QL file you

00:05:50,300 --> 00:05:52,540
don't really see anything else

00:05:51,290 --> 00:05:55,100
everything else just sort of like

00:05:52,540 --> 00:05:57,560
generated for you without actually being

00:05:55,100 --> 00:05:59,600
a file on disk the other option is a

00:05:57,560 --> 00:06:02,600
graph QL server what they term full

00:05:59,600 --> 00:06:07,280
stack the graph QL full stack is more of

00:06:02,600 --> 00:06:09,470
a you can use this as a database entry

00:06:07,280 --> 00:06:12,380
integration layer and also the graph QL

00:06:09,470 --> 00:06:15,200
API on top so what Brisbane does is it

00:06:12,380 --> 00:06:17,690
croute is it creates a database schema

00:06:15,200 --> 00:06:20,270
from this graph QL file and then what it

00:06:17,690 --> 00:06:23,000
does on top of that is it exposes that

00:06:20,270 --> 00:06:27,110
through an actual user facing graph QL

00:06:23,000 --> 00:06:28,190
API there's about five different boiler

00:06:27,110 --> 00:06:30,500
plates that you can choose from there's

00:06:28,190 --> 00:06:32,510
an basic advanced typescript basic

00:06:30,500 --> 00:06:36,080
advanced and then a react full stack

00:06:32,510 --> 00:06:38,210
basic you might be able to tell from me

00:06:36,080 --> 00:06:40,820
talking about rails and Django that I

00:06:38,210 --> 00:06:41,300
would not suggest doing the full staff

00:06:40,820 --> 00:06:43,280
version

00:06:41,300 --> 00:06:44,750
where you integrate your API and your

00:06:43,280 --> 00:06:47,780
front-end the same codebase and then

00:06:44,750 --> 00:06:51,440
ship it it ends up with a lot of

00:06:47,780 --> 00:06:54,379
complexity and plus when you want to use

00:06:51,440 --> 00:06:55,789
the STL as sort of your basis of

00:06:54,379 --> 00:06:58,520
communication between the front end and

00:06:55,789 --> 00:07:00,349
the back end teams sticking everything

00:06:58,520 --> 00:07:02,629
in one codebase isn't really the thing

00:07:00,349 --> 00:07:04,789
you want to do you want to use that one

00:07:02,629 --> 00:07:06,560
thing as the communication layer and if

00:07:04,789 --> 00:07:08,449
you need to communicate back and forth

00:07:06,560 --> 00:07:09,889
you say hey this field is deprecated I'm

00:07:08,449 --> 00:07:11,720
going to use a directive to mark it as

00:07:09,889 --> 00:07:13,430
deprecated and then when somebody goes

00:07:11,720 --> 00:07:16,699
and introspects the schema in graphical

00:07:13,430 --> 00:07:18,740
or any of the other tools they go oh we

00:07:16,699 --> 00:07:20,949
shouldn't be using this anymore the

00:07:18,740 --> 00:07:23,210
back-end team is going to get rid of it

00:07:20,949 --> 00:07:26,780
and the other thing is after you

00:07:23,210 --> 00:07:28,219
initialize a Prisma project it deploys

00:07:26,780 --> 00:07:30,800
it and you can deploy it to their

00:07:28,219 --> 00:07:33,770
services their clusters which are hosted

00:07:30,800 --> 00:07:37,000
in the cloud and everybody knows how the

00:07:33,770 --> 00:07:39,469
cloud goes so I won't talk about that

00:07:37,000 --> 00:07:43,580
somebody else's server right and then

00:07:39,469 --> 00:07:44,930
there's the local which is docker I mean

00:07:43,580 --> 00:07:47,150
you basically use this docker compose

00:07:44,930 --> 00:07:49,699
under the hood so you deploy this it

00:07:47,150 --> 00:07:53,449
goes to your docker cluster or any of

00:07:49,699 --> 00:07:54,949
the other clusters and when you deploy

00:07:53,449 --> 00:07:59,810
it it actually does a set of schema

00:07:54,949 --> 00:08:01,759
migrations so if you have a post type it

00:07:59,810 --> 00:08:03,650
will go and it will migrate the my

00:08:01,759 --> 00:08:05,409
sequel schema the primary database that

00:08:03,650 --> 00:08:07,880
it uses is my sequel although they have

00:08:05,409 --> 00:08:09,620
future plans support for just about any

00:08:07,880 --> 00:08:13,180
database that you can think of that

00:08:09,620 --> 00:08:16,370
would be applicable including Postgres

00:08:13,180 --> 00:08:20,840
some Google products cockroach DB if

00:08:16,370 --> 00:08:22,219
anybody is deploying that and then the

00:08:20,840 --> 00:08:24,349
other thing it does is it has this seed

00:08:22,219 --> 00:08:27,020
graph QL file and if you've ever worked

00:08:24,349 --> 00:08:30,080
with like docker containers and used

00:08:27,020 --> 00:08:33,770
sequel scripts to bootstrap all of your

00:08:30,080 --> 00:08:35,390
database on boot or on up it's pretty

00:08:33,770 --> 00:08:37,370
much the same thing except executed

00:08:35,390 --> 00:08:42,620
through graphical mutations instead of

00:08:37,370 --> 00:08:44,390
sequel queries so if we treat that

00:08:42,620 --> 00:08:45,829
directory we end up with two different

00:08:44,390 --> 00:08:47,420
folders and our evening

00:08:45,829 --> 00:08:50,510
there's a database folder a source

00:08:47,420 --> 00:08:52,760
folder the database folder has your data

00:08:50,510 --> 00:08:54,260
model docker fql and that's what's used

00:08:52,760 --> 00:08:54,950
to actually do the schema migrations

00:08:54,260 --> 00:08:57,740
against them I see

00:08:54,950 --> 00:08:59,270
database this is where you'll be doing a

00:08:57,740 --> 00:09:01,690
bunch of your work if you're actually

00:08:59,270 --> 00:09:05,000
trying to focus on the data model the

00:09:01,690 --> 00:09:08,540
other files are the generated files and

00:09:05,000 --> 00:09:10,970
source and because the database schema

00:09:08,540 --> 00:09:14,720
file doesn't include the root query and

00:09:10,970 --> 00:09:16,280
mutation types those go in source under

00:09:14,720 --> 00:09:19,070
a file that you can actually modify and

00:09:16,280 --> 00:09:21,140
add new resolvers to if you need to so

00:09:19,070 --> 00:09:22,400
the nice thing about starting a project

00:09:21,140 --> 00:09:24,980
this way or continuing a project this

00:09:22,400 --> 00:09:26,600
way is that not only can you start it

00:09:24,980 --> 00:09:29,330
out like that but it will also grow to

00:09:26,600 --> 00:09:32,120
be as complex as you need it to be so

00:09:29,330 --> 00:09:35,480
the schema in this case is just a post

00:09:32,120 --> 00:09:37,370
it has an ID is published title some

00:09:35,480 --> 00:09:40,730
text typical things that you would have

00:09:37,370 --> 00:09:42,380
an in blog post and then you've got

00:09:40,730 --> 00:09:43,640
default values which here goes back to

00:09:42,380 --> 00:09:46,400
the directives that I was just talking

00:09:43,640 --> 00:09:49,130
about before so if you look at the post

00:09:46,400 --> 00:09:51,800
type you'll see something that says is

00:09:49,130 --> 00:09:55,160
published : boolean which tells you the

00:09:51,800 --> 00:09:57,470
type and then that is required with an

00:09:55,160 --> 00:10:00,290
exclamation point and then the directive

00:09:57,470 --> 00:10:02,090
at default which gives you the ability

00:10:00,290 --> 00:10:07,100
to set a default value in your database

00:10:02,090 --> 00:10:08,750
when you initialize a new object we just

00:10:07,100 --> 00:10:12,440
talked about seed seeds are basically

00:10:08,750 --> 00:10:15,020
just one giant mutation who here if you

00:10:12,440 --> 00:10:20,180
saw three mutations and the same object

00:10:15,020 --> 00:10:24,020
would know where do they execute in talk

00:10:20,180 --> 00:10:26,360
to that guy later basically they all

00:10:24,020 --> 00:10:28,400
execute and in non-deterministically

00:10:26,360 --> 00:10:30,980
right there parallelized they they'd

00:10:28,400 --> 00:10:32,450
aren't you can't depend on one and then

00:10:30,980 --> 00:10:36,110
the other if they're all in the same

00:10:32,450 --> 00:10:38,960
mutation so basically if you are trying

00:10:36,110 --> 00:10:40,550
to seed a bunch of data you want to set

00:10:38,960 --> 00:10:42,560
it up such that you can just insert a

00:10:40,550 --> 00:10:47,300
bunch of objects and then see the

00:10:42,560 --> 00:10:49,310
results this is a nice of the

00:10:47,300 --> 00:10:53,390
playground which is like built on top of

00:10:49,310 --> 00:10:57,350
graphical I know you all can see it it's

00:10:53,390 --> 00:10:59,260
lovely but basically if you--if you

00:10:57,350 --> 00:11:02,000
initialize a new project with Prisma

00:10:59,260 --> 00:11:03,320
what you get with it is a set of NPM

00:11:02,000 --> 00:11:05,990
package scripts and one of them is

00:11:03,320 --> 00:11:08,040
called playground if you start that it

00:11:05,990 --> 00:11:09,449
will start up in a chrome window

00:11:08,040 --> 00:11:11,610
or whatever your default browser is if

00:11:09,449 --> 00:11:13,110
you have the desktop app installed which

00:11:11,610 --> 00:11:14,759
you can do through brew it will actually

00:11:13,110 --> 00:11:16,740
kick up the desktop app and start a new

00:11:14,759 --> 00:11:21,480
workspace for you which is a really nice

00:11:16,740 --> 00:11:23,850
touch and this playground gives you

00:11:21,480 --> 00:11:28,259
access to both the app graph QL API and

00:11:23,850 --> 00:11:29,819
the database graph QL API and it's its

00:11:28,259 --> 00:11:31,440
graphical so if you're familiar with

00:11:29,819 --> 00:11:32,880
graphical it gives you autocomplete it

00:11:31,440 --> 00:11:34,620
gives you schema inspection you can

00:11:32,880 --> 00:11:36,959
click through all of the different types

00:11:34,620 --> 00:11:39,240
that make up the graph QL API which

00:11:36,959 --> 00:11:40,860
means that now that you've built this as

00:11:39,240 --> 00:11:42,180
the backend person or as the first

00:11:40,860 --> 00:11:44,399
person that touched the project the

00:11:42,180 --> 00:11:45,600
front-end team can now either use a

00:11:44,399 --> 00:11:48,300
hosted version of this that you already

00:11:45,600 --> 00:11:50,220
have your PM can use a hosted version of

00:11:48,300 --> 00:11:53,699
this if they want to it's actually

00:11:50,220 --> 00:11:55,190
fairly simple to operate or you can just

00:11:53,699 --> 00:12:00,089
set it up to run in the docker

00:11:55,190 --> 00:12:03,029
environment that you have locally so

00:12:00,089 --> 00:12:04,680
updating in this world looks like just

00:12:03,029 --> 00:12:06,569
changing graph QL types so you've got

00:12:04,680 --> 00:12:09,000
this dot schema file which has a number

00:12:06,569 --> 00:12:12,120
of types and if you want to add

00:12:09,000 --> 00:12:14,040
something to it you just add a new thing

00:12:12,120 --> 00:12:15,930
to the type if you want to rename things

00:12:14,040 --> 00:12:17,579
there rename directives there's unique

00:12:15,930 --> 00:12:19,290
directives all the things that you would

00:12:17,579 --> 00:12:19,769
expect to have in my sequel database

00:12:19,290 --> 00:12:25,440
right

00:12:19,769 --> 00:12:28,380
there's relations the unique is a Cu ID

00:12:25,440 --> 00:12:29,519
so it's globally unique in terms of the

00:12:28,380 --> 00:12:31,019
way that relay would want it to be

00:12:29,519 --> 00:12:32,880
growth globally unique if you were

00:12:31,019 --> 00:12:34,800
accessing it through the node property

00:12:32,880 --> 00:12:38,850
if anybody's familiar with the way that

00:12:34,800 --> 00:12:41,250
real 8 has an that node property and

00:12:38,850 --> 00:12:43,079
then you just run the deploy and the

00:12:41,250 --> 00:12:46,440
deploy goes to your cluster in this case

00:12:43,079 --> 00:12:47,910
it's my local hosted stalker it could be

00:12:46,440 --> 00:12:50,519
in the cloud somewhere it could be

00:12:47,910 --> 00:12:52,649
kubernetes if anybody has a kubernetes

00:12:50,519 --> 00:12:54,660
deploy if anybody has a gke deploy or

00:12:52,649 --> 00:12:58,139
something like that you can actually

00:12:54,660 --> 00:13:04,889
just throw this gamble up run the pods

00:12:58,139 --> 00:13:06,120
and then deploy to that cluster so the

00:13:04,889 --> 00:13:08,310
second scenario that I was going to talk

00:13:06,120 --> 00:13:10,920
about is the sort of front end needs

00:13:08,310 --> 00:13:13,860
more scenario Fernan needs something in

00:13:10,920 --> 00:13:15,329
addition and that's sort of when I would

00:13:13,860 --> 00:13:17,850
bring up Apollo is when I would bring up

00:13:15,329 --> 00:13:19,829
the link state link error all of the

00:13:17,850 --> 00:13:21,000
links but somebody else is actually

00:13:19,829 --> 00:13:23,149
talking about that so I'm going to avoid

00:13:21,000 --> 00:13:23,149
it

00:13:23,180 --> 00:13:27,450
but the one thing I will say is that

00:13:25,590 --> 00:13:29,940
link-state is sort of the expansion

00:13:27,450 --> 00:13:34,170
mechanism for the SDL on the client side

00:13:29,940 --> 00:13:35,460
if you need more state if you have a

00:13:34,170 --> 00:13:37,110
case that you would have normally used

00:13:35,460 --> 00:13:39,120
read UPS for but you want it to be typed

00:13:37,110 --> 00:13:41,190
you want it to be graph QL you want it

00:13:39,120 --> 00:13:42,390
to all be in the same thing you don't

00:13:41,190 --> 00:13:44,580
want three different state management

00:13:42,390 --> 00:13:45,990
libraries in your UI you would use

00:13:44,580 --> 00:13:47,430
something like link state and you would

00:13:45,990 --> 00:13:49,790
write your own resolvers and then use

00:13:47,430 --> 00:13:52,560
them in the same way as everything else

00:13:49,790 --> 00:13:56,310
and for that I'm going to end because

00:13:52,560 --> 00:14:00,710
just about out of time but open to

00:13:56,310 --> 00:14:00,710
questions or you can contact me later

00:14:01,640 --> 00:14:09,039
[Music]

00:14:02,390 --> 00:14:09,039

YouTube URL: https://www.youtube.com/watch?v=xTZkDYZXh14


