Title: Keynote by: Matt DeBergalis, Co-founder and CTO at Apollo
Publication date: 2019-07-19
Playlist: Federation Launch at Apollo Day Seattle 2019
Description: 
	
Captions: 
	00:00:02,480 --> 00:00:07,379
it's great to be here thanks all of you

00:00:04,770 --> 00:00:09,870
for coming it's really exciting as

00:00:07,379 --> 00:00:13,799
Michael said to have a chance to do this

00:00:09,870 --> 00:00:15,870
up in Seattle we've got a great set of

00:00:13,799 --> 00:00:19,080
folks here today I just want to give

00:00:15,870 --> 00:00:20,520
everyone a sense of who's here and how

00:00:19,080 --> 00:00:23,250
much excitement and energy there is

00:00:20,520 --> 00:00:25,529
around graph QL and data graph

00:00:23,250 --> 00:00:27,210
technology we're also live streaming

00:00:25,529 --> 00:00:29,460
this I think there's five or six hundred

00:00:27,210 --> 00:00:31,679
people registered who are watching from

00:00:29,460 --> 00:00:33,809
all over the world to learn about this

00:00:31,679 --> 00:00:35,930
stuff so it's it's really exciting for

00:00:33,809 --> 00:00:39,120
all of us

00:00:35,930 --> 00:00:40,640
Apollo's a special name for us 50 years

00:00:39,120 --> 00:00:44,430
ago today

00:00:40,640 --> 00:00:47,520
Apollo 11 launched for the first man

00:00:44,430 --> 00:00:50,250
moon mission I've been inspired by this

00:00:47,520 --> 00:00:53,000
stuff since I was a little kid I think

00:00:50,250 --> 00:00:56,309
part of it is just like the audacity of

00:00:53,000 --> 00:00:58,199
going to another world part of it is

00:00:56,309 --> 00:00:59,969
national pride for signing up to do

00:00:58,199 --> 00:01:04,680
something really hard and and pulling it

00:00:59,969 --> 00:01:07,590
off part of its the engineering if if

00:01:04,680 --> 00:01:12,090
you're if you're into good system design

00:01:07,590 --> 00:01:13,619
and solving hard problems with good

00:01:12,090 --> 00:01:15,920
technology it doesn't get much better

00:01:13,619 --> 00:01:21,630
than this this is a lot of kerosene

00:01:15,920 --> 00:01:23,189
burning all at once and I don't know

00:01:21,630 --> 00:01:24,750
mostly I just wanted to have a chance to

00:01:23,189 --> 00:01:27,080
watch this with you I think it's really

00:01:24,750 --> 00:01:27,080
cool

00:01:27,150 --> 00:01:32,280
this is 500 frames per second of the

00:01:30,060 --> 00:01:35,670
first couple seconds of launch as the

00:01:32,280 --> 00:01:47,010
the Saturn 5 comes up how about over a

00:01:35,670 --> 00:01:48,540
round of applause for this so I hope

00:01:47,010 --> 00:01:53,040
some of you take some of the same

00:01:48,540 --> 00:01:56,220
inspiration it's it's really amazing to

00:01:53,040 --> 00:01:58,410
see what great technology can do our

00:01:56,220 --> 00:02:00,480
whole industry is directly downstream of

00:01:58,410 --> 00:02:03,440
this rocket and the space program and

00:02:00,480 --> 00:02:05,730
what we built for Apollo and so I think

00:02:03,440 --> 00:02:09,270
it's just amazing to be able to do it on

00:02:05,730 --> 00:02:13,770
on such a cool day here's another thing

00:02:09,270 --> 00:02:17,010
going up into the right this is Apollo

00:02:13,770 --> 00:02:19,740
client downloads week by week and we use

00:02:17,010 --> 00:02:21,960
that as a proxy to understand the

00:02:19,740 --> 00:02:24,870
adoption of graph QL as a whole

00:02:21,960 --> 00:02:26,850
Apollo clients essentially the industry

00:02:24,870 --> 00:02:30,180
standard way of connecting graphical

00:02:26,850 --> 00:02:31,530
clients to a data graph and as I said

00:02:30,180 --> 00:02:34,110
earlier we've just seen incredible

00:02:31,530 --> 00:02:36,290
momentum around this and it's

00:02:34,110 --> 00:02:39,750
interesting to ask what's behind that

00:02:36,290 --> 00:02:41,489
we're not talking about yarn or some

00:02:39,750 --> 00:02:43,170
technology you could adopt in a day or

00:02:41,489 --> 00:02:49,050
two we're talking about a replacement

00:02:43,170 --> 00:02:52,350
for rest right rest and it's interesting

00:02:49,050 --> 00:02:54,600
to ask why there's such excitement to

00:02:52,350 --> 00:02:57,690
make such a major architectural change

00:02:54,600 --> 00:03:00,780
in how we build applications and how we

00:02:57,690 --> 00:03:02,730
connect them to our data and we know a

00:03:00,780 --> 00:03:04,800
lot of the advantages right there's some

00:03:02,730 --> 00:03:06,420
performance benefits to graph QL maybe

00:03:04,800 --> 00:03:07,820
you're writing less code but I think

00:03:06,420 --> 00:03:10,770
there's something more fundamental here

00:03:07,820 --> 00:03:12,780
it's about access to your data and it's

00:03:10,770 --> 00:03:16,170
about getting the value out of your data

00:03:12,780 --> 00:03:19,130
so if we look at an example of a modern

00:03:16,170 --> 00:03:22,800
travel application that we might build

00:03:19,130 --> 00:03:25,280
it's more than just a modern UI it's

00:03:22,800 --> 00:03:28,470
that we've connected the user experience

00:03:25,280 --> 00:03:31,050
to many different kinds of data whether

00:03:28,470 --> 00:03:33,300
it's product inventory machine learning

00:03:31,050 --> 00:03:36,450
personalization recommendations

00:03:33,300 --> 00:03:39,210
real-time pricing all of that has to

00:03:36,450 --> 00:03:40,380
come together to build a modern user

00:03:39,210 --> 00:03:42,030
perience the kind of thing that our

00:03:40,380 --> 00:03:44,970
users expect the kind of thing that we

00:03:42,030 --> 00:03:49,710
can build a business on top of and if

00:03:44,970 --> 00:03:51,930
that's not enough the application has to

00:03:49,710 --> 00:03:53,670
be delivered on this dizzying array now

00:03:51,930 --> 00:03:56,130
of platforms it's not just web and

00:03:53,670 --> 00:03:58,200
mobile it's its voice and IOT and the

00:03:56,130 --> 00:03:59,670
watch and embedded and carplay and God

00:03:58,200 --> 00:04:01,710
knows what's coming next week and just

00:03:59,670 --> 00:04:04,290
on and on and on so we have this

00:04:01,710 --> 00:04:06,510
conundrum where we want to build a great

00:04:04,290 --> 00:04:10,110
user experience we want to connect that

00:04:06,510 --> 00:04:12,180
user to an array of data that's living

00:04:10,110 --> 00:04:13,470
in micro services third party API is

00:04:12,180 --> 00:04:16,680
wherever it may be

00:04:13,470 --> 00:04:17,820
and we find ourselves writing a lot of

00:04:16,680 --> 00:04:19,560
plumbing a lot of point-to-point

00:04:17,820 --> 00:04:21,870
connections to make all that work

00:04:19,560 --> 00:04:23,720
there's an m-by-n problem here as these

00:04:21,870 --> 00:04:27,510
applications and these data sources

00:04:23,720 --> 00:04:29,820
expand and the problem is there's no

00:04:27,510 --> 00:04:31,410
value in that plumbing we signed up to

00:04:29,820 --> 00:04:35,130
make an amazing user experience but what

00:04:31,410 --> 00:04:37,680
we do all day is we write rest endpoints

00:04:35,130 --> 00:04:40,170
backends for front ends we reuse api's

00:04:37,680 --> 00:04:42,420
in different ways and we're really only

00:04:40,170 --> 00:04:44,640
causing problems when we do that it can

00:04:42,420 --> 00:04:46,200
only make the application worse if we

00:04:44,640 --> 00:04:47,760
have a security problem or performance

00:04:46,200 --> 00:04:50,640
flaw or whatever it may be there's no

00:04:47,760 --> 00:04:52,260
value in that plumbing and so the

00:04:50,640 --> 00:04:54,630
solution of course is the data graph

00:04:52,260 --> 00:04:56,820
this is the way out

00:04:54,630 --> 00:05:01,050
and we we throw all that away and

00:04:56,820 --> 00:05:03,960
instead we build a layer that decouples

00:05:01,050 --> 00:05:06,390
our applications from the data that they

00:05:03,960 --> 00:05:08,580
need and in a data graph the

00:05:06,390 --> 00:05:11,070
applications describe what they need in

00:05:08,580 --> 00:05:13,500
the form of a graph QL query and the

00:05:11,070 --> 00:05:15,420
services that we have describe what they

00:05:13,500 --> 00:05:17,550
can provide in the form of a graph to L

00:05:15,420 --> 00:05:19,110
schema and the purpose of the graph

00:05:17,550 --> 00:05:21,450
in-between is the function is a

00:05:19,110 --> 00:05:23,970
marketplace almost like an Amazon Prime

00:05:21,450 --> 00:05:27,300
as a developer building an application I

00:05:23,970 --> 00:05:29,220
can browse the entire menu of what's in

00:05:27,300 --> 00:05:30,570
my organization I don't have to know who

00:05:29,220 --> 00:05:32,970
built it I didn't have to know it

00:05:30,570 --> 00:05:35,160
existed before I needed it and I don't

00:05:32,970 --> 00:05:38,640
have to know how it gets to me into my

00:05:35,160 --> 00:05:40,530
app it's just a layer that lets me

00:05:38,640 --> 00:05:43,110
navigate and take advantage of all that

00:05:40,530 --> 00:05:45,210
information and that to me is the really

00:05:43,110 --> 00:05:48,300
powerful driver behind all this momentum

00:05:45,210 --> 00:05:51,300
is teams realizing with a data graph I

00:05:48,300 --> 00:05:52,040
can build not just faster applications I

00:05:51,300 --> 00:05:54,290
can

00:05:52,040 --> 00:05:55,580
not just with fewer developers it's that

00:05:54,290 --> 00:05:57,590
I i can build things that weren't

00:05:55,580 --> 00:05:59,270
possible before and i can build a rich

00:05:57,590 --> 00:06:03,010
experience that was just out of reach

00:05:59,270 --> 00:06:06,680
for me as a development team before him

00:06:03,010 --> 00:06:08,570
there's a lot to like about this it's

00:06:06,680 --> 00:06:10,640
more than that app dev velocity it's

00:06:08,570 --> 00:06:13,790
also this lets us have a far more

00:06:10,640 --> 00:06:15,290
consistent user experience we'll hear

00:06:13,790 --> 00:06:18,170
more about that later today because

00:06:15,290 --> 00:06:20,180
instead of duplicating code inside each

00:06:18,170 --> 00:06:21,860
client I can centralize a lot of the

00:06:20,180 --> 00:06:23,330
concerns not just around the business

00:06:21,860 --> 00:06:25,820
logic but the whole presentation layer

00:06:23,330 --> 00:06:28,160
of my app into the data graph and I

00:06:25,820 --> 00:06:30,410
think even more exciting and looking for

00:06:28,160 --> 00:06:33,590
their future this is gonna give me a

00:06:30,410 --> 00:06:35,420
deeper understanding of how my data is

00:06:33,590 --> 00:06:38,240
being used then I've ever had before

00:06:35,420 --> 00:06:39,620
we'll see some examples of that but the

00:06:38,240 --> 00:06:41,210
fact that we have this fine-grained

00:06:39,620 --> 00:06:43,910
knowledge is really powerful a really

00:06:41,210 --> 00:06:45,470
exciting opportunity to move beyond what

00:06:43,910 --> 00:06:47,120
was what was possible with the REST API

00:06:45,470 --> 00:06:50,090
s and these point-to-point connections

00:06:47,120 --> 00:06:51,320
we've we've lived with in the past so

00:06:50,090 --> 00:06:53,900
what we want to do today more than

00:06:51,320 --> 00:06:56,510
anything is talk about how you adopt

00:06:53,900 --> 00:07:01,010
this technology what's the journey like

00:06:56,510 --> 00:07:02,690
for going from that first application

00:07:01,010 --> 00:07:04,610
all the way through your entire

00:07:02,690 --> 00:07:07,430
organization being built on a data graph

00:07:04,610 --> 00:07:10,970
and I hope what comes out of this is

00:07:07,430 --> 00:07:13,250
that a lot of this is about how you

00:07:10,970 --> 00:07:15,200
build software it's about process and

00:07:13,250 --> 00:07:17,300
workflow and communication and

00:07:15,200 --> 00:07:19,430
collaboration and it's a big change to

00:07:17,300 --> 00:07:20,780
some of what we do compared to how it

00:07:19,430 --> 00:07:22,970
works in a world where there are fixed

00:07:20,780 --> 00:07:24,920
REST API s and we build apps on top of

00:07:22,970 --> 00:07:26,510
that you're going to need some

00:07:24,920 --> 00:07:27,890
technology along the way to we'll talk

00:07:26,510 --> 00:07:30,380
about that but I want you to get in the

00:07:27,890 --> 00:07:33,230
mindset that this journey is mostly

00:07:30,380 --> 00:07:35,660
about how you build software and how you

00:07:33,230 --> 00:07:39,050
collaborate on what your data means and

00:07:35,660 --> 00:07:40,250
how you're gonna provide it to the

00:07:39,050 --> 00:07:44,360
developers who are gonna take advantage

00:07:40,250 --> 00:07:47,090
of it the first step of of this process

00:07:44,360 --> 00:07:49,940
and I suspect many of you are here and

00:07:47,090 --> 00:07:53,540
it's why you came today is really about

00:07:49,940 --> 00:07:54,980
that first feature on a data graph this

00:07:53,540 --> 00:07:57,380
is all about learning the technology

00:07:54,980 --> 00:07:59,570
this is about learning graph QL the

00:07:57,380 --> 00:08:01,430
query language it's about learning the

00:07:59,570 --> 00:08:02,840
tools that allow you to take advantage

00:08:01,430 --> 00:08:04,969
of this structured data and how you're

00:08:02,840 --> 00:08:07,609
gonna consume it

00:08:04,969 --> 00:08:09,919
and the prize here is seeing your own

00:08:07,609 --> 00:08:13,489
data that already lives in your core

00:08:09,919 --> 00:08:16,009
api's structured as a graph you can

00:08:13,489 --> 00:08:17,629
query that's the magical moment and then

00:08:16,009 --> 00:08:19,279
plumbed that into your user interface

00:08:17,629 --> 00:08:20,929
and you can see the whole end-to-end

00:08:19,279 --> 00:08:23,449
development experience in the whole way

00:08:20,929 --> 00:08:27,409
that this simplifies the the code used

00:08:23,449 --> 00:08:30,319
to have to write by hand a big part of

00:08:27,409 --> 00:08:32,959
this story is the tooling so we're gonna

00:08:30,319 --> 00:08:36,229
we're gonna have some demos of this

00:08:32,959 --> 00:08:39,319
later today as a product engineer this

00:08:36,229 --> 00:08:42,319
trio of technologies a component library

00:08:39,319 --> 00:08:46,059
like react a data technology like Apollo

00:08:42,319 --> 00:08:48,620
backed by strong typing is an incredible

00:08:46,059 --> 00:08:50,600
far more productive development

00:08:48,620 --> 00:08:53,990
experience and I think part of what may

00:08:50,600 --> 00:08:56,059
be exciting to see is that it goes

00:08:53,990 --> 00:08:57,920
beyond the ability to type some graph QL

00:08:56,059 --> 00:08:59,649
instead of hand write some fetching code

00:08:57,920 --> 00:09:02,029
you're gonna see a whole lot of benefits

00:08:59,649 --> 00:09:05,779
and I see some heads nodding for some of

00:09:02,029 --> 00:09:07,279
you who've seen this in terms of the the

00:09:05,779 --> 00:09:08,899
amount of structure you can bring in the

00:09:07,279 --> 00:09:10,250
velocity you get because of that and the

00:09:08,899 --> 00:09:12,620
kind of rich collaboration and

00:09:10,250 --> 00:09:14,660
reusability that comes with having that

00:09:12,620 --> 00:09:17,000
that's just one example and we'll see

00:09:14,660 --> 00:09:18,889
more of this we can wire in a lot of the

00:09:17,000 --> 00:09:20,750
fine-grained information that we have in

00:09:18,889 --> 00:09:22,339
a data graph into our editor right at

00:09:20,750 --> 00:09:24,259
development time we can see how much a

00:09:22,339 --> 00:09:26,870
query is going to cost us in terms of

00:09:24,259 --> 00:09:28,370
milliseconds as we type it because we

00:09:26,870 --> 00:09:30,470
have this predictive ability based on

00:09:28,370 --> 00:09:32,180
what we've seen other queries running on

00:09:30,470 --> 00:09:34,189
the graph look like and to have that

00:09:32,180 --> 00:09:35,720
knowledge at your fingertips as you're

00:09:34,189 --> 00:09:37,550
building your application rather than

00:09:35,720 --> 00:09:40,459
seeing it two months later once you

00:09:37,550 --> 00:09:41,920
rolled out into production is incredibly

00:09:40,459 --> 00:09:44,660
powerful

00:09:41,920 --> 00:09:46,250
the second phase of the journey is about

00:09:44,660 --> 00:09:51,410
going into production with that first

00:09:46,250 --> 00:09:53,750
key product and this is really where you

00:09:51,410 --> 00:09:55,490
start to see the big benefits of a data

00:09:53,750 --> 00:09:57,980
graph this is when you get to delete a

00:09:55,490 --> 00:09:59,329
back-end for a front-end or remove a

00:09:57,980 --> 00:10:02,329
bunch of old rest code that you don't

00:09:59,329 --> 00:10:03,980
want to maintain any longer and this is

00:10:02,329 --> 00:10:06,319
really about establishing the patterns

00:10:03,980 --> 00:10:08,600
for how you're gonna roll this out in

00:10:06,319 --> 00:10:10,639
the future the workflows that you're

00:10:08,600 --> 00:10:13,309
going to use in your organization for

00:10:10,639 --> 00:10:14,689
development and the operational

00:10:13,309 --> 00:10:18,350
practices you're going to put in place

00:10:14,689 --> 00:10:21,290
to protect and maintain that graph

00:10:18,350 --> 00:10:22,999
as its use expands there's great news

00:10:21,290 --> 00:10:24,649
here we have worked with hundreds of

00:10:22,999 --> 00:10:27,769
companies that have gone down this path

00:10:24,649 --> 00:10:31,120
and what's emerged in our conversations

00:10:27,769 --> 00:10:35,300
are a set of best practices for how to

00:10:31,120 --> 00:10:37,459
build and maintain and expand a data

00:10:35,300 --> 00:10:40,939
graph in production and my co-founder

00:10:37,459 --> 00:10:43,399
Jeff and I have written up a summary of

00:10:40,939 --> 00:10:44,689
these at principled graphical calm I

00:10:43,399 --> 00:10:46,309
won't go through each of these here

00:10:44,689 --> 00:10:48,439
today but the point is there are answers

00:10:46,309 --> 00:10:50,540
there's now clarity about the right

00:10:48,439 --> 00:10:52,129
architecture and the right way to think

00:10:50,540 --> 00:10:55,040
about structuring how you're going to

00:10:52,129 --> 00:10:57,740
build a graph one thing that emerges

00:10:55,040 --> 00:10:59,569
that I want to emphasize is the

00:10:57,740 --> 00:11:02,089
importance of taking a product first

00:10:59,569 --> 00:11:05,089
approach to designing this graph and

00:11:02,089 --> 00:11:06,649
what I mean by that is that you really

00:11:05,089 --> 00:11:09,589
want to think about your graph as

00:11:06,649 --> 00:11:11,360
something that serves the exact needs of

00:11:09,589 --> 00:11:13,129
the products and the user experiences

00:11:11,360 --> 00:11:14,839
that you're trying to build in other

00:11:13,129 --> 00:11:17,149
words you're going to start with the

00:11:14,839 --> 00:11:19,699
screen that you want and you want to

00:11:17,149 --> 00:11:22,550
work backwards from that to ask what

00:11:19,699 --> 00:11:25,519
graph what structure of data best serves

00:11:22,550 --> 00:11:28,790
that need and you want to build exactly

00:11:25,519 --> 00:11:30,709
that no more no less and then map that

00:11:28,790 --> 00:11:35,180
to the services the actual capabilities

00:11:30,709 --> 00:11:37,540
that provide the actual data or the are

00:11:35,180 --> 00:11:40,430
PCs that you're going to have to consume

00:11:37,540 --> 00:11:41,839
it's tempting with an API technology to

00:11:40,430 --> 00:11:43,670
go the other direction right it's

00:11:41,839 --> 00:11:46,519
tempting to start with your core api's

00:11:43,670 --> 00:11:48,529
and then build the semantic graph of all

00:11:46,519 --> 00:11:50,059
my data in exactly the right shape and

00:11:48,529 --> 00:11:53,139
what we've found over and again is that

00:11:50,059 --> 00:11:56,930
teams that take a the the other approach

00:11:53,139 --> 00:11:58,430
bump into a lot of friction because they

00:11:56,930 --> 00:12:00,559
don't end up with a graph that's

00:11:58,430 --> 00:12:02,720
optimized for what a product team really

00:12:00,559 --> 00:12:04,399
wants to consume to build that

00:12:02,720 --> 00:12:06,290
technology so I want to leave you with

00:12:04,399 --> 00:12:07,970
that nugget make sure that you're

00:12:06,290 --> 00:12:08,660
involving your product engineers from

00:12:07,970 --> 00:12:10,610
day one

00:12:08,660 --> 00:12:12,649
make sure there's a strong collaboration

00:12:10,610 --> 00:12:14,720
and a thoughtful approach to how you're

00:12:12,649 --> 00:12:17,179
going to design that and make sure that

00:12:14,720 --> 00:12:18,170
you've got an agile process because

00:12:17,179 --> 00:12:19,519
you're gonna add more and more

00:12:18,170 --> 00:12:21,259
applications more and more user

00:12:19,519 --> 00:12:22,819
experiences that depend on the graph

00:12:21,259 --> 00:12:23,990
over time and as you do that you're

00:12:22,819 --> 00:12:25,069
gonna want to change the graph you're

00:12:23,990 --> 00:12:26,600
gonna want to add more to it

00:12:25,069 --> 00:12:28,129
you're gonna want to change some of the

00:12:26,600 --> 00:12:30,200
structure of what you already have and

00:12:28,129 --> 00:12:32,959
you're gonna want tooling and work

00:12:30,200 --> 00:12:35,570
to help you do that here's an example of

00:12:32,959 --> 00:12:36,889
one of those this is called schema

00:12:35,570 --> 00:12:39,529
change validation it's part of the

00:12:36,889 --> 00:12:43,070
Apollo platform and what we're looking

00:12:39,529 --> 00:12:44,990
at here is what happens when a developer

00:12:43,070 --> 00:12:48,079
makes a change to a data graph that's

00:12:44,990 --> 00:12:50,300
not compatible with the applications

00:12:48,079 --> 00:12:52,820
that are in the field and what's really

00:12:50,300 --> 00:12:55,430
cool about graph QL is that we can check

00:12:52,820 --> 00:12:57,500
for that compatibility statically at

00:12:55,430 --> 00:12:59,930
development time there's an algebra that

00:12:57,500 --> 00:13:01,579
we can run we know what the structure of

00:12:59,930 --> 00:13:04,790
the graph is we know the type of every

00:13:01,579 --> 00:13:06,920
field and we know exactly what queries

00:13:04,790 --> 00:13:08,810
the applications that are consuming the

00:13:06,920 --> 00:13:10,670
graph are issuing we have a log a

00:13:08,810 --> 00:13:12,649
structured log of every one of those and

00:13:10,670 --> 00:13:15,079
so based on that information we can

00:13:12,649 --> 00:13:17,029
actually do this calculus of if you want

00:13:15,079 --> 00:13:18,829
to change this field to this type or if

00:13:17,029 --> 00:13:19,880
you want to add this to the enum or if

00:13:18,829 --> 00:13:23,810
you want to do something with an input

00:13:19,880 --> 00:13:25,339
type we can enumerate the exact list of

00:13:23,810 --> 00:13:27,380
clients that would be affected by that

00:13:25,339 --> 00:13:29,540
change and give you all the information

00:13:27,380 --> 00:13:30,860
you need to either take a different

00:13:29,540 --> 00:13:32,510
approach at the graph level or

00:13:30,860 --> 00:13:33,680
collaborate with the consumers of the

00:13:32,510 --> 00:13:35,690
graph so that everything can move

00:13:33,680 --> 00:13:37,790
forward and this stuff isn't as simple

00:13:35,690 --> 00:13:39,410
as just like don't remove a field that

00:13:37,790 --> 00:13:41,089
somebody's using there's a lot of

00:13:39,410 --> 00:13:43,399
subtlety to the sorts of changes that

00:13:41,089 --> 00:13:45,199
you can make in a graph and a lot of

00:13:43,399 --> 00:13:48,890
structure that we can take advantage of

00:13:45,199 --> 00:13:51,260
to give each team an agile process for

00:13:48,890 --> 00:13:53,720
evolving that graph over time without

00:13:51,260 --> 00:13:55,100
breaking the consumers of the graph one

00:13:53,720 --> 00:13:58,399
thing that happens is you go down this

00:13:55,100 --> 00:14:00,890
path is you're gonna start to see more

00:13:58,399 --> 00:14:02,209
and more apps querying the graph you as

00:14:00,890 --> 00:14:04,579
a developer may not have known about

00:14:02,209 --> 00:14:05,930
that's the whole prize in some sense so

00:14:04,579 --> 00:14:07,640
you'll want the structure in place to be

00:14:05,930 --> 00:14:09,019
able to protect yourself from the

00:14:07,640 --> 00:14:11,269
development process that you're you're

00:14:09,019 --> 00:14:12,589
taking here's another example of a tool

00:14:11,269 --> 00:14:14,600
that you'll want in production we call

00:14:12,589 --> 00:14:17,360
this safe listing and the idea here is

00:14:14,600 --> 00:14:19,279
simple it's wonderful that you can write

00:14:17,360 --> 00:14:22,459
an arbitrary graph QL query to consume

00:14:19,279 --> 00:14:23,990
data any way you like in development but

00:14:22,459 --> 00:14:26,449
in production you probably don't want to

00:14:23,990 --> 00:14:28,550
do that you probably don't want a graph

00:14:26,449 --> 00:14:30,740
QL endpoint on the internet that accepts

00:14:28,550 --> 00:14:35,290
an arbitrary query of arbitrary cost or

00:14:30,740 --> 00:14:37,850
complexity right so the model we

00:14:35,290 --> 00:14:38,810
advocate for is where you register the

00:14:37,850 --> 00:14:40,640
queries that you're trusting to

00:14:38,810 --> 00:14:43,370
developers are writing in development

00:14:40,640 --> 00:14:44,060
and then your graph manager pushes that

00:14:43,370 --> 00:14:46,490
configure

00:14:44,060 --> 00:14:49,160
into your data graph layer as a manifest

00:14:46,490 --> 00:14:51,980
or a whitelist or a safe list of all the

00:14:49,160 --> 00:14:56,090
different queries that you can accept in

00:14:51,980 --> 00:14:58,340
production these are examples of tools

00:14:56,090 --> 00:15:01,430
and workflows that aren't part of the

00:14:58,340 --> 00:15:04,220
core technology for executing a graph QL

00:15:01,430 --> 00:15:06,800
query or for consuming a graphical query

00:15:04,220 --> 00:15:09,250
in a UI these are things that live in

00:15:06,800 --> 00:15:13,250
what we call a graph manager a set of

00:15:09,250 --> 00:15:16,400
management tools that sit alongside your

00:15:13,250 --> 00:15:18,680
query execution layer to give you the

00:15:16,400 --> 00:15:20,900
full benefits of the data graph and so

00:15:18,680 --> 00:15:22,460
this is a diagram of how we structure

00:15:20,900 --> 00:15:24,200
this in Apollo the Apollo platform

00:15:22,460 --> 00:15:25,970
really has three pieces there's some

00:15:24,200 --> 00:15:28,190
open source that implements the core

00:15:25,970 --> 00:15:29,720
query execution and query consumption

00:15:28,190 --> 00:15:31,750
technology I think almost everyone here

00:15:29,720 --> 00:15:34,820
knows about Apollo client Apollo server

00:15:31,750 --> 00:15:36,320
there is a graph manager which is a set

00:15:34,820 --> 00:15:38,690
of services that implement things like

00:15:36,320 --> 00:15:39,560
schema change management safe listing

00:15:38,690 --> 00:15:41,510
and some other things we're going to

00:15:39,560 --> 00:15:43,430
show you today and then there's a set of

00:15:41,510 --> 00:15:46,100
integrations that hook off of that graph

00:15:43,430 --> 00:15:50,080
manager to systems like the S code

00:15:46,100 --> 00:15:52,340
slack github page or duty whatever and

00:15:50,080 --> 00:15:54,290
what we want to show you today is

00:15:52,340 --> 00:15:57,620
whether you use this or build some of

00:15:54,290 --> 00:16:00,260
this yourself this is critical to having

00:15:57,620 --> 00:16:01,640
a data graph that multiple developers

00:16:00,260 --> 00:16:03,430
are collaborating on that you can roll

00:16:01,640 --> 00:16:10,520
out into production and evolve over time

00:16:03,430 --> 00:16:12,020
in an agile and safe way okay that takes

00:16:10,520 --> 00:16:14,660
us to the third stage so if the first

00:16:12,020 --> 00:16:16,250
stage is getting your your hands dirty

00:16:14,660 --> 00:16:17,780
with graphical technology and the

00:16:16,250 --> 00:16:19,190
end-to-end development environment and

00:16:17,780 --> 00:16:21,350
the second stage is about putting that

00:16:19,190 --> 00:16:23,420
first critical strategic application

00:16:21,350 --> 00:16:25,040
into production on the graph what comes

00:16:23,420 --> 00:16:26,450
next is really interesting and something

00:16:25,040 --> 00:16:28,850
I want to spend a few minutes on which

00:16:26,450 --> 00:16:30,680
is scaling the graph how do you go from

00:16:28,850 --> 00:16:32,440
something that basically one team built

00:16:30,680 --> 00:16:35,720
to something that the entire

00:16:32,440 --> 00:16:38,150
organization can share as a shared

00:16:35,720 --> 00:16:39,680
strategic layer of the stack that gives

00:16:38,150 --> 00:16:42,050
you these benefits across everything

00:16:39,680 --> 00:16:44,060
you're building and this is where the

00:16:42,050 --> 00:16:47,270
extraordinary benefits in the real prize

00:16:44,060 --> 00:16:50,180
of data graph come into play because now

00:16:47,270 --> 00:16:52,820
we have consistency across the org we

00:16:50,180 --> 00:16:54,050
have reusability across the org and we

00:16:52,820 --> 00:16:55,500
can take advantage of all the things

00:16:54,050 --> 00:16:57,180
I've talked about you

00:16:55,500 --> 00:17:00,960
four teams that don't know much about

00:16:57,180 --> 00:17:02,640
the graph or how its implemented and it

00:17:00,960 --> 00:17:05,550
goes something like this you start small

00:17:02,640 --> 00:17:07,020
and then you expand because that mobile

00:17:05,550 --> 00:17:08,700
team next door to you thinks we'll wait

00:17:07,020 --> 00:17:10,800
a second can't I query the same graph

00:17:08,700 --> 00:17:12,630
you just wrote for the web app and then

00:17:10,800 --> 00:17:14,070
maybe the adjacent internal tools team

00:17:12,630 --> 00:17:15,630
takes advantage of it and they had to

00:17:14,070 --> 00:17:17,730
add a little bit to the graph to support

00:17:15,630 --> 00:17:19,050
their use case and then maybe you go on

00:17:17,730 --> 00:17:20,300
from there and pretty soon you've got

00:17:19,050 --> 00:17:24,350
something that spans the entire

00:17:20,300 --> 00:17:28,320
organization and the conundrum here is

00:17:24,350 --> 00:17:30,360
how do you do this without introducing a

00:17:28,320 --> 00:17:32,670
big monolith or a central choke point

00:17:30,360 --> 00:17:34,560
for development because the idea that

00:17:32,670 --> 00:17:36,420
we're gonna roll out a big graph QL

00:17:34,560 --> 00:17:40,080
server that sits in front of every

00:17:36,420 --> 00:17:42,090
single API we have and sits behind every

00:17:40,080 --> 00:17:43,860
single application we ship doesn't quite

00:17:42,090 --> 00:17:46,260
add up you need a story for how you're

00:17:43,860 --> 00:17:50,250
gonna do that in a safe and distributed

00:17:46,260 --> 00:17:53,490
way with a large team I was remiss

00:17:50,250 --> 00:17:55,470
earlier and not thanking Dan and Jim and

00:17:53,490 --> 00:17:57,330
Shane and the Expedia team we've been

00:17:55,470 --> 00:17:59,490
working together for many months now on

00:17:57,330 --> 00:18:01,860
exactly this problem they're here today

00:17:59,490 --> 00:18:04,140
and you're gonna hear directly from them

00:18:01,860 --> 00:18:05,730
about their experience building this and

00:18:04,140 --> 00:18:08,490
what Expedia is done is really exciting

00:18:05,730 --> 00:18:10,470
they have built a federated data graph

00:18:08,490 --> 00:18:12,390
they've built a data graph where the

00:18:10,470 --> 00:18:13,530
implementation isn't a monolith but it's

00:18:12,390 --> 00:18:15,720
actually distributed across multiple

00:18:13,530 --> 00:18:18,360
graph QL services that are composed

00:18:15,720 --> 00:18:20,580
together into one graph and I want to

00:18:18,360 --> 00:18:24,150
show you what that looks like and how

00:18:20,580 --> 00:18:26,220
we've thought about this problem so the

00:18:24,150 --> 00:18:28,350
way we think about this is you you want

00:18:26,220 --> 00:18:30,750
to split your graph architecture into

00:18:28,350 --> 00:18:35,490
two layers with separate

00:18:30,750 --> 00:18:39,780
responsibilities one layer is a set of

00:18:35,490 --> 00:18:41,550
services each of which implement part of

00:18:39,780 --> 00:18:43,770
your graph and in this example we have a

00:18:41,550 --> 00:18:46,980
product service a review service and

00:18:43,770 --> 00:18:49,140
account service and the key idea here is

00:18:46,980 --> 00:18:51,300
that each of these is going to be owned

00:18:49,140 --> 00:18:52,620
and managed by a separate team possibly

00:18:51,300 --> 00:18:53,850
with a completely different development

00:18:52,620 --> 00:18:56,730
cycle maybe with a different set of

00:18:53,850 --> 00:18:59,700
technologies and each of them is going

00:18:56,730 --> 00:19:01,770
to encapsulate a certain concept a

00:18:59,700 --> 00:19:04,520
certain set of concerns that fit

00:19:01,770 --> 00:19:06,540
together the other part of the layer is

00:19:04,520 --> 00:19:08,130
infrastructure that shared across the

00:19:06,540 --> 00:19:10,860
organization a gate

00:19:08,130 --> 00:19:12,750
and the role of the Gateway is to join

00:19:10,860 --> 00:19:15,240
these together into a single graph and

00:19:12,750 --> 00:19:17,910
let you execute queries against that as

00:19:15,240 --> 00:19:18,929
if it were one graph and internally what

00:19:17,910 --> 00:19:20,700
it's going to do is it's going to break

00:19:18,929 --> 00:19:21,929
that query into pieces and some of its

00:19:20,700 --> 00:19:23,669
going to go to the product service and

00:19:21,929 --> 00:19:26,520
some gonna go the account service and so

00:19:23,669 --> 00:19:28,289
on this is technology that we've been

00:19:26,520 --> 00:19:30,030
working on for a long time we built a

00:19:28,289 --> 00:19:32,250
tool called schema stitching some years

00:19:30,030 --> 00:19:33,360
ago that was a first attempt at this but

00:19:32,250 --> 00:19:36,900
schema stitching had some real

00:19:33,360 --> 00:19:38,250
limitations and we've we've been working

00:19:36,900 --> 00:19:39,539
over the last couple months on something

00:19:38,250 --> 00:19:41,340
that we're really excited about called

00:19:39,539 --> 00:19:42,780
Apollo Federation which takes a much

00:19:41,340 --> 00:19:44,370
more principled and thoughtful approach

00:19:42,780 --> 00:19:48,570
to the problem based on our experience

00:19:44,370 --> 00:19:50,700
working with many of these teams apollo

00:19:48,570 --> 00:19:52,440
federation gets you that proper

00:19:50,700 --> 00:19:54,179
separation of concerns where the code

00:19:52,440 --> 00:19:55,830
for each part of the graph lives in one

00:19:54,179 --> 00:19:58,590
service separate from the others and

00:19:55,830 --> 00:20:02,309
decoupled in terms of its development it

00:19:58,590 --> 00:20:03,690
gets you know code in the gateway so you

00:20:02,309 --> 00:20:05,010
can roll out a gateway as a piece of

00:20:03,690 --> 00:20:07,260
shared infrastructure just like your

00:20:05,010 --> 00:20:08,580
Kafka infrastructure that individual

00:20:07,260 --> 00:20:10,049
developers who are using it don't have

00:20:08,580 --> 00:20:12,480
to touch day-to-day as they build out

00:20:10,049 --> 00:20:15,659
the graph and it gets you this agile way

00:20:12,480 --> 00:20:20,280
of building the graph without having to

00:20:15,659 --> 00:20:23,100
have that single monolith so very end of

00:20:20,280 --> 00:20:25,830
May we release the open source core of

00:20:23,100 --> 00:20:29,130
Apollo Federation James is going to demo

00:20:25,830 --> 00:20:31,530
this for you in just a moment and it

00:20:29,130 --> 00:20:34,770
really came in two pieces support for

00:20:31,530 --> 00:20:37,380
the server to expose a partial graph and

00:20:34,770 --> 00:20:39,059
an open source gateway that can stitch

00:20:37,380 --> 00:20:42,330
that together into a single composed

00:20:39,059 --> 00:20:44,250
graph and execute queries a lot of teams

00:20:42,330 --> 00:20:45,360
have already adopted this in production

00:20:44,250 --> 00:20:49,110
we're now running

00:20:45,360 --> 00:20:51,929
I think closing in on about 10,000

00:20:49,110 --> 00:20:54,929
downloads a week of this technology so

00:20:51,929 --> 00:20:57,299
the the adoption has been really

00:20:54,929 --> 00:20:59,520
exciting cheerful for example in Denver

00:20:57,299 --> 00:21:02,159
has moved from their production graph QL

00:20:59,520 --> 00:21:04,020
layer using schema stitching to using

00:21:02,159 --> 00:21:05,190
the Apollo Federation technology in

00:21:04,020 --> 00:21:07,020
production and they've been able to

00:21:05,190 --> 00:21:09,500
eliminate a lot of the the fragile

00:21:07,020 --> 00:21:11,669
stitching code as a result of that

00:21:09,500 --> 00:21:13,289
there's another half of the story though

00:21:11,669 --> 00:21:17,390
and what were you've just released today

00:21:13,289 --> 00:21:20,640
is what we call managed federation and

00:21:17,390 --> 00:21:21,330
managed federation is the other piece of

00:21:20,640 --> 00:21:21,940
the puzzle

00:21:21,330 --> 00:21:23,860
it's the

00:21:21,940 --> 00:21:26,860
and the workflows the stuff that lives

00:21:23,860 --> 00:21:29,190
in the graph manager that helps you

00:21:26,860 --> 00:21:32,740
coordinate and collaborate on a large

00:21:29,190 --> 00:21:36,310
distributed graph and these are all

00:21:32,740 --> 00:21:38,830
about how do I organize my development

00:21:36,310 --> 00:21:40,900
process how do I wire up my DevOps

00:21:38,830 --> 00:21:43,000
process and how do I manage and monitor

00:21:40,900 --> 00:21:44,790
what ends up now being a distributed

00:21:43,000 --> 00:21:47,560
system that my entire team is sharing

00:21:44,790 --> 00:21:50,680
and I want to show you an example of

00:21:47,560 --> 00:21:52,690
what that looks like so at the heart of

00:21:50,680 --> 00:21:54,160
this is a list of services that

00:21:52,690 --> 00:21:57,490
implement your graph and so from the

00:21:54,160 --> 00:21:59,080
graph manager for example we can get the

00:21:57,490 --> 00:22:00,280
list of implementing services for a

00:21:59,080 --> 00:22:01,870
graph each of them is going to be a

00:22:00,280 --> 00:22:05,680
separate micro service running somewhere

00:22:01,870 --> 00:22:08,170
and we can start to track the history of

00:22:05,680 --> 00:22:10,690
those over time and the partial graph

00:22:08,170 --> 00:22:13,720
that each of them implements and you'll

00:22:10,690 --> 00:22:15,460
see all of this in more detail and it's

00:22:13,720 --> 00:22:17,170
all up on the Apollo documentation now

00:22:15,460 --> 00:22:19,930
something you can play with and we hope

00:22:17,170 --> 00:22:21,580
you take a look there's some workflows

00:22:19,930 --> 00:22:24,550
that that enables and I'll just give you

00:22:21,580 --> 00:22:26,830
a taste to this we talked about schema

00:22:24,550 --> 00:22:28,510
change control earlier schema change

00:22:26,830 --> 00:22:30,040
control in a distributed graph is even

00:22:28,510 --> 00:22:31,480
more important because I'm gonna have

00:22:30,040 --> 00:22:33,700
multiple teams each working on a

00:22:31,480 --> 00:22:36,880
particular piece of the graph and in

00:22:33,700 --> 00:22:39,280
this example if the product team makes a

00:22:36,880 --> 00:22:42,040
change to its part of the graph what we

00:22:39,280 --> 00:22:44,470
need to be able to do is first compose

00:22:42,040 --> 00:22:47,050
that with the rest of the services that

00:22:44,470 --> 00:22:50,200
make up the whole graph and then test

00:22:47,050 --> 00:22:54,370
that in development against the known

00:22:50,200 --> 00:22:56,110
use of the graph as a whole and manage

00:22:54,370 --> 00:22:59,190
Federation does that so you'll see an

00:22:56,110 --> 00:23:01,900
example of how we can catch a

00:22:59,190 --> 00:23:03,850
incompatibility at build time even in

00:23:01,900 --> 00:23:06,670
the context of just one service that

00:23:03,850 --> 00:23:08,950
makes up the complete graph here's the

00:23:06,670 --> 00:23:11,080
other key workflow when you want to make

00:23:08,950 --> 00:23:15,340
a change that is good how do you

00:23:11,080 --> 00:23:17,320
coordinate with the other teams and with

00:23:15,340 --> 00:23:19,120
the overall graph kill gateway what we

00:23:17,320 --> 00:23:21,790
see at a lot of companies is the rise of

00:23:19,120 --> 00:23:23,950
not just micro services but cloud native

00:23:21,790 --> 00:23:26,230
technology like envoy or SDO or

00:23:23,950 --> 00:23:27,940
spinnaker that allow teams to have

00:23:26,230 --> 00:23:30,100
really sophisticated deployment

00:23:27,940 --> 00:23:32,020
strategies for each of their micro

00:23:30,100 --> 00:23:35,500
services and the graph QL implementing

00:23:32,020 --> 00:23:37,650
services are no exception so I managed

00:23:35,500 --> 00:23:40,990
excuse me a managed Federation

00:23:37,650 --> 00:23:43,510
architecture is one that allows you to

00:23:40,990 --> 00:23:46,360
coordinate the rollout of an individual

00:23:43,510 --> 00:23:48,970
service with an update to the overall

00:23:46,360 --> 00:23:52,450
graph schema that your organization uses

00:23:48,970 --> 00:23:54,130
and the upshot is a team that owns the

00:23:52,450 --> 00:23:56,169
review service for example can publish a

00:23:54,130 --> 00:23:56,860
change using their existing tools and

00:23:56,169 --> 00:23:59,350
workflows

00:23:56,860 --> 00:23:59,830
they don't need administrative access to

00:23:59,350 --> 00:24:02,890
the Gateway

00:23:59,830 --> 00:24:06,280
instead the manager recomposes the new

00:24:02,890 --> 00:24:08,260
schema based on the latest definition of

00:24:06,280 --> 00:24:10,929
the graph from each service and then

00:24:08,260 --> 00:24:12,909
pushes that configuration into the

00:24:10,929 --> 00:24:15,549
Gateway which can then smoothly

00:24:12,909 --> 00:24:17,380
transition clients from the old schema

00:24:15,549 --> 00:24:19,120
and the old set of services to the new

00:24:17,380 --> 00:24:21,549
schema and the new set of services and

00:24:19,120 --> 00:24:23,200
so the prize here is this agile

00:24:21,549 --> 00:24:24,730
decoupled development process that

00:24:23,200 --> 00:24:26,650
everyone's looking for you no longer

00:24:24,730 --> 00:24:29,200
have a single point of failure you no

00:24:26,650 --> 00:24:30,850
longer have that fragile user code and

00:24:29,200 --> 00:24:32,980
you've allowed each team to iterate at

00:24:30,850 --> 00:24:34,799
its own pace and on its own schedule but

00:24:32,980 --> 00:24:36,640
together what you've built is a

00:24:34,799 --> 00:24:39,490
strategic asset for the whole

00:24:36,640 --> 00:24:42,400
organization something that applications

00:24:39,490 --> 00:24:44,049
can consume no matter which team they're

00:24:42,400 --> 00:24:45,640
on or which parts of the graph they're

00:24:44,049 --> 00:24:47,230
most interested in and they consume it

00:24:45,640 --> 00:24:49,240
without knowing the implementation

00:24:47,230 --> 00:24:51,640
details of what data lives in what

00:24:49,240 --> 00:24:54,610
service so we're really excited about

00:24:51,640 --> 00:24:56,409
this this is something that's been I'd

00:24:54,610 --> 00:24:57,940
say a long time coming and if I can come

00:24:56,409 --> 00:24:59,650
back to the principles for just a moment

00:24:57,940 --> 00:25:02,890
the first three principles that we've

00:24:59,650 --> 00:25:04,480
talked about kind of the bedrock of a

00:25:02,890 --> 00:25:06,820
data graph strategy for a company that's

00:25:04,480 --> 00:25:09,190
thinking about scale is you want one

00:25:06,820 --> 00:25:10,570
graph for your whole company but you

00:25:09,190 --> 00:25:12,400
want to distribute an implementation of

00:25:10,570 --> 00:25:14,909
that graph and that means you need a

00:25:12,400 --> 00:25:16,870
place to track the history of that graph

00:25:14,909 --> 00:25:19,590
that's separate from its own

00:25:16,870 --> 00:25:22,450
implementation those first three are

00:25:19,590 --> 00:25:24,100
really the keys to success when you're

00:25:22,450 --> 00:25:26,559
in that scale phase of building out a

00:25:24,100 --> 00:25:27,820
large graph and with manage Federation

00:25:26,559 --> 00:25:30,370
we think we've got it we think we've got

00:25:27,820 --> 00:25:31,600
the building blocks the teams need to be

00:25:30,370 --> 00:25:34,360
able to roll forward with this

00:25:31,600 --> 00:25:37,210
technology incrementally and

00:25:34,360 --> 00:25:38,650
successfully so we'll talk more about

00:25:37,210 --> 00:25:40,809
this over the course of the day we're

00:25:38,650 --> 00:25:44,320
all here to answer questions and of

00:25:40,809 --> 00:25:46,360
course as I said tons of documentation

00:25:44,320 --> 00:25:48,160
and examples online of how this works

00:25:46,360 --> 00:25:51,130
and how you can get started

00:25:48,160 --> 00:25:53,110
and let me leave with with one last

00:25:51,130 --> 00:25:55,030
stage if we've built a graph and the

00:25:53,110 --> 00:25:57,760
graph spans the org and now we've got

00:25:55,030 --> 00:25:59,850
something that exposes the the real

00:25:57,760 --> 00:26:02,230
meaning of our data and makes it visible

00:25:59,850 --> 00:26:03,910
it's interesting to think about what you

00:26:02,230 --> 00:26:05,500
can do beyond just developing

00:26:03,910 --> 00:26:07,300
applications and we've seen some

00:26:05,500 --> 00:26:08,910
examples of this starting to emerge in

00:26:07,300 --> 00:26:11,500
lots of companies and it's stuff that

00:26:08,910 --> 00:26:13,300
for us is a big part of our roadmap and

00:26:11,500 --> 00:26:15,550
how we want to think about the future of

00:26:13,300 --> 00:26:18,280
data graph a really good example

00:26:15,550 --> 00:26:20,080
Republican partner aap is right why

00:26:18,280 --> 00:26:21,760
would I make my partner's consume data

00:26:20,080 --> 00:26:23,140
through these narrow straws why don't I

00:26:21,760 --> 00:26:25,060
just give them the graph and that's a

00:26:23,140 --> 00:26:27,010
really exciting direction there are some

00:26:25,060 --> 00:26:30,340
examples like github and Shopify that

00:26:27,010 --> 00:26:32,050
have had public graphical api's and the

00:26:30,340 --> 00:26:34,390
benefits to the partner ecosystem are

00:26:32,050 --> 00:26:35,950
really extraordinary if you're thinking

00:26:34,390 --> 00:26:38,290
about your own company as a platform

00:26:35,950 --> 00:26:40,480
maybe more and more and less about the

00:26:38,290 --> 00:26:42,040
actual apps that you're shipping this is

00:26:40,480 --> 00:26:45,300
a really interesting direction to think

00:26:42,040 --> 00:26:47,650
about and and to set the stage for

00:26:45,300 --> 00:26:48,730
you're also going to find a lot of use

00:26:47,650 --> 00:26:51,730
of the graph that isn't just an

00:26:48,730 --> 00:26:55,360
application we've found teams at many of

00:26:51,730 --> 00:26:57,580
our customers that are coming in Monday

00:26:55,360 --> 00:26:59,650
morning and they discover a script or a

00:26:57,580 --> 00:27:01,120
little internal admin tool or something

00:26:59,650 --> 00:27:03,850
that someone's written that consumes the

00:27:01,120 --> 00:27:07,030
graph because why not and so it's

00:27:03,850 --> 00:27:09,970
exciting to think about a world where a

00:27:07,030 --> 00:27:11,620
bi team or a customer support team can

00:27:09,970 --> 00:27:13,240
directly consume the graph or write a

00:27:11,620 --> 00:27:15,010
little piece of software to use the data

00:27:13,240 --> 00:27:17,200
graph instead of having to block on

00:27:15,010 --> 00:27:18,820
software development and we all know how

00:27:17,200 --> 00:27:21,730
painful it can be to get those sort of

00:27:18,820 --> 00:27:22,450
other line of business apps or internal

00:27:21,730 --> 00:27:23,680
tools built

00:27:22,450 --> 00:27:26,140
I think the graph is a really

00:27:23,680 --> 00:27:28,030
interesting opportunity to simplify that

00:27:26,140 --> 00:27:29,380
and to expose data to more of the

00:27:28,030 --> 00:27:32,290
company beyond just the application

00:27:29,380 --> 00:27:34,300
engineers and finally I'll leave you

00:27:32,290 --> 00:27:36,370
with this thought if the graph gives us

00:27:34,300 --> 00:27:37,810
this really precise knowledge of who's

00:27:36,370 --> 00:27:39,130
consuming our data and how they're

00:27:37,810 --> 00:27:41,200
consuming it and how that changes over

00:27:39,130 --> 00:27:44,440
time I think that has extraordinary

00:27:41,200 --> 00:27:48,930
implications for security and privacy

00:27:44,440 --> 00:27:52,150
and and legal questions like GDP are

00:27:48,930 --> 00:27:54,610
right we know that the expectations now

00:27:52,150 --> 00:27:57,330
for development teams are higher than

00:27:54,610 --> 00:28:00,940
ever in terms of being responsible

00:27:57,330 --> 00:28:02,290
stewards of the data that we own

00:28:00,940 --> 00:28:03,820
and I think what we're gonna find is

00:28:02,290 --> 00:28:06,850
that the data graph becomes a really

00:28:03,820 --> 00:28:08,710
natural place to enforce policy and to

00:28:06,850 --> 00:28:10,960
get our individual development teams out

00:28:08,710 --> 00:28:13,480
of the business of having to bake some

00:28:10,960 --> 00:28:15,280
of these ideas into the code itself and

00:28:13,480 --> 00:28:16,960
instead letting it be something that we

00:28:15,280 --> 00:28:19,720
can think of as a governance layer on

00:28:16,960 --> 00:28:22,780
top of the data we have and that's I

00:28:19,720 --> 00:28:24,430
think a really exciting direction so I

00:28:22,780 --> 00:28:27,790
want to thank you I want to thank you

00:28:24,430 --> 00:28:29,440
for coming I want to encourage you to

00:28:27,790 --> 00:28:31,390
ask questions and learn from each other

00:28:29,440 --> 00:28:35,590
today this is an event that we're really

00:28:31,390 --> 00:28:37,250
excited about and hope you get a lot out

00:28:35,590 --> 00:28:44,709
of it thank you very much

00:28:37,250 --> 00:28:44,709

YouTube URL: https://www.youtube.com/watch?v=X8g0JlS3mZw


