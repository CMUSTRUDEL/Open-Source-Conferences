Title: Creating a federated schema for a global company by: Shane Myrick, SSD at Expedia Group
Publication date: 2019-07-19
Playlist: Federation Launch at Apollo Day Seattle 2019
Description: 
	
Captions: 
	00:00:03,470 --> 00:00:08,910
all right yeah there we go hi hello

00:00:06,899 --> 00:00:11,550
everyone my name is Shayne Myrick

00:00:08,910 --> 00:00:13,920
so I'm from Expedia group and today I'm

00:00:11,550 --> 00:00:16,230
going to be talking about how we went

00:00:13,920 --> 00:00:23,400
from a previous REST API model to a

00:00:16,230 --> 00:00:25,859
federated graph QL model so yeah so

00:00:23,400 --> 00:00:28,019
today we've already heard about some of

00:00:25,859 --> 00:00:30,720
the new methods that Apollo is building

00:00:28,019 --> 00:00:32,700
for federated graph QL and some of the

00:00:30,720 --> 00:00:34,530
tooling this has actually been our

00:00:32,700 --> 00:00:36,450
journey through the initial kind of

00:00:34,530 --> 00:00:38,070
concept of graph QL and what we

00:00:36,450 --> 00:00:40,320
previously heard of is schema stitching

00:00:38,070 --> 00:00:42,329
so we this is kind of the journey and

00:00:40,320 --> 00:00:44,370
what we've learned over the past year or

00:00:42,329 --> 00:00:45,870
so doing graph QL and how we're gonna be

00:00:44,370 --> 00:00:47,910
working towards this new federated model

00:00:45,870 --> 00:00:51,539
but just heads up this is not the

00:00:47,910 --> 00:00:53,489
federated model you saw earlier today so

00:00:51,539 --> 00:00:55,770
just to start off you might have heard I

00:00:53,489 --> 00:00:58,020
said Expedia group Expedia group is

00:00:55,770 --> 00:01:01,829
actually a collection of 25 different

00:00:58,020 --> 00:01:04,650
brands and I work for specifically these

00:01:01,829 --> 00:01:07,380
brands and a group of Expedia group and

00:01:04,650 --> 00:01:08,850
we over the years of our companies we've

00:01:07,380 --> 00:01:10,409
built lots of different technology to

00:01:08,850 --> 00:01:12,960
provide products to our customers

00:01:10,409 --> 00:01:15,990
so things like hotels cars flights

00:01:12,960 --> 00:01:17,820
activities etc and all these different

00:01:15,990 --> 00:01:20,250
products are managed by different teams

00:01:17,820 --> 00:01:23,430
those teams can be all across the globe

00:01:20,250 --> 00:01:26,909
we have offices here in Seattle offices

00:01:23,430 --> 00:01:29,070
in London Chicago India Brisbane and so

00:01:26,909 --> 00:01:31,079
a lot of these teams off to work

00:01:29,070 --> 00:01:33,630
together and that could be sometimes

00:01:31,079 --> 00:01:36,540
very difficult sharing across time zones

00:01:33,630 --> 00:01:39,030
doing remote meetings communication

00:01:36,540 --> 00:01:40,790
across these different boundaries and

00:01:39,030 --> 00:01:43,110
cultural differences can kind of lead to

00:01:40,790 --> 00:01:45,689
just different ways on how we develop

00:01:43,110 --> 00:01:47,520
our products so we were noticing some

00:01:45,689 --> 00:01:48,869
discrepancies when we kind of started

00:01:47,520 --> 00:01:51,360
looking back at what we were building

00:01:48,869 --> 00:01:53,220
for our customers today so we actually

00:01:51,360 --> 00:01:55,710
first started our graph QL journey by

00:01:53,220 --> 00:01:57,570
looking at our traveler experience so if

00:01:55,710 --> 00:02:00,180
I'm someone coming to one of our brands

00:01:57,570 --> 00:02:01,860
like let's say Expedia I'm going to

00:02:00,180 --> 00:02:03,869
possibly want to book a hotel and a

00:02:01,860 --> 00:02:04,920
flight to a new destination maybe in

00:02:03,869 --> 00:02:07,170
that destination I'm gonna use some

00:02:04,920 --> 00:02:09,300
activities so here's just some general

00:02:07,170 --> 00:02:11,280
screenshots of what search results might

00:02:09,300 --> 00:02:14,459
look like on all those different

00:02:11,280 --> 00:02:16,290
pages you might notice they look similar

00:02:14,459 --> 00:02:18,300
ish right they're all using kind of the

00:02:16,290 --> 00:02:20,250
same colors they were displayed in a

00:02:18,300 --> 00:02:21,569
list but really if we kind of kind of

00:02:20,250 --> 00:02:23,370
break down to some of these details

00:02:21,569 --> 00:02:25,230
there's just things that are different

00:02:23,370 --> 00:02:26,430
that really don't need to be and if we

00:02:25,230 --> 00:02:28,020
want to provide a consistent experience

00:02:26,430 --> 00:02:29,880
to our customers we want everything to

00:02:28,020 --> 00:02:32,190
look the same and make sure everyone's

00:02:29,880 --> 00:02:34,560
seen the same information so things like

00:02:32,190 --> 00:02:36,030
the filters and sort selection right in

00:02:34,560 --> 00:02:38,489
one page it might be at the top and you

00:02:36,030 --> 00:02:40,230
might have an optional input bar we

00:02:38,489 --> 00:02:41,580
could add more information versus like

00:02:40,230 --> 00:02:42,959
on our mobile app they're down at the

00:02:41,580 --> 00:02:45,630
bottom you have to press a button to

00:02:42,959 --> 00:02:46,739
open up a new page and sure that's fine

00:02:45,630 --> 00:02:48,570
right it's different experiences

00:02:46,739 --> 00:02:50,400
different teams building the apps but

00:02:48,570 --> 00:02:52,500
really that's leading to an experience

00:02:50,400 --> 00:02:55,050
where their traveller is using the UI

00:02:52,500 --> 00:02:56,670
and a different model on one page and

00:02:55,050 --> 00:02:58,170
then transitioning to buying a different

00:02:56,670 --> 00:03:00,030
product they're still on the same site

00:02:58,170 --> 00:03:01,260
but now they have to use in a different

00:03:00,030 --> 00:03:03,870
matter and that just kind of leads to a

00:03:01,260 --> 00:03:06,209
jarring experience but not only is the

00:03:03,870 --> 00:03:09,390
UI different sometimes our data would be

00:03:06,209 --> 00:03:10,920
different so we have right here on the

00:03:09,390 --> 00:03:12,630
left side there's this little module

00:03:10,920 --> 00:03:15,480
which tells you if you're booking a

00:03:12,630 --> 00:03:17,340
hotel in Maui we know the inventory for

00:03:15,480 --> 00:03:19,530
that region on the dates are searching

00:03:17,340 --> 00:03:21,630
and maybe it's really sold up right it's

00:03:19,530 --> 00:03:25,380
99% booked so you might want to consider

00:03:21,630 --> 00:03:27,810
booking a hotel that API is provided by

00:03:25,380 --> 00:03:29,340
a specific team they might have you know

00:03:27,810 --> 00:03:32,610
REST API and documentation that you have

00:03:29,340 --> 00:03:34,470
to use and this other team who maybe is

00:03:32,610 --> 00:03:36,180
using a different page maybe they're not

00:03:34,470 --> 00:03:38,630
even using consuming that API because

00:03:36,180 --> 00:03:40,500
they don't know that team exists so in

00:03:38,630 --> 00:03:42,239
overall you might even get different

00:03:40,500 --> 00:03:44,489
experiences on the data that you show

00:03:42,239 --> 00:03:46,410
your customers so this is what we really

00:03:44,489 --> 00:03:48,239
wanted to change if we wanted to align

00:03:46,410 --> 00:03:50,609
our traveler experience we needed to

00:03:48,239 --> 00:03:55,019
first make sure that we're showing the

00:03:50,609 --> 00:03:57,380
same data to all our customers all right

00:03:55,019 --> 00:04:00,060
so how do we kind of get to that

00:03:57,380 --> 00:04:02,910
separated experience well like with most

00:04:00,060 --> 00:04:05,040
companies we have a lot of domain teams

00:04:02,910 --> 00:04:06,720
here at the bottom we have our hotels

00:04:05,040 --> 00:04:08,940
flights cars all the same as I mentioned

00:04:06,720 --> 00:04:10,890
before and they provide a set of api's

00:04:08,940 --> 00:04:13,650
and it's not just a single API

00:04:10,890 --> 00:04:15,209
you know the hotel's API team that

00:04:13,650 --> 00:04:16,620
provides lots of different API is to

00:04:15,209 --> 00:04:18,750
provide the shopping experience to our

00:04:16,620 --> 00:04:21,359
customers and they have to somehow

00:04:18,750 --> 00:04:23,099
connect to all the clients here at the

00:04:21,359 --> 00:04:24,569
top so we have our web

00:04:23,099 --> 00:04:27,030
there might be the desktop and the

00:04:24,569 --> 00:04:29,250
mobile web we have our iOS native

00:04:27,030 --> 00:04:31,220
applications maybe even some new clients

00:04:29,250 --> 00:04:33,599
going forward like Alexa and chatbots

00:04:31,220 --> 00:04:34,500
and so they have to of course

00:04:33,599 --> 00:04:37,710
they have to connect to all these

00:04:34,500 --> 00:04:39,509
different services so as a client if I

00:04:37,710 --> 00:04:41,430
know I will need to provide some new

00:04:39,509 --> 00:04:43,319
product to our our customers or

00:04:41,430 --> 00:04:44,849
travelers after first know that this

00:04:43,319 --> 00:04:46,979
product even exists in their company

00:04:44,849 --> 00:04:49,199
like I said write that API that provides

00:04:46,979 --> 00:04:50,880
the booking availability I might not

00:04:49,199 --> 00:04:52,590
even know as a client team that someone

00:04:50,880 --> 00:04:54,090
actually made that API in Expedia

00:04:52,590 --> 00:04:56,130
because we're a fairly large company but

00:04:54,090 --> 00:04:57,960
let's say I do know this team exists

00:04:56,130 --> 00:04:59,220
they're making this API then I have to

00:04:57,960 --> 00:05:01,530
go talk with that team I have to

00:04:59,220 --> 00:05:02,909
possibly say the amount of traffic I'm

00:05:01,530 --> 00:05:04,860
gonna be sending this team so they can

00:05:02,909 --> 00:05:06,770
provide an appropriate scaling I have to

00:05:04,860 --> 00:05:09,569
read their documentation I have to

00:05:06,770 --> 00:05:11,430
understand how their REST API works you

00:05:09,569 --> 00:05:13,380
know we already need to provide certain

00:05:11,430 --> 00:05:15,360
keys and you just have to do all this

00:05:13,380 --> 00:05:17,370
back and forth communication before you

00:05:15,360 --> 00:05:19,460
even start thinking about sending a

00:05:17,370 --> 00:05:22,080
sample request or even using their data

00:05:19,460 --> 00:05:24,419
but then not other than that on the

00:05:22,080 --> 00:05:26,490
domain side on the bottom side of the

00:05:24,419 --> 00:05:28,380
API team you also have to manage all the

00:05:26,490 --> 00:05:29,880
different clients right so let's say you

00:05:28,380 --> 00:05:31,889
have all your client list out there

00:05:29,880 --> 00:05:34,229
let's say you want to deprecated a field

00:05:31,889 --> 00:05:36,090
or a deprecating API right you have to

00:05:34,229 --> 00:05:37,770
then send out these mass emails to every

00:05:36,090 --> 00:05:40,620
single client saying hey we're gonna

00:05:37,770 --> 00:05:42,900
turn this off on two weeks that hard

00:05:40,620 --> 00:05:44,159
deadline better be migrated of course we

00:05:42,900 --> 00:05:45,690
reach that two weeks you know it's

00:05:44,159 --> 00:05:47,130
migrated so we just gotta keep sending

00:05:45,690 --> 00:05:49,500
on with these emails over and over again

00:05:47,130 --> 00:05:50,969
right so it's just kind of hard to have

00:05:49,500 --> 00:05:53,430
this back-and-forth communication and

00:05:50,969 --> 00:05:55,169
then that just scales even exponentially

00:05:53,430 --> 00:05:57,569
when again we're talking about not just

00:05:55,169 --> 00:05:58,770
teams working in possibly the same

00:05:57,569 --> 00:06:00,330
office but we're talking about teams

00:05:58,770 --> 00:06:03,060
working across the globe and across

00:06:00,330 --> 00:06:06,360
different time zones so we kind of

00:06:03,060 --> 00:06:07,979
started to reduce our concepts here or

00:06:06,360 --> 00:06:09,690
reduce the kind of friction the

00:06:07,979 --> 00:06:11,400
interaction points we had when we

00:06:09,690 --> 00:06:13,229
started moving into a PWA

00:06:11,400 --> 00:06:15,659
which is a progressive web application

00:06:13,229 --> 00:06:17,759
and a BFF which is a back-end for

00:06:15,659 --> 00:06:19,560
front-end this was kind of one of our

00:06:17,759 --> 00:06:22,620
first goals the main goal here was to

00:06:19,560 --> 00:06:25,590
reduce the amount of client code that

00:06:22,620 --> 00:06:27,780
the PWA has so that it also reduces the

00:06:25,590 --> 00:06:28,889
amount of business logic it has right so

00:06:27,780 --> 00:06:30,900
if we want to move all the business

00:06:28,889 --> 00:06:32,759
object back to the server that means we

00:06:30,900 --> 00:06:34,710
can consolidate all the connections

00:06:32,759 --> 00:06:37,349
coming out of the BFF it can handle

00:06:34,710 --> 00:06:38,729
doing all that data connection bringing

00:06:37,349 --> 00:06:40,559
up the appropriate data to the client

00:06:38,729 --> 00:06:42,689
and then the client can just be worried

00:06:40,559 --> 00:06:44,729
about displaying the data in a view

00:06:42,689 --> 00:06:46,589
specific manner and it reduces all the

00:06:44,729 --> 00:06:48,389
logic reduces the client payload and

00:06:46,589 --> 00:06:50,490
makes the app faster for everyone and

00:06:48,389 --> 00:06:52,499
this went great we learned a lot from

00:06:50,490 --> 00:06:54,509
implementing this pattern we are

00:06:52,499 --> 00:06:56,039
actually going to be you know rolling we

00:06:54,509 --> 00:06:58,559
really believe that the PWA is a good

00:06:56,039 --> 00:07:01,020
pattern going forward but if we wanted

00:06:58,559 --> 00:07:03,150
to roll this out for any of the other

00:07:01,020 --> 00:07:04,919
applications not just maybe on the

00:07:03,150 --> 00:07:07,710
lodging but the flights team or even on

00:07:04,919 --> 00:07:09,990
iOS or Android we realized we had to do

00:07:07,710 --> 00:07:11,370
a BFF for every single application

00:07:09,990 --> 00:07:13,439
because they were all just slightly

00:07:11,370 --> 00:07:15,689
different and if we're just adding

00:07:13,439 --> 00:07:17,460
another BFF for every single service

00:07:15,689 --> 00:07:18,899
that really isn't solving anything now

00:07:17,460 --> 00:07:20,279
we're just having another layer in

00:07:18,899 --> 00:07:23,339
between the different data connections

00:07:20,279 --> 00:07:25,499
so what we really needed was a BFF for

00:07:23,339 --> 00:07:28,080
every single service a BFF for everyone

00:07:25,499 --> 00:07:29,460
so this is where graph QL comes in

00:07:28,080 --> 00:07:31,770
alright we've all kind of heard the

00:07:29,460 --> 00:07:33,479
story of how graph QL can unify our

00:07:31,770 --> 00:07:35,370
schema and we have one single schema now

00:07:33,479 --> 00:07:36,870
served to the clients the clients don't

00:07:35,370 --> 00:07:38,580
have to worry about where the data is

00:07:36,870 --> 00:07:39,930
coming from or setting up these

00:07:38,580 --> 00:07:41,729
connections once you kind of get

00:07:39,930 --> 00:07:43,409
on-boarded you do that initial setup of

00:07:41,729 --> 00:07:44,789
connecting to the graph then you just

00:07:43,409 --> 00:07:46,409
write your queries and you don't have to

00:07:44,789 --> 00:07:48,599
worry about that communication back and

00:07:46,409 --> 00:07:52,409
forth between the teams and this is

00:07:48,599 --> 00:07:54,360
exactly what we wanted to do however as

00:07:52,409 --> 00:07:57,029
I mentioned before the hotels domain

00:07:54,360 --> 00:07:59,310
team is a large organization they have

00:07:57,029 --> 00:08:01,639
tons of api's lots of developers on

00:07:59,310 --> 00:08:04,379
contribute I looked at just the

00:08:01,639 --> 00:08:06,449
contributors of the BFF the for the

00:08:04,379 --> 00:08:08,099
lodging BFFs but the other day we had

00:08:06,449 --> 00:08:10,469
over a hundred and fifty contributors to

00:08:08,099 --> 00:08:12,599
that codebase so that's a lot of people

00:08:10,469 --> 00:08:15,479
for just one section of this little

00:08:12,599 --> 00:08:17,069
graph alright so if we wanted to scale

00:08:15,479 --> 00:08:19,319
this out to everyone we couldn't have

00:08:17,069 --> 00:08:22,139
every single team contributing to one

00:08:19,319 --> 00:08:24,089
single graph QL codebase or API or

00:08:22,139 --> 00:08:25,919
schema so we know right from the start

00:08:24,089 --> 00:08:28,559
we actually had to kind of come up with

00:08:25,919 --> 00:08:30,120
this concept of federated schema which

00:08:28,559 --> 00:08:32,519
it means that we actually let the

00:08:30,120 --> 00:08:35,219
individual domain teams create their own

00:08:32,519 --> 00:08:36,750
graph QL services so hotels can own the

00:08:35,219 --> 00:08:39,990
service that provides the data for

00:08:36,750 --> 00:08:42,539
hotels and the landing search pages that

00:08:39,990 --> 00:08:44,040
you might see and then the customer team

00:08:42,539 --> 00:08:45,840
can provide all the customer data

00:08:44,040 --> 00:08:47,280
or maybe the checkout team can provide

00:08:45,840 --> 00:08:49,350
all the checkout day that you might need

00:08:47,280 --> 00:08:51,300
and then it's up to the top level

00:08:49,350 --> 00:08:54,000
gateway to then just stitch those all

00:08:51,300 --> 00:08:55,890
together into one top level schema that

00:08:54,000 --> 00:08:57,630
the clients interact with so now we have

00:08:55,890 --> 00:08:59,790
the benefit of clients interacting with

00:08:57,630 --> 00:09:01,110
this just a single interaction point but

00:08:59,790 --> 00:09:03,330
the teams themselves can still be

00:09:01,110 --> 00:09:04,950
isolated and kind of focus on their

00:09:03,330 --> 00:09:08,370
areas of their domain that they really

00:09:04,950 --> 00:09:09,810
understand and this has just been kind

00:09:08,370 --> 00:09:13,560
of the goal of how we've been going

00:09:09,810 --> 00:09:15,960
forward is making sure that all these

00:09:13,560 --> 00:09:18,300
teams can provide these new graphical

00:09:15,960 --> 00:09:20,040
micro services in a quick manner because

00:09:18,300 --> 00:09:21,960
we were currently on the rest of

00:09:20,040 --> 00:09:23,580
architecture so how do we migrate from

00:09:21,960 --> 00:09:26,280
rest to getting all these teams to

00:09:23,580 --> 00:09:27,990
create these micro services well we

00:09:26,280 --> 00:09:31,920
needed to kind of have some technology

00:09:27,990 --> 00:09:34,230
changes right so first off we needed to

00:09:31,920 --> 00:09:36,240
kind of work with our teams with

00:09:34,230 --> 00:09:38,490
authorities existing technology stacks

00:09:36,240 --> 00:09:40,710
that we've had so a lot of those API

00:09:38,490 --> 00:09:42,870
teams they're using they're using Java

00:09:40,710 --> 00:09:45,180
and lots of platform libraries which are

00:09:42,870 --> 00:09:46,560
Expedia is specific so we needed to

00:09:45,180 --> 00:09:48,150
still integrate with those teams so that

00:09:46,560 --> 00:09:52,530
means we need to do graphic you'll

00:09:48,150 --> 00:09:54,300
servers in Java we also needed to kind

00:09:52,530 --> 00:09:55,560
of talk with the teams that they they

00:09:54,300 --> 00:09:57,570
were doing because a lot of the teams

00:09:55,560 --> 00:09:59,250
since they were isolated they could do

00:09:57,570 --> 00:10:01,680
stuff on their own they were building

00:09:59,250 --> 00:10:03,510
their server technologies differently so

00:10:01,680 --> 00:10:05,400
some teams we're using spring boots some

00:10:03,510 --> 00:10:07,020
teams are using drop wizard some teams

00:10:05,400 --> 00:10:09,590
were logging their metrics and Splunk

00:10:07,020 --> 00:10:13,110
some teams are logging their metrics in

00:10:09,590 --> 00:10:14,670
in sorry in a cloud watch or just

00:10:13,110 --> 00:10:16,080
anywhere anywhere in week you might have

00:10:14,670 --> 00:10:17,910
your metrics library teams are doing it

00:10:16,080 --> 00:10:19,080
differently and we wanted teams to kind

00:10:17,910 --> 00:10:20,790
of make sure if they're getting on board

00:10:19,080 --> 00:10:24,030
to this graph cue ball platform they're

00:10:20,790 --> 00:10:25,890
all doing it similar which means that we

00:10:24,030 --> 00:10:28,890
needed to kind of start changing the

00:10:25,890 --> 00:10:31,110
developer experience so we first start

00:10:28,890 --> 00:10:34,410
off looking at okay if we want to do a

00:10:31,110 --> 00:10:36,420
graph QL Java server we want we looked

00:10:34,410 --> 00:10:38,670
into the graphical Java open source

00:10:36,420 --> 00:10:40,070
library it's a great library maintained

00:10:38,670 --> 00:10:44,670
by a great community it's very active

00:10:40,070 --> 00:10:47,010
however we noticed that we wanted to add

00:10:44,670 --> 00:10:49,230
some more features on top of that server

00:10:47,010 --> 00:10:51,450
implementation we really enjoy using

00:10:49,230 --> 00:10:53,220
kopplin at Expedia it provides some

00:10:51,450 --> 00:10:54,899
great developer tooling

00:10:53,220 --> 00:10:56,910
you know the language is really rich and

00:10:54,899 --> 00:10:59,009
it has this great feature of null

00:10:56,910 --> 00:11:00,779
ability so in Kotlin you can say

00:10:59,009 --> 00:11:03,120
something is null or it might not be a

00:11:00,779 --> 00:11:05,819
port it is nullable whereas a non novel

00:11:03,120 --> 00:11:08,550
same thing with graph QL and so we knew

00:11:05,819 --> 00:11:10,560
that that we could use these tools

00:11:08,550 --> 00:11:13,079
together to kind of provide some new

00:11:10,560 --> 00:11:14,550
schema generation for a graphical Java

00:11:13,079 --> 00:11:17,279
server which I'll talk about in a little

00:11:14,550 --> 00:11:19,529
bit so not until only on top of that if

00:11:17,279 --> 00:11:21,899
we're going to be building this server

00:11:19,529 --> 00:11:24,329
with all these different tools we wanted

00:11:21,899 --> 00:11:27,149
teams to be able to easily onboard onto

00:11:24,329 --> 00:11:28,649
this graph QL architecture and if they

00:11:27,149 --> 00:11:30,360
wanted to create that little graph QL

00:11:28,649 --> 00:11:33,209
service in between the clients and the

00:11:30,360 --> 00:11:35,129
Gateway and their existing API they

00:11:33,209 --> 00:11:37,379
needed to quickly be able to spin up a

00:11:35,129 --> 00:11:39,600
new graphical service so we started

00:11:37,379 --> 00:11:40,620
standardizing some of the metrics some

00:11:39,600 --> 00:11:42,569
of the logging some of the server

00:11:40,620 --> 00:11:45,089
technologies and we just provide a

00:11:42,569 --> 00:11:46,769
template for our teams to kind of fork

00:11:45,089 --> 00:11:49,170
that template and then from there they

00:11:46,769 --> 00:11:50,939
can easily just add their business logic

00:11:49,170 --> 00:11:53,069
and then their schema can then be

00:11:50,939 --> 00:11:54,300
exposed up into the graph and now since

00:11:53,069 --> 00:11:56,129
we're all using the same technology we

00:11:54,300 --> 00:11:58,050
all get the same metrics we can kind of

00:11:56,129 --> 00:12:00,209
coordinate with teams better and we have

00:11:58,050 --> 00:12:02,129
an SDK which everyone kind of consumes

00:12:00,209 --> 00:12:03,990
so if we need to roll up new graphical

00:12:02,129 --> 00:12:07,019
features or tools everyone can just

00:12:03,990 --> 00:12:08,399
update their SDK SDK version and we can

00:12:07,019 --> 00:12:10,680
now coordinator with all these teams

00:12:08,399 --> 00:12:14,910
managing both the servers and at the

00:12:10,680 --> 00:12:16,290
gateway level as well and then also we

00:12:14,910 --> 00:12:17,879
needed to kind of standardize some of

00:12:16,290 --> 00:12:22,259
the tools we're doing around our schema

00:12:17,879 --> 00:12:24,300
stitching so right now we have before we

00:12:22,259 --> 00:12:26,100
are doing our first pass a graph QL we

00:12:24,300 --> 00:12:28,649
just kind of took the schema we just

00:12:26,100 --> 00:12:30,569
started with one hotel schema and we

00:12:28,649 --> 00:12:32,399
brought it up to the Loom and it just

00:12:30,569 --> 00:12:34,199
kind of exposed the schema but we

00:12:32,399 --> 00:12:35,970
realized that if we wanted to add more

00:12:34,199 --> 00:12:38,639
tools for the developer experience to

00:12:35,970 --> 00:12:40,949
catch any schema breaking breakages

00:12:38,639 --> 00:12:42,029
anything that might go wrong making sure

00:12:40,949 --> 00:12:44,009
that you're stitching the schema

00:12:42,029 --> 00:12:46,620
properly or not you know adding in a

00:12:44,009 --> 00:12:47,970
field which might cause some errors when

00:12:46,620 --> 00:12:49,589
you did also kind of standardize the

00:12:47,970 --> 00:12:51,389
developer experience for schema

00:12:49,589 --> 00:12:54,240
stitching as well as you're doing your

00:12:51,389 --> 00:12:55,980
server development so first off let's

00:12:54,240 --> 00:12:59,069
kind of talk about the generating that

00:12:55,980 --> 00:13:02,760
schema so we actually open sourced the

00:12:59,069 --> 00:13:04,829
graph QL Kotlin which is an extended

00:13:02,760 --> 00:13:06,630
just an extension on top of graph QL

00:13:04,829 --> 00:13:08,279
Java so if you're using graphical Java

00:13:06,630 --> 00:13:10,889
today what you can do is if you are

00:13:08,279 --> 00:13:13,019
coding that server in Kotlin instead of

00:13:10,889 --> 00:13:14,699
writing a schema file which normally

00:13:13,019 --> 00:13:16,980
traditionally you write a separate graph

00:13:14,699 --> 00:13:19,800
Kuehl schema file or maybe just writing

00:13:16,980 --> 00:13:21,899
it in a string format you can instead

00:13:19,800 --> 00:13:23,940
just write your column code as if it's a

00:13:21,899 --> 00:13:27,360
function so you write a function like

00:13:23,940 --> 00:13:29,420
get hotels and that might accept some

00:13:27,360 --> 00:13:33,360
optional arguments and their returns

00:13:29,420 --> 00:13:35,250
graph Kotlin data model and that what we

00:13:33,360 --> 00:13:37,529
do is we just use reflection looking at

00:13:35,250 --> 00:13:39,120
that function that turns into a

00:13:37,529 --> 00:13:40,680
graphical schema it is called the same

00:13:39,120 --> 00:13:42,449
it's called by the same field it returns

00:13:40,680 --> 00:13:44,810
the same object types and just allows

00:13:42,449 --> 00:13:47,070
our developers to not worry about

00:13:44,810 --> 00:13:48,930
maintaining two sources of truth of the

00:13:47,070 --> 00:13:50,339
schema file and your code you can just

00:13:48,930 --> 00:13:52,230
write your function which is your con

00:13:50,339 --> 00:13:53,790
function and that's your schema it just

00:13:52,230 --> 00:13:56,550
makes it a lot easier to kind of go back

00:13:53,790 --> 00:14:00,420
and forth so if you want to check us out

00:13:56,550 --> 00:14:04,350
on github graphical Kotlin and up there

00:14:00,420 --> 00:14:06,720
and github and then also since we have

00:14:04,350 --> 00:14:08,990
this sdk and we have all these different

00:14:06,720 --> 00:14:11,699
services and everyone's using the same

00:14:08,990 --> 00:14:14,639
same domain types we wanted to make sure

00:14:11,699 --> 00:14:15,959
that if let's say the host hell's team

00:14:14,639 --> 00:14:17,600
since we're doing schema stitching they

00:14:15,959 --> 00:14:19,740
added a new type and they called it

00:14:17,600 --> 00:14:22,170
coordinates right corners are pretty

00:14:19,740 --> 00:14:23,670
common as far as a tribal goes right we

00:14:22,170 --> 00:14:25,800
needed to know where a specific point is

00:14:23,670 --> 00:14:27,690
on the globe so at coordinates might

00:14:25,800 --> 00:14:28,920
have a latitude and longitude well if

00:14:27,690 --> 00:14:30,839
we're doing schema stitching if the

00:14:28,920 --> 00:14:32,910
hotel's team added that into their

00:14:30,839 --> 00:14:34,680
schema that would actually conflict if

00:14:32,910 --> 00:14:36,510
the flights team wanted to add it into

00:14:34,680 --> 00:14:38,100
their schema because we don't know which

00:14:36,510 --> 00:14:39,720
one is the source of truth with it right

00:14:38,100 --> 00:14:41,399
that they had actually conflict in the

00:14:39,720 --> 00:14:43,589
schema stitcher which means we needed to

00:14:41,399 --> 00:14:44,730
have some way of sharing types across

00:14:43,589 --> 00:14:47,459
the different services

00:14:44,730 --> 00:14:49,589
so in our sdk we actually have this

00:14:47,459 --> 00:14:51,300
concept of a shared type it's just

00:14:49,589 --> 00:14:53,279
simply marked with a little directive at

00:14:51,300 --> 00:14:55,529
shared really just an information marker

00:14:53,279 --> 00:14:57,329
in the schema but this just is actually

00:14:55,529 --> 00:14:59,730
code that's checked in into our sdk

00:14:57,329 --> 00:15:01,829
which then all the schema developers can

00:14:59,730 --> 00:15:03,990
use i mean it provides some consistency

00:15:01,829 --> 00:15:06,480
so we all are using the same information

00:15:03,990 --> 00:15:08,160
so we did this with some pretty core

00:15:06,480 --> 00:15:10,589
concepts like coordinates

00:15:08,160 --> 00:15:12,839
you know geo points regions things like

00:15:10,589 --> 00:15:13,850
that we also did it for things in our UI

00:15:12,839 --> 00:15:16,100
so

00:15:13,850 --> 00:15:18,140
rather than just returning a date-time

00:15:16,100 --> 00:15:20,510
object we have a date/time object which

00:15:18,140 --> 00:15:22,280
has a localized stream so you can always

00:15:20,510 --> 00:15:24,320
everyone's going to see the same format

00:15:22,280 --> 00:15:27,230
for a date so you no longer going to see

00:15:24,320 --> 00:15:29,840
a date in you know month month day day

00:15:27,230 --> 00:15:31,130
year year on ones one page and it might

00:15:29,840 --> 00:15:32,990
be year first on the other page

00:15:31,130 --> 00:15:35,690
everyone's going to have the consistent

00:15:32,990 --> 00:15:37,340
date formatting on the same pages same

00:15:35,690 --> 00:15:39,170
thing goes with currency right like do

00:15:37,340 --> 00:15:41,360
we round the currency to the nearest

00:15:39,170 --> 00:15:43,490
cent or do round to the nearest dollar

00:15:41,360 --> 00:15:44,960
right that type of business logic

00:15:43,490 --> 00:15:46,760
shouldn't be determined by each

00:15:44,960 --> 00:15:48,650
individual team it should really just be

00:15:46,760 --> 00:15:50,180
something kind of company-wide unless

00:15:48,650 --> 00:15:51,650
there's some specific reason why it

00:15:50,180 --> 00:15:53,540
needs to be different all right but if

00:15:51,650 --> 00:15:54,920
we had a company law decision that means

00:15:53,540 --> 00:15:56,870
we all get the same formatting we all

00:15:54,920 --> 00:16:01,130
get the same experience across three

00:15:56,870 --> 00:16:02,810
different travelers so speaking of this

00:16:01,130 --> 00:16:05,030
stitching let's say we have these shared

00:16:02,810 --> 00:16:06,800
types the first thing that we did to

00:16:05,030 --> 00:16:08,870
kind of implement the schema stitching

00:16:06,800 --> 00:16:11,630
of going getting the schema back into

00:16:08,870 --> 00:16:13,910
the gateway was that we had all of this

00:16:11,630 --> 00:16:15,050
we have all our services here so we have

00:16:13,910 --> 00:16:16,820
the graphical gateway and we have

00:16:15,050 --> 00:16:19,790
individual services the first approach

00:16:16,820 --> 00:16:21,680
we had was just to write a simple

00:16:19,790 --> 00:16:23,600
polling code we put this code in the

00:16:21,680 --> 00:16:25,550
Gateway and what I would do is the

00:16:23,600 --> 00:16:27,860
individual graphical services would

00:16:25,550 --> 00:16:28,940
expose an endpoint which expose the

00:16:27,860 --> 00:16:30,710
schema so we could just hit that

00:16:28,940 --> 00:16:32,510
endpoint and say hey give us your latest

00:16:30,710 --> 00:16:34,010
schema what's your schema right now and

00:16:32,510 --> 00:16:36,170
we just ran that on a polling operation

00:16:34,010 --> 00:16:38,060
and we'd update if we noticed there was

00:16:36,170 --> 00:16:40,400
any changes we just update the graph

00:16:38,060 --> 00:16:43,040
kill gateway schema and we just expose

00:16:40,400 --> 00:16:44,420
that as the new master schema this

00:16:43,040 --> 00:16:46,340
obviously didn't work too well because

00:16:44,420 --> 00:16:48,380
sometimes what if the polling operation

00:16:46,340 --> 00:16:49,990
had some errors maybe teams deployed

00:16:48,380 --> 00:16:52,850
something that they weren't supposed to

00:16:49,990 --> 00:16:55,010
we kind of quickly realized that this

00:16:52,850 --> 00:16:57,890
was not the best model going forward so

00:16:55,010 --> 00:16:59,180
our v2 for schema stitching kind of

00:16:57,890 --> 00:17:01,610
looks a little something like this now

00:16:59,180 --> 00:17:05,120
so let's say we have the flight service

00:17:01,610 --> 00:17:07,940
here they make a change we do our checks

00:17:05,120 --> 00:17:10,790
on the only change and let's say it gets

00:17:07,940 --> 00:17:13,420
merged in so what happens is that schema

00:17:10,790 --> 00:17:16,160
actually gets generated on build time

00:17:13,420 --> 00:17:18,470
before that was deployed and we push

00:17:16,160 --> 00:17:19,809
that up to a s3 bucket so it's just

00:17:18,470 --> 00:17:22,629
somewhere it's stored

00:17:19,809 --> 00:17:24,129
and then what we have is actually a AWS

00:17:22,629 --> 00:17:25,629
lambda which is watching all these

00:17:24,129 --> 00:17:27,159
storage locations for all the different

00:17:25,629 --> 00:17:30,249
schemas and whenever something is

00:17:27,159 --> 00:17:32,320
modified then that stitcher can run the

00:17:30,249 --> 00:17:34,359
same code which we previously had in our

00:17:32,320 --> 00:17:36,070
gateway we move that out of the Gateway

00:17:34,359 --> 00:17:37,539
and now can run the same code to stitch

00:17:36,070 --> 00:17:41,619
this Phoenix together do any extra

00:17:37,539 --> 00:17:43,869
validations and then push that up to the

00:17:41,619 --> 00:17:45,219
gateway so not only does it just push it

00:17:43,869 --> 00:17:47,409
to the gateway but we actually push it

00:17:45,219 --> 00:17:51,399
to another s3 bucket which is now our

00:17:47,409 --> 00:17:53,019
history of the public schema so since we

00:17:51,399 --> 00:17:55,330
kind of moved this process into our

00:17:53,019 --> 00:17:58,509
build pipeline we can now now add more

00:17:55,330 --> 00:18:00,159
extra metadata around our schema so we

00:17:58,509 --> 00:18:01,359
can now say ok this is the get hash

00:18:00,159 --> 00:18:03,519
that's how we actually tagged the

00:18:01,359 --> 00:18:05,469
version that is currently deployed but

00:18:03,519 --> 00:18:07,599
we can add Expedia specific information

00:18:05,469 --> 00:18:09,729
like what was the SDK version used to

00:18:07,599 --> 00:18:11,379
build this schema what was the logging

00:18:09,729 --> 00:18:12,519
libraries they were using anything we

00:18:11,379 --> 00:18:14,229
can just kind of keep track of more

00:18:12,519 --> 00:18:16,389
metadata since it's now being published

00:18:14,229 --> 00:18:18,789
into our own repository of our schema

00:18:16,389 --> 00:18:20,679
diversity and not only that since we're

00:18:18,789 --> 00:18:24,039
now kind of putting it into the pipeline

00:18:20,679 --> 00:18:26,169
we started pushing our tools into the

00:18:24,039 --> 00:18:27,639
Apollo schema registry so this is where

00:18:26,169 --> 00:18:29,409
we started connecting with the Apollo

00:18:27,639 --> 00:18:32,379
team and kind of talking about how we

00:18:29,409 --> 00:18:33,940
were doing Federation and what that what

00:18:32,379 --> 00:18:36,369
their plans were for the schema registry

00:18:33,940 --> 00:18:39,159
and their Federation going forward and

00:18:36,369 --> 00:18:41,200
we started using some other tools so as

00:18:39,159 --> 00:18:44,349
we saw earlier since we're pushing the

00:18:41,200 --> 00:18:47,379
schema into a registry we can now look

00:18:44,349 --> 00:18:49,029
at the types and a nice UI so using

00:18:47,379 --> 00:18:51,789
Apollo engine which I guess it's now

00:18:49,029 --> 00:18:53,950
called graph manager and then not only

00:18:51,789 --> 00:18:55,690
that do we have the schema registry but

00:18:53,950 --> 00:18:58,509
we have the usage information right so

00:18:55,690 --> 00:19:00,099
now we can see that the clients here the

00:18:58,509 --> 00:19:01,960
number of clients using the specific

00:19:00,099 --> 00:19:03,909
field on a property like the ID image

00:19:01,960 --> 00:19:06,070
name but also the operations they're

00:19:03,909 --> 00:19:09,099
performing so if we need to talk with a

00:19:06,070 --> 00:19:11,080
specific client because they are using a

00:19:09,099 --> 00:19:12,729
deprecated field we can exact we can see

00:19:11,080 --> 00:19:14,499
exactly that client that's using that

00:19:12,729 --> 00:19:17,499
operation where it's coming from and

00:19:14,499 --> 00:19:19,239
what kind of data they're sending us so

00:19:17,499 --> 00:19:22,269
if we have this registry of this

00:19:19,239 --> 00:19:23,799
information we can now actually validate

00:19:22,269 --> 00:19:26,769
the schema changes right so we can look

00:19:23,799 --> 00:19:29,320
at the usages someone's made a change we

00:19:26,769 --> 00:19:31,330
can run a github check on PR time to

00:19:29,320 --> 00:19:32,790
validate that hey your skin your schema

00:19:31,330 --> 00:19:34,890
change which you might

00:19:32,790 --> 00:19:37,110
no you made because all you did is write

00:19:34,890 --> 00:19:39,150
a simple Kotlin function you might have

00:19:37,110 --> 00:19:41,250
actually broken the schema this kind of

00:19:39,150 --> 00:19:43,170
has been a really really helpful for us

00:19:41,250 --> 00:19:44,910
because because we made the developer

00:19:43,170 --> 00:19:46,980
experience of creating a schema so easy

00:19:44,910 --> 00:19:48,870
often as we were training new developers

00:19:46,980 --> 00:19:50,970
they they didn't realize that just

00:19:48,870 --> 00:19:53,460
adding a new field into a common data

00:19:50,970 --> 00:19:55,110
class actually impacted the end result

00:19:53,460 --> 00:19:57,990
of the schema so now we can validate

00:19:55,110 --> 00:19:59,850
this on PR time and kind of push these

00:19:57,990 --> 00:20:04,800
changes lowering the stock and catch

00:19:59,850 --> 00:20:08,280
them earlier so now we have all these

00:20:04,800 --> 00:20:09,930
great technology changes we needed to

00:20:08,280 --> 00:20:12,120
start rolling them out to the other

00:20:09,930 --> 00:20:13,920
teams and you can't just do this by

00:20:12,120 --> 00:20:16,980
saying here's the tools go ahead have

00:20:13,920 --> 00:20:18,660
fun we needed to actually start training

00:20:16,980 --> 00:20:20,520
teams and talking about what graph QL

00:20:18,660 --> 00:20:23,520
means and how you use these tools and

00:20:20,520 --> 00:20:24,930
this kind of requires more of a personal

00:20:23,520 --> 00:20:26,310
connection culture changes in our

00:20:24,930 --> 00:20:28,410
company which people are not used to

00:20:26,310 --> 00:20:30,120
right we're not used to having to work

00:20:28,410 --> 00:20:32,220
in a single graph we're used to having

00:20:30,120 --> 00:20:34,080
our own teams working their silos they

00:20:32,220 --> 00:20:35,910
make their API they have full control

00:20:34,080 --> 00:20:37,350
but now if we're working in a single

00:20:35,910 --> 00:20:39,870
graph we actually have to talk with each

00:20:37,350 --> 00:20:41,790
other we have to sit down and say like

00:20:39,870 --> 00:20:43,680
why does this data need to exist on our

00:20:41,790 --> 00:20:47,340
graph what business value are you

00:20:43,680 --> 00:20:49,350
providing and so we needed to maintain

00:20:47,340 --> 00:20:51,390
our graph in some way and we noticed

00:20:49,350 --> 00:20:53,700
that we couldn't just let the team's

00:20:51,390 --> 00:20:56,970
contribute to the graph as they see fit

00:20:53,700 --> 00:20:58,590
we needed to have some responsibilities

00:20:56,970 --> 00:21:00,660
of what actually went into the graph and

00:20:58,590 --> 00:21:03,450
so we first started with this concept of

00:21:00,660 --> 00:21:06,000
a schema manager which is or schema

00:21:03,450 --> 00:21:07,860
managers and the core team for graph QL

00:21:06,000 --> 00:21:10,500
and that's actually the team that I work

00:21:07,860 --> 00:21:12,090
on so we kind of are the team that

00:21:10,500 --> 00:21:14,760
coordinates between all the different

00:21:12,090 --> 00:21:16,320
teams providing graph QL services and we

00:21:14,760 --> 00:21:17,760
bring them together to make sure that

00:21:16,320 --> 00:21:19,590
they are all understanding of how we

00:21:17,760 --> 00:21:21,000
want to do graph QL because you can do

00:21:19,590 --> 00:21:22,800
graph QL in lots of different ways at

00:21:21,000 --> 00:21:25,620
your company but the way that we wanted

00:21:22,800 --> 00:21:26,580
to implement graph QL and we want to

00:21:25,620 --> 00:21:27,930
make sure everyone's doing the same

00:21:26,580 --> 00:21:30,540
thing using all our tools that we

00:21:27,930 --> 00:21:33,600
provided with us in the SDK or in all

00:21:30,540 --> 00:21:35,880
our development tools and making sure

00:21:33,600 --> 00:21:37,200
that we coordinate together so now

00:21:35,880 --> 00:21:40,110
therefore actually bringing teams

00:21:37,200 --> 00:21:42,240
together we can now have meetings where

00:21:40,110 --> 00:21:43,679
previously the hotel's team

00:21:42,240 --> 00:21:45,059
and the flight's team would never talk

00:21:43,679 --> 00:21:46,410
to each other there's no reason for them

00:21:45,059 --> 00:21:49,020
to talk but now if they're actually

00:21:46,410 --> 00:21:50,250
coming into a single graph now we can

00:21:49,020 --> 00:21:51,480
actually talk about things that might be

00:21:50,250 --> 00:21:53,370
doing similar that they never even

00:21:51,480 --> 00:21:55,500
realized we can start sharing code

00:21:53,370 --> 00:21:57,900
sharing ideas and it's just been a

00:21:55,500 --> 00:21:59,910
really big shift in the way that our

00:21:57,900 --> 00:22:01,230
teams communicate now that we're again

00:21:59,910 --> 00:22:02,940
spread across the globe

00:22:01,230 --> 00:22:05,550
it's kind of been a big culture shift

00:22:02,940 --> 00:22:07,679
forever and to kind of get used to so we

00:22:05,550 --> 00:22:09,210
wanted to define some of those best

00:22:07,679 --> 00:22:10,860
practices like what would does a good

00:22:09,210 --> 00:22:12,809
graph cool scheme look like for us at

00:22:10,860 --> 00:22:14,880
Expedia and for us the first thing we

00:22:12,809 --> 00:22:17,610
want to do is write all these rules down

00:22:14,880 --> 00:22:19,830
as the schema managers we could tell

00:22:17,610 --> 00:22:21,120
everyone these but again since we're a

00:22:19,830 --> 00:22:22,980
global company we needed to make sure

00:22:21,120 --> 00:22:25,260
that all this information was written

00:22:22,980 --> 00:22:28,290
somewhere teams could come back to it in

00:22:25,260 --> 00:22:30,240
reference as they see please but if not

00:22:28,290 --> 00:22:32,820
only that if we decided to change our

00:22:30,240 --> 00:22:34,620
decisions or change our understanding of

00:22:32,820 --> 00:22:36,750
what a good schema looks like we could

00:22:34,620 --> 00:22:38,070
then go update the documentation and it

00:22:36,750 --> 00:22:40,530
just comes be a central place for

00:22:38,070 --> 00:22:44,700
everyone to kind of coordinate we also

00:22:40,530 --> 00:22:46,679
needed to we also needed to make do

00:22:44,700 --> 00:22:49,920
schema reviews with the team's right so

00:22:46,679 --> 00:22:51,780
I mentioned before that we'd have a

00:22:49,920 --> 00:22:54,510
meeting to kind of bring the teams

00:22:51,780 --> 00:22:57,540
together what often occurs is that we

00:22:54,510 --> 00:22:58,800
have teams we they propose a new field

00:22:57,540 --> 00:23:00,750
that they want to add into the schema

00:22:58,800 --> 00:23:03,000
usually it's a top-level field something

00:23:00,750 --> 00:23:04,740
like the we only add new capability they

00:23:03,000 --> 00:23:07,020
want to do the property search the hotel

00:23:04,740 --> 00:23:09,240
search in the in the graph QL API rather

00:23:07,020 --> 00:23:11,250
than a REST API well what we would do is

00:23:09,240 --> 00:23:13,410
we actually sit down with that hotel's

00:23:11,250 --> 00:23:14,880
team and we'd ask them hey what does

00:23:13,410 --> 00:23:16,770
your schema look like for property

00:23:14,880 --> 00:23:19,380
search are you actually returning the

00:23:16,770 --> 00:23:20,820
best schema possible you know let's look

00:23:19,380 --> 00:23:22,950
at like what you're returning let's look

00:23:20,820 --> 00:23:24,900
at your data models and let's discuss if

00:23:22,950 --> 00:23:27,660
this is the best approach and this is

00:23:24,900 --> 00:23:28,980
not just like it's not we're not trying

00:23:27,660 --> 00:23:30,540
to be gatekeepers here we're not trying

00:23:28,980 --> 00:23:32,040
to block people from doing development

00:23:30,540 --> 00:23:33,240
but it's just a good way to make sure

00:23:32,040 --> 00:23:35,480
that if we're trying to roll this out

00:23:33,240 --> 00:23:37,590
across multiple teams multiple

00:23:35,480 --> 00:23:39,300
organizations that we everyone kind of

00:23:37,590 --> 00:23:41,400
really understood what the graph QL

00:23:39,300 --> 00:23:43,080
looks like for us so we actually sit

00:23:41,400 --> 00:23:44,700
down we have these reviews and then we

00:23:43,080 --> 00:23:46,110
keep iterating to make sure that you

00:23:44,700 --> 00:23:48,510
know you're not just blocked but we can

00:23:46,110 --> 00:23:52,080
provide the best schema possible for

00:23:48,510 --> 00:23:53,820
your customers and we are not only that

00:23:52,080 --> 00:23:55,350
we wanted to make sure that the schema

00:23:53,820 --> 00:23:56,940
just evolved so you

00:23:55,350 --> 00:23:58,799
you're you know you're not locked into

00:23:56,940 --> 00:24:00,330
providing a single schema right now we

00:23:58,799 --> 00:24:02,160
will make sure that the schema you're

00:24:00,330 --> 00:24:04,200
trying to provide for what's a property

00:24:02,160 --> 00:24:07,820
search again it could be extendable to

00:24:04,200 --> 00:24:10,919
some new features down the road and so a

00:24:07,820 --> 00:24:12,780
schema which is scalable for us is

00:24:10,919 --> 00:24:14,970
actually a schema that is designed for

00:24:12,780 --> 00:24:18,360
the clients so I mentioned earlier that

00:24:14,970 --> 00:24:20,789
you know we wanted the UI to look very

00:24:18,360 --> 00:24:22,590
similar well that means that the clients

00:24:20,789 --> 00:24:24,510
should actually be kind of defining the

00:24:22,590 --> 00:24:26,220
schema based on the UI right if we have

00:24:24,510 --> 00:24:28,799
our data models they should not be

00:24:26,220 --> 00:24:31,200
focused on defining the concept of an

00:24:28,799 --> 00:24:32,549
API they should be focused on powering

00:24:31,200 --> 00:24:35,490
the clients that we need to actually

00:24:32,549 --> 00:24:37,830
show so for us we want to actually focus

00:24:35,490 --> 00:24:39,809
on the client defining their schema

00:24:37,830 --> 00:24:41,940
first right if your client understands

00:24:39,809 --> 00:24:44,370
the responsibility of all the business

00:24:41,940 --> 00:24:47,039
value needs to provide all the use cases

00:24:44,370 --> 00:24:48,299
it has it actually understands kind of

00:24:47,039 --> 00:24:50,220
the edge cases that you might have not

00:24:48,299 --> 00:24:52,559
known because maybe that previously the

00:24:50,220 --> 00:24:54,210
client was calling to api's and merging

00:24:52,559 --> 00:24:57,210
the data together and you didn't even

00:24:54,210 --> 00:24:58,919
know that as the other API team so we

00:24:57,210 --> 00:25:01,020
actually first start with the client and

00:24:58,919 --> 00:25:02,940
then you work backwards from there we

00:25:01,020 --> 00:25:04,590
were we started talking with the service

00:25:02,940 --> 00:25:06,090
team saying okay this is the client this

00:25:04,590 --> 00:25:08,100
is the schema that the client wanted to

00:25:06,090 --> 00:25:10,440
implement so how can we work with those

00:25:08,100 --> 00:25:12,840
service teams to now adapt the schema to

00:25:10,440 --> 00:25:14,820
fit that client need and then we also

00:25:12,840 --> 00:25:17,429
want to make sure that any data that we

00:25:14,820 --> 00:25:20,370
added is only ever going to be used by

00:25:17,429 --> 00:25:21,630
the client so now we wanted to align on

00:25:20,370 --> 00:25:23,730
the data that we're showing the customer

00:25:21,630 --> 00:25:26,429
but we're also trying to slowly align

00:25:23,730 --> 00:25:28,890
our visual elements of a text video so

00:25:26,429 --> 00:25:32,610
if someone customer let's say it's the

00:25:28,890 --> 00:25:34,770
mobile app iOS an iOS app if it's using

00:25:32,610 --> 00:25:36,929
data that's different than the Android

00:25:34,770 --> 00:25:38,400
app that that right there that's a red

00:25:36,929 --> 00:25:40,409
flag for us all right we don't want

00:25:38,400 --> 00:25:41,700
clients using different applications so

00:25:40,409 --> 00:25:43,140
we actually want to make sure that all

00:25:41,700 --> 00:25:45,780
the data we're adding is going to be

00:25:43,140 --> 00:25:47,280
used by similar applications and then if

00:25:45,780 --> 00:25:48,510
data is not going to be used it

00:25:47,280 --> 00:25:53,340
shouldn't really just go in the graph at

00:25:48,510 --> 00:25:57,210
all so let's kind of take a look at what

00:25:53,340 --> 00:25:59,250
a designing an API might look like or

00:25:57,210 --> 00:26:02,309
designing a graph QL a schema might look

00:25:59,250 --> 00:26:03,800
like if we instead start from the API so

00:26:02,309 --> 00:26:05,990
up here we have

00:26:03,800 --> 00:26:08,120
first chunk again hopefully everyone can

00:26:05,990 --> 00:26:10,760
see that basically up there all it is is

00:26:08,120 --> 00:26:12,920
the first part of JSON it says the user

00:26:10,760 --> 00:26:14,720
object and it has some flag saying is

00:26:12,920 --> 00:26:16,130
the user logged in let's say you called

00:26:14,720 --> 00:26:18,050
the API to check that the users logged

00:26:16,130 --> 00:26:20,510
in true or false then we have another

00:26:18,050 --> 00:26:23,660
concept here we get a list of hotels and

00:26:20,510 --> 00:26:25,640
every Hotel has this concept of member

00:26:23,660 --> 00:26:27,110
pricing all right you don't need to know

00:26:25,640 --> 00:26:29,150
what that is I'm just telling you that

00:26:27,110 --> 00:26:30,680
they exist but let's say as the API team

00:26:29,150 --> 00:26:32,060
that's all you know - right you just

00:26:30,680 --> 00:26:34,520
know there's this concept of member

00:26:32,060 --> 00:26:36,170
pricing so what we're gonna do is if

00:26:34,520 --> 00:26:37,940
someone's logged in and they are a

00:26:36,170 --> 00:26:40,130
member then we're going to show this new

00:26:37,940 --> 00:26:41,990
feature on our hotel search results ok

00:26:40,130 --> 00:26:45,080
it sounds great so if we go over here to

00:26:41,990 --> 00:26:47,510
the right side you might see we have a

00:26:45,080 --> 00:26:50,060
new field hotel search we can get a list

00:26:47,510 --> 00:26:52,340
of hotels and every Hotel has an ID name

00:26:50,060 --> 00:26:55,010
and this new flag which is display the

00:26:52,340 --> 00:26:56,570
member pricing right so it's just pretty

00:26:55,010 --> 00:26:58,340
simple check now the client doesn't have

00:26:56,570 --> 00:27:00,020
to do that to check for is the user

00:26:58,340 --> 00:27:02,030
logged in or not they just have one

00:27:00,020 --> 00:27:03,830
single check which is either the user

00:27:02,030 --> 00:27:05,810
logged or display the member pricing

00:27:03,830 --> 00:27:09,410
true or false just show it to the user

00:27:05,810 --> 00:27:11,000
seems pretty simple enough but if we

00:27:09,410 --> 00:27:13,250
actually kind of take a step back and

00:27:11,000 --> 00:27:14,480
actually look at this the claim the

00:27:13,250 --> 00:27:17,210
client experience and what they

00:27:14,480 --> 00:27:18,770
developed they actually have two things

00:27:17,210 --> 00:27:20,750
they might show the customer so up at

00:27:18,770 --> 00:27:22,640
the top there is the badge for the

00:27:20,750 --> 00:27:23,810
member pricing right so if you're logged

00:27:22,640 --> 00:27:25,700
in you might see this little badge

00:27:23,810 --> 00:27:27,650
saying hey if you're you're logged in

00:27:25,700 --> 00:27:30,320
you get to save more money but the

00:27:27,650 --> 00:27:31,730
client knows that actually it displays

00:27:30,320 --> 00:27:34,130
this other information in that same

00:27:31,730 --> 00:27:35,990
location which is maybe a shortage so

00:27:34,130 --> 00:27:37,670
this hotel there's only eight rooms left

00:27:35,990 --> 00:27:39,860
so we're going to give you a special

00:27:37,670 --> 00:27:42,560
deal on that hotel if you booked now all

00:27:39,860 --> 00:27:44,540
right but only the client knows right

00:27:42,560 --> 00:27:46,100
now in the situation which order that

00:27:44,540 --> 00:27:48,230
displays what if we had both features

00:27:46,100 --> 00:27:50,150
enabled if both were true right which

00:27:48,230 --> 00:27:52,400
one goes first which one takes priority

00:27:50,150 --> 00:27:54,260
if that logic is quote coded into the

00:27:52,400 --> 00:27:56,330
client that's business logic then then

00:27:54,260 --> 00:27:58,220
has to be duplicated across every single

00:27:56,330 --> 00:28:00,380
client consuming that graph alright so

00:27:58,220 --> 00:28:02,060
you know I OS Android all the web apps

00:28:00,380 --> 00:28:04,460
everyone has to add that same boolean

00:28:02,060 --> 00:28:06,620
check so instead what we try to do is

00:28:04,460 --> 00:28:08,210
have a schema which just provides

00:28:06,620 --> 00:28:10,730
information that the client needs which

00:28:08,210 --> 00:28:11,910
really all they all you see here is the

00:28:10,730 --> 00:28:14,070
concept of

00:28:11,910 --> 00:28:16,620
write an offer badge and it all it has

00:28:14,070 --> 00:28:18,720
is possibly an icon and some text that

00:28:16,620 --> 00:28:20,100
is gonna display to the user right and

00:28:18,720 --> 00:28:22,770
this is actually what is being powered

00:28:20,100 --> 00:28:25,289
by the client and yes this might be a

00:28:22,770 --> 00:28:26,940
very specific UI example that not

00:28:25,289 --> 00:28:28,860
everyone might use in their graph QL API

00:28:26,940 --> 00:28:30,929
but really the core concept here is that

00:28:28,860 --> 00:28:32,730
we're trying to reduce the client logic

00:28:30,929 --> 00:28:35,190
right any boolean checks that your

00:28:32,730 --> 00:28:37,470
client do any in inject any filtering

00:28:35,190 --> 00:28:39,539
that the client is doing if you want to

00:28:37,470 --> 00:28:41,970
test those changes out across different

00:28:39,539 --> 00:28:43,890
apps and services you then have to go to

00:28:41,970 --> 00:28:45,299
every single client and app to make sure

00:28:43,890 --> 00:28:47,669
that they're all doing the new business

00:28:45,299 --> 00:28:50,549
logic whereas on this model we can

00:28:47,669 --> 00:28:52,049
actually try maybe a new badge right and

00:28:50,549 --> 00:28:54,059
this the client doesn't even have to

00:28:52,049 --> 00:28:56,520
know if the badge changes at all on the

00:28:54,059 --> 00:28:57,780
backend we can run a new test maybe ten

00:28:56,520 --> 00:28:59,520
percent of the traffic see this new

00:28:57,780 --> 00:29:01,470
concept the new badge with a different

00:28:59,520 --> 00:29:03,240
color and we can test out on the back

00:29:01,470 --> 00:29:05,429
end which one is better but we don't

00:29:03,240 --> 00:29:07,169
have to update the clients so this is

00:29:05,429 --> 00:29:11,700
kind of the design of a client for

00:29:07,169 --> 00:29:15,150
schema all right so just kind of wrap up

00:29:11,700 --> 00:29:16,799
here the lessons we've learned over kind

00:29:15,150 --> 00:29:18,870
of implementing all these changes is

00:29:16,799 --> 00:29:21,289
that we want to first reduce the

00:29:18,870 --> 00:29:24,450
developer friction right the graph QL is

00:29:21,289 --> 00:29:26,460
really not about your the customer

00:29:24,450 --> 00:29:28,260
experience the customer our travelers

00:29:26,460 --> 00:29:30,059
don't care for using rust api's don't

00:29:28,260 --> 00:29:31,559
care for using graphical api's all they

00:29:30,059 --> 00:29:32,549
all they see is a product right they

00:29:31,559 --> 00:29:35,070
just want to be able to book a hotel

00:29:32,549 --> 00:29:37,169
booked a flight so the graph QL is

00:29:35,070 --> 00:29:38,820
really meant to empower your developers

00:29:37,169 --> 00:29:39,090
to make sure that your tooling works for

00:29:38,820 --> 00:29:40,650
you

00:29:39,090 --> 00:29:42,539
that you are getting all these safety

00:29:40,650 --> 00:29:44,460
checks and if your developers are

00:29:42,539 --> 00:29:45,990
working faster working better that

00:29:44,460 --> 00:29:47,640
actually then translates to your

00:29:45,990 --> 00:29:49,679
customers same benefit for adding more

00:29:47,640 --> 00:29:51,630
features to your customers all right so

00:29:49,679 --> 00:29:54,150
making sure that developer friction for

00:29:51,630 --> 00:29:56,970
us has been key for all this entire

00:29:54,150 --> 00:29:58,440
migration and then having our client for

00:29:56,970 --> 00:30:01,289
schema which what we learned from

00:29:58,440 --> 00:30:02,520
implementing a PWA first has really been

00:30:01,289 --> 00:30:04,320
paying off right we've been trying to

00:30:02,520 --> 00:30:06,240
teach this model to with more and more

00:30:04,320 --> 00:30:08,940
teams as we onboard them onto the graph

00:30:06,240 --> 00:30:10,620
QL architecture and sometimes it takes

00:30:08,940 --> 00:30:11,970
teams a little bit to kind of understand

00:30:10,620 --> 00:30:14,580
what we mean by client first but

00:30:11,970 --> 00:30:15,900
eventually it clicks and we have been

00:30:14,580 --> 00:30:17,970
seeing these benefits of being able to

00:30:15,900 --> 00:30:19,710
run tiel's on the server and not being

00:30:17,970 --> 00:30:21,480
up not being worried about updating

00:30:19,710 --> 00:30:24,179
clients and it's actually really paying

00:30:21,480 --> 00:30:24,940
off for our business and then secondly

00:30:24,179 --> 00:30:27,250
our

00:30:24,940 --> 00:30:28,960
kind of last point here creating a

00:30:27,250 --> 00:30:31,390
community creating this like idea of

00:30:28,960 --> 00:30:34,090
like maintaining a graph QL schema at a

00:30:31,390 --> 00:30:35,650
large company is is very hard just

00:30:34,090 --> 00:30:38,170
crania community in general is very hard

00:30:35,650 --> 00:30:39,880
all right so our the idea of having a

00:30:38,170 --> 00:30:42,220
schema manager team is that we start

00:30:39,880 --> 00:30:44,590
kind of bringing more teams into this

00:30:42,220 --> 00:30:46,840
concept of what does our graph QL schema

00:30:44,590 --> 00:30:48,660
and what does good graph QL look like if

00:30:46,840 --> 00:30:50,740
we can teach that to more and more teams

00:30:48,660 --> 00:30:53,920
it no longer becomes the responsibility

00:30:50,740 --> 00:30:56,590
of just the core schema managers team to

00:30:53,920 --> 00:30:58,660
enforce that it becomes the collection

00:30:56,590 --> 00:31:00,460
of everyone who's using the graphical

00:30:58,660 --> 00:31:02,200
schema to actually benefit from having a

00:31:00,460 --> 00:31:04,090
good schema right not just the server's

00:31:02,200 --> 00:31:05,650
but also the client developers we all

00:31:04,090 --> 00:31:10,360
want to create the best experience for

00:31:05,650 --> 00:31:12,820
all of us so and last point here is just

00:31:10,360 --> 00:31:15,430
we kind of now transitioned to thinking

00:31:12,820 --> 00:31:17,740
no longer in terms of api's but we now

00:31:15,430 --> 00:31:20,380
think of graph you'll is a graph for our

00:31:17,740 --> 00:31:21,490
business right we think of our do all

00:31:20,380 --> 00:31:23,800
our different clients here are just

00:31:21,490 --> 00:31:26,080
experiences and how we show some data

00:31:23,800 --> 00:31:29,440
the data just comes from a graphic and

00:31:26,080 --> 00:31:31,480
it's up to the platform the graph the

00:31:29,440 --> 00:31:33,400
graph platform to provide all these

00:31:31,480 --> 00:31:35,560
answers to questions that all these

00:31:33,400 --> 00:31:36,880
applications might have like why are the

00:31:35,560 --> 00:31:39,610
nearest hotels near the space you know

00:31:36,880 --> 00:31:41,950
it can I put that hotel in my cart do

00:31:39,610 --> 00:31:43,420
weather reviews for that hotel and you

00:31:41,950 --> 00:31:44,920
know are there insurance options for

00:31:43,420 --> 00:31:46,960
that hotel oh these are just questions

00:31:44,920 --> 00:31:49,120
that our customers are asking to us and

00:31:46,960 --> 00:31:51,010
it's up to the graph to answer them and

00:31:49,120 --> 00:31:52,840
then if we need to change any

00:31:51,010 --> 00:31:54,670
architecture or API is under the hood

00:31:52,840 --> 00:31:58,360
the graph doesn't care right the clients

00:31:54,670 --> 00:32:02,230
don't need to care about that all right

00:31:58,360 --> 00:32:04,510
so that's all I have for today if you

00:32:02,230 --> 00:32:05,650
want to follow us on Expedia group we're

00:32:04,510 --> 00:32:08,560
hopefully going to be posting more

00:32:05,650 --> 00:32:10,270
publicly about kind of how we use Apollo

00:32:08,560 --> 00:32:12,730
Federation going forward and we migrated

00:32:10,270 --> 00:32:15,880
to the new Federation model you can also

00:32:12,730 --> 00:32:18,820
follow me social and here's some of the

00:32:15,880 --> 00:32:23,720
links for today thanks everyone

00:32:18,820 --> 00:32:23,720

YouTube URL: https://www.youtube.com/watch?v=Orq_QtXKLwg


