Title: What it takes to run the world's largest GraphQL server - Jan Jergus
Publication date: 2017-11-16
Playlist: GraphQL SF: Experimental GraphQL
Description: 
	Facebook's Jan Jergus  presents at GraphQL SF: Experimental GraphQL on 5/13/17.

Jan is responsible for the GraphQL server Facebook uses internally. He'll discuss what it takes to run the highest volume GraphQL server in the wild, including some interesting performance optimizations Facebook has done to save CPU and tooling they've developed to prevent people from accidentally introducing breaking changes to our GraphQL schema. He's happy to answer questions about Facebook's server implementation after the talk. 

Join GraphQL SF to get notified about future meetups: https://www.meetup.com/GraphQL-SF/
Captions: 
	00:00:00,030 --> 00:00:04,710
we have yann from facebook who's going

00:00:02,340 --> 00:00:06,930
to talk about how he's been developing

00:00:04,710 --> 00:00:08,250
Facebook's internal hack craft kill

00:00:06,930 --> 00:00:10,170
server that powers their production

00:00:08,250 --> 00:00:12,269
mobile apps he's gonna talk a little bit

00:00:10,170 --> 00:00:14,790
about how they made it perform enough to

00:00:12,269 --> 00:00:16,410
handle those requests and also what it

00:00:14,790 --> 00:00:18,180
takes to build a graphical server that

00:00:16,410 --> 00:00:19,830
so many developers can collaborate on

00:00:18,180 --> 00:00:27,680
without stepping all over each other

00:00:19,830 --> 00:00:31,740
so please yawn take it away hey everyone

00:00:27,680 --> 00:00:33,960
I'm yawn first of all I want to thank

00:00:31,740 --> 00:00:36,570
the meteor team for inviting us all here

00:00:33,960 --> 00:00:38,219
um I'm very excited to be here it's my

00:00:36,570 --> 00:00:43,050
first time at one of these community

00:00:38,219 --> 00:00:45,480
meet ups hopefully not the last one yeah

00:00:43,050 --> 00:00:47,370
I think the the original plan was that

00:00:45,480 --> 00:00:50,550
uh Lee Baron would come today and speak

00:00:47,370 --> 00:00:52,170
about the RFC process so if you were

00:00:50,550 --> 00:00:55,559
hoping for that I have some bad news and

00:00:52,170 --> 00:00:57,840
some good news bad news is a lease in

00:00:55,559 --> 00:01:00,120
London so he can make it here good news

00:00:57,840 --> 00:01:01,410
is he spoke about that at the London

00:01:00,120 --> 00:01:05,040
graphic you'll meet up and there's a

00:01:01,410 --> 00:01:06,840
recording so I recommend a highly

00:01:05,040 --> 00:01:08,490
recommended to watch that there are some

00:01:06,840 --> 00:01:09,360
links here make sure you memorize them

00:01:08,490 --> 00:01:11,010
before I switch to the next slide

00:01:09,360 --> 00:01:16,650
because you'll never see them again

00:01:11,010 --> 00:01:18,570
after that so uh anyway so I'm I'm gonna

00:01:16,650 --> 00:01:21,150
tell you I'm gonna tell you today about

00:01:18,570 --> 00:01:24,710
what it takes to around what probably

00:01:21,150 --> 00:01:30,689
the world's biggest graphical server

00:01:24,710 --> 00:01:34,350
right so I work out I work on the

00:01:30,689 --> 00:01:36,060
graphical server team at Facebook so a

00:01:34,350 --> 00:01:38,250
little about what that what that entails

00:01:36,060 --> 00:01:40,470
so my favorite feature of graph QL is

00:01:38,250 --> 00:01:42,600
that it's a it's a language designed for

00:01:40,470 --> 00:01:44,340
client developers it's our goal is to

00:01:42,600 --> 00:01:46,770
build the ideal language you always wish

00:01:44,340 --> 00:01:48,560
you had if you're a client developer so

00:01:46,770 --> 00:01:52,079
obviously a big part of that is just

00:01:48,560 --> 00:01:54,479
making sure we achieve that goal or get

00:01:52,079 --> 00:01:56,280
as close as we can so client developers

00:01:54,479 --> 00:01:57,600
are a big customers so it's not just on

00:01:56,280 --> 00:02:00,149
the server team but on the graphical

00:01:57,600 --> 00:02:02,040
team in general but then especially on

00:02:00,149 --> 00:02:03,840
the server team we have another very

00:02:02,040 --> 00:02:06,119
important group of customers and these

00:02:03,840 --> 00:02:07,740
are the server developers which may or

00:02:06,119 --> 00:02:10,860
may not be the same people sometimes

00:02:07,740 --> 00:02:12,580
there are such as there aren't so these

00:02:10,860 --> 00:02:14,080
are the people who build and I'm back in

00:02:12,580 --> 00:02:19,090
services and they want to expose them

00:02:14,080 --> 00:02:21,790
over-over graphic UL so what we what we

00:02:19,090 --> 00:02:23,860
need to do for them the perhaps primary

00:02:21,790 --> 00:02:26,260
goal is that we need to make it we need

00:02:23,860 --> 00:02:28,000
to make the framework easy to use so

00:02:26,260 --> 00:02:30,520
that means the the abstractions that we

00:02:28,000 --> 00:02:32,500
build should be easy to understand it

00:02:30,520 --> 00:02:34,510
shouldn't require tons of boilerplate to

00:02:32,500 --> 00:02:38,470
expose some simple concept like a new

00:02:34,510 --> 00:02:40,000
type or a field using graphic you that's

00:02:38,470 --> 00:02:42,760
one of our goals but there's another

00:02:40,000 --> 00:02:46,450
perhaps equally important one and that's

00:02:42,760 --> 00:02:48,370
we're that's that we are sort of the

00:02:46,450 --> 00:02:51,790
shield that guards the realms of men

00:02:48,370 --> 00:02:55,360
where we're responsible for making sure

00:02:51,790 --> 00:02:57,400
our graphical schema is a is sound and

00:02:55,360 --> 00:03:00,880
sensible and that it stays that way

00:02:57,400 --> 00:03:05,890
so for data for that we employ a variety

00:03:00,880 --> 00:03:07,780
of techniques mainly we try to make we

00:03:05,890 --> 00:03:11,230
try to make the we try to make the

00:03:07,780 --> 00:03:12,940
abstractions we try to design in them in

00:03:11,230 --> 00:03:15,459
such a way that it makes their doing the

00:03:12,940 --> 00:03:18,730
right thing easy and doing the wrong

00:03:15,459 --> 00:03:20,320
thing harder or ideally impossible but

00:03:18,730 --> 00:03:22,630
then we also have a ton of things like

00:03:20,320 --> 00:03:24,190
lint rules for example if you if you

00:03:22,630 --> 00:03:27,090
create a new field that looks like it

00:03:24,190 --> 00:03:30,160
might be an ID because it's name is ID

00:03:27,090 --> 00:03:31,959
but you are you try to give it the type

00:03:30,160 --> 00:03:33,459
of string or integer and we warn you

00:03:31,959 --> 00:03:37,000
that this this field should probably be

00:03:33,459 --> 00:03:39,070
using the ID type and then we have some

00:03:37,000 --> 00:03:41,230
even more fancy tools like for example

00:03:39,070 --> 00:03:43,690
if you try to commit a change that would

00:03:41,230 --> 00:03:45,310
not be backwards compatible we have this

00:03:43,690 --> 00:03:47,950
boss that will show you a warning right

00:03:45,310 --> 00:03:49,450
there on the on the revision it will

00:03:47,950 --> 00:03:51,160
tell you that we removing some field

00:03:49,450 --> 00:03:55,780
other clients might still be querying

00:03:51,160 --> 00:03:58,180
for so that's part of what we do but

00:03:55,780 --> 00:04:00,970
another important part is that we also

00:03:58,180 --> 00:04:02,320
care a lot about efficiency so since

00:04:00,970 --> 00:04:05,800
like I mentioned graphical is designed

00:04:02,320 --> 00:04:07,920
for client developers a lot of time that

00:04:05,800 --> 00:04:10,299
means we have to make trade-offs where

00:04:07,920 --> 00:04:12,820
to make things easy for the client

00:04:10,299 --> 00:04:15,850
developers we do a lot of work on the

00:04:12,820 --> 00:04:17,709
server so as framework go graph Keo is

00:04:15,850 --> 00:04:19,030
not particularly cheap on the server we

00:04:17,709 --> 00:04:21,280
have to do a lot of work on the server

00:04:19,030 --> 00:04:23,530
most anything from parsing the query

00:04:21,280 --> 00:04:26,580
validating it to make sure there are not

00:04:23,530 --> 00:04:29,260
like infinite loops of fragments

00:04:26,580 --> 00:04:32,710
- formatting the response and all that

00:04:29,260 --> 00:04:34,540
so there's actually a significant

00:04:32,710 --> 00:04:37,150
overhead of the graphical framework I

00:04:34,540 --> 00:04:38,890
think even in our somewhat optimized

00:04:37,150 --> 00:04:41,010
implantation is something on the very

00:04:38,890 --> 00:04:43,780
roughly on the order of ten percent of

00:04:41,010 --> 00:04:45,880
CPU time in a graphical request would be

00:04:43,780 --> 00:04:50,710
could be considered the overhead of the

00:04:45,880 --> 00:04:52,660
graph QL framework so we're we're happy

00:04:50,710 --> 00:04:54,640
to pay this cost for older all the

00:04:52,660 --> 00:04:58,060
advantages of graph QL but it's not

00:04:54,640 --> 00:04:59,800
negligible and it's important doing even

00:04:58,060 --> 00:05:01,930
small optimization there can have a lot

00:04:59,800 --> 00:05:04,210
of impact we can literally save millions

00:05:01,930 --> 00:05:06,340
of dollars at our scale by making some

00:05:04,210 --> 00:05:08,650
fairly minor optimization somewhere

00:05:06,340 --> 00:05:14,200
inside the internals of our graphical

00:05:08,650 --> 00:05:16,420
server so since the topic of today is

00:05:14,200 --> 00:05:18,730
experimental graph QL I'd like to frame

00:05:16,420 --> 00:05:20,350
the rest of the talk as a an overview of

00:05:18,730 --> 00:05:24,460
some things that we've experimented with

00:05:20,350 --> 00:05:25,690
over the over the past few years so

00:05:24,460 --> 00:05:27,160
there'll be there'll be a little of

00:05:25,690 --> 00:05:28,810
everything but you'll see that most of

00:05:27,160 --> 00:05:30,520
what I talk about will fall into some of

00:05:28,810 --> 00:05:32,290
the categories I just mentioned so it'll

00:05:30,520 --> 00:05:35,230
either make things faster or easier to

00:05:32,290 --> 00:05:38,830
use for some group of our customers and

00:05:35,230 --> 00:05:41,680
I'll start in I'll start in 2015 which

00:05:38,830 --> 00:05:43,510
you may remember as a the year graph

00:05:41,680 --> 00:05:45,220
kill was released the graphical

00:05:43,510 --> 00:05:47,440
open-source specification was released

00:05:45,220 --> 00:05:51,000
and you probably know that we viewed

00:05:47,440 --> 00:05:53,440
graphical at Facebook before then and

00:05:51,000 --> 00:05:55,780
the version that we used before was

00:05:53,440 --> 00:05:57,750
actually somewhat different from the one

00:05:55,780 --> 00:06:01,360
that we released us as an open-source

00:05:57,750 --> 00:06:02,860
specification so this process of

00:06:01,360 --> 00:06:04,540
formulating the opens of specification

00:06:02,860 --> 00:06:06,820
was a very good opportunity for us to

00:06:04,540 --> 00:06:09,520
revisit some of the older design

00:06:06,820 --> 00:06:11,560
decisions or in many cases not as much

00:06:09,520 --> 00:06:16,470
decisions as just like how things

00:06:11,560 --> 00:06:19,150
evolved over time and this ranged from

00:06:16,470 --> 00:06:21,360
trivial things like minor cleanups in

00:06:19,150 --> 00:06:23,320
the graphical syntax all the way to

00:06:21,360 --> 00:06:25,780
significant changes that change the

00:06:23,320 --> 00:06:28,240
semantics of the language or change how

00:06:25,780 --> 00:06:31,990
the language is used I'll start with

00:06:28,240 --> 00:06:34,240
some examples of the former so here on

00:06:31,990 --> 00:06:36,850
the left you can see a query in or a

00:06:34,240 --> 00:06:39,490
part of a query in our legacy graphical

00:06:36,850 --> 00:06:41,800
syntax and on the right you can see the

00:06:39,490 --> 00:06:43,319
equivalent part of the query in the open

00:06:41,800 --> 00:06:45,789
source syntax that you're familiar with

00:06:43,319 --> 00:06:47,830
the interesting thing to notice here is

00:06:45,789 --> 00:06:49,960
that in our legacy same text graphical

00:06:47,830 --> 00:06:55,000
fields didn't have arguments they had

00:06:49,960 --> 00:06:56,710
calls and those calls had arguments so

00:06:55,000 --> 00:06:58,330
this is a kind of an interesting change

00:06:56,710 --> 00:07:00,729
it's not strictly better or worse it's

00:06:58,330 --> 00:07:03,039
just different it makes some things easy

00:07:00,729 --> 00:07:06,340
it makes some things easier to express

00:07:03,039 --> 00:07:07,870
for example here you can see that the

00:07:06,340 --> 00:07:11,050
version in the open source graphical is

00:07:07,870 --> 00:07:13,990
not maybe it's more verbose and it also

00:07:11,050 --> 00:07:15,789
maybe allows some weird cases like what

00:07:13,990 --> 00:07:17,979
if you specify the month but not the day

00:07:15,789 --> 00:07:20,889
how do we resolve that then we'd have to

00:07:17,979 --> 00:07:25,960
come up with workarounds that again

00:07:20,889 --> 00:07:27,669
result in more syntax but in the end we

00:07:25,960 --> 00:07:29,860
decided that this extra indirection of

00:07:27,669 --> 00:07:31,150
having calls and calls having arguments

00:07:29,860 --> 00:07:33,669
was probably not worth it

00:07:31,150 --> 00:07:35,289
it also led into weird edge cases like

00:07:33,669 --> 00:07:37,870
what does it mean to have a call that

00:07:35,289 --> 00:07:41,919
has no arguments yeah what does this

00:07:37,870 --> 00:07:43,630
what does this represent so that's a

00:07:41,919 --> 00:07:46,479
that's an interesting that's an

00:07:43,630 --> 00:07:48,280
interesting example another thing I'd

00:07:46,479 --> 00:07:50,320
like to show you are we had something

00:07:48,280 --> 00:07:52,150
called the route calls which sounds

00:07:50,320 --> 00:07:54,490
similar on the surface but it's actually

00:07:52,150 --> 00:07:56,349
quite a quite a different thing it

00:07:54,490 --> 00:08:00,969
shares the same text with the calls that

00:07:56,349 --> 00:08:03,159
I've just showed you and the idea is you

00:08:00,969 --> 00:08:05,139
know that each graphical query starts

00:08:03,159 --> 00:08:07,330
with the route field which starts with

00:08:05,139 --> 00:08:10,719
the route object on which we can query

00:08:07,330 --> 00:08:13,060
for some fields and then their subfields

00:08:10,719 --> 00:08:15,460
and so on so in our legacy syntax that

00:08:13,060 --> 00:08:18,039
wasn't deer would feel that wasn't deer

00:08:15,460 --> 00:08:19,569
would object that was a of the object so

00:08:18,039 --> 00:08:22,150
each query started with a different

00:08:19,569 --> 00:08:23,889
through an object and the route call was

00:08:22,150 --> 00:08:26,139
sort of a resolver that would that would

00:08:23,889 --> 00:08:29,919
that would produce the route object at

00:08:26,139 --> 00:08:31,599
which the query should start so you can

00:08:29,919 --> 00:08:33,219
probably guess that as part of the

00:08:31,599 --> 00:08:35,500
migration to open-source graphic you at

00:08:33,219 --> 00:08:38,289
Facebook we just converted all the route

00:08:35,500 --> 00:08:40,779
calls into fields on the route object I

00:08:38,289 --> 00:08:43,260
think this was a welcome cleanup no one

00:08:40,779 --> 00:08:45,640
is really missing the route calls so

00:08:43,260 --> 00:08:49,320
this is a nice thing that simplified the

00:08:45,640 --> 00:08:49,320
language without really losing anything

00:08:50,520 --> 00:08:55,890
all right you're all familiar with

00:08:53,160 --> 00:08:57,690
fragments these are they're very good

00:08:55,890 --> 00:08:59,670
way to conditionally include parts of

00:08:57,690 --> 00:09:03,630
the query in the response depending on

00:08:59,670 --> 00:09:04,740
the runtime types of some objects what

00:09:03,630 --> 00:09:06,660
you probably don't know is that

00:09:04,740 --> 00:09:08,220
fragments well originally they weren't

00:09:06,660 --> 00:09:10,170
part of graphical at all in the very

00:09:08,220 --> 00:09:12,510
first version but then when we added

00:09:10,170 --> 00:09:14,160
them at first they didn't actually have

00:09:12,510 --> 00:09:18,740
a type they were just a simple way to

00:09:14,160 --> 00:09:22,170
reuse reuse pieces of a graphical code

00:09:18,740 --> 00:09:23,790
so fragments as you know them now there

00:09:22,170 --> 00:09:25,560
was a feature that we called conditional

00:09:23,790 --> 00:09:27,120
fragments and there was a that only

00:09:25,560 --> 00:09:30,450
became part of the graphical language

00:09:27,120 --> 00:09:32,730
later but uh people liked it so much and

00:09:30,450 --> 00:09:34,830
it was so useful that eventually in the

00:09:32,730 --> 00:09:38,010
open source specification that became

00:09:34,830 --> 00:09:41,280
the only way to write fragments in graph

00:09:38,010 --> 00:09:43,560
QL and there's an interesting point to

00:09:41,280 --> 00:09:45,240
mention here in data since we need to

00:09:43,560 --> 00:09:46,830
preserve backwards compatibility to

00:09:45,240 --> 00:09:49,260
support all the old clients that are

00:09:46,830 --> 00:09:52,590
still out there in the wild we had to

00:09:49,260 --> 00:09:54,690
include some way for our new server to

00:09:52,590 --> 00:09:56,520
support these unconditional fragments so

00:09:54,690 --> 00:09:58,380
we have a we have a special directive

00:09:56,520 --> 00:10:00,420
for this and this is probably the reason

00:09:58,380 --> 00:10:01,860
why directives are such a prominent part

00:10:00,420 --> 00:10:03,210
or have been such a permanent part of

00:10:01,860 --> 00:10:04,920
the graphical specification from the

00:10:03,210 --> 00:10:06,660
start because we really need them to

00:10:04,920 --> 00:10:12,060
support all these legacy use cases in

00:10:06,660 --> 00:10:14,520
our server and then one more thing that

00:10:12,060 --> 00:10:16,470
I'd like to mention this is perhaps the

00:10:14,520 --> 00:10:19,860
most important change from legacy graph

00:10:16,470 --> 00:10:22,170
QL to open source graphic ul this is a

00:10:19,860 --> 00:10:24,780
this is not a syntactic change it's a

00:10:22,170 --> 00:10:26,190
change in behavior the old graph QL had

00:10:24,780 --> 00:10:28,770
this behavior that we call fat

00:10:26,190 --> 00:10:31,080
interfaces it means that if there's an

00:10:28,770 --> 00:10:33,300
object or in this case a root call that

00:10:31,080 --> 00:10:35,370
resolves to an abstract type like node

00:10:33,300 --> 00:10:39,240
here which can resolve to basically

00:10:35,370 --> 00:10:40,980
anything then you could query for any

00:10:39,240 --> 00:10:43,140
field on that as long as that field

00:10:40,980 --> 00:10:45,420
exists on any subtype of that abstract

00:10:43,140 --> 00:10:48,000
type and then our server if the type

00:10:45,420 --> 00:10:50,340
exists on whatever the runtime type ends

00:10:48,000 --> 00:10:53,130
up being then we give you the response

00:10:50,340 --> 00:10:56,430
otherwise we just give you now so there

00:10:53,130 --> 00:10:59,760
kind of sounds simple but it has some

00:10:56,430 --> 00:11:01,530
disadvantages the verbs most obvious

00:10:59,760 --> 00:11:03,270
disadvantage is that this can leads to

00:11:01,530 --> 00:11:04,120
over fetching for example if the

00:11:03,270 --> 00:11:05,920
intention here

00:11:04,120 --> 00:11:08,200
is what in the open-source graphical

00:11:05,920 --> 00:11:10,029
would be expressed as this that we want

00:11:08,200 --> 00:11:11,470
to if this if this node is a user we

00:11:10,029 --> 00:11:13,690
want to fetch the name and friends and

00:11:11,470 --> 00:11:16,870
if it's a group then we fetch one of em

00:11:13,690 --> 00:11:18,250
Burres the this can result in over

00:11:16,870 --> 00:11:20,380
fetching because groups probably also

00:11:18,250 --> 00:11:22,270
have names so we would fetch the name of

00:11:20,380 --> 00:11:24,790
groups here as well even though that's

00:11:22,270 --> 00:11:26,110
not what we need it so it can result in

00:11:24,790 --> 00:11:29,170
over fetching because of things like

00:11:26,110 --> 00:11:31,360
this but there's a there's a more subtle

00:11:29,170 --> 00:11:34,720
but much more dangerous disadvantage and

00:11:31,360 --> 00:11:37,210
that's a this behavior enforces that all

00:11:34,720 --> 00:11:39,250
subtypes of a specific abstract type

00:11:37,210 --> 00:11:42,460
they all have to be consistent with each

00:11:39,250 --> 00:11:45,130
other so if any if any type of node for

00:11:42,460 --> 00:11:47,170
example has a field called location then

00:11:45,130 --> 00:11:49,510
any other ta any other type that also

00:11:47,170 --> 00:11:51,160
has a field called location that field

00:11:49,510 --> 00:11:54,100
has to be consistent it has to return

00:11:51,160 --> 00:11:55,480
the same return type it has to return it

00:11:54,100 --> 00:11:59,260
has to have the same set of arguments

00:11:55,480 --> 00:12:00,910
and this was a huge pain and it still is

00:11:59,260 --> 00:12:02,500
a huge pain for Parag developers because

00:12:00,910 --> 00:12:06,279
we still have to support this behavior

00:12:02,500 --> 00:12:06,970
because of legacy clients but this is

00:12:06,279 --> 00:12:09,700
something that uh

00:12:06,970 --> 00:12:11,230
with without that interfaces wouldn't

00:12:09,700 --> 00:12:13,600
happen and we would have completely

00:12:11,230 --> 00:12:15,610
avoided this problem so we're trying to

00:12:13,600 --> 00:12:17,770
we're trying to get to a stage where

00:12:15,610 --> 00:12:21,760
that interfaces are a thing of the past

00:12:17,770 --> 00:12:23,290
but we're not quite there yet now all

00:12:21,760 --> 00:12:26,140
that uh all these things that I've

00:12:23,290 --> 00:12:28,360
showed you is probably at this point

00:12:26,140 --> 00:12:30,040
you're probably wondering like how we're

00:12:28,360 --> 00:12:31,600
like where we crazy or what the old

00:12:30,040 --> 00:12:35,560
version just seems so much worse than

00:12:31,600 --> 00:12:37,089
the new one but then and that's if you

00:12:35,560 --> 00:12:40,029
look at each think separately that

00:12:37,089 --> 00:12:41,350
probably is true but if you look at

00:12:40,029 --> 00:12:43,750
these things together like this

00:12:41,350 --> 00:12:46,000
combination of how unconditional

00:12:43,750 --> 00:12:48,550
fragments and fad interfaces would be

00:12:46,000 --> 00:12:51,480
used and work together it actually kind

00:12:48,550 --> 00:12:54,010
of makes sense it forms a system that is

00:12:51,480 --> 00:12:56,230
internally coherent so here we're

00:12:54,010 --> 00:12:57,850
fetching for we're fetching for a node

00:12:56,230 --> 00:12:59,050
of an recurring for a node of an

00:12:57,850 --> 00:13:00,430
abstract type we have a bunch of

00:12:59,050 --> 00:13:04,839
unconditional fragments that are

00:13:00,430 --> 00:13:06,580
therefore always included and thanks to

00:13:04,839 --> 00:13:07,990
the fed interface behavior this is now

00:13:06,580 --> 00:13:09,670
the problem we can fetch for all these

00:13:07,990 --> 00:13:11,700
fields which may or may not exist on the

00:13:09,670 --> 00:13:15,280
type so it kind of makes sense together

00:13:11,700 --> 00:13:17,020
but I think it's probably agree data the

00:13:15,280 --> 00:13:18,100
new over the version we ended up with

00:13:17,020 --> 00:13:22,930
for the open source

00:13:18,100 --> 00:13:24,399
open service is probably preferable so

00:13:22,930 --> 00:13:28,509
that's an overview of what we

00:13:24,399 --> 00:13:30,220
experimented with at the time around the

00:13:28,509 --> 00:13:33,639
time we're working on the open source

00:13:30,220 --> 00:13:35,319
specification now I forgot to mention

00:13:33,639 --> 00:13:37,630
that this presentation is like one of

00:13:35,319 --> 00:13:39,940
those nonlinear movies where no time

00:13:37,630 --> 00:13:41,709
skips back and forth and you have to put

00:13:39,940 --> 00:13:44,139
it all together at the end to make sense

00:13:41,709 --> 00:13:45,940
of it so now I should be imagining a

00:13:44,139 --> 00:13:49,899
cutscene with some aminos music in the

00:13:45,940 --> 00:13:52,690
background I'm gonna I'm gonna jump a

00:13:49,899 --> 00:13:55,000
few years few years back and cover cover

00:13:52,690 --> 00:13:57,009
one one lesson that we learned early the

00:13:55,000 --> 00:13:58,779
most important lesson data I'll keep

00:13:57,009 --> 00:14:02,380
going back to later in the presentation

00:13:58,779 --> 00:14:04,000
and that's that the best graphical

00:14:02,380 --> 00:14:08,889
server is one that doesn't actually

00:14:04,000 --> 00:14:10,480
accept graphical queries at all so we

00:14:08,889 --> 00:14:12,519
don't want clients to send us graphical

00:14:10,480 --> 00:14:15,550
queries what we want clients to send us

00:14:12,519 --> 00:14:18,639
are just IDs of what we call persisted

00:14:15,550 --> 00:14:21,579
queries that means that for any query

00:14:18,639 --> 00:14:23,889
that any queries that our clients want

00:14:21,579 --> 00:14:27,010
to send us we store them in a database

00:14:23,889 --> 00:14:28,660
on the server we give them an ID and we

00:14:27,010 --> 00:14:31,029
ask the clients to send us this ID

00:14:28,660 --> 00:14:33,399
instead so this has the obvious

00:14:31,029 --> 00:14:34,779
advantage that we say if we save a lot

00:14:33,399 --> 00:14:36,670
of bandwidth especially on slower

00:14:34,779 --> 00:14:38,680
networks somewhere our queries are

00:14:36,670 --> 00:14:42,630
pretty big yeah I think going into maybe

00:14:38,680 --> 00:14:45,040
hundreds of kilobytes tens at least so

00:14:42,630 --> 00:14:47,800
this save some bandwidth but it has some

00:14:45,040 --> 00:14:49,480
it enables lots and lots of other

00:14:47,800 --> 00:14:54,760
optimizations like some that I'll

00:14:49,480 --> 00:14:59,290
mention I'll mention later so let's go

00:14:54,760 --> 00:15:00,490
back to the present or last year then

00:14:59,290 --> 00:15:02,500
the main thing that we worked on last

00:15:00,490 --> 00:15:04,089
year was we were building a new server

00:15:02,500 --> 00:15:05,800
runtime based on the open source

00:15:04,089 --> 00:15:08,050
specification to be used as a

00:15:05,800 --> 00:15:09,910
replacement for the old like a secret of

00:15:08,050 --> 00:15:11,980
kill that we the server that we had and

00:15:09,910 --> 00:15:13,660
this was again a good opportunity for us

00:15:11,980 --> 00:15:15,790
to revisit the various things about how

00:15:13,660 --> 00:15:18,279
the old server worked and in this case

00:15:15,790 --> 00:15:23,860
it was mostly concentrating on that on

00:15:18,279 --> 00:15:25,449
performance making things faster so

00:15:23,860 --> 00:15:28,149
first thing let's talk about parsing

00:15:25,449 --> 00:15:31,559
parsing is a pretty big chunk of the

00:15:28,149 --> 00:15:33,819
overhead of graph QL I think even after

00:15:31,559 --> 00:15:36,129
even after some of the optimizations

00:15:33,819 --> 00:15:37,779
element I'll mention it's still

00:15:36,129 --> 00:15:39,959
something on the order of 10 percent of

00:15:37,779 --> 00:15:47,230
the overhead that's a very rough number

00:15:39,959 --> 00:15:50,910
so it's it's pretty costly and the

00:15:47,230 --> 00:15:50,910
obvious thing you can do there is that

00:15:51,329 --> 00:15:54,999
we realize that will

00:15:53,290 --> 00:15:57,179
we're probably executing the same

00:15:54,999 --> 00:15:59,559
graphical queries over and over again

00:15:57,179 --> 00:16:01,149
for example something like the newsfeed

00:15:59,559 --> 00:16:03,040
query from whatever is the current

00:16:01,149 --> 00:16:04,389
version of Facebook for Android we've

00:16:03,040 --> 00:16:07,029
been executing that over and over again

00:16:04,389 --> 00:16:08,799
so let's not let's not parse it every

00:16:07,029 --> 00:16:11,919
time let's just parse it once and store

00:16:08,799 --> 00:16:13,449
it in a memory in its pre parse form so

00:16:11,919 --> 00:16:15,939
to see how much we could save with an

00:16:13,449 --> 00:16:20,730
optimization like this we would look at

00:16:15,939 --> 00:16:23,290
some data so this is a chart that shows

00:16:20,730 --> 00:16:26,019
what percentage of production traffic

00:16:23,290 --> 00:16:29,949
would be covered if we if we stopped

00:16:26,019 --> 00:16:31,629
parsing the top X top X queries now the

00:16:29,949 --> 00:16:34,389
exact numbers here are not important

00:16:31,629 --> 00:16:35,319
what I just wanna which is you probably

00:16:34,389 --> 00:16:38,049
don't see them anyway

00:16:35,319 --> 00:16:40,720
but uh what I want to show you is that

00:16:38,049 --> 00:16:43,059
it's either it's clear that we can gain

00:16:40,720 --> 00:16:45,129
big advantages from storing the first

00:16:43,059 --> 00:16:47,529
few queries and then we quickly get into

00:16:45,129 --> 00:16:49,329
diminishing returns where we can store

00:16:47,529 --> 00:16:51,730
hundreds of more queries for only

00:16:49,329 --> 00:16:56,019
covering a small increase in percentage

00:16:51,730 --> 00:16:57,850
of production traffic it's a it's

00:16:56,019 --> 00:16:59,230
amazing how smooth this graph is right

00:16:57,850 --> 00:17:01,619
you you wouldn't believe you wouldn't

00:16:59,230 --> 00:17:04,419
leave this as actual data

00:17:01,619 --> 00:17:07,120
yeah so uh

00:17:04,419 --> 00:17:09,789
based on this we arrived at a kind of a

00:17:07,120 --> 00:17:12,279
sweet spot where if we store the top 200

00:17:09,789 --> 00:17:13,990
queries that we see in production at any

00:17:12,279 --> 00:17:15,970
point in time if you store these in

00:17:13,990 --> 00:17:17,350
memory in their pre passed form that

00:17:15,970 --> 00:17:19,630
means we wouldn't have to parse about

00:17:17,350 --> 00:17:22,120
seven we wouldn't have to parse anything

00:17:19,630 --> 00:17:24,880
in about 70% of the graphical requests

00:17:22,120 --> 00:17:27,130
we receive in production of course the

00:17:24,880 --> 00:17:28,659
top 200 queries change all the time so

00:17:27,130 --> 00:17:32,529
we have to recompute what those are

00:17:28,659 --> 00:17:36,730
daily or even multiple times a day but

00:17:32,529 --> 00:17:38,950
this is still always true so we actually

00:17:36,730 --> 00:17:40,629
have this right now at every and every

00:17:38,950 --> 00:17:42,580
one of our web servers a chunk of memory

00:17:40,629 --> 00:17:44,950
is dedicated to storing the pre past

00:17:42,580 --> 00:17:47,920
form of whatever the top 200

00:17:44,950 --> 00:17:49,420
your queries are at the time this is one

00:17:47,920 --> 00:17:53,110
good optimization that allowed us to

00:17:49,420 --> 00:17:57,730
save over two-thirds of the parsing CPU

00:17:53,110 --> 00:17:58,930
cost another optimization was that we

00:17:57,730 --> 00:18:01,750
don't always have to parse the whole

00:17:58,930 --> 00:18:04,180
query a typical query consists of a one

00:18:01,750 --> 00:18:07,570
operation and then all the fragments

00:18:04,180 --> 00:18:09,100
tens or even hundreds in some cases so

00:18:07,570 --> 00:18:11,290
let's just start by parsing the

00:18:09,100 --> 00:18:12,760
operation and if we start executing the

00:18:11,290 --> 00:18:15,780
operation and then we run into some

00:18:12,760 --> 00:18:18,760
fragments that we need to expand

00:18:15,780 --> 00:18:22,210
we just parse them we just parse them at

00:18:18,760 --> 00:18:26,920
that point so this is another useful

00:18:22,210 --> 00:18:29,200
optimization and then at some point we

00:18:26,920 --> 00:18:31,150
just at some point we ran out of these

00:18:29,200 --> 00:18:32,920
clever ideas that we could that we could

00:18:31,150 --> 00:18:34,690
implement so we just had to put our

00:18:32,920 --> 00:18:38,500
heads down and just optimize the

00:18:34,690 --> 00:18:40,000
out of the parser that we had so just to

00:18:38,500 --> 00:18:42,220
give you an example of the kind of thing

00:18:40,000 --> 00:18:43,990
with it this is an example this is a

00:18:42,220 --> 00:18:47,290
chunk of code from our actual production

00:18:43,990 --> 00:18:51,090
graphical parser in a in hack which is a

00:18:47,290 --> 00:18:54,070
sort of an enhanced version of PHP and

00:18:51,090 --> 00:18:55,690
you can see some pretty crazy

00:18:54,070 --> 00:18:57,580
optimizations here for example the

00:18:55,690 --> 00:19:00,010
conditions in the loop are ordered by

00:18:57,580 --> 00:19:01,870
likelihood so since the most common type

00:19:00,010 --> 00:19:04,540
of whitespace we see is a space we check

00:19:01,870 --> 00:19:05,920
for that first and then it's probably

00:19:04,540 --> 00:19:07,570
short circuits and we don't even check

00:19:05,920 --> 00:19:09,910
for those other types of white space

00:19:07,570 --> 00:19:14,110
like carriage returns which we don't

00:19:09,910 --> 00:19:17,020
have at all or tabs or even we found out

00:19:14,110 --> 00:19:19,960
that in a HH VM which is our virtual

00:19:17,020 --> 00:19:22,480
machine that rounds PHP or heck it was a

00:19:19,960 --> 00:19:24,100
it was more expensive to access instance

00:19:22,480 --> 00:19:26,710
variables than it was to access

00:19:24,100 --> 00:19:28,060
variables on the stack so we would at

00:19:26,710 --> 00:19:31,660
the beginning of this function that it

00:19:28,060 --> 00:19:33,700
needs to access them multiple times we

00:19:31,660 --> 00:19:35,290
would copy them into into local

00:19:33,700 --> 00:19:40,110
variables on the stack and then copy

00:19:35,290 --> 00:19:43,090
them back at the end so with things like

00:19:40,110 --> 00:19:46,330
with things with optimizations like this

00:19:43,090 --> 00:19:49,930
we were able to from from the naive ax

00:19:46,330 --> 00:19:51,820
or initially prototype information that

00:19:49,930 --> 00:19:55,360
we had who made it faster by something

00:19:51,820 --> 00:19:57,100
like between 2/3 and 3/4 so if you put

00:19:55,360 --> 00:19:58,870
these if you put if you put this all

00:19:57,100 --> 00:20:03,250
together you can calculate the

00:19:58,870 --> 00:20:04,900
we made the parser about probably around

00:20:03,250 --> 00:20:06,640
10 times faster than it would have been

00:20:04,900 --> 00:20:08,320
without any of these optimizations so

00:20:06,640 --> 00:20:11,380
since the parser is now

00:20:08,320 --> 00:20:13,210
10% of the overhead you can imagine that

00:20:11,380 --> 00:20:15,100
without this it would be about half of

00:20:13,210 --> 00:20:18,550
the overhead so that would be that would

00:20:15,100 --> 00:20:21,760
be pretty crazy so this is some pretty

00:20:18,550 --> 00:20:23,440
good stuff another thing that the

00:20:21,760 --> 00:20:25,210
graphical server does is validating

00:20:23,440 --> 00:20:26,559
queries before we run them to detect

00:20:25,210 --> 00:20:28,570
things like when you're trying to query

00:20:26,559 --> 00:20:31,300
for fields that don't exist or if you

00:20:28,570 --> 00:20:33,760
have an infinite cycle in your fragments

00:20:31,300 --> 00:20:35,679
things like that the optimization we did

00:20:33,760 --> 00:20:40,240
here is actually pretty simple we just

00:20:35,679 --> 00:20:42,280
don't do it so the idea here is that

00:20:40,240 --> 00:20:44,380
since most of our queries are persisted

00:20:42,280 --> 00:20:46,450
queries we only get an ID we don't need

00:20:44,380 --> 00:20:48,340
to parse them every time we just we just

00:20:46,450 --> 00:20:50,710
or we don't need to validate them every

00:20:48,340 --> 00:20:52,690
time we just validate them once at the

00:20:50,710 --> 00:20:54,309
time their persisted and then when

00:20:52,690 --> 00:20:55,750
they're actually running production we

00:20:54,309 --> 00:20:58,240
already know they're valid so there's

00:20:55,750 --> 00:20:59,830
just no reason to do it again so we

00:20:58,240 --> 00:21:03,460
don't even need to optimize this we just

00:20:59,830 --> 00:21:05,200
don't do it then another thing that the

00:21:03,460 --> 00:21:07,690
graphical server does and it also

00:21:05,200 --> 00:21:09,610
accounts for a non-trivial chunk of the

00:21:07,690 --> 00:21:13,120
overhead is a something we call

00:21:09,610 --> 00:21:14,440
defragmenting it's a when you have an

00:21:13,120 --> 00:21:16,590
object which about with a bunch of

00:21:14,440 --> 00:21:19,059
fields and maybe multiple fragments

00:21:16,590 --> 00:21:21,580
possibly nested fragments and you're

00:21:19,059 --> 00:21:25,000
trying to actually generate the response

00:21:21,580 --> 00:21:26,770
to send to the client and you know we

00:21:25,000 --> 00:21:33,460
need to merge all the fields from the

00:21:26,770 --> 00:21:34,600
different fragments and yeah so we'll

00:21:33,460 --> 00:21:38,650
merge merge all the fields from the

00:21:34,600 --> 00:21:39,790
different fragments so one this seems

00:21:38,650 --> 00:21:42,160
like another good candidate for

00:21:39,790 --> 00:21:43,450
memorization like maybe there's a there

00:21:42,160 --> 00:21:47,170
might be fragments in the query which

00:21:43,450 --> 00:21:48,640
are included repeatedly or things like

00:21:47,170 --> 00:21:52,030
that so this seems like something that

00:21:48,640 --> 00:21:54,580
we could also memorize but wait not so

00:21:52,030 --> 00:21:57,220
fast this is a screenshot from the open

00:21:54,580 --> 00:21:59,200
source two fql specification this is the

00:21:57,220 --> 00:22:00,640
relevant function that is respond or

00:21:59,200 --> 00:22:03,790
just this is the part this is the

00:22:00,640 --> 00:22:06,820
function that's responsible for doing

00:22:03,790 --> 00:22:08,710
this this part of graphical execution

00:22:06,820 --> 00:22:10,960
and you can see that this function has

00:22:08,710 --> 00:22:12,140
with four arguments one of them is a

00:22:10,960 --> 00:22:13,910
selection set

00:22:12,140 --> 00:22:16,670
actually a list of notes did not be

00:22:13,910 --> 00:22:18,380
arbitrarily long so even calculating

00:22:16,670 --> 00:22:20,150
some kind of cash key that we could use

00:22:18,380 --> 00:22:21,970
to memorize the values that this

00:22:20,150 --> 00:22:24,140
function calculates that would be a

00:22:21,970 --> 00:22:26,030
doubling a non-trivial amount of work

00:22:24,140 --> 00:22:28,520
probably it would cost more than we

00:22:26,030 --> 00:22:29,870
would even say from the memorization so

00:22:28,520 --> 00:22:32,360
the first thing we would even need to do

00:22:29,870 --> 00:22:33,730
before we even consider is is figure out

00:22:32,360 --> 00:22:38,750
a way to make this function more

00:22:33,730 --> 00:22:40,730
memories I memo is able so to speak so

00:22:38,750 --> 00:22:42,710
the header the function header we

00:22:40,730 --> 00:22:44,260
actually ended up with looks sort of

00:22:42,710 --> 00:22:46,670
like this it's actually pretty similar

00:22:44,260 --> 00:22:49,960
has the context which just has the

00:22:46,670 --> 00:22:52,340
variable values the parents type again

00:22:49,960 --> 00:22:53,900
but then instead of this selection set

00:22:52,340 --> 00:22:55,430
we figure we figure out that the

00:22:53,900 --> 00:22:57,650
selection set must come from somewhere

00:22:55,430 --> 00:23:00,470
in the original graphical or query text

00:22:57,650 --> 00:23:02,390
so instead of storing instead of trying

00:23:00,470 --> 00:23:05,270
to calculate the memorization key based

00:23:02,390 --> 00:23:07,700
on the selection set we just stored the

00:23:05,270 --> 00:23:11,030
one node it came from my weight actually

00:23:07,700 --> 00:23:12,650
it's not always one node in some cases

00:23:11,030 --> 00:23:14,630
that might be multiple nodes if our

00:23:12,650 --> 00:23:16,520
because of these fairly complicated

00:23:14,630 --> 00:23:19,400
merging behaviors that can happen in

00:23:16,520 --> 00:23:22,010
some cases so this actually has to be a

00:23:19,400 --> 00:23:25,280
vector of parent nodes but in most cases

00:23:22,010 --> 00:23:27,170
it is indeed just one node or very few

00:23:25,280 --> 00:23:32,450
nodes so this is a small vector and it's

00:23:27,170 --> 00:23:34,370
pretty feasible to memorize on that so

00:23:32,450 --> 00:23:37,880
now that we made it sort of memorize

00:23:34,370 --> 00:23:39,919
memorize able the other thing is

00:23:37,880 --> 00:23:43,370
we still had to consider whether it

00:23:39,919 --> 00:23:45,049
makes sense to memorize every time like

00:23:43,370 --> 00:23:46,549
do do we actually do repeated word

00:23:45,049 --> 00:23:48,230
that's worth memorizing or would the

00:23:46,549 --> 00:23:51,500
overhead of memorizing just be a waste

00:23:48,230 --> 00:23:53,799
of time and memory so once again we

00:23:51,500 --> 00:23:56,270
looked at some data so this is an

00:23:53,799 --> 00:23:58,730
analysis of one of our biggest queries

00:23:56,270 --> 00:24:03,320
probably the newsfeed query or something

00:23:58,730 --> 00:24:05,360
similar and it shows here that the

00:24:03,320 --> 00:24:08,929
majority of the selection sets that we

00:24:05,360 --> 00:24:11,600
defragment only only occur once the 454

00:24:08,929 --> 00:24:13,190
selection sets only occur once but

00:24:11,600 --> 00:24:16,070
there's a significant amount that occur

00:24:13,190 --> 00:24:17,480
multiple times there there there's quite

00:24:16,070 --> 00:24:20,120
a lot that occurred two or three times

00:24:17,480 --> 00:24:23,179
then it goes down but there are a few

00:24:20,120 --> 00:24:26,330
outliers like this one that occurs 211

00:24:23,179 --> 00:24:27,919
times in the same query so it seems that

00:24:26,330 --> 00:24:29,360
it might be worth memorizing some times

00:24:27,919 --> 00:24:31,159
but maybe we want to be a little more

00:24:29,360 --> 00:24:36,470
clever and just not do it all the time

00:24:31,159 --> 00:24:38,600
so the first idea we had was to just

00:24:36,470 --> 00:24:40,789
memorize four lists so if we have a list

00:24:38,600 --> 00:24:43,100
then the same selection set would be

00:24:40,789 --> 00:24:45,260
evaluated for every element of that list

00:24:43,100 --> 00:24:47,270
so there was a good candidate and we had

00:24:45,260 --> 00:24:48,890
some success with memorizing that but

00:24:47,270 --> 00:24:51,200
over time we were we were actually able

00:24:48,890 --> 00:24:53,539
to micro optimize the generation of the

00:24:51,200 --> 00:24:55,250
cache key even more and at the point at

00:24:53,539 --> 00:24:57,830
that point became fees became feasible

00:24:55,250 --> 00:25:01,000
to memorize even more often now we

00:24:57,830 --> 00:25:03,350
memorize always but only as long as this

00:25:01,000 --> 00:25:05,210
vector of parent notes only has one

00:25:03,350 --> 00:25:08,360
element which turns out to be like over

00:25:05,210 --> 00:25:10,220
90% of cases so if it has more than one

00:25:08,360 --> 00:25:12,980
element which is in one of those crazy

00:25:10,220 --> 00:25:16,370
merging scenarios were so then in those

00:25:12,980 --> 00:25:20,450
cases we just don't memorize it and that

00:25:16,370 --> 00:25:22,070
seems to work pretty well and the final

00:25:20,450 --> 00:25:25,760
optimization we've done that I'd like to

00:25:22,070 --> 00:25:29,450
mention so if you think of the graph QL

00:25:25,760 --> 00:25:32,600
schema the type system on your server it

00:25:29,450 --> 00:25:34,909
consists of a set of graphical types in

00:25:32,600 --> 00:25:37,940
our case thousands of them

00:25:34,909 --> 00:25:40,190
then each type has fields ranging

00:25:37,940 --> 00:25:42,559
anywhere from one to hundreds of fields

00:25:40,190 --> 00:25:45,500
and a field may have in the field in

00:25:42,559 --> 00:25:47,000
turn has some arguments so it turned out

00:25:45,500 --> 00:25:50,530
to be really important for us to

00:25:47,000 --> 00:25:52,720
instantiate these lazily so we wouldn't

00:25:50,530 --> 00:25:54,790
and every time we receive a pipe request

00:25:52,720 --> 00:25:56,500
we wouldn't instant she ate this whole

00:25:54,790 --> 00:25:57,760
schema with all the possible types and

00:25:56,500 --> 00:25:59,740
all the possible field and their

00:25:57,760 --> 00:26:01,690
definitions and all their arguments we

00:25:59,740 --> 00:26:04,060
just instantiate without whichever types

00:26:01,690 --> 00:26:07,240
or whichever queries whichever fields

00:26:04,060 --> 00:26:09,520
were actually queried and one specific

00:26:07,240 --> 00:26:12,100
example I'd like to show you is how we

00:26:09,520 --> 00:26:14,170
handle arguments and first I'll show you

00:26:12,100 --> 00:26:16,930
what it looks like in the reference

00:26:14,170 --> 00:26:19,180
implementation in graph qlj s so this is

00:26:16,930 --> 00:26:21,640
the relevant chunk from graphical J's

00:26:19,180 --> 00:26:26,710
that resolves the value of a graphical

00:26:21,640 --> 00:26:28,480
field this function here it constructs

00:26:26,710 --> 00:26:30,580
all the argument definitions for the

00:26:28,480 --> 00:26:35,230
given field and then courses the

00:26:30,580 --> 00:26:37,690
arguments to the to the correct value of

00:26:35,230 --> 00:26:40,210
the of the correct type of each argument

00:26:37,690 --> 00:26:42,070
and then we pass the course arguments to

00:26:40,210 --> 00:26:44,680
the resolver function so this makes a

00:26:42,070 --> 00:26:46,600
lot of sense but it actually wastes some

00:26:44,680 --> 00:26:50,050
work that doesn't really need to need to

00:26:46,600 --> 00:26:54,160
be done so what we actually do looks

00:26:50,050 --> 00:26:56,620
sort of like this so we rely heavily on

00:26:54,160 --> 00:26:58,720
generated code we generate a super

00:26:56,620 --> 00:27:03,790
optimized resolver for every field in

00:26:58,720 --> 00:27:06,430
our graphical schema and this mean if

00:27:03,790 --> 00:27:07,630
you can if you if you look here you'll

00:27:06,430 --> 00:27:10,870
notice that this doesn't actually

00:27:07,630 --> 00:27:13,120
construct any sort of an object that

00:27:10,870 --> 00:27:14,500
would represent an argument at all all

00:27:13,120 --> 00:27:16,660
we construct is an object that

00:27:14,500 --> 00:27:19,120
represents the type of the argument so

00:27:16,660 --> 00:27:20,650
the first argument width is of an int

00:27:19,120 --> 00:27:23,170
type so we have this generated

00:27:20,650 --> 00:27:26,170
hard-coded object that represents the

00:27:23,170 --> 00:27:31,900
inste type here and then we have then we

00:27:26,170 --> 00:27:34,690
just use that and another thing here is

00:27:31,900 --> 00:27:36,610
that we don't even do this if the

00:27:34,690 --> 00:27:39,130
argument was not actually specified in

00:27:36,610 --> 00:27:41,440
the query so if there isn't a if there

00:27:39,130 --> 00:27:43,690
isn't a width argument in the query then

00:27:41,440 --> 00:27:45,760
we don't even construct the the

00:27:43,690 --> 00:27:48,820
representation of the in type we just

00:27:45,760 --> 00:27:52,170
immediately store now in this in this in

00:27:48,820 --> 00:27:52,170
this variable

00:27:54,009 --> 00:27:59,629
all right so that's an overview of some

00:27:57,739 --> 00:28:01,940
performance optimizations that we've

00:27:59,629 --> 00:28:04,609
done that allowed us to make the new

00:28:01,940 --> 00:28:09,139
server even faster than the old one that

00:28:04,609 --> 00:28:11,710
we had now I'd like to move back to the

00:28:09,139 --> 00:28:16,099
present or move forward to the present

00:28:11,710 --> 00:28:18,559
what we're working on right now is that

00:28:16,099 --> 00:28:20,269
we're trying to revisit how server

00:28:18,559 --> 00:28:23,389
developers write these graphical

00:28:20,269 --> 00:28:26,359
definitions by which I mean the first

00:28:23,389 --> 00:28:29,210
part is what types exist in our schema

00:28:26,359 --> 00:28:30,769
and how how do they declare what types

00:28:29,210 --> 00:28:34,580
exists and what fields exist on these

00:28:30,769 --> 00:28:36,769
types and then an even more or even more

00:28:34,580 --> 00:28:38,239
interesting part is how do they create

00:28:36,769 --> 00:28:40,969
these field resolvers how do they

00:28:38,239 --> 00:28:44,109
declare the chunk of PHP code that

00:28:40,969 --> 00:28:47,029
actually resolves the value of the field

00:28:44,109 --> 00:28:48,950
one idea that sometimes comes up is that

00:28:47,029 --> 00:28:51,409
we could use the graphical idea language

00:28:48,950 --> 00:28:54,169
which i think is soon to be part of the

00:28:51,409 --> 00:28:56,659
official specification so a developer

00:28:54,169 --> 00:28:58,969
would write the definition of their type

00:28:56,659 --> 00:29:00,559
in the ideal language and from that we

00:28:58,969 --> 00:29:02,719
would generate some kind of stuff some

00:29:00,559 --> 00:29:05,089
kind of PHP class with empty functions

00:29:02,719 --> 00:29:07,279
that they would have to fill in and then

00:29:05,089 --> 00:29:09,469
they would run some other build step

00:29:07,279 --> 00:29:11,179
that generates the super optimize the

00:29:09,469 --> 00:29:14,359
runtime definitions like the one that I

00:29:11,179 --> 00:29:16,460
just showed you so this is one

00:29:14,359 --> 00:29:20,749
possibility that would be a fully

00:29:16,460 --> 00:29:23,719
typesafe but it seems like a lot of

00:29:20,749 --> 00:29:25,369
steps that people never like having to

00:29:23,719 --> 00:29:28,429
do a lot of steps as part of their

00:29:25,369 --> 00:29:32,389
development potentially hundreds of

00:29:28,429 --> 00:29:33,799
times during the day and also you would

00:29:32,389 --> 00:29:38,710
force everyone to learn this new

00:29:33,799 --> 00:29:41,450
language this this graphical IDL which

00:29:38,710 --> 00:29:43,639
and it's not necessarily a bad thing you

00:29:41,450 --> 00:29:44,779
you could argue that you want people who

00:29:43,639 --> 00:29:46,879
write graphical definitions to

00:29:44,779 --> 00:29:52,609
understand graph QL but on the other

00:29:46,879 --> 00:29:56,089
hand in some cases it's good to have a

00:29:52,609 --> 00:29:57,859
lower barrier of entry so we've been

00:29:56,089 --> 00:30:01,460
thinking of different ways to bridge the

00:29:57,859 --> 00:30:05,179
the graph QL and the HEC type system or

00:30:01,460 --> 00:30:07,040
the PHP reg type system so one idea

00:30:05,179 --> 00:30:08,390
we're experimenting with now is

00:30:07,040 --> 00:30:10,220
if we could just take the existing

00:30:08,390 --> 00:30:13,940
functions that people already have and

00:30:10,220 --> 00:30:19,010
annotate them using attributes so that

00:30:13,940 --> 00:30:23,060
they become exposed as a as fresh fuel

00:30:19,010 --> 00:30:25,190
types so here we annotate some class so

00:30:23,060 --> 00:30:27,230
that it is it exposed as an object type

00:30:25,190 --> 00:30:29,030
in graph QL and then I'll say some

00:30:27,230 --> 00:30:34,430
function so it is exposed as in graph QL

00:30:29,030 --> 00:30:35,750
field the graphical framework can infer

00:30:34,430 --> 00:30:37,730
pretty much everything that it needs

00:30:35,750 --> 00:30:39,020
from the from the HEC code so this

00:30:37,730 --> 00:30:41,390
includes the types of the arguments

00:30:39,020 --> 00:30:43,040
including things like which arguments

00:30:41,390 --> 00:30:44,810
are optional which arguments have

00:30:43,040 --> 00:30:47,480
default values and what those default

00:30:44,810 --> 00:30:50,000
values are this this is we can access

00:30:47,480 --> 00:30:54,380
all these using using reflection in the

00:30:50,000 --> 00:30:55,850
heck and hh3m and a big advantage of

00:30:54,380 --> 00:30:57,830
this that we can get a lot of type

00:30:55,850 --> 00:31:01,190
checking for free from the HEC type

00:30:57,830 --> 00:31:02,930
checker so if for example the developer

00:31:01,190 --> 00:31:05,120
tries to return something that's not an

00:31:02,930 --> 00:31:06,890
image from this function it would be a

00:31:05,120 --> 00:31:10,730
type error and it will be immediately

00:31:06,890 --> 00:31:12,380
surface to them and we can take this

00:31:10,730 --> 00:31:17,390
even further we can implement things

00:31:12,380 --> 00:31:19,640
like interfaces so if we annotate a HEC

00:31:17,390 --> 00:31:24,470
interface so that it becomes a graphical

00:31:19,640 --> 00:31:26,900
interface then any any any HEC class

00:31:24,470 --> 00:31:28,970
that implements this interface if it's

00:31:26,900 --> 00:31:30,650
annotated as a graphic you'll type that

00:31:28,970 --> 00:31:32,570
would mean that graphical type also has

00:31:30,650 --> 00:31:36,080
to implement the respective graphical

00:31:32,570 --> 00:31:38,960
interface so this is pretty neat because

00:31:36,080 --> 00:31:41,510
the hack Peck type checker enforces that

00:31:38,960 --> 00:31:44,000
both the HEC type system is sound and

00:31:41,510 --> 00:31:46,580
that the graphical type system is sound

00:31:44,000 --> 00:31:49,310
so if for example they forget to add a

00:31:46,580 --> 00:31:50,450
gen profile picture function here which

00:31:49,310 --> 00:31:52,850
means we wouldn't know how to resolve

00:31:50,450 --> 00:31:54,440
the profile picture graphical field this

00:31:52,850 --> 00:31:58,220
would be a type error that the heck type

00:31:54,440 --> 00:32:00,470
trigger wouldn't let in so that's pretty

00:31:58,220 --> 00:32:03,350
neat another thing that people like to

00:32:00,470 --> 00:32:05,690
do is a reusing their field resolver

00:32:03,350 --> 00:32:07,340
code for example I'd say the profile

00:32:05,690 --> 00:32:08,840
picture field could be implemented in

00:32:07,340 --> 00:32:10,070
the same way on different types and we

00:32:08,840 --> 00:32:12,800
won't don't want people to have to write

00:32:10,070 --> 00:32:14,000
this code over and over again so this is

00:32:12,800 --> 00:32:15,800
something that would we would get

00:32:14,000 --> 00:32:17,570
completely for free in a system like

00:32:15,800 --> 00:32:19,130
this because we can we can use the

00:32:17,570 --> 00:32:20,600
methods that heck already has for

00:32:19,130 --> 00:32:25,250
reusing code

00:32:20,600 --> 00:32:26,960
like apps or classes or trades and the

00:32:25,250 --> 00:32:28,790
list goes on there are other things that

00:32:26,960 --> 00:32:31,010
line up quite nicely for example list

00:32:28,790 --> 00:32:33,590
types exist in hag and in graph QL in

00:32:31,010 --> 00:32:37,820
essentially the same form same thing for

00:32:33,590 --> 00:32:40,040
enum types so these are some things that

00:32:37,820 --> 00:32:43,550
will work but we also have some concerns

00:32:40,040 --> 00:32:46,520
so no no system is without disadvantages

00:32:43,550 --> 00:32:49,460
and the one open question here is what

00:32:46,520 --> 00:32:51,710
to do if there are situations where the

00:32:49,460 --> 00:32:53,330
type systems don't quite line up so I

00:32:51,710 --> 00:32:55,100
have some examples from where that

00:32:53,330 --> 00:32:56,750
happens in heck but if you try to apply

00:32:55,100 --> 00:32:58,430
similar concepts to any other language

00:32:56,750 --> 00:33:00,530
you'll probably come up with that maybe

00:32:58,430 --> 00:33:02,990
the same maybe different examples one

00:33:00,530 --> 00:33:04,790
example is a union types which are an

00:33:02,990 --> 00:33:07,760
important part of graph QL but don't

00:33:04,790 --> 00:33:09,650
exist at all in a heck and then there

00:33:07,760 --> 00:33:11,900
are things like input objects where the

00:33:09,650 --> 00:33:14,540
similar concept exists but it's not

00:33:11,900 --> 00:33:16,670
quite the same for example there's no

00:33:14,540 --> 00:33:19,160
way to declare default values which are

00:33:16,670 --> 00:33:21,770
also people use a lot of input objects

00:33:19,160 --> 00:33:23,960
in our schema so that's one thing that

00:33:21,770 --> 00:33:26,300
comes up another the another thing that

00:33:23,960 --> 00:33:29,180
comes up is that it's not always not

00:33:26,300 --> 00:33:30,590
always a good idea to just mix your what

00:33:29,180 --> 00:33:33,140
is essentially a declaration of your

00:33:30,590 --> 00:33:37,310
public API with your internal codes a

00:33:33,140 --> 00:33:40,430
very very valid concern but on the other

00:33:37,310 --> 00:33:42,530
hand sometimes sometimes the classes you

00:33:40,430 --> 00:33:44,600
have already are sort of a public API

00:33:42,530 --> 00:33:46,760
for your data model and in those cases

00:33:44,600 --> 00:33:49,460
we don't want to force you to write a

00:33:46,760 --> 00:33:50,870
second second declaration just for

00:33:49,460 --> 00:33:52,790
graphical it's nice that you can just

00:33:50,870 --> 00:33:56,000
annotate the existing one so there's a

00:33:52,790 --> 00:33:58,040
trade-off here I think we'll have to

00:33:56,000 --> 00:34:00,020
trust people that they would be careful

00:33:58,040 --> 00:34:01,700
about doing this right and if there's

00:34:00,020 --> 00:34:03,260
some sort of internal class that

00:34:01,700 --> 00:34:05,810
shouldn't really be exposed as public

00:34:03,260 --> 00:34:08,480
API they'll try to extract the public

00:34:05,810 --> 00:34:14,180
idea into a separate wrapper class or an

00:34:08,480 --> 00:34:15,410
interface or something else all right so

00:34:14,180 --> 00:34:18,710
that's what we're that's what we're

00:34:15,410 --> 00:34:20,600
thinking about right now and to conclude

00:34:18,710 --> 00:34:22,160
the talk I'd like to just mention a few

00:34:20,600 --> 00:34:24,230
things that we haven't really tackled

00:34:22,160 --> 00:34:26,290
yet but that sometimes come up in

00:34:24,230 --> 00:34:30,080
discussions and that we may or may at

00:34:26,290 --> 00:34:32,350
tackle in the future so an interesting

00:34:30,080 --> 00:34:34,409
one is this notion of non-null ability

00:34:32,350 --> 00:34:36,030
graph QL allows fields to

00:34:34,409 --> 00:34:37,740
unknowable in which case the server

00:34:36,030 --> 00:34:40,200
should guarantee that the value of the

00:34:37,740 --> 00:34:41,819
field is never now clients developers

00:34:40,200 --> 00:34:43,559
love this because then they don't have

00:34:41,819 --> 00:34:45,780
to do now checks in their code and it's

00:34:43,559 --> 00:34:48,000
like they save a lot of boilerplate it's

00:34:45,780 --> 00:34:50,879
just great all around the problem is

00:34:48,000 --> 00:34:53,460
that on the server life is not so easy

00:34:50,879 --> 00:34:57,119
we can't really guarantee anything any

00:34:53,460 --> 00:34:59,309
field resolver which is arbitrary PHP

00:34:57,119 --> 00:35:02,520
code may throw an exception and then we

00:34:59,309 --> 00:35:04,950
just have no value no value to put there

00:35:02,520 --> 00:35:08,609
so the question is how how do we resolve

00:35:04,950 --> 00:35:10,559
this like how do we how do we allow a

00:35:08,609 --> 00:35:12,780
server developers to exposed unknowable

00:35:10,559 --> 00:35:16,500
fields but also allow them to actually

00:35:12,780 --> 00:35:19,049
provide some guarantees that's one thing

00:35:16,500 --> 00:35:23,730
another thing another popular topic is

00:35:19,049 --> 00:35:24,900
error handling so graph keep the

00:35:23,730 --> 00:35:27,059
graphical specification actually

00:35:24,900 --> 00:35:28,500
provides a good way to do this it it

00:35:27,059 --> 00:35:31,079
specifies that the response should

00:35:28,500 --> 00:35:33,480
contain a list of errors these errors

00:35:31,079 --> 00:35:34,890
may contain arbitrary metadata so it's

00:35:33,480 --> 00:35:36,539
not infeasible that we will include

00:35:34,890 --> 00:35:38,490
something like a path to where the error

00:35:36,539 --> 00:35:41,220
happened directly there in the response

00:35:38,490 --> 00:35:42,990
and the clients can do whatever they

00:35:41,220 --> 00:35:45,390
want with these errors have some kind of

00:35:42,990 --> 00:35:49,920
super sensible extremely nuanced error

00:35:45,390 --> 00:35:52,680
behavior but the truth is that clients

00:35:49,920 --> 00:35:55,440
don't really like to do this they don't

00:35:52,680 --> 00:35:57,299
want to have a super sensible extremely

00:35:55,440 --> 00:35:59,880
nuanced error behavior for every single

00:35:57,299 --> 00:36:01,619
traffic you'll field in the response so

00:35:59,880 --> 00:36:03,690
the question is how how can we provide

00:36:01,619 --> 00:36:07,380
frameworks or abstractions on either the

00:36:03,690 --> 00:36:10,140
server or the client side then make

00:36:07,380 --> 00:36:12,390
error handling that make good error

00:36:10,140 --> 00:36:16,920
handling easy easy to do for client

00:36:12,390 --> 00:36:19,950
developers so that's a that's all I have

00:36:16,920 --> 00:36:21,779
at this point I like to open it up for

00:36:19,950 --> 00:36:24,710
any questions you might have

00:36:21,779 --> 00:36:24,710
thank you for listening

00:36:26,820 --> 00:36:35,130
[Music]

00:36:28,040 --> 00:36:37,170
yes question the question is whether we

00:36:35,130 --> 00:36:40,230
have some kind of a new global context

00:36:37,170 --> 00:36:42,060
object that we pass to we pass to all

00:36:40,230 --> 00:36:43,890
the field field implementations that

00:36:42,060 --> 00:36:45,540
they can use for things like fetching

00:36:43,890 --> 00:36:48,900
the currently logged in user and that

00:36:45,540 --> 00:36:55,530
yes we we have that so I I didn't do the

00:36:48,900 --> 00:36:57,360
way so on there are there are multiple

00:36:55,530 --> 00:36:59,250
ways to do this they're served the right

00:36:57,360 --> 00:37:02,190
way to do this and there's sort of the

00:36:59,250 --> 00:37:04,470
way that we actually have to do this the

00:37:02,190 --> 00:37:06,420
right way is that this should ideally be

00:37:04,470 --> 00:37:10,050
part of the parent object which is

00:37:06,420 --> 00:37:12,150
always a accessible so like if you're if

00:37:10,050 --> 00:37:14,310
you're if you're a field on the user

00:37:12,150 --> 00:37:16,560
object the user object would contain

00:37:14,310 --> 00:37:19,020
this context and then pass it down to

00:37:16,560 --> 00:37:22,050
any any child objects so that's sort of

00:37:19,020 --> 00:37:23,640
the right way to do that so then then

00:37:22,050 --> 00:37:25,170
the field resolvers have no other state

00:37:23,640 --> 00:37:27,240
besides the parent object and any

00:37:25,170 --> 00:37:29,490
arguments provided to them so that's

00:37:27,240 --> 00:37:32,160
nice clean way to do that in practice

00:37:29,490 --> 00:37:36,660
this is not always so easy so we do

00:37:32,160 --> 00:37:38,880
actually so we do actually have a global

00:37:36,660 --> 00:37:41,160
context object we call it the viewer

00:37:38,880 --> 00:37:43,320
context and we make this constant we

00:37:41,160 --> 00:37:46,620
make this context object available to

00:37:43,320 --> 00:37:48,210
any any field implementations and the

00:37:46,620 --> 00:37:49,530
way to do that that's basically an

00:37:48,210 --> 00:37:51,330
implementation detail I think there are

00:37:49,530 --> 00:37:53,190
multiple different ways to do that what

00:37:51,330 --> 00:37:54,570
we would probably do in this proposal

00:37:53,190 --> 00:37:57,450
that I showed you with the with the

00:37:54,570 --> 00:37:59,790
attributes is that like if you if you

00:37:57,450 --> 00:38:02,220
include an attribute of this type the

00:37:59,790 --> 00:38:04,260
viewer context and then the graphical

00:38:02,220 --> 00:38:07,040
framework would magically put the right

00:38:04,260 --> 00:38:09,990
thing there so that's one way to do that

00:38:07,040 --> 00:38:12,170
if you have any chance just do it the

00:38:09,990 --> 00:38:12,170
right way

00:38:12,500 --> 00:38:23,450
yeah yeah I think you were first in the

00:38:21,180 --> 00:38:23,450
back

00:38:26,349 --> 00:38:31,269
I mean question is if we're doing any

00:38:28,749 --> 00:38:32,680
query optimizations like joins in SQL

00:38:31,269 --> 00:38:35,289
that's a that's a very good question

00:38:32,680 --> 00:38:37,839
actually it does a it does come up from

00:38:35,289 --> 00:38:40,209
time to time we haven't really needed it

00:38:37,839 --> 00:38:42,959
as much as perhaps some other system

00:38:40,209 --> 00:38:48,519
that depend on things like SQL because a

00:38:42,959 --> 00:38:50,920
hack and a JVM have a very good model of

00:38:48,519 --> 00:38:52,809
asynchronous execution where things get

00:38:50,920 --> 00:38:54,910
automatically batched and then sent two

00:38:52,809 --> 00:38:56,739
databases together and provides that

00:38:54,910 --> 00:38:58,479
other layer lower than graph kill so we

00:38:56,739 --> 00:39:00,880
this doesn't come up very often but it

00:38:58,479 --> 00:39:03,249
does come or from time to time and we

00:39:00,880 --> 00:39:04,839
have one at least one place I can think

00:39:03,249 --> 00:39:06,819
of where we've been experimenting with

00:39:04,839 --> 00:39:09,279
this we currently don't have a really

00:39:06,819 --> 00:39:13,539
good implementation more of a slightly

00:39:09,279 --> 00:39:16,839
Hecky one where we we give a specific

00:39:13,539 --> 00:39:18,249
field resolver a way to look ahead in

00:39:16,839 --> 00:39:20,289
the graphical query and do some

00:39:18,249 --> 00:39:22,180
optimizations based on that so that's

00:39:20,289 --> 00:39:22,869
sort of a hacky implantation please

00:39:22,180 --> 00:39:25,779
don't do that

00:39:22,869 --> 00:39:28,089
but it's a it's just so that we can see

00:39:25,779 --> 00:39:29,319
if this actually helps if it does then

00:39:28,089 --> 00:39:30,910
we'll probably try to come up with a

00:39:29,319 --> 00:39:32,469
cleaner way to do that I think there

00:39:30,910 --> 00:39:34,869
have been proposals in the community

00:39:32,469 --> 00:39:37,059
some of them were pretty good and

00:39:34,869 --> 00:39:38,769
interesting like this notion of a to

00:39:37,059 --> 00:39:40,630
pass execution where the first pass

00:39:38,769 --> 00:39:42,819
would be to gather all the information

00:39:40,630 --> 00:39:44,079
needed to optimize the query and then

00:39:42,819 --> 00:39:47,109
the second pass would actually produce

00:39:44,079 --> 00:39:50,670
the data but yeah it's a bit of an open

00:39:47,109 --> 00:39:52,239
question still very good the question

00:39:50,670 --> 00:39:53,979
thanks if you guys have any more

00:39:52,239 --> 00:39:56,440
questions for any of the speakers please

00:39:53,979 --> 00:39:57,970
feel free to ask afterwards and thank

00:39:56,440 --> 00:40:04,720
you so much for the talk yan

00:39:57,970 --> 00:40:04,720

YouTube URL: https://www.youtube.com/watch?v=nOYyix0NpvY


