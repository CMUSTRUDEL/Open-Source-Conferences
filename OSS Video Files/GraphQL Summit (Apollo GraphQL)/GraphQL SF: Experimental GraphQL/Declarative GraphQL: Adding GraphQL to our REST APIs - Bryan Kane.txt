Title: Declarative GraphQL: Adding GraphQL to our REST APIs - Bryan Kane
Publication date: 2017-11-16
Playlist: GraphQL SF: Experimental GraphQL
Description: 
	Coursera's Bryan Kane presents at GraphQL SF: Experimental GraphQL on 5/13/17.

Coursera has over 500 REST APIs in production. We're all in on GraphQL, but given this scale, it would be impossible to build a schema and write 500 custom resolvers to handle each of our endpoints. Instead, we used information we already had about our APIs (which actions are available, and request and response formats) to automatically build GraphQL resolvers and add them all to a single, unified schema. We also created a structured way for developers to define relations between models, in both forward and reverse directions, which will enable almost all pages on Coursera to be loaded via a single GraphQL query.

Join GraphQL SF to get notified about future meetups: https://www.meetup.com/GraphQL-SF/
Captions: 
	00:00:00,030 --> 00:00:07,950
let's get started with Brian from

00:00:02,850 --> 00:00:10,200
Coursera Brian please everyone I'm Brian

00:00:07,950 --> 00:00:11,759
I'm a software engineer at Coursera on

00:00:10,200 --> 00:00:13,650
the front end infrastructure team and

00:00:11,759 --> 00:00:16,350
I'll talk to you a little bit today on

00:00:13,650 --> 00:00:18,810
decorative fql basically how we adopt a

00:00:16,350 --> 00:00:20,189
graphic UL and added graphic L to all of

00:00:18,810 --> 00:00:23,189
our AP is without actually writing a

00:00:20,189 --> 00:00:24,689
single resolver so I guess give you a

00:00:23,189 --> 00:00:26,130
little bit of context for those of you

00:00:24,689 --> 00:00:28,140
who aren't familiar with the Coursera

00:00:26,130 --> 00:00:30,210
course there is an online education

00:00:28,140 --> 00:00:31,949
company we partner with the world's best

00:00:30,210 --> 00:00:33,899
universities and the best companies and

00:00:31,949 --> 00:00:35,850
work with them to take their courses and

00:00:33,899 --> 00:00:37,380
produce courses with them and put them

00:00:35,850 --> 00:00:40,050
online for anyone in the world to take

00:00:37,380 --> 00:00:41,219
we've been around for almost five years

00:00:40,050 --> 00:00:43,920
now

00:00:41,219 --> 00:00:46,170
we've had thousands of courses we have I

00:00:43,920 --> 00:00:47,969
think 25 million users and millions of

00:00:46,170 --> 00:00:50,280
course completions so we're really

00:00:47,969 --> 00:00:52,739
trying to revolutionize online education

00:00:50,280 --> 00:00:54,149
and as we do all that we definitely

00:00:52,739 --> 00:00:56,879
there's a lot of different products that

00:00:54,149 --> 00:00:58,260
we need to build all the time so of

00:00:56,879 --> 00:00:59,760
course we need to build a whole bunch of

00:00:58,260 --> 00:01:01,590
api's to be able to support all these

00:00:59,760 --> 00:01:03,809
products so I'll give you I guess a

00:01:01,590 --> 00:01:06,210
little bit of context on the rest API is

00:01:03,809 --> 00:01:07,740
at Coursera and kind of our evolution

00:01:06,210 --> 00:01:11,610
over the past five years that we've been

00:01:07,740 --> 00:01:13,260
building Coursera so right now of course

00:01:11,610 --> 00:01:15,210
era we have five hundred eighty-four

00:01:13,260 --> 00:01:17,100
different resources we consider a

00:01:15,210 --> 00:01:18,659
resource kind of it's one-to-one with a

00:01:17,100 --> 00:01:21,930
model so you can imagine like a course

00:01:18,659 --> 00:01:24,119
resource and instructor resource a quiz

00:01:21,930 --> 00:01:25,470
resource of course grade resource all of

00:01:24,119 --> 00:01:28,619
these different kind of entities that we

00:01:25,470 --> 00:01:31,770
have we call resources and then on those

00:01:28,619 --> 00:01:33,270
we have 1350 to different end points so

00:01:31,770 --> 00:01:34,710
you can imagine for a course you might

00:01:33,270 --> 00:01:37,470
have different ways to actually get that

00:01:34,710 --> 00:01:40,020
data you have lookup by an ID of look up

00:01:37,470 --> 00:01:41,640
by slug maybe we could get like all of

00:01:40,020 --> 00:01:43,229
your enrollments and/or all of your

00:01:41,640 --> 00:01:44,610
courses that you're enrolled in so we

00:01:43,229 --> 00:01:46,020
have different ways of accessing these

00:01:44,610 --> 00:01:48,869
different resources through these

00:01:46,020 --> 00:01:51,420
endpoints and all of these are split up

00:01:48,869 --> 00:01:52,950
on 70 different services we don't really

00:01:51,420 --> 00:01:55,140
like to use the term micro services

00:01:52,950 --> 00:01:58,979
because it has kind of a bad rep but we

00:01:55,140 --> 00:02:00,329
call them like medium-size services so

00:01:58,979 --> 00:02:02,219
it's split up and we try to keep

00:02:00,329 --> 00:02:03,600
everything pretty siloed and services

00:02:02,219 --> 00:02:05,880
and things that make sense group

00:02:03,600 --> 00:02:07,829
together will go together like one team

00:02:05,880 --> 00:02:10,020
should own a service completely we don't

00:02:07,829 --> 00:02:11,190
try to have things split up on two

00:02:10,020 --> 00:02:13,440
different teams or in the same service

00:02:11,190 --> 00:02:14,490
so try to just keep it logically

00:02:13,440 --> 00:02:16,960
separate

00:02:14,490 --> 00:02:20,050
we actually do all this with just about

00:02:16,960 --> 00:02:21,730
30 back-end developers so there's a lot

00:02:20,050 --> 00:02:23,770
of services to maintain a lot of api's

00:02:21,730 --> 00:02:25,360
to right and not too many developers

00:02:23,770 --> 00:02:28,450
actually maintain all this and keep

00:02:25,360 --> 00:02:30,340
building these new api's so over the

00:02:28,450 --> 00:02:32,020
years we've been building a lot of api's

00:02:30,340 --> 00:02:34,420
and we realized that we needed to come

00:02:32,020 --> 00:02:35,680
up with some better way to actually be

00:02:34,420 --> 00:02:37,120
able to write all these API s and

00:02:35,680 --> 00:02:40,210
something that would let us do it faster

00:02:37,120 --> 00:02:41,980
more consistently and just easier so we

00:02:40,210 --> 00:02:44,440
actually built a framework called nap

00:02:41,980 --> 00:02:46,780
time it's a rest framework it's terrible

00:02:44,440 --> 00:02:48,100
name I'm really sorry about that not my

00:02:46,780 --> 00:02:50,350
fault

00:02:48,100 --> 00:02:53,140
so nap time is basically a library that

00:02:50,350 --> 00:02:54,900
we made that lets us kind of abstract a

00:02:53,140 --> 00:02:57,040
lot of the basics around building an API

00:02:54,900 --> 00:02:58,240
into common libraries so we don't have

00:02:57,040 --> 00:03:00,190
to think about so many things

00:02:58,240 --> 00:03:01,630
every time we're building an API it just

00:03:00,190 --> 00:03:05,290
makes it a lot easier to build these new

00:03:01,630 --> 00:03:07,210
api's so some benefits that gives us all

00:03:05,290 --> 00:03:09,640
of our API s are very consistent with

00:03:07,210 --> 00:03:11,470
nap time all the requests are in the

00:03:09,640 --> 00:03:13,600
same format the responses are all in the

00:03:11,470 --> 00:03:15,580
same format paginations handled and

00:03:13,600 --> 00:03:16,690
consistent way these are things that we

00:03:15,580 --> 00:03:18,850
don't have to think about every time

00:03:16,690 --> 00:03:20,770
we're building a new API I'd like to say

00:03:18,850 --> 00:03:24,040
that once you know one nap time API you

00:03:20,770 --> 00:03:25,630
know all of them we also it's a much

00:03:24,040 --> 00:03:27,400
lower cost when you're building these

00:03:25,630 --> 00:03:28,720
new API s because you don't have to

00:03:27,400 --> 00:03:30,460
think about all these things every time

00:03:28,720 --> 00:03:32,080
you're building an API you don't have to

00:03:30,460 --> 00:03:33,160
come up with your pagination model you

00:03:32,080 --> 00:03:34,390
don't have to think about how you're

00:03:33,160 --> 00:03:36,730
gonna do aught entick ation

00:03:34,390 --> 00:03:38,590
authorization and because we actually

00:03:36,730 --> 00:03:39,970
have all this boilerplate objected away

00:03:38,590 --> 00:03:41,860
you don't actually have to write that

00:03:39,970 --> 00:03:44,590
code you just have to worry about the

00:03:41,860 --> 00:03:46,060
core functionality of our API how to get

00:03:44,590 --> 00:03:48,060
that data and return it you don't have

00:03:46,060 --> 00:03:50,710
to worry about all those other things

00:03:48,060 --> 00:03:52,960
and because we're using Scala for all of

00:03:50,710 --> 00:03:54,460
our API s we get this type safety and

00:03:52,960 --> 00:03:56,800
get this a lot of correctness checking

00:03:54,460 --> 00:03:59,080
built in at compile time so we can never

00:03:56,800 --> 00:04:01,780
have an API that looks like a get but

00:03:59,080 --> 00:04:04,390
returns multiple elements we can ever

00:04:01,780 --> 00:04:06,280
like have an API under the courses API

00:04:04,390 --> 00:04:07,540
that returns an instructor so we check

00:04:06,280 --> 00:04:09,310
that everything is actually in the

00:04:07,540 --> 00:04:11,320
correct format and works the correct way

00:04:09,310 --> 00:04:15,670
at compile time and just make sure that

00:04:11,320 --> 00:04:17,530
all of our API s are very consistent but

00:04:15,670 --> 00:04:19,299
I mean we build this thing called nap

00:04:17,530 --> 00:04:21,310
time it worked out pretty well for us

00:04:19,299 --> 00:04:24,340
but there's just a lot of things that it

00:04:21,310 --> 00:04:26,290
can't even handle and mostly rest fault

00:04:24,340 --> 00:04:27,400
some of it's our fault but there's just

00:04:26,290 --> 00:04:30,220
a lot that

00:04:27,400 --> 00:04:33,550
it wasn't doing for us so one big thing

00:04:30,220 --> 00:04:35,410
is just loading related data so for

00:04:33,550 --> 00:04:37,120
example if we had like a course page you

00:04:35,410 --> 00:04:38,169
want to get the course information we

00:04:37,120 --> 00:04:39,130
also want to get the instructor

00:04:38,169 --> 00:04:41,169
information you want to get the

00:04:39,130 --> 00:04:43,389
university information you could either

00:04:41,169 --> 00:04:44,860
make an API call get the courses that

00:04:43,389 --> 00:04:46,539
comes back they can go fetch the

00:04:44,860 --> 00:04:48,580
instructors then Ghat comes back then

00:04:46,539 --> 00:04:51,310
you go fetch the universities and that's

00:04:48,580 --> 00:04:52,389
just really slow for the users or you

00:04:51,310 --> 00:04:55,150
could try to like come up with some

00:04:52,389 --> 00:04:57,490
weird syntax we tried this where you

00:04:55,150 --> 00:04:58,870
could like have a URL and you say I want

00:04:57,490 --> 00:05:00,820
to get the courses and include the

00:04:58,870 --> 00:05:03,070
instructors on that include universities

00:05:00,820 --> 00:05:04,780
on the instructors and so we ended up

00:05:03,070 --> 00:05:06,870
like super long URLs that were actually

00:05:04,780 --> 00:05:08,380
longer than the HTTP limit and

00:05:06,870 --> 00:05:10,510
developers were trying to actually

00:05:08,380 --> 00:05:11,940
construct these URLs by hand we had to

00:05:10,510 --> 00:05:13,990
write libraries around that and

00:05:11,940 --> 00:05:17,560
eventually just took a step back we were

00:05:13,990 --> 00:05:20,620
like that's ridiculous another problem

00:05:17,560 --> 00:05:22,300
is API discovery is really hard so you

00:05:20,620 --> 00:05:23,440
build an API you think it's really cool

00:05:22,300 --> 00:05:25,120
you give it to the developer that's

00:05:23,440 --> 00:05:26,800
building product but three months later

00:05:25,120 --> 00:05:28,930
if another developer on another teams

00:05:26,800 --> 00:05:30,310
needs to use the same API if they can't

00:05:28,930 --> 00:05:31,599
find it they won't know that it's there

00:05:30,310 --> 00:05:33,849
and they'll go ask another back-end

00:05:31,599 --> 00:05:35,169
developer to build that API so we've had

00:05:33,849 --> 00:05:37,479
a couple cases where we have like

00:05:35,169 --> 00:05:39,190
multiple API serve an exact same data

00:05:37,479 --> 00:05:41,289
just with different names because the

00:05:39,190 --> 00:05:42,760
developer didn't know about it we also

00:05:41,289 --> 00:05:44,409
have so many times when a client

00:05:42,760 --> 00:05:46,389
developer needs to like get profile

00:05:44,409 --> 00:05:48,159
information so they'll go to slack the

00:05:46,389 --> 00:05:49,930
last entire Channel how do I get profile

00:05:48,159 --> 00:05:51,520
information everyone jumps in with

00:05:49,930 --> 00:05:53,949
different answers and there was no like

00:05:51,520 --> 00:05:57,310
easy way to figure out what API to use

00:05:53,949 --> 00:05:58,990
for all your different things also

00:05:57,310 --> 00:06:00,909
communities are just super important

00:05:58,990 --> 00:06:02,470
when you're trying to build a librarian

00:06:00,909 --> 00:06:04,510
house it's one thing to actually build

00:06:02,470 --> 00:06:06,880
that library but maintaining it writing

00:06:04,510 --> 00:06:08,979
the documentation doing support all that

00:06:06,880 --> 00:06:11,050
is super expensive and it really adds up

00:06:08,979 --> 00:06:13,090
another thing we like to refer to as a

00:06:11,050 --> 00:06:15,010
Google ability when you're onboarding

00:06:13,090 --> 00:06:16,960
new people and like we've had developers

00:06:15,010 --> 00:06:18,130
come in and they're using nap time and

00:06:16,960 --> 00:06:19,270
they're like oh this is cool but I don't

00:06:18,130 --> 00:06:21,010
know how to do something so they'll

00:06:19,270 --> 00:06:22,750
Google like naptime tricks or like how

00:06:21,010 --> 00:06:24,550
to use nap time they'll get information

00:06:22,750 --> 00:06:25,690
on how to take a good power nap but

00:06:24,550 --> 00:06:27,220
they're not going to get information on

00:06:25,690 --> 00:06:28,949
how to actually use our library because

00:06:27,220 --> 00:06:31,449
no one else in the world knows about it

00:06:28,949 --> 00:06:33,190
so we kind of looked at all this and

00:06:31,449 --> 00:06:34,360
these problems were kind of coming up

00:06:33,190 --> 00:06:36,700
over the years and we realized that

00:06:34,360 --> 00:06:38,710
there needed to be some other option out

00:06:36,700 --> 00:06:40,780
there and I guess you could probably

00:06:38,710 --> 00:06:43,270
guess because I'm here you're all here

00:06:40,780 --> 00:06:46,420
QL so I'll talk a little bit I guess

00:06:43,270 --> 00:06:49,419
about how we've made the journey to

00:06:46,420 --> 00:06:52,270
graph QL so I guess taking a step back

00:06:49,419 --> 00:06:54,040
why we chose graph QL on top of all the

00:06:52,270 --> 00:06:56,139
obvious things I'm really those three

00:06:54,040 --> 00:06:59,200
problems that I mentioned it really

00:06:56,139 --> 00:07:02,139
solves all of those for us so I mean

00:06:59,200 --> 00:07:03,310
with graph graphical API discovery is so

00:07:02,139 --> 00:07:04,780
much easier if you want to get

00:07:03,310 --> 00:07:06,340
information about a course you're either

00:07:04,780 --> 00:07:08,320
search on the right hand side where it

00:07:06,340 --> 00:07:09,520
loads all of your documentation or just

00:07:08,320 --> 00:07:11,139
type course and you're gonna get the

00:07:09,520 --> 00:07:13,720
autocomplete of all the different course

00:07:11,139 --> 00:07:15,460
API is available so developers don't

00:07:13,720 --> 00:07:16,720
have to like figure out what our API is

00:07:15,460 --> 00:07:18,130
are available search for the code base

00:07:16,720 --> 00:07:21,130
or anything they just go to graphical

00:07:18,130 --> 00:07:23,200
and immediately find that out also

00:07:21,130 --> 00:07:25,120
nested data and related data it's much

00:07:23,200 --> 00:07:27,220
more intuitive you don't have weird URL

00:07:25,120 --> 00:07:29,860
syntax or anything it it looks like what

00:07:27,220 --> 00:07:31,270
you want it to look like and the fact

00:07:29,860 --> 00:07:34,000
that there's a standard and a spec

00:07:31,270 --> 00:07:35,470
behind is huge I mean everyone kind of

00:07:34,000 --> 00:07:36,850
had their own interpretation of what

00:07:35,470 --> 00:07:39,130
they wanted to REST API is to look like

00:07:36,850 --> 00:07:41,410
but no one was actually correct because

00:07:39,130 --> 00:07:43,810
there is no correct thing having some

00:07:41,410 --> 00:07:45,970
concrete thing that says this is graph

00:07:43,810 --> 00:07:47,979
QL this is how it should be these are

00:07:45,970 --> 00:07:49,720
the this is a structure behind it just

00:07:47,979 --> 00:07:50,770
made it so much easier for us because we

00:07:49,720 --> 00:07:54,280
didn't have to come up with all of that

00:07:50,770 --> 00:07:55,660
on our own so look at all this and we're

00:07:54,280 --> 00:07:57,190
like okay graph kill is definitely

00:07:55,660 --> 00:08:00,060
something great we want to move to it

00:07:57,190 --> 00:08:02,050
but how do we actually get to graph QL

00:08:00,060 --> 00:08:04,090
it's not actually that easy you can't

00:08:02,050 --> 00:08:05,500
just do like npm install' graph QL and

00:08:04,090 --> 00:08:08,650
suddenly all grapey eyes work with

00:08:05,500 --> 00:08:11,560
graphic UL so you have to kind of adapt

00:08:08,650 --> 00:08:12,640
it to your api's in a specific way most

00:08:11,560 --> 00:08:14,710
people when they get started they

00:08:12,640 --> 00:08:16,630
probably install like a Palo server or

00:08:14,710 --> 00:08:19,030
some other graphical server and they'll

00:08:16,630 --> 00:08:22,090
then define resolvers that say okay I

00:08:19,030 --> 00:08:23,979
have a course object in graph QL and I

00:08:22,090 --> 00:08:26,320
need to get that data from my existing

00:08:23,979 --> 00:08:27,970
course API or I can get it from the

00:08:26,320 --> 00:08:29,830
course database so I can do some

00:08:27,970 --> 00:08:32,589
business logic there to get the course

00:08:29,830 --> 00:08:34,630
but we have these like 500 600 different

00:08:32,589 --> 00:08:37,150
API is already there and we didn't want

00:08:34,630 --> 00:08:39,900
to go in and write that all for each one

00:08:37,150 --> 00:08:42,280
by hand on how to fetch all that data

00:08:39,900 --> 00:08:44,440
mostly because developers are lazy they

00:08:42,280 --> 00:08:46,540
really don't want to go and just rewrite

00:08:44,440 --> 00:08:48,730
this thing we made that time easy for

00:08:46,540 --> 00:08:50,020
them cuz they didn't want to handle all

00:08:48,730 --> 00:08:51,250
that they want everything solved for

00:08:50,020 --> 00:08:52,959
them so bigger write the actual business

00:08:51,250 --> 00:08:54,310
logic and the stuff that matters they

00:08:52,959 --> 00:08:55,720
don't want to go write some more

00:08:54,310 --> 00:08:57,190
extra things just to get their API

00:08:55,720 --> 00:08:57,810
working when it was already working and

00:08:57,190 --> 00:09:00,130
rest

00:08:57,810 --> 00:09:02,290
it also requires keeping different

00:09:00,130 --> 00:09:04,840
services in sync so if we built this one

00:09:02,290 --> 00:09:06,760
like graph QL layer and we add a new API

00:09:04,840 --> 00:09:08,529
in there we have to then every time we

00:09:06,760 --> 00:09:09,970
update one of our API is in a service we

00:09:08,529 --> 00:09:12,460
have to go update this graph QL layer

00:09:09,970 --> 00:09:14,260
also and we like to really keep our

00:09:12,460 --> 00:09:16,420
services very self-contained so

00:09:14,260 --> 00:09:19,779
developers want to deploy it forward

00:09:16,420 --> 00:09:20,680
rollback shift 50/50 traffic there are a

00:09:19,779 --> 00:09:22,660
whole bunch of different things they

00:09:20,680 --> 00:09:24,190
could do inside their service but if we

00:09:22,660 --> 00:09:27,910
had to then keep two services in sync

00:09:24,190 --> 00:09:30,089
that becomes much more difficult Leslie

00:09:27,910 --> 00:09:32,560
schema design could be very inconsistent

00:09:30,089 --> 00:09:33,940
so if we told developers they should go

00:09:32,560 --> 00:09:35,890
write their own schema on how they want

00:09:33,940 --> 00:09:37,450
their data to be access you could have

00:09:35,890 --> 00:09:39,190
two different teams with two different

00:09:37,450 --> 00:09:41,920
interpretations on what their ideal

00:09:39,190 --> 00:09:43,660
schema looks like and we also we saw

00:09:41,920 --> 00:09:45,640
there are so many benefits with nap time

00:09:43,660 --> 00:09:47,140
and we kind of figured that out once and

00:09:45,640 --> 00:09:48,550
everything was consistent and we didn't

00:09:47,140 --> 00:09:51,460
want to get into that graphic you all

00:09:48,550 --> 00:09:53,020
again so we kind of did what any good

00:09:51,460 --> 00:09:54,100
developer does when they look at the

00:09:53,020 --> 00:09:55,450
problem and they realize that they're

00:09:54,100 --> 00:09:57,490
doing the same thing over and over and

00:09:55,450 --> 00:09:57,990
there are some good option we automated

00:09:57,490 --> 00:10:00,580
it

00:09:57,990 --> 00:10:02,410
so with nap time we get actually three

00:10:00,580 --> 00:10:05,130
very important things that lets us kind

00:10:02,410 --> 00:10:07,660
of automate this transition to graph QL

00:10:05,130 --> 00:10:10,780
the first one is to get a schema that

00:10:07,660 --> 00:10:12,520
has all the available endpoints so we

00:10:10,780 --> 00:10:14,680
have like the courses be one resource

00:10:12,520 --> 00:10:16,450
instructors be one we actually because

00:10:14,680 --> 00:10:18,610
we're using Scala and everything is at

00:10:16,450 --> 00:10:21,040
compile time we can generate kind of

00:10:18,610 --> 00:10:22,570
like a JSON file that says this courses

00:10:21,040 --> 00:10:25,720
view one resource is available on the

00:10:22,570 --> 00:10:28,480
catalog service and tells you basically

00:10:25,720 --> 00:10:30,490
where everything is it also tells us a

00:10:28,480 --> 00:10:33,010
lot of the input parameters so of course

00:10:30,490 --> 00:10:34,780
resource will have a by slug finder that

00:10:33,010 --> 00:10:36,730
takes in a slug parameter that's a

00:10:34,780 --> 00:10:37,920
string so we get all that detailed type

00:10:36,730 --> 00:10:40,360
information

00:10:37,920 --> 00:10:42,820
lastly we get schema definitions for all

00:10:40,360 --> 00:10:45,220
the response bodies so everything that

00:10:42,820 --> 00:10:48,040
comes back from that API we have a

00:10:45,220 --> 00:10:50,380
schema that defines a type we use our

00:10:48,040 --> 00:10:52,750
home it's based off LinkedIn stress Lee

00:10:50,380 --> 00:10:54,790
it's called courier but actually Maps

00:10:52,750 --> 00:10:57,190
pretty much one-to-one with graph QL so

00:10:54,790 --> 00:11:00,040
it has primitives in it it has record

00:10:57,190 --> 00:11:01,209
types unions enums all the things that

00:11:00,040 --> 00:11:03,250
you'll find the graphical schema we

00:11:01,209 --> 00:11:06,100
actually had that already for all of our

00:11:03,250 --> 00:11:08,019
response bodies so you took all that

00:11:06,100 --> 00:11:10,600
data and we kind of just

00:11:08,019 --> 00:11:12,660
adapted it to graph QL so built it to

00:11:10,600 --> 00:11:15,069
service that does two different things

00:11:12,660 --> 00:11:16,959
it goes in every five minutes it hits

00:11:15,069 --> 00:11:18,489
all of our services against all the

00:11:16,959 --> 00:11:20,829
schema information and we build a

00:11:18,489 --> 00:11:22,420
unified graphical schema that takes all

00:11:20,829 --> 00:11:23,649
the information we know about the

00:11:22,420 --> 00:11:25,420
different end points available the

00:11:23,649 --> 00:11:27,339
different resources and the different

00:11:25,420 --> 00:11:28,779
requests and response types and we build

00:11:27,339 --> 00:11:32,860
this schema that basically represents

00:11:28,779 --> 00:11:35,019
the state of all of Coursera's api's and

00:11:32,860 --> 00:11:36,670
then we built a generic resolver that

00:11:35,019 --> 00:11:39,040
given anything that comes in from the

00:11:36,670 --> 00:11:40,509
schema we know how to go resolve it

00:11:39,040 --> 00:11:42,429
because all of our API is look the same

00:11:40,509 --> 00:11:44,889
they work in the same way we just built

00:11:42,429 --> 00:11:47,920
this single resolver that could take any

00:11:44,889 --> 00:11:51,519
input and go and hit our downstream

00:11:47,920 --> 00:11:53,679
api's and get the data and I'll just

00:11:51,519 --> 00:11:56,170
also mention kind of as a side note they

00:11:53,679 --> 00:11:57,579
built all this on sangria library so if

00:11:56,170 --> 00:11:59,529
you're using Scala and you want to do

00:11:57,579 --> 00:12:00,939
graphical stuff sangria is definitely

00:11:59,529 --> 00:12:02,889
the way to go I don't know if there are

00:12:00,939 --> 00:12:04,329
other options out there but you want to

00:12:02,889 --> 00:12:06,850
use sangria it does pretty much

00:12:04,329 --> 00:12:08,980
everything you need to do and more and

00:12:06,850 --> 00:12:10,389
it's just really easy to use and if

00:12:08,980 --> 00:12:11,920
you're not using Scala and you want to

00:12:10,389 --> 00:12:15,970
if there's a Coursera course for that go

00:12:11,920 --> 00:12:17,889
check it out so I'll talk a little bit

00:12:15,970 --> 00:12:19,540
about our schema design this was I guess

00:12:17,889 --> 00:12:22,600
somewhat controversial when we were

00:12:19,540 --> 00:12:23,980
first coming up with it but it's kind of

00:12:22,600 --> 00:12:26,049
worked out pretty well for us so we have

00:12:23,980 --> 00:12:28,059
three different kind of main things I'll

00:12:26,049 --> 00:12:30,459
point out the first one is guess the

00:12:28,059 --> 00:12:32,350
response body type so all of our REST

00:12:30,459 --> 00:12:34,420
API is were in the format of there's a

00:12:32,350 --> 00:12:36,819
model name and then a V and then version

00:12:34,420 --> 00:12:39,040
name so we kind of adapted that to a

00:12:36,819 --> 00:12:41,709
little more like graph QL so we'll have

00:12:39,040 --> 00:12:42,879
a courses v1 if we need to do some sort

00:12:41,709 --> 00:12:45,509
of like very backwards incompatible

00:12:42,879 --> 00:12:49,959
thing we can make of courses v2 in there

00:12:45,509 --> 00:12:52,419
sometimes it happens and then we have

00:12:49,959 --> 00:12:53,980
this courses v1 resource so this is

00:12:52,419 --> 00:12:56,049
different than what most of you would

00:12:53,980 --> 00:12:57,850
probably expect where it's actually this

00:12:56,049 --> 00:12:59,199
is embedded in the root and it's

00:12:57,850 --> 00:13:00,999
basically an object that has a

00:12:59,199 --> 00:13:03,009
collection of different ways to look it

00:13:00,999 --> 00:13:04,569
up so you don't just go directly from

00:13:03,009 --> 00:13:06,879
the root to get your course you would go

00:13:04,569 --> 00:13:09,129
through this courses v1 resource and has

00:13:06,879 --> 00:13:10,779
these different handlers on the course

00:13:09,129 --> 00:13:13,629
endpoint where you could get the course

00:13:10,779 --> 00:13:15,429
information and then the connections

00:13:13,629 --> 00:13:17,200
pretty basic it has elements and has

00:13:15,429 --> 00:13:20,149
pagination in there

00:13:17,200 --> 00:13:21,589
so as I mentioned there are these two

00:13:20,149 --> 00:13:24,110
options that we were looking at and

00:13:21,589 --> 00:13:25,550
developing our schema first one is where

00:13:24,110 --> 00:13:27,589
we have everything mess it in this I

00:13:25,550 --> 00:13:29,029
courses V one resource and the other

00:13:27,589 --> 00:13:31,670
option is to take all these different

00:13:29,029 --> 00:13:34,459
handlers the 1,300 of them and put them

00:13:31,670 --> 00:13:36,620
on the roof and I mean both options had

00:13:34,459 --> 00:13:39,200
their pros and cons some of the pros for

00:13:36,620 --> 00:13:40,640
the one in the bottom right is it looks

00:13:39,200 --> 00:13:42,050
a little bit more like graph QL you

00:13:40,640 --> 00:13:44,540
don't have to jump through this extra

00:13:42,050 --> 00:13:46,070
layer to get to your data and on your

00:13:44,540 --> 00:13:48,950
route you can just do anything you want

00:13:46,070 --> 00:13:50,630
it's much easier to kind of just jump

00:13:48,950 --> 00:13:53,390
directly to get the data that you want

00:13:50,630 --> 00:13:55,370
but some of the problems with that is we

00:13:53,390 --> 00:13:57,470
didn't have any way to kind of generate

00:13:55,370 --> 00:14:00,560
these names automatically so it required

00:13:57,470 --> 00:14:02,570
developers to go in and define like the

00:14:00,560 --> 00:14:04,040
main route name for all of these

00:14:02,570 --> 00:14:06,529
handlers and we don't want to give them

00:14:04,040 --> 00:14:08,000
extra work another thing is a lot of

00:14:06,529 --> 00:14:09,860
these names it might be more difficult

00:14:08,000 --> 00:14:11,209
when you're trying to figure out how to

00:14:09,860 --> 00:14:13,579
get the data if you're going through

00:14:11,209 --> 00:14:15,290
1,300 options if there's a lot more

00:14:13,579 --> 00:14:17,000
there so if we named everything that was

00:14:15,290 --> 00:14:19,010
to get all starting with the part all

00:14:17,000 --> 00:14:20,540
and you start typing all in graphical

00:14:19,010 --> 00:14:22,850
you'd get a list of like 500 different

00:14:20,540 --> 00:14:24,740
options in there that I was a little

00:14:22,850 --> 00:14:27,320
scared for us and we wanted to make it a

00:14:24,740 --> 00:14:28,670
little bit easier for developers so it

00:14:27,320 --> 00:14:31,459
the way of nesting everything in this

00:14:28,670 --> 00:14:33,140
course is v1 resource object if you know

00:14:31,459 --> 00:14:34,490
you need to get a course and most of the

00:14:33,140 --> 00:14:36,649
time developers right now are still

00:14:34,490 --> 00:14:38,899
thinking in terms of I know this REST

00:14:36,649 --> 00:14:40,910
API how do I get in graph QL so they're

00:14:38,899 --> 00:14:42,170
typing courses v1 they see that there

00:14:40,910 --> 00:14:44,839
and then they see all the different ways

00:14:42,170 --> 00:14:46,459
to get the course so it makes it much

00:14:44,839 --> 00:14:47,990
easier for them as they're kind of going

00:14:46,459 --> 00:14:50,660
through this and it makes it much easier

00:14:47,990 --> 00:14:52,459
for us as back-end developers that we

00:14:50,660 --> 00:14:55,520
don't have to add this extra work in to

00:14:52,459 --> 00:14:57,140
get everything working with graph QL so

00:14:55,520 --> 00:14:59,180
this was pretty cool we kind of built

00:14:57,140 --> 00:15:02,510
the service and ran it and also we had a

00:14:59,180 --> 00:15:04,790
giant schema I think was like 30,000

00:15:02,510 --> 00:15:06,140
lines so it was very long I had

00:15:04,790 --> 00:15:07,279
basically all of our API s and

00:15:06,140 --> 00:15:09,410
everything in there and that was really

00:15:07,279 --> 00:15:11,390
cool we went to graphical and everything

00:15:09,410 --> 00:15:13,160
worked it was awesome but that was only

00:15:11,390 --> 00:15:14,750
really half of it I mean one of the main

00:15:13,160 --> 00:15:16,820
benefits that I mentioned earlier with

00:15:14,750 --> 00:15:19,370
graph QL said unless you link everything

00:15:16,820 --> 00:15:21,410
together in a really easy way and by

00:15:19,370 --> 00:15:23,089
just converting our basic rest api's to

00:15:21,410 --> 00:15:25,579
graph QL we didn't actually get that yet

00:15:23,089 --> 00:15:27,079
so we really wanted some sort of query

00:15:25,579 --> 00:15:29,089
that looked like this where we can get

00:15:27,079 --> 00:15:29,710
the course information then we get the

00:15:29,089 --> 00:15:31,390
instructor

00:15:29,710 --> 00:15:33,070
we could get the maybe the University on

00:15:31,390 --> 00:15:34,840
the instructor you get your enrollments

00:15:33,070 --> 00:15:38,500
in there basically everything you need

00:15:34,840 --> 00:15:40,450
all in a single query so some of the

00:15:38,500 --> 00:15:41,830
problems be your kind of thing about

00:15:40,450 --> 00:15:43,660
this problem and we didn't really know

00:15:41,830 --> 00:15:46,330
exactly how to solve it

00:15:43,660 --> 00:15:47,980
one big thing that is important for us

00:15:46,330 --> 00:15:50,140
is we treat all of our back-end API is

00:15:47,980 --> 00:15:51,400
like a black box so if you're doing

00:15:50,140 --> 00:15:52,720
something where you have a relational

00:15:51,400 --> 00:15:54,460
database and you want to get the data

00:15:52,720 --> 00:15:56,440
out of there that's really easy if you

00:15:54,460 --> 00:15:57,910
want to get courses and instructors you

00:15:56,440 --> 00:15:59,740
select your courses you join on

00:15:57,910 --> 00:16:01,450
instructors on a certain field then you

00:15:59,740 --> 00:16:04,210
get everything there and one statement

00:16:01,450 --> 00:16:06,370
there's no way to join across API as

00:16:04,210 --> 00:16:09,520
easily you have to go and fetch the data

00:16:06,370 --> 00:16:11,530
individually another problem is that we

00:16:09,520 --> 00:16:12,940
had no control over our back-end systems

00:16:11,530 --> 00:16:14,800
because we have all these different

00:16:12,940 --> 00:16:16,750
services we like to give teams as much

00:16:14,800 --> 00:16:18,550
independence as possible we couldn't

00:16:16,750 --> 00:16:20,350
make any assumptions on how the backend

00:16:18,550 --> 00:16:21,250
services function we couldn't assume

00:16:20,350 --> 00:16:23,080
that they were using relational

00:16:21,250 --> 00:16:25,420
databases and they could take Hin sound

00:16:23,080 --> 00:16:27,730
like how to join things it was just the

00:16:25,420 --> 00:16:29,320
API that they gave us was we get this

00:16:27,730 --> 00:16:31,630
resource we have the ways to get it and

00:16:29,320 --> 00:16:32,950
that's all that we know so I mean most

00:16:31,630 --> 00:16:34,750
of our data is actually stored in

00:16:32,950 --> 00:16:36,820
Cassandra which is no sequel database

00:16:34,750 --> 00:16:38,230
and in Cassandra if you want to be able

00:16:36,820 --> 00:16:39,970
to look up buy something you have to

00:16:38,230 --> 00:16:42,160
explicitly make an index before you

00:16:39,970 --> 00:16:43,570
store your data you can't just like

00:16:42,160 --> 00:16:45,520
create a course an arbitrary to look up

00:16:43,570 --> 00:16:47,380
by the course title unless you know that

00:16:45,520 --> 00:16:49,510
you want to look it up beforehand so

00:16:47,380 --> 00:16:50,980
there is no API available to look up by

00:16:49,510 --> 00:16:54,940
title there was no way that we could

00:16:50,980 --> 00:16:56,560
actually get that data we also really

00:16:54,940 --> 00:16:58,690
want to keep the services as independent

00:16:56,560 --> 00:17:00,310
as possible we didn't ever want to have

00:16:58,690 --> 00:17:02,080
say you want to go from courses to

00:17:00,310 --> 00:17:03,340
instructors we didn't want the course

00:17:02,080 --> 00:17:05,770
resources have to know about the

00:17:03,340 --> 00:17:08,320
instructor if it didn't already we don't

00:17:05,770 --> 00:17:09,730
want the resource have to then go make

00:17:08,320 --> 00:17:11,050
an API call get the instructor

00:17:09,730 --> 00:17:13,030
information only included in the

00:17:11,050 --> 00:17:16,690
response we really want everything to be

00:17:13,030 --> 00:17:17,830
as independent as siloed as possible so

00:17:16,690 --> 00:17:19,030
as we were kind of going through this

00:17:17,830 --> 00:17:20,890
and thinking about the different

00:17:19,030 --> 00:17:22,030
approaches we could take realize that

00:17:20,890 --> 00:17:23,260
there were kind of three different

00:17:22,030 --> 00:17:25,390
problems that we were trying to solve

00:17:23,260 --> 00:17:28,480
there were three types of ways that our

00:17:25,390 --> 00:17:30,910
data is related first one we call

00:17:28,480 --> 00:17:33,040
forward relationships these are pretty

00:17:30,910 --> 00:17:35,650
basic it's so you have two models like a

00:17:33,040 --> 00:17:37,150
course and instructor in this case for a

00:17:35,650 --> 00:17:39,460
forward relationship the course would

00:17:37,150 --> 00:17:41,440
know which instructors are in the course

00:17:39,460 --> 00:17:42,100
so you have maybe an instructor IDs

00:17:41,440 --> 00:17:44,470
field

00:17:42,100 --> 00:17:46,090
course so then it's very easy to know

00:17:44,470 --> 00:17:49,780
from the course which instructors are

00:17:46,090 --> 00:17:52,240
part of it the next one we call reverse

00:17:49,780 --> 00:17:54,039
relationship that's when model a doesn't

00:17:52,240 --> 00:17:56,049
know about model B but model B knows

00:17:54,039 --> 00:17:57,970
about model A so if you have a course

00:17:56,049 --> 00:17:59,620
relating to instructors it might not

00:17:57,970 --> 00:18:02,350
know about the instructors in the course

00:17:59,620 --> 00:18:06,130
but an instructor might know about the

00:18:02,350 --> 00:18:07,960
courses that they're part of the last

00:18:06,130 --> 00:18:09,460
one is when there's just no relationship

00:18:07,960 --> 00:18:11,140
whatsoever model a doesn't know about

00:18:09,460 --> 00:18:13,480
model B and model B doesn't know about

00:18:11,140 --> 00:18:14,710
model A so I'll talk a little bit about

00:18:13,480 --> 00:18:18,039
how we kind of solve these three

00:18:14,710 --> 00:18:19,960
different relationships first one for

00:18:18,039 --> 00:18:21,789
relationships these are pretty easy you

00:18:19,960 --> 00:18:23,350
know from the course how to get the

00:18:21,789 --> 00:18:26,049
instructors so you have all the IDS you

00:18:23,350 --> 00:18:28,150
just special that data so what we did is

00:18:26,049 --> 00:18:31,270
we came up with this kind of syntax to

00:18:28,150 --> 00:18:33,370
add on to our courses resource to be

00:18:31,270 --> 00:18:35,230
able to define courses resource has

00:18:33,370 --> 00:18:37,510
related instructors and this is how you

00:18:35,230 --> 00:18:40,659
fetch the information so you'll see we

00:18:37,510 --> 00:18:42,159
made kind of a multi get relation we

00:18:40,659 --> 00:18:43,990
came up with just names for that and it

00:18:42,159 --> 00:18:46,870
specifies that the resource name is

00:18:43,990 --> 00:18:48,490
instructors v1 and specifies how to get

00:18:46,870 --> 00:18:51,010
the instructors for it and include some

00:18:48,490 --> 00:18:53,080
extra arguments so a couple things to

00:18:51,010 --> 00:18:55,299
point out here is we didn't actually

00:18:53,080 --> 00:18:57,400
write any like imperative code on how to

00:18:55,299 --> 00:18:59,289
fetch the instructors we just defined

00:18:57,400 --> 00:19:01,030
the different properties are about the

00:18:59,289 --> 00:19:03,370
relationship and then we're able to use

00:19:01,030 --> 00:19:05,650
that in our graph QL service another

00:19:03,370 --> 00:19:07,480
thing it's a little change but we're

00:19:05,650 --> 00:19:08,919
kind of okay with it is that the IDS

00:19:07,480 --> 00:19:11,020
field you'll see that it's kind of a

00:19:08,919 --> 00:19:12,429
quote and there's dollar sign we do some

00:19:11,020 --> 00:19:14,559
sort of string interpolation in there

00:19:12,429 --> 00:19:16,929
just to give developers a little bit

00:19:14,559 --> 00:19:19,030
more power sometimes you have a Model A

00:19:16,929 --> 00:19:20,500
and to get the ID from model B you have

00:19:19,030 --> 00:19:23,289
to combine two different fields in there

00:19:20,500 --> 00:19:25,990
or you add like a it's a course : and

00:19:23,289 --> 00:19:27,760
the course ID come up with some strange

00:19:25,990 --> 00:19:29,919
IDs and we basically just need to

00:19:27,760 --> 00:19:32,590
compromise some give developers a little

00:19:29,919 --> 00:19:35,559
bit more power on how to go from model a

00:19:32,590 --> 00:19:37,480
tamato b and lastly we have arguments in

00:19:35,559 --> 00:19:39,280
there this is pretty similar to what

00:19:37,480 --> 00:19:41,080
you'd expect with R s if we need to

00:19:39,280 --> 00:19:43,480
specify some extra arguments on how to

00:19:41,080 --> 00:19:45,400
look it up from the together instructors

00:19:43,480 --> 00:19:48,970
for the course then you let developers

00:19:45,400 --> 00:19:51,220
put that in there so next talk about

00:19:48,970 --> 00:19:52,659
reverse relationships these a little

00:19:51,220 --> 00:19:54,669
more complicated but it's not actually

00:19:52,659 --> 00:19:55,870
that bad the way that we do that is we

00:19:54,669 --> 00:19:58,270
give resource be there

00:19:55,870 --> 00:20:00,460
possibility of returning its matches

00:19:58,270 --> 00:20:03,280
based on some information about model a

00:20:00,460 --> 00:20:05,890
so if our instructor knows which courses

00:20:03,280 --> 00:20:07,870
they're in then we could build away on

00:20:05,890 --> 00:20:09,460
instructor resource that given a course

00:20:07,870 --> 00:20:12,130
ID it can return all the matching

00:20:09,460 --> 00:20:13,870
instructors and then in resource a we

00:20:12,130 --> 00:20:16,809
just specify how to look it up based on

00:20:13,870 --> 00:20:19,120
that so in this case we have kind of a

00:20:16,809 --> 00:20:21,550
finder reverse relation that still goes

00:20:19,120 --> 00:20:23,380
to instructors b1 but it looks it up by

00:20:21,550 --> 00:20:25,360
course ID and then we specified the

00:20:23,380 --> 00:20:28,210
course ID is going to be the ID from the

00:20:25,360 --> 00:20:29,950
course so it's still pretty easy for the

00:20:28,210 --> 00:20:31,600
developer if they're adding this in to

00:20:29,950 --> 00:20:33,640
just specify in a couple lines how the

00:20:31,600 --> 00:20:35,260
relationship works and the way that this

00:20:33,640 --> 00:20:36,970
actually works on our backend is every

00:20:35,260 --> 00:20:38,440
time we get a call from the course and

00:20:36,970 --> 00:20:40,860
we want to get related instructors we

00:20:38,440 --> 00:20:42,880
just call this REST API and we get the

00:20:40,860 --> 00:20:46,690
instructors that match that course ID

00:20:42,880 --> 00:20:48,220
and then just add that data in there and

00:20:46,690 --> 00:20:50,140
lastly the resource is no connection

00:20:48,220 --> 00:20:51,510
realize that this is an actually problem

00:20:50,140 --> 00:20:53,320
that we need to solve in graph QL

00:20:51,510 --> 00:20:55,090
basically just need to build a new

00:20:53,320 --> 00:20:56,500
resource to combine the two things so

00:20:55,090 --> 00:20:58,630
you might have a course instructors

00:20:56,500 --> 00:21:01,179
resource that have a bi course and by

00:20:58,630 --> 00:21:03,309
instructor finder on there this isn't

00:21:01,179 --> 00:21:04,660
something that we needed to really think

00:21:03,309 --> 00:21:08,200
about in the graph QL and there are

00:21:04,660 --> 00:21:10,240
other ways around it so as we build all

00:21:08,200 --> 00:21:11,920
of this we kind of adapted it to all of

00:21:10,240 --> 00:21:13,780
our different api's and we learned a lot

00:21:11,920 --> 00:21:15,160
mostly around developer experience what

00:21:13,780 --> 00:21:17,200
would make it the easiest way to

00:21:15,160 --> 00:21:20,620
transition to graph QL without kind of

00:21:17,200 --> 00:21:22,120
disrupting too many things the first

00:21:20,620 --> 00:21:25,870
thing that was super important for us is

00:21:22,120 --> 00:21:27,610
declarative over imperative so graph gal

00:21:25,870 --> 00:21:29,980
is super popular on clients because

00:21:27,610 --> 00:21:31,510
client developers they don't want to

00:21:29,980 --> 00:21:33,520
know or they don't need to know how to

00:21:31,510 --> 00:21:35,470
go fetch the data they specified the

00:21:33,520 --> 00:21:36,880
data that they want and then trust that

00:21:35,470 --> 00:21:39,670
there's some other system that will get

00:21:36,880 --> 00:21:40,960
them that data that's why I mean client

00:21:39,670 --> 00:21:42,130
developers love graphical they write

00:21:40,960 --> 00:21:43,780
that they want the courses they write

00:21:42,130 --> 00:21:45,940
that they want the instructors then it

00:21:43,780 --> 00:21:47,260
all just happens for them we really

00:21:45,940 --> 00:21:48,460
wanted that also for a back-end

00:21:47,260 --> 00:21:50,710
developers when we're defining these

00:21:48,460 --> 00:21:52,990
relationships we didn't want to have

00:21:50,710 --> 00:21:55,000
back in developers right how to go from

00:21:52,990 --> 00:21:56,950
the course API go fetch the instructors

00:21:55,000 --> 00:21:58,600
and how to link everything together we

00:21:56,950 --> 00:22:00,970
just want them to say we have a course

00:21:58,600 --> 00:22:05,080
we have related instructors it's related

00:22:00,970 --> 00:22:06,700
on this field go work your magic next

00:22:05,080 --> 00:22:08,440
things large migrations are really

00:22:06,700 --> 00:22:09,520
expensive and this might seem kind of

00:22:08,440 --> 00:22:11,530
obvious but it's something that

00:22:09,520 --> 00:22:13,630
really tried to think about a lot as we

00:22:11,530 --> 00:22:15,580
were doing things so we're kind of

00:22:13,630 --> 00:22:20,170
working through now on adapting a lot of

00:22:15,580 --> 00:22:21,190
our clients to graph QL and it's not the

00:22:20,170 --> 00:22:23,350
most difficult thing but it's definitely

00:22:21,190 --> 00:22:25,750
taking some time and it's requiring a

00:22:23,350 --> 00:22:27,040
lot of weird stuff here and there and we

00:22:25,750 --> 00:22:29,050
really didn't want to have to pay that

00:22:27,040 --> 00:22:30,610
cost again on the back end if we went to

00:22:29,050 --> 00:22:32,140
our like director of engineering and

00:22:30,610 --> 00:22:33,610
said hey we really want to move to graph

00:22:32,140 --> 00:22:36,220
kill we know it's the right thing to do

00:22:33,610 --> 00:22:37,690
but we're gonna have to go and pay this

00:22:36,220 --> 00:22:39,280
class on the front end migrating Resta

00:22:37,690 --> 00:22:40,960
graph QL we're also gonna have to go

00:22:39,280 --> 00:22:42,820
reread a whole bunch of api's or add

00:22:40,960 --> 00:22:44,860
some new things in here to get all of

00:22:42,820 --> 00:22:46,090
our backend API to work the graph QL you

00:22:44,860 --> 00:22:47,710
probably just look at us and think that

00:22:46,090 --> 00:22:50,200
we were crazy so we need to kind of make

00:22:47,710 --> 00:22:52,030
some compromises and find easier ways to

00:22:50,200 --> 00:22:54,570
do this without making all of our

00:22:52,030 --> 00:22:58,000
developers pay the cost

00:22:54,570 --> 00:22:59,890
lastly we this is kind of has a couple

00:22:58,000 --> 00:23:01,930
names I her like graph kill first I've

00:22:59,890 --> 00:23:03,490
heard wish driven development but a lot

00:23:01,930 --> 00:23:04,900
of things that graph kill you really

00:23:03,490 --> 00:23:07,120
want to know your schema before you

00:23:04,900 --> 00:23:08,320
start building your product this is true

00:23:07,120 --> 00:23:10,120
when you're building a new product you

00:23:08,320 --> 00:23:11,680
wanna maybe define your graphical schema

00:23:10,120 --> 00:23:13,540
before you build your front-end before

00:23:11,680 --> 00:23:16,510
you build your back-end but this is also

00:23:13,540 --> 00:23:17,920
actually applied for us too so initially

00:23:16,510 --> 00:23:20,020
we actually built our assembler

00:23:17,920 --> 00:23:21,760
graphical service without support for

00:23:20,020 --> 00:23:22,900
reverse relations because we looked at

00:23:21,760 --> 00:23:24,760
some of the code and we're like oh we

00:23:22,900 --> 00:23:26,380
probably don't need that well developers

00:23:24,760 --> 00:23:28,510
will find ways around it's fine it's

00:23:26,380 --> 00:23:30,190
gonna be too much work but if we

00:23:28,510 --> 00:23:32,140
actually looked at all of our schemas

00:23:30,190 --> 00:23:33,760
for all the process before we actually

00:23:32,140 --> 00:23:34,990
built this we would have seen that we

00:23:33,760 --> 00:23:36,790
definitely need to build something like

00:23:34,990 --> 00:23:39,160
this there was just no way that we could

00:23:36,790 --> 00:23:40,960
get around it but we did some work on

00:23:39,160 --> 00:23:42,610
like scoping out our schemas before we

00:23:40,960 --> 00:23:44,590
built this but we could have done a lot

00:23:42,610 --> 00:23:46,930
more figuring out all of our ideal

00:23:44,590 --> 00:23:49,870
schemas and then building the graphical

00:23:46,930 --> 00:23:51,370
product from that so those are kind of

00:23:49,870 --> 00:23:53,140
the main lessons that we've learned

00:23:51,370 --> 00:23:55,210
there's still a lot more that we're

00:23:53,140 --> 00:23:57,130
doing with graph QL this is kind of only

00:23:55,210 --> 00:23:58,750
the beginning we have a lot of bugs to

00:23:57,130 --> 00:24:00,850
migrate to graphical a lot of people to

00:23:58,750 --> 00:24:02,980
ramp up to graph kill but really excited

00:24:00,850 --> 00:24:04,930
on all the potential that gives us and

00:24:02,980 --> 00:24:06,370
all the opportunities that we have out

00:24:04,930 --> 00:24:08,650
that we didn't really have for the rest

00:24:06,370 --> 00:24:10,900
before so with that I'll just make a

00:24:08,650 --> 00:24:12,220
very quick plug that we're always hiring

00:24:10,900 --> 00:24:13,720
so if you're interested in working on

00:24:12,220 --> 00:24:15,040
graphical stuff on using building

00:24:13,720 --> 00:24:16,420
products I want to build some

00:24:15,040 --> 00:24:18,340
infrastructure stuff there's some really

00:24:16,420 --> 00:24:21,930
cool things we're doing come talk to me

00:24:18,340 --> 00:24:21,930
later and thanks very much

00:24:22,300 --> 00:24:29,020
[Applause]

00:24:27,010 --> 00:24:32,950
so we have a couple minutes for some

00:24:29,020 --> 00:24:35,070
questions any questions for Brian do we

00:24:32,950 --> 00:24:37,360
do anything for n plus-1 fetching issues

00:24:35,070 --> 00:24:40,120
we've done a little bit so we try to

00:24:37,360 --> 00:24:42,730
optimize whenever possible we have multi

00:24:40,120 --> 00:24:44,169
guests on most of our resources and it's

00:24:42,730 --> 00:24:45,850
we very strongly encourage that

00:24:44,169 --> 00:24:47,289
developers build these multi guests and

00:24:45,850 --> 00:24:50,529
we try to batch everything together from

00:24:47,289 --> 00:24:52,090
our assembler service but some cases

00:24:50,529 --> 00:24:55,059
with like the founder of us relations we

00:24:52,090 --> 00:24:57,640
had I guess one API call for every

00:24:55,059 --> 00:24:59,380
single element in there that is in the

00:24:57,640 --> 00:25:02,010
most optimal we try to expose that when

00:24:59,380 --> 00:25:05,020
possible through like complexity scores

00:25:02,010 --> 00:25:07,590
but we haven't optimized it too much is

00:25:05,020 --> 00:25:07,590
that what you're asking

00:25:13,270 --> 00:25:17,800
question was how does it scale and

00:25:14,980 --> 00:25:19,780
caching so at first no caching most of

00:25:17,800 --> 00:25:22,360
our api's are in cache just because

00:25:19,780 --> 00:25:23,950
there's a lot of other work you have to

00:25:22,360 --> 00:25:25,300
do around caching every time so it makes

00:25:23,950 --> 00:25:27,490
a change in one service you might have

00:25:25,300 --> 00:25:29,170
to go update another service so we try

00:25:27,490 --> 00:25:32,530
to build most of our API is to just be

00:25:29,170 --> 00:25:33,910
fast and not require caching so we've

00:25:32,530 --> 00:25:35,500
kind of taken the same approach for now

00:25:33,910 --> 00:25:36,970
in our graphical service we don't

00:25:35,500 --> 00:25:39,880
actually cache anything and we assume

00:25:36,970 --> 00:25:42,700
that our service kennel if you could

00:25:39,880 --> 00:25:43,960
maybe scale up if we need to if it

00:25:42,700 --> 00:25:45,910
becomes an issue I'm sure we'll come up

00:25:43,960 --> 00:25:51,100
with some approach around it but so far

00:25:45,910 --> 00:25:53,740
we haven't needed to the first question

00:25:51,100 --> 00:25:55,360
was how do we do metrics with the

00:25:53,740 --> 00:25:56,740
sangria stuff we've actually just been

00:25:55,360 --> 00:25:59,440
able to add like different filters and

00:25:56,740 --> 00:26:00,900
plugins in there so as the request comes

00:25:59,440 --> 00:26:03,190
in we're kind of adding in different

00:26:00,900 --> 00:26:04,780
reuse data dog for all of our metrics so

00:26:03,190 --> 00:26:06,250
we basically add different API calls in

00:26:04,780 --> 00:26:09,340
there just to record different timings

00:26:06,250 --> 00:26:12,430
in there so we have like median latency

00:26:09,340 --> 00:26:14,260
p95 p99 keep track of also a number of

00:26:12,430 --> 00:26:15,970
failures number of I think we have

00:26:14,260 --> 00:26:18,160
number of entities in our graphical

00:26:15,970 --> 00:26:20,950
schema just some basic things around

00:26:18,160 --> 00:26:23,310
that the second one was around first

00:26:20,950 --> 00:26:27,160
thing and basically how that's worked

00:26:23,310 --> 00:26:28,630
that's kind of a something that we kind

00:26:27,160 --> 00:26:32,230
of just got when we converted from the

00:26:28,630 --> 00:26:33,580
rest stuff to graph QL so most of the

00:26:32,230 --> 00:26:35,590
time we try to do backwards incompatible

00:26:33,580 --> 00:26:38,350
or backwards compatible things when

00:26:35,590 --> 00:26:40,720
possible but that's not always a case if

00:26:38,350 --> 00:26:42,610
like some fundamental logic chains or we

00:26:40,720 --> 00:26:45,730
need to like create a completely new

00:26:42,610 --> 00:26:47,260
model so this is basically just allowing

00:26:45,730 --> 00:26:49,510
us to adapt these rest endpoints to

00:26:47,260 --> 00:26:50,980
graphical we kind of have to take that

00:26:49,510 --> 00:26:52,750
version in there and just support both

00:26:50,980 --> 00:26:54,160
of them there's we could maybe do

00:26:52,750 --> 00:26:55,870
something around only supporting one in

00:26:54,160 --> 00:26:57,640
choosing which one to support but that

00:26:55,870 --> 00:27:00,180
would remove a lot of that automation

00:26:57,640 --> 00:27:00,180
from there

00:27:00,240 --> 00:27:03,640
cool thank you everyone for the

00:27:02,170 --> 00:27:05,940
questions thanks again Brian for

00:27:03,640 --> 00:27:05,940

YouTube URL: https://www.youtube.com/watch?v=F329W0PR6ds


