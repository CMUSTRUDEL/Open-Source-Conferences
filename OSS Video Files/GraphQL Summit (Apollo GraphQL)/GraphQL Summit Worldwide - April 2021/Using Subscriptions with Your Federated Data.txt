Title: Using Subscriptions with Your Federated Data
Publication date: 2021-04-13
Playlist: GraphQL Summit Worldwide - April 2021
Description: 
	In this talk, we will describe how to add scalable subscriptions to a federated graph using a decoupled service responsible for managing client connections and providing real-time updates to those clients. 

With this approach, the subscriptions service can use any of the types defined in the federated data graph as output types for the Subscription fields in its schema, and it can do so without redefining those types explicitly.

Key takeaways:
* Do you need subscriptions?
* How to build decoupled subscriptions
* How to fulfill subscriptions with help from the gateway
Captions: 
	00:00:00,740 --> 00:00:12,970
[Music]

00:00:16,000 --> 00:00:18,960
okay here we go

00:00:17,199 --> 00:00:21,039
i'd like to begin by thanking everyone

00:00:18,960 --> 00:00:23,519
for joining me for this talk today

00:00:21,039 --> 00:00:24,800
and before we jump into the content i'll

00:00:23,519 --> 00:00:25,439
share just a little bit about my

00:00:24,800 --> 00:00:27,680
background

00:00:25,439 --> 00:00:29,119
again my name is mandy wise and i've

00:00:27,680 --> 00:00:30,960
been doing full stack development with

00:00:29,119 --> 00:00:32,719
graphql for four years now

00:00:30,960 --> 00:00:34,559
and i currently work as a solutions

00:00:32,719 --> 00:00:36,239
architect at apollo

00:00:34,559 --> 00:00:37,680
and in addition to that i've also

00:00:36,239 --> 00:00:39,520
authored and co-authored a couple of

00:00:37,680 --> 00:00:41,760
books about graphql

00:00:39,520 --> 00:00:43,360
and today i am very excited to share

00:00:41,760 --> 00:00:44,160
with you a solution for using

00:00:43,360 --> 00:00:47,200
subscriptions

00:00:44,160 --> 00:00:49,039
alongside a federated data graph

00:00:47,200 --> 00:00:51,039
and to that end we'll begin by

00:00:49,039 --> 00:00:53,360
discussing what apollo federation

00:00:51,039 --> 00:00:56,160
is and what's currently possible in its

00:00:53,360 --> 00:00:57,440
related open source libraries

00:00:56,160 --> 00:00:59,199
then we'll explore why it's

00:00:57,440 --> 00:01:01,120
architecturally beneficial to think

00:00:59,199 --> 00:01:03,359
about subscription operations as a

00:01:01,120 --> 00:01:06,960
separate concern from other operations

00:01:03,359 --> 00:01:08,960
executed against a data graph and lastly

00:01:06,960 --> 00:01:10,400
we'll see how we can build a decoupled

00:01:08,960 --> 00:01:12,240
subscription service

00:01:10,400 --> 00:01:13,760
that integrates with the federated data

00:01:12,240 --> 00:01:16,640
graph schema

00:01:13,760 --> 00:01:18,560
so let's begin with apollo federation

00:01:16,640 --> 00:01:19,439
federation has been around for a couple

00:01:18,560 --> 00:01:21,439
years now

00:01:19,439 --> 00:01:23,439
and since its release it has allowed us

00:01:21,439 --> 00:01:25,040
to get a lot closer to realizing the

00:01:23,439 --> 00:01:26,400
dream of designing and building

00:01:25,040 --> 00:01:29,200
distributed graphql

00:01:26,400 --> 00:01:30,880
architectures that are both maintainable

00:01:29,200 --> 00:01:34,560
and that can easily facilitate

00:01:30,880 --> 00:01:36,560
cross-team collaboration specifically

00:01:34,560 --> 00:01:38,240
federation allows teams to embrace

00:01:36,560 --> 00:01:39,759
separation of concerns

00:01:38,240 --> 00:01:41,600
so that they can work on different

00:01:39,759 --> 00:01:43,360
products and features that are powered

00:01:41,600 --> 00:01:45,119
by a single data graph

00:01:43,360 --> 00:01:47,680
and they can do this work without

00:01:45,119 --> 00:01:49,920
stepping on each other's toes

00:01:47,680 --> 00:01:51,759
and on top of that apollo gateway takes

00:01:49,920 --> 00:01:53,040
a declarative approach to composing

00:01:51,759 --> 00:01:55,600
subgraphs together

00:01:53,040 --> 00:01:57,200
and handles query planning for us so we

00:01:55,600 --> 00:01:59,040
don't have to deal with the imperative

00:01:57,200 --> 00:02:00,880
pain points of other approaches to

00:01:59,040 --> 00:02:02,880
designing distributed graphql

00:02:00,880 --> 00:02:05,520
architectures

00:02:02,880 --> 00:02:06,719
so that means that back-end teams can

00:02:05,520 --> 00:02:08,959
independently manage

00:02:06,719 --> 00:02:11,280
their portions of the data graph while

00:02:08,959 --> 00:02:13,200
still exposing a single graphql endpoint

00:02:11,280 --> 00:02:15,360
to client developers

00:02:13,200 --> 00:02:17,840
and at the moment this works well for

00:02:15,360 --> 00:02:20,080
query and mutation operations

00:02:17,840 --> 00:02:23,200
but out of the box apollo federation

00:02:20,080 --> 00:02:25,520
doesn't support subscription operations

00:02:23,200 --> 00:02:27,680
now before we jump down the rabbit hole

00:02:25,520 --> 00:02:29,360
of how a federated data graph

00:02:27,680 --> 00:02:31,120
may be extended to support those

00:02:29,360 --> 00:02:32,720
subscription operations

00:02:31,120 --> 00:02:34,959
i think there's an important question to

00:02:32,720 --> 00:02:36,080
consider and i would say it's an

00:02:34,959 --> 00:02:38,160
important question to

00:02:36,080 --> 00:02:40,959
answer for both federated and

00:02:38,160 --> 00:02:42,560
non-federated data graphs alike

00:02:40,959 --> 00:02:44,800
and that question is whether

00:02:42,560 --> 00:02:46,640
subscriptions are truly the right way to

00:02:44,800 --> 00:02:48,400
support the real-time feature that you

00:02:46,640 --> 00:02:50,560
need to implement

00:02:48,400 --> 00:02:52,480
today there are many popular graphql

00:02:50,560 --> 00:02:53,760
servers and other libraries that support

00:02:52,480 --> 00:02:55,360
subscriptions

00:02:53,760 --> 00:02:57,200
and the barriers to getting up and

00:02:55,360 --> 00:03:00,400
running with them are relatively low

00:02:57,200 --> 00:03:02,879
which is great and many of these popular

00:03:00,400 --> 00:03:05,120
graphql subscription implementations

00:03:02,879 --> 00:03:06,319
typically use websockets as a transport

00:03:05,120 --> 00:03:08,239
layer

00:03:06,319 --> 00:03:10,080
but there's no such thing as a full

00:03:08,239 --> 00:03:12,560
duplex free lunch

00:03:10,080 --> 00:03:14,560
for example maintaining an open socket

00:03:12,560 --> 00:03:16,159
connection to receive updates from a

00:03:14,560 --> 00:03:17,840
subscription operation

00:03:16,159 --> 00:03:20,560
will have non-trivial battery

00:03:17,840 --> 00:03:22,879
implications for mobile devices

00:03:20,560 --> 00:03:25,040
so before you add the subscription type

00:03:22,879 --> 00:03:27,440
to any graphql schema

00:03:25,040 --> 00:03:28,560
it's worth asking if polling for less

00:03:27,440 --> 00:03:31,360
frequent updates

00:03:28,560 --> 00:03:32,000
or using push notifications on mobile

00:03:31,360 --> 00:03:35,519
would be a more

00:03:32,000 --> 00:03:37,120
suitable solution but let's say for your

00:03:35,519 --> 00:03:38,959
use case that subscriptions are the

00:03:37,120 --> 00:03:41,040
right technical answer

00:03:38,959 --> 00:03:43,120
at this point we'll turn our attention

00:03:41,040 --> 00:03:43,920
to leveraging what's available in apollo

00:03:43,120 --> 00:03:46,400
gateway

00:03:43,920 --> 00:03:48,560
to support those subscription operations

00:03:46,400 --> 00:03:51,040
against your federated data graph

00:03:48,560 --> 00:03:53,120
and will do so in a way that for clients

00:03:51,040 --> 00:03:56,799
will feel as seamless as it does with a

00:03:53,120 --> 00:03:56,799
monolithic graphql api

00:03:57,040 --> 00:04:01,120
so turning our attention back to our

00:03:59,360 --> 00:04:03,040
federated data graph

00:04:01,120 --> 00:04:04,959
it's important to note that a key

00:04:03,040 --> 00:04:06,319
feature of apollo federation is that it

00:04:04,959 --> 00:04:08,640
was designed to support

00:04:06,319 --> 00:04:10,480
decoupled and distributed graphql

00:04:08,640 --> 00:04:13,519
architectures

00:04:10,480 --> 00:04:14,080
however the stateless nature of the http

00:04:13,519 --> 00:04:16,160
transport

00:04:14,080 --> 00:04:18,479
layer that usually supports query and

00:04:16,160 --> 00:04:20,479
mutation operations on the graph

00:04:18,479 --> 00:04:22,479
may not need to scale in the same way

00:04:20,479 --> 00:04:23,759
that stateful websocket connections need

00:04:22,479 --> 00:04:25,360
to

00:04:23,759 --> 00:04:27,360
but in a standard approach to

00:04:25,360 --> 00:04:28,320
implementing subscriptions for a graphql

00:04:27,360 --> 00:04:30,160
api

00:04:28,320 --> 00:04:32,639
we often end up coupling these two

00:04:30,160 --> 00:04:35,360
transport concerns together

00:04:32,639 --> 00:04:37,360
so in the spirit of decoupling ideally

00:04:35,360 --> 00:04:40,840
our federated data graph would remain as

00:04:37,360 --> 00:04:42,240
the stateless execution engine of the

00:04:40,840 --> 00:04:44,400
api

00:04:42,240 --> 00:04:46,160
and alongside it we could have a

00:04:44,400 --> 00:04:47,759
separate and dedicated subscription

00:04:46,160 --> 00:04:49,440
service that's responsible for

00:04:47,759 --> 00:04:50,880
maintaining the stateful connections

00:04:49,440 --> 00:04:52,880
with clients

00:04:50,880 --> 00:04:54,880
as well as processing and responding to

00:04:52,880 --> 00:04:57,120
those requests

00:04:54,880 --> 00:04:59,040
so in this scenario the stateless and

00:04:57,120 --> 00:04:59,680
stateful transport related concerns of

00:04:59,040 --> 00:05:02,560
the graph

00:04:59,680 --> 00:05:04,639
can be scaled independently but this

00:05:02,560 --> 00:05:06,560
proposed architecture then leads us to

00:05:04,639 --> 00:05:07,919
some very practical and important

00:05:06,560 --> 00:05:10,560
questions

00:05:07,919 --> 00:05:12,240
for example if the subscriptions are

00:05:10,560 --> 00:05:14,240
managed in a separate service

00:05:12,240 --> 00:05:16,320
and apollo federation doesn't directly

00:05:14,240 --> 00:05:18,400
integrate with subscriptions yet

00:05:16,320 --> 00:05:20,560
then how do you use the same types that

00:05:18,400 --> 00:05:23,680
are defined in the federated data graph

00:05:20,560 --> 00:05:26,400
as output types for subscription fields

00:05:23,680 --> 00:05:28,160
and how will subscription operations

00:05:26,400 --> 00:05:30,080
resolve additional data that isn't

00:05:28,160 --> 00:05:32,240
provided in the message payload that was

00:05:30,080 --> 00:05:35,199
published by a subgraph

00:05:32,240 --> 00:05:36,560
and lastly if the type definitions from

00:05:35,199 --> 00:05:38,080
the federated data graph

00:05:36,560 --> 00:05:39,840
are included in the subscription

00:05:38,080 --> 00:05:42,080
services schema

00:05:39,840 --> 00:05:44,160
how will backend teams keep the schemas

00:05:42,080 --> 00:05:46,000
in sync between the graph router

00:05:44,160 --> 00:05:47,919
and the subscription service without

00:05:46,000 --> 00:05:48,479
amassing large amounts of technical debt

00:05:47,919 --> 00:05:52,160
or other

00:05:48,479 --> 00:05:54,720
overhead well i should be able to

00:05:52,160 --> 00:05:56,800
provide some answers to those questions

00:05:54,720 --> 00:05:58,400
the separate subscription service will

00:05:56,800 --> 00:05:59,440
be responsible for defining a

00:05:58,400 --> 00:06:02,000
subscription type

00:05:59,440 --> 00:06:03,280
only but under the hood we will auto

00:06:02,000 --> 00:06:04,960
magically incorporate

00:06:03,280 --> 00:06:07,440
all the type definitions from the

00:06:04,960 --> 00:06:09,440
federated data graph into the schema

00:06:07,440 --> 00:06:11,440
so that any of these types may be used

00:06:09,440 --> 00:06:12,880
as output types for those subscription

00:06:11,440 --> 00:06:15,520
fields

00:06:12,880 --> 00:06:17,520
in doing so client developers can write

00:06:15,520 --> 00:06:19,440
subscription operations in a way that

00:06:17,520 --> 00:06:21,280
reflects the natural relationships

00:06:19,440 --> 00:06:22,720
between the types in your federated data

00:06:21,280 --> 00:06:25,280
graph

00:06:22,720 --> 00:06:26,800
and from the client's perspective it

00:06:25,280 --> 00:06:28,400
will appear as though they are running

00:06:26,800 --> 00:06:30,240
these subscription operations

00:06:28,400 --> 00:06:31,840
directly against the same data graph

00:06:30,240 --> 00:06:34,479
that they are also running query and

00:06:31,840 --> 00:06:36,000
mutation operations against because in

00:06:34,479 --> 00:06:37,440
essence that's exactly what they're

00:06:36,000 --> 00:06:39,199
doing

00:06:37,440 --> 00:06:41,680
and from the subgraph developers

00:06:39,199 --> 00:06:43,680
perspective they will be able to publish

00:06:41,680 --> 00:06:45,840
subscription related messages to a

00:06:43,680 --> 00:06:47,440
shared pub sub implementation

00:06:45,840 --> 00:06:49,280
just as they would for a monolithic

00:06:47,440 --> 00:06:52,000
graphql api

00:06:49,280 --> 00:06:52,720
and then within the subscription service

00:06:52,000 --> 00:06:54,720
subscription

00:06:52,720 --> 00:06:57,039
type definitions and resolvers may be

00:06:54,720 --> 00:07:00,560
configured exactly as they would be

00:06:57,039 --> 00:07:02,319
for any graphql api but while using

00:07:00,560 --> 00:07:05,199
output types that are defined in the

00:07:02,319 --> 00:07:07,360
federated data graph

00:07:05,199 --> 00:07:09,120
so to explore this solution in more

00:07:07,360 --> 00:07:10,400
depth let's imagine the following

00:07:09,120 --> 00:07:12,400
scenario

00:07:10,400 --> 00:07:14,080
we're going to build a live blog powered

00:07:12,400 --> 00:07:16,400
by apollo federation

00:07:14,080 --> 00:07:18,800
and this data graph will have an author

00:07:16,400 --> 00:07:21,520
service and a post service

00:07:18,800 --> 00:07:23,280
and for this live blog we'll need a

00:07:21,520 --> 00:07:26,000
single subscription operation

00:07:23,280 --> 00:07:27,599
to push new posts to subscribe clients

00:07:26,000 --> 00:07:29,199
immediately as those posts become

00:07:27,599 --> 00:07:31,599
available

00:07:29,199 --> 00:07:33,680
and in addition to the basic post data

00:07:31,599 --> 00:07:35,919
we will also need to traverse the graph

00:07:33,680 --> 00:07:39,360
to provide some related author details

00:07:35,919 --> 00:07:41,599
in the subscription response as well

00:07:39,360 --> 00:07:43,599
so let's explore the basic setup in a

00:07:41,599 --> 00:07:45,360
bit more depth

00:07:43,599 --> 00:07:46,960
there are four main architectural

00:07:45,360 --> 00:07:47,919
components we'll concern ourselves with

00:07:46,960 --> 00:07:50,960
here

00:07:47,919 --> 00:07:52,400
first the graph router and its subgraphs

00:07:50,960 --> 00:07:54,479
we'll also have our decoupled

00:07:52,400 --> 00:07:57,440
subscription service

00:07:54,479 --> 00:07:58,000
and we'll have a redis instance and

00:07:57,440 --> 00:08:01,440
lastly

00:07:58,000 --> 00:08:03,759
an apollo client powered react app now

00:08:01,440 --> 00:08:04,879
the post sub graph will publish post

00:08:03,759 --> 00:08:07,599
added messages

00:08:04,879 --> 00:08:09,199
to redis after a new post is created in

00:08:07,599 --> 00:08:10,800
a mutation

00:08:09,199 --> 00:08:12,639
and the subscription service will

00:08:10,800 --> 00:08:14,800
subscribe to those same post added

00:08:12,639 --> 00:08:16,720
messages from redis

00:08:14,800 --> 00:08:18,720
and the subscription service may

00:08:16,720 --> 00:08:20,560
occasionally need to make calls over to

00:08:18,720 --> 00:08:21,360
the graph router to fetch additional

00:08:20,560 --> 00:08:23,360
data

00:08:21,360 --> 00:08:26,319
needed to fully resolve a post added

00:08:23,360 --> 00:08:27,919
subscription operation

00:08:26,319 --> 00:08:29,599
and then the new post data will be

00:08:27,919 --> 00:08:32,640
pushed down to the client via a

00:08:29,599 --> 00:08:34,880
websocket connection

00:08:32,640 --> 00:08:35,919
now we use redis pub sub for

00:08:34,880 --> 00:08:38,080
subscriptions here

00:08:35,919 --> 00:08:39,279
instead of a basic in memory pub sub

00:08:38,080 --> 00:08:41,760
implementation

00:08:39,279 --> 00:08:42,800
because any of the subgraph services may

00:08:41,760 --> 00:08:45,600
need to publish

00:08:42,800 --> 00:08:47,440
messages to redis while the subscription

00:08:45,600 --> 00:08:48,880
service will need to be able to receive

00:08:47,440 --> 00:08:50,640
those same messages

00:08:48,880 --> 00:08:52,640
and we can easily imagine that these

00:08:50,640 --> 00:08:54,240
services may be running in completely

00:08:52,640 --> 00:08:57,120
different containers

00:08:54,240 --> 00:09:00,080
so for this scenario we'll use graphql

00:08:57,120 --> 00:09:02,160
redis subscriptions

00:09:00,080 --> 00:09:04,399
in our post service it's worth noting

00:09:02,160 --> 00:09:07,200
that we are referencing an author entity

00:09:04,399 --> 00:09:08,000
from an author's subgraph to use as the

00:09:07,200 --> 00:09:10,560
author field

00:09:08,000 --> 00:09:12,160
on the post type and we're referencing

00:09:10,560 --> 00:09:15,279
that author based on its id

00:09:12,160 --> 00:09:17,040
key field and we also have an ad post

00:09:15,279 --> 00:09:18,240
mutation which is where we'll need to

00:09:17,040 --> 00:09:20,839
publish a meta

00:09:18,240 --> 00:09:23,200
a message to redis about a new post's

00:09:20,839 --> 00:09:26,240
availability

00:09:23,200 --> 00:09:28,480
and over in the post resolvers we do

00:09:26,240 --> 00:09:31,920
exactly that inside of an ad post

00:09:28,480 --> 00:09:33,839
resolver publishing a post added message

00:09:31,920 --> 00:09:35,279
with a payload containing some of the

00:09:33,839 --> 00:09:37,360
new post data

00:09:35,279 --> 00:09:39,360
but we don't include anything in that

00:09:37,360 --> 00:09:41,519
payload about the post author apart from

00:09:39,360 --> 00:09:43,519
its id

00:09:41,519 --> 00:09:46,080
now zipping over to the subscription

00:09:43,519 --> 00:09:48,240
service the type definitions that we

00:09:46,080 --> 00:09:49,600
manually define here will only contain

00:09:48,240 --> 00:09:51,600
the subscription type

00:09:49,600 --> 00:09:52,880
as well as any field we want to add to

00:09:51,600 --> 00:09:55,120
that type

00:09:52,880 --> 00:09:57,040
however because we're going to merge the

00:09:55,120 --> 00:09:59,279
types from the federated data graph

00:09:57,040 --> 00:10:00,560
into the schema in just a moment we'll

00:09:59,279 --> 00:10:02,399
be able to use

00:10:00,560 --> 00:10:04,240
those types defined in the federated

00:10:02,399 --> 00:10:06,560
data graph as output types

00:10:04,240 --> 00:10:09,120
for the subscription fields even though

00:10:06,560 --> 00:10:11,600
they are not explicitly defined here

00:10:09,120 --> 00:10:12,800
so in this case we use the post type

00:10:11,600 --> 00:10:16,640
that is owned by the post

00:10:12,800 --> 00:10:18,640
subgraph now this is where things start

00:10:16,640 --> 00:10:21,200
to get really interesting

00:10:18,640 --> 00:10:21,920
so to get the schema for the federated

00:10:21,200 --> 00:10:24,000
data graph

00:10:21,920 --> 00:10:25,839
we can instantiate an apollo gateway

00:10:24,000 --> 00:10:27,040
object directly in the subscription

00:10:25,839 --> 00:10:29,519
service

00:10:27,040 --> 00:10:30,480
and in this example we're using managed

00:10:29,519 --> 00:10:33,120
federation

00:10:30,480 --> 00:10:34,640
so there would be an apollo key variable

00:10:33,120 --> 00:10:36,640
set in the environment

00:10:34,640 --> 00:10:39,200
and we don't need to provide a service

00:10:36,640 --> 00:10:41,760
list option in its config

00:10:39,200 --> 00:10:43,360
it's also worth noting that this gateway

00:10:41,760 --> 00:10:44,399
is a little bit different from what

00:10:43,360 --> 00:10:46,000
we're used to seeing

00:10:44,399 --> 00:10:49,200
because we're not going to pass this

00:10:46,000 --> 00:10:51,920
gateway directly into an apollo server

00:10:49,200 --> 00:10:53,360
we will however set an on schema change

00:10:51,920 --> 00:10:55,360
option for that gateway

00:10:53,360 --> 00:10:56,959
that will take the gateway schema and

00:10:55,360 --> 00:10:58,959
incorporate it with the subscription

00:10:56,959 --> 00:11:01,279
services type definitions

00:10:58,959 --> 00:11:03,360
and the resolvers to make an executable

00:11:01,279 --> 00:11:06,720
schema for the service to run its

00:11:03,360 --> 00:11:08,640
subscription operations against and the

00:11:06,720 --> 00:11:11,120
on schema change option will run

00:11:08,640 --> 00:11:14,959
whenever the gateway pulls apollo studio

00:11:11,120 --> 00:11:17,360
for the schema and it detects a change

00:11:14,959 --> 00:11:18,560
now over in the resolvers for our

00:11:17,360 --> 00:11:21,120
subscription fields

00:11:18,560 --> 00:11:22,800
we'll also set up a client to access the

00:11:21,120 --> 00:11:25,120
shared redis instance

00:11:22,800 --> 00:11:27,519
just as we did in the post service but

00:11:25,120 --> 00:11:29,040
here we listen for post added messages

00:11:27,519 --> 00:11:31,440
instead

00:11:29,040 --> 00:11:33,440
and if all we ever needed to do was

00:11:31,440 --> 00:11:35,519
resolve data that's available in the

00:11:33,440 --> 00:11:36,320
message payload provided by the post

00:11:35,519 --> 00:11:37,839
service

00:11:36,320 --> 00:11:40,480
then this would be the end of the story

00:11:37,839 --> 00:11:42,079
for us but that payload doesn't include

00:11:40,480 --> 00:11:44,640
the author details we need

00:11:42,079 --> 00:11:45,440
or for that matter any other data about

00:11:44,640 --> 00:11:47,519
the new post

00:11:45,440 --> 00:11:49,920
that may be queried when using that node

00:11:47,519 --> 00:11:51,920
as an entry point to the graph

00:11:49,920 --> 00:11:54,079
so we'll need some way to resolve that

00:11:51,920 --> 00:11:56,480
additional data whenever it is requested

00:11:54,079 --> 00:11:58,720
by clients

00:11:56,480 --> 00:12:00,800
so to illustrate what we have to work

00:11:58,720 --> 00:12:01,839
with when a new post added message is

00:12:00,800 --> 00:12:03,920
received

00:12:01,839 --> 00:12:05,760
we can see here what field values are

00:12:03,920 --> 00:12:07,440
available in the payload

00:12:05,760 --> 00:12:08,800
and what we still need to resolve from

00:12:07,440 --> 00:12:11,920
the federated data graph

00:12:08,800 --> 00:12:13,760
to fully resolve the complete operation

00:12:11,920 --> 00:12:15,360
and there are a couple different ways we

00:12:13,760 --> 00:12:18,320
could approach this

00:12:15,360 --> 00:12:20,720
for one we could define resolvers on the

00:12:18,320 --> 00:12:23,200
post type on a per field basis in the

00:12:20,720 --> 00:12:24,959
subscription service to fetch data

00:12:23,200 --> 00:12:26,639
from the gateway for any of these

00:12:24,959 --> 00:12:27,760
additional fields that the client may

00:12:26,639 --> 00:12:29,920
request

00:12:27,760 --> 00:12:31,120
but this may not be very efficient in

00:12:29,920 --> 00:12:33,680
terms of network

00:12:31,120 --> 00:12:35,600
requests and it may not be very future

00:12:33,680 --> 00:12:36,720
proof either as the graph continues to

00:12:35,600 --> 00:12:38,560
evolve

00:12:36,720 --> 00:12:40,639
so also just a more maintainable

00:12:38,560 --> 00:12:42,800
approach that we can take

00:12:40,639 --> 00:12:43,680
which is to leverage the generic resolve

00:12:42,800 --> 00:12:45,600
method

00:12:43,680 --> 00:12:47,279
inside of the resolver for the post

00:12:45,600 --> 00:12:49,760
added subscription field

00:12:47,279 --> 00:12:52,000
because this method will allow us to

00:12:49,760 --> 00:12:54,160
intercept the payload and do whatever

00:12:52,000 --> 00:12:55,839
we need to do to it before resolving the

00:12:54,160 --> 00:12:58,399
operation

00:12:55,839 --> 00:13:00,480
so here we can create a data source

00:12:58,399 --> 00:13:01,920
that's capable of diffing the provided

00:13:00,480 --> 00:13:04,000
payload fields

00:13:01,920 --> 00:13:05,040
with the actual field selections in the

00:13:04,000 --> 00:13:07,279
operation

00:13:05,040 --> 00:13:09,360
and then query the federated data graph

00:13:07,279 --> 00:13:12,480
for just those missing fields

00:13:09,360 --> 00:13:14,959
in a single request so what this

00:13:12,480 --> 00:13:17,040
approach ultimately enables is that as

00:13:14,959 --> 00:13:19,519
long as the data source provides a

00:13:17,040 --> 00:13:21,200
mechanism to fetch a single post from

00:13:19,519 --> 00:13:23,279
the federated data graph

00:13:21,200 --> 00:13:25,600
then the post can be used as an entry

00:13:23,279 --> 00:13:27,519
point to all other relationships it has

00:13:25,600 --> 00:13:29,839
with other nodes in the graph

00:13:27,519 --> 00:13:31,360
and thus fully resolve all of the data

00:13:29,839 --> 00:13:33,279
that's required for the subscription

00:13:31,360 --> 00:13:36,000
operation

00:13:33,279 --> 00:13:37,920
great so with that going in place the

00:13:36,000 --> 00:13:40,160
last step is to fire up a websocket

00:13:37,920 --> 00:13:42,240
server to use as an endpoint to send the

00:13:40,160 --> 00:13:44,320
subscription operations to

00:13:42,240 --> 00:13:47,279
and one option that we can use for this

00:13:44,320 --> 00:13:49,600
is the graphqlws library

00:13:47,279 --> 00:13:51,680
and using this library's use server

00:13:49,600 --> 00:13:53,279
function we can set the gateway data

00:13:51,680 --> 00:13:55,680
source on the context so that it's

00:13:53,279 --> 00:13:57,920
available to all of the resolvers

00:13:55,680 --> 00:13:58,959
and we may also wish to set additional

00:13:57,920 --> 00:14:01,199
context here too

00:13:58,959 --> 00:14:02,480
such as a token retrieved from the

00:14:01,199 --> 00:14:05,360
connection programs if

00:14:02,480 --> 00:14:07,120
authentication is involved and

00:14:05,360 --> 00:14:09,199
importantly for our purposes

00:14:07,120 --> 00:14:11,519
we would use the unsubscribe callback

00:14:09,199 --> 00:14:12,880
here to set the execution arguments for

00:14:11,519 --> 00:14:14,560
each subscription

00:14:12,880 --> 00:14:16,959
including the current value of the

00:14:14,560 --> 00:14:18,240
schema variable we previously set in the

00:14:16,959 --> 00:14:22,160
gateway objects

00:14:18,240 --> 00:14:24,320
on schema change method and lastly

00:14:22,160 --> 00:14:26,560
in the onsubscribe callback we can

00:14:24,320 --> 00:14:28,839
optionally return a graphql error if a

00:14:26,560 --> 00:14:31,279
client tries to send a query or mutation

00:14:28,839 --> 00:14:32,079
operation to this websocket powered

00:14:31,279 --> 00:14:34,160
endpoint

00:14:32,079 --> 00:14:36,959
instead of the http endpoint for the

00:14:34,160 --> 00:14:39,279
federated data graph

00:14:36,959 --> 00:14:42,000
so on a final note let's talk about what

00:14:39,279 --> 00:14:43,839
this means for clients

00:14:42,000 --> 00:14:45,519
and the good news is that as far as

00:14:43,839 --> 00:14:48,079
subscriptions are concerned it's going

00:14:45,519 --> 00:14:50,399
to be business as usual for them

00:14:48,079 --> 00:14:52,320
the most important thing is that when a

00:14:50,399 --> 00:14:54,160
client creates a websocket link

00:14:52,320 --> 00:14:55,760
that link will point to the endpoint for

00:14:54,160 --> 00:14:56,560
the subscription service that we just

00:14:55,760 --> 00:14:58,639
set up

00:14:56,560 --> 00:15:00,560
and then the http link will point

00:14:58,639 --> 00:15:01,839
directly to the gateway endpoint as

00:15:00,560 --> 00:15:04,160
usual

00:15:01,839 --> 00:15:06,079
and from there the client can direct

00:15:04,160 --> 00:15:08,560
traffic as needed using apollo client

00:15:06,079 --> 00:15:10,959
split function

00:15:08,560 --> 00:15:12,320
now to wrap up i'd like to quickly cover

00:15:10,959 --> 00:15:14,160
off some considerations and

00:15:12,320 --> 00:15:17,519
cross-cutting concerns to keep in mind

00:15:14,160 --> 00:15:19,600
when you implement the solution first

00:15:17,519 --> 00:15:21,279
this solution requires all subscription

00:15:19,600 --> 00:15:23,279
fields to be defined in a single

00:15:21,279 --> 00:15:25,519
decoupled subscription service

00:15:23,279 --> 00:15:27,519
so that may necessitate that ownership

00:15:25,519 --> 00:15:28,160
of the service is shared across teams

00:15:27,519 --> 00:15:30,320
that manage

00:15:28,160 --> 00:15:33,519
independent portions of the schema that

00:15:30,320 --> 00:15:36,000
are applicable to queries and mutations

00:15:33,519 --> 00:15:36,959
second some level of coordination would

00:15:36,000 --> 00:15:39,519
be necessary

00:15:36,959 --> 00:15:40,959
to ensure that event labels such as the

00:15:39,519 --> 00:15:42,959
post added label

00:15:40,959 --> 00:15:45,040
are synchronized between the subgraphs

00:15:42,959 --> 00:15:47,519
that publish events and the subscription

00:15:45,040 --> 00:15:49,839
service that calls the async iterator

00:15:47,519 --> 00:15:50,959
iterator method with these labels as

00:15:49,839 --> 00:15:52,720
arguments

00:15:50,959 --> 00:15:55,360
because breaking changes may occur

00:15:52,720 --> 00:15:57,759
without such coordination

00:15:55,360 --> 00:15:59,680
third to improve real-time performance

00:15:57,759 --> 00:16:01,839
and minimize the number of requests

00:15:59,680 --> 00:16:02,720
from the subscription service back to

00:16:01,839 --> 00:16:05,360
the gateway

00:16:02,720 --> 00:16:06,800
to resolve those non-payload fields some

00:16:05,360 --> 00:16:07,680
form of caching would likely be

00:16:06,800 --> 00:16:09,920
desirable

00:16:07,680 --> 00:16:11,839
and further you may perhaps also

00:16:09,920 --> 00:16:14,399
encourage client developers to avoid

00:16:11,839 --> 00:16:15,199
over fetching data in their subscription

00:16:14,399 --> 00:16:17,199
operations

00:16:15,199 --> 00:16:19,440
and leverage the apollo client cache

00:16:17,199 --> 00:16:21,680
wherever possible

00:16:19,440 --> 00:16:23,279
lastly removing a type from the

00:16:21,680 --> 00:16:24,639
federated data graph when the

00:16:23,279 --> 00:16:27,120
subscription service

00:16:24,639 --> 00:16:28,160
uses that type as an output type for one

00:16:27,120 --> 00:16:30,399
of its fields

00:16:28,160 --> 00:16:32,880
will be a breaking change unless this

00:16:30,399 --> 00:16:35,120
type removal happens simultaneously

00:16:32,880 --> 00:16:36,399
between both the subscription service

00:16:35,120 --> 00:16:38,880
and the gateway

00:16:36,399 --> 00:16:41,120
so good schema governance practices are

00:16:38,880 --> 00:16:42,160
a must and it would also be a good idea

00:16:41,120 --> 00:16:44,800
to lean on your

00:16:42,160 --> 00:16:46,720
observability tooling here to understand

00:16:44,800 --> 00:16:48,399
what operations are being executed

00:16:46,720 --> 00:16:51,680
against your federated data graph

00:16:48,399 --> 00:16:53,440
from the subscription service

00:16:51,680 --> 00:16:55,360
now some of the code examples i shared

00:16:53,440 --> 00:16:57,360
today were truncated for brevity's sake

00:16:55,360 --> 00:16:59,519
so i've included a full working example

00:16:57,360 --> 00:17:02,000
of this pattern in this repo

00:16:59,519 --> 00:17:03,199
and this repo also contains reference

00:17:02,000 --> 00:17:05,360
implementations to

00:17:03,199 --> 00:17:06,319
all of the utilities that i shared today

00:17:05,360 --> 00:17:08,640
such as the

00:17:06,319 --> 00:17:10,640
make subscription schema function the

00:17:08,640 --> 00:17:12,000
add gateway data source to subscription

00:17:10,640 --> 00:17:13,919
context function

00:17:12,000 --> 00:17:15,360
and the gateway data source base class

00:17:13,919 --> 00:17:17,439
2.

00:17:15,360 --> 00:17:19,120
and with that i'd like to say thank you

00:17:17,439 --> 00:17:20,640
so much for joining me for this talk

00:17:19,120 --> 00:17:33,840
today and i'd be happy to take some

00:17:20,640 --> 00:17:33,840
questions now

00:17:34,100 --> 00:17:37,220
[Music]

00:17:38,080 --> 00:17:40,160

YouTube URL: https://www.youtube.com/watch?v=C5pSwLpjZM0


