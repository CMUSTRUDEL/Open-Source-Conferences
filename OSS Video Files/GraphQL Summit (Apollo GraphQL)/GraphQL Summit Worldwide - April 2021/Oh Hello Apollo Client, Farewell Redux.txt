Title: Oh Hello Apollo Client, Farewell Redux
Publication date: 2021-04-13
Playlist: GraphQL Summit Worldwide - April 2021
Description: 
	A good state management library should have the ability to manage side effects, transform data, and update state. Apollo client 3 has all of that but where does that stand with Redux? If you were also a skeptic then you will enjoy this talk as Ankita takes you through her journey of adopting and scaling Apollo client for state management.

 In this talk, Ankita will draw comparisons with Redux and Context and walk you through how an e-commerce application has adopted it and scaled it.

Key takeaways:
* How hooks allowed the team to remove redux actions
* Use local-only fields and type policies to manage all client data in one place
* How to use reactive variables for authentication
Captions: 
	00:00:00,740 --> 00:00:12,970
[Music]

00:00:14,160 --> 00:00:18,080
hello everyone

00:00:15,360 --> 00:00:19,840
um i hope everyone is having a good day

00:00:18,080 --> 00:00:22,400
or had a good day or

00:00:19,840 --> 00:00:24,560
hopefully we'll have a good day um my

00:00:22,400 --> 00:00:26,560
name is ankita kulkarni i'm a tech lead

00:00:24,560 --> 00:00:28,000
at loblaw digital and today i'm going to

00:00:26,560 --> 00:00:30,400
be talking about

00:00:28,000 --> 00:00:32,079
oh hello apollo client and farewell

00:00:30,400 --> 00:00:35,120
redux

00:00:32,079 --> 00:00:36,320
um like i said i'm ankita i'm working on

00:00:35,120 --> 00:00:39,280
at loblaw digital

00:00:36,320 --> 00:00:40,399
on a pro on a e-commerce application

00:00:39,280 --> 00:00:42,800
like shoppers drug

00:00:40,399 --> 00:00:44,079
called shoppers drug mart and today i'm

00:00:42,800 --> 00:00:47,360
going to be taking you

00:00:44,079 --> 00:00:48,480
on a journey for why i guess it's time

00:00:47,360 --> 00:00:51,840
for us to say

00:00:48,480 --> 00:00:52,399
maybe favorable to redux and why apollo

00:00:51,840 --> 00:00:54,879
client

00:00:52,399 --> 00:00:57,440
is should be used essentially for as a

00:00:54,879 --> 00:01:00,000
good state management strategy

00:00:57,440 --> 00:01:01,120
so let's take a step back here and

00:01:00,000 --> 00:01:04,159
assess

00:01:01,120 --> 00:01:06,159
what we usually typically look for in a

00:01:04,159 --> 00:01:08,400
good state management library

00:01:06,159 --> 00:01:09,280
or what exactly do we mean by good state

00:01:08,400 --> 00:01:12,400
management

00:01:09,280 --> 00:01:13,680
what makes a good state manager so there

00:01:12,400 --> 00:01:15,920
are a few principles

00:01:13,680 --> 00:01:17,040
one being that the data is normalized so

00:01:15,920 --> 00:01:19,439
if you think about it

00:01:17,040 --> 00:01:20,560
you don't want the data to be duplicated

00:01:19,439 --> 00:01:23,920
in your global store

00:01:20,560 --> 00:01:25,360
overall just because you don't know what

00:01:23,920 --> 00:01:26,880
the source of truth is

00:01:25,360 --> 00:01:28,479
what the real thing is and it makes

00:01:26,880 --> 00:01:30,000
sense

00:01:28,479 --> 00:01:32,320
data gets transformed pretty

00:01:30,000 --> 00:01:33,520
consistently so for example

00:01:32,320 --> 00:01:35,360
you want to make sure that the

00:01:33,520 --> 00:01:38,159
transformation of data

00:01:35,360 --> 00:01:39,680
is quite consistent so that whatever you

00:01:38,159 --> 00:01:41,200
whenever you pass your input

00:01:39,680 --> 00:01:42,720
that's exactly what you're passing

00:01:41,200 --> 00:01:44,479
getting as an output

00:01:42,720 --> 00:01:45,840
you're able to visualize the global

00:01:44,479 --> 00:01:48,079
state after

00:01:45,840 --> 00:01:49,759
i mean visualization helps right so when

00:01:48,079 --> 00:01:51,520
you do which when you are able to

00:01:49,759 --> 00:01:53,040
visualize the global state it makes

00:01:51,520 --> 00:01:54,640
sense because then you can

00:01:53,040 --> 00:01:56,479
kind of debug what's going on and

00:01:54,640 --> 00:01:57,119
whatnot which brings up me to my next

00:01:56,479 --> 00:01:59,759
topic

00:01:57,119 --> 00:02:02,159
which is debugging is not hard i mean is

00:01:59,759 --> 00:02:05,040
debugging ever that easy

00:02:02,159 --> 00:02:06,719
it could be at times but just to make

00:02:05,040 --> 00:02:08,399
sure that whenever something is going

00:02:06,719 --> 00:02:09,360
wrong with our state we are able to

00:02:08,399 --> 00:02:12,239
debug it quite

00:02:09,360 --> 00:02:13,920
easily and lastly you can write tests so

00:02:12,239 --> 00:02:15,520
that's this is extremely important just

00:02:13,920 --> 00:02:17,040
because whatever code you're writing is

00:02:15,520 --> 00:02:19,120
extremely important to be able to write

00:02:17,040 --> 00:02:22,480
tests for that as well

00:02:19,120 --> 00:02:25,280
and we all know a library that was good

00:02:22,480 --> 00:02:25,840
this is still good at this i guess

00:02:25,280 --> 00:02:28,560
readers

00:02:25,840 --> 00:02:29,360
redux fixes everything i mean i have

00:02:28,560 --> 00:02:31,680
used redux

00:02:29,360 --> 00:02:33,599
a lot in a lot of different applications

00:02:31,680 --> 00:02:36,480
and it is quite

00:02:33,599 --> 00:02:37,440
remarkable and how you know we can use

00:02:36,480 --> 00:02:39,840
readouts to

00:02:37,440 --> 00:02:41,040
essentially do the complete front-end

00:02:39,840 --> 00:02:44,080
management

00:02:41,040 --> 00:02:46,480
uh of your overall state but as most

00:02:44,080 --> 00:02:49,680
libraries redux is also opinionated

00:02:46,480 --> 00:02:51,680
in terms of how things go

00:02:49,680 --> 00:02:53,360
what exactly for those who don't know i

00:02:51,680 --> 00:02:54,720
want to talk about like what exactly is

00:02:53,360 --> 00:02:57,280
redux right

00:02:54,720 --> 00:02:58,800
redux is essentially a predictable state

00:02:57,280 --> 00:03:01,280
container for javascript

00:02:58,800 --> 00:03:02,000
in other words it's meant to handle and

00:03:01,280 --> 00:03:04,480
organize

00:03:02,000 --> 00:03:05,120
global application state data so as you

00:03:04,480 --> 00:03:07,120
can see

00:03:05,120 --> 00:03:09,120
you don't need to dispatch an action

00:03:07,120 --> 00:03:11,599
which goes into the dispatcher

00:03:09,120 --> 00:03:13,200
and we need a reducer to manipulate the

00:03:11,599 --> 00:03:15,760
state so that our ui

00:03:13,200 --> 00:03:17,040
component gets re-rendered and in a

00:03:15,760 --> 00:03:20,080
redux world

00:03:17,040 --> 00:03:22,959
or i would say in traditionally in in

00:03:20,080 --> 00:03:23,840
any sort of like asynchron async action

00:03:22,959 --> 00:03:25,440
itself

00:03:23,840 --> 00:03:27,440
there are different action types one

00:03:25,440 --> 00:03:30,400
being for example

00:03:27,440 --> 00:03:32,239
a card a card request would typically

00:03:30,400 --> 00:03:36,640
have a success and an error

00:03:32,239 --> 00:03:39,840
as well so it's extremely important that

00:03:36,640 --> 00:03:42,560
cart request is handled correctly and

00:03:39,840 --> 00:03:43,040
we do get necessary success and error

00:03:42,560 --> 00:03:45,280
data

00:03:43,040 --> 00:03:46,480
based on that and based on that we also

00:03:45,280 --> 00:03:49,519
we would be able to show the different

00:03:46,480 --> 00:03:49,519
loading states as well

00:03:53,439 --> 00:03:57,519
so essentially this is what a

00:03:55,439 --> 00:03:59,120
asynchronous request would look like in

00:03:57,519 --> 00:04:02,319
a redux application

00:03:59,120 --> 00:04:03,439
this is a redux saga example and as you

00:04:02,319 --> 00:04:06,400
can notice that

00:04:03,439 --> 00:04:08,239
in you're able to fetch the card data so

00:04:06,400 --> 00:04:10,080
get card query is something

00:04:08,239 --> 00:04:11,760
that is defined for the card query

00:04:10,080 --> 00:04:13,920
itself and

00:04:11,760 --> 00:04:15,040
you can dispatch an action like card

00:04:13,920 --> 00:04:16,560
success

00:04:15,040 --> 00:04:18,239
and then if there's an error you

00:04:16,560 --> 00:04:20,639
dispatch card error

00:04:18,239 --> 00:04:21,440
and at the bottom here we also have like

00:04:20,639 --> 00:04:24,639
a watcher

00:04:21,440 --> 00:04:28,240
which essentially watches all our

00:04:24,639 --> 00:04:30,639
requests overall so why switch

00:04:28,240 --> 00:04:31,840
well it's because apollo graphql

00:04:30,639 --> 00:04:35,360
happened

00:04:31,840 --> 00:04:35,840
after apollo client hooks we were able

00:04:35,360 --> 00:04:39,440
to

00:04:35,840 --> 00:04:41,680
retrieve loading error data states from

00:04:39,440 --> 00:04:44,560
the use query hook itself

00:04:41,680 --> 00:04:45,600
it gave us ability to make queries on

00:04:44,560 --> 00:04:47,919
the front end

00:04:45,600 --> 00:04:49,520
using the hooks way which is pretty

00:04:47,919 --> 00:04:51,040
modern way of doing things

00:04:49,520 --> 00:04:53,199
and you can also pass in like different

00:04:51,040 --> 00:04:54,639
variables such as in this case

00:04:53,199 --> 00:04:56,639
if it's a card query and if it's a

00:04:54,639 --> 00:04:58,080
logged in user or not based on that you

00:04:56,639 --> 00:04:59,759
can pass in like different variables and

00:04:58,080 --> 00:05:01,919
whatnot

00:04:59,759 --> 00:05:03,600
it really made our life easy and just

00:05:01,919 --> 00:05:04,400
like use query we also have used

00:05:03,600 --> 00:05:06,160
mutation

00:05:04,400 --> 00:05:07,440
as well where you can actually trigger

00:05:06,160 --> 00:05:09,680
any sort of

00:05:07,440 --> 00:05:10,880
post calls or put calls or anything like

00:05:09,680 --> 00:05:12,400
that in their in your front-end

00:05:10,880 --> 00:05:14,400
application as well

00:05:12,400 --> 00:05:17,520
so what that what does that this mean we

00:05:14,400 --> 00:05:19,840
don't no longer need a cart request

00:05:17,520 --> 00:05:22,400
essentially we in terms of a success and

00:05:19,840 --> 00:05:24,080
failure we can lean on the hooks itself

00:05:22,400 --> 00:05:27,440
for the success and failure

00:05:24,080 --> 00:05:29,600
of the specific request and query

00:05:27,440 --> 00:05:31,199
so again we don't need an action type

00:05:29,600 --> 00:05:34,080
for all three

00:05:31,199 --> 00:05:35,520
and but i'm still not convinced that it

00:05:34,080 --> 00:05:39,360
does replace redux

00:05:35,520 --> 00:05:41,759
right just because what about

00:05:39,360 --> 00:05:42,960
things like transforming data

00:05:41,759 --> 00:05:45,600
normalizing data

00:05:42,960 --> 00:05:46,880
handle handling asynchronous actions

00:05:45,600 --> 00:05:49,120
triggering state updates in the

00:05:46,880 --> 00:05:50,720
component and remember selectors

00:05:49,120 --> 00:05:52,479
but those who don't know what selectors

00:05:50,720 --> 00:05:56,319
are is essentially you can

00:05:52,479 --> 00:05:58,160
access the global state and pick exactly

00:05:56,319 --> 00:05:59,520
what you're selecting and what state

00:05:58,160 --> 00:06:03,600
you're selecting

00:05:59,520 --> 00:06:06,800
uh as well so this really helps with

00:06:03,600 --> 00:06:09,280
testing your data overall but also you

00:06:06,800 --> 00:06:11,680
only grab a slice of the state that you

00:06:09,280 --> 00:06:14,479
necessarily need

00:06:11,680 --> 00:06:16,639
so we have apollo client three that

00:06:14,479 --> 00:06:19,919
essentially is like yes

00:06:16,639 --> 00:06:21,199
challenge accepted a lot of good things

00:06:19,919 --> 00:06:23,120
have come out of the live

00:06:21,199 --> 00:06:24,560
like this essentially apollo client

00:06:23,120 --> 00:06:27,840
three overall

00:06:24,560 --> 00:06:30,240
and that definitely helps a lot with our

00:06:27,840 --> 00:06:32,240
overall front-end state management like

00:06:30,240 --> 00:06:32,880
i'm i'm gonna be honest i've had my

00:06:32,240 --> 00:06:35,199
share

00:06:32,880 --> 00:06:36,000
fair share of doubts especially coming

00:06:35,199 --> 00:06:39,039
from

00:06:36,000 --> 00:06:41,280
a redux react context background

00:06:39,039 --> 00:06:43,360
i felt like this was something that made

00:06:41,280 --> 00:06:44,960
my life a lot easier and

00:06:43,360 --> 00:06:46,800
you know had me convinced this is this

00:06:44,960 --> 00:06:48,639
is the great move

00:06:46,800 --> 00:06:50,800
so what essentially is the difference

00:06:48,639 --> 00:06:53,599
between a redux

00:06:50,800 --> 00:06:54,560
um architecture and apollo client

00:06:53,599 --> 00:06:56,639
architecture

00:06:54,560 --> 00:06:59,039
and obviously there are quite a lot of

00:06:56,639 --> 00:07:00,240
differences overall but it's extremely

00:06:59,039 --> 00:07:03,759
important

00:07:00,240 --> 00:07:07,280
that you know in one case

00:07:03,759 --> 00:07:08,639
redux is going to handle pretty much

00:07:07,280 --> 00:07:10,560
or i guess apollo client is going to

00:07:08,639 --> 00:07:13,840
handle pretty much everything for us

00:07:10,560 --> 00:07:14,639
and redux is like we get control to do

00:07:13,840 --> 00:07:18,000
everything

00:07:14,639 --> 00:07:19,599
and that's why it's the the meme here um

00:07:18,000 --> 00:07:21,039
so it only depends whether you want to

00:07:19,599 --> 00:07:23,280
give up control or not

00:07:21,039 --> 00:07:24,479
but at the same time i mean i don't want

00:07:23,280 --> 00:07:27,440
to give up my control

00:07:24,479 --> 00:07:28,479
right apollo client does do the heavy

00:07:27,440 --> 00:07:31,440
lifting

00:07:28,479 --> 00:07:32,080
for you so like it will manage all your

00:07:31,440 --> 00:07:34,639
state

00:07:32,080 --> 00:07:36,400
it will handle data normalization and a

00:07:34,639 --> 00:07:37,280
lot of things that we talked about in

00:07:36,400 --> 00:07:38,479
terms of

00:07:37,280 --> 00:07:41,039
what makes a really good state

00:07:38,479 --> 00:07:42,720
management solution and just because it

00:07:41,039 --> 00:07:44,319
does the heavy lifting for you

00:07:42,720 --> 00:07:46,400
we need to kind of work with it to

00:07:44,319 --> 00:07:46,879
understand how it internally works as

00:07:46,400 --> 00:07:48,400
well

00:07:46,879 --> 00:07:50,720
because i feel like this would be like

00:07:48,400 --> 00:07:54,080
my biggest i would say take away

00:07:50,720 --> 00:07:56,720
after upgrading to apollo 5 3 was that

00:07:54,080 --> 00:07:58,800
and essentially using caching as a

00:07:56,720 --> 00:07:59,919
state management strategy overall on the

00:07:58,800 --> 00:08:03,599
front end too

00:07:59,919 --> 00:08:06,720
that how does essentially the

00:08:03,599 --> 00:08:09,039
root query works or how does the overall

00:08:06,720 --> 00:08:11,599
apollo client handle the different

00:08:09,039 --> 00:08:13,680
actions and reducers and all that

00:08:11,599 --> 00:08:14,960
all those concepts that we initially

00:08:13,680 --> 00:08:17,039
talked about

00:08:14,960 --> 00:08:19,199
so let us revisit some of the state

00:08:17,039 --> 00:08:21,599
management principles

00:08:19,199 --> 00:08:22,240
my data is not analyzed right because we

00:08:21,599 --> 00:08:26,080
don't want

00:08:22,240 --> 00:08:28,720
any duplicates

00:08:26,080 --> 00:08:29,440
just because apollo takes care of it for

00:08:28,720 --> 00:08:31,199
us

00:08:29,440 --> 00:08:33,599
we don't need to worry about things like

00:08:31,199 --> 00:08:36,719
actions and reducers

00:08:33,599 --> 00:08:39,279
so what exactly does apollo client

00:08:36,719 --> 00:08:42,159
provide us it automatically caches your

00:08:39,279 --> 00:08:44,240
data by generating a unique id

00:08:42,159 --> 00:08:45,600
it normalizes new data in query

00:08:44,240 --> 00:08:48,480
responses and after

00:08:45,600 --> 00:08:50,080
mutation just because the cache

00:08:48,480 --> 00:08:52,959
generates a unique id

00:08:50,080 --> 00:08:53,760
for every identifier and identifiable

00:08:52,959 --> 00:08:56,080
object

00:08:53,760 --> 00:08:58,320
included in the response the cache is

00:08:56,080 --> 00:08:59,519
the cache stores the object by id in a

00:08:58,320 --> 00:09:01,920
flat lookup table

00:08:59,519 --> 00:09:03,040
right and whenever an incoming request

00:09:01,920 --> 00:09:05,360
comes in

00:09:03,040 --> 00:09:06,880
with the same id as an existing object

00:09:05,360 --> 00:09:09,279
the fields of those objects are

00:09:06,880 --> 00:09:11,440
essentially merged

00:09:09,279 --> 00:09:13,519
and just because it stores data using

00:09:11,440 --> 00:09:14,640
references it can also look up data

00:09:13,519 --> 00:09:18,399
quite easily

00:09:14,640 --> 00:09:18,800
right and it does all that manipulation

00:09:18,399 --> 00:09:21,440
for

00:09:18,800 --> 00:09:22,320
us right we don't need to necessarily

00:09:21,440 --> 00:09:24,399
ask for

00:09:22,320 --> 00:09:26,080
it to do it because it will do it for

00:09:24,399 --> 00:09:28,320
you whereas in redux

00:09:26,080 --> 00:09:29,680
or i would say a lot of other state

00:09:28,320 --> 00:09:31,279
management libraries

00:09:29,680 --> 00:09:34,320
we would have to kind of tell the state

00:09:31,279 --> 00:09:37,600
management library to do it for us

00:09:34,320 --> 00:09:39,920
by actions and reducers and whatnot

00:09:37,600 --> 00:09:41,760
so let's take a look up how the root

00:09:39,920 --> 00:09:44,240
query overall looks like

00:09:41,760 --> 00:09:45,040
we need to we again the biggest takeaway

00:09:44,240 --> 00:09:46,560
being

00:09:45,040 --> 00:09:48,560
we need to understand how the cache

00:09:46,560 --> 00:09:50,000
overall works and the little bit of how

00:09:48,560 --> 00:09:52,880
it works internally

00:09:50,000 --> 00:09:53,519
so it would keep a copy of the it would

00:09:52,880 --> 00:09:55,920
have like

00:09:53,519 --> 00:09:58,720
generated a root query and in this

00:09:55,920 --> 00:10:01,200
example back to our card example overall

00:09:58,720 --> 00:10:02,320
it would keep a reference for each each

00:10:01,200 --> 00:10:04,720
card object

00:10:02,320 --> 00:10:06,720
so that is essentially going to do a

00:10:04,720 --> 00:10:09,440
lookup based on reference

00:10:06,720 --> 00:10:11,120
just to update what has changed in your

00:10:09,440 --> 00:10:13,279
data

00:10:11,120 --> 00:10:15,360
and like i said understanding the

00:10:13,279 --> 00:10:18,399
internal workings of the apollo client

00:10:15,360 --> 00:10:19,279
would definitely help in terms of how

00:10:18,399 --> 00:10:21,839
you

00:10:19,279 --> 00:10:24,959
essentially organize your overall state

00:10:21,839 --> 00:10:26,560
of your application and so on

00:10:24,959 --> 00:10:28,560
data transformation this was another

00:10:26,560 --> 00:10:31,600
principle that we talked about

00:10:28,560 --> 00:10:34,399
and even though you think about it

00:10:31,600 --> 00:10:36,240
that if we have to manipulate data and

00:10:34,399 --> 00:10:38,079
we have to transform data we could also

00:10:36,240 --> 00:10:39,360
do that in the graphql server itself we

00:10:38,079 --> 00:10:40,240
don't necessarily need to do that on the

00:10:39,360 --> 00:10:42,720
front end

00:10:40,240 --> 00:10:46,399
but we need to keep in mind that the

00:10:42,720 --> 00:10:48,959
graphql server is not just being used by

00:10:46,399 --> 00:10:50,079
one team it could potentially be used by

00:10:48,959 --> 00:10:52,480
different teams

00:10:50,079 --> 00:10:54,320
so one we can just fully transform the

00:10:52,480 --> 00:10:57,040
data exactly how we like

00:10:54,320 --> 00:10:57,760
just because how we want the data to

00:10:57,040 --> 00:10:59,360
look like

00:10:57,760 --> 00:11:01,200
is a job of more of a front-end

00:10:59,360 --> 00:11:04,640
application and

00:11:01,200 --> 00:11:06,240
not necessarily the server so again

00:11:04,640 --> 00:11:08,240
as it's possible the several apps will

00:11:06,240 --> 00:11:09,360
be using it this is something that we

00:11:08,240 --> 00:11:12,000
need to keep in mind

00:11:09,360 --> 00:11:12,480
and let's take a look at a few examples

00:11:12,000 --> 00:11:14,480
one

00:11:12,480 --> 00:11:16,000
is let's say we are building an

00:11:14,480 --> 00:11:17,680
e-commerce application

00:11:16,000 --> 00:11:20,560
and this is how our card query looks

00:11:17,680 --> 00:11:22,079
like most of the product details

00:11:20,560 --> 00:11:23,760
and the card details are stored in the

00:11:22,079 --> 00:11:25,839
back are stored

00:11:23,760 --> 00:11:27,600
essentially in the back end and this is

00:11:25,839 --> 00:11:30,800
the graphql query

00:11:27,600 --> 00:11:33,600
that's fetching that data at the bottom

00:11:30,800 --> 00:11:35,120
this is how you would call it in a use

00:11:33,600 --> 00:11:38,640
query using

00:11:35,120 --> 00:11:38,640
you using an apollo client

00:11:38,880 --> 00:11:42,800
and on the right hand side this is

00:11:40,240 --> 00:11:46,079
essentially the example of data

00:11:42,800 --> 00:11:47,519
of how it looks like and again it

00:11:46,079 --> 00:11:49,760
doesn't match like

00:11:47,519 --> 00:11:51,440
exactly but you can kind of get the idea

00:11:49,760 --> 00:11:53,760
of how what the product data would

00:11:51,440 --> 00:11:56,800
essentially look like

00:11:53,760 --> 00:12:00,639
so let's say if we do have a

00:11:56,800 --> 00:12:04,480
example wherein we do want to show okay

00:12:00,639 --> 00:12:06,320
for out of stock or low stock um

00:12:04,480 --> 00:12:07,680
card items we want to show a message to

00:12:06,320 --> 00:12:09,440
the user and that's it this is

00:12:07,680 --> 00:12:12,480
essentially a react example

00:12:09,440 --> 00:12:14,079
right this is super simple i have

00:12:12,480 --> 00:12:16,880
obviously trimmed it down

00:12:14,079 --> 00:12:18,639
to take the actual logic of the

00:12:16,880 --> 00:12:20,079
application because obviously that logic

00:12:18,639 --> 00:12:21,440
would be way too complicated

00:12:20,079 --> 00:12:23,760
but on the left hand side what we are

00:12:21,440 --> 00:12:25,760
seeing is that we call the card query

00:12:23,760 --> 00:12:28,240
and then we have a function to get out

00:12:25,760 --> 00:12:31,120
of stock or low stock text

00:12:28,240 --> 00:12:32,240
and based on what we have in our data we

00:12:31,120 --> 00:12:34,959
essentially show

00:12:32,240 --> 00:12:35,680
and again it's super simple if the card

00:12:34,959 --> 00:12:39,920
items

00:12:35,680 --> 00:12:42,000
um that we have or is essentially

00:12:39,920 --> 00:12:44,399
being subtracted from the available

00:12:42,000 --> 00:12:47,360
stock then we essentially say that okay

00:12:44,399 --> 00:12:48,079
it's going to be low stock or if we do

00:12:47,360 --> 00:12:51,279
look at the

00:12:48,079 --> 00:12:52,720
is out of stock variable from

00:12:51,279 --> 00:12:54,399
the card query itself then we're going

00:12:52,720 --> 00:12:55,360
to show out of stock and at the bottom

00:12:54,399 --> 00:12:57,040
we're just looping

00:12:55,360 --> 00:12:58,560
on the right hand side this is how we

00:12:57,040 --> 00:13:00,160
would essentially

00:12:58,560 --> 00:13:02,720
again show the data as well as an

00:13:00,160 --> 00:13:03,279
example now this is how it would look

00:13:02,720 --> 00:13:05,360
like

00:13:03,279 --> 00:13:07,040
but again all this application all this

00:13:05,360 --> 00:13:08,399
logic could potentially be used in

00:13:07,040 --> 00:13:09,920
different pages as well

00:13:08,399 --> 00:13:11,839
we want to make sure that our data

00:13:09,920 --> 00:13:12,720
transformation is all happening in one

00:13:11,839 --> 00:13:16,560
spot

00:13:12,720 --> 00:13:18,880
versus in different spots right

00:13:16,560 --> 00:13:20,160
so how can we achieve the same in apollo

00:13:18,880 --> 00:13:23,440
client

00:13:20,160 --> 00:13:25,839
well let's do this right so what are

00:13:23,440 --> 00:13:28,959
some local only fields

00:13:25,839 --> 00:13:30,560
now apollo client queries can include

00:13:28,959 --> 00:13:33,440
local only fields

00:13:30,560 --> 00:13:34,639
that aren't defined in your graphql

00:13:33,440 --> 00:13:36,560
server schema

00:13:34,639 --> 00:13:38,000
so what this means is that you can

00:13:36,560 --> 00:13:39,040
manipulate a lot of the logic on the

00:13:38,000 --> 00:13:40,480
front of them

00:13:39,040 --> 00:13:42,959
the values for these fields are

00:13:40,480 --> 00:13:44,320
calculated locally using any logic that

00:13:42,959 --> 00:13:46,800
you want so for example

00:13:44,320 --> 00:13:49,040
in this case an apollo client is making

00:13:46,800 --> 00:13:51,680
the get card query that we saw

00:13:49,040 --> 00:13:52,959
and if you notice something it's going

00:13:51,680 --> 00:13:54,320
to go to the server

00:13:52,959 --> 00:13:56,399
but at the bottom over there there is

00:13:54,320 --> 00:13:56,880
something called a stock text and it has

00:13:56,399 --> 00:14:00,000
an ad

00:13:56,880 --> 00:14:02,800
client uh i would say a variable

00:14:00,000 --> 00:14:04,800
right and that's because what it does is

00:14:02,800 --> 00:14:06,160
essentially using add client

00:14:04,800 --> 00:14:07,680
it's not going to go to the server to

00:14:06,160 --> 00:14:08,720
fetch that information it's going to go

00:14:07,680 --> 00:14:10,240
to the client cache

00:14:08,720 --> 00:14:12,720
on the front end itself to fetch that

00:14:10,240 --> 00:14:14,880
information a single query itself can

00:14:12,720 --> 00:14:16,079
include both local only fields

00:14:14,880 --> 00:14:17,839
and fields that are fresh from my

00:14:16,079 --> 00:14:18,959
graphql server like we saw in this

00:14:17,839 --> 00:14:21,360
example

00:14:18,959 --> 00:14:22,639
so how is exactly does the query would

00:14:21,360 --> 00:14:23,360
look like and this is how the query

00:14:22,639 --> 00:14:26,639
would look like

00:14:23,360 --> 00:14:28,800
right we are calling stock text so in

00:14:26,639 --> 00:14:30,720
local just because local only fields

00:14:28,800 --> 00:14:32,560
allow us to

00:14:30,720 --> 00:14:33,760
provide any logic that we want in the

00:14:32,560 --> 00:14:36,480
stock text

00:14:33,760 --> 00:14:38,720
what we have is in the read function we

00:14:36,480 --> 00:14:41,120
have the logic for that exact same

00:14:38,720 --> 00:14:43,040
function that we saw in the in the

00:14:41,120 --> 00:14:47,120
couple of slides before that

00:14:43,040 --> 00:14:49,360
and the reason being that for example

00:14:47,120 --> 00:14:51,680
what's going to happen is the minute we

00:14:49,360 --> 00:14:53,680
get to this spot

00:14:51,680 --> 00:14:54,720
on product itself it's going to look up

00:14:53,680 --> 00:14:57,279
stock text

00:14:54,720 --> 00:14:58,800
and stock text it's going to have a read

00:14:57,279 --> 00:15:01,839
function and it's going to

00:14:58,800 --> 00:15:03,680
essentially render this logic right and

00:15:01,839 --> 00:15:04,720
that this definitely helps and this is

00:15:03,680 --> 00:15:06,639
such a cool

00:15:04,720 --> 00:15:08,480
state management strategy because if

00:15:06,639 --> 00:15:09,360
you're using any sort of transformers on

00:15:08,480 --> 00:15:11,040
the front end

00:15:09,360 --> 00:15:13,760
you would essentially add local only

00:15:11,040 --> 00:15:14,399
fields that have access to the graphql

00:15:13,760 --> 00:15:16,720
data

00:15:14,399 --> 00:15:18,079
so this is where it would go first and

00:15:16,720 --> 00:15:19,760
as you can see when you're creating the

00:15:18,079 --> 00:15:20,480
client that's when you essentially pass

00:15:19,760 --> 00:15:22,000
it

00:15:20,480 --> 00:15:23,920
and now if you want to access that same

00:15:22,000 --> 00:15:24,720
data in the component this is how you

00:15:23,920 --> 00:15:26,560
would do it

00:15:24,720 --> 00:15:28,560
right the difference being that now all

00:15:26,560 --> 00:15:29,040
that logic is gone and a component can

00:15:28,560 --> 00:15:31,120
focus

00:15:29,040 --> 00:15:32,160
on the ui piece of it and actually

00:15:31,120 --> 00:15:34,000
rendering the data

00:15:32,160 --> 00:15:35,920
and stock tax is essentially just being

00:15:34,000 --> 00:15:37,440
accessed from the use query data

00:15:35,920 --> 00:15:39,360
variable itself

00:15:37,440 --> 00:15:41,360
now what about fields that don't need to

00:15:39,360 --> 00:15:44,240
be defined in a graphql dive

00:15:41,360 --> 00:15:45,759
right what about them well we they also

00:15:44,240 --> 00:15:46,880
introduce something called as reactive

00:15:45,759 --> 00:15:49,279
variables

00:15:46,880 --> 00:15:51,040
reactive variables are a specific

00:15:49,279 --> 00:15:52,560
mechanism for storing local state

00:15:51,040 --> 00:15:54,800
outside of the cache

00:15:52,560 --> 00:15:56,320
because they are separate from the cache

00:15:54,800 --> 00:15:58,079
reactive variables can store

00:15:56,320 --> 00:15:59,759
any data in any shape that you want it

00:15:58,079 --> 00:16:01,680
doesn't need to kind of necessarily

00:15:59,759 --> 00:16:04,639
abide by the graphql server

00:16:01,680 --> 00:16:06,240
type principles and most importantly

00:16:04,639 --> 00:16:07,920
modifying it

00:16:06,240 --> 00:16:10,399
triggers an update of the component

00:16:07,920 --> 00:16:11,120
itself so again storing whatever you

00:16:10,399 --> 00:16:13,759
want

00:16:11,120 --> 00:16:14,160
modifies them modifies them triggers an

00:16:13,759 --> 00:16:16,320
update

00:16:14,160 --> 00:16:18,160
as well and this is how essentially a

00:16:16,320 --> 00:16:19,600
reactive variable would look like

00:16:18,160 --> 00:16:21,360
i have created a reactive variable

00:16:19,600 --> 00:16:23,360
called is logged in war

00:16:21,360 --> 00:16:24,639
and you use the make war from apollo

00:16:23,360 --> 00:16:26,560
client itself

00:16:24,639 --> 00:16:27,920
that would trigger a function called is

00:16:26,560 --> 00:16:29,360
user logged in

00:16:27,920 --> 00:16:31,279
i don't have the logic for this user

00:16:29,360 --> 00:16:33,360
logged in here but as you can see what

00:16:31,279 --> 00:16:33,920
happens is that function is responsible

00:16:33,360 --> 00:16:35,759
for

00:16:33,920 --> 00:16:38,000
checking the token making sure the token

00:16:35,759 --> 00:16:39,920
has not expired and so on and so forth

00:16:38,000 --> 00:16:41,600
and we are calling that and storing that

00:16:39,920 --> 00:16:43,680
and it is logged in variable

00:16:41,600 --> 00:16:45,839
and the same thing under type policies

00:16:43,680 --> 00:16:48,959
we are defining and returning that

00:16:45,839 --> 00:16:49,600
now anytime you want to access the is

00:16:48,959 --> 00:16:50,959
logged in

00:16:49,600 --> 00:16:53,120
the user is logged in or not and the

00:16:50,959 --> 00:16:55,680
component should show something

00:16:53,120 --> 00:16:56,240
uh based on the logged in information or

00:16:55,680 --> 00:16:58,399
not

00:16:56,240 --> 00:16:59,360
we essentially could do that just like

00:16:58,399 --> 00:17:01,920
this

00:16:59,360 --> 00:17:02,959
so if the user is logged in we render

00:17:01,920 --> 00:17:04,720
the app

00:17:02,959 --> 00:17:07,120
if the user is not logged in we render

00:17:04,720 --> 00:17:09,520
the login page and apollo also

00:17:07,120 --> 00:17:11,600
gives us the ability to actually access

00:17:09,520 --> 00:17:13,839
that variable directly in the component

00:17:11,600 --> 00:17:16,160
using use reactive hook which is pretty

00:17:13,839 --> 00:17:18,160
cool so anytime the user is not logged

00:17:16,160 --> 00:17:20,400
in because the component expires

00:17:18,160 --> 00:17:21,280
uh sorry if the token expires or not

00:17:20,400 --> 00:17:24,400
essentially

00:17:21,280 --> 00:17:26,240
that would render the login page because

00:17:24,400 --> 00:17:28,880
this component gets re-rendered

00:17:26,240 --> 00:17:30,080
now isn't that really cool i mean i

00:17:28,880 --> 00:17:32,240
found this super cool

00:17:30,080 --> 00:17:33,760
and again going back to a lot of redux

00:17:32,240 --> 00:17:34,640
principles and state management

00:17:33,760 --> 00:17:38,000
principles

00:17:34,640 --> 00:17:40,880
this just solves a lot of the

00:17:38,000 --> 00:17:41,679
a lot of the pro key problems for us

00:17:40,880 --> 00:17:44,480
lastly

00:17:41,679 --> 00:17:46,799
debugging with apollo client you are

00:17:44,480 --> 00:17:49,120
also able to visualize your cache

00:17:46,799 --> 00:17:50,160
as well and this is extremely important

00:17:49,120 --> 00:17:52,240
right because as

00:17:50,160 --> 00:17:53,919
in redux or a lot of different libraries

00:17:52,240 --> 00:17:56,080
we do have dev tools

00:17:53,919 --> 00:17:58,320
so you can re visualize your cache over

00:17:56,080 --> 00:17:58,960
here and this is an example of the dev

00:17:58,320 --> 00:18:02,000
tools

00:17:58,960 --> 00:18:05,120
um and based on

00:18:02,000 --> 00:18:06,799
for example e is logged in is a

00:18:05,120 --> 00:18:08,720
reactive variable and you do need to

00:18:06,799 --> 00:18:11,840
check off the box for load from cache

00:18:08,720 --> 00:18:12,799
to show what the value of it lastly

00:18:11,840 --> 00:18:14,880
testing

00:18:12,799 --> 00:18:16,799
we do need to make sure that we are able

00:18:14,880 --> 00:18:20,080
to test our data consistently

00:18:16,799 --> 00:18:22,799
so this is an example of a mock provider

00:18:20,080 --> 00:18:23,919
wherein we pass in the data the default

00:18:22,799 --> 00:18:25,919
mock data as well

00:18:23,919 --> 00:18:27,280
if you want it the key thing here is

00:18:25,919 --> 00:18:31,200
that we need to make sure

00:18:27,280 --> 00:18:33,840
that the fetch policy is cash

00:18:31,200 --> 00:18:35,520
first so that we're able to test the

00:18:33,840 --> 00:18:37,679
mock request and data

00:18:35,520 --> 00:18:39,679
and a component would look like this

00:18:37,679 --> 00:18:42,799
wherein we essentially have

00:18:39,679 --> 00:18:45,520
a fetch policy or cash first

00:18:42,799 --> 00:18:47,280
mock data is essentially data from mocks

00:18:45,520 --> 00:18:47,919
and we are waiting and checking if the

00:18:47,280 --> 00:18:50,880
name is

00:18:47,919 --> 00:18:52,160
in kira for example i would say that

00:18:50,880 --> 00:18:55,200
keep an open mind

00:18:52,160 --> 00:18:57,919
is extremely important just because

00:18:55,200 --> 00:18:59,600
we are giving up control but at the same

00:18:57,919 --> 00:19:00,720
time just because apollo client is doing

00:18:59,600 --> 00:19:02,960
a lot for us

00:19:00,720 --> 00:19:05,120
it definitely helps us in terms of

00:19:02,960 --> 00:19:07,200
visualizing everything

00:19:05,120 --> 00:19:09,440
again take control or give your control

00:19:07,200 --> 00:19:10,000
a little in redux we're already doing a

00:19:09,440 --> 00:19:12,880
lot

00:19:10,000 --> 00:19:15,039
we have bigger problems to solve using

00:19:12,880 --> 00:19:16,559
redux and apollo client with graphql

00:19:15,039 --> 00:19:19,520
there's a lot of redundant

00:19:16,559 --> 00:19:20,160
data as well which is again you are

00:19:19,520 --> 00:19:22,640
we're using

00:19:20,160 --> 00:19:24,240
graphql but we also have redux apollo

00:19:22,640 --> 00:19:26,240
client already stores data

00:19:24,240 --> 00:19:27,520
so it does feel quite redundant and you

00:19:26,240 --> 00:19:30,240
do need to understand

00:19:27,520 --> 00:19:31,919
lastly how apollo client works it's

00:19:30,240 --> 00:19:34,720
definitely a mindset shift

00:19:31,919 --> 00:19:35,919
but this is something that i feel like

00:19:34,720 --> 00:19:38,000
with

00:19:35,919 --> 00:19:39,440
onboarding your team on apollo client

00:19:38,000 --> 00:19:42,320
more talking about

00:19:39,440 --> 00:19:43,200
how you want to fetch data talking about

00:19:42,320 --> 00:19:45,840
a lot of

00:19:43,200 --> 00:19:46,720
uh complex async stuff that needs to be

00:19:45,840 --> 00:19:50,320
handled

00:19:46,720 --> 00:19:52,240
maybe by apollo client for example

00:19:50,320 --> 00:19:55,200
things like that would definitely help a

00:19:52,240 --> 00:19:56,720
lot tremendously with your mindset sure

00:19:55,200 --> 00:19:58,880
just because it will help you understand

00:19:56,720 --> 00:20:00,960
how apollo client is doing it for you

00:19:58,880 --> 00:20:02,960
and how you can work with it to be able

00:20:00,960 --> 00:20:04,720
to understand it better

00:20:02,960 --> 00:20:06,880
well this is pretty much the end if you

00:20:04,720 --> 00:20:09,600
do have any questions comments

00:20:06,880 --> 00:20:12,080
feedback uh catch me after on twitch

00:20:09,600 --> 00:20:15,280
i'll be happy to answer any questions

00:20:12,080 --> 00:20:16,960
thank you so much for your time and yeah

00:20:15,280 --> 00:20:21,840
i'll i'll be happy to answer any

00:20:16,960 --> 00:20:21,840
questions after

00:20:24,140 --> 00:20:31,650
[Music]

00:20:32,480 --> 00:20:34,559

YouTube URL: https://www.youtube.com/watch?v=6_39tpIBGIA


