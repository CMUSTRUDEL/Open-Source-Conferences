Title: Supercharge Your Schemas with Custom Directives (Ryan Chenkie)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Using Apollo, we can write directives to supercharge our schemas with custom behavior. Let's talk about how to write custom directives and the benefits they offer.

Ryan Chenkie, Trainer/Developer at Angularcasts.io, is a full-stack JavaScript developer, trainer, and Google Developer Expert and believes that GraphQL's schema language is beautiful. It allows us to author data models concisely and communicate with teammates clearly. 

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Captions: 
	00:00:02,920 --> 00:00:07,040
alright thanks for visions hi everyone

00:00:05,120 --> 00:00:09,920
my name is Ryan and I want to talk to

00:00:07,040 --> 00:00:12,440
you today about schema directives and in

00:00:09,920 --> 00:00:14,630
particular custom schema directives how

00:00:12,440 --> 00:00:16,820
we might go about using this what I

00:00:14,630 --> 00:00:19,850
think is a pretty cool feature of graph

00:00:16,820 --> 00:00:22,160
QL - to achieve some some neat things

00:00:19,850 --> 00:00:24,020
with our graphical schemas quick show of

00:00:22,160 --> 00:00:26,990
hands anybody using any kind of schema

00:00:24,020 --> 00:00:30,019
directives so far okay cool excellent a

00:00:26,990 --> 00:00:32,360
couple of us so I guess you know maybe

00:00:30,019 --> 00:00:34,100
this is in a kind of custom way that

00:00:32,360 --> 00:00:36,110
you're doing this what I want to go over

00:00:34,100 --> 00:00:38,600
is kind of some of the newer stuff that

00:00:36,110 --> 00:00:40,790
we've got with Apollo that allows us to

00:00:38,600 --> 00:00:43,610
achieve custom schema directives more

00:00:40,790 --> 00:00:46,520
easily than we used to to achieve it so

00:00:43,610 --> 00:00:48,559
like I said my name is Ryan chengqi I'm

00:00:46,520 --> 00:00:50,420
an angular and node consultant so I

00:00:48,559 --> 00:00:53,059
build a lot of applications in angular

00:00:50,420 --> 00:00:55,190
with node backends I help out businesses

00:00:53,059 --> 00:00:56,930
that are kind of just looking to get new

00:00:55,190 --> 00:00:59,750
technology in or maybe they don't have

00:00:56,930 --> 00:01:01,399
any technology at all I kind of do some

00:00:59,750 --> 00:01:04,399
business analysis stuff and build them

00:01:01,399 --> 00:01:08,080
applications and also Google developer

00:01:04,399 --> 00:01:11,810
experts and I teach at angular cast IO

00:01:08,080 --> 00:01:13,100
all right so what is a schema directive

00:01:11,810 --> 00:01:15,260
in the first place

00:01:13,100 --> 00:01:18,650
well to answer that we can go to the

00:01:15,260 --> 00:01:21,110
graph QL spec directives provide this

00:01:18,650 --> 00:01:23,509
way to do kind of this alternate runtime

00:01:21,110 --> 00:01:26,360
execution so we can think about it a

00:01:23,509 --> 00:01:29,479
little bit like changing the behavior of

00:01:26,360 --> 00:01:30,740
something at runtime so a good way to

00:01:29,479 --> 00:01:32,930
think about this is if we have a

00:01:30,740 --> 00:01:34,400
resolver that resolves with this certain

00:01:32,930 --> 00:01:37,250
piece of data certain piece of

00:01:34,400 --> 00:01:40,390
information we might want to affect the

00:01:37,250 --> 00:01:45,140
way that that resolver works at runtime

00:01:40,390 --> 00:01:47,090
so with directives in mind we've got we

00:01:45,140 --> 00:01:50,090
got a couple things at least in the spec

00:01:47,090 --> 00:01:51,140
we've got these built in directives when

00:01:50,090 --> 00:01:52,790
we're talking about queries because

00:01:51,140 --> 00:01:55,130
we've got directives at the query level

00:01:52,790 --> 00:01:57,380
and also at the schema level with

00:01:55,130 --> 00:02:00,259
queries the spec talks about the Skip

00:01:57,380 --> 00:02:02,049
and the include directives so kind of

00:02:00,259 --> 00:02:04,219
you know hopefully it's self-explanatory

00:02:02,049 --> 00:02:06,979
skip if there's some condition that's

00:02:04,219 --> 00:02:08,840
true or false include come at the

00:02:06,979 --> 00:02:10,789
inverse of that and then when we're

00:02:08,840 --> 00:02:12,500
talking about directives on the schema

00:02:10,789 --> 00:02:14,190
the spec really just talks about this

00:02:12,500 --> 00:02:17,790
one this deprecated

00:02:14,190 --> 00:02:19,370
directive and and it says after that

00:02:17,790 --> 00:02:22,080
basically if you want to do directives

00:02:19,370 --> 00:02:24,960
kind of it's up to you implement it

00:02:22,080 --> 00:02:26,490
however you want and that's been I guess

00:02:24,960 --> 00:02:28,170
a little bit of a sticking point for a

00:02:26,490 --> 00:02:29,520
lot of people historically when they

00:02:28,170 --> 00:02:31,590
want to use directives because there

00:02:29,520 --> 00:02:33,450
isn't like it hasn't been a super

00:02:31,590 --> 00:02:34,890
clear-cut way of doing it there's kind

00:02:33,450 --> 00:02:37,740
of everybody's reinventing the wheel

00:02:34,890 --> 00:02:39,390
every time they want to do directives so

00:02:37,740 --> 00:02:41,250
before we get too much into how you

00:02:39,390 --> 00:02:43,680
would actually create one let's take a

00:02:41,250 --> 00:02:46,170
look at what it looks like so here we've

00:02:43,680 --> 00:02:49,200
got just a simple field it's up type

00:02:46,170 --> 00:02:51,600
string field is foo if we want to use

00:02:49,200 --> 00:02:55,230
some kind of directive on it all we got

00:02:51,600 --> 00:02:58,050
to do is at sign directive name just

00:02:55,230 --> 00:03:00,840
like that if our directive is to take

00:02:58,050 --> 00:03:03,000
some arguments well we can just pass in

00:03:00,840 --> 00:03:05,130
an argument kind of like this so

00:03:03,000 --> 00:03:06,930
whatever argument is named whatever

00:03:05,130 --> 00:03:10,230
value we want to give it kind of like a

00:03:06,930 --> 00:03:12,270
function call all right so let's take a

00:03:10,230 --> 00:03:15,030
look at the kind of quintessential

00:03:12,270 --> 00:03:18,480
example of a directive so the deprecated

00:03:15,030 --> 00:03:19,680
directive let's say we've got this you

00:03:18,480 --> 00:03:22,920
know we've got this type here this

00:03:19,680 --> 00:03:25,500
invoice type and once upon a time we

00:03:22,920 --> 00:03:26,910
named a field something that we don't

00:03:25,500 --> 00:03:29,100
really want to have it named as anymore

00:03:26,910 --> 00:03:31,770
so client name here we want to say that

00:03:29,100 --> 00:03:33,630
this field should be deprecated and we

00:03:31,770 --> 00:03:37,430
provide a reason for that so what the

00:03:33,630 --> 00:03:40,950
client is with the client calling this

00:03:37,430 --> 00:03:44,640
this resolver is gonna get is this field

00:03:40,950 --> 00:03:47,760
should be replaced by something else so

00:03:44,640 --> 00:03:49,800
what we'd get if we did the query again

00:03:47,760 --> 00:03:51,570
just asking for client instead is we'd

00:03:49,800 --> 00:03:54,030
get the actual field we're looking for

00:03:51,570 --> 00:03:55,440
so deprecated directive can be useful of

00:03:54,030 --> 00:03:58,260
course if you want to deprecate certain

00:03:55,440 --> 00:03:59,610
fields so beyond that though beyond this

00:03:58,260 --> 00:04:01,590
deprecated directive is kind of the

00:03:59,610 --> 00:04:04,530
standard one that comes with a spec what

00:04:01,590 --> 00:04:06,120
can we solve basically anytime we want

00:04:04,530 --> 00:04:09,480
to again change the behavior of a

00:04:06,120 --> 00:04:12,060
resolver change how change what comes

00:04:09,480 --> 00:04:13,410
out of it when it's queried so this is

00:04:12,060 --> 00:04:16,919
useful for a lot of things

00:04:13,410 --> 00:04:18,660
internationalization is one one way that

00:04:16,919 --> 00:04:20,310
we can use them we can have something

00:04:18,660 --> 00:04:22,530
set up where depending on where the user

00:04:20,310 --> 00:04:24,090
is depending on their locale they'll get

00:04:22,530 --> 00:04:26,250
a different value out that's particular

00:04:24,090 --> 00:04:27,440
to them one of the biggest things that I

00:04:26,250 --> 00:04:29,510
really like is

00:04:27,440 --> 00:04:31,370
education and access control for those

00:04:29,510 --> 00:04:32,540
of you who said you're using directives

00:04:31,370 --> 00:04:35,150
anybody using it for this purpose

00:04:32,540 --> 00:04:37,220
access control authentication okay

00:04:35,150 --> 00:04:38,510
couple hands very good I really like it

00:04:37,220 --> 00:04:41,240
for this and one of the reasons that I

00:04:38,510 --> 00:04:43,610
like it is because you can get really

00:04:41,240 --> 00:04:45,830
kind of declarative and really explicit

00:04:43,610 --> 00:04:48,830
with how certain fields on your schema

00:04:45,830 --> 00:04:50,450
should behave so that's a very nice use

00:04:48,830 --> 00:04:52,550
case we've got things like string

00:04:50,450 --> 00:04:54,770
formatting so if you want to reformat a

00:04:52,550 --> 00:04:57,020
string you know turn it to uppercase

00:04:54,770 --> 00:04:59,690
turn it to lowercase not sure if you do

00:04:57,020 --> 00:05:02,540
that a lot but that's a decent use case

00:04:59,690 --> 00:05:04,130
for directives as well and we've got

00:05:02,540 --> 00:05:07,220
things like caching that's another use

00:05:04,130 --> 00:05:09,680
case and because when we're working with

00:05:07,220 --> 00:05:11,780
directives we're ultimately working with

00:05:09,680 --> 00:05:15,080
kind of a new resolver for that field

00:05:11,780 --> 00:05:16,970
what we can do is do a sync work because

00:05:15,080 --> 00:05:19,340
resolvers handle async so we can do

00:05:16,970 --> 00:05:21,200
things like who can make a call to some

00:05:19,340 --> 00:05:24,260
external service maybe we could call a

00:05:21,200 --> 00:05:25,940
REST API and return data from that so we

00:05:24,260 --> 00:05:30,620
can get pretty creative we can do a lot

00:05:25,940 --> 00:05:33,040
of things with custom directives so like

00:05:30,620 --> 00:05:37,040
I said earlier using custom directives

00:05:33,040 --> 00:05:38,750
used to suck it used to be tricky and

00:05:37,040 --> 00:05:41,570
cumbersome and because there wasn't a

00:05:38,750 --> 00:05:43,460
really prescriptive way to do it there

00:05:41,570 --> 00:05:45,950
were kind of it was left up to

00:05:43,460 --> 00:05:47,840
interpretation but thankfully with new

00:05:45,950 --> 00:05:49,190
things from Apollo that were released

00:05:47,840 --> 00:05:52,070
earlier this year it's become a lot

00:05:49,190 --> 00:05:55,370
easier so let's see how to do this let's

00:05:52,070 --> 00:05:58,490
go for a visit and what do I mean by

00:05:55,370 --> 00:06:00,760
that well with Apollo we get this class

00:05:58,490 --> 00:06:04,220
called schema directive visitor and the

00:06:00,760 --> 00:06:06,830
idea here is that our schemas are made

00:06:04,220 --> 00:06:08,960
up of lots of different parts you know

00:06:06,830 --> 00:06:11,030
there's there's many different aspects

00:06:08,960 --> 00:06:12,800
to a schema if you will and when we're

00:06:11,030 --> 00:06:15,410
creating directives it won't always be

00:06:12,800 --> 00:06:17,419
the case that every part of our schema

00:06:15,410 --> 00:06:20,480
should be affected or potentially

00:06:17,419 --> 00:06:22,280
affected by a directive so what we get

00:06:20,480 --> 00:06:25,070
is this schema directive visitor class

00:06:22,280 --> 00:06:27,169
that has ways that we can visit various

00:06:25,070 --> 00:06:29,870
parts of the schema and the two that I

00:06:27,169 --> 00:06:31,190
would say you'll probably use most often

00:06:29,870 --> 00:06:34,280
if you're implementing custom directives

00:06:31,190 --> 00:06:36,350
would be visit the field definition so

00:06:34,280 --> 00:06:38,930
how the field is actually defined or

00:06:36,350 --> 00:06:41,060
visit the object those are kind of the

00:06:38,930 --> 00:06:41,420
two that are most used but we've got a

00:06:41,060 --> 00:06:43,040
whole

00:06:41,420 --> 00:06:45,770
some others you know visit the scaler

00:06:43,040 --> 00:06:48,980
visit Ino anything else that goes into a

00:06:45,770 --> 00:06:51,880
schema to construct it you can visit it

00:06:48,980 --> 00:06:54,830
with the schema directive visitor class

00:06:51,880 --> 00:06:57,950
alright so let's think about this what

00:06:54,830 --> 00:06:59,540
are we gonna do if we want to take this

00:06:57,950 --> 00:07:01,700
data output that we would normally get

00:06:59,540 --> 00:07:03,110
just a hello world string and we wanted

00:07:01,700 --> 00:07:06,650
to turn it in see you hello graphs

00:07:03,110 --> 00:07:08,750
you'll summit instead well here is our

00:07:06,650 --> 00:07:10,280
very tiny graph key all set up that

00:07:08,750 --> 00:07:12,530
would help us to accomplish that first

00:07:10,280 --> 00:07:15,800
screen let's get our tie our query type

00:07:12,530 --> 00:07:17,600
with hello the string type and then

00:07:15,800 --> 00:07:19,970
we're resolving just a simple string

00:07:17,600 --> 00:07:23,150
rate right away out of it what we would

00:07:19,970 --> 00:07:26,510
do if we wanted to say have this

00:07:23,150 --> 00:07:29,030
directive called replace is we would

00:07:26,510 --> 00:07:31,760
first to tell graph QL about it so

00:07:29,030 --> 00:07:34,310
within our type definition here just

00:07:31,760 --> 00:07:36,470
right above our query type we would

00:07:34,310 --> 00:07:38,090
first want to say okay graph QL we want

00:07:36,470 --> 00:07:40,340
this directive I want to declare this

00:07:38,090 --> 00:07:41,990
directive called replace it's a couple

00:07:40,340 --> 00:07:43,430
parts of this I want to declare this

00:07:41,990 --> 00:07:46,790
directive call it replace that's what I

00:07:43,430 --> 00:07:48,920
want to name it replace should take in

00:07:46,790 --> 00:07:51,770
arguments and it should be keyed by the

00:07:48,920 --> 00:07:53,150
name replacement type string and where

00:07:51,770 --> 00:07:55,190
we want that to operate is that the

00:07:53,150 --> 00:07:57,500
field definition level so remember

00:07:55,190 --> 00:08:00,530
there's many different places within our

00:07:57,500 --> 00:08:03,200
schema that we can visit but we probably

00:08:00,530 --> 00:08:04,820
want to limit it to only the places that

00:08:03,200 --> 00:08:06,920
we actually want to use the directive

00:08:04,820 --> 00:08:10,070
ultimately and in this case that's at

00:08:06,920 --> 00:08:12,560
the field definition level so then what

00:08:10,070 --> 00:08:14,690
happens is we can use that directive

00:08:12,560 --> 00:08:17,390
again just putting it beside the field

00:08:14,690 --> 00:08:19,400
we can call our replace and pass in our

00:08:17,390 --> 00:08:23,720
replacement string and what do we get

00:08:19,400 --> 00:08:25,460
out of it now actually before we go

00:08:23,720 --> 00:08:28,580
there I'll just go to the actual

00:08:25,460 --> 00:08:30,470
implementation of the schema directive

00:08:28,580 --> 00:08:32,330
visitor class it's the kind of last

00:08:30,470 --> 00:08:34,910
piece that we need and it's kind of the

00:08:32,330 --> 00:08:36,920
crux of it what we need to do is create

00:08:34,910 --> 00:08:39,350
we need to subclass schema directive

00:08:36,920 --> 00:08:41,030
visitor and if we want to visit the

00:08:39,350 --> 00:08:43,729
field definition level well we would

00:08:41,030 --> 00:08:46,100
call that method and we would provide

00:08:43,729 --> 00:08:48,740
something other than what we would

00:08:46,100 --> 00:08:50,930
normally get out of this field so how do

00:08:48,740 --> 00:08:52,440
we do that well we can call for the

00:08:50,930 --> 00:08:54,600
argument that we pass in

00:08:52,440 --> 00:08:56,940
remember at replace we pass in a

00:08:54,600 --> 00:08:59,190
replacement string and then all we have

00:08:56,940 --> 00:09:01,920
to do is call field field to dot resolve

00:08:59,190 --> 00:09:03,420
give it a new function to resolve with

00:09:01,920 --> 00:09:06,090
something else and what we're gonna

00:09:03,420 --> 00:09:08,130
resolve with is the replacement string

00:09:06,090 --> 00:09:10,410
that was passed in so we've got our

00:09:08,130 --> 00:09:12,180
target field definition we've got the

00:09:10,410 --> 00:09:14,790
argument that was passed in and that

00:09:12,180 --> 00:09:17,850
we've got a new resolver to use if we're

00:09:14,790 --> 00:09:19,890
gonna be calling this directive and then

00:09:17,850 --> 00:09:22,410
to make this all kind of tie together we

00:09:19,890 --> 00:09:23,940
have to tell Apollo about it so make

00:09:22,410 --> 00:09:26,640
executable schema if you're using that

00:09:23,940 --> 00:09:28,980
you would pass in schema directives and

00:09:26,640 --> 00:09:33,780
you would tell it about which directives

00:09:28,980 --> 00:09:36,000
you've got all right so at the end of

00:09:33,780 --> 00:09:39,230
all that what we get out of it is the

00:09:36,000 --> 00:09:42,720
hello graph QL Sumit's string so again

00:09:39,230 --> 00:09:45,480
thinking back to our initial setup what

00:09:42,720 --> 00:09:47,400
we've got with our resolver here this is

00:09:45,480 --> 00:09:49,650
the initial behavior hello gives us

00:09:47,400 --> 00:09:51,990
hello world but as soon as we tack on

00:09:49,650 --> 00:09:53,880
the at replace directive we're going to

00:09:51,990 --> 00:09:57,000
get some different behavior at runtime

00:09:53,880 --> 00:09:58,860
even though our initial schema was

00:09:57,000 --> 00:10:01,620
initial resolver was defined in a

00:09:58,860 --> 00:10:04,920
different way all right so a cool

00:10:01,620 --> 00:10:06,900
feature of course of directives is that

00:10:04,920 --> 00:10:08,670
they can be async so we have our

00:10:06,900 --> 00:10:10,560
resolvers that are fully capable of

00:10:08,670 --> 00:10:13,170
handing a fully capable of handling

00:10:10,560 --> 00:10:15,240
async so let's say we've got this

00:10:13,170 --> 00:10:16,650
situation not sure if this would you

00:10:15,240 --> 00:10:18,450
know be a typical situation that you

00:10:16,650 --> 00:10:21,360
would want to be getting a list of

00:10:18,450 --> 00:10:23,370
github users but maybe you do and you

00:10:21,360 --> 00:10:25,710
might have the ID the login the avatar

00:10:23,370 --> 00:10:29,730
URL and your query is to just call for

00:10:25,710 --> 00:10:32,460
users so what if we wanted to make this

00:10:29,730 --> 00:10:34,800
make the call to github not using their

00:10:32,460 --> 00:10:37,050
graph QL implementation just using their

00:10:34,800 --> 00:10:40,290
REST API what if we wanted to make a

00:10:37,050 --> 00:10:43,110
call to github using kind of graph QL

00:10:40,290 --> 00:10:45,180
style on our end well what we could do

00:10:43,110 --> 00:10:47,760
is maybe define something called a rest

00:10:45,180 --> 00:10:51,089
directive and a rest directive would

00:10:47,760 --> 00:10:52,830
give us this at rest symbol to use the

00:10:51,089 --> 00:10:54,780
implementation of the directive itself

00:10:52,830 --> 00:10:57,630
would look a little bit like this again

00:10:54,780 --> 00:10:59,820
we want to visit the field definition

00:10:57,630 --> 00:11:02,790
and maybe we want to pass in something

00:10:59,820 --> 00:11:04,560
like a method and a URL so a URL might

00:11:02,790 --> 00:11:07,020
be the location of the github API

00:11:04,560 --> 00:11:09,930
to make a call - and the method you know

00:11:07,020 --> 00:11:11,700
we could passing like get and then we

00:11:09,930 --> 00:11:13,860
would just use an async function this

00:11:11,700 --> 00:11:15,960
time so field dot result becomes an

00:11:13,860 --> 00:11:18,390
async function I'm using Axios in this

00:11:15,960 --> 00:11:20,100
case passing in our URL and our method

00:11:18,390 --> 00:11:23,490
and then just returning the data

00:11:20,100 --> 00:11:24,779
now this isn't fully kind of fleshed out

00:11:23,490 --> 00:11:26,730
there would be a lot more detail that

00:11:24,779 --> 00:11:28,860
you would probably want to handle here

00:11:26,730 --> 00:11:30,870
you know how do you handle errors how do

00:11:28,860 --> 00:11:32,550
you handle when there's no data that

00:11:30,870 --> 00:11:34,710
comes back you don't want to be thinking

00:11:32,550 --> 00:11:37,890
about these things things like caching

00:11:34,710 --> 00:11:39,930
but really simple implementation just

00:11:37,890 --> 00:11:41,850
you know for the sake of simplicity how

00:11:39,930 --> 00:11:43,560
you would make a call that's you know

00:11:41,850 --> 00:11:47,250
pretty straightforward it's just async

00:11:43,560 --> 00:11:49,529
await here so then we do the rest of the

00:11:47,250 --> 00:11:51,000
work that we've got to do we say we've

00:11:49,529 --> 00:11:53,430
got this directive it's called the rest

00:11:51,000 --> 00:11:55,380
takes two arguments method and URL and

00:11:53,430 --> 00:11:57,270
again it operates on the field

00:11:55,380 --> 00:12:02,070
definition level that's where we want to

00:11:57,270 --> 00:12:05,490
use it so our users field now can take

00:12:02,070 --> 00:12:08,700
this directive we just call at rest give

00:12:05,490 --> 00:12:11,160
it the method give it the URL and just

00:12:08,700 --> 00:12:14,310
like that we've got a list of users

00:12:11,160 --> 00:12:16,710
coming back from github is API so this

00:12:14,310 --> 00:12:19,470
can be a cool way to start to transition

00:12:16,710 --> 00:12:22,470
perhaps from a REST API towards graph QL

00:12:19,470 --> 00:12:24,420
maybe you want to scaffold your graph QL

00:12:22,470 --> 00:12:27,420
implementation but maybe you're not

00:12:24,420 --> 00:12:29,700
fully ready to turn over from your rest

00:12:27,420 --> 00:12:32,610
implementation and so what you can do is

00:12:29,700 --> 00:12:34,980
you can start to describe the schema

00:12:32,610 --> 00:12:37,320
that you're going to have using graph QL

00:12:34,980 --> 00:12:41,390
and you can make a rest call and have a

00:12:37,320 --> 00:12:45,089
very simple way to tie in to that okay

00:12:41,390 --> 00:12:47,490
getting to the way to use directives

00:12:45,089 --> 00:12:51,690
that I really like is to do

00:12:47,490 --> 00:12:55,860
authorization related tasks so what you

00:12:51,690 --> 00:12:57,510
get when you are using the resolver when

00:12:55,860 --> 00:12:59,670
you're defining a new resolver is you

00:12:57,510 --> 00:13:02,220
get the context so thinking about

00:12:59,670 --> 00:13:04,260
resolvers as you typically would we get

00:13:02,220 --> 00:13:06,959
you know information about them we get

00:13:04,260 --> 00:13:09,900
the context we get arguments we get

00:13:06,959 --> 00:13:11,990
information and these are all pieces

00:13:09,900 --> 00:13:14,959
that are useful for various things

00:13:11,990 --> 00:13:18,089
context talks about the request itself

00:13:14,959 --> 00:13:19,649
it talks about things that might be

00:13:18,089 --> 00:13:22,920
that request any headers that might

00:13:19,649 --> 00:13:24,839
exist on it any other information about

00:13:22,920 --> 00:13:27,059
kind of the requests that you might want

00:13:24,839 --> 00:13:30,540
to go for so wouldn't it be cool if we

00:13:27,059 --> 00:13:32,970
could use that to have a directive that

00:13:30,540 --> 00:13:34,470
checks for authorization information and

00:13:32,970 --> 00:13:36,480
so there are many different ways that

00:13:34,470 --> 00:13:39,420
you can handle authentication that you

00:13:36,480 --> 00:13:40,709
can handle authorization depending on

00:13:39,420 --> 00:13:42,600
your setup it might look a bit different

00:13:40,709 --> 00:13:45,899
and what I'm gonna show you but the

00:13:42,600 --> 00:13:47,699
ideas I think will carry over so I'm

00:13:45,899 --> 00:13:49,470
gonna show you a kind of a way that you

00:13:47,699 --> 00:13:51,629
might do this using JSON web tokens

00:13:49,470 --> 00:13:54,300
anybody using JSON web tokens for their

00:13:51,629 --> 00:13:56,490
API all right very cool

00:13:54,300 --> 00:13:58,439
anybody like definitely using cookies

00:13:56,490 --> 00:14:01,040
and sessions and sticking to that not

00:13:58,439 --> 00:14:05,910
touching JSON web tokens just curious

00:14:01,040 --> 00:14:09,540
yeah one guy here excellent so Jason web

00:14:05,910 --> 00:14:10,800
tokens very popular I kind of I don't

00:14:09,540 --> 00:14:12,959
advocate for one over the other

00:14:10,800 --> 00:14:14,639
necessarily I like JSON web tokens I

00:14:12,959 --> 00:14:16,410
usually use them but cookies and

00:14:14,639 --> 00:14:19,740
sessions perfectly valid way to do it as

00:14:16,410 --> 00:14:22,199
well so what if we could get that token

00:14:19,740 --> 00:14:25,019
on an incoming request and use the

00:14:22,199 --> 00:14:27,149
information in it to drive the decision

00:14:25,019 --> 00:14:30,029
as to whether or not the user has access

00:14:27,149 --> 00:14:32,009
and what that might look like when it

00:14:30,029 --> 00:14:34,290
comes time to implement it is something

00:14:32,009 --> 00:14:37,019
like this we could have a directive cult

00:14:34,290 --> 00:14:38,999
has scoped and the idea here is that we

00:14:37,019 --> 00:14:41,699
want to look for a particular scope

00:14:38,999 --> 00:14:43,170
that's that the user would have and this

00:14:41,699 --> 00:14:45,809
doesn't have to be scoped necessarily

00:14:43,170 --> 00:14:47,699
you might want to have this be role for

00:14:45,809 --> 00:14:50,220
example if you have like just role based

00:14:47,699 --> 00:14:52,170
access control you can say the user has

00:14:50,220 --> 00:14:53,730
to be an adman they've got to be a

00:14:52,170 --> 00:14:55,889
manager or whatever the case might be

00:14:53,730 --> 00:14:57,420
but scopes are an interesting way to

00:14:55,889 --> 00:14:59,550
handle access control because you can

00:14:57,420 --> 00:15:01,860
get pretty fine-grained you can start to

00:14:59,550 --> 00:15:04,199
say things like the user has to be able

00:15:01,860 --> 00:15:05,459
to read users as the resource in this

00:15:04,199 --> 00:15:08,939
case or they have to be able to write

00:15:05,459 --> 00:15:11,639
users to get access here that that's the

00:15:08,939 --> 00:15:14,339
idea behind scopes so what would that

00:15:11,639 --> 00:15:15,870
look like if we go to implement it well

00:15:14,339 --> 00:15:18,389
again we need to visit the field

00:15:15,870 --> 00:15:21,089
definition and we want to take the scope

00:15:18,389 --> 00:15:23,220
that comes in as the arguments and this

00:15:21,089 --> 00:15:25,529
time we have to do some extra work of

00:15:23,220 --> 00:15:27,929
course because checking authentication

00:15:25,529 --> 00:15:29,610
authorization it's you know it's more

00:15:27,929 --> 00:15:31,209
involved than just like you know

00:15:29,610 --> 00:15:33,399
resolving with something

00:15:31,209 --> 00:15:36,579
so the first thing I'm note though is

00:15:33,399 --> 00:15:38,199
that we can get the token if it's coming

00:15:36,579 --> 00:15:40,359
through on the authorization header

00:15:38,199 --> 00:15:42,160
which often it does that's where you

00:15:40,359 --> 00:15:43,809
would put it in your request from the

00:15:42,160 --> 00:15:46,329
client you would stick a JSON web token

00:15:43,809 --> 00:15:47,229
on an authorization header you can get

00:15:46,329 --> 00:15:48,759
that from the contest

00:15:47,229 --> 00:15:50,559
so just contacts headers Don

00:15:48,759 --> 00:15:52,539
authorization we're doing some work

00:15:50,559 --> 00:15:54,069
saying like if there's no token at all

00:15:52,539 --> 00:15:55,869
just error out right away because we

00:15:54,069 --> 00:15:59,049
can't make a determination about the

00:15:55,869 --> 00:16:00,850
authentication state but if the user has

00:15:59,049 --> 00:16:02,439
the particular scope that's what we're

00:16:00,850 --> 00:16:04,269
doing here and this user has scope

00:16:02,439 --> 00:16:06,489
function if they have the scope that

00:16:04,269 --> 00:16:09,519
we're looking for then we're just going

00:16:06,489 --> 00:16:11,169
to wrap the resolver basically pass

00:16:09,519 --> 00:16:13,929
through to this context and that's gonna

00:16:11,169 --> 00:16:16,269
send back what the user was trying to

00:16:13,929 --> 00:16:19,149
get at if not they don't have that scope

00:16:16,269 --> 00:16:21,249
we just send back not authorized so

00:16:19,149 --> 00:16:21,850
what's happening in the user has scope

00:16:21,249 --> 00:16:24,669
function

00:16:21,850 --> 00:16:26,499
who knows I that's up to you that that

00:16:24,669 --> 00:16:28,839
yeah it's probably going to involve

00:16:26,499 --> 00:16:31,119
verifying the JSON web token it's

00:16:28,839 --> 00:16:33,220
probably going to involve reading the

00:16:31,119 --> 00:16:34,869
payload from it you know doing some

00:16:33,220 --> 00:16:36,759
checks to make sure they have the the

00:16:34,869 --> 00:16:38,619
appropriate scope but if all that pass

00:16:36,759 --> 00:16:41,559
is then we can just send through the

00:16:38,619 --> 00:16:44,169
data and the cool thing about this is

00:16:41,559 --> 00:16:46,709
that you can start to mark off

00:16:44,169 --> 00:16:49,209
particular fields that require certain

00:16:46,709 --> 00:16:52,269
authentication and authorization info so

00:16:49,209 --> 00:16:54,609
one of your fields might require read

00:16:52,269 --> 00:16:56,470
access one of them might require some

00:16:54,609 --> 00:16:59,439
other kind of access depending on how

00:16:56,470 --> 00:17:02,589
you're doing you're all set up and if a

00:16:59,439 --> 00:17:04,480
user makes a query for multiple fields

00:17:02,589 --> 00:17:05,889
but they only have access to one they'll

00:17:04,480 --> 00:17:08,500
get back an error but they'll still get

00:17:05,889 --> 00:17:11,980
back the data for the thing that they

00:17:08,500 --> 00:17:13,809
are able to access so there's there's

00:17:11,980 --> 00:17:15,339
ways that you there are things you would

00:17:13,809 --> 00:17:17,110
have to do in your application to

00:17:15,339 --> 00:17:20,709
account for that and to handle various

00:17:17,110 --> 00:17:22,269
kind of states if you will of users

00:17:20,709 --> 00:17:24,129
being able to access some things and not

00:17:22,269 --> 00:17:26,409
other things but it gives us this cool

00:17:24,129 --> 00:17:30,879
way of being able to very descriptively

00:17:26,409 --> 00:17:32,620
say what users need to have in terms of

00:17:30,879 --> 00:17:34,600
access control to be able to get at

00:17:32,620 --> 00:17:36,340
certain things and the reason I really

00:17:34,600 --> 00:17:38,289
like this is it becomes very readable so

00:17:36,340 --> 00:17:39,820
it becomes easy to look at your schema

00:17:38,289 --> 00:17:41,289
especially if you're working in big

00:17:39,820 --> 00:17:43,570
teams to look at your schema and say

00:17:41,289 --> 00:17:45,820
okay this is what

00:17:43,570 --> 00:17:48,070
this is what is required to get at this

00:17:45,820 --> 00:17:50,080
resource this is what it is required to

00:17:48,070 --> 00:17:52,899
get at this resource and it's a it's a

00:17:50,080 --> 00:17:54,159
very readable it creates a very readable

00:17:52,899 --> 00:17:57,279
schema

00:17:54,159 --> 00:17:59,500
all right so that being said schema

00:17:57,279 --> 00:18:01,720
directives aren't the only option to

00:17:59,500 --> 00:18:05,139
solve these problems especially when it

00:18:01,720 --> 00:18:08,139
comes to access control to authorization

00:18:05,139 --> 00:18:11,159
they they aren't the only way to do it

00:18:08,139 --> 00:18:14,350
and some people don't like coupling

00:18:11,159 --> 00:18:16,779
coupling logic if you will directly to

00:18:14,350 --> 00:18:19,990
their schema another popular option is

00:18:16,779 --> 00:18:21,309
to use middlewares so there is this

00:18:19,990 --> 00:18:23,980
package called graph Tyrell middleware

00:18:21,309 --> 00:18:26,139
and this is a useful tool if you want to

00:18:23,980 --> 00:18:27,820
if you want to take the logic out of

00:18:26,139 --> 00:18:29,769
your schema definition and have it be

00:18:27,820 --> 00:18:34,419
separate and kind of what it looks like

00:18:29,769 --> 00:18:36,519
is this you would have you know some

00:18:34,419 --> 00:18:39,129
kind of like is logged in function that

00:18:36,519 --> 00:18:42,340
can do some checks for you and then you

00:18:39,129 --> 00:18:44,379
just tie you tie your middleware to

00:18:42,340 --> 00:18:48,009
various parts of your query and then you

00:18:44,379 --> 00:18:51,250
pass it in to your to your schema at the

00:18:48,009 --> 00:18:54,059
end by applying in middleware so this

00:18:51,250 --> 00:18:56,860
kind of removes this tight coupling of

00:18:54,059 --> 00:18:58,889
logic to your schema and lets you

00:18:56,860 --> 00:19:01,120
achieve the same thing somewhere else

00:18:58,889 --> 00:19:02,830
and some people like doing it this way

00:19:01,120 --> 00:19:04,570
some people don't mind having it tied

00:19:02,830 --> 00:19:05,980
directly to their schema but this is

00:19:04,570 --> 00:19:10,240
another option this might work better

00:19:05,980 --> 00:19:12,399
for your situation all right so that is

00:19:10,240 --> 00:19:14,740
actually about it the slides are

00:19:12,399 --> 00:19:17,039
available at this link if you are

00:19:14,740 --> 00:19:19,179
interested one thing I would say is

00:19:17,039 --> 00:19:22,090
experiments with schema directives

00:19:19,179 --> 00:19:25,179
there's you know a much easier way to do

00:19:22,090 --> 00:19:27,610
it now with graphical tools it's if you

00:19:25,179 --> 00:19:29,440
tried to approach it previously and

00:19:27,610 --> 00:19:31,629
we're kind of a bit put off because it

00:19:29,440 --> 00:19:33,940
was difficult it's much easier to do now

00:19:31,629 --> 00:19:35,620
and get creative there's lots of

00:19:33,940 --> 00:19:36,850
different use cases for them there's

00:19:35,620 --> 00:19:39,370
lots of different things you can solve

00:19:36,850 --> 00:19:41,379
and go nuts if you want to find me on

00:19:39,370 --> 00:19:43,750
Twitter I am at Ryan chengqi there

00:19:41,379 --> 00:19:46,920
thanks so much your time and we will see

00:19:43,750 --> 00:19:49,960
you around the conference tomorrow

00:19:46,920 --> 00:19:52,640
[Music]

00:19:49,960 --> 00:19:52,640

YouTube URL: https://www.youtube.com/watch?v=Gc8bSXX7oyU


