Title: Building Type-Safe GraphQL Servers (Johannes Schickling)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 8, 2018

Johannes Schickling, co-founder & CEO of Prisma, explores why building applications in a type-safe way is the gold standard for application development. It comes at the cost of writing lots of boilerplate and, for GraphQL, keeping data structures in sync with the strongly typed GraphQL schema. This talk discusses the tools and best practices for building end-to-end type-safe applications with GraphQL, touching on topics like schema-based code generation, type-safe resolvers, Apollo Data Sources, strongly typed database access and more.

Learn more:  https://summit.graphql.com
Captions: 
	00:00:05,390 --> 00:00:11,129
everybody it's great to be back today I

00:00:08,460 --> 00:00:13,259
want to talk about graph KL servers but

00:00:11,129 --> 00:00:17,009
specifically about talk a building

00:00:13,259 --> 00:00:20,310
typesafe graphical servers so the agenda

00:00:17,009 --> 00:00:22,590
is first I want to talk a little bit why

00:00:20,310 --> 00:00:25,140
graphic white type safety matters and

00:00:22,590 --> 00:00:27,330
specifically why type safety matters for

00:00:25,140 --> 00:00:30,510
building schema first graph KL servers

00:00:27,330 --> 00:00:32,970
will look into a tool called graphic

00:00:30,510 --> 00:00:35,220
Elgin which allows you to build type

00:00:32,970 --> 00:00:38,089
safe graphical servers and we also see

00:00:35,220 --> 00:00:40,710
that in action in a live demo and

00:00:38,089 --> 00:00:43,920
afterwards we also see the benefits of

00:00:40,710 --> 00:00:46,440
type safe database access what you what

00:00:43,920 --> 00:00:47,940
you can do with Prisma so my name is

00:00:46,440 --> 00:00:50,760
Johanna chuckling I'm the founder and

00:00:47,940 --> 00:00:52,650
CEO at Prisma where we're building tools

00:00:50,760 --> 00:00:54,510
around databases and the data layer for

00:00:52,650 --> 00:00:56,699
modern applications if you want to

00:00:54,510 --> 00:01:00,299
follow me on Twitter you can see the

00:00:56,699 --> 00:01:02,400
handles on the slides at prismo we are

00:01:00,299 --> 00:01:05,610
building the Prisma client which is an

00:01:02,400 --> 00:01:08,520
auto-generated type safe client library

00:01:05,610 --> 00:01:11,850
for your database which you can think

00:01:08,520 --> 00:01:16,380
about like as a replacement for RMS

00:01:11,850 --> 00:01:19,200
which scale we're building prismo my

00:01:16,380 --> 00:01:22,770
grade which is the declarative migration

00:01:19,200 --> 00:01:24,840
tools and also Prisma admin which you

00:01:22,770 --> 00:01:29,520
can think about like as a modern version

00:01:24,840 --> 00:01:30,540
of PHP madman so let's get to the meat

00:01:29,520 --> 00:01:35,000
of this talk

00:01:30,540 --> 00:01:38,250
why type safety for graphical servers so

00:01:35,000 --> 00:01:40,200
generally why type safety matters is I

00:01:38,250 --> 00:01:44,220
think type safety is one of the most

00:01:40,200 --> 00:01:46,980
underappreciated tools in in the tool

00:01:44,220 --> 00:01:48,570
belt of a modern web developer and I

00:01:46,980 --> 00:01:51,150
think it's just seeing like a bit of a

00:01:48,570 --> 00:01:53,040
renaissance right now and the big

00:01:51,150 --> 00:01:55,490
benefits you get with type safety is

00:01:53,040 --> 00:01:57,659
like that you can catch arrows at

00:01:55,490 --> 00:02:00,750
development or build time instead of

00:01:57,659 --> 00:02:03,960
causing instead of detecting them in

00:02:00,750 --> 00:02:06,510
production and causing downtime so this

00:02:03,960 --> 00:02:07,890
way if you're following a if you're

00:02:06,510 --> 00:02:10,769
using type safety in your development

00:02:07,890 --> 00:02:14,430
you can move fast build and ship

00:02:10,769 --> 00:02:16,380
features fast with confidence with was

00:02:14,430 --> 00:02:19,050
feeling good about not breaking stuff

00:02:16,380 --> 00:02:22,080
it also if you just care about a better

00:02:19,050 --> 00:02:25,140
developer experience type safety enable

00:02:22,080 --> 00:02:27,530
set type safety gives you auto

00:02:25,140 --> 00:02:30,750
completion especially with vias code

00:02:27,530 --> 00:02:33,540
makes it so nice nicely integrated and

00:02:30,750 --> 00:02:35,490
for the JavaScript developers to amongst

00:02:33,540 --> 00:02:38,160
us and this is what my talk will also

00:02:35,490 --> 00:02:40,140
focus on today I would go as far as

00:02:38,160 --> 00:02:43,350
saying like that typescript is really

00:02:40,140 --> 00:02:44,850
becoming the new default both for API is

00:02:43,350 --> 00:02:46,770
that you're building projects that

00:02:44,850 --> 00:02:49,410
you're doing but also for new libraries

00:02:46,770 --> 00:02:51,900
I think every tool of Apollo is for

00:02:49,410 --> 00:02:55,260
example also in typescript so if you've

00:02:51,900 --> 00:02:57,480
kind of still have like a bad feeling

00:02:55,260 --> 00:02:59,400
about like maybe fuse Java in the past

00:02:57,480 --> 00:03:02,580
and you remember all of this huge

00:02:59,400 --> 00:03:05,880
boilerplate or if you've used flow for

00:03:02,580 --> 00:03:07,350
react but that didn't really was wasn't

00:03:05,880 --> 00:03:08,910
really quite worth it for you I would

00:03:07,350 --> 00:03:11,700
really encourage you to check out

00:03:08,910 --> 00:03:13,590
typescript because it kind of gives you

00:03:11,700 --> 00:03:17,520
the best of all worlds and has just such

00:03:13,590 --> 00:03:20,400
a fantastic ecosystem so that's a

00:03:17,520 --> 00:03:22,130
general page for type safety in

00:03:20,400 --> 00:03:25,290
typescript which will look into today

00:03:22,130 --> 00:03:28,170
but let's talk about graphical servers

00:03:25,290 --> 00:03:30,000
so generally there are two ways of

00:03:28,170 --> 00:03:32,310
building graphical servers and I think

00:03:30,000 --> 00:03:35,070
in this conference we've already seen a

00:03:32,310 --> 00:03:37,410
couple of these so there's the resolver

00:03:35,070 --> 00:03:40,320
first approach and then there is the

00:03:37,410 --> 00:03:42,650
schema first approach and will now look

00:03:40,320 --> 00:03:46,020
into both of these approaches and see

00:03:42,650 --> 00:03:48,600
what the differences are so the resolve

00:03:46,020 --> 00:03:51,060
first approach for example which is used

00:03:48,600 --> 00:03:53,490
by graphical Ruby or if you're building

00:03:51,060 --> 00:03:56,130
a graphical server in scala with sangria

00:03:53,490 --> 00:03:58,770
or with graphene and python that's using

00:03:56,130 --> 00:04:01,920
the resolve of first approach and the

00:03:58,770 --> 00:04:04,080
idea here is that you basically define

00:04:01,920 --> 00:04:07,350
your entire graphical schema just in

00:04:04,080 --> 00:04:10,470
your own code like in Ruby or Scala and

00:04:07,350 --> 00:04:12,390
based on this code that you're how are

00:04:10,470 --> 00:04:15,570
you generating are you sorry how you're

00:04:12,390 --> 00:04:17,790
defining your resolvers that actually

00:04:15,570 --> 00:04:20,880
you derive the graphical schema from

00:04:17,790 --> 00:04:23,540
that Python introspection so the your

00:04:20,880 --> 00:04:26,910
resolver code is the source of truth the

00:04:23,540 --> 00:04:29,380
alternative to that which is the schema

00:04:26,910 --> 00:04:31,720
first approach turns it the other way

00:04:29,380 --> 00:04:33,820
around and you're riding first your

00:04:31,720 --> 00:04:36,790
graphical schema definition using

00:04:33,820 --> 00:04:39,730
graphical STL and you use that kind of

00:04:36,790 --> 00:04:42,850
like as your contract to now implement

00:04:39,730 --> 00:04:45,280
your resolvers and this approach is very

00:04:42,850 --> 00:04:48,490
very prominent in the JavaScript

00:04:45,280 --> 00:04:51,280
ecosystem but also and go for it for

00:04:48,490 --> 00:04:53,550
example with GTL gen and this is the

00:04:51,280 --> 00:04:56,950
dista approach I want to focus on today

00:04:53,550 --> 00:04:59,530
since I think most of us here have used

00:04:56,950 --> 00:05:00,340
this approach and I think it's a it's a

00:04:59,530 --> 00:05:03,400
great approach

00:05:00,340 --> 00:05:05,680
it just has also brings a couple of

00:05:03,400 --> 00:05:08,170
problems with them and this is what I

00:05:05,680 --> 00:05:10,750
would like to talk about so I actually

00:05:08,170 --> 00:05:12,670
curious who view like has build a

00:05:10,750 --> 00:05:16,630
graphical server with a schema first

00:05:12,670 --> 00:05:18,790
approach okay great so I'm pretty sure

00:05:16,630 --> 00:05:21,010
that a lot of you have run into some of

00:05:18,790 --> 00:05:25,480
these problems that I'll show you in a

00:05:21,010 --> 00:05:29,140
second so here is a relatively simple

00:05:25,480 --> 00:05:32,320
graphical server so on the Left we see a

00:05:29,140 --> 00:05:34,660
the schema definition in graphical STL

00:05:32,320 --> 00:05:37,140
and on the right we see the the resolver

00:05:34,660 --> 00:05:39,010
implementations it's a super simple

00:05:37,140 --> 00:05:42,370
application we basically just have a

00:05:39,010 --> 00:05:45,010
user type here and you can query for who

00:05:42,370 --> 00:05:46,960
are your authentic ated user and you we

00:05:45,010 --> 00:05:50,650
have a login mutation and a sign of

00:05:46,960 --> 00:05:52,690
mutation so and in the implementations

00:05:50,650 --> 00:05:55,420
fairly straightforward just assume that

00:05:52,690 --> 00:05:56,890
the functions that are used here that

00:05:55,420 --> 00:06:00,820
they actually do what they are supposed

00:05:56,890 --> 00:06:02,680
to do but there is a catch in this

00:06:00,820 --> 00:06:07,090
little code snippet here they're

00:06:02,680 --> 00:06:09,070
actually four bucks building so and all

00:06:07,090 --> 00:06:12,430
of these bucks could have been caught by

00:06:09,070 --> 00:06:14,800
better tooling so I want to use a couple

00:06:12,430 --> 00:06:17,260
of seconds to just like maybe yeah give

00:06:14,800 --> 00:06:20,710
you a couple of seconds to see whether

00:06:17,260 --> 00:06:25,440
you see at least two arrows and if you

00:06:20,710 --> 00:06:28,210
do raise your hand all right

00:06:25,440 --> 00:06:30,250
imagine now that's your job on a daily

00:06:28,210 --> 00:06:32,260
basis and I'm pretty sure that you've

00:06:30,250 --> 00:06:35,290
all like spent a lot of time like

00:06:32,260 --> 00:06:37,570
looking for looking for our bug or then

00:06:35,290 --> 00:06:39,729
you just like fine you just like run

00:06:37,570 --> 00:06:42,040
into this in production and I think we

00:06:39,729 --> 00:06:42,730
can all save a lot of time if we have

00:06:42,040 --> 00:06:45,850
better to

00:06:42,730 --> 00:06:49,150
that so that helps us solving these

00:06:45,850 --> 00:06:50,620
problems so let's take a look at some of

00:06:49,150 --> 00:06:52,660
these problems that we have in here

00:06:50,620 --> 00:06:55,330
since some of them are felt more obvious

00:06:52,660 --> 00:06:59,680
some of them are fairly subtle so first

00:06:55,330 --> 00:07:02,770
one is here for the log of mutation the

00:06:59,680 --> 00:07:05,110
mutation now STL actually wraps the

00:07:02,770 --> 00:07:07,720
input arguments in an input object here

00:07:05,110 --> 00:07:10,990
in our implementation we're using the

00:07:07,720 --> 00:07:13,000
arts that username directly so the late

00:07:10,990 --> 00:07:14,410
as as soon as you've would have run the

00:07:13,000 --> 00:07:16,240
login mutation you would have caught

00:07:14,410 --> 00:07:18,150
that but still would have been nice if

00:07:16,240 --> 00:07:22,060
stooling would have helped us here

00:07:18,150 --> 00:07:24,070
another even more obvious error is we

00:07:22,060 --> 00:07:24,910
forgot to implement the signup mutation

00:07:24,070 --> 00:07:27,910
in the first place

00:07:24,910 --> 00:07:31,510
again if we want to try it then we would

00:07:27,910 --> 00:07:34,630
have caught us but here too a lot more

00:07:31,510 --> 00:07:38,260
subtle mistakes so if we look here at

00:07:34,630 --> 00:07:43,020
the profile picture your L which returns

00:07:38,260 --> 00:07:45,790
a string and like a non malleable string

00:07:43,020 --> 00:07:48,700
then and we're comparing this to our

00:07:45,790 --> 00:07:50,500
actual implementation if we say here on

00:07:48,700 --> 00:07:52,810
the in the data if we don't have the

00:07:50,500 --> 00:07:54,970
picture ID then just return null we

00:07:52,810 --> 00:07:57,040
would probably not have a test for that

00:07:54,970 --> 00:08:00,160
and it would just like pop up in

00:07:57,040 --> 00:08:03,190
production edge case and blow up if you

00:08:00,160 --> 00:08:05,650
would have a type save system that would

00:08:03,190 --> 00:08:07,540
tell us hey unit never allowed to return

00:08:05,650 --> 00:08:12,310
null here that would be a big benefit

00:08:07,540 --> 00:08:14,050
and here's the the last mistake I think

00:08:12,310 --> 00:08:16,990
that's the most subtle one but also the

00:08:14,050 --> 00:08:19,630
most dangerous one as we are kind of

00:08:16,990 --> 00:08:21,700
relying on like building graph building

00:08:19,630 --> 00:08:23,290
graphical servers in JavaScript we're

00:08:21,700 --> 00:08:26,530
kind of relying on this concept of a

00:08:23,290 --> 00:08:29,800
default resolver so the concept of a

00:08:26,530 --> 00:08:31,900
default resolver is basically in the

00:08:29,800 --> 00:08:34,510
most naive way of how you build a

00:08:31,900 --> 00:08:36,840
graphical server in in a schema first

00:08:34,510 --> 00:08:39,040
ways that you basically say for every

00:08:36,840 --> 00:08:41,320
field that you've defined in your

00:08:39,040 --> 00:08:43,120
graphical schema in your type you also

00:08:41,320 --> 00:08:45,580
need to implement a resolver function

00:08:43,120 --> 00:08:48,580
but that would mean we need to if a type

00:08:45,580 --> 00:08:50,340
has like 20 fields and all of them like

00:08:48,580 --> 00:08:53,380
scalar values we need to implement

00:08:50,340 --> 00:08:54,670
basically 20 identity functions and that

00:08:53,380 --> 00:08:56,530
doesn't really make it makes a lot of

00:08:54,670 --> 00:08:59,140
sense so

00:08:56,530 --> 00:09:02,230
what's the graph Kalenjin javascript

00:08:59,140 --> 00:09:06,280
basis does is that it says like hey if

00:09:02,230 --> 00:09:08,920
the data is a one-to-one mapping to to

00:09:06,280 --> 00:09:10,540
our graphical type definition then you

00:09:08,920 --> 00:09:13,570
don't need to implement it then we'll

00:09:10,540 --> 00:09:15,160
just work the problem is like if it's

00:09:13,570 --> 00:09:17,140
not a one-to-one mapping but we kind of

00:09:15,160 --> 00:09:19,300
think it is a one-to-one mapping then it

00:09:17,140 --> 00:09:21,640
just blows up in production and that's

00:09:19,300 --> 00:09:24,880
the case here so if you're looking back

00:09:21,640 --> 00:09:27,550
here into the query implementation where

00:09:24,880 --> 00:09:31,810
we return a user and the user is now

00:09:27,550 --> 00:09:35,620
passed in into the into the into the

00:09:31,810 --> 00:09:39,190
user resolvers here we're kind of

00:09:35,620 --> 00:09:41,680
assuming for ID username and name that

00:09:39,190 --> 00:09:44,650
there is a default resolver that is the

00:09:41,680 --> 00:09:47,500
case for ID and name but it's not the

00:09:44,650 --> 00:09:50,200
case for username here because the user

00:09:47,500 --> 00:09:52,690
name in our schema is camel case and our

00:09:50,200 --> 00:09:55,990
data for whatever reason is all

00:09:52,690 --> 00:09:58,510
lowercase so and that will just blow up

00:09:55,990 --> 00:10:01,750
in production I'm pretty sure a lot of

00:09:58,510 --> 00:10:03,640
you have like had a similar situation in

00:10:01,750 --> 00:10:05,230
the past and you've just like scratch

00:10:03,640 --> 00:10:07,630
your head what what's what's going on

00:10:05,230 --> 00:10:09,850
and all of these problems that we've

00:10:07,630 --> 00:10:13,030
seen can be solved through better

00:10:09,850 --> 00:10:16,030
tooling so the problem here is really

00:10:13,030 --> 00:10:18,790
like these inconsistencies between your

00:10:16,030 --> 00:10:22,620
graphical schema that you've defined and

00:10:18,790 --> 00:10:26,050
your actual resolver implementation and

00:10:22,620 --> 00:10:28,390
you can either fix them like as they pop

00:10:26,050 --> 00:10:31,060
up and you get I get paged in the middle

00:10:28,390 --> 00:10:34,210
of the night or you find them like at

00:10:31,060 --> 00:10:37,900
development time at Build time and you

00:10:34,210 --> 00:10:40,000
can do so using type safety so let's

00:10:37,900 --> 00:10:43,210
think about like how can we create a

00:10:40,000 --> 00:10:45,880
type safe mapping between our graphical

00:10:43,210 --> 00:10:47,380
types to type script and type script

00:10:45,880 --> 00:10:50,620
here's just an example you could also

00:10:47,380 --> 00:10:52,750
use flow or whatever other language but

00:10:50,620 --> 00:10:55,510
we're using typescript here so the idea

00:10:52,750 --> 00:10:58,300
is to create a mapping into typescript

00:10:55,510 --> 00:11:02,620
interfaces and then let the typescript

00:10:58,300 --> 00:11:06,670
compiler or vyas code for example let it

00:11:02,620 --> 00:11:07,519
help us to basically let it tell us

00:11:06,670 --> 00:11:10,879
which

00:11:07,519 --> 00:11:13,339
the things we need to fix so the idea

00:11:10,879 --> 00:11:15,470
for this mapping is like that based on a

00:11:13,339 --> 00:11:19,249
graphical type definition here for

00:11:15,470 --> 00:11:21,619
example type query was a hell of was a

00:11:19,249 --> 00:11:25,100
hell of field we would create the

00:11:21,619 --> 00:11:27,769
following interface so we're just like

00:11:25,100 --> 00:11:31,279
maps want one all the things like the

00:11:27,769 --> 00:11:33,110
name arguments the return type and now

00:11:31,279 --> 00:11:36,170
that we have this interface definition

00:11:33,110 --> 00:11:40,129
we now need to import it and implement

00:11:36,170 --> 00:11:43,339
it in our actual resolvers and just by

00:11:40,129 --> 00:11:45,949
doing that now the type system can

00:11:43,339 --> 00:11:48,259
basically help us to avoid mistakes so

00:11:45,949 --> 00:11:50,509
let's take a look at a couple of these

00:11:48,259 --> 00:11:53,089
mistakes that it avoids so for example

00:11:50,509 --> 00:11:55,480
if we're having here for whatever reason

00:11:53,089 --> 00:11:59,329
we haven't implemented the hello

00:11:55,480 --> 00:12:01,610
resolver then vias code will tell us

00:11:59,329 --> 00:12:03,290
like hey hello the hello resolver is

00:12:01,610 --> 00:12:05,660
missing please implement it and it

00:12:03,290 --> 00:12:08,089
wouldn't even allow you to build and

00:12:05,660 --> 00:12:11,529
start your graphical server another

00:12:08,089 --> 00:12:14,720
common problem is if you want to access

00:12:11,529 --> 00:12:17,209
an argument that isn't that doesn't

00:12:14,720 --> 00:12:19,929
exist will also tell you like hey

00:12:17,209 --> 00:12:24,230
there's just the name argument available

00:12:19,929 --> 00:12:26,360
now the common error is or a little bit

00:12:24,230 --> 00:12:31,459
more subtle but also pretty dangerous is

00:12:26,360 --> 00:12:34,549
if you would return a value of a wrong

00:12:31,459 --> 00:12:37,459
type in your resolver again here type

00:12:34,549 --> 00:12:39,309
system can tell you hey here I'm for

00:12:37,459 --> 00:12:43,369
hello I'm just expecting a string

00:12:39,309 --> 00:12:46,730
boolean that doesn't work and all of

00:12:43,369 --> 00:12:51,379
these problems are not like caught by

00:12:46,730 --> 00:12:53,749
the type system so again the idea is we

00:12:51,379 --> 00:12:56,059
would basically translate our graphical

00:12:53,749 --> 00:12:59,660
schema into type script interfaces

00:12:56,059 --> 00:13:01,879
implement them but the problem now if

00:12:59,660 --> 00:13:04,339
you would do that manually this is a

00:13:01,879 --> 00:13:07,009
fairly super super small graphical

00:13:04,339 --> 00:13:10,429
schema if it would now do that for a

00:13:07,009 --> 00:13:14,720
more real-world graphical schema then

00:13:10,429 --> 00:13:16,970
we're gonna end up with a huge huge file

00:13:14,720 --> 00:13:18,740
that we manually need to maintain and

00:13:16,970 --> 00:13:21,170
that might arguably even

00:13:18,740 --> 00:13:24,140
worse like if you're kind of relying on

00:13:21,170 --> 00:13:25,730
a like a type definition that you've

00:13:24,140 --> 00:13:28,970
created for yourself you kind of feel

00:13:25,730 --> 00:13:31,700
like safe but probably you've made a lot

00:13:28,970 --> 00:13:33,920
of mistakes by creating these type

00:13:31,700 --> 00:13:36,380
definitions in the first place

00:13:33,920 --> 00:13:39,380
and it's just a lot of work so and the

00:13:36,380 --> 00:13:40,490
solution to this problem is that we're

00:13:39,380 --> 00:13:43,910
going to use cogeneration

00:13:40,490 --> 00:13:46,520
so we basically gonna use a tool that

00:13:43,910 --> 00:13:49,070
manually that that automatically maps

00:13:46,520 --> 00:13:51,820
the graphical schema definition into

00:13:49,070 --> 00:13:54,920
typescript interface definitions and

00:13:51,820 --> 00:13:57,080
automatically handles that for us so for

00:13:54,920 --> 00:13:59,089
those of you who are new to the idea of

00:13:57,080 --> 00:14:01,370
cogeneration it's basically like this

00:13:59,089 --> 00:14:03,890
automatic automatic concept that

00:14:01,370 --> 00:14:07,670
something gets regenerated for you this

00:14:03,890 --> 00:14:10,490
code you you're not supposed to edit

00:14:07,670 --> 00:14:13,700
this code you're just supposed to import

00:14:10,490 --> 00:14:16,010
from it and don't maybe if you hear

00:14:13,700 --> 00:14:18,260
about cogeneration don't confuse it with

00:14:16,010 --> 00:14:20,690
code scaffolding what you might be used

00:14:18,260 --> 00:14:23,029
from like Ruby on Rails was like the

00:14:20,690 --> 00:14:24,800
rails controller scaffolding the

00:14:23,029 --> 00:14:27,079
difference for the scaffolded code is

00:14:24,800 --> 00:14:29,329
like the scaffolded codes will be your

00:14:27,079 --> 00:14:31,399
code and you need to change it the code

00:14:29,329 --> 00:14:34,070
generated code is rather sitting on the

00:14:31,399 --> 00:14:36,350
side it's basically like doing the magic

00:14:34,070 --> 00:14:40,459
but you can look into it if you need to

00:14:36,350 --> 00:14:43,880
understand it so that's basically it the

00:14:40,459 --> 00:14:45,560
concepts are how we want to solve the

00:14:43,880 --> 00:14:48,829
problems that we have with schema first

00:14:45,560 --> 00:14:51,290
development is combining type safety and

00:14:48,829 --> 00:14:54,860
cogeneration and that's exactly what

00:14:51,290 --> 00:14:57,529
graph K told Jen does so graph Calgon i

00:14:54,860 --> 00:15:01,190
think we've officially released it last

00:14:57,529 --> 00:15:04,640
week is meant for types a is meant for

00:15:01,190 --> 00:15:06,560
schema first graphical servers and makes

00:15:04,640 --> 00:15:08,270
everything around your graph kill server

00:15:06,560 --> 00:15:11,120
type safe so your resolvers your

00:15:08,270 --> 00:15:13,760
arguments your models and since it's

00:15:11,120 --> 00:15:17,600
based on cogent you don't need to write

00:15:13,760 --> 00:15:20,060
any boilerplate so graph Calgon is a

00:15:17,600 --> 00:15:21,950
fairly simple and lightweight tool that

00:15:20,060 --> 00:15:23,959
works with all the existing JavaScript

00:15:21,950 --> 00:15:25,940
ecosystem so it works with apollo

00:15:23,959 --> 00:15:28,070
servers graphical yoga as graphical

00:15:25,940 --> 00:15:30,860
tools and you can use it both

00:15:28,070 --> 00:15:32,570
for building your your own like graph KL

00:15:30,860 --> 00:15:35,990
native model

00:15:32,570 --> 00:15:37,760
applications or you can use it for for

00:15:35,990 --> 00:15:40,760
making your graphical gateway type safe

00:15:37,760 --> 00:15:42,980
and I think the the neat trick here is

00:15:40,760 --> 00:15:46,510
like that graphical Jen doesn't really

00:15:42,980 --> 00:15:48,440
do all the hard work it's rather that it

00:15:46,510 --> 00:15:50,270
provides the foundation that the

00:15:48,440 --> 00:15:54,500
typescript compiler can do all of the

00:15:50,270 --> 00:15:56,300
hard work so how it works just west

00:15:54,500 --> 00:15:58,550
we've seen before we have our graphical

00:15:56,300 --> 00:16:00,080
schema definition we generate interfaces

00:15:58,550 --> 00:16:02,990
we need to now implement these

00:16:00,080 --> 00:16:06,290
interfaces and the workflow looks

00:16:02,990 --> 00:16:10,010
basically like this you have your schema

00:16:06,290 --> 00:16:14,000
or you have a schema change you run a

00:16:10,010 --> 00:16:16,820
graph Kyojin and then basically the

00:16:14,000 --> 00:16:18,500
typescript compiler tells you what

00:16:16,820 --> 00:16:21,080
everything is good or what do you need

00:16:18,500 --> 00:16:24,040
to change something and yep then you can

00:16:21,080 --> 00:16:27,290
make again changes to your tree schema

00:16:24,040 --> 00:16:30,080
so to get started you can either use

00:16:27,290 --> 00:16:31,880
this for building new graphical servers

00:16:30,080 --> 00:16:33,560
from scratch so you can bootstrap a new

00:16:31,880 --> 00:16:37,640
graphical server who is already

00:16:33,560 --> 00:16:40,970
everything set up or you can add it to

00:16:37,640 --> 00:16:44,870
your existing project by simply selling

00:16:40,970 --> 00:16:47,690
graphical Elgin either as a globally or

00:16:44,870 --> 00:16:50,630
adding it as a def dependency you can

00:16:47,690 --> 00:16:52,670
initialize your config file using

00:16:50,630 --> 00:16:54,560
graphical agenda in it and then you

00:16:52,670 --> 00:16:57,230
basically just start importing these

00:16:54,560 --> 00:17:00,680
tabs these typescript interfaces in your

00:16:57,230 --> 00:17:02,570
resolver implementations so the config

00:17:00,680 --> 00:17:06,020
file looks something like this so you

00:17:02,570 --> 00:17:08,630
need to specify your language you need

00:17:06,020 --> 00:17:12,189
to specify where your graphical schema

00:17:08,630 --> 00:17:14,360
lives you what you can point to a

00:17:12,189 --> 00:17:16,310
context to finish in the context is

00:17:14,360 --> 00:17:19,160
basically the thing that's passed into

00:17:16,310 --> 00:17:22,640
every of your resolvers and you can also

00:17:19,160 --> 00:17:26,959
make that type safe and you need to

00:17:22,640 --> 00:17:28,160
provide mappings to your models so maybe

00:17:26,959 --> 00:17:31,000
not all of you are familiar with a

00:17:28,160 --> 00:17:34,280
concept of a model a model is basically

00:17:31,000 --> 00:17:36,860
the thing that you return in a resolver

00:17:34,280 --> 00:17:38,660
that's passed in as a parent value in

00:17:36,860 --> 00:17:40,220
another resolver so you're probably

00:17:38,660 --> 00:17:42,230
familiar with your graphical schema and

00:17:40,220 --> 00:17:44,150
your resolvers and the models is

00:17:42,230 --> 00:17:45,560
basically model is just like a term of

00:17:44,150 --> 00:17:47,510
the data that you return

00:17:45,560 --> 00:17:49,670
one resolver that's passed into the

00:17:47,510 --> 00:17:52,760
other resolver and you're also supposed

00:17:49,670 --> 00:17:54,530
to have type definitions for that to

00:17:52,760 --> 00:17:58,340
make the mapping inside of your

00:17:54,530 --> 00:17:59,960
resolvers also type safe so yeah that's

00:17:58,340 --> 00:18:02,660
basically everything you have to you

00:17:59,960 --> 00:18:06,230
have to know let's take a look at an

00:18:02,660 --> 00:18:09,080
actual demo of how this works so in this

00:18:06,230 --> 00:18:12,110
demo we're gonna look into an existing

00:18:09,080 --> 00:18:14,090
graphical server that I've prepared has

00:18:12,110 --> 00:18:18,800
a few bugs which we're gonna use

00:18:14,090 --> 00:18:20,690
graphical gem to help us find them so

00:18:18,800 --> 00:18:24,950
we'll introduce graphical gem fix these

00:18:20,690 --> 00:18:27,050
problems and then we also gonna evolved

00:18:24,950 --> 00:18:32,620
graphical schema a little bit and see

00:18:27,050 --> 00:18:36,350
the workflow of that so let's do that um

00:18:32,620 --> 00:18:38,870
hopefully this is big enough so and I

00:18:36,350 --> 00:18:43,400
hope the contrast is good enough I can

00:18:38,870 --> 00:18:45,470
also switch this to the light theme so

00:18:43,400 --> 00:18:48,680
my favorite but might be a little bit

00:18:45,470 --> 00:18:53,000
more visible so this is super simple

00:18:48,680 --> 00:18:55,220
graphical server so here let's take a

00:18:53,000 --> 00:18:57,470
look in the index file here we're simply

00:18:55,220 --> 00:19:00,230
starting a new graphical server it

00:18:57,470 --> 00:19:03,820
points to our graphical schema points to

00:19:00,230 --> 00:19:09,110
the resolvers and also passes here a

00:19:03,820 --> 00:19:11,690
data object into the into the context so

00:19:09,110 --> 00:19:14,000
the data object here is basically just a

00:19:11,690 --> 00:19:15,110
replacement for our database it's

00:19:14,000 --> 00:19:17,960
basically just like a couple of

00:19:15,110 --> 00:19:21,680
variables that mock our database and in

00:19:17,960 --> 00:19:24,170
this implementation so if we take a look

00:19:21,680 --> 00:19:26,000
in our graphical schema the graph get

00:19:24,170 --> 00:19:28,970
schema looks like this we have a super

00:19:26,000 --> 00:19:32,030
simple logging application where we can

00:19:28,970 --> 00:19:35,300
query for feed for some drafts we always

00:19:32,030 --> 00:19:37,400
get like some posts returned and we can

00:19:35,300 --> 00:19:40,940
also we have a couple of mutations here

00:19:37,400 --> 00:19:42,830
a post has an ID title content whether

00:19:40,940 --> 00:19:46,880
it's published and it has an author and

00:19:42,830 --> 00:19:50,020
a user has an ID name and their posts so

00:19:46,880 --> 00:19:53,120
super simple let's actually fire up that

00:19:50,020 --> 00:19:56,890
graphical server and see whether it

00:19:53,120 --> 00:19:59,440
works so we're just gonna open up the

00:19:56,890 --> 00:20:03,790
graphical playground here

00:19:59,440 --> 00:20:09,070
we can now query for the feed let's get

00:20:03,790 --> 00:20:10,900
the title the ID and the content we can

00:20:09,070 --> 00:20:13,000
query for this perfect

00:20:10,900 --> 00:20:15,610
so we already get getting back some data

00:20:13,000 --> 00:20:19,300
let's take a look at how the how the

00:20:15,610 --> 00:20:21,190
query is implemented just as simple as

00:20:19,300 --> 00:20:26,950
this we're just accessing the data

00:20:21,190 --> 00:20:29,140
object here on our context and then just

00:20:26,950 --> 00:20:33,760
filter the the post whether they are

00:20:29,140 --> 00:20:36,400
published or not alright so in our graph

00:20:33,760 --> 00:20:42,000
Cal schema we also see the field here is

00:20:36,400 --> 00:20:44,560
published so let's also query this and

00:20:42,000 --> 00:20:48,790
okay now we are running into a problem

00:20:44,560 --> 00:20:51,670
so why is this let's say so here we are

00:20:48,790 --> 00:20:54,910
basically returning a post so let's take

00:20:51,670 --> 00:20:57,280
a look in the post resolver our post

00:20:54,910 --> 00:21:00,610
resolver looks like this right now so we

00:20:57,280 --> 00:21:03,700
basically just implement the author is

00:21:00,610 --> 00:21:06,040
over and we are kind of relying on the

00:21:03,700 --> 00:21:10,450
default resolvers kind of doing the

00:21:06,040 --> 00:21:12,310
right thing so if we now if again to

00:21:10,450 --> 00:21:15,940
recap the concept of a default resolver

00:21:12,310 --> 00:21:18,670
it works for so long that your data that

00:21:15,940 --> 00:21:21,910
you're returning actually matches the

00:21:18,670 --> 00:21:24,010
graphical schema so if we take a look

00:21:21,910 --> 00:21:26,410
here into like what a post here looks

00:21:24,010 --> 00:21:31,150
like and what the data we have available

00:21:26,410 --> 00:21:33,570
here we have a D ID that matches title

00:21:31,150 --> 00:21:36,700
title matches content content matches

00:21:33,570 --> 00:21:40,030
okay so here we have published and here

00:21:36,700 --> 00:21:41,830
we have is published so this is already

00:21:40,030 --> 00:21:46,120
something that we've just now kind of

00:21:41,830 --> 00:21:49,000
seen in production that this where it

00:21:46,120 --> 00:21:50,920
breaks down so let's now introduce graph

00:21:49,000 --> 00:21:55,860
Cal gen and see whether it can help us

00:21:50,920 --> 00:21:58,750
with this so we we simply do so by

00:21:55,860 --> 00:22:01,450
adding this graph Cal gen llamo file

00:21:58,750 --> 00:22:03,460
here I've already added it so I've

00:22:01,450 --> 00:22:07,030
configured typescript pointed to the

00:22:03,460 --> 00:22:11,440
schema pointed to the context definition

00:22:07,030 --> 00:22:13,149
and wired up the models so so the models

00:22:11,440 --> 00:22:15,759
are basically just here in this

00:22:13,149 --> 00:22:18,450
types file just a typescript definition

00:22:15,759 --> 00:22:21,879
for what our data actually looks like

00:22:18,450 --> 00:22:26,830
and that's basically all we need now we

00:22:21,879 --> 00:22:30,820
can run graph Cal junk or short GG and

00:22:26,830 --> 00:22:33,509
that basically generates the over here

00:22:30,820 --> 00:22:36,669
generates the type definitions for us

00:22:33,509 --> 00:22:39,759
which we can now use for example here

00:22:36,669 --> 00:22:44,349
for the post resolvers which we can now

00:22:39,759 --> 00:22:45,549
use in our post resolver and implement

00:22:44,349 --> 00:22:48,519
our resolvers with it

00:22:45,549 --> 00:22:52,419
so I've already added this here now we

00:22:48,519 --> 00:22:55,989
just need to say here post resolvers dot

00:22:52,419 --> 00:22:58,149
type and now we already see okay we get

00:22:55,989 --> 00:23:00,700
an error message here property ID is

00:22:58,149 --> 00:23:03,070
missing okay so this would basically now

00:23:00,700 --> 00:23:06,129
force us to implement all of the default

00:23:03,070 --> 00:23:08,139
resolvers but there's a shortcut for

00:23:06,129 --> 00:23:11,169
this so we can basically just since

00:23:08,139 --> 00:23:13,830
graph Calgon already generates the

00:23:11,169 --> 00:23:17,499
default resolvers fast we can just now

00:23:13,830 --> 00:23:21,190
mix them them in here the next problem

00:23:17,499 --> 00:23:23,349
that we see ha property is published as

00:23:21,190 --> 00:23:26,409
missing and that makes sense this is not

00:23:23,349 --> 00:23:27,549
part of the default resolvers here the

00:23:26,409 --> 00:23:30,190
default resolvers comes this

00:23:27,549 --> 00:23:31,779
intersection of your graphical type

00:23:30,190 --> 00:23:34,299
definition and the data that you have

00:23:31,779 --> 00:23:36,909
actually available so that makes sense

00:23:34,299 --> 00:23:38,739
we need to implement the is published

00:23:36,909 --> 00:23:40,989
resolver and the cool thing is we

00:23:38,739 --> 00:23:44,529
already get auto completion here for is

00:23:40,989 --> 00:23:48,129
published we can now just say here on we

00:23:44,529 --> 00:23:49,929
just returned published and we you see

00:23:48,129 --> 00:23:52,690
here we're also getting auto completion

00:23:49,929 --> 00:23:54,460
here for the parent value since this is

00:23:52,690 --> 00:23:58,719
typed based on the model that we've

00:23:54,460 --> 00:24:00,700
injected so now we can we save this we

00:23:58,719 --> 00:24:05,080
no longer get an error message we can

00:24:00,700 --> 00:24:08,139
start the graphical server again and now

00:24:05,080 --> 00:24:10,599
when we query this it works so this has

00:24:08,139 --> 00:24:12,279
already helped us to find the problem

00:24:10,599 --> 00:24:15,549
and the really neat thing about

00:24:12,279 --> 00:24:16,919
graphical genesis well that we've just

00:24:15,549 --> 00:24:20,169
seen now like that we can incrementally

00:24:16,919 --> 00:24:22,839
adopt this so on a resolver by resolver

00:24:20,169 --> 00:24:25,119
level and it already helps you to find

00:24:22,839 --> 00:24:26,750
problems let's do this also for the

00:24:25,119 --> 00:24:32,600
query resolvers here

00:24:26,750 --> 00:24:36,289
so let's stitch let's just imported okay

00:24:32,600 --> 00:24:41,179
and now we also get a error here and we

00:24:36,289 --> 00:24:44,780
already see it in here post ID post id

00:24:41,179 --> 00:24:45,350
does not exist on type arcs so and that

00:24:44,780 --> 00:24:49,309
makes sense

00:24:45,350 --> 00:24:52,370
if we take a look again in our graphical

00:24:49,309 --> 00:24:55,940
schema in our graphical sima we have

00:24:52,370 --> 00:24:58,429
here posts ID and four and here we're

00:24:55,940 --> 00:25:01,010
kind of accessing arcs dot post ID which

00:24:58,429 --> 00:25:03,230
doesn't exist so let's see what we have

00:25:01,010 --> 00:25:06,679
available here we have available here ID

00:25:03,230 --> 00:25:09,710
so let's save that and the server is

00:25:06,679 --> 00:25:11,960
running again so graphical gem like one

00:25:09,710 --> 00:25:13,850
step at a time tells us about the

00:25:11,960 --> 00:25:17,390
inconsistencies between our graphical

00:25:13,850 --> 00:25:19,669
schema and and the resolvers so and you

00:25:17,390 --> 00:25:21,860
can use graphical gem to initially find

00:25:19,669 --> 00:25:24,890
problems but also to evolve your schema

00:25:21,860 --> 00:25:28,669
so let's say would add a slack field

00:25:24,890 --> 00:25:31,370
here we would now save this run

00:25:28,669 --> 00:25:34,400
graphical gen again and if we now go

00:25:31,370 --> 00:25:36,950
back to our posts this will now tell us

00:25:34,400 --> 00:25:40,669
hey we didn't on our data we don't have

00:25:36,950 --> 00:25:44,960
a slug so it forces you to to implement

00:25:40,669 --> 00:25:48,700
the the remaining resolvers which we can

00:25:44,960 --> 00:25:54,049
just do like that so let's say this is a

00:25:48,700 --> 00:25:57,080
title to lowercase and everything is

00:25:54,049 --> 00:26:00,350
happy again so that is basically how you

00:25:57,080 --> 00:26:02,809
can introduce graphical gem in your

00:26:00,350 --> 00:26:05,330
existing in your existing project and

00:26:02,809 --> 00:26:09,590
how it helps you to find a lot of these

00:26:05,330 --> 00:26:15,020
problems yep so let's get back to the

00:26:09,590 --> 00:26:17,419
presentation again perfect a few

00:26:15,020 --> 00:26:19,570
thoughts on the future of graph children

00:26:17,419 --> 00:26:23,770
graph girl Jen is heavily inspired by

00:26:19,570 --> 00:26:26,360
equivalent tool in NGO called gql Jen

00:26:23,770 --> 00:26:29,299
which is yeah kind of kind of like a

00:26:26,360 --> 00:26:30,710
sister project now where we are taking a

00:26:29,299 --> 00:26:33,650
lot of inspiration from and we are

00:26:30,710 --> 00:26:38,000
trying to evolve the the road map in a

00:26:33,650 --> 00:26:40,040
similar fashion so and based on that we

00:26:38,000 --> 00:26:42,620
also want to add support for

00:26:40,040 --> 00:26:46,040
integration system or plugin system that

00:26:42,620 --> 00:26:48,590
allows you to for example talk to Jerry

00:26:46,040 --> 00:26:50,929
PC services or Swift services map that

00:26:48,590 --> 00:26:52,640
together in a type safe way we also want

00:26:50,929 --> 00:26:55,370
to add support for other JavaScript

00:26:52,640 --> 00:26:59,240
based languages for example for reason

00:26:55,370 --> 00:27:01,309
yeah so I think there are a few few

00:26:59,240 --> 00:27:03,950
really interesting ideas so if you're

00:27:01,309 --> 00:27:07,280
interested in contributing also like

00:27:03,950 --> 00:27:09,980
please get in touch so the last thing I

00:27:07,280 --> 00:27:13,490
would like to talk about is kind of what

00:27:09,980 --> 00:27:16,280
I see is the holy grail for for

00:27:13,490 --> 00:27:18,679
development for modern developers which

00:27:16,280 --> 00:27:22,340
is the idea of enter and type safety so

00:27:18,679 --> 00:27:24,429
especially for in the graphical space

00:27:22,340 --> 00:27:27,890
we've seen I think a couple of talks

00:27:24,429 --> 00:27:30,980
about like why does what it's

00:27:27,890 --> 00:27:33,080
interesting and the the idea is

00:27:30,980 --> 00:27:35,299
basically that you have a type safe

00:27:33,080 --> 00:27:38,510
mapping from like your row as it lives

00:27:35,299 --> 00:27:40,370
in your database up to how you can

00:27:38,510 --> 00:27:43,549
access your data in your reactor props

00:27:40,370 --> 00:27:45,980
and very often it's like not a

00:27:43,549 --> 00:27:47,419
one-to-one mapping and you need to map

00:27:45,980 --> 00:27:49,400
it somehow differently but you still

00:27:47,419 --> 00:27:51,590
need to do the mapping and type safe way

00:27:49,400 --> 00:27:53,390
that's the idea of enter and type safety

00:27:51,590 --> 00:27:58,010
and I think the biggest missing piece

00:27:53,390 --> 00:28:00,140
here is like if it goes through like one

00:27:58,010 --> 00:28:03,740
step at a time through the stack like

00:28:00,140 --> 00:28:06,020
Apollo cogent already helps us to have a

00:28:03,740 --> 00:28:08,630
type safe mapping from our graphical API

00:28:06,020 --> 00:28:11,030
into our front-end applications graph KL

00:28:08,630 --> 00:28:14,000
gen helps you for your graphical server

00:28:11,030 --> 00:28:15,860
and node to make that type safe and the

00:28:14,000 --> 00:28:18,500
missing piece is basically how do you

00:28:15,860 --> 00:28:21,410
access your data from your database in a

00:28:18,500 --> 00:28:23,750
type safe way that's exactly what we are

00:28:21,410 --> 00:28:25,970
doing with Prisma which gives you type

00:28:23,750 --> 00:28:28,490
safe database access and that's a pretty

00:28:25,970 --> 00:28:31,130
big deal because this api to database

00:28:28,490 --> 00:28:34,309
mapping is i think one of the most

00:28:31,130 --> 00:28:37,190
brittle and error-prone things that you

00:28:34,309 --> 00:28:39,230
have to do as an api developer and one

00:28:37,190 --> 00:28:42,410
of the most common causes for downtime

00:28:39,230 --> 00:28:44,150
and production and the way how it

00:28:42,410 --> 00:28:46,220
typically tackle this is just by writing

00:28:44,150 --> 00:28:49,549
a lot of integration tests and these are

00:28:46,220 --> 00:28:51,110
as kind of like ugly to test and most of

00:28:49,549 --> 00:28:53,580
them you can just like they become

00:28:51,110 --> 00:28:56,340
obsolete if you have type safety further

00:28:53,580 --> 00:28:58,800
part and that's what we're enabling with

00:28:56,340 --> 00:29:01,590
prismo so with prismo you can basically

00:28:58,800 --> 00:29:05,280
generate auto generate a type save

00:29:01,590 --> 00:29:07,650
database client for any kind of language

00:29:05,280 --> 00:29:10,170
for any kind of database so you can

00:29:07,650 --> 00:29:12,270
either use your existing database and

00:29:10,170 --> 00:29:14,220
introspect that or you can start from

00:29:12,270 --> 00:29:17,580
scratch and evolve your database on your

00:29:14,220 --> 00:29:19,140
own and presumably that client library

00:29:17,580 --> 00:29:22,350
for you and prismo as query engine

00:29:19,140 --> 00:29:27,000
allows you to efficiently resolve data

00:29:22,350 --> 00:29:29,220
from various data sources so and prismo

00:29:27,000 --> 00:29:32,280
is especially interesting for building

00:29:29,220 --> 00:29:35,190
graphical servers because Prisma client

00:29:32,280 --> 00:29:37,230
already has a built in data loader that

00:29:35,190 --> 00:29:40,350
solves the N + 1 curve problem for you

00:29:37,230 --> 00:29:42,480
and also makes it super easy for you to

00:29:40,350 --> 00:29:45,030
implement common API features like

00:29:42,480 --> 00:29:47,910
filtering pagination crud functionality

00:29:45,030 --> 00:29:49,530
and even it's real time layer makes it

00:29:47,910 --> 00:29:52,860
easy for you to implement your own

00:29:49,530 --> 00:29:54,870
graphical subscriptions on a high-level

00:29:52,860 --> 00:29:56,910
Prisma works like this for an existing

00:29:54,870 --> 00:29:58,770
data database for example that you

00:29:56,910 --> 00:30:01,050
connect it to your database you

00:29:58,770 --> 00:30:03,270
introspect your schema you generate a

00:30:01,050 --> 00:30:08,550
client for that and then you basically

00:30:03,270 --> 00:30:11,340
start building your API yeah so this was

00:30:08,550 --> 00:30:13,590
a high-level overview over the concepts

00:30:11,340 --> 00:30:16,200
of type safety and to end type safety

00:30:13,590 --> 00:30:19,740
and for building graphical schema first

00:30:16,200 --> 00:30:23,040
graphical servers few key takeaways for

00:30:19,740 --> 00:30:24,780
you basically I think it's interesting

00:30:23,040 --> 00:30:27,030
to think about su building a new

00:30:24,780 --> 00:30:28,680
graphical server about the two different

00:30:27,030 --> 00:30:30,450
ways of doing and schema first and

00:30:28,680 --> 00:30:33,120
resolver first both have their

00:30:30,450 --> 00:30:37,110
advantages I think we're gonna see a lot

00:30:33,120 --> 00:30:40,260
more in in both camps if you're going if

00:30:37,110 --> 00:30:42,540
you're going to scheme at first then I

00:30:40,260 --> 00:30:44,610
would really encourage you to like give

00:30:42,540 --> 00:30:47,430
typescript a chance and use graphical

00:30:44,610 --> 00:30:49,860
gen to let it help you solve a lot of

00:30:47,430 --> 00:30:52,860
these problems during the development

00:30:49,860 --> 00:30:56,370
time and if you want to go all-in on

00:30:52,860 --> 00:30:58,290
enter and type safety check out Prisma

00:30:56,370 --> 00:31:03,510
which gives you type safe database

00:30:58,290 --> 00:31:06,300
access if you hear a few resources you

00:31:03,510 --> 00:31:07,540
can find graphical gem on github also a

00:31:06,300 --> 00:31:11,950
couple of examples for

00:31:07,540 --> 00:31:13,720
and yeah two more things one if you're

00:31:11,950 --> 00:31:15,850
interested in working on this sort of

00:31:13,720 --> 00:31:19,120
tooling working on database tooling API

00:31:15,850 --> 00:31:21,250
tooling we're hiring so feel free to

00:31:19,120 --> 00:31:24,340
check out our jobs page or talk to me

00:31:21,250 --> 00:31:27,430
afterwards and would be awesome to see

00:31:24,340 --> 00:31:30,730
many of you in summer in Berlin next

00:31:27,430 --> 00:31:34,660
year where we are organizing the

00:31:30,730 --> 00:31:36,910
graphical conf we deceive peas are open

00:31:34,660 --> 00:31:39,700
also if you're interested in giving a

00:31:36,910 --> 00:31:42,550
talk yourself there feel free to submit

00:31:39,700 --> 00:31:43,540
a talk and yeah that was it thank you so

00:31:42,550 --> 00:31:48,559
much

00:31:43,540 --> 00:31:48,559

YouTube URL: https://www.youtube.com/watch?v=TqPBUXUHQx8


