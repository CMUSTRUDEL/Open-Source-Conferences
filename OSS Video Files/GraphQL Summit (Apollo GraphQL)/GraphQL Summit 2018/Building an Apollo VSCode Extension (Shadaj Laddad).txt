Title: Building an Apollo VSCode Extension (Shadaj Laddad)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Shadaj Laddad, Software Engineering Intern at Apollo, is currently a student at UC Berkeley studying Electrical Engineering and Computer Science. 

Apollo VSCode is a brand new, open-source extension that provides code completion, linting, and analytics data for GraphQL right in your IDE! In this talk, we'll explore all of the features of this extension, from writing queries faster to getting Engine performance stats displayed inline, and how to use them to optimize your GraphQL development workflow. We'll also take a look at some features coming soon to the extension and how to get involved with contributing to the extension!

Learn more about Apollo:  https://www.apollographql.com/

Join Apollo's community Slack group:  https://www.apollographql.com/slack/

Learn more:  https://summit.graphql.com
Captions: 
	00:00:05,020 --> 00:00:09,010
all right so today I'm going to be

00:00:07,089 --> 00:00:11,080
talking about the Apollo of yes code

00:00:09,010 --> 00:00:13,299
extension now I think we've seen this

00:00:11,080 --> 00:00:15,490
already a lot today so in Jeff's

00:00:13,299 --> 00:00:17,230
presentation in Peggy's presentation

00:00:15,490 --> 00:00:19,060
we've already seen it so today I'm gonna

00:00:17,230 --> 00:00:20,079
be going kind of more in depth with how

00:00:19,060 --> 00:00:22,240
you have to get set up with this

00:00:20,079 --> 00:00:23,170
extension and all the features it offers

00:00:22,240 --> 00:00:26,890
you

00:00:23,170 --> 00:00:28,449
so first hi I'm sue Dodge I'm a freshman

00:00:26,890 --> 00:00:29,679
at UC Berkeley where I'm studying

00:00:28,449 --> 00:00:33,489
Electrical Engineering and computer

00:00:29,679 --> 00:00:36,070
science I as Jessie mentioned I was an

00:00:33,489 --> 00:00:38,019
intern time two times at Apollo some

00:00:36,070 --> 00:00:40,629
things you might know me for the Apollo

00:00:38,019 --> 00:00:42,159
client to cache API which is used by

00:00:40,629 --> 00:00:45,070
Hermes so that's something I developed

00:00:42,159 --> 00:00:46,420
in my first internship and then recently

00:00:45,070 --> 00:00:47,500
I've been working a while on the Apollo

00:00:46,420 --> 00:00:50,710
cogent and COI

00:00:47,500 --> 00:00:52,030
so I added things like Scala support to

00:00:50,710 --> 00:00:53,739
a polo coach in and then I worked on

00:00:52,030 --> 00:00:55,210
things like bringing the cogent into the

00:00:53,739 --> 00:00:58,360
CLI and a lot of the new features there

00:00:55,210 --> 00:01:00,549
and a Paul vs code so that's something I

00:00:58,360 --> 00:01:01,689
worked on this summer and I'm super

00:01:00,549 --> 00:01:04,900
excited to share it with you so

00:01:01,689 --> 00:01:07,119
introducing apollo vs code now this

00:01:04,900 --> 00:01:09,009
isn't something that just i worked on

00:01:07,119 --> 00:01:11,229
there are a lot of people who helped out

00:01:09,009 --> 00:01:12,869
and especially after my internship and

00:01:11,229 --> 00:01:16,600
bringing this to the finish line so

00:01:12,869 --> 00:01:19,149
thanks to James Baxley Martin Walraven

00:01:16,600 --> 00:01:23,560
and Trevor shear for really helping make

00:01:19,149 --> 00:01:25,749
this extension as awesome as it is so

00:01:23,560 --> 00:01:27,159
what is the purpose of the apollo vs

00:01:25,749 --> 00:01:28,539
code extension there are two primary

00:01:27,159 --> 00:01:30,700
goals here you want to make graph

00:01:28,539 --> 00:01:33,700
writing graph QL faster and smarter so

00:01:30,700 --> 00:01:35,590
faster that's like any IDE extension you

00:01:33,700 --> 00:01:38,380
have code completion you can provide

00:01:35,590 --> 00:01:40,780
maybe some snippets to make writing what

00:01:38,380 --> 00:01:42,219
common patterns and graph kill fast but

00:01:40,780 --> 00:01:44,079
I think the really cool thing that we're

00:01:42,219 --> 00:01:47,079
able to do with graph QL is we're able

00:01:44,079 --> 00:01:49,600
to make this process a lot smarter we're

00:01:47,079 --> 00:01:51,159
writing graph QL isn't just dumping a

00:01:49,600 --> 00:01:53,049
bunch of fields into a file you have to

00:01:51,159 --> 00:01:55,569
make decisions about it if you have

00:01:53,049 --> 00:01:57,789
multiple ways to get similar sets of

00:01:55,569 --> 00:01:59,380
data that might have different impacts

00:01:57,789 --> 00:02:00,189
on how you render it in your client you

00:01:59,380 --> 00:02:02,049
might want to know

00:02:00,189 --> 00:02:03,850
oh this field is going to take a lot of

00:02:02,049 --> 00:02:06,069
time to get from my server so I may want

00:02:03,850 --> 00:02:07,420
to do that only on the web client but on

00:02:06,069 --> 00:02:09,459
a mobile client where people expect much

00:02:07,420 --> 00:02:10,810
snappier experiences I want to use the

00:02:09,459 --> 00:02:14,530
field that's a lot snappier to get from

00:02:10,810 --> 00:02:16,360
the server so what does Apple vs could

00:02:14,530 --> 00:02:17,620
give you it gives you code completion to

00:02:16,360 --> 00:02:18,740
write graph kill queries faster and this

00:02:17,620 --> 00:02:20,990
is something we've seen

00:02:18,740 --> 00:02:22,340
basically anywhere you're writing

00:02:20,990 --> 00:02:24,050
graticule you will get code completion

00:02:22,340 --> 00:02:26,630
that's something we've really focused on

00:02:24,050 --> 00:02:28,130
so if you're writing fields that take

00:02:26,630 --> 00:02:30,290
parameters that are enums will give you

00:02:28,130 --> 00:02:31,550
code completion for the enums if you're

00:02:30,290 --> 00:02:33,260
writing mutations will give you code

00:02:31,550 --> 00:02:35,810
completion there anywhere you can think

00:02:33,260 --> 00:02:37,850
of you get code completion we give you

00:02:35,810 --> 00:02:39,620
automatic linking so as we'll see in a

00:02:37,850 --> 00:02:41,270
bit a poll vs code is actually built

00:02:39,620 --> 00:02:43,970
upon the foundations provided by a

00:02:41,270 --> 00:02:45,380
Polock cogent and the policy ally so any

00:02:43,970 --> 00:02:46,880
type of graphic you linting that you

00:02:45,380 --> 00:02:50,060
have in those tools automatically comes

00:02:46,880 --> 00:02:51,530
over to the IDE integration you get

00:02:50,060 --> 00:02:53,780
quick navigation so if you're working

00:02:51,530 --> 00:02:55,460
with large code bases it can be really

00:02:53,780 --> 00:02:58,040
hard to understand Oh where's this

00:02:55,460 --> 00:02:59,900
fragment coming for from or I have this

00:02:58,040 --> 00:03:01,280
fragment where is it being used is there

00:02:59,900 --> 00:03:02,870
any point in having this fragment in my

00:03:01,280 --> 00:03:04,880
code base anymore if all the devs aren't

00:03:02,870 --> 00:03:06,110
using anymore so you get quick

00:03:04,880 --> 00:03:08,240
navigation to understand that and you

00:03:06,110 --> 00:03:10,370
get in line performance stats to

00:03:08,240 --> 00:03:12,590
minimize context switches so with a poll

00:03:10,370 --> 00:03:14,930
engine you can know exactly how fast

00:03:12,590 --> 00:03:17,060
your query is gonna run based on data

00:03:14,930 --> 00:03:18,560
from your real live proxxon app and you

00:03:17,060 --> 00:03:20,180
can make decisions based on this to

00:03:18,560 --> 00:03:24,560
understand what type of queries you want

00:03:20,180 --> 00:03:26,660
to be performing so let's do a live demo

00:03:24,560 --> 00:03:29,060
and hopefully everything will work so I

00:03:26,660 --> 00:03:31,010
put together a to-do list because so

00:03:29,060 --> 00:03:33,530
that I don't forget to demo some parts

00:03:31,010 --> 00:03:36,020
so let's start by writing an a my query

00:03:33,530 --> 00:03:39,530
graph QL so let me zoom in on this

00:03:36,020 --> 00:03:41,660
because this is so here I have a simple

00:03:39,530 --> 00:03:43,040
graph QL file and we can start writing

00:03:41,660 --> 00:03:44,630
queries so I can start by running a

00:03:43,040 --> 00:03:46,760
query I can name it my query

00:03:44,630 --> 00:03:48,680
so here I've configured the pawl vs code

00:03:46,760 --> 00:03:49,580
extension to run against to get hunt API

00:03:48,680 --> 00:03:52,370
so Kahuna's

00:03:49,580 --> 00:03:55,250
demo app that we developed at Apollo so

00:03:52,370 --> 00:03:56,840
here I don't remember I totally forgot

00:03:55,250 --> 00:03:58,880
what fields are in this so I can just

00:03:56,840 --> 00:04:00,710
hit control space and now I know exactly

00:03:58,880 --> 00:04:02,960
what's available so this is kind of your

00:04:00,710 --> 00:04:05,660
first step of using the vs cut extension

00:04:02,960 --> 00:04:08,870
so I can say okay my current user get me

00:04:05,660 --> 00:04:10,790
their Avatar but I can do even more

00:04:08,870 --> 00:04:13,760
things so for example let's say I want

00:04:10,790 --> 00:04:16,090
to get an entry now it knows that repo

00:04:13,760 --> 00:04:19,160
full name is actually a required

00:04:16,090 --> 00:04:21,020
parameter for this entry field so if you

00:04:19,160 --> 00:04:22,610
it's optional it actually will directly

00:04:21,020 --> 00:04:24,230
take you inside those curly braces but

00:04:22,610 --> 00:04:26,630
in this case a knows repo full name is

00:04:24,230 --> 00:04:28,729
required in order to query this field so

00:04:26,630 --> 00:04:31,460
it's going to generate code to type that

00:04:28,729 --> 00:04:33,310
in second type in a polar graph QL slash

00:04:31,460 --> 00:04:35,660
Apollo client

00:04:33,310 --> 00:04:37,280
now I can say okay what's available on

00:04:35,660 --> 00:04:40,100
here I could get the comment count oh

00:04:37,280 --> 00:04:42,980
now we have some stats so now we can see

00:04:40,100 --> 00:04:45,380
here that on average the entry field

00:04:42,980 --> 00:04:47,540
takes 193 milliseconds to query and a

00:04:45,380 --> 00:04:49,250
common count takes 606 milliseconds so I

00:04:47,540 --> 00:04:50,960
might want to consider maybe not

00:04:49,250 --> 00:04:52,670
querying the common count because that's

00:04:50,960 --> 00:04:53,720
gonna take some time but let's say I

00:04:52,670 --> 00:04:56,390
want to do that and then I can get

00:04:53,720 --> 00:04:58,520
comments I can get the content I can get

00:04:56,390 --> 00:05:01,580
the repository and I can get the full

00:04:58,520 --> 00:05:03,110
name of that repository and so in just a

00:05:01,580 --> 00:05:05,150
couple of seconds we were able to go

00:05:03,110 --> 00:05:06,530
from not knowing anything about this

00:05:05,150 --> 00:05:08,030
schema that we were dealing with to

00:05:06,530 --> 00:05:09,350
being able to write a query against it

00:05:08,030 --> 00:05:11,360
because we're able to understand at

00:05:09,350 --> 00:05:15,320
every stage exactly what data is

00:05:11,360 --> 00:05:17,330
available for us so okay we wrote okay

00:05:15,320 --> 00:05:19,010
so now let's write a fragment so

00:05:17,330 --> 00:05:21,410
fragments are a really powerful tool in

00:05:19,010 --> 00:05:24,200
graph QL for two reasons one day allows

00:05:21,410 --> 00:05:25,490
you to reuse different different field

00:05:24,200 --> 00:05:27,200
sets that you're going to need to query

00:05:25,490 --> 00:05:28,730
and two they work really great with

00:05:27,200 --> 00:05:30,200
statically typed systems so if you have

00:05:28,730 --> 00:05:31,820
a fragment that fragment can have a type

00:05:30,200 --> 00:05:33,620
of its own so then you can share that

00:05:31,820 --> 00:05:36,500
type of data that data model across your

00:05:33,620 --> 00:05:41,240
application so it sort of fragment for

00:05:36,500 --> 00:05:43,280
comments and name so now I can say oh I

00:05:41,240 --> 00:05:45,560
want this to be on a type now what type

00:05:43,280 --> 00:05:47,150
do I want so as I mentioned we've really

00:05:45,560 --> 00:05:49,370
made it a strong focus to make sure that

00:05:47,150 --> 00:05:50,900
code completion works everywhere so here

00:05:49,370 --> 00:05:52,940
I'm writing a fragment it knows that

00:05:50,900 --> 00:05:54,290
after on you have to pass it and type

00:05:52,940 --> 00:05:56,240
that that fragment is going to be

00:05:54,290 --> 00:06:00,470
performed on so I can say oh this is

00:05:56,240 --> 00:06:03,290
going to be on an entry and now inside

00:06:00,470 --> 00:06:05,870
here I can say okay I have my comments I

00:06:03,290 --> 00:06:08,690
have the content and I have my

00:06:05,870 --> 00:06:11,750
repository and I have the full name so

00:06:08,690 --> 00:06:14,210
now I can just replace this chunk with

00:06:11,750 --> 00:06:16,130
dot and now it code completes because it

00:06:14,210 --> 00:06:17,330
knows that I'm inside an entry so all

00:06:16,130 --> 00:06:18,950
the fragments that are available on

00:06:17,330 --> 00:06:23,480
entry can apply and so I can could

00:06:18,950 --> 00:06:24,590
complete I have this query so now that

00:06:23,480 --> 00:06:27,380
we have a query we can play around with

00:06:24,590 --> 00:06:28,700
this a little more so if I want to jump

00:06:27,380 --> 00:06:30,140
around and kind of understand more about

00:06:28,700 --> 00:06:31,700
my application let's assume that

00:06:30,140 --> 00:06:33,200
comments a name was in a different file

00:06:31,700 --> 00:06:36,340
or we can move it to a separate file for

00:06:33,200 --> 00:06:40,640
now comments fragment

00:06:36,340 --> 00:06:41,960
graph q all so this fragment I have it

00:06:40,640 --> 00:06:43,430
here let's say I want to know where this

00:06:41,960 --> 00:06:44,870
is so first of all if I hover over it it

00:06:43,430 --> 00:06:46,310
shows me the source I can also jump to

00:06:44,870 --> 00:06:47,810
this and this works no matter

00:06:46,310 --> 00:06:49,370
how larger codebase is the way the

00:06:47,810 --> 00:06:50,870
extension works is actually scans all

00:06:49,370 --> 00:06:52,640
the graph QL files throughout your

00:06:50,870 --> 00:06:54,470
project and then looks at all of them at

00:06:52,640 --> 00:06:56,660
once so even if your fragment is

00:06:54,470 --> 00:06:57,950
somewhere far out in your application

00:06:56,660 --> 00:06:59,300
it'll still be able to find and you can

00:06:57,950 --> 00:07:02,360
jump to it and understand exactly what's

00:06:59,300 --> 00:07:03,170
going on now we can do a couple more

00:07:02,360 --> 00:07:05,420
things okay

00:07:03,170 --> 00:07:08,240
validation so let's say I write current

00:07:05,420 --> 00:07:09,530
use you get validation relatively

00:07:08,240 --> 00:07:10,670
straightforward so now you can make sure

00:07:09,530 --> 00:07:12,350
that all of your queries are gonna run

00:07:10,670 --> 00:07:14,720
we actually do a couple more things so

00:07:12,350 --> 00:07:17,090
for example if you forget to put your

00:07:14,720 --> 00:07:18,230
name Apollo actually doesn't support

00:07:17,090 --> 00:07:19,760
anonymous operations when you're using

00:07:18,230 --> 00:07:21,050
with the COI or if you're working with

00:07:19,760 --> 00:07:22,220
engine tools so we'll make sure that

00:07:21,050 --> 00:07:24,320
you're following this practice practice

00:07:22,220 --> 00:07:25,700
of naming all of your operations and

00:07:24,320 --> 00:07:27,800
also make sure that you're compatible

00:07:25,700 --> 00:07:29,450
with tools for generating static types

00:07:27,800 --> 00:07:32,840
where the static type names are gonna be

00:07:29,450 --> 00:07:34,640
based on your query name performance

00:07:32,840 --> 00:07:37,370
stats we've seen before basically

00:07:34,640 --> 00:07:38,900
anywhere that you have data from engine

00:07:37,370 --> 00:07:41,150
available for this fields you may see

00:07:38,900 --> 00:07:42,860
them and these stats are always updated

00:07:41,150 --> 00:07:44,390
live based on whatever app all engine

00:07:42,860 --> 00:07:47,480
has received from your traces from your

00:07:44,390 --> 00:07:48,890
production server and schema and

00:07:47,480 --> 00:07:51,890
navigation okay this is really awesome

00:07:48,890 --> 00:07:53,450
so let's say you a field and you want to

00:07:51,890 --> 00:07:55,700
explore more things related to the field

00:07:53,450 --> 00:07:57,290
well in addition to being able to jump

00:07:55,700 --> 00:07:59,810
to fragments you can also jump directly

00:07:57,290 --> 00:08:02,060
to your schema now I actually don't have

00:07:59,810 --> 00:08:03,620
a schema file in my entire project I got

00:08:02,060 --> 00:08:05,360
it from an introspection but what we're

00:08:03,620 --> 00:08:07,220
able to do is we're able to reconstruct

00:08:05,360 --> 00:08:08,510
a schema file as if this is what you

00:08:07,220 --> 00:08:10,130
wrote when you were working with your

00:08:08,510 --> 00:08:11,540
server and you're able to navigate it so

00:08:10,130 --> 00:08:13,850
you can see oh what else is available my

00:08:11,540 --> 00:08:15,770
user add the name of the user of the URL

00:08:13,850 --> 00:08:17,270
of their github page I can see

00:08:15,770 --> 00:08:18,860
everything that's available in this

00:08:17,270 --> 00:08:21,050
scheme and this is live generated based

00:08:18,860 --> 00:08:22,550
on the results that you get from a paul

00:08:21,050 --> 00:08:26,210
engine or your local server

00:08:22,550 --> 00:08:27,950
introspection and finally and Peggy

00:08:26,210 --> 00:08:30,170
talked about this a little bit we have

00:08:27,950 --> 00:08:33,190
support for client-side schemas so let's

00:08:30,170 --> 00:08:35,480
say I write a client schema graph QL

00:08:33,190 --> 00:08:37,580
know you have there's no conflict

00:08:35,480 --> 00:08:39,410
required to set up a client-side schema

00:08:37,580 --> 00:08:43,550
all you have to do is say I'm gonna

00:08:39,410 --> 00:08:45,680
extend a type and now I can extend let's

00:08:43,550 --> 00:08:49,160
say the entry type and then I can add

00:08:45,680 --> 00:08:52,490
local field field it's going to be a

00:08:49,160 --> 00:08:57,170
string so now the moment I did that now

00:08:52,490 --> 00:08:59,649
I can see something broke oh no this

00:08:57,170 --> 00:09:03,369
isn't great let's see

00:08:59,649 --> 00:09:03,699
I'm in my entry okay this is okay here

00:09:03,369 --> 00:09:05,350
we go

00:09:03,699 --> 00:09:07,569
there we go so now I can say local field

00:09:05,350 --> 00:09:09,249
and it shows up and this is without any

00:09:07,569 --> 00:09:10,509
configuration required so we're actually

00:09:09,249 --> 00:09:12,939
able to automatically scan all of your

00:09:10,509 --> 00:09:14,680
graph QL files if we detect that extent

00:09:12,939 --> 00:09:16,420
type were automatically able to stitch

00:09:14,680 --> 00:09:17,619
that into your server-side schema so

00:09:16,420 --> 00:09:20,800
then those fields are available wherever

00:09:17,619 --> 00:09:22,869
you want to create them so that's it for

00:09:20,800 --> 00:09:24,100
the live demo things went pretty well I

00:09:22,869 --> 00:09:26,290
guess

00:09:24,100 --> 00:09:28,540
so a little bit of what goes on inside

00:09:26,290 --> 00:09:30,009
so you have your vs code extension what

00:09:28,540 --> 00:09:31,509
we've done is we've designed this so

00:09:30,009 --> 00:09:32,709
that the vs code part of this is

00:09:31,509 --> 00:09:35,709
actually a very thin layer on top of

00:09:32,709 --> 00:09:37,329
some larger Apolo language server and so

00:09:35,709 --> 00:09:40,029
what you're able to do with this is if

00:09:37,329 --> 00:09:42,100
you want support for atom or Emacs or

00:09:40,029 --> 00:09:43,480
IntelliJ all you have to do is just talk

00:09:42,100 --> 00:09:45,309
to the language server and the language

00:09:43,480 --> 00:09:48,550
server can be reused across every IDE

00:09:45,309 --> 00:09:49,839
you want in addition your appalling

00:09:48,550 --> 00:09:51,939
which server actually talks to the

00:09:49,839 --> 00:09:53,170
Apollo CLI so we used to see lies this

00:09:51,939 --> 00:09:55,360
foundation which handles things like

00:09:53,170 --> 00:09:57,040
getting your schema running validation

00:09:55,360 --> 00:09:58,990
and so we're able to build upon this

00:09:57,040 --> 00:10:00,790
base that's used for handling all of the

00:09:58,990 --> 00:10:04,629
tooling across your projects and were

00:10:00,790 --> 00:10:06,819
able to integrate this into your IDE so

00:10:04,629 --> 00:10:08,499
get starting today is really easy you

00:10:06,819 --> 00:10:09,279
install the extension and you add your

00:10:08,499 --> 00:10:10,600
engine key

00:10:09,279 --> 00:10:12,370
what does adding your engine key look

00:10:10,600 --> 00:10:14,019
like it's as simple as this so you

00:10:12,370 --> 00:10:16,240
specify what your service name is you

00:10:14,019 --> 00:10:17,620
specify what your API key is and the

00:10:16,240 --> 00:10:20,319
moment you hit save if you have that

00:10:17,620 --> 00:10:21,910
extension installed you'll get code

00:10:20,319 --> 00:10:24,459
completion automatically in your IDE and

00:10:21,910 --> 00:10:26,079
also here I use graph QL files it also

00:10:24,459 --> 00:10:28,660
works with typescript JavaScript files

00:10:26,079 --> 00:10:33,309
if you have your graphical tag installed

00:10:28,660 --> 00:10:34,329
and also I hope you all contribute so as

00:10:33,309 --> 00:10:35,800
I mentioned this is based on the

00:10:34,329 --> 00:10:37,420
language server protocol so if you're

00:10:35,800 --> 00:10:39,699
looking for integrations with atom or

00:10:37,420 --> 00:10:41,499
other IDs that you like please

00:10:39,699 --> 00:10:44,170
contribute to the Apollo tooling repo

00:10:41,499 --> 00:10:47,290
which now contains the COI code gen and

00:10:44,170 --> 00:10:49,870
our language server alright so that's a

00:10:47,290 --> 00:10:52,689
quick overview of what goes on with the

00:10:49,870 --> 00:10:56,819
apollo vs code extension and so i hope

00:10:52,689 --> 00:10:56,819

YouTube URL: https://www.youtube.com/watch?v=cZtQgK83AqQ


