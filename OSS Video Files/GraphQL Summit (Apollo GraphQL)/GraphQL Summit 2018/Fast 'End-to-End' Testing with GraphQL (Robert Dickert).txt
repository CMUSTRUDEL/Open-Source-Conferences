Title: Fast 'End-to-End' Testing with GraphQL (Robert Dickert)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Robert Dickert, Senior Software Engineer at OK GROW!, knows that end-to-end testing has always been painful, but GraphQL can help. The GraphQL-first paradigm allows a new way of testing that gives us the confidence of true end-to-end tests without needing both client and server running, and without heavy end-to-end testing tools.

Learn more:  https://summit.graphql.com
Captions: 
	00:00:04,100 --> 00:00:09,709
hi everyone I'm Robert Dickert and this

00:00:06,920 --> 00:00:12,650
is fast and and testing with graph QL so

00:00:09,709 --> 00:00:15,289
quick intro I'm a developer app ok grow

00:00:12,650 --> 00:00:17,990
where we build web and mobile apps we do

00:00:15,289 --> 00:00:20,330
graph QL training and we also run a

00:00:17,990 --> 00:00:23,240
search KS the first all JavaScript

00:00:20,330 --> 00:00:25,250
testing conference testing is a really

00:00:23,240 --> 00:00:27,560
important part of our culture and ok

00:00:25,250 --> 00:00:30,730
grow and we look at it as more than just

00:00:27,560 --> 00:00:34,010
quality control we as programmers

00:00:30,730 --> 00:00:36,170
translate the business domain to working

00:00:34,010 --> 00:00:38,089
code now if you haven't encountered the

00:00:36,170 --> 00:00:40,579
term business domain before let's look

00:00:38,089 --> 00:00:42,859
at an example if our domain is

00:00:40,579 --> 00:00:44,719
interpersonal banking we can make some

00:00:42,859 --> 00:00:48,260
statements about our business regarding

00:00:44,719 --> 00:00:49,909
accounts deposits and so on and we can

00:00:48,260 --> 00:00:53,539
extract specific terminology that

00:00:49,909 --> 00:00:55,039
describes our domain let's say we have a

00:00:53,539 --> 00:00:58,100
business requirement which states that

00:00:55,039 --> 00:01:00,339
clients can view their updated balance

00:00:58,100 --> 00:01:02,929
when they transfer funds very simple

00:01:00,339 --> 00:01:05,330
using that we can formulate our testing

00:01:02,929 --> 00:01:07,100
scenarios so here we have a requirement

00:01:05,330 --> 00:01:08,990
that's written in gherkin language of

00:01:07,100 --> 00:01:11,899
cucumber using the given when then

00:01:08,990 --> 00:01:15,259
formula so we have given Tonia's logged

00:01:11,899 --> 00:01:17,780
in and he has a balance of $150 when he

00:01:15,259 --> 00:01:22,310
transfers $100 to Rodrigo than his

00:01:17,780 --> 00:01:23,899
balance is $50 ok so let's look at that

00:01:22,310 --> 00:01:26,329
let's look at the breakdown between the

00:01:23,899 --> 00:01:27,829
client and the server so the client

00:01:26,329 --> 00:01:29,899
needs to call the mutation correctly and

00:01:27,829 --> 00:01:32,659
display the outcome and then the server

00:01:29,899 --> 00:01:34,520
needs to perform the actual transfer so

00:01:32,659 --> 00:01:35,929
your Apps domain is spread across the

00:01:34,520 --> 00:01:39,289
client and the server with different

00:01:35,929 --> 00:01:41,570
functionality in each so let's say that

00:01:39,289 --> 00:01:45,200
we write client and server tests and get

00:01:41,570 --> 00:01:48,140
them to pass looks good so is that

00:01:45,200 --> 00:01:51,770
enough how confident are you in your

00:01:48,140 --> 00:01:53,840
tests what if both tests are ok but

00:01:51,770 --> 00:01:55,549
there's a problem with how the test is

00:01:53,840 --> 00:01:58,700
handled or how the client and the server

00:01:55,549 --> 00:02:00,020
handoff data between each other so in

00:01:58,700 --> 00:02:02,179
this case your individual tests are

00:02:00,020 --> 00:02:04,999
green but your end-to-end scenario is

00:02:02,179 --> 00:02:06,679
broken what we want is a test that makes

00:02:04,999 --> 00:02:08,360
sure that the process can traverse all

00:02:06,679 --> 00:02:11,150
the way from the client to the server

00:02:08,360 --> 00:02:13,610
and this brings us to end to end tests

00:02:11,150 --> 00:02:16,070
now what people usually mean here is a

00:02:13,610 --> 00:02:17,100
full simulation of the app including

00:02:16,070 --> 00:02:19,260
full client

00:02:17,100 --> 00:02:21,900
full server environments so we automate

00:02:19,260 --> 00:02:23,400
the input we let it traverse the app we

00:02:21,900 --> 00:02:26,010
run some assertions against the results

00:02:23,400 --> 00:02:29,190
as displayed in the browser and it works

00:02:26,010 --> 00:02:32,190
right it feels good conceptually so why

00:02:29,190 --> 00:02:33,720
don't we do this all the time well the

00:02:32,190 --> 00:02:35,880
reason isn't a mystery to anyone who's

00:02:33,720 --> 00:02:38,370
used a lot of selenium or tools like

00:02:35,880 --> 00:02:40,220
that these tests can be really slow too

00:02:38,370 --> 00:02:42,740
slow for test-driven development and

00:02:40,220 --> 00:02:46,830
they're also brittle and hard to set up

00:02:42,740 --> 00:02:48,780
but what's the alternative what if we

00:02:46,830 --> 00:02:51,240
could have end-to-end tests that were

00:02:48,780 --> 00:02:54,320
fast easy to write and that could be run

00:02:51,240 --> 00:02:57,090
independently on the client and server

00:02:54,320 --> 00:02:59,280
well there is a way after all

00:02:57,090 --> 00:03:01,170
we're using graph QL and it's already

00:02:59,280 --> 00:03:03,660
improved our process by getting front

00:03:01,170 --> 00:03:07,260
and back end devs to agree on data

00:03:03,660 --> 00:03:09,540
requirements if you think about it every

00:03:07,260 --> 00:03:12,390
graph QL operation can be specified by

00:03:09,540 --> 00:03:16,800
four things the operation the arguments

00:03:12,390 --> 00:03:19,050
the context and the response if we look

00:03:16,800 --> 00:03:21,870
at how we use these on the server it's a

00:03:19,050 --> 00:03:25,140
very straightforward API test so we need

00:03:21,870 --> 00:03:27,030
to set a value on the database and then

00:03:25,140 --> 00:03:30,840
we take the operation variables and

00:03:27,030 --> 00:03:32,790
context and pass them to run them on our

00:03:30,840 --> 00:03:35,940
graph killer resolver and then we can

00:03:32,790 --> 00:03:37,590
assert the result that comes back on the

00:03:35,940 --> 00:03:40,260
client it's a little bit different right

00:03:37,590 --> 00:03:42,450
we have we'll probably need to set a

00:03:40,260 --> 00:03:46,380
field state on a form component and then

00:03:42,450 --> 00:03:49,500
we trigger our mutation and and then we

00:03:46,380 --> 00:03:51,060
execute a locked out mutation that

00:03:49,500 --> 00:03:53,100
returns our expected graphical results

00:03:51,060 --> 00:03:55,260
and then we check to make sure that we

00:03:53,100 --> 00:03:56,460
displayed it correctly so all very very

00:03:55,260 --> 00:03:58,920
straightforward and it sounds like

00:03:56,460 --> 00:04:00,540
they're working together right but how

00:03:58,920 --> 00:04:04,890
do we make sure that these tests are

00:04:00,540 --> 00:04:07,170
really truly linked well I would assert

00:04:04,890 --> 00:04:10,770
that the test can be considered part of

00:04:07,170 --> 00:04:13,680
the same end to end process if four

00:04:10,770 --> 00:04:15,270
things are true so if the operation that

00:04:13,680 --> 00:04:18,450
the client and the server are using are

00:04:15,270 --> 00:04:20,100
the same if the variables that are

00:04:18,450 --> 00:04:22,260
passed by the client are the same ones

00:04:20,100 --> 00:04:24,840
that are used by the server test if they

00:04:22,260 --> 00:04:26,370
are using a common context and if the

00:04:24,840 --> 00:04:28,919
expected result that we get back from

00:04:26,370 --> 00:04:30,630
the server is used as the mocked value

00:04:28,919 --> 00:04:34,860
for the client thus

00:04:30,630 --> 00:04:36,960
closing the loop this is a contract test

00:04:34,860 --> 00:04:39,180
contract tests are usually used to

00:04:36,960 --> 00:04:42,030
confirm that an outside API that you

00:04:39,180 --> 00:04:43,470
depend on hasn't changed meaning that we

00:04:42,030 --> 00:04:46,410
can count on the Mach values in our

00:04:43,470 --> 00:04:47,880
tests here we are adapting that concept

00:04:46,410 --> 00:04:50,220
to assert that our client and server

00:04:47,880 --> 00:04:54,810
tests are in fact part of the same

00:04:50,220 --> 00:04:57,120
request but how do we do this the answer

00:04:54,810 --> 00:04:59,070
is to have two worlds in which the test

00:04:57,120 --> 00:05:00,810
runs this comes for free if you use

00:04:59,070 --> 00:05:04,110
cucumber but you can implement this and

00:05:00,810 --> 00:05:06,630
other testing frameworks too so let's go

00:05:04,110 --> 00:05:09,420
line by line in our test so the first

00:05:06,630 --> 00:05:11,580
line is given Tony is logged in okay

00:05:09,420 --> 00:05:13,230
well our client is probably sending a

00:05:11,580 --> 00:05:15,030
token or a cookie or something like that

00:05:13,230 --> 00:05:17,520
so we actually don't need to do anything

00:05:15,030 --> 00:05:19,620
on the client on the server we simply

00:05:17,520 --> 00:05:23,190
need to set the context for the graph QL

00:05:19,620 --> 00:05:26,970
requests so the second line is and he

00:05:23,190 --> 00:05:29,250
has a balance of $150 again on the

00:05:26,970 --> 00:05:31,530
server we probably shouldn't need to set

00:05:29,250 --> 00:05:34,320
a test database or some kind of value

00:05:31,530 --> 00:05:36,060
that we're going to work against on the

00:05:34,320 --> 00:05:38,970
client we might not need to set anything

00:05:36,060 --> 00:05:42,330
kind depends on the app the third line

00:05:38,970 --> 00:05:43,380
when he transfers $100 to Rodrigo okay

00:05:42,330 --> 00:05:44,850
this is where the action takes place

00:05:43,380 --> 00:05:48,120
this is where we trigger the mutation

00:05:44,850 --> 00:05:50,040
and this is where we are setting

00:05:48,120 --> 00:05:52,590
variables making sure they passed those

00:05:50,040 --> 00:05:54,930
arguments this is where we trigger the

00:05:52,590 --> 00:05:57,570
mutation and and then finally we get to

00:05:54,930 --> 00:06:01,740
the last step that his balance is $50 on

00:05:57,570 --> 00:06:04,140
the client we translate this to check

00:06:01,740 --> 00:06:08,340
the UI result and on the server we check

00:06:04,140 --> 00:06:10,260
the response so if we do these ties our

00:06:08,340 --> 00:06:12,780
tests together and we can run either

00:06:10,260 --> 00:06:16,110
client or server independently I remain

00:06:12,780 --> 00:06:17,940
confident in our end and process that

00:06:16,110 --> 00:06:19,410
means we can use fast and lean tests

00:06:17,940 --> 00:06:21,510
that don't slow down our feedback loop

00:06:19,410 --> 00:06:22,160
so tests in this paradigm can be very

00:06:21,510 --> 00:06:25,800
fast

00:06:22,160 --> 00:06:28,170
certainly sub-second so there's a few

00:06:25,800 --> 00:06:30,210
caveats so first of all you'll probably

00:06:28,170 --> 00:06:32,780
still want to have some and end tests

00:06:30,210 --> 00:06:35,700
you can just use a lot less of them

00:06:32,780 --> 00:06:37,830
there's also a risk of mistakes that

00:06:35,700 --> 00:06:40,080
break the contract without you realizing

00:06:37,830 --> 00:06:41,580
it context is probably the most likely

00:06:40,080 --> 00:06:44,040
place for a problem and that's one

00:06:41,580 --> 00:06:44,480
reason why off is still a great place

00:06:44,040 --> 00:06:47,450
for

00:06:44,480 --> 00:06:49,490
real end-to-end tests finally the setup

00:06:47,450 --> 00:06:51,650
for these tests is more complex than

00:06:49,490 --> 00:06:53,270
plain old integration tests although

00:06:51,650 --> 00:06:56,540
it's probably easier and faster than

00:06:53,270 --> 00:06:56,960
setting up end-to-end tests and for your

00:06:56,540 --> 00:06:58,400
trouble

00:06:56,960 --> 00:07:01,550
you get tests that are a whole lot

00:06:58,400 --> 00:07:03,410
faster and graph QL makes this process

00:07:01,550 --> 00:07:05,270
really easy because it's so well

00:07:03,410 --> 00:07:07,250
specified that you can you can use a

00:07:05,270 --> 00:07:09,980
common infrastructure for all of your

00:07:07,250 --> 00:07:11,510
operations it's also a really nice

00:07:09,980 --> 00:07:14,870
extension of the graph QL first

00:07:11,510 --> 00:07:17,210
philosophy so you can not only agree on

00:07:14,870 --> 00:07:18,590
the schema but do the tests and then the

00:07:17,210 --> 00:07:19,850
front end person can work on the front

00:07:18,590 --> 00:07:21,140
end what I haven't without having to

00:07:19,850 --> 00:07:24,800
stand up the back end and have really

00:07:21,140 --> 00:07:26,000
rapid tests so what do you think if

00:07:24,800 --> 00:07:28,370
you're wondering where you can get this

00:07:26,000 --> 00:07:30,500
we've done a proof of concept but we

00:07:28,370 --> 00:07:32,060
haven't published it yet we have used

00:07:30,500 --> 00:07:34,490
this in production code but I'd love to

00:07:32,060 --> 00:07:37,610
hear your reaction so come find me if

00:07:34,490 --> 00:07:39,280
you'd like to talk about this and thank

00:07:37,610 --> 00:07:44,790
you very much for your time

00:07:39,280 --> 00:07:44,790

YouTube URL: https://www.youtube.com/watch?v=tECxsJf4UqU


