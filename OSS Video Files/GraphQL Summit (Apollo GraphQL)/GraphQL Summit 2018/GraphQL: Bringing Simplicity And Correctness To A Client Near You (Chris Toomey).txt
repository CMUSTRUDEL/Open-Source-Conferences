Title: GraphQL: Bringing Simplicity And Correctness To A Client Near You (Chris Toomey)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 8, 2018

Chris Toomey, Development Director at thoughtbot, details how GraphQL can bring simplicity and consistency across your clients, while simultaneously improving productivity and correctness.

Learn more:  https://summit.graphql.com
Captions: 
	00:00:08,230 --> 00:00:11,619
can everyone hear me all the way in the

00:00:09,730 --> 00:00:15,810
back yeah somebody in the back wave to

00:00:11,619 --> 00:00:17,890
me yeah perfect thank you so yes I am

00:00:15,810 --> 00:00:20,199
incredibly excited to be here today to

00:00:17,890 --> 00:00:22,419
be part of the graph QL community it is

00:00:20,199 --> 00:00:24,849
absolutely amazing seeing the adoption

00:00:22,419 --> 00:00:26,560
curve of this technology graph QL is

00:00:24,849 --> 00:00:28,539
only a few years old and yet it seems to

00:00:26,560 --> 00:00:31,179
have taken off in a way that I've not

00:00:28,539 --> 00:00:32,710
really seen many other technologies gain

00:00:31,179 --> 00:00:34,690
the sort of adoption that graph QL has

00:00:32,710 --> 00:00:37,989
looking around here just at this

00:00:34,690 --> 00:00:39,940
conference the breadth of industries and

00:00:37,989 --> 00:00:41,590
companies that is represented and the

00:00:39,940 --> 00:00:44,890
depth of investment that folks are

00:00:41,590 --> 00:00:46,120
making into graph QL is it's absolutely

00:00:44,890 --> 00:00:48,489
fantastic and it's really heartening to

00:00:46,120 --> 00:00:50,230
me as I continue to dig into graph QL

00:00:48,489 --> 00:00:51,969
and explore the different options that

00:00:50,230 --> 00:00:53,980
are available there now personally I

00:00:51,969 --> 00:00:55,030
started as a graph QL skeptic I tried

00:00:53,980 --> 00:00:57,039
things out on the client side and I

00:00:55,030 --> 00:00:58,809
thought this is fantastic I love this

00:00:57,039 --> 00:01:00,250
but I imagine somebody on the server

00:00:58,809 --> 00:01:02,859
side is gonna have to pay the bill this

00:01:00,250 --> 00:01:04,780
is a more complicated thing to do and

00:01:02,859 --> 00:01:07,270
yet the deeper that I dig into this

00:01:04,780 --> 00:01:09,369
world the more that I think graph QL is

00:01:07,270 --> 00:01:11,710
actually one of the more fundamental and

00:01:09,369 --> 00:01:13,270
needed changes in the world of

00:01:11,710 --> 00:01:15,190
technology that we've seen in many years

00:01:13,270 --> 00:01:16,690
obviously that's somewhat of a lofty

00:01:15,190 --> 00:01:17,890
claim but I'm amongst friends here so

00:01:16,690 --> 00:01:19,869
hopefully you're all roughly in

00:01:17,890 --> 00:01:22,539
agreement with that now in this talk I

00:01:19,869 --> 00:01:25,270
want to explore some of the architecture

00:01:22,539 --> 00:01:27,910
and philosophy that under undermines all

00:01:25,270 --> 00:01:29,770
of graph QL I want to do it through the

00:01:27,910 --> 00:01:30,819
lens of client-side development but I

00:01:29,770 --> 00:01:33,130
think we'll be talking about bigger

00:01:30,819 --> 00:01:34,989
things as well both in the server and

00:01:33,130 --> 00:01:37,840
then the way graph QL can inform our

00:01:34,989 --> 00:01:39,489
systems so very briefly about me once

00:01:37,840 --> 00:01:41,560
again my name is Chris to me I work at a

00:01:39,489 --> 00:01:44,050
development consultancy development and

00:01:41,560 --> 00:01:46,360
design called plop OTT and you can find

00:01:44,050 --> 00:01:48,489
me on the internet at Twitter I'm at

00:01:46,360 --> 00:01:49,899
Chris to me and I also host a podcast

00:01:48,489 --> 00:01:51,660
called the bike shed which is at

00:01:49,899 --> 00:01:53,709
underscore bike shed on Twitter I

00:01:51,660 --> 00:01:55,300
working at a consultancy I think

00:01:53,709 --> 00:01:56,619
actually looking at the majority of the

00:01:55,300 --> 00:01:57,849
talks that's actually somewhat different

00:01:56,619 --> 00:01:59,860
than most of the other things that we've

00:01:57,849 --> 00:02:01,869
seen there are a lot of folks coming

00:01:59,860 --> 00:02:03,429
from product companies working on a

00:02:01,869 --> 00:02:05,860
little bit more focused in a particular

00:02:03,429 --> 00:02:07,270
domain or industry but by virtue of

00:02:05,860 --> 00:02:10,149
working at a consultancy I get to see a

00:02:07,270 --> 00:02:11,560
cross-section of different problems of

00:02:10,149 --> 00:02:13,830
different technologies of different

00:02:11,560 --> 00:02:15,819
businesses of different industries and

00:02:13,830 --> 00:02:18,310
uniformly I think graph QL is a

00:02:15,819 --> 00:02:20,430
technology that can help in almost all

00:02:18,310 --> 00:02:22,920
of these cases now

00:02:20,430 --> 00:02:24,060
reason why I think this is we're gonna

00:02:22,920 --> 00:02:26,790
take a little bit of a historical

00:02:24,060 --> 00:02:29,400
journey here together way back when

00:02:26,790 --> 00:02:31,650
let's say ten years ago so eternity in

00:02:29,400 --> 00:02:34,140
internet years applications were much

00:02:31,650 --> 00:02:35,879
simpler we had a single application it

00:02:34,140 --> 00:02:38,010
probably had a database it rendered some

00:02:35,879 --> 00:02:40,189
HTML sent that down to the browser and

00:02:38,010 --> 00:02:43,859
then we just kind of did that on a loop

00:02:40,189 --> 00:02:45,810
this is this was a simpler time this was

00:02:43,859 --> 00:02:47,819
an easier time to build things but over

00:02:45,810 --> 00:02:49,319
time things have moved just an aside

00:02:47,819 --> 00:02:51,750
some people may call this the monolith

00:02:49,319 --> 00:02:54,060
both in better or worse terms depending

00:02:51,750 --> 00:02:55,590
on how you consider that but over time

00:02:54,060 --> 00:02:59,430
we've seen the transition from these

00:02:55,590 --> 00:03:01,019
simpler applications to platforms so at

00:02:59,430 --> 00:03:02,939
a minimum it's pretty much table stakes

00:03:01,019 --> 00:03:04,409
at this point to have an iOS app not a

00:03:02,939 --> 00:03:07,260
requirement we can get away with mobile

00:03:04,409 --> 00:03:09,060
web that in a lot of cases an iOS app is

00:03:07,260 --> 00:03:11,219
pretty much a requirement

00:03:09,060 --> 00:03:13,290
additionally then we may want to see

00:03:11,219 --> 00:03:14,700
additional behavior in our web apps we

00:03:13,290 --> 00:03:17,489
want to see more performance we want to

00:03:14,700 --> 00:03:19,019
see better interactive things closer to

00:03:17,489 --> 00:03:21,750
what we're experiencing in iOS apps in

00:03:19,019 --> 00:03:23,099
mobile so we're starting to fracture out

00:03:21,750 --> 00:03:25,229
our world again still maybe we're

00:03:23,099 --> 00:03:27,959
connected to the monolith but this keeps

00:03:25,229 --> 00:03:30,030
expanding and the more I look at

00:03:27,959 --> 00:03:32,129
companies out there the less I'm seeing

00:03:30,030 --> 00:03:33,690
it's a simple crud app for project

00:03:32,129 --> 00:03:35,819
management that's it it's very it's very

00:03:33,690 --> 00:03:38,099
straight forward more what I'm seeing

00:03:35,819 --> 00:03:40,199
our platforms we have Airbnb which is a

00:03:38,099 --> 00:03:41,849
platform for connecting folks with

00:03:40,199 --> 00:03:43,530
places to stay and folks who want to

00:03:41,849 --> 00:03:45,389
stay there as well as supporting

00:03:43,530 --> 00:03:48,000
back-end teams that need to curate and

00:03:45,389 --> 00:03:49,739
manage all of that content so each of

00:03:48,000 --> 00:03:51,689
those are different facets on the data

00:03:49,739 --> 00:03:53,939
that we have different points of view

00:03:51,689 --> 00:03:56,099
and each of them also may have an iOS

00:03:53,939 --> 00:03:58,739
app an Android app a web app or maybe

00:03:56,099 --> 00:04:01,379
even multiple of them so we're seeing

00:03:58,739 --> 00:04:03,479
this fracturing of clients which i think

00:04:01,379 --> 00:04:05,790
is potentially a good thing this allows

00:04:03,479 --> 00:04:08,220
for more purposeful experiences better

00:04:05,790 --> 00:04:09,180
workflows for the users but it is

00:04:08,220 --> 00:04:11,310
complexity

00:04:09,180 --> 00:04:13,199
I think that's we can't really argue

00:04:11,310 --> 00:04:14,759
against that having more clients having

00:04:13,199 --> 00:04:16,169
more things that need to understand how

00:04:14,759 --> 00:04:20,220
our application works is a more

00:04:16,169 --> 00:04:21,780
complicated world similarly on the other

00:04:20,220 --> 00:04:24,360
side of the aisle we're seeing a

00:04:21,780 --> 00:04:26,430
transition from traditional monoliths

00:04:24,360 --> 00:04:28,950
single sources of truth into a

00:04:26,430 --> 00:04:30,719
fracturing of services here I've

00:04:28,950 --> 00:04:32,190
represented what a potential

00:04:30,719 --> 00:04:33,729
organization of that might look like and

00:04:32,190 --> 00:04:36,460
this to me is

00:04:33,729 --> 00:04:37,870
is probably the most concerning version

00:04:36,460 --> 00:04:40,270
of how this can play out we have a

00:04:37,870 --> 00:04:42,039
number of client applications talking to

00:04:40,270 --> 00:04:44,050
both the central monolith but also to

00:04:42,039 --> 00:04:45,520
some of the services we have even

00:04:44,050 --> 00:04:48,370
bi-directional communication between

00:04:45,520 --> 00:04:50,379
some of the services and the clients and

00:04:48,370 --> 00:04:53,620
even just from a mathematical standpoint

00:04:50,379 --> 00:04:56,199
this is more complex now I want to pause

00:04:53,620 --> 00:04:57,069
here and switch over to instead of

00:04:56,199 --> 00:04:58,300
thinking about it in terms of

00:04:57,069 --> 00:05:00,819
architecture I want to think about this

00:04:58,300 --> 00:05:03,659
in terms of technology running the clock

00:05:00,819 --> 00:05:05,559
back about those 10 15 years ago we

00:05:03,659 --> 00:05:07,240
implemented the vast majority of our

00:05:05,559 --> 00:05:09,789
logic on the server side or rendering

00:05:07,240 --> 00:05:11,319
HTML we send that down to the client now

00:05:09,789 --> 00:05:12,729
if we take the clock forward a few years

00:05:11,319 --> 00:05:14,319
we decide we want a little bit more

00:05:12,729 --> 00:05:17,860
behavior out of our systems we want a

00:05:14,319 --> 00:05:20,919
little bit more interactive mnestheus

00:05:17,860 --> 00:05:22,689
and so jQuery came along and at the time

00:05:20,919 --> 00:05:24,460
jQuery was an absolute godsend because

00:05:22,689 --> 00:05:25,960
it provided some organizations some

00:05:24,460 --> 00:05:28,210
common behavior across the different

00:05:25,960 --> 00:05:30,639
browsers and it allowed us to push more

00:05:28,210 --> 00:05:32,559
of our logic to the client side I think

00:05:30,639 --> 00:05:33,819
this was largely a good trend but then

00:05:32,559 --> 00:05:34,990
we kind of kept moving backbone

00:05:33,819 --> 00:05:37,059
personally was the next thing that I

00:05:34,990 --> 00:05:39,819
moved on to spent a few years in

00:05:37,059 --> 00:05:42,069
backbone lands and again moving more of

00:05:39,819 --> 00:05:43,479
our work to the client side at this

00:05:42,069 --> 00:05:46,089
point now we're rendering templates on

00:05:43,479 --> 00:05:47,560
the client side actually a good portion

00:05:46,089 --> 00:05:50,020
of the logic of our systems has moved

00:05:47,560 --> 00:05:51,129
and then as we keep going amber and

00:05:50,020 --> 00:05:53,349
angular we're sort of the next

00:05:51,129 --> 00:05:55,169
incremental step here really pushing

00:05:53,349 --> 00:05:57,490
that logic over to the client side

00:05:55,169 --> 00:05:59,349
alongside underpinning all of this would

00:05:57,490 --> 00:06:01,509
be obviously the adoption of REST API s

00:05:59,349 --> 00:06:03,819
and the proliferation of those which

00:06:01,509 --> 00:06:06,759
again are not necessarily bad in and of

00:06:03,819 --> 00:06:07,930
themselves the final step of the most

00:06:06,759 --> 00:06:12,039
recent one that I at least personally

00:06:07,930 --> 00:06:13,360
worked on was reacting Redux and as I

00:06:12,039 --> 00:06:14,919
first started to work with them I found

00:06:13,360 --> 00:06:17,680
them to be a breath of fresh air react

00:06:14,919 --> 00:06:19,479
and it's the view is a function of the

00:06:17,680 --> 00:06:21,699
data I absolutely love that Redux

00:06:19,479 --> 00:06:23,649
provided a clarity and the way that

00:06:21,699 --> 00:06:24,849
we're manipulating state but if we're

00:06:23,649 --> 00:06:26,259
being honest it was a lot of code and a

00:06:24,849 --> 00:06:26,969
lot of logic that still lived in our

00:06:26,259 --> 00:06:30,039
systems

00:06:26,969 --> 00:06:32,379
now this isn't inherently a bad thing I

00:06:30,039 --> 00:06:34,360
don't want to you know push any judgment

00:06:32,379 --> 00:06:35,259
on to this but when we look at it in the

00:06:34,360 --> 00:06:37,419
context of what was happening

00:06:35,259 --> 00:06:39,279
architectural II I think it becomes a

00:06:37,419 --> 00:06:41,229
problem when we have the fan-out of all

00:06:39,279 --> 00:06:42,519
of these clients and potentially the

00:06:41,229 --> 00:06:43,959
complication of splitting out our

00:06:42,519 --> 00:06:45,969
back-end into many services and

00:06:43,959 --> 00:06:47,560
encouraging communication between them

00:06:45,969 --> 00:06:50,200
this is

00:06:47,560 --> 00:06:52,060
far too much complexity for clients that

00:06:50,200 --> 00:06:54,580
are already owning too much of the logic

00:06:52,060 --> 00:06:57,250
to take on so coming back to our

00:06:54,580 --> 00:06:59,800
technology for the first time in a long

00:06:57,250 --> 00:07:01,600
time with graph QL I think we've seen a

00:06:59,800 --> 00:07:03,669
shift back we've taken some of that

00:07:01,600 --> 00:07:05,620
logic that was being implemented on the

00:07:03,669 --> 00:07:07,090
client and specifically in each of the

00:07:05,620 --> 00:07:08,650
different clients that we had and we've

00:07:07,090 --> 00:07:10,780
been able to push it back to the server

00:07:08,650 --> 00:07:13,480
graph QL provides us a different layer a

00:07:10,780 --> 00:07:15,010
different place to house that logic and

00:07:13,480 --> 00:07:16,419
I cannot stress enough how happy I am

00:07:15,010 --> 00:07:17,860
that this is the world that we get to

00:07:16,419 --> 00:07:20,560
live in now how meaningful of a change

00:07:17,860 --> 00:07:21,880
that I think this is so this is what it

00:07:20,560 --> 00:07:24,310
looks like in terms of the architecture

00:07:21,880 --> 00:07:26,229
diagram we've now introduced graph QL as

00:07:24,310 --> 00:07:27,760
the single central API it's that gateway

00:07:26,229 --> 00:07:29,110
this is a common theme that we've seen

00:07:27,760 --> 00:07:31,389
throughout the talks at the conference

00:07:29,110 --> 00:07:33,400
so far and actually I like to take it

00:07:31,389 --> 00:07:35,710
one step further which is let's hide all

00:07:33,400 --> 00:07:38,080
that back-end stuff so not only have we

00:07:35,710 --> 00:07:39,760
provided that choke point the fan-in and

00:07:38,080 --> 00:07:41,650
fan-out of the graph QL API there in the

00:07:39,760 --> 00:07:43,389
middle but we can actually use that to

00:07:41,650 --> 00:07:45,790
truly hi to the backend from ourselves

00:07:43,389 --> 00:07:46,960
and we've heard this repeated as a best

00:07:45,790 --> 00:07:47,950
practice from a number of different

00:07:46,960 --> 00:07:51,550
folks throughout the conference

00:07:47,950 --> 00:07:53,229
do not let your graph QL API reflect the

00:07:51,550 --> 00:07:56,830
structure of the database tables the

00:07:53,229 --> 00:08:00,070
services etc use the graph QL API as a a

00:07:56,830 --> 00:08:02,680
point to think about the design of your

00:08:00,070 --> 00:08:04,450
domain what is true about your platform

00:08:02,680 --> 00:08:06,100
and again this all speaks to the

00:08:04,450 --> 00:08:08,890
transition we've had from applications

00:08:06,100 --> 00:08:11,320
to platforms at its heart we still need

00:08:08,890 --> 00:08:13,360
to provide slices of the same big data

00:08:11,320 --> 00:08:15,130
piece to each of these clients but they

00:08:13,360 --> 00:08:16,690
want slightly different versions that

00:08:15,130 --> 00:08:17,830
doesn't mean we necessarily want to

00:08:16,690 --> 00:08:19,389
fracture that out into the different

00:08:17,830 --> 00:08:23,380
services or at least not expose that to

00:08:19,389 --> 00:08:24,580
the clients so now with all of that in

00:08:23,380 --> 00:08:26,590
mind we can take a look at some of the

00:08:24,580 --> 00:08:28,690
fundamental aspects of graph QL and see

00:08:26,590 --> 00:08:29,889
how they affect all of this so one of

00:08:28,690 --> 00:08:31,120
the core pieces of graphic UL is the

00:08:29,889 --> 00:08:33,339
idea that you get what you asked for

00:08:31,120 --> 00:08:35,110
rather than an rest you hit an endpoint

00:08:33,339 --> 00:08:36,909
you get back whatever data with graph QL

00:08:35,110 --> 00:08:38,110
you explicitly request the fields that

00:08:36,909 --> 00:08:40,300
you want and only the fields that you

00:08:38,110 --> 00:08:42,039
want often we talk about this in terms

00:08:40,300 --> 00:08:43,300
of performance this is very useful

00:08:42,039 --> 00:08:45,580
because it reduces the size of the

00:08:43,300 --> 00:08:47,380
payload coming back from the server but

00:08:45,580 --> 00:08:49,779
frankly I'm much more interested in this

00:08:47,380 --> 00:08:51,820
because of the freedom and ownership

00:08:49,779 --> 00:08:54,279
that this gives the client the client is

00:08:51,820 --> 00:08:56,500
able to say explicitly declaratively

00:08:54,279 --> 00:08:57,820
this is what I need the server actually

00:08:56,500 --> 00:08:59,290
gets some benefits out of this as well

00:08:57,820 --> 00:09:01,180
because it knows the fields that are

00:08:59,290 --> 00:09:03,220
being used with rest it was

00:09:01,180 --> 00:09:06,040
largely a black box we didn't know what

00:09:03,220 --> 00:09:07,450
fields anyone was using and so every

00:09:06,040 --> 00:09:09,490
change potentially could be a breaking

00:09:07,450 --> 00:09:11,080
change but we've graphed Y well we get a

00:09:09,490 --> 00:09:13,030
much more meaningful conversation

00:09:11,080 --> 00:09:15,460
between the client and server and we

00:09:13,030 --> 00:09:19,990
allow each client to own the little

00:09:15,460 --> 00:09:23,050
piece of data that it needs it seems to

00:09:19,990 --> 00:09:24,400
have left us now the next piece of the

00:09:23,050 --> 00:09:26,080
graph QL picture that I really think is

00:09:24,400 --> 00:09:28,270
interesting is getting related resources

00:09:26,080 --> 00:09:30,670
in a single query now again a lot of

00:09:28,270 --> 00:09:33,100
focus with this is often on performance

00:09:30,670 --> 00:09:34,480
this allows us to reduce the number of

00:09:33,100 --> 00:09:36,280
round trips which can be incredibly

00:09:34,480 --> 00:09:38,320
impactful for especially mobile clients

00:09:36,280 --> 00:09:39,880
but in general if we can make one

00:09:38,320 --> 00:09:42,250
request and get all the data we need

00:09:39,880 --> 00:09:43,690
that's gonna be better but I'm actually

00:09:42,250 --> 00:09:46,630
much more interested in it from a

00:09:43,690 --> 00:09:48,520
complexity standpoint if we needed to

00:09:46,630 --> 00:09:50,350
fan out and make multiple requests

00:09:48,520 --> 00:09:51,910
especially multiple dependent requests

00:09:50,350 --> 00:09:53,560
first get the information about the

00:09:51,910 --> 00:09:55,330
human then we have a bunch of IDs send

00:09:53,560 --> 00:09:57,460
those into the other back-end to get the

00:09:55,330 --> 00:09:59,140
starships and then we need to merge all

00:09:57,460 --> 00:10:01,410
of that data together that's data

00:09:59,140 --> 00:10:03,310
manipulation that's data handling that's

00:10:01,410 --> 00:10:05,290
orchestration that every single one of

00:10:03,310 --> 00:10:08,860
our clients needs to do both graph QL

00:10:05,290 --> 00:10:10,090
were able to move away from that and

00:10:08,860 --> 00:10:11,740
lastly we have the schema and the type

00:10:10,090 --> 00:10:12,910
system probably my favorite feature of

00:10:11,740 --> 00:10:15,220
graphic you all the fact that it is so

00:10:12,910 --> 00:10:18,010
core and central to the whole thing this

00:10:15,220 --> 00:10:20,170
lets us describe provide a common

00:10:18,010 --> 00:10:22,420
language for what is true about our

00:10:20,170 --> 00:10:25,750
domain what can we do what can we ask

00:10:22,420 --> 00:10:26,920
for how can we change things and what

00:10:25,750 --> 00:10:28,990
are the different variants of how we can

00:10:26,920 --> 00:10:32,350
do all of those things all of this is

00:10:28,990 --> 00:10:34,810
fantastic and it allows for or I think

00:10:32,350 --> 00:10:36,370
it supports the idea of having small

00:10:34,810 --> 00:10:37,810
focused clients that can each do what

00:10:36,370 --> 00:10:39,970
they want well but can vary

00:10:37,810 --> 00:10:42,070
independently because we have this

00:10:39,970 --> 00:10:45,850
strongly typed contract between the

00:10:42,070 --> 00:10:48,760
server and the clients so with that as

00:10:45,850 --> 00:10:51,580
some context I have a sample app that I

00:10:48,760 --> 00:10:52,690
put together just on this screen so this

00:10:51,580 --> 00:10:55,000
is going to be the app that we'll work

00:10:52,690 --> 00:10:57,970
through as sort of a case study of some

00:10:55,000 --> 00:10:59,620
of these pieces in practice is a very

00:10:57,970 --> 00:11:01,900
simple app but I think it's just enough

00:10:59,620 --> 00:11:03,580
to give us something to talk about so to

00:11:01,900 --> 00:11:05,470
start we have a search bar here this is

00:11:03,580 --> 00:11:08,140
connected to the github graph QL API and

00:11:05,470 --> 00:11:09,370
I can type in my name run search and

00:11:08,140 --> 00:11:10,900
you'll see that will populate out here

00:11:09,370 --> 00:11:12,820
with a few tiles one for each of the

00:11:10,900 --> 00:11:13,740
people that person happens to be my

00:11:12,820 --> 00:11:15,750
brother irrelevant

00:11:13,740 --> 00:11:17,460
but just thought I'd share I can also

00:11:15,750 --> 00:11:18,960
load more and sit down here we get

00:11:17,460 --> 00:11:22,230
pagination all these things fall pretty

00:11:18,960 --> 00:11:24,480
naturally out of reactant Apollo Apollo

00:11:22,230 --> 00:11:25,710
is the framework that we're using behind

00:11:24,480 --> 00:11:27,690
the scenes here and we'll dig into that

00:11:25,710 --> 00:11:28,950
in just a second but now for any of

00:11:27,690 --> 00:11:31,440
these users I can go ahead and click on

00:11:28,950 --> 00:11:32,730
them and here we have the summary of me

00:11:31,440 --> 00:11:34,830
so we have my login we have my name

00:11:32,730 --> 00:11:36,240
description we have the organization's

00:11:34,830 --> 00:11:37,980
that I'm part of on github and then we

00:11:36,240 --> 00:11:40,740
have a list of all the repositories I

00:11:37,980 --> 00:11:42,060
was doing that just a little bit those

00:11:40,740 --> 00:11:43,320
of you good with pattern matching we'll

00:11:42,060 --> 00:11:45,720
notice that I spend far too much time

00:11:43,320 --> 00:11:48,420
writing vim script this is not a thing

00:11:45,720 --> 00:11:50,100
that I recommend anyone do I swear that

00:11:48,420 --> 00:11:51,210
I do write other things in vim script

00:11:50,100 --> 00:11:53,340
but this is actually my most popular

00:11:51,210 --> 00:11:54,930
repositories I'm mostly known on the

00:11:53,340 --> 00:11:56,730
internet for reading vim script so maybe

00:11:54,930 --> 00:11:58,800
today will change that but it's actually

00:11:56,730 --> 00:12:00,210
one down here which is Ruby but if you

00:11:58,800 --> 00:12:01,320
look closer actually it's a vim plugin

00:12:00,210 --> 00:12:04,680
that just happens to be written in Ruby

00:12:01,320 --> 00:12:05,910
so it's aside from the point but if we

00:12:04,680 --> 00:12:07,530
look at these at first they seem like

00:12:05,910 --> 00:12:09,060
relatively simple pieces of data but

00:12:07,530 --> 00:12:11,520
actually there's a lot going on here so

00:12:09,060 --> 00:12:14,880
each of these has a link it has the

00:12:11,520 --> 00:12:16,830
title it has the description it has some

00:12:14,880 --> 00:12:19,500
metadata about the repository including

00:12:16,830 --> 00:12:21,000
the proper color of the language that is

00:12:19,500 --> 00:12:22,710
represented and we've got the fork count

00:12:21,000 --> 00:12:23,940
the star count and then lastly we have

00:12:22,710 --> 00:12:25,170
the ability this is the only piece where

00:12:23,940 --> 00:12:26,520
we can actually change data but if I

00:12:25,170 --> 00:12:28,410
come up here and I click the unstart

00:12:26,520 --> 00:12:29,880
button we got a loading state and now

00:12:28,410 --> 00:12:31,800
we've changed the state of that button

00:12:29,880 --> 00:12:33,870
and also if you see down here that's two

00:12:31,800 --> 00:12:36,120
three one two if I start it's two three

00:12:33,870 --> 00:12:37,800
one three so we'll look at how that's

00:12:36,120 --> 00:12:39,450
implemented but I just wanted to give

00:12:37,800 --> 00:12:42,090
the the framework of the actual

00:12:39,450 --> 00:12:45,270
application itself and now we can come

00:12:42,090 --> 00:12:48,300
in here and dive in so the first thing

00:12:45,270 --> 00:12:51,120
that is interesting to me with graph QL

00:12:48,300 --> 00:12:53,550
and with react particularly and we're

00:12:51,120 --> 00:12:55,590
gonna use react as the test here and

00:12:53,550 --> 00:12:57,480
Apollo client none of these things are

00:12:55,590 --> 00:12:58,740
truly specific or require those

00:12:57,480 --> 00:13:00,990
technologies but they happen to work

00:12:58,740 --> 00:13:02,430
extremely well and probably be weird for

00:13:00,990 --> 00:13:04,470
me to use anything else than Apollo at

00:13:02,430 --> 00:13:05,820
this conference but I am a huge fan of

00:13:04,470 --> 00:13:09,780
it and I think it really does a great

00:13:05,820 --> 00:13:11,160
job so by virtue of all of these pieces

00:13:09,780 --> 00:13:13,050
that we talked about with graph QL by

00:13:11,160 --> 00:13:15,270
the consistent structure that it

00:13:13,050 --> 00:13:16,320
provides this is all the configuration

00:13:15,270 --> 00:13:18,270
that we needed we're able to set up the

00:13:16,320 --> 00:13:19,710
client basically just pointed at the URL

00:13:18,270 --> 00:13:21,600
there's a little bit of off logic in

00:13:19,710 --> 00:13:23,670
there but that's it if we think about a

00:13:21,600 --> 00:13:24,960
REST API we would have to manage all of

00:13:23,670 --> 00:13:27,450
the different endpoints think about how

00:13:24,960 --> 00:13:28,890
we're D structuring the resources

00:13:27,450 --> 00:13:30,780
there's actually caching going on behind

00:13:28,890 --> 00:13:32,730
here there's management of error states

00:13:30,780 --> 00:13:35,130
there's a lot that Apollo can do for us

00:13:32,730 --> 00:13:37,620
just by convention based on the graph QL

00:13:35,130 --> 00:13:39,210
standard now we jump down here this is

00:13:37,620 --> 00:13:40,230
the outer shell of the whole app and

00:13:39,210 --> 00:13:41,970
we're able to just provide that

00:13:40,230 --> 00:13:43,740
configured Apollo client in and

00:13:41,970 --> 00:13:46,950
everything's great that's the entirety

00:13:43,740 --> 00:13:48,900
of the configuration and I absolutely

00:13:46,950 --> 00:13:50,310
love how simple that is how how little

00:13:48,900 --> 00:13:52,800
code was necessary to actually get up

00:13:50,310 --> 00:13:54,210
and running so now as we dig in this is

00:13:52,800 --> 00:13:56,040
the first component that we'll be taking

00:13:54,210 --> 00:13:59,700
a look at this is the user list so if we

00:13:56,040 --> 00:14:01,170
come back to the app this is this whole

00:13:59,700 --> 00:14:03,300
page here so not including the search

00:14:01,170 --> 00:14:05,160
bar but the whole list of results down

00:14:03,300 --> 00:14:06,530
here including the load more button so

00:14:05,160 --> 00:14:09,540
that's what we're looking at right now

00:14:06,530 --> 00:14:11,880
and again we're able to see very little

00:14:09,540 --> 00:14:13,200
code which i think is a great thing but

00:14:11,880 --> 00:14:14,670
perhaps most importantly is the fact

00:14:13,200 --> 00:14:17,400
that we're able to co-locate the query

00:14:14,670 --> 00:14:19,110
beside the component now I'm guessing

00:14:17,400 --> 00:14:20,670
this is common for most of you folks

00:14:19,110 --> 00:14:22,800
doing this but this is still something

00:14:20,670 --> 00:14:25,230
that I haven't quite gotten over I'm

00:14:22,800 --> 00:14:27,210
still extremely excited about this would

00:14:25,230 --> 00:14:29,730
be impossible in a rest system because

00:14:27,210 --> 00:14:32,100
each component would then have a

00:14:29,730 --> 00:14:34,440
different view of the world this is

00:14:32,100 --> 00:14:35,940
really only possible in the context of

00:14:34,440 --> 00:14:38,070
the type system the graph QL provides

00:14:35,940 --> 00:14:40,890
and to highlight that if we jump down

00:14:38,070 --> 00:14:42,360
here what we're doing is we're running a

00:14:40,890 --> 00:14:44,760
search we're specifying the number of

00:14:42,360 --> 00:14:46,530
people that we want the actual search

00:14:44,760 --> 00:14:48,990
string that we're using we're refining

00:14:46,530 --> 00:14:50,790
it down to the type of user and then

00:14:48,990 --> 00:14:52,710
from there we're actually doing there's

00:14:50,790 --> 00:14:54,840
a little bit of pagination info what's

00:14:52,710 --> 00:14:56,100
interesting is if I introduce a typo yes

00:14:54,840 --> 00:14:57,450
lint is running in the background it's

00:14:56,100 --> 00:14:59,550
looking at my scheme and it's able to

00:14:57,450 --> 00:15:01,620
live tell me no this is not acceptable

00:14:59,550 --> 00:15:03,000
you've produced a typo here and even

00:15:01,620 --> 00:15:04,770
give me the wonderful did you mean name

00:15:03,000 --> 00:15:07,320
I did mean name thank you yes Lynn

00:15:04,770 --> 00:15:09,210
that's so nice of you this would be

00:15:07,320 --> 00:15:11,550
impossible again in a REST API are not

00:15:09,210 --> 00:15:13,020
impossible but incredibly difficult I've

00:15:11,550 --> 00:15:15,330
tried to do similar things with JSON

00:15:13,020 --> 00:15:16,860
schema and other documentation tools but

00:15:15,330 --> 00:15:19,740
it always ends up being a ton of work

00:15:16,860 --> 00:15:21,600
and rarely correct or rarely consistent

00:15:19,740 --> 00:15:23,790
for that long but because the type

00:15:21,600 --> 00:15:26,760
system is core to graph QL this just

00:15:23,790 --> 00:15:28,320
sort of naturally falls out this same

00:15:26,760 --> 00:15:29,760
sort of thing is true if we jump up here

00:15:28,320 --> 00:15:30,690
if we make this into a string that's

00:15:29,760 --> 00:15:33,900
going to highlight that we have an

00:15:30,690 --> 00:15:35,220
invalid value if I type typo here same

00:15:33,900 --> 00:15:37,710
sort of thing so we're able to get deep

00:15:35,220 --> 00:15:38,790
validation of these queries which is

00:15:37,710 --> 00:15:40,080
really the only way that it would be

00:15:38,790 --> 00:15:40,760
possible to have them spread throughout

00:15:40,080 --> 00:15:41,810
your code

00:15:40,760 --> 00:15:43,910
it's the idea that they're living

00:15:41,810 --> 00:15:45,710
alongside each component it's only

00:15:43,910 --> 00:15:49,970
possible in the context of this sort of

00:15:45,710 --> 00:15:52,040
validation but as we take a little bit

00:15:49,970 --> 00:15:53,480
broader of a look if we come up here we

00:15:52,040 --> 00:15:54,230
now have that query defined we're able

00:15:53,480 --> 00:15:55,700
to use it

00:15:54,230 --> 00:15:57,710
Apollo provides us the wonderful query

00:15:55,700 --> 00:16:00,020
component and leans into the the render

00:15:57,710 --> 00:16:01,460
prompt pattern but that's sort of

00:16:00,020 --> 00:16:03,680
irrelevant in my mind what I like is

00:16:01,460 --> 00:16:05,270
this center bit this is all of the code

00:16:03,680 --> 00:16:08,300
necessary that configuration and then

00:16:05,270 --> 00:16:10,520
this page to render that list there's a

00:16:08,300 --> 00:16:12,320
lot of behavior that's inherent in all

00:16:10,520 --> 00:16:13,190
of that and it's incredibly little code

00:16:12,320 --> 00:16:14,810
it's very direct

00:16:13,190 --> 00:16:16,850
it's the code that I would use if I were

00:16:14,810 --> 00:16:18,560
to describe to another human well I want

00:16:16,850 --> 00:16:19,880
to search and get all the users that

00:16:18,560 --> 00:16:21,500
match the search string and then I want

00:16:19,880 --> 00:16:23,390
to render them each into a little you

00:16:21,500 --> 00:16:26,060
know tile on the page and that's

00:16:23,390 --> 00:16:27,260
basically exactly what we have here that

00:16:26,060 --> 00:16:30,220
just sort of naturally falls out of

00:16:27,260 --> 00:16:33,590
graph QL and out of reactant Apollo but

00:16:30,220 --> 00:16:35,630
this really to me this is the simplicity

00:16:33,590 --> 00:16:37,760
that I see here especially in contrast

00:16:35,630 --> 00:16:38,780
the things like react and redux that

00:16:37,760 --> 00:16:41,660
pattern before where there would be

00:16:38,780 --> 00:16:42,920
actions and whole cycles and many

00:16:41,660 --> 00:16:44,930
different files that I needed to edit

00:16:42,920 --> 00:16:47,840
the fact that everything I need can live

00:16:44,930 --> 00:16:49,640
in the single file is fantastic now all

00:16:47,840 --> 00:16:51,830
that being said there is one thing that

00:16:49,640 --> 00:16:53,840
I do want to highlight which is if I

00:16:51,830 --> 00:16:56,690
come back down let see you to the word

00:16:53,840 --> 00:16:58,100
name there if I search for the step to

00:16:56,690 --> 00:16:59,540
trust me I'm searching the file and I'm

00:16:58,100 --> 00:17:03,140
only finding one instance I'm talking

00:16:59,540 --> 00:17:04,430
about the name here but why nobody else

00:17:03,140 --> 00:17:06,680
cares about the name why is this in my

00:17:04,430 --> 00:17:08,810
query it turns out the answer to that is

00:17:06,680 --> 00:17:10,280
the user tile so it's that little

00:17:08,810 --> 00:17:11,959
component that we're actually rendering

00:17:10,280 --> 00:17:14,540
in the list that's the piece that cares

00:17:11,959 --> 00:17:16,280
about it but now my parent query has to

00:17:14,540 --> 00:17:17,150
own that and so in the previous talk we

00:17:16,280 --> 00:17:19,070
actually heard a couple different

00:17:17,150 --> 00:17:21,890
options but the one that I become most

00:17:19,070 --> 00:17:24,199
fond of is the idea of using fragments

00:17:21,890 --> 00:17:26,720
so this is a core piece of the graph QL

00:17:24,199 --> 00:17:28,520
language and the same way that we had

00:17:26,720 --> 00:17:30,710
with the parent query if I introduce a

00:17:28,520 --> 00:17:32,780
type of here this is not just an extra

00:17:30,710 --> 00:17:34,750
string of text that we're gonna pass in

00:17:32,780 --> 00:17:38,330
to a parent query but this is a

00:17:34,750 --> 00:17:41,690
fundamental piece of the syntax of graph

00:17:38,330 --> 00:17:43,910
QL and so with this we're able to break

00:17:41,690 --> 00:17:46,160
out the data needs of this sub component

00:17:43,910 --> 00:17:47,750
let them own the specifics that they

00:17:46,160 --> 00:17:50,810
want and then if we come back over here

00:17:47,750 --> 00:17:52,150
let's see if I jump down here I can

00:17:50,810 --> 00:17:56,680
actually bring that in

00:17:52,150 --> 00:17:59,940
user child and then we can change this

00:17:56,680 --> 00:18:02,290
section here to just reference that and

00:17:59,940 --> 00:18:03,880
ideally everything should still work I

00:18:02,290 --> 00:18:07,170
think it also worked on modular II Odin

00:18:03,880 --> 00:18:10,810
makes it hard to tell but that was great

00:18:07,170 --> 00:18:13,240
so what's interesting and actually this

00:18:10,810 --> 00:18:17,470
was slightly ahead of us so let's go

00:18:13,240 --> 00:18:18,850
ahead and change that subtly something

00:18:17,470 --> 00:18:22,750
actually changed there which I'm gonna

00:18:18,850 --> 00:18:24,010
change back now company is the word that

00:18:22,750 --> 00:18:24,880
we had in here but we actually wanted

00:18:24,010 --> 00:18:26,650
that to be names I'm going to switch

00:18:24,880 --> 00:18:29,620
that back to name perfect now we can see

00:18:26,650 --> 00:18:31,570
there's my name Chris to me but now

00:18:29,620 --> 00:18:33,610
we'll actually undo that change we can

00:18:31,570 --> 00:18:34,750
transition name over to be company at

00:18:33,610 --> 00:18:36,070
this point again we get that same

00:18:34,750 --> 00:18:38,080
validation we know that that's a valid

00:18:36,070 --> 00:18:39,940
field if we save this

00:18:38,080 --> 00:18:41,740
that's one single file that needed to

00:18:39,940 --> 00:18:43,810
change no one else needed to care about

00:18:41,740 --> 00:18:45,610
that implementation detail the parent

00:18:43,810 --> 00:18:47,680
query was left exactly the same but the

00:18:45,610 --> 00:18:49,500
sub component was able to own that

00:18:47,680 --> 00:18:52,390
specific aspect of the data needs

00:18:49,500 --> 00:18:54,850
similarly if I come up here and I

00:18:52,390 --> 00:18:57,100
changed the 12 to 6 as I come back we'll

00:18:54,850 --> 00:19:00,220
see that that list is reduced down from

00:18:57,100 --> 00:19:03,100
12 to 6 what I love about this is it

00:19:00,220 --> 00:19:04,900
allows for again that query colocation

00:19:03,100 --> 00:19:06,790
is incredibly powerful but with

00:19:04,900 --> 00:19:09,970
fragments were able to take that one

00:19:06,790 --> 00:19:12,340
step further and say parent queries can

00:19:09,970 --> 00:19:14,140
own the specifics so here we're looking

00:19:12,340 --> 00:19:17,140
at the parent query and it says I these

00:19:14,140 --> 00:19:19,180
are the users that I care about I'm

00:19:17,140 --> 00:19:20,950
gonna actually not say too much about

00:19:19,180 --> 00:19:22,810
the details I'm gonna leave that to

00:19:20,950 --> 00:19:25,660
someone else and then that child

00:19:22,810 --> 00:19:28,660
component the fragment here that one can

00:19:25,660 --> 00:19:30,370
say I care about the details this is

00:19:28,660 --> 00:19:31,900
what about each of those users that I

00:19:30,370 --> 00:19:33,820
care about I don't care which user I

00:19:31,900 --> 00:19:35,350
care about the what I care about the

00:19:33,820 --> 00:19:36,850
which we're able to bring those together

00:19:35,350 --> 00:19:42,280
and let each of these components own

00:19:36,850 --> 00:19:43,900
their own data needs so this is a

00:19:42,280 --> 00:19:45,760
relatively simple example but we can dig

00:19:43,900 --> 00:19:47,110
in a little bit deeper just to see what

00:19:45,760 --> 00:19:49,360
this looks like as we try and expand

00:19:47,110 --> 00:19:52,210
upon that idea this is the user page

00:19:49,360 --> 00:19:54,190
query so if we come back here this

00:19:52,210 --> 00:19:55,780
paints this entire page so this query is

00:19:54,190 --> 00:19:57,700
going to own all of the data from the

00:19:55,780 --> 00:19:59,020
very top the image and all of the header

00:19:57,700 --> 00:20:01,360
information all the way down through

00:19:59,020 --> 00:20:02,530
each of the repositories and the

00:20:01,360 --> 00:20:04,600
structure of this query is interesting

00:20:02,530 --> 00:20:05,590
because it leans on that fragment

00:20:04,600 --> 00:20:07,270
pattern even ha

00:20:05,590 --> 00:20:09,850
so we can see here there's the user

00:20:07,270 --> 00:20:12,160
header the org and the repo each are

00:20:09,850 --> 00:20:13,840
fragments that we're bringing in now

00:20:12,160 --> 00:20:16,300
again I want to emphasize the pattern

00:20:13,840 --> 00:20:19,120
here of the parent query is describing

00:20:16,300 --> 00:20:21,220
which user which organizations which

00:20:19,120 --> 00:20:22,570
repositories in this case it's the user

00:20:21,220 --> 00:20:24,580
that happens to match the login that's

00:20:22,570 --> 00:20:26,140
being passed in it's the first ten

00:20:24,580 --> 00:20:27,250
organizations I'm not actually that

00:20:26,140 --> 00:20:29,560
popular so I'm not in ten organizations

00:20:27,250 --> 00:20:31,810
but if I were or if I 115

00:20:29,560 --> 00:20:33,040
we've now truncated that down and said

00:20:31,810 --> 00:20:35,200
something meaningful about which

00:20:33,040 --> 00:20:37,510
organizations and then the repositories

00:20:35,200 --> 00:20:39,660
is by far the most interesting bit all

00:20:37,510 --> 00:20:42,790
of that is a structured way of saying

00:20:39,660 --> 00:20:45,610
give me the most popular repositories so

00:20:42,790 --> 00:20:46,660
order it by stargazers descending make

00:20:45,610 --> 00:20:48,100
sure they're not forked so these are

00:20:46,660 --> 00:20:50,290
actually my repositories and give me the

00:20:48,100 --> 00:20:52,150
first ten and then from there we're able

00:20:50,290 --> 00:20:55,080
to let the subcomponents and their

00:20:52,150 --> 00:20:57,550
associated fragments own the data needs

00:20:55,080 --> 00:20:58,750
so looking at that in particular this is

00:20:57,550 --> 00:21:00,370
the user header so this is the

00:20:58,750 --> 00:21:01,720
information about the user and we can

00:21:00,370 --> 00:21:04,060
see this ends up being a leaf node

00:21:01,720 --> 00:21:05,230
it just says ID name bio etc this is all

00:21:04,060 --> 00:21:07,780
the information necessary to pop

00:21:05,230 --> 00:21:10,210
populate that top section same sort of

00:21:07,780 --> 00:21:12,010
thing happens with the org so for each

00:21:10,210 --> 00:21:13,480
of the orgs I just want the ID name and

00:21:12,010 --> 00:21:16,840
the avatar URL so that I can render

00:21:13,480 --> 00:21:18,400
their image but the repo is where things

00:21:16,840 --> 00:21:20,200
get interesting for each of the

00:21:18,400 --> 00:21:21,700
repositories this actually looks like a

00:21:20,200 --> 00:21:24,100
very small file but it's encapsulating a

00:21:21,700 --> 00:21:26,260
lot here we're actually going to split

00:21:24,100 --> 00:21:28,510
this out into two of its own fragments

00:21:26,260 --> 00:21:30,460
so we've got the repo header and the

00:21:28,510 --> 00:21:32,110
repo stats the repo header is giving the

00:21:30,460 --> 00:21:34,600
title and the URL and things like that

00:21:32,110 --> 00:21:37,000
the repo stats is giving that lower bar

00:21:34,600 --> 00:21:37,690
as all of the forks and stars and all of

00:21:37,000 --> 00:21:39,730
those sort of things

00:21:37,690 --> 00:21:42,670
so we'll actually focus in on the repo

00:21:39,730 --> 00:21:44,320
stats here we can see we can keep a

00:21:42,670 --> 00:21:47,470
building on this pattern so now down

00:21:44,320 --> 00:21:49,420
here on repository we need ID fork count

00:21:47,470 --> 00:21:51,880
all of these pieces and then primary

00:21:49,420 --> 00:21:54,490
language which itself we go one level

00:21:51,880 --> 00:21:56,530
deeper and now we're finally at language

00:21:54,490 --> 00:22:00,430
which says I want the ID the name and

00:21:56,530 --> 00:22:02,440
the color of the language all of this

00:22:00,430 --> 00:22:04,720
then gets composed back together into

00:22:02,440 --> 00:22:06,490
the one query that we need to run and

00:22:04,720 --> 00:22:07,960
we're able to say a lot of meaningful

00:22:06,490 --> 00:22:10,240
things while allowing each of these

00:22:07,960 --> 00:22:12,400
components to own their data need to

00:22:10,240 --> 00:22:15,480
change things locally and not have to

00:22:12,400 --> 00:22:15,480
affect many different files

00:22:15,590 --> 00:22:21,529
and again that's painting everything

00:22:18,020 --> 00:22:22,970
that we see here so this is fantastic

00:22:21,529 --> 00:22:26,390
but we can even take this whole pattern

00:22:22,970 --> 00:22:29,480
one step further if we look here we now

00:22:26,390 --> 00:22:30,559
have the toggle star button and one

00:22:29,480 --> 00:22:31,820
thing that I really like about this is

00:22:30,559 --> 00:22:33,380
just how simple this button is it's

00:22:31,820 --> 00:22:34,700
encapsulating everything and so I'm now

00:22:33,380 --> 00:22:36,710
putting it into my component tree by

00:22:34,700 --> 00:22:38,510
saying I want the toggle start button I

00:22:36,710 --> 00:22:40,309
don't care about any of the details I

00:22:38,510 --> 00:22:41,840
don't want to manage any of what that

00:22:40,309 --> 00:22:44,120
means I just want a button that allows

00:22:41,840 --> 00:22:46,820
me to toggle the Stars and so we're able

00:22:44,120 --> 00:22:48,710
to do that it also does bring along its

00:22:46,820 --> 00:22:51,140
own data needs so we've got here the

00:22:48,710 --> 00:22:52,789
toggle star button that's saying whether

00:22:51,140 --> 00:22:54,049
or not the user is starred and what the

00:22:52,789 --> 00:22:58,010
star count is so we're getting that

00:22:54,049 --> 00:23:00,740
information and as we start to dig into

00:22:58,010 --> 00:23:02,000
it the component itself has some

00:23:00,740 --> 00:23:03,350
interesting things so at the top we're

00:23:02,000 --> 00:23:05,179
switching between two different variants

00:23:03,350 --> 00:23:06,980
of the component one to star and when to

00:23:05,179 --> 00:23:09,080
on star that largely is due to the

00:23:06,980 --> 00:23:11,630
structure of the graph QL mutation that

00:23:09,080 --> 00:23:13,309
github provides but as we look at it

00:23:11,630 --> 00:23:15,559
this is the actual component that does

00:23:13,309 --> 00:23:17,179
the work very similar to the query

00:23:15,559 --> 00:23:18,980
component Apollo provides us a mutation

00:23:17,179 --> 00:23:20,539
component which we can wrap around

00:23:18,980 --> 00:23:22,279
things yields us in a function and now

00:23:20,539 --> 00:23:24,200
our actual rendering the part that

00:23:22,279 --> 00:23:26,659
builds our UI it's very simply a button

00:23:24,200 --> 00:23:28,730
we register an onclick handler that will

00:23:26,659 --> 00:23:30,320
fire that mutation and we even pretty

00:23:28,730 --> 00:23:32,450
much for free get the loading state

00:23:30,320 --> 00:23:33,649
which I was actually very happy to find

00:23:32,450 --> 00:23:36,860
as I was building this I think that's

00:23:33,649 --> 00:23:38,000
that's nice that's a nice freebie here

00:23:36,860 --> 00:23:41,059
we have the fragment that's associated

00:23:38,000 --> 00:23:43,070
with that so this is all of the data

00:23:41,059 --> 00:23:45,860
necessary to initially paint the

00:23:43,070 --> 00:23:47,270
rendering of this as well as for each of

00:23:45,860 --> 00:23:50,149
the two mutations so there's the star

00:23:47,270 --> 00:23:51,799
mutation here and the Unser mutation we

00:23:50,149 --> 00:23:54,020
actually want to read up that

00:23:51,799 --> 00:23:55,700
information as is one of the fantastic

00:23:54,020 --> 00:23:57,380
features of graph QL that actually don't

00:23:55,700 --> 00:23:59,960
hear folks talk about as much but the

00:23:57,380 --> 00:24:01,490
idea that for each mutation we can

00:23:59,960 --> 00:24:04,100
actually ask for data in return we can

00:24:01,490 --> 00:24:05,690
do a query the mutation will expose to

00:24:04,100 --> 00:24:07,909
us certain fields that we can then query

00:24:05,690 --> 00:24:08,450
into and so in this case we can ask for

00:24:07,909 --> 00:24:10,159
that data

00:24:08,450 --> 00:24:12,380
Apollo is going to automatically update

00:24:10,159 --> 00:24:15,169
the cache rerender any relevant pieces

00:24:12,380 --> 00:24:16,669
and the UI just magically stays

00:24:15,169 --> 00:24:18,230
up-to-date there's no imperative code

00:24:16,669 --> 00:24:20,179
here where I'm managing things and

00:24:18,230 --> 00:24:22,370
saying oh and also go update that other

00:24:20,179 --> 00:24:24,409
thing I'm merely communicating with my

00:24:22,370 --> 00:24:26,080
server having a simple a conversation as

00:24:24,409 --> 00:24:28,190
possible from the client perspective and

00:24:26,080 --> 00:24:30,379
things just work

00:24:28,190 --> 00:24:32,389
and now our whole button works now this

00:24:30,379 --> 00:24:34,669
is a case where things get a little bit

00:24:32,389 --> 00:24:36,139
this component is knowing a little bit

00:24:34,669 --> 00:24:38,179
more than it needs because technically

00:24:36,139 --> 00:24:40,850
it doesn't need the star count in order

00:24:38,179 --> 00:24:42,409
to render itself it's being we're

00:24:40,850 --> 00:24:45,950
coupling a little bit across those two

00:24:42,409 --> 00:24:47,509
components that said because we know and

00:24:45,950 --> 00:24:48,980
we can validate these queries that's a

00:24:47,509 --> 00:24:50,809
little bit of extra data that

00:24:48,980 --> 00:24:52,190
potentially could be wasteful if my

00:24:50,809 --> 00:24:54,350
other component were not rendered on the

00:24:52,190 --> 00:24:55,789
screen but I'm generally okay with that

00:24:54,350 --> 00:24:56,899
I'm okay with this component saying like

00:24:55,789 --> 00:24:58,940
and I know these things might change

00:24:56,899 --> 00:25:01,039
it's just a little more data let's get

00:24:58,940 --> 00:25:05,629
that and ensure that we have an

00:25:01,039 --> 00:25:07,279
up-to-date view of the world now all of

00:25:05,629 --> 00:25:09,409
this is fantastic but we can go even

00:25:07,279 --> 00:25:12,049
further and for that i'm unfortunately

00:25:09,409 --> 00:25:14,210
gonna leave them as we've said i really

00:25:12,049 --> 00:25:16,279
like them but what I want to explore now

00:25:14,210 --> 00:25:18,200
is a typescript variant of this whole

00:25:16,279 --> 00:25:20,659
project so I wrote the whole thing using

00:25:18,200 --> 00:25:21,529
JavaScript and then I explored what

00:25:20,659 --> 00:25:23,570
would this look like if we were to

00:25:21,529 --> 00:25:24,799
transition it over to typescript knowing

00:25:23,570 --> 00:25:27,080
that we have the strong types in the

00:25:24,799 --> 00:25:28,610
graph to L schema can we leverage that

00:25:27,080 --> 00:25:30,169
and can we get some value out of it and

00:25:28,610 --> 00:25:31,159
the answer is very much so we've heard

00:25:30,169 --> 00:25:32,659
this a few different times throughout

00:25:31,159 --> 00:25:35,330
the conference but I'm gonna show you

00:25:32,659 --> 00:25:37,490
now what exactly that looks like so here

00:25:35,330 --> 00:25:39,710
I'm hovering over user dot log in and

00:25:37,490 --> 00:25:41,090
very initially we can see that we get

00:25:39,710 --> 00:25:42,679
the information about the type there's a

00:25:41,090 --> 00:25:44,570
little extra thing here that I think is

00:25:42,679 --> 00:25:46,700
worth noting which is the username used

00:25:44,570 --> 00:25:49,370
to log in this is the description field

00:25:46,700 --> 00:25:52,399
coming from the graph QL API and it's

00:25:49,370 --> 00:25:54,230
just that one little bit of extra nicety

00:25:52,399 --> 00:25:56,090
that comes from having that centralized

00:25:54,230 --> 00:25:57,919
schema defining our domain in that way

00:25:56,090 --> 00:26:00,019
and then allowing that to flow through

00:25:57,919 --> 00:26:01,970
our system so now we know that this is a

00:26:00,019 --> 00:26:06,049
string that's fantastic if we start to

00:26:01,970 --> 00:26:07,610
type in here typescript and the S code

00:26:06,049 --> 00:26:09,110
will do some magic so I know that I can

00:26:07,610 --> 00:26:11,720
call the to uppercase function because

00:26:09,110 --> 00:26:14,809
this is a string this is great but now

00:26:11,720 --> 00:26:17,570
if I jump back here right now I have

00:26:14,809 --> 00:26:19,639
user dot and now we can see these are

00:26:17,570 --> 00:26:20,870
the four fields that are available so

00:26:19,639 --> 00:26:22,039
this is something that it knows and

00:26:20,870 --> 00:26:23,840
we'll talk in a minute about how it

00:26:22,039 --> 00:26:25,009
actually knows that but I can go through

00:26:23,840 --> 00:26:27,080
each of these options and let's say I

00:26:25,009 --> 00:26:28,039
want to switch this over to name so now

00:26:27,080 --> 00:26:30,019
I've switched it to name and you'll

00:26:28,039 --> 00:26:32,179
notice that we get red squiggly

00:26:30,019 --> 00:26:34,279
underline something is wrong and again

00:26:32,179 --> 00:26:36,320
if we hover here we can see the problem

00:26:34,279 --> 00:26:38,869
is that unlike login which is

00:26:36,320 --> 00:26:40,519
definitively going to be their name is

00:26:38,869 --> 00:26:41,430
nullable users do not have to provide

00:26:40,519 --> 00:26:43,320
their name via

00:26:41,430 --> 00:26:47,040
gie so it's possible that this is a null

00:26:43,320 --> 00:26:48,590
field and I don't you to think that I'm

00:26:47,040 --> 00:26:50,640
just like making up things to

00:26:48,590 --> 00:26:52,440
demonstrate all this is a real bug that

00:26:50,640 --> 00:26:53,490
I found in transition to typescript the

00:26:52,440 --> 00:26:55,530
JavaScript version of the app is

00:26:53,490 --> 00:26:56,670
currently broken I didn't really feel

00:26:55,530 --> 00:26:58,230
like fixing it but the typescript

00:26:56,670 --> 00:27:01,560
version works and this was a real thing

00:26:58,230 --> 00:27:03,950
that it found as well as I think the

00:27:01,560 --> 00:27:06,570
bugs are great but the experience of

00:27:03,950 --> 00:27:09,330
using this this is all defined from the

00:27:06,570 --> 00:27:12,120
query local to the component here and

00:27:09,330 --> 00:27:13,380
being able to leverage that is fantastic

00:27:12,120 --> 00:27:14,940
it just makes the developer experience

00:27:13,380 --> 00:27:17,700
the discoverability all of that so much

00:27:14,940 --> 00:27:19,020
better so the place that this actually

00:27:17,700 --> 00:27:21,210
comes from I've just opened up another

00:27:19,020 --> 00:27:23,580
file which is a generated file Apollo

00:27:21,210 --> 00:27:26,160
CLI allows us to produce this and this

00:27:23,580 --> 00:27:28,560
is a specific interface so a typescript

00:27:26,160 --> 00:27:30,720
interface unique to the fragment that

00:27:28,560 --> 00:27:32,400
was located in this file so again that

00:27:30,720 --> 00:27:33,960
fragment decomposition allows us to

00:27:32,400 --> 00:27:36,510
break apart our code in an interesting

00:27:33,960 --> 00:27:39,840
way but it even extends here into this

00:27:36,510 --> 00:27:41,070
type system so we know that users have a

00:27:39,840 --> 00:27:42,450
whole bunch of fields that we can

00:27:41,070 --> 00:27:44,100
possibly get but in this case we know

00:27:42,450 --> 00:27:45,960
that we're only querying for these four

00:27:44,100 --> 00:27:47,820
so we got a type that is specific to

00:27:45,960 --> 00:27:49,700
that and gives us all of the information

00:27:47,820 --> 00:27:54,300
necessary to work directly with that

00:27:49,700 --> 00:27:55,620
piece of data within our system so now

00:27:54,300 --> 00:27:57,750
we've explored the typescript thing the

00:27:55,620 --> 00:28:01,050
last thing that I want to look at is if

00:27:57,750 --> 00:28:03,360
we think about the queries in toad in

00:28:01,050 --> 00:28:04,560
total what all did we do to paint that

00:28:03,360 --> 00:28:06,780
user page that was the much more

00:28:04,560 --> 00:28:08,640
complicated query so this is the actual

00:28:06,780 --> 00:28:10,320
query as it was rendered you can see it

00:28:08,640 --> 00:28:12,090
still got the fragments reference so

00:28:10,320 --> 00:28:15,420
there's a bunch of fragments or actually

00:28:12,090 --> 00:28:18,300
all folded up together but if I then

00:28:15,420 --> 00:28:19,290
produce the logical inline version I

00:28:18,300 --> 00:28:22,290
think there's some very interesting

00:28:19,290 --> 00:28:23,960
things that we can observe in here the

00:28:22,290 --> 00:28:26,790
first is this repositories

00:28:23,960 --> 00:28:28,830
connectionists Association this has a

00:28:26,790 --> 00:28:30,750
very robust query language that is

00:28:28,830 --> 00:28:32,700
structured into it by virtue of the type

00:28:30,750 --> 00:28:34,530
system by virtue of the schema graph QL

00:28:32,700 --> 00:28:37,200
allows us to say these sort of things

00:28:34,530 --> 00:28:39,060
an arrest system we would have to hit an

00:28:37,200 --> 00:28:41,100
additional endpoint maybe there's some

00:28:39,060 --> 00:28:44,130
parameterization there but the idea of

00:28:41,100 --> 00:28:45,960
having this level of expressiveness and

00:28:44,130 --> 00:28:48,360
in fact github zests API

00:28:45,960 --> 00:28:50,280
the v3 API which is one of the best that

00:28:48,360 --> 00:28:51,929
I've ever seen does not support this

00:28:50,280 --> 00:28:53,700
this is not a question that I can ask

00:28:51,929 --> 00:28:56,269
of the rest API but it just sort of

00:28:53,700 --> 00:28:58,289
naturally falls out of the graph QL API

00:28:56,269 --> 00:28:59,610
similarly and I think this was really

00:28:58,289 --> 00:29:02,669
well highlighted in the github talk

00:28:59,610 --> 00:29:06,119
yesterday viewer has starred these sort

00:29:02,669 --> 00:29:08,610
of computations we don't want to meet

00:29:06,119 --> 00:29:10,769
the user exactly at the UI we don't want

00:29:08,610 --> 00:29:13,019
to say should show button but the idea

00:29:10,769 --> 00:29:14,970
that we can ask more intuitive questions

00:29:13,019 --> 00:29:18,539
viewer has starred viewer can star

00:29:14,970 --> 00:29:20,639
viewer can administer is fork is source

00:29:18,539 --> 00:29:23,820
these are all things that are part of

00:29:20,639 --> 00:29:26,460
the github graph QL API that allow users

00:29:23,820 --> 00:29:28,169
allow clients to more directly express

00:29:26,460 --> 00:29:30,600
the needs that they have for the data

00:29:28,169 --> 00:29:32,940
and I think this is just fantastic and

00:29:30,600 --> 00:29:35,970
in contrast to REST API is we always had

00:29:32,940 --> 00:29:38,279
the dual constraint of anything we add

00:29:35,970 --> 00:29:40,830
in is bloating the bloating the response

00:29:38,279 --> 00:29:42,299
every client is now paying a tax in

00:29:40,830 --> 00:29:43,769
order for that new field to be in there

00:29:42,299 --> 00:29:46,159
so do we really want to add it or not

00:29:43,769 --> 00:29:48,269
now I don't think you should go

00:29:46,159 --> 00:29:51,629
completely wild with this and add

00:29:48,269 --> 00:29:53,190
everything to your geographic ul API but

00:29:51,629 --> 00:29:55,919
the idea of adding things that are more

00:29:53,190 --> 00:29:57,809
user centric more client centric I think

00:29:55,919 --> 00:29:59,249
graph QL really opens us up to that and

00:29:57,809 --> 00:30:01,740
we can see that here what the viewer has

00:29:59,249 --> 00:30:05,669
starred similarly primary language is a

00:30:01,740 --> 00:30:07,559
really interesting one the graph QL API

00:30:05,669 --> 00:30:09,600
exposes both languages which is an array

00:30:07,559 --> 00:30:12,799
of language objects and primary language

00:30:09,600 --> 00:30:15,440
which is a single language field

00:30:12,799 --> 00:30:18,029
historically that would likely have been

00:30:15,440 --> 00:30:20,070
by convention the first thing in the

00:30:18,029 --> 00:30:22,039
array is the one that is the primary

00:30:20,070 --> 00:30:24,360
language or something to that effect

00:30:22,039 --> 00:30:26,759
similarly the languages are actually

00:30:24,360 --> 00:30:30,539
exposed in the REST API just as strings

00:30:26,759 --> 00:30:32,970
then script Ruby etc so there was no way

00:30:30,539 --> 00:30:34,769
to get the color this would just not

00:30:32,970 --> 00:30:36,210
really be possible or in reality the

00:30:34,769 --> 00:30:37,830
thing that we would do is every single

00:30:36,210 --> 00:30:40,110
client would actually have a local cache

00:30:37,830 --> 00:30:42,690
of them script is this color green Ruby

00:30:40,110 --> 00:30:44,369
is this color red Python is blue yellow

00:30:42,690 --> 00:30:45,749
something like that but each client

00:30:44,369 --> 00:30:47,730
would need to own that data or then

00:30:45,749 --> 00:30:49,320
pushing all of that logic back out to

00:30:47,730 --> 00:30:51,509
our clients but with graph QL again we

00:30:49,320 --> 00:30:55,080
can sort of wrap our arms around it and

00:30:51,509 --> 00:30:56,759
pull it back to the server again one

00:30:55,080 --> 00:30:58,369
last thing is all of the associations

00:30:56,759 --> 00:31:02,100
all the connections that we can make

00:30:58,369 --> 00:31:03,929
every edge that we add to our graph in

00:31:02,100 --> 00:31:05,940
graph QL is an investment in the

00:31:03,929 --> 00:31:07,320
platform ideally it's telling

00:31:05,940 --> 00:31:11,340
thing that's true about your domain and

00:31:07,320 --> 00:31:13,350
about your modeling so with that I have

00:31:11,340 --> 00:31:14,519
a few parting thoughts some of the

00:31:13,350 --> 00:31:15,480
things that really keep me coming back

00:31:14,519 --> 00:31:17,370
to graph QL

00:31:15,480 --> 00:31:19,049
I think graph QL encourages and informs

00:31:17,370 --> 00:31:21,179
in architecture as we're seeing the

00:31:19,049 --> 00:31:23,100
fracturing of clients and services graph

00:31:21,179 --> 00:31:24,149
QL gives us an answer it's a relatively

00:31:23,100 --> 00:31:26,759
simple answer but I think it's

00:31:24,149 --> 00:31:30,029
incredibly powerful and I think it's one

00:31:26,759 --> 00:31:31,649
worth leaning into an association with

00:31:30,029 --> 00:31:34,529
that graph QL introduces an abstraction

00:31:31,649 --> 00:31:36,240
layer from modeling our domain when I

00:31:34,529 --> 00:31:38,340
first started working with graph QL I

00:31:36,240 --> 00:31:40,139
thought of it as rest but better rest

00:31:38,340 --> 00:31:42,090
but I can ask for whatever I want and I

00:31:40,139 --> 00:31:43,740
can have some associations but what I

00:31:42,090 --> 00:31:45,690
find time and time again is that the

00:31:43,740 --> 00:31:47,039
questions and the conversations that I

00:31:45,690 --> 00:31:49,860
have with teams when we're building out

00:31:47,039 --> 00:31:51,659
graph QL api's are more fundamental they

00:31:49,860 --> 00:31:53,519
are more focused on the product needs

00:31:51,659 --> 00:31:55,500
and on what's true of the platform and

00:31:53,519 --> 00:31:57,740
less on I'm going to serialize a

00:31:55,500 --> 00:32:00,090
resource now I'm gonna expose this data

00:31:57,740 --> 00:32:01,889
so again I think this is something to

00:32:00,090 --> 00:32:03,840
lean into to take time with and to be

00:32:01,889 --> 00:32:05,789
very careful with because it can be a

00:32:03,840 --> 00:32:08,279
very valuable investment in the platform

00:32:05,789 --> 00:32:10,559
and lastly and perhaps most importantly

00:32:08,279 --> 00:32:13,440
graph QL encourages a product centric

00:32:10,559 --> 00:32:15,809
approach what we see are ways of

00:32:13,440 --> 00:32:17,220
defining our system in our platform that

00:32:15,809 --> 00:32:18,899
are useful to the clients

00:32:17,220 --> 00:32:21,480
simplifications that make it easier for

00:32:18,899 --> 00:32:23,490
us to build our client applications and

00:32:21,480 --> 00:32:26,549
I think that's the right place to invest

00:32:23,490 --> 00:32:28,019
in having the simplicity it's right up

00:32:26,549 --> 00:32:31,139
where the users are it's where the money

00:32:28,019 --> 00:32:32,490
is made ideally it doesn't push too much

00:32:31,139 --> 00:32:34,350
complexity on the back end but I think

00:32:32,490 --> 00:32:36,299
if we have to bias in one direction a

00:32:34,350 --> 00:32:37,529
product centric approach is always going

00:32:36,299 --> 00:32:40,019
to be the right choice and I'm so

00:32:37,529 --> 00:32:43,320
excited that graph QL has encouraged

00:32:40,019 --> 00:32:44,909
that throughout the community so with

00:32:43,320 --> 00:32:46,799
that I thank you all for your time I

00:32:44,909 --> 00:32:48,389
hope that was interesting and useful

00:32:46,799 --> 00:32:50,490
we'd love to chat with anyone in the

00:32:48,389 --> 00:32:51,190
breaks or over lunch but thank you very

00:32:50,490 --> 00:32:52,060
much

00:32:51,190 --> 00:32:52,560
[Applause]

00:32:52,060 --> 00:32:55,630
[Music]

00:32:52,560 --> 00:32:55,630

YouTube URL: https://www.youtube.com/watch?v=pYYupACpY4U


