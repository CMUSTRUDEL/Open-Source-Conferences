Title: GraphQL Summit 2018 - Opening Keynote (Geoff Schmidt)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Apollo's co-founder and CEO, Geoff Schmidt, shares his insights on "how to do GraphQL right" and his vision for the ecosystem.

Learn more about Apollo:  https://www.apollographql.com/

Join Apollo's community Slack group:  https://www.apollographql.com/slack/

Learn more:  https://summit.graphql.com
Captions: 
	00:00:05,149 --> 00:00:09,990
awesome third annual graphical summit

00:00:07,620 --> 00:00:12,330
and our theme isthere is doing graph

00:00:09,990 --> 00:00:14,160
fuel right it's good time for graph QL

00:00:12,330 --> 00:00:16,080
we're at a point where a lot has been

00:00:14,160 --> 00:00:18,360
learned about graphical over the past

00:00:16,080 --> 00:00:19,830
three years from a lot of people who

00:00:18,360 --> 00:00:21,540
have implemented it and we're now at a

00:00:19,830 --> 00:00:24,960
point where we can really leverage all

00:00:21,540 --> 00:00:26,309
of that to adopt graph QL quickly at

00:00:24,960 --> 00:00:29,730
scale and do really cool things with it

00:00:26,309 --> 00:00:31,919
so let me just start with a quick

00:00:29,730 --> 00:00:34,680
overview of where the where the

00:00:31,919 --> 00:00:36,540
graphical ecosystem is so graph QL is

00:00:34,680 --> 00:00:38,550
emerged especially over the last year as

00:00:36,540 --> 00:00:40,500
a developer mega trend and you can see

00:00:38,550 --> 00:00:42,270
this a couple ways one way you can see

00:00:40,500 --> 00:00:44,460
it is in a Polock client download this

00:00:42,270 --> 00:00:46,610
is a nice quantitative metric Apollo

00:00:44,460 --> 00:00:48,660
client downloads have grown from around

00:00:46,610 --> 00:00:51,150
10,000 downloads a week at the beginning

00:00:48,660 --> 00:00:54,290
of last year to now I think we had

00:00:51,150 --> 00:00:56,850
almost 500,000 downloads two weeks ago

00:00:54,290 --> 00:00:59,100
it's just been an incredible you know

00:00:56,850 --> 00:01:00,270
hockey-stick of adoption let's put that

00:00:59,100 --> 00:01:02,280
in the context of the larger ecosystem

00:01:00,270 --> 00:01:03,809
though like what is you know what is

00:01:02,280 --> 00:01:06,930
almost 2 million downloads a month

00:01:03,809 --> 00:01:11,399
really mean here's some survey data I

00:01:06,930 --> 00:01:13,770
found so in the state of JavaScript 2018

00:01:11,399 --> 00:01:15,359
survey they found that 83 percent of

00:01:13,770 --> 00:01:19,139
respondents said that they were either

00:01:15,359 --> 00:01:21,959
using or wanted to learn graph QL and in

00:01:19,139 --> 00:01:23,729
the node.js foundation 2018 user survey

00:01:21,959 --> 00:01:26,039
they actually got in the node community

00:01:23,729 --> 00:01:27,600
that over 20 percent of all no

00:01:26,039 --> 00:01:30,329
developers said that they were using

00:01:27,600 --> 00:01:32,369
graphical in that survey so that's

00:01:30,329 --> 00:01:37,020
definitely what I would call a mega

00:01:32,369 --> 00:01:39,270
trend and there's a lot of great

00:01:37,020 --> 00:01:40,889
companies behind graph tool - these are

00:01:39,270 --> 00:01:43,829
just some of the companies that are here

00:01:40,889 --> 00:01:45,840
in the audience today and many of these

00:01:43,829 --> 00:01:47,579
companies many of you are making really

00:01:45,840 --> 00:01:50,369
significant investments in graph you'll

00:01:47,579 --> 00:01:53,999
already I'd love to see a show of hands

00:01:50,369 --> 00:01:56,270
who's here from Survey Monkey I think we

00:01:53,999 --> 00:01:59,969
have 24 people here from Survey Monkey

00:01:56,270 --> 00:02:03,359
who's here from Netflix I think we have

00:01:59,969 --> 00:02:05,480
39 people here from Netflix who's here

00:02:03,359 --> 00:02:07,640
from Credit Karma

00:02:05,480 --> 00:02:11,450
I think we have 69 people here from

00:02:07,640 --> 00:02:13,790
Credit Karma it's it's awesome and I

00:02:11,450 --> 00:02:16,490
could talk about Atlassian Expedia

00:02:13,790 --> 00:02:18,920
Ebates Zillow PayPal Braintree EA

00:02:16,490 --> 00:02:20,540
Microsoft Nordstrom's reddit Shopify I

00:02:18,920 --> 00:02:22,490
could read this whole slide to you and I

00:02:20,540 --> 00:02:25,790
wouldn't cover all the amazing teams

00:02:22,490 --> 00:02:27,890
that are here today and so the question

00:02:25,790 --> 00:02:30,530
that this brings up for me is why is

00:02:27,890 --> 00:02:32,600
this there are so many things your time

00:02:30,530 --> 00:02:33,800
is so valuable your team's time is so

00:02:32,600 --> 00:02:36,800
valuable there's so many things that you

00:02:33,800 --> 00:02:38,870
could be doing why are we here why is

00:02:36,800 --> 00:02:42,170
now the right time for a new technology

00:02:38,870 --> 00:02:44,720
in the data layer and so to try to

00:02:42,170 --> 00:02:46,870
understand that we've we had Apollo who

00:02:44,720 --> 00:02:49,640
spent hundreds of hours over the last

00:02:46,870 --> 00:02:52,160
year talking to people in the community

00:02:49,640 --> 00:02:55,550
and trying to understand how to use

00:02:52,160 --> 00:02:56,960
graph QL Y to use graph QL and what

00:02:55,550 --> 00:02:59,930
would you like to see next in graph kill

00:02:56,960 --> 00:03:02,060
and how can we help and so the rest of

00:02:59,930 --> 00:03:03,320
my talk is going to summarize what we

00:03:02,060 --> 00:03:04,970
learned about that and what we're trying

00:03:03,320 --> 00:03:08,120
to do that help you based on those

00:03:04,970 --> 00:03:10,190
hundreds of hours of conversations and

00:03:08,120 --> 00:03:10,970
that's also the basis of my belief that

00:03:10,190 --> 00:03:12,709
we're now at a point where our

00:03:10,970 --> 00:03:13,700
conference theme can be doing graph kill

00:03:12,709 --> 00:03:15,950
right because we have a really good

00:03:13,700 --> 00:03:19,280
handle on what that is and how to do it

00:03:15,950 --> 00:03:20,750
so let me first start with why graphed

00:03:19,280 --> 00:03:23,959
well why is why is now the time for

00:03:20,750 --> 00:03:26,239
something new and I think this really is

00:03:23,959 --> 00:03:28,160
the heart of it we used to build web

00:03:26,239 --> 00:03:30,230
apps and web apps had this idea you've

00:03:28,160 --> 00:03:32,540
got a web server you've got a browser

00:03:30,230 --> 00:03:34,820
and you're gonna send HTML from that web

00:03:32,540 --> 00:03:38,540
server down to the browser okay Ruby on

00:03:34,820 --> 00:03:40,010
Rails PHP asp.net spring django lots of

00:03:38,540 --> 00:03:42,320
frameworks all lamp stack derivatives

00:03:40,010 --> 00:03:44,000
and over the past five or ten years

00:03:42,320 --> 00:03:45,410
we've seen a transition to a totally

00:03:44,000 --> 00:03:47,420
different architecture where you've got

00:03:45,410 --> 00:03:49,820
apps which are actual pieces of software

00:03:47,420 --> 00:03:50,750
not web browsers that talk to or if

00:03:49,820 --> 00:03:52,640
they're web browsers they're running

00:03:50,750 --> 00:03:54,350
code for you they're talking to services

00:03:52,640 --> 00:03:57,860
in the cloud and what that means is now

00:03:54,350 --> 00:03:59,510
you need an API every app now has an API

00:03:57,860 --> 00:04:02,690
inside of it because the app needs some

00:03:59,510 --> 00:04:05,630
way to talk to the cloud so somewhat

00:04:02,690 --> 00:04:08,260
surprisingly rest turns out to not be

00:04:05,630 --> 00:04:11,209
the right way to build those api's and

00:04:08,260 --> 00:04:13,010
the reason for that is that rest

00:04:11,209 --> 00:04:15,220
besides being 20 years old and designed

00:04:13,010 --> 00:04:18,320
for something totally different is a

00:04:15,220 --> 00:04:20,930
procedural API technology and by

00:04:18,320 --> 00:04:22,370
procedural what I mean is basically the

00:04:20,930 --> 00:04:23,930
way you use rest is you write a bunch of

00:04:22,370 --> 00:04:25,910
endpoints which are essentially remote

00:04:23,930 --> 00:04:27,950
procedure calls and this is a call that

00:04:25,910 --> 00:04:29,690
you know runs a block of code and does a

00:04:27,950 --> 00:04:32,330
thing and gives you a report of your

00:04:29,690 --> 00:04:34,400
data so my first spin of my app I write

00:04:32,330 --> 00:04:35,930
a first procedure call let's say for

00:04:34,400 --> 00:04:38,780
that first screen I need data from the

00:04:35,930 --> 00:04:40,790
posts and the likes service great you

00:04:38,780 --> 00:04:42,770
know that was easy it works perfect

00:04:40,790 --> 00:04:44,300
but then when I go write the second

00:04:42,770 --> 00:04:46,310
screen I need a different combination of

00:04:44,300 --> 00:04:48,260
data and now I have to write I have to

00:04:46,310 --> 00:04:50,230
add another purple arrow that's going to

00:04:48,260 --> 00:04:54,170
go talk to a different set of services

00:04:50,230 --> 00:04:55,940
and now for the rest of my screens I

00:04:54,170 --> 00:04:58,220
just have to keep on adding purple

00:04:55,940 --> 00:05:02,270
arrows and you end up with a lot of

00:04:58,220 --> 00:05:03,980
purple arrows and that's bad you don't

00:05:02,270 --> 00:05:05,840
actually want the purple arrows because

00:05:03,980 --> 00:05:07,850
every purple arrow represents code you

00:05:05,840 --> 00:05:09,410
have to write and this is code that

00:05:07,850 --> 00:05:11,180
spends spans the front end and the back

00:05:09,410 --> 00:05:12,320
end so to write that code you have to

00:05:11,180 --> 00:05:13,400
coordinate multiple teams because you

00:05:12,320 --> 00:05:14,540
have to do the state management on the

00:05:13,400 --> 00:05:17,900
client and you have to build the

00:05:14,540 --> 00:05:19,370
endpoints on the on the services you end

00:05:17,900 --> 00:05:21,800
up with hundreds of these purple arrows

00:05:19,370 --> 00:05:24,440
meaning that it's nearly impossible to

00:05:21,800 --> 00:05:25,970
fully document those purple arrows or

00:05:24,440 --> 00:05:27,440
keep that documentation up to date

00:05:25,970 --> 00:05:29,120
meaning that maintaining all those

00:05:27,440 --> 00:05:30,800
purple arrows this is probably not going

00:05:29,120 --> 00:05:32,090
to be any fun and the fact probably it's

00:05:30,800 --> 00:05:35,600
going to happen the way it really should

00:05:32,090 --> 00:05:37,880
and the and the real tragedy here is all

00:05:35,600 --> 00:05:39,740
of these purple arrows are code and this

00:05:37,880 --> 00:05:43,160
is code that can't make your app good it

00:05:39,740 --> 00:05:45,139
can only make it bad it's it can only

00:05:43,160 --> 00:05:46,190
hurt latency server load battery life

00:05:45,139 --> 00:05:48,860
network traffic

00:05:46,190 --> 00:05:51,500
security you're not going to make your

00:05:48,860 --> 00:05:52,490
app better with this by doing this code

00:05:51,500 --> 00:05:53,330
well you're only going to make it worse

00:05:52,490 --> 00:05:55,639
by doing it poorly

00:05:53,330 --> 00:05:57,020
so this antenna and the same time you

00:05:55,639 --> 00:05:58,250
end up tightly coupling your front end

00:05:57,020 --> 00:06:00,230
and your back end so that it's hard to

00:05:58,250 --> 00:06:01,280
change either one of those things so you

00:06:00,230 --> 00:06:04,580
end up basically with a whole bunch of

00:06:01,280 --> 00:06:07,930
really costly boilerplate code so if

00:06:04,580 --> 00:06:10,400
rest is a procedural approach to api's

00:06:07,930 --> 00:06:11,990
graph fuel is an alternative way to

00:06:10,400 --> 00:06:13,820
think about it that's a declarative

00:06:11,990 --> 00:06:15,860
approach to api's so we're not gonna

00:06:13,820 --> 00:06:17,260
have any purple arrows instead what

00:06:15,860 --> 00:06:20,090
we're gonna do is we're gonna have a

00:06:17,260 --> 00:06:21,260
approach where your apps simply describe

00:06:20,090 --> 00:06:22,820
their data requirements you can draw

00:06:21,260 --> 00:06:24,590
I'll just write a little graphical query

00:06:22,820 --> 00:06:27,050
co-locate that with your UI components

00:06:24,590 --> 00:06:28,400
and you've described the requirements

00:06:27,050 --> 00:06:30,170
and kind of a way that a piece of

00:06:28,400 --> 00:06:30,860
software can understand without having

00:06:30,170 --> 00:06:31,849
to be you know

00:06:30,860 --> 00:06:35,719
Turing equivalent or solve the halting

00:06:31,849 --> 00:06:37,370
problem and then you your services just

00:06:35,719 --> 00:06:39,020
need to describe their capabilities and

00:06:37,370 --> 00:06:41,539
then once you've got those descriptions

00:06:39,020 --> 00:06:45,020
what services can do and what apps need

00:06:41,539 --> 00:06:48,469
graph QL can be like a marketplace or a

00:06:45,020 --> 00:06:50,650
clearing house or a matchmaker that maps

00:06:48,469 --> 00:06:52,879
those requirements to those capabilities

00:06:50,650 --> 00:06:55,069
and this means you have much less code

00:06:52,879 --> 00:06:56,659
it means you have consistent performance

00:06:55,069 --> 00:06:58,819
it means that you can easily audit your

00:06:56,659 --> 00:07:00,770
security surface we can talk about the

00:06:58,819 --> 00:07:02,930
technical benefits but sometimes it's

00:07:00,770 --> 00:07:05,900
helpful I've found to kind of put this

00:07:02,930 --> 00:07:07,759
in a broader business context so here's

00:07:05,900 --> 00:07:10,099
my my summary maybe of how to think

00:07:07,759 --> 00:07:12,889
about the business benefits of graph QL

00:07:10,099 --> 00:07:14,300
maybe a good slide to share with whoever

00:07:12,889 --> 00:07:16,550
you need to talk to to get permission to

00:07:14,300 --> 00:07:19,639
do this if that's anyone but yourselves

00:07:16,550 --> 00:07:21,620
I know what the rest you often end up in

00:07:19,639 --> 00:07:23,960
situations where future development is

00:07:21,620 --> 00:07:25,370
slowed down because the front-end team

00:07:23,960 --> 00:07:27,560
is waiting on the back-end team to give

00:07:25,370 --> 00:07:29,060
them new endpoints whereas with graph QL

00:07:27,560 --> 00:07:31,490
both because you're writing less code

00:07:29,060 --> 00:07:33,319
and because you have much less cross

00:07:31,490 --> 00:07:34,879
team coordination you're going to be

00:07:33,319 --> 00:07:37,639
able to ship more features this year

00:07:34,879 --> 00:07:39,860
with graph QL and the other thing is if

00:07:37,639 --> 00:07:42,020
you're entering new channels if you're

00:07:39,860 --> 00:07:43,370
going to ship on iOS or Android whereas

00:07:42,020 --> 00:07:44,839
you hadn't before we hear from people

00:07:43,370 --> 00:07:46,909
that they can often get those apps to

00:07:44,839 --> 00:07:48,919
market months faster than if they

00:07:46,909 --> 00:07:50,270
weren't using graph QL because they can

00:07:48,919 --> 00:07:51,409
leverage all the data infrastructure and

00:07:50,270 --> 00:07:53,750
data fetching stuff they already built

00:07:51,409 --> 00:07:55,490
once for web and very rapidly build

00:07:53,750 --> 00:07:59,330
their iOS or Android app on top of that

00:07:55,490 --> 00:08:02,180
so that's one benefit another benefit is

00:07:59,330 --> 00:08:04,849
what we often find you know who's had

00:08:02,180 --> 00:08:05,960
the experience where you've got a you're

00:08:04,849 --> 00:08:07,339
using some app and there's a great

00:08:05,960 --> 00:08:09,229
experience on the web and it's not as

00:08:07,339 --> 00:08:10,669
good on mobile or it works pretty good

00:08:09,229 --> 00:08:11,839
on iOS but not as good on the hand right

00:08:10,669 --> 00:08:16,490
she's ever had that experience with an

00:08:11,839 --> 00:08:17,539
app probably most users it's really hard

00:08:16,490 --> 00:08:18,949
to get that feature parity and

00:08:17,539 --> 00:08:20,930
consistency across multiple platforms

00:08:18,949 --> 00:08:22,009
with rest for a number of reasons

00:08:20,930 --> 00:08:23,389
including the fact that you end up with

00:08:22,009 --> 00:08:24,349
data fetching code that's pushed into

00:08:23,389 --> 00:08:26,449
the clients where it should have been

00:08:24,349 --> 00:08:27,650
and shared across platforms and also

00:08:26,449 --> 00:08:29,830
just the fact that feature developments

00:08:27,650 --> 00:08:32,630
so hard what we hear from people

00:08:29,830 --> 00:08:35,570
empirically in the field talking to all

00:08:32,630 --> 00:08:37,399
of you is we find that it's a lot easier

00:08:35,570 --> 00:08:39,140
to ship consistent high-quality user

00:08:37,399 --> 00:08:40,819
experiences across multiple platforms

00:08:39,140 --> 00:08:43,000
when you have this consistent data layer

00:08:40,819 --> 00:08:43,000
in place

00:08:43,779 --> 00:08:47,439
staying a lot of people in a situation

00:08:46,089 --> 00:08:49,420
today where you're trying to move from a

00:08:47,439 --> 00:08:50,699
monolith to a set of micro-services and

00:08:49,420 --> 00:08:52,839
maybe you're just beginning this journey

00:08:50,699 --> 00:08:54,040
or maybe you're halfway there

00:08:52,839 --> 00:08:55,360
or maybe you've got it up and running

00:08:54,040 --> 00:08:56,589
but you're still trying to figure out

00:08:55,360 --> 00:08:57,579
how to how to manage it and what your

00:08:56,589 --> 00:08:59,800
processes are going to be for the next

00:08:57,579 --> 00:09:01,389
five years that can be really

00:08:59,800 --> 00:09:02,499
challenging with rest because the tight

00:09:01,389 --> 00:09:03,850
coupling you've got all these apps

00:09:02,499 --> 00:09:06,639
you're calling right into your monolith

00:09:03,850 --> 00:09:07,870
and the end of making assumptions with

00:09:06,639 --> 00:09:09,189
what you're back at making more back

00:09:07,870 --> 00:09:10,329
into some assumptions where your back

00:09:09,189 --> 00:09:13,480
end looks like then you'd really like

00:09:10,329 --> 00:09:15,040
with a graph QL you you end up creating

00:09:13,480 --> 00:09:16,449
this abstraction layer between the apps

00:09:15,040 --> 00:09:18,069
and the services and that makes it much

00:09:16,449 --> 00:09:19,899
easier to refactor either one of those

00:09:18,069 --> 00:09:22,509
things you can refactor from one

00:09:19,899 --> 00:09:23,889
monolith to services or from one set of

00:09:22,509 --> 00:09:25,779
services to different set of services

00:09:23,889 --> 00:09:27,129
without necessarily having to disturb

00:09:25,779 --> 00:09:32,949
all your apps in the field in the same

00:09:27,129 --> 00:09:34,509
way another benefit this is one is maybe

00:09:32,949 --> 00:09:35,860
talked about a little bit less in public

00:09:34,509 --> 00:09:37,990
but we certainly hear about it in the

00:09:35,860 --> 00:09:39,550
conversations we have in private it can

00:09:37,990 --> 00:09:41,620
be pretty hard to secure a rest endpoint

00:09:39,550 --> 00:09:44,800
a REST API because you end up with

00:09:41,620 --> 00:09:46,389
hundreds of these endpoints probably

00:09:44,800 --> 00:09:47,709
written on deadlines probably not

00:09:46,389 --> 00:09:49,870
written by your most senior team members

00:09:47,709 --> 00:09:51,579
and every single one of those is like a

00:09:49,870 --> 00:09:53,319
little hole in your firewall exposing

00:09:51,579 --> 00:09:55,449
some unknown combination of data based

00:09:53,319 --> 00:09:57,790
on the parameters you passed to it so

00:09:55,449 --> 00:09:59,379
how are you ever gonna audit that entire

00:09:57,790 --> 00:10:00,670
security surface every single rest

00:09:59,379 --> 00:10:03,389
endpoint you've ever had can you even

00:10:00,670 --> 00:10:07,149
list all the rest endpoints you have

00:10:03,389 --> 00:10:08,800
whereas with graph to L you can manage

00:10:07,149 --> 00:10:10,120
and secure your whole API from one

00:10:08,800 --> 00:10:11,500
central location because you have this

00:10:10,120 --> 00:10:13,449
declare to the understanding of what it

00:10:11,500 --> 00:10:17,290
is you don't have all those pink arrows

00:10:13,449 --> 00:10:18,850
that you have to analyze and finally

00:10:17,290 --> 00:10:21,040
graph kills a lot of benefits for public

00:10:18,850 --> 00:10:24,189
API is because well we often find with

00:10:21,040 --> 00:10:25,629
public API s is put it this way if you

00:10:24,189 --> 00:10:27,189
thought it was hard building the API is

00:10:25,629 --> 00:10:28,420
that your front-end team needs so they

00:10:27,189 --> 00:10:29,350
could build their applications and if

00:10:28,420 --> 00:10:30,160
you thought you're constantly having to

00:10:29,350 --> 00:10:30,819
coordinate between the front of the

00:10:30,160 --> 00:10:33,309
backend teams

00:10:30,819 --> 00:10:35,199
imagine how hard it is when you're

00:10:33,309 --> 00:10:36,040
building for partners or API consumers

00:10:35,199 --> 00:10:38,379
that don't even work at your company

00:10:36,040 --> 00:10:40,240
there might be a six-month change cycle

00:10:38,379 --> 00:10:42,370
generously if that partner needs a

00:10:40,240 --> 00:10:44,319
customization but they also have the

00:10:42,370 --> 00:10:47,290
same needs that your internal app teams

00:10:44,319 --> 00:10:49,179
need so with graphical you can build a

00:10:47,290 --> 00:10:51,220
much more flexible public API and that's

00:10:49,179 --> 00:10:52,540
that enables a lot more applications for

00:10:51,220 --> 00:10:54,069
your partners and creates a much better

00:10:52,540 --> 00:10:55,720
experience for your mutual user and

00:10:54,069 --> 00:10:57,400
that's what's driven companies like

00:10:55,720 --> 00:11:01,630
github and Shopify to

00:10:57,400 --> 00:11:03,610
Graaff feel for their public API but if

00:11:01,630 --> 00:11:04,060
we zoom out a little bit all of those

00:11:03,610 --> 00:11:06,360
are pretty

00:11:04,060 --> 00:11:09,220
nuts-and-bolts technical benefits

00:11:06,360 --> 00:11:10,960
immediate benefits but there's a bigger

00:11:09,220 --> 00:11:12,910
picture here about what the graph isn't

00:11:10,960 --> 00:11:14,560
and what it means when you have one

00:11:12,910 --> 00:11:18,089
graph of all your data there are many

00:11:14,560 --> 00:11:20,230
uses to become possible from that and

00:11:18,089 --> 00:11:21,550
you know I'm not going to go into too

00:11:20,230 --> 00:11:23,470
much detail right now and interest of

00:11:21,550 --> 00:11:24,640
time but on the Left I've listed some of

00:11:23,470 --> 00:11:26,020
the business benefits some of the

00:11:24,640 --> 00:11:28,600
leverage you can get once you have this

00:11:26,020 --> 00:11:30,880
graph so we've talked a lot about app

00:11:28,600 --> 00:11:32,230
development that's our main focus

00:11:30,880 --> 00:11:33,550
we've talked a little bit about partner

00:11:32,230 --> 00:11:35,620
enablement in other words public api's

00:11:33,550 --> 00:11:37,240
but there are so many other uses and

00:11:35,620 --> 00:11:39,010
ways your organization can benefit from

00:11:37,240 --> 00:11:40,870
graph QL if you have your data in a

00:11:39,010 --> 00:11:42,339
graph there's business intelligence you

00:11:40,870 --> 00:11:43,930
can take all that data in your graph and

00:11:42,339 --> 00:11:47,140
you can very easily get into tableau or

00:11:43,930 --> 00:11:48,550
looker or power bi not just the data in

00:11:47,140 --> 00:11:51,610
the graph but the way people are using

00:11:48,550 --> 00:11:53,950
the graph you can say you know let's

00:11:51,610 --> 00:11:55,570
look at my graph logs and say do people

00:11:53,950 --> 00:11:58,529
search more for ice cream on hot days

00:11:55,570 --> 00:12:01,000
you know in a particular country right

00:11:58,529 --> 00:12:02,560
we are hearing about graph 12 once

00:12:01,000 --> 00:12:04,360
you've got this graph we heard about it

00:12:02,560 --> 00:12:05,920
being used by product management to

00:12:04,360 --> 00:12:07,000
understand the way people are using your

00:12:05,920 --> 00:12:09,100
products or see what data is available

00:12:07,000 --> 00:12:11,320
we hear about it being used by customer

00:12:09,100 --> 00:12:12,790
support to be able to dive in and

00:12:11,320 --> 00:12:14,230
diagnose what's going with the customer

00:12:12,790 --> 00:12:16,570
or even call graphical mutations

00:12:14,230 --> 00:12:18,010
directly there are some amazing

00:12:16,570 --> 00:12:20,170
possibilities for auditing and

00:12:18,010 --> 00:12:21,820
compliance do I want to know absolutely

00:12:20,170 --> 00:12:23,410
for sure whose retrieves a particular

00:12:21,820 --> 00:12:24,910
medical record well I can do that just

00:12:23,410 --> 00:12:26,260
by looking at the graph access logs

00:12:24,910 --> 00:12:27,790
there's a lot of really cool

00:12:26,260 --> 00:12:29,860
possibilities when you have a unified

00:12:27,790 --> 00:12:32,230
way of thinking about your app data and

00:12:29,860 --> 00:12:35,140
that's even on top of all of the

00:12:32,230 --> 00:12:36,820
technical leverage you get to have a

00:12:35,140 --> 00:12:39,010
social way to think about access control

00:12:36,820 --> 00:12:40,750
demand control the change management

00:12:39,010 --> 00:12:42,670
around your schema and a lot more

00:12:40,750 --> 00:12:44,230
benefits we're going to talk about in

00:12:42,670 --> 00:12:48,400
the rest of my talk and also the rest of

00:12:44,230 --> 00:12:51,459
today so it's no wonder given all these

00:12:48,400 --> 00:12:53,200
really cool benefits on top of 20 year

00:12:51,459 --> 00:12:55,990
old rest technology that we're seeing

00:12:53,200 --> 00:12:57,160
not just tactical adoption of graph QL

00:12:55,990 --> 00:12:59,620
where people are using it for a feature

00:12:57,160 --> 00:13:00,700
- but strategic adoption of graph DL

00:12:59,620 --> 00:13:02,290
where people are rolling it out across

00:13:00,700 --> 00:13:04,240
their whole company and making big

00:13:02,290 --> 00:13:07,030
investments big bets on it

00:13:04,240 --> 00:13:08,410
one example is Airbnb and I'm gonna have

00:13:07,030 --> 00:13:09,970
Adam near a up on the stage right after

00:13:08,410 --> 00:13:11,439
me who tell you a lot more about this

00:13:09,970 --> 00:13:14,019
I just want to as a teaser I want to

00:13:11,439 --> 00:13:16,899
read you this quote from quote from Adam

00:13:14,019 --> 00:13:18,610
about what's going on Airbnb Apollo will

00:13:16,899 --> 00:13:22,509
power all of our customer experiences

00:13:18,610 --> 00:13:25,500
across web iOS and Android and another

00:13:22,509 --> 00:13:28,990
example CNBC Ashish Gupta who runs

00:13:25,500 --> 00:13:30,639
front-end engineering at CNBC says we

00:13:28,990 --> 00:13:32,259
truly believe that graphical is the next

00:13:30,639 --> 00:13:34,209
generation data layer for applications

00:13:32,259 --> 00:13:36,100
this isn't just another JavaScript

00:13:34,209 --> 00:13:38,680
library of the week that's going to help

00:13:36,100 --> 00:13:40,569
you build a future faster it is that but

00:13:38,680 --> 00:13:42,279
it's also a much bigger picture about

00:13:40,569 --> 00:13:45,310
how you can manage data as we go forward

00:13:42,279 --> 00:13:46,509
into the modern cloud era and these are

00:13:45,310 --> 00:13:49,209
just a couple the companies are making

00:13:46,509 --> 00:13:50,949
big strategic bets on graph QL and we'll

00:13:49,209 --> 00:13:52,360
hear a lot more talks about why this is

00:13:50,949 --> 00:13:55,300
and how people are doing it and how to

00:13:52,360 --> 00:13:57,220
do graph kill right over the next two

00:13:55,300 --> 00:13:58,829
days so that's why I said at the

00:13:57,220 --> 00:14:01,990
beginning that it's go time for graph QL

00:13:58,829 --> 00:14:05,139
but my other promise was that we know

00:14:01,990 --> 00:14:07,089
how to do graphical right so we're

00:14:05,139 --> 00:14:08,470
learning more stuff every day but we're

00:14:07,089 --> 00:14:10,899
now at the point where so many people

00:14:08,470 --> 00:14:12,970
have adopted graph QL at meaningful

00:14:10,899 --> 00:14:14,740
scale that we're at a point where we can

00:14:12,970 --> 00:14:16,620
kind of summarize some of the best

00:14:14,740 --> 00:14:19,240
practices about how to do it right so

00:14:16,620 --> 00:14:21,040
what we've done is we've taken

00:14:19,240 --> 00:14:22,480
everything we've learned over those

00:14:21,040 --> 00:14:24,399
hundreds of hours of conversations with

00:14:22,480 --> 00:14:25,930
you and I've summarized it down here

00:14:24,399 --> 00:14:29,439
into what I'm going to call ten

00:14:25,930 --> 00:14:30,670
graphical values and these values soared

00:14:29,439 --> 00:14:31,930
into three categories and I'm going to

00:14:30,670 --> 00:14:34,000
go through there's a set of integrity

00:14:31,930 --> 00:14:35,800
values there's a set of agility values

00:14:34,000 --> 00:14:37,689
and there's a set of operational values

00:14:35,800 --> 00:14:39,339
so I'll give you a quick overview of

00:14:37,689 --> 00:14:40,660
this you're gonna find these ideas

00:14:39,339 --> 00:14:42,819
threaded through all the talks at the

00:14:40,660 --> 00:14:44,649
conference today and we also have a lot

00:14:42,819 --> 00:14:45,759
more to say on our blog and you know

00:14:44,649 --> 00:14:47,110
there's a lots of lots of places for

00:14:45,759 --> 00:14:48,550
this conversation to continue but I just

00:14:47,110 --> 00:14:50,199
want to start with this overview so your

00:14:48,550 --> 00:14:51,129
oriented you think about the talks that

00:14:50,199 --> 00:14:56,319
you're going to see over the next two

00:14:51,129 --> 00:14:57,879
days so integrity values the integrity

00:14:56,319 --> 00:15:00,279
values are really all about the idea

00:14:57,879 --> 00:15:03,610
that you want one graph you don't want a

00:15:00,279 --> 00:15:05,410
lot of little individual graphs because

00:15:03,610 --> 00:15:07,360
when the more people are using your

00:15:05,410 --> 00:15:09,730
graph the more valuable it gets and also

00:15:07,360 --> 00:15:11,559
if you had many individual if you had

00:15:09,730 --> 00:15:13,269
dozens of little overlapping but

00:15:11,559 --> 00:15:15,009
incomplete that inconsistent and

00:15:13,269 --> 00:15:18,399
incompatible implementations of a graph

00:15:15,009 --> 00:15:19,929
it would be pure chaos so the way you

00:15:18,399 --> 00:15:21,290
want to think about a graph is this one

00:15:19,929 --> 00:15:23,449
graph for your company

00:15:21,290 --> 00:15:26,120
at the same time it's important not to

00:15:23,449 --> 00:15:28,009
create a monolith you may have we

00:15:26,120 --> 00:15:30,019
already have people that are looking at

00:15:28,009 --> 00:15:32,690
having hundreds of developers if not

00:15:30,019 --> 00:15:33,889
more consuming their graph and well and

00:15:32,690 --> 00:15:35,149
many different services teams all

00:15:33,889 --> 00:15:37,190
building services that feed into the

00:15:35,149 --> 00:15:39,649
graph so at the same time it's important

00:15:37,190 --> 00:15:41,690
that moving on to the second value that

00:15:39,649 --> 00:15:43,279
you have a federated implementation you

00:15:41,690 --> 00:15:45,110
need a way for many different teams to

00:15:43,279 --> 00:15:46,970
all work together to build that one

00:15:45,110 --> 00:15:49,190
graph for your company and decoupled

00:15:46,970 --> 00:15:50,720
their release cycles and to cover there

00:15:49,190 --> 00:15:52,069
a couple of their design process isn't

00:15:50,720 --> 00:15:54,319
actually B couple the way the services

00:15:52,069 --> 00:15:56,149
run so you want to have one graph but

00:15:54,319 --> 00:15:57,440
you want to have it federated and to

00:15:56,149 --> 00:15:59,630
enable that you want to track your

00:15:57,440 --> 00:16:02,300
scheming or registry this is another way

00:15:59,630 --> 00:16:03,800
of saying you use version control for

00:16:02,300 --> 00:16:05,420
your source code you should probably

00:16:03,800 --> 00:16:06,889
have a consistent way of tracking your

00:16:05,420 --> 00:16:07,940
schemas too you should have a source of

00:16:06,889 --> 00:16:09,050
truth for your schemas and you should

00:16:07,940 --> 00:16:12,709
under how your schemas are changing

00:16:09,050 --> 00:16:15,019
because unless you can write down what

00:16:12,709 --> 00:16:16,310
your what your schema is and you have a

00:16:15,019 --> 00:16:17,540
source of truth for that it's hard to

00:16:16,310 --> 00:16:19,220
say if you have one graph and it's hard

00:16:17,540 --> 00:16:21,079
to look for inconsistencies that might

00:16:19,220 --> 00:16:22,399
exist across your company even if you

00:16:21,079 --> 00:16:23,480
just have a client in a server you still

00:16:22,399 --> 00:16:24,769
want to have a source of truth that

00:16:23,480 --> 00:16:25,940
coordinates the many versions that are

00:16:24,769 --> 00:16:29,079
existing as you develop your graph

00:16:25,940 --> 00:16:29,079
between that client in that server

00:16:29,139 --> 00:16:35,209
second set the next four values are the

00:16:32,420 --> 00:16:37,940
agility values these are about how you

00:16:35,209 --> 00:16:39,649
know if if we brought up this idea in

00:16:37,940 --> 00:16:40,760
1970 and since someone said how would

00:16:39,649 --> 00:16:42,829
you implement this someone probably

00:16:40,760 --> 00:16:44,360
design a Gantt chart with this water

00:16:42,829 --> 00:16:45,560
flow process where over the next three

00:16:44,360 --> 00:16:46,690
years we were gonna do requirements

00:16:45,560 --> 00:16:48,440
gathering across our whole company

00:16:46,690 --> 00:16:50,420
understand what everyone wants in a

00:16:48,440 --> 00:16:51,709
graph you know and and maybe three years

00:16:50,420 --> 00:16:54,319
from now we'd have a broken

00:16:51,709 --> 00:16:55,550
implementation of it but we as an

00:16:54,319 --> 00:16:58,449
industry have learned so much about

00:16:55,550 --> 00:17:00,709
agile development processes and

00:16:58,449 --> 00:17:02,209
graphical is such a great fit for this

00:17:00,709 --> 00:17:03,620
graph keel is designed to be

00:17:02,209 --> 00:17:05,179
incrementally adoptable you don't have

00:17:03,620 --> 00:17:07,220
to stop the world and rewrite everything

00:17:05,179 --> 00:17:09,169
you can implement graphical a bit at a

00:17:07,220 --> 00:17:10,549
time and when you do that you get all

00:17:09,169 --> 00:17:12,829
the benefits an agile approach to

00:17:10,549 --> 00:17:14,959
software Bowman so there's a there's a

00:17:12,829 --> 00:17:19,010
few key points in doing agility right

00:17:14,959 --> 00:17:20,540
with graph QL one point is you want to

00:17:19,010 --> 00:17:22,250
have an abstract schema so you don't

00:17:20,540 --> 00:17:23,329
want your schema to be coupled with the

00:17:22,250 --> 00:17:24,799
way your back that's actually

00:17:23,329 --> 00:17:26,089
implemented you want to respect that

00:17:24,799 --> 00:17:27,709
your back is going to change over time

00:17:26,089 --> 00:17:28,940
so the schema should be something that

00:17:27,709 --> 00:17:30,950
kind of floats on top of your back-end

00:17:28,940 --> 00:17:34,140
and it should be ordered around the

00:17:30,950 --> 00:17:35,700
needs of the product in particular

00:17:34,140 --> 00:17:37,440
the good way to approach it that we've

00:17:35,700 --> 00:17:39,750
heard over and over again is you want to

00:17:37,440 --> 00:17:41,100
you want to build your schema kind of

00:17:39,750 --> 00:17:42,090
just in time or put another way do you

00:17:41,100 --> 00:17:44,190
want to build your schema against

00:17:42,090 --> 00:17:45,120
real-world use cases so when someone

00:17:44,190 --> 00:17:46,590
needs something out of your schema

00:17:45,120 --> 00:17:48,210
that's the time to add that field that's

00:17:46,590 --> 00:17:49,860
the time that add that object don't

00:17:48,210 --> 00:17:51,980
speculate a bunch of stuff where you're

00:17:49,860 --> 00:17:54,600
not sure that you're gonna need it

00:17:51,980 --> 00:17:56,760
likewise you want to maintain that

00:17:54,600 --> 00:17:58,440
schema over time using agile schema

00:17:56,760 --> 00:17:59,550
maintenance product practices so you're

00:17:58,440 --> 00:18:00,600
gonna add fields as you need field

00:17:59,550 --> 00:18:02,370
sometimes you're gonna find that you

00:18:00,600 --> 00:18:04,170
need to remove a field or that you want

00:18:02,370 --> 00:18:06,330
the deprecated field it turns out

00:18:04,170 --> 00:18:08,190
graphical provides really good tooling

00:18:06,330 --> 00:18:10,110
that lets you manage this process in an

00:18:08,190 --> 00:18:11,610
agile way it's not a version process

00:18:10,110 --> 00:18:13,140
where I release a version and the next I

00:18:11,610 --> 00:18:14,700
release another version extra I really

00:18:13,140 --> 00:18:17,220
another version it's a far more agile

00:18:14,700 --> 00:18:19,470
way to manage schemas made possible by

00:18:17,220 --> 00:18:21,600
all this great tooling see some examples

00:18:19,470 --> 00:18:23,940
that in a second on the performance

00:18:21,600 --> 00:18:25,200
front performance is also something you

00:18:23,940 --> 00:18:28,740
want to approach incrementally

00:18:25,200 --> 00:18:31,260
interactively agilely there's that

00:18:28,740 --> 00:18:32,520
expression premature optimization is the

00:18:31,260 --> 00:18:33,660
root of all evil I think that's

00:18:32,520 --> 00:18:36,750
something I learned back when I was a

00:18:33,660 --> 00:18:39,390
C++ coder and the same thing is true

00:18:36,750 --> 00:18:40,980
with graph QL graph field gives you such

00:18:39,390 --> 00:18:42,780
a great set of tools to understand the

00:18:40,980 --> 00:18:44,610
actual usage patterns for your api's

00:18:42,780 --> 00:18:46,440
that you can incrementally make whatever

00:18:44,610 --> 00:18:47,790
changes unique need to the way queries

00:18:46,440 --> 00:18:50,010
are executed the way your services are

00:18:47,790 --> 00:18:52,080
structured in response to the actual

00:18:50,010 --> 00:18:53,520
demand patterns you're seeing and that's

00:18:52,080 --> 00:18:55,290
a there's a very powerful set of

00:18:53,520 --> 00:18:58,980
function on around that you can even do

00:18:55,290 --> 00:19:00,450
things like predictive load planning

00:18:58,980 --> 00:19:03,480
provisioning so you can say if I ship is

00:19:00,450 --> 00:19:05,280
how much load might have create and are

00:19:03,480 --> 00:19:06,420
my services set up for that so you want

00:19:05,280 --> 00:19:10,110
to take full advantage of all those

00:19:06,420 --> 00:19:12,270
capabilities and finally you should

00:19:10,110 --> 00:19:14,430
there's another way that you can be

00:19:12,270 --> 00:19:15,900
agile with graph to L and that's to take

00:19:14,430 --> 00:19:17,580
everything you know about this graph all

00:19:15,900 --> 00:19:19,560
the great graph meta data how it's being

00:19:17,580 --> 00:19:21,480
used and put that you want to thread

00:19:19,560 --> 00:19:23,370
that through the entire softer element

00:19:21,480 --> 00:19:25,080
cycle when you're in your editor writing

00:19:23,370 --> 00:19:27,090
like pressing the first key to write the

00:19:25,080 --> 00:19:28,560
first line of code for application you

00:19:27,090 --> 00:19:30,900
want all that data about the graph to be

00:19:28,560 --> 00:19:32,370
there your fingertips and likewise when

00:19:30,900 --> 00:19:33,810
you're checking code in and your C ICD

00:19:32,370 --> 00:19:35,010
process you want the graph metadata

00:19:33,810 --> 00:19:38,640
there you want that to be you a Bic WA

00:19:35,010 --> 00:19:40,860
to start your whole process and the and

00:19:38,640 --> 00:19:44,190
the final three values and it's a lot of

00:19:40,860 --> 00:19:46,380
values the operational values this is

00:19:44,190 --> 00:19:47,190
about how you run graph QL and make it

00:19:46,380 --> 00:19:50,790
stable scale

00:19:47,190 --> 00:19:52,110
and secure so there's you know what what

00:19:50,790 --> 00:19:53,700
off looks like your graphical is a

00:19:52,110 --> 00:19:55,500
combination of both access control and

00:19:53,700 --> 00:19:57,480
demand control access control who can do

00:19:55,500 --> 00:19:59,040
what demand control how much of that can

00:19:57,480 --> 00:20:00,480
they do like can you send an expensive

00:19:59,040 --> 00:20:03,750
query or only an expensive query how

00:20:00,480 --> 00:20:05,610
many can you send because graphical

00:20:03,750 --> 00:20:07,350
gives you a lot of power with that comes

00:20:05,610 --> 00:20:08,670
you know you could say great

00:20:07,350 --> 00:20:11,850
responsibility or you could say the

00:20:08,670 --> 00:20:12,930
importance of good governance and you

00:20:11,850 --> 00:20:14,340
don't want to let just anyone on the

00:20:12,930 --> 00:20:15,780
internet send you just any graphical

00:20:14,340 --> 00:20:18,750
query need a way to manage and think

00:20:15,780 --> 00:20:20,460
about that process structured logging is

00:20:18,750 --> 00:20:24,150
another really amazing thing that

00:20:20,460 --> 00:20:25,560
graphical can do you can it's a

00:20:24,150 --> 00:20:27,810
graphical logs or not just a bunch of

00:20:25,560 --> 00:20:29,220
random text logs you actually know in a

00:20:27,810 --> 00:20:31,740
very structured and fine-grained way

00:20:29,220 --> 00:20:33,810
exactly who is doing what as a virtue of

00:20:31,740 --> 00:20:35,490
graph feels strongly tight declarative

00:20:33,810 --> 00:20:37,440
nature and there's so much benefit you

00:20:35,490 --> 00:20:39,810
can get out of that so you should have a

00:20:37,440 --> 00:20:41,010
unified strategy for that and finally

00:20:39,810 --> 00:20:43,080
when you think about how to operate

00:20:41,010 --> 00:20:45,240
graph QL there's so many capabilities

00:20:43,080 --> 00:20:46,770
here so much tooling you want to adopt a

00:20:45,240 --> 00:20:49,500
layered approach to this just like with

00:20:46,770 --> 00:20:50,280
HTTP you adopt or with rest you adopt a

00:20:49,500 --> 00:20:51,570
layered approach you're gonna have a

00:20:50,280 --> 00:20:53,910
proxy you wouldn't have a client talk

00:20:51,570 --> 00:20:54,990
directly to a web server you want to

00:20:53,910 --> 00:20:56,280
have a graph to a layer in your

00:20:54,990 --> 00:20:58,260
architecture to manage some of these

00:20:56,280 --> 00:21:00,180
considerations for you that's not to say

00:20:58,260 --> 00:21:02,610
that your back-end shouldn't speak graft

00:21:00,180 --> 00:21:04,560
well that's fine but you don't want to

00:21:02,610 --> 00:21:05,730
take every single consideration relating

00:21:04,560 --> 00:21:11,220
to graph hill and put it in every single

00:21:05,730 --> 00:21:13,860
back-end process alright so the 10

00:21:11,220 --> 00:21:18,000
graphical values will see this threaded

00:21:13,860 --> 00:21:19,020
through the the talks today now moving

00:21:18,000 --> 00:21:21,360
to a little bit more of an Apollo

00:21:19,020 --> 00:21:23,040
specific note what this raises the

00:21:21,360 --> 00:21:25,440
question is how do you do all this stuff

00:21:23,040 --> 00:21:27,200
well the other thing we've been doing

00:21:25,440 --> 00:21:30,060
over the last year or two at Apollo is

00:21:27,200 --> 00:21:31,620
we've been working to put graphical all

00:21:30,060 --> 00:21:33,030
the whole thesis of the company is we

00:21:31,620 --> 00:21:36,420
want to put graphical my hands of every

00:21:33,030 --> 00:21:38,250
development team and so our next step on

00:21:36,420 --> 00:21:40,650
that is an announcement I have today

00:21:38,250 --> 00:21:42,060
which is the new platform we're

00:21:40,650 --> 00:21:45,300
launching today the Apollo graphical

00:21:42,060 --> 00:21:46,680
platform so this is a complete set of

00:21:45,300 --> 00:21:48,120
functionality based on everything we've

00:21:46,680 --> 00:21:49,470
heard from all of you about what you

00:21:48,120 --> 00:21:51,090
need to roll this out in many different

00:21:49,470 --> 00:21:53,280
you know at many different scales and in

00:21:51,090 --> 00:21:57,420
many different use cases let me walk you

00:21:53,280 --> 00:21:59,170
through what's inside the box as part of

00:21:57,420 --> 00:22:00,610
our vision here of this being

00:21:59,170 --> 00:22:04,000
a tool set that you can use to implement

00:22:00,610 --> 00:22:05,590
graphical quickly on your team so to

00:22:04,000 --> 00:22:07,450
start with there's of course the Apollo

00:22:05,590 --> 00:22:09,100
open search libraries this is our heart

00:22:07,450 --> 00:22:11,590
and soul it always will be

00:22:09,100 --> 00:22:13,600
Apollo client Apollo server I think

00:22:11,590 --> 00:22:15,180
probably 90 95 percent of graphical

00:22:13,600 --> 00:22:18,190
implementations are built on top of this

00:22:15,180 --> 00:22:21,010
and next to that we put some great dev

00:22:18,190 --> 00:22:23,680
tools to support you in using those

00:22:21,010 --> 00:22:25,270
libraries and tools so chrome dev tools

00:22:23,680 --> 00:22:27,250
been out for a while they're great we're

00:22:25,270 --> 00:22:29,650
adding on top of that some great IDE

00:22:27,250 --> 00:22:31,840
plugin for vs code initially but with

00:22:29,650 --> 00:22:33,990
more coming and the CLI to help you

00:22:31,840 --> 00:22:36,220
manage all the functionality okay so far

00:22:33,990 --> 00:22:39,040
things you've seen before probably could

00:22:36,220 --> 00:22:40,990
have predicted but today what we're

00:22:39,040 --> 00:22:42,670
adding underneath that is a schema

00:22:40,990 --> 00:22:44,080
registry I talked about the importance

00:22:42,670 --> 00:22:45,760
of schema registries and how they're

00:22:44,080 --> 00:22:50,200
like version control for your for your

00:22:45,760 --> 00:22:51,580
schema this is a this is a free service

00:22:50,200 --> 00:22:52,720
it's a it's a SAS service we are

00:22:51,580 --> 00:22:54,490
operating for the been through the

00:22:52,720 --> 00:22:56,290
community and we think I mean you don't

00:22:54,490 --> 00:22:57,520
have to use it but we think it's it's

00:22:56,290 --> 00:22:59,980
really powerful when you're able to

00:22:57,520 --> 00:23:01,390
actually have a source of truth to

00:22:59,980 --> 00:23:05,230
understand what your schemas are so it's

00:23:01,390 --> 00:23:07,090
part of our platform vision and then on

00:23:05,230 --> 00:23:09,520
top of this we had another layer of

00:23:07,090 --> 00:23:10,780
services so because there's more than

00:23:09,520 --> 00:23:12,700
just your schema that you need to track

00:23:10,780 --> 00:23:14,050
in a graph you need to track all the

00:23:12,700 --> 00:23:16,090
clients that could use your graph you

00:23:14,050 --> 00:23:17,440
need to track all the operations that

00:23:16,090 --> 00:23:18,820
they might perform especially in a

00:23:17,440 --> 00:23:21,250
pre-registered query situation which is

00:23:18,820 --> 00:23:23,590
how many people from what security and

00:23:21,250 --> 00:23:25,060
you also need a way to perform that

00:23:23,590 --> 00:23:27,880
structured logging and that's the trace

00:23:25,060 --> 00:23:29,350
warehouse in the diagram here ingesting

00:23:27,880 --> 00:23:30,970
all those traces the trace that is

00:23:29,350 --> 00:23:32,860
produced when every graphical operation

00:23:30,970 --> 00:23:34,570
executes and having the right pipeline

00:23:32,860 --> 00:23:35,800
to get intelligence of that by

00:23:34,570 --> 00:23:37,120
aggregating and reviewing them or

00:23:35,800 --> 00:23:38,170
picking out individual traces so you can

00:23:37,120 --> 00:23:40,900
understand what's going on in your graph

00:23:38,170 --> 00:23:43,360
this is another core graph service

00:23:40,900 --> 00:23:45,700
component and then once you've got those

00:23:43,360 --> 00:23:47,890
graph services what you can layer on top

00:23:45,700 --> 00:23:50,980
of those graph services is a set of

00:23:47,890 --> 00:23:53,170
workflow and policy modules so access

00:23:50,980 --> 00:23:55,630
control demand control scheme exchange

00:23:53,170 --> 00:23:56,830
control ways to leverage all of that

00:23:55,630 --> 00:23:58,540
information you have about your graph

00:23:56,830 --> 00:23:59,560
and how it's being used throughout your

00:23:58,540 --> 00:24:03,970
development cycle throughout your

00:23:59,560 --> 00:24:07,570
company oh and one more thing very

00:24:03,970 --> 00:24:09,820
excited to announce today the first

00:24:07,570 --> 00:24:11,049
version of our distributed graph 12

00:24:09,820 --> 00:24:12,909
query execution engine

00:24:11,049 --> 00:24:14,230
which lets you take a single graph to a

00:24:12,909 --> 00:24:16,149
query and the divide that over many

00:24:14,230 --> 00:24:17,440
back-end services by creating a query

00:24:16,149 --> 00:24:18,970
plan and understanding how that

00:24:17,440 --> 00:24:20,679
courgettes federated over many different

00:24:18,970 --> 00:24:22,570
services so it looks to the client like

00:24:20,679 --> 00:24:23,889
one server but it's actually distributed

00:24:22,570 --> 00:24:27,429
over many different graphical micro

00:24:23,889 --> 00:24:29,980
services so I'll take a quick spin

00:24:27,429 --> 00:24:33,220
through some of the functionality here

00:24:29,980 --> 00:24:37,779
so you see how this all fits together so

00:24:33,220 --> 00:24:40,239
this is the new Apollo platform BS code

00:24:37,779 --> 00:24:43,149
plugin so we're writing a graphical

00:24:40,239 --> 00:24:45,789
query here and the really cool thing is

00:24:43,149 --> 00:24:48,940
I have access to my entire schema right

00:24:45,789 --> 00:24:50,590
here in my editor you know I don't have

00:24:48,940 --> 00:24:52,960
to go to any other page this is coming

00:24:50,590 --> 00:24:54,940
live off of the schema server and I can

00:24:52,960 --> 00:24:56,409
see all the fields that are available

00:24:54,940 --> 00:24:58,869
I'm on all the types I can see the

00:24:56,409 --> 00:25:00,340
documentation so I don't even have to

00:24:58,869 --> 00:25:02,190
leave my editor to have an always

00:25:00,340 --> 00:25:04,330
up-to-date always complete view of

00:25:02,190 --> 00:25:07,509
exactly what the data is what data is

00:25:04,330 --> 00:25:09,220
available in my graph and as you can see

00:25:07,509 --> 00:25:11,139
as I am recursing into the query its

00:25:09,220 --> 00:25:13,749
context-sensitive so I actually know in

00:25:11,139 --> 00:25:16,059
the query just like in graphical what

00:25:13,749 --> 00:25:18,669
fields are available at any given point

00:25:16,059 --> 00:25:20,950
in the query and I can see the types and

00:25:18,669 --> 00:25:23,499
the signatures for every single one of

00:25:20,950 --> 00:25:24,879
those those fields I can even if I'm

00:25:23,499 --> 00:25:28,629
gonna pass an argument I've got the

00:25:24,879 --> 00:25:30,669
documentation on the arguments and I can

00:25:28,629 --> 00:25:32,619
even I give them provide interactive

00:25:30,669 --> 00:25:34,600
completion so this size argument is an

00:25:32,619 --> 00:25:36,639
enum I can actually let you pick from

00:25:34,600 --> 00:25:39,909
the available email values right inside

00:25:36,639 --> 00:25:44,080
your editor so that's pretty cool but

00:25:39,909 --> 00:25:45,879
watch what's about to happen next what's

00:25:44,080 --> 00:25:48,940
that four milliseconds that appears next

00:25:45,879 --> 00:25:50,409
to is book that's the four milliseconds

00:25:48,940 --> 00:25:51,789
of latency that we are predictably

00:25:50,409 --> 00:25:53,379
telling you that field is going to

00:25:51,789 --> 00:25:54,850
contribute to running your query that's

00:25:53,379 --> 00:25:57,009
based on live production data

00:25:54,850 --> 00:25:58,840
this being plumbed into your editor so

00:25:57,009 --> 00:25:59,889
we take all the traces we run this to an

00:25:58,840 --> 00:26:01,749
aggregation pipeline

00:25:59,889 --> 00:26:03,100
and we push that into your editor so you

00:26:01,749 --> 00:26:05,320
know what's expensive and what's

00:26:03,100 --> 00:26:06,489
inexpensive not three weeks from now

00:26:05,320 --> 00:26:08,559
when you go into production as you're

00:26:06,489 --> 00:26:11,019
actually writing your code now another

00:26:08,559 --> 00:26:13,210
thing I said this was coming from the

00:26:11,019 --> 00:26:15,340
schema server we're gonna do one more

00:26:13,210 --> 00:26:18,100
thing here so this is using a version of

00:26:15,340 --> 00:26:19,990
the schema that that's the production

00:26:18,100 --> 00:26:23,200
version of this schema and now what

00:26:19,990 --> 00:26:24,309
we're gonna do is we're going to switch

00:26:23,200 --> 00:26:26,110
to a different version of the schema

00:26:24,309 --> 00:26:27,460
we're going to switch to the upcoming

00:26:26,110 --> 00:26:28,570
version of this schema that isn't live

00:26:27,460 --> 00:26:30,789
yet that's what we all need to be

00:26:28,570 --> 00:26:32,590
targeting and you can see a little

00:26:30,789 --> 00:26:34,809
squiggle appeared under named instantly

00:26:32,590 --> 00:26:36,010
when I switch to that schema and that's

00:26:34,809 --> 00:26:37,360
because that name field just got

00:26:36,010 --> 00:26:39,880
deprecated in the new version of the

00:26:37,360 --> 00:26:41,350
schema so you can see the the note about

00:26:39,880 --> 00:26:43,210
the deprecation right there in your

00:26:41,350 --> 00:26:45,789
scheme and you can fix it now the fields

00:26:43,210 --> 00:26:47,549
called full name because we are doing an

00:26:45,789 --> 00:26:50,139
agile incremental change to our schema

00:26:47,549 --> 00:26:52,000
so that's how you can put all these

00:26:50,139 --> 00:26:54,490
tools together the IDE integration of

00:26:52,000 --> 00:26:56,440
schema registry the trace warehouse to

00:26:54,490 --> 00:26:59,760
deliver an incredibly agile rich

00:26:56,440 --> 00:27:03,700
development experience around graph QL

00:26:59,760 --> 00:27:07,510
here's another example what a CIN CD

00:27:03,700 --> 00:27:09,399
look like in a graphical world so this

00:27:07,510 --> 00:27:12,250
is the dashboard of Apollo engine and

00:27:09,399 --> 00:27:14,669
you can see how now let's see so we're

00:27:12,250 --> 00:27:16,960
we're looking at this that new schema

00:27:14,669 --> 00:27:18,820
this is the schema on the schema server

00:27:16,960 --> 00:27:21,940
that we're viewing here in our dashboard

00:27:18,820 --> 00:27:23,909
and what we can see is the changes to

00:27:21,940 --> 00:27:26,559
the schemas that have happened recently

00:27:23,909 --> 00:27:28,809
we can track those changes this is

00:27:26,559 --> 00:27:30,519
integrated with version control so this

00:27:28,809 --> 00:27:32,440
is coming right this is all coming right

00:27:30,519 --> 00:27:34,299
out of get out of your ear get process

00:27:32,440 --> 00:27:35,799
we can see the changes that are

00:27:34,299 --> 00:27:38,139
happening is the schema changes over

00:27:35,799 --> 00:27:39,399
time and guess what we can also see we

00:27:38,139 --> 00:27:42,639
can see that this particular commit

00:27:39,399 --> 00:27:44,559
actually broke some clients five broken

00:27:42,639 --> 00:27:48,039
queries well what are those five broken

00:27:44,559 --> 00:27:49,750
queries we can zoom in to that and and

00:27:48,039 --> 00:27:51,909
what I mean broke it first of all well

00:27:49,750 --> 00:27:54,549
what I mean by broken is we've actually

00:27:51,909 --> 00:27:57,880
used a slice of production traffic to

00:27:54,549 --> 00:28:01,120
validate the new schema so in this

00:27:57,880 --> 00:28:03,909
window of time we found that there were

00:28:01,120 --> 00:28:05,409
clients that were making API queries

00:28:03,909 --> 00:28:09,190
that were valid before but with the new

00:28:05,409 --> 00:28:10,990
schema changes are no longer valid and

00:28:09,190 --> 00:28:12,880
so we can zoom into that we can see that

00:28:10,990 --> 00:28:15,610
because we have a client registry we can

00:28:12,880 --> 00:28:18,010
identify the particular client that the

00:28:15,610 --> 00:28:19,899
schema change impacted so is this like I

00:28:18,010 --> 00:28:21,820
don't know some like little prototype or

00:28:19,899 --> 00:28:25,480
toy or was this our main app in this

00:28:21,820 --> 00:28:27,970
case it was space Explorer on iOS we can

00:28:25,480 --> 00:28:30,820
see the exact queries because we have an

00:28:27,970 --> 00:28:32,649
operation registry they were broken by

00:28:30,820 --> 00:28:33,940
the schema change and we can even see

00:28:32,649 --> 00:28:36,080
like how much those queries are actually

00:28:33,940 --> 00:28:38,720
used and how

00:28:36,080 --> 00:28:41,750
important so hopefully these two

00:28:38,720 --> 00:28:43,580
examples paint a picture of the power of

00:28:41,750 --> 00:28:45,019
graph QL about how you can go into your

00:28:43,580 --> 00:28:48,019
IDE and how you can go into your whole

00:28:45,019 --> 00:28:49,370
workflow process to have a 360-degree

00:28:48,019 --> 00:28:51,169
picture of the data it's available to

00:28:49,370 --> 00:28:52,370
you and I would just say as a community

00:28:51,169 --> 00:28:54,049
we're only beginning to scratch the

00:28:52,370 --> 00:28:55,940
surface of this we're only a couple

00:28:54,049 --> 00:28:57,529
years into graph QL this is going to be

00:28:55,940 --> 00:28:58,399
like any other foundational technology

00:28:57,529 --> 00:28:59,690
where we're still going to be finding

00:28:58,399 --> 00:29:02,690
new cool things we can do with this

00:28:59,690 --> 00:29:04,970
stuff for the next five or ten years one

00:29:02,690 --> 00:29:06,380
more thing I can't mention federated

00:29:04,970 --> 00:29:07,789
execution without telling you a little

00:29:06,380 --> 00:29:09,769
bit about how it works so I'll just do a

00:29:07,789 --> 00:29:11,779
super high-level thing let's say you've

00:29:09,769 --> 00:29:13,220
got this incoming graphical query we're

00:29:11,779 --> 00:29:14,409
looking for recommendations for users

00:29:13,220 --> 00:29:16,220
for products they might want to purchase

00:29:14,409 --> 00:29:18,500
and we also want to know if those

00:29:16,220 --> 00:29:19,610
products are in stock so to do that

00:29:18,500 --> 00:29:21,799
we're going to need to talk to four

00:29:19,610 --> 00:29:24,830
different microservices product accounts

00:29:21,799 --> 00:29:26,059
inventory and recommendations now we

00:29:24,830 --> 00:29:27,529
don't want to create a monolith at the

00:29:26,059 --> 00:29:28,760
center of our architecture that joins

00:29:27,529 --> 00:29:30,139
all those three together we want those

00:29:28,760 --> 00:29:33,860
four teams to be able to work

00:29:30,139 --> 00:29:35,720
independently so here's what we do we

00:29:33,860 --> 00:29:37,880
send the query to the apollo gateway

00:29:35,720 --> 00:29:40,850
which is a new apollo system component

00:29:37,880 --> 00:29:43,539
as part of that purple layer and the

00:29:40,850 --> 00:29:46,130
apollo gateway constructs a query plan

00:29:43,539 --> 00:29:47,630
in the query plan just like a query plan

00:29:46,130 --> 00:29:50,240
of the database this is a distributed

00:29:47,630 --> 00:29:51,710
query execution engine so we can see how

00:29:50,240 --> 00:29:53,630
are we going to execute that query and

00:29:51,710 --> 00:29:56,269
what it uses to produce the query plan

00:29:53,630 --> 00:29:57,590
is a set of service definition files so

00:29:56,269 --> 00:29:58,940
you've loaded the service definition

00:29:57,590 --> 00:30:00,350
files for all these back-end services

00:29:58,940 --> 00:30:02,269
into the gateway you don't have to write

00:30:00,350 --> 00:30:03,740
any code in the Gateway it can work from

00:30:02,269 --> 00:30:07,159
those declarative service definition

00:30:03,740 --> 00:30:09,049
files to produce this query plan and we

00:30:07,159 --> 00:30:11,360
can see in the query plan there are four

00:30:09,049 --> 00:30:15,260
services that the query is going to need

00:30:11,360 --> 00:30:17,120
to talk to and first we have to talk to

00:30:15,260 --> 00:30:18,440
accounts and then based on we got from

00:30:17,120 --> 00:30:20,480
accounts we have to go talk to

00:30:18,440 --> 00:30:22,070
recommendations and the base book we got

00:30:20,480 --> 00:30:25,100
from recommendations we can go to

00:30:22,070 --> 00:30:28,490
product and inventory in parallel that's

00:30:25,100 --> 00:30:30,049
pretty cool and you can take and we we

00:30:28,490 --> 00:30:32,149
gather up all that data we summarize it

00:30:30,049 --> 00:30:35,179
we join it and we assemble it into the

00:30:32,149 --> 00:30:37,399
final result that's sent to the user we

00:30:35,179 --> 00:30:39,049
could cool stuff so I'm almost out of

00:30:37,399 --> 00:30:41,870
time so I won't spend too much time here

00:30:39,049 --> 00:30:43,549
but I just want to let you all know we

00:30:41,870 --> 00:30:45,320
are committed we built this because we

00:30:43,549 --> 00:30:45,660
want to see graphical adopted everywhere

00:30:45,320 --> 00:30:47,250
and

00:30:45,660 --> 00:30:49,890
want to see it reach its full potential

00:30:47,250 --> 00:30:52,080
so some of this is commercial that's

00:30:49,890 --> 00:30:53,670
part of how we and I labeled the layers

00:30:52,080 --> 00:30:55,740
to show which was which that's part of

00:30:53,670 --> 00:30:57,810
how we as Apollo make money and fund the

00:30:55,740 --> 00:31:00,060
develop in a graph QL but we're

00:30:57,810 --> 00:31:01,290
committed to offering the community dish

00:31:00,060 --> 00:31:04,340
into this it includes all the essential

00:31:01,290 --> 00:31:06,540
stuff the schemer registry and Explorer

00:31:04,340 --> 00:31:08,520
all the basic stuff that everyone needs

00:31:06,540 --> 00:31:11,490
to run this free to any query volume

00:31:08,520 --> 00:31:13,860
forever then we have a variety of plan

00:31:11,490 --> 00:31:15,300
starting as low as $49 a month you can

00:31:13,860 --> 00:31:17,460
check it on our web page it has all the

00:31:15,300 --> 00:31:19,110
functionality and if you are an

00:31:17,460 --> 00:31:22,620
enterprise user we have a whole bunch of

00:31:19,110 --> 00:31:24,930
options for a a version of this that

00:31:22,620 --> 00:31:29,040
meets your needs including a 24/7 365

00:31:24,930 --> 00:31:30,360
SLA for the entire Apollo platform so

00:31:29,040 --> 00:31:31,680
that includes Apollo client a public

00:31:30,360 --> 00:31:35,790
server you can run this in production

00:31:31,680 --> 00:31:39,900
and will support the whole thing but

00:31:35,790 --> 00:31:41,400
we've been like I said before Apollo

00:31:39,900 --> 00:31:43,200
client Apollo server our heart and soul

00:31:41,400 --> 00:31:44,670
at the same time as we've been building

00:31:43,200 --> 00:31:46,230
this over the last year we've been

00:31:44,670 --> 00:31:47,970
continuing to push the Apollo client

00:31:46,230 --> 00:31:49,350
Apollo server development forward and we

00:31:47,970 --> 00:31:51,120
also have launches on that front so this

00:31:49,350 --> 00:31:53,580
week we're launching I guess I should

00:31:51,120 --> 00:31:56,610
say releasing in this case Apollo server

00:31:53,580 --> 00:31:58,710
2.2 apollo server has to point to as an

00:31:56,610 --> 00:31:59,940
entirely new request pipeline this is a

00:31:58,710 --> 00:32:01,890
way that you can slice and dice and

00:31:59,940 --> 00:32:04,320
configure the way any graphical request

00:32:01,890 --> 00:32:05,940
is handled inside Apollo server this is

00:32:04,320 --> 00:32:07,350
the functionality that we use to build

00:32:05,940 --> 00:32:09,750
all of that Apollo platform

00:32:07,350 --> 00:32:11,190
functionality you can use it to to build

00:32:09,750 --> 00:32:12,480
cool stuff like that or even build your

00:32:11,190 --> 00:32:14,010
own version of all that functionality if

00:32:12,480 --> 00:32:16,350
you don't like ours and and want yours

00:32:14,010 --> 00:32:18,900
and likewise we're releasing Apollo

00:32:16,350 --> 00:32:21,210
client 2.5 this has integrated state

00:32:18,900 --> 00:32:23,190
management so we've seen how great

00:32:21,210 --> 00:32:25,080
Apollo link-state has been for giving

00:32:23,190 --> 00:32:26,610
people a unified way of managing all the

00:32:25,080 --> 00:32:27,630
state not just the state coming from the

00:32:26,610 --> 00:32:29,250
server but always stayed in your

00:32:27,630 --> 00:32:30,840
application using one graphical based

00:32:29,250 --> 00:32:33,510
interface so we're making that a

00:32:30,840 --> 00:32:35,400
first-class concept in Apollo client 2.5

00:32:33,510 --> 00:32:38,220
the other thing is we've made massive

00:32:35,400 --> 00:32:40,020
performance improvements based on years

00:32:38,220 --> 00:32:43,230
of experience now running graphical at

00:32:40,020 --> 00:32:44,940
scale in the client at ever more more

00:32:43,230 --> 00:32:46,620
demanding applications at higher and

00:32:44,940 --> 00:32:47,820
higher scales and now you benefit all

00:32:46,620 --> 00:32:48,720
that wisdom from all the community

00:32:47,820 --> 00:32:52,290
members who've been running at that

00:32:48,720 --> 00:32:54,530
scale one other announcement as many of

00:32:52,290 --> 00:32:55,940
you have probably heard

00:32:54,530 --> 00:32:57,940
we have a very exciting time in the

00:32:55,940 --> 00:33:00,260
graphical community where there is now a

00:32:57,940 --> 00:33:02,630
effort to build a graphical foundation

00:33:00,260 --> 00:33:04,760
so what this means graph Co has always

00:33:02,630 --> 00:33:06,950
been an open standard and we've had a

00:33:04,760 --> 00:33:08,000
great graphical working group that's

00:33:06,950 --> 00:33:10,280
been meeting over the past couple years

00:33:08,000 --> 00:33:12,170
to push graph go forward graph field has

00:33:10,280 --> 00:33:14,390
now become so important and use it so

00:33:12,170 --> 00:33:15,650
many companies and there's so many

00:33:14,390 --> 00:33:16,910
opportunities ahead of us where we need

00:33:15,650 --> 00:33:18,320
to really come together closely as a

00:33:16,910 --> 00:33:20,720
community that it's time for a

00:33:18,320 --> 00:33:22,970
foundation for a graph QL so that we can

00:33:20,720 --> 00:33:24,950
coordinate all the many uses of graph QL

00:33:22,970 --> 00:33:26,720
and so that we can't have a good forum

00:33:24,950 --> 00:33:29,330
for evolving the graph fuel standard

00:33:26,720 --> 00:33:32,330
faster so we're really excited to come

00:33:29,330 --> 00:33:34,130
together with Linux Facebook looking to

00:33:32,330 --> 00:33:35,330
foundation Facebook and many of the

00:33:34,130 --> 00:33:38,840
other top users in the graphical

00:33:35,330 --> 00:33:40,790
community to form this foundation but I

00:33:38,840 --> 00:33:41,750
want to phrase this is an invitation we

00:33:40,790 --> 00:33:42,980
are only at the beginning of this

00:33:41,750 --> 00:33:44,330
process we want to include

00:33:42,980 --> 00:33:46,310
representatives from all the

00:33:44,330 --> 00:33:47,840
constituencies in this room so we're

00:33:46,310 --> 00:33:49,640
looking for more people to be founding

00:33:47,840 --> 00:33:50,870
members of the foundation so if this is

00:33:49,640 --> 00:33:52,640
something might be interesting to you or

00:33:50,870 --> 00:33:55,610
your company whether you're implementing

00:33:52,640 --> 00:33:57,560
graphical tools you know because as an

00:33:55,610 --> 00:33:58,910
open source project or as a company or

00:33:57,560 --> 00:34:00,500
whether you are making a big investment

00:33:58,910 --> 00:34:02,540
in graphical at your company or whether

00:34:00,500 --> 00:34:04,190
you're just an end user we want to have

00:34:02,540 --> 00:34:06,710
all those things represented in the

00:34:04,190 --> 00:34:07,730
Technical Community Foundation so please

00:34:06,710 --> 00:34:08,720
reach out to us if it's something that

00:34:07,730 --> 00:34:15,110
you're interested in getting involved

00:34:08,720 --> 00:34:20,659
with so finally I just wanted to thank a

00:34:15,110 --> 00:34:23,090
few people we have a tradition of Apollo

00:34:20,659 --> 00:34:24,320
where we love to do shout outs where we

00:34:23,090 --> 00:34:27,560
we point out something we think it's

00:34:24,320 --> 00:34:30,530
awesome we all clap for it so I just

00:34:27,560 --> 00:34:32,570
want to recognize Ivan Goncharov Ivan is

00:34:30,530 --> 00:34:34,909
one of the unsung heroes of the

00:34:32,570 --> 00:34:36,560
graphical community he does so much work

00:34:34,909 --> 00:34:37,790
to maintain the specification he's been

00:34:36,560 --> 00:34:39,950
the backbone of the graphical working

00:34:37,790 --> 00:34:42,080
group and we don't hear his name on

00:34:39,950 --> 00:34:43,429
stage as often as we should so can we

00:34:42,080 --> 00:34:46,240
all give a round of applause for Ivan

00:34:43,429 --> 00:34:46,240
his great work on the graph

00:34:51,679 --> 00:34:58,010
I want to recognize Prizm aha Sura and

00:34:55,909 --> 00:34:59,390
neo4j these are three teams that are

00:34:58,010 --> 00:35:01,970
doing amazing things to push the

00:34:59,390 --> 00:35:03,290
boundaries of graph QL come up with new

00:35:01,970 --> 00:35:04,880
ways to use it new ways we can get

00:35:03,290 --> 00:35:06,050
benefits from it that's even far beyond

00:35:04,880 --> 00:35:07,430
everything I've talked about in the talk

00:35:06,050 --> 00:35:09,770
about how you can build new applications

00:35:07,430 --> 00:35:12,559
on graph QL quickly about a head can use

00:35:09,770 --> 00:35:14,420
graph feel to query a database really

00:35:12,559 --> 00:35:15,650
amazing cutting-edge work that's pushing

00:35:14,420 --> 00:35:24,680
the community forward so let's have a

00:35:15,650 --> 00:35:25,940
round of applause for them too I hope

00:35:24,680 --> 00:35:27,680
you don't mind if I quickly thank the

00:35:25,940 --> 00:35:30,619
Apollo team they have worked so hard

00:35:27,680 --> 00:35:32,270
over the last year to do everything we

00:35:30,619 --> 00:35:33,559
do on a public line at all Apollo server

00:35:32,270 --> 00:35:35,450
while also getting the whole platform

00:35:33,559 --> 00:35:37,369
together while also running on this

00:35:35,450 --> 00:35:38,359
conference and so let's give them a

00:35:37,369 --> 00:35:41,290
round of applause and thank them for

00:35:38,359 --> 00:35:41,290
their hard work getting us together

00:35:44,580 --> 00:35:49,560
I want to thank our sponsors without

00:35:47,580 --> 00:35:53,460
whom this conference would be impossible

00:35:49,560 --> 00:35:55,860
github Gatsby neo4j again shift Shopify

00:35:53,460 --> 00:36:02,580
eight base thank you so much you make it

00:35:55,860 --> 00:36:04,290
happen and we have a lounge upstairs

00:36:02,580 --> 00:36:05,640
where you can check out all of all the

00:36:04,290 --> 00:36:06,750
cool things that our sponsors are doing

00:36:05,640 --> 00:36:08,720
with graph fuel and hope you go check

00:36:06,750 --> 00:36:10,710
that out some really cool demos up there

00:36:08,720 --> 00:36:12,300
and finally I want to thank all of you

00:36:10,710 --> 00:36:14,640
for coming I know there's many things

00:36:12,300 --> 00:36:16,770
you could be doing today and I'm very

00:36:14,640 --> 00:36:19,120
grateful that you have taken the time to

00:36:16,770 --> 00:36:25,469
come spend two days here with us

00:36:19,120 --> 00:36:25,469

YouTube URL: https://www.youtube.com/watch?v=IjJkAL4RWyQ


