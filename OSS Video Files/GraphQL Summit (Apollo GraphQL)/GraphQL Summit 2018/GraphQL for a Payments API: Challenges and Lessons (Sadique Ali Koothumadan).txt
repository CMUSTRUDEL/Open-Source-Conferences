Title: GraphQL for a Payments API: Challenges and Lessons (Sadique Ali Koothumadan)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 8, 2018

Sadique Ali Koothumadan, Senior Software Engineer at Braintree, shows how to introduce a public GraphQL API on top of existing layers of APIs for a complex domain, while keeping the internal APIs flexible. Learn about the challenges we faced and the lessons we learned while moving from REST to GraphQL.

Learn more:  https://summit.graphql.com
Captions: 
	00:00:04,720 --> 00:00:10,510
good afternoon everyone thank you for

00:00:07,360 --> 00:00:13,030
coming to my talk I am sadiq ali KU

00:00:10,510 --> 00:00:17,110
tomaron do not even try my last name so

00:00:13,030 --> 00:00:20,020
many syllables for most of you I am a

00:00:17,110 --> 00:00:22,509
software engineer at Braintree I also

00:00:20,020 --> 00:00:23,110
happen to be sdq Ali on most of the

00:00:22,509 --> 00:00:25,390
Internet

00:00:23,110 --> 00:00:28,149
although there is a combination between

00:00:25,390 --> 00:00:30,669
an Indonesian teenager named sadiq ali

00:00:28,149 --> 00:00:32,739
and me as to who get to use the name is

00:00:30,669 --> 00:00:35,200
Leakey early so invariably on the

00:00:32,739 --> 00:00:37,240
internet if you see a sneaky early it's

00:00:35,200 --> 00:00:39,760
me but sometimes you will see an

00:00:37,240 --> 00:00:46,080
Indonesian teenager who is not me named

00:00:39,760 --> 00:00:46,080
stq Ali so today I am here to talk about

00:00:47,130 --> 00:00:53,470
clearly ok here so today I'm here to

00:00:51,280 --> 00:00:57,040
talk about umbrella implementing a graph

00:00:53,470 --> 00:00:59,680
QL API at Braintree some of the

00:00:57,040 --> 00:01:01,570
challenges that we ran into and some of

00:00:59,680 --> 00:01:03,550
the lessons that we learned it's a 30

00:01:01,570 --> 00:01:05,650
minute talk so I won't be go I won't be

00:01:03,550 --> 00:01:07,150
able to go into everything but I'll be

00:01:05,650 --> 00:01:12,359
able to cover most of the important

00:01:07,150 --> 00:01:14,890
things so we are Braintree and Braintree

00:01:12,359 --> 00:01:16,659
is the payment platform of choice for

00:01:14,890 --> 00:01:21,579
your favorite applications and services

00:01:16,659 --> 00:01:23,759
so if you booked an uber ride or order

00:01:21,579 --> 00:01:27,509
delivery from your favorite restaurant

00:01:23,759 --> 00:01:27,509
that payment goes through us

00:01:27,780 --> 00:01:35,759
so at brain to a graph QL is part of our

00:01:31,060 --> 00:01:38,469
ongoing effort to digital well a

00:01:35,759 --> 00:01:41,770
marketing person clearly wrote this

00:01:38,469 --> 00:01:43,659
slide and so I'm going to just try and

00:01:41,770 --> 00:01:45,189
do justice to it right side Braintree

00:01:43,659 --> 00:01:48,130
graph QL is part of our ongoing

00:01:45,189 --> 00:01:49,569
platforms digital transformation which

00:01:48,130 --> 00:01:52,119
will allow us to deliver an always

00:01:49,569 --> 00:01:53,649
improving developer and online consumer

00:01:52,119 --> 00:01:55,749
experience I believe in the second part

00:01:53,649 --> 00:01:57,579
I don't quite believe in this particular

00:01:55,749 --> 00:02:00,999
sentence the way it is written but it's

00:01:57,579 --> 00:02:02,740
ok all right so our idea is available to

00:02:00,999 --> 00:02:04,929
you at graph QL do at Braintree payments

00:02:02,740 --> 00:02:07,209
calm you can go there sign up for a

00:02:04,929 --> 00:02:08,800
sandbox account and do all the cool

00:02:07,209 --> 00:02:13,900
things that you know how to do with a

00:02:08,800 --> 00:02:16,450
graph QL API so we are a company that

00:02:13,900 --> 00:02:18,370
takes a lot of pride in our SDKs or

00:02:16,450 --> 00:02:21,790
software development kids

00:02:18,370 --> 00:02:23,830
allow our merchants to integrate fast

00:02:21,790 --> 00:02:25,599
and start accepting payments because if

00:02:23,830 --> 00:02:28,120
you're a merchant you don't really care

00:02:25,599 --> 00:02:30,879
about the fact that all you know sadiq

00:02:28,120 --> 00:02:32,140
wants to write graph QL API right you

00:02:30,879 --> 00:02:34,150
want to be able to accept payments

00:02:32,140 --> 00:02:35,950
that's all your care you care about so

00:02:34,150 --> 00:02:37,659
we take a lot of pride in our SDKs we

00:02:35,950 --> 00:02:41,769
put a lot of love and care into it and

00:02:37,659 --> 00:02:44,500
in turn our merchants lower SDKs this is

00:02:41,769 --> 00:02:46,230
basically kind of a representative

00:02:44,500 --> 00:02:49,390
diagram of what we are dealing with

00:02:46,230 --> 00:02:52,359
right we have a bunch of SDKs which most

00:02:49,390 --> 00:02:55,959
of our merchants use we have an API

00:02:52,359 --> 00:02:59,140
layer and we have Braintree services of

00:02:55,959 --> 00:03:00,879
various flavors and capabilities spread

00:02:59,140 --> 00:03:03,400
across the globe that use different

00:03:00,879 --> 00:03:07,359
stags different protocols to talk and

00:03:03,400 --> 00:03:08,739
then we have this large number of third

00:03:07,359 --> 00:03:12,250
party systems that we have no control

00:03:08,739 --> 00:03:14,049
over and if you are even a cursory

00:03:12,250 --> 00:03:16,510
familiarity with the payments domain you

00:03:14,049 --> 00:03:18,760
would know that that part that I have

00:03:16,510 --> 00:03:24,910
shown in cloud is really like a wild

00:03:18,760 --> 00:03:27,250
wild west I want to start by reminding

00:03:24,910 --> 00:03:31,180
everybody that there are no absolute

00:03:27,250 --> 00:03:34,510
isms here right this is a talk about how

00:03:31,180 --> 00:03:37,480
to layer graph QL API on an already

00:03:34,510 --> 00:03:40,090
existing very successful API and get it

00:03:37,480 --> 00:03:44,079
to run alongside that successful REST

00:03:40,090 --> 00:03:45,940
API we heard yesterday from lot of

00:03:44,079 --> 00:03:49,180
people who had the opportunity big

00:03:45,940 --> 00:03:53,349
opportunity to build their entire system

00:03:49,180 --> 00:03:54,970
from ground up with graph QL in mind for

00:03:53,349 --> 00:03:56,949
example we heard from the wonderful team

00:03:54,970 --> 00:03:58,900
at Aldi about how they were able to

00:03:56,949 --> 00:04:01,599
apply the principles of CQRS

00:03:58,900 --> 00:04:04,209
all through their platform with the idea

00:04:01,599 --> 00:04:08,049
that eventually the consumers of their

00:04:04,209 --> 00:04:12,370
API are going to access their API

00:04:08,049 --> 00:04:15,190
through graph QL I believe that we come

00:04:12,370 --> 00:04:17,260
it we come at its problem from the other

00:04:15,190 --> 00:04:19,090
side of the spectrum these things are

00:04:17,260 --> 00:04:20,889
what for us there is no guarantee that

00:04:19,090 --> 00:04:23,530
will work for you but my hope is that

00:04:20,889 --> 00:04:30,090
you would see patterns that you could

00:04:23,530 --> 00:04:30,090
potentially adopt so why graph QL

00:04:31,990 --> 00:04:37,670
as he can as you can see right we work

00:04:35,420 --> 00:04:40,190
in the payments domain and a lot of our

00:04:37,670 --> 00:04:42,320
merchants are very tech savvy right they

00:04:40,190 --> 00:04:45,560
happen to be technology companies

00:04:42,320 --> 00:04:47,650
themselves or companies were technology

00:04:45,560 --> 00:04:50,210
is at the very forefront of what they do

00:04:47,650 --> 00:04:54,770
right so we take a lot of pride in our

00:04:50,210 --> 00:04:57,080
SDKs and integrations right and most of

00:04:54,770 --> 00:04:58,400
our merchants use them but some of our

00:04:57,080 --> 00:05:00,890
merchants want direct integration

00:04:58,400 --> 00:05:03,740
because they want fine grained control

00:05:00,890 --> 00:05:07,780
over the experience that they are in 10

00:05:03,740 --> 00:05:07,780
providing to their end customers

00:05:08,770 --> 00:05:16,880
obviously graph QL allows them to do

00:05:13,040 --> 00:05:19,820
that because these api's that we have

00:05:16,880 --> 00:05:22,010
today were not written with direct

00:05:19,820 --> 00:05:29,080
integrations in mind they were returned

00:05:22,010 --> 00:05:33,680
with SDKs in mind most of our merchants

00:05:29,080 --> 00:05:37,040
provide their end customers mobile

00:05:33,680 --> 00:05:41,300
experiences that are snappy fast and we

00:05:37,040 --> 00:05:43,850
and our merchants want to use less

00:05:41,300 --> 00:05:45,680
bandwidth right so we always hear this

00:05:43,850 --> 00:05:47,390
right graph QL allows you to choose your

00:05:45,680 --> 00:05:48,710
own pay log and we have a lot of

00:05:47,390 --> 00:05:50,900
merchants who are at this point where

00:05:48,710 --> 00:05:53,270
they want to control the payload that

00:05:50,900 --> 00:05:53,990
they receive and transport between the

00:05:53,270 --> 00:05:56,320
payment gateway

00:05:53,990 --> 00:05:58,550
and the users mobile phone application

00:05:56,320 --> 00:06:00,650
we want our merchants to be able to

00:05:58,550 --> 00:06:03,440
build faster integration using

00:06:00,650 --> 00:06:06,230
interactive tooling in their activity

00:06:03,440 --> 00:06:08,750
and the ability to in respect is at the

00:06:06,230 --> 00:06:09,980
core of what graph QL does and that made

00:06:08,750 --> 00:06:11,990
it a great fit for us

00:06:09,980 --> 00:06:15,170
we also want to be in a position where

00:06:11,990 --> 00:06:19,670
we can evolve our API really fast

00:06:15,170 --> 00:06:21,320
without breaking a lot of things I'll

00:06:19,670 --> 00:06:24,560
take a moment to talk about technology

00:06:21,320 --> 00:06:27,020
choices right so if you have been paying

00:06:24,560 --> 00:06:28,910
attention the last couple of days there

00:06:27,020 --> 00:06:30,770
is less Twitter thread that go that can

00:06:28,910 --> 00:06:32,690
be kind of summarized as this right

00:06:30,770 --> 00:06:35,270
which is that graph QL exists only

00:06:32,690 --> 00:06:38,390
because JavaScript people are too much

00:06:35,270 --> 00:06:39,979
in love with JSON I'm not going to go

00:06:38,390 --> 00:06:42,770
into that I'm not a JavaScript person

00:06:39,979 --> 00:06:52,250
and we are not really a JavaScript shop

00:06:42,770 --> 00:06:55,580
but make of it what you will our API out

00:06:52,250 --> 00:06:56,919
API gateway uses Java right but that

00:06:55,580 --> 00:07:00,590
does not mean that we are going to write

00:06:56,919 --> 00:07:02,240
report edge resolver Factory right there

00:07:00,590 --> 00:07:06,080
are ways to do this in Java without

00:07:02,240 --> 00:07:11,599
having to write Java so we don't have

00:07:06,080 --> 00:07:13,370
any of those so these are our technology

00:07:11,599 --> 00:07:16,550
choices right as we started our journey

00:07:13,370 --> 00:07:18,800
along this path we looked at the tools

00:07:16,550 --> 00:07:20,330
that were available at that time and we

00:07:18,800 --> 00:07:22,880
are probably the only people upon this

00:07:20,330 --> 00:07:25,250
stage who don't use Apollo maybe that

00:07:22,880 --> 00:07:28,009
will change but we didn't right we took

00:07:25,250 --> 00:07:30,949
the graph QL Java library mostly because

00:07:28,009 --> 00:07:33,349
we want to be able to write this graph

00:07:30,949 --> 00:07:35,800
QL API alongside our existing REST API

00:07:33,349 --> 00:07:38,120
because it's very important to us that

00:07:35,800 --> 00:07:40,190
our existing merchants who have

00:07:38,120 --> 00:07:42,800
integrated with us continue to receive

00:07:40,190 --> 00:07:45,620
the same care and attention and our

00:07:42,800 --> 00:07:49,639
thought to the REST API till they

00:07:45,620 --> 00:07:51,080
migrate we also happen to use the Java

00:07:49,639 --> 00:07:53,960
implementation of Facebook data loader

00:07:51,080 --> 00:07:55,969
to improve query efficiency and

00:07:53,960 --> 00:07:57,650
eventually we moved to graph QL Java

00:07:55,969 --> 00:07:59,389
tools because we wanted to eliminate

00:07:57,650 --> 00:08:05,029
some of the boilerplate that we were in

00:07:59,389 --> 00:08:06,800
the we ended up writing if we were to

00:08:05,029 --> 00:08:09,550
make this decision today maybe we will

00:08:06,800 --> 00:08:12,080
choose a different stack we don't know

00:08:09,550 --> 00:08:16,009
but I would definitely say that looking

00:08:12,080 --> 00:08:17,719
back the learnings for our team from

00:08:16,009 --> 00:08:20,360
implementing the framework on top of

00:08:17,719 --> 00:08:24,979
these things was very important because

00:08:20,360 --> 00:08:26,330
now our team understands graph QL one of

00:08:24,979 --> 00:08:29,180
the first decisions we had to make was

00:08:26,330 --> 00:08:31,490
that as we as we were onboarding more

00:08:29,180 --> 00:08:33,800
and more teams to our API we realized

00:08:31,490 --> 00:08:36,469
that we were representing our schema in

00:08:33,800 --> 00:08:39,050
an ideal file write an interface

00:08:36,469 --> 00:08:41,270
description language file and that file

00:08:39,050 --> 00:08:43,789
was growing really fast right you can

00:08:41,270 --> 00:08:46,940
imagine we being in the payments

00:08:43,789 --> 00:08:49,790
industry expose a lot of capabilities to

00:08:46,940 --> 00:08:53,660
merchants which obviously are developed

00:08:49,790 --> 00:08:56,270
by a large number of teams so our schema

00:08:53,660 --> 00:08:59,600
file was growing fast and we had to

00:08:56,270 --> 00:09:01,970
how to organize our schema so we

00:08:59,600 --> 00:09:04,910
considered splitting our schema along

00:09:01,970 --> 00:09:06,230
domain boundaries right so some of the

00:09:04,910 --> 00:09:08,990
some of the domains that are very

00:09:06,230 --> 00:09:12,350
obvious in our industry our cards

00:09:08,990 --> 00:09:15,950
tokenization of cards reporting merchant

00:09:12,350 --> 00:09:18,710
ID so on and so forth we soon discovered

00:09:15,950 --> 00:09:20,750
that if you were to split along this

00:09:18,710 --> 00:09:24,560
line we would end up with a common file

00:09:20,750 --> 00:09:27,290
right and as you know util and common

00:09:24,560 --> 00:09:29,540
are were things going to die right if

00:09:27,290 --> 00:09:31,250
you have any kind of butyl or common

00:09:29,540 --> 00:09:33,560
this is where you end up dumping things

00:09:31,250 --> 00:09:37,220
that you don't frankly want to think a

00:09:33,560 --> 00:09:39,200
lot about so we didn't want so we

00:09:37,220 --> 00:09:41,900
decided to split along graph QL concepts

00:09:39,200 --> 00:09:44,540
now this may be a departure from some of

00:09:41,900 --> 00:09:47,090
the advice and success stories that you

00:09:44,540 --> 00:09:48,770
heard on stage today right and I want to

00:09:47,090 --> 00:09:51,020
remind everybody that this works for us

00:09:48,770 --> 00:09:53,750
and it works for us because it gives us

00:09:51,020 --> 00:09:56,990
very cleaner boundaries it has less

00:09:53,750 --> 00:09:59,690
duplication it makes it easier for our

00:09:56,990 --> 00:10:04,700
developers to go and figure out where

00:09:59,690 --> 00:10:08,060
the schema is composed from the next

00:10:04,700 --> 00:10:10,670
decision point that we arrived at was

00:10:08,060 --> 00:10:13,760
whether to make our API relay relay

00:10:10,670 --> 00:10:15,890
compliant or not so for those of you

00:10:13,760 --> 00:10:20,180
those of you who are not familiar with

00:10:15,890 --> 00:10:23,450
it relay is a specification on top of

00:10:20,180 --> 00:10:26,300
graph QL it can be summarized as a set

00:10:23,450 --> 00:10:29,990
of assumptions that a client is willing

00:10:26,300 --> 00:10:31,310
to make about its graph QL server there

00:10:29,990 --> 00:10:34,790
are some things that we really like to

00:10:31,310 --> 00:10:37,610
relay right so we really like the fact

00:10:34,790 --> 00:10:41,060
that relay enforces consistent input

00:10:37,610 --> 00:10:44,390
structure we like the fact that relay

00:10:41,060 --> 00:10:47,510
forces you to formalize connections and

00:10:44,390 --> 00:10:50,410
paginations and query efficiency we like

00:10:47,510 --> 00:10:53,720
the fact that relay talks about

00:10:50,410 --> 00:10:55,850
identifiers and the ability to refits

00:10:53,720 --> 00:10:59,540
objects in your system given an

00:10:55,850 --> 00:11:01,400
identifier so overall we think that

00:10:59,540 --> 00:11:03,250
really gave us a guiding principle and

00:11:01,400 --> 00:11:08,120
we decided to adopt some of these things

00:11:03,250 --> 00:11:09,440
of course you know stories can't always

00:11:08,120 --> 00:11:12,380
end great

00:11:09,440 --> 00:11:16,130
so this post has to think about global

00:11:12,380 --> 00:11:19,580
ideals right so real a kind of dictates

00:11:16,130 --> 00:11:21,860
that given an identifier without knowing

00:11:19,580 --> 00:11:24,620
anything about that entity you should be

00:11:21,860 --> 00:11:27,730
able to fetch it right and obviously our

00:11:24,620 --> 00:11:30,740
REST API did not care about global IDs

00:11:27,730 --> 00:11:32,510
because if you look at these examples

00:11:30,740 --> 00:11:34,610
you would know that if you look at the

00:11:32,510 --> 00:11:38,540
first you are which can be used to close

00:11:34,610 --> 00:11:41,660
an open transaction that identifier wv3

00:11:38,540 --> 00:11:44,630
e not gonna say the rest but you get the

00:11:41,660 --> 00:11:47,840
idea that has meaning in our system only

00:11:44,630 --> 00:11:49,760
so far as it lies in the corners of the

00:11:47,840 --> 00:11:52,640
transaction right it has no meaning

00:11:49,760 --> 00:11:55,250
outside that you are similarly for the

00:11:52,640 --> 00:11:59,180
second example that identifier is

00:11:55,250 --> 00:12:01,100
meaningful to our system only if it is

00:11:59,180 --> 00:12:03,170
in the context of a merchant right it

00:12:01,100 --> 00:12:06,500
works well right so you could you can

00:12:03,170 --> 00:12:08,870
think of the rest api contextualizing

00:12:06,500 --> 00:12:11,420
your identifier obviously we will not

00:12:08,870 --> 00:12:14,450
have that ability when we are moving to

00:12:11,420 --> 00:12:16,640
graph queue so we have to confront this

00:12:14,450 --> 00:12:18,530
and ask ourselves so how are we going to

00:12:16,640 --> 00:12:20,570
have global IDs in a system like ours

00:12:18,530 --> 00:12:23,900
right so we always like to think about

00:12:20,570 --> 00:12:27,080
the format of it right what does what is

00:12:23,900 --> 00:12:29,270
a global identifier look like for an ID

00:12:27,080 --> 00:12:33,230
that could be dealing with any entity in

00:12:29,270 --> 00:12:37,700
your system eventually we settled on URL

00:12:33,230 --> 00:12:39,680
say base64 encoded strings we also had

00:12:37,700 --> 00:12:42,200
to think about how does our legacy

00:12:39,680 --> 00:12:44,200
systems and our existing REST API deal

00:12:42,200 --> 00:12:47,810
with the presence of this new global ID

00:12:44,200 --> 00:12:49,760
so the way we approach it is our legacy

00:12:47,810 --> 00:12:52,730
back-end systems that the consumer

00:12:49,760 --> 00:12:55,160
doesn't get to see now adds a global ID

00:12:52,730 --> 00:12:57,500
with every entity that it returns and

00:12:55,160 --> 00:12:59,920
that the API layer we decide what to do

00:12:57,500 --> 00:13:02,950
with it so our graph q layer obviously

00:12:59,920 --> 00:13:05,630
passes it on to the client deals with

00:13:02,950 --> 00:13:09,890
deals with it when the client is asking

00:13:05,630 --> 00:13:12,339
for that entity and our REST API doesn't

00:13:09,890 --> 00:13:12,339
care about

00:13:16,279 --> 00:13:20,569
so we also want to point out the fact

00:13:18,319 --> 00:13:23,810
that we came to the decision that

00:13:20,569 --> 00:13:25,850
certain entities in our API will not

00:13:23,810 --> 00:13:28,459
have global identifier now that may seem

00:13:25,850 --> 00:13:31,100
strange because we went into the effort

00:13:28,459 --> 00:13:34,370
of trying to do a lot of the things that

00:13:31,100 --> 00:13:35,800
no that release talks about right and it

00:13:34,370 --> 00:13:40,189
turned out great for us

00:13:35,800 --> 00:13:42,920
but we are we have certain requirements

00:13:40,189 --> 00:13:45,110
that we are we I believe are not willing

00:13:42,920 --> 00:13:46,819
to go beyond which is that for example

00:13:45,110 --> 00:13:49,879
if you are a merchant there is no

00:13:46,819 --> 00:13:51,529
business if you are a merchant to even

00:13:49,879 --> 00:13:54,499
think about accessing somebody else's

00:13:51,529 --> 00:13:57,559
data so there are there are entities in

00:13:54,499 --> 00:14:02,259
our system that do not conform to global

00:13:57,559 --> 00:14:08,209
IDs that you could say make us

00:14:02,259 --> 00:14:10,339
non-compliant with really the next issue

00:14:08,209 --> 00:14:12,589
that we had to deal with like everybody

00:14:10,339 --> 00:14:14,809
else who has ever tried to take a graph

00:14:12,589 --> 00:14:17,360
QL system to production is how to deal

00:14:14,809 --> 00:14:20,180
with query complexity right if you are

00:14:17,360 --> 00:14:23,540
not careful it is very easy to build a

00:14:20,180 --> 00:14:26,389
graph QL system there is an invitation

00:14:23,540 --> 00:14:30,680
for people to perform a denial of

00:14:26,389 --> 00:14:34,220
service on your system the approach we

00:14:30,680 --> 00:14:37,610
ended up taking was that we always

00:14:34,220 --> 00:14:40,430
compute the complexity of a particular

00:14:37,610 --> 00:14:42,889
query or mutation on the fly we assign

00:14:40,430 --> 00:14:44,629
complexity factor to a very entity that

00:14:42,889 --> 00:14:50,660
can participate in a potential output

00:14:44,629 --> 00:14:52,459
and we reject we reject calls that

00:14:50,660 --> 00:14:56,269
exceed the threshold through

00:14:52,459 --> 00:14:58,970
instrumentations the next thing I want

00:14:56,269 --> 00:15:00,800
to look at is API visibility right so

00:14:58,970 --> 00:15:04,759
what does it really mean for us when we

00:15:00,800 --> 00:15:07,519
talk about API visibility the ability of

00:15:04,759 --> 00:15:10,429
graph QL to provide you in

00:15:07,519 --> 00:15:12,350
respectability and the ability for

00:15:10,429 --> 00:15:15,050
people to interact with it is great

00:15:12,350 --> 00:15:17,689
right it allows you to conveniently

00:15:15,050 --> 00:15:19,519
expose your API without doing anything

00:15:17,689 --> 00:15:22,790
right you your schema is your

00:15:19,519 --> 00:15:25,939
documentation if you will now it's not

00:15:22,790 --> 00:15:27,740
always a good thing in our experience it

00:15:25,939 --> 00:15:29,000
is not necessarily a good thing so I

00:15:27,740 --> 00:15:30,560
want to be very clear

00:15:29,000 --> 00:15:34,370
that I'm not really talking about

00:15:30,560 --> 00:15:37,280
authorization right we are talking about

00:15:34,370 --> 00:15:39,860
whether a particular client should even

00:15:37,280 --> 00:15:41,600
know that this schema has other

00:15:39,860 --> 00:15:46,400
capabilities that it has no business

00:15:41,600 --> 00:15:48,230
dealing with in our case we are very

00:15:46,400 --> 00:15:50,150
clear about certain things which is that

00:15:48,230 --> 00:15:51,580
we have server-side integrations we have

00:15:50,150 --> 00:15:54,100
client-side integrations we have

00:15:51,580 --> 00:15:57,950
administration panel so on and so forth

00:15:54,100 --> 00:16:00,680
we want to make it very very clear that

00:15:57,950 --> 00:16:02,090
the server-side integrations should not

00:16:00,680 --> 00:16:03,770
even know that there is a particular

00:16:02,090 --> 00:16:06,440
capability that a client-side

00:16:03,770 --> 00:16:08,930
integration has access to and vice versa

00:16:06,440 --> 00:16:11,090
and you can imagine what an admin panel

00:16:08,930 --> 00:16:13,250
would feature in this conversation right

00:16:11,090 --> 00:16:17,840
we want certain capabilities that are

00:16:13,250 --> 00:16:19,160
visible only to admin panel and I want

00:16:17,840 --> 00:16:20,570
to stress the fact that it's not like

00:16:19,160 --> 00:16:23,320
certain capabilities that can be

00:16:20,570 --> 00:16:26,120
executed by admin panel these

00:16:23,320 --> 00:16:28,670
capabilities are not even visible to

00:16:26,120 --> 00:16:31,310
other consumers so the way we do it is

00:16:28,670 --> 00:16:33,080
that we always build the schema

00:16:31,310 --> 00:16:35,780
dynamically so this is a theme that you

00:16:33,080 --> 00:16:38,390
have heard in a lot of lot of talks here

00:16:35,780 --> 00:16:40,550
on stage which is that you always have

00:16:38,390 --> 00:16:42,440
to build your schema for the current

00:16:40,550 --> 00:16:43,790
request for the current user who is

00:16:42,440 --> 00:16:46,790
presenting and authorize or the

00:16:43,790 --> 00:16:50,180
dedication token so building the schema

00:16:46,790 --> 00:16:53,060
late for every request allows us to look

00:16:50,180 --> 00:16:55,550
at it and say this type of consumer is a

00:16:53,060 --> 00:16:56,720
server-side integration so we are going

00:16:55,550 --> 00:17:00,080
to build the schema in such a way that

00:16:56,720 --> 00:17:04,130
the other side of the API is not visible

00:17:00,080 --> 00:17:07,910
to them which brings us to authorization

00:17:04,130 --> 00:17:10,370
right they are kind of related in our

00:17:07,910 --> 00:17:12,770
rest world although a session is pretty

00:17:10,370 --> 00:17:15,380
clear regardless of what technology

00:17:12,770 --> 00:17:17,449
stack you use or what your what language

00:17:15,380 --> 00:17:17,870
you use you end up with something like

00:17:17,449 --> 00:17:21,140
this

00:17:17,870 --> 00:17:23,900
right you have a function or method as

00:17:21,140 --> 00:17:27,680
you might call it producing a response

00:17:23,900 --> 00:17:29,750
which is mapped to a URL pattern which

00:17:27,680 --> 00:17:34,160
in turn gets mapped to a set of Rights

00:17:29,750 --> 00:17:38,480
or roles that has to be present on the

00:17:34,160 --> 00:17:42,220
credential that is being presented so if

00:17:38,480 --> 00:17:44,350
we if you look at our API or most

00:17:42,220 --> 00:17:46,330
westerby's people had a long time to

00:17:44,350 --> 00:17:47,799
think about this right people arrived at

00:17:46,330 --> 00:17:50,460
the conclusion that this is a good way

00:17:47,799 --> 00:17:54,789
of doing it and works most of the time

00:17:50,460 --> 00:17:56,620
now you know a graph QL world let's look

00:17:54,789 --> 00:18:00,190
at this example query this is not a real

00:17:56,620 --> 00:18:02,200
query right I made this up so let's say

00:18:00,190 --> 00:18:04,360
you have a query to get fetch panel data

00:18:02,200 --> 00:18:07,059
and panel data consists of transactions

00:18:04,360 --> 00:18:09,909
which succeeded and let's say there are

00:18:07,059 --> 00:18:12,970
failures that are transactions that we

00:18:09,909 --> 00:18:14,830
want only admin users to see right now

00:18:12,970 --> 00:18:17,140
we could take the same approach we took

00:18:14,830 --> 00:18:19,780
in the REST API which is to say that the

00:18:17,140 --> 00:18:22,120
moment you receive a panel data query

00:18:19,780 --> 00:18:24,490
you can ascertain that a panel data

00:18:22,120 --> 00:18:27,880
query consists of things that only an

00:18:24,490 --> 00:18:30,250
admin have access to right you can

00:18:27,880 --> 00:18:32,530
reject the entire query and we didn't

00:18:30,250 --> 00:18:35,500
want to do that we we wanted to put our

00:18:32,530 --> 00:18:38,200
merchants in a place where if they make

00:18:35,500 --> 00:18:40,240
a graph QL query they will get the

00:18:38,200 --> 00:18:41,770
results of all the operations that have

00:18:40,240 --> 00:18:47,200
that they have the right to execute

00:18:41,770 --> 00:18:49,390
right so for us that meant that we had

00:18:47,200 --> 00:18:52,240
to forward all the requests that a

00:18:49,390 --> 00:18:55,360
client could see into their downstream

00:18:52,240 --> 00:18:57,549
systems and then let the downstream

00:18:55,360 --> 00:18:59,860
systems decide whether it needs to

00:18:57,549 --> 00:19:02,080
succeed or not and if the downstream

00:18:59,860 --> 00:19:04,600
system besides that it needs to fail our

00:19:02,080 --> 00:19:07,270
graph QL layer would aggregate the

00:19:04,600 --> 00:19:09,400
errors if the downstream system decides

00:19:07,270 --> 00:19:12,010
that this is good to go and it produces

00:19:09,400 --> 00:19:15,340
a valid output we would pass it on to

00:19:12,010 --> 00:19:18,370
the client so you can think of it as

00:19:15,340 --> 00:19:22,780
partial successes which brings us to

00:19:18,370 --> 00:19:25,059
designing for partial successes in our

00:19:22,780 --> 00:19:27,010
world and in what you know and in the

00:19:25,059 --> 00:19:28,720
worlds of the systems that most of you

00:19:27,010 --> 00:19:31,240
are building there is no guarantee of

00:19:28,720 --> 00:19:33,610
any downstream action reliably

00:19:31,240 --> 00:19:37,240
succeeding and it is especially true in

00:19:33,610 --> 00:19:39,250
our world where this is what kind of

00:19:37,240 --> 00:19:41,020
what we are building right so we have

00:19:39,250 --> 00:19:42,760
the graph QL API that talks various

00:19:41,020 --> 00:19:45,669
protocols to various Braintree own

00:19:42,760 --> 00:19:49,080
systems which in turn talk to systems on

00:19:45,669 --> 00:19:52,240
by third parties living across the world

00:19:49,080 --> 00:19:53,649
third body systems could go down to

00:19:52,240 --> 00:19:54,550
third body systems could go down at the

00:19:53,649 --> 00:19:57,880
same time

00:19:54,550 --> 00:20:00,640
worse your own systems could go down so

00:19:57,880 --> 00:20:03,070
for us there is no guarantee that we

00:20:00,640 --> 00:20:04,360
will be able to serve a particular field

00:20:03,070 --> 00:20:08,170
that we'll be able to resolve a

00:20:04,360 --> 00:20:11,470
particular field so that force has to be

00:20:08,170 --> 00:20:13,540
comfortable serving knowledge the

00:20:11,470 --> 00:20:16,300
comfort being comfort comfortable self

00:20:13,540 --> 00:20:19,690
serving nulls in the graph QL me graph

00:20:16,300 --> 00:20:22,540
QL world means that the fields of your

00:20:19,690 --> 00:20:23,830
output types have to be nullable this is

00:20:22,540 --> 00:20:25,990
also a theme that you would have heard

00:20:23,830 --> 00:20:27,370
in a lot of conversations here which is

00:20:25,990 --> 00:20:30,400
that your output fields have to be

00:20:27,370 --> 00:20:33,460
number nullable especially if you are

00:20:30,400 --> 00:20:36,070
trying to build a graph QL API on top of

00:20:33,460 --> 00:20:39,550
an existing API while keeping things

00:20:36,070 --> 00:20:42,580
working for the existing consumers some

00:20:39,550 --> 00:20:45,820
people may have the luxury or fields

00:20:42,580 --> 00:20:50,020
that are not nullable in outputs if you

00:20:45,820 --> 00:20:52,210
have those you should say thanks we

00:20:50,020 --> 00:20:54,580
don't have that luxury and we have

00:20:52,210 --> 00:20:56,710
learned to look at it as a success that

00:20:54,580 --> 00:20:58,750
we all we have output fields that are

00:20:56,710 --> 00:21:03,730
nullable and we won't be able to resolve

00:20:58,750 --> 00:21:05,590
them or response to that is to be

00:21:03,730 --> 00:21:06,940
careful about collecting all the errors

00:21:05,590 --> 00:21:11,230
aggregating all the arrays and

00:21:06,940 --> 00:21:14,770
forwarding it to the client which brings

00:21:11,230 --> 00:21:19,060
me to error handling so over the years

00:21:14,770 --> 00:21:21,520
we at Braintree had a consensus in our

00:21:19,060 --> 00:21:24,370
entire system as to how errors are

00:21:21,520 --> 00:21:26,680
represented right so this used to be a

00:21:24,370 --> 00:21:29,890
rough structure of our error right our

00:21:26,680 --> 00:21:31,450
clients understood this or as

00:21:29,890 --> 00:21:33,100
understood disease or monitoring systems

00:21:31,450 --> 00:21:34,540
understood these or developers

00:21:33,100 --> 00:21:39,070
understood these or documentation

00:21:34,540 --> 00:21:41,440
understood these now more importantly

00:21:39,070 --> 00:21:45,760
you could lean back on the HTTP status

00:21:41,440 --> 00:21:49,090
code to communicate nuances in errors

00:21:45,760 --> 00:21:51,480
and with that you know with graph QL

00:21:49,090 --> 00:21:54,840
that nuance is gone right everything is

00:21:51,480 --> 00:21:54,840
to xx

00:21:56,240 --> 00:22:01,280
so if you look at the previous

00:21:57,970 --> 00:22:03,050
representation you can see that in every

00:22:01,280 --> 00:22:06,770
response we want to be able to represent

00:22:03,050 --> 00:22:08,510
multiple errors right we want to support

00:22:06,770 --> 00:22:10,370
legacy error codes because the legacy

00:22:08,510 --> 00:22:12,860
error codes are important to us we have

00:22:10,370 --> 00:22:14,600
merchants depending on it more

00:22:12,860 --> 00:22:18,380
importantly in graph QL the errors are

00:22:14,600 --> 00:22:22,480
not in respectable right so we think

00:22:18,380 --> 00:22:25,640
that error handling in graph QL deserves

00:22:22,480 --> 00:22:27,020
some law from the community and there is

00:22:25,640 --> 00:22:28,730
a lot of conversation about it learn a

00:22:27,020 --> 00:22:32,030
lot of positive conversations about it

00:22:28,730 --> 00:22:34,490
but I think that if we think of graph QL

00:22:32,030 --> 00:22:36,920
as the thing it is which is the future

00:22:34,490 --> 00:22:39,440
of API development then I think we need

00:22:36,920 --> 00:22:41,540
to invest more time and love in coming

00:22:39,440 --> 00:22:43,520
up with a better strategy to deal with

00:22:41,540 --> 00:22:46,280
errors so if you look at this right this

00:22:43,520 --> 00:22:49,130
is a sample error from our system we

00:22:46,280 --> 00:22:52,160
have a list of errors for this we have a

00:22:49,130 --> 00:22:54,140
message which is pretty clear what it is

00:22:52,160 --> 00:22:55,790
we have locations now location is an

00:22:54,140 --> 00:22:57,620
interesting right that location is

00:22:55,790 --> 00:22:59,600
talking about the place in the resolve

00:22:57,620 --> 00:23:03,260
the query where an exception happened

00:22:59,600 --> 00:23:05,510
that's not really useful at least unless

00:23:03,260 --> 00:23:07,040
we believe it's not useful if we are

00:23:05,510 --> 00:23:09,320
finding that useful I would like to talk

00:23:07,040 --> 00:23:13,130
to you and learn from you we have the

00:23:09,320 --> 00:23:15,140
pot the pot denotes the place in the

00:23:13,130 --> 00:23:16,670
query where the error happened but

00:23:15,140 --> 00:23:19,880
wouldn't be awesome if you could point

00:23:16,670 --> 00:23:21,679
the pot to the place in the deep nested

00:23:19,880 --> 00:23:24,970
structure of your input and tell that

00:23:21,679 --> 00:23:27,679
this is where they are or happened and

00:23:24,970 --> 00:23:30,080
then we have extensions right where we

00:23:27,679 --> 00:23:32,420
throw in a lot of legacy error codes

00:23:30,080 --> 00:23:34,190
again there is no typing associated with

00:23:32,420 --> 00:23:35,660
it right there is no typing associated

00:23:34,190 --> 00:23:38,480
with it the errors are not in

00:23:35,660 --> 00:23:40,370
respectable and we find that errors end

00:23:38,480 --> 00:23:43,280
up being dumping ground for untyped data

00:23:40,370 --> 00:23:45,260
right in a system and in a technology

00:23:43,280 --> 00:23:47,450
that focuses so much on getting your

00:23:45,260 --> 00:23:49,250
schema right thinking about types you

00:23:47,450 --> 00:23:51,350
know carefully selecting the type of

00:23:49,250 --> 00:23:51,980
things that you want said why why are we

00:23:51,350 --> 00:23:56,420
okay

00:23:51,980 --> 00:23:58,890
sending untyped string in errors right

00:23:56,420 --> 00:24:03,270
so I believe

00:23:58,890 --> 00:24:07,110
I believe that the strength of graph QL

00:24:03,270 --> 00:24:08,670
is in defined types right types are very

00:24:07,110 --> 00:24:11,010
important that'sthat's why we are here

00:24:08,670 --> 00:24:13,590
with without if graph here was not a

00:24:11,010 --> 00:24:16,080
pipe system we would all be sitting here

00:24:13,590 --> 00:24:18,150
I personally believe that right so I I

00:24:16,080 --> 00:24:22,170
believe that we need to extend some same

00:24:18,150 --> 00:24:23,730
thought into our handle so one of my

00:24:22,170 --> 00:24:25,380
colleagues Cory has written down a

00:24:23,730 --> 00:24:27,960
proposal to solve some of these issues

00:24:25,380 --> 00:24:29,490
right obviously nobody is going to solve

00:24:27,960 --> 00:24:33,120
it in one day nobody is going to solve

00:24:29,490 --> 00:24:35,040
it in one RFC so you may not agree with

00:24:33,120 --> 00:24:37,740
everything that is in the RFC but it's

00:24:35,040 --> 00:24:39,390
on graph QL github page so I would

00:24:37,740 --> 00:24:41,160
encourage all of you to go there and

00:24:39,390 --> 00:24:42,810
have a conversation right even if you

00:24:41,160 --> 00:24:44,820
completely disagree with the particular

00:24:42,810 --> 00:24:46,950
approach I believe that all of you

00:24:44,820 --> 00:24:51,020
having the conversation will help us

00:24:46,950 --> 00:24:51,020
improve error handling as a community

00:24:52,610 --> 00:24:59,670
the next thing that we found interesting

00:24:55,770 --> 00:25:01,980
while writing our graph QL API was the

00:24:59,670 --> 00:25:04,980
teamwork flow right as I mentioned

00:25:01,980 --> 00:25:07,170
before we have a lot of capabilities

00:25:04,980 --> 00:25:09,090
being developed by teams that are

00:25:07,170 --> 00:25:11,760
geographically distributed distributed

00:25:09,090 --> 00:25:14,340
along you know reporting structures and

00:25:11,760 --> 00:25:16,770
domain boundaries and budgets and so on

00:25:14,340 --> 00:25:21,180
and so forth right now as people are

00:25:16,770 --> 00:25:22,320
trying to contribute to this API we

00:25:21,180 --> 00:25:24,390
ended up in a really interesting

00:25:22,320 --> 00:25:27,660
situation right so we have an API team

00:25:24,390 --> 00:25:29,520
who are custodians of the schema right

00:25:27,660 --> 00:25:31,530
so they're always playing this balancing

00:25:29,520 --> 00:25:33,210
act because they're or they're acting as

00:25:31,530 --> 00:25:35,520
the custodians of the API making sure

00:25:33,210 --> 00:25:38,190
that your schema is right your API makes

00:25:35,520 --> 00:25:40,710
sense for merchants but then you have on

00:25:38,190 --> 00:25:42,690
the other side a product team who want

00:25:40,710 --> 00:25:45,030
to put a new cool feature in the hands

00:25:42,690 --> 00:25:48,570
of the merchants right so we found that

00:25:45,030 --> 00:25:53,520
this wasn't really working till we

00:25:48,570 --> 00:25:55,980
decided to address it which is that we

00:25:53,520 --> 00:25:59,730
found that the collaboration needed for

00:25:55,980 --> 00:26:02,400
creating a large-scale graph QL API

00:25:59,730 --> 00:26:06,570
pardon for the word scale maybe I should

00:26:02,400 --> 00:26:08,900
say a graph QL FPA of large scope is

00:26:06,570 --> 00:26:08,900
that

00:26:09,370 --> 00:26:14,660
the schema change has become very

00:26:11,809 --> 00:26:16,970
important and if you have like 16 teams

00:26:14,660 --> 00:26:18,950
contributing to the schema we found that

00:26:16,970 --> 00:26:22,340
the only way we could get it right was

00:26:18,950 --> 00:26:24,470
forcing people to propose schema changes

00:26:22,340 --> 00:26:26,600
without being tied into the

00:26:24,470 --> 00:26:29,059
implementations of how you are going to

00:26:26,600 --> 00:26:30,919
do a particular resolver right so we

00:26:29,059 --> 00:26:33,290
always encourage people to submit pull

00:26:30,919 --> 00:26:36,860
requests where the resolver doesn't do

00:26:33,290 --> 00:26:38,990
anything but it it presents the new

00:26:36,860 --> 00:26:42,169
schema as the team would desire it and

00:26:38,990 --> 00:26:44,570
then we will have conversations about it

00:26:42,169 --> 00:26:46,970
and the conversations are now focused on

00:26:44,570 --> 00:26:48,590
the schema and getting it right because

00:26:46,970 --> 00:26:51,350
you are no longer a child in the

00:26:48,590 --> 00:26:53,450
intricacies of how your resolver or that

00:26:51,350 --> 00:26:55,309
effector is going to work because you

00:26:53,450 --> 00:26:57,980
know as we know all right as developers

00:26:55,309 --> 00:27:00,830
we all we all like having like really

00:26:57,980 --> 00:27:01,520
long conversations around peers right we

00:27:00,830 --> 00:27:03,700
all like it

00:27:01,520 --> 00:27:07,370
if you don't you're you're a good person

00:27:03,700 --> 00:27:13,210
thank you people you know people like

00:27:07,370 --> 00:27:15,770
using PRS as slack if you will right so

00:27:13,210 --> 00:27:17,630
separating the change in the schema with

00:27:15,770 --> 00:27:19,160
the change in the implementation allows

00:27:17,630 --> 00:27:20,419
you to focus on the schema which is

00:27:19,160 --> 00:27:22,910
which you know which if you are the

00:27:20,419 --> 00:27:24,919
custodian of an API is very important to

00:27:22,910 --> 00:27:26,450
you right that is what your person sees

00:27:24,919 --> 00:27:28,610
that is good that is what is going to

00:27:26,450 --> 00:27:32,380
dictate the experience that your emergen

00:27:28,610 --> 00:27:37,100
has which brings me to my last point

00:27:32,380 --> 00:27:39,410
which is to focus on the schema again we

00:27:37,100 --> 00:27:41,630
may be departing from a lot of the

00:27:39,410 --> 00:27:43,940
advice and patterns that you have seen

00:27:41,630 --> 00:27:47,450
from other people where people who are

00:27:43,940 --> 00:27:49,370
ok with the idea that your schema will

00:27:47,450 --> 00:27:50,960
slowly evolve and you have to be

00:27:49,370 --> 00:27:53,660
comfortable with it right and I think

00:27:50,960 --> 00:27:56,870
that works when you are building things

00:27:53,660 --> 00:27:58,040
bottom up with the assumption that you

00:27:56,870 --> 00:28:00,440
are going to serve everything your

00:27:58,040 --> 00:28:02,210
graphically for us that doesn't apply

00:28:00,440 --> 00:28:04,429
because we have to keep supporting

00:28:02,210 --> 00:28:06,679
things right we are trying to put graph

00:28:04,429 --> 00:28:11,120
QL on you know for a lack of better of a

00:28:06,679 --> 00:28:13,059
very successful API all right and so we

00:28:11,120 --> 00:28:15,220
believe that getting the schema right is

00:28:13,059 --> 00:28:17,390
important in a situation like ours

00:28:15,220 --> 00:28:21,650
getting the schema right is worth

00:28:17,390 --> 00:28:22,860
investing the team's time on and schema

00:28:21,650 --> 00:28:25,350
just like anything in soft

00:28:22,860 --> 00:28:26,970
where you can get it right when there

00:28:25,350 --> 00:28:30,179
are multiple people and teams involved

00:28:26,970 --> 00:28:32,900
in only through discussions right graph

00:28:30,179 --> 00:28:35,490
QL or any kind of API so software

00:28:32,900 --> 00:28:36,960
building it ultimately is about the

00:28:35,490 --> 00:28:39,179
people who participate in the building

00:28:36,960 --> 00:28:42,360
right maybe twenty years down the lane

00:28:39,179 --> 00:28:44,070
some I would generate it but today it is

00:28:42,360 --> 00:28:46,080
about the people and so there is no

00:28:44,070 --> 00:28:48,390
substitute for like open communication

00:28:46,080 --> 00:28:50,549
between teams not just not just between

00:28:48,390 --> 00:28:53,040
the custodians and the and the product

00:28:50,549 --> 00:28:57,960
teams but between the custodians the API

00:28:53,040 --> 00:29:01,040
teams and different API teams I want to

00:28:57,960 --> 00:29:04,200
end by reminding all of us including me

00:29:01,040 --> 00:29:07,770
that an effort like what we did at

00:29:04,200 --> 00:29:10,049
Braintree does not happen because of one

00:29:07,770 --> 00:29:13,200
or two or three people right it takes

00:29:10,049 --> 00:29:15,540
like hundreds of people to create an API

00:29:13,200 --> 00:29:17,460
that exposes the kind of capabilities

00:29:15,540 --> 00:29:20,280
that we want our merchants to have

00:29:17,460 --> 00:29:21,720
access to right and yet like one or two

00:29:20,280 --> 00:29:24,720
people come on the stage and talk about

00:29:21,720 --> 00:29:27,150
it like me today so I want to thank all

00:29:24,720 --> 00:29:30,299
the people at Braintree who contributed

00:29:27,150 --> 00:29:32,610
in thought in code in review whatever

00:29:30,299 --> 00:29:34,350
form that may be to our graph PLA PA I

00:29:32,610 --> 00:29:37,410
specifically want to thank certain

00:29:34,350 --> 00:29:41,669
people so I want to thank Miriam Luc

00:29:37,410 --> 00:29:43,290
Cory Alex Tom and do for the time they

00:29:41,669 --> 00:29:47,130
spend the attention that they put into

00:29:43,290 --> 00:29:48,570
it and they thought about graph QL some

00:29:47,130 --> 00:29:52,799
of them are here if you run into them

00:29:48,570 --> 00:29:54,950
say hi finally I want to thank all of

00:29:52,799 --> 00:29:57,840
you for spending your afternoon

00:29:54,950 --> 00:30:00,720
listening to me I hope you got something

00:29:57,840 --> 00:30:02,340
out of it I certainly did because just

00:30:00,720 --> 00:30:04,260
having this conversation made me think

00:30:02,340 --> 00:30:07,500
about the things that things we did and

00:30:04,260 --> 00:30:09,990
I find that a net positive I also want

00:30:07,500 --> 00:30:12,960
to tell people that I really value

00:30:09,990 --> 00:30:15,330
feedback and I really act on feedback so

00:30:12,960 --> 00:30:17,640
if you have feedback on any aspects of

00:30:15,330 --> 00:30:20,460
my talk I will listen to you and I will

00:30:17,640 --> 00:30:20,950
thank you thank you for coming you have

00:30:20,460 --> 00:30:27,009
a nice evening

00:30:20,950 --> 00:30:27,009

YouTube URL: https://www.youtube.com/watch?v=NKMDBH0CWHs


