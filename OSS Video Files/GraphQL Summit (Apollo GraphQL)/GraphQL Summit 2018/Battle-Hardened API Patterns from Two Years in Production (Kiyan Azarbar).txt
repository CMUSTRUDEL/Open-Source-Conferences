Title: Battle-Hardened API Patterns from Two Years in Production (Kiyan Azarbar)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Kiyan Azarbar, Senior Developer at Shopify, knows that GraphQL is mission-critical at Shopify. For two years it has propelled our mobile app forward, and its use continues to spread, powering multiple APIs and bridging separate domains and services together. This talk presents the most valuable lessons we've learned about this new lingua franca.

Resources:
Learn more about Summit - https://summit.graphql.com/
Explore the GraphQL FAQs - https://www.apollographql.com/docs/resources/faq
Checkout the Apollo docs - https://www.apollographql.com/docs/
Learn GraphQL using Apollo's Tutorials: https://odyssey.apollographql.com/
Captions: 
	00:00:07,380 --> 00:00:12,790
okay thanks for coming everyone my name

00:00:10,000 --> 00:00:16,779
is Qian osbahr and I work on graphic you

00:00:12,790 --> 00:00:19,240
LAPI is at Shopify this talk the talk

00:00:16,779 --> 00:00:21,220
itself is called battle-hardened API

00:00:19,240 --> 00:00:23,800
patterns from two plus years in

00:00:21,220 --> 00:00:26,350
production but really that's just a

00:00:23,800 --> 00:00:28,480
fancy way of introducing what we've

00:00:26,350 --> 00:00:31,449
learned and distilled into a set of best

00:00:28,480 --> 00:00:33,340
practices for designing graph QL schemas

00:00:31,449 --> 00:00:37,120
or graphical api's you can use the terms

00:00:33,340 --> 00:00:39,549
interchangeably but before diving into

00:00:37,120 --> 00:00:42,610
the weeds I wanted to take some time to

00:00:39,549 --> 00:00:43,930
ease into the idea and explain why you

00:00:42,610 --> 00:00:47,680
should even care what I have to say

00:00:43,930 --> 00:00:51,869
today so I'm actually on on a team at

00:00:47,680 --> 00:00:55,299
Shopify named API patterns we're

00:00:51,869 --> 00:00:57,430
responsible for a lot of graph field

00:00:55,299 --> 00:01:00,580
related things as you can see or barely

00:00:57,430 --> 00:01:01,780
see with the font size but none of that

00:01:00,580 --> 00:01:03,400
stuff is relevant the only thing that's

00:01:01,780 --> 00:01:05,409
relevant is what's in blue so like

00:01:03,400 --> 00:01:07,840
number one which is establishing

00:01:05,409 --> 00:01:10,240
patterns and best practices now you

00:01:07,840 --> 00:01:13,290
might be wondering what the word pattern

00:01:10,240 --> 00:01:17,260
even means here but before I explain

00:01:13,290 --> 00:01:19,150
here's a really really really quick sort

00:01:17,260 --> 00:01:22,690
of condensed history and context on

00:01:19,150 --> 00:01:24,460
graph QL at Shopify this is like a talk

00:01:22,690 --> 00:01:26,650
an internal talk I gave that was 20

00:01:24,460 --> 00:01:32,050
minutes long compressed into like 45

00:01:26,650 --> 00:01:33,580
seconds so this is what graph QL kind of

00:01:32,050 --> 00:01:35,350
looked like working on graphical looked

00:01:33,580 --> 00:01:37,210
like about two years ago at two and

00:01:35,350 --> 00:01:41,680
maybe two and a half years ago mid-2016

00:01:37,210 --> 00:01:43,659
at Shopify just a few pioneers exploring

00:01:41,680 --> 00:01:46,420
new technology building something which

00:01:43,659 --> 00:01:50,770
they hope would power radically improved

00:01:46,420 --> 00:01:53,050
mobile experience so we were working on

00:01:50,770 --> 00:01:55,240
a new mobile app a native mobile app

00:01:53,050 --> 00:01:57,640
both in iOS and Android and we had

00:01:55,240 --> 00:02:00,400
chosen graph QL as a technology to power

00:01:57,640 --> 00:02:01,990
that app this was I should point out

00:02:00,400 --> 00:02:04,330
this was a highly focused mobile centric

00:02:01,990 --> 00:02:05,409
version or subset of Shopify so it

00:02:04,330 --> 00:02:09,340
didn't have to encompass the full

00:02:05,409 --> 00:02:11,769
functionality but it needed to come what

00:02:09,340 --> 00:02:13,060
was necessary for mobile so the team

00:02:11,769 --> 00:02:15,670
that was working on the graph QL

00:02:13,060 --> 00:02:17,530
back-end for that the patterns and the

00:02:15,670 --> 00:02:19,240
principles and the unified vision that

00:02:17,530 --> 00:02:20,770
they they put out was really just

00:02:19,240 --> 00:02:22,570
like a happy byproduct of the team

00:02:20,770 --> 00:02:25,120
structure so when you've got like a

00:02:22,570 --> 00:02:26,950
small number of contributors and a

00:02:25,120 --> 00:02:29,200
culture of collaboration and peer review

00:02:26,950 --> 00:02:34,180
this sort of thing just happens falls

00:02:29,200 --> 00:02:35,170
out by default so that was 2016 you see

00:02:34,180 --> 00:02:38,530
they're having a really good time there

00:02:35,170 --> 00:02:41,290
and flash-forward to today

00:02:38,530 --> 00:02:44,320
this is what graph QL being a graphical

00:02:41,290 --> 00:02:45,910
contributor is like today at Shopify so

00:02:44,320 --> 00:02:48,820
Shopify is really large mature platform

00:02:45,910 --> 00:02:50,260
it was then and it's even bigger now but

00:02:48,820 --> 00:02:53,980
at the time they were only working on a

00:02:50,260 --> 00:02:56,170
subset to support mobile our REST API

00:02:53,980 --> 00:02:57,460
has also been around for a really long

00:02:56,170 --> 00:03:00,850
time that's been built up over time and

00:02:57,460 --> 00:03:02,830
has a very large service area each

00:03:00,850 --> 00:03:05,530
aspect of arrest was built and

00:03:02,830 --> 00:03:07,090
maintained by a team experts in the

00:03:05,530 --> 00:03:10,270
respective domains people who really

00:03:07,090 --> 00:03:13,750
understand the problem space and their

00:03:10,270 --> 00:03:15,910
API consumers so graph QL for graph QL

00:03:13,750 --> 00:03:17,710
or graph QL public API to have the same

00:03:15,910 --> 00:03:20,200
depth and breadth they should hold true

00:03:17,710 --> 00:03:22,030
again so in the past year at least the

00:03:20,200 --> 00:03:23,800
majority of graph QL contributions at

00:03:22,030 --> 00:03:26,530
Java have come directly from the

00:03:23,800 --> 00:03:30,670
specialist teams themselves so one

00:03:26,530 --> 00:03:32,920
consequence of this is the the rate of

00:03:30,670 --> 00:03:36,190
PR is affecting our graph QL schemas is

00:03:32,920 --> 00:03:38,740
already pretty staggering we get like on

00:03:36,190 --> 00:03:41,380
a slow day we might get like 12 or 13

00:03:38,740 --> 00:03:44,830
PRS and on the peak day we could get in

00:03:41,380 --> 00:03:47,170
the 20s even pushing 30 so and it's and

00:03:44,830 --> 00:03:49,360
this continues to rise so this growth

00:03:47,170 --> 00:03:52,540
had to be managed somehow so Shopify as

00:03:49,360 --> 00:03:54,490
as a whole continues to have this like a

00:03:52,540 --> 00:03:56,920
unified vision for their graph QL API

00:03:54,490 --> 00:03:58,870
and also so that the individual teams

00:03:56,920 --> 00:03:59,710
could contribute to this vision and even

00:03:58,870 --> 00:04:03,760
enhance it

00:03:59,710 --> 00:04:05,850
so the stewardship of this vision is one

00:04:03,760 --> 00:04:08,350
of the main responsibilities of my team

00:04:05,850 --> 00:04:09,820
it sounds like really fancy to say

00:04:08,350 --> 00:04:11,940
stewardship but it's actually a word we

00:04:09,820 --> 00:04:14,950
use I wish we had scepters but we don't

00:04:11,940 --> 00:04:17,140
and in support of this goal we created a

00:04:14,950 --> 00:04:19,780
graph QL API design guide or design

00:04:17,140 --> 00:04:20,859
tutorial this was internal only at first

00:04:19,780 --> 00:04:22,420
it was really so that we don't have to

00:04:20,859 --> 00:04:23,590
repeat ourselves all the time when

00:04:22,420 --> 00:04:27,400
working with the teams that were writing

00:04:23,590 --> 00:04:29,110
graph QL backend code but eventually it

00:04:27,400 --> 00:04:31,220
was generalized and it was made public

00:04:29,110 --> 00:04:33,230
in May so

00:04:31,220 --> 00:04:34,430
this is the link so this talk is based

00:04:33,230 --> 00:04:35,960
on our design tutorial but it only

00:04:34,430 --> 00:04:36,980
covers a small portion of it so if

00:04:35,960 --> 00:04:40,270
you're interested in learning more I

00:04:36,980 --> 00:04:43,370
really encourage you to visit that link

00:04:40,270 --> 00:04:45,530
but first before fully diving in I want

00:04:43,370 --> 00:04:48,470
to pull up to a bit of a higher altitude

00:04:45,530 --> 00:04:51,200
and discuss in a more general general

00:04:48,470 --> 00:04:53,210
sense why this even matters so in my

00:04:51,200 --> 00:04:56,180
opinion api's are fundamental to modern

00:04:53,210 --> 00:04:58,790
apps but API design is fundamentally

00:04:56,180 --> 00:05:00,800
opposite in its approach

00:04:58,790 --> 00:05:01,760
maybe OP a pose isn't the right word

00:05:00,800 --> 00:05:04,220
maybe a better word would be

00:05:01,760 --> 00:05:05,600
complimentary but no matter how you

00:05:04,220 --> 00:05:09,200
slice it these two things are very

00:05:05,600 --> 00:05:11,540
different so this is my take modern app

00:05:09,200 --> 00:05:13,790
development is characterized by two

00:05:11,540 --> 00:05:16,250
strong driving forces one is the pace of

00:05:13,790 --> 00:05:18,320
development and also the frequency of

00:05:16,250 --> 00:05:19,580
direction changes that I tried to

00:05:18,320 --> 00:05:21,740
capture that in that slide

00:05:19,580 --> 00:05:24,440
it's a MotoGP rider doing like a 68

00:05:21,740 --> 00:05:27,680
degree turn at high speed app

00:05:24,440 --> 00:05:29,120
development also exploratory so and this

00:05:27,680 --> 00:05:30,400
is where the racetrack analogy kind of

00:05:29,120 --> 00:05:33,080
breaks down but I'm gonna ask you to

00:05:30,400 --> 00:05:34,669
break into your imagination a bit and

00:05:33,080 --> 00:05:36,800
imagine a track that never repeats

00:05:34,669 --> 00:05:38,930
itself with lots of little Forks in the

00:05:36,800 --> 00:05:41,030
road where visibility is poor and

00:05:38,930 --> 00:05:42,650
conditions are unknown that's basically

00:05:41,030 --> 00:05:44,450
app development but the best apps don't

00:05:42,650 --> 00:05:46,700
shy away from change and they aren't

00:05:44,450 --> 00:05:49,400
afraid to try new things out measure and

00:05:46,700 --> 00:05:52,820
assess so app development is really

00:05:49,400 --> 00:05:54,710
subject to rapid course corrections so

00:05:52,820 --> 00:05:57,050
what app developers need is an API that

00:05:54,710 --> 00:06:02,210
can support these shifts so on the other

00:05:57,050 --> 00:06:05,840
hand API design it's my big reveal for

00:06:02,210 --> 00:06:07,520
my analogy it's kind of like the truck

00:06:05,840 --> 00:06:09,500
that helps get these super bikes to the

00:06:07,520 --> 00:06:11,690
racetrack and supports them in their in

00:06:09,500 --> 00:06:13,700
their efforts so I think a good API

00:06:11,690 --> 00:06:16,669
design ideally allows the app to pivot

00:06:13,700 --> 00:06:19,100
back and forth as often as it needed but

00:06:16,669 --> 00:06:21,800
it's important to note that whether our

00:06:19,100 --> 00:06:23,780
design choices are whether our design

00:06:21,800 --> 00:06:26,690
choices reward us or end up haunting us

00:06:23,780 --> 00:06:28,610
they do stick around for a long time so

00:06:26,690 --> 00:06:30,919
teams need to commit to supporting these

00:06:28,610 --> 00:06:32,419
design choices in their API it's much

00:06:30,919 --> 00:06:34,070
easier to add a missing piece than to

00:06:32,419 --> 00:06:35,090
remove or change one that's not quite

00:06:34,070 --> 00:06:37,910
right and they'll touch on that later

00:06:35,090 --> 00:06:40,940
but I think good API design really boils

00:06:37,910 --> 00:06:43,550
down to striking the magic balance so on

00:06:40,940 --> 00:06:44,920
one side we have and this is this is an

00:06:43,550 --> 00:06:47,050
interesting slide because it's Express

00:06:44,920 --> 00:06:49,060
as a pair of negatives things that you

00:06:47,050 --> 00:06:50,260
shouldn't do but it's maybe more useful

00:06:49,060 --> 00:06:52,060
because I've found these tendencies

00:06:50,260 --> 00:06:54,190
these two tendencies come quite

00:06:52,060 --> 00:06:55,450
naturally to developers but because

00:06:54,190 --> 00:06:56,710
they're an opposition they balance each

00:06:55,450 --> 00:06:58,510
other out so one of those is the

00:06:56,710 --> 00:07:00,570
tendency to over engineer to try and

00:06:58,510 --> 00:07:02,680
plan for everything in the future and

00:07:00,570 --> 00:07:05,590
make an API do everything you could

00:07:02,680 --> 00:07:07,690
possibly want and the other is a

00:07:05,590 --> 00:07:09,490
tendency to oversimplify to build

00:07:07,690 --> 00:07:11,440
something really quickly that makes a

00:07:09,490 --> 00:07:13,060
lot of sense get it out the door don't

00:07:11,440 --> 00:07:15,130
worry about complications that may never

00:07:13,060 --> 00:07:17,290
arise obviously both of these tendencies

00:07:15,130 --> 00:07:18,900
are not necessarily correct that the

00:07:17,290 --> 00:07:20,920
answer is like some middle ground

00:07:18,900 --> 00:07:22,510
because these are in opposition they

00:07:20,920 --> 00:07:25,030
balance each other out and we can focus

00:07:22,510 --> 00:07:27,670
on the actual positive stated positively

00:07:25,030 --> 00:07:28,990
the group on the left there their mantra

00:07:27,670 --> 00:07:31,300
might be don't paint yourself into a

00:07:28,990 --> 00:07:33,340
corner don't makes things so radically

00:07:31,300 --> 00:07:35,020
simple that an extra feature request

00:07:33,340 --> 00:07:36,670
will require you to be our connect and

00:07:35,020 --> 00:07:38,560
the ones on the right side the

00:07:36,670 --> 00:07:40,480
oversimplify errs might say build only

00:07:38,560 --> 00:07:42,730
what's needed today so what we're really

00:07:40,480 --> 00:07:46,900
trying to do is strike that balance so

00:07:42,730 --> 00:07:48,460
all this is just to say that's getting

00:07:46,900 --> 00:07:50,970
it right the first time is really our

00:07:48,460 --> 00:07:54,370
goal it's what we strive for when we're

00:07:50,970 --> 00:07:57,220
building api's with app UX and

00:07:54,370 --> 00:07:58,930
functionality changing so rapidly it's

00:07:57,220 --> 00:08:01,570
it's clear that sometimes the API is

00:07:58,930 --> 00:08:03,310
sometimes will need to change and evolve

00:08:01,570 --> 00:08:05,200
to support this now adding something

00:08:03,310 --> 00:08:07,330
comes for free and graphic yield but if

00:08:05,200 --> 00:08:09,070
you want to change something that's more

00:08:07,330 --> 00:08:10,990
difficult now the great thing about

00:08:09,070 --> 00:08:13,660
graph QL is it gives us some really

00:08:10,990 --> 00:08:16,390
great tools to evolve our API over

00:08:13,660 --> 00:08:18,160
something like rest in which deprecation

00:08:16,390 --> 00:08:20,410
is sort of you have to hand roll your

00:08:18,160 --> 00:08:22,570
own solution but even though we have

00:08:20,410 --> 00:08:24,730
graphical deprecations it's not a magic

00:08:22,570 --> 00:08:28,150
bullet at all so getting it right the

00:08:24,730 --> 00:08:30,730
first time is the design goal here so

00:08:28,150 --> 00:08:31,960
this talk is really about some

00:08:30,730 --> 00:08:34,810
techniques that we've developed at

00:08:31,960 --> 00:08:36,430
Shopify to help us get it right more

00:08:34,810 --> 00:08:38,830
often than not more quickly and

00:08:36,430 --> 00:08:40,900
consistently than if we were to consider

00:08:38,830 --> 00:08:44,020
all angles from first principles every

00:08:40,900 --> 00:08:45,520
single time it was built up over almost

00:08:44,020 --> 00:08:47,500
three years of experience for us to

00:08:45,520 --> 00:08:49,360
support our mobile app and then in

00:08:47,500 --> 00:08:50,890
building public api's we actually have

00:08:49,360 --> 00:08:52,270
two public API so if you're interested

00:08:50,890 --> 00:08:53,260
please come to our booth and talk to us

00:08:52,270 --> 00:08:55,210
about it

00:08:53,260 --> 00:08:57,550
and then now also rapidly proliferating

00:08:55,210 --> 00:08:58,540
internal use within Shopify on top of

00:08:57,550 --> 00:09:01,240
that so

00:08:58,540 --> 00:09:02,290
is you know has gone all-in on graft you

00:09:01,240 --> 00:09:05,170
all and these are the patterns that

00:09:02,290 --> 00:09:07,300
we've established so hopefully this is

00:09:05,170 --> 00:09:08,620
how you'll feel after this talk but it's

00:09:07,300 --> 00:09:10,810
not going to even come close to covering

00:09:08,620 --> 00:09:12,850
these patterns and principles that we've

00:09:10,810 --> 00:09:14,800
assembled together in this tutorial the

00:09:12,850 --> 00:09:17,650
main purpose of the talk is to showcase

00:09:14,800 --> 00:09:19,900
a few high-value and hard-won insights

00:09:17,650 --> 00:09:22,420
and hopefully whet your appetite for

00:09:19,900 --> 00:09:24,550
finding out more so hopefully you'll be

00:09:22,420 --> 00:09:27,580
encouraged to explore these further and

00:09:24,550 --> 00:09:29,860
visit that link so I'm gonna I'm gonna

00:09:27,580 --> 00:09:31,980
start out by introducing some some of

00:09:29,860 --> 00:09:33,970
our rules for designing schemas but I

00:09:31,980 --> 00:09:36,460
realize how off-putting

00:09:33,970 --> 00:09:39,130
it is for me to sort of stand up here on

00:09:36,460 --> 00:09:41,170
a stage and rein rules down upon the

00:09:39,130 --> 00:09:43,270
group of forward-thinking technologists

00:09:41,170 --> 00:09:47,770
so let's dispense with that word these

00:09:43,270 --> 00:09:51,400
aren't rules so what are they more like

00:09:47,770 --> 00:09:52,840
guidelines suggestions or what I'm gonna

00:09:51,400 --> 00:09:54,520
go with is a term that I think is even

00:09:52,840 --> 00:09:58,060
more accurate to the spirit of what I'm

00:09:54,520 --> 00:09:59,710
gonna present and that's patterns not

00:09:58,060 --> 00:10:02,650
just because in team isn't Hampton API

00:09:59,710 --> 00:10:04,060
packs so why patterns pattern pattern

00:10:02,650 --> 00:10:06,640
recognition is the process of extracting

00:10:04,060 --> 00:10:09,820
some meaningful signal from a sea of

00:10:06,640 --> 00:10:11,380
noise and working on our API for several

00:10:09,820 --> 00:10:14,320
years we've identified some recurring

00:10:11,380 --> 00:10:17,560
themes choices design choices which we

00:10:14,320 --> 00:10:19,990
got right ones which appeared often and

00:10:17,560 --> 00:10:22,570
performed better in contrast to other

00:10:19,990 --> 00:10:25,570
choices that were more rare so over time

00:10:22,570 --> 00:10:28,540
we've kind of recognized the patterns of

00:10:25,570 --> 00:10:29,950
design choices that succeed so over time

00:10:28,540 --> 00:10:32,260
we recognize these and we did what all

00:10:29,950 --> 00:10:34,540
developers love to do we enumerated them

00:10:32,260 --> 00:10:36,130
and I mean like literally a new rate of

00:10:34,540 --> 00:10:38,980
them.they we didn't even give them names

00:10:36,130 --> 00:10:41,410
they're seven numbers so we believe

00:10:38,980 --> 00:10:44,230
these design patterns work in most cases

00:10:41,410 --> 00:10:45,760
but they may not all work for you they

00:10:44,230 --> 00:10:48,280
don't even work for us 100% of the time

00:10:45,760 --> 00:10:49,930
to be honest there are always exceptions

00:10:48,280 --> 00:10:52,060
that's what software is all about so

00:10:49,930 --> 00:10:55,210
pick and choose which ones resonate with

00:10:52,060 --> 00:10:56,470
you and make the most sense for you so

00:10:55,210 --> 00:10:58,570
before we start I'm going to quickly

00:10:56,470 --> 00:11:00,700
introduce a feature that will be

00:10:58,570 --> 00:11:02,830
modeling in our schema all of the

00:11:00,700 --> 00:11:05,830
examples will be about collections

00:11:02,830 --> 00:11:06,880
so really TL DRS collections are just a

00:11:05,830 --> 00:11:09,880
way of grouping

00:11:06,880 --> 00:11:12,010
it's just groups of products so here's

00:11:09,880 --> 00:11:13,680
what the create screen looks like in

00:11:12,010 --> 00:11:17,170
Shopify to give it more visual example

00:11:13,680 --> 00:11:19,750
collections have a title description and

00:11:17,170 --> 00:11:22,170
a type the type can be either manual or

00:11:19,750 --> 00:11:24,490
automated let's call it automatic in

00:11:22,170 --> 00:11:26,050
manual collections you select the

00:11:24,490 --> 00:11:27,760
products by hand

00:11:26,050 --> 00:11:29,950
it's what manual means in automatic

00:11:27,760 --> 00:11:31,720
collections you define a rule to

00:11:29,950 --> 00:11:36,220
dynamically match products to be

00:11:31,720 --> 00:11:37,750
included so that's what you see here in

00:11:36,220 --> 00:11:40,390
an automatic collection you've got

00:11:37,750 --> 00:11:42,460
condition conditions you select should

00:11:40,390 --> 00:11:44,530
do all the conditions have to match or

00:11:42,460 --> 00:11:46,180
is it good enough for any condition to

00:11:44,530 --> 00:11:49,900
match and then the conditions are like

00:11:46,180 --> 00:11:52,480
dropdowns for example product tag is

00:11:49,900 --> 00:11:55,540
equal to and then you enter a string so

00:11:52,480 --> 00:11:57,250
at a very high level collections might

00:11:55,540 --> 00:12:00,040
be implemented in your application like

00:11:57,250 --> 00:12:01,450
this so we have two classes one from

00:12:00,040 --> 00:12:03,550
manual collection and one for automatic

00:12:01,450 --> 00:12:06,040
collections and either through

00:12:03,550 --> 00:12:09,040
inheritance or composition or some other

00:12:06,040 --> 00:12:12,900
super computer science II term they use

00:12:09,040 --> 00:12:16,600
a common base or an abstract collection

00:12:12,900 --> 00:12:18,670
so this is what graph QL schema

00:12:16,600 --> 00:12:21,850
definition language or SDL would look

00:12:18,670 --> 00:12:24,940
like for it for anyone not familiar STL

00:12:21,850 --> 00:12:26,710
is the SDL is just a precise and concise

00:12:24,940 --> 00:12:28,300
way of capturing the state of a schema

00:12:26,710 --> 00:12:30,490
what's there and what isn't what's

00:12:28,300 --> 00:12:31,870
allowed what isn't so I won't be

00:12:30,490 --> 00:12:33,250
explaining the spec but you'll be seeing

00:12:31,870 --> 00:12:35,560
enough of this and the examples to get a

00:12:33,250 --> 00:12:37,270
good sense of it so this is this

00:12:35,560 --> 00:12:39,820
represents the most literal way of

00:12:37,270 --> 00:12:41,710
designing this feature in graph QL we've

00:12:39,820 --> 00:12:44,290
got the generic collection interface and

00:12:41,710 --> 00:12:45,970
two types that implement the interface

00:12:44,290 --> 00:12:47,260
and to implement interface it's

00:12:45,970 --> 00:12:48,730
basically just a contract that you have

00:12:47,260 --> 00:12:51,370
to have the same fields of the same

00:12:48,730 --> 00:12:52,780
types so if you see there manual

00:12:51,370 --> 00:12:54,690
collection implements collection by

00:12:52,780 --> 00:12:57,790
simply just having a title that's string

00:12:54,690 --> 00:13:00,220
now automatic collection also satisfies

00:12:57,790 --> 00:13:02,110
that contract but it has an extra has an

00:13:00,220 --> 00:13:03,940
extra field so the rules field is an

00:13:02,110 --> 00:13:06,160
example of a field that varies between

00:13:03,940 --> 00:13:10,030
the two concrete collection types since

00:13:06,160 --> 00:13:13,090
manual doesn't have it but this schema

00:13:10,030 --> 00:13:15,010
is just a direct representation of how

00:13:13,090 --> 00:13:17,680
we implemented this in our application

00:13:15,010 --> 00:13:19,000
code there may be good reasons for our

00:13:17,680 --> 00:13:19,710
back-end to do it this way to be

00:13:19,000 --> 00:13:21,690
designed

00:13:19,710 --> 00:13:24,810
this way but it doesn't mean our API

00:13:21,690 --> 00:13:26,760
should mirror this design after all the

00:13:24,810 --> 00:13:28,830
the core concept that we're trying to

00:13:26,760 --> 00:13:32,610
model here is the collection itself and

00:13:28,830 --> 00:13:34,320
that's part of our business domain so

00:13:32,610 --> 00:13:35,730
the question is what our API consumers

00:13:34,320 --> 00:13:38,970
actually care about the two different

00:13:35,730 --> 00:13:41,610
types of collections and an interface

00:13:38,970 --> 00:13:43,650
and I don't think they would so here's

00:13:41,610 --> 00:13:45,510
the simplified solution we've collapsed

00:13:43,650 --> 00:13:47,280
the two different types you even got rid

00:13:45,510 --> 00:13:49,190
of the interface we just have a

00:13:47,280 --> 00:13:51,750
collection now with the title and rules

00:13:49,190 --> 00:13:52,950
but you may have noticed the downside

00:13:51,750 --> 00:13:54,720
you may may have may think to yourself

00:13:52,950 --> 00:13:56,700
well rules only apply to automatic

00:13:54,720 --> 00:13:59,520
collections and before they were only on

00:13:56,700 --> 00:14:00,960
that type now there now we have like

00:13:59,520 --> 00:14:02,610
manual collections which will have this

00:14:00,960 --> 00:14:06,330
extraneous field which might be

00:14:02,610 --> 00:14:07,740
confusing or misleading but you know we

00:14:06,330 --> 00:14:11,010
really want to design our types around

00:14:07,740 --> 00:14:13,200
the most important concept rules really

00:14:11,010 --> 00:14:14,460
of secondary importance to this concept

00:14:13,200 --> 00:14:16,440
so they shouldn't drive our design and

00:14:14,460 --> 00:14:18,000
if we had two separate types it was

00:14:16,440 --> 00:14:20,790
really because they were driving our

00:14:18,000 --> 00:14:23,760
design and one thing I've learned in

00:14:20,790 --> 00:14:26,430
trying to convince developers of a

00:14:23,760 --> 00:14:28,260
certain way of designing things of api's

00:14:26,430 --> 00:14:30,390
is that sometimes all you need to do is

00:14:28,260 --> 00:14:32,700
reframe the situation so you can

00:14:30,390 --> 00:14:34,260
actually say that you know collections

00:14:32,700 --> 00:14:35,730
manual collections are just a special

00:14:34,260 --> 00:14:38,040
case of an automatic collection that

00:14:35,730 --> 00:14:39,300
have an empty empty rule set so that

00:14:38,040 --> 00:14:42,090
works and that's what we've done here

00:14:39,300 --> 00:14:45,210
and it actually makes our design kind of

00:14:42,090 --> 00:14:46,380
more future-proof and flexible since you

00:14:45,210 --> 00:14:47,850
know maybe collections in the future

00:14:46,380 --> 00:14:49,110
maybe they could end up being a hybrid

00:14:47,850 --> 00:14:50,400
and maybe we want to have collections

00:14:49,110 --> 00:14:53,070
where you add products manually but

00:14:50,400 --> 00:14:58,710
there also have rules to automatically

00:14:53,070 --> 00:15:00,090
apply extra products to those so this is

00:14:58,710 --> 00:15:02,940
now distilled into our first pattern

00:15:00,090 --> 00:15:04,770
which is never expose implementation

00:15:02,940 --> 00:15:06,150
details in your API design it doesn't

00:15:04,770 --> 00:15:07,500
matter how you accomplish something what

00:15:06,150 --> 00:15:12,060
you're really trying to do is represent

00:15:07,500 --> 00:15:13,440
the concept in the API now design your

00:15:12,060 --> 00:15:15,900
console your API around the business

00:15:13,440 --> 00:15:17,370
domain and don't design it around

00:15:15,900 --> 00:15:19,200
implementation but also don't design

00:15:17,370 --> 00:15:22,080
around the user interface and definitely

00:15:19,200 --> 00:15:24,180
don't design it around legacy api's so

00:15:22,080 --> 00:15:25,230
we're gonna go over one more example of

00:15:24,180 --> 00:15:28,410
this because this is really our most

00:15:25,230 --> 00:15:30,570
fundamental pattern or guideline so

00:15:28,410 --> 00:15:32,019
again I describe collections as groups

00:15:30,570 --> 00:15:34,899
of products now

00:15:32,019 --> 00:15:36,399
this can end up being many many standard

00:15:34,899 --> 00:15:38,199
many to many relationship in our

00:15:36,399 --> 00:15:39,279
database and our database might be

00:15:38,199 --> 00:15:40,899
designed something like this with a

00:15:39,279 --> 00:15:43,209
collections table in a products table

00:15:40,899 --> 00:15:46,420
and then a join table which will call

00:15:43,209 --> 00:15:48,670
collection memberships so a collection

00:15:46,420 --> 00:15:51,610
membership represents a product being in

00:15:48,670 --> 00:15:53,470
collection so if we want to model this

00:15:51,610 --> 00:15:54,999
in graph QL once again we start with a

00:15:53,470 --> 00:15:59,230
really direct representation of this in

00:15:54,999 --> 00:16:02,709
our schema we've got a collection and it

00:15:59,230 --> 00:16:05,799
has a memberships field which is a list

00:16:02,709 --> 00:16:07,839
of it's a list field of collection

00:16:05,799 --> 00:16:11,470
membership type same with products they

00:16:07,839 --> 00:16:13,360
both have that now the first guideline

00:16:11,470 --> 00:16:15,519
again is violated here the first pattern

00:16:13,360 --> 00:16:16,869
which was to avoid avoid exposing

00:16:15,519 --> 00:16:18,399
implementation details and that's

00:16:16,869 --> 00:16:20,499
exactly what we've done so to improve

00:16:18,399 --> 00:16:21,999
this design we should ask the same

00:16:20,499 --> 00:16:23,799
question we asked before which is what

00:16:21,999 --> 00:16:26,369
is the main concept that we care about I

00:16:23,799 --> 00:16:28,779
think this one's even easier to come see

00:16:26,369 --> 00:16:30,369
so the main concept is really a

00:16:28,779 --> 00:16:32,199
collection as a group of products and

00:16:30,369 --> 00:16:34,329
products can be in multiple collections

00:16:32,199 --> 00:16:36,699
no one really cares about join tables

00:16:34,329 --> 00:16:39,519
no one wants to traverse through joint a

00:16:36,699 --> 00:16:41,799
of these so ideally for the API we can

00:16:39,519 --> 00:16:43,119
design that as directly as possible so

00:16:41,799 --> 00:16:44,139
the new version on the right does that

00:16:43,119 --> 00:16:45,939
and I've grayed out the fields that

00:16:44,139 --> 00:16:47,350
don't matter to this example we've got a

00:16:45,939 --> 00:16:49,569
collection that has a products field

00:16:47,350 --> 00:16:51,730
which is the list of products that it

00:16:49,569 --> 00:16:53,740
contains or that are contained in it and

00:16:51,730 --> 00:16:55,509
product has a collections field with a

00:16:53,740 --> 00:16:57,819
list of collections that contain that

00:16:55,509 --> 00:17:00,160
product so this is much simpler we've

00:16:57,819 --> 00:17:03,120
completely eliminated a type and a

00:17:00,160 --> 00:17:05,529
concept an extraneous concept to the API

00:17:03,120 --> 00:17:08,439
so here's here's where we're at right

00:17:05,529 --> 00:17:09,789
now a schema is pretty minimal and I've

00:17:08,439 --> 00:17:12,610
excluded a lot of fields that we have in

00:17:09,789 --> 00:17:16,360
our real production schema I did this to

00:17:12,610 --> 00:17:18,220
keep it simple but one other tip here is

00:17:16,360 --> 00:17:19,809
before you start adding fields and types

00:17:18,220 --> 00:17:21,250
you should really ask yourself if it's

00:17:19,809 --> 00:17:23,110
really needed at this time just because

00:17:21,250 --> 00:17:25,059
the database column or model property or

00:17:23,110 --> 00:17:26,350
a rest attribute exists doesn't mean it

00:17:25,059 --> 00:17:29,590
automatically needs to be added to

00:17:26,350 --> 00:17:32,320
graphic UL from the start so this is a

00:17:29,590 --> 00:17:34,450
pattern number two it's easier to add

00:17:32,320 --> 00:17:37,330
elements to a schema than to remove them

00:17:34,450 --> 00:17:39,100
or to change them now usually removing

00:17:37,330 --> 00:17:40,720
or changing something from the schema

00:17:39,100 --> 00:17:43,010
it's a breaking change and can be very

00:17:40,720 --> 00:17:45,360
difficult to deal with

00:17:43,010 --> 00:17:46,710
and the if you're wondering what the

00:17:45,360 --> 00:17:50,720
snake is this is what happened when I

00:17:46,710 --> 00:17:52,710
typed in high-res image of an adder so

00:17:50,720 --> 00:17:54,960
another thing I wanted to point out is

00:17:52,710 --> 00:17:57,330
that graph QL is an opportunity to

00:17:54,960 --> 00:17:58,890
really clean house you can get rid of

00:17:57,330 --> 00:18:00,930
things that don't make sense to expose

00:17:58,890 --> 00:18:02,790
you can rename fields you can shift

00:18:00,930 --> 00:18:04,110
things around it's an opportunity to get

00:18:02,790 --> 00:18:06,170
things right and you should be really

00:18:04,110 --> 00:18:08,850
comfortable with the idea of not being

00:18:06,170 --> 00:18:10,700
slavishly devoted to mimicking what is

00:18:08,850 --> 00:18:15,960
existing in the in the rest api or

00:18:10,700 --> 00:18:17,340
existing implementation so here's our

00:18:15,960 --> 00:18:20,070
collection type with some new fields

00:18:17,340 --> 00:18:22,260
added we've got two two rules fields now

00:18:20,070 --> 00:18:23,790
so I'm gonna highlight those we've got

00:18:22,260 --> 00:18:25,170
rules which you already know and then we

00:18:23,790 --> 00:18:27,660
have this field called rules applied

00:18:25,170 --> 00:18:30,480
disjunctive Li the second one is a new

00:18:27,660 --> 00:18:31,830
boolean property these fields both have

00:18:30,480 --> 00:18:33,750
to do with collection rules and they're

00:18:31,830 --> 00:18:36,390
obviously related so this is true

00:18:33,750 --> 00:18:38,610
semantically but it's also hinted by the

00:18:36,390 --> 00:18:41,100
fact that we chose names that have a

00:18:38,610 --> 00:18:42,690
shared prefix so is there a way to

00:18:41,100 --> 00:18:44,490
indicate this relationship in the schema

00:18:42,690 --> 00:18:45,750
somehow it's kind of leading question

00:18:44,490 --> 00:18:47,970
because obviously not you know there is

00:18:45,750 --> 00:18:50,310
in rest there are reasons to shy away

00:18:47,970 --> 00:18:51,870
from this because you know we want to

00:18:50,310 --> 00:18:53,280
like reduce round trips we don't want to

00:18:51,870 --> 00:18:55,710
over inflate the response for people who

00:18:53,280 --> 00:18:58,350
don't care about those fields but in

00:18:55,710 --> 00:19:01,470
graph QL we can actually group those two

00:18:58,350 --> 00:19:03,300
into a type so in on the right there we

00:19:01,470 --> 00:19:05,880
have a collection which has a rule set

00:19:03,300 --> 00:19:07,800
which is a list of rules and then a

00:19:05,880 --> 00:19:09,750
boolean that explains how those rules

00:19:07,800 --> 00:19:10,700
are applied whether disjunctive Lee or

00:19:09,750 --> 00:19:13,290
conjunctively

00:19:10,700 --> 00:19:16,050
so that just means generally just means

00:19:13,290 --> 00:19:17,820
or or any this this might seem like

00:19:16,050 --> 00:19:19,740
overkill to you because it's just two

00:19:17,820 --> 00:19:22,620
fields but we've really found that in

00:19:19,740 --> 00:19:24,240
it's not really overkill you could argue

00:19:22,620 --> 00:19:26,400
the case that if they're only two then

00:19:24,240 --> 00:19:28,440
maybe it should be flat but collapsed

00:19:26,400 --> 00:19:30,870
again into a type gives you a nice place

00:19:28,440 --> 00:19:33,390
to contain future fields are related to

00:19:30,870 --> 00:19:35,400
the same concept and definitely once you

00:19:33,390 --> 00:19:38,790
get to three related things we really

00:19:35,400 --> 00:19:40,530
recommend that people use a type so a

00:19:38,790 --> 00:19:42,240
pattern number three is group closely

00:19:40,530 --> 00:19:44,270
related fields together into their own

00:19:42,240 --> 00:19:46,770
type

00:19:44,270 --> 00:19:48,240
so it's very common for new schemas to

00:19:46,770 --> 00:19:51,210
start with a one-to-one mapping between

00:19:48,240 --> 00:19:52,830
graph QL types and models but one other

00:19:51,210 --> 00:19:55,260
thing I'd like to point out is that you

00:19:52,830 --> 00:19:57,630
shouldn't be afraid to create types that

00:19:55,260 --> 00:19:59,450
don't correspond to some to a model in

00:19:57,630 --> 00:20:01,530
your system or a table in your database

00:19:59,450 --> 00:20:03,930
don't be afraid to create types which

00:20:01,530 --> 00:20:07,460
only exist in craft QL if they help to

00:20:03,930 --> 00:20:10,410
represent your business domain properly

00:20:07,460 --> 00:20:13,590
so that's where we are now on the right

00:20:10,410 --> 00:20:15,360
we've applied some of these patterns but

00:20:13,590 --> 00:20:16,860
let's focus on this products field and

00:20:15,360 --> 00:20:19,440
this is kind of an important one

00:20:16,860 --> 00:20:20,970
it's not very sexy but it's important so

00:20:19,440 --> 00:20:24,330
right now products is returning a list

00:20:20,970 --> 00:20:26,160
of products under collection now at

00:20:24,330 --> 00:20:28,350
Shopify collections can easily have

00:20:26,160 --> 00:20:29,790
thousands 210th out tens of thousands of

00:20:28,350 --> 00:20:31,770
products so trying to return every

00:20:29,790 --> 00:20:35,190
product would be in a single array would

00:20:31,770 --> 00:20:37,620
be unwise so whenever you implement a

00:20:35,190 --> 00:20:40,410
field that a plural field that returns

00:20:37,620 --> 00:20:42,090
multiple objects always ask yourself if

00:20:40,410 --> 00:20:44,730
this field should be paginate it or not

00:20:42,090 --> 00:20:46,830
how many of this object can there be

00:20:44,730 --> 00:20:48,810
is there any theoretical limit in the

00:20:46,830 --> 00:20:50,250
data model if there is and this limit is

00:20:48,810 --> 00:20:52,350
really small then maybe there's a case

00:20:50,250 --> 00:20:54,060
for keeping it as a list field and you

00:20:52,350 --> 00:20:56,130
can make the call as to whether

00:20:54,060 --> 00:20:58,650
pagination is worth the extra complexity

00:20:56,130 --> 00:21:00,900
because make no mistake pagination is

00:20:58,650 --> 00:21:03,120
complex although we do have tools and

00:21:00,900 --> 00:21:04,740
clients to help us deal with that in our

00:21:03,120 --> 00:21:07,050
case the field needs to be paginating

00:21:04,740 --> 00:21:09,230
so I'm not actually gonna go over the

00:21:07,050 --> 00:21:11,820
details of pagination there we use

00:21:09,230 --> 00:21:13,800
connections from the relay spec which is

00:21:11,820 --> 00:21:16,370
a very common pattern you just need to

00:21:13,800 --> 00:21:19,170
pick one and stick to it

00:21:16,370 --> 00:21:21,390
but here's the the pattern we like to

00:21:19,170 --> 00:21:24,210
call it look forward to the future can

00:21:21,390 --> 00:21:26,220
you envision a time when this list field

00:21:24,210 --> 00:21:27,360
might need to be paginate a lot of

00:21:26,220 --> 00:21:28,710
people really want to start out saying

00:21:27,360 --> 00:21:29,940
oh it's no problem like it's not gonna

00:21:28,710 --> 00:21:32,280
be a long list it's fine that's fine

00:21:29,940 --> 00:21:34,380
it's just a bunch of known values but

00:21:32,280 --> 00:21:35,820
then those get added to an attitude over

00:21:34,380 --> 00:21:37,890
time eventually get to the point where

00:21:35,820 --> 00:21:39,360
they're really unwieldy to deal with but

00:21:37,890 --> 00:21:41,520
the important thing to point out here is

00:21:39,360 --> 00:21:43,110
not the details of connections versus

00:21:41,520 --> 00:21:45,150
list fields it's that if you choose one

00:21:43,110 --> 00:21:46,500
and then you want to go to a connection

00:21:45,150 --> 00:21:47,940
in the future if you choose list field

00:21:46,500 --> 00:21:49,410
you want to go to connection you can't

00:21:47,940 --> 00:21:52,440
it totally breaks the clients

00:21:49,410 --> 00:21:53,850
expectations of the return type so this

00:21:52,440 --> 00:21:55,600
is kind of like deciding whether you

00:21:53,850 --> 00:21:57,940
need 16 gigs of ram in your

00:21:55,600 --> 00:21:59,799
but bro you better be sure that you're

00:21:57,940 --> 00:22:02,590
getting the right size because you can't

00:21:59,799 --> 00:22:04,059
change it later or you can with the

00:22:02,590 --> 00:22:05,500
graph QL but you have to go through all

00:22:04,059 --> 00:22:10,480
the deprecation cycle and it's a real

00:22:05,500 --> 00:22:12,100
pain so now we come to the image ID

00:22:10,480 --> 00:22:14,830
field I'm going to summarize this really

00:22:12,100 --> 00:22:16,809
really really quickly that it's actually

00:22:14,830 --> 00:22:18,880
a tendency for people who are

00:22:16,809 --> 00:22:20,230
translating rest api is to provide ID

00:22:18,880 --> 00:22:22,570
fields but this is actually an

00:22:20,230 --> 00:22:24,730
anti-pattern in graph QL and the better

00:22:22,570 --> 00:22:28,360
solution is to actually provide the

00:22:24,730 --> 00:22:30,340
object itself so this is what I've done

00:22:28,360 --> 00:22:31,750
here a collection contains the image

00:22:30,340 --> 00:22:34,270
which is an image type which right now

00:22:31,750 --> 00:22:36,460
is just a placeholder for ID but it will

00:22:34,270 --> 00:22:38,830
give you a place to add other other

00:22:36,460 --> 00:22:40,840
fields on the images in the future so

00:22:38,830 --> 00:22:42,970
that's pattern number five which is to

00:22:40,840 --> 00:22:46,030
use object references instead of ID

00:22:42,970 --> 00:22:47,890
fields this really allows you to go in

00:22:46,030 --> 00:22:49,659
and traverse relations and do it all in

00:22:47,890 --> 00:22:53,530
one query whereas in the past with res

00:22:49,659 --> 00:22:55,510
yet to make multiple requests we've got

00:22:53,530 --> 00:22:57,880
a field here which is kind of weird

00:22:55,510 --> 00:23:00,250
sounds weird called body HTML and this

00:22:57,880 --> 00:23:01,929
is kind of for legacy reasons but what

00:23:00,250 --> 00:23:04,990
this field is actually doing is

00:23:01,929 --> 00:23:06,730
describing the collection so this field

00:23:04,990 --> 00:23:09,039
name can easily be confusing to someone

00:23:06,730 --> 00:23:11,440
using the API now it's really just a

00:23:09,039 --> 00:23:13,299
description so why not just rename it

00:23:11,440 --> 00:23:15,340
which is a much sort of clearer way to

00:23:13,299 --> 00:23:17,440
do it so our pattern number six is

00:23:15,340 --> 00:23:19,090
always choose field names based on what

00:23:17,440 --> 00:23:21,220
makes sense not based on the

00:23:19,090 --> 00:23:23,049
implementation or on what the field was

00:23:21,220 --> 00:23:28,679
called in legacy api's this is very

00:23:23,049 --> 00:23:31,570
important I'm going to skip over scalars

00:23:28,679 --> 00:23:35,590
and I'm coming to one of my favorite

00:23:31,570 --> 00:23:37,630
rules here so if you look over here I've

00:23:35,590 --> 00:23:40,059
been ignoring the collection rule type

00:23:37,630 --> 00:23:42,250
for a while but let's take a look at it

00:23:40,059 --> 00:23:43,659
now so as a reminder products can be in

00:23:42,250 --> 00:23:46,059
the collection when they're matched by a

00:23:43,659 --> 00:23:48,580
rule each rule consists of a field to

00:23:46,059 --> 00:23:51,120
match on or a database column and a type

00:23:48,580 --> 00:23:53,980
of relation and an actual value to use

00:23:51,120 --> 00:23:55,690
so here's an example there in white so

00:23:53,980 --> 00:23:57,640
we could say like the field is product

00:23:55,690 --> 00:24:01,120
title the relation is contains and the

00:23:57,640 --> 00:24:03,150
value is shirt what's important to note

00:24:01,120 --> 00:24:06,549
here is if you look at those dropdowns

00:24:03,150 --> 00:24:08,530
the left side field is a drop down the

00:24:06,549 --> 00:24:08,960
right side the relation is also a drop

00:24:08,530 --> 00:24:10,789
down

00:24:08,960 --> 00:24:13,250
so these are things with an own set of

00:24:10,789 --> 00:24:14,480
values and often their representative

00:24:13,250 --> 00:24:15,679
interfaces as dropdowns

00:24:14,480 --> 00:24:18,049
but because of this we can actually

00:24:15,679 --> 00:24:19,909
convert these two fields to enums and

00:24:18,049 --> 00:24:24,380
this is something that we do a lot a job

00:24:19,909 --> 00:24:26,120
by so now we have two new enum types

00:24:24,380 --> 00:24:28,880
collection rule field and collection

00:24:26,120 --> 00:24:30,980
rule relation and they're a well-defined

00:24:28,880 --> 00:24:35,059
set of fields that you can match on and

00:24:30,980 --> 00:24:37,100
relations and this is like really one of

00:24:35,059 --> 00:24:38,840
my favorites which is use younam's for

00:24:37,100 --> 00:24:40,130
fields which can only take a specific

00:24:38,840 --> 00:24:42,740
set of values if you're not one of those

00:24:40,130 --> 00:24:44,029
values you can't get in and this is

00:24:42,740 --> 00:24:45,890
actually something really important to

00:24:44,029 --> 00:24:47,659
emphasize because if you're writing your

00:24:45,890 --> 00:24:48,799
application in a dynamic language that

00:24:47,659 --> 00:24:50,480
doesn't have strong typing it's

00:24:48,799 --> 00:24:53,600
definitely not a tendency to think this

00:24:50,480 --> 00:24:55,399
way and even a database design level we

00:24:53,600 --> 00:24:56,659
often have tables that contain lists of

00:24:55,399 --> 00:24:59,240
known values but they're represented as

00:24:56,659 --> 00:25:01,640
varchars so we're used to using magic

00:24:59,240 --> 00:25:03,260
strings graph QL is this really great

00:25:01,640 --> 00:25:06,230
way to add a little bit of typing a

00:25:03,260 --> 00:25:08,059
little bit of like guarantees to your

00:25:06,230 --> 00:25:10,940
contract it's actually really really

00:25:08,059 --> 00:25:12,320
helpful in writing your queries people

00:25:10,940 --> 00:25:13,940
who are like working at graphical or

00:25:12,320 --> 00:25:15,289
anything with linting can actually see

00:25:13,940 --> 00:25:17,690
all the possible values there's no

00:25:15,289 --> 00:25:21,200
chance of misspelling them etc it's

00:25:17,690 --> 00:25:25,220
really useful for the consumer so here's

00:25:21,200 --> 00:25:26,990
something else here's some pseudo

00:25:25,220 --> 00:25:29,390
JavaScript code I'm not really the

00:25:26,990 --> 00:25:31,850
greatest JavaScript so I assume that it

00:25:29,390 --> 00:25:35,630
works but this is to try and determine

00:25:31,850 --> 00:25:39,260
to try and determine whether a product

00:25:35,630 --> 00:25:41,120
is contained in the collection so you'd

00:25:39,260 --> 00:25:42,440
actually have to get the full list and

00:25:41,120 --> 00:25:45,590
you have to Trevor you have to iterate

00:25:42,440 --> 00:25:47,450
in traverse and make comparisons and the

00:25:45,590 --> 00:25:50,299
problem is when that happens every

00:25:47,450 --> 00:25:51,770
client has to do this and every client

00:25:50,299 --> 00:25:53,659
has to implement the same or similar

00:25:51,770 --> 00:25:56,299
logic and it leads to duplication and

00:25:53,659 --> 00:25:57,559
potentially differences in bugs so what

00:25:56,299 --> 00:25:58,370
is the solution here and this is

00:25:57,559 --> 00:25:59,779
something that's really great about

00:25:58,370 --> 00:26:02,870
graph cubes because our fields don't

00:25:59,779 --> 00:26:05,179
have to directly correspond to database

00:26:02,870 --> 00:26:07,429
columns or things to do with our with

00:26:05,179 --> 00:26:09,590
our datastore we can have derive fields

00:26:07,429 --> 00:26:11,510
are really just driven by functions so

00:26:09,590 --> 00:26:13,419
this field takes the ID of a product and

00:26:11,510 --> 00:26:15,230
returns a boolean based on the server

00:26:13,419 --> 00:26:18,049
determining if a product is in the

00:26:15,230 --> 00:26:19,850
collection or not so we can have a field

00:26:18,049 --> 00:26:20,320
has product passing an ID and then we

00:26:19,850 --> 00:26:22,509
will get

00:26:20,320 --> 00:26:26,019
true or false and this is really really

00:26:22,509 --> 00:26:28,630
useful so pattern number nine is the API

00:26:26,019 --> 00:26:31,389
should provide business logic not just

00:26:28,630 --> 00:26:33,730
data complex calculations really should

00:26:31,389 --> 00:26:38,590
be done on the server in one place not

00:26:33,730 --> 00:26:40,539
on the client in many places so I'm

00:26:38,590 --> 00:26:42,279
gonna talk a little bit I've about

00:26:40,539 --> 00:26:44,799
mutations there's a lot more on

00:26:42,279 --> 00:26:47,320
mutations in our design tutorial which I

00:26:44,799 --> 00:26:48,880
encourage you all to read and I didn't

00:26:47,320 --> 00:26:51,519
really have time to get into that here

00:26:48,880 --> 00:26:54,549
but I do want to talk about one small

00:26:51,519 --> 00:26:57,220
aspect of it so here we have a mutation

00:26:54,549 --> 00:26:59,710
that updates a collection and the return

00:26:57,220 --> 00:27:02,019
type right now is is a collection but

00:26:59,710 --> 00:27:03,879
this doesn't give us much flexibility we

00:27:02,019 --> 00:27:08,470
can either return a collection or null

00:27:03,879 --> 00:27:10,330
but we can't return anything else so one

00:27:08,470 --> 00:27:12,279
solution is to create a payload type

00:27:10,330 --> 00:27:16,059
specific to each mutation which we will

00:27:12,279 --> 00:27:18,309
use as a return type right now this is

00:27:16,059 --> 00:27:19,809
just a wrapper for the collection itself

00:27:18,309 --> 00:27:21,309
as you can see there it just contains

00:27:19,809 --> 00:27:23,049
the collection but we'll see how this

00:27:21,309 --> 00:27:25,299
becomes useful so notice the return

00:27:23,049 --> 00:27:27,759
types null ability we can actually make

00:27:25,299 --> 00:27:29,440
it non null which means it can never be

00:27:27,759 --> 00:27:30,940
no that we can guarantee that we will

00:27:29,440 --> 00:27:33,519
always return the payload and this has

00:27:30,940 --> 00:27:37,120
some benefits so pattern number two is

00:27:33,519 --> 00:27:39,909
to use a payload return type so back to

00:27:37,120 --> 00:27:41,710
the payload type mutations can succeed

00:27:39,909 --> 00:27:44,019
or fail and you want to provide feedback

00:27:41,710 --> 00:27:47,379
to your API consumers on those failures

00:27:44,019 --> 00:27:49,629
no graph ul has support for query level

00:27:47,379 --> 00:27:51,399
errors built-in but these are not ideal

00:27:49,629 --> 00:27:53,409
for business level mutation failures are

00:27:51,399 --> 00:27:55,929
more about like validation against the

00:27:53,409 --> 00:27:57,639
schema whether your your query is

00:27:55,929 --> 00:28:00,669
malformed or not these are top level

00:27:57,639 --> 00:28:02,769
errors but a job finder and all our

00:28:00,669 --> 00:28:05,409
payload types we include a user errors

00:28:02,769 --> 00:28:07,120
field which is really feedback from the

00:28:05,409 --> 00:28:09,340
mutation so if there's something went

00:28:07,120 --> 00:28:11,139
wrong the query was well-formed but it

00:28:09,340 --> 00:28:13,269
just had to do with logic on the

00:28:11,139 --> 00:28:15,789
business side like who didn't provide a

00:28:13,269 --> 00:28:17,620
correct a when you're trying to update B

00:28:15,789 --> 00:28:20,500
you can actually be informed of that

00:28:17,620 --> 00:28:23,409
with the user errors so a successful

00:28:20,500 --> 00:28:24,909
mutation would return an empty list of

00:28:23,409 --> 00:28:26,429
user errors and it would return the

00:28:24,909 --> 00:28:28,299
collection object that was updated

00:28:26,429 --> 00:28:30,429
unsuccessful mutation would return a

00:28:28,299 --> 00:28:32,379
null for the collection object and you

00:28:30,429 --> 00:28:32,980
notice there that in the update payload

00:28:32,379 --> 00:28:35,320
collection

00:28:32,980 --> 00:28:38,530
doesn't have a exclamation decided so

00:28:35,320 --> 00:28:41,530
it's knowable and an empty user errors

00:28:38,530 --> 00:28:43,120
list we're sorry if it came back as null

00:28:41,530 --> 00:28:44,860
you would have a list of user errors

00:28:43,120 --> 00:28:46,169
which would explain what the what the

00:28:44,860 --> 00:28:50,260
issue was

00:28:46,169 --> 00:28:51,840
so patterned number 13 is that you can

00:28:50,260 --> 00:28:55,120
make mistakes and recover from them

00:28:51,840 --> 00:28:57,400
mutations should provide user or

00:28:55,120 --> 00:28:58,690
business level errors verify a user

00:28:57,400 --> 00:29:00,730
errors field or whatever you want to

00:28:58,690 --> 00:29:02,230
call it on the mutation payload and

00:29:00,730 --> 00:29:03,700
having a payload gives you the

00:29:02,230 --> 00:29:05,049
flexibility because you guarantee the

00:29:03,700 --> 00:29:07,480
payload is there and then the actual

00:29:05,049 --> 00:29:09,070
return type could be null but the user

00:29:07,480 --> 00:29:15,429
errors field could it could contain

00:29:09,070 --> 00:29:17,169
information and pattern number 14 there

00:29:15,429 --> 00:29:19,780
is kind of a corollary to that which is

00:29:17,169 --> 00:29:21,730
most payloads for a mutation should be

00:29:19,780 --> 00:29:24,160
payload fields like the fields that are

00:29:21,730 --> 00:29:26,169
inside the return type they should be

00:29:24,160 --> 00:29:30,340
knowable which allows us to return null

00:29:26,169 --> 00:29:33,309
and something goes wrong so I've got

00:29:30,340 --> 00:29:34,480
like 40 seconds less left which I'm

00:29:33,309 --> 00:29:36,280
really impressed with because when I

00:29:34,480 --> 00:29:40,540
tried this at home I went 10 minutes

00:29:36,280 --> 00:29:42,340
over so these are all the guidelines I

00:29:40,540 --> 00:29:44,770
could realistically cover in a short

00:29:42,340 --> 00:29:47,080
talk like this I wish I could stand up

00:29:44,770 --> 00:29:49,960
here and talk for an hour actually no I

00:29:47,080 --> 00:29:52,929
don't but but I have but I could I could

00:29:49,960 --> 00:29:54,850
do it so here's the link again to the

00:29:52,929 --> 00:29:56,950
full design tutorial that this talk was

00:29:54,850 --> 00:29:59,620
based on there is a lot more in this

00:29:56,950 --> 00:30:02,280
design store a lot of sort of technical

00:29:59,620 --> 00:30:05,230
nuances about mutations and and

00:30:02,280 --> 00:30:07,270
principles and approaches and I really

00:30:05,230 --> 00:30:09,190
urge you if you're interested in api's

00:30:07,270 --> 00:30:11,470
to take a look at what we put together

00:30:09,190 --> 00:30:13,059
we do it's not necessarily all correct

00:30:11,470 --> 00:30:15,130
and other people might have come up with

00:30:13,059 --> 00:30:16,840
better solutions but these are things

00:30:15,130 --> 00:30:18,610
that have really fallen out from you

00:30:16,840 --> 00:30:20,620
know three years of use almost three

00:30:18,610 --> 00:30:22,240
years of use and we're always interested

00:30:20,620 --> 00:30:24,580
in the feedback as well so that's the

00:30:22,240 --> 00:30:26,110
link over there and I hope these

00:30:24,580 --> 00:30:27,460
guidelines give you a head start in

00:30:26,110 --> 00:30:28,370
designing your own graphical schema so

00:30:27,460 --> 00:30:29,370
thanks for listening

00:30:28,370 --> 00:30:31,640
[Applause]

00:30:29,370 --> 00:30:34,249
[Music]

00:30:31,640 --> 00:30:34,249

YouTube URL: https://www.youtube.com/watch?v=mqaz6vmAGis


