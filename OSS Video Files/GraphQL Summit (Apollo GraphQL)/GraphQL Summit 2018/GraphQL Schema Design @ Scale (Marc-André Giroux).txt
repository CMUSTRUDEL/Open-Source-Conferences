Title: GraphQL Schema Design @ Scale (Marc-André Giroux)
Publication date: 2018-12-05
Playlist: GraphQL Summit 2018
Description: 
	Talk from GraphQL Summit 2018 - Nov 7, 2018

Marc-André Giroux, Platform Interface Engineer at GitHub, is trying to help build better APIs. 
GraphQL's type system is what makes it so powerful. However, as our schemas grow, they sometimes become hard to evolve, hard to reason about, and hard to use for our integrators. Over the past 3 years, he's observed the good, the bad, and ugly in GraphQL schemas. These are his findings.

Resources:
Checkout the Apollo docs - https://www.apollographql.com/docs/
Explore the schema docs - https://www.apollographql.com/docs/apollo-server/schema/schema/
Learn more about the Summit - https://summit.graphql.com
Captions: 
	00:00:04,250 --> 00:00:09,110
hey everyone it's super cool to be here

00:00:06,920 --> 00:00:14,000
today today we're going to talk about

00:00:09,110 --> 00:00:16,340
schema design at scale here because

00:00:14,000 --> 00:00:18,740
we're gonna talk a bit more than just

00:00:16,340 --> 00:00:21,080
schema design tips but how it works

00:00:18,740 --> 00:00:23,330
within kind of a large organization and

00:00:21,080 --> 00:00:28,250
everything we've built

00:00:23,330 --> 00:00:31,490
I get hub around that so I'm mark

00:00:28,250 --> 00:00:32,809
I usually name is however you want to

00:00:31,490 --> 00:00:34,550
pronounce that it's my family name

00:00:32,809 --> 00:00:37,820
backwards

00:00:34,550 --> 00:00:39,739
I am from Montreal Canada it's my third

00:00:37,820 --> 00:00:42,019
summit this year so I'm pretty happy to

00:00:39,739 --> 00:00:45,140
see the evolution from the first summit

00:00:42,019 --> 00:00:47,390
way less people everybody trying out

00:00:45,140 --> 00:00:50,929
this new strange technology to today

00:00:47,390 --> 00:00:52,969
seeing like huge companies awesome

00:00:50,929 --> 00:00:58,670
projects popping around like every week

00:00:52,969 --> 00:01:03,769
almost and yeah work at github no jokes

00:00:58,670 --> 00:01:07,390
about Microsoft today so graph kill at

00:01:03,769 --> 00:01:10,460
github kinda has a pretty big history

00:01:07,390 --> 00:01:12,530
given how new graph Killy is we've been

00:01:10,460 --> 00:01:15,440
using it for a long time it started as a

00:01:12,530 --> 00:01:18,860
come at a small experiment and now

00:01:15,440 --> 00:01:20,360
pretty much all our new features get

00:01:18,860 --> 00:01:25,040
released with a graphical API Isis

00:01:20,360 --> 00:01:27,160
schema is grown very large we have 200

00:01:25,040 --> 00:01:30,560
plus engineers working on a single like

00:01:27,160 --> 00:01:32,830
monolithic schema our product teams are

00:01:30,560 --> 00:01:36,110
releasing new products pretty quickly

00:01:32,830 --> 00:01:38,450
and we manage a public version of our

00:01:36,110 --> 00:01:42,710
API and an internal one as well as the

00:01:38,450 --> 00:01:45,530
enterprise versions of those and this

00:01:42,710 --> 00:01:48,110
comes with a bunch of challenges the

00:01:45,530 --> 00:01:50,150
first one being we're already pretty

00:01:48,110 --> 00:01:53,660
proud of like our REST API we take good

00:01:50,150 --> 00:01:56,420
care of like maintaining designing are

00:01:53,660 --> 00:01:58,820
very well crafted easy to use API and we

00:01:56,420 --> 00:02:01,310
really wanted to stay the same

00:01:58,820 --> 00:02:03,140
principles when it comes to graph 0 we

00:02:01,310 --> 00:02:04,970
also have a pretty small API team so

00:02:03,140 --> 00:02:07,909
there's a pretty big challenge compared

00:02:04,970 --> 00:02:10,069
to the big teams and a lot of different

00:02:07,909 --> 00:02:13,250
product teams that want to ship

00:02:10,069 --> 00:02:15,500
graphical API that github and finally

00:02:13,250 --> 00:02:17,120
one of the hardest things is when it

00:02:15,500 --> 00:02:18,160
comes to schema design graphical is

00:02:17,120 --> 00:02:20,810
still new

00:02:18,160 --> 00:02:23,570
every week we're seeing new use cases we

00:02:20,810 --> 00:02:26,720
didn't think of the API kima get up we

00:02:23,570 --> 00:02:29,840
take a look at a lot of PRS that the

00:02:26,720 --> 00:02:32,330
product teams go through with and it's

00:02:29,840 --> 00:02:35,870
not always clear-cut what the design

00:02:32,330 --> 00:02:38,450
rule should be for each of them and

00:02:35,870 --> 00:02:41,210
before we kind of dive deeper into what

00:02:38,450 --> 00:02:44,120
schema design looks like kind of want to

00:02:41,210 --> 00:02:46,010
go back a little and think in the first

00:02:44,120 --> 00:02:48,740
place why we chose graph QL right and

00:02:46,010 --> 00:02:51,170
you've probably heard this almost year

00:02:48,740 --> 00:02:55,310
after year now and many talks repeat

00:02:51,170 --> 00:02:57,800
that but for us graph QL was first of

00:02:55,310 --> 00:03:00,830
all a really great tape type system that

00:02:57,800 --> 00:03:03,830
allowed us to express possibilities to

00:03:00,830 --> 00:03:05,800
get out of AP is combined with the

00:03:03,830 --> 00:03:08,000
declarative Ness of the query language

00:03:05,800 --> 00:03:10,640
client selecting exactly what they need

00:03:08,000 --> 00:03:13,730
and we've talked about this a lot

00:03:10,640 --> 00:03:16,580
already but why is it so important to us

00:03:13,730 --> 00:03:20,090
to design not a perfect schema but

00:03:16,580 --> 00:03:22,160
really nice to use schema to me it kind

00:03:20,090 --> 00:03:24,470
of breaks down into two things the first

00:03:22,160 --> 00:03:27,230
one is we want to build api's that will

00:03:24,470 --> 00:03:29,989
stand the test of time so we want to

00:03:27,230 --> 00:03:33,350
build an API that allows us to be

00:03:29,989 --> 00:03:36,610
evolvable and kind of minimize the risks

00:03:33,350 --> 00:03:39,980
of just making a terrible mistake and

00:03:36,610 --> 00:03:42,980
with a graphical type system it allows

00:03:39,980 --> 00:03:45,050
us to kind of build our types in a way

00:03:42,980 --> 00:03:46,070
that keeps the future open for us

00:03:45,050 --> 00:03:49,880
because we know there's a lot more

00:03:46,070 --> 00:03:52,700
coming the other thing was we wanted to

00:03:49,880 --> 00:03:55,760
just build ApS that are easy to use and

00:03:52,700 --> 00:03:57,800
it sounds easy but it actually isn't we

00:03:55,760 --> 00:03:59,780
need to provide a way with graphical

00:03:57,800 --> 00:04:01,940
type system to express these

00:03:59,780 --> 00:04:03,860
possibilities but in a way clients

00:04:01,940 --> 00:04:07,580
really understand quickly what they can

00:04:03,860 --> 00:04:11,390
do with github doing so graph kills key

00:04:07,580 --> 00:04:12,560
my design before we get into that too

00:04:11,390 --> 00:04:15,350
much let's start with a few

00:04:12,560 --> 00:04:17,229
misconceptions we have about graphical

00:04:15,350 --> 00:04:21,320
type system and the way we design it

00:04:17,229 --> 00:04:24,530
first of all when working a sufficiently

00:04:21,320 --> 00:04:26,900
large schema or application graph you'll

00:04:24,530 --> 00:04:30,110
rarely is just a layer on top of the

00:04:26,900 --> 00:04:32,150
database whatever we hear it's not

00:04:30,110 --> 00:04:36,770
really just sequel over J

00:04:32,150 --> 00:04:37,880
it's a bit more than this your graphical

00:04:36,770 --> 00:04:40,580
schema doesn't have to match your

00:04:37,880 --> 00:04:43,190
existing rest api resources I know it's

00:04:40,580 --> 00:04:44,630
tempting sometimes to there's great

00:04:43,190 --> 00:04:48,229
tools coming out that allow us to

00:04:44,630 --> 00:04:51,560
convert existing rest resources back

00:04:48,229 --> 00:04:53,169
them up your grass QL but really we can

00:04:51,560 --> 00:04:56,060
think a little further than that and

00:04:53,169 --> 00:04:59,180
finally it also doesn't have to map our

00:04:56,060 --> 00:05:01,970
UI there's good reasons why you maybe

00:04:59,180 --> 00:05:05,570
would but when you have an API as large

00:05:01,970 --> 00:05:09,190
as github we can't just focus on one use

00:05:05,570 --> 00:05:11,870
case or just one layer like the UI

00:05:09,190 --> 00:05:16,190
instead what I think the real power of

00:05:11,870 --> 00:05:18,710
graphical is is to model an interface to

00:05:16,190 --> 00:05:21,380
our core domain so what github is all

00:05:18,710 --> 00:05:23,690
about so what can I do what github what

00:05:21,380 --> 00:05:26,030
can get how provide me with what are the

00:05:23,690 --> 00:05:27,470
use case so this is really what

00:05:26,030 --> 00:05:30,320
graphical lets us do with the type

00:05:27,470 --> 00:05:32,900
system it's easy to convert a debase

00:05:30,320 --> 00:05:35,630
schema to a graphical type system but

00:05:32,900 --> 00:05:38,479
it's not necessarily what we want for a

00:05:35,630 --> 00:05:40,430
lot of us here usually when we start a

00:05:38,479 --> 00:05:43,130
graphical API we start from scratch it's

00:05:40,430 --> 00:05:44,840
pretty new technology and I see that as

00:05:43,130 --> 00:05:48,050
a pretty good opportunity to kind of

00:05:44,840 --> 00:05:51,470
take the time and design the front door

00:05:48,050 --> 00:05:53,090
to our domains basically so we can let

00:05:51,470 --> 00:05:55,940
go of that coupling to that database

00:05:53,090 --> 00:05:59,360
schema or to our rest resources or our

00:05:55,940 --> 00:06:01,400
UI and really start thinking about what

00:05:59,360 --> 00:06:05,720
our API use cases and behaviors are all

00:06:01,400 --> 00:06:08,479
about so I see two keys to a really

00:06:05,720 --> 00:06:10,699
well-designed graphical API here first

00:06:08,479 --> 00:06:12,199
of all we have to be experts at our

00:06:10,699 --> 00:06:15,710
domain if you work in an e-commerce

00:06:12,199 --> 00:06:17,660
company we must know ecommerce things we

00:06:15,710 --> 00:06:22,160
work at a social company we need to know

00:06:17,660 --> 00:06:24,710
about social social entities what our

00:06:22,160 --> 00:06:26,630
service is all about and second of all

00:06:24,710 --> 00:06:28,370
we need to be good at graft well we need

00:06:26,630 --> 00:06:30,680
to understand graphical primitives and

00:06:28,370 --> 00:06:33,590
how we can build a schema to represent

00:06:30,680 --> 00:06:36,580
that domain there's a little problem

00:06:33,590 --> 00:06:40,070
with that and kind of looks like this

00:06:36,580 --> 00:06:41,840
usually our graphical experts or people

00:06:40,070 --> 00:06:43,830
who really care about graph QL are not

00:06:41,840 --> 00:06:45,930
necessarily the same people as kit

00:06:43,830 --> 00:06:48,690
that care about your business domain or

00:06:45,930 --> 00:06:50,670
you needs if you work at a small

00:06:48,690 --> 00:06:54,540
business it might actually be one person

00:06:50,670 --> 00:06:56,790
and that's great but I github I don't

00:06:54,540 --> 00:06:58,860
have the knowledge of every single

00:06:56,790 --> 00:07:02,370
entity that exists in a get up world I'm

00:06:58,860 --> 00:07:06,090
not an expert the source control

00:07:02,370 --> 00:07:10,350
entities in general there's people who

00:07:06,090 --> 00:07:11,910
work on these daily and really they're

00:07:10,350 --> 00:07:15,000
not astray the same as people who know

00:07:11,910 --> 00:07:17,580
graphical well so I get up we recently

00:07:15,000 --> 00:07:19,800
started working with API first so if

00:07:17,580 --> 00:07:23,190
we're releasing a new feature it

00:07:19,800 --> 00:07:26,280
probably comes with its API also and the

00:07:23,190 --> 00:07:28,680
way we work is that that part of the

00:07:26,280 --> 00:07:32,010
schema that API is built by the same

00:07:28,680 --> 00:07:35,850
team that is building the feature it may

00:07:32,010 --> 00:07:38,280
sound obvious but really our API team

00:07:35,850 --> 00:07:40,380
here is there to help the product teams

00:07:38,280 --> 00:07:43,770
they're really the dominant domain

00:07:40,380 --> 00:07:45,510
experts here to build a great schema so

00:07:43,770 --> 00:07:47,970
as you see it's not really the same team

00:07:45,510 --> 00:07:49,830
that does both the graphical specific

00:07:47,970 --> 00:07:52,020
things and building the schema we're

00:07:49,830 --> 00:07:54,480
really helping the experts here which is

00:07:52,020 --> 00:07:59,030
why I think we're able to build a schema

00:07:54,480 --> 00:08:01,650
that makes sense both a domain way and

00:07:59,030 --> 00:08:05,340
using the right graph fuel primitives

00:08:01,650 --> 00:08:09,330
for it so let's go into actual design

00:08:05,340 --> 00:08:12,240
tips now as I was building this dag this

00:08:09,330 --> 00:08:13,080
talk I was I started compiling like tips

00:08:12,240 --> 00:08:14,870
we use at github

00:08:13,080 --> 00:08:16,860
we have style guides we have

00:08:14,870 --> 00:08:19,290
documentation on how to build a great

00:08:16,860 --> 00:08:21,570
schema but I realized what I wanted to

00:08:19,290 --> 00:08:24,330
talk about today is not really these

00:08:21,570 --> 00:08:26,460
concrete tips but more the guiding

00:08:24,330 --> 00:08:30,300
principles we use when coming up with

00:08:26,460 --> 00:08:32,540
this these tips we see every week we see

00:08:30,300 --> 00:08:35,130
a new suitcase we didn't think about

00:08:32,540 --> 00:08:38,040
something we need to really scratch our

00:08:35,130 --> 00:08:41,460
head with and wonder how we can design

00:08:38,040 --> 00:08:44,460
this and we use usually the same set of

00:08:41,460 --> 00:08:48,120
guiding principles to arrive with a new

00:08:44,460 --> 00:08:51,360
rule and I'll talk about some cool tools

00:08:48,120 --> 00:08:54,210
we use also around this the first one is

00:08:51,360 --> 00:08:56,670
designed for behavior or use cases over

00:08:54,210 --> 00:08:59,520
data and we talked about this a bit

00:08:56,670 --> 00:09:01,680
with the domain versus just the database

00:08:59,520 --> 00:09:05,790
came earlier but this is really about

00:09:01,680 --> 00:09:09,510
designing a schema that talks to your

00:09:05,790 --> 00:09:12,420
users really lets us think in terms of

00:09:09,510 --> 00:09:15,150
use cases instead of just what data it

00:09:12,420 --> 00:09:18,240
represents and failure to do so I've

00:09:15,150 --> 00:09:20,910
been calling anemic graph QL and I

00:09:18,240 --> 00:09:23,340
shamelessly stole this term from the

00:09:20,910 --> 00:09:27,000
anemic domain model modal and a pattern

00:09:23,340 --> 00:09:29,220
from margin Fowler in 2003 so I thought

00:09:27,000 --> 00:09:31,740
it was really cool thinking about this

00:09:29,220 --> 00:09:35,250
graph killed best practice but turns out

00:09:31,740 --> 00:09:38,940
15 years ago these same concerns were

00:09:35,250 --> 00:09:41,670
being solved other levels and here's an

00:09:38,940 --> 00:09:45,810
example of it here's quite a simple

00:09:41,670 --> 00:09:48,710
update issue mutation that takes an

00:09:45,810 --> 00:09:52,020
issue input and updates an issue with it

00:09:48,710 --> 00:09:54,960
there's a few problems here if you

00:09:52,020 --> 00:09:57,120
notice everything is inaudible here so

00:09:54,960 --> 00:09:59,910
the client looks at this and selects

00:09:57,120 --> 00:10:04,650
kind of the right input values to fill

00:09:59,910 --> 00:10:06,960
in to update what it wants but what if I

00:10:04,650 --> 00:10:10,920
let's say want to add a designee to an

00:10:06,960 --> 00:10:13,620
issue well by looking at this I need to

00:10:10,920 --> 00:10:15,660
kind of think about which values I

00:10:13,620 --> 00:10:18,150
should be filling in to add an assignee

00:10:15,660 --> 00:10:20,370
it's not really clear to me how to do

00:10:18,150 --> 00:10:23,220
that and if on the server side I

00:10:20,370 --> 00:10:26,330
eventually add another step let's say

00:10:23,220 --> 00:10:29,280
another data field that should be

00:10:26,330 --> 00:10:31,170
entered when adding an assignee every

00:10:29,280 --> 00:10:33,240
time that was just relying on adding an

00:10:31,170 --> 00:10:37,620
ID in that list of assignee IDs is now

00:10:33,240 --> 00:10:39,540
broken so we turn on that state where

00:10:37,620 --> 00:10:41,580
the client has to manage state

00:10:39,540 --> 00:10:44,010
everything on a client and needs to

00:10:41,580 --> 00:10:46,280
figure out which data attributes to

00:10:44,010 --> 00:10:48,540
change to provide a certain behavior and

00:10:46,280 --> 00:10:52,020
what I'm proposing here is to kind of

00:10:48,540 --> 00:10:55,950
reverse that and have the schema clearly

00:10:52,020 --> 00:10:59,400
tell us what's possible and how how to

00:10:55,950 --> 00:11:02,520
do it here you'll notice our inputs are

00:10:59,400 --> 00:11:05,280
like much more strongly typed in every

00:11:02,520 --> 00:11:06,579
of these inputs we need to fill in a

00:11:05,280 --> 00:11:08,499
label ID in issue

00:11:06,579 --> 00:11:10,959
and it's a quite a simple example but

00:11:08,499 --> 00:11:13,059
with more fields our payload start to be

00:11:10,959 --> 00:11:16,179
really more descriptive and let the

00:11:13,059 --> 00:11:20,379
client know a lot more what's you're

00:11:16,179 --> 00:11:24,100
able to do same thing were we just read

00:11:20,379 --> 00:11:25,600
queries here's a very simple example of

00:11:24,100 --> 00:11:28,179
a pull request that's not actually how

00:11:25,600 --> 00:11:32,589
it's designed he it has a title

00:11:28,179 --> 00:11:34,119
description a CI status and reviews so

00:11:32,589 --> 00:11:36,100
what if we had a use case of a client I

00:11:34,119 --> 00:11:39,160
wanted to know the pull request is okay

00:11:36,100 --> 00:11:41,259
to be merged the client might look at

00:11:39,160 --> 00:11:44,279
the schema and say I have a CI status if

00:11:41,259 --> 00:11:47,290
it's green and if all the reviews are

00:11:44,279 --> 00:11:50,559
approvals and nobody what requires

00:11:47,290 --> 00:11:52,360
change is probably mirja below the

00:11:50,559 --> 00:11:55,149
problem here is a bit like the mutations

00:11:52,360 --> 00:11:57,220
if I add a new rule let's say github

00:11:55,149 --> 00:12:00,129
adds that the checks feature and now

00:11:57,220 --> 00:12:02,619
checks also need to be green and not

00:12:00,129 --> 00:12:05,439
only the CI status the client logic now

00:12:02,619 --> 00:12:07,209
needs to change and adapt to the data

00:12:05,439 --> 00:12:10,089
that was provided by the type for

00:12:07,209 --> 00:12:11,439
request so I would encourage you to not

00:12:10,089 --> 00:12:15,249
only provide the data that's always

00:12:11,439 --> 00:12:17,769
going to be useful but to provide helper

00:12:15,249 --> 00:12:21,040
fields or really behavior driven fields

00:12:17,769 --> 00:12:23,470
that answer a client use case so is

00:12:21,040 --> 00:12:26,319
merge about here is really what a client

00:12:23,470 --> 00:12:28,509
wanted to know and the server knows how

00:12:26,319 --> 00:12:31,149
to fulfill that field if we change the

00:12:28,509 --> 00:12:36,009
rules in the backend here that is mirja

00:12:31,149 --> 00:12:39,369
both field will remain true always if we

00:12:36,009 --> 00:12:42,279
go back to the mutation example here it

00:12:39,369 --> 00:12:44,860
looks great it's easy to see what we can

00:12:42,279 --> 00:12:48,339
do but we quickly hit some use cases

00:12:44,860 --> 00:12:50,410
where this really wasn't enough a good

00:12:48,339 --> 00:12:54,699
example of that is with a client that

00:12:50,410 --> 00:12:57,939
wanted to update labels remove another

00:12:54,699 --> 00:13:01,239
label add an assignee and finally save

00:12:57,939 --> 00:13:03,610
and update all of this with these fine

00:13:01,239 --> 00:13:06,100
grained mutation that we define here we

00:13:03,610 --> 00:13:08,829
would need to send multiple mutation

00:13:06,100 --> 00:13:10,779
fields to the server to execute the

00:13:08,829 --> 00:13:12,970
problem here is that we have no

00:13:10,779 --> 00:13:15,129
guarantees that maybe one of them will

00:13:12,970 --> 00:13:17,439
fail and the client needs to handle that

00:13:15,129 --> 00:13:19,379
weird state where maybe I've

00:13:17,439 --> 00:13:21,329
successfully added added an assignee

00:13:19,379 --> 00:13:23,729
but one of the label removals didn't

00:13:21,329 --> 00:13:25,769
work it's really hard to track so we

00:13:23,729 --> 00:13:27,599
were really wondering what the right

00:13:25,769 --> 00:13:31,079
design is here is because we didn't want

00:13:27,599 --> 00:13:33,689
that big fat update issue that had all

00:13:31,079 --> 00:13:36,869
the problems we talked about but this

00:13:33,689 --> 00:13:38,459
approach didn't left us like with big

00:13:36,869 --> 00:13:40,889
problems when it comes to batch

00:13:38,459 --> 00:13:44,249
mutations or like kind of a need in a

00:13:40,889 --> 00:13:46,529
transaction here and we explored some

00:13:44,249 --> 00:13:50,579
other options for example maybe if we

00:13:46,529 --> 00:13:52,499
had a union input we could send an list

00:13:50,579 --> 00:13:56,179
of operations that the server could

00:13:52,499 --> 00:13:59,309
execute while that would have worked

00:13:56,179 --> 00:14:01,229
this still wasn't really the behavior

00:13:59,309 --> 00:14:04,739
driven we wanted we wanted a schema

00:14:01,229 --> 00:14:06,769
that's really easy to use so this was

00:14:04,739 --> 00:14:09,779
really a problem between atomicity

00:14:06,769 --> 00:14:12,479
sending everything at once and it either

00:14:09,779 --> 00:14:16,499
works or not and granularity and these

00:14:12,479 --> 00:14:18,169
really use case driven fields after

00:14:16,499 --> 00:14:22,489
looking for a number of these solutions

00:14:18,169 --> 00:14:25,109
we realized what if we just did both

00:14:22,489 --> 00:14:28,079
some finer grained mutations for most

00:14:25,109 --> 00:14:31,019
clients and if there is a use case where

00:14:28,079 --> 00:14:34,529
it's actually valid to send everything

00:14:31,019 --> 00:14:37,739
at once have that big fat mutation then

00:14:34,529 --> 00:14:39,269
why not and to really understand I've

00:14:37,739 --> 00:14:41,369
been really thinking that this is the

00:14:39,269 --> 00:14:43,589
right approach for a while now and to

00:14:41,369 --> 00:14:46,769
really explain what I mean I want to go

00:14:43,589 --> 00:14:50,009
back a few years ago kind of before grad

00:14:46,769 --> 00:14:53,549
school was released publicly and maybe

00:14:50,009 --> 00:14:55,769
even thought up in the first place a lot

00:14:53,549 --> 00:14:59,009
of people back then in 2000 maybe 10

00:14:55,769 --> 00:15:00,649
2012 had the same problem had multiple

00:14:59,009 --> 00:15:04,019
different clients with different needs

00:15:00,649 --> 00:15:06,989
maybe of a mobile app desktop app a web

00:15:04,019 --> 00:15:10,169
app a PlayStation app many clients

00:15:06,989 --> 00:15:13,769
different use cases sometimes limited by

00:15:10,169 --> 00:15:15,889
the resources of the device so really

00:15:13,769 --> 00:15:18,259
different data needs for clients and

00:15:15,889 --> 00:15:22,220
graph kill really wasn't the only thing

00:15:18,259 --> 00:15:24,209
back then that was invented for that I

00:15:22,220 --> 00:15:26,099
know if you're friendlier with this

00:15:24,209 --> 00:15:28,439
pattern here but our friends at

00:15:26,099 --> 00:15:30,749
SoundCloud eventually they had a bunch

00:15:28,439 --> 00:15:31,750
of back-end services they also had that

00:15:30,749 --> 00:15:34,090
problem where the

00:15:31,750 --> 00:15:36,460
mobile data requirement maybe were

00:15:34,090 --> 00:15:37,750
different from the web garments this

00:15:36,460 --> 00:15:40,720
gave birth to a pattern called the

00:15:37,750 --> 00:15:42,580
backend for front-end pattern where you

00:15:40,720 --> 00:15:45,940
would create one of these back-end for

00:15:42,580 --> 00:15:49,060
front-end instances per device for

00:15:45,940 --> 00:15:51,640
example a mobile BFF here would be able

00:15:49,060 --> 00:15:54,310
to aggregate the data a mobile client

00:15:51,640 --> 00:15:56,530
would need and web BFF here would

00:15:54,310 --> 00:16:00,850
aggregate the data a web client would

00:15:56,530 --> 00:16:03,190
mean same kind of years in 2012 our

00:16:00,850 --> 00:16:06,220
friends and Netflix released a blog post

00:16:03,190 --> 00:16:08,560
on kind of their new strategy for api's

00:16:06,220 --> 00:16:09,820
were instead of having a

00:16:08,560 --> 00:16:13,240
one-size-fits-all

00:16:09,820 --> 00:16:15,160
huge REST API that I think they have

00:16:13,240 --> 00:16:16,540
like they had like 800 plus different

00:16:15,160 --> 00:16:20,950
clients Playstations

00:16:16,540 --> 00:16:22,360
Xbox mobile phones etc what they did

00:16:20,950 --> 00:16:24,850
instead of that back in forefront

00:16:22,360 --> 00:16:28,060
approach is having kind of server-side

00:16:24,850 --> 00:16:30,190
adapters that would execute pre and post

00:16:28,060 --> 00:16:34,480
filters on payloads and adapt it to the

00:16:30,190 --> 00:16:36,190
right device and if we go back to 2012

00:16:34,480 --> 00:16:38,500
again I wonder what Facebook was

00:16:36,190 --> 00:16:41,950
thinking about it was thinking about

00:16:38,500 --> 00:16:44,110
graph QL and really what it makes me

00:16:41,950 --> 00:16:46,620
think of is graphical is kind of a

00:16:44,110 --> 00:16:50,040
solution to the same set of problems

00:16:46,620 --> 00:16:52,300
it's a very different implementation of

00:16:50,040 --> 00:16:54,310
solution but it really makes me think

00:16:52,300 --> 00:16:55,120
that graph QL is kind of our back-end

00:16:54,310 --> 00:16:58,800
for front-end

00:16:55,120 --> 00:17:02,339
or our client specific adapter here

00:16:58,800 --> 00:17:05,170
except the solutions very different

00:17:02,339 --> 00:17:09,430
graphical being so declarative in client

00:17:05,170 --> 00:17:11,410
centric it has no select star and this

00:17:09,430 --> 00:17:14,560
is one of my favorite properties of

00:17:11,410 --> 00:17:16,510
graph tool a client always needs to

00:17:14,560 --> 00:17:18,550
define exactly what it needs and there's

00:17:16,510 --> 00:17:23,290
no give me everything else for example

00:17:18,550 --> 00:17:26,890
and what it gives us is kind of every

00:17:23,290 --> 00:17:28,840
client has a different mini version of

00:17:26,890 --> 00:17:31,690
the schema on the client side right like

00:17:28,840 --> 00:17:35,080
every time is free to use whatever

00:17:31,690 --> 00:17:39,780
subset of the schema they want and that

00:17:35,080 --> 00:17:43,710
helps a lot drive these decisions sorry

00:17:39,780 --> 00:17:45,550
so really we shouldn't be afraid to add

00:17:43,710 --> 00:17:48,490
another use case

00:17:45,550 --> 00:17:50,860
each client is selecting a subset of

00:17:48,490 --> 00:17:54,100
this scheme already it cares about so if

00:17:50,860 --> 00:17:56,020
we are in need of that big update issue

00:17:54,100 --> 00:17:58,630
mutation this doesn't actually affect

00:17:56,020 --> 00:18:00,060
our other clients so we should stay away

00:17:58,630 --> 00:18:02,200
from trying to build that

00:18:00,060 --> 00:18:05,470
one-size-fits-all rest if you had at

00:18:02,200 --> 00:18:07,090
Netflix was struggling with I also think

00:18:05,470 --> 00:18:09,220
we should be staying away from being

00:18:07,090 --> 00:18:11,830
like building it as a graph QL API and

00:18:09,220 --> 00:18:13,960
trying to build an API that has fields

00:18:11,830 --> 00:18:16,120
that try to be too smart try to handle

00:18:13,960 --> 00:18:19,540
too many different variations of our

00:18:16,120 --> 00:18:22,540
same use case so we should really

00:18:19,540 --> 00:18:26,080
embrace these and build around that

00:18:22,540 --> 00:18:27,130
build our schema in a way that if my

00:18:26,080 --> 00:18:29,380
mobile client means a different

00:18:27,130 --> 00:18:33,520
variation of the field shouldn't be

00:18:29,380 --> 00:18:35,650
afraid of providing it a different

00:18:33,520 --> 00:18:38,410
version of that rule is we always prefer

00:18:35,650 --> 00:18:41,890
highly optimized fields over generic or

00:18:38,410 --> 00:18:43,990
smart fields here's a really really

00:18:41,890 --> 00:18:47,200
simple example that I've actually seen

00:18:43,990 --> 00:18:50,860
while reviewing PRS sometimes we have a

00:18:47,200 --> 00:18:53,110
user field to fetch a user and it used

00:18:50,860 --> 00:18:55,720
to only have an ID but some clients

00:18:53,110 --> 00:18:59,080
actually wanted to fetch a user by login

00:18:55,720 --> 00:19:02,010
instead so our field became here a field

00:18:59,080 --> 00:19:04,480
user that can take either an ID or login

00:19:02,010 --> 00:19:06,940
and maybe the first site this looks

00:19:04,480 --> 00:19:08,590
pretty useful but we have the same

00:19:06,940 --> 00:19:11,200
problems we had with mutations earlier

00:19:08,590 --> 00:19:14,110
our two arguments here are not nullable

00:19:11,200 --> 00:19:17,200
what happens if I pass none of them what

00:19:14,110 --> 00:19:18,880
if I pass both this is all things that

00:19:17,200 --> 00:19:21,040
our schema is not telling us at a first

00:19:18,880 --> 00:19:24,570
sight and I will have to validate at

00:19:21,040 --> 00:19:28,180
runtime and we've been really trying to

00:19:24,570 --> 00:19:31,210
design use that powerful type system to

00:19:28,180 --> 00:19:33,780
the best we can and try to type things

00:19:31,210 --> 00:19:37,180
correctly so here it's not really great

00:19:33,780 --> 00:19:39,730
instead this might look really simple

00:19:37,180 --> 00:19:41,710
because a simple example but we're just

00:19:39,730 --> 00:19:43,840
dividing that into two fields and right

00:19:41,710 --> 00:19:46,360
away these fields speak to us a little

00:19:43,840 --> 00:19:48,280
more we know to get a user by ID you

00:19:46,360 --> 00:19:49,940
really need to provide an ID to get a

00:19:48,280 --> 00:19:51,620
user by login we really

00:19:49,940 --> 00:19:54,860
you need to provide that logging string

00:19:51,620 --> 00:19:58,759
and this is a really basic example again

00:19:54,860 --> 00:20:01,190
but we had like much complex more

00:19:58,759 --> 00:20:03,289
complex variations of this where fields

00:20:01,190 --> 00:20:04,850
had different boolean arguments to

00:20:03,289 --> 00:20:07,820
filter different ways or include

00:20:04,850 --> 00:20:09,950
different values and by exploding these

00:20:07,820 --> 00:20:12,379
into different fields it turns out as

00:20:09,950 --> 00:20:16,340
kima was much better and really easier

00:20:12,379 --> 00:20:18,470
to understand so I want to get into kind

00:20:16,340 --> 00:20:21,230
of what tooling we built around these

00:20:18,470 --> 00:20:24,019
guiding principles and how that helped

00:20:21,230 --> 00:20:26,990
our product teams and our API team to

00:20:24,019 --> 00:20:31,309
ship better api's and a first step to

00:20:26,990 --> 00:20:34,909
that is our checked in SDL so every time

00:20:31,309 --> 00:20:37,789
a product developer or somebody working

00:20:34,909 --> 00:20:40,370
on a new API adds a new type a new field

00:20:37,789 --> 00:20:42,470
any member to the schema

00:20:40,370 --> 00:20:45,340
we're actually required to dump the

00:20:42,470 --> 00:20:49,129
schema SDL and checking in and to github

00:20:45,340 --> 00:20:53,509
we write our schema using the graphical

00:20:49,129 --> 00:20:56,360
ruby gem so this is used Ruby classes so

00:20:53,509 --> 00:20:59,090
to us we don't use the SDL directly so

00:20:56,360 --> 00:21:02,950
the SDL is rather an artifact of our

00:20:59,090 --> 00:21:06,409
Ruby class is used to build a schema and

00:21:02,950 --> 00:21:08,000
this gives us a few advantages since

00:21:06,409 --> 00:21:10,850
we're using Ruby to define that schema

00:21:08,000 --> 00:21:13,250
it's much easier to look at the SDL to

00:21:10,850 --> 00:21:15,139
see what has changed in a TR especially

00:21:13,250 --> 00:21:19,190
for the API team that reviews a lot of

00:21:15,139 --> 00:21:20,750
PR s it's really easy to just go right

00:21:19,190 --> 00:21:22,990
away to what s changing the public

00:21:20,750 --> 00:21:25,519
schema here and we see it really easily

00:21:22,990 --> 00:21:28,009
from the same Ruby classes we also

00:21:25,519 --> 00:21:29,929
generate the internal public and

00:21:28,009 --> 00:21:33,860
enterprise versions of the schema so

00:21:29,929 --> 00:21:35,179
these as DL dumps really help us see

00:21:33,860 --> 00:21:39,080
what has changed without looking at a

00:21:35,179 --> 00:21:39,860
ruby code too much right away with that

00:21:39,080 --> 00:21:42,769
schema dump

00:21:39,860 --> 00:21:45,200
we're actually able every time a new

00:21:42,769 --> 00:21:47,360
change is added or anything has changed

00:21:45,200 --> 00:21:51,230
in the schema we run a company around

00:21:47,360 --> 00:21:53,570
them and at first this led us actually

00:21:51,230 --> 00:21:57,769
just fail CI whenever a breaking change

00:21:53,570 --> 00:21:59,750
was detected our API has to be stable we

00:21:57,769 --> 00:22:02,779
have so many API different API clients

00:21:59,750 --> 00:22:04,710
that rely on most of our fields so we

00:22:02,779 --> 00:22:06,210
just failed us yesterday

00:22:04,710 --> 00:22:08,340
this was an ideal though because

00:22:06,210 --> 00:22:10,740
sometimes we actually need to remove

00:22:08,340 --> 00:22:12,660
some fields maybe we've gone to the

00:22:10,740 --> 00:22:17,010
route of duplicating it and it's time to

00:22:12,660 --> 00:22:19,220
remove it so we also use that schema

00:22:17,010 --> 00:22:22,290
comparator to generate a schema change

00:22:19,220 --> 00:22:24,150
log every day we just log everything

00:22:22,290 --> 00:22:26,190
that's changed in the schema the cells

00:22:24,150 --> 00:22:30,030
are integrators kind of keep up to date

00:22:26,190 --> 00:22:31,680
with the github API but that failing

00:22:30,030 --> 00:22:33,810
test was kind of annoying to us because

00:22:31,680 --> 00:22:36,410
it required a code change every time a

00:22:33,810 --> 00:22:38,910
breaking change was actually a legit one

00:22:36,410 --> 00:22:40,620
and the time to actually shipping a

00:22:38,910 --> 00:22:43,470
change was a little bit too slow for us

00:22:40,620 --> 00:22:45,800
so we introduced a new friend to our API

00:22:43,470 --> 00:22:48,810
team called graphical doctor and

00:22:45,800 --> 00:22:51,450
graphical doctor is a PR review bot that

00:22:48,810 --> 00:22:54,450
helps us kind of enforce best practices

00:22:51,450 --> 00:22:57,720
give pointers and also detecting changes

00:22:54,450 --> 00:23:00,300
to the schema and write kind of action

00:22:57,720 --> 00:23:01,470
to take in these cases so here somebody

00:23:00,300 --> 00:23:05,280
was trying to remove the pull request

00:23:01,470 --> 00:23:06,780
field and the budget just mmm probably

00:23:05,280 --> 00:23:08,100
shouldn't do that straightaway you

00:23:06,780 --> 00:23:10,560
should probably deprecated it first

00:23:08,100 --> 00:23:16,110
because we have integrators relying on

00:23:10,560 --> 00:23:18,630
it we also have the graph fueled ducks a

00:23:16,110 --> 00:23:20,730
repo here that's kind of our own

00:23:18,630 --> 00:23:23,730
internal design tips I was talking about

00:23:20,730 --> 00:23:26,280
earlier this helps a lot but the cool

00:23:23,730 --> 00:23:29,670
thing is that the graphical doctor is

00:23:26,280 --> 00:23:33,600
aware of that rule book Kara and is able

00:23:29,670 --> 00:23:36,930
to tell anyone who's opening a PR that

00:23:33,600 --> 00:23:38,940
may be here an order by argument needs a

00:23:36,930 --> 00:23:41,370
default value and these are kind of our

00:23:38,940 --> 00:23:45,000
own little rules that might not apply to

00:23:41,370 --> 00:23:48,420
your use cases but we have we have files

00:23:45,000 --> 00:23:51,480
full of them but sometimes we're not

00:23:48,420 --> 00:23:54,030
perfect schema design is hard and we do

00:23:51,480 --> 00:23:56,280
make mistakes and we have to repair them

00:23:54,030 --> 00:23:59,610
somehow so the first thing we looked at

00:23:56,280 --> 00:24:02,580
was that deprecated directive and we

00:23:59,610 --> 00:24:04,290
started using it to slowly get away from

00:24:02,580 --> 00:24:09,180
fields that maybe we designed wrong

00:24:04,290 --> 00:24:11,340
named in a bad way or anything else so

00:24:09,180 --> 00:24:13,890
we used it pretty much everywhere and

00:24:11,340 --> 00:24:17,190
what we started realizing is that the

00:24:13,890 --> 00:24:18,630
reason argument here in the directive we

00:24:17,190 --> 00:24:21,120
have a bunch of people working in a

00:24:18,630 --> 00:24:23,150
schema and the reasons were kind of all

00:24:21,120 --> 00:24:24,890
over the place some people were

00:24:23,150 --> 00:24:28,050
proposing an alternative

00:24:24,890 --> 00:24:30,420
some people were just saying stop using

00:24:28,050 --> 00:24:32,610
this field and this wasn't the best

00:24:30,420 --> 00:24:35,670
experience for our integrators what we

00:24:32,610 --> 00:24:37,860
want is a bit more consistency in the

00:24:35,670 --> 00:24:40,680
duplication messages here and a lot more

00:24:37,860 --> 00:24:42,270
help to integrators to know what they

00:24:40,680 --> 00:24:46,200
can do now that the field that we're

00:24:42,270 --> 00:24:48,830
using is being duplicated so I mentioned

00:24:46,200 --> 00:24:51,480
earlier using Ruby to define our schema

00:24:48,830 --> 00:24:54,590
and what we did is came up with an Ruby

00:24:51,480 --> 00:24:58,620
API to deprecate pretty much any member

00:24:54,590 --> 00:25:01,740
and that API enforces three things first

00:24:58,620 --> 00:25:04,440
of all the start date is one we want to

00:25:01,740 --> 00:25:06,660
start the deprecation period then we

00:25:04,440 --> 00:25:09,240
have the reason that's kind of the

00:25:06,660 --> 00:25:11,520
original reason string here and we also

00:25:09,240 --> 00:25:13,680
have that superseded by field here which

00:25:11,520 --> 00:25:16,170
is really important for us is what a

00:25:13,680 --> 00:25:18,180
integrator should use instead or an

00:25:16,170 --> 00:25:21,870
alternative solution to the field that

00:25:18,180 --> 00:25:24,960
we're using and what we do with that API

00:25:21,870 --> 00:25:27,360
is we actually to respect the spec we

00:25:24,960 --> 00:25:29,430
actually build up and encode that

00:25:27,360 --> 00:25:32,610
information into the reason string at

00:25:29,430 --> 00:25:34,230
the graphical level so here with the

00:25:32,610 --> 00:25:37,170
start date we were able to compute

00:25:34,230 --> 00:25:39,240
automatically a removal date we try to

00:25:37,170 --> 00:25:42,420
remove fields three to six months after

00:25:39,240 --> 00:25:44,370
they're being deprecated the reason is

00:25:42,420 --> 00:25:48,240
included here and

00:25:44,370 --> 00:25:50,490
the alternative way is included so with

00:25:48,240 --> 00:25:52,890
that Ruby API that all developers have

00:25:50,490 --> 00:25:54,960
to use all our duplication reasons

00:25:52,890 --> 00:25:58,260
started being much more consistent and a

00:25:54,960 --> 00:26:00,180
lot more helpful to integrators there

00:25:58,260 --> 00:26:02,220
was another kind of hurdle here is that

00:26:00,180 --> 00:26:07,100
we could only use the deprecated

00:26:02,220 --> 00:26:10,800
directive on fields or enum values and

00:26:07,100 --> 00:26:12,150
what we did here is well we can't really

00:26:10,800 --> 00:26:15,180
use it because we don't want to go

00:26:12,150 --> 00:26:17,310
against the spec but we'll just fake it

00:26:15,180 --> 00:26:20,460
and a panda string to the description

00:26:17,310 --> 00:26:21,900
this was far from perfect but we were

00:26:20,460 --> 00:26:23,760
kind of hoping to prove a point that

00:26:21,900 --> 00:26:25,080
there was indeed a use case to

00:26:23,760 --> 00:26:27,460
deprecating

00:26:25,080 --> 00:26:29,710
arguments I'm actually happy recently

00:26:27,460 --> 00:26:31,809
this week I saw there's a PR pretty

00:26:29,710 --> 00:26:34,480
close to be merged in the graphical spec

00:26:31,809 --> 00:26:38,950
to be able to deprecate arguments and

00:26:34,480 --> 00:26:41,440
input values with this Ruby API though

00:26:38,950 --> 00:26:44,440
we actually collect information on every

00:26:41,440 --> 00:26:46,750
single deprecation in our schema and we

00:26:44,440 --> 00:26:49,150
auto generate our documentation a

00:26:46,750 --> 00:26:51,039
breaking changes page here that includes

00:26:49,150 --> 00:26:53,650
the reason why what should be used

00:26:51,039 --> 00:26:56,919
instead and when the field will be

00:26:53,650 --> 00:26:59,350
actually sunset and this page there's no

00:26:56,919 --> 00:27:02,980
human that dashes it this really only

00:26:59,350 --> 00:27:07,450
generated from metadata we collect from

00:27:02,980 --> 00:27:10,809
our Ruby schema so we deprecated the

00:27:07,450 --> 00:27:12,850
things this is great but the hard things

00:27:10,809 --> 00:27:14,679
and there is actually making the change

00:27:12,850 --> 00:27:18,340
removing the field after it's been

00:27:14,679 --> 00:27:20,049
duplicated so I mentioned we give

00:27:18,340 --> 00:27:22,960
between three and six months to

00:27:20,049 --> 00:27:25,480
integrators to move away from fields but

00:27:22,960 --> 00:27:27,159
even after six months you know it is

00:27:25,480 --> 00:27:30,000
probably there's a lot of people still

00:27:27,159 --> 00:27:32,409
using that field and we didn't know who

00:27:30,000 --> 00:27:35,140
we wanted to know exactly who was using

00:27:32,409 --> 00:27:36,940
the fields that were duplicated how much

00:27:35,140 --> 00:27:39,730
they were used maybe if they're used

00:27:36,940 --> 00:27:41,289
like once a week we can actually move on

00:27:39,730 --> 00:27:44,620
without fearing to break a big

00:27:41,289 --> 00:27:46,299
integrator for example and we realized

00:27:44,620 --> 00:27:48,490
something my favorite graph killed

00:27:46,299 --> 00:27:49,870
poverty that graph girl has no select

00:27:48,490 --> 00:27:52,539
star it's actually very useful here

00:27:49,870 --> 00:27:54,580
because we know exactly our schema is

00:27:52,539 --> 00:27:57,220
used we know down to the individual

00:27:54,580 --> 00:27:59,590
fields arguments enum values we know

00:27:57,220 --> 00:28:02,530
exactly what parts our schema is used

00:27:59,590 --> 00:28:04,299
and when so what we started doing is

00:28:02,530 --> 00:28:08,890
that whenever we had a public API for

00:28:04,299 --> 00:28:11,740
hitting our API we immediately put in

00:28:08,890 --> 00:28:15,640
some queue and we have this graphical

00:28:11,740 --> 00:28:19,240
query analytics service whose job is

00:28:15,640 --> 00:28:21,760
basically just to take a query gonna

00:28:19,240 --> 00:28:25,210
denormalize it into every single field

00:28:21,760 --> 00:28:28,059
or member that was used and put that

00:28:25,210 --> 00:28:28,450
entire and data warehouse so that was

00:28:28,059 --> 00:28:30,549
great

00:28:28,450 --> 00:28:33,549
we have all that information in our data

00:28:30,549 --> 00:28:36,399
warehouse we knew exactly how our schema

00:28:33,549 --> 00:28:37,899
was used but we wanted something better

00:28:36,399 --> 00:28:38,360
than this this was just in our data

00:28:37,899 --> 00:28:42,140
warehouse

00:28:38,360 --> 00:28:43,460
it wasn't so great to query against we

00:28:42,140 --> 00:28:46,130
wanted something that developers could

00:28:43,460 --> 00:28:47,630
use whenever their duplicating something

00:28:46,130 --> 00:28:50,420
or trying to remove something with a

00:28:47,630 --> 00:28:54,110
quick feedback loop and I get up we use

00:28:50,420 --> 00:28:55,990
our friendly Shoebat here in our slack

00:28:54,110 --> 00:28:58,640
channel that helps up with a bunch of

00:28:55,990 --> 00:29:02,810
really everything we deploy using hue

00:28:58,640 --> 00:29:05,120
but so we thought why not use you but to

00:29:02,810 --> 00:29:08,000
actually help our developers know how

00:29:05,120 --> 00:29:11,570
our schema is used so in our slack

00:29:08,000 --> 00:29:13,870
channels any engineer can start asking

00:29:11,570 --> 00:29:16,850
you but give me the usage for the field

00:29:13,870 --> 00:29:19,970
name on type repository on our public

00:29:16,850 --> 00:29:22,940
schema since last five days for example

00:29:19,970 --> 00:29:25,460
and what Hubert will do is actually

00:29:22,940 --> 00:29:29,390
query presto over our data warehouse and

00:29:25,460 --> 00:29:32,540
we turn us with what the data we wanted

00:29:29,390 --> 00:29:35,720
here somebody wanted to remove the name

00:29:32,540 --> 00:29:38,150
field for example well click quickly we

00:29:35,720 --> 00:29:40,840
see that their repository name field is

00:29:38,150 --> 00:29:43,550
really used and we shouldn't do that yet

00:29:40,840 --> 00:29:46,070
but still this wasn't as friendly enough

00:29:43,550 --> 00:29:47,390
because maybe some of our engineers as I

00:29:46,070 --> 00:29:49,160
said earlier we have a lot of people who

00:29:47,390 --> 00:29:51,710
are working on a schema it's a lot of

00:29:49,160 --> 00:29:53,300
chances to maybe forget something we

00:29:51,710 --> 00:29:56,390
really wanted to be sure that whenever

00:29:53,300 --> 00:29:59,240
something is removed we check if it's

00:29:56,390 --> 00:30:02,330
safe so graph our graphical dr friend

00:29:59,240 --> 00:30:04,490
not only now tells us that removing it

00:30:02,330 --> 00:30:06,710
feels a breaking change but it tells it

00:30:04,490 --> 00:30:08,510
tells us that the field actually has

00:30:06,710 --> 00:30:11,510
been used a lot in the past day for

00:30:08,510 --> 00:30:14,720
example we also have information on

00:30:11,510 --> 00:30:17,390
which apps which innovator which user is

00:30:14,720 --> 00:30:19,010
using the fields so that lets us for

00:30:17,390 --> 00:30:21,620
example when is the last month of

00:30:19,010 --> 00:30:24,800
duplication reach out by email to our

00:30:21,620 --> 00:30:26,480
integrators and say we've noticed you've

00:30:24,800 --> 00:30:29,660
been using this query this query in this

00:30:26,480 --> 00:30:32,150
query and they're using these fields

00:30:29,660 --> 00:30:34,910
that we've been duplicating so you can

00:30:32,150 --> 00:30:37,550
imagine this lets us build tools that

00:30:34,910 --> 00:30:40,040
are even cooler than this soon for

00:30:37,550 --> 00:30:42,680
example we encode the superseded by what

00:30:40,040 --> 00:30:44,990
a client should use instead imagine if

00:30:42,680 --> 00:30:46,310
we could use that to provide an

00:30:44,990 --> 00:30:48,130
alternative query that would be

00:30:46,310 --> 00:30:50,060
equivalent to their old query and

00:30:48,130 --> 00:30:52,410
automatically kind of migrate their

00:30:50,060 --> 00:30:56,550
queries for them so this is all

00:30:52,410 --> 00:31:00,120
we're looking at so graphical schema

00:30:56,550 --> 00:31:03,240
design at scale is really about to me

00:31:00,120 --> 00:31:06,360
talking to or becoming when it's simple

00:31:03,240 --> 00:31:08,070
domain experts really knowing what your

00:31:06,360 --> 00:31:11,070
application what your business is all

00:31:08,070 --> 00:31:13,710
about it's also thinking about that

00:31:11,070 --> 00:31:17,790
domain really more than thinking about

00:31:13,710 --> 00:31:19,950
the data how your data is backed which

00:31:17,790 --> 00:31:22,410
data is used by your entities and really

00:31:19,950 --> 00:31:25,740
more about what they can do and what

00:31:22,410 --> 00:31:27,270
behavior is they show and sometimes it's

00:31:25,740 --> 00:31:29,520
not really about building at one size

00:31:27,270 --> 00:31:31,530
fits all we wasted a lot of time trying

00:31:29,520 --> 00:31:33,540
to think how could we make this field

00:31:31,530 --> 00:31:35,700
and all these all these variations and

00:31:33,540 --> 00:31:37,830
in the end just providing different ways

00:31:35,700 --> 00:31:41,160
of doing things it's perfectly fine

00:31:37,830 --> 00:31:44,040
sometimes and finally we have that great

00:31:41,160 --> 00:31:47,240
type system and we really must use it to

00:31:44,040 --> 00:31:50,100
build great tools to help engineers work

00:31:47,240 --> 00:31:52,590
client build better clients and

00:31:50,100 --> 00:31:55,730
everything that has to do with a type

00:31:52,590 --> 00:32:03,839
system thank you so much

00:31:55,730 --> 00:32:03,839

YouTube URL: https://www.youtube.com/watch?v=pJamhW2xPYw


