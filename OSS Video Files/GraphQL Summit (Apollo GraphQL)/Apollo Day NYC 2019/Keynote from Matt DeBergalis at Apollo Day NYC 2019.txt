Title: Keynote from Matt DeBergalis at Apollo Day NYC 2019
Publication date: 2019-05-20
Playlist: Apollo Day NYC 2019
Description: 
	
Captions: 
	00:00:01,650 --> 00:00:06,160
all right well welcome everyone let's

00:00:04,180 --> 00:00:10,540
get right into it my name is Matt I'm

00:00:06,160 --> 00:00:12,190
really excited to have a chance to share

00:00:10,540 --> 00:00:15,190
all of all this great stuff with

00:00:12,190 --> 00:00:18,640
everyone here and look my point of view

00:00:15,190 --> 00:00:20,109
on all of this is we're all here to

00:00:18,640 --> 00:00:23,230
learn together graphical is a really new

00:00:20,109 --> 00:00:25,720
technology and everything you're gonna

00:00:23,230 --> 00:00:27,099
see from us and everything I know came

00:00:25,720 --> 00:00:29,650
from working with teams that are

00:00:27,099 --> 00:00:31,779
building amazing stuff so please don't

00:00:29,650 --> 00:00:32,860
take this as a an event where you came

00:00:31,779 --> 00:00:34,090
we're going to tell you a bunch of stuff

00:00:32,860 --> 00:00:37,690
and then you go home it really isn't

00:00:34,090 --> 00:00:40,270
that and I'm really excited to learn

00:00:37,690 --> 00:00:41,590
from everyone here and find out more

00:00:40,270 --> 00:00:44,170
about what what everyone is doing

00:00:41,590 --> 00:00:47,340
let's start by assuring everyone that

00:00:44,170 --> 00:00:50,170
you're in the right room so this is a

00:00:47,340 --> 00:00:51,940
look at how graph QL adoption has

00:00:50,170 --> 00:00:53,680
progressed over the last few years from

00:00:51,940 --> 00:00:55,629
Google Trends and and we're sitting it

00:00:53,680 --> 00:00:57,280
next to some of the other ideas like

00:00:55,629 --> 00:01:00,879
Falkor or Oh data that tried to

00:00:57,280 --> 00:01:03,250
structure how an API might work and the

00:01:00,879 --> 00:01:05,410
point is it's it's happening this has

00:01:03,250 --> 00:01:09,100
all the makings of a developer megatrend

00:01:05,410 --> 00:01:09,520
I think something north of 80% of graph

00:01:09,100 --> 00:01:12,240
QL

00:01:09,520 --> 00:01:14,170
excuse me JavaScript developers

00:01:12,240 --> 00:01:15,729
according to the state of JavaScript

00:01:14,170 --> 00:01:18,700
survey last year said that they're using

00:01:15,729 --> 00:01:20,650
or want to learn graph QL north of 20

00:01:18,700 --> 00:01:22,270
percent of all new developers according

00:01:20,650 --> 00:01:27,369
to the nude foundation are actively

00:01:22,270 --> 00:01:30,009
developing graph QL api's Laurie Voss of

00:01:27,369 --> 00:01:32,320
NPM talks about graph QL is one of the

00:01:30,009 --> 00:01:36,610
absolute must learn technologies for

00:01:32,320 --> 00:01:39,759
2019 so on and so on and so on so you

00:01:36,610 --> 00:01:42,280
know this is new but it's absolutely up

00:01:39,759 --> 00:01:44,259
off the ground and one of the things

00:01:42,280 --> 00:01:46,780
we're gonna try to do today is help you

00:01:44,259 --> 00:01:48,640
gain more confidence about not just

00:01:46,780 --> 00:01:50,619
adopting graph kill but going faster and

00:01:48,640 --> 00:01:52,540
further maybe then you were otherwise

00:01:50,619 --> 00:01:54,700
planning and I think part of having that

00:01:52,540 --> 00:01:57,640
coffin it says seeing the momentum and

00:01:54,700 --> 00:02:00,280
the proof points across the industry of

00:01:57,640 --> 00:02:01,829
what people are doing we get a bird's

00:02:00,280 --> 00:02:04,210
eye view of a lot of that at Apollo

00:02:01,829 --> 00:02:04,540
because of our open source work one of

00:02:04,210 --> 00:02:07,240
the thing

00:02:04,540 --> 00:02:09,100
we know early on is Apollo client this

00:02:07,240 --> 00:02:13,480
is the library that binds your UI to

00:02:09,100 --> 00:02:15,160
your graphical schema that looks about

00:02:13,480 --> 00:02:19,120
right

00:02:15,160 --> 00:02:21,610
so what's driving all this you know

00:02:19,120 --> 00:02:23,020
Pascal doesn't like yarn or redux

00:02:21,610 --> 00:02:26,110
something you might reasonably implement

00:02:23,020 --> 00:02:27,760
in a day or two it's a it's an API we're

00:02:26,110 --> 00:02:31,330
talking about an API that's displacing

00:02:27,760 --> 00:02:36,370
rest rest as the link between your apps

00:02:31,330 --> 00:02:37,870
and your services so it's a lot to adopt

00:02:36,370 --> 00:02:39,850
something like that and the benefits

00:02:37,870 --> 00:02:41,380
have to be commensurate with that and I

00:02:39,850 --> 00:02:43,150
think we all know a lot of the story

00:02:41,380 --> 00:02:44,560
it's it's less data on the wire it's

00:02:43,150 --> 00:02:46,210
great tooling we're gonna see some

00:02:44,560 --> 00:02:49,060
examples of that but I think the story

00:02:46,210 --> 00:02:51,190
goes deeper than that and to illustrate

00:02:49,060 --> 00:02:53,640
what I'm what I'm thinking about we

00:02:51,190 --> 00:02:55,810
might look at a kind of modern app

00:02:53,640 --> 00:02:59,950
experience here's sort of your

00:02:55,810 --> 00:03:03,490
hypothetical you know hotel booking app

00:02:59,950 --> 00:03:07,590
and what we hear over and over and what

00:03:03,490 --> 00:03:11,620
we see is a modern app means data a

00:03:07,590 --> 00:03:15,550
modern app experience means connecting

00:03:11,620 --> 00:03:18,430
users with a growing array of different

00:03:15,550 --> 00:03:21,280
bits of data that create the experience

00:03:18,430 --> 00:03:25,480
they have whether it's personalization

00:03:21,280 --> 00:03:28,150
or machine learning and recommendations

00:03:25,480 --> 00:03:29,950
or real-time pricing and inventory or

00:03:28,150 --> 00:03:33,160
something social or something that's

00:03:29,950 --> 00:03:36,070
streaming into the user experience great

00:03:33,160 --> 00:03:37,959
experiences depend on being able to

00:03:36,070 --> 00:03:40,360
bring all the data you have into into

00:03:37,959 --> 00:03:42,010
one screen and that data lives in a

00:03:40,360 --> 00:03:43,630
growing array of places right with the

00:03:42,010 --> 00:03:45,820
rise of micro services and cloud native

00:03:43,630 --> 00:03:47,380
architecture this information doesn't

00:03:45,820 --> 00:03:49,239
come from one database or one endpoint

00:03:47,380 --> 00:03:50,890
anymore it comes from three four five

00:03:49,239 --> 00:03:55,209
ten different systems that you may be

00:03:50,890 --> 00:03:58,870
running in your environment and if

00:03:55,209 --> 00:04:01,690
you'll excuse the crude drawing that's

00:03:58,870 --> 00:04:03,130
one of the trends we see there's there's

00:04:01,690 --> 00:04:05,560
another thing happening at the same time

00:04:03,130 --> 00:04:07,920
which is the expectations of our users

00:04:05,560 --> 00:04:10,750
are now that the applications are on a

00:04:07,920 --> 00:04:12,190
growing array of platforms it's not just

00:04:10,750 --> 00:04:15,810
web and mobile anymore right we also

00:04:12,190 --> 00:04:18,329
have IOT we've got carplay watches

00:04:15,810 --> 00:04:20,160
voice and something coming next year

00:04:18,329 --> 00:04:21,329
that we don't know about yet but when it

00:04:20,160 --> 00:04:23,040
emerges we're gonna have to have our

00:04:21,329 --> 00:04:26,100
applications and our experiences on that

00:04:23,040 --> 00:04:27,930
platform too and all of that is against

00:04:26,100 --> 00:04:30,870
a third shred there's a backdrop against

00:04:27,930 --> 00:04:33,360
this which is the government is starting

00:04:30,870 --> 00:04:35,700
to take an interest in this stuff and so

00:04:33,360 --> 00:04:38,870
the way that data moves from the cloud

00:04:35,700 --> 00:04:41,490
to our apps is now governed by GAAP our

00:04:38,870 --> 00:04:45,210
by you know the California consumer

00:04:41,490 --> 00:04:47,750
Privacy Act coming next year and we're

00:04:45,210 --> 00:04:50,820
gonna have to start having a structured

00:04:47,750 --> 00:04:52,290
understanding of exactly how our data

00:04:50,820 --> 00:04:54,510
moves and exactly what we're doing with

00:04:52,290 --> 00:04:55,889
it and so the question is how on earth

00:04:54,510 --> 00:04:58,410
are we supposed to build great apps

00:04:55,889 --> 00:05:00,330
quickly when we've got all these

00:04:58,410 --> 00:05:02,310
services all these things that we have

00:05:00,330 --> 00:05:04,200
to build all these connections between

00:05:02,310 --> 00:05:05,820
the two that are governed by these rules

00:05:04,200 --> 00:05:07,250
that most developers don't want to know

00:05:05,820 --> 00:05:11,070
about and shouldn't have to know about

00:05:07,250 --> 00:05:12,930
and the way out of the mess and our

00:05:11,070 --> 00:05:16,470
point of view is this new layer in the

00:05:12,930 --> 00:05:17,880
stack the data graph and when we talk

00:05:16,470 --> 00:05:22,680
about the rise of graph QL and the

00:05:17,880 --> 00:05:25,560
adoption of these ideas most of that is

00:05:22,680 --> 00:05:29,669
in the context of of this concept where

00:05:25,560 --> 00:05:32,010
we're going to use graph QL as a way to

00:05:29,669 --> 00:05:33,510
decouple the services that we run

00:05:32,010 --> 00:05:35,400
internally we're all the business logic

00:05:33,510 --> 00:05:37,500
and the data and all that investment

00:05:35,400 --> 00:05:39,030
we've made lives from the applications

00:05:37,500 --> 00:05:42,330
and the user experiences that we need to

00:05:39,030 --> 00:05:46,800
build going forward you can think of it

00:05:42,330 --> 00:05:49,200
as a marketplace right the applications

00:05:46,800 --> 00:05:51,530
describe declaratively the data they

00:05:49,200 --> 00:05:54,539
require in the form of graphical queries

00:05:51,530 --> 00:05:57,030
services describe their capabilities in

00:05:54,539 --> 00:05:59,880
the form of a resolver right in a schema

00:05:57,030 --> 00:06:05,100
and what we put in the middle is this

00:05:59,880 --> 00:06:08,010
this amazon pine for all your data right

00:06:05,100 --> 00:06:09,630
I don't have to know where it's gonna

00:06:08,010 --> 00:06:11,010
come from exactly I don't have to know

00:06:09,630 --> 00:06:13,080
about all the logistics that live

00:06:11,010 --> 00:06:14,400
underneath that to be able to take

00:06:13,080 --> 00:06:16,289
advantage of this idea that is a

00:06:14,400 --> 00:06:16,770
consumer of data I just described what I

00:06:16,289 --> 00:06:18,270
need

00:06:16,770 --> 00:06:21,360
just like I go order some stuff from

00:06:18,270 --> 00:06:23,729
Amazon and it shows up exactly the way I

00:06:21,360 --> 00:06:26,220
asked for it without any complication

00:06:23,729 --> 00:06:27,360
and there's so many compelling ideas to

00:06:26,220 --> 00:06:29,129
this I think so

00:06:27,360 --> 00:06:32,419
development velocity go

00:06:29,129 --> 00:06:34,949
that saying you're not writing all those

00:06:32,419 --> 00:06:36,419
individual api's you're not building all

00:06:34,949 --> 00:06:38,489
of that point-to-point connectivity

00:06:36,419 --> 00:06:40,999
between each app and each service we

00:06:38,489 --> 00:06:43,979
call that the N by n problem sometimes

00:06:40,999 --> 00:06:45,869
you you get consistency so things can

00:06:43,979 --> 00:06:47,580
live in the data graph like localization

00:06:45,869 --> 00:06:48,899
or internationalization that you used to

00:06:47,580 --> 00:06:51,179
have to write individually and each

00:06:48,899 --> 00:06:55,199
client now you get to write at once and

00:06:51,179 --> 00:06:56,789
it's the same for everyone um and I

00:06:55,199 --> 00:07:00,809
think maybe most exciting for the first

00:06:56,789 --> 00:07:03,990
time we have this central view and

00:07:00,809 --> 00:07:06,389
control over how data moves around the

00:07:03,990 --> 00:07:08,580
organization this fine-grained

00:07:06,389 --> 00:07:10,860
understanding of exactly what data each

00:07:08,580 --> 00:07:12,929
client needs exactly what data it's

00:07:10,860 --> 00:07:15,959
using and not using exactly which part

00:07:12,929 --> 00:07:17,939
of a services API is actually finding

00:07:15,959 --> 00:07:19,679
its way to you user and how and in what

00:07:17,939 --> 00:07:21,360
setting and we're gonna see some

00:07:19,679 --> 00:07:24,949
examples of how powerful that is and how

00:07:21,360 --> 00:07:26,909
exciting that can be for app development

00:07:24,949 --> 00:07:29,189
the other cool thing about the data

00:07:26,909 --> 00:07:31,379
graph is you can start really small so

00:07:29,189 --> 00:07:34,139
our recommendation and what most teams

00:07:31,379 --> 00:07:37,199
do is just start with one screen in one

00:07:34,139 --> 00:07:39,149
app and just one service and your graph

00:07:37,199 --> 00:07:40,889
is nothing more than one or two graphic

00:07:39,149 --> 00:07:43,829
you'll types and a few resolvers it's

00:07:40,889 --> 00:07:46,619
that simple there's good news and bad

00:07:43,829 --> 00:07:50,369
news here though there's a really strong

00:07:46,619 --> 00:07:53,399
network effect around that graph what

00:07:50,369 --> 00:07:55,889
inevitably happens is as soon as you

00:07:53,399 --> 00:07:57,599
stand one up the adjacent mobile

00:07:55,889 --> 00:07:59,279
application wants to consume the same

00:07:57,599 --> 00:08:01,319
graph it might only need an extra field

00:07:59,279 --> 00:08:02,849
or two Anna scheming to do that and that

00:08:01,319 --> 00:08:05,099
enables you to bring in a new service

00:08:02,849 --> 00:08:06,749
that brings in a new piece of data that

00:08:05,099 --> 00:08:09,149
allows you to move more components from

00:08:06,749 --> 00:08:10,499
your your web app over you're not gonna

00:08:09,149 --> 00:08:11,969
end up with ten of these things that are

00:08:10,499 --> 00:08:14,969
really little you're gonna end up with

00:08:11,969 --> 00:08:16,409
one big one and that's the challenge and

00:08:14,969 --> 00:08:19,349
a lot of what we want to talk about

00:08:16,409 --> 00:08:22,079
today is fundamentally what we hear from

00:08:19,349 --> 00:08:24,679
teams that are adopting this if I can

00:08:22,079 --> 00:08:27,300
distill it all down to one point is I

00:08:24,679 --> 00:08:29,279
know I'm committed to graph QL my

00:08:27,300 --> 00:08:32,610
developers are gonna quit if I don't do

00:08:29,279 --> 00:08:36,120
it and I see the benefits of

00:08:32,610 --> 00:08:38,909
centralizing all this into a schema but

00:08:36,120 --> 00:08:40,380
I know there's a lot at stake because I

00:08:38,909 --> 00:08:41,950
know I'm going to end up with one and

00:08:40,380 --> 00:08:43,750
the idea for example

00:08:41,950 --> 00:08:46,150
that all my developers 200 developers

00:08:43,750 --> 00:08:49,750
are gonna collaborate on a big no thing

00:08:46,150 --> 00:08:51,850
in the middle of my my stack is nuts so

00:08:49,750 --> 00:08:53,320
I want to know that I'm architecting

00:08:51,850 --> 00:08:55,030
this schema right I want to know that I

00:08:53,320 --> 00:08:57,160
have the right patterns for how I

00:08:55,030 --> 00:08:58,480
connect my services to my apps I want to

00:08:57,160 --> 00:08:59,920
know that I have the right development

00:08:58,480 --> 00:09:01,240
process and collaboration in place I

00:08:59,920 --> 00:09:02,770
want to know that the right team Owens

00:09:01,240 --> 00:09:05,380
this and that I have the right process

00:09:02,770 --> 00:09:11,860
around how it changes and how it evolves

00:09:05,380 --> 00:09:13,810
over time and to answer some of that my

00:09:11,860 --> 00:09:17,080
co-founder Jeff and I wrote a document

00:09:13,810 --> 00:09:19,170
it's at principled graphical calm that

00:09:17,080 --> 00:09:21,570
distills what we've learned from

00:09:19,170 --> 00:09:25,630
hundreds of conversations with teams

00:09:21,570 --> 00:09:27,700
startups enterprises all sizes and

00:09:25,630 --> 00:09:32,080
captures the best patterns we've learned

00:09:27,700 --> 00:09:33,160
about how best to architect a graph what

00:09:32,080 --> 00:09:34,960
it looks like to have an agile

00:09:33,160 --> 00:09:36,940
development process around that graph

00:09:34,960 --> 00:09:40,300
what it looks like to have a thoughtful

00:09:36,940 --> 00:09:42,460
approach to DevOps and management and

00:09:40,300 --> 00:09:44,620
monitoring of this stuff and I'm not

00:09:42,460 --> 00:09:47,080
going to go through all these today but

00:09:44,620 --> 00:09:49,720
we are going to touch on some of them as

00:09:47,080 --> 00:09:52,260
we go through the day and and the reason

00:09:49,720 --> 00:09:54,550
I put this up on the screen is this

00:09:52,260 --> 00:09:57,340
these principles aren't just something

00:09:54,550 --> 00:10:00,130
we made up they're a road map they're a

00:09:57,340 --> 00:10:02,740
road map for you as you're adopting

00:10:00,130 --> 00:10:03,850
graph QL that can help guide you down

00:10:02,740 --> 00:10:06,250
the right path

00:10:03,850 --> 00:10:08,890
for how to build this out from from step

00:10:06,250 --> 00:10:11,350
one to step two to step 100 they're also

00:10:08,890 --> 00:10:13,300
a road map for us in terms of what we

00:10:11,350 --> 00:10:14,920
build to support you the products and

00:10:13,300 --> 00:10:16,240
the open-source libraries and the tools

00:10:14,920 --> 00:10:19,840
and the guidance and all that it all

00:10:16,240 --> 00:10:21,040
comes from from these core ideas so I'll

00:10:19,840 --> 00:10:23,620
show you a couple examples of what we've

00:10:21,040 --> 00:10:25,810
done so far this is one of the features

00:10:23,620 --> 00:10:29,800
in Apollo called schema change

00:10:25,810 --> 00:10:31,600
validation the idea here is you want to

00:10:29,800 --> 00:10:32,560
have an agile process around your graph

00:10:31,600 --> 00:10:34,510
that means you're going to need to

00:10:32,560 --> 00:10:36,370
change it you're not just gonna keep

00:10:34,510 --> 00:10:39,190
adding more fields to it you're gonna

00:10:36,370 --> 00:10:41,470
want to prune it and evolve it as your

00:10:39,190 --> 00:10:43,570
product needs change and if you have

00:10:41,470 --> 00:10:45,130
that ability it gives you great freedom

00:10:43,570 --> 00:10:46,270
to move quickly as you start building

00:10:45,130 --> 00:10:47,290
because you don't have to worry about

00:10:46,270 --> 00:10:48,880
making a mistake

00:10:47,290 --> 00:10:51,010
one of the benefits turns out of graph

00:10:48,880 --> 00:10:53,230
QL is that it's it's very light on its

00:10:51,010 --> 00:10:54,440
feet it lets you be quick with your with

00:10:53,230 --> 00:10:57,379
your development cycle

00:10:54,440 --> 00:10:58,910
so here's an example of why having this

00:10:57,379 --> 00:11:01,839
fine-grained understanding of data can

00:10:58,910 --> 00:11:04,220
be so powerful with graph QL we can

00:11:01,839 --> 00:11:06,110
validate at build time whether a

00:11:04,220 --> 00:11:08,029
proposed change to your data graph is

00:11:06,110 --> 00:11:10,430
compatible with all the clients out

00:11:08,029 --> 00:11:12,680
there that are consuming the graph and

00:11:10,430 --> 00:11:14,750
we can do this algebraically we have

00:11:12,680 --> 00:11:17,360
precise knowledge of every query that's

00:11:14,750 --> 00:11:20,089
been run in production and we can couple

00:11:17,360 --> 00:11:21,620
that with the proposed change so you're

00:11:20,089 --> 00:11:24,189
removing a field or you're changing

00:11:21,620 --> 00:11:27,470
something about an input type and and

00:11:24,189 --> 00:11:30,350
essentially enumerate all of the clients

00:11:27,470 --> 00:11:31,939
that are affected by that change this

00:11:30,350 --> 00:11:34,040
gives you a process now for either

00:11:31,939 --> 00:11:35,810
pushing that any way because it's an old

00:11:34,040 --> 00:11:37,970
client you're not concerned talking to

00:11:35,810 --> 00:11:39,379
the correct team maybe deprecating the

00:11:37,970 --> 00:11:40,790
field instead of removing it outright

00:11:39,379 --> 00:11:42,740
there's a whole set of workflows you can

00:11:40,790 --> 00:11:43,850
build around this and some of this stuff

00:11:42,740 --> 00:11:45,290
is obvious like you're not going to

00:11:43,850 --> 00:11:47,839
delete a field that's being used but

00:11:45,290 --> 00:11:49,939
it's actually pretty sophisticated you

00:11:47,839 --> 00:11:51,589
know this this is taken from our

00:11:49,939 --> 00:11:53,750
documentation for schema change

00:11:51,589 --> 00:11:55,819
validation there are some interesting

00:11:53,750 --> 00:11:58,129
cases around what if you change the

00:11:55,819 --> 00:11:59,959
structure of an enum type or if you make

00:11:58,129 --> 00:12:01,730
an input type required that wasn't

00:11:59,959 --> 00:12:04,069
previously required that's safe in some

00:12:01,730 --> 00:12:05,089
cases less safe and others so the point

00:12:04,069 --> 00:12:06,889
is we have this really sophisticated

00:12:05,089 --> 00:12:09,529
understanding way beyond what we ever

00:12:06,889 --> 00:12:12,800
had with rest api's of how we can evolve

00:12:09,529 --> 00:12:15,949
this graph here's another example we

00:12:12,800 --> 00:12:18,220
have a plug-in for vs code this has

00:12:15,949 --> 00:12:22,300
gotten really popular in the client

00:12:18,220 --> 00:12:24,290
community you get the basics things like

00:12:22,300 --> 00:12:25,880
autocomplete let's bring in the

00:12:24,290 --> 00:12:27,889
documentation string so you can see

00:12:25,880 --> 00:12:30,439
what's in the scheme as you type but it

00:12:27,889 --> 00:12:32,540
goes way beyond that for example we can

00:12:30,439 --> 00:12:35,689
show the predicted performance of a

00:12:32,540 --> 00:12:37,579
query is this thing I'm typing which

00:12:35,689 --> 00:12:42,470
I've never used in a product before fast

00:12:37,579 --> 00:12:44,990
or slow does adding this field is it

00:12:42,470 --> 00:12:46,279
basically for free or is it expensive

00:12:44,990 --> 00:12:47,149
because it turns out behind the scenes

00:12:46,279 --> 00:12:48,740
that's coming from a whole different

00:12:47,149 --> 00:12:51,410
service and that changes the whole query

00:12:48,740 --> 00:12:53,870
execution model so this empowers

00:12:51,410 --> 00:12:55,339
developers as you're building product

00:12:53,870 --> 00:12:57,439
with a level of understanding of the

00:12:55,339 --> 00:12:59,269
consequence of what you're building at

00:12:57,439 --> 00:13:01,069
build time right as you're as you're

00:12:59,269 --> 00:13:03,160
just in this phase of first

00:13:01,069 --> 00:13:06,230
experimenting with a new product shape

00:13:03,160 --> 00:13:08,240
or at their example safe listening

00:13:06,230 --> 00:13:10,610
I can type any arbitrary graph QL query

00:13:08,240 --> 00:13:12,620
I can develop software 10 times faster

00:13:10,610 --> 00:13:13,910
that's awesome the idea that I'm going

00:13:12,620 --> 00:13:16,310
to put that thing on the internet and

00:13:13,910 --> 00:13:19,400
anyone can type a graphical query that's

00:13:16,310 --> 00:13:21,830
less awesome so there's a there's a

00:13:19,400 --> 00:13:24,560
pattern we recommend called safe listing

00:13:21,830 --> 00:13:26,090
where as part of the build cycle in your

00:13:24,560 --> 00:13:27,530
CI tool chain for your client we

00:13:26,090 --> 00:13:31,190
actually extract the queries that you've

00:13:27,530 --> 00:13:34,190
written register those produce a

00:13:31,190 --> 00:13:36,920
manifest and have the server use that

00:13:34,190 --> 00:13:38,750
manifest as a yes/no condition for

00:13:36,920 --> 00:13:41,150
incoming queries so we've now crunched

00:13:38,750 --> 00:13:42,680
down in production your use of graph QL

00:13:41,150 --> 00:13:44,720
to a set of understood our PCs that

00:13:42,680 --> 00:13:45,800
you've validated in the development

00:13:44,720 --> 00:13:48,530
cycle and that you can have in

00:13:45,800 --> 00:13:51,770
production okay those are some examples

00:13:48,530 --> 00:13:53,210
they're all based on this chloral paulo

00:13:51,770 --> 00:13:54,890
platform and i'll just speak for a

00:13:53,210 --> 00:13:57,710
moment about what it is that we've built

00:13:54,890 --> 00:13:59,570
and what it's for so the the central

00:13:57,710 --> 00:14:01,490
part of Apollo is a set of open source

00:13:59,570 --> 00:14:03,140
libraries and tools that implement graph

00:14:01,490 --> 00:14:04,550
QL so we have a server of course and a

00:14:03,140 --> 00:14:07,670
client for both JavaScript and for

00:14:04,550 --> 00:14:10,100
mobile along with some associated

00:14:07,670 --> 00:14:12,290
libraries and tools what we layer

00:14:10,100 --> 00:14:14,780
underneath that is a we call it a graph

00:14:12,290 --> 00:14:17,510
manager so a set of registries that run

00:14:14,780 --> 00:14:19,490
in the cloud that track your schema and

00:14:17,510 --> 00:14:21,230
how it changes over time which clients

00:14:19,490 --> 00:14:24,020
you registered what the operations and

00:14:21,230 --> 00:14:25,610
those clients are and a set of analytics

00:14:24,020 --> 00:14:27,950
that are specific to graph QL so that

00:14:25,610 --> 00:14:30,170
for example we can do schema change

00:14:27,950 --> 00:14:31,700
validation by knowing which queries had

00:14:30,170 --> 00:14:34,400
run and therefore replaying those

00:14:31,700 --> 00:14:36,410
against the proposed change in the graph

00:14:34,400 --> 00:14:38,030
and then on top of that you can build a

00:14:36,410 --> 00:14:41,390
lot of workflows not just schema change

00:14:38,030 --> 00:14:42,950
control but access control and some more

00:14:41,390 --> 00:14:46,100
sophisticated stuff at enterprise scale

00:14:42,950 --> 00:14:49,400
around rolling out large changes to two

00:14:46,100 --> 00:14:50,900
graphs with many developers okay we'll

00:14:49,400 --> 00:14:54,050
talk more about this over the course of

00:14:50,900 --> 00:14:57,290
the day what I want to do is look

00:14:54,050 --> 00:14:59,540
forward and set the stage a little bit

00:14:57,290 --> 00:15:02,180
for what you're going to hear from James

00:14:59,540 --> 00:15:03,710
and from Peggy and others over the next

00:15:02,180 --> 00:15:06,200
couple hours so there's two big ideas

00:15:03,710 --> 00:15:10,580
that we've been working on that we want

00:15:06,200 --> 00:15:13,760
to share and have a discussion about the

00:15:10,580 --> 00:15:16,610
first ones Federation so this is about

00:15:13,760 --> 00:15:17,850
architecting a data graph for scale it's

00:15:16,610 --> 00:15:19,620
so important

00:15:17,850 --> 00:15:21,540
well we talked to teams especially

00:15:19,620 --> 00:15:22,890
larger teams that are going down that

00:15:21,540 --> 00:15:24,120
path where they're starting with a small

00:15:22,890 --> 00:15:25,590
graph and they're getting bigger and

00:15:24,120 --> 00:15:28,710
bigger here's the thing we hear over and

00:15:25,590 --> 00:15:30,210
over again they've put something into

00:15:28,710 --> 00:15:32,880
production and it's actually usually

00:15:30,210 --> 00:15:34,020
something pretty important because you

00:15:32,880 --> 00:15:35,610
want to prove the value of the

00:15:34,020 --> 00:15:37,290
technology right away so maybe it's the

00:15:35,610 --> 00:15:39,150
booking page or maybe it's the the

00:15:37,290 --> 00:15:42,900
checkout flow for an e-commerce store

00:15:39,150 --> 00:15:44,730
and the experience has been great and so

00:15:42,900 --> 00:15:47,400
the the goal is now to expand to that

00:15:44,730 --> 00:15:49,680
org-wide data graph because the benefits

00:15:47,400 --> 00:15:54,360
are clear and as I said we're gonna want

00:15:49,680 --> 00:15:55,500
one big one not ten little ones but how

00:15:54,360 --> 00:15:57,000
are you gonna do it right you're not

00:15:55,500 --> 00:15:58,710
gonna have a hundred developers pushing

00:15:57,000 --> 00:16:02,150
code into a node app you need something

00:15:58,710 --> 00:16:04,680
more more scalable something that has

00:16:02,150 --> 00:16:06,570
more reliability more structure more

00:16:04,680 --> 00:16:09,120
process something that allows teams to

00:16:06,570 --> 00:16:10,860
move in an independent way this has been

00:16:09,120 --> 00:16:14,070
a topic in the graphical community for

00:16:10,860 --> 00:16:16,290
years we published a library called

00:16:14,070 --> 00:16:18,210
schema stitching some time ago that was

00:16:16,290 --> 00:16:19,530
one approach to this turns out not to be

00:16:18,210 --> 00:16:22,680
the right approach we'll talk about more

00:16:19,530 --> 00:16:23,880
of that in a moment but for the last six

00:16:22,680 --> 00:16:25,650
months or so we've been working on

00:16:23,880 --> 00:16:28,050
something we're pretty excited about

00:16:25,650 --> 00:16:31,560
called Federation we've been working

00:16:28,050 --> 00:16:34,440
with teams from New York Times Airbnb

00:16:31,560 --> 00:16:37,230
Expedia and other companies on an

00:16:34,440 --> 00:16:38,760
architecture for taking a graph not as a

00:16:37,230 --> 00:16:41,220
monolith but it's something composed

00:16:38,760 --> 00:16:44,820
from parts and it looks something like

00:16:41,220 --> 00:16:46,950
this so that layer that we put inside of

00:16:44,820 --> 00:16:48,660
our environment between our apps and our

00:16:46,950 --> 00:16:49,890
services we're actually going to break

00:16:48,660 --> 00:16:52,820
into two parts with separate

00:16:49,890 --> 00:16:55,530
responsibilities so we're gonna have a

00:16:52,820 --> 00:16:57,570
set of micro services not just one but a

00:16:55,530 --> 00:17:00,480
whole set each of which is responsible

00:16:57,570 --> 00:17:02,010
for defining a portion of the graph we

00:17:00,480 --> 00:17:03,630
might have a product team we might have

00:17:02,010 --> 00:17:05,459
a user accounts team waiter we might

00:17:03,630 --> 00:17:07,589
have a reviews team and this

00:17:05,459 --> 00:17:09,990
architecture is designed to align with

00:17:07,589 --> 00:17:12,300
the teams you already have so you

00:17:09,990 --> 00:17:13,860
probably have micro service owners that

00:17:12,300 --> 00:17:16,439
are responsible for different parts of

00:17:13,860 --> 00:17:18,420
your data ecosystem what we're looking

00:17:16,439 --> 00:17:20,520
for here is an architecture that lets us

00:17:18,420 --> 00:17:22,770
align the data graph with that structure

00:17:20,520 --> 00:17:25,650
so that the experts at each of those

00:17:22,770 --> 00:17:27,710
domains are responsible for their parts

00:17:25,650 --> 00:17:29,760
of the graph the types the fields the

00:17:27,710 --> 00:17:31,320
mutations and such that that are

00:17:29,760 --> 00:17:35,220
specific to that

00:17:31,320 --> 00:17:36,510
and there's a lot of there's some cool

00:17:35,220 --> 00:17:39,510
stuff in here James is going to show you

00:17:36,510 --> 00:17:41,670
a lot of that in a moment the other half

00:17:39,510 --> 00:17:44,040
of the story is a gateway this is your

00:17:41,670 --> 00:17:45,990
shared infrastructure there is no user

00:17:44,040 --> 00:17:48,380
code in this gateway is an important

00:17:45,990 --> 00:17:51,090
part of this design this is where

00:17:48,380 --> 00:17:53,400
centralized management metrics and

00:17:51,090 --> 00:17:55,050
analytics policy enforcement safe

00:17:53,400 --> 00:17:56,520
listing for example the idea that we're

00:17:55,050 --> 00:17:59,130
gonna push a manifest of what's allowed

00:17:56,520 --> 00:18:01,050
and not allowed all that is about the

00:17:59,130 --> 00:18:04,470
graph as a whole so that lives in the

00:18:01,050 --> 00:18:06,600
gateway and so this architecture allows

00:18:04,470 --> 00:18:08,160
you to have a shared piece of

00:18:06,600 --> 00:18:14,640
infrastructure just like you might have

00:18:08,160 --> 00:18:17,670
a shared Kafka deploy right that is the

00:18:14,640 --> 00:18:19,350
foundation of your overall graph but

00:18:17,670 --> 00:18:21,810
then the the actual definition the

00:18:19,350 --> 00:18:24,480
schema is the result of individual teams

00:18:21,810 --> 00:18:27,510
working independently on individual

00:18:24,480 --> 00:18:30,390
graph micro-services and if you pair

00:18:27,510 --> 00:18:31,800
that with the platform the stuff I was

00:18:30,390 --> 00:18:34,920
showing you earlier things like schema

00:18:31,800 --> 00:18:36,500
change validation safe listing and so on

00:18:34,920 --> 00:18:39,750
you end up with something that's really

00:18:36,500 --> 00:18:41,100
really interesting and and the workflow

00:18:39,750 --> 00:18:43,710
might be something like this when the

00:18:41,100 --> 00:18:45,690
product team on its own schedule its own

00:18:43,710 --> 00:18:48,090
sprint cycle wants to make a change to

00:18:45,690 --> 00:18:50,100
their part of the data model they might

00:18:48,090 --> 00:18:51,300
push an update to that product micro

00:18:50,100 --> 00:18:53,760
service that's going to trigger a

00:18:51,300 --> 00:18:55,140
recomputation of the whole graph we're

00:18:53,760 --> 00:18:56,700
gonna validate that by the way so we're

00:18:55,140 --> 00:18:58,650
gonna make sure that that new graph is

00:18:56,700 --> 00:19:00,060
compatible with all the use cases and

00:18:58,650 --> 00:19:03,230
then we're gonna push that into the

00:19:00,060 --> 00:19:06,150
Gateway and now all of the applications

00:19:03,230 --> 00:19:08,100
have the have the new fields or the

00:19:06,150 --> 00:19:10,680
changed part of the graph available to

00:19:08,100 --> 00:19:12,210
them and then maybe a day later or an

00:19:10,680 --> 00:19:14,220
hour later or a month later I don't know

00:19:12,210 --> 00:19:15,930
the user team does the same thing and

00:19:14,220 --> 00:19:18,260
the point is these things are happening

00:19:15,930 --> 00:19:21,300
independently so there's a way to

00:19:18,260 --> 00:19:23,070
operate at this local scale where the

00:19:21,300 --> 00:19:24,540
team is responsible just for its piece

00:19:23,070 --> 00:19:26,670
and you don't have to know about all the

00:19:24,540 --> 00:19:28,110
different parts of the graph that you're

00:19:26,670 --> 00:19:29,490
not responsible for and you don't have

00:19:28,110 --> 00:19:31,110
to know about all the clients or the

00:19:29,490 --> 00:19:33,660
consumers of the graph that are using

00:19:31,110 --> 00:19:36,030
your data not directly anyway you just

00:19:33,660 --> 00:19:38,460
have the structure in place so that as

00:19:36,030 --> 00:19:40,200
you make changes to it those changes are

00:19:38,460 --> 00:19:41,100
validated pushed into production in a

00:19:40,200 --> 00:19:43,080
seamless way

00:19:41,100 --> 00:19:45,480
your gateway flips over from one can

00:19:43,080 --> 00:19:46,500
to the next clients are none the wiser

00:19:45,480 --> 00:19:48,450
because you're always making

00:19:46,500 --> 00:19:49,950
backward-compatible changes or ford

00:19:48,450 --> 00:19:53,520
compatible I should say as you make

00:19:49,950 --> 00:19:55,530
these changes and you end up with the

00:19:53,520 --> 00:19:57,150
holy grail of sorts you have a single

00:19:55,530 --> 00:19:59,700
data graph but a federated

00:19:57,150 --> 00:20:01,290
implementation to that graph so that's

00:19:59,700 --> 00:20:04,950
the first big idea we're going to talk

00:20:01,290 --> 00:20:08,310
about we are releasing in just a couple

00:20:04,950 --> 00:20:09,750
of weeks the implementation of this and

00:20:08,310 --> 00:20:11,670
everything in this picture on the left

00:20:09,750 --> 00:20:16,950
the Gateway and the micro-services is

00:20:11,670 --> 00:20:18,720
all 100% MIT open source I'm told that

00:20:16,950 --> 00:20:20,400
if you come talk to us today we will get

00:20:18,720 --> 00:20:21,930
you an advance copy of that so we do

00:20:20,400 --> 00:20:23,340
have people running this stuff and we'd

00:20:21,930 --> 00:20:26,490
be really excited to get your feedback

00:20:23,340 --> 00:20:27,840
on it and along with that comes a whole

00:20:26,490 --> 00:20:29,640
ton of documentation about the

00:20:27,840 --> 00:20:31,260
programming model and how you describe a

00:20:29,640 --> 00:20:33,960
graph in this way where the two parts

00:20:31,260 --> 00:20:36,000
can be joined as I described so James is

00:20:33,960 --> 00:20:36,870
going to walk through all of that in

00:20:36,000 --> 00:20:39,840
just a minute we'll do that

00:20:36,870 --> 00:20:44,940
interactively please pepper him with

00:20:39,840 --> 00:20:45,450
questions and we'll get you a copy after

00:20:44,940 --> 00:20:49,080
the show

00:20:45,450 --> 00:20:53,490
okay second big idea and I'm really

00:20:49,080 --> 00:20:55,380
excited about this is I think what's

00:20:53,490 --> 00:21:00,200
emerging is a I'll call it a new modern

00:20:55,380 --> 00:21:03,840
stack and if if Federation is about

00:21:00,200 --> 00:21:07,680
graph architecture this idea is about

00:21:03,840 --> 00:21:09,660
using the graph and I think how many

00:21:07,680 --> 00:21:11,790
people here are our product engineer is

00:21:09,660 --> 00:21:14,010
working on react or something like react

00:21:11,790 --> 00:21:16,380
as part of your your role yeah a lot of

00:21:14,010 --> 00:21:18,030
the audience and we typically see graph

00:21:16,380 --> 00:21:19,500
QL as first adopted by product

00:21:18,030 --> 00:21:22,380
engineering teams because the problems

00:21:19,500 --> 00:21:24,690
that solve are so product centric that

00:21:22,380 --> 00:21:29,670
it's it's a it's the fastest way to

00:21:24,690 --> 00:21:32,250
something that's valuable and I think

00:21:29,670 --> 00:21:35,430
everybody knows some of the benefits

00:21:32,250 --> 00:21:37,700
we've seen tooling we've seen you know

00:21:35,430 --> 00:21:39,960
you don't have to write as much code

00:21:37,700 --> 00:21:41,670
maybe fewer bytes on the wire is

00:21:39,960 --> 00:21:44,970
important especially for a lot of teams

00:21:41,670 --> 00:21:46,530
on mobile networks but I think there's a

00:21:44,970 --> 00:21:48,900
lot more to the story that hasn't been

00:21:46,530 --> 00:21:51,390
told yet and one of the things that

00:21:48,900 --> 00:21:53,760
graph QL lets you do is it lets you take

00:21:51,390 --> 00:21:55,170
a unified approach to managing all the

00:21:53,760 --> 00:21:56,730
data in your app not just the data

00:21:55,170 --> 00:21:56,999
coming from the cloud but also the data

00:21:56,730 --> 00:22:00,269
the

00:21:56,999 --> 00:22:03,779
local to your client and I think what's

00:22:00,269 --> 00:22:06,419
emerging is a new stack and to me the

00:22:03,779 --> 00:22:07,799
three legs of the stool are react Apollo

00:22:06,419 --> 00:22:10,889
and typescript

00:22:07,799 --> 00:22:13,289
write a system for managing your your

00:22:10,889 --> 00:22:15,989
user components a system for managing

00:22:13,289 --> 00:22:18,179
your data and a foundation underneath

00:22:15,989 --> 00:22:20,699
that that gives you static typing

00:22:18,179 --> 00:22:22,619
end-to-end through the stack and what we

00:22:20,699 --> 00:22:25,019
want to show you and Peggy is gonna walk

00:22:22,619 --> 00:22:28,079
through some examples of this is how

00:22:25,019 --> 00:22:30,749
productive and how powerful and frankly

00:22:28,079 --> 00:22:33,539
just how fun an environment built on

00:22:30,749 --> 00:22:35,519
these three ideas can be an environment

00:22:33,539 --> 00:22:37,709
where I have a set of reusable

00:22:35,519 --> 00:22:39,929
components I have a way to describe

00:22:37,709 --> 00:22:41,219
their data requirements instead of

00:22:39,929 --> 00:22:42,599
writing all this code I don't need to

00:22:41,219 --> 00:22:44,009
write Redux state management code I

00:22:42,599 --> 00:22:45,779
don't need to write data fetching code

00:22:44,009 --> 00:22:48,959
that calls rest endpoints I just

00:22:45,779 --> 00:22:51,569
describe what it is that I need and a

00:22:48,959 --> 00:22:54,959
type system so that all that stuff is

00:22:51,569 --> 00:22:57,749
governed by build time checks all the

00:22:54,959 --> 00:22:59,429
way from your underlying services all

00:22:57,749 --> 00:23:02,189
the way up through your your UI

00:22:59,429 --> 00:23:04,709
components we found that's a phenomenal

00:23:02,189 --> 00:23:06,299
combination this is what a lot of the

00:23:04,709 --> 00:23:07,469
teams we've worked with our adopting and

00:23:06,299 --> 00:23:09,599
we want to show you some of the really

00:23:07,469 --> 00:23:13,859
exciting benefits of going down that

00:23:09,599 --> 00:23:15,299
path with tooling and and just some of

00:23:13,859 --> 00:23:19,949
the latest and greatest in the in the

00:23:15,299 --> 00:23:21,839
JavaScript ecosystem okay so that's what

00:23:19,949 --> 00:23:25,589
we have we've also got some amazing

00:23:21,839 --> 00:23:27,389
talks from people in the Apollo and the

00:23:25,589 --> 00:23:29,429
graphical community we're really excited

00:23:27,389 --> 00:23:31,619
to share some of these ideas as I said

00:23:29,429 --> 00:23:34,079
the biggest thing here is for us to

00:23:31,619 --> 00:23:37,189
learn from each other so during the

00:23:34,079 --> 00:23:40,949
break after the conversation please do

00:23:37,189 --> 00:23:42,449
chat with us chat with each other as I

00:23:40,949 --> 00:23:44,519
said it's a new technology we're really

00:23:42,449 --> 00:23:46,679
excited it is the right answer I think

00:23:44,519 --> 00:23:48,989
for some of the challenges that product

00:23:46,679 --> 00:23:50,849
teams are facing today and we're gonna

00:23:48,989 --> 00:23:54,779
build it together so thanks very much

00:23:50,849 --> 00:23:57,859
and let me introduce James to talk to us

00:23:54,779 --> 00:23:57,859
about Federation

00:23:58,540 --> 00:24:00,600

YouTube URL: https://www.youtube.com/watch?v=UFdvM9ZoJNo


