Title: DevOps Days Tel Aviv 2013: Ignite: Monitoring Patterns with Riemann - Itai Frenkel & Eli Polonsky
Publication date: 2013-10-24
Playlist: DevOps Days Tel Aviv - September 2013
Description: 
	Riemann aggregates events from your servers and applications with a powerful stream processing language, which enables concise monitoring rule declarations. This 5 minute ignite talk gives a taste of common monitoring pattern implementations: heartbeat, statistics, event enrichment, state based filters, multi-tenant monitoring, and reviews what you can do with Riemann after processing these patterns.

Speakers:

Itai Frenkel and Eli Polonski, GigaSpaces

Eli Polonsky and Itai Frenkel work at GigaSpaces, developing the the Cloudify open source devops and cloud automation suite. Part of their work includes open source devops tool evaluation such as Riemann.
Captions: 
	00:00:09,559 --> 00:00:15,870
so this presentation is a little bit

00:00:12,300 --> 00:00:21,000
different so hang on so it's gonna be a

00:00:15,870 --> 00:00:23,400
nice ride okay so we're gonna talk about

00:00:21,000 --> 00:00:25,019
the monitoring system called Riemann and

00:00:23,400 --> 00:00:27,119
I don't know how many of you heard it

00:00:25,019 --> 00:00:29,609
but if you have then good okay so

00:00:27,119 --> 00:00:31,710
Riemann it's a monitoring system and

00:00:29,609 --> 00:00:35,280
event processor that helps you monitor

00:00:31,710 --> 00:00:37,530
your distributed systems it's if it can

00:00:35,280 --> 00:00:39,480
very easily tell you what broke where

00:00:37,530 --> 00:00:44,730
did it break when did it happen and much

00:00:39,480 --> 00:00:46,559
much more Riemann can accept events from

00:00:44,730 --> 00:00:48,120
multiple sources as you see and can

00:00:46,559 --> 00:00:50,280
propagate them forward to multiple

00:00:48,120 --> 00:00:52,860
outputs you can have log stash to

00:00:50,280 --> 00:00:54,840
monitor your analyze your log files you

00:00:52,860 --> 00:00:56,789
can have collected d plugins to monitor

00:00:54,840 --> 00:00:58,920
your stack and you have a lot of

00:00:56,789 --> 00:01:03,420
language specific clients to monitor

00:00:58,920 --> 00:01:05,549
your application so Chuck Norris handles

00:01:03,420 --> 00:01:08,760
the bad guys the same way women had

00:01:05,549 --> 00:01:10,650
those events first kicks ass then they

00:01:08,760 --> 00:01:13,409
lock him up and then the wait until the

00:01:10,650 --> 00:01:15,119
event expires which has time to leave so

00:01:13,409 --> 00:01:17,880
the interesting part is where you lock

00:01:15,119 --> 00:01:20,220
the events okay so for each service on

00:01:17,880 --> 00:01:23,280
each host we store the last event until

00:01:20,220 --> 00:01:25,560
a new event comes or until it expires

00:01:23,280 --> 00:01:30,509
and now we're going to show you some

00:01:25,560 --> 00:01:32,460
kickass closure code so the first use

00:01:30,509 --> 00:01:34,770
case we're going to see is just a very

00:01:32,460 --> 00:01:36,689
simple liveness detection we have two

00:01:34,770 --> 00:01:38,820
hosts the report heartbeat events

00:01:36,689 --> 00:01:40,979
periodically and at some point in time

00:01:38,820 --> 00:01:43,259
you can see hose to be crashes which

00:01:40,979 --> 00:01:45,540
means its heartbeat stopped because

00:01:43,259 --> 00:01:47,640
every event has a time to live this will

00:01:45,540 --> 00:01:49,170
trigger a man to take some action this

00:01:47,640 --> 00:01:51,360
is how it looks like this is an actual

00:01:49,170 --> 00:01:53,369
closure snippet taken from a riemann

00:01:51,360 --> 00:01:56,340
configuration it's really prayed forward

00:01:53,369 --> 00:01:59,399
when the event with tag keep-alive

00:01:56,340 --> 00:02:00,960
expires just send an email and expired

00:01:59,399 --> 00:02:03,960
is a built-in function designed to

00:02:00,960 --> 00:02:07,170
inspect the time-to-live of an event so

00:02:03,960 --> 00:02:11,039
what this slide says is that if Chuck

00:02:07,170 --> 00:02:13,680
Norris is here Raymond is here ok women

00:02:11,039 --> 00:02:17,549
can do anything you want us to

00:02:13,680 --> 00:02:19,829
quickly trigger based on threshold and

00:02:17,549 --> 00:02:22,319
the code is really simple a function

00:02:19,829 --> 00:02:25,319
that takes a condition predicate and an

00:02:22,319 --> 00:02:27,629
action so if it's a request latency it's

00:02:25,319 --> 00:02:35,430
more than 10 then send you an email

00:02:27,629 --> 00:02:37,500
pretty simple okay this actually causes

00:02:35,430 --> 00:02:39,989
a bunch of emails now to be sent to your

00:02:37,500 --> 00:02:41,909
inbox and pollute your inbox you can

00:02:39,989 --> 00:02:44,340
simply resolve this by having raymond

00:02:41,909 --> 00:02:46,709
react just to state changes so here we

00:02:44,340 --> 00:02:48,900
define that when a metric is bigger than

00:02:46,709 --> 00:02:51,870
10 the state is error and when it's less

00:02:48,900 --> 00:02:54,419
than to the state is ok this is the code

00:02:51,870 --> 00:02:56,700
so then when the services request

00:02:54,419 --> 00:02:59,069
latency and the metric is bigger than 10

00:02:56,700 --> 00:03:01,980
we change the state to error with the

00:02:59,069 --> 00:03:04,739
width function and then when the state

00:03:01,980 --> 00:03:07,250
changes from ok to error again we just

00:03:04,739 --> 00:03:10,500
send an email so this will just send one

00:03:07,250 --> 00:03:14,069
so you know they say Chuck Norris can

00:03:10,500 --> 00:03:19,349
divide by zero so women can every given

00:03:14,069 --> 00:03:21,120
null values so seriously if you have a

00:03:19,349 --> 00:03:23,579
lot of events you want to take some kind

00:03:21,120 --> 00:03:25,229
of median average right and if you have

00:03:23,579 --> 00:03:27,810
a big cluster oh my god so you need to

00:03:25,229 --> 00:03:29,970
group by different hosts then take each

00:03:27,810 --> 00:03:33,900
median or average and then to the maxim

00:03:29,970 --> 00:03:36,720
and of course put them in their jail so

00:03:33,900 --> 00:03:40,379
how does look in code can you gender in

00:03:36,720 --> 00:03:43,590
any other tool so this is it through by

00:03:40,379 --> 00:03:45,989
then only we only interesting request

00:03:43,590 --> 00:03:47,609
latency then choose the percentiles over

00:03:45,989 --> 00:03:49,859
the last minute median call this

00:03:47,609 --> 00:03:56,159
function which just folded the maximum

00:03:49,859 --> 00:03:58,739
into the index that's it works ok this

00:03:56,159 --> 00:04:00,540
is the system described with database

00:03:58,739 --> 00:04:02,069
you can sit here and many web servers

00:04:00,540 --> 00:04:03,720
connected to that database so they hold

00:04:02,069 --> 00:04:06,259
the database connection when this

00:04:03,720 --> 00:04:08,780
database crashes basically every server

00:04:06,259 --> 00:04:11,549
sends out a database connection error

00:04:08,780 --> 00:04:13,470
these errors are all the same we don't

00:04:11,549 --> 00:04:15,959
really need them all you can filter

00:04:13,470 --> 00:04:17,970
these with Riemann by using the throttle

00:04:15,959 --> 00:04:21,150
and the roll up this code will

00:04:17,970 --> 00:04:23,610
eventually at the end result will be two

00:04:21,150 --> 00:04:25,530
emails containing one event at the

00:04:23,610 --> 00:04:27,060
beginning of the hour and now

00:04:25,530 --> 00:04:30,450
ninety-eight event email at the end of

00:04:27,060 --> 00:04:32,430
the hour so this is just a simple

00:04:30,450 --> 00:04:34,050
scenario can out Chuck Norris we just

00:04:32,430 --> 00:04:37,380
want to add a new key value pair to the

00:04:34,050 --> 00:04:39,090
event that's it we have a good reason to

00:04:37,380 --> 00:04:44,010
do it you can do it in any other

00:04:39,090 --> 00:04:46,800
monitoring tool so basically what this

00:04:44,010 --> 00:04:48,990
slide says is that everything chuck

00:04:46,800 --> 00:04:51,810
norris can do women can do better and

00:04:48,990 --> 00:04:53,639
faster okay that's what means you can do

00:04:51,810 --> 00:04:56,070
any custom function you want that does

00:04:53,639 --> 00:05:01,410
basically anything as long as you know

00:04:56,070 --> 00:05:03,330
closure okay so think of a multi-tenant

00:05:01,410 --> 00:05:05,760
environment i'm sure you all use it

00:05:03,330 --> 00:05:07,530
where you need tenant-based isolation

00:05:05,760 --> 00:05:09,990
but you also need an overall view of

00:05:07,530 --> 00:05:12,510
your entire system you can have riemann

00:05:09,990 --> 00:05:15,300
forward each tenant state to a dedicated

00:05:12,510 --> 00:05:17,550
riemann aggregator server this is in

00:05:15,300 --> 00:05:20,640
code so we define the tcp client to

00:05:17,550 --> 00:05:22,979
connect to that aggregator and in each

00:05:20,640 --> 00:05:25,320
tenant server we have it react to state

00:05:22,979 --> 00:05:27,840
changes that we saw before we modify the

00:05:25,320 --> 00:05:29,220
event by adding a tenant key and we

00:05:27,840 --> 00:05:31,530
forwarded it to the rim and aggregator

00:05:29,220 --> 00:05:34,500
which will now store on information on

00:05:31,530 --> 00:05:36,450
all tenants okay so this is riemann the

00:05:34,500 --> 00:05:38,190
website you should check it out see the

00:05:36,450 --> 00:05:40,410
video lecture by Kyle Kingsbury it's

00:05:38,190 --> 00:05:42,750
really really entertaining there is also

00:05:40,410 --> 00:05:46,050
an active community up by a three node

00:05:42,750 --> 00:05:48,440
channel and google groups and just play

00:05:46,050 --> 00:05:48,440
around with it

00:05:50,560 --> 00:05:52,620

YouTube URL: https://www.youtube.com/watch?v=hQYY4PL5HBw


