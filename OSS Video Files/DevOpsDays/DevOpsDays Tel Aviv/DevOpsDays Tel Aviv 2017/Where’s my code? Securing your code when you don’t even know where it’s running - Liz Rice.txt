Title: Where’s my code? Securing your code when you don’t even know where it’s running - Liz Rice
Publication date: 2017-11-29
Playlist: DevOpsDays Tel Aviv 2017
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:12,480
I am based in London but I work for aqua

00:00:08,940 --> 00:00:15,330
who's heard of aqua the show of hands

00:00:12,480 --> 00:00:20,970
okay so aqua our container security

00:00:15,330 --> 00:00:22,439
company based here in Tel Aviv and we

00:00:20,970 --> 00:00:25,830
help enterprises secure their

00:00:22,439 --> 00:00:27,029
containerized deployments and this

00:00:25,830 --> 00:00:31,130
morning I'm going to talk a bit more

00:00:27,029 --> 00:00:33,870
generally about securing your code

00:00:31,130 --> 00:00:35,040
potentially using tools like Accra but a

00:00:33,870 --> 00:00:37,440
lot of things I'm going to talk about

00:00:35,040 --> 00:00:41,640
can be done with open source tools as

00:00:37,440 --> 00:00:45,390
well so securing your code when you

00:00:41,640 --> 00:00:48,000
don't know where it is a bit of a

00:00:45,390 --> 00:00:50,070
history lesson anybody here remember the

00:00:48,000 --> 00:00:53,520
days when we used to actually go and buy

00:00:50,070 --> 00:00:56,699
physical Hardware for ourselves few

00:00:53,520 --> 00:00:58,859
hands anybody's still doing that yeah if

00:00:56,699 --> 00:01:01,289
you if you are still doing that so you

00:00:58,859 --> 00:01:02,910
guys you know exactly where your code is

00:01:01,289 --> 00:01:05,970
running because you bought the physical

00:01:02,910 --> 00:01:10,500
machine and you know where it is for

00:01:05,970 --> 00:01:14,070
many of us maybe a decade ago or so we

00:01:10,500 --> 00:01:20,549
started moving to the cloud we started

00:01:14,070 --> 00:01:23,130
using things like AWS or as you and we

00:01:20,549 --> 00:01:28,220
no longer knew exactly where our code

00:01:23,130 --> 00:01:31,650
would be with no it's us East or Europe

00:01:28,220 --> 00:01:33,780
West we might have a rough idea you know

00:01:31,650 --> 00:01:36,540
oh us East that's Virginia but we don't

00:01:33,780 --> 00:01:37,590
know where the physical data center is

00:01:36,540 --> 00:01:39,450
we're certainly not going to be allowed

00:01:37,590 --> 00:01:44,040
to get in and look at the Machine

00:01:39,450 --> 00:01:46,110
anymore but you can still address those

00:01:44,040 --> 00:01:48,960
machines individually you get an

00:01:46,110 --> 00:01:50,220
identifier for each of those virtual

00:01:48,960 --> 00:01:53,490
machines that you're going to be running

00:01:50,220 --> 00:01:56,640
your code on so you still have a pretty

00:01:53,490 --> 00:01:58,950
good idea where each individual part of

00:01:56,640 --> 00:02:01,880
your application is in terms of which

00:01:58,950 --> 00:02:04,700
virtual machine is on

00:02:01,880 --> 00:02:07,009
and this is a massive oversimplification

00:02:04,700 --> 00:02:09,890
but the kind of process we would use

00:02:07,009 --> 00:02:12,620
would be a development team would write

00:02:09,890 --> 00:02:15,560
some code some ops people would

00:02:12,620 --> 00:02:17,060
provision servers the code would get

00:02:15,560 --> 00:02:18,620
deployed onto those servers and we

00:02:17,060 --> 00:02:20,510
wouldn't do that very often because it

00:02:18,620 --> 00:02:25,190
would be pretty you know scary and

00:02:20,510 --> 00:02:27,700
painful and things could go wrong and in

00:02:25,190 --> 00:02:31,459
between our sort of software release

00:02:27,700 --> 00:02:34,250
schedule security things might happen

00:02:31,459 --> 00:02:36,980
new vulnerabilities might get discovered

00:02:34,250 --> 00:02:39,739
and we would have to go and patch our

00:02:36,980 --> 00:02:44,480
servers to bring them up to speed with

00:02:39,739 --> 00:02:48,080
those new patches that had been found so

00:02:44,480 --> 00:02:51,230
over time the state of our servers would

00:02:48,080 --> 00:02:55,910
kind of drift away from what it was

00:02:51,230 --> 00:02:57,620
originally intended to be and a lot of

00:02:55,910 --> 00:02:59,930
those changes a lot of that drift would

00:02:57,620 --> 00:03:03,069
be deliberate it was because of security

00:02:59,930 --> 00:03:05,299
patches but you know this human

00:03:03,069 --> 00:03:08,600
intervention here this is people often

00:03:05,299 --> 00:03:10,430
SSH into machines and they don't always

00:03:08,600 --> 00:03:13,640
get it a hundred percent right or they

00:03:10,430 --> 00:03:15,950
might miss one of the servers or just

00:03:13,640 --> 00:03:20,690
something would happen that would mean

00:03:15,950 --> 00:03:22,310
you didn't know exactly what state some

00:03:20,690 --> 00:03:25,519
of those servers were in or it would be

00:03:22,310 --> 00:03:27,829
very easy to get to a position where you

00:03:25,519 --> 00:03:32,060
couldn't really recreate the exact state

00:03:27,829 --> 00:03:34,880
of those servers and then DevOps

00:03:32,060 --> 00:03:37,519
happened with apologies to all the

00:03:34,880 --> 00:03:40,310
people whose logos I've left out we

00:03:37,519 --> 00:03:42,049
started to think about encoding

00:03:40,310 --> 00:03:44,150
everything we're doing encoding our

00:03:42,049 --> 00:03:47,090
servers encoding everything about our

00:03:44,150 --> 00:03:50,000
deployment as code so that we can

00:03:47,090 --> 00:03:52,730
reproduce it we started putting our

00:03:50,000 --> 00:03:55,340
software into containers docker have

00:03:52,730 --> 00:03:58,780
their catchphrase of it build once and

00:03:55,340 --> 00:04:01,430
deploy everywhere or run everywhere so

00:03:58,780 --> 00:04:04,389
and we've used CI CD pipelines to

00:04:01,430 --> 00:04:07,299
automate everything so we're no longer

00:04:04,389 --> 00:04:10,250
manually getting into machines we're

00:04:07,299 --> 00:04:13,720
automating the whole process we've got a

00:04:10,250 --> 00:04:16,840
whole bunch of tools to help us get our

00:04:13,720 --> 00:04:19,170
software and our servers into a state

00:04:16,840 --> 00:04:20,980
that we have predefined through

00:04:19,170 --> 00:04:23,380
infrastructure as code through

00:04:20,980 --> 00:04:28,360
automating processes through CI CD

00:04:23,380 --> 00:04:30,270
pipelines who's heard of the term cattle

00:04:28,360 --> 00:04:32,950
not pets

00:04:30,270 --> 00:04:34,720
okay so quite a few have heard of this

00:04:32,950 --> 00:04:38,950
term cattle not pets I just love this

00:04:34,720 --> 00:04:42,850
little if it's great so the idea of

00:04:38,950 --> 00:04:45,930
cattle not pets is well suppose you have

00:04:42,850 --> 00:04:48,040
a herd of got any farmers in the room

00:04:45,930 --> 00:04:48,910
there are like there were two of the

00:04:48,040 --> 00:04:51,660
back excellent

00:04:48,910 --> 00:04:54,280
right so suppose you have a herd of cows

00:04:51,660 --> 00:04:56,050
I'm sure if you're an expert and if you

00:04:54,280 --> 00:04:59,020
get close up enough to a cow you can

00:04:56,050 --> 00:05:01,000
tell one cow from another but from a

00:04:59,020 --> 00:05:04,150
distance they all kind of look the same

00:05:01,000 --> 00:05:05,560
and you have a herd of them and the

00:05:04,150 --> 00:05:07,780
important thing is more the kind of

00:05:05,560 --> 00:05:10,600
collective herd rather than the

00:05:07,780 --> 00:05:13,330
individual cows in it and if something

00:05:10,600 --> 00:05:16,660
sort of terrible before one of your cows

00:05:13,330 --> 00:05:19,419
you think get terribly upset and you

00:05:16,660 --> 00:05:21,960
just get a new one whereas obviously if

00:05:19,419 --> 00:05:24,340
you have a pet who has a cat or a dog

00:05:21,960 --> 00:05:26,560
yeah so quite a few of you have a cat or

00:05:24,340 --> 00:05:30,130
a dog I'm sure you would be devastated

00:05:26,560 --> 00:05:32,320
if your cat or dog were to you know

00:05:30,130 --> 00:05:34,990
something terrible what happened to it

00:05:32,320 --> 00:05:37,600
so the idea of cattle not pets when we

00:05:34,990 --> 00:05:39,669
think about um software when we think

00:05:37,600 --> 00:05:41,500
about deployments is you should be

00:05:39,669 --> 00:05:45,550
treating your servers you should be

00:05:41,500 --> 00:05:48,130
treating your containers like cattle you

00:05:45,550 --> 00:05:50,260
want uncertain number of them to be up

00:05:48,130 --> 00:05:52,840
and running about the fields but you

00:05:50,260 --> 00:05:55,300
don't necessarily care if an individual

00:05:52,840 --> 00:05:57,520
one dies you just get a new one so you

00:05:55,300 --> 00:06:00,190
replace your servers and ideally because

00:05:57,520 --> 00:06:01,690
we've got automation we can replace our

00:06:00,190 --> 00:06:06,520
servers and we can replace our

00:06:01,690 --> 00:06:09,130
containers automatically so we have this

00:06:06,520 --> 00:06:12,640
pipeline process these days again super

00:06:09,130 --> 00:06:16,870
super simplified model but we start by

00:06:12,640 --> 00:06:19,510
writing software we in the same sense we

00:06:16,870 --> 00:06:23,440
also write scripts for provisioning our

00:06:19,510 --> 00:06:25,630
servers we build images and we deploy

00:06:23,440 --> 00:06:28,120
those images and whenever anything needs

00:06:25,630 --> 00:06:30,940
to change we come back to the beginning

00:06:28,120 --> 00:06:33,880
of the pipeline what does this mean for

00:06:30,940 --> 00:06:36,550
security and essentially it is something

00:06:33,880 --> 00:06:38,950
that worries people so note I did a

00:06:36,550 --> 00:06:43,900
survey earlier this year def sec ops

00:06:38,950 --> 00:06:46,539
survey and a vast majority 88% said that

00:06:43,900 --> 00:06:49,479
they were concerned about security when

00:06:46,539 --> 00:06:51,130
deploying containers and it's really not

00:06:49,479 --> 00:06:53,560
that surprising when you think about the

00:06:51,130 --> 00:06:58,990
challenge that containerization brings

00:06:53,560 --> 00:07:00,850
to security so we now use orchestrators

00:06:58,990 --> 00:07:03,190
we might be using things like docker we

00:07:00,850 --> 00:07:08,260
might be using cuban Etsy's hands up if

00:07:03,190 --> 00:07:13,270
you are using kubernetes okay yes in

00:07:08,260 --> 00:07:14,590
production okay a few and can I also see

00:07:13,270 --> 00:07:17,610
a show of hands if you're using an

00:07:14,590 --> 00:07:21,370
Orchestrator that is not kubernetes Oh

00:07:17,610 --> 00:07:25,300
quite a lot of nomads yeah yeah and any

00:07:21,370 --> 00:07:28,419
me sauce mesosphere uses docker swarm

00:07:25,300 --> 00:07:32,950
users okay this is there must be some

00:07:28,419 --> 00:07:36,460
other four ec is yes yeah a few CS what

00:07:32,950 --> 00:07:38,020
what else who what else did you open

00:07:36,460 --> 00:07:40,930
shift okay I'll go in account open shift

00:07:38,020 --> 00:07:43,300
is kubernetes but sir okay that's just

00:07:40,930 --> 00:07:46,330
from my interest say we have these

00:07:43,300 --> 00:07:48,789
orchestrators and they are responsible

00:07:46,330 --> 00:07:52,090
for putting code somewhere in our

00:07:48,789 --> 00:07:54,610
deployment so we don't necessarily know

00:07:52,090 --> 00:07:57,550
where any individual piece of code is

00:07:54,610 --> 00:08:00,550
going to land it's gonna be somewhere in

00:07:57,550 --> 00:08:01,660
this cluster of virtual machines we

00:08:00,550 --> 00:08:03,490
don't know where the virtual machines

00:08:01,660 --> 00:08:05,200
are and we certainly don't really know

00:08:03,490 --> 00:08:11,349
which one's going to get picked for any

00:08:05,200 --> 00:08:15,180
given bit of our application and it's

00:08:11,349 --> 00:08:17,440
pretty typical for an enterprise to have

00:08:15,180 --> 00:08:21,070
hundreds of micro services that their

00:08:17,440 --> 00:08:24,630
container izing and each of those micro

00:08:21,070 --> 00:08:27,160
services could have you know dozens of

00:08:24,630 --> 00:08:30,000
instances of containers running so there

00:08:27,160 --> 00:08:33,360
could be thousands of containers and

00:08:30,000 --> 00:08:37,440
those containers don't last very long

00:08:33,360 --> 00:08:39,899
data dog did some analysis of

00:08:37,440 --> 00:08:43,350
data that they had collected from

00:08:39,899 --> 00:08:45,459
containers in production and they

00:08:43,350 --> 00:08:47,140
they're saying that if you have

00:08:45,459 --> 00:08:49,510
containers in production under

00:08:47,140 --> 00:08:52,750
orchestration the average lifetime is

00:08:49,510 --> 00:08:55,480
only just a bit over a couple of days so

00:08:52,750 --> 00:08:57,910
this is all a pretty moving target

00:08:55,480 --> 00:09:00,070
you've got this amorphous cluster with

00:08:57,910 --> 00:09:03,870
software that keeps changing and keeps

00:09:00,070 --> 00:09:07,390
moving from one server to another which

00:09:03,870 --> 00:09:10,450
and inside each of those containers you

00:09:07,390 --> 00:09:14,740
potentially have essentially a Linux

00:09:10,450 --> 00:09:16,810
distribution so that's a lot of

00:09:14,740 --> 00:09:19,959
different places for dependencies to

00:09:16,810 --> 00:09:25,899
exist and you don't necessarily know

00:09:19,959 --> 00:09:27,790
where those dependencies are so how are

00:09:25,899 --> 00:09:31,300
you supposed to patch those containers

00:09:27,790 --> 00:09:33,010
we used to SSH in and apply patches but

00:09:31,300 --> 00:09:34,600
how on earth can you be expected to do

00:09:33,010 --> 00:09:36,610
that when there are thousands of the

00:09:34,600 --> 00:09:40,060
things and you don't even know which

00:09:36,610 --> 00:09:43,120
machines that are on and the answer is

00:09:40,060 --> 00:09:47,470
of course you do not patch containers

00:09:43,120 --> 00:09:50,430
you don't patch container images instead

00:09:47,470 --> 00:09:52,959
we use the process that we've been

00:09:50,430 --> 00:09:56,320
talking about all along we use that

00:09:52,959 --> 00:10:00,459
pipeline process to help us get patches

00:09:56,320 --> 00:10:02,800
into place this pipeline is supposed to

00:10:00,459 --> 00:10:04,690
be a pipeline it is supposed to start at

00:10:02,800 --> 00:10:06,279
the beginning and move all the way to

00:10:04,690 --> 00:10:10,029
the end you always move in the same

00:10:06,279 --> 00:10:12,130
direction and that's exactly the same if

00:10:10,029 --> 00:10:16,769
you're talking about applying changes

00:10:12,130 --> 00:10:19,329
that relate to security patches we build

00:10:16,769 --> 00:10:23,170
images we build container images and

00:10:19,329 --> 00:10:26,709
they are immutable if you want to add a

00:10:23,170 --> 00:10:29,320
new a new update into a container image

00:10:26,709 --> 00:10:30,899
you build a new one you never change an

00:10:29,320 --> 00:10:33,519
existing one

00:10:30,899 --> 00:10:36,550
we run containers based on those

00:10:33,519 --> 00:10:38,589
container images but we never modify

00:10:36,550 --> 00:10:40,300
those running containers if you want to

00:10:38,589 --> 00:10:43,839
change the software that's inside a

00:10:40,300 --> 00:10:45,850
container you modify the image and

00:10:43,839 --> 00:10:47,640
redeploy so you always start at the

00:10:45,850 --> 00:10:50,210
beginning of the pipeline

00:10:47,640 --> 00:10:54,440
and follow it through to its conclusion

00:10:50,210 --> 00:10:57,900
and by doing that it allows us to add

00:10:54,440 --> 00:11:00,420
lots of automation for things like

00:10:57,900 --> 00:11:03,840
security into the process we might be

00:11:00,420 --> 00:11:04,980
adding testing into the pipeline process

00:11:03,840 --> 00:11:07,890
it's obviously not just all about

00:11:04,980 --> 00:11:10,710
building its building and testing but

00:11:07,890 --> 00:11:11,580
those tests can include tests related to

00:11:10,710 --> 00:11:15,120
security

00:11:11,580 --> 00:11:18,870
they can include integration of tools

00:11:15,120 --> 00:11:22,170
that help us with security for example

00:11:18,870 --> 00:11:25,110
vulnerability scanning there are lots of

00:11:22,170 --> 00:11:28,010
different tools things like a choir but

00:11:25,110 --> 00:11:34,020
also some open source options like way

00:11:28,010 --> 00:11:35,610
that will scan your images and look at

00:11:34,020 --> 00:11:37,470
what basically compare them against a

00:11:35,610 --> 00:11:40,020
database of known vulnerabilities and

00:11:37,470 --> 00:11:42,680
let you know if there are any

00:11:40,020 --> 00:11:46,410
vulnerabilities inside that image you

00:11:42,680 --> 00:11:49,050
might want to be scanning your base

00:11:46,410 --> 00:11:50,850
images that you've taken from a third

00:11:49,050 --> 00:11:53,850
party who takes base images from the

00:11:50,850 --> 00:11:56,220
Internet of course you do because they

00:11:53,850 --> 00:11:59,520
you know like where else are you going

00:11:56,220 --> 00:12:01,290
to get your kind of base image for you

00:11:59,520 --> 00:12:03,120
know cooler OS or whatever scratch

00:12:01,290 --> 00:12:07,770
that's a good good place to start I'll

00:12:03,120 --> 00:12:09,570
come to that obviously you don't have to

00:12:07,770 --> 00:12:11,970
get your base images from the open

00:12:09,570 --> 00:12:14,850
Internet but many of us are because

00:12:11,970 --> 00:12:17,880
we're using you know particular language

00:12:14,850 --> 00:12:21,630
distributions and if we're pulling

00:12:17,880 --> 00:12:22,740
images from let's say docker hub we want

00:12:21,630 --> 00:12:24,420
to know that those don't have

00:12:22,740 --> 00:12:26,820
vulnerabilities in them so it's a very

00:12:24,420 --> 00:12:29,270
good idea to integrate some kind of

00:12:26,820 --> 00:12:32,190
vulnerability scanning into the process

00:12:29,270 --> 00:12:34,770
we also want to scan images that we

00:12:32,190 --> 00:12:37,860
built ourselves we could very easily be

00:12:34,770 --> 00:12:40,380
putting dependencies in that could have

00:12:37,860 --> 00:12:46,290
problems we want to scan for those

00:12:40,380 --> 00:12:48,510
problems as well and it's a good idea to

00:12:46,290 --> 00:12:51,260
have some kind of tooling that can tell

00:12:48,510 --> 00:12:53,040
us or all that software that's deployed

00:12:51,260 --> 00:12:55,589
does it

00:12:53,040 --> 00:12:58,410
have any of these vulnerabilities so we

00:12:55,589 --> 00:13:00,300
want to be able to use automation to

00:12:58,410 --> 00:13:02,130
tell us okay

00:13:00,300 --> 00:13:04,050
a new vulnerability has been found and

00:13:02,130 --> 00:13:07,079
it affects these particular container

00:13:04,050 --> 00:13:09,120
images so that we know we can take the

00:13:07,079 --> 00:13:11,339
patch for that vulnerability we can

00:13:09,120 --> 00:13:15,029
rebuild the affected images we can

00:13:11,339 --> 00:13:17,880
redeploy so the result of vulnerability

00:13:15,029 --> 00:13:19,620
scanning is hmm yeah you need to do a

00:13:17,880 --> 00:13:21,620
rebuild for these particular images

00:13:19,620 --> 00:13:23,910
because there is a new patch available

00:13:21,620 --> 00:13:27,269
you might also want to build into your

00:13:23,910 --> 00:13:31,800
pipeline other kinds of image policy

00:13:27,269 --> 00:13:33,569
checks again this is a sort of thing

00:13:31,800 --> 00:13:35,880
that tools like a quad can help you with

00:13:33,569 --> 00:13:38,569
but you can also use other open-source

00:13:35,880 --> 00:13:43,380
tooling for example the kubernetes

00:13:38,569 --> 00:13:45,600
admission control checks you might want

00:13:43,380 --> 00:13:48,000
to be testing for things like do my

00:13:45,600 --> 00:13:49,470
container images require running as root

00:13:48,000 --> 00:13:53,970
because it would be better if they

00:13:49,470 --> 00:13:57,269
didn't because privileges you might want

00:13:53,970 --> 00:14:00,000
to have policies around what base image

00:13:57,269 --> 00:14:01,350
was used for your set of images that

00:14:00,000 --> 00:14:03,600
you're going to deploy in a lot of

00:14:01,350 --> 00:14:07,740
organizations there's an agreement

00:14:03,600 --> 00:14:11,730
between security ops and development

00:14:07,740 --> 00:14:14,010
teams around a base image or set of base

00:14:11,730 --> 00:14:15,690
images maybe you know here's a base

00:14:14,010 --> 00:14:16,889
image we're going to use for Python and

00:14:15,690 --> 00:14:19,800
this is the base image we're going to

00:14:16,889 --> 00:14:24,690
use for Java so that we're starting from

00:14:19,800 --> 00:14:26,639
a known known starting point and the

00:14:24,690 --> 00:14:29,250
security team can have a good view on

00:14:26,639 --> 00:14:32,970
what's being allowed into those base

00:14:29,250 --> 00:14:35,819
images and then you can use image policy

00:14:32,970 --> 00:14:37,410
checks to make sure that the images

00:14:35,819 --> 00:14:39,449
you're building and then the images

00:14:37,410 --> 00:14:43,410
you're deploying actually meet those

00:14:39,449 --> 00:14:45,600
kind of policy requirements so again

00:14:43,410 --> 00:14:48,269
automation is your friend automation is

00:14:45,600 --> 00:14:50,790
helping you and if anything doesn't meet

00:14:48,269 --> 00:14:53,189
your policy checks by putting into the

00:14:50,790 --> 00:14:54,870
pipeline the development teams can know

00:14:53,189 --> 00:14:55,709
about it early on and they can fix it

00:14:54,870 --> 00:14:58,089
earlier

00:14:55,709 --> 00:15:02,800
rather than waiting until a problem

00:14:58,089 --> 00:15:04,540
actually happens in the field so we've

00:15:02,800 --> 00:15:07,959
talked a bit about how the pipeline can

00:15:04,540 --> 00:15:11,889
help you make sure your container images

00:15:07,959 --> 00:15:17,320
don't contain known vulnerabilities but

00:15:11,889 --> 00:15:20,139
what about the hosts that those those

00:15:17,320 --> 00:15:22,269
containers are actually running on so

00:15:20,139 --> 00:15:24,459
one thing you can do now that you don't

00:15:22,269 --> 00:15:26,620
you if we've just run in containers on

00:15:24,459 --> 00:15:29,699
each survey you don't have to be running

00:15:26,620 --> 00:15:32,230
an all-purpose all-singing all-dancing

00:15:29,699 --> 00:15:36,250
distribution on those servers or on

00:15:32,230 --> 00:15:38,820
those v-- ends all you need is what is

00:15:36,250 --> 00:15:41,320
required and sufficient for your

00:15:38,820 --> 00:15:43,839
container engine and your orchestration

00:15:41,320 --> 00:15:48,120
platform to work and supporting things

00:15:43,839 --> 00:15:50,860
like logging monitoring there are some

00:15:48,120 --> 00:15:52,360
operating system distributions that are

00:15:50,860 --> 00:15:56,079
specifically designed to help you with

00:15:52,360 --> 00:15:59,680
this things like core OS Red Hat's

00:15:56,079 --> 00:16:01,420
Project atomic rancher they're all

00:15:59,680 --> 00:16:04,180
examples of operating systems that have

00:16:01,420 --> 00:16:06,160
had some stuff removed because the

00:16:04,180 --> 00:16:08,470
smaller the operating system the smaller

00:16:06,160 --> 00:16:10,800
the attack surface so you might want to

00:16:08,470 --> 00:16:16,480
think about using one of those dedicated

00:16:10,800 --> 00:16:20,829
host devices we can use automation again

00:16:16,480 --> 00:16:22,839
to help us with host security I'm

00:16:20,829 --> 00:16:25,209
particularly thinking here about things

00:16:22,839 --> 00:16:27,760
like the benchmarks from the center for

00:16:25,209 --> 00:16:30,579
internet security they have some

00:16:27,760 --> 00:16:33,790
benchmarks for docker and also for

00:16:30,579 --> 00:16:35,519
kubernetes I was actually involved in a

00:16:33,790 --> 00:16:38,949
little bit of the updates for the latest

00:16:35,519 --> 00:16:44,350
kubernetes benchmark and those

00:16:38,949 --> 00:16:46,959
benchmarks have hundreds of tests or

00:16:44,350 --> 00:16:49,600
benchmarks if you like that describe the

00:16:46,959 --> 00:16:51,520
best practice for various configuration

00:16:49,600 --> 00:16:54,250
settings so

00:16:51,520 --> 00:16:56,920
essentially you test your hosts against

00:16:54,250 --> 00:16:59,500
these benchmarks and it tells you have

00:16:56,920 --> 00:17:04,500
you used best practices in terms of

00:16:59,500 --> 00:17:04,500
things like encryption settings or

00:17:05,760 --> 00:17:13,060
configuration settings that could affect

00:17:09,010 --> 00:17:15,010
your security stance so by automating

00:17:13,060 --> 00:17:17,080
those tests and running those tests

00:17:15,010 --> 00:17:20,500
regularly on your hosts you can see

00:17:17,080 --> 00:17:22,450
whether or not your hosts are complying

00:17:20,500 --> 00:17:24,970
with best practices and if they're not

00:17:22,450 --> 00:17:26,530
maybe you have good reasons for those

00:17:24,970 --> 00:17:27,459
particular settings but at least you

00:17:26,530 --> 00:17:30,970
know about it

00:17:27,459 --> 00:17:33,640
through automated testing another thing

00:17:30,970 --> 00:17:37,120
that you can do through the power of

00:17:33,640 --> 00:17:40,540
automation is recycle these servers I

00:17:37,120 --> 00:17:42,490
think this is a really powerful idea you

00:17:40,540 --> 00:17:48,060
know I showed that graph before a server

00:17:42,490 --> 00:17:51,400
drift because we're able to recreate

00:17:48,060 --> 00:17:54,280
servers through code infrastructure as

00:17:51,400 --> 00:17:58,030
code all those marvelous automation

00:17:54,280 --> 00:18:01,780
tools it should be easy to rebuild new

00:17:58,030 --> 00:18:06,790
servers so why not do that do that on a

00:18:01,780 --> 00:18:09,340
regular basis recycle the hosts on some

00:18:06,790 --> 00:18:11,710
kind of regular schedule this helps you

00:18:09,340 --> 00:18:14,680
for two reasons one is if for some

00:18:11,710 --> 00:18:17,260
reason your server has drifted away from

00:18:14,680 --> 00:18:20,190
its original design configuration

00:18:17,260 --> 00:18:24,070
perhaps because somebody has attacked it

00:18:20,190 --> 00:18:25,840
well you can't by restarting it you've

00:18:24,070 --> 00:18:29,050
pulled the rug out from underneath that

00:18:25,840 --> 00:18:34,440
attackers feet you've reset it to its

00:18:29,050 --> 00:18:38,080
desired State the other thing that is

00:18:34,440 --> 00:18:40,420
beneficial is it's like a fire drill you

00:18:38,080 --> 00:18:42,310
have tested and you are testing on a

00:18:40,420 --> 00:18:44,860
regular basis what happens if you

00:18:42,310 --> 00:18:47,650
destroy a server and recreate it so

00:18:44,860 --> 00:18:49,480
knowing that that can happen

00:18:47,650 --> 00:18:51,850
in your sort of normal day-to-day

00:18:49,480 --> 00:18:54,700
production it means that if you have an

00:18:51,850 --> 00:18:57,580
emergency you know that your processes

00:18:54,700 --> 00:19:01,289
work already it's all about treating

00:18:57,580 --> 00:19:05,020
your servers as cattle and not pets

00:19:01,289 --> 00:19:07,690
there's a good blog post by Diego Monica

00:19:05,020 --> 00:19:09,880
from docker that talks about a concept

00:19:07,690 --> 00:19:13,840
of reverse uptime which is essentially

00:19:09,880 --> 00:19:16,510
this idea of measuring how long your

00:19:13,840 --> 00:19:20,440
hosts are actually up for and having

00:19:16,510 --> 00:19:22,630
some target for the maximum of that that

00:19:20,440 --> 00:19:25,740
you want it you don't want your loads to

00:19:22,630 --> 00:19:30,240
last for longer than a particular metric

00:19:25,740 --> 00:19:30,240
precisely because of this recycling idea

00:19:31,529 --> 00:19:38,850
there's no reason why you can't also use

00:19:34,659 --> 00:19:43,090
your existing security tools on your

00:19:38,850 --> 00:19:44,200
containerized deployments in fact

00:19:43,090 --> 00:19:47,740
there's an argument that says that

00:19:44,200 --> 00:19:50,200
intrusion detection can work better on a

00:19:47,740 --> 00:19:54,250
container deployment than on a sort of

00:19:50,200 --> 00:19:56,559
traditional deployment because they work

00:19:54,250 --> 00:19:59,590
by looking at changes in the file system

00:19:56,559 --> 00:20:02,500
and if you're running containers on a

00:19:59,590 --> 00:20:05,559
node the containerized code is in a

00:20:02,500 --> 00:20:07,960
particular part of the file system so

00:20:05,559 --> 00:20:10,470
changes in the rest of the file system

00:20:07,960 --> 00:20:13,690
anything kind of weird and unusual

00:20:10,470 --> 00:20:16,570
possibly an exploit happening they

00:20:13,690 --> 00:20:20,590
should be easier to detect because we

00:20:16,570 --> 00:20:22,299
should have much fewer reasons for for

00:20:20,590 --> 00:20:24,159
example for individuals to login there

00:20:22,299 --> 00:20:29,350
are no real reasons for individuals to

00:20:24,159 --> 00:20:31,090
log into these cattle nodes so our

00:20:29,350 --> 00:20:34,929
existing tooling can work more

00:20:31,090 --> 00:20:37,860
effectively in these environments and

00:20:34,929 --> 00:20:40,320
then there are some things that are

00:20:37,860 --> 00:20:44,139
characteristics of containers themselves

00:20:40,320 --> 00:20:47,059
that can help us with security

00:20:44,139 --> 00:20:50,179
so the first one of these is the idea of

00:20:47,059 --> 00:20:52,219
reducing images and I've got a little

00:20:50,179 --> 00:20:54,469
one of the things I've got running on

00:20:52,219 --> 00:20:56,779
here is a very small web server called

00:20:54,469 --> 00:21:00,949
hello these are both windows into the

00:20:56,779 --> 00:21:04,119
same virtual machine and if I go to that

00:21:00,949 --> 00:21:08,749
it's it's 81 I think it's on no it's not

00:21:04,119 --> 00:21:11,509
3 276 mate never get so there is a web

00:21:08,749 --> 00:21:22,669
server very simple bit of code running

00:21:11,509 --> 00:21:29,239
there you're all awake now can only exec

00:21:22,669 --> 00:21:33,319
into that container image so suppose

00:21:29,239 --> 00:21:36,049
that I what's called it's called hello

00:21:33,319 --> 00:21:41,539
suppose if I try to run a shell into

00:21:36,049 --> 00:21:44,509
that running container I can't do it

00:21:41,539 --> 00:21:46,940
because there is no shell inside that

00:21:44,509 --> 00:21:48,559
container now if I was an attacker the

00:21:46,940 --> 00:21:50,959
fact that I don't have a shell is going

00:21:48,559 --> 00:21:52,119
to make it a heck of a lot harder for me

00:21:50,959 --> 00:21:54,949
to do anything

00:21:52,119 --> 00:21:59,089
attack e with that particular container

00:21:54,949 --> 00:22:02,179
and the reason why I can't shell into it

00:21:59,089 --> 00:22:04,759
why there is no shell is because I built

00:22:02,179 --> 00:22:07,609
that as a super super small image based

00:22:04,759 --> 00:22:09,979
on the scratch image scratch is

00:22:07,609 --> 00:22:13,099
literally nothing there is nothing in

00:22:09,979 --> 00:22:17,509
the file system except what I copied in

00:22:13,099 --> 00:22:20,259
myself which was a Hello binary and some

00:22:17,509 --> 00:22:20,259
template files

00:22:20,530 --> 00:22:25,780
that isn't going to be suitable for

00:22:22,480 --> 00:22:27,070
everybody not everybody is in a position

00:22:25,780 --> 00:22:28,810
particularly if you've got legacy code

00:22:27,070 --> 00:22:31,960
and depending on the languages you're

00:22:28,810 --> 00:22:36,250
running with you can't necessarily just

00:22:31,960 --> 00:22:40,000
use a standalone binary executable in

00:22:36,250 --> 00:22:41,680
all your container images but the point

00:22:40,000 --> 00:22:45,700
here is to illustrate that the smaller

00:22:41,680 --> 00:22:47,650
you can make the containerized code the

00:22:45,700 --> 00:22:50,740
the less code there is in there the

00:22:47,650 --> 00:22:52,900
fewer tools you put in there the less

00:22:50,740 --> 00:22:56,770
useful that particular container will be

00:22:52,900 --> 00:23:00,490
should somebody manage to somehow get

00:22:56,770 --> 00:23:03,550
inside it reducing the attack surface is

00:23:00,490 --> 00:23:06,520
a very good thing it also has a whole

00:23:03,550 --> 00:23:08,920
bunch of other benefits around you know

00:23:06,520 --> 00:23:12,130
it being a smaller image it being easier

00:23:08,920 --> 00:23:14,560
to pull all sorts of good things also

00:23:12,130 --> 00:23:17,860
there clearly can't be as many

00:23:14,560 --> 00:23:24,760
vulnerabilities in an image that doesn't

00:23:17,860 --> 00:23:26,650
contain libraries dependencies another

00:23:24,760 --> 00:23:31,210
benefit that we get out of micro

00:23:26,650 --> 00:23:33,220
services and containerized code is that

00:23:31,210 --> 00:23:35,830
we no longer have like one great big

00:23:33,220 --> 00:23:39,610
monolith we have these isolated pieces

00:23:35,830 --> 00:23:41,530
of code and we can reason about which

00:23:39,610 --> 00:23:47,560
bits of code should talk to each other

00:23:41,530 --> 00:23:49,600
and then we can use tools to limit the

00:23:47,560 --> 00:23:51,790
communication so that only the

00:23:49,600 --> 00:23:56,290
communications that we expect are

00:23:51,790 --> 00:24:00,310
allowed things like sto and envoi can

00:23:56,290 --> 00:24:02,940
help with this kind of thing there are

00:24:00,310 --> 00:24:06,840
also other tools like a core available

00:24:02,940 --> 00:24:09,670
and these tools can make it easy to

00:24:06,840 --> 00:24:12,130
limit which containers can talk to each

00:24:09,670 --> 00:24:15,220
other and encrypt those connections

00:24:12,130 --> 00:24:17,200
between them making it a lot harder

00:24:15,220 --> 00:24:19,510
again if somebody does manage to exploit

00:24:17,200 --> 00:24:23,440
one container it's much harder to move

00:24:19,510 --> 00:24:25,350
laterally from there to other parts of

00:24:23,440 --> 00:24:27,570
the system

00:24:25,350 --> 00:24:30,470
another thing we can reason about with

00:24:27,570 --> 00:24:34,159
micro services and containerized code is

00:24:30,470 --> 00:24:38,580
what those containers are supposed to do

00:24:34,159 --> 00:24:41,940
when they're actually executing if

00:24:38,580 --> 00:24:45,480
you've got a monolith it's really hard

00:24:41,940 --> 00:24:47,460
to exit in theory you can say I know

00:24:45,480 --> 00:24:50,610
exactly what my code is supposed to do

00:24:47,460 --> 00:24:52,200
but the reality as we all know is there

00:24:50,610 --> 00:24:54,950
will be error paths that we've never

00:24:52,200 --> 00:24:58,919
seen before because monolithic code is

00:24:54,950 --> 00:25:01,559
complicated if we're really in the

00:24:58,919 --> 00:25:05,029
fortunate position of having micro

00:25:01,559 --> 00:25:10,049
service code that really is broken into

00:25:05,029 --> 00:25:12,899
kind of nicely isolated bits of function

00:25:10,049 --> 00:25:15,419
it's much easier to actually say yeah

00:25:12,899 --> 00:25:18,210
I've got tests to execute all of my

00:25:15,419 --> 00:25:20,639
paths that execute all my arrow paths as

00:25:18,210 --> 00:25:23,039
well as the the happy paths and I can

00:25:20,639 --> 00:25:27,899
have a much better view of what each

00:25:23,039 --> 00:25:30,539
container should be allowed to do and if

00:25:27,899 --> 00:25:34,820
we know that and we can detect what it's

00:25:30,539 --> 00:25:37,860
actually doing then we can flag up

00:25:34,820 --> 00:25:40,799
unexpected behavior that can be a red

00:25:37,860 --> 00:25:46,320
flag telling us that something bad is

00:25:40,799 --> 00:25:48,480
happening to our deployment and I'm

00:25:46,320 --> 00:25:51,450
going to do a little demo to kind of

00:25:48,480 --> 00:25:54,240
show the principle of this using a

00:25:51,450 --> 00:25:57,120
vulnerability called shell shock has

00:25:54,240 --> 00:26:00,360
everybody heard of shell shock yeah

00:25:57,120 --> 00:26:04,320
quite a few of you so shell shock was an

00:26:00,360 --> 00:26:07,019
exploit a few years ago now in bash but

00:26:04,320 --> 00:26:10,799
basically meant you could execute

00:26:07,019 --> 00:26:15,000
arbitrary code so let me find my window

00:26:10,799 --> 00:26:19,289
again right so I have here a very small

00:26:15,000 --> 00:26:21,509
web server running well it's an Apache

00:26:19,289 --> 00:26:26,639
web server it's running a vulnerable

00:26:21,509 --> 00:26:30,289
version of bash inside it and if I go to

00:26:26,639 --> 00:26:30,289
now this one is on

00:26:30,429 --> 00:26:39,079
8081 so there's a webpage there it's

00:26:34,909 --> 00:26:43,479
some Apache thing I also have some CGI

00:26:39,079 --> 00:26:45,709
scripts which so CGI is the kind of

00:26:43,479 --> 00:26:52,759
old-fashioned way of creating dynamic

00:26:45,709 --> 00:26:55,849
web content and there is a CGI generated

00:26:52,759 --> 00:26:58,579
page from this web server and I also

00:26:55,849 --> 00:27:00,649
want to check that there is not

00:26:58,579 --> 00:27:03,919
currently anything at this particular

00:27:00,649 --> 00:27:06,649
address and dot HTML because I'm going

00:27:03,919 --> 00:27:09,769
to attack that so all my attack is going

00:27:06,649 --> 00:27:13,099
to create that so at the moment n dot

00:27:09,769 --> 00:27:23,029
HTML responds with the 404 there is no

00:27:13,099 --> 00:27:25,519
page there so I'm going to run a another

00:27:23,029 --> 00:27:29,079
container which is going to attach to

00:27:25,519 --> 00:27:35,479
the web server process ID space

00:27:29,079 --> 00:27:40,399
so that's container shell-shocked yes if

00:27:35,479 --> 00:27:42,139
I can spell it and I need to give it P

00:27:40,399 --> 00:27:48,559
tracing capabilities because I'm going

00:27:42,139 --> 00:27:51,769
to use a utility called s trace and I'm

00:27:48,559 --> 00:27:57,619
just going to use an image that has open

00:27:51,769 --> 00:28:00,859
to with s trace installed ok so

00:27:57,619 --> 00:28:03,229
hopefully I can see from here yeah I can

00:28:00,859 --> 00:28:06,289
see my own process is inside this

00:28:03,229 --> 00:28:09,169
container but I can also see the Apache

00:28:06,289 --> 00:28:14,029
processes that are serving that website

00:28:09,169 --> 00:28:17,359
and I'm going to use s trace I am

00:28:14,029 --> 00:28:21,109
interested in a system call so s tracer

00:28:17,359 --> 00:28:25,269
traces system calls and I'm interested

00:28:21,109 --> 00:28:28,609
in the system call exec ve which is

00:28:25,269 --> 00:28:31,810
what's generated when you run a new

00:28:28,609 --> 00:28:35,430
executable it runs a new binary for you

00:28:31,810 --> 00:28:39,780
and I'm going to look at these processes

00:28:35,430 --> 00:28:43,270
looks like I want eight nine and

00:28:39,780 --> 00:28:46,890
nineteen and I'm gonna follow any child

00:28:43,270 --> 00:28:52,150
processes that they might create okay

00:28:46,890 --> 00:28:56,290
so now if I hit that CGI page again we

00:28:52,150 --> 00:28:59,830
can see that that actually did some

00:28:56,290 --> 00:29:01,570
execution of that CGI script and that's

00:28:59,830 --> 00:29:05,980
what we're going to consider normal

00:29:01,570 --> 00:29:08,440
behavior that's that's all good so now

00:29:05,980 --> 00:29:13,000
I'm going to use the shell-shocked

00:29:08,440 --> 00:29:16,930
attack on this same server and I do this

00:29:13,000 --> 00:29:20,950
by passing in a user agent string and a

00:29:16,930 --> 00:29:24,730
little incantation so that I can now run

00:29:20,950 --> 00:29:27,850
some arbitrary code and I am going to

00:29:24,730 --> 00:29:31,780
run ends and I'm going to put the

00:29:27,850 --> 00:29:36,330
results into a file which corresponds to

00:29:31,780 --> 00:29:40,780
that and HTML address that oops

00:29:36,330 --> 00:29:44,460
slash and dot HTML so that's the page

00:29:40,780 --> 00:29:49,360
that didn't previously exist

00:29:44,460 --> 00:29:50,890
okay now that generated a 500 error for

00:29:49,360 --> 00:29:53,680
me but I'm a hacker so I don't care

00:29:50,890 --> 00:29:55,750
about that it's fine what's more

00:29:53,680 --> 00:30:00,100
interesting is over here we could see

00:29:55,750 --> 00:30:01,810
the CGI script got run again and then we

00:30:00,100 --> 00:30:05,470
could see that bash got run and then we

00:30:01,810 --> 00:30:08,740
could see the end got run now I am NOT

00:30:05,470 --> 00:30:09,940
an Apache expert I'm not going to tell

00:30:08,740 --> 00:30:12,100
you that there is no reason why it

00:30:09,940 --> 00:30:14,320
shouldn't ever run bash but I am going

00:30:12,100 --> 00:30:17,710
to say is there really any reason why it

00:30:14,320 --> 00:30:22,090
should be allowed to run ends if I go

00:30:17,710 --> 00:30:24,100
back to that page again we can see that

00:30:22,090 --> 00:30:26,260
that has generated some potentially

00:30:24,100 --> 00:30:28,000
useful information for me I can get me

00:30:26,260 --> 00:30:32,220
in fact I could have run any command I

00:30:28,000 --> 00:30:37,289
liked through that attack

00:30:32,220 --> 00:30:39,120
so if we were able to say actually we're

00:30:37,289 --> 00:30:43,710
only going to allow a certain set of

00:30:39,120 --> 00:30:47,070
executables then we could restrict the

00:30:43,710 --> 00:30:49,980
ability of an attacker to take advantage

00:30:47,070 --> 00:30:52,289
of that exploit now I'm not saying that

00:30:49,980 --> 00:30:53,580
yeah all run fine you know it's fine to

00:30:52,289 --> 00:30:54,929
run with shell shock if you've got this

00:30:53,580 --> 00:30:57,809
kind of protection of course it isn't

00:30:54,929 --> 00:31:01,230
the point is more that if you have tools

00:30:57,809 --> 00:31:03,870
that enable you to check for example

00:31:01,230 --> 00:31:06,149
which executables are being run then

00:31:03,870 --> 00:31:10,009
that could protect you in the event of

00:31:06,149 --> 00:31:10,009
there being some kind of vulnerability

00:31:10,220 --> 00:31:13,230
serverless

00:31:11,340 --> 00:31:16,230
is I just wanted to mention service

00:31:13,230 --> 00:31:17,580
because it's another example of code

00:31:16,230 --> 00:31:19,440
that you don't really know where it's

00:31:17,580 --> 00:31:22,259
running and in some cases you don't even

00:31:19,440 --> 00:31:23,940
really know what the code is so what am

00:31:22,259 --> 00:31:28,049
I talking about when I think about

00:31:23,940 --> 00:31:30,960
serving us well first of all do you need

00:31:28,049 --> 00:31:33,269
to think about security when you're

00:31:30,960 --> 00:31:34,679
running service code and well I would

00:31:33,269 --> 00:31:36,259
think it's probably a good idea to at

00:31:34,679 --> 00:31:39,450
least understand what the sort of

00:31:36,259 --> 00:31:41,370
security measures have what kind of

00:31:39,450 --> 00:31:42,840
security measures are in place and to

00:31:41,370 --> 00:31:45,750
understand what's going on under the

00:31:42,840 --> 00:31:49,610
covers a little bit and service really

00:31:45,750 --> 00:31:53,909
I'm thinking two sets of things one is

00:31:49,610 --> 00:31:57,929
managed services so things like RDS

00:31:53,909 --> 00:32:00,450
databases or bigquery you can go to your

00:31:57,929 --> 00:32:03,799
providers like Microsoft and Amazon and

00:32:00,450 --> 00:32:07,350
Google and they can provide you with

00:32:03,799 --> 00:32:08,759
amazing tools like databases that

00:32:07,350 --> 00:32:11,990
prevent you from having to worry about

00:32:08,759 --> 00:32:14,100
setting them up and to some extent

00:32:11,990 --> 00:32:15,570
particularly you know depending on the

00:32:14,100 --> 00:32:18,690
size of your organization and your

00:32:15,570 --> 00:32:21,450
particular application perhaps it's

00:32:18,690 --> 00:32:22,919
better to leave the configuration of

00:32:21,450 --> 00:32:25,860
some of these services you know we use

00:32:22,919 --> 00:32:28,139
manage databases because it's hard to

00:32:25,860 --> 00:32:30,389
manage a database it's hard to manage

00:32:28,139 --> 00:32:32,870
things like replication and it can be

00:32:30,389 --> 00:32:36,240
hard to manage things like security so

00:32:32,870 --> 00:32:37,950
provided that the provider of these

00:32:36,240 --> 00:32:40,660
services is doing a decent job of

00:32:37,950 --> 00:32:45,460
security and you're using there

00:32:40,660 --> 00:32:47,110
controls effectively that can be a good

00:32:45,460 --> 00:32:49,780
solution that could well be better than

00:32:47,110 --> 00:32:52,270
doing it yourself the other set of

00:32:49,780 --> 00:32:55,780
function that everybody thinks of when

00:32:52,270 --> 00:32:57,310
they think of service is functions some

00:32:55,780 --> 00:33:00,780
kind of functions as a service things

00:32:57,310 --> 00:33:03,670
like lambda is anybody using functions

00:33:00,780 --> 00:33:05,020
yeah a few hands if you're using them

00:33:03,670 --> 00:33:07,200
are using them in production hands

00:33:05,020 --> 00:33:11,140
awfully or actually isn't yeah good okay

00:33:07,200 --> 00:33:14,530
so this stuff is really taking off very

00:33:11,140 --> 00:33:17,140
quickly and the important thing I think

00:33:14,530 --> 00:33:19,120
to recognize or one important thing to

00:33:17,140 --> 00:33:21,670
recognize is that functions are

00:33:19,120 --> 00:33:25,050
essentially running in containers this

00:33:21,670 --> 00:33:28,540
is you know screenshot from the AWS

00:33:25,050 --> 00:33:30,610
documentation when you run a lambda

00:33:28,540 --> 00:33:34,870
function it is running inside a

00:33:30,610 --> 00:33:37,090
container again there will be a ton of

00:33:34,870 --> 00:33:38,890
things that Amazon or the equivalents

00:33:37,090 --> 00:33:43,120
from the other providers are doing for

00:33:38,890 --> 00:33:45,730
you in terms of security but it's good

00:33:43,120 --> 00:33:48,490
to be aware it's good to be aware that

00:33:45,730 --> 00:33:51,190
things like the runtime that your

00:33:48,490 --> 00:33:53,400
function runs in if it has

00:33:51,190 --> 00:33:56,770
vulnerabilities

00:33:53,400 --> 00:33:58,270
it's just code right the vulnerabilities

00:33:56,770 --> 00:34:01,540
could be there so you want to know that

00:33:58,270 --> 00:34:04,540
if your shipping container itest code to

00:34:01,540 --> 00:34:07,870
the function to the extent that you can

00:34:04,540 --> 00:34:08,980
control that container environments you

00:34:07,870 --> 00:34:11,740
want to make sure that it doesn't

00:34:08,980 --> 00:34:14,460
contain vulnerabilities to the best

00:34:11,740 --> 00:34:14,460
extent you can

00:34:14,890 --> 00:34:19,960
so I'm going to just finish up with some

00:34:16,630 --> 00:34:21,880
advantages that by being cloud native by

00:34:19,960 --> 00:34:24,960
using automation by using DevOps

00:34:21,880 --> 00:34:29,650
processes some advantages that we

00:34:24,960 --> 00:34:31,300
potentially have for security so one is

00:34:29,650 --> 00:34:35,470
this some idea that we're decomposing

00:34:31,300 --> 00:34:38,260
the problem and just as containers and

00:34:35,470 --> 00:34:39,880
micro services left us decompose an

00:34:38,260 --> 00:34:43,120
architecture problem decompose a

00:34:39,880 --> 00:34:46,900
software design problem we can also

00:34:43,120 --> 00:34:52,090
decompose the security defense problem

00:34:46,900 --> 00:34:55,210
and by securing our individual

00:34:52,090 --> 00:34:57,280
containers we can add extra layers of

00:34:55,210 --> 00:34:59,170
defense over and above what we used to

00:34:57,280 --> 00:35:02,490
have in traditional deployments where we

00:34:59,170 --> 00:35:06,040
protected around the whole application

00:35:02,490 --> 00:35:08,170
we have the advantages of continuous

00:35:06,040 --> 00:35:10,750
deployment have to be automating the

00:35:08,170 --> 00:35:15,100
full deployment process to take

00:35:10,750 --> 00:35:16,450
advantage of having a pipeline even if

00:35:15,100 --> 00:35:19,330
there's a manual step before you

00:35:16,450 --> 00:35:22,540
actually deploy it's much faster and

00:35:19,330 --> 00:35:26,230
easier to deploy your code in cloud

00:35:22,540 --> 00:35:28,330
native pipeline processes and if you can

00:35:26,230 --> 00:35:31,660
deploy your code easily you probably do

00:35:28,330 --> 00:35:35,170
it much more frequently and when you

00:35:31,660 --> 00:35:37,060
redeploy your code you reduce the time

00:35:35,170 --> 00:35:40,290
in which an attacker could have

00:35:37,060 --> 00:35:44,200
exploited the previously running code

00:35:40,290 --> 00:35:46,180
and the last thing is I think in the

00:35:44,200 --> 00:35:48,040
kind of DevOps world and in the sort of

00:35:46,180 --> 00:35:51,730
cloud native world there are some really

00:35:48,040 --> 00:35:54,010
good communities things like this events

00:35:51,730 --> 00:35:56,290
where people share best practices and

00:35:54,010 --> 00:35:58,210
they talk about you know what has worked

00:35:56,290 --> 00:36:01,990
for them what tooling or automation

00:35:58,210 --> 00:36:05,200
processes what organizational structures

00:36:01,990 --> 00:36:08,980
have worked for them and we can use that

00:36:05,200 --> 00:36:13,020
to help in the kind of collective fights

00:36:08,980 --> 00:36:13,020
against security exploits

00:36:13,430 --> 00:36:19,980
we did a survey at aqua just a couple of

00:36:16,920 --> 00:36:21,420
months ago and 80 percent of the

00:36:19,980 --> 00:36:24,210
respondents to that survey said that

00:36:21,420 --> 00:36:25,740
they felt there was room to improve the

00:36:24,210 --> 00:36:27,960
security of their containerized

00:36:25,740 --> 00:36:29,730
deployments so you know there are lots

00:36:27,960 --> 00:36:32,039
of best practices still to be shared

00:36:29,730 --> 00:36:35,789
lots of things we can learn from each

00:36:32,039 --> 00:36:37,980
other and popular quotes from the

00:36:35,789 --> 00:36:39,960
Enterprise Strategy Group one was you

00:36:37,980 --> 00:36:42,289
know containers require us to be

00:36:39,960 --> 00:36:44,999
collaborative and that's part of what

00:36:42,289 --> 00:36:49,589
days like today are all about thinking

00:36:44,999 --> 00:36:51,869
about how we can collaborate better and

00:36:49,589 --> 00:36:53,819
also that it's a good idea to embed

00:36:51,869 --> 00:36:54,900
security early into the process I

00:36:53,819 --> 00:36:56,849
actually think there's two different

00:36:54,900 --> 00:37:01,619
ways of interpreting this particular

00:36:56,849 --> 00:37:05,910
quote one is it's a good idea to embed

00:37:01,619 --> 00:37:10,289
security automation tooling as early as

00:37:05,910 --> 00:37:13,049
possible in the pipeline that earlier

00:37:10,289 --> 00:37:14,369
you can report security issues to the

00:37:13,049 --> 00:37:16,710
development team the faster they can

00:37:14,369 --> 00:37:19,589
address them I think you can also

00:37:16,710 --> 00:37:22,859
interpret this sentence to say when you

00:37:19,589 --> 00:37:26,279
are thinking about your pipeline your

00:37:22,859 --> 00:37:28,739
organization your dev ops or dev cycle

00:37:26,279 --> 00:37:32,099
structure it's a good idea to think

00:37:28,739 --> 00:37:33,809
about security early on don't sort of

00:37:32,099 --> 00:37:35,730
have security just as an afterthought

00:37:33,809 --> 00:37:40,460
because you can build it into this

00:37:35,730 --> 00:37:42,539
pipeline if I leave you with one thing

00:37:40,460 --> 00:37:44,309
we already talked about continuous

00:37:42,539 --> 00:37:46,380
integration we talked about continuous

00:37:44,309 --> 00:37:50,059
deployment let's also think about

00:37:46,380 --> 00:37:52,440
continuous security through the process

00:37:50,059 --> 00:37:55,289
there is a link to the survey results

00:37:52,440 --> 00:37:56,849
that I just mentioned and also a link to

00:37:55,289 --> 00:37:59,069
the queue bench tool this is the

00:37:56,849 --> 00:38:03,210
automation tool for it's an open-source

00:37:59,069 --> 00:38:05,339
tool for automating the kubernetes CIS

00:38:03,210 --> 00:38:07,519
benchmark and something that we've been

00:38:05,339 --> 00:38:10,799
working on and Accra

00:38:07,519 --> 00:38:12,029
so with that I don't know no idea what

00:38:10,799 --> 00:38:14,239
how we're doing schedule wise but I

00:38:12,029 --> 00:38:17,279
probably can take some questions I think

00:38:14,239 --> 00:38:22,229
yes good yes I have the okay to take

00:38:17,279 --> 00:38:24,209
some questions any questions so the

00:38:22,229 --> 00:38:28,799
question is and dr. cloud has some

00:38:24,209 --> 00:38:30,839
security sort of scanning and alerting

00:38:28,799 --> 00:38:32,519
built in and is that sort of something

00:38:30,839 --> 00:38:35,190
that you can rely on I am going to say

00:38:32,519 --> 00:38:37,410
it is considerably better than nothing

00:38:35,190 --> 00:38:40,339
definitely use it you know why not

00:38:37,410 --> 00:38:43,289
it may not be everything you need

00:38:40,339 --> 00:38:47,009
depending on your application but you

00:38:43,289 --> 00:38:49,559
know it's it's it's a start I would

00:38:47,009 --> 00:38:51,539
definitely use that over nothing for

00:38:49,559 --> 00:38:53,880
sure one of the interesting things there

00:38:51,539 --> 00:38:58,289
when you look at these vulnerability

00:38:53,880 --> 00:39:04,829
scanning and alerting tools is false

00:38:58,289 --> 00:39:08,009
positives and the the dedicated tools

00:39:04,829 --> 00:39:11,069
will tend to bit like Akwa will tend to

00:39:08,009 --> 00:39:14,910
do a better job of not giving you false

00:39:11,069 --> 00:39:18,259
positive results okay I think that's it

00:39:14,910 --> 00:39:18,259

YouTube URL: https://www.youtube.com/watch?v=We-v-v1Ds7A


