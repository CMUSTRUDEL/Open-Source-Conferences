Title: How We Automatically Analyzed 1,000 Crash Dumps in Ten Minutes - Dina Goldshtein
Publication date: 2015-11-01
Playlist: DevOps Days Tel Aviv 2015
Description: 
	http://www.devopsdays.org/events/2015-telaviv/

BrightSource’s production environment is disconnected from the main network, and there's no easy way to perform remote debugging or get live monitoring data from the field. By configuring Windows to automatically generate crash dumps, we obtained hundreds of dump files from multiple servers while working on our latest release. There was no way we could analyze these dumps by hand, triage the bugs, and assign them to the relevant developers.

That's when I discovered ClrMD – a Microsoft NuGet package that provides a dump debugging API. In this talk I'll explain how we built a tool with ClrMD to automatically analyze dumps and obtain exception information, thread call stacks, and memory usage.

We also integrated this tool with Redmine, a popular project and work item management tool, to file bugs automatically to the relevant developer based on the tool's initial analysis.

About the speaker - Dina Goldshtein

Dina Goldshtein is an Embedded Software Team Leader at BrightSource Energy, a solar energy company.

Dina leads a team of embedded software engineers building systems for real-time processors, develops infrastructure components in C#, C++, and JavaScript, and spends a lot of time improving processes, tools, and operations.
Captions: 
	00:00:09,639 --> 00:00:18,619
hi everybody hi so here we have dinner

00:00:14,809 --> 00:00:21,740
gulch 10 and dinner is an amazing girl

00:00:18,619 --> 00:00:24,859
are you I knew back to university by

00:00:21,740 --> 00:00:27,189
women I so I knew her back at the

00:00:24,859 --> 00:00:31,730
University when we were both young and

00:00:27,189 --> 00:00:35,360
so yeah and beautiful well I was not

00:00:31,730 --> 00:00:37,400
beautiful but still so and back then in

00:00:35,360 --> 00:00:39,170
the University dinner was already like a

00:00:37,400 --> 00:00:41,750
very known character everybody knew

00:00:39,170 --> 00:00:44,510
dinner and she was she was the author of

00:00:41,750 --> 00:00:45,980
like the textbook that we use decadence

00:00:44,510 --> 00:00:48,770
in the University it was like

00:00:45,980 --> 00:00:51,320
unbelievable people actually you know

00:00:48,770 --> 00:00:54,470
gather then bought her like a scanner

00:00:51,320 --> 00:00:58,640
with a multi fiddle whatever which

00:00:54,470 --> 00:01:00,680
was like insane back then and she later

00:00:58,640 --> 00:01:03,470
started working at vitals and she did a

00:01:00,680 --> 00:01:05,750
lot of cool stuff vitals and she's going

00:01:03,470 --> 00:01:09,640
to tell us about one of those things so

00:01:05,750 --> 00:01:09,640
without further ado is Dina

00:01:47,700 --> 00:01:55,570
did you do mean for now I know you hear

00:01:50,710 --> 00:01:58,479
me is this better or worse okay no

00:01:55,570 --> 00:02:01,300
problem okay so what are we going to

00:01:58,479 --> 00:02:03,550
talk about today so first of all I'm

00:02:01,300 --> 00:02:05,229
going to tell you what dumps are what

00:02:03,550 --> 00:02:07,840
they're good for why we need them what

00:02:05,229 --> 00:02:10,269
they can do for us then I'm going to

00:02:07,840 --> 00:02:13,450
talk to you about analysis of these dump

00:02:10,269 --> 00:02:15,910
files both manual analysis and automatic

00:02:13,450 --> 00:02:18,790
analysis then I'm going to present you

00:02:15,910 --> 00:02:25,980
the entire flow of our automatic triage

00:02:18,790 --> 00:02:25,980
system for crashes okay let's go on

00:02:26,190 --> 00:02:30,820
first of all I can't continue without

00:02:28,680 --> 00:02:32,799
talking about a bit about the background

00:02:30,820 --> 00:02:34,959
and you know self-promotion and

00:02:32,799 --> 00:02:37,000
everything so bright source is an

00:02:34,959 --> 00:02:40,420
Israeli company it's located in

00:02:37,000 --> 00:02:42,310
Jerusalem we do solar energy okay here

00:02:40,420 --> 00:02:44,860
you can see an image it's not very clear

00:02:42,310 --> 00:02:46,930
but you can get the idea from google

00:02:44,860 --> 00:02:49,510
earth you can see three of our fields

00:02:46,930 --> 00:02:51,190
here I don't know any other company

00:02:49,510 --> 00:02:54,250
whose product you can see on google

00:02:51,190 --> 00:02:57,010
earth so that's pretty cool what we do

00:02:54,250 --> 00:02:59,530
is that we build huge fields filled with

00:02:57,010 --> 00:03:02,260
mirrors and they concentrate the energy

00:02:59,530 --> 00:03:04,440
of the Sun too big boilers which are

00:03:02,260 --> 00:03:07,690
located in the middle of the fields and

00:03:04,440 --> 00:03:09,280
there's water inside and boils and I'm

00:03:07,690 --> 00:03:11,290
not a physicist but from what I

00:03:09,280 --> 00:03:15,250
understand once we have steam we have

00:03:11,290 --> 00:03:17,920
electricity so so that's that and here

00:03:15,250 --> 00:03:19,480
you can see a close-up of one of the

00:03:17,920 --> 00:03:22,000
field you can see the mirror here and

00:03:19,480 --> 00:03:23,859
you can see the tower and the boil the

00:03:22,000 --> 00:03:26,049
boiler and the reason that it shines

00:03:23,859 --> 00:03:27,310
like that is that actually all the

00:03:26,049 --> 00:03:29,650
sunbeams are

00:03:27,310 --> 00:03:31,690
and traded on the boiler and that's why

00:03:29,650 --> 00:03:33,400
it looks like that so why am I telling

00:03:31,690 --> 00:03:35,470
you all of this well first of all

00:03:33,400 --> 00:03:37,540
because we're cool and all that and

00:03:35,470 --> 00:03:39,790
second of all because this entire

00:03:37,540 --> 00:03:42,819
operation it's a bit ly pretty big one

00:03:39,790 --> 00:03:45,910
it has control software and control

00:03:42,819 --> 00:03:48,640
software has bugs and the software

00:03:45,910 --> 00:03:50,680
crashes and that developers have to fix

00:03:48,640 --> 00:03:54,700
it and that's what we're here to talk

00:03:50,680 --> 00:03:59,950
about so let's start with some bakes

00:03:54,700 --> 00:04:03,580
basics what users don't like violent

00:03:59,950 --> 00:04:05,350
crashes okay so I mean violent crashes I

00:04:03,580 --> 00:04:07,420
mean that every program just shuts down

00:04:05,350 --> 00:04:10,900
and nothing happens and just disappears

00:04:07,420 --> 00:04:14,019
so at first what we did was wrap all the

00:04:10,900 --> 00:04:15,849
code up in a special mechanism which

00:04:14,019 --> 00:04:18,340
kind of swallowed all the unhandled

00:04:15,849 --> 00:04:20,859
exceptions and displayed a nice screen

00:04:18,340 --> 00:04:23,830
for the user something along the lines

00:04:20,859 --> 00:04:26,650
of something oops something unexpected

00:04:23,830 --> 00:04:28,510
happened please contact development you

00:04:26,650 --> 00:04:31,450
can find log files here and there

00:04:28,510 --> 00:04:33,400
something like that and and that was

00:04:31,450 --> 00:04:35,440
pretty good I mean our system is

00:04:33,400 --> 00:04:38,020
composed of several modules and they

00:04:35,440 --> 00:04:41,620
write a lot of logs okay it's pretty

00:04:38,020 --> 00:04:44,440
extensive and we managed to solve quite

00:04:41,620 --> 00:04:46,960
a few bugs like that we got reports from

00:04:44,440 --> 00:04:49,780
the field something happened at this day

00:04:46,960 --> 00:04:53,950
that this time we opened the log files

00:04:49,780 --> 00:04:55,539
we looked inside we saw the error that

00:04:53,950 --> 00:04:58,120
was logged and we managed to solve

00:04:55,539 --> 00:05:01,360
everything but the problem was that ass

00:04:58,120 --> 00:05:03,669
time passed passed by what happened is

00:05:01,360 --> 00:05:06,100
that we started encountering crashes

00:05:03,669 --> 00:05:08,289
that happened and we couldn't recreate

00:05:06,100 --> 00:05:10,300
them in the development environment we

00:05:08,289 --> 00:05:13,479
couldn't understand from the logs what

00:05:10,300 --> 00:05:16,660
happened we just couldn't and so we had

00:05:13,479 --> 00:05:19,570
to tell it the users I'm sorry we

00:05:16,660 --> 00:05:22,800
couldn't resolve this issue please let

00:05:19,570 --> 00:05:25,570
us know again if this happens moreover

00:05:22,800 --> 00:05:27,580
what was even more interesting is that

00:05:25,570 --> 00:05:30,639
sometimes we did manage to solve the

00:05:27,580 --> 00:05:33,910
problem but the last error message in

00:05:30,639 --> 00:05:36,820
the log file was had absolutely nothing

00:05:33,910 --> 00:05:38,780
to do with the actual problem okay so

00:05:36,820 --> 00:05:42,320
that was a pretty common

00:05:38,780 --> 00:05:44,090
Mario and we had to solve that so what

00:05:42,320 --> 00:05:46,430
we really needed was a mechanism that

00:05:44,090 --> 00:05:49,880
allows us to know which exception

00:05:46,430 --> 00:05:53,620
happened when it happened and how

00:05:49,880 --> 00:05:56,630
exactly we got to that point of code

00:05:53,620 --> 00:05:59,600
with that exception for example let's

00:05:56,630 --> 00:06:02,810
say that my error was that some key was

00:05:59,600 --> 00:06:05,750
not found in some dictionary ok that's

00:06:02,810 --> 00:06:09,050
not that it's good to know but which key

00:06:05,750 --> 00:06:11,419
which dictionary what was the flow that

00:06:09,050 --> 00:06:14,180
of events that led me to this point in

00:06:11,419 --> 00:06:16,610
the code where I couldn't find that key

00:06:14,180 --> 00:06:19,190
in that dictionary I can't know that

00:06:16,610 --> 00:06:21,230
from all the logs the lock is general

00:06:19,190 --> 00:06:23,090
it's good right I mean I could know that

00:06:21,230 --> 00:06:26,110
there was a problem with some key in

00:06:23,090 --> 00:06:28,940
some dictionary but unless I treat each

00:06:26,110 --> 00:06:32,360
each exception specifically and write

00:06:28,940 --> 00:06:34,460
specific data I can't no more details

00:06:32,360 --> 00:06:37,910
which I can see when i'm debugging the

00:06:34,460 --> 00:06:39,860
code itself so i had we had to find some

00:06:37,910 --> 00:06:42,860
sort of mechanism to allow us to get

00:06:39,860 --> 00:06:49,450
this data postmortem after the crash

00:06:42,860 --> 00:06:49,450
already happened I'm sorry

00:06:50,590 --> 00:06:56,440
okay I'm sorry once again this slide so

00:06:53,860 --> 00:06:59,740
luckily enough this mechanism exists

00:06:56,440 --> 00:07:03,040
okay it's called a dumb file a Down file

00:06:59,740 --> 00:07:05,770
is essentially an image of the processes

00:07:03,040 --> 00:07:08,920
memory everything that belongs to this

00:07:05,770 --> 00:07:11,950
process exists in the dump file it means

00:07:08,920 --> 00:07:14,860
that you can see they're all the threats

00:07:11,950 --> 00:07:17,650
that belong to the process all the data

00:07:14,860 --> 00:07:20,890
on the heap all the local variables all

00:07:17,650 --> 00:07:23,590
the call stacks for all the treads all

00:07:20,890 --> 00:07:25,810
the locks the threads that date but hold

00:07:23,590 --> 00:07:29,320
the locks and the threads that weight on

00:07:25,810 --> 00:07:31,420
these locks really anything that belongs

00:07:29,320 --> 00:07:33,970
to the process is saved in this dump

00:07:31,420 --> 00:07:39,730
file so that's a pretty good place to

00:07:33,970 --> 00:07:43,990
start okay and luckily enough windows

00:07:39,730 --> 00:07:46,780
can take a such dump file when a program

00:07:43,990 --> 00:07:49,360
crashes and if the program crashes and

00:07:46,780 --> 00:07:51,490
we have this dump file which which is a

00:07:49,360 --> 00:07:54,250
representation of the crash of the

00:07:51,490 --> 00:07:56,380
memories of the processes memory at the

00:07:54,250 --> 00:07:58,780
moment of the crash we can then look at

00:07:56,380 --> 00:08:01,030
it and see what's inside and try to

00:07:58,780 --> 00:08:05,140
analyze it so we need a tool that does

00:08:01,030 --> 00:08:07,060
this luckily for us again this format is

00:08:05,140 --> 00:08:09,400
pretty standard and all the regular

00:08:07,060 --> 00:08:13,330
debuggers know how to open and read this

00:08:09,400 --> 00:08:15,460
data and yes I'm sorry and read this

00:08:13,330 --> 00:08:22,180
data and so then we can take a look

00:08:15,460 --> 00:08:24,520
inside and see what's going on okay so

00:08:22,180 --> 00:08:26,940
here you can see a screenshot of a dump

00:08:24,520 --> 00:08:30,190
file which I opened with visual studio

00:08:26,940 --> 00:08:33,520
sorry which are opened with visual

00:08:30,190 --> 00:08:37,720
studio and do you see the fine print

00:08:33,520 --> 00:08:40,510
here okay so it's not a lot of data

00:08:37,720 --> 00:08:43,300
that's just the welcome screen for the

00:08:40,510 --> 00:08:44,980
for the dump file but what you can see

00:08:43,300 --> 00:08:47,950
here already you can see the

00:08:44,980 --> 00:08:51,430
architecture of the of the process and

00:08:47,950 --> 00:08:53,110
two lines below that you can see the

00:08:51,430 --> 00:08:55,480
actual exception that happened and there

00:08:53,110 --> 00:08:58,090
was some sort of access violation some

00:08:55,480 --> 00:09:00,760
tread try to read or write to a virtual

00:08:58,090 --> 00:09:02,440
address for which does not have an

00:09:00,760 --> 00:09:03,230
appropriate permissions or something

00:09:02,440 --> 00:09:05,420
like that

00:09:03,230 --> 00:09:08,870
so something really wrong happened there

00:09:05,420 --> 00:09:16,630
ok now let's look closely more closely

00:09:08,870 --> 00:09:16,630
inside I have here oh I'm sorry

00:09:21,810 --> 00:09:29,910
okay I have a visual studio here and I

00:09:25,340 --> 00:09:31,950
already dragged a dump file inside okay

00:09:29,910 --> 00:09:33,810
and that's the welcome screen it's not

00:09:31,950 --> 00:09:36,180
the exact same damn file is in the

00:09:33,810 --> 00:09:38,430
slides but it's similar and here you can

00:09:36,180 --> 00:09:46,410
see the same the same data that you saw

00:09:38,430 --> 00:09:48,300
before now i can click on debug and i

00:09:46,410 --> 00:09:51,450
get a window saying that there was an

00:09:48,300 --> 00:09:54,029
exception and some more data even from

00:09:51,450 --> 00:09:56,250
what I saw from the exception more than

00:09:54,029 --> 00:09:59,550
I saw in the welcome screen and once i

00:09:56,250 --> 00:10:03,300
click on break here i can actually see

00:09:59,550 --> 00:10:06,180
the call stack here and i can look sorry

00:10:03,300 --> 00:10:09,000
and i can traverse the call stack and

00:10:06,180 --> 00:10:12,120
see local variables from various points

00:10:09,000 --> 00:10:15,060
in the in the call stack and i can see

00:10:12,120 --> 00:10:17,700
exactly how I got to this point where i

00:10:15,060 --> 00:10:25,040
got the exception I can also see other

00:10:17,700 --> 00:10:25,040
treads other treads just a moment

00:10:27,870 --> 00:10:34,110
other treads okay and I can scroll down

00:10:31,920 --> 00:10:36,270
there are plenty of treads here I can

00:10:34,110 --> 00:10:39,120
click on this one for example and see

00:10:36,270 --> 00:10:42,870
the call stack for this thread or or

00:10:39,120 --> 00:10:45,000
this tread and for each frame and this

00:10:42,870 --> 00:10:48,650
in these treads in these call stacks

00:10:45,000 --> 00:10:48,650
let's find something more interesting

00:10:51,810 --> 00:10:57,480
okay and for each frame in the call

00:10:54,570 --> 00:11:02,430
stack of each of these treads I can

00:10:57,480 --> 00:11:05,130
click on the on the frame if I have if i

00:11:02,430 --> 00:11:07,260
have if i have source code available i

00:11:05,130 --> 00:11:09,000
can provide it to the debugger but I

00:11:07,260 --> 00:11:10,950
don't have source code available here

00:11:09,000 --> 00:11:12,420
and even if I did I wouldn't show you

00:11:10,950 --> 00:11:15,029
the code so that doesn't matter so I

00:11:12,420 --> 00:11:16,380
just cancel it and now if I had the code

00:11:15,029 --> 00:11:18,779
i would actually see it here in this

00:11:16,380 --> 00:11:21,060
window but i can see here in the local

00:11:18,779 --> 00:11:23,820
stabbed all the local variables and

00:11:21,060 --> 00:11:25,710
that's pretty cool okay all of this is

00:11:23,820 --> 00:11:27,960
data that i got from the dump file

00:11:25,710 --> 00:11:35,960
because the dump file is an image of the

00:11:27,960 --> 00:11:35,960
processes memory sorry

00:11:44,570 --> 00:11:50,460
yes okay

00:11:47,670 --> 00:11:52,530
how did this magic happen how does the

00:11:50,460 --> 00:11:55,250
vulgar how this visual visual studio

00:11:52,530 --> 00:11:58,050
know all this stuff about my process

00:11:55,250 --> 00:12:00,540
okay I mean I didn't compile this

00:11:58,050 --> 00:12:03,150
process now I compiled it a while ago on

00:12:00,540 --> 00:12:05,880
a different machine and somehow Visual

00:12:03,150 --> 00:12:08,040
Studio knows all the stuff how is this

00:12:05,880 --> 00:12:11,250
well how is this possible so the

00:12:08,040 --> 00:12:13,650
mechanism is something called symbol Phi

00:12:11,250 --> 00:12:16,020
a symbol symbol file or debug

00:12:13,650 --> 00:12:19,740
information what happens is that anytime

00:12:16,020 --> 00:12:23,460
we compile and executable or dll in

00:12:19,740 --> 00:12:26,400
Visual Studio for example also along

00:12:23,460 --> 00:12:29,250
with the DLL or executable Visual Studio

00:12:26,400 --> 00:12:32,030
creates a file whose extension is PDB

00:12:29,250 --> 00:12:34,950
and this file contains all sorts of

00:12:32,030 --> 00:12:38,870
helper information which can help

00:12:34,950 --> 00:12:42,230
debuggers understand our code better

00:12:38,870 --> 00:12:47,990
what is this debug information contain

00:12:42,230 --> 00:12:52,980
mostly correspondence between locations

00:12:47,990 --> 00:12:55,610
memory addresses and method names as we

00:12:52,980 --> 00:12:59,790
know each method resides in some

00:12:55,610 --> 00:13:02,340
location in the processes memory so in

00:12:59,790 --> 00:13:06,270
order to understand and display this

00:13:02,340 --> 00:13:08,640
nice call stack including dll names and

00:13:06,270 --> 00:13:12,450
method names there has to be a

00:13:08,640 --> 00:13:16,020
correspondence between the memory where

00:13:12,450 --> 00:13:19,290
the function resides and its name also

00:13:16,020 --> 00:13:24,410
the debug information contains names of

00:13:19,290 --> 00:13:28,620
local variables arguments their types

00:13:24,410 --> 00:13:31,230
even even file names and lines of code

00:13:28,620 --> 00:13:33,180
where the function was defined that

00:13:31,230 --> 00:13:34,980
would allow that's what allows me when I

00:13:33,180 --> 00:13:37,920
opened the source code in Visual Studio

00:13:34,980 --> 00:13:40,560
to double click on a frame in a call

00:13:37,920 --> 00:13:42,690
stack and visual studio would show me

00:13:40,560 --> 00:13:45,810
the code that corresponds to this frame

00:13:42,690 --> 00:13:47,480
so that's also available using the

00:13:45,810 --> 00:13:49,519
symbols file

00:13:47,480 --> 00:13:53,779
now what happens if I don't have a

00:13:49,519 --> 00:13:57,230
symbols file here I show you the what

00:13:53,779 --> 00:14:01,010
happens if i run the same debugger as i

00:13:57,230 --> 00:14:03,110
used for this for this dump if i run the

00:14:01,010 --> 00:14:06,829
same debugger trying to get the call

00:14:03,110 --> 00:14:09,769
stack of the same dump file okay of the

00:14:06,829 --> 00:14:12,050
same tread everything the same but i

00:14:09,769 --> 00:14:15,500
just didn't give the debugger the

00:14:12,050 --> 00:14:17,540
symbols file and see what happens it

00:14:15,500 --> 00:14:20,560
doesn't even give me the correct call

00:14:17,540 --> 00:14:23,870
stack it's not just that i have numbers

00:14:20,560 --> 00:14:26,720
instead of names it's not just that i

00:14:23,870 --> 00:14:29,480
have numbers instead of names i actually

00:14:26,720 --> 00:14:32,899
don't have the entire call stack so

00:14:29,480 --> 00:14:36,589
symbols are essential for me to be able

00:14:32,899 --> 00:14:41,089
to debug and understand and analyze them

00:14:36,589 --> 00:14:45,620
files correctly by the way a similar

00:14:41,089 --> 00:14:48,829
mechanism of symbol files and uncertain

00:14:45,620 --> 00:14:50,990
debug information and dumps exists for

00:14:48,829 --> 00:14:54,560
linux as well but it's a different

00:14:50,990 --> 00:14:58,480
format so you can't use visual studio to

00:14:54,560 --> 00:15:01,160
the bag to debug dump of a linux process

00:14:58,480 --> 00:15:03,319
and not familiar with the tools there so

00:15:01,160 --> 00:15:06,399
we have to search online of it but i

00:15:03,319 --> 00:15:06,399
know it it exists

00:15:09,889 --> 00:15:16,579
okay so one thing I didn't say before is

00:15:13,699 --> 00:15:20,420
that each time we compile an executable

00:15:16,579 --> 00:15:22,790
or dll a new simple file gets created

00:15:20,420 --> 00:15:26,329
even if the code didn't change at all

00:15:22,790 --> 00:15:30,379
still a new file is created a new

00:15:26,329 --> 00:15:33,589
symbols file and the debugger knows to

00:15:30,379 --> 00:15:36,829
make sure that we use the correct symbol

00:15:33,589 --> 00:15:39,589
files with a correct dll so if we try to

00:15:36,829 --> 00:15:41,919
a bag an executable or a dll with

00:15:39,589 --> 00:15:45,100
symbols file that were created during

00:15:41,919 --> 00:15:48,109
some different time it just won't work

00:15:45,100 --> 00:15:50,029
there are ways to force the debugger to

00:15:48,109 --> 00:15:52,519
load them anyway I will not get into

00:15:50,029 --> 00:15:55,189
this but like the basic flow of events

00:15:52,519 --> 00:15:57,379
is that if you provide the debugger with

00:15:55,189 --> 00:15:59,689
a different symbols file that was

00:15:57,379 --> 00:16:02,089
created during a different time it just

00:15:59,689 --> 00:16:04,910
won't work so it's essential and since

00:16:02,089 --> 00:16:07,399
it's essential for us to have the

00:16:04,910 --> 00:16:10,489
symbols file available when we try to

00:16:07,399 --> 00:16:13,129
debug something we just need to save

00:16:10,489 --> 00:16:16,189
them every time we make release of our

00:16:13,129 --> 00:16:18,410
product we must save the symbols files

00:16:16,189 --> 00:16:21,949
that were created during the build

00:16:18,410 --> 00:16:23,839
process for our product sometimes people

00:16:21,949 --> 00:16:29,209
save it in the same folder as the

00:16:23,839 --> 00:16:31,999
release itself that's okay but we could

00:16:29,209 --> 00:16:35,749
make it a little bit better there is a

00:16:31,999 --> 00:16:38,720
concept called symbol server where you

00:16:35,749 --> 00:16:43,970
can store your symbol files in a certain

00:16:38,720 --> 00:16:46,850
organized way and the way you save them

00:16:43,970 --> 00:16:50,660
is that you set you organize them by the

00:16:46,850 --> 00:16:53,329
name of the executable or dll and some

00:16:50,660 --> 00:16:55,249
hash code which is unique and depends on

00:16:53,329 --> 00:16:58,399
the time that you compiled your

00:16:55,249 --> 00:17:00,439
executable or dll and why is that good

00:16:58,399 --> 00:17:03,319
for us that's good for us because the

00:17:00,439 --> 00:17:06,589
buggers the regular debuggers use this

00:17:03,319 --> 00:17:08,750
standard mechanism of symbol server to

00:17:06,589 --> 00:17:11,659
retrieve symbols so you can actually

00:17:08,750 --> 00:17:14,990
tell your debugger hey my symbol server

00:17:11,659 --> 00:17:16,730
is located in and that's the simple

00:17:14,990 --> 00:17:19,490
server itself it's a fancy word it's not

00:17:16,730 --> 00:17:21,649
a server it's just a folder on a shared

00:17:19,490 --> 00:17:22,800
network drive and you can tell your

00:17:21,649 --> 00:17:25,230
debugger where

00:17:22,800 --> 00:17:27,480
your symbol server is and once you've

00:17:25,230 --> 00:17:30,330
configured it it will know for good

00:17:27,480 --> 00:17:32,460
where the symbols reside and it will

00:17:30,330 --> 00:17:35,640
know how to retrieve them automatically

00:17:32,460 --> 00:17:38,670
without having to provide them manually

00:17:35,640 --> 00:17:40,980
each time you want to debug and that's a

00:17:38,670 --> 00:17:43,320
really good thing because usually end up

00:17:40,980 --> 00:17:45,930
debugging many versions many different

00:17:43,320 --> 00:17:48,240
versions of the same product anyone to

00:17:45,930 --> 00:17:50,640
have to remember where the symbols

00:17:48,240 --> 00:17:54,540
reside you just want you know the

00:17:50,640 --> 00:17:56,790
debugger to work so if you have a so if

00:17:54,540 --> 00:17:59,610
you have a certain place where all the

00:17:56,790 --> 00:18:03,540
developers store all their symbols in

00:17:59,610 --> 00:18:06,270
this specific format okay and everybody

00:18:03,540 --> 00:18:08,340
configure their the buggers to point to

00:18:06,270 --> 00:18:10,440
that simple server then everything just

00:18:08,340 --> 00:18:12,690
works magically you don't have to think

00:18:10,440 --> 00:18:15,690
about it ever again now you're probably

00:18:12,690 --> 00:18:18,990
asking yourself well it looks like a

00:18:15,690 --> 00:18:21,630
real pain having to save the symbols in

00:18:18,990 --> 00:18:24,000
such an intricate format how do you know

00:18:21,630 --> 00:18:26,510
the hash I mean it's quite long and I

00:18:24,000 --> 00:18:30,230
certainly don't want to type it myself

00:18:26,510 --> 00:18:33,110
that's just you know error-prone and

00:18:30,230 --> 00:18:35,340
again luckily for us there's a tool

00:18:33,110 --> 00:18:37,830
distributed by Microsoft it's called

00:18:35,340 --> 00:18:40,290
seem store you just tell it where the

00:18:37,830 --> 00:18:42,870
symbol server is and you tell it where

00:18:40,290 --> 00:18:45,320
your symbols file is and it just stores

00:18:42,870 --> 00:18:48,810
the symbol file in the symbol server

00:18:45,320 --> 00:18:50,790
according to this format okay so you

00:18:48,810 --> 00:18:53,160
don't really have to do it yourself you

00:18:50,790 --> 00:18:55,470
just use the stool to put your symbols

00:18:53,160 --> 00:18:58,200
in the symbol server and forget about it

00:18:55,470 --> 00:19:00,000
I strongly recommend that you integrate

00:18:58,200 --> 00:19:02,280
the stool into your release procedure

00:19:00,000 --> 00:19:04,020
because then it will just get done

00:19:02,280 --> 00:19:06,870
automatically every time you do a

00:19:04,020 --> 00:19:08,910
release and you know really don't have

00:19:06,870 --> 00:19:11,150
to think about it much so it's really

00:19:08,910 --> 00:19:14,610
convenient

00:19:11,150 --> 00:19:18,030
okay so that's why we've been talking

00:19:14,610 --> 00:19:20,159
about all sorts of general staff let's

00:19:18,030 --> 00:19:22,500
return to the bright source stuff and

00:19:20,159 --> 00:19:26,159
understand what are the challenges that

00:19:22,500 --> 00:19:29,039
we're facing and why analyzing the dumps

00:19:26,159 --> 00:19:33,090
in our situation was harder than in

00:19:29,039 --> 00:19:35,070
other situations so let's talk a bit

00:19:33,090 --> 00:19:37,110
about our production about our

00:19:35,070 --> 00:19:39,510
development and production environment

00:19:37,110 --> 00:19:41,640
our development environment is quite

00:19:39,510 --> 00:19:45,630
convenient we have internet we have

00:19:41,640 --> 00:19:48,450
network shares we have mail whatever we

00:19:45,630 --> 00:19:52,289
have linked and it's all good but our

00:19:48,450 --> 00:19:54,570
product is power plants okay power

00:19:52,289 --> 00:19:57,630
plants are not connected to the Internet

00:19:54,570 --> 00:20:00,000
they're not connected to anything

00:19:57,630 --> 00:20:03,120
basically there's an inner network

00:20:00,000 --> 00:20:05,850
internal network shared between the

00:20:03,120 --> 00:20:07,950
between the servers and we don't have as

00:20:05,850 --> 00:20:11,100
programmers as developers we don't have

00:20:07,950 --> 00:20:13,440
access to it if we need access to the

00:20:11,100 --> 00:20:15,539
production network we need to go to a

00:20:13,440 --> 00:20:18,120
special room it's in another room

00:20:15,539 --> 00:20:21,510
there's a network there which is located

00:20:18,120 --> 00:20:25,110
in Israel and only this network can

00:20:21,510 --> 00:20:28,549
connect through a special one way very

00:20:25,110 --> 00:20:32,250
secure safe wherever all sorts of

00:20:28,549 --> 00:20:34,710
security layers in place there and it

00:20:32,250 --> 00:20:37,140
can connect and do remote control over

00:20:34,710 --> 00:20:39,480
the computers in the production network

00:20:37,140 --> 00:20:42,150
which are completely separate again from

00:20:39,480 --> 00:20:44,960
our development environment and and

00:20:42,150 --> 00:20:48,510
there's a possibility to copy files

00:20:44,960 --> 00:20:50,850
really really really slowly from the

00:20:48,510 --> 00:20:53,700
production network to the network in

00:20:50,850 --> 00:20:57,419
that specific room in our building

00:20:53,700 --> 00:21:01,350
single room okay so that that makes

00:20:57,419 --> 00:21:04,289
things harder because if before we could

00:21:01,350 --> 00:21:08,309
for example if we had crashes and

00:21:04,289 --> 00:21:11,850
production we could do remote debugging

00:21:08,309 --> 00:21:14,880
with visual studio or somehow connect

00:21:11,850 --> 00:21:17,610
and see what's going on live we can do

00:21:14,880 --> 00:21:20,150
that the developers can't do anything

00:21:17,610 --> 00:21:23,980
live on the production okay

00:21:20,150 --> 00:21:23,980
and that's that's a real problem

00:21:30,370 --> 00:21:37,090
so as I said we can't attach a debugger

00:21:34,570 --> 00:21:40,740
we can do remote we can do remote

00:21:37,090 --> 00:21:44,020
analysis moreover as we saw before

00:21:40,740 --> 00:21:47,950
symbols are very critical to our ability

00:21:44,020 --> 00:21:52,180
to analyze and understand them files and

00:21:47,950 --> 00:21:55,240
debug processes generally the problem

00:21:52,180 --> 00:21:58,000
with these debug information files is

00:21:55,240 --> 00:22:00,280
that it makes hackers lives easier it

00:21:58,000 --> 00:22:06,040
actually makes you worse engineering

00:22:00,280 --> 00:22:09,850
easier so we can't it's very not usual

00:22:06,040 --> 00:22:11,559
to put symbol files on production

00:22:09,850 --> 00:22:14,110
networks because production networks

00:22:11,559 --> 00:22:17,440
belong to our clients and we don't want

00:22:14,110 --> 00:22:21,370
to disclose our intellectual property to

00:22:17,440 --> 00:22:23,050
our clients so the debug information it

00:22:21,370 --> 00:22:25,660
just can't be anywhere near the

00:22:23,050 --> 00:22:28,540
production it's in our office in our

00:22:25,660 --> 00:22:32,050
office is not connected in any way to

00:22:28,540 --> 00:22:35,380
production so we can't even install

00:22:32,050 --> 00:22:38,290
visual studio or any debugger on the

00:22:35,380 --> 00:22:40,990
production Network and like go there in

00:22:38,290 --> 00:22:43,570
this only room in the building and do

00:22:40,990 --> 00:22:45,910
remote control and try to debug we don't

00:22:43,570 --> 00:22:51,250
have that ability the only thing that we

00:22:45,910 --> 00:22:54,370
can do is take dumps of our process move

00:22:51,250 --> 00:22:58,540
them to Israel in intricate ways and

00:22:54,370 --> 00:23:00,850
then analyze them postmortem okay how do

00:22:58,540 --> 00:23:03,820
we take these dumps so first of all it's

00:23:00,850 --> 00:23:07,480
possible to take a dump of any process

00:23:03,820 --> 00:23:10,150
at any time using for example task

00:23:07,480 --> 00:23:14,020
manager okay you can just right click on

00:23:10,150 --> 00:23:18,220
a process and mark take take them ya

00:23:14,020 --> 00:23:20,410
know it's funny and that creates a dump

00:23:18,220 --> 00:23:22,870
file so that's possible but that's

00:23:20,410 --> 00:23:26,320
manual and annoying and you know you

00:23:22,870 --> 00:23:29,740
can't you can't plan to take a take down

00:23:26,320 --> 00:23:31,840
at the exact moment of the crush so

00:23:29,740 --> 00:23:34,750
there's a mechanism in windows which

00:23:31,840 --> 00:23:37,570
actually allows configuring windows to

00:23:34,750 --> 00:23:40,360
take an automatic dump at the moment at

00:23:37,570 --> 00:23:42,419
the exact moment of a crash there's a

00:23:40,360 --> 00:23:44,700
link i put at the end of the slides

00:23:42,419 --> 00:23:46,559
it's called a windows error reporting

00:23:44,700 --> 00:23:49,950
you just have to configure several stuff

00:23:46,559 --> 00:23:52,169
in the registry and then dumps are

00:23:49,950 --> 00:23:57,389
taking automatically and store it

00:23:52,169 --> 00:23:58,679
somewhere on the on the disk so so

00:23:57,389 --> 00:24:01,379
that's the only thing that we can do

00:23:58,679 --> 00:24:05,249
actually so we configured our our

00:24:01,379 --> 00:24:08,970
servers to get dumps of the processes

00:24:05,249 --> 00:24:13,590
that crash and and once the shift was

00:24:08,970 --> 00:24:15,210
over our operators can move them to the

00:24:13,590 --> 00:24:17,700
office to the development environment

00:24:15,210 --> 00:24:19,649
and when developers get there in the

00:24:17,700 --> 00:24:22,379
morning they can have a look in the in

00:24:19,649 --> 00:24:24,299
the network share whatever and and see

00:24:22,379 --> 00:24:26,899
if there are new dumps that need to be

00:24:24,299 --> 00:24:26,899
analyzed

00:24:30,509 --> 00:24:38,459
let's go over the flow of the manual

00:24:34,259 --> 00:24:42,239
analysis flow okay so we need to take

00:24:38,459 --> 00:24:44,909
the dump from the office share and get

00:24:42,239 --> 00:24:47,699
it to the developers computer okay

00:24:44,909 --> 00:24:50,519
obviously that's not really necessary we

00:24:47,699 --> 00:24:55,559
could analyze the dump from the network

00:24:50,519 --> 00:24:58,079
share but it's faster on an SSD on a

00:24:55,559 --> 00:25:00,539
machine with an SSD rather than working

00:24:58,079 --> 00:25:03,690
on the network shared which is which is

00:25:00,539 --> 00:25:06,479
a slow storage which everybody access

00:25:03,690 --> 00:25:08,159
all the time so and thats can't dumps

00:25:06,479 --> 00:25:10,499
can be pretty big I mean remember it's

00:25:08,159 --> 00:25:13,049
an image of a process so if we're

00:25:10,499 --> 00:25:17,969
talking 32-bit it could be easily to

00:25:13,049 --> 00:25:20,789
three gigs if it's 64 you know it can be

00:25:17,969 --> 00:25:23,249
much larger so it's a large file and we

00:25:20,789 --> 00:25:25,769
need to have it available somewhere then

00:25:23,249 --> 00:25:29,369
if we don't have a symbol server in

00:25:25,769 --> 00:25:32,639
place we need to find the version of the

00:25:29,369 --> 00:25:35,309
product that we're trying to develop we

00:25:32,639 --> 00:25:37,949
need to find the symbol files we need to

00:25:35,309 --> 00:25:42,029
give them to the debugger we need to

00:25:37,949 --> 00:25:44,309
debug the dump file locate the last

00:25:42,029 --> 00:25:47,309
exception that occurred the one that

00:25:44,309 --> 00:25:50,819
caused the crash then we need to find

00:25:47,309 --> 00:25:53,219
the call stack that code that made us

00:25:50,819 --> 00:25:56,749
arrive at this exception we need to

00:25:53,219 --> 00:25:59,369
locate the function in this call stack

00:25:56,749 --> 00:26:02,339
the first function that actually belongs

00:25:59,369 --> 00:26:08,039
to us to write the words and not say

00:26:02,339 --> 00:26:09,839
win32 or clr or c runtime or whatever we

00:26:08,039 --> 00:26:12,059
need to find something that's ours that

00:26:09,839 --> 00:26:14,069
we can sign to some developer in bright

00:26:12,059 --> 00:26:16,949
source we need to remember who that

00:26:14,069 --> 00:26:18,809
developer is i mean if i see some dll

00:26:16,949 --> 00:26:21,629
which I know it's ours I need to

00:26:18,809 --> 00:26:23,849
remember who the developer that's a sign

00:26:21,629 --> 00:26:26,129
that's little responsible of this dll

00:26:23,849 --> 00:26:29,999
and then i need to go to our project

00:26:26,129 --> 00:26:33,239
management place and open a bug report

00:26:29,999 --> 00:26:35,549
if you know if i don't like this

00:26:33,239 --> 00:26:37,979
developer very much I would just write

00:26:35,549 --> 00:26:40,169
in the bug report that there's a dump

00:26:37,979 --> 00:26:43,230
for you here's the location

00:26:40,169 --> 00:26:46,440
if I'm if I'm in a more cooperative mode

00:26:43,230 --> 00:26:50,159
I probably should include a call stack

00:26:46,440 --> 00:26:53,759
the exception maybe some other info that

00:26:50,159 --> 00:26:56,309
i found useful and something else that i

00:26:53,759 --> 00:26:58,769
should mention here is that probably

00:26:56,309 --> 00:27:00,239
when we released a buggy version a lot

00:26:58,769 --> 00:27:03,450
of the crashes are from the same

00:27:00,239 --> 00:27:06,299
location so if i could also aggregate

00:27:03,450 --> 00:27:08,999
all the crashes that were caused by the

00:27:06,299 --> 00:27:11,129
Semak the same exception in the same

00:27:08,999 --> 00:27:13,830
location in the code that would be

00:27:11,129 --> 00:27:15,570
really awesome and well aggregation is

00:27:13,830 --> 00:27:18,600
obviously impossible when you have

00:27:15,570 --> 00:27:21,450
dozens of the of crashes per day because

00:27:18,600 --> 00:27:23,220
it takes time I wrote here I guess that

00:27:21,450 --> 00:27:25,710
this whole process might take about 10

00:27:23,220 --> 00:27:28,350
minutes for adam but from my own

00:27:25,710 --> 00:27:31,950
experience after three of those you

00:27:28,350 --> 00:27:33,769
start to get exponentially slower it's

00:27:31,950 --> 00:27:37,350
really it's really an annoying task

00:27:33,769 --> 00:27:40,169
truly it's it's it's repetitive its

00:27:37,350 --> 00:27:42,269
mundane it's just you know we have to

00:27:40,169 --> 00:27:45,869
like a row but you have to drag them

00:27:42,269 --> 00:27:49,049
since I'd drag the the symbols click on

00:27:45,869 --> 00:27:51,259
debug search for the call stack find the

00:27:49,049 --> 00:27:54,450
developer responsible open the ticket

00:27:51,259 --> 00:27:56,009
it's really it's not fun at all and so

00:27:54,450 --> 00:27:59,460
aggregation is totally out of the

00:27:56,009 --> 00:28:02,159
question here and and you know so we

00:27:59,460 --> 00:28:04,889
must find a way to do this better really

00:28:02,159 --> 00:28:06,869
because with you know if it's about 10

00:28:04,889 --> 00:28:09,239
minutes per dump and I forgot to mention

00:28:06,869 --> 00:28:12,239
this before but this whole thing was

00:28:09,239 --> 00:28:15,029
done during very early stages of

00:28:12,239 --> 00:28:19,590
development work project and the

00:28:15,029 --> 00:28:23,340
software was no really it was an

00:28:19,590 --> 00:28:26,369
unstable let's color that and I think

00:28:23,340 --> 00:28:30,029
that in our worst days we had dozens of

00:28:26,369 --> 00:28:32,669
crashes so you know multiply thousands

00:28:30,029 --> 00:28:35,760
of crashes by ten minutes the developers

00:28:32,669 --> 00:28:38,590
don't get to do much developing

00:28:35,760 --> 00:28:44,890
so so we should find a way to make

00:28:38,590 --> 00:28:48,970
faster and we found this way a few years

00:28:44,890 --> 00:28:52,059
ago microsoft released a library called

00:28:48,970 --> 00:28:55,780
clr md it's a distributed via nuke

00:28:52,059 --> 00:28:58,570
nougat and and what what gives us is

00:28:55,780 --> 00:29:01,690
that it gives us a programmatic API for

00:28:58,570 --> 00:29:04,300
debugging it means I can do the same

00:29:01,690 --> 00:29:06,820
things that I described here before and

00:29:04,300 --> 00:29:09,640
I showed you like loading the dump

00:29:06,820 --> 00:29:12,580
clicking play looking at the treads

00:29:09,640 --> 00:29:15,429
looking at the call stacks it gives me a

00:29:12,580 --> 00:29:21,179
programmatic API and I can do all of

00:29:15,429 --> 00:29:24,820
that in code meaning automatically ok so

00:29:21,179 --> 00:29:27,429
what it allows us to do the exact things

00:29:24,820 --> 00:29:29,920
that we need it allows us to get the

00:29:27,429 --> 00:29:34,090
last event in the code that happened in

00:29:29,920 --> 00:29:36,070
the dump exception in our case it allows

00:29:34,090 --> 00:29:38,500
us to get a list of all the threats that

00:29:36,070 --> 00:29:40,450
we have it allows us to get the call

00:29:38,500 --> 00:29:44,920
stacks for each of these treads it

00:29:40,450 --> 00:29:49,330
allows us to understand which tread had

00:29:44,920 --> 00:29:52,000
the exception that caused the crash it

00:29:49,330 --> 00:29:53,590
allows us it allows us many more things

00:29:52,000 --> 00:29:56,260
actually but that's the things that we

00:29:53,590 --> 00:29:59,770
need for our process of analyzing the

00:29:56,260 --> 00:30:02,950
code recently this library became open

00:29:59,770 --> 00:30:05,350
source it's available on github I put a

00:30:02,950 --> 00:30:07,600
link here but you can also Google clr md

00:30:05,350 --> 00:30:11,610
and it will probably get you to the

00:30:07,600 --> 00:30:14,410
right place let's look at some code

00:30:11,610 --> 00:30:18,429
those are snippets you can't copy paste

00:30:14,410 --> 00:30:20,500
it exactly the way it is some some local

00:30:18,429 --> 00:30:23,470
variable declaration is missing but i

00:30:20,500 --> 00:30:26,140
just want to show you the concept so the

00:30:23,470 --> 00:30:29,380
first line loads are dumped that was

00:30:26,140 --> 00:30:31,690
easy just one function loads down then

00:30:29,380 --> 00:30:33,460
what i want to show you here oh the

00:30:31,690 --> 00:30:36,600
mouse is not in the right place then

00:30:33,460 --> 00:30:41,120
what you can see here is how i get

00:30:36,600 --> 00:30:45,810
information about the last exception

00:30:41,120 --> 00:30:50,520
using this library so first of all you

00:30:45,810 --> 00:30:54,540
can see here that I have that have code

00:30:50,520 --> 00:30:57,960
the checks if this process was managed

00:30:54,540 --> 00:31:00,630
or native and that's a very important

00:30:57,960 --> 00:31:03,480
feature although this library is written

00:31:00,630 --> 00:31:07,170
in C sharp it supports debugging and

00:31:03,480 --> 00:31:08,910
analyzing both native and managed code

00:31:07,170 --> 00:31:11,340
that's very important because

00:31:08,910 --> 00:31:14,790
specifically in our case and I assume

00:31:11,340 --> 00:31:18,410
that it might be similar in very other

00:31:14,790 --> 00:31:20,760
in many other cases we had the UI the

00:31:18,410 --> 00:31:24,480
system itself had the UI which was

00:31:20,760 --> 00:31:27,950
written in WPF in.net but the core logic

00:31:24,480 --> 00:31:31,650
an algorithmic parts were written in C++

00:31:27,950 --> 00:31:33,480
which was wrapped in C++ CLI and that's

00:31:31,650 --> 00:31:36,840
how the you i interacted with these

00:31:33,480 --> 00:31:39,870
modules and so most of the crashes

00:31:36,840 --> 00:31:42,720
actually were from the C++ code not

00:31:39,870 --> 00:31:45,300
because the C++ developers were worse

00:31:42,720 --> 00:31:48,780
but simply because most of the code was

00:31:45,300 --> 00:31:52,470
C++ and C++ is more complicated as it is

00:31:48,780 --> 00:31:54,660
so so most of the crashes were from C++

00:31:52,470 --> 00:31:57,620
and it was very important for us to be

00:31:54,660 --> 00:32:01,470
able to get this dump from a managed

00:31:57,620 --> 00:32:05,520
process which contained native parts and

00:32:01,470 --> 00:32:08,970
be able to debug and analyze both parts

00:32:05,520 --> 00:32:12,600
of the process okay so here you can see

00:32:08,970 --> 00:32:16,860
that it's possible to understand if the

00:32:12,600 --> 00:32:19,350
process is managed or native and it's

00:32:16,860 --> 00:32:21,660
not very important right now but it is

00:32:19,350 --> 00:32:25,140
possible for a managed native to contain

00:32:21,660 --> 00:32:27,480
inside several versions of cor so the

00:32:25,140 --> 00:32:30,000
debugger even supports that we could

00:32:27,480 --> 00:32:33,360
actually debug again it's not the right

00:32:30,000 --> 00:32:35,100
screen I'm sorry here you can see that

00:32:33,360 --> 00:32:37,830
it's possible to check if we have

00:32:35,100 --> 00:32:40,050
several versions of clr in our process

00:32:37,830 --> 00:32:42,630
and it's possible to debug all of them

00:32:40,050 --> 00:32:46,240
if we need

00:32:42,630 --> 00:32:49,240
so here I check what happens I check if

00:32:46,240 --> 00:32:52,060
the process it's managed and if indeed

00:32:49,240 --> 00:32:55,360
the process is managed I get more api's

00:32:52,060 --> 00:32:58,930
available which expose more data for

00:32:55,360 --> 00:33:02,410
example I'll get to it in a second and

00:32:58,930 --> 00:33:05,500
more detail but here if I know that the

00:33:02,410 --> 00:33:08,050
process is managed I can get more data

00:33:05,500 --> 00:33:10,720
about the current exception I can get

00:33:08,050 --> 00:33:12,850
more data which is relevant for clr like

00:33:10,720 --> 00:33:15,640
the type of the exception and not just

00:33:12,850 --> 00:33:18,760
the message describing what was written

00:33:15,640 --> 00:33:21,850
inside so now let's look how we get the

00:33:18,760 --> 00:33:24,520
exception information here we have the

00:33:21,850 --> 00:33:27,220
gap get last event information method

00:33:24,520 --> 00:33:30,910
that's a general method it works both

00:33:27,220 --> 00:33:34,300
for managed and fur- and it has quite a

00:33:30,910 --> 00:33:38,320
lot of out parameters I think that the

00:33:34,300 --> 00:33:40,870
important one for our for our purpose is

00:33:38,320 --> 00:33:43,690
the event type because there are several

00:33:40,870 --> 00:33:46,080
events possible and we're interested

00:33:43,690 --> 00:33:50,650
just in the events which are exception

00:33:46,080 --> 00:33:54,070
and the description and the description

00:33:50,650 --> 00:33:56,470
and I'm sorry and the thread index this

00:33:54,070 --> 00:33:58,750
is this is this is the information that

00:33:56,470 --> 00:34:01,690
interests us because using the thread

00:33:58,750 --> 00:34:04,780
index we can then go and ask for the

00:34:01,690 --> 00:34:07,570
call stack that belongs to this thread

00:34:04,780 --> 00:34:09,159
and using the call stack will be able to

00:34:07,570 --> 00:34:11,740
understand who's the developer

00:34:09,159 --> 00:34:15,850
responsible and housh we should open the

00:34:11,740 --> 00:34:19,030
bug report on ok so that's the general

00:34:15,850 --> 00:34:24,460
code here we get the exception whether

00:34:19,030 --> 00:34:27,550
it was negative or or managed and in

00:34:24,460 --> 00:34:29,950
here we can see that if we know that the

00:34:27,550 --> 00:34:33,429
that the process was managed we can get

00:34:29,950 --> 00:34:36,060
even more data about about the clr

00:34:33,429 --> 00:34:36,060
exception

00:34:36,250 --> 00:34:43,790
alrighty so last part of this whole

00:34:41,240 --> 00:34:48,890
process is integration with the project

00:34:43,790 --> 00:34:51,350
manager we use read mine which is one of

00:34:48,890 --> 00:34:54,350
the nice things about it besides being

00:34:51,350 --> 00:34:56,660
free and open source and all that is

00:34:54,350 --> 00:34:58,880
that it exposes a Web API which allows

00:34:56,660 --> 00:35:01,130
us to interact with it programmatically

00:34:58,880 --> 00:35:03,890
and that's very important if we want to

00:35:01,130 --> 00:35:06,920
automate the entire process again

00:35:03,890 --> 00:35:10,420
there's a rapper available for this Web

00:35:06,920 --> 00:35:12,740
API is distributed via via nougat

00:35:10,420 --> 00:35:15,470
actually when I prepare these slides I

00:35:12,740 --> 00:35:17,660
discovered there are now two rappers for

00:35:15,470 --> 00:35:19,610
this Web API I'm not sure what the

00:35:17,660 --> 00:35:21,920
difference is I guess it should check it

00:35:19,610 --> 00:35:24,110
sometime but this whole thing was

00:35:21,920 --> 00:35:26,060
written a couple of years ago back then

00:35:24,110 --> 00:35:31,420
there was only one and it worked so you

00:35:26,060 --> 00:35:34,160
know if it works don't change it awesome

00:35:31,420 --> 00:35:38,510
now the moment we've all been waiting

00:35:34,160 --> 00:35:42,140
for let's make an overview of our entire

00:35:38,510 --> 00:35:45,080
dump analysis process okay that's that's

00:35:42,140 --> 00:35:46,790
the Holy Grail we've been waiting for at

00:35:45,080 --> 00:35:50,000
the end of each shift we have the power

00:35:46,790 --> 00:35:53,990
we have operators coming every day

00:35:50,000 --> 00:35:55,790
around I think it was 3-4 p.m. they were

00:35:53,990 --> 00:35:59,240
coming to the office in Israel and the

00:35:55,790 --> 00:36:01,430
field was located in California so they

00:35:59,240 --> 00:36:04,460
were coming in the afternoon and working

00:36:01,430 --> 00:36:06,290
a night shift until five six in the

00:36:04,460 --> 00:36:08,930
morning and at the end of their shift

00:36:06,290 --> 00:36:12,590
they would pack up all the dump files

00:36:08,930 --> 00:36:15,680
created and start moving moving them to

00:36:12,590 --> 00:36:19,250
the office network by the time the

00:36:15,680 --> 00:36:22,580
developers arrived to work say eight

00:36:19,250 --> 00:36:25,370
nine ten in the morning they can go to

00:36:22,580 --> 00:36:27,950
our office to our network share save

00:36:25,370 --> 00:36:32,300
their new dumps and start analyzing them

00:36:27,950 --> 00:36:34,850
with our dump analyzer which is

00:36:32,300 --> 00:36:36,830
automatic as we said according to a

00:36:34,850 --> 00:36:39,740
configuration file which i'm going to

00:36:36,830 --> 00:36:42,620
show you in a bit the damn analyzer was

00:36:39,740 --> 00:36:44,930
also able to make a correspondence

00:36:42,620 --> 00:36:50,960
between the cold step and the developer

00:36:44,930 --> 00:36:54,950
which we should open a ticket for here

00:36:50,960 --> 00:36:58,940
is a screenshot of the results which i

00:36:54,950 --> 00:37:02,720
ran on this laptop a few days ago then

00:36:58,940 --> 00:37:06,170
the analysis was on about 70 dump files

00:37:02,720 --> 00:37:10,070
and it took like about three minutes

00:37:06,170 --> 00:37:14,990
okay so instead of having to go through

00:37:10,070 --> 00:37:18,730
70 I think to 74 74 dump files manually

00:37:14,990 --> 00:37:22,040
opening each one of them and running the

00:37:18,730 --> 00:37:24,230
running the code the running the

00:37:22,040 --> 00:37:25,730
commands in visual studio which show us

00:37:24,230 --> 00:37:28,040
the coal stacks and the threads and the

00:37:25,730 --> 00:37:31,040
exceptions on all that I just click the

00:37:28,040 --> 00:37:33,200
button and it just work okay another

00:37:31,040 --> 00:37:36,350
thing you can see here which is realized

00:37:33,200 --> 00:37:38,240
is the statistics at the end because all

00:37:36,350 --> 00:37:40,370
of this is automated and happens

00:37:38,240 --> 00:37:42,980
programmatically it's really easy to

00:37:40,370 --> 00:37:45,230
make statistics on the dump file so

00:37:42,980 --> 00:37:47,720
example for for example we can see here

00:37:45,230 --> 00:37:51,680
a correspondence between the module name

00:37:47,720 --> 00:37:53,810
and the number of errors that happen so

00:37:51,680 --> 00:37:56,240
we can know which module had the most

00:37:53,810 --> 00:37:59,720
bugs we can know which developer had the

00:37:56,240 --> 00:38:03,740
least bugs and that's nice we actually

00:37:59,720 --> 00:38:06,710
didn't implement this ability in the

00:38:03,740 --> 00:38:09,200
dump analyzer but obviously now that we

00:38:06,710 --> 00:38:12,710
have this ability to make statistics and

00:38:09,200 --> 00:38:16,310
things we can also do that do that

00:38:12,710 --> 00:38:18,740
aggregation I talked about before and we

00:38:16,310 --> 00:38:21,440
can open a single ticket with many

00:38:18,740 --> 00:38:25,250
instances of them files which will

00:38:21,440 --> 00:38:28,150
present the same problem so to sum this

00:38:25,250 --> 00:38:33,400
up I just want to show you that it works

00:38:28,150 --> 00:38:33,400
here is oh sorry again

00:38:34,140 --> 00:38:40,120
here is our configuration file you can

00:38:38,470 --> 00:38:42,760
see here the location of the dumps it's

00:38:40,120 --> 00:38:44,800
not very interesting and then that's the

00:38:42,760 --> 00:38:49,350
interesting part we have the

00:38:44,800 --> 00:38:53,740
correspondence between the modules and

00:38:49,350 --> 00:38:56,680
the developers which owned this code

00:38:53,740 --> 00:38:59,620
okay so we have something called sfg and

00:38:56,680 --> 00:39:02,590
mucha show is responsible for that code

00:38:59,620 --> 00:39:06,670
and we have sfc optics and it's child

00:39:02,590 --> 00:39:09,210
I'll quoc okay and the code is is able

00:39:06,670 --> 00:39:12,670
to go over the call stack understand

00:39:09,210 --> 00:39:15,250
which module is the first one in the

00:39:12,670 --> 00:39:17,920
call stack and open a ticket for the

00:39:15,250 --> 00:39:22,440
Ravel for the relevant developer let's

00:39:17,920 --> 00:39:22,440
run this okay

00:39:26,080 --> 00:39:32,470
it's starting to run it's displaying

00:39:28,450 --> 00:39:37,870
stuff on the screen but let's look in my

00:39:32,470 --> 00:39:40,180
red mine okay I see let me make this

00:39:37,870 --> 00:39:44,710
bigger I see tickets starting to appear

00:39:40,180 --> 00:39:47,080
we had 18 I'll refresh I have 28 now so

00:39:44,710 --> 00:39:50,050
it's actually opening tickets right this

00:39:47,080 --> 00:39:53,110
moment and let's look at them okay it's

00:39:50,050 --> 00:39:55,510
a bug there was a problem in the in the

00:39:53,110 --> 00:39:59,610
title of the ticket we can see the

00:39:55,510 --> 00:39:59,610
module and the name of the function

00:40:01,110 --> 00:40:06,700
sorry the name of the function and you

00:40:04,510 --> 00:40:09,580
can even see here the exception that

00:40:06,700 --> 00:40:15,090
happened if i click inside I can see the

00:40:09,580 --> 00:40:15,090
call stack okay so it actually works

00:40:15,690 --> 00:40:18,960
sorry again

00:40:21,119 --> 00:40:25,400
okay no not okay

00:40:26,200 --> 00:40:28,530
you'd think

00:40:35,480 --> 00:40:39,319
I'm sorry okay

00:40:40,549 --> 00:40:44,019
ok now that

00:40:47,640 --> 00:40:54,510
ok that's the sorry so that's it I show

00:40:52,200 --> 00:40:56,850
you our entire flow we talked about

00:40:54,510 --> 00:40:59,220
dumps what they can give us why they're

00:40:56,850 --> 00:41:02,280
good I showed you the entire process

00:40:59,220 --> 00:41:04,490
automatic process of our trash of crash

00:41:02,280 --> 00:41:07,410
dumps I show you that it actually works

00:41:04,490 --> 00:41:09,900
and there are some resources here if you

00:41:07,410 --> 00:41:11,610
want to try to do it at home I do hope

00:41:09,900 --> 00:41:15,260
you don't have to analyze dozens of

00:41:11,610 --> 00:41:15,260

YouTube URL: https://www.youtube.com/watch?v=InswdKC6W20


