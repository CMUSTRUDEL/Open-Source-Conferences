Title: Why You Should Test Your Software in Production - Joseph Pierri - DevOpsDays Tel Aviv 2016
Publication date: 2017-01-08
Playlist: DevOps Days Tel Aviv 2016
Description: 
	
Captions: 
	00:00:02,710 --> 00:00:09,970
[Music]

00:00:07,360 --> 00:00:16,279
this is my first time in Israel I'm

00:00:09,970 --> 00:00:19,970
super happy to be here I'm visiting from

00:00:16,279 --> 00:00:22,550
Toronto and the title of my presentation

00:00:19,970 --> 00:00:28,039
today is we'll do it live testing your

00:00:22,550 --> 00:00:30,499
software in production so I work for a

00:00:28,039 --> 00:00:33,860
company called pagerduty how many people

00:00:30,499 --> 00:00:36,290
here have heard of pay-tv okay so

00:00:33,860 --> 00:00:38,090
there's a few I saw a few people didn't

00:00:36,290 --> 00:00:40,940
put up their hands so I'll give a brief

00:00:38,090 --> 00:00:44,000
description where we call ourselves an

00:00:40,940 --> 00:00:45,530
incident management platform and what

00:00:44,000 --> 00:00:48,230
that means is you know you have your

00:00:45,530 --> 00:00:51,620
monitoring tools that help you to detect

00:00:48,230 --> 00:00:53,600
problems and you have people at your

00:00:51,620 --> 00:00:56,270
company that are there to you know that

00:00:53,600 --> 00:00:59,420
can fix the problems and what we do is

00:00:56,270 --> 00:01:01,580
we connect the information from the

00:00:59,420 --> 00:01:03,860
monitoring tools to the right people so

00:01:01,580 --> 00:01:07,280
we provide the right problem with the

00:01:03,860 --> 00:01:11,570
right context to the right people to the

00:01:07,280 --> 00:01:14,060
right person so about me I am a software

00:01:11,570 --> 00:01:19,130
engineer at pagerduty I've worked there

00:01:14,060 --> 00:01:21,649
for 33 a half years I've worked on a

00:01:19,130 --> 00:01:24,439
variety of projects at page beauty in my

00:01:21,649 --> 00:01:26,509
time there from user facing features to

00:01:24,439 --> 00:01:28,549
back-end services and I'm currently a

00:01:26,509 --> 00:01:31,369
member of the core team and what we do

00:01:28,549 --> 00:01:33,289
is we build services and libraries that

00:01:31,369 --> 00:01:36,579
help empower the rest of the engineering

00:01:33,289 --> 00:01:36,579
division a PhD

00:01:36,790 --> 00:01:41,080
so I'd like to begin my talk with a

00:01:39,100 --> 00:01:43,570
quote and the quote goes as follows

00:01:41,080 --> 00:01:46,750
people who don't take risks generally

00:01:43,570 --> 00:01:48,760
make two big mistakes a year people who

00:01:46,750 --> 00:01:53,740
do take risks generally make about two

00:01:48,760 --> 00:01:55,180
big mistakes year my talk today is sort

00:01:53,740 --> 00:01:56,770
of related to the topic of risk and I'm

00:01:55,180 --> 00:01:59,710
going to bring up the the word risk a

00:01:56,770 --> 00:02:01,300
few times and this quote kind of

00:01:59,710 --> 00:02:03,940
highlights the misperceptions that

00:02:01,300 --> 00:02:07,420
people have when it comes to the topic

00:02:03,940 --> 00:02:10,479
of risk so when we think about risk as

00:02:07,420 --> 00:02:12,370
it pertains to software we think of

00:02:10,479 --> 00:02:15,340
testing as a tool that can help us to

00:02:12,370 --> 00:02:18,430
mitigate risk right it it helps reduce

00:02:15,340 --> 00:02:21,310
the risk inherent in software

00:02:18,430 --> 00:02:22,870
development process we also have to keep

00:02:21,310 --> 00:02:24,550
in mind another risk in the software

00:02:22,870 --> 00:02:31,060
development process and that's the risk

00:02:24,550 --> 00:02:33,940
of moving too slowly so I'd like to

00:02:31,060 --> 00:02:36,300
frame the the problem of the challenge

00:02:33,940 --> 00:02:39,370
that we have when we're testing software

00:02:36,300 --> 00:02:41,140
we kind of have a few things that we're

00:02:39,370 --> 00:02:44,860
trying to optimize we're trying to

00:02:41,140 --> 00:02:46,570
optimize the users experience so I test

00:02:44,860 --> 00:02:49,420
software because I don't want a user to

00:02:46,570 --> 00:02:52,900
see you know a bug that I've introduced

00:02:49,420 --> 00:02:55,239
with my code I try to minimize

00:02:52,900 --> 00:02:58,000
operational pain when I'm talking oh and

00:02:55,239 --> 00:03:01,090
i'm testing software i want to make sure

00:02:58,000 --> 00:03:03,100
that if i've introduced a non performant

00:03:01,090 --> 00:03:04,209
query for example someone else is not

00:03:03,100 --> 00:03:08,170
going to get woken up in the middle of

00:03:04,209 --> 00:03:09,430
the night as a result of the problem you

00:03:08,170 --> 00:03:11,410
know while i'm trying to optimize for

00:03:09,430 --> 00:03:13,630
both of these variables i have to deal

00:03:11,410 --> 00:03:16,600
with a constraint the constraint is that

00:03:13,630 --> 00:03:18,730
developer time is a finite resource so

00:03:16,600 --> 00:03:21,130
it's really about how do we make the

00:03:18,730 --> 00:03:24,600
most efficient use of this constraint of

00:03:21,130 --> 00:03:24,600
this like finite resource

00:03:25,620 --> 00:03:32,640
so I'll to talk about testing let me

00:03:29,190 --> 00:03:36,000
begin with maybe a conventional approach

00:03:32,640 --> 00:03:39,299
to testing with a web application this

00:03:36,000 --> 00:03:41,790
is basically how the testing environment

00:03:39,299 --> 00:03:44,640
I pagerduty looks when I joined and it

00:03:41,790 --> 00:03:46,110
continued to live for a long time so if

00:03:44,640 --> 00:03:49,560
I'm making a change if I'm a developer

00:03:46,110 --> 00:03:51,329
and I make a software change I am going

00:03:49,560 --> 00:03:54,989
to first validate that it looks good on

00:03:51,329 --> 00:03:57,180
my local box I'll you know run it in a

00:03:54,989 --> 00:03:59,160
development environment assuming

00:03:57,180 --> 00:04:01,230
everything looks good I'll deploy to

00:03:59,160 --> 00:04:02,819
staging a staging environment is

00:04:01,230 --> 00:04:04,200
something that you know sort of

00:04:02,819 --> 00:04:06,090
production like but not really full

00:04:04,200 --> 00:04:10,530
fledged it's kind of like production

00:04:06,090 --> 00:04:12,480
light next if everything looks good

00:04:10,530 --> 00:04:15,540
maybe I'll want to validate that it

00:04:12,480 --> 00:04:17,400
behaves well under load and and to do

00:04:15,540 --> 00:04:19,400
that I'll introduce I'll you know I'll

00:04:17,400 --> 00:04:21,840
promote it to the load test environment

00:04:19,400 --> 00:04:25,350
assuming it looks both correct and

00:04:21,840 --> 00:04:27,510
performant I'll deploy to production so

00:04:25,350 --> 00:04:30,810
this is actually you know it has a lot

00:04:27,510 --> 00:04:32,280
of benefits but what's the problem so

00:04:30,810 --> 00:04:34,289
I'd like to talk first about the

00:04:32,280 --> 00:04:37,200
problems with staging the staging

00:04:34,289 --> 00:04:39,180
environment so if I'm using a staging

00:04:37,200 --> 00:04:41,190
environment this works really well at a

00:04:39,180 --> 00:04:43,110
company with five people you have one

00:04:41,190 --> 00:04:45,860
staging environment when a developer

00:04:43,110 --> 00:04:48,479
wants to make some changes they you know

00:04:45,860 --> 00:04:50,669
say declare in some way that they're

00:04:48,479 --> 00:04:53,460
using staging we used like a locking

00:04:50,669 --> 00:04:55,080
system and they deploy their changes to

00:04:53,460 --> 00:04:57,860
staging do their testing and then

00:04:55,080 --> 00:04:57,860
release the lock

00:04:58,660 --> 00:05:03,070
so the problem comes in when you go from

00:05:01,270 --> 00:05:05,620
like five developers to 50 developers

00:05:03,070 --> 00:05:09,040
and they're all trying to use the same

00:05:05,620 --> 00:05:10,900
environment what's more maybe your

00:05:09,040 --> 00:05:12,700
service has evolved maybe it used to be

00:05:10,900 --> 00:05:15,520
a single application and now you've

00:05:12,700 --> 00:05:19,630
scaled it out to you know multiple

00:05:15,520 --> 00:05:22,090
microservices that interact if I'm

00:05:19,630 --> 00:05:24,160
developer a and I'm testing a certain

00:05:22,090 --> 00:05:27,130
service and developer B is testing

00:05:24,160 --> 00:05:29,320
another service in staging can either of

00:05:27,130 --> 00:05:32,320
us really be sure of the correctness of

00:05:29,320 --> 00:05:34,900
our results but if you know if we're

00:05:32,320 --> 00:05:37,390
both testing at the same time you often

00:05:34,900 --> 00:05:38,950
run into cases where you know I can't

00:05:37,390 --> 00:05:41,650
validate that my changes are correct

00:05:38,950 --> 00:05:46,300
because the the service that he was

00:05:41,650 --> 00:05:48,070
testing is broken and more more

00:05:46,300 --> 00:05:51,600
generally staging can often be broken

00:05:48,070 --> 00:05:54,280
like who owns staging if a production

00:05:51,600 --> 00:05:57,120
service is down someone is going to get

00:05:54,280 --> 00:06:00,700
paged if a service in staging is down

00:05:57,120 --> 00:06:03,070
generally no one gets paged and you kind

00:06:00,700 --> 00:06:10,630
of have this problem of staging falling

00:06:03,070 --> 00:06:11,950
into disrepair for me so the result of

00:06:10,630 --> 00:06:15,070
all of this is that if I'm a developer

00:06:11,950 --> 00:06:16,840
and I want to test a change to source

00:06:15,070 --> 00:06:19,390
code or like I wanted to test a change

00:06:16,840 --> 00:06:20,710
that I've made to a service I often

00:06:19,390 --> 00:06:22,930
might have to spend a few hours

00:06:20,710 --> 00:06:24,550
debugging what's wrong with staging so

00:06:22,930 --> 00:06:27,610
the ROI here is kind of out of whack

00:06:24,550 --> 00:06:30,600
I've wasted a bunch of time just getting

00:06:27,610 --> 00:06:30,600
my tests to run

00:06:32,870 --> 00:06:35,900
okay now I'd like to talk about some of

00:06:34,850 --> 00:06:38,270
the challenges with a low test

00:06:35,900 --> 00:06:41,330
environment so there's a lot of

00:06:38,270 --> 00:06:44,330
advantages to doing load testing the

00:06:41,330 --> 00:06:45,950
problem is how do you maintain this so

00:06:44,330 --> 00:06:48,050
what what are the characteristics that

00:06:45,950 --> 00:06:50,600
we want in the load test environment we

00:06:48,050 --> 00:06:53,590
want a realistic data set in the

00:06:50,600 --> 00:06:57,950
datastore we want a realistic fleet size

00:06:53,590 --> 00:07:00,050
so you know in some cases this might

00:06:57,950 --> 00:07:03,080
mean one to one with production so if I

00:07:00,050 --> 00:07:05,420
have you know ten production servers I

00:07:03,080 --> 00:07:06,680
might want ten and load test as well and

00:07:05,420 --> 00:07:09,350
then I want to somehow simulate

00:07:06,680 --> 00:07:11,860
realistic production traffic and you

00:07:09,350 --> 00:07:17,600
know possibly also spiky bursty traffic

00:07:11,860 --> 00:07:21,440
to simulate surges in traffic so what

00:07:17,600 --> 00:07:24,850
are the challenges here maintaining the

00:07:21,440 --> 00:07:29,060
data set in parity with production can L

00:07:24,850 --> 00:07:30,410
can involve introducing a process to

00:07:29,060 --> 00:07:33,380
replicate the production data set from

00:07:30,410 --> 00:07:34,820
production to load test and this is

00:07:33,380 --> 00:07:36,110
something this is like another moving

00:07:34,820 --> 00:07:39,440
part this is something that someone has

00:07:36,110 --> 00:07:41,900
to maintain this is you know something

00:07:39,440 --> 00:07:43,640
that can break this is something that

00:07:41,900 --> 00:07:45,590
actually can be quite involved if you

00:07:43,640 --> 00:07:49,010
have to remove personally identifiable

00:07:45,590 --> 00:07:50,960
information from the data set what about

00:07:49,010 --> 00:07:53,810
scaling the your fleet to match

00:07:50,960 --> 00:07:55,910
production this may not be hard but it's

00:07:53,810 --> 00:07:59,780
certainly expensive if you're paying

00:07:55,910 --> 00:08:01,400
amazon one dollar for every if you're

00:07:59,780 --> 00:08:02,840
paying amazon one dollar for production

00:08:01,400 --> 00:08:04,940
you got to pay them another dollar for

00:08:02,840 --> 00:08:06,440
your load test environment so a pedro

00:08:04,940 --> 00:08:08,150
duty for a long time we had one to one

00:08:06,440 --> 00:08:10,760
parody between production and blow test

00:08:08,150 --> 00:08:12,560
we just found that it was cost

00:08:10,760 --> 00:08:14,690
prohibitive after a while it no longer

00:08:12,560 --> 00:08:18,590
made sense and then in terms of

00:08:14,690 --> 00:08:20,210
generating production like traffic if

00:08:18,590 --> 00:08:23,060
you think of all of the sources of

00:08:20,210 --> 00:08:25,490
traffic that your application

00:08:23,060 --> 00:08:29,360
has to deal with whether it's coming

00:08:25,490 --> 00:08:32,570
from users of your API users of your you

00:08:29,360 --> 00:08:35,240
know mobile app cron jobs that run in

00:08:32,570 --> 00:08:37,039
the background you can right kind of

00:08:35,240 --> 00:08:39,110
simplistic scripts that simulate

00:08:37,039 --> 00:08:44,570
production traffic but in the end how

00:08:39,110 --> 00:08:47,180
real can they really be so I'd like to

00:08:44,570 --> 00:08:49,040
talk about in contrast with the kind of

00:08:47,180 --> 00:08:50,380
conventional approach to testing web

00:08:49,040 --> 00:08:54,560
apps and less conventional approaches

00:08:50,380 --> 00:08:56,060
and some of these have gotten gained you

00:08:54,560 --> 00:08:59,150
know more widespread popularity in

00:08:56,060 --> 00:09:02,029
recent years so one idea is using local

00:08:59,150 --> 00:09:04,580
containers and other ideas using

00:09:02,029 --> 00:09:06,320
disposable environments and finally the

00:09:04,580 --> 00:09:08,570
idea of testing changes in production

00:09:06,320 --> 00:09:11,420
now these aren't mutually exclusive and

00:09:08,570 --> 00:09:15,010
in fact they're complementary and you

00:09:11,420 --> 00:09:18,610
can you can use this kind of set of

00:09:15,010 --> 00:09:23,600
approaches to replace kind of existing

00:09:18,610 --> 00:09:25,580
conventional approaches so what little

00:09:23,600 --> 00:09:27,890
containers what do I mean I mean that if

00:09:25,580 --> 00:09:31,250
I'm testing service a and has

00:09:27,890 --> 00:09:33,710
dependencies b c and d maybe i'll spin

00:09:31,250 --> 00:09:37,550
up containers for each of a b c and d on

00:09:33,710 --> 00:09:40,370
my local machine you know this has a lot

00:09:37,550 --> 00:09:42,410
of advantages first of all no more

00:09:40,370 --> 00:09:46,120
contention problems every developer can

00:09:42,410 --> 00:09:47,960
test their changes on their local box

00:09:46,120 --> 00:09:50,270
theoretically you met you may have

00:09:47,960 --> 00:09:52,370
scaling issues here if your service

00:09:50,270 --> 00:09:54,380
depends on a thousand other services or

00:09:52,370 --> 00:09:55,850
something like that you may not be able

00:09:54,380 --> 00:09:59,240
to run them all into over the box but

00:09:55,850 --> 00:10:00,810
generally it's a pretty you know a big

00:09:59,240 --> 00:10:02,680
improvement

00:10:00,810 --> 00:10:05,019
disposable environments what do I mean

00:10:02,680 --> 00:10:07,779
here I mean that if I want to test a

00:10:05,019 --> 00:10:09,970
change I press a button and I get a copy

00:10:07,779 --> 00:10:12,490
of production that I can test my change

00:10:09,970 --> 00:10:15,180
on when i'm done with testing my change

00:10:12,490 --> 00:10:18,790
i just throw away the environment so

00:10:15,180 --> 00:10:21,190
what this implies is that i've codified

00:10:18,790 --> 00:10:24,130
what my environment looks like so i have

00:10:21,190 --> 00:10:26,440
a you know you can use tools like chef

00:10:24,130 --> 00:10:28,600
or puppet to describe your

00:10:26,440 --> 00:10:30,430
infrastructure with code there's other

00:10:28,600 --> 00:10:34,720
tools that you can use to describe your

00:10:30,430 --> 00:10:37,390
entire environment the this is not

00:10:34,720 --> 00:10:39,640
necessarily as straightforward as it

00:10:37,390 --> 00:10:42,010
might seem though there's obviously a

00:10:39,640 --> 00:10:45,120
lot of moving parts here but it's

00:10:42,010 --> 00:10:47,470
another you know promising approach

00:10:45,120 --> 00:10:48,670
finally the idea of testing your changes

00:10:47,470 --> 00:10:52,600
in production so like why would you want

00:10:48,670 --> 00:10:54,790
to do this basically the the benefit

00:10:52,600 --> 00:10:56,709
here is that you know that your test the

00:10:54,790 --> 00:10:59,350
testing that you're doing has a

00:10:56,709 --> 00:11:01,300
realistic workload and a realistic

00:10:59,350 --> 00:11:02,800
environment you're going to be able to

00:11:01,300 --> 00:11:04,510
catch changes that you wouldn't be able

00:11:02,800 --> 00:11:11,560
to catch in any other pre-production

00:11:04,510 --> 00:11:13,029
type testing and you know by doing so

00:11:11,560 --> 00:11:15,399
you can really help your team to move

00:11:13,029 --> 00:11:20,980
faster and improve your ability to

00:11:15,399 --> 00:11:22,510
iterate but what you really have to be

00:11:20,980 --> 00:11:24,820
aware of is that you need risk

00:11:22,510 --> 00:11:27,420
mitigation strategies here and I'd like

00:11:24,820 --> 00:11:27,420
to talk about those

00:11:28,830 --> 00:11:35,040
so risk mitigation strategies so what I

00:11:33,150 --> 00:11:37,230
want to deal with here is the case of I

00:11:35,040 --> 00:11:40,890
I've deployed something that's broken

00:11:37,230 --> 00:11:43,560
something you know it's like a bad to

00:11:40,890 --> 00:11:45,390
play what do I want to make sure of I

00:11:43,560 --> 00:11:47,100
want to make sure of number one that

00:11:45,390 --> 00:11:49,590
someone knows almost immediately that

00:11:47,100 --> 00:11:51,750
something has gone wrong I want to know

00:11:49,590 --> 00:11:54,810
I want to make sure that the blast

00:11:51,750 --> 00:11:58,100
radius the impact on users is contained

00:11:54,810 --> 00:12:01,020
so we know you know the scale of

00:11:58,100 --> 00:12:02,310
possible affected users and we want to

00:12:01,020 --> 00:12:08,250
make sure that it's very easy to roll

00:12:02,310 --> 00:12:10,680
back so how do you know quickly that

00:12:08,250 --> 00:12:12,450
something has gone wrong here you want

00:12:10,680 --> 00:12:13,590
to leverage monitoring tools so the

00:12:12,450 --> 00:12:15,930
previous speaker actually talked about

00:12:13,590 --> 00:12:18,210
you know monitoring and the benefits

00:12:15,930 --> 00:12:21,930
that provides what you can do is you can

00:12:18,210 --> 00:12:24,630
configure monitoring tools to you know

00:12:21,930 --> 00:12:27,630
alert you when certain metrics that

00:12:24,630 --> 00:12:29,460
you're emitting exceed thresholds you

00:12:27,630 --> 00:12:32,370
want to leverage like log aggregators

00:12:29,460 --> 00:12:34,920
why are those useful well you can set up

00:12:32,370 --> 00:12:38,150
real-time searches if I see to you no

00:12:34,920 --> 00:12:41,400
more error messages than I'm used to in

00:12:38,150 --> 00:12:43,170
in my logs over the last minute let's

00:12:41,400 --> 00:12:46,830
say that's a good clue that something's

00:12:43,170 --> 00:12:48,900
gone wrong and those two inputs from

00:12:46,830 --> 00:12:50,600
monitoring tools and log aggregators can

00:12:48,900 --> 00:12:53,370
be fed into like an alerting service

00:12:50,600 --> 00:12:55,770
alerting service you know can be used to

00:12:53,370 --> 00:13:00,710
make sure that the team responsible for

00:12:55,770 --> 00:13:00,710
the the software is aware right away

00:13:02,250 --> 00:13:08,370
so that covers some good ground but we

00:13:05,320 --> 00:13:11,889
you know it's not actually sufficient

00:13:08,370 --> 00:13:13,990
one other thing that you need to think

00:13:11,889 --> 00:13:18,820
about is breaking functional behavior

00:13:13,990 --> 00:13:20,560
even if you're not necessarily you know

00:13:18,820 --> 00:13:21,810
your metrics aren't bad or you're not

00:13:20,560 --> 00:13:23,829
seeing a lot of errors in your logs

00:13:21,810 --> 00:13:26,050
functionally your product might not be

00:13:23,829 --> 00:13:28,690
the same so one thing that we invested

00:13:26,050 --> 00:13:31,480
in a page duty is end-to-end production

00:13:28,690 --> 00:13:33,639
functional testing what this means is

00:13:31,480 --> 00:13:34,690
what we did is we went through and we

00:13:33,639 --> 00:13:37,720
describe these are all the behaviors

00:13:34,690 --> 00:13:39,399
that we think our product has or should

00:13:37,720 --> 00:13:41,649
always should always be true of our

00:13:39,399 --> 00:13:44,410
product and what we did is we codified

00:13:41,649 --> 00:13:46,870
all of those expected behaviors in tests

00:13:44,410 --> 00:13:50,500
in a test suite and we have a system

00:13:46,870 --> 00:13:52,209
that basically runs that test suite

00:13:50,500 --> 00:13:54,160
continuously against our production

00:13:52,209 --> 00:13:56,649
environment so we basically treat our

00:13:54,160 --> 00:13:59,380
product as a black box and we're

00:13:56,649 --> 00:14:01,360
executing tests against it the moment

00:13:59,380 --> 00:14:04,829
that an expected behavior ceases to be

00:14:01,360 --> 00:14:04,829
true someone gets alerted

00:14:08,400 --> 00:14:16,050
and we affectionately call this system

00:14:10,560 --> 00:14:20,340
watchdog ok so once we're more confident

00:14:16,050 --> 00:14:21,780
that we'll know when something breaks we

00:14:20,340 --> 00:14:26,160
want to make sure that we limit the

00:14:21,780 --> 00:14:27,780
blast radius of any you know breakage so

00:14:26,160 --> 00:14:30,660
how do we do that one popular technique

00:14:27,780 --> 00:14:32,940
is this idea of Canary deploys so canary

00:14:30,660 --> 00:14:35,490
deploys I think the term comes from

00:14:32,940 --> 00:14:38,820
canary in the coal mine so you know if I

00:14:35,490 --> 00:14:41,040
have 10 servers in my production

00:14:38,820 --> 00:14:44,040
environment maybe I only deploy to 1 out

00:14:41,040 --> 00:14:47,910
of 10 there by knowing that I've only

00:14:44,040 --> 00:14:49,410
broken the you know only ten percent of

00:14:47,910 --> 00:14:52,380
incoming traffic is affected by the

00:14:49,410 --> 00:14:54,900
break and this in this diagram have

00:14:52,380 --> 00:14:56,970
indicated that the change software is B

00:14:54,900 --> 00:15:00,420
plus and the original version that's V

00:14:56,970 --> 00:15:02,760
and of course the Canaries can be rolled

00:15:00,420 --> 00:15:05,660
back if a break you know if there's a

00:15:02,760 --> 00:15:05,660
problem that's encountered

00:15:07,520 --> 00:15:12,450
another strategy that you can use to

00:15:09,840 --> 00:15:15,960
limit the blast radius of any problems

00:15:12,450 --> 00:15:18,870
is via feature flags so in this case the

00:15:15,960 --> 00:15:21,860
idea is rather than deploying to a

00:15:18,870 --> 00:15:24,900
subset of hosts deploy the change to all

00:15:21,860 --> 00:15:27,030
hosts but GART and you know basically

00:15:24,900 --> 00:15:29,010
the code doesn't get executed unless a

00:15:27,030 --> 00:15:34,200
feature phone the flag is true for that

00:15:29,010 --> 00:15:37,920
user so at pagerduty we use this idea to

00:15:34,200 --> 00:15:39,270
break down you know to expose three

00:15:37,920 --> 00:15:41,460
groups three different groups of users

00:15:39,270 --> 00:15:43,860
to software changes the first group is

00:15:41,460 --> 00:15:46,350
internal users so any new feature that

00:15:43,860 --> 00:15:50,430
we add to our product the first set of

00:15:46,350 --> 00:15:52,070
users that see it is internal users the

00:15:50,430 --> 00:15:56,010
next set of users would be like

00:15:52,070 --> 00:15:58,200
participants in our beta a group so

00:15:56,010 --> 00:15:59,820
people you know any cut customers that

00:15:58,200 --> 00:16:03,060
are interested in getting features as

00:15:59,820 --> 00:16:04,380
soon as possible and then lastly if

00:16:03,060 --> 00:16:07,140
things look good for those two groups

00:16:04,380 --> 00:16:09,890
will turn on the feature flag for our

00:16:07,140 --> 00:16:09,890
general user base

00:16:10,940 --> 00:16:15,770
okay so rolling back so this is you know

00:16:14,210 --> 00:16:20,120
I have made a change it's broken

00:16:15,770 --> 00:16:22,520
something how do I you know back out the

00:16:20,120 --> 00:16:25,940
key here is boring I want boring deploys

00:16:22,520 --> 00:16:28,430
I want boring rollbacks I don't I want

00:16:25,940 --> 00:16:30,010
them automated if possible I want them

00:16:28,430 --> 00:16:32,030
to be completely uneventful and

00:16:30,010 --> 00:16:33,410
completely predictable I don't want to

00:16:32,030 --> 00:16:38,330
have to remember syntax or anything like

00:16:33,410 --> 00:16:41,540
that so what we this is kind of a

00:16:38,330 --> 00:16:43,040
diagram that exemplifies the you know

00:16:41,540 --> 00:16:45,560
sort of the deployment pipeline that we

00:16:43,040 --> 00:16:47,540
use at pagerduty it you know we have a

00:16:45,560 --> 00:16:50,510
nota mated system that does the canary

00:16:47,540 --> 00:16:52,850
deploy observes if certain metrics look

00:16:50,510 --> 00:16:55,640
healthy and then either rolls back or

00:16:52,850 --> 00:16:58,340
does the full to play but it doesn't

00:16:55,640 --> 00:17:00,620
really matter what your deployment and

00:16:58,340 --> 00:17:05,150
roll back to look like as long as they

00:17:00,620 --> 00:17:07,040
are bore that's the key okay so now

00:17:05,150 --> 00:17:09,829
we've talked about risk mitigation with

00:17:07,040 --> 00:17:13,540
the testing and production strategy now

00:17:09,829 --> 00:17:16,760
let's talk about like cultural kind of

00:17:13,540 --> 00:17:17,959
issues so so the cultural ingredients

00:17:16,760 --> 00:17:20,720
that you might you might want to

00:17:17,959 --> 00:17:23,449
consider so one important thing if if

00:17:20,720 --> 00:17:26,420
you're considering like doing this type

00:17:23,449 --> 00:17:29,660
of strategy is it's very fundamental to

00:17:26,420 --> 00:17:31,760
have a DevOps mentality meaning you

00:17:29,660 --> 00:17:35,140
build it you run it that's the quote

00:17:31,760 --> 00:17:38,630
that werner vogels I think originally

00:17:35,140 --> 00:17:40,100
used and basic idea is you know I've

00:17:38,630 --> 00:17:41,330
written software I'm the one that's

00:17:40,100 --> 00:17:45,020
going to get woken up in the middle of

00:17:41,330 --> 00:17:47,680
the night if it breaks another way of

00:17:45,020 --> 00:17:47,680
putting that is

00:17:49,110 --> 00:17:56,200
sorry the the the best way to improve

00:17:52,900 --> 00:18:00,090
the quality of software is to make their

00:17:56,200 --> 00:18:00,090
engineer who wrote it responsible for it

00:18:00,810 --> 00:18:05,050
okay so the other thing the other a

00:18:03,670 --> 00:18:07,450
cultural ingredient that you need is to

00:18:05,050 --> 00:18:09,940
assess your risk tolerance so you know

00:18:07,450 --> 00:18:12,280
companies or organizations can vary on

00:18:09,940 --> 00:18:14,800
within a spectrum of risk aversion

00:18:12,280 --> 00:18:18,850
meaning the most important thing is is

00:18:14,800 --> 00:18:21,490
software stability to perhaps less

00:18:18,850 --> 00:18:24,510
risk-averse meaning the input you know

00:18:21,490 --> 00:18:28,420
the value moving fast over necessarily

00:18:24,510 --> 00:18:29,920
you know avoiding all risks and then

00:18:28,420 --> 00:18:35,470
it's important to quantify what that

00:18:29,920 --> 00:18:40,150
means so assess like what is the what

00:18:35,470 --> 00:18:42,580
kind of worst case would be acceptable

00:18:40,150 --> 00:18:44,620
from a business perspective and in terms

00:18:42,580 --> 00:18:47,620
of like percentage of affected users and

00:18:44,620 --> 00:18:50,110
in terms of its maximum of like

00:18:47,620 --> 00:18:52,480
affordable downtime is if you can

00:18:50,110 --> 00:18:54,850
quantify those numbers then you can kind

00:18:52,480 --> 00:18:57,060
of identify parameters within the

00:18:54,850 --> 00:18:57,060
process

00:18:59,940 --> 00:19:05,309
so you know what like in the real world

00:19:03,059 --> 00:19:09,149
what would this methodology be suitable

00:19:05,309 --> 00:19:10,710
for this the sort of strategy so if

00:19:09,149 --> 00:19:12,929
you're introducing a new feature this is

00:19:10,710 --> 00:19:15,210
an ideal candidate you know users aren't

00:19:12,929 --> 00:19:19,470
conditioned to expect anything of this

00:19:15,210 --> 00:19:22,139
new feature and therefore they're not

00:19:19,470 --> 00:19:26,009
like there's you know it's it's an easy

00:19:22,139 --> 00:19:27,779
thing to to add you can also add it

00:19:26,009 --> 00:19:31,409
behind a feature flag as I described so

00:19:27,779 --> 00:19:32,909
that makes it pretty convenient things

00:19:31,409 --> 00:19:35,309
like incremental changes so if I'm

00:19:32,909 --> 00:19:37,259
taking my software from state a state B

00:19:35,309 --> 00:19:40,549
I've broken it up into a spectrum of

00:19:37,259 --> 00:19:43,679
smaller changes that can be a suitable

00:19:40,549 --> 00:19:45,570
use case as well in this case I've

00:19:43,679 --> 00:19:49,200
already d risk that by making this the

00:19:45,570 --> 00:19:51,539
software change incremental and each of

00:19:49,200 --> 00:19:54,240
those smaller incremental changes you

00:19:51,539 --> 00:19:55,529
could use the strategy with finally

00:19:54,240 --> 00:19:57,480
something like a new service so I've

00:19:55,529 --> 00:20:00,929
written a new service and it's going to

00:19:57,480 --> 00:20:02,820
be eventually user facing at first I

00:20:00,929 --> 00:20:04,919
could just have it take all of its

00:20:02,820 --> 00:20:07,679
normal inputs but not produce anything

00:20:04,919 --> 00:20:09,059
any outputs or you know I could make it

00:20:07,679 --> 00:20:10,139
interact with the rests of the

00:20:09,059 --> 00:20:12,509
components that then my infrastructure

00:20:10,139 --> 00:20:13,830
but just like instead of sending any

00:20:12,509 --> 00:20:15,450
outputs it would just log them or

00:20:13,830 --> 00:20:17,669
something a lot of those lines so this

00:20:15,450 --> 00:20:20,840
is another you know pretty simple case

00:20:17,669 --> 00:20:23,039
where testing and production could work

00:20:20,840 --> 00:20:24,389
what's more difficult well mobile apps

00:20:23,039 --> 00:20:27,210
mobile apps are really difficult because

00:20:24,389 --> 00:20:29,519
there's no rollback and you know in

00:20:27,210 --> 00:20:31,110
general the mobile release cycle is

00:20:29,519 --> 00:20:34,200
quite different than something like a

00:20:31,110 --> 00:20:37,080
web app if I'm a bank I probably don't

00:20:34,200 --> 00:20:38,730
want to do this with my ATMs and that's

00:20:37,080 --> 00:20:40,590
because you know on the spectrum I'm

00:20:38,730 --> 00:20:42,980
probably way more risk averse I never

00:20:40,590 --> 00:20:45,960
wanted bad user experience with my ATM

00:20:42,980 --> 00:20:48,919
software and finally with something like

00:20:45,960 --> 00:20:48,919
a rocket you know general

00:20:49,630 --> 00:20:54,200
okay so how do you know if this is

00:20:52,670 --> 00:20:59,470
working how do you know if this is

00:20:54,200 --> 00:21:03,800
accomplishing what you expected it to

00:20:59,470 --> 00:21:06,260
generally what you'd want to see is you

00:21:03,800 --> 00:21:08,540
know a shorter development cycle and if

00:21:06,260 --> 00:21:10,430
you can measure it you should you should

00:21:08,540 --> 00:21:13,190
hope you know hopefully that metric will

00:21:10,430 --> 00:21:15,590
improve you should see more deploys more

00:21:13,190 --> 00:21:18,620
frequent deploys so measure everything

00:21:15,590 --> 00:21:20,060
this is a you know a dashboard that we

00:21:18,620 --> 00:21:21,920
actually have internally we're

00:21:20,060 --> 00:21:24,940
calculating for three services the

00:21:21,920 --> 00:21:24,940
number of deploys by date

00:21:28,679 --> 00:21:35,820
so actually to illustrate this topic

00:21:32,159 --> 00:21:38,249
with a real life example I'd like to go

00:21:35,820 --> 00:21:41,490
into a shark tangent and I call this a

00:21:38,249 --> 00:21:43,820
tale of two services so this is what

00:21:41,490 --> 00:21:46,139
actually motivated me to give this talk

00:21:43,820 --> 00:21:47,669
so do you remember the quote that I said

00:21:46,139 --> 00:21:50,129
that I mentioned at the beginning of the

00:21:47,669 --> 00:21:52,519
talk about people making two big

00:21:50,129 --> 00:21:55,769
mistakes whether or not they take risks

00:21:52,519 --> 00:21:58,740
so in the first the first service that

00:21:55,769 --> 00:22:01,740
we wrote at pay treaty this was in 2014

00:21:58,740 --> 00:22:03,389
and it was a back-end service as part of

00:22:01,740 --> 00:22:05,789
our notification pipeline it's a really

00:22:03,389 --> 00:22:06,899
high priority project at the time but of

00:22:05,789 --> 00:22:08,700
course there's always other high

00:22:06,899 --> 00:22:10,889
priority projects going on at within the

00:22:08,700 --> 00:22:11,940
company at the time and so we had to

00:22:10,889 --> 00:22:15,539
deal with contention headaches our

00:22:11,940 --> 00:22:18,080
development cycle took a long time in

00:22:15,539 --> 00:22:20,669
part due to contention in part due to

00:22:18,080 --> 00:22:23,820
rigorous kind of like expectations for

00:22:20,669 --> 00:22:25,409
low testing so we didn't really adopt

00:22:23,820 --> 00:22:28,110
any of the techniques that I described

00:22:25,409 --> 00:22:32,369
and we did we basically built the

00:22:28,110 --> 00:22:33,749
service fully in in before kind of

00:22:32,369 --> 00:22:35,940
exposing it to any production traffic

00:22:33,749 --> 00:22:39,809
and specifically we we went through a

00:22:35,940 --> 00:22:42,570
you know a long low test cycle now did

00:22:39,809 --> 00:22:44,490
we make two big mistakes sure I mean as

00:22:42,570 --> 00:22:46,409
much load temp it as much as low testing

00:22:44,490 --> 00:22:48,840
can help there's still things that you

00:22:46,409 --> 00:22:51,269
can only discover in production and we

00:22:48,840 --> 00:22:53,039
did and you know the penalty of course

00:22:51,269 --> 00:22:55,129
that we paid is that we wasted a lot of

00:22:53,039 --> 00:22:55,129
time

00:22:55,900 --> 00:23:01,390
so the second service in this tale of

00:22:59,410 --> 00:23:05,110
two services is one that we wrote this

00:23:01,390 --> 00:23:07,090
year in 2016 granted it was a little

00:23:05,110 --> 00:23:08,800
simpler of the service it was something

00:23:07,090 --> 00:23:11,860
that consumed from a data store and

00:23:08,800 --> 00:23:14,170
published a Kafka we took a different

00:23:11,860 --> 00:23:16,750
approach in this case and we decided

00:23:14,170 --> 00:23:18,250
right from the start that our goal was

00:23:16,750 --> 00:23:21,220
to get it into production as quickly as

00:23:18,250 --> 00:23:22,840
possible and you know the kind of

00:23:21,220 --> 00:23:24,130
approach that had described with a new

00:23:22,840 --> 00:23:26,500
service is the approach that we took

00:23:24,130 --> 00:23:29,140
here we had it receiving inputs from

00:23:26,500 --> 00:23:31,600
other services but not actually

00:23:29,140 --> 00:23:34,120
producing anything so not actually

00:23:31,600 --> 00:23:37,510
affecting any outputs it was

00:23:34,120 --> 00:23:39,960
containerized and you know that that

00:23:37,510 --> 00:23:43,840
made things slightly easier as well and

00:23:39,960 --> 00:23:45,490
there's you know that someone on the

00:23:43,840 --> 00:23:47,680
team had actually said the phrase prod

00:23:45,490 --> 00:23:51,430
is the best low test anyway when I was

00:23:47,680 --> 00:23:53,170
from the slack jawed so did we make two

00:23:51,430 --> 00:23:56,170
big mistakes yes we still make two

00:23:53,170 --> 00:23:59,710
victus days so I guess in this in this

00:23:56,170 --> 00:24:01,330
case we proved the quote correct but the

00:23:59,710 --> 00:24:03,130
advantage of course then what I'm trying

00:24:01,330 --> 00:24:06,210
to get at is we save time and we had it

00:24:03,130 --> 00:24:06,210
in production within two weeks

00:24:06,440 --> 00:24:10,370
so bringing it together what have I

00:24:08,539 --> 00:24:12,799
covered today so we talked today about

00:24:10,370 --> 00:24:14,360
conventional approaches to testing we

00:24:12,799 --> 00:24:17,360
talked about the strategy of testing and

00:24:14,360 --> 00:24:19,039
production we talked about how if you

00:24:17,360 --> 00:24:20,659
want to use that strategy you should

00:24:19,039 --> 00:24:23,210
really focus on reducing risk and

00:24:20,659 --> 00:24:25,820
strategies for doing that and then I

00:24:23,210 --> 00:24:29,690
talked about what this looks like in the

00:24:25,820 --> 00:24:32,360
real world so lastly I'd like to go on

00:24:29,690 --> 00:24:35,539
one more tangent and this is another

00:24:32,360 --> 00:24:37,669
tale this is a tale of a bridge the

00:24:35,539 --> 00:24:40,250
bridge in question is the silver bridge

00:24:37,669 --> 00:24:45,440
and this is a bridge that spanned

00:24:40,250 --> 00:24:47,659
spanned the Ohio River it was built in

00:24:45,440 --> 00:24:51,830
nineteen twenty-eight and it collapsed

00:24:47,659 --> 00:24:54,679
in 1967 so this this bridge actually

00:24:51,830 --> 00:24:56,740
collapsed due to wait one of the

00:24:54,679 --> 00:24:59,870
components in the bridge a load-bearing

00:24:56,740 --> 00:25:01,340
component failed and it failed because

00:24:59,870 --> 00:25:04,700
of the amount of weight that was on it

00:25:01,340 --> 00:25:06,789
in 1967 it was rush hour and you know

00:25:04,700 --> 00:25:10,309
cars were presumably bumper-to-bumper

00:25:06,789 --> 00:25:11,990
the testing that are the specs that the

00:25:10,309 --> 00:25:15,019
bridge had been built for in 1928

00:25:11,990 --> 00:25:17,000
assumed car wait you know assumed that

00:25:15,019 --> 00:25:20,179
car has had a particular mass of course

00:25:17,000 --> 00:25:21,620
cars were much heavier in 1967 so in a

00:25:20,179 --> 00:25:27,289
sense you can say this is a load testing

00:25:21,620 --> 00:25:29,750
failure the the historian Henry petrosky

00:25:27,289 --> 00:25:31,429
had the following quote the legacy of

00:25:29,750 --> 00:25:33,049
the silver bridge should be to remind

00:25:31,429 --> 00:25:35,929
engineers to proceed always with the

00:25:33,049 --> 00:25:38,059
utmost caution ever mindful of the

00:25:35,929 --> 00:25:40,460
possible existence of unknown unknowns

00:25:38,059 --> 00:25:44,149
and the possible consequences of even

00:25:40,460 --> 00:25:47,120
the smallest design decision now in

00:25:44,149 --> 00:25:49,909
light of I guess talking about software

00:25:47,120 --> 00:25:51,889
and strategies that you can use to

00:25:49,909 --> 00:25:54,139
mitigate risk and software I'd argue

00:25:51,889 --> 00:25:58,580
that this is true for bridges but not

00:25:54,139 --> 00:26:01,850
necessarily true for software so if you

00:25:58,580 --> 00:26:04,039
look at software versus bridges you know

00:26:01,850 --> 00:26:05,960
you can see that the deployments of the

00:26:04,039 --> 00:26:08,400
two things are quite different

00:26:05,960 --> 00:26:10,440
we know that roll backs are very

00:26:08,400 --> 00:26:13,470
difficult with bridges but quite easy

00:26:10,440 --> 00:26:15,600
with software we know that you know a

00:26:13,470 --> 00:26:17,910
bad deploy the bridge can be

00:26:15,600 --> 00:26:20,070
catastrophic we know that with software

00:26:17,910 --> 00:26:23,880
if you have you know the right systems

00:26:20,070 --> 00:26:25,770
in place that can be manageable and we

00:26:23,880 --> 00:26:27,840
we know that our approach with bridges

00:26:25,770 --> 00:26:29,820
should be to never fail you know you

00:26:27,840 --> 00:26:31,380
never want to have a bridge fail with

00:26:29,820 --> 00:26:33,510
software you want to make sure that if

00:26:31,380 --> 00:26:36,000
you fail you can roll back you roll back

00:26:33,510 --> 00:26:40,830
quickly and that you minimize the amount

00:26:36,000 --> 00:26:43,010
of you know the blast radius so in light

00:26:40,830 --> 00:26:45,060
of that I just like to say that the

00:26:43,010 --> 00:26:47,460
risk-averse approach that we might take

00:26:45,060 --> 00:26:48,900
with a bridge would be suitable with the

00:26:47,460 --> 00:26:51,200
bridge but not necessarily suitable

00:26:48,900 --> 00:26:51,200
let's offer

00:26:53,340 --> 00:27:10,269
[Applause]

00:26:58,440 --> 00:27:12,429
any questions well yeah so I mean we do

00:27:10,269 --> 00:27:13,659
rollbacks all the time it's actually I

00:27:12,429 --> 00:27:17,080
don't think we see it as a sign of

00:27:13,659 --> 00:27:21,659
failure I don't have a graph with that

00:27:17,080 --> 00:27:24,659
sorry maybe we should have a metric oh

00:27:21,659 --> 00:27:24,659
yeah

00:27:33,170 --> 00:27:36,920
so

00:27:34,550 --> 00:27:40,130
yeah so one of the things I mentioned

00:27:36,920 --> 00:27:42,980
was feature flags so if we did rollbacks

00:27:40,130 --> 00:27:44,150
it be us internally that are my most

00:27:42,980 --> 00:27:47,150
likely seeing the air it's a good

00:27:44,150 --> 00:27:49,520
question but I yeah in generally like we

00:27:47,150 --> 00:27:50,780
have you know the layer of different all

00:27:49,520 --> 00:27:54,940
those layers that i mentioned of

00:27:50,780 --> 00:27:58,040
strategies to prevent you know and

00:27:54,940 --> 00:28:00,470
obviously we there are cases where

00:27:58,040 --> 00:28:02,090
something slips through and affects our

00:28:00,470 --> 00:28:05,200
users but generally this idea of using

00:28:02,090 --> 00:28:08,510
feature flags for a lot of new software

00:28:05,200 --> 00:28:09,920
changes prevents external users from

00:28:08,510 --> 00:28:12,400
seeing it's generally internal users

00:28:09,920 --> 00:28:12,400
that suffer from

00:28:14,100 --> 00:28:20,539
it's it's pretty quick we i mean i'd say

00:28:18,090 --> 00:28:25,350
like five under five minutes in general

00:28:20,539 --> 00:28:28,410
we have a in general are escalated with

00:28:25,350 --> 00:28:30,500
customers we you know we I forget the

00:28:28,410 --> 00:28:33,510
number that we provide but we basically

00:28:30,500 --> 00:28:34,890
every we go into a full panic mode if

00:28:33,510 --> 00:28:36,390
things are down for more than five

00:28:34,890 --> 00:28:39,660
minutes or more than a couple minutes

00:28:36,390 --> 00:28:41,429
actually we we have a process that I

00:28:39,660 --> 00:28:44,400
didn't really talk about for resolving

00:28:41,429 --> 00:28:46,110
major incidents and that kicks off after

00:28:44,400 --> 00:28:47,549
like a few minutes of our service being

00:28:46,110 --> 00:28:52,049
unavailable so we take those very

00:28:47,549 --> 00:28:55,340
seriously maybe I should have emphasized

00:28:52,049 --> 00:28:57,840
that but I'm actually someone that I

00:28:55,340 --> 00:29:00,659
play a role of incident commander at

00:28:57,840 --> 00:29:02,730
pagerduty so that's one of the roles

00:29:00,659 --> 00:29:05,159
that I have at the company and what that

00:29:02,730 --> 00:29:07,559
means is if our service is down for a

00:29:05,159 --> 00:29:11,070
few minutes I'm getting paged and I'm

00:29:07,559 --> 00:29:13,440
organizing a conference call and I'm you

00:29:11,070 --> 00:29:15,510
know pulling in technical experts on all

00:29:13,440 --> 00:29:17,220
the different components and we're you

00:29:15,510 --> 00:29:20,520
know talking about how to quickly get

00:29:17,220 --> 00:29:21,840
back up so we take we take down time for

00:29:20,520 --> 00:29:24,440
our customers very seriously I didn't

00:29:21,840 --> 00:29:24,440
want to give that impression

00:29:25,620 --> 00:29:29,130
any other questions

00:29:32,150 --> 00:29:37,930
you

00:29:32,740 --> 00:29:37,930

YouTube URL: https://www.youtube.com/watch?v=ighPhdMHT5w


