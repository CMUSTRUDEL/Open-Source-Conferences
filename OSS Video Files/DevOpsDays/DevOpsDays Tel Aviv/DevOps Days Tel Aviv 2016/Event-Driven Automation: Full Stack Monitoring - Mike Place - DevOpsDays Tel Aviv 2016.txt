Title: Event-Driven Automation: Full Stack Monitoring - Mike Place - DevOpsDays Tel Aviv 2016
Publication date: 2017-01-23
Playlist: DevOps Days Tel Aviv 2016
Description: 
	
Captions: 
	00:00:02,920 --> 00:00:14,039
[Music]

00:00:07,940 --> 00:00:16,670
alright let's get started so that we can

00:00:14,039 --> 00:00:19,710
move through this and get into launch

00:00:16,670 --> 00:00:22,890
thank you so much for having me here i

00:00:19,710 --> 00:00:26,189
am mike place i am from Salt Lake City

00:00:22,890 --> 00:00:28,740
Utah so I am a little ways from home but

00:00:26,189 --> 00:00:31,560
it's been really wonderful to come out

00:00:28,740 --> 00:00:35,430
here i am on the core engineering team

00:00:31,560 --> 00:00:37,770
at saltstack saltstack as you know as

00:00:35,430 --> 00:00:40,109
you may know is a configuration

00:00:37,770 --> 00:00:43,800
management and server automation

00:00:40,109 --> 00:00:46,050
framework it sits in the same space as

00:00:43,800 --> 00:00:48,420
our friends at chef and puppet and

00:00:46,050 --> 00:00:51,600
danceable and what have you salt is a

00:00:48,420 --> 00:00:55,620
python-based open source project it's on

00:00:51,600 --> 00:00:57,899
github and yeah so I maintain that

00:00:55,620 --> 00:01:00,570
project if you're a solid contributor

00:00:57,899 --> 00:01:03,120
thank you very much I do appreciate it

00:01:00,570 --> 00:01:05,940
on the guy that reviews all the pull

00:01:03,120 --> 00:01:08,690
requests and what have you so today I

00:01:05,940 --> 00:01:12,450
want to talk about event-driven

00:01:08,690 --> 00:01:14,880
infrastructure and one of the things

00:01:12,450 --> 00:01:17,990
that we try to do in our office is make

00:01:14,880 --> 00:01:21,870
sure that everything is question driven

00:01:17,990 --> 00:01:24,930
we have a philosophy that it's much

00:01:21,870 --> 00:01:28,470
better to focus on asking the right

00:01:24,930 --> 00:01:31,590
question than trying to rush to a quick

00:01:28,470 --> 00:01:33,900
answer and so as I prepared this

00:01:31,590 --> 00:01:36,720
presentation one of the things that I've

00:01:33,900 --> 00:01:39,390
tried to do is leave many of the

00:01:36,720 --> 00:01:41,690
conclusions somewhat open-ended and so

00:01:39,390 --> 00:01:44,280
it's my hope that at the end of this

00:01:41,690 --> 00:01:48,300
even if we don't wrap things up into a

00:01:44,280 --> 00:01:50,910
nice bow that at least hopefully you'll

00:01:48,300 --> 00:01:54,480
have some questions that you can take

00:01:50,910 --> 00:01:57,030
back to your teams to to ask them and

00:01:54,480 --> 00:01:59,580
ask yourselves about the way you've

00:01:57,030 --> 00:02:03,120
designed your infrastructure and the way

00:01:59,580 --> 00:02:06,000
you do things day to day so I want to

00:02:03,120 --> 00:02:08,899
start with a statement automation

00:02:06,000 --> 00:02:13,130
brought us new tool chains and DevOps

00:02:08,899 --> 00:02:15,860
brought us new culture well what now

00:02:13,130 --> 00:02:19,340
and one of the things that I've come to

00:02:15,860 --> 00:02:23,600
realize as I go from place to place is

00:02:19,340 --> 00:02:26,360
that one of the important ways to look

00:02:23,600 --> 00:02:30,560
at computing and modern infrastructure

00:02:26,360 --> 00:02:32,690
and even modern culture is to ask where

00:02:30,560 --> 00:02:35,780
it is that we've been where has all of

00:02:32,690 --> 00:02:38,330
this come from for example when we

00:02:35,780 --> 00:02:41,120
talked we spent most of 2016 talking

00:02:38,330 --> 00:02:42,560
about docker and containers and we have

00:02:41,120 --> 00:02:44,330
to ask ourselves first in order to

00:02:42,560 --> 00:02:46,490
understand dr. in containers where did

00:02:44,330 --> 00:02:49,010
all of this come from right and of

00:02:46,490 --> 00:02:51,740
course the answer is that you know that

00:02:49,010 --> 00:02:54,110
stuff is built on technology that is now

00:02:51,740 --> 00:02:56,600
many years old started with the chroot

00:02:54,110 --> 00:02:59,390
GL's and went to embassy groups and so

00:02:56,600 --> 00:03:01,520
on and so forth and one of the things

00:02:59,390 --> 00:03:04,610
are one of the technologies that I think

00:03:01,520 --> 00:03:07,670
the stura modern infrastructure is built

00:03:04,610 --> 00:03:10,340
on are the principles of distributed

00:03:07,670 --> 00:03:12,890
computing and so I want to start by

00:03:10,340 --> 00:03:16,070
talking a little bit about distributed

00:03:12,890 --> 00:03:18,440
computing before we lead into the idea

00:03:16,070 --> 00:03:21,110
of event-driven automation and what it

00:03:18,440 --> 00:03:24,320
can do for us so I think there are three

00:03:21,110 --> 00:03:26,540
pillars of distributed computing the

00:03:24,320 --> 00:03:29,270
first the ability for the system to be

00:03:26,540 --> 00:03:32,210
aware of the existence and capability of

00:03:29,270 --> 00:03:35,750
its member nodes right we call this

00:03:32,210 --> 00:03:38,870
service discovery all right the second

00:03:35,750 --> 00:03:42,170
the ability to coordinate tasks between

00:03:38,870 --> 00:03:45,650
those nodes right we call this a

00:03:42,170 --> 00:03:48,770
scheduler the last is inter process

00:03:45,650 --> 00:03:52,070
communication which can connect almost

00:03:48,770 --> 00:03:53,240
any node in the system to any other now

00:03:52,070 --> 00:03:55,520
when I talk about distributed computing

00:03:53,240 --> 00:03:57,500
sometimes people think i'm talking about

00:03:55,520 --> 00:03:59,540
parallel computing which share memory

00:03:57,500 --> 00:04:02,800
architectures and all of that I'm not

00:03:59,540 --> 00:04:05,660
I'm talking simply about any sort of

00:04:02,800 --> 00:04:09,260
computing infrastructure which contains

00:04:05,660 --> 00:04:11,840
these three components and I think that

00:04:09,260 --> 00:04:14,900
if you think about that modern

00:04:11,840 --> 00:04:17,660
infrastructure simply in these simple

00:04:14,900 --> 00:04:21,140
terms you'll start to recognize these

00:04:17,660 --> 00:04:23,510
principles in the infrastructure that

00:04:21,140 --> 00:04:26,620
you've built today for example going

00:04:23,510 --> 00:04:29,540
back to containerization

00:04:26,620 --> 00:04:31,580
one of the ways that that I think about

00:04:29,540 --> 00:04:33,890
containerization is simply moving back

00:04:31,580 --> 00:04:36,860
to the idea of a distributed operating

00:04:33,890 --> 00:04:39,500
system and thinking about a container as

00:04:36,860 --> 00:04:42,500
a single process on that operating

00:04:39,500 --> 00:04:44,330
system and if you do so I think you have

00:04:42,500 --> 00:04:46,610
to ask yourself okay fine I've got all

00:04:44,330 --> 00:04:48,830
these processes running on a distributed

00:04:46,610 --> 00:04:50,750
system what's the inter process

00:04:48,830 --> 00:04:52,430
communication mechanism going to look

00:04:50,750 --> 00:04:56,330
like and that's what we're going to talk

00:04:52,430 --> 00:04:59,060
about today IPC in a distributed

00:04:56,330 --> 00:05:02,180
operating system is effectively just

00:04:59,060 --> 00:05:06,290
called a message bus and message buses I

00:05:02,180 --> 00:05:08,690
think are a critical component that we

00:05:06,290 --> 00:05:11,000
don't talk enough about so what are the

00:05:08,690 --> 00:05:14,630
properties of a message bus first a

00:05:11,000 --> 00:05:16,340
message bus has a data model write it we

00:05:14,630 --> 00:05:18,410
know how to exchange data between

00:05:16,340 --> 00:05:20,000
processes between nodes on these

00:05:18,410 --> 00:05:22,250
operating systems because effectively

00:05:20,000 --> 00:05:24,320
they speak the same language we have a

00:05:22,250 --> 00:05:27,530
command set for communicating that data

00:05:24,320 --> 00:05:30,500
right in regular IPC you know this all

00:05:27,530 --> 00:05:32,990
comes from the C library and we have a

00:05:30,500 --> 00:05:38,480
transport infrastructure to communicate

00:05:32,990 --> 00:05:41,480
that data between endpoints so trying to

00:05:38,480 --> 00:05:43,880
connect this back to DevOps right which

00:05:41,480 --> 00:05:45,770
is what we're here to discuss I'm going

00:05:43,880 --> 00:05:50,060
to make the claim that we already have

00:05:45,770 --> 00:05:52,130
message buses built for operations okay

00:05:50,060 --> 00:05:55,040
what are those message buses well we

00:05:52,130 --> 00:05:56,960
have things like monitoring right we

00:05:55,040 --> 00:05:59,330
have central nodes which go out and try

00:05:56,960 --> 00:06:01,460
to connect to services figure out what

00:05:59,330 --> 00:06:04,700
the state of those services are we have

00:06:01,460 --> 00:06:07,070
services which report their state back

00:06:04,700 --> 00:06:09,680
to central aggregation points to do

00:06:07,070 --> 00:06:11,270
graphing and what have you we have

00:06:09,680 --> 00:06:13,880
configuration management which i think

00:06:11,270 --> 00:06:17,330
is a logical message bus for ops message

00:06:13,880 --> 00:06:19,480
bus excuse me for operations the notion

00:06:17,330 --> 00:06:22,370
that we have a command and control

00:06:19,480 --> 00:06:25,460
system that can perform remote execution

00:06:22,370 --> 00:06:28,880
tasks on remote remote nodes and report

00:06:25,460 --> 00:06:31,580
back the status of those tasks we have

00:06:28,880 --> 00:06:33,440
things like chat ops we can do things

00:06:31,580 --> 00:06:36,320
like auto scaling across this message

00:06:33,440 --> 00:06:39,050
bus right we have for example Amazon's

00:06:36,320 --> 00:06:40,150
lambda which is a wonderful example of

00:06:39,050 --> 00:06:44,689
what a message bus

00:06:40,150 --> 00:06:46,990
can and can do in modern infrastructure

00:06:44,689 --> 00:06:49,550
and of course one of the primary

00:06:46,990 --> 00:06:54,949
responsibilities of a message but for

00:06:49,550 --> 00:06:56,629
operations is provisioning right it's a

00:06:54,949 --> 00:06:59,419
common framework that has the properties

00:06:56,629 --> 00:07:01,819
discussed before that can provision new

00:06:59,419 --> 00:07:05,060
hosts new containers new services what

00:07:01,819 --> 00:07:07,669
have you so I think on the other side of

00:07:05,060 --> 00:07:09,740
that we also have message buses for

00:07:07,669 --> 00:07:12,830
developers or better put for

00:07:09,740 --> 00:07:14,629
applications all right anything that

00:07:12,830 --> 00:07:17,840
connects various lovers levels of an

00:07:14,629 --> 00:07:21,770
application stack I think has a message

00:07:17,840 --> 00:07:24,110
bus of some kind right sometimes these

00:07:21,770 --> 00:07:26,539
are simply streaming api's between

00:07:24,110 --> 00:07:29,449
services sometimes they're set up and

00:07:26,539 --> 00:07:31,699
torn down on demand but the question

00:07:29,449 --> 00:07:34,339
that I want or the first question that I

00:07:31,699 --> 00:07:35,659
want us to consider about our own

00:07:34,339 --> 00:07:39,379
infrastructures and consider bringing

00:07:35,659 --> 00:07:41,289
back to our teams in DevOps we talk a

00:07:39,379 --> 00:07:44,389
lot about connecting these two sides

00:07:41,289 --> 00:07:46,849
well what happens if we examine both of

00:07:44,389 --> 00:07:48,409
those types of message buses and we

00:07:46,849 --> 00:07:51,229
consider the possibilities that could

00:07:48,409 --> 00:07:53,629
emerge when those formerly siloed

00:07:51,229 --> 00:07:57,560
streams of events are shared with each

00:07:53,629 --> 00:07:59,930
other right what happens if we give our

00:07:57,560 --> 00:08:02,810
configuration management layer insight

00:07:59,930 --> 00:08:05,569
and understanding into the monitoring

00:08:02,810 --> 00:08:07,009
layer for example those are the sorts of

00:08:05,569 --> 00:08:11,060
questions were going to be discussing

00:08:07,009 --> 00:08:14,300
for the rest of this talk so the first

00:08:11,060 --> 00:08:16,569
question is what does most automation

00:08:14,300 --> 00:08:19,580
look like right now I spend all my day

00:08:16,569 --> 00:08:21,560
building full stack and I think about

00:08:19,580 --> 00:08:23,779
this question from time to time most

00:08:21,560 --> 00:08:26,689
automation right now is effectively

00:08:23,779 --> 00:08:29,419
packaged workflows do you remember early

00:08:26,689 --> 00:08:31,959
on back in the sort of the birth of

00:08:29,419 --> 00:08:35,690
DevOps as it were we were promised

00:08:31,959 --> 00:08:37,640
infrastructure as code right and that

00:08:35,690 --> 00:08:39,669
sounded really nice at the time I

00:08:37,640 --> 00:08:43,669
thought well that's very attractive and

00:08:39,669 --> 00:08:45,980
what we got effectively and much of this

00:08:43,669 --> 00:08:49,610
is is my fault if you want to lay some

00:08:45,980 --> 00:08:51,050
some blame is we got you know sort of

00:08:49,610 --> 00:08:53,630
series of steps that we would list out

00:08:51,050 --> 00:08:54,980
we would go do these steps a little bit

00:08:53,630 --> 00:08:57,410
we had a little bit of abstraction we

00:08:54,980 --> 00:09:00,230
had a little bit of error control we had

00:08:57,410 --> 00:09:02,660
a lot of effectively imperative

00:09:00,230 --> 00:09:04,490
frameworks right we would say okay this

00:09:02,660 --> 00:09:05,900
is how we can describe an infrastructure

00:09:04,490 --> 00:09:07,250
and we're going to use you know and the

00:09:05,900 --> 00:09:09,530
debate is really going to be Oh shall we

00:09:07,250 --> 00:09:12,680
use ya moul or JSON or should we use a

00:09:09,530 --> 00:09:15,320
DSL to describe this infrastructure and

00:09:12,680 --> 00:09:17,060
much of the time this was focused around

00:09:15,320 --> 00:09:20,530
provisioning these workflows were

00:09:17,060 --> 00:09:23,450
effectively initiated by lazy humans and

00:09:20,530 --> 00:09:26,180
I think even today it's fair to say that

00:09:23,450 --> 00:09:29,330
despite our best efforts the stuff can

00:09:26,180 --> 00:09:31,130
be very brittle and the reason that it's

00:09:29,330 --> 00:09:33,110
brittle I think at the end of the day

00:09:31,130 --> 00:09:35,270
something that should be obvious if we

00:09:33,110 --> 00:09:37,670
think about it which is that despite all

00:09:35,270 --> 00:09:39,650
our best efforts at monitoring and

00:09:37,670 --> 00:09:41,300
looking at graphs and trying to have

00:09:39,650 --> 00:09:44,810
stand-ups and what-have-you during the

00:09:41,300 --> 00:09:47,170
day we're still not really great at

00:09:44,810 --> 00:09:50,240
understanding the state of our systems

00:09:47,170 --> 00:09:53,170
especially the state of the system at

00:09:50,240 --> 00:09:55,460
the point that we engage automation

00:09:53,170 --> 00:09:58,400
right we still make a lot of assumptions

00:09:55,460 --> 00:10:00,950
either even today and you know for

00:09:58,400 --> 00:10:02,570
example like in the salt world you know

00:10:00,950 --> 00:10:05,510
some of the questions are like okay well

00:10:02,570 --> 00:10:08,120
how do I you know test and make sure my

00:10:05,510 --> 00:10:09,950
infrastructure is in a proper state

00:10:08,120 --> 00:10:12,800
before I run it well you can go out and

00:10:09,950 --> 00:10:15,920
you can test against you know your

00:10:12,800 --> 00:10:18,590
intended declaration and that gives you

00:10:15,920 --> 00:10:20,660
a binary answer about you know yes or no

00:10:18,590 --> 00:10:23,690
am I in compliance but that's not a

00:10:20,660 --> 00:10:25,820
particularly in depth understanding of

00:10:23,690 --> 00:10:28,070
what's going on and I think most

00:10:25,820 --> 00:10:30,680
importantly this doesn't really feel

00:10:28,070 --> 00:10:32,510
much like programming right and when

00:10:30,680 --> 00:10:35,300
DevOps launched I was promised

00:10:32,510 --> 00:10:38,570
infrastructure as code and what I got

00:10:35,300 --> 00:10:42,200
was you know again this declarative

00:10:38,570 --> 00:10:44,840
imperative debate but what I wanted was

00:10:42,200 --> 00:10:46,580
you know code real code I wanted to be

00:10:44,840 --> 00:10:49,310
able to do things like callbacks right

00:10:46,580 --> 00:10:53,240
and introduce some a synchronicity and

00:10:49,310 --> 00:10:56,810
actually be able to program my

00:10:53,240 --> 00:10:59,360
infrastructure beyond simply declaring

00:10:56,810 --> 00:11:02,420
what this provisioning state ought to

00:10:59,360 --> 00:11:04,010
look like so the question that I want to

00:11:02,420 --> 00:11:06,810
focus on for the rest of this is okay

00:11:04,010 --> 00:11:10,529
how can we move beyond that how can

00:11:06,810 --> 00:11:13,470
how can we extend that model so the area

00:11:10,529 --> 00:11:15,470
that I look at in thinking about this is

00:11:13,470 --> 00:11:17,580
event-driven programming right

00:11:15,470 --> 00:11:18,840
event-driven programming for people

00:11:17,580 --> 00:11:20,640
don't know it's a paradigm where the

00:11:18,840 --> 00:11:23,029
flow of the program is determined by

00:11:20,640 --> 00:11:25,200
events right by user actions

00:11:23,029 --> 00:11:27,210
event-driven programming is probably

00:11:25,200 --> 00:11:28,980
made most famous by you know people that

00:11:27,210 --> 00:11:32,220
write gooeys as much as I I don't like

00:11:28,980 --> 00:11:34,800
Dewey's you know effectively you

00:11:32,220 --> 00:11:37,080
register for events right you wait for

00:11:34,800 --> 00:11:41,460
them to occur and when they do occur you

00:11:37,080 --> 00:11:42,330
perform some action right so what are

00:11:41,460 --> 00:11:46,440
the principles of event-driven

00:11:42,330 --> 00:11:49,080
programming right note jf was was very

00:11:46,440 --> 00:11:51,320
early to this party like I mentioned

00:11:49,080 --> 00:11:53,490
most GUI applications on the desktop

00:11:51,320 --> 00:11:55,140
have some form of event driven

00:11:53,490 --> 00:11:59,220
programming and pretty much anything on

00:11:55,140 --> 00:12:01,740
iOS right is all event-driven and as

00:11:59,220 --> 00:12:04,820
horrible as all of that stuff is I think

00:12:01,740 --> 00:12:06,839
there is a lesson for us here right

00:12:04,820 --> 00:12:08,339
there are three principles in

00:12:06,839 --> 00:12:11,100
event-driven programming that I think

00:12:08,339 --> 00:12:13,250
are worth noting first you have a set of

00:12:11,100 --> 00:12:15,180
functions which can handle events right

00:12:13,250 --> 00:12:16,589
depending on the implementation these

00:12:15,180 --> 00:12:18,870
can be blocking they can be non blocking

00:12:16,589 --> 00:12:22,050
what have you you need a mechanism for

00:12:18,870 --> 00:12:25,650
binding registered functions to events

00:12:22,050 --> 00:12:28,050
all right and last you need main loop or

00:12:25,650 --> 00:12:29,610
loops if you're very brave which can

00:12:28,050 --> 00:12:31,620
consistently pole for two events and

00:12:29,610 --> 00:12:33,600
call matching event handlers that can

00:12:31,620 --> 00:12:37,350
take action whenever an event is

00:12:33,600 --> 00:12:39,660
received now I think it's important to

00:12:37,350 --> 00:12:41,970
be honest and talk about the criticisms

00:12:39,660 --> 00:12:44,850
of aventurine programming of which there

00:12:41,970 --> 00:12:46,710
are many all right one is that the

00:12:44,850 --> 00:12:49,950
writing procedures to perform steps in a

00:12:46,710 --> 00:12:51,980
particular order is not always easy this

00:12:49,950 --> 00:12:54,180
is in it the imperative side of things

00:12:51,980 --> 00:12:55,589
on the other side we have declarative

00:12:54,180 --> 00:12:59,040
right we're describing the intended

00:12:55,589 --> 00:13:01,800
state of a system without explicit about

00:12:59,040 --> 00:13:03,810
explicitly describing the steps to

00:13:01,800 --> 00:13:06,660
achieve that state that's the

00:13:03,810 --> 00:13:09,290
declarative approach highly asynchronous

00:13:06,660 --> 00:13:13,560
code can be difficult to troubleshoot I

00:13:09,290 --> 00:13:15,089
think that's true wherever you go and it

00:13:13,560 --> 00:13:16,830
takes a mind shift to think about

00:13:15,089 --> 00:13:19,440
imperative and declarative approaches

00:13:16,830 --> 00:13:19,890
melded into one which i think is what

00:13:19,440 --> 00:13:22,510
event

00:13:19,890 --> 00:13:24,370
programming ultimately looks like and

00:13:22,510 --> 00:13:26,020
that can create some confusion and it

00:13:24,370 --> 00:13:28,180
could be challenging to translate

00:13:26,020 --> 00:13:31,630
procedural work flows into something

00:13:28,180 --> 00:13:33,400
asynchronous and event-driven but I

00:13:31,630 --> 00:13:34,650
think at the same time the event driven

00:13:33,400 --> 00:13:36,820
programming has a number of advantages

00:13:34,650 --> 00:13:39,970
first I think it's easy to find natural

00:13:36,820 --> 00:13:41,850
dividing lines for unit testing one's

00:13:39,970 --> 00:13:44,640
infrastructure it's highly composable

00:13:41,850 --> 00:13:47,110
and I think most importantly

00:13:44,640 --> 00:13:48,850
event-driven programming or as will see

00:13:47,110 --> 00:13:55,350
a mentoring and infrastructure makes it

00:13:48,850 --> 00:13:58,660
very easy and simple to have a common a

00:13:55,350 --> 00:14:02,530
common platform for both the dev side

00:13:58,660 --> 00:14:08,710
and the op side to speak ok so if you

00:14:02,530 --> 00:14:11,890
have a singular message bus a singular

00:14:08,710 --> 00:14:14,680
plane for your application to put

00:14:11,890 --> 00:14:16,900
telemetry events on to that for example

00:14:14,680 --> 00:14:19,780
your config management system can dip

00:14:16,900 --> 00:14:22,720
into all of a sudden you can have these

00:14:19,780 --> 00:14:26,620
formerly siloed components listening for

00:14:22,720 --> 00:14:28,180
events and reacting accordingly and it's

00:14:26,620 --> 00:14:33,010
the breakdown of these silos that I

00:14:28,180 --> 00:14:34,089
think has a tremendous potential ok yeah

00:14:33,010 --> 00:14:35,860
I mentioned that it's a good way to

00:14:34,089 --> 00:14:39,820
model systems that need to be both

00:14:35,860 --> 00:14:41,980
asynchronous and reactive so to conclude

00:14:39,820 --> 00:14:44,740
this definition a high-speed event bus

00:14:41,980 --> 00:14:45,970
Plus event-driven programming brings us

00:14:44,740 --> 00:14:49,089
a concept called event-driven

00:14:45,970 --> 00:14:53,589
infrastructure so the question is what

00:14:49,089 --> 00:14:54,940
can this help us do well many things but

00:14:53,589 --> 00:14:57,370
few of those things are things like

00:14:54,940 --> 00:14:59,589
gating deploys behind the operational

00:14:57,370 --> 00:15:01,839
state of the network right right now we

00:14:59,589 --> 00:15:03,280
sort of look at graphs and go ok it's

00:15:01,839 --> 00:15:05,560
going to be okay I think this is going

00:15:03,280 --> 00:15:07,600
to be ok but we can introduce automation

00:15:05,560 --> 00:15:10,990
into that step because in theory we know

00:15:07,600 --> 00:15:14,050
what constitutes a state that's ok to

00:15:10,990 --> 00:15:15,700
deploy one that's not we can react to

00:15:14,050 --> 00:15:17,890
service degradation by performing a

00:15:15,700 --> 00:15:20,170
checklist right there was just an ignite

00:15:17,890 --> 00:15:22,000
about this concept of network operations

00:15:20,170 --> 00:15:23,740
center in which you know we have people

00:15:22,000 --> 00:15:25,510
that sit and when a bad thing happens

00:15:23,740 --> 00:15:26,980
they go through and they look at their

00:15:25,510 --> 00:15:28,570
checklist and then they do those things

00:15:26,980 --> 00:15:32,650
well we ought to be able to automate all

00:15:28,570 --> 00:15:33,470
of that and I believe that most

00:15:32,650 --> 00:15:36,410
interestingly

00:15:33,470 --> 00:15:38,210
we can in creating a message bus that

00:15:36,410 --> 00:15:41,660
both our application developers can use

00:15:38,210 --> 00:15:44,420
and our ops folks can use we can create

00:15:41,660 --> 00:15:46,400
the ability to tune the application to

00:15:44,420 --> 00:15:48,980
the health of the infrastructure or you

00:15:46,400 --> 00:15:51,770
know vice versa so what are the

00:15:48,980 --> 00:15:54,050
principles we're talking about here on a

00:15:51,770 --> 00:15:57,170
shared event bus we have events which

00:15:54,050 --> 00:15:59,720
originate from applications and from

00:15:57,170 --> 00:16:02,300
systems we have filters to sort those

00:15:59,720 --> 00:16:04,970
events and apply rules to them and as

00:16:02,300 --> 00:16:08,690
rules are met registered at excuse me

00:16:04,970 --> 00:16:10,220
registered actions occur again I want to

00:16:08,690 --> 00:16:13,550
run through the disadvantages because

00:16:10,220 --> 00:16:15,110
they're both there's potential for tight

00:16:13,550 --> 00:16:17,570
coupling between the event schema and

00:16:15,110 --> 00:16:19,340
consumers of the schema there's very

00:16:17,570 --> 00:16:22,790
much the potential for message loss

00:16:19,340 --> 00:16:24,710
especially at scale and it's again

00:16:22,790 --> 00:16:26,690
difficult to reason sometimes about what

00:16:24,710 --> 00:16:32,270
blocking operations might look like in

00:16:26,690 --> 00:16:36,320
this model and hopefully I can go

00:16:32,270 --> 00:16:39,350
forward here there we go advantages I

00:16:36,320 --> 00:16:41,290
think an event driven approach for

00:16:39,350 --> 00:16:45,050
infrastructure management is distributed

00:16:41,290 --> 00:16:46,640
scalable and loosely coupled it

00:16:45,050 --> 00:16:50,000
effectively functions as a DevOps

00:16:46,640 --> 00:16:52,730
automation black backplane for a system

00:16:50,000 --> 00:16:54,140
and it does more than just configuring

00:16:52,730 --> 00:16:56,180
and provisioning systems at their birth

00:16:54,140 --> 00:16:59,780
which I think has traditionally been the

00:16:56,180 --> 00:17:01,760
focus of automation space we talked

00:16:59,780 --> 00:17:04,010
about how to provision things how to

00:17:01,760 --> 00:17:06,290
orchestrate them at their birth we don't

00:17:04,010 --> 00:17:09,140
do a very good job at thinking about

00:17:06,290 --> 00:17:11,930
what the whole life cycle of a system is

00:17:09,140 --> 00:17:14,900
going to be and it provides an immediate

00:17:11,930 --> 00:17:16,310
common programmable layer on top of the

00:17:14,900 --> 00:17:20,290
existing automation and deployment

00:17:16,310 --> 00:17:23,390
systems fine so how do we build one

00:17:20,290 --> 00:17:24,860
through much of this this conference

00:17:23,390 --> 00:17:26,360
I've heard people say again and again

00:17:24,860 --> 00:17:27,620
that you should never build your own

00:17:26,360 --> 00:17:29,750
tools that you should always take

00:17:27,620 --> 00:17:33,140
something off the shelf I think that's

00:17:29,750 --> 00:17:36,740
completely fine but at the same time I

00:17:33,140 --> 00:17:38,690
don't think that you necessarily need to

00:17:36,740 --> 00:17:41,990
go and deploy kafka if your needs are

00:17:38,690 --> 00:17:44,270
small a and B I think that it's

00:17:41,990 --> 00:17:46,430
important to understand how one might

00:17:44,270 --> 00:17:48,710
build a system themselves

00:17:46,430 --> 00:17:52,100
off before they go out and decide to

00:17:48,710 --> 00:17:55,580
just use something so we need a couple

00:17:52,100 --> 00:17:57,290
of things we need slow we need an event

00:17:55,580 --> 00:17:59,510
to be emitted on this bus that would

00:17:57,290 --> 00:18:01,190
flow to a manager and we need the

00:17:59,510 --> 00:18:04,070
manager to check and see if the event

00:18:01,190 --> 00:18:06,410
matches a registered Handler if it does

00:18:04,070 --> 00:18:08,240
match we need a series of rules to check

00:18:06,410 --> 00:18:09,680
and for each set of rules which are

00:18:08,240 --> 00:18:11,930
matched we need an action to be

00:18:09,680 --> 00:18:14,000
undertaken forgive me as I speed up

00:18:11,930 --> 00:18:17,780
because I am running a little bit low on

00:18:14,000 --> 00:18:21,380
time so the moving pieces here we have

00:18:17,780 --> 00:18:24,490
an event bus transport right we have a

00:18:21,380 --> 00:18:26,870
telemetry alright which is the

00:18:24,490 --> 00:18:28,730
monitoring that's emitted on to this bus

00:18:26,870 --> 00:18:31,700
either from the applications or from the

00:18:28,730 --> 00:18:34,760
systems which right underneath it we

00:18:31,700 --> 00:18:37,850
have actors right which take these

00:18:34,760 --> 00:18:40,880
events and perform actions on them and

00:18:37,850 --> 00:18:43,040
reactors which can react to events as

00:18:40,880 --> 00:18:45,590
they flow in so how do we build one of

00:18:43,040 --> 00:18:49,820
these we need to handle a couple of

00:18:45,590 --> 00:18:51,560
concerns we must handle security dep

00:18:49,820 --> 00:18:53,660
that's a long conversation and one that

00:18:51,560 --> 00:18:55,780
we don't have time for in the scope of

00:18:53,660 --> 00:18:58,340
this but we can discuss it later on

00:18:55,780 --> 00:19:00,800
reliability we need to be able to

00:18:58,340 --> 00:19:03,140
serialize data on this bus because again

00:19:00,800 --> 00:19:04,820
we need a common data model and we need

00:19:03,140 --> 00:19:07,640
me an easy set of interfaces for sending

00:19:04,820 --> 00:19:09,710
and receiving with libraries shared with

00:19:07,640 --> 00:19:12,530
languages on the dev side and on the

00:19:09,710 --> 00:19:14,000
outside we need to support multiple

00:19:12,530 --> 00:19:15,620
architectures and we need to be able to

00:19:14,000 --> 00:19:17,900
do message filtering and message routing

00:19:15,620 --> 00:19:20,900
and what have you so in terms of

00:19:17,900 --> 00:19:22,580
topology typically message buses of this

00:19:20,900 --> 00:19:25,460
type or pub subs right there one too

00:19:22,580 --> 00:19:28,430
many most implementations are brokered

00:19:25,460 --> 00:19:31,850
right so they're loosely coupled you

00:19:28,430 --> 00:19:33,620
know you can use dds what have you or

00:19:31,850 --> 00:19:35,990
you can also do push poll which is

00:19:33,620 --> 00:19:39,290
effectively one-to-one if you look at

00:19:35,990 --> 00:19:41,090
typical off-the-shelf message buses

00:19:39,290 --> 00:19:43,820
which we'll get to in a second they

00:19:41,090 --> 00:19:45,110
support models for both and so if you

00:19:43,820 --> 00:19:47,900
want to pull one of these off the shelf

00:19:45,110 --> 00:19:50,420
and use them there are a number of them

00:19:47,900 --> 00:19:51,920
most of them are simply language

00:19:50,420 --> 00:19:55,790
bindings and that's you know stuff like

00:19:51,920 --> 00:19:58,250
zeromq what-have-you activemq or you can

00:19:55,790 --> 00:19:59,630
get sort of full shelf solutions and

00:19:58,250 --> 00:20:03,140
that stuff life call

00:19:59,630 --> 00:20:05,300
go or lambda in the cloud or of course

00:20:03,140 --> 00:20:08,720
saltstack which I happen to like quite a

00:20:05,300 --> 00:20:11,540
lot so on the telemetry side we need the

00:20:08,720 --> 00:20:14,840
ability for applications to admit events

00:20:11,540 --> 00:20:18,290
onto the bus all right which means that

00:20:14,840 --> 00:20:20,780
we need little plugins effectively that

00:20:18,290 --> 00:20:23,180
we can hand over to our developers and

00:20:20,780 --> 00:20:26,600
say ok when you want to emit an event on

00:20:23,180 --> 00:20:29,480
to this bus simply fire this bit of code

00:20:26,600 --> 00:20:31,040
all right it should be light and easy

00:20:29,480 --> 00:20:33,260
enough that it's simple to pour it into

00:20:31,040 --> 00:20:35,330
any language and it should just be

00:20:33,260 --> 00:20:37,760
lightweight messaging this is not the

00:20:35,330 --> 00:20:40,730
place to push you know megabytes of data

00:20:37,760 --> 00:20:43,360
around by any means so I want to

00:20:40,730 --> 00:20:47,900
illustrate how simple this is to do in

00:20:43,360 --> 00:20:49,610
in something like Python and zeromq to

00:20:47,900 --> 00:20:52,390
create a message bus and start to push

00:20:49,610 --> 00:20:55,520
data on to it that's really all you need

00:20:52,390 --> 00:20:58,430
it's you know you can do it in 10 to 15

00:20:55,520 --> 00:21:00,440
lines of code so this is not something

00:20:58,430 --> 00:21:02,900
where you need a ton of programming

00:21:00,440 --> 00:21:05,450
experience to make happen in your

00:21:02,900 --> 00:21:09,130
infrastructure how do you build a

00:21:05,450 --> 00:21:13,730
reactor this is me quoting me on twitter

00:21:09,130 --> 00:21:18,290
which is that building reactors or you

00:21:13,730 --> 00:21:20,120
know effectively rules engines can be

00:21:18,290 --> 00:21:22,010
somewhat difficult but it doesn't

00:21:20,120 --> 00:21:23,720
necessarily have to be because the

00:21:22,010 --> 00:21:25,940
decision engine right something that

00:21:23,720 --> 00:21:29,900
takes events and chooses when to react

00:21:25,940 --> 00:21:32,270
upon them really can be simple or as

00:21:29,900 --> 00:21:33,890
complex as they want but the devops idea

00:21:32,270 --> 00:21:36,440
is to create a simple and sherrod

00:21:33,890 --> 00:21:38,690
abstraction for those rules so for

00:21:36,440 --> 00:21:42,800
example here's something that you are

00:21:38,690 --> 00:21:46,340
one way that you might describe a rules

00:21:42,800 --> 00:21:47,870
engine that both your out Ops guys and

00:21:46,340 --> 00:21:49,820
your dev guys can speak to you this one

00:21:47,870 --> 00:21:52,400
I just this is completely arbitrary this

00:21:49,820 --> 00:21:53,780
isn't like some published project but

00:21:52,400 --> 00:21:56,750
this is yeah mole that shows something

00:21:53,780 --> 00:21:59,810
along the lines of ok if you see events

00:21:56,750 --> 00:22:04,190
matching this tag like client load here

00:21:59,810 --> 00:22:08,360
reactions that that should be run here

00:22:04,190 --> 00:22:09,950
are registers a register in this example

00:22:08,360 --> 00:22:12,320
would be something that for example

00:22:09,950 --> 00:22:12,770
aggregates data or performs regression

00:22:12,320 --> 00:22:15,140
analysis

00:22:12,770 --> 00:22:16,820
this or what have you and here rules

00:22:15,140 --> 00:22:18,980
which need to be matched and if these

00:22:16,820 --> 00:22:22,160
rules are matched then you should run

00:22:18,980 --> 00:22:24,980
these reactions the point is that it

00:22:22,160 --> 00:22:27,170
should be very simple to be able to

00:22:24,980 --> 00:22:30,740
write rules and reactions that are

00:22:27,170 --> 00:22:33,380
shared by both sides of the house we

00:22:30,740 --> 00:22:35,510
need an actor write an actor is simply

00:22:33,380 --> 00:22:38,000
something that's run as a result of an

00:22:35,510 --> 00:22:39,890
event gap matching a given rule right

00:22:38,000 --> 00:22:42,170
that could be a call to an external

00:22:39,890 --> 00:22:45,910
service a config management call code

00:22:42,170 --> 00:22:49,400
that runs locally what have you I did

00:22:45,910 --> 00:22:50,510
create sort of a sample of all of this

00:22:49,400 --> 00:22:53,030
because I know that some of these

00:22:50,510 --> 00:22:56,030
concepts can be abstract if you want to

00:22:53,030 --> 00:22:59,540
look at it I put it all there to review

00:22:56,030 --> 00:23:01,880
in order to build scalable systems we

00:22:59,540 --> 00:23:03,620
need to be able to adopt the lessons of

00:23:01,880 --> 00:23:06,140
distributed computing and we can migrate

00:23:03,620 --> 00:23:10,160
from simple human initiated workflows to

00:23:06,140 --> 00:23:12,710
reactive programmable systems and event

00:23:10,160 --> 00:23:15,020
buses are pretty good so I let's build

00:23:12,710 --> 00:23:19,789
more of those thanks very much

00:23:15,020 --> 00:23:19,789

YouTube URL: https://www.youtube.com/watch?v=t3LwkVWiW5k


