Title: Object-oriented design for infrastructure-as-a-code - Anna Bankirer
Publication date: 2020-01-21
Playlist: DevOpsDays Tel Aviv 2019
Description: 
	Everyone talks about the fact that infrastructure should be programmatic and treated as a code, but often what this means is just writing a bunch of scripts to automate our deployments.
By doing so, aspects like proper documentation, separation to modules , abstraction, even version control that are standard for "regular" software projects are omitted from infrastructure systems.
This leads to cumbersome, monolith system - the very thing we are trying to resolve in the software design.
I would like to discuss the basic software design principles like SOLID and DRY and how to apply them when automating our deployments, writing docker containers or writing our application stack.
Captions: 
	00:00:00,440 --> 00:00:03,580
[Music]

00:00:03,980 --> 00:00:10,530
so ever named Donna I'm a software

00:00:07,859 --> 00:00:14,639
engineer and I work for a company called

00:00:10,530 --> 00:00:15,960
ADA where in addition to building when

00:00:14,639 --> 00:00:19,189
addition to having great people and

00:00:15,960 --> 00:00:22,170
technologies we also built a system that

00:00:19,189 --> 00:00:25,640
analyzes different medical images the

00:00:22,170 --> 00:00:28,470
text ethology is in real-time and helps

00:00:25,640 --> 00:00:29,939
radiologists be faster inaccurate and

00:00:28,470 --> 00:00:33,719
I'm here to talk about the concept

00:00:29,939 --> 00:00:36,480
called objects writer design so what is

00:00:33,719 --> 00:00:39,629
object-oriented design basically two set

00:00:36,480 --> 00:00:41,850
of principles and techniques and it can

00:00:39,629 --> 00:00:46,469
be used to build large systems that are

00:00:41,850 --> 00:00:50,340
modular and can be managed and scale and

00:00:46,469 --> 00:00:52,110
also change in minute now this concept

00:00:50,340 --> 00:00:54,480
is there well to the new concept

00:00:52,110 --> 00:00:56,340
well kissing archaeological terms

00:00:54,480 --> 00:00:58,980
because been around for more than 50

00:00:56,340 --> 00:01:01,859
years however I don't think it makes it

00:00:58,980 --> 00:01:04,350
any less relevant today I would even

00:01:01,859 --> 00:01:06,510
argue that concepts that survive faster

00:01:04,350 --> 00:01:10,500
height for so many years have something

00:01:06,510 --> 00:01:13,290
fundamentally right about them and my

00:01:10,500 --> 00:01:15,270
main claim for this talk is that object

00:01:13,290 --> 00:01:17,159
20 design is a universal concept it can

00:01:15,270 --> 00:01:21,000
be used not only for application code

00:01:17,159 --> 00:01:23,430
but also for infrastructure code and why

00:01:21,000 --> 00:01:25,170
would a show disclaimer that I'm not

00:01:23,430 --> 00:01:28,259
going to cover all the theory of

00:01:25,170 --> 00:01:29,579
object-oriented design but instead focus

00:01:28,259 --> 00:01:33,180
on the essence of OD

00:01:29,579 --> 00:01:34,439
and the show is some of the very basic

00:01:33,180 --> 00:01:37,770
and common techniques that you can use

00:01:34,439 --> 00:01:39,210
to build better systems the concept of

00:01:37,770 --> 00:01:41,759
object-oriented design is often

00:01:39,210 --> 00:01:44,579
mentioned with some other big words like

00:01:41,759 --> 00:01:46,350
inheritance and polymorphism and implies

00:01:44,579 --> 00:01:48,780
that you need to build some complex

00:01:46,350 --> 00:01:51,270
hierarchies and have multiple levels of

00:01:48,780 --> 00:01:55,200
abstractions now I'm not saying that

00:01:51,270 --> 00:01:56,520
these concepts are unuseful or bad I

00:01:55,200 --> 00:02:01,560
just claim that they are not mandatory

00:01:56,520 --> 00:02:06,770
to build awesome systems which brings me

00:02:01,560 --> 00:02:09,270
to what is OD and how it came to life so

00:02:06,770 --> 00:02:12,150
supposedly supposedly the person who

00:02:09,270 --> 00:02:13,380
coined the term is L&K computer

00:02:12,150 --> 00:02:16,110
scientist and one

00:02:13,380 --> 00:02:17,970
the developers of Smalltalk the one of

00:02:16,110 --> 00:02:21,780
the first object-oriented languages and

00:02:17,970 --> 00:02:25,560
what he tried to solve is to build

00:02:21,780 --> 00:02:28,470
systems that are composed of modular

00:02:25,560 --> 00:02:30,630
components that actually don't use short

00:02:28,470 --> 00:02:33,290
state but instead use messaging to

00:02:30,630 --> 00:02:37,620
communicate this design leads to a

00:02:33,290 --> 00:02:39,690
system that is really modular it can

00:02:37,620 --> 00:02:41,760
scale well it can be broken down to

00:02:39,690 --> 00:02:45,360
microservices and even run on different

00:02:41,760 --> 00:02:48,750
machines leading to a decentralized a

00:02:45,360 --> 00:02:51,060
distributed system that is that this

00:02:48,750 --> 00:02:54,540
most important property is that it's

00:02:51,060 --> 00:02:56,280
resilient to change so to me the essence

00:02:54,540 --> 00:02:59,820
of object-oriented design is mostly

00:02:56,280 --> 00:03:02,160
about change and most specifically build

00:02:59,820 --> 00:03:05,040
systems that are resilient and adaptive

00:03:02,160 --> 00:03:08,280
to change and you will see this theme of

00:03:05,040 --> 00:03:11,450
change is a common theme through the

00:03:08,280 --> 00:03:15,420
many object-oriented principles because

00:03:11,450 --> 00:03:17,550
well to be honest we as engineers have

00:03:15,420 --> 00:03:21,330
this tendency of trying to build the

00:03:17,550 --> 00:03:24,030
perfect software system but I think that

00:03:21,330 --> 00:03:25,800
the main goal should be accepting the

00:03:24,030 --> 00:03:27,840
inevitability of change and instead of

00:03:25,800 --> 00:03:30,380
building perfect systems simply build

00:03:27,840 --> 00:03:32,820
systems that are more adaptive to change

00:03:30,380 --> 00:03:34,590
so if that was the case and it's all

00:03:32,820 --> 00:03:35,840
about change and building decentralized

00:03:34,590 --> 00:03:38,040
systems then how come today

00:03:35,840 --> 00:03:40,440
object-oriented design is mostly

00:03:38,040 --> 00:03:42,720
associated with Java C sharp and other

00:03:40,440 --> 00:03:45,600
know languages that will make most

00:03:42,720 --> 00:03:47,310
operations engineers run in terror so to

00:03:45,600 --> 00:03:51,770
understand why we need to take a short

00:03:47,310 --> 00:03:55,410
trip back in time so how did we get here

00:03:51,770 --> 00:03:56,730
if we go to around 1960s there was no

00:03:55,410 --> 00:03:59,280
real difference between infrastructure

00:03:56,730 --> 00:04:01,920
code the application code and everything

00:03:59,280 --> 00:04:03,990
was basically responding responsibility

00:04:01,920 --> 00:04:06,720
of the almighty computer programmer who

00:04:03,990 --> 00:04:08,550
was doing the job of how do you engineer

00:04:06,720 --> 00:04:11,430
software engineer at the experts and

00:04:08,550 --> 00:04:13,050
even an electrical engineer if needed so

00:04:11,430 --> 00:04:17,040
if you think it's tough to find skilled

00:04:13,050 --> 00:04:19,650
engineers today think again so some time

00:04:17,040 --> 00:04:22,040
is passed and software has developed in

00:04:19,650 --> 00:04:24,300
its own separate discipline and

00:04:22,040 --> 00:04:27,139
cross-platform language is a different

00:04:24,300 --> 00:04:29,669
software containers and platforms

00:04:27,139 --> 00:04:31,680
abstracted did a very good job of

00:04:29,669 --> 00:04:35,280
obstructing the infrastructure from the

00:04:31,680 --> 00:04:38,010
developers so software engineers started

00:04:35,280 --> 00:04:39,680
to build large software systems instead

00:04:38,010 --> 00:04:42,449
of just programming the machine

00:04:39,680 --> 00:04:45,120
this of course created new challenges

00:04:42,449 --> 00:04:48,380
and this is where new concepts and

00:04:45,120 --> 00:04:51,150
techniques like object-oriented design

00:04:48,380 --> 00:04:54,470
came to save the day and were widely

00:04:51,150 --> 00:04:56,880
adopted now at the same time

00:04:54,470 --> 00:04:59,130
infrastructure world also had its own

00:04:56,880 --> 00:05:01,470
exponential growth and for many years

00:04:59,130 --> 00:05:03,950
the most you know the focus was mostly

00:05:01,470 --> 00:05:06,450
around hardware and performance

00:05:03,950 --> 00:05:08,520
databases databases the building

00:05:06,450 --> 00:05:10,470
networking infrastructure and of course

00:05:08,520 --> 00:05:14,960
small little things called internet in

00:05:10,470 --> 00:05:20,000
the cloud and finally where are we now

00:05:14,960 --> 00:05:21,900
so some more time has passed and

00:05:20,000 --> 00:05:23,639
infrastructure became more and more

00:05:21,900 --> 00:05:26,250
sophisticated and complex it started

00:05:23,639 --> 00:05:28,229
requiring some more automation and other

00:05:26,250 --> 00:05:30,840
solutions from software to deal with

00:05:28,229 --> 00:05:32,880
these new complexities and at the same

00:05:30,840 --> 00:05:35,460
time software engineers also reached the

00:05:32,880 --> 00:05:37,470
end of the capacity of building scalable

00:05:35,460 --> 00:05:38,910
large systems without paying more

00:05:37,470 --> 00:05:43,740
attention to the underlying

00:05:38,910 --> 00:05:45,840
infrastructure so now these two very

00:05:43,740 --> 00:05:47,460
different paradigms are closer than ever

00:05:45,840 --> 00:05:50,340
and I think this is a really good

00:05:47,460 --> 00:05:52,380
opportunity to start borrowing concepts

00:05:50,340 --> 00:05:54,090
the successful at least concepts from

00:05:52,380 --> 00:05:55,830
each other and one of this concept that

00:05:54,090 --> 00:05:56,630
is in my opinion is object-oriented

00:05:55,830 --> 00:06:01,139
design

00:05:56,630 --> 00:06:03,440
so to start describing the principles of

00:06:01,139 --> 00:06:06,599
object-oriented design let's first

00:06:03,440 --> 00:06:08,610
define what's our basic unit of work and

00:06:06,599 --> 00:06:11,039
in object-oriented design it's

00:06:08,610 --> 00:06:13,830
unsurprisingly an object so what is an

00:06:11,039 --> 00:06:16,440
object basically it's an independent

00:06:13,830 --> 00:06:18,570
entity that has an internal States set

00:06:16,440 --> 00:06:20,780
of operations they define how the object

00:06:18,570 --> 00:06:22,620
communicates with other objects and

00:06:20,780 --> 00:06:26,490
hopefully to have a very specific

00:06:22,620 --> 00:06:29,010
purpose so let's look at an example now

00:06:26,490 --> 00:06:31,680
what you see here is very simple dr.

00:06:29,010 --> 00:06:33,660
Campos configuration now dr. maybe at

00:06:31,680 --> 00:06:37,200
the first thing that you this comes to

00:06:33,660 --> 00:06:39,539
mind when speaking about OD but I think

00:06:37,200 --> 00:06:40,910
it's a very good example the

00:06:39,539 --> 00:06:44,150
demonstrates the concept of an

00:06:40,910 --> 00:06:46,310
because docker container is independent

00:06:44,150 --> 00:06:48,680
entity it has an internal state it even

00:06:46,310 --> 00:06:51,950
has a type in form of a document it

00:06:48,680 --> 00:06:53,630
defines clearly how it interacts with

00:06:51,950 --> 00:06:55,430
the outside world and it has a very

00:06:53,630 --> 00:06:58,280
clear purpose in this case you have two

00:06:55,430 --> 00:07:03,320
objects one is a DV service and another

00:06:58,280 --> 00:07:06,410
one simple admin service for DB okay so

00:07:03,320 --> 00:07:07,840
now let's go to what I'm going to cover

00:07:06,410 --> 00:07:11,060
only two object-oriented principles

00:07:07,840 --> 00:07:13,730
because as I said it's a short talk and

00:07:11,060 --> 00:07:15,710
we need to focus so one is the single

00:07:13,730 --> 00:07:18,260
responsibility principle and the other

00:07:15,710 --> 00:07:20,510
is dependency inversion both apart of

00:07:18,260 --> 00:07:24,590
the so-called solid principles which are

00:07:20,510 --> 00:07:27,560
very common in object-oriented world now

00:07:24,590 --> 00:07:30,140
a single responsibility or SOP is

00:07:27,560 --> 00:07:32,390
probably the easiest concept to explain

00:07:30,140 --> 00:07:36,080
but the hardest one to practice in

00:07:32,390 --> 00:07:37,910
reality so the definition is that your

00:07:36,080 --> 00:07:39,980
objects should only have one clear

00:07:37,910 --> 00:07:42,110
purpose or is Robert Martin define it

00:07:39,980 --> 00:07:48,860
only one reason to change remember

00:07:42,110 --> 00:07:50,690
change so what is a therapy so the idea

00:07:48,860 --> 00:07:53,720
here and the main goal is to keep us

00:07:50,690 --> 00:07:56,380
from building a monolith large system

00:07:53,720 --> 00:07:59,900
and instead building small components

00:07:56,380 --> 00:08:03,080
that have very clear responsibilities

00:07:59,900 --> 00:08:05,180
and if I quote Robert Martin again he

00:08:03,080 --> 00:08:07,310
defined the essence of SRP as you should

00:08:05,180 --> 00:08:09,440
gather together the things that change

00:08:07,310 --> 00:08:11,060
for the same reasons and separate those

00:08:09,440 --> 00:08:12,950
things the change for different reasons

00:08:11,060 --> 00:08:16,580
and I tried to say it really fast at

00:08:12,950 --> 00:08:17,930
times so the idea here is again to limit

00:08:16,580 --> 00:08:19,610
the impact of change because if you

00:08:17,930 --> 00:08:22,550
accept the fact that your system is

00:08:19,610 --> 00:08:24,380
going to change so what it happens you

00:08:22,550 --> 00:08:26,420
will be very likely if it will it will

00:08:24,380 --> 00:08:29,300
be limited to a single component instead

00:08:26,420 --> 00:08:32,080
being forced to change your whole system

00:08:29,300 --> 00:08:35,120
and another side benefit is if you

00:08:32,080 --> 00:08:36,710
gather together similar functionality to

00:08:35,120 --> 00:08:40,250
also be easier for you to test

00:08:36,710 --> 00:08:41,660
functionality let's take an example of

00:08:40,250 --> 00:08:44,450
how we can use this universal principle

00:08:41,660 --> 00:08:47,000
in a restaurant so let's say we go to a

00:08:44,450 --> 00:08:50,000
small family restaurant you will usually

00:08:47,000 --> 00:08:51,470
see what I call a one-man show you will

00:08:50,000 --> 00:08:53,510
see the owner of the restaurant who is

00:08:51,470 --> 00:08:54,840
also the waiter you will take your coat

00:08:53,510 --> 00:08:56,400
you will seat you to table

00:08:54,840 --> 00:08:58,460
and also being you the food which might

00:08:56,400 --> 00:09:02,160
be very nice and cozy and maybe even

00:08:58,460 --> 00:09:03,990
efficient for smaller place but if it

00:09:02,160 --> 00:09:06,180
gets bigger what usually will happen is

00:09:03,990 --> 00:09:08,730
that you will start hiring more people

00:09:06,180 --> 00:09:11,010
and more importantly will assign clear

00:09:08,730 --> 00:09:13,350
responsibilities to each person you will

00:09:11,010 --> 00:09:15,690
have the hostess you have waiters the

00:09:13,350 --> 00:09:18,240
cook and probably someone that will wash

00:09:15,690 --> 00:09:20,760
your dishes and this might be much a bit

00:09:18,240 --> 00:09:23,700
less cozy but it is much easier to

00:09:20,760 --> 00:09:25,290
manage scale and change if needed so

00:09:23,700 --> 00:09:26,820
even if you want to test this principle

00:09:25,290 --> 00:09:28,410
for yourself the next time you go to a

00:09:26,820 --> 00:09:30,540
nice restaurant just try and make the

00:09:28,410 --> 00:09:32,820
hostess bring you some food and you will

00:09:30,540 --> 00:09:35,660
see just how protective they are of the

00:09:32,820 --> 00:09:38,130
single responsibility principle there

00:09:35,660 --> 00:09:40,200
okay this brings me to the next

00:09:38,130 --> 00:09:44,640
principle which is called dependency

00:09:40,200 --> 00:09:47,130
inversion the definition again by Robert

00:09:44,640 --> 00:09:49,770
Martin is that high level modules should

00:09:47,130 --> 00:09:54,390
not depend on low level modules both

00:09:49,770 --> 00:09:57,540
should depend on abstractions now as you

00:09:54,390 --> 00:09:59,940
your system starts getting larger you by

00:09:57,540 --> 00:10:04,890
nature start to build the start building

00:09:59,940 --> 00:10:06,690
more complex objects now this will quite

00:10:04,890 --> 00:10:09,150
naturally introduce more dependencies

00:10:06,690 --> 00:10:11,820
between the objects and more dependency

00:10:09,150 --> 00:10:14,100
is it means that your system is much

00:10:11,820 --> 00:10:15,180
less resilient to change because one

00:10:14,100 --> 00:10:18,180
object affects the other

00:10:15,180 --> 00:10:20,310
so instead dependence inversion implies

00:10:18,180 --> 00:10:22,470
that she should use very simple objects

00:10:20,310 --> 00:10:24,690
and why are they I'm using abstraction

00:10:22,470 --> 00:10:26,610
this in turn will limit impact the

00:10:24,690 --> 00:10:28,560
future change and again it's much easier

00:10:26,610 --> 00:10:30,360
to test because you can use mock

00:10:28,560 --> 00:10:32,520
dependencies in your tests instead of

00:10:30,360 --> 00:10:35,430
actual dependencies thanks to the

00:10:32,520 --> 00:10:38,850
abstraction so if you go to the

00:10:35,430 --> 00:10:40,920
restaurant analogy again we might want

00:10:38,850 --> 00:10:44,730
to provide a delivery service for our

00:10:40,920 --> 00:10:46,500
customers now one option is to develop

00:10:44,730 --> 00:10:48,210
an in-house delivery service which will

00:10:46,500 --> 00:10:50,040
give you a lot of control you will

00:10:48,210 --> 00:10:51,540
define exactly what kind of a service

00:10:50,040 --> 00:10:52,950
you need to provide provide but of

00:10:51,540 --> 00:10:54,540
course you will need to operate the

00:10:52,950 --> 00:10:56,730
whole thing to hire the personnel and

00:10:54,540 --> 00:10:59,760
hear the complaints of the unsatisfied

00:10:56,730 --> 00:11:01,740
customers another option is to outsource

00:10:59,760 --> 00:11:03,720
your delivery service or as we call it

00:11:01,740 --> 00:11:06,910
in the software world and abstraction

00:11:03,720 --> 00:11:09,310
now you can use wall to some other

00:11:06,910 --> 00:11:12,190
the delivery service but in both cases

00:11:09,310 --> 00:11:14,770
it will reduce the control you have over

00:11:12,190 --> 00:11:17,590
the service but it will also reduce the

00:11:14,770 --> 00:11:19,030
dependency and in the future if you

00:11:17,590 --> 00:11:23,560
would like to change your delivery

00:11:19,030 --> 00:11:26,470
service it will be much easier so now

00:11:23,560 --> 00:11:29,860
let's go to some practical details now I

00:11:26,470 --> 00:11:32,380
want to demonstrate these principles and

00:11:29,860 --> 00:11:35,050
how they help us to redesign our system

00:11:32,380 --> 00:11:37,510
in a doc so we work with hospitals so we

00:11:35,050 --> 00:11:40,210
have two main services

00:11:37,510 --> 00:11:41,350
one is the on-prem service that handles

00:11:40,210 --> 00:11:44,080
all the communication with the hospital

00:11:41,350 --> 00:11:46,150
data services the identification and a

00:11:44,080 --> 00:11:48,850
bunch of other stuff and the other one

00:11:46,150 --> 00:11:51,670
is the backend service which we call the

00:11:48,850 --> 00:11:53,590
analysis server and it's its main

00:11:51,670 --> 00:11:58,240
objective is to analyze the medical data

00:11:53,590 --> 00:12:00,850
and provide insights or anomalies so

00:11:58,240 --> 00:12:02,410
this was really basic architecture but

00:12:00,850 --> 00:12:05,560
it started quite well when you only had

00:12:02,410 --> 00:12:08,350
a few hospitals to serve but the main

00:12:05,560 --> 00:12:11,290
plain was that we had to set up a new

00:12:08,350 --> 00:12:13,660
back-end service for each new site which

00:12:11,290 --> 00:12:15,520
was also very difficult to deploy it was

00:12:13,660 --> 00:12:18,280
it was not scalable it was really

00:12:15,520 --> 00:12:20,200
expensive but fortunately we had an

00:12:18,280 --> 00:12:23,680
exponential growth and we had to really

00:12:20,200 --> 00:12:25,990
texture this this thing to succeed so

00:12:23,680 --> 00:12:27,520
this is really roughly our architecture

00:12:25,990 --> 00:12:31,530
right now you don't need to understand

00:12:27,520 --> 00:12:34,660
every icon the main idea is that we

00:12:31,530 --> 00:12:39,610
solved our main pain and created a more

00:12:34,660 --> 00:12:41,770
dynamic back end infrastructure so by by

00:12:39,610 --> 00:12:45,010
taking our back-end service and breaking

00:12:41,770 --> 00:12:47,140
it down to smaller components by

00:12:45,010 --> 00:12:49,240
extracting all the internal dependencies

00:12:47,140 --> 00:12:52,480
like configuration and communication to

00:12:49,240 --> 00:12:57,700
external components by using console

00:12:52,480 --> 00:12:59,650
cues and external DB etc so now let's

00:12:57,700 --> 00:13:01,960
take an example of how we use the single

00:12:59,650 --> 00:13:03,790
responsibility principle so this

00:13:01,960 --> 00:13:05,440
probably the first step in

00:13:03,790 --> 00:13:07,720
object-oriented design is to identify

00:13:05,440 --> 00:13:09,910
your objects to take your large system

00:13:07,720 --> 00:13:12,130
and break it down to components in our

00:13:09,910 --> 00:13:15,580
case it was we had several main

00:13:12,130 --> 00:13:17,950
components one is the web web api the DB

00:13:15,580 --> 00:13:21,459
service the configuration

00:13:17,950 --> 00:13:23,260
so each of those got their own component

00:13:21,459 --> 00:13:25,269
and responsibilities for example the web

00:13:23,260 --> 00:13:27,430
service is now responsible only for the

00:13:25,269 --> 00:13:29,560
communication with the on from service

00:13:27,430 --> 00:13:32,649
the configuration service instead of

00:13:29,560 --> 00:13:35,230
being a component of the analysis is now

00:13:32,649 --> 00:13:37,769
an external entity and also obstructed

00:13:35,230 --> 00:13:41,769
all the DB service operations and

00:13:37,769 --> 00:13:43,360
delegated it to another service of

00:13:41,769 --> 00:13:45,519
course all of these things were also

00:13:43,360 --> 00:13:48,160
reflected in our deployment process if

00:13:45,519 --> 00:13:50,769
before we only had like a bunch of batch

00:13:48,160 --> 00:13:53,680
scripts that deployed everything we now

00:13:50,769 --> 00:13:58,990
have a modular deployment process using

00:13:53,680 --> 00:14:00,730
terraform and Sarah grant the second

00:13:58,990 --> 00:14:04,750
example is how we use the dependency

00:14:00,730 --> 00:14:08,410
inversion principle so this is just one

00:14:04,750 --> 00:14:10,410
example of how it's how it took an

00:14:08,410 --> 00:14:13,570
internal and local configuration

00:14:10,410 --> 00:14:15,790
extracted it to console and abstracted

00:14:13,570 --> 00:14:18,760
it from the analysis server using our

00:14:15,790 --> 00:14:19,630
configuration service so in the future

00:14:18,760 --> 00:14:22,149
if you want to change the implementation

00:14:19,630 --> 00:14:26,860
the analysis service will have very

00:14:22,149 --> 00:14:28,810
little impact right and finally which

00:14:26,860 --> 00:14:30,730
this is a very simple example it

00:14:28,810 --> 00:14:32,230
demonstrates how you can see dependency

00:14:30,730 --> 00:14:35,019
inversion tools that tarragon to

00:14:32,230 --> 00:14:37,120
terraform and this is the way we deploy

00:14:35,019 --> 00:14:38,620
I hope you can stay well your property

00:14:37,120 --> 00:14:43,480
don't see anything but this is the way

00:14:38,620 --> 00:14:45,010
that we deploy our RDS cluster and we

00:14:43,480 --> 00:14:47,589
use Tara grant which is the field

00:14:45,010 --> 00:14:49,720
wrapper on top of Tara form and it makes

00:14:47,589 --> 00:14:51,310
it much easier to use different tariffs

00:14:49,720 --> 00:14:54,220
or modules for different environments

00:14:51,310 --> 00:14:56,920
and also make a deployment called much

00:14:54,220 --> 00:15:00,880
more object 20 so in this case you can

00:14:56,920 --> 00:15:04,480
see the that our audio starter has a

00:15:00,880 --> 00:15:07,720
dependency on our V PC but it's a really

00:15:04,480 --> 00:15:09,790
really abstract dependency and if it

00:15:07,720 --> 00:15:11,589
doesn't really know anything about how

00:15:09,790 --> 00:15:13,600
it's implemented or who created it and

00:15:11,589 --> 00:15:19,329
if we want to change it in the future to

00:15:13,600 --> 00:15:22,449
be much easier to change so let's bring

00:15:19,329 --> 00:15:24,670
me to conclusion some takeaways so first

00:15:22,449 --> 00:15:26,319
hopefully I made my point and show you

00:15:24,670 --> 00:15:28,209
that object-oriented design is not

00:15:26,319 --> 00:15:30,069
strictly the propriety of the software

00:15:28,209 --> 00:15:31,750
engineers application code it can be

00:15:30,069 --> 00:15:33,040
used universally in

00:15:31,750 --> 00:15:35,770
infrastructure code and even in a

00:15:33,040 --> 00:15:37,450
restaurant second is that there is a

00:15:35,770 --> 00:15:39,160
bunch of information about object

00:15:37,450 --> 00:15:41,230
oriented programming online so I urge

00:15:39,160 --> 00:15:43,120
you to go and learn for yourself and

00:15:41,230 --> 00:15:46,930
find the principles that works for you

00:15:43,120 --> 00:15:48,880
in your system and finally when you

00:15:46,930 --> 00:15:51,190
start applying the principles just keep

00:15:48,880 --> 00:15:53,500
it simple because you don't need to get

00:15:51,190 --> 00:15:55,480
good at object 20 design this is not the

00:15:53,500 --> 00:15:58,120
goal remember that the real goal is to

00:15:55,480 --> 00:16:00,970
build systems that are good at being

00:15:58,120 --> 00:16:05,710
adaptive to change thank you

00:16:00,970 --> 00:16:10,799
[Applause]

00:16:05,710 --> 00:16:10,799

YouTube URL: https://www.youtube.com/watch?v=zGelvnsrQ20


