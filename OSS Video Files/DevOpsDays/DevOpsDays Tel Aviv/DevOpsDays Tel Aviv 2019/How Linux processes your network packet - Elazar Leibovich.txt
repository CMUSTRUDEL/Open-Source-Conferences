Title: How Linux processes your network packet - Elazar Leibovich
Publication date: 2020-01-13
Playlist: DevOpsDays Tel Aviv 2019
Description: 
	Modern environment uses a lot of the Linux networking stack capability.

Every docker container requires a dedicated bridge, usually a few iptables entries to expose port, and a dnsmasq daemon, and masquarading to allow internet access.

It is hence important to understand Linux network fundumentals. From the driver interrupt/NAPI, to the network stack, the various filters it passes through and the various hooks you have at your disposal to alter and view the network packets flow.

We will first review the theory, and then present useful tools to apply the theory and debug problems in common situations.

We will survey common containers situations and see how packets move from the hardware to the container's veth.
Captions: 
	00:00:00,440 --> 00:00:03,580
[Music]

00:00:04,279 --> 00:00:11,849
hello everyone thank you for coming

00:00:08,120 --> 00:00:14,099
my name is Dale available which I was

00:00:11,849 --> 00:00:14,849
working on virtualization and network

00:00:14,099 --> 00:00:17,310
virtualization

00:00:14,849 --> 00:00:20,970
in Ravello and there I fell in love with

00:00:17,310 --> 00:00:24,960
Linux networking internals I also wrote

00:00:20,970 --> 00:00:26,970
the go proxy proxy library program a

00:00:24,960 --> 00:00:29,970
library that also has a lot to do with

00:00:26,970 --> 00:00:34,980
me talking so networking the topic

00:00:29,970 --> 00:00:37,440
closer to my heart and this DevOps day

00:00:34,980 --> 00:00:41,850
this year is all about the basic

00:00:37,440 --> 00:00:45,050
building blocks of our systems this is

00:00:41,850 --> 00:00:49,440
another topic topic which I really like

00:00:45,050 --> 00:00:53,780
many years ago I learned the HTML do you

00:00:49,440 --> 00:00:59,879
didn't wanna hear and hear about that

00:00:53,780 --> 00:01:01,920
dhtml one hand to hand Dan and well I I

00:00:59,879 --> 00:01:02,600
can tell you that today this is not

00:01:01,920 --> 00:01:06,600
relevant

00:01:02,600 --> 00:01:09,030
however if I've had learned then TCP

00:01:06,600 --> 00:01:12,320
many of the thing I've learned by then

00:01:09,030 --> 00:01:14,970
would still be relevant today so

00:01:12,320 --> 00:01:16,070
learning the basic building blocks could

00:01:14,970 --> 00:01:22,020
be very useful

00:01:16,070 --> 00:01:25,140
so to them going to explain the how

00:01:22,020 --> 00:01:29,610
network packets are processed through an

00:01:25,140 --> 00:01:34,500
example a problem one can run into and

00:01:29,610 --> 00:01:36,840
running containers and Dockers this is

00:01:34,500 --> 00:01:40,530
not a comprehensive talk about every

00:01:36,840 --> 00:01:42,750
possible Linux and network device this

00:01:40,530 --> 00:01:44,790
is not an in-depth talk about every

00:01:42,750 --> 00:01:47,729
little detail that the channel does to

00:01:44,790 --> 00:01:51,450
the packet once it received I would skip

00:01:47,729 --> 00:01:54,600
details I will be slightly I would

00:01:51,450 --> 00:01:57,659
simplify things but what's important for

00:01:54,600 --> 00:02:01,439
me is to give you the high level view

00:01:57,659 --> 00:02:05,520
and to get you into the a stick and I'll

00:02:01,439 --> 00:02:08,119
be very happy if anyone would exit this

00:02:05,520 --> 00:02:09,929
talk and without to learn more about

00:02:08,119 --> 00:02:12,690
networking in general on Linux and

00:02:09,929 --> 00:02:15,810
walking in particular

00:02:12,690 --> 00:02:19,080
so let's start at the right away what's

00:02:15,810 --> 00:02:23,730
the problem I've run into so let's say

00:02:19,080 --> 00:02:26,160
you wrote an application something like

00:02:23,730 --> 00:02:29,370
collecti application that received

00:02:26,160 --> 00:02:31,320
matrix by UDP and it's beautiful graphs

00:02:29,370 --> 00:02:33,780
from the first matrix not like this one

00:02:31,320 --> 00:02:36,330
really beautiful graphs and you

00:02:33,780 --> 00:02:39,720
developed it it works everything is good

00:02:36,330 --> 00:02:41,490
now you deploy it you run it in the

00:02:39,720 --> 00:02:42,890
production production like environment

00:02:41,490 --> 00:02:45,270
with docker that's what everyone does

00:02:42,890 --> 00:02:47,550
you would probably run it with a command

00:02:45,270 --> 00:02:51,240
line like this one and it would work you

00:02:47,550 --> 00:02:53,190
would send matrix and data from your

00:02:51,240 --> 00:02:56,550
laptop to the container the container

00:02:53,190 --> 00:03:00,000
would receive them but the problem our

00:02:56,550 --> 00:03:02,880
problem starts if you tell your manager

00:03:00,000 --> 00:03:06,090
about that and you both want to test

00:03:02,880 --> 00:03:10,920
your container now with his matrix to

00:03:06,090 --> 00:03:12,660
see how your container handle them and

00:03:10,920 --> 00:03:15,690
he wants to send you packet from his

00:03:12,660 --> 00:03:17,190
laptop to your container docker has a

00:03:15,690 --> 00:03:19,830
solution for that it's called port

00:03:17,190 --> 00:03:21,600
mapping or exposed and if you would run

00:03:19,830 --> 00:03:25,830
your container with a command line like

00:03:21,600 --> 00:03:28,140
this one it would map port 8000 on your

00:03:25,830 --> 00:03:32,160
laptop to port 8000 on your container

00:03:28,140 --> 00:03:34,320
and it would work your boss would be

00:03:32,160 --> 00:03:36,560
able to send data to your laptop at port

00:03:34,320 --> 00:03:39,959
8000 and - and docker would make sure

00:03:36,560 --> 00:03:44,280
that the packets would reach the

00:03:39,959 --> 00:03:46,920
container so far so good but what

00:03:44,280 --> 00:03:48,840
happens if for some reason we didn't

00:03:46,920 --> 00:03:53,220
start it with a correct port mapping the

00:03:48,840 --> 00:03:56,520
content is running some other processes

00:03:53,220 --> 00:03:57,750
are using it or it's doing a long for

00:03:56,520 --> 00:04:01,680
something you don't want to stop in the

00:03:57,750 --> 00:04:04,380
middle and you want to do this port

00:04:01,680 --> 00:04:07,410
mapping you want data to reach to this

00:04:04,380 --> 00:04:09,120
container from your boss laptop without

00:04:07,410 --> 00:04:12,030
stopping the container you can stop it

00:04:09,120 --> 00:04:17,340
and run it again with port mapping what

00:04:12,030 --> 00:04:19,500
can you do so the first thing I do is I

00:04:17,340 --> 00:04:21,479
switch to Internet and that's what I

00:04:19,500 --> 00:04:23,970
came up with when I google for the

00:04:21,479 --> 00:04:25,620
relevant keyword and this looks like an

00:04:23,970 --> 00:04:29,010
official answer from docker

00:04:25,620 --> 00:04:31,710
it says docker staff and the answer I

00:04:29,010 --> 00:04:34,290
can summarize it in one word

00:04:31,710 --> 00:04:35,460
no you can't do that if you want to

00:04:34,290 --> 00:04:36,960
support mapping you have to kill the

00:04:35,460 --> 00:04:40,590
continue you'll just stop the content

00:04:36,960 --> 00:04:42,720
and static started again so what why I

00:04:40,590 --> 00:04:45,060
want to do the bosses at my desk is

00:04:42,720 --> 00:04:47,070
waiting to see what his metrics how he

00:04:45,060 --> 00:04:51,810
held the graph from if metrics would

00:04:47,070 --> 00:04:53,820
look like and I want to enable his

00:04:51,810 --> 00:04:57,960
metrics to reach my container without

00:04:53,820 --> 00:05:00,090
stopping it this is the problem so but

00:04:57,960 --> 00:05:03,570
before we understand how to do that we

00:05:00,090 --> 00:05:07,760
first need to understand how packet

00:05:03,570 --> 00:05:11,030
reach the container from my laptop

00:05:07,760 --> 00:05:16,490
before we start solving the problem of

00:05:11,030 --> 00:05:19,260
packets getting from my boss laptop so

00:05:16,490 --> 00:05:22,740
there are three and networking concepts

00:05:19,260 --> 00:05:25,080
I need to introduce to explain how this

00:05:22,740 --> 00:05:29,130
happen the first one is network name

00:05:25,080 --> 00:05:33,349
space network namespace is all network

00:05:29,130 --> 00:05:33,349
related thing like routing tables

00:05:34,160 --> 00:05:42,960
networked if I said in a box isolated

00:05:39,139 --> 00:05:47,039
every docker container by default starts

00:05:42,960 --> 00:05:50,310
in its own network name space network

00:05:47,039 --> 00:05:52,740
Nexus all of us isolation of everything

00:05:50,310 --> 00:05:56,930
related to networking every Network

00:05:52,740 --> 00:06:01,500
every process is in its own in a single

00:05:56,930 --> 00:06:03,090
Network native every Network device in

00:06:01,500 --> 00:06:05,430
your machine is in a single network nice

00:06:03,090 --> 00:06:07,440
place and you laptop starts with the

00:06:05,430 --> 00:06:12,930
default network name if that everything

00:06:07,440 --> 00:06:16,830
by default is in it so how do we

00:06:12,930 --> 00:06:19,199
diagnose that in a way to see it then

00:06:16,830 --> 00:06:21,360
the different network Mayfest is you can

00:06:19,199 --> 00:06:25,740
do that with simple LS the progress

00:06:21,360 --> 00:06:27,840
/proc /proc ID / NS is a directory that

00:06:25,740 --> 00:06:29,490
contains the various network name name

00:06:27,840 --> 00:06:33,240
and a namespace set of a single process

00:06:29,490 --> 00:06:35,820
and here you can see in the line above

00:06:33,240 --> 00:06:38,099
the network name space of a process

00:06:35,820 --> 00:06:38,970
inside docker container which is

00:06:38,099 --> 00:06:41,970
different from

00:06:38,970 --> 00:06:48,270
the network namespace of system

00:06:41,970 --> 00:06:51,090
reprocess which is just one so as we

00:06:48,270 --> 00:06:53,340
said network name faces are isolated so

00:06:51,090 --> 00:06:55,440
by default you cannot send anything from

00:06:53,340 --> 00:06:57,840
the doctor namespace to your different

00:06:55,440 --> 00:07:02,550
names with your laptop how do we do that

00:06:57,840 --> 00:07:05,400
so the first the first network device

00:07:02,550 --> 00:07:08,790
that helped us in this task is a virtual

00:07:05,400 --> 00:07:13,800
virtual Ethernet pair or vesper this

00:07:08,790 --> 00:07:16,800
pair is something like that to network

00:07:13,800 --> 00:07:18,930
devices one I took advice one pure every

00:07:16,800 --> 00:07:21,210
packet reaches to one end would be sent

00:07:18,930 --> 00:07:24,300
to its peer and vice versa and we can

00:07:21,210 --> 00:07:26,250
put one end inside one network namespace

00:07:24,300 --> 00:07:30,390
the other end in our laptop in the

00:07:26,250 --> 00:07:31,980
default network namespace and the

00:07:30,390 --> 00:07:34,470
container and the different network

00:07:31,980 --> 00:07:38,630
analysis would be able to speak with one

00:07:34,470 --> 00:07:42,030
and one another through this vest pair

00:07:38,630 --> 00:07:46,650
the other component is bridge bridges

00:07:42,030 --> 00:07:48,840
like a physical switch and the preacher

00:07:46,650 --> 00:07:51,480
told us took two enslaved to connect

00:07:48,840 --> 00:07:54,169
many network devices to put them inside

00:07:51,480 --> 00:07:56,940
the bridge and the bridge would know

00:07:54,169 --> 00:07:58,919
when a packet reaches the bridge it

00:07:56,940 --> 00:08:03,150
would select its destination from one of

00:07:58,919 --> 00:08:08,430
the devices in slave and would move the

00:08:03,150 --> 00:08:11,520
packet to this port or network device

00:08:08,430 --> 00:08:16,290
and this is the way docker connect many

00:08:11,520 --> 00:08:21,060
containers to one another so let's see a

00:08:16,290 --> 00:08:22,800
simple example so to your left you can

00:08:21,060 --> 00:08:25,800
see the different methods I will laptop

00:08:22,800 --> 00:08:31,350
to your right the daka namespace we're

00:08:25,800 --> 00:08:36,330
sending a packet to whose destination IP

00:08:31,350 --> 00:08:38,280
is our container IP the linux find out

00:08:36,330 --> 00:08:41,339
that it needs to send this packet

00:08:38,280 --> 00:08:43,560
through this to the bridge the bridge is

00:08:41,339 --> 00:08:45,180
usually called the doctor zero it send

00:08:43,560 --> 00:08:47,370
it to the bridge to the dock of the

00:08:45,180 --> 00:08:48,839
network in fact of the bridge when I

00:08:47,370 --> 00:08:51,060
talk interface moves it to the bridge

00:08:48,839 --> 00:08:52,190
the bridge move this to one end of the

00:08:51,060 --> 00:08:53,750
Vesper

00:08:52,190 --> 00:08:56,570
the first pair moved it to the other end

00:08:53,750 --> 00:08:59,900
and that's how this packet the packet

00:08:56,570 --> 00:09:01,910
reaches the container okay again how can

00:08:59,900 --> 00:09:05,330
we see we logged into a device how can

00:09:01,910 --> 00:09:08,120
we see that we have a vest pair one way

00:09:05,330 --> 00:09:12,700
to do that is do the IP route to suit

00:09:08,120 --> 00:09:16,370
which is usually installed on almost any

00:09:12,700 --> 00:09:19,460
Linux device IP link or IPL would give

00:09:16,370 --> 00:09:23,480
us a list of the network devices in the

00:09:19,460 --> 00:09:27,290
in the continent namespace and the add

00:09:23,480 --> 00:09:32,510
sign tells us that device number 51

00:09:27,290 --> 00:09:34,940
whose name is the best 500 deal 144 in a

00:09:32,510 --> 00:09:42,500
vest pair and it's peer is device number

00:09:34,940 --> 00:09:48,700
50 so this is how we can know that I can

00:09:42,500 --> 00:09:51,530
find out that that we have a vest pair

00:09:48,700 --> 00:09:54,610
this this very same command can tell

00:09:51,530 --> 00:09:56,810
that you can tell that that a vest pair

00:09:54,610 --> 00:10:00,020
and that would reverse the inside that

00:09:56,810 --> 00:10:03,590
bridge master dr. zero means this device

00:10:00,020 --> 00:10:05,480
ID 25 is inside dr. zero and this is

00:10:03,590 --> 00:10:08,240
another thing a useful concept sees a

00:10:05,480 --> 00:10:11,360
faith with a file system which can show

00:10:08,240 --> 00:10:13,070
details about network devices and it

00:10:11,360 --> 00:10:17,440
shows us that dr. Theo is indeed a

00:10:13,070 --> 00:10:20,000
bridge okay then now back to the problem

00:10:17,440 --> 00:10:22,700
we don't want to reach from the laptop

00:10:20,000 --> 00:10:27,320
to that container we can already do that

00:10:22,700 --> 00:10:33,280
we need to reach from our network

00:10:27,320 --> 00:10:36,170
interface to the to the bridge because

00:10:33,280 --> 00:10:38,090
our boss sends packet to our laptop and

00:10:36,170 --> 00:10:41,660
those packets are received by a by our

00:10:38,090 --> 00:10:44,570
network card which is many times s 0 and

00:10:41,660 --> 00:10:46,280
we need to somehow move the packets from

00:10:44,570 --> 00:10:48,530
the east arrow to the doctor to your

00:10:46,280 --> 00:10:50,090
bridge and then as we said before it

00:10:48,530 --> 00:10:52,280
would reach the usual path to the

00:10:50,090 --> 00:10:55,550
container how do we do that so again

00:10:52,280 --> 00:10:56,960
before we understand the hell how do we

00:10:55,550 --> 00:10:59,840
do that we need to understand what

00:10:56,960 --> 00:11:03,550
happens to packet that are received in a

00:10:59,840 --> 00:11:03,550
network device in Linux

00:11:03,859 --> 00:11:10,499
so again high-level view when a packet

00:11:08,069 --> 00:11:13,109
is received the routing table is

00:11:10,499 --> 00:11:15,209
searched and where the kernel is trying

00:11:13,109 --> 00:11:17,759
to find out if this packet is for us is

00:11:15,209 --> 00:11:19,439
for an IP that we manage or it is

00:11:17,759 --> 00:11:20,729
pocketed for another machine and we're

00:11:19,439 --> 00:11:23,699
just helping it reach its final

00:11:20,729 --> 00:11:25,919
destination two options option 1 the

00:11:23,699 --> 00:11:27,989
packet is for us we do local delivery

00:11:25,919 --> 00:11:29,879
the kernel searches for an application

00:11:27,989 --> 00:11:32,069
waiting for this packet and copy the

00:11:29,879 --> 00:11:33,809
data to this application option B the

00:11:32,069 --> 00:11:36,269
kernel the no application knows about it

00:11:33,809 --> 00:11:39,029
and that cannot forward it to the device

00:11:36,269 --> 00:11:44,369
that would help it reach its final

00:11:39,029 --> 00:11:49,379
destination so back to our program we

00:11:44,369 --> 00:11:51,660
have a certain IP we get a packet to our

00:11:49,379 --> 00:11:53,639
IP because my boss don't know the

00:11:51,660 --> 00:11:55,109
internal IP of the container instance

00:11:53,639 --> 00:11:58,859
packet to my laptop that's what you know

00:11:55,109 --> 00:12:01,799
so we're getting a packet to 1025 or 1

00:11:58,859 --> 00:12:04,139
let's say that's my internal that's the

00:12:01,799 --> 00:12:05,879
same IP of my network device so the

00:12:04,139 --> 00:12:09,389
kernel says hey this packet is for us

00:12:05,879 --> 00:12:10,949
it's tries local delivery yeah what

00:12:09,389 --> 00:12:15,119
happens with local delivery how can we

00:12:10,949 --> 00:12:20,399
diagnose that so this is an SNMP counter

00:12:15,119 --> 00:12:23,639
which we can inspect and you can see the

00:12:20,399 --> 00:12:25,229
RFC description but let me simplify that

00:12:23,639 --> 00:12:27,269
or in plain English this is the number

00:12:25,229 --> 00:12:29,039
of UDP packet they cannot dropped

00:12:27,269 --> 00:12:30,839
because no application is waiting for

00:12:29,039 --> 00:12:35,789
that and that's exactly what would

00:12:30,839 --> 00:12:38,850
happen to the packet sent by my boss to

00:12:35,789 --> 00:12:41,489
my IP we can see that in action we can

00:12:38,850 --> 00:12:44,339
see netcat sent a UDP packet to port

00:12:41,489 --> 00:12:46,709
8000 we're checking the UDP no port

00:12:44,339 --> 00:12:48,959
counter and status again usually

00:12:46,709 --> 00:12:51,239
installed by default and you can see

00:12:48,959 --> 00:12:54,389
this the country is now 1 because this

00:12:51,239 --> 00:12:56,399
packet was received they can I said

00:12:54,389 --> 00:12:57,989
local delivery the kernel so no

00:12:56,399 --> 00:13:00,839
application is waiting for this packet

00:12:57,989 --> 00:13:02,699
so it increment this counter we were

00:13:00,839 --> 00:13:06,739
able to know that it's a packet was

00:13:02,699 --> 00:13:06,739
dropped yeah

00:13:06,770 --> 00:13:15,770
so how do we do that the last Network

00:13:11,450 --> 00:13:21,200
continent we need is called IP tables IP

00:13:15,770 --> 00:13:23,690
tables in a few wars is a way to modify

00:13:21,200 --> 00:13:26,930
or drop network packet during the

00:13:23,690 --> 00:13:27,550
processing as I said before the the

00:13:26,930 --> 00:13:29,690
network

00:13:27,550 --> 00:13:32,209
receives a packet and start processing

00:13:29,690 --> 00:13:35,470
it it find out whether it whether or not

00:13:32,209 --> 00:13:38,600
it's for us it does either local

00:13:35,470 --> 00:13:40,640
delivery or forwarding so in various

00:13:38,600 --> 00:13:43,040
points during this process we can catch

00:13:40,640 --> 00:13:50,029
the packet and modify or drop it and IP

00:13:43,040 --> 00:13:52,580
tables enables to do that so we want to

00:13:50,029 --> 00:13:57,890
I pick tables to modify this packet

00:13:52,580 --> 00:14:00,110
before the decision is made whether this

00:13:57,890 --> 00:14:01,070
packet is for us or not because after

00:14:00,110 --> 00:14:05,029
that it's too late

00:14:01,070 --> 00:14:06,740
it would always try to move it to the to

00:14:05,029 --> 00:14:11,540
an application waiting waiting for that

00:14:06,740 --> 00:14:15,709
so that's the point we want to catch the

00:14:11,540 --> 00:14:19,520
packet okay so let's look at this

00:14:15,709 --> 00:14:23,300
command more closely the first line is

00:14:19,520 --> 00:14:27,740
as we said at what stage do we want to

00:14:23,300 --> 00:14:30,440
process this packet and the stage is pre

00:14:27,740 --> 00:14:32,750
routing to decide if this packet is for

00:14:30,440 --> 00:14:35,000
us or not they can always look for the

00:14:32,750 --> 00:14:39,140
routing table which contains local

00:14:35,000 --> 00:14:42,230
routing rules and external routing rules

00:14:39,140 --> 00:14:44,120
and we want to do left before routine

00:14:42,230 --> 00:14:45,589
privity because after the routing table

00:14:44,120 --> 00:14:50,839
who look up after the country started is

00:14:45,589 --> 00:14:53,329
inspected for us or not it's right now

00:14:50,839 --> 00:14:54,709
the other line is which packet would do

00:14:53,329 --> 00:14:57,740
we want to process with all - all

00:14:54,709 --> 00:15:00,380
packets we want only packets for us so

00:14:57,740 --> 00:15:04,399
this had packets that were received on

00:15:00,380 --> 00:15:06,770
f0 on our network card of with protocol

00:15:04,399 --> 00:15:08,660
UDP and whose destination port is the

00:15:06,770 --> 00:15:12,230
port we want to receive data for our

00:15:08,660 --> 00:15:15,190
application so this is a second line and

00:15:12,230 --> 00:15:18,350
the last line is what what we want to do

00:15:15,190 --> 00:15:20,420
with this

00:15:18,350 --> 00:15:22,130
at home I won't go into too much detail

00:15:20,420 --> 00:15:24,740
dine at his destination not which

00:15:22,130 --> 00:15:27,560
basically means change the destination

00:15:24,740 --> 00:15:32,950
IP and we're moving the destination and

00:15:27,560 --> 00:15:36,230
the port to the internal port of our

00:15:32,950 --> 00:15:40,550
container so what would happen is the

00:15:36,230 --> 00:15:41,960
packet would be received in s0 the

00:15:40,550 --> 00:15:43,730
kernel would start to process it it

00:15:41,960 --> 00:15:46,460
would see IP table rule that applies

00:15:43,730 --> 00:15:48,860
before routing so before deciding if

00:15:46,460 --> 00:15:51,620
this packet is for us or not it would

00:15:48,860 --> 00:15:53,990
apply this rule and the rule would

00:15:51,620 --> 00:15:57,350
change the destination IP IP once the

00:15:53,990 --> 00:15:58,430
destination IP is change the cannon

00:15:57,350 --> 00:16:00,140
would decide this packet needs

00:15:58,430 --> 00:16:01,670
forwarding it doesn't in local the very

00:16:00,140 --> 00:16:03,410
nice forwarding it would forward it to

00:16:01,670 --> 00:16:05,840
the aquaszero and from dhaka through to

00:16:03,410 --> 00:16:12,640
reach the content so as we saw this

00:16:05,840 --> 00:16:17,810
walked this walked think that is my

00:16:12,640 --> 00:16:20,570
search said is impossible walked with

00:16:17,810 --> 00:16:23,240
the basic Linux networking command

00:16:20,570 --> 00:16:29,120
available on almost any modern Linux

00:16:23,240 --> 00:16:35,270
machine so I think the lesson from this

00:16:29,120 --> 00:16:36,800
talk is that with simple commands you

00:16:35,270 --> 00:16:39,200
can do you can solve interesting

00:16:36,800 --> 00:16:40,670
problems but what you have to do is to

00:16:39,200 --> 00:16:42,500
understand the basics understand the

00:16:40,670 --> 00:16:45,220
fundamentals understand the package fall

00:16:42,500 --> 00:16:47,870
in the packet processing

00:16:45,220 --> 00:16:49,820
thank you very much before taking

00:16:47,870 --> 00:16:52,970
question I have a puzzle for you and I

00:16:49,820 --> 00:16:56,210
promise surprise to anyone solving it

00:16:52,970 --> 00:16:59,480
and sending the solution to me and I

00:16:56,210 --> 00:17:01,790
solved this the assadist problem but

00:16:59,480 --> 00:17:04,070
when I solve this problem every packet

00:17:01,790 --> 00:17:07,430
that I received move directly to the

00:17:04,070 --> 00:17:10,460
container I want a solution that give

00:17:07,430 --> 00:17:12,320
pre-sentence to my laptop if there's an

00:17:10,460 --> 00:17:14,900
application on my laptop waiting for

00:17:12,320 --> 00:17:17,330
packets on port 8000 this application

00:17:14,900 --> 00:17:19,250
would take if I kill this application

00:17:17,330 --> 00:17:20,720
and now no one is waiting I want a

00:17:19,250 --> 00:17:23,270
packet to move to the container

00:17:20,720 --> 00:17:28,760
how do we do that no external tools just

00:17:23,270 --> 00:17:30,590
what's available by default on any Linux

00:17:28,760 --> 00:17:32,150
machine this is my questions for you

00:17:30,590 --> 00:17:42,110
now if anyone asked question

00:17:32,150 --> 00:17:44,090
I'll be happy too no no no okay let me

00:17:42,110 --> 00:17:47,090
explain it again I I don't want to find

00:17:44,090 --> 00:17:49,940
out if someone is listening I want that

00:17:47,090 --> 00:17:52,400
when I start an application listening to

00:17:49,940 --> 00:17:54,680
packets on port 8000 the application

00:17:52,400 --> 00:17:58,430
would get and would get in free would

00:17:54,680 --> 00:18:00,260
get connections to port it out but I

00:17:58,430 --> 00:18:02,240
want that in the very moment that I kiss

00:18:00,260 --> 00:18:04,850
the central application those same

00:18:02,240 --> 00:18:06,620
packets will be forwarded to my

00:18:04,850 --> 00:18:08,540
container I don't want to find out

00:18:06,620 --> 00:18:11,320
whatever I wanted to be done

00:18:08,540 --> 00:18:15,620
automatically for him for me

00:18:11,320 --> 00:18:20,760
[Applause]

00:18:15,620 --> 00:18:20,760

YouTube URL: https://www.youtube.com/watch?v=3Ij0aZRsw9w


