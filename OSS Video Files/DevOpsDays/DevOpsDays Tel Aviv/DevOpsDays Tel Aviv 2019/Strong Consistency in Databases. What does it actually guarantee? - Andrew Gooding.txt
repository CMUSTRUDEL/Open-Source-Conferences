Title: Strong Consistency in Databases. What does it actually guarantee? - Andrew Gooding
Publication date: 2020-01-12
Playlist: DevOpsDays Tel Aviv 2019
Description: 
	Distributed data stores are subject to the CAP theorem, and historically NoSQL distributed systems have chosen availability over consistency. This has been changing, yet many famous databases are still AP only.

In Eric Brewer's 2012 follow-up article about the CAP theorem he stated:
"Availability is obviously continuous from 0 to 100 percent, but there are also many levels of consistency, and even partitions have nuances, including disagreement within the system about whether a partition exists."

This talk will include a theoretical overview, but focus on the practical aspects of the theorem.

* What are the tradeoffs between AP and CP modes?

* How do they affect your application and data?

* How do different levels of consistency actually matter?
Captions: 
	00:00:00,440 --> 00:00:03,580
[Music]

00:00:04,850 --> 00:00:12,120
okay hello hello everybody my name is

00:00:09,599 --> 00:00:16,260
Andy Gooding I'm the vice president of

00:00:12,120 --> 00:00:19,039
engineering at aerospike we make a

00:00:16,260 --> 00:00:23,189
database some of you may even use it

00:00:19,039 --> 00:00:26,490
I've been there for eight years so

00:00:23,189 --> 00:00:30,779
almost from it's very beginning before

00:00:26,490 --> 00:00:33,210
that I spent many years doing a lot of

00:00:30,779 --> 00:00:35,550
other kinds of software mostly embedded

00:00:33,210 --> 00:00:40,110
systems like phones and set-top boxes

00:00:35,550 --> 00:00:44,100
and if you go far enough back you find

00:00:40,110 --> 00:00:46,559
that I'm not really a computer scientist

00:00:44,100 --> 00:00:49,739
originally I was a theoretical physicist

00:00:46,559 --> 00:00:52,500
so I came to this from a different angle

00:00:49,739 --> 00:00:57,690
from most people but don't let that

00:00:52,500 --> 00:01:00,420
worry you two years ago we added a big

00:00:57,690 --> 00:01:05,430
feature aerospike we added strong

00:01:00,420 --> 00:01:08,310
consistency as an option when we did it

00:01:05,430 --> 00:01:10,200
we we tried a very novel approach for

00:01:08,310 --> 00:01:12,960
what we thought were very good reasons

00:01:10,200 --> 00:01:15,720
and we still think are very good season

00:01:12,960 --> 00:01:19,350
reasons and and it worked out really

00:01:15,720 --> 00:01:21,240
well our we think our system is great it

00:01:19,350 --> 00:01:24,799
works it actually guarantees strong

00:01:21,240 --> 00:01:27,689
consistency but this talk is not about

00:01:24,799 --> 00:01:31,759
aerospike strong consistency it's just

00:01:27,689 --> 00:01:35,880
about strong consistency in general so

00:01:31,759 --> 00:01:38,220
really it's about what is it what does a

00:01:35,880 --> 00:01:40,500
guarantee mean do you care what are the

00:01:38,220 --> 00:01:44,189
alternatives what does it mean for you

00:01:40,500 --> 00:01:47,430
as a developer or DevOps what does it

00:01:44,189 --> 00:01:50,130
mean an operation maybe what are the

00:01:47,430 --> 00:01:56,090
trade-offs with the alternatives all

00:01:50,130 --> 00:01:59,490
right so yeah let's get to it

00:01:56,090 --> 00:02:01,680
so I said it wasn't a computer

00:01:59,490 --> 00:02:04,649
scientists and that's true

00:02:01,680 --> 00:02:05,969
but if you are or you were you went to

00:02:04,649 --> 00:02:07,860
school in it you've probably heard of

00:02:05,969 --> 00:02:10,800
this thing called the cap theorem I'm

00:02:07,860 --> 00:02:12,510
not going to prove it here although

00:02:10,800 --> 00:02:13,319
maybe by the end of the talk you'll have

00:02:12,510 --> 00:02:20,250
some

00:02:13,319 --> 00:02:23,459
some sense as to why it it's true the

00:02:20,250 --> 00:02:25,620
letters in cap are for the c is for

00:02:23,459 --> 00:02:28,349
consistency they a is for availability

00:02:25,620 --> 00:02:30,510
and the P is for partitioning so we're

00:02:28,349 --> 00:02:34,860
talking about databases of our clusters

00:02:30,510 --> 00:02:36,900
and the P is when we say cluster

00:02:34,860 --> 00:02:40,349
partitioning it means that the cluster

00:02:36,900 --> 00:02:44,220
kind of breaks up or isn't all there

00:02:40,349 --> 00:02:46,620
the C in which is consistency I've

00:02:44,220 --> 00:02:50,090
modified with strong consistency for

00:02:46,620 --> 00:02:55,700
reasons that may become apparent later

00:02:50,090 --> 00:02:55,700
but anyway what does this mean

00:02:55,760 --> 00:02:59,879
theorem basically says that there are

00:02:58,049 --> 00:03:02,909
these three things and when you have a

00:02:59,879 --> 00:03:06,930
distributed system database you get to

00:03:02,909 --> 00:03:14,870
choose any two as long as one of them is

00:03:06,930 --> 00:03:18,299
P and so that doesn't seem fair C and a

00:03:14,870 --> 00:03:20,760
sound pretty cool consistency sounds

00:03:18,299 --> 00:03:23,609
cool availability sounds cool cluster

00:03:20,760 --> 00:03:26,430
partitioning does not sound cool so why

00:03:23,609 --> 00:03:28,620
do I have to choose that one and the

00:03:26,430 --> 00:03:31,819
reason is because in the real world you

00:03:28,620 --> 00:03:31,819
don't really have a choice

00:03:34,310 --> 00:03:41,489
partitions just happen nodes go down and

00:03:38,730 --> 00:03:44,010
it doesn't necessarily mean that your

00:03:41,489 --> 00:03:46,709
software hat isn't perfect it can be

00:03:44,010 --> 00:03:51,329
hardware it can be someone kicked the

00:03:46,709 --> 00:03:53,160
plug out but nodes will go down and also

00:03:51,329 --> 00:03:56,669
any of you that have any experience with

00:03:53,160 --> 00:03:59,459
networks know that connections are not

00:03:56,669 --> 00:04:01,430
perfect eventually something's gonna

00:03:59,459 --> 00:04:03,900
happen connections will break and

00:04:01,430 --> 00:04:06,120
usually when people are discussing cap

00:04:03,900 --> 00:04:07,250
and cluster partitions this is kind of

00:04:06,120 --> 00:04:09,870
what they're talking about

00:04:07,250 --> 00:04:11,879
they're talking about split brain

00:04:09,870 --> 00:04:13,440
scenarios you know where some of the

00:04:11,879 --> 00:04:15,299
cluster can't see the rest of the

00:04:13,440 --> 00:04:20,699
cluster or the clients can't see the

00:04:15,299 --> 00:04:22,849
cluster server nodes but I but at some

00:04:20,699 --> 00:04:25,229
level you know if you have a node that

00:04:22,849 --> 00:04:26,070
nothing can see it it may as well be

00:04:25,229 --> 00:04:28,680
down and

00:04:26,070 --> 00:04:32,040
so nodes being down also kind of count

00:04:28,680 --> 00:04:34,110
as partitioning so this is just gonna

00:04:32,040 --> 00:04:35,820
happen and most of you in here probably

00:04:34,110 --> 00:04:38,460
already know this I don't have to try

00:04:35,820 --> 00:04:40,970
and convince you that that you you just

00:04:38,460 --> 00:04:44,250
got to choose P it's not really a choice

00:04:40,970 --> 00:04:48,180
so really it comes down to you're gonna

00:04:44,250 --> 00:04:50,760
choose consistency or availability so

00:04:48,180 --> 00:04:53,070
again consistency we will call strong

00:04:50,760 --> 00:04:57,030
consistency availability maximum

00:04:53,070 --> 00:05:00,150
availability strong consistency is

00:04:57,030 --> 00:05:02,040
actually very well defined it has a I

00:05:00,150 --> 00:05:07,770
think a pretty clear definition which

00:05:02,040 --> 00:05:10,980
I'll show you in a minute and maximum

00:05:07,770 --> 00:05:12,720
availability one thing I want to point

00:05:10,980 --> 00:05:14,190
out there is that it doesn't mean a

00:05:12,720 --> 00:05:18,060
hundred percent availability

00:05:14,190 --> 00:05:20,700
availability no matter what you do the

00:05:18,060 --> 00:05:24,630
the sad news is that it can it can

00:05:20,700 --> 00:05:26,640
always go to zero if here someone blows

00:05:24,630 --> 00:05:28,980
your cluster up or all your clusters up

00:05:26,640 --> 00:05:32,370
and or the power goes out you're gonna

00:05:28,980 --> 00:05:34,710
end up with zero availability no matter

00:05:32,370 --> 00:05:38,550
how good your hardware and software is

00:05:34,710 --> 00:05:40,340
so of a Israeli maximum availability and

00:05:38,550 --> 00:05:45,870
I'll tell you what I think that means

00:05:40,340 --> 00:05:47,760
also in a minute okay one other thing I

00:05:45,870 --> 00:05:50,370
want Apple other things I want to point

00:05:47,760 --> 00:05:53,640
out is that yeah you have to make this

00:05:50,370 --> 00:05:56,190
choice but it might not be as dire as it

00:05:53,640 --> 00:06:00,180
sounds it doesn't mean that if I choose

00:05:56,190 --> 00:06:01,740
C in every single possible scenario

00:06:00,180 --> 00:06:03,860
where the cluster isn't hold that I'm

00:06:01,740 --> 00:06:06,390
going to lose availability and

00:06:03,860 --> 00:06:08,250
conversely choosing a doesn't

00:06:06,390 --> 00:06:13,350
necessarily mean that that every

00:06:08,250 --> 00:06:16,020
scenario breaks consistency most most

00:06:13,350 --> 00:06:18,090
good distributed systems should be able

00:06:16,020 --> 00:06:21,150
to tell around tolerate a certain amount

00:06:18,090 --> 00:06:23,430
of P without without actually

00:06:21,150 --> 00:06:26,490
sacrificing either one whether it calls

00:06:23,430 --> 00:06:29,970
itself a CP or an AP system in

00:06:26,490 --> 00:06:31,860
particular most of them should at least

00:06:29,970 --> 00:06:34,440
they'll allow you to upgrade your

00:06:31,860 --> 00:06:37,169
cluster so take one node down at a time

00:06:34,440 --> 00:06:39,750
or however many nodes down at a time do

00:06:37,169 --> 00:06:42,870
a rolling upgrade without sacrifice

00:06:39,750 --> 00:06:45,150
pricing either consistency or you're a

00:06:42,870 --> 00:06:48,780
hundred percent of the ability or your

00:06:45,150 --> 00:06:50,460
maximum availability so it's really the

00:06:48,780 --> 00:06:52,220
choice is about what happens when things

00:06:50,460 --> 00:06:55,680
get worse

00:06:52,220 --> 00:06:59,310
okay so promise to promise you a nice

00:06:55,680 --> 00:07:05,400
clean definition for strong consistency

00:06:59,310 --> 00:07:08,010
so here it is in simplest terms what it

00:07:05,400 --> 00:07:11,550
means is that from the point of view of

00:07:08,010 --> 00:07:16,440
the clients the outside world a given

00:07:11,550 --> 00:07:18,660
record the it has only a single linear

00:07:16,440 --> 00:07:21,210
progression of the record version and

00:07:18,660 --> 00:07:23,160
its content and that may sound kind of

00:07:21,210 --> 00:07:25,380
obvious some trivial like you know isn't

00:07:23,160 --> 00:07:28,260
isn't that what all databases do and

00:07:25,380 --> 00:07:30,360
turns out no and distributed systems

00:07:28,260 --> 00:07:34,680
it's not actually a given or trivial

00:07:30,360 --> 00:07:36,740
that this happens but this is one half

00:07:34,680 --> 00:07:41,880
of the definition of strong consistency

00:07:36,740 --> 00:07:45,600
so these I drew a string of versions

00:07:41,880 --> 00:07:48,290
there with operations each operation is

00:07:45,600 --> 00:07:51,120
a right essentially it's looking at the

00:07:48,290 --> 00:07:53,340
current version of the record and it

00:07:51,120 --> 00:07:55,500
takes you to a new version of the record

00:07:53,340 --> 00:07:58,169
it could literally be an atomic

00:07:55,500 --> 00:08:00,030
operation or it could be two

00:07:58,169 --> 00:08:02,880
transactions where you do a read modify

00:08:00,030 --> 00:08:04,919
write to the generation check but the

00:08:02,880 --> 00:08:07,410
idea is that you're going from one

00:08:04,919 --> 00:08:10,710
version to the next and almost all the

00:08:07,410 --> 00:08:12,270
time it depends on on the previous

00:08:10,710 --> 00:08:15,000
version of the record what the next

00:08:12,270 --> 00:08:18,530
version of the record is going to be so

00:08:15,000 --> 00:08:22,350
the other part of the definition is that

00:08:18,530 --> 00:08:25,790
any operation that you do that is

00:08:22,350 --> 00:08:28,320
acknowledged as successful to any client

00:08:25,790 --> 00:08:32,940
has to be reflected in the progression

00:08:28,320 --> 00:08:35,159
and never be lost so but that that's the

00:08:32,940 --> 00:08:37,169
long way of saying don't lose rights if

00:08:35,159 --> 00:08:40,380
I if I did this thing and it succeeded

00:08:37,169 --> 00:08:43,200
it better not evidence of it better not

00:08:40,380 --> 00:08:46,740
magically disappear later on or not be

00:08:43,200 --> 00:08:50,250
visible from another view so to me this

00:08:46,740 --> 00:08:53,750
is strong consistency there are some

00:08:50,250 --> 00:08:56,240
nuances concerning read-only

00:08:53,750 --> 00:08:59,510
operations and version progressions you

00:08:56,240 --> 00:09:01,310
see there I'll come back and talk about

00:08:59,510 --> 00:09:03,850
that later but I don't want to kind of

00:09:01,310 --> 00:09:10,180
muddy up what I think the the actual

00:09:03,850 --> 00:09:10,180
definition of strong consistency is so

00:09:11,170 --> 00:09:21,320
okay what's maximum availability in

00:09:17,110 --> 00:09:23,720
simplest terms that means that I'm going

00:09:21,320 --> 00:09:26,360
to my operations are going to succeed as

00:09:23,720 --> 00:09:31,670
long as any part of the cluster is

00:09:26,360 --> 00:09:35,810
visible so for example I may have a

00:09:31,670 --> 00:09:37,850
bunch of connection failures even if I

00:09:35,810 --> 00:09:40,610
can only see one node from a given

00:09:37,850 --> 00:09:44,420
client I'm gonna my operations going to

00:09:40,610 --> 00:09:46,390
succeed on that node so it really is

00:09:44,420 --> 00:09:49,340
saying that you know I'm just gonna

00:09:46,390 --> 00:09:51,320
whatever I can see I'm always gonna go

00:09:49,340 --> 00:09:52,880
ahead and just and just do the operation

00:09:51,320 --> 00:09:54,650
even if I can't see the clip the whole

00:09:52,880 --> 00:10:00,980
cluster even though even if I can only

00:09:54,650 --> 00:10:04,790
see one teeny piece of it I okay what

00:10:00,980 --> 00:10:07,100
that pretty much means is in a in an AP

00:10:04,790 --> 00:10:10,460
system where you've chosen maximum

00:10:07,100 --> 00:10:12,470
availability you are gonna allow the

00:10:10,460 --> 00:10:14,450
record progression that we just talked

00:10:12,470 --> 00:10:15,890
about the single linear progression in

00:10:14,450 --> 00:10:18,740
strong consistency

00:10:15,890 --> 00:10:22,010
you're gonna bag that you're gonna allow

00:10:18,740 --> 00:10:24,620
the record progression to split and the

00:10:22,010 --> 00:10:27,740
way that happens is really that pretty

00:10:24,620 --> 00:10:30,620
much what's going on is you you're using

00:10:27,740 --> 00:10:32,390
replication so a copy of your record and

00:10:30,620 --> 00:10:35,300
there's just not one copy of your record

00:10:32,390 --> 00:10:39,680
in the cluster I it's usually two or

00:10:35,300 --> 00:10:42,589
more and they're on different nodes and

00:10:39,680 --> 00:10:46,150
when you get these foot brain scenarios

00:10:42,589 --> 00:10:49,490
what can happen is different clients see

00:10:46,150 --> 00:10:51,230
different replicas and they start the

00:10:49,490 --> 00:10:55,339
same but if the different clients start

00:10:51,230 --> 00:10:57,370
doing operations on different replicas

00:10:55,339 --> 00:11:00,770
because there are the ones you can see

00:10:57,370 --> 00:11:03,950
then you will get different lineages

00:11:00,770 --> 00:11:06,709
so that the record will the record

00:11:03,950 --> 00:11:07,490
progression will split it can even be

00:11:06,709 --> 00:11:09,410
one client

00:11:07,490 --> 00:11:11,240
that ends up doing the split if it just

00:11:09,410 --> 00:11:13,310
alternately sees one node and then

00:11:11,240 --> 00:11:14,930
another and the two replicas resided

00:11:13,310 --> 00:11:16,820
there you can do an operation in water

00:11:14,930 --> 00:11:19,370
then you can go back to the older

00:11:16,820 --> 00:11:22,720
version and do another operation that

00:11:19,370 --> 00:11:25,670
starts on the older version again so

00:11:22,720 --> 00:11:31,000
that that's the thing that you're gonna

00:11:25,670 --> 00:11:34,850
allow so by definition that breaks

00:11:31,000 --> 00:11:38,830
consistency so you know you can sort of

00:11:34,850 --> 00:11:38,830
start to see what the trade-off is here

00:11:38,860 --> 00:11:46,459
so here's a drawing of a simple split

00:11:43,160 --> 00:11:48,500
those same four operations that that

00:11:46,459 --> 00:11:52,730
happened that I drew for you in strong

00:11:48,500 --> 00:11:55,070
consistency go one through oh four if it

00:11:52,730 --> 00:11:58,360
turns out that oh one and Oh to end up

00:11:55,070 --> 00:12:01,820
starting on different copies of the

00:11:58,360 --> 00:12:04,700
version zero of your record you end up

00:12:01,820 --> 00:12:06,649
with these versions here that just

00:12:04,700 --> 00:12:09,920
aren't the same thing as the versions

00:12:06,649 --> 00:12:13,130
that you saw in in the strong

00:12:09,920 --> 00:12:17,810
consistency sequence so V Y is just

00:12:13,130 --> 00:12:20,209
missing a one VB is missing o2 and o3 so

00:12:17,810 --> 00:12:24,380
your your Eve already violated your

00:12:20,209 --> 00:12:27,170
consistency contract I I bet eventually

00:12:24,380 --> 00:12:29,750
perhaps here your cluster will mend

00:12:27,170 --> 00:12:32,720
itself and so you'll take all the

00:12:29,750 --> 00:12:38,000
versions that split and you'll merge

00:12:32,720 --> 00:12:40,520
them together again and sometimes if

00:12:38,000 --> 00:12:43,579
you're really clever you might actually

00:12:40,520 --> 00:12:45,620
even be able to recover v4 in other

00:12:43,579 --> 00:12:47,360
words the exact record that you would

00:12:45,620 --> 00:12:49,279
have seen if none of this ever happened

00:12:47,360 --> 00:12:51,800
none of the splitting ever happened and

00:12:49,279 --> 00:12:57,430
and you know you were you guaranteed

00:12:51,800 --> 00:13:01,010
strong consistency I people call this

00:12:57,430 --> 00:13:03,500
eventual consistency and it's sort of

00:13:01,010 --> 00:13:05,660
why we've kind of added the strong to

00:13:03,500 --> 00:13:07,850
consistency as far as cap theorem is

00:13:05,660 --> 00:13:10,670
concerned the letter C and consistency

00:13:07,850 --> 00:13:13,579
mean strong consistency but since people

00:13:10,670 --> 00:13:15,800
call this eventual consistency we kind

00:13:13,579 --> 00:13:18,079
of put the strong on the thing the cap

00:13:15,800 --> 00:13:20,710
is talking about to distinguish it from

00:13:18,079 --> 00:13:23,660
this so

00:13:20,710 --> 00:13:27,680
so yeah this is eventual consistency the

00:13:23,660 --> 00:13:29,600
the ability to take all your split

00:13:27,680 --> 00:13:31,580
lineages and merge them back together to

00:13:29,600 --> 00:13:35,620
make it as if all the splitting was just

00:13:31,580 --> 00:13:40,310
a bad dream and it never happened so

00:13:35,620 --> 00:13:42,590
this graphic is the rainbow powered unit

00:13:40,310 --> 00:13:48,140
flying unicorn is probably what got this

00:13:42,590 --> 00:13:50,390
talk into this DevOps meetup it I don't

00:13:48,140 --> 00:13:55,520
mean to imply that I don't believe in

00:13:50,390 --> 00:13:58,220
eventual consistency it is a thing but

00:13:55,520 --> 00:14:00,290
there's a lot of Mythology surrounding

00:13:58,220 --> 00:14:03,290
it and so it's probably worth where I'm

00:14:00,290 --> 00:14:05,930
gonna spend a few slides on that kind of

00:14:03,290 --> 00:14:07,850
explaining or you know talking about the

00:14:05,930 --> 00:14:09,980
mythology around it so I've had

00:14:07,850 --> 00:14:12,470
conversations with with people like

00:14:09,980 --> 00:14:14,840
potential customers for our database and

00:14:12,470 --> 00:14:18,080
say you know I really love strong

00:14:14,840 --> 00:14:19,970
consistency but but you know if you

00:14:18,080 --> 00:14:22,520
can't if you can't give it to us then

00:14:19,970 --> 00:14:24,470
that's okay we can we can manage with

00:14:22,520 --> 00:14:27,140
eventual consistency so just give us

00:14:24,470 --> 00:14:29,270
that and I'll ask them wait you you

00:14:27,140 --> 00:14:31,550
prefer eventual consistency then no no

00:14:29,270 --> 00:14:33,320
no we would love strong consistency but

00:14:31,550 --> 00:14:36,230
if you can't do it we'll settle for

00:14:33,320 --> 00:14:37,640
eventual consistency so you know in

00:14:36,230 --> 00:14:39,560
their mind it's this thing that's

00:14:37,640 --> 00:14:41,210
somewhere along the way to strong

00:14:39,560 --> 00:14:43,820
consistency and it's as if they think

00:14:41,210 --> 00:14:46,580
well if you're trying to develop a

00:14:43,820 --> 00:14:47,780
strong consistency system you can just

00:14:46,580 --> 00:14:50,540
kind of stop short

00:14:47,780 --> 00:14:54,200
you have eventual consistency and that's

00:14:50,540 --> 00:14:57,590
just not the case at all they are very

00:14:54,200 --> 00:14:59,720
different unicorns they they both have

00:14:57,590 --> 00:15:01,340
four legs on a horn on their fart and

00:14:59,720 --> 00:15:04,040
they're powered by rainbows but the

00:15:01,340 --> 00:15:08,710
resemblance stops there they really very

00:15:04,040 --> 00:15:11,000
different things and so I so you know if

00:15:08,710 --> 00:15:13,370
I'm gonna take you through a little bit

00:15:11,000 --> 00:15:15,620
eventual consistency and you know kind

00:15:13,370 --> 00:15:19,730
of see why so one of the big differences

00:15:15,620 --> 00:15:22,850
is eventual consistency is very useful

00:15:19,730 --> 00:15:25,670
it depends on what you're doing in these

00:15:22,850 --> 00:15:29,180
operations whether how tractable it is

00:15:25,670 --> 00:15:32,660
to achieve eventual consistency so I'll

00:15:29,180 --> 00:15:33,950
show you that even in simple paces

00:15:32,660 --> 00:15:36,200
eventual consistency

00:15:33,950 --> 00:15:39,410
can be tricky and have some costs so

00:15:36,200 --> 00:15:41,900
let's look at that operation split

00:15:39,410 --> 00:15:44,780
sequence again and suppose that our

00:15:41,900 --> 00:15:47,270
operations are just arithmetic additions

00:15:44,780 --> 00:15:49,370
or maybe subtractions so if you're

00:15:47,270 --> 00:15:51,260
version 0 the value is a hundred you

00:15:49,370 --> 00:15:53,570
have all these things plus five plus

00:15:51,260 --> 00:15:56,690
seven and one split plus two plus nine

00:15:53,570 --> 00:15:58,850
and the other if you were to achieve

00:15:56,690 --> 00:16:01,370
eventual consistency here when they

00:15:58,850 --> 00:16:04,550
merge back together you need the value

00:16:01,370 --> 00:16:08,300
123 to show up that all of those ops

00:16:04,550 --> 00:16:12,890
happened but the key thing to note here

00:16:08,300 --> 00:16:15,290
is that version B in version Y which are

00:16:12,890 --> 00:16:18,850
what you have at the end of each split

00:16:15,290 --> 00:16:23,000
are by themselves not enough to generate

00:16:18,850 --> 00:16:24,740
the four value you you kind of have to

00:16:23,000 --> 00:16:28,220
know what the value was when these

00:16:24,740 --> 00:16:30,530
things split and it gets more involved

00:16:28,220 --> 00:16:32,780
you you actually have to kind of know

00:16:30,530 --> 00:16:35,030
the version of the splits because I drew

00:16:32,780 --> 00:16:38,120
you one simple split here but you could

00:16:35,030 --> 00:16:40,310
have multiple splits you could have

00:16:38,120 --> 00:16:41,990
lineages that start from scratch on a

00:16:40,310 --> 00:16:44,240
node that didn't have a copy of the

00:16:41,990 --> 00:16:46,010
replicas your merge backs could be

00:16:44,240 --> 00:16:47,510
complicated you may not be able to see

00:16:46,010 --> 00:16:49,280
all the things at once you may be

00:16:47,510 --> 00:16:51,770
merging a long lineage with another one

00:16:49,280 --> 00:16:54,200
that that you didn't directly split from

00:16:51,770 --> 00:16:56,630
and so it turns out you actually kind of

00:16:54,200 --> 00:16:58,370
have to be able to ID the the record you

00:16:56,630 --> 00:17:02,090
know that goes with the value that you

00:16:58,370 --> 00:17:03,830
have at the split so you need to know

00:17:02,090 --> 00:17:06,680
the versions and values at the splits

00:17:03,830 --> 00:17:10,670
and you you kind of either need to know

00:17:06,680 --> 00:17:12,709
when your split and or or hold when your

00:17:10,670 --> 00:17:14,690
not split to be able to clean up this

00:17:12,709 --> 00:17:17,720
history or you're gonna end up storing

00:17:14,690 --> 00:17:19,400
all the versions and values and that is

00:17:17,720 --> 00:17:21,410
just you know now you're in a world

00:17:19,400 --> 00:17:23,570
where that's just a different kind of

00:17:21,410 --> 00:17:25,850
database if you have to keep track of

00:17:23,570 --> 00:17:27,770
all of this history for records when

00:17:25,850 --> 00:17:32,300
they're split and repair it when when

00:17:27,770 --> 00:17:34,040
you think they're whole again so in

00:17:32,300 --> 00:17:36,950
general that was actually a pretty

00:17:34,040 --> 00:17:40,310
simple use case by the most people's

00:17:36,950 --> 00:17:42,950
standards it gets trickier operations

00:17:40,310 --> 00:17:45,080
might not be derived from values so you

00:17:42,950 --> 00:17:46,430
I have four going to eight if you know

00:17:45,080 --> 00:17:49,400
you're just doing a written with a cool

00:17:46,430 --> 00:17:51,800
yeah that was a plus four but if it

00:17:49,400 --> 00:17:53,450
could have been more operations I don't

00:17:51,800 --> 00:17:57,320
know other things can get you from four

00:17:53,450 --> 00:18:00,130
to eight to similarly previous values

00:17:57,320 --> 00:18:03,110
may not be derived from operations

00:18:00,130 --> 00:18:05,540
obviously something like a hash takes

00:18:03,110 --> 00:18:08,300
many different initial values to the

00:18:05,540 --> 00:18:10,610
same final value but it's not just

00:18:08,300 --> 00:18:13,430
hashes you can do things like an

00:18:10,610 --> 00:18:15,860
arithmetic mod or you might have a list

00:18:13,430 --> 00:18:16,430
that you trim and select stuff out of

00:18:15,860 --> 00:18:18,200
them

00:18:16,430 --> 00:18:21,020
you know you can see what what's left

00:18:18,200 --> 00:18:22,730
but drop the bottom ten things I have no

00:18:21,020 --> 00:18:29,060
idea what the heck those were before

00:18:22,730 --> 00:18:31,250
this operation and finally operations

00:18:29,060 --> 00:18:32,840
may not necessarily commute meaning

00:18:31,250 --> 00:18:34,820
they're they're being taped they may not

00:18:32,840 --> 00:18:36,920
be order dependent so if you're just

00:18:34,820 --> 00:18:39,320
doing arithmetic addition yeah plus five

00:18:36,920 --> 00:18:42,250
plus three same as plus three plus five

00:18:39,320 --> 00:18:44,390
but can change some arithmetic here and

00:18:42,250 --> 00:18:46,370
suddenly it doesn't work that way

00:18:44,390 --> 00:18:49,100
anymore it matters what order you you

00:18:46,370 --> 00:18:51,500
apply these operations in and it's not

00:18:49,100 --> 00:18:53,960
just you know arithmetic operations is

00:18:51,500 --> 00:18:56,900
most things actually kind of seem to be

00:18:53,960 --> 00:19:00,680
this way like string concatenation you

00:18:56,900 --> 00:19:03,170
know start with cat append woman then

00:19:00,680 --> 00:19:07,700
rules that's very different to you know

00:19:03,170 --> 00:19:10,070
cat rules woman so it's a it just a lot

00:19:07,700 --> 00:19:13,310
of things it's just a this is not an

00:19:10,070 --> 00:19:17,240
unusual thing so the order matters and

00:19:13,310 --> 00:19:19,550
so what that all means is you can't just

00:19:17,240 --> 00:19:21,440
store the version and value ups but you

00:19:19,550 --> 00:19:23,840
gotta know all the operations and the

00:19:21,440 --> 00:19:25,730
times they happen since then if you're

00:19:23,840 --> 00:19:29,540
gonna try and cover every use case there

00:19:25,730 --> 00:19:32,000
is and so now you're talking you know

00:19:29,540 --> 00:19:33,410
this this is starting to get costly it's

00:19:32,000 --> 00:19:36,770
like you know what are my records

00:19:33,410 --> 00:19:38,000
blockchains you know it's just you're

00:19:36,770 --> 00:19:41,120
gonna have to keep track of a lot of

00:19:38,000 --> 00:19:43,910
stuff either forever or be fancy about

00:19:41,120 --> 00:19:45,320
knowing the stay to your cluster and you

00:19:43,910 --> 00:19:49,570
know when your records split them to

00:19:45,320 --> 00:19:52,700
come whole again to clean up history so

00:19:49,570 --> 00:19:55,060
so yeah I mean it can get complicated

00:19:52,700 --> 00:19:56,530
and certainly to do it generically is

00:19:55,060 --> 00:20:00,080
extreme

00:19:56,530 --> 00:20:01,820
complicated strong consistency systems

00:20:00,080 --> 00:20:03,770
generally you don't have to deal with

00:20:01,820 --> 00:20:06,440
this you absolutely don't need any

00:20:03,770 --> 00:20:08,660
history at all you can you can implement

00:20:06,440 --> 00:20:10,820
a system with the final version you know

00:20:08,660 --> 00:20:14,690
you don't you know to do this stuff and

00:20:10,820 --> 00:20:18,890
so again very different unicorns so a

00:20:14,690 --> 00:20:22,220
lot of people might say oh well why

00:20:18,890 --> 00:20:24,700
can't I just use CRT T's well

00:20:22,220 --> 00:20:27,980
CRT T's all that is is really a way of

00:20:24,700 --> 00:20:30,920
packaging everything I just said in into

00:20:27,980 --> 00:20:33,980
the data type and so the C R DT is also

00:20:30,920 --> 00:20:36,650
very a very very use case dependent if

00:20:33,980 --> 00:20:38,690
the C R DT is meant to handle a certain

00:20:36,650 --> 00:20:42,230
class of operations it might be quite

00:20:38,690 --> 00:20:44,270
tractable if if it's a bigger class that

00:20:42,230 --> 00:20:48,260
can get really hairy a lot of effort

00:20:44,270 --> 00:20:49,820
goes into those things but but yeah in

00:20:48,260 --> 00:20:53,300
general they're incredibly use case

00:20:49,820 --> 00:20:55,640
dependent and it's just really a neat

00:20:53,300 --> 00:20:57,920
our way of maybe of packaging everything

00:20:55,640 --> 00:21:00,320
I just said they're storing the history

00:20:57,920 --> 00:21:02,950
they need and they're managing it Nord

00:21:00,320 --> 00:21:05,480
in order to be able to recover the the

00:21:02,950 --> 00:21:07,850
version of the final version of the

00:21:05,480 --> 00:21:09,260
record after the merge you want they'll

00:21:07,850 --> 00:21:11,060
also get a lot of people that say oh

00:21:09,260 --> 00:21:16,130
just just give me you can meet the two

00:21:11,060 --> 00:21:18,440
records and I'll merge them and that can

00:21:16,130 --> 00:21:20,570
be a heck of a thing in two ways that

00:21:18,440 --> 00:21:22,340
actually Tufton turns out that you know

00:21:20,570 --> 00:21:24,680
they they end up saying oh yeah and we

00:21:22,340 --> 00:21:27,200
leave the history too you know but

00:21:24,680 --> 00:21:31,060
sometimes even if they can somehow do an

00:21:27,200 --> 00:21:34,250
acceptable merge without much history

00:21:31,060 --> 00:21:36,320
it's still a just a sort of an

00:21:34,250 --> 00:21:38,270
application costly thing you have to

00:21:36,320 --> 00:21:40,310
present these things through some

00:21:38,270 --> 00:21:41,900
notification scheme to the app they have

00:21:40,310 --> 00:21:44,330
to deal that you have to write them back

00:21:41,900 --> 00:21:47,030
so there all sorts of costs there - that

00:21:44,330 --> 00:21:50,590
- that's not generally as as easy as

00:21:47,030 --> 00:21:55,040
people like to think so yeah in general

00:21:50,590 --> 00:21:57,410
eventual consistency very complex as

00:21:55,040 --> 00:22:02,720
spent and especially in a use case

00:21:57,410 --> 00:22:05,180
dependent so yeah you just have to know

00:22:02,720 --> 00:22:07,100
that this this is not just a stop along

00:22:05,180 --> 00:22:08,030
the route to strong consistency it's

00:22:07,100 --> 00:22:10,910
something

00:22:08,030 --> 00:22:15,380
completely different and again reminding

00:22:10,910 --> 00:22:17,090
you that it is not you are not in the C

00:22:15,380 --> 00:22:19,370
world of the cap here if you're doing

00:22:17,090 --> 00:22:21,220
eventual consistency or firmly in the a

00:22:19,370 --> 00:22:24,050
world its aha it's the high availability

00:22:21,220 --> 00:22:27,020
system you're just trying to expend a

00:22:24,050 --> 00:22:29,000
lot of effort to to minimize or if

00:22:27,020 --> 00:22:32,000
you're lucky eradicate the permanent day

00:22:29,000 --> 00:22:34,100
to loss but but you're in an AP system

00:22:32,000 --> 00:22:36,200
when the splits are going on and they

00:22:34,100 --> 00:22:38,150
can go on for a long time

00:22:36,200 --> 00:22:45,370
strong consistency is out the window

00:22:38,150 --> 00:22:47,330
this is not strong consistency okay so

00:22:45,370 --> 00:22:49,970
if you're gonna choose a high

00:22:47,330 --> 00:22:52,400
availability system maybe you have all

00:22:49,970 --> 00:22:54,470
these fancy CRT T's and so forth and you

00:22:52,400 --> 00:22:58,010
can get your your eventual consistency

00:22:54,470 --> 00:23:00,710
but what it usually means is that people

00:22:58,010 --> 00:23:03,560
are choosing to lose rights so again

00:23:00,710 --> 00:23:07,820
back to our simple split scenario or a

00:23:03,560 --> 00:23:10,850
simple split scenario you generally end

00:23:07,820 --> 00:23:13,000
up with much more much simpler merge

00:23:10,850 --> 00:23:15,920
schemes when the cluster mends itself

00:23:13,000 --> 00:23:18,140
for example you can just pick the latest

00:23:15,920 --> 00:23:21,590
one in this case that means you lose two

00:23:18,140 --> 00:23:23,450
rights the X and the y or maybe you have

00:23:21,590 --> 00:23:25,400
a policy where you pick the one with the

00:23:23,450 --> 00:23:29,150
most history which in this case means

00:23:25,400 --> 00:23:32,080
you might lose the latest Wan but either

00:23:29,150 --> 00:23:38,900
way you're you're losing something there

00:23:32,080 --> 00:23:41,690
let me actually flip back to to the to

00:23:38,900 --> 00:23:45,230
this guy where you pick the latest just

00:23:41,690 --> 00:23:47,240
a hammer home the notion that eventual

00:23:45,230 --> 00:23:49,670
consistency is incredibly use case

00:23:47,240 --> 00:23:52,280
dependent I can claim that this is

00:23:49,670 --> 00:23:54,170
eventual consistency if my usage model

00:23:52,280 --> 00:23:56,240
is such that these operations actually

00:23:54,170 --> 00:23:59,000
don't care about the previous value like

00:23:56,240 --> 00:24:00,740
maybe I'm just writing my record is just

00:23:59,000 --> 00:24:03,200
the current position of something and I

00:24:00,740 --> 00:24:06,260
don't care where it was before in this

00:24:03,200 --> 00:24:08,060
case if I you know but if I choose VA

00:24:06,260 --> 00:24:10,430
well that's what what it would have been

00:24:08,060 --> 00:24:12,890
if I have a strong consistent system you

00:24:10,430 --> 00:24:16,370
know it would have I would have ended up

00:24:12,890 --> 00:24:18,020
with VA anyway because I it's just I'm

00:24:16,370 --> 00:24:20,090
just right here a brand new record and

00:24:18,020 --> 00:24:21,590
that's what it would have been so that's

00:24:20,090 --> 00:24:23,720
the the ultimate Dempster

00:24:21,590 --> 00:24:26,630
of how you space dependent eventual

00:24:23,720 --> 00:24:29,210
consistency is but yeah generally what

00:24:26,630 --> 00:24:35,410
we're talking about is is we're losing

00:24:29,210 --> 00:24:37,640
rights I so again a quick summary I

00:24:35,410 --> 00:24:41,600
you're choosing hey you're gonna allow

00:24:37,640 --> 00:24:43,550
these record progression splits which

00:24:41,600 --> 00:24:45,290
you know since they're you're allowing

00:24:43,550 --> 00:24:47,390
them and they're observable by

00:24:45,290 --> 00:24:51,230
definition you're out of the world of

00:24:47,390 --> 00:24:53,480
see and the cap theorem and then your

00:24:51,230 --> 00:24:55,430
problem now goes down goes down to

00:24:53,480 --> 00:24:57,980
conflict resolution of the split

00:24:55,430 --> 00:25:01,310
lineages and that usually comes down to

00:24:57,980 --> 00:25:03,250
being really complex and costly if you

00:25:01,310 --> 00:25:07,010
want to try to minimize loss or

00:25:03,250 --> 00:25:08,420
eradicate it if you're lucky or you

00:25:07,010 --> 00:25:09,980
choose something simpler and you're

00:25:08,420 --> 00:25:13,250
pretty much accepting that you're gonna

00:25:09,980 --> 00:25:16,570
lose some rights and these scenarios so

00:25:13,250 --> 00:25:21,260
that's just how it goes I

00:25:16,570 --> 00:25:25,850
you can choosing strong consistency what

00:25:21,260 --> 00:25:29,750
that generally means is that to do it to

00:25:25,850 --> 00:25:31,790
actually make the guarantee you have to

00:25:29,750 --> 00:25:34,100
disallow operations that would cause

00:25:31,790 --> 00:25:37,160
record version splits so like in this

00:25:34,100 --> 00:25:38,720
book bring scenario here I don't want to

00:25:37,160 --> 00:25:40,760
write to that guy out there

00:25:38,720 --> 00:25:43,460
on the right if that's all I can see

00:25:40,760 --> 00:25:48,320
because you know that's just begging for

00:25:43,460 --> 00:25:49,670
a lineage split so most systems will

00:25:48,320 --> 00:25:51,920
just say yeah you're not going to be

00:25:49,670 --> 00:25:53,720
able to write that and so the record

00:25:51,920 --> 00:25:57,280
becomes unavailable and that's your

00:25:53,720 --> 00:26:02,240
choice but that's what what you gotta do

00:25:57,280 --> 00:26:05,900
usually to to guarantee see the other

00:26:02,240 --> 00:26:08,330
part of it is that you need to disallow

00:26:05,900 --> 00:26:10,310
observation of records that do actually

00:26:08,330 --> 00:26:13,220
get written in these cases where they

00:26:10,310 --> 00:26:15,110
shouldn't and you might ask well why not

00:26:13,220 --> 00:26:19,070
just make it so that there never any

00:26:15,110 --> 00:26:21,830
dirty records I'd love to we tried but I

00:26:19,070 --> 00:26:23,780
kind of think now the that it's hard to

00:26:21,830 --> 00:26:25,460
see how to do SC without having to deal

00:26:23,780 --> 00:26:27,920
with dirty records because the bottom

00:26:25,460 --> 00:26:30,020
line is you can be in the middle of

00:26:27,920 --> 00:26:31,820
writing in a perfectly good cluster and

00:26:30,020 --> 00:26:32,690
it's just halfway through it made it to

00:26:31,820 --> 00:26:34,999
one node

00:26:32,690 --> 00:26:37,190
that's when the the cluster partition

00:26:34,999 --> 00:26:39,859
happens and the other ones just don't

00:26:37,190 --> 00:26:42,950
get done so you're sort of stuck with

00:26:39,859 --> 00:26:45,169
this thing and the job of strong

00:26:42,950 --> 00:26:47,779
consistency consistency then is still

00:26:45,169 --> 00:26:49,580
like make sure nobody sees that and an

00:26:47,779 --> 00:26:51,950
observed lineage from the outside and

00:26:49,580 --> 00:26:55,369
then get rid of it as fast as you can

00:26:51,950 --> 00:26:58,099
and that that might mean that you know

00:26:55,369 --> 00:27:00,019
the right lineage version when you do

00:26:58,099 --> 00:27:02,239
the merge back just pretty much wings

00:27:00,019 --> 00:27:03,859
over that and luckily you know you don't

00:27:02,239 --> 00:27:06,499
need history and all of that to that

00:27:03,859 --> 00:27:08,869
merge it's just one record straight up

00:27:06,499 --> 00:27:11,059
winning over the other or it could even

00:27:08,869 --> 00:27:13,369
mean that when the cluster mends you

00:27:11,059 --> 00:27:15,289
actually finish propagating that dirty

00:27:13,369 --> 00:27:17,269
record and then if it gets to enough

00:27:15,289 --> 00:27:21,320
places you define it as being clean and

00:27:17,269 --> 00:27:23,359
you can go that way too or both some

00:27:21,320 --> 00:27:25,070
systems maybe even do rollback if you

00:27:23,359 --> 00:27:28,549
know you know what the previous version

00:27:25,070 --> 00:27:30,799
is I don't know there are probably a lot

00:27:28,549 --> 00:27:32,539
of ways to do it but there probably I

00:27:30,799 --> 00:27:34,099
don't know of any way that I would be

00:27:32,539 --> 00:27:36,379
able to make a system like list of the

00:27:34,099 --> 00:27:38,929
voids the concept of the dirty record

00:27:36,379 --> 00:27:41,149
altogether but yeah generally what

00:27:38,929 --> 00:27:44,139
you're doing is disallowing stuff in a

00:27:41,149 --> 00:27:47,960
in a ap system you would be allowing and

00:27:44,139 --> 00:27:50,899
that means that by definition I'm not

00:27:47,960 --> 00:27:52,970
making maximum use of my availability

00:27:50,899 --> 00:27:55,190
and disallowing transactions and telling

00:27:52,970 --> 00:27:58,940
you that records or partitions are

00:27:55,190 --> 00:28:03,409
unavailable and that's the trade-off so

00:27:58,940 --> 00:28:05,330
you know different different things for

00:28:03,409 --> 00:28:08,570
different use cases some things just

00:28:05,330 --> 00:28:10,970
have to have strong consistency they

00:28:08,570 --> 00:28:13,009
just can't afford to see these weird

00:28:10,970 --> 00:28:15,739
into me intermediate records of missing

00:28:13,009 --> 00:28:17,299
writes and all that and other use cases

00:28:15,739 --> 00:28:19,460
they're they don't mind some of that

00:28:17,299 --> 00:28:21,499
they'd rather just you know keep ruling

00:28:19,460 --> 00:28:23,299
and if it means uh if it means some

00:28:21,499 --> 00:28:25,820
records end up being a little bit weird

00:28:23,299 --> 00:28:31,519
or you lose you lose some rights you can

00:28:25,820 --> 00:28:33,559
maybe you can tolerate that okay I said

00:28:31,519 --> 00:28:35,720
I'd come back and tell you about within

00:28:33,559 --> 00:28:38,130
strong consistency some choices of

00:28:35,720 --> 00:28:41,040
read-only behavior so there's our

00:28:38,130 --> 00:28:45,900
single lineage or single progression

00:28:41,040 --> 00:28:48,350
again that's strongly consistent but

00:28:45,900 --> 00:28:54,480
there are some nuances in read-only

00:28:48,350 --> 00:28:57,090
operations as to whether you can get

00:28:54,480 --> 00:29:01,620
away with some things so I'm gonna put

00:28:57,090 --> 00:29:04,370
down two different kinds of behavior

00:29:01,620 --> 00:29:08,760
that you can make your read-only

00:29:04,370 --> 00:29:10,890
operations follow wanna which I call

00:29:08,760 --> 00:29:12,750
session consistency I don't know what

00:29:10,890 --> 00:29:15,870
the other names for this are we'd watch

00:29:12,750 --> 00:29:17,970
ero so forth a hard time with with

00:29:15,870 --> 00:29:20,490
nomenclature and computer science

00:29:17,970 --> 00:29:23,040
sometimes seems like there is there

00:29:20,490 --> 00:29:25,380
isn't just one standard thing but anyway

00:29:23,040 --> 00:29:27,240
to me what that means is that a single

00:29:25,380 --> 00:29:32,010
client is never gonna see a stale

00:29:27,240 --> 00:29:34,440
version if you've seen v3 you're never

00:29:32,010 --> 00:29:36,750
gonna see v2 again you're only going

00:29:34,440 --> 00:29:39,510
forward from there

00:29:36,750 --> 00:29:42,510
the other option I listed here is

00:29:39,510 --> 00:29:44,700
linearized which means that even across

00:29:42,510 --> 00:29:47,340
different clients you'll never see a

00:29:44,700 --> 00:29:51,000
stale version meaning that client a can

00:29:47,340 --> 00:29:55,830
see if client a is seeing v3 then client

00:29:51,000 --> 00:29:57,750
B better not see v2 and just for the

00:29:55,830 --> 00:30:00,540
heck of it I'll throw up a third option

00:29:57,750 --> 00:30:02,310
you know they're relaxed there you have

00:30:00,540 --> 00:30:03,750
use cases where people don't want to

00:30:02,310 --> 00:30:06,240
lose the rights which is the core

00:30:03,750 --> 00:30:07,620
definition of strong consistency but

00:30:06,240 --> 00:30:10,290
they actually don't really care if they

00:30:07,620 --> 00:30:15,030
occasionally see a stale version as long

00:30:10,290 --> 00:30:19,140
as it's not a dirty version but usually

00:30:15,030 --> 00:30:21,810
the big question is do I need my leaves

00:30:19,140 --> 00:30:24,600
linearized or a session okay that's the

00:30:21,810 --> 00:30:27,390
question I mostly get asked about repos

00:30:24,600 --> 00:30:31,050
and that the reason people are asking is

00:30:27,390 --> 00:30:35,280
typically linearizes more costly back

00:30:31,050 --> 00:30:39,230
usually significantly more costly to to

00:30:35,280 --> 00:30:44,340
deliver for a read meaning ending

00:30:39,230 --> 00:30:46,890
transaction latency so though my usual

00:30:44,340 --> 00:30:49,250
answer is to tell if you need linearized

00:30:46,890 --> 00:30:50,990
or not ask yourself whether

00:30:49,250 --> 00:30:53,320
is there any way that you could verify

00:30:50,990 --> 00:30:56,060
that your system would know if

00:30:53,320 --> 00:30:58,880
linearization was violated in other

00:30:56,060 --> 00:31:02,120
words is there some external source of

00:30:58,880 --> 00:31:05,210
truth outside the database where if

00:31:02,120 --> 00:31:08,960
client a had seen v3 that you could tell

00:31:05,210 --> 00:31:12,200
that client B sees v2 after client a

00:31:08,960 --> 00:31:15,530
sees v3 and that could be two people

00:31:12,200 --> 00:31:18,170
sitting you know on their phone at the

00:31:15,530 --> 00:31:20,510
opposite sides of the city asking them

00:31:18,170 --> 00:31:23,510
did you see v3 did that counts if that's

00:31:20,510 --> 00:31:26,990
your external your external way of

00:31:23,510 --> 00:31:29,870
verification but really more often than

00:31:26,990 --> 00:31:32,600
not it turns out that no there isn't and

00:31:29,870 --> 00:31:34,130
so if there isn't a way that the

00:31:32,600 --> 00:31:36,050
different clients are gonna be able to

00:31:34,130 --> 00:31:38,750
check whether they went backwards on

00:31:36,050 --> 00:31:40,310
what the other ones saw then then you

00:31:38,750 --> 00:31:43,010
don't really need it you know if all the

00:31:40,310 --> 00:31:44,690
client sees is all it sees and it

00:31:43,010 --> 00:31:47,300
doesn't know what they know or care what

00:31:44,690 --> 00:31:48,980
the other clients are seeing then you

00:31:47,300 --> 00:31:51,320
know so it's a little behind maybe the

00:31:48,980 --> 00:31:53,300
other ones so V three of them I just

00:31:51,320 --> 00:31:55,460
picked up v2 but I'll eventually get

00:31:53,300 --> 00:31:59,270
there and usually that that's what

00:31:55,460 --> 00:32:01,370
people need anyway so these don't get

00:31:59,270 --> 00:32:03,050
these confused of the actual definition

00:32:01,370 --> 00:32:05,810
of strong consistency they're kind of

00:32:03,050 --> 00:32:07,850
they're just I mean they're their own

00:32:05,810 --> 00:32:10,370
thing they may be important you really

00:32:07,850 --> 00:32:12,770
may need linearized reads but these are

00:32:10,370 --> 00:32:15,530
read modes or read-only modes or choices

00:32:12,770 --> 00:32:20,920
within strong consistency you are in the

00:32:15,530 --> 00:32:25,120
world of strong consistency here okay

00:32:20,920 --> 00:32:28,460
just quickly I'm going to describe a

00:32:25,120 --> 00:32:30,140
traditional consensus system to the

00:32:28,460 --> 00:32:33,890
delivers that guarantees strong

00:32:30,140 --> 00:32:36,350
consistency usually the way those work

00:32:33,890 --> 00:32:38,960
is that the replicas in the cluster are

00:32:36,350 --> 00:32:42,050
kind of in fixed places they don't

00:32:38,960 --> 00:32:44,810
really move around you do an operation

00:32:42,050 --> 00:32:46,490
that writes to all of them and a

00:32:44,810 --> 00:32:48,350
successful operation is gonna be defined

00:32:46,490 --> 00:32:51,980
as something that got written to a

00:32:48,350 --> 00:32:54,520
majority of them so corollary of that is

00:32:51,980 --> 00:32:58,580
that you can get your hundred-percent

00:32:54,520 --> 00:32:59,870
availability with n nodes missing I as

00:32:58,580 --> 00:33:02,840
long as you have to end

00:32:59,870 --> 00:33:05,680
long replicas because you know you need

00:33:02,840 --> 00:33:08,840
a majority to have a successful right

00:33:05,680 --> 00:33:10,730
which then therefore means that just to

00:33:08,840 --> 00:33:13,100
do a rolling upgrade in this sort of

00:33:10,730 --> 00:33:15,710
system you need at least three replicas

00:33:13,100 --> 00:33:21,290
you need replication factor three to do

00:33:15,710 --> 00:33:23,000
this without losing any availability one

00:33:21,290 --> 00:33:25,340
thing about these systems they typically

00:33:23,000 --> 00:33:27,650
do preserve partial availability well by

00:33:25,340 --> 00:33:30,110
making use of all all the connectivity

00:33:27,650 --> 00:33:32,210
you know any path you can take to to get

00:33:30,110 --> 00:33:34,520
to right to the place you intend to

00:33:32,210 --> 00:33:38,170
right is taken them they're actually

00:33:34,520 --> 00:33:41,480
pretty resilient to some pretty heavy P

00:33:38,170 --> 00:33:43,100
but there are alternatives and I said I

00:33:41,480 --> 00:33:45,860
wasn't going to talk about aerospike

00:33:43,100 --> 00:33:49,000
strong consistency so for the next slide

00:33:45,860 --> 00:33:53,750
or two it's will call it Kevin system

00:33:49,000 --> 00:33:55,970
alright so in Kevin system I've drawn

00:33:53,750 --> 00:33:56,300
two replicas here you'll see why in a

00:33:55,970 --> 00:33:58,429
minute

00:33:56,300 --> 00:34:03,280
it's different to the traditional

00:33:58,429 --> 00:34:06,050
consensus system your operations are

00:34:03,280 --> 00:34:08,120
master centric they go through a master

00:34:06,050 --> 00:34:10,190
and the master will replicate to to the

00:34:08,120 --> 00:34:15,919
replicas so it looks kind of like what

00:34:10,190 --> 00:34:18,230
just happened there in that graphic I in

00:34:15,919 --> 00:34:21,139
this world successful operations are

00:34:18,230 --> 00:34:23,149
defined not as having written to a

00:34:21,139 --> 00:34:25,310
majority but having written to your

00:34:23,149 --> 00:34:29,620
replication factor number of replicas so

00:34:25,310 --> 00:34:32,750
in this case here also two replicas but

00:34:29,620 --> 00:34:35,690
interestingly I you can get 100%

00:34:32,750 --> 00:34:38,300
availability with n nodes missing with

00:34:35,690 --> 00:34:41,330
just n plus long replicas which is a

00:34:38,300 --> 00:34:43,940
pretty neat trick and that means that

00:34:41,330 --> 00:34:45,919
you just need two or more replicas to do

00:34:43,940 --> 00:34:50,110
a rolling upgrade with a hundred percent

00:34:45,919 --> 00:34:54,440
of the ability so this is a difference I

00:34:50,110 --> 00:34:56,990
mean it we view it as a pro Kevin and I

00:34:54,440 --> 00:34:59,150
we we think that's a good thing because

00:34:56,990 --> 00:35:02,120
if you can run with with two replicas

00:34:59,150 --> 00:35:05,090
instead of three that's you know with

00:35:02,120 --> 00:35:07,910
three is 50% more storage costs and the

00:35:05,090 --> 00:35:10,990
transactions it's 50% more network stuff

00:35:07,910 --> 00:35:13,660
just to write just to write your records

00:35:10,990 --> 00:35:16,869
so this is kind of cute it helps costs

00:35:13,660 --> 00:35:18,910
and performance on the other hand our

00:35:16,869 --> 00:35:22,270
system is not as good as a traditional

00:35:18,910 --> 00:35:25,480
consensus system it's is pretty good in

00:35:22,270 --> 00:35:27,849
very simple peace scenarios but once the

00:35:25,480 --> 00:35:32,020
connections break start to get really

00:35:27,849 --> 00:35:34,480
prevalent then we degenerate our partial

00:35:32,020 --> 00:35:36,880
availability pretty quickly and you can

00:35:34,480 --> 00:35:39,609
concoct some some schemes where

00:35:36,880 --> 00:35:42,460
consensus system retains quite a lot and

00:35:39,609 --> 00:35:44,890
we go all the way to zero until the

00:35:42,460 --> 00:35:50,650
cluster gets amended but you know

00:35:44,890 --> 00:35:52,690
different things so again the pros for

00:35:50,650 --> 00:35:55,029
us are we just need fewer replicas to

00:35:52,690 --> 00:35:57,099
tolerate giving number of nodes down or

00:35:55,029 --> 00:35:59,109
we can tolerate more nodes down for a

00:35:57,099 --> 00:36:01,089
given replication factor and here you

00:35:59,109 --> 00:36:03,069
can also think the racks instead of

00:36:01,089 --> 00:36:07,569
nodes if you have rack aware all these

00:36:03,069 --> 00:36:09,760
systems usually do so it can mean lower

00:36:07,569 --> 00:36:11,740
costs and higher performance and the

00:36:09,760 --> 00:36:14,650
traditional systems generally are much

00:36:11,740 --> 00:36:17,410
better at preserving higher partial

00:36:14,650 --> 00:36:19,660
availability of the severe P P scenarios

00:36:17,410 --> 00:36:21,069
so for example if your cluster with a

00:36:19,660 --> 00:36:23,520
bunch all the nodes were a bunch of

00:36:21,069 --> 00:36:25,779
planes flying around and you expect the

00:36:23,520 --> 00:36:27,819
connectivity to just be all over the map

00:36:25,779 --> 00:36:30,880
then maybe you don't want to use Kevin

00:36:27,819 --> 00:36:34,450
system but maybe if it's a rack and a

00:36:30,880 --> 00:36:36,700
rule that you know 99.99% of the time

00:36:34,450 --> 00:36:39,130
the connections are pretty good then

00:36:36,700 --> 00:36:43,299
maybe the pros of Kevin system start to

00:36:39,130 --> 00:36:47,049
look pretty appealing okay so again

00:36:43,299 --> 00:36:49,569
finally this choice of C versus a is

00:36:47,049 --> 00:36:53,760
really all about which do you prefer on

00:36:49,569 --> 00:36:57,250
a very rainy day again mostly like rain

00:36:53,760 --> 00:36:59,109
like upgrades it's not really that's not

00:36:57,250 --> 00:37:03,460
driving your choice you get both for

00:36:59,109 --> 00:37:07,089
free and most system C sacrifices a on

00:37:03,460 --> 00:37:11,829
very rainy days other way around for a

00:37:07,089 --> 00:37:14,319
if you choose a C can sometimes be more

00:37:11,829 --> 00:37:18,520
involved to deploy it certainly is for

00:37:14,319 --> 00:37:20,200
Kevin system because the the ASIS the AP

00:37:18,520 --> 00:37:22,050
system is really nice and that you know

00:37:20,200 --> 00:37:24,000
you have to tell the nodes in the class

00:37:22,050 --> 00:37:25,770
the you-know-what the cluster is

00:37:24,000 --> 00:37:29,520
supposed to be but we actually have to

00:37:25,770 --> 00:37:30,720
do that for the for the CP system so it

00:37:29,520 --> 00:37:36,030
can be a little more involved

00:37:30,720 --> 00:37:37,770
operationally sometimes strong

00:37:36,030 --> 00:37:40,290
consistency means that it's less

00:37:37,770 --> 00:37:42,480
performance and high availability in our

00:37:40,290 --> 00:37:44,460
case that's not really true

00:37:42,480 --> 00:37:46,590
we then that was really the original

00:37:44,460 --> 00:37:48,210
motivation for trying this new way of

00:37:46,590 --> 00:37:52,560
doing it that was our goal and we

00:37:48,210 --> 00:37:56,610
succeeded but but yeah in general this

00:37:52,560 --> 00:37:59,550
is your trade-off do I am I done or I'm

00:37:56,610 --> 00:38:02,160
done okay so my good I don't have to

00:37:59,550 --> 00:38:05,280
talk about my optional slide so thank

00:38:02,160 --> 00:38:07,640
you very much so they're gonna use the

00:38:05,280 --> 00:38:10,410
question session for the last slide a

00:38:07,640 --> 00:38:13,790
lot of people have systems that they

00:38:10,410 --> 00:38:16,230
claim delivers strong consistency and

00:38:13,790 --> 00:38:18,720
often they just don't

00:38:16,230 --> 00:38:21,200
maybe they they don't know what it is or

00:38:18,720 --> 00:38:23,250
maybe they just are disingenuous but

00:38:21,200 --> 00:38:25,950
even if we're telling you that we

00:38:23,250 --> 00:38:28,220
deliver strong consistency you shouldn't

00:38:25,950 --> 00:38:32,690
necessarily take our word for it

00:38:28,220 --> 00:38:36,270
the Jetson tests are run by this guy

00:38:32,690 --> 00:38:37,980
Kyle Kingsbury who has sort of made a

00:38:36,270 --> 00:38:40,730
career out of this of going out going

00:38:37,980 --> 00:38:45,890
around and being a third-party

00:38:40,730 --> 00:38:50,430
one-man-band verification method for

00:38:45,890 --> 00:38:52,440
strongly consistent systems so he he

00:38:50,430 --> 00:38:53,880
tests a lot of things like here I just

00:38:52,440 --> 00:38:56,880
talked about the system with single

00:38:53,880 --> 00:38:58,680
record transactions he does all sorts of

00:38:56,880 --> 00:39:02,790
other stuff he leave the multi record

00:38:58,680 --> 00:39:08,880
transactions stuff things like that but

00:39:02,790 --> 00:39:10,980
we had him come to test our system these

00:39:08,880 --> 00:39:13,260
days you you pay him to come test your

00:39:10,980 --> 00:39:15,240
system but he does not like wash the

00:39:13,260 --> 00:39:18,030
results not like you're paying him to do

00:39:15,240 --> 00:39:20,100
your PR he will happily report any

00:39:18,030 --> 00:39:25,140
trouble that he finds of any stage of

00:39:20,100 --> 00:39:27,540
his investigation so for us he verified

00:39:25,140 --> 00:39:30,890
the strong consistency definition he

00:39:27,540 --> 00:39:30,890
verified that we do in need

00:39:31,279 --> 00:39:35,279
guarantee it are singled in your

00:39:33,509 --> 00:39:38,160
progression of record version we do

00:39:35,279 --> 00:39:41,369
indeed never lose rights he did measure

00:39:38,160 --> 00:39:46,559
our availability degradation or you know

00:39:41,369 --> 00:39:50,250
in extreme partition scenes and he did

00:39:46,559 --> 00:39:52,740
verify our linearized reap mode which

00:39:50,250 --> 00:39:56,569
you know is the hardest one to deliver

00:39:52,740 --> 00:39:59,160
so he put the system through the ringer

00:39:56,569 --> 00:40:01,470
he was there for a couple of months and

00:39:59,160 --> 00:40:04,140
he really digs in and tries to

00:40:01,470 --> 00:40:07,289
understand how it works so that he can

00:40:04,140 --> 00:40:09,569
try and break it I mean that it's not

00:40:07,289 --> 00:40:11,339
just that he's interested in it but the

00:40:09,569 --> 00:40:13,470
better he understands that the the

00:40:11,339 --> 00:40:16,920
better chance he has of setting up his

00:40:13,470 --> 00:40:19,259
tests on customizing it to expose a flaw

00:40:16,920 --> 00:40:21,150
in your system so he tried very very

00:40:19,259 --> 00:40:24,839
hard for us for a couple of months and

00:40:21,150 --> 00:40:27,380
then eventually resigned conceded that

00:40:24,839 --> 00:40:29,670
we couldn't break strong consistency

00:40:27,380 --> 00:40:31,549
although it was let me tell you

00:40:29,670 --> 00:40:35,970
interesting couple of months anyway

00:40:31,549 --> 00:40:38,250
right so yeah if you I mean if you're

00:40:35,970 --> 00:40:39,900
considering a system that claims to

00:40:38,250 --> 00:40:42,480
guarantee strong consistency and you

00:40:39,900 --> 00:40:47,190
think that's the thing that you need or

00:40:42,480 --> 00:40:50,430
whatever it's whatever the system claims

00:40:47,190 --> 00:40:52,410
it's guaranteeing you should go look at

00:40:50,430 --> 00:40:54,359
and see if he's tested this system and

00:40:52,410 --> 00:40:57,839
see what he has to say about it because

00:40:54,359 --> 00:40:58,980
it's a pretty good outside look at you

00:40:57,839 --> 00:41:01,680
know so you don't have to take the

00:40:58,980 --> 00:41:03,809
vendors word for it you know obviously

00:41:01,680 --> 00:41:06,089
I'm telling the truth right you know

00:41:03,809 --> 00:41:08,490
when I say we didn't deliver strong

00:41:06,089 --> 00:41:11,430
consistency there's no question that's

00:41:08,490 --> 00:41:13,710
what's happening but actually it was

00:41:11,430 --> 00:41:16,049
nice too because we tested the heck out

00:41:13,710 --> 00:41:18,000
of our stuff but you know those are our

00:41:16,049 --> 00:41:20,460
tests I was actually pretty interested

00:41:18,000 --> 00:41:22,890
to see actually kind of scared you know

00:41:20,460 --> 00:41:24,690
the two months I felt like I was you

00:41:22,890 --> 00:41:26,730
know it's a sword of Damocles above my

00:41:24,690 --> 00:41:28,200
head like every morning I wake up oh no

00:41:26,730 --> 00:41:31,250
we're gonna go and he's gonna show that

00:41:28,200 --> 00:41:33,930
something's wrong it's broken and

00:41:31,250 --> 00:41:34,670
they're actually a couple false alarms

00:41:33,930 --> 00:41:36,710
in there

00:41:34,670 --> 00:41:38,570
that just you know I nearly had a heart

00:41:36,710 --> 00:41:42,290
attack until we discovered they were

00:41:38,570 --> 00:41:48,020
false alarms but but yeah he tried

00:41:42,290 --> 00:41:50,690
really hard and so it you can if he's if

00:41:48,020 --> 00:41:52,280
he's tested a system that that you're

00:41:50,690 --> 00:41:54,230
interested in you should definitely go

00:41:52,280 --> 00:41:57,050
read read what he has to say he's almost

00:41:54,230 --> 00:42:00,500
sensational in his reports I mean we

00:41:57,050 --> 00:42:05,090
passed but it's a yeah it's still kind

00:42:00,500 --> 00:42:06,950
of you have to dig in there to see that

00:42:05,090 --> 00:42:07,670
okay thanks

00:42:06,950 --> 00:42:12,740
that was it

00:42:07,670 --> 00:42:17,880
[Applause]

00:42:12,740 --> 00:42:17,880

YouTube URL: https://www.youtube.com/watch?v=QpmhyK6rJ8o


