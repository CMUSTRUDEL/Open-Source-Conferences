Title: Cloud Native & OSS Keynote: The World Has Changed   Have Our Designs? Avishai Ish Shalom, Scylla | C
Publication date: 2020-12-26
Playlist: Community Summit TLV 2020
Description: 
	When we build systems our design and tradeoffs reflect the different scales of the system: the speed of disks, latency of network; They reflect the constraints and abilities of the underlying technologies. But as technology advances some of these assumptions have become invalid. We are no longer running on physical machines for which RDBMS systems were designed; SSD changed pretty much everything in the storage world, but our software was designed for magnetic disks; NVRAM? O/S design is way off. This talk will show how changes in hardware technologies impact design rational of various systems, highlighting the importance of understanding and rethinking the design rational and explore new designs that arise from the new rational.
Captions: 
	00:00:02,880 --> 00:00:05,940
[Music]

00:00:13,840 --> 00:00:17,920
and uh

00:00:14,719 --> 00:00:20,880
going on to uh our

00:00:17,920 --> 00:00:20,880
keynote speaker

00:00:22,080 --> 00:00:25,439
in just a second our keynote speaker

00:00:24,800 --> 00:00:28,720
today

00:00:25,439 --> 00:00:30,720
is uh mr avishai ichalon

00:00:28,720 --> 00:00:32,160
you may probably know avishai from the

00:00:30,720 --> 00:00:35,360
community he's been uh

00:00:32,160 --> 00:00:39,440
quite of a veteran here in the community

00:00:35,360 --> 00:00:42,239
avisha is um i've known avicii for over

00:00:39,440 --> 00:00:43,040
10 years when he founded his consultancy

00:00:42,239 --> 00:00:45,440
firm

00:00:43,040 --> 00:00:46,640
back in a few bites and since then he's

00:00:45,440 --> 00:00:49,760
done

00:00:46,640 --> 00:00:49,760
so much around

00:00:49,920 --> 00:00:54,879
as engineering in residence in vc and

00:00:52,960 --> 00:00:56,559
the engineering manager at wix and so

00:00:54,879 --> 00:00:59,920
much more so uh

00:00:56,559 --> 00:01:02,480
lots of adventures uh lots of adventures

00:00:59,920 --> 00:01:03,039
uh and now he's converted to the dark

00:01:02,480 --> 00:01:06,240
side

00:01:03,039 --> 00:01:08,960
uh being a developer advocate at

00:01:06,240 --> 00:01:09,840
uh scilab uh if you know the sila db

00:01:08,960 --> 00:01:12,720
open source

00:01:09,840 --> 00:01:15,200
uh let me uh add uh avishai to the

00:01:12,720 --> 00:01:15,200
stream

00:01:15,920 --> 00:01:20,560
good morning good morning how are you

00:01:18,640 --> 00:01:23,600
great great how are you doing

00:01:20,560 --> 00:01:25,680
great it's been a while

00:01:23,600 --> 00:01:27,200
yeah yeah since the last time you on a

00:01:25,680 --> 00:01:30,560
podcast

00:01:27,200 --> 00:01:32,640
so um i wish i um you know we've been

00:01:30,560 --> 00:01:36,079
around for a while now and uh

00:01:32,640 --> 00:01:39,439
without saying our agents and uh

00:01:36,079 --> 00:01:42,079
so so many transformations in the uh

00:01:39,439 --> 00:01:42,640
you know from from on-prem all the way

00:01:42,079 --> 00:01:46,479
to uh

00:01:42,640 --> 00:01:47,040
cloud and serverless from uh pets to uh

00:01:46,479 --> 00:01:49,520
cattle

00:01:47,040 --> 00:01:50,720
from uh i don't know three-tier apps to

00:01:49,520 --> 00:01:54,479
uh to uh

00:01:50,720 --> 00:01:58,159
microservices the death star so um

00:01:54,479 --> 00:02:00,000
um how would you say this impacts our

00:01:58,159 --> 00:02:01,280
choices or assumptions what you're

00:02:00,000 --> 00:02:02,960
taking that

00:02:01,280 --> 00:02:05,360
um so the problem is that technology

00:02:02,960 --> 00:02:07,600
moves really really fast but

00:02:05,360 --> 00:02:08,399
our brains don't move as fast there's a

00:02:07,600 --> 00:02:10,959
lot of

00:02:08,399 --> 00:02:12,879
stuff that we're conditioned for and you

00:02:10,959 --> 00:02:14,879
know patterns in which we think and

00:02:12,879 --> 00:02:16,640
we tend to take them away and kind of

00:02:14,879 --> 00:02:19,200
pattern match even on things that

00:02:16,640 --> 00:02:20,879
are not exactly the same and the other

00:02:19,200 --> 00:02:24,400
problem is that uh because

00:02:20,879 --> 00:02:26,879
of the organizational um structure of

00:02:24,400 --> 00:02:28,640
the technology community uh with

00:02:26,879 --> 00:02:31,440
protocols or you know

00:02:28,640 --> 00:02:33,519
projects or whatever um actually getting

00:02:31,440 --> 00:02:35,120
people to agree on how to use stuff is

00:02:33,519 --> 00:02:36,480
very very hard and takes a lot of time

00:02:35,120 --> 00:02:38,480
so a protocol

00:02:36,480 --> 00:02:39,599
to make it ubiquitous takes about 30

00:02:38,480 --> 00:02:41,200
years which is

00:02:39,599 --> 00:02:43,360
you know if you if you think about it in

00:02:41,200 --> 00:02:45,760
terms of hardware it's eternity

00:02:43,360 --> 00:02:46,879
so we have a lot of protocols which are

00:02:45,760 --> 00:02:48,720
not uh

00:02:46,879 --> 00:02:50,720
not suitable for the way we use them

00:02:48,720 --> 00:02:52,160
today so like a very good example would

00:02:50,720 --> 00:02:53,840
be telephone lines

00:02:52,160 --> 00:02:55,840
you know a lot of us here in israel use

00:02:53,840 --> 00:02:57,360
ads lines and then

00:02:55,840 --> 00:02:59,840
if you sell the phone at home you're

00:02:57,360 --> 00:03:01,599
basically using a phone emulation

00:02:59,840 --> 00:03:03,440
on top of you know some kind of a

00:03:01,599 --> 00:03:06,159
compatibility layer on top of

00:03:03,440 --> 00:03:07,840
actual phone lines you know and and the

00:03:06,159 --> 00:03:09,519
entire world is like this it's not only

00:03:07,840 --> 00:03:11,280
uh phones that's um

00:03:09,519 --> 00:03:13,440
yeah let's do something for the for the

00:03:11,280 --> 00:03:16,560
talk itself because i think yeah

00:03:13,440 --> 00:03:18,879
some of these so uh i'll just uh

00:03:16,560 --> 00:03:20,640
roll it over and for the uh for our

00:03:18,879 --> 00:03:23,120
viewers participants do

00:03:20,640 --> 00:03:24,159
ask away questions uh for a wish i will

00:03:23,120 --> 00:03:26,319
answer q a

00:03:24,159 --> 00:03:27,360
after the talk and also come back to us

00:03:26,319 --> 00:03:29,280
after the talk itself

00:03:27,360 --> 00:03:31,680
and say to us to answer some of the

00:03:29,280 --> 00:03:32,720
questions so do ask away on the discord

00:03:31,680 --> 00:03:34,080
and we'll uh

00:03:32,720 --> 00:03:36,159
try and answer at least some of these

00:03:34,080 --> 00:03:38,560
questions after the uh talk

00:03:36,159 --> 00:03:47,840
so see you again avishai after the talk

00:03:38,560 --> 00:03:47,840
good luck

00:03:51,040 --> 00:03:57,460
[Music]

00:04:03,840 --> 00:04:08,640
first award from our sponsors are you

00:04:06,560 --> 00:04:11,599
using quality

00:04:08,640 --> 00:04:13,439
having trouble reading that email a4

00:04:11,599 --> 00:04:14,560
size documents aren't readable on your

00:04:13,439 --> 00:04:16,079
phone

00:04:14,560 --> 00:04:18,000
if you're suffering from any of these

00:04:16,079 --> 00:04:22,240
symptoms you might be experiencing

00:04:18,000 --> 00:04:24,000
obsolete design consult your doctor now

00:04:22,240 --> 00:04:25,919
welcome to the world of change heaver

00:04:24,000 --> 00:04:27,600
designs my name is avishai shalom i'm

00:04:25,919 --> 00:04:28,240
knuckleberg on twitter you can find me

00:04:27,600 --> 00:04:30,000
there

00:04:28,240 --> 00:04:32,160
follow me if you like i work for a

00:04:30,000 --> 00:04:34,400
company called sita we make a database a

00:04:32,160 --> 00:04:36,400
distributed database high performance

00:04:34,400 --> 00:04:38,240
that's compatible with dynamodb and

00:04:36,400 --> 00:04:39,520
cassandra look it up it's very

00:04:38,240 --> 00:04:42,720
interesting it's open source

00:04:39,520 --> 00:04:44,240
you might like it so why are we having

00:04:42,720 --> 00:04:45,680
this conversation

00:04:44,240 --> 00:04:47,520
the problem is that our brains are

00:04:45,680 --> 00:04:49,199
programmed for performing patterns

00:04:47,520 --> 00:04:51,360
and when we look at the world we see

00:04:49,199 --> 00:04:52,400
those familiar patterns even when those

00:04:51,360 --> 00:04:54,320
patterns are no longer

00:04:52,400 --> 00:04:56,160
relevant because the world has changed

00:04:54,320 --> 00:04:57,280
around us hardware has changed

00:04:56,160 --> 00:04:59,680
dramatically in the last

00:04:57,280 --> 00:05:00,560
30 years use cases have changed

00:04:59,680 --> 00:05:03,199
dramatically

00:05:00,560 --> 00:05:04,800
you know over the last 30 years but

00:05:03,199 --> 00:05:06,800
sometimes our treatment systems

00:05:04,800 --> 00:05:08,080
have not followed suit and have not

00:05:06,800 --> 00:05:09,680
changed accordingly

00:05:08,080 --> 00:05:12,479
so i'm going to give a few examples of

00:05:09,680 --> 00:05:13,520
this but before we get we dive into

00:05:12,479 --> 00:05:14,960
those examples

00:05:13,520 --> 00:05:17,280
we should probably take a look at this

00:05:14,960 --> 00:05:18,720
table of latency numbers that every

00:05:17,280 --> 00:05:21,280
developer should know

00:05:18,720 --> 00:05:21,840
those a very interesting and famous

00:05:21,280 --> 00:05:24,400
table

00:05:21,840 --> 00:05:25,680
out on the internet look it up you can

00:05:24,400 --> 00:05:26,880
find it on github

00:05:25,680 --> 00:05:29,680
but i'm going to run through it very

00:05:26,880 --> 00:05:30,320
very fast so magnetic disk random stick

00:05:29,680 --> 00:05:33,120
takes about

00:05:30,320 --> 00:05:34,240
10 milliseconds ssd is about 550

00:05:33,120 --> 00:05:37,120
microseconds

00:05:34,240 --> 00:05:39,360
a round trip in a local area network in

00:05:37,120 --> 00:05:41,039
data center is less than

00:05:39,360 --> 00:05:42,880
half a millisecond sometimes about

00:05:41,039 --> 00:05:45,360
around a quarter of a millisecond

00:05:42,880 --> 00:05:46,240
to read from ssd one megabytes about one

00:05:45,360 --> 00:05:48,960
millisecond

00:05:46,240 --> 00:05:49,600
and to send one megabyte over a network

00:05:48,960 --> 00:05:52,720
is about

00:05:49,600 --> 00:05:53,520
10 milliseconds now let's dive into

00:05:52,720 --> 00:05:56,160
those examples

00:05:53,520 --> 00:05:57,600
let's talk about hadoop hadoop is an

00:05:56,160 --> 00:06:01,600
open source project

00:05:57,600 --> 00:06:05,120
that's basically a framework

00:06:01,600 --> 00:06:07,120
for processing big data it

00:06:05,120 --> 00:06:08,560
was originally open sourced by yahoo in

00:06:07,120 --> 00:06:11,520
00:06:08,560 --> 00:06:11,919
but it's based on a design from google

00:06:11,520 --> 00:06:14,720
from

00:06:11,919 --> 00:06:16,720
2003 2004 the map produced and jks

00:06:14,720 --> 00:06:19,280
papers very interesting read

00:06:16,720 --> 00:06:21,039
um it was later picked up by claudio and

00:06:19,280 --> 00:06:24,080
later hortonworks

00:06:21,039 --> 00:06:25,039
for further design and to popularize it

00:06:24,080 --> 00:06:27,280
in

00:06:25,039 --> 00:06:29,600
organizations around the world amazon

00:06:27,280 --> 00:06:31,520
later in 2009

00:06:29,600 --> 00:06:32,960
provided the service deep as a service

00:06:31,520 --> 00:06:35,919
emr

00:06:32,960 --> 00:06:37,120
which was basically on running hadoop on

00:06:35,919 --> 00:06:40,400
ec2

00:06:37,120 --> 00:06:41,680
and around 2013 this was where hadoop

00:06:40,400 --> 00:06:43,600
started being

00:06:41,680 --> 00:06:45,600
widely adopted in enterprises and

00:06:43,600 --> 00:06:49,280
corporations

00:06:45,600 --> 00:06:51,840
so about 10 years that that took from

00:06:49,280 --> 00:06:53,120
when hadoop was written design until it

00:06:51,840 --> 00:06:56,319
was

00:06:53,120 --> 00:06:59,520
adopted in many companies

00:06:56,319 --> 00:07:01,199
so what was the design of hadoop what

00:06:59,520 --> 00:07:03,039
was it based on

00:07:01,199 --> 00:07:05,120
so basically we're talking about big

00:07:03,039 --> 00:07:07,120
data so a lot of data

00:07:05,120 --> 00:07:09,199
much more data than you could store in a

00:07:07,120 --> 00:07:11,599
single machine

00:07:09,199 --> 00:07:14,000
so we needed a lot of machines this was

00:07:11,599 --> 00:07:17,199
why tools distributed and those machines

00:07:14,000 --> 00:07:19,599
used commodity disks magnetic disks

00:07:17,199 --> 00:07:21,440
and because ram was expensive we

00:07:19,599 --> 00:07:21,840
actually had much more data than we had

00:07:21,440 --> 00:07:24,160
ram

00:07:21,840 --> 00:07:26,000
so basically hadoop was a framework that

00:07:24,160 --> 00:07:27,759
needed to work off the disk

00:07:26,000 --> 00:07:29,520
network bandwidth was also fairly

00:07:27,759 --> 00:07:31,599
limited so we couldn't really move data

00:07:29,520 --> 00:07:33,520
between machines very easily

00:07:31,599 --> 00:07:35,360
also this was designed for physical

00:07:33,520 --> 00:07:36,720
networks so we actually cared about the

00:07:35,360 --> 00:07:39,039
topology of the network for

00:07:36,720 --> 00:07:40,720
locality and we're talking about very

00:07:39,039 --> 00:07:43,599
large files and data sets because this

00:07:40,720 --> 00:07:45,680
is basically what big data is

00:07:43,599 --> 00:07:46,800
all of those conditions brought forth a

00:07:45,680 --> 00:07:48,639
design rationale

00:07:46,800 --> 00:07:51,919
that was based around data locality

00:07:48,639 --> 00:07:53,840
which means we want to move data as

00:07:51,919 --> 00:07:55,280
only when we really really need to we

00:07:53,840 --> 00:07:55,599
don't want to move data if we don't have

00:07:55,280 --> 00:07:57,039
to

00:07:55,599 --> 00:08:00,240
how do we do this we move the

00:07:57,039 --> 00:08:02,400
computation to the data

00:08:00,240 --> 00:08:03,440
but if we look at the differences that

00:08:02,400 --> 00:08:06,560
happen between

00:08:03,440 --> 00:08:07,759
2003 and 10 years later a lot of things

00:08:06,560 --> 00:08:09,280
change when i'm talking about

00:08:07,759 --> 00:08:12,800
hardware for example the network

00:08:09,280 --> 00:08:16,400
bandwidth was almost 10 times as

00:08:12,800 --> 00:08:19,280
big discs although they didn't become

00:08:16,400 --> 00:08:20,000
much faster they have become much much

00:08:19,280 --> 00:08:22,720
larger

00:08:20,000 --> 00:08:24,479
and similarly ram has become much bigger

00:08:22,720 --> 00:08:27,680
as well

00:08:24,479 --> 00:08:30,000
also we now had ssd new

00:08:27,680 --> 00:08:30,800
storage technologies ssd became

00:08:30,000 --> 00:08:32,800
commonplace

00:08:30,800 --> 00:08:34,320
and also virtualization where now we

00:08:32,800 --> 00:08:35,120
were no longer talking about physical

00:08:34,320 --> 00:08:37,680
networks

00:08:35,120 --> 00:08:38,320
and physical machines for example emr

00:08:37,680 --> 00:08:40,159
was

00:08:38,320 --> 00:08:43,440
natively based on the cloud so

00:08:40,159 --> 00:08:45,120
everything there was virtual

00:08:43,440 --> 00:08:46,640
if we're talking about ramp prices it's

00:08:45,120 --> 00:08:48,399
worth taking a look at this

00:08:46,640 --> 00:08:51,519
very interesting graph this is a graph

00:08:48,399 --> 00:08:54,160
of ram prices from the early 2000s still

00:08:51,519 --> 00:08:55,279
more or less today and i actually have

00:08:54,160 --> 00:08:58,640
data all the way from

00:08:55,279 --> 00:08:59,760
the 50s but because the ram prices drop

00:08:58,640 --> 00:09:02,000
exponentially

00:08:59,760 --> 00:09:03,839
um if i actually put the graph that then

00:09:02,000 --> 00:09:06,000
dates back all the way to the 60s or

00:09:03,839 --> 00:09:07,440
50s you wouldn't even see this this part

00:09:06,000 --> 00:09:08,959
of the graph because it would look like

00:09:07,440 --> 00:09:11,120
a flat line

00:09:08,959 --> 00:09:13,040
so grant prices drop exponentially the

00:09:11,120 --> 00:09:16,000
size increases exponentially

00:09:13,040 --> 00:09:16,240
and this is expected to continue in 2013

00:09:16,000 --> 00:09:18,320
it

00:09:16,240 --> 00:09:19,440
actually became very very obvious that

00:09:18,320 --> 00:09:22,640
this is going to be

00:09:19,440 --> 00:09:24,320
a trend that's going to continue so

00:09:22,640 --> 00:09:25,920
let's revisit the design assumptions

00:09:24,320 --> 00:09:28,800
that we had

00:09:25,920 --> 00:09:30,560
data is still larger than ram but we

00:09:28,800 --> 00:09:31,519
actually have much more ram this ratio

00:09:30,560 --> 00:09:34,080
was not as

00:09:31,519 --> 00:09:35,200
extreme as it was before ram has become

00:09:34,080 --> 00:09:37,279
much cheaper

00:09:35,200 --> 00:09:38,800
the disks were no longer no longer no

00:09:37,279 --> 00:09:40,800
longer necessarily magnetic

00:09:38,800 --> 00:09:43,279
the network bandwidth was no longer

00:09:40,800 --> 00:09:45,519
limited relative to the size of the data

00:09:43,279 --> 00:09:46,800
we still had large files in large data

00:09:45,519 --> 00:09:49,519
sets of course

00:09:46,800 --> 00:09:50,560
but when we were talking about this kind

00:09:49,519 --> 00:09:51,920
of system

00:09:50,560 --> 00:09:54,080
where we have much more ram and much

00:09:51,920 --> 00:09:54,800
more bandwidth it now makes sense to

00:09:54,080 --> 00:09:57,839
move

00:09:54,800 --> 00:09:59,920
data from the disks to

00:09:57,839 --> 00:10:02,160
the ram of remote machines and process

00:09:59,920 --> 00:10:05,040
it the where the computation is

00:10:02,160 --> 00:10:06,160
so we actually had a new design that

00:10:05,040 --> 00:10:09,040
made more sense and

00:10:06,160 --> 00:10:10,240
by 2013 everyone started to move from

00:10:09,040 --> 00:10:12,560
hadoop mapreduce

00:10:10,240 --> 00:10:15,120
to newer more modern frameworks that

00:10:12,560 --> 00:10:18,399
were based on new designs impala spark

00:10:15,120 --> 00:10:19,040
presto and things like that so by the

00:10:18,399 --> 00:10:21,279
time

00:10:19,040 --> 00:10:23,440
hadoop started being widely adopted it

00:10:21,279 --> 00:10:26,079
was already deprecated this happened in

00:10:23,440 --> 00:10:28,000
less than a decade

00:10:26,079 --> 00:10:29,200
so now let's talk about something really

00:10:28,000 --> 00:10:32,079
really old

00:10:29,200 --> 00:10:33,440
relational databases relational

00:10:32,079 --> 00:10:36,399
databases

00:10:33,440 --> 00:10:38,000
are about 30 years old if not more

00:10:36,399 --> 00:10:40,160
oracle for example was initially

00:10:38,000 --> 00:10:43,120
released at the end of the 70s

00:10:40,160 --> 00:10:44,399
and sql end of the 80s prosecutors my

00:10:43,120 --> 00:10:46,800
sequel were released

00:10:44,399 --> 00:10:49,200
mid-90s but the design is actually based

00:10:46,800 --> 00:10:51,839
on all the projects from the 80s

00:10:49,200 --> 00:10:55,040
so relational database design is

00:10:51,839 --> 00:10:56,800
actually more than 30 years old

00:10:55,040 --> 00:10:58,640
what was the design rational relational

00:10:56,800 --> 00:11:00,560
databases the design rationale

00:10:58,640 --> 00:11:02,160
was based on the fact that ram was

00:11:00,560 --> 00:11:04,480
really and was small

00:11:02,160 --> 00:11:06,160
and super expensive and also disks were

00:11:04,480 --> 00:11:09,200
especially fast disks were very

00:11:06,160 --> 00:11:12,320
expensive so if you think

00:11:09,200 --> 00:11:13,760
that if you think about the fact that

00:11:12,320 --> 00:11:16,320
when you need to look for something in

00:11:13,760 --> 00:11:19,839
an index you need to do a free a few

00:11:16,320 --> 00:11:22,000
disc sex so let's say you do about five

00:11:19,839 --> 00:11:23,519
it takes about 50 milliseconds to find

00:11:22,000 --> 00:11:26,800
something in

00:11:23,519 --> 00:11:28,720
the disk in based index

00:11:26,800 --> 00:11:29,920
but if you're actually looking in ram

00:11:28,720 --> 00:11:31,600
it's much faster

00:11:29,920 --> 00:11:33,040
than the network if the network run

00:11:31,600 --> 00:11:34,880
shape is around one millisecond it

00:11:33,040 --> 00:11:37,360
actually makes more sense

00:11:34,880 --> 00:11:39,200
to fetch data from a remote server that

00:11:37,360 --> 00:11:40,000
might have the data in ram than it is to

00:11:39,200 --> 00:11:43,120
do

00:11:40,000 --> 00:11:46,000
local disk six it's much much

00:11:43,120 --> 00:11:47,680
slower so what do we do we send the

00:11:46,000 --> 00:11:49,600
computation over the network to where

00:11:47,680 --> 00:11:51,440
the data is hosted on a big monolithic

00:11:49,600 --> 00:11:52,880
server that has a lot ram and a lot of

00:11:51,440 --> 00:11:55,040
disks it's likely to have

00:11:52,880 --> 00:11:57,600
the data or at least the index keys

00:11:55,040 --> 00:11:58,959
cached in a ram

00:11:57,600 --> 00:12:00,720
this brings us to this kind of

00:11:58,959 --> 00:12:02,240
architecture which is the famous three

00:12:00,720 --> 00:12:04,880
tier architecture this is just

00:12:02,240 --> 00:12:06,160
the bottom two tiers the database and

00:12:04,880 --> 00:12:08,000
application servers

00:12:06,160 --> 00:12:09,360
so we have a bunch of applications which

00:12:08,000 --> 00:12:11,680
are stateless and

00:12:09,360 --> 00:12:14,880
they store all the state in the database

00:12:11,680 --> 00:12:16,720
this big monolithic expensive database

00:12:14,880 --> 00:12:18,560
and every time they need to do something

00:12:16,720 --> 00:12:19,200
they talk to that database they send a

00:12:18,560 --> 00:12:21,279
query

00:12:19,200 --> 00:12:24,320
rpc style they get a response and they

00:12:21,279 --> 00:12:26,959
do the computations

00:12:24,320 --> 00:12:28,959
when we fast forward to 2020 a lot of

00:12:26,959 --> 00:12:30,800
things have changed we now have ssd

00:12:28,959 --> 00:12:33,200
drives which are much much faster the

00:12:30,800 --> 00:12:36,079
latency is about 50 microseconds

00:12:33,200 --> 00:12:37,120
ram has become much cheaper and so has

00:12:36,079 --> 00:12:39,360
ssd

00:12:37,120 --> 00:12:43,120
network latency hasn't changed much but

00:12:39,360 --> 00:12:46,480
the bandwidth had grown about 100 times

00:12:43,120 --> 00:12:47,519
so does that change anything actually it

00:12:46,480 --> 00:12:50,639
does

00:12:47,519 --> 00:12:52,639
now it's actually cheaper to fetch data

00:12:50,639 --> 00:12:55,200
from your local disk than it is to go to

00:12:52,639 --> 00:12:57,600
a remote server um it's about

00:12:55,200 --> 00:12:58,880
let's say 200 milliseconds or 200 sorry

00:12:57,600 --> 00:13:01,680
00:12:58,880 --> 00:13:02,240
microseconds to get data from a disk

00:13:01,680 --> 00:13:04,800
based

00:13:02,240 --> 00:13:06,639
based index on your local ssd and it's

00:13:04,800 --> 00:13:08,560
about one millisecond to get the data

00:13:06,639 --> 00:13:10,800
from a remote server even like

00:13:08,560 --> 00:13:12,240
if that server is very big and very

00:13:10,800 --> 00:13:14,399
powerful

00:13:12,240 --> 00:13:15,279
so the rationale has changed

00:13:14,399 --> 00:13:17,760
dramatically

00:13:15,279 --> 00:13:19,519
and if we think about this we actually

00:13:17,760 --> 00:13:20,240
arrive to architectures like this where

00:13:19,519 --> 00:13:22,800
the application

00:13:20,240 --> 00:13:23,839
servers keep a replicated copy of the

00:13:22,800 --> 00:13:26,480
database

00:13:23,839 --> 00:13:27,440
locally so in many machines today on

00:13:26,480 --> 00:13:30,399
amazon

00:13:27,440 --> 00:13:32,160
we actually have a lot more ram and

00:13:30,399 --> 00:13:34,320
local ssd than we use

00:13:32,160 --> 00:13:35,600
many applications don't actually use the

00:13:34,320 --> 00:13:37,519
local data and

00:13:35,600 --> 00:13:39,519
local disk that they get for free in

00:13:37,519 --> 00:13:42,079
amazon many instances you get

00:13:39,519 --> 00:13:43,120
terabytes of free nvme storage which is

00:13:42,079 --> 00:13:45,199
very fast

00:13:43,120 --> 00:13:47,120
and if you want to utilize it we need to

00:13:45,199 --> 00:13:48,560
store data locally

00:13:47,120 --> 00:13:50,240
and this is basically what this

00:13:48,560 --> 00:13:51,519
architecture does it uses network

00:13:50,240 --> 00:13:53,360
replication

00:13:51,519 --> 00:13:54,800
to utilize the high throughput of the

00:13:53,360 --> 00:13:57,279
network

00:13:54,800 --> 00:14:00,079
instead of being latency bound by doing

00:13:57,279 --> 00:14:02,639
repeated rpc calls

00:14:00,079 --> 00:14:04,959
another example is the common cache

00:14:02,639 --> 00:14:07,360
architecture so usually we would have

00:14:04,959 --> 00:14:08,800
a centralized cache usually memcached

00:14:07,360 --> 00:14:10,240
already so something like that and all

00:14:08,800 --> 00:14:13,600
the application servers

00:14:10,240 --> 00:14:14,880
would go remotely to that cache server

00:14:13,600 --> 00:14:16,959
to fetch data

00:14:14,880 --> 00:14:18,240
the downside of this architecture is

00:14:16,959 --> 00:14:21,120
that if you need to

00:14:18,240 --> 00:14:22,959
spend one or two milliseconds to get

00:14:21,120 --> 00:14:24,000
over the network to the remote cache

00:14:22,959 --> 00:14:26,560
server

00:14:24,000 --> 00:14:28,000
that sometimes is less efficient than

00:14:26,560 --> 00:14:29,839
just going to the database

00:14:28,000 --> 00:14:31,440
for example the database could deliver a

00:14:29,839 --> 00:14:33,199
response in that in the same time frame

00:14:31,440 --> 00:14:34,320
so you're not actually saving time by

00:14:33,199 --> 00:14:37,120
going to the cache

00:14:34,320 --> 00:14:38,800
if of course you have a cache myth then

00:14:37,120 --> 00:14:40,480
you also have to go to the relational

00:14:38,800 --> 00:14:42,320
database and you're actually doubling

00:14:40,480 --> 00:14:44,240
your latency

00:14:42,320 --> 00:14:45,680
so given the hardware that we have it

00:14:44,240 --> 00:14:47,120
now makes sense to have this kind of

00:14:45,680 --> 00:14:50,240
architecture where you have

00:14:47,120 --> 00:14:53,519
cache replicas reside locally on

00:14:50,240 --> 00:14:56,240
on application instances the stick

00:14:53,519 --> 00:14:57,440
to the local cache is very very fast

00:14:56,240 --> 00:14:59,760
almost zero time

00:14:57,440 --> 00:15:01,360
and because we have in many cases

00:14:59,760 --> 00:15:04,240
especially in amazon we have

00:15:01,360 --> 00:15:05,680
fast nvme drives on application servers

00:15:04,240 --> 00:15:07,440
which are sometimes very big and

00:15:05,680 --> 00:15:09,199
currently not being utilized

00:15:07,440 --> 00:15:10,639
we can actually use them to store cash

00:15:09,199 --> 00:15:12,880
very cheaply

00:15:10,639 --> 00:15:14,399
oh in ram that's not uncommon to see

00:15:12,880 --> 00:15:15,920
machines in amazon that have

00:15:14,399 --> 00:15:17,920
several gigabytes of ram which are not

00:15:15,920 --> 00:15:19,839
being used by the application

00:15:17,920 --> 00:15:22,240
so again we can replicate from the

00:15:19,839 --> 00:15:24,079
database and utilize the high throughput

00:15:22,240 --> 00:15:26,160
that we have over the network

00:15:24,079 --> 00:15:27,440
and this is what some innovative

00:15:26,160 --> 00:15:29,839
projects do

00:15:27,440 --> 00:15:31,199
there's a project by google called group

00:15:29,839 --> 00:15:33,920
cache for example which

00:15:31,199 --> 00:15:35,360
has local cache local ram cache on

00:15:33,920 --> 00:15:36,800
application servers and basically

00:15:35,360 --> 00:15:38,320
replicates from peers

00:15:36,800 --> 00:15:41,360
also very interesting i recommend that

00:15:38,320 --> 00:15:43,040
you look at it

00:15:41,360 --> 00:15:44,959
let's talk about relational database

00:15:43,040 --> 00:15:47,199
clusters so

00:15:44,959 --> 00:15:49,199
a relational database cluster is

00:15:47,199 --> 00:15:51,839
basically a cluster where you have

00:15:49,199 --> 00:15:53,040
a primary which has some kind of

00:15:51,839 --> 00:15:56,480
transaction log or

00:15:53,040 --> 00:15:57,360
write a headlog which is the basis of

00:15:56,480 --> 00:16:00,079
replication

00:15:57,360 --> 00:16:01,120
the the secondary is read this log and

00:16:00,079 --> 00:16:03,680
apply it on

00:16:01,120 --> 00:16:05,040
on the secondaries and that log is

00:16:03,680 --> 00:16:08,240
persisted on all the

00:16:05,040 --> 00:16:10,880
all the servers both the primary and the

00:16:08,240 --> 00:16:10,880
secondary

00:16:10,959 --> 00:16:16,800
and for persistence on every machine

00:16:14,160 --> 00:16:18,000
we basically write twice right once to

00:16:16,800 --> 00:16:19,920
the log

00:16:18,000 --> 00:16:23,040
and again to the you can call it

00:16:19,920 --> 00:16:27,040
snapshot the data file of the database

00:16:23,040 --> 00:16:30,160
this design has a very clear rationale

00:16:27,040 --> 00:16:32,720
the clear rationale at the time was that

00:16:30,160 --> 00:16:33,440
we need to make sure the data is doable

00:16:32,720 --> 00:16:35,519
this is a d

00:16:33,440 --> 00:16:38,240
in acid and we also need to make sure

00:16:35,519 --> 00:16:41,440
that rights are

00:16:38,240 --> 00:16:43,120
atomic and consistent and isolated data

00:16:41,440 --> 00:16:44,720
loss is not acceptable because if

00:16:43,120 --> 00:16:46,079
something happens to the disk we need to

00:16:44,720 --> 00:16:48,399
be able to recover it

00:16:46,079 --> 00:16:50,240
not necessarily we have a replica back

00:16:48,399 --> 00:16:52,639
in the day 30 years ago

00:16:50,240 --> 00:16:54,720
you sometimes have only one server

00:16:52,639 --> 00:16:56,079
downtime was acceptable but data loss

00:16:54,720 --> 00:16:59,120
was not acceptable

00:16:56,079 --> 00:17:00,079
and all of this design basically assumed

00:16:59,120 --> 00:17:03,120
that you have very

00:17:00,079 --> 00:17:04,880
reliable physical hardware so there's a

00:17:03,120 --> 00:17:08,160
lot of code in database

00:17:04,880 --> 00:17:11,520
in a relational database whose single

00:17:08,160 --> 00:17:14,240
whose goal is to make sure that if you

00:17:11,520 --> 00:17:16,079
get uh if right gets acknowledged that

00:17:14,240 --> 00:17:16,799
means it's safely on installed on the

00:17:16,079 --> 00:17:19,039
disk and

00:17:16,799 --> 00:17:20,880
even something bad happens to the server

00:17:19,039 --> 00:17:24,079
you can still recover that

00:17:20,880 --> 00:17:24,720
that light that data from the disk might

00:17:24,079 --> 00:17:26,480
be

00:17:24,720 --> 00:17:28,319
with forensics so for example you could

00:17:26,480 --> 00:17:30,320
send the disk to forensics and recover

00:17:28,319 --> 00:17:32,080
the data from there

00:17:30,320 --> 00:17:34,320
but this kind of assumed that we have

00:17:32,080 --> 00:17:36,480
physical hardware and monolithic servers

00:17:34,320 --> 00:17:38,080
what happens when we cloud in the cloud

00:17:36,480 --> 00:17:39,840
today we run servers in the cloud

00:17:38,080 --> 00:17:41,440
it's not possible to get the physical

00:17:39,840 --> 00:17:43,760
disk for forensic

00:17:41,440 --> 00:17:44,799
from amazon that's not going to happen

00:17:43,760 --> 00:17:47,679
um also

00:17:44,799 --> 00:17:49,360
today we need uptime so we're no longer

00:17:47,679 --> 00:17:51,120
willing to tolerate downtime so

00:17:49,360 --> 00:17:52,799
if we have a problem with the database

00:17:51,120 --> 00:17:53,600
server we're going to fail over to the

00:17:52,799 --> 00:17:55,200
secondary

00:17:53,600 --> 00:17:57,280
and when we fail over to the secondary

00:17:55,200 --> 00:17:59,360
it doesn't matter if the

00:17:57,280 --> 00:18:01,120
data that we've written has reached the

00:17:59,360 --> 00:18:03,840
disk on the primary

00:18:01,120 --> 00:18:04,960
if it's not on the secondary we have

00:18:03,840 --> 00:18:08,400
lost data

00:18:04,960 --> 00:18:11,520
so having this kind of durability and

00:18:08,400 --> 00:18:13,039
an acid guarantees doesn't actually help

00:18:11,520 --> 00:18:14,559
us anymore because we can't actually

00:18:13,039 --> 00:18:16,799
utilize it

00:18:14,559 --> 00:18:18,400
so this is the common architecture that

00:18:16,799 --> 00:18:21,440
we have in the cloud

00:18:18,400 --> 00:18:24,720
we basically have two uh nodes

00:18:21,440 --> 00:18:26,559
um a primary and secondary and we write

00:18:24,720 --> 00:18:28,400
the disk the disk is usually ebs that's

00:18:26,559 --> 00:18:31,360
a persistent disc on amazon

00:18:28,400 --> 00:18:32,000
and ebs is a network disk it's a remote

00:18:31,360 --> 00:18:35,200
storage

00:18:32,000 --> 00:18:37,600
and underlying in inside of the

00:18:35,200 --> 00:18:38,320
ebs stack it's basically replicating to

00:18:37,600 --> 00:18:41,360
three different

00:18:38,320 --> 00:18:43,600
storage nodes so we actually have

00:18:41,360 --> 00:18:45,039
two levels of replication one for the

00:18:43,600 --> 00:18:46,160
database layer and another for the

00:18:45,039 --> 00:18:48,480
storage levels which

00:18:46,160 --> 00:18:50,720
so that means we'll basically have a

00:18:48,480 --> 00:18:52,320
replication amplification we rotate many

00:18:50,720 --> 00:18:53,840
more times than we plan for

00:18:52,320 --> 00:18:55,440
but this also means that we don't

00:18:53,840 --> 00:18:56,480
actually know what's the actual

00:18:55,440 --> 00:18:59,440
durability

00:18:56,480 --> 00:19:00,640
of the data is why because the fsync the

00:18:59,440 --> 00:19:03,679
system call that's

00:19:00,640 --> 00:19:05,280
supposedly has semantics of you know if

00:19:03,679 --> 00:19:06,160
this is acknowledged and this is safely

00:19:05,280 --> 00:19:07,760
on the desk

00:19:06,160 --> 00:19:09,280
it's now virtualized so we don't

00:19:07,760 --> 00:19:10,799
actually know if it gives us the

00:19:09,280 --> 00:19:13,679
guarantees that we imagine

00:19:10,799 --> 00:19:14,640
we trust in a way the the ebs layout to

00:19:13,679 --> 00:19:17,280
do what

00:19:14,640 --> 00:19:18,400
sync is telling us but this is not

00:19:17,280 --> 00:19:20,240
likely the case

00:19:18,400 --> 00:19:21,760
because we know for a fact that ebs is

00:19:20,240 --> 00:19:25,120
not a simple storage uh

00:19:21,760 --> 00:19:27,039
source drive so a lot of the things in

00:19:25,120 --> 00:19:29,520
this design have been violated

00:19:27,039 --> 00:19:31,200
so understanding this we can think of

00:19:29,520 --> 00:19:32,240
different architectures for example

00:19:31,200 --> 00:19:34,640
instead of using

00:19:32,240 --> 00:19:36,720
remote storage like eps we can use local

00:19:34,640 --> 00:19:40,720
storage like the local nvme drive

00:19:36,720 --> 00:19:44,000
on ec2 instances and

00:19:40,720 --> 00:19:46,160
to get the redundancy that we need we

00:19:44,000 --> 00:19:47,760
can use the database level replication

00:19:46,160 --> 00:19:49,200
we can replicate from primary to

00:19:47,760 --> 00:19:51,200
secondaries

00:19:49,200 --> 00:19:52,799
using native replication layer of the

00:19:51,200 --> 00:19:55,039
database and this is actually

00:19:52,799 --> 00:19:57,600
very useful and also this is the basic

00:19:55,039 --> 00:20:00,640
design of many nosql

00:19:57,600 --> 00:20:04,640
databases like sealer for example

00:20:00,640 --> 00:20:08,000
aws or is another very interesting case

00:20:04,640 --> 00:20:09,679
aws also understood that uh you know

00:20:08,000 --> 00:20:11,039
that a lot of things have changed in

00:20:09,679 --> 00:20:13,520
database design and they

00:20:11,039 --> 00:20:15,440
try to rethink to really how the

00:20:13,520 --> 00:20:18,880
database should look on the cloud

00:20:15,440 --> 00:20:21,120
so what they did is they basically

00:20:18,880 --> 00:20:22,640
split the database in two they have one

00:20:21,120 --> 00:20:25,520
part which is the part where you

00:20:22,640 --> 00:20:26,080
apply the log and that part now resides

00:20:25,520 --> 00:20:29,280
on

00:20:26,080 --> 00:20:32,480
the storage nodes themselves so

00:20:29,280 --> 00:20:35,760
we kind of get this design where

00:20:32,480 --> 00:20:37,919
the the database server

00:20:35,760 --> 00:20:39,679
serves the request for read and write

00:20:37,919 --> 00:20:41,679
but instead of writing the

00:20:39,679 --> 00:20:42,720
the data to the snapshot or the data

00:20:41,679 --> 00:20:45,440
file itself

00:20:42,720 --> 00:20:47,520
it generates the log the commit log

00:20:45,440 --> 00:20:48,400
which is then replicated directly to

00:20:47,520 --> 00:20:50,480
storage nodes

00:20:48,400 --> 00:20:51,520
which apply it on the data file on

00:20:50,480 --> 00:20:54,880
snapshot

00:20:51,520 --> 00:20:56,960
and then all of the secondaries

00:20:54,880 --> 00:20:58,799
all they need to do is just read from

00:20:56,960 --> 00:21:00,720
that data file and save reads

00:20:58,799 --> 00:21:02,799
and in case of failover you only fail

00:21:00,720 --> 00:21:04,960
the computation and

00:21:02,799 --> 00:21:05,840
the generation of the log over to the

00:21:04,960 --> 00:21:08,559
secondary

00:21:05,840 --> 00:21:10,400
so this helps them scale better in the

00:21:08,559 --> 00:21:11,280
cloud and also removes one level of

00:21:10,400 --> 00:21:13,760
abstraction

00:21:11,280 --> 00:21:15,039
and makes the the rights and grids of

00:21:13,760 --> 00:21:18,799
all the storage layer

00:21:15,039 --> 00:21:20,000
more coherent now we have to remember

00:21:18,799 --> 00:21:21,520
when we talk about storage

00:21:20,000 --> 00:21:23,520
and the changes that became that

00:21:21,520 --> 00:21:25,919
happened in storage in the last 30 years

00:21:23,520 --> 00:21:27,760
that even the api of storage doesn't

00:21:25,919 --> 00:21:29,919
make sense anymore

00:21:27,760 --> 00:21:31,120
we basically have a block level api

00:21:29,919 --> 00:21:32,799
which is something like

00:21:31,120 --> 00:21:34,400
i want to write a four kilo four

00:21:32,799 --> 00:21:37,039
kilobyte block and

00:21:34,400 --> 00:21:38,480
please say this block number or whatever

00:21:37,039 --> 00:21:42,080
and reading that block is

00:21:38,480 --> 00:21:44,880
basically the same but this makes sense

00:21:42,080 --> 00:21:46,080
when you have a disk whose physical

00:21:44,880 --> 00:21:48,880
structure

00:21:46,080 --> 00:21:49,600
basically is composed of log of blocks

00:21:48,880 --> 00:21:53,360
but

00:21:49,600 --> 00:21:55,840
modern disks are not built this way

00:21:53,360 --> 00:21:57,039
for example ssd is more more or less a

00:21:55,840 --> 00:22:00,159
key value store

00:21:57,039 --> 00:22:02,720
it actually stores items by key

00:22:00,159 --> 00:22:03,840
and it can you know it can utilize high

00:22:02,720 --> 00:22:06,880
parallelization

00:22:03,840 --> 00:22:09,120
which magnetic disks did not allow for

00:22:06,880 --> 00:22:11,280
so we kind of have a problem where we

00:22:09,120 --> 00:22:13,360
cannot use the abilities of the

00:22:11,280 --> 00:22:14,559
of modern hardware because we're limited

00:22:13,360 --> 00:22:16,880
by the api

00:22:14,559 --> 00:22:17,600
also there's a lot of other differences

00:22:16,880 --> 00:22:20,480
for example

00:22:17,600 --> 00:22:21,200
you can't actually mutate data on ssd on

00:22:20,480 --> 00:22:23,280
ssd

00:22:21,200 --> 00:22:25,120
you can only append data and you have an

00:22:23,280 --> 00:22:26,799
internal process of garbage collection

00:22:25,120 --> 00:22:28,080
so this created a lot of problems we

00:22:26,799 --> 00:22:30,559
needed to introduce a new

00:22:28,080 --> 00:22:32,559
system called trim the famous stream to

00:22:30,559 --> 00:22:34,400
allow the operating system to

00:22:32,559 --> 00:22:35,919
give the disc hints on how to do its

00:22:34,400 --> 00:22:38,240
internal garbage collection

00:22:35,919 --> 00:22:39,200
and so on and so on so on so a lot of

00:22:38,240 --> 00:22:42,240
problems though

00:22:39,200 --> 00:22:44,080
and this needed to be rethought when

00:22:42,240 --> 00:22:45,280
we're talking about storage

00:22:44,080 --> 00:22:47,360
we have to remember that even the

00:22:45,280 --> 00:22:48,880
storage api is not

00:22:47,360 --> 00:22:51,120
really added and built for today's

00:22:48,880 --> 00:22:51,840
hardware the storage api that we

00:22:51,120 --> 00:22:55,760
currently use

00:22:51,840 --> 00:22:56,799
is a block level api basic language of

00:22:55,760 --> 00:22:59,679
the api

00:22:56,799 --> 00:23:00,720
is blocks of a fixed size and it's

00:22:59,679 --> 00:23:03,039
basically an

00:23:00,720 --> 00:23:05,840
immutable api where we write blocks in

00:23:03,039 --> 00:23:07,679
place to muted them

00:23:05,840 --> 00:23:09,440
and the performance for reading light is

00:23:07,679 --> 00:23:11,120
mostly the same but there's a huge

00:23:09,440 --> 00:23:13,600
difference between random lights

00:23:11,120 --> 00:23:14,799
and sequential lights because magnetic

00:23:13,600 --> 00:23:16,240
discs were

00:23:14,799 --> 00:23:18,400
were actually pretty good at doing

00:23:16,240 --> 00:23:20,320
sequential lights so we have a lot of

00:23:18,400 --> 00:23:23,679
operating system behavior that build

00:23:20,320 --> 00:23:23,679
on top of this like reader head

00:23:23,919 --> 00:23:27,200
also the parallelism of magnetic disks

00:23:25,919 --> 00:23:28,880
was very very low

00:23:27,200 --> 00:23:31,039
but this is no longer true when we're

00:23:28,880 --> 00:23:35,120
talking about modern storage for example

00:23:31,039 --> 00:23:37,679
ssd is basically key value

00:23:35,120 --> 00:23:38,880
storage device and it has high

00:23:37,679 --> 00:23:41,679
parallelism

00:23:38,880 --> 00:23:42,480
and it's not mutable it has a garbage

00:23:41,679 --> 00:23:45,360
collection

00:23:42,480 --> 00:23:45,840
process instead and basically you only

00:23:45,360 --> 00:23:48,720
append

00:23:45,840 --> 00:23:49,440
to the ssd and the new system call that

00:23:48,720 --> 00:23:52,400
we introduced

00:23:49,440 --> 00:23:53,200
the trim call that allows the operating

00:23:52,400 --> 00:23:55,840
system to tell

00:23:53,200 --> 00:23:57,520
to go and to tell the ssd what it can

00:23:55,840 --> 00:23:59,120
garbage collect

00:23:57,520 --> 00:24:01,600
but also we have virtualized storage

00:23:59,120 --> 00:24:05,120
like ebs it's not a simple magnetic disk

00:24:01,600 --> 00:24:06,640
you can also use a hyperlolization

00:24:05,120 --> 00:24:09,360
it doesn't necessarily need read the

00:24:06,640 --> 00:24:11,520
head it doesn't necessarily give you

00:24:09,360 --> 00:24:12,400
higher speeds for sequential writes

00:24:11,520 --> 00:24:16,080
versus uh

00:24:12,400 --> 00:24:18,559
random whites so all of this api doesn't

00:24:16,080 --> 00:24:21,520
actually make sense anymore

00:24:18,559 --> 00:24:21,919
this introduced a lot of problems and

00:24:21,520 --> 00:24:24,480
also

00:24:21,919 --> 00:24:24,960
there's a lot of innovative solutions

00:24:24,480 --> 00:24:27,120
for this

00:24:24,960 --> 00:24:28,159
for example samsung has released a new

00:24:27,120 --> 00:24:31,200
drive ssd

00:24:28,159 --> 00:24:34,320
drive that exposes a new

00:24:31,200 --> 00:24:35,200
key value store api of course that's not

00:24:34,320 --> 00:24:37,039
um

00:24:35,200 --> 00:24:38,559
suitable for normal usage you need

00:24:37,039 --> 00:24:40,640
special drivers for this

00:24:38,559 --> 00:24:41,919
but it actually gives very interesting

00:24:40,640 --> 00:24:43,919
results

00:24:41,919 --> 00:24:45,200
if you look at seth the open source

00:24:43,919 --> 00:24:47,760
distributed storage

00:24:45,200 --> 00:24:49,919
project they have what is known as

00:24:47,760 --> 00:24:52,000
bluestone which is a storage layer that

00:24:49,919 --> 00:24:52,960
bypasses the file system and directly

00:24:52,000 --> 00:24:55,120
talks storage

00:24:52,960 --> 00:24:56,240
to utilize modern hardware so very

00:24:55,120 --> 00:24:59,600
interesting projects

00:24:56,240 --> 00:25:03,039
very interesting cases if we think of

00:24:59,600 --> 00:25:06,320
how to talk to new hardware

00:25:03,039 --> 00:25:09,520
but even the operating system structure

00:25:06,320 --> 00:25:09,840
that we use in mostly all our servers we

00:25:09,520 --> 00:25:13,120
use

00:25:09,840 --> 00:25:15,039
linux linux's origin originally was

00:25:13,120 --> 00:25:16,880
designed in the 90s and it boils heavily

00:25:15,039 --> 00:25:18,559
from unix which is a system that was

00:25:16,880 --> 00:25:20,880
designed in the 70s

00:25:18,559 --> 00:25:22,000
windows is also pretty old it's

00:25:20,880 --> 00:25:26,320
originally from

00:25:22,000 --> 00:25:28,080
the mid-90s same for osx and ios which

00:25:26,320 --> 00:25:31,120
are based on the bsd project

00:25:28,080 --> 00:25:33,279
from again the 90s and android which is

00:25:31,120 --> 00:25:34,960
fairly modern operating system again is

00:25:33,279 --> 00:25:36,720
based on linux

00:25:34,960 --> 00:25:38,640
so a lot of things have changed and

00:25:36,720 --> 00:25:40,960
operating system architecture

00:25:38,640 --> 00:25:42,159
has adapted of course but still there's

00:25:40,960 --> 00:25:44,960
a lot of gaps

00:25:42,159 --> 00:25:46,320
that exist when we're talking about

00:25:44,960 --> 00:25:48,320
modern hardware

00:25:46,320 --> 00:25:49,919
we now have multi-cores we have a lot of

00:25:48,320 --> 00:25:51,679
course in some cases

00:25:49,919 --> 00:25:53,520
even hundreds of calls we have

00:25:51,679 --> 00:25:55,360
non-volatile world alarm

00:25:53,520 --> 00:25:57,600
and operating systems make a lot of

00:25:55,360 --> 00:26:00,480
assumptions about the volatility of ram

00:25:57,600 --> 00:26:01,919
we have direct i o a synchronous io

00:26:00,480 --> 00:26:04,799
which we use monmo

00:26:01,919 --> 00:26:05,200
and the operating system struggle to be

00:26:04,799 --> 00:26:07,840
to

00:26:05,200 --> 00:26:09,679
adapt to this but sometimes like very

00:26:07,840 --> 00:26:11,360
large gaps

00:26:09,679 --> 00:26:12,720
here's an example which relates to

00:26:11,360 --> 00:26:14,320
multicol

00:26:12,720 --> 00:26:16,000
a lot of the software that we currently

00:26:14,320 --> 00:26:18,799
use is multi-threaded

00:26:16,000 --> 00:26:20,000
and the problem is that threads can move

00:26:18,799 --> 00:26:23,120
between

00:26:20,000 --> 00:26:24,000
calls on cpu calls and the operating

00:26:23,120 --> 00:26:26,799
system basically

00:26:24,000 --> 00:26:28,080
decides where to locate the threads and

00:26:26,799 --> 00:26:30,159
we can't

00:26:28,080 --> 00:26:31,279
tell the operating system you know what

00:26:30,159 --> 00:26:33,120
to do we can

00:26:31,279 --> 00:26:34,960
to some degree do cpu pinning but it's

00:26:33,120 --> 00:26:37,039
fairly limited

00:26:34,960 --> 00:26:38,640
when a thread moves to one from one call

00:26:37,039 --> 00:26:41,600
to another call we have a problem

00:26:38,640 --> 00:26:41,919
why because memory is now divided into

00:26:41,600 --> 00:26:43,760
uh

00:26:41,919 --> 00:26:45,039
what's known as nodes this is like

00:26:43,760 --> 00:26:48,080
pneuma nodes and

00:26:45,039 --> 00:26:51,679
when you try to access from one core

00:26:48,080 --> 00:26:53,440
to the memory that is being owned by

00:26:51,679 --> 00:26:56,960
another call

00:26:53,440 --> 00:26:58,640
access is slower so the cost of it is

00:26:56,960 --> 00:27:00,240
higher and also we need locks to

00:26:58,640 --> 00:27:02,960
synchronize the

00:27:00,240 --> 00:27:04,960
memory between threads so this

00:27:02,960 --> 00:27:06,960
introduces a lot of performance problems

00:27:04,960 --> 00:27:09,919
and hinders of scalability

00:27:06,960 --> 00:27:11,440
so scaling databases and other software

00:27:09,919 --> 00:27:13,919
that's multi-threaded across

00:27:11,440 --> 00:27:14,799
many calls has become a huge problem in

00:27:13,919 --> 00:27:18,320
addition

00:27:14,799 --> 00:27:19,760
if you have an use of the network

00:27:18,320 --> 00:27:21,360
the network stack itself is

00:27:19,760 --> 00:27:24,000
multi-threaded and can also

00:27:21,360 --> 00:27:25,200
relocate between calls and we don't

00:27:24,000 --> 00:27:26,480
actually have control of this the

00:27:25,200 --> 00:27:29,600
operating system

00:27:26,480 --> 00:27:32,799
makes decisions about where to locate

00:27:29,600 --> 00:27:34,000
the processing of packets and network

00:27:32,799 --> 00:27:36,159
network data

00:27:34,000 --> 00:27:37,279
the operating system does its best to

00:27:36,159 --> 00:27:40,559
give you locality

00:27:37,279 --> 00:27:42,000
both for for cache and memory but it

00:27:40,559 --> 00:27:43,520
doesn't know what your application is

00:27:42,000 --> 00:27:45,120
going to do so it's fairly limited and

00:27:43,520 --> 00:27:48,720
you cannot solve this problem

00:27:45,120 --> 00:27:49,760
by itself what can we do a more modern

00:27:48,720 --> 00:27:51,520
solution

00:27:49,760 --> 00:27:52,960
is an architecture that is known as a

00:27:51,520 --> 00:27:53,919
childbirth core design or thread

00:27:52,960 --> 00:27:56,240
protocol design

00:27:53,919 --> 00:27:57,760
where we have one process of one thread

00:27:56,240 --> 00:27:59,440
that's completely separate from all the

00:27:57,760 --> 00:28:01,279
other it's a share nothing architecture

00:27:59,440 --> 00:28:03,679
we do not show memory between

00:28:01,279 --> 00:28:04,480
threads or between processes and each of

00:28:03,679 --> 00:28:06,399
them runs on

00:28:04,480 --> 00:28:07,840
one core and one call and exactly one

00:28:06,399 --> 00:28:11,200
core it does not

00:28:07,840 --> 00:28:12,240
and does not read or write to the memory

00:28:11,200 --> 00:28:15,200
of other

00:28:12,240 --> 00:28:16,720
shards or processes instead when we need

00:28:15,200 --> 00:28:19,039
to communicate between threads

00:28:16,720 --> 00:28:20,640
we do it with an explicit rpc

00:28:19,039 --> 00:28:21,279
communication mechanism across the

00:28:20,640 --> 00:28:24,720
course

00:28:21,279 --> 00:28:25,679
and that's we reduced the requirement

00:28:24,720 --> 00:28:29,039
for locking

00:28:25,679 --> 00:28:31,520
and we gained scalability

00:28:29,039 --> 00:28:32,159
for many many calls but this of course

00:28:31,520 --> 00:28:35,679
makes

00:28:32,159 --> 00:28:37,600
the mechanism of thread scheduling

00:28:35,679 --> 00:28:39,120
a between because we don't actually use

00:28:37,600 --> 00:28:41,679
it so if you look at

00:28:39,120 --> 00:28:43,039
sealer for example it uses a framework

00:28:41,679 --> 00:28:44,960
open source framework we call

00:28:43,039 --> 00:28:46,799
style which is actually like a mini

00:28:44,960 --> 00:28:47,679
operating system in itself it does the

00:28:46,799 --> 00:28:50,559
scheduling

00:28:47,679 --> 00:28:51,840
it does the memory allocation for itself

00:28:50,559 --> 00:28:53,679
and it basically

00:28:51,840 --> 00:28:55,360
kind of overrides a lot of the kernel

00:28:53,679 --> 00:28:58,080
mechanisms

00:28:55,360 --> 00:28:59,039
but again you get this modern

00:28:58,080 --> 00:29:01,919
architecture that

00:28:59,039 --> 00:29:02,960
allows you to scale very well so what

00:29:01,919 --> 00:29:05,520
have we learned

00:29:02,960 --> 00:29:07,200
from the from all those examples we've

00:29:05,520 --> 00:29:07,679
learned that we need to rethink a lot of

00:29:07,200 --> 00:29:09,520
our

00:29:07,679 --> 00:29:11,760
design principles and we need to

00:29:09,520 --> 00:29:14,159
understand the design rationale

00:29:11,760 --> 00:29:15,279
of the projects that we use and the

00:29:14,159 --> 00:29:17,039
systems that we use

00:29:15,279 --> 00:29:19,360
why because a lot of them are no longer

00:29:17,039 --> 00:29:20,880
true we need to recheck our design

00:29:19,360 --> 00:29:21,600
assumptions and start from first

00:29:20,880 --> 00:29:24,880
principles

00:29:21,600 --> 00:29:26,640
when we do that we can find many many

00:29:24,880 --> 00:29:28,480
interesting things that we can change

00:29:26,640 --> 00:29:31,360
and benefit from

00:29:28,480 --> 00:29:33,360
we shouldn't take anything for granted

00:29:31,360 --> 00:29:34,480
even if we don't end up changing the

00:29:33,360 --> 00:29:36,080
architecture

00:29:34,480 --> 00:29:38,399
we will still better understand the

00:29:36,080 --> 00:29:40,960
design limits and where it can fail and

00:29:38,399 --> 00:29:43,760
what we can do about it

00:29:40,960 --> 00:29:45,120
but it's also very important to be

00:29:43,760 --> 00:29:46,720
careful we don't want to change

00:29:45,120 --> 00:29:49,039
architecture

00:29:46,720 --> 00:29:50,720
needlessly there's something that's

00:29:49,039 --> 00:29:52,000
often ignored which is the value of

00:29:50,720 --> 00:29:54,240
maturity

00:29:52,000 --> 00:29:55,840
maturity especially when it comes to

00:29:54,240 --> 00:29:57,600
systems like databases

00:29:55,840 --> 00:29:59,200
is very very hard to achieve it takes a

00:29:57,600 --> 00:30:01,200
very very long time it's

00:29:59,200 --> 00:30:02,559
basically 30 years of learning that

00:30:01,200 --> 00:30:04,640
we're throwing down the drain

00:30:02,559 --> 00:30:06,080
when we change your system we don't want

00:30:04,640 --> 00:30:08,720
to do this unless

00:30:06,080 --> 00:30:09,919
we actually gain very big strategic

00:30:08,720 --> 00:30:12,159
advantages

00:30:09,919 --> 00:30:13,039
so by all means rethink your

00:30:12,159 --> 00:30:15,760
architecture

00:30:13,039 --> 00:30:18,080
rethink your designs but only change it

00:30:15,760 --> 00:30:23,840
if there's a lot you can gain

00:30:18,080 --> 00:30:23,840
just don't be a hipster thank you

00:30:24,290 --> 00:30:30,229
[Music]

00:30:34,480 --> 00:30:40,480
every that was a great talk

00:30:37,520 --> 00:30:42,080
thank you very much thank you i have to

00:30:40,480 --> 00:30:42,960
admit that it's uh it's great but then

00:30:42,080 --> 00:30:44,880
again uh

00:30:42,960 --> 00:30:47,200
quite quite disturbing because you

00:30:44,880 --> 00:30:48,240
actually uh peel down layer after layer

00:30:47,200 --> 00:30:50,480
and showing us

00:30:48,240 --> 00:30:51,360
essentially that we are under the

00:30:50,480 --> 00:30:53,679
assumption that we're

00:30:51,360 --> 00:30:55,520
running on you know the the top notch

00:30:53,679 --> 00:30:57,200
and the cutting edge bleeding it but

00:30:55,520 --> 00:30:57,600
then again we're based on layers that

00:30:57,200 --> 00:31:01,279
are

00:30:57,600 --> 00:31:04,399
have been written in the 70s or 90s and

00:31:01,279 --> 00:31:07,120
and hardly are equipped to to

00:31:04,399 --> 00:31:07,519
handle the uh the new workload well you

00:31:07,120 --> 00:31:09,919
know

00:31:07,519 --> 00:31:11,039
as i go and get older i realized that

00:31:09,919 --> 00:31:14,960
actually you know

00:31:11,039 --> 00:31:14,960
legacy is not so bad you know

00:31:15,120 --> 00:31:19,200
which is yet another disturbing thing

00:31:17,360 --> 00:31:21,279
because on the one end uh

00:31:19,200 --> 00:31:22,480
we may we may think okay what can we do

00:31:21,279 --> 00:31:25,760
better but then again

00:31:22,480 --> 00:31:26,480
you bring up a valid point which is okay

00:31:25,760 --> 00:31:29,120
it may be

00:31:26,480 --> 00:31:31,279
old but then again it comes with a lot

00:31:29,120 --> 00:31:34,720
of maturity in the software so uh

00:31:31,279 --> 00:31:37,039
yeah maybe if we you know looking at the

00:31:34,720 --> 00:31:39,679
example of hadoop that you gave

00:31:37,039 --> 00:31:41,919
you know 10 years to to popularize and

00:31:39,679 --> 00:31:43,760
by then it's become outdated

00:31:41,919 --> 00:31:44,960
due to the technological changes and

00:31:43,760 --> 00:31:49,120
then you know also that

00:31:44,960 --> 00:31:51,440
the rate is only pacing up uh so

00:31:49,120 --> 00:31:52,880
how can we choose wisely uh the platform

00:31:51,440 --> 00:31:54,000
to adopt know as an as an end

00:31:52,880 --> 00:31:55,760
organization not

00:31:54,000 --> 00:31:57,200
someone now designing a new platform

00:31:55,760 --> 00:31:59,440
like asylum maybe but

00:31:57,200 --> 00:32:00,880
as an end user wanting to choose the

00:31:59,440 --> 00:32:02,799
right platforms

00:32:00,880 --> 00:32:04,960
to adopt in the organization in light of

00:32:02,799 --> 00:32:08,159
these rates of change

00:32:04,960 --> 00:32:10,799
especially in the open source domain

00:32:08,159 --> 00:32:12,840
i think it's not so much important to

00:32:10,799 --> 00:32:16,960
choose correctly as much as it

00:32:12,840 --> 00:32:18,559
is important to uh properly change

00:32:16,960 --> 00:32:20,000
um because you have to assume that

00:32:18,559 --> 00:32:21,279
you're not going to get it right there's

00:32:20,000 --> 00:32:22,880
almost no way

00:32:21,279 --> 00:32:24,799
um even if you look into the future and

00:32:22,880 --> 00:32:26,399
you extrapolate yourself in ten years

00:32:24,799 --> 00:32:28,480
you know we're gonna have a machine with

00:32:26,399 --> 00:32:30,000
just as many calls and whatever a lot of

00:32:28,480 --> 00:32:31,760
things can happen in the meantime that

00:32:30,000 --> 00:32:33,840
will take it to a different direction

00:32:31,760 --> 00:32:35,200
so it's kind of like you can try very

00:32:33,840 --> 00:32:37,679
hard to make the right choice

00:32:35,200 --> 00:32:40,000
odds are you're not going to make it but

00:32:37,679 --> 00:32:41,600
if you invest in apis and

00:32:40,000 --> 00:32:43,840
good abstraction those that actually

00:32:41,600 --> 00:32:46,480
allow you to make those changes later on

00:32:43,840 --> 00:32:48,320
then you can adapt and uh maybe you know

00:32:46,480 --> 00:32:50,240
shave off this technical debt

00:32:48,320 --> 00:32:51,919
uh so that's one thing and we're

00:32:50,240 --> 00:32:54,080
actually getting much better at this

00:32:51,919 --> 00:32:55,200
one of the problems of 30 years ago is

00:32:54,080 --> 00:32:56,159
that we didn't have those kind of

00:32:55,200 --> 00:32:58,320
protocols

00:32:56,159 --> 00:33:00,480
and everything was coupled so i used to

00:32:58,320 --> 00:33:02,320
work on mainframes a long time ago

00:33:00,480 --> 00:33:03,919
and probably mainframes is that they

00:33:02,320 --> 00:33:06,240
talked directly with the hardware

00:33:03,919 --> 00:33:08,000
so if you needed to change the hardware

00:33:06,240 --> 00:33:09,840
you had to write an emulator

00:33:08,000 --> 00:33:11,200
because there was no drivers or anything

00:33:09,840 --> 00:33:12,799
like that uh so

00:33:11,200 --> 00:33:14,320
we don't do this mistake anymore we

00:33:12,799 --> 00:33:15,279
actually have drivers and protocols and

00:33:14,320 --> 00:33:17,279
apis

00:33:15,279 --> 00:33:19,200
uh so it makes it easier but also the

00:33:17,279 --> 00:33:21,919
apis sometimes get older so it's

00:33:19,200 --> 00:33:24,320
you know kind of work in progress but uh

00:33:21,919 --> 00:33:28,159
just don't try to get it right i guess

00:33:24,320 --> 00:33:29,679
my advice actually i i think that's a

00:33:28,159 --> 00:33:31,760
that's a very interesting point you made

00:33:29,679 --> 00:33:32,159
because there was some advantage you

00:33:31,760 --> 00:33:33,760
know

00:33:32,159 --> 00:33:35,679
back in the mainframe days that

00:33:33,760 --> 00:33:38,000
everything was vertically optimized

00:33:35,679 --> 00:33:40,159
because on the 100 those a very the

00:33:38,000 --> 00:33:42,240
disadvantage of coupling but then again

00:33:40,159 --> 00:33:43,840
you knew that things were like through

00:33:42,240 --> 00:33:45,919
all the different layers were very much

00:33:43,840 --> 00:33:47,600
optimized where here you actually showed

00:33:45,919 --> 00:33:49,519
that we were working on

00:33:47,600 --> 00:33:51,440
some on top of so many layers of

00:33:49,519 --> 00:33:52,960
virtualizations that aren't necessarily

00:33:51,440 --> 00:33:55,039
optimized to one another you know

00:33:52,960 --> 00:33:56,720
the storage drivers the virtual networks

00:33:55,039 --> 00:33:58,720
the operating system the

00:33:56,720 --> 00:34:00,480
virtual machine containers and you name

00:33:58,720 --> 00:34:03,279
it um

00:34:00,480 --> 00:34:04,159
so i'm just wondering given this uh

00:34:03,279 --> 00:34:06,880
state of

00:34:04,159 --> 00:34:07,840
where we stand with it does it make more

00:34:06,880 --> 00:34:10,159
sense to

00:34:07,840 --> 00:34:11,760
uh uh you know almost also performance

00:34:10,159 --> 00:34:13,919
wise to use

00:34:11,760 --> 00:34:15,760
uh you know a cloud provider that is

00:34:13,919 --> 00:34:18,720
focused on optimizing the stack

00:34:15,760 --> 00:34:21,839
virtually so the equivalent of the uh

00:34:18,720 --> 00:34:24,399
the mainframe on the cloud arena

00:34:21,839 --> 00:34:26,879
so you made a very good point it's a

00:34:24,399 --> 00:34:28,639
basic trade-off between flexibility and

00:34:26,879 --> 00:34:30,079
performance of optimization and

00:34:28,639 --> 00:34:31,679
efficiency and

00:34:30,079 --> 00:34:34,079
there's really no way around this i mean

00:34:31,679 --> 00:34:34,960
every abstraction that has its cost and

00:34:34,079 --> 00:34:37,200
actually

00:34:34,960 --> 00:34:38,480
if you uh look at the way modern stack

00:34:37,200 --> 00:34:40,159
is built we actually use

00:34:38,480 --> 00:34:42,320
sometimes three or four layers of

00:34:40,159 --> 00:34:44,720
virtualization uh for example

00:34:42,320 --> 00:34:46,839
you have sandboxes usually in the

00:34:44,720 --> 00:34:49,040
node.js or java and then you have

00:34:46,839 --> 00:34:51,119
containers and then you have the

00:34:49,040 --> 00:34:52,399
hypervisor and sometimes like another

00:34:51,119 --> 00:34:55,839
one

00:34:52,399 --> 00:34:57,520
under that so this is the price we pay

00:34:55,839 --> 00:34:59,280
for having the amazing flexibility we

00:34:57,520 --> 00:35:01,760
have today

00:34:59,280 --> 00:35:03,760
but as it turns out in many cases we you

00:35:01,760 --> 00:35:04,800
don't actually need this kind of extreme

00:35:03,760 --> 00:35:06,400
performance

00:35:04,800 --> 00:35:08,320
whether you have you need performance

00:35:06,400 --> 00:35:10,079
but the thing about performance is it

00:35:08,320 --> 00:35:12,720
has to be good enough

00:35:10,079 --> 00:35:14,480
um and yet in some cases and this is

00:35:12,720 --> 00:35:16,480
like very contextual you do

00:35:14,480 --> 00:35:18,640
actually need to have uh extreme

00:35:16,480 --> 00:35:20,400
performance and then you see things

00:35:18,640 --> 00:35:21,839
like real-time operating systems that

00:35:20,400 --> 00:35:23,520
work directly with the hardware

00:35:21,839 --> 00:35:26,800
and you write in color space you don't

00:35:23,520 --> 00:35:29,119
use this uh user space crossface uh

00:35:26,800 --> 00:35:31,760
separation so it's very contextual i

00:35:29,119 --> 00:35:35,040
think for the most case like the 99

00:35:31,760 --> 00:35:36,320
99 of us prefer flexibility over extreme

00:35:35,040 --> 00:35:38,480
performance and then you have one

00:35:36,320 --> 00:35:39,920
percent of the world which actually want

00:35:38,480 --> 00:35:41,599
excellent performance and don't want to

00:35:39,920 --> 00:35:44,400
pay in flexibility so

00:35:41,599 --> 00:35:45,119
that's a trade-off basically yeah

00:35:44,400 --> 00:35:46,800
interesting

00:35:45,119 --> 00:35:49,359
and and what would you say the you know

00:35:46,800 --> 00:35:50,800
uh the next as much as we can be

00:35:49,359 --> 00:35:52,480
foresee now that we're at the end of

00:35:50,800 --> 00:35:55,920
2020 and everyone is

00:35:52,480 --> 00:35:58,240
giving predictions to 2020 2021

00:35:55,920 --> 00:35:59,440
what do you foresee is the next step in

00:35:58,240 --> 00:36:02,720
the evolution in these

00:35:59,440 --> 00:36:04,720
domains uh so it's hard to say but you

00:36:02,720 --> 00:36:06,400
do see a couple of trends at audience

00:36:04,720 --> 00:36:07,359
that are already happening right now so

00:36:06,400 --> 00:36:10,560
first of all

00:36:07,359 --> 00:36:14,240
in the first time in about 20 years

00:36:10,560 --> 00:36:16,320
the processor wars are back yay i don't

00:36:14,240 --> 00:36:18,800
remember like amd versus intel versus

00:36:16,320 --> 00:36:20,800
citrix and competing architectures or

00:36:18,800 --> 00:36:22,800
risk and cisco like that i kind of

00:36:20,800 --> 00:36:24,800
forgot that this happened and then

00:36:22,800 --> 00:36:26,720
now this year you know it's back now we

00:36:24,800 --> 00:36:29,119
have arm versus intel and

00:36:26,720 --> 00:36:30,720
there's another open standard for

00:36:29,119 --> 00:36:33,920
instruction set

00:36:30,720 --> 00:36:34,880
um so this is going to be hot uh there's

00:36:33,920 --> 00:36:37,359
a lot of

00:36:34,880 --> 00:36:39,280
incentives and a lot of benefits to

00:36:37,359 --> 00:36:41,119
moving back to risk

00:36:39,280 --> 00:36:43,520
so i think we're going to see a lot of

00:36:41,119 --> 00:36:44,640
changes in in processor world for sure

00:36:43,520 --> 00:36:48,000
and memory

00:36:44,640 --> 00:36:51,200
and all of those buses also storage

00:36:48,000 --> 00:36:52,800
i think it's going to be a big one and

00:36:51,200 --> 00:36:54,960
then on the top

00:36:52,800 --> 00:36:56,560
stack on top of the stack we're going to

00:36:54,960 --> 00:37:00,240
see a lot of changes i think in

00:36:56,560 --> 00:37:01,440
virtualization and and containerization

00:37:00,240 --> 00:37:03,040
and sandboxing

00:37:01,440 --> 00:37:05,359
um i think we're going to move up a

00:37:03,040 --> 00:37:08,720
little bit we're going to go back to

00:37:05,359 --> 00:37:10,800
uh runtime sandboxes so if

00:37:08,720 --> 00:37:12,079
we actually had this 10-15 years ago

00:37:10,800 --> 00:37:14,400
with java but didn't

00:37:12,079 --> 00:37:15,440
take because it was probably too early

00:37:14,400 --> 00:37:16,960
but now with

00:37:15,440 --> 00:37:18,960
webassembly i think it's going to be

00:37:16,960 --> 00:37:21,520
back because it actually makes

00:37:18,960 --> 00:37:22,800
more sense if you're providing a lambda

00:37:21,520 --> 00:37:24,720
like service

00:37:22,800 --> 00:37:26,560
um it actually makes more sense to build

00:37:24,720 --> 00:37:28,560
around uh web assembly

00:37:26,560 --> 00:37:30,400
than it does to build around the docker

00:37:28,560 --> 00:37:33,520
containers and their api

00:37:30,400 --> 00:37:34,240
so i think like five years into the

00:37:33,520 --> 00:37:35,599
future

00:37:34,240 --> 00:37:37,359
i think web assembly is going to be the

00:37:35,599 --> 00:37:40,000
thing

00:37:37,359 --> 00:37:41,680
that's interesting thanks a lot that was

00:37:40,000 --> 00:37:43,839
a great uh great talk

00:37:41,680 --> 00:37:45,040
and uh for all our listeners avisha is

00:37:43,839 --> 00:37:46,480
still with us so

00:37:45,040 --> 00:37:48,880
if you have more questions that you want

00:37:46,480 --> 00:37:52,240
to uh fire out of this side then

00:37:48,880 --> 00:37:53,280
go ahead and discord and i'm sure that

00:37:52,240 --> 00:37:55,280
the discussion will

00:37:53,280 --> 00:37:56,560
carry on there thanks a lot avishai for

00:37:55,280 --> 00:38:04,160
joining us

00:37:56,560 --> 00:38:04,160

YouTube URL: https://www.youtube.com/watch?v=Ci7O-AyXOhI


