Title: Deploy and Destroy: Testing Environments - Michael Arenzon - DevOpsDays Tel Aviv 2018
Publication date: 2019-01-03
Playlist: DevOpsDays Tel Aviv 2018
Description: 
	One of the critical factors for development velocity is software correctness. Our ability to develop and ship new features fast is bounded by our ability to validate several aspects of the change: * Does the feature meet the requirements? * How does the feature affect existing code, and how can it affect the production environment? With continues codebase growth and new features being added, naturally our productivity decreases, and our need to improve the guarantees for quality and correctness increase.

In this talk, I’ll focus on testing environments: why developers need a self-serve platform to create a full functioning environment on-demand, how such environments should be managed, and how can one restore part of the lost velocity. I’ll cover an internal system we use at AppsFlyer called ‘Namespaces’ that addresses the issue with the help of Mesos / Marathon, Docker, Traefik, and Consul.
Captions: 
	00:00:05,359 --> 00:00:09,750
my name is Micah and I gonna talk today

00:00:08,160 --> 00:00:12,900
about deploying destroy testing

00:00:09,750 --> 00:00:15,719
environments the origin of these title

00:00:12,900 --> 00:00:18,150
comes from years ago when a friend tried

00:00:15,719 --> 00:00:20,100
to capture a sushi plate and I fought a

00:00:18,150 --> 00:00:22,590
bump with his shirt of deploying destroy

00:00:20,100 --> 00:00:26,340
so then I decided that I have to invent

00:00:22,590 --> 00:00:28,680
some talk two years that I do and a bit

00:00:26,340 --> 00:00:30,960
of up slow we're a leading mobile

00:00:28,680 --> 00:00:33,000
tribution company who helped upmarket

00:00:30,960 --> 00:00:35,190
used to understand how to spend their

00:00:33,000 --> 00:00:38,010
budget but let's look a bit at the

00:00:35,190 --> 00:00:39,960
numbers we around 120 people and we are

00:00:38,010 --> 00:00:42,239
ending we have hundreds of

00:00:39,960 --> 00:00:44,850
micro-services thousands of servers and

00:00:42,239 --> 00:00:48,510
were handling around 80 billion events a

00:00:44,850 --> 00:00:52,140
day means that we quite a huge scale and

00:00:48,510 --> 00:00:54,329
when it's on how to maintain it and like

00:00:52,140 --> 00:00:56,730
every other company with a growth of the

00:00:54,329 --> 00:00:59,850
R&D with a graph of your codebase the

00:00:56,730 --> 00:01:01,649
velocity is going down at first you say

00:00:59,850 --> 00:01:05,309
okay maybe I need to improve something

00:01:01,649 --> 00:01:08,729
maybe add tools maybe add some tests can

00:01:05,309 --> 00:01:11,430
we see some small jump the velocity then

00:01:08,729 --> 00:01:13,920
maybe we are lacking of documentation we

00:01:11,430 --> 00:01:16,350
are lacking of a guidance for a new

00:01:13,920 --> 00:01:19,470
employees to understand how to develop

00:01:16,350 --> 00:01:21,450
and how to work in the system and then

00:01:19,470 --> 00:01:23,549
someone says yeah let's do micro

00:01:21,450 --> 00:01:27,450
services all the way down and the

00:01:23,549 --> 00:01:29,820
velocity even go slower and someone says

00:01:27,450 --> 00:01:33,150
yeah sure let's add CI let's pipelines

00:01:29,820 --> 00:01:35,909
etc etc which is oh nice and I try to

00:01:33,150 --> 00:01:38,430
show how we can increase it a bit more

00:01:35,909 --> 00:01:41,850
with dynamic dev and testing

00:01:38,430 --> 00:01:43,829
environments so in the spectrum of test

00:01:41,850 --> 00:01:46,920
pyramid which tries to describe some

00:01:43,829 --> 00:01:48,659
model of cost value in terms of unit

00:01:46,920 --> 00:01:50,759
tests are the cheapest and have the

00:01:48,659 --> 00:01:53,820
highest value of our go test is harder

00:01:50,759 --> 00:01:57,000
to implement but also have a value my

00:01:53,820 --> 00:01:59,250
talk would be around here we try to see

00:01:57,000 --> 00:02:03,090
how we can leverage the integration test

00:01:59,250 --> 00:02:03,719
and Greta's with such system where it

00:02:03,090 --> 00:02:06,600
all begins

00:02:03,719 --> 00:02:09,060
so the classic model is free

00:02:06,600 --> 00:02:12,000
environments of development which can be

00:02:09,060 --> 00:02:13,650
either local or remote then we have the

00:02:12,000 --> 00:02:16,290
staging or the testing

00:02:13,650 --> 00:02:18,329
which are usually static once we push

00:02:16,290 --> 00:02:20,970
our code and we want to make sure that

00:02:18,329 --> 00:02:23,430
our code is good enough before deploying

00:02:20,970 --> 00:02:26,610
to production we usually deploy to some

00:02:23,430 --> 00:02:28,769
test staging environment and if and if

00:02:26,610 --> 00:02:32,340
everything goes right we deploy to

00:02:28,769 --> 00:02:35,280
production but it's quite good it's

00:02:32,340 --> 00:02:36,709
better than nothing so sure Devin test

00:02:35,280 --> 00:02:40,650
environments are easy to maintain

00:02:36,709 --> 00:02:42,810
usually they have low overhead and you

00:02:40,650 --> 00:02:45,840
have a free dependencies right if you

00:02:42,810 --> 00:02:47,250
have to hundreds micro-services 300 you

00:02:45,840 --> 00:02:49,200
shouldn't really care about your

00:02:47,250 --> 00:02:51,780
dependency deployments you just have

00:02:49,200 --> 00:02:53,549
them inside that environment and it's

00:02:51,780 --> 00:02:55,379
similar to production for those

00:02:53,549 --> 00:02:57,840
developers that are keep using Windows

00:02:55,379 --> 00:03:00,000
for their development at least we see

00:02:57,840 --> 00:03:02,879
how their code is running on the same

00:03:00,000 --> 00:03:05,370
platform as the production but it has

00:03:02,879 --> 00:03:07,859
some trade-offs first one is fuzzy

00:03:05,370 --> 00:03:10,500
version control means that we never know

00:03:07,859 --> 00:03:12,840
actually what of what is the versions

00:03:10,500 --> 00:03:15,510
which is the code running in the shared

00:03:12,840 --> 00:03:18,180
environment maybe I deploy today my code

00:03:15,510 --> 00:03:19,949
to the test environment but later on to

00:03:18,180 --> 00:03:22,829
how software some other teammate

00:03:19,949 --> 00:03:24,739
deployed changes I can never be sure

00:03:22,829 --> 00:03:27,299
what's running in that environment

00:03:24,739 --> 00:03:29,639
stability who's actually responsible for

00:03:27,299 --> 00:03:31,980
that environment what happens if it

00:03:29,639 --> 00:03:34,349
fells down does the dev ops handle it as

00:03:31,980 --> 00:03:37,409
the developers it's never clear the

00:03:34,349 --> 00:03:40,129
boundaries of the responsibility shirts

00:03:37,409 --> 00:03:43,169
date and mutability is probably the main

00:03:40,129 --> 00:03:44,819
concerns you have a show database you

00:03:43,169 --> 00:03:46,979
have a shirt state across your

00:03:44,819 --> 00:03:49,440
development across your state the

00:03:46,979 --> 00:03:52,889
chances you collision with other tests

00:03:49,440 --> 00:03:55,530
is quite huge and usually I heard many

00:03:52,889 --> 00:03:58,049
people that updated their schema edits

00:03:55,530 --> 00:03:59,970
from your database and someone else just

00:03:58,049 --> 00:04:03,629
change it because it wasn't good enough

00:03:59,970 --> 00:04:06,540
for data's so it's so fuzzy and I'm

00:04:03,629 --> 00:04:09,870
leading to the next point of let's treat

00:04:06,540 --> 00:04:12,060
it as a CAD or not as parts dev and test

00:04:09,870 --> 00:04:14,489
environment shouldn't be something like

00:04:12,060 --> 00:04:16,799
snowflake that we need to maintain and

00:04:14,489 --> 00:04:18,599
make sure it healthy test and dev

00:04:16,799 --> 00:04:21,570
environment should be something that is

00:04:18,599 --> 00:04:24,779
easy to create easy to reproduce in easy

00:04:21,570 --> 00:04:27,240
to maintain and I try to figure it

00:04:24,779 --> 00:04:31,229
myself what are the key principles

00:04:27,240 --> 00:04:34,110
to have such two and I reduce it to four

00:04:31,229 --> 00:04:37,699
main points definition interaction

00:04:34,110 --> 00:04:40,229
safety and usability the first one

00:04:37,699 --> 00:04:42,419
trying to describe environment as a

00:04:40,229 --> 00:04:44,669
human-readable schema it should have

00:04:42,419 --> 00:04:47,370
been something that existing it should

00:04:44,669 --> 00:04:49,710
be something that we can describe in

00:04:47,370 --> 00:04:54,090
words in something that every person

00:04:49,710 --> 00:04:55,949
every technical person can understand we

00:04:54,090 --> 00:05:00,030
want the interaction with the system to

00:04:55,949 --> 00:05:03,300
be via API UI and CLI are enhancements

00:05:00,030 --> 00:05:06,599
or something that helps but they're not

00:05:03,300 --> 00:05:09,690
the core of the product API should be

00:05:06,599 --> 00:05:11,940
our enabling to create and maintain the

00:05:09,690 --> 00:05:15,120
environments and everything should be

00:05:11,940 --> 00:05:17,479
via API that leads to a self self

00:05:15,120 --> 00:05:21,270
platform which which were aiming to

00:05:17,479 --> 00:05:23,430
safety isolation obviously we don't want

00:05:21,270 --> 00:05:25,590
different environments to interact with

00:05:23,430 --> 00:05:27,479
each other especially we don't want the

00:05:25,590 --> 00:05:30,330
production environment to speak with the

00:05:27,479 --> 00:05:33,590
test environments or vice versa so

00:05:30,330 --> 00:05:36,539
isolation is the key to safeness and

00:05:33,590 --> 00:05:39,330
composable what I mean by composable is

00:05:36,539 --> 00:05:41,360
that this to of creation should be a

00:05:39,330 --> 00:05:44,639
building block should be something that

00:05:41,360 --> 00:05:48,419
every person at the company can use to

00:05:44,639 --> 00:05:50,849
leverage in their own systems and that's

00:05:48,419 --> 00:05:53,729
why we created namespace it's an

00:05:50,849 --> 00:05:56,849
internal system at UPS layer which helps

00:05:53,729 --> 00:05:58,620
people to create a testing environments

00:05:56,849 --> 00:06:01,710
without dealing with the infrastructure

00:05:58,620 --> 00:06:04,440
what do I mean by that the key features

00:06:01,710 --> 00:06:07,319
of the system is the environment is a

00:06:04,440 --> 00:06:09,330
JSON file or they just create a schema

00:06:07,319 --> 00:06:12,449
that describes how the environment is

00:06:09,330 --> 00:06:15,389
look like it's fully self-serve we are

00:06:12,449 --> 00:06:17,250
we have api's for everything to maintain

00:06:15,389 --> 00:06:20,849
the environment whether it's creation

00:06:17,250 --> 00:06:23,490
updation and delete we have isolation

00:06:20,849 --> 00:06:25,469
between environments none of the

00:06:23,490 --> 00:06:28,860
environments are interacting with other

00:06:25,469 --> 00:06:30,900
ones so we provide safeness and the most

00:06:28,860 --> 00:06:33,030
important it's a building block and I'll

00:06:30,900 --> 00:06:35,969
show later in this talk how we leverage

00:06:33,030 --> 00:06:38,669
that system it's based on two main

00:06:35,969 --> 00:06:39,849
concept services and resources every

00:06:38,669 --> 00:06:42,459
environment

00:06:39,849 --> 00:06:44,379
a set of dependencies by dependencies I

00:06:42,459 --> 00:06:46,809
mean we have our own code which is

00:06:44,379 --> 00:06:49,270
usually our services and we have our

00:06:46,809 --> 00:06:51,520
back ends which can be my sequel Kafka

00:06:49,270 --> 00:06:54,399
any database any queue anything that you

00:06:51,520 --> 00:06:56,800
need to be part as your environment so

00:06:54,399 --> 00:07:00,369
we separate those both as part of the

00:06:56,800 --> 00:07:04,119
Declaration of the environment the main

00:07:00,369 --> 00:07:06,550
technologies we used in in namespaces is

00:07:04,119 --> 00:07:08,770
metal smart on docker traffic and

00:07:06,550 --> 00:07:10,749
console where the first layer is the

00:07:08,770 --> 00:07:12,490
orchestration layer medicine marathon

00:07:10,749 --> 00:07:14,649
for those who are not familiar is

00:07:12,490 --> 00:07:17,679
similar to kubernetes in terms of

00:07:14,649 --> 00:07:20,830
orchestration platform and we're using

00:07:17,679 --> 00:07:22,839
traffic which is dynamic proxy similar

00:07:20,830 --> 00:07:25,019
to H epoxy for those who familiar and

00:07:22,839 --> 00:07:28,029
consul for the service discovery and

00:07:25,019 --> 00:07:31,059
communication with those technologies we

00:07:28,029 --> 00:07:34,509
managed to create dynamic environment

00:07:31,059 --> 00:07:36,429
creation so remember the key principles

00:07:34,509 --> 00:07:40,269
I just stopped before let's see how we

00:07:36,429 --> 00:07:42,249
apply them to a namespace so how a

00:07:40,269 --> 00:07:45,550
namespace definition how a namespace

00:07:42,249 --> 00:07:48,519
schema looks like the first attributes

00:07:45,550 --> 00:07:50,769
is namespace name environment type and

00:07:48,519 --> 00:07:54,789
global environment variables as you can

00:07:50,769 --> 00:07:58,240
see I emphasize namespace and F type for

00:07:54,789 --> 00:08:01,269
purpose usually environments have their

00:07:58,240 --> 00:08:02,769
own scope their own definition if I have

00:08:01,269 --> 00:08:05,349
a test environment

00:08:02,769 --> 00:08:08,050
I want the test config to get up if I

00:08:05,349 --> 00:08:09,759
have a dev environment and what did they

00:08:08,050 --> 00:08:11,919
have configured to be up we have

00:08:09,759 --> 00:08:14,829
different set of configuration and

00:08:11,919 --> 00:08:16,990
attributes or the way the runtime works

00:08:14,829 --> 00:08:19,899
in different types of environments but

00:08:16,990 --> 00:08:21,849
that does mean doesn't mean what's the

00:08:19,899 --> 00:08:24,819
scope what's the name of the environment

00:08:21,849 --> 00:08:26,829
so if I'm developer one and there's

00:08:24,819 --> 00:08:29,129
another developer in my team and we want

00:08:26,829 --> 00:08:31,929
both to test the same system in tests

00:08:29,129 --> 00:08:35,139
say that the environment type is test

00:08:31,929 --> 00:08:37,389
but my namespace will be Michael and his

00:08:35,139 --> 00:08:39,099
namespace would be your CEO or some

00:08:37,389 --> 00:08:42,099
other name we have a full separation

00:08:39,099 --> 00:08:45,279
between the environment with exactly the

00:08:42,099 --> 00:08:47,079
same behavior and then we have the

00:08:45,279 --> 00:08:48,730
environment variables which we can

00:08:47,079 --> 00:08:50,949
inject environment variables and

00:08:48,730 --> 00:08:53,740
override configuration or other stuff if

00:08:50,949 --> 00:08:55,480
you want we have the service details

00:08:53,740 --> 00:08:57,370
that's the way how we describe with

00:08:55,480 --> 00:09:00,520
services we want to have as part of the

00:08:57,370 --> 00:09:01,930
environment so we have the ID image and

00:09:00,520 --> 00:09:04,990
common details which are explained a bit

00:09:01,930 --> 00:09:07,209
later the ID is the unique identifier of

00:09:04,990 --> 00:09:09,850
the service of that up in the

00:09:07,209 --> 00:09:12,370
environment ID helps us to communicate

00:09:09,850 --> 00:09:15,399
and distinguish between different apps

00:09:12,370 --> 00:09:18,100
in the environment image is the spec of

00:09:15,399 --> 00:09:20,440
how we describe which application do we

00:09:18,100 --> 00:09:22,839
even want so it can be the service name

00:09:20,440 --> 00:09:25,180
and the version and then we have the

00:09:22,839 --> 00:09:27,339
resource details it's a separate part

00:09:25,180 --> 00:09:29,800
that defines what are the resources we

00:09:27,339 --> 00:09:31,300
want as part of the environment you can

00:09:29,800 --> 00:09:33,970
see the difference here that here we

00:09:31,300 --> 00:09:36,880
just asked for name rather therefore an

00:09:33,970 --> 00:09:39,070
image we ask for a name because we try

00:09:36,880 --> 00:09:41,680
to simply find a new credit pool of

00:09:39,070 --> 00:09:44,200
resources behind so name is actual

00:09:41,680 --> 00:09:47,350
reference to a predefined resource where

00:09:44,200 --> 00:09:50,589
it's my sequel Kafka any any third party

00:09:47,350 --> 00:09:53,320
you're using and lastly the common

00:09:50,589 --> 00:09:55,660
details which are the explanation of how

00:09:53,320 --> 00:09:59,170
the application behaves and what it

00:09:55,660 --> 00:10:02,140
requires so we have obviously the port

00:09:59,170 --> 00:10:04,209
that the app or the resource expose we

00:10:02,140 --> 00:10:06,820
have the amounts of CPU and memory we

00:10:04,209 --> 00:10:08,560
need for that application to run we have

00:10:06,820 --> 00:10:11,110
the health check definition to explain

00:10:08,560 --> 00:10:13,360
even whether the application is healthy

00:10:11,110 --> 00:10:16,420
or not does the deployment word well or

00:10:13,360 --> 00:10:18,250
not and we have ability to override the

00:10:16,420 --> 00:10:21,399
environment variable per specific

00:10:18,250 --> 00:10:23,920
resource or up another thing about the

00:10:21,399 --> 00:10:26,709
resource and the service separation the

00:10:23,920 --> 00:10:29,050
reason we separate between those is two

00:10:26,709 --> 00:10:32,079
things first so you can actually see

00:10:29,050 --> 00:10:35,260
inside your JSON your services and your

00:10:32,079 --> 00:10:38,529
backends for clarity and second thing is

00:10:35,260 --> 00:10:41,200
to create deployment dependencies

00:10:38,529 --> 00:10:44,170
usually we want our resources to be up

00:10:41,200 --> 00:10:46,209
first and then the services that's how

00:10:44,170 --> 00:10:48,459
we provide a guarantee that first the

00:10:46,209 --> 00:10:51,510
resources will be deployed and run and

00:10:48,459 --> 00:10:54,790
then the service is gonna be deployed

00:10:51,510 --> 00:10:57,970
let's look how it actually looks in real

00:10:54,790 --> 00:11:01,300
life JSON so we have a namespace called

00:10:57,970 --> 00:11:04,089
DevOps laziness and with one environment

00:11:01,300 --> 00:11:06,990
verbo of conference Scalla days then we

00:11:04,089 --> 00:11:11,050
have our service hello world of

00:11:06,990 --> 00:11:13,600
by hello world name with port 8081

00:11:11,050 --> 00:11:16,540
health check I'm taking the latest

00:11:13,600 --> 00:11:18,820
version at the latest keyword it tells

00:11:16,540 --> 00:11:21,820
the system that just take the latest

00:11:18,820 --> 00:11:23,530
built version of that service and we

00:11:21,820 --> 00:11:25,870
have another environment variable which

00:11:23,530 --> 00:11:27,670
conference that overrides the previous

00:11:25,870 --> 00:11:30,880
environment variable with DevOps dates

00:11:27,670 --> 00:11:32,710
and then I added memcache because it's a

00:11:30,880 --> 00:11:34,780
high scale service and we need somehow

00:11:32,710 --> 00:11:38,290
to manage the load so we have another

00:11:34,780 --> 00:11:40,510
cache layer we managed to answer the

00:11:38,290 --> 00:11:42,520
principle of environment as a human

00:11:40,510 --> 00:11:44,980
readable schema it's something that

00:11:42,520 --> 00:11:48,910
every technical person can understand

00:11:44,980 --> 00:11:51,580
can create and can manage second thing

00:11:48,910 --> 00:11:53,740
is the IP I as I mentioned this this

00:11:51,580 --> 00:11:55,750
platform is fully self-serve and for

00:11:53,740 --> 00:11:57,880
that we need a set of API is to maintain

00:11:55,750 --> 00:12:01,060
the environment so we have the creation

00:11:57,880 --> 00:12:02,560
to read the update and the delete API we

00:12:01,060 --> 00:12:04,840
have the ability to create new

00:12:02,560 --> 00:12:07,660
environment we have the ability to read

00:12:04,840 --> 00:12:09,610
a schema of different environments if we

00:12:07,660 --> 00:12:11,290
want to fetch a configure a scheme of

00:12:09,610 --> 00:12:14,170
different environments we have the

00:12:11,290 --> 00:12:16,480
ability if we want only to change one

00:12:14,170 --> 00:12:19,390
service so one resource as part of the

00:12:16,480 --> 00:12:22,060
environment which has sent an update

00:12:19,390 --> 00:12:24,100
query we don't need to fully recreate

00:12:22,060 --> 00:12:26,520
the environment we just can update a

00:12:24,100 --> 00:12:29,500
specific scope of that environment and

00:12:26,520 --> 00:12:32,350
obviously we can delete so we fulfil

00:12:29,500 --> 00:12:34,570
here the deployment destroy constraints

00:12:32,350 --> 00:12:36,100
we mentioned and also there's another

00:12:34,570 --> 00:12:38,530
set of endpoints that I haven't

00:12:36,100 --> 00:12:42,250
mentioned like status refresh logs

00:12:38,530 --> 00:12:45,970
another helpers for the maintenance of

00:12:42,250 --> 00:12:48,370
the environment cool that's how it

00:12:45,970 --> 00:12:51,640
eventually looks for those people who

00:12:48,370 --> 00:12:54,400
are looking for UI inside of marathon we

00:12:51,640 --> 00:12:57,430
have some idea of group dependencies and

00:12:54,400 --> 00:12:59,830
marathon displays them as directories so

00:12:57,430 --> 00:13:02,410
basically when developers queue is any

00:12:59,830 --> 00:13:04,750
technical person opens marathon they

00:13:02,410 --> 00:13:07,870
just can find their environment click on

00:13:04,750 --> 00:13:11,470
the directory and see what the resources

00:13:07,870 --> 00:13:15,660
and what the services are running cool

00:13:11,470 --> 00:13:18,250
so it's fully API driven and self-serve

00:13:15,660 --> 00:13:20,499
everyone can create an environment

00:13:18,250 --> 00:13:23,289
that's really important principle

00:13:20,499 --> 00:13:25,179
for this system we don't want to

00:13:23,289 --> 00:13:27,159
maintain it we don't want to be the guys

00:13:25,179 --> 00:13:29,889
that I please create me a new

00:13:27,159 --> 00:13:32,109
environment like unusual companies when

00:13:29,889 --> 00:13:34,449
you have maybe some operations group and

00:13:32,109 --> 00:13:36,339
people come into your saying yeah please

00:13:34,449 --> 00:13:40,329
bring me a new environment no I want it

00:13:36,339 --> 00:13:42,099
to be fully self so let's take a look a

00:13:40,329 --> 00:13:44,559
bit about the communication and service

00:13:42,099 --> 00:13:46,719
discovery inside that environment so as

00:13:44,559 --> 00:13:49,629
I mentioned we have a two main fields

00:13:46,719 --> 00:13:51,639
the namespace name which distinguish

00:13:49,629 --> 00:13:54,129
between different environments and you

00:13:51,639 --> 00:13:56,469
have the ID which describes the unique

00:13:54,129 --> 00:13:59,279
identifier of that up we take it

00:13:56,469 --> 00:14:03,819
together and compose it to a URL code

00:13:59,279 --> 00:14:06,879
the namespace dot ID dot suffix of

00:14:03,819 --> 00:14:09,549
absolute calm domain that's the way we

00:14:06,879 --> 00:14:13,239
create a service discovery for every

00:14:09,549 --> 00:14:16,799
environment we create fqdn that resolves

00:14:13,239 --> 00:14:19,689
to that specific environment internally

00:14:16,799 --> 00:14:23,049
although C names are resolving to only

00:14:19,689 --> 00:14:25,419
one server which is the proxy behind

00:14:23,049 --> 00:14:27,639
that environment so with every

00:14:25,419 --> 00:14:30,309
environment we deployed the traffic

00:14:27,639 --> 00:14:32,649
proxy I mentioned before and traffic is

00:14:30,309 --> 00:14:35,199
a ingress controller is a part that

00:14:32,649 --> 00:14:38,439
maintains the entrance that environment

00:14:35,199 --> 00:14:41,499
and the routing inside all the C names

00:14:38,439 --> 00:14:43,269
of the services are resolving to that

00:14:41,499 --> 00:14:49,239
proxy is that clear

00:14:43,269 --> 00:14:51,369
good so how we can make sure that the

00:14:49,239 --> 00:14:54,189
services and the resources actually

00:14:51,369 --> 00:14:56,859
communicate with the dependencies inside

00:14:54,189 --> 00:14:59,769
the environment we're using resolve

00:14:56,859 --> 00:15:02,979
confirm that that's the magic we just

00:14:59,769 --> 00:15:05,349
add domain search as part of every

00:15:02,979 --> 00:15:08,709
container which says always try to

00:15:05,349 --> 00:15:11,529
resolve the C names inside your own

00:15:08,709 --> 00:15:14,439
scope we can see in this example that

00:15:11,529 --> 00:15:16,869
we're just using short names for the

00:15:14,439 --> 00:15:20,619
communication it's enough to write the

00:15:16,869 --> 00:15:24,069
ID as your cname to find it internally

00:15:20,619 --> 00:15:26,379
it will be resolved to the fqdn of it so

00:15:24,069 --> 00:15:28,869
if we had the helo a hello world service

00:15:26,379 --> 00:15:31,659
and we just try to Carol it inside the

00:15:28,869 --> 00:15:33,800
environment it will be expanded to hello

00:15:31,659 --> 00:15:36,139
world the DevOps SNS

00:15:33,800 --> 00:15:37,730
dot observe that comes suffix if you

00:15:36,139 --> 00:15:42,470
want to communicate with the memcached

00:15:37,730 --> 00:15:43,699
we created before exactly same way what

00:15:42,470 --> 00:15:45,470
happens if you want to talk with

00:15:43,699 --> 00:15:49,040
different environments with production

00:15:45,470 --> 00:15:51,559
or with different namespaces we just add

00:15:49,040 --> 00:15:55,429
the suffix of the environment that's the

00:15:51,559 --> 00:15:57,470
way we can explicitly tell that we want

00:15:55,429 --> 00:16:00,019
to communicate with different parts of

00:15:57,470 --> 00:16:02,239
the system that are not part of our

00:16:00,019 --> 00:16:05,439
namespace that are not part of our

00:16:02,239 --> 00:16:07,759
environment this also helped us to

00:16:05,439 --> 00:16:09,949
understand configuration and see when

00:16:07,759 --> 00:16:11,720
people communicating inside the

00:16:09,949 --> 00:16:13,549
environment and when they want to

00:16:11,720 --> 00:16:15,939
communicate outside of the environment

00:16:13,549 --> 00:16:19,850
it's really explicit and and

00:16:15,939 --> 00:16:22,850
understandable cool so for those

00:16:19,850 --> 00:16:25,369
familiar with kubernetes days this kind

00:16:22,850 --> 00:16:27,949
of reassess the service mode of

00:16:25,369 --> 00:16:31,939
kubernetes for some reason they steal

00:16:27,949 --> 00:16:35,059
our ideas ideas how to do that but you

00:16:31,939 --> 00:16:38,839
know it's open source essentially so we

00:16:35,059 --> 00:16:41,299
achieved isolation but not really the

00:16:38,839 --> 00:16:43,850
isolation is the inner space means that

00:16:41,299 --> 00:16:46,069
eventually if someone wants to refer to

00:16:43,850 --> 00:16:50,029
a production resource they still have

00:16:46,069 --> 00:16:52,939
the ability so we decided to go for the

00:16:50,029 --> 00:16:56,209
DNS Convention for two parts first one

00:16:52,939 --> 00:16:58,309
if would block the network with block

00:16:56,209 --> 00:17:02,269
the VP's internally for every

00:16:58,309 --> 00:17:04,370
environment the system would be bad like

00:17:02,269 --> 00:17:06,289
I am a new developer and I want to

00:17:04,370 --> 00:17:08,689
create a new environment usually I don't

00:17:06,289 --> 00:17:10,370
even know what all my dependencies so I

00:17:08,689 --> 00:17:12,980
want to discover them and I need to

00:17:10,370 --> 00:17:15,319
start from some point if I block all the

00:17:12,980 --> 00:17:17,029
communication outside the first

00:17:15,319 --> 00:17:19,419
bootstrap the first creation of the

00:17:17,029 --> 00:17:22,189
environment would be quite hard and

00:17:19,419 --> 00:17:23,959
second reason is that sometimes we do

00:17:22,189 --> 00:17:27,319
want to communicate with outside

00:17:23,959 --> 00:17:29,899
resources to solve that in next next

00:17:27,319 --> 00:17:32,179
versions will allow to send an attribute

00:17:29,899 --> 00:17:34,700
saying do you want to have isolated

00:17:32,179 --> 00:17:37,309
network or not that's the way we do

00:17:34,700 --> 00:17:39,889
support people that do not want in any

00:17:37,309 --> 00:17:42,500
manner in any matter to communicate with

00:17:39,889 --> 00:17:44,720
production and for people who still want

00:17:42,500 --> 00:17:47,460
to communicate with other environments

00:17:44,720 --> 00:17:50,070
at the outside of the testing scope

00:17:47,460 --> 00:17:54,919
can do that it's the choice of the

00:17:50,070 --> 00:17:58,250
environment creation owner composability

00:17:54,919 --> 00:18:01,320
that's a real life example of

00:17:58,250 --> 00:18:03,270
integration of that system to our gitlab

00:18:01,320 --> 00:18:06,149
system gitlab is our version control

00:18:03,270 --> 00:18:07,860
system and we are doing merge request or

00:18:06,149 --> 00:18:09,750
pull request for every change we are

00:18:07,860 --> 00:18:12,720
doing in our code bases in our services

00:18:09,750 --> 00:18:15,390
so here's an example of one of the

00:18:12,720 --> 00:18:17,460
developers that created a new branch a

00:18:15,390 --> 00:18:20,850
new metric as pull requests with a

00:18:17,460 --> 00:18:23,730
change with a bug fix and get labs sent

00:18:20,850 --> 00:18:27,120
a request to our system to create a new

00:18:23,730 --> 00:18:30,149
environment we can see that they have

00:18:27,120 --> 00:18:32,820
its own private environment with these

00:18:30,149 --> 00:18:35,880
changes which is cool if I want to check

00:18:32,820 --> 00:18:38,490
his changes especially if the service is

00:18:35,880 --> 00:18:41,100
UI based I can easily go to that merge

00:18:38,490 --> 00:18:43,140
request open that link go to the

00:18:41,100 --> 00:18:45,360
environment and see the changes lively

00:18:43,140 --> 00:18:49,230
before merging it to the code base

00:18:45,360 --> 00:18:51,539
before marie-jeanne to production its

00:18:49,230 --> 00:18:53,850
API driven by design as I mentioned we

00:18:51,539 --> 00:18:56,610
can use it anywhere we want if it's part

00:18:53,850 --> 00:18:59,220
of our CI or CD pipelines if it's part

00:18:56,610 --> 00:19:01,289
of our selenium or UI builds if it's

00:18:59,220 --> 00:19:04,230
part of any scheduled jobs you have the

00:19:01,289 --> 00:19:06,720
full control to to choose in which

00:19:04,230 --> 00:19:09,570
lifecycle you want to use the system

00:19:06,720 --> 00:19:14,010
you're fully owning the lifecycle of

00:19:09,570 --> 00:19:17,640
your environment composable which is

00:19:14,010 --> 00:19:19,590
good but so good that nice right I'm

00:19:17,640 --> 00:19:22,140
just telling such a good things it's

00:19:19,590 --> 00:19:24,570
composable it's safe it's nice but it's

00:19:22,140 --> 00:19:27,419
never like that and implemented the

00:19:24,570 --> 00:19:29,880
system was quite hard we had tons of

00:19:27,419 --> 00:19:31,980
production and other issues that we

00:19:29,880 --> 00:19:35,399
tried to solve the first one and

00:19:31,980 --> 00:19:37,890
obviously is docker we have around 1 2 3

00:19:35,399 --> 00:19:40,380
4 bucks all those are real bugs of

00:19:37,890 --> 00:19:42,809
docker that we had in production I think

00:19:40,380 --> 00:19:46,409
we had different 5 versions of docker

00:19:42,809 --> 00:19:50,130
and every single one of them had bug

00:19:46,409 --> 00:19:52,890
critical bug we managed to overcome that

00:19:50,130 --> 00:19:56,700
buying some utilities that are sitting

00:19:52,890 --> 00:19:58,679
on the notes and just fixing those

00:19:56,700 --> 00:20:01,200
doctor bugs I can explain it offline

00:19:58,679 --> 00:20:03,149
because it's not the nicest fixes by

00:20:01,200 --> 00:20:07,049
it helps to work with dog hair in our

00:20:03,149 --> 00:20:10,320
workload infrastructure utilization was

00:20:07,049 --> 00:20:12,600
also concerned the first design we try

00:20:10,320 --> 00:20:15,600
to figure out whether do we want to

00:20:12,600 --> 00:20:17,760
spawn up a new instances for every

00:20:15,600 --> 00:20:20,039
environment or do we want to have a

00:20:17,760 --> 00:20:22,649
common pool of instances and leverage

00:20:20,039 --> 00:20:24,389
them eventually we choose masters and

00:20:22,649 --> 00:20:28,230
marathon that are working on a

00:20:24,389 --> 00:20:31,350
predefined pool of resources so this

00:20:28,230 --> 00:20:34,260
picture was taking a few days ago and we

00:20:31,350 --> 00:20:36,840
can see that with as sixty agents or

00:20:34,260 --> 00:20:41,399
with 60 worker nodes we're running

00:20:36,840 --> 00:20:43,830
around 612 containers for over 55

00:20:41,399 --> 00:20:46,559
different environments and the

00:20:43,830 --> 00:20:48,480
utilization is quite nice you can see

00:20:46,559 --> 00:20:52,080
that the most of the utilization is

00:20:48,480 --> 00:20:54,840
murmuring because usually people when

00:20:52,080 --> 00:20:57,450
they deploy the application they need

00:20:54,840 --> 00:21:00,630
more memory of memo exception or other

00:20:57,450 --> 00:21:02,970
problems CP is usually a compressible

00:21:00,630 --> 00:21:04,139
resource so nobody really cares in the

00:21:02,970 --> 00:21:06,929
test environment

00:21:04,139 --> 00:21:09,750
if the request takes a bit longer they

00:21:06,929 --> 00:21:13,950
just care that it won't fail in the test

00:21:09,750 --> 00:21:16,139
environment service discovery was also a

00:21:13,950 --> 00:21:19,200
tough part so as I mentioned using

00:21:16,139 --> 00:21:21,809
Martin and Martin provides us event bus

00:21:19,200 --> 00:21:23,580
which we can subscribe and get all the

00:21:21,809 --> 00:21:26,940
events of the deployments of that

00:21:23,580 --> 00:21:29,639
environment we found out that sometimes

00:21:26,940 --> 00:21:33,419
we have delayed messages and even losing

00:21:29,639 --> 00:21:37,799
messages so we overcome that issue with

00:21:33,419 --> 00:21:40,440
another tool that sinks marathon - your

00:21:37,799 --> 00:21:42,690
environment so is as I mentioned inside

00:21:40,440 --> 00:21:44,519
every environment we have the proxy that

00:21:42,690 --> 00:21:46,440
helps in the discovery in the

00:21:44,519 --> 00:21:49,049
communication inside the environment and

00:21:46,440 --> 00:21:51,990
we have this tool that helps to sync

00:21:49,049 --> 00:21:54,960
periodically against Murdoch that's the

00:21:51,990 --> 00:21:58,590
way we avoid inconsistencies inside the

00:21:54,960 --> 00:22:01,139
environment data replication which is

00:21:58,590 --> 00:22:03,570
also a tough issue usually when we

00:22:01,139 --> 00:22:06,809
create test environment we want to have

00:22:03,570 --> 00:22:10,260
a real life data at least a subset of it

00:22:06,809 --> 00:22:13,289
and for that we went with the design of

00:22:10,260 --> 00:22:15,030
let's delegated to the data owners we

00:22:13,289 --> 00:22:16,560
helped them to create the replication

00:22:15,030 --> 00:22:19,290
and jobs we hold them to create the

00:22:16,560 --> 00:22:21,840
containers of their database but the

00:22:19,290 --> 00:22:24,180
ownership of the data is by the team

00:22:21,840 --> 00:22:26,340
they decide which data they want to

00:22:24,180 --> 00:22:27,780
replicate want to take the snapshot and

00:22:26,340 --> 00:22:30,270
we help them to create the

00:22:27,780 --> 00:22:32,850
infrastructure for that means that

00:22:30,270 --> 00:22:35,850
account Lee for a set of database we

00:22:32,850 --> 00:22:38,760
have a idea one hole or one daily

00:22:35,850 --> 00:22:41,310
snapshot of the data usually a subset of

00:22:38,760 --> 00:22:43,620
the data it starts somewhere Innisfree

00:22:41,310 --> 00:22:46,320
bucket and when people create a new

00:22:43,620 --> 00:22:49,290
environment they can just specify which

00:22:46,320 --> 00:22:51,960
snapshot version they want to take so

00:22:49,290 --> 00:22:54,510
you can actually have your own

00:22:51,960 --> 00:22:56,820
production data or a subset of it

00:22:54,510 --> 00:23:00,450
usually you want a subset of it inside

00:22:56,820 --> 00:23:03,300
your testing environment debug ability

00:23:00,450 --> 00:23:05,460
is also a problem because usually in

00:23:03,300 --> 00:23:08,250
dynamic environments people never show

00:23:05,460 --> 00:23:10,560
what happened to their service and one

00:23:08,250 --> 00:23:13,860
of the main problems is out of memory

00:23:10,560 --> 00:23:16,740
people does not well how much memory

00:23:13,860 --> 00:23:20,000
does their services actually need when

00:23:16,740 --> 00:23:23,790
we previously sat on bare metal on VP

00:23:20,000 --> 00:23:26,910
VPS instances we have usually large

00:23:23,790 --> 00:23:29,190
constraints 16 gig of memory many cores

00:23:26,910 --> 00:23:31,800
and people doesn't even know how much

00:23:29,190 --> 00:23:33,960
actually resources they need and when

00:23:31,800 --> 00:23:36,510
they started to use the system they set

00:23:33,960 --> 00:23:39,000
up yeah I think I need one Giga two gigs

00:23:36,510 --> 00:23:41,730
of memory and it never was like that

00:23:39,000 --> 00:23:44,600
some of the services had heap size of

00:23:41,730 --> 00:23:47,130
five ten gigs and they defined a

00:23:44,600 --> 00:23:49,320
constraint of one memory one gig of

00:23:47,130 --> 00:23:52,800
memory and they just had out of memory

00:23:49,320 --> 00:23:56,250
exceptions all the time it's quite worth

00:23:52,800 --> 00:23:58,890
to mention that we need somehow to make

00:23:56,250 --> 00:24:01,560
the observability of the system clear

00:23:58,890 --> 00:24:03,780
when it's somehow to expose these cells

00:24:01,560 --> 00:24:06,090
in a way that every person can

00:24:03,780 --> 00:24:09,000
understand if the container crashed on

00:24:06,090 --> 00:24:11,070
exit got 125 nobody will know what it

00:24:09,000 --> 00:24:13,140
means but if you can translate this

00:24:11,070 --> 00:24:15,750
information into some line that cells

00:24:13,140 --> 00:24:17,850
here your services quash because out out

00:24:15,750 --> 00:24:20,490
of memory it's something that everyone

00:24:17,850 --> 00:24:23,820
can understand and use to fix the

00:24:20,490 --> 00:24:26,370
environment stability is also a point

00:24:23,820 --> 00:24:27,930
when my environment is not up or not

00:24:26,370 --> 00:24:28,410
running whose fault is that

00:24:27,930 --> 00:24:30,690
is

00:24:28,410 --> 00:24:32,700
platform fault or developers of a

00:24:30,690 --> 00:24:35,310
technical personal fault

00:24:32,700 --> 00:24:38,430
so again usually it's out of memory bugs

00:24:35,310 --> 00:24:41,100
and observability is a way to explain

00:24:38,430 --> 00:24:44,760
where the issues happen whether it's on

00:24:41,100 --> 00:24:46,560
outside or on their side logs metrics

00:24:44,760 --> 00:24:51,030
yes please do that

00:24:46,560 --> 00:24:52,950
and Lasky is that essentially what I

00:24:51,030 --> 00:24:56,240
described to you is another deployment

00:24:52,950 --> 00:24:59,760
tool and you need to consider that it's

00:24:56,240 --> 00:25:02,010
in terms of deployment we don't want to

00:24:59,760 --> 00:25:03,870
have the same principles we're doing in

00:25:02,010 --> 00:25:06,060
production we don't want to have

00:25:03,870 --> 00:25:07,770
Bluegreen deployments we don't want to

00:25:06,060 --> 00:25:10,050
have canary deployments inside of

00:25:07,770 --> 00:25:13,530
testing environments want to get into

00:25:10,050 --> 00:25:15,960
the point as fast as we can so ideally

00:25:13,530 --> 00:25:18,360
we want to leverage our deployment

00:25:15,960 --> 00:25:20,490
mechanism orchestration layer where

00:25:18,360 --> 00:25:22,710
let's go Burnett is Master snow model

00:25:20,490 --> 00:25:24,570
any tool you're using as your

00:25:22,710 --> 00:25:27,150
orchestration layer but the interface

00:25:24,570 --> 00:25:29,490
itself should be different you should

00:25:27,150 --> 00:25:31,620
provide a schema or something that's

00:25:29,490 --> 00:25:33,570
readable and reproducible for testing

00:25:31,620 --> 00:25:35,160
environments while for production

00:25:33,570 --> 00:25:37,470
deployments you usually want to have

00:25:35,160 --> 00:25:39,600
strong pipelines that are testing it

00:25:37,470 --> 00:25:42,390
validating your changes before deploying

00:25:39,600 --> 00:25:45,810
to the production it's different

00:25:42,390 --> 00:25:48,780
concerns different aspects and ideally

00:25:45,810 --> 00:25:53,700
we do want to etch one system that

00:25:48,780 --> 00:25:56,130
manages some resources in production my

00:25:53,700 --> 00:25:59,430
two cents from all this projects it's a

00:25:56,130 --> 00:26:02,060
product like it's not another devops hog

00:25:59,430 --> 00:26:05,100
or - it's a product for anything

00:26:02,060 --> 00:26:08,010
developers are using it yours of using

00:26:05,100 --> 00:26:09,960
people rely on that system you should

00:26:08,010 --> 00:26:10,830
provide metrics you should provide a

00:26:09,960 --> 00:26:12,750
nice API

00:26:10,830 --> 00:26:14,670
you should communicate with bugs you

00:26:12,750 --> 00:26:16,830
should treat it like any other product

00:26:14,670 --> 00:26:19,050
your company is developing and it's

00:26:16,830 --> 00:26:21,000
really important because it's the key

00:26:19,050 --> 00:26:23,040
for the success of that product if

00:26:21,000 --> 00:26:25,350
you're treating it like yeah I'll just

00:26:23,040 --> 00:26:27,600
hack some and SIBO script and I'll

00:26:25,350 --> 00:26:30,720
create an environment that's maybe fine

00:26:27,600 --> 00:26:34,560
420 developer scale 50 developer scale

00:26:30,720 --> 00:26:36,900
once you pass the 200 300 members it

00:26:34,560 --> 00:26:39,060
doesn't work people don't care about

00:26:36,900 --> 00:26:41,460
your hacks they want something nice they

00:26:39,060 --> 00:26:42,429
want some UI the one API they want the

00:26:41,460 --> 00:26:46,240
ability to create

00:26:42,429 --> 00:26:47,919
by themself the environments so to recap

00:26:46,240 --> 00:26:49,960
what we learned today static

00:26:47,919 --> 00:26:52,119
environments are good okay it's

00:26:49,960 --> 00:26:54,909
definitely better than nothing but

00:26:52,119 --> 00:26:57,249
dynamic environments is where you need

00:26:54,909 --> 00:27:00,580
to strive to is where you can actually

00:26:57,249 --> 00:27:03,490
leverage the scale simplify as much as

00:27:00,580 --> 00:27:05,409
possible so so going in the design of

00:27:03,490 --> 00:27:08,590
API driven is good

00:27:05,409 --> 00:27:11,649
you should expose all the things you can

00:27:08,590 --> 00:27:15,309
in API creation and managing should be

00:27:11,649 --> 00:27:17,919
as API the KPI for your product is

00:27:15,309 --> 00:27:19,720
developer QA happiness if they manage to

00:27:17,919 --> 00:27:22,269
create new environments if they manage

00:27:19,720 --> 00:27:25,840
to maintain them means that your work is

00:27:22,269 --> 00:27:27,970
good if you ask receive messages every

00:27:25,840 --> 00:27:29,710
day of it's not working I'm not sure how

00:27:27,970 --> 00:27:31,980
to create environment can you help me

00:27:29,710 --> 00:27:35,080
and you need to baby see the system

00:27:31,980 --> 00:27:36,039
means that somewhere in the process you

00:27:35,080 --> 00:27:40,240
missed something

00:27:36,039 --> 00:27:42,340
treat the KPI is good keep it layered so

00:27:40,240 --> 00:27:44,710
I mentioned lots of time in this talk

00:27:42,340 --> 00:27:48,100
this whole system I described is a

00:27:44,710 --> 00:27:51,399
building block I don't try to solve all

00:27:48,100 --> 00:27:54,129
the problems of testing I actually even

00:27:51,399 --> 00:27:56,200
don't know all the complex pipelines of

00:27:54,129 --> 00:27:59,230
the selenium builds what I do know that

00:27:56,200 --> 00:28:01,029
with my system they can spawn

00:27:59,230 --> 00:28:03,519
environments with the resources and

00:28:01,029 --> 00:28:05,529
services they need for their selenium

00:28:03,519 --> 00:28:07,929
pipelines I provide them the

00:28:05,529 --> 00:28:11,499
infrastructure and the components for

00:28:07,929 --> 00:28:13,659
their for their pipelines and you should

00:28:11,499 --> 00:28:16,210
shouldn't thrive to over engineered

00:28:13,659 --> 00:28:19,330
solution like some of the mention here

00:28:16,210 --> 00:28:21,460
but if you do it's fine enough it

00:28:19,330 --> 00:28:23,320
depends on the scale I do believe that

00:28:21,460 --> 00:28:26,919
building blocks are better than a

00:28:23,320 --> 00:28:28,419
full-blown solution and nobody cares

00:28:26,919 --> 00:28:30,610
about your door problems

00:28:28,419 --> 00:28:32,499
really like none of the developers came

00:28:30,610 --> 00:28:34,059
to me yeah I know it's because of the

00:28:32,499 --> 00:28:34,570
DoCoMo bug you mentioned in the previous

00:28:34,059 --> 00:28:36,759
slides

00:28:34,570 --> 00:28:39,009
nobody cares they want the product to

00:28:36,759 --> 00:28:41,919
work so if you need to change your

00:28:39,009 --> 00:28:44,409
technology to hack your way to fix the

00:28:41,919 --> 00:28:47,019
code of dokyun send them apologize do

00:28:44,409 --> 00:28:48,990
everything you need nobody should be

00:28:47,019 --> 00:28:52,299
aware of your internal dependencies

00:28:48,990 --> 00:28:54,490
nobody should try to fix them for you if

00:28:52,299 --> 00:28:56,200
you have talking about it doesn't means

00:28:54,490 --> 00:28:59,620
that they need to change their

00:28:56,200 --> 00:29:02,139
to be compliant with the back and if you

00:28:59,620 --> 00:29:03,789
remember agenda I hope that after this

00:29:02,139 --> 00:29:06,669
talk you understand how such

00:29:03,789 --> 00:29:09,929
environments can increase back a beat

00:29:06,669 --> 00:29:12,430
the loss velocity that caused by growth

00:29:09,929 --> 00:29:20,290
thank you

00:29:12,430 --> 00:29:22,450
questions yeah how how long does it take

00:29:20,290 --> 00:29:25,060
I think the first version we managed to

00:29:22,450 --> 00:29:27,880
hack in two weeks just a prototype and

00:29:25,060 --> 00:29:31,360
after the whole production debugging dr.

00:29:27,880 --> 00:29:35,010
bugs etc swam I think it took us two or

00:29:31,360 --> 00:29:37,920
three months to get it to a stable phase

00:29:35,010 --> 00:29:49,030
two people work on that project

00:29:37,920 --> 00:29:51,960
yeah depends so I think the fastest

00:29:49,030 --> 00:29:55,120
environment can be spin up in one minute

00:29:51,960 --> 00:29:57,700
environments with 2030 services with a

00:29:55,120 --> 00:29:59,860
large load time can take up 10-15

00:29:57,700 --> 00:30:09,220
minutes it's really depends on your team

00:29:59,860 --> 00:30:11,050
on your dependencies yeah one of the

00:30:09,220 --> 00:30:13,720
examples is that database snapshot that

00:30:11,050 --> 00:30:16,750
I mentioned so part of the teams have

00:30:13,720 --> 00:30:18,550
quite huge databases means that only the

00:30:16,750 --> 00:30:20,740
container of the database startup time

00:30:18,550 --> 00:30:23,920
takes at least 10 minutes and what do we

00:30:20,740 --> 00:30:25,840
do nothing if the person wants to wait

00:30:23,920 --> 00:30:28,030
15 minutes that's fine enough it's his

00:30:25,840 --> 00:30:30,160
choice but if he wants to lower the time

00:30:28,030 --> 00:30:32,260
we create we can create a different

00:30:30,160 --> 00:30:34,690
solution for the database Fink

00:30:32,260 --> 00:30:36,910
we just can create a brief a pre-baked

00:30:34,690 --> 00:30:38,860
doggerel with the data insight so you

00:30:36,910 --> 00:30:41,640
don't wait for the snapshot download if

00:30:38,860 --> 00:30:44,080
your service takes up to 10 minutes

00:30:41,640 --> 00:30:46,090
bootstrap time we need to debug it

00:30:44,080 --> 00:30:51,580
figure out why it takes so long but I

00:30:46,090 --> 00:30:53,710
can't magically reduce the time yeah so

00:30:51,580 --> 00:30:57,190
the question was open source it's not

00:30:53,710 --> 00:30:59,830
yet but you can see my email down there

00:30:57,190 --> 00:31:01,810
and if any one of you was curious about

00:30:59,830 --> 00:31:04,000
that and want to join we're looking for

00:31:01,810 --> 00:31:06,010
people that will help us to improve

00:31:04,000 --> 00:31:08,950
enhance an open source that system

00:31:06,010 --> 00:31:13,350
hopefully in the next year we do open

00:31:08,950 --> 00:31:16,350
source it but join us in other questions

00:31:13,350 --> 00:31:16,350
yeah

00:31:21,390 --> 00:31:26,380
good question we do have other

00:31:24,250 --> 00:31:30,850
deployment tool for production we're not

00:31:26,380 --> 00:31:36,660
using Messersmith why not amazing do we

00:31:30,850 --> 00:31:40,030
do because the slide I mentioned here I

00:31:36,660 --> 00:31:42,760
don't do any of Connery blue green I

00:31:40,030 --> 00:31:45,040
don't do any validation I try to spawn

00:31:42,760 --> 00:31:47,110
up the environment as fast as I can and

00:31:45,040 --> 00:31:51,770
in production and you do want to have

00:31:47,110 --> 00:31:56,260
validations so we're done thank you

00:31:51,770 --> 00:32:01,390
[Applause]

00:31:56,260 --> 00:32:01,390

YouTube URL: https://www.youtube.com/watch?v=sI_IrFTbWbo


