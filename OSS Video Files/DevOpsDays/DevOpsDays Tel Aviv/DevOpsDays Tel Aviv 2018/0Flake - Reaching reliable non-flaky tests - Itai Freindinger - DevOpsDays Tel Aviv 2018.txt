Title: 0Flake - Reaching reliable non-flaky tests - Itai Freindinger - DevOpsDays Tel Aviv 2018
Publication date: 2019-01-03
Playlist: DevOpsDays Tel Aviv 2018
Description: 
	Flaky tests are a waste of time and money. It becomes a nightmare when the component under test is a very complex non deterministic decision system. We found that mocks, stubs and docker sidecars have their limits and we moved more tests from the CI to pre-production testing (canary on steroids)
Captions: 
	00:00:05,270 --> 00:00:11,090
okay so hello everyone my name is Atty

00:00:08,059 --> 00:00:16,190
I'm from a company called footer and

00:00:11,090 --> 00:00:19,439
today we're gonna talk about flaky tests

00:00:16,190 --> 00:00:22,289
so what are flaky tests flaky tests can

00:00:19,439 --> 00:00:27,029
fail or pass for the exact same

00:00:22,289 --> 00:00:28,980
configuration so what do we usually do

00:00:27,029 --> 00:00:33,300
we just try to patch them and you know

00:00:28,980 --> 00:00:35,430
go on with our next item on the list

00:00:33,300 --> 00:00:37,170
we don't usually stop and think about

00:00:35,430 --> 00:00:40,980
what really what is the underlying

00:00:37,170 --> 00:00:42,719
problem here and so after you pass the

00:00:40,980 --> 00:00:45,420
test and then it fails again you need to

00:00:42,719 --> 00:00:47,820
test the pest of the test that you just

00:00:45,420 --> 00:00:49,559
patched over the test because you're not

00:00:47,820 --> 00:00:51,270
really sure if you fix the problem or

00:00:49,559 --> 00:00:53,520
not because by definition it happens

00:00:51,270 --> 00:00:55,230
sometimes and if you have a complex

00:00:53,520 --> 00:00:58,050
enough service it will happen more often

00:00:55,230 --> 00:01:01,469
than not and that's gonna be a big

00:00:58,050 --> 00:01:04,019
problem so more often do not the

00:01:01,469 --> 00:01:08,100
underlying problem of flaky tests is the

00:01:04,019 --> 00:01:13,710
assumption that each test has only one

00:01:08,100 --> 00:01:15,689
correct answer so while in reality the

00:01:13,710 --> 00:01:18,900
test could have like a range or even a

00:01:15,689 --> 00:01:22,860
spectrum of correct answers and you need

00:01:18,900 --> 00:01:27,119
to account for that and the reason I

00:01:22,860 --> 00:01:29,810
want to mention confidence is because of

00:01:27,119 --> 00:01:34,590
our customers so our customers our

00:01:29,810 --> 00:01:37,500
enterprise ecommerce merchants and they

00:01:34,590 --> 00:01:39,240
probably I mean today they know who for

00:01:37,500 --> 00:01:43,649
their is but if we go like three years

00:01:39,240 --> 00:01:46,020
back it wasn't a common brand and so

00:01:43,649 --> 00:01:49,259
they would ask us how do you prepare for

00:01:46,020 --> 00:01:50,189
Black Friday Black Friday is the days

00:01:49,259 --> 00:01:51,630
where they have you know these

00:01:50,189 --> 00:01:54,590
promotions and they make most of the

00:01:51,630 --> 00:01:58,020
money and the expected answer would be

00:01:54,590 --> 00:02:01,469
that we would tell them we do code free

00:01:58,020 --> 00:02:03,509
it's one month in advance but no no

00:02:01,469 --> 00:02:05,670
startup does that right I mean so the

00:02:03,509 --> 00:02:08,250
answer we do give them is that we have a

00:02:05,670 --> 00:02:09,179
lot of confidence in our system in the

00:02:08,250 --> 00:02:11,819
tests

00:02:09,179 --> 00:02:14,099
and so we project this confidence to our

00:02:11,819 --> 00:02:18,060
customers and we say the fraudsters the

00:02:14,099 --> 00:02:20,189
I'll explain in a minute we further

00:02:18,060 --> 00:02:22,700
provides basically a fraud prevention

00:02:20,189 --> 00:02:25,739
solution for e-commerce merchants so

00:02:22,700 --> 00:02:27,299
this is an adversary environment in

00:02:25,739 --> 00:02:30,120
which the fraudsters keep on trying

00:02:27,299 --> 00:02:31,530
again and again and again and so the

00:02:30,120 --> 00:02:34,829
fact is they never sleep

00:02:31,530 --> 00:02:37,620
they never you know they keep on trying

00:02:34,829 --> 00:02:43,049
and so we cannot just code fees we need

00:02:37,620 --> 00:02:45,450
to keep on evolving and so the test

00:02:43,049 --> 00:02:46,799
providers confidence in in three

00:02:45,450 --> 00:02:48,959
different phases in the development

00:02:46,799 --> 00:02:51,599
right obviously during development and

00:02:48,959 --> 00:02:54,719
then drink deployment we usually have

00:02:51,599 --> 00:02:57,239
these trip flight checks we're gonna go

00:02:54,719 --> 00:02:58,829
over those and then when they run

00:02:57,239 --> 00:03:01,680
continuously in production we usually

00:02:58,829 --> 00:03:03,269
call them probes or monitoring or stuff

00:03:01,680 --> 00:03:06,359
like that but basically it's I would

00:03:03,269 --> 00:03:09,269
call those this whole family tests and

00:03:06,359 --> 00:03:11,519
the main theme of this talk is about

00:03:09,269 --> 00:03:16,829
confidence okay how do we gain

00:03:11,519 --> 00:03:18,150
confidence so first I'm gonna give a

00:03:16,829 --> 00:03:19,799
little bit of context because I'm gonna

00:03:18,150 --> 00:03:21,750
use like the same example again and

00:03:19,799 --> 00:03:24,269
again and again and then we're going to

00:03:21,750 --> 00:03:27,209
talk about flaky unit tests due to

00:03:24,269 --> 00:03:29,489
precision accuracy problems the second

00:03:27,209 --> 00:03:32,549
example is going to be about our flaky

00:03:29,489 --> 00:03:35,819
integration tests because the system

00:03:32,549 --> 00:03:37,919
being tested is non-deterministic okay

00:03:35,819 --> 00:03:39,930
I'll repeat that again you have a system

00:03:37,919 --> 00:03:42,150
each time you test it you get a

00:03:39,930 --> 00:03:45,000
different result you can see why that

00:03:42,150 --> 00:03:47,849
would could result in a flaky test and

00:03:45,000 --> 00:03:50,519
then the last one we were talking about

00:03:47,849 --> 00:03:53,419
flaky system tests that are caused due

00:03:50,519 --> 00:03:56,459
to a synchronous data pipeline hiccups

00:03:53,419 --> 00:03:59,280
which is again a normal thing but it

00:03:56,459 --> 00:04:01,500
could cause a lot of trouble and you

00:03:59,280 --> 00:04:04,799
would see that each one of the solutions

00:04:01,500 --> 00:04:08,159
I'm going to propose we basically bend

00:04:04,799 --> 00:04:11,970
over backwards to fix the tests and it

00:04:08,159 --> 00:04:14,609
requires a lot of a lot of investment so

00:04:11,970 --> 00:04:16,380
you might want to try it or not but you

00:04:14,609 --> 00:04:19,349
need to keep track of the requirements

00:04:16,380 --> 00:04:21,269
of why we did such a great investment in

00:04:19,349 --> 00:04:23,800
order to fix it because this might be

00:04:21,269 --> 00:04:26,540
relevant to you or not

00:04:23,800 --> 00:04:29,390
so let's start some context

00:04:26,540 --> 00:04:31,130
so as of said footer provides a fraud

00:04:29,390 --> 00:04:34,220
prevention solution for e-commerce

00:04:31,130 --> 00:04:37,100
merchants so think five years ago you go

00:04:34,220 --> 00:04:39,530
online you shop for something you press

00:04:37,100 --> 00:04:42,260
the checkout button you fill in the

00:04:39,530 --> 00:04:44,510
shipping address let lick your home in

00:04:42,260 --> 00:04:48,620
Israel probably and the billing address

00:04:44,510 --> 00:04:50,420
which is usually the the address of the

00:04:48,620 --> 00:04:53,540
credit card holder usually it's the same

00:04:50,420 --> 00:04:57,410
address and then you click the Buy Now

00:04:53,540 --> 00:04:59,540
button and they said we're sorry we we

00:04:57,410 --> 00:05:01,640
never saw an Israeli credit card maybe

00:04:59,540 --> 00:05:03,500
you're a fraudster please call customer

00:05:01,640 --> 00:05:05,900
support or we don't support shipping to

00:05:03,500 --> 00:05:09,170
Israel all those kind of things so this

00:05:05,900 --> 00:05:11,800
was I think I'd say five years ago today

00:05:09,170 --> 00:05:15,460
every ecommerce merchant has their own

00:05:11,800 --> 00:05:17,480
either they they partner with with

00:05:15,460 --> 00:05:21,290
companies like further or they have

00:05:17,480 --> 00:05:24,410
their in-house fraud prevention team so

00:05:21,290 --> 00:05:26,420
how the system works the raw input is

00:05:24,410 --> 00:05:29,750
the billing of the shipping addresses

00:05:26,420 --> 00:05:31,700
like text and the output is a decision

00:05:29,750 --> 00:05:35,060
either you decline the transaction or

00:05:31,700 --> 00:05:35,450
you approve it so this is how the game

00:05:35,060 --> 00:05:38,030
works

00:05:35,450 --> 00:05:41,840
if footer approves a legitimate

00:05:38,030 --> 00:05:44,540
transaction we get a cut of the deal

00:05:41,840 --> 00:05:50,120
which is very nice if we approve a

00:05:44,540 --> 00:05:51,920
transaction and later on we it ends up

00:05:50,120 --> 00:05:53,810
being fertile and transaction for

00:05:51,920 --> 00:05:56,300
example it was someone using someone

00:05:53,810 --> 00:06:00,140
else's credit card or in an identity

00:05:56,300 --> 00:06:04,060
theft then for our needs to repay the

00:06:00,140 --> 00:06:08,390
money of the money to the our customers

00:06:04,060 --> 00:06:10,100
and it becomes very very tricky because

00:06:08,390 --> 00:06:11,720
let's say we want to decline more

00:06:10,100 --> 00:06:14,060
transactions what happens is that the

00:06:11,720 --> 00:06:15,950
end users do get like very angry because

00:06:14,060 --> 00:06:17,630
they cannot you know checkout they start

00:06:15,950 --> 00:06:19,700
calling your customers customer support

00:06:17,630 --> 00:06:21,350
and so on and then we get calls saying

00:06:19,700 --> 00:06:23,210
what are you doing we cannot handle all

00:06:21,350 --> 00:06:25,700
these customer support calls right and

00:06:23,210 --> 00:06:28,520
if we approve too much transactions then

00:06:25,700 --> 00:06:31,100
too many forces would you know come in

00:06:28,520 --> 00:06:33,740
and then we'll have trouble because we

00:06:31,100 --> 00:06:35,990
need to you know reimburse our customers

00:06:33,740 --> 00:06:36,650
and they would have trouble with credit

00:06:35,990 --> 00:06:38,210
card issuers

00:06:36,650 --> 00:06:40,100
because things and you you've reached

00:06:38,210 --> 00:06:41,840
the maximum amount of you know illegal

00:06:40,100 --> 00:06:44,270
transactions for the land transactions

00:06:41,840 --> 00:06:48,050
and so on so there is like a very narrow

00:06:44,270 --> 00:06:50,210
band where we operate so how does the

00:06:48,050 --> 00:06:54,139
system work so we get the raw data the

00:06:50,210 --> 00:06:55,250
first thing we need to process it okay

00:06:54,139 --> 00:06:58,310
this is where we're gonna talk about

00:06:55,250 --> 00:06:59,840
unit testing so in this example we

00:06:58,310 --> 00:07:01,669
designed a feature which is called

00:06:59,840 --> 00:07:04,250
billing shipping distance which is the

00:07:01,669 --> 00:07:05,660
distance between the billing address the

00:07:04,250 --> 00:07:07,520
credit card holder address and the

00:07:05,660 --> 00:07:09,680
shipping address and the result is in

00:07:07,520 --> 00:07:11,360
miles and then the next the next

00:07:09,680 --> 00:07:14,210
component is a fraud prediction which is

00:07:11,360 --> 00:07:16,370
a machine learning component which makes

00:07:14,210 --> 00:07:18,800
things more interesting as you'll see

00:07:16,370 --> 00:07:21,889
soon and then the last component takes

00:07:18,800 --> 00:07:23,990
the fraud probability and then applies

00:07:21,889 --> 00:07:26,389
you know customer specific policies and

00:07:23,990 --> 00:07:29,150
outputs a decision in this in in this

00:07:26,389 --> 00:07:31,820
case the building shipping distance was

00:07:29,150 --> 00:07:33,800
twelve hundred miles the fault predicted

00:07:31,820 --> 00:07:37,130
it's a 25 percent fraud probability and

00:07:33,800 --> 00:07:38,240
the policy is that if it's above twenty

00:07:37,130 --> 00:07:40,729
percent then decline the transaction

00:07:38,240 --> 00:07:45,470
okay so this is the example I'm gonna

00:07:40,729 --> 00:07:47,680
you know hammer in this presentation so

00:07:45,470 --> 00:07:50,240
let's start with flake unit tests if you

00:07:47,680 --> 00:07:52,490
you know phrase out then phase in again

00:07:50,240 --> 00:07:54,860
you can see the top right corner like

00:07:52,490 --> 00:07:58,300
this it says unit test so you know which

00:07:54,860 --> 00:08:02,690
example we read what I'm talking about

00:07:58,300 --> 00:08:05,330
floating points yeah a precision quick

00:08:02,690 --> 00:08:07,010
question how many of the Hebrew speakers

00:08:05,330 --> 00:08:09,530
on the audience know the example between

00:08:07,010 --> 00:08:12,979
precision and accuracy how do you say

00:08:09,530 --> 00:08:15,800
precision in Hebrew Deok how do you say

00:08:12,979 --> 00:08:19,550
accuracy in Hebrew Duke so people get

00:08:15,800 --> 00:08:22,250
confused so let's say I say pi equals

00:08:19,550 --> 00:08:25,760
three point one so this is very accurate

00:08:22,250 --> 00:08:28,190
but not very precise if I say pi equals

00:08:25,760 --> 00:08:31,340
three point five five five five five I'm

00:08:28,190 --> 00:08:37,610
very precise but it's not accurate if I

00:08:31,340 --> 00:08:40,700
say pi equals 3.14159265 three five then

00:08:37,610 --> 00:08:43,880
I both precise and accurate okay so now

00:08:40,700 --> 00:08:45,920
we're talking about precision most

00:08:43,880 --> 00:08:47,970
developers eventually find out that

00:08:45,920 --> 00:08:52,320
floaty points are

00:08:47,970 --> 00:08:55,590
have this precision range and it was

00:08:52,320 --> 00:08:58,440
designed to have a very high range of

00:08:55,590 --> 00:09:01,730
values but it loses accuracy that's like

00:08:58,440 --> 00:09:04,920
basic trade-off of floating points and

00:09:01,730 --> 00:09:06,840
so when you go back to the example where

00:09:04,920 --> 00:09:11,220
we want to measure the distance between

00:09:06,840 --> 00:09:13,320
two points on earth this is like this is

00:09:11,220 --> 00:09:18,240
an example I copied from the readme file

00:09:13,320 --> 00:09:21,000
of the GOP our library and when you run

00:09:18,240 --> 00:09:24,620
it here you get this error right because

00:09:21,000 --> 00:09:27,060
there's a precision difference so

00:09:24,620 --> 00:09:30,060
developers usually when they see such an

00:09:27,060 --> 00:09:33,360
error they like yeah whatever that just

00:09:30,060 --> 00:09:35,550
plus minus 0.01 miles and let's go on

00:09:33,360 --> 00:09:40,440
with our lives right problem solved

00:09:35,550 --> 00:09:43,200
yay and then I think if I remember

00:09:40,440 --> 00:09:47,190
correctly it says on the 7th of April

00:09:43,200 --> 00:09:49,290
2018 the default distance algorithm in

00:09:47,190 --> 00:09:52,410
the Gil play library was upgraded to a

00:09:49,290 --> 00:09:56,100
better one it is more accurate now and

00:09:52,410 --> 00:09:58,260
so I came happy to the office I called

00:09:56,100 --> 00:09:59,400
the relevant fraud analyst listen we

00:09:58,260 --> 00:10:01,470
have like a new version we have to

00:09:59,400 --> 00:10:05,490
upgrade he was like yeah whatever

00:10:01,470 --> 00:10:09,060
and I upgraded it and our test failed

00:10:05,490 --> 00:10:13,110
because the you know the expected result

00:10:09,060 --> 00:10:14,700
wasn't the right one so this was this

00:10:13,110 --> 00:10:16,410
time I was like okay I'm not gonna patch

00:10:14,700 --> 00:10:19,620
it right and I called the analyst he was

00:10:16,410 --> 00:10:21,210
like who cares about 0.01 miles it has

00:10:19,620 --> 00:10:23,760
no meaning from Freud analyst

00:10:21,210 --> 00:10:25,770
perspective so we change it to B plus

00:10:23,760 --> 00:10:28,590
minus one mile or if it's a it's a

00:10:25,770 --> 00:10:32,089
really big distance than even 1% in this

00:10:28,590 --> 00:10:36,000
case like plus minus five miles is okay

00:10:32,089 --> 00:10:38,040
and that got us thinking that developers

00:10:36,000 --> 00:10:39,270
should not be maintaining these tests at

00:10:38,040 --> 00:10:41,460
all because they don't have the

00:10:39,270 --> 00:10:43,200
domain-specific knowledge and this is

00:10:41,460 --> 00:10:45,089
not just a problem with you know gear

00:10:43,200 --> 00:10:47,820
distance if you think about reputation

00:10:45,089 --> 00:10:51,420
it's it's a range okay it's a spectrum

00:10:47,820 --> 00:10:53,130
and and it can change and then you need

00:10:51,420 --> 00:10:54,960
to just keep failing and you see like

00:10:53,130 --> 00:10:57,150
for analysts every day coming to work

00:10:54,960 --> 00:10:58,790
and and you know copying like they have

00:10:57,150 --> 00:11:00,230
this assertion error in the CI

00:10:58,790 --> 00:11:02,480
they copy it and then they copy the

00:11:00,230 --> 00:11:04,820
result of the test and the test passes

00:11:02,480 --> 00:11:07,670
and then history trying doing this again

00:11:04,820 --> 00:11:09,530
and again so we designed this versus

00:11:07,670 --> 00:11:12,860
Liam test report that basically allows

00:11:09,530 --> 00:11:14,860
analyst to put the raw data inside it's

00:11:12,860 --> 00:11:19,580
easier for them and then we have this

00:11:14,860 --> 00:11:22,430
aprox ESL language if you want or you

00:11:19,580 --> 00:11:25,700
can specify one of these options and

00:11:22,430 --> 00:11:28,100
this is how most of our unit tests look

00:11:25,700 --> 00:11:31,970
like so it started with you know flaky

00:11:28,100 --> 00:11:36,860
tests but eventually the the basic

00:11:31,970 --> 00:11:41,690
confidence in our system was broken and

00:11:36,860 --> 00:11:43,820
we had to fix it in a more basic way so

00:11:41,690 --> 00:11:46,670
this was easy this was like warming up

00:11:43,820 --> 00:11:50,270
okay next thanks in an integration test

00:11:46,670 --> 00:11:53,990
so I would like to test this whole flow

00:11:50,270 --> 00:11:56,510
and this flow is I'm gonna prove in a

00:11:53,990 --> 00:11:59,000
minute is non-deterministic for the same

00:11:56,510 --> 00:12:03,190
input in my result in different results

00:11:59,000 --> 00:12:07,280
and why because all of these features

00:12:03,190 --> 00:12:10,430
they depend on micro-services it could

00:12:07,280 --> 00:12:12,860
be you know as we saw in Nissan's

00:12:10,430 --> 00:12:15,140
lecture it could be like internal micro

00:12:12,860 --> 00:12:18,110
services that are external to this

00:12:15,140 --> 00:12:22,370
service or they could be even external

00:12:18,110 --> 00:12:25,910
to your company and so what happens when

00:12:22,370 --> 00:12:27,860
the gear coding service fails so we need

00:12:25,910 --> 00:12:30,320
still to you know to give some kind of

00:12:27,860 --> 00:12:31,940
result right so almost every feature has

00:12:30,320 --> 00:12:33,920
like this fallback mode so in this case

00:12:31,940 --> 00:12:37,340
instead of saying the billing shipping

00:12:33,920 --> 00:12:39,980
distance is greater than 100 well 1,200

00:12:37,340 --> 00:12:42,680
miles we the result of the feature is

00:12:39,980 --> 00:12:44,240
it's greater than 100 miles because we

00:12:42,680 --> 00:12:48,140
see they're like in different states or

00:12:44,240 --> 00:12:49,700
something like that and so an exception

00:12:48,140 --> 00:12:51,710
is raised and this is very important so

00:12:49,700 --> 00:12:54,380
just you know hold that in your in your

00:12:51,710 --> 00:12:57,740
head for a moment and the fog prediction

00:12:54,380 --> 00:12:59,870
it got a slightly different input and it

00:12:57,740 --> 00:13:03,410
provided a slightly different output but

00:12:59,870 --> 00:13:05,480
because of the policy the test now fails

00:13:03,410 --> 00:13:09,800
because the expected result is decline

00:13:05,480 --> 00:13:11,040
while actually sometimes it's flaky and

00:13:09,800 --> 00:13:13,110
it returns the proof

00:13:11,040 --> 00:13:15,420
but there's nothing wrong with the

00:13:13,110 --> 00:13:17,700
system that we are testing okay which is

00:13:15,420 --> 00:13:21,240
everything except uh it's it's it's

00:13:17,700 --> 00:13:23,040
everything except the blue boxes but it

00:13:21,240 --> 00:13:26,280
includes all the arrows right it's an

00:13:23,040 --> 00:13:29,160
integration test so let's analyze what's

00:13:26,280 --> 00:13:31,350
going on here there is a basic trade-off

00:13:29,160 --> 00:13:34,530
in integration tests you want stability

00:13:31,350 --> 00:13:37,380
anyone integration coverage and so and

00:13:34,530 --> 00:13:40,050
the far inside you could say this is

00:13:37,380 --> 00:13:41,460
what like most new developers they're

00:13:40,050 --> 00:13:43,260
like you know what let's just stop

00:13:41,460 --> 00:13:46,230
everything don't call don't call any

00:13:43,260 --> 00:13:49,080
other service we readies we'll just pip

00:13:46,230 --> 00:13:50,760
install fake Freddy's or whatever and

00:13:49,080 --> 00:13:53,370
then each other service will write a

00:13:50,760 --> 00:13:55,140
stop or a marker and then you say and

00:13:53,370 --> 00:13:56,700
then the test will always pass yeah

00:13:55,140 --> 00:13:58,320
great but what is the integration

00:13:56,700 --> 00:14:02,190
coverage you didn't test what you wanted

00:13:58,320 --> 00:14:04,590
to test you will eventually end up in

00:14:02,190 --> 00:14:06,390
production and you will in production

00:14:04,590 --> 00:14:08,880
with many exceptions and that you could

00:14:06,390 --> 00:14:10,050
have caught earlier in the integration

00:14:08,880 --> 00:14:13,170
test that's the whole point of an

00:14:10,050 --> 00:14:15,960
integration test so at the other end you

00:14:13,170 --> 00:14:17,730
can connect to other services always so

00:14:15,960 --> 00:14:20,040
the integration tests each times it ones

00:14:17,730 --> 00:14:25,020
are Gayle coding it calls the Cal coding

00:14:20,040 --> 00:14:26,940
a micro service and the problem is that

00:14:25,020 --> 00:14:31,710
sometimes there are exceptions like we

00:14:26,940 --> 00:14:34,340
just saw and I wonder like with their

00:14:31,710 --> 00:14:37,200
show of hands how many of you has have

00:14:34,340 --> 00:14:38,220
at your work at least one environment

00:14:37,200 --> 00:14:39,840
let's say the production environment

00:14:38,220 --> 00:14:43,500
right everyone has a production

00:14:39,840 --> 00:14:45,570
environment ok how many have how many of

00:14:43,500 --> 00:14:48,680
you have like two let's say production

00:14:45,570 --> 00:14:52,170
and test okay do you have three maybe

00:14:48,680 --> 00:14:54,030
okay four no okay

00:14:52,170 --> 00:14:57,480
so oh you do have like three people

00:14:54,030 --> 00:14:58,740
raise their hand so the problem okay so

00:14:57,480 --> 00:15:01,020
we have one and a half we have

00:14:58,740 --> 00:15:02,850
production and we have a developer you

00:15:01,020 --> 00:15:05,880
can call it test environment and the

00:15:02,850 --> 00:15:07,830
problem here is is is fatigue okay you

00:15:05,880 --> 00:15:11,100
cannot production environment if

00:15:07,830 --> 00:15:13,290
something breaks you need to run and fix

00:15:11,100 --> 00:15:15,330
it you cancel whatever meeting your your

00:15:13,290 --> 00:15:17,790
ad or whatever you're at lunch or

00:15:15,330 --> 00:15:20,400
whatever you just go in and fix it but

00:15:17,790 --> 00:15:22,800
you don't want to double this tax by two

00:15:20,400 --> 00:15:24,220
and by three and by four it doesn't make

00:15:22,800 --> 00:15:26,680
any sense so

00:15:24,220 --> 00:15:28,780
in the test environment it's okay you

00:15:26,680 --> 00:15:30,970
know to go for the meeting and maybe fix

00:15:28,780 --> 00:15:33,250
it when you're back or fix it tomorrow

00:15:30,970 --> 00:15:36,850
morning and that leaves us with

00:15:33,250 --> 00:15:40,710
integration tests that sometimes get

00:15:36,850 --> 00:15:43,030
exceptions so what do we do with that

00:15:40,710 --> 00:15:45,580
what you don't want to do you don't want

00:15:43,030 --> 00:15:48,430
to add just slap on retries this is just

00:15:45,580 --> 00:15:49,810
like patching the unit test because when

00:15:48,430 --> 00:15:53,200
you end a retry to a test

00:15:49,810 --> 00:15:55,270
usually it adds up by means of the time

00:15:53,200 --> 00:15:58,030
of the test when it fails gets much

00:15:55,270 --> 00:16:00,550
longer and it assumes that the problem

00:15:58,030 --> 00:16:02,710
is temporary so the Galle coding service

00:16:00,550 --> 00:16:05,050
didn't work and now five minutes later

00:16:02,710 --> 00:16:08,100
someone fixed it no that's not what

00:16:05,050 --> 00:16:10,540
actually happens so what we did okay so

00:16:08,100 --> 00:16:12,310
so one way of approaching it is going

00:16:10,540 --> 00:16:14,770
from the left side to the right and

00:16:12,310 --> 00:16:16,890
basically you say okay I'm not going to

00:16:14,770 --> 00:16:19,270
use fake fairies I'm going to install

00:16:16,890 --> 00:16:22,240
darker red is something localhost and

00:16:19,270 --> 00:16:25,830
this is I'm not going to call the Gil PI

00:16:22,240 --> 00:16:28,540
micro service I'm going to install a GOP

00:16:25,830 --> 00:16:30,370
darker on the localhost and so it makes

00:16:28,540 --> 00:16:31,030
sense if your system is relatively

00:16:30,370 --> 00:16:33,400
simple

00:16:31,030 --> 00:16:34,720
but if you have I know 10 micro services

00:16:33,400 --> 00:16:37,420
and each one of them recursively

00:16:34,720 --> 00:16:40,270
requires you know a database and special

00:16:37,420 --> 00:16:42,250
configuration and more Dockers then each

00:16:40,270 --> 00:16:46,240
test suite would require you know like

00:16:42,250 --> 00:16:52,290
20 or 30 dollars to start and this would

00:16:46,240 --> 00:16:54,580
not hold so we'll go from the right up

00:16:52,290 --> 00:16:56,470
so the first thing that we do do you

00:16:54,580 --> 00:16:59,410
remember the exception monitoring code

00:16:56,470 --> 00:17:00,940
we mark it drink test and we just log

00:16:59,410 --> 00:17:04,690
every time there is an exception to say

00:17:00,940 --> 00:17:06,640
okay exception we write it down and then

00:17:04,690 --> 00:17:08,800
at the end of the test we take the list

00:17:06,640 --> 00:17:11,560
of exceptions and we look at them and

00:17:08,800 --> 00:17:13,120
they say oh you know this exception you

00:17:11,560 --> 00:17:15,640
know it's not it's not because of us

00:17:13,120 --> 00:17:19,150
it's this this other other service

00:17:15,640 --> 00:17:21,160
failed and you know probably would get

00:17:19,150 --> 00:17:23,410
fixed tomorrow morning so it's okay so

00:17:21,160 --> 00:17:26,590
we let the tests pass

00:17:23,410 --> 00:17:28,870
don't get angry so like you know people

00:17:26,590 --> 00:17:31,780
look at me strange this is what we do a

00:17:28,870 --> 00:17:34,780
test has an exception we say okay it's

00:17:31,780 --> 00:17:36,220
okay but then but this this doesn't

00:17:34,780 --> 00:17:38,000
really solve the problem right because

00:17:36,220 --> 00:17:40,280
there is an assertion landed

00:17:38,000 --> 00:17:43,010
says decision equals decline and now

00:17:40,280 --> 00:17:45,940
it's approve you cannot you cannot just

00:17:43,010 --> 00:17:49,310
delete that certian right yes you can

00:17:45,940 --> 00:17:53,830
so our integration test does not have an

00:17:49,310 --> 00:17:56,150
assert on the end result of our system

00:17:53,830 --> 00:17:58,250
okay yeah we have an integration test

00:17:56,150 --> 00:18:00,110
that always passes almost have really

00:17:58,250 --> 00:18:02,420
good coverage and really good stability

00:18:00,110 --> 00:18:05,210
but we don't actually test that the one

00:18:02,420 --> 00:18:06,650
thing that we get money for so we are

00:18:05,210 --> 00:18:10,370
what I'm gonna show you now is this

00:18:06,650 --> 00:18:12,820
whole big operation just to test that a

00:18:10,370 --> 00:18:17,870
sir

00:18:12,820 --> 00:18:20,090
so this basically shows that reminds us

00:18:17,870 --> 00:18:22,430
that that this big client decision is

00:18:20,090 --> 00:18:24,290
something that we sent back to our

00:18:22,430 --> 00:18:26,990
customers this is where we make money

00:18:24,290 --> 00:18:28,520
and so we said okay we don't have a

00:18:26,990 --> 00:18:30,350
really you know full fledge testing

00:18:28,520 --> 00:18:32,660
environment let's let's test it in

00:18:30,350 --> 00:18:35,540
production yeah you know what bird is

00:18:32,660 --> 00:18:37,580
this the cannery a songbird very

00:18:35,540 --> 00:18:39,950
beautiful bird that in the old days

00:18:37,580 --> 00:18:42,710
coal miners would take with them down to

00:18:39,950 --> 00:18:44,720
the coal mine and other than singing

00:18:42,710 --> 00:18:47,900
this bird is very sensitive to lethal

00:18:44,720 --> 00:18:50,870
gas and so when the when the Connery

00:18:47,900 --> 00:18:52,970
stopped singing they just no get revert

00:18:50,870 --> 00:18:57,410
and get out of there and get back home

00:18:52,970 --> 00:19:00,020
and and and this is like the metaphor

00:18:57,410 --> 00:19:02,420
for a canary release this is what

00:19:00,020 --> 00:19:05,060
Netflix you free do no fan of Netflix

00:19:02,420 --> 00:19:07,910
blogs you would see this a lot basically

00:19:05,060 --> 00:19:09,530
how it works I go over this quickly you

00:19:07,910 --> 00:19:12,710
have an existing production environment

00:19:09,530 --> 00:19:15,350
and then you install the version to

00:19:12,710 --> 00:19:17,060
let's say only three instances you don't

00:19:15,350 --> 00:19:18,860
want to sacrifice too much traffic

00:19:17,060 --> 00:19:22,160
but you connect it to the same old

00:19:18,860 --> 00:19:23,930
balancer as the production and then you

00:19:22,160 --> 00:19:25,640
want to compare metrics between the

00:19:23,930 --> 00:19:28,340
canary environment and the production

00:19:25,640 --> 00:19:30,230
environment the problem is that there

00:19:28,340 --> 00:19:31,760
they were not born equal right because

00:19:30,230 --> 00:19:34,580
the production environment already has

00:19:31,760 --> 00:19:37,040
all the caches all the connections it is

00:19:34,580 --> 00:19:39,140
much much scaled out and so it doesn't

00:19:37,040 --> 00:19:40,970
make much sense to compare the cannery

00:19:39,140 --> 00:19:43,430
release to the production so what they

00:19:40,970 --> 00:19:45,380
do the with the cannery they also deploy

00:19:43,430 --> 00:19:47,330
three instances of version one they call

00:19:45,380 --> 00:19:48,800
it baseline and then they come

00:19:47,330 --> 00:19:53,510
here are the results of cannery and

00:19:48,800 --> 00:19:55,990
baseline okay does this make sense and

00:19:53,510 --> 00:20:00,080
they also now have like this spin-off

00:19:55,990 --> 00:20:02,810
this open-source spinnaker I owe that

00:20:00,080 --> 00:20:06,890
lets you do all this deployment and they

00:20:02,810 --> 00:20:09,200
have this new Kayenta features which

00:20:06,890 --> 00:20:11,660
does the the automatic chimera in the

00:20:09,200 --> 00:20:15,110
analysis you can just take it and use it

00:20:11,660 --> 00:20:21,200
we don't we don't use it and and this is

00:20:15,110 --> 00:20:22,940
this is why lost money okay so wait wait

00:20:21,200 --> 00:20:26,360
this is complicated just look at me for

00:20:22,940 --> 00:20:29,000
a minute we lose money all the time okay

00:20:26,360 --> 00:20:30,800
sometimes Fosters are able to get

00:20:29,000 --> 00:20:32,900
through and this is part of the cost of

00:20:30,800 --> 00:20:35,030
doing business it's not something we can

00:20:32,900 --> 00:20:37,700
control too much at least not in the

00:20:35,030 --> 00:20:38,740
short term engineering class is

00:20:37,700 --> 00:20:41,330
something this is like what we call

00:20:38,740 --> 00:20:44,570
analytics loss but engineering loss is

00:20:41,330 --> 00:20:46,760
when a machine fails and then we switch

00:20:44,570 --> 00:20:49,820
to fallback mode our results are not as

00:20:46,760 --> 00:20:52,940
accurate and then we lose money again we

00:20:49,820 --> 00:20:55,880
cannot prevent instances from failing

00:20:52,940 --> 00:20:57,770
right so this is engineering loss but

00:20:55,880 --> 00:21:00,610
there is another factor for engineering

00:20:57,770 --> 00:21:06,200
loss added by a cannery are really cycle

00:21:00,610 --> 00:21:09,140
which we can control so there's so there

00:21:06,200 --> 00:21:11,150
are two things to observe here there are

00:21:09,140 --> 00:21:13,010
minimum transact number of transactions

00:21:11,150 --> 00:21:14,900
needed before you can have a

00:21:13,010 --> 00:21:19,070
statistically significant result to

00:21:14,900 --> 00:21:20,870
compare the cannery v2 with v3 okay it

00:21:19,070 --> 00:21:22,220
takes usually a let's say 10 minutes 15

00:21:20,870 --> 00:21:24,170
minutes it really depends on the

00:21:22,220 --> 00:21:27,950
throughput right so this is a number

00:21:24,170 --> 00:21:33,020
this part you cannot you cannot reduce

00:21:27,950 --> 00:21:35,180
it and then Netflix for each let's say

00:21:33,020 --> 00:21:37,520
transaction they would probably give a

00:21:35,180 --> 00:21:39,590
wrong recommendation or some kind of

00:21:37,520 --> 00:21:40,910
hiccup with the video streaming that I

00:21:39,590 --> 00:21:42,500
guess they could you know they have

00:21:40,910 --> 00:21:45,380
probably local caching so no one would

00:21:42,500 --> 00:21:50,270
even notice but at footer we handle

00:21:45,380 --> 00:21:53,660
flight tickets jewelry shoes food and

00:21:50,270 --> 00:21:56,240
other expensive stuff and so we cannot

00:21:53,660 --> 00:21:59,110
afford this to let the cannery you know

00:21:56,240 --> 00:22:03,929
stop singing too much money

00:21:59,110 --> 00:22:06,039
and so we use Bluegreen deployments

00:22:03,929 --> 00:22:07,690
Bluegreen deployments that we call

00:22:06,039 --> 00:22:12,039
affectionally affectless

00:22:07,690 --> 00:22:13,809
just I'll show in a minute so the green

00:22:12,039 --> 00:22:16,720
environment is now in production and we

00:22:13,809 --> 00:22:19,990
want to deploy v2 so we deploy a

00:22:16,720 --> 00:22:22,960
complete fully scaled deployment this is

00:22:19,990 --> 00:22:25,240
the one in blue and it starts with a

00:22:22,960 --> 00:22:29,470
toggle they recall affectless

00:22:25,240 --> 00:22:31,630
equals true okay so this that the blue

00:22:29,470 --> 00:22:36,159
environment is different because of this

00:22:31,630 --> 00:22:38,830
little toggle and so the first thing we

00:22:36,159 --> 00:22:40,360
start doing is do you remember the

00:22:38,830 --> 00:22:42,190
integration test from before which

00:22:40,360 --> 00:22:43,899
basically sends in our bogus

00:22:42,190 --> 00:22:45,970
transactions and check checks for

00:22:43,899 --> 00:22:47,889
exception we do that here again just to

00:22:45,970 --> 00:22:49,659
warm up everything start the connections

00:22:47,889 --> 00:22:51,909
make sure they know this is serious

00:22:49,659 --> 00:22:54,130
exceptions now we we do care if it

00:22:51,909 --> 00:22:57,960
doesn't if it's not able to connect to

00:22:54,130 --> 00:23:02,080
the a key location micro service and

00:22:57,960 --> 00:23:04,090
then we send a copy of the real traffic

00:23:02,080 --> 00:23:06,639
we just read it from the database in a

00:23:04,090 --> 00:23:09,399
short delay choose the blue environment

00:23:06,639 --> 00:23:12,279
and the reason we need this toggle is so

00:23:09,399 --> 00:23:14,080
the the statefulness of the blood

00:23:12,279 --> 00:23:15,730
environment would not conflict with the

00:23:14,080 --> 00:23:17,500
green environment so basically instead

00:23:15,730 --> 00:23:19,630
of writing to an s3 bucket called

00:23:17,500 --> 00:23:21,940
production we write to an s3 bucket

00:23:19,630 --> 00:23:23,409
called affectless or instead of writing

00:23:21,940 --> 00:23:26,799
to this table we have like this

00:23:23,409 --> 00:23:29,260
underscore affectless table so it is

00:23:26,799 --> 00:23:31,600
very slightly different from production

00:23:29,260 --> 00:23:34,029
but it handles the same traffic okay it

00:23:31,600 --> 00:23:37,179
is killed just as much as production we

00:23:34,029 --> 00:23:40,779
try to warm it up and now we can compare

00:23:37,179 --> 00:23:43,870
between the two environments and this is

00:23:40,779 --> 00:23:45,990
where it gets tricky so do you remember

00:23:43,870 --> 00:23:49,779
this guy the architect from the metrics

00:23:45,990 --> 00:23:51,789
he told me Oh some of my answers you

00:23:49,779 --> 00:23:54,490
will understand and some of them you

00:23:51,789 --> 00:23:57,250
will not so I'm a developer I'm an

00:23:54,490 --> 00:23:59,350
engineer and I look at the results and

00:23:57,250 --> 00:24:02,049
they're not the same the blue and the

00:23:59,350 --> 00:24:03,850
green er elves are different and I'm

00:24:02,049 --> 00:24:05,559
like I have no idea why the machine

00:24:03,850 --> 00:24:07,570
learning decided to accept this one and

00:24:05,559 --> 00:24:10,539
decline that's that that transaction the

00:24:07,570 --> 00:24:12,550
machines that the train machine learning

00:24:10,539 --> 00:24:15,760
model is much more

00:24:12,550 --> 00:24:18,070
it is much smarter than their average or

00:24:15,760 --> 00:24:23,950
above-average engineer when it comes to

00:24:18,070 --> 00:24:26,290
fraud prevention so we call the profit

00:24:23,950 --> 00:24:28,660
okay we call the fraud analyst and this

00:24:26,290 --> 00:24:31,750
is also a quote from the movie you've

00:24:28,660 --> 00:24:34,630
already made your so your choice you are

00:24:31,750 --> 00:24:38,920
here to try to understand why you made

00:24:34,630 --> 00:24:40,690
it so this is how it looks like from a

00:24:38,920 --> 00:24:43,360
engineer's perspective you get this

00:24:40,690 --> 00:24:46,120
report and slack that says that

00:24:43,360 --> 00:24:47,260
decisions are different between their

00:24:46,120 --> 00:24:49,660
feckless and the production environment

00:24:47,260 --> 00:24:52,030
the APL agencies are great the

00:24:49,660 --> 00:24:54,580
exceptions are are great but there's a

00:24:52,030 --> 00:24:56,710
problem and would advise not to switch

00:24:54,580 --> 00:25:00,100
and then what you usually do

00:24:56,710 --> 00:25:02,110
you call an analyst okay because maybe

00:25:00,100 --> 00:25:03,910
maybe the blue environment is even

00:25:02,110 --> 00:25:06,580
better maybe we fix something maybe the

00:25:03,910 --> 00:25:09,220
precision just got better so an analyst

00:25:06,580 --> 00:25:12,250
can go over all the diagnostics and all

00:25:09,220 --> 00:25:14,410
the transactions and together the

00:25:12,250 --> 00:25:17,860
developer and analysts figure out what

00:25:14,410 --> 00:25:19,840
when what went wrong or what is better

00:25:17,860 --> 00:25:22,390
so this is like the downside of this

00:25:19,840 --> 00:25:24,580
approach but it is much much safer and

00:25:22,390 --> 00:25:30,550
this is how we gain confidence in each

00:25:24,580 --> 00:25:32,620
and each version we deploy and so the

00:25:30,550 --> 00:25:38,980
next step is to you know drain the green

00:25:32,620 --> 00:25:40,720
the green environment and then we still

00:25:38,980 --> 00:25:43,330
have we still leave the green one is

00:25:40,720 --> 00:25:46,270
fallback because 15 minutes is usually

00:25:43,330 --> 00:25:48,550
not enough to understand all the

00:25:46,270 --> 00:25:53,500
problems and we have like separate bi

00:25:48,550 --> 00:25:55,120
monitoring against thresholds and we

00:25:53,500 --> 00:25:57,370
check that the blue environment is

00:25:55,120 --> 00:25:59,950
really really good from a business

00:25:57,370 --> 00:26:03,100
perspective and then about let's say

00:25:59,950 --> 00:26:04,420
four hours later we're back to where we

00:26:03,100 --> 00:26:07,720
started with the new version of

00:26:04,420 --> 00:26:10,330
production yay so if you ever want to

00:26:07,720 --> 00:26:13,900
implement that at home so this is when

00:26:10,330 --> 00:26:16,660
you need a remember small problems will

00:26:13,900 --> 00:26:19,750
slip through and accumulate that's gonna

00:26:16,660 --> 00:26:23,350
happen because it's after 14 minutes

00:26:19,750 --> 00:26:26,220
there's some statistical insignificant

00:26:23,350 --> 00:26:28,560
changes that you cannot catch

00:26:26,220 --> 00:26:34,530
so the way to mitigate that is usually

00:26:28,560 --> 00:26:36,750
to group the statistics by host okay

00:26:34,530 --> 00:26:39,540
maybe just one host that has a problem

00:26:36,750 --> 00:26:44,040
or by a tenant maybe it's only specific

00:26:39,540 --> 00:26:46,740
customer that this change we applied has

00:26:44,040 --> 00:26:48,660
problems with and then even with even

00:26:46,740 --> 00:26:50,550
even if like if you look globally at

00:26:48,660 --> 00:26:52,380
your problem it looks it looks fine but

00:26:50,550 --> 00:26:55,020
then when you zoom into specific

00:26:52,380 --> 00:26:58,670
customer you see that oh these customers

00:26:55,020 --> 00:27:01,650
decisions is always always a proof and

00:26:58,670 --> 00:27:04,200
so API latency is if you ever compare

00:27:01,650 --> 00:27:07,230
API latency start with the median

00:27:04,200 --> 00:27:08,940
latency and then go up to the 95th

00:27:07,230 --> 00:27:11,880
percentile latency usually you will see

00:27:08,940 --> 00:27:13,770
a flat line but if you try to compare 99

00:27:11,880 --> 00:27:15,180
13c you can do it but that requires some

00:27:13,770 --> 00:27:18,540
processing because you will see all

00:27:15,180 --> 00:27:21,300
kinds of spikes don't even bother with

00:27:18,540 --> 00:27:26,760
the maximum latency and the last thing

00:27:21,300 --> 00:27:30,030
is about exceptions it's not it's not

00:27:26,760 --> 00:27:33,570
realistic to accept zero exceptions with

00:27:30,030 --> 00:27:35,820
new features ok don't don't even try so

00:27:33,570 --> 00:27:37,800
what we do we have like this features

00:27:35,820 --> 00:27:39,300
that we expect them just to work because

00:27:37,800 --> 00:27:40,980
there have been system like forever and

00:27:39,300 --> 00:27:44,190
there are new features and we have like

00:27:40,980 --> 00:27:46,830
this thresholds that we try to keep you

00:27:44,190 --> 00:27:49,020
know pushing down but don't try to get

00:27:46,830 --> 00:27:53,280
to zero exceptions it's not realistic

00:27:49,020 --> 00:27:58,080
okay last one are you ready this is like

00:27:53,280 --> 00:27:59,850
the more more difficult example so

00:27:58,080 --> 00:28:01,500
actually we don't have only one service

00:27:59,850 --> 00:28:04,260
which is a decision service we have many

00:28:01,500 --> 00:28:07,080
services here you can see the analytic

00:28:04,260 --> 00:28:12,150
service which is basically up reporting

00:28:07,080 --> 00:28:15,300
database dashboard UI so the the fraud

00:28:12,150 --> 00:28:16,920
manager you know customer our customers

00:28:15,300 --> 00:28:18,540
front manager can look at what's going

00:28:16,920 --> 00:28:21,150
on in their business from a fraud

00:28:18,540 --> 00:28:23,580
perspective and this is important

00:28:21,150 --> 00:28:28,080
because one of the key decision-makers

00:28:23,580 --> 00:28:29,850
of choosing our solution is now looking

00:28:28,080 --> 00:28:32,480
at data from the analytic service and

00:28:29,850 --> 00:28:34,740
then there is the billing service which

00:28:32,480 --> 00:28:39,040
basically once a month issues an invoice

00:28:34,740 --> 00:28:41,140
and again the customers that's a CFO

00:28:39,040 --> 00:28:45,040
Director of Finance is looking at the

00:28:41,140 --> 00:28:47,680
output of this service and so the key

00:28:45,040 --> 00:28:50,710
decision-makers are looking at these two

00:28:47,680 --> 00:28:53,200
services and if we have a mistakes it's

00:28:50,710 --> 00:28:55,570
gonna be really really embarrassing okay

00:28:53,200 --> 00:28:57,670
really embarrassing so as I've said

00:28:55,570 --> 00:29:00,070
we're going to bend over backwards to

00:28:57,670 --> 00:29:04,050
increase our confidence in these two

00:29:00,070 --> 00:29:06,220
services so as micro service goes each

00:29:04,050 --> 00:29:08,830
micro service needs to have their own

00:29:06,220 --> 00:29:11,530
database right you want to know separate

00:29:08,830 --> 00:29:14,020
the teams or separate down the code

00:29:11,530 --> 00:29:16,360
separate databases and then you need a

00:29:14,020 --> 00:29:18,970
synchronous data pipeline to stick

00:29:16,360 --> 00:29:23,790
between them obviously let's say it's a

00:29:18,970 --> 00:29:27,160
publish/subscribe publish/subscribe

00:29:23,790 --> 00:29:29,230
pipeline and so each time that this each

00:29:27,160 --> 00:29:31,930
time the decision service gets a

00:29:29,230 --> 00:29:34,450
transaction the analytics reporting

00:29:31,930 --> 00:29:36,100
database gets updated and also the you

00:29:34,450 --> 00:29:37,690
know the billing database note that a

00:29:36,100 --> 00:29:41,440
new transaction has arrived so at the

00:29:37,690 --> 00:29:44,560
end of the month we can create new

00:29:41,440 --> 00:29:46,810
invoice and so the first thing you can

00:29:44,560 --> 00:29:50,020
see that the different services have

00:29:46,810 --> 00:29:52,600
different latency or eventual

00:29:50,020 --> 00:29:54,310
consistency requirements and we're using

00:29:52,600 --> 00:29:58,450
the same data pipeline for all of them

00:29:54,310 --> 00:30:01,930
and after once or twice that the

00:29:58,450 --> 00:30:05,260
engineering got embarrassed by these

00:30:01,930 --> 00:30:07,450
kind of mistakes we try to perform a

00:30:05,260 --> 00:30:09,850
naive system test which basically what

00:30:07,450 --> 00:30:14,830
it does is you send a transaction and

00:30:09,850 --> 00:30:18,090
then you wait 15 seconds maybe 60 and

00:30:14,830 --> 00:30:20,200
then you query and each other of the

00:30:18,090 --> 00:30:23,080
services and want to check that their

00:30:20,200 --> 00:30:25,840
that their database is up-to-date and

00:30:23,080 --> 00:30:30,250
there's no embarrassing mistake so that

00:30:25,840 --> 00:30:32,410
this work no why because a synchronous

00:30:30,250 --> 00:30:34,630
data pipelines have hiccups sometimes

00:30:32,410 --> 00:30:36,280
you get like a burst of traffic and the

00:30:34,630 --> 00:30:38,530
queue start to fill up and then it

00:30:36,280 --> 00:30:42,460
doesn't take 15 seconds it takes 60

00:30:38,530 --> 00:30:45,820
seconds and that's okay this is this is

00:30:42,460 --> 00:30:47,620
a healthy state of the system but the

00:30:45,820 --> 00:30:51,010
but the tests fail so we can try to

00:30:47,620 --> 00:30:52,780
increase it to 660 seconds or 600

00:30:51,010 --> 00:30:54,730
seconds or patch it or whatever but

00:30:52,780 --> 00:30:59,470
you wouldn't get to the bottom of the

00:30:54,730 --> 00:31:02,140
problem so the real solution is another

00:30:59,470 --> 00:31:04,570
service that does reconciliation the

00:31:02,140 --> 00:31:07,660
reconciliation service has access to all

00:31:04,570 --> 00:31:11,830
three databases yeah okay

00:31:07,660 --> 00:31:13,420
all three databases and it just does

00:31:11,830 --> 00:31:17,580
different select statements for example

00:31:13,420 --> 00:31:20,260
select maximum time or select the latest

00:31:17,580 --> 00:31:23,650
transaction IDs and it just prepares

00:31:20,260 --> 00:31:25,330
them and issues another if something is

00:31:23,650 --> 00:31:28,120
wrong and in this service you can

00:31:25,330 --> 00:31:30,220
configure different SLA s for different

00:31:28,120 --> 00:31:32,500
databases and different services and you

00:31:30,220 --> 00:31:35,610
have much more flexibility and

00:31:32,500 --> 00:31:39,850
confidence in the results

00:31:35,610 --> 00:31:42,630
so the basic two problems you want to

00:31:39,850 --> 00:31:46,810
check is for missing data okay and

00:31:42,630 --> 00:31:49,720
referential integrity problems so think

00:31:46,810 --> 00:31:52,060
about transactional semantics some

00:31:49,720 --> 00:31:53,890
customers they issue an order and then

00:31:52,060 --> 00:31:55,600
they issue like an update someone

00:31:53,890 --> 00:31:57,610
decides to change the credit card and

00:31:55,600 --> 00:32:00,010
some other customers they issue an order

00:31:57,610 --> 00:32:02,800
then they cancel the old old order and

00:32:00,010 --> 00:32:05,200
then they issue a new different order

00:32:02,800 --> 00:32:09,310
but it's basically the same you know

00:32:05,200 --> 00:32:11,140
transaction and so this reconsider I

00:32:09,310 --> 00:32:13,990
need to know all this and make sure

00:32:11,140 --> 00:32:15,820
everything is in is in check basically

00:32:13,990 --> 00:32:18,250
it has only you know it's a green

00:32:15,820 --> 00:32:21,880
everything is okay red means there's a

00:32:18,250 --> 00:32:25,450
problem we need to fix it so and this is

00:32:21,880 --> 00:32:27,580
where we got we got really motivated we

00:32:25,450 --> 00:32:30,550
said why why should a human fix it maybe

00:32:27,580 --> 00:32:33,550
maybe we should have the reconciliate

00:32:30,550 --> 00:32:35,770
err fix the problems for us if it finds

00:32:33,550 --> 00:32:37,420
something wrong it should reach to the

00:32:35,770 --> 00:32:39,970
right service which is the system of

00:32:37,420 --> 00:32:42,910
record for this specific object and then

00:32:39,970 --> 00:32:44,410
resend it through the data pipeline so

00:32:42,910 --> 00:32:46,450
this is what what is called like

00:32:44,410 --> 00:32:49,060
generally in control theory a feedback

00:32:46,450 --> 00:32:51,640
loop and after this lecture I invite you

00:32:49,060 --> 00:32:53,320
to log into Wikipedia on Donita login

00:32:51,640 --> 00:32:55,800
just go to Wikipedia and look for

00:32:53,320 --> 00:32:59,200
positive feedback this is one of the

00:32:55,800 --> 00:33:01,300
most scary reads you would ever have it

00:32:59,200 --> 00:33:05,410
talks about total system meltdown and

00:33:01,300 --> 00:33:09,549
and you know Armageddon

00:33:05,410 --> 00:33:11,500
and this is why imagine that analytic

00:33:09,549 --> 00:33:13,750
service takes 100 milliseconds to

00:33:11,500 --> 00:33:15,370
process the transactions usually and if

00:33:13,750 --> 00:33:17,950
it's a really really big transactions

00:33:15,370 --> 00:33:20,919
they take ten times let's say one second

00:33:17,950 --> 00:33:23,470
and so usually no one cares right now

00:33:20,919 --> 00:33:25,510
once once every few hours you get a

00:33:23,470 --> 00:33:27,040
really big transaction or even once

00:33:25,510 --> 00:33:29,559
every minute it doesn't really affect

00:33:27,040 --> 00:33:31,840
the effect the performance of the

00:33:29,559 --> 00:33:35,799
analytic service but let's say you had a

00:33:31,840 --> 00:33:38,260
bug that all the big transactions failed

00:33:35,799 --> 00:33:41,470
and the data reconciliation service

00:33:38,260 --> 00:33:44,830
decides to resend all these big

00:33:41,470 --> 00:33:47,770
transactions again effectively it clogs

00:33:44,830 --> 00:33:49,900
the analytic service and then there are

00:33:47,770 --> 00:33:52,360
more missing transactions right positive

00:33:49,900 --> 00:33:54,730
feedback and the reconsider tries to

00:33:52,360 --> 00:33:59,470
send more and more again and again and

00:33:54,730 --> 00:34:01,809
again and again yeah so this is this is

00:33:59,470 --> 00:34:05,470
what that Wikipedia article meant about

00:34:01,809 --> 00:34:10,270
total meltdown and obviously it happened

00:34:05,470 --> 00:34:12,369
to us once so what do you do you keep on

00:34:10,270 --> 00:34:15,480
reading in the Wikipedia article and it

00:34:12,369 --> 00:34:17,830
says what you need to do is filtering

00:34:15,480 --> 00:34:20,350
limiting damping and negative feedback

00:34:17,830 --> 00:34:22,540
it doesn't explain what these means so

00:34:20,350 --> 00:34:24,820
let's try to think together filtering

00:34:22,540 --> 00:34:27,730
means you don't need to fix everything

00:34:24,820 --> 00:34:29,139
some objects it's okay that would you

00:34:27,730 --> 00:34:31,659
know be out of sync they have no

00:34:29,139 --> 00:34:35,020
business meaning probably some kind of

00:34:31,659 --> 00:34:38,800
internal flags test data or something

00:34:35,020 --> 00:34:41,409
like that limiting means that you don't

00:34:38,800 --> 00:34:45,879
try to fix the same problem more than

00:34:41,409 --> 00:34:48,340
once okay makes sense damping do you

00:34:45,879 --> 00:34:52,750
remember damping from auto scaling group

00:34:48,340 --> 00:34:55,780
cinemas on damping means yeah damping

00:34:52,750 --> 00:34:56,830
means that once you fix a problem you

00:34:55,780 --> 00:34:59,619
wait for five minutes

00:34:56,830 --> 00:35:02,730
don't do anything whatever you do don't

00:34:59,619 --> 00:35:05,140
do anything that's damping so this

00:35:02,730 --> 00:35:07,270
reduces the positive feedback and the

00:35:05,140 --> 00:35:09,580
last time this is like that the best

00:35:07,270 --> 00:35:11,800
solution and the most difficult one is

00:35:09,580 --> 00:35:13,240
negative feedback so the way you could

00:35:11,800 --> 00:35:15,180
implement negative feedback is by

00:35:13,240 --> 00:35:18,920
monitoring than a

00:35:15,180 --> 00:35:21,990
service and if it's if it's unhealthy

00:35:18,920 --> 00:35:24,329
then you don't try to fix it by sending

00:35:21,990 --> 00:35:25,829
more data so the simplest way to

00:35:24,329 --> 00:35:28,920
implement it is just to look at the

00:35:25,829 --> 00:35:30,510
input queue okay of this then oolitic

00:35:28,920 --> 00:35:33,569
service and if it's above a certain

00:35:30,510 --> 00:35:36,750
threshold the reconciler reconciliation

00:35:33,569 --> 00:35:38,579
service needs to wait okay do nothing

00:35:36,750 --> 00:35:41,430
until the analytic service is healthy

00:35:38,579 --> 00:35:43,980
again and then you know slowly but

00:35:41,430 --> 00:35:46,920
surely keep on sending new data and then

00:35:43,980 --> 00:35:49,530
it works okay and this is how you know

00:35:46,920 --> 00:35:52,559
if the to wrap things up this is how we

00:35:49,530 --> 00:35:56,510
gain more confidence in our data in our

00:35:52,559 --> 00:36:00,329
system so we'll take questions not right

00:35:56,510 --> 00:36:02,670
if you want if it was like a little bit

00:36:00,329 --> 00:36:04,980
too fast everything I've just said we

00:36:02,670 --> 00:36:09,410
published it yesterday in our tech blog

00:36:04,980 --> 00:36:12,809
so feel free to check it out yeah okay

00:36:09,410 --> 00:36:14,819
so the question is how come the two

00:36:12,809 --> 00:36:16,200
versions can basically work under the

00:36:14,819 --> 00:36:21,710
same assumptions right with the same

00:36:16,200 --> 00:36:21,710
databases or the same the same state

00:36:24,240 --> 00:36:41,170
kind of yeah so here's the thing both

00:36:39,339 --> 00:36:42,880
the effective version of the green

00:36:41,170 --> 00:36:44,589
version and I'm sorry the blue version

00:36:42,880 --> 00:36:47,740
and the green version they both use the

00:36:44,589 --> 00:36:51,609
same databases exactly okay for reading

00:36:47,740 --> 00:36:53,920
at least and so maybe the green version

00:36:51,609 --> 00:36:55,809
changed something and then when the blue

00:36:53,920 --> 00:36:58,750
version tries to handle the same

00:36:55,809 --> 00:37:01,240
transaction again it wouldn't see the

00:36:58,750 --> 00:37:04,210
same state that it would have if it were

00:37:01,240 --> 00:37:06,130
the green version right this is is this

00:37:04,210 --> 00:37:09,490
a scenario talking about because like

00:37:06,130 --> 00:37:13,539
it's not a fair comparison and so yeah

00:37:09,490 --> 00:37:17,680
it's true in this specific service this

00:37:13,539 --> 00:37:20,920
is how it works so we try to ignore some

00:37:17,680 --> 00:37:22,390
of the hints that was left by the the

00:37:20,920 --> 00:37:24,670
green environment when we run the blue

00:37:22,390 --> 00:37:27,700
environment but as for caching and for

00:37:24,670 --> 00:37:29,500
some of the more deep analysis the blue

00:37:27,700 --> 00:37:32,019
environment sometimes is even faster and

00:37:29,500 --> 00:37:34,029
you know it's much easier for it to work

00:37:32,019 --> 00:37:36,579
because all of the hard work and all the

00:37:34,029 --> 00:37:40,359
caches know that state changes probably

00:37:36,579 --> 00:37:42,430
hinted what the right answer is for the

00:37:40,359 --> 00:37:47,410
blue version so actually the blue

00:37:42,430 --> 00:37:50,529
version has a better better chance of

00:37:47,410 --> 00:37:53,769
getting the right answer than the green

00:37:50,529 --> 00:37:55,089
version because most of the answers to

00:37:53,769 --> 00:37:57,549
most of the questions about the

00:37:55,089 --> 00:38:00,369
transactions are already in the database

00:37:57,549 --> 00:38:02,079
and so yeah you you're not comparing

00:38:00,369 --> 00:38:04,569
apples to apples but this is the best we

00:38:02,079 --> 00:38:06,400
have there you need to me ticketing in

00:38:04,569 --> 00:38:08,470
your code we're trying to we're trying

00:38:06,400 --> 00:38:10,990
to make this effective struggle as you

00:38:08,470 --> 00:38:12,819
know as light as possible and we just

00:38:10,990 --> 00:38:16,329
say okay if it's if it's not a big

00:38:12,819 --> 00:38:22,170
change then and we will just let the new

00:38:16,329 --> 00:38:22,170
version through yeah

00:38:25,870 --> 00:38:30,770
okay yeah so I skipped a few slides if

00:38:28,400 --> 00:38:36,020
you saw one of them is that your

00:38:30,770 --> 00:38:38,840
engineering peers will most likely be

00:38:36,020 --> 00:38:40,820
against breaking the isolation barriers

00:38:38,840 --> 00:38:42,770
between different micro-services and

00:38:40,820 --> 00:38:44,360
this is true it just makes the

00:38:42,770 --> 00:38:47,210
reconciliation code easier just to

00:38:44,360 --> 00:38:49,490
select mocks whatever and so what we do

00:38:47,210 --> 00:38:52,700
to me to get that we require unified

00:38:49,490 --> 00:38:55,850
schema repository so if one database has

00:38:52,700 --> 00:38:58,220
a column called tenant ID and it's an

00:38:55,850 --> 00:38:59,930
integer the other the other database

00:38:58,220 --> 00:39:02,660
would not call it tenant number and make

00:38:59,930 --> 00:39:04,400
it a string okay and then same thing for

00:39:02,660 --> 00:39:07,280
x times that you have like the customer

00:39:04,400 --> 00:39:09,680
x time our x time update times them

00:39:07,280 --> 00:39:12,230
cancel time stamp all that so all have

00:39:09,680 --> 00:39:15,940
need to have the same name and the same

00:39:12,230 --> 00:39:17,720
type and so at least you are somewhat

00:39:15,940 --> 00:39:19,040
decoupled from some of the

00:39:17,720 --> 00:39:20,960
implementation but it's just so much

00:39:19,040 --> 00:39:23,320
easier to write it with one sequel

00:39:20,960 --> 00:39:29,750
statement then no or elastic search

00:39:23,320 --> 00:39:32,840
query and it's worth it so what Ellie

00:39:29,750 --> 00:39:36,230
asked is about how how do you make sure

00:39:32,840 --> 00:39:38,900
that Reconciliation service does what it

00:39:36,230 --> 00:39:40,550
actually needs to do so the

00:39:38,900 --> 00:39:42,110
reconciliation service is the test

00:39:40,550 --> 00:39:45,670
itself if you want to write a test on

00:39:42,110 --> 00:39:47,690
top of the test you could but

00:39:45,670 --> 00:39:51,260
reconciliation service requires a lot of

00:39:47,690 --> 00:39:53,480
experience Perriman tation and so at

00:39:51,260 --> 00:39:55,610
first you started like with like dry

00:39:53,480 --> 00:39:58,220
mode we just outputs what it what it

00:39:55,610 --> 00:40:00,470
would have done you basically test it in

00:39:58,220 --> 00:40:02,870
production you could write tests for the

00:40:00,470 --> 00:40:04,790
tests for the tests but at some point

00:40:02,870 --> 00:40:06,590
you need a you need to stop so the

00:40:04,790 --> 00:40:08,450
reconciliation service basically looks

00:40:06,590 --> 00:40:11,240
very much like the system test it just

00:40:08,450 --> 00:40:14,240
it just continues and it has the

00:40:11,240 --> 00:40:16,250
specific service configuration and has

00:40:14,240 --> 00:40:20,030
direct access to the databases of the

00:40:16,250 --> 00:40:23,150
implementation looks very similar it's

00:40:20,030 --> 00:40:26,090
it's even simpler so there there's less

00:40:23,150 --> 00:40:29,000
chance of a bug there but yeah it

00:40:26,090 --> 00:40:29,840
requires some experimentation okay thank

00:40:29,000 --> 00:40:34,260
you very much

00:40:29,840 --> 00:40:39,389
[Applause]

00:40:34,260 --> 00:40:39,389

YouTube URL: https://www.youtube.com/watch?v=Ni0YUpZgcng


