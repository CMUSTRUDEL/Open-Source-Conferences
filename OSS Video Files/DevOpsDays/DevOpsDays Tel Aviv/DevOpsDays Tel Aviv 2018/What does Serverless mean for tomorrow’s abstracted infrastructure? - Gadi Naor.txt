Title: What does Serverless mean for tomorrow’s abstracted infrastructure? - Gadi Naor
Publication date: 2019-01-03
Playlist: DevOpsDays Tel Aviv 2018
Description: 
	DevOpsDays Tel Aviv 2018

In this presentation we will take a deeper look into the teams tasked with making sure that serverless’ main advantage - focusing on application development — is guaranteed. We will also discuss key steps need to follow to ensure their cloud environments are fully operational, configured and secured.
Captions: 
	00:00:05,750 --> 00:00:12,929
as local table Coulomb and some actually

00:00:09,510 --> 00:00:16,619
sir after may like my my little DevOps

00:00:12,929 --> 00:00:19,830
days sponsor animal Aloha a schmee

00:00:16,619 --> 00:00:22,650
gardener and the city of had a founder

00:00:19,830 --> 00:00:24,029
in a curve lab shame I'll see the of a

00:00:22,650 --> 00:00:27,029
hominid waiting at the Bell

00:00:24,029 --> 00:00:29,070
Alma's dimeric tortured serverless be

00:00:27,029 --> 00:00:32,579
Muslim Albertson Assad Elsie obstruct

00:00:29,070 --> 00:00:35,880
SIA aimlessly botulinum as metaldehyde

00:00:32,579 --> 00:00:38,399
and redeem at collate were not able all

00:00:35,880 --> 00:00:40,739
inertial a team valerian Aleta ethically

00:00:38,399 --> 00:00:44,040
comic initials day I was Emma Vito a

00:00:40,739 --> 00:00:48,300
mono monitor in sexual film appear to us

00:00:44,040 --> 00:00:50,129
a volley testing a Motoko / ROTC of a

00:00:48,300 --> 00:00:52,820
gamma man among add volume security

00:00:50,129 --> 00:00:55,710
become eliminates me and me Tel Aviv

00:00:52,820 --> 00:00:57,750
machinery loss section is a technology

00:00:55,710 --> 00:00:59,660
of the code aim the skateboard and in

00:00:57,750 --> 00:01:02,430
Cavell assorted a channeler Holloway had

00:00:59,660 --> 00:01:04,860
been times of it BC there at the moving

00:01:02,430 --> 00:01:06,900
force out live or not as the the local

00:01:04,860 --> 00:01:10,439
I'm advocates official artery motel

00:01:06,900 --> 00:01:13,770
Malaika shall you security Maxima Nicole

00:01:10,439 --> 00:01:17,280
hi I'm Val a em live note my name is a

00:01:13,770 --> 00:01:19,200
VPN firewall in my PS seem very kosher

00:01:17,280 --> 00:01:22,290
home to llamas Amidala barely make out

00:01:19,200 --> 00:01:24,990
the cloud will a cloud native em hibachi

00:01:22,290 --> 00:01:27,479
a solution vanity bar volume they of

00:01:24,990 --> 00:01:29,610
Camille globulin Vanden Borre Motel much

00:01:27,479 --> 00:01:31,740
affected daily mode mode mad girl I owe

00:01:29,610 --> 00:01:34,680
money Bates Amharic mr. washee-washee

00:01:31,740 --> 00:01:37,049
Bona aims maho-chan microservice

00:01:34,680 --> 00:01:39,210
firewall Mohammed CAD mode kaliesha dot

00:01:37,049 --> 00:01:40,710
gamma so data segmentation hook

00:01:39,210 --> 00:01:44,189
technique abuser by spectrum shell

00:01:40,710 --> 00:01:46,649
several s eval gonzo melanoma election

00:01:44,189 --> 00:01:49,770
officials had varam a mod mod more team

00:01:46,649 --> 00:01:54,890
Jim Nasim no furniture she blew shot Eva

00:01:49,770 --> 00:01:57,899
Holland got a mahaki my name but washi

00:01:54,890 --> 00:02:00,840
Nicolas de haut it all right so going

00:01:57,899 --> 00:02:03,600
back to these nice drawings of our

00:02:00,840 --> 00:02:05,369
day-to-day life with micro services so

00:02:03,600 --> 00:02:07,259
essentially when we move into micro

00:02:05,369 --> 00:02:09,750
services we break down the entire

00:02:07,259 --> 00:02:12,819
monolith that we were part of basically

00:02:09,750 --> 00:02:15,459
building for many for many many years or

00:02:12,819 --> 00:02:16,689
or our minds depends on how all these

00:02:15,459 --> 00:02:18,370
the company that you work for the

00:02:16,689 --> 00:02:20,519
project that you work for but

00:02:18,370 --> 00:02:23,519
essentially when you break it down you

00:02:20,519 --> 00:02:25,930
employ multiple components that are

00:02:23,519 --> 00:02:29,709
necessarily distributed to support scale

00:02:25,930 --> 00:02:32,049
sometimes we are let's say digressing

00:02:29,709 --> 00:02:34,569
into spending infrastructure over

00:02:32,049 --> 00:02:38,230
multiple regions multiple availability

00:02:34,569 --> 00:02:40,239
zones for sure but if you go multi cloud

00:02:38,230 --> 00:02:42,489
or any advanced use cases like that

00:02:40,239 --> 00:02:44,469
it becomes extremely complex to even

00:02:42,489 --> 00:02:47,349
control all the moving parts that you

00:02:44,469 --> 00:02:49,599
have at your hand and it's not only the

00:02:47,349 --> 00:02:52,329
operational side of things but also on

00:02:49,599 --> 00:02:54,069
the test side and on the operational of

00:02:52,329 --> 00:02:56,620
course but the application monitoring

00:02:54,069 --> 00:02:59,199
and security becomes an extremely

00:02:56,620 --> 00:03:01,090
complex just think about even the simple

00:02:59,199 --> 00:03:03,699
thing as firewalls we used to have

00:03:01,090 --> 00:03:05,199
firewalls at the edge and now once

00:03:03,699 --> 00:03:07,719
everything is running inside with one

00:03:05,199 --> 00:03:10,150
hop from the cloud to the outside world

00:03:07,719 --> 00:03:12,909
firewalls are not the very effective way

00:03:10,150 --> 00:03:15,870
to kind of build a perimeter around the

00:03:12,909 --> 00:03:18,370
moving parts and when you go server less

00:03:15,870 --> 00:03:21,009
when it comes to service it really

00:03:18,370 --> 00:03:23,409
defines new perimeter oftentimes we are

00:03:21,009 --> 00:03:26,590
running our entire infrastructure fully

00:03:23,409 --> 00:03:29,109
hosted over the cloud provider and there

00:03:26,590 --> 00:03:31,989
is a balance between whether we are in

00:03:29,109 --> 00:03:33,879
control versus are we managing

00:03:31,989 --> 00:03:37,150
infrastructure which both of them has

00:03:33,879 --> 00:03:39,370
pros and cons and in this talk I'm going

00:03:37,150 --> 00:03:41,579
to kind of give you the check and

00:03:39,370 --> 00:03:44,139
balance between what does it mean to run

00:03:41,579 --> 00:03:46,030
fully hosted using servers

00:03:44,139 --> 00:03:48,879
infrastructure but on the other hand I

00:03:46,030 --> 00:03:51,159
will show you some examples of how we do

00:03:48,879 --> 00:03:52,769
similar things with fully managed

00:03:51,159 --> 00:03:57,370
infrastructure that does give you

00:03:52,769 --> 00:03:59,620
service service programming environment

00:03:57,370 --> 00:04:01,000
when you think about the span of the

00:03:59,620 --> 00:04:03,129
problem that we're dealing with on our

00:04:01,000 --> 00:04:06,239
day to day development life cycles and

00:04:03,129 --> 00:04:09,609
the infinite loop here really manifests

00:04:06,239 --> 00:04:12,699
the challenges the developer have by

00:04:09,609 --> 00:04:14,979
building the code testing it and then

00:04:12,699 --> 00:04:17,139
continuously deploying that into

00:04:14,979 --> 00:04:19,419
production release releasing that into

00:04:17,139 --> 00:04:22,210
production it can be differential

00:04:19,419 --> 00:04:25,090
updates just updating a single micro

00:04:22,210 --> 00:04:26,740
service or a single service and at the

00:04:25,090 --> 00:04:28,630
end of the day when you think about it

00:04:26,740 --> 00:04:31,030
I'm service is just an application

00:04:28,630 --> 00:04:33,330
vehicle we can implement it using

00:04:31,030 --> 00:04:37,479
containers we can you implement it using

00:04:33,330 --> 00:04:40,419
bare metal or even VMs but necessarily

00:04:37,479 --> 00:04:42,460
these are all application vehicles for

00:04:40,419 --> 00:04:44,949
our code in our business functionality

00:04:42,460 --> 00:04:47,349
now the challenge around each and every

00:04:44,949 --> 00:04:49,660
one of those steps is how do we make

00:04:47,349 --> 00:04:54,630
sure that we build the system from day

00:04:49,660 --> 00:04:57,130
one to be operational friendly and to be

00:04:54,630 --> 00:04:58,479
verified from a security standpoint and

00:04:57,130 --> 00:05:01,900
the verification from the security

00:04:58,479 --> 00:05:04,539
standpoint can start with view scanning

00:05:01,900 --> 00:05:06,520
your code for vulnerabilities you making

00:05:04,539 --> 00:05:09,069
sure that your software supply chain is

00:05:06,520 --> 00:05:12,789
coming from trusted sources and we all

00:05:09,069 --> 00:05:15,340
heard about the recent nodejs commits of

00:05:12,789 --> 00:05:17,470
attackers into the repositories

00:05:15,340 --> 00:05:19,750
themselves so out of the gate you are

00:05:17,470 --> 00:05:23,199
actually put or potentially bringing in

00:05:19,750 --> 00:05:25,500
code that can contain something that is

00:05:23,199 --> 00:05:27,639
not of the original intent of the

00:05:25,500 --> 00:05:31,900
developer so we are going to touch on

00:05:27,639 --> 00:05:34,300
those four kind of area and with a focus

00:05:31,900 --> 00:05:39,610
on both the developer the operation and

00:05:34,300 --> 00:05:43,719
the security side so wow this is all

00:05:39,610 --> 00:05:46,210
right so when we think about service and

00:05:43,719 --> 00:05:48,280
service architecture we can think about

00:05:46,210 --> 00:05:51,669
from an operational standpoint meaning

00:05:48,280 --> 00:05:54,430
no service fully managed security think

00:05:51,669 --> 00:05:57,969
about lambda is kind of the go-to use

00:05:54,430 --> 00:05:59,979
case for service but RDS or any fully

00:05:57,969 --> 00:06:01,599
managed service that you are not

00:05:59,979 --> 00:06:04,060
actually managing the underlying

00:06:01,599 --> 00:06:07,300
infrastructure would fit into that model

00:06:04,060 --> 00:06:09,340
but servers can be just as much as a

00:06:07,300 --> 00:06:11,650
programming model what does it mean it

00:06:09,340 --> 00:06:14,280
means that it's service based we're

00:06:11,650 --> 00:06:17,650
thinking about application as an

00:06:14,280 --> 00:06:19,630
aggregation of services that have strong

00:06:17,650 --> 00:06:22,330
API boundaries between the different

00:06:19,630 --> 00:06:25,210
services and then those services are

00:06:22,330 --> 00:06:27,400
either triggered by user request by

00:06:25,210 --> 00:06:29,650
events and the underlying infrastructure

00:06:27,400 --> 00:06:32,680
to drive this can be message queues can

00:06:29,650 --> 00:06:34,690
be emails could be text message or

00:06:32,680 --> 00:06:36,250
whatever but at the end of the day when

00:06:34,690 --> 00:06:38,139
you think about the programming model

00:06:36,250 --> 00:06:40,150
this is something that is very powerful

00:06:38,139 --> 00:06:40,810
for the development team because

00:06:40,150 --> 00:06:43,690
essentially

00:06:40,810 --> 00:06:45,400
we broke down the application into

00:06:43,690 --> 00:06:47,620
multiple microservices and teams can

00:06:45,400 --> 00:06:50,200
move in parallel so as long as they are

00:06:47,620 --> 00:06:52,540
keeping very strong isolation on one of

00:06:50,200 --> 00:06:54,610
the api's are we changing API is

00:06:52,540 --> 00:06:57,940
responsibly meaning that we do not

00:06:54,610 --> 00:07:00,700
modify semantics or syntax but on the

00:06:57,940 --> 00:07:02,740
other hand we do preserve our backward

00:07:00,700 --> 00:07:06,910
compatibility between the different

00:07:02,740 --> 00:07:10,510
micro services and the API boundaries so

00:07:06,910 --> 00:07:13,690
when we go into the service operational

00:07:10,510 --> 00:07:16,210
model we think about what what is it

00:07:13,690 --> 00:07:19,080
that challenges the most once we go into

00:07:16,210 --> 00:07:22,570
like fully managed infrastructure and

00:07:19,080 --> 00:07:25,990
the first thing that you meet when it

00:07:22,570 --> 00:07:27,940
comes to service is testing testing

00:07:25,990 --> 00:07:30,130
under service infrastructure means that

00:07:27,940 --> 00:07:33,700
you need to build an abstraction between

00:07:30,130 --> 00:07:36,970
how your work how your code is working

00:07:33,700 --> 00:07:39,460
on one hand and how things or elements

00:07:36,970 --> 00:07:41,350
or events are triggering that code so

00:07:39,460 --> 00:07:44,020
the abstraction is extremely complex

00:07:41,350 --> 00:07:46,300
think about even about lambda lambda is

00:07:44,020 --> 00:07:49,990
a time box machine we have no control

00:07:46,300 --> 00:07:53,070
where it's running you have some control

00:07:49,990 --> 00:07:55,690
on what is the duration of the lambda

00:07:53,070 --> 00:07:59,320
runtime and then when you think about

00:07:55,690 --> 00:08:01,030
how do you debug lambda applications or

00:07:59,320 --> 00:08:03,010
service applications at our time books

00:08:01,030 --> 00:08:04,600
how do you monitor those applications

00:08:03,010 --> 00:08:07,419
what do you do if you have a security

00:08:04,600 --> 00:08:10,419
event on one of the lambda invocations

00:08:07,419 --> 00:08:12,340
that in a minute from now there is not

00:08:10,419 --> 00:08:14,830
really something that you can log into a

00:08:12,340 --> 00:08:17,410
server or even do that I don't know if

00:08:14,830 --> 00:08:20,320
any any of you open the reverse shell

00:08:17,410 --> 00:08:23,320
into a lambda it's a pretty restricted

00:08:20,320 --> 00:08:25,090
environment you cannot do a lot in terms

00:08:23,320 --> 00:08:27,190
of actually understanding what's

00:08:25,090 --> 00:08:31,390
happening on the inside but on the other

00:08:27,190 --> 00:08:33,159
hand think about kind of the go-to best

00:08:31,390 --> 00:08:36,430
practices that you do as a developers

00:08:33,159 --> 00:08:38,620
setting up at a comfort zone of the

00:08:36,430 --> 00:08:41,380
bugging infrastructure is kind of the

00:08:38,620 --> 00:08:44,350
first thing that you do as a developer

00:08:41,380 --> 00:08:47,680
so these challenges once you go into

00:08:44,350 --> 00:08:50,339
lambda it pretty much shaped the world

00:08:47,680 --> 00:08:53,110
that you know on a day to day basis and

00:08:50,339 --> 00:08:54,490
the same challenges apply once you think

00:08:53,110 --> 00:08:58,060
about monitoring

00:08:54,490 --> 00:09:00,640
and I will touch about that in in the

00:08:58,060 --> 00:09:03,100
next few slides so let's talk a little

00:09:00,640 --> 00:09:06,730
bit about the testing strategies and and

00:09:03,100 --> 00:09:08,860
what are they so if I'll take an example

00:09:06,730 --> 00:09:13,690
of an open source project recently

00:09:08,860 --> 00:09:15,940
presented in three invent this Soleil

00:09:13,690 --> 00:09:17,200
fire if I pronounced it correctly it

00:09:15,940 --> 00:09:19,690
means I'm sorry

00:09:17,200 --> 00:09:21,430
think about mobile application where you

00:09:19,690 --> 00:09:25,690
want to collect arrows from the mobile

00:09:21,430 --> 00:09:29,230
application in your edge API collector

00:09:25,690 --> 00:09:32,920
API is basically a lambda function that

00:09:29,230 --> 00:09:35,620
you ingest in bound different events and

00:09:32,920 --> 00:09:39,640
those events are basically I'm coming on

00:09:35,620 --> 00:09:41,890
SN topics as based on that of propagate

00:09:39,640 --> 00:09:44,320
that into a persistent storage you can

00:09:41,890 --> 00:09:47,560
propagate metrics you can propagate it

00:09:44,320 --> 00:09:50,620
into an s3 bucket so think about what

00:09:47,560 --> 00:09:52,830
would it take to actually build the

00:09:50,620 --> 00:09:56,399
testing environment or the function that

00:09:52,830 --> 00:10:00,220
implements the internal side where it

00:09:56,399 --> 00:10:04,540
routes the different logs and errors

00:10:00,220 --> 00:10:06,490
into the different persistent storage so

00:10:04,540 --> 00:10:08,649
when you build this function you

00:10:06,490 --> 00:10:10,510
essentially need to define a very strong

00:10:08,649 --> 00:10:12,550
boundaries of what's coming into the

00:10:10,510 --> 00:10:16,779
function so you can actually mock it

00:10:12,550 --> 00:10:18,279
using a local triggering mechanism so

00:10:16,779 --> 00:10:20,770
essentially what you can do at the end

00:10:18,279 --> 00:10:24,010
of the day is run that locally using

00:10:20,770 --> 00:10:27,750
docker lambda or any of the local

00:10:24,010 --> 00:10:30,850
testing tools for for lambda and then

00:10:27,750 --> 00:10:32,410
anything that goes out of function into

00:10:30,850 --> 00:10:34,870
the persistent storage is something that

00:10:32,410 --> 00:10:37,870
you also want to build an abstraction

00:10:34,870 --> 00:10:40,240
for so whether it is an s3 or whether

00:10:37,870 --> 00:10:41,470
this is a database at the end of the day

00:10:40,240 --> 00:10:44,230
you want to make sure that you can

00:10:41,470 --> 00:10:46,300
activate your function using those

00:10:44,230 --> 00:10:48,730
abstraction and understand what is

00:10:46,300 --> 00:10:51,610
happening inside a function from both

00:10:48,730 --> 00:10:54,160
the functionality per the functionality

00:10:51,610 --> 00:10:56,350
perspective meaning that we want to make

00:10:54,160 --> 00:10:58,320
sure that the happy path is really happy

00:10:56,350 --> 00:11:01,450
and everything is happening as expected

00:10:58,320 --> 00:11:02,800
but going to the other side is how do

00:11:01,450 --> 00:11:05,529
you make sure that from a security

00:11:02,800 --> 00:11:08,360
standpoint you can securely test your

00:11:05,529 --> 00:11:11,540
code you can try to manipulate the API

00:11:08,360 --> 00:11:14,300
as using fuzzing meaning that we try

00:11:11,540 --> 00:11:16,910
different input mechanisms different

00:11:14,300 --> 00:11:19,519
inputs into the API boundaries and

00:11:16,910 --> 00:11:23,089
making sure that the outcome is as

00:11:19,519 --> 00:11:24,529
expected and the testing part is

00:11:23,089 --> 00:11:27,140
something that is really challenging

00:11:24,529 --> 00:11:29,019
from a developer standpoint because we

00:11:27,140 --> 00:11:31,910
need to develop out-of-the-box

00:11:29,019 --> 00:11:34,250
very strong API boundaries and actually

00:11:31,910 --> 00:11:36,620
build a mock for every each and one of

00:11:34,250 --> 00:11:38,329
the micro services that we deploy so it

00:11:36,620 --> 00:11:41,089
is an overhead from a development

00:11:38,329 --> 00:11:44,149
standpoint but on the other hand these

00:11:41,089 --> 00:11:48,170
are very good development practices try

00:11:44,149 --> 00:11:49,820
to define those boundaries and api's not

00:11:48,170 --> 00:11:53,290
to mention that if you get to do the

00:11:49,820 --> 00:11:56,329
security testing early on with your

00:11:53,290 --> 00:11:57,709
development practices then it really

00:11:56,329 --> 00:12:03,260
gives you a handle of what will happen

00:11:57,709 --> 00:12:06,200
in the production so when we think about

00:12:03,260 --> 00:12:08,990
local testing there are I listed just

00:12:06,200 --> 00:12:10,519
two of the kind of tools that are out

00:12:08,990 --> 00:12:13,010
there for local testing there are many

00:12:10,519 --> 00:12:15,410
tools some of them are coming from the

00:12:13,010 --> 00:12:17,750
cloud providers and some of them are

00:12:15,410 --> 00:12:20,540
open source projects that are basically

00:12:17,750 --> 00:12:24,620
enable you to test locally what you are

00:12:20,540 --> 00:12:28,750
running the next kind of and let me skip

00:12:24,620 --> 00:12:31,459
to the original slide of micro services

00:12:28,750 --> 00:12:34,760
think about who think about monitoring

00:12:31,459 --> 00:12:37,519
and tracing issues in production when it

00:12:34,760 --> 00:12:41,240
comes to distributed environment it's

00:12:37,519 --> 00:12:44,390
not particular to service as in general

00:12:41,240 --> 00:12:46,699
this is a general problem that is

00:12:44,390 --> 00:12:49,250
associated with distributed systems and

00:12:46,699 --> 00:12:52,760
micro services as an implementation of

00:12:49,250 --> 00:12:54,470
distributed system you have originally

00:12:52,760 --> 00:12:56,480
we had the monolith server we had a

00:12:54,470 --> 00:12:59,570
two-tier application it was quite simple

00:12:56,480 --> 00:13:02,899
to understand if something is busy

00:12:59,570 --> 00:13:05,120
looping on the API server or it was busy

00:13:02,899 --> 00:13:06,920
looping on on transaction to the

00:13:05,120 --> 00:13:09,290
database or the queries to the database

00:13:06,920 --> 00:13:11,060
are inefficient think about the

00:13:09,290 --> 00:13:15,079
transaction that need to traverse

00:13:11,060 --> 00:13:19,930
multiple micro services it might go in

00:13:15,079 --> 00:13:22,310
through an Kafka message broker or SNS

00:13:19,930 --> 00:13:25,220
queuing and a deal

00:13:22,310 --> 00:13:28,040
of the day thinking about what is the

00:13:25,220 --> 00:13:30,560
user impact when it goes to int when it

00:13:28,040 --> 00:13:33,370
comes to tracing is something that is it

00:13:30,560 --> 00:13:36,080
is extremely complex to actually

00:13:33,370 --> 00:13:38,450
understand what is happening take that

00:13:36,080 --> 00:13:40,220
notion into server less you don't even

00:13:38,450 --> 00:13:42,890
have control where the code is running

00:13:40,220 --> 00:13:45,620
so if you could login to a server and

00:13:42,890 --> 00:13:47,540
understand what is going on from a

00:13:45,620 --> 00:13:50,120
troubleshooting perspective or you could

00:13:47,540 --> 00:13:52,490
scale down your entire application into

00:13:50,120 --> 00:13:54,860
something that is running with replica

00:13:52,490 --> 00:13:57,470
level of 1 then you could actually do

00:13:54,860 --> 00:14:02,360
some debugging and understand along the

00:13:57,470 --> 00:14:06,230
way what was breaking so luckily enough

00:14:02,360 --> 00:14:08,600
there is a new framework or relatively

00:14:06,230 --> 00:14:11,089
new standard around tracing and

00:14:08,600 --> 00:14:14,750
monitoring which basically called open

00:14:11,089 --> 00:14:17,150
tracing it is sponsored by the CNC F

00:14:14,750 --> 00:14:20,410
which is basically the umbrella project

00:14:17,150 --> 00:14:23,420
that kubernetes and East EO and many

00:14:20,410 --> 00:14:26,300
well adopted open-source projects are

00:14:23,420 --> 00:14:28,900
basically employing and at the end of

00:14:26,300 --> 00:14:34,160
the day what it gives us it gives us the

00:14:28,900 --> 00:14:36,950
framework the API definitions of how do

00:14:34,160 --> 00:14:39,710
we collect telemetry from micro services

00:14:36,950 --> 00:14:44,300
that span across multiple transactions

00:14:39,710 --> 00:14:46,370
by associating a specific ID and and I I

00:14:44,300 --> 00:14:48,950
would I would like quickly asked like

00:14:46,370 --> 00:14:50,960
which one of you associate IDs with

00:14:48,950 --> 00:14:55,040
their debug.trace logs to actually

00:14:50,960 --> 00:14:56,660
search them afterwards in production it

00:14:55,040 --> 00:15:00,230
should be most of us that are doing that

00:14:56,660 --> 00:15:02,780
practice open tracing gives you exactly

00:15:00,230 --> 00:15:05,420
that essentially it gives you to

00:15:02,780 --> 00:15:08,360
associate a transaction ID with HTTP

00:15:05,420 --> 00:15:10,790
requests and over time it will expand

00:15:08,360 --> 00:15:12,980
into additional protocols and then you

00:15:10,790 --> 00:15:15,500
can trace the span meaning that the

00:15:12,980 --> 00:15:18,470
entire micro service transactions across

00:15:15,500 --> 00:15:22,250
the different micro services and give

00:15:18,470 --> 00:15:25,070
you essentially inside of what exactly

00:15:22,250 --> 00:15:27,230
is happening from an operational

00:15:25,070 --> 00:15:31,540
perspective meaning how many time we

00:15:27,230 --> 00:15:34,840
spend in micro service a B or or C and

00:15:31,540 --> 00:15:37,860
let's see an example of

00:15:34,840 --> 00:15:41,020
how we do that one thing to note this is

00:15:37,860 --> 00:15:42,880
when we go into service applications

00:15:41,020 --> 00:15:45,760
meaning that we are not doing anything

00:15:42,880 --> 00:15:48,310
like sto or service mesh or any of those

00:15:45,760 --> 00:15:51,190
new frameworks it does mean that you

00:15:48,310 --> 00:15:53,050
need to integrate client libraries into

00:15:51,190 --> 00:15:57,610
your runtime code that basically

00:15:53,050 --> 00:16:00,970
activates the different tracing

00:15:57,610 --> 00:16:03,400
mechanisms and emit those traces to a

00:16:00,970 --> 00:16:05,740
tracing aggregation service and you can

00:16:03,400 --> 00:16:08,230
see that on the right hand side there

00:16:05,740 --> 00:16:10,840
are open source projects like Jagger and

00:16:08,230 --> 00:16:14,110
Zipkin that basically aggregates the

00:16:10,840 --> 00:16:18,070
different tracing data and can give you

00:16:14,110 --> 00:16:20,620
something that looks like that it can

00:16:18,070 --> 00:16:22,690
track and give you how much time did we

00:16:20,620 --> 00:16:25,150
spend in each and every one of the

00:16:22,690 --> 00:16:28,090
services that is running east-west

00:16:25,150 --> 00:16:29,920
inside your environment and from an

00:16:28,090 --> 00:16:32,470
operational perspective when you think

00:16:29,920 --> 00:16:34,150
about what do you want to have the most

00:16:32,470 --> 00:16:36,910
from your systems you want your system

00:16:34,150 --> 00:16:39,960
to tell you that something is off you do

00:16:36,910 --> 00:16:42,120
that by searching for anomalies any

00:16:39,960 --> 00:16:45,370
irregularities that are associated with

00:16:42,120 --> 00:16:49,900
an error trend that let's say for

00:16:45,370 --> 00:16:53,470
example an API starts to return 500 HTTP

00:16:49,900 --> 00:16:55,600
code or a 404 that presents a negative

00:16:53,470 --> 00:16:57,130
trend these are the points where you

00:16:55,600 --> 00:16:59,260
want to see your system to actually tell

00:16:57,130 --> 00:17:00,820
you that something goes off because at

00:16:59,260 --> 00:17:04,300
the end of the day we cannot actively

00:17:00,820 --> 00:17:07,060
look for elements that are not working

00:17:04,300 --> 00:17:09,270
in the system tracing is just one aspect

00:17:07,060 --> 00:17:12,520
meaning that if one of the services

00:17:09,270 --> 00:17:14,680
exhibits the gradation in the response

00:17:12,520 --> 00:17:16,350
time in the average or the mean time or

00:17:14,680 --> 00:17:18,820
the p99

00:17:16,350 --> 00:17:21,520
response time this is where actually

00:17:18,820 --> 00:17:24,070
your SRA or the dev ops are kicking in

00:17:21,520 --> 00:17:25,330
and actually looking into the problems

00:17:24,070 --> 00:17:28,030
whether this is something that is

00:17:25,330 --> 00:17:30,280
associated with the infrastructure in

00:17:28,030 --> 00:17:32,650
service and lambda this is not something

00:17:30,280 --> 00:17:35,530
that we would expect from the

00:17:32,650 --> 00:17:37,360
infrastructure to actually show sluggish

00:17:35,530 --> 00:17:40,510
and slowly but when you think about

00:17:37,360 --> 00:17:42,790
actually server less in in the managed

00:17:40,510 --> 00:17:45,130
use case which I will show you in the

00:17:42,790 --> 00:17:46,630
next few slides then this is something

00:17:45,130 --> 00:17:48,460
that you actually want to see if there's

00:17:46,630 --> 00:17:51,520
something off with the servers

00:17:48,460 --> 00:17:53,340
if there are enough resources and so on

00:17:51,520 --> 00:17:57,210
and so forth

00:17:53,340 --> 00:18:00,880
so let's talk about how do we operate

00:17:57,210 --> 00:18:03,670
server less architecture in a fully

00:18:00,880 --> 00:18:08,020
managed environment so anyone here I

00:18:03,670 --> 00:18:09,370
heard about creative alright so for

00:18:08,020 --> 00:18:11,560
those who doesn't know it's a new

00:18:09,370 --> 00:18:14,230
project open sourced by Google and

00:18:11,560 --> 00:18:17,860
sponsored by IBM a Billiton and

00:18:14,230 --> 00:18:22,050
basically all the kind of vendors that

00:18:17,860 --> 00:18:25,900
support kubernetes any steel anyone here

00:18:22,050 --> 00:18:30,580
heard of work with eesti oh okay more

00:18:25,900 --> 00:18:32,950
folks and kubernetes alright better so

00:18:30,580 --> 00:18:36,820
when we think about this cloud nearly

00:18:32,950 --> 00:18:40,780
trifecta essentially this is basically

00:18:36,820 --> 00:18:43,360
the technology stack that she drives us

00:18:40,780 --> 00:18:45,730
into running serverless infrastructure

00:18:43,360 --> 00:18:48,220
in a fully managed environment meaning

00:18:45,730 --> 00:18:51,130
that kubernetes delivering the

00:18:48,220 --> 00:18:55,360
primitives the primitives to deploy and

00:18:51,130 --> 00:18:59,100
orchestrate workload sto is basically

00:18:55,360 --> 00:19:02,380
the control plane and the backbone of

00:18:59,100 --> 00:19:05,920
connecting services in a meaningful way

00:19:02,380 --> 00:19:08,830
in a reliable way an observable way and

00:19:05,920 --> 00:19:10,420
Kay native is basically the past

00:19:08,830 --> 00:19:12,670
abstraction for the platform as a

00:19:10,420 --> 00:19:16,150
service abstractions that give you the

00:19:12,670 --> 00:19:18,490
ability to run application modify

00:19:16,150 --> 00:19:21,700
application deployed application in a

00:19:18,490 --> 00:19:23,590
relatively easy way now I will say that

00:19:21,700 --> 00:19:26,050
the disclaimer here that these are

00:19:23,590 --> 00:19:26,710
early-stage projects now I know that as

00:19:26,050 --> 00:19:29,530
a DevOps

00:19:26,710 --> 00:19:32,050
we all have the experimental stuff but

00:19:29,530 --> 00:19:33,670
once you go into production this is

00:19:32,050 --> 00:19:35,440
something that you need to carefully

00:19:33,670 --> 00:19:38,110
examine when is the right time to engage

00:19:35,440 --> 00:19:40,690
so kubernetes for that matter is

00:19:38,110 --> 00:19:42,190
relatively mature enough there are

00:19:40,690 --> 00:19:44,440
thousands of companies that are running

00:19:42,190 --> 00:19:46,720
that in production including ourselves

00:19:44,440 --> 00:19:49,600
and then when you think think about sto

00:19:46,720 --> 00:19:53,440
and KNAT if these are more at the early

00:19:49,600 --> 00:19:55,480
stage even though if you're is g8 there

00:19:53,440 --> 00:19:59,830
are still many elements to Easter that

00:19:55,480 --> 00:20:02,080
are missing so quickly about the kind of

00:19:59,830 --> 00:20:05,289
new stack associated with

00:20:02,080 --> 00:20:06,760
kay native it essentially brings in a

00:20:05,289 --> 00:20:09,669
lot of capabilities to both the

00:20:06,760 --> 00:20:13,390
developer and the up side of the world

00:20:09,669 --> 00:20:16,179
by building and orchestrating code from

00:20:13,390 --> 00:20:20,370
get delivering that into production and

00:20:16,179 --> 00:20:25,299
what I would like to walk you through is

00:20:20,370 --> 00:20:28,480
how do we do Bluegreen deployment under

00:20:25,299 --> 00:20:31,840
this platform so I'll skip to through a

00:20:28,480 --> 00:20:34,450
couple of slides and kind of lay the

00:20:31,840 --> 00:20:37,240
foundation of what the kennedys serving

00:20:34,450 --> 00:20:40,120
primitives are in the sense that Kay

00:20:37,240 --> 00:20:42,460
native defines this service as the

00:20:40,120 --> 00:20:45,340
configuration and the association of

00:20:42,460 --> 00:20:49,200
route with configuration and kind of

00:20:45,340 --> 00:20:52,240
those two becomes your micro service now

00:20:49,200 --> 00:20:54,669
anyone here does in practice Bluegreen

00:20:52,240 --> 00:20:57,130
deployments meaning that you deploy two

00:20:54,669 --> 00:20:59,470
versions of your micro service and still

00:20:57,130 --> 00:21:02,470
traffic some percentage of the traffic

00:20:59,470 --> 00:21:04,149
to actually test is this something that

00:21:02,470 --> 00:21:09,429
anyone practice actively do today in

00:21:04,149 --> 00:21:11,679
production okay so if anyone did that by

00:21:09,429 --> 00:21:13,419
hand it's not an easy problem the day to

00:21:11,679 --> 00:21:16,929
day basis to actually deploy different

00:21:13,419 --> 00:21:20,110
micro services manually or automatically

00:21:16,929 --> 00:21:22,350
and do a traffic steering at the edge K

00:21:20,110 --> 00:21:24,730
native out-of-the-box bring that exact

00:21:22,350 --> 00:21:27,880
capability and it looks very promising

00:21:24,730 --> 00:21:30,309
at least in the early tests that we have

00:21:27,880 --> 00:21:32,889
conducted but then again there is a lot

00:21:30,309 --> 00:21:36,010
of component in that technology stack

00:21:32,889 --> 00:21:38,529
that can challenge each and every one so

00:21:36,010 --> 00:21:40,809
when we think about what does it mean to

00:21:38,529 --> 00:21:42,669
do the Bluegreen deployment so I took

00:21:40,809 --> 00:21:45,399
here an example of the configuration

00:21:42,669 --> 00:21:48,399
file in ki native it looks very familiar

00:21:45,399 --> 00:21:50,049
to regular kubernetes resources and at

00:21:48,399 --> 00:21:52,929
the end of the day you define here a

00:21:50,049 --> 00:21:55,630
snapshot of your code a build of your

00:21:52,929 --> 00:21:58,870
code that basically represents the blue

00:21:55,630 --> 00:22:00,820
version of our code you apply it into

00:21:58,870 --> 00:22:03,519
production by just doing the cube CTL

00:22:00,820 --> 00:22:07,480
apply and the file name that contains

00:22:03,519 --> 00:22:10,000
that resource and the system behind in

00:22:07,480 --> 00:22:15,670
the background create a revision that is

00:22:10,000 --> 00:22:17,530
revision one of this specific resource

00:22:15,670 --> 00:22:19,570
if I will do that again with different

00:22:17,530 --> 00:22:21,790
version it will automatically recreate a

00:22:19,570 --> 00:22:24,130
new revision and this is exactly what we

00:22:21,790 --> 00:22:29,380
are going to do next once we are going

00:22:24,130 --> 00:22:31,720
to deploy our green version inversion in

00:22:29,380 --> 00:22:34,030
in that specific deployment we deploy a

00:22:31,720 --> 00:22:36,280
route it basically defines how the

00:22:34,030 --> 00:22:39,490
service measure are the service platform

00:22:36,280 --> 00:22:42,040
routes traffic to my different code

00:22:39,490 --> 00:22:45,040
revisions so essentially what it means

00:22:42,040 --> 00:22:48,430
that I can define a route I can define

00:22:45,040 --> 00:22:50,440
what is the backing workload and the

00:22:48,430 --> 00:22:53,500
revision of that specific workload and

00:22:50,440 --> 00:22:56,650
based on that I also defined that the

00:22:53,500 --> 00:23:01,270
revision 100% of the traffic I steer

00:22:56,650 --> 00:23:05,790
into the blue version once a build is

00:23:01,270 --> 00:23:09,460
available we do the exact same

00:23:05,790 --> 00:23:11,920
deployment of the resource file into the

00:23:09,460 --> 00:23:14,710
platform into the stack meaning that now

00:23:11,920 --> 00:23:16,840
revealed that the build now carries the

00:23:14,710 --> 00:23:19,150
green version that we want to deploy

00:23:16,840 --> 00:23:23,320
into the production and the one thing

00:23:19,150 --> 00:23:26,830
left out of this operation is basically

00:23:23,320 --> 00:23:28,960
to steer the traffic into the next phase

00:23:26,830 --> 00:23:31,780
and that is something that we basically

00:23:28,960 --> 00:23:34,330
articulate by changing the route so

00:23:31,780 --> 00:23:37,180
right now the route basically say that I

00:23:34,330 --> 00:23:39,910
have two revisions that are running in

00:23:37,180 --> 00:23:43,240
my deployment of my production workload

00:23:39,910 --> 00:23:46,240
and presently the revision basically

00:23:43,240 --> 00:23:48,700
says that I still still hundred percent

00:23:46,240 --> 00:23:51,580
of the traffic to my blue version and

00:23:48,700 --> 00:23:53,710
all I need to do is just play with the

00:23:51,580 --> 00:23:57,400
steering of the percentage of the

00:23:53,710 --> 00:24:00,760
traffic in front of us so now I can

00:23:57,400 --> 00:24:02,350
slowly shift two percent and initially

00:24:00,760 --> 00:24:05,080
it makes sense to kind of try and shift

00:24:02,350 --> 00:24:07,810
two percent of the traffic into the

00:24:05,080 --> 00:24:08,980
green version try to get a handle

00:24:07,810 --> 00:24:12,670
whether this is something that behaves

00:24:08,980 --> 00:24:15,340
in a expectable and predictable way from

00:24:12,670 --> 00:24:19,110
a functional standpoint and once we have

00:24:15,340 --> 00:24:21,340
that we can shift the entire workload by

00:24:19,110 --> 00:24:24,250
increasing the amount of traffic that we

00:24:21,340 --> 00:24:27,730
steer into the green part of it and you

00:24:24,250 --> 00:24:29,440
can see that it is as simple as changing

00:24:27,730 --> 00:24:31,269
a configuration file

00:24:29,440 --> 00:24:33,460
and just deploying that into the fabric

00:24:31,269 --> 00:24:35,440
and the fabric takes care of all the

00:24:33,460 --> 00:24:38,289
rest meaning the steering of the traffic

00:24:35,440 --> 00:24:40,720
for those of you who actually want the

00:24:38,289 --> 00:24:42,250
breakdown so sto is the one that is

00:24:40,720 --> 00:24:44,740
taking care of steering the traffic

00:24:42,250 --> 00:24:47,740
between the different workloads and K

00:24:44,740 --> 00:24:49,419
native provides the abstractions and the

00:24:47,740 --> 00:24:52,120
resources that actually orchestrate

00:24:49,419 --> 00:24:53,889
everything behind and kubernetes

00:24:52,120 --> 00:24:55,720
naturally is kind of the backbone of

00:24:53,889 --> 00:24:57,580
everything in terms of scheduling the

00:24:55,720 --> 00:25:01,539
different revisions and the different

00:24:57,580 --> 00:25:02,919
pods now from a developer standpoint you

00:25:01,539 --> 00:25:05,230
can think about this as actually

00:25:02,919 --> 00:25:07,750
managing your entire micro service

00:25:05,230 --> 00:25:10,659
architecture and infrastructure as code

00:25:07,750 --> 00:25:13,330
just like you manage your kubernetes

00:25:10,659 --> 00:25:17,440
Yama's today or you manage your cloud

00:25:13,330 --> 00:25:19,179
formation elements today but it does

00:25:17,440 --> 00:25:21,279
give you the power from an operational

00:25:19,179 --> 00:25:24,490
standpoint to actually bring in

00:25:21,279 --> 00:25:25,990
practices that are involving the

00:25:24,490 --> 00:25:27,070
blue/green deployment and actually

00:25:25,990 --> 00:25:30,070
gradually deploying

00:25:27,070 --> 00:25:32,799
into production doing some conformance

00:25:30,070 --> 00:25:34,570
tests on the small percentage of the

00:25:32,799 --> 00:25:37,779
traffic if you want to bring new

00:25:34,570 --> 00:25:41,049
features for example to some of your

00:25:37,779 --> 00:25:45,340
iPhone users and and not to your Android

00:25:41,049 --> 00:25:48,909
users you can still steer traffic with

00:25:45,340 --> 00:25:50,799
this notion just by specifying specific

00:25:48,909 --> 00:25:56,590
headers that are associated for example

00:25:50,799 --> 00:25:59,470
with Android phones now from from a

00:25:56,590 --> 00:26:03,309
security standpoint when you think about

00:25:59,470 --> 00:26:04,389
both server less as the fully managed

00:26:03,309 --> 00:26:07,480
infrastructure

00:26:04,389 --> 00:26:09,879
deployment mechanism versus running

00:26:07,480 --> 00:26:12,669
service architecture using

00:26:09,879 --> 00:26:15,159
infrastructure that we manage there are

00:26:12,669 --> 00:26:17,200
pros and cons so out of the box server

00:26:15,159 --> 00:26:20,620
list as you all know running inside a

00:26:17,200 --> 00:26:23,169
micro VM called firecracker Amazon

00:26:20,620 --> 00:26:26,500
basically open-source that project

00:26:23,169 --> 00:26:28,539
recently at reinvent it provides very

00:26:26,500 --> 00:26:30,879
strong isolations all the way down to

00:26:28,539 --> 00:26:34,120
the CPU level on one hand it's quite

00:26:30,879 --> 00:26:36,669
different than running something inside

00:26:34,120 --> 00:26:39,429
a container but on the other hand when

00:26:36,669 --> 00:26:41,049
you think about running it on a fully

00:26:39,429 --> 00:26:43,419
managed infrastructure you can see here

00:26:41,049 --> 00:26:46,029
that even deploying into

00:26:43,419 --> 00:26:48,759
kubernetes this is something that I can

00:26:46,029 --> 00:26:50,979
actually escape from the function into

00:26:48,759 --> 00:26:52,959
the underlying infrastructure there are

00:26:50,979 --> 00:26:55,659
multiple vulnerabilities over time in

00:26:52,959 --> 00:26:57,729
kubernetes and and right now in East EO

00:26:55,659 --> 00:27:00,789
there is an open issue that basically

00:26:57,729 --> 00:27:03,099
enables anyone that runs the service

00:27:00,789 --> 00:27:05,589
function as route to actually define a

00:27:03,099 --> 00:27:10,589
user that basically escaped from the

00:27:05,589 --> 00:27:13,739
mesh entirely and actually do some some

00:27:10,589 --> 00:27:16,659
sniffing and an east-west basically

00:27:13,739 --> 00:27:18,219
traffic inside the underlying

00:27:16,659 --> 00:27:20,859
infrastructure this is not something

00:27:18,219 --> 00:27:22,899
that you would expect on your Amazon

00:27:20,859 --> 00:27:27,519
Landa but this is something that is

00:27:22,899 --> 00:27:31,269
quite possible on the new projects this

00:27:27,519 --> 00:27:33,729
is why we basically say that East unk

00:27:31,269 --> 00:27:36,099
native are awesome as a forward-looking

00:27:33,729 --> 00:27:38,289
statement from the cloud providers in

00:27:36,099 --> 00:27:40,419
the companies that are behind those but

00:27:38,289 --> 00:27:43,570
there is a lot of legwork to actually

00:27:40,419 --> 00:27:46,059
get it into a secured infrastructure

00:27:43,570 --> 00:27:47,709
that you can trust and operate and

00:27:46,059 --> 00:27:51,549
operate for all the use cases that are

00:27:47,709 --> 00:27:54,909
out there so one thing to kind of keep

00:27:51,549 --> 00:27:58,149
in mind when we go into functions and

00:27:54,909 --> 00:28:00,820
services how do you build this kind of

00:27:58,149 --> 00:28:02,950
perimeter around your function so even

00:28:00,820 --> 00:28:05,019
if you using lambda you can define the

00:28:02,950 --> 00:28:07,599
i''m rules but if I as an attacker can

00:28:05,019 --> 00:28:10,299
manipulate an application vulnerability

00:28:07,599 --> 00:28:13,089
that I can bounce my data outside of the

00:28:10,299 --> 00:28:15,129
function or the lambda if it's running

00:28:13,089 --> 00:28:17,619
outside my VPC meaning it's a fully

00:28:15,129 --> 00:28:20,200
hosted AWS lambda there is nothing that

00:28:17,619 --> 00:28:22,779
actually prevented me from getting the

00:28:20,200 --> 00:28:25,809
data outside the lambda itself

00:28:22,779 --> 00:28:27,489
now even though serverless offers the

00:28:25,809 --> 00:28:30,869
infant taking of the burden of the

00:28:27,489 --> 00:28:33,719
infrastructure security we are still as

00:28:30,869 --> 00:28:36,429
developers and application developers

00:28:33,719 --> 00:28:38,320
are confined to all the application

00:28:36,429 --> 00:28:41,200
security challenges that are out there

00:28:38,320 --> 00:28:43,599
so if I have a vulnerability in my

00:28:41,200 --> 00:28:45,429
application code where I bring in an

00:28:43,599 --> 00:28:48,729
open source component that is

00:28:45,429 --> 00:28:51,159
misbehaving it's my responsibility both

00:28:48,729 --> 00:28:52,929
as a developer and as the ops to

00:28:51,159 --> 00:28:56,739
actually take care of and understand

00:28:52,929 --> 00:28:57,100
what exactly is happening lambda on in

00:28:56,739 --> 00:28:59,980
that

00:28:57,100 --> 00:29:03,160
spec brings in many blind spots into the

00:28:59,980 --> 00:29:05,559
mix because essentially we are we have

00:29:03,160 --> 00:29:07,809
very little control of how traffic is

00:29:05,559 --> 00:29:09,730
being steered from the lambda outside

00:29:07,809 --> 00:29:13,240
I am should give us anything that

00:29:09,730 --> 00:29:14,740
happens if you are 100% AWS then it

00:29:13,240 --> 00:29:19,480
should give you the ability to control

00:29:14,740 --> 00:29:21,970
what is happening is twist inside Amazon

00:29:19,480 --> 00:29:24,820
services but if you are employing for

00:29:21,970 --> 00:29:27,059
example slack or MongoDB as a service

00:29:24,820 --> 00:29:30,220
then this is something that would become

00:29:27,059 --> 00:29:34,630
impossible to do if you're running as a

00:29:30,220 --> 00:29:36,460
fully hosted lamda now the other element

00:29:34,630 --> 00:29:38,169
that I think is extremely important when

00:29:36,460 --> 00:29:40,090
you think about security and both

00:29:38,169 --> 00:29:43,659
operations and we talked about a little

00:29:40,090 --> 00:29:46,510
bit on the operational side this is the

00:29:43,659 --> 00:29:49,450
the behavioral anomaly so when you think

00:29:46,510 --> 00:29:52,090
about micro service it is replicated as

00:29:49,450 --> 00:29:54,280
lambda functions how do you find an

00:29:52,090 --> 00:29:55,990
anomaly in a group that basically runs

00:29:54,280 --> 00:29:58,480
in an infrastructure that we do not

00:29:55,990 --> 00:30:02,260
control on one hand but if something

00:29:58,480 --> 00:30:04,450
goes off this time-boxed runtime how can

00:30:02,260 --> 00:30:06,220
I identify that something actually went

00:30:04,450 --> 00:30:08,470
off within the group and how can I

00:30:06,220 --> 00:30:11,500
identify that something that connects to

00:30:08,470 --> 00:30:14,350
my database is not doing anything that

00:30:11,500 --> 00:30:17,440
is our original intent meaning that it

00:30:14,350 --> 00:30:19,750
can interact with my database but just

00:30:17,440 --> 00:30:22,950
as much interact with other databases or

00:30:19,750 --> 00:30:25,150
bounce data outside of my function so

00:30:22,950 --> 00:30:27,190
searching for those anomalies is

00:30:25,150 --> 00:30:29,350
something that you need to have it's not

00:30:27,190 --> 00:30:31,570
something that you normally find in open

00:30:29,350 --> 00:30:33,880
source projects and it often times

00:30:31,570 --> 00:30:36,909
revert to actually getting like a third

00:30:33,880 --> 00:30:39,340
party security solution that can bring

00:30:36,909 --> 00:30:41,350
you those insights think about the same

00:30:39,340 --> 00:30:45,520
aspect from an operational perspective

00:30:41,350 --> 00:30:48,280
and monitoring your infrastructure so

00:30:45,520 --> 00:30:52,059
all the open tracing and the spans that

00:30:48,280 --> 00:30:53,530
the monitoring infrastructure emit and

00:30:52,059 --> 00:30:55,870
normal ease can tell you if something

00:30:53,530 --> 00:30:57,850
goes off as a specific micro service and

00:30:55,870 --> 00:30:59,860
the main thing that it serves is

00:30:57,850 --> 00:31:02,590
actually the ability to reduce the time

00:30:59,860 --> 00:31:05,380
from understanding that something is

00:31:02,590 --> 00:31:07,419
wrong to actually pinpoint where it went

00:31:05,380 --> 00:31:10,540
wrong and who is the person that needs

00:31:07,419 --> 00:31:12,430
to fix that element in service

00:31:10,540 --> 00:31:14,320
hundred percent of the times it's going

00:31:12,430 --> 00:31:16,470
to be a developer that needs to be

00:31:14,320 --> 00:31:19,020
involved when you think about

00:31:16,470 --> 00:31:22,680
traditional security practices

00:31:19,020 --> 00:31:25,420
developers are not kind of the go-to

00:31:22,680 --> 00:31:27,130
persona in terms of all the security

00:31:25,420 --> 00:31:30,130
issues that are running in production

00:31:27,130 --> 00:31:32,950
and today once we go into service is

00:31:30,130 --> 00:31:35,440
something that we do expect some level

00:31:32,950 --> 00:31:38,080
of ownership and accountability from

00:31:35,440 --> 00:31:39,550
from the developers and the DevOps and

00:31:38,080 --> 00:31:41,470
this is something that changed

00:31:39,550 --> 00:31:43,900
dramatically as we move into cloud

00:31:41,470 --> 00:31:48,250
native as we move to an application

00:31:43,900 --> 00:31:51,280
centric world so just to quickly

00:31:48,250 --> 00:31:53,800
overview and this would be the last

00:31:51,280 --> 00:31:56,860
slide of what are the application

00:31:53,800 --> 00:31:58,840
security risks when it comes to server

00:31:56,860 --> 00:32:01,420
less so first of all I would say that

00:31:58,840 --> 00:32:04,120
there is nothing new Under the Sun in

00:32:01,420 --> 00:32:07,720
the sense that server is just like

00:32:04,120 --> 00:32:09,760
containers just like VMs applications

00:32:07,720 --> 00:32:11,560
and applications have security

00:32:09,760 --> 00:32:14,620
vulnerabilities and there's nothing that

00:32:11,560 --> 00:32:16,540
you can actually different there is

00:32:14,620 --> 00:32:18,040
there are specific elements that you

00:32:16,540 --> 00:32:20,260
want to make sure that you take care of

00:32:18,040 --> 00:32:22,480
once you go into service specifically

00:32:20,260 --> 00:32:25,390
when it comes to fully managed

00:32:22,480 --> 00:32:28,360
environments the first one is how do you

00:32:25,390 --> 00:32:31,570
deal with injection of events so if

00:32:28,360 --> 00:32:34,240
originally we had SQL injection now we

00:32:31,570 --> 00:32:37,300
have different interfaces like message

00:32:34,240 --> 00:32:40,720
queues and protocols that are not HTTP

00:32:37,300 --> 00:32:44,080
protocols per se on one hand but on the

00:32:40,720 --> 00:32:48,250
other hand these are still vectors that

00:32:44,080 --> 00:32:50,820
I can inject input that is invalid and I

00:32:48,250 --> 00:32:56,260
can basically bounce data and and maybe

00:32:50,820 --> 00:32:59,530
get a hold of my our workload so we are

00:32:56,260 --> 00:33:01,240
not kind of the mechanisms to do full

00:32:59,530 --> 00:33:05,230
control over the entire spectrum of

00:33:01,240 --> 00:33:07,360
those and necessarily wefts are not

00:33:05,230 --> 00:33:09,820
something that you can deploy in a

00:33:07,360 --> 00:33:12,280
service environment broken

00:33:09,820 --> 00:33:15,160
authentication and authorization at the

00:33:12,280 --> 00:33:17,620
edge is something that can expose API is

00:33:15,160 --> 00:33:21,490
it can allow whether it's an

00:33:17,620 --> 00:33:22,750
authenticated user that can escalate the

00:33:21,490 --> 00:33:25,870
privileges

00:33:22,750 --> 00:33:27,670
do more than what they expected it's

00:33:25,870 --> 00:33:29,110
nothing new Under the Sun it's just

00:33:27,670 --> 00:33:31,960
something that you need to take care of

00:33:29,110 --> 00:33:34,600
once you propagate authentication and

00:33:31,960 --> 00:33:37,690
authorization data into the internal

00:33:34,600 --> 00:33:41,710
micro-services meaning that if my age

00:33:37,690 --> 00:33:45,310
API server is press is taking privileges

00:33:41,710 --> 00:33:47,050
actions with internal micro service then

00:33:45,310 --> 00:33:51,040
this is something that potentially user

00:33:47,050 --> 00:33:53,770
can exploit and perform operations that

00:33:51,040 --> 00:33:57,550
are not part of the original intent of

00:33:53,770 --> 00:34:00,730
the application anything that's too

00:33:57,550 --> 00:34:02,980
unsecure server less deployments meaning

00:34:00,730 --> 00:34:04,630
that you are not giving the minimal

00:34:02,980 --> 00:34:08,320
privileges the I am rows to the

00:34:04,630 --> 00:34:12,220
functions whether it's on creative or on

00:34:08,320 --> 00:34:15,040
on lambda anything that spends your

00:34:12,220 --> 00:34:18,010
software supply chain make sure you gain

00:34:15,040 --> 00:34:20,080
in open source software from trusted

00:34:18,010 --> 00:34:24,790
sources that you scan them that you scan

00:34:20,080 --> 00:34:27,070
them with relatively solid tools I know

00:34:24,790 --> 00:34:29,200
that it's very easy to revert to open

00:34:27,070 --> 00:34:31,179
source but open source sometimes give

00:34:29,200 --> 00:34:34,540
part of the answers to whatever is

00:34:31,179 --> 00:34:36,669
happening in your environment anything

00:34:34,540 --> 00:34:39,940
that relates to visibility if you have

00:34:36,669 --> 00:34:42,340
blind spots if something goes off it's

00:34:39,940 --> 00:34:44,649
impossible for you even to see that make

00:34:42,340 --> 00:34:47,440
sure you have visibility both into the

00:34:44,649 --> 00:34:49,980
ops things the telemetry but just as

00:34:47,440 --> 00:34:53,110
much make sure that you do that for your

00:34:49,980 --> 00:34:55,060
security infrastructure so thanks

00:34:53,110 --> 00:35:00,380
everyone for taking the time

00:34:55,060 --> 00:35:05,510
[Applause]

00:35:00,380 --> 00:35:05,510

YouTube URL: https://www.youtube.com/watch?v=9ylGpnSIloA


