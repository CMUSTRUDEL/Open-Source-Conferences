Title: DevOpsDays Chicago 2019 - Jessie Frazelle - Why Open Source Firmware is Important
Publication date: 2019-09-09
Playlist: DevOpsDays Chicago 2019
Description: 
	Jessie Frazelle - Why Open Source Firmware is Important

This talk will dive into some of the problems of running servers at scale, with data from surveys and why open source firmware will solve some of the problems. Why is it important for security and root of trust? It will also cover the state of open source firmware today.
Captions: 
	00:00:13,809 --> 00:00:16,000
Jessie Frazelle - Why Open Source Firmware is Important

00:00:16,000 --> 00:00:17,230
It will be better for everybody.

00:00:17,230 --> 00:00:18,610
This is the part where I start to get slaphappy.

00:00:18,610 --> 00:00:19,610
We are starting the next talk, please make your way in.

00:00:19,610 --> 00:00:20,610
It is my pleasure to introduce the first afternoon speaker, and that is Jessie Frazelle!

00:00:20,610 --> 00:00:21,610
Thank you!

00:00:21,610 --> 00:00:22,610
>>Jessie Frazelle: I'm Jessie Frazelle, thank you for having me.

00:00:22,610 --> 00:00:27,250
I love coming to Chicago, and it is nice during the summer, other than yesterday when it rained.

00:00:27,250 --> 00:00:31,570
I felt like it was my fault for being here.

00:00:31,570 --> 00:00:37,710
I'm talking why open source firmware is important, and I hate giving the same talk twice, so

00:00:37,710 --> 00:00:43,050
this is going to be a little bit different, and also going to prod and a bunch of other

00:00:43,050 --> 00:00:45,170
stuff.

00:00:45,170 --> 00:00:54,039
So if you think about the layers of software today, you have a bunch of software up top,

00:00:54,039 --> 00:00:58,780
like your app, and then maybe something that controls the app.

00:00:58,780 --> 00:01:02,980
And you have the operating system, firm ware, and hardware.

00:01:02,980 --> 00:01:09,560
So all software, firm ware, and hardware, just to make it super general.

00:01:09,560 --> 00:01:13,869
If we make it even more general, then everything is shit.

00:01:13,869 --> 00:01:17,450
[ Laughter ]. And I think everyone can agree on that, because

00:01:17,450 --> 00:01:20,960
everything has bugs and everything is horrible.

00:01:20,960 --> 00:01:29,749
So if we look at the privilege levels for this kind of stack, you have ring three, which

00:01:29,749 --> 00:01:33,359
is user space, ring two, it doesn't exist anymore.

00:01:33,359 --> 00:01:37,069
It was drivers, the same with ring one.

00:01:37,069 --> 00:01:46,520
Ring zero is your kernel space, and then ring negative one, also kind of the negative rings,

00:01:46,520 --> 00:01:48,270
are made up.

00:01:48,270 --> 00:01:51,729
But if you think about it, all the rings are made up.

00:01:51,729 --> 00:02:00,090
So there's ring negative one, HyperVisor, sent, KPM, whatever you use.

00:02:00,090 --> 00:02:07,700
And then there's two, the UEM mode.

00:02:07,700 --> 00:02:13,510
And then there's ring negative three, at the very bottom, the management engine.

00:02:13,510 --> 00:02:18,740
And then there's equivalents on other processors.

00:02:18,740 --> 00:02:24,270
So the part that we don't know about, because we do open source software for all the others,

00:02:24,270 --> 00:02:30,939
is system management mode, UFI kernel, and the management engine.

00:02:30,939 --> 00:02:37,299
And so that's -- that is, like, pretty scary, that our most privileged software is in the

00:02:37,299 --> 00:02:38,950
layers we don't know about.

00:02:38,950 --> 00:02:41,590
So we will go over what they are.

00:02:41,590 --> 00:02:47,000
System management mode was for power management and people shoved a bunch of other shit in

00:02:47,000 --> 00:02:48,000
there.

00:02:48,000 --> 00:02:55,500
So it is hardware control, proprietary, design code, vendors add new features there and say,

00:02:55,500 --> 00:02:57,090
throw it into system management mode.

00:02:57,090 --> 00:02:59,810
Maybe it would be better somewhere else.

00:02:59,810 --> 00:03:07,849
It handles system events, like memory, errors, runtime things there as well.

00:03:07,849 --> 00:03:10,340
So there are correctable errors and stuff like that.

00:03:10,340 --> 00:03:12,980
It is a half-kernel.

00:03:12,980 --> 00:03:16,810
And then we have the UEFI kernel, extremely complex.

00:03:16,810 --> 00:03:22,860
I don't know if anybody looked at the code for that, but if you asked somebody that worked

00:03:22,860 --> 00:03:30,459
on it, it takes forever to fix a bug because it is unbreakable, and unreadable code.

00:03:30,459 --> 00:03:33,920
It is, like, way too much code.

00:03:33,920 --> 00:03:40,209
So someone was telling me they tried to make a one line change to the UEFI kernel and took

00:03:40,209 --> 00:03:43,329
forever to find where the bug was, which is horrifying.

00:03:43,329 --> 00:03:53,741
And the after-factor applications are after-boot, and there is security that you cannot wrap

00:03:53,741 --> 00:04:00,430
your head around unless you hire the author of UEFI.

00:04:00,430 --> 00:04:07,090
People say it is really bad, oh, we hired the author, cool.

00:04:07,090 --> 00:04:20,600
No one can wrap their head around it, so it is not worth it.

00:04:20,600 --> 00:04:27,820
And Intel management engine, networking management, Intel proprietary features, and you can look

00:04:27,820 --> 00:04:31,720
at the crazy things that the management engine does as well.

00:04:31,720 --> 00:04:36,710
And then there's -- it can actually re-image your device, even if it is powered off, which

00:04:36,710 --> 00:04:42,590
is incredibly terrifying, and also terrifying that there's a web server in there.

00:04:42,590 --> 00:04:48,310
It can re-image your device, and it is hooked up to the internet, I agree.

00:04:48,310 --> 00:04:54,139
So it turns on the node invisibly, and then it runs minutes, which nobody knew for the

00:04:54,139 --> 00:04:55,139
longest time.

00:04:55,139 --> 00:05:04,810
So the most popular Unix runtime is Minx, which is crazy.

00:05:04,810 --> 00:05:13,650
So there ended up being in 2017 a critical bug in all Intel processors that happened

00:05:13,650 --> 00:05:20,900
because of the minx layer, and it came up that they were using minx, there was a bug

00:05:20,900 --> 00:05:27,500
in the network server, the web server, in minx, in the Intel management engine.

00:05:27,500 --> 00:05:30,080
It is like, why is that even there?

00:05:30,080 --> 00:05:33,639
That's a really good question.

00:05:33,639 --> 00:05:37,360
And why is it still there is even a better question.

00:05:37,360 --> 00:05:42,060
And that's one example of a bad attack.

00:05:42,060 --> 00:05:47,509
If you Google any firmware bugs or anything, you can easily find others.

00:05:47,509 --> 00:05:59,790
And one that was recent was the Bloomberg's article on mod chips on super micro boards,

00:05:59,790 --> 00:06:12,889
while this didn't happen, it is plausible and you can find a great talk on it 

00:06:12,889 --> 00:06:15,070
called mod chips and the state.

00:06:15,070 --> 00:06:20,990
And he goes through how you would do it, it is complicated and you have to hack the supply

00:06:20,990 --> 00:06:21,990
chain.

00:06:21,990 --> 00:06:26,490
Why hack through the supply chain if you can walk through the firm ware?

00:06:26,490 --> 00:06:29,490
That's a lot easier.

00:06:29,490 --> 00:06:31,110
So this is bad.

00:06:31,110 --> 00:06:36,640
One, you can do mod chips, but two, the firm ware is already very easy to get through.

00:06:36,640 --> 00:06:38,039
So just use that.

00:06:38,039 --> 00:06:40,240
And it gets even worse.

00:06:40,240 --> 00:06:44,740
So there is a feature called Intel boot guard.

00:06:44,740 --> 00:06:51,520
What this allows you to do is to kind of, like, guard the firmware on your box, which

00:06:51,520 --> 00:06:54,680
sounds great, right, in theory.

00:06:54,680 --> 00:07:01,500
So with boot guard, you are locked into always booting the same firmware, and it assigns

00:07:01,500 --> 00:07:05,349
it and Intel verifies that this has been signed.

00:07:05,349 --> 00:07:11,669
You cannot modify the firm ware, like you want to run core boot instead.

00:07:11,669 --> 00:07:14,900
You cannot, Intel owns the keys, you cannot sign it.

00:07:14,900 --> 00:07:22,539
And what you can do, and this is what Trammel figured out in a different talk of his.

00:07:22,539 --> 00:07:27,690
You can -- there was a bug where if you get rid of the screen that you can't boot this

00:07:27,690 --> 00:07:32,300
firmware, and you don't replace it, you can't find the image and it will boot anyways.

00:07:32,300 --> 00:07:39,030
So this isn't even doing its job at the end of the day, and it is making it hard for people

00:07:39,030 --> 00:07:44,440
to run open source firm ware, and I will get into the software and stuff like that.

00:07:44,440 --> 00:07:52,099
And it is causing Intel to be the own software process you are running on their computers

00:07:52,099 --> 00:07:55,550
and on their chips.

00:07:55,550 --> 00:08:02,110
So if we add up all the things that are in these lower stacks, you get 2.5 other kernels.

00:08:02,110 --> 00:08:12,259
So you are already probably running Linux, Windows, or Solarius, your own OS and kernel.

00:08:12,259 --> 00:08:16,190
And then you have these two and a half other ones that nobody vetted, or knows what is

00:08:16,190 --> 00:08:24,110
going on, and they have their networking stacks and servers.

00:08:24,110 --> 00:08:27,010
And then the code can modify itself and persist.

00:08:27,010 --> 00:08:32,330
You are connected to the internet, and the code modifies and we don't know what the code

00:08:32,330 --> 00:08:35,610
looks like because you cannot see it.

00:08:35,610 --> 00:08:39,180
So that is horrifying.

00:08:39,180 --> 00:08:43,110
All of them have exploits and they are complex.

00:08:43,110 --> 00:08:48,529
So my hypothesis is once you need to deal with the firm ware, it becomes pain.

00:08:48,529 --> 00:08:55,810
This comes from a survey I sent out online and talking to people.

00:08:55,810 --> 00:09:01,640
But I kind of blew up, I asked this on the internet, there's a bunch of replies.

00:09:01,640 --> 00:09:04,560
I will go over funny ones.

00:09:04,560 --> 00:09:12,750
But the ping is astronomical at the firm ware level, and in general, computers are shit

00:09:12,750 --> 00:09:15,920
and I will go over that as well because computers are funny.

00:09:15,920 --> 00:09:25,490
So super microbios, and an IPMI bug were trying to load the module to free up the SSH session

00:09:25,490 --> 00:09:30,450
to draw up traffic, but it would fail the server.

00:09:30,450 --> 00:09:39,439
And working your server is super popular -- there was one time when we -- (off-mic comments)

00:09:39,439 --> 00:09:42,770
-- bios, and we worked 3,000 machines at the same time.

00:09:42,770 --> 00:09:44,290
That is horrifying.

00:09:44,290 --> 00:09:56,540
So a firmware bug and flash, causing IE, which recovered in a fraction of a section, because

00:09:56,540 --> 00:09:59,589
network loss, because it buffer overflowed in the time.

00:09:59,589 --> 00:10:04,010
And there's a troubleshooting in the statement.

00:10:04,010 --> 00:10:07,000
I would love to watch that movie, it would be really good.

00:10:07,000 --> 00:10:10,860
And I would watch these for any of these, honestly.

00:10:10,860 --> 00:10:21,639
And the C-series servers, C6100, the PMI board survived a time of updating it 50 percent

00:10:21,639 --> 00:10:30,430
of the time, and it was bad enough that Dell asked to send a tech out to do it manually.

00:10:30,430 --> 00:10:34,750
Once it failed, it is not addressable for a second try locally.

00:10:34,750 --> 00:10:42,600
So here is another Dell, after that, I came up with a bug in the firmware to make it think

00:10:42,600 --> 00:10:52,190
the server was overheating, re-boot the chassis, and the suggestion was to re-boot the sensor,

00:10:52,190 --> 00:10:54,910
it was great.

00:10:54,910 --> 00:11:03,960
And IBM HS-20 blades, both IBM and Dell were bad.

00:11:03,960 --> 00:11:10,470
They sent a new controller board and asked that I not tell IBM.

00:11:10,470 --> 00:11:19,550
Absolutely horrifying, if you talk to people, Dell cannot ship the same sku twice.

00:11:19,550 --> 00:11:28,290
So the sku is made-up, and then there's a bajillion other skus if you open up the box.

00:11:28,290 --> 00:11:31,480
That's a problem in and of itself.

00:11:31,480 --> 00:11:37,360
So outage said in general are vulnerable and I'm including this, because some of them are

00:11:37,360 --> 00:11:38,360
really funny.

00:11:38,360 --> 00:11:44,610
And data link between our DR and main site was having rhythmic packet loss.

00:11:44,610 --> 00:11:53,889
So UXU, it was fiber, nobody could explain it, the lines were lying over on accident

00:11:53,889 --> 00:11:59,570
and packet loss is driving other.

00:11:59,570 --> 00:12:04,670
And this was weight-related.

00:12:04,670 --> 00:12:16,209
And S390 box kept powering down, everything looked normal and it sat next to the box,

00:12:16,209 --> 00:12:24,230
nothing happened, at 4:00 I get coffee, the box power is down, a loose floor tile wobbling

00:12:24,230 --> 00:12:25,500
the power cable.

00:12:25,500 --> 00:12:27,029
So insane.

00:12:27,029 --> 00:12:33,940
I would be so pissed if that were me, you got to be fucking kidding me, that I just

00:12:33,940 --> 00:12:35,010
-- yeah.

00:12:35,010 --> 00:12:41,949
And another theory that I have for this relates to talking to a lot of people on these issues

00:12:41,949 --> 00:12:46,450
is that it is kind of like a form of Conway's law.

00:12:46,450 --> 00:12:56,850
So in talking to a few firmware hackers, when they find a vulnerability and Dell or a vendor's

00:12:56,850 --> 00:13:00,139
firm ware, they have to tell the vendor.

00:13:00,139 --> 00:13:10,620
And the vendor doesn't know what to do right away, and two, they cannot talk to the teams

00:13:10,620 --> 00:13:11,620
internally.

00:13:11,620 --> 00:13:19,111
If they are between two interfaces and the two teams cannot talk to each other, the hacker

00:13:19,111 --> 00:13:23,350
has to do the communication between the two teams.

00:13:23,350 --> 00:13:27,279
That is actually your problem, that these two teams are talking to each other.

00:13:27,279 --> 00:13:35,680
So from the perspective of hardware engineers, they are thinking that you are crazy to think

00:13:35,680 --> 00:13:40,100
that hardware engineers are isolating them safely.

00:13:40,100 --> 00:13:45,930
They are one layer of the stack, and they are like, those software people are fucking

00:13:45,930 --> 00:13:46,930
nuts.

00:13:46,930 --> 00:13:53,600
They are doing multi-tenant shit and we're like, please stop.

00:13:53,600 --> 00:13:57,720
And so melt down proved this to be true.

00:13:57,720 --> 00:14:06,790
If you ask a hardware engineer about Spectre melt down, it is crazy to begin with.

00:14:06,790 --> 00:14:08,300
That is interesting.

00:14:08,300 --> 00:14:17,310
And from the perspective of the lower software stack on hardware, they want the vendors and

00:14:17,310 --> 00:14:22,279
chip manufacturers and stuff to make the preferred to do list.

00:14:22,279 --> 00:14:29,212
So stop doing, you know, runtime services because it is fucked up anyways and it doesn't

00:14:29,212 --> 00:14:30,212
work well.

00:14:30,212 --> 00:14:31,880
So they want them to give them the control.

00:14:31,880 --> 00:14:37,570
So these communication channels aren't working out, since no one seems to know the other

00:14:37,570 --> 00:14:40,810
side's opinion, or they don't give a shit.

00:14:40,810 --> 00:14:43,540
Yeah, they keep saying that, but they don't care.

00:14:43,540 --> 00:14:50,560
And vendors can really debug firm ware issues, like they said, or the hackers do the communication

00:14:50,560 --> 00:14:51,560
between the teams.

00:14:51,560 --> 00:14:57,360
There is oversight and lack of communication leads to the ad shit.

00:14:57,360 --> 00:15:10,019
I don't know if you recall, but there was a hack on IBM's metal cloud soft layer, the

00:15:10,019 --> 00:15:17,500
servers were exposed and the hackers were able to distribute malware through the exposed

00:15:17,500 --> 00:15:18,500
VMC.

00:15:18,500 --> 00:15:29,160
So if you were to get one of those metal nodes, do this, and delete your node or any customers

00:15:29,160 --> 00:15:33,850
that come on to that node, the hacker is basically owning you.

00:15:33,850 --> 00:15:42,460
And that is the whole problem with the cloud, they should be guaranteeing and the next customers

00:15:42,460 --> 00:15:52,139
using the resource should have their data read or anything like that.

00:15:52,139 --> 00:16:03,290
So how do no one, when building soft layer, think about B&C and protecting it, or making

00:16:03,290 --> 00:16:05,949
sure it wasn't exposed, or anything like that?

00:16:05,949 --> 00:16:12,160
And these miscommunications happen when the teams aren't allowed to talk, or the team

00:16:12,160 --> 00:16:18,960
is just so blinders on that they don't thing about what elt what else could happen, or

00:16:18,960 --> 00:16:24,660
it is not going to vector, because our job is orchestration.

00:16:24,660 --> 00:16:27,529
We don't care about that.

00:16:27,529 --> 00:16:30,080
If no one cares, then no one is going to deal with it.

00:16:30,080 --> 00:16:34,800
If no one communicates they should know about that, no one is going to deal with it.

00:16:34,800 --> 00:16:40,260
And someone needs to own that high-level vision, right, so it is kind of up to them.

00:16:40,260 --> 00:16:44,990
And I like seeing these miscommunication in the layers of the stack happen in the ecosystem

00:16:44,990 --> 00:16:45,990
as well.

00:16:45,990 --> 00:16:55,100
So Kubernetes has a couple security layers where it is more like a window dressing.

00:16:55,100 --> 00:17:01,240
And this -- and I wrote a blog post on it.

00:17:01,240 --> 00:17:04,390
When something is only blocked by the Kubernetes API.

00:17:04,390 --> 00:17:09,530
So one example is execing into other containers.

00:17:09,530 --> 00:17:14,490
Kubernetes has a security feature that you cannot exec into other containers, and all

00:17:14,490 --> 00:17:17,699
this does is block the API.

00:17:17,699 --> 00:17:26,790
Then you get a 502, or whatever the actual response is, that you are not allowed.

00:17:26,790 --> 00:17:35,080
So if you were on the node itself, you can exec in through multiple other norms.

00:17:35,080 --> 00:17:45,750
And a lot of people use it -- they combine all the descriptors because it is not that

00:17:45,750 --> 00:17:50,560
fucking hard, even if you block the Docker exec.

00:17:50,560 --> 00:17:58,900
And if you blocked all the layers, you can combine the file descriptors.

00:17:58,900 --> 00:18:06,980
It is one of the things where people do not look at the full picture, and it is advertised

00:18:06,980 --> 00:18:09,640
as something it is not.

00:18:09,640 --> 00:18:13,800
So it looks like this, because I can walk around this thing.

00:18:13,800 --> 00:18:21,860
It is a common pattern, most of these vulnerabilities that people find, I just walked around it.

00:18:21,860 --> 00:18:30,060
And miscommunication of various layers lead to bug and intersecting layers, that is where

00:18:30,060 --> 00:18:34,380
bugs lie, people having incorrect assumptions.

00:18:34,380 --> 00:18:41,870
And it leads back to our, everything is poop, which it is, and everything has bugs.

00:18:41,870 --> 00:18:43,510
So how do we fix these things?

00:18:43,510 --> 00:18:51,560
Well, we do it with open source firm ware, the point of this talk and why it is important.

00:18:51,560 --> 00:18:55,530
That doesn't fix all the layers of the stack, an interesting point.

00:18:55,530 --> 00:19:04,070
When the movements started, it was first called NERF: Non-extensible, reduced firm ware, I

00:19:04,070 --> 00:19:12,650
thought it was cool, and it is doing what this entails.

00:19:12,650 --> 00:19:20,250
They are making firmware less capable of doing harm, actions more visible, remove the runtime

00:19:20,250 --> 00:19:21,250
components.

00:19:21,250 --> 00:19:25,990
So with the management engine, you cannot run all of it, but take away the web server,

00:19:25,990 --> 00:19:36,210
and you can remove the IP stack and then you remove the ability to self-reflash, because

00:19:36,210 --> 00:19:38,670
that seems super harmful.

00:19:38,670 --> 00:19:40,800
And you let Linux run the flash updates.

00:19:40,800 --> 00:19:49,550
And everyone runs Linux anyways, so it should be embedded for you.

00:19:49,550 --> 00:19:55,380
So to go back to the visual, we have user space on type, the kernel, HyperVisor, UEFI,

00:19:55,380 --> 00:19:58,380
and the management engine.

00:19:58,380 --> 00:20:03,811
So you are getting rid of it, you cannot entirely get rid of UEFI, the management engine you

00:20:03,811 --> 00:20:09,330
cannot entirely get rid of either.

00:20:09,330 --> 00:20:21,010
And zooming in on these, you have SNM, disabled, UFI is minimalized, you have the UXI with

00:20:21,010 --> 00:20:26,060
a minimal user land, and it senses a Linux kernel.

00:20:26,060 --> 00:20:32,180
And your user land is tools that you know, you can use a batch if you want it to.

00:20:32,180 --> 00:20:34,160
Maybe you don't.

00:20:34,160 --> 00:20:36,920
And then you have a minimize management engine.

00:20:36,920 --> 00:20:45,430
And how you do the third part with the management engine is you use this tool in GitHub, Cleaner,

00:20:45,430 --> 00:20:50,180
and then the stack on top for negative two looks like this.

00:20:50,180 --> 00:20:53,810
So You Boot and Core Boot, you can use.

00:20:53,810 --> 00:21:02,250
Core Boot, there is actually a lot of production usage that has recently made the press about

00:21:02,250 --> 00:21:03,410
people using it.

00:21:03,410 --> 00:21:07,750
So that's really cool in production, super dope.

00:21:07,750 --> 00:21:16,410
And that's what handles silicon in the DRAM initialization, it pushes to Linux boot for

00:21:16,410 --> 00:21:19,280
stack testing.

00:21:19,280 --> 00:21:26,320
And then you can use this product from Google if you want for the user space, it is written

00:21:26,320 --> 00:21:30,000
in Go, binary and nice.

00:21:30,000 --> 00:21:36,730
And you can have these nice user space tools, since it is written in Go, you can make patches

00:21:36,730 --> 00:21:41,720
easily and that handles the A-Frame.

00:21:41,720 --> 00:21:43,580
So why Linux?

00:21:43,580 --> 00:21:50,490
A single kernel works for several boards, Linux has a shit ton of drivers.

00:21:50,490 --> 00:21:56,950
It is embedded with a lot of eyes on it, it is used extensibly.

00:21:56,950 --> 00:22:02,440
People have their naysay about Linux, but that is probably some of the most highly-looked

00:22:02,440 --> 00:22:04,620
at code.

00:22:04,620 --> 00:22:10,450
So it is a single open source kernel, versus the two and a half other shit shows that were

00:22:10,450 --> 00:22:17,230
mostly closed off.

00:22:17,230 --> 00:22:28,350
And 

00:22:28,350 --> 00:22:44,350
now -- drop in audio -- anything you would do at boot is easily modifiable in a modern

00:22:44,350 --> 00:22:45,350
stack.

00:22:45,350 --> 00:22:50,330
It allows you to hire devs that are not necessarily firmware devs, they know other switches that

00:22:50,330 --> 00:22:54,980
are cool, because the logic is, like, whatever.

00:22:54,980 --> 00:23:00,580
And you get memory safety if you use an actual memory-safe language.

00:23:00,580 --> 00:23:07,100
So it also turns out that it made boot time 5 times faster, which is amazing.

00:23:07,100 --> 00:23:10,860
So that's also another great win.

00:23:10,860 --> 00:23:13,980
And now, moving on to reciprocity, these are tied together.

00:23:13,980 --> 00:23:24,980
So by having all open source software, you can verify a boot that the software that you're

00:23:24,980 --> 00:23:27,850
running is the software that you should be running.

00:23:27,850 --> 00:23:34,220
And today, a lot of these open source firmware things that I went over, Linux boot, it wraps

00:23:34,220 --> 00:23:42,540
like a proprietary binary, a minimal binary from your chip manufacturer.

00:23:42,540 --> 00:23:49,960
So you can do a root of trust that verifies that the code you have everywhere is the right

00:23:49,960 --> 00:23:51,190
hatch.

00:23:51,190 --> 00:23:59,950
But the back door, if it is a binary you don't know about -- it is still cool in terms of

00:23:59,950 --> 00:24:03,070
checking the integrity on boot.

00:24:03,070 --> 00:24:06,550
So there's a few examples in the wild of this today.

00:24:06,550 --> 00:24:11,680
Google has Titan, that is custom Silicon that they wrote.

00:24:11,680 --> 00:24:14,820
They have given a lot of talks on it, which is great.

00:24:14,820 --> 00:24:20,350
It would be cool if it was open source, but there's a lot of documentation on this, if

00:24:20,350 --> 00:24:22,010
you want to look further into it.

00:24:22,010 --> 00:24:33,090
But they have on-chip verified boot, a cryptographic identity secure, and bootware signature check,

00:24:33,090 --> 00:24:38,930
monitor, sign-on, physical security, and transparent development.

00:24:38,930 --> 00:24:43,470
So that's really nice, and there's a great paper on this, too.

00:24:43,470 --> 00:24:47,230
Amazon has nitro, part of the Nitrostack, with a Nitrochip.

00:24:47,230 --> 00:24:56,540
And there's an FPGA, I don't know if that is true, but somebody from Amazon will correct

00:24:56,540 --> 00:24:57,540
me.

00:24:57,540 --> 00:25:09,310
And FPGA are programable logic array arrays, which fits nicely for hashes.

00:25:09,310 --> 00:25:19,570
If you are familiar with Apple, you are familiar that easy not easy to get a (indiscernible)

00:25:19,570 --> 00:25:21,060
on this.

00:25:21,060 --> 00:25:29,010
So there are some people from duo that try to reverse engineer it, but there is a paper

00:25:29,010 --> 00:25:34,740
online that has information, which is nice.

00:25:34,740 --> 00:25:39,300
And it must have taken forever for someone at Apple to release this.

00:25:39,300 --> 00:25:43,140
So thank you, to whoever that was.

00:25:43,140 --> 00:25:50,770
What it ends up looking like, the Boot ROM evaluates the signature, and iboot verifies

00:25:50,770 --> 00:26:01,810
the T2 cache signature, and T2 evaluates the UEFI signature, and that happens on the T2

00:26:01,810 --> 00:26:02,810
chip.

00:26:02,810 --> 00:26:12,380
And then Over Spy, the firmware evaluates the .EFI signature, and the boot dot EFI evaluates

00:26:12,380 --> 00:26:18,760
Mac OS kernel signature, which is pretty clean.

00:26:18,760 --> 00:26:23,410
And it is easier to wrap your head around what is happening.

00:26:23,410 --> 00:26:30,400
And it is more like a relay, where one thing leads to another down the line.

00:26:30,400 --> 00:26:39,890
So honestly, if you were to read anything after this talk, this is the best paper, the

00:26:39,890 --> 00:26:46,870
security on-place for your iPhone, which is super well-thought out.

00:26:46,870 --> 00:26:49,170
So, yeah, there's that.

00:26:49,170 --> 00:26:58,050
And Microsoft has Server S, and so the specs for Serverus are open source on GitHub and

00:26:58,050 --> 00:26:59,750
part of the compute project.

00:26:59,750 --> 00:27:01,770
There is no code.

00:27:01,770 --> 00:27:08,630
If you ask someone if it is open source, they will say it is just a spec, have that conversation

00:27:08,630 --> 00:27:14,360
numerous times, and they will say it is literally just a spec.

00:27:14,360 --> 00:27:16,480
No idea if they are going to open source the rest of that.

00:27:16,480 --> 00:27:18,480
That would be cool.

00:27:18,480 --> 00:27:30,240
It would go over a spec for doing a root of trust, so if you are interested in that, there

00:27:30,240 --> 00:27:31,630
is another option.

00:27:31,630 --> 00:27:36,400
Eventually you need to wrap a proprietary binary for your firm ware.

00:27:36,400 --> 00:27:43,640
It would be great if the vendors gave you open source firmware, you can verify without

00:27:43,640 --> 00:27:49,280
a doubt that the stuff in the proprietary binary was not back-door or whatever, if you

00:27:49,280 --> 00:27:53,060
are a government agency you would care about that.

00:27:53,060 --> 00:27:57,600
Maybe not everybody else would care, but some people do.

00:27:57,600 --> 00:28:03,820
If all firm ware was open source from all manufacturers, you can guarantee the integrity

00:28:03,820 --> 00:28:06,390
of the hardware as well.

00:28:06,390 --> 00:28:09,960
But today, you basically guarantee what you say it is.

00:28:09,960 --> 00:28:18,780
It is still a pipe dream to have that, though.

00:28:18,780 --> 00:28:26,350
To wrap up, through open source visibility, minimalism, and open communication, you can

00:28:26,350 --> 00:28:31,380
push computing to a better, more secure place from the hardware-up.

00:28:31,380 --> 00:28:34,960
We can't keep building on top of shit.

00:28:34,960 --> 00:28:38,130
Nobody needs to really care about these base layers.

00:28:38,130 --> 00:28:40,330
How can you help?

00:28:40,330 --> 00:28:47,140
Push back on vendors to open source their firmware, if the organization that you work

00:28:47,140 --> 00:28:52,540
in buys a lot of stuff from them, you will have more leverage than the rest of us.

00:28:52,540 --> 00:28:56,600
So, anyone can help in this space.

00:28:56,600 --> 00:29:01,550
And a huge thanks to the firmware community and all their work on this, because they have

00:29:01,550 --> 00:29:03,640
helped me understand a lot of this space, because I knew nothing going into it.

00:29:03,640 --> 00:29:04,640
There are great talks online if you want to dive deeper -- all these people have great

00:29:04,640 --> 00:29:05,640
talks online.

00:29:05,640 --> 00:29:06,640
Rick and Zaulen -- I don't know how to say that.

00:29:06,640 --> 00:29:07,640
And thank you for having me!

00:29:07,640 --> 00:29:08,640
[ Applause ]. >> Thank you so much, Jessie.

00:29:08,640 --> 00:29:09,640
That was fantastic.

00:29:09,640 --> 00:29:10,640
So we have a break until 3:15.

00:29:10,640 --> 00:29:11,640
So at 3:15 will be the next set of open spaces, you can find the schedule on Slack or on the

00:29:11,640 --> 00:29:12,640
board, or you can come here to play a real-life dungeons and dragons with Garima.

00:29:12,640 --> 00:29:20,450
So you can get some swag, something to drink, go talk on Slack, do things.

00:29:20,450 --> 00:29:28,320
>> Our main program will resume in main hall C in 5 minutes.

00:29:28,320 --> 00:29:35,540

YouTube URL: https://www.youtube.com/watch?v=oHK0lhBbJ3g


