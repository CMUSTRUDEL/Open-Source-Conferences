Title: DevOpsDays Boston 2019 - DevOps and the Database Bottleneck by Dan Zentgraf
Publication date: 2019-10-11
Playlist: DevOpsDays Boston 2019
Description: 
	DevOps and the Database Bottleneck by Dan Zentgraf

Databases are central to just about every application system but remain a neglected topic when it comes to DevOps. Seriously - while application change delivery has evolved to where changes can be applied in amazingly short intervals, most enterprise databases still live in a silo that exists somewhere on the other side of a bureaucratic ticket-driven process from 2003. To be fair, databases are critical things which, when broken, will break everything else. However, given that you can never be faster than your slowest operation, this central part of application systems is often a drag on teamsâ€™ overall throughput. So, something has to give if we are to get through the Database Bottleneck bring agility to application delivery and the businesses it supports.

The good news is that there is an emerging body of knowledge on how to conquer this challenge and this talk will:

Describe the problem of automating / accelerating database changes
Explain how the problem impacts the various roles in app delivery
Introduce the two main approaches to database change automation - state-based and migration-based
Explain the strengths and weaknesses of each approach
Discuss how they fit into CI/CD workflows
This talk will discuss problems, approaches, and solution patterns It will explicitly not have a tool or demo focus, but instead look at the approaches, processes and context into which you can fit tools.
Captions: 
	00:00:19,520 --> 00:00:33,290
So as Laura said my name is Dan Zentgraf I'm out of Austin, Texas.

00:00:33,290 --> 00:00:40,050
And one of the things I do down there is serve as an organizer to DevOps Days Austin.

00:00:40,050 --> 00:00:49,090
An annual event takes a ton of work to bring one of these things together be sure and thank

00:00:49,090 --> 00:00:56,370
the organizers, volunteers and sponsors for this event today and the great environment

00:00:56,370 --> 00:00:58,590
and venue that we're in.

00:00:58,590 --> 00:01:16,850
So with that, this afterthought we have about this database is kind of a weird thing.

00:01:16,850 --> 00:01:22,950
And the funny thing about this, so as we go -- we're going to talk about this.

00:01:22,950 --> 00:01:37,430
I'm going to focus databases The vast is still in relational platforms.

00:01:37,430 --> 00:01:59,880
We talk about blocking factors why is 

00:01:59,880 --> 00:02:02,110
this hard.

00:02:02,110 --> 00:02:09,200
Database change management has been around since the dawn of the database.

00:02:09,200 --> 00:02:35,700
I think there's three and a half pages where it actually mentions databases.

00:02:35,700 --> 00:02:43,000
And we all of a sudden we have to it rate to pull that off and bring automation to that

00:02:43,000 --> 00:02:44,060
problem.

00:02:44,060 --> 00:02:51,030
It just blows me away that 12 years later it's still kind of the same state of affairs.

00:02:51,030 --> 00:02:54,690
And you think about this community, we've had the opportunity to DevOps the heck out

00:02:54,690 --> 00:02:56,470
of everything else.

00:02:56,470 --> 00:03:00,090
And in some cases twice.

00:03:00,090 --> 00:03:07,890
And yet really fast.

00:03:07,890 --> 00:03:21,760
And the database takes hours and in some cases days.

00:03:21,760 --> 00:03:27,931
The process orchestrators, things that are CD tools, new ones, old ones, I get a quick

00:03:27,931 --> 00:03:30,910
survey of a mix.

00:03:30,910 --> 00:03:34,630
New ones, old ones, classics.

00:03:34,630 --> 00:03:35,630
Whatever.

00:03:35,630 --> 00:03:42,270
And two of one you look at their functionality and it boils down to we can run that SQL script

00:03:42,270 --> 00:03:46,840
good for you.

00:03:46,840 --> 00:03:53,230
We know scripts into the whole thing isn't quite the same as automation.

00:03:53,230 --> 00:03:56,550
So it's kind of a weird thing.

00:03:56,550 --> 00:04:07,790
So with that, I kind of was like well, what is it about the database.

00:04:07,790 --> 00:04:11,720
There's a new thing we can do with this.

00:04:11,720 --> 00:04:14,620
The first part is technical.

00:04:14,620 --> 00:04:25,100
Databases are funky things that don't lend themselves to easy automation, you kind of

00:04:25,100 --> 00:04:31,280
want it to stay, right.

00:04:31,280 --> 00:04:35,629
And despite the fact they actually have one of the oldest DSLs on the planet, it's an

00:04:35,629 --> 00:04:44,909
oldest international frigging standard.

00:04:44,909 --> 00:04:51,050
We have manual processes, hand crafting this and various rituals.

00:04:51,050 --> 00:04:53,270
That's kind of crazy.

00:04:53,270 --> 00:04:55,009
But here's the thing.

00:04:55,009 --> 00:04:59,629
Is that in addition to the data in the databases, the structure around the database is more

00:04:59,629 --> 00:05:02,910
than just data in the databases.

00:05:02,910 --> 00:05:21,309
And if you screw up these other pieces, you can lose data and that makes people very sad.

00:05:21,309 --> 00:05:26,740
The key integration.

00:05:26,740 --> 00:05:34,090
Monolithic or some kind of micro services, we don't have the APIs yet.

00:05:34,090 --> 00:05:41,469
So deep in the sac and touch it, and stuff falls down and you figure out quickly especially

00:05:41,469 --> 00:05:47,960
if an organization you don't just update a database.

00:05:47,960 --> 00:05:53,340
Second piece is of course the big organization factor.

00:05:53,340 --> 00:05:57,840
In most organizations you find that the database team is a black box on the other side of the

00:05:57,840 --> 00:05:58,840
wall.

00:05:58,840 --> 00:06:00,419
You stuff in a ticket.

00:06:00,419 --> 00:06:09,259
The DBAs are seeing more of the changes coming out.

00:06:09,259 --> 00:06:15,870
Devs are adopting agile and other practices, and we're getting helpers that have to be

00:06:15,870 --> 00:06:19,360
empowered to make their own changes if they're going to do their job.

00:06:19,360 --> 00:06:26,879
And the developers vastly outnumber DBAs.

00:06:26,879 --> 00:06:44,249
I see numbers, my record is 200 to 1, developers to DBA s.

00:06:44,249 --> 00:06:54,830
A proliferation of database platforms, now are enterprise.

00:06:54,830 --> 00:07:04,120
They can come in, and now DBAs have to learn that.

00:07:04,120 --> 00:07:18,789
It is the new oil under this industrial revolution in which we find ourselves.

00:07:18,789 --> 00:07:25,499
No pressure on what's happening to the resources of DBAs.

00:07:25,499 --> 00:07:29,219
And you put these things together and you figure out that yeah, this is a really tough

00:07:29,219 --> 00:07:30,219
thing.

00:07:30,219 --> 00:07:36,870
Like we bring these factors together in DevOps, it's all these things, you figure out pretty

00:07:36,870 --> 00:07:41,669
quickly, that this is the fact the failure is extremely high.

00:07:41,669 --> 00:07:44,860
Big corporations have these multi terabyte databases.

00:07:44,860 --> 00:07:57,979
The time for recovery is difficult now.

00:07:57,979 --> 00:08:02,330
If you screw this up it's not just a bad day, you could be in the news.

00:08:02,330 --> 00:08:10,270
So a classic kind of problem, it's harder to deal with.

00:08:10,270 --> 00:08:15,229
So the organizations responded as they usually do by throwing people in the process, barriers

00:08:15,229 --> 00:08:18,349
to change rather than facilitators to change.

00:08:18,349 --> 00:08:20,599
They get to say put an expert in.

00:08:20,599 --> 00:08:27,899
No how many how worked the expert is our safety valve, and if nothing else we can blame them

00:08:27,899 --> 00:08:32,050
if things go wrong.

00:08:32,050 --> 00:08:33,839
Meanwhile you have other factors.

00:08:33,839 --> 00:08:37,390
If you think about what this means, if you've got all these different teams and the database

00:08:37,390 --> 00:08:41,750
is my point of integration, inject the change in this thing.

00:08:41,750 --> 00:08:49,900
How do I control what's going on in there and how do I know my changes aren't going

00:08:49,900 --> 00:08:50,900
to break anything.

00:08:50,900 --> 00:08:54,200
A full stack developer should be doing this stuff, that's awesome.

00:08:54,200 --> 00:09:01,420
How many of them have been writing SQL any length of time or volume.

00:09:01,420 --> 00:09:10,720
It's a lovely new phenomenon and the right to change, but will it be performing?

00:09:10,720 --> 00:09:15,470
Will it kill the database with incredibly long operation?

00:09:15,470 --> 00:09:18,820
You need some way of catching that stuff.

00:09:18,820 --> 00:09:23,200
And on top of that, part of the reason we have that proliferation is it's a call center.

00:09:23,200 --> 00:09:24,350
It's IT ops.

00:09:24,350 --> 00:09:25,640
How do we drive that down?

00:09:25,640 --> 00:09:29,310
We start changing out our databases because that open source stuff is a hell of a lot

00:09:29,310 --> 00:09:38,510
cheaper than the classic databases we called enterprise and we are done, so it's pretty

00:09:38,510 --> 00:09:41,160
daunting when you think about this, right?

00:09:41,160 --> 00:09:43,720
But I've got a piece of good news for you.

00:09:43,720 --> 00:09:46,680
We've done this before.

00:09:46,680 --> 00:09:51,970
So in DevOps we have fought this battle before.

00:09:51,970 --> 00:09:56,870
I remember back in the old days we used to have to convince system administrators that

00:09:56,870 --> 00:10:02,840
an ephemeral environment is a possible thing.

00:10:02,840 --> 00:10:12,630
There's no magic bullet for convincing them to do it.

00:10:12,630 --> 00:10:16,940
It's important it needs to be done if we're going to go forward.

00:10:16,940 --> 00:10:23,940
There's no magic bullet for tearing down those monoliths for proper APIs so they can communicate.

00:10:23,940 --> 00:10:25,340
Bad news, it's engineering.

00:10:25,340 --> 00:10:30,010
There's no magic bullet for any of this stuff.

00:10:30,010 --> 00:10:35,380
So at the end of the day it comes down to making sure we have a good definition of our

00:10:35,380 --> 00:10:41,760
problem where our primary bottlenecks are, start to build some solutions, working through

00:10:41,760 --> 00:10:48,830
it, measuring our outcomes, improving, iterating and getting better so we can get this bottleneck

00:10:48,830 --> 00:10:50,880
out of our way.

00:10:50,880 --> 00:10:53,800
Which brings us to the next line.

00:10:53,800 --> 00:10:56,080
What does database change management even mean?

00:10:56,080 --> 00:11:00,000
How many people have thought about database change management?

00:11:00,000 --> 00:11:05,330
What are the principles in play here?

00:11:05,330 --> 00:11:10,560
The funny thing is well, I think it's kind of funny, but it's like actually pretty simple.

00:11:10,560 --> 00:11:14,750
There are two basic ways you can approach this problem.

00:11:14,750 --> 00:11:17,910
First of all we call a migration based approach.

00:11:17,910 --> 00:11:21,420
We say that the change is the most important thing.

00:11:21,420 --> 00:11:22,870
That is our first-class citizens.

00:11:22,870 --> 00:11:26,630
We create the change, we manage the hell out of the change, we understand what's going

00:11:26,630 --> 00:11:31,690
on with the change itself at all points in the second.

00:11:31,690 --> 00:11:34,220
Second is what's called state-based.

00:11:34,220 --> 00:11:41,840
And this says that the state of the database or bases are the first-class citizen.

00:11:41,840 --> 00:11:44,740
The state is the most important thing.

00:11:44,740 --> 00:11:54,280
And we worry about finding differences among them to progress the changes.

00:11:54,280 --> 00:11:56,280
Summarized.

00:11:56,280 --> 00:12:03,440
Migration is the as code approach, state base is the point and click approach.

00:12:03,440 --> 00:12:18,280
Requires good knowledge of 

00:12:18,280 --> 00:12:19,280
the SQL.

00:12:19,280 --> 00:12:24,220
The tool figures it out in a state based environment.

00:12:24,220 --> 00:12:33,690
Migration based cares about the impacted objects, state-based cares about all the objects.

00:12:33,690 --> 00:12:35,620
Each of them have strengths and weaknesses.

00:12:35,620 --> 00:12:39,200
There's a set of trade-offs.

00:12:39,200 --> 00:12:41,590
There's no magic bullet.

00:12:41,590 --> 00:12:44,140
There are good points and bad points to each of these.

00:12:44,140 --> 00:12:54,550
In a migration based approach, we have a lot of existing documents.

00:12:54,550 --> 00:12:59,070
We know how to merge the code from multiple creators.

00:12:59,070 --> 00:13:04,030
I can isolate my changes very easily in a large database.

00:13:04,030 --> 00:13:09,910
I can group my changes very easily so I know what's a release, what's in the release and

00:13:09,910 --> 00:13:13,750
what's moving forward.

00:13:13,750 --> 00:13:17,470
On pretty cool.

00:13:17,470 --> 00:13:24,670
In a state based on the other hand is really good when it comes to closed teams.

00:13:24,670 --> 00:13:27,970
It's easy to isolate stuff.

00:13:27,970 --> 00:13:34,481
I don't have to worry as much about having somebody on staff who's a good SQL database

00:13:34,481 --> 00:13:38,130
person or make sure I've got that knowledge widespread.

00:13:38,130 --> 00:13:45,160
I can get a guilty drift detection so if someone starts monkeying with that database on that

00:13:45,160 --> 00:13:50,110
pipe lane, I'm going to see it because I'm looking at it all the time.

00:13:50,110 --> 00:13:52,590
And it's really easy to deal with bulk changes.

00:13:52,590 --> 00:14:00,560
I can make a whole bunch of changes, boom I'm in and done.

00:14:00,560 --> 00:14:04,130
Conversely, each of them has down sides.

00:14:04,130 --> 00:14:11,620
Migration based, it has the core problem that there is a need for strong database engine

00:14:11,620 --> 00:14:15,660
and SQL knowledge somewhere on the team.

00:14:15,660 --> 00:14:24,740
Database changes have to go in a certain order otherwise bad things can happen.

00:14:24,740 --> 00:14:31,760
We're going to have to do the DevOps thing and tear down some of our organizational roles.

00:14:31,760 --> 00:14:34,670
And I'm going to have to invent a process for that group detection.

00:14:34,670 --> 00:14:38,370
A large environment a lot of stuff coming in, I'm going to have some something that

00:14:38,370 --> 00:14:40,670
monitors the change.

00:14:40,670 --> 00:14:46,540
State based is complicated environments and you have this situation where you need to

00:14:46,540 --> 00:14:49,430
isolate and merge changes from multiple contributors.

00:14:49,430 --> 00:14:53,800
It becomes difficult to do that, because whose state takes precedent.

00:14:53,800 --> 00:14:59,670
What works on my machine, works on my machine and the database in the middle who goes first.

00:14:59,670 --> 00:15:04,120
You have to answer that question and you have to invent a process to arbitrate the changes

00:15:04,120 --> 00:15:06,240
as they come in together.

00:15:06,240 --> 00:15:10,760
So it's a process either way.

00:15:10,760 --> 00:15:14,940
State-based also requires you to be absolutely sure of the state before you push a button

00:15:14,940 --> 00:15:16,200
to generate the changes.

00:15:16,200 --> 00:15:20,010
You have to do it absolutely perfectly every time.

00:15:20,010 --> 00:15:26,960
So that's a thing.

00:15:26,960 --> 00:15:30,670
And you do the bulk thing, somebody gets to review the code.

00:15:30,670 --> 00:15:36,170
And if you've ever reviewed code generated by a tool, you know how much fun that really

00:15:36,170 --> 00:15:39,230
isn't.

00:15:39,230 --> 00:15:44,110
So the cool thing is is that if you think about it, you're going to end up using attributes

00:15:44,110 --> 00:15:45,750
of both of these.

00:15:45,750 --> 00:15:52,990
It's going to be your organizational of how you do this, but there's no purity thing here.

00:15:52,990 --> 00:15:56,630
This is engineering, use the capabilities at hand you take a primary approach build

00:15:56,630 --> 00:16:01,279
the processes around and you cherry pick the stuff that's going to help.

00:16:01,279 --> 00:16:11,150
If you're state-based you still want to need and add tweak scripts.

00:16:11,150 --> 00:16:15,930
So you might use a state-based technique to make sure you're writing the best changes

00:16:15,930 --> 00:16:18,310
possible to a migration based approach.

00:16:18,310 --> 00:16:20,540
It doesn't mean you're suddenly state-based.

00:16:20,540 --> 00:16:23,080
Okay.

00:16:23,080 --> 00:16:26,330
So database changes.

00:16:26,330 --> 00:16:30,650
And an idea of what's going on there, still doesn't answer the question.

00:16:30,650 --> 00:16:31,740
How do we actually break the bottleneck?

00:16:31,740 --> 00:16:35,390
How do we bring this into our CI/CD processes?

00:16:35,390 --> 00:16:39,890
Again, the good news here is that you've learned some things over the years.

00:16:39,890 --> 00:16:45,080
Some examples of CI/CD.

00:16:45,080 --> 00:16:50,120
Of things you need to do for anything, full stop.

00:16:50,120 --> 00:16:52,180
You need to involve everyone.

00:16:52,180 --> 00:16:54,060
It seems like it's a good idea.

00:16:54,060 --> 00:16:58,080
DevOps is a collaboration kind of a thing.

00:16:58,080 --> 00:17:03,360
I need to figure out how to do fast feedback loops if I'm going to make a change to an

00:17:03,360 --> 00:17:07,860
app or a database, I need to know if the change is any good.

00:17:07,860 --> 00:17:11,860
Does it actually advance the ball for my application.

00:17:11,860 --> 00:17:17,990
Small batch processing, how do I keep it easy to track.

00:17:17,990 --> 00:17:22,420
I want to make sure I'm doing the things the right way, the same all the way through the

00:17:22,420 --> 00:17:23,420
process.

00:17:23,420 --> 00:17:25,600
My environments look the same, everything is consistent.

00:17:25,600 --> 00:17:31,340
Again, guess what?

00:17:31,340 --> 00:17:38,460
When we talk about focusing in on bringing the databases into our CI/CD flow, let's talk

00:17:38,460 --> 00:17:41,620
about it the four angles.

00:17:41,620 --> 00:17:43,990
First we want a version of the thing.

00:17:43,990 --> 00:17:49,770
We want to automate everything, we want to test everything and that production-like environment

00:17:49,770 --> 00:17:57,240
stuff for a beast like a database becomes super important.

00:17:57,240 --> 00:18:01,620
So versioning everything.

00:18:01,620 --> 00:18:08,211
One thing I love about these things, we have these vast, picky things in the DevOps, version

00:18:08,211 --> 00:18:09,770
all the things.

00:18:09,770 --> 00:18:12,720
What are all the things when we start talking about database changes?

00:18:12,720 --> 00:18:14,930
What is everything in our context?

00:18:14,930 --> 00:18:16,630
First is the changes themselves.

00:18:16,630 --> 00:18:22,100
It's like check your scripts into source code please for the love of God.

00:18:22,100 --> 00:18:29,400
I mean, and that sounds obvious, it's like oh.

00:18:29,400 --> 00:18:36,060
You would be shocked the number of these enterprises I go into, this just happened last month,

00:18:36,060 --> 00:18:43,920
large financial services company, someplace on the west coast, tons of PII, massive financial

00:18:43,920 --> 00:18:50,530
regulated space, seeking changes in an open file share.

00:18:50,530 --> 00:18:53,160
Yeah.

00:18:53,160 --> 00:18:54,260
So yeah.

00:18:54,260 --> 00:18:55,350
Anyway.

00:18:55,350 --> 00:18:56,410
Start there.

00:18:56,410 --> 00:18:59,470
The second thing you have to think about when you're versioning stuff is how do I group

00:18:59,470 --> 00:19:00,470
my changes.

00:19:00,470 --> 00:19:05,540
If I'm going to actually make multiple changes into a system, how do I group them and version

00:19:05,540 --> 00:19:08,760
that group so I can track it through my python.

00:19:08,760 --> 00:19:14,360
These changes, I've tested them, these changes in this order, all together.

00:19:14,360 --> 00:19:18,120
And how do I do that in an environment consistently.

00:19:18,120 --> 00:19:20,820
Third thing is the schema itself.

00:19:20,820 --> 00:19:29,980
The schema, to be able to self-identify, both to a human, as well as to the automated process,

00:19:29,980 --> 00:19:31,780
where it is at.

00:19:31,780 --> 00:19:37,160
So I know what schema I'm working on, I can compare, I can contrast, I can run my changes,

00:19:37,160 --> 00:19:42,550
I can know if the changes are actually a fit or not, doing the right thing in the right

00:19:42,550 --> 00:19:49,590
place, whether it's as a humor an automated process, without that implementation, problems

00:19:49,590 --> 00:19:53,920
occur.

00:19:53,920 --> 00:19:54,920
Second thing.

00:19:54,920 --> 00:19:55,920
Automate everything.

00:19:55,920 --> 00:20:00,560
Automation is the backbone of everything we do in DevOps.

00:20:00,560 --> 00:20:01,560
Absolute backbone.

00:20:01,560 --> 00:20:06,740
And when you apply that to bringing something lake database changes into the CI/CD pipeline

00:20:06,740 --> 00:20:08,910
we have multiple points we have to think about.

00:20:08,910 --> 00:20:17,510
The first is how do we actually automation -- shift left some quality here.

00:20:17,510 --> 00:20:24,040
We've got to build for code, how do we get something like that for our database changes.

00:20:24,040 --> 00:20:30,580
Give feedback immediately to the change creator that changes are great, hey, these changes

00:20:30,580 --> 00:20:32,400
kind of suck.

00:20:32,400 --> 00:20:38,160
I mean, this is lake a very first thing that we need to determine.

00:20:38,160 --> 00:20:41,330
How do we break the build over bad database change.

00:20:41,330 --> 00:20:43,950
Seems like a simple question for everything else.

00:20:43,950 --> 00:20:45,940
But there you are.

00:20:45,940 --> 00:20:48,750
Obviously we want to be automated to the entire pipeline.

00:20:48,750 --> 00:20:53,820
We want to do the same thing in every environment, every time.

00:20:53,820 --> 00:20:55,430
We want to do it the same way.

00:20:55,430 --> 00:20:59,559
So we know that if it's repeatable, we know that if it's an actual production I want to

00:20:59,559 --> 00:21:02,991
do it a lot of times in my lower environments, stop me if you've heard this before.

00:21:02,991 --> 00:21:09,210
We want to rehearse our deployments so when we get to production it's a nonissue.

00:21:09,210 --> 00:21:14,240
That way we know it's repeatable we have a hey degree of faith that we're going to get

00:21:14,240 --> 00:21:17,200
what we expect.

00:21:17,200 --> 00:21:34,560
And last thing is how do I use automation smart so I can refresh my environment.

00:21:34,560 --> 00:21:39,000
We also have to worry coming back the other way.

00:21:39,000 --> 00:21:48,660
The more you're going get these big environments, know that you're testing in good environments

00:21:48,660 --> 00:21:57,380
with good test data so you have high Fidelity tests.

00:21:57,380 --> 00:22:07,150
Support feature changes, road tests, reset as quick as I can.

00:22:07,150 --> 00:22:16,050
It's going to happen with someone typing fixed scripts or copying them in.

00:22:16,050 --> 00:22:18,130
Testing everything.

00:22:18,130 --> 00:22:23,679
So I mentioned already the idea about having a good set of inspections for the changes

00:22:23,679 --> 00:22:25,550
at the build time.

00:22:25,550 --> 00:22:36,120
We're trying to answer three questions when the changes come in.

00:22:36,120 --> 00:22:43,020
Guess what static code checkers exist for SQL if you use them, they work.

00:22:43,020 --> 00:22:44,670
And you can know if these changes are acceptable.

00:22:44,670 --> 00:22:47,140
Should I do anything with them in the first place.

00:22:47,140 --> 00:22:50,710
Then I need to know, do they work.

00:22:50,710 --> 00:22:57,320
And if they do work, do they leave the database in a good state.

00:22:57,320 --> 00:23:01,390
I can run a smoke test against it, how am I expecting my database changes, how can I

00:23:01,390 --> 00:23:10,430
make sure that they work the way I expected.

00:23:10,430 --> 00:23:13,580
At any stage in the pipeline.

00:23:13,580 --> 00:23:15,270
What's my strategy for fixing it.

00:23:15,270 --> 00:23:22,970
Can I refresh the environment quickly, do I role back, fix forward, what is it?

00:23:22,970 --> 00:23:24,910
You have to pick.

00:23:24,910 --> 00:23:28,940
Otherwise you spent a bunch of time with people sitting on their hands while somebody fixes

00:23:28,940 --> 00:23:32,360
the database so that you can do it again.

00:23:32,360 --> 00:23:36,710
Remember that by definition at some point here, you are putting completely untested

00:23:36,710 --> 00:23:40,309
changes into a target database.

00:23:40,309 --> 00:23:41,680
Things are going to break.

00:23:41,680 --> 00:23:47,130
You have to have a strategy for resetting that environment and trying the changes again

00:23:47,130 --> 00:23:52,970
to a hopeful work.

00:23:52,970 --> 00:23:59,270
And that goes directly to this idea of ensuring production-like environments.

00:23:59,270 --> 00:24:01,680
Have you to figure out what your refresh strategy is going to be.

00:24:01,680 --> 00:24:05,070
How do I refresh the environment quickly.

00:24:05,070 --> 00:24:06,770
There's techniques.

00:24:06,770 --> 00:24:12,000
There are clouds in the clouds, there are things in the sand if you're on-prem that

00:24:12,000 --> 00:24:15,870
you can do to rapidly reset a database.

00:24:15,870 --> 00:24:19,210
Not just the structure but also the data in it.

00:24:19,210 --> 00:24:26,920
Just the amount of products that you can create hybrids to do it.

00:24:26,920 --> 00:24:32,600
Again you have to have a strategy, otherwise what the heck are you testing against?

00:24:32,600 --> 00:24:45,320
Is it the right schema for the feature, does it have the right data, what?

00:24:45,320 --> 00:24:47,250
So this becomes a thing.

00:24:47,250 --> 00:24:57,590
You can do simple things like a clever thing I saw recently is test-driven development.

00:24:57,590 --> 00:25:01,760
Your pull request doesn't -- your pull request doesn't get accepted if you don't have the

00:25:01,760 --> 00:25:06,309
matching test for the new in-bound future.

00:25:06,309 --> 00:25:11,780
Your pull request for your SQL changes don't get accepted until you have a matching fixed

00:25:11,780 --> 00:25:13,560
script.

00:25:13,560 --> 00:25:17,860
It just doesn't get accepted.

00:25:17,860 --> 00:25:20,660
Full stop.

00:25:20,660 --> 00:25:23,820
Simple things, simple steps, measurable improvements.

00:25:23,820 --> 00:25:32,360
And that's where I want to wrap up.

00:25:32,360 --> 00:25:38,600
Is data changes in our environment or application changes don't have to be slow.

00:25:38,600 --> 00:25:39,970
There's no reason for it.

00:25:39,970 --> 00:25:44,010
The tools, the techniques are out there and they work.

00:25:44,010 --> 00:25:45,630
It is completely doable.

00:25:45,630 --> 00:25:48,960
But there is no magic bullet.

00:25:48,960 --> 00:25:55,600
Take away the ideas to get started and bring this stuff and start working on it in your

00:25:55,600 --> 00:26:00,480
own shop and take this bottleneck out of your environment, take the quality of problems

00:26:00,480 --> 00:26:04,800
that go with it out of your environment and start making it work right.

00:26:04,800 --> 00:26:11,679
To that end, I have a number of resources you can look into, some reading on database

00:26:11,679 --> 00:26:12,679
change management.

00:26:12,679 --> 00:26:19,410
I will post these slides someplace, the organizer said there's a place to put them, I will put

00:26:19,410 --> 00:26:21,570
them there.

00:26:21,570 --> 00:26:23,559
There's readings and some tools.

00:26:23,559 --> 00:26:30,230
Open source and commercial, that can help you do the things and learn about doing the

00:26:30,230 --> 00:26:35,650
things here for your inspection.

00:26:35,650 --> 00:26:38,420
So with that, I think we're right at about time.

00:26:38,420 --> 00:26:39,870
And we're going out into break.

00:26:39,870 --> 00:26:42,320
I stand between you and coffee.

00:26:42,320 --> 00:26:49,679
So I want to thank you all very much.

00:26:49,679 --> 00:26:50,190

YouTube URL: https://www.youtube.com/watch?v=6lePgmJ4x7c


