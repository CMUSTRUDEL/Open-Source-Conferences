Title: DevOpsDays Boston 2019- A Monolith, a Microservices, and a Function Walk into a Bar by Ian Crosby
Publication date: 2019-10-11
Playlist: DevOpsDays Boston 2019
Description: 
	A Monolith, a Microservices, and a Function Walk into a Bar by Ian Crosby

With a variety of choices and a constantly changing landscape designing a lasting architecture is no easy task. Monolith style applications take a lot of criticism these days, but when starting a new project this is often the right choice. In the early stages we cannot anticipate the changes which will come, from a technical perspective or in terms of features and requirements. Microservices, serverless or the next latest trend may be turn out to be the solution we need, but this is rarely clear on day one. The most important aspect of any new architecture is that it lends itself to incremental change.

In this talk, we will walk through evolving a non trivial monolithic application. We’ll cover how and why to split out functionality as microservices. From there we will continue with separating pieces into functions, and integrate them via the serverless paradigm. We’ll cover the platforms, patterns, and practices which make these migrations easier.

Attendees will learn the benefits and drawbacks of each architecture style. As well as best practices for evolving your architecture (when, why, and how). The live demo will involve Docker, Kubernetes and KNative, while focusing on the general patterns rather than the specific technologies involved.

#DevOpsDays #DevOpsDaysBoston
Captions: 
	00:00:01,480 --> 00:00:27,289
Cool. Thank you very much. Very happy to be here at DevOpsDays Boston. I think this full

00:00:27,289 --> 00:00:32,140
room is proof that if you throw enough buzzwords into your title, people will come to your

00:00:32,140 --> 00:00:34,260
talk. [ Laughter ]

00:00:34,260 --> 00:00:39,020
I only realized after submitting this abstract and getting accepted that I was probably gonna

00:00:39,020 --> 00:00:44,200
have to come up with a punchline for this or else there would be a big disappointment.

00:00:44,200 --> 00:00:49,609
Which I did. If you stick around to the end, I promise a very lame joke. But I want to

00:00:49,609 --> 00:00:54,239
start with a quick story. This is about a project that I worked on. A little more than

00:00:54,239 --> 00:00:59,690
a year ago. And we had a client come to us and had this really cool piece of technology.

00:00:59,690 --> 00:01:05,420
And they wanted us to build this cloud platform for it. And there's NDAs involved so I can't

00:01:05,420 --> 00:01:09,100
specifically talk about the client and the technology. But it doesn't really matter.

00:01:09,100 --> 00:01:14,020
Basically this piece of technology's hardware was going to collect a bunch of data and fed

00:01:14,020 --> 00:01:19,640
into the platform to do a bunch of machine learning stuff and solve all these interesting

00:01:19,640 --> 00:01:24,640
problem farce bunch of different people. They were really excited about this and I was really

00:01:24,640 --> 00:01:31,150
excited. An opportunity to build this, really a green field. So, we started and went on

00:01:31,150 --> 00:01:36,820
to design this ideal architecture, right? So, everything was microservices from the

00:01:36,820 --> 00:01:42,240
start. Everything in containers, running on Kubernetes in the cloud. Using message queues,

00:01:42,240 --> 00:01:46,820
event driven, all stuff that you're supposed to do. And things were coming along pretty

00:01:46,820 --> 00:01:52,020
well. We are nearing the alpha release of this platform. And then we had a meeting with

00:01:52,020 --> 00:01:56,950
the client and they said, hey, we have good news. We actually found somebody who wants

00:01:56,950 --> 00:02:01,631
to use this platform. And I was like, well, yeah, that's probably important. Somebody

00:02:01,631 --> 00:02:06,890
actually using this. And they said, yeah, so, can you take that platform you built and

00:02:06,890 --> 00:02:12,011
run it on one of their servers inside their closed private network. So

00:02:12,011 --> 00:02:17,510
[ Laughter ] As frustration slowly turned into this kind

00:02:17,510 --> 00:02:23,500
of realization, these weren't crazy demands on their side, right? The learning that I

00:02:23,500 --> 00:02:31,030
eventually came to is that there is no ideal architecture. Everything depends on context.

00:02:31,030 --> 00:02:35,269
It depends on the business case that you start from. And you can design this, you know, beautiful,

00:02:35,269 --> 00:02:40,680
perfect system, but if you don't have a proper use for it, then what's the point? And so,

00:02:40,680 --> 00:02:44,342
this is kind of when inspired me to throw this talk together. And this is one of the

00:02:44,342 --> 00:02:48,590
things I want to talk about is this idea of an ideal architecture and what is it or what

00:02:48,590 --> 00:02:54,969
are the different architectures we can use? So, already thrown this term around a bit

00:02:54,969 --> 00:03:00,579
so far today. An architecture, I think, it's obviously a term that we've borrowed from

00:03:00,579 --> 00:03:05,780
somewhere else. And maybe in the early days it had a better fit. But I think more and

00:03:05,780 --> 00:03:11,609
more this is the metaphor's not working very well. So, we think of architectures for buildings.

00:03:11,609 --> 00:03:15,610
This is a lot of design work which is done fully up front and then gets handed off to

00:03:15,610 --> 00:03:19,900
this other team, this other company to go and build things. And the architecture is

00:03:19,900 --> 00:03:25,340
pretty much static for the life cycle. But I think this software architecture, this is

00:03:25,340 --> 00:03:30,050
not the case anymore. Architectures that we build in design are going to be constantly

00:03:30,050 --> 00:03:36,200
changing. We need to think about that when we build architecture. So, if we can't take

00:03:36,200 --> 00:03:41,620
the architecture metaphor from buildings anymore, then how do we define it? Well, there's not

00:03:41,620 --> 00:03:45,549
really that many great definitions of this. I was kind of searching through. And the best

00:03:45,549 --> 00:03:50,310
definition that I like the most came from Martin Fowler, actually quoting Ralph Johnson.

00:03:50,310 --> 00:03:56,900
So, architecture is the important stuff. Whatever that is. And it seems kind of like a funny

00:03:56,900 --> 00:04:01,529
definition, but it's also pretty powerful. I mean, architecture, it's the important things,

00:04:01,529 --> 00:04:04,959
right? These are the things, the decisions that we want to get right at the start. Because

00:04:04,959 --> 00:04:09,930
they're going to be harder to change later. And the second part, you know, whatever that

00:04:09,930 --> 00:04:15,419
is. Because it depends. Every project is different what the important things are. The architecture

00:04:15,419 --> 00:04:21,090
is going to be different for every single system. But even with all this, you know,

00:04:21,090 --> 00:04:25,290
there have been some trends. All right? If we kind of go way back and look at mainframes

00:04:25,290 --> 00:04:32,570
and into client server architectures and three tier and microservices. You can see this trend

00:04:32,570 --> 00:04:38,200
of slowly splitting things into smaller and smaller pieces. When you think of these trends,

00:04:38,200 --> 00:04:45,751
you are forgiven to come to this conclusion. We had monoliths, and they were all right

00:04:45,751 --> 00:04:52,270
for a while. And microservices are better. And serverless, split it into smaller pieces.

00:04:52,270 --> 00:04:58,480
And serverless is even better. But I think this is essentially not true. And that's the

00:04:58,480 --> 00:05:04,060
realization they came to. It depends on your business case or context which architecture

00:05:04,060 --> 00:05:09,340
is better. So, I want to quickly run through each of these three, just kind of at a high

00:05:09,340 --> 00:05:13,700
level, talk about some of their pros and cons and some of the use cases. And I know this

00:05:13,700 --> 00:05:18,560
doesn't blanketly cover all kinds of architectures. There's many different styles out there. But

00:05:18,560 --> 00:05:25,010
these are the common three terms that we're using a lot today. So, if we start with the

00:05:25,010 --> 00:05:30,970
monolith. You know, how do we define this? It's kind of a blanket term, right? Generally

00:05:30,970 --> 00:05:36,250
a monolith, we think of things being all one single piece. The most important part of that

00:05:36,250 --> 00:05:42,390
deployment. If we have to deploy our system or application all together, then even if

00:05:42,390 --> 00:05:47,410
it's separated, this is essentially a monolith we have. And there are different types. The

00:05:47,410 --> 00:05:52,410
most common would be a single process. Right? Everything is run as a single process in,

00:05:52,410 --> 00:05:58,270
for example, like a jar file. There are also this idea of modular monoliths. Believe it

00:05:58,270 --> 00:06:05,330
or not, you can have nice, well architected monolithic architectures. And then you can

00:06:05,330 --> 00:06:09,860
even try and build a distributed road. But if you end up with all these different dependencies

00:06:09,860 --> 00:06:16,230
and coupling and you have to deploy your thing together, you still essentially have a monolith.

00:06:16,230 --> 00:06:20,740
But there are some advantages of this kind of architecture, right? First of all, they're

00:06:20,740 --> 00:06:25,400
very quick to build. So, if I'm starting something from scratch, this is probably the road that

00:06:25,400 --> 00:06:29,580
I'm going to take. Because it's much quicker, especially with a small team, to just get

00:06:29,580 --> 00:06:36,951
something built and get something work. They're more performant in certain aspects. If we

00:06:36,951 --> 00:06:41,510
think of everything running in a single process, all of these function calls with a lot quicker

00:06:41,510 --> 00:06:49,600
than anything that has to go across the network. Simple. A caveat there. But in general, if

00:06:49,600 --> 00:06:53,381
our architecture is, you know, this one big piece, it's much easier to reason about, it's

00:06:53,381 --> 00:07:00,600
easier to plan for in things like deployments. Of course, there's some drawbacks as well.

00:07:00,600 --> 00:07:05,650
Maintenance is inherently difficult in monoliths. The more monolithic an application, the longer

00:07:05,650 --> 00:07:11,500
it lives, the harder and harder it is to maintain these things and the slower they end up into

00:07:11,500 --> 00:07:19,320
this big ball of mud. Deployments can be very difficult. Even changing a small piece of

00:07:19,320 --> 00:07:23,411
your application, if you have to deploy the whole thing, you're never entirely shoe how

00:07:23,411 --> 00:07:28,620
it's going to affect the rest. Deployments become a really scary idea where we have a

00:07:28,620 --> 00:07:34,710
bunch of people on call and just waiting to see if something goes wrong. And then we're

00:07:34,710 --> 00:07:38,960
kind of locked into the technology choices we make at the beginning. You know, programming

00:07:38,960 --> 00:07:43,590
language you choose, the database, for example. We're more or less stuck with those for the

00:07:43,590 --> 00:07:48,970
life cycle of this. But with these pros and cons in mind, there are use cases where it's

00:07:48,970 --> 00:07:54,660
the right thing. So, things like proof of concepts or prototypes. Again, if we're starting

00:07:54,660 --> 00:08:00,790
from scratch, a monolith is just much quicker to build so it's probably the better use case.

00:08:00,790 --> 00:08:05,940
If we only have a single team, you know, maybe building just a small or medium size application,

00:08:05,940 --> 00:08:11,780
then why bother with anything else? A monolith might still be a good fit. Or if we have something

00:08:11,780 --> 00:08:16,380
that's just very well defined, once it's built we don't expect a lot of changes coming around.

00:08:16,380 --> 00:08:22,590
And maybe we should think about a monolithic style application. So, from there we move

00:08:22,590 --> 00:08:30,080
on to microservices. And to define this, I'll leave that to Sam Newman. So, he defined a

00:08:30,080 --> 00:08:37,219
microservice as independently deployable services modeled around a business domain. It necessarily

00:08:37,219 --> 00:08:43,289
follows that a microservice architecture is composed of many different microservices.

00:08:43,289 --> 00:08:48,379
And there are certain qualities that we kind of expect. They're small, hence the name,

00:08:48,379 --> 00:08:54,420
they're scalable, elastic, they should be resilient, fault tolerant. These are all characteristics

00:08:54,420 --> 00:09:00,921
that we want to build into good microservices. , of course, there are some advantages. Our

00:09:00,921 --> 00:09:06,870
design is much measure flexible. It's easier to swap out different pieces. Adding in functionality,

00:09:06,870 --> 00:09:10,600
we can, again, choose the technology we want. Maybe something fits better in a different

00:09:10,600 --> 00:09:18,250
language. Easier to scale. If I'm, you know, running into bottlenecks with my application,

00:09:18,250 --> 00:09:22,370
and, you know, I need to run another instance or I need to, you know, be able to handle

00:09:22,370 --> 00:09:26,899
more traffic. But I can only scale the piece that specifically needs it rather than running

00:09:26,899 --> 00:09:33,750
an entire instance of my whole monolithic application. And kind of from the Conway's

00:09:33,750 --> 00:09:38,329
Law sort of things, it does match nice we are larger organization when is you have many

00:09:38,329 --> 00:09:43,519
different teams. You know, we can assign certain teams a microservice or several microservices.

00:09:43,519 --> 00:09:48,620
They don't need to know or understand the entire system. They have their specific domain

00:09:48,620 --> 00:09:56,560
and they can work with the rest through well designed APIs. Of course, there's some drawbacks

00:09:56,560 --> 00:10:02,240
here as well. All the complexity which may have existed in the complex monolith, it now

00:10:02,240 --> 00:10:07,220
moves to the network. And these can be very difficult to kind of track what's going on.

00:10:07,220 --> 00:10:12,899
You have probably all seen these dependency diagrams from Netflix and Amazon. They match

00:10:12,899 --> 00:10:16,839
all their dependencies between the different microservices and it can be very complicated

00:10:16,839 --> 00:10:24,569
to try to understand that. Latency. As we mentioned, all these nice quick function calls

00:10:24,569 --> 00:10:29,240
we had before, they're now going over the network. And these services are probably even

00:10:29,240 --> 00:10:35,551
running on different physical machines. So, they're going to be a bit slower. And there

00:10:35,551 --> 00:10:40,370
is a bit of a learning curve. With microservices themselves and all the new technologies which

00:10:40,370 --> 00:10:47,509
tend to come with it. So, this needs to be taken into account. In terms of use cases,

00:10:47,509 --> 00:10:53,180
again, if we have large organizations with many teams, we might think of a microservices

00:10:53,180 --> 00:10:59,540
approach. It might fit better with our team structures. If we have a well defined domain

00:10:59,540 --> 00:11:04,230
that we really understand well, and we're able to draw these bound arise between our

00:11:04,230 --> 00:11:11,100
services and be pretty confident, then, again, microservices might be a good fit. But I think

00:11:11,100 --> 00:11:15,569
the most common use case is, hey, we started with a monolith. And we've kind of reached

00:11:15,569 --> 00:11:21,180
the boundaries. We've reached the limits. Maybe now is time to move to something else.

00:11:21,180 --> 00:11:27,920
So, this brings us to serverless. I thought I was really clever here. This is a serverless

00:11:27,920 --> 00:11:34,999
data center. Apparently I'm far from the first person to make this joke. So, again, to define

00:11:34,999 --> 00:11:40,079
this, I'll let someone else do this job. This is from Mike Roberts. And here we're kind

00:11:40,079 --> 00:11:47,600
of distinguishing on the function as a service side. So, he defines it as logic which run

00:11:47,600 --> 00:11:53,529
in stateless compute containers that are event triggered, ephemeral, and fully managed by

00:11:53,529 --> 00:12:00,069
a third party. Break that down quickly, your applications are running in stateless containers.

00:12:00,069 --> 00:12:09,420
So, this enforces characteristics. Event triggered. Could be API calls, could be cues, could be

00:12:09,420 --> 00:12:14,430
anything. Ephemeral. They're not going to stick around. Again, we have to build this

00:12:14,430 --> 00:12:19,420
into our assumptions. And most importantly, fully managed by a third of had party. This

00:12:19,420 --> 00:12:25,992
is the main of serverless, that someone else is taking care of the servers somewhere. So,

00:12:25,992 --> 00:12:32,319
some of the advantages of this, cost savings. So, the idea that the pay for what you use

00:12:32,319 --> 00:12:37,290
model. And this could be in your monthly cloud bill. But it could be in terms of computing

00:12:37,290 --> 00:12:44,100
resources if you have an internal platform. This idea of invisible infrastructure. So,

00:12:44,100 --> 00:12:48,649
yes, of course, there are servers somewhere. But the idea is that we really don't care.

00:12:48,649 --> 00:12:54,630
There's a fully managed platform, be it the cloud provider or your team. They take care

00:12:54,630 --> 00:13:01,370
of the infrastructure. I need to just worry about running my application. Or writing my

00:13:01,370 --> 00:13:06,579
application. And security. Again, with the little asterisk here. Basically the security

00:13:06,579 --> 00:13:12,619
is now the responsibility of this third party. And as a developer, there's less things that

00:13:12,619 --> 00:13:20,339
I can do wrong. There's less risk involved in the serverless application. So, some drawbacks,

00:13:20,339 --> 00:13:26,269
of course. Vendor lock in. Especially in the early days where Lambda was the only game

00:13:26,269 --> 00:13:31,550
in town. If you really want to take advantage of this, you're going all in. And vendor lock

00:13:31,550 --> 00:13:38,269
in isn't necessarily a bad thing, but it is a decision that should be made consciously.

00:13:38,269 --> 00:13:45,759
Debugging serverless applications, still difficult, complicated. Can it's still, even though we

00:13:45,759 --> 00:13:50,189
have been talking about serverless for a long time, I feel like it's fairly immature with

00:13:50,189 --> 00:13:55,730
the tools out there. And only recently are there more production ready platforms that

00:13:55,730 --> 00:14:04,449
are available. Talk about use cases. We talk about event driven architectures. This is

00:14:04,449 --> 00:14:08,649
probably a good fit. These functions that we're building are going to be triggered by

00:14:08,649 --> 00:14:14,740
events. So, this might be a nice fit. Any type of asynchronous tasks. Maybe running

00:14:14,740 --> 00:14:21,089
machine learning jobs or things that just have to run for a certain amount of time,

00:14:21,089 --> 00:14:26,019
but it's less predictable. That might be good for a serverless pattern. Most importantly

00:14:26,019 --> 00:14:30,310
is you need to have this platform already available. Maybe you're already on a cloud

00:14:30,310 --> 00:14:35,470
provider that has a serverless platform or you have some internal team. But I wouldn't

00:14:35,470 --> 00:14:39,829
go out and build a serverless platform just to take advantage of a serverless architecture.

00:14:39,829 --> 00:14:47,579
I think the cost doesn't really outweigh the benefits. So, if we have a statement that,

00:14:47,579 --> 00:14:53,020
you know, none of these are the ideal architecture, and it kind of depends on your use case, then

00:14:53,020 --> 00:14:57,749
how do we choose? How do we choose which one to go with? Say we're starting from scratch.

00:14:57,749 --> 00:15:03,700
Well, you know, we look at our specific use case, our specific context. Look at the pros

00:15:03,700 --> 00:15:08,580
and cons of each of these and try to see which one is the right fit. But the thing is, it's

00:15:08,580 --> 00:15:13,830
not either/or. For any medium system, you're going to have at least two of the styles of

00:15:13,830 --> 00:15:21,639
architecture in there. There's also good news and bad news when designing an initial architecture.

00:15:21,639 --> 00:15:25,670
The good news is you're not designing this architecture which is going to live forever.

00:15:25,670 --> 00:15:30,610
You know, this is not way back where a bunch of architects sit in a room and design this

00:15:30,610 --> 00:15:35,680
for five years and see you in five years to do the next one. Our architectures are gonna

00:15:35,680 --> 00:15:41,739
change. So, this puts a little bit of the pressure off when designing it. The bad news,

00:15:41,739 --> 00:15:46,809
well, your architecture's actually gonna change. So, you can't just, you know, design this

00:15:46,809 --> 00:15:51,850
and hand it off and you're done. You know, architecture needs to be done continuously.

00:15:51,850 --> 00:15:56,819
You also need to think about how change is gonna affect the architecture that you design.

00:15:56,819 --> 00:16:03,129
Now, I'm not spouting some new idea here. There's several different ideas and concepts

00:16:03,129 --> 00:16:08,579
which are kind of around this same theory and I want to just highlight a couple of them.

00:16:08,579 --> 00:16:15,489
Michael Nygard who wrote the great book releasing, he has great talks and has workshops called

00:16:15,489 --> 00:16:20,110
architecture without an end state, those are his talks. I encourage you to find one online.

00:16:20,110 --> 00:16:29,949
He talks about in enterprises the fallacy of the three year plan. We design our architecture

00:16:29,949 --> 00:16:35,810
and this is set for the next three years. He says we never reach the three years because

00:16:35,810 --> 00:16:42,041
change is inevitable. Whether it's the technology, whether it's the business direction, whether

00:16:42,041 --> 00:16:47,689
it's the people. So, we need to stop thinking in these kind of ways and again, bring architecture

00:16:47,689 --> 00:16:55,019
into a more continuous process. A similar kind of idea is this idea of evolutionary

00:16:55,019 --> 00:17:00,920
architecture. You can read about this, really good book, building evolutionary architectures

00:17:00,920 --> 00:17:07,529
by Neal Ford, Rebecca Parsons and Patrick Kua. They're talking about this architecture

00:17:07,529 --> 00:17:15,539
that that needs to evolve. They're talking about measuring the evolvability of your system.

00:17:15,539 --> 00:17:21,649
They have this concept of fitness functions which essentially is a way to, you know, measure

00:17:21,649 --> 00:17:25,829
your architecture for different things so that we have a guided evolution. It's not

00:17:25,829 --> 00:17:30,070
just random how our architecture evolves. But we make sure it evolves in the way that

00:17:30,070 --> 00:17:36,830
we want. And I think this also all kind of fits into the idea of cloud native. If you

00:17:36,830 --> 00:17:42,330
kind of get the buzzwords out of the way and all the technology. It's about building systems,

00:17:42,330 --> 00:17:47,271
you know, meant for the cloud. So, this means taking advantage of infinite compute. But

00:17:47,271 --> 00:17:51,679
also being able to handle, you know, failures. There's less and less control that we have.

00:17:51,679 --> 00:17:55,559
So, now we want to build resilient systems. We want to build systems that can respond

00:17:55,559 --> 00:18:01,350
to change. So, of course, the common thread that we're going through here is that, you

00:18:01,350 --> 00:18:06,140
know, change is something which is inevitable. Even in our architecture. So, we need to start

00:18:06,140 --> 00:18:11,870
thinking about this as we're designing and as we're continuously changing our systems.

00:18:11,870 --> 00:18:20,501
The question is how do we build our systems for change? How do we make this easier? There's

00:18:20,501 --> 00:18:26,980
a couple ways. One way is kind of the big rewrite, right? We have this system. And,

00:18:26,980 --> 00:18:30,890
you know, it's not really working anymore. So, we're just gone no throw it out and build

00:18:30,890 --> 00:18:37,520
a new system. We're going to replace our monolith with serverless. And, you know, I kind of

00:18:37,520 --> 00:18:41,400
heard some talks around these license. But I don't know how many organizations who have

00:18:41,400 --> 00:18:46,150
like six months to just put everything on hold and rewrite the entire system. And personally,

00:18:46,150 --> 00:18:53,630
I've never seen this actually pan out. So, how do we do this more continually? And this

00:18:53,630 --> 00:18:57,350
is something that we've, you know, we've already learned in the software world, right? This

00:18:57,350 --> 00:19:03,340
idea of small, quick iterations. Bringing it down early, delivering value quickly and

00:19:03,340 --> 00:19:08,620
constantly. It's the same kind of idea on the architecture level. We want to be doing

00:19:08,620 --> 00:19:14,480
quick iterations. Running experiments and letting our architecture evolve over time.

00:19:14,480 --> 00:19:20,240
So, we want to move more to like kind of a constant migration. And to try to bring this

00:19:20,240 --> 00:19:25,290
back into maybe a little bit more concrete. Look at ways that we can actually do this.

00:19:25,290 --> 00:19:29,380
So, we have our architecture, we have maybe a monolith. And we want to start migrating

00:19:29,380 --> 00:19:35,179
this to microservices or serverless or starting to introduce some new pattern. You know, there's

00:19:35,179 --> 00:19:40,309
kind of some common steps that we want to go through. So, we want to identify the piece

00:19:40,309 --> 00:19:46,230
that we're gonna start with. So, find this seam, right? In our system. And this is the

00:19:46,230 --> 00:19:51,890
new piece which we're going to eventually replace with a function or a microservice.

00:19:51,890 --> 00:19:57,630
So, then, you know, we pull it out. And this could just be, you know, rewriting it or pulling

00:19:57,630 --> 00:20:02,340
the existing logic into a microservice, for example. And we might leave the existing piece

00:20:02,340 --> 00:20:08,870
in there. We either redirect traffic, usually kind of slowly. So, slowly start feeding the

00:20:08,870 --> 00:20:14,070
traffic to the new system, the new service. And there are good tools that can help you

00:20:14,070 --> 00:20:19,380
do this. And we need to have proper monitoring in place, of course, so that we know what's

00:20:19,380 --> 00:20:24,519
happening. Are we getting the same results? Are error rates going up? And once we're finally

00:20:24,519 --> 00:20:29,430
happy that, hey, this new service performs at least as good as the old one, then we can

00:20:29,430 --> 00:20:35,020
retire and throw out the old piece and just repeat. We go through this constant iterative

00:20:35,020 --> 00:20:44,000
process. So, again, just to make this a little bit more concrete. Got to go into a a live

00:20:44,000 --> 00:20:48,280
demo here because those always go very well. [ Laughter ]

00:20:48,280 --> 00:20:55,320
So, I've got this application. It's a little bit more than a hello world. What it's trying

00:20:55,320 --> 00:21:01,380
to do is to find missing people. This is kind of the logical flow. It takes in images from

00:21:01,380 --> 00:21:06,289
a variety of cameras in theory. It's going to process and ingest those. It's going to

00:21:06,289 --> 00:21:10,640
try to detect faces if it can define those in the images. We're going to detect the face,

00:21:10,640 --> 00:21:16,309
do some coding and search in our database to see if these match any of the people we

00:21:16,309 --> 00:21:25,270
happen to be looking for. If so, there's a notification. And update the data and eventually

00:21:25,270 --> 00:21:33,130
send this to some UI. So, the first architecture. We're building this thing from scratch. Again,

00:21:33,130 --> 00:21:39,039
a monolith is probably the right way to go. We just want to build something quickly. So,

00:21:39,039 --> 00:21:46,169
the architecture is fairly simple, the monolith, connect to the database and there's a small

00:21:46,169 --> 00:21:58,650
frontend on the front. So, let's quickly show this initial version. Hopefully that is big

00:21:58,650 --> 00:22:02,160
enough. So, even though it's a monolith, of course, I'm going to run this on Kubernetes

00:22:02,160 --> 00:22:06,240
because, hey, that's what we do. [ Laughter ]

00:22:06,240 --> 00:22:11,690
So, I've got three pods running, three applications running on my Kubernetes cluster. Got the

00:22:11,690 --> 00:22:22,260
database, this frontend and this monolith. So, now if I go to the UI. As you can see,

00:22:22,260 --> 00:22:30,220
I'm not a UI or UX designer by any stretch. Terrible skills. And we do have a small loadTest

00:22:30,220 --> 00:22:38,430
which is essentially going to simulate images come in from cameras. We start running this.

00:22:38,430 --> 00:22:43,260
And hopefully things happen. There we go. We're getting these events coming up hey.

00:22:43,260 --> 00:22:47,720
We've detected this person in this location and we have this cool globe showing where

00:22:47,720 --> 00:22:56,250
they are. Cool. So that kind of works. Then we get to you know, we put these things into

00:22:56,250 --> 00:23:04,169
production and start increasing traffic in. We start to hit some bottlenecks. And then

00:23:04,169 --> 00:23:09,160
things start to go slow. Trust me on this. Because I've knocked over the cluster a few

00:23:09,160 --> 00:23:17,380
times by putting the traffic up too high. It will definitely break. And so, there's

00:23:17,380 --> 00:23:20,780
a couple options we can do here, right? We want to scale our application. Maybe we can

00:23:20,780 --> 00:23:26,370
just run another instance of the monolith. But if we're doing the applications, maybe

00:23:26,370 --> 00:23:32,580
look at where the bottleneck is. And we find out that the limits it's hitting is around

00:23:32,580 --> 00:23:39,311
this. It's an intensive process. It's taking a lot of time, a lot of CPU. So, another option

00:23:39,311 --> 00:23:43,191
is take this logic and we're going to pull this out as a microservice and implement this

00:23:43,191 --> 00:23:51,080
together. We're going through the same steps. This is around you are specific encoding piece

00:23:51,080 --> 00:23:55,630
of functionality. We're going to pull it out and then redirect our traffic so that our

00:23:55,630 --> 00:23:59,760
old backend just calls the new piece. We can even leave the existing logic in there for

00:23:59,760 --> 00:24:06,380
now until we're confident. The version 2 of our architecture. Very similar. We have this

00:24:06,380 --> 00:24:12,809
other service. We have ripped the exact same logic out and put it in its own piece. So,

00:24:12,809 --> 00:24:31,279
if we go and deploy this. This one. Yes. So, what this is doing, this is just updating

00:24:31,279 --> 00:24:37,220
the monolith backend to now call the new service and it deploys the new service. So, if I see

00:24:37,220 --> 00:24:44,030
what I have running now. This is the old version going away. This is the new version. And this

00:24:44,030 --> 00:24:51,649
is our new service which we've created. Pretty straightforward. So, then if I go back and

00:24:51,649 --> 00:24:58,750
run my load test again and see what happens. You know, essentially functionality wise,

00:24:58,750 --> 00:25:02,759
we didn't change anything. So, as you can see, everything still seems to be the same

00:25:02,759 --> 00:25:08,390
from the user perspective. But what we campaign is a much easier ability to actually scale

00:25:08,390 --> 00:25:19,850
things. So, now what I can do if I you know, once I'm hitting these limits... 

00:25:19,850 --> 00:25:28,159
I can say, Kubectl scale. And I only have to scale this one piece. The actual encoding.

00:25:28,159 --> 00:25:36,570
If I can remember the syntax. And say we want to run four instances. Then if I see what's

00:25:36,570 --> 00:25:42,149
running, you know, now I have four versions of this small encoding service instead of

00:25:42,149 --> 00:25:46,659
multiple versions of my big monolith. This is kind benefit that we get. Now we are able

00:25:46,659 --> 00:25:56,790
to handle a whole lot more traffic. So, you know, we've kind of improved things. We're

00:25:56,790 --> 00:26:00,710
getting a little bit better. And, again, this is a small kind of iterative approaches to

00:26:00,710 --> 00:26:06,630
slowly change our architecture. Now imagine another similar use case or a different use

00:26:06,630 --> 00:26:11,809
case where we actually want to add functionality. And I want to be able to, for example, add

00:26:11,809 --> 00:26:17,880
alerts. Add notifications if we actually find a match between some people. And so, of course,

00:26:17,880 --> 00:26:20,840
for alerts we're gonna put these in Slack because that's where all important information

00:26:20,840 --> 00:26:26,600
goes. But we think, you know, this is actually kind of an asynchronous task. Maybe this fits

00:26:26,600 --> 00:26:33,049
in well with kind of a serverless. One of the stipulations I put this, if you don't

00:26:33,049 --> 00:26:38,440
have a platform actually available and it doesn't make sense, luckily, so, I'm running

00:26:38,440 --> 00:26:44,820
this on Google Cloud, so, they have something called Google Cloud Run, which is essentially

00:26:44,820 --> 00:26:51,690
just a managed version of K native. K native is the serverless platform on Kubernetes.

00:26:51,690 --> 00:26:57,919
It's one of the more mature serverless platforms available. Because I have this available and

00:26:57,919 --> 00:27:03,660
I want to build their new logic, then it's quite easy for me to integrate these things.

00:27:03,660 --> 00:27:10,440
I just need to build the logic for my new service. I don't need to care about setting

00:27:10,440 --> 00:27:15,830
my Kubernetes configurations anymore or think about the infrastructure or think about scaling.

00:27:15,830 --> 00:27:21,919
So, this is when the next version looks like. Again, we've just added this one piece which

00:27:21,919 --> 00:27:35,990
is for alerting. And we're gonna add this as a function. So, to do this... I send so,

00:27:35,990 --> 00:27:43,460
what I'm actually going to do is just so, this is a set image command. So, all I'm doing

00:27:43,460 --> 00:27:47,690
is showing you the only thing that changes is the version of the monolith backend. Instead

00:27:47,690 --> 00:27:55,179
of going to version 3, when it finds version 3, we're going to trigger this function which

00:27:55,179 --> 00:28:05,059
is up there. And then in order to actually deploy my function, so, again, I say I'm using

00:28:05,059 --> 00:28:11,620
Google Cloud Run. I'll use their CLI, which is pretty straightforward. All I'm specifying

00:28:11,620 --> 00:28:17,790
here is the image. So, this is the Docker image of my new service. And then I'm coding

00:28:17,790 --> 00:28:23,460
it to my existing Kubernetes cluster to say, hey, go run this on your serverless platform

00:28:23,460 --> 00:28:29,460
and make sure it's available. And then it takes care of showing this is available for

00:28:29,460 --> 00:28:41,950
all of my existing applications. So, sending this should be now up and running. So, now

00:28:41,950 --> 00:28:51,490
if we go and run our load test. We should see new things happening. You see that the

00:28:51,490 --> 00:28:57,629
load is coming up. And then in theory, if we see a match now, we should get some kind

00:28:57,629 --> 00:29:02,809
of a notification. I think there's only like 20 or so people in my load test. So, again,

00:29:02,809 --> 00:29:10,690
hopefully we should get a match. And then what happens is the backend will just trigger

00:29:10,690 --> 00:29:30,310
trigger this new service which is running on Cloud Run. The suspense. I just

00:29:30,310 --> 00:29:36,280
>> Just a quick time check. Less than 10 minutes to the next session. So

00:29:36,280 --> 00:29:44,610
>> Good thing my demo just worked, then. [ Laughter ]

00:29:44,610 --> 00:29:51,820
[ Applause ] So, you can see now this new serverless function

00:29:51,820 --> 00:30:00,280
just sends a message to Slack whenever we find it. I can kill that. And cool. So, we've

00:30:00,280 --> 00:30:07,419
kind of, you know, we see this slow evolution of our architecture, right? And our, you know,

00:30:07,419 --> 00:30:11,710
so we're not done here. The idea is, again, that this is something which continuously

00:30:11,710 --> 00:30:18,220
happens. We can slowly migrate our system to serverless as it makes sense. And while

00:30:18,220 --> 00:30:23,261
these are a little bit trivial examples, I think the process is the same. You know, we

00:30:23,261 --> 00:30:27,509
want to follow this plan of identifying the piece that we want to replace. You know, finding

00:30:27,509 --> 00:30:32,820
a good reason. You know, building the new piece, routing your traffic. And there's tools

00:30:32,820 --> 00:30:38,860
that you can, you know, tells you traffic switching. And then monitor to see that things

00:30:38,860 --> 00:30:44,790
have actually improved. We should be running things as experiments. I say that I have a

00:30:44,790 --> 00:30:49,090
hypothesis that if I pull this piece of logic out and run it as a service, I'm going to

00:30:49,090 --> 00:30:56,220
reduce my costs by X. You can run this experiment, gather the data and do the succeed or pass.

00:30:56,220 --> 00:31:02,120
And you've got that data available. If it didn't, that's fine. Roll back and continue.

00:31:02,120 --> 00:31:07,110
The idea is this is something we should be doing continuously. So, kind of to summarize

00:31:07,110 --> 00:31:13,769
we are, this idea of an ideal architecture, it doesn't exist. It depends on your context,

00:31:13,769 --> 00:31:18,990
the specific use case, on the business you're in. And these things needs to be taken into

00:31:18,990 --> 00:31:26,350
consideration. And even when you have a design, the change is going to be inevitable. Technologies

00:31:26,350 --> 00:31:31,090
changing from business directions to everything. So, you need to take this into account when

00:31:31,090 --> 00:31:36,850
you're initially designing and as well throughout the whole process. So, in order to be constantly

00:31:36,850 --> 00:31:41,710
changing our architectures, you know with we want to be running this as experiments.

00:31:41,710 --> 00:31:46,820
Constantly iterating. Making changes. Seeing if they're valid or not. Moving back when

00:31:46,820 --> 00:31:58,029
we can. That's all I have. Thank you. [ Applause ]

00:31:58,029 --> 00:32:03,140
I did owe you one lame joke. I promised, a monolith, a microservice and a function walk

00:32:03,140 --> 00:32:10,919
into a bar and grab a table in the corner. And the function says, hey, friends, I just

00:32:10,919 --> 00:32:17,320
got paged, so, drinks are on me bot paid. She goes off to get drinks. Done for a long

00:32:17,320 --> 00:32:24,860
time. The monolith says, hey, you were gone and you still don't have any drinks. And the

00:32:24,860 --> 00:32:28,750
function says, well, I looked everywhere, but there was no server.

00:32:28,750 --> 00:32:31,330

YouTube URL: https://www.youtube.com/watch?v=ufeZfCFVCuM


