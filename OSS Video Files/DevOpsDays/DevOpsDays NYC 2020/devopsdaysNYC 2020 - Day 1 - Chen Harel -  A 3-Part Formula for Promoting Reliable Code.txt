Title: devopsdaysNYC 2020 - Day 1 - Chen Harel -  A 3-Part Formula for Promoting Reliable Code
Publication date: 2020-03-30
Playlist: DevOpsDays NYC 2020
Description: 
	Reliability Scoring: A 3-Part Formula for Promoting Reliable Code

The expression “separate the signal from the noise” comes up early and often in monitoring, but when our systems continue to get louder and louder – more errors, more alerts, more logs to sift through – finding the one anomaly that actually matters to the reliability of your application can be like finding a needle in a stack of needles.

This was a problem my team encountered when monitoring our own systems. We were capturing tons of data about billions of events happening every day, without a quantifiable way of knowing what to fix first and how reliable our releases and applications actually were. So our R&D team set out to devise a formula for not only clearly defining what constitutes an anomaly in our code, but also for helping to prioritize the issues that actually matter and actually blocking them from making it to production in the first place.

This session will walk attendees through our open source reliability scoring system in Grafana and a variety of CI/CD tools that provides DevOps teams with a formulaic approach to prioritizing anomalies and understanding the stability of their releases – before they go to production.

The formula scores releases for stability and safety based on if it: – Introduces new errors – Makes existing errors happen at a higher rate (i.e. rate increase) – Introduces slowdowns into the environment

The talk will walk through how to follow the below process and will include an example of the process being applied in practice: – Detect all errors and slowdowns – Classify each event – Prioritize by severity – Score the release – Block release – Visualize the data
Captions: 
	00:00:14,750 --> 00:00:17,470
so

00:00:18,000 --> 00:00:25,019
thank you for sticking with me or with

00:00:20,340 --> 00:00:28,800
us last talk of the day so it's always

00:00:25,019 --> 00:00:33,930
it's always great to cut to go last not

00:00:28,800 --> 00:00:36,780
really but I understand that we have an

00:00:33,930 --> 00:00:39,900
awesome after party app and open the

00:00:36,780 --> 00:00:43,409
third floor so it should be interesting

00:00:39,900 --> 00:00:46,649
to stay and stick around I'm here to

00:00:43,409 --> 00:00:50,239
talk to you about what our engineering

00:00:46,649 --> 00:00:52,829
team did in order to improve our

00:00:50,239 --> 00:00:56,179
software reliability again this is a

00:00:52,829 --> 00:00:59,070
devops days conference but I know from

00:00:56,179 --> 00:01:01,370
I've went to a couple I want to start

00:00:59,070 --> 00:01:06,210
with the some of the some hand raises

00:01:01,370 --> 00:01:10,220
who here actually codes in an

00:01:06,210 --> 00:01:10,220
application that then runs in production

00:01:10,310 --> 00:01:19,560
that's awesome who doesn't code okay ok

00:01:17,759 --> 00:01:21,690
so we have we have a few that maybe we

00:01:19,560 --> 00:01:24,770
can convert now killing that's not

00:01:21,690 --> 00:01:27,599
that's not the purpose of this code talk

00:01:24,770 --> 00:01:29,220
all right that that slide is not really

00:01:27,599 --> 00:01:30,929
interesting but if you want my Twitter

00:01:29,220 --> 00:01:33,420
handle because I understand it's

00:01:30,929 --> 00:01:36,270
important then it's on the on the screen

00:01:33,420 --> 00:01:44,190
I work for a company called over ops

00:01:36,270 --> 00:01:51,690
were helping developers you know who

00:01:44,190 --> 00:01:55,860
builds software fast sorry I'm I let's

00:01:51,690 --> 00:01:57,509
let's let's let's rewind this we're

00:01:55,860 --> 00:01:59,849
helping people who write software

00:01:57,509 --> 00:02:01,890
deliver code faster and raise the

00:01:59,849 --> 00:02:07,920
quality and again that's kind of helping

00:02:01,890 --> 00:02:09,899
me frame the conversation now what we

00:02:07,920 --> 00:02:12,060
and as I said our engineering team in

00:02:09,899 --> 00:02:15,000
Tel Aviv were facing with a lot of

00:02:12,060 --> 00:02:18,440
production outages we had a lot of what

00:02:15,000 --> 00:02:21,180
we call save one where customers are

00:02:18,440 --> 00:02:24,019
jumping on the support portal and are

00:02:21,180 --> 00:02:27,990
actually not very happy with our

00:02:24,019 --> 00:02:30,580
application and we saw that you know

00:02:27,990 --> 00:02:33,070
while we are hands on and working

00:02:30,580 --> 00:02:37,990
when the code actually ships we could

00:02:33,070 --> 00:02:39,940
have done a lot more to find and fix

00:02:37,990 --> 00:02:45,280
issues even before they reach production

00:02:39,940 --> 00:02:48,910
and by embracing what we call code

00:02:45,280 --> 00:02:52,210
quality gates throughout the CI CD

00:02:48,910 --> 00:02:54,790
pipeline we were able to eventually

00:02:52,210 --> 00:02:58,600
reduce those save ones and again as we

00:02:54,790 --> 00:03:02,020
talk through this 20 minutes you I hope

00:02:58,600 --> 00:03:06,060
I can convince you that this is really

00:03:02,020 --> 00:03:10,570
helpful for your organization as well

00:03:06,060 --> 00:03:13,120
now kind of building one on on what I've

00:03:10,570 --> 00:03:15,520
said already we've we've seen and by

00:03:13,120 --> 00:03:18,280
speaking with other companies that speed

00:03:15,520 --> 00:03:23,610
and stability aren't really working

00:03:18,280 --> 00:03:28,900
together and the cost of poor quality

00:03:23,610 --> 00:03:31,510
there is a citizen on nonprofit

00:03:28,900 --> 00:03:34,270
organization the link is down below for

00:03:31,510 --> 00:03:38,320
their 2018 report has estimated that

00:03:34,270 --> 00:03:43,030
this dispute sorry the poor quality of

00:03:38,320 --> 00:03:45,280
software cost our industry 3 trillion in

00:03:43,030 --> 00:03:47,830
2018 that's a trillion with the T not a

00:03:45,280 --> 00:03:50,050
billion so it's a huge number again you

00:03:47,830 --> 00:03:52,060
can argue about their methods but

00:03:50,050 --> 00:03:53,620
essentially it's a huge number we all

00:03:52,060 --> 00:03:56,020
know that we introduce bugs into the

00:03:53,620 --> 00:03:58,870
code that sometimes we break application

00:03:56,020 --> 00:04:03,640
as we as we impact the revenue stream of

00:03:58,870 --> 00:04:05,470
our companies and it's bad and I hope

00:04:03,640 --> 00:04:10,120
that again part of the reason we're all

00:04:05,470 --> 00:04:14,680
here today is in order to fix that or at

00:04:10,120 --> 00:04:16,419
least reduce the problem and it may be

00:04:14,680 --> 00:04:20,320
cheesy but I think again this is one of

00:04:16,419 --> 00:04:23,320
those lines that really resonates with

00:04:20,320 --> 00:04:24,580
with my team when we talk about you know

00:04:23,320 --> 00:04:28,570
the engineering managers are talking

00:04:24,580 --> 00:04:31,030
about velocity and burn charts I'm all

00:04:28,570 --> 00:04:33,430
about the quality again kind of bridging

00:04:31,030 --> 00:04:38,630
that gap between engineering and the

00:04:33,430 --> 00:04:43,010
business we have to remember the quality

00:04:38,630 --> 00:04:45,620
now as I said in my role I speak with a

00:04:43,010 --> 00:04:49,460
lot of engineering managers directors VP

00:04:45,620 --> 00:04:51,920
CEOs whatever and there are some best

00:04:49,460 --> 00:04:55,430
practices in the industry in order to

00:04:51,920 --> 00:04:59,030
improve that quality or at least that

00:04:55,430 --> 00:05:02,810
transition between velocity speed and

00:04:59,030 --> 00:05:06,080
the quality of your applications I think

00:05:02,810 --> 00:05:10,070
the most famous one is the whole you

00:05:06,080 --> 00:05:13,190
build it you run it phrase from from

00:05:10,070 --> 00:05:16,940
amazon's CTO back in oh six if i recall

00:05:13,190 --> 00:05:22,550
and what we've what we're hearing is

00:05:16,940 --> 00:05:24,860
that you know engineers need to own the

00:05:22,550 --> 00:05:27,050
code that runs in production otherwise

00:05:24,860 --> 00:05:29,690
they don't care they move on to their

00:05:27,050 --> 00:05:32,000
next sprints or the next PRDS or

00:05:29,690 --> 00:05:36,010
whatever you guys call it and stop

00:05:32,000 --> 00:05:38,900
caring or you know they gets

00:05:36,010 --> 00:05:42,860
reintroduced or acquainted with their

00:05:38,900 --> 00:05:45,170
code in a later phase and they kind of

00:05:42,860 --> 00:05:48,730
context switch and forget about it so

00:05:45,170 --> 00:05:51,850
this whole notion of being accountable

00:05:48,730 --> 00:05:58,250
to your application to the codebase is

00:05:51,850 --> 00:06:02,000
crucial second is the whole notion of

00:05:58,250 --> 00:06:05,870
shift left testing again if you can

00:06:02,000 --> 00:06:08,420
invest more in your CI pipeline in your

00:06:05,870 --> 00:06:11,660
automated tests god forbid in your

00:06:08,420 --> 00:06:15,220
manual tests you should do it any dollar

00:06:11,660 --> 00:06:18,740
spent before stuff reaches production is

00:06:15,220 --> 00:06:22,100
going to be multiplied by a ton if you

00:06:18,740 --> 00:06:24,440
can spot that next bug or next code

00:06:22,100 --> 00:06:29,300
change at unity that broke the entire

00:06:24,440 --> 00:06:33,020
application and some kind of again

00:06:29,300 --> 00:06:35,530
thought leadership approaches we've also

00:06:33,020 --> 00:06:40,960
seen people talk about shift right

00:06:35,530 --> 00:06:43,700
testing in production how am I going to

00:06:40,960 --> 00:06:47,479
put a lot of resources whether it's

00:06:43,700 --> 00:06:50,060
developers or you name them test folks

00:06:47,479 --> 00:06:51,730
on the app itself while it's running in

00:06:50,060 --> 00:06:56,500
production with a you know

00:06:51,730 --> 00:07:03,940
where all the greasy stuff is and and

00:06:56,500 --> 00:07:05,830
catch errors there as actual users and

00:07:03,940 --> 00:07:09,160
but if you kind of go back to what I'm

00:07:05,830 --> 00:07:13,030
trying to do to preach here we wanted to

00:07:09,160 --> 00:07:18,490
have a mess total myth and method that

00:07:13,030 --> 00:07:21,310
we can actually quantify our quality we

00:07:18,490 --> 00:07:24,520
wanted to grade our builds grade our

00:07:21,310 --> 00:07:27,930
code and know before we promote code

00:07:24,520 --> 00:07:31,900
whether we're actually going to you know

00:07:27,930 --> 00:07:35,380
to some degree of certainty be more safe

00:07:31,900 --> 00:07:38,410
and and in order to do that we had to go

00:07:35,380 --> 00:07:44,350
back to our data points and make sure we

00:07:38,410 --> 00:07:46,600
have good data at our disposal and and

00:07:44,350 --> 00:07:48,760
those data points that I'm talking about

00:07:46,600 --> 00:07:55,350
you have kind of two ways of looking at

00:07:48,760 --> 00:07:58,150
it if you are using any CI CD pipeline

00:07:55,350 --> 00:08:03,010
let's talk about CIA even for a second

00:07:58,150 --> 00:08:05,920
I'm I hope that you can use a static

00:08:03,010 --> 00:08:10,360
analysis tool as part of your build

00:08:05,920 --> 00:08:12,280
whether it's you know we are a Java shop

00:08:10,360 --> 00:08:14,860
so let's even take the java compiler

00:08:12,280 --> 00:08:16,840
right you have to first look at all the

00:08:14,860 --> 00:08:19,540
warnings and then you look at stuff like

00:08:16,840 --> 00:08:22,210
with sonar cube on the code snows and

00:08:19,540 --> 00:08:24,820
best practices and patterns static

00:08:22,210 --> 00:08:28,420
analysis tools are I would say your

00:08:24,820 --> 00:08:31,979
first quality gate to even start to

00:08:28,420 --> 00:08:35,080
think about you know quality in software

00:08:31,979 --> 00:08:39,040
then there's code coverage I think again

00:08:35,080 --> 00:08:45,010
in 2020 testing has one every one should

00:08:39,040 --> 00:08:47,590
be adding some coverage of tests in

00:08:45,010 --> 00:08:50,920
multiple fronts multiple angles I don't

00:08:47,590 --> 00:08:53,530
want to go into in there but you know we

00:08:50,920 --> 00:08:56,830
have tools today that measure your code

00:08:53,530 --> 00:08:58,900
coverage and again not saying that you

00:08:56,830 --> 00:09:01,480
need a hundred percent I think other

00:08:58,900 --> 00:09:05,209
talks or other people have smarter than

00:09:01,480 --> 00:09:08,420
me has expressed why that is not a goal

00:09:05,209 --> 00:09:10,880
but having a certain amount a decent

00:09:08,420 --> 00:09:15,470
amount of code coverage or testing is

00:09:10,880 --> 00:09:17,690
crucial to your developers belief for

00:09:15,470 --> 00:09:19,579
yourself you know when you believe that

00:09:17,690 --> 00:09:25,220
you've shipped something that is correct

00:09:19,579 --> 00:09:26,329
and of high quality and the last kind of

00:09:25,220 --> 00:09:28,790
data point that I want to mention

00:09:26,329 --> 00:09:34,000
because we're all looking at it even if

00:09:28,790 --> 00:09:37,870
we're not acknowledging it is the output

00:09:34,000 --> 00:09:42,339
from our applications and that output

00:09:37,870 --> 00:09:47,180
usually or at the very bare minimum is

00:09:42,339 --> 00:09:49,790
it with log files now the problem with

00:09:47,180 --> 00:09:51,319
log files is that it's you know when

00:09:49,790 --> 00:09:53,959
again I'm sure you know this by now

00:09:51,319 --> 00:09:57,259
they're unstructured and sometimes

00:09:53,959 --> 00:09:59,600
they're missing crucial data or the

00:09:57,259 --> 00:10:02,089
verbosity is not what you wished or the

00:09:59,600 --> 00:10:06,440
severity is not turned on where you

00:10:02,089 --> 00:10:09,350
wanted it to be or again if you kind of

00:10:06,440 --> 00:10:12,529
open your mind why do I even care about

00:10:09,350 --> 00:10:15,560
log files in my build that's like a

00:10:12,529 --> 00:10:17,480
production thing in Splunk or elastic I

00:10:15,560 --> 00:10:21,949
don't really think about it as part of

00:10:17,480 --> 00:10:25,850
my CI pipeline again part of what I'm

00:10:21,949 --> 00:10:29,740
trying to kind of get you to realize is

00:10:25,850 --> 00:10:32,689
that all of this data points can be used

00:10:29,740 --> 00:10:36,230
to our benefits when we're talking about

00:10:32,689 --> 00:10:38,959
quality in our software just kind of

00:10:36,230 --> 00:10:42,670
thinking about it you know do I have an

00:10:38,959 --> 00:10:46,279
arrow statement in my test

00:10:42,670 --> 00:10:51,680
maybe it's green but if I had an error

00:10:46,279 --> 00:10:54,709
what does it mean and and with that I

00:10:51,680 --> 00:10:58,810
want to kind of take you to the same

00:10:54,709 --> 00:11:01,579
journey that our engineering team had

00:10:58,810 --> 00:11:05,420
which is kind of looking at some more

00:11:01,579 --> 00:11:08,269
data points that our applications spits

00:11:05,420 --> 00:11:11,389
out and we're here to talk about you

00:11:08,269 --> 00:11:13,579
know new errors and we're here to talk

00:11:11,389 --> 00:11:15,110
about increasing errors if you think

00:11:13,579 --> 00:11:18,050
about something that even though it's

00:11:15,110 --> 00:11:21,050
not new the rate has changed

00:11:18,050 --> 00:11:23,360
volume has changed and about slowdowns

00:11:21,050 --> 00:11:27,110
again all of our all of us wants our

00:11:23,360 --> 00:11:32,360
applications to stick within the

00:11:27,110 --> 00:11:34,339
boundaries of our SL O's and we wanted

00:11:32,360 --> 00:11:40,870
to look at that as early as possible

00:11:34,339 --> 00:11:43,690
even if in our pre prod environments and

00:11:40,870 --> 00:11:49,399
when I say we are looking at quality

00:11:43,690 --> 00:11:53,750
this is where we branded the reliability

00:11:49,399 --> 00:11:56,510
score our concept we will say we look at

00:11:53,750 --> 00:11:59,560
in a branch of a release candidate and

00:11:56,510 --> 00:12:03,860
will start to look at it from that data

00:11:59,560 --> 00:12:06,649
types perspective did it introduce new

00:12:03,860 --> 00:12:08,690
errors is does it have existing errors

00:12:06,649 --> 00:12:12,290
that happen at a higher rate or does it

00:12:08,690 --> 00:12:16,700
have slowdowns or it introduced new

00:12:12,290 --> 00:12:21,320
slowdowns in different end points how

00:12:16,700 --> 00:12:25,940
we're actually scoring is is is I guess

00:12:21,320 --> 00:12:28,490
the main point here right first remember

00:12:25,940 --> 00:12:31,490
what I said you need good data so we

00:12:28,490 --> 00:12:34,100
need to detect all the errors all the

00:12:31,490 --> 00:12:39,250
slowdowns that happen in our application

00:12:34,100 --> 00:12:42,829
in order to even begin the process then

00:12:39,250 --> 00:12:45,230
again every person in the room can take

00:12:42,829 --> 00:12:49,130
this to their own world we need to

00:12:45,230 --> 00:12:53,480
classify it our touch on that in a

00:12:49,130 --> 00:12:55,730
second then we prioritize it will show

00:12:53,480 --> 00:12:59,329
in a second how you make this entire

00:12:55,730 --> 00:13:02,149
thing into one reasonable score zero to

00:12:59,329 --> 00:13:05,690
100 and then you can start to discuss

00:13:02,149 --> 00:13:08,540
whether that number can be used to mark

00:13:05,690 --> 00:13:12,529
a build unstable right if I'm if my

00:13:08,540 --> 00:13:17,630
build or my automated test suite or my

00:13:12,529 --> 00:13:21,740
nightly had a 70 is it fine to promote

00:13:17,630 --> 00:13:23,899
probably not and the last bit that we

00:13:21,740 --> 00:13:27,100
like because word that data nerds is how

00:13:23,899 --> 00:13:30,050
we are visualizing it all to kind of

00:13:27,100 --> 00:13:31,520
broadcast to the entire company outside

00:13:30,050 --> 00:13:33,980
of engineering what

00:13:31,520 --> 00:13:39,020
up with our builds and how engineering

00:13:33,980 --> 00:13:40,580
is progressing all right so with

00:13:39,020 --> 00:13:43,910
detection because I think that's really

00:13:40,580 --> 00:13:48,010
where people kind of lose faith in a way

00:13:43,910 --> 00:13:52,340
how do I get this data and they're

00:13:48,010 --> 00:13:55,580
really two kind of approaches you have

00:13:52,340 --> 00:13:57,860
the manual one if you're injecting using

00:13:55,580 --> 00:14:01,370
a matrix library you're gathering a lot

00:13:57,860 --> 00:14:03,800
of data on your application or again

00:14:01,370 --> 00:14:07,360
those in famous log files that you have

00:14:03,800 --> 00:14:10,670
that you can parse and get actionable

00:14:07,360 --> 00:14:14,270
aggregations from again not pretty I've

00:14:10,670 --> 00:14:17,630
seen I've seen Splunk queries it has

00:14:14,270 --> 00:14:23,720
like 10,000 characters in them so it's

00:14:17,630 --> 00:14:25,490
it's really bad but it's possible and if

00:14:23,720 --> 00:14:28,460
you're thinking about the automatic

00:14:25,490 --> 00:14:32,600
approach then you have tools like an APM

00:14:28,460 --> 00:14:34,550
now again part of those what's going on

00:14:32,600 --> 00:14:36,740
in your organization we've seen

00:14:34,550 --> 00:14:39,830
organizations that the APM is only being

00:14:36,740 --> 00:14:43,520
used in production there are no licenses

00:14:39,830 --> 00:14:48,230
for dev the engineering manager says but

00:14:43,520 --> 00:14:49,910
again if you kind of you know stay in my

00:14:48,230 --> 00:14:54,200
in the mindset that I'm trying to share

00:14:49,910 --> 00:14:57,470
here it's actually as important to run

00:14:54,200 --> 00:14:59,570
your tools throughout the stack and

00:14:57,470 --> 00:15:02,720
whether it's on your dev environment

00:14:59,570 --> 00:15:07,630
test load whatever think about what you

00:15:02,720 --> 00:15:12,620
can what you possess in production and

00:15:07,630 --> 00:15:15,740
walk it through backwards so you can use

00:15:12,620 --> 00:15:17,870
the data to think about the quality of

00:15:15,740 --> 00:15:20,900
your application and again there are

00:15:17,870 --> 00:15:23,090
other methods you have a load tracking

00:15:20,900 --> 00:15:27,860
tools which is also a great way of

00:15:23,090 --> 00:15:30,260
understanding what's new so let's say we

00:15:27,860 --> 00:15:32,360
have all of that data now let's talk

00:15:30,260 --> 00:15:36,410
about classification what it means to

00:15:32,360 --> 00:15:37,370
classify that data set now for every

00:15:36,410 --> 00:15:40,430
error

00:15:37,370 --> 00:15:45,530
let's take like an exception I can start

00:15:40,430 --> 00:15:49,790
to gather some extra data on it metadata

00:15:45,530 --> 00:15:53,810
if I know where it happened what service

00:15:49,790 --> 00:15:56,540
or end point was in was impacted even

00:15:53,810 --> 00:16:01,040
you know get blame who actually wrote

00:15:56,540 --> 00:16:04,190
that piece of code where when why as

00:16:01,040 --> 00:16:06,560
well as the amount the sheer amount of

00:16:04,190 --> 00:16:08,410
data that I have meaning for instance

00:16:06,560 --> 00:16:14,110
how many times it happened during that

00:16:08,410 --> 00:16:17,300
nightly build prioritizing is

00:16:14,110 --> 00:16:19,970
essentially saying well if it's new then

00:16:17,300 --> 00:16:23,630
great if it hasn't been observed before

00:16:19,970 --> 00:16:27,740
that's by definition new but what it

00:16:23,630 --> 00:16:29,870
means to be severe again a Java shop has

00:16:27,740 --> 00:16:31,790
has to throw a nullpointerexception on

00:16:29,870 --> 00:16:33,890
the wall because that's like the easiest

00:16:31,790 --> 00:16:35,360
example of them all you know if my

00:16:33,890 --> 00:16:38,000
thread died if I have a

00:16:35,360 --> 00:16:41,060
nullpointerexception I wanna start to

00:16:38,000 --> 00:16:45,290
prioritize between several events and

00:16:41,060 --> 00:16:50,600
and reason about some of them before the

00:16:45,290 --> 00:16:52,160
others increasing errors pretty similar

00:16:50,600 --> 00:16:54,620
thought again not not trying to really

00:16:52,160 --> 00:16:57,380
blow your mind here with these examples

00:16:54,620 --> 00:16:59,900
right if I have a rate meaning that that

00:16:57,380 --> 00:17:02,950
exception happened you know three

00:16:59,900 --> 00:17:06,320
percent of the times now it happens ten

00:17:02,950 --> 00:17:12,830
the math is pretty simple I can call

00:17:06,320 --> 00:17:13,820
that an increasing error we can talk

00:17:12,830 --> 00:17:15,340
about that later

00:17:13,820 --> 00:17:19,400
because I'm running out of time

00:17:15,340 --> 00:17:20,000
especially if you're looking at pre prod

00:17:19,400 --> 00:17:22,130
data

00:17:20,000 --> 00:17:25,160
you always have to kind of remember that

00:17:22,130 --> 00:17:28,390
in order to make the math works you need

00:17:25,160 --> 00:17:32,030
to really think about your data set as

00:17:28,390 --> 00:17:34,370
things that are discrete and some of the

00:17:32,030 --> 00:17:36,470
statistics won't really apply if you're

00:17:34,370 --> 00:17:39,170
kind of wandering around you know an

00:17:36,470 --> 00:17:41,690
hour a day or something like that but

00:17:39,170 --> 00:17:44,800
that's something that we've again that's

00:17:41,690 --> 00:17:48,740
easily solvable with some seasonality

00:17:44,800 --> 00:17:50,540
tricks and we've we've done that

00:17:48,740 --> 00:17:52,280
successfully so I'm throwing it out

00:17:50,540 --> 00:17:54,590
there because it's it was one of those

00:17:52,280 --> 00:17:57,080
first things that that pop to mind how

00:17:54,590 --> 00:17:58,970
we're gonna work with data that is you

00:17:57,080 --> 00:17:59,360
know runs an hour a day or something

00:17:58,970 --> 00:18:03,080
like

00:17:59,360 --> 00:18:05,299
that slowdowns pretty similar to what I

00:18:03,080 --> 00:18:08,570
mentioned with increasing errors if you

00:18:05,299 --> 00:18:12,890
have an endpoint that now slowing down

00:18:08,570 --> 00:18:15,080
if you have a servlet is a very

00:18:12,890 --> 00:18:17,030
horrifying name but that's that's how my

00:18:15,080 --> 00:18:18,920
mind works you know you have an average

00:18:17,030 --> 00:18:21,110
and you have standard deviations again

00:18:18,920 --> 00:18:23,809
the math is pretty simple if you have

00:18:21,110 --> 00:18:32,870
the data and you want to produce some

00:18:23,809 --> 00:18:39,580
nice statistics out of it and behold the

00:18:32,870 --> 00:18:42,830
formula that we're taking all of the

00:18:39,580 --> 00:18:46,220
events we've gathered right the new the

00:18:42,830 --> 00:18:50,900
increasing the slowdowns and it may

00:18:46,220 --> 00:18:53,390
sound naive but we just started to score

00:18:50,900 --> 00:18:56,929
them and aggregate them into what we

00:18:53,390 --> 00:18:58,880
call a penalty so if you have like a

00:18:56,929 --> 00:19:01,220
hundred you know everyone starts with a

00:18:58,880 --> 00:19:02,540
hundred and then you start to penalize

00:19:01,220 --> 00:19:05,150
you're built for every new

00:19:02,540 --> 00:19:09,040
nullpointerexception and you had three

00:19:05,150 --> 00:19:12,080
and that nullpointerexception got

00:19:09,040 --> 00:19:15,559
deducted by two points you see where I'm

00:19:12,080 --> 00:19:22,160
going with it it's it's again it's naive

00:19:15,559 --> 00:19:25,190
and our our approach here was playing

00:19:22,160 --> 00:19:30,020
with the math until it made sense in a

00:19:25,190 --> 00:19:32,419
way meaning we kind of tried to predict

00:19:30,020 --> 00:19:35,600
and also we had a data about which

00:19:32,419 --> 00:19:38,030
builds of rich code changes resulted in

00:19:35,600 --> 00:19:41,270
outages and we kind of backtracked and

00:19:38,030 --> 00:19:44,780
so well you know how could have we known

00:19:41,270 --> 00:19:47,870
what should have we'd scored in order

00:19:44,780 --> 00:19:49,610
for that change to be flagged as

00:19:47,870 --> 00:19:54,470
something that yet that you shouldn't

00:19:49,610 --> 00:19:56,900
promote and that's why in in that third

00:19:54,470 --> 00:19:58,929
line you see this weight and in the

00:19:56,900 --> 00:20:02,929
fourth line you see this normalization

00:19:58,929 --> 00:20:05,450
and I have the the actual code snippets

00:20:02,929 --> 00:20:09,500
on github and some of it or on the deck

00:20:05,450 --> 00:20:12,330
feel free to if you care go in it's all

00:20:09,500 --> 00:20:16,409
open-source how we're for

00:20:12,330 --> 00:20:17,549
forming those scores for our builds so I

00:20:16,409 --> 00:20:19,500
don't want to really touch on that

00:20:17,549 --> 00:20:21,990
because as I said there's a lot of hand

00:20:19,500 --> 00:20:29,070
waving here that won't really do us any

00:20:21,990 --> 00:20:32,340
good and kind of obviously I mainly want

00:20:29,070 --> 00:20:34,620
you to hear what I'm saying and then

00:20:32,340 --> 00:20:36,630
think about your own organization and

00:20:34,620 --> 00:20:42,600
how you can take those approaches and

00:20:36,630 --> 00:20:44,730
you know add it to your practice before

00:20:42,600 --> 00:20:46,919
I kind of sum up I do want to mention

00:20:44,730 --> 00:20:50,130
that we've again as I said we've open

00:20:46,919 --> 00:20:53,190
sourced this entire calculation for our

00:20:50,130 --> 00:20:55,639
benefit and we've also made it available

00:20:53,190 --> 00:20:58,620
through code quality gates plugins

00:20:55,639 --> 00:21:02,760
whether it's in Jenkins or other CI

00:20:58,620 --> 00:21:07,289
tools conkers and essentially as I said

00:21:02,760 --> 00:21:11,610
our main reasoning here is if we score

00:21:07,289 --> 00:21:17,159
and the score is low we want to stop a

00:21:11,610 --> 00:21:19,980
build or not promote code as I said a

00:21:17,159 --> 00:21:20,429
nice snippet of the calculation Java I'm

00:21:19,980 --> 00:21:23,940
sorry

00:21:20,429 --> 00:21:26,490
maybe Kotlin next year this is a sample

00:21:23,940 --> 00:21:29,460
of our Jenkins report again shows like

00:21:26,490 --> 00:21:33,870
you know new exceptions and some other

00:21:29,460 --> 00:21:36,149
cool stuff that we use and this is how

00:21:33,870 --> 00:21:39,450
it gets fed into influx and then graph

00:21:36,149 --> 00:21:42,690
on ax so for every build you have the

00:21:39,450 --> 00:21:48,750
your new increasing slowdowns and that

00:21:42,690 --> 00:21:52,080
score as as the doctor prescribed again

00:21:48,750 --> 00:21:53,070
data nerds we are if you hover again

00:21:52,080 --> 00:21:56,789
that's part of our implementation

00:21:53,070 --> 00:21:59,519
obviously you can see exactly how what

00:21:56,789 --> 00:22:01,820
was the penalty deduction all the scores

00:21:59,519 --> 00:22:09,269
and points that we use in order to

00:22:01,820 --> 00:22:12,029
calculate this score so kind of putting

00:22:09,269 --> 00:22:13,860
this in perspective our engineering team

00:22:12,029 --> 00:22:16,500
by embracing this practice and actually

00:22:13,860 --> 00:22:19,139
stopping build that introduced new

00:22:16,500 --> 00:22:21,809
errors we were able to reduce our self

00:22:19,139 --> 00:22:23,559
ones by 75 percent which is great for

00:22:21,809 --> 00:22:27,220
the business

00:22:23,559 --> 00:22:29,380
I invite you to think about your quality

00:22:27,220 --> 00:22:31,780
case that you can introduce and you

00:22:29,380 --> 00:22:34,059
haven't already to your pipeline again

00:22:31,780 --> 00:22:36,390
it doesn't have to be the ones I talked

00:22:34,059 --> 00:22:40,150
about if you have a different use case

00:22:36,390 --> 00:22:45,010
by all means do add quality gates as

00:22:40,150 --> 00:22:47,559
many as you can and again we're in a

00:22:45,010 --> 00:22:48,970
DevOps today's conference I'm sure some

00:22:47,559 --> 00:22:51,820
of you are working on the reliability

00:22:48,970 --> 00:22:54,280
aspects of the organization it shouldn't

00:22:51,820 --> 00:22:56,860
start in production you have to worry

00:22:54,280 --> 00:23:02,710
about the reliability as early as

00:22:56,860 --> 00:23:04,630
possible and as I said a lot of blinks

00:23:02,710 --> 00:23:17,470
about all the things that I've talked

00:23:04,630 --> 00:23:21,580
about that's all I had yes I'm sorry

00:23:17,470 --> 00:23:25,000
that these are not short URLs but if you

00:23:21,580 --> 00:23:26,920
are and again I would love to speak to

00:23:25,000 --> 00:23:30,580
any of you I know it doesn't have to be

00:23:26,920 --> 00:23:33,460
a question either now or up on the third

00:23:30,580 --> 00:23:36,250
floor that's right I also brought some

00:23:33,460 --> 00:23:38,020
folks that work with me John and Steve

00:23:36,250 --> 00:23:39,760
from over ops if you can kind of show

00:23:38,020 --> 00:23:43,690
your hands yeah they were suits but

00:23:39,760 --> 00:23:46,120
they're nice guys kind of talk about

00:23:43,690 --> 00:23:48,850
what over ops as a company does not

00:23:46,120 --> 00:23:50,530
trying to no no shameless plugs in

00:23:48,850 --> 00:23:53,320
DevOps today so I wouldn't even mention

00:23:50,530 --> 00:23:56,590
it yeah it's me the guy with the

00:23:53,320 --> 00:23:59,140
questions so I wanted to ask if you give

00:23:56,590 --> 00:24:01,030
any thought to whether or not we as an

00:23:59,140 --> 00:24:03,610
industry just kind of throughout the

00:24:01,030 --> 00:24:06,420
role of QA and then reinvented it in the

00:24:03,610 --> 00:24:11,070
most elaborate way possible

00:24:06,420 --> 00:24:12,960
I think I'm gonna edit as another bullet

00:24:11,070 --> 00:24:14,630
on my on my slide if I ever do this talk

00:24:12,960 --> 00:24:18,990
again

00:24:14,630 --> 00:24:20,880
well well well said right I think all

00:24:18,990 --> 00:24:23,750
right so I I do want to share some some

00:24:20,880 --> 00:24:26,880
it's gonna be some frustrations right I

00:24:23,750 --> 00:24:32,280
being a co-founder it over ops I hired

00:24:26,880 --> 00:24:35,940
our first keyway engineer three years in

00:24:32,280 --> 00:24:38,400
and my co-founders and and the

00:24:35,940 --> 00:24:40,980
engineering manager were always trying

00:24:38,400 --> 00:24:42,570
to say we don't need keyway the

00:24:40,980 --> 00:24:46,260
developers will do everything that we

00:24:42,570 --> 00:24:48,300
they can and so so yes I think everyone

00:24:46,260 --> 00:24:49,800
kind of say well you don't need QA then

00:24:48,300 --> 00:24:51,720
at the end of the day someone is

00:24:49,800 --> 00:24:53,910
responsible for the quality of the

00:24:51,720 --> 00:24:56,940
application I for once would love for

00:24:53,910 --> 00:24:59,010
every company to have a director of

00:24:56,940 --> 00:25:00,690
quality doesn't even have to be a keyway

00:24:59,010 --> 00:25:02,880
manager but someone who really thinks

00:25:00,690 --> 00:25:05,670
about quality from a strategic

00:25:02,880 --> 00:25:07,590
standpoint so III really resonate with

00:25:05,670 --> 00:25:11,520
what you're saying about QA is being

00:25:07,590 --> 00:25:15,360
kind of those you know does anyone have

00:25:11,520 --> 00:25:17,970
a QA title here in the audience perfect

00:25:15,360 --> 00:25:20,760
call yourself DevOps from now on and

00:25:17,970 --> 00:25:22,950
that that's that's out of the industry

00:25:20,760 --> 00:25:26,720
are handling no but but but but for

00:25:22,950 --> 00:25:29,550
reals I think you know you are you're

00:25:26,720 --> 00:25:32,520
invaluable and super important for

00:25:29,550 --> 00:25:36,240
engine healthy engineering organization

00:25:32,520 --> 00:25:45,300
and we just need to keep fighting the

00:25:36,240 --> 00:25:47,530
fight for quality so perfect thank you

00:25:45,300 --> 00:25:48,590
so much thank you very very much

00:25:47,530 --> 00:25:55,340
[Applause]

00:25:48,590 --> 00:25:57,400
[Music]

00:25:55,340 --> 00:25:57,400

YouTube URL: https://www.youtube.com/watch?v=VNGEUETU4BY


