Title: Dr. Jeremias Roessler - Test Automation Without Assertions
Publication date: 2019-11-04
Playlist: All Things Open 2019
Description: 
	GUI test automation is broken — because regression testing is not testing, but version control of the behavior of the software.

Gradually, an insight is gaining ground in the testing world: Test automation without assertions works better! Whether ApprovalsTest, Jest (Facebook, Open Source) or recheck (retest, Open Source) – the number of tools that work according to the approach of Golden Master Testing / Characterization Testing / Approval Testing is constantly increasing. This approach promises more robust tests with less effort for creation and maintenance, while all the while testing much more completely. What this means, which different tools are available (mostly Open Source), and where the strengths and weaknesses of this approach lie, will be explained in this presentation.

Don’t miss the next trend in test automation…
Captions: 
	00:00:04,750 --> 00:00:07,870
[Music]

00:00:08,340 --> 00:00:13,290
so hello everybody thank you very much

00:00:10,559 --> 00:00:15,240
for coming both to this conference and

00:00:13,290 --> 00:00:19,050
to this talk I know it's the last last

00:00:15,240 --> 00:00:21,480
talk of the day so thanks for staying

00:00:19,050 --> 00:00:23,670
long enough and and coming to this talk

00:00:21,480 --> 00:00:25,439
and what I'm going to talk about is

00:00:23,670 --> 00:00:29,279
taste animation without assertions and

00:00:25,439 --> 00:00:32,969
this is also a project on github and my

00:00:29,279 --> 00:00:35,579
goal for today for this talk is to have

00:00:32,969 --> 00:00:38,239
you like the approach and like the

00:00:35,579 --> 00:00:42,329
project so much that you go all the way

00:00:38,239 --> 00:00:43,920
to give us a get up star so that for you

00:00:42,329 --> 00:00:45,750
if you have a github account is not very

00:00:43,920 --> 00:00:48,480
much to do it's like a click for you and

00:00:45,750 --> 00:00:52,170
but for us for our project it means very

00:00:48,480 --> 00:00:54,210
lot so I hope that I can get you to the

00:00:52,170 --> 00:00:56,430
point where you like it and say okay at

00:00:54,210 --> 00:00:58,500
least I give it a get up star and if you

00:00:56,430 --> 00:00:59,870
do that I have a couple of stickers here

00:00:58,500 --> 00:01:03,600
that I want to share with you so

00:00:59,870 --> 00:01:09,450
afterwards I'll just spread them and you

00:01:03,600 --> 00:01:12,720
can grab some of them so maybe you know

00:01:09,450 --> 00:01:16,189
the problem in general if you have a

00:01:12,720 --> 00:01:19,049
test that checks something and although

00:01:16,189 --> 00:01:23,369
what you check although what do you

00:01:19,049 --> 00:01:25,830
check is fulfilled but the test does not

00:01:23,369 --> 00:01:30,360
quite capture the intent like it does

00:01:25,830 --> 00:01:33,689
not capture what you really want to see

00:01:30,360 --> 00:01:35,610
and then this talk is for you and the

00:01:33,689 --> 00:01:43,409
first thing I want to start with is a

00:01:35,610 --> 00:01:47,640
short demo so can everybody see this

00:01:43,409 --> 00:01:49,530
okay so this is a very short selenium

00:01:47,640 --> 00:01:52,619
test for those of you who are familiar

00:01:49,530 --> 00:01:55,649
with LM it's it's explicitly short and

00:01:52,619 --> 00:01:59,549
explicitly simple such that it works for

00:01:55,649 --> 00:02:01,530
sorry for conference talk and if I

00:01:59,549 --> 00:02:04,079
execute it you will see that all it does

00:02:01,530 --> 00:02:06,210
is it opens a page it enters user

00:02:04,079 --> 00:02:08,090
name/password clicks on success it

00:02:06,210 --> 00:02:11,069
clicks on login and then checks whether

00:02:08,090 --> 00:02:13,379
the the message success was to plate on

00:02:11,069 --> 00:02:13,830
the follow-up page so in order to check

00:02:13,379 --> 00:02:16,020
whether

00:02:13,830 --> 00:02:20,790
the login was successful it's a very

00:02:16,020 --> 00:02:23,010
simple test and I have the HTML here

00:02:20,790 --> 00:02:25,200
that makes up the page that is being

00:02:23,010 --> 00:02:29,670
tested and if I now change something

00:02:25,200 --> 00:02:32,130
let's say I remove just one character

00:02:29,670 --> 00:02:35,190
from the from the Declaration of the CSS

00:02:32,130 --> 00:02:36,960
then what you will see is that the

00:02:35,190 --> 00:02:38,790
website is actually broken because

00:02:36,960 --> 00:02:40,380
there's no CSS anymore it's it's

00:02:38,790 --> 00:02:43,080
rendered from from a user's perspective

00:02:40,380 --> 00:02:46,800
it's broken but because all I check is

00:02:43,080 --> 00:02:48,720
whether a success is being displayed the

00:02:46,800 --> 00:02:51,510
test still passes right so this is

00:02:48,720 --> 00:02:53,610
clearly not what I want and on the other

00:02:51,510 --> 00:02:57,780
hand if I change something as

00:02:53,610 --> 00:03:01,070
insignificant as an ID and now going

00:02:57,780 --> 00:03:04,380
back to the test it identifies or it

00:03:01,070 --> 00:03:07,590
kept it it identifies the element it

00:03:04,380 --> 00:03:12,080
wants to interact with by the ID so if I

00:03:07,590 --> 00:03:12,080
change the ID now if I execute the test

00:03:15,800 --> 00:03:20,580
obviously it's broken so it can't work

00:03:18,570 --> 00:03:22,500
on it anymore and because it can't

00:03:20,580 --> 00:03:25,500
identify the elements anymore in once

00:03:22,500 --> 00:03:28,440
they attacked with although that what I

00:03:25,500 --> 00:03:30,720
change the ID is in cific insignificant

00:03:28,440 --> 00:03:33,480
for the user so the user was using your

00:03:30,720 --> 00:03:36,510
website doesn't care what IDs your

00:03:33,480 --> 00:03:39,959
elements have yet the test does and we

00:03:36,510 --> 00:03:43,830
think that this is the opposite of what

00:03:39,959 --> 00:03:47,250
we want to see so instead you could use

00:03:43,830 --> 00:03:50,459
recheck which I'm going to show you and

00:03:47,250 --> 00:03:52,080
you just grab your driver your your

00:03:50,459 --> 00:03:54,600
chrome driver or what have you in the

00:03:52,080 --> 00:03:59,430
recheck driver and then if you execute

00:03:54,600 --> 00:04:06,060
the same test and you remove or change

00:03:59,430 --> 00:04:07,709
the CSS declaration as you can see the

00:04:06,060 --> 00:04:10,860
website is again broken because I

00:04:07,709 --> 00:04:11,489
removed the CSS but this time it's being

00:04:10,860 --> 00:04:14,340
detected

00:04:11,489 --> 00:04:16,709
and it says that it has 116 differences

00:04:14,340 --> 00:04:19,500
that are unintended and the test fails

00:04:16,709 --> 00:04:22,740
so this is what you want to see and even

00:04:19,500 --> 00:04:27,360
better if you now change or remove the

00:04:22,740 --> 00:04:30,900
ID and execute the test

00:04:27,360 --> 00:04:35,490
guess what it still works

00:04:30,900 --> 00:04:38,189
so it can identify the ID and execute

00:04:35,490 --> 00:04:39,659
the test and the screen so this is what

00:04:38,189 --> 00:04:41,639
we want to see what we would like to

00:04:39,659 --> 00:04:44,099
have with the selenium or with with with

00:04:41,639 --> 00:04:46,409
any test of a user interface and I'm now

00:04:44,099 --> 00:04:50,909
going to show you and explain you to you

00:04:46,409 --> 00:04:56,090
how this works under the hood and how we

00:04:50,909 --> 00:04:59,610
can use it so sorry

00:04:56,090 --> 00:05:02,610
so the idea generally is that we one

00:04:59,610 --> 00:05:06,779
that we do one thing differently instead

00:05:02,610 --> 00:05:09,569
so with a typical test you define the

00:05:06,779 --> 00:05:11,939
outcome so yeah you you write an assert

00:05:09,569 --> 00:05:14,099
where you say what you want to see and

00:05:11,939 --> 00:05:16,680
instead with that type of tests you

00:05:14,099 --> 00:05:19,800
approve the outcome so you so you

00:05:16,680 --> 00:05:22,770
manually test once and then you capture

00:05:19,800 --> 00:05:24,810
that what what you manually test it and

00:05:22,770 --> 00:05:26,580
verify that it's correct within your

00:05:24,810 --> 00:05:28,800
testing framework and your testing

00:05:26,580 --> 00:05:31,770
framework just make sure that it doesn't

00:05:28,800 --> 00:05:35,659
change unexpectedly that you don't have

00:05:31,770 --> 00:05:38,879
unintended side effects regressions and

00:05:35,659 --> 00:05:42,150
in that regard we argue that automated

00:05:38,879 --> 00:05:44,190
tests are not tests because whether with

00:05:42,150 --> 00:05:46,469
a manual test when you execute that

00:05:44,190 --> 00:05:49,529
manual test what you try to find is a

00:05:46,469 --> 00:05:53,729
bug at this the second you execute the

00:05:49,529 --> 00:05:56,189
test you try to improve the quality of

00:05:53,729 --> 00:05:58,699
your project but with an automated test

00:05:56,189 --> 00:06:02,789
what you do is you expect that it passes

00:05:58,699 --> 00:06:05,310
so all the automated test does is it

00:06:02,789 --> 00:06:08,099
guards you against unintended changes

00:06:05,310 --> 00:06:10,379
and against regressions so in that

00:06:08,099 --> 00:06:14,839
regard an automated test is more like

00:06:10,379 --> 00:06:16,949
version control than a typical test and

00:06:14,839 --> 00:06:19,349
typical version control like if you use

00:06:16,949 --> 00:06:22,099
good in get in your project it answers

00:06:19,349 --> 00:06:25,349
the question where has the code changed

00:06:22,099 --> 00:06:27,930
but what you rather would have is the

00:06:25,349 --> 00:06:30,419
problem is that the code is not the

00:06:27,930 --> 00:06:32,939
software software is more than code

00:06:30,419 --> 00:06:36,180
software is what you get when you

00:06:32,939 --> 00:06:37,589
execute the code and you put in I put it

00:06:36,180 --> 00:06:39,389
into a runtime system you put in some

00:06:37,589 --> 00:06:41,279
data as we put in some configuration and

00:06:39,389 --> 00:06:43,259
so what you see on the

00:06:41,279 --> 00:06:47,699
Queen the the experience that the user

00:06:43,259 --> 00:06:49,799
has is more than the code so using

00:06:47,699 --> 00:06:53,039
version control to capture and govern

00:06:49,799 --> 00:06:56,669
the code fails short of governing the

00:06:53,039 --> 00:06:58,679
user experience and what we really want

00:06:56,669 --> 00:07:03,509
to know is where has the software

00:06:58,679 --> 00:07:06,509
changed so right now we close the gap

00:07:03,509 --> 00:07:08,699
using automated tests and in in that

00:07:06,509 --> 00:07:11,339
view in you know using that notion that

00:07:08,699 --> 00:07:15,329
I just explained means that an automated

00:07:11,339 --> 00:07:17,699
test is a means to turn the dynamic

00:07:15,329 --> 00:07:20,939
runtime behavior of your software into

00:07:17,699 --> 00:07:22,709
an static artifact then that then can be

00:07:20,939 --> 00:07:26,909
governed by a version control and you

00:07:22,709 --> 00:07:29,309
execute the test to to compare the

00:07:26,909 --> 00:07:30,959
expected runtime behavior of the

00:07:29,309 --> 00:07:36,059
software with the actual runtime

00:07:30,959 --> 00:07:38,369
behavior of the software so if automated

00:07:36,059 --> 00:07:40,829
tests are version control

00:07:38,369 --> 00:07:42,839
then I have an example for you that's

00:07:40,829 --> 00:07:46,439
using a different project different

00:07:42,839 --> 00:07:48,809
open-source project and that works on on

00:07:46,439 --> 00:07:52,079
the unit level or not on the unit level

00:07:48,809 --> 00:07:53,159
on the interface level so in that in

00:07:52,079 --> 00:07:56,519
that example

00:07:53,159 --> 00:07:59,639
you want some XML to be transformed and

00:07:56,519 --> 00:08:02,249
you have an remove element transformer

00:07:59,639 --> 00:08:06,779
that should remove remove take out of

00:08:02,249 --> 00:08:09,239
the XML and what you do is in your test

00:08:06,779 --> 00:08:11,459
with the assertions you just check that

00:08:09,239 --> 00:08:13,589
the remove tech has been removed so it's

00:08:11,459 --> 00:08:16,079
no longer contained and that the keep

00:08:13,589 --> 00:08:18,509
tag is still within the XML so it's not

00:08:16,079 --> 00:08:21,599
removed so what you want to see is that

00:08:18,509 --> 00:08:24,209
if you input the above XML then what

00:08:21,599 --> 00:08:26,129
result should be like is the the below

00:08:24,209 --> 00:08:30,739
XML right this is what you want to test

00:08:26,129 --> 00:08:34,889
however the way you assert that behavior

00:08:30,739 --> 00:08:37,529
if that is the result of your of your

00:08:34,889 --> 00:08:40,409
transformation the test still passes so

00:08:37,529 --> 00:08:42,930
that's an example like before and where

00:08:40,409 --> 00:08:45,059
the assertion falls short of capturing

00:08:42,930 --> 00:08:47,519
the essence of what you want to what you

00:08:45,059 --> 00:08:49,709
want to what you want to see so here

00:08:47,519 --> 00:08:51,209
again as you can see the keep tech is

00:08:49,709 --> 00:08:52,110
still there it's not even a valid XML

00:08:51,209 --> 00:08:54,780
anymore right

00:08:52,110 --> 00:08:56,520
but the keep tag is is there

00:08:54,780 --> 00:09:03,080
the remove track is not so this test

00:08:56,520 --> 00:09:07,650
will pass and on that level

00:09:03,080 --> 00:09:09,750
sorry on that level what you can do is

00:09:07,650 --> 00:09:12,180
and go to master testing so it's

00:09:09,750 --> 00:09:14,220
something that's been invented in the

00:09:12,180 --> 00:09:15,900
80s so it's it's known technique it's

00:09:14,220 --> 00:09:19,380
something that is usually applied to

00:09:15,900 --> 00:09:21,330
legacy systems if you have a large code

00:09:19,380 --> 00:09:24,030
base of legacy code that you can't

00:09:21,330 --> 00:09:26,400
govern any more then what you do is you

00:09:24,030 --> 00:09:27,510
go for the input output and just ensure

00:09:26,400 --> 00:09:29,340
that the output doesn't change

00:09:27,510 --> 00:09:33,510
unintentionally and this is called

00:09:29,340 --> 00:09:35,460
master testing and so this is approval

00:09:33,510 --> 00:09:38,490
tests and this works for for Java

00:09:35,460 --> 00:09:41,760
projects or chava code and you can just

00:09:38,490 --> 00:09:43,710
verify that the result is what you

00:09:41,760 --> 00:09:46,200
expect so the first time you execute the

00:09:43,710 --> 00:09:48,450
test it will fail but it will create the

00:09:46,200 --> 00:09:51,300
golden master and the next time you

00:09:48,450 --> 00:09:54,600
execute the test it will compare the

00:09:51,300 --> 00:09:56,790
exact output that was generated to the

00:09:54,600 --> 00:09:59,340
output that was approved before and it

00:09:56,790 --> 00:10:03,150
will show if as much as one single

00:09:59,340 --> 00:10:05,810
character changes so it will only pass

00:10:03,150 --> 00:10:08,880
if the result looks like that

00:10:05,810 --> 00:10:11,340
however using such a technique go to

00:10:08,880 --> 00:10:14,760
master approach you usually have two

00:10:11,340 --> 00:10:16,860
challenges one is noise and the other is

00:10:14,760 --> 00:10:18,960
redundancy and I'll come to each one of

00:10:16,860 --> 00:10:22,800
that in a minute I'll start with noise

00:10:18,960 --> 00:10:25,050
and so what do you mean by noise or how

00:10:22,800 --> 00:10:26,730
can you can you address the issue well

00:10:25,050 --> 00:10:29,190
if you have noise for instance in an

00:10:26,730 --> 00:10:31,560
audio signal what you do is you apply a

00:10:29,190 --> 00:10:34,440
filter right and when we can do the same

00:10:31,560 --> 00:10:38,310
here but coming back to our original

00:10:34,440 --> 00:10:40,470
notion of testing not being or automated

00:10:38,310 --> 00:10:44,730
testing not being testing actually but

00:10:40,470 --> 00:10:47,910
being a version control then what what

00:10:44,730 --> 00:10:51,210
what noise is is suddenly something

00:10:47,910 --> 00:10:53,820
different so if you have an assert

00:10:51,210 --> 00:10:57,810
statement then what the desert as assert

00:10:53,820 --> 00:11:00,120
statement does is it creates a rule in a

00:10:57,810 --> 00:11:01,890
denialist of changes like if if a

00:11:00,120 --> 00:11:04,640
testing is version control then the

00:11:01,890 --> 00:11:08,259
assert statement says ok this property

00:11:04,640 --> 00:11:10,779
this whatever it is doesn't may not

00:11:08,259 --> 00:11:13,299
change without me being noticed so if

00:11:10,779 --> 00:11:15,999
that change the test has to fail and I

00:11:13,299 --> 00:11:18,369
will be noticed and notified and then I

00:11:15,999 --> 00:11:22,989
can either update the test or I can fix

00:11:18,369 --> 00:11:24,819
whatever is broken on the other hand on

00:11:22,989 --> 00:11:27,669
version control we have the notion of a

00:11:24,819 --> 00:11:30,639
git ignore which means that if you have

00:11:27,669 --> 00:11:33,279
too much if you have like class files

00:11:30,639 --> 00:11:35,589
artifact log log files stuff like that

00:11:33,279 --> 00:11:39,189
and you ignore them using a git ignore

00:11:35,589 --> 00:11:40,779
file to remove the noise so in the

00:11:39,189 --> 00:11:43,749
container file everything that you're

00:11:40,779 --> 00:11:47,470
not interested in you just specify and

00:11:43,749 --> 00:11:50,350
it's been ignored and this creates a

00:11:47,470 --> 00:11:51,669
spectrum right and the ideal amount of

00:11:50,350 --> 00:11:54,160
checks that you want to have in your

00:11:51,669 --> 00:11:56,619
typical test is somewhere in between so

00:11:54,160 --> 00:11:59,529
on the one hand side if you don't

00:11:56,619 --> 00:12:02,169
specify any assertions then you check

00:11:59,529 --> 00:12:04,299
nothing right if your denialist is empty

00:12:02,169 --> 00:12:07,359
you check nothing on the other hand side

00:12:04,299 --> 00:12:09,639
if you don't specify anything in your

00:12:07,359 --> 00:12:12,639
git ignore file for instance and then

00:12:09,639 --> 00:12:14,619
you check everything so not as much as a

00:12:12,639 --> 00:12:16,660
single character may change without you

00:12:14,619 --> 00:12:18,369
being noticed but what you want in a

00:12:16,660 --> 00:12:20,980
typical environment is something in

00:12:18,369 --> 00:12:22,839
between right you want you don't want to

00:12:20,980 --> 00:12:24,220
be notified about every change because

00:12:22,839 --> 00:12:26,980
you have things that you don't care

00:12:24,220 --> 00:12:31,019
about but about you want to be notified

00:12:26,980 --> 00:12:33,549
about things that you do care about and

00:12:31,019 --> 00:12:35,879
interesting enough it makes it different

00:12:33,549 --> 00:12:41,039
from which side you approach the problem

00:12:35,879 --> 00:12:43,419
so at Google they have this interesting

00:12:41,039 --> 00:12:45,730
mechanism where they notify manual

00:12:43,419 --> 00:12:48,309
testers so if you're a manual tester at

00:12:45,730 --> 00:12:51,399
Google and then you should take you

00:12:48,309 --> 00:12:54,129
should watch out for those unicorns or

00:12:51,399 --> 00:12:58,179
the dancing ponies on the screen because

00:12:54,129 --> 00:13:02,220
those mark changed functionality so if

00:12:58,179 --> 00:13:05,139
you're a tester you want to test vary

00:13:02,220 --> 00:13:06,789
scrutiny you want to scrutinize the

00:13:05,139 --> 00:13:10,149
elements that are marked with such a

00:13:06,789 --> 00:13:12,249
unicorn however at some point somebody

00:13:10,149 --> 00:13:15,369
forgot to remove that marker before

00:13:12,249 --> 00:13:18,100
pushing to production so suddenly the

00:13:15,369 --> 00:13:21,980
customers had dancing unicorns on the

00:13:18,100 --> 00:13:24,890
screen because and also nobody thought

00:13:21,980 --> 00:13:27,050
about writing a test for that so because

00:13:24,890 --> 00:13:29,690
nobody expected you know dancing

00:13:27,050 --> 00:13:33,500
unicorns on the screen which means that

00:13:29,690 --> 00:13:35,450
if you essentially you can write an

00:13:33,500 --> 00:13:40,670
assertion for something that you don't

00:13:35,450 --> 00:13:42,650
expect right if if if you don't know

00:13:40,670 --> 00:13:46,700
that this could eventually happen you

00:13:42,650 --> 00:13:49,940
don't guard against it however if you

00:13:46,700 --> 00:13:53,270
are notified about every unexpected

00:13:49,940 --> 00:13:55,160
change then you get notified about the

00:13:53,270 --> 00:13:57,740
dancing Kanye unicorns on the screen

00:13:55,160 --> 00:14:00,260
because they are unexpected so you get

00:13:57,740 --> 00:14:02,120
notified about them and this is the

00:14:00,260 --> 00:14:03,350
reason like even I didn't want to call

00:14:02,120 --> 00:14:09,170
that blacklist whitelist

00:14:03,350 --> 00:14:11,150
but if you do for instance a firewall if

00:14:09,170 --> 00:14:13,880
you create a firewall then you don't

00:14:11,150 --> 00:14:16,490
close individual ports you close all the

00:14:13,880 --> 00:14:18,590
ports at once and you do white list of

00:14:16,490 --> 00:14:20,690
ports that you want to allow right and

00:14:18,590 --> 00:14:24,980
this is the same principle for obvious

00:14:20,690 --> 00:14:28,010
reasons and the other thing that kind of

00:14:24,980 --> 00:14:30,680
makes sense is that most of the time you

00:14:28,010 --> 00:14:33,470
want to check more rather than less so

00:14:30,680 --> 00:14:38,470
typically the amount of checks that you

00:14:33,470 --> 00:14:41,450
want to want to put into into your tests

00:14:38,470 --> 00:14:43,010
more so you don't you don't want to put

00:14:41,450 --> 00:14:46,010
assertions for each and everything and

00:14:43,010 --> 00:14:47,720
you rather want to ignore those five I

00:14:46,010 --> 00:14:51,800
don't know elements or attributes that

00:14:47,720 --> 00:14:54,020
you don't care about this is the reason

00:14:51,800 --> 00:14:56,960
why we call our approach also get for

00:14:54,020 --> 00:14:59,270
the GUI because it's essentially what

00:14:56,960 --> 00:15:02,240
what we do get is our role model in that

00:14:59,270 --> 00:15:05,030
regard and therefore like it has a GUID

00:15:02,240 --> 00:15:07,310
ignore file and we created a recheck

00:15:05,030 --> 00:15:09,140
ignore file so you can put that recheck

00:15:07,310 --> 00:15:15,050
ignore file even into your project or

00:15:09,140 --> 00:15:18,530
into your personal folder like your user

00:15:15,050 --> 00:15:21,650
folder and beneath that retest and then

00:15:18,530 --> 00:15:24,560
retest will pick it up so you can for

00:15:21,650 --> 00:15:26,090
instance ignore attributes on a global

00:15:24,560 --> 00:15:29,750
level so you can ignore the class

00:15:26,090 --> 00:15:31,580
attribute or you can specify rekha axis

00:15:29,750 --> 00:15:34,040
so you can say everything that starts

00:15:31,580 --> 00:15:35,779
with data I want to ignore so that

00:15:34,040 --> 00:15:38,870
dragged X specifically ignore

00:15:35,779 --> 00:15:42,170
everything which is again not what you

00:15:38,870 --> 00:15:43,850
want to do then you can ignore specific

00:15:42,170 --> 00:15:45,800
elements so you can say I don't care

00:15:43,850 --> 00:15:46,610
about links or I don't care about

00:15:45,800 --> 00:15:49,810
iframes

00:15:46,610 --> 00:15:53,809
or I don't care about you know specific

00:15:49,810 --> 00:15:57,519
elements within your DOM and you can

00:15:53,809 --> 00:16:00,079
identify individual elements by

00:15:57,519 --> 00:16:04,579
identifying attributes like by their ID

00:16:00,079 --> 00:16:07,009
by their class by the XPath so you could

00:16:04,579 --> 00:16:09,559
just and then you can combine that so

00:16:07,009 --> 00:16:13,339
you can say okay for the element with

00:16:09,559 --> 00:16:18,230
the ID thief whatever I want to ignore

00:16:13,339 --> 00:16:22,220
the font or I want to ignore whole

00:16:18,230 --> 00:16:26,809
subtrees maybe I just specify I don't

00:16:22,220 --> 00:16:29,749
care about whatever I have changing

00:16:26,809 --> 00:16:31,879
animation on my website or a subtree

00:16:29,749 --> 00:16:34,370
that that's coming from from a different

00:16:31,879 --> 00:16:35,839
component from a different micro service

00:16:34,370 --> 00:16:40,459
whatever so I want to ignore that

00:16:35,839 --> 00:16:44,480
completely so in such a way and ignore

00:16:40,459 --> 00:16:46,730
is like a filter what I said earlier to

00:16:44,480 --> 00:16:49,879
ignore the noise you can ignore and

00:16:46,730 --> 00:16:52,129
filter or subject no file to reduce the

00:16:49,879 --> 00:16:54,139
noise in the changes that you are

00:16:52,129 --> 00:17:00,579
notified about and I just want to give

00:16:54,139 --> 00:17:07,339
you a short demo again so if you are

00:17:00,579 --> 00:17:09,770
right if you have a website like that so

00:17:07,339 --> 00:17:12,289
these two websites as you can see are

00:17:09,770 --> 00:17:16,699
very different from one another so they

00:17:12,289 --> 00:17:18,490
have they differ in color in font in in

00:17:16,699 --> 00:17:22,480
the outline like where the elements are

00:17:18,490 --> 00:17:26,360
placed they differ on very much and

00:17:22,480 --> 00:17:30,049
using the GUI but you can do the same

00:17:26,360 --> 00:17:32,120
with the CLI you can see that all of

00:17:30,049 --> 00:17:36,830
those changes are picked up now you can

00:17:32,120 --> 00:17:39,380
use filters to ignore those changes just

00:17:36,830 --> 00:17:41,480
for the second so you can ignore

00:17:39,380 --> 00:17:44,299
positioning you can ignore all style

00:17:41,480 --> 00:17:46,549
attributes like color font what have you

00:17:44,299 --> 00:17:48,710
and you can ignore any invisible

00:17:46,549 --> 00:17:51,710
attributes like XPath

00:17:48,710 --> 00:17:54,590
class changes ID changes and if you do

00:17:51,710 --> 00:17:59,559
that then you see that the contents of

00:17:54,590 --> 00:18:02,840
those two websites differ in exactly

00:17:59,559 --> 00:18:05,240
four places so you have you have to

00:18:02,840 --> 00:18:09,950
changes in contents and you obviously

00:18:05,240 --> 00:18:12,350
have changes in the in the illustrations

00:18:09,950 --> 00:18:16,929
that that are being shown and you can do

00:18:12,350 --> 00:18:20,720
the same thing with CLI so if you just

00:18:16,929 --> 00:18:30,289
give the report that recheck produces

00:18:20,720 --> 00:18:42,320
with the c-loc oh no I'm sorry it's a

00:18:30,289 --> 00:18:45,380
live demo so right if you give the

00:18:42,320 --> 00:18:47,510
report file on the seal I just like that

00:18:45,380 --> 00:18:49,850
then it reports all the differences and

00:18:47,510 --> 00:18:52,549
as you can see these are semantic

00:18:49,850 --> 00:18:54,679
differences so it doesn't give you just

00:18:52,549 --> 00:18:56,630
it just it doesn't state there is

00:18:54,679 --> 00:19:00,110
something different it tells you exactly

00:18:56,630 --> 00:19:03,860
what differs and but you can ignore as

00:19:00,110 --> 00:19:06,020
before using filters you can ignore

00:19:03,860 --> 00:19:08,630
positioning style attributes and

00:19:06,020 --> 00:19:13,549
invisible attributes to come up with the

00:19:08,630 --> 00:19:20,480
same result as you can see reporting the

00:19:13,549 --> 00:19:22,399
same result so if you would do pixel

00:19:20,480 --> 00:19:24,049
living which I mean there are some

00:19:22,399 --> 00:19:25,909
approaches both open-source and

00:19:24,049 --> 00:19:28,309
commercially and that you can use for

00:19:25,909 --> 00:19:30,409
visual regression testing if you do

00:19:28,309 --> 00:19:32,539
pixel diffing for those two websites

00:19:30,409 --> 00:19:34,340
then obviously was it what it will give

00:19:32,539 --> 00:19:36,490
you is it says look everything's

00:19:34,340 --> 00:19:36,490
different

00:19:37,630 --> 00:19:46,340
which is the case however and using the

00:19:43,669 --> 00:19:48,200
rechecking no file or using filters as

00:19:46,340 --> 00:19:50,779
you just saw you can drill down on that

00:19:48,200 --> 00:19:53,240
so you can say where does it differ so

00:19:50,779 --> 00:19:55,970
ignore the font show me where the text

00:19:53,240 --> 00:19:58,220
differs ignore or do the other way

00:19:55,970 --> 00:20:00,200
around if you have say an English

00:19:58,220 --> 00:20:01,250
version of a website and a Spanish

00:20:00,200 --> 00:20:02,570
version of a website

00:20:01,250 --> 00:20:04,370
you made him one

00:20:02,570 --> 00:20:09,019
all the content and say okay where does

00:20:04,370 --> 00:20:10,490
the CSS differ so and and what this also

00:20:09,019 --> 00:20:13,789
gives you which we didn't intend when we

00:20:10,490 --> 00:20:16,759
created it AC possibility to do cross

00:20:13,789 --> 00:20:18,590
browser across device testing where you

00:20:16,759 --> 00:20:20,539
can say okay I want to generate the

00:20:18,590 --> 00:20:22,669
golden master on a Firefox and I want to

00:20:20,539 --> 00:20:27,139
compare it to the golden master on a

00:20:22,669 --> 00:20:29,269
chrome and see what those differ so demo

00:20:27,139 --> 00:20:32,779
you had this is just a backup if the

00:20:29,269 --> 00:20:35,330
demo wouldn't work and what also works

00:20:32,779 --> 00:20:38,929
is very interesting is it works with

00:20:35,330 --> 00:20:48,190
animations so you can't sensibly if you

00:20:38,929 --> 00:20:48,190
have moving didn't open that if you have

00:20:50,080 --> 00:20:55,250
moving elements like these you obviously

00:20:53,450 --> 00:20:57,230
can't do pixel diffing right because

00:20:55,250 --> 00:21:01,750
they just they will just keep on moving

00:20:57,230 --> 00:21:05,659
so it's it's not possible to give them

00:21:01,750 --> 00:21:11,350
bitwise in a piecewise in any sensible

00:21:05,659 --> 00:21:11,350
way however using recheck it will report

00:21:12,639 --> 00:21:19,389
that there's a difference in in that

00:21:15,889 --> 00:21:19,389
text sorry

00:21:19,419 --> 00:21:24,590
there's okay I can do that life so we

00:21:22,639 --> 00:21:28,190
also created a Chrome extension for that

00:21:24,590 --> 00:21:31,370
so you can just install the Chrome

00:21:28,190 --> 00:21:34,279
extension and and create anything on the

00:21:31,370 --> 00:21:37,220
go on the fly so I just create the gold

00:21:34,279 --> 00:21:41,210
master then and the chrome extension

00:21:37,220 --> 00:21:45,740
also is open source then I compare it

00:21:41,210 --> 00:21:48,549
and then the report is created so I can

00:21:45,740 --> 00:21:48,549
load the report

00:21:51,490 --> 00:21:58,059
and ignoring the positioning because

00:21:56,020 --> 00:22:01,510
obviously that changes with moving text

00:21:58,059 --> 00:22:04,690
and it will just report you that the

00:22:01,510 --> 00:22:08,559
animation now starts 0.3 seconds later

00:22:04,690 --> 00:22:13,090
and that there's a difference in that

00:22:08,559 --> 00:22:19,299
text where you can drill down on it and

00:22:13,090 --> 00:22:20,919
and see what it actually is so the other

00:22:19,299 --> 00:22:23,770
problem that I mentioned earlier with a

00:22:20,919 --> 00:22:26,020
golden master approach is redundancy so

00:22:23,770 --> 00:22:27,940
if you create like hundreds of gold

00:22:26,020 --> 00:22:30,370
masters then there will be a natural

00:22:27,940 --> 00:22:31,929
overlap like if you have a website and

00:22:30,370 --> 00:22:34,510
you create a gold master on the website

00:22:31,929 --> 00:22:36,090
and for instance you check the logo well

00:22:34,510 --> 00:22:41,020
I guess what all of your tests will fail

00:22:36,090 --> 00:22:45,370
and it for other tools we learned that

00:22:41,020 --> 00:22:46,779
it's cumbersome to apply each and every

00:22:45,370 --> 00:22:48,100
change to all of the golden masters

00:22:46,779 --> 00:22:50,350
because you have to manually if you have

00:22:48,100 --> 00:22:52,750
hundreds of tests you have to go through

00:22:50,350 --> 00:22:56,760
hundreds of changes manually and apply

00:22:52,750 --> 00:22:59,950
it each and every one of them by

00:22:56,760 --> 00:23:04,299
individually and we solve that problem

00:22:59,950 --> 00:23:06,309
and with tooling so if you if you have

00:23:04,299 --> 00:23:08,110
the problem and then you can just say

00:23:06,309 --> 00:23:10,480
commit you have to review the changes

00:23:08,110 --> 00:23:12,399
obviously but if you if you think the

00:23:10,480 --> 00:23:14,559
changes are fine if you updated your

00:23:12,399 --> 00:23:20,159
website if you change the logo and then

00:23:14,559 --> 00:23:20,159
you can just say commit all using the

00:23:20,490 --> 00:23:27,370
the CLI that I just showed you and it

00:23:23,470 --> 00:23:30,250
will apply all of the changes to all of

00:23:27,370 --> 00:23:32,470
the gold masters or you can select them

00:23:30,250 --> 00:23:40,049
individually and using the GUI for

00:23:32,470 --> 00:23:40,049
instance and you can say anymore sorry

00:23:47,809 --> 00:23:57,799
okay so you can just say I want to apply

00:23:52,820 --> 00:24:00,600
just slow so I want to apply that change

00:23:57,799 --> 00:24:02,010
and I want to apply that change and I

00:24:00,600 --> 00:24:03,659
want to ignore that change and you can

00:24:02,010 --> 00:24:06,299
all that change and if you nail press

00:24:03,659 --> 00:24:09,419
apply the golden master is updated and

00:24:06,299 --> 00:24:12,960
the ignore fan is updated and the same

00:24:09,419 --> 00:24:15,270
like here you you applied you accepted

00:24:12,960 --> 00:24:17,909
individual changes and the same change

00:24:15,270 --> 00:24:20,010
to the same element is applied to every

00:24:17,909 --> 00:24:22,110
instance of that change so if you have

00:24:20,010 --> 00:24:24,750
100 golden masters and you change the

00:24:22,110 --> 00:24:27,120
logo it's literally still just one click

00:24:24,750 --> 00:24:37,350
and all of the gold masters will be

00:24:27,120 --> 00:24:41,130
updated and now and what I showed

00:24:37,350 --> 00:24:44,580
earlier and what some of you might have

00:24:41,130 --> 00:24:47,880
tipped you off is how did we make the

00:24:44,580 --> 00:24:50,549
test not break when the ID changed like

00:24:47,880 --> 00:24:51,120
I change the ID of the test and it

00:24:50,549 --> 00:24:56,580
didn't break

00:24:51,120 --> 00:24:59,669
remember how did we do that well we have

00:24:56,580 --> 00:25:02,700
now the comfortable situation that if

00:24:59,669 --> 00:25:04,620
like here we change the ID and we still

00:25:02,700 --> 00:25:07,350
have the golden master which is

00:25:04,620 --> 00:25:09,600
essentially a copy of the website and in

00:25:07,350 --> 00:25:12,720
that copy of the website we still have

00:25:09,600 --> 00:25:15,840
the old ID so we can just go to the old

00:25:12,720 --> 00:25:19,370
version that we have persisted retrieve

00:25:15,840 --> 00:25:21,899
the element by the still existing ID

00:25:19,370 --> 00:25:24,029
then go to the new version of the

00:25:21,899 --> 00:25:27,809
website make a one-on-one assignment of

00:25:24,029 --> 00:25:29,789
all the elements - of all the existing

00:25:27,809 --> 00:25:31,679
elements to all the old elements and

00:25:29,789 --> 00:25:33,570
then find the element with the highest

00:25:31,679 --> 00:25:37,200
match with the highest overlap and

00:25:33,570 --> 00:25:42,690
return that and use that so what we do

00:25:37,200 --> 00:25:44,520
here is we essentially use the we make

00:25:42,690 --> 00:25:46,440
intentionally use of the redundancy

00:25:44,520 --> 00:25:48,690
that's created within the golden master

00:25:46,440 --> 00:25:51,809
we use the name we use the class

00:25:48,690 --> 00:25:54,630
attribute with used exam XPath that is

00:25:51,809 --> 00:25:56,250
there to find the element that was

00:25:54,630 --> 00:25:59,309
intended and it doesn't only work for

00:25:56,250 --> 00:26:01,920
for ID it works also for name for text

00:25:59,309 --> 00:26:04,100
for for XPath for

00:26:01,920 --> 00:26:08,100
for like any attribute that selenium has

00:26:04,100 --> 00:26:11,100
and what it does I am and what it does

00:26:08,100 --> 00:26:13,560
is at the at the second we have to do

00:26:11,100 --> 00:26:16,380
that so if this at the situation where

00:26:13,560 --> 00:26:18,180
we realize that the ID that we are

00:26:16,380 --> 00:26:21,000
referencing in the test is not in the

00:26:18,180 --> 00:26:23,970
actual website anymore then we create a

00:26:21,000 --> 00:26:27,990
warning that we lock to the to the to

00:26:23,970 --> 00:26:30,150
the lock and we now can say because we

00:26:27,990 --> 00:26:33,300
make the one on one assignment we now

00:26:30,150 --> 00:26:35,850
can identify which old element to which

00:26:33,300 --> 00:26:38,340
new element was mapped and then we can

00:26:35,850 --> 00:26:41,550
say ok you need to update your test and

00:26:38,340 --> 00:26:43,590
we know which test to update and we know

00:26:41,550 --> 00:26:45,240
how to update it so the next logical

00:26:43,590 --> 00:26:47,280
step would we want to implement we

00:26:45,240 --> 00:26:49,380
haven't implemented it yet but the next

00:26:47,280 --> 00:26:51,750
logical step that we're working on is to

00:26:49,380 --> 00:26:54,570
do that automatically for you so instead

00:26:51,750 --> 00:26:56,970
of you having to go to your own test

00:26:54,570 --> 00:27:02,660
code and changing the test code we can

00:26:56,970 --> 00:27:05,700
do that for you not implemented yet and

00:27:02,660 --> 00:27:08,400
we also can go one step further because

00:27:05,700 --> 00:27:13,200
and what we do is when when we create

00:27:08,400 --> 00:27:17,180
the the copy of the website or what we

00:27:13,200 --> 00:27:20,400
can do is we can insert an additional

00:27:17,180 --> 00:27:22,830
attribute into the copy of the website

00:27:20,400 --> 00:27:25,950
that didn't exist or that doesn't exist

00:27:22,830 --> 00:27:28,490
on the actual website and then we can

00:27:25,950 --> 00:27:31,650
reference that additional attribute and

00:27:28,490 --> 00:27:34,530
because it doesn't live on the actual

00:27:31,650 --> 00:27:36,360
website it's never affected by change so

00:27:34,530 --> 00:27:39,000
however you change the website that

00:27:36,360 --> 00:27:41,340
attribute won't change so we have a

00:27:39,000 --> 00:27:44,910
constant virtual identifier we call it

00:27:41,340 --> 00:27:47,910
the retest ID and essentially it stopped

00:27:44,910 --> 00:27:49,860
just to drop in replacement so within

00:27:47,910 --> 00:27:52,050
the golden master we introduced an

00:27:49,860 --> 00:27:54,960
additional attribute and you now can

00:27:52,050 --> 00:27:56,640
reference that attribute and again using

00:27:54,960 --> 00:27:58,680
the one on one assignment mechanism it

00:27:56,640 --> 00:28:04,640
will always find the highest match and

00:27:58,680 --> 00:28:08,220
use that and so you're independent of of

00:28:04,640 --> 00:28:10,590
actual changes like if we're if I don't

00:28:08,220 --> 00:28:13,080
know if you're not the developer and

00:28:10,590 --> 00:28:15,630
someone else changes the website and the

00:28:13,080 --> 00:28:17,970
ID changes and your test breaks

00:28:15,630 --> 00:28:22,880
this can't happen again anymore with

00:28:17,970 --> 00:28:25,470
that and also you can use it instead of

00:28:22,880 --> 00:28:27,840
cumbersome selectors like there's a

00:28:25,470 --> 00:28:31,920
problem that some elements don't have

00:28:27,840 --> 00:28:34,440
IDs then you are you know you use a

00:28:31,920 --> 00:28:39,390
fallback of going to the xpath or going

00:28:34,440 --> 00:28:41,760
to like in that case very complex CSS

00:28:39,390 --> 00:28:46,290
selector and instead of that you can

00:28:41,760 --> 00:28:48,810
just use a very easy to use retest ID

00:28:46,290 --> 00:28:51,480
that you can yourself define that you

00:28:48,810 --> 00:28:53,880
can give a meaningful name and that is

00:28:51,480 --> 00:28:55,620
independent of any change and you don't

00:28:53,880 --> 00:28:57,360
have to go to another developer that's

00:28:55,620 --> 00:28:59,670
maintaining that part of the code and

00:28:57,360 --> 00:29:02,190
say please please PLEASE insert an ID

00:28:59,670 --> 00:29:05,010
for me that I can you know reference

00:29:02,190 --> 00:29:11,910
instead you can do it yourself in the

00:29:05,010 --> 00:29:14,250
copy of the website so the support for

00:29:11,910 --> 00:29:17,000
that to retrieve that ID I have to admit

00:29:14,250 --> 00:29:19,410
is right now not not not ideal so

00:29:17,000 --> 00:29:21,900
because it takes ml you essentially have

00:29:19,410 --> 00:29:24,000
to to search the golden master for the

00:29:21,900 --> 00:29:26,370
element that you want to want to use and

00:29:24,000 --> 00:29:28,650
then just use the retest ID so it's it's

00:29:26,370 --> 00:29:32,400
straightforward but it's not ideal so

00:29:28,650 --> 00:29:34,530
we're working on how to improve that but

00:29:32,400 --> 00:29:39,540
it's a drop-in replacement in your code

00:29:34,530 --> 00:29:42,210
so you can't just using that you can

00:29:39,540 --> 00:29:46,350
just say okay I want to use the retest

00:29:42,210 --> 00:29:48,960
ID and as he saw earlier it's it's a

00:29:46,350 --> 00:29:51,990
generated ID and you can adapt it to any

00:29:48,960 --> 00:29:54,270
value you want but if you don't care

00:29:51,990 --> 00:29:56,910
about it and in that case we're just

00:29:54,270 --> 00:29:59,670
using the actual ID with a with an

00:29:56,910 --> 00:30:00,210
encounter but you can change it any way

00:29:59,670 --> 00:30:02,280
you like

00:30:00,210 --> 00:30:03,960
in if you just have to also change it

00:30:02,280 --> 00:30:11,130
within the golden master and then you

00:30:03,960 --> 00:30:12,330
can reference it and another thing that

00:30:11,130 --> 00:30:14,910
you can do that some of our customers

00:30:12,330 --> 00:30:17,400
did is you now can create data

00:30:14,910 --> 00:30:21,570
independent tests so if you have a

00:30:17,400 --> 00:30:23,490
situation and where you get test data

00:30:21,570 --> 00:30:25,890
from production into your test system

00:30:23,490 --> 00:30:29,140
and that changes like every other week

00:30:25,890 --> 00:30:30,520
and you can create you know

00:30:29,140 --> 00:30:32,290
for that meaningful test for that

00:30:30,520 --> 00:30:36,010
because you can't assert anything if

00:30:32,290 --> 00:30:39,250
your your underlying test database

00:30:36,010 --> 00:30:41,410
changes then you can do that now so the

00:30:39,250 --> 00:30:43,420
the approach for that is that you create

00:30:41,410 --> 00:30:46,000
a test that data independent so you

00:30:43,420 --> 00:30:50,260
don't click on a specific I don't know

00:30:46,000 --> 00:30:52,660
an item or a specific name of a user

00:30:50,260 --> 00:30:55,480
instead you click on the first user or

00:30:52,660 --> 00:30:57,550
on the first item and program your test

00:30:55,480 --> 00:30:59,860
in that road in that way and then what

00:30:57,550 --> 00:31:03,010
you can do is you flip out the database

00:30:59,860 --> 00:31:04,900
you throw away you go to masters you let

00:31:03,010 --> 00:31:07,660
the test run create the golden masters

00:31:04,900 --> 00:31:09,940
and with a new data and then you

00:31:07,660 --> 00:31:12,310
exchange your code and let the test run

00:31:09,940 --> 00:31:14,410
with a new data with a new code and see

00:31:12,310 --> 00:31:16,900
whether the new code behaved any

00:31:14,410 --> 00:31:20,260
differently than the previous code in

00:31:16,900 --> 00:31:22,600
previous version of the software so the

00:31:20,260 --> 00:31:24,520
benefits of recheck to summarize it

00:31:22,600 --> 00:31:28,480
gives you rule-based deterministic

00:31:24,520 --> 00:31:31,030
ignore so you don't need any like with

00:31:28,480 --> 00:31:33,190
pixels you don't need to ignore parts of

00:31:31,030 --> 00:31:35,260
the image you don't need to use AI or

00:31:33,190 --> 00:31:36,820
any other stuff it's a deterministic

00:31:35,260 --> 00:31:39,280
ignore of what you what you're not

00:31:36,820 --> 00:31:41,680
interested in it's open source you can

00:31:39,280 --> 00:31:44,650
use it offline it's it gives you

00:31:41,680 --> 00:31:47,380
unbreakable selenium and in theory it

00:31:44,650 --> 00:31:49,420
works for any technical interface so we

00:31:47,380 --> 00:31:52,480
started off with implementing it for

00:31:49,420 --> 00:31:54,550
Java for selenium and but next thing we

00:31:52,480 --> 00:31:56,980
do is implementing it for JavaScript and

00:31:54,550 --> 00:31:59,020
then it can be integrated into say

00:31:56,980 --> 00:32:01,210
Cypress or other JavaScript based

00:31:59,020 --> 00:32:03,460
testing frameworks and but you could

00:32:01,210 --> 00:32:05,440
this the same approach could be used for

00:32:03,460 --> 00:32:08,850
XML for chasten for any technical

00:32:05,440 --> 00:32:11,620
interface you have and for any data

00:32:08,850 --> 00:32:14,620
technical data that that you generate

00:32:11,620 --> 00:32:16,660
that you interface with and using the

00:32:14,620 --> 00:32:20,200
same ignore mechanism for instance to to

00:32:16,660 --> 00:32:22,150
ignore timestamps or ignore I don't know

00:32:20,200 --> 00:32:25,210
parts of the data yet that you're not

00:32:22,150 --> 00:32:27,220
interested in people like it so far

00:32:25,210 --> 00:32:30,880
I mean it's not that widespread and it's

00:32:27,220 --> 00:32:35,230
very fresh what I showed you is like 12

00:32:30,880 --> 00:32:37,060
weeks old so it's not exactly widespread

00:32:35,230 --> 00:32:39,250
technology yet but we're working on that

00:32:37,060 --> 00:32:42,210
and you could help us if you give us a

00:32:39,250 --> 00:32:42,210
github star for instance

00:32:42,230 --> 00:32:47,850
as I said it's open source and the

00:32:46,590 --> 00:32:49,800
Chrome extension that I showed you is

00:32:47,850 --> 00:32:51,840
also open source and you very much

00:32:49,800 --> 00:32:55,020
invited to try it and to give us

00:32:51,840 --> 00:32:59,040
feedback on it so that's retest recheck

00:32:55,020 --> 00:33:02,960
web and by the way I'm I will post the

00:32:59,040 --> 00:33:08,790
slides afterwards as on SlideShare and

00:33:02,960 --> 00:33:12,240
distribute via Twitter and to just

00:33:08,790 --> 00:33:14,040
explain what we do and so and the Robi

00:33:12,240 --> 00:33:18,390
GUI that I showed earlier part of that

00:33:14,040 --> 00:33:19,980
is proprietary or part of that is a paid

00:33:18,390 --> 00:33:22,400
solution so if you want to use the GUI

00:33:19,980 --> 00:33:26,310
to maintain your tests this this will be

00:33:22,400 --> 00:33:29,010
come with a slight cost and if you want

00:33:26,310 --> 00:33:33,710
to use the cloud to to store and

00:33:29,010 --> 00:33:36,600
retrieve both the golden masters and the

00:33:33,710 --> 00:33:38,700
reports that are generated and then this

00:33:36,600 --> 00:33:41,130
or if you want to use the cloud to you

00:33:38,700 --> 00:33:43,860
know collaborate in teams then this is

00:33:41,130 --> 00:33:46,650
also something that that we are making

00:33:43,860 --> 00:33:48,270
money with and but if you have a open

00:33:46,650 --> 00:33:50,190
source project and you want to use this

00:33:48,270 --> 00:33:52,230
for open source and it's free to use for

00:33:50,190 --> 00:33:53,910
open source so if you have like I don't

00:33:52,230 --> 00:33:55,410
know if you're the maintainer of an open

00:33:53,910 --> 00:33:58,020
source project you can just go and use

00:33:55,410 --> 00:34:00,570
that and the very interesting thing is

00:33:58,020 --> 00:34:03,630
that this is an enabling technology so

00:34:00,570 --> 00:34:06,120
the reason we implemented that is not

00:34:03,630 --> 00:34:08,520
because we thought it was so cool that's

00:34:06,120 --> 00:34:10,500
just what we learned afterwards the

00:34:08,520 --> 00:34:13,050
reason why we implemented this is we

00:34:10,500 --> 00:34:16,679
need it for AI based test generation so

00:34:13,050 --> 00:34:19,639
this is where we come from we implement

00:34:16,679 --> 00:34:22,500
technology that generates a I based

00:34:19,639 --> 00:34:25,320
generates tests for your applications in

00:34:22,500 --> 00:34:28,260
that case for your website so if you

00:34:25,320 --> 00:34:30,690
that's right now close better so but if

00:34:28,260 --> 00:34:35,429
you're interested in that just contact

00:34:30,690 --> 00:34:42,210
us and we'll be happy to - yeah keep you

00:34:35,429 --> 00:34:46,260
posted so yeah to wrap up and I think

00:34:42,210 --> 00:34:50,340
you should use that I think it's

00:34:46,260 --> 00:34:54,090
probably better it gives you the

00:34:50,340 --> 00:34:55,800
possibility to find differences and it's

00:34:54,090 --> 00:34:57,180
even you know you can even use

00:34:55,800 --> 00:34:59,340
for cross-browser testing cross-device

00:34:57,180 --> 00:35:02,190
testing stuff like that although the

00:34:59,340 --> 00:35:05,550
original intent was to use it for

00:35:02,190 --> 00:35:07,890
functional testing we have it wait we

00:35:05,550 --> 00:35:10,410
have made an effort to make it easy to

00:35:07,890 --> 00:35:13,320
create and maintain the vague nor files

00:35:10,410 --> 00:35:16,170
and to make that a very powerful

00:35:13,320 --> 00:35:18,930
approach so that you can easily ignore

00:35:16,170 --> 00:35:21,210
stuff that you're not interested in and

00:35:18,930 --> 00:35:23,190
it helps you create easy easily create

00:35:21,210 --> 00:35:25,860
tests and easily maintain the tests

00:35:23,190 --> 00:35:28,530
because as I said what we're working on

00:35:25,860 --> 00:35:30,750
right now is Auto healing the tests so

00:35:28,530 --> 00:35:34,080
once you say that you want to apply a

00:35:30,750 --> 00:35:35,700
change with the CLI or with the GUI you

00:35:34,080 --> 00:35:38,280
can say that you want to apply that to

00:35:35,700 --> 00:35:42,290
the code as well and we will fix the

00:35:38,280 --> 00:35:45,030
test for you before it breaks so yeah

00:35:42,290 --> 00:35:48,570
thank you very much as I said please

00:35:45,030 --> 00:35:51,870
star us on github and here are free

00:35:48,570 --> 00:35:52,580
stickers if anybody wants some thank you

00:35:51,870 --> 00:35:59,490
very much

00:35:52,580 --> 00:36:07,180
[Applause]

00:35:59,490 --> 00:36:08,440
are there any questions yeah whether the

00:36:07,180 --> 00:36:11,710
question was whether we have a separate

00:36:08,440 --> 00:36:14,320
ignore file per test this is a pending

00:36:11,710 --> 00:36:17,380
pull request so we will in we will have

00:36:14,320 --> 00:36:30,700
that with the next release and any other

00:36:17,380 --> 00:36:32,710
questions yeah yes so we have an proof

00:36:30,700 --> 00:36:34,630
of concept implementation so I wouldn't

00:36:32,710 --> 00:36:37,240
say it's production-ready but we have a

00:36:34,630 --> 00:36:39,850
proof of concept exam l implementation

00:36:37,240 --> 00:36:42,940
for XML and it works just fine so you

00:36:39,850 --> 00:36:45,550
can using the same mechanisms that I

00:36:42,940 --> 00:36:47,860
showed you can ignore timestamps you can

00:36:45,550 --> 00:36:52,720
ignore data parts of the XML that you're

00:36:47,860 --> 00:36:55,090
interested in and yeah it shouldn't

00:36:52,720 --> 00:36:57,070
matter so as we said as I said we we

00:36:55,090 --> 00:36:59,560
make a one on one assignment of all the

00:36:57,070 --> 00:37:02,350
elements also in the XML and so if the

00:36:59,560 --> 00:37:05,110
order changes of the XML elements it

00:37:02,350 --> 00:37:08,380
will try to if there's enough context

00:37:05,110 --> 00:37:10,560
like if they have enough data to to make

00:37:08,380 --> 00:37:12,760
that assignment then it should work okay

00:37:10,560 --> 00:37:22,450
thank you any more time any more

00:37:12,760 --> 00:37:24,580
questions sorry at the time line and so

00:37:22,450 --> 00:37:27,160
the question was about the timelines of

00:37:24,580 --> 00:37:29,590
Cyprus integration and so we're actively

00:37:27,160 --> 00:37:31,390
working on that and so it's not

00:37:29,590 --> 00:37:33,070
something that will happen you know in

00:37:31,390 --> 00:37:35,230
half a year it's something that will

00:37:33,070 --> 00:37:37,210
happen in the coming weeks or months so

00:37:35,230 --> 00:37:39,220
we're working on that I have no idea how

00:37:37,210 --> 00:37:42,190
long it will take so I'm not making any

00:37:39,220 --> 00:37:47,160
promises here but we're working on it

00:37:42,190 --> 00:37:47,160
right right now any other questions

00:37:53,130 --> 00:37:57,270
and sorry can you repeat the last part

00:38:00,450 --> 00:38:11,079
yeah okay

00:38:08,910 --> 00:38:12,520
so the question was whether how this

00:38:11,079 --> 00:38:14,619
integrates with pull requests when we

00:38:12,520 --> 00:38:16,569
update the golden masters and the golden

00:38:14,619 --> 00:38:19,599
masters are essentially XML files

00:38:16,569 --> 00:38:22,930
and they are stored locally and so you

00:38:19,599 --> 00:38:25,359
can just commit them and since it's XML

00:38:22,930 --> 00:38:27,970
it works with merging and and all the

00:38:25,359 --> 00:38:31,119
you know standard get and and and

00:38:27,970 --> 00:38:34,720
workflow mechanisms and you can if you

00:38:31,119 --> 00:38:38,020
apply a change to the gold masters I'm

00:38:34,720 --> 00:38:40,630
using the CLI for instance then as I

00:38:38,020 --> 00:38:42,250
showed it will apply if you don't

00:38:40,630 --> 00:38:44,829
exclude like if you apply all the

00:38:42,250 --> 00:38:47,380
changes it will update all the the

00:38:44,829 --> 00:38:49,180
golden masters according to to the

00:38:47,380 --> 00:38:51,780
changes that have been made does it

00:38:49,180 --> 00:38:51,780
answer the question

00:39:01,320 --> 00:39:08,680
okay so it I mean we're working on that

00:39:05,980 --> 00:39:12,640
as I said one of the things we offer is

00:39:08,680 --> 00:39:14,950
storing the golden masters and pull the

00:39:12,640 --> 00:39:17,800
reports for you and then in that regard

00:39:14,950 --> 00:39:22,510
in that case it would still be one line

00:39:17,800 --> 00:39:23,490
of change and we're right now thinking

00:39:22,510 --> 00:39:26,790
about for instance the github

00:39:23,490 --> 00:39:30,460
integration where you would have to

00:39:26,790 --> 00:39:32,580
approve the changes and then the the

00:39:30,460 --> 00:39:36,310
github the pull request would be only

00:39:32,580 --> 00:39:38,140
impossible to merge if there are no more

00:39:36,310 --> 00:39:39,730
differences and but that's not

00:39:38,140 --> 00:39:41,800
implemented yet so we're working on that

00:39:39,730 --> 00:39:44,859
it's as I said it's it's still early

00:39:41,800 --> 00:39:48,849
phase kind of so what I showed you is

00:39:44,859 --> 00:39:51,220
all working but yeah that is something

00:39:48,849 --> 00:39:58,240
to implement in the future and any more

00:39:51,220 --> 00:40:00,760
questions yeah and when so the the core

00:39:58,240 --> 00:40:03,340
part the the core technology is now

00:40:00,760 --> 00:40:05,500
implemented in JavaScript and that that

00:40:03,340 --> 00:40:11,050
extracts all the data from the website

00:40:05,500 --> 00:40:15,760
and sends it off to to a Java recipient

00:40:11,050 --> 00:40:18,880
service and having extracted that it

00:40:15,760 --> 00:40:21,580
should now be very easy to port that to

00:40:18,880 --> 00:40:22,630
other languages the first obviously the

00:40:21,580 --> 00:40:26,170
first language we're working on is

00:40:22,630 --> 00:40:28,450
JavaScript have it integrated into

00:40:26,170 --> 00:40:30,670
existing JavaScript frameworks like

00:40:28,450 --> 00:40:33,420
Cypress and but the next step afterwards

00:40:30,670 --> 00:40:38,349
I would be to call the JavaScript from

00:40:33,420 --> 00:40:41,680
Python Ruby and and stuff like that so

00:40:38,349 --> 00:40:46,140
it's it's on the roadmap but yeah takes

00:40:41,680 --> 00:40:46,140
might take awhile so there yeah

00:40:56,710 --> 00:41:02,270
that's a very good question so the

00:40:59,810 --> 00:41:04,609
question was if there's a substantial

00:41:02,270 --> 00:41:07,070
change to the element we have an

00:41:04,609 --> 00:41:13,010
internal threshold that you can set and

00:41:07,070 --> 00:41:14,869
if the if it like if the the element is

00:41:13,010 --> 00:41:18,890
is more different than the threshold

00:41:14,869 --> 00:41:21,020
allows then we will not map it but it's

00:41:18,890 --> 00:41:22,730
it's kind of a hard problem like even

00:41:21,020 --> 00:41:25,280
for a human if you have a website and

00:41:22,730 --> 00:41:26,480
and you have a button that disappears

00:41:25,280 --> 00:41:29,060
here and another button that appears

00:41:26,480 --> 00:41:31,580
here at one point is it the same pattern

00:41:29,060 --> 00:41:34,130
and at one point it's not so it's it's

00:41:31,580 --> 00:41:37,040
kind of a gray lis gray area so it's not

00:41:34,130 --> 00:41:38,690
a it's a hard problem and right now as I

00:41:37,040 --> 00:41:40,330
said we solve it with our threshold so

00:41:38,690 --> 00:41:43,910
if it's right now if it's 70 percent

00:41:40,330 --> 00:41:46,670
overlap of attributes then we assume

00:41:43,910 --> 00:41:50,000
it's the same element still and if not

00:41:46,670 --> 00:41:54,290
then we then we say we don't we don't

00:41:50,000 --> 00:41:59,770
assign it but yeah yeah that's

00:41:54,290 --> 00:41:59,770
configurable so any more questions yeah

00:42:05,609 --> 00:42:10,750
and so the question was whether we can

00:42:08,770 --> 00:42:18,730
check for an array of objects inside a

00:42:10,750 --> 00:42:22,150
list so so what we do right now is you

00:42:18,730 --> 00:42:24,250
check either the complete website or you

00:42:22,150 --> 00:42:25,869
give it individual and like if you have

00:42:24,250 --> 00:42:27,609
an element a component based approach

00:42:25,869 --> 00:42:29,560
then you can check individual web

00:42:27,609 --> 00:42:32,530
elements you can say I want to I want to

00:42:29,560 --> 00:42:34,960
test I don't know that a drop-down list

00:42:32,530 --> 00:42:36,940
for instance and then we would assign

00:42:34,960 --> 00:42:38,470
then would check every element that's

00:42:36,940 --> 00:42:40,750
contained in the in the drop-down list

00:42:38,470 --> 00:42:43,210
even if it doesn't display like if it's

00:42:40,750 --> 00:42:46,060
if it's not you know if no one has

00:42:43,210 --> 00:42:48,250
clicked on it so it's not opened but but

00:42:46,060 --> 00:42:50,890
containing the HTML and then we would

00:42:48,250 --> 00:42:52,240
check for that does it answer the

00:42:50,890 --> 00:43:11,050
question okay

00:42:52,240 --> 00:43:12,640
any more questions yeah so essentially

00:43:11,050 --> 00:43:14,830
the web the question was whether I need

00:43:12,640 --> 00:43:17,520
to create a golden master for different

00:43:14,830 --> 00:43:20,109
permutations and the short answer is yes

00:43:17,520 --> 00:43:23,619
but you can do that explicitly so what I

00:43:20,109 --> 00:43:25,720
showed here is an implicit creation so

00:43:23,619 --> 00:43:28,570
this this recheck driver creates a

00:43:25,720 --> 00:43:32,020
golden master after every action so if

00:43:28,570 --> 00:43:34,780
you say get if you say if send Keys send

00:43:32,020 --> 00:43:37,210
keys and click and then these results in

00:43:34,780 --> 00:43:41,710
four golden masters but you can do so

00:43:37,210 --> 00:43:44,849
also explicitly so there's there's a API

00:43:41,710 --> 00:43:49,140
a different API where you just use your

00:43:44,849 --> 00:43:51,520
neutral chrome driver and use a recheck

00:43:49,140 --> 00:43:56,250
implementation and then you can call

00:43:51,520 --> 00:44:02,349
explicitly for the for the creation and

00:43:56,250 --> 00:44:05,500
comparison of the golden master sorry so

00:44:02,349 --> 00:44:07,330
in that in that way you can reduce the

00:44:05,500 --> 00:44:10,660
amount of golden masters that are being

00:44:07,330 --> 00:44:13,180
created and what you do is here you give

00:44:10,660 --> 00:44:17,170
it a semantic name and it will compare

00:44:13,180 --> 00:44:18,040
to that semantic name so what you for

00:44:17,170 --> 00:44:19,750
instance if you wanna do

00:44:18,040 --> 00:44:22,770
protesting you would create you would

00:44:19,750 --> 00:44:27,100
refer to the same name from a different

00:44:22,770 --> 00:44:29,170
test or from a different operating

00:44:27,100 --> 00:44:30,700
system of stuff and and then you would

00:44:29,170 --> 00:44:33,790
see the differences to that that's that

00:44:30,700 --> 00:44:39,430
answer the question yeah okay any any

00:44:33,790 --> 00:44:41,710
more questions okay so thank you very

00:44:39,430 --> 00:44:44,080
much for having me and thanks for

00:44:41,710 --> 00:44:47,830
attending and have a good safe trip home

00:44:44,080 --> 00:44:47,830
[Applause]

00:44:50,650 --> 00:44:53,780

YouTube URL: https://www.youtube.com/watch?v=2CGu7vNVY00


