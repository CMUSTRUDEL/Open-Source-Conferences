Title: All Things Open 2018 - Brian Platz, Fluree, PBC - Building Blockchain Apps for the Enterprise
Publication date: 2018-12-05
Playlist: All Things Open 2018 Playlist
Description: 
	All Things Open 2018 - Brian Platz, Fluree, PBC - Building Blockchain Apps for the Enterprise
Captions: 
	00:00:02,419 --> 00:00:06,960
this also isn't like a super-advanced

00:00:05,160 --> 00:00:09,000
course either it's kind of kind of like

00:00:06,960 --> 00:00:12,290
Goldilocks it's right in the middle

00:00:09,000 --> 00:00:16,109
there so we'll be covering primarily

00:00:12,290 --> 00:00:18,300
three things one is some of the

00:00:16,109 --> 00:00:21,270
considerations or what to pay attention

00:00:18,300 --> 00:00:22,980
to and what not to pay attention to when

00:00:21,270 --> 00:00:25,650
you're looking to build an enterprise

00:00:22,980 --> 00:00:27,269
blockchain app so what are some of the

00:00:25,650 --> 00:00:28,710
characteristics what are some of the

00:00:27,269 --> 00:00:31,349
trade-offs and what are some of the

00:00:28,710 --> 00:00:34,260
things you can just ignore I will talk a

00:00:31,349 --> 00:00:36,630
little bit about data and how to manage

00:00:34,260 --> 00:00:38,790
data this is one of the issues that I

00:00:36,630 --> 00:00:41,450
think is most plaguing to kind of

00:00:38,790 --> 00:00:42,629
building enterprise blockchain APS's

00:00:41,450 --> 00:00:45,870
blockchains

00:00:42,629 --> 00:00:48,629
or applications in particular involve a

00:00:45,870 --> 00:00:50,460
lot more things going on than kind of

00:00:48,629 --> 00:00:52,860
where the blockchain piece fits in so

00:00:50,460 --> 00:00:55,620
how do we help coordinate all that and

00:00:52,860 --> 00:00:57,960
we'll talk a little bit about maybe some

00:00:55,620 --> 00:01:01,859
considerations is to where things are

00:00:57,960 --> 00:01:03,840
going so I am I'm with flurry DB we're a

00:01:01,859 --> 00:01:06,450
North Carolina company we're up in

00:01:03,840 --> 00:01:08,490
winston-salem and we're not going to

00:01:06,450 --> 00:01:09,510
really talk it'll come up a couple times

00:01:08,490 --> 00:01:12,630
we're not going to talk much about

00:01:09,510 --> 00:01:14,430
flurry but it's a database blockchain

00:01:12,630 --> 00:01:15,509
product that we have been working on for

00:01:14,430 --> 00:01:18,180
about four years

00:01:15,509 --> 00:01:20,180
I'm the co CEO a little bit about me

00:01:18,180 --> 00:01:23,490
I've been building enterprise software

00:01:20,180 --> 00:01:25,860
for about 25 years the other co CEO is

00:01:23,490 --> 00:01:29,909
Flip Phillip hausky a good friend of

00:01:25,860 --> 00:01:32,159
mine and we have built a good number of

00:01:29,909 --> 00:01:35,189
companies had a couple public offerings

00:01:32,159 --> 00:01:38,479
so far to date but as I guess we'd both

00:01:35,189 --> 00:01:40,350
be quick to say in this industry

00:01:38,479 --> 00:01:43,350
probably what you've done in the last

00:01:40,350 --> 00:01:47,240
three or so months is all that really

00:01:43,350 --> 00:01:50,909
matters so I started my career doing

00:01:47,240 --> 00:01:53,820
development and been really just focused

00:01:50,909 --> 00:01:55,829
more in the business aspect but when we

00:01:53,820 --> 00:01:57,840
started flurry about four years ago it

00:01:55,829 --> 00:02:00,210
really drew me back into the development

00:01:57,840 --> 00:02:01,920
side it kind of got me to geek out a bit

00:02:00,210 --> 00:02:05,159
about blockchain

00:02:01,920 --> 00:02:06,600
I love blockchain because the most

00:02:05,159 --> 00:02:09,090
interesting and I think challenging

00:02:06,600 --> 00:02:10,950
parts of computing or at least that draw

00:02:09,090 --> 00:02:13,080
to me are distributed computing and

00:02:10,950 --> 00:02:17,040
cryptography and this is just a

00:02:13,080 --> 00:02:18,030
incredible mashup of the two and you

00:02:17,040 --> 00:02:20,310
know you just have to deal with

00:02:18,030 --> 00:02:21,750
adversaries so much more in this space

00:02:20,310 --> 00:02:25,550
than you do in typical enterprise

00:02:21,750 --> 00:02:29,970
computing so for me that's very exciting

00:02:25,550 --> 00:02:33,240
so to get things started I figured we

00:02:29,970 --> 00:02:36,300
would talk about things we hear about

00:02:33,240 --> 00:02:38,700
blockchain determine whether they're

00:02:36,300 --> 00:02:41,010
true or not or determine if they even

00:02:38,700 --> 00:02:44,280
matter when we're building enterprise

00:02:41,010 --> 00:02:45,390
applications so I've put together a

00:02:44,280 --> 00:02:48,750
couple questions

00:02:45,390 --> 00:02:49,950
black chains doesn't matter that they're

00:02:48,750 --> 00:02:51,510
bad for the environment

00:02:49,950 --> 00:02:54,540
does anyone think they're bad for the

00:02:51,510 --> 00:02:56,160
environment some people I hear this all

00:02:54,540 --> 00:02:57,270
the time it's maybe we shouldn't use

00:02:56,160 --> 00:02:59,750
black chains it's bad for the

00:02:57,270 --> 00:03:02,430
environment I think in an enterprise

00:02:59,750 --> 00:03:04,380
black chain implementation this probably

00:03:02,430 --> 00:03:05,910
doesn't matter a whole lot because this

00:03:04,380 --> 00:03:07,860
primarily focuses around the

00:03:05,910 --> 00:03:11,730
proof-of-work algorithm which Bitcoin of

00:03:07,860 --> 00:03:14,430
course uses but most enterprise

00:03:11,730 --> 00:03:16,260
blockchain implementations depending on

00:03:14,430 --> 00:03:18,810
what you're using you're probably not

00:03:16,260 --> 00:03:21,630
damaging the environment any more than

00:03:18,810 --> 00:03:24,930
just running normal servers so this

00:03:21,630 --> 00:03:27,300
probably doesn't matter black chains

00:03:24,930 --> 00:03:29,970
they're just big slow databases and you

00:03:27,300 --> 00:03:32,190
know everyone's heard about Bitcoin only

00:03:29,970 --> 00:03:33,180
doing three or seven transactions per

00:03:32,190 --> 00:03:38,209
second

00:03:33,180 --> 00:03:40,680
is it true yeah you know to a degree

00:03:38,209 --> 00:03:42,180
again when we talk about black chain I

00:03:40,680 --> 00:03:44,310
think I don't know if anyone saw Amber's

00:03:42,180 --> 00:03:46,590
talk but she did a good job of kind of

00:03:44,310 --> 00:03:48,750
introducing all these slices that people

00:03:46,590 --> 00:03:52,470
are thinking about black chain problems

00:03:48,750 --> 00:03:55,080
around and when you come from it from a

00:03:52,470 --> 00:03:57,600
certain angle you have a perspective of

00:03:55,080 --> 00:04:00,330
exactly how black chains being used and

00:03:57,600 --> 00:04:02,269
if you're thinking about Bitcoin then in

00:04:00,330 --> 00:04:05,760
fact both of these statements are true

00:04:02,269 --> 00:04:07,560
but most of the technologies that we're

00:04:05,760 --> 00:04:08,730
using don't have these characteristics

00:04:07,560 --> 00:04:11,160
so they're not things we particularly

00:04:08,730 --> 00:04:12,840
have to worry about our black chains

00:04:11,160 --> 00:04:17,010
slower yeah I mean you know one of the

00:04:12,840 --> 00:04:18,540
things that is important to at least get

00:04:17,010 --> 00:04:20,310
your head around a little bit when we're

00:04:18,540 --> 00:04:22,200
used to building enterprise applications

00:04:20,310 --> 00:04:24,210
we're used to scaling out you know our

00:04:22,200 --> 00:04:26,550
app tier layer and we put a load

00:04:24,210 --> 00:04:28,919
balancer in front of it and we of course

00:04:26,550 --> 00:04:31,229
want a request to go in and one server

00:04:28,919 --> 00:04:34,080
to process that business logic and give

00:04:31,229 --> 00:04:35,640
us a result and the you know black

00:04:34,080 --> 00:04:37,169
chains are almost the opposite of that

00:04:35,640 --> 00:04:39,270
it's like putting a load balancer in

00:04:37,169 --> 00:04:41,310
front of it except every server needs to

00:04:39,270 --> 00:04:43,229
process every single request and then

00:04:41,310 --> 00:04:44,970
talk to each other and make sure they

00:04:43,229 --> 00:04:47,940
come up with an agreement so that does

00:04:44,970 --> 00:04:50,580
slow things down but three transactions

00:04:47,940 --> 00:04:52,560
per second you know we have technologies

00:04:50,580 --> 00:04:56,190
out there now claiming you know in the

00:04:52,560 --> 00:04:59,669
case of the dag technologies like hash

00:04:56,190 --> 00:05:01,500
graph claiming 250,000 transactions per

00:04:59,669 --> 00:05:04,410
second when we're building an enterprise

00:05:01,500 --> 00:05:06,150
app sometimes these numbers don't even

00:05:04,410 --> 00:05:08,880
matter in fact very often they do my

00:05:06,150 --> 00:05:10,860
last company was a HR software as a

00:05:08,880 --> 00:05:13,620
service company and one of our largest

00:05:10,860 --> 00:05:18,360
customers a fortune 500 customer we ran

00:05:13,620 --> 00:05:20,849
all their HR systems they they did about

00:05:18,360 --> 00:05:22,410
one transaction this doesn't include

00:05:20,849 --> 00:05:24,060
queries you know that's different this

00:05:22,410 --> 00:05:26,880
is just updating data about one

00:05:24,060 --> 00:05:29,160
transaction per minute was the average

00:05:26,880 --> 00:05:32,910
and that's a you know fortune 500

00:05:29,160 --> 00:05:34,650
company all their HR systems so it's a

00:05:32,910 --> 00:05:36,690
matter of perspective what I want to be

00:05:34,650 --> 00:05:38,940
like data dog who I saw their booth

00:05:36,690 --> 00:05:41,220
downstairs trying to ingest billions log

00:05:38,940 --> 00:05:42,840
files and store those in a blockchain no

00:05:41,220 --> 00:05:46,349
you know it's probably a pretty bad

00:05:42,840 --> 00:05:48,330
choice so yeah they're slow but they're

00:05:46,349 --> 00:05:50,039
plenty fast for most of what we want to

00:05:48,330 --> 00:05:51,360
do in the enterprise and a lot of this

00:05:50,039 --> 00:05:53,760
is going to depend on some of the

00:05:51,360 --> 00:05:57,780
consensus mechanisms we choose to focus

00:05:53,760 --> 00:06:00,030
on which we'll talk a little bit black

00:05:57,780 --> 00:06:01,020
chains must be resistant to civil

00:06:00,030 --> 00:06:04,860
attacks

00:06:01,020 --> 00:06:07,200
I would since we're in such a big room I

00:06:04,860 --> 00:06:09,419
would ask people to explain some of this

00:06:07,200 --> 00:06:12,210
but I would just go through a bit of it

00:06:09,419 --> 00:06:14,760
myself to keep things moving so a simple

00:06:12,210 --> 00:06:17,729
attack is where someone impersonates the

00:06:14,760 --> 00:06:19,349
identity of multiple people and of

00:06:17,729 --> 00:06:20,820
course when we think about public black

00:06:19,349 --> 00:06:22,770
chains this is really important because

00:06:20,820 --> 00:06:24,650
the key obviously with the public

00:06:22,770 --> 00:06:27,419
blockchain is that we're not

00:06:24,650 --> 00:06:29,099
constricting the participants in any way

00:06:27,419 --> 00:06:30,870
and when we don't constrict the

00:06:29,099 --> 00:06:32,880
participants we have no idea who the

00:06:30,870 --> 00:06:35,310
participants are so we have to come up

00:06:32,880 --> 00:06:37,569
with consensus mechanisms that deal with

00:06:35,310 --> 00:06:39,369
this problem and

00:06:37,569 --> 00:06:42,819
proof-of-work is a good one proof of

00:06:39,369 --> 00:06:45,639
steak is another one but in an

00:06:42,819 --> 00:06:48,879
enterprise environment in almost all

00:06:45,639 --> 00:06:51,039
cases where we're setting up a black

00:06:48,879 --> 00:06:53,309
chain for a consortium or anything like

00:06:51,039 --> 00:06:56,800
that we know who the participants are so

00:06:53,309 --> 00:06:58,629
this becomes completely irrelevant to us

00:06:56,800 --> 00:07:00,759
in most of these implementations

00:06:58,629 --> 00:07:02,949
we don't care because we control the

00:07:00,759 --> 00:07:04,899
initial access or who's participating

00:07:02,949 --> 00:07:07,509
therefore it's pretty easy to prevent

00:07:04,899 --> 00:07:09,249
civil attacks this one I think's a

00:07:07,509 --> 00:07:12,249
little bit tougher doesn't need to be

00:07:09,249 --> 00:07:14,709
Byzantine fault-tolerant so the

00:07:12,249 --> 00:07:17,589
Byzantine generals problem for those not

00:07:14,709 --> 00:07:20,770
familiar with it it's sort of a mine

00:07:17,589 --> 00:07:24,580
Theory problem that Byzantine generals a

00:07:20,770 --> 00:07:26,409
bunch of them surround a city and they

00:07:24,580 --> 00:07:28,059
all need to decide together whether

00:07:26,409 --> 00:07:30,279
they're gonna attack or retreat because

00:07:28,059 --> 00:07:33,459
of half attack and half retreat they

00:07:30,279 --> 00:07:35,679
would end up getting defeated so the

00:07:33,459 --> 00:07:37,209
problem is is what if there's a traitor

00:07:35,679 --> 00:07:39,189
in the mix what if there's someone

00:07:37,209 --> 00:07:41,080
feeding bad information so you know say

00:07:39,189 --> 00:07:42,849
half say they're gonna attack half say

00:07:41,080 --> 00:07:45,129
they're going to retreat and then the

00:07:42,849 --> 00:07:47,199
last deciding vote tells the first half

00:07:45,129 --> 00:07:49,389
attack and the second half we retreat

00:07:47,199 --> 00:07:50,439
and they would split up the network so

00:07:49,389 --> 00:07:52,869
it's an important characteristic

00:07:50,439 --> 00:07:54,699
especially in full public black chains

00:07:52,869 --> 00:07:57,669
that we need full Byzantine fault

00:07:54,699 --> 00:07:59,399
tolerance but if we are building an

00:07:57,669 --> 00:08:01,449
enterprise app and if that app has

00:07:59,399 --> 00:08:04,719
participants that don't have to fully

00:08:01,449 --> 00:08:06,519
trust each other but they may partially

00:08:04,719 --> 00:08:09,249
trust each other trust each other enough

00:08:06,519 --> 00:08:11,979
to do some degree of business is this

00:08:09,249 --> 00:08:15,249
critical to have in an enterprise black

00:08:11,979 --> 00:08:17,589
chains what we're primarily using in a

00:08:15,249 --> 00:08:19,419
private blockchain we're using the

00:08:17,589 --> 00:08:21,369
algorithm or some derivative of the

00:08:19,419 --> 00:08:23,680
algorithm practical Byzantine fault

00:08:21,369 --> 00:08:25,899
tolerance and so making this decision

00:08:23,680 --> 00:08:28,899
actually adds constraints on your

00:08:25,899 --> 00:08:33,279
network in a sort of your typical pbft

00:08:28,899 --> 00:08:34,959
setup you need to support for the number

00:08:33,279 --> 00:08:38,199
of failures you want to support you need

00:08:34,959 --> 00:08:40,539
three times that plus one computers in

00:08:38,199 --> 00:08:43,029
the network so to support a single

00:08:40,539 --> 00:08:44,680
failure you would need four computers on

00:08:43,029 --> 00:08:46,620
the network to support two failures you

00:08:44,680 --> 00:08:49,029
need seven computers on the network

00:08:46,620 --> 00:08:51,610
Byzantine fault tolerance also involves

00:08:49,029 --> 00:08:53,200
additional sort of technically to

00:08:51,610 --> 00:08:55,540
additional steps over something like

00:08:53,200 --> 00:08:58,690
Paxos or raft which is what a lot of our

00:08:55,540 --> 00:09:01,000
databases and you know zookeeper things

00:08:58,690 --> 00:09:03,339
like these that you've perhaps used are

00:09:01,000 --> 00:09:06,459
using those are really just require

00:09:03,339 --> 00:09:08,740
majority so you know in a raft protocol

00:09:06,459 --> 00:09:10,720
you want to see typically five nodes on

00:09:08,740 --> 00:09:13,269
the network and that allows two failures

00:09:10,720 --> 00:09:15,940
so the same two failures in a pbft

00:09:13,269 --> 00:09:18,550
network you need seven nodes to support

00:09:15,940 --> 00:09:22,360
two failures so if you want to go

00:09:18,550 --> 00:09:26,170
Byzantine fault tolerance you can it's

00:09:22,360 --> 00:09:28,390
gonna allow you to resist people feeding

00:09:26,170 --> 00:09:30,149
misinformation into the network but

00:09:28,390 --> 00:09:33,310
importantly as long as you have a good

00:09:30,149 --> 00:09:35,620
blockchain implementation even if you're

00:09:33,310 --> 00:09:38,170
using something like Paxos a raft that

00:09:35,620 --> 00:09:40,779
isn't Byzantine fault tolerant it's not

00:09:38,170 --> 00:09:42,730
like someone's gonna necessarily fake

00:09:40,779 --> 00:09:44,980
the data but someone can much more

00:09:42,730 --> 00:09:47,290
easily take down the network they can

00:09:44,980 --> 00:09:49,180
manipulate the information but you still

00:09:47,290 --> 00:09:51,370
know who did what you know you still

00:09:49,180 --> 00:09:53,079
have a record of that so it's important

00:09:51,370 --> 00:09:54,490
thing to think about whether or not you

00:09:53,079 --> 00:09:56,079
really need it if you don't need it

00:09:54,490 --> 00:09:57,970
you'll get more redundancy in your

00:09:56,079 --> 00:09:59,410
network for the same number of nodes and

00:09:57,970 --> 00:10:01,089
you actually have a faster network

00:09:59,410 --> 00:10:03,810
because there's a couple less checks

00:10:01,089 --> 00:10:03,810
that need to be done

00:10:05,490 --> 00:10:10,839
so black chains don't have finality

00:10:09,310 --> 00:10:12,310
sometimes I hear people say they have

00:10:10,839 --> 00:10:15,010
finality but for the most part they

00:10:12,310 --> 00:10:17,529
don't enterprise block chains do to a

00:10:15,010 --> 00:10:19,630
degree something using raft or Paxos or

00:10:17,529 --> 00:10:21,910
pbft is going to have some degree of

00:10:19,630 --> 00:10:23,620
finality and finality just means that

00:10:21,910 --> 00:10:25,810
you have some guarantee of when the

00:10:23,620 --> 00:10:27,100
transaction is done and of course when

00:10:25,810 --> 00:10:29,769
we think about building enterprise

00:10:27,100 --> 00:10:31,510
applications this is always just a given

00:10:29,769 --> 00:10:33,370
for us you know if you create an invoice

00:10:31,510 --> 00:10:36,699
in your system or you put in an HR

00:10:33,370 --> 00:10:38,920
record you get back the result from your

00:10:36,699 --> 00:10:41,230
app and of course it's done it can't be

00:10:38,920 --> 00:10:43,149
changed but in the black chain world

00:10:41,230 --> 00:10:44,949
this isn't necessarily the case you

00:10:43,149 --> 00:10:46,750
could have a confirmation of a

00:10:44,949 --> 00:10:50,019
transaction come back and then the case

00:10:46,750 --> 00:10:53,320
that there was a fork or uncle in the

00:10:50,019 --> 00:10:54,820
network then you could be in a situation

00:10:53,320 --> 00:10:56,860
where you thought you had something

00:10:54,820 --> 00:10:58,660
confirmed but you found out ten minutes

00:10:56,860 --> 00:11:01,420
20 minutes 30 minutes later that it

00:10:58,660 --> 00:11:03,760
really didn't happen so it's a difficult

00:11:01,420 --> 00:11:04,899
issue to contend with especially when we

00:11:03,760 --> 00:11:07,930
have to somehow incorporate

00:11:04,899 --> 00:11:09,759
this into enterprise software but it's

00:11:07,930 --> 00:11:11,639
something that can and does happen in

00:11:09,759 --> 00:11:15,430
public blockchains

00:11:11,639 --> 00:11:17,889
so as long as we're doing a private or

00:11:15,430 --> 00:11:19,990
sort of permission blockchain across

00:11:17,889 --> 00:11:21,579
multiple organizations then this

00:11:19,990 --> 00:11:23,980
probably isn't that big of a

00:11:21,579 --> 00:11:25,749
consideration but if you are focused

00:11:23,980 --> 00:11:32,559
more on a public blockchain side it

00:11:25,749 --> 00:11:35,829
likely is or should be so why are we

00:11:32,559 --> 00:11:38,649
doing this to begin with and I think the

00:11:35,829 --> 00:11:41,589
best kind of tip of the iceberg term

00:11:38,649 --> 00:11:46,209
that everything in black chain follows

00:11:41,589 --> 00:11:48,279
off falls off of is around trust and I

00:11:46,209 --> 00:11:49,869
think it's amazing how little you know

00:11:48,279 --> 00:11:52,149
we've we've come up with ways of dealing

00:11:49,869 --> 00:11:54,639
with it but how little we can trust any

00:11:52,149 --> 00:11:59,079
of the information that's actually in

00:11:54,639 --> 00:12:01,029
our systems when we are running into any

00:11:59,079 --> 00:12:03,550
sort of internal system in our business

00:12:01,029 --> 00:12:05,230
are we able to guarantee that a piece of

00:12:03,550 --> 00:12:07,269
data hasn't been tampered with

00:12:05,230 --> 00:12:09,100
whether it was tampered with by someone

00:12:07,269 --> 00:12:11,350
internally or it was tampered with

00:12:09,100 --> 00:12:12,999
because you got hacked and maybe you

00:12:11,350 --> 00:12:15,399
didn't even know it someone changed that

00:12:12,999 --> 00:12:17,679
information the fact is we don't know

00:12:15,399 --> 00:12:19,990
and in fact we have built massive

00:12:17,679 --> 00:12:22,389
industries around the fact that we don't

00:12:19,990 --> 00:12:24,069
actually trust almost any of our

00:12:22,389 --> 00:12:27,040
information and certainly other people

00:12:24,069 --> 00:12:28,899
don't trust us about it and so this is I

00:12:27,040 --> 00:12:31,199
think what we have an opportunity to

00:12:28,899 --> 00:12:34,509
change using blockchain technology I

00:12:31,199 --> 00:12:36,009
like you know we're not usually talking

00:12:34,509 --> 00:12:37,420
about crypto currencies when we're

00:12:36,009 --> 00:12:39,850
talking about an enterprise block chains

00:12:37,420 --> 00:12:43,689
but Bitcoin to me is just this

00:12:39,850 --> 00:12:45,699
phenomenal piece of technology it's this

00:12:43,689 --> 00:12:48,189
right combination of items that came

00:12:45,699 --> 00:12:50,860
together to exhibit these qualities that

00:12:48,189 --> 00:12:53,079
are pretty amazing and when you think

00:12:50,860 --> 00:12:56,319
about what's happening with Bitcoin it

00:12:53,079 --> 00:12:59,470
is the epitome of information security

00:12:56,319 --> 00:13:01,809
we are so used to having our data our

00:12:59,470 --> 00:13:03,459
databases and we put firewalls around

00:13:01,809 --> 00:13:05,529
them and we're trying to do everything

00:13:03,459 --> 00:13:07,660
possible possible to protect that

00:13:05,529 --> 00:13:10,449
information but here's a database

00:13:07,660 --> 00:13:12,160
essentially it's a database that's not

00:13:10,449 --> 00:13:15,009
protected by anything it's out in the

00:13:12,160 --> 00:13:17,230
public network if you could hack it if

00:13:15,009 --> 00:13:18,070
you could do something you would become

00:13:17,230 --> 00:13:19,480
you know

00:13:18,070 --> 00:13:21,220
simply one of the richest people in the

00:13:19,480 --> 00:13:24,010
world I mean there's plenty of incentive

00:13:21,220 --> 00:13:26,950
to hack this thing yet now it's been

00:13:24,010 --> 00:13:28,570
running for ten years and it's never

00:13:26,950 --> 00:13:30,520
been hacked there's no security breaches

00:13:28,570 --> 00:13:32,650
around it I mean you've heard of some

00:13:30,520 --> 00:13:35,950
security breaches but they're not in the

00:13:32,650 --> 00:13:38,170
Bitcoin protocol itself they're in

00:13:35,950 --> 00:13:41,680
people who have set up services around

00:13:38,170 --> 00:13:45,250
the periphery of it but this is pretty

00:13:41,680 --> 00:13:48,310
amazing information security and why

00:13:45,250 --> 00:13:51,070
shouldn't all of our data have that sort

00:13:48,310 --> 00:13:53,890
of integrity I think it should I think

00:13:51,070 --> 00:13:54,790
eventually it well and it can but you

00:13:53,890 --> 00:13:57,130
think about just some of these

00:13:54,790 --> 00:13:59,710
industries that that are it's it because

00:13:57,130 --> 00:14:01,900
we don't trust in our information so

00:13:59,710 --> 00:14:04,930
title industry I think is a great

00:14:01,900 --> 00:14:07,450
example there's 15 billion dollars spent

00:14:04,930 --> 00:14:09,130
annually on the title industry and it's

00:14:07,450 --> 00:14:11,410
because we don't trust our land records

00:14:09,130 --> 00:14:14,110
you know we don't trust that someone

00:14:11,410 --> 00:14:14,830
might not claim that they own a piece of

00:14:14,110 --> 00:14:17,290
property

00:14:14,830 --> 00:14:18,760
15 billion dollar industry and insurance

00:14:17,290 --> 00:14:20,110
that we did you know you're closing out

00:14:18,760 --> 00:14:21,670
a house you just say okay this is

00:14:20,110 --> 00:14:23,230
something I have to do but you don't

00:14:21,670 --> 00:14:25,450
think about why you have to do it the

00:14:23,230 --> 00:14:27,910
reason you have to do it is because we

00:14:25,450 --> 00:14:29,860
don't trust our information the audit

00:14:27,910 --> 00:14:32,200
industry you know huge part of this is

00:14:29,860 --> 00:14:34,900
looking and verifying information and

00:14:32,200 --> 00:14:37,150
data it's about a 210 billion dollar

00:14:34,900 --> 00:14:39,400
industry and of course when we end up

00:14:37,150 --> 00:14:41,950
having problems in the supply chain or

00:14:39,400 --> 00:14:44,740
things happen what it costs our

00:14:41,950 --> 00:14:46,930
businesses is massive and I think the

00:14:44,740 --> 00:14:48,310
key and it's probably hard to see but

00:14:46,930 --> 00:14:52,570
the key is really down here at the

00:14:48,310 --> 00:14:55,930
bottom if we can fully trust the data in

00:14:52,570 --> 00:14:58,510
the integrity of the information then we

00:14:55,930 --> 00:15:00,820
can conduct business even if we don't

00:14:58,510 --> 00:15:02,230
fully trust the other parties so I think

00:15:00,820 --> 00:15:03,760
it also opens up a lot of new

00:15:02,230 --> 00:15:05,020
opportunities for people to start

00:15:03,760 --> 00:15:07,570
working together and these are some of

00:15:05,020 --> 00:15:09,850
the most exciting use cases that I have

00:15:07,570 --> 00:15:11,860
seen around this space exactly exciting

00:15:09,850 --> 00:15:14,740
to me I'll give two examples of a very

00:15:11,860 --> 00:15:17,230
similar one type of use case but two

00:15:14,740 --> 00:15:18,850
different industries one is financial

00:15:17,230 --> 00:15:20,740
services you know they need to go

00:15:18,850 --> 00:15:22,690
through and do on every new account

00:15:20,740 --> 00:15:24,070
holder know your customer and aunt I'm

00:15:22,690 --> 00:15:26,860
under money-laundering

00:15:24,070 --> 00:15:28,240
law checks and of course they don't you

00:15:26,860 --> 00:15:29,600
know it's administrative work for them

00:15:28,240 --> 00:15:32,410
it doesn't really add any value

00:15:29,600 --> 00:15:34,790
so there are multiple startups now I

00:15:32,410 --> 00:15:36,680
know most intimately the one that's

00:15:34,790 --> 00:15:40,250
approached us about using our product

00:15:36,680 --> 00:15:41,899
for it but they want and have some

00:15:40,250 --> 00:15:44,120
endorsement for some of the big banks to

00:15:41,899 --> 00:15:45,410
start working together sharing a

00:15:44,120 --> 00:15:47,449
blockchain network where they're

00:15:45,410 --> 00:15:49,430
actually sharing for this particular

00:15:47,449 --> 00:15:51,829
customer identity I already did

00:15:49,430 --> 00:15:53,660
know your customer check and you can

00:15:51,829 --> 00:15:55,940
still do it if you don't really trust me

00:15:53,660 --> 00:15:57,829
but here's you know proof that I went

00:15:55,940 --> 00:16:00,110
through that and they can start sharing

00:15:57,829 --> 00:16:02,810
some of this administrative tasks a

00:16:00,110 --> 00:16:05,089
similar use case that's come up for a

00:16:02,810 --> 00:16:06,980
start-up recently is in the healthcare

00:16:05,089 --> 00:16:10,240
industry that I think is really exciting

00:16:06,980 --> 00:16:13,160
and it's all around verifying doctors

00:16:10,240 --> 00:16:14,990
and verifying their resumes and their

00:16:13,160 --> 00:16:16,790
credentials this is something that's

00:16:14,990 --> 00:16:18,259
very expensive to do obviously it's

00:16:16,790 --> 00:16:20,990
pretty critical the hospital would be

00:16:18,259 --> 00:16:22,670
enormous ly liable and in a lot of

00:16:20,990 --> 00:16:24,470
trouble if they had a doctor in there

00:16:22,670 --> 00:16:27,050
that didn't really do the things they

00:16:24,470 --> 00:16:28,970
claimed they did but here's an

00:16:27,050 --> 00:16:31,190
opportunity to potentially have multiple

00:16:28,970 --> 00:16:33,680
hospitals who technically are

00:16:31,190 --> 00:16:35,389
competitors with each other but actually

00:16:33,680 --> 00:16:37,459
start to share some of the same

00:16:35,389 --> 00:16:38,930
credentialing information for doctors so

00:16:37,459 --> 00:16:40,880
they don't need to go through the full

00:16:38,930 --> 00:16:42,740
lengthy and costly process every time

00:16:40,880 --> 00:16:45,170
they can actually have checkpoints that

00:16:42,740 --> 00:16:47,750
they can share and get doctors

00:16:45,170 --> 00:16:49,610
practicing in their hospitals quicker so

00:16:47,750 --> 00:16:51,560
both of these are examples of you know

00:16:49,610 --> 00:16:53,360
competitors actually starting to do more

00:16:51,560 --> 00:16:55,819
and more business together because they

00:16:53,360 --> 00:17:00,100
can trust the information and the use

00:16:55,819 --> 00:17:03,860
cases obviously extend well beyond that

00:17:00,100 --> 00:17:06,079
so where does this trust come from these

00:17:03,860 --> 00:17:08,270
are kind of the five key things that

00:17:06,079 --> 00:17:12,169
black chain brings they don't all have

00:17:08,270 --> 00:17:13,669
to exist but if they all don't exist

00:17:12,169 --> 00:17:15,679
there's some trade-offs to be made but

00:17:13,669 --> 00:17:17,299
you can get some of the benefits without

00:17:15,679 --> 00:17:18,980
these existing you can get a lot of

00:17:17,299 --> 00:17:20,720
black chain benefits without even using

00:17:18,980 --> 00:17:22,909
a black chain you know this isn't again

00:17:20,720 --> 00:17:24,949
completely like new technology that

00:17:22,909 --> 00:17:26,900
didn't exist before Bitcoin it's mostly

00:17:24,949 --> 00:17:29,240
technology we've been using a long time

00:17:26,900 --> 00:17:31,220
just combined in some kind of new and

00:17:29,240 --> 00:17:34,640
interesting ways but of course we have

00:17:31,220 --> 00:17:37,850
decentralization of control the idea

00:17:34,640 --> 00:17:40,549
that the information is immutable that

00:17:37,850 --> 00:17:42,929
you're keeping a record of everything so

00:17:40,549 --> 00:17:44,669
that you can go back and replay that and

00:17:42,929 --> 00:17:46,619
make sure that you catch up with the

00:17:44,669 --> 00:17:49,440
current time and that everything is in

00:17:46,619 --> 00:17:51,210
valid that we have some degree of tamper

00:17:49,440 --> 00:17:53,070
resistance that the information is

00:17:51,210 --> 00:17:56,070
validated and portly there's a set of

00:17:53,070 --> 00:17:59,940
rules there and transparency of the

00:17:56,070 --> 00:18:01,769
information so it's pretty key so this

00:17:59,940 --> 00:18:03,720
is you know it's probably a somewhat

00:18:01,769 --> 00:18:06,299
biased grid of thinking about some of

00:18:03,720 --> 00:18:08,759
these technologies because of course

00:18:06,299 --> 00:18:10,740
flurry sorta sits sits off to the right

00:18:08,759 --> 00:18:12,480
but this is a couple dimensions sort of

00:18:10,740 --> 00:18:15,720
one of my perspectives on the market

00:18:12,480 --> 00:18:17,519
there's several but when you're trying

00:18:15,720 --> 00:18:20,009
to place the vendors because we here are

00:18:17,519 --> 00:18:23,190
so many vendors this helps me at least

00:18:20,009 --> 00:18:25,740
understand where they tend to focus so

00:18:23,190 --> 00:18:29,220
on one axis here I have data flexibility

00:18:25,740 --> 00:18:32,070
so in in this corner would be things

00:18:29,220 --> 00:18:33,869
that have no data flexibility very fixed

00:18:32,070 --> 00:18:36,119
type of information that we're tracking

00:18:33,869 --> 00:18:38,850
and dealing with and of course bitcoins

00:18:36,119 --> 00:18:40,919
you know a great example there are ways

00:18:38,850 --> 00:18:42,929
of jamming like custom data in the

00:18:40,919 --> 00:18:44,909
Bitcoin there's a kind of special field

00:18:42,929 --> 00:18:47,039
called op return that you can stick

00:18:44,909 --> 00:18:49,080
about 80 bytes of information and if you

00:18:47,039 --> 00:18:50,970
want to and if you want to pay extra for

00:18:49,080 --> 00:18:54,419
that transaction but for the most part

00:18:50,970 --> 00:18:56,429
bitcoin is very single purpose you know

00:18:54,419 --> 00:18:59,159
it stores what it stores to do the job

00:18:56,429 --> 00:19:01,529
it needs to do and on the Left access we

00:18:59,159 --> 00:19:03,509
have rules rule flexibility and this is

00:19:01,529 --> 00:19:07,080
you know smart contracts or that sort of

00:19:03,509 --> 00:19:10,980
capability so how much can you start to

00:19:07,080 --> 00:19:13,440
change and manipulate the rules so most

00:19:10,980 --> 00:19:15,629
of our initial blockchain use cases of

00:19:13,440 --> 00:19:17,639
course our financial services oriented

00:19:15,629 --> 00:19:19,740
just makes sense

00:19:17,639 --> 00:19:22,429
things like currencies digital

00:19:19,740 --> 00:19:26,129
currencies and digital asset tracking

00:19:22,429 --> 00:19:28,679
digital asset transfers these are just

00:19:26,129 --> 00:19:34,110
initial easy hit it out of the park

00:19:28,679 --> 00:19:35,879
examples so you tend to see them more in

00:19:34,110 --> 00:19:37,860
this single purpose kind of not as

00:19:35,879 --> 00:19:39,629
flexible sort of system and of course we

00:19:37,860 --> 00:19:41,429
have things like hyper ledger fabric

00:19:39,629 --> 00:19:42,990
which allows you to really write a lot

00:19:41,429 --> 00:19:45,710
of your own custom code and start

00:19:42,990 --> 00:19:49,700
defining a lot of those capabilities

00:19:45,710 --> 00:19:53,490
these tend to favor all transactional

00:19:49,700 --> 00:19:55,289
items so I am you know trading us

00:19:53,490 --> 00:19:56,629
security I'm trading a stock I'm

00:19:55,289 --> 00:19:59,549
exchanging money

00:19:56,629 --> 00:20:01,709
and of course over here were a little

00:19:59,549 --> 00:20:05,929
bit more towards how you'd use a normal

00:20:01,709 --> 00:20:10,200
database to track and build up schemas

00:20:05,929 --> 00:20:11,940
so another important dimension that when

00:20:10,200 --> 00:20:13,830
you think about different black chains

00:20:11,940 --> 00:20:15,149
and what they're bringing beyond sort of

00:20:13,830 --> 00:20:17,209
what sort of flexibility or

00:20:15,149 --> 00:20:19,979
customization are you looking for is

00:20:17,209 --> 00:20:24,179
going to be more on the private public

00:20:19,979 --> 00:20:27,379
space so consensus allows us to operate

00:20:24,179 --> 00:20:31,019
in a completely decentralized innate

00:20:27,379 --> 00:20:33,029
manner distributed is also going to use

00:20:31,019 --> 00:20:35,729
consensus we've been using distributed

00:20:33,029 --> 00:20:37,529
for a long time and this is mostly gonna

00:20:35,729 --> 00:20:38,969
change although it doesn't have to but

00:20:37,529 --> 00:20:40,320
it's mostly going to change kind of the

00:20:38,969 --> 00:20:43,200
two spectrums are just going to be

00:20:40,320 --> 00:20:45,269
public and private networks so private

00:20:43,200 --> 00:20:47,940
networks the huge advantage here is that

00:20:45,269 --> 00:20:50,329
you know the participants on the network

00:20:47,940 --> 00:20:52,529
and so all this requires consensus

00:20:50,329 --> 00:20:56,609
obviously the easiest way to get

00:20:52,529 --> 00:20:59,429
consensus is you collect votes majority

00:20:56,609 --> 00:21:01,469
should win unless it's a presidential

00:20:59,429 --> 00:21:04,469
election and then of course majority

00:21:01,469 --> 00:21:06,299
doesn't always win but majority should

00:21:04,469 --> 00:21:07,739
win and that's really what raft and

00:21:06,299 --> 00:21:10,859
paxos do they're just looking for

00:21:07,739 --> 00:21:14,309
majority votes and moving the network

00:21:10,859 --> 00:21:16,499
forward all consensus is doing in this

00:21:14,309 --> 00:21:18,749
case is is just making sure everybody

00:21:16,499 --> 00:21:20,940
has the same state everyone has the same

00:21:18,749 --> 00:21:22,589
log entries the same pieces of

00:21:20,940 --> 00:21:25,109
information otherwise they can't work

00:21:22,589 --> 00:21:26,549
together is you get morning to the

00:21:25,109 --> 00:21:28,109
public networks these are were things

00:21:26,549 --> 00:21:30,719
like proof of work and proof of stake

00:21:28,109 --> 00:21:32,940
are doing could you see proof of work in

00:21:30,719 --> 00:21:34,589
a private network sure I'm not sure

00:21:32,940 --> 00:21:36,599
again proof of work is going to chew up

00:21:34,589 --> 00:21:38,070
Network resources so it's probably not

00:21:36,599 --> 00:21:41,159
going to make sense but it's a perfectly

00:21:38,070 --> 00:21:42,869
valid consensus mechanism proof of stake

00:21:41,159 --> 00:21:44,669
you'll see that a little bit more going

00:21:42,869 --> 00:21:47,489
into the private side proof of authority

00:21:44,669 --> 00:21:49,739
is really just sort of like kind of like

00:21:47,489 --> 00:21:51,599
a username password and of course we

00:21:49,739 --> 00:21:54,989
talked a bit about pbft practical

00:21:51,599 --> 00:21:56,429
Byzantine fault tolerance but when you

00:21:54,989 --> 00:21:58,200
hear people talk about proof of work

00:21:56,429 --> 00:22:01,320
proof of stake and all these sorts of

00:21:58,200 --> 00:22:02,879
consensus mechanisms in that realm

00:22:01,320 --> 00:22:04,440
they're almost always going to be

00:22:02,879 --> 00:22:06,479
talking about public blockchains and

00:22:04,440 --> 00:22:08,029
lots of times in the enterprise we may

00:22:06,479 --> 00:22:13,609
or may not care

00:22:08,029 --> 00:22:14,599
or be using a public blockchain all

00:22:13,609 --> 00:22:16,359
right so if we're gonna build an

00:22:14,599 --> 00:22:18,710
enterprise app kind of how does

00:22:16,359 --> 00:22:20,629
blockchain technology typically fit into

00:22:18,710 --> 00:22:21,859
that or at least what's doing it now and

00:22:20,629 --> 00:22:23,570
of course we all need to have an

00:22:21,859 --> 00:22:25,549
agreement of what an enterprise app is

00:22:23,570 --> 00:22:26,809
and I think in the simplest view

00:22:25,549 --> 00:22:28,580
hopefully I don't get too many

00:22:26,809 --> 00:22:30,499
contentions on this this is what an

00:22:28,580 --> 00:22:32,719
enterprise app is where you know typical

00:22:30,499 --> 00:22:34,309
three-tier app we've got our client here

00:22:32,719 --> 00:22:38,409
we got some sort of application server

00:22:34,309 --> 00:22:41,269
tier and we've got a data tier and

00:22:38,409 --> 00:22:43,519
generally we're connecting through at

00:22:41,269 --> 00:22:45,710
the app tier some sort of integration

00:22:43,519 --> 00:22:48,409
that's firing off again typically a very

00:22:45,710 --> 00:22:51,070
transactional item to the blockchain

00:22:48,409 --> 00:22:53,989
network does the blockchain network

00:22:51,070 --> 00:22:56,659
completely replace an enterprise app I

00:22:53,989 --> 00:22:59,059
can't think that I have any examples

00:22:56,659 --> 00:23:00,859
where where that's the case usually

00:22:59,059 --> 00:23:02,799
we're using this to extend the

00:23:00,859 --> 00:23:05,389
capability that we're already doing and

00:23:02,799 --> 00:23:08,269
we'll talk a little bit again about this

00:23:05,389 --> 00:23:10,159
data problem we have with it but there's

00:23:08,269 --> 00:23:13,789
a lot of information around that

00:23:10,159 --> 00:23:15,619
application that we can't fully have on

00:23:13,789 --> 00:23:18,259
the blockchain network so typically

00:23:15,619 --> 00:23:20,179
we're issuing transactions over we may

00:23:18,259 --> 00:23:22,219
be trying to secure part of the

00:23:20,179 --> 00:23:24,320
information about the transaction and

00:23:22,219 --> 00:23:27,019
make sure it has hopefully as much

00:23:24,320 --> 00:23:28,820
integrity that's our goal to have as

00:23:27,019 --> 00:23:30,589
much integrity around the data that

00:23:28,820 --> 00:23:33,589
surrounds the transaction is a

00:23:30,589 --> 00:23:36,999
transaction itself you know block chains

00:23:33,589 --> 00:23:39,710
are really really good at proving that

00:23:36,999 --> 00:23:42,409
person or entity a you know bought

00:23:39,710 --> 00:23:44,989
something from person or entity B for

00:23:42,409 --> 00:23:47,629
say a hundred dollars or 100 tokens and

00:23:44,989 --> 00:23:49,639
maybe they've even done this 50 times in

00:23:47,629 --> 00:23:51,799
a day but they're really really bad at

00:23:49,639 --> 00:23:53,779
telling you what that was for so we can

00:23:51,799 --> 00:23:57,349
prove that the money went across tor the

00:23:53,779 --> 00:24:00,049
transaction happened but you know

00:23:57,349 --> 00:24:01,940
where's the rest of it and that ends up

00:24:00,049 --> 00:24:05,179
presenting probably the biggest problem

00:24:01,940 --> 00:24:06,469
for typical enterprise applications so

00:24:05,179 --> 00:24:07,039
usually say you were going to use

00:24:06,469 --> 00:24:09,889
aetherium

00:24:07,039 --> 00:24:12,349
and on the public network and you're

00:24:09,889 --> 00:24:13,879
issuing some sort of transaction or some

00:24:12,349 --> 00:24:16,339
sort of information that you're trying

00:24:13,879 --> 00:24:18,799
to store over here what you would end up

00:24:16,339 --> 00:24:21,290
doing is you'll end up running a local

00:24:18,799 --> 00:24:22,280
aetherium node and then you know

00:24:21,290 --> 00:24:24,200
depending on what you're using in your

00:24:22,280 --> 00:24:26,900
apt here if you're using like nodejs

00:24:24,200 --> 00:24:29,150
you'll use a client library that will

00:24:26,900 --> 00:24:30,590
you know if I need to look up data or

00:24:29,150 --> 00:24:32,450
information that's existing in the

00:24:30,590 --> 00:24:34,550
network it'll actually issue that

00:24:32,450 --> 00:24:36,260
request to your local aetherium node

00:24:34,550 --> 00:24:38,000
that you're running which is staying

00:24:36,260 --> 00:24:39,380
synchronized with the network so of

00:24:38,000 --> 00:24:41,360
course you need to make sure this part

00:24:39,380 --> 00:24:43,400
of it whatever you're using to help you

00:24:41,360 --> 00:24:45,020
know manage how that data gets over to

00:24:43,400 --> 00:24:47,720
your app that it's up and it's running

00:24:45,020 --> 00:24:50,390
and then it's healthy and doing a good

00:24:47,720 --> 00:24:56,570
job but yeah

00:24:50,390 --> 00:24:58,670
that's about it so how do we store

00:24:56,570 --> 00:25:00,770
information I'll get into kind of some

00:24:58,670 --> 00:25:02,000
of the challenges we have in dealing

00:25:00,770 --> 00:25:06,140
with the information around the

00:25:02,000 --> 00:25:08,810
transaction so this is a very very

00:25:06,140 --> 00:25:11,750
simple solidity contract so if you were

00:25:08,810 --> 00:25:14,600
using a theory I'm I'm not proposing you

00:25:11,750 --> 00:25:18,980
use aetherium in any way but it's a

00:25:14,600 --> 00:25:20,720
basic contract that in this case is

00:25:18,980 --> 00:25:22,700
storing an unsigned integer and

00:25:20,720 --> 00:25:25,490
basically it's just setting up a getter

00:25:22,700 --> 00:25:27,320
and setter an important consideration to

00:25:25,490 --> 00:25:30,530
think about if you're building an

00:25:27,320 --> 00:25:32,720
enterprise application is what if I have

00:25:30,530 --> 00:25:37,060
a new field of data or a new piece of

00:25:32,720 --> 00:25:40,640
information that I need to store because

00:25:37,060 --> 00:25:42,520
apps change and evolve our requirements

00:25:40,640 --> 00:25:45,020
change and evolve how do we handle that

00:25:42,520 --> 00:25:47,270
and the answer becomes a little bit

00:25:45,020 --> 00:25:50,090
tough especially in a public network

00:25:47,270 --> 00:25:52,160
because once this is actually set up you

00:25:50,090 --> 00:25:55,490
can't really modify it otherwise it

00:25:52,160 --> 00:25:57,170
wouldn't be immutable the people you

00:25:55,490 --> 00:25:59,900
know one of the guarantees that we want

00:25:57,170 --> 00:26:03,560
to give people in a fully decentralized

00:25:59,900 --> 00:26:05,720
network is that this business logic that

00:26:03,560 --> 00:26:07,550
perhaps they put their money into for

00:26:05,720 --> 00:26:09,980
some reason that someone can't come

00:26:07,550 --> 00:26:11,780
along and change it so if we let people

00:26:09,980 --> 00:26:13,730
just upgrade this then we couldn't

00:26:11,780 --> 00:26:17,060
provide that sort of guarantee so we

00:26:13,730 --> 00:26:19,010
can't really let them upgrade it so how

00:26:17,060 --> 00:26:21,230
do we get around that well sort of the I

00:26:19,010 --> 00:26:23,390
guess naive approach would be you create

00:26:21,230 --> 00:26:25,550
a new contract and now you need to

00:26:23,390 --> 00:26:27,350
transfer all the assets and information

00:26:25,550 --> 00:26:29,450
from the old contract over to the new

00:26:27,350 --> 00:26:31,130
contract and depending on how much you

00:26:29,450 --> 00:26:34,130
have in that this could end up costing

00:26:31,130 --> 00:26:35,960
tens of thousands of dollars to do

00:26:34,130 --> 00:26:38,870
I've heard examples of that happening

00:26:35,960 --> 00:26:40,460
the more logical approach is that you

00:26:38,870 --> 00:26:43,610
try and actually separate your data

00:26:40,460 --> 00:26:45,800
management from more the business logic

00:26:43,610 --> 00:26:48,380
and hope you don't need to evolve the

00:26:45,800 --> 00:26:50,030
data management piece very much and what

00:26:48,380 --> 00:26:52,250
you end up doing is just basically

00:26:50,030 --> 00:26:54,050
having the components in a smart

00:26:52,250 --> 00:26:57,830
contract that store and manage

00:26:54,050 --> 00:27:00,350
information and then that contract gives

00:26:57,830 --> 00:27:01,190
the contract that has your application

00:27:00,350 --> 00:27:03,890
logic in it

00:27:01,190 --> 00:27:05,870
permission to utilize it and call its

00:27:03,890 --> 00:27:07,490
methods and that way if you upgrade your

00:27:05,870 --> 00:27:09,860
app you can just kind of create a new

00:27:07,490 --> 00:27:11,840
business logic tier and all you need to

00:27:09,860 --> 00:27:13,490
do is take your contract that's storing

00:27:11,840 --> 00:27:15,350
your data and essentially give

00:27:13,490 --> 00:27:17,000
permission to the new tier now of course

00:27:15,350 --> 00:27:18,680
all your users and everyone would have

00:27:17,000 --> 00:27:22,790
to start using the new application

00:27:18,680 --> 00:27:25,130
because the old application you wouldn't

00:27:22,790 --> 00:27:28,040
want anyone using that anymore so

00:27:25,130 --> 00:27:30,170
there's there's some challenges that you

00:27:28,040 --> 00:27:32,450
really need to think about if you want

00:27:30,170 --> 00:27:33,830
flexibility and upgrading your app but

00:27:32,450 --> 00:27:38,030
yeah just a simple getter and setter

00:27:33,830 --> 00:27:40,670
sort of method if you were using flurry

00:27:38,030 --> 00:27:43,450
DB we we set things up more like a

00:27:40,670 --> 00:27:45,680
database this is just a simple JSON

00:27:43,450 --> 00:27:47,870
request to the network but in this case

00:27:45,680 --> 00:27:50,120
we're setting up a string attribute

00:27:47,870 --> 00:27:52,520
which is a user name and we're saying

00:27:50,120 --> 00:27:54,860
it's a unique attribute or basically a

00:27:52,520 --> 00:27:57,140
primary key but this would be the

00:27:54,860 --> 00:27:58,880
equivalent of setting up information in

00:27:57,140 --> 00:28:00,320
that blockchain network that you're

00:27:58,880 --> 00:28:01,310
going to be storing in this case we're

00:28:00,320 --> 00:28:03,230
saying we're gonna start storing

00:28:01,310 --> 00:28:05,690
usernames and and you know here's a

00:28:03,230 --> 00:28:07,250
basic schema for it in this case this is

00:28:05,690 --> 00:28:09,890
just an unsigned integer I didn't give

00:28:07,250 --> 00:28:11,420
it a name but solidity contract

00:28:09,890 --> 00:28:12,820
essentially doing the same thing we're

00:28:11,420 --> 00:28:17,060
gonna store this particular piece of

00:28:12,820 --> 00:28:19,070
value on the blockchain network so the

00:28:17,060 --> 00:28:21,710
data issue that we start running into is

00:28:19,070 --> 00:28:24,380
that like I mentioned most blockchain

00:28:21,710 --> 00:28:26,450
transactions they are really good at

00:28:24,380 --> 00:28:29,960
doing this they're really good at

00:28:26,450 --> 00:28:32,810
tracking an entity and that some sort of

00:28:29,960 --> 00:28:35,240
asset transfers some sort of application

00:28:32,810 --> 00:28:38,240
happened perhaps there is a smart

00:28:35,240 --> 00:28:40,490
contract in there that's doing logic you

00:28:38,240 --> 00:28:43,220
know the typical smart contract example

00:28:40,490 --> 00:28:45,410
is like an escrow it locks up my money

00:28:43,220 --> 00:28:47,870
for 30 days and some event happened then

00:28:45,410 --> 00:28:49,970
it transfers it to the other party if

00:28:47,870 --> 00:28:53,029
doesn't happen the money comes back to

00:28:49,970 --> 00:28:55,190
me but however regardless during that

00:28:53,029 --> 00:28:57,830
time frame the money's locked up so

00:28:55,190 --> 00:29:00,860
smart contract might make a bit more

00:28:57,830 --> 00:29:03,080
intelligence around this but when we

00:29:00,860 --> 00:29:05,179
build enterprise applications there is

00:29:03,080 --> 00:29:07,809
so much more information we're typically

00:29:05,179 --> 00:29:11,090
dealing with maybe we're conducting

00:29:07,809 --> 00:29:12,679
stuff around a particular invoice and

00:29:11,090 --> 00:29:14,330
that invoice has products and those

00:29:12,679 --> 00:29:16,279
products have warranties there might be

00:29:14,330 --> 00:29:18,529
pictures there might have been approval

00:29:16,279 --> 00:29:19,760
processes all these sorts of items were

00:29:18,529 --> 00:29:22,250
having to deal with in an enterprise

00:29:19,760 --> 00:29:24,529
application we need to put that data

00:29:22,250 --> 00:29:26,539
somewhere and if that data is completely

00:29:24,529 --> 00:29:28,130
disconnected from the transaction itself

00:29:26,539 --> 00:29:30,230
the fact that I can prove that

00:29:28,130 --> 00:29:31,789
transaction might not be that much

00:29:30,230 --> 00:29:34,190
benefit to me at the end of the day

00:29:31,789 --> 00:29:40,010
because if I can't prove what it was for

00:29:34,190 --> 00:29:42,529
then it might be for move so the obvious

00:29:40,010 --> 00:29:46,309
thing would be let's just store it on

00:29:42,529 --> 00:29:48,020
chain now most of those you know I had

00:29:46,309 --> 00:29:50,090
that chart up initially for a reason

00:29:48,020 --> 00:29:51,980
most of the black chains focus on

00:29:50,090 --> 00:29:57,110
facilitating transactions they don't

00:29:51,980 --> 00:30:00,169
focus on storing data so it's not really

00:29:57,110 --> 00:30:01,700
a knock against them but I will ask this

00:30:00,169 --> 00:30:03,830
anyone want to guess what it would cost

00:30:01,700 --> 00:30:11,720
to put a gigabyte of data on the

00:30:03,830 --> 00:30:14,090
etherium blockchain millions of dollars

00:30:11,720 --> 00:30:16,010
so you know one point late last year

00:30:14,090 --> 00:30:19,399
this is about 10 million dollars to put

00:30:16,010 --> 00:30:20,870
it on there so if you could put data on

00:30:19,399 --> 00:30:22,760
the blockchain or if you have just a

00:30:20,870 --> 00:30:25,760
tiny bit of information it can actually

00:30:22,760 --> 00:30:28,010
work but at the point that you're

00:30:25,760 --> 00:30:29,149
dealing with an enterprise app that

00:30:28,010 --> 00:30:32,330
actually has a lot of information

00:30:29,149 --> 00:30:34,789
enterprise apps typically have somewhat

00:30:32,330 --> 00:30:36,289
low transactional velocity not that many

00:30:34,789 --> 00:30:38,600
transactions per second but they're

00:30:36,289 --> 00:30:43,370
typically very very rich in information

00:30:38,600 --> 00:30:46,610
and data so it makes this a problem so

00:30:43,370 --> 00:30:48,409
there's kind of three main solutions and

00:30:46,610 --> 00:30:52,159
I'll talk about the pros and cons of

00:30:48,409 --> 00:30:55,640
each of these that are out there today

00:30:52,159 --> 00:30:59,059
so the first which I mentioned is just

00:30:55,640 --> 00:31:00,440
store the data on chain so the great

00:30:59,059 --> 00:31:01,639
advantage here is that there's no

00:31:00,440 --> 00:31:03,379
integration the infirm

00:31:01,639 --> 00:31:05,749
about the transaction is right with the

00:31:03,379 --> 00:31:07,639
transaction itself and this works again

00:31:05,749 --> 00:31:09,259
really good if your Bitcoin because

00:31:07,639 --> 00:31:10,700
you're not really storing much about the

00:31:09,259 --> 00:31:11,719
transaction you don't really care about

00:31:10,700 --> 00:31:14,419
it

00:31:11,719 --> 00:31:17,299
so where this is going to be very useful

00:31:14,419 --> 00:31:19,070
is if it's a very transaction-oriented

00:31:17,299 --> 00:31:21,529
you just have a tiny bit of data

00:31:19,070 --> 00:31:22,999
obviously the disadvantage is that

00:31:21,529 --> 00:31:25,579
especially if you're using a public

00:31:22,999 --> 00:31:27,859
blockchain network the cost of doing

00:31:25,579 --> 00:31:30,169
this or even some of the private

00:31:27,859 --> 00:31:31,669
blockchain networks the cost of doing

00:31:30,169 --> 00:31:34,879
this is still high because they're just

00:31:31,669 --> 00:31:36,619
not designed to facilitate a lot of

00:31:34,879 --> 00:31:38,539
information like that they're designed

00:31:36,619 --> 00:31:44,869
to handle consensus generally around

00:31:38,539 --> 00:31:48,950
transactions this is what I hear most

00:31:44,869 --> 00:31:51,349
often being recommended is just use a

00:31:48,950 --> 00:31:53,839
regular database and put the information

00:31:51,349 --> 00:31:56,209
in there and then hash the data from the

00:31:53,839 --> 00:31:57,289
database and then store the hash with

00:31:56,209 --> 00:31:59,269
the transaction

00:31:57,289 --> 00:32:02,169
so you're just storing a little bit of

00:31:59,269 --> 00:32:05,029
data with the transaction in the hash I

00:32:02,169 --> 00:32:06,499
don't particularly like this idea I

00:32:05,029 --> 00:32:07,909
think most of the people who recommend

00:32:06,499 --> 00:32:10,029
doing this are people who haven't done

00:32:07,909 --> 00:32:12,769
it themselves

00:32:10,029 --> 00:32:14,299
one advantage of course you have with

00:32:12,769 --> 00:32:16,579
this is that you know in theory you have

00:32:14,299 --> 00:32:19,489
unlimited data storage because data

00:32:16,579 --> 00:32:21,469
storage is really cheap nowadays the

00:32:19,489 --> 00:32:24,799
disadvantage of course is now our data

00:32:21,469 --> 00:32:26,329
is separated and we have integration

00:32:24,799 --> 00:32:27,979
that's required to bring this

00:32:26,329 --> 00:32:30,679
transaction together which you know

00:32:27,979 --> 00:32:32,479
again not that big of a deal these other

00:32:30,679 --> 00:32:34,909
parts start to become bigger deals to me

00:32:32,479 --> 00:32:37,219
I need to be able to reproduce all the

00:32:34,909 --> 00:32:40,339
information because all we're storing is

00:32:37,219 --> 00:32:42,559
a hash and if I can't reproduce that

00:32:40,339 --> 00:32:43,940
information identically then the hash is

00:32:42,559 --> 00:32:45,859
gonna be different even if it's one

00:32:43,940 --> 00:32:49,009
character even if it's a sorting issue

00:32:45,859 --> 00:32:51,709
you know even if it's a character

00:32:49,009 --> 00:32:54,019
encoding issue if I encoded it in utf-8

00:32:51,709 --> 00:32:55,789
I'm gonna get a different hash than if i

00:32:54,019 --> 00:32:58,309
encode even though the data is identical

00:32:55,789 --> 00:32:59,690
in utf-16 they're just going to look

00:32:58,309 --> 00:33:01,909
different and I won't know what's

00:32:59,690 --> 00:33:05,149
different about them so my concern about

00:33:01,909 --> 00:33:07,729
this is that there are a good number of

00:33:05,149 --> 00:33:09,589
failure points and I don't know that I

00:33:07,729 --> 00:33:11,749
want to be the person that gets the call

00:33:09,589 --> 00:33:13,940
five years down the road when there's an

00:33:11,749 --> 00:33:15,140
issue with some sort of transaction and

00:33:13,940 --> 00:33:19,070
it's

00:33:15,140 --> 00:33:21,710
on me to reproduce this particular piece

00:33:19,070 --> 00:33:23,510
of data in the identical way and come up

00:33:21,710 --> 00:33:26,030
with that hash so I can somehow prove it

00:33:23,510 --> 00:33:28,760
this this also tends to have one other

00:33:26,030 --> 00:33:30,500
issue which is the data around the

00:33:28,760 --> 00:33:32,510
transactions even though I'm hashing all

00:33:30,500 --> 00:33:33,950
that up together it's really sort it's

00:33:32,510 --> 00:33:35,060
essentially stored like a document

00:33:33,950 --> 00:33:39,500
database I mean that's all you're doing

00:33:35,060 --> 00:33:41,930
with it so any relationships in there do

00:33:39,500 --> 00:33:44,870
not have the same level of integrity so

00:33:41,930 --> 00:33:47,030
if it's a invoice I'm generating and

00:33:44,870 --> 00:33:49,520
that invoice is being shared on a supply

00:33:47,030 --> 00:33:52,010
chain network with different companies

00:33:49,520 --> 00:33:53,540
that invoice may reference product

00:33:52,010 --> 00:33:55,340
numbers or product information

00:33:53,540 --> 00:33:57,320
well that product information isn't

00:33:55,340 --> 00:33:59,780
being held or secured in the same way so

00:33:57,320 --> 00:34:01,790
someone could still manipulate all the

00:33:59,780 --> 00:34:03,770
dependent data but it still looks like

00:34:01,790 --> 00:34:06,350
my transaction is fine because I can

00:34:03,770 --> 00:34:07,850
reproduce that original invoice so this

00:34:06,350 --> 00:34:09,440
doesn't really build on the history of

00:34:07,850 --> 00:34:11,270
information there and maintain the

00:34:09,440 --> 00:34:13,460
integrity of the historical information

00:34:11,270 --> 00:34:15,679
but it can secure a little bit of

00:34:13,460 --> 00:34:17,480
metadata around something again my big

00:34:15,679 --> 00:34:20,300
concern with this ends up being

00:34:17,480 --> 00:34:22,610
reproducibility not that I don't trust

00:34:20,300 --> 00:34:24,320
me to be able to reproduce it but you

00:34:22,610 --> 00:34:25,970
know how many people know that the

00:34:24,320 --> 00:34:27,470
person who built this in their company

00:34:25,970 --> 00:34:29,750
is going to be there in five years and

00:34:27,470 --> 00:34:32,030
left good documentation and that someone

00:34:29,750 --> 00:34:34,159
else is going to be able to have that so

00:34:32,030 --> 00:34:38,960
I think it opens up a lot of failure

00:34:34,159 --> 00:34:40,880
points I really love ipfs so you don't

00:34:38,960 --> 00:34:42,620
hear this I would much rather do this

00:34:40,880 --> 00:34:46,310
over storing it in a traditional

00:34:42,620 --> 00:34:48,620
database it still has almost all the

00:34:46,310 --> 00:34:51,710
same challenges we talked about except

00:34:48,620 --> 00:34:54,409
it's gonna take off your hands creating

00:34:51,710 --> 00:34:56,840
that hash because it's standardized and

00:34:54,409 --> 00:34:58,820
every tool you end up using will end up

00:34:56,840 --> 00:35:01,280
having that and it's being stored in a

00:34:58,820 --> 00:35:03,380
technology that isn't designed to make

00:35:01,280 --> 00:35:05,150
it super easy to overwrite information

00:35:03,380 --> 00:35:08,360
right databases just make it immensely

00:35:05,150 --> 00:35:10,190
easy whether you intended to or not to

00:35:08,360 --> 00:35:12,170
update records and destroy old

00:35:10,190 --> 00:35:14,030
information and you may even not know

00:35:12,170 --> 00:35:15,830
that you destroyed information that was

00:35:14,030 --> 00:35:19,040
important you just don't know

00:35:15,830 --> 00:35:21,560
so using IP FS you can take your data

00:35:19,040 --> 00:35:23,160
you can encode it using any way you want

00:35:21,560 --> 00:35:25,800
you can

00:35:23,160 --> 00:35:29,090
you know just use JSON encoding encode

00:35:25,800 --> 00:35:32,250
everything in a map as a string and

00:35:29,090 --> 00:35:36,290
stored in ipfs ipfs will generate that

00:35:32,250 --> 00:35:38,760
hash it's a content addressable sort of

00:35:36,290 --> 00:35:40,920
content addressable piece of technology

00:35:38,760 --> 00:35:42,530
where the hash will always be identical

00:35:40,920 --> 00:35:44,910
for that particular piece of information

00:35:42,530 --> 00:35:47,340
you still need to run an IP FS

00:35:44,910 --> 00:35:48,990
repository locally because IP FS doesn't

00:35:47,340 --> 00:35:50,700
like it's not like you're shipping it

00:35:48,990 --> 00:35:52,860
off to someone else's cloud or they're

00:35:50,700 --> 00:35:54,950
gonna to get guarantee that they're

00:35:52,860 --> 00:35:57,540
gonna be storing that for you

00:35:54,950 --> 00:36:01,200
Technologies like file coin you know

00:35:57,540 --> 00:36:02,490
eventually we'll look to try to solve

00:36:01,200 --> 00:36:04,740
this problem where you don't necessarily

00:36:02,490 --> 00:36:06,690
have to run your own node you can pay

00:36:04,740 --> 00:36:09,840
other people to store data for you on an

00:36:06,690 --> 00:36:11,580
ongoing basis so it's a it's a better

00:36:09,840 --> 00:36:14,880
solution it still has that data

00:36:11,580 --> 00:36:16,620
dependency and integrity issue where the

00:36:14,880 --> 00:36:19,170
metadata you're storing for that

00:36:16,620 --> 00:36:21,120
transaction is isolated so if there's

00:36:19,170 --> 00:36:23,460
any references to other pieces of

00:36:21,120 --> 00:36:25,380
information etc that need its integrity

00:36:23,460 --> 00:36:28,950
you might not have the integrity of the

00:36:25,380 --> 00:36:30,810
sub information ipfs is a lot like

00:36:28,950 --> 00:36:32,430
object storage it really is object

00:36:30,810 --> 00:36:35,580
storage so in particular a few of things

00:36:32,430 --> 00:36:37,650
that need object storage images videos

00:36:35,580 --> 00:36:42,510
things like that IP FS is a great

00:36:37,650 --> 00:36:44,790
solution I'll talk about how we see

00:36:42,510 --> 00:36:49,530
making this data and information

00:36:44,790 --> 00:36:53,820
available so Flurry's approach has been

00:36:49,530 --> 00:36:57,330
to secure the information at the

00:36:53,820 --> 00:37:00,060
database source so you use it like you

00:36:57,330 --> 00:37:01,950
use a normal database that way all the

00:37:00,060 --> 00:37:04,260
dependent information is tracked for you

00:37:01,950 --> 00:37:05,490
you have consistent hash replication you

00:37:04,260 --> 00:37:07,770
actually have something you can query

00:37:05,490 --> 00:37:09,120
and do some interesting things with so

00:37:07,770 --> 00:37:12,660
that would change the picture a little

00:37:09,120 --> 00:37:13,980
bit from this which will still be what

00:37:12,660 --> 00:37:17,100
you want to do if you're using a public

00:37:13,980 --> 00:37:18,840
network or a very transactional oriented

00:37:17,100 --> 00:37:20,730
network which again a lot of our initial

00:37:18,840 --> 00:37:23,340
use cases are but more does something

00:37:20,730 --> 00:37:26,220
like this where essentially you're just

00:37:23,340 --> 00:37:29,490
using a database in parts of the data in

00:37:26,220 --> 00:37:32,250
your database have consensus needs

00:37:29,490 --> 00:37:35,130
around it so there will be participants

00:37:32,250 --> 00:37:37,560
that end up validating certain types of

00:37:35,130 --> 00:37:39,060
transactions other types of transactions

00:37:37,560 --> 00:37:41,490
maybe you don't want on the network

00:37:39,060 --> 00:37:43,350
maybe you don't want validated but if we

00:37:41,490 --> 00:37:44,730
can start to access that information in

00:37:43,350 --> 00:37:47,010
the same way we're used to in our

00:37:44,730 --> 00:37:48,210
typical 3t rap you know as far as we're

00:37:47,010 --> 00:37:51,240
concerned we're just using another

00:37:48,210 --> 00:37:54,230
database we don't necessarily have to

00:37:51,240 --> 00:37:57,390
deal with all those integration points

00:37:54,230 --> 00:37:58,980
I'll talk a little bit about and then we

00:37:57,390 --> 00:38:02,280
got at least a few minutes I think for

00:37:58,980 --> 00:38:05,340
questions a little bit as far as where

00:38:02,280 --> 00:38:08,490
we see some of this information and how

00:38:05,340 --> 00:38:09,780
we make it accessible so we've got some

00:38:08,490 --> 00:38:11,730
of these challenges we've talked about

00:38:09,780 --> 00:38:13,320
you know we're creating smart contracts

00:38:11,730 --> 00:38:15,360
we're putting these on networks for

00:38:13,320 --> 00:38:16,770
creating hashes of all this data and

00:38:15,360 --> 00:38:18,870
when we're building an enterprise

00:38:16,770 --> 00:38:21,090
application you know some business user

00:38:18,870 --> 00:38:22,530
somewhere needs to pull up a page they

00:38:21,090 --> 00:38:24,300
need to check on the status of an

00:38:22,530 --> 00:38:26,610
invoice or they need to see some sort of

00:38:24,300 --> 00:38:29,130
chart on the history of kind of where

00:38:26,610 --> 00:38:33,150
things have done and we are huge huge

00:38:29,130 --> 00:38:35,040
fans of the ideas of the Semantic Web I

00:38:33,150 --> 00:38:38,010
even heard that kind of brought up

00:38:35,040 --> 00:38:41,250
before but in particular using the RDF

00:38:38,010 --> 00:38:43,080
format of storing data and I think that

00:38:41,250 --> 00:38:45,240
we're gonna see a real resurgence around

00:38:43,080 --> 00:38:47,730
this type of technology because it just

00:38:45,240 --> 00:38:49,980
starts to make a lot of sense in this

00:38:47,730 --> 00:38:52,380
context so this is an example where we

00:38:49,980 --> 00:38:55,710
had like a database update and ended up

00:38:52,380 --> 00:38:59,310
producing data that ended up making

00:38:55,710 --> 00:39:01,530
itself into a block on some black chain

00:38:59,310 --> 00:39:04,950
but if we can actually represent that

00:39:01,530 --> 00:39:06,630
data is an RDF sort of triple store in

00:39:04,950 --> 00:39:08,100
our case we use sort of an extended

00:39:06,630 --> 00:39:10,140
version because we're dealing with time

00:39:08,100 --> 00:39:12,450
we're dealing with changes over time

00:39:10,140 --> 00:39:14,400
then all of a sudden we can use some of

00:39:12,450 --> 00:39:17,190
these standardized query technologies

00:39:14,400 --> 00:39:19,080
that are really amazing technologies

00:39:17,190 --> 00:39:20,910
like sparkle I don't know how many

00:39:19,080 --> 00:39:23,610
people have used or played with it but

00:39:20,910 --> 00:39:26,190
this is really really cool stuff that

00:39:23,610 --> 00:39:28,470
hasn't totally found its niche yet I

00:39:26,190 --> 00:39:32,060
think to take off and I think this is

00:39:28,470 --> 00:39:36,000
the space that really helps it take off

00:39:32,060 --> 00:39:43,220
so what do we expect is going to change

00:39:36,000 --> 00:39:47,670
as a result of all this well I think

00:39:43,220 --> 00:39:49,560
using things like RDF triple stores and

00:39:47,670 --> 00:39:51,340
information combined with blockchain

00:39:49,560 --> 00:39:53,960
technology to be able to

00:39:51,340 --> 00:39:56,330
guarantee the integrity so blockchain is

00:39:53,960 --> 00:39:59,300
going to guarantee who submitted that

00:39:56,330 --> 00:40:00,619
data when it was submitted and that it

00:39:59,300 --> 00:40:03,230
hasn't been tampered with

00:40:00,619 --> 00:40:05,030
that will end up in a world before we

00:40:03,230 --> 00:40:07,520
know it where everyone not only has a

00:40:05,030 --> 00:40:09,740
public website every company but also a

00:40:07,520 --> 00:40:12,320
public data store of information

00:40:09,740 --> 00:40:13,730
maybe it's your product catalog whatever

00:40:12,320 --> 00:40:17,119
it happens to be that other third

00:40:13,730 --> 00:40:18,859
parties can interact with you and in the

00:40:17,119 --> 00:40:20,330
same way that lots of times we download

00:40:18,859 --> 00:40:22,400
a piece of software right now and we

00:40:20,330 --> 00:40:24,140
have a you know sha-256 hash that

00:40:22,400 --> 00:40:25,010
guarantees that that software hasn't

00:40:24,140 --> 00:40:27,560
been tampered with

00:40:25,010 --> 00:40:29,540
before we run it we should have that

00:40:27,560 --> 00:40:31,940
level integrity of all the information

00:40:29,540 --> 00:40:33,200
that comes from an organization and I

00:40:31,940 --> 00:40:35,060
think we'll have that soon so I think

00:40:33,200 --> 00:40:38,420
companies will end up publishing out

00:40:35,060 --> 00:40:41,090
datasets that are verifiable came from

00:40:38,420 --> 00:40:43,910
them including history you know how it's

00:40:41,090 --> 00:40:46,550
been updated and changed so we're real

00:40:43,910 --> 00:40:48,560
big fans of RDF I think the entire audit

00:40:46,550 --> 00:40:50,240
industry really needs to shift or at

00:40:48,560 --> 00:40:52,490
least the parts of the audit industry

00:40:50,240 --> 00:40:54,380
that deal with verifying data because

00:40:52,490 --> 00:40:56,540
again if we can trust the integrity of

00:40:54,380 --> 00:40:58,940
the information at the source we no

00:40:56,540 --> 00:41:01,510
longer need third parties to come in and

00:40:58,940 --> 00:41:08,480
give their stamp of approval for that

00:41:01,510 --> 00:41:10,310
what was that amen okay so I think all

00:41:08,480 --> 00:41:12,950
public records I think this should be

00:41:10,310 --> 00:41:14,750
the the next thing that we all do is

00:41:12,950 --> 00:41:16,700
just get all of our public records onto

00:41:14,750 --> 00:41:19,190
block chains it's a perfect use case it

00:41:16,700 --> 00:41:20,690
makes a lot of sense in this one I

00:41:19,190 --> 00:41:23,060
really believe we're going to end up

00:41:20,690 --> 00:41:25,190
seeing it I think every database should

00:41:23,060 --> 00:41:26,780
be a black chain database because why

00:41:25,190 --> 00:41:28,640
wouldn't we want this level of

00:41:26,780 --> 00:41:30,170
information security and integrity

00:41:28,640 --> 00:41:32,359
around every piece of information we

00:41:30,170 --> 00:41:33,650
have like why wouldn't we probably the

00:41:32,359 --> 00:41:34,520
big reason we wouldn't want to is

00:41:33,650 --> 00:41:37,040
because of it

00:41:34,520 --> 00:41:39,350
there's a cost associated with in time

00:41:37,040 --> 00:41:41,960
or performance but those barriers are

00:41:39,350 --> 00:41:44,359
quickly quickly breaking down and if you

00:41:41,960 --> 00:41:46,760
hear things about seven transactions per

00:41:44,359 --> 00:41:49,430
second on Bitcoin also keep in mind

00:41:46,760 --> 00:41:50,660
hopefully like we talked about part of

00:41:49,430 --> 00:41:54,619
its because it's using a proof-of-work

00:41:50,660 --> 00:41:56,480
part protocol so that wouldn't be the

00:41:54,619 --> 00:41:57,970
case for a typical enterprise app it

00:41:56,480 --> 00:42:00,080
doesn't have those same level of

00:41:57,970 --> 00:42:02,480
restrictions we can do things really

00:42:00,080 --> 00:42:04,460
really quickly so with that I'll

00:42:02,480 --> 00:42:05,029
conclude and we got a couple minutes for

00:42:04,460 --> 00:42:11,509
questions

00:42:05,029 --> 00:42:13,869
if anyone has a yes sir all right I'll

00:42:11,509 --> 00:42:13,869
repeat it

00:42:31,760 --> 00:42:34,879
[Music]

00:42:35,030 --> 00:42:41,050
yeah I think it's a great question and

00:42:39,020 --> 00:42:44,300
one I hear a lot and the question was

00:42:41,050 --> 00:42:48,770
why can't three companies or however

00:42:44,300 --> 00:42:50,660
many just share a database to store

00:42:48,770 --> 00:42:53,570
information and the answer is I think

00:42:50,660 --> 00:42:55,520
they could but blockchain inherently is

00:42:53,570 --> 00:42:58,160
going to provide you several aspects

00:42:55,520 --> 00:43:00,680
that those databases don't automatically

00:42:58,160 --> 00:43:02,330
do you could write code that starts to

00:43:00,680 --> 00:43:03,860
provide those same aspects if you want

00:43:02,330 --> 00:43:07,460
but then you're you know you're starting

00:43:03,860 --> 00:43:09,440
to ride write code which is fine so the

00:43:07,460 --> 00:43:11,120
things that they're not gonna standard

00:43:09,440 --> 00:43:12,950
database isn't gonna do is for one it's

00:43:11,120 --> 00:43:14,810
not decentralized in any way

00:43:12,950 --> 00:43:17,720
meaning that somebody has to run that

00:43:14,810 --> 00:43:20,780
and all the other parties have to trust

00:43:17,720 --> 00:43:22,160
that party that's running it and we

00:43:20,780 --> 00:43:23,750
actually see this in business quite a

00:43:22,160 --> 00:43:25,730
bit but usually in business when this

00:43:23,750 --> 00:43:28,550
happens because they do need a master

00:43:25,730 --> 00:43:30,350
data source the other companies will end

00:43:28,550 --> 00:43:32,630
up as part of the contract or whatever

00:43:30,350 --> 00:43:34,850
it has happens to be is some sort of

00:43:32,630 --> 00:43:36,620
right to come in and audit that

00:43:34,850 --> 00:43:37,910
information because they don't

00:43:36,620 --> 00:43:40,490
necessarily know I mean it could be

00:43:37,910 --> 00:43:41,750
someone in their IT department we're

00:43:40,490 --> 00:43:43,460
doing this even in the software

00:43:41,750 --> 00:43:44,060
as-a-service space but a good software

00:43:43,460 --> 00:43:47,600
as-a-service

00:43:44,060 --> 00:43:50,150
vendor needs to have you know sock to

00:43:47,600 --> 00:43:51,950
compliance basically strict controls

00:43:50,150 --> 00:43:54,790
around who has access to what data

00:43:51,950 --> 00:43:57,290
because they control it nobody else does

00:43:54,790 --> 00:43:59,210
so that's definitely one thing that

00:43:57,290 --> 00:44:01,430
you're gonna get with blockchain

00:43:59,210 --> 00:44:03,800
technology out of the box you can't do

00:44:01,430 --> 00:44:07,370
that with a normal database you're also

00:44:03,800 --> 00:44:10,670
going to get immutability and tamper

00:44:07,370 --> 00:44:12,500
resistance so the other piece is yeah

00:44:10,670 --> 00:44:14,540
what if someone modified a historical

00:44:12,500 --> 00:44:17,360
record you have no real good way of

00:44:14,540 --> 00:44:19,880
proving that now we can export out logs

00:44:17,360 --> 00:44:22,280
from you know our database and you know

00:44:19,880 --> 00:44:24,710
hash them and store them and things like

00:44:22,280 --> 00:44:26,330
that so all that is possible and again a

00:44:24,710 --> 00:44:28,430
lot of black chain technology or just

00:44:26,330 --> 00:44:30,920
they're these simple tools that we've

00:44:28,430 --> 00:44:32,540
been using for a long time they're just

00:44:30,920 --> 00:44:35,110
combined in a way that actually makes

00:44:32,540 --> 00:44:37,370
some really neat things start to happen

00:44:35,110 --> 00:44:39,860
so that would be at least another piece

00:44:37,370 --> 00:44:41,690
that you wouldn't wouldn't have so I

00:44:39,860 --> 00:44:44,000
don't think you can achieve the same

00:44:41,690 --> 00:44:45,950
sort of things you'd be writing a lot of

00:44:44,000 --> 00:44:46,910
code and some of them you can't achieve

00:44:45,950 --> 00:44:52,569
at all but

00:44:46,910 --> 00:44:52,569
it would depend on your use case yes sir

00:45:02,400 --> 00:45:08,819
the question is why is it so costly to

00:45:06,059 --> 00:45:14,130
store information on like a public

00:45:08,819 --> 00:45:15,869
blockchain so well I talked about

00:45:14,130 --> 00:45:18,020
aetherium specifically so I answer

00:45:15,869 --> 00:45:21,089
specific to aetherium so aetherium has

00:45:18,020 --> 00:45:23,579
two tokens anyone who hasn't really used

00:45:21,089 --> 00:45:25,980
it might not know that but one of the

00:45:23,579 --> 00:45:28,589
tokens of sculpt gas and the other is

00:45:25,980 --> 00:45:30,750
ether which is what people trade and

00:45:28,589 --> 00:45:33,270
every time you do a transaction on a

00:45:30,750 --> 00:45:35,220
theory 'm gas is supposed to actually

00:45:33,270 --> 00:45:37,170
represent the compute power you know

00:45:35,220 --> 00:45:39,690
what it ends up really costing the

00:45:37,170 --> 00:45:41,579
company and you submit when you do a

00:45:39,690 --> 00:45:44,339
transaction you submit an exchange rate

00:45:41,579 --> 00:45:46,589
between the two in the initial purpose

00:45:44,339 --> 00:45:48,450
which i think it's a great purpose it

00:45:46,589 --> 00:45:49,859
just hasn't worked incredibly well but I

00:45:48,450 --> 00:45:53,099
haven't seen anything else work better

00:45:49,859 --> 00:45:56,130
is that if a theory 'm like spikes and

00:45:53,099 --> 00:45:57,779
doubles and cost will the cost of doing

00:45:56,130 --> 00:45:59,130
transactions on the network shouldn't

00:45:57,779 --> 00:46:00,420
double as well because it's not like my

00:45:59,130 --> 00:46:02,940
computer got twice as expensive

00:46:00,420 --> 00:46:04,890
overnight just because the ether

00:46:02,940 --> 00:46:07,410
you know doubled so by having this

00:46:04,890 --> 00:46:11,520
exchange rate they're trying to fix the

00:46:07,410 --> 00:46:14,520
cost of gas to a particular type of

00:46:11,520 --> 00:46:18,390
compute and resource so storing

00:46:14,520 --> 00:46:21,539
information on aetherium has a very

00:46:18,390 --> 00:46:23,730
specific gas price so there's a very you

00:46:21,539 --> 00:46:25,529
know specific cost that it has and that

00:46:23,730 --> 00:46:29,250
costs at least currently is fixed what

00:46:25,529 --> 00:46:31,140
they end up charging for that so the

00:46:29,250 --> 00:46:34,109
reason it cost so much is because it

00:46:31,140 --> 00:46:36,930
costs a lot in gas to store that what

00:46:34,109 --> 00:46:38,789
does it cost a lot in gas the big

00:46:36,930 --> 00:46:41,000
concern with a lot of the full public

00:46:38,789 --> 00:46:43,440
networks is going to be the block size

00:46:41,000 --> 00:46:45,390
because you're having to deal with

00:46:43,440 --> 00:46:48,079
moving that much information it becomes

00:46:45,390 --> 00:46:52,559
very difficult to have the network run

00:46:48,079 --> 00:46:55,470
quickly one of the theorems big focuses

00:46:52,559 --> 00:46:58,770
was quick transaction times so they do a

00:46:55,470 --> 00:47:00,539
block about every 15 seconds well what

00:46:58,770 --> 00:47:03,029
if it takes more than 15 seconds to

00:47:00,539 --> 00:47:04,950
transmit the amount of data in a block

00:47:03,029 --> 00:47:07,349
you know I think the average household

00:47:04,950 --> 00:47:10,289
at least in developed countries now has

00:47:07,349 --> 00:47:12,839
about 23 megabit per second sort of

00:47:10,289 --> 00:47:14,490
bandwidth so that you roughly three

00:47:12,839 --> 00:47:15,420
megabytes a second is what you could

00:47:14,490 --> 00:47:18,119
push through that assume

00:47:15,420 --> 00:47:20,970
you had all of that so if you had a

00:47:18,119 --> 00:47:22,619
block that's three megabytes in an ideal

00:47:20,970 --> 00:47:24,089
scenario where that was your only

00:47:22,619 --> 00:47:26,099
bandwidth constraint and it was just two

00:47:24,089 --> 00:47:28,470
computers talking to each other that's

00:47:26,099 --> 00:47:30,180
going to take you a second just just to

00:47:28,470 --> 00:47:31,530
move that data across and then still

00:47:30,180 --> 00:47:33,119
needs to be verified and then a

00:47:31,530 --> 00:47:37,200
confirmation needs to be sent back

00:47:33,119 --> 00:47:40,950
etcetera so they want to make in that

00:47:37,200 --> 00:47:44,579
case the storage not be cheap otherwise

00:47:40,950 --> 00:47:46,140
the block sizes would be pretty enormous

00:47:44,579 --> 00:47:47,700
so theorems already got a pretty

00:47:46,140 --> 00:47:50,900
substantial amount of data that you have

00:47:47,700 --> 00:47:55,140
to sync up at this point but that's the

00:47:50,900 --> 00:47:57,450
you know it was focused around settling

00:47:55,140 --> 00:47:59,010
transactions quickly and efficiently not

00:47:57,450 --> 00:48:05,329
around storing data that wasn't their

00:47:59,010 --> 00:48:05,329
primary design goal initially yes sir

00:48:12,599 --> 00:48:17,570
you

00:48:15,340 --> 00:48:19,700
yeah I think the biggest thing the

00:48:17,570 --> 00:48:22,340
question is you know in the future does

00:48:19,700 --> 00:48:23,690
the expense of all this go away and I

00:48:22,340 --> 00:48:25,670
think it does you know aetherium is

00:48:23,690 --> 00:48:28,580
working very hard on sharding sharding

00:48:25,670 --> 00:48:31,490
you know should help drive the prices

00:48:28,580 --> 00:48:33,080
quite a bit down the thing that becomes

00:48:31,490 --> 00:48:34,670
very difficult with sharding is of

00:48:33,080 --> 00:48:36,590
course when you have to do transactions

00:48:34,670 --> 00:48:38,180
across shard so you're there so

00:48:36,590 --> 00:48:40,700
obviously going to be a penalty there

00:48:38,180 --> 00:48:43,580
when we talk about in an enterprise

00:48:40,700 --> 00:48:46,220
blockchain use case if we're looking to

00:48:43,580 --> 00:48:48,080
support someone paying for my product

00:48:46,220 --> 00:48:49,730
and bitcoin then I need to use Bitcoin

00:48:48,080 --> 00:48:51,670
but a lot of the things that we're

00:48:49,730 --> 00:48:55,190
looking at for enterprise black chains

00:48:51,670 --> 00:48:57,050
we're if the data is already sharded

00:48:55,190 --> 00:49:00,020
it's already a pretty small set of data

00:48:57,050 --> 00:49:01,880
that we're looking to do so storing a

00:49:00,020 --> 00:49:03,830
gigabyte of data on an enterprise black

00:49:01,880 --> 00:49:06,020
chain shouldn't be an issue the problem

00:49:03,830 --> 00:49:07,880
is a theorem is a full public blockchain

00:49:06,020 --> 00:49:10,070
and if everyone's storing a gigabyte

00:49:07,880 --> 00:49:11,750
then I have every company in the world

00:49:10,070 --> 00:49:13,670
maybe trying to store a gigabyte on

00:49:11,750 --> 00:49:15,830
there but in a more of a private

00:49:13,670 --> 00:49:17,480
blockchain network you know these are in

00:49:15,830 --> 00:49:19,870
generally we're working with bandwidth

00:49:17,480 --> 00:49:24,200
far greater than 23 megabits per second

00:49:19,870 --> 00:49:27,710
so the data we have a lot more Liberty

00:49:24,200 --> 00:49:29,450
on the data size in a private a typical

00:49:27,710 --> 00:49:30,770
private blockchain network again someone

00:49:29,450 --> 00:49:32,300
may want to use aetherium for some

00:49:30,770 --> 00:49:34,070
reason in an enterprise blockchain and

00:49:32,300 --> 00:49:34,970
that's perfectly fine to do but you're

00:49:34,070 --> 00:49:36,470
gonna have some of those data

00:49:34,970 --> 00:49:38,690
limitations just because in the nature

00:49:36,470 --> 00:49:40,850
of what it is and I think if anything

00:49:38,690 --> 00:49:43,490
and hopefully I started out with a lot

00:49:40,850 --> 00:49:46,160
of this that's the takeaway is that this

00:49:43,490 --> 00:49:48,380
is a big space there's a lot of products

00:49:46,160 --> 00:49:50,900
they do things in very very different

00:49:48,380 --> 00:49:52,520
ways and some of them are going to work

00:49:50,900 --> 00:49:54,740
really well for certain things you're

00:49:52,520 --> 00:49:57,080
trying to accomplish and really bad for

00:49:54,740 --> 00:49:58,850
other things so you need to try and pick

00:49:57,080 --> 00:50:00,410
the right products that align with what

00:49:58,850 --> 00:50:01,520
you're trying to accomplish and a lot of

00:50:00,410 --> 00:50:03,890
these problems that we hear about

00:50:01,520 --> 00:50:06,110
completely evaporate because they're

00:50:03,890 --> 00:50:07,760
irrelevant for what you're trying to do

00:50:06,110 --> 00:50:13,390
in the product you're using they're

00:50:07,760 --> 00:50:13,390
irrelevant for it yes

00:50:23,759 --> 00:50:28,139
yeah the question is how does a I come

00:50:26,429 --> 00:50:31,649
into this there's actually some projects

00:50:28,139 --> 00:50:33,869
that boy I can't think of the name I

00:50:31,649 --> 00:50:36,869
know a guy who's working on something

00:50:33,869 --> 00:50:38,609
that's trying to have a lot of

00:50:36,869 --> 00:50:41,429
information available with the purpose

00:50:38,609 --> 00:50:45,509
of machine learning and AI and have it

00:50:41,429 --> 00:50:47,189
out on a blockchain standpoint you know

00:50:45,509 --> 00:50:50,819
I I can give you my perspective from

00:50:47,189 --> 00:50:54,389
Fleury we our database our query engine

00:50:50,819 --> 00:50:56,969
is a full sort of semantic graph query

00:50:54,389 --> 00:50:58,439
engine and part of the purpose is

00:50:56,969 --> 00:51:01,199
because we just think graph databases

00:50:58,439 --> 00:51:03,959
are an ideal format for today's modern

00:51:01,199 --> 00:51:07,469
apps and also the reason is is that that

00:51:03,959 --> 00:51:09,559
is an a very ideal format to feed into

00:51:07,469 --> 00:51:12,029
machine learning and AI sort of

00:51:09,559 --> 00:51:13,199
mechanisms the other thing we do because

00:51:12,029 --> 00:51:15,509
we're carrying around the full history

00:51:13,199 --> 00:51:18,119
of the blockchain itself which in our

00:51:15,509 --> 00:51:21,029
case is basically database updates we've

00:51:18,119 --> 00:51:23,039
built in time travel so allow you to

00:51:21,029 --> 00:51:24,949
actually query any point in the database

00:51:23,039 --> 00:51:27,089
instantly without having to you know

00:51:24,949 --> 00:51:28,709
restore backup or something every

00:51:27,089 --> 00:51:32,189
versions available to you instantly

00:51:28,709 --> 00:51:33,749
SuperSpeed queries to do that but that

00:51:32,189 --> 00:51:35,880
historical context is the other

00:51:33,749 --> 00:51:37,409
component the most AI in machine

00:51:35,880 --> 00:51:38,849
learning need they need the history they

00:51:37,409 --> 00:51:41,189
need to look at the patterns over time

00:51:38,849 --> 00:51:42,899
and of course the typical database is an

00:51:41,189 --> 00:51:45,599
update and place database so that it

00:51:42,899 --> 00:51:47,159
doesn't have that so I think part of it

00:51:45,599 --> 00:51:48,449
depends on how you structure the data to

00:51:47,159 --> 00:51:50,819
make it friendly in that manner

00:51:48,449 --> 00:51:52,499
certainly the historical context very

00:51:50,819 --> 00:51:55,049
well aligns with I think artificial

00:51:52,499 --> 00:51:58,549
intelligence and where it's going and my

00:51:55,049 --> 00:52:00,630
guess is is yeah we're up for time so

00:51:58,549 --> 00:52:03,409
thank you I'll be around if anyone has

00:52:00,630 --> 00:52:03,409

YouTube URL: https://www.youtube.com/watch?v=qRzzmqtZ8t0


