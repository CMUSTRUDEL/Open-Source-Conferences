Title: All Things Open 2018 - Shaun Lamb, SAS Institute - Cloud Native for Speed and Security
Publication date: 2018-12-05
Playlist: All Things Open 2018 Playlist
Description: 
	All Things Open 2018 - Shaun Lamb, SAS Institute - Cloud Native for Speed and Security
Captions: 
	00:00:03,009 --> 00:00:07,520
okay let's go ahead and get started

00:00:04,990 --> 00:00:10,090
thank you guys for sticking around for

00:00:07,520 --> 00:00:12,290
the final session of the conference I

00:00:10,090 --> 00:00:13,849
imagine that most folks have a lot of

00:00:12,290 --> 00:00:15,610
ideas swirling around in your head so I

00:00:13,849 --> 00:00:20,420
wanted to start off with a light-hearted

00:00:15,610 --> 00:00:22,160
analogy and it's I think it's the

00:00:20,420 --> 00:00:23,570
prisoner's prerogative in order to ask a

00:00:22,160 --> 00:00:25,460
couple questions right off the bat of

00:00:23,570 --> 00:00:26,180
the audience so I have two important

00:00:25,460 --> 00:00:28,039
questions

00:00:26,180 --> 00:00:30,890
how many people have fond memories of

00:00:28,039 --> 00:00:34,309
the original classic Nintendo the very

00:00:30,890 --> 00:00:37,699
first one yeah okay and how many people

00:00:34,309 --> 00:00:40,429
remember the game genie attachment for

00:00:37,699 --> 00:00:43,429
the original Nintendo anybody I got a

00:00:40,429 --> 00:00:44,899
couple yeah all right good okay so for

00:00:43,429 --> 00:00:47,719
those that aren't familiar the game

00:00:44,899 --> 00:00:49,909
genie was a it was an attachment onto a

00:00:47,719 --> 00:00:51,889
Nintendo game where you could put it in

00:00:49,909 --> 00:00:53,839
and then imply series of codes and it

00:00:51,889 --> 00:00:56,149
would modify the way that the games

00:00:53,839 --> 00:00:58,399
would work and so you could do things

00:00:56,149 --> 00:00:59,749
like for this Ninja Turtle games here

00:00:58,399 --> 00:01:01,909
that I have attached to the game genie

00:00:59,749 --> 00:01:05,359
you could give infinite lives or

00:01:01,909 --> 00:01:07,159
additional powers you could you know it

00:01:05,359 --> 00:01:09,259
started a different level very cool

00:01:07,159 --> 00:01:11,420
things if you were you know nine

00:01:09,259 --> 00:01:14,479
ten-year-old kid and for me I was just

00:01:11,420 --> 00:01:17,539
floored by this this to me this was

00:01:14,479 --> 00:01:20,030
somewhere between sorcery and just

00:01:17,539 --> 00:01:22,429
genius and I was deeply fascinated and

00:01:20,030 --> 00:01:24,229
really wondered about what foresight the

00:01:22,429 --> 00:01:26,149
people in Nintendo must have had to

00:01:24,229 --> 00:01:29,359
create this attachment that worked with

00:01:26,149 --> 00:01:30,950
every single game that I owned and it

00:01:29,359 --> 00:01:33,020
wasn't until many years later that I

00:01:30,950 --> 00:01:35,090
learned that the game genie wasn't

00:01:33,020 --> 00:01:37,520
actually created by the people in

00:01:35,090 --> 00:01:40,130
Nintendo this was done by a third-party

00:01:37,520 --> 00:01:42,770
company and in fact Nintendo adamantly

00:01:40,130 --> 00:01:44,569
opposed the game genie they thought I

00:01:42,770 --> 00:01:46,429
was going to be it was going to

00:01:44,569 --> 00:01:51,380
jeopardize the success of the relatively

00:01:46,429 --> 00:01:53,990
new video game console and so here we go

00:01:51,380 --> 00:01:56,509
I'm going to show one of the one of my

00:01:53,990 --> 00:01:59,420
favorite game genie codes it's a Mario

00:01:56,509 --> 00:02:01,159
moonwalk game genie code and you know in

00:01:59,420 --> 00:02:03,409
I played Mario like a thousand times

00:02:01,159 --> 00:02:04,819
before I got my game genie and I had

00:02:03,409 --> 00:02:06,350
seen him run and jump and shoot

00:02:04,819 --> 00:02:08,780
fireballs but all of a sudden he could

00:02:06,350 --> 00:02:10,909
fly and I mean this was amazing to me

00:02:08,780 --> 00:02:12,830
but after learning though that it was

00:02:10,909 --> 00:02:13,940
developed by a third party it really

00:02:12,830 --> 00:02:15,980
made me think about

00:02:13,940 --> 00:02:17,840
there this was just some beloved you

00:02:15,980 --> 00:02:21,170
know Nintendo accessory there was it a

00:02:17,840 --> 00:02:23,090
commercialized hacking device I have

00:02:21,170 --> 00:02:25,100
another code up here there if you put

00:02:23,090 --> 00:02:28,370
that into a text file and save it as a

00:02:25,100 --> 00:02:30,770
CSV open it up in Excel that it would

00:02:28,370 --> 00:02:33,230
recursively delete the C Drive

00:02:30,770 --> 00:02:35,270
on a Windows machine so what is it is it

00:02:33,230 --> 00:02:37,430
a hacking device when Nintendo did

00:02:35,270 --> 00:02:39,680
everything they could in order to stop

00:02:37,430 --> 00:02:41,450
the sales of the game genie and there is

00:02:39,680 --> 00:02:43,280
a series of court battles that went back

00:02:41,450 --> 00:02:45,320
and forth and for a while there was a

00:02:43,280 --> 00:02:48,320
stoppage of sales of the game genie in

00:02:45,320 --> 00:02:50,540
the United States meanwhile individual

00:02:48,320 --> 00:02:52,370
game makers were also taking steps to

00:02:50,540 --> 00:02:54,560
thwart game genie they were coming up

00:02:52,370 --> 00:02:57,320
with memory checksums and other types of

00:02:54,560 --> 00:02:59,450
security controls in order to stop game

00:02:57,320 --> 00:03:01,190
genie from from modifying their game

00:02:59,450 --> 00:03:03,770
they thought that people might go to

00:03:01,190 --> 00:03:05,030
Blockbuster Video rent the game beat it

00:03:03,770 --> 00:03:07,430
really quickly with the help of game

00:03:05,030 --> 00:03:10,520
genie and then never actually buy their

00:03:07,430 --> 00:03:12,860
game there was one game in particular

00:03:10,520 --> 00:03:13,520
that was really effective at warding

00:03:12,860 --> 00:03:15,650
game genie

00:03:13,520 --> 00:03:17,120
it was the Bart Simpson's vs space

00:03:15,650 --> 00:03:20,600
mutants game which was actually a really

00:03:17,120 --> 00:03:21,950
good game if anybody's playing it you

00:03:20,600 --> 00:03:24,380
know they had really effective memory

00:03:21,950 --> 00:03:27,110
checksums in place and so it took quite

00:03:24,380 --> 00:03:28,910
some time for the game genie developers

00:03:27,110 --> 00:03:31,700
in order to come up with codes but

00:03:28,910 --> 00:03:33,800
eventually they did it and at that point

00:03:31,700 --> 00:03:34,940
in time Nintendo was really stuck I mean

00:03:33,800 --> 00:03:36,890
this was not an internet-connected

00:03:34,940 --> 00:03:38,959
device this was the very first Nintendo

00:03:36,890 --> 00:03:42,260
and there wasn't any kind of system for

00:03:38,959 --> 00:03:43,910
them to roll out patches and this is you

00:03:42,260 --> 00:03:45,200
know I think in some ways at least for

00:03:43,910 --> 00:03:47,300
the security folks and maybe the

00:03:45,200 --> 00:03:49,580
developers and apps too we can relate to

00:03:47,300 --> 00:03:51,830
this we can't say that were completely

00:03:49,580 --> 00:03:54,320
blocked from rolling out security fixes

00:03:51,830 --> 00:03:56,239
but maybe sometimes it feels that way

00:03:54,320 --> 00:03:59,269
and if you see if you look at the white

00:03:56,239 --> 00:04:01,160
hat statistic here on average it takes a

00:03:59,269 --> 00:04:03,380
long time to fix critical

00:04:01,160 --> 00:04:06,230
vulnerabilities this is a real industry

00:04:03,380 --> 00:04:08,959
problem and it's a it's partly why we

00:04:06,230 --> 00:04:11,269
see somebody exploits in the wild we see

00:04:08,959 --> 00:04:15,440
them in the headlines and so what I'm

00:04:11,269 --> 00:04:20,030
going to talk about isn't oh that's not

00:04:15,440 --> 00:04:21,530
good see I'm just gonna get a handle on

00:04:20,030 --> 00:04:24,470
the technical difficulties right away I

00:04:21,530 --> 00:04:25,480
think maybe the HDMI is loose or that

00:04:24,470 --> 00:04:36,160
work

00:04:25,480 --> 00:04:38,260
oh it didn't okay you have to say okay

00:04:36,160 --> 00:04:40,630
well while he's doing that so what I'm

00:04:38,260 --> 00:04:43,000
gonna do is talk about in architecture

00:04:40,630 --> 00:04:45,820
to more quickly roll out security

00:04:43,000 --> 00:04:48,160
mitigations and have security controls

00:04:45,820 --> 00:04:49,900
in place from the beginning and so I'm

00:04:48,160 --> 00:04:52,390
going to talk about cloud native

00:04:49,900 --> 00:04:56,050
platforms like kubernetes and Cloud

00:04:52,390 --> 00:04:59,500
Foundry and talk about how you can have

00:04:56,050 --> 00:05:02,530
a container strategy in order to really

00:04:59,500 --> 00:05:04,570
effectively patch and upgrade as needed

00:05:02,530 --> 00:05:07,690
I'm going to talk about the API gateway

00:05:04,570 --> 00:05:09,820
and how that prevents against common

00:05:07,690 --> 00:05:11,020
application level vulnerabilities like

00:05:09,820 --> 00:05:12,940
oh ah stop - any kinds of

00:05:11,020 --> 00:05:16,000
vulnerabilities and I'm going to talk

00:05:12,940 --> 00:05:17,470
about what's called an is tool which

00:05:16,000 --> 00:05:19,360
stands for interactive application

00:05:17,470 --> 00:05:23,020
security testing also known as a

00:05:19,360 --> 00:05:25,840
container runtime agent where it's

00:05:23,020 --> 00:05:28,150
running in the background on the

00:05:25,840 --> 00:05:31,720
platform and it's providing real-time

00:05:28,150 --> 00:05:33,490
continuous security feedback and so this

00:05:31,720 --> 00:05:34,930
isn't just vulnerability you know

00:05:33,490 --> 00:05:37,810
third-party dependency kind of feedback

00:05:34,930 --> 00:05:40,150
its feedback about the entire platform

00:05:37,810 --> 00:05:41,860
so it's giving you all the deep you know

00:05:40,150 --> 00:05:44,290
details about do you have kubernetes

00:05:41,860 --> 00:05:46,510
configured in a way that is secure

00:05:44,290 --> 00:05:48,340
do you have docker configured in a way

00:05:46,510 --> 00:05:50,230
that's secure and so it's giving all

00:05:48,340 --> 00:05:57,100
that feedback immediately without the

00:05:50,230 --> 00:05:58,870
need to kick off tests manually also

00:05:57,100 --> 00:06:00,640
they can sit and talk about the

00:05:58,870 --> 00:06:03,280
continuous integration tool and helps

00:06:00,640 --> 00:06:06,910
how that helps deploy your applications

00:06:03,280 --> 00:06:10,450
more quickly ultimately what we're

00:06:06,910 --> 00:06:13,930
trying to do is a deploy secure apps as

00:06:10,450 --> 00:06:15,760
fast as possible so to start off I'll

00:06:13,930 --> 00:06:18,430
talk about the API management tool and

00:06:15,760 --> 00:06:20,530
the benefits there and security trolls

00:06:18,430 --> 00:06:22,810
controls that you can use and then I'll

00:06:20,530 --> 00:06:25,030
detail the four aspects of cloud native

00:06:22,810 --> 00:06:26,680
architectures and finally talk about the

00:06:25,030 --> 00:06:31,360
cloud native platform itself and the

00:06:26,680 --> 00:06:35,260
security benefits that you get there so

00:06:31,360 --> 00:06:36,490
API management tools generally have you

00:06:35,260 --> 00:06:38,380
know there's there's a there's a wide

00:06:36,490 --> 00:06:39,350
variety of them there's some really

00:06:38,380 --> 00:06:42,020
lightweight

00:06:39,350 --> 00:06:44,980
simple API management tools and then

00:06:42,020 --> 00:06:48,290
there's more robust commercial tools I

00:06:44,980 --> 00:06:50,330
would group them into two parts you have

00:06:48,290 --> 00:06:53,720
your pure API management tools and then

00:06:50,330 --> 00:06:55,700
you have API security gateways some API

00:06:53,720 --> 00:06:59,570
management tools are really just focused

00:06:55,700 --> 00:07:02,870
on either monetization or tracking and

00:06:59,570 --> 00:07:05,720
giving feedback about your api's you

00:07:02,870 --> 00:07:07,250
know they'll give nice graphs geo globe

00:07:05,720 --> 00:07:09,140
graphs where you can see where in the

00:07:07,250 --> 00:07:11,360
world people are calling your api's and

00:07:09,140 --> 00:07:13,190
they'll give you some other security

00:07:11,360 --> 00:07:14,810
features like authentication and

00:07:13,190 --> 00:07:18,290
authorization but for the most part

00:07:14,810 --> 00:07:20,540
these aren't real security tools these

00:07:18,290 --> 00:07:22,220
are you know just API management tools

00:07:20,540 --> 00:07:24,770
and so if you're looking for an API

00:07:22,220 --> 00:07:27,590
gateway be aware of that that they're

00:07:24,770 --> 00:07:31,310
they're not all geared towards security

00:07:27,590 --> 00:07:33,470
specifically but ultimately both of

00:07:31,310 --> 00:07:35,450
those types of tools they're essentially

00:07:33,470 --> 00:07:38,570
proxy so there are wrappers around your

00:07:35,450 --> 00:07:41,000
api's and they will let you standardize

00:07:38,570 --> 00:07:42,890
on a set of reusable reusable API

00:07:41,000 --> 00:07:45,080
security controls so if we're looking

00:07:42,890 --> 00:07:47,330
more at talking more about the API

00:07:45,080 --> 00:07:49,190
gateway the diagram on the right is a

00:07:47,330 --> 00:07:51,200
hybrid cloud model where we have an

00:07:49,190 --> 00:07:53,330
admin console that's running in the

00:07:51,200 --> 00:07:55,550
cloud and then it's syncing up two

00:07:53,330 --> 00:07:57,880
installations of the API gateway that's

00:07:55,550 --> 00:08:00,410
running in a platform like kubernetes

00:07:57,880 --> 00:08:02,990
you can see that the service wrapper

00:08:00,410 --> 00:08:05,600
it's completely independent which makes

00:08:02,990 --> 00:08:09,920
it language agnostic so you could have

00:08:05,600 --> 00:08:11,900
Python Java different types of api's and

00:08:09,920 --> 00:08:14,780
you can still leverage the same API

00:08:11,900 --> 00:08:17,900
gateway more specifically the features

00:08:14,780 --> 00:08:21,440
include authentication like ooofff the

00:08:17,900 --> 00:08:22,730
ability to generate JW TS and then they

00:08:21,440 --> 00:08:24,260
support all the other types of

00:08:22,730 --> 00:08:26,240
authentication as well and maybe you

00:08:24,260 --> 00:08:28,610
have a legacy client that just supports

00:08:26,240 --> 00:08:30,880
basic off and so you can configure

00:08:28,610 --> 00:08:34,099
security policy at the API gateway level

00:08:30,880 --> 00:08:36,469
you know to verify those credentials as

00:08:34,099 --> 00:08:38,930
they're coming in you also get

00:08:36,469 --> 00:08:41,780
application level security policies and

00:08:38,930 --> 00:08:43,280
in more of the robust sophisticated API

00:08:41,780 --> 00:08:45,350
gateways you get some of these right out

00:08:43,280 --> 00:08:47,450
of the box there's been a number of good

00:08:45,350 --> 00:08:49,880
ole off top ten type presentations at

00:08:47,450 --> 00:08:51,410
this conference and

00:08:49,880 --> 00:08:53,030
you know they've talked about cross-site

00:08:51,410 --> 00:08:55,010
scripting and aft reversal and open

00:08:53,030 --> 00:08:58,730
redirects in a lot of cases you get

00:08:55,010 --> 00:09:01,070
those types of mitigations for free so I

00:08:58,730 --> 00:09:04,940
will say that generally the API gateway

00:09:01,070 --> 00:09:07,580
is well-received by developers and

00:09:04,940 --> 00:09:09,530
operations folks but I think what's

00:09:07,580 --> 00:09:11,540
pretty common is the perception of

00:09:09,530 --> 00:09:13,250
security folks you know they're coming

00:09:11,540 --> 00:09:16,430
up with excessive or really just

00:09:13,250 --> 00:09:18,140
superfluous requirements and people are

00:09:16,430 --> 00:09:19,850
just naturally inclined at this point in

00:09:18,140 --> 00:09:22,670
time to sort of push back and reject

00:09:19,850 --> 00:09:24,110
these ideas from a security group like

00:09:22,670 --> 00:09:26,210
no matter what you're doing is just not

00:09:24,110 --> 00:09:28,880
quite good enough or just like a

00:09:26,210 --> 00:09:33,290
ridiculous password policy requirement

00:09:28,880 --> 00:09:35,840
and I will say that the API gateway it's

00:09:33,290 --> 00:09:38,540
a rare win win between developers and

00:09:35,840 --> 00:09:40,940
security and and partly it's because the

00:09:38,540 --> 00:09:42,770
Gateway it's not a complex integration

00:09:40,940 --> 00:09:44,240
you could take an API that you've never

00:09:42,770 --> 00:09:48,110
even thought about using the Gateway

00:09:44,240 --> 00:09:50,240
with and wrap it how often do you have a

00:09:48,110 --> 00:09:52,400
security control that actually reduces

00:09:50,240 --> 00:09:54,710
the amount of code that a developer has

00:09:52,400 --> 00:09:56,750
to write and how often do you have a

00:09:54,710 --> 00:09:59,600
security control that speeds up it

00:09:56,750 --> 00:10:01,550
increases the time to production so that

00:09:59,600 --> 00:10:03,800
I mean that's that's what's different

00:10:01,550 --> 00:10:06,050
about the API gateway and I think about

00:10:03,800 --> 00:10:07,460
this in terms of boilerplate code and

00:10:06,050 --> 00:10:09,530
that's the code that developers will

00:10:07,460 --> 00:10:11,300
write from app to app and it's very

00:10:09,530 --> 00:10:12,710
similar they may have to make just

00:10:11,300 --> 00:10:17,080
slight adjustments because of the

00:10:12,710 --> 00:10:19,640
framework or the language that's in use

00:10:17,080 --> 00:10:21,440
that boilerplate code really goes away

00:10:19,640 --> 00:10:23,150
when you're using an API gateway at

00:10:21,440 --> 00:10:24,890
least some of it especially the security

00:10:23,150 --> 00:10:26,870
related boilerplate code because you can

00:10:24,890 --> 00:10:28,640
extract it and put it into the API

00:10:26,870 --> 00:10:31,550
gateway and then reuse it over and over

00:10:28,640 --> 00:10:33,110
again I like this definition here from

00:10:31,550 --> 00:10:34,880
Wikipedia about boilerplate code

00:10:33,110 --> 00:10:37,400
especially the last part where it says

00:10:34,880 --> 00:10:39,470
the need for boilerplate can be reduced

00:10:37,400 --> 00:10:43,250
through high-level mechanisms the API

00:10:39,470 --> 00:10:45,650
gateway is that high level mechanism so

00:10:43,250 --> 00:10:47,660
let's take a look at a real example of

00:10:45,650 --> 00:10:50,750
how an API gateway could help mitigate

00:10:47,660 --> 00:10:51,710
an application vulnerability like I said

00:10:50,750 --> 00:10:53,420
that there's been a lot of great

00:10:51,710 --> 00:10:55,580
presentations about the most common

00:10:53,420 --> 00:10:57,530
types of vulnerabilities like the ojas

00:10:55,580 --> 00:10:58,460
top ten I'm gonna look at one that's a

00:10:57,530 --> 00:11:00,620
little bit lesser-known

00:10:58,460 --> 00:11:02,480
and this is that same CSV formula

00:11:00,620 --> 00:11:04,490
injection example that I mentioned a

00:11:02,480 --> 00:11:06,500
minute ago at least this video is going

00:11:04,490 --> 00:11:08,960
to play you can see that I have the CSV

00:11:06,500 --> 00:11:11,390
file there and it has that command

00:11:08,960 --> 00:11:14,839
equals command with an R in der and then

00:11:11,390 --> 00:11:16,730
a directory I'm opening up that file and

00:11:14,839 --> 00:11:18,920
accepting the warning that Excel gives

00:11:16,730 --> 00:11:22,370
and you can see that that directory just

00:11:18,920 --> 00:11:25,070
magically disappeared that's CSV formula

00:11:22,370 --> 00:11:28,490
injection so how would you mitigate that

00:11:25,070 --> 00:11:30,620
at the API gateway level if you had an

00:11:28,490 --> 00:11:33,230
API that was returning CSV you could

00:11:30,620 --> 00:11:35,810
write a policy that's going to look for

00:11:33,230 --> 00:11:38,240
formulas which is any common delimited

00:11:35,810 --> 00:11:39,560
cell value where the first character is

00:11:38,240 --> 00:11:41,480
not just equal but there's some other

00:11:39,560 --> 00:11:43,670
ones as well you could parse the

00:11:41,480 --> 00:11:43,880
response and then you have a decision to

00:11:43,670 --> 00:11:46,010
make

00:11:43,880 --> 00:11:49,880
you could either send back an error or

00:11:46,010 --> 00:11:52,310
an exception or you could actually

00:11:49,880 --> 00:11:56,060
modify the actual response and return

00:11:52,310 --> 00:11:58,160
that and so that may not be the most

00:11:56,060 --> 00:11:59,420
common type of vulnerability but I

00:11:58,160 --> 00:12:02,720
thought it was an interesting exploit

00:11:59,420 --> 00:12:04,970
example is the API gave me gonna fix all

00:12:02,720 --> 00:12:07,250
your application security problems no it

00:12:04,970 --> 00:12:10,600
won't and prominent author Gary McGraw

00:12:07,250 --> 00:12:12,770
who used to be the CEO or CTO of Citadel

00:12:10,600 --> 00:12:14,720
he wrote about the myth of perimeter

00:12:12,770 --> 00:12:16,520
level security and that's what an API

00:12:14,720 --> 00:12:18,230
gateway is it is perimeter level

00:12:16,520 --> 00:12:20,330
security it's much like an intrusion

00:12:18,230 --> 00:12:22,580
protection system or it's a really

00:12:20,330 --> 00:12:24,410
specialized web application firewall

00:12:22,580 --> 00:12:27,200
it's not gonna fix all of your problems

00:12:24,410 --> 00:12:29,690
by any means but it's one part of the

00:12:27,200 --> 00:12:32,270
solution it you know it can provide

00:12:29,690 --> 00:12:35,030
authentication especially you know like

00:12:32,270 --> 00:12:36,800
Oh auth or or even verifying client

00:12:35,030 --> 00:12:41,360
certificates it can handle those things

00:12:36,800 --> 00:12:43,460
for you so practically how do you how do

00:12:41,360 --> 00:12:45,620
we actually use the API gateway we've

00:12:43,460 --> 00:12:48,050
been doing it for a couple years now at

00:12:45,620 --> 00:12:50,600
SAS and usually we choose one

00:12:48,050 --> 00:12:51,530
authentication type of policy you know

00:12:50,600 --> 00:12:54,410
we'll choose ooofff

00:12:51,530 --> 00:12:57,020
we've also integrated the API gateway

00:12:54,410 --> 00:12:59,089
with our identity provider our identity

00:12:57,020 --> 00:13:00,620
management solution and so we have a

00:12:59,089 --> 00:13:02,630
policy that we can use for that and then

00:13:00,620 --> 00:13:04,490
in some cases we will use basic auth or

00:13:02,630 --> 00:13:06,560
client certificates so you choose one

00:13:04,490 --> 00:13:08,209
authentication policy and then there is

00:13:06,560 --> 00:13:12,140
another set of policies that we always

00:13:08,209 --> 00:13:14,970
use rate limiting throttling basic types

00:13:12,140 --> 00:13:17,310
of validations for obviously militia

00:13:14,970 --> 00:13:20,730
requests like obvious cross-site

00:13:17,310 --> 00:13:22,680
scripting you know attempts will block

00:13:20,730 --> 00:13:24,540
that at the API gateway level for every

00:13:22,680 --> 00:13:27,420
single API and other things like

00:13:24,540 --> 00:13:29,100
cross-site request forgery as well and

00:13:27,420 --> 00:13:30,899
then we have these other policies like

00:13:29,100 --> 00:13:33,029
CSV formula injection that are kind of

00:13:30,899 --> 00:13:34,769
in our back pocket imagine if you have

00:13:33,029 --> 00:13:37,769
an application that's ready to go live

00:13:34,769 --> 00:13:39,839
you get a pen test report back there's a

00:13:37,769 --> 00:13:41,790
bunch of vulnerabilities it's nice to be

00:13:39,839 --> 00:13:45,389
able to say hey this is an API gateway

00:13:41,790 --> 00:13:48,149
wrapped API and so we can you just use

00:13:45,389 --> 00:13:50,250
this policy we can easily apply it and

00:13:48,149 --> 00:13:52,170
then mitigate that now maybe that's a

00:13:50,250 --> 00:13:53,939
short-term fix or the full-fledged fix

00:13:52,170 --> 00:13:56,160
you know it really depends on the the

00:13:53,939 --> 00:13:57,899
situation but it's nice instead of

00:13:56,160 --> 00:14:00,660
having to say you guys need to delay

00:13:57,899 --> 00:14:02,370
your production go live we can say hey

00:14:00,660 --> 00:14:06,899
use this policy and then you guys are

00:14:02,370 --> 00:14:08,310
good to go it's nice to have that on the

00:14:06,899 --> 00:14:11,430
left there that is the oh ah stop ten

00:14:08,310 --> 00:14:12,839
that's actually the 2013 list of it but

00:14:11,430 --> 00:14:15,449
you can see that the API gateway is

00:14:12,839 --> 00:14:16,439
helpful for many of those items but

00:14:15,449 --> 00:14:18,810
we're going to talk about the cloud

00:14:16,439 --> 00:14:20,490
native platform next and how that helps

00:14:18,810 --> 00:14:24,329
the security posture of this

00:14:20,490 --> 00:14:26,790
architecture as well these are the four

00:14:24,329 --> 00:14:28,589
aspects of a cloud native architecture

00:14:26,790 --> 00:14:31,350
and you can see that the platform is

00:14:28,589 --> 00:14:32,939
there behind it we talked about the API

00:14:31,350 --> 00:14:35,819
gateway as it relates to micro services

00:14:32,939 --> 00:14:38,459
already I'm going to get into DevOps and

00:14:35,819 --> 00:14:39,750
dev sec ops next and then talk about the

00:14:38,459 --> 00:14:41,309
role of the continuous integration

00:14:39,750 --> 00:14:43,199
system and then how that helps with

00:14:41,309 --> 00:14:46,379
upgrades and patching and also how the

00:14:43,199 --> 00:14:47,699
containers and choosing based images and

00:14:46,379 --> 00:14:49,589
in cloud foundry choosing your build

00:14:47,699 --> 00:14:54,180
packs wisely now that really helps with

00:14:49,589 --> 00:14:57,329
an effective upgrade strategy so the

00:14:54,180 --> 00:14:59,730
first is dev ops in dev sec ops my

00:14:57,329 --> 00:15:02,279
definition is that dev ops and powers

00:14:59,730 --> 00:15:04,949
developers to perform operations and

00:15:02,279 --> 00:15:07,079
also security tasks themselves but with

00:15:04,949 --> 00:15:08,610
guardrails so we're not fully turning

00:15:07,079 --> 00:15:10,620
over the reins we're not fully saying

00:15:08,610 --> 00:15:12,209
developers just do everything yourself

00:15:10,620 --> 00:15:15,269
I still believe in the separation of

00:15:12,209 --> 00:15:17,129
concerns and so I think that it makes

00:15:15,269 --> 00:15:19,050
sense to you know specialization of

00:15:17,129 --> 00:15:21,529
labor where you have experts in in each

00:15:19,050 --> 00:15:23,370
field but there are certain tasks that

00:15:21,529 --> 00:15:24,839
developers should be able to do

00:15:23,370 --> 00:15:27,580
themselves that in the past you know in

00:15:24,839 --> 00:15:29,830
a traditional architecture they couldn't

00:15:27,580 --> 00:15:31,660
a part of the reason that dev sack ops

00:15:29,830 --> 00:15:33,990
is possible is because of the cloud

00:15:31,660 --> 00:15:36,960
native platforms have such robust

00:15:33,990 --> 00:15:40,360
handling around infrastructure is code

00:15:36,960 --> 00:15:42,490
you can specify most of the metadata

00:15:40,360 --> 00:15:44,590
almost all of the metadata around an

00:15:42,490 --> 00:15:47,290
application in the yamo files or the

00:15:44,590 --> 00:15:47,740
json files for both kubernetes and Cloud

00:15:47,290 --> 00:15:50,610
Foundry

00:15:47,740 --> 00:15:53,560
and so developers can modify those files

00:15:50,610 --> 00:15:56,200
include them in their code base and and

00:15:53,560 --> 00:15:57,880
then make changes as necessary where

00:15:56,200 --> 00:16:00,730
they're then deployed you know with a

00:15:57,880 --> 00:16:02,860
button push click inside your continuous

00:16:00,730 --> 00:16:04,510
integration tool so that's

00:16:02,860 --> 00:16:06,130
infrastructure is code and sometimes I

00:16:04,510 --> 00:16:08,050
refer to this as security is code as

00:16:06,130 --> 00:16:10,180
well because you're putting some of the

00:16:08,050 --> 00:16:12,190
security controls right there in the

00:16:10,180 --> 00:16:15,460
code base as well at least the

00:16:12,190 --> 00:16:17,320
configuration aspect of it so the

00:16:15,460 --> 00:16:18,970
platform's allowing developers to do

00:16:17,320 --> 00:16:20,740
things which typically in the past they

00:16:18,970 --> 00:16:23,440
had to open up tickets for and that's a

00:16:20,740 --> 00:16:26,550
part of the friction that DevOps is

00:16:23,440 --> 00:16:29,320
trying to eliminate DevOps is a way to

00:16:26,550 --> 00:16:30,700
help help developer and operations and

00:16:29,320 --> 00:16:33,250
security folks better collaborate with

00:16:30,700 --> 00:16:34,840
one another operations folks in the past

00:16:33,250 --> 00:16:36,910
would get bogged down with endless

00:16:34,840 --> 00:16:38,230
queues of tickets and then developers

00:16:36,910 --> 00:16:39,820
would get frustrated because they would

00:16:38,230 --> 00:16:41,860
be waiting for operational folks to

00:16:39,820 --> 00:16:45,040
implement those I mean it was not a good

00:16:41,860 --> 00:16:46,810
situation on either side but now with in

00:16:45,040 --> 00:16:48,220
with infrastructure as code developers

00:16:46,810 --> 00:16:50,170
can do those kinds of things themselves

00:16:48,220 --> 00:16:53,230
like basic things setting environment

00:16:50,170 --> 00:16:55,360
variables scaling the app just you know

00:16:53,230 --> 00:16:57,850
increasing the amount of memory saying I

00:16:55,360 --> 00:16:59,950
want five load balanced instances of

00:16:57,850 --> 00:17:01,900
this application you can do all those

00:16:59,950 --> 00:17:03,670
things really easily with the

00:17:01,900 --> 00:17:04,320
configurations and kubernetes in cloud

00:17:03,670 --> 00:17:06,790
foundry

00:17:04,320 --> 00:17:09,100
you can also developer can also do

00:17:06,790 --> 00:17:11,709
security tasks you know they can set

00:17:09,100 --> 00:17:15,370
security headers there's ways to

00:17:11,709 --> 00:17:18,400
integrate the tools with with your

00:17:15,370 --> 00:17:20,620
password vault and then even things like

00:17:18,400 --> 00:17:22,510
forcing SSL for the app those are all

00:17:20,620 --> 00:17:25,209
things developers can do themselves now

00:17:22,510 --> 00:17:26,650
with configuration this code so to give

00:17:25,209 --> 00:17:28,810
an example of that on the right I have a

00:17:26,650 --> 00:17:30,850
cloud foundry manifest file you can see

00:17:28,810 --> 00:17:32,770
where I've set the memory amount I've

00:17:30,850 --> 00:17:35,710
set the number of instances we're

00:17:32,770 --> 00:17:38,770
forcing HTTP a developer can change the

00:17:35,710 --> 00:17:40,690
URL whenever they want and on the Left I

00:17:38,770 --> 00:17:43,120
have an example of an engine next comp

00:17:40,690 --> 00:17:44,889
in the Cloud Foundry world they have a

00:17:43,120 --> 00:17:47,129
what's known as a static build pack

00:17:44,889 --> 00:17:50,259
which is really just a type of image and

00:17:47,129 --> 00:17:52,210
its engine necks based and so developers

00:17:50,259 --> 00:17:54,279
can set these files put them in their

00:17:52,210 --> 00:17:57,429
codebase and then change the response

00:17:54,279 --> 00:17:59,500
headers as needed for many teams in the

00:17:57,429 --> 00:18:01,539
past was the operations team that

00:17:59,500 --> 00:18:03,159
exclusively maintained configurations

00:18:01,539 --> 00:18:04,899
for things like an Apache server and

00:18:03,159 --> 00:18:06,070
that's where this would be done so you

00:18:04,899 --> 00:18:07,809
would have a ticket to the operations

00:18:06,070 --> 00:18:09,549
team in order to change those kinds of

00:18:07,809 --> 00:18:13,960
headers but again developers can now do

00:18:09,549 --> 00:18:16,149
that themselves you know the content

00:18:13,960 --> 00:18:17,889
security policy that's especially

00:18:16,149 --> 00:18:19,809
valuable for mitigating cross-site

00:18:17,889 --> 00:18:21,429
scripting and it is an example of one of

00:18:19,809 --> 00:18:23,470
those configurations that does seem to

00:18:21,429 --> 00:18:25,000
change on a regular basis so it actually

00:18:23,470 --> 00:18:28,840
makes sense for developers to be able to

00:18:25,000 --> 00:18:30,070
do that security task themselves now the

00:18:28,840 --> 00:18:33,309
next thing I want to talk about is the

00:18:30,070 --> 00:18:34,750
is tool in greater detail that stands

00:18:33,309 --> 00:18:37,960
for interactive application security

00:18:34,750 --> 00:18:39,879
testing we sometimes it's called a

00:18:37,960 --> 00:18:41,379
container runtime security agent and

00:18:39,879 --> 00:18:42,970
remember that these cloud native

00:18:41,379 --> 00:18:44,679
platforms are distributed in their

00:18:42,970 --> 00:18:46,840
multi-tenant and so you have

00:18:44,679 --> 00:18:48,549
applications you know running side by

00:18:46,840 --> 00:18:51,220
side on the same worker nodes

00:18:48,549 --> 00:18:52,960
similarly the I asked tools or this

00:18:51,220 --> 00:18:56,169
agent is running on you know it's

00:18:52,960 --> 00:18:58,389
running on each one of those nodes and

00:18:56,169 --> 00:19:00,820
so in a kubernetes environment this is

00:18:58,389 --> 00:19:02,710
the daemon set and by running all across

00:19:00,820 --> 00:19:04,960
the platform it's able to report

00:19:02,710 --> 00:19:06,970
continuously everything from application

00:19:04,960 --> 00:19:09,669
level vulnerabilities as far as

00:19:06,970 --> 00:19:11,860
third-party dependencies goes but also

00:19:09,669 --> 00:19:14,769
compliance issues like is the container

00:19:11,860 --> 00:19:17,049
running as root does it have access to

00:19:14,769 --> 00:19:17,679
the you know the file system could have

00:19:17,049 --> 00:19:20,830
write access

00:19:17,679 --> 00:19:22,990
can it access host resources can ask can

00:19:20,830 --> 00:19:24,909
it access like the host network for

00:19:22,990 --> 00:19:27,429
example which would be a big security

00:19:24,909 --> 00:19:29,200
red flag the ayatollahs goes is going to

00:19:27,429 --> 00:19:33,009
report on all of those things and give

00:19:29,200 --> 00:19:34,389
that feedback pod security policies

00:19:33,009 --> 00:19:36,039
especially for kubernetes are so

00:19:34,389 --> 00:19:37,840
important and also the security context

00:19:36,039 --> 00:19:40,409
as well that's another thing that the is

00:19:37,840 --> 00:19:43,059
tool is looking at but it also provides

00:19:40,409 --> 00:19:45,700
things like malware protection now you

00:19:43,059 --> 00:19:47,379
may think you know at least our

00:19:45,700 --> 00:19:48,850
experience was we had these tools we've

00:19:47,379 --> 00:19:50,320
used them for a long times it provides

00:19:48,850 --> 00:19:53,590
malware protection file integrity

00:19:50,320 --> 00:19:53,950
monitoring and their websites for those

00:19:53,590 --> 00:19:56,110
two

00:19:53,950 --> 00:19:58,539
advertise that their support and work

00:19:56,110 --> 00:20:00,549
great in containerized environments with

00:19:58,539 --> 00:20:02,620
an actor you really dig into it you find

00:20:00,549 --> 00:20:04,750
that it's it's pretty difficult to take

00:20:02,620 --> 00:20:07,029
those traditional security tools and

00:20:04,750 --> 00:20:09,730
make them work with containers and so

00:20:07,029 --> 00:20:12,610
having a cloud native security testing

00:20:09,730 --> 00:20:14,830
tool is hugely important and that's what

00:20:12,610 --> 00:20:15,789
these container runtime agents are the

00:20:14,830 --> 00:20:17,169
other thing that they provide is

00:20:15,789 --> 00:20:18,730
detailed audit logging so if you're

00:20:17,169 --> 00:20:20,620
running in a regulated or highly

00:20:18,730 --> 00:20:23,919
compliant environment then that's that's

00:20:20,620 --> 00:20:25,240
absolutely absolutely essential now the

00:20:23,919 --> 00:20:26,830
thing about these tools that are running

00:20:25,240 --> 00:20:29,830
continuously is that you need somebody

00:20:26,830 --> 00:20:31,539
to actually look at the results and so

00:20:29,830 --> 00:20:34,320
this why it's so important to have a

00:20:31,539 --> 00:20:36,700
network of security champions having a

00:20:34,320 --> 00:20:39,190
group that has been educated about how

00:20:36,700 --> 00:20:42,250
to use the tools understand the findings

00:20:39,190 --> 00:20:44,830
triage the results mark items as false

00:20:42,250 --> 00:20:46,240
positives that's so important otherwise

00:20:44,830 --> 00:20:47,799
that the tool is reporting these

00:20:46,240 --> 00:20:51,580
findings and nobody does anything with

00:20:47,799 --> 00:20:53,289
it then and what's what's the point so

00:20:51,580 --> 00:20:56,529
the security champions is absolutely

00:20:53,289 --> 00:20:59,169
crucial next I want to talk about

00:20:56,529 --> 00:21:02,139
containers and how that impacts patch

00:20:59,169 --> 00:21:05,289
management so whisking with micro

00:21:02,139 --> 00:21:07,450
service based architectures you end up

00:21:05,289 --> 00:21:10,179
with a lot of applications and so you

00:21:07,450 --> 00:21:13,000
need a way to upgrade those applications

00:21:10,179 --> 00:21:15,159
and both for kubernetes and Cloud

00:21:13,000 --> 00:21:18,159
Foundry if you're strategic in the way

00:21:15,159 --> 00:21:19,360
that you whitelist those allowed images

00:21:18,159 --> 00:21:21,669
then you're going to be in much better

00:21:19,360 --> 00:21:23,710
shape Cloud Foundry sort of does this

00:21:21,669 --> 00:21:25,600
out of the box with our system of build

00:21:23,710 --> 00:21:27,909
packs Cloud Foundry and the people at

00:21:25,600 --> 00:21:29,440
pivotal release build packs for each

00:21:27,909 --> 00:21:32,799
major language so there's one for

00:21:29,440 --> 00:21:34,110
java.net Python and so on and every time

00:21:32,799 --> 00:21:37,269
that there's a security vulnerability

00:21:34,110 --> 00:21:40,059
which gets published as a CBE every time

00:21:37,269 --> 00:21:41,830
that comes out the folks at Cloud

00:21:40,059 --> 00:21:44,529
Foundry and the open source community is

00:21:41,830 --> 00:21:48,370
going to upgrade the build pack and then

00:21:44,529 --> 00:21:51,580
release that new version and so you know

00:21:48,370 --> 00:21:53,649
your company and what we do is we we at

00:21:51,580 --> 00:21:55,389
times customize those build packs and

00:21:53,649 --> 00:21:57,309
then we push them out to our different

00:21:55,389 --> 00:21:59,740
running environments and the great thing

00:21:57,309 --> 00:22:01,450
about build packs is that they come as

00:21:59,740 --> 00:22:04,210
an ordered list so you can have multiple

00:22:01,450 --> 00:22:05,950
Java build packs let's say put the

00:22:04,210 --> 00:22:07,480
latest and greatest there at the top and

00:22:05,950 --> 00:22:10,360
so next time an

00:22:07,480 --> 00:22:12,880
goes to push out a version Cloud Foundry

00:22:10,360 --> 00:22:15,340
will detect that it's a Java app use the

00:22:12,880 --> 00:22:17,320
latest Java build pack and automatically

00:22:15,340 --> 00:22:19,480
you know you've gotten the updates that

00:22:17,320 --> 00:22:20,950
way and the thing that I really like is

00:22:19,480 --> 00:22:23,770
that in the event of a critical

00:22:20,950 --> 00:22:25,360
vulnerability it's possible to roll out

00:22:23,770 --> 00:22:27,010
that build back to all of the

00:22:25,360 --> 00:22:29,170
applications at once so let's say that

00:22:27,010 --> 00:22:31,540
you have a hundred Java applications you

00:22:29,170 --> 00:22:33,730
can do a clean swap of that layer

00:22:31,540 --> 00:22:36,840
underneath and force those apps to

00:22:33,730 --> 00:22:38,670
restage and get the latest build pack

00:22:36,840 --> 00:22:40,300
I'm also going to talk about

00:22:38,670 --> 00:22:42,160
misconfigurations and about how

00:22:40,300 --> 00:22:46,170
whitelisting images can help avoid miss

00:22:42,160 --> 00:22:49,120
configurations so I want to compare

00:22:46,170 --> 00:22:51,370
Dockers of images versus Cloud Foundry

00:22:49,120 --> 00:22:53,590
build packs for a minute

00:22:51,370 --> 00:22:56,410
you know there's a real risk with docker

00:22:53,590 --> 00:22:58,720
images of just you know sprawling out of

00:22:56,410 --> 00:23:00,760
control there's there's docker

00:22:58,720 --> 00:23:02,830
registries you know various available

00:23:00,760 --> 00:23:04,360
you know I think the very first step

00:23:02,830 --> 00:23:07,660
that you can do in terms of having a

00:23:04,360 --> 00:23:11,470
good patch management upgrade process is

00:23:07,660 --> 00:23:13,210
to whitelist a set of images and that

00:23:11,470 --> 00:23:15,700
can be just you know at a bare minimum

00:23:13,210 --> 00:23:18,730
saying you know only use the official

00:23:15,700 --> 00:23:21,250
docker repositories only use those

00:23:18,730 --> 00:23:23,500
official ones that are blessed by docker

00:23:21,250 --> 00:23:25,870
that's a great starting point but what

00:23:23,500 --> 00:23:28,570
we found is that for containerized

00:23:25,870 --> 00:23:31,510
microservices you typically don't need a

00:23:28,570 --> 00:23:34,420
full-fledged OS you don't really need a

00:23:31,510 --> 00:23:37,090
full CentOS or a rel and that there are

00:23:34,420 --> 00:23:39,430
lightweight base images like Alpine

00:23:37,090 --> 00:23:41,260
which is a lightweight linux distro you

00:23:39,430 --> 00:23:43,330
can use those kinds of images which are

00:23:41,260 --> 00:23:45,370
significantly smaller and reduces the

00:23:43,330 --> 00:23:47,080
security footprint so that means that

00:23:45,370 --> 00:23:49,060
they're they're faster they use less

00:23:47,080 --> 00:23:51,670
disk space and once you start doing

00:23:49,060 --> 00:23:54,580
continuous security testing you'll see

00:23:51,670 --> 00:23:57,850
that over time there's way fewer issues

00:23:54,580 --> 00:24:00,820
with these lightweight slim images like

00:23:57,850 --> 00:24:03,310
alpine compared to the full-fledged OS

00:24:00,820 --> 00:24:05,860
versions like this Tomcat Alpine docker

00:24:03,310 --> 00:24:06,910
image is 15% the size and it's so much

00:24:05,860 --> 00:24:08,830
smaller and the security for any

00:24:06,910 --> 00:24:11,410
security footprint is so much smaller

00:24:08,830 --> 00:24:14,980
there's a it's a big win all around

00:24:11,410 --> 00:24:16,330
really so if you can't have a

00:24:14,980 --> 00:24:17,500
fine-grained whitelist

00:24:16,330 --> 00:24:19,870
if you can't have a fine-grained

00:24:17,500 --> 00:24:21,159
whitelist of your images at least like

00:24:19,870 --> 00:24:23,470
encouraging Alpine

00:24:21,159 --> 00:24:26,409
is a good step forward or another slim

00:24:23,470 --> 00:24:29,200
distribution there's Alpine images by

00:24:26,409 --> 00:24:33,519
the way for engine X and Java openjdk

00:24:29,200 --> 00:24:37,749
Python and the list goes on the other

00:24:33,519 --> 00:24:39,960
big win then go back here cuz it likes

00:24:37,749 --> 00:24:42,940
this slide better the other big win with

00:24:39,960 --> 00:24:45,429
white listing a set of images that you

00:24:42,940 --> 00:24:47,529
in void avoid miss configurations so in

00:24:45,429 --> 00:24:49,059
a traditional environment especially

00:24:47,529 --> 00:24:50,139
before you know ansible and puppet and

00:24:49,059 --> 00:24:53,080
technologies like that

00:24:50,139 --> 00:24:55,119
every environment was built custom with

00:24:53,080 --> 00:24:56,889
a lot of manual work and as a result

00:24:55,119 --> 00:24:59,889
there was a great potential for human

00:24:56,889 --> 00:25:02,279
error for example somebody may you know

00:24:59,889 --> 00:25:05,440
leave the Tomcat administrative console

00:25:02,279 --> 00:25:07,210
completely open and using default

00:25:05,440 --> 00:25:09,129
credentials those are the kind of

00:25:07,210 --> 00:25:10,989
exploits that you hear about in the wild

00:25:09,129 --> 00:25:13,570
in real environments and so by

00:25:10,989 --> 00:25:16,779
whitelisting a base set of images like

00:25:13,570 --> 00:25:19,059
using the Tomcat Alpine docker image

00:25:16,779 --> 00:25:21,429
those types of things are disabled by

00:25:19,059 --> 00:25:22,960
default it's secure by default and by

00:25:21,429 --> 00:25:24,820
minimizing the amount of customization

00:25:22,960 --> 00:25:26,049
to your docker images you're less likely

00:25:24,820 --> 00:25:28,210
to have these kinds of miss

00:25:26,049 --> 00:25:32,679
configuration issues that like I said

00:25:28,210 --> 00:25:35,499
cause real real issues alright next up

00:25:32,679 --> 00:25:36,940
is continuous integration and you know I

00:25:35,499 --> 00:25:38,409
imagine that people in the room have

00:25:36,940 --> 00:25:40,779
been using continuous integration tools

00:25:38,409 --> 00:25:43,479
for a long time who's been using CI for

00:25:40,779 --> 00:25:45,580
more than five years anybody anybody

00:25:43,479 --> 00:25:46,929
more than ten I think it was about ten

00:25:45,580 --> 00:25:48,519
years ago when I first started using

00:25:46,929 --> 00:25:50,289
continuous integration tools they've

00:25:48,519 --> 00:25:52,570
been around a while so why is this a

00:25:50,289 --> 00:25:54,519
core part of cloud native architectures

00:25:52,570 --> 00:25:58,259
I think what's special about cloud

00:25:54,519 --> 00:26:01,389
native is that they have very robust

00:25:58,259 --> 00:26:04,269
api's and CL eyes so you can go from

00:26:01,389 --> 00:26:06,609
zero to full production app just with

00:26:04,269 --> 00:26:08,710
the configuration metadata files there

00:26:06,609 --> 00:26:10,629
may be just a slight bit of initial set

00:26:08,710 --> 00:26:12,879
up on the platform itself but the

00:26:10,629 --> 00:26:14,889
application it can be fully automated

00:26:12,879 --> 00:26:16,659
and so that means what you're doing with

00:26:14,889 --> 00:26:19,479
your your application in terms of your

00:26:16,659 --> 00:26:21,279
CI setup is much different and I'm gonna

00:26:19,479 --> 00:26:24,039
show in the next slide here but you know

00:26:21,279 --> 00:26:26,200
you're doing things like pulling your

00:26:24,039 --> 00:26:27,999
secrets from your secure vault pushing

00:26:26,200 --> 00:26:29,919
out the app binding it with any

00:26:27,999 --> 00:26:32,440
dependencies that it needs to a database

00:26:29,919 --> 00:26:33,380
for example running your CI tools

00:26:32,440 --> 00:26:35,480
automatically

00:26:33,380 --> 00:26:36,890
I mean you can do a lot more with the

00:26:35,480 --> 00:26:38,510
cloud platform than you could in the

00:26:36,890 --> 00:26:40,280
past like with a traditional jetty or

00:26:38,510 --> 00:26:41,690
Tomcat where the really the best you

00:26:40,280 --> 00:26:42,770
could do is just push out a new version

00:26:41,690 --> 00:26:45,500
of the application

00:26:42,770 --> 00:26:47,810
now you can fully tear down and then

00:26:45,500 --> 00:26:48,860
redeploy so this is what that looks like

00:26:47,810 --> 00:26:51,890
think of your continuous integration

00:26:48,860 --> 00:26:53,360
tool as you know going out to your

00:26:51,890 --> 00:26:55,400
source code repository pulling the

00:26:53,360 --> 00:26:59,840
source code and it's running the static

00:26:55,400 --> 00:27:01,460
analysis tool and by the way you might

00:26:59,840 --> 00:27:04,070
be thinking well why aren't we using the

00:27:01,460 --> 00:27:06,260
I asked tool and so full disclosure a

00:27:04,070 --> 00:27:08,390
lot of the is tools are super expensive

00:27:06,260 --> 00:27:10,430
I mean you heard me describe how great

00:27:08,390 --> 00:27:12,350
they are and how they reduce manual

00:27:10,430 --> 00:27:15,350
efforts and so as you would probably

00:27:12,350 --> 00:27:17,360
expect they cost a lot of money and

00:27:15,350 --> 00:27:19,250
right now the is tools are relatively

00:27:17,360 --> 00:27:22,100
new in the market and we compared

00:27:19,250 --> 00:27:24,320
several of them and found that those I

00:27:22,100 --> 00:27:25,990
asked tools oftentimes don't do

00:27:24,320 --> 00:27:28,760
everything they don't do static analysis

00:27:25,990 --> 00:27:30,230
source composition analysis and dynamic

00:27:28,760 --> 00:27:32,630
unless you're willing to write a really

00:27:30,230 --> 00:27:34,190
big check and so you might still be

00:27:32,630 --> 00:27:36,740
doing security testing through your CI

00:27:34,190 --> 00:27:39,110
pipeline or maybe for you know extra

00:27:36,740 --> 00:27:40,970
verification you want to do that maybe

00:27:39,110 --> 00:27:44,180
you want to fail a build for example if

00:27:40,970 --> 00:27:45,770
there's a high severity finding so after

00:27:44,180 --> 00:27:47,120
the CI tool runs the static code

00:27:45,770 --> 00:27:48,620
analysis it's going to grab the

00:27:47,120 --> 00:27:50,060
artifacts maybe if you're using

00:27:48,620 --> 00:27:52,250
something like Nexus or other Factory

00:27:50,060 --> 00:27:54,020
and it's doing the composition analysis

00:27:52,250 --> 00:27:55,970
that's the SCA that's the third-party

00:27:54,020 --> 00:27:57,290
vulnerability checking and then it's

00:27:55,970 --> 00:27:59,630
going to programmatically reach out to

00:27:57,290 --> 00:28:01,400
your password vault push the application

00:27:59,630 --> 00:28:04,460
and then the final step is to bind that

00:28:01,400 --> 00:28:06,170
secret to the running application and

00:28:04,460 --> 00:28:07,910
I'm going to talk about secret scoping

00:28:06,170 --> 00:28:11,000
and segmentation in a minute but the

00:28:07,910 --> 00:28:14,210
idea here is that you are really

00:28:11,000 --> 00:28:15,950
limiting who can access that secret by

00:28:14,210 --> 00:28:17,960
binding it just to the application

00:28:15,950 --> 00:28:20,780
orange or in the case of kubernetes

00:28:17,960 --> 00:28:21,800
you're it's it's available through other

00:28:20,780 --> 00:28:24,040
apps that are running in the same

00:28:21,800 --> 00:28:24,040
namespace

00:28:25,150 --> 00:28:30,740
okay so micro services last but not

00:28:28,790 --> 00:28:32,720
least of the four aspects I'm going to

00:28:30,740 --> 00:28:35,360
talk about a lot of times people will

00:28:32,720 --> 00:28:37,550
find micro services by what they're not

00:28:35,360 --> 00:28:38,920
you know they're not monoliths micro

00:28:37,550 --> 00:28:41,110
services are independently deployable

00:28:38,920 --> 00:28:43,310
you might have

00:28:41,110 --> 00:28:46,100
microservices that are 10,000 lines of

00:28:43,310 --> 00:28:49,580
code instead of one big 100,000 plus

00:28:46,100 --> 00:28:51,680
line application and I think most groups

00:28:49,580 --> 00:28:54,140
have been doing micro services long

00:28:51,680 --> 00:28:57,890
enough where you know we've seen the

00:28:54,140 --> 00:28:58,870
pros and cons of this approach let's say

00:28:57,890 --> 00:29:01,640
that you have a security vulnerability

00:28:58,870 --> 00:29:03,200
with your monolith it can be like this

00:29:01,640 --> 00:29:06,290
18-wheeler here it can be really

00:29:03,200 --> 00:29:08,720
difficult in order to make a quick

00:29:06,290 --> 00:29:11,450
change a lot of times with monoliths

00:29:08,720 --> 00:29:13,370
there's tight coupling and as a result

00:29:11,450 --> 00:29:16,190
you have to do a pretty big set of

00:29:13,370 --> 00:29:18,530
regression testing and so it might take

00:29:16,190 --> 00:29:19,940
three months or six months in order to

00:29:18,530 --> 00:29:20,570
get that fix out to your production

00:29:19,940 --> 00:29:23,810
environment

00:29:20,570 --> 00:29:24,920
now with micro-services because they're

00:29:23,810 --> 00:29:27,380
independent and they're independent

00:29:24,920 --> 00:29:29,540
independently deployable it's likely

00:29:27,380 --> 00:29:31,970
that you can get those fixes out more

00:29:29,540 --> 00:29:36,260
quickly if it's an end it's just the one

00:29:31,970 --> 00:29:38,210
micro service that you need to update so

00:29:36,260 --> 00:29:39,380
that mean there's pros and cons here and

00:29:38,210 --> 00:29:41,210
we've already talked about the build

00:29:39,380 --> 00:29:43,190
pack or image strategy needed to help

00:29:41,210 --> 00:29:45,410
with the upgrade aspect but what about

00:29:43,190 --> 00:29:47,270
application level security controls I'm

00:29:45,410 --> 00:29:50,840
going to use the example of course

00:29:47,270 --> 00:29:53,810
headers here and you can see the diagram

00:29:50,840 --> 00:29:55,340
there the picture on the right you know

00:29:53,810 --> 00:29:56,390
they're juggling all these balls which

00:29:55,340 --> 00:29:58,130
is just like juggling lots of

00:29:56,390 --> 00:29:59,420
microservices and hopefully you can see

00:29:58,130 --> 00:30:01,100
the one on the left where they've

00:29:59,420 --> 00:30:03,140
dropped the one ball there I mean it's

00:30:01,100 --> 00:30:06,950
easy with there's complexity and

00:30:03,140 --> 00:30:09,890
managing lots of things so let's look at

00:30:06,950 --> 00:30:12,380
an example with cores so let's say that

00:30:09,890 --> 00:30:14,750
you have a monolith and it has some API

00:30:12,380 --> 00:30:16,940
endpoints and those API endpoints are

00:30:14,750 --> 00:30:18,230
being called from a browser from an

00:30:16,940 --> 00:30:20,630
application that's hosted from a

00:30:18,230 --> 00:30:23,090
different domain now the API is gonna

00:30:20,630 --> 00:30:25,610
have to return course headers because

00:30:23,090 --> 00:30:27,590
the browser all modern browsers enforce

00:30:25,610 --> 00:30:29,240
what's called the same origin policy you

00:30:27,590 --> 00:30:32,240
know if it sees something from evil.com

00:30:29,240 --> 00:30:34,430
it's gonna require some course headers

00:30:32,240 --> 00:30:36,760
coming back from the API to say that

00:30:34,430 --> 00:30:39,290
it's okay for evil comm to call your API

00:30:36,760 --> 00:30:40,970
now if you're implementing this you know

00:30:39,290 --> 00:30:43,160
your developer the quickest and easiest

00:30:40,970 --> 00:30:45,560
thing you can do as far as setting your

00:30:43,160 --> 00:30:47,900
course HTTP response headers is just set

00:30:45,560 --> 00:30:50,570
this star here in the gray just set it a

00:30:47,900 --> 00:30:51,470
star say everybody can call my API you

00:30:50,570 --> 00:30:54,050
know it's okay

00:30:51,470 --> 00:30:55,110
the monolith goes through penetration

00:30:54,050 --> 00:30:57,809
testing

00:30:55,110 --> 00:30:59,610
and the pentester says the the course

00:30:57,809 --> 00:31:02,400
headers their overly permissive this is

00:30:59,610 --> 00:31:04,200
not good this needs to be fixed and so

00:31:02,400 --> 00:31:06,150
the monolith a developers they're like

00:31:04,200 --> 00:31:08,880
cool we can fix this we can create a

00:31:06,150 --> 00:31:11,640
whitelist no problem done and so you

00:31:08,880 --> 00:31:13,320
have some custom course header custom

00:31:11,640 --> 00:31:15,390
course code that's within the

00:31:13,320 --> 00:31:18,630
application a few months later monolith

00:31:15,390 --> 00:31:20,460
becomes alone same thing but this time

00:31:18,630 --> 00:31:22,470
they're savvy they know about course

00:31:20,460 --> 00:31:24,360
they know about the security risks and

00:31:22,470 --> 00:31:24,929
as a result they think we're going to

00:31:24,360 --> 00:31:26,820
modularize

00:31:24,929 --> 00:31:29,030
we're gonna create a component and this

00:31:26,820 --> 00:31:32,040
is going to be elegant and reusable and

00:31:29,030 --> 00:31:34,610
so they make some bug fixes and they end

00:31:32,040 --> 00:31:37,140
up with a course filter at version 1.1

00:31:34,610 --> 00:31:39,540
six months later monolith c comes out

00:31:37,140 --> 00:31:40,679
there's another security pin test they

00:31:39,540 --> 00:31:42,419
realized that there were a couple of

00:31:40,679 --> 00:31:44,370
bugs maybe there was some functional

00:31:42,419 --> 00:31:47,730
bugs as well and they end up with

00:31:44,370 --> 00:31:50,700
version 1.3 so what do we have here we

00:31:47,730 --> 00:31:53,130
have really a security control and they

00:31:50,700 --> 00:31:55,770
now have three implementations of it so

00:31:53,130 --> 00:31:58,470
ideally you would be able just to take

00:31:55,770 --> 00:32:00,840
the one very good implementation the one

00:31:58,470 --> 00:32:03,870
that's most thorough and most secure and

00:32:00,840 --> 00:32:06,540
apply it to all of your applications and

00:32:03,870 --> 00:32:10,350
that really brings us full circle back

00:32:06,540 --> 00:32:12,000
to the api gateway that course code that

00:32:10,350 --> 00:32:14,130
is your boilerplate and you want to

00:32:12,000 --> 00:32:15,840
extract that into the Gateway especially

00:32:14,130 --> 00:32:18,929
as you have lots and lots of micro

00:32:15,840 --> 00:32:20,400
services so you can reuse the very good

00:32:18,929 --> 00:32:24,059
implementation the one that's very

00:32:20,400 --> 00:32:27,870
thorough so let's get into the cloud

00:32:24,059 --> 00:32:31,320
native platform sorry about the slides

00:32:27,870 --> 00:32:33,120
there so like I said the cloud platforms

00:32:31,320 --> 00:32:35,100
they are distributed they are multi

00:32:33,120 --> 00:32:36,660
tenant and so you have disparate

00:32:35,100 --> 00:32:39,330
applications that are running side by

00:32:36,660 --> 00:32:42,780
side in the same node this is not

00:32:39,330 --> 00:32:45,210
separate VMs we're talking the same the

00:32:42,780 --> 00:32:46,980
same instances right and so you have to

00:32:45,210 --> 00:32:49,020
leverage certain features within the

00:32:46,980 --> 00:32:51,690
cloud native platform in order to keep

00:32:49,020 --> 00:32:53,040
those apps safe and secure and so

00:32:51,690 --> 00:32:56,640
there's three types of segmentation

00:32:53,040 --> 00:32:59,220
there is micro segmentation network

00:32:56,640 --> 00:33:02,309
micro segmentation resource segmentation

00:32:59,220 --> 00:33:04,679
and also secret segmentation or secret

00:33:02,309 --> 00:33:06,150
scoping you need to leverage all three

00:33:04,679 --> 00:33:07,620
of those things in order to protect your

00:33:06,150 --> 00:33:09,990
api's imagine

00:33:07,620 --> 00:33:12,240
if you have one application that's

00:33:09,990 --> 00:33:14,100
running and there's a memory leak or

00:33:12,240 --> 00:33:17,030
maybe there's an active exploit going on

00:33:14,100 --> 00:33:20,460
and it's sucking up all the memory there

00:33:17,030 --> 00:33:22,110
you need that resource segmentation you

00:33:20,460 --> 00:33:25,950
need to be able to define resource

00:33:22,110 --> 00:33:27,540
limits you need to be able to find those

00:33:25,950 --> 00:33:29,160
resources and so that that one

00:33:27,540 --> 00:33:32,910
misbehaving app isn't going to suck up

00:33:29,160 --> 00:33:35,430
all the memory similar we need micro

00:33:32,910 --> 00:33:38,340
segmentation into place often times with

00:33:35,430 --> 00:33:40,380
these cloud platforms they're sharing IP

00:33:38,340 --> 00:33:42,840
addresses and so you have multiple apps

00:33:40,380 --> 00:33:45,570
that are being served up from the same

00:33:42,840 --> 00:33:47,910
IP address and say your conventional

00:33:45,570 --> 00:33:50,730
approach to firewalls and firewall

00:33:47,910 --> 00:33:52,980
handling may not work depending on the

00:33:50,730 --> 00:33:54,750
type of firewall that you have and so

00:33:52,980 --> 00:33:56,610
the platform's have Network micro

00:33:54,750 --> 00:33:58,679
segmentation built into them in Cloud

00:33:56,610 --> 00:34:00,750
Foundry it's called a SGS or application

00:33:58,679 --> 00:34:06,450
security groups and kubernetes that's

00:34:00,750 --> 00:34:07,200
called network policies all right and

00:34:06,450 --> 00:34:09,090
I'm going to talk about the

00:34:07,200 --> 00:34:10,860
orchestration engine as well and how

00:34:09,090 --> 00:34:12,780
that offers protections against denial

00:34:10,860 --> 00:34:16,169
of service protection the orchestration

00:34:12,780 --> 00:34:17,820
engines are constantly evaluating your

00:34:16,169 --> 00:34:19,980
running applications and how many

00:34:17,820 --> 00:34:22,919
instances or replicas you've requested

00:34:19,980 --> 00:34:25,200
so maybe you requested you know three

00:34:22,919 --> 00:34:26,520
instances and that's the desired it's

00:34:25,200 --> 00:34:28,590
going to constantly the platform's

00:34:26,520 --> 00:34:30,990
constantly checking the actual number

00:34:28,590 --> 00:34:33,330
and it's going to try to reconcile any

00:34:30,990 --> 00:34:35,190
differences between the two so in the

00:34:33,330 --> 00:34:37,350
event that an application actually falls

00:34:35,190 --> 00:34:38,669
over one of those instances it runs out

00:34:37,350 --> 00:34:40,770
of memory or there's some kind of issue

00:34:38,669 --> 00:34:42,600
with it it's just gonna spawn up another

00:34:40,770 --> 00:34:48,240
one and the platform's do that within

00:34:42,600 --> 00:34:51,330
seconds microseconds it's very fast okay

00:34:48,240 --> 00:34:53,040
so in a second I'm going to show a more

00:34:51,330 --> 00:34:56,820
zoomed in view of the cloud native

00:34:53,040 --> 00:34:59,010
platform I'm going to show two different

00:34:56,820 --> 00:35:01,560
api's that are running in separate

00:34:59,010 --> 00:35:04,290
kubernetes namespaces and we're using

00:35:01,560 --> 00:35:08,010
the segmentation features built-in so

00:35:04,290 --> 00:35:09,990
imagine that you have one of the api's

00:35:08,010 --> 00:35:11,820
that's trying to make an external call

00:35:09,990 --> 00:35:14,970
to a database you're gonna whitelist

00:35:11,820 --> 00:35:16,920
that with your kubernetes network policy

00:35:14,970 --> 00:35:19,980
to actually call out that it's allowed

00:35:16,920 --> 00:35:21,450
for that connection to occur but that

00:35:19,980 --> 00:35:23,430
application doesn't need to get

00:35:21,450 --> 00:35:25,050
any other databases it doesn't need to

00:35:23,430 --> 00:35:30,450
make any other outbound connections and

00:35:25,050 --> 00:35:32,869
so why should it be allowed to so now

00:35:30,450 --> 00:35:34,980
imagine that you have another API and

00:35:32,869 --> 00:35:36,780
somehow it has malware that's

00:35:34,980 --> 00:35:39,089
successfully running on it so there was

00:35:36,780 --> 00:35:41,190
a there was you know file uploaded a

00:35:39,089 --> 00:35:43,079
malware is running and what that malware

00:35:41,190 --> 00:35:46,500
is trying to do is data exfiltration

00:35:43,079 --> 00:35:48,450
it's actually trying to steal data that

00:35:46,500 --> 00:35:50,339
that api or you know maybe the file

00:35:48,450 --> 00:35:51,900
system and it's trying to send that out

00:35:50,339 --> 00:35:54,270
you know to evil.com

00:35:51,900 --> 00:35:56,369
or some other site if you have network

00:35:54,270 --> 00:35:58,740
segmentation in place then those kinds

00:35:56,369 --> 00:36:00,210
of outbound connections to some random

00:35:58,740 --> 00:36:02,970
website is going to be blocked by

00:36:00,210 --> 00:36:05,040
default similarly for a resource

00:36:02,970 --> 00:36:08,640
segmentation you know you're going to

00:36:05,040 --> 00:36:11,250
allocate a set of you know memory and

00:36:08,640 --> 00:36:14,970
other resources both to the segment's

00:36:11,250 --> 00:36:16,290
and the individual api's and by doing

00:36:14,970 --> 00:36:17,550
that you're going to make sure that one

00:36:16,290 --> 00:36:19,980
of those isn't going to suck up all the

00:36:17,550 --> 00:36:22,200
resources and call system degradation on

00:36:19,980 --> 00:36:27,690
some API that's running on the exact

00:36:22,200 --> 00:36:30,150
same worker node of the platform and so

00:36:27,690 --> 00:36:32,160
lastly I'll talk about the third type of

00:36:30,150 --> 00:36:34,680
segmentation which is secret

00:36:32,160 --> 00:36:36,750
segmentation really I think more

00:36:34,680 --> 00:36:39,060
commonly referred to secret scoping and

00:36:36,750 --> 00:36:40,530
so with the name spaces in kubernetes

00:36:39,060 --> 00:36:45,150
and Cloud Foundry has something similar

00:36:40,530 --> 00:36:47,880
when you create a secret it is it's only

00:36:45,150 --> 00:36:50,400
accessible by applications in the same

00:36:47,880 --> 00:36:54,240
namespace so other apps aren't able to

00:36:50,400 --> 00:36:56,579
access that secret and that that

00:36:54,240 --> 00:36:58,770
prevents you know a breach if you

00:36:56,579 --> 00:37:00,599
imagine like a traditional system there

00:36:58,770 --> 00:37:02,220
we go that's on the Left where you have

00:37:00,599 --> 00:37:03,900
lots of applications that are running on

00:37:02,220 --> 00:37:06,660
the shared server you know without the

00:37:03,900 --> 00:37:08,970
segmentation features there's more risks

00:37:06,660 --> 00:37:13,589
that those applications can get to one

00:37:08,970 --> 00:37:16,290
of those secrets so using namespaces you

00:37:13,589 --> 00:37:19,680
know strategically is a great way really

00:37:16,290 --> 00:37:21,630
to limit what what can happen in a

00:37:19,680 --> 00:37:23,130
worst-case type of breach these network

00:37:21,630 --> 00:37:25,619
segmentation resource Eggman tation

00:37:23,130 --> 00:37:27,839
that's really gonna save your bacon in

00:37:25,619 --> 00:37:30,089
the event that you have malware or some

00:37:27,839 --> 00:37:31,440
other exploit actually happening it's

00:37:30,089 --> 00:37:34,750
going to minimize the scope and

00:37:31,440 --> 00:37:36,370
potential of what that breach can do

00:37:34,750 --> 00:37:38,440
and so the last one I'm going to talk

00:37:36,370 --> 00:37:40,630
about is the orchestration itself there

00:37:38,440 --> 00:37:42,610
is a common this is a no-loss top ten

00:37:40,630 --> 00:37:45,370
vulnerability called XML entity

00:37:42,610 --> 00:37:46,780
expansion and down here I have an XML

00:37:45,370 --> 00:37:49,840
snippet which is known as the billion

00:37:46,780 --> 00:37:51,160
laughs attack so if you send this XML

00:37:49,840 --> 00:37:54,790
into an XML parser

00:37:51,160 --> 00:37:57,040
it's gonna continuously expand these

00:37:54,790 --> 00:37:58,630
entities to the point where a typical

00:37:57,040 --> 00:38:00,460
application is going to run out of

00:37:58,630 --> 00:38:02,770
memory and it's gonna crash

00:38:00,460 --> 00:38:04,960
but because the orchestration engine is

00:38:02,770 --> 00:38:06,970
constantly scanning and looking at the

00:38:04,960 --> 00:38:08,770
desired state versus the actual state

00:38:06,970 --> 00:38:10,240
let's say that you have three replicas

00:38:08,770 --> 00:38:13,030
it's going to detect

00:38:10,240 --> 00:38:14,470
with one falls over I have tested this

00:38:13,030 --> 00:38:17,170
it's one of the fun parts of my job

00:38:14,470 --> 00:38:18,910
you know I tested this on actually Cloud

00:38:17,170 --> 00:38:21,580
Foundry and there was no downtime

00:38:18,910 --> 00:38:23,560
whatsoever instances were falling over

00:38:21,580 --> 00:38:26,620
but they were immediately being respond

00:38:23,560 --> 00:38:28,480
back up and so this is sort of the you

00:38:26,620 --> 00:38:31,180
know you get this kind of protection for

00:38:28,480 --> 00:38:39,040
free because of that constant health

00:38:31,180 --> 00:38:42,130
checking and the respawning all right so

00:38:39,040 --> 00:38:44,070
we've so to summarize we've talked about

00:38:42,130 --> 00:38:46,600
the API gateway and how that can

00:38:44,070 --> 00:38:48,730
mitigate common application level

00:38:46,600 --> 00:38:50,350
security vulnerabilities we've talked

00:38:48,730 --> 00:38:51,610
about the segmentation features and how

00:38:50,350 --> 00:38:54,520
that's so important when you have a

00:38:51,610 --> 00:38:56,620
multi-tenant distributed platform talked

00:38:54,520 --> 00:38:59,500
about the I asked tools and if your

00:38:56,620 --> 00:39:01,810
company can afford it the how that just

00:38:59,500 --> 00:39:05,380
streamlines security testing and gives

00:39:01,810 --> 00:39:06,910
you that continuous feedback now what

00:39:05,380 --> 00:39:09,430
we're getting out here is to get fast

00:39:06,910 --> 00:39:10,900
feedback to the developers so they know

00:39:09,430 --> 00:39:12,490
about the security of their applications

00:39:10,900 --> 00:39:14,170
to me that's a big part of dev sec ops

00:39:12,490 --> 00:39:16,660
and ultimately we want to help

00:39:14,170 --> 00:39:19,060
developers quickly deploy secure

00:39:16,660 --> 00:39:21,880
production ready applications so I

00:39:19,060 --> 00:39:26,200
wanted to finish up with just a few

00:39:21,880 --> 00:39:28,930
thoughts about def sec ops originally

00:39:26,200 --> 00:39:30,880
was been a couple years now we defined a

00:39:28,930 --> 00:39:33,280
network of security champions and I

00:39:30,880 --> 00:39:36,160
think that's absolutely essential if

00:39:33,280 --> 00:39:39,010
you're if you're aspiring moving towards

00:39:36,160 --> 00:39:42,220
dev sec ops you need a network for

00:39:39,010 --> 00:39:43,990
communication and a part of that is

00:39:42,220 --> 00:39:46,600
because security groups are often very

00:39:43,990 --> 00:39:48,080
much outnumbered right you have small

00:39:46,600 --> 00:39:49,790
security and compliance team

00:39:48,080 --> 00:39:53,600
in lots and lots of developers and

00:39:49,790 --> 00:39:54,710
operations folks at a typical company so

00:39:53,600 --> 00:39:57,350
having this network of security

00:39:54,710 --> 00:39:59,300
champions is so important so you can get

00:39:57,350 --> 00:40:02,060
out application security initiatives

00:39:59,300 --> 00:40:04,520
like using an API gateway or like

00:40:02,060 --> 00:40:06,860
network segmentation you need that for

00:40:04,520 --> 00:40:08,720
communication purposes but I will tell

00:40:06,860 --> 00:40:11,060
you that when I initially form that

00:40:08,720 --> 00:40:13,610
group I sort of imagined that it would

00:40:11,060 --> 00:40:16,250
be a lot of you know the security folks

00:40:13,610 --> 00:40:18,320
telling other people about how to secure

00:40:16,250 --> 00:40:21,940
their applications and I really realized

00:40:18,320 --> 00:40:25,040
now that that was hubris on my part

00:40:21,940 --> 00:40:26,810
what's turned out is that it's enabled

00:40:25,040 --> 00:40:28,850
relationship building and two-way

00:40:26,810 --> 00:40:31,820
communication and understanding the

00:40:28,850 --> 00:40:34,010
problems of other groups and so my

00:40:31,820 --> 00:40:38,390
advice for folks if you're moving

00:40:34,010 --> 00:40:41,450
towards DevOps is talk to people and

00:40:38,390 --> 00:40:44,050
listen and try to search for mutually

00:40:41,450 --> 00:40:47,510
beneficial solutions think of this as

00:40:44,050 --> 00:40:49,430
searching for the win-win I mentioned

00:40:47,510 --> 00:40:51,620
with the API gateway that's beneficial

00:40:49,430 --> 00:40:53,660
for developers because it reduces

00:40:51,620 --> 00:40:58,730
boilerplate code and you get these high

00:40:53,660 --> 00:41:00,830
quality reusable security controls you

00:40:58,730 --> 00:41:04,910
know that's a partnership that's that's

00:41:00,830 --> 00:41:06,500
a joint victory in a way similarly you

00:41:04,910 --> 00:41:09,710
know look to partner with operations

00:41:06,500 --> 00:41:11,330
understand their concerns which is hey

00:41:09,710 --> 00:41:12,920
this new architecture moving towards

00:41:11,330 --> 00:41:14,330
cloud native am I going to start getting

00:41:12,920 --> 00:41:16,130
called all the time in the middle of the

00:41:14,330 --> 00:41:17,600
night are there gonna be outages and

00:41:16,130 --> 00:41:19,640
admittedly there is definitely a

00:41:17,600 --> 00:41:22,310
learning curve with moving towards cloud

00:41:19,640 --> 00:41:23,990
native it takes time in education and

00:41:22,310 --> 00:41:27,350
going to conferences like this to learn

00:41:23,990 --> 00:41:31,010
about it I think but in many ways this

00:41:27,350 --> 00:41:33,320
is moving towards this platform it has

00:41:31,010 --> 00:41:36,230
simplified life for the operations folks

00:41:33,320 --> 00:41:38,210
in part because of the health checking

00:41:36,230 --> 00:41:40,220
and the respawning that helps with both

00:41:38,210 --> 00:41:42,110
availability for them so that they don't

00:41:40,220 --> 00:41:43,670
get called the mill the night and it's

00:41:42,110 --> 00:41:46,280
also great for security because we're

00:41:43,670 --> 00:41:49,340
protected sort of inherently against

00:41:46,280 --> 00:41:52,370
different types of security attacks and

00:41:49,340 --> 00:41:54,830
lastly the is tool and also you know

00:41:52,370 --> 00:41:56,840
coming using security tools that work

00:41:54,830 --> 00:41:59,720
well with the CI pipeline I think that's

00:41:56,840 --> 00:42:02,000
so important there's a lot of variance

00:41:59,720 --> 00:42:04,910
in terms of who runs security testing

00:42:02,000 --> 00:42:06,710
tools at various companies but whoever

00:42:04,910 --> 00:42:08,980
is running them you know make it as easy

00:42:06,710 --> 00:42:11,480
as possible on them if you think that

00:42:08,980 --> 00:42:13,310
you can do something in the name of

00:42:11,480 --> 00:42:14,630
security this is the right thing to do

00:42:13,310 --> 00:42:16,910
for security and so of course we're

00:42:14,630 --> 00:42:20,000
gonna do it you know that's a big

00:42:16,910 --> 00:42:22,130
mistake it's really about searching for

00:42:20,000 --> 00:42:24,980
these mutually beneficial solutions and

00:42:22,130 --> 00:42:27,260
I think by listening and actually trying

00:42:24,980 --> 00:42:29,780
to better collaborate which is what

00:42:27,260 --> 00:42:32,000
DevOps is all about you end up with

00:42:29,780 --> 00:42:36,980
better solutions and process this as

00:42:32,000 --> 00:42:40,340
well in the end and that is about it

00:42:36,980 --> 00:42:43,460
and I think we have a couple minutes if

00:42:40,340 --> 00:42:47,620
anybody has a question he'll try to

00:42:43,460 --> 00:42:47,620
answer yep

00:42:53,500 --> 00:42:58,040
yeah and if you want to talk to me

00:42:55,730 --> 00:43:00,140
afterwards and we looked at a lot of a

00:42:58,040 --> 00:43:04,240
lot of different solutions and so I can

00:43:00,140 --> 00:43:07,240
I can give you my thoughts about that

00:43:04,240 --> 00:43:07,240
okay

00:43:15,250 --> 00:43:21,500
yeah and so it's been a while but we did

00:43:18,260 --> 00:43:23,210
a comparison of multiple API gateways my

00:43:21,500 --> 00:43:25,790
understanding we didn't actually look at

00:43:23,210 --> 00:43:29,329
at Amazon's at the time my understanding

00:43:25,790 --> 00:43:31,640
that Amazon has a laughs you know Web

00:43:29,329 --> 00:43:35,480
Application Firewall and that their API

00:43:31,640 --> 00:43:37,520
gateway doesn't you know provide that

00:43:35,480 --> 00:43:38,809
same kind of security functionality so

00:43:37,520 --> 00:43:41,240
it might be a combination of those two

00:43:38,809 --> 00:43:44,540
but I'm speaking outside my knowledge

00:43:41,240 --> 00:43:55,299
now so I'm gonna stop any other

00:43:44,540 --> 00:43:57,520
questions and that's been something

00:43:55,299 --> 00:44:01,160
we've been working towards for sure

00:43:57,520 --> 00:44:03,650
automation actually is a part of what we

00:44:01,160 --> 00:44:06,740
consider infrastructure is is code and

00:44:03,650 --> 00:44:09,950
we're security is code we have a system

00:44:06,740 --> 00:44:11,410
where folks can create JSON files so

00:44:09,950 --> 00:44:14,000
that exists as a part of your codebase

00:44:11,410 --> 00:44:16,040
we have a continuous integration system

00:44:14,000 --> 00:44:17,839
where that's an artifact and then when

00:44:16,040 --> 00:44:22,430
we do when we go to deploy the app the

00:44:17,839 --> 00:44:24,530
api's it automatically applies that JSON

00:44:22,430 --> 00:44:26,869
file so this works really well in Cloud

00:44:24,530 --> 00:44:29,030
Foundry the Cloud Foundry mechanism for

00:44:26,869 --> 00:44:30,619
hooking up a proxy which is essentially

00:44:29,030 --> 00:44:32,420
what the API gateway is it's called a

00:44:30,619 --> 00:44:34,970
route Service Cloud Foundry route

00:44:32,420 --> 00:44:38,329
service and so you can programmatically

00:44:34,970 --> 00:44:40,430
configure the API gateway so the parts

00:44:38,329 --> 00:44:41,690
that are manual though and this is more

00:44:40,430 --> 00:44:44,450
of like a conversation between

00:44:41,690 --> 00:44:46,730
development and security it's about what

00:44:44,450 --> 00:44:48,170
security policies make sense so like I

00:44:46,730 --> 00:44:50,630
said you're choosing one authentication

00:44:48,170 --> 00:44:52,609
option and then you're always using some

00:44:50,630 --> 00:44:56,059
of these other policies that's the part

00:44:52,609 --> 00:44:57,650
that takes some time applying and like

00:44:56,059 --> 00:44:59,210
you know some API gateways allow you to

00:44:57,650 --> 00:45:01,400
simply drag-and-drop the policies you

00:44:59,210 --> 00:45:04,190
want or or they where they provide an

00:45:01,400 --> 00:45:06,500
API or CLI to apply whatever policies

00:45:04,190 --> 00:45:13,730
but it's really like the decision

00:45:06,500 --> 00:45:16,390
process is what takes time all right any

00:45:13,730 --> 00:45:16,390
other questions

00:45:16,740 --> 00:45:21,130
okay well thanks very much everybody for

00:45:19,869 --> 00:45:24,739
sticking around

00:45:21,130 --> 00:45:24,739

YouTube URL: https://www.youtube.com/watch?v=G4DFQgJYw3E


