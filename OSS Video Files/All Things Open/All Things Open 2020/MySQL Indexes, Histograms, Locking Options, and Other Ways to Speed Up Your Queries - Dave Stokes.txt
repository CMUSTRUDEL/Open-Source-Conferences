Title: MySQL Indexes, Histograms, Locking Options, and Other Ways to Speed Up Your Queries - Dave Stokes
Publication date: 2020-10-28
Playlist: All Things Open 2020
Description: 
	Presented by: Dave Stokes, Oracle
Presented at All Things Open 2020 - Extended Sessions Tracks

Abstract: Slow query? Add an index or two! But things are suddenly even slower! Indexes are great tools to speed data lookup but have overhead issues. Histograms donâ€™t have that overhead but may not be suited. And how you lock rows also effects performance. So what do you do to speed up queries smartly?
Captions: 
	00:00:05,440 --> 00:00:09,760
okay today we're talking about mysql

00:00:07,919 --> 00:00:12,080
indexes histograms and other ways to

00:00:09,760 --> 00:00:16,560
speed up your queries

00:00:12,080 --> 00:00:18,880
and uh let me

00:00:16,560 --> 00:00:20,240
tell you this is kind of a dry subject

00:00:18,880 --> 00:00:22,080
we'll get into that more later

00:00:20,240 --> 00:00:24,000
uh hi everyone my name is dave stokes i

00:00:22,080 --> 00:00:25,039
really miss not being at the real show

00:00:24,000 --> 00:00:28,000
this year

00:00:25,039 --> 00:00:29,519
uh it is a great experience because i've

00:00:28,000 --> 00:00:30,000
watched all things open grow from a

00:00:29,519 --> 00:00:32,480
couple hundred

00:00:30,000 --> 00:00:33,120
people to a couple thousand people uh it

00:00:32,480 --> 00:00:34,960
is an

00:00:33,120 --> 00:00:36,480
amazing event now if you need to get a

00:00:34,960 --> 00:00:38,559
hold of me uh i'm

00:00:36,480 --> 00:00:39,760
at stoker on twitter david.stokes

00:00:38,559 --> 00:00:44,239
oracle.com

00:00:39,760 --> 00:00:46,719
i'm a community manager for for uh

00:00:44,239 --> 00:00:48,480
for mysql products uh so oracle pays me

00:00:46,719 --> 00:00:50,879
to go around talking about

00:00:48,480 --> 00:00:52,399
uh mysql stuff except for this year

00:00:50,879 --> 00:00:55,920
where i don't get the travel is

00:00:52,399 --> 00:00:58,320
this much so let's uh

00:00:55,920 --> 00:01:00,520
go on to the next slide uh safe harbor

00:00:58,320 --> 00:01:04,239
agreement i am going to be speaking

00:01:00,520 --> 00:01:06,880
99.999 today about the open source

00:01:04,239 --> 00:01:08,400
community edition of the mysql server

00:01:06,880 --> 00:01:11,200
and related software

00:01:08,400 --> 00:01:13,119
uh it is free under the gpl version 2 or

00:01:11,200 --> 00:01:15,520
i should say it's licensed under the gpl

00:01:13,119 --> 00:01:19,360
version 2 which is a little more

00:01:15,520 --> 00:01:21,040
correct if i get off on a tangent during

00:01:19,360 --> 00:01:23,200
q and a

00:01:21,040 --> 00:01:24,799
about something that's coming out the

00:01:23,200 --> 00:01:26,240
safe harbor agreement basically says you

00:01:24,799 --> 00:01:27,920
can't hold me

00:01:26,240 --> 00:01:29,520
accountable to it because i don't have

00:01:27,920 --> 00:01:31,200
perfect knowledge of what's coming out

00:01:29,520 --> 00:01:32,640
uh so if i mention anything that's not

00:01:31,200 --> 00:01:35,840
an official product yet

00:01:32,640 --> 00:01:35,840
take it with a grain of salt

00:01:36,479 --> 00:01:40,720
so big warning if you're running mysql56

00:01:39,680 --> 00:01:44,079
the end of life

00:01:40,720 --> 00:01:46,000
is like february 5th of 2021

00:01:44,079 --> 00:01:47,840
that means you have five months to

00:01:46,000 --> 00:01:50,640
upgrade to five seven

00:01:47,840 --> 00:01:53,200
possibly hopefully i mean hopefully even

00:01:50,640 --> 00:01:55,520
better would be upgrade to my skill 8 0.

00:01:53,200 --> 00:01:56,399
i highly recommend that a lot of great

00:01:55,520 --> 00:01:58,479
features

00:01:56,399 --> 00:01:59,840
there so if you're running five six

00:01:58,479 --> 00:02:01,119
please plan to upgrade if you're running

00:01:59,840 --> 00:02:04,799
something earlier

00:02:01,119 --> 00:02:07,360
uh please upgrade asap

00:02:04,799 --> 00:02:08,879
uh by the way uh this is a new thing

00:02:07,360 --> 00:02:10,560
that came out this month

00:02:08,879 --> 00:02:12,160
you can now test drive the mysql

00:02:10,560 --> 00:02:15,040
database service for free

00:02:12,160 --> 00:02:16,480
uh if you sign up at this uh cloud slash

00:02:15,040 --> 00:02:19,200
free at oracle.com

00:02:16,480 --> 00:02:20,480
i get 300 in credits which will last you

00:02:19,200 --> 00:02:22,239
a long time

00:02:20,480 --> 00:02:23,920
uh by the way that mclaren i wish they

00:02:22,239 --> 00:02:25,599
were handing out those out to employees

00:02:23,920 --> 00:02:27,040
unfortunately if they are i haven't

00:02:25,599 --> 00:02:29,040
gotten mine yet

00:02:27,040 --> 00:02:31,760
but then amazon has been kind of late in

00:02:29,040 --> 00:02:36,879
deliveries in my area

00:02:31,760 --> 00:02:40,239
so what are we talking about today well

00:02:36,879 --> 00:02:42,000
this is a talk on things that you don't

00:02:40,239 --> 00:02:45,200
really uh

00:02:42,000 --> 00:02:48,560
see mentioned uh a lot

00:02:45,200 --> 00:02:49,760
uh in a lost rational logical manner uh

00:02:48,560 --> 00:02:51,360
first problem is that no one really

00:02:49,760 --> 00:02:52,560
complains when the database is running

00:02:51,360 --> 00:02:54,000
as it should

00:02:52,560 --> 00:02:57,200
um you'll never hear anyone complain

00:02:54,000 --> 00:02:59,519
that the database is too fast

00:02:57,200 --> 00:03:01,360
well what do we mean there well what

00:02:59,519 --> 00:03:03,200
happens is someone sends off a query

00:03:01,360 --> 00:03:04,400
and they either want it to come back

00:03:03,200 --> 00:03:07,680
faster

00:03:04,400 --> 00:03:09,280
or a little faster and

00:03:07,680 --> 00:03:10,560
if you start seeing stuff on the

00:03:09,280 --> 00:03:12,319
internet about speeding up queries you

00:03:10,560 --> 00:03:12,959
see a whole bunch of misinformation or a

00:03:12,319 --> 00:03:15,599
whole bunch of

00:03:12,959 --> 00:03:17,200
old information so we're going to talk

00:03:15,599 --> 00:03:18,080
to anybody how you speed up queries and

00:03:17,200 --> 00:03:21,120
it is not a

00:03:18,080 --> 00:03:23,440
harry potter like dark art there's no

00:03:21,120 --> 00:03:24,000
human sacrifices involved other than the

00:03:23,440 --> 00:03:26,080
dba

00:03:24,000 --> 00:03:28,720
sanity and they don't have a lot of that

00:03:26,080 --> 00:03:30,959
anyway so it's not a big loss there

00:03:28,720 --> 00:03:33,280
so the understanding of how to speed up

00:03:30,959 --> 00:03:36,000
query is what i want to stress today

00:03:33,280 --> 00:03:37,599
it is actually treated as magic a lot of

00:03:36,000 --> 00:03:40,879
the early dbas

00:03:37,599 --> 00:03:42,080
uh kind of treated it as sacred

00:03:40,879 --> 00:03:44,000
knowledge and we're not going to have

00:03:42,080 --> 00:03:46,159
passive on to the

00:03:44,000 --> 00:03:48,000
to the general public but we're going to

00:03:46,159 --> 00:03:49,680
talk about what goes on behind

00:03:48,000 --> 00:03:51,440
so today we're mainly looking at the

00:03:49,680 --> 00:03:53,840
proper use of indexes

00:03:51,440 --> 00:03:56,959
histograms locking options and some

00:03:53,840 --> 00:04:00,000
other ways to speed up queries

00:03:56,959 --> 00:04:02,239
well this is a dry subject how dry

00:04:00,000 --> 00:04:03,200
very dry we're talking saltine crackers

00:04:02,239 --> 00:04:06,640
in the sahara

00:04:03,200 --> 00:04:08,879
desert during the middle of august dry

00:04:06,640 --> 00:04:10,640
there's a lot of text on screen

00:04:08,879 --> 00:04:12,879
unfortunately when you

00:04:10,640 --> 00:04:14,400
give technical presentations after

00:04:12,879 --> 00:04:16,000
reviews

00:04:14,400 --> 00:04:17,840
that you get into it is that this was

00:04:16,000 --> 00:04:20,079
too much information and the other half

00:04:17,840 --> 00:04:22,800
will say this is not enough information

00:04:20,079 --> 00:04:24,160
so uh i recommend that you go out and

00:04:22,800 --> 00:04:26,080
download the slides i should say

00:04:24,160 --> 00:04:28,160
dave stokes instead of david m stokes

00:04:26,080 --> 00:04:29,280
there download the slides and use them

00:04:28,160 --> 00:04:32,320
as a reference

00:04:29,280 --> 00:04:32,720
uh later try not to absorb it all at

00:04:32,320 --> 00:04:35,520
once

00:04:32,720 --> 00:04:36,880
we're we're giving you a lot of medicine

00:04:35,520 --> 00:04:37,520
and you don't have to drink the entire

00:04:36,880 --> 00:04:40,880
bottle

00:04:37,520 --> 00:04:42,639
uh matter of fact it's better if you

00:04:40,880 --> 00:04:44,560
get through this get to a point where

00:04:42,639 --> 00:04:46,080
you literally say hey my brain is full

00:04:44,560 --> 00:04:47,280
and come back later and work through the

00:04:46,080 --> 00:04:49,759
rest of it

00:04:47,280 --> 00:04:50,560
and by the way database optimizations

00:04:49,759 --> 00:04:53,120
need

00:04:50,560 --> 00:04:53,680
to change over time as you're underlying

00:04:53,120 --> 00:04:55,919
data

00:04:53,680 --> 00:04:56,800
changes we're talking about changes in

00:04:55,919 --> 00:05:00,240
structure and

00:04:56,800 --> 00:05:03,120
changes in size what worked on tuesday

00:05:00,240 --> 00:05:05,120
may not work a year from tuesday

00:05:03,120 --> 00:05:06,320
unfortunately i can't cover a lot of

00:05:05,120 --> 00:05:09,280
territory that all

00:05:06,320 --> 00:05:10,080
does tails into this like system

00:05:09,280 --> 00:05:11,840
configuration

00:05:10,080 --> 00:05:13,280
on the operating system by the way the

00:05:11,840 --> 00:05:14,479
linux folks have been doing a lot of

00:05:13,280 --> 00:05:17,680
neat stuff

00:05:14,479 --> 00:05:19,360
that have been kind of helping the

00:05:17,680 --> 00:05:20,800
database world especially the open

00:05:19,360 --> 00:05:21,680
source database world

00:05:20,800 --> 00:05:26,000
also not going to talk about

00:05:21,680 --> 00:05:28,000
configuration of mysql my general

00:05:26,000 --> 00:05:29,440
general thing here is tell people uh set

00:05:28,000 --> 00:05:33,440
your inner db

00:05:29,440 --> 00:05:35,600
table cache size to 75 to 80

00:05:33,440 --> 00:05:36,960
of ram and go from there also not

00:05:35,600 --> 00:05:38,320
talking about hardware

00:05:36,960 --> 00:05:39,840
by the way there are two types of disk

00:05:38,320 --> 00:05:40,800
controllers and both will lie to you

00:05:39,840 --> 00:05:42,400
one's called

00:05:40,800 --> 00:05:44,080
right back one's called right through

00:05:42,400 --> 00:05:46,320
and they both give you bad information

00:05:44,080 --> 00:05:48,880
you don't really get good information

00:05:46,320 --> 00:05:50,400
and networking there's a whole bunch of

00:05:48,880 --> 00:05:53,120
problems with networking

00:05:50,400 --> 00:05:54,720
sharing your database server with your

00:05:53,120 --> 00:05:56,880
ldap server

00:05:54,720 --> 00:05:58,400
or something like that is a real mess

00:05:56,880 --> 00:05:59,759
and definitely don't share your database

00:05:58,400 --> 00:06:01,520
server with your mail server

00:05:59,759 --> 00:06:04,160
you run an email storm and everything

00:06:01,520 --> 00:06:06,560
just goes to heck

00:06:04,160 --> 00:06:07,199
also not covering normalizing your data

00:06:06,560 --> 00:06:09,120
um

00:06:07,199 --> 00:06:11,039
i i need to do a talk on normalizing the

00:06:09,120 --> 00:06:12,000
data properly hopefully for the next all

00:06:11,039 --> 00:06:14,560
things open

00:06:12,000 --> 00:06:16,080
we're all in raleigh uh basically

00:06:14,560 --> 00:06:17,120
normalizing your data

00:06:16,080 --> 00:06:19,759
make sure that you don't have any

00:06:17,120 --> 00:06:20,800
duplications in your data and you put

00:06:19,759 --> 00:06:23,199
out

00:06:20,800 --> 00:06:24,319
you chop up your data into logical

00:06:23,199 --> 00:06:25,840
groupings

00:06:24,319 --> 00:06:27,600
uh why do you do this well it makes

00:06:25,840 --> 00:06:30,240
things easier and more logical

00:06:27,600 --> 00:06:31,680
uh it hits the relational calculus and

00:06:30,240 --> 00:06:33,759
the symbolic logic

00:06:31,680 --> 00:06:34,960
a lot better and why am i telling you

00:06:33,759 --> 00:06:37,520
this well you can't build a

00:06:34,960 --> 00:06:38,720
scan skyscraper on a foundation of sand

00:06:37,520 --> 00:06:41,120
if your data is

00:06:38,720 --> 00:06:41,840
is laid out wrong uh nothing you're

00:06:41,120 --> 00:06:44,479
going to do

00:06:41,840 --> 00:06:45,440
is going to make it run better as i say

00:06:44,479 --> 00:06:46,639
down the bottom

00:06:45,440 --> 00:06:48,080
no matter how much training you give a

00:06:46,639 --> 00:06:49,680
docks it's not going to run faster than

00:06:48,080 --> 00:06:51,599
a thorough red horse

00:06:49,680 --> 00:06:52,960
so i recommend using the third normal

00:06:51,599 --> 00:06:55,120
form or better

00:06:52,960 --> 00:06:57,440
i like using json columns where you can

00:06:55,120 --> 00:06:59,680
have a full gigabyte of data

00:06:57,440 --> 00:07:00,639
for stub table data avoiding repeated

00:06:59,680 --> 00:07:03,520
and unneeded

00:07:00,639 --> 00:07:05,520
index and table dives what i mean there

00:07:03,520 --> 00:07:07,199
is that if you have

00:07:05,520 --> 00:07:08,639
a little it's like you want to get

00:07:07,199 --> 00:07:10,400
something about a customer and you have

00:07:08,639 --> 00:07:13,440
to go through the main customer table

00:07:10,400 --> 00:07:16,000
to a preferences table into

00:07:13,440 --> 00:07:17,520
a locale table and something like that

00:07:16,000 --> 00:07:19,039
each one of those is you have to go

00:07:17,520 --> 00:07:20,639
look up an index and then go into a

00:07:19,039 --> 00:07:22,240
table look up another index go into

00:07:20,639 --> 00:07:22,960
another table look up another index and

00:07:22,240 --> 00:07:25,520
finding

00:07:22,960 --> 00:07:26,960
your main table if you're doing that

00:07:25,520 --> 00:07:29,759
slightly to normalize your

00:07:26,960 --> 00:07:31,039
your data and use the json data type

00:07:29,759 --> 00:07:32,639
also you have to think about how you're

00:07:31,039 --> 00:07:34,319
going to use your data

00:07:32,639 --> 00:07:36,160
i see a lot of folks recording their

00:07:34,319 --> 00:07:36,880
data as time series and then they want

00:07:36,160 --> 00:07:40,400
to go back

00:07:36,880 --> 00:07:44,080
and look at it as oltp processing

00:07:40,400 --> 00:07:46,960
doesn't quite work that way

00:07:44,080 --> 00:07:48,319
now the optimizer is what we need to

00:07:46,960 --> 00:07:50,560
concentrate on

00:07:48,319 --> 00:07:52,319
uh consider the optimizer the brain and

00:07:50,560 --> 00:07:56,000
nervous system

00:07:52,319 --> 00:07:59,680
of of your compute of your database

00:07:56,000 --> 00:08:01,440
the optimizer is

00:07:59,680 --> 00:08:03,280
you'll find it in all modern databases

00:08:01,440 --> 00:08:06,560
and it wants to try to figure out the

00:08:03,280 --> 00:08:09,039
most efficient way to get your your data

00:08:06,560 --> 00:08:10,720
efficiency is defined by cost what is

00:08:09,039 --> 00:08:14,879
the cost well the cost

00:08:10,720 --> 00:08:18,240
is the amount of discretes 45 years ago

00:08:14,879 --> 00:08:21,919
disks were very slow very very expensive

00:08:18,240 --> 00:08:23,680
and the idea was to minimize duplication

00:08:21,919 --> 00:08:25,599
and the number of reads you had to do to

00:08:23,680 --> 00:08:28,720
get all your data

00:08:25,599 --> 00:08:32,320
so optimizers cost

00:08:28,720 --> 00:08:33,839
things out using historical data and

00:08:32,320 --> 00:08:35,519
they look at they do estimate some

00:08:33,839 --> 00:08:37,279
things like based on the cardinality of

00:08:35,519 --> 00:08:38,399
your row or the number of unique entries

00:08:37,279 --> 00:08:41,039
in the row

00:08:38,399 --> 00:08:41,519
and uh heroes find you can actually go

00:08:41,039 --> 00:08:43,680
out to the

00:08:41,519 --> 00:08:45,040
uh look at the mystical source code to

00:08:43,680 --> 00:08:49,040
see what the optimizer

00:08:45,040 --> 00:08:52,160
uh actually runs through stuff

00:08:49,040 --> 00:08:52,959
now the query optimizer looks at all the

00:08:52,160 --> 00:08:55,040
options

00:08:52,959 --> 00:08:56,399
it wants to find your data once again

00:08:55,040 --> 00:08:58,080
the cheapest way

00:08:56,399 --> 00:09:00,320
and since part of this is built on

00:08:58,080 --> 00:09:02,000
historical information it's like the gps

00:09:00,320 --> 00:09:03,440
on your phone or your car

00:09:02,000 --> 00:09:05,839
uh if i want to go to my favorite

00:09:03,440 --> 00:09:06,480
mexican restaurant it's left out of the

00:09:05,839 --> 00:09:09,120
driveway

00:09:06,480 --> 00:09:10,480
first right first left left across the

00:09:09,120 --> 00:09:13,920
railroad tracks

00:09:10,480 --> 00:09:17,680
and i'm there

00:09:13,920 --> 00:09:19,360
now the gps doesn't know there's a train

00:09:17,680 --> 00:09:21,120
parked across railroad tracks it doesn't

00:09:19,360 --> 00:09:22,480
know that there's some horizontal boring

00:09:21,120 --> 00:09:23,680
folks that have cut off the end of the

00:09:22,480 --> 00:09:26,080
road

00:09:23,680 --> 00:09:27,680
so it's you can see how in a similar way

00:09:26,080 --> 00:09:31,040
the optimizer can be

00:09:27,680 --> 00:09:34,240
misled by inserts of data

00:09:31,040 --> 00:09:35,680
and other changes now mysql unlike a

00:09:34,240 --> 00:09:37,360
database like oracle wants to

00:09:35,680 --> 00:09:40,720
re-optimize the query

00:09:37,360 --> 00:09:43,519
each time it sees it that can get

00:09:40,720 --> 00:09:44,480
messy for some folks by the way if that

00:09:43,519 --> 00:09:46,320
kind of bothers you

00:09:44,480 --> 00:09:48,080
look for the section on optimizer hints

00:09:46,320 --> 00:09:49,440
later in this presentation

00:09:48,080 --> 00:09:50,880
and by the way we're going to take a

00:09:49,440 --> 00:09:52,240
look and show you how to find the query

00:09:50,880 --> 00:09:54,880
plan and see what the optimizer

00:09:52,240 --> 00:09:54,880
wants to do

00:09:56,000 --> 00:10:02,839
so if you have five joins in your

00:09:59,839 --> 00:10:05,360
query the optimizer will try to figure

00:10:02,839 --> 00:10:10,079
out which one goes where

00:10:05,360 --> 00:10:10,079
best and this is five factorial

00:10:10,640 --> 00:10:15,760
number of options i can go through so

00:10:13,600 --> 00:10:18,079
that's 120 different options

00:10:15,760 --> 00:10:21,040
so you can see how this gets can

00:10:18,079 --> 00:10:22,959
potentially get messy quickly

00:10:21,040 --> 00:10:25,120
so how do you find the query plan well

00:10:22,959 --> 00:10:28,880
you run in a uh

00:10:25,120 --> 00:10:32,959
a then explain on your query

00:10:28,880 --> 00:10:33,920
now explain basically could take a full

00:10:32,959 --> 00:10:35,519
week or two

00:10:33,920 --> 00:10:37,519
to properly run you through i'm going to

00:10:35,519 --> 00:10:39,279
give you the highlights when in doubt go

00:10:37,519 --> 00:10:40,959
out and look at the optimization chapter

00:10:39,279 --> 00:10:42,240
in the mysql manual

00:10:40,959 --> 00:10:46,160
uh there are also books that i'll show

00:10:42,240 --> 00:10:49,279
you later that go through this very well

00:10:46,160 --> 00:10:50,320
explain basically is prepended on your

00:10:49,279 --> 00:10:52,399
query

00:10:50,320 --> 00:10:54,000
it used to be that it only worked on

00:10:52,399 --> 00:10:55,920
select so if you're trying to optimize

00:10:54,000 --> 00:10:58,480
an update you had to change it to select

00:10:55,920 --> 00:10:59,839
and put explain in front of that

00:10:58,480 --> 00:11:02,160
and here you can see the syntax and

00:10:59,839 --> 00:11:04,959
there's a lot going on here

00:11:02,160 --> 00:11:05,680
it gets very very um convoluted very

00:11:04,959 --> 00:11:07,600
quickly and

00:11:05,680 --> 00:11:09,120
uh of course the output is not exactly

00:11:07,600 --> 00:11:11,440
the easiest to read but we'll

00:11:09,120 --> 00:11:14,000
run you through it and give you a 5000

00:11:11,440 --> 00:11:15,519
foot overview

00:11:14,000 --> 00:11:17,040
but now for something completely

00:11:15,519 --> 00:11:18,240
different um

00:11:17,040 --> 00:11:21,920
there are many tools for looking at

00:11:18,240 --> 00:11:23,920
queries and they're all based on explain

00:11:21,920 --> 00:11:25,519
first there's the general explain and

00:11:23,920 --> 00:11:26,399
then there's the qualifier we change the

00:11:25,519 --> 00:11:28,160
format

00:11:26,399 --> 00:11:29,600
there's explain analyze and of course

00:11:28,160 --> 00:11:31,200
there's visual explaining for those who

00:11:29,600 --> 00:11:36,000
like mysql workbench

00:11:31,200 --> 00:11:38,240
uh by the way mysql8022 came out today

00:11:36,000 --> 00:11:39,440
so here's an example of looking at

00:11:38,240 --> 00:11:42,800
explain

00:11:39,440 --> 00:11:45,360
uh the top line is our query

00:11:42,800 --> 00:11:46,160
and what we've typed in there is explain

00:11:45,360 --> 00:11:48,640
that triggers

00:11:46,160 --> 00:11:49,200
uh running explain and our query that we

00:11:48,640 --> 00:11:52,320
want to look

00:11:49,200 --> 00:11:53,839
at is select star stars the shorthand

00:11:52,320 --> 00:11:56,240
for everything

00:11:53,839 --> 00:11:57,519
so we're selecting everything from the

00:11:56,240 --> 00:12:01,519
table city

00:11:57,519 --> 00:12:04,639
where the country code is equal to gbr

00:12:01,519 --> 00:12:06,480
now the details are

00:12:04,639 --> 00:12:09,040
it's going to come back and say id of

00:12:06,480 --> 00:12:11,440
one it's a simple query it's

00:12:09,040 --> 00:12:12,880
working on the table city there's no

00:12:11,440 --> 00:12:15,040
partitions it's going to use

00:12:12,880 --> 00:12:16,079
it has a type of reference that there's

00:12:15,040 --> 00:12:18,160
many types of queries

00:12:16,079 --> 00:12:20,079
uh we'll go in there in this case it's a

00:12:18,160 --> 00:12:21,440
reference and if you look down a couple

00:12:20,079 --> 00:12:22,480
of the world you see the reference is a

00:12:21,440 --> 00:12:25,200
constant and that's

00:12:22,480 --> 00:12:26,399
our country code of gbr and the

00:12:25,200 --> 00:12:28,320
optimizer comes out

00:12:26,399 --> 00:12:29,760
and does an estimate and it says we're

00:12:28,320 --> 00:12:31,279
going to have to read 81 rows to get

00:12:29,760 --> 00:12:32,880
that information

00:12:31,279 --> 00:12:34,399
and the filtered 100 will go in that a

00:12:32,880 --> 00:12:35,360
little bit more but it basically knows

00:12:34,399 --> 00:12:38,079
all the data

00:12:35,360 --> 00:12:39,519
in the table and knows how to get that

00:12:38,079 --> 00:12:43,440
part of this because it's using

00:12:39,519 --> 00:12:45,279
a a key or an index

00:12:43,440 --> 00:12:46,639
and it knows the number of entries in

00:12:45,279 --> 00:12:49,600
the index where

00:12:46,639 --> 00:12:50,720
the country code matches gbr now a

00:12:49,600 --> 00:12:53,279
little bit below

00:12:50,720 --> 00:12:53,760
uh or after it says one row and set one

00:12:53,279 --> 00:12:56,800
warning

00:12:53,760 --> 00:12:57,839
where it says note that is actually the

00:12:56,800 --> 00:12:59,760
query plan

00:12:57,839 --> 00:13:00,880
so it's going to go out and says okay

00:12:59,760 --> 00:13:04,320
we're going to go out and

00:13:00,880 --> 00:13:07,360
select world.city dot id

00:13:04,320 --> 00:13:08,880
world is the name of the schema or

00:13:07,360 --> 00:13:10,800
database that we're in city's the name

00:13:08,880 --> 00:13:12,240
of the table and id is the first column

00:13:10,800 --> 00:13:13,600
remember we have that asterisk up

00:13:12,240 --> 00:13:17,040
there's a wild card

00:13:13,600 --> 00:13:21,839
so it's going to name out each of the

00:13:17,040 --> 00:13:21,839
columns in the table

00:13:22,079 --> 00:13:27,920
okay visual explain this is a handy tool

00:13:26,240 --> 00:13:29,760
generally when you look at it it gives

00:13:27,920 --> 00:13:31,600
you different colored blocks

00:13:29,760 --> 00:13:33,279
green is good red is usually telling you

00:13:31,600 --> 00:13:35,519
it needs to take a look at it

00:13:33,279 --> 00:13:36,399
this is a little more information than

00:13:35,519 --> 00:13:38,000
what you saw

00:13:36,399 --> 00:13:39,440
in the previous slide but you'll see

00:13:38,000 --> 00:13:40,240
other ways how to get that information

00:13:39,440 --> 00:13:43,920
too

00:13:40,240 --> 00:13:43,920
and this is run on the same query

00:13:44,480 --> 00:13:50,160
now if we do format equals tree the the

00:13:48,000 --> 00:13:51,760
data comes out a little bit differently

00:13:50,160 --> 00:13:56,320
you get a tree structure

00:13:51,760 --> 00:14:00,000
as you see here select star from city

00:13:56,320 --> 00:14:01,040
here we're joining uh the table country

00:14:00,000 --> 00:14:02,800
and we're going to match them up where

00:14:01,040 --> 00:14:05,040
city population equals country

00:14:02,800 --> 00:14:07,920
population slightly different query

00:14:05,040 --> 00:14:10,399
and it's going to do a hash join uh

00:14:07,920 --> 00:14:13,600
traditionally mysql before 8 0

00:14:10,399 --> 00:14:14,079
17 or 18 did everything by a nested

00:14:13,600 --> 00:14:16,160
branch

00:14:14,079 --> 00:14:17,920
loop now we're doing a lot of hash joins

00:14:16,160 --> 00:14:20,560
much much much faster

00:14:17,920 --> 00:14:22,480
so it reads in the city tables

00:14:20,560 --> 00:14:24,320
information and then there's a hash join

00:14:22,480 --> 00:14:27,040
over in the country

00:14:24,320 --> 00:14:29,120
data of that and you can see here we

00:14:27,040 --> 00:14:31,279
actually have a cost estimate

00:14:29,120 --> 00:14:33,440
and the number of rows that it wants to

00:14:31,279 --> 00:14:33,440
read

00:14:33,519 --> 00:14:37,360
table scan on city which means it has to

00:14:36,560 --> 00:14:39,120
go through

00:14:37,360 --> 00:14:40,800
all the cities it's going to find there

00:14:39,120 --> 00:14:45,199
and it's going to do a table scan on

00:14:40,800 --> 00:14:47,199
country as part of it doing the hashes

00:14:45,199 --> 00:14:49,839
now if we do format equals json you get

00:14:47,199 --> 00:14:51,519
even more information

00:14:49,839 --> 00:14:53,279
this is the same query before we're

00:14:51,519 --> 00:14:54,639
joining city population in the country

00:14:53,279 --> 00:14:56,480
population

00:14:54,639 --> 00:14:57,839
uh it's going to give us the query cost

00:14:56,480 --> 00:15:00,560
it's going to tell us it has to do a

00:14:57,839 --> 00:15:04,639
nested loop on country

00:15:00,560 --> 00:15:05,839
and it's going to read 239 lines

00:15:04,639 --> 00:15:09,360
and it's going to give some various

00:15:05,839 --> 00:15:10,720
costs like the read cost evaluation cost

00:15:09,360 --> 00:15:12,639
it's going to tell us what columns it's

00:15:10,720 --> 00:15:15,839
going to need to read

00:15:12,639 --> 00:15:18,959
and we're going to use city to do

00:15:15,839 --> 00:15:20,639
the table city to do a hash join

00:15:18,959 --> 00:15:22,800
in that case what columns are using

00:15:20,639 --> 00:15:22,800
there

00:15:24,000 --> 00:15:28,560
now explains analyze came out 8018 all

00:15:27,120 --> 00:15:31,279
the explains you've seen up to now

00:15:28,560 --> 00:15:32,399
use historical information which is

00:15:31,279 --> 00:15:34,160
pretty good

00:15:32,399 --> 00:15:35,440
explain analyze actually goes out and

00:15:34,160 --> 00:15:37,600
runs your query

00:15:35,440 --> 00:15:38,959
so if you're running a query that goes

00:15:37,600 --> 00:15:40,639
out there and

00:15:38,959 --> 00:15:42,800
loads several petabytes worth of

00:15:40,639 --> 00:15:45,519
information you may not want to run this

00:15:42,800 --> 00:15:47,120
uh every other case i really enjoy this

00:15:45,519 --> 00:15:48,000
it actually goes out there and gives you

00:15:47,120 --> 00:15:51,360
the actual

00:15:48,000 --> 00:15:52,880
time and the actual data by the way if

00:15:51,360 --> 00:15:53,920
you run explain and then run explain

00:15:52,880 --> 00:15:57,279
analyze and see a

00:15:53,920 --> 00:15:59,199
difference in the results or the uh

00:15:57,279 --> 00:16:00,800
from the estimated to the real run

00:15:59,199 --> 00:16:03,600
analyze table

00:16:00,800 --> 00:16:04,320
on that table where the tables involved

00:16:03,600 --> 00:16:07,519
and

00:16:04,320 --> 00:16:08,639
update the statistics

00:16:07,519 --> 00:16:11,279
okay we're going to have a little bit

00:16:08,639 --> 00:16:14,320
more on using explain later but now

00:16:11,279 --> 00:16:15,839
let's jump over to indexes well

00:16:14,320 --> 00:16:18,079
indexes are probably the least

00:16:15,839 --> 00:16:21,199
understood part of

00:16:18,079 --> 00:16:22,639
database performance tuning according to

00:16:21,199 --> 00:16:24,240
wikipedia

00:16:22,639 --> 00:16:25,519
a database index is a data structure

00:16:24,240 --> 00:16:27,839
that improves the speed of data

00:16:25,519 --> 00:16:29,600
retrieval well how does it do that

00:16:27,839 --> 00:16:31,360
well basically what it does it takes the

00:16:29,600 --> 00:16:32,000
column that or columns that you're

00:16:31,360 --> 00:16:35,199
indexing

00:16:32,000 --> 00:16:36,000
and creates a mini table with just those

00:16:35,199 --> 00:16:39,199
values

00:16:36,000 --> 00:16:39,199
and then where to go get it

00:16:40,160 --> 00:16:44,560
and i like to think as a table with

00:16:42,320 --> 00:16:47,759
shortcuts to another table

00:16:44,560 --> 00:16:51,120
or a model of some of your data within

00:16:47,759 --> 00:16:51,759
a table and of course the more tables

00:16:51,120 --> 00:16:54,000
and more

00:16:51,759 --> 00:16:54,959
indexes you have to read and get the

00:16:54,000 --> 00:16:58,320
data

00:16:54,959 --> 00:17:01,120
uh the slower things run and uh

00:16:58,320 --> 00:17:02,720
databases love memory so the more memory

00:17:01,120 --> 00:17:04,240
you can throw in your database server

00:17:02,720 --> 00:17:06,240
the better

00:17:04,240 --> 00:17:07,919
best performance you can have is when

00:17:06,240 --> 00:17:11,039
the entire working set

00:17:07,919 --> 00:17:12,959
sits in memory it can get very expensive

00:17:11,039 --> 00:17:15,199
on a lot of machines and by the way use

00:17:12,959 --> 00:17:17,199
good error correcting memory

00:17:15,199 --> 00:17:19,919
so if everything's in memory you don't

00:17:17,199 --> 00:17:25,120
have to do disc greens

00:17:19,919 --> 00:17:25,120
and things will just absolutely scream

00:17:25,360 --> 00:17:29,840
now there are many many many types of

00:17:28,079 --> 00:17:31,520
indexes

00:17:29,840 --> 00:17:32,960
and i'm going to cover some of the most

00:17:31,520 --> 00:17:36,960
popular ones here and some

00:17:32,960 --> 00:17:40,640
options this is the

00:17:36,960 --> 00:17:44,799
syntax for create index as you can see

00:17:40,640 --> 00:17:47,919
you do create unique full text spatial

00:17:44,799 --> 00:17:51,280
unique basically means uh one value

00:17:47,919 --> 00:17:55,840
for that um that

00:17:51,280 --> 00:17:57,360
uh um

00:17:55,840 --> 00:17:59,360
oh what do i recommend is a good primer

00:17:57,360 --> 00:18:02,320
for learning sql

00:17:59,360 --> 00:18:03,200
um if you're mathematically involved cj

00:18:02,320 --> 00:18:05,760
dates

00:18:03,200 --> 00:18:07,039
uh primer on sql unfortunately i can't

00:18:05,760 --> 00:18:07,919
reach the book right here just get the

00:18:07,039 --> 00:18:10,320
title

00:18:07,919 --> 00:18:12,840
um also if you find a copy of the old

00:18:10,320 --> 00:18:16,240
mysql

00:18:12,840 --> 00:18:18,559
um certification guide

00:18:16,240 --> 00:18:20,799
rather than that i really don't have a

00:18:18,559 --> 00:18:20,799
uh

00:18:22,080 --> 00:18:25,720
i would say go out to your local the

00:18:23,760 --> 00:18:28,080
other thing is go to your local

00:18:25,720 --> 00:18:31,280
bookstore um

00:18:28,080 --> 00:18:31,600
and and grab a used book there and uh if

00:18:31,280 --> 00:18:32,799
this

00:18:31,600 --> 00:18:34,080
was written in the past seven years it

00:18:32,799 --> 00:18:36,400
should be a pretty good you know like

00:18:34,080 --> 00:18:39,440
myself in 24 hours or

00:18:36,400 --> 00:18:41,280
or um something like that so

00:18:39,440 --> 00:18:43,120
various options uh you're creating an

00:18:41,280 --> 00:18:43,919
index and you have to specify the table

00:18:43,120 --> 00:18:46,559
name

00:18:43,919 --> 00:18:49,760
and what you're indexing and of course

00:18:46,559 --> 00:18:51,039
there's a whole bunch of options

00:18:49,760 --> 00:18:55,360
you can say whether you're using a b

00:18:51,039 --> 00:18:58,400
tree or a hash other algorithms

00:18:55,360 --> 00:19:00,640
lock options and usually you just see

00:18:58,400 --> 00:19:01,919
create index as you'll see in a minute

00:19:00,640 --> 00:19:04,480
uh the table name and what you're

00:19:01,919 --> 00:19:04,480
indexing

00:19:08,400 --> 00:19:12,559
okay we're creating a table with a

00:19:10,720 --> 00:19:14,000
primary key so we're creating a table

00:19:12,559 --> 00:19:17,039
called t1

00:19:14,000 --> 00:19:17,919
our first column creatively called c1 is

00:19:17,039 --> 00:19:20,480
an integer

00:19:17,919 --> 00:19:21,360
uh not null we'll talk about nulls later

00:19:20,480 --> 00:19:23,679
auto increment

00:19:21,360 --> 00:19:25,360
for those you not used to mysql we don't

00:19:23,679 --> 00:19:28,240
have sequences so what happens

00:19:25,360 --> 00:19:29,280
is you set up a column to auto increment

00:19:28,240 --> 00:19:32,000
and the first

00:19:29,280 --> 00:19:33,520
value first data that goes in there gets

00:19:32,000 --> 00:19:35,760
the automaker value of

00:19:33,520 --> 00:19:36,559
one or whatever you pre-selected second

00:19:35,760 --> 00:19:39,200
one gets two

00:19:36,559 --> 00:19:40,799
the system keeps track of all this and

00:19:39,200 --> 00:19:45,919
notice in red there we've

00:19:40,799 --> 00:19:45,919
designated this as the primary key

00:19:46,000 --> 00:19:52,080
so inodb which is the default table

00:19:49,039 --> 00:19:54,960
type on on mysql

00:19:52,080 --> 00:19:57,039
these days uh really loves primary keys

00:19:54,960 --> 00:19:58,000
uh you'll force a key on you if you

00:19:57,039 --> 00:20:00,480
don't have one

00:19:58,000 --> 00:20:01,840
so we have a very simple table here and

00:20:00,480 --> 00:20:02,400
now whenever we want to look up

00:20:01,840 --> 00:20:05,120
something

00:20:02,400 --> 00:20:06,000
the database is hoping that you're going

00:20:05,120 --> 00:20:10,159
to try to use the

00:20:06,000 --> 00:20:13,280
primary key to get to that information

00:20:10,159 --> 00:20:16,880
by the way an index is a list of keys

00:20:13,280 --> 00:20:20,000
you'll see the terms key

00:20:16,880 --> 00:20:25,440
and index overused

00:20:20,000 --> 00:20:25,440
and uh mixed up and used interchangeably

00:20:26,240 --> 00:20:30,240
and uh that can get confusing by the way

00:20:28,240 --> 00:20:32,159
in the mysql world we have a lot of that

00:20:30,240 --> 00:20:33,919
you'll hear schema and database used

00:20:32,159 --> 00:20:35,360
interchangeably when it's technically a

00:20:33,919 --> 00:20:37,919
schema but we tend to use it as a

00:20:35,360 --> 00:20:37,919
database

00:20:38,559 --> 00:20:44,000
so the primary key this is a key

00:20:41,600 --> 00:20:44,960
that is you hopefully uniquely defined

00:20:44,000 --> 00:20:48,000
for a row

00:20:44,960 --> 00:20:49,919
and should be immutable in odb

00:20:48,000 --> 00:20:52,320
as i mentioned earlier knees a primary

00:20:49,919 --> 00:20:53,360
key if you don't specify one it will

00:20:52,320 --> 00:20:55,840
make one up for you

00:20:53,360 --> 00:20:57,919
and it's almost guaranteed it would it's

00:20:55,840 --> 00:21:01,760
not quite the one you want

00:20:57,919 --> 00:21:04,320
for high performance try not to use null

00:21:01,760 --> 00:21:06,080
values with the null values in a minute

00:21:04,320 --> 00:21:07,679
and also for those of you who really

00:21:06,080 --> 00:21:10,000
love uuids

00:21:07,679 --> 00:21:11,520
they're not a good choice for primary

00:21:10,000 --> 00:21:13,840
keys well why

00:21:11,520 --> 00:21:14,720
well they don't monotonically increase

00:21:13,840 --> 00:21:17,840
we're using b

00:21:14,720 --> 00:21:19,760
trees or actually b plus trees and they

00:21:17,840 --> 00:21:22,159
like things to increment

00:21:19,760 --> 00:21:23,280
in single units or multiples of single

00:21:22,159 --> 00:21:26,559
units

00:21:23,280 --> 00:21:28,159
uuids tend to jump around a lot and for

00:21:26,559 --> 00:21:30,640
therefore they're not very efficient

00:21:28,159 --> 00:21:32,000
being used as indexes in mysql

00:21:30,640 --> 00:21:34,640
however we do have a nice little

00:21:32,000 --> 00:21:36,559
function called uuid the bim

00:21:34,640 --> 00:21:40,159
which if you read up the man page on it

00:21:36,559 --> 00:21:43,360
will actually show you how to use uuid

00:21:40,159 --> 00:21:46,559
sort of a special

00:21:43,360 --> 00:21:47,679
way to use them as primary keys i i

00:21:46,559 --> 00:21:49,520
really don't

00:21:47,679 --> 00:21:52,080
recommend using uni ids but if you have

00:21:49,520 --> 00:21:53,520
to if it's the way your your architect

00:21:52,080 --> 00:21:56,480
to set things up

00:21:53,520 --> 00:21:56,480
that's the way to do it

00:21:56,960 --> 00:22:00,880
okay you can also index on the prefix of

00:22:00,080 --> 00:22:03,919
a column

00:22:00,880 --> 00:22:04,799
uh what i mean here um oftentimes you

00:22:03,919 --> 00:22:08,880
don't need

00:22:04,799 --> 00:22:11,280
to go back and index like all the uuid

00:22:08,880 --> 00:22:13,760
or maybe on a uuid uh here we're taking

00:22:11,280 --> 00:22:17,360
the first ten characters of a name

00:22:13,760 --> 00:22:18,080
uh probably last name and in places

00:22:17,360 --> 00:22:19,760
where

00:22:18,080 --> 00:22:22,080
most your names are saying like between

00:22:19,760 --> 00:22:23,760
six and twenty characters long

00:22:22,080 --> 00:22:25,760
uh this will save you some space and

00:22:23,760 --> 00:22:27,520
some and guarantee you some speed on

00:22:25,760 --> 00:22:29,760
looking for indexes

00:22:27,520 --> 00:22:31,120
um sometimes if you're doing something

00:22:29,760 --> 00:22:33,600
like on a city name

00:22:31,120 --> 00:22:35,520
uh most city names are relatively short

00:22:33,600 --> 00:22:38,960
and then you get into whales and

00:22:35,520 --> 00:22:41,120
all bets are off so in this case

00:22:38,960 --> 00:22:42,559
only the first 10 characters are indexed

00:22:41,120 --> 00:22:45,679
in this example

00:22:42,559 --> 00:22:46,159
uh it's also i've seen it used in supply

00:22:45,679 --> 00:22:49,600
chain

00:22:46,159 --> 00:22:52,480
where it's like the first 15 characters

00:22:49,600 --> 00:22:54,320
are the manufacturer where who the

00:22:52,480 --> 00:22:56,559
manufacturer is where it came from

00:22:54,320 --> 00:22:57,600
and the rough date number or order

00:22:56,559 --> 00:22:59,520
number that

00:22:57,600 --> 00:23:00,880
came in and then the rest of the

00:22:59,520 --> 00:23:03,120
information that you

00:23:00,880 --> 00:23:06,000
don't index on is more specific to that

00:23:03,120 --> 00:23:06,000
part or batch

00:23:07,600 --> 00:23:11,440
okay multi-column indexes uh here we

00:23:10,960 --> 00:23:14,240
have

00:23:11,440 --> 00:23:15,679
a simple little table called test uh by

00:23:14,240 --> 00:23:17,280
the way i do all these wonderfully

00:23:15,679 --> 00:23:19,039
creative names don't i

00:23:17,280 --> 00:23:20,880
uh what we're gonna do is we're gonna

00:23:19,039 --> 00:23:23,679
have a column for an id

00:23:20,880 --> 00:23:25,200
we're going to have a last name column a

00:23:23,679 --> 00:23:28,080
first name column

00:23:25,200 --> 00:23:28,799
and we have a primary key of id and then

00:23:28,080 --> 00:23:32,400
we have another

00:23:28,799 --> 00:23:35,520
index on last name and first name

00:23:32,400 --> 00:23:36,000
so when this where data gets added into

00:23:35,520 --> 00:23:39,840
this

00:23:36,000 --> 00:23:41,360
table it's going to

00:23:39,840 --> 00:23:43,840
take whatever you feed it for first name

00:23:41,360 --> 00:23:46,880
and last name and create an index

00:23:43,840 --> 00:23:49,679
entry for just that now

00:23:46,880 --> 00:23:52,080
this search searching on this index you

00:23:49,679 --> 00:23:54,480
can use it for last name and first name

00:23:52,080 --> 00:23:56,400
or just last name it works left to right

00:23:54,480 --> 00:23:59,360
uh you cannot search first name on

00:23:56,400 --> 00:24:00,240
on this if you're doing a index on your

00:23:59,360 --> 00:24:02,000
month date

00:24:00,240 --> 00:24:03,760
uh that index will work for your month

00:24:02,000 --> 00:24:04,720
date your month but it won't work for

00:24:03,760 --> 00:24:06,640
date

00:24:04,720 --> 00:24:08,159
uh won't work for a month uh it will

00:24:06,640 --> 00:24:10,480
work for a year

00:24:08,159 --> 00:24:14,559
and the big hint here is put your

00:24:10,480 --> 00:24:17,679
highest cardinality or the rarest

00:24:14,559 --> 00:24:19,360
occurrence field first and of course you

00:24:17,679 --> 00:24:21,039
can sub-index these and all that so if

00:24:19,360 --> 00:24:22,640
you want to do the first 20 characters

00:24:21,039 --> 00:24:24,640
of the last name and all that

00:24:22,640 --> 00:24:25,679
now what's really exciting is that if

00:24:24,640 --> 00:24:27,520
you have

00:24:25,679 --> 00:24:29,200
all the information you want in the

00:24:27,520 --> 00:24:30,159
index you don't have to do the dive in

00:24:29,200 --> 00:24:32,240
the table

00:24:30,159 --> 00:24:34,320
and that's called a covering index and

00:24:32,240 --> 00:24:35,919
those are

00:24:34,320 --> 00:24:38,559
big payoffs if you're going to work

00:24:35,919 --> 00:24:38,559
those out

00:24:39,360 --> 00:24:44,320
hashing values sometimes the data you

00:24:42,159 --> 00:24:47,120
have just doesn't really index very well

00:24:44,320 --> 00:24:50,080
and one of the things you can do is take

00:24:47,120 --> 00:24:53,200
the data in that and create a hash

00:24:50,080 --> 00:24:56,000
uh in this example we're going to hash

00:24:53,200 --> 00:24:57,440
value one and value two we're going to

00:24:56,000 --> 00:25:00,000
concat them together and then hash them

00:24:57,440 --> 00:25:02,559
with md5

00:25:00,000 --> 00:25:04,559
now as i mentioned earlier sometimes

00:25:02,559 --> 00:25:06,960
your your data just didn't quite work or

00:25:04,559 --> 00:25:09,520
you want to obfuscate it

00:25:06,960 --> 00:25:11,760
if it's something that's very very short

00:25:09,520 --> 00:25:14,000
reasonably unique

00:25:11,760 --> 00:25:15,120
it sometimes will speed things up a lot

00:25:14,000 --> 00:25:17,520
faster

00:25:15,120 --> 00:25:18,400
the wider your index the more memory it

00:25:17,520 --> 00:25:19,600
takes up

00:25:18,400 --> 00:25:21,600
so if you have something like you're

00:25:19,600 --> 00:25:22,799
trying to index that's like 200

00:25:21,600 --> 00:25:26,080
characters long

00:25:22,799 --> 00:25:26,080
this might be another

00:25:26,320 --> 00:25:32,400
another option for you for keeping your

00:25:29,440 --> 00:25:32,400
data organized

00:25:33,840 --> 00:25:39,120
some other type of indexes unique

00:25:36,320 --> 00:25:42,320
indexes which is only one row per value

00:25:39,120 --> 00:25:44,720
full text indexes for those who

00:25:42,320 --> 00:25:46,960
run elasticsearch you can ignore this

00:25:44,720 --> 00:25:49,200
that's probably a better choice for

00:25:46,960 --> 00:25:53,039
90 of the corpus searching out there if

00:25:49,200 --> 00:25:53,039
you're doing looking into a lot of

00:25:54,159 --> 00:26:00,880
textual data but if you need um

00:25:57,520 --> 00:26:04,240
it's like three to fifteen characters

00:26:00,880 --> 00:26:07,919
and uh want to do string searches

00:26:04,240 --> 00:26:10,559
you can do full text indexes the ones

00:26:07,919 --> 00:26:12,000
the one for nodb is rather nice where

00:26:10,559 --> 00:26:14,799
you can actually specify

00:26:12,000 --> 00:26:16,880
a number of words between finding the

00:26:14,799 --> 00:26:20,000
first word and the second word

00:26:16,880 --> 00:26:22,799
so if you're looking for um

00:26:20,000 --> 00:26:23,760
purple car and you want them within five

00:26:22,799 --> 00:26:26,159
words of each other like you're

00:26:23,760 --> 00:26:28,720
searching for a new ride

00:26:26,159 --> 00:26:30,320
it will return that the occurrences were

00:26:28,720 --> 00:26:31,440
purple and car within five words of each

00:26:30,320 --> 00:26:34,480
other it won't come out

00:26:31,440 --> 00:26:34,960
and say that he liked prince's purple

00:26:34,480 --> 00:26:38,880
rain

00:26:34,960 --> 00:26:39,440
and twenty uh 20 words later tells you

00:26:38,880 --> 00:26:42,640
that there's

00:26:39,440 --> 00:26:44,480
actually a uh a car for sale in your

00:26:42,640 --> 00:26:45,279
area oh let's have another q and a let's

00:26:44,480 --> 00:26:48,480
see if i can

00:26:45,279 --> 00:26:49,840
do that uh good

00:26:48,480 --> 00:26:52,080
primer okay i'll have to come back to

00:26:49,840 --> 00:26:54,720
that again later uh

00:26:52,080 --> 00:26:55,919
covering indexes i mentioned earlier uh

00:26:54,720 --> 00:26:57,600
that's when

00:26:55,919 --> 00:26:59,679
like we're searching the last name and

00:26:57,600 --> 00:27:01,520
first name and we didn't have to after

00:26:59,679 --> 00:27:03,600
we find the index entry go back and

00:27:01,520 --> 00:27:05,039
return the data

00:27:03,600 --> 00:27:07,120
so in that case if you're searching for

00:27:05,039 --> 00:27:08,720
last name stokes and it pulls back the

00:27:07,120 --> 00:27:09,919
one or two records that it matches you

00:27:08,720 --> 00:27:11,760
have all that there without having to

00:27:09,919 --> 00:27:15,520
die on the table

00:27:11,760 --> 00:27:16,240
secondary indexes secondary indexes are

00:27:15,520 --> 00:27:19,039
a little bit

00:27:16,240 --> 00:27:20,000
different than primary indexes secondary

00:27:19,039 --> 00:27:22,880
index is another

00:27:20,000 --> 00:27:23,600
column in your table that is being

00:27:22,880 --> 00:27:26,320
indexed

00:27:23,600 --> 00:27:27,120
but what's actually saved is not the

00:27:26,320 --> 00:27:28,559
this

00:27:27,120 --> 00:27:30,880
the data from the column that you

00:27:28,559 --> 00:27:34,480
indexed it's actually saving the primary

00:27:30,880 --> 00:27:37,440
key so when you look up like zip code

00:27:34,480 --> 00:27:38,399
but you have my my other information

00:27:37,440 --> 00:27:40,480
saved under

00:27:38,399 --> 00:27:42,320
my select social security number or

00:27:40,480 --> 00:27:44,559
customer id number

00:27:42,320 --> 00:27:47,440
it will actually use that number in the

00:27:44,559 --> 00:27:50,159
table for the secondary index

00:27:47,440 --> 00:27:51,120
spatial indexes this is for geographical

00:27:50,159 --> 00:27:53,919
geographical

00:27:51,120 --> 00:27:54,320
information here we're using r indexes

00:27:53,919 --> 00:27:57,440
so

00:27:54,320 --> 00:27:59,279
if i have geographic information in my

00:27:57,440 --> 00:28:01,440
database and by the way we use the boost

00:27:59,279 --> 00:28:04,080
geometry data

00:28:01,440 --> 00:28:05,360
database libraries very very handy very

00:28:04,080 --> 00:28:08,880
very powerful

00:28:05,360 --> 00:28:11,520
so if i have an index set up to cover

00:28:08,880 --> 00:28:13,279
say like north texas it will have a

00:28:11,520 --> 00:28:13,919
whole bunch of various points within

00:28:13,279 --> 00:28:15,520
there

00:28:13,919 --> 00:28:17,360
and i can check to see is this point

00:28:15,520 --> 00:28:19,840
within that index or not within that

00:28:17,360 --> 00:28:19,840
index

00:28:24,640 --> 00:28:28,399
okay functional indexes these um these

00:28:27,840 --> 00:28:31,440
really are

00:28:28,399 --> 00:28:33,200
fun for functional indexes uh they're

00:28:31,440 --> 00:28:35,360
a result of a function applied to one or

00:28:33,200 --> 00:28:36,640
more columns of a single table

00:28:35,360 --> 00:28:38,640
uh the first one we're going to create a

00:28:36,640 --> 00:28:40,159
table called t1 we're going to have two

00:28:38,640 --> 00:28:41,919
integer columns

00:28:40,159 --> 00:28:44,559
and we're going to have a functional

00:28:41,919 --> 00:28:46,720
index where we have the absolute of call

00:28:44,559 --> 00:28:48,480
one yeah absolute on a

00:28:46,720 --> 00:28:50,640
integer is not a great deal but measure

00:28:48,480 --> 00:28:52,000
that was a real and you're searching for

00:28:50,640 --> 00:28:53,200
a price someone says hey

00:28:52,000 --> 00:28:56,480
show me everything you have in your

00:28:53,200 --> 00:28:58,799
inventory that's under ten dollars

00:28:56,480 --> 00:29:01,200
uh the second one we're doing a create

00:28:58,799 --> 00:29:04,159
index we're actually adding two columns

00:29:01,200 --> 00:29:05,600
so maybe that's the cost of production

00:29:04,159 --> 00:29:07,600
and the cost of delivery

00:29:05,600 --> 00:29:09,440
and someone wants to know what can i get

00:29:07,600 --> 00:29:12,720
delivered to me for less than x amount

00:29:09,440 --> 00:29:14,480
amount of dollars the

00:29:12,720 --> 00:29:16,720
third one we have in there we're

00:29:14,480 --> 00:29:19,440
creating index two on table one

00:29:16,720 --> 00:29:20,799
we're going to add column one and column

00:29:19,440 --> 00:29:23,279
two so what can i get

00:29:20,799 --> 00:29:24,320
that's under this and what can i get

00:29:23,279 --> 00:29:26,320
were the

00:29:24,320 --> 00:29:27,360
delivery prices more than the actual

00:29:26,320 --> 00:29:29,279
information

00:29:27,360 --> 00:29:32,720
and also we want to have an index for

00:29:29,279 --> 00:29:34,640
the original price of production

00:29:32,720 --> 00:29:36,640
and you could also do things uh as in

00:29:34,640 --> 00:29:38,240
the last example column one times 40.

00:29:36,640 --> 00:29:41,760
maybe that's a

00:29:38,240 --> 00:29:42,640
markup for or or commission and you can

00:29:41,760 --> 00:29:45,200
just

00:29:42,640 --> 00:29:46,880
describe them as descending uh in the

00:29:45,200 --> 00:29:50,559
past before moscow 8-0

00:29:46,880 --> 00:29:52,320
if you specified a descending index

00:29:50,559 --> 00:29:54,320
we lied to you it really wasn't

00:29:52,320 --> 00:29:57,440
descending we just read it backwards

00:29:54,320 --> 00:29:57,760
however with mysql80 it does actually do

00:29:57,440 --> 00:30:00,880
that

00:29:57,760 --> 00:30:02,399
okay second q a let's see we have your

00:30:00,880 --> 00:30:04,320
secondary energy is both the primary

00:30:02,399 --> 00:30:06,399
index and the secondary index

00:30:04,320 --> 00:30:08,880
well the secondary index think is that

00:30:06,399 --> 00:30:10,080
as the value for the column or columns

00:30:08,880 --> 00:30:13,520
that you've indexed

00:30:10,080 --> 00:30:16,799
with a pointer to the primary key

00:30:13,520 --> 00:30:19,360
hopefully that that answers that for

00:30:16,799 --> 00:30:19,360
william bishop

00:30:19,840 --> 00:30:23,440
i'll go back and answer these all again

00:30:21,279 --> 00:30:27,039
at the end we've got plenty of time

00:30:23,440 --> 00:30:27,039
since we have back to back sessions

00:30:27,679 --> 00:30:34,840
okay multi-value indexes these

00:30:31,360 --> 00:30:37,120
came out about a year ago very very

00:30:34,840 --> 00:30:40,480
handy

00:30:37,120 --> 00:30:43,760
the the json data type

00:30:40,480 --> 00:30:45,600
um lets you have arrays now

00:30:43,760 --> 00:30:47,760
traditionally sql doesn't have well

00:30:45,600 --> 00:30:50,720
mysql doesn't have an array data type

00:30:47,760 --> 00:30:51,360
and i see a lot of people using json to

00:30:50,720 --> 00:30:54,240
try to

00:30:51,360 --> 00:30:55,520
work around that limitation now

00:30:54,240 --> 00:30:58,399
traditionally with

00:30:55,520 --> 00:30:59,120
indexes you had one entry in the index

00:30:58,399 --> 00:31:02,080
for every

00:30:59,120 --> 00:31:02,880
or for every column that you had indexed

00:31:02,080 --> 00:31:05,679
you had one

00:31:02,880 --> 00:31:07,039
entry in the index table it doesn't

00:31:05,679 --> 00:31:09,279
quite work for arrays

00:31:07,039 --> 00:31:10,799
so with multi-value indexes you can

00:31:09,279 --> 00:31:13,919
actually have

00:31:10,799 --> 00:31:19,120
multiple values per row

00:31:13,919 --> 00:31:21,600
in the index so here we're using

00:31:19,120 --> 00:31:22,640
the member of function and we're looking

00:31:21,600 --> 00:31:25,760
to see

00:31:22,640 --> 00:31:27,200
is there a value of three in this array

00:31:25,760 --> 00:31:28,960
and of course it returns the one that

00:31:27,200 --> 00:31:30,799
tell us that yes there is

00:31:28,960 --> 00:31:34,240
and then you can use other json

00:31:30,799 --> 00:31:38,720
functions to pull out the exact

00:31:34,240 --> 00:31:38,720
item we want or the entire json document

00:31:40,640 --> 00:31:44,559
mysql has two main types of index

00:31:42,640 --> 00:31:48,159
structures on the left you have a b

00:31:44,559 --> 00:31:52,320
tree and if you follow this out um

00:31:48,159 --> 00:31:55,679
the entries 0 to 40 take this branch

00:31:52,320 --> 00:31:57,120
to this leaf and we know on this branch

00:31:55,679 --> 00:32:00,159
the values 0 to 10

00:31:57,120 --> 00:32:02,399
are going to be in this block 11 to 19

00:32:00,159 --> 00:32:03,600
are going to be over here 20 to 25 we're

00:32:02,399 --> 00:32:05,120
not noting

00:32:03,600 --> 00:32:07,679
um if we're coming over here we've got

00:32:05,120 --> 00:32:09,760
the values 200 to 250

00:32:07,679 --> 00:32:11,039
uh they're going to be on this leaf and

00:32:09,760 --> 00:32:14,240
then it breaks down

00:32:11,039 --> 00:32:16,320
so everything doesn't quite give you

00:32:14,240 --> 00:32:18,320
true binary search capability but

00:32:16,320 --> 00:32:20,320
it's it's pretty close lets you zero in

00:32:18,320 --> 00:32:24,080
on things pretty quickly

00:32:20,320 --> 00:32:26,320
um notice that it's not uh

00:32:24,080 --> 00:32:28,080
one leaf one branch at the very bottom

00:32:26,320 --> 00:32:29,440
but it's kind of a block and you'll see

00:32:28,080 --> 00:32:31,440
when i start talking about histograms

00:32:29,440 --> 00:32:34,640
where that comes in okay

00:32:31,440 --> 00:32:36,000
hashes are more efficient than our

00:32:34,640 --> 00:32:39,200
traditional nested loose

00:32:36,000 --> 00:32:42,159
join you

00:32:39,200 --> 00:32:43,200
basically hash the two values together

00:32:42,159 --> 00:32:46,240
and return the

00:32:43,200 --> 00:32:50,080
the corresponding matches to the client

00:32:46,240 --> 00:32:51,919
uh older versions of mysql before 8 0 i

00:32:50,080 --> 00:32:54,399
believe with 17 you're going to see b

00:32:51,919 --> 00:32:56,000
trees and what we do is we do either one

00:32:54,399 --> 00:32:58,159
table and do a massive loop branch

00:32:56,000 --> 00:32:59,760
onto another table uh going through the

00:32:58,159 --> 00:33:02,640
indexes for both

00:32:59,760 --> 00:33:04,000
with hashes um basically you you can

00:33:02,640 --> 00:33:05,679
think of it as one big read for the

00:33:04,000 --> 00:33:06,480
first table one big read for the second

00:33:05,679 --> 00:33:08,720
table

00:33:06,480 --> 00:33:11,840
uh throw them in memory and voila it

00:33:08,720 --> 00:33:11,840
pops out the other end

00:33:13,760 --> 00:33:19,840
now the optimizer the heuristics

00:33:17,440 --> 00:33:21,919
are kind of interesting if there's a

00:33:19,840 --> 00:33:24,080
choice between multiple indexes

00:33:21,919 --> 00:33:25,679
mysql normally uses the index that's the

00:33:24,080 --> 00:33:27,279
smallest number of rows

00:33:25,679 --> 00:33:30,000
that is what it thinks is the most

00:33:27,279 --> 00:33:32,320
selective that may or may not be true

00:33:30,000 --> 00:33:35,919
for your data and your application

00:33:32,320 --> 00:33:37,600
i will show you later how to force

00:33:35,919 --> 00:33:40,240
force indexes when you find out that

00:33:37,600 --> 00:33:43,360
there are better ways to do stuff

00:33:40,240 --> 00:33:45,120
now when you're indexing columns

00:33:43,360 --> 00:33:46,960
you can use just about any data type you

00:33:45,120 --> 00:33:48,480
want except for the the blobs or the

00:33:46,960 --> 00:33:50,720
jsons

00:33:48,480 --> 00:33:52,159
but if you're comparing them it helps to

00:33:50,720 --> 00:33:55,440
have them the same

00:33:52,159 --> 00:33:56,880
data type and size uh now varchar and

00:33:55,440 --> 00:33:57,600
char you can kind of consider them the

00:33:56,880 --> 00:34:01,760
same

00:33:57,600 --> 00:34:03,039
uh it's not that not expensive to switch

00:34:01,760 --> 00:34:04,960
between that

00:34:03,039 --> 00:34:07,120
if you're using an integer and a real or

00:34:04,960 --> 00:34:08,800
an integer and a var car

00:34:07,120 --> 00:34:10,480
things have to be casted they have to be

00:34:08,800 --> 00:34:14,240
matched up and that

00:34:10,480 --> 00:34:14,960
slows things down also i really

00:34:14,240 --> 00:34:18,240
recommend

00:34:14,960 --> 00:34:21,800
that if you're not using utf-8 mb4

00:34:18,240 --> 00:34:26,000
please switch over to utf-8 and before

00:34:21,800 --> 00:34:27,679
mysql80 is really optimized around that

00:34:26,000 --> 00:34:31,599
that gives you the full latin character

00:34:27,679 --> 00:34:34,480
set all four planes of the unicode

00:34:31,599 --> 00:34:36,000
9.0 standard so you can support chinese

00:34:34,480 --> 00:34:37,760
japanese and korean

00:34:36,000 --> 00:34:39,679
and plus the thing that everyone really

00:34:37,760 --> 00:34:42,399
really needs in their database

00:34:39,679 --> 00:34:42,399
emojis

00:34:44,000 --> 00:34:50,480
okay no no is one of those great ideas

00:34:48,159 --> 00:34:51,440
that you kind of wonder if you could go

00:34:50,480 --> 00:34:54,399
back in time

00:34:51,440 --> 00:34:55,599
and uh wave a wand and not actually

00:34:54,399 --> 00:34:58,960
change too much

00:34:55,599 --> 00:35:02,000
um so we don't have um recreated

00:34:58,960 --> 00:35:03,599
pterodactyls like jurassic park

00:35:02,000 --> 00:35:04,960
or maybe we finally get the flying cars

00:35:03,599 --> 00:35:06,320
they've promised me since i was a little

00:35:04,960 --> 00:35:08,160
kid

00:35:06,320 --> 00:35:09,520
but we'll go into the concept of null i

00:35:08,160 --> 00:35:10,560
tend to tell most folks when they're

00:35:09,520 --> 00:35:12,480
starting out

00:35:10,560 --> 00:35:14,079
try to stay away from it as much as

00:35:12,480 --> 00:35:15,119
possible what am i talking about with

00:35:14,079 --> 00:35:16,880
null

00:35:15,119 --> 00:35:18,480
well in the early days of databases back

00:35:16,880 --> 00:35:21,440
in the 1970s

00:35:18,480 --> 00:35:22,560
um the question was okay if we're going

00:35:21,440 --> 00:35:25,839
to use

00:35:22,560 --> 00:35:28,320
one for true and zero for false how do

00:35:25,839 --> 00:35:31,839
we designate that we're missing the data

00:35:28,320 --> 00:35:34,720
but don't know value and

00:35:31,839 --> 00:35:36,480
uh someone came with the idea it's okay

00:35:34,720 --> 00:35:38,000
let's have a value of no

00:35:36,480 --> 00:35:40,160
matter fact if you look at old versions

00:35:38,000 --> 00:35:44,000
of mysql you'll see null designated as

00:35:40,160 --> 00:35:46,720
a backslash capital m as a shorthand

00:35:44,000 --> 00:35:48,079
well null can be handy in the right

00:35:46,720 --> 00:35:50,720
circumstances

00:35:48,079 --> 00:35:52,720
unfortunately not everyone uses it as

00:35:50,720 --> 00:35:55,040
intended

00:35:52,720 --> 00:35:56,720
uh here's another visual example of the

00:35:55,040 --> 00:35:58,800
idea of null

00:35:56,720 --> 00:36:00,320
probably not the best example but it it

00:35:58,800 --> 00:36:03,520
does tend to stick in one's

00:36:00,320 --> 00:36:07,119
mind forgive me if i discard your

00:36:03,520 --> 00:36:07,119
your gray matter permanently on this

00:36:07,599 --> 00:36:11,280
indexing null values uh really drives

00:36:09,680 --> 00:36:16,160
them down the performance of the

00:36:11,280 --> 00:36:18,240
indexes imagine you have a database with

00:36:16,160 --> 00:36:19,440
everyone's house number each house has a

00:36:18,240 --> 00:36:21,599
unique number

00:36:19,440 --> 00:36:23,040
but then you have lots of land that

00:36:21,599 --> 00:36:25,599
don't have a house number so you just

00:36:23,040 --> 00:36:28,880
kind of put them in with no values

00:36:25,599 --> 00:36:32,079
if you're searching for a particular

00:36:28,880 --> 00:36:35,040
attribute to that to that information

00:36:32,079 --> 00:36:36,800
and you know you're looking for

00:36:35,040 --> 00:36:40,720
something has a southern exposure for

00:36:36,800 --> 00:36:42,640
example the ones with the

00:36:40,720 --> 00:36:44,240
keys pop up right away and then the one

00:36:42,640 --> 00:36:46,800
there's the nulls you kind of have to

00:36:44,240 --> 00:36:47,839
grab them all and go out there and and

00:36:46,800 --> 00:36:49,520
go through there

00:36:47,839 --> 00:36:52,000
it's like sorting through a jump drawer

00:36:49,520 --> 00:36:56,240
to find a battery that may or may not be

00:36:52,000 --> 00:36:58,640
be dead so

00:36:56,240 --> 00:36:59,440
they're basically unsearchable so i tell

00:36:58,640 --> 00:37:02,160
people

00:36:59,440 --> 00:37:03,119
for indexing columns designate them when

00:37:02,160 --> 00:37:08,160
you create them as

00:37:03,119 --> 00:37:10,160
not null invisible indexes uh when i

00:37:08,160 --> 00:37:13,520
first heard about this i thought this

00:37:10,160 --> 00:37:14,320
was a weird idea but the more i played

00:37:13,520 --> 00:37:16,079
with it

00:37:14,320 --> 00:37:18,960
the more i love it and hopefully you'll

00:37:16,079 --> 00:37:18,960
learn to love it too

00:37:19,119 --> 00:37:24,320
so in the olden days uh speak

00:37:22,400 --> 00:37:26,320
think back about three and a half years

00:37:24,320 --> 00:37:29,440
ago imagine you're a dba

00:37:26,320 --> 00:37:32,000
and you're in your office uh at work uh

00:37:29,440 --> 00:37:33,920
in a building uh with other co-workers

00:37:32,000 --> 00:37:36,480
down the hall

00:37:33,920 --> 00:37:37,040
and you have a index you're not quite

00:37:36,480 --> 00:37:40,720
sure

00:37:37,040 --> 00:37:42,160
is doing its job you're not sure if it's

00:37:40,720 --> 00:37:43,760
useful and you'd like to free up the

00:37:42,160 --> 00:37:46,320
memory if you can

00:37:43,760 --> 00:37:48,560
so the first thing you do is you check

00:37:46,320 --> 00:37:50,720
your query using explain

00:37:48,560 --> 00:37:52,320
and explain for some reason isn't using

00:37:50,720 --> 00:37:55,520
that index so

00:37:52,320 --> 00:37:59,119
well maybe i don't need that index so

00:37:55,520 --> 00:38:01,040
you blow it away rerun explain

00:37:59,119 --> 00:38:03,119
and in the process of looking at the

00:38:01,040 --> 00:38:05,520
output from the explain command

00:38:03,119 --> 00:38:06,400
your phone starts ringing you start

00:38:05,520 --> 00:38:08,240
getting

00:38:06,400 --> 00:38:09,760
text messages and you hear screams down

00:38:08,240 --> 00:38:11,839
the hallway about

00:38:09,760 --> 00:38:13,359
suddenly the database is slow you know

00:38:11,839 --> 00:38:16,160
what what's happened

00:38:13,359 --> 00:38:17,040
so if you're aha my query doesn't use

00:38:16,160 --> 00:38:20,160
that index

00:38:17,040 --> 00:38:23,440
but their query does use that index

00:38:20,160 --> 00:38:25,520
and it seems that everyone in the world

00:38:23,440 --> 00:38:26,960
is using that index so you need to get

00:38:25,520 --> 00:38:29,599
that back

00:38:26,960 --> 00:38:31,040
so you you recreate that index hopefully

00:38:29,599 --> 00:38:33,520
you've written down the definition or

00:38:31,040 --> 00:38:36,160
i've saved it someplace

00:38:33,520 --> 00:38:37,200
and it can take seconds or minutes or

00:38:36,160 --> 00:38:38,880
hours or

00:38:37,200 --> 00:38:41,440
longer to rebuild that index depending

00:38:38,880 --> 00:38:45,839
on the size of the data

00:38:41,440 --> 00:38:49,040
so um that was kind of a messy

00:38:45,839 --> 00:38:50,560
after invisible indexes you doubt the

00:38:49,040 --> 00:38:53,839
usefulness of the index

00:38:50,560 --> 00:38:54,560
you check using explain make that index

00:38:53,839 --> 00:38:57,040
invisible

00:38:54,560 --> 00:38:58,320
so the optimizer on the system and this

00:38:57,040 --> 00:39:01,200
system level

00:38:58,320 --> 00:39:02,640
uh cannot see that index you rerun

00:39:01,200 --> 00:39:05,440
explain

00:39:02,640 --> 00:39:07,280
and once again uh you hear the the

00:39:05,440 --> 00:39:09,280
cacophony of your coworkers screaming

00:39:07,280 --> 00:39:11,760
about the database being slow

00:39:09,280 --> 00:39:13,200
and you make the index visible and

00:39:11,760 --> 00:39:16,960
everyone's happy

00:39:13,200 --> 00:39:18,480
well the uh this is the opportunity

00:39:16,960 --> 00:39:20,000
where you break out your your standard

00:39:18,480 --> 00:39:22,880
problem you know blaming on the network

00:39:20,000 --> 00:39:26,320
javascript gdpr slash cloud

00:39:22,880 --> 00:39:27,040
whatever you want to blame it on this is

00:39:26,320 --> 00:39:30,160
a great

00:39:27,040 --> 00:39:32,800
tool and i really really recommend it

00:39:30,160 --> 00:39:33,599
it's very very handy the other thing i

00:39:32,800 --> 00:39:35,839
recommend

00:39:33,599 --> 00:39:37,440
is learning how to use use mysql

00:39:35,839 --> 00:39:39,920
workbench just so you look at the

00:39:37,440 --> 00:39:40,880
schema tables and one of the reports

00:39:39,920 --> 00:39:43,599
that we'll give you

00:39:40,880 --> 00:39:46,320
is which indexes are out there but have

00:39:43,599 --> 00:39:49,200
not been used in a while

00:39:46,320 --> 00:39:50,240
i would say they are candidates for

00:39:49,200 --> 00:39:52,880
removal

00:39:50,240 --> 00:39:55,040
not to be removed but you have to be

00:39:52,880 --> 00:39:57,599
cautious

00:39:55,040 --> 00:39:58,079
some indexes aren't used all that often

00:39:57,599 --> 00:40:00,000
um

00:39:58,079 --> 00:40:01,280
so if you just rebooted and you go out

00:40:00,000 --> 00:40:04,720
there and you'll see a whole bunch

00:40:01,280 --> 00:40:06,079
of of uh candidates out there

00:40:04,720 --> 00:40:08,079
uh they may not have been used yet they

00:40:06,079 --> 00:40:10,560
may not have been seated there might be

00:40:08,079 --> 00:40:11,839
may not be statistics out there for them

00:40:10,560 --> 00:40:13,440
and the other thing is there are some

00:40:11,839 --> 00:40:14,160
indexes that you will run into during

00:40:13,440 --> 00:40:17,440
your career

00:40:14,160 --> 00:40:18,160
that might be used for um quarterly

00:40:17,440 --> 00:40:23,119
statements

00:40:18,160 --> 00:40:23,119
or year-end processing and uh

00:40:23,200 --> 00:40:29,520
be very very careful about blowing away

00:40:25,119 --> 00:40:29,520
an index and i recommend keeping it

00:40:30,640 --> 00:40:34,560
invisible for a while before you you

00:40:32,560 --> 00:40:36,839
knock it off just to make sure

00:40:34,560 --> 00:40:38,800
and then as always make sure you keep

00:40:36,839 --> 00:40:42,160
backups

00:40:38,800 --> 00:40:45,280
so how do you create an invisible index

00:40:42,160 --> 00:40:46,800
i'll use the alter table statement so

00:40:45,280 --> 00:40:49,200
we're going to alter table t1

00:40:46,800 --> 00:40:50,319
alter index i underscore idx make it

00:40:49,200 --> 00:40:52,640
invisible

00:40:50,319 --> 00:40:54,400
well how do you make it visible just

00:40:52,640 --> 00:40:55,760
same thing but instead of invisible you

00:40:54,400 --> 00:40:59,119
type visible

00:40:55,760 --> 00:41:00,800
uh very very handy i've used since this

00:40:59,119 --> 00:41:02,960
has come out i've used this

00:41:00,800 --> 00:41:04,560
several dozen times helping customers

00:41:02,960 --> 00:41:08,319
solve problems

00:41:04,560 --> 00:41:11,440
this is very very very handy

00:41:08,319 --> 00:41:14,720
now histograms histograms came out

00:41:11,440 --> 00:41:15,280
with mysql 8-0 indexes have been around

00:41:14,720 --> 00:41:18,560
since

00:41:15,280 --> 00:41:22,880
um the early three days histograms

00:41:18,560 --> 00:41:25,839
are fairly new well what is a histogram

00:41:22,880 --> 00:41:28,160
well it's not a gluten-free keto

00:41:25,839 --> 00:41:30,960
friendly biscuit

00:41:28,160 --> 00:41:32,960
it's more of a frequency distribution of

00:41:30,960 --> 00:41:34,960
your data

00:41:32,960 --> 00:41:36,800
remember your the key here is the

00:41:34,960 --> 00:41:38,640
optimizer needs to know where your data

00:41:36,800 --> 00:41:40,319
is to be able to go out and get it

00:41:38,640 --> 00:41:42,800
and it needs to have a rough idea where

00:41:40,319 --> 00:41:47,680
it is to give you a

00:41:42,800 --> 00:41:49,920
a a good guesstimate a swag of how to

00:41:47,680 --> 00:41:52,960
get to your data

00:41:49,920 --> 00:41:54,079
so this is histogram of height of 10 000

00:41:52,960 --> 00:41:56,319
u.s females

00:41:54,079 --> 00:41:57,599
measured in centimeters which is not the

00:41:56,319 --> 00:41:59,599
way we traditionally do that in the

00:41:57,599 --> 00:42:02,000
united states

00:41:59,599 --> 00:42:03,960
as you can see the majority of them seem

00:42:02,000 --> 00:42:07,599
to be around

00:42:03,960 --> 00:42:10,319
165 or so centimeters high

00:42:07,599 --> 00:42:11,599
so it gives you a a distribution well

00:42:10,319 --> 00:42:14,400
how does a database

00:42:11,599 --> 00:42:16,000
use that sort of information well

00:42:14,400 --> 00:42:17,920
wikipedia declares histogram

00:42:16,000 --> 00:42:22,240
is an accurate representation of the

00:42:17,920 --> 00:42:22,240
distribu distribution of numerical data

00:42:22,560 --> 00:42:26,240
and we're talking about a approximate

00:42:25,200 --> 00:42:30,000
distribution

00:42:26,240 --> 00:42:31,599
within a column so for mysql histograms

00:42:30,000 --> 00:42:35,200
help the optimizer find the most

00:42:31,599 --> 00:42:38,319
efficient plan to grab your data

00:42:35,200 --> 00:42:39,680
so i like to think of histograms as a

00:42:38,319 --> 00:42:42,800
series of logical

00:42:39,680 --> 00:42:46,079
buckets um

00:42:42,800 --> 00:42:47,200
there are two types singleton where each

00:42:46,079 --> 00:42:50,960
bucket has

00:42:47,200 --> 00:42:55,440
a single value or a range of values

00:42:50,960 --> 00:42:58,079
and equiheit where you basically take

00:42:55,440 --> 00:42:59,280
every all the data and divide it up

00:42:58,079 --> 00:43:02,800
evenly

00:42:59,280 --> 00:43:04,480
so uh singletons you have all the a's

00:43:02,800 --> 00:43:05,119
all the b's all the c's and separate

00:43:04,480 --> 00:43:06,880
buckets

00:43:05,119 --> 00:43:08,319
and equal height you have a thousand

00:43:06,880 --> 00:43:11,200
people and you put them in four

00:43:08,319 --> 00:43:12,800
different buckets of 250 people each

00:43:11,200 --> 00:43:15,200
now the maximum number of buckets you

00:43:12,800 --> 00:43:17,359
can have is a thousand twenty four

00:43:15,200 --> 00:43:19,200
um i've been playing this for the while

00:43:17,359 --> 00:43:19,599
haven't really seen a need to go up that

00:43:19,200 --> 00:43:22,560
high

00:43:19,599 --> 00:43:24,880
uh you might have a good need and uh

00:43:22,560 --> 00:43:27,680
it's available

00:43:24,880 --> 00:43:30,000
now histogram statistics are useful

00:43:27,680 --> 00:43:34,560
primarily for non-indexed

00:43:30,000 --> 00:43:38,400
columns now what do i mean by that

00:43:34,560 --> 00:43:40,640
um your index data is already indexed

00:43:38,400 --> 00:43:42,240
and is fast enough for the optimizer to

00:43:40,640 --> 00:43:44,400
know where it is

00:43:42,240 --> 00:43:45,520
histograms i recommend for data that

00:43:44,400 --> 00:43:49,119
doesn't churn

00:43:45,520 --> 00:43:52,640
too often could be

00:43:49,119 --> 00:43:54,480
used for some sort of quarterly data

00:43:52,640 --> 00:43:56,560
maybe your customers don't move too

00:43:54,480 --> 00:43:58,240
often um

00:43:56,560 --> 00:44:00,480
think of stuff that you really don't

00:43:58,240 --> 00:44:03,520
have to worry about updates more than

00:44:00,480 --> 00:44:04,960
say two times a week or maybe two times

00:44:03,520 --> 00:44:07,760
a month

00:44:04,960 --> 00:44:09,280
and uh histograms are only created on

00:44:07,760 --> 00:44:11,200
demand

00:44:09,280 --> 00:44:12,960
we'll talk about overhead with indexes

00:44:11,200 --> 00:44:16,079
in a minute so there is no

00:44:12,960 --> 00:44:19,359
overhead when a table is modified but

00:44:16,079 --> 00:44:21,280
the histogram data is kind of aged and

00:44:19,359 --> 00:44:24,240
is not 100 accurate anymore every time

00:44:21,280 --> 00:44:24,240
you add something to it

00:44:25,359 --> 00:44:28,800
so why would you use a histogram instead

00:44:27,440 --> 00:44:32,240
of an index

00:44:28,800 --> 00:44:36,000
well indexes have a cost you insert

00:44:32,240 --> 00:44:38,480
a record and the the little model

00:44:36,000 --> 00:44:39,280
table for keeping the index data has to

00:44:38,480 --> 00:44:42,000
have that

00:44:39,280 --> 00:44:43,280
copy of that data inserted into its copy

00:44:42,000 --> 00:44:46,160
uh if you update it

00:44:43,280 --> 00:44:47,040
or you delete it uh say likewise that

00:44:46,160 --> 00:44:49,920
overhead

00:44:47,040 --> 00:44:51,839
has to be done sometimes when you see

00:44:49,920 --> 00:44:53,599
sites that have been over indexed

00:44:51,839 --> 00:44:55,280
especially when they're indexed in the

00:44:53,599 --> 00:44:56,000
same columns over and over and over

00:44:55,280 --> 00:44:59,440
again

00:44:56,000 --> 00:45:01,440
uh this overhead can get pretty heavy

00:44:59,440 --> 00:45:02,960
and that can really degrade the

00:45:01,440 --> 00:45:05,760
performance

00:45:02,960 --> 00:45:06,240
and occasionally the optimizer will make

00:45:05,760 --> 00:45:09,680
index

00:45:06,240 --> 00:45:10,960
dives uh as things change uh as data is

00:45:09,680 --> 00:45:14,560
updated

00:45:10,960 --> 00:45:16,160
or or deleted uh does index drives to

00:45:14,560 --> 00:45:19,280
try to get an estimate of

00:45:16,160 --> 00:45:21,280
what's in a given range uh think of this

00:45:19,280 --> 00:45:23,680
as doing inventory

00:45:21,280 --> 00:45:25,839
and this can become costly because it's

00:45:23,680 --> 00:45:28,160
not going to pick the best time for you

00:45:25,839 --> 00:45:29,599
to go out there and dive into your your

00:45:28,160 --> 00:45:30,640
data and figure out if everything's

00:45:29,599 --> 00:45:33,200
still laid out in

00:45:30,640 --> 00:45:34,960
a nice balanced b trees uh it's going to

00:45:33,200 --> 00:45:38,560
do it when it's convenient for the

00:45:34,960 --> 00:45:41,200
optimizer so histogram statistics are a

00:45:38,560 --> 00:45:43,520
lot cheaper

00:45:41,200 --> 00:45:44,720
now occasionally the optimizer is

00:45:43,520 --> 00:45:47,760
brilliant as it is

00:45:44,720 --> 00:45:50,720
um fails to find the most efficient plan

00:45:47,760 --> 00:45:52,560
and ends up spinning its wheels um

00:45:50,720 --> 00:45:53,920
executing query or giving you a query

00:45:52,560 --> 00:45:56,480
plan that's going to

00:45:53,920 --> 00:45:58,640
be less than optimal now the optimizer

00:45:56,480 --> 00:46:02,160
assumes that the data is evenly

00:45:58,640 --> 00:46:02,160
distributed in a column

00:46:02,480 --> 00:46:06,880
not all the time the old joke about you

00:46:05,280 --> 00:46:09,200
know when you assume you make an ass out

00:46:06,880 --> 00:46:12,480
of me it really comes to life here

00:46:09,200 --> 00:46:15,440
so the optimizer often doesn't have

00:46:12,480 --> 00:46:19,359
enough knowledge of what's going on

00:46:15,440 --> 00:46:20,720
it may not know exactly how many rows

00:46:19,359 --> 00:46:23,280
are in each table

00:46:20,720 --> 00:46:23,920
uh it can has that information at hand

00:46:23,280 --> 00:46:26,480
but it may not

00:46:23,920 --> 00:46:28,720
know it inherent without going out there

00:46:26,480 --> 00:46:30,240
and seeking that information

00:46:28,720 --> 00:46:32,079
also it may not know how many distinct

00:46:30,240 --> 00:46:33,599
values there are in each column

00:46:32,079 --> 00:46:35,599
these are columns that are indexed by

00:46:33,599 --> 00:46:37,440
the way and

00:46:35,599 --> 00:46:38,640
how is the data distributed in each

00:46:37,440 --> 00:46:42,960
column

00:46:38,640 --> 00:46:45,359
if you're looking at um

00:46:42,960 --> 00:46:46,240
um ages you could probably figure a

00:46:45,359 --> 00:46:48,000
random

00:46:46,240 --> 00:46:50,240
poisson distribution if you have a

00:46:48,000 --> 00:46:52,240
general set of data from

00:46:50,240 --> 00:46:53,599
the general population uh might be

00:46:52,240 --> 00:46:54,839
heavily skewed if you have a bunch of

00:46:53,599 --> 00:46:58,880
teenagers

00:46:54,839 --> 00:47:00,480
so um the optimizer wants to

00:46:58,880 --> 00:47:03,440
wants to know all these pieces of

00:47:00,480 --> 00:47:04,960
information and actually more

00:47:03,440 --> 00:47:07,680
so as i mentioned earlier we have two

00:47:04,960 --> 00:47:11,040
types of histograms uh the echo height

00:47:07,680 --> 00:47:11,760
one bucket is the range of values uh so

00:47:11,040 --> 00:47:13,920
if in school

00:47:11,760 --> 00:47:15,760
you were told line up a to g h to l m to

00:47:13,920 --> 00:47:17,359
d and u to z

00:47:15,760 --> 00:47:19,040
and uh you're like me and your last

00:47:17,359 --> 00:47:20,319
bucket um

00:47:19,040 --> 00:47:21,839
it always helped because we always had

00:47:20,319 --> 00:47:23,280
extra time to line up and get ordered

00:47:21,839 --> 00:47:24,079
before because they're too busy with the

00:47:23,280 --> 00:47:27,520
atoms

00:47:24,079 --> 00:47:30,720
and the charles's and the dickenses and

00:47:27,520 --> 00:47:33,200
the uh eggberts

00:47:30,720 --> 00:47:35,040
now singleton uh one bucket represents

00:47:33,200 --> 00:47:37,760
one single value in a column

00:47:35,040 --> 00:47:39,520
and these are probably this is the most

00:47:37,760 --> 00:47:41,520
accurate of the two

00:47:39,520 --> 00:47:43,359
um i'd say the echo height is kind of

00:47:41,520 --> 00:47:44,000
like a 5000 foot overview and the

00:47:43,359 --> 00:47:46,240
singleton

00:47:44,000 --> 00:47:48,160
is flying uh literally just above the

00:47:46,240 --> 00:47:50,839
ground

00:47:48,160 --> 00:47:52,319
so let's take a look at a frequency

00:47:50,839 --> 00:47:54,319
histogram

00:47:52,319 --> 00:47:56,880
we have three buckets uh creatively

00:47:54,319 --> 00:47:59,520
named 101 102 and 104

00:47:56,880 --> 00:48:00,640
have no idea what happened to 103 and

00:47:59,520 --> 00:48:04,400
we're going to insert

00:48:00,640 --> 00:48:07,920
into our table

00:48:04,400 --> 00:48:09,359
two 101s two 102 well three 102s and one

00:48:07,920 --> 00:48:13,119
104.

00:48:09,359 --> 00:48:15,599
so two here three here

00:48:13,119 --> 00:48:15,599
one here

00:48:16,319 --> 00:48:23,359
now if we select the id and

00:48:20,240 --> 00:48:24,240
the value from our table we see we have

00:48:23,359 --> 00:48:28,160
the two

00:48:24,240 --> 00:48:31,440
101s 3 102s and

00:48:28,160 --> 00:48:34,559
the 1 104. so

00:48:31,440 --> 00:48:35,839
if we analyze table frequency histogram

00:48:34,559 --> 00:48:39,359
which is the table created

00:48:35,839 --> 00:48:40,880
and instead of three buckets

00:48:39,359 --> 00:48:44,160
we can print out some information from

00:48:40,880 --> 00:48:47,280
the information schema

00:48:44,160 --> 00:48:49,599
table or schema and

00:48:47,280 --> 00:48:50,880
the table column statistics and it'll

00:48:49,599 --> 00:48:52,880
come back and tell us

00:48:50,880 --> 00:48:54,000
the histogram buckets that have been set

00:48:52,880 --> 00:48:57,280
up so

00:48:54,000 --> 00:49:00,079
we know bucket 101 has one third

00:48:57,280 --> 00:49:02,000
of all our information so as the

00:49:00,079 --> 00:49:04,720
optimizer is looking for where it has to

00:49:02,000 --> 00:49:06,319
read it knows that it reads 101 it's

00:49:04,720 --> 00:49:08,559
going to have

00:49:06,319 --> 00:49:10,000
33 and a third percent of all the

00:49:08,559 --> 00:49:12,319
information

00:49:10,000 --> 00:49:13,920
if we look in the second bucket for the

00:49:12,319 --> 00:49:15,760
value of 102

00:49:13,920 --> 00:49:18,559
we know the first and second buckets

00:49:15,760 --> 00:49:20,000
that we have 83 and a third of all the

00:49:18,559 --> 00:49:23,760
data

00:49:20,000 --> 00:49:25,599
and if we look in the last bucket

00:49:23,760 --> 00:49:27,040
we know that including it in the

00:49:25,599 --> 00:49:31,119
previous buckets we have

00:49:27,040 --> 00:49:34,960
everything we have

00:49:31,119 --> 00:49:37,359
1.0 percent of uh

00:49:34,960 --> 00:49:38,640
100 of everything and by the way this

00:49:37,359 --> 00:49:40,559
information goes back and does this

00:49:38,640 --> 00:49:42,800
tells us that we do have a singleton

00:49:40,559 --> 00:49:42,800
here

00:49:43,599 --> 00:49:48,480
now if we look at the statistics um

00:49:46,880 --> 00:49:50,079
we're going to go out and look at the

00:49:48,480 --> 00:49:53,119
column statistics

00:49:50,079 --> 00:49:55,599
and we know that

00:49:53,119 --> 00:49:56,319
for our value of 101 our cumulative

00:49:55,599 --> 00:50:00,079
frequency

00:49:56,319 --> 00:50:03,119
is 33 and a third and

00:50:00,079 --> 00:50:05,280
our our frequency is the third i wish

00:50:03,119 --> 00:50:07,359
that wasn't popping up again

00:50:05,280 --> 00:50:09,440
for the value of 102 our cumulative

00:50:07,359 --> 00:50:10,160
frequency is 83 and a third and the

00:50:09,440 --> 00:50:13,280
frequency

00:50:10,160 --> 00:50:16,480
is 50 percent and

00:50:13,280 --> 00:50:18,400
for 104 our frequency is only 16.7

00:50:16,480 --> 00:50:20,400
but if you have all the buckets of value

00:50:18,400 --> 00:50:22,960
104 and below

00:50:20,400 --> 00:50:27,839
you have 100 of the cumulative frequency

00:50:22,960 --> 00:50:27,839
of the distribution of the data

00:50:28,960 --> 00:50:33,760
so how do you create a histogram well

00:50:31,599 --> 00:50:36,960
you use it with the analyze table

00:50:33,760 --> 00:50:38,240
um statement uh the first one we're

00:50:36,960 --> 00:50:41,119
going to go out and create

00:50:38,240 --> 00:50:43,359
a histogram on c1 a histogram on c2 and

00:50:41,119 --> 00:50:45,680
a histogram on c3 each with 10 buckets

00:50:43,359 --> 00:50:47,839
so those are three separate histograms

00:50:45,680 --> 00:50:50,720
you're not creating a histogram with c1

00:50:47,839 --> 00:50:54,480
c2 and c3 somehow merged together

00:50:50,720 --> 00:50:54,480
i want to get rid of a histogram

00:50:54,640 --> 00:51:00,240
you do the analyze table drop histogram

00:50:57,680 --> 00:51:00,960
if you want to change the bucket size

00:51:00,240 --> 00:51:03,680
you just do

00:51:00,960 --> 00:51:06,559
analyze table name the column and change

00:51:03,680 --> 00:51:06,559
the bucket size

00:51:07,359 --> 00:51:11,359
for information on histograms uh you can

00:51:10,720 --> 00:51:13,839
go out

00:51:11,359 --> 00:51:15,280
to the information schema dot column

00:51:13,839 --> 00:51:18,319
statistics information

00:51:15,280 --> 00:51:19,520
and we'll give you um what the table is

00:51:18,319 --> 00:51:22,000
what the column names that you have a

00:51:19,520 --> 00:51:23,520
histogram on the data type

00:51:22,000 --> 00:51:25,359
and by the way you can't have histograms

00:51:23,520 --> 00:51:26,960
on strings that's designed mainly for

00:51:25,359 --> 00:51:28,400
numerics but it does work

00:51:26,960 --> 00:51:30,720
as you can see there's various bucket

00:51:28,400 --> 00:51:30,720
counts

00:51:31,760 --> 00:51:35,599
so this is an example where histograms

00:51:34,079 --> 00:51:38,079
really shine

00:51:35,599 --> 00:51:39,280
where things really pop for you we're

00:51:38,079 --> 00:51:42,079
going to create a table called

00:51:39,280 --> 00:51:43,839
h1 we have an id field that's an

00:51:42,079 --> 00:51:46,240
unsigned integer

00:51:43,839 --> 00:51:47,680
and then we have x which is another

00:51:46,240 --> 00:51:51,680
integer inside

00:51:47,680 --> 00:51:55,040
and into our table we're going to insert

00:51:51,680 --> 00:51:58,319
two ones three twos and

00:51:55,040 --> 00:52:01,920
four threes and if we select

00:51:58,319 --> 00:52:02,720
the the value and the count of each

00:52:01,920 --> 00:52:06,000
values we see

00:52:02,720 --> 00:52:09,040
once again we have two ones

00:52:06,000 --> 00:52:11,760
three twos and

00:52:09,040 --> 00:52:11,760
four threes

00:52:12,880 --> 00:52:18,720
now if we run a explain

00:52:16,640 --> 00:52:20,720
on select star from h1 where x is

00:52:18,720 --> 00:52:24,079
greater than zero

00:52:20,720 --> 00:52:26,400
the the server will go out there

00:52:24,079 --> 00:52:27,359
and it knows that there's nine rows out

00:52:26,400 --> 00:52:28,960
there

00:52:27,359 --> 00:52:30,960
and it's going to estimate that it's

00:52:28,960 --> 00:52:34,160
going to have to read 33

00:52:30,960 --> 00:52:36,800
and a third of all the tables

00:52:34,160 --> 00:52:38,480
filter is kind of a a rough guesstimate

00:52:36,800 --> 00:52:39,520
of how much data that it knows where it

00:52:38,480 --> 00:52:42,480
is

00:52:39,520 --> 00:52:44,720
and it's kind of like you go out to the

00:52:42,480 --> 00:52:46,880
garage and you know where the christmas

00:52:44,720 --> 00:52:49,280
ornaments are or the hanukkah ornaments

00:52:46,880 --> 00:52:51,359
or some other ornaments

00:52:49,280 --> 00:52:52,400
and you think they're in two boxes but

00:52:51,359 --> 00:52:54,000
you find out that

00:52:52,400 --> 00:52:56,559
no there's another box that you're

00:52:54,000 --> 00:52:58,800
missing that you have to go out and find

00:52:56,559 --> 00:53:00,480
so in this case the optimizers come back

00:52:58,800 --> 00:53:01,760
and said yeah i um

00:53:00,480 --> 00:53:03,680
nine roads and i'm gonna have to read

00:53:01,760 --> 00:53:07,119
about a third of the

00:53:03,680 --> 00:53:08,800
the data and as we know

00:53:07,119 --> 00:53:10,240
um if you look at the where statement x

00:53:08,800 --> 00:53:12,839
is greater than zero our values are

00:53:10,240 --> 00:53:16,000
greater than zero

00:53:12,839 --> 00:53:18,079
so um this

00:53:16,000 --> 00:53:19,520
this example of of how the optimizer

00:53:18,079 --> 00:53:23,839
wants to give you an estimate

00:53:19,520 --> 00:53:27,040
and it may not be an accurate estimate

00:53:23,839 --> 00:53:28,319
so let's analyze our table let's create

00:53:27,040 --> 00:53:31,200
a histogram

00:53:28,319 --> 00:53:31,599
with three buckets why three buckets

00:53:31,200 --> 00:53:33,599
well

00:53:31,599 --> 00:53:34,720
we only have three values i could have

00:53:33,599 --> 00:53:36,160
done more buckets but they would have

00:53:34,720 --> 00:53:39,680
just been uh

00:53:36,160 --> 00:53:41,839
unused so now when i do

00:53:39,680 --> 00:53:43,359
explain select star from each one rest

00:53:41,839 --> 00:53:45,839
is greater than zero

00:53:43,359 --> 00:53:46,400
it knows that there's once again nine

00:53:45,839 --> 00:53:48,960
rows

00:53:46,400 --> 00:53:50,559
and it knows where all the data is so

00:53:48,960 --> 00:53:52,559
the estimate is going to give us

00:53:50,559 --> 00:53:53,599
um the query plan that's going to give

00:53:52,559 --> 00:53:57,200
us is

00:53:53,599 --> 00:53:59,280
a little more more intelligent

00:53:57,200 --> 00:54:00,319
uh of course this is a very simple uh

00:53:59,280 --> 00:54:01,440
query

00:54:00,319 --> 00:54:03,119
and i wish i had something that was a

00:54:01,440 --> 00:54:04,720
better example for a more complex thing

00:54:03,119 --> 00:54:07,920
but that really wouldn't fit in the time

00:54:04,720 --> 00:54:07,920
period that we have here

00:54:08,640 --> 00:54:12,480
so if we look at this with explain

00:54:10,160 --> 00:54:13,200
analyze remember explain analyze

00:54:12,480 --> 00:54:15,119
actually runs

00:54:13,200 --> 00:54:17,040
the query uh where regular explain just

00:54:15,119 --> 00:54:20,000
kind of does a guesstimate

00:54:17,040 --> 00:54:21,520
uh it goes out and gives us the full

00:54:20,000 --> 00:54:24,079
information

00:54:21,520 --> 00:54:26,559
now notice on the bottom line that tells

00:54:24,079 --> 00:54:29,200
us it has to do a table scan

00:54:26,559 --> 00:54:31,040
traditionally dbas will tell you that

00:54:29,200 --> 00:54:34,079
you don't want a full table scan

00:54:31,040 --> 00:54:35,599
well that's not always a bad thing

00:54:34,079 --> 00:54:37,440
in this case we're looking at all the

00:54:35,599 --> 00:54:39,119
records in that table

00:54:37,440 --> 00:54:40,240
if you're doing quarterly statements you

00:54:39,119 --> 00:54:41,520
probably have to go through all the

00:54:40,240 --> 00:54:44,000
customers

00:54:41,520 --> 00:54:45,359
to get that and that's a full table scan

00:54:44,000 --> 00:54:47,760
so the hard fast rule that you want to

00:54:45,359 --> 00:54:52,799
get rid of all tape full table scans

00:54:47,760 --> 00:54:55,280
is not actually a hard and fast rule

00:54:52,799 --> 00:54:56,480
okay performance is just not indexes and

00:54:55,280 --> 00:54:58,079
histograms

00:54:56,480 --> 00:55:00,640
there are a lot of other tweaks that can

00:54:58,079 --> 00:55:03,040
be done to speed things up

00:55:00,640 --> 00:55:04,160
uh you can use explain to see what your

00:55:03,040 --> 00:55:05,119
query is doing

00:55:04,160 --> 00:55:07,440
and one of the things you'll see is

00:55:05,119 --> 00:55:09,440
reports on file sorts full table scans

00:55:07,440 --> 00:55:12,319
using temporary tables

00:55:09,440 --> 00:55:13,440
and um that's handy we'll take a look at

00:55:12,319 --> 00:55:15,839
that a little bit

00:55:13,440 --> 00:55:17,200
also uh does the join order look right

00:55:15,839 --> 00:55:18,400
we're talking about that a little bit

00:55:17,200 --> 00:55:20,480
more

00:55:18,400 --> 00:55:22,160
buffers and caches big enough we don't

00:55:20,480 --> 00:55:23,040
really have time to cover that today but

00:55:22,160 --> 00:55:24,400
uh

00:55:23,040 --> 00:55:26,559
there's some other things you can do to

00:55:24,400 --> 00:55:28,960
look at uh do you have enough memory

00:55:26,559 --> 00:55:30,000
uh if your system is three years old and

00:55:28,960 --> 00:55:33,599
you've added

00:55:30,000 --> 00:55:35,200
500 new customers uh in the past quarter

00:55:33,599 --> 00:55:36,960
uh you might be constrained by your

00:55:35,200 --> 00:55:40,799
hardware also

00:55:36,960 --> 00:55:44,559
uh discs have rapidly been evolving

00:55:40,799 --> 00:55:46,079
uh if your uh disks

00:55:44,559 --> 00:55:49,599
for those who haven't done everything on

00:55:46,079 --> 00:55:53,440
the cloud yet your disk might be

00:55:49,599 --> 00:55:54,319
holding you back so something we've also

00:55:53,440 --> 00:55:57,440
changed nato

00:55:54,319 --> 00:55:59,119
is locking options the two we introduced

00:55:57,440 --> 00:56:01,680
that might change the way you architect

00:55:59,119 --> 00:56:02,240
things is the no wait option and the

00:56:01,680 --> 00:56:06,000
skipped

00:56:02,240 --> 00:56:07,200
lock option um these i'll show you in a

00:56:06,000 --> 00:56:10,720
minute where they uh

00:56:07,200 --> 00:56:13,119
with some examples are very very handy

00:56:10,720 --> 00:56:15,040
traditionally when you when you lock try

00:56:13,119 --> 00:56:17,760
to lock some information

00:56:15,040 --> 00:56:19,680
uh either it locks all that for you that

00:56:17,760 --> 00:56:21,680
exactly what you requested

00:56:19,680 --> 00:56:22,880
or you're told to wait while it goes out

00:56:21,680 --> 00:56:24,240
there to get those like

00:56:22,880 --> 00:56:26,079
those locks for you and you're

00:56:24,240 --> 00:56:27,119
constrained for whoever else has the

00:56:26,079 --> 00:56:28,839
data locked

00:56:27,119 --> 00:56:31,040
and is waiting to lock it in front of

00:56:28,839 --> 00:56:32,799
you

00:56:31,040 --> 00:56:34,960
so this example we're going to go out

00:56:32,799 --> 00:56:40,079
and buy some concert tickets

00:56:34,960 --> 00:56:41,920
and we're going to start a transaction

00:56:40,079 --> 00:56:45,040
uh pretend your ticket master by the way

00:56:41,920 --> 00:56:47,760
ticketmaster does use mysql for its uh

00:56:45,040 --> 00:56:49,440
seating front end and we want to find

00:56:47,760 --> 00:56:51,440
seat numbers and row numbers and the

00:56:49,440 --> 00:56:52,720
cost of tickets from a table called

00:56:51,440 --> 00:56:55,440
seats

00:56:52,720 --> 00:56:56,960
that we're going to abbreviate as s and

00:56:55,440 --> 00:57:00,079
we're going to join that

00:56:56,960 --> 00:57:03,200
to the seat rows table called

00:57:00,079 --> 00:57:07,119
sr using the row number

00:57:03,200 --> 00:57:09,520
and we're looking for seats in row

00:57:07,119 --> 00:57:10,319
seats three or four and rows five and

00:57:09,520 --> 00:57:12,160
six

00:57:10,319 --> 00:57:13,599
uh maybe this is the lucky seat for us

00:57:12,160 --> 00:57:17,440
maybe this is the uh

00:57:13,599 --> 00:57:18,799
best uh acoustic uh place in the entire

00:57:17,440 --> 00:57:21,839
auditorium

00:57:18,799 --> 00:57:25,359
so we're looking for specific seats

00:57:21,839 --> 00:57:27,280
in new specific rows and of course

00:57:25,359 --> 00:57:28,640
we don't want to go out there and look

00:57:27,280 --> 00:57:29,920
for those tickets if they're already

00:57:28,640 --> 00:57:31,920
locked

00:57:29,920 --> 00:57:33,520
and we're going to lock these tables for

00:57:31,920 --> 00:57:33,920
update and then we're going to tell it

00:57:33,520 --> 00:57:37,200
skip

00:57:33,920 --> 00:57:40,480
lock now in this case

00:57:37,200 --> 00:57:41,680
if seats 3 and four and five are already

00:57:40,480 --> 00:57:44,799
locked by someone

00:57:41,680 --> 00:57:47,920
you'll only get the records for row six

00:57:44,799 --> 00:57:48,559
if both seats three and four and both

00:57:47,920 --> 00:57:52,240
rows

00:57:48,559 --> 00:57:53,280
are already taken um you get a return

00:57:52,240 --> 00:57:55,520
right away saying hey

00:57:53,280 --> 00:57:56,799
um those aren't there but have you

00:57:55,520 --> 00:57:58,960
looked in row seven

00:57:56,799 --> 00:58:00,480
and you can summarize logically let's

00:57:58,960 --> 00:58:03,040
look at rows seven and eight maybe we

00:58:00,480 --> 00:58:03,040
can get there

00:58:03,920 --> 00:58:09,599
uh lock no weight uh just a slight

00:58:06,400 --> 00:58:13,119
variation on on this so once again

00:58:09,599 --> 00:58:16,720
we're looking for seats three and four

00:58:13,119 --> 00:58:20,559
and we're looking for rows in uh

00:58:16,720 --> 00:58:23,440
we're seat stream four in row 12.

00:58:20,559 --> 00:58:24,000
and again not booked and we're going to

00:58:23,440 --> 00:58:26,640
do

00:58:24,000 --> 00:58:27,760
gift locked and we want to share these

00:58:26,640 --> 00:58:30,319
seats

00:58:27,760 --> 00:58:31,440
and we're going to put this in as no

00:58:30,319 --> 00:58:35,440
wait

00:58:31,440 --> 00:58:37,599
if these are available

00:58:35,440 --> 00:58:39,680
uh you'll get that and you'll get that

00:58:37,599 --> 00:58:42,640
those records locked for you to update

00:58:39,680 --> 00:58:44,960
uh if they're not available it returns

00:58:42,640 --> 00:58:47,280
right away

00:58:44,960 --> 00:58:48,559
now if we hadn't had no weight on there

00:58:47,280 --> 00:58:52,000
you would have had to wait for

00:58:48,559 --> 00:58:55,359
a default timeout of 50 seconds which

00:58:52,000 --> 00:58:58,400
if you're trying to go for hot uh

00:58:55,359 --> 00:59:01,599
seats for a hot concert you can

00:58:58,400 --> 00:59:03,200
know that that's often a bad thing

00:59:01,599 --> 00:59:05,839
you're not going to go into that see

00:59:03,200 --> 00:59:08,000
that artist that you want to see

00:59:05,839 --> 00:59:09,280
okay other fast ways of improving your

00:59:08,000 --> 00:59:10,400
queries

00:59:09,280 --> 00:59:12,480
well we're going to talk about resource

00:59:10,400 --> 00:59:13,280
groups optimizer hints partitioning and

00:59:12,480 --> 00:59:16,480
multi-value

00:59:13,280 --> 00:59:19,920
indexes resource

00:59:16,480 --> 00:59:23,040
groups if you have a multi

00:59:19,920 --> 00:59:25,119
core multiple virtual cpu machine

00:59:23,040 --> 00:59:26,480
you can create resource groups in this

00:59:25,119 --> 00:59:29,280
case we're going to create a group

00:59:26,480 --> 00:59:31,680
called batch for low priority processing

00:59:29,280 --> 00:59:32,319
and we're going to dedicate two cpus to

00:59:31,680 --> 00:59:33,520
it

00:59:32,319 --> 00:59:35,839
uh we're hoping here that you have at

00:59:33,520 --> 00:59:38,400
least a four cpu machine to do that

00:59:35,839 --> 00:59:38,960
uh by the way you you can lock yourself

00:59:38,400 --> 00:59:42,240
out

00:59:38,960 --> 00:59:43,920
of other virtual cpus by specifying all

00:59:42,240 --> 00:59:46,799
your cpus for

00:59:43,920 --> 00:59:48,160
a resource group that you're going to

00:59:46,799 --> 00:59:51,440
default to

00:59:48,160 --> 00:59:54,000
set a thread priority and

00:59:51,440 --> 00:59:55,599
when you're making your queries you can

00:59:54,000 --> 00:59:58,960
either type in

00:59:55,599 --> 01:00:00,640
set resource group batch in the start of

00:59:58,960 --> 01:00:04,559
your transaction

01:00:00,640 --> 01:00:08,799
or this is called an optimizer hint

01:00:04,559 --> 01:00:12,720
uh we make a comment inside the query

01:00:08,799 --> 01:00:14,880
and yeah like you know that um

01:00:12,720 --> 01:00:16,559
i'll talk about that later so when you

01:00:14,880 --> 01:00:18,640
go to insert these records

01:00:16,559 --> 01:00:19,920
and see research batch group the

01:00:18,640 --> 01:00:22,960
optimizer will

01:00:19,920 --> 01:00:26,400
push these off to those two virtual cpus

01:00:22,960 --> 01:00:26,400
for that group resource group

01:00:26,559 --> 01:00:31,280
optimizer hints once again these are

01:00:29,119 --> 01:00:33,920
comments within a query as you see there

01:00:31,280 --> 01:00:36,000
in red in this example you know that if

01:00:33,920 --> 01:00:38,079
you join t1 to t2

01:00:36,000 --> 01:00:39,440
it gives you the performance you want

01:00:38,079 --> 01:00:41,599
remember

01:00:39,440 --> 01:00:42,559
the optimizer wants to go for the

01:00:41,599 --> 01:00:45,599
smallest

01:00:42,559 --> 01:00:50,799
of the two targets first

01:00:45,599 --> 01:00:53,920
so in this case um maybe t2

01:00:50,799 --> 01:00:54,400
uh well let's just say t2 doesn't give

01:00:53,920 --> 01:00:56,000
you

01:00:54,400 --> 01:00:57,599
the performance you want so you want to

01:00:56,000 --> 01:01:01,040
force it to go t1

01:00:57,599 --> 01:01:02,640
to t2 instead of t2 to t1

01:01:01,040 --> 01:01:04,079
now there are lots of other optimizer

01:01:02,640 --> 01:01:05,520
hints on there type of push down

01:01:04,079 --> 01:01:06,240
conditions you can do a whole bunch of

01:01:05,520 --> 01:01:11,839
other stuff

01:01:06,240 --> 01:01:11,839
well this is probably the handiest one

01:01:12,319 --> 01:01:16,799
partitioning you can actually partition

01:01:15,599 --> 01:01:20,079
your data

01:01:16,799 --> 01:01:22,079
by a value in a column hopefully please

01:01:20,079 --> 01:01:24,480
please please use a key

01:01:22,079 --> 01:01:26,079
this is supported with our nodb and ndb

01:01:24,480 --> 01:01:28,880
storage engines

01:01:26,079 --> 01:01:29,440
and if you want to partition your data

01:01:28,880 --> 01:01:32,559
by

01:01:29,440 --> 01:01:34,480
some sort of time interval or by

01:01:32,559 --> 01:01:37,200
a geographic location or something like

01:01:34,480 --> 01:01:39,920
that you can actually

01:01:37,200 --> 01:01:41,760
have different uh platters different

01:01:39,920 --> 01:01:44,079
partitions different areas

01:01:41,760 --> 01:01:45,440
uh segmented off for this and the

01:01:44,079 --> 01:01:46,799
optimizer will know that if you're

01:01:45,440 --> 01:01:48,400
looking for something in great britain

01:01:46,799 --> 01:01:53,040
and you're partitioned off by country

01:01:48,400 --> 01:01:56,319
it'll go just go to that partition

01:01:53,040 --> 01:02:00,480
so let's go a little bit more into

01:01:56,319 --> 01:02:00,480
how the query optimizer really

01:02:00,799 --> 01:02:06,160
really does stuff for you this is where

01:02:04,240 --> 01:02:07,520
things get a little tricky so if you

01:02:06,160 --> 01:02:10,559
have some caffeine with you please take

01:02:07,520 --> 01:02:10,559
a big gulp right now

01:02:11,039 --> 01:02:16,400
so here's our query

01:02:14,079 --> 01:02:17,440
we're going to select from the table

01:02:16,400 --> 01:02:19,599
city

01:02:17,440 --> 01:02:20,720
its name we're going to select from the

01:02:19,599 --> 01:02:24,400
city country

01:02:20,720 --> 01:02:26,799
it's name column and we're going to

01:02:24,400 --> 01:02:27,839
join the country column to the city

01:02:26,799 --> 01:02:31,680
column

01:02:27,839 --> 01:02:34,160
on two column uh tables on two columns

01:02:31,680 --> 01:02:35,760
in the city call city table there's a

01:02:34,160 --> 01:02:38,000
column called country code

01:02:35,760 --> 01:02:39,200
that corresponds to the country.code

01:02:38,000 --> 01:02:41,039
column

01:02:39,200 --> 01:02:43,119
and in this case we're going to look for

01:02:41,039 --> 01:02:46,240
where the country code is equal to

01:02:43,119 --> 01:02:48,000
gbr so

01:02:46,240 --> 01:02:49,599
fairly simple we're driving two pieces

01:02:48,000 --> 01:02:50,720
of information one each from two

01:02:49,599 --> 01:02:53,280
different tables

01:02:50,720 --> 01:02:55,440
and we're only interested in those from

01:02:53,280 --> 01:02:58,160
great britain

01:02:55,440 --> 01:02:59,680
so once again i feel like a magician

01:02:58,160 --> 01:03:00,079
explaining a very bad card trick here

01:02:59,680 --> 01:03:01,119
but

01:03:00,079 --> 01:03:03,680
we're going to go out there and get

01:03:01,119 --> 01:03:06,079
city.name and country.name

01:03:03,680 --> 01:03:07,839
from the city table on the country table

01:03:06,079 --> 01:03:11,039
that's how the two tables

01:03:07,839 --> 01:03:13,520
are correspond to each other

01:03:11,039 --> 01:03:14,400
and once again we only want all the

01:03:13,520 --> 01:03:17,200
records

01:03:14,400 --> 01:03:19,200
that correspond where the country.code

01:03:17,200 --> 01:03:22,400
could have been the city.country code

01:03:19,200 --> 01:03:23,280
equals to gbr now the optimizer sees

01:03:22,400 --> 01:03:24,960
your query

01:03:23,280 --> 01:03:28,799
and looks at it says okay is there

01:03:24,960 --> 01:03:30,799
something i can do here to simplify it

01:03:28,799 --> 01:03:32,000
well if you run explain on it um you see

01:03:30,799 --> 01:03:35,440
the the basics

01:03:32,000 --> 01:03:36,160
of the two queries um as you see the top

01:03:35,440 --> 01:03:39,039
one

01:03:36,160 --> 01:03:40,000
uh it's going to want to use the table

01:03:39,039 --> 01:03:43,599
country

01:03:40,000 --> 01:03:47,039
it has a

01:03:43,599 --> 01:03:49,200
the constant is country code equals gbr

01:03:47,039 --> 01:03:51,520
uh this is this is the tricky part here

01:03:49,200 --> 01:03:53,119
country code is gbr is a constant

01:03:51,520 --> 01:03:54,880
uh it sees that we have a possible key

01:03:53,119 --> 01:03:55,760
of using the primary it is going to use

01:03:54,880 --> 01:03:59,280
the com

01:03:55,760 --> 01:04:01,520
the primary in the city

01:03:59,280 --> 01:04:03,200
uh it has a possible key it's using its

01:04:01,520 --> 01:04:05,280
possible key

01:04:03,200 --> 01:04:07,119
and once again both these it says

01:04:05,280 --> 01:04:08,640
filtered 100 so it knows

01:04:07,119 --> 01:04:11,200
roughly where well it was pretty well

01:04:08,640 --> 01:04:14,640
where the data is

01:04:11,200 --> 01:04:18,079
so if we look at the actual query plan

01:04:14,640 --> 01:04:20,160
it tells us that uh it's going to select

01:04:18,079 --> 01:04:24,000
world.city

01:04:20,160 --> 01:04:25,839
uh the name capital end name as name

01:04:24,000 --> 01:04:28,079
it's going to select the united

01:04:25,839 --> 01:04:31,039
kingdom's name

01:04:28,079 --> 01:04:31,599
from worlds.city join world.country

01:04:31,039 --> 01:04:35,119
where we're

01:04:31,599 --> 01:04:38,079
sitting named country code equals gbr

01:04:35,119 --> 01:04:39,200
so the optimizer whenever we're going

01:04:38,079 --> 01:04:42,559
out there to

01:04:39,200 --> 01:04:43,520
two tables well the optimizer said well

01:04:42,559 --> 01:04:46,880
we don't really need to

01:04:43,520 --> 01:04:46,880
dive into the second table

01:04:47,440 --> 01:04:52,720
to get the the name for that one piece

01:04:50,160 --> 01:04:52,720
of output

01:04:52,960 --> 01:04:58,640
and also noticed um that

01:04:56,240 --> 01:05:03,039
it instead of uh it's done the

01:04:58,640 --> 01:05:08,160
world.city country code equals gbr

01:05:03,039 --> 01:05:11,839
where earlier we had

01:05:08,160 --> 01:05:11,839
country.code equals gvr

01:05:12,319 --> 01:05:16,160
so it's gone from country over to city

01:05:13,920 --> 01:05:16,160
there

01:05:18,079 --> 01:05:22,480
so the optimizer knows just to grab the

01:05:20,480 --> 01:05:24,640
gbr records from the city table

01:05:22,480 --> 01:05:27,920
and does not really need to read the

01:05:24,640 --> 01:05:27,920
country table at all

01:05:28,240 --> 01:05:37,200
so the optimizers saved us some

01:05:31,280 --> 01:05:39,520
some work there

01:05:37,200 --> 01:05:40,640
and when you run explain analyze um you

01:05:39,520 --> 01:05:43,039
can see that

01:05:40,640 --> 01:05:46,000
uh our estimate from the previous step

01:05:43,039 --> 01:05:46,000
is was pretty good

01:05:46,640 --> 01:05:50,799
now to dig into this gap once again when

01:05:50,079 --> 01:05:54,079
you're reading

01:05:50,799 --> 01:05:54,079
the output from explain

01:05:55,200 --> 01:06:01,760
we had this country code equals gbr so

01:05:59,440 --> 01:06:03,119
it knows that the type of query we're

01:06:01,760 --> 01:06:04,640
going to do is going to be using a

01:06:03,119 --> 01:06:09,920
constant

01:06:04,640 --> 01:06:14,640
and that's our country coders gvr

01:06:09,920 --> 01:06:16,720
now a little bit further down if you

01:06:14,640 --> 01:06:19,119
look at the type for the second query on

01:06:16,720 --> 01:06:22,799
city it's a reference

01:06:19,119 --> 01:06:22,799
and once again that's the gbr

01:06:23,760 --> 01:06:26,720
now if you run out to the manual for

01:06:24,960 --> 01:06:28,240
mysql it will tell you what the various

01:06:26,720 --> 01:06:30,160
columns mean

01:06:28,240 --> 01:06:32,079
and if you've never looked through this

01:06:30,160 --> 01:06:34,160
before i recommend

01:06:32,079 --> 01:06:35,440
a good read there's a lot of information

01:06:34,160 --> 01:06:36,319
here there's some books later i'll

01:06:35,440 --> 01:06:39,039
recommend that

01:06:36,319 --> 01:06:40,079
go into more detail but the basic

01:06:39,039 --> 01:06:43,200
outputs you're getting

01:06:40,079 --> 01:06:43,200
are which columns

01:06:44,880 --> 01:06:48,960
are being looked at uh the table name if

01:06:47,280 --> 01:06:52,240
there's any partitions

01:06:48,960 --> 01:06:53,920
um uh um

01:06:52,240 --> 01:06:56,799
i should explain this this is uh when

01:06:53,920 --> 01:06:59,200
you for the type of join

01:06:56,799 --> 01:07:00,000
where you have um the type here for

01:06:59,200 --> 01:07:02,480
constant or

01:07:00,000 --> 01:07:02,480
reference

01:07:04,400 --> 01:07:09,599
you'll see a whole bunch of joint type

01:07:07,680 --> 01:07:12,160
information that

01:07:09,599 --> 01:07:12,160
is out there

01:07:12,720 --> 01:07:16,160
this is the raw data that comes to you

01:07:14,319 --> 01:07:18,079
it is tricky to learn how to read

01:07:16,160 --> 01:07:20,400
it is worthwhile doing if you have a lot

01:07:18,079 --> 01:07:23,599
of queries that you're responsible for

01:07:20,400 --> 01:07:27,440
uh the trick to watch for is are there

01:07:23,599 --> 01:07:31,520
possible keys out there and what keys is

01:07:27,440 --> 01:07:31,520
actually using it can only use one key

01:07:31,599 --> 01:07:38,000
at a time so some general rules

01:07:36,000 --> 01:07:39,920
go out there and look at indexing or

01:07:38,000 --> 01:07:43,680
histograming columns on the right side

01:07:39,920 --> 01:07:47,039
of a where clause

01:07:43,680 --> 01:07:49,039
also look at sorting

01:07:47,039 --> 01:07:50,640
or indexing columns that you sort on on

01:07:49,039 --> 01:07:54,400
a regular basis

01:07:50,640 --> 01:07:57,599
be sure you test that once again

01:07:54,400 --> 01:07:59,359
join on like types and size columns

01:07:57,599 --> 01:08:01,520
also if you do a covering index where

01:07:59,359 --> 01:08:04,799
you get all your data out of the index

01:08:01,520 --> 01:08:06,000
um it's like you have a limited number

01:08:04,799 --> 01:08:10,480
of customers you

01:08:06,000 --> 01:08:10,880
index um maybe their customer number and

01:08:10,480 --> 01:08:12,960
their

01:08:10,880 --> 01:08:14,960
their zip code so that when they or

01:08:12,960 --> 01:08:16,400
their postal code so that when they uh

01:08:14,960 --> 01:08:18,319
call you up and say i'm customer one two

01:08:16,400 --> 01:08:18,960
three four uh what's the shipping rate

01:08:18,319 --> 01:08:21,520
to

01:08:18,960 --> 01:08:22,480
uh raleigh it actually has that

01:08:21,520 --> 01:08:24,560
information because you have the zip

01:08:22,480 --> 01:08:26,480
code and they can

01:08:24,560 --> 01:08:28,640
look that up in another table for the

01:08:26,480 --> 01:08:32,319
shipping rates

01:08:28,640 --> 01:08:35,440
okay let's look at a nastier

01:08:32,319 --> 01:08:37,279
query this one is

01:08:35,440 --> 01:08:40,239
from our sequila database which you'll

01:08:37,279 --> 01:08:43,359
see in a lot of mysql documentation

01:08:40,239 --> 01:08:44,159
the tequila database was a recreation of

01:08:43,359 --> 01:08:47,839
a

01:08:44,159 --> 01:08:50,159
video tape rental store

01:08:47,839 --> 01:08:51,199
uh believe it or not to the younger

01:08:50,159 --> 01:08:53,279
generation

01:08:51,199 --> 01:08:55,440
uh if you wanted to see a movie you

01:08:53,279 --> 01:08:56,000
drove to the nearest strip mall went to

01:08:55,440 --> 01:08:58,719
a

01:08:56,000 --> 01:09:00,080
shop usually called blockbuster uh

01:08:58,719 --> 01:09:01,600
searched through the aisles for the

01:09:00,080 --> 01:09:04,080
available movies

01:09:01,600 --> 01:09:05,600
and uh actually rented them for a set

01:09:04,080 --> 01:09:08,799
amount of time

01:09:05,600 --> 01:09:10,880
now in this example

01:09:08,799 --> 01:09:12,400
we're going to select some data from one

01:09:10,880 --> 01:09:13,920
table called rental

01:09:12,400 --> 01:09:15,759
that's going to be joined on the

01:09:13,920 --> 01:09:17,600
customer on another table has the

01:09:15,759 --> 01:09:18,640
customer's address

01:09:17,600 --> 01:09:21,040
we're actually going to go out and have

01:09:18,640 --> 01:09:23,600
an inventory for all the the videotapes

01:09:21,040 --> 01:09:23,600
we're going to get

01:09:23,839 --> 01:09:27,520
the list of information on the film

01:09:25,600 --> 01:09:30,239
that's from the inventory

01:09:27,520 --> 01:09:30,239
and we're going to do

01:09:30,960 --> 01:09:33,920
we're going to look for the ones where

01:09:31,920 --> 01:09:35,440
the rental return date is null which

01:09:33,920 --> 01:09:37,920
means it hasn't been returned

01:09:35,440 --> 01:09:40,080
in this case we're also looking for the

01:09:37,920 --> 01:09:40,080
uh

01:09:40,319 --> 01:09:46,480
the rental date is um

01:09:44,400 --> 01:09:48,319
the rental date plus an interval for the

01:09:46,480 --> 01:09:50,640
length of time you can rent the the tape

01:09:48,319 --> 01:09:52,080
hot tapes you can render overnight um

01:09:50,640 --> 01:09:54,320
less interesting tapes

01:09:52,080 --> 01:09:55,520
uh you can rent for a longer period of

01:09:54,320 --> 01:09:57,520
time and

01:09:55,520 --> 01:09:59,199
check that against the current date so

01:09:57,520 --> 01:10:01,600
you're kind of looking for

01:09:59,199 --> 01:10:04,719
who has the most amount of tapes out

01:10:01,600 --> 01:10:04,719
that need to be returned

01:10:05,040 --> 01:10:08,880
so if you want to explain on this you

01:10:07,040 --> 01:10:12,960
get a lot of stuff back

01:10:08,880 --> 01:10:15,360
and um the old amigo my eyes

01:10:12,960 --> 01:10:18,159
glaze over when you look at that but

01:10:15,360 --> 01:10:18,159
there's a really

01:10:18,960 --> 01:10:22,480
there's really a treasure trove of

01:10:20,320 --> 01:10:25,040
information in here

01:10:22,480 --> 01:10:25,920
so what you do is you start simply if

01:10:25,040 --> 01:10:29,040
you're beginning

01:10:25,920 --> 01:10:31,679
at this i recommend

01:10:29,040 --> 01:10:33,440
looking at it with visual explain this

01:10:31,679 --> 01:10:35,040
helps give you a rough idea what happens

01:10:33,440 --> 01:10:36,719
we're going to go out and scan the full

01:10:35,040 --> 01:10:40,080
table of rental to find all the

01:10:36,719 --> 01:10:43,199
the movies and check which ones

01:10:40,080 --> 01:10:46,640
haven't uh met our other conditions

01:10:43,199 --> 01:10:49,199
and see this is all nested loop

01:10:46,640 --> 01:10:49,760
joins here and gives our information you

01:10:49,199 --> 01:10:53,199
actually see

01:10:49,760 --> 01:10:55,280
the the cost of various steps

01:10:53,199 --> 01:10:57,600
this step is the cost of 560 has to read

01:10:55,280 --> 01:10:58,960
one row

01:10:57,600 --> 01:11:01,120
here where things are combined and

01:10:58,960 --> 01:11:05,280
sorted you see the total query cost ends

01:11:01,120 --> 01:11:05,280
up being 5500 roughly

01:11:05,840 --> 01:11:12,000
so let's look at this uh tree format

01:11:09,520 --> 01:11:12,880
uh it gives you the same information you

01:11:12,000 --> 01:11:16,400
saw on the

01:11:12,880 --> 01:11:17,760
the previous page

01:11:16,400 --> 01:11:20,400
but doesn't give you a lot of detail

01:11:17,760 --> 01:11:23,040
what's actually going on

01:11:20,400 --> 01:11:24,000
so back to the old tabular explain and

01:11:23,040 --> 01:11:25,920
once again

01:11:24,000 --> 01:11:27,840
this can make your eyes glow release

01:11:25,920 --> 01:11:29,600
over and once again

01:11:27,840 --> 01:11:32,239
if this is kind of overloading you come

01:11:29,600 --> 01:11:34,400
back later the slides are available

01:11:32,239 --> 01:11:35,520
and you can go through all this so we

01:11:34,400 --> 01:11:38,640
get this information

01:11:35,520 --> 01:11:41,280
and let's take a look at it um

01:11:38,640 --> 01:11:43,199
cleaned up a little bit we have the name

01:11:41,280 --> 01:11:45,040
of the table so we're going after rental

01:11:43,199 --> 01:11:48,320
customer address inventory

01:11:45,040 --> 01:11:51,520
film uh we see possible keys

01:11:48,320 --> 01:11:54,960
that it can use in this case it has one

01:11:51,520 --> 01:11:56,640
two possible keys but it's not using a

01:11:54,960 --> 01:11:59,120
key

01:11:56,640 --> 01:12:00,400
so usually full table scans are bad

01:11:59,120 --> 01:12:04,000
things in this case

01:12:00,400 --> 01:12:06,640
it's unavoidable in this case

01:12:04,000 --> 01:12:08,719
the customer table we have two possible

01:12:06,640 --> 01:12:12,080
keys and it's using the primary

01:12:08,719 --> 01:12:13,520
as we know primaries are are pretty nice

01:12:12,080 --> 01:12:15,520
uh usually a little bit faster than

01:12:13,520 --> 01:12:16,640
secondaries so that's that's good

01:12:15,520 --> 01:12:20,320
information

01:12:16,640 --> 01:12:21,920
well what else do we need to know

01:12:20,320 --> 01:12:24,719
well here's all the keys that are

01:12:21,920 --> 01:12:27,760
possible and uh

01:12:24,719 --> 01:12:30,880
once again this one doesn't use

01:12:27,760 --> 01:12:32,640
any keys so that's always going to be

01:12:30,880 --> 01:12:34,400
whenever you see a full table scanner

01:12:32,640 --> 01:12:36,880
type equals all

01:12:34,400 --> 01:12:40,080
always make sure that you really need to

01:12:36,880 --> 01:12:40,080
get all that information

01:12:40,320 --> 01:12:46,159
so back to our our uh

01:12:43,840 --> 01:12:46,960
our nasty query with all the joins in

01:12:46,159 --> 01:12:51,360
here

01:12:46,960 --> 01:12:54,320
um let's take a look at it um

01:12:51,360 --> 01:12:55,040
with a little more discerning eye so a

01:12:54,320 --> 01:12:56,560
lot of folks

01:12:55,040 --> 01:12:58,239
are going to look at this type of query

01:12:56,560 --> 01:13:01,360
and they're going to come back and say

01:12:58,239 --> 01:13:03,679
why is this query so slow if it only

01:13:01,360 --> 01:13:04,719
returns five records if you notice down

01:13:03,679 --> 01:13:08,000
here on the bottom

01:13:04,719 --> 01:13:10,719
it says limit five well

01:13:08,000 --> 01:13:12,080
what happens is to get this information

01:13:10,719 --> 01:13:14,800
it has to

01:13:12,080 --> 01:13:15,600
compile all the information so yes it's

01:13:14,800 --> 01:13:19,280
only returning

01:13:15,600 --> 01:13:22,080
five lines of data five rows of data

01:13:19,280 --> 01:13:22,560
but it has to compile all the data to

01:13:22,080 --> 01:13:25,280
give you

01:13:22,560 --> 01:13:27,600
the top five if you don't have to rank

01:13:25,280 --> 01:13:27,600
data

01:13:27,840 --> 01:13:32,800
it's usually faster so

01:13:31,280 --> 01:13:34,480
if we come back here and take a look at

01:13:32,800 --> 01:13:37,840
our our nasty explain

01:13:34,480 --> 01:13:39,440
output um this is the extra field this

01:13:37,840 --> 01:13:40,320
wraps badly and i couldn't figure out a

01:13:39,440 --> 01:13:42,800
way to do it

01:13:40,320 --> 01:13:44,159
uh it tells us that we're using a where

01:13:42,800 --> 01:13:45,679
statement

01:13:44,159 --> 01:13:47,440
which means there's extra logic that has

01:13:45,679 --> 01:13:50,560
to be on more than a straight joint

01:13:47,440 --> 01:13:52,960
we're using a temporary table temporary

01:13:50,560 --> 01:13:54,560
tables are a lot faster than mysql80 if

01:13:52,960 --> 01:13:56,719
you're running five seven or before

01:13:54,560 --> 01:13:59,120
what happens is there's a preset limit

01:13:56,719 --> 01:14:01,440
on the temporary table this is a special

01:13:59,120 --> 01:14:03,920
storage engine when i got to a certain

01:14:01,440 --> 01:14:06,239
size everything would halt

01:14:03,920 --> 01:14:08,080
all the data be copied over to an nodb

01:14:06,239 --> 01:14:10,719
table and then restarted

01:14:08,080 --> 01:14:11,920
that that halting copy restart was very

01:14:10,719 --> 01:14:15,360
expensive

01:14:11,920 --> 01:14:17,040
also file sort of file sorts

01:14:15,360 --> 01:14:19,040
um you have to go out to disk and have

01:14:17,040 --> 01:14:22,159
the system do the the file sort

01:14:19,040 --> 01:14:23,360
or you do file sort within the server uh

01:14:22,159 --> 01:14:27,040
that's an expensive thing

01:14:23,360 --> 01:14:30,239
maybe if we index the column there

01:14:27,040 --> 01:14:30,239
we don't we can avoid that

01:14:30,640 --> 01:14:34,239
as i mentioned earlier um the edo

01:14:33,120 --> 01:14:37,840
temporary table

01:14:34,239 --> 01:14:39,840
space is much much much faster and uh

01:14:37,840 --> 01:14:42,239
you'll find it roughly between 10 and 15

01:14:39,840 --> 01:14:43,600
percent faster

01:14:42,239 --> 01:14:44,640
so when you start looking at that ask

01:14:43,600 --> 01:14:45,679
your query you're going to ask go out

01:14:44,640 --> 01:14:47,600
there and say is there something on

01:14:45,679 --> 01:14:49,920
index that we might index

01:14:47,600 --> 01:14:52,159
um or could it be something better if we

01:14:49,920 --> 01:14:53,760
use the histogram

01:14:52,159 --> 01:14:55,360
also the other thing is is there a

01:14:53,760 --> 01:14:56,320
better way to make a key can we make a

01:14:55,360 --> 01:14:59,040
composite key

01:14:56,320 --> 01:15:02,080
could we use two or three columns to uh

01:14:59,040 --> 01:15:02,080
to do what we need to do

01:15:02,880 --> 01:15:06,400
so one of the things you do is you can

01:15:04,239 --> 01:15:07,120
type the uh to check on indexes you can

01:15:06,400 --> 01:15:09,920
tote

01:15:07,120 --> 01:15:11,040
you type show index from rental uh we'll

01:15:09,920 --> 01:15:13,520
find out there's actually

01:15:11,040 --> 01:15:15,199
more indexes out there than what we're

01:15:13,520 --> 01:15:17,040
seeing in the explain

01:15:15,199 --> 01:15:19,120
uh there's the primary of course there's

01:15:17,040 --> 01:15:20,960
one for rental date

01:15:19,120 --> 01:15:22,320
there's one for inventory id and the

01:15:20,960 --> 01:15:25,440
customer id

01:15:22,320 --> 01:15:28,640
also we have two foreign keys and they

01:15:25,440 --> 01:15:28,640
tie to other tables

01:15:29,679 --> 01:15:34,960
same with film there's more indexes out

01:15:31,520 --> 01:15:34,960
there that we saw from explained

01:15:35,040 --> 01:15:39,280
also something you might want to do is

01:15:37,440 --> 01:15:41,040
consider a functional index

01:15:39,280 --> 01:15:42,800
uh this stuff in red we're trying to

01:15:41,040 --> 01:15:43,520
figure out a rental date plus interval

01:15:42,800 --> 01:15:45,679
time

01:15:43,520 --> 01:15:48,000
and check that versus current date which

01:15:45,679 --> 01:15:51,280
is a function call

01:15:48,000 --> 01:15:52,960
maybe you can find a way

01:15:51,280 --> 01:15:55,040
generated column or a functional index

01:15:52,960 --> 01:15:56,080
to actually get that materialized in its

01:15:55,040 --> 01:15:59,040
own column

01:15:56,080 --> 01:16:01,120
so you know what t what videos are due

01:15:59,040 --> 01:16:03,840
back on what dates

01:16:01,120 --> 01:16:05,120
uh how do you do this well trial and

01:16:03,840 --> 01:16:06,640
error

01:16:05,120 --> 01:16:08,159
one of the problems with the declarative

01:16:06,640 --> 01:16:11,760
language like sql

01:16:08,159 --> 01:16:13,360
is that you can't look at a a query and

01:16:11,760 --> 01:16:14,880
tell if it's good or not

01:16:13,360 --> 01:16:16,560
if you've been programming for more than

01:16:14,880 --> 01:16:18,320
say two months or so you can look at a

01:16:16,560 --> 01:16:20,719
piece of code and tell

01:16:18,320 --> 01:16:21,600
whether it's good or not procedural

01:16:20,719 --> 01:16:23,440
languages or

01:16:21,600 --> 01:16:25,920
object-oriented languages uh you can

01:16:23,440 --> 01:16:27,440
look at that it's called a code smell

01:16:25,920 --> 01:16:29,600
occasionally here older programmers

01:16:27,440 --> 01:16:31,280
going into someone's github library they

01:16:29,600 --> 01:16:33,360
look at something and they go

01:16:31,280 --> 01:16:35,120
that code doesn't smell right to me they

01:16:33,360 --> 01:16:38,159
look at the code just something doesn't

01:16:35,120 --> 01:16:39,679
bring performance to them uh sql

01:16:38,159 --> 01:16:41,280
yeah i can't do that you have to look at

01:16:39,679 --> 01:16:45,199
the underlying data structure

01:16:41,280 --> 01:16:45,199
and the other underlying indexes

01:16:45,520 --> 01:16:48,880
so let's say we want to go out and add

01:16:48,080 --> 01:16:51,280
that column

01:16:48,880 --> 01:16:52,960
um do we want to run an alter table

01:16:51,280 --> 01:16:54,960
before 80 adding a

01:16:52,960 --> 01:16:56,480
column was very expensive everything had

01:16:54,960 --> 01:16:58,800
to be copied over

01:16:56,480 --> 01:16:59,520
uh basically processing halted the table

01:16:58,800 --> 01:17:01,040
that you were cop

01:16:59,520 --> 01:17:02,719
that you're modifying that you're adding

01:17:01,040 --> 01:17:05,920
the column on

01:17:02,719 --> 01:17:07,120
uh was tacked on like the framework of

01:17:05,920 --> 01:17:08,640
the other one and then the data was

01:17:07,120 --> 01:17:10,080
copied over

01:17:08,640 --> 01:17:11,679
also if you add a new column how do you

01:17:10,080 --> 01:17:13,679
see the data if we run a functional

01:17:11,679 --> 01:17:15,040
index on that information how to make

01:17:13,679 --> 01:17:16,000
that information in there probably have

01:17:15,040 --> 01:17:18,400
to write a

01:17:16,000 --> 01:17:19,679
quick and dirty to do that if we use a

01:17:18,400 --> 01:17:21,600
generated column

01:17:19,679 --> 01:17:22,880
um this is the type of data that we can

01:17:21,600 --> 01:17:25,280
extract and

01:17:22,880 --> 01:17:26,560
make some computation on put in there

01:17:25,280 --> 01:17:27,520
would it be better if we had a stub

01:17:26,560 --> 01:17:30,800
table write something

01:17:27,520 --> 01:17:33,679
in in json to get rid of extra

01:17:30,800 --> 01:17:35,440
index and table dives also how much of

01:17:33,679 --> 01:17:37,360
your code you need to change to support

01:17:35,440 --> 01:17:41,120
that and other considerations

01:17:37,360 --> 01:17:44,239
this is why dbas tear off their hair

01:17:41,120 --> 01:17:46,560
oh we just want to add this to that and

01:17:44,239 --> 01:17:47,840
can you change this at the same time

01:17:46,560 --> 01:17:51,120
these type of changes can be very

01:17:47,840 --> 01:17:51,120
expensive and very messy

01:17:51,440 --> 01:17:54,719
so let me start going to wrap-up mode

01:17:53,679 --> 01:17:57,360
here since you've been

01:17:54,719 --> 01:17:58,480
nicely sitting here for a long time uh

01:17:57,360 --> 01:18:01,280
where to look for information the

01:17:58,480 --> 01:18:02,719
definitive guide is the mysql manual

01:18:01,280 --> 01:18:04,320
i believe it's chapter eight it talks

01:18:02,719 --> 01:18:06,320
about query optimization that's

01:18:04,320 --> 01:18:08,280
worth a good read i also like to point

01:18:06,320 --> 01:18:11,199
you to two resources

01:18:08,280 --> 01:18:12,719
forms.mysql.com which has nothing like

01:18:11,199 --> 01:18:14,960
34 subgroups

01:18:12,719 --> 01:18:16,560
especially one on performance there's

01:18:14,960 --> 01:18:20,000
groups for newbies

01:18:16,560 --> 01:18:21,360
jobs certification uh they're going to

01:18:20,000 --> 01:18:24,480
be storage engine

01:18:21,360 --> 01:18:25,440
various interfaces for python php and

01:18:24,480 --> 01:18:28,880
all that

01:18:25,440 --> 01:18:29,760
also mysql community.slack our engineers

01:18:28,880 --> 01:18:32,000
really

01:18:29,760 --> 01:18:33,040
monitor that heavily so if you have a

01:18:32,000 --> 01:18:35,600
question

01:18:33,040 --> 01:18:38,880
forums is a good shot but i think these

01:18:35,600 --> 01:18:40,560
days the slack is a little bit better

01:18:38,880 --> 01:18:42,719
if you're running masculine you need

01:18:40,560 --> 01:18:45,520
this book jesper wisborg crow

01:18:42,719 --> 01:18:47,600
a former colleague of mine uh his other

01:18:45,520 --> 01:18:49,760
books are outstanding

01:18:47,600 --> 01:18:50,800
uh this book weighs about seven and a

01:18:49,760 --> 01:18:54,080
half pounds

01:18:50,800 --> 01:18:55,840
it's probably 500 pages i'm on my

01:18:54,080 --> 01:18:57,360
third reading through it and i'm finding

01:18:55,840 --> 01:19:00,960
new stuff all the time

01:18:57,360 --> 01:19:04,560
it is a great book for query tuning

01:19:00,960 --> 01:19:06,480
especially based around mysql 8.

01:19:04,560 --> 01:19:08,080
another book especially if you can find

01:19:06,480 --> 01:19:10,480
the third edition not the first

01:19:08,080 --> 01:19:11,679
or second this is getting a little bit

01:19:10,480 --> 01:19:15,280
long in the tooth

01:19:11,679 --> 01:19:16,560
but it does explain explain very well

01:19:15,280 --> 01:19:18,320
unfortunately i don't think there's

01:19:16,560 --> 01:19:21,440
going to be a fourth edition

01:19:18,320 --> 01:19:22,000
a very very good book you usually find

01:19:21,440 --> 01:19:25,360
this in a

01:19:22,000 --> 01:19:27,280
used bookstore uh a lot of dbas

01:19:25,360 --> 01:19:28,880
uh who've had a copy of this you'll find

01:19:27,280 --> 01:19:30,320
notes you'll find post-it notes you'll

01:19:28,880 --> 01:19:32,640
find uh

01:19:30,320 --> 01:19:34,719
uh other stuff in there there it's a

01:19:32,640 --> 01:19:35,840
great book

01:19:34,719 --> 01:19:38,080
by the way if you're working with the

01:19:35,840 --> 01:19:39,600
json data type the second version of my

01:19:38,080 --> 01:19:41,040
book

01:19:39,600 --> 01:19:42,640
of moscow and json a practical

01:19:41,040 --> 01:19:44,239
programming guide has just come out in

01:19:42,640 --> 01:19:46,159
the past 10 days

01:19:44,239 --> 01:19:48,400
the original book was 108 pages this

01:19:46,159 --> 01:19:50,000
one's 247 pages

01:19:48,400 --> 01:19:52,239
there's a lot of changes in two years

01:19:50,000 --> 01:19:54,239
with jason and mysql

01:19:52,239 --> 01:19:56,560
a lot of programming examples if you

01:19:54,239 --> 01:19:58,800
look at the

01:19:56,560 --> 01:20:00,560
manual pages on the json functions and

01:19:58,800 --> 01:20:02,159
all that they're a reference guide

01:20:00,560 --> 01:20:05,280
they're not a teaching tool i

01:20:02,159 --> 01:20:06,639
wrote a lot of example code so that you

01:20:05,280 --> 01:20:09,280
can see what goes on there are

01:20:06,639 --> 01:20:11,120
illustrations so you can see what

01:20:09,280 --> 01:20:12,480
the commands look like when you run them

01:20:11,120 --> 01:20:13,360
that's a lot of information on best

01:20:12,480 --> 01:20:16,320
practices

01:20:13,360 --> 01:20:17,520
so if you're using the json data type or

01:20:16,320 --> 01:20:20,320
want to get started with the

01:20:17,520 --> 01:20:21,360
nosql json document store with mysql

01:20:20,320 --> 01:20:25,040
this is a

01:20:21,360 --> 01:20:26,639
handy resource and i hope you'll buy a

01:20:25,040 --> 01:20:28,560
copy

01:20:26,639 --> 01:20:31,040
by the way if you work for a startup

01:20:28,560 --> 01:20:33,760
oracle would like to help you

01:20:31,040 --> 01:20:34,239
you can enroll at oracle.com startup uh

01:20:33,760 --> 01:20:37,040
what it

01:20:34,239 --> 01:20:37,520
gets you well it gets you a big discount

01:20:37,040 --> 01:20:40,719
on

01:20:37,520 --> 01:20:41,600
uh on getting into the the cloud lots of

01:20:40,719 --> 01:20:43,600
discounts

01:20:41,600 --> 01:20:45,600
a global exposure with marketing we'll

01:20:43,600 --> 01:20:48,639
do a lot of promotion for you

01:20:45,600 --> 01:20:52,159
and it's a very exciting program

01:20:48,639 --> 01:20:54,400
and if you are startup and

01:20:52,159 --> 01:20:56,800
are looking to to build quickly this is

01:20:54,400 --> 01:21:00,000
a great way to do it

01:20:56,800 --> 01:21:02,560
and with that i want to thank you if

01:21:00,000 --> 01:21:03,920
you uh want to get a hold of me uh we're

01:21:02,560 --> 01:21:05,520
going to have a q a session

01:21:03,920 --> 01:21:07,760
i'm willing to answer questions as long

01:21:05,520 --> 01:21:10,600
as people around on twitter i'm at

01:21:07,760 --> 01:21:12,320
stoker i have a blog at

01:21:10,600 --> 01:21:15,120
elephantdolphin.blogspot.com

01:21:12,320 --> 01:21:16,480
um planet.mysql is a moscow blog

01:21:15,120 --> 01:21:18,320
aggregation

01:21:16,480 --> 01:21:20,000
point as i mentioned before the forums

01:21:18,320 --> 01:21:22,080
and the community slash

01:21:20,000 --> 01:21:23,280
and the slides for this presentation are

01:21:22,080 --> 01:21:27,040
slideshow

01:21:23,280 --> 01:21:30,320
dave stokes um let me go back

01:21:27,040 --> 01:21:33,920
to um

01:21:30,320 --> 01:21:36,480
q a uh let me go back to

01:21:33,920 --> 01:21:38,080
sheila question what would i consider a

01:21:36,480 --> 01:21:42,800
good primer

01:21:38,080 --> 01:21:46,239
um let's see if i can

01:21:42,800 --> 01:21:49,280
uh let me do that um

01:21:46,239 --> 01:21:51,679
basically any mysql book that's under

01:21:49,280 --> 01:21:53,840
about seven years old i'd recommend

01:21:51,679 --> 01:21:56,639
i if you have a good used bookstore in

01:21:53,840 --> 01:21:58,400
your area i recommend that

01:21:56,639 --> 01:22:01,040
the other great thing about mysql it is

01:21:58,400 --> 01:22:02,719
very very well documented online

01:22:01,040 --> 01:22:04,800
so you can go out there and find all

01:22:02,719 --> 01:22:07,600
sorts of resources

01:22:04,800 --> 01:22:08,960
my my favorite guide the guy that really

01:22:07,600 --> 01:22:10,960
honed my

01:22:08,960 --> 01:22:13,040
professional teeth with mysql was the

01:22:10,960 --> 01:22:15,679
old 5.0 certification guide that's

01:22:13,040 --> 01:22:16,639
a great guide paul dubois has a book on

01:22:15,679 --> 01:22:19,840
mysql

01:22:16,639 --> 01:22:21,920
that is another eight page or 800 pager

01:22:19,840 --> 01:22:23,600
that's great

01:22:21,920 --> 01:22:25,600
okay let's go on to uh william's

01:22:23,600 --> 01:22:27,760
question again and i'll get to rose

01:22:25,600 --> 01:22:29,920
um do secondary indexes usable primary

01:22:27,760 --> 01:22:33,040
index and the secondary index

01:22:29,920 --> 01:22:36,400
um if the index you consider having the

01:22:33,040 --> 01:22:38,719
um the value that you want indexed uh so

01:22:36,400 --> 01:22:40,480
like my zip code 76247

01:22:38,719 --> 01:22:42,639
and then we'll have a pointer to where

01:22:40,480 --> 01:22:45,120
in the table space where the data is

01:22:42,639 --> 01:22:45,840
the secondary index uh points the

01:22:45,120 --> 01:22:47,440
primary

01:22:45,840 --> 01:22:49,360
and the primary goes right to the data

01:22:47,440 --> 01:22:52,159
block um

01:22:49,360 --> 01:22:53,440
that's the best way i can describe that

01:22:52,159 --> 01:22:55,440
do i have recommendations for

01:22:53,440 --> 01:22:57,360
understanding why indexes are chosen or

01:22:55,440 --> 01:23:00,159
don't show up as possible index in five

01:22:57,360 --> 01:23:01,280
six uh once again admonition five six

01:23:00,159 --> 01:23:04,560
ends of life

01:23:01,280 --> 01:23:07,520
in five months by the way

01:23:04,560 --> 01:23:08,960
i don't know what aws google or anyone

01:23:07,520 --> 01:23:12,080
else is doing

01:23:08,960 --> 01:23:14,239
for that occurrence but

01:23:12,080 --> 01:23:15,679
uh by the way the mysql cloud out there

01:23:14,239 --> 01:23:17,040
is running 8-0

01:23:15,679 --> 01:23:18,639
and you do get the full enterprise

01:23:17,040 --> 01:23:20,239
edition so you get the great backup tool

01:23:18,639 --> 01:23:23,600
the great monitoring tool

01:23:20,239 --> 01:23:25,840
okay why indexes aren't chosen um

01:23:23,600 --> 01:23:27,360
usually the most common reason is that

01:23:25,840 --> 01:23:29,040
it has a choice of two

01:23:27,360 --> 01:23:32,800
indexes that's going to try to grab the

01:23:29,040 --> 01:23:32,800
smaller kind of wants to grab the most

01:23:32,840 --> 01:23:39,040
selective

01:23:34,000 --> 01:23:39,040
it's um um

01:23:40,719 --> 01:23:43,920
let me type in we could be looking at

01:23:42,639 --> 01:23:47,280
the smaller

01:23:43,920 --> 01:23:50,239
of the two options

01:23:47,280 --> 01:23:52,560
and of course see my my typing is not

01:23:50,239 --> 01:23:52,560
always

01:23:54,320 --> 01:24:00,800
um the the other thing is

01:23:57,600 --> 01:24:04,960
the optimizer is not perfect uh

01:24:00,800 --> 01:24:07,280
you should need to run analyze

01:24:04,960 --> 01:24:07,280
table

01:24:08,800 --> 01:24:20,000
to update the statistics

01:24:17,040 --> 01:24:20,000
for the optimizer

01:24:23,040 --> 01:24:27,760
so there's a lot of

01:24:28,239 --> 01:24:32,960
stuff that go there um

01:24:33,120 --> 01:24:35,520
got me

01:24:37,280 --> 01:24:41,760
whoops get out here let me stop the

01:24:39,920 --> 01:24:45,120
share

01:24:41,760 --> 01:24:46,960
and there i um

01:24:45,120 --> 01:24:48,239
boy 49 of you stood through the the

01:24:46,960 --> 01:24:51,920
entire thing i want to

01:24:48,239 --> 01:24:51,920
thank you for that um

01:24:52,639 --> 01:24:58,320
um let's see from michael aker i'm going

01:24:56,000 --> 01:25:02,800
to start blaming everything on gdpr

01:24:58,320 --> 01:25:02,800
join the europeans early and often um

01:25:03,120 --> 01:25:06,560
from alan mason thanks as always for the

01:25:05,040 --> 01:25:07,920
great talk thank you alan say hi to

01:25:06,560 --> 01:25:09,120
carmen for me

01:25:07,920 --> 01:25:10,480
by the way if you don't know them make

01:25:09,120 --> 01:25:11,199
sure you meet them next year when we're

01:25:10,480 --> 01:25:12,880
all live

01:25:11,199 --> 01:25:14,320
they are great folks and they're both

01:25:12,880 --> 01:25:16,080
dbas

01:25:14,320 --> 01:25:18,719
can i show us the reference links last

01:25:16,080 --> 01:25:22,800
slide um

01:25:18,719 --> 01:25:25,760
i think i can let me do that

01:25:22,800 --> 01:25:26,960
um already down slides download slides

01:25:25,760 --> 01:25:28,320
this is the information information

01:25:26,960 --> 01:25:31,440
thanks a william

01:25:28,320 --> 01:25:35,760
uh from jake galligan thank you

01:25:31,440 --> 01:25:35,760
okay let me go back to the last slide

01:25:38,840 --> 01:25:41,840
and

01:25:42,159 --> 01:25:44,880
there we go

01:25:46,239 --> 01:25:50,159
and let me take this out of

01:25:50,960 --> 01:25:55,840
full screen mode so i can see other

01:25:52,840 --> 01:25:55,840
questions

01:25:57,280 --> 01:26:00,719
it's not going to do that

01:26:03,440 --> 01:26:06,960
well i'll keep this up for another few

01:26:05,280 --> 01:26:10,800
seconds and i'll go back to

01:26:06,960 --> 01:26:10,800
looking at the q a and the comments

01:26:17,280 --> 01:26:25,600
okay uh when can we access the recording

01:26:20,840 --> 01:26:27,360
um i'm sure the wonderful organizers

01:26:25,600 --> 01:26:29,040
of all things open will have them online

01:26:27,360 --> 01:26:30,880
i actually recorded pre-recorded a

01:26:29,040 --> 01:26:32,320
version of this so i don't know which

01:26:30,880 --> 01:26:33,920
they're going to record

01:26:32,320 --> 01:26:35,440
hopefully they won't inflict both on the

01:26:33,920 --> 01:26:36,880
world

01:26:35,440 --> 01:26:38,800
i'm sure they'll have them up there

01:26:36,880 --> 01:26:42,320
shortly as soon as we can

01:26:38,800 --> 01:26:45,520
um pod jennifer and the crew

01:26:42,320 --> 01:26:47,280
do an amazing job and um

01:26:45,520 --> 01:26:49,679
this show has grown from a few hundred

01:26:47,280 --> 01:26:53,040
people to a few thousand people

01:26:49,679 --> 01:26:54,880
uh rather quickly and uh

01:26:53,040 --> 01:26:56,159
it's a great event and they're they're

01:26:54,880 --> 01:26:57,120
so thorough i'm sure they probably

01:26:56,159 --> 01:26:58,400
already have up there and i'm

01:26:57,120 --> 01:27:00,960
dummy media doesn't know where they have

01:26:58,400 --> 01:27:02,080
them oh there's a thing at is recording

01:27:00,960 --> 01:27:04,320
this talk and we're bringing links for

01:27:02,080 --> 01:27:06,960
access uh thank you jennifer

01:27:04,320 --> 01:27:07,840
uh someone alexis smith wrote downloaded

01:27:06,960 --> 01:27:09,440
the books from

01:27:07,840 --> 01:27:12,159
my company's blue university and plan to

01:27:09,440 --> 01:27:15,440
begin reading soon

01:27:12,159 --> 01:27:15,440
bless you there for doing that

01:27:15,760 --> 01:27:20,159
without anything else um i want to thank

01:27:18,880 --> 01:27:22,000
you for attending

01:27:20,159 --> 01:27:23,600
lots of other good chats out there on

01:27:22,000 --> 01:27:25,600
databases

01:27:23,600 --> 01:27:27,600
if you've never gone to a real

01:27:25,600 --> 01:27:29,199
conference this is a real conversation

01:27:27,600 --> 01:27:31,360
say that if you've never gone to a

01:27:29,199 --> 01:27:33,120
conference in person

01:27:31,360 --> 01:27:35,040
i usually recommend and i do recommend

01:27:33,120 --> 01:27:37,280
for virtual conferences

01:27:35,040 --> 01:27:40,159
if you have an opening in your schedule

01:27:37,280 --> 01:27:43,280
and there is a talk that on the subject

01:27:40,159 --> 01:27:45,360
you know absolutely nothing about

01:27:43,280 --> 01:27:46,400
that invest 30 minutes of your time and

01:27:45,360 --> 01:27:48,400
go listen

01:27:46,400 --> 01:27:50,080
uh it might expand your horizons you

01:27:48,400 --> 01:27:51,040
might find that little nugget in the

01:27:50,080 --> 01:27:53,120
bottom of the stream

01:27:51,040 --> 01:27:54,159
that ends up being your your future

01:27:53,120 --> 01:27:56,239
fortune

01:27:54,159 --> 01:27:58,159
or it just might be something you say

01:27:56,239 --> 01:28:00,080
gee i now know all about subject x that

01:27:58,159 --> 01:28:02,159
i ever wanted to do

01:28:00,080 --> 01:28:04,880
and with that i'd like to thank the

01:28:02,159 --> 01:28:06,719
wonderful organizers of all things open

01:28:04,880 --> 01:28:08,639
uh don't forget there are other shows

01:28:06,719 --> 01:28:11,679
open source 101 hopefully we'll

01:28:08,639 --> 01:28:14,080
see you in austin next april at austin's

01:28:11,679 --> 01:28:15,600
one of my favorite cities and with that

01:28:14,080 --> 01:28:17,920
um

01:28:15,600 --> 01:28:19,280
you can uh pay me later oops one more on

01:28:17,920 --> 01:28:21,040
the q a

01:28:19,280 --> 01:28:22,960
does my school calculate histograms on

01:28:21,040 --> 01:28:26,639
index columns uh usually you

01:28:22,960 --> 01:28:29,120
index or you histogram you don't do both

01:28:26,639 --> 01:28:30,320
um you probably could do an index on

01:28:29,120 --> 01:28:31,040
histogram but that would be kind of

01:28:30,320 --> 01:28:34,000
redundant

01:28:31,040 --> 01:28:34,719
and uh as soon as the index data starts

01:28:34,000 --> 01:28:37,440
changing

01:28:34,719 --> 01:28:38,719
uh the histogram comes out of date why

01:28:37,440 --> 01:28:40,320
would you care about histograms on

01:28:38,719 --> 01:28:42,080
non-indexed columns

01:28:40,320 --> 01:28:44,239
well maybe you have data doesn't change

01:28:42,080 --> 01:28:47,600
too often uh shipping rates

01:28:44,239 --> 01:28:49,040
uh actuarial rates if you're uh into

01:28:47,600 --> 01:28:51,280
insurance

01:28:49,040 --> 01:28:52,560
um maybe it's a piece of information

01:28:51,280 --> 01:28:54,719
hasn't changed too often the united

01:28:52,560 --> 01:28:55,679
states has not added another state in my

01:28:54,719 --> 01:28:58,880
lifetime

01:28:55,679 --> 01:29:00,159
so if i had a table with

01:28:58,880 --> 01:29:04,000
state codes in there it might be better

01:29:00,159 --> 01:29:05,840
to histogram rather than than index

01:29:04,000 --> 01:29:07,360
and in cases where there's a full scan

01:29:05,840 --> 01:29:10,080
yeah you kind of get a wash but at least

01:29:07,360 --> 01:29:13,280
the optimizer is a better idea

01:29:10,080 --> 01:29:13,280
downloading the slides

01:29:13,440 --> 01:29:16,800
you'll see that either in the recording

01:29:14,719 --> 01:29:19,440
presentation or

01:29:16,800 --> 01:29:20,400
you go to slideshare.net slash dave

01:29:19,440 --> 01:29:23,600
d-a-v-e

01:29:20,400 --> 01:29:24,560
stokes s-t-o-k-e-s and with that i'm

01:29:23,600 --> 01:29:27,840
going to wrap this up

01:29:24,560 --> 01:29:30,000
thank you all for uh for coming

01:29:27,840 --> 01:29:37,440
and have a great day and enjoy the rest

01:29:30,000 --> 01:29:37,440

YouTube URL: https://www.youtube.com/watch?v=zhg1b8IKWzw


