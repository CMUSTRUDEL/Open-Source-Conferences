Title: Fight Complexity with Functional Programming - Gopal S. Akshintala
Publication date: 2020-12-17
Playlist: All Things Open 2020 - Programming Languages Track
Description: 
	Presented by: Gopal S. Akshintala, Microsoft
Presented at All Things Open 2020 - Programming Languages Track

Abstract: A Metric-driven approach to reduce Cognitive Complexity in a code base, using Functional Programming, demoed **hands-on**, by solving a complex real-world ubiquitous design challenge - REST API Bulk Request Validation, with an extensible Framework that separates what-to-do (Validations) from how-to-do (Validation Orchestration). Let's do a case study of a successful implementation done by our team in the world's largest SaaS org, _Salesforce_, through our in-house baked FOSS library **Vader**.
Captions: 
	00:00:05,120 --> 00:00:07,759
hey thank you

00:00:06,080 --> 00:00:10,880
and thanks ito for this great

00:00:07,759 --> 00:00:13,440
opportunity and i am uh

00:00:10,880 --> 00:00:15,200
speaking live from india and it's 9 p.m

00:00:13,440 --> 00:00:16,080
here it's an awesome time to give a tech

00:00:15,200 --> 00:00:18,080
talk

00:00:16,080 --> 00:00:20,240
and welcome to my talk it's fight

00:00:18,080 --> 00:00:24,160
complexity with functional programming

00:00:20,240 --> 00:00:26,400
and i'm gopal i work for microsoft and

00:00:24,160 --> 00:00:28,480
this is my twitter handle and my website

00:00:26,400 --> 00:00:30,480
where i kind of blog about functional

00:00:28,480 --> 00:00:32,800
programming and other things

00:00:30,480 --> 00:00:34,559
so without further ado let's begin our

00:00:32,800 --> 00:00:36,719
talk with a

00:00:34,559 --> 00:00:39,360
piece of line that i keep hearing from

00:00:36,719 --> 00:00:41,120
managers especially because uh

00:00:39,360 --> 00:00:43,200
i see a lot of resistance towards

00:00:41,120 --> 00:00:45,600
functional programming these days uh

00:00:43,200 --> 00:00:47,120
i mean at least because of not awareness

00:00:45,600 --> 00:00:49,280
towards functional programming

00:00:47,120 --> 00:00:51,120
and i keep hearing this saying that fp

00:00:49,280 --> 00:00:52,399
is cool because it's complex enough to

00:00:51,120 --> 00:00:53,600
make doves feel like they're doing

00:00:52,399 --> 00:00:56,160
something smart

00:00:53,600 --> 00:00:58,000
but today we're gonna see that fe is not

00:00:56,160 --> 00:01:01,039
actually complex but that instead

00:00:58,000 --> 00:01:02,559
it fights complexity and we're gonna see

00:01:01,039 --> 00:01:05,040
how that is gonna

00:01:02,559 --> 00:01:06,240
we're gonna achieve that by the way uh i

00:01:05,040 --> 00:01:08,080
hope i can uh

00:01:06,240 --> 00:01:10,320
you kind of interrupt me for if i have

00:01:08,080 --> 00:01:11,760
any qns in between the talk

00:01:10,320 --> 00:01:13,439
and i hope the host is going to

00:01:11,760 --> 00:01:16,400
interrupt me uh if

00:01:13,439 --> 00:01:17,119
if you want that to be clarified on the

00:01:16,400 --> 00:01:19,280
run

00:01:17,119 --> 00:01:20,799
and by the way this talk is probably

00:01:19,280 --> 00:01:22,320
totally based on a true story that

00:01:20,799 --> 00:01:24,880
happened within our team

00:01:22,320 --> 00:01:27,759
where and how we kind of brainstormed

00:01:24,880 --> 00:01:30,000
ourselves and how we kind of

00:01:27,759 --> 00:01:31,920
pushed fv and what is the use case and

00:01:30,000 --> 00:01:34,320
i'm going to establish all those

00:01:31,920 --> 00:01:36,240
design discussions that we have done and

00:01:34,320 --> 00:01:39,439
how fp is a better suit

00:01:36,240 --> 00:01:41,040
for a certain problem and let's start

00:01:39,439 --> 00:01:43,040
with our talk with something very

00:01:41,040 --> 00:01:44,000
serious that the the holy watch that we

00:01:43,040 --> 00:01:46,399
keep having

00:01:44,000 --> 00:01:48,479
on our day-to-day basis so the first one

00:01:46,399 --> 00:01:49,040
in my list is ide light versus dark

00:01:48,479 --> 00:01:51,600
theme

00:01:49,040 --> 00:01:53,360
so i see this war quite predominantly

00:01:51,600 --> 00:01:54,000
especially these days when the dark

00:01:53,360 --> 00:01:56,880
themes

00:01:54,000 --> 00:01:58,000
are on the rise and i was i used to like

00:01:56,880 --> 00:02:00,719
like themes but then

00:01:58,000 --> 00:02:03,200
not until i bought my 32-inch monitor i

00:02:00,719 --> 00:02:05,759
understood the value of dark themes

00:02:03,200 --> 00:02:07,920
and eclipses intellij this is pretty

00:02:05,759 --> 00:02:08,800
predominant on our floor people keep who

00:02:07,920 --> 00:02:11,360
use intellij

00:02:08,800 --> 00:02:12,959
feel that like that's ultimate id and

00:02:11,360 --> 00:02:14,959
any other id doesn't matter

00:02:12,959 --> 00:02:17,120
and vice versa with people who use

00:02:14,959 --> 00:02:17,599
eclipse so why am i talking about all

00:02:17,120 --> 00:02:20,160
this

00:02:17,599 --> 00:02:21,280
what about this oops versus fp have you

00:02:20,160 --> 00:02:23,599
ever had this

00:02:21,280 --> 00:02:25,520
war in your team where people say hey

00:02:23,599 --> 00:02:26,319
oops it's better than fp or fp is better

00:02:25,520 --> 00:02:29,200
than oops

00:02:26,319 --> 00:02:30,160
i had this i we had this fight and i had

00:02:29,200 --> 00:02:32,640
these doubts

00:02:30,160 --> 00:02:34,879
especially during my initial days of the

00:02:32,640 --> 00:02:39,040
carrier while i was trying to understand

00:02:34,879 --> 00:02:41,840
what is fb yep

00:02:39,040 --> 00:02:43,280
cool uh so what is fp and what is oops

00:02:41,840 --> 00:02:45,920
and which one is better than

00:02:43,280 --> 00:02:47,200
what so i kind of searched everywhere i

00:02:45,920 --> 00:02:50,319
kind of uh

00:02:47,200 --> 00:02:52,000
read all the books etc and then

00:02:50,319 --> 00:02:54,000
towards the end i could understand that

00:02:52,000 --> 00:02:54,640
there really is no verses in between

00:02:54,000 --> 00:02:56,400
them

00:02:54,640 --> 00:02:58,319
it's not like one is greater than the

00:02:56,400 --> 00:03:01,040
other i can't really think of

00:02:58,319 --> 00:03:02,959
how you can cannot have both these

00:03:01,040 --> 00:03:05,920
paradigms within an application

00:03:02,959 --> 00:03:07,120
and i cannot even imagine how we can't

00:03:05,920 --> 00:03:09,120
have both of them

00:03:07,120 --> 00:03:10,400
so let's try to understand what is oops

00:03:09,120 --> 00:03:13,760
and what is fp

00:03:10,400 --> 00:03:15,200
so oops can be put into this solid

00:03:13,760 --> 00:03:16,640
principle that uncle bob has

00:03:15,200 --> 00:03:19,120
predominantly you know

00:03:16,640 --> 00:03:20,959
said the solid principles and then fp

00:03:19,120 --> 00:03:22,080
talks about immutability differential

00:03:20,959 --> 00:03:24,720
transparency

00:03:22,080 --> 00:03:26,799
side effects etc so i don't see any

00:03:24,720 --> 00:03:27,120
exclusivity between these principles and

00:03:26,799 --> 00:03:29,280
i

00:03:27,120 --> 00:03:30,400
i totally agree that this both can be

00:03:29,280 --> 00:03:32,400
used together

00:03:30,400 --> 00:03:33,920
so that's it unfortunately we can't talk

00:03:32,400 --> 00:03:35,760
about all these principles that kind of

00:03:33,920 --> 00:03:38,080
lot of blog posts books and etc

00:03:35,760 --> 00:03:40,239
do that you can go and refer today we're

00:03:38,080 --> 00:03:42,560
gonna see the application uh we can

00:03:40,239 --> 00:03:44,959
gonna take few of these and see how we

00:03:42,560 --> 00:03:46,720
can apply them in a real world example

00:03:44,959 --> 00:03:48,640
and i'm also going to prove we're going

00:03:46,720 --> 00:03:50,400
to tackle an object-oriented paradigm

00:03:48,640 --> 00:03:52,480
with a functional touch so just to prove

00:03:50,400 --> 00:03:54,560
that there is no difference between them

00:03:52,480 --> 00:03:56,319
and i'm going to show a lot of code but

00:03:54,560 --> 00:03:57,120
please don't worry at all just sit back

00:03:56,319 --> 00:03:59,040
and relax

00:03:57,120 --> 00:04:00,640
i'm going to share all the code links

00:03:59,040 --> 00:04:03,040
and the slide deck etc

00:04:00,640 --> 00:04:03,840
so just don't try to read code andhra i

00:04:03,040 --> 00:04:07,360
know it's very

00:04:03,840 --> 00:04:07,840
difficult so i just gonna you just can

00:04:07,360 --> 00:04:10,159
skim

00:04:07,840 --> 00:04:11,840
through the concepts that i kind of talk

00:04:10,159 --> 00:04:12,400
through and i'm gonna use kotlin for

00:04:11,840 --> 00:04:14,159
today

00:04:12,400 --> 00:04:15,760
and kotlin is an awesome language i'm a

00:04:14,159 --> 00:04:17,600
great fan of kotlin being a java

00:04:15,760 --> 00:04:19,919
developer starting as a java developer

00:04:17,600 --> 00:04:21,199
kotlin proved to be an awesome awesome

00:04:19,919 --> 00:04:23,440
uh

00:04:21,199 --> 00:04:25,680
language and i'm going to use another

00:04:23,440 --> 00:04:27,440
awesome library called arrow

00:04:25,680 --> 00:04:29,199
for demonstrating some of the functional

00:04:27,440 --> 00:04:31,840
paradigms and this

00:04:29,199 --> 00:04:32,880
is put through it has been worked by

00:04:31,840 --> 00:04:34,960
those smart people

00:04:32,880 --> 00:04:36,080
and a lot of hard work is put into that

00:04:34,960 --> 00:04:39,040
so let's

00:04:36,080 --> 00:04:40,160
jump in there is another war that we

00:04:39,040 --> 00:04:42,479
didn't touch up which was

00:04:40,160 --> 00:04:44,800
imperative was declarative and this is

00:04:42,479 --> 00:04:46,800
pretty predominant at least recently

00:04:44,800 --> 00:04:47,840
in these chatland developers who was a

00:04:46,800 --> 00:04:49,840
jordan developer

00:04:47,840 --> 00:04:52,080
uh somebody like me who has started with

00:04:49,840 --> 00:04:53,360
java and then moved to kotlin

00:04:52,080 --> 00:04:56,000
so i would call him a chocolate

00:04:53,360 --> 00:04:58,000
developer why am i taking kotlin because

00:04:56,000 --> 00:05:00,000
scotland uh is one of the modern

00:04:58,000 --> 00:05:01,120
languages which has a lot of emphasis on

00:05:00,000 --> 00:05:03,039
functional programming

00:05:01,120 --> 00:05:04,160
there is a lot of functional tool set

00:05:03,039 --> 00:05:05,919
that is first class

00:05:04,160 --> 00:05:07,199
within the language and a lot of

00:05:05,919 --> 00:05:09,440
operations that come in which we're

00:05:07,199 --> 00:05:12,080
gonna see towards the end

00:05:09,440 --> 00:05:12,800
so so if somebody like this was started

00:05:12,080 --> 00:05:14,720
in java

00:05:12,800 --> 00:05:15,840
where imperative is predominant not

00:05:14,720 --> 00:05:17,759
until java 8 where

00:05:15,840 --> 00:05:19,199
lambdas and streams are there and even

00:05:17,759 --> 00:05:21,199
after the introduction of them

00:05:19,199 --> 00:05:23,440
they're not in the mainstream i still

00:05:21,199 --> 00:05:24,400
see people using java 8 but not using

00:05:23,440 --> 00:05:25,919
those

00:05:24,400 --> 00:05:28,639
declarative tools that they have

00:05:25,919 --> 00:05:30,320
provided that they're putting in

00:05:28,639 --> 00:05:31,680
so let's try to understand the

00:05:30,320 --> 00:05:32,560
difference in these styles with an

00:05:31,680 --> 00:05:35,039
example

00:05:32,560 --> 00:05:36,479
so for me imperative style is like this

00:05:35,039 --> 00:05:39,120
the metaphor i use is

00:05:36,479 --> 00:05:40,639
like imagine you have puzzles pieces and

00:05:39,120 --> 00:05:41,840
you have an instruction set to fit those

00:05:40,639 --> 00:05:45,039
pieces together

00:05:41,840 --> 00:05:46,960
and you hand it to the computer

00:05:45,039 --> 00:05:48,720
uh differently separately like you have

00:05:46,960 --> 00:05:50,160
these instructions that separately

00:05:48,720 --> 00:05:51,840
and the puzzle pieces separately and

00:05:50,160 --> 00:05:53,360
then computer is going to read your

00:05:51,840 --> 00:05:54,080
instruction set fit all those puzzle

00:05:53,360 --> 00:05:55,600
pieces

00:05:54,080 --> 00:05:58,160
and run your code which is like the byte

00:05:55,600 --> 00:06:00,000
code for a computer it doesn't really

00:05:58,160 --> 00:06:00,720
matter for a programmer who is reading

00:06:00,000 --> 00:06:02,960
your code

00:06:00,720 --> 00:06:04,240
he really has to make a mental model

00:06:02,960 --> 00:06:05,759
while he is reading your code to

00:06:04,240 --> 00:06:07,680
understand what's going on

00:06:05,759 --> 00:06:09,280
let's see that with an actual code

00:06:07,680 --> 00:06:11,520
example so

00:06:09,280 --> 00:06:13,360
we're all isolated so we kind of can use

00:06:11,520 --> 00:06:14,960
some team building activity here

00:06:13,360 --> 00:06:16,800
so the team willing activity that i'm

00:06:14,960 --> 00:06:18,560
gonna propose is

00:06:16,800 --> 00:06:20,560
just concatenate take all the last names

00:06:18,560 --> 00:06:22,160
of your teammates concatenate them with

00:06:20,560 --> 00:06:24,080
a delimiter so i'm looking at

00:06:22,160 --> 00:06:26,960
for a string something like this which

00:06:24,080 --> 00:06:29,680
would have this as a delimiter

00:06:26,960 --> 00:06:31,120
so okay given this problem to a

00:06:29,680 --> 00:06:33,199
imperative programmer

00:06:31,120 --> 00:06:34,960
so he would imagine he's a junior

00:06:33,199 --> 00:06:36,240
developer so he would start out his

00:06:34,960 --> 00:06:37,680
implementation like this

00:06:36,240 --> 00:06:39,600
wherein he is kind of looking through

00:06:37,680 --> 00:06:40,960
all the teammates and extracting the

00:06:39,600 --> 00:06:43,440
last name based on

00:06:40,960 --> 00:06:45,039
a space character a last base character

00:06:43,440 --> 00:06:47,919
and then he's concatenating them

00:06:45,039 --> 00:06:49,919
okay he gives that for a code review and

00:06:47,919 --> 00:06:50,400
the senior developer kind of screams on

00:06:49,919 --> 00:06:54,400
him

00:06:50,400 --> 00:06:56,400
man where are all the edge cases right

00:06:54,400 --> 00:06:58,720
he's missing on out on a lot of edge

00:06:56,400 --> 00:07:00,720
cases because we are dealing with

00:06:58,720 --> 00:07:02,080
spaces here and we are doing dealing

00:07:00,720 --> 00:07:04,000
with nulls

00:07:02,080 --> 00:07:05,360
and we are fortunate in kotlin that we

00:07:04,000 --> 00:07:07,360
have nullable types

00:07:05,360 --> 00:07:09,280
uh so that you can explicitly say this

00:07:07,360 --> 00:07:12,479
can be null and this can't be known

00:07:09,280 --> 00:07:15,039
uh but in java we kind of are

00:07:12,479 --> 00:07:15,599
null bit me a lot of times and i had to

00:07:15,039 --> 00:07:18,319
really

00:07:15,599 --> 00:07:21,039
spend you know sleepless fridays because

00:07:18,319 --> 00:07:23,599
i checked in without checking nulls

00:07:21,039 --> 00:07:25,199
so he would go back to his drawing board

00:07:23,599 --> 00:07:26,319
he would think about all the edge cases

00:07:25,199 --> 00:07:27,599
that he is missing

00:07:26,319 --> 00:07:29,599
and then he would come up with an

00:07:27,599 --> 00:07:31,520
approach like this okay

00:07:29,599 --> 00:07:33,039
he would submit his admin start to the

00:07:31,520 --> 00:07:35,919
code review again

00:07:33,039 --> 00:07:36,400
and then now when the code he runs the

00:07:35,919 --> 00:07:39,520
code

00:07:36,400 --> 00:07:42,400
the output looks like this

00:07:39,520 --> 00:07:44,000
so as you can see uh there is a

00:07:42,400 --> 00:07:46,160
telemeter towards the end

00:07:44,000 --> 00:07:47,199
one more a delimiter which he needs to

00:07:46,160 --> 00:07:49,599
take care uh

00:07:47,199 --> 00:07:50,319
it's a simple case right but then he has

00:07:49,599 --> 00:07:52,960
to go

00:07:50,319 --> 00:07:53,680
again he has to make another patch to

00:07:52,960 --> 00:07:56,319
his code

00:07:53,680 --> 00:07:58,560
and come up with a code like this

00:07:56,319 --> 00:08:01,520
wherein he has a

00:07:58,560 --> 00:08:03,280
uh a flag and he has a flag like he's

00:08:01,520 --> 00:08:03,680
first flag and all that again don't kind

00:08:03,280 --> 00:08:05,840
of

00:08:03,680 --> 00:08:07,440
go into the code you can i'll be showing

00:08:05,840 --> 00:08:07,919
you the code links you can go and see

00:08:07,440 --> 00:08:10,560
that

00:08:07,919 --> 00:08:11,199
all i'm trying to kind of convey is he

00:08:10,560 --> 00:08:13,120
has to

00:08:11,199 --> 00:08:14,560
do all this noise and what he's trying

00:08:13,120 --> 00:08:16,720
to do is totally lost

00:08:14,560 --> 00:08:18,160
just like any just like the agile horse

00:08:16,720 --> 00:08:20,240
you see on the right side

00:08:18,160 --> 00:08:22,240
it's like any form of art as you keep

00:08:20,240 --> 00:08:24,080
patching it it kind of loses actual

00:08:22,240 --> 00:08:26,479
meaning what is trying to convey

00:08:24,080 --> 00:08:27,280
and yeah this is how it ends up looking

00:08:26,479 --> 00:08:29,280
like

00:08:27,280 --> 00:08:30,960
imagine the same programmer is born in a

00:08:29,280 --> 00:08:32,080
parallel universe as a declarative

00:08:30,960 --> 00:08:33,519
programmer

00:08:32,080 --> 00:08:35,360
he would start out the code with the

00:08:33,519 --> 00:08:37,120
same given the same requirements

00:08:35,360 --> 00:08:39,200
in this way wherein he would use a

00:08:37,120 --> 00:08:42,320
sequence which is like stream in

00:08:39,200 --> 00:08:44,480
java which is pretty predominant

00:08:42,320 --> 00:08:46,080
uh and he would use something like this

00:08:44,480 --> 00:08:47,519
a map and passes a function

00:08:46,080 --> 00:08:49,760
you're going to touch upon this map and

00:08:47,519 --> 00:08:51,519
platform going forward on bit

00:08:49,760 --> 00:08:53,839
but then just for now understand this is

00:08:51,519 --> 00:08:54,959
a syntax in which you can declaratively

00:08:53,839 --> 00:08:58,240
do the same thing that's

00:08:54,959 --> 00:08:58,640
imperative done on the left side and as

00:08:58,240 --> 00:09:01,440
he

00:08:58,640 --> 00:09:02,800
uh discovers the edge cases he would go

00:09:01,440 --> 00:09:05,440
about writing

00:09:02,800 --> 00:09:06,160
extending his code instead of patching

00:09:05,440 --> 00:09:08,160
his code

00:09:06,160 --> 00:09:10,000
just like this on the right side wherein

00:09:08,160 --> 00:09:10,480
he keeps adding those conditions in

00:09:10,000 --> 00:09:14,000
between

00:09:10,480 --> 00:09:16,720
map filter etc and then

00:09:14,000 --> 00:09:18,080
is a step by step of how he was able to

00:09:16,720 --> 00:09:19,200
convert this imperative code to

00:09:18,080 --> 00:09:21,120
declarative code

00:09:19,200 --> 00:09:22,880
which i'm not going to spend much time

00:09:21,120 --> 00:09:25,360
because of a limited time

00:09:22,880 --> 00:09:26,320
but you can go about an understanding

00:09:25,360 --> 00:09:28,800
and you can always

00:09:26,320 --> 00:09:30,560
message me if you have some doubts so

00:09:28,800 --> 00:09:32,800
this is imperative we have seen it

00:09:30,560 --> 00:09:34,480
and this is declarative so declarative

00:09:32,800 --> 00:09:36,080
is like you already have all those

00:09:34,480 --> 00:09:37,440
pieces fit together and then you're

00:09:36,080 --> 00:09:39,360
giving it to the computer

00:09:37,440 --> 00:09:41,760
and for a programmer who is reading your

00:09:39,360 --> 00:09:43,200
code the picture is already there on the

00:09:41,760 --> 00:09:45,200
canvas of your id and

00:09:43,200 --> 00:09:47,279
you really don't have to spend time to

00:09:45,200 --> 00:09:50,880
you know fit the pieces together

00:09:47,279 --> 00:09:53,519
that said java is like

00:09:50,880 --> 00:09:55,040
the lion king of languages right uh no

00:09:53,519 --> 00:09:56,800
doubt no debate about it it's a

00:09:55,040 --> 00:09:58,560
predominantly used language it kind of

00:09:56,800 --> 00:10:00,399
started when i started going to

00:09:58,560 --> 00:10:01,760
elementary school when i'm four or five

00:10:00,399 --> 00:10:03,600
years of age

00:10:01,760 --> 00:10:05,920
and even now people are using that in

00:10:03,600 --> 00:10:08,959
production and that's not a joke

00:10:05,920 --> 00:10:12,000
uh kotlin kind of just got into this

00:10:08,959 --> 00:10:15,200
uh space recently but then it has

00:10:12,000 --> 00:10:16,000
kind of drawn a lot of ice and one thing

00:10:15,200 --> 00:10:17,680
that

00:10:16,000 --> 00:10:19,839
caught my eye in bottleness they are

00:10:17,680 --> 00:10:21,600
pumping a lot of functional set

00:10:19,839 --> 00:10:23,279
and why is that new programming

00:10:21,600 --> 00:10:24,000
languages are really pumping this

00:10:23,279 --> 00:10:25,760
functional

00:10:24,000 --> 00:10:27,279
sets now and java is actually following

00:10:25,760 --> 00:10:29,600
kotlin and kind of

00:10:27,279 --> 00:10:31,279
adding features like sealed classes etc

00:10:29,600 --> 00:10:34,079
where kotlin already have it

00:10:31,279 --> 00:10:35,760
and even the functional tool set keep on

00:10:34,079 --> 00:10:36,240
increasing this functional tool set in

00:10:35,760 --> 00:10:39,040
java

00:10:36,240 --> 00:10:40,800
and why now let's understand if this

00:10:39,040 --> 00:10:42,160
whatever imperative versus declarative

00:10:40,800 --> 00:10:44,640
is just about style

00:10:42,160 --> 00:10:46,000
or is there more about it so let's try

00:10:44,640 --> 00:10:47,760
to give a wrinkle to a problem

00:10:46,000 --> 00:10:50,000
let's concatenate all these names in

00:10:47,760 --> 00:10:52,240
parallel how can you

00:10:50,000 --> 00:10:53,920
make this run in parallel i mean just

00:10:52,240 --> 00:10:55,600
think about it

00:10:53,920 --> 00:10:57,279
i already have an implementation which

00:10:55,600 --> 00:10:57,680
i'm going to show share in the code

00:10:57,279 --> 00:11:00,160
links

00:10:57,680 --> 00:11:02,160
because i couldn't fit that in a slide

00:11:00,160 --> 00:11:03,839
it is really going to be monstrous if i

00:11:02,160 --> 00:11:04,560
kind of make it in parallel you can kind

00:11:03,839 --> 00:11:06,560
of use

00:11:04,560 --> 00:11:08,640
fork joint pools or co routines or

00:11:06,560 --> 00:11:09,120
whatever but it doesn't really end up

00:11:08,640 --> 00:11:12,800
looking

00:11:09,120 --> 00:11:14,079
nice and it already has the code logic

00:11:12,800 --> 00:11:15,600
is dissolved already

00:11:14,079 --> 00:11:17,680
the moment you try to make this in

00:11:15,600 --> 00:11:18,640
parallel this kind of is going to blow

00:11:17,680 --> 00:11:21,680
up

00:11:18,640 --> 00:11:23,519
but the declarative code the problem is

00:11:21,680 --> 00:11:25,040
the how to do's and what to do there are

00:11:23,519 --> 00:11:26,640
two how to do's in here

00:11:25,040 --> 00:11:28,399
the looping through the list aggregating

00:11:26,640 --> 00:11:31,040
results are how to do's and

00:11:28,399 --> 00:11:31,440
what to do validating and extracting

00:11:31,040 --> 00:11:33,760
right

00:11:31,440 --> 00:11:35,519
the problem is the imperative has both

00:11:33,760 --> 00:11:37,360
of them merge together

00:11:35,519 --> 00:11:39,279
and that's the problem now that one of

00:11:37,360 --> 00:11:40,000
the how to do looping has changed to

00:11:39,279 --> 00:11:43,200
parallel

00:11:40,000 --> 00:11:45,200
everything needs to be rewritten but the

00:11:43,200 --> 00:11:47,680
declarative code it's pretty simple all

00:11:45,200 --> 00:11:49,519
i got to do is just convert this

00:11:47,680 --> 00:11:51,680
sequence to a parallel stream or

00:11:49,519 --> 00:11:52,800
whatever synonymous in your language

00:11:51,680 --> 00:11:55,040
that you're using

00:11:52,800 --> 00:11:56,720
uh the part that i'm want to convey is

00:11:55,040 --> 00:11:59,760
you've got to write to abstractions

00:11:56,720 --> 00:12:01,279
the core context philosophy if you

00:11:59,760 --> 00:12:02,880
want to do things differently without

00:12:01,279 --> 00:12:04,800
doing different things you're going to

00:12:02,880 --> 00:12:06,480
write to those abstractions to see the

00:12:04,800 --> 00:12:08,000
part which is going to change

00:12:06,480 --> 00:12:10,000
and you can kind of switch it out and

00:12:08,000 --> 00:12:12,399
then and declarative coding provides

00:12:10,000 --> 00:12:14,079
you that mechanism so this is kind of

00:12:12,399 --> 00:12:15,360
you don't have to tag this to function

00:12:14,079 --> 00:12:17,279
programming this is

00:12:15,360 --> 00:12:18,880
predominantly same but just that you

00:12:17,279 --> 00:12:20,480
realize whatever you have done is

00:12:18,880 --> 00:12:22,800
something

00:12:20,480 --> 00:12:23,600
this that you're gonna you can kind of

00:12:22,800 --> 00:12:25,680
switch the

00:12:23,600 --> 00:12:27,920
stream to parallel sequence and then

00:12:25,680 --> 00:12:30,480
make things everything run in parallel

00:12:27,920 --> 00:12:32,000
awesome so we're almost halfway through

00:12:30,480 --> 00:12:32,560
a tech talk and i've got an interval

00:12:32,000 --> 00:12:35,040
bang

00:12:32,560 --> 00:12:37,120
for you guys uh the sequence that we

00:12:35,040 --> 00:12:40,480
have been using is a monad

00:12:37,120 --> 00:12:42,320
so i hope a lot of some

00:12:40,480 --> 00:12:44,160
you must have heard about monad at some

00:12:42,320 --> 00:12:46,880
place or the other if you're kind of

00:12:44,160 --> 00:12:47,519
a citizen programmer and i'm sure you

00:12:46,880 --> 00:12:49,279
that

00:12:47,519 --> 00:12:51,519
very name would have scared you and it

00:12:49,279 --> 00:12:52,160
scared me as well but then i'm pretty

00:12:51,519 --> 00:12:55,440
enthusiastic

00:12:52,160 --> 00:12:58,320
i want to really see what monad is and

00:12:55,440 --> 00:13:00,160
uh the most part of me is i really want

00:12:58,320 --> 00:13:02,560
to use it in my production code

00:13:00,160 --> 00:13:04,839
but then i have to understand is it

00:13:02,560 --> 00:13:08,079
really used in production

00:13:04,839 --> 00:13:09,200
so today let's not focus on what i'm one

00:13:08,079 --> 00:13:12,079
ad is but then

00:13:09,200 --> 00:13:13,920
focus on why it is used and this is me

00:13:12,079 --> 00:13:15,680
by the way trying to understand

00:13:13,920 --> 00:13:17,839
functus warner's applicatives in my

00:13:15,680 --> 00:13:21,040
initial days going through all those

00:13:17,839 --> 00:13:23,120
papers and blog posts uh you know

00:13:21,040 --> 00:13:24,560
none of them made sense like monarchs

00:13:23,120 --> 00:13:25,519
and monarch and the category of window

00:13:24,560 --> 00:13:27,600
functors

00:13:25,519 --> 00:13:30,000
that's like a harry potter spell right i

00:13:27,600 --> 00:13:31,360
it didn't really make any sense to me

00:13:30,000 --> 00:13:33,040
and there is even a joke this

00:13:31,360 --> 00:13:34,560
predominant joke on the left side says

00:13:33,040 --> 00:13:35,440
that monarchs are cursed once you

00:13:34,560 --> 00:13:37,440
understand them

00:13:35,440 --> 00:13:38,560
you cannot lose the ability to explain

00:13:37,440 --> 00:13:40,880
them to others

00:13:38,560 --> 00:13:42,320
so i'm gonna try to do the same today

00:13:40,880 --> 00:13:44,160
tonight uh i mean

00:13:42,320 --> 00:13:45,839
to the morning uh which is kind of

00:13:44,160 --> 00:13:48,000
ironical and

00:13:45,839 --> 00:13:49,279
i'm gonna call all these monads these

00:13:48,000 --> 00:13:51,040
are all different things actually

00:13:49,279 --> 00:13:52,240
functions monarch suffocatives but just

00:13:51,040 --> 00:13:54,399
for the sake of

00:13:52,240 --> 00:13:56,240
today's evening uh i'm going to just

00:13:54,399 --> 00:13:58,240
call all of the monarchs and if you want

00:13:56,240 --> 00:13:59,920
to really understand the difference

00:13:58,240 --> 00:14:02,480
please kind of go through this blog post

00:13:59,920 --> 00:14:04,800
by this guy smart guy which

00:14:02,480 --> 00:14:05,760
is a translated post from haskell which

00:14:04,800 --> 00:14:08,399
has a

00:14:05,760 --> 00:14:10,399
very detailed explanation of what these

00:14:08,399 --> 00:14:13,519
three categories are

00:14:10,399 --> 00:14:15,360
so and as i said i'm going to use this

00:14:13,519 --> 00:14:18,720
awesome awesome library arrow

00:14:15,360 --> 00:14:21,199
and which is uh which has

00:14:18,720 --> 00:14:22,000
been worked to uh since kind of couple

00:14:21,199 --> 00:14:24,079
of years

00:14:22,000 --> 00:14:25,680
and they have almost there towards one

00:14:24,079 --> 00:14:27,440
point overlays and

00:14:25,680 --> 00:14:29,600
they've got some great functional tool

00:14:27,440 --> 00:14:32,240
set that you should go and explore

00:14:29,600 --> 00:14:34,560
i'm gonna just pick a piece from there

00:14:32,240 --> 00:14:36,160
uh using either one add which i'm gonna

00:14:34,560 --> 00:14:37,680
we're gonna predominantly use today in

00:14:36,160 --> 00:14:39,920
for today's problem

00:14:37,680 --> 00:14:41,760
and what is the one at again it's just a

00:14:39,920 --> 00:14:42,160
design pattern it's just a way of doing

00:14:41,760 --> 00:14:44,639
things

00:14:42,160 --> 00:14:46,160
in some way but then like i said we're

00:14:44,639 --> 00:14:47,120
just going to focus on the application

00:14:46,160 --> 00:14:49,120
really if you're not

00:14:47,120 --> 00:14:50,560
if you are a library developer or just

00:14:49,120 --> 00:14:52,160
want to write a monarch with your own

00:14:50,560 --> 00:14:53,600
hands just play around you can go in the

00:14:52,160 --> 00:14:57,760
source code and see that

00:14:53,600 --> 00:14:59,760
uh so let's issue uh i mean

00:14:57,760 --> 00:15:01,199
understand this either monad has two

00:14:59,760 --> 00:15:04,000
states so

00:15:01,199 --> 00:15:05,920
uh state it's on the left as you can see

00:15:04,000 --> 00:15:09,279
alien in the box with the red state

00:15:05,920 --> 00:15:11,360
it's like i'll be using that for

00:15:09,279 --> 00:15:12,959
i'll be saying that as a left state and

00:15:11,360 --> 00:15:13,839
there is a right state wherein you have

00:15:12,959 --> 00:15:15,519
a valid value

00:15:13,839 --> 00:15:17,040
actually you can use this left and right

00:15:15,519 --> 00:15:18,959
for anything but then

00:15:17,040 --> 00:15:21,440
it's it's a just a conviction to use

00:15:18,959 --> 00:15:23,920
left for invalids and rights for valids

00:15:21,440 --> 00:15:24,639
especially if you're using either monad

00:15:23,920 --> 00:15:25,920
and this is

00:15:24,639 --> 00:15:27,839
something called a sum type in

00:15:25,920 --> 00:15:29,680
functional programming

00:15:27,839 --> 00:15:31,279
so as i said i'll be using left for

00:15:29,680 --> 00:15:34,800
validation failures and i

00:15:31,279 --> 00:15:37,440
will be going into the problem so

00:15:34,800 --> 00:15:38,959
so uh some some crash course on monad

00:15:37,440 --> 00:15:40,800
before we get into the problem

00:15:38,959 --> 00:15:42,959
so imagine you have a plus 3 function

00:15:40,800 --> 00:15:45,680
and let's say you want to

00:15:42,959 --> 00:15:47,279
add plus 3 to a value so traditionally

00:15:45,680 --> 00:15:48,720
you would pass that value you'd call the

00:15:47,279 --> 00:15:49,360
function passing that value and you

00:15:48,720 --> 00:15:52,160
would

00:15:49,360 --> 00:15:54,480
do a plus 3 on it so imagine if you have

00:15:52,160 --> 00:15:57,600
that value within the monarch box

00:15:54,480 --> 00:15:59,759
you would in turn pass a function to it

00:15:57,600 --> 00:16:00,720
and the monad applies that function on

00:15:59,759 --> 00:16:02,240
that value

00:16:00,720 --> 00:16:04,800
and then puts the result back in the

00:16:02,240 --> 00:16:07,040
monarch box so that is the difference uh

00:16:04,800 --> 00:16:09,440
just a paradigm shift

00:16:07,040 --> 00:16:11,040
and this is how it's done with the code

00:16:09,440 --> 00:16:12,160
so when you say either dot right you're

00:16:11,040 --> 00:16:14,639
putting that two

00:16:12,160 --> 00:16:16,160
inside of one ad box and then uh

00:16:14,639 --> 00:16:18,000
syntactically i mean they can be

00:16:16,160 --> 00:16:19,279
different things for the programming

00:16:18,000 --> 00:16:21,440
different programming languages

00:16:19,279 --> 00:16:23,759
i hope this is a language diagnostic

00:16:21,440 --> 00:16:27,279
though just i'm using kotlin because

00:16:23,759 --> 00:16:29,519
it's a great language and as you can see

00:16:27,279 --> 00:16:30,639
in the map as you pass a plus three

00:16:29,519 --> 00:16:33,199
function to it

00:16:30,639 --> 00:16:33,680
and then the plus three function is uh

00:16:33,199 --> 00:16:36,000
the

00:16:33,680 --> 00:16:36,880
is applied on this two and then you

00:16:36,000 --> 00:16:40,240
would get a result

00:16:36,880 --> 00:16:41,920
back out of it so same thing

00:16:40,240 --> 00:16:43,839
for the sequence if you have a sequence

00:16:41,920 --> 00:16:45,680
of characters you wanna sorry sequence

00:16:43,839 --> 00:16:48,000
of integers and you want to apply

00:16:45,680 --> 00:16:49,839
the same function one after the other

00:16:48,000 --> 00:16:50,880
and you would want to have a sequence

00:16:49,839 --> 00:16:55,040
with the applied

00:16:50,880 --> 00:16:57,120
result this is how you get it so

00:16:55,040 --> 00:16:58,959
what if the either is on the left state

00:16:57,120 --> 00:17:00,560
so all it's going to happen is the

00:16:58,959 --> 00:17:02,240
the function that you're going to pass

00:17:00,560 --> 00:17:04,400
is just going to get ignored

00:17:02,240 --> 00:17:05,600
so that this is our important philosophy

00:17:04,400 --> 00:17:07,839
important uh

00:17:05,600 --> 00:17:09,360
property that we're gonna use in our uh

00:17:07,839 --> 00:17:13,039
for our problem

00:17:09,360 --> 00:17:16,400
so so where is this

00:17:13,039 --> 00:17:18,240
gonna come handy so imagine if you have

00:17:16,400 --> 00:17:20,720
an area of functions that you want to

00:17:18,240 --> 00:17:22,400
apply so traditionally you would do this

00:17:20,720 --> 00:17:23,919
do this way right you kind of pass a

00:17:22,400 --> 00:17:24,640
result of one function to another

00:17:23,919 --> 00:17:26,559
function

00:17:24,640 --> 00:17:28,000
you do f of g of h of x just like in

00:17:26,559 --> 00:17:31,039
maths but

00:17:28,000 --> 00:17:33,600
if you have um one add you can do this

00:17:31,039 --> 00:17:34,480
like you can apply these functions one

00:17:33,600 --> 00:17:37,600
after the other

00:17:34,480 --> 00:17:40,400
in a chain declaratively and

00:17:37,600 --> 00:17:40,799
the best part is this is how it looks

00:17:40,400 --> 00:17:44,080
like

00:17:40,799 --> 00:17:45,919
uh and then if one of the

00:17:44,080 --> 00:17:48,080
results turns into a red box in the

00:17:45,919 --> 00:17:50,480
middle all that's going to happen is

00:17:48,080 --> 00:17:51,120
uh the functions the the other functions

00:17:50,480 --> 00:17:52,640
which are

00:17:51,120 --> 00:17:55,440
being applied are just going to get

00:17:52,640 --> 00:17:56,640
ignored so this property we're going to

00:17:55,440 --> 00:17:59,440
use again

00:17:56,640 --> 00:18:01,440
and uh so the very important question

00:17:59,440 --> 00:18:02,880
are monarchs used in enterprise software

00:18:01,440 --> 00:18:04,480
are they just for theory

00:18:02,880 --> 00:18:06,559
so that is what i'm going to demonstrate

00:18:04,480 --> 00:18:09,840
how we have used monarchs

00:18:06,559 --> 00:18:11,600
so we kind of have a cult following

00:18:09,840 --> 00:18:14,000
about one ads in our team and

00:18:11,600 --> 00:18:15,520
people are like crazy whenever someone

00:18:14,000 --> 00:18:18,559
says monad because

00:18:15,520 --> 00:18:19,840
we had to do hard brainstorming almost

00:18:18,559 --> 00:18:21,679
like killing each other

00:18:19,840 --> 00:18:23,600
saying we should should we have monash

00:18:21,679 --> 00:18:25,360
or should we not have one ads

00:18:23,600 --> 00:18:27,679
and we finally came to the library

00:18:25,360 --> 00:18:30,400
called vader and

00:18:27,679 --> 00:18:32,000
this library was helping us to do

00:18:30,400 --> 00:18:34,880
validations for

00:18:32,000 --> 00:18:36,080
our services which are rest services

00:18:34,880 --> 00:18:37,919
which i'm gonna

00:18:36,080 --> 00:18:40,000
quickly touch upon the requirements and

00:18:37,919 --> 00:18:41,600
show you some dummy code and how we

00:18:40,000 --> 00:18:43,760
solved it

00:18:41,600 --> 00:18:46,000
so as i said we are we were building

00:18:43,760 --> 00:18:46,720
rest apis we were payment industry and

00:18:46,000 --> 00:18:48,880
we had

00:18:46,720 --> 00:18:50,240
services like payment referred uh

00:18:48,880 --> 00:18:53,120
authorization etc

00:18:50,240 --> 00:18:55,840
and they all are json payloads so this

00:18:53,120 --> 00:18:56,720
is a sample json payload for one of our

00:18:55,840 --> 00:18:59,200
services

00:18:56,720 --> 00:19:00,640
and this is how a client places a

00:18:59,200 --> 00:19:03,440
request to our service

00:19:00,640 --> 00:19:04,240
and he's gonna he has to pass the amount

00:19:03,440 --> 00:19:06,720
the

00:19:04,240 --> 00:19:08,080
payment method and card etc these are

00:19:06,720 --> 00:19:10,960
very familiar terms

00:19:08,080 --> 00:19:12,080
uh so imagine uh amazon you're paying

00:19:10,960 --> 00:19:14,080
through amazon and

00:19:12,080 --> 00:19:15,520
this is a request you place for service

00:19:14,080 --> 00:19:19,120
uh something like stripe

00:19:15,520 --> 00:19:21,360
if you know that uh so the thing is

00:19:19,120 --> 00:19:22,400
uh a peculiar requirement that our

00:19:21,360 --> 00:19:24,080
service has is

00:19:22,400 --> 00:19:25,600
the payment method as you can see in the

00:19:24,080 --> 00:19:28,000
middle this is

00:19:25,600 --> 00:19:28,960
you can call it a child uh object within

00:19:28,000 --> 00:19:32,799
this parent

00:19:28,960 --> 00:19:34,240
json right this uh will be reused uh the

00:19:32,799 --> 00:19:37,919
structure is reused

00:19:34,240 --> 00:19:39,440
across multiple services uh as it is

00:19:37,919 --> 00:19:42,480
like without any change

00:19:39,440 --> 00:19:44,640
so this is one example so the problem is

00:19:42,480 --> 00:19:46,160
uh the validations we don't want to

00:19:44,640 --> 00:19:47,440
rewrite those validations for the

00:19:46,160 --> 00:19:48,799
payment method

00:19:47,440 --> 00:19:51,120
all the validations for the payment

00:19:48,799 --> 00:19:52,320
method we want to reuse these

00:19:51,120 --> 00:19:53,840
validations and just

00:19:52,320 --> 00:19:55,520
hook these validations to the other

00:19:53,840 --> 00:19:57,360
service so

00:19:55,520 --> 00:19:58,559
essentially saying that we want to share

00:19:57,360 --> 00:20:00,240
all the validations

00:19:58,559 --> 00:20:02,240
for the data structure which is common

00:20:00,240 --> 00:20:05,760
across multiple services

00:20:02,240 --> 00:20:07,440
i hope this is clear so but then there

00:20:05,760 --> 00:20:09,280
are other validations like simple data

00:20:07,440 --> 00:20:10,960
validations like amount and this amount

00:20:09,280 --> 00:20:12,480
fail is something which is again common

00:20:10,960 --> 00:20:14,960
across all the services

00:20:12,480 --> 00:20:16,799
and uh this is a shade validation that

00:20:14,960 --> 00:20:19,200
i've said and this is a

00:20:16,799 --> 00:20:20,080
effective validation which i kind of if

00:20:19,200 --> 00:20:21,840
i have to verify

00:20:20,080 --> 00:20:24,080
an account id is valid or not i would

00:20:21,840 --> 00:20:27,280
have to hit the db make a db call

00:20:24,080 --> 00:20:29,440
which is exception prone so

00:20:27,280 --> 00:20:30,559
so we have so many uh val such

00:20:29,440 --> 00:20:33,280
validations

00:20:30,559 --> 00:20:34,000
and these by the way come in batches so

00:20:33,280 --> 00:20:36,640
what i've

00:20:34,000 --> 00:20:37,760
shown you is one a list of one so we

00:20:36,640 --> 00:20:40,799
would get a list of

00:20:37,760 --> 00:20:43,919
n suggestion notes and then we had to

00:20:40,799 --> 00:20:45,760
validate all of those and we had i'll be

00:20:43,919 --> 00:20:47,600
going into the requirements very shortly

00:20:45,760 --> 00:20:49,039
and we had to build a batch validation

00:20:47,600 --> 00:20:52,320
framework for that why

00:20:49,039 --> 00:20:54,159
uh we'll see so for this talk uh i'm not

00:20:52,320 --> 00:20:56,080
gonna get into this production because

00:20:54,159 --> 00:20:56,640
it's very boring let's just replace that

00:20:56,080 --> 00:20:58,960
with

00:20:56,640 --> 00:21:00,960
an egg so whenever i say we're

00:20:58,960 --> 00:21:02,159
validating egg assume we're validating

00:21:00,960 --> 00:21:04,480
something like

00:21:02,159 --> 00:21:06,159
just an object and then to represent a

00:21:04,480 --> 00:21:08,240
child object like payment method

00:21:06,159 --> 00:21:09,520
i would be calling a yoke i'd be using

00:21:08,240 --> 00:21:12,720
yoke object

00:21:09,520 --> 00:21:14,880
so let's get and so by the way uh now so

00:21:12,720 --> 00:21:16,880
that now that we have a list of x

00:21:14,880 --> 00:21:19,280
we got to filter out valid x from

00:21:16,880 --> 00:21:23,520
invalid x so that's our requirement

00:21:19,280 --> 00:21:25,280
for the day so some requirements again

00:21:23,520 --> 00:21:27,600
uh we have to configure the order of

00:21:25,280 --> 00:21:29,280
validation so imagine i have

00:21:27,600 --> 00:21:31,840
as i've told there are some validations

00:21:29,280 --> 00:21:32,159
which do db calls some more which might

00:21:31,840 --> 00:21:34,000
do

00:21:32,159 --> 00:21:36,000
network calls these are all costly i

00:21:34,000 --> 00:21:37,520
want to keep them towards the end

00:21:36,000 --> 00:21:39,840
i want to keep the cheaper validations

00:21:37,520 --> 00:21:41,840
at the start so uh

00:21:39,840 --> 00:21:43,440
if i have to do a fail fast when i say

00:21:41,840 --> 00:21:46,080
fail fast it's like whenever a

00:21:43,440 --> 00:21:46,720
validation fails i want to stop my

00:21:46,080 --> 00:21:49,200
validation

00:21:46,720 --> 00:21:51,760
validating there itself so if i have to

00:21:49,200 --> 00:21:54,240
do that i should as a developer have

00:21:51,760 --> 00:21:55,840
a way to configure those validations and

00:21:54,240 --> 00:21:57,520
i should be cross sharing common and

00:21:55,840 --> 00:21:59,360
nested validations as i've

00:21:57,520 --> 00:22:00,880
discussed before the payment method i

00:21:59,360 --> 00:22:01,840
should be able to hook it to other

00:22:00,880 --> 00:22:04,000
services

00:22:01,840 --> 00:22:05,280
uh without actually rewriting them in

00:22:04,000 --> 00:22:07,039
each and every service

00:22:05,280 --> 00:22:09,200
and support both fail fast and

00:22:07,039 --> 00:22:11,600
recognization on each subrequest

00:22:09,200 --> 00:22:13,280
so as i've said fail fast is one way we

00:22:11,600 --> 00:22:15,600
have another route where we

00:22:13,280 --> 00:22:18,000
want to do error accumulation we want

00:22:15,600 --> 00:22:20,799
actually all the validation failures

00:22:18,000 --> 00:22:22,480
so that's how that's another requirement

00:22:20,799 --> 00:22:25,120
and then we want partial failures

00:22:22,480 --> 00:22:27,440
so when you have a list of json nodes we

00:22:25,120 --> 00:22:29,520
kind of want to

00:22:27,440 --> 00:22:31,280
filter out the invalid ones but then

00:22:29,520 --> 00:22:33,679
move ahead with the valid ones

00:22:31,280 --> 00:22:34,480
but then because there's a batch i can't

00:22:33,679 --> 00:22:36,559
really

00:22:34,480 --> 00:22:38,720
send back the error response so this is

00:22:36,559 --> 00:22:41,360
how it looks so imagine i have a

00:22:38,720 --> 00:22:42,080
validation layer i have kind of two

00:22:41,360 --> 00:22:45,360
invalids

00:22:42,080 --> 00:22:48,080
the alien represents invalid we can say

00:22:45,360 --> 00:22:49,440
so it's like an alien egg or something

00:22:48,080 --> 00:22:51,440
so

00:22:49,440 --> 00:22:53,919
then i'm marching forward with this five

00:22:51,440 --> 00:22:55,600
valid x and then on the service layer i

00:22:53,919 --> 00:22:58,159
got some xyz exception

00:22:55,600 --> 00:22:58,880
i have to mark something again invalid

00:22:58,159 --> 00:23:01,280
or something

00:22:58,880 --> 00:23:03,200
or some some error response the problem

00:23:01,280 --> 00:23:05,440
is like whenever in the validation layer

00:23:03,200 --> 00:23:07,600
whenever i find some invalids i can't

00:23:05,440 --> 00:23:09,440
right away send back the invalid

00:23:07,600 --> 00:23:13,039
response because it's a batch

00:23:09,440 --> 00:23:14,400
validation uh batch service so i had to

00:23:13,039 --> 00:23:16,159
wait till the end

00:23:14,400 --> 00:23:17,520
and then only can send aggregated

00:23:16,159 --> 00:23:19,360
response back

00:23:17,520 --> 00:23:21,520
those are partial failures how am i

00:23:19,360 --> 00:23:22,320
going to hold these invalid ones till

00:23:21,520 --> 00:23:24,240
the end

00:23:22,320 --> 00:23:26,080
and skip them from getting processed in

00:23:24,240 --> 00:23:28,000
service layer and db layer so that's a

00:23:26,080 --> 00:23:30,159
challenge

00:23:28,000 --> 00:23:32,080
and some meta requirements are we can't

00:23:30,159 --> 00:23:33,280
have to accommodate a century validation

00:23:32,080 --> 00:23:34,480
so if you have five or ten

00:23:33,280 --> 00:23:37,200
whatever i've shown you is like the

00:23:34,480 --> 00:23:39,200
simplest payload but then we have uh

00:23:37,200 --> 00:23:41,200
our payload actually is increasing it

00:23:39,200 --> 00:23:43,120
has been increasing and then

00:23:41,200 --> 00:23:44,960
we keep adding new fields as we have

00:23:43,120 --> 00:23:47,679
more requirements and then

00:23:44,960 --> 00:23:48,559
our validations kind of went almost to a

00:23:47,679 --> 00:23:50,720
00:23:48,559 --> 00:23:51,679
and across services it's not just one

00:23:50,720 --> 00:23:54,240
service

00:23:51,679 --> 00:23:54,799
and and we have to we like i said we

00:23:54,240 --> 00:23:57,440
have to

00:23:54,799 --> 00:23:59,120
hook few validations to one service like

00:23:57,440 --> 00:24:00,159
pick and choose these validations which

00:23:59,120 --> 00:24:03,600
kind of makes this

00:24:00,159 --> 00:24:04,159
tricky and unit testability is very

00:24:03,600 --> 00:24:06,880
important

00:24:04,159 --> 00:24:08,720
and no compromise on performance so like

00:24:06,880 --> 00:24:09,440
anything else any like any other

00:24:08,720 --> 00:24:12,000
requirement

00:24:09,440 --> 00:24:13,440
uh uh the requirements are agile like

00:24:12,000 --> 00:24:15,679
any other real-world application

00:24:13,440 --> 00:24:18,000
requirements never stay constant

00:24:15,679 --> 00:24:19,760
so on a first day we had one again one

00:24:18,000 --> 00:24:21,120
validation life is pretty simple just

00:24:19,760 --> 00:24:22,799
you know pass that one actually to

00:24:21,120 --> 00:24:25,840
validation get the result back

00:24:22,799 --> 00:24:27,840
done uh when you have many eggs and one

00:24:25,840 --> 00:24:28,640
validation still not so difficult you

00:24:27,840 --> 00:24:31,360
can look

00:24:28,640 --> 00:24:32,640
through all the eggs you can pass them

00:24:31,360 --> 00:24:34,400
through the validation

00:24:32,640 --> 00:24:35,679
and then get back the result they can

00:24:34,400 --> 00:24:38,159
filter things are

00:24:35,679 --> 00:24:39,840
pretty easy the moment you have many

00:24:38,159 --> 00:24:42,960
eggs and many validations

00:24:39,840 --> 00:24:45,919
that's where in the problem starts

00:24:42,960 --> 00:24:47,600
you know it kind of becomes a difficult

00:24:45,919 --> 00:24:49,679
problem and if i have to deal that

00:24:47,600 --> 00:24:53,520
problem in an imperative style i'll show

00:24:49,679 --> 00:24:53,520
you how the code can end up looking like

00:24:53,600 --> 00:24:56,880
i hope the font is fine for everybody uh

00:24:56,400 --> 00:25:00,400
let me

00:24:56,880 --> 00:25:02,559
let me know if there's a problem uh

00:25:00,400 --> 00:25:03,760
so yeah what i'm gonna what i'm showing

00:25:02,559 --> 00:25:06,640
you is how

00:25:03,760 --> 00:25:07,679
you have if you go about doing it

00:25:06,640 --> 00:25:09,679
imperatively

00:25:07,679 --> 00:25:12,159
the code ends up looking like again this

00:25:09,679 --> 00:25:15,039
is a dummy code a simple code that just

00:25:12,159 --> 00:25:15,440
i'm using for demonstration but uh

00:25:15,039 --> 00:25:17,919
looking

00:25:15,440 --> 00:25:19,120
even looking at this code from a mile

00:25:17,919 --> 00:25:21,760
away you can see

00:25:19,120 --> 00:25:24,960
uh just opening chat could you make it a

00:25:21,760 --> 00:25:24,960
bit larger okay

00:25:26,840 --> 00:25:43,840
uh

00:25:29,840 --> 00:25:43,840
just a second

00:25:54,240 --> 00:25:59,120
hope this is fine uh

00:26:01,520 --> 00:26:06,559
cool so uh the code ends up looking like

00:26:04,559 --> 00:26:08,320
this so this is pretty fabulous for a

00:26:06,559 --> 00:26:10,080
lot of us because we keep seeing this

00:26:08,320 --> 00:26:12,880
kind of code in our production

00:26:10,080 --> 00:26:14,960
a lot of fills try catches and all those

00:26:12,880 --> 00:26:17,039
inverted pyramid kind of stuff

00:26:14,960 --> 00:26:18,960
so let me try to explain what we're

00:26:17,039 --> 00:26:22,240
trying to do here

00:26:18,960 --> 00:26:25,520
uh you can answer this okay

00:26:22,240 --> 00:26:28,159
cool i think i just zoomed back in

00:26:25,520 --> 00:26:28,159
what did i do

00:26:30,000 --> 00:26:32,720
ah this is

00:26:33,440 --> 00:26:41,039
okay uh

00:26:38,320 --> 00:26:41,039
it's weird

00:26:47,760 --> 00:26:55,520
okay how did i do control what

00:26:51,360 --> 00:26:58,159
huh got it i was control scrolling

00:26:55,520 --> 00:27:00,000
yeah so uh what i'm trying to do is i

00:26:58,159 --> 00:27:03,039
let's say i have got a carton

00:27:00,000 --> 00:27:06,320
uh which is a list of eggs so

00:27:03,039 --> 00:27:07,039
we're gonna have to result a map wherein

00:27:06,320 --> 00:27:10,240
i have a

00:27:07,039 --> 00:27:12,880
ids of all the eggs and then all the

00:27:10,240 --> 00:27:14,240
invalid x and then the reason why the

00:27:12,880 --> 00:27:16,720
eggs are invalid

00:27:14,240 --> 00:27:17,520
so how about how can we do that like

00:27:16,720 --> 00:27:20,320
week

00:27:17,520 --> 00:27:21,600
imperatively simplistic way i have to

00:27:20,320 --> 00:27:24,399
look through all the eggs

00:27:21,600 --> 00:27:25,919
and then for each egg i have few rules

00:27:24,399 --> 00:27:29,120
that it needs to pass

00:27:25,919 --> 00:27:31,120
and based on it result uh if if it

00:27:29,120 --> 00:27:33,360
passes the rule if it doesn't pass the

00:27:31,120 --> 00:27:35,600
rule i'll have to remove that

00:27:33,360 --> 00:27:36,640
from the iterator because i don't want

00:27:35,600 --> 00:27:38,799
that egg through

00:27:36,640 --> 00:27:40,320
to get processed for further rules so

00:27:38,799 --> 00:27:42,320
for the validations

00:27:40,320 --> 00:27:44,880
and then put that in a bucket with the

00:27:42,320 --> 00:27:46,880
id saying why this egg is bad

00:27:44,880 --> 00:27:48,880
right so that is the simplest thing i'm

00:27:46,880 --> 00:27:50,399
doing and then

00:27:48,880 --> 00:27:52,399
i have try catches because there are

00:27:50,399 --> 00:27:54,080
some rules which can throw exceptions

00:27:52,399 --> 00:27:55,600
like the db operations that we have

00:27:54,080 --> 00:27:57,760
discussed before

00:27:55,600 --> 00:27:59,360
and some rules that are working on the

00:27:57,760 --> 00:28:01,520
nested object say yoke

00:27:59,360 --> 00:28:02,559
so for that i have to actually dig

00:28:01,520 --> 00:28:05,840
inside so the

00:28:02,559 --> 00:28:07,440
the more nested it is uh the the pyramid

00:28:05,840 --> 00:28:08,240
grows the inverted pyramid grows on my

00:28:07,440 --> 00:28:10,399
screen

00:28:08,240 --> 00:28:12,000
and then finally i'll give back this uh

00:28:10,399 --> 00:28:13,840
map so

00:28:12,000 --> 00:28:16,159
this is as simple as like i i hardly

00:28:13,840 --> 00:28:18,399
have few three or four validations and

00:28:16,159 --> 00:28:22,000
the score already is monstrous

00:28:18,399 --> 00:28:23,919
and oh okay so can we make it better

00:28:22,000 --> 00:28:26,640
uh what if i kind of break each and

00:28:23,919 --> 00:28:30,399
every rule into its own

00:28:26,640 --> 00:28:33,679
method let's see if that can improve so

00:28:30,399 --> 00:28:34,320
this is where i have this is another

00:28:33,679 --> 00:28:37,279
file

00:28:34,320 --> 00:28:38,960
with the same uh again i'll be

00:28:37,279 --> 00:28:40,159
explaining the project structure so that

00:28:38,960 --> 00:28:43,200
you can go back and

00:28:40,159 --> 00:28:45,440
refer but then here i have broken down

00:28:43,200 --> 00:28:46,480
each and every function into its own

00:28:45,440 --> 00:28:48,720
each and every

00:28:46,480 --> 00:28:51,120
operation into its own function so for

00:28:48,720 --> 00:28:54,399
one simple rule i have this one function

00:28:51,120 --> 00:28:56,960
and etc etc but the problem is there is

00:28:54,399 --> 00:28:57,440
this guy like the orchestrator which had

00:28:56,960 --> 00:28:59,520
to

00:28:57,440 --> 00:29:02,000
again call each and every function pass

00:28:59,520 --> 00:29:04,559
the egg and then get the result back

00:29:02,000 --> 00:29:06,240
and based on that he has to maintain uh

00:29:04,559 --> 00:29:08,559
whether i have to remove the egg or

00:29:06,240 --> 00:29:10,240
pass the egg to further validations etc

00:29:08,559 --> 00:29:12,720
i would call somebody like this an

00:29:10,240 --> 00:29:15,840
octopus orchestrator because it's trying

00:29:12,720 --> 00:29:16,880
to do a lot of things

00:29:15,840 --> 00:29:19,200
trying to manage a lot of

00:29:16,880 --> 00:29:20,000
responsibilities and this is going to

00:29:19,200 --> 00:29:21,600
blow up

00:29:20,000 --> 00:29:23,360
so we have the same problem we

00:29:21,600 --> 00:29:24,960
essentially didn't kind of

00:29:23,360 --> 00:29:26,960
solve the problem just by breaking it

00:29:24,960 --> 00:29:30,080
into functions and

00:29:26,960 --> 00:29:32,399
i would say uh code like this is complex

00:29:30,080 --> 00:29:33,360
so but then i just don't want to say it

00:29:32,399 --> 00:29:36,720
subjectively

00:29:33,360 --> 00:29:39,520
i want to objectively measure the code

00:29:36,720 --> 00:29:40,960
measure the complexity in this code so i

00:29:39,520 --> 00:29:44,240
would use something like

00:29:40,960 --> 00:29:46,960
sonar cube which is pretty popular so i

00:29:44,240 --> 00:29:48,159
all i had to do was run the sonar

00:29:46,960 --> 00:29:51,520
console on my

00:29:48,159 --> 00:29:54,080
local machine so you can read about it

00:29:51,520 --> 00:29:55,679
online how you can set it up and i have

00:29:54,080 --> 00:29:57,840
a gradle plugin sonar cube

00:29:55,679 --> 00:29:59,600
and then i had to run the gradle task

00:29:57,840 --> 00:30:01,120
gradle sonar cube here

00:29:59,600 --> 00:30:02,960
and then i would get this beautiful

00:30:01,120 --> 00:30:04,559
matrix in here

00:30:02,960 --> 00:30:06,240
and by the way before getting into it

00:30:04,559 --> 00:30:08,480
i'm using

00:30:06,240 --> 00:30:09,520
cognitive complexity over cyclomatic

00:30:08,480 --> 00:30:12,000
complexity i'm not

00:30:09,520 --> 00:30:13,600
using cyclomatic complexity and this

00:30:12,000 --> 00:30:17,039
blog post on sonar cube

00:30:13,600 --> 00:30:19,120
has details on how cyclomatic complexity

00:30:17,039 --> 00:30:21,200
uh only doesn't measure maintainability

00:30:19,120 --> 00:30:22,320
and how cognitive complexity is better

00:30:21,200 --> 00:30:25,120
than that

00:30:22,320 --> 00:30:27,279
so you should really go check it out but

00:30:25,120 --> 00:30:29,440
one thing is cognitive complexity really

00:30:27,279 --> 00:30:30,960
understands humor readability rather

00:30:29,440 --> 00:30:32,960
than just checking blindly checking the

00:30:30,960 --> 00:30:36,399
number of branches

00:30:32,960 --> 00:30:37,200
so so you can on in your sona console

00:30:36,399 --> 00:30:39,440
you can go to

00:30:37,200 --> 00:30:40,960
this measure and then the cognitive

00:30:39,440 --> 00:30:43,279
complexity you should be able to see the

00:30:40,960 --> 00:30:46,960
cognitive complexity of your files

00:30:43,279 --> 00:30:48,399
so this is the number i get and

00:30:46,960 --> 00:30:50,080
i would say this is like a demo code you

00:30:48,399 --> 00:30:51,840
could see a i'm not doing

00:30:50,080 --> 00:30:53,200
a lot of things but still the cognitive

00:30:51,840 --> 00:30:55,760
complexity is too much for

00:30:53,200 --> 00:30:57,840
a little bit of code and i see this

00:30:55,760 --> 00:31:00,559
complexity can go down to

00:30:57,840 --> 00:31:01,200
single digits which uh we're gonna see

00:31:00,559 --> 00:31:04,080
how

00:31:01,200 --> 00:31:06,559
the journey how of how we can do that

00:31:04,080 --> 00:31:08,799
but before that

00:31:06,559 --> 00:31:10,640
let's see step by step where how we can

00:31:08,799 --> 00:31:12,559
get there

00:31:10,640 --> 00:31:14,799
but for now we're stuck with a code like

00:31:12,559 --> 00:31:17,120
this a chaotic code right

00:31:14,799 --> 00:31:18,880
imagine you're you're like a developer a

00:31:17,120 --> 00:31:20,640
developer is like playing this game

00:31:18,880 --> 00:31:21,919
and the state in your code the egg is

00:31:20,640 --> 00:31:23,519
trying to escape from all the

00:31:21,919 --> 00:31:25,440
validations which are like

00:31:23,519 --> 00:31:26,720
written everywhere see there are no

00:31:25,440 --> 00:31:28,240
rules you can kind of

00:31:26,720 --> 00:31:30,559
write your validation function like

00:31:28,240 --> 00:31:32,320
anything and one validation can call any

00:31:30,559 --> 00:31:33,279
other validation there is a there's no

00:31:32,320 --> 00:31:35,600
rules at all

00:31:33,279 --> 00:31:38,000
which kind of makes it chaotic by the

00:31:35,600 --> 00:31:38,720
way i love playing this game as a child

00:31:38,000 --> 00:31:40,720
so this is

00:31:38,720 --> 00:31:42,480
this is i think the hell level in mario

00:31:40,720 --> 00:31:44,240
done by some fan i should definitely

00:31:42,480 --> 00:31:47,120
play this

00:31:44,240 --> 00:31:48,880
and so we're going to achieve uh now

00:31:47,120 --> 00:31:49,519
we're going to solve this problem by

00:31:48,880 --> 00:31:51,120
using

00:31:49,519 --> 00:31:52,880
a pattern called chain of responsibility

00:31:51,120 --> 00:31:54,559
this is pretty popular

00:31:52,880 --> 00:31:56,880
especially when it comes to validations

00:31:54,559 --> 00:31:57,519
and this is people might know it as an

00:31:56,880 --> 00:31:59,200
object

00:31:57,519 --> 00:32:01,039
paradigm i would really i really don't

00:31:59,200 --> 00:32:04,480
want to label that that way

00:32:01,039 --> 00:32:06,880
but we're gonna use fp today

00:32:04,480 --> 00:32:08,240
so the question is is if the best fit to

00:32:06,880 --> 00:32:10,320
solve this problem

00:32:08,240 --> 00:32:12,720
so this is a functional programming talk

00:32:10,320 --> 00:32:14,559
of course what do you expect me to say

00:32:12,720 --> 00:32:16,159
uh take your till here and say oh sorry

00:32:14,559 --> 00:32:18,960
object oriented programming is

00:32:16,159 --> 00:32:19,360
better than this so i'm just kidding so

00:32:18,960 --> 00:32:21,919
yes

00:32:19,360 --> 00:32:24,159
sp is the best fit and validation is one

00:32:21,919 --> 00:32:27,519
classic case to actually

00:32:24,159 --> 00:32:30,000
see how fp how powerful fp is so again

00:32:27,519 --> 00:32:33,039
uh i'm saying fp but uh don't kind of

00:32:30,000 --> 00:32:34,640
think that i'm exclusive exclusively

00:32:33,039 --> 00:32:38,320
saying fp is better than oops

00:32:34,640 --> 00:32:39,600
i'm just uh saying uh what's uh i'm just

00:32:38,320 --> 00:32:42,640
talking about those policies or

00:32:39,600 --> 00:32:46,240
principles under the fb um

00:32:42,640 --> 00:32:49,039
so the moment uh what the problem that

00:32:46,240 --> 00:32:50,640
we what mistake we did is we kind of

00:32:49,039 --> 00:32:51,679
thought it's a one dimensional problem

00:32:50,640 --> 00:32:53,600
without just exa

00:32:51,679 --> 00:32:55,120
looping and validations are just

00:32:53,600 --> 00:32:56,000
function that we need to call but the

00:32:55,120 --> 00:32:58,720
moment you think

00:32:56,000 --> 00:33:00,080
validations are entities too they're

00:32:58,720 --> 00:33:02,399
functions right they're

00:33:00,080 --> 00:33:04,720
they're citizens i mean uh why do you

00:33:02,399 --> 00:33:07,919
think functions are just some plain old

00:33:04,720 --> 00:33:09,039
uh things that objects are the important

00:33:07,919 --> 00:33:11,200
part right

00:33:09,039 --> 00:33:13,039
that's like objection under programming

00:33:11,200 --> 00:33:14,720
but then the moment you think functions

00:33:13,039 --> 00:33:16,320
are things too you'll get a different

00:33:14,720 --> 00:33:17,760
perspective of this problem

00:33:16,320 --> 00:33:19,840
and you think there's a two dimensional

00:33:17,760 --> 00:33:22,399
problem and this kind of becomes like a

00:33:19,840 --> 00:33:24,320
matrix wherein you can

00:33:22,399 --> 00:33:26,720
actually plot which is valid which is

00:33:24,320 --> 00:33:30,000
invalid again is what validation

00:33:26,720 --> 00:33:31,760
so what i mean by uh

00:33:30,000 --> 00:33:33,120
functions are things too i'll i'm gonna

00:33:31,760 --> 00:33:35,440
show that but for now

00:33:33,120 --> 00:33:36,240
this is what we're gonna build uh today

00:33:35,440 --> 00:33:39,279
so

00:33:36,240 --> 00:33:40,960
uh we are essentially gonna split uh the

00:33:39,279 --> 00:33:43,200
what to do is from how to do's

00:33:40,960 --> 00:33:45,120
as we have discussed before and what are

00:33:43,200 --> 00:33:47,120
what produce in our uh problem the all

00:33:45,120 --> 00:33:48,960
the validations are what to do

00:33:47,120 --> 00:33:50,399
and how to do's are the configuration

00:33:48,960 --> 00:33:51,679
orchestration a configuration is

00:33:50,399 --> 00:33:54,159
something wherein

00:33:51,679 --> 00:33:56,399
how i just want to configure how my

00:33:54,159 --> 00:33:59,679
validations run the order in which my

00:33:56,399 --> 00:34:01,600
validation is run and orchestration is

00:33:59,679 --> 00:34:03,919
how exactly am i firing those

00:34:01,600 --> 00:34:06,720
validations is it fail fast is it

00:34:03,919 --> 00:34:08,320
error accumulation as a singular

00:34:06,720 --> 00:34:11,520
parallel etc

00:34:08,320 --> 00:34:12,159
so and first thing i would do is make

00:34:11,520 --> 00:34:13,760
all the thing

00:34:12,159 --> 00:34:16,159
x immutable that's the first thing i

00:34:13,760 --> 00:34:18,320
would do to solve this because

00:34:16,159 --> 00:34:20,639
mutability is the root cause for a lot

00:34:18,320 --> 00:34:21,359
of lot of problems and as a developer i

00:34:20,639 --> 00:34:23,839
know how

00:34:21,359 --> 00:34:26,159
silly bugs used to hide when things are

00:34:23,839 --> 00:34:28,800
being mutated unnecessarily

00:34:26,159 --> 00:34:29,359
and as a java programmer i suffered this

00:34:28,800 --> 00:34:31,200
a lot

00:34:29,359 --> 00:34:33,280
the moment you make it immutable your

00:34:31,200 --> 00:34:36,159
state really becomes predictable

00:34:33,280 --> 00:34:37,520
and i mean you don't lose anything

00:34:36,159 --> 00:34:39,520
that's

00:34:37,520 --> 00:34:41,359
i feel immutability should be used

00:34:39,520 --> 00:34:44,480
wherever necessary

00:34:41,359 --> 00:34:46,560
so in kotlin we are fortunate to have

00:34:44,480 --> 00:34:48,720
data classes so i'm using

00:34:46,560 --> 00:34:51,040
data classes which are immutable by

00:34:48,720 --> 00:34:52,879
default

00:34:51,040 --> 00:34:54,879
if you're not in kotlin if you are in

00:34:52,879 --> 00:34:57,919
java you can kind of

00:34:54,879 --> 00:34:57,919
use any other

00:34:58,160 --> 00:35:01,520
lombok or something which predominantly

00:35:00,160 --> 00:35:04,880
gives you

00:35:01,520 --> 00:35:07,040
this data class so

00:35:04,880 --> 00:35:08,160
this is what i mean a data class that

00:35:07,040 --> 00:35:10,560
i'm talking about

00:35:08,160 --> 00:35:13,359
egg and then it has few properties and

00:35:10,560 --> 00:35:16,400
then as i've told it has a yoke

00:35:13,359 --> 00:35:17,040
so now i'm gonna get into showing you

00:35:16,400 --> 00:35:20,960
the code

00:35:17,040 --> 00:35:22,160
and uh let me uh help you understand the

00:35:20,960 --> 00:35:23,760
uh

00:35:22,160 --> 00:35:26,480
project structure so that you can go

00:35:23,760 --> 00:35:30,720
back and refer post this talk

00:35:26,480 --> 00:35:32,240
okay do i have something in the chat

00:35:30,720 --> 00:35:34,480
yeah that's right data glasses are

00:35:32,240 --> 00:35:36,160
coming as i said java is following up

00:35:34,480 --> 00:35:39,520
with the kotlin

00:35:36,160 --> 00:35:42,000
which is kind of so

00:35:39,520 --> 00:35:44,079
uh this project structure that i have as

00:35:42,000 --> 00:35:45,280
i've said this is a dummy code to kind

00:35:44,079 --> 00:35:47,760
of

00:35:45,280 --> 00:35:49,359
replicate uh or simulate what the veda

00:35:47,760 --> 00:35:52,240
library that we have developed

00:35:49,359 --> 00:35:54,000
so this particular algebra has all the

00:35:52,240 --> 00:35:57,119
library related code

00:35:54,000 --> 00:35:59,119
and this class you can think of is like

00:35:57,119 --> 00:36:01,760
a consumer to that library

00:35:59,119 --> 00:36:03,599
and you have various ways how we are

00:36:01,760 --> 00:36:05,440
consuming how you're calling and we're

00:36:03,599 --> 00:36:08,560
gonna i'm gonna get into them

00:36:05,440 --> 00:36:12,079
and then and then a few tests

00:36:08,560 --> 00:36:13,680
to to prove that uh approve or

00:36:12,079 --> 00:36:15,599
to actually simulate things that i'm

00:36:13,680 --> 00:36:17,280
going to demonstrate which you should uh

00:36:15,599 --> 00:36:18,800
definitely check out so

00:36:17,280 --> 00:36:20,560
if you really want to understand this

00:36:18,800 --> 00:36:26,640
start from the test and then

00:36:20,560 --> 00:36:29,920
go your way up understanding things

00:36:26,640 --> 00:36:31,760
okay and then

00:36:29,920 --> 00:36:34,160
second thing uh we have a heterogeneous

00:36:31,760 --> 00:36:34,720
data types in a pipeline what i mean by

00:36:34,160 --> 00:36:38,000
that

00:36:34,720 --> 00:36:40,640
so we have eggs pallidex invalid x uh

00:36:38,000 --> 00:36:42,480
as we talked i don't really care about

00:36:40,640 --> 00:36:43,920
invalid x i care about the reason why

00:36:42,480 --> 00:36:46,400
the eggs are invalid

00:36:43,920 --> 00:36:46,960
so i essentially have a violation

00:36:46,400 --> 00:36:48,800
failure

00:36:46,960 --> 00:36:50,960
and then i have a valid egg the two

00:36:48,800 --> 00:36:52,640
different data types and i can't put

00:36:50,960 --> 00:36:55,119
them in a single list

00:36:52,640 --> 00:36:55,680
so for that reason i would be using uh

00:36:55,119 --> 00:36:57,119
either

00:36:55,680 --> 00:36:59,839
either one ad that we have discussed

00:36:57,119 --> 00:37:01,920
before because either has two states

00:36:59,839 --> 00:37:03,200
uh you really are in the end you have

00:37:01,920 --> 00:37:05,119
objects of either

00:37:03,200 --> 00:37:07,040
but then they can exist in two different

00:37:05,119 --> 00:37:07,680
states uh i'm gonna show you how that

00:37:07,040 --> 00:37:08,960
happens

00:37:07,680 --> 00:37:11,119
so but then we're going to solve this

00:37:08,960 --> 00:37:13,200
problem using this and then we're going

00:37:11,119 --> 00:37:15,200
to standardize all the validations

00:37:13,200 --> 00:37:16,560
what i mean by that as of we have seen

00:37:15,200 --> 00:37:18,560
before

00:37:16,560 --> 00:37:20,400
imperative style you can write functions

00:37:18,560 --> 00:37:21,920
in any way nobody is going to stop you

00:37:20,400 --> 00:37:22,960
from having three parameters four

00:37:21,920 --> 00:37:24,880
parameters

00:37:22,960 --> 00:37:26,480
but then if you really want to bring a

00:37:24,880 --> 00:37:28,079
structure to your problem

00:37:26,480 --> 00:37:30,000
you have to standardize them what i mean

00:37:28,079 --> 00:37:32,160
by standardizes

00:37:30,000 --> 00:37:33,839
they have to have same input and same

00:37:32,160 --> 00:37:36,320
output all the validation should have

00:37:33,839 --> 00:37:41,440
standard input and output

00:37:36,320 --> 00:37:41,440
but let me get into what i mean by that

00:37:43,599 --> 00:37:49,520
so this is how our new code looks like

00:37:46,960 --> 00:37:51,200
what i mean by new coders this is how

00:37:49,520 --> 00:37:53,200
our validations look like

00:37:51,200 --> 00:37:54,400
so these are same analogous validations

00:37:53,200 --> 00:37:55,359
that we have seen before in our

00:37:54,400 --> 00:37:57,760
imperative style

00:37:55,359 --> 00:37:58,720
but now they're totally unrecognizable

00:37:57,760 --> 00:38:01,200
like they're

00:37:58,720 --> 00:38:03,680
converted to a functional style so let

00:38:01,200 --> 00:38:06,720
me try to explain one by one

00:38:03,680 --> 00:38:08,400
so this particular validation uh the

00:38:06,720 --> 00:38:09,440
simplest validation we have is turned

00:38:08,400 --> 00:38:13,520
into this

00:38:09,440 --> 00:38:16,400
and you can see from this function the

00:38:13,520 --> 00:38:17,119
uh input is gonna be uh either one and

00:38:16,400 --> 00:38:19,760
then

00:38:17,119 --> 00:38:20,320
output is sorry i mean what i mean is

00:38:19,760 --> 00:38:23,520
this is

00:38:20,320 --> 00:38:25,440
a validator and this returns a function

00:38:23,520 --> 00:38:26,960
so this is a function so i'm just

00:38:25,440 --> 00:38:28,720
assigning that to

00:38:26,960 --> 00:38:30,000
and then what is this validator this is

00:38:28,720 --> 00:38:33,520
just a custom defined

00:38:30,000 --> 00:38:35,359
type type alias which means like uh

00:38:33,520 --> 00:38:37,280
typically i hope understand i i don't

00:38:35,359 --> 00:38:38,960
know java java doesn't have it

00:38:37,280 --> 00:38:40,800
but then this is a way to actually

00:38:38,960 --> 00:38:42,160
declare it to say what you're meaning

00:38:40,800 --> 00:38:43,920
you can just what i mean is you can

00:38:42,160 --> 00:38:45,359
replace this validator with this

00:38:43,920 --> 00:38:47,920
whatever you see in

00:38:45,359 --> 00:38:48,960
this type so what it does is it takes in

00:38:47,920 --> 00:38:51,040
a validatable

00:38:48,960 --> 00:38:53,040
which is egg in our case and then

00:38:51,040 --> 00:38:56,000
returns back an either monarch

00:38:53,040 --> 00:38:57,680
and either one can as we discussed is

00:38:56,000 --> 00:39:00,320
can be on left side or right state

00:38:57,680 --> 00:39:01,280
so when it's on left state it would hold

00:39:00,320 --> 00:39:03,359
a failure

00:39:01,280 --> 00:39:04,720
and if it's the right state it i don't

00:39:03,359 --> 00:39:06,640
really care if it's on the right side

00:39:04,720 --> 00:39:09,680
it's valid for me

00:39:06,640 --> 00:39:11,280
so uh that's what

00:39:09,680 --> 00:39:12,720
we have converted all our functions

00:39:11,280 --> 00:39:15,920
looking like so

00:39:12,720 --> 00:39:19,200
every property you see is a property

00:39:15,920 --> 00:39:20,079
having a function assigned and each and

00:39:19,200 --> 00:39:22,640
every function as

00:39:20,079 --> 00:39:23,200
we discussed uh follows the pattern and

00:39:22,640 --> 00:39:26,000
then

00:39:23,200 --> 00:39:26,720
now as you can see i get an egg and then

00:39:26,000 --> 00:39:30,480
i

00:39:26,720 --> 00:39:33,760
this is by the way is called either dsl

00:39:30,480 --> 00:39:35,440
this is coming from arrow uh i obviously

00:39:33,760 --> 00:39:36,320
don't have time to cover this but this

00:39:35,440 --> 00:39:38,560
is awesome

00:39:36,320 --> 00:39:40,160
as you can see you can't find a map of

00:39:38,560 --> 00:39:41,760
flat map anywhere

00:39:40,160 --> 00:39:43,280
all that noise is taken out you can

00:39:41,760 --> 00:39:45,440
actually write this in

00:39:43,280 --> 00:39:46,880
uh like a full comprehension if you are

00:39:45,440 --> 00:39:48,320
familiar with scala they have four

00:39:46,880 --> 00:39:49,760
comprehensions which is missing in

00:39:48,320 --> 00:39:52,240
content as well as java

00:39:49,760 --> 00:39:53,200
but these guys fill that gap i hope this

00:39:52,240 --> 00:39:56,720
really comes to

00:39:53,200 --> 00:39:59,839
uh first class uh support in kotlin

00:39:56,720 --> 00:40:01,760
and then so again all of this is a dummy

00:39:59,839 --> 00:40:04,960
code there are some dummy rules and

00:40:01,760 --> 00:40:06,960
dummy output all this various failure

00:40:04,960 --> 00:40:09,440
cases why it can be failure

00:40:06,960 --> 00:40:12,079
failure and all so you can go back and

00:40:09,440 --> 00:40:14,720
understand this code in the leisure

00:40:12,079 --> 00:40:15,920
uh and there are a few yoke validations

00:40:14,720 --> 00:40:18,960
as we have discussed

00:40:15,920 --> 00:40:19,839
children also have some validations so

00:40:18,960 --> 00:40:24,160
this is how

00:40:19,839 --> 00:40:25,839
nothing really fancy about this so

00:40:24,160 --> 00:40:27,359
configure the order of validations our

00:40:25,839 --> 00:40:28,079
first requirement how did we achieve

00:40:27,359 --> 00:40:29,280
that

00:40:28,079 --> 00:40:31,119
so now that you have seen the

00:40:29,280 --> 00:40:33,680
validations are just

00:40:31,119 --> 00:40:36,079
values right functions are just values

00:40:33,680 --> 00:40:39,520
uh how do you put this in order all you

00:40:36,079 --> 00:40:41,680
need is an ordered list right uh if your

00:40:39,520 --> 00:40:43,440
your requirement is a bit more complex

00:40:41,680 --> 00:40:44,079
like you have a parent having multiple

00:40:43,440 --> 00:40:46,000
children

00:40:44,079 --> 00:40:47,920
and children having multiple parents and

00:40:46,000 --> 00:40:48,800
all that stuff it actually becomes a

00:40:47,920 --> 00:40:51,599
graph problem

00:40:48,800 --> 00:40:53,280
uh and if you really need to have a

00:40:51,599 --> 00:40:55,200
chain you've got to do a topological

00:40:53,280 --> 00:40:57,839
thought or something but in the end uh

00:40:55,200 --> 00:40:58,480
it's it's uh the problem is taken out

00:40:57,839 --> 00:41:00,480
from the

00:40:58,480 --> 00:41:02,240
actual code orchestrator uh in the

00:41:00,480 --> 00:41:04,000
imperative the orchestrated octopus

00:41:02,240 --> 00:41:05,359
orchestrator is doing all the things

00:41:04,000 --> 00:41:08,000
and the moment you want to really

00:41:05,359 --> 00:41:10,079
shuffle uh these validations or add new

00:41:08,000 --> 00:41:12,240
validations you have to do a code change

00:41:10,079 --> 00:41:13,280
but the moment if we take this ordering

00:41:12,240 --> 00:41:15,200
out

00:41:13,280 --> 00:41:17,040
we kind of are you can write function

00:41:15,200 --> 00:41:17,440
anywhere but then ordering is taken care

00:41:17,040 --> 00:41:19,760
by the

00:41:17,440 --> 00:41:21,280
different uh entity i'm gonna go into

00:41:19,760 --> 00:41:24,400
that

00:41:21,280 --> 00:41:24,960
and this is config so uh just look at

00:41:24,400 --> 00:41:26,960
these

00:41:24,960 --> 00:41:29,040
so all the parents i can make a parent

00:41:26,960 --> 00:41:29,680
validation chain just by making a list

00:41:29,040 --> 00:41:31,040
of them

00:41:29,680 --> 00:41:33,280
and children i can make a child

00:41:31,040 --> 00:41:36,079
validation uh chain

00:41:33,280 --> 00:41:37,119
awesome so cross share common and nested

00:41:36,079 --> 00:41:40,240
validations

00:41:37,119 --> 00:41:40,720
now uh imagine uh my first problem as

00:41:40,240 --> 00:41:42,640
i've said

00:41:40,720 --> 00:41:43,760
imagine the child validations all

00:41:42,640 --> 00:41:46,400
comprised to

00:41:43,760 --> 00:41:47,440
a payment method so for me to actually

00:41:46,400 --> 00:41:49,200
validate that egg

00:41:47,440 --> 00:41:50,800
i have to validate both the egg the

00:41:49,200 --> 00:41:52,960
parent as well as all

00:41:50,800 --> 00:41:55,359
the validation the children right but

00:41:52,960 --> 00:41:57,920
the problem here is you can see

00:41:55,359 --> 00:41:59,520
these are of type list of validator

00:41:57,920 --> 00:42:02,480
which takes an egg

00:41:59,520 --> 00:42:04,160
which has egg on the input as well as

00:42:02,480 --> 00:42:05,920
the validation failure on the output

00:42:04,160 --> 00:42:07,839
but this is a different type as you can

00:42:05,920 --> 00:42:10,079
see this has yolk and valid failure

00:42:07,839 --> 00:42:10,960
i really can't concat these two lists

00:42:10,079 --> 00:42:13,760
and prepare a

00:42:10,960 --> 00:42:15,359
actual chain chain of responsibilities

00:42:13,760 --> 00:42:17,280
that are required for validating this

00:42:15,359 --> 00:42:20,000
egg right

00:42:17,280 --> 00:42:21,280
so what is the uh how can we actually

00:42:20,000 --> 00:42:23,599
concat this

00:42:21,280 --> 00:42:24,640
so the only solution is you got to lift

00:42:23,599 --> 00:42:28,000
all the child

00:42:24,640 --> 00:42:29,119
validations to parent type so what i

00:42:28,000 --> 00:42:31,680
mean by lifting

00:42:29,119 --> 00:42:33,359
so let me get to the code and show you

00:42:31,680 --> 00:42:36,319
what i mean by lifting

00:42:33,359 --> 00:42:38,160
i think i have some in slides so yeah

00:42:36,319 --> 00:42:40,640
imagine this is parent validation

00:42:38,160 --> 00:42:41,599
so you have a validator of type parent

00:42:40,640 --> 00:42:44,079
and then

00:42:41,599 --> 00:42:45,680
you have a validator of which takes and

00:42:44,079 --> 00:42:48,079
a child object

00:42:45,680 --> 00:42:49,200
and you kind of convert this to this how

00:42:48,079 --> 00:42:52,319
do we do that

00:42:49,200 --> 00:42:56,640
uh so i am

00:42:52,319 --> 00:42:59,680
uh within this file called

00:42:56,640 --> 00:43:00,960
sorry i think it's config dsl uh i can't

00:42:59,680 --> 00:43:03,839
say the file name

00:43:00,960 --> 00:43:04,560
that's fine yeah it's config dsl and

00:43:03,839 --> 00:43:06,000
within this

00:43:04,560 --> 00:43:07,280
uh you should be able to see this

00:43:06,000 --> 00:43:08,400
function called lift to parent

00:43:07,280 --> 00:43:10,480
validation type

00:43:08,400 --> 00:43:12,319
so all it does is it takes in a child

00:43:10,480 --> 00:43:14,160
validation and then gives you back a

00:43:12,319 --> 00:43:16,319
parent validation within that

00:43:14,160 --> 00:43:18,400
how the lifting is performed you kind of

00:43:16,319 --> 00:43:20,160
also take a mapper which kind of tells

00:43:18,400 --> 00:43:21,200
you how to take your child out of your

00:43:20,160 --> 00:43:22,960
parent

00:43:21,200 --> 00:43:25,520
in a particular case it's just probably

00:43:22,960 --> 00:43:27,920
a getter get off yoke

00:43:25,520 --> 00:43:28,720
and then uh this few other parameters

00:43:27,920 --> 00:43:30,640
just to

00:43:28,720 --> 00:43:32,240
uh for for the sake of parent is

00:43:30,640 --> 00:43:34,480
knowledge child is null

00:43:32,240 --> 00:43:35,599
so essentially all i'm trying to do is i

00:43:34,480 --> 00:43:38,000
i use this mapper

00:43:35,599 --> 00:43:39,359
i take the child out of the parent and

00:43:38,000 --> 00:43:42,400
then

00:43:39,359 --> 00:43:43,119
i i apply the child validation so the

00:43:42,400 --> 00:43:45,839
written type

00:43:43,119 --> 00:43:46,960
actually hap the input is parent as you

00:43:45,839 --> 00:43:50,000
can see so that

00:43:46,960 --> 00:43:54,960
this turns out to be this validation now

00:43:50,000 --> 00:43:57,280
with that lifting i can happily

00:43:54,960 --> 00:43:59,119
concat these parent validations with all

00:43:57,280 --> 00:44:01,599
the child validation chain

00:43:59,119 --> 00:44:02,560
and then prepare a mega list of

00:44:01,599 --> 00:44:05,040
validations

00:44:02,560 --> 00:44:07,119
uh which i can call a validation chain

00:44:05,040 --> 00:44:10,400
but what is the use of this uh

00:44:07,119 --> 00:44:11,839
lifting so imagine now this egg is a

00:44:10,400 --> 00:44:13,760
chicken egg so i'm

00:44:11,839 --> 00:44:15,760
valid in chicken eggs and i would need

00:44:13,760 --> 00:44:17,839
all the yolk validations i can i have

00:44:15,760 --> 00:44:19,760
done a lifting tomorrow i have a dino

00:44:17,839 --> 00:44:21,680
egg but then it has the same yolk as the

00:44:19,760 --> 00:44:23,920
chicken egg

00:44:21,680 --> 00:44:25,920
uh i can really reuse all this yoke

00:44:23,920 --> 00:44:28,880
validations and but just by lifting them

00:44:25,920 --> 00:44:30,160
to the dynamic context if all i have to

00:44:28,880 --> 00:44:33,599
know is how to take

00:44:30,160 --> 00:44:36,079
the yoke out of dynamic so

00:44:33,599 --> 00:44:37,760
i hope you are clear about this and

00:44:36,079 --> 00:44:39,599
support both fail fast and error

00:44:37,760 --> 00:44:42,160
accumulation on e-sub-requests now we're

00:44:39,599 --> 00:44:44,319
jumping into orchestration part

00:44:42,160 --> 00:44:44,319
so

00:44:46,640 --> 00:44:51,119
the orchestrate and strat so have

00:44:49,280 --> 00:44:52,960
multiple strategies defined which i'm

00:44:51,119 --> 00:44:56,640
going to get into it but before that

00:44:52,960 --> 00:44:59,520
this is a runner dsl uh so this is a

00:44:56,640 --> 00:45:00,960
the the function which the client or

00:44:59,520 --> 00:45:01,920
whoever is consuming this library is

00:45:00,960 --> 00:45:04,800
going to call

00:45:01,920 --> 00:45:05,200
so imagine if you have to validate fail

00:45:04,800 --> 00:45:07,760
fast

00:45:05,200 --> 00:45:08,400
all i do is pass all the validatables

00:45:07,760 --> 00:45:10,000
which are

00:45:08,400 --> 00:45:12,000
eggs in our case as you can see this

00:45:10,000 --> 00:45:14,160
code is totally written in generic way

00:45:12,000 --> 00:45:15,599
so in my consumer has eggs and

00:45:14,160 --> 00:45:16,720
validation failures you can have

00:45:15,599 --> 00:45:19,040
something else

00:45:16,720 --> 00:45:20,800
fitting into this framework so even the

00:45:19,040 --> 00:45:22,319
library is totally generic written in a

00:45:20,800 --> 00:45:23,440
generic way there is no concrete type

00:45:22,319 --> 00:45:25,280
anywhere

00:45:23,440 --> 00:45:27,359
so yeah getting back to your problem we

00:45:25,280 --> 00:45:28,400
need validate bills and then we need

00:45:27,359 --> 00:45:30,400
validators

00:45:28,400 --> 00:45:31,760
all the validators that we define in our

00:45:30,400 --> 00:45:33,760
config the list

00:45:31,760 --> 00:45:35,760
i just need the chain in which you can

00:45:33,760 --> 00:45:37,839
want to run all validators

00:45:35,760 --> 00:45:40,079
and then you would need a mapper for

00:45:37,839 --> 00:45:43,119
throwable so if i get an exception

00:45:40,079 --> 00:45:46,000
how exactly i should map that exception

00:45:43,119 --> 00:45:47,839
to evaluate failure and then these

00:45:46,000 --> 00:45:48,960
parameters were in reference null or

00:45:47,839 --> 00:45:52,400
something

00:45:48,960 --> 00:45:54,720
so with these inputs in place i can just

00:45:52,400 --> 00:45:55,040
use this part traverse which comes again

00:45:54,720 --> 00:45:58,000
from

00:45:55,040 --> 00:45:58,839
arrow which is simply superb in terms of

00:45:58,000 --> 00:46:02,160
its

00:45:58,839 --> 00:46:04,800
conciseness uh what it does is

00:46:02,160 --> 00:46:07,359
it traverses this list in parallel so

00:46:04,800 --> 00:46:09,760
imagine if i have a four core system

00:46:07,359 --> 00:46:10,960
i should be able to validate four eggs

00:46:09,760 --> 00:46:13,280
at a time

00:46:10,960 --> 00:46:14,240
by actually validating all the eggs one

00:46:13,280 --> 00:46:17,359
after the other

00:46:14,240 --> 00:46:21,200
so i i can do these things in parallel

00:46:17,359 --> 00:46:23,359
so this is uh so this is so powerful and

00:46:21,200 --> 00:46:25,520
you should really go and check it out

00:46:23,359 --> 00:46:26,560
and this is accumulated errors where and

00:46:25,520 --> 00:46:29,599
i would do the same

00:46:26,560 --> 00:46:30,480
but then now i can run uh again four

00:46:29,599 --> 00:46:33,119
core system

00:46:30,480 --> 00:46:34,960
you can kind of validate four x and

00:46:33,119 --> 00:46:38,240
running four validations on each

00:46:34,960 --> 00:46:41,359
at a time which is like two x faster

00:46:38,240 --> 00:46:43,119
so you have to now we have to find two

00:46:41,359 --> 00:46:44,480
and then let's see what exactly happens

00:46:43,119 --> 00:46:47,440
in the strategy

00:46:44,480 --> 00:46:48,319
so i'm not gonna go into details of this

00:46:47,440 --> 00:46:49,680
uh you can

00:46:48,319 --> 00:46:51,200
you should be able to understand if you

00:46:49,680 --> 00:46:51,920
kind of put a diva point and just check

00:46:51,200 --> 00:46:54,319
it out

00:46:51,920 --> 00:46:56,000
this code might look kind of scary on

00:46:54,319 --> 00:46:58,880
the first look but then it's not really

00:46:56,000 --> 00:46:59,760
it's very simple it has loggers as well

00:46:58,880 --> 00:47:01,520
you can just

00:46:59,760 --> 00:47:04,160
run the code and see run the test cases

00:47:01,520 --> 00:47:07,200
and see what is going on

00:47:04,160 --> 00:47:07,200
let me check my chat

00:47:08,160 --> 00:47:14,400
cool i'll answer all those uh so

00:47:12,079 --> 00:47:16,079
so what what you can see is i'm showing

00:47:14,400 --> 00:47:18,319
you a fail-fire strategy

00:47:16,079 --> 00:47:19,680
so all you can have to do is you can use

00:47:18,319 --> 00:47:21,280
something called fold again it's

00:47:19,680 --> 00:47:21,920
predominant in functional programming

00:47:21,280 --> 00:47:24,079
language

00:47:21,920 --> 00:47:24,960
somebody who has worked with functional

00:47:24,079 --> 00:47:28,319
programming uh

00:47:24,960 --> 00:47:28,880
identifies this uh immediately uh if you

00:47:28,319 --> 00:47:31,119
have not

00:47:28,880 --> 00:47:33,040
uh this is something you should know and

00:47:31,119 --> 00:47:34,640
i should go about exploring uh

00:47:33,040 --> 00:47:36,480
it is not something this fold is nothing

00:47:34,640 --> 00:47:38,480
specific nothing special but then

00:47:36,480 --> 00:47:39,839
why i'm saying is this this acts as a

00:47:38,480 --> 00:47:41,599
shared vocabulary

00:47:39,839 --> 00:47:43,280
and then all it does is it does an

00:47:41,599 --> 00:47:44,400
aggregation something like reduce if you

00:47:43,280 --> 00:47:46,319
have heard about it

00:47:44,400 --> 00:47:47,440
and then you kind of fire a validation

00:47:46,319 --> 00:47:49,359
and do stuff

00:47:47,440 --> 00:47:51,520
and then you can have similarly some

00:47:49,359 --> 00:47:53,280
other strategy which you don't do it

00:47:51,520 --> 00:47:56,400
why i'm showing you two strategies is

00:47:53,280 --> 00:47:58,160
now strategy is totally independent of

00:47:56,400 --> 00:47:59,760
uh the validations as well as the order

00:47:58,160 --> 00:48:00,400
of validations now strategy is in your

00:47:59,760 --> 00:48:02,240
hands

00:48:00,400 --> 00:48:03,599
you can do whatever you want you can use

00:48:02,240 --> 00:48:05,440
part traffic so tomorrow there is

00:48:03,599 --> 00:48:09,119
something else which is more

00:48:05,440 --> 00:48:10,880
much a lot better uh you can kind of use

00:48:09,119 --> 00:48:11,680
it without actually disturbing any of

00:48:10,880 --> 00:48:13,920
these things

00:48:11,680 --> 00:48:15,520
or disturbing any of the tests for these

00:48:13,920 --> 00:48:18,400
things well tested things

00:48:15,520 --> 00:48:20,160
and you're doing like as we discussed as

00:48:18,400 --> 00:48:21,760
we started the how to do

00:48:20,160 --> 00:48:23,280
is in your hands and you can kind of

00:48:21,760 --> 00:48:25,280
switch them and

00:48:23,280 --> 00:48:27,200
similarly for error accumulation you

00:48:25,280 --> 00:48:29,920
kind of have multiple strategies

00:48:27,200 --> 00:48:30,400
which you can kind of switch uh imagine

00:48:29,920 --> 00:48:32,800
if

00:48:30,400 --> 00:48:34,480
why why i stretch on four lists imagine

00:48:32,800 --> 00:48:35,920
if i don't use fold

00:48:34,480 --> 00:48:37,680
i would probably have to write my

00:48:35,920 --> 00:48:39,440
orchestration this way

00:48:37,680 --> 00:48:42,400
uh as you can see again this is like an

00:48:39,440 --> 00:48:45,520
agile horse having all

00:48:42,400 --> 00:48:46,880
all those unnecessary details shadowing

00:48:45,520 --> 00:48:48,880
the core logic

00:48:46,880 --> 00:48:50,000
and if you can see there's a nested for

00:48:48,880 --> 00:48:51,760
loop and

00:48:50,000 --> 00:48:53,520
no matter how many times i see a nested

00:48:51,760 --> 00:48:55,440
for loop uh newness would follow

00:48:53,520 --> 00:48:57,520
again a different one i really have to

00:48:55,440 --> 00:49:00,079
spend time and understand put a diva

00:48:57,520 --> 00:49:03,520
point and see what is going on here

00:49:00,079 --> 00:49:06,319
so if you can go with these operators

00:49:03,520 --> 00:49:08,880
it they can really save a lot of time

00:49:06,319 --> 00:49:10,800
effort as well as uh

00:49:08,880 --> 00:49:12,960
access the shared vocabulary between

00:49:10,800 --> 00:49:14,160
your team and even if you see that in a

00:49:12,960 --> 00:49:16,400
new language you can

00:49:14,160 --> 00:49:17,920
right identify what's going on there and

00:49:16,400 --> 00:49:18,400
these are a few operators which are

00:49:17,920 --> 00:49:21,119
coming

00:49:18,400 --> 00:49:22,800
uh right out of the box in kotlin you

00:49:21,119 --> 00:49:25,200
should really go about exploring them

00:49:22,800 --> 00:49:26,720
and using them on your day-to-day basis

00:49:25,200 --> 00:49:28,319
replacing all your for loops

00:49:26,720 --> 00:49:29,920
and you could see the compression ratio

00:49:28,319 --> 00:49:31,440
that you got you kind of get four is to

00:49:29,920 --> 00:49:33,200
uncompression ratio and

00:49:31,440 --> 00:49:35,760
code really becomes concise and just

00:49:33,200 --> 00:49:38,079
expressing what is trying to do

00:49:35,760 --> 00:49:40,319
and partial failures uh how are we

00:49:38,079 --> 00:49:42,640
handling partial failure so if you see

00:49:40,319 --> 00:49:45,839
the written type of these strategies are

00:49:42,640 --> 00:49:45,839
list of

00:49:46,000 --> 00:49:51,680
uh the list of ethers right as we

00:49:49,200 --> 00:49:54,800
discussed we get list of either boxes

00:49:51,680 --> 00:49:56,240
so those either stay in left or right

00:49:54,800 --> 00:49:57,920
and then we have talked about property

00:49:56,240 --> 00:49:59,040
where and if it's on the left side the

00:49:57,920 --> 00:50:00,400
red state

00:49:59,040 --> 00:50:02,079
whatever function you're playing on it

00:50:00,400 --> 00:50:02,880
just gets ignored it just doesn't get

00:50:02,079 --> 00:50:05,760
processed

00:50:02,880 --> 00:50:06,960
so you take this bag of ethers you send

00:50:05,760 --> 00:50:09,520
them to any layer

00:50:06,960 --> 00:50:10,960
and then if you process them as these

00:50:09,520 --> 00:50:13,599
keep applying functions like

00:50:10,960 --> 00:50:15,440
composition on them you kind of don't

00:50:13,599 --> 00:50:16,079
have to think whether this how to skip

00:50:15,440 --> 00:50:17,760
these

00:50:16,079 --> 00:50:19,359
invalid ones they'll be skipped

00:50:17,760 --> 00:50:20,400
automatically by the property of this

00:50:19,359 --> 00:50:22,160
monarch right

00:50:20,400 --> 00:50:24,160
so that's how we can handle partial

00:50:22,160 --> 00:50:25,280
failures and towards the end we get

00:50:24,160 --> 00:50:27,760
again

00:50:25,280 --> 00:50:29,280
end of our flow of the code flow you

00:50:27,760 --> 00:50:30,079
will have a bag of either so you can

00:50:29,280 --> 00:50:32,640
simply just

00:50:30,079 --> 00:50:33,280
pass back uh the error response build

00:50:32,640 --> 00:50:34,800
construct and

00:50:33,280 --> 00:50:36,800
response based on the state of that

00:50:34,800 --> 00:50:39,280
monad

00:50:36,800 --> 00:50:41,119
awesome what are comics complexity so we

00:50:39,280 --> 00:50:44,800
have measured complexity for

00:50:41,119 --> 00:50:47,920
the imperative one let's see how the

00:50:44,800 --> 00:50:47,920
declarative one looks like

00:50:51,200 --> 00:50:56,880
so again i'm in the same project

00:50:54,319 --> 00:50:58,880
uh i got to this declarative i've we

00:50:56,880 --> 00:50:59,440
have seen validated six file where and i

00:50:58,880 --> 00:51:03,040
have

00:50:59,440 --> 00:51:05,040
and this is five just five and

00:51:03,040 --> 00:51:07,280
the number of validations are a lot more

00:51:05,040 --> 00:51:09,920
than the ones that have been imperative

00:51:07,280 --> 00:51:11,440
and this is an awesome improvement in

00:51:09,920 --> 00:51:14,000
terms of complexity

00:51:11,440 --> 00:51:15,520
and this metric as i've told talks about

00:51:14,000 --> 00:51:18,319
readability of the code

00:51:15,520 --> 00:51:20,880
and we kind of achieved we fought with

00:51:18,319 --> 00:51:23,040
complexity and kind of kill it

00:51:20,880 --> 00:51:25,359
and with this i want to pass a statement

00:51:23,040 --> 00:51:27,839
that happy is not complex but it fight

00:51:25,359 --> 00:51:29,760
cognitive complexity

00:51:27,839 --> 00:51:31,599
and we got minimum cognitive complexity

00:51:29,760 --> 00:51:33,200
with same time complexity what i mean is

00:51:31,599 --> 00:51:34,640
we haven't compromised on performance

00:51:33,200 --> 00:51:37,839
anywhere

00:51:34,640 --> 00:51:39,440
and this is i've named this railway

00:51:37,839 --> 00:51:40,800
oriented programming and i didn't call

00:51:39,440 --> 00:51:43,440
in this term this

00:51:40,800 --> 00:51:44,800
great guy wise guy scott flashing who is

00:51:43,440 --> 00:51:47,119
popular in f

00:51:44,800 --> 00:51:48,079
sharp space coined this and this

00:51:47,119 --> 00:51:50,480
particular implement

00:51:48,079 --> 00:51:51,680
implementation is inspired by that you

00:51:50,480 --> 00:51:52,559
should really go about checking your

00:51:51,680 --> 00:51:55,200
stocks

00:51:52,559 --> 00:51:56,640
and you really get a lot more uh

00:51:55,200 --> 00:52:00,240
insights about this kind of

00:51:56,640 --> 00:52:03,839
approach finally uh we have

00:52:00,240 --> 00:52:04,720
uh really a linear code right we don't

00:52:03,839 --> 00:52:07,839
really have

00:52:04,720 --> 00:52:10,160
ifs and else's and all those uh you know

00:52:07,839 --> 00:52:12,400
chaos that we had before we had linear

00:52:10,160 --> 00:52:15,040
code our state passes linearly

00:52:12,400 --> 00:52:17,280
from left and right uh we have either

00:52:15,040 --> 00:52:19,040
and you know things are very simple now

00:52:17,280 --> 00:52:20,319
and by the way this is the code deck

00:52:19,040 --> 00:52:23,359
where you can see all the

00:52:20,319 --> 00:52:24,960
sorry this is a source code link and

00:52:23,359 --> 00:52:26,319
these are the slide deck and where you

00:52:24,960 --> 00:52:28,800
can see all the slides

00:52:26,319 --> 00:52:30,839
and i hope things should be clear i have

00:52:28,800 --> 00:52:33,839
have comments and all that stuff

00:52:30,839 --> 00:52:37,520
so just before finishing

00:52:33,839 --> 00:52:39,440
uh so i just want to touch about this

00:52:37,520 --> 00:52:40,960
blob paradox like

00:52:39,440 --> 00:52:42,880
again there is no silver bullet you

00:52:40,960 --> 00:52:46,240
should realistic to

00:52:42,880 --> 00:52:48,000
making keeping things simple and

00:52:46,240 --> 00:52:49,680
again i'm not saying imperative is

00:52:48,000 --> 00:52:52,480
complex as such imperative

00:52:49,680 --> 00:52:53,280
can be simple uh it in particular use

00:52:52,480 --> 00:52:55,200
cases

00:52:53,280 --> 00:52:56,480
you can really go about doing simply

00:52:55,200 --> 00:52:58,640
with imperative style and

00:52:56,480 --> 00:53:00,400
if it really brings in more complexity

00:52:58,640 --> 00:53:01,760
and how can you actually get this

00:53:00,400 --> 00:53:04,640
way to use imperative versus where to

00:53:01,760 --> 00:53:06,079
use fp uh you have to master both you

00:53:04,640 --> 00:53:08,559
have to really

00:53:06,079 --> 00:53:09,359
gain some experience in terms of once

00:53:08,559 --> 00:53:11,280
you understand

00:53:09,359 --> 00:53:12,480
and this particular picture i don't want

00:53:11,280 --> 00:53:14,960
to say that functional

00:53:12,480 --> 00:53:16,160
the one is better than object oriented

00:53:14,960 --> 00:53:18,160
uh what i mean is

00:53:16,160 --> 00:53:20,319
somebody who knows both functional and

00:53:18,160 --> 00:53:22,640
object oriented or imperative decorative

00:53:20,319 --> 00:53:23,760
is a wiser programmer and you should

00:53:22,640 --> 00:53:26,960
really go

00:53:23,760 --> 00:53:29,599
experimenting and i would love to hear

00:53:26,960 --> 00:53:31,359
feedback uh this is my personal email id

00:53:29,599 --> 00:53:33,920
thanks a lot for this opportunity and

00:53:31,359 --> 00:53:36,720
skadoosh we have won the war on

00:53:33,920 --> 00:53:37,839
complexity i'm open to questions i know

00:53:36,720 --> 00:53:40,559
a lot of questions

00:53:37,839 --> 00:53:42,240
i don't know if um time if i'm on time

00:53:40,559 --> 00:53:45,680
or not

00:53:42,240 --> 00:53:47,280
so there's two in the q a do you want to

00:53:45,680 --> 00:53:50,480
address those first

00:53:47,280 --> 00:53:53,280
yep uh so you want to pick few questions

00:53:50,480 --> 00:53:55,040
uh or should i go in the chat and just

00:53:53,280 --> 00:53:58,160
answer them

00:53:55,040 --> 00:54:01,839
all right can you see the q a um panel

00:53:58,160 --> 00:54:04,079
oh guys you can just speak up and uh

00:54:01,839 --> 00:54:05,599
talk ah there's so many questions i see

00:54:04,079 --> 00:54:06,400
that the monarch code is actually hard

00:54:05,599 --> 00:54:10,480
to follow

00:54:06,400 --> 00:54:14,160
okay and answer this

00:54:10,480 --> 00:54:16,000
data class records okay i don't see any

00:54:14,160 --> 00:54:16,960
questions recommended forums recommended

00:54:16,000 --> 00:54:19,839
forums or slack

00:54:16,960 --> 00:54:20,480
channels um yeah i would i would really

00:54:19,839 --> 00:54:23,280
uh

00:54:20,480 --> 00:54:24,160
recommend this kotlin slack channel and

00:54:23,280 --> 00:54:26,480
we have

00:54:24,160 --> 00:54:27,680
arrow slack channel as our slack channel

00:54:26,480 --> 00:54:30,720
within the kotlin

00:54:27,680 --> 00:54:32,800
workspace so which

00:54:30,720 --> 00:54:34,400
the people are really patient you ask

00:54:32,800 --> 00:54:35,280
any dummy question they will really

00:54:34,400 --> 00:54:37,599
answer

00:54:35,280 --> 00:54:39,520
on any time of the day so i really

00:54:37,599 --> 00:54:41,839
recommend checking out the arrow channel

00:54:39,520 --> 00:54:43,280
joining there and keep asking questions

00:54:41,839 --> 00:54:46,240
about by exploring their

00:54:43,280 --> 00:54:49,280
uh things and then slide deck i've done

00:54:46,240 --> 00:54:49,280
that and thanks so much for

00:54:51,119 --> 00:54:56,079
thanks thanks watching and so there are

00:54:54,400 --> 00:54:59,680
four questions in the q a

00:54:56,079 --> 00:55:02,640
and i can read them out to you sure yep

00:54:59,680 --> 00:55:03,520
i'm interested that you you choose uh

00:55:02,640 --> 00:55:06,880
immunity of

00:55:03,520 --> 00:55:10,000
immutability referential transparency

00:55:06,880 --> 00:55:10,480
such as primary f and p principles where

00:55:10,000 --> 00:55:12,319
do you

00:55:10,480 --> 00:55:14,079
put your concepts like functions as

00:55:12,319 --> 00:55:16,960
first class values

00:55:14,079 --> 00:55:17,520
as well as reliance on higher order

00:55:16,960 --> 00:55:20,880
functions

00:55:17,520 --> 00:55:23,920
like map section and compose

00:55:20,880 --> 00:55:24,960
yep so uh we have seen first class

00:55:23,920 --> 00:55:28,079
functions uh

00:55:24,960 --> 00:55:29,520
so whenever uh when i've shown you these

00:55:28,079 --> 00:55:30,960
validated functions they're actually

00:55:29,520 --> 00:55:32,559
first class functions

00:55:30,960 --> 00:55:34,559
so what are first class functions

00:55:32,559 --> 00:55:35,920
they're just functions assigned to

00:55:34,559 --> 00:55:39,280
variables

00:55:35,920 --> 00:55:41,119
so where i have them validators right

00:55:39,280 --> 00:55:42,640
these are first class functions and what

00:55:41,119 --> 00:55:43,920
are higher order functions higher order

00:55:42,640 --> 00:55:45,760
functions are

00:55:43,920 --> 00:55:48,240
functions which take in a function which

00:55:45,760 --> 00:55:50,319
gives another function which in our case

00:55:48,240 --> 00:55:51,520
if you can go to config dsl this is one

00:55:50,319 --> 00:55:53,599
example of that

00:55:51,520 --> 00:55:55,200
this takes in a function and then gives

00:55:53,599 --> 00:55:58,400
you back another function

00:55:55,200 --> 00:56:01,599
so this is a high order function so uh

00:55:58,400 --> 00:56:02,079
the question uh i hope i answered the

00:56:01,599 --> 00:56:04,960
question

00:56:02,079 --> 00:56:06,079
what is it talking can you kind of

00:56:04,960 --> 00:56:08,720
repeat that uh

00:56:06,079 --> 00:56:09,599
if it has something else um it said

00:56:08,720 --> 00:56:11,440
where do you put

00:56:09,599 --> 00:56:13,760
concepts like functions as first class

00:56:11,440 --> 00:56:16,079
values as well as reliance on higher

00:56:13,760 --> 00:56:18,640
order functions like map section and

00:56:16,079 --> 00:56:21,599
compose

00:56:18,640 --> 00:56:23,359
okay uh i kind of didn't understand the

00:56:21,599 --> 00:56:25,280
last part composed but if you're talking

00:56:23,359 --> 00:56:26,720
about function composibility it's

00:56:25,280 --> 00:56:28,400
chaining functions one after the other

00:56:26,720 --> 00:56:31,440
which we have talked about

00:56:28,400 --> 00:56:32,319
dot map and then i was passing functions

00:56:31,440 --> 00:56:35,599
in the slide

00:56:32,319 --> 00:56:37,839
one of the slides so if you want to see

00:56:35,599 --> 00:56:39,680
where you put it in terms of principles

00:56:37,839 --> 00:56:40,799
uh i mean i'm not really strict you can

00:56:39,680 --> 00:56:42,559
probably put it in

00:56:40,799 --> 00:56:44,319
differential transparency reference

00:56:42,559 --> 00:56:47,359
transfer talks more about

00:56:44,319 --> 00:56:49,040
pure and impure functions like uh the

00:56:47,359 --> 00:56:50,720
functions output should actually depend

00:56:49,040 --> 00:56:53,599
on its arguments fast

00:56:50,720 --> 00:56:54,960
so you would call that and then no

00:56:53,599 --> 00:56:56,400
matter how many times you call that

00:56:54,960 --> 00:56:58,480
function the output shouldn't change you

00:56:56,400 --> 00:57:01,680
shouldn't do any side effects in between

00:56:58,480 --> 00:57:03,520
which is a bit more uh i mean it takes

00:57:01,680 --> 00:57:05,119
time it needs to talk again

00:57:03,520 --> 00:57:06,640
so probably you can just bring me on

00:57:05,119 --> 00:57:08,160
twitter or something which where i can

00:57:06,640 --> 00:57:11,200
surely be happy to answer

00:57:08,160 --> 00:57:13,520
yeah next question

00:57:11,200 --> 00:57:15,760
take one more okay sure yeah if you have

00:57:13,520 --> 00:57:17,119
time i understand functional is supposed

00:57:15,760 --> 00:57:19,200
to be stateless

00:57:17,119 --> 00:57:23,599
how does one handle passing around

00:57:19,200 --> 00:57:23,599
objects which maintain their own data

00:57:23,680 --> 00:57:29,520
okay so functional programming

00:57:26,720 --> 00:57:31,520
is not meant to be stateless uh what

00:57:29,520 --> 00:57:33,200
what do you mean by stateless i mean

00:57:31,520 --> 00:57:34,880
it has multiple meanings when you call

00:57:33,200 --> 00:57:37,440
stateless

00:57:34,880 --> 00:57:39,599
so what we have just seen is where

00:57:37,440 --> 00:57:40,079
objects are being passed on to different

00:57:39,599 --> 00:57:41,599
functions

00:57:40,079 --> 00:57:43,359
they are being transformed into

00:57:41,599 --> 00:57:44,960
different functions right so

00:57:43,359 --> 00:57:47,119
you should you be able to use fp

00:57:44,960 --> 00:57:49,359
wherever you have a use case wherein

00:57:47,119 --> 00:57:50,559
you transform data you transform state

00:57:49,359 --> 00:57:52,640
from one to another

00:57:50,559 --> 00:57:54,640
and again immutability is different

00:57:52,640 --> 00:57:56,400
where when you don't mutate the state

00:57:54,640 --> 00:57:59,280
but then you transform it

00:57:56,400 --> 00:57:59,839
so whenever you have chain of functions

00:57:59,280 --> 00:58:01,760
and you have

00:57:59,839 --> 00:58:03,839
objects that needs to be transformed

00:58:01,760 --> 00:58:06,000
like you have calculation engines

00:58:03,839 --> 00:58:07,680
or big data that's why fe is pretty

00:58:06,000 --> 00:58:10,160
popular in big data field where

00:58:07,680 --> 00:58:11,040
they have a lot of transformations so

00:58:10,160 --> 00:58:14,160
that's where in

00:58:11,040 --> 00:58:16,559
uh uh you should be able to find

00:58:14,160 --> 00:58:17,440
places wherein this state is being

00:58:16,559 --> 00:58:20,160
handled but

00:58:17,440 --> 00:58:22,480
i wouldn't say fp is stateless uh if

00:58:20,160 --> 00:58:24,799
you're talking about uh

00:58:22,480 --> 00:58:26,319
side effects uh what i mean is uh

00:58:24,799 --> 00:58:28,960
talking to db etc

00:58:26,319 --> 00:58:30,319
that has a state uh that's a different

00:58:28,960 --> 00:58:33,599
concept uh um

00:58:30,319 --> 00:58:34,799
i hope i i know i kind of didn't answer

00:58:33,599 --> 00:58:36,559
your questions right but then we should

00:58:34,799 --> 00:58:38,640
be able to kind of

00:58:36,559 --> 00:58:40,960
have a chat and understand more because

00:58:38,640 --> 00:58:43,280
this is a deeper question

00:58:40,960 --> 00:58:44,319
or you can speak up if you have uh if

00:58:43,280 --> 00:58:46,400
the if you're

00:58:44,319 --> 00:58:48,799
still on the call help me understand

00:58:46,400 --> 00:58:51,280
what you mean by stateless

00:58:48,799 --> 00:58:52,240
yeah you can raise your hand and we can

00:58:51,280 --> 00:58:56,160
take you off of me

00:58:52,240 --> 00:58:58,000
if you would like um there's another

00:58:56,160 --> 00:58:59,599
reference to are there any recommended

00:58:58,000 --> 00:59:01,119
forms and slacks that you would

00:58:59,599 --> 00:59:02,799
that would be good for functional

00:59:01,119 --> 00:59:04,720
newbies yeah i answered that like

00:59:02,799 --> 00:59:07,040
you should be able to join kotlin

00:59:04,720 --> 00:59:09,599
channel and cotton workspace

00:59:07,040 --> 00:59:11,440
invite is open to everybody and there is

00:59:09,599 --> 00:59:14,000
arrow channel i would recommend

00:59:11,440 --> 00:59:15,760
and then even on getter there is a vavr

00:59:14,000 --> 00:59:17,920
channel that's for java and again

00:59:15,760 --> 00:59:19,280
people are equally supportive and you

00:59:17,920 --> 00:59:21,359
can keep asking questions

00:59:19,280 --> 00:59:22,400
that's how you and i started you start

00:59:21,359 --> 00:59:24,720
pick a library

00:59:22,400 --> 00:59:26,720
which talks about these principles keep

00:59:24,720 --> 00:59:28,480
uh you know experimenting with that and

00:59:26,720 --> 00:59:30,839
then keep asking questions in the slack

00:59:28,480 --> 00:59:33,760
channels and people will

00:59:30,839 --> 00:59:35,359
answer all right one person wants you to

00:59:33,760 --> 00:59:37,599
go back to the slide with the links to

00:59:35,359 --> 00:59:40,079
your talk

00:59:37,599 --> 00:59:40,960
yeah i've shared that in the slide deck

00:59:40,079 --> 00:59:44,559
and the video

00:59:40,960 --> 00:59:46,799
and uh i hope you have some forum to

00:59:44,559 --> 00:59:48,480
keep those links right

00:59:46,799 --> 01:00:00,960
or you can take a screenshot if you want

00:59:48,480 --> 01:00:05,040
i'll share it once again

01:00:00,960 --> 01:00:06,880
yep here's one there you go awesome

01:00:05,040 --> 01:00:08,240
and can you please uh well that's the

01:00:06,880 --> 01:00:08,960
same one can you please post a link to

01:00:08,240 --> 01:00:11,119
your slide

01:00:08,960 --> 01:00:12,319
in your email address again okay they

01:00:11,119 --> 01:00:15,839
would like to connect with you

01:00:12,319 --> 01:00:15,839
offline yeah

01:00:15,920 --> 01:00:23,599
great and that's it from the q a

01:00:20,240 --> 01:00:24,240
awesome thanks a lot ato once again and

01:00:23,599 --> 01:00:26,799
thanks

01:00:24,240 --> 01:00:28,000
everyone for attending taking your time

01:00:26,799 --> 01:00:36,079
hope i made your time

01:00:28,000 --> 01:00:36,079

YouTube URL: https://www.youtube.com/watch?v=Dvr6gx4XaD8


