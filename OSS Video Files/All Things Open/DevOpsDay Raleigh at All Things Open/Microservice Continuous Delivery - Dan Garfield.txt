Title: Microservice Continuous Delivery - Dan Garfield
Publication date: 2020-12-03
Playlist: DevOpsDay Raleigh at All Things Open
Description: 
	Presented by: Dan Garfield, Codefresh
Presented at All Things Open 2020, DevOpsDay Raleigh

Abstract: Delivering complex microservice applications that rely on lots of interconnected services is a lot easier than it used to be. Thanks to Kubernetes and Helm, we can drastically reduce the barriers to continuous delivery. In this talk, we’ll show how real teams bring all the pieces together to build software faster and deliver higher quality code at scale. 

Using these real strategies, teams have been reducing their mean time to recover (MTTR), change lead time, change failure rates and improving their own mental health. We’ll marry Shift Left, GitOps, CI, and CD together for a comprehensive strategy.
Captions: 
	00:00:05,040 --> 00:00:08,720
we're going to jump right into it uh

00:00:06,560 --> 00:00:10,719
as always feel free to ask questions in

00:00:08,720 --> 00:00:12,080
in the zoom i will be monitoring that as

00:00:10,719 --> 00:00:14,240
we go

00:00:12,080 --> 00:00:15,920
and uh so feel free to interrupt me and

00:00:14,240 --> 00:00:16,400
and just shout out questions as we got

00:00:15,920 --> 00:00:17,520
them

00:00:16,400 --> 00:00:19,359
and we'll get into it we're going to

00:00:17,520 --> 00:00:21,119
talk about ci cd pipelines for micro

00:00:19,359 --> 00:00:22,560
services and best practices that we've

00:00:21,119 --> 00:00:25,039
learned

00:00:22,560 --> 00:00:26,720
so first off to introduce myself my name

00:00:25,039 --> 00:00:29,119
is dan garfield i am the chief

00:00:26,720 --> 00:00:31,279
technology evangelist for code fresh

00:00:29,119 --> 00:00:32,399
you can find me on twitter at today was

00:00:31,279 --> 00:00:33,360
awesome

00:00:32,399 --> 00:00:36,239
where i mostly just talk about

00:00:33,360 --> 00:00:38,320
kubernetes and microservices and

00:00:36,239 --> 00:00:40,719
my home built cluster and stuff like

00:00:38,320 --> 00:00:42,160
that i'm a google cloud developer expert

00:00:40,719 --> 00:00:43,600
focused on cloud i'm also a member of

00:00:42,160 --> 00:00:44,000
the forbes technology council i guess

00:00:43,600 --> 00:00:45,840
that

00:00:44,000 --> 00:00:48,160
badge is actually out of date it's 2020

00:00:45,840 --> 00:00:50,079
now not 2018. so

00:00:48,160 --> 00:00:51,280
but uh but that's that's what i that's

00:00:50,079 --> 00:00:52,559
who i am what i do

00:00:51,280 --> 00:00:55,280
um we're going to talk about a little

00:00:52,559 --> 00:00:58,480
bit of a case study that i did with

00:00:55,280 --> 00:01:01,440
an old teammate of mine around expedia's

00:00:58,480 --> 00:01:03,840
journey to microservices and then how we

00:01:01,440 --> 00:01:05,760
do it at code fresh as well

00:01:03,840 --> 00:01:07,520
so first of all to explain why

00:01:05,760 --> 00:01:08,799
microservices i have an analogy that i

00:01:07,520 --> 00:01:09,280
like to use i don't know if it's totally

00:01:08,799 --> 00:01:10,799
helpful

00:01:09,280 --> 00:01:12,640
at this point maybe everybody totally

00:01:10,799 --> 00:01:13,760
gets it if it's boring shout out in the

00:01:12,640 --> 00:01:17,280
chat that it's boring but

00:01:13,760 --> 00:01:20,479
uh i really love space travel

00:01:17,280 --> 00:01:20,960
and i love the stories of the space race

00:01:20,479 --> 00:01:22,960
and

00:01:20,960 --> 00:01:25,680
getting to the moon and everything and

00:01:22,960 --> 00:01:26,560
any space nerd knows that this is a

00:01:25,680 --> 00:01:28,799
picture

00:01:26,560 --> 00:01:30,960
of apollo 13. what you can see they're

00:01:28,799 --> 00:01:33,520
essentially two different ships

00:01:30,960 --> 00:01:34,720
there is the lunar module which is on

00:01:33,520 --> 00:01:35,040
the left hand side that's what they're

00:01:34,720 --> 00:01:36,960
going to

00:01:35,040 --> 00:01:38,560
use to land on the moon and then there's

00:01:36,960 --> 00:01:40,000
the command module which is on the right

00:01:38,560 --> 00:01:43,600
hand side and as you can see the command

00:01:40,000 --> 00:01:44,720
module has exploded and it's not going

00:01:43,600 --> 00:01:47,759
to work well

00:01:44,720 --> 00:01:51,520
anymore and when this happened uh

00:01:47,759 --> 00:01:53,360
the the people on board had lost most of

00:01:51,520 --> 00:01:54,000
their oxygen and they had to find a way

00:01:53,360 --> 00:01:55,680
to turn

00:01:54,000 --> 00:01:57,439
the lunar module which is meant to hold

00:01:55,680 --> 00:02:00,560
people for a few hours

00:01:57,439 --> 00:02:03,680
into their home for a matter of uh

00:02:00,560 --> 00:02:05,600
of a week or so so um i actually like

00:02:03,680 --> 00:02:07,040
this example because you can think about

00:02:05,600 --> 00:02:10,160
these as essentially two

00:02:07,040 --> 00:02:13,200
monoliths um each one is completely

00:02:10,160 --> 00:02:16,000
self-contained it has all of its own

00:02:13,200 --> 00:02:16,959
systems its own life support systems etc

00:02:16,000 --> 00:02:20,000
and

00:02:16,959 --> 00:02:22,319
uh i like this for you for for there's

00:02:20,000 --> 00:02:23,920
for explaining microservices because

00:02:22,319 --> 00:02:26,000
there's this moment where

00:02:23,920 --> 00:02:27,200
after where they realize that these two

00:02:26,000 --> 00:02:29,760
different monoliths

00:02:27,200 --> 00:02:30,560
use two completely different uh sized

00:02:29,760 --> 00:02:34,000
oxygen

00:02:30,560 --> 00:02:35,360
carbon uh filters and they need these to

00:02:34,000 --> 00:02:36,000
get rid of the carbon dioxide that

00:02:35,360 --> 00:02:38,640
they're breathing

00:02:36,000 --> 00:02:40,000
out in order to not die and so there's

00:02:38,640 --> 00:02:41,599
this great moment in the film

00:02:40,000 --> 00:02:43,760
apollo 13 when they say we need to make

00:02:41,599 --> 00:02:44,879
this fit into this using only the stuff

00:02:43,760 --> 00:02:45,920
that's on the spacecraft and they have

00:02:44,879 --> 00:02:46,800
to figure out how to do it and teach

00:02:45,920 --> 00:02:48,640
them how to do it

00:02:46,800 --> 00:02:50,000
so they can stay alive and i like this

00:02:48,640 --> 00:02:52,640
example as monoliths because

00:02:50,000 --> 00:02:53,599
i feel like if they had a micro service

00:02:52,640 --> 00:02:55,200
based approach

00:02:53,599 --> 00:02:56,879
you know these and of course this is

00:02:55,200 --> 00:02:59,200
what they did later is they were like oh

00:02:56,879 --> 00:03:01,280
we should think of oxygen as a service

00:02:59,200 --> 00:03:02,959
and uh it's gonna work in a universal

00:03:01,280 --> 00:03:04,720
way so all our filters are gonna work no

00:03:02,959 --> 00:03:06,239
matter what you know uh

00:03:04,720 --> 00:03:08,800
monolith that they're plugged into so

00:03:06,239 --> 00:03:10,480
this is kind of a a fun example of

00:03:08,800 --> 00:03:12,159
of microservices and it shows that you

00:03:10,480 --> 00:03:13,360
can create things one time and use them

00:03:12,159 --> 00:03:16,879
over and over again

00:03:13,360 --> 00:03:19,760
um and that's really valuable right so

00:03:16,879 --> 00:03:21,840
um that's my that's my brief example or

00:03:19,760 --> 00:03:23,519
analogy about why microservices

00:03:21,840 --> 00:03:25,040
uh most people you know kind of

00:03:23,519 --> 00:03:26,959
understand the value of microservices of

00:03:25,040 --> 00:03:28,720
course it allows you to scale as well

00:03:26,959 --> 00:03:30,080
a few years ago expedia went through

00:03:28,720 --> 00:03:32,319
this process where

00:03:30,080 --> 00:03:33,760
they had multiple monoliths and this

00:03:32,319 --> 00:03:34,560
happened because they'd acquired several

00:03:33,760 --> 00:03:38,720
companies

00:03:34,560 --> 00:03:41,200
they were they had cars different cars

00:03:38,720 --> 00:03:43,040
services that they had acquired and they

00:03:41,200 --> 00:03:44,879
had completely different model lists

00:03:43,040 --> 00:03:46,959
different uis different ux's different

00:03:44,879 --> 00:03:48,080
databases and so they went through a big

00:03:46,959 --> 00:03:51,040
re-architecture

00:03:48,080 --> 00:03:52,239
to make all of these uh into a group of

00:03:51,040 --> 00:03:54,400
microservices

00:03:52,239 --> 00:03:55,599
that they could use across their entire

00:03:54,400 --> 00:03:58,239
platform

00:03:55,599 --> 00:03:59,360
and that was the goal right now anybody

00:03:58,239 --> 00:04:00,640
that's done this kind of work before

00:03:59,360 --> 00:04:03,680
knows that it's uh

00:04:00,640 --> 00:04:06,239
it's fairly complex to achieve

00:04:03,680 --> 00:04:07,360
um but this is the the experience that

00:04:06,239 --> 00:04:08,799
they had

00:04:07,360 --> 00:04:10,640
first of all they decided they wanted to

00:04:08,799 --> 00:04:12,720
consolidate all those code bases

00:04:10,640 --> 00:04:14,080
they wanted to build shared libraries

00:04:12,720 --> 00:04:16,239
for global platforms

00:04:14,080 --> 00:04:17,759
and shared libraries are fairly common

00:04:16,239 --> 00:04:18,799
kind of approach to this thing because

00:04:17,759 --> 00:04:20,320
it feels more

00:04:18,799 --> 00:04:22,560
micro servicing but we'll get into

00:04:20,320 --> 00:04:24,400
issues with that

00:04:22,560 --> 00:04:26,080
and then they wanted to rely on manual

00:04:24,400 --> 00:04:27,919
integration testing

00:04:26,080 --> 00:04:29,759
which turned out to be a big problem

00:04:27,919 --> 00:04:31,680
because once you've split up into lots

00:04:29,759 --> 00:04:34,720
of micro services you've created

00:04:31,680 --> 00:04:36,639
a lot more uh a lot more

00:04:34,720 --> 00:04:38,400
areas you know attack surface if you

00:04:36,639 --> 00:04:40,080
will to test

00:04:38,400 --> 00:04:41,280
they did want to standardize their ci cd

00:04:40,080 --> 00:04:42,400
pipeline and they wanted to use maven

00:04:41,280 --> 00:04:44,080
for modularity

00:04:42,400 --> 00:04:45,440
but there were a lot of issues with this

00:04:44,080 --> 00:04:46,880
approach because one

00:04:45,440 --> 00:04:48,479
all the teams were geographically

00:04:46,880 --> 00:04:49,360
distributed so it was just difficult to

00:04:48,479 --> 00:04:50,720
get everybody

00:04:49,360 --> 00:04:52,479
you know on the same page it was

00:04:50,720 --> 00:04:54,240
difficult to get everybody to say

00:04:52,479 --> 00:04:55,919
to pick the same tools everybody knows

00:04:54,240 --> 00:04:57,520
that organizational inertia is one of

00:04:55,919 --> 00:04:59,199
the biggest challenges you have

00:04:57,520 --> 00:05:00,639
and they ended up with way too many

00:04:59,199 --> 00:05:01,840
pipelines instead of having 100

00:05:00,639 --> 00:05:04,320
pipelines they had

00:05:01,840 --> 00:05:05,919
thousand plus pipelines all of a sudden

00:05:04,320 --> 00:05:07,280
to try to manage

00:05:05,919 --> 00:05:09,280
for all these different micro services

00:05:07,280 --> 00:05:11,120
they were creating and of course those

00:05:09,280 --> 00:05:12,400
pipelines were not modular or reusable

00:05:11,120 --> 00:05:13,840
so every time somebody wanted to change

00:05:12,400 --> 00:05:15,360
something it meant going and updating

00:05:13,840 --> 00:05:16,400
you know a thousand pipelines

00:05:15,360 --> 00:05:18,720
um and we're going to get into these

00:05:16,400 --> 00:05:20,240
issues more specifically of course they

00:05:18,720 --> 00:05:21,840
were using jenkins so they said they had

00:05:20,240 --> 00:05:23,280
a lot of master slave issues

00:05:21,840 --> 00:05:25,840
um and then they had a lot of copy and

00:05:23,280 --> 00:05:28,000
paste going on uh as this process

00:05:25,840 --> 00:05:28,880
started um so jumping right into the

00:05:28,000 --> 00:05:30,880
micro services

00:05:28,880 --> 00:05:32,000
i think there was a big understanding

00:05:30,880 --> 00:05:33,919
about the value of

00:05:32,000 --> 00:05:35,039
microservices from an architectural

00:05:33,919 --> 00:05:38,560
standpoint

00:05:35,039 --> 00:05:39,360
but there was there was definitely a lot

00:05:38,560 --> 00:05:41,440
to be learned

00:05:39,360 --> 00:05:45,600
in terms of how microservices work

00:05:41,440 --> 00:05:48,960
within a development context

00:05:45,600 --> 00:05:50,960
so one of the things they learned is

00:05:48,960 --> 00:05:52,400
that they should have prioritized the ci

00:05:50,960 --> 00:05:54,160
cd and development process

00:05:52,400 --> 00:05:56,400
much higher because that ultimately

00:05:54,160 --> 00:05:58,080
became the biggest bottleneck

00:05:56,400 --> 00:06:00,000
once they once they kind of had

00:05:58,080 --> 00:06:03,039
re-architected

00:06:00,000 --> 00:06:05,759
and they needed to find a

00:06:03,039 --> 00:06:07,360
an easier way to bootstrap new projects

00:06:05,759 --> 00:06:09,120
and they needed to find a way to do more

00:06:07,360 --> 00:06:10,000
reusability so these are a lot of

00:06:09,120 --> 00:06:13,280
learnings from

00:06:10,000 --> 00:06:16,160
some kind of deep in the trenches

00:06:13,280 --> 00:06:17,199
panes of if you go from a couple of

00:06:16,160 --> 00:06:19,360
monoliths to

00:06:17,199 --> 00:06:20,560
hundreds or thousands of microservices

00:06:19,360 --> 00:06:21,759
how do you approach it

00:06:20,560 --> 00:06:23,680
so we're actually going to go through

00:06:21,759 --> 00:06:25,280
these more granularly and

00:06:23,680 --> 00:06:26,560
this kind of goes into how we actually

00:06:25,280 --> 00:06:28,160
do this internally at code fresh because

00:06:26,560 --> 00:06:31,520
we have a complex micro service

00:06:28,160 --> 00:06:34,479
stack so first of all

00:06:31,520 --> 00:06:35,759
when you organize pipelines for a

00:06:34,479 --> 00:06:37,440
monolithic application

00:06:35,759 --> 00:06:40,080
traditionally what you have and this is

00:06:37,440 --> 00:06:44,240
the traditional view is you do

00:06:40,080 --> 00:06:46,720
one project one pipeline one repo

00:06:44,240 --> 00:06:48,479
and this makes perfect sense right you

00:06:46,720 --> 00:06:51,840
have a a

00:06:48,479 --> 00:06:54,080
a pipeline for every repo and each each

00:06:51,840 --> 00:06:56,080
application has its own repo

00:06:54,080 --> 00:06:57,280
and that works great now the issue with

00:06:56,080 --> 00:07:00,319
that of course is that

00:06:57,280 --> 00:07:01,599
what if you have uh if you have you know

00:07:00,319 --> 00:07:02,560
a monolithic application that's fine you

00:07:01,599 --> 00:07:03,520
don't have that many repos you don't

00:07:02,560 --> 00:07:04,960
have that many apps

00:07:03,520 --> 00:07:07,039
but if you take that app and you split

00:07:04,960 --> 00:07:09,680
it into 500 microservices

00:07:07,039 --> 00:07:11,120
now you have to maintain 500 pipelines

00:07:09,680 --> 00:07:13,840
now you have to maintain

00:07:11,120 --> 00:07:14,240
500 different git repos and this can be

00:07:13,840 --> 00:07:17,520
really

00:07:14,240 --> 00:07:20,319
complex to manage

00:07:17,520 --> 00:07:22,479
and this this is also usually led by a

00:07:20,319 --> 00:07:23,599
single team which is very anti-devops

00:07:22,479 --> 00:07:25,599
the whole purpose of this

00:07:23,599 --> 00:07:27,039
is to put more power into the hands of

00:07:25,599 --> 00:07:28,080
the developers so they can take more of

00:07:27,039 --> 00:07:30,319
the process

00:07:28,080 --> 00:07:31,680
um and have more control over what's

00:07:30,319 --> 00:07:33,680
being deployed what's being tested

00:07:31,680 --> 00:07:36,240
what's being built what's being released

00:07:33,680 --> 00:07:37,599
um so you can see there's a clear issue

00:07:36,240 --> 00:07:38,960
of scalability if you take

00:07:37,599 --> 00:07:40,800
all of these different repos and each

00:07:38,960 --> 00:07:42,560
one splits into potentially four

00:07:40,800 --> 00:07:42,960
different microservices you end up with

00:07:42,560 --> 00:07:46,319
a

00:07:42,960 --> 00:07:48,000
ton of repos and a ton of pipelines

00:07:46,319 --> 00:07:50,400
so this does not feel like a very good

00:07:48,000 --> 00:07:52,319
plan of course if you look at the

00:07:50,400 --> 00:07:53,919
largest companies microsoft and google

00:07:52,319 --> 00:07:55,440
both do monorepo

00:07:53,919 --> 00:07:57,039
though at a scale that is sort of

00:07:55,440 --> 00:07:58,560
mind-boggling i'm not necessarily

00:07:57,039 --> 00:08:01,360
recommending that right off the bat but

00:07:58,560 --> 00:08:02,960
um but there are some big advantages to

00:08:01,360 --> 00:08:04,240
starting to get into something like that

00:08:02,960 --> 00:08:05,680
this isn't a talk advocating for

00:08:04,240 --> 00:08:08,720
monorepo but it's more

00:08:05,680 --> 00:08:09,680
uh but but that is um one potential

00:08:08,720 --> 00:08:13,280
avenue to help

00:08:09,680 --> 00:08:15,680
one one potential tool um the other

00:08:13,280 --> 00:08:16,560
the issue here as well is that shared

00:08:15,680 --> 00:08:19,440
libraries

00:08:16,560 --> 00:08:20,960
is not a solution so uh there's a big

00:08:19,440 --> 00:08:22,720
thought that it's like okay well

00:08:20,960 --> 00:08:24,319
we have to make a ton of pipelines and

00:08:22,720 --> 00:08:26,879
what we'll do is we'll create

00:08:24,319 --> 00:08:27,680
a bunch of shared libraries so we can

00:08:26,879 --> 00:08:30,319
use these

00:08:27,680 --> 00:08:31,599
pipeline segments in all these different

00:08:30,319 --> 00:08:32,719
pipelines and so we can construct

00:08:31,599 --> 00:08:33,839
pipelines from all these different

00:08:32,719 --> 00:08:37,200
shared libraries

00:08:33,839 --> 00:08:39,120
and this will work well and

00:08:37,200 --> 00:08:40,560
if anybody who has experience doing this

00:08:39,120 --> 00:08:42,800
knows that this is actually

00:08:40,560 --> 00:08:43,599
not a great solution because these

00:08:42,800 --> 00:08:46,720
libraries

00:08:43,599 --> 00:08:49,680
rely on each other in very complex ways

00:08:46,720 --> 00:08:50,399
so first of all this requires everyone

00:08:49,680 --> 00:08:53,519
to use

00:08:50,399 --> 00:08:55,760
the same version of these libraries

00:08:53,519 --> 00:08:57,839
and it re it requires them all to use

00:08:55,760 --> 00:08:58,880
the same underlying software so for

00:08:57,839 --> 00:09:02,880
example if

00:08:58,880 --> 00:09:05,920
library a is using one version of

00:09:02,880 --> 00:09:07,120
uh i don't know java library b has to

00:09:05,920 --> 00:09:08,480
use that as well because when they're

00:09:07,120 --> 00:09:09,440
going to execute in a pipeline they're

00:09:08,480 --> 00:09:10,959
going to execute

00:09:09,440 --> 00:09:12,399
inside of a shared vm kind of

00:09:10,959 --> 00:09:13,279
environment so this this creates a lot

00:09:12,399 --> 00:09:15,760
of conflicts

00:09:13,279 --> 00:09:17,519
um and and if you've ever experienced

00:09:15,760 --> 00:09:18,160
like uh i want to upgrade a jenkins

00:09:17,519 --> 00:09:20,160
plug-in

00:09:18,160 --> 00:09:21,440
you've run into this issue right you've

00:09:20,160 --> 00:09:22,000
noticed that all of a sudden these

00:09:21,440 --> 00:09:24,560
things

00:09:22,000 --> 00:09:26,320
start behaving in very abnormal ways and

00:09:24,560 --> 00:09:27,680
a lot of things start breaking

00:09:26,320 --> 00:09:29,760
so they rely on each other in very

00:09:27,680 --> 00:09:31,839
complex ways and then it also means that

00:09:29,760 --> 00:09:33,120
any changes to those shared libraries

00:09:31,839 --> 00:09:35,200
have to go to admins

00:09:33,120 --> 00:09:36,800
so people can't necessarily self-serve

00:09:35,200 --> 00:09:38,640
the components or tools they need

00:09:36,800 --> 00:09:40,160
and if they do want to change versions

00:09:38,640 --> 00:09:41,519
of something of course they have to

00:09:40,160 --> 00:09:43,279
talk to an admin and say hey i want to

00:09:41,519 --> 00:09:44,880
change the version i have to you know

00:09:43,279 --> 00:09:46,080
the my application i'm using i need to

00:09:44,880 --> 00:09:47,680
use this version

00:09:46,080 --> 00:09:49,200
the underlying software is using this

00:09:47,680 --> 00:09:50,399
version we need to reconcile those

00:09:49,200 --> 00:09:51,920
things and now all of a sudden instead

00:09:50,399 --> 00:09:53,600
of a conversation between you and just

00:09:51,920 --> 00:09:55,120
the admins there's five other teams

00:09:53,600 --> 00:09:56,959
using different shared libraries

00:09:55,120 --> 00:09:59,040
that all will have to upgrade as well so

00:09:56,959 --> 00:09:59,760
this becomes you know a nightmare to

00:09:59,040 --> 00:10:01,519
manage

00:09:59,760 --> 00:10:03,519
so it becomes a big stability problem

00:10:01,519 --> 00:10:05,760
and of course it also usually relies on

00:10:03,519 --> 00:10:07,440
a proprietary api so it's not

00:10:05,760 --> 00:10:09,920
it's not something you can just build

00:10:07,440 --> 00:10:11,279
and use uh anywhere it's not agnostic

00:10:09,920 --> 00:10:13,920
right

00:10:11,279 --> 00:10:15,440
so um i'm gonna get into how we actually

00:10:13,920 --> 00:10:18,320
approach this internally at code fresh

00:10:15,440 --> 00:10:20,720
we have a complex micro service stack

00:10:18,320 --> 00:10:22,320
and we essentially have three things

00:10:20,720 --> 00:10:24,160
that we've really learned have been

00:10:22,320 --> 00:10:27,040
battle tested tried and true that work

00:10:24,160 --> 00:10:29,600
really well container based pipelines

00:10:27,040 --> 00:10:31,200
shared pipelines and deployment testing

00:10:29,600 --> 00:10:34,000
make a huge difference

00:10:31,200 --> 00:10:35,360
when you're doing csv for microservices

00:10:34,000 --> 00:10:37,680
so first of all here's our

00:10:35,360 --> 00:10:38,800
here's our uh architecture this is a

00:10:37,680 --> 00:10:40,560
little bit out of date

00:10:38,800 --> 00:10:42,160
but what you can see is that we have to

00:10:40,560 --> 00:10:44,399
support uh

00:10:42,160 --> 00:10:45,440
our kind of position as a ci cd platform

00:10:44,399 --> 00:10:47,680
is that we are git

00:10:45,440 --> 00:10:49,600
and cloud agnostic so we're going to

00:10:47,680 --> 00:10:51,040
work really well with any git provider

00:10:49,600 --> 00:10:51,920
we're going to work really well with any

00:10:51,040 --> 00:10:53,519
cloud provider

00:10:51,920 --> 00:10:55,760
and of course we have to integrate with

00:10:53,519 --> 00:10:58,959
every single testing tool

00:10:55,760 --> 00:11:00,320
security tool in between and monitoring

00:10:58,959 --> 00:11:00,959
solutions so that everything works

00:11:00,320 --> 00:11:03,200
smoothly

00:11:00,959 --> 00:11:04,880
so that's a complex stack we've got a

00:11:03,200 --> 00:11:06,160
ton of different micro services

00:11:04,880 --> 00:11:07,760
a few dozen different micro services

00:11:06,160 --> 00:11:10,240
we're using to do that we have dozens of

00:11:07,760 --> 00:11:12,399
different runtimes we need to support

00:11:10,240 --> 00:11:14,560
we also have like an on-prem version of

00:11:12,399 --> 00:11:15,519
code fresh we have a code fresh runner

00:11:14,560 --> 00:11:18,079
which is like a

00:11:15,519 --> 00:11:18,640
zero trust deploy it on your own cluster

00:11:18,079 --> 00:11:21,040
and

00:11:18,640 --> 00:11:22,160
and run builds and pipelines as much as

00:11:21,040 --> 00:11:23,839
you want

00:11:22,160 --> 00:11:25,920
uh kind of model in addition to the sas

00:11:23,839 --> 00:11:26,959
model so this this means we have a lot

00:11:25,920 --> 00:11:28,560
of different

00:11:26,959 --> 00:11:30,480
variability that we have to be able to

00:11:28,560 --> 00:11:33,920
support so

00:11:30,480 --> 00:11:36,959
our approach to building microservices

00:11:33,920 --> 00:11:37,680
uh it takes this into account so first

00:11:36,959 --> 00:11:39,040
off

00:11:37,680 --> 00:11:40,720
one of the things we do is we do

00:11:39,040 --> 00:11:42,320
container-based pipelines so this has

00:11:40,720 --> 00:11:42,800
gotten very popular in the last few

00:11:42,320 --> 00:11:43,839
years

00:11:42,800 --> 00:11:47,120
if you haven't heard of using

00:11:43,839 --> 00:11:47,120
container-based pipelines

00:11:47,519 --> 00:11:52,000
it might be a bit of a shock i suppose

00:11:49,279 --> 00:11:55,120
but basically the idea is that

00:11:52,000 --> 00:11:57,600
every single step within the pipeline

00:11:55,120 --> 00:11:58,240
should be its own container it should be

00:11:57,600 --> 00:12:00,160
its own

00:11:58,240 --> 00:12:01,279
image now what does that mean it means

00:12:00,160 --> 00:12:04,160
that those

00:12:01,279 --> 00:12:04,720
images those steps do not rely on each

00:12:04,160 --> 00:12:07,760
other

00:12:04,720 --> 00:12:08,160
i can have one version of java in one

00:12:07,760 --> 00:12:10,079
step

00:12:08,160 --> 00:12:11,200
and another version and another step and

00:12:10,079 --> 00:12:13,600
they are not going to

00:12:11,200 --> 00:12:15,920
interact with each other in any way and

00:12:13,600 --> 00:12:18,000
this this actually allows you

00:12:15,920 --> 00:12:19,360
uh in a certain sense it allows you to

00:12:18,000 --> 00:12:21,519
think of almost every step as a

00:12:19,360 --> 00:12:23,519
microservice if you will

00:12:21,519 --> 00:12:25,200
but what we what you have is is

00:12:23,519 --> 00:12:28,000
basically building blocks

00:12:25,200 --> 00:12:29,760
and these images don't rely on any

00:12:28,000 --> 00:12:31,680
proprietary api

00:12:29,760 --> 00:12:33,120
these can be any language you can write

00:12:31,680 --> 00:12:33,760
them in any language you're comfortable

00:12:33,120 --> 00:12:35,519
with

00:12:33,760 --> 00:12:36,800
and they can do whatever job that they

00:12:35,519 --> 00:12:38,079
need to do

00:12:36,800 --> 00:12:39,920
and of course people can self-serve

00:12:38,079 --> 00:12:41,120
these there's hundreds of thousands of

00:12:39,920 --> 00:12:42,560
different docker images out there

00:12:41,120 --> 00:12:44,480
publicly available that you can take and

00:12:42,560 --> 00:12:46,639
grab and use for different jobs

00:12:44,480 --> 00:12:48,800
and building docker images is like

00:12:46,639 --> 00:12:50,240
wicked easy it's very very simple

00:12:48,800 --> 00:12:51,760
um so the way that we analyze this

00:12:50,240 --> 00:12:52,639
inside of code fresh is we actually

00:12:51,760 --> 00:12:55,600
create

00:12:52,639 --> 00:12:56,800
on the pipeline a shared volume now the

00:12:55,600 --> 00:12:58,399
way you handle the shared volume is

00:12:56,800 --> 00:13:00,880
pretty important

00:12:58,399 --> 00:13:01,839
what we do is essentially that shared

00:13:00,880 --> 00:13:04,480
volume lives

00:13:01,839 --> 00:13:05,040
on the local ssd for the build node but

00:13:04,480 --> 00:13:07,360
it is

00:13:05,040 --> 00:13:08,800
also cached and refreshed no matter

00:13:07,360 --> 00:13:09,600
where the pipeline execution is

00:13:08,800 --> 00:13:12,000
happening

00:13:09,600 --> 00:13:13,519
uh so that means i have really high

00:13:12,000 --> 00:13:16,399
performance i o

00:13:13,519 --> 00:13:17,760
in between the steps but i also get all

00:13:16,399 --> 00:13:18,880
the benefits of caching

00:13:17,760 --> 00:13:21,040
without doing any additional

00:13:18,880 --> 00:13:22,320
configuration which is really killer so

00:13:21,040 --> 00:13:25,680
it basically means your pipelines are

00:13:22,320 --> 00:13:25,680
going to be super fast by default

00:13:26,240 --> 00:13:29,680
we have a huge open source library of

00:13:28,160 --> 00:13:32,240
steps that code fresh dot io

00:13:29,680 --> 00:13:34,639
steps these are all essentially docker

00:13:32,240 --> 00:13:37,440
images with a schema attached to them

00:13:34,639 --> 00:13:38,800
that you could take and use in really

00:13:37,440 --> 00:13:40,160
any platform

00:13:38,800 --> 00:13:41,519
these are of course designed for code

00:13:40,160 --> 00:13:43,360
fresh but you could take them and

00:13:41,519 --> 00:13:45,519
execute them locally

00:13:43,360 --> 00:13:47,440
to to use any of these steps yourself

00:13:45,519 --> 00:13:48,880
these are essentially just docker images

00:13:47,440 --> 00:13:50,079
and again they do have a schema that

00:13:48,880 --> 00:13:52,320
describes what they do and what their

00:13:50,079 --> 00:13:53,680
outputs are and that kind of thing but

00:13:52,320 --> 00:13:55,279
you could basically take these and run

00:13:53,680 --> 00:13:56,560
these locally to do any of the things

00:13:55,279 --> 00:13:58,000
you want to do

00:13:56,560 --> 00:13:59,920
and these are all open source all these

00:13:58,000 --> 00:14:01,600
steps are

00:13:59,920 --> 00:14:04,240
the other thing that we recommend is

00:14:01,600 --> 00:14:06,880
using a single pipeline that operates

00:14:04,240 --> 00:14:09,199
with a context so what this means is

00:14:06,880 --> 00:14:10,320
that rather than having one pipeline per

00:14:09,199 --> 00:14:14,480
repo

00:14:10,320 --> 00:14:17,040
i can create one pipeline and then

00:14:14,480 --> 00:14:18,959
each repository that i want to have

00:14:17,040 --> 00:14:22,160
execute with that pipeline

00:14:18,959 --> 00:14:24,560
will just have its own trigger

00:14:22,160 --> 00:14:26,320
so if repo a has a change that's a

00:14:24,560 --> 00:14:27,519
trigger if repo b has a change that's a

00:14:26,320 --> 00:14:30,959
different trigger right

00:14:27,519 --> 00:14:33,519
and those triggers come with the context

00:14:30,959 --> 00:14:35,120
of of where that application is being

00:14:33,519 --> 00:14:36,480
built from so it says hey this is the

00:14:35,120 --> 00:14:37,760
repo that's changing

00:14:36,480 --> 00:14:39,839
these are the changes that are being

00:14:37,760 --> 00:14:41,199
made all these things

00:14:39,839 --> 00:14:42,959
and they can bring more context to them

00:14:41,199 --> 00:14:44,320
they can even have descriptions about

00:14:42,959 --> 00:14:45,440
which deployment environments they're

00:14:44,320 --> 00:14:47,120
supposed to use they can have

00:14:45,440 --> 00:14:49,199
descriptions of what testing should be

00:14:47,120 --> 00:14:50,880
done so this means that you can

00:14:49,199 --> 00:14:54,240
basically create a pipeline

00:14:50,880 --> 00:14:57,600
that is contextually aware enough

00:14:54,240 --> 00:14:58,000
to operate hundreds or even thousands of

00:14:57,600 --> 00:15:01,440
different

00:14:58,000 --> 00:15:02,160
services so if i want to upgrade or make

00:15:01,440 --> 00:15:03,920
a change

00:15:02,160 --> 00:15:05,680
very simple i can i can make it right

00:15:03,920 --> 00:15:07,120
there if somebody wants to split this

00:15:05,680 --> 00:15:07,839
off and fork it and make their own

00:15:07,120 --> 00:15:09,360
version

00:15:07,839 --> 00:15:11,519
that's very easy too because again all

00:15:09,360 --> 00:15:12,079
of these steps are just docker images so

00:15:11,519 --> 00:15:14,000
i can

00:15:12,079 --> 00:15:15,760
i can actually take the pipeline

00:15:14,000 --> 00:15:17,279
replicate it and make

00:15:15,760 --> 00:15:20,000
additional changes if i don't want to

00:15:17,279 --> 00:15:21,440
use a centralized pipeline

00:15:20,000 --> 00:15:23,040
so this makes it very easy to work and

00:15:21,440 --> 00:15:23,760
so if you think about what's on your

00:15:23,040 --> 00:15:25,360
code base

00:15:23,760 --> 00:15:26,800
you have tests you might have a doctor

00:15:25,360 --> 00:15:28,560
composed you might have helm charts you

00:15:26,800 --> 00:15:30,800
might have dependencies all those things

00:15:28,560 --> 00:15:32,720
those all come with the trigger so once

00:15:30,800 --> 00:15:34,720
the trigger pushes

00:15:32,720 --> 00:15:36,480
and tells the pipeline to execute the

00:15:34,720 --> 00:15:37,120
pipeline has all the information it

00:15:36,480 --> 00:15:39,680
needs

00:15:37,120 --> 00:15:41,759
to do what is essentially a fairly

00:15:39,680 --> 00:15:43,120
flexible pipeline execution

00:15:41,759 --> 00:15:44,160
um it's going to build a docker image

00:15:43,120 --> 00:15:44,880
right it's going to build whatever

00:15:44,160 --> 00:15:46,800
docker image

00:15:44,880 --> 00:15:48,320
the code base tells it to maybe it's

00:15:46,800 --> 00:15:49,120
going to spin up a docker compose for

00:15:48,320 --> 00:15:50,800
running tests

00:15:49,120 --> 00:15:52,800
and it's going to spin up whatever

00:15:50,800 --> 00:15:54,959
composition is described and whatever

00:15:52,800 --> 00:15:56,560
tests are described within the repo

00:15:54,959 --> 00:15:58,639
so this means you can essentially write

00:15:56,560 --> 00:15:59,600
your automation once and then if you

00:15:58,639 --> 00:16:01,920
just follow the

00:15:59,600 --> 00:16:02,959
sort of you know syntax within all your

00:16:01,920 --> 00:16:05,360
other repos

00:16:02,959 --> 00:16:07,279
then you have a very straightforward

00:16:05,360 --> 00:16:09,199
simple way of executing

00:16:07,279 --> 00:16:11,120
uh pipelines for hundreds or thousands

00:16:09,199 --> 00:16:14,000
of microservices

00:16:11,120 --> 00:16:14,720
this is a very very scalable approach so

00:16:14,000 --> 00:16:16,560
i'm going to show you

00:16:14,720 --> 00:16:18,399
a very quick demo of how we do this in

00:16:16,560 --> 00:16:20,560
codefresh i can actually show you our

00:16:18,399 --> 00:16:23,199
internal ci process

00:16:20,560 --> 00:16:24,560
so um i'm going to go over into the code

00:16:23,199 --> 00:16:26,240
first platform here

00:16:24,560 --> 00:16:28,320
and you can see i'm actually looking

00:16:26,240 --> 00:16:29,279
into projects i'm looking at code fresh

00:16:28,320 --> 00:16:30,480
pipelines

00:16:29,279 --> 00:16:31,680
and you know we've got a bunch of

00:16:30,480 --> 00:16:33,440
pipelines in here but i'm going to show

00:16:31,680 --> 00:16:34,240
you the ci one we do have a cd one as

00:16:33,440 --> 00:16:37,199
well

00:16:34,240 --> 00:16:38,079
but within the ci pipeline and i'll

00:16:37,199 --> 00:16:39,360
actually show you one of these

00:16:38,079 --> 00:16:41,440
executions here

00:16:39,360 --> 00:16:42,800
um so here's the uh here you can see

00:16:41,440 --> 00:16:45,279
there's actually a build

00:16:42,800 --> 00:16:47,199
currently running looks like safie is uh

00:16:45,279 --> 00:16:47,839
getting a deployment going which is

00:16:47,199 --> 00:16:49,759
great

00:16:47,839 --> 00:16:52,240
love to see that let's look at the

00:16:49,759 --> 00:16:54,240
workflow really quick

00:16:52,240 --> 00:16:55,279
now this workflow is actually stored

00:16:54,240 --> 00:16:58,560
inside

00:16:55,279 --> 00:17:00,160
of a repo where we keep a number of

00:16:58,560 --> 00:17:01,600
different pipelines

00:17:00,160 --> 00:17:03,680
and so you can see that the yaml is

00:17:01,600 --> 00:17:05,839
defined here it's actually taken from

00:17:03,680 --> 00:17:07,679
that location now what you'll see on the

00:17:05,839 --> 00:17:09,039
left here is the definition of the

00:17:07,679 --> 00:17:10,319
pipeline you can see there are a number

00:17:09,039 --> 00:17:11,919
of different hooks

00:17:10,319 --> 00:17:13,439
there's different success criteria and

00:17:11,919 --> 00:17:16,400
then of course we get into the steps

00:17:13,439 --> 00:17:17,439
and you can see here where we're doing a

00:17:16,400 --> 00:17:20,640
um

00:17:17,439 --> 00:17:22,400
where we're actually cloning our uh repo

00:17:20,640 --> 00:17:24,799
we've hard-coded that it's always going

00:17:22,400 --> 00:17:28,480
to clone from our organization

00:17:24,799 --> 00:17:29,919
but then the repo name and the branch

00:17:28,480 --> 00:17:31,679
and and all the secrets and everything

00:17:29,919 --> 00:17:34,559
all of these are variable

00:17:31,679 --> 00:17:35,679
so depending on what trigger is pushing

00:17:34,559 --> 00:17:38,400
all of these

00:17:35,679 --> 00:17:39,919
will check out these essentially check

00:17:38,400 --> 00:17:41,280
out different repos based on that

00:17:39,919 --> 00:17:42,880
now on the right hand side you can see

00:17:41,280 --> 00:17:43,760
all of the different triggers that we

00:17:42,880 --> 00:17:45,200
have

00:17:43,760 --> 00:17:47,760
for all the different services that are

00:17:45,200 --> 00:17:50,160
running off of this ci pipeline so this

00:17:47,760 --> 00:17:52,799
allows us again we created one pipeline

00:17:50,160 --> 00:17:53,440
we have dozens of different ci services

00:17:52,799 --> 00:17:55,760
uh

00:17:53,440 --> 00:17:57,120
sorry dozens of different microservices

00:17:55,760 --> 00:17:59,520
that are actually triggering

00:17:57,120 --> 00:18:00,960
changes in here and of course we do

00:17:59,520 --> 00:18:01,520
support all the secrets and stuff like

00:18:00,960 --> 00:18:03,360
that

00:18:01,520 --> 00:18:05,039
and if we uh if we look at a build

00:18:03,360 --> 00:18:07,280
really quick

00:18:05,039 --> 00:18:10,320
um we can see what uh we can see what

00:18:07,280 --> 00:18:10,320
saffi's up to here

00:18:10,559 --> 00:18:15,360
um so you can see it's cloned our repo

00:18:13,520 --> 00:18:17,200
it's setting different variables

00:18:15,360 --> 00:18:19,120
um looks like he's got some validation

00:18:17,200 --> 00:18:20,240
version issues in this case this one

00:18:19,120 --> 00:18:22,960
does not create a pr

00:18:20,240 --> 00:18:24,320
because it has not passed that uh

00:18:22,960 --> 00:18:26,320
criteria

00:18:24,320 --> 00:18:28,320
installs some test dependencies running

00:18:26,320 --> 00:18:30,720
unit tests composition tasks

00:18:28,320 --> 00:18:32,240
looks like it uh oh at this point it's

00:18:30,720 --> 00:18:33,039
going to add some pull requests to image

00:18:32,240 --> 00:18:35,919
and richer

00:18:33,039 --> 00:18:37,840
but it looks like he didn't pass his

00:18:35,919 --> 00:18:38,880
security scan so his pipeline has been

00:18:37,840 --> 00:18:41,760
marked as failed

00:18:38,880 --> 00:18:42,960
so um that means he gets the feedback

00:18:41,760 --> 00:18:45,120
right away right that's just that's

00:18:42,960 --> 00:18:47,760
exactly what you want

00:18:45,120 --> 00:18:48,480
uh so essentially what we do is we have

00:18:47,760 --> 00:18:52,080
a big

00:18:48,480 --> 00:18:53,760
shared ci pipeline that executes for all

00:18:52,080 --> 00:18:56,559
the different services

00:18:53,760 --> 00:18:58,480
and then as part of that pipeline it

00:18:56,559 --> 00:18:59,679
actually creates a pull request onto a

00:18:58,480 --> 00:19:02,000
repository

00:18:59,679 --> 00:19:03,440
where it generates the manifests that

00:19:02,000 --> 00:19:05,520
are going into deployment

00:19:03,440 --> 00:19:06,640
and then that's managed by our cd

00:19:05,520 --> 00:19:08,640
pipeline

00:19:06,640 --> 00:19:11,280
so you'll see here is that all of these

00:19:08,640 --> 00:19:12,240
triggers are actually off of the same

00:19:11,280 --> 00:19:14,640
repo

00:19:12,240 --> 00:19:15,760
so you might be thinking wait how do i

00:19:14,640 --> 00:19:18,000
have multiple

00:19:15,760 --> 00:19:19,760
triggers for one repo well the answer is

00:19:18,000 --> 00:19:22,720
that each of these triggers

00:19:19,760 --> 00:19:25,840
has filters on it so each of these

00:19:22,720 --> 00:19:28,960
triggers basically has a filter

00:19:25,840 --> 00:19:31,039
that says uh only trigger when there are

00:19:28,960 --> 00:19:32,799
changes made to this subfolder so this

00:19:31,039 --> 00:19:34,240
is kind of the monorepo support

00:19:32,799 --> 00:19:36,480
and this is actually pretty important

00:19:34,240 --> 00:19:37,760
when you're doing get ops because get

00:19:36,480 --> 00:19:39,200
ops

00:19:37,760 --> 00:19:41,380
basically prescribes that your

00:19:39,200 --> 00:19:42,799
application and your infrastructure

00:19:41,380 --> 00:19:46,160
[Music]

00:19:42,799 --> 00:19:47,520
manifests should usually be separate

00:19:46,160 --> 00:19:49,280
this allows you to make changes to your

00:19:47,520 --> 00:19:51,200
application which then trigger the

00:19:49,280 --> 00:19:52,000
generation of manifests which are put

00:19:51,200 --> 00:19:53,760
into

00:19:52,000 --> 00:19:56,559
a separate repo reviewed in a separate

00:19:53,760 --> 00:19:59,360
pull request and allows you to

00:19:56,559 --> 00:20:01,039
continue the ci cd process so you can

00:19:59,360 --> 00:20:02,559
see these are all essentially working

00:20:01,039 --> 00:20:06,240
off of

00:20:02,559 --> 00:20:07,520
one chart repository one one git repo

00:20:06,240 --> 00:20:08,960
that has all our different home charts

00:20:07,520 --> 00:20:11,280
in it and we're basically

00:20:08,960 --> 00:20:12,000
generating and making changes to those

00:20:11,280 --> 00:20:13,440
charts

00:20:12,000 --> 00:20:15,840
which is then triggering the actual

00:20:13,440 --> 00:20:17,280
deployment into production

00:20:15,840 --> 00:20:19,280
so you can you can see how this would be

00:20:17,280 --> 00:20:20,880
a very scalable way to do this

00:20:19,280 --> 00:20:22,720
and of course we can support hundreds of

00:20:20,880 --> 00:20:26,799
thousands of microservices

00:20:22,720 --> 00:20:30,080
doing that one last note here

00:20:26,799 --> 00:20:31,679
is is about deployment verification so

00:20:30,080 --> 00:20:33,200
i don't know if any of you caught the

00:20:31,679 --> 00:20:36,559
last talk um

00:20:33,200 --> 00:20:37,840
that i sorry the speaker's name

00:20:36,559 --> 00:20:39,280
escapes me but she was speaking about

00:20:37,840 --> 00:20:40,799
istio and talking about doing canary

00:20:39,280 --> 00:20:42,320
releases and things like that

00:20:40,799 --> 00:20:44,640
one of the issues that happens with

00:20:42,320 --> 00:20:46,880
microservices is that

00:20:44,640 --> 00:20:48,080
as your infrastructure becomes more

00:20:46,880 --> 00:20:50,559
complex

00:20:48,080 --> 00:20:51,440
the usefulness of early testing goes

00:20:50,559 --> 00:20:54,159
down

00:20:51,440 --> 00:20:54,640
so in your when your application stack

00:20:54,159 --> 00:20:56,559
is

00:20:54,640 --> 00:20:58,320
you know three or four micro services

00:20:56,559 --> 00:21:00,320
you can throw those all into like a

00:20:58,320 --> 00:21:01,840
like a docker compose and actually spin

00:21:00,320 --> 00:21:02,799
it up as part of the pipeline run the

00:21:01,840 --> 00:21:05,440
whole thing

00:21:02,799 --> 00:21:07,440
and uh and basically excuse me actually

00:21:05,440 --> 00:21:08,720
burn it in and test it but

00:21:07,440 --> 00:21:10,240
when you have thousands of micro

00:21:08,720 --> 00:21:11,760
services and some of those are even

00:21:10,240 --> 00:21:14,080
external services like

00:21:11,760 --> 00:21:15,280
you know maybe the uh sales force api or

00:21:14,080 --> 00:21:18,159
whatever

00:21:15,280 --> 00:21:19,360
spinning up that entire stack for every

00:21:18,159 --> 00:21:22,000
single change

00:21:19,360 --> 00:21:23,679
starts to become less and less

00:21:22,000 --> 00:21:25,520
reasonable

00:21:23,679 --> 00:21:27,600
so what we do recommend is that you

00:21:25,520 --> 00:21:28,320
actually go with something like a canary

00:21:27,600 --> 00:21:30,480
deployment

00:21:28,320 --> 00:21:32,080
and of course a canary deployment will

00:21:30,480 --> 00:21:34,559
uh when you release something it will

00:21:32,080 --> 00:21:37,600
release a small change

00:21:34,559 --> 00:21:39,679
and uh and then test it and move up over

00:21:37,600 --> 00:21:41,200
and over until it's actually reached 100

00:21:39,679 --> 00:21:43,360
of the traffic that your customers

00:21:41,200 --> 00:21:44,640
are are doing and if at any point

00:21:43,360 --> 00:21:47,120
there's an issue

00:21:44,640 --> 00:21:48,000
it'll catch it block it and rebirth the

00:21:47,120 --> 00:21:49,520
change um

00:21:48,000 --> 00:21:51,120
and so this is something that we we

00:21:49,520 --> 00:21:53,360
advocate pretty heavily

00:21:51,120 --> 00:21:54,240
there's a pretty good talk about this uh

00:21:53,360 --> 00:21:57,200
linked here

00:21:54,240 --> 00:21:57,840
at uh i'll throw it in the chat i think

00:21:57,200 --> 00:21:59,840
oh

00:21:57,840 --> 00:22:01,440
it was uh lin sun yes thank you again

00:21:59,840 --> 00:22:06,480
lin son for that that great talk

00:22:01,440 --> 00:22:06,480
um let me oh i lost my mouse

00:22:08,000 --> 00:22:14,240
oh here we go i'll throw this uh

00:22:11,200 --> 00:22:16,400
link in the chat here thanks for telling

00:22:14,240 --> 00:22:16,400
me

00:22:16,559 --> 00:22:20,480
there you are um so that uh that is

00:22:19,760 --> 00:22:22,159
another

00:22:20,480 --> 00:22:24,159
you know avenue that i do recommend

00:22:22,159 --> 00:22:26,240
getting into um

00:22:24,159 --> 00:22:28,159
though uh though there's uh not quite

00:22:26,240 --> 00:22:31,440
time to get deep into that

00:22:28,159 --> 00:22:34,559
into that uh topic during this talk um

00:22:31,440 --> 00:22:35,280
so in summary uh shared pipelines are

00:22:34,559 --> 00:22:37,760
certainly

00:22:35,280 --> 00:22:39,679
much much better than shared libraries

00:22:37,760 --> 00:22:40,159
um highly recommend those i think that

00:22:39,679 --> 00:22:43,520
they're

00:22:40,159 --> 00:22:46,559
much stronger and

00:22:43,520 --> 00:22:48,320
uh again using reusable docker images

00:22:46,559 --> 00:22:48,960
that's much much better than copy and

00:22:48,320 --> 00:22:51,679
pasting

00:22:48,960 --> 00:22:53,200
between lots of different uh pipelines

00:22:51,679 --> 00:22:54,159
because you get all this drift and stuff

00:22:53,200 --> 00:22:56,000
like that

00:22:54,159 --> 00:22:58,240
reusable docker images basically mean

00:22:56,000 --> 00:23:00,080
people can self-serve the images

00:22:58,240 --> 00:23:02,159
um with the versions that they want and

00:23:00,080 --> 00:23:05,039
i'll give you an example with terraform

00:23:02,159 --> 00:23:06,799
uh terraform famously does usually not

00:23:05,039 --> 00:23:08,559
like to work between different versions

00:23:06,799 --> 00:23:11,120
of itself

00:23:08,559 --> 00:23:13,679
and with with our code fresh steps

00:23:11,120 --> 00:23:16,320
library which i'll show you really quick

00:23:13,679 --> 00:23:17,520
we actually have a terraform uh step in

00:23:16,320 --> 00:23:18,960
here

00:23:17,520 --> 00:23:21,840
and that terraform step i can just

00:23:18,960 --> 00:23:24,480
self-serve whatever version

00:23:21,840 --> 00:23:26,159
that i want for my pipeline so if i'm

00:23:24,480 --> 00:23:28,080
using a different version of terraform

00:23:26,159 --> 00:23:30,000
it's not going to require you know

00:23:28,080 --> 00:23:31,760
another team to upgrade all their stuff

00:23:30,000 --> 00:23:33,440
to use that

00:23:31,760 --> 00:23:36,240
and then finally deployment validation

00:23:33,440 --> 00:23:37,679
with canary is definitely a really

00:23:36,240 --> 00:23:39,440
strong direction to go in i highly

00:23:37,679 --> 00:23:40,880
recommend that

00:23:39,440 --> 00:23:42,720
to get to canary of course you have to

00:23:40,880 --> 00:23:44,640
have great ci and you have to have great

00:23:42,720 --> 00:23:45,600
cd and if you don't have those things in

00:23:44,640 --> 00:23:46,720
place then you're not going to be able

00:23:45,600 --> 00:23:49,120
to do canary so

00:23:46,720 --> 00:23:50,240
i do recommend that there is a longer

00:23:49,120 --> 00:23:52,480
forum blog post

00:23:50,240 --> 00:23:53,760
about this talk so if you want to refer

00:23:52,480 --> 00:23:55,520
to that i'll throw that in the chat as

00:23:53,760 --> 00:23:56,559
well it's a it's a great resource and it

00:23:55,520 --> 00:24:00,400
was put together

00:23:56,559 --> 00:24:02,080
um by costas capilonus who's uh a guy on

00:24:00,400 --> 00:24:04,400
my team who's fantastic you can follow

00:24:02,080 --> 00:24:06,400
him on twitter at codepipes

00:24:04,400 --> 00:24:08,400
and with that i will open the floor to

00:24:06,400 --> 00:24:10,080
questions and uh would be thrilled if

00:24:08,400 --> 00:24:11,360
any of you want to try that out

00:24:10,080 --> 00:24:12,880
you can try it out on our platform but

00:24:11,360 --> 00:24:13,840
of course you can take those prac those

00:24:12,880 --> 00:24:16,159
best practices

00:24:13,840 --> 00:24:18,799
and try to build them into you know

00:24:16,159 --> 00:24:22,080
whatever tools you're using today

00:24:18,799 --> 00:24:22,080
so with that questions

00:24:24,000 --> 00:24:27,039
watching the chat here uh i'm not seeing

00:24:26,240 --> 00:24:29,440
the resources

00:24:27,039 --> 00:24:31,520
in zoom chat oh that's because i posted

00:24:29,440 --> 00:24:33,120
them to panelists so that was not very

00:24:31,520 --> 00:24:34,000
smart of me let me do panelists and

00:24:33,120 --> 00:24:36,880
attendees

00:24:34,000 --> 00:24:38,960
there you go there is both the uh the

00:24:36,880 --> 00:24:40,400
canary deployment talk that i refer to

00:24:38,960 --> 00:24:43,039
using istu and helm

00:24:40,400 --> 00:24:44,080
and the uh blog post on ci cd pipelines

00:24:43,039 --> 00:24:46,320
thank you joshua for

00:24:44,080 --> 00:24:48,080
for pointing that out um while you're

00:24:46,320 --> 00:24:51,520
thinking of questions

00:24:48,080 --> 00:24:53,679
one of the questions i often get um

00:24:51,520 --> 00:24:55,120
oh yeah thanks thanks for reposting the

00:24:53,679 --> 00:24:58,159
uh the link to the

00:24:55,120 --> 00:24:58,159
apollo 13.

00:24:59,440 --> 00:25:02,640
one of the questions i often get about

00:25:01,200 --> 00:25:06,240
this is

00:25:02,640 --> 00:25:08,080
uh essentially how do you handle

00:25:06,240 --> 00:25:10,240
uh you know once these things are all

00:25:08,080 --> 00:25:11,840
running how do you actually know what's

00:25:10,240 --> 00:25:13,279
going on like if you have thousands of

00:25:11,840 --> 00:25:15,600
microservices doesn't it get

00:25:13,279 --> 00:25:17,840
hard to tell what's going on and the

00:25:15,600 --> 00:25:18,880
answer is yeah it does get hard

00:25:17,840 --> 00:25:20,880
this is something that we've actually

00:25:18,880 --> 00:25:23,360
been working a lot on uh

00:25:20,880 --> 00:25:24,960
because if you are deploying to

00:25:23,360 --> 00:25:27,840
thousands of different microservices

00:25:24,960 --> 00:25:30,080
and you're deploying dozens of times of

00:25:27,840 --> 00:25:33,279
times per day

00:25:30,080 --> 00:25:34,799
that can be really complex and so

00:25:33,279 --> 00:25:37,120
one of the things we've been talking a

00:25:34,799 --> 00:25:37,440
lot about is essentially how you bring

00:25:37,120 --> 00:25:40,159
in

00:25:37,440 --> 00:25:42,720
observability how do you bring in logs

00:25:40,159 --> 00:25:46,000
and metrics into that process

00:25:42,720 --> 00:25:47,200
and then how do you get insight into uh

00:25:46,000 --> 00:25:48,720
how do you get insight into what's

00:25:47,200 --> 00:25:50,640
actually available and so like in our

00:25:48,720 --> 00:25:53,360
platform what we built

00:25:50,640 --> 00:25:54,000
is um actually i don't want to show you

00:25:53,360 --> 00:25:56,960
in

00:25:54,000 --> 00:25:58,320
this one let me show you in this what we

00:25:56,960 --> 00:26:00,159
actually built is a view

00:25:58,320 --> 00:26:01,360
of all your runtime environments and

00:26:00,159 --> 00:26:03,039
applications

00:26:01,360 --> 00:26:04,640
uh so you can actually see what's

00:26:03,039 --> 00:26:07,760
running actually i don't have a ton

00:26:04,640 --> 00:26:07,760
in this one let me do

00:26:08,799 --> 00:26:13,440
well now you can see it anyway um

00:26:12,000 --> 00:26:14,960
so you can see for example i have this

00:26:13,440 --> 00:26:16,559
cluster and i can see all the different

00:26:14,960 --> 00:26:19,600
services that i've deployed

00:26:16,559 --> 00:26:20,799
and if i had actually uh if these were

00:26:19,600 --> 00:26:21,919
actually running through the cluster i

00:26:20,799 --> 00:26:24,960
would actually be able to see

00:26:21,919 --> 00:26:26,559
links to like the deployments and the

00:26:24,960 --> 00:26:27,520
images and all those kinds of things so

00:26:26,559 --> 00:26:29,919
there's a lot of different kind of

00:26:27,520 --> 00:26:31,679
metrics things that we try to do to make

00:26:29,919 --> 00:26:34,799
visibility front and center so people

00:26:31,679 --> 00:26:37,120
know what's going on at all times

00:26:34,799 --> 00:26:38,080
cody asks you mentioned complexity of

00:26:37,120 --> 00:26:40,320
shared library

00:26:38,080 --> 00:26:42,640
as you consolidate many smaller

00:26:40,320 --> 00:26:44,080
pipelines into fewer larger ones

00:26:42,640 --> 00:26:45,840
could you like highlight some of the

00:26:44,080 --> 00:26:48,640
indicators you've witnessed that bring

00:26:45,840 --> 00:26:51,760
those shared libraries under scrutiny

00:26:48,640 --> 00:26:54,400
uh yeah so the shared libraries problem

00:26:51,760 --> 00:26:55,360
is most often experienced in version

00:26:54,400 --> 00:26:59,039
drift

00:26:55,360 --> 00:27:01,760
so i want to use one version

00:26:59,039 --> 00:27:03,039
of something and another tool wants to

00:27:01,760 --> 00:27:05,679
use a different version

00:27:03,039 --> 00:27:07,279
and so now we have to reconcile because

00:27:05,679 --> 00:27:08,880
those shared libraries have to

00:27:07,279 --> 00:27:10,320
execute essentially within the same

00:27:08,880 --> 00:27:11,360
workspace they're executing within the

00:27:10,320 --> 00:27:13,039
same vm

00:27:11,360 --> 00:27:14,799
so i can't have different versions of

00:27:13,039 --> 00:27:16,799
java installed

00:27:14,799 --> 00:27:18,399
um and and different versions of java

00:27:16,799 --> 00:27:20,399
between those two things and so

00:27:18,399 --> 00:27:21,760
if you like if you're looking for

00:27:20,399 --> 00:27:23,520
indicators like

00:27:21,760 --> 00:27:25,039
are you afraid of what will happen if

00:27:23,520 --> 00:27:26,720
you upgrade a version within a shared

00:27:25,039 --> 00:27:29,440
library

00:27:26,720 --> 00:27:30,480
if you are then that probably means that

00:27:29,440 --> 00:27:31,840
shared libraries are

00:27:30,480 --> 00:27:33,360
a constraint in a bottleneck before you

00:27:31,840 --> 00:27:34,399
because it means you have a complex

00:27:33,360 --> 00:27:36,320
relationship

00:27:34,399 --> 00:27:37,440
between shared libraries that you don't

00:27:36,320 --> 00:27:40,399
fully understand

00:27:37,440 --> 00:27:41,919
but you expect will potentially break if

00:27:40,399 --> 00:27:42,880
you're dreading upgrading something like

00:27:41,919 --> 00:27:44,720
that because of it

00:27:42,880 --> 00:27:46,159
that's a really good indication another

00:27:44,720 --> 00:27:47,679
thing that i see a lot of and this is

00:27:46,159 --> 00:27:49,550
actually a security concern

00:27:47,679 --> 00:27:50,960
i wrote a blog post about this called

00:27:49,550 --> 00:27:53,840
[Music]

00:27:50,960 --> 00:27:57,120
this is kind of controversial reasons

00:27:53,840 --> 00:27:57,120
jenkins fails

00:27:58,159 --> 00:28:02,080
yeah this this blog post right here i'll

00:27:59,840 --> 00:28:04,480
throw in this is kind of controversial

00:28:02,080 --> 00:28:06,720
uh maybe because of the image i stuck at

00:28:04,480 --> 00:28:09,919
the top of it

00:28:06,720 --> 00:28:13,919
but um one of the issues that happens

00:28:09,919 --> 00:28:17,600
uh with this is that um

00:28:13,919 --> 00:28:21,440
is that uh people will start

00:28:17,600 --> 00:28:24,880
proliferating different uh masters

00:28:21,440 --> 00:28:26,640
in order to handle um version

00:28:24,880 --> 00:28:27,919
conflict so like i want to use one

00:28:26,640 --> 00:28:29,039
version of java and someone else wants

00:28:27,919 --> 00:28:30,799
to use a different one

00:28:29,039 --> 00:28:32,159
so rather than reconciling i'm going to

00:28:30,799 --> 00:28:33,520
split off and create a new jenkins

00:28:32,159 --> 00:28:35,360
master that i have to manage

00:28:33,520 --> 00:28:36,559
and uh so i can install the version that

00:28:35,360 --> 00:28:38,799
i want and

00:28:36,559 --> 00:28:40,799
um what we've i've actually seen at

00:28:38,799 --> 00:28:44,159
companies i've seen companies that have

00:28:40,799 --> 00:28:45,279
thousands of different masters that

00:28:44,159 --> 00:28:46,880
they're all trying to manage

00:28:45,279 --> 00:28:50,640
and almost all of them are way out of

00:28:46,880 --> 00:28:52,880
date so this creates a big problem

00:28:50,640 --> 00:28:56,159
from the chat and i'll alternate between

00:28:52,880 --> 00:28:58,000
the the q a and the chat here

00:28:56,159 --> 00:29:00,000
from the chat would there be a scenario

00:28:58,000 --> 00:29:02,159
of circular dependency

00:29:00,000 --> 00:29:04,080
of unified pipeline script given that we

00:29:02,159 --> 00:29:05,840
use a single pipeline for all repos and

00:29:04,080 --> 00:29:07,200
any additional step required for one

00:29:05,840 --> 00:29:09,039
single repo script

00:29:07,200 --> 00:29:11,279
um there shouldn't be any circular

00:29:09,039 --> 00:29:12,559
dependencies when you're using a shared

00:29:11,279 --> 00:29:14,559
pipeline like that

00:29:12,559 --> 00:29:16,080
um the only the only scenario in which

00:29:14,559 --> 00:29:19,520
that would happen is if your

00:29:16,080 --> 00:29:22,399
output from that pipeline was modifying

00:29:19,520 --> 00:29:24,000
another repo that is also on the ci

00:29:22,399 --> 00:29:25,760
pipeline so i mentioned that we actually

00:29:24,000 --> 00:29:28,799
separate out

00:29:25,760 --> 00:29:32,320
the infrastructure uh like the

00:29:28,799 --> 00:29:33,440
um like the deployment manifests and the

00:29:32,320 --> 00:29:35,279
application mana

00:29:33,440 --> 00:29:37,120
the application description those are in

00:29:35,279 --> 00:29:39,520
two different repositories

00:29:37,120 --> 00:29:41,279
so everything that executes over here

00:29:39,520 --> 00:29:44,080
executes on the ci pipeline

00:29:41,279 --> 00:29:45,520
and it generates pull requests onto our

00:29:44,080 --> 00:29:47,200
infrastructure repos

00:29:45,520 --> 00:29:48,880
which then go through us a different

00:29:47,200 --> 00:29:50,080
process so that way we don't ever go

00:29:48,880 --> 00:29:53,200
through any kind of

00:29:50,080 --> 00:29:54,640
circular dependency ashok asks what

00:29:53,200 --> 00:29:57,760
tools and frameworks

00:29:54,640 --> 00:29:59,039
do you use for observability um so we

00:29:57,760 --> 00:30:02,720
actually uh

00:29:59,039 --> 00:30:04,000
i uh we we work with a number of

00:30:02,720 --> 00:30:07,919
different logging providers

00:30:04,000 --> 00:30:09,039
and i'm we have some stuff internally

00:30:07,919 --> 00:30:12,000
that we do that basically

00:30:09,039 --> 00:30:12,960
overlays performance and metrics on top

00:30:12,000 --> 00:30:15,760
of

00:30:12,960 --> 00:30:17,039
our uh pipelines and this is something

00:30:15,760 --> 00:30:18,399
that we're working on right now

00:30:17,039 --> 00:30:20,559
releasing to the public and so you

00:30:18,399 --> 00:30:22,720
should actually see it in our platform

00:30:20,559 --> 00:30:24,480
released for other people in the next uh

00:30:22,720 --> 00:30:27,360
couple of weeks keep it on the dl

00:30:24,480 --> 00:30:27,760
we haven't announced it yet so just you

00:30:27,360 --> 00:30:31,039
know

00:30:27,760 --> 00:30:34,159
just between us friends here um

00:30:31,039 --> 00:30:36,720
another question uh comes from casey

00:30:34,159 --> 00:30:38,559
nix nixos happily runs multiple versions

00:30:36,720 --> 00:30:39,919
of codes and shared libraries if that's

00:30:38,559 --> 00:30:40,799
a problem you have and don't want to get

00:30:39,919 --> 00:30:42,559
into docker

00:30:40,799 --> 00:30:44,080
um i haven't tried next in nixos and

00:30:42,559 --> 00:30:48,399
that that certainly is a

00:30:44,080 --> 00:30:50,480
an interesting recommendation my

00:30:48,399 --> 00:30:51,440
my hesitation with with that would be

00:30:50,480 --> 00:30:53,279
and and

00:30:51,440 --> 00:30:54,880
and i also want to separate out i'm

00:30:53,279 --> 00:30:57,440
talking about containers

00:30:54,880 --> 00:30:59,200
and docker and containers used to be

00:30:57,440 --> 00:31:00,640
this you know kind of synonymous

00:30:59,200 --> 00:31:02,640
and sometimes i talk to people who are

00:31:00,640 --> 00:31:04,240
like oh i don't use docker at all

00:31:02,640 --> 00:31:06,720
i just use containers i just use them on

00:31:04,240 --> 00:31:08,720
a different runtime that's totally fine

00:31:06,720 --> 00:31:10,640
i'm not making any any specific docker

00:31:08,720 --> 00:31:12,960
recommendations here

00:31:10,640 --> 00:31:14,320
i'm really just talking about any you

00:31:12,960 --> 00:31:17,679
know oci compliant

00:31:14,320 --> 00:31:18,080
image that you want to use um andrew

00:31:17,679 --> 00:31:19,519
asks

00:31:18,080 --> 00:31:21,120
what are the hardware requirements for

00:31:19,519 --> 00:31:23,120
code fresh we have had

00:31:21,120 --> 00:31:25,440
scaling problems with concourse garden

00:31:23,120 --> 00:31:27,039
workers with a lot of task containers or

00:31:25,440 --> 00:31:29,840
launched at the same time

00:31:27,039 --> 00:31:32,159
um so this uh this actually comes this

00:31:29,840 --> 00:31:34,240
is actually a really big strength for us

00:31:32,159 --> 00:31:35,440
we are a kubernetes native platform so

00:31:34,240 --> 00:31:36,799
we really take advantage of the

00:31:35,440 --> 00:31:39,519
kubernetes primitives

00:31:36,799 --> 00:31:41,360
um if i can install the code fresh

00:31:39,519 --> 00:31:44,559
runner on a very minimalist

00:31:41,360 --> 00:31:47,039
small cluster and if i

00:31:44,559 --> 00:31:48,640
i can basically throw pipelines at that

00:31:47,039 --> 00:31:51,760
all day long and it will

00:31:48,640 --> 00:31:53,440
uh it will spin up as many pods

00:31:51,760 --> 00:31:55,360
as there are uh pipelines that need to

00:31:53,440 --> 00:31:57,440
be executed and if your kubernetes

00:31:55,360 --> 00:31:59,840
cluster is set up with like auto scaling

00:31:57,440 --> 00:32:02,960
it'll just add nodes and execute

00:31:59,840 --> 00:32:04,080
and this works really really well if i

00:32:02,960 --> 00:32:04,880
had more time i would show you really

00:32:04,080 --> 00:32:07,679
quick

00:32:04,880 --> 00:32:10,559
but it's pretty rad i would recommend if

00:32:07,679 --> 00:32:10,559
you want to see this

00:32:11,200 --> 00:32:14,960
at codefresh.io there is at the very top

00:32:13,840 --> 00:32:18,399
of the page

00:32:14,960 --> 00:32:18,720
the code fresh runner here um try this

00:32:18,399 --> 00:32:21,360
guy

00:32:18,720 --> 00:32:23,279
out it'll uh it'll it's really easy to

00:32:21,360 --> 00:32:25,600
install get up and running

00:32:23,279 --> 00:32:27,600
and what i actually did is to test this

00:32:25,600 --> 00:32:30,640
is i made a bash script

00:32:27,600 --> 00:32:31,039
called spam pipelines and all it does is

00:32:30,640 --> 00:32:33,840
uh

00:32:31,039 --> 00:32:35,200
run it runs code fresh run pipeline and

00:32:33,840 --> 00:32:36,159
then it just does it as many times i

00:32:35,200 --> 00:32:38,720
tell it to do it

00:32:36,159 --> 00:32:41,360
and i've put in a bucket of executions

00:32:38,720 --> 00:32:44,080
in there and it will spin up and execute

00:32:41,360 --> 00:32:45,600
as many um you know nodes on my cluster

00:32:44,080 --> 00:32:47,039
as i need so i've seen really great

00:32:45,600 --> 00:32:48,799
scalability with this

00:32:47,039 --> 00:32:50,320
and i've seen it also from our customers

00:32:48,799 --> 00:32:55,039
not just in my my my uh

00:32:50,320 --> 00:32:58,399
you know sort of silly uh test scenario

00:32:55,039 --> 00:33:00,080
um good question coming back over uh

00:32:58,399 --> 00:33:02,799
what other tools would you recommend

00:33:00,080 --> 00:33:04,799
using if you are using jenkins for cicd

00:33:02,799 --> 00:33:06,880
um well we don't use jenkins obviously

00:33:04,799 --> 00:33:08,880
we we're code fresh is uh

00:33:06,880 --> 00:33:10,080
is essentially a replacement for jenkins

00:33:08,880 --> 00:33:11,600
so i don't know that i would have a

00:33:10,080 --> 00:33:13,200
whole lot of recommendations i would say

00:33:11,600 --> 00:33:14,240
deployment operators are certainly

00:33:13,200 --> 00:33:16,159
really interesting

00:33:14,240 --> 00:33:18,799
um we're doing a lot of work with argo

00:33:16,159 --> 00:33:20,320
cd um we really like that open source

00:33:18,799 --> 00:33:20,799
project and we've been contributing to

00:33:20,320 --> 00:33:21,919
it for

00:33:20,799 --> 00:33:23,279
for a while and it's something that

00:33:21,919 --> 00:33:24,960
we've been building also into our

00:33:23,279 --> 00:33:27,360
platform so that's definitely

00:33:24,960 --> 00:33:28,320
one that i would recommend checking out

00:33:27,360 --> 00:33:31,120
as well

00:33:28,320 --> 00:33:33,200
um yaboo asks any thoughts about

00:33:31,120 --> 00:33:34,320
deploying serverless functions instead

00:33:33,200 --> 00:33:35,679
of containers

00:33:34,320 --> 00:33:38,159
is there anything you will change in

00:33:35,679 --> 00:33:39,360
pipelines architecture in general so i

00:33:38,159 --> 00:33:42,320
think functions are great

00:33:39,360 --> 00:33:43,440
uh no no problem with that um deploying

00:33:42,320 --> 00:33:45,760
serverless functions

00:33:43,440 --> 00:33:47,200
actually are deploying containers 99 of

00:33:45,760 --> 00:33:49,279
the time on 99 platforms

00:33:47,200 --> 00:33:50,960
actually is a container underneath um

00:33:49,279 --> 00:33:51,760
it's just a matter of how you want to

00:33:50,960 --> 00:33:53,440
describe it

00:33:51,760 --> 00:33:54,960
so i don't really think it changes a

00:33:53,440 --> 00:33:56,480
whole lot about the deployment pattern i

00:33:54,960 --> 00:33:57,279
think you still want to have probably a

00:33:56,480 --> 00:34:00,720
ci

00:33:57,279 --> 00:34:02,080
and a cd uh kind of uh process and that

00:34:00,720 --> 00:34:05,840
you want to have probably

00:34:02,080 --> 00:34:07,039
your your code repos and your sort of

00:34:05,840 --> 00:34:08,320
infrastructure repos that you're making

00:34:07,039 --> 00:34:09,119
changes to so

00:34:08,320 --> 00:34:11,200
when you make a change to your

00:34:09,119 --> 00:34:12,079
application you basically open up a pull

00:34:11,200 --> 00:34:14,159
request to

00:34:12,079 --> 00:34:16,000
um your functions library which then

00:34:14,159 --> 00:34:19,520
actually syncs it and deploys it

00:34:16,000 --> 00:34:20,960
it's what i would recommend but uh but

00:34:19,520 --> 00:34:22,560
yeah i don't i don't think it really

00:34:20,960 --> 00:34:24,159
changes anything too dramatically i

00:34:22,560 --> 00:34:25,839
think it uh maybe just

00:34:24,159 --> 00:34:27,839
simplifies what kind of manifest you

00:34:25,839 --> 00:34:29,280
need to manage and depending on what

00:34:27,839 --> 00:34:30,960
platform you're using

00:34:29,280 --> 00:34:33,919
um you know you might be running your

00:34:30,960 --> 00:34:34,320
serverless platform on top of kubernetes

00:34:33,919 --> 00:34:37,839
um

00:34:34,320 --> 00:34:39,359
or you might be using a a provider

00:34:37,839 --> 00:34:40,960
like a cloud provider's you know

00:34:39,359 --> 00:34:43,200
built-in serverless platform

00:34:40,960 --> 00:34:44,159
either case i don't think it changes the

00:34:43,200 --> 00:34:47,440
the math um

00:34:44,159 --> 00:34:50,159
to to too directly

00:34:47,440 --> 00:34:52,079
awesome well it looks like uh we

00:34:50,159 --> 00:34:54,240
answered all the questions hopefully uh

00:34:52,079 --> 00:34:56,320
none of that was too uh if it was

00:34:54,240 --> 00:34:58,480
controversial hopefully uh it was at

00:34:56,320 --> 00:35:01,040
least something to learn from and uh

00:34:58,480 --> 00:35:03,040
and valuable um again i do recommend

00:35:01,040 --> 00:35:06,320
trying this stuff out we've seen

00:35:03,040 --> 00:35:09,440
uh we actually i mentioned kind of the

00:35:06,320 --> 00:35:11,440
the way that um shared pipelines work

00:35:09,440 --> 00:35:12,960
and since we have a second um one thing

00:35:11,440 --> 00:35:13,920
that i would really recommend trying to

00:35:12,960 --> 00:35:16,960
learn this

00:35:13,920 --> 00:35:20,320
is if i go and execute let me see if i

00:35:16,960 --> 00:35:23,680
actually have one sitting right here

00:35:20,320 --> 00:35:26,160
i think i actually have a cool way to

00:35:23,680 --> 00:35:26,160
show this

00:35:28,079 --> 00:35:33,839
um yeah i can't remember if i

00:35:31,359 --> 00:35:36,079
actually run this in a little while but

00:35:33,839 --> 00:35:37,599
let me try to run this guy

00:35:36,079 --> 00:35:39,440
check out my settings make sure this

00:35:37,599 --> 00:35:42,240
isn't uh

00:35:39,440 --> 00:35:42,640
some runtime that i've removed yeah okay

00:35:42,240 --> 00:35:44,160
so

00:35:42,640 --> 00:35:46,560
one one way that i can just show you the

00:35:44,160 --> 00:35:48,800
way this um this shared pipeline works

00:35:46,560 --> 00:35:51,680
is i'm gonna run this in debug mode

00:35:48,800 --> 00:35:52,000
and this will actually allow me to put

00:35:51,680 --> 00:35:53,839
in

00:35:52,000 --> 00:35:55,760
break points into my pipeline and then

00:35:53,839 --> 00:35:58,400
interact with it in real time

00:35:55,760 --> 00:35:59,520
um i haven't messed with this pipeline

00:35:58,400 --> 00:36:01,359
in a while so

00:35:59,520 --> 00:36:02,640
uh we'll see if it works well and i

00:36:01,359 --> 00:36:03,760
can't remember if this account is even

00:36:02,640 --> 00:36:06,000
set up properly

00:36:03,760 --> 00:36:07,280
but i'm going to set up a looks like

00:36:06,000 --> 00:36:09,359
i've already got some break points set

00:36:07,280 --> 00:36:12,800
up to override these different steps

00:36:09,359 --> 00:36:15,839
um so i can set breakpoints before

00:36:12,800 --> 00:36:18,079
during a step execution or afterwards

00:36:15,839 --> 00:36:19,760
and this will actually show you um i

00:36:18,079 --> 00:36:20,960
think in a really direct way how those

00:36:19,760 --> 00:36:22,880
volumes work

00:36:20,960 --> 00:36:24,640
so if you think about it i've got go

00:36:22,880 --> 00:36:27,040
tooling java tooling.net

00:36:24,640 --> 00:36:29,200
tooling they're all separate right i'm

00:36:27,040 --> 00:36:33,200
not executing them together

00:36:29,200 --> 00:36:37,440
um and let's see if we've

00:36:33,200 --> 00:36:39,040
initialized here rocking and rolling

00:36:37,440 --> 00:36:40,560
yeah once it starts this step then it

00:36:39,040 --> 00:36:43,680
will drop me to the debug so

00:36:40,560 --> 00:36:45,119
all of these steps are executing within

00:36:43,680 --> 00:36:46,320
their own container

00:36:45,119 --> 00:36:48,640
now again this isn't something that's

00:36:46,320 --> 00:36:50,320
docker specific these could be just any

00:36:48,640 --> 00:36:51,599
oci compliant containers

00:36:50,320 --> 00:36:52,800
they're going to execute exactly the

00:36:51,599 --> 00:36:55,200
same doesn't doesn't matter what the

00:36:52,800 --> 00:36:57,280
runtime is

00:36:55,200 --> 00:36:58,640
and this will actually allow me to

00:36:57,280 --> 00:37:01,040
create these

00:36:58,640 --> 00:37:02,640
steps that are completely separate and

00:37:01,040 --> 00:37:06,000
execute in a completely

00:37:02,640 --> 00:37:06,720
separate way so there's no conflict

00:37:06,000 --> 00:37:09,119
there's no

00:37:06,720 --> 00:37:11,280
execution between them and there's no

00:37:09,119 --> 00:37:12,720
dependency between these platforms so if

00:37:11,280 --> 00:37:14,640
one component

00:37:12,720 --> 00:37:16,720
is using you know one version it's not

00:37:14,640 --> 00:37:19,839
going to be an issue on another version

00:37:16,720 --> 00:37:23,040
um so here yeah i've dropped into

00:37:19,839 --> 00:37:25,599
my step here and uh

00:37:23,040 --> 00:37:27,359
let's see if you can see that i am

00:37:25,599 --> 00:37:28,480
within the shared volume you can see

00:37:27,359 --> 00:37:31,760
what's in here

00:37:28,480 --> 00:37:31,760
i can create um

00:37:32,960 --> 00:37:37,200
create a go link thing here and if i run

00:37:34,880 --> 00:37:39,920
go

00:37:37,200 --> 00:37:40,240
go version you can see that goes here

00:37:39,920 --> 00:37:43,359
but

00:37:40,240 --> 00:37:45,599
java won't be net won't be

00:37:43,359 --> 00:37:46,880
right they're not found um so let's say

00:37:45,599 --> 00:37:49,119
i'm happy i'm going to move on

00:37:46,880 --> 00:37:50,160
it's now going to move me on into my

00:37:49,119 --> 00:37:51,920
next debug step

00:37:50,160 --> 00:37:53,359
which is in this java container so it's

00:37:51,920 --> 00:37:54,960
actually going to spin that up so you

00:37:53,359 --> 00:37:56,960
can see i'm basically moving in and out

00:37:54,960 --> 00:37:58,560
of containers right

00:37:56,960 --> 00:38:00,000
so here it's now set up my next

00:37:58,560 --> 00:38:01,839
workspace and

00:38:00,000 --> 00:38:03,119
here if i try to run go version it's not

00:38:01,839 --> 00:38:03,760
going to work because go is not

00:38:03,119 --> 00:38:07,119
installed

00:38:03,760 --> 00:38:10,560
in this container right but java is so

00:38:07,119 --> 00:38:11,359
uh java i can't remember the syntax on

00:38:10,560 --> 00:38:15,359
java it's like

00:38:11,359 --> 00:38:15,359
java dash v or

00:38:16,839 --> 00:38:19,839
java

00:38:20,079 --> 00:38:24,240
i can never remember the syntax on java

00:38:22,400 --> 00:38:26,000
i don't use java very much

00:38:24,240 --> 00:38:27,440
and java is like the weird one it uses

00:38:26,000 --> 00:38:30,880
like the

00:38:27,440 --> 00:38:32,079
you know uh it's like the way that it

00:38:30,880 --> 00:38:34,720
checks reversion is

00:38:32,079 --> 00:38:35,760
is some some bizarre oh is it just

00:38:34,720 --> 00:38:37,280
version

00:38:35,760 --> 00:38:38,400
no it's something it's it's different

00:38:37,280 --> 00:38:39,680
than that anyway we don't have to get

00:38:38,400 --> 00:38:42,000
into it but you get the idea i think

00:38:39,680 --> 00:38:43,920
this explains it um fairly well so

00:38:42,000 --> 00:38:45,599
oh everybody everybody in the chats like

00:38:43,920 --> 00:38:46,880
yelling at me all the other people that

00:38:45,599 --> 00:38:51,359
use java all the time are like

00:38:46,880 --> 00:38:55,040
oh my gosh uh java v

00:38:51,359 --> 00:38:56,720
no java dash version

00:38:55,040 --> 00:39:00,640
oh there we go there we go yeah it's

00:38:56,720 --> 00:39:03,359
java dash version okay

00:39:00,640 --> 00:39:04,400
thanks guys uh so so yeah we can see

00:39:03,359 --> 00:39:07,920
that java works

00:39:04,400 --> 00:39:09,440
and of course golang go does not work

00:39:07,920 --> 00:39:10,800
right because goes not in this container

00:39:09,440 --> 00:39:12,400
so you can see they're actually separate

00:39:10,800 --> 00:39:13,760
containers but they're executing within

00:39:12,400 --> 00:39:14,560
the shared volume and if i check this

00:39:13,760 --> 00:39:16,560
volume

00:39:14,560 --> 00:39:17,920
you can see where i exported this go

00:39:16,560 --> 00:39:19,839
link text

00:39:17,920 --> 00:39:22,160
and this is cool again because it's

00:39:19,839 --> 00:39:24,320
actually executing on a local ssd

00:39:22,160 --> 00:39:25,920
so the i o is really fast we actually

00:39:24,320 --> 00:39:27,599
had a customer gave a talk at kubecon

00:39:25,920 --> 00:39:28,320
last year and their build times went

00:39:27,599 --> 00:39:30,160
from

00:39:28,320 --> 00:39:32,400
like an hour and a half to like 12

00:39:30,160 --> 00:39:32,720
minutes because they just had a lot of i

00:39:32,400 --> 00:39:34,960
o

00:39:32,720 --> 00:39:35,839
requirements in between the steps and

00:39:34,960 --> 00:39:38,480
they were using

00:39:35,839 --> 00:39:40,400
a like a network drive before and that

00:39:38,480 --> 00:39:42,079
just the i o was so slow

00:39:40,400 --> 00:39:43,440
that their pipeline executions were

00:39:42,079 --> 00:39:45,119
really slow and of course everything

00:39:43,440 --> 00:39:48,000
that i do here is going to be cached

00:39:45,119 --> 00:39:48,480
um though though not within the debug

00:39:48,000 --> 00:39:50,240
actually

00:39:48,480 --> 00:39:52,240
within the debug it won't be cached but

00:39:50,240 --> 00:39:53,440
a normal pipeline execution would be

00:39:52,240 --> 00:39:55,040
anyway i think that gives you a pretty

00:39:53,440 --> 00:39:55,760
good idea go try it out it's a lot of

00:39:55,040 --> 00:39:58,000
fun

00:39:55,760 --> 00:39:59,760
it's a fun way to build pipelines too

00:39:58,000 --> 00:40:00,560
and with that i think we'll come to a

00:39:59,760 --> 00:40:02,640
close and

00:40:00,560 --> 00:40:03,920
really appreciate you attending the talk

00:40:02,640 --> 00:40:05,520
if you liked it or you didn't like it

00:40:03,920 --> 00:40:07,040
hit me up on twitter at today was

00:40:05,520 --> 00:40:08,079
awesome interested to hear your feedback

00:40:07,040 --> 00:40:08,720
if you think i could have done something

00:40:08,079 --> 00:40:10,400
better

00:40:08,720 --> 00:40:13,440
let me know if you think i did something

00:40:10,400 --> 00:40:15,760
really great love to hear that even more

00:40:13,440 --> 00:40:23,599
with that i'll pass it back over to our

00:40:15,760 --> 00:40:23,599

YouTube URL: https://www.youtube.com/watch?v=ndjlWDZ0AYU


