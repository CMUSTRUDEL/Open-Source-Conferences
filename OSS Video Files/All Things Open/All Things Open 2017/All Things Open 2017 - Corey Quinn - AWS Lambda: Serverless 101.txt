Title: All Things Open 2017 - Corey Quinn - AWS Lambda: Serverless 101
Publication date: 2017-11-28
Playlist: All Things Open 2017
Description: 
	All Things Open 2017, Raleigh NC, Raleigh Convention Center. www.Allthingsopen.org
Captions: 
	00:00:00,000 --> 00:00:03,480
all right thank you all for your

00:00:01,920 --> 00:00:06,150
patience sorry about that

00:00:03,480 --> 00:00:08,900
for those of you who are more observant

00:00:06,150 --> 00:00:11,070
than others I am NOT in fact John Willis

00:00:08,900 --> 00:00:13,380
John was unable to make it here today

00:00:11,070 --> 00:00:16,470
and as Todd mentioned during the keynote

00:00:13,380 --> 00:00:18,449
and I quote for those of you who were

00:00:16,470 --> 00:00:22,890
expecting John Willis to be here I have

00:00:18,449 --> 00:00:24,750
some sad news he's not able to make it

00:00:22,890 --> 00:00:26,220
and for the first half of that sentence

00:00:24,750 --> 00:00:27,390
most people in that room thought that he

00:00:26,220 --> 00:00:28,830
was saying that John well it was

00:00:27,390 --> 00:00:31,830
something horrible that happened to John

00:00:28,830 --> 00:00:33,630
so fortunately that is not the case but

00:00:31,830 --> 00:00:36,210
Todd we love you please don't ever work

00:00:33,630 --> 00:00:39,210
in healthcare I'm sorry to tell you mr.

00:00:36,210 --> 00:00:41,670
and mrs. Smith the cafeteria is out of

00:00:39,210 --> 00:00:43,410
bagels it just doesn't go well okay so

00:00:41,670 --> 00:00:45,750
let's talk instead about an impromptu

00:00:43,410 --> 00:00:48,870
last minute talk here silence of the

00:00:45,750 --> 00:00:51,449
lambdas terrible ideas in AWS lambda

00:00:48,870 --> 00:00:55,829
this is more or less a survey of the

00:00:51,449 --> 00:00:57,750
whole serverless movement and this is

00:00:55,829 --> 00:01:01,770
going to be a little on the interesting

00:00:57,750 --> 00:01:05,489
side quick poll here who uses lambda for

00:01:01,770 --> 00:01:08,820
something today okay who has no idea

00:01:05,489 --> 00:01:10,110
what lambda is okay there are a few

00:01:08,820 --> 00:01:12,030
honest people there good good good I

00:01:10,110 --> 00:01:14,430
don't think anyone truly knows it the

00:01:12,030 --> 00:01:17,820
idea historically behind serverless

00:01:14,430 --> 00:01:20,369
has been getting away from the idea of

00:01:17,820 --> 00:01:22,439
paying a provider to run instances and

00:01:20,369 --> 00:01:25,680
running infrastructure instead you just

00:01:22,439 --> 00:01:29,009
hand them some code and say here run

00:01:25,680 --> 00:01:33,060
this and that idea works reasonably well

00:01:29,009 --> 00:01:34,909
the challenge of course is that it of

00:01:33,060 --> 00:01:37,409
course is never that easy

00:01:34,909 --> 00:01:39,750
also protip if you ever decide to run a

00:01:37,409 --> 00:01:41,729
conference and call it server less be

00:01:39,750 --> 00:01:43,259
very careful about giving context to the

00:01:41,729 --> 00:01:44,939
wait staff unless you enjoy people

00:01:43,259 --> 00:01:46,680
spitting in your food if you're

00:01:44,939 --> 00:01:50,280
presenting is hi we're here to take your

00:01:46,680 --> 00:01:52,170
job doesn't doesn't play well so the

00:01:50,280 --> 00:01:54,060
idea behind this is not just one of

00:01:52,170 --> 00:01:55,619
wouldn't it be nifty if we didn't have

00:01:54,060 --> 00:01:57,329
to think about infrastructure but

00:01:55,619 --> 00:01:59,670
there's an economic argument for it

00:01:57,329 --> 00:02:02,040
you're not paying for things to run by

00:01:59,670 --> 00:02:04,320
the hour and it works better for some

00:02:02,040 --> 00:02:06,630
implementations than others for example

00:02:04,320 --> 00:02:08,250
the idea of small glue tasks that just

00:02:06,630 --> 00:02:10,590
need to fire every once in a while is

00:02:08,250 --> 00:02:12,140
terrific its picture cron jobs we don't

00:02:10,590 --> 00:02:14,600
have to worry about whether the cron

00:02:12,140 --> 00:02:16,430
the quran demon is running or whether or

00:02:14,600 --> 00:02:19,220
not the instance that's running on is

00:02:16,430 --> 00:02:21,200
being monitored appropriately the idea

00:02:19,220 --> 00:02:23,510
also comes down to being able to break

00:02:21,200 --> 00:02:26,540
things into discrete tasks and massively

00:02:23,510 --> 00:02:28,490
parallel eyes them which is a handy way

00:02:26,540 --> 00:02:30,740
of approaching these things it opens up

00:02:28,490 --> 00:02:32,900
the possibility of doing things and new

00:02:30,740 --> 00:02:34,760
and interesting ways for those of us who

00:02:32,900 --> 00:02:36,980
don't generally have a few thousand

00:02:34,760 --> 00:02:40,580
spare machines sitting around ready to

00:02:36,980 --> 00:02:42,290
do our work at a moment's notice so the

00:02:40,580 --> 00:02:46,970
idea here is that you can write

00:02:42,290 --> 00:02:49,070
arbitrary code for lambda and send it on

00:02:46,970 --> 00:02:52,750
up there in a variety of blessed

00:02:49,070 --> 00:02:55,550
approved languages that it supports and

00:02:52,750 --> 00:02:58,160
then you end up invoking it via some

00:02:55,550 --> 00:03:00,110
form of trigger or event source to use

00:02:58,160 --> 00:03:02,030
their term in other words here's some

00:03:00,110 --> 00:03:04,910
random code and you should run it

00:03:02,030 --> 00:03:08,000
whenever a thing happens whenever

00:03:04,910 --> 00:03:10,610
someone uploads an object to s3 that can

00:03:08,000 --> 00:03:13,700
serve as a trigger whenever a user hits

00:03:10,610 --> 00:03:15,890
a certain website or a event is received

00:03:13,700 --> 00:03:17,209
or even just the passing of time you

00:03:15,890 --> 00:03:19,489
even accepts traditional cron

00:03:17,209 --> 00:03:21,200
expressions which is super handy for

00:03:19,489 --> 00:03:25,400
those of us who never advanced past the

00:03:21,200 --> 00:03:26,750
dark days of Unix and I am gonna be

00:03:25,400 --> 00:03:28,940
talking about lambda here because that

00:03:26,750 --> 00:03:31,820
is sort of the 800-pound gorilla in this

00:03:28,940 --> 00:03:33,920
space but both Asher and Google Cloud

00:03:31,820 --> 00:03:35,480
has something very similar for this for

00:03:33,920 --> 00:03:38,540
those on the more open side of the world

00:03:35,480 --> 00:03:41,269
there are options such as open FAS which

00:03:38,540 --> 00:03:43,100
stands for functions as a service this

00:03:41,269 --> 00:03:44,180
is a new enough concept that we haven't

00:03:43,100 --> 00:03:46,400
have we don't have a lot of the

00:03:44,180 --> 00:03:47,900
buzzwords that have evolved around this

00:03:46,400 --> 00:03:53,420
so we're still trying to figure out even

00:03:47,900 --> 00:03:55,190
how to define it so before I tell you

00:03:53,420 --> 00:03:58,040
what lambda is great for I want to talk

00:03:55,190 --> 00:04:00,050
about things it's not great for using

00:03:58,040 --> 00:04:02,810
some technology that I've licensed from

00:04:00,050 --> 00:04:08,330
the wildly successful startup hot dog or

00:04:02,810 --> 00:04:11,239
not so if your code and all of its

00:04:08,330 --> 00:04:13,360
dependencies bundled together are larger

00:04:11,239 --> 00:04:15,680
than 75 megabytes

00:04:13,360 --> 00:04:18,049
that's probably not a great candidate

00:04:15,680 --> 00:04:21,109
for a lambda function 75 Meg's is a hard

00:04:18,049 --> 00:04:23,600
limit now you can get around this by as

00:04:21,109 --> 00:04:24,090
your function starts go ahead and grab a

00:04:23,600 --> 00:04:25,650
bunch

00:04:24,090 --> 00:04:27,330
dependencies from elsewhere in the

00:04:25,650 --> 00:04:29,850
internet pull it down from s3 or whatnot

00:04:27,330 --> 00:04:36,120
but that's frankly kind of a terrible

00:04:29,850 --> 00:04:39,930
pattern if your code requires a lot of

00:04:36,120 --> 00:04:41,820
state databases data stores etc or

00:04:39,930 --> 00:04:43,740
you're dealing with large quantities of

00:04:41,820 --> 00:04:47,100
data that need to be local and can't be

00:04:43,740 --> 00:04:50,580
grabbed at runtime that's also not a

00:04:47,100 --> 00:04:53,790
great candidate for lambda functions the

00:04:50,580 --> 00:04:56,100
idea here is that functions run I

00:04:53,790 --> 00:04:57,270
definitely it runs at once and then it's

00:04:56,100 --> 00:04:58,620
done

00:04:57,270 --> 00:05:00,810
and the reason behind that is in

00:04:58,620 --> 00:05:02,400
distributed systems it is impossible

00:05:00,810 --> 00:05:04,710
according to the tenets of computer

00:05:02,400 --> 00:05:08,400
science to guarantee exactly once

00:05:04,710 --> 00:05:10,680
execution you can have three options of

00:05:08,400 --> 00:05:12,630
at most once in other words it will only

00:05:10,680 --> 00:05:15,630
ever run once but it's not guaranteed to

00:05:12,630 --> 00:05:16,979
run at least once in which case you

00:05:15,630 --> 00:05:19,169
could have it run a second time

00:05:16,979 --> 00:05:20,910
depending on failure mode and who the

00:05:19,169 --> 00:05:22,380
hell even knows which is generally how

00:05:20,910 --> 00:05:27,690
most of us tend to write things if we're

00:05:22,380 --> 00:05:30,360
lazy and high I am also if you want a

00:05:27,690 --> 00:05:32,700
systems architecture that a freaking

00:05:30,360 --> 00:05:36,030
human being has a hope in hell of

00:05:32,700 --> 00:05:38,010
understanding then you absolutely don't

00:05:36,030 --> 00:05:40,169
want to use lambda functions because it

00:05:38,010 --> 00:05:42,780
very quickly turns into a living

00:05:40,169 --> 00:05:45,090
nightmare of a sprawl picture of

00:05:42,780 --> 00:05:48,320
microservices diagrams or a Boston

00:05:45,090 --> 00:05:50,970
Street Map and you're pretty close so

00:05:48,320 --> 00:05:54,030
let's instead talk about when we do want

00:05:50,970 --> 00:05:56,970
to use lambda functions so we're gonna

00:05:54,030 --> 00:05:58,950
start with what a lambda function looks

00:05:56,970 --> 00:06:01,880
like in less abstract terms and more

00:05:58,950 --> 00:06:05,580
once we start delving into these things

00:06:01,880 --> 00:06:08,610
because under the hood lender runtimes

00:06:05,580 --> 00:06:09,510
are frankly just containers that have

00:06:08,610 --> 00:06:11,400
some somewhat interesting

00:06:09,510 --> 00:06:13,560
characteristics as a result you don't

00:06:11,400 --> 00:06:15,090
generally get to see most of this stuff

00:06:13,560 --> 00:06:17,370
under the hood but I have some sneaky

00:06:15,090 --> 00:06:21,229
tricks to a tease information about the

00:06:17,370 --> 00:06:24,030
lambda runtime out of it so for starters

00:06:21,229 --> 00:06:26,250
you can configure the amount of ram that

00:06:24,030 --> 00:06:29,070
a lambda function runs with ranging at a

00:06:26,250 --> 00:06:31,650
low end from 128 megabytes all the way

00:06:29,070 --> 00:06:34,979
on up to a gigabyte and a half and as

00:06:31,650 --> 00:06:36,390
you scale that winds up costing the

00:06:34,979 --> 00:06:38,280
changing the amount of money

00:06:36,390 --> 00:06:42,450
it costs the billing metric is the

00:06:38,280 --> 00:06:44,460
amount of RAM and per 100 milliseconds

00:06:42,450 --> 00:06:46,710
that the function runs for so this

00:06:44,460 --> 00:06:49,080
usually winds up being stupendously

00:06:46,710 --> 00:06:50,700
inexpensive to give you a ballpark on

00:06:49,080 --> 00:06:54,120
this if you have a function set to use

00:06:50,700 --> 00:06:56,790
one gigabyte of ram and it runs for ten

00:06:54,120 --> 00:07:01,680
thousand seconds that's gonna cost you a

00:06:56,790 --> 00:07:03,810
penny a month as a result millions of

00:07:01,680 --> 00:07:06,720
requests pass through lamda generally

00:07:03,810 --> 00:07:08,550
wind up costing you tens of dollars so

00:07:06,720 --> 00:07:10,050
the economics of this as it scales

00:07:08,550 --> 00:07:14,460
generally tends to be extremely

00:07:10,050 --> 00:07:16,500
reasonable and the CPU and network

00:07:14,460 --> 00:07:18,360
ability that alanda function has

00:07:16,500 --> 00:07:20,370
available to it scale linearly with the

00:07:18,360 --> 00:07:21,900
amount of RAM you allocate for it so

00:07:20,370 --> 00:07:24,570
give it more RAM you'll find that the

00:07:21,900 --> 00:07:25,770
CPU performance improves too you can

00:07:24,570 --> 00:07:27,270
insert some hand-waving here because

00:07:25,770 --> 00:07:27,690
there's no guarantee around how this

00:07:27,270 --> 00:07:29,760
works

00:07:27,690 --> 00:07:33,210
it's just we know it gets faster when we

00:07:29,760 --> 00:07:35,910
start playing with it there's also a

00:07:33,210 --> 00:07:37,950
hard limit of 300 seconds that a

00:07:35,910 --> 00:07:41,070
function will execute for at the end of

00:07:37,950 --> 00:07:42,600
that 300 seconds it will stop this is a

00:07:41,070 --> 00:07:44,370
fantastic way that they've managed to

00:07:42,600 --> 00:07:45,810
solve the halting problem how do you

00:07:44,370 --> 00:07:47,130
know that the functions going to nut

00:07:45,810 --> 00:07:52,920
don't run forever Oh

00:07:47,130 --> 00:07:55,050
after 300 seconds it's done and this is

00:07:52,920 --> 00:07:58,440
fun if you run a function a second time

00:07:55,050 --> 00:08:00,690
it may but it's not guaranteed to reuse

00:07:58,440 --> 00:08:02,880
the container that had just used so if

00:08:00,690 --> 00:08:04,740
you've still got an active DB connection

00:08:02,880 --> 00:08:06,630
it'll reuse it if your code is written

00:08:04,740 --> 00:08:08,760
to take advantage of it by the way

00:08:06,630 --> 00:08:10,650
surprise you get to write code that

00:08:08,760 --> 00:08:12,330
assumes that magically has to know this

00:08:10,650 --> 00:08:14,610
stuff and do all these tests it's

00:08:12,330 --> 00:08:18,150
wonderful because it's non-deterministic

00:08:14,610 --> 00:08:20,820
whether this will work or not you also

00:08:18,150 --> 00:08:23,850
wind up with half a gigabyte of scratch

00:08:20,820 --> 00:08:25,740
space in slash temp the entire rest of

00:08:23,850 --> 00:08:27,540
the filesystem is read-only which

00:08:25,740 --> 00:08:29,160
invariably surprises the living hell out

00:08:27,540 --> 00:08:30,780
of the bus the first time that we wind

00:08:29,160 --> 00:08:32,160
up trying to use this and write

00:08:30,780 --> 00:08:35,100
something to the filesystem and the

00:08:32,160 --> 00:08:36,750
function fails and I do want to

00:08:35,100 --> 00:08:38,729
apologize as you might tell I'm not much

00:08:36,750 --> 00:08:40,560
of a graphic designer here let's add

00:08:38,729 --> 00:08:44,820
some color and maybe a better font on

00:08:40,560 --> 00:08:46,860
that and maybe a background image there

00:08:44,820 --> 00:08:48,480
we go here in 2013 this is a very

00:08:46,860 --> 00:08:51,750
forward-looking talk

00:08:48,480 --> 00:08:54,660
and so we know a lot of these things are

00:08:51,750 --> 00:08:58,199
true because amazon has told us that

00:08:54,660 --> 00:09:00,060
they're true but some of it that we

00:08:58,199 --> 00:09:02,070
learned from people like Eric Hammond

00:09:00,060 --> 00:09:04,740
and other people who built functions

00:09:02,070 --> 00:09:06,839
that copy things out of the lambda

00:09:04,740 --> 00:09:08,490
environment and then we start to we can

00:09:06,839 --> 00:09:10,410
inspect them once they're here in fact

00:09:08,490 --> 00:09:12,209
there are docker containers that emulate

00:09:10,410 --> 00:09:13,920
the lambda environment that are built

00:09:12,209 --> 00:09:15,360
through this exact approach as a lambda

00:09:13,920 --> 00:09:18,420
function that's only purpose is to

00:09:15,360 --> 00:09:19,649
scrape the entire file system and throw

00:09:18,420 --> 00:09:21,800
it somewhere else that's going to

00:09:19,649 --> 00:09:25,680
survive after the function terminates

00:09:21,800 --> 00:09:29,130
and Clay Smith of New Relic wrote a

00:09:25,680 --> 00:09:31,920
lambda function that opens a reverse SSH

00:09:29,130 --> 00:09:34,529
tunnel into the lambda environment so

00:09:31,920 --> 00:09:36,870
you now have an SSH shell into the

00:09:34,529 --> 00:09:43,649
execution environment until the function

00:09:36,870 --> 00:09:45,690
terminates don't do that and if you're

00:09:43,649 --> 00:09:47,910
still unclear on lambda functions and

00:09:45,690 --> 00:09:49,920
want to learn more about it there is a

00:09:47,910 --> 00:09:52,380
developer guide that Amazon makes

00:09:49,920 --> 00:09:54,120
available if you pull it up on there to

00:09:52,380 --> 00:09:57,470
the website you can flip to the getting

00:09:54,120 --> 00:10:03,360
started section you'll find it on page

00:09:57,470 --> 00:10:05,130
174 what's on the first 173 pages oh

00:10:03,360 --> 00:10:08,550
it's just the foundational knowledge

00:10:05,130 --> 00:10:11,699
because well actually lambda is very

00:10:08,550 --> 00:10:15,839
simple and it's probably your fault if

00:10:11,699 --> 00:10:17,459
you don't understand it so not that this

00:10:15,839 --> 00:10:19,199
is complex or anything but there are

00:10:17,459 --> 00:10:21,990
entire companies and open source

00:10:19,199 --> 00:10:24,209
projects that are built around nothing

00:10:21,990 --> 00:10:26,130
other than making lambda functions and

00:10:24,209 --> 00:10:28,560
other service implementations easier to

00:10:26,130 --> 00:10:30,029
work with I'm probably missing a few

00:10:28,560 --> 00:10:31,440
that have launched in the last 20

00:10:30,029 --> 00:10:34,920
minutes since I last looked at this

00:10:31,440 --> 00:10:36,870
slide for example there's an AWS project

00:10:34,920 --> 00:10:38,730
just hit 1.0 called Challis that does

00:10:36,870 --> 00:10:41,069
the exact same thing yes an open source

00:10:38,730 --> 00:10:42,870
project written by AWS to make working

00:10:41,069 --> 00:10:44,850
with lambdas marginally less terrible

00:10:42,870 --> 00:10:48,209
everything is awful welcome to

00:10:44,850 --> 00:10:50,550
technology and the idea behind these is

00:10:48,209 --> 00:10:53,000
that they take a lot of the manual work

00:10:50,550 --> 00:10:55,260
out of building this sort of thing in a

00:10:53,000 --> 00:10:59,540
reasonable context and you just didn't

00:10:55,260 --> 00:11:01,560
click button receive function so

00:10:59,540 --> 00:11:04,380
originally I sat down

00:11:01,560 --> 00:11:06,360
to write a bunch of demos that

00:11:04,380 --> 00:11:10,560
highlighted a bunch of terrible things

00:11:06,360 --> 00:11:13,260
you could do with lambda and I had some

00:11:10,560 --> 00:11:17,940
wonderful terrible awful ideas that I

00:11:13,260 --> 00:11:19,110
thought would be funny for example one

00:11:17,940 --> 00:11:21,810
of the triggers that you can use to

00:11:19,110 --> 00:11:24,510
invoke a lambda function is you fire off

00:11:21,810 --> 00:11:27,720
a trigger by having an object appear in

00:11:24,510 --> 00:11:29,490
an s3 bucket it then appears the lambda

00:11:27,720 --> 00:11:31,529
runs it does some sort of massaging and

00:11:29,490 --> 00:11:34,980
then it can for example write an s3

00:11:31,529 --> 00:11:36,810
object somewhere else or not somewhere

00:11:34,980 --> 00:11:38,730
else you could write it back to the same

00:11:36,810 --> 00:11:42,000
place and then you've built yourself a

00:11:38,730 --> 00:11:44,130
lambda infinite loop and yes this works

00:11:42,000 --> 00:11:45,600
well it doesn't work I mean it runs

00:11:44,130 --> 00:11:46,920
forever exactly like you'd think it

00:11:45,600 --> 00:11:49,320
would and it's broken

00:11:46,920 --> 00:11:54,089
but it works as far as it won't stop you

00:11:49,320 --> 00:11:55,320
from doing this another idea I had was

00:11:54,089 --> 00:11:57,000
you can have a bunch of these things

00:11:55,320 --> 00:11:58,710
working concurrently so why not have

00:11:57,000 --> 00:12:00,450
10,000 of them all talk to the same

00:11:58,710 --> 00:12:02,460
database server at once because what

00:12:00,450 --> 00:12:05,100
could possibly go wrong seems like a

00:12:02,460 --> 00:12:09,360
good plan turns out databases don't like

00:12:05,100 --> 00:12:10,680
this why is it smell like metal and of

00:12:09,360 --> 00:12:12,690
course the ever popular idea of

00:12:10,680 --> 00:12:14,460
transpiling through a bunch of different

00:12:12,690 --> 00:12:15,870
lambda functions lambda function 2

00:12:14,460 --> 00:12:19,200
lambda function 2 lambda function 2

00:12:15,870 --> 00:12:21,390
lambda function and yes incidentally you

00:12:19,200 --> 00:12:23,610
can use bash for this and you can upload

00:12:21,390 --> 00:12:25,530
compiled binaries to get the go pieces

00:12:23,610 --> 00:12:26,670
working and the way that that winds up

00:12:25,530 --> 00:12:28,560
working is you effectively have

00:12:26,670 --> 00:12:30,390
something that written in code is more

00:12:28,560 --> 00:12:33,210
or less a one-liner that shells out or

00:12:30,390 --> 00:12:34,620
invokes the thing you just uploaded and

00:12:33,210 --> 00:12:37,170
yet lambda functions can call other

00:12:34,620 --> 00:12:39,060
lambda functions it's like a game of

00:12:37,170 --> 00:12:41,960
telephone with the express purpose of

00:12:39,060 --> 00:12:41,960
making us hate our lives

00:12:42,500 --> 00:12:48,570
and my personal favorite demonstrating

00:12:45,830 --> 00:12:51,600
large-scale projects that can be done

00:12:48,570 --> 00:12:54,330
with piecework so a fun fact is that for

00:12:51,600 --> 00:12:56,940
a long time the elasticsearch default

00:12:54,330 --> 00:13:01,110
password was changed me and I can test

00:12:56,940 --> 00:13:03,779
for this programmatically completely

00:13:01,110 --> 00:13:06,540
unrelated fact there are 4.2 billion IP

00:13:03,779 --> 00:13:10,470
addresses on the internet I can test for

00:13:06,540 --> 00:13:12,959
this with a calculator and when you

00:13:10,470 --> 00:13:14,590
combine these two facts you learn that I

00:13:12,959 --> 00:13:19,120
probably should have started writing

00:13:14,590 --> 00:13:22,120
talk sooner so little math on this it's

00:13:19,120 --> 00:13:24,100
going to be a bet over $9,000 to run

00:13:22,120 --> 00:13:28,120
this incidentally if you wind up firing

00:13:24,100 --> 00:13:30,460
this off but that's why you use someone

00:13:28,120 --> 00:13:32,650
else's AWS account for this as opposed

00:13:30,460 --> 00:13:34,210
to your own suddenly it's a lot less

00:13:32,650 --> 00:13:35,080
expensive to you personally and that's

00:13:34,210 --> 00:13:37,720
what it's all about

00:13:35,080 --> 00:13:40,090
that thousand at a time incidentally is

00:13:37,720 --> 00:13:42,400
not just an arbitrary number by default

00:13:40,090 --> 00:13:44,650
in a new AWS account that is the number

00:13:42,400 --> 00:13:46,690
of functions are allowed to run

00:13:44,650 --> 00:13:48,310
concurrently this is more or less a

00:13:46,690 --> 00:13:50,500
safety mechanism to keep you from doing

00:13:48,310 --> 00:13:54,370
something truly horrific if you ask them

00:13:50,500 --> 00:13:56,890
nicely they will raise that for you so I

00:13:54,370 --> 00:13:58,240
did I didn't have time to wait for the

00:13:56,890 --> 00:14:00,070
last since I went to the last minute I

00:13:58,240 --> 00:14:02,170
didn't have 46 days sitting around

00:14:00,070 --> 00:14:04,750
waiting for my ridiculous expensive

00:14:02,170 --> 00:14:06,850
project to complete so yeah can you

00:14:04,750 --> 00:14:08,620
please set my account to run four

00:14:06,850 --> 00:14:11,620
billion concurrent lambda functions

00:14:08,620 --> 00:14:13,810
because I want to scan the entire ipv4

00:14:11,620 --> 00:14:16,390
internet for vulnerable elasticsearch

00:14:13,810 --> 00:14:17,920
clusters at the same time and the reason

00:14:16,390 --> 00:14:23,020
is is I well I think it would be funny

00:14:17,920 --> 00:14:24,400
and as it turns out Amazon has 13

00:14:23,020 --> 00:14:26,380
leadership principles that they hire

00:14:24,400 --> 00:14:28,390
people based upon and one that isn't

00:14:26,380 --> 00:14:30,580
mentioned in those at all is a sense of

00:14:28,390 --> 00:14:32,710
humor so you can probably guess how that

00:14:30,580 --> 00:14:33,820
conversation went out and now there's a

00:14:32,710 --> 00:14:38,170
shoot to kill order on me if I ever

00:14:33,820 --> 00:14:41,020
enter Seattle again and I originally

00:14:38,170 --> 00:14:43,450
thought all this stuff was funny and it

00:14:41,020 --> 00:14:43,920
turns out I was wrong because it wasn't

00:14:43,450 --> 00:14:50,170
funny

00:14:43,920 --> 00:14:53,350
it was actively hilarious but more than

00:14:50,170 --> 00:14:55,570
AWS being spoil sports about letting me

00:14:53,350 --> 00:14:58,120
turn their flagship serverless offering

00:14:55,570 --> 00:15:00,160
into an attack platform to actively make

00:14:58,120 --> 00:15:03,340
the internet a worse place to be I had a

00:15:00,160 --> 00:15:06,280
bigger problem namely that a lot of

00:15:03,340 --> 00:15:08,740
people out there are using lambda for

00:15:06,280 --> 00:15:11,200
fascinating interesting things and they

00:15:08,740 --> 00:15:14,020
looked at my ideas for this talk and

00:15:11,200 --> 00:15:15,580
said you're adorable child here hold

00:15:14,020 --> 00:15:18,490
this for a minute I'm going to need that

00:15:15,580 --> 00:15:20,170
back so the fundamental problem here was

00:15:18,490 --> 00:15:21,790
that I wound up getting upstaged by

00:15:20,170 --> 00:15:23,640
things that people wrote put into

00:15:21,790 --> 00:15:26,440
production and signed their name to and

00:15:23,640 --> 00:15:27,320
what I found made all of the ridiculous

00:15:26,440 --> 00:15:29,900
ideas I meant

00:15:27,320 --> 00:15:33,140
previously look like contrived nonsense

00:15:29,900 --> 00:15:35,510
so haha this is funny sort of pales in

00:15:33,140 --> 00:15:37,910
comparison next - we did this and open

00:15:35,510 --> 00:15:41,390
sourced it apparently with a straight

00:15:37,910 --> 00:15:43,370
face so as a result this is now a talk

00:15:41,390 --> 00:15:45,080
about lambda versatility because I can't

00:15:43,370 --> 00:15:47,630
in good conscience get up on stage and

00:15:45,080 --> 00:15:50,720
make fun of people's hard work directly

00:15:47,630 --> 00:15:53,330
so now I'm casting this as various

00:15:50,720 --> 00:15:58,570
proofs of concept that people have done

00:15:53,330 --> 00:15:58,570
with lambda anyone know what this is

00:15:59,620 --> 00:16:03,490
don't be shy shout it out

00:16:04,240 --> 00:16:11,540
sort of usually it's wrapped in that

00:16:07,550 --> 00:16:15,050
yeah commodore 64 that is a 6502

00:16:11,540 --> 00:16:16,370
processor and given the contact with the

00:16:15,050 --> 00:16:17,990
talk I'm bringing this up in you

00:16:16,370 --> 00:16:21,200
probably know what's coming that's right

00:16:17,990 --> 00:16:23,720
someone built it you now have lambda

00:16:21,200 --> 00:16:27,230
functions that can speak in 6502

00:16:23,720 --> 00:16:28,820
assembler compared to that building a

00:16:27,230 --> 00:16:31,610
lambda that invokes itself doesn't

00:16:28,820 --> 00:16:35,600
really compare it's the 1980s are back

00:16:31,610 --> 00:16:37,370
again in the cloud it's amazing oh oh

00:16:35,600 --> 00:16:40,220
it's true it's a great learning platform

00:16:37,370 --> 00:16:42,320
it's just not shall we say a modern best

00:16:40,220 --> 00:16:43,640
practice in most shops except as one

00:16:42,320 --> 00:16:46,970
place I worked at and I still have the

00:16:43,640 --> 00:16:51,310
scars from that perhaps other folks have

00:16:46,970 --> 00:16:54,590
heard of clamavi the open source virus

00:16:51,310 --> 00:16:56,900
scanner that analyzes files to make sure

00:16:54,590 --> 00:16:59,660
that they're safe perhaps some of you

00:16:56,900 --> 00:17:02,060
run it perhaps somebody should get back

00:16:59,660 --> 00:17:04,510
to 2013 where this stuff belongs because

00:17:02,060 --> 00:17:07,939
we're talking about serverless now

00:17:04,510 --> 00:17:11,329
Airbnb wrote something called binary

00:17:07,939 --> 00:17:14,180
alert that serves the same function the

00:17:11,329 --> 00:17:17,420
idea is that you get a binary into this

00:17:14,180 --> 00:17:19,100
thing it has a bunch of rules scans the

00:17:17,420 --> 00:17:21,939
crap out of it and then returns whether

00:17:19,100 --> 00:17:25,670
this is a malicious binary or not

00:17:21,939 --> 00:17:27,890
instead of yum install clamavi like I'm

00:17:25,670 --> 00:17:30,080
some sort of ancient caribou trekking

00:17:27,890 --> 00:17:33,290
across the tundra somewhere now we can

00:17:30,080 --> 00:17:35,060
go serverless and web-scale and yes this

00:17:33,290 --> 00:17:37,400
is an actual diagram from their

00:17:35,060 --> 00:17:39,140
documentation of how it works so I have

00:17:37,400 --> 00:17:39,690
a simple tool when you can have three

00:17:39,140 --> 00:17:42,360
lambda

00:17:39,690 --> 00:17:43,950
functions s3 the simple queuing service

00:17:42,360 --> 00:17:46,620
cloud watch the simple notification

00:17:43,950 --> 00:17:49,379
service and dynamodb and a few more

00:17:46,620 --> 00:17:51,929
thrown in for fun because it this way

00:17:49,379 --> 00:17:54,539
you don't have to run servers anymore so

00:17:51,929 --> 00:17:57,120
things are great and oh by the way just

00:17:54,539 --> 00:17:58,889
like with clamavi getting the file into

00:17:57,120 --> 00:18:01,889
the system in the first place is also

00:17:58,889 --> 00:18:03,269
left as an exercise for the reader this

00:18:01,889 --> 00:18:04,590
is just a helpful reminder that when

00:18:03,269 --> 00:18:06,720
people build stuff like this it's

00:18:04,590 --> 00:18:13,080
pointing out the number one project that

00:18:06,720 --> 00:18:15,210
they're working on is their resume so

00:18:13,080 --> 00:18:17,610
this is once was fun don't be fooled

00:18:15,210 --> 00:18:20,159
this is George Porter he's an assistant

00:18:17,610 --> 00:18:22,110
professor at the UCSD computer science

00:18:20,159 --> 00:18:24,779
department and he is of course not a

00:18:22,110 --> 00:18:26,789
lambda function I have another lambda

00:18:24,779 --> 00:18:28,049
function here that told me so it's yeah

00:18:26,789 --> 00:18:31,710
training that stuff on neural networks

00:18:28,049 --> 00:18:38,039
is awesome so he wound up building a

00:18:31,710 --> 00:18:40,919
thing it turns out that John Emmons is a

00:18:38,039 --> 00:18:42,330
PhD student at Stanford and he in

00:18:40,919 --> 00:18:47,220
conjunction with the previous gentleman

00:18:42,330 --> 00:18:50,340
wrote a WS lamda face both as a proof of

00:18:47,220 --> 00:18:53,700
concept as well as got a neat toy to

00:18:50,340 --> 00:18:57,389
play with and earlier this year John

00:18:53,700 --> 00:18:59,610
went to n SDI in Boston as which is a

00:18:57,389 --> 00:19:02,129
huge Knicks conference that focuses on

00:18:59,610 --> 00:19:04,440
distributed systems and he went there as

00:19:02,129 --> 00:19:06,570
one does and he spent the day at the

00:19:04,440 --> 00:19:08,970
conference with a GoPro strapped to his

00:19:06,570 --> 00:19:11,009
head as one most assuredly does not or

00:19:08,970 --> 00:19:12,629
at least shouldn't and what's fun about

00:19:11,009 --> 00:19:14,730
that by the way is in the background you

00:19:12,629 --> 00:19:15,809
can see the Facebook sponsor banner and

00:19:14,730 --> 00:19:17,009
they're looking at him with a GoPro

00:19:15,809 --> 00:19:18,870
strapped to his head probably going

00:19:17,009 --> 00:19:21,240
amateur will show you how surveillance

00:19:18,870 --> 00:19:23,250
is done I digress so at the end of this

00:19:21,240 --> 00:19:26,850
conference he has over six hours of

00:19:23,250 --> 00:19:28,470
video from this thing and because of

00:19:26,850 --> 00:19:31,590
this talk you know where this is going

00:19:28,470 --> 00:19:33,929
from here he fired it off into a series

00:19:31,590 --> 00:19:37,200
of lambda functions to analyze each

00:19:33,929 --> 00:19:40,889
frame individually to see if it has

00:19:37,200 --> 00:19:42,899
George in it he then wound up stitching

00:19:40,889 --> 00:19:45,779
those frames back together into a video

00:19:42,899 --> 00:19:46,860
montage and we learned a few things we

00:19:45,779 --> 00:19:49,889
learned that in six hours

00:19:46,860 --> 00:19:52,139
George is willing to spend 17 seconds

00:19:49,889 --> 00:19:53,220
talking to someone at a conference with

00:19:52,139 --> 00:19:57,510
a GoPro strapped

00:19:53,220 --> 00:19:58,860
their head the point being is that when

00:19:57,510 --> 00:20:01,950
you have projects that are massively

00:19:58,860 --> 00:20:06,570
parallel izybelle lambda is an awesome

00:20:01,950 --> 00:20:08,580
and efficient tool for this stuff to

00:20:06,570 --> 00:20:12,120
break that video down from six hours to

00:20:08,580 --> 00:20:14,250
17 seconds cost $8 that includes

00:20:12,120 --> 00:20:16,110
incidentally the time of an ec2 instance

00:20:14,250 --> 00:20:17,640
that was managing these things as well

00:20:16,110 --> 00:20:20,100
because at some point you can't go

00:20:17,640 --> 00:20:21,630
purely serverless you have to admit you

00:20:20,100 --> 00:20:26,610
know some sort of master controller that

00:20:21,630 --> 00:20:28,169
works the more interesting statistic is

00:20:26,610 --> 00:20:30,450
that it took less than five minutes to

00:20:28,169 --> 00:20:31,830
consume that entire six hour video of

00:20:30,450 --> 00:20:33,809
course not including the time it takes

00:20:31,830 --> 00:20:36,409
to upload that but assuming that he was

00:20:33,809 --> 00:20:38,850
on a conference Wi-Fi at the time at

00:20:36,409 --> 00:20:42,260
certain points of scale lambda becomes

00:20:38,850 --> 00:20:42,260
an awesome and efficient tool

00:20:43,340 --> 00:20:50,669
incidentally lambda is also certified to

00:20:46,919 --> 00:20:52,110
pass PCI you can work with hippo with it

00:20:50,669 --> 00:20:53,640
so you can put yes people's private

00:20:52,110 --> 00:20:58,010
healthcare information through it and

00:20:53,640 --> 00:21:02,880
that's kind of Awesome and terrifying

00:20:58,010 --> 00:21:05,159
but in 2015 when AWS announced that

00:21:02,880 --> 00:21:07,260
lambda was now available for general use

00:21:05,159 --> 00:21:09,929
their headline was that lambda is now

00:21:07,260 --> 00:21:13,140
generally available that's also their

00:21:09,929 --> 00:21:15,210
SLA so do you guarantee three nines no

00:21:13,140 --> 00:21:18,840
but it's generally available you know

00:21:15,210 --> 00:21:23,580
except the times when it isn't and that

00:21:18,840 --> 00:21:25,830
becomes a little bit of a problem lastly

00:21:23,580 --> 00:21:29,130
I want to talk a little bit about using

00:21:25,830 --> 00:21:30,690
lambda to make people regret ever

00:21:29,130 --> 00:21:36,929
letting me near a computer in the first

00:21:30,690 --> 00:21:38,370
place let alone there's I'm gonna start

00:21:36,929 --> 00:21:40,200
with a disclaimer here this is really

00:21:38,370 --> 00:21:42,299
more for humor than something you should

00:21:40,200 --> 00:21:44,490
actually do despite the fact I have a

00:21:42,299 --> 00:21:47,520
surprisingly workable code sample coming

00:21:44,490 --> 00:21:50,820
up please don't do this please don't

00:21:47,520 --> 00:21:53,400
hate me please don't sue me okay we

00:21:50,820 --> 00:21:57,419
mentioned earlier that virtually

00:21:53,400 --> 00:21:59,370
anything can be a lambda trigger and AWS

00:21:57,419 --> 00:22:02,070
gives examples of this in demos all the

00:21:59,370 --> 00:22:03,480
time they you have an example of a

00:22:02,070 --> 00:22:04,730
warning when you hit certain spending

00:22:03,480 --> 00:22:07,280
thresholds

00:22:04,730 --> 00:22:09,049
alarms you can use it to clean up the

00:22:07,280 --> 00:22:10,490
remnants of auto-scaling groups that

00:22:09,049 --> 00:22:12,730
have since terminated you don't want all

00:22:10,490 --> 00:22:15,080
the cruft and so there as a result and

00:22:12,730 --> 00:22:17,330
obviously because they're trying to sell

00:22:15,080 --> 00:22:21,169
us things most of their examples include

00:22:17,330 --> 00:22:25,000
using the AWS api's themselves as a

00:22:21,169 --> 00:22:27,470
target for what the function can do

00:22:25,000 --> 00:22:31,040
reasonable on a completely unrelated

00:22:27,470 --> 00:22:34,580
note did you know the AWS support system

00:22:31,040 --> 00:22:38,720
has an api and you can use it to do

00:22:34,580 --> 00:22:41,150
things like open support cases maybe

00:22:38,720 --> 00:22:43,840
with a parameter like the error message

00:22:41,150 --> 00:22:47,990
that you're just getting so

00:22:43,840 --> 00:22:51,950
theoretically every time you encounter

00:22:47,990 --> 00:22:54,679
an error thrown by an Amazon API you

00:22:51,950 --> 00:22:57,500
could automatically open a support

00:22:54,679 --> 00:22:59,660
ticket in fact your try-catch blocks

00:22:57,500 --> 00:23:02,540
could open thousands of high-priority

00:22:59,660 --> 00:23:04,940
support tickets an hour and when the a

00:23:02,540 --> 00:23:07,910
support API itself starts throwing

00:23:04,940 --> 00:23:10,370
errors well you can open a ticket for

00:23:07,910 --> 00:23:14,750
that you ever wonder why Amazon support

00:23:10,370 --> 00:23:16,100
is sometimes slow to respond yeah that's

00:23:14,750 --> 00:23:18,140
me sorry

00:23:16,100 --> 00:23:24,080
forget the boy who cried wolf I'm

00:23:18,140 --> 00:23:27,380
apparently the boy who breeds them I am

00:23:24,080 --> 00:23:29,059
going to incidentally here's a link for

00:23:27,380 --> 00:23:31,130
those who care I'm about to have a

00:23:29,059 --> 00:23:32,660
bibliography of links and I don't want

00:23:31,130 --> 00:23:34,340
people have to to frantically copy those

00:23:32,660 --> 00:23:36,650
down the all of my slides for this

00:23:34,340 --> 00:23:37,880
presentation live there so if you want

00:23:36,650 --> 00:23:43,360
to go ahead and grab them feel free I

00:23:37,880 --> 00:23:45,710
will tweet it out after as well and

00:23:43,360 --> 00:23:49,100
everything that I have mentioned here so

00:23:45,710 --> 00:23:50,600
far I do have a link to rather than just

00:23:49,100 --> 00:23:52,730
don't you have to take me at my word for

00:23:50,600 --> 00:23:55,970
this I I brought the I project the type

00:23:52,730 --> 00:23:57,410
of documentation so thank you all for

00:23:55,970 --> 00:24:00,020
listening to me talk does anyone have

00:23:57,410 --> 00:24:03,470
any questions about lambda and general

00:24:00,020 --> 00:24:08,240
server lists why I'm a poor imitation at

00:24:03,470 --> 00:24:09,830
best of John Willis we also accept

00:24:08,240 --> 00:24:11,980
what's the matter with you as a valid

00:24:09,830 --> 00:24:11,980
question

00:24:12,950 --> 00:24:17,590
yeah so do a lot of people it turns out

00:24:18,460 --> 00:24:25,400
Bert I also want to thank Randall hunt

00:24:23,360 --> 00:24:28,100
who's a senior Technical Evangelist at

00:24:25,400 --> 00:24:29,510
AWS or so we thought

00:24:28,100 --> 00:24:30,980
but when I was building this I

00:24:29,510 --> 00:24:31,730
accidentally put that picture in the

00:24:30,980 --> 00:24:33,590
wrong place

00:24:31,730 --> 00:24:36,320
turns out he's 30 lambda functions

00:24:33,590 --> 00:24:38,090
wearing a hoodie in fact if you DM em on

00:24:36,320 --> 00:24:41,470
Twitter more often than not a lambda

00:24:38,090 --> 00:24:44,000
function responds that's a terrible idea

00:24:41,470 --> 00:24:45,410
this has been silence of the lambdas my

00:24:44,000 --> 00:24:47,210
name is kori Quinn I hope you've enjoyed

00:24:45,410 --> 00:24:49,300
this and please enjoy the rest of the

00:24:47,210 --> 00:24:49,300

YouTube URL: https://www.youtube.com/watch?v=WG-08BA7KbY


