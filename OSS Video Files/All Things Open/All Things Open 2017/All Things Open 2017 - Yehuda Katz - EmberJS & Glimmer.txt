Title: All Things Open 2017 - Yehuda Katz - EmberJS & Glimmer
Publication date: 2017-11-28
Playlist: All Things Open 2017
Description: 
	All Things Open 2017, Raleigh NC, Raleigh Convention Center. www.Allthingsopen.org
Captions: 
	00:00:00,000 --> 00:00:04,500
what I want to do is break these axes

00:00:01,650 --> 00:00:05,910
instead of many axes which would make

00:00:04,500 --> 00:00:08,130
this talk very boring and hard to follow

00:00:05,910 --> 00:00:11,880
I'm going to break it down into two

00:00:08,130 --> 00:00:14,309
pieces the first category is the bread

00:00:11,880 --> 00:00:16,049
and butter of the web how fast the user

00:00:14,309 --> 00:00:18,270
gets something meaningful after they tap

00:00:16,049 --> 00:00:19,740
on a link to your site with a cold cash

00:00:18,270 --> 00:00:21,810
so the first time they click on a link

00:00:19,740 --> 00:00:24,810
from Google they come to your site how

00:00:21,810 --> 00:00:27,119
fast they get that how fast they get

00:00:24,810 --> 00:00:30,570
that content so download downloading

00:00:27,119 --> 00:00:33,570
fast and addition to downloading fast we

00:00:30,570 --> 00:00:34,800
also want things to render fast and in

00:00:33,570 --> 00:00:36,660
addition to downloading and rendering

00:00:34,800 --> 00:00:38,399
fast we also want it to happen even on

00:00:36,660 --> 00:00:39,750
slow networks right so you can probably

00:00:38,399 --> 00:00:40,980
make something download very fast if you

00:00:39,750 --> 00:00:42,000
have a fast Network that should be

00:00:40,980 --> 00:00:43,920
obvious you have a fast Network

00:00:42,000 --> 00:00:45,719
downloading will be fast

00:00:43,920 --> 00:00:48,719
but more and more were truant we're

00:00:45,719 --> 00:00:50,010
dealing with slow networks the second

00:00:48,719 --> 00:00:52,649
category is actually a place where the

00:00:50,010 --> 00:00:54,899
web has traditionally struggled keeping

00:00:52,649 --> 00:00:57,480
the app nice and responsive to use once

00:00:54,899 --> 00:00:59,730
it's up and running and that what I mean

00:00:57,480 --> 00:01:02,670
by that is once you click on something

00:00:59,730 --> 00:01:03,989
it updates very quickly maintain 60fps

00:01:02,670 --> 00:01:05,220
where that matters so that's things like

00:01:03,989 --> 00:01:06,630
scrolling right when you scroll you

00:01:05,220 --> 00:01:08,430
don't want to feel jank you don't want

00:01:06,630 --> 00:01:10,530
to feel like it's breaking up as you

00:01:08,430 --> 00:01:12,330
scroll and just like we care about

00:01:10,530 --> 00:01:14,010
things being lightweight and fast and

00:01:12,330 --> 00:01:15,570
and getting up and running quickly on

00:01:14,010 --> 00:01:19,020
slow networks we care about things being

00:01:15,570 --> 00:01:21,810
responsive and updating quickly even on

00:01:19,020 --> 00:01:25,880
app on things with a slow CPU usually

00:01:21,810 --> 00:01:28,229
these two columns are in tension

00:01:25,880 --> 00:01:30,299
starting fast usually means that a bare

00:01:28,229 --> 00:01:32,100
minimum of both code and work has to be

00:01:30,299 --> 00:01:33,689
done during the initial render but

00:01:32,100 --> 00:01:35,130
staying fast actually requires being

00:01:33,689 --> 00:01:36,570
smart about how we update the Dom and

00:01:35,130 --> 00:01:38,340
usually the smarter we want to be the

00:01:36,570 --> 00:01:39,420
more code we have to load and the more

00:01:38,340 --> 00:01:42,299
we have to keep track of during the

00:01:39,420 --> 00:01:43,439
initial render right so we have we want

00:01:42,299 --> 00:01:44,729
to make the initial render as fast as

00:01:43,439 --> 00:01:46,649
possible which means getting as much as

00:01:44,729 --> 00:01:48,119
possible out of that path but at the

00:01:46,649 --> 00:01:49,860
same time in order to make things fast

00:01:48,119 --> 00:01:51,600
to update we need to keep track of what

00:01:49,860 --> 00:01:55,920
we did the first time around and that's

00:01:51,600 --> 00:01:59,340
just a tricky thing to do to do in a to

00:01:55,920 --> 00:02:00,960
do together so games do a really great

00:01:59,340 --> 00:02:02,790
job with responsiveness you get really

00:02:00,960 --> 00:02:04,439
incredibly immersive experiences running

00:02:02,790 --> 00:02:06,479
on modern consoles and even mobile

00:02:04,439 --> 00:02:08,399
devices without with hardly a hiccup

00:02:06,479 --> 00:02:10,140
bomb I played some games on my mobile

00:02:08,399 --> 00:02:12,270
phones and once I'm getting up and

00:02:10,140 --> 00:02:14,120
running usually it's pretty quick as

00:02:12,270 --> 00:02:17,909
long as it's a modern mobile

00:02:14,120 --> 00:02:20,400
however it comes at a cost the dreaded

00:02:17,909 --> 00:02:22,530
loading screen for those of you who play

00:02:20,400 --> 00:02:24,060
video games in order to keep things

00:02:22,530 --> 00:02:25,950
running quickly once you start playing

00:02:24,060 --> 00:02:27,510
what games do is they subject their

00:02:25,950 --> 00:02:29,400
users to extremely long loading times

00:02:27,510 --> 00:02:30,750
sometimes people need to wait literally

00:02:29,400 --> 00:02:32,549
minutes of loading time to keep things

00:02:30,750 --> 00:02:34,079
smooth when I was googling for this

00:02:32,549 --> 00:02:35,730
image I found people on reddit saying

00:02:34,079 --> 00:02:37,319
I've waited literally minutes and people

00:02:35,730 --> 00:02:41,010
I had just keep waiting it's probably

00:02:37,319 --> 00:02:43,319
fine so basically what games are doing

00:02:41,010 --> 00:02:44,819
is they know that they can expect our

00:02:43,319 --> 00:02:46,650
users to wait for a very very long

00:02:44,819 --> 00:02:49,200
period of time in order to get things

00:02:46,650 --> 00:02:50,700
going and in exchange for that they make

00:02:49,200 --> 00:02:54,030
things very responsive once things are

00:02:50,700 --> 00:02:55,590
up and running on the flip side what the

00:02:54,030 --> 00:02:57,690
web is focused on is getting content on

00:02:55,590 --> 00:02:59,939
the screen as fast as possible on a

00:02:57,690 --> 00:03:01,109
desktop forget about minutes if you

00:02:59,939 --> 00:03:02,700
don't get the content up in a matter of

00:03:01,109 --> 00:03:06,329
seconds your users are going to leave

00:03:02,700 --> 00:03:08,970
and as Alex Russell said here he works

00:03:06,329 --> 00:03:11,099
at at Google on web standards and chrome

00:03:08,970 --> 00:03:13,049
he said the web superpower is that it's

00:03:11,099 --> 00:03:16,200
so good at this kind of ephemeral usage

00:03:13,049 --> 00:03:17,489
right so we have ephemeral use is a main

00:03:16,200 --> 00:03:20,669
use case of the web it's actually a very

00:03:17,489 --> 00:03:21,959
unique thing about the web and while

00:03:20,669 --> 00:03:23,819
users of native apps are willing to

00:03:21,959 --> 00:03:26,849
tolerate literally minutes of initial

00:03:23,819 --> 00:03:29,790
installation as Alex said here he said

00:03:26,849 --> 00:03:31,909
you react native and Cordova spots you

00:03:29,790 --> 00:03:34,019
first run via heavyweight install step

00:03:31,909 --> 00:03:36,419
web applications actually don't have

00:03:34,019 --> 00:03:37,739
that luxury and in addition to web

00:03:36,419 --> 00:03:39,209
applications normally not having that

00:03:37,739 --> 00:03:41,190
luxury the kind that we may have written

00:03:39,209 --> 00:03:43,709
ten years ago the situation is actually

00:03:41,190 --> 00:03:45,299
getting worse not better in emerging

00:03:43,709 --> 00:03:48,329
markets which provides sort of anti

00:03:45,299 --> 00:03:49,819
Moore's Law effect what's happening is

00:03:48,329 --> 00:03:51,720
that the internet and computing is

00:03:49,819 --> 00:03:54,180
expanding into more more parts of the

00:03:51,720 --> 00:03:56,519
world maybe someday we'll be every 100%

00:03:54,180 --> 00:03:58,470
of the world but every time we expand

00:03:56,519 --> 00:04:00,419
into a new area those new users have

00:03:58,470 --> 00:04:02,819
worse connectivity and slower devices

00:04:00,419 --> 00:04:04,349
than the existing users right so if we

00:04:02,819 --> 00:04:05,669
want to reach those users without giving

00:04:04,349 --> 00:04:07,049
up on building the client kind of

00:04:05,669 --> 00:04:08,790
ambitious products we want to build on

00:04:07,049 --> 00:04:10,379
the web we actually need to find ways to

00:04:08,790 --> 00:04:11,760
do more with less

00:04:10,379 --> 00:04:13,500
and it goes without saying that slow

00:04:11,760 --> 00:04:15,299
connectivity isn't just a problem for

00:04:13,500 --> 00:04:17,159
emerging markets every time you drive

00:04:15,299 --> 00:04:19,349
into a tunnel or take the subway or

00:04:17,159 --> 00:04:20,489
leave a major urban area you have to

00:04:19,349 --> 00:04:22,440
deal with the same kinds of constraints

00:04:20,489 --> 00:04:24,210
millions of people in the United States

00:04:22,440 --> 00:04:27,180
buy phones every year that have very

00:04:24,210 --> 00:04:29,130
limited CPU capacity and sometimes

00:04:27,180 --> 00:04:31,620
poor network connectivity there's many

00:04:29,130 --> 00:04:33,810
places in the country with that problem

00:04:31,620 --> 00:04:35,669
so bottom line the issues of slow

00:04:33,810 --> 00:04:37,169
connectivity and limited CPU capacity

00:04:35,669 --> 00:04:39,270
aren't going anywhere for a long time

00:04:37,169 --> 00:04:41,669
we're gonna continue to expand the

00:04:39,270 --> 00:04:43,139
internet and accessibility to more and

00:04:41,669 --> 00:04:44,850
more places but there's always the next

00:04:43,139 --> 00:04:46,800
frontier that's gonna have slower

00:04:44,850 --> 00:04:47,759
devices slower connectivity and that's

00:04:46,800 --> 00:04:51,990
just gonna be happening for the

00:04:47,759 --> 00:04:53,300
foreseeable future until we fully until

00:04:51,990 --> 00:04:56,970
and unless we fully coat the entire

00:04:53,300 --> 00:04:59,070
world with very fast internet and very

00:04:56,970 --> 00:05:00,900
fast devices we're gonna have a number

00:04:59,070 --> 00:05:04,250
of people in the world who have who need

00:05:00,900 --> 00:05:06,960
to deal with these these constraints and

00:05:04,250 --> 00:05:09,060
III the reason I brought up the stuff

00:05:06,960 --> 00:05:10,650
about going into a tunnel or whatever is

00:05:09,060 --> 00:05:12,120
that I think it may be the case that we

00:05:10,650 --> 00:05:14,190
never try to solve that problem it could

00:05:12,120 --> 00:05:15,960
be that there are some places you go

00:05:14,190 --> 00:05:17,430
into a cave there's some suburban or

00:05:15,960 --> 00:05:20,580
rural areas that we just never worry

00:05:17,430 --> 00:05:22,889
that hard about making wireless

00:05:20,580 --> 00:05:24,960
connectivity fast I don't I don't know

00:05:22,889 --> 00:05:26,639
whether we will or not but it's

00:05:24,960 --> 00:05:27,870
certainly a long way off before we even

00:05:26,639 --> 00:05:29,280
know the answer to that question so for

00:05:27,870 --> 00:05:31,740
the foreseeable future if we want to be

00:05:29,280 --> 00:05:32,729
building good applications that work for

00:05:31,740 --> 00:05:36,389
a lot of people we have to deal with

00:05:32,729 --> 00:05:37,889
these problems and frankly we're not

00:05:36,389 --> 00:05:40,979
gonna be able to ask web developers to

00:05:37,889 --> 00:05:42,389
shoulder this burden on their own web

00:05:40,979 --> 00:05:44,580
application development as I said before

00:05:42,389 --> 00:05:47,340
is already extremely challenging most

00:05:44,580 --> 00:05:48,900
developers including me don't have a lot

00:05:47,340 --> 00:05:50,550
of time to be thinking about applying

00:05:48,900 --> 00:05:51,570
performance incantations on top of all

00:05:50,550 --> 00:05:54,389
the other things that you have to be

00:05:51,570 --> 00:05:56,130
doing day in and day out like what I

00:05:54,389 --> 00:05:58,349
basically am doing is adding features to

00:05:56,130 --> 00:06:00,120
a product I work really hard to add

00:05:58,349 --> 00:06:02,820
features I work really hard to make them

00:06:00,120 --> 00:06:05,940
good but on top between having to you

00:06:02,820 --> 00:06:07,500
know know CSS and get the Java scripts

00:06:05,940 --> 00:06:09,180
to work in the first place and think

00:06:07,500 --> 00:06:10,710
about all the nitty-gritty details about

00:06:09,180 --> 00:06:12,210
the design work with designers that's

00:06:10,710 --> 00:06:13,919
basically my entire day I don't really

00:06:12,210 --> 00:06:16,770
have a lot of time to be thinking about

00:06:13,919 --> 00:06:18,419
all these other additional things so if

00:06:16,770 --> 00:06:19,740
we want to build applique so so what

00:06:18,419 --> 00:06:21,120
most people do is they just scale down

00:06:19,740 --> 00:06:23,099
their ambition but like I said I'm not

00:06:21,120 --> 00:06:25,560
that kind of person if we want to build

00:06:23,099 --> 00:06:28,020
applications that are ambitious and

00:06:25,560 --> 00:06:29,789
accessible at the same time we actually

00:06:28,020 --> 00:06:31,409
need to find ways to have tools that can

00:06:29,789 --> 00:06:32,909
achieve good performance by default so

00:06:31,409 --> 00:06:34,650
we need to have tools that are fast

00:06:32,909 --> 00:06:37,440
without asking the users to do a lot of

00:06:34,650 --> 00:06:39,539
work to make things be fast and maybe at

00:06:37,440 --> 00:06:40,950
this point you you might be asking is

00:06:39,539 --> 00:06:43,350
that even possible um

00:06:40,950 --> 00:06:45,390
as we saw games achieve runtime

00:06:43,350 --> 00:06:48,600
responsiveness by maker by making users

00:06:45,390 --> 00:06:50,070
wait forever as they load and native

00:06:48,600 --> 00:06:51,480
applications achieve runtime

00:06:50,070 --> 00:06:52,800
responsiveness by making users wait

00:06:51,480 --> 00:06:54,870
literally minutes for the initial

00:06:52,800 --> 00:06:59,400
installation so maybe there's not much

00:06:54,870 --> 00:07:00,780
we can do to be responsive to get the to

00:06:59,400 --> 00:07:02,370
make things feel good once they're

00:07:00,780 --> 00:07:04,050
running at the same time as we get

00:07:02,370 --> 00:07:05,250
things on the page maybe that's just the

00:07:04,050 --> 00:07:08,010
price you have to pay for being the web

00:07:05,250 --> 00:07:11,370
we have to take the fast content side

00:07:08,010 --> 00:07:12,630
and give up on the nice app side but

00:07:11,370 --> 00:07:15,660
maybe there is something that we can do

00:07:12,630 --> 00:07:18,860
to achieve them to achieve that goal

00:07:15,660 --> 00:07:21,960
without giving up the super power and

00:07:18,860 --> 00:07:23,340
basically that leads into the point of

00:07:21,960 --> 00:07:25,260
the the talk here which is that the

00:07:23,340 --> 00:07:28,260
solution in my view is to compile away

00:07:25,260 --> 00:07:29,490
the runtime so the programmer has to be

00:07:28,260 --> 00:07:31,230
able to have all the tools if you think

00:07:29,490 --> 00:07:33,270
about like what a programmer has access

00:07:31,230 --> 00:07:34,740
to when they write using cocoa or

00:07:33,270 --> 00:07:36,960
Android studio there's a lot of stuff

00:07:34,740 --> 00:07:38,670
going on and those when those

00:07:36,960 --> 00:07:40,110
programming models but you don't have to

00:07:38,670 --> 00:07:41,460
actually every application doesn't have

00:07:40,110 --> 00:07:42,420
to include them although they could

00:07:41,460 --> 00:07:47,160
probably get away with it if they have

00:07:42,420 --> 00:07:49,050
to we we neither have the cocoa runtime

00:07:47,160 --> 00:07:52,050
nor can we get away with shipping it so

00:07:49,050 --> 00:07:53,490
we need to find ways of having a very

00:07:52,050 --> 00:07:56,520
robust programming model that's fast by

00:07:53,490 --> 00:07:59,550
default but also compiles away at

00:07:56,520 --> 00:08:01,980
compile time and in order to accomplish

00:07:59,550 --> 00:08:03,060
those twin goals of responsiveness and

00:08:01,980 --> 00:08:04,320
small payloads this is something we've

00:08:03,060 --> 00:08:06,330
been thinking about for a very long time

00:08:04,320 --> 00:08:09,900
we built a thing called a rendering

00:08:06,330 --> 00:08:12,300
engine called the glimmer VM and yes the

00:08:09,900 --> 00:08:13,830
glimmer uses both a compiler and a VM

00:08:12,300 --> 00:08:15,420
architecture to achieve its performance

00:08:13,830 --> 00:08:18,810
goals like I said earlier and we'll see

00:08:15,420 --> 00:08:20,970
why soon first just what is glimmer for

00:08:18,810 --> 00:08:22,140
people who didn't already know glimmer

00:08:20,970 --> 00:08:24,180
is the rendering engine that's used

00:08:22,140 --> 00:08:26,760
inside of ember it's actually embers

00:08:24,180 --> 00:08:28,140
third rendering engine but embers

00:08:26,760 --> 00:08:30,030
template syntax has remained largely

00:08:28,140 --> 00:08:31,920
compatible the entire time as we've

00:08:30,030 --> 00:08:33,420
improved the infrastructure ember is

00:08:31,920 --> 00:08:35,700
meant to be used for a full-fledged

00:08:33,420 --> 00:08:37,320
applications and one thing that happened

00:08:35,700 --> 00:08:38,280
as we continued to improve the rendering

00:08:37,320 --> 00:08:39,660
engine and people got more and more

00:08:38,280 --> 00:08:43,190
excited about the rendering engine and

00:08:39,660 --> 00:08:46,710
maybe less and less excited about ember

00:08:43,190 --> 00:08:49,140
people wanted to use glimmer in more

00:08:46,710 --> 00:08:51,270
context more standalone context so last

00:08:49,140 --> 00:08:52,980
year we released a thing called glimmer

00:08:51,270 --> 00:08:54,450
J's which is basically a standalone

00:08:52,980 --> 00:08:54,690
version of just a rendering engine that

00:08:54,450 --> 00:08:57,540
you can

00:08:54,690 --> 00:08:58,710
in more places without without having to

00:08:57,540 --> 00:09:00,720
bring along the entire Ember

00:08:58,710 --> 00:09:02,550
our mission for that project is

00:09:00,720 --> 00:09:03,870
eventually that you can NPM your way

00:09:02,550 --> 00:09:04,740
from glimmer jazz to ember and that's

00:09:03,870 --> 00:09:09,420
still something that we're actively

00:09:04,740 --> 00:09:12,330
working on so additionally glimmer j/s

00:09:09,420 --> 00:09:13,890
is still pre 1.0 but the thing that is

00:09:12,330 --> 00:09:15,210
really great about glimmer jazz existing

00:09:13,890 --> 00:09:16,290
is that it allowed us to experiment with

00:09:15,210 --> 00:09:18,240
basically everything else that's in the

00:09:16,290 --> 00:09:19,680
rest of my talk right so because ember

00:09:18,240 --> 00:09:21,570
has such very strong has such strong

00:09:19,680 --> 00:09:23,040
compatibility requirements we don't have

00:09:21,570 --> 00:09:25,620
as much room to maneuver in terms of

00:09:23,040 --> 00:09:27,780
experimenting with users applications

00:09:25,620 --> 00:09:29,160
but glimmer J has allowed us to have a

00:09:27,780 --> 00:09:34,130
sort of end to end story that let us

00:09:29,160 --> 00:09:36,270
experiment with a lot of cool stuff so

00:09:34,130 --> 00:09:37,770
getting a little bit into the technical

00:09:36,270 --> 00:09:40,740
details here here's an example of a

00:09:37,770 --> 00:09:42,060
glimmer J s component glimmer J's has a

00:09:40,740 --> 00:09:44,460
really nice modern and mineral

00:09:42,060 --> 00:09:45,840
minimalist component API you don't have

00:09:44,460 --> 00:09:47,400
to mess around with observers or

00:09:45,840 --> 00:09:48,690
bindings or set State or anything you

00:09:47,400 --> 00:09:50,130
just tell us which properties might

00:09:48,690 --> 00:09:51,750
change with the track decorator and

00:09:50,130 --> 00:09:53,220
anytime you change that property using

00:09:51,750 --> 00:09:55,950
normal JavaScript syntax we will update

00:09:53,220 --> 00:09:57,840
the Dom for you glimmer uses handlebars

00:09:55,950 --> 00:09:59,850
templates which is the thing on the left

00:09:57,840 --> 00:10:01,320
side to describe each components Dom

00:09:59,850 --> 00:10:03,750
output so if you're familiar with react

00:10:01,320 --> 00:10:07,290
a template is basically the same thing

00:10:03,750 --> 00:10:08,190
as a render function and react now a lot

00:10:07,290 --> 00:10:09,480
of people want to tell you that

00:10:08,190 --> 00:10:10,890
templates are fundamentally less

00:10:09,480 --> 00:10:12,450
powerful they're like training wheels

00:10:10,890 --> 00:10:14,820
until you reach level 19 enlightenment

00:10:12,450 --> 00:10:16,470
of doing everything in JavaScript but if

00:10:14,820 --> 00:10:18,090
rendering costs dominate the performance

00:10:16,470 --> 00:10:19,350
of most web application doesn't it make

00:10:18,090 --> 00:10:20,880
sense to have a language that's designed

00:10:19,350 --> 00:10:22,560
to optimize for that and that's

00:10:20,880 --> 00:10:25,560
basically what handlebars and glimmer

00:10:22,560 --> 00:10:26,970
are the key thing to understand about

00:10:25,560 --> 00:10:29,280
glimmer the key inside of glimmer is

00:10:26,970 --> 00:10:30,630
that handlebars as a language is not

00:10:29,280 --> 00:10:31,830
just a templating engine it's a

00:10:30,630 --> 00:10:33,390
declarative functional programming

00:10:31,830 --> 00:10:35,370
language we're building and updating the

00:10:33,390 --> 00:10:39,089
Dom it wasn't that when I made

00:10:35,370 --> 00:10:40,890
handlebars in the first place in 2009 I

00:10:39,089 --> 00:10:42,089
think but somewhere along the way it

00:10:40,890 --> 00:10:43,770
changed from being a string

00:10:42,089 --> 00:10:44,790
concatenation engine to a declarative

00:10:43,770 --> 00:10:47,190
functional programming language for

00:10:44,790 --> 00:10:49,050
building and updating Dom in this sense

00:10:47,190 --> 00:10:50,940
it has more in common with something

00:10:49,050 --> 00:10:52,350
like elm than the string concatenation

00:10:50,940 --> 00:10:55,080
libraries people usually think about

00:10:52,350 --> 00:10:56,580
when they think about templates so what

00:10:55,080 --> 00:10:57,839
happens if we view glimmer through the

00:10:56,580 --> 00:10:59,339
lens of a functional programming

00:10:57,839 --> 00:11:02,250
language specialized for producing and

00:10:59,339 --> 00:11:04,589
updating Dom let's take a look at the

00:11:02,250 --> 00:11:06,089
high-level architecture the first thing

00:11:04,589 --> 00:11:07,410
to note is that it's quite different for

00:11:06,089 --> 00:11:09,269
what most people think of when they

00:11:07,410 --> 00:11:12,060
think of a JavaScript library

00:11:09,269 --> 00:11:13,680
it's not mostly doing things in the

00:11:12,060 --> 00:11:16,440
browser the bulk of glimmers code is in

00:11:13,680 --> 00:11:17,670
its compiler our goal is both to reduce

00:11:16,440 --> 00:11:18,870
the amount of code sent to the browser

00:11:17,670 --> 00:11:20,760
as well as the amount of work it has to

00:11:18,870 --> 00:11:22,529
do once it gets there so to accomplish

00:11:20,760 --> 00:11:26,910
that we move as much as we can into the

00:11:22,529 --> 00:11:28,170
compilation step so the glimmer compiler

00:11:26,910 --> 00:11:30,360
takes in all the components in your

00:11:28,170 --> 00:11:32,760
application at once so your application

00:11:30,360 --> 00:11:34,529
any real applications gonna have

00:11:32,760 --> 00:11:37,470
probably hundreds of components but

00:11:34,529 --> 00:11:39,600
maybe at least dozens takes them all in

00:11:37,470 --> 00:11:41,250
all at once parses them and turns them

00:11:39,600 --> 00:11:43,050
into an executable program that will run

00:11:41,250 --> 00:11:48,510
in the browser building and updating

00:11:43,050 --> 00:11:50,640
your Dom so what kind of program does it

00:11:48,510 --> 00:11:52,890
turn them into so for example babel

00:11:50,640 --> 00:11:55,140
turns JSX into JavaScript and spelt

00:11:52,890 --> 00:11:56,700
turns templates into JavaScript glimmer

00:11:55,140 --> 00:11:59,930
on the other hand compiles them into

00:11:56,700 --> 00:12:02,040
something called glimmer byte code

00:11:59,930 --> 00:12:04,260
glimmer byte code is a binary format

00:12:02,040 --> 00:12:05,670
that efficiently and I'll talk a little

00:12:04,260 --> 00:12:06,660
bit more later about why there's a

00:12:05,670 --> 00:12:08,190
difference between compiling to

00:12:06,660 --> 00:12:10,500
JavaScript and compiling to bytecode why

00:12:08,190 --> 00:12:12,990
it's more than just a cool technical

00:12:10,500 --> 00:12:14,850
trick so a glimmer bytecode is a binary

00:12:12,990 --> 00:12:17,180
format that efficiently encodes DOM and

00:12:14,850 --> 00:12:19,769
component related operations so it's not

00:12:17,180 --> 00:12:21,720
just a simple bytecode like if you were

00:12:19,769 --> 00:12:23,850
gonna take a lisp class and write a list

00:12:21,720 --> 00:12:25,380
by code it's really a specialized VM

00:12:23,850 --> 00:12:28,199
specialized by code that's designed for

00:12:25,380 --> 00:12:31,589
talking about things that we do in the

00:12:28,199 --> 00:12:33,750
browser and here is some an example of a

00:12:31,589 --> 00:12:38,940
real-world template compiled into a

00:12:33,750 --> 00:12:40,560
real-world op codes so what happens is

00:12:38,940 --> 00:12:42,269
this bytecode is executed on top of the

00:12:40,560 --> 00:12:44,730
glimmer VM it's a small runtime that's

00:12:42,269 --> 00:12:47,070
included with the application today we

00:12:44,730 --> 00:12:49,680
got the run to the VM down to about 18

00:12:47,070 --> 00:12:50,790
kilobytes with Brantly compression but

00:12:49,680 --> 00:12:52,860
we're confident that we can get this

00:12:50,790 --> 00:12:54,290
down to at least 10k in the in the near

00:12:52,860 --> 00:12:57,329
term

00:12:54,290 --> 00:12:59,610
so today the glimmer runtime itself is

00:12:57,329 --> 00:13:01,380
very small like I said we have plants

00:12:59,610 --> 00:13:04,529
make it even smaller but the bigger deal

00:13:01,380 --> 00:13:06,570
then the templating engine being small

00:13:04,529 --> 00:13:08,550
is templates the templates themselves

00:13:06,570 --> 00:13:09,630
are very small over the wire and in

00:13:08,550 --> 00:13:11,820
practice if you look at real

00:13:09,630 --> 00:13:14,070
applications templates or render

00:13:11,820 --> 00:13:15,570
functions and react they actually

00:13:14,070 --> 00:13:17,040
dominate app size so if you look at an

00:13:15,570 --> 00:13:18,660
application the vast majority of the

00:13:17,040 --> 00:13:20,160
code in your application is actually

00:13:18,660 --> 00:13:22,079
going to end up being those render

00:13:20,160 --> 00:13:22,450
functions or those templates so winds

00:13:22,079 --> 00:13:24,610
intent

00:13:22,450 --> 00:13:25,840
sighs make a big difference so I've been

00:13:24,610 --> 00:13:27,490
talking a little bit about stuff we've

00:13:25,840 --> 00:13:30,160
been doing for the second version of the

00:13:27,490 --> 00:13:31,870
of the template format the binary

00:13:30,160 --> 00:13:33,310
template format but the first version

00:13:31,870 --> 00:13:35,170
which actually did less things even that

00:13:33,310 --> 00:13:37,570
I'm talking about here got a pretty big

00:13:35,170 --> 00:13:40,480
win we shifted an ember I think last

00:13:37,570 --> 00:13:42,970
year or earlier this year last year it

00:13:40,480 --> 00:13:44,100
says 1 December and a lot of people

00:13:42,970 --> 00:13:47,350
reported that they got something like

00:13:44,100 --> 00:13:48,910
50% improvements in their app size total

00:13:47,350 --> 00:13:50,980
app size so that basically illustrates

00:13:48,910 --> 00:13:53,500
how true it is that there's so that

00:13:50,980 --> 00:13:55,720
people's templates are such a big chunk

00:13:53,500 --> 00:13:57,900
of their application so that was that

00:13:55,720 --> 00:14:05,140
was v1 we're actually doing more in v2

00:13:57,900 --> 00:14:06,850
and so v1 so so size getting your

00:14:05,140 --> 00:14:08,650
template smaller is nice it means you

00:14:06,850 --> 00:14:10,360
have to download less things but there's

00:14:08,650 --> 00:14:12,670
actually a bigger problem with

00:14:10,360 --> 00:14:14,800
downloading things than just downloading

00:14:12,670 --> 00:14:17,020
things over the network there's also the

00:14:14,800 --> 00:14:18,880
time it takes to parse javascript in the

00:14:17,020 --> 00:14:20,620
browser and you probably think oh like

00:14:18,880 --> 00:14:23,590
parsing that seems like a small step

00:14:20,620 --> 00:14:24,970
it's probably pretty quick but there's

00:14:23,590 --> 00:14:26,770
actually a really good blog post that

00:14:24,970 --> 00:14:28,390
addy osmani of Google did last year

00:14:26,770 --> 00:14:30,130
where he did an analysis of like what

00:14:28,390 --> 00:14:31,480
actually takes all the time when you're

00:14:30,130 --> 00:14:32,950
booting an application because the

00:14:31,480 --> 00:14:34,600
Google is really interested in trying to

00:14:32,950 --> 00:14:37,090
get people to reduce the amount of time

00:14:34,600 --> 00:14:39,250
and what he found was that parse and

00:14:37,090 --> 00:14:40,690
compile take up a huge percentage of the

00:14:39,250 --> 00:14:42,250
total time in some cases they might even

00:14:40,690 --> 00:14:43,870
take up more time than the actual time

00:14:42,250 --> 00:14:45,850
takes to execute the JavaScript in the

00:14:43,870 --> 00:14:49,150
first place like in this example and

00:14:45,850 --> 00:14:52,030
mobile phones even like good mobile

00:14:49,150 --> 00:14:54,580
phones like the pixel also take a huge

00:14:52,030 --> 00:14:56,380
amount of time so this is this is a

00:14:54,580 --> 00:14:58,630
mobile phone with a slower CPU and it

00:14:56,380 --> 00:15:00,970
takes something like over a second where

00:14:58,630 --> 00:15:03,640
the desktop takes about 200 milliseconds

00:15:00,970 --> 00:15:05,500
and and even faster phones take more

00:15:03,640 --> 00:15:07,120
than 200 milliseconds so parse and

00:15:05,500 --> 00:15:08,800
compile could take multiple seconds and

00:15:07,120 --> 00:15:12,370
since your target is seconds this is

00:15:08,800 --> 00:15:13,900
really a huge amount of time this is

00:15:12,370 --> 00:15:15,550
basically something that all frameworks

00:15:13,900 --> 00:15:18,040
have seen so emperor saw this a few

00:15:15,550 --> 00:15:19,930
years ago but sebastian mark badge who

00:15:18,040 --> 00:15:22,270
was on the core team he's one of the

00:15:19,930 --> 00:15:23,710
main people who works on react tweeted

00:15:22,270 --> 00:15:26,020
last year that parsing and compiling is

00:15:23,710 --> 00:15:27,790
a huge problem and he was talking about

00:15:26,020 --> 00:15:29,290
trying to get more get them to talk

00:15:27,790 --> 00:15:31,900
about it more and if you follow him he's

00:15:29,290 --> 00:15:33,100
talked a lot about it so parsing and

00:15:31,900 --> 00:15:35,540
compiling that's a huge problem for

00:15:33,100 --> 00:15:37,899
javascript frameworks

00:15:35,540 --> 00:15:39,829
this is something that everyone saw so

00:15:37,899 --> 00:15:41,300
remember our goal is not just to make

00:15:39,829 --> 00:15:43,009
applications snappy once they're running

00:15:41,300 --> 00:15:44,389
which is what Jets are good at so the

00:15:43,009 --> 00:15:46,699
you know the JavaScript JIT once you're

00:15:44,389 --> 00:15:48,620
running it's great just know JavaScript

00:15:46,699 --> 00:15:50,029
runs pretty fast but we also need to get

00:15:48,620 --> 00:15:52,639
content on the screen quickly so we need

00:15:50,029 --> 00:15:53,750
to do something about parsing and you

00:15:52,639 --> 00:15:55,220
might have guessed based on what I've

00:15:53,750 --> 00:15:57,050
said so far what the answer to our

00:15:55,220 --> 00:15:58,459
problem is that which is that we can use

00:15:57,050 --> 00:16:00,529
the compiler to do the work outside of

00:15:58,459 --> 00:16:02,240
the browser so instead of doing the

00:16:00,529 --> 00:16:03,380
parsing and compiling inside the browser

00:16:02,240 --> 00:16:04,819
what if we could do the parsing and

00:16:03,380 --> 00:16:06,709
compiling outside of the browser and

00:16:04,819 --> 00:16:08,480
what does that mean so I've talked a

00:16:06,709 --> 00:16:10,730
little bit about it but I want to go

00:16:08,480 --> 00:16:11,959
into a little more detail here so here

00:16:10,730 --> 00:16:14,690
here's the template that we've been

00:16:11,959 --> 00:16:17,000
looking at so far and I want to talk

00:16:14,690 --> 00:16:19,430
about what exactly it means and then in

00:16:17,000 --> 00:16:22,579
a minute I'll show you a real world demo

00:16:19,430 --> 00:16:24,620
so first of all anything that's like a

00:16:22,579 --> 00:16:26,420
string so if we look at this template

00:16:24,620 --> 00:16:27,680
there's things like current weather New

00:16:26,420 --> 00:16:30,199
York New York right anything that looks

00:16:27,680 --> 00:16:31,850
like a string gets stored in JSON JSON

00:16:30,199 --> 00:16:33,949
is much faster to parse than JavaScript

00:16:31,850 --> 00:16:35,480
for obvious reasons and more importantly

00:16:33,949 --> 00:16:37,370
you can actually parse JSON off the main

00:16:35,480 --> 00:16:39,290
thread so if you use a fetch and tell

00:16:37,370 --> 00:16:41,209
the browser that it's JSON it actually

00:16:39,290 --> 00:16:43,069
does the parsing of the of the JSON off

00:16:41,209 --> 00:16:46,250
the main thread so there's no blocking

00:16:43,069 --> 00:16:49,069
at all waiting for the JSON and but more

00:16:46,250 --> 00:16:50,839
and that's that's a chunk of stuff but

00:16:49,069 --> 00:16:52,519
it's actually not the bulk of it the

00:16:50,839 --> 00:16:54,290
bulk of it is the actual program and the

00:16:52,519 --> 00:16:56,300
program itself is byte codes it's just a

00:16:54,290 --> 00:16:57,800
bunch of binary and there's no parse of

00:16:56,300 --> 00:16:59,720
that at all as soon as we get the bytes

00:16:57,800 --> 00:17:01,310
in the browser we're ready to go right

00:16:59,720 --> 00:17:03,139
it's just it's just a bunch of bytes in

00:17:01,310 --> 00:17:04,250
a buffer and when we when it when we're

00:17:03,139 --> 00:17:05,540
going to render we just jumped to

00:17:04,250 --> 00:17:08,000
someplace in the buffer and just start

00:17:05,540 --> 00:17:10,400
running the VM so what that means is

00:17:08,000 --> 00:17:11,839
that all these templates that in older

00:17:10,400 --> 00:17:14,150
versions of ember and a lot of other

00:17:11,839 --> 00:17:16,459
frameworks are JavaScript even spelt

00:17:14,150 --> 00:17:18,319
which you know also boils away the

00:17:16,459 --> 00:17:19,610
runtime compiles the JavaScript all

00:17:18,319 --> 00:17:21,079
these templates don't actually have any

00:17:19,610 --> 00:17:23,240
parsing or any compile time at all

00:17:21,079 --> 00:17:25,100
because we compile them already into

00:17:23,240 --> 00:17:29,210
something that that we can run on our

00:17:25,100 --> 00:17:30,799
own VM so and like I said that's the

00:17:29,210 --> 00:17:32,480
bulk of your application code as soon as

00:17:30,799 --> 00:17:33,710
we have the bytes all ready to go so let

00:17:32,480 --> 00:17:33,890
me show you a demo of what that looks

00:17:33,710 --> 00:17:35,990
like

00:17:33,890 --> 00:17:39,590
first I'm gonna just show you I'm gonna

00:17:35,990 --> 00:17:42,530
compare glimmer to pre-act now as I said

00:17:39,590 --> 00:17:45,140
before the glimmer VM is 18 K and

00:17:42,530 --> 00:17:46,760
pre-act is 3 K so obviously we have a

00:17:45,140 --> 00:17:49,310
look it's a little tricky for us to be

00:17:46,760 --> 00:17:53,170
competitive here

00:17:49,310 --> 00:17:54,530
so let me start so this is basically it

00:17:53,170 --> 00:17:56,960
there we go

00:17:54,530 --> 00:17:58,820
so what we did is we took a bunch of

00:17:56,960 --> 00:18:00,230
Wikipedia pages and turn them into

00:17:58,820 --> 00:18:03,140
components and we're rendering them with

00:18:00,230 --> 00:18:05,210
the Fast 3G profile with a 6x CPU

00:18:03,140 --> 00:18:06,710
slowdown this is approximately like a

00:18:05,210 --> 00:18:09,260
real device that I once I have to work

00:18:06,710 --> 00:18:10,370
on in in the real world there's actually

00:18:09,260 --> 00:18:12,380
is a lot of static content and

00:18:10,370 --> 00:18:13,790
applications both in things like headers

00:18:12,380 --> 00:18:15,740
and footers but also kind of sprinkled

00:18:13,790 --> 00:18:18,350
around everywhere so this is a nice test

00:18:15,740 --> 00:18:19,940
case of initial render also if you have

00:18:18,350 --> 00:18:21,470
heard about glimmers like quote-unquote

00:18:19,940 --> 00:18:22,490
static optimizations they don't come

00:18:21,470 --> 00:18:24,560
into play here because we're just

00:18:22,490 --> 00:18:25,850
rendering the first time so as you can

00:18:24,560 --> 00:18:28,430
see glimmer was very competitive the

00:18:25,850 --> 00:18:30,980
react I think we barely beat react app

00:18:28,430 --> 00:18:32,150
react I mean and again the interesting

00:18:30,980 --> 00:18:34,580
the surprising thing there is that we

00:18:32,150 --> 00:18:36,650
beep react even though we're quite a bit

00:18:34,580 --> 00:18:38,030
larger part of that has to do with what

00:18:36,650 --> 00:18:39,140
happens to the templates when you once

00:18:38,030 --> 00:18:42,400
you're actually running the real the

00:18:39,140 --> 00:18:42,400
templates in the real world

00:18:43,940 --> 00:18:51,110
I actually don't do I think this is a

00:18:46,250 --> 00:18:52,340
repeat of exactly the same thing I will

00:18:51,110 --> 00:18:54,230
wait just in case there's anything

00:18:52,340 --> 00:18:55,460
there's some reason I put it here other

00:18:54,230 --> 00:18:58,090
than it's a repeat of the same thing no

00:18:55,460 --> 00:19:00,860
it's repeated the same thing seems good

00:18:58,090 --> 00:19:03,590
so by the way as I said we chose pre

00:19:00,860 --> 00:19:05,890
active for this stress test because it's

00:19:03,590 --> 00:19:10,760
very tiny which benefits initial render

00:19:05,890 --> 00:19:13,460
react itself actually helps so react

00:19:10,760 --> 00:19:16,760
doesn't win we're not using pre act as a

00:19:13,460 --> 00:19:19,220
cheap react itself still it loses

00:19:16,760 --> 00:19:22,130
because of its larger bulk but react is

00:19:19,220 --> 00:19:24,410
able to do some more smarts than pre act

00:19:22,130 --> 00:19:26,030
but for this stress test we really

00:19:24,410 --> 00:19:27,500
wanted to focus on how fast we can get

00:19:26,030 --> 00:19:30,290
content on the screen not what we can do

00:19:27,500 --> 00:19:33,410
once it's on the screen and and we did

00:19:30,290 --> 00:19:35,810
pretty well so however as we saw initial

00:19:33,410 --> 00:19:37,280
render still took some time and at this

00:19:35,810 --> 00:19:38,930
point we're doing pretty simple

00:19:37,280 --> 00:19:40,550
operations it's actually pretty hard for

00:19:38,930 --> 00:19:41,810
us to optimize much faster than this

00:19:40,550 --> 00:19:43,370
because if you look at the profile it's

00:19:41,810 --> 00:19:45,020
mostly bound by like how fast you can

00:19:43,370 --> 00:19:47,420
create elements and set attributes which

00:19:45,020 --> 00:19:50,390
is more or less the low-level operations

00:19:47,420 --> 00:19:55,370
so we actually need to try to find a

00:19:50,390 --> 00:19:57,560
different approach and the answer to the

00:19:55,370 --> 00:19:59,210
better and it's worth noting one of the

00:19:57,560 --> 00:20:00,920
issues with it taking 500 milliseconds

00:19:59,210 --> 00:20:02,500
to a second to two seconds is that while

00:20:00,920 --> 00:20:04,059
it's rendering the user can't scroll

00:20:02,500 --> 00:20:05,440
so even though you kind of you got

00:20:04,059 --> 00:20:07,330
through some amount so in that case

00:20:05,440 --> 00:20:08,710
there's like several screens of content

00:20:07,330 --> 00:20:10,210
even though you got past the first

00:20:08,710 --> 00:20:11,380
screen of content the user still can't

00:20:10,210 --> 00:20:13,780
look at it they can't scroll everything

00:20:11,380 --> 00:20:16,570
is blocked waiting and that's more or

00:20:13,780 --> 00:20:17,830
less how most systems work so what we

00:20:16,570 --> 00:20:19,809
wanted to do is what if we could

00:20:17,830 --> 00:20:21,669
actually start putting the content on

00:20:19,809 --> 00:20:23,049
the screen as fast as we have it instead

00:20:21,669 --> 00:20:27,159
of waiting for the whole thing to finish

00:20:23,049 --> 00:20:29,559
so here's another demo of Glenn we break

00:20:27,159 --> 00:20:31,480
the work into pieces it's exactly the

00:20:29,559 --> 00:20:33,580
same profile of phones exactly the same

00:20:31,480 --> 00:20:35,890
applications as you see glimmer was much

00:20:33,580 --> 00:20:38,710
faster and again that's because we were

00:20:35,890 --> 00:20:40,030
able to emit the start start putting

00:20:38,710 --> 00:20:41,740
content on the screen as fast as we were

00:20:40,030 --> 00:20:45,280
able to render it instead of waiting for

00:20:41,740 --> 00:20:47,799
it to finish in this case we get the

00:20:45,280 --> 00:20:49,900
best of both worlds so exactly what does

00:20:47,799 --> 00:20:50,890
it mean that we broke up the work you

00:20:49,900 --> 00:20:52,059
might think about breaking up the work

00:20:50,890 --> 00:20:53,740
that seems like an obvious thing you

00:20:52,059 --> 00:20:56,770
would want to do it so clearly anybody

00:20:53,740 --> 00:20:58,630
can do it the reason that glimmer is

00:20:56,770 --> 00:21:00,429
able to do it is that we broke we

00:20:58,630 --> 00:21:03,220
already broke up all the work into

00:21:00,429 --> 00:21:04,210
opcodes so here's some example op codes

00:21:03,220 --> 00:21:05,500
that we might be running these

00:21:04,210 --> 00:21:06,580
particular ones do not take 100

00:21:05,500 --> 00:21:10,630
milliseconds but if you have a lot of

00:21:06,580 --> 00:21:12,880
them they will so normally we would act

00:21:10,630 --> 00:21:13,929
like before this most recent change we

00:21:12,880 --> 00:21:15,820
would execute all the app code

00:21:13,929 --> 00:21:18,460
synchronously wait till you finish and

00:21:15,820 --> 00:21:20,140
we're done similarly like react or pre

00:21:18,460 --> 00:21:22,030
act or any of these systems they run the

00:21:20,140 --> 00:21:23,320
render functions they keep running the

00:21:22,030 --> 00:21:24,909
render functions recursively until you

00:21:23,320 --> 00:21:26,289
get to the end then once they built up

00:21:24,909 --> 00:21:27,549
the whole virtual bomb then they start

00:21:26,289 --> 00:21:30,309
putting the virtual Dom into the Dom

00:21:27,549 --> 00:21:31,870
right so similar story you run the whole

00:21:30,309 --> 00:21:36,220
program when you're done you put stuff

00:21:31,870 --> 00:21:38,620
in the Dom but actually we can do better

00:21:36,220 --> 00:21:40,090
because it's just a flat list of byte

00:21:38,620 --> 00:21:42,280
codes it's not like a nested structure

00:21:40,090 --> 00:21:43,929
we have to understand we can use

00:21:42,280 --> 00:21:45,130
deadlines provided by the browser so

00:21:43,929 --> 00:21:46,900
requests I'll call back is this new

00:21:45,130 --> 00:21:49,659
feature that the browser provided that

00:21:46,900 --> 00:21:52,120
allows us to know how much time we have

00:21:49,659 --> 00:21:53,530
before the browser needs to let the user

00:21:52,120 --> 00:21:56,260
scroll basically which is approximately

00:21:53,530 --> 00:21:58,059
60 milliseconds and what we can do is we

00:21:56,260 --> 00:22:01,000
can slice up those opcodes again these

00:21:58,059 --> 00:22:04,630
are these do not take that long but many

00:22:01,000 --> 00:22:07,150
of them do we can we can do that so we

00:22:04,630 --> 00:22:08,799
can slice it up into pieces notably we

00:22:07,150 --> 00:22:10,570
can do that with the existing byte code

00:22:08,799 --> 00:22:11,710
and the existing VM the existing VM

00:22:10,570 --> 00:22:13,480
already allowed you to control the

00:22:11,710 --> 00:22:16,210
timing of the byte code execution we

00:22:13,480 --> 00:22:18,460
just didn't do anything with that yes

00:22:16,210 --> 00:22:21,340
but in glimmer 0.9 which is going to be

00:22:18,460 --> 00:22:23,590
released as a canary this week sometime

00:22:21,340 --> 00:22:26,770
this particular slicing is built-in so

00:22:23,590 --> 00:22:28,720
if you have a big page well as of glimmr

00:22:26,770 --> 00:22:30,060
0.9 we'll start putting things on the

00:22:28,720 --> 00:22:35,800
screen as soon as we have them available

00:22:30,060 --> 00:22:38,620
I also I should mention fiber and react

00:22:35,800 --> 00:22:39,970
is helpful here like fibro helps them to

00:22:38,620 --> 00:22:42,610
do things that are somewhat like this

00:22:39,970 --> 00:22:44,140
the cost of fiber those up there's a

00:22:42,610 --> 00:22:46,030
bigger runtime right so there's always

00:22:44,140 --> 00:22:47,860
this push and pull where you can get

00:22:46,030 --> 00:22:50,080
very very tiny runtime like pre-act

00:22:47,860 --> 00:22:52,450
but you don't have any smarts at all or

00:22:50,080 --> 00:22:53,410
you can get them much more robust

00:22:52,450 --> 00:22:55,570
runtime when you're dealing with

00:22:53,410 --> 00:22:56,710
JavaScript like react and then you have

00:22:55,570 --> 00:22:59,020
to deal with however long it takes to

00:22:56,710 --> 00:23:02,110
download a parse and execute that much

00:22:59,020 --> 00:23:03,490
JavaScript I actually didn't get a

00:23:02,110 --> 00:23:05,110
chance to talk about a lot of other

00:23:03,490 --> 00:23:06,340
important features that glimmer VM

00:23:05,110 --> 00:23:09,580
provides for example I didn't talk about

00:23:06,340 --> 00:23:11,440
updating at all so what the way that we

00:23:09,580 --> 00:23:12,880
keep things responsive is by having the

00:23:11,440 --> 00:23:15,040
initial render emit a much smaller

00:23:12,880 --> 00:23:16,210
updating program which we can run

00:23:15,040 --> 00:23:17,860
whenever we want to update the Dom

00:23:16,210 --> 00:23:19,360
without having to do something like walk

00:23:17,860 --> 00:23:21,580
an entire tree of virtual Dom so instead

00:23:19,360 --> 00:23:23,620
of walking a tree comparing trees

00:23:21,580 --> 00:23:25,900
reconciling whatever the initial

00:23:23,620 --> 00:23:27,490
rendering program just emits a second

00:23:25,900 --> 00:23:29,200
program that we run the second program

00:23:27,490 --> 00:23:31,090
emits a third program that we run etc

00:23:29,200 --> 00:23:32,860
whatever we want to update something and

00:23:31,090 --> 00:23:34,150
the consequence of that is that we don't

00:23:32,860 --> 00:23:35,590
have to actually allocate we don't have

00:23:34,150 --> 00:23:37,450
to create anything whenever we're

00:23:35,590 --> 00:23:38,380
looking to update something that also

00:23:37,450 --> 00:23:41,170
liens on all the compilation

00:23:38,380 --> 00:23:43,120
architecture to make it efficient we

00:23:41,170 --> 00:23:44,920
also have had for a while now

00:23:43,120 --> 00:23:46,630
server-side rendering and rehydration

00:23:44,920 --> 00:23:48,910
built into the VM so server-side

00:23:46,630 --> 00:23:50,200
rendering means you can render glimmer

00:23:48,910 --> 00:23:52,690
that's because we don't use the Dom

00:23:50,200 --> 00:23:54,610
internally we use a subset and we have a

00:23:52,690 --> 00:23:55,960
server implementation and rehydration

00:23:54,610 --> 00:23:59,500
means we can take something that the

00:23:55,960 --> 00:24:02,230
server provided and rehydrate it we do

00:23:59,500 --> 00:24:04,510
cool stuff like repairing rehydrate so

00:24:02,230 --> 00:24:06,220
even if there's small mistakes we'll fix

00:24:04,510 --> 00:24:08,110
them that can happen because like your

00:24:06,220 --> 00:24:09,130
internationalization library and v8 is

00:24:08,110 --> 00:24:10,270
different from edges

00:24:09,130 --> 00:24:14,800
internationalization library or

00:24:10,270 --> 00:24:16,000
something and zero glimmer 0.9 adds the

00:24:14,800 --> 00:24:18,220
two bullets at the bottom which are

00:24:16,000 --> 00:24:19,660
streaming server side rendering and you

00:24:18,220 --> 00:24:21,190
can sort of imagine how this can work

00:24:19,660 --> 00:24:22,660
right because it's a bunch of opcodes

00:24:21,190 --> 00:24:24,310
whenever we reach certain op codes like

00:24:22,660 --> 00:24:26,110
flush element that's an appropriate time

00:24:24,310 --> 00:24:29,200
for us to do streaming we can build that

00:24:26,110 --> 00:24:31,200
in an incremental rehydration basically

00:24:29,200 --> 00:24:34,270
means that we can

00:24:31,200 --> 00:24:36,010
so if your rehydrating a bunch of Dom

00:24:34,270 --> 00:24:38,679
let's say you have you know many screens

00:24:36,010 --> 00:24:39,760
if you stop rehydrate the whole thing by

00:24:38,679 --> 00:24:40,960
running the whole program again what's

00:24:39,760 --> 00:24:42,010
gonna happen is the users not gonna be

00:24:40,960 --> 00:24:43,900
able to scroll while you're in the

00:24:42,010 --> 00:24:46,000
middle of rehydrating and incremental

00:24:43,900 --> 00:24:48,730
rehydration basically will rehydrate

00:24:46,000 --> 00:24:50,620
just a chunk of the Dom that a chunk at

00:24:48,730 --> 00:24:54,100
a time in the same kind of manner as the

00:24:50,620 --> 00:24:55,450
previous slide the incremental slide but

00:24:54,100 --> 00:24:56,440
against Dom that already existed right

00:24:55,450 --> 00:24:58,570
which means that the user can start

00:24:56,440 --> 00:25:00,330
scrolling right away and behind the

00:24:58,570 --> 00:25:03,850
scenes will start enhancing it with

00:25:00,330 --> 00:25:05,440
behavior and both of those things are

00:25:03,850 --> 00:25:07,720
coming in 0.9 which is gonna be released

00:25:05,440 --> 00:25:09,340
this week if you want to play with

00:25:07,720 --> 00:25:11,890
glimmer the easiest way to do that is

00:25:09,340 --> 00:25:14,440
the glimmer playground which is glimmer

00:25:11,890 --> 00:25:16,750
playground Detlef ID comm there's an

00:25:14,440 --> 00:25:19,690
easter egg for people who watch the 90s

00:25:16,750 --> 00:25:21,580
movie the net is a PI sign on the bottom

00:25:19,690 --> 00:25:26,410
and it will show you the OP codes for

00:25:21,580 --> 00:25:27,790
whatever thing you typed in if you like

00:25:26,410 --> 00:25:28,660
the playground if you played around with

00:25:27,790 --> 00:25:30,250
it and you won't like it

00:25:28,660 --> 00:25:34,450
check out glimmer jest comm which is

00:25:30,250 --> 00:25:36,340
basically the library and she want I

00:25:34,450 --> 00:25:38,140
want to close by saying by using a

00:25:36,340 --> 00:25:40,030
compiler and a VM architecture to boil

00:25:38,140 --> 00:25:41,470
away runtime costs we actually do

00:25:40,030 --> 00:25:43,270
succeed at the original goal that we

00:25:41,470 --> 00:25:45,429
talked about which is to get content on

00:25:43,270 --> 00:25:47,110
the screen quickly without conceding and

00:25:45,429 --> 00:25:49,330
ambitious applications to our native

00:25:47,110 --> 00:25:51,640
brethren so what I will say is let's

00:25:49,330 --> 00:25:53,110
expand our point of view compiling away

00:25:51,640 --> 00:25:54,610
the runtime lets us build ambitious

00:25:53,110 --> 00:25:56,380
applications that don't compromise on

00:25:54,610 --> 00:25:58,030
what Alex said was the web superpower

00:25:56,380 --> 00:25:59,950
getting content to anyone who has a

00:25:58,030 --> 00:26:02,240
computing device in a matter of seconds

00:25:59,950 --> 00:26:06,270
thank you very much

00:26:02,240 --> 00:26:12,260
[Applause]

00:26:06,270 --> 00:26:12,260
I think I have time for questions party

00:26:14,120 --> 00:26:17,120
yes

00:26:24,110 --> 00:26:29,929
yes

00:26:26,450 --> 00:26:31,850
yeah so general so the question is

00:26:29,929 --> 00:26:34,749
debugging there's a few things I would

00:26:31,850 --> 00:26:37,909
say about that first of all in general

00:26:34,749 --> 00:26:39,499
the more abstract we get the more risky

00:26:37,909 --> 00:26:41,950
that is and I think that we take that

00:26:39,499 --> 00:26:41,950

YouTube URL: https://www.youtube.com/watch?v=g-b6ipLxUhw


