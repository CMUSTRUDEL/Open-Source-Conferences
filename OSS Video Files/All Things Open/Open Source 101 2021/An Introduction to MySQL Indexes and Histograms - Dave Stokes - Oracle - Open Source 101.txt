Title: An Introduction to MySQL Indexes and Histograms - Dave Stokes - Oracle - Open Source 101
Publication date: 2021-04-12
Playlist: Open Source 101 2021
Description: 
	Dave Stokes, MySQL Community Manager at Oracle, delivered the talk "An Introduction to MySQL Indexes and Histograms" at Open Source 101 on Tuesday, March 30, 2021.

Abstract:
Nobody ever complains that the database is too fast. But tuning a database query can get tricky. You add one index and things go faster but adding a second one makes processing crawl. The MySQL optimizer uses historical information to develop a query plan and the two best known ways to augment that information are indexes and histograms. This session covers how indexes really work, how the optimizer evaluates those indices for processing, how secondary indexes piggy-backâ€™ on primary indexes, and how to tell what index is really being used. And new in 8.0 are histograms but they may not fit your data. So if you want faster queries or just a better understanding of how MySQL works then this session is for you.

Find Dave on the internets:
Twitter: https://twitter.com/stoker
Personal website: https://elephantdolphin.blogspot.com/
Captions: 
	00:00:05,120 --> 00:00:09,120
my name is dave stokes

00:00:06,399 --> 00:00:09,760
i am a community manager for mysql

00:00:09,120 --> 00:00:10,880
products

00:00:09,760 --> 00:00:14,160
i've been doing that for a little bit

00:00:10,880 --> 00:00:15,759
over a decade now time is flying

00:00:14,160 --> 00:00:18,160
if you need to get a hold of me uh email

00:00:15,759 --> 00:00:20,480
address is david.stokes at oracle.com

00:00:18,160 --> 00:00:22,480
twitter handles at stoker uh if you just

00:00:20,480 --> 00:00:24,160
search for dave stokes mysql you're

00:00:22,480 --> 00:00:26,720
bound to find some

00:00:24,160 --> 00:00:28,160
some tangential way to get to me uh

00:00:26,720 --> 00:00:28,720
before we get going since i work for

00:00:28,160 --> 00:00:31,279
oracle

00:00:28,720 --> 00:00:33,280
i have to mention that today i'm talking

00:00:31,279 --> 00:00:35,360
about the free open source version of

00:00:33,280 --> 00:00:37,760
mysql server and all the rest of our

00:00:35,360 --> 00:00:39,600
products i might touch

00:00:37,760 --> 00:00:42,320
lightly on the enterprise version that

00:00:39,600 --> 00:00:43,760
you do have to buy a subscription to use

00:00:42,320 --> 00:00:45,440
it's free to download for 30 days to

00:00:43,760 --> 00:00:46,640
evaluate but after that you have to get

00:00:45,440 --> 00:00:48,640
a subscription

00:00:46,640 --> 00:00:50,079
but if we get off on a tangent on some

00:00:48,640 --> 00:00:52,160
stuff coming out and there's a lot of

00:00:50,079 --> 00:00:52,879
stuff coming out in the next 30 to 90

00:00:52,160 --> 00:00:55,920
days from

00:00:52,879 --> 00:00:56,320
mysql uh please take it with a grain of

00:00:55,920 --> 00:00:57,520
salt

00:00:56,320 --> 00:00:59,280
i don't have perfect knowledge what's

00:00:57,520 --> 00:01:01,280
coming out i'm testing some of the stuff

00:00:59,280 --> 00:01:02,800
it's really fantastic but i can't really

00:01:01,280 --> 00:01:05,119
promise it's going to be exactly the way

00:01:02,800 --> 00:01:07,520
i see it when it gets to your hands

00:01:05,119 --> 00:01:09,760
by the way if you're running mysql56

00:01:07,520 --> 00:01:12,640
last february it reached its end

00:01:09,760 --> 00:01:15,759
of life no more updates more no more bug

00:01:12,640 --> 00:01:17,280
fixes please upgrade to mysql 5.7 or

00:01:15,759 --> 00:01:19,840
better yet 8-0

00:01:17,280 --> 00:01:21,920
a lot of good wins by simply upgrading

00:01:19,840 --> 00:01:23,920
there

00:01:21,920 --> 00:01:25,439
by the way if you want to try mysql in

00:01:23,920 --> 00:01:27,920
the cloud for free

00:01:25,439 --> 00:01:29,200
uh you can get 300 for the credits uh by

00:01:27,920 --> 00:01:32,400
going to oracle.com

00:01:29,200 --> 00:01:35,280
cloud slash free uh 300 on the smaller

00:01:32,400 --> 00:01:36,720
machines will last you quite a long time

00:01:35,280 --> 00:01:38,479
uh please try it you'll see some

00:01:36,720 --> 00:01:40,000
announcements about this coming up

00:01:38,479 --> 00:01:41,520
uh very shortly there's some new

00:01:40,000 --> 00:01:42,000
features that are really really amazing

00:01:41,520 --> 00:01:46,000
and

00:01:42,000 --> 00:01:49,439
like i said here's 300 free go try it

00:01:46,000 --> 00:01:51,600
so what is this session about well i

00:01:49,439 --> 00:01:52,799
part of my job as a evangelist is i go

00:01:51,600 --> 00:01:53,280
out there and i read what people are

00:01:52,799 --> 00:01:55,280
writing

00:01:53,280 --> 00:01:57,759
problems they're having solutions

00:01:55,280 --> 00:02:00,320
they're offering from mysql

00:01:57,759 --> 00:02:01,840
and uh very rarely do i ever see anyone

00:02:00,320 --> 00:02:03,119
complaining about the database running

00:02:01,840 --> 00:02:05,439
too fast

00:02:03,119 --> 00:02:06,719
i've actually never actually had anyone

00:02:05,439 --> 00:02:07,680
complain the database is running too

00:02:06,719 --> 00:02:10,239
fast

00:02:07,680 --> 00:02:11,280
so you have a query and you want to make

00:02:10,239 --> 00:02:13,280
it faster

00:02:11,280 --> 00:02:14,959
and you start reading some of the stuff

00:02:13,280 --> 00:02:16,959
out there on the web uh unfortunately

00:02:14,959 --> 00:02:18,879
not the mysql manual we read other stuff

00:02:16,959 --> 00:02:20,640
and it ends up looking like something

00:02:18,879 --> 00:02:22,959
like a terry parter dark arts where

00:02:20,640 --> 00:02:23,360
you're waving a wand over a newt's toe

00:02:22,959 --> 00:02:25,680
and

00:02:23,360 --> 00:02:27,920
boom smoke goes off and your query runs

00:02:25,680 --> 00:02:30,560
faster no that's not it

00:02:27,920 --> 00:02:32,640
understand how queries work is treated

00:02:30,560 --> 00:02:34,160
as magic but it's really not

00:02:32,640 --> 00:02:36,879
so we're going to be looking today at

00:02:34,160 --> 00:02:38,000
the proper uses of indexes histograms

00:02:36,879 --> 00:02:39,200
i'm not going to cover the locking

00:02:38,000 --> 00:02:40,160
options and some of the other ways to

00:02:39,200 --> 00:02:42,239
speed up

00:02:40,160 --> 00:02:44,080
if you go out to slideshare.net dave

00:02:42,239 --> 00:02:46,080
stokes i'll give that

00:02:44,080 --> 00:02:47,680
several times during this presentation

00:02:46,080 --> 00:02:49,599
you'll see a much longer presentation

00:02:47,680 --> 00:02:51,599
than what you're seeing here

00:02:49,599 --> 00:02:53,200
i'm limited to 45 minutes thereabouts

00:02:51,599 --> 00:02:55,360
try to get down to 35

00:02:53,200 --> 00:02:57,840
to 40. but there's a lot of other good

00:02:55,360 --> 00:03:01,360
material out there

00:02:57,840 --> 00:03:04,319
now this is a dry subject we're talking

00:03:01,360 --> 00:03:05,760
mojave desert late september dry

00:03:04,319 --> 00:03:07,680
unfortunately that's the way it is for

00:03:05,760 --> 00:03:09,840
some technical subjects i can't make it

00:03:07,680 --> 00:03:11,280
uh fun and bouncy i can't use hand

00:03:09,840 --> 00:03:14,319
puppets unfortunately

00:03:11,280 --> 00:03:15,760
more probably lack of talent on my site

00:03:14,319 --> 00:03:17,360
there's a lot of text on screen i'm

00:03:15,760 --> 00:03:19,680
sorry about that

00:03:17,360 --> 00:03:21,120
download the slides from slideshow dave

00:03:19,680 --> 00:03:23,760
stokes

00:03:21,120 --> 00:03:25,280
you'll actually find some of this a

00:03:23,760 --> 00:03:25,760
couple other places for other shows i'm

00:03:25,280 --> 00:03:27,440
doing

00:03:25,760 --> 00:03:29,040
i continue to update the slide deck so

00:03:27,440 --> 00:03:29,519
if you see it too much from now they'll

00:03:29,040 --> 00:03:32,080
probably have

00:03:29,519 --> 00:03:34,239
a lot more material in there don't try

00:03:32,080 --> 00:03:36,080
to absorb everything at once

00:03:34,239 --> 00:03:37,519
see what you can get out of it first and

00:03:36,080 --> 00:03:38,799
then work with a little bit then come

00:03:37,519 --> 00:03:40,000
back

00:03:38,799 --> 00:03:41,760
instead of giving you a spoonful of

00:03:40,000 --> 00:03:43,280
medicine i'm shoving the entire medicine

00:03:41,760 --> 00:03:46,400
factory down your throat in this

00:03:43,280 --> 00:03:48,560
very fast presentation uh big advice

00:03:46,400 --> 00:03:49,599
work on your most frequent queries first

00:03:48,560 --> 00:03:50,959
uh something that runs a hundred

00:03:49,599 --> 00:03:52,799
thousand times a minute

00:03:50,959 --> 00:03:54,400
that you save two milliseconds off of is

00:03:52,799 --> 00:03:56,400
a big big win to

00:03:54,400 --> 00:03:57,439
pay off there and then work on the next

00:03:56,400 --> 00:03:59,120
one

00:03:57,439 --> 00:04:00,799
by the way your optimizations may need

00:03:59,120 --> 00:04:01,920
to change over time

00:04:00,799 --> 00:04:04,080
the query that you have running

00:04:01,920 --> 00:04:05,599
perfectly today six months from now when

00:04:04,080 --> 00:04:08,879
you've doubled your data size

00:04:05,599 --> 00:04:09,760
might need some tuning also today i'm

00:04:08,879 --> 00:04:11,599
not going to cover

00:04:09,760 --> 00:04:13,519
uh system configuration i'm not going to

00:04:11,599 --> 00:04:16,479
talk about what you set

00:04:13,519 --> 00:04:17,120
your os 2 or the mysql server to for

00:04:16,479 --> 00:04:20,320
optimal

00:04:17,120 --> 00:04:20,880
performance that's kind of a itself a

00:04:20,320 --> 00:04:22,639
one week

00:04:20,880 --> 00:04:24,240
tutorial not going to talk about

00:04:22,639 --> 00:04:27,120
hardware hardware is

00:04:24,240 --> 00:04:28,800
a real messy subject and no two sites

00:04:27,120 --> 00:04:30,800
seem to have exactly the same stuff even

00:04:28,800 --> 00:04:31,759
in the cloud which is kind of scary

00:04:30,800 --> 00:04:33,040
also i'm not going to talk about

00:04:31,759 --> 00:04:34,800
networking by the way if you've ever had

00:04:33,040 --> 00:04:35,919
an ldap and a dns zone update

00:04:34,800 --> 00:04:38,080
while you're trying to do replication

00:04:35,919 --> 00:04:39,360
change servers it's not a pretty thing

00:04:38,080 --> 00:04:43,040
and once again the slides are at

00:04:39,360 --> 00:04:44,400
slideshare.net dave stokes

00:04:43,040 --> 00:04:45,600
also i'm not going to cover normalizing

00:04:44,400 --> 00:04:47,520
your data this is where you take your

00:04:45,600 --> 00:04:50,560
data and organize it so you have

00:04:47,520 --> 00:04:52,479
no or minimal redundancies if your data

00:04:50,560 --> 00:04:54,720
is not structured right it's like

00:04:52,479 --> 00:04:56,160
building a skyscraper on a beach with a

00:04:54,720 --> 00:04:58,560
set where the waves are coming in and

00:04:56,160 --> 00:05:00,320
the winds eroding the sand behind you

00:04:58,560 --> 00:05:02,400
i recommend you use third normal form or

00:05:00,320 --> 00:05:03,520
better i have modified this past couple

00:05:02,400 --> 00:05:06,320
years saying

00:05:03,520 --> 00:05:07,360
use a json column for stub data you have

00:05:06,320 --> 00:05:09,520
a one gigabyte

00:05:07,360 --> 00:05:12,160
payload there you can denormalize a

00:05:09,520 --> 00:05:13,360
little bit where it makes sense

00:05:12,160 --> 00:05:15,360
but you have to also think about how

00:05:13,360 --> 00:05:17,039
you're going to use your data how you

00:05:15,360 --> 00:05:18,639
want to pull the data out actually says

00:05:17,039 --> 00:05:20,080
more about

00:05:18,639 --> 00:05:22,720
your structure than how you actually put

00:05:20,080 --> 00:05:25,360
it in there you can't really eat

00:05:22,720 --> 00:05:27,440
soup very well with a fork and by the

00:05:25,360 --> 00:05:29,440
way badly normalized data will hurt your

00:05:27,440 --> 00:05:31,360
performance

00:05:29,440 --> 00:05:32,880
third normalized form or better the math

00:05:31,360 --> 00:05:35,199
does work out it does make your

00:05:32,880 --> 00:05:36,720
your queries faster over time and no

00:05:35,199 --> 00:05:38,000
matter how much training you give it a

00:05:36,720 --> 00:05:42,080
dachshund will not outrun

00:05:38,000 --> 00:05:43,199
a thoroughbred horse over a mile

00:05:42,080 --> 00:05:45,120
so the main thing we're talking about

00:05:43,199 --> 00:05:46,000
today in in and about it is the

00:05:45,120 --> 00:05:48,800
optimizer

00:05:46,000 --> 00:05:50,720
and wikipedia says it's the the brain

00:05:48,800 --> 00:05:52,880
and nervous system of the database

00:05:50,720 --> 00:05:54,880
and it wants to take your query and

00:05:52,880 --> 00:05:56,560
optimize it to be able to pull back your

00:05:54,880 --> 00:05:59,600
data efficient

00:05:56,560 --> 00:06:01,440
efficiently been a long day one of the

00:05:59,600 --> 00:06:04,160
problem hardest problems in

00:06:01,440 --> 00:06:06,000
data in computer science and databases

00:06:04,160 --> 00:06:08,400
is how to estimate the cost

00:06:06,000 --> 00:06:10,560
of your data a long time ago most of the

00:06:08,400 --> 00:06:11,919
databases came with the idea of coming

00:06:10,560 --> 00:06:15,120
up with the cost of disk

00:06:11,919 --> 00:06:18,880
reads uh read from disk is 100

00:06:15,120 --> 00:06:20,960
100 000 times slower than from memory

00:06:18,880 --> 00:06:22,400
uh big big big win if you can pull

00:06:20,960 --> 00:06:26,560
something out of memory

00:06:22,400 --> 00:06:28,479
databases love memory so the optimizer

00:06:26,560 --> 00:06:31,120
has a mathematical model depending on

00:06:28,479 --> 00:06:32,880
that cost to try to pull back your

00:06:31,120 --> 00:06:35,600
your information and it has that

00:06:32,880 --> 00:06:37,680
information through detailed statistics

00:06:35,600 --> 00:06:39,680
as anyone can tell you statistics have

00:06:37,680 --> 00:06:41,440
problems um like a gps

00:06:39,680 --> 00:06:43,199
the cost is built on historical

00:06:41,440 --> 00:06:44,479
information like if i want to go to my

00:06:43,199 --> 00:06:46,000
favorite restaurant left out of the

00:06:44,479 --> 00:06:47,039
driveway right at the stop sign over the

00:06:46,000 --> 00:06:48,720
railroad tracks and my favorite

00:06:47,039 --> 00:06:50,160
restaurants on the right

00:06:48,720 --> 00:06:52,000
unfortunately i don't know that my

00:06:50,160 --> 00:06:53,440
neighbor has blocked my driveway

00:06:52,000 --> 00:06:55,199
the train tracks are being torn up for

00:06:53,440 --> 00:06:57,360
construction and the restaurant

00:06:55,199 --> 00:06:58,880
has decided to move across the street so

00:06:57,360 --> 00:07:00,160
my historical information does mean

00:06:58,880 --> 00:07:02,319
little to no good

00:07:00,160 --> 00:07:04,080
optimizers like that if it has bad

00:07:02,319 --> 00:07:05,120
information about where your data is or

00:07:04,080 --> 00:07:06,800
incomplete

00:07:05,120 --> 00:07:08,160
uh it's going to make a bad query plan

00:07:06,800 --> 00:07:10,800
which means things are going to be

00:07:08,160 --> 00:07:11,440
slow by the way mysql wants to see each

00:07:10,800 --> 00:07:13,360
query

00:07:11,440 --> 00:07:14,800
every time and try to optimize it

00:07:13,360 --> 00:07:16,240
there's no locking down the query plan

00:07:14,800 --> 00:07:17,440
like you can in oracle or some other

00:07:16,240 --> 00:07:18,960
databases

00:07:17,440 --> 00:07:20,080
a little bit later if you go through the

00:07:18,960 --> 00:07:21,360
slides you'll see something about

00:07:20,080 --> 00:07:23,120
optimizer hints i can't

00:07:21,360 --> 00:07:25,199
cover that today but it's a way to kind

00:07:23,120 --> 00:07:26,720
of give hints to the

00:07:25,199 --> 00:07:28,319
to the server about what you want it to

00:07:26,720 --> 00:07:29,520
do

00:07:28,319 --> 00:07:31,759
by the way is it like you're joining

00:07:29,520 --> 00:07:34,960
five tables which is fairly common

00:07:31,759 --> 00:07:36,720
that's um five factorial options or 120

00:07:34,960 --> 00:07:38,319
different options that the server can do

00:07:36,720 --> 00:07:39,759
oh by the way that's my dog boo back

00:07:38,319 --> 00:07:41,039
there

00:07:39,759 --> 00:07:44,720
you might see another little brown one

00:07:41,039 --> 00:07:47,520
that's mac uh they very rarely comment

00:07:44,720 --> 00:07:48,560
explain explain is usually uh the only

00:07:47,520 --> 00:07:50,720
way you're going to find

00:07:48,560 --> 00:07:52,319
what your optimizer wants to do and give

00:07:50,720 --> 00:07:54,560
you the query plan

00:07:52,319 --> 00:07:56,160
now the explained syntax if you go to

00:07:54,560 --> 00:07:56,639
the buy scale manual which is in chapter

00:07:56,160 --> 00:07:58,639
eight

00:07:56,639 --> 00:08:00,319
uh tells you how the server wants to

00:07:58,639 --> 00:08:01,840
process your query

00:08:00,319 --> 00:08:04,000
and you can see here there's a lot of

00:08:01,840 --> 00:08:04,639
different options you prepend the word

00:08:04,000 --> 00:08:06,639
explain

00:08:04,639 --> 00:08:09,120
to a select delete insert replace or

00:08:06,639 --> 00:08:11,680
update statement

00:08:09,120 --> 00:08:12,720
by the way explain has several varieties

00:08:11,680 --> 00:08:14,000
to make things

00:08:12,720 --> 00:08:15,360
even more complex for those of you

00:08:14,000 --> 00:08:16,879
starting off and if you are just

00:08:15,360 --> 00:08:18,639
starting off

00:08:16,879 --> 00:08:20,879
it's there's a lot of varieties out

00:08:18,639 --> 00:08:23,840
there just do the best you can

00:08:20,879 --> 00:08:25,280
now here's a simple example we have a

00:08:23,840 --> 00:08:27,120
query select star

00:08:25,280 --> 00:08:28,479
which is the wild card for everything

00:08:27,120 --> 00:08:30,479
all the columns

00:08:28,479 --> 00:08:32,240
from the table name city where the

00:08:30,479 --> 00:08:34,959
country code column

00:08:32,240 --> 00:08:37,039
has the value of gbr and by the way in

00:08:34,959 --> 00:08:37,360
my scale the backslash capital g gives

00:08:37,039 --> 00:08:39,519
you

00:08:37,360 --> 00:08:41,839
a horizon a vertical readout instead of

00:08:39,519 --> 00:08:44,959
the horizontal tabular readout

00:08:41,839 --> 00:08:48,080
so there's our query

00:08:44,959 --> 00:08:49,279
the details for the query what it's

00:08:48,080 --> 00:08:50,880
going to

00:08:49,279 --> 00:08:52,959
think it wants to do to get the

00:08:50,880 --> 00:08:53,839
information and then the actual query

00:08:52,959 --> 00:08:54,959
plan

00:08:53,839 --> 00:08:57,200
you notice the query plan is kind of

00:08:54,959 --> 00:08:59,360
like our query but the

00:08:57,200 --> 00:09:01,519
the optimizers added a couple things for

00:08:59,360 --> 00:09:03,440
us

00:09:01,519 --> 00:09:04,640
now if you're a little more visual with

00:09:03,440 --> 00:09:06,399
microscope workbench

00:09:04,640 --> 00:09:09,440
you can get some of this information

00:09:06,399 --> 00:09:11,519
with visual work visual explain

00:09:09,440 --> 00:09:12,959
uh there's explained formatting tree

00:09:11,519 --> 00:09:14,320
which gives us more information

00:09:12,959 --> 00:09:16,000
now this is a slightly different query

00:09:14,320 --> 00:09:17,760
we're actually joining two tables

00:09:16,000 --> 00:09:19,760
together and we're hooking them up

00:09:17,760 --> 00:09:22,800
where the city dot population is equal

00:09:19,760 --> 00:09:24,560
to the country.population

00:09:22,800 --> 00:09:25,920
information and it tells in this case

00:09:24,560 --> 00:09:26,480
we're running an inner hash join that's

00:09:25,920 --> 00:09:28,240
one of the two

00:09:26,480 --> 00:09:29,839
join types that we have and you'll see

00:09:28,240 --> 00:09:31,200
that those can be a lot faster than our

00:09:29,839 --> 00:09:34,000
standard

00:09:31,200 --> 00:09:34,880
nested loop for those who want even more

00:09:34,000 --> 00:09:37,279
information

00:09:34,880 --> 00:09:38,959
format equals json and it gives you all

00:09:37,279 --> 00:09:40,240
sorts of information the rows examine

00:09:38,959 --> 00:09:43,120
the read cost

00:09:40,240 --> 00:09:44,880
the columns used uh a whole bunch of

00:09:43,120 --> 00:09:46,399
other stuff how it's joined

00:09:44,880 --> 00:09:47,440
for those starting off this is overkill

00:09:46,399 --> 00:09:48,560
for those who've been doing this for a

00:09:47,440 --> 00:09:51,760
while there's some value

00:09:48,560 --> 00:09:53,120
information in here also about a year

00:09:51,760 --> 00:09:55,440
ago explained added

00:09:53,120 --> 00:09:58,000
explain analyze all those other explains

00:09:55,440 --> 00:10:01,360
used historical information

00:09:58,000 --> 00:10:03,760
whatever the system was able to glean

00:10:01,360 --> 00:10:05,600
from the past executions when you run

00:10:03,760 --> 00:10:06,560
explain analyze it actually goes out and

00:10:05,600 --> 00:10:08,959
runs your query

00:10:06,560 --> 00:10:10,800
so be careful if you have a real nasty

00:10:08,959 --> 00:10:12,399
query when you explain analyze

00:10:10,800 --> 00:10:14,000
but actually comes back it tells you the

00:10:12,399 --> 00:10:15,600
actual time it took and the number of

00:10:14,000 --> 00:10:18,160
rows it had to read and the number of

00:10:15,600 --> 00:10:19,519
loops it had to run

00:10:18,160 --> 00:10:20,959
so we'll use a little bit more on

00:10:19,519 --> 00:10:22,640
explain later but i wanted to kind of

00:10:20,959 --> 00:10:23,839
give you a general overview of how we

00:10:22,640 --> 00:10:26,640
get to query plan

00:10:23,839 --> 00:10:28,640
so what is an index well according to

00:10:26,640 --> 00:10:29,760
wikipedia a database index is a data

00:10:28,640 --> 00:10:31,200
structure that improves the speed of

00:10:29,760 --> 00:10:34,480
data retrieval

00:10:31,200 --> 00:10:37,040
well how does this uh happen well

00:10:34,480 --> 00:10:38,959
you have to create an index and i tend

00:10:37,040 --> 00:10:41,040
to think of as creating a

00:10:38,959 --> 00:10:42,079
smaller stubby table that points to the

00:10:41,040 --> 00:10:45,120
bigger table

00:10:42,079 --> 00:10:46,000
and by the way that table uh that index

00:10:45,120 --> 00:10:48,560
table should point

00:10:46,000 --> 00:10:49,839
should also be in memory next to the

00:10:48,560 --> 00:10:51,360
data table

00:10:49,839 --> 00:10:53,440
and the more memory have the better

00:10:51,360 --> 00:10:54,800
because if it has to move things in and

00:10:53,440 --> 00:10:57,120
out

00:10:54,800 --> 00:10:58,560
it can be painful and also the more

00:10:57,120 --> 00:10:59,279
memory have the better because remember

00:10:58,560 --> 00:11:01,040
memory is

00:10:59,279 --> 00:11:02,800
a hundred thousand times faster than a

00:11:01,040 --> 00:11:04,480
disk read

00:11:02,800 --> 00:11:05,839
and of course to make this even more

00:11:04,480 --> 00:11:07,279
difficult there are many types of

00:11:05,839 --> 00:11:10,000
indexes

00:11:07,279 --> 00:11:10,800
if you look at the manual page you see

00:11:10,000 --> 00:11:13,680
that we have

00:11:10,800 --> 00:11:14,000
create index index name with options of

00:11:13,680 --> 00:11:17,279
unique

00:11:14,000 --> 00:11:20,079
full text spatial some other

00:11:17,279 --> 00:11:21,600
things you can do with it now mysql uses

00:11:20,079 --> 00:11:24,560
what they call a clustered index

00:11:21,600 --> 00:11:27,040
and the table is organized based on the

00:11:24,560 --> 00:11:29,200
value of the primary key

00:11:27,040 --> 00:11:30,079
and for best performance choose a

00:11:29,200 --> 00:11:32,320
primary key

00:11:30,079 --> 00:11:35,040
carefully uh up for you'll get the best

00:11:32,320 --> 00:11:36,880
performance out of that

00:11:35,040 --> 00:11:38,079
by the way modifying a primary key or

00:11:36,880 --> 00:11:39,440
replacing it with some other field is

00:11:38,079 --> 00:11:41,839
very costly

00:11:39,440 --> 00:11:43,519
and if you're an oracle type person this

00:11:41,839 --> 00:11:45,680
is better known as an indexed organized

00:11:43,519 --> 00:11:47,519
table to you

00:11:45,680 --> 00:11:49,040
so we have this little what i call

00:11:47,519 --> 00:11:52,079
stubby index table

00:11:49,040 --> 00:11:53,200
that has the pointers to our our data

00:11:52,079 --> 00:11:54,800
table

00:11:53,200 --> 00:11:55,839
this is the way i think of it it's not

00:11:54,800 --> 00:11:57,440
really the way it works behind the

00:11:55,839 --> 00:12:00,639
covers but it's kind of a

00:11:57,440 --> 00:12:02,240
a good conceptual overview

00:12:00,639 --> 00:12:03,600
now if you have a secondary index so you

00:12:02,240 --> 00:12:05,200
already have your primary index and you

00:12:03,600 --> 00:12:06,720
index something else

00:12:05,200 --> 00:12:08,160
the secondary index is kind of cheap

00:12:06,720 --> 00:12:09,360
because they just have a pointer to the

00:12:08,160 --> 00:12:11,279
primary index

00:12:09,360 --> 00:12:14,000
so there's really no extra magic to a

00:12:11,279 --> 00:12:16,560
secondary index

00:12:14,000 --> 00:12:18,639
so let's create a simple table create

00:12:16,560 --> 00:12:19,600
table t1 by the way you'll love my table

00:12:18,639 --> 00:12:22,000
and column names

00:12:19,600 --> 00:12:22,880
column one int not null we'll talk about

00:12:22,000 --> 00:12:24,399
null later

00:12:22,880 --> 00:12:26,320
auto increment that means every time you

00:12:24,399 --> 00:12:28,880
insert a record it's going to bump that

00:12:26,320 --> 00:12:31,279
integer value by one or some other

00:12:28,880 --> 00:12:32,399
preset increment and we declare it as

00:12:31,279 --> 00:12:35,040
primary key

00:12:32,399 --> 00:12:37,360
and then we have two other columns now

00:12:35,040 --> 00:12:40,160
an index is a list of keys

00:12:37,360 --> 00:12:42,160
and in the mysql world you'll hear key

00:12:40,160 --> 00:12:43,839
and index used interchangeably

00:12:42,160 --> 00:12:45,920
we also use database and schema

00:12:43,839 --> 00:12:47,839
interchangeably got to apologize that

00:12:45,920 --> 00:12:50,959
that's our just our karman

00:12:47,839 --> 00:12:52,480
usage now the primary key is

00:12:50,959 --> 00:12:54,320
a key for the index that is uniquely

00:12:52,480 --> 00:12:56,000
defined hopefully uniquely

00:12:54,320 --> 00:12:57,839
and it should be immutable i mean don't

00:12:56,000 --> 00:12:59,839
go around changing it

00:12:57,839 --> 00:13:01,680
energyb requires the primary key for

00:12:59,839 --> 00:13:02,639
proper efficiency and if you don't

00:13:01,680 --> 00:13:03,760
specify one

00:13:02,639 --> 00:13:06,560
it will make one up for you and it's

00:13:03,760 --> 00:13:09,760
almost guaranteed to be the wrong one

00:13:06,560 --> 00:13:12,000
by the way i recommend not using

00:13:09,760 --> 00:13:13,680
null values in there and by the way if

00:13:12,000 --> 00:13:15,680
you're a fan of uuids

00:13:13,680 --> 00:13:17,360
they do not increase monotonically that

00:13:15,680 --> 00:13:18,800
means they don't go by one or some

00:13:17,360 --> 00:13:20,959
preset

00:13:18,800 --> 00:13:22,320
increment if you have to use uuid's

00:13:20,959 --> 00:13:26,000
please use our uuid

00:13:22,320 --> 00:13:27,279
to bin function otherwise avoid uuids if

00:13:26,000 --> 00:13:30,720
possible they're not

00:13:27,279 --> 00:13:33,200
efficient with mysql now

00:13:30,720 --> 00:13:34,639
if you have some data that say like a

00:13:33,200 --> 00:13:36,399
last name

00:13:34,639 --> 00:13:37,760
sometimes you get away with not indexing

00:13:36,399 --> 00:13:40,480
all of it in this case

00:13:37,760 --> 00:13:42,560
we're going to create an index part of

00:13:40,480 --> 00:13:43,920
name on a table called customer

00:13:42,560 --> 00:13:46,720
and we're going to take the name column

00:13:43,920 --> 00:13:49,199
and index just the first 10 characters

00:13:46,720 --> 00:13:50,720
now if you live in a uh in a country

00:13:49,199 --> 00:13:52,720
that lets you

00:13:50,720 --> 00:13:53,920
have names that are longer than 10

00:13:52,720 --> 00:13:56,079
characters

00:13:53,920 --> 00:13:58,000
and you can kind of get in the ballpark

00:13:56,079 --> 00:14:01,920
with 10 or less characters

00:13:58,000 --> 00:14:02,560
this is a good option also you can have

00:14:01,920 --> 00:14:04,959
multiple

00:14:02,560 --> 00:14:06,000
columns in an index in this case we have

00:14:04,959 --> 00:14:09,519
a table

00:14:06,000 --> 00:14:12,320
where we have a column called id

00:14:09,519 --> 00:14:14,079
which will later make a primary key we

00:14:12,320 --> 00:14:16,240
have a last name and first name

00:14:14,079 --> 00:14:17,120
and we're indexing creating an index

00:14:16,240 --> 00:14:19,760
called name

00:14:17,120 --> 00:14:20,560
on the last name and first name now this

00:14:19,760 --> 00:14:22,320
index will work

00:14:20,560 --> 00:14:23,600
on searching for last name and first

00:14:22,320 --> 00:14:26,079
name and last name

00:14:23,600 --> 00:14:26,880
but not first name uh its usage is left

00:14:26,079 --> 00:14:31,199
to right

00:14:26,880 --> 00:14:33,440
uh put the highest cardinality uh first

00:14:31,199 --> 00:14:35,120
and by the way sometimes you can have

00:14:33,440 --> 00:14:36,079
indexes that will hold all the data you

00:14:35,120 --> 00:14:37,199
need to return

00:14:36,079 --> 00:14:39,040
and you don't have to dive in the data

00:14:37,199 --> 00:14:41,040
to get all the information from a index

00:14:39,040 --> 00:14:43,519
we'll talk about that a little bit

00:14:41,040 --> 00:14:45,199
and sometimes you have values that just

00:14:43,519 --> 00:14:47,600
don't quite work

00:14:45,199 --> 00:14:49,519
for indexing and one thing you can try

00:14:47,600 --> 00:14:51,519
is hashing the values in this example we

00:14:49,519 --> 00:14:53,600
have value one and value two

00:14:51,519 --> 00:14:56,079
we're going to concatenate them together

00:14:53,600 --> 00:14:57,680
and then we're gonna do an md5 hash

00:14:56,079 --> 00:15:01,360
i've used this before in parts

00:14:57,680 --> 00:15:01,360
assemblies where um

00:15:01,680 --> 00:15:04,959
maybe it's a model number and a serial

00:15:03,360 --> 00:15:06,480
number put them together and it ends up

00:15:04,959 --> 00:15:09,040
being a better alternative to trying to

00:15:06,480 --> 00:15:11,360
search by the other two

00:15:09,040 --> 00:15:13,040
and of course my skill gives even more

00:15:11,360 --> 00:15:14,639
options unique indexes where there's

00:15:13,040 --> 00:15:16,560
only one value per row

00:15:14,639 --> 00:15:18,480
full text searches for doing uh

00:15:16,560 --> 00:15:20,160
searching for strings for uh certain

00:15:18,480 --> 00:15:22,800
combinations of letters and

00:15:20,160 --> 00:15:24,639
numbers uh covering index that's where

00:15:22,800 --> 00:15:25,920
your index has all the information you

00:15:24,639 --> 00:15:28,959
need

00:15:25,920 --> 00:15:32,160
in my case first name last name zip code

00:15:28,959 --> 00:15:33,360
and patient number my doctor i call it

00:15:32,160 --> 00:15:34,959
they want first last name

00:15:33,360 --> 00:15:36,720
and zip code and i will pull up my

00:15:34,959 --> 00:15:38,160
patient number for them so

00:15:36,720 --> 00:15:40,560
that saves them a little time diamond

00:15:38,160 --> 00:15:42,560
and data talked about secondary indexes

00:15:40,560 --> 00:15:44,160
already spatial indexes if you're

00:15:42,560 --> 00:15:46,399
writing your own um

00:15:44,160 --> 00:15:47,839
google maps or something similar uh you

00:15:46,399 --> 00:15:51,600
can type in okay

00:15:47,839 --> 00:15:53,519
i need a i need to know if this point is

00:15:51,600 --> 00:15:54,079
when this piece of geometry it can tell

00:15:53,519 --> 00:15:55,680
you

00:15:54,079 --> 00:15:57,839
oh i had someone in the chat let's see

00:15:55,680 --> 00:15:59,839
what it says

00:15:57,839 --> 00:16:01,759
is mysql just using a hash table under

00:15:59,839 --> 00:16:05,279
the hood to store all the data

00:16:01,759 --> 00:16:08,639
no it is a full relational table

00:16:05,279 --> 00:16:12,160
now the the json stuff is basically a

00:16:08,639 --> 00:16:12,160
blob but is not a hash table

00:16:12,240 --> 00:16:16,320
okay let's get going functional indexes

00:16:14,399 --> 00:16:17,519
uh this is something that's kind of neat

00:16:16,320 --> 00:16:20,560
you can actually have some sort of

00:16:17,519 --> 00:16:23,600
computation to create your index

00:16:20,560 --> 00:16:26,959
the first one uh creating a table t1

00:16:23,600 --> 00:16:29,600
we have a something called call one that

00:16:26,959 --> 00:16:31,600
we're using the absolute value of that

00:16:29,600 --> 00:16:33,360
uh to get a value this might be

00:16:31,600 --> 00:16:35,519
something that is temperature and you

00:16:33,360 --> 00:16:37,440
don't care whether it's plus or minus

00:16:35,519 --> 00:16:39,120
something you do is maybe you have like

00:16:37,440 --> 00:16:40,720
in this bottom one you have a forty

00:16:39,120 --> 00:16:44,079
percent overhead you gotta charge

00:16:40,720 --> 00:16:45,199
uh for uh cost value uh there's all

00:16:44,079 --> 00:16:48,240
sorts of other com

00:16:45,199 --> 00:16:51,199
complicated uh analysis or calculations

00:16:48,240 --> 00:16:53,360
you to create indexes there

00:16:51,199 --> 00:16:54,399
multi-value indexes in the past you

00:16:53,360 --> 00:16:57,199
could not have

00:16:54,399 --> 00:16:59,040
more entries in an index than you had in

00:16:57,199 --> 00:17:01,360
the actual data table

00:16:59,040 --> 00:17:03,199
well with the json data type people

00:17:01,360 --> 00:17:05,679
started using that because it has a

00:17:03,199 --> 00:17:07,360
an array type and mysql does not have a

00:17:05,679 --> 00:17:09,439
native array data type

00:17:07,360 --> 00:17:11,280
so what we have to do is come up with a

00:17:09,439 --> 00:17:12,959
way to have more

00:17:11,280 --> 00:17:14,480
index entries and there actually rows

00:17:12,959 --> 00:17:15,600
the data and that's our multi-value

00:17:14,480 --> 00:17:18,000
indexes

00:17:15,600 --> 00:17:19,199
in this example we're looking to see if

00:17:18,000 --> 00:17:21,520
the value of three

00:17:19,199 --> 00:17:22,480
is a member of this array and if it is

00:17:21,520 --> 00:17:26,400
it returns a one

00:17:22,480 --> 00:17:28,240
i've got another question let's see

00:17:26,400 --> 00:17:30,080
this number include columns for sql

00:17:28,240 --> 00:17:31,600
server unfortunately i'm

00:17:30,080 --> 00:17:34,160
i haven't played with sql server in many

00:17:31,600 --> 00:17:36,880
long years and i couldn't answer that

00:17:34,160 --> 00:17:36,880
i'm sorry

00:17:37,039 --> 00:17:42,799
thank you ray for that question

00:17:40,240 --> 00:17:44,480
okay my skill has two types of indexes

00:17:42,799 --> 00:17:45,120
the first is a traditional b tree

00:17:44,480 --> 00:17:47,600
actually it's a b

00:17:45,120 --> 00:17:48,240
plus tree so if we're looking for a

00:17:47,600 --> 00:17:52,000
value

00:17:48,240 --> 00:17:55,039
of um let's say

00:17:52,000 --> 00:17:57,360
78 we know we have to take this node

00:17:55,039 --> 00:17:58,320
down to here and then have our pointer

00:17:57,360 --> 00:18:02,080
to our

00:17:58,320 --> 00:18:03,919
our data we also have hashes which is

00:18:02,080 --> 00:18:04,799
where you basically union two tables

00:18:03,919 --> 00:18:08,720
together

00:18:04,799 --> 00:18:11,360
and uh pull out the needed matches there

00:18:08,720 --> 00:18:13,200
this is about a year old in mysql and

00:18:11,360 --> 00:18:14,640
works very very fast if you're doing

00:18:13,200 --> 00:18:17,600
what we call echo joins where you have

00:18:14,640 --> 00:18:19,840
value x is equal to value y

00:18:17,600 --> 00:18:20,640
now please keep in mind if there's a

00:18:19,840 --> 00:18:24,320
choice between

00:18:20,640 --> 00:18:26,160
multiple indexes mysql's heuristic is

00:18:24,320 --> 00:18:28,400
that it tries to take the index that's

00:18:26,160 --> 00:18:30,400
the smallest number of rows

00:18:28,400 --> 00:18:32,000
hopefully the most selective sometimes

00:18:30,400 --> 00:18:33,360
that isn't the right answer but that's

00:18:32,000 --> 00:18:35,039
kind of the rough heuristic and you can

00:18:33,360 --> 00:18:37,039
override that a little bit

00:18:35,039 --> 00:18:38,559
also if you're doing comparisons make

00:18:37,039 --> 00:18:41,600
sure you're comparison

00:18:38,559 --> 00:18:42,000
doing comparisons on similar things for

00:18:41,600 --> 00:18:43,600
example

00:18:42,000 --> 00:18:45,120
here if you're doing a varchar 10 and a

00:18:43,600 --> 00:18:47,039
car 10 they're both roughly character

00:18:45,120 --> 00:18:50,880
data in both size 10.

00:18:47,039 --> 00:18:52,880
but if you're doing a car 10 and car 15

00:18:50,880 --> 00:18:54,960
that machine has to do some extra

00:18:52,880 --> 00:18:57,200
calculations for you to get that there

00:18:54,960 --> 00:18:58,080
cars and integers there's some casting

00:18:57,200 --> 00:19:00,320
has to go on

00:18:58,080 --> 00:19:01,840
and all that casting and all that kind

00:19:00,320 --> 00:19:02,640
of slows you down and it has to be done

00:19:01,840 --> 00:19:07,039
for each row

00:19:02,640 --> 00:19:07,039
and if you can avoid it please do

00:19:07,200 --> 00:19:13,520
okay no this is an interesting subject

00:19:11,280 --> 00:19:14,559
uh the original idea back uh in the

00:19:13,520 --> 00:19:17,760
punch card days

00:19:14,559 --> 00:19:19,760
is that you had one bit of data

00:19:17,760 --> 00:19:21,679
if it was true would be one it was false

00:19:19,760 --> 00:19:23,679
it was zero and then people say well

00:19:21,679 --> 00:19:25,120
how to record that we don't know what

00:19:23,679 --> 00:19:25,520
the value is and they came up with the

00:19:25,120 --> 00:19:28,799
idea

00:19:25,520 --> 00:19:30,320
no the trouble is you if you have just

00:19:28,799 --> 00:19:32,880
one bit you just can't do

00:19:30,320 --> 00:19:34,480
no with one bit you can do with two bits

00:19:32,880 --> 00:19:38,000
either the null's on or no

00:19:34,480 --> 00:19:40,720
off and uh this is a cute representation

00:19:38,000 --> 00:19:41,200
of the idea of null now the trouble with

00:19:40,720 --> 00:19:43,760
nulls

00:19:41,200 --> 00:19:45,360
is basically they're not a value so if

00:19:43,760 --> 00:19:47,840
you have a whole bunch of

00:19:45,360 --> 00:19:49,919
uh values you're searching through and

00:19:47,840 --> 00:19:52,400
you have nulls in there

00:19:49,919 --> 00:19:53,919
everything's screaming along until it

00:19:52,400 --> 00:19:55,840
has to go through the junk drawer full

00:19:53,919 --> 00:19:57,120
of nulls to search for the matches and

00:19:55,840 --> 00:20:01,600
that slows things down

00:19:57,120 --> 00:20:05,280
so if you can avoid using nulls in a

00:20:01,600 --> 00:20:07,039
in a index column the better

00:20:05,280 --> 00:20:09,039
now something added with my scale 8-0

00:20:07,039 --> 00:20:12,240
which is now coming up on its third

00:20:09,039 --> 00:20:14,480
anniversary is invisible indexes

00:20:12,240 --> 00:20:16,080
in the past whoops got another q a up

00:20:14,480 --> 00:20:17,840
here

00:20:16,080 --> 00:20:19,440
how does the full text search work i

00:20:17,840 --> 00:20:21,679
don't have a text down to change

00:20:19,440 --> 00:20:24,000
or does it do the tokenization i believe

00:20:21,679 --> 00:20:27,039
it's text analyzer chains it doesn't do

00:20:24,000 --> 00:20:27,840
tokenization to my knowledge uh the idea

00:20:27,039 --> 00:20:31,039
is it

00:20:27,840 --> 00:20:32,720
takes your your text and creates an

00:20:31,039 --> 00:20:33,440
index into that so if you're searching

00:20:32,720 --> 00:20:36,240
for

00:20:33,440 --> 00:20:38,320
t-h-e it has a bunch of things to start

00:20:36,240 --> 00:20:39,919
with t-h-e you type in an art knows oh

00:20:38,320 --> 00:20:41,520
it's gonna be

00:20:39,919 --> 00:20:43,280
there or something similar and it kind

00:20:41,520 --> 00:20:44,880
of changes down through that

00:20:43,280 --> 00:20:47,120
i'm sure my engineering friends are

00:20:44,880 --> 00:20:49,600
laughing at me i'm not that

00:20:47,120 --> 00:20:51,360
bad description okay before individual

00:20:49,600 --> 00:20:52,080
indexes you were running explain on a

00:20:51,360 --> 00:20:54,720
query

00:20:52,080 --> 00:20:55,760
and one of the indexes that was a

00:20:54,720 --> 00:20:57,679
possibility

00:20:55,760 --> 00:20:59,840
you're not sure if it was a good one so

00:20:57,679 --> 00:21:00,480
you doubt the useful enough news of that

00:20:59,840 --> 00:21:02,000
index

00:21:00,480 --> 00:21:04,080
you check it running explain you're

00:21:02,000 --> 00:21:07,039
still not sure if it's good or bad

00:21:04,080 --> 00:21:07,520
you remove that index and you rerun

00:21:07,039 --> 00:21:08,960
explain

00:21:07,520 --> 00:21:10,880
and as you're re-running explain you get

00:21:08,960 --> 00:21:12,720
a phone call a text or a screen from a

00:21:10,880 --> 00:21:15,440
pal user about how somebody

00:21:12,720 --> 00:21:16,960
their query has turned to glacial

00:21:15,440 --> 00:21:18,559
progress

00:21:16,960 --> 00:21:20,720
well then you suddenly realize that that

00:21:18,559 --> 00:21:23,039
index may not be good for your query but

00:21:20,720 --> 00:21:24,559
a lot of other people are waiting for

00:21:23,039 --> 00:21:26,080
that index and really need it

00:21:24,559 --> 00:21:28,840
so you have to go out and rebuild that

00:21:26,080 --> 00:21:30,240
index which can take quite a long time

00:21:28,840 --> 00:21:32,640
unfortunately now

00:21:30,240 --> 00:21:34,240
after invisible indexes you doubt the

00:21:32,640 --> 00:21:36,480
usefulness of the index

00:21:34,240 --> 00:21:38,400
you check the query running explain you

00:21:36,480 --> 00:21:40,559
make that index invisible in other words

00:21:38,400 --> 00:21:41,760
the optimizer cannot see that index it's

00:21:40,559 --> 00:21:43,440
like you've thrown

00:21:41,760 --> 00:21:45,919
harry potter's invisibility cloak over

00:21:43,440 --> 00:21:47,200
it and it may be there but the optimizer

00:21:45,919 --> 00:21:50,000
can't see it

00:21:47,200 --> 00:21:51,200
you rerun explain you get a phone call

00:21:50,000 --> 00:21:53,600
from

00:21:51,200 --> 00:21:55,200
the power user and you basically make

00:21:53,600 --> 00:21:56,480
the index visible again

00:21:55,200 --> 00:21:58,640
and then you blame the problem on the

00:21:56,480 --> 00:21:59,039
network javascript gdpr slack or the

00:21:58,640 --> 00:22:00,480
cloud

00:21:59,039 --> 00:22:02,320
i got another question let's see what i

00:22:00,480 --> 00:22:04,960
can do

00:22:02,320 --> 00:22:04,960
that's the uh

00:22:06,799 --> 00:22:12,159
the last one queen okay uh syskema

00:22:10,400 --> 00:22:13,440
is very interesting and helpful

00:22:12,159 --> 00:22:14,640
especially if you turn on my skull

00:22:13,440 --> 00:22:15,440
workbench will give you a lot of this

00:22:14,640 --> 00:22:17,919
information

00:22:15,440 --> 00:22:19,360
it will tell you what indexes have not

00:22:17,919 --> 00:22:22,640
been used in a while

00:22:19,360 --> 00:22:24,799
uh the trouble here is that the data is

00:22:22,640 --> 00:22:26,720
only good from the last reboot

00:22:24,799 --> 00:22:28,799
so if you reboot it on monday you have

00:22:26,720 --> 00:22:31,440
an index that might be used maybe once a

00:22:28,799 --> 00:22:33,280
week or once a month or once a quarter

00:22:31,440 --> 00:22:35,679
and that might be a very valuable index

00:22:33,280 --> 00:22:37,280
so if you have an index that you uh

00:22:35,679 --> 00:22:38,720
shows up on this list and you think it's

00:22:37,280 --> 00:22:41,360
a candidate for removal

00:22:38,720 --> 00:22:42,320
make it invisible for a while a good six

00:22:41,360 --> 00:22:45,520
months to a year

00:22:42,320 --> 00:22:47,760
before blowing it away just in case

00:22:45,520 --> 00:22:49,120
how do you use invisible index alter

00:22:47,760 --> 00:22:51,919
table

00:22:49,120 --> 00:22:52,240
in this case t1 alter index in the index

00:22:51,919 --> 00:22:54,159
name

00:22:52,240 --> 00:22:56,080
and make it invisible now the optimizer

00:22:54,159 --> 00:22:56,720
can't see it i want to turn it visible

00:22:56,080 --> 00:22:58,960
again

00:22:56,720 --> 00:23:01,200
you just do alter cable with invisible

00:22:58,960 --> 00:23:04,080
at the end

00:23:01,200 --> 00:23:05,360
okay on to histograms well histograms

00:23:04,080 --> 00:23:06,400
are also something that came out with

00:23:05,360 --> 00:23:08,559
mysql80

00:23:06,400 --> 00:23:09,760
and no it's not a gluten-free keto

00:23:08,559 --> 00:23:12,000
friendly biscuit

00:23:09,760 --> 00:23:13,840
it's actually a measurement this is an

00:23:12,000 --> 00:23:16,000
example of a histogram

00:23:13,840 --> 00:23:18,159
someone went out and measured the height

00:23:16,000 --> 00:23:20,159
of 10 000 us females

00:23:18,159 --> 00:23:22,559
in centimeters and they created this

00:23:20,159 --> 00:23:24,720
lovely little bar chart think of each

00:23:22,559 --> 00:23:26,799
one of these vertical bars as a bucket

00:23:24,720 --> 00:23:28,720
full of data

00:23:26,799 --> 00:23:29,840
so wikipedia says the histogram is an

00:23:28,720 --> 00:23:31,760
accurate representation of the

00:23:29,840 --> 00:23:33,200
distribution numerical data

00:23:31,760 --> 00:23:34,720
for relational database management the

00:23:33,200 --> 00:23:36,000
histogram is an approximation of data

00:23:34,720 --> 00:23:39,200
distribution within a specific

00:23:36,000 --> 00:23:40,960
column what that does is

00:23:39,200 --> 00:23:42,880
once the optimizer knows how the data is

00:23:40,960 --> 00:23:44,400
laid out in the column it can find the

00:23:42,880 --> 00:23:46,799
data much more efficiently

00:23:44,400 --> 00:23:48,799
efficiently and i have a good example

00:23:46,799 --> 00:23:51,200
coming up

00:23:48,799 --> 00:23:51,919
so we have two types of histograms

00:23:51,200 --> 00:23:54,799
singleton

00:23:51,919 --> 00:23:56,400
and equiheight and uh think of these as

00:23:54,799 --> 00:24:00,159
buckets it was a maximum of

00:23:56,400 --> 00:24:04,080
1024 per column now a singleton

00:24:00,159 --> 00:24:05,679
is a single value in there um like 15.

00:24:04,080 --> 00:24:07,840
equal height is where you have 10

00:24:05,679 --> 00:24:10,960
buckets and you put 10 percent

00:24:07,840 --> 00:24:13,200
of your data into each bucket

00:24:10,960 --> 00:24:14,159
now histograms are primarily useful for

00:24:13,200 --> 00:24:17,039
non-index

00:24:14,159 --> 00:24:18,400
columns and data that does not churn a

00:24:17,039 --> 00:24:20,400
histogram can be created

00:24:18,400 --> 00:24:22,880
on demand so you can put into a crown

00:24:20,400 --> 00:24:25,600
table to run when things are quiet

00:24:22,880 --> 00:24:26,880
it doesn't have overhead the way an

00:24:25,600 --> 00:24:29,279
index has

00:24:26,880 --> 00:24:30,799
and the statistics are very very good

00:24:29,279 --> 00:24:32,240
for the optimizer

00:24:30,799 --> 00:24:34,960
now why would you use histogram instead

00:24:32,240 --> 00:24:38,159
of an index well maintaining an index

00:24:34,960 --> 00:24:39,600
has a cost anytime you do an insert an

00:24:38,159 --> 00:24:42,559
update or delete

00:24:39,600 --> 00:24:44,080
that means the index as well as the data

00:24:42,559 --> 00:24:46,559
has to be updated

00:24:44,080 --> 00:24:48,080
and on busy systems this can get very

00:24:46,559 --> 00:24:49,760
very expensive

00:24:48,080 --> 00:24:51,679
by the way from time to time the

00:24:49,760 --> 00:24:54,880
optimizer optimizer will take index

00:24:51,679 --> 00:24:57,279
dives to double check the statistics

00:24:54,880 --> 00:24:59,039
in some cases this can become very

00:24:57,279 --> 00:24:59,440
costly and it often happens at the worst

00:24:59,039 --> 00:25:00,480
time

00:24:59,440 --> 00:25:01,840
when you're trying to crank out

00:25:00,480 --> 00:25:04,240
something on a friday afternoon for

00:25:01,840 --> 00:25:06,320
payroll

00:25:04,240 --> 00:25:08,400
now occasionally the optimizer fails to

00:25:06,320 --> 00:25:09,919
find the most efficient plan and ends up

00:25:08,400 --> 00:25:11,279
spending a lot time executing the query

00:25:09,919 --> 00:25:13,200
than necessary

00:25:11,279 --> 00:25:15,039
now the optimizers assume that the data

00:25:13,200 --> 00:25:19,600
is evenly distributed in a column

00:25:15,039 --> 00:25:21,679
which is sometimes true but often not

00:25:19,600 --> 00:25:23,360
the optimizer just doesn't know how many

00:25:21,679 --> 00:25:25,919
good rows are in each table

00:25:23,360 --> 00:25:27,279
how many values are in each column and

00:25:25,919 --> 00:25:28,640
how is the data distributed it's going

00:25:27,279 --> 00:25:30,799
to assume that everything's distributed

00:25:28,640 --> 00:25:32,320
evenly which is not often the case

00:25:30,799 --> 00:25:35,120
as i mentioned two earlier we have two

00:25:32,320 --> 00:25:36,400
types of histograms the equiheit and the

00:25:35,120 --> 00:25:38,880
singleton

00:25:36,400 --> 00:25:39,600
equiheit is you're dividing up the third

00:25:38,880 --> 00:25:41,360
grade class

00:25:39,600 --> 00:25:42,640
with all the people whose last names

00:25:41,360 --> 00:25:45,039
begin with an a to g

00:25:42,640 --> 00:25:46,000
in one row htl the next m to z in the

00:25:45,039 --> 00:25:47,679
next

00:25:46,000 --> 00:25:50,640
uh singleton i have a good example that

00:25:47,679 --> 00:25:53,679
coming up in just a minute

00:25:50,640 --> 00:25:55,679
so let's take a look at a histogram and

00:25:53,679 --> 00:25:59,200
take a look at the frequency

00:25:55,679 --> 00:26:00,960
we have three possible values 101 102

00:25:59,200 --> 00:26:03,520
and 104 have no idea what happened to

00:26:00,960 --> 00:26:06,559
103. we're going to insert into a table

00:26:03,520 --> 00:26:09,760
called frequency histogram two 101s

00:26:06,559 --> 00:26:11,840
three 102s and 1104.

00:26:09,760 --> 00:26:12,799
and we looked at our data there's our

00:26:11,840 --> 00:26:15,840
two 101s

00:26:12,799 --> 00:26:17,120
3102s and the 1 104 and we create a

00:26:15,840 --> 00:26:19,679
histogram on there

00:26:17,120 --> 00:26:21,039
with three buckets so all the 101s are

00:26:19,679 --> 00:26:23,520
in one bucket exact

00:26:21,039 --> 00:26:24,559
etc so if we take a look at our

00:26:23,520 --> 00:26:28,159
information schema

00:26:24,559 --> 00:26:29,919
on the statistics um we can find out

00:26:28,159 --> 00:26:33,279
what the histogram looks like

00:26:29,919 --> 00:26:33,679
we know that 33 of all data is going to

00:26:33,279 --> 00:26:36,960
be

00:26:33,679 --> 00:26:39,919
values in the first 101 bucket

00:26:36,960 --> 00:26:40,720
we know if you look at 101 and 102

00:26:39,919 --> 00:26:43,600
together

00:26:40,720 --> 00:26:46,720
that's 83 percent of your data and if

00:26:43,600 --> 00:26:50,320
you look at 103 102 and 104 that's 100

00:26:46,720 --> 00:26:54,720
of your data and if you look at the

00:26:50,320 --> 00:26:58,400
cumulative frequency you see 101 is 33

00:26:54,720 --> 00:26:59,120
83 for 102 and 104 if you're getting all

00:26:58,400 --> 00:27:01,600
the values

00:26:59,120 --> 00:27:03,200
up to 104 you got 100 of the values uh

00:27:01,600 --> 00:27:05,279
even though the frequency

00:27:03,200 --> 00:27:07,600
is not as impressive with the cumulative

00:27:05,279 --> 00:27:09,840
frequency the optimizer knows where the

00:27:07,600 --> 00:27:12,400
data is

00:27:09,840 --> 00:27:14,159
so how do you create a histogram well

00:27:12,400 --> 00:27:16,400
you type analyze table

00:27:14,159 --> 00:27:19,120
update histogram in this case we're

00:27:16,400 --> 00:27:20,480
going to create histograms on columns c1

00:27:19,120 --> 00:27:22,960
c2 and c3

00:27:20,480 --> 00:27:24,240
each with 10 buckets we work with the

00:27:22,960 --> 00:27:26,480
data i realize it needs

00:27:24,240 --> 00:27:28,480
updating you run analyze again and

00:27:26,480 --> 00:27:30,399
update the buckets on c1 and c2

00:27:28,480 --> 00:27:32,000
and to get rid of the bucket on c2 we

00:27:30,399 --> 00:27:33,760
can do drop histogram

00:27:32,000 --> 00:27:35,760
now these are three different histograms

00:27:33,760 --> 00:27:36,960
with three different uses

00:27:35,760 --> 00:27:39,120
i can get information from the

00:27:36,960 --> 00:27:40,720
histograms from the information schema

00:27:39,120 --> 00:27:42,159
i can tell you the data type and the

00:27:40,720 --> 00:27:45,760
number of buckets that you

00:27:42,159 --> 00:27:48,960
are using now here's an example of where

00:27:45,760 --> 00:27:50,720
histograms really shine and you'll have

00:27:48,960 --> 00:27:52,880
to indulge me here this is probably not

00:27:50,720 --> 00:27:54,880
the easiest

00:27:52,880 --> 00:27:56,159
explanation out there but it does work

00:27:54,880 --> 00:27:56,880
so we're going to create a table called

00:27:56,159 --> 00:27:59,919
h1

00:27:56,880 --> 00:28:02,640
which has a id column and a

00:27:59,919 --> 00:28:04,000
column called x it's an integer so we're

00:28:02,640 --> 00:28:06,880
going to insert two ones

00:28:04,000 --> 00:28:07,679
three twos and four threes into our

00:28:06,880 --> 00:28:10,480
table

00:28:07,679 --> 00:28:13,200
and if we do a count of those two ones

00:28:10,480 --> 00:28:16,240
three twos and four threes

00:28:13,200 --> 00:28:17,840
now without a histogram and we run a

00:28:16,240 --> 00:28:20,080
query that says okay select everything

00:28:17,840 --> 00:28:21,760
from h1 where x has a value greater than

00:28:20,080 --> 00:28:24,399
zero

00:28:21,760 --> 00:28:25,919
the optimizer has some information but

00:28:24,399 --> 00:28:28,399
it doesn't have really good information

00:28:25,919 --> 00:28:31,520
so this filtered column here

00:28:28,399 --> 00:28:33,760
is its estimate of the percentage of

00:28:31,520 --> 00:28:34,880
rows it's going to have to read it knows

00:28:33,760 --> 00:28:36,799
it has three

00:28:34,880 --> 00:28:38,480
nine rows out there and it's guessing

00:28:36,799 --> 00:28:39,840
it's going to have to read at least a

00:28:38,480 --> 00:28:42,080
third of those

00:28:39,840 --> 00:28:43,200
well imagine that's uh trips to the

00:28:42,080 --> 00:28:45,840
grocery store

00:28:43,200 --> 00:28:48,559
or other trips you have to do it's going

00:28:45,840 --> 00:28:51,919
to tell you yeah i can do that

00:28:48,559 --> 00:28:52,399
i can get all that with with three out

00:28:51,919 --> 00:28:55,600
of

00:28:52,399 --> 00:28:57,919
nine trips

00:28:55,600 --> 00:28:59,679
now this is kind of a rush estimate but

00:28:57,919 --> 00:29:02,399
it is kind of a

00:28:59,679 --> 00:29:03,679
a good thing but remember here it thinks

00:29:02,399 --> 00:29:05,520
it's going to have to make

00:29:03,679 --> 00:29:07,760
you're going to have to read 33 of our

00:29:05,520 --> 00:29:10,000
nine rows

00:29:07,760 --> 00:29:11,520
so let's create a histogram with three

00:29:10,000 --> 00:29:12,880
buckets

00:29:11,520 --> 00:29:14,559
and this time when we learn the same

00:29:12,880 --> 00:29:16,159
query select star from h1 where x is

00:29:14,559 --> 00:29:19,279
greater than zero

00:29:16,159 --> 00:29:21,679
it now knows that

00:29:19,279 --> 00:29:23,279
it's going to have to read all the rows

00:29:21,679 --> 00:29:25,919
of our nine rows to get

00:29:23,279 --> 00:29:26,480
all those values or before it had a

00:29:25,919 --> 00:29:29,200
rough

00:29:26,480 --> 00:29:29,760
idea of where how much it had to read so

00:29:29,200 --> 00:29:31,440
this was

00:29:29,760 --> 00:29:33,039
able to be able to grab things and give

00:29:31,440 --> 00:29:33,679
us a better estimate so instead of

00:29:33,039 --> 00:29:34,960
saying

00:29:33,679 --> 00:29:36,640
you know i could do this in two days it

00:29:34,960 --> 00:29:38,960
knew it could actually do it in four

00:29:36,640 --> 00:29:41,279
days

00:29:38,960 --> 00:29:43,120
i'll skip over that now performance is

00:29:41,279 --> 00:29:45,120
not just not indexes and histograms

00:29:43,120 --> 00:29:46,799
there's lots of other things out there

00:29:45,120 --> 00:29:48,480
um when you use explained you'll see

00:29:46,799 --> 00:29:50,000
things like file sources where your data

00:29:48,480 --> 00:29:52,960
has to actually be written out to disk

00:29:50,000 --> 00:29:55,039
and or memory and sorted uh full table

00:29:52,960 --> 00:29:56,159
scans this is the entire data table has

00:29:55,039 --> 00:29:57,840
to be read

00:29:56,159 --> 00:30:00,320
uh if you're doing something like

00:29:57,840 --> 00:30:01,600
quarterly reports or monthly invoices

00:30:00,320 --> 00:30:04,240
you have to go from the front to the

00:30:01,600 --> 00:30:06,720
back anyway usually you don't want

00:30:04,240 --> 00:30:08,000
full table scans uh seeing full table

00:30:06,720 --> 00:30:10,000
scans means you may

00:30:08,000 --> 00:30:11,360
may not have a proper index or any

00:30:10,000 --> 00:30:12,960
indexes at all

00:30:11,360 --> 00:30:14,720
uh temporary tables which are vastly

00:30:12,960 --> 00:30:16,480
improved in nato uh that's another thing

00:30:14,720 --> 00:30:18,320
can slow you down

00:30:16,480 --> 00:30:19,679
after a while you get used to a database

00:30:18,320 --> 00:30:21,520
and you can tell

00:30:19,679 --> 00:30:23,520
uh if the joint order looks right and

00:30:21,520 --> 00:30:24,240
sometimes the optimizer just does not do

00:30:23,520 --> 00:30:25,919
that

00:30:24,240 --> 00:30:27,360
and there's the more systemic stuff you

00:30:25,919 --> 00:30:28,880
know are your buffers and cache is big

00:30:27,360 --> 00:30:30,880
enough do you have enough memory

00:30:28,880 --> 00:30:32,799
is your i o fast enough or your discs

00:30:30,880 --> 00:30:35,679
are just like devices keeping up with

00:30:32,799 --> 00:30:38,080
your need now i'm going to skip over a

00:30:35,679 --> 00:30:40,640
lot of these things unlocking options

00:30:38,080 --> 00:30:41,760
and other ways to speed things up

00:30:40,640 --> 00:30:43,840
because

00:30:41,760 --> 00:30:45,919
um they're out there on the regular

00:30:43,840 --> 00:30:48,320
slides but i wanted to leave

00:30:45,919 --> 00:30:50,240
10 15 minutes for q a by the way the

00:30:48,320 --> 00:30:52,720
full slides are at slideshare.net

00:30:50,240 --> 00:30:53,679
dave stokes on other other things you

00:30:52,720 --> 00:30:56,080
can do

00:30:53,679 --> 00:30:59,279
like resource groups using multi-volume

00:30:56,080 --> 00:31:01,279
indexes optimizer hints and partitioning

00:30:59,279 --> 00:31:03,039
now if you're really interested in this

00:31:01,279 --> 00:31:05,679
and you want to play with it i highly

00:31:03,039 --> 00:31:07,679
recommend reading the mysql manual

00:31:05,679 --> 00:31:10,320
probably the best single source by the

00:31:07,679 --> 00:31:11,519
way between releases we do update this

00:31:10,320 --> 00:31:12,960
so

00:31:11,519 --> 00:31:14,399
there might be stuff in there that's

00:31:12,960 --> 00:31:16,159
that's new it's worth a re-read on a

00:31:14,399 --> 00:31:19,000
regular basis

00:31:16,159 --> 00:31:20,320
if you have questions we have forums at

00:31:19,000 --> 00:31:21,760
forums.mysql.com

00:31:20,320 --> 00:31:24,080
our engineers take a look at on a

00:31:21,760 --> 00:31:27,279
regular basis so chances are

00:31:24,080 --> 00:31:30,240
you can get a really a plus answer

00:31:27,279 --> 00:31:32,120
if you're a little bit patient uh also i

00:31:30,240 --> 00:31:33,679
recommend highly joining

00:31:32,120 --> 00:31:35,840
mysqlcommunity.slack.com you are part of

00:31:33,679 --> 00:31:39,200
the mysql community so please join in

00:31:35,840 --> 00:31:42,960
uh our engineers really monitor this uh

00:31:39,200 --> 00:31:47,519
great place for information on mysql

00:31:42,960 --> 00:31:50,559
and a lot of value information out there

00:31:47,519 --> 00:31:52,559
now here's two books i recommend i uh

00:31:50,559 --> 00:31:54,000
highly recommend this author jesper

00:31:52,559 --> 00:31:56,080
wisbord crowe

00:31:54,000 --> 00:31:57,919
he used to be mysql support he's now off

00:31:56,080 --> 00:32:01,120
at another company

00:31:57,919 --> 00:32:02,159
but he writes very well explains things

00:32:01,120 --> 00:32:05,679
very easily

00:32:02,159 --> 00:32:07,279
for highly uh detailed subjects i reread

00:32:05,679 --> 00:32:10,320
these books on a regular basis

00:32:07,279 --> 00:32:12,880
and i find more information every time

00:32:10,320 --> 00:32:14,159
you do need these books all his other

00:32:12,880 --> 00:32:14,960
books like the one on the python

00:32:14,159 --> 00:32:16,720
connector are

00:32:14,960 --> 00:32:18,720
absolutely amazing i recommend buying

00:32:16,720 --> 00:32:21,919
everything of his

00:32:18,720 --> 00:32:23,760
now this is another book that i i kind

00:32:21,919 --> 00:32:25,360
of hesitate to recommend

00:32:23,760 --> 00:32:27,760
the third edition has been out for

00:32:25,360 --> 00:32:29,039
several years it's getting dated

00:32:27,760 --> 00:32:30,480
you can usually find it and use

00:32:29,039 --> 00:32:31,600
bookstores make sure you get the third

00:32:30,480 --> 00:32:33,120
edition

00:32:31,600 --> 00:32:35,760
the first and second editions are very

00:32:33,120 --> 00:32:37,360
very old supposedly a fourth edition is

00:32:35,760 --> 00:32:39,840
in the works and i do not believe the

00:32:37,360 --> 00:32:41,360
original authors are involved

00:32:39,840 --> 00:32:43,440
but it has a lot of good explanations

00:32:41,360 --> 00:32:45,840
about how a lot of things work at the

00:32:43,440 --> 00:32:48,640
lower level mysql

00:32:45,840 --> 00:32:49,760
now if you're using the json data type

00:32:48,640 --> 00:32:52,480
and

00:32:49,760 --> 00:32:54,080
uh can't make heads of tails through the

00:32:52,480 --> 00:32:56,799
through the documentation please buy a

00:32:54,080 --> 00:32:58,320
copy of my book it's available on amazon

00:32:56,799 --> 00:33:00,399
second edition came out a couple months

00:32:58,320 --> 00:33:01,519
ago lots of programming examples and

00:33:00,399 --> 00:33:03,120
best practices

00:33:01,519 --> 00:33:04,960
this is a book that you can sit down

00:33:03,120 --> 00:33:06,159
with no knowledge of json

00:33:04,960 --> 00:33:08,640
and be able to use it relational

00:33:06,159 --> 00:33:10,640
database or a new sql document store

00:33:08,640 --> 00:33:12,960
the mysql moscow nosql document store

00:33:10,640 --> 00:33:14,399
very easily and the second edition

00:33:12,960 --> 00:33:16,080
in the two years since i published the

00:33:14,399 --> 00:33:17,600
first one i was able to add twice the

00:33:16,080 --> 00:33:18,000
material i'm getting more material and

00:33:17,600 --> 00:33:20,000
i'm

00:33:18,000 --> 00:33:21,200
not being coarse yet do a third edition

00:33:20,000 --> 00:33:24,559
but that might be

00:33:21,200 --> 00:33:26,000
two or three years down the road also if

00:33:24,559 --> 00:33:27,760
you are in a startup

00:33:26,000 --> 00:33:29,679
i have a deal for you i'm one of the

00:33:27,760 --> 00:33:32,240
startup ambassadors

00:33:29,679 --> 00:33:33,919
if you go to oracle.com startup there's

00:33:32,240 --> 00:33:34,559
a lot of stuff that oracle wants to give

00:33:33,919 --> 00:33:37,360
you

00:33:34,559 --> 00:33:38,799
discounts uh we can give you some

00:33:37,360 --> 00:33:40,640
marketing exposure

00:33:38,799 --> 00:33:42,159
uh we invite you to events to show off

00:33:40,640 --> 00:33:43,039
what you're doing and help promote what

00:33:42,159 --> 00:33:46,159
you're doing

00:33:43,039 --> 00:33:47,120
uh there's some mentorship and exposure

00:33:46,159 --> 00:33:50,320
to

00:33:47,120 --> 00:33:53,440
almost half a million oracle customers

00:33:50,320 --> 00:33:55,679
and uh it's free to join and has a lot

00:33:53,440 --> 00:33:57,760
of great stuff there

00:33:55,679 --> 00:33:59,200
and with that uh if you need to get a

00:33:57,760 --> 00:34:00,399
hold of me i'm david.stokes at

00:33:59,200 --> 00:34:03,360
oracle.com

00:34:00,399 --> 00:34:04,720
at stoker on twitter i have a php

00:34:03,360 --> 00:34:07,679
related blog

00:34:04,720 --> 00:34:09,839
elephant elephantdolphin.blogspot.com

00:34:07,679 --> 00:34:10,240
dolphin is the mysql mascot elephant is

00:34:09,839 --> 00:34:12,800
the

00:34:10,240 --> 00:34:14,399
php mascot if you're looking for the

00:34:12,800 --> 00:34:15,599
latest mysql blogs to see what's going

00:34:14,399 --> 00:34:18,639
on with the mysql

00:34:15,599 --> 00:34:20,399
world planet.mysql.com once again we

00:34:18,639 --> 00:34:21,960
have the forums and i highly encourage

00:34:20,399 --> 00:34:23,919
you to go out to moscow

00:34:21,960 --> 00:34:25,359
community.slack.com and join there

00:34:23,919 --> 00:34:27,839
and once again these slides are on

00:34:25,359 --> 00:34:29,760
slideshow.net and let me go out to the q

00:34:27,839 --> 00:34:32,480
and a

00:34:29,760 --> 00:34:32,480
and uh

00:34:33,040 --> 00:34:38,480
that was awesome thank you dave okay

00:34:36,560 --> 00:34:40,159
i think we got everything well thank you

00:34:38,480 --> 00:34:41,119
for having me and thanks for for hosting

00:34:40,159 --> 00:34:42,800
me

00:34:41,119 --> 00:34:44,560
and uh this is a wonderful show

00:34:42,800 --> 00:34:45,760
hopefully we'll be in person next year

00:34:44,560 --> 00:34:48,639
and once again i want to plug the

00:34:45,760 --> 00:34:49,359
october show todd and his crew do an

00:34:48,639 --> 00:34:52,000
amazing job

00:34:49,359 --> 00:34:54,560
every year jennifer suber who's his

00:34:52,000 --> 00:34:54,560
right hand

00:34:54,960 --> 00:34:58,480
majordomo does an amazing job handling

00:34:56,879 --> 00:35:02,079
me because i'm always forgetting stuff

00:34:58,480 --> 00:35:05,119
and here's some more questions

00:35:02,079 --> 00:35:07,520
i see a question yeah great talk thank

00:35:05,119 --> 00:35:09,040
you very much from

00:35:07,520 --> 00:35:11,359
from uh just says the first three

00:35:09,040 --> 00:35:13,119
letters

00:35:11,359 --> 00:35:14,480
well hopefully we'll be our index is

00:35:13,119 --> 00:35:17,280
stored in an object file or separate

00:35:14,480 --> 00:35:18,640
files um

00:35:17,280 --> 00:35:20,800
they're actually stored with the data

00:35:18,640 --> 00:35:23,200
but i really couldn't give you a

00:35:20,800 --> 00:35:24,880
decent explanation in under 25 minutes

00:35:23,200 --> 00:35:26,720
and a whiteboard and some very

00:35:24,880 --> 00:35:28,800
misleading drawings

00:35:26,720 --> 00:35:30,320
if you really really want to know go out

00:35:28,800 --> 00:35:32,320
to the mysql community

00:35:30,320 --> 00:35:33,359
and ask someone where the layouts are

00:35:32,320 --> 00:35:34,960
they can point you to it

00:35:33,359 --> 00:35:37,280
by the way the source for mysql is out

00:35:34,960 --> 00:35:40,320
on github so if you want to uh

00:35:37,280 --> 00:35:42,240
to work with that it's out there and

00:35:40,320 --> 00:35:43,440
thank you ray for saying uh thanks david

00:35:42,240 --> 00:35:45,359
appreciate the guns from this we'll be

00:35:43,440 --> 00:35:47,040
exploring this in detail

00:35:45,359 --> 00:35:48,720
well thank you all for turning out i'm

00:35:47,040 --> 00:35:50,400
the last talk in the session i think we

00:35:48,720 --> 00:35:51,599
have to stand by for the prizes and

00:35:50,400 --> 00:35:55,440
giveaways

00:35:51,599 --> 00:35:56,960
and uh i think that's it for me

00:35:55,440 --> 00:35:59,280
thank you dave yeah i think i see a

00:35:56,960 --> 00:36:01,440
question in the q a

00:35:59,280 --> 00:36:03,920
how does the full text search work does

00:36:01,440 --> 00:36:05,359
it have text analyzer chains

00:36:03,920 --> 00:36:06,880
i think it's text analyzing change but

00:36:05,359 --> 00:36:08,640
it might be tokenization i'm not really

00:36:06,880 --> 00:36:09,359
sure i think it's more text analyzer i

00:36:08,640 --> 00:36:11,839
don't

00:36:09,359 --> 00:36:14,160
i don't play with the uh in the bits

00:36:11,839 --> 00:36:16,400
anymore

00:36:14,160 --> 00:36:16,400
okay

00:36:18,960 --> 00:36:22,720
okay folks well if that's it uh or

00:36:20,880 --> 00:36:27,839
you're too shy

00:36:22,720 --> 00:36:27,839

YouTube URL: https://www.youtube.com/watch?v=5oLBxlce1Ns


