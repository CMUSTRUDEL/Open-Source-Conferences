Title: "Adding Scripting to Your Application" - Matthew Burke - Capital One - Open Source 101
Publication date: 2021-04-07
Playlist: Open Source 101 2021
Description: 
	Matthew Burke, Software Engineer at Capital One, delivered a talk titled "Adding Scripting to Your Application" at Open Source 101 on Tuesday, March 30, 2021.

Abstract:
In this talk, I will discuss the reasons why you might want to add scripting to your application. These reasons include facilitating debugging, tuning, prototyping, extensibility, and flexible configuration. I will then turn to examine some of the options for adding scriptings such as Python, Guile, and Lua.

The majority of the presentation will consist of a simple, how-to demonstration. Here I will present a simple C application, add an embedded Lua interpreter and show how to extend the app with a couple of Lua commands. The emphasis will be on explaining Luaâ€™s embedding API.

Find Matthew on the internets:
Twitter: https://twitter.com/profburke
LinkedIn: https://www.linkedin.com/in/matthewmburke/
GitHub: https://github.com/profburke
Personal Website: https://matthewburke.com/
Captions: 
	00:00:05,279 --> 00:00:07,919
thank you

00:00:06,319 --> 00:00:09,519
uh good afternoon everybody and thank

00:00:07,919 --> 00:00:11,519
you for coming to the talk

00:00:09,519 --> 00:00:13,280
uh i'm i'm assuming people are here

00:00:11,519 --> 00:00:16,800
because it says that there are

00:00:13,280 --> 00:00:19,279
36 participants up on the little toolbar

00:00:16,800 --> 00:00:21,279
uh you're into this i'm still not

00:00:19,279 --> 00:00:24,800
particularly used to

00:00:21,279 --> 00:00:24,800
speaking to a uh

00:00:25,039 --> 00:00:28,240
a blank screen well it's not blank i can

00:00:27,359 --> 00:00:30,880
see my

00:00:28,240 --> 00:00:32,399
see my slides but but no audience which

00:00:30,880 --> 00:00:33,840
is kind of a bummer but we'll just do

00:00:32,399 --> 00:00:35,600
the best that we can

00:00:33,840 --> 00:00:38,079
anyway my name is matthew burke i'm a

00:00:35,600 --> 00:00:39,680
mobile software developer at capital one

00:00:38,079 --> 00:00:43,200
and i'm going to talk about adding

00:00:39,680 --> 00:00:46,800
scripting to your application

00:00:43,200 --> 00:00:48,399
so before we discuss how to add

00:00:46,800 --> 00:00:50,399
scripting we should at least briefly

00:00:48,399 --> 00:00:52,320
discuss what i mean by scripting and why

00:00:50,399 --> 00:00:54,640
you might want to do it

00:00:52,320 --> 00:00:57,280
for the purposes of today's talk i'll

00:00:54,640 --> 00:00:58,640
define scripting as the ability to add

00:00:57,280 --> 00:01:00,480
logic to an existing

00:00:58,640 --> 00:01:03,520
released application without needing

00:01:00,480 --> 00:01:05,439
access to the program's source code

00:01:03,520 --> 00:01:07,360
the ability to script an application is

00:01:05,439 --> 00:01:10,560
often but not always provided for

00:01:07,360 --> 00:01:13,200
end users who may have limited fluency

00:01:10,560 --> 00:01:14,799
with software development

00:01:13,200 --> 00:01:16,400
now originally i was going to say

00:01:14,799 --> 00:01:17,439
without needing to recompile the

00:01:16,400 --> 00:01:20,400
application

00:01:17,439 --> 00:01:22,320
but i think that just shows i don't know

00:01:20,400 --> 00:01:24,320
my biases or my age

00:01:22,320 --> 00:01:26,320
that's not actually correct since it's

00:01:24,320 --> 00:01:28,720
possible to script an application

00:01:26,320 --> 00:01:30,400
written in an interpreted language in

00:01:28,720 --> 00:01:32,079
fact a few years ago i worked on a

00:01:30,400 --> 00:01:33,200
rather large project that's a different

00:01:32,079 --> 00:01:35,840
company

00:01:33,200 --> 00:01:37,840
that allowed end users scripting and the

00:01:35,840 --> 00:01:39,280
application itself was written in lua so

00:01:37,840 --> 00:01:40,640
it doesn't have to be a compiled

00:01:39,280 --> 00:01:43,040
language you can

00:01:40,640 --> 00:01:44,560
add scripting to any any computer

00:01:43,040 --> 00:01:46,560
language

00:01:44,560 --> 00:01:48,479
and while we're on the subject also let

00:01:46,560 --> 00:01:49,520
me briefly address the term scripting

00:01:48,479 --> 00:01:51,200
language

00:01:49,520 --> 00:01:52,799
i want to define the term scripting

00:01:51,200 --> 00:01:54,799
language using i know

00:01:52,799 --> 00:01:56,880
when i see it approach so scripting

00:01:54,799 --> 00:01:59,280
language is a language like javascript

00:01:56,880 --> 00:02:01,040
or python or tickle

00:01:59,280 --> 00:02:02,399
it pretty much overlaps with what we

00:02:01,040 --> 00:02:05,119
once referred to

00:02:02,399 --> 00:02:07,280
as a dynamic language and essentially

00:02:05,119 --> 00:02:09,520
means an interpreted language

00:02:07,280 --> 00:02:12,160
uh one without requiring variables to be

00:02:09,520 --> 00:02:14,080
assigned a data type

00:02:12,160 --> 00:02:16,000
now the definitions i've given gloss

00:02:14,080 --> 00:02:17,840
over a few things um

00:02:16,000 --> 00:02:18,959
maybe honestly they gloss over a lot of

00:02:17,840 --> 00:02:20,319
things but i think they're good enough

00:02:18,959 --> 00:02:22,800
for us to be getting on with

00:02:20,319 --> 00:02:24,959
so that's what we're going to stick with

00:02:22,800 --> 00:02:28,080
for today

00:02:24,959 --> 00:02:31,120
so why script why give

00:02:28,080 --> 00:02:33,760
users the ability to add logic to your

00:02:31,120 --> 00:02:33,760
application

00:02:34,800 --> 00:02:38,959
some of the main advantages of allowing

00:02:36,480 --> 00:02:40,560
scripting include the following

00:02:38,959 --> 00:02:42,640
the scripting language may be more

00:02:40,560 --> 00:02:43,760
expressive or maybe a better fit for the

00:02:42,640 --> 00:02:45,040
problem domain

00:02:43,760 --> 00:02:47,120
so for example you might have an

00:02:45,040 --> 00:02:48,319
application for graphing mathematical

00:02:47,120 --> 00:02:50,319
expressions

00:02:48,319 --> 00:02:53,120
and you might give the users the ability

00:02:50,319 --> 00:02:55,840
to write those mathematical expressions

00:02:53,120 --> 00:02:57,760
in a language more suitable than say c

00:02:55,840 --> 00:03:01,760
or tickle or python or

00:02:57,760 --> 00:03:03,280
more traditional computer languages on a

00:03:01,760 --> 00:03:05,519
sort of different text a scripting

00:03:03,280 --> 00:03:06,720
language may provide a simpler mode of

00:03:05,519 --> 00:03:11,040
expression

00:03:06,720 --> 00:03:13,200
or maybe provide an environment which

00:03:11,040 --> 00:03:14,319
makes it easy to sandbox and thus makes

00:03:13,200 --> 00:03:16,720
it safer

00:03:14,319 --> 00:03:18,159
or simpler to provide for your end users

00:03:16,720 --> 00:03:19,760
and there are a number of programs that

00:03:18,159 --> 00:03:24,480
have taken this approach

00:03:19,760 --> 00:03:27,840
adobe lightroom which is a program for

00:03:24,480 --> 00:03:28,959
curating and editing photos allows the

00:03:27,840 --> 00:03:30,799
users to

00:03:28,959 --> 00:03:32,480
extend the application writing small

00:03:30,799 --> 00:03:34,560
scripts using the programming language

00:03:32,480 --> 00:03:37,440
lua

00:03:34,560 --> 00:03:39,599
a long long time ago one of my favorite

00:03:37,440 --> 00:03:40,720
mail handling tools was a program called

00:03:39,599 --> 00:03:43,760
mh

00:03:40,720 --> 00:03:46,000
which essentially

00:03:43,760 --> 00:03:47,760
provided a bunch of simple applications

00:03:46,000 --> 00:03:50,480
which you could glue together writing

00:03:47,760 --> 00:03:50,480
bash scripts

00:03:51,840 --> 00:03:55,599
it's useful to consider five scenarios

00:03:53,920 --> 00:03:57,760
when making use of scripting

00:03:55,599 --> 00:04:00,000
and probably one of the most obvious

00:03:57,760 --> 00:04:02,239
ones is configuration

00:04:00,000 --> 00:04:04,080
so if we use a scripting language to

00:04:02,239 --> 00:04:06,799
implement configuration

00:04:04,080 --> 00:04:08,560
files that can be quite flexible and

00:04:06,799 --> 00:04:10,080
there's systems that do this at a whole

00:04:08,560 --> 00:04:12,560
range of levels

00:04:10,080 --> 00:04:14,000
from simple key value pairs to

00:04:12,560 --> 00:04:17,199
full-blown configuration

00:04:14,000 --> 00:04:20,079
files using lots of complicated logic

00:04:17,199 --> 00:04:21,280
in the configuration itself and one of

00:04:20,079 --> 00:04:24,400
the big advantages

00:04:21,280 --> 00:04:26,400
of using a scripting language for

00:04:24,400 --> 00:04:28,960
implementing configuration files is the

00:04:26,400 --> 00:04:30,800
ability to parse the contents

00:04:28,960 --> 00:04:34,800
of the file without having to write your

00:04:30,800 --> 00:04:34,800
own uh language processing code

00:04:35,040 --> 00:04:39,840
uh i'm going to mention as a throwaway

00:04:37,040 --> 00:04:43,040
line here that some people that you

00:04:39,840 --> 00:04:44,800
if if you read some people some people's

00:04:43,040 --> 00:04:46,639
blogs or talk to some people about

00:04:44,800 --> 00:04:48,960
system design

00:04:46,639 --> 00:04:50,160
they may mention scriptable

00:04:48,960 --> 00:04:53,199
configuration as an

00:04:50,160 --> 00:04:55,919
anti-pattern i'm not sure that i uh

00:04:53,199 --> 00:04:57,280
well i know i don't believe a hundred

00:04:55,919 --> 00:04:58,960
percent in that

00:04:57,280 --> 00:05:01,680
as i think you're going to hear me say

00:04:58,960 --> 00:05:03,680
several times throughout this talk

00:05:01,680 --> 00:05:05,600
the correct answer i think depends it

00:05:03,680 --> 00:05:07,600
depends on the circumstances it depends

00:05:05,600 --> 00:05:09,520
on the trade-offs you're willing to make

00:05:07,600 --> 00:05:11,280
and so i think there are certain

00:05:09,520 --> 00:05:13,919
circumstances where

00:05:11,280 --> 00:05:16,960
scriptable configuration is is a

00:05:13,919 --> 00:05:18,720
powerful and useful tool

00:05:16,960 --> 00:05:22,560
another scenario in which adding

00:05:18,720 --> 00:05:22,560
scripting to an application is useful is

00:05:22,840 --> 00:05:26,560
prototyping

00:05:24,000 --> 00:05:28,320
uh in particular uh scripting gives you

00:05:26,560 --> 00:05:31,919
a good way of being able to

00:05:28,320 --> 00:05:34,479
easily prototype ui and ux user

00:05:31,919 --> 00:05:35,680
interfaces and user experiences either

00:05:34,479 --> 00:05:38,240
during development

00:05:35,680 --> 00:05:39,360
or even afterwards you can use it to

00:05:38,240 --> 00:05:42,720
facilitate

00:05:39,360 --> 00:05:44,560
a b testing uh is is this

00:05:42,720 --> 00:05:46,160
application is this interface with a

00:05:44,560 --> 00:05:48,080
blue button better than this interface

00:05:46,160 --> 00:05:50,639
with a red button

00:05:48,080 --> 00:05:52,240
and i'm i think dramatically over

00:05:50,639 --> 00:05:54,880
simplifying a b a b

00:05:52,240 --> 00:05:57,360
testing but i'm not really a designer so

00:05:54,880 --> 00:05:58,720
uh so indulge me

00:05:57,360 --> 00:06:00,240
there are a number of libraries for

00:05:58,720 --> 00:06:01,520
implementing so-called tweaks

00:06:00,240 --> 00:06:03,759
functionality

00:06:01,520 --> 00:06:05,680
uh so the ability to somehow pull up

00:06:03,759 --> 00:06:09,039
some sort of control panel and adjust

00:06:05,680 --> 00:06:11,840
the parameters of a running application

00:06:09,039 --> 00:06:13,600
and typically this is used during

00:06:11,840 --> 00:06:16,560
development or during testing

00:06:13,600 --> 00:06:21,840
although it can be used during a product

00:06:16,560 --> 00:06:21,840
in a production application as well

00:06:22,960 --> 00:06:27,520
a third scenario in which scripting is

00:06:25,360 --> 00:06:29,440
useful is tuning

00:06:27,520 --> 00:06:31,440
the idea of tuning is used quite

00:06:29,440 --> 00:06:33,280
extensively in developing games but it's

00:06:31,440 --> 00:06:36,000
also used in all sorts of programming

00:06:33,280 --> 00:06:38,160
and is very similar to prototyping

00:06:36,000 --> 00:06:39,039
but the essence is that as you're

00:06:38,160 --> 00:06:41,600
developing

00:06:39,039 --> 00:06:43,360
a program there are a lot of parameters

00:06:41,600 --> 00:06:45,199
for which it's not really clear in

00:06:43,360 --> 00:06:45,919
advance what the value of the parameter

00:06:45,199 --> 00:06:47,360
should be

00:06:45,919 --> 00:06:50,160
and again i think some of the most

00:06:47,360 --> 00:06:52,479
obvious uh examples to think of are

00:06:50,160 --> 00:06:54,880
things like timing of animations and

00:06:52,479 --> 00:06:57,280
similar sorts of values and you don't

00:06:54,880 --> 00:07:01,440
want to have to be

00:06:57,280 --> 00:07:04,080
going through a whole uh code compile

00:07:01,440 --> 00:07:04,800
deploy cycle every time you want to try

00:07:04,080 --> 00:07:07,199
tweaking

00:07:04,800 --> 00:07:08,080
the value of the duration of an

00:07:07,199 --> 00:07:11,199
animation

00:07:08,080 --> 00:07:13,360
and so scripting allows you to very

00:07:11,199 --> 00:07:14,960
easily and very rapidly go through this

00:07:13,360 --> 00:07:17,680
cycle

00:07:14,960 --> 00:07:18,479
one particular example uh i'm working on

00:07:17,680 --> 00:07:22,639
a mobile app

00:07:18,479 --> 00:07:23,759
for uh conjugation drills for japanese

00:07:22,639 --> 00:07:25,520
verbs

00:07:23,759 --> 00:07:26,800
and there are different animations that

00:07:25,520 --> 00:07:28,319
play depending on whether you get the

00:07:26,800 --> 00:07:31,840
answer right

00:07:28,319 --> 00:07:33,680
uh or wrong to the current question

00:07:31,840 --> 00:07:34,960
and questions such as how long the

00:07:33,680 --> 00:07:36,560
animation should play

00:07:34,960 --> 00:07:39,440
how vibrant should the colors in the

00:07:36,560 --> 00:07:40,560
animation be what's a good font size to

00:07:39,440 --> 00:07:42,800
use for

00:07:40,560 --> 00:07:44,720
different aspects of the user interface

00:07:42,800 --> 00:07:46,479
these all require extensive trial and

00:07:44,720 --> 00:07:48,479
error to find good values

00:07:46,479 --> 00:07:51,280
or maybe i should just find a developer

00:07:48,479 --> 00:07:54,400
to i'm sorry a designer to work with but

00:07:51,280 --> 00:07:58,240
but either way it's

00:07:54,400 --> 00:08:00,000
gives me a lot more flexible and rapid

00:07:58,240 --> 00:08:02,479
turnaround time on trying to

00:08:00,000 --> 00:08:05,039
identify and nail down these parameters

00:08:02,479 --> 00:08:07,199
if i don't need to go back into xcode

00:08:05,039 --> 00:08:09,360
recompile my application redeploy it to

00:08:07,199 --> 00:08:11,199
a phone or to the simulator

00:08:09,360 --> 00:08:12,560
every time i want to adjust the value

00:08:11,199 --> 00:08:15,759
and so in particular

00:08:12,560 --> 00:08:17,840
i have a system in place where i can tap

00:08:15,759 --> 00:08:20,400
on the screen and pull up a

00:08:17,840 --> 00:08:21,039
dialog that's got a rebel a read about

00:08:20,400 --> 00:08:23,520
print loop

00:08:21,039 --> 00:08:24,639
so essentially an interface an

00:08:23,520 --> 00:08:27,599
interpreter

00:08:24,639 --> 00:08:28,800
that exposes all of these parameters

00:08:27,599 --> 00:08:31,360
that i want to adjust

00:08:28,800 --> 00:08:33,120
in my application and i can tweak i can

00:08:31,360 --> 00:08:35,919
change the values of these

00:08:33,120 --> 00:08:37,039
and carry on and see whether i like the

00:08:35,919 --> 00:08:39,680
new values or not

00:08:37,039 --> 00:08:43,440
again rapidly without having to get out

00:08:39,680 --> 00:08:43,440
of the flow of what it is that i'm doing

00:08:45,040 --> 00:08:49,680
debugging is a the fourth scenario i

00:08:47,839 --> 00:08:53,600
want to briefly talk about

00:08:49,680 --> 00:08:55,440
um and in debugging we want to expose

00:08:53,600 --> 00:08:56,959
the internal state of an application

00:08:55,440 --> 00:08:59,279
while it's running

00:08:56,959 --> 00:09:00,320
and every ide i can think of provides a

00:08:59,279 --> 00:09:03,040
debugger and

00:09:00,320 --> 00:09:05,200
they all or at least almost all give you

00:09:03,040 --> 00:09:06,399
the ability to write scripts in some

00:09:05,200 --> 00:09:08,320
language that can

00:09:06,399 --> 00:09:12,000
run at different trigger points usually

00:09:08,320 --> 00:09:12,000
a break point or similar

00:09:14,720 --> 00:09:18,480
and the final scenario i want to mention

00:09:16,320 --> 00:09:20,560
is extensibility

00:09:18,480 --> 00:09:22,959
so here we're providing the end user the

00:09:20,560 --> 00:09:24,959
ability to add logic to the application

00:09:22,959 --> 00:09:26,640
i already mentioned the example of the

00:09:24,959 --> 00:09:27,279
application the graph mathematical

00:09:26,640 --> 00:09:30,160
functions

00:09:27,279 --> 00:09:31,040
that were supplied by the user another

00:09:30,160 --> 00:09:33,040
example

00:09:31,040 --> 00:09:34,399
a few years back i wrote an application

00:09:33,040 --> 00:09:37,680
that allowed you to

00:09:34,399 --> 00:09:41,120
rearrange the icons on a plugged in

00:09:37,680 --> 00:09:42,880
iphone um i'll mention

00:09:41,120 --> 00:09:44,560
before i forget that the app is

00:09:42,880 --> 00:09:46,640
currently way out of date

00:09:44,560 --> 00:09:48,160
and i'm slowly working on trying to get

00:09:46,640 --> 00:09:51,040
it back into our running state

00:09:48,160 --> 00:09:51,920
but when it worked it was it was a lot

00:09:51,040 --> 00:09:54,080
of fun

00:09:51,920 --> 00:09:55,040
what it did is is you uh hooked up your

00:09:54,080 --> 00:09:57,600
iphone

00:09:55,040 --> 00:09:59,040
using you you using uh you know plugged

00:09:57,600 --> 00:10:00,880
into usb

00:09:59,040 --> 00:10:02,320
it sucked down information about all the

00:10:00,880 --> 00:10:04,160
applications that you had

00:10:02,320 --> 00:10:05,360
on your iphone and how they're arranged

00:10:04,160 --> 00:10:07,680
across the various

00:10:05,360 --> 00:10:09,600
screens on springboard and then it would

00:10:07,680 --> 00:10:12,640
let you rearrange them and then save

00:10:09,600 --> 00:10:15,200
that new configuration back to the phone

00:10:12,640 --> 00:10:17,519
and the way it did it is it allowed the

00:10:15,200 --> 00:10:19,760
user to supply a sorting function

00:10:17,519 --> 00:10:21,040
so the application had an embedded lua

00:10:19,760 --> 00:10:22,959
interpreter

00:10:21,040 --> 00:10:24,720
and the main application which was

00:10:22,959 --> 00:10:25,519
written in c would expose all the

00:10:24,720 --> 00:10:28,560
information

00:10:25,519 --> 00:10:29,360
about the icons and the applications on

00:10:28,560 --> 00:10:32,720
the iphone

00:10:29,360 --> 00:10:35,120
to the lua environment as a collection

00:10:32,720 --> 00:10:37,200
and then the user would supply a

00:10:35,120 --> 00:10:39,040
function a sorting function

00:10:37,200 --> 00:10:41,200
that could make use of any or all of

00:10:39,040 --> 00:10:44,560
this information to decide

00:10:41,200 --> 00:10:46,000
which which application should sort

00:10:44,560 --> 00:10:48,160
before the other application

00:10:46,000 --> 00:10:50,399
and these range from you could very

00:10:48,160 --> 00:10:50,959
easily do a sort of mundane sort sort

00:10:50,399 --> 00:10:53,120
all my app

00:10:50,959 --> 00:10:54,480
uh sort all the apps on my phone by

00:10:53,120 --> 00:10:55,519
alphabetically by the name of the

00:10:54,480 --> 00:10:57,920
application

00:10:55,519 --> 00:11:00,079
to more exotics and forms of sort so for

00:10:57,920 --> 00:11:03,279
example sort them all by the predominant

00:11:00,079 --> 00:11:04,160
color in the apps icon i'm not sure that

00:11:03,279 --> 00:11:05,839
that's

00:11:04,160 --> 00:11:07,279
particularly useful but that's certainly

00:11:05,839 --> 00:11:08,880
something that you could do and that's a

00:11:07,279 --> 00:11:11,360
great example of

00:11:08,880 --> 00:11:12,839
scripting an application giving the user

00:11:11,360 --> 00:11:15,680
the ability

00:11:12,839 --> 00:11:17,360
to take the information

00:11:15,680 --> 00:11:19,600
and use it in unforeseen and

00:11:17,360 --> 00:11:22,000
unpre-planned

00:11:19,600 --> 00:11:22,000
fashion

00:11:24,560 --> 00:11:28,320
now there's a lot of overlap between

00:11:26,480 --> 00:11:30,399
these scenarios and rather than trying

00:11:28,320 --> 00:11:31,040
to focus on clearly delineating between

00:11:30,399 --> 00:11:32,640
them

00:11:31,040 --> 00:11:35,120
let's instead concentrate on what they

00:11:32,640 --> 00:11:36,800
have in common in all these scenarios we

00:11:35,120 --> 00:11:38,560
can refer to the host language so the

00:11:36,800 --> 00:11:39,600
language in which the core application

00:11:38,560 --> 00:11:41,040
is written

00:11:39,600 --> 00:11:42,399
and then we can talk about the hosted

00:11:41,040 --> 00:11:43,440
language the language in which the

00:11:42,399 --> 00:11:45,120
scripts are written

00:11:43,440 --> 00:11:47,279
and both of these languages have an

00:11:45,120 --> 00:11:48,320
environment or context by which i mean

00:11:47,279 --> 00:11:50,639
the data

00:11:48,320 --> 00:11:52,560
that's manipulable by code in that

00:11:50,639 --> 00:11:55,920
language

00:11:52,560 --> 00:11:56,959
and so the regardless of the scenario

00:11:55,920 --> 00:11:59,360
the key point

00:11:56,959 --> 00:12:00,399
we need to the the key feature we need

00:11:59,360 --> 00:12:02,320
to be able to

00:12:00,399 --> 00:12:03,760
implement using a scripting language is

00:12:02,320 --> 00:12:05,600
we need to be able to exchange

00:12:03,760 --> 00:12:08,240
information between the host environment

00:12:05,600 --> 00:12:08,240
and the hosted

00:12:08,839 --> 00:12:12,480
environment

00:12:11,040 --> 00:12:14,240
now at this point i want to take a brief

00:12:12,480 --> 00:12:17,360
digression to talk about an

00:12:14,240 --> 00:12:18,959
architectural concern particularly if we

00:12:17,360 --> 00:12:19,760
have the freedom to architect our system

00:12:18,959 --> 00:12:22,160
from scratch

00:12:19,760 --> 00:12:22,959
there's an interesting question of which

00:12:22,160 --> 00:12:26,160
language

00:12:22,959 --> 00:12:28,160
is in the driver's seat if you talk to a

00:12:26,160 --> 00:12:30,959
number of developers

00:12:28,160 --> 00:12:32,639
who develop scripting applications many

00:12:30,959 --> 00:12:35,200
of them are going to advocate

00:12:32,639 --> 00:12:36,720
that rather than writing the program in

00:12:35,200 --> 00:12:39,040
say a language like c

00:12:36,720 --> 00:12:41,200
and then adding a scripting engine to

00:12:39,040 --> 00:12:42,480
that you want to flip it around and

00:12:41,200 --> 00:12:43,360
instead write the bulk of the

00:12:42,480 --> 00:12:45,440
application

00:12:43,360 --> 00:12:47,839
in the scripting language python or lua

00:12:45,440 --> 00:12:51,200
or a tickle or guile or whatever

00:12:47,839 --> 00:12:53,040
and then provide little bits of

00:12:51,200 --> 00:12:53,600
low-level functionality in a language

00:12:53,040 --> 00:12:56,959
like c

00:12:53,600 --> 00:13:00,240
or rust and use the highlight use the

00:12:56,959 --> 00:13:02,959
scripting language to glue them together

00:13:00,240 --> 00:13:04,399
okay so an example of this is

00:13:02,959 --> 00:13:06,320
illustrated here by this

00:13:04,399 --> 00:13:08,720
this diagram several years ago i bought

00:13:06,320 --> 00:13:10,079
a couple of blink ones from a company

00:13:08,720 --> 00:13:12,560
called thingam

00:13:10,079 --> 00:13:13,680
so they plug into the usb slot on a

00:13:12,560 --> 00:13:16,000
computer

00:13:13,680 --> 00:13:17,760
and uh they're just led lights

00:13:16,000 --> 00:13:18,880
multi-colored led lights that you can

00:13:17,760 --> 00:13:20,800
control

00:13:18,880 --> 00:13:22,639
and you can control them either with the

00:13:20,800 --> 00:13:23,680
control panel application that came with

00:13:22,639 --> 00:13:25,839
the blanks

00:13:23,680 --> 00:13:26,800
or they also provide an api and you

00:13:25,839 --> 00:13:28,800
could write your own

00:13:26,800 --> 00:13:29,839
programs to manipulate them however you

00:13:28,800 --> 00:13:32,880
such as

00:13:29,839 --> 00:13:34,320
and there are uh their apis uh bindings

00:13:32,880 --> 00:13:35,519
to a number of different languages i

00:13:34,320 --> 00:13:38,880
wrote a binding

00:13:35,519 --> 00:13:39,839
to lua and if we have time at the end of

00:13:38,880 --> 00:13:42,880
the talk we'll look

00:13:39,839 --> 00:13:43,600
at the code a little bit and basically

00:13:42,880 --> 00:13:46,480
what it does

00:13:43,600 --> 00:13:47,440
is there's some small amount of c code

00:13:46,480 --> 00:13:49,600
which

00:13:47,440 --> 00:13:51,680
makes use of this api to manipulate the

00:13:49,600 --> 00:13:54,160
blanks and then i can write

00:13:51,680 --> 00:13:55,279
whatever functionality i want in lua

00:13:54,160 --> 00:13:57,279
making use of the

00:13:55,279 --> 00:13:58,320
using the of that of that binding

00:13:57,279 --> 00:14:00,959
library

00:13:58,320 --> 00:14:02,000
okay and i've written several different

00:14:00,959 --> 00:14:03,519
new applications

00:14:02,000 --> 00:14:05,199
that let you do various things with

00:14:03,519 --> 00:14:08,320
these blanks such as the

00:14:05,199 --> 00:14:11,839
not very original flash out morris code

00:14:08,320 --> 00:14:13,680
to to more interesting applications

00:14:11,839 --> 00:14:16,160
so what's the better approach which

00:14:13,680 --> 00:14:19,199
language do you let drive the

00:14:16,160 --> 00:14:21,680
the system and and it depends

00:14:19,199 --> 00:14:23,519
uh i mentioned that if you're writing

00:14:21,680 --> 00:14:25,279
the system from scratch

00:14:23,519 --> 00:14:27,120
then a number of people would argue that

00:14:25,279 --> 00:14:29,360
you want to write the bulk of the

00:14:27,120 --> 00:14:31,279
application in the scripting language

00:14:29,360 --> 00:14:32,639
or you know what we often call the

00:14:31,279 --> 00:14:34,959
scripting language

00:14:32,639 --> 00:14:36,079
but very often we don't have the freedom

00:14:34,959 --> 00:14:37,920
or the luxury

00:14:36,079 --> 00:14:39,519
of writing the application from scratch

00:14:37,920 --> 00:14:41,040
very often we're in the case of taking

00:14:39,519 --> 00:14:43,600
an existing application

00:14:41,040 --> 00:14:44,959
and needing to implement functionality

00:14:43,600 --> 00:14:46,160
so there are a lot of trade-offs

00:14:44,959 --> 00:14:48,560
involved

00:14:46,160 --> 00:14:50,320
but the interesting thing is that i

00:14:48,560 --> 00:14:51,920
would argue that regardless as to which

00:14:50,320 --> 00:14:52,639
direction you're going which language

00:14:51,920 --> 00:14:55,680
you're letting

00:14:52,639 --> 00:14:58,079
drive the this drive the

00:14:55,680 --> 00:14:59,279
system as a whole you still have that

00:14:58,079 --> 00:15:02,639
same core problem

00:14:59,279 --> 00:15:04,320
of how do you get information from one

00:15:02,639 --> 00:15:06,560
environment from one context to the

00:15:04,320 --> 00:15:08,399
other how do you manipulate

00:15:06,560 --> 00:15:10,880
data in one context from the other

00:15:08,399 --> 00:15:10,880
context

00:15:11,279 --> 00:15:14,320
okay one other thing that i want to

00:15:12,800 --> 00:15:18,160
mention real quickly

00:15:14,320 --> 00:15:19,440
um is uh we really ought to talk about

00:15:18,160 --> 00:15:20,800
error handling and we really ought to

00:15:19,440 --> 00:15:23,199
talk about security

00:15:20,800 --> 00:15:24,880
uh and both of these things as many

00:15:23,199 --> 00:15:26,800
other people have said are things that

00:15:24,880 --> 00:15:29,920
that you really need to consider from

00:15:26,800 --> 00:15:31,279
the beginning not bolted on at the end

00:15:29,920 --> 00:15:33,199
and with that in mind we're going to do

00:15:31,279 --> 00:15:36,160
what almost everybody does and

00:15:33,199 --> 00:15:37,759
i'm going to now ignore them because we

00:15:36,160 --> 00:15:39,600
have limited time

00:15:37,759 --> 00:15:40,959
and i'd like to get to some interesting

00:15:39,600 --> 00:15:43,600
code and

00:15:40,959 --> 00:15:45,680
i'd like the code to be understandable

00:15:43,600 --> 00:15:47,759
without a lot of background and without

00:15:45,680 --> 00:15:49,360
a lot of in-depth knowledge and so i'm

00:15:47,759 --> 00:15:50,639
going to leave most of the security and

00:15:49,360 --> 00:15:53,040
most of the

00:15:50,639 --> 00:15:54,480
error handling out but keep in mind that

00:15:53,040 --> 00:15:56,240
it is important

00:15:54,480 --> 00:15:58,880
consideration and whenever you're

00:15:56,240 --> 00:16:00,320
evaluating what language

00:15:58,880 --> 00:16:02,560
you should use for your scripting

00:16:00,320 --> 00:16:05,600
application you should certainly

00:16:02,560 --> 00:16:08,240
up front give some thought as to how

00:16:05,600 --> 00:16:12,560
easy or complicated the language makes

00:16:08,240 --> 00:16:12,560
adding security features handling errors

00:16:14,480 --> 00:16:20,639
all right so with uh preliminaries of

00:16:18,320 --> 00:16:22,240
what what scripting is and why we should

00:16:20,639 --> 00:16:22,959
script the next question that we really

00:16:22,240 --> 00:16:24,079
need to address

00:16:22,959 --> 00:16:27,839
i'm going to blow through this real

00:16:24,079 --> 00:16:27,839
quickly is what language should we use

00:16:29,360 --> 00:16:32,800
well you can guess from my previous

00:16:31,040 --> 00:16:34,320
remarks that i don't think there is one

00:16:32,800 --> 00:16:35,279
right answer it's not what language

00:16:34,320 --> 00:16:36,720
should we use

00:16:35,279 --> 00:16:38,720
we could talk a little bit about what

00:16:36,720 --> 00:16:40,480
language can i use

00:16:38,720 --> 00:16:42,480
what are the characteristics we need in

00:16:40,480 --> 00:16:44,880
a scripting language

00:16:42,480 --> 00:16:46,800
well it should be dead simple to get the

00:16:44,880 --> 00:16:48,800
information from the host context to the

00:16:46,800 --> 00:16:50,800
hosted contacts

00:16:48,800 --> 00:16:52,079
it should cleanly express the essence of

00:16:50,800 --> 00:16:53,759
the problem domain

00:16:52,079 --> 00:16:56,240
if we think back to the function plotter

00:16:53,759 --> 00:16:58,320
example i mentioned earlier

00:16:56,240 --> 00:16:59,920
ideally what we want is a language that

00:16:58,320 --> 00:17:01,920
allows you to easily express

00:16:59,920 --> 00:17:03,680
complicated mathematical expressions

00:17:01,920 --> 00:17:06,559
that you can then graph

00:17:03,680 --> 00:17:06,880
if writing the mathematical formula to

00:17:06,559 --> 00:17:09,760
be

00:17:06,880 --> 00:17:11,679
craft requires a lot of effort requires

00:17:09,760 --> 00:17:13,839
convoluted syntax then your system is

00:17:11,679 --> 00:17:15,679
not going to be successful

00:17:13,839 --> 00:17:19,280
and as i mentioned just a minute ago we

00:17:15,679 --> 00:17:22,640
want a language that allows for security

00:17:19,280 --> 00:17:25,679
ideally we'd like a language that allows

00:17:22,640 --> 00:17:27,839
some amount of easily implemented

00:17:25,679 --> 00:17:30,000
sandboxing although you should keep in

00:17:27,839 --> 00:17:32,080
mind that sandboxing is never going to

00:17:30,000 --> 00:17:33,039
be ideal and so again you've got a risk

00:17:32,080 --> 00:17:35,360
tradeoff

00:17:33,039 --> 00:17:37,039
who are the users how likely is it that

00:17:35,360 --> 00:17:38,960
they are going to be malicious that

00:17:37,039 --> 00:17:41,360
they're going to be error-prone

00:17:38,960 --> 00:17:43,280
what's your risk tolerance there are

00:17:41,360 --> 00:17:45,440
lots of important questions there

00:17:43,280 --> 00:17:47,360
and again i'm going to fluff over them

00:17:45,440 --> 00:17:49,840
and not go into them in any

00:17:47,360 --> 00:17:49,840
detail

00:17:50,400 --> 00:17:54,080
real quickly here are some languages

00:17:51,919 --> 00:17:56,880
that we could use

00:17:54,080 --> 00:17:58,000
for doing scripting tickle um i'm not

00:17:56,880 --> 00:18:00,240
sure

00:17:58,000 --> 00:18:01,440
uh how many of you out there are

00:18:00,240 --> 00:18:04,080
familiar with tickle

00:18:01,440 --> 00:18:06,559
tickle is a language that i like a lot

00:18:04,080 --> 00:18:09,280
roughly 20 years ago i used it

00:18:06,559 --> 00:18:13,280
uh quite a bit developing interactive

00:18:09,280 --> 00:18:13,280
websites using aol server

00:18:13,520 --> 00:18:19,200
um i've got a question just popped up

00:18:15,840 --> 00:18:19,200
i'll get to in just one second

00:18:20,080 --> 00:18:24,000
python is an obvious choice it's an

00:18:21,919 --> 00:18:25,919
immensely powerful language

00:18:24,000 --> 00:18:27,039
in its own right it's also used as a

00:18:25,919 --> 00:18:29,840
scripting language

00:18:27,039 --> 00:18:31,679
in various applications the code here is

00:18:29,840 --> 00:18:36,000
an example from blender

00:18:31,679 --> 00:18:36,000
a popular open source 3d tool

00:18:39,360 --> 00:18:44,320
guile guile is news ubiquitous

00:18:42,240 --> 00:18:47,360
intelligent language for extensions

00:18:44,320 --> 00:18:50,720
and basically it's a dialectic scheme

00:18:47,360 --> 00:18:52,160
so dialect of lisp if you will and

00:18:50,720 --> 00:18:54,240
yes i know there's a big difference

00:18:52,160 --> 00:18:56,080
between list spin scheme but i told you

00:18:54,240 --> 00:18:58,640
i'm glossing over and hand waving a lot

00:18:56,080 --> 00:18:58,640
of details

00:18:58,960 --> 00:19:04,480
the example here is a his code is user

00:19:02,320 --> 00:19:05,840
supplied code for creating a report in a

00:19:04,480 --> 00:19:08,480
program called

00:19:05,840 --> 00:19:08,480
new cache

00:19:09,679 --> 00:19:12,799
and then finally we're going to talk

00:19:11,440 --> 00:19:16,160
about lua

00:19:12,799 --> 00:19:20,000
in detail for the rest of this talk um

00:19:16,160 --> 00:19:22,160
and um the question that popped up in qa

00:19:20,000 --> 00:19:23,919
is q a is i've heard you mention the

00:19:22,160 --> 00:19:25,679
lewis language a lot in your talk and

00:19:23,919 --> 00:19:27,760
from my understanding lua is usually

00:19:25,679 --> 00:19:29,440
associated with the bsds

00:19:27,760 --> 00:19:31,440
what do you like about lua compared to

00:19:29,440 --> 00:19:34,000
other scripting languages like perl and

00:19:31,440 --> 00:19:34,000
python

00:19:34,320 --> 00:19:39,760
so a couple things i suppose uh

00:19:37,919 --> 00:19:42,320
i suppose that's true that lou is often

00:19:39,760 --> 00:19:43,520
uh associated with bsds with various

00:19:42,320 --> 00:19:45,440
flavors of

00:19:43,520 --> 00:19:46,880
unix linux those sorts of operating

00:19:45,440 --> 00:19:49,520
systems however

00:19:46,880 --> 00:19:51,200
uh lua is actually available on on

00:19:49,520 --> 00:19:53,919
almost every system that you can think

00:19:51,200 --> 00:19:57,520
of i know a number of people who use lua

00:19:53,919 --> 00:19:59,760
in windows environments um i've used lua

00:19:57,520 --> 00:20:00,559
myself uh in a number of embedded

00:19:59,760 --> 00:20:06,320
environments

00:20:00,559 --> 00:20:08,720
uh like with the uh esp82 that's the

00:20:06,320 --> 00:20:08,720
problem

00:20:08,799 --> 00:20:14,080
uh i'm blanking on the number but uh the

00:20:11,200 --> 00:20:15,440
the esp mic not the esp32s which are the

00:20:14,080 --> 00:20:18,080
newer ones but the older

00:20:15,440 --> 00:20:20,640
uh system on a chips they have a lua

00:20:18,080 --> 00:20:24,400
system that you can use for coding them

00:20:20,640 --> 00:20:25,840
there are a number of other uh embedded

00:20:24,400 --> 00:20:29,919
systems that have really nice

00:20:25,840 --> 00:20:30,799
lua systems embedded in them there was

00:20:29,919 --> 00:20:34,400
for example

00:20:30,799 --> 00:20:36,480
uh for a while there was a series of

00:20:34,400 --> 00:20:37,600
led screens that had a built-in lua

00:20:36,480 --> 00:20:40,159
interpreter

00:20:37,600 --> 00:20:42,320
that you could use for doing interesting

00:20:40,159 --> 00:20:43,840
display

00:20:42,320 --> 00:20:46,159
what do i like about them compared to

00:20:43,840 --> 00:20:49,840
languages like perl and python

00:20:46,159 --> 00:20:51,760
one is is the small size um

00:20:49,840 --> 00:20:53,039
i think even though we're now at the

00:20:51,760 --> 00:20:56,240
point where for example

00:20:53,039 --> 00:20:57,520
iot devices have memory measured in in

00:20:56,240 --> 00:21:00,559
megabytes

00:20:57,520 --> 00:21:02,000
i think still having small size often of

00:21:00,559 --> 00:21:05,760
the interpreter often can be very

00:21:02,000 --> 00:21:08,880
useful um probably

00:21:05,760 --> 00:21:10,799
the main thing i like about lua and

00:21:08,880 --> 00:21:12,320
as we'll see in just a few minutes i

00:21:10,799 --> 00:21:13,440
mentioned that one of the things you

00:21:12,320 --> 00:21:16,000
want is is

00:21:13,440 --> 00:21:17,919
a very simple way a very powerful but

00:21:16,000 --> 00:21:19,840
simple way of getting information

00:21:17,919 --> 00:21:22,320
back and forth between the host language

00:21:19,840 --> 00:21:24,080
and the hosted language and i think lua

00:21:22,320 --> 00:21:28,000
nails that down

00:21:24,080 --> 00:21:30,960
to t um in fact one of the first

00:21:28,000 --> 00:21:31,360
things that that drew me to lua was uh

00:21:30,960 --> 00:21:33,360
back

00:21:31,360 --> 00:21:35,840
uh before the turn of the century i was

00:21:33,360 --> 00:21:37,840
developing violet applications

00:21:35,840 --> 00:21:39,679
uh and there was a version of lua that

00:21:37,840 --> 00:21:41,120
was available on the palm pilot called

00:21:39,679 --> 00:21:43,919
plua

00:21:41,120 --> 00:21:44,720
and lua made it very easy plua made it

00:21:43,919 --> 00:21:47,840
very easy

00:21:44,720 --> 00:21:50,960
to interact with the palm pilot os

00:21:47,840 --> 00:21:52,880
and to extend the functionality and

00:21:50,960 --> 00:21:54,960
ever since then i've it's been one of my

00:21:52,880 --> 00:21:57,679
go-to languages

00:21:54,960 --> 00:21:58,320
the code up here is a code that works

00:21:57,679 --> 00:22:02,080
with

00:21:58,320 --> 00:22:04,320
modlua which is one of the modules

00:22:02,080 --> 00:22:06,720
that's distributed with the apache web

00:22:04,320 --> 00:22:06,720
server

00:22:06,799 --> 00:22:13,520
i've used lua on ios i've used lua and

00:22:10,159 --> 00:22:17,360
android i mentioned palm pilot and

00:22:13,520 --> 00:22:17,360
quite a range of platforms

00:22:19,520 --> 00:22:24,559
um i think at this point i'm going to

00:22:22,720 --> 00:22:26,000
skip over these couple of slides about

00:22:24,559 --> 00:22:27,919
an introduction to lua

00:22:26,000 --> 00:22:29,600
there are some syntactic differences and

00:22:27,919 --> 00:22:32,320
some others uh

00:22:29,600 --> 00:22:33,840
some design choices that a lot of people

00:22:32,320 --> 00:22:36,799
are up in arms about

00:22:33,840 --> 00:22:37,760
uh one based indexing versus zero based

00:22:36,799 --> 00:22:40,720
indexing being the

00:22:37,760 --> 00:22:40,720
being the chief one

00:22:41,120 --> 00:22:45,679
but lua by and large looks a lot like

00:22:44,000 --> 00:22:46,159
most of the other programming languages

00:22:45,679 --> 00:22:48,000
that

00:22:46,159 --> 00:22:49,840
that you're familiar with so i'm going

00:22:48,000 --> 00:22:52,240
to skip over these couple of slides

00:22:49,840 --> 00:22:54,480
and as we're talking about as we're

00:22:52,240 --> 00:22:56,880
looking at actual code integration code

00:22:54,480 --> 00:22:58,000
we may come back and and hit some points

00:22:56,880 --> 00:23:01,440
about lua

00:22:58,000 --> 00:23:01,440
if it turns out to be necessary

00:23:01,760 --> 00:23:06,400
so let's talk about an example let's

00:23:04,640 --> 00:23:08,400
take a look at an example of

00:23:06,400 --> 00:23:09,440
scripting an application and so for this

00:23:08,400 --> 00:23:11,919
applica

00:23:09,440 --> 00:23:12,960
so for this example i want a simple

00:23:11,919 --> 00:23:14,640
program i'm going to

00:23:12,960 --> 00:23:16,720
show you a program and see and i'm going

00:23:14,640 --> 00:23:19,679
to show you how to embed lua into it

00:23:16,720 --> 00:23:21,039
and how to get that interaction between

00:23:19,679 --> 00:23:24,720
the two different environments

00:23:21,039 --> 00:23:27,360
and so i want a program a c program

00:23:24,720 --> 00:23:29,280
that provides the minimal amount of

00:23:27,360 --> 00:23:29,919
distractions yet something that's that's

00:23:29,280 --> 00:23:33,200
just

00:23:29,919 --> 00:23:36,640
begging to be scripted

00:23:33,200 --> 00:23:40,400
so of course here it is hello world

00:23:36,640 --> 00:23:41,520
okay um at this point it occurs to me

00:23:40,400 --> 00:23:44,480
that

00:23:41,520 --> 00:23:46,559
i was going to i was going to run a poll

00:23:44,480 --> 00:23:48,880
earlier on

00:23:46,559 --> 00:23:50,559
and one of the questions was just a

00:23:48,880 --> 00:23:54,400
general survey of roughly how

00:23:50,559 --> 00:23:58,159
how familiar uh all of you all

00:23:54,400 --> 00:24:00,080
are with c programming but uh naturally

00:23:58,159 --> 00:24:02,000
i i didn't remember to do that so i'm

00:24:00,080 --> 00:24:04,799
just gonna to braise on

00:24:02,000 --> 00:24:06,960
um this is basically pretty simple the

00:24:04,799 --> 00:24:10,159
pound include line at the top

00:24:06,960 --> 00:24:12,799
uh is how in c we bring in uh

00:24:10,159 --> 00:24:13,679
declarations uh one of the things about

00:24:12,799 --> 00:24:15,679
c is that

00:24:13,679 --> 00:24:18,240
uh typically declarations and

00:24:15,679 --> 00:24:19,440
implementations are separated uh so

00:24:18,240 --> 00:24:22,240
declaration is

00:24:19,440 --> 00:24:24,000
is declaring the names of variables of

00:24:22,240 --> 00:24:25,120
functions and so forth and what their

00:24:24,000 --> 00:24:26,799
types are and then

00:24:25,120 --> 00:24:28,880
the implementation is of course the

00:24:26,799 --> 00:24:30,400
implementation so here we're saying

00:24:28,880 --> 00:24:32,400
we're going to make use of the standard

00:24:30,400 --> 00:24:34,720
i o library uh

00:24:32,400 --> 00:24:36,080
and we're not doing a whole lot we're

00:24:34,720 --> 00:24:39,360
going to print out hello world

00:24:36,080 --> 00:24:39,360
so how are we going to script this

00:24:40,720 --> 00:24:47,200
um before i show you that let's just say

00:24:44,880 --> 00:24:50,400
let's just go over a couple other points

00:24:47,200 --> 00:24:52,799
about c real quickly

00:24:50,400 --> 00:24:53,520
okay so c is compiled language and it's

00:24:52,799 --> 00:24:55,840
a language

00:24:53,520 --> 00:24:58,720
that's statically typed so if we look

00:24:55,840 --> 00:25:00,640
back here for example

00:24:58,720 --> 00:25:02,000
main is the function it's the entry

00:25:00,640 --> 00:25:04,720
point to our application

00:25:02,000 --> 00:25:05,760
and it's a type int uh it returns an

00:25:04,720 --> 00:25:08,480
integer

00:25:05,760 --> 00:25:10,240
which uh you don't see here but we'll

00:25:08,480 --> 00:25:14,640
ignore that for now

00:25:10,240 --> 00:25:18,080
so it's a statically typed language

00:25:14,640 --> 00:25:20,720
handling of memory is manually done

00:25:18,080 --> 00:25:22,400
you use a function called malloc to

00:25:20,720 --> 00:25:23,440
allocate memory and then you have to

00:25:22,400 --> 00:25:25,200
remember to free it

00:25:23,440 --> 00:25:27,440
and if you don't remember to free it

00:25:25,200 --> 00:25:29,440
really bad things happen

00:25:27,440 --> 00:25:31,120
which is a big motivator for why we have

00:25:29,440 --> 00:25:33,440
a whole bunch of other languages that we

00:25:31,120 --> 00:25:36,799
program it

00:25:33,440 --> 00:25:38,159
uh and um c lets you make use of

00:25:36,799 --> 00:25:40,640
pointers

00:25:38,159 --> 00:25:42,159
and despite the nasty evil things you've

00:25:40,640 --> 00:25:44,799
heard about pointers which

00:25:42,159 --> 00:25:46,720
basically are ways of being able to

00:25:44,799 --> 00:25:48,000
manipulate and access different spots

00:25:46,720 --> 00:25:50,320
and memory

00:25:48,000 --> 00:25:52,080
um pretty much every language lets you

00:25:50,320 --> 00:25:53,760
use pointers it's just that some of them

00:25:52,080 --> 00:25:55,600
wrap it up and hide it behind the

00:25:53,760 --> 00:25:58,320
curtain a little bit

00:25:55,600 --> 00:25:59,279
uh in particular two things to uh keep

00:25:58,320 --> 00:26:01,279
an eye out

00:25:59,279 --> 00:26:02,799
for as we look at c code if you're not

00:26:01,279 --> 00:26:05,440
familiar with c

00:26:02,799 --> 00:26:06,480
uh the asterisk uh anytime you see an

00:26:05,440 --> 00:26:08,080
asterisk or

00:26:06,480 --> 00:26:09,679
ampersand you know you're dealing with

00:26:08,080 --> 00:26:10,960
with pointers the asterisk is

00:26:09,679 --> 00:26:13,039
dereferencing

00:26:10,960 --> 00:26:14,480
so we're going to take a pointer in

00:26:13,039 --> 00:26:16,799
other words a variable that

00:26:14,480 --> 00:26:17,760
doesn't have data in it but it has the

00:26:16,799 --> 00:26:20,720
location

00:26:17,760 --> 00:26:23,120
of data and the asterisk says take that

00:26:20,720 --> 00:26:24,720
location go out and get me the data

00:26:23,120 --> 00:26:26,159
the ampersand kind of works the other

00:26:24,720 --> 00:26:28,159
way around the ampersand takes a

00:26:26,159 --> 00:26:30,400
variable and grabs its address

00:26:28,159 --> 00:26:31,840
and then we can use that to take regular

00:26:30,400 --> 00:26:35,039
variables

00:26:31,840 --> 00:26:35,039
and turn them into pointers

00:26:35,279 --> 00:26:39,360
and as i mentioned um uh just a minute

00:26:38,880 --> 00:26:41,760
ago

00:26:39,360 --> 00:26:42,480
uh one of the big things about c is we

00:26:41,760 --> 00:26:44,480
is is

00:26:42,480 --> 00:26:46,240
there's oftentimes the separation

00:26:44,480 --> 00:26:48,000
between the declaration so you'll get

00:26:46,240 --> 00:26:50,559
for example these dot h these header

00:26:48,000 --> 00:26:52,480
files that declare

00:26:50,559 --> 00:26:53,760
functions and variables and so forth and

00:26:52,480 --> 00:26:56,880
then their implementation

00:26:53,760 --> 00:26:56,880
in the dot c files

00:26:57,200 --> 00:27:01,919
so the first step in scripting hello

00:27:00,159 --> 00:27:04,480
world is we need to embed a new

00:27:01,919 --> 00:27:04,480
interpreter

00:27:05,520 --> 00:27:10,720
um and for the most part uh

00:27:08,720 --> 00:27:12,400
subject to limitations the screen size

00:27:10,720 --> 00:27:15,200
what i'm doing in these next slides

00:27:12,400 --> 00:27:16,400
is a code that you've already seen is

00:27:15,200 --> 00:27:18,080
going to be in white

00:27:16,400 --> 00:27:21,120
and new code is going to be highlighted

00:27:18,080 --> 00:27:23,600
in green and so to embed a lua

00:27:21,120 --> 00:27:25,520
interpreter

00:27:23,600 --> 00:27:27,520
into your program doesn't require a lot

00:27:25,520 --> 00:27:28,960
of work we have two header files that we

00:27:27,520 --> 00:27:32,159
need to

00:27:28,960 --> 00:27:34,480
include and we need to create

00:27:32,159 --> 00:27:35,200
a lua interpreter and we do that on this

00:27:34,480 --> 00:27:38,640
line here

00:27:35,200 --> 00:27:40,399
with the lual new state function uh

00:27:38,640 --> 00:27:42,640
one thing to keep in mind about the lua

00:27:40,399 --> 00:27:44,640
api any

00:27:42,640 --> 00:27:45,760
function that's prefixed with lua

00:27:44,640 --> 00:27:49,039
underscore

00:27:45,760 --> 00:27:51,840
is sort of a core api function

00:27:49,039 --> 00:27:53,120
and any function prefixed with lua l

00:27:51,840 --> 00:27:55,760
underscore

00:27:53,120 --> 00:27:57,520
is in this auxiliary library they're

00:27:55,760 --> 00:27:59,520
sort of convenience functions so we

00:27:57,520 --> 00:28:01,760
could get by without them

00:27:59,520 --> 00:28:03,200
but it's going to make life a lot more

00:28:01,760 --> 00:28:04,640
complicated there's more code that you

00:28:03,200 --> 00:28:06,960
have to write if you don't use these

00:28:04,640 --> 00:28:08,720
helper functions

00:28:06,960 --> 00:28:10,159
so to embed a lua interpreter all we

00:28:08,720 --> 00:28:12,640
really need to do

00:28:10,159 --> 00:28:14,640
is we need to create a new state and

00:28:12,640 --> 00:28:17,200
store it in a variable

00:28:14,640 --> 00:28:20,000
so that's what this capital l is the

00:28:17,200 --> 00:28:23,600
it's a pointer to a lewis state

00:28:20,000 --> 00:28:25,120
it is possible to embed several lewis

00:28:23,600 --> 00:28:27,360
states in an application

00:28:25,120 --> 00:28:29,039
uh if you have a multi-threaded

00:28:27,360 --> 00:28:31,120
application if you want to make use of

00:28:29,039 --> 00:28:33,919
multiple cores that can be useful to do

00:28:31,120 --> 00:28:35,600
i'm not going to talk about it here

00:28:33,919 --> 00:28:37,039
uh and then in the next line what i've

00:28:35,600 --> 00:28:39,520
done is i've

00:28:37,039 --> 00:28:40,640
moved the responsibility of printing

00:28:39,520 --> 00:28:43,120
hello world

00:28:40,640 --> 00:28:44,000
out of the c realm and into the lua

00:28:43,120 --> 00:28:46,159
realm so

00:28:44,000 --> 00:28:47,520
we make use of this helper function blue

00:28:46,159 --> 00:28:49,840
l d string

00:28:47,520 --> 00:28:52,720
which does the obvious thing it takes a

00:28:49,840 --> 00:28:56,320
string which should be valid lua code

00:28:52,720 --> 00:28:56,320
and executes it in the state

00:28:56,480 --> 00:29:01,360
in the interpreter and if we run this

00:28:59,520 --> 00:29:03,120
program we get this output here on this

00:29:01,360 --> 00:29:04,960
slide

00:29:03,120 --> 00:29:07,440
so that's probably not what we were

00:29:04,960 --> 00:29:07,440
expecting

00:29:08,880 --> 00:29:11,840
so i said that by and large i'm not

00:29:10,720 --> 00:29:13,520
going to really talk about error

00:29:11,840 --> 00:29:16,080
handling or any of that but i do want to

00:29:13,520 --> 00:29:17,600
briefly mention it here

00:29:16,080 --> 00:29:20,960
so let's see if we can sort of figure

00:29:17,600 --> 00:29:23,200
out why we didn't get any output

00:29:20,960 --> 00:29:24,320
so i'm going to add one more library the

00:29:23,200 --> 00:29:27,279
standard lib

00:29:24,320 --> 00:29:29,919
this is the c standard lib i need it to

00:29:27,279 --> 00:29:29,919
be able to get

00:29:30,480 --> 00:29:36,320
exit which you see down at the bottom

00:29:34,159 --> 00:29:38,080
and i'm going to use that i'm going to

00:29:36,320 --> 00:29:40,960
execute that d string command

00:29:38,080 --> 00:29:43,279
and i'm going to uh take the return

00:29:40,960 --> 00:29:45,039
value which is an integer

00:29:43,279 --> 00:29:46,559
i'm going to capture that in a variable

00:29:45,039 --> 00:29:48,480
i'm going to check to see if it's equal

00:29:46,559 --> 00:29:50,399
to the constant lua okay

00:29:48,480 --> 00:29:52,000
if it isn't that means an error occurred

00:29:50,399 --> 00:29:55,200
i'll print out an error message

00:29:52,000 --> 00:29:57,279
and i'll exit the program uh in most

00:29:55,200 --> 00:29:58,559
unixes and i'm not sure about windows

00:29:57,279 --> 00:29:59,440
and other operating systems the

00:29:58,559 --> 00:30:02,880
convention is

00:29:59,440 --> 00:30:04,640
that if a program returns zero it's

00:30:02,880 --> 00:30:05,919
run successfully if it returns a

00:30:04,640 --> 00:30:07,600
non-zero value

00:30:05,919 --> 00:30:10,240
that signals an error so i'm going to

00:30:07,600 --> 00:30:10,240
return one

00:30:11,520 --> 00:30:16,960
now we need a little bit more to

00:30:15,520 --> 00:30:18,240
understand what's going on

00:30:16,960 --> 00:30:20,320
let's pretend that we've done a little

00:30:18,240 --> 00:30:23,520
bit more debugging and triaging

00:30:20,320 --> 00:30:25,120
uh the the problem is that print hello

00:30:23,520 --> 00:30:28,480
world will only work

00:30:25,120 --> 00:30:31,840
if the print function is defined in lua

00:30:28,480 --> 00:30:33,679
the core lua provides a real

00:30:31,840 --> 00:30:36,480
minimal set of functions and one of the

00:30:33,679 --> 00:30:38,559
functions it does not provide as print

00:30:36,480 --> 00:30:39,760
and if we want the print function the

00:30:38,559 --> 00:30:43,279
easiest way to do that

00:30:39,760 --> 00:30:46,320
is to uh take our lewis state l

00:30:43,279 --> 00:30:48,159
and uh inject the standard the lewis

00:30:46,320 --> 00:30:49,520
standard library functions into it and

00:30:48,159 --> 00:30:51,039
that's what i'm doing here with this

00:30:49,520 --> 00:30:54,159
green code

00:30:51,039 --> 00:30:55,600
the key point here though is that if we

00:30:54,159 --> 00:30:57,120
don't need

00:30:55,600 --> 00:30:58,640
all the standard library we don't

00:30:57,120 --> 00:30:59,919
necessarily have to include it in our

00:30:58,640 --> 00:31:02,559
louis state

00:30:59,919 --> 00:31:04,080
uh i don't show you but there are five

00:31:02,559 --> 00:31:06,000
or six different uh

00:31:04,080 --> 00:31:07,919
sub-libraries in the standard library

00:31:06,000 --> 00:31:08,880
and we can include just the ones that we

00:31:07,919 --> 00:31:10,720
want

00:31:08,880 --> 00:31:12,080
we can also separately create our own

00:31:10,720 --> 00:31:13,679
libraries and include them into the

00:31:12,080 --> 00:31:15,760
state as well

00:31:13,679 --> 00:31:17,360
if we include the standard library and

00:31:15,760 --> 00:31:22,720
run the code again

00:31:17,360 --> 00:31:22,720
we get what we expect we get hello world

00:31:23,279 --> 00:31:27,279
now let's take this a second step

00:31:27,600 --> 00:31:33,840
because that's not a particularly

00:31:29,440 --> 00:31:36,960
compelling use of scripting

00:31:33,840 --> 00:31:38,640
so here what i'm going to do is uh two

00:31:36,960 --> 00:31:39,200
things first of all the bottom line the

00:31:38,640 --> 00:31:42,240
printf

00:31:39,200 --> 00:31:43,120
i've moved hello world back out of lua

00:31:42,240 --> 00:31:45,279
land and

00:31:43,120 --> 00:31:47,279
back into c land where it was originally

00:31:45,279 --> 00:31:49,120
so the c program is responsible for

00:31:47,279 --> 00:31:51,200
printing hello world

00:31:49,120 --> 00:31:52,799
but the other thing that i've added here

00:31:51,200 --> 00:31:55,440
is i'm going to

00:31:52,799 --> 00:31:56,960
read in and parse a configuration file

00:31:55,440 --> 00:31:59,760
so this configuration file

00:31:56,960 --> 00:32:04,000
is going to be a file here i've

00:31:59,760 --> 00:32:04,000
hard-coded the name hello.cfg

00:32:04,559 --> 00:32:12,720
it's some valid lua program

00:32:09,120 --> 00:32:14,720
and so what i'm doing is i pass in the

00:32:12,720 --> 00:32:18,240
lua state to the configure function

00:32:14,720 --> 00:32:20,640
which is at the top here i'm ignoring

00:32:18,240 --> 00:32:21,760
error handling and so forth i'm running

00:32:20,640 --> 00:32:24,080
this helper

00:32:21,760 --> 00:32:25,360
i'm invoking this helper function do

00:32:24,080 --> 00:32:28,799
file which

00:32:25,360 --> 00:32:30,159
takes the name file reads it in parses

00:32:28,799 --> 00:32:33,279
it and runs it

00:32:30,159 --> 00:32:34,399
and whatever variable and function

00:32:33,279 --> 00:32:38,080
definitions

00:32:34,399 --> 00:32:40,000
occur in that lewis grip are going to be

00:32:38,080 --> 00:32:42,399
permanently embedded

00:32:40,000 --> 00:32:43,919
into the lewis state l and so i can make

00:32:42,399 --> 00:32:46,880
use of them later on

00:32:43,919 --> 00:32:46,880
in the c program

00:32:48,240 --> 00:32:52,159
but notice that i'm not really i i still

00:32:51,440 --> 00:32:56,240
haven't yet

00:32:52,159 --> 00:32:59,360
achieved what i said we need i'm not

00:32:56,240 --> 00:33:00,399
taking any data from lua land and making

00:32:59,360 --> 00:33:02,720
use of it in c

00:33:00,399 --> 00:33:04,640
or vice versa so we're not really there

00:33:02,720 --> 00:33:09,200
yet

00:33:04,640 --> 00:33:11,440
okay and so to to get that

00:33:09,200 --> 00:33:14,640
interaction between the two environments

00:33:11,440 --> 00:33:17,120
needs a little bit more work

00:33:14,640 --> 00:33:19,440
this is not necessarily the best way of

00:33:17,120 --> 00:33:22,799
doing this but it but it is the easiest

00:33:19,440 --> 00:33:23,760
so i'm going to create an array of 256

00:33:22,799 --> 00:33:27,840
characters called

00:33:23,760 --> 00:33:28,960
name i'm including the string library

00:33:27,840 --> 00:33:30,559
because later on i'm going to need a

00:33:28,960 --> 00:33:32,399
function called stir copy

00:33:30,559 --> 00:33:34,000
which copies a string from one variable

00:33:32,399 --> 00:33:35,600
to another

00:33:34,000 --> 00:33:37,519
and i'm going to call this function get

00:33:35,600 --> 00:33:38,640
name and the result of the function

00:33:37,519 --> 00:33:40,559
after it completes

00:33:38,640 --> 00:33:42,080
is that the name variable is going to

00:33:40,559 --> 00:33:43,519
have some data in it

00:33:42,080 --> 00:33:46,080
and down here at the end i'm going to

00:33:43,519 --> 00:33:48,399
use that data to print out my

00:33:46,080 --> 00:33:49,120
salutations so now i can use the config

00:33:48,399 --> 00:33:50,960
file

00:33:49,120 --> 00:33:52,399
and i don't just have to say hello world

00:33:50,960 --> 00:33:54,720
i can say hello to

00:33:52,399 --> 00:33:55,519
whoever i've configured via the config

00:33:54,720 --> 00:33:56,799
file

00:33:55,519 --> 00:33:59,200
let's take a look at the get name

00:33:56,799 --> 00:33:59,200
function

00:34:01,200 --> 00:34:06,880
okay here it is again no real error

00:34:04,320 --> 00:34:10,320
handling or checking

00:34:06,880 --> 00:34:11,760
let's look at the key pieces so here i'm

00:34:10,320 --> 00:34:15,440
making use of the

00:34:11,760 --> 00:34:18,159
lua api notice this is the the core api

00:34:15,440 --> 00:34:19,200
it's not lua l it's just lua to get

00:34:18,159 --> 00:34:20,800
global

00:34:19,200 --> 00:34:23,040
so i'm assuming that that the

00:34:20,800 --> 00:34:25,839
configuration file is going to set some

00:34:23,040 --> 00:34:28,320
global variable called name i'm going to

00:34:25,839 --> 00:34:31,200
grab that value

00:34:28,320 --> 00:34:32,879
and i'm going to then use the tostring

00:34:31,200 --> 00:34:35,119
function

00:34:32,879 --> 00:34:36,399
to pull that out of lua land and stick

00:34:35,119 --> 00:34:39,839
it into n

00:34:36,399 --> 00:34:39,839
which is a function in

00:34:41,679 --> 00:34:45,040
um which is the function in the c

00:34:43,919 --> 00:34:46,720
environment

00:34:45,040 --> 00:34:50,240
and give me just one second i need to

00:34:46,720 --> 00:34:52,639
move this q a window out of the way

00:34:50,240 --> 00:35:02,400
which is tricky because my cursor is

00:34:52,639 --> 00:35:06,560
invisible for some reason

00:35:02,400 --> 00:35:09,680
um all right i'm giving up on that um

00:35:06,560 --> 00:35:12,560
so let's talk just a little bit

00:35:09,680 --> 00:35:13,040
about how this lua 2 string functions uh

00:35:12,560 --> 00:35:14,560
and

00:35:13,040 --> 00:35:16,480
and to make it clear what's going on

00:35:14,560 --> 00:35:19,680
here with the two-string function

00:35:16,480 --> 00:35:22,560
i need to talk a little bit about how

00:35:19,680 --> 00:35:25,359
data is passed back and forth between

00:35:22,560 --> 00:35:31,280
lua and c

00:35:25,359 --> 00:35:35,280
when c code invokes a lua function

00:35:31,280 --> 00:35:35,839
it gets a stack uh and this works the

00:35:35,280 --> 00:35:38,240
other way

00:35:35,839 --> 00:35:40,400
as well if lou invokes a c function it

00:35:38,240 --> 00:35:42,560
gets a stack of data

00:35:40,400 --> 00:35:44,079
and all the information that's con

00:35:42,560 --> 00:35:45,599
that's that's

00:35:44,079 --> 00:35:47,440
transferred from one context to the

00:35:45,599 --> 00:35:48,400
other is passed on this stack when the

00:35:47,440 --> 00:35:50,160
function

00:35:48,400 --> 00:35:51,599
when the c function returns or when the

00:35:50,160 --> 00:35:52,240
lua function returns and wants to

00:35:51,599 --> 00:35:55,599
communicate

00:35:52,240 --> 00:35:58,160
information back to the other context

00:35:55,599 --> 00:36:00,400
it puts that information on the stack as

00:35:58,160 --> 00:36:00,400
well

00:36:00,880 --> 00:36:05,359
i really ought to call this a stackish

00:36:03,280 --> 00:36:08,880
data structure because

00:36:05,359 --> 00:36:09,839
you can actually easily access any item

00:36:08,880 --> 00:36:12,000
on the stack

00:36:09,839 --> 00:36:13,440
whereas traditionally with a stack we we

00:36:12,000 --> 00:36:15,760
limit ourselves to only being able to

00:36:13,440 --> 00:36:17,680
access items at the top

00:36:15,760 --> 00:36:18,960
but by and large this behaves like a

00:36:17,680 --> 00:36:20,400
stack and that we're going to push

00:36:18,960 --> 00:36:22,880
things onto it we're going to be able to

00:36:20,400 --> 00:36:25,440
pop things off of it

00:36:22,880 --> 00:36:26,960
the indexes that we use so for example

00:36:25,440 --> 00:36:28,960
you see here lua 2 string

00:36:26,960 --> 00:36:30,720
l because we need to pass the lowest

00:36:28,960 --> 00:36:32,480
state to every function

00:36:30,720 --> 00:36:35,119
and then minus one that's the stack

00:36:32,480 --> 00:36:36,960
index stack indices positive stack

00:36:35,119 --> 00:36:37,680
indices start with one at the bottom of

00:36:36,960 --> 00:36:39,839
the stack

00:36:37,680 --> 00:36:41,200
and go all the way up to the top of the

00:36:39,839 --> 00:36:42,800
stack

00:36:41,200 --> 00:36:44,480
the negative indices work the other way

00:36:42,800 --> 00:36:46,000
around so negative one is the item on

00:36:44,480 --> 00:36:49,520
the stack

00:36:46,000 --> 00:36:51,680
and so what we're saying here is

00:36:49,520 --> 00:36:52,960
i want to grab the item from the top of

00:36:51,680 --> 00:36:56,800
the stack

00:36:52,960 --> 00:36:58,400
and i'm assuming that it's a string

00:36:56,800 --> 00:37:00,079
ideally i would have already checked to

00:36:58,400 --> 00:37:00,720
make sure that it legitimately is a

00:37:00,079 --> 00:37:03,040
string

00:37:00,720 --> 00:37:05,040
and signal an error if not but i'm

00:37:03,040 --> 00:37:06,720
cutting corners

00:37:05,040 --> 00:37:08,160
so we're grabbing this string that's on

00:37:06,720 --> 00:37:11,280
the top of the stack

00:37:08,160 --> 00:37:14,160
we're copying it into this variable n

00:37:11,280 --> 00:37:15,839
and then we're going to uh use the

00:37:14,160 --> 00:37:17,920
string copy remember that's the c

00:37:15,839 --> 00:37:19,839
standard function from for copying

00:37:17,920 --> 00:37:22,079
strings from one variable to another

00:37:19,839 --> 00:37:24,960
we're going to copy it out of n and into

00:37:22,079 --> 00:37:27,599
in into name which i've passed in

00:37:24,960 --> 00:37:29,920
now uh if i was doing this for real i

00:37:27,599 --> 00:37:31,200
wouldn't do this two-step process but

00:37:29,920 --> 00:37:33,040
i thought it would make things a little

00:37:31,200 --> 00:37:35,359
bit clearer if i had the two different

00:37:33,040 --> 00:37:37,599
lines here

00:37:35,359 --> 00:37:38,640
so as i mentioned we're taking the data

00:37:37,599 --> 00:37:40,720
out of n

00:37:38,640 --> 00:37:42,160
and we're putting it into name the one

00:37:40,720 --> 00:37:45,599
thing you have to be careful of

00:37:42,160 --> 00:37:48,079
is is again handling memory properly

00:37:45,599 --> 00:37:49,680
lua is a garbage collected language and

00:37:48,079 --> 00:37:51,839
so you need to make sure

00:37:49,680 --> 00:37:53,359
that if you're referencing things like

00:37:51,839 --> 00:37:54,800
strings

00:37:53,359 --> 00:37:57,520
that they don't get collected out from

00:37:54,800 --> 00:37:58,960
under you and the api provides uh

00:37:57,520 --> 00:38:01,119
guarantees about when

00:37:58,960 --> 00:38:03,040
garbage collection will happen uh and

00:38:01,119 --> 00:38:05,839
i'm not going to get into them because

00:38:03,040 --> 00:38:05,839
we don't have time

00:38:08,640 --> 00:38:12,480
just to give you a little bit of taste

00:38:10,079 --> 00:38:15,760
here's something with a little bit more

00:38:12,480 --> 00:38:19,359
uh error handling uh included into it

00:38:15,760 --> 00:38:21,200
so this is approaching reasonable code

00:38:19,359 --> 00:38:22,720
so i'm going to get the global name

00:38:21,200 --> 00:38:24,960
we've already seen that

00:38:22,720 --> 00:38:26,160
and that get global function returns the

00:38:24,960 --> 00:38:29,359
type

00:38:26,160 --> 00:38:31,200
of data in the name variable i'm going

00:38:29,359 --> 00:38:31,760
to check that type to make sure it's a

00:38:31,200 --> 00:38:34,240
string

00:38:31,760 --> 00:38:34,800
and if it is i'll make use of it if it

00:38:34,240 --> 00:38:36,560
isn't

00:38:34,800 --> 00:38:39,040
i'm going to print an error message and

00:38:36,560 --> 00:38:39,040
exit

00:38:41,200 --> 00:38:47,040
and i could be even more more safe and

00:38:44,480 --> 00:38:49,040
secure here i can handle things better

00:38:47,040 --> 00:38:51,119
if the variable isn't defined at all if

00:38:49,040 --> 00:38:52,960
my configuration file does not define

00:38:51,119 --> 00:38:55,520
the name variable

00:38:52,960 --> 00:38:56,400
then what the type the name type is

00:38:55,520 --> 00:38:58,240
going to be

00:38:56,400 --> 00:38:59,520
is going to indicate that that name is

00:38:58,240 --> 00:39:01,599
nil

00:38:59,520 --> 00:39:05,599
and so i'll use the default value here

00:39:01,599 --> 00:39:07,359
i'll fall back on on saying hello world

00:39:05,599 --> 00:39:08,960
so the point here the main point being

00:39:07,359 --> 00:39:11,359
that the lua api has

00:39:08,960 --> 00:39:14,000
has quite a bit of machinery available

00:39:11,359 --> 00:39:17,680
to you for being able to properly detect

00:39:14,000 --> 00:39:20,960
and handle error situations even if i'm

00:39:17,680 --> 00:39:23,200
continuing to cut corners

00:39:20,960 --> 00:39:25,359
okay so here's what the hello

00:39:23,200 --> 00:39:28,480
configuration file might look like in in

00:39:25,359 --> 00:39:30,160
lua comments are prefixed by two dashes

00:39:28,480 --> 00:39:32,079
so i just have a comment here indicating

00:39:30,160 --> 00:39:33,760
the name of the file and i'm setting

00:39:32,079 --> 00:39:35,440
name equal to sophia

00:39:33,760 --> 00:39:37,920
and if we were to run this program with

00:39:35,440 --> 00:39:40,800
this config file the output we'd get is

00:39:37,920 --> 00:39:40,800
hello sophia

00:39:41,680 --> 00:39:47,920
now let's take this uh one more step of

00:39:45,119 --> 00:39:47,920
complication

00:39:48,480 --> 00:39:52,160
um and i think since i have the time for

00:39:51,119 --> 00:39:56,160
it

00:39:52,160 --> 00:40:00,160
uh let me zip back in my slides

00:39:56,160 --> 00:40:00,160
and let's just take a look real quickly

00:40:00,400 --> 00:40:07,440
uh at this slide here

00:40:04,640 --> 00:40:09,200
another aspect i really like about lua

00:40:07,440 --> 00:40:12,480
and one of the key aspects of lua

00:40:09,200 --> 00:40:14,400
is that is that lua has one core

00:40:12,480 --> 00:40:16,400
data structuring mechanism and it's

00:40:14,400 --> 00:40:19,440
called a table

00:40:16,400 --> 00:40:22,880
and essentially a table is a combination

00:40:19,440 --> 00:40:26,560
of an array and

00:40:22,880 --> 00:40:27,280
a dictionary and so for example here you

00:40:26,560 --> 00:40:30,400
see i'm

00:40:27,280 --> 00:40:30,960
defining a table called t and i'm making

00:40:30,400 --> 00:40:33,839
use of

00:40:30,960 --> 00:40:35,280
both that functionality i'm assigning

00:40:33,839 --> 00:40:38,640
value 1 and value 2

00:40:35,280 --> 00:40:41,440
to 2 keys and

00:40:38,640 --> 00:40:42,640
the three four ten essentially are going

00:40:41,440 --> 00:40:44,560
into you could think of

00:40:42,640 --> 00:40:46,000
there being a sort of array portion of

00:40:44,560 --> 00:40:49,440
this table

00:40:46,000 --> 00:40:51,040
so at index one uh is i'm going to store

00:40:49,440 --> 00:40:52,240
the value of three at index two i'm to

00:40:51,040 --> 00:40:55,119
start the value of four and an

00:40:52,240 --> 00:40:55,839
index ten i'm going to store uh the

00:40:55,119 --> 00:40:57,200
value

00:40:55,839 --> 00:40:59,920
i'm sorry at index three i'm gonna store

00:40:57,200 --> 00:40:59,920
the value ten

00:41:00,880 --> 00:41:06,319
so i really like that about lua the fact

00:41:04,880 --> 00:41:09,359
that there's this

00:41:06,319 --> 00:41:11,760
one key data structuring mechanism uh

00:41:09,359 --> 00:41:13,119
and it's very flexible and very powerful

00:41:11,760 --> 00:41:16,720
and the implementation is

00:41:13,119 --> 00:41:19,040
very elegant um

00:41:16,720 --> 00:41:20,079
and we can use that along with some

00:41:19,040 --> 00:41:23,440
syntactic sugar

00:41:20,079 --> 00:41:26,400
which i'm not going to go into to to

00:41:23,440 --> 00:41:28,160
to get some very expressive lua code

00:41:26,400 --> 00:41:31,520
particularly if we're using lua for

00:41:28,160 --> 00:41:32,000
for configurations and so very often if

00:41:31,520 --> 00:41:33,599
you use

00:41:32,000 --> 00:41:35,680
lua to do some sort of scripting and

00:41:33,599 --> 00:41:37,760
configuration you're going to

00:41:35,680 --> 00:41:39,119
see these table data structures floating

00:41:37,760 --> 00:41:41,599
floating around

00:41:39,119 --> 00:41:42,400
and so if we now switch back to the c

00:41:41,599 --> 00:41:46,160
code

00:41:42,400 --> 00:41:46,160
for this more complicated example

00:41:46,800 --> 00:41:50,960
what we're going to do is rather than

00:41:48,720 --> 00:41:51,760
getting data out of global variables

00:41:50,960 --> 00:41:54,960
we're going to get

00:41:51,760 --> 00:41:54,960
data out of tables

00:41:56,000 --> 00:41:59,040
so here i'm getting more information out

00:41:58,480 --> 00:42:00,960
of the

00:41:59,040 --> 00:42:02,480
world i'm going to get a count and i'm

00:42:00,960 --> 00:42:03,280
also going to get a salutation whether

00:42:02,480 --> 00:42:06,000
you say

00:42:03,280 --> 00:42:08,079
hello or goodbye or greetings or whatnot

00:42:06,000 --> 00:42:11,520
all that stuff is going to be configured

00:42:08,079 --> 00:42:14,319
in lua and you see down

00:42:11,520 --> 00:42:15,200
below i'm going to make use of that

00:42:14,319 --> 00:42:18,000
count

00:42:15,200 --> 00:42:18,560
is going to control how many times i

00:42:18,000 --> 00:42:21,599
repeat

00:42:18,560 --> 00:42:22,560
saying hello and i'm going to grab the

00:42:21,599 --> 00:42:25,200
name and i'm going to grab the

00:42:22,560 --> 00:42:25,200
salutation

00:42:25,440 --> 00:42:31,520
so this greeting details we pass in

00:42:28,640 --> 00:42:32,960
a pointer for name notice on the slide

00:42:31,520 --> 00:42:34,560
below here i've got two

00:42:32,960 --> 00:42:36,160
character buffers one for name and

00:42:34,560 --> 00:42:36,640
salutation i'm going to pass them both

00:42:36,160 --> 00:42:37,920
in

00:42:36,640 --> 00:42:40,240
and then i'm going to make use of that

00:42:37,920 --> 00:42:44,960
ampersand to turn the count variable

00:42:40,240 --> 00:42:49,119
into a pointer

00:42:44,960 --> 00:42:50,480
and here's the crux i'm going to

00:42:49,119 --> 00:42:52,400
for simplicity's sake i'm going to

00:42:50,480 --> 00:42:54,560
assume my table is

00:42:52,400 --> 00:42:54,560
uh

00:42:55,520 --> 00:42:59,119
sorry i i get up here the table i'm

00:42:57,920 --> 00:43:01,040
going to assume it's in a global

00:42:59,119 --> 00:43:03,440
variable called greeting

00:43:01,040 --> 00:43:04,319
and then i need to get items out of that

00:43:03,440 --> 00:43:06,160
table

00:43:04,319 --> 00:43:08,560
and so it works pretty much the same way

00:43:06,160 --> 00:43:11,920
i'm going to push onto the stack

00:43:08,560 --> 00:43:13,200
the index the key that i want the data

00:43:11,920 --> 00:43:15,359
from

00:43:13,200 --> 00:43:16,640
i'm going to then use this get tab get

00:43:15,359 --> 00:43:19,280
table function which

00:43:16,640 --> 00:43:20,400
grabs data out of the table that's on

00:43:19,280 --> 00:43:22,240
the stack

00:43:20,400 --> 00:43:24,000
and the index here minus two is telling

00:43:22,240 --> 00:43:26,480
me what stack position

00:43:24,000 --> 00:43:27,200
is the the table is located in so it

00:43:26,480 --> 00:43:30,800
expects

00:43:27,200 --> 00:43:32,720
a table at that position it expects a

00:43:30,800 --> 00:43:35,760
key at the top of the stack

00:43:32,720 --> 00:43:38,839
and it returns the data onto the stack

00:43:35,760 --> 00:43:40,160
and then with the string copy uh that

00:43:38,839 --> 00:43:41,920
two-step

00:43:40,160 --> 00:43:43,599
uh process that i did before i'm

00:43:41,920 --> 00:43:45,680
combining it into one line i'm going to

00:43:43,599 --> 00:43:47,839
grab the string at the top of the stack

00:43:45,680 --> 00:43:49,839
i'm going to copy it into the c variable

00:43:47,839 --> 00:43:52,240
name

00:43:49,839 --> 00:43:53,119
that doesn't remove that data from the

00:43:52,240 --> 00:43:55,920
top of the stack

00:43:53,119 --> 00:43:57,119
and so this next line lewis set top will

00:43:55,920 --> 00:43:59,440
do so

00:43:57,119 --> 00:44:00,160
so it leaves the table on the stack and

00:43:59,440 --> 00:44:01,520
nothing else

00:44:00,160 --> 00:44:04,160
so i can do the same thing for

00:44:01,520 --> 00:44:06,560
salutation and then i can do down here

00:44:04,160 --> 00:44:09,839
at the bottom i can do similar code

00:44:06,560 --> 00:44:09,839
for to get the count

00:44:10,560 --> 00:44:13,839
and if we look at the config file uh

00:44:13,359 --> 00:44:16,640
here's an

00:44:13,839 --> 00:44:18,640
alternate syntax for uh creating a table

00:44:16,640 --> 00:44:20,240
and specifying values in it so i've

00:44:18,640 --> 00:44:22,240
created this greeting table

00:44:20,240 --> 00:44:23,920
i've specified the name i specified the

00:44:22,240 --> 00:44:27,200
salutation ohio

00:44:23,920 --> 00:44:28,800
is informal for uh good morning japanese

00:44:27,200 --> 00:44:30,480
and i'm going to repeat it three times

00:44:28,800 --> 00:44:31,760
so i'm going to print out ohio yoshi

00:44:30,480 --> 00:44:34,240
three times

00:44:31,760 --> 00:44:36,400
based on this configuration but remember

00:44:34,240 --> 00:44:37,680
this is a lua program

00:44:36,400 --> 00:44:39,760
and so i could do something more

00:44:37,680 --> 00:44:42,079
complicated if i wanted to

00:44:39,760 --> 00:44:43,520
so now the value of count is going to be

00:44:42,079 --> 00:44:48,800
a random number

00:44:43,520 --> 00:44:51,040
from 1 to 10. so me my son matthew

00:44:48,800 --> 00:44:52,480
i know i'm almost out of time very much

00:44:51,040 --> 00:44:55,520
okay thank you

00:44:52,480 --> 00:44:58,800
thank you um so

00:44:55,520 --> 00:45:00,079
this gives you a taste of uh scripting

00:44:58,800 --> 00:45:02,720
and lua

00:45:00,079 --> 00:45:04,000
uh and so there's a lot more that we

00:45:02,720 --> 00:45:06,160
could talk about in terms

00:45:04,000 --> 00:45:07,839
of lua functionality and how to access

00:45:06,160 --> 00:45:11,119
it from the api

00:45:07,839 --> 00:45:13,280
uh but uh

00:45:11,119 --> 00:45:15,040
and and certainly feel free to reach out

00:45:13,280 --> 00:45:16,160
to me later if you have questions and

00:45:15,040 --> 00:45:18,240
i'd be interested in

00:45:16,160 --> 00:45:20,079
and i i'd be more than happy to discuss

00:45:18,240 --> 00:45:23,200
in more detail but there are two

00:45:20,079 --> 00:45:24,000
important things here that i wanted to

00:45:23,200 --> 00:45:27,760
go over

00:45:24,000 --> 00:45:31,040
uh and so one was i wanted to give you

00:45:27,760 --> 00:45:33,280
uh some detailed example of doing

00:45:31,040 --> 00:45:35,359
scripting with a particular language

00:45:33,280 --> 00:45:37,119
um in the first half of the talk what i

00:45:35,359 --> 00:45:39,280
wanted to do is i wanted to give you

00:45:37,119 --> 00:45:41,520
ideas of

00:45:39,280 --> 00:45:43,200
uh what scripting is all about why you

00:45:41,520 --> 00:45:45,680
wanted the script

00:45:43,200 --> 00:45:48,240
uh and so hopefully i've covered who

00:45:45,680 --> 00:45:51,680
what where why and how

00:45:48,240 --> 00:45:54,400
and i hope that the last 45 minutes

00:45:51,680 --> 00:45:55,359
has been useful and interesting as i

00:45:54,400 --> 00:45:57,440
said

00:45:55,359 --> 00:45:59,200
since we're out of time please feel free

00:45:57,440 --> 00:46:00,640
to contact me

00:45:59,200 --> 00:46:02,880
i know that they're going to make the

00:46:00,640 --> 00:46:05,760
recording and the slide decks available

00:46:02,880 --> 00:46:08,160
so you'll have my contact information i

00:46:05,760 --> 00:46:15,839
thank you very much for your time

00:46:08,160 --> 00:46:15,839
and i hope you enjoyed open source 101.

00:46:16,560 --> 00:46:18,640

YouTube URL: https://www.youtube.com/watch?v=cVQG86Mxsw0


