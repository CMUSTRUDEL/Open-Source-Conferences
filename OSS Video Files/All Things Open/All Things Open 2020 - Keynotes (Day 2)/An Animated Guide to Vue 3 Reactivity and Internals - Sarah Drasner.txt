Title: An Animated Guide to Vue 3 Reactivity and Internals - Sarah Drasner
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Keynotes (Day 2)
Description: 
	Presented by: Sarah Drasner, Netlify
Presented at All Things Open 2020 Keynotes (Day 2)

Abstract: There is a lot of talk about Reactivity in the frontend landscape of late, but what is it? And how does Vue use reactive premises to manage state in an application? In this talk, we'll go over what reactivity is in general, and how that applies to the upcoming changes in Vue 3. We'll cover proxies, the virtual DOM, and watchers along the way.
Captions: 
	00:00:05,520 --> 00:00:10,000
all right i am so excited to be here

00:00:08,000 --> 00:00:12,000
um thank you so much todd and all of the

00:00:10,000 --> 00:00:14,000
organizers of all things open for having

00:00:12,000 --> 00:00:14,400
me this is such a wonderful conference i

00:00:14,000 --> 00:00:16,480
mean

00:00:14,400 --> 00:00:18,320
i'm really passionate about open source

00:00:16,480 --> 00:00:21,359
so i'm so glad to be here

00:00:18,320 --> 00:00:22,640
um so why are they having me here today

00:00:21,359 --> 00:00:24,560
uh well it might be because they're

00:00:22,640 --> 00:00:26,880
curious about how vue

00:00:24,560 --> 00:00:28,400
3 actually works and thankfully that's a

00:00:26,880 --> 00:00:30,320
question i can answer because

00:00:28,400 --> 00:00:32,000
otherwise that would be kind of awkward

00:00:30,320 --> 00:00:35,280
um today we're going to go

00:00:32,000 --> 00:00:38,239
through an animated guide of you three

00:00:35,280 --> 00:00:40,079
reactivities and internals we're going

00:00:38,239 --> 00:00:43,200
to go through some really

00:00:40,079 --> 00:00:43,600
you know deep down stuff but i'm going

00:00:43,200 --> 00:00:45,200
to

00:00:43,600 --> 00:00:47,120
introduce it at a kind of high level

00:00:45,200 --> 00:00:49,120
with some animation so that you can

00:00:47,120 --> 00:00:50,960
understand what's changing and what's

00:00:49,120 --> 00:00:53,199
staying the same

00:00:50,960 --> 00:00:54,559
as mentioned i'm sarah drasner or sarah

00:00:53,199 --> 00:00:57,920
edo on twitter

00:00:54,559 --> 00:00:59,920
i'm on the view core team i'm a vp of

00:00:57,920 --> 00:01:02,640
developer experience at netlify

00:00:59,920 --> 00:01:04,879
as todd mentioned i also am a

00:01:02,640 --> 00:01:07,280
co-organizer of concatenate along with

00:01:04,879 --> 00:01:08,400
amazing people like codebeast on twitter

00:01:07,280 --> 00:01:10,240
gift um

00:01:08,400 --> 00:01:12,159
a few other people that you might uh be

00:01:10,240 --> 00:01:14,880
aware of um

00:01:12,159 --> 00:01:16,720
i'm i mentioned that i'm a vp event uh

00:01:14,880 --> 00:01:18,159
of developer experience at nellify which

00:01:16,720 --> 00:01:20,159
is neither netflix or

00:01:18,159 --> 00:01:21,920
shopify which is very confusing for my

00:01:20,159 --> 00:01:23,759
parents but if you're not familiar with

00:01:21,920 --> 00:01:26,159
netlify it's my favorite way to

00:01:23,759 --> 00:01:27,280
uh to deploy sites and apps which is why

00:01:26,159 --> 00:01:29,040
i asked to work there

00:01:27,280 --> 00:01:32,159
we also support a lot of open source

00:01:29,040 --> 00:01:34,640
projects like react and kubernetes and

00:01:32,159 --> 00:01:36,079
uh vue and lodash so if you're

00:01:34,640 --> 00:01:38,240
interested in open source

00:01:36,079 --> 00:01:39,119
support that is also a good place to do

00:01:38,240 --> 00:01:41,360
so

00:01:39,119 --> 00:01:42,560
so i'm going to walk through everything

00:01:41,360 --> 00:01:44,240
today but i want to

00:01:42,560 --> 00:01:45,759
i want you to know that all the demos

00:01:44,240 --> 00:01:47,759
for the talk are also

00:01:45,759 --> 00:01:49,920
open source they're all written in

00:01:47,759 --> 00:01:50,880
javascript even though they're animated

00:01:49,920 --> 00:01:52,079
i'm going to be showing you some

00:01:50,880 --> 00:01:53,200
animated things on the screen but

00:01:52,079 --> 00:01:56,560
they're all still

00:01:53,200 --> 00:01:57,280
just javascript um it's using a lot of

00:01:56,560 --> 00:01:59,840
the same

00:01:57,280 --> 00:02:00,399
premises that we'll be covering which

00:01:59,840 --> 00:02:02,560
makes it

00:02:00,399 --> 00:02:03,759
very meta i'm going to explain some

00:02:02,560 --> 00:02:06,560
disparate concepts

00:02:03,759 --> 00:02:08,000
sort of in an faq format based on real

00:02:06,560 --> 00:02:10,319
questions that people ask me but

00:02:08,000 --> 00:02:11,680
one thing to note is that the concepts

00:02:10,319 --> 00:02:12,720
that i'm going to show you are all

00:02:11,680 --> 00:02:14,640
interrelated

00:02:12,720 --> 00:02:17,840
so they work in concert together to

00:02:14,640 --> 00:02:20,879
create a single experience

00:02:17,840 --> 00:02:22,080
so what is reactivity the canonical

00:02:20,879 --> 00:02:23,840
example that people usually

00:02:22,080 --> 00:02:25,440
show because it's a great one is an

00:02:23,840 --> 00:02:28,800
excel spreadsheet so

00:02:25,440 --> 00:02:29,120
if we were to you know have a cell that

00:02:28,800 --> 00:02:32,000
was

00:02:29,120 --> 00:02:32,560
two and three and the last one is five

00:02:32,000 --> 00:02:35,760
if we're

00:02:32,560 --> 00:02:37,920
updating that and we have that sum it's

00:02:35,760 --> 00:02:39,680
automatically going to update in that

00:02:37,920 --> 00:02:42,319
final cell right we have

00:02:39,680 --> 00:02:44,319
we initially had a sum of five but we

00:02:42,319 --> 00:02:45,040
didn't have to change anything in order

00:02:44,319 --> 00:02:48,080
to make that

00:02:45,040 --> 00:02:51,360
six we just changed the first value

00:02:48,080 --> 00:02:52,879
and then that you know updated as well

00:02:51,360 --> 00:02:55,200
this is not the way that things work in

00:02:52,879 --> 00:02:58,480
javascript so if i had a value of 2

00:02:55,200 --> 00:02:59,440
and i had a sum and it was 5 if my value

00:02:58,480 --> 00:03:02,640
of 2

00:02:59,440 --> 00:03:05,760
i reassign to 3 and then

00:03:02,640 --> 00:03:08,879
log sum again it will stay five

00:03:05,760 --> 00:03:11,440
so how do we adjust to changes

00:03:08,879 --> 00:03:13,360
in javascript in terms of reactivity and

00:03:11,440 --> 00:03:15,840
reactivity is something that is

00:03:13,360 --> 00:03:17,200
a you know a kind of programming concept

00:03:15,840 --> 00:03:20,879
that is bigger than just

00:03:17,200 --> 00:03:22,239
view but it's really useful for uis and

00:03:20,879 --> 00:03:25,519
applications because

00:03:22,239 --> 00:03:27,120
we do a lot of adjusting to change so

00:03:25,519 --> 00:03:28,799
in order to make those changes in

00:03:27,120 --> 00:03:30,560
javascript uh

00:03:28,799 --> 00:03:32,080
we would have to detect if there's a

00:03:30,560 --> 00:03:33,920
change in one of those values

00:03:32,080 --> 00:03:35,840
we'd have to track the function that

00:03:33,920 --> 00:03:36,640
changes it we'd have to trigger a

00:03:35,840 --> 00:03:39,440
function

00:03:36,640 --> 00:03:40,400
so that it can update that final value

00:03:39,440 --> 00:03:42,879
so how does view

00:03:40,400 --> 00:03:43,440
three do this view three just came out

00:03:42,879 --> 00:03:46,080
so

00:03:43,440 --> 00:03:48,400
how does that do this we get this done

00:03:46,080 --> 00:03:51,920
with a thing called proxies so i made an

00:03:48,400 --> 00:03:54,959
animated explainer that goes over it

00:03:51,920 --> 00:03:54,959
we start with an object

00:03:55,680 --> 00:04:00,560
we add a handler and a proxy to the

00:03:58,840 --> 00:04:03,680
object

00:04:00,560 --> 00:04:03,680
in this case it's the same

00:04:05,200 --> 00:04:09,920
but look we can intercept the object

00:04:07,439 --> 00:04:11,519
with this proxy

00:04:09,920 --> 00:04:14,480
and here's the cool part if we change

00:04:11,519 --> 00:04:16,560
the first object the proxied object

00:04:14,480 --> 00:04:17,759
updates accordingly without adjusting

00:04:16,560 --> 00:04:19,919
the handler

00:04:17,759 --> 00:04:22,400
with reactivity we can respond to

00:04:19,919 --> 00:04:24,560
changes instantly

00:04:22,400 --> 00:04:26,639
cool that was quick and kind of high

00:04:24,560 --> 00:04:28,560
level so let's explore this concept in a

00:04:26,639 --> 00:04:30,880
little bit more depth and then move on

00:04:28,560 --> 00:04:32,080
so let's dive into what proxies are in

00:04:30,880 --> 00:04:34,720
general

00:04:32,080 --> 00:04:36,479
a proxy is an object that encases

00:04:34,720 --> 00:04:38,960
another object or function and allows

00:04:36,479 --> 00:04:41,280
you to intercept it

00:04:38,960 --> 00:04:42,320
so he at its base here's what it looks

00:04:41,280 --> 00:04:44,800
like new

00:04:42,320 --> 00:04:46,000
proxy and you pass in the target and the

00:04:44,800 --> 00:04:47,120
handler and let's look at what that

00:04:46,000 --> 00:04:49,840
looks like

00:04:47,120 --> 00:04:51,520
so if i have my dinner and the meal is

00:04:49,840 --> 00:04:54,240
tacos

00:04:51,520 --> 00:04:55,680
i can create a handler that basically

00:04:54,240 --> 00:04:57,360
has this get method

00:04:55,680 --> 00:04:59,360
that passes in the target in the prop

00:04:57,360 --> 00:05:02,160
and we're returning the target prop

00:04:59,360 --> 00:05:02,720
in square bracket notation if we get the

00:05:02,160 --> 00:05:06,000
meal

00:05:02,720 --> 00:05:07,120
and we say const proxy is the dinner and

00:05:06,000 --> 00:05:09,600
the handler

00:05:07,120 --> 00:05:10,800
and then we console.log proxy.meal what

00:05:09,600 --> 00:05:13,440
do you think is going to happen

00:05:10,800 --> 00:05:16,160
well you see tacos is returned that's

00:05:13,440 --> 00:05:18,080
awesome because tacos are amazing

00:05:16,160 --> 00:05:20,080
but what if we want to intercept this

00:05:18,080 --> 00:05:23,520
value and we can actually do that

00:05:20,080 --> 00:05:25,919
quite easily so we can console log

00:05:23,520 --> 00:05:27,120
something like intercepted here or

00:05:25,919 --> 00:05:30,400
anything that you'd

00:05:27,120 --> 00:05:33,360
wish and we still return that you know

00:05:30,400 --> 00:05:35,120
our return our return prop and target

00:05:33,360 --> 00:05:35,600
prop and square bracket notation and

00:05:35,120 --> 00:05:37,759
cool

00:05:35,600 --> 00:05:38,720
if what what do we see we see

00:05:37,759 --> 00:05:41,680
intercepted

00:05:38,720 --> 00:05:43,280
and then tacos so that gives us kind of

00:05:41,680 --> 00:05:46,720
like a useful

00:05:43,280 --> 00:05:48,000
um way to kind of be involved in that

00:05:46,720 --> 00:05:50,800
object as we

00:05:48,000 --> 00:05:51,600
proxy that object so you can see

00:05:50,800 --> 00:05:53,280
console.log

00:05:51,600 --> 00:05:55,360
intercepted and there we've logged

00:05:53,280 --> 00:05:58,880
intercepted

00:05:55,360 --> 00:05:59,759
so what if we want to do something

00:05:58,880 --> 00:06:02,080
totally different

00:05:59,759 --> 00:06:03,520
we don't we don't necessarily want to do

00:06:02,080 --> 00:06:06,240
exactly the same thing

00:06:03,520 --> 00:06:06,800
we don't have to return the target and

00:06:06,240 --> 00:06:08,800
prop

00:06:06,800 --> 00:06:10,319
we can actually do something completely

00:06:08,800 --> 00:06:12,080
different so we can console.log

00:06:10,319 --> 00:06:13,360
we swapped out your dinner and i can

00:06:12,080 --> 00:06:16,479
return burger

00:06:13,360 --> 00:06:18,319
and then if i say you know proxy.meal

00:06:16,479 --> 00:06:18,720
and we say we swapped out your burger

00:06:18,319 --> 00:06:21,199
your

00:06:18,720 --> 00:06:22,400
your meal and that's a burger and now

00:06:21,199 --> 00:06:24,800
we're getting a burger

00:06:22,400 --> 00:06:26,880
i mean that's that's crazy i don't want

00:06:24,800 --> 00:06:28,240
a burger i want a taco so in javascript

00:06:26,880 --> 00:06:31,600
that's called the trap

00:06:28,240 --> 00:06:33,039
um it's because we can do and we can do

00:06:31,600 --> 00:06:35,919
many things we can intercept

00:06:33,039 --> 00:06:36,960
things in many ways um and yeah it's a

00:06:35,919 --> 00:06:38,880
trap

00:06:36,960 --> 00:06:40,319
we don't necessarily want a burger

00:06:38,880 --> 00:06:42,960
instead of a taco

00:06:40,319 --> 00:06:44,639
uh so the key here is that we can

00:06:42,960 --> 00:06:44,960
intercept this in any way that we want

00:06:44,639 --> 00:06:47,440
but

00:06:44,960 --> 00:06:48,720
if you want to use it in the same way

00:06:47,440 --> 00:06:51,520
you have to remember

00:06:48,720 --> 00:06:53,039
to also return that value okay so let's

00:06:51,520 --> 00:06:55,680
go back to the initial

00:06:53,039 --> 00:06:57,280
uh example here so we're returning with

00:06:55,680 --> 00:07:00,560
that square bracket notation but there's

00:06:57,280 --> 00:07:02,160
another way to extract the value

00:07:00,560 --> 00:07:04,039
this is something that only proxies

00:07:02,160 --> 00:07:07,039
allow us to do you can say

00:07:04,039 --> 00:07:08,800
reflex.get and spread the arguments

00:07:07,039 --> 00:07:10,720
and one one of those arguments that you

00:07:08,800 --> 00:07:12,800
can add is called receiver

00:07:10,720 --> 00:07:14,160
what's important about receiver is that

00:07:12,800 --> 00:07:17,120
it allows us to bind

00:07:14,160 --> 00:07:17,919
this properly that's important because

00:07:17,120 --> 00:07:20,160
in view

00:07:17,919 --> 00:07:22,319
we do a lot of binding of this we have

00:07:20,160 --> 00:07:24,800
to bind this appropriately

00:07:22,319 --> 00:07:26,160
in order for view to work under the hood

00:07:24,800 --> 00:07:29,360
so this is really nice

00:07:26,160 --> 00:07:30,000
because we have proper binding so now

00:07:29,360 --> 00:07:32,319
let's talk

00:07:30,000 --> 00:07:34,080
about what we might need here in order

00:07:32,319 --> 00:07:36,560
to make view reactive

00:07:34,080 --> 00:07:38,080
we mentioned that we might need to track

00:07:36,560 --> 00:07:39,039
some of those values so we need a

00:07:38,080 --> 00:07:41,440
function

00:07:39,039 --> 00:07:42,479
that will track any changes that occur

00:07:41,440 --> 00:07:44,560
with these objects

00:07:42,479 --> 00:07:45,680
with these properties and values which

00:07:44,560 --> 00:07:48,639
is called pre

00:07:45,680 --> 00:07:50,479
called track in uh view three and it

00:07:48,639 --> 00:07:53,120
saves any changes

00:07:50,479 --> 00:07:55,919
those changes that it saves are then

00:07:53,120 --> 00:07:55,919
called effects

00:07:56,240 --> 00:08:02,080
so now in our set method we

00:07:59,520 --> 00:08:03,280
are going to show all of the same things

00:08:02,080 --> 00:08:05,919
the target key

00:08:03,280 --> 00:08:07,039
but we are also passing in the value and

00:08:05,919 --> 00:08:10,000
we're returning

00:08:07,039 --> 00:08:11,280
that reflect of the set of all of those

00:08:10,000 --> 00:08:12,720
arguments

00:08:11,280 --> 00:08:14,800
but there's one last thing that we can

00:08:12,720 --> 00:08:15,599
do oh and this is called trigger in view

00:08:14,800 --> 00:08:18,400
so we're

00:08:15,599 --> 00:08:18,879
triggering we're running the changes

00:08:18,400 --> 00:08:21,599
that

00:08:18,879 --> 00:08:23,599
have to be updated and there's one thing

00:08:21,599 --> 00:08:25,599
that we want to do for efficiency

00:08:23,599 --> 00:08:27,440
we want to store the old value in the

00:08:25,599 --> 00:08:29,280
new value because we want to check if

00:08:27,440 --> 00:08:29,840
the old value is different from the new

00:08:29,280 --> 00:08:31,680
value

00:08:29,840 --> 00:08:33,279
and then run trigger because we don't

00:08:31,680 --> 00:08:35,120
necessarily want to run trigger every

00:08:33,279 --> 00:08:36,640
single time we only want to run it when

00:08:35,120 --> 00:08:40,479
something has changed

00:08:36,640 --> 00:08:42,000
cool so now remember this list

00:08:40,479 --> 00:08:44,480
this list is the list of things that

00:08:42,000 --> 00:08:46,720
we'd have to do to update those values

00:08:44,480 --> 00:08:48,000
automatically or with some reactive

00:08:46,720 --> 00:08:51,120
premises

00:08:48,000 --> 00:08:53,440
um so okay looking at this detect when

00:08:51,120 --> 00:08:55,120
there's a change in one of the values we

00:08:53,440 --> 00:08:56,959
no longer have to do this anymore

00:08:55,120 --> 00:08:58,080
because proxies is already doing this

00:08:56,959 --> 00:08:59,600
for us

00:08:58,080 --> 00:09:01,839
we're going to track the function that

00:08:59,600 --> 00:09:04,959
changes it and this is literally called

00:09:01,839 --> 00:09:06,560
track in view we're going to trigger

00:09:04,959 --> 00:09:08,000
the function so that it can update that

00:09:06,560 --> 00:09:10,480
final value and

00:09:08,000 --> 00:09:11,519
finally the function that changes it is

00:09:10,480 --> 00:09:12,959
called effect

00:09:11,519 --> 00:09:15,519
so if you need to find any of these

00:09:12,959 --> 00:09:17,680
methods the code base is here

00:09:15,519 --> 00:09:19,040
now you know in view two everything was

00:09:17,680 --> 00:09:21,519
one single package

00:09:19,040 --> 00:09:22,720
in view three we split it out into many

00:09:21,519 --> 00:09:25,600
many packages

00:09:22,720 --> 00:09:26,240
uh uh reactivity is now a package in and

00:09:25,600 --> 00:09:28,160
of itself

00:09:26,240 --> 00:09:29,839
so you can use that separately from all

00:09:28,160 --> 00:09:31,680
of the rest of you and you might ask

00:09:29,839 --> 00:09:34,000
like why is that necessary well

00:09:31,680 --> 00:09:36,000
let's say you were working with non-dom

00:09:34,000 --> 00:09:37,839
operations right there's a lot of

00:09:36,000 --> 00:09:39,120
stuff that vue does in order to work

00:09:37,839 --> 00:09:40,800
with the virtual dom

00:09:39,120 --> 00:09:42,480
that you don't necessarily need if

00:09:40,800 --> 00:09:44,800
you're working with electron or

00:09:42,480 --> 00:09:46,560
native development so that's a separate

00:09:44,800 --> 00:09:47,680
package so that you can code split and

00:09:46,560 --> 00:09:49,519
tree shake

00:09:47,680 --> 00:09:52,080
and all of the packages are separate now

00:09:49,519 --> 00:09:54,800
so you can have an extremely small

00:09:52,080 --> 00:09:56,480
build um if you'd like to check out any

00:09:54,800 --> 00:09:58,720
of the things that i mentioned before

00:09:56,480 --> 00:09:59,680
you can see them in this package in

00:09:58,720 --> 00:10:01,519
particular

00:09:59,680 --> 00:10:02,720
and if you wanted to look at them for

00:10:01,519 --> 00:10:05,360
just your life

00:10:02,720 --> 00:10:05,839
or any other curiosity reasons that's

00:10:05,360 --> 00:10:08,560
where there

00:10:05,839 --> 00:10:11,120
they are another thing is that proxies

00:10:08,560 --> 00:10:14,480
are now es6 previously it was

00:10:11,120 --> 00:10:15,680
es5 and below so object.define property

00:10:14,480 --> 00:10:18,959
was how we used

00:10:15,680 --> 00:10:22,079
uh view three so view our view too

00:10:18,959 --> 00:10:23,920
in view three we're using proxies um

00:10:22,079 --> 00:10:25,680
we are making a separate package that's

00:10:23,920 --> 00:10:26,560
a little bit bigger to support older

00:10:25,680 --> 00:10:29,600
browsers

00:10:26,560 --> 00:10:31,519
but this smaller build supports modern

00:10:29,600 --> 00:10:33,200
browsers and is

00:10:31,519 --> 00:10:35,040
really really a performance and

00:10:33,200 --> 00:10:35,839
efficient so you can check out all of

00:10:35,040 --> 00:10:39,680
that work

00:10:35,839 --> 00:10:41,839
in the view next repo cool

00:10:39,680 --> 00:10:42,959
so let's dig into how watchers work if

00:10:41,839 --> 00:10:44,640
you're familiar with vue

00:10:42,959 --> 00:10:46,720
you might know something about watchers

00:10:44,640 --> 00:10:49,440
watchers are a way to hook into some of

00:10:46,720 --> 00:10:53,200
that reactivity and adjust to changes

00:10:49,440 --> 00:10:53,680
so how do proxies relate to these final

00:10:53,200 --> 00:10:55,600
dom

00:10:53,680 --> 00:10:57,120
updates how do we hook into them with

00:10:55,600 --> 00:10:58,959
watchers

00:10:57,120 --> 00:11:00,320
so if you're not familiar with watchers

00:10:58,959 --> 00:11:02,399
here's how they work

00:11:00,320 --> 00:11:04,000
anytime we change this property you can

00:11:02,399 --> 00:11:06,160
see that we're watching

00:11:04,000 --> 00:11:08,560
the same data property as that counter

00:11:06,160 --> 00:11:10,640
so we've got the counter is zero

00:11:08,560 --> 00:11:12,640
and then we're watching the counter and

00:11:10,640 --> 00:11:13,360
we're logging the new value in the old

00:11:12,640 --> 00:11:15,440
value

00:11:13,360 --> 00:11:17,360
and if we increase it or decrease it you

00:11:15,440 --> 00:11:19,279
can see i'm watching that property

00:11:17,360 --> 00:11:22,320
anytime the property changes

00:11:19,279 --> 00:11:23,839
i can console log and i i can also do a

00:11:22,320 --> 00:11:26,399
ton of other things

00:11:23,839 --> 00:11:28,480
but it gives me access to the new and

00:11:26,399 --> 00:11:29,440
old versions of the value anytime

00:11:28,480 --> 00:11:32,399
something changes

00:11:29,440 --> 00:11:34,000
so how does this work in v3 before we

00:11:32,399 --> 00:11:36,240
dive into that concept

00:11:34,000 --> 00:11:37,920
there are a set of base concepts to

00:11:36,240 --> 00:11:40,959
understand get it set

00:11:37,920 --> 00:11:43,040
anyway in order to understand the

00:11:40,959 --> 00:11:45,519
in our workings we'll have to cover sets

00:11:43,040 --> 00:11:48,880
maps and weak maps

00:11:45,519 --> 00:11:49,920
a set is a series of only values similar

00:11:48,880 --> 00:11:51,760
to an array

00:11:49,920 --> 00:11:54,000
where a particular value can only be

00:11:51,760 --> 00:11:55,920
inserted once so what does that mean

00:11:54,000 --> 00:11:58,240
if you have something like my lunch

00:11:55,920 --> 00:11:59,360
items and you have this new set of taco

00:11:58,240 --> 00:12:02,000
burger taco

00:11:59,360 --> 00:12:03,760
and you console log my lunch items the

00:12:02,000 --> 00:12:06,079
set is really only gonna store

00:12:03,760 --> 00:12:07,680
the taco and the burger it's gonna throw

00:12:06,079 --> 00:12:09,120
out anything that's redundant so it's

00:12:07,680 --> 00:12:12,399
gonna throw out my other taco which is

00:12:09,120 --> 00:12:16,000
really sad i can only get that once

00:12:12,399 --> 00:12:18,079
a map is sort of like an object

00:12:16,000 --> 00:12:20,160
it's got some main differences but you

00:12:18,079 --> 00:12:22,720
can think of it similarly because a map

00:12:20,160 --> 00:12:24,800
is a series of keys and values

00:12:22,720 --> 00:12:26,399
but it has some key differences and it

00:12:24,800 --> 00:12:27,519
has actually a lot of differences but

00:12:26,399 --> 00:12:29,519
we're going to cover the ones that are

00:12:27,519 --> 00:12:31,360
really pertinent for view three

00:12:29,519 --> 00:12:34,079
key value pairs remember their explicit

00:12:31,360 --> 00:12:35,680
ordering it performs better in scenarios

00:12:34,079 --> 00:12:37,760
involving frequent additions and

00:12:35,680 --> 00:12:40,800
removals like set you can

00:12:37,760 --> 00:12:42,399
only add key value pairs once and it has

00:12:40,800 --> 00:12:47,040
some nice methods like

00:12:42,399 --> 00:12:48,800
size has set clear delete by the key

00:12:47,040 --> 00:12:50,959
this isn't all the things that are

00:12:48,800 --> 00:12:52,639
different different about maps than

00:12:50,959 --> 00:12:55,040
objects but we're covering the most

00:12:52,639 --> 00:12:58,560
crucial ones for our purposes

00:12:55,040 --> 00:13:00,800
so just like in set map

00:12:58,560 --> 00:13:02,720
in a new map in this example for a new

00:13:00,800 --> 00:13:05,440
map we can't

00:13:02,720 --> 00:13:06,800
keep the same key value pair twice right

00:13:05,440 --> 00:13:09,440
we saw that in set

00:13:06,800 --> 00:13:11,360
where if i have new map dot set lunch

00:13:09,440 --> 00:13:13,839
one is tacos lunch two

00:13:11,360 --> 00:13:14,800
is burgers but if i try to log another

00:13:13,839 --> 00:13:16,959
lunch one

00:13:14,800 --> 00:13:20,000
it will throw it away i get lunch one is

00:13:16,959 --> 00:13:22,720
tacos lunch two is burgers and that's it

00:13:20,000 --> 00:13:24,079
it doesn't add it again so the last

00:13:22,720 --> 00:13:24,399
thing that we're going to talk about is

00:13:24,079 --> 00:13:26,240
we

00:13:24,399 --> 00:13:27,760
weak map so it's similar to a map but

00:13:26,240 --> 00:13:29,920
the references are held

00:13:27,760 --> 00:13:32,000
weekly in other words if you delete

00:13:29,920 --> 00:13:34,240
something the reference can be garbage

00:13:32,000 --> 00:13:36,399
collected but in the map it can't

00:13:34,240 --> 00:13:38,399
so this also means that it loses the

00:13:36,399 --> 00:13:39,760
implicit ordering it also loses some of

00:13:38,399 --> 00:13:43,279
those nice methods like

00:13:39,760 --> 00:13:46,240
has delete by the key you know size

00:13:43,279 --> 00:13:48,320
and etc but the main difference about

00:13:46,240 --> 00:13:49,040
weak map that's really crucial to view

00:13:48,320 --> 00:13:52,320
three

00:13:49,040 --> 00:13:54,480
is garbage literally garbage

00:13:52,320 --> 00:13:55,920
but more like a happy kind of garbage

00:13:54,480 --> 00:13:58,399
because we like

00:13:55,920 --> 00:14:02,800
collecting garbage this makes view much

00:13:58,399 --> 00:14:05,519
faster and i'll show you why

00:14:02,800 --> 00:14:07,199
so if we have something like this object

00:14:05,519 --> 00:14:09,120
here

00:14:07,199 --> 00:14:11,120
when you pass an object to a view

00:14:09,120 --> 00:14:13,680
instance as data view converts it to a

00:14:11,120 --> 00:14:13,680
proxy

00:14:14,160 --> 00:14:17,360
this proxy enables you to perform

00:14:16,399 --> 00:14:19,040
dependency track

00:14:17,360 --> 00:14:20,399
tracking and change notification when

00:14:19,040 --> 00:14:22,560
proc pro

00:14:20,399 --> 00:14:24,320
properties are accessed there are two

00:14:22,560 --> 00:14:26,800
levels of dependencies for every

00:14:24,320 --> 00:14:26,800
component

00:14:27,040 --> 00:14:30,560
the first level uses map and stores the

00:14:29,040 --> 00:14:35,040
dependency for every

00:14:30,560 --> 00:14:36,560
property the second level uses set to

00:14:35,040 --> 00:14:39,440
track the effects that will be run when

00:14:36,560 --> 00:14:39,440
the values change

00:14:40,240 --> 00:14:43,839
after the first render we've tracked the

00:14:42,079 --> 00:14:46,560
list of dependencies in the property

00:14:43,839 --> 00:14:48,639
accessed during the render

00:14:46,560 --> 00:14:52,720
conversely the component becomes a

00:14:48,639 --> 00:14:52,720
subscriber to each of these properties

00:14:53,040 --> 00:14:57,600
when a proxy intercepts a set operation

00:14:55,440 --> 00:15:00,160
the property will notify all of the

00:14:57,600 --> 00:15:01,440
subscribers and the components we render

00:15:00,160 --> 00:15:04,000
view reactivity

00:15:01,440 --> 00:15:06,000
efficiently tracks all of the changes in

00:15:04,000 --> 00:15:08,079
that application

00:15:06,000 --> 00:15:09,680
cool so that was pretty high level if

00:15:08,079 --> 00:15:11,360
you'd like more information

00:15:09,680 --> 00:15:13,680
view mastery does a wonderful job of

00:15:11,360 --> 00:15:15,279
this uh they have a whole course on view

00:15:13,680 --> 00:15:18,480
through your reactivity that i

00:15:15,279 --> 00:15:20,079
uh suggest you try out okay on to the

00:15:18,480 --> 00:15:21,920
next we talked about reactivity and

00:15:20,079 --> 00:15:24,240
watchers but how do those properties

00:15:21,920 --> 00:15:25,120
actually change in the dom how are these

00:15:24,240 --> 00:15:27,680
properties getting

00:15:25,120 --> 00:15:28,160
reflected get it a little proxy joke in

00:15:27,680 --> 00:15:30,480
there

00:15:28,160 --> 00:15:32,480
in our interfaces okay so now let's

00:15:30,480 --> 00:15:32,959
cover how does the virtual dom actually

00:15:32,480 --> 00:15:34,720
work

00:15:32,959 --> 00:15:36,639
you might have heard this phrase before

00:15:34,720 --> 00:15:38,160
the virtual dom or the view dom

00:15:36,639 --> 00:15:39,680
it's a concept that many javascript

00:15:38,160 --> 00:15:41,040
frameworks use to create really

00:15:39,680 --> 00:15:44,480
performant api

00:15:41,040 --> 00:15:47,440
uh uis let's dig in

00:15:44,480 --> 00:15:47,440
so here's the dom

00:15:47,759 --> 00:15:52,240
we make a copy in javascript called the

00:15:49,519 --> 00:15:52,240
virtual dom

00:15:53,519 --> 00:15:58,320
we do this because touching the dom with

00:15:55,680 --> 00:16:00,079
javascript is computationally expensive

00:15:58,320 --> 00:16:01,920
while performing updates in javascript

00:16:00,079 --> 00:16:03,759
is cheap

00:16:01,920 --> 00:16:05,040
finding the required dom nodes and

00:16:03,759 --> 00:16:06,160
updating them with javascript is

00:16:05,040 --> 00:16:08,639
expensive

00:16:06,160 --> 00:16:11,040
so we batch calls and change the dom all

00:16:08,639 --> 00:16:11,040
at once

00:16:11,600 --> 00:16:14,959
the virtual dom is a lightweight

00:16:12,959 --> 00:16:16,480
javascript object created by this render

00:16:14,959 --> 00:16:18,800
function

00:16:16,480 --> 00:16:19,920
it takes three arguments the element the

00:16:18,800 --> 00:16:23,360
object with data

00:16:19,920 --> 00:16:24,800
props attributes and an array

00:16:23,360 --> 00:16:26,720
and the array is where we pass in

00:16:24,800 --> 00:16:27,920
children which all have these arguments

00:16:26,720 --> 00:16:30,959
too

00:16:27,920 --> 00:16:32,160
here's the text in the div and it's

00:16:30,959 --> 00:16:37,199
child the uh

00:16:32,160 --> 00:16:39,120
the ul and now in turn the allies

00:16:37,199 --> 00:16:41,120
if we need to update the list items we

00:16:39,120 --> 00:16:43,680
do so in javascript

00:16:41,120 --> 00:16:44,720
and only then do we update the actual

00:16:43,680 --> 00:16:46,399
dom

00:16:44,720 --> 00:16:50,240
the virtual dom allows us to make

00:16:46,399 --> 00:16:52,560
performant updates to our uis

00:16:50,240 --> 00:16:53,360
cool but what are the differences

00:16:52,560 --> 00:16:56,079
between

00:16:53,360 --> 00:16:57,839
the virtual dom and something like a

00:16:56,079 --> 00:16:58,480
server-side rendered application would

00:16:57,839 --> 00:17:01,920
say

00:16:58,480 --> 00:17:04,240
next or gridson let's cover that next

00:17:01,920 --> 00:17:05,120
so what one of the questions that i get

00:17:04,240 --> 00:17:07,520
frequently

00:17:05,120 --> 00:17:08,799
is what is hydration and when we're

00:17:07,520 --> 00:17:09,600
working with some of these meta

00:17:08,799 --> 00:17:11,839
frameworks

00:17:09,600 --> 00:17:12,720
it is done in a slightly different way

00:17:11,839 --> 00:17:15,039
so but

00:17:12,720 --> 00:17:15,919
before we talk about hydration i want to

00:17:15,039 --> 00:17:18,799
first cover

00:17:15,919 --> 00:17:20,160
why it's necessary so why something like

00:17:18,799 --> 00:17:21,839
jam stack

00:17:20,160 --> 00:17:23,520
with a client-side rendering solution

00:17:21,839 --> 00:17:25,039
the server delivers a file without

00:17:23,520 --> 00:17:26,240
content until you fetch everything in

00:17:25,039 --> 00:17:28,160
the browser compiles it

00:17:26,240 --> 00:17:29,600
and you're far away from that server the

00:17:28,160 --> 00:17:32,880
latency for the request

00:17:29,600 --> 00:17:34,720
gets bigger with older server side

00:17:32,880 --> 00:17:35,760
rendering solutions the server compiles

00:17:34,720 --> 00:17:37,679
and fetches everything

00:17:35,760 --> 00:17:39,039
builds the web page and delivers a fully

00:17:37,679 --> 00:17:42,640
populated html

00:17:39,039 --> 00:17:42,640
page that's much faster

00:17:43,600 --> 00:17:46,720
however every time you navigate to a new

00:17:45,360 --> 00:17:48,480
route the server has to do it all over

00:17:46,720 --> 00:17:49,200
again it has to compile infect it and

00:17:48,480 --> 00:17:51,039
deliver it

00:17:49,200 --> 00:17:54,000
this process delays the load sometimes

00:17:51,039 --> 00:17:54,000
by whole seconds

00:17:55,520 --> 00:17:58,880
recently an approach called jamstack has

00:17:57,280 --> 00:17:59,360
become popular which addresses both

00:17:58,880 --> 00:18:00,880
issues

00:17:59,360 --> 00:18:02,880
we build the whole site and deploy the

00:18:00,880 --> 00:18:04,640
content to cdns which means it's

00:18:02,880 --> 00:18:06,320
geo-replicated around the globe

00:18:04,640 --> 00:18:07,840
we never go back to a server on

00:18:06,320 --> 00:18:09,600
additional requests

00:18:07,840 --> 00:18:11,440
we call it jam stack and not static

00:18:09,600 --> 00:18:13,600
because it extends beyond static

00:18:11,440 --> 00:18:15,600
we can make the page dynamic with api

00:18:13,600 --> 00:18:19,280
calls or server list functions

00:18:15,600 --> 00:18:21,440
and the user can use it right away

00:18:19,280 --> 00:18:23,280
what's more because there's no server

00:18:21,440 --> 00:18:25,919
involved there are fewer attack

00:18:23,280 --> 00:18:29,840
vectors that makes jam stack really

00:18:25,919 --> 00:18:29,840
performant and secure

00:18:30,160 --> 00:18:36,160
so when we're using jam sac premises

00:18:33,679 --> 00:18:37,360
and also things like next and grid some

00:18:36,160 --> 00:18:39,919
that are pre-rendered

00:18:37,360 --> 00:18:42,160
not only are we having a single point of

00:18:39,919 --> 00:18:43,600
uh not only are we not having a single

00:18:42,160 --> 00:18:45,039
point of origin server

00:18:43,600 --> 00:18:46,720
we don't have to make subsequent

00:18:45,039 --> 00:18:48,240
requests and it has

00:18:46,720 --> 00:18:50,240
better security because we don't have

00:18:48,240 --> 00:18:53,840
access to that single point of origin

00:18:50,240 --> 00:18:55,760
in the server so that in turn

00:18:53,840 --> 00:18:57,919
gives us amazing performance and better

00:18:55,760 --> 00:19:00,000
security so

00:18:57,919 --> 00:19:01,600
if it's statically rendered here's the

00:19:00,000 --> 00:19:04,000
part where i get that question

00:19:01,600 --> 00:19:05,600
about that hydration right if it's

00:19:04,000 --> 00:19:06,880
statically rendered and everything is

00:19:05,600 --> 00:19:08,640
rendered on the page

00:19:06,880 --> 00:19:11,520
how do you actually interact with it and

00:19:08,640 --> 00:19:13,440
that's where hydration comes in

00:19:11,520 --> 00:19:17,280
it can speed up performance to initially

00:19:13,440 --> 00:19:18,960
serve raw html and css

00:19:17,280 --> 00:19:22,320
we can do this by server-side rendering

00:19:18,960 --> 00:19:23,919
an app and delivering it statically

00:19:22,320 --> 00:19:25,760
after it's been served view needs to

00:19:23,919 --> 00:19:27,120
take over some of the elements that are

00:19:25,760 --> 00:19:30,320
dynamic

00:19:27,120 --> 00:19:30,320
this is called hydration

00:19:31,520 --> 00:19:34,960
so since the market markup has been

00:19:33,360 --> 00:19:36,559
rendered we don't throw it away and

00:19:34,960 --> 00:19:38,799
recreate recreate it

00:19:36,559 --> 00:19:40,720
instead we want to hydrate the dom just

00:19:38,799 --> 00:19:41,919
the pieces that are interactive and make

00:19:40,720 --> 00:19:43,520
those interactive

00:19:41,919 --> 00:19:46,080
here the button can now respond to

00:19:43,520 --> 00:19:48,400
changes and we can add to the cart

00:19:46,080 --> 00:19:49,520
and hydration allows us to create fast

00:19:48,400 --> 00:19:52,559
and secure sites

00:19:49,520 --> 00:19:54,799
and still have a reactive ui

00:19:52,559 --> 00:19:56,240
cool so with this these approaches we

00:19:54,799 --> 00:19:58,240
can pre-build and pre-render our

00:19:56,240 --> 00:19:59,840
applications while still serving dynamic

00:19:58,240 --> 00:20:03,039
content

00:19:59,840 --> 00:20:06,240
we learned a lot in what 20 minutes

00:20:03,039 --> 00:20:08,559
we covered how reactivity works how view

00:20:06,240 --> 00:20:11,039
three uses proxies how watchers work in

00:20:08,559 --> 00:20:12,960
view three how the virtual dom works in

00:20:11,039 --> 00:20:14,960
view three and how and why next and

00:20:12,960 --> 00:20:16,240
gridson are you using pre-rendered

00:20:14,960 --> 00:20:18,799
content and how they then

00:20:16,240 --> 00:20:20,559
hydrate the dom that's fantastic we now

00:20:18,799 --> 00:20:21,200
know so much and our boundaries are

00:20:20,559 --> 00:20:23,120
endless

00:20:21,200 --> 00:20:24,720
so if you ever need to access these

00:20:23,120 --> 00:20:26,720
materials to review

00:20:24,720 --> 00:20:28,640
all of the materials are open source on

00:20:26,720 --> 00:20:30,799
my github at this url

00:20:28,640 --> 00:20:31,679
and all of the slides and the code pens

00:20:30,799 --> 00:20:33,200
so that you can

00:20:31,679 --> 00:20:35,760
explore all of the code and all of the

00:20:33,200 --> 00:20:37,360
animations but they are also in the view

00:20:35,760 --> 00:20:37,760
docs i mentioned i'm on the view core

00:20:37,360 --> 00:20:40,240
team

00:20:37,760 --> 00:20:41,280
so all of this explanation also lists

00:20:40,240 --> 00:20:44,159
lives in the new

00:20:41,280 --> 00:20:46,320
reactivity system are in the reactivity

00:20:44,159 --> 00:20:47,200
section of our brand new documentation

00:20:46,320 --> 00:20:50,080
for the view

00:20:47,200 --> 00:20:52,000
docs so now can you not only build

00:20:50,080 --> 00:20:52,720
performant and beautiful experiences on

00:20:52,000 --> 00:20:54,960
the web

00:20:52,720 --> 00:20:56,720
you understand how all of these reactive

00:20:54,960 --> 00:20:58,159
premises and concepts are helping keep

00:20:56,720 --> 00:21:00,799
your users focus

00:20:58,159 --> 00:21:01,679
on task and enabling them to have

00:21:00,799 --> 00:21:03,120
superpowers

00:21:01,679 --> 00:21:05,440
while they're enabling well while

00:21:03,120 --> 00:21:14,000
they're traversing your application

00:21:05,440 --> 00:21:14,000

YouTube URL: https://www.youtube.com/watch?v=5TESsWA6xXM


