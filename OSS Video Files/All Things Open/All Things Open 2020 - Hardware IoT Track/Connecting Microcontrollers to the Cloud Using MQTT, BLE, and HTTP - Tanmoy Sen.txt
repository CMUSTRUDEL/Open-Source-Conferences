Title: Connecting Microcontrollers to the Cloud Using MQTT, BLE, and HTTP - Tanmoy Sen
Publication date: 2020-12-17
Playlist: All Things Open 2020 - Hardware IoT Track
Description: 
	Presented by: Tanmoy Sen, Amazon Web Services
Presented at All Things Open 2020 - Hardware/IoT Track

Abstract: Connecting microcontroller-based devices to the cloud enables data collection, analysis and remote updates to deployed devices. Often, these devices need to cost-effectively connect to a mobile device for provisioning, reading, and security. This talk describes how to easily program, deploy, secure, connect, and manage small, low-power edge devices with the open source real-time OS, FreeRTOS, using different connectivity protocols. You learn how to authenticate microcontroller devices with iOS and Android devices and to monitor, manage, and update firmware using the over-the-air update functionality.
Captions: 
	00:00:05,279 --> 00:00:08,800
uh good morning everyone

00:00:06,720 --> 00:00:10,080
um thank you for thank you so much for

00:00:08,800 --> 00:00:12,160
joining this session on connecting

00:00:10,080 --> 00:00:14,960
microcontrollers to the cloud

00:00:12,160 --> 00:00:16,240
um i'm done myself i'm a product manager

00:00:14,960 --> 00:00:19,279
in aws

00:00:16,240 --> 00:00:21,119
amazon web services and i focus on

00:00:19,279 --> 00:00:22,880
edge devices device software for the

00:00:21,119 --> 00:00:25,199
edge i'm talking about microcontrollers

00:00:22,880 --> 00:00:28,320
microprocessors

00:00:25,199 --> 00:00:30,160
so within the aws iit org there's this

00:00:28,320 --> 00:00:32,559
this is there are two products uh

00:00:30,160 --> 00:00:35,600
embedded csdk and freertos

00:00:32,559 --> 00:00:38,719
and i work on on the roadmapping and um

00:00:35,600 --> 00:00:39,760
and features for for both of them but

00:00:38,719 --> 00:00:41,200
anyways um

00:00:39,760 --> 00:00:42,960
my talk is about connecting

00:00:41,200 --> 00:00:45,600
microcontrollers to the cloud and i'm

00:00:42,960 --> 00:00:47,440
going to discuss the various aspects of

00:00:45,600 --> 00:00:49,200
of connecting these these really

00:00:47,440 --> 00:00:52,239
constrained devices to

00:00:49,200 --> 00:00:55,120
to the cloud uh how do we do it um

00:00:52,239 --> 00:00:56,719
and what are the various aspects of of

00:00:55,120 --> 00:00:59,600
connecting these

00:00:56,719 --> 00:01:00,239
these using protocols such as mqtt or

00:00:59,600 --> 00:01:02,320
http

00:01:00,239 --> 00:01:03,600
the application layer protocols are

00:01:02,320 --> 00:01:06,159
bluetooth low energy

00:01:03,600 --> 00:01:07,920
um which is again a very popular uh

00:01:06,159 --> 00:01:13,840
popular transport protocol for

00:01:07,920 --> 00:01:13,840
for low power devices

00:01:15,759 --> 00:01:20,159
before i dive into the connectivity

00:01:17,360 --> 00:01:22,880
protocols um i'll briefly talk about

00:01:20,159 --> 00:01:24,640
um talk about the key attributes of

00:01:22,880 --> 00:01:25,520
connecting these microcontrollers to the

00:01:24,640 --> 00:01:27,759
cloud

00:01:25,520 --> 00:01:28,960
what are what are microcontrollers and

00:01:27,759 --> 00:01:32,079
then i'm going to talk about

00:01:28,960 --> 00:01:34,079
how um even when we when we connect

00:01:32,079 --> 00:01:35,600
these devices to the cloud how do

00:01:34,079 --> 00:01:38,079
microcontrollers and the iot

00:01:35,600 --> 00:01:38,799
applications in general benefit from the

00:01:38,079 --> 00:01:39,920
cloud

00:01:38,799 --> 00:01:42,000
then i'm going to talk about the

00:01:39,920 --> 00:01:43,280
connecting uh connectivity aspects of

00:01:42,000 --> 00:01:46,320
these um

00:01:43,280 --> 00:01:47,920
of the um of microcontrollers using hdb

00:01:46,320 --> 00:01:50,799
mqtt and ble

00:01:47,920 --> 00:01:52,799
and then um towards the end there's an

00:01:50,799 --> 00:01:54,560
important feature for iot devices all

00:01:52,799 --> 00:01:56,560
iot devices they need update

00:01:54,560 --> 00:01:58,399
updateability of the firmware so i'm

00:01:56,560 --> 00:01:59,439
going to talk about over-the-air updates

00:01:58,399 --> 00:02:02,399
and how it's done

00:01:59,439 --> 00:02:04,479
um within within aws iot and the feature

00:02:02,399 --> 00:02:09,360
that we have developed

00:02:04,479 --> 00:02:11,200
so um let's let's dive in

00:02:09,360 --> 00:02:13,120
what are microcontrollers

00:02:11,200 --> 00:02:15,120
microcontrollers are

00:02:13,120 --> 00:02:16,720
integrated circuits with a small

00:02:15,120 --> 00:02:18,959
processor performing

00:02:16,720 --> 00:02:21,120
perform very simple tasks and very

00:02:18,959 --> 00:02:22,080
specific tasks like reading sensor data

00:02:21,120 --> 00:02:24,000
crunching numbers

00:02:22,080 --> 00:02:25,200
and sending it ahead for future

00:02:24,000 --> 00:02:27,200
processing

00:02:25,200 --> 00:02:28,400
these are very constrained devices we

00:02:27,200 --> 00:02:30,319
are talking about

00:02:28,400 --> 00:02:32,480
megahertz in compute speed early

00:02:30,319 --> 00:02:33,440
megahertz of compute speed clock

00:02:32,480 --> 00:02:35,440
frequency

00:02:33,440 --> 00:02:36,959
and kilobytes of ram just to give and

00:02:35,440 --> 00:02:38,879
give you an idea of scale

00:02:36,959 --> 00:02:40,560
because most of the times we are we are

00:02:38,879 --> 00:02:41,360
acquainted with application processors

00:02:40,560 --> 00:02:43,280
running

00:02:41,360 --> 00:02:44,480
gigahertz of clock frequency and

00:02:43,280 --> 00:02:47,120
megabytes um

00:02:44,480 --> 00:02:48,080
and much more and higher of ram and

00:02:47,120 --> 00:02:50,560
flash

00:02:48,080 --> 00:02:52,400
so these are very constraint devices and

00:02:50,560 --> 00:02:54,560
because of the specificity and

00:02:52,400 --> 00:02:56,160
simplicity of these microcontrollers

00:02:54,560 --> 00:02:57,519
they're really pertinent for iot

00:02:56,160 --> 00:03:00,080
applications

00:02:57,519 --> 00:03:02,720
and designs looking for very low power

00:03:00,080 --> 00:03:02,720
applications

00:03:03,760 --> 00:03:09,120
but these microcontrollers are part

00:03:06,800 --> 00:03:11,280
of of the things in the interior of

00:03:09,120 --> 00:03:13,040
things when we call iotr internal

00:03:11,280 --> 00:03:14,640
things these microcontrollers become a

00:03:13,040 --> 00:03:17,200
huge part of that

00:03:14,640 --> 00:03:18,239
and these these can can be found in

00:03:17,200 --> 00:03:19,920
everyday devices

00:03:18,239 --> 00:03:21,920
everywhere in all industrial verticals

00:03:19,920 --> 00:03:24,480
you think about fitness trackers

00:03:21,920 --> 00:03:27,200
you think about industrial applications

00:03:24,480 --> 00:03:29,360
vehicle automation

00:03:27,200 --> 00:03:30,480
think about medical medical equipment

00:03:29,360 --> 00:03:32,560
asset tracking

00:03:30,480 --> 00:03:34,159
just name a few you whenever you find a

00:03:32,560 --> 00:03:36,000
sensor on an actuator

00:03:34,159 --> 00:03:37,680
you'll see microcontrollers attached to

00:03:36,000 --> 00:03:39,280
it and sending data and number crunching

00:03:37,680 --> 00:03:41,040
numbers

00:03:39,280 --> 00:03:42,480
they're sold in billions of units every

00:03:41,040 --> 00:03:43,519
year because of the simplicity as a

00:03:42,480 --> 00:03:45,200
specificity

00:03:43,519 --> 00:03:47,360
we use several microcontrollers to

00:03:45,200 --> 00:03:50,720
perform one one single application

00:03:47,360 --> 00:03:53,360
so you can find several microcontrollers

00:03:50,720 --> 00:03:54,959
in um in one application and therefore

00:03:53,360 --> 00:03:56,640
they are sold in billions of units every

00:03:54,959 --> 00:03:57,920
year

00:03:56,640 --> 00:04:00,080
but microcontrollers are very

00:03:57,920 --> 00:04:02,000
constrained devices and

00:04:00,080 --> 00:04:05,760
and that's why they greatly benefit from

00:04:02,000 --> 00:04:05,760
connecting to the resource rich cloud

00:04:06,560 --> 00:04:10,959
now when when you talk about connecting

00:04:08,879 --> 00:04:11,519
these microcontrollers to the cloud you

00:04:10,959 --> 00:04:13,680
see

00:04:11,519 --> 00:04:16,000
um where they like at the bottom of the

00:04:13,680 --> 00:04:19,040
screen that you see uh bottom and left

00:04:16,000 --> 00:04:22,400
you'll see microcontroller devices um

00:04:19,040 --> 00:04:26,160
um in in in several applications like

00:04:22,400 --> 00:04:29,199
um like fans uh

00:04:26,160 --> 00:04:32,080
like windmills or uh

00:04:29,199 --> 00:04:33,759
water faucets uh automotive applications

00:04:32,080 --> 00:04:34,320
they either connect directly to the

00:04:33,759 --> 00:04:36,880
cloud

00:04:34,320 --> 00:04:37,600
maybe using uh protocols such as wi-fi

00:04:36,880 --> 00:04:39,840
or

00:04:37,600 --> 00:04:41,600
cellular or through a more powerful

00:04:39,840 --> 00:04:42,160
gateway device you could think of an

00:04:41,600 --> 00:04:44,880
application

00:04:42,160 --> 00:04:46,080
processor collecting acting as a hub and

00:04:44,880 --> 00:04:47,840
collecting data

00:04:46,080 --> 00:04:49,280
aggregating data from all the

00:04:47,840 --> 00:04:50,720
microcontrollers that are connected to

00:04:49,280 --> 00:04:53,520
it

00:04:50,720 --> 00:04:54,479
but as more and more devices connect to

00:04:53,520 --> 00:04:56,400
the cloud

00:04:54,479 --> 00:04:58,400
and send data to the cloud the cloud

00:04:56,400 --> 00:05:00,160
enables us to do several things

00:04:58,400 --> 00:05:02,560
they securely manage they securely

00:05:00,160 --> 00:05:03,039
connect these uh manage these devices at

00:05:02,560 --> 00:05:05,840
scale

00:05:03,039 --> 00:05:07,360
so that they connect to a broker and

00:05:05,840 --> 00:05:09,120
millions of microcontrollers sending

00:05:07,360 --> 00:05:10,000
millions and millions of kilobytes of

00:05:09,120 --> 00:05:13,120
data

00:05:10,000 --> 00:05:14,000
can uh can effectively be managed at

00:05:13,120 --> 00:05:16,960
scale

00:05:14,000 --> 00:05:19,280
you also on board these devices manage

00:05:16,960 --> 00:05:20,880
these devices and do firmware updates on

00:05:19,280 --> 00:05:22,400
the fleet of devices that are deployed

00:05:20,880 --> 00:05:24,560
in the field

00:05:22,400 --> 00:05:26,240
so um the cloud becomes an important

00:05:24,560 --> 00:05:27,600
aspect at that too

00:05:26,240 --> 00:05:29,039
when you have several hundreds of

00:05:27,600 --> 00:05:30,160
thousands of millions of devices

00:05:29,039 --> 00:05:32,320
deployed in the field

00:05:30,160 --> 00:05:33,680
you need to audit these devices and

00:05:32,320 --> 00:05:35,600
detect anomalies

00:05:33,680 --> 00:05:37,600
uh if you see any security vulnerability

00:05:35,600 --> 00:05:39,120
for any of the of the devices or the

00:05:37,600 --> 00:05:40,960
devices are sending um

00:05:39,120 --> 00:05:42,960
packets that that you think are

00:05:40,960 --> 00:05:44,720
anomalous then you have

00:05:42,960 --> 00:05:46,000
that you can they didn't detect these

00:05:44,720 --> 00:05:49,120
and perform um

00:05:46,000 --> 00:05:52,000
perform right actions needed for those

00:05:49,120 --> 00:05:53,280
and further down further down the um the

00:05:52,000 --> 00:05:54,880
the cloud path

00:05:53,280 --> 00:05:56,400
you see that you can perform data

00:05:54,880 --> 00:05:58,720
analytics and

00:05:56,400 --> 00:05:59,440
and and finally the most important thing

00:05:58,720 --> 00:06:02,000
is that you can

00:05:59,440 --> 00:06:04,960
fully integrate with other other aws

00:06:02,000 --> 00:06:08,160
services or other cloud services like uh

00:06:04,960 --> 00:06:09,199
like a simple storage service amazon s3

00:06:08,160 --> 00:06:11,199
or ec2

00:06:09,199 --> 00:06:12,319
those are aws services that you can use

00:06:11,199 --> 00:06:16,160
um while

00:06:12,319 --> 00:06:16,160
when you connect to the iot broker

00:06:16,560 --> 00:06:20,240
however connecting microcontrollers to

00:06:19,120 --> 00:06:22,240
the cloud takes

00:06:20,240 --> 00:06:24,400
careful design considerations both on

00:06:22,240 --> 00:06:27,120
the device side and the cloud side

00:06:24,400 --> 00:06:29,039
um let me let me try to understand um

00:06:27,120 --> 00:06:31,120
make you understand this by taking a

00:06:29,039 --> 00:06:34,479
very simple example the example of a

00:06:31,120 --> 00:06:35,360
of a light bulb the block diagram on the

00:06:34,479 --> 00:06:37,919
right that you see

00:06:35,360 --> 00:06:39,919
is is a representation of a program

00:06:37,919 --> 00:06:42,960
space of microcontroller

00:06:39,919 --> 00:06:45,919
the um the functionality the green

00:06:42,960 --> 00:06:47,280
box that you see in the bc below is

00:06:45,919 --> 00:06:49,680
basically

00:06:47,280 --> 00:06:50,560
um just the the functionality the

00:06:49,680 --> 00:06:52,960
business value

00:06:50,560 --> 00:06:54,080
that that um any device performs you

00:06:52,960 --> 00:06:55,919
could think of

00:06:54,080 --> 00:06:57,599
dimming the light bulb turning it on and

00:06:55,919 --> 00:06:58,960
off at certain instances you can change

00:06:57,599 --> 00:07:01,120
the color of the light bulbs

00:06:58,960 --> 00:07:02,240
so so this is the business value of any

00:07:01,120 --> 00:07:04,960
simple light bulb

00:07:02,240 --> 00:07:06,479
but that is a small piece of code but

00:07:04,960 --> 00:07:07,599
but when you are thinking of connecting

00:07:06,479 --> 00:07:09,919
this light bulb to

00:07:07,599 --> 00:07:11,520
to the internet uh to the cloud you are

00:07:09,919 --> 00:07:12,000
basically thinking of adding several

00:07:11,520 --> 00:07:15,199
things

00:07:12,000 --> 00:07:16,319
connect communication stack um for for

00:07:15,199 --> 00:07:18,880
connectivity

00:07:16,319 --> 00:07:20,639
security libraries management of these

00:07:18,880 --> 00:07:21,039
um of these devices deployed in the

00:07:20,639 --> 00:07:23,919
field

00:07:21,039 --> 00:07:25,680
security over the air updates so we are

00:07:23,919 --> 00:07:26,000
talking about several libraries that is

00:07:25,680 --> 00:07:27,680
just

00:07:26,000 --> 00:07:29,840
attached to to the business

00:07:27,680 --> 00:07:31,919
functionality the small piece of code

00:07:29,840 --> 00:07:33,120
and this is completely undifferentiated

00:07:31,919 --> 00:07:34,800
that you have to write and stitch

00:07:33,120 --> 00:07:37,520
together to securely connect your light

00:07:34,800 --> 00:07:37,520
bulb to the cloud

00:07:38,000 --> 00:07:42,160
and that's where open source libraries

00:07:40,479 --> 00:07:44,080
such as friatas

00:07:42,160 --> 00:07:45,440
can help you reduce the pain point help

00:07:44,080 --> 00:07:47,680
you reduce the effort

00:07:45,440 --> 00:07:50,800
in connecting these microcontrollers to

00:07:47,680 --> 00:07:52,560
your controller devices to the cloud

00:07:50,800 --> 00:07:55,120
it provides everything that you need for

00:07:52,560 --> 00:07:58,160
connectivity and security and updates

00:07:55,120 --> 00:08:01,039
so um we we think about

00:07:58,160 --> 00:08:02,720
the friatas kernel friata's cuddle is a

00:08:01,039 --> 00:08:04,639
market leading real-time operating

00:08:02,720 --> 00:08:05,440
system for microcontrollers can be used

00:08:04,639 --> 00:08:08,319
for

00:08:05,440 --> 00:08:08,960
disconnected smart devices but can also

00:08:08,319 --> 00:08:11,520
be

00:08:08,960 --> 00:08:14,000
can use can be used as a foundation for

00:08:11,520 --> 00:08:15,440
internet connectivity

00:08:14,000 --> 00:08:17,440
and there are other software libraries

00:08:15,440 --> 00:08:19,840
like bluetooth low energy the

00:08:17,440 --> 00:08:21,919
abstraction stack for local connectivity

00:08:19,840 --> 00:08:24,000
uh cloud connectivity you can think of

00:08:21,919 --> 00:08:25,599
mqtt and http as the application layer

00:08:24,000 --> 00:08:28,639
protocol to connect to

00:08:25,599 --> 00:08:29,440
connect to any cloud and security

00:08:28,639 --> 00:08:31,520
libraries and

00:08:29,440 --> 00:08:33,519
for security i'm talking about data at

00:08:31,520 --> 00:08:35,440
rest and data in transit

00:08:33,519 --> 00:08:36,560
so you need security in both aspects

00:08:35,440 --> 00:08:38,159
because whenever your

00:08:36,560 --> 00:08:40,560
certificates and credentials are stored

00:08:38,159 --> 00:08:42,640
on device you need security for those

00:08:40,560 --> 00:08:43,919
and when data is sent from the device

00:08:42,640 --> 00:08:45,680
back to the cloud

00:08:43,919 --> 00:08:47,360
you need that to be encrypted and

00:08:45,680 --> 00:08:50,560
secured and authenticated when it

00:08:47,360 --> 00:08:52,399
reaches the mqtt broker for example

00:08:50,560 --> 00:08:54,000
and apart from the libraries you you

00:08:52,399 --> 00:08:56,080
have to have security

00:08:54,000 --> 00:08:57,839
for the entire device life cycle and

00:08:56,080 --> 00:09:01,680
that's where over-the-air updates

00:08:57,839 --> 00:09:03,120
or um or updatability of these devices

00:09:01,680 --> 00:09:05,920
become really important

00:09:03,120 --> 00:09:06,959
and with friata's we have we have a

00:09:05,920 --> 00:09:09,519
feature an integer

00:09:06,959 --> 00:09:11,600
integrated service that helps you deploy

00:09:09,519 --> 00:09:14,640
security um security fixes

00:09:11,600 --> 00:09:16,000
bug fixes and firmware updates directly

00:09:14,640 --> 00:09:19,920
to the devices on the field

00:09:16,000 --> 00:09:19,920
um and and that too remotely

00:09:20,800 --> 00:09:24,240
all friata's libraries are are open

00:09:23,600 --> 00:09:26,880
source

00:09:24,240 --> 00:09:27,760
and they are under the permissive mit

00:09:26,880 --> 00:09:29,680
license

00:09:27,760 --> 00:09:30,880
so you have the flexibility to change

00:09:29,680 --> 00:09:33,360
these libraries

00:09:30,880 --> 00:09:35,040
to to to suit your end application

00:09:33,360 --> 00:09:36,880
whatever application that you design

00:09:35,040 --> 00:09:39,279
you don't need to report any anywhere

00:09:36,880 --> 00:09:41,920
you need to follow pay pay it forward

00:09:39,279 --> 00:09:42,320
just use the libraries um however you

00:09:41,920 --> 00:09:45,279
see

00:09:42,320 --> 00:09:45,680
um see fit and you can customize it to

00:09:45,279 --> 00:09:50,000
your

00:09:45,680 --> 00:09:53,440
end application

00:09:50,000 --> 00:09:55,519
now let's talk about um mqtt as one of

00:09:53,440 --> 00:09:57,040
the connectivity protocols and

00:09:55,519 --> 00:09:58,560
one of the libraries that friatas

00:09:57,040 --> 00:10:01,680
provides as open source

00:09:58,560 --> 00:10:01,680
or cloud connectivity

00:10:01,760 --> 00:10:05,600
mqtt is based on the oss standard oss

00:10:04,399 --> 00:10:07,839
open standard

00:10:05,600 --> 00:10:08,880
and mqtt is a lightweight publish

00:10:07,839 --> 00:10:11,279
subscribe

00:10:08,880 --> 00:10:13,680
application layer protocol that runs on

00:10:11,279 --> 00:10:16,560
top of tcp

00:10:13,680 --> 00:10:17,680
it has a very small code and bandwidth

00:10:16,560 --> 00:10:19,760
requirements

00:10:17,680 --> 00:10:21,519
that is devices can sleep most of the

00:10:19,760 --> 00:10:22,880
time in most of the use cases and wake

00:10:21,519 --> 00:10:26,720
up only to send data

00:10:22,880 --> 00:10:28,720
um send data to um to a topic which is

00:10:26,720 --> 00:10:31,519
which it is subscribed to which makes

00:10:28,720 --> 00:10:33,680
mqtt very suitable for iot applications

00:10:31,519 --> 00:10:35,680
because it gives you scale and it

00:10:33,680 --> 00:10:37,519
buttons to constrain microcontroller

00:10:35,680 --> 00:10:40,640
devices

00:10:37,519 --> 00:10:42,800
it uses a concept of topic topic as a

00:10:40,640 --> 00:10:44,880
matching mechanism between publishers

00:10:42,800 --> 00:10:46,880
and subscribers so publishers are

00:10:44,880 --> 00:10:48,880
basically that publish

00:10:46,880 --> 00:10:50,720
data to a topic and subscribers are

00:10:48,880 --> 00:10:52,880
basically um

00:10:50,720 --> 00:10:55,519
clients that are listening to a topic

00:10:52,880 --> 00:10:58,560
and see what data has been published

00:10:55,519 --> 00:11:00,480
publishers and subscribers are two

00:10:58,560 --> 00:11:02,399
um at the two ends and they can

00:11:00,480 --> 00:11:05,200
communicate in several ways

00:11:02,399 --> 00:11:05,680
for example is a point-to-point pattern

00:11:05,200 --> 00:11:09,040
um

00:11:05,680 --> 00:11:12,320
a point-to-point pattern is when

00:11:09,040 --> 00:11:14,720
two things use a single mqtt topic

00:11:12,320 --> 00:11:15,680
as the communication channel so they use

00:11:14,720 --> 00:11:18,160
a single topic

00:11:15,680 --> 00:11:19,279
the publisher subscribes the button in

00:11:18,160 --> 00:11:20,959
data to the topic

00:11:19,279 --> 00:11:22,720
and the subscriber listens to it and

00:11:20,959 --> 00:11:24,880
takes action based on that

00:11:22,720 --> 00:11:26,160
the second is a broadcast pattern

00:11:24,880 --> 00:11:29,040
broadcast pattern is

00:11:26,160 --> 00:11:30,399
when a single publisher sends out the

00:11:29,040 --> 00:11:32,640
same message

00:11:30,399 --> 00:11:34,399
to all the subscribers all the clients

00:11:32,640 --> 00:11:36,959
that are subscribed to the topic

00:11:34,399 --> 00:11:39,040
for example a weather station

00:11:36,959 --> 00:11:41,360
transmitting a broadcast message

00:11:39,040 --> 00:11:43,200
to all the buses in the engineer area

00:11:41,360 --> 00:11:46,560
all the buses can listen to the packet

00:11:43,200 --> 00:11:48,160
um to do the message say it's really

00:11:46,560 --> 00:11:50,320
windy or it's really cold and take

00:11:48,160 --> 00:11:52,639
actions based on that

00:11:50,320 --> 00:11:53,519
the third is the fan and pattern fan and

00:11:52,639 --> 00:11:56,240
pattern is the

00:11:53,519 --> 00:11:58,000
exact reverse of the broadcast pattern

00:11:56,240 --> 00:12:01,040
where several publishers

00:11:58,000 --> 00:12:02,959
um send data to a single topic and one

00:12:01,040 --> 00:12:05,120
subscriber is listening to it

00:12:02,959 --> 00:12:06,720
and this is really useful for use cases

00:12:05,120 --> 00:12:08,639
such as

00:12:06,720 --> 00:12:10,000
you can you can think of robotic arms

00:12:08,639 --> 00:12:13,600
sending health status

00:12:10,000 --> 00:12:15,279
regularly to the same topic and the iot

00:12:13,600 --> 00:12:15,920
application the subscribe and listening

00:12:15,279 --> 00:12:18,399
to it

00:12:15,920 --> 00:12:19,120
aggregates it and the aggregate data

00:12:18,399 --> 00:12:21,279
makes sense

00:12:19,120 --> 00:12:24,240
makes application more more pertinent

00:12:21,279 --> 00:12:27,360
and unreliable

00:12:24,240 --> 00:12:29,040
so these these are the three um three

00:12:27,360 --> 00:12:32,160
communication patterns that

00:12:29,040 --> 00:12:36,560
that is mostly seen for iot devices

00:12:32,160 --> 00:12:39,200
um but let's dive

00:12:36,560 --> 00:12:40,639
into one of the uh use cases on a

00:12:39,200 --> 00:12:42,320
point-to-point pattern or a

00:12:40,639 --> 00:12:44,560
point-to-point communication aspect

00:12:42,320 --> 00:12:46,880
the diagram that you see on the right is

00:12:44,560 --> 00:12:48,800
is let's take an example of that

00:12:46,880 --> 00:12:50,000
the repair service that you can see as

00:12:48,800 --> 00:12:52,720
the publisher

00:12:50,000 --> 00:12:54,320
is basically sending um sending status

00:12:52,720 --> 00:12:57,360
data shipment data

00:12:54,320 --> 00:13:00,480
of uh refills to the topic

00:12:57,360 --> 00:13:02,560
um uh to the topic refill

00:13:00,480 --> 00:13:04,000
and then there are two um washing

00:13:02,560 --> 00:13:07,040
machines connected to it as

00:13:04,000 --> 00:13:11,440
as subscribers listening to it

00:13:07,040 --> 00:13:14,560
and the washing machine on top sees that

00:13:11,440 --> 00:13:15,839
the status is it has been shipped

00:13:14,560 --> 00:13:18,240
while the shipment data has been

00:13:15,839 --> 00:13:20,480
transmitted it also gets the arrival day

00:13:18,240 --> 00:13:21,760
arrival status data so it alerts the

00:13:20,480 --> 00:13:24,000
user that the

00:13:21,760 --> 00:13:25,600
the new refill is going to arrive by

00:13:24,000 --> 00:13:28,639
this in this state

00:13:25,600 --> 00:13:31,360
the the one limbo the motion machine

00:13:28,639 --> 00:13:32,160
in the um that you see below is

00:13:31,360 --> 00:13:34,399
listening to

00:13:32,160 --> 00:13:36,160
another topic which says the same

00:13:34,399 --> 00:13:37,040
publisher publishes that it has been

00:13:36,160 --> 00:13:40,079
delayed

00:13:37,040 --> 00:13:42,560
and it alerts the delay to the user

00:13:40,079 --> 00:13:43,680
so this is how a point-to-point pattern

00:13:42,560 --> 00:13:46,320
is also used

00:13:43,680 --> 00:13:47,839
for one-to-many communication where a

00:13:46,320 --> 00:13:51,040
single unique topic is

00:13:47,839 --> 00:13:51,519
used for and rotated through for several

00:13:51,040 --> 00:13:53,519
um

00:13:51,519 --> 00:13:54,639
several clients and several several

00:13:53,519 --> 00:13:57,360
subscribers

00:13:54,639 --> 00:13:57,360
subscribe to it

00:13:58,320 --> 00:14:04,959
for connecting microcontrollers to um

00:14:01,600 --> 00:14:07,199
to to the cloud you basically

00:14:04,959 --> 00:14:09,199
for aws iit in general you basically

00:14:07,199 --> 00:14:12,000
need transport layer um

00:14:09,199 --> 00:14:12,959
encryption which is tls 1.2 that is the

00:14:12,000 --> 00:14:16,399
recommended

00:14:12,959 --> 00:14:19,600
protocol for encryption of data

00:14:16,399 --> 00:14:21,360
and for authentication we use x5 509

00:14:19,600 --> 00:14:23,600
clan certificates um

00:14:21,360 --> 00:14:25,519
so that when the device has connected

00:14:23,600 --> 00:14:26,079
the broker they're authenticated and

00:14:25,519 --> 00:14:31,839
then

00:14:26,079 --> 00:14:31,839
the communication can happen

00:14:33,440 --> 00:14:36,880
friatas also provides a second library

00:14:36,160 --> 00:14:39,040
um

00:14:36,880 --> 00:14:39,920
for cloud connectivity it's the http

00:14:39,040 --> 00:14:41,760
library

00:14:39,920 --> 00:14:44,399
but it's it's used for a very different

00:14:41,760 --> 00:14:46,959
use case um

00:14:44,399 --> 00:14:49,680
several microcontroller devices that use

00:14:46,959 --> 00:14:53,120
hdtv to connect to the cloud

00:14:49,680 --> 00:14:55,120
and it makes us wonder

00:14:53,120 --> 00:14:56,959
as to why an iot device would use a

00:14:55,120 --> 00:15:00,240
protocol typically used for

00:14:56,959 --> 00:15:03,199
for web-based communication so

00:15:00,240 --> 00:15:05,440
we talked to several customers and most

00:15:03,199 --> 00:15:06,639
of these customers use http for high

00:15:05,440 --> 00:15:08,720
bandwidth downloads

00:15:06,639 --> 00:15:09,760
um for example if you want to download

00:15:08,720 --> 00:15:12,240
videos

00:15:09,760 --> 00:15:14,000
images to your iot devices one of the

00:15:12,240 --> 00:15:15,440
biggest applications for that has been

00:15:14,000 --> 00:15:17,760
kitchen appliances

00:15:15,440 --> 00:15:20,480
um you think of a coffee maker that can

00:15:17,760 --> 00:15:20,959
that is using http to download uh recipe

00:15:20,480 --> 00:15:24,639
images

00:15:20,959 --> 00:15:28,639
um your your refrigerator downloading

00:15:24,639 --> 00:15:32,399
images of of of of

00:15:28,639 --> 00:15:35,199
let's say recipes even in orchards

00:15:32,399 --> 00:15:36,160
agricultural use cases you think of

00:15:35,199 --> 00:15:38,959
sensors

00:15:36,160 --> 00:15:39,759
sending and uploading images of pests to

00:15:38,959 --> 00:15:42,320
the cloud

00:15:39,759 --> 00:15:42,800
these are the use cases that that need

00:15:42,320 --> 00:15:45,199
large

00:15:42,800 --> 00:15:46,959
files um to be uploaded or downloaded we

00:15:45,199 --> 00:15:49,839
are talking about nvs here

00:15:46,959 --> 00:15:51,759
and those are the use cases where http

00:15:49,839 --> 00:15:54,240
becomes more pertinent

00:15:51,759 --> 00:15:55,759
the second thing uh second scenario that

00:15:54,240 --> 00:16:00,079
we have seen from customers is

00:15:55,759 --> 00:16:01,920
also um also to confirm to existing http

00:16:00,079 --> 00:16:04,399
based legacy systems

00:16:01,920 --> 00:16:06,399
our customer has already designed the

00:16:04,399 --> 00:16:07,519
entire infrastructure iot platform based

00:16:06,399 --> 00:16:09,680
on http

00:16:07,519 --> 00:16:11,600
and they would not try to move away from

00:16:09,680 --> 00:16:13,279
http because of the legacy purposes and

00:16:11,600 --> 00:16:15,440
that's why htv becomes pertinent for

00:16:13,279 --> 00:16:18,240
those two

00:16:15,440 --> 00:16:21,440
freertos distributes the http library

00:16:18,240 --> 00:16:23,279
that uses the https 1.1 protocol

00:16:21,440 --> 00:16:25,279
protocol standard to download and upload

00:16:23,279 --> 00:16:27,600
files to amazon s3

00:16:25,279 --> 00:16:28,399
the simple storage service or to any web

00:16:27,600 --> 00:16:30,800
hosted

00:16:28,399 --> 00:16:33,920
web hosted service and it secures the

00:16:30,800 --> 00:16:36,240
file transfer using tls1.2 again

00:16:33,920 --> 00:16:37,120
so that any communication any uploads

00:16:36,240 --> 00:16:39,519
any downloads

00:16:37,120 --> 00:16:41,120
is done securely and it's completely

00:16:39,519 --> 00:16:44,160
managed

00:16:41,120 --> 00:16:46,240
at this point i'll um i'll pause i'll

00:16:44,160 --> 00:16:50,720
pause for a bit to see if if there are

00:16:46,240 --> 00:16:53,360
any questions

00:16:50,720 --> 00:16:55,120
hi tmy i don't see any questions at this

00:16:53,360 --> 00:16:57,279
time i'll just take this moment to

00:16:55,120 --> 00:16:59,680
remind everyone if you do have questions

00:16:57,279 --> 00:17:01,680
you can post them either in the chat box

00:16:59,680 --> 00:17:05,839
the q a box or raise your hand

00:17:01,680 --> 00:17:05,839
thank you

00:17:06,880 --> 00:17:11,360
and then i just wanted to add i dropped

00:17:08,799 --> 00:17:12,319
the reference to your aws white paper in

00:17:11,360 --> 00:17:14,319
the chat

00:17:12,319 --> 00:17:15,520
um for anybody that was interested in

00:17:14,319 --> 00:17:16,319
learning more about that diagram that

00:17:15,520 --> 00:17:18,319
you would put in there

00:17:16,319 --> 00:17:19,360
so if you have anything to add uh

00:17:18,319 --> 00:17:20,799
topic-wise

00:17:19,360 --> 00:17:23,760
just uh let me know and i'll put it in

00:17:20,799 --> 00:17:25,199
there yeah absolutely i think that's a

00:17:23,760 --> 00:17:27,039
that's a really good white paper i put a

00:17:25,199 --> 00:17:28,559
reference um

00:17:27,039 --> 00:17:30,799
i guess not a link but the style

00:17:28,559 --> 00:17:32,320
statement to it too it talks about

00:17:30,799 --> 00:17:34,320
all the three protocols and best

00:17:32,320 --> 00:17:36,880
practices for connecting your devices to

00:17:34,320 --> 00:17:37,520
to aws rt talks about point to point

00:17:36,880 --> 00:17:39,440
talks about

00:17:37,520 --> 00:17:40,880
uh fanning talks about broadcast and

00:17:39,440 --> 00:17:41,280
what are the best practices to do there

00:17:40,880 --> 00:17:42,960
so

00:17:41,280 --> 00:17:47,840
thanks thanks so much chris and you'll

00:17:42,960 --> 00:17:47,840
really find that useful

00:17:49,440 --> 00:17:54,480
all right if there are um no questions

00:17:51,600 --> 00:17:58,000
at this point um

00:17:54,480 --> 00:17:59,600
i'll i'll move ahead that sounds great

00:17:58,000 --> 00:18:01,840
and why thank you

00:17:59,600 --> 00:18:01,840
thanks

00:18:03,440 --> 00:18:07,440
all right let's talk about bluetooth low

00:18:04,960 --> 00:18:07,440
energy

00:18:07,520 --> 00:18:10,799
there are millions of devices such as

00:18:09,039 --> 00:18:13,440
fitness trackers headsets

00:18:10,799 --> 00:18:16,160
and simple sensor devices like humidity

00:18:13,440 --> 00:18:19,600
sensors temperature sensors

00:18:16,160 --> 00:18:21,280
they connect they connect locally to any

00:18:19,600 --> 00:18:23,440
mobile phone that we have seen

00:18:21,280 --> 00:18:24,550
but they could also greatly benefit if

00:18:23,440 --> 00:18:26,480
they could connect to

00:18:24,550 --> 00:18:30,480
[Music]

00:18:26,480 --> 00:18:30,480
connect to the cloud for

00:18:30,799 --> 00:18:36,240
i'm sorry this this

00:18:33,760 --> 00:18:38,000
[Music]

00:18:36,240 --> 00:18:40,000
horizon that happens to me all the time

00:18:38,000 --> 00:18:42,320
too i'm sure all of us with these zoom

00:18:40,000 --> 00:18:45,200
calls have had that experience

00:18:42,320 --> 00:18:46,160
yeah i really really apologize for that

00:18:45,200 --> 00:18:48,960
um

00:18:46,160 --> 00:18:50,400
all right it's gone now all right there

00:18:48,960 --> 00:18:51,120
there are millions of devices as we have

00:18:50,400 --> 00:18:52,799
seen sensor

00:18:51,120 --> 00:18:54,240
are sending sensor data to the cloud and

00:18:52,799 --> 00:18:56,960
they run on batteries um

00:18:54,240 --> 00:18:58,720
they are really um trying to get to as

00:18:56,960 --> 00:19:00,559
low as possible on power

00:18:58,720 --> 00:19:01,760
so that the batteries the the battery

00:19:00,559 --> 00:19:05,360
life is um

00:19:01,760 --> 00:19:06,080
uh is elongated but uh these devices

00:19:05,360 --> 00:19:08,640
typically

00:19:06,080 --> 00:19:09,280
run bluetooth low energy or ble and

00:19:08,640 --> 00:19:11,280
would

00:19:09,280 --> 00:19:12,400
greatly benefit from security connecting

00:19:11,280 --> 00:19:13,840
to the cloud

00:19:12,400 --> 00:19:15,440
by connecting to the cloud they have

00:19:13,840 --> 00:19:17,679
access to all the different uh

00:19:15,440 --> 00:19:19,360
different services and features that

00:19:17,679 --> 00:19:20,160
cloud offers for example over-the-air

00:19:19,360 --> 00:19:23,120
updates

00:19:20,160 --> 00:19:25,039
device shadow that these constrained

00:19:23,120 --> 00:19:27,039
microcontrollers running the ble

00:19:25,039 --> 00:19:28,640
bluetooth low energy stack would not be

00:19:27,039 --> 00:19:31,120
able to do it alone

00:19:28,640 --> 00:19:32,080
and therefore because these devices do

00:19:31,120 --> 00:19:35,280
not support

00:19:32,080 --> 00:19:37,039
ib they need a gateway

00:19:35,280 --> 00:19:38,720
such as such as a mobile phone that you

00:19:37,039 --> 00:19:42,080
can see on the diagram in the middle

00:19:38,720 --> 00:19:44,240
to connect to the cloud the process

00:19:42,080 --> 00:19:45,679
and if you try to take a simple blue

00:19:44,240 --> 00:19:47,840
bluetooth device and connect it to the

00:19:45,679 --> 00:19:48,880
cloud the process involves several steps

00:19:47,840 --> 00:19:50,880
and can be really

00:19:48,880 --> 00:19:52,160
time consuming you first have to select

00:19:50,880 --> 00:19:53,600
the microcontroller that you would need

00:19:52,160 --> 00:19:55,600
to connect to the cloud

00:19:53,600 --> 00:19:57,120
and then select the compatible ble

00:19:55,600 --> 00:19:58,960
stacks um

00:19:57,120 --> 00:20:00,400
integrate all the cloud connectivity

00:19:58,960 --> 00:20:02,640
libraries to um

00:20:00,400 --> 00:20:04,559
to the corresponding mobile sdks the

00:20:02,640 --> 00:20:06,960
android and ios sdks

00:20:04,559 --> 00:20:08,480
finally code them test them using the

00:20:06,960 --> 00:20:11,440
android and ios device

00:20:08,480 --> 00:20:12,240
and then you are finally ready this this

00:20:11,440 --> 00:20:14,720
problem becomes

00:20:12,240 --> 00:20:16,000
worse when you're trying to evaluate

00:20:14,720 --> 00:20:17,039
different microcontrollers at the

00:20:16,000 --> 00:20:19,440
evaluation stage

00:20:17,039 --> 00:20:20,559
and you have to do the process over and

00:20:19,440 --> 00:20:22,640
over again

00:20:20,559 --> 00:20:23,600
to see if this this makes sense and

00:20:22,640 --> 00:20:27,039
whatever um

00:20:23,600 --> 00:20:29,679
whatever microcutter that you choose

00:20:27,039 --> 00:20:31,120
so free at us acknowledge this problem

00:20:29,679 --> 00:20:33,679
and talk to several customers

00:20:31,120 --> 00:20:35,919
and um the way we proceeded with this we

00:20:33,679 --> 00:20:38,640
provided a standardized api layer

00:20:35,919 --> 00:20:40,799
um uh to interface with the ble stacks

00:20:38,640 --> 00:20:43,600
provided by microcontroller vendors

00:20:40,799 --> 00:20:45,440
so with that abstraction layer with the

00:20:43,600 --> 00:20:46,960
standardized api layer you don't have to

00:20:45,440 --> 00:20:47,360
change your application whenever you

00:20:46,960 --> 00:20:49,520
change

00:20:47,360 --> 00:20:51,280
the the microcontroller underneath but

00:20:49,520 --> 00:20:53,679
you just have to

00:20:51,280 --> 00:20:54,799
port it to the right api layer and you

00:20:53,679 --> 00:20:57,600
are done

00:20:54,799 --> 00:20:59,840
this also enables the use of standard

00:20:57,600 --> 00:21:02,080
generic access profile and generic

00:20:59,840 --> 00:21:03,679
attributes profile gap and gad to create

00:21:02,080 --> 00:21:05,760
dvd applications

00:21:03,679 --> 00:21:07,120
for those who are not aware according to

00:21:05,760 --> 00:21:09,840
ble specifications

00:21:07,120 --> 00:21:10,799
gaap defines how ble devices broadcast

00:21:09,840 --> 00:21:12,480
availability

00:21:10,799 --> 00:21:14,320
so there might be several bla devices

00:21:12,480 --> 00:21:15,120
that are pinging their availability and

00:21:14,320 --> 00:21:18,240
status

00:21:15,120 --> 00:21:19,919
and then um whenever it connects to a

00:21:18,240 --> 00:21:21,919
mobile phone that is interested in

00:21:19,919 --> 00:21:23,760
communicating with the bre device um

00:21:21,919 --> 00:21:25,120
the gaap protocol is pertinent towards

00:21:23,760 --> 00:21:27,760
that gatt

00:21:25,120 --> 00:21:28,559
on the other hand describes how data is

00:21:27,760 --> 00:21:31,039
transferred

00:21:28,559 --> 00:21:31,600
when the connection is established you

00:21:31,039 --> 00:21:33,200
um

00:21:31,600 --> 00:21:34,960
with a mobile phone and a ble device

00:21:33,200 --> 00:21:37,039
when you are connected gat

00:21:34,960 --> 00:21:38,799
is how you communicate how you transfer

00:21:37,039 --> 00:21:42,000
data

00:21:38,799 --> 00:21:43,440
so um the the free rtos api layer that i

00:21:42,000 --> 00:21:45,200
just talked about it provides

00:21:43,440 --> 00:21:47,679
it's also it's all it also provides

00:21:45,200 --> 00:21:50,400
companion android and ios sdks

00:21:47,679 --> 00:21:51,120
to integrate with aws iot functionality

00:21:50,400 --> 00:21:53,600
so

00:21:51,120 --> 00:21:55,840
um you have your friata sdk the

00:21:53,600 --> 00:21:58,400
standardized api that connects to

00:21:55,840 --> 00:21:59,679
the ble stack and then you have got the

00:21:58,400 --> 00:22:01,600
um the android and

00:21:59,679 --> 00:22:03,200
ios sdk so that you can build your

00:22:01,600 --> 00:22:04,320
application mobile application to

00:22:03,200 --> 00:22:07,840
connect these devices

00:22:04,320 --> 00:22:12,159
um back to the cloud using mqtt

00:22:07,840 --> 00:22:14,880
now friatas has taken a step further and

00:22:12,159 --> 00:22:15,919
provided custom gap profiles for mqtt

00:22:14,880 --> 00:22:18,720
over ble

00:22:15,919 --> 00:22:21,200
so um on top of ble profile we have the

00:22:18,720 --> 00:22:23,039
mqtt so that the devices the bd devices

00:22:21,200 --> 00:22:26,400
can communicate directly

00:22:23,039 --> 00:22:27,120
to a with aws iot and use its different

00:22:26,400 --> 00:22:30,000
features

00:22:27,120 --> 00:22:32,159
using the mobile device as a proxy and

00:22:30,000 --> 00:22:34,000
wi-fi provisioning over ble is another

00:22:32,159 --> 00:22:35,840
custom profile that we built to securely

00:22:34,000 --> 00:22:36,720
send wi-fi credentials to your device

00:22:35,840 --> 00:22:39,760
over blu

00:22:36,720 --> 00:22:42,480
and this is really useful for for

00:22:39,760 --> 00:22:44,880
use cases where we need to provision

00:22:42,480 --> 00:22:48,159
wi-fi credentials onto new appliances

00:22:44,880 --> 00:22:48,159
installed at home for example

00:22:49,440 --> 00:22:54,159
uh now let's talk about the first custom

00:22:51,360 --> 00:22:57,280
profile wi-fi provisioning over ple

00:22:54,159 --> 00:23:01,039
um um mqtt over ble so mkt

00:22:57,280 --> 00:23:03,679
over ple actually enables um your anyone

00:23:01,039 --> 00:23:04,080
using bla devices to connect to aws iot

00:23:03,679 --> 00:23:06,320
via

00:23:04,080 --> 00:23:08,720
a mobile phone as a proxy as you can see

00:23:06,320 --> 00:23:09,919
on the diagram on the right the ios and

00:23:08,720 --> 00:23:12,400
the android sdks

00:23:09,919 --> 00:23:12,960
um provide the proxy libraries and you

00:23:12,400 --> 00:23:14,559
can use

00:23:12,960 --> 00:23:16,720
simple demo applications that are

00:23:14,559 --> 00:23:19,039
provided within the sdks itself

00:23:16,720 --> 00:23:19,760
um and free out of source code to

00:23:19,039 --> 00:23:21,919
quickly

00:23:19,760 --> 00:23:23,440
to quickly get started on this there

00:23:21,919 --> 00:23:25,600
isn't there is a sample

00:23:23,440 --> 00:23:26,880
application that you can um that you can

00:23:25,600 --> 00:23:29,200
use as a reference

00:23:26,880 --> 00:23:30,320
but it's mainly for you to develop your

00:23:29,200 --> 00:23:32,080
own application that

00:23:30,320 --> 00:23:34,559
uh custom built application using the

00:23:32,080 --> 00:23:37,120
sdk libraries

00:23:34,559 --> 00:23:39,440
the mobile device has to securely

00:23:37,120 --> 00:23:41,679
connect to aws iit and there has to be a

00:23:39,440 --> 00:23:43,679
a process where it authenticates and

00:23:41,679 --> 00:23:46,480
authorizes with aws iit

00:23:43,679 --> 00:23:48,400
and for that um an example that we

00:23:46,480 --> 00:23:49,600
provided is with the amazon cognito

00:23:48,400 --> 00:23:52,240
service

00:23:49,600 --> 00:23:52,799
amazon cloud data service is is for user

00:23:52,240 --> 00:23:55,200
sign-ups

00:23:52,799 --> 00:23:56,559
sign in and access control to web and

00:23:55,200 --> 00:23:59,120
mobile applications

00:23:56,559 --> 00:24:00,880
so this is something that we have that

00:23:59,120 --> 00:24:02,880
we have provided as an example code

00:24:00,880 --> 00:24:04,720
you can use as a reference to get you

00:24:02,880 --> 00:24:08,320
started connecting your pla device to

00:24:04,720 --> 00:24:10,320
to iot core now what is the advantage of

00:24:08,320 --> 00:24:11,360
mqtt over ble um seems like a new

00:24:10,320 --> 00:24:14,559
concept but

00:24:11,360 --> 00:24:16,880
mqhd over ble if you imagine that is is

00:24:14,559 --> 00:24:18,000
basically a conduit becomes a conduit

00:24:16,880 --> 00:24:20,880
from the ble the

00:24:18,000 --> 00:24:22,799
end devices directly to aws iot and you

00:24:20,880 --> 00:24:25,120
can use aws services such as

00:24:22,799 --> 00:24:26,559
over-the-air updates and aws iot device

00:24:25,120 --> 00:24:28,400
shadow

00:24:26,559 --> 00:24:30,240
over the air updates you can use the

00:24:28,400 --> 00:24:33,039
same mechanism that we have built

00:24:30,240 --> 00:24:33,440
for over-the-air updates and push it

00:24:33,039 --> 00:24:35,440
down

00:24:33,440 --> 00:24:37,200
directly to your end devices the ble

00:24:35,440 --> 00:24:39,919
devices to

00:24:37,200 --> 00:24:41,440
update your firmware so you can use the

00:24:39,919 --> 00:24:43,039
ota service

00:24:41,440 --> 00:24:44,960
which is which becomes completely

00:24:43,039 --> 00:24:45,600
agnostic of the transport layer protocol

00:24:44,960 --> 00:24:48,240
whether

00:24:45,600 --> 00:24:50,080
what it uses underneath whether it's tcp

00:24:48,240 --> 00:24:51,200
based or bld based it doesn't really

00:24:50,080 --> 00:24:53,919
matter

00:24:51,200 --> 00:24:55,600
and similarly for aws iot device shadow

00:24:53,919 --> 00:24:58,840
you can use different services

00:24:55,600 --> 00:25:00,400
uh when we are talking mqtt on top of

00:24:58,840 --> 00:25:02,880
ble

00:25:00,400 --> 00:25:05,919
uh the second custom profile that we

00:25:02,880 --> 00:25:08,400
have generated that we have created for

00:25:05,919 --> 00:25:10,240
for connecting your ble devices

00:25:08,400 --> 00:25:11,120
microcontroller based ble devices to the

00:25:10,240 --> 00:25:14,159
cloud

00:25:11,120 --> 00:25:14,640
is wi-fi provisioning over ble and this

00:25:14,159 --> 00:25:16,400
becomes

00:25:14,640 --> 00:25:18,320
really important when you have to let's

00:25:16,400 --> 00:25:21,360
say provision um ssid

00:25:18,320 --> 00:25:24,240
or password over the ble channel uh you

00:25:21,360 --> 00:25:27,360
have seen the provisioning steps like of

00:25:24,240 --> 00:25:30,640
for for uh new new appliances

00:25:27,360 --> 00:25:32,480
being being provisioned

00:25:30,640 --> 00:25:34,559
field technicians come in and quickly

00:25:32,480 --> 00:25:36,960
set up and install iot devices

00:25:34,559 --> 00:25:38,000
on these devices by using the bld

00:25:36,960 --> 00:25:41,200
configuration

00:25:38,000 --> 00:25:44,720
configuration path so this

00:25:41,200 --> 00:25:46,559
this saves a lot of effort and um and

00:25:44,720 --> 00:25:48,559
other problems that that is encountered

00:25:46,559 --> 00:25:51,600
with other provisioning mechanisms like

00:25:48,559 --> 00:25:54,320
soft ap based wi-fi um

00:25:51,600 --> 00:25:56,080
provisioning users can save multiple

00:25:54,320 --> 00:25:57,440
wi-fi configurations and this becomes

00:25:56,080 --> 00:25:59,360
really important if you have multiple

00:25:57,440 --> 00:26:01,360
devices and wi-fi routers at home

00:25:59,360 --> 00:26:03,440
and you need to save multiple wi-fi

00:26:01,360 --> 00:26:05,760
configurations in each of these machines

00:26:03,440 --> 00:26:06,640
and we have also provided examples in

00:26:05,760 --> 00:26:08,880
which you can

00:26:06,640 --> 00:26:10,240
re-prioritize add and delete saved

00:26:08,880 --> 00:26:12,240
networks from

00:26:10,240 --> 00:26:15,200
all the list of wi-fi configurations

00:26:12,240 --> 00:26:18,799
that you saved on your device

00:26:15,200 --> 00:26:20,240
for security uh we um security is one of

00:26:18,799 --> 00:26:22,000
the top most concerns when we are

00:26:20,240 --> 00:26:22,559
pairing the ble device with the mobile

00:26:22,000 --> 00:26:24,960
phone

00:26:22,559 --> 00:26:27,200
and that's why we use the the standard

00:26:24,960 --> 00:26:29,600
the bld secure connection standard

00:26:27,200 --> 00:26:31,279
that is provided by um bluetooth low

00:26:29,600 --> 00:26:36,960
energy standard protocol

00:26:31,279 --> 00:26:39,600
uh for uh for the the initial pairing

00:26:36,960 --> 00:26:40,880
um and if you want to get started with

00:26:39,600 --> 00:26:42,960
the custom profile

00:26:40,880 --> 00:26:44,799
of using wi-fi provisioning over ble you

00:26:42,960 --> 00:26:47,200
can you can use the demo code

00:26:44,799 --> 00:26:53,200
included in the source code that will

00:26:47,200 --> 00:26:55,440
help you quickly get started

00:26:53,200 --> 00:26:56,640
moving over to the to one of the most

00:26:55,440 --> 00:27:00,000
important aspects

00:26:56,640 --> 00:27:00,320
is is over-the-air updates and this has

00:27:00,000 --> 00:27:03,360
come

00:27:00,320 --> 00:27:05,440
with after repeated customer um

00:27:03,360 --> 00:27:06,880
customer inputs and customer feedback

00:27:05,440 --> 00:27:09,120
that we need update

00:27:06,880 --> 00:27:10,080
updateability all iot devices need

00:27:09,120 --> 00:27:12,320
updatability

00:27:10,080 --> 00:27:14,640
but the problem that exists today is

00:27:12,320 --> 00:27:17,919
fragmentation of the market

00:27:14,640 --> 00:27:20,240
all customers use different types of

00:27:17,919 --> 00:27:21,840
ota feature and capability and they do

00:27:20,240 --> 00:27:23,679
it themselves

00:27:21,840 --> 00:27:25,039
what this means is that there is not a

00:27:23,679 --> 00:27:26,000
single solution not a standardized

00:27:25,039 --> 00:27:28,399
solution and

00:27:26,000 --> 00:27:29,520
and these solutions are not scalable

00:27:28,399 --> 00:27:31,279
when they're trying to change

00:27:29,520 --> 00:27:34,399
applications change microcontrollers

00:27:31,279 --> 00:27:34,399
change the end devices

00:27:34,880 --> 00:27:40,720
and updating a few devices manually

00:27:38,159 --> 00:27:42,960
is viable um when we think about ota we

00:27:40,720 --> 00:27:44,799
think about updating former manually um

00:27:42,960 --> 00:27:46,240
pushing the usb plug-in or a serial

00:27:44,799 --> 00:27:46,880
interface and then push the new phone

00:27:46,240 --> 00:27:48,480
back

00:27:46,880 --> 00:27:50,320
but when you're talking about iot

00:27:48,480 --> 00:27:51,919
devices we're talking about millions of

00:27:50,320 --> 00:27:54,799
devices potentially

00:27:51,919 --> 00:27:56,399
and to update that manually is is not

00:27:54,799 --> 00:27:57,919
viable it's not practical

00:27:56,399 --> 00:27:59,760
and therefore over the air update

00:27:57,919 --> 00:28:01,039
solution becomes more practical at that

00:27:59,760 --> 00:28:04,240
point at that scale

00:28:01,039 --> 00:28:06,240
and more cost effective but for

00:28:04,240 --> 00:28:09,440
microcontroller based application

00:28:06,240 --> 00:28:11,200
needs um careful consideration

00:28:09,440 --> 00:28:13,120
we are thinking about saving every

00:28:11,200 --> 00:28:15,120
kilobyte of memory without compromising

00:28:13,120 --> 00:28:17,760
security of the microcontroller based

00:28:15,120 --> 00:28:20,159
devices you need to think about both the

00:28:17,760 --> 00:28:21,440
devices aspect of over-the-air updates

00:28:20,159 --> 00:28:24,159
and the cloud aspect

00:28:21,440 --> 00:28:25,200
we have to optimize for both of these

00:28:24,159 --> 00:28:26,640
let's look at how

00:28:25,200 --> 00:28:30,320
how this is done and what is the

00:28:26,640 --> 00:28:33,760
approach that we have taken within aws

00:28:30,320 --> 00:28:36,000
so freertos um provides an ota service

00:28:33,760 --> 00:28:36,799
where you can use the aws iot device

00:28:36,000 --> 00:28:38,799
management

00:28:36,799 --> 00:28:39,840
um if you haven't seen device management

00:28:38,799 --> 00:28:42,559
you can actually um

00:28:39,840 --> 00:28:43,279
look it up so you can go to the console

00:28:42,559 --> 00:28:45,679
and

00:28:43,279 --> 00:28:46,559
schedule an ot update job you can do it

00:28:45,679 --> 00:28:48,880
for um

00:28:46,559 --> 00:28:50,720
remotely updating device devices or a

00:28:48,880 --> 00:28:53,520
group of devices you can think of

00:28:50,720 --> 00:28:55,440
all the sensors in a building building

00:28:53,520 --> 00:28:57,840
floor for example

00:28:55,440 --> 00:28:59,760
and you get the ability to quote sign

00:28:57,840 --> 00:29:00,240
the firmware images while scheduling the

00:28:59,760 --> 00:29:02,159
update

00:29:00,240 --> 00:29:03,600
and the devices have the capability to

00:29:02,159 --> 00:29:05,039
validate the signatures

00:29:03,600 --> 00:29:07,600
when the firmware is downloaded to the

00:29:05,039 --> 00:29:09,600
device so you get an end-to-end security

00:29:07,600 --> 00:29:12,000
of the authentication whenever you are

00:29:09,600 --> 00:29:14,320
sending the firmware updates to the the

00:29:12,000 --> 00:29:16,000
devices and this helps this actually

00:29:14,320 --> 00:29:17,360
helps customers be assured

00:29:16,000 --> 00:29:19,360
that the firmware is coming from the

00:29:17,360 --> 00:29:21,840
right source a trusted source

00:29:19,360 --> 00:29:24,399
and hasn't been transferred during

00:29:21,840 --> 00:29:27,200
during transit

00:29:24,399 --> 00:29:28,640
updates are streamed to the devices over

00:29:27,200 --> 00:29:30,640
mqtt

00:29:28,640 --> 00:29:31,919
using the same tls connection that was

00:29:30,640 --> 00:29:33,679
established um

00:29:31,919 --> 00:29:35,360
in the first place for devices to

00:29:33,679 --> 00:29:38,159
connect to aws rt

00:29:35,360 --> 00:29:39,520
which means that whenever whenever you

00:29:38,159 --> 00:29:41,919
are using the same socket where

00:29:39,520 --> 00:29:43,120
using the same tls connection it saves

00:29:41,919 --> 00:29:44,720
spacious memory on the

00:29:43,120 --> 00:29:47,279
microcontroller-based devices because

00:29:44,720 --> 00:29:50,799
you don't have to open a second socket

00:29:47,279 --> 00:29:53,520
just just for um for ota

00:29:50,799 --> 00:29:54,480
and after the new image is downloaded we

00:29:53,520 --> 00:29:57,600
have apis

00:29:54,480 --> 00:29:59,120
um to to actually see to uh to

00:29:57,600 --> 00:30:02,399
to measure the installation has been

00:29:59,120 --> 00:30:05,840
directly correctly done and the reboot

00:30:02,399 --> 00:30:05,840
and the reboot logic is present

00:30:06,240 --> 00:30:11,039
um now let's quickly go into some of the

00:30:09,760 --> 00:30:14,399
technical details of

00:30:11,039 --> 00:30:18,799
how ot on friatas is done

00:30:14,399 --> 00:30:21,120
um for any ota service an oto or mqtt

00:30:18,799 --> 00:30:23,840
especially has two distinct orders

00:30:21,120 --> 00:30:25,840
for the first is the operator the user

00:30:23,840 --> 00:30:27,520
who schedules the ot update job

00:30:25,840 --> 00:30:28,960
and the second is the device the end

00:30:27,520 --> 00:30:31,120
device on the field

00:30:28,960 --> 00:30:32,399
which takes control after the update job

00:30:31,120 --> 00:30:34,480
has been scheduled

00:30:32,399 --> 00:30:36,480
and the device makes sure that the

00:30:34,480 --> 00:30:38,320
entire update process is smooth

00:30:36,480 --> 00:30:40,640
and within the device i'm talking about

00:30:38,320 --> 00:30:42,799
um two two different aspects

00:30:40,640 --> 00:30:44,720
boot loader which is basically using

00:30:42,799 --> 00:30:46,000
used for booting the new firmware the

00:30:44,720 --> 00:30:49,440
new updated firmware

00:30:46,000 --> 00:30:52,799
and ot agent which manages the um

00:30:49,440 --> 00:30:56,159
the entire process of of firmware coming

00:30:52,799 --> 00:30:56,159
in into the device itself

00:30:56,559 --> 00:31:03,279
now the flow is um is

00:30:59,919 --> 00:31:05,440
multi-step the at first the operator

00:31:03,279 --> 00:31:06,720
authors the firmware update so you're

00:31:05,440 --> 00:31:08,000
building a new firmware you're building

00:31:06,720 --> 00:31:10,320
a new version

00:31:08,000 --> 00:31:11,200
you build a new format um and upload it

00:31:10,320 --> 00:31:13,919
to the cloud

00:31:11,200 --> 00:31:15,039
upload it to amazon s3 or any web hosted

00:31:13,919 --> 00:31:18,320
service

00:31:15,039 --> 00:31:20,240
now the the operator schedules an

00:31:18,320 --> 00:31:21,360
update job using the device management

00:31:20,240 --> 00:31:24,080
console as i mentioned

00:31:21,360 --> 00:31:26,080
um earlier where he or she can sign the

00:31:24,080 --> 00:31:29,440
firmware and select the right

00:31:26,080 --> 00:31:32,880
s3 bucket being done used for

00:31:29,440 --> 00:31:33,840
the audio process but the console is

00:31:32,880 --> 00:31:36,960
just one of the

00:31:33,840 --> 00:31:38,880
one of the solutions for advanced users

00:31:36,960 --> 00:31:40,720
ota can also be scheduled using command

00:31:38,880 --> 00:31:43,120
line interface or cli

00:31:40,720 --> 00:31:44,720
but once the ot update job whichever

00:31:43,120 --> 00:31:45,440
method whether it's the clr or the

00:31:44,720 --> 00:31:47,360
console

00:31:45,440 --> 00:31:49,919
but once the ot update job has been

00:31:47,360 --> 00:31:52,720
scheduled the devices are notified

00:31:49,919 --> 00:31:54,399
um that an update is coming so there's a

00:31:52,720 --> 00:31:56,799
new firmware all the devices that are

00:31:54,399 --> 00:31:59,360
subscribed to the mqa topic know

00:31:56,799 --> 00:32:00,000
that there's this new format that is

00:31:59,360 --> 00:32:03,679
that is ready

00:32:00,000 --> 00:32:03,679
for ready for that

00:32:04,720 --> 00:32:10,799
now at this point the device takes over

00:32:08,640 --> 00:32:12,880
the device especially the ota agent

00:32:10,799 --> 00:32:15,919
within the device takes control

00:32:12,880 --> 00:32:19,200
the device downloads the new image um in

00:32:15,919 --> 00:32:19,600
chunks from aws iot core and writes

00:32:19,200 --> 00:32:22,399
those

00:32:19,600 --> 00:32:22,960
chunks to flash flash within the memory

00:32:22,399 --> 00:32:25,200
itself

00:32:22,960 --> 00:32:26,720
within the microcontroller itself in a

00:32:25,200 --> 00:32:29,760
separate partition

00:32:26,720 --> 00:32:33,440
so um if you think of a

00:32:29,760 --> 00:32:36,799
1mb uh image you split it into

00:32:33,440 --> 00:32:39,360
chunks libya maybe 5 kb chucks and

00:32:36,799 --> 00:32:42,159
those are downloaded back to the flash

00:32:39,360 --> 00:32:44,399
and kept in a separate partition the

00:32:42,159 --> 00:32:45,440
primary image the the formula that is

00:32:44,399 --> 00:32:47,279
currently running

00:32:45,440 --> 00:32:48,640
is the one that is currently executed

00:32:47,279 --> 00:32:51,200
and it basically

00:32:48,640 --> 00:32:52,159
sends um the chunks over to a second

00:32:51,200 --> 00:32:55,360
partition within the

00:32:52,159 --> 00:32:59,360
within the flash the ot

00:32:55,360 --> 00:33:02,799
agent now stitches the chunks together

00:32:59,360 --> 00:33:05,919
and in sequence and verifies um

00:33:02,799 --> 00:33:07,120
that that the signature is is done if

00:33:05,919 --> 00:33:09,120
successful

00:33:07,120 --> 00:33:11,840
it notifies the application that the new

00:33:09,120 --> 00:33:14,240
image is ready to be used

00:33:11,840 --> 00:33:15,600
at this point the bootloader the

00:33:14,240 --> 00:33:16,480
bootloader within the device takes

00:33:15,600 --> 00:33:18,240
control

00:33:16,480 --> 00:33:20,000
it verifies that the new image comes

00:33:18,240 --> 00:33:20,880
from the trusted source and initiates a

00:33:20,000 --> 00:33:24,559
self test

00:33:20,880 --> 00:33:26,799
it checks for um for the checksum

00:33:24,559 --> 00:33:28,559
um and the image if it's coming from the

00:33:26,799 --> 00:33:30,320
right source and verifies the signature

00:33:28,559 --> 00:33:32,960
that was used in code signing

00:33:30,320 --> 00:33:34,399
and if all checks pass the older image

00:33:32,960 --> 00:33:38,159
is deleted and the device

00:33:34,399 --> 00:33:40,080
boots from the new image so um

00:33:38,159 --> 00:33:41,760
you might think that why is that

00:33:40,080 --> 00:33:43,279
necessary but that's it that is

00:33:41,760 --> 00:33:45,440
necessary because the old image is

00:33:43,279 --> 00:33:47,919
deleted as a security practice um

00:33:45,440 --> 00:33:49,039
to prevent the device to roll back to an

00:33:47,919 --> 00:33:51,120
unsecured image

00:33:49,039 --> 00:33:52,399
um and therefore the security patch was

00:33:51,120 --> 00:33:55,120
coming in

00:33:52,399 --> 00:33:55,519
finally after everything has been done

00:33:55,120 --> 00:33:58,159
this

00:33:55,519 --> 00:34:00,080
device sends the status to aws iot or

00:33:58,159 --> 00:34:01,679
any cloud but the ot update job has been

00:34:00,080 --> 00:34:05,440
successfully completed

00:34:01,679 --> 00:34:08,079
so this is an end to end cloud to device

00:34:05,440 --> 00:34:10,480
device story where you initiate the

00:34:08,079 --> 00:34:14,399
process the operator initiates a process

00:34:10,480 --> 00:34:16,079
on the cloud by updating a job um

00:34:14,399 --> 00:34:17,440
the notification is sent to the device

00:34:16,079 --> 00:34:19,520
the device takes over

00:34:17,440 --> 00:34:21,760
downloads the entire firmware and it

00:34:19,520 --> 00:34:24,000
notifies it back to the cloud that the

00:34:21,760 --> 00:34:25,040
the execution has been completed and a

00:34:24,000 --> 00:34:29,359
new firmware has been

00:34:25,040 --> 00:34:31,440
successfully installed so um

00:34:29,359 --> 00:34:32,960
this is the entire ot action that we

00:34:31,440 --> 00:34:36,399
where we have done for

00:34:32,960 --> 00:34:40,000
for mqtt but

00:34:36,399 --> 00:34:41,040
you are you are free to use it for http

00:34:40,000 --> 00:34:43,919
based downloads too

00:34:41,040 --> 00:34:44,960
so for example if you use mqtt for just

00:34:43,919 --> 00:34:46,560
for notification

00:34:44,960 --> 00:34:48,000
and you want to download megabytes of

00:34:46,560 --> 00:34:51,839
firmware over http

00:34:48,000 --> 00:34:51,839
you have the flexibility to do that too

00:34:51,919 --> 00:34:57,440
now um how do we get started how do we

00:34:55,119 --> 00:35:00,160
start building new iot projects

00:34:57,440 --> 00:35:01,599
um freeahtos.org is the place where you

00:35:00,160 --> 00:35:02,000
will find all information you can

00:35:01,599 --> 00:35:04,160
download

00:35:02,000 --> 00:35:06,320
source code you can review documentation

00:35:04,160 --> 00:35:07,920
um the api documentation

00:35:06,320 --> 00:35:09,359
and the demos for all free rtos

00:35:07,920 --> 00:35:10,160
libraries whether it's the free artist

00:35:09,359 --> 00:35:12,800
kernel

00:35:10,160 --> 00:35:14,160
or or any of the iot libraries that are

00:35:12,800 --> 00:35:16,960
provided with it

00:35:14,160 --> 00:35:18,079
and if you already have selected a

00:35:16,960 --> 00:35:20,800
microcontroller

00:35:18,079 --> 00:35:21,839
um let's say from sd microelectronics

00:35:20,800 --> 00:35:24,720
from ti

00:35:21,839 --> 00:35:26,400
from nxp espressif any if you have

00:35:24,720 --> 00:35:29,680
chosen any microcontroller

00:35:26,400 --> 00:35:32,079
that you want to use you can go to the

00:35:29,680 --> 00:35:34,079
iot reference integrations page

00:35:32,079 --> 00:35:36,400
and you can download deported and

00:35:34,079 --> 00:35:38,480
pre-integrated and tested and validated

00:35:36,400 --> 00:35:40,320
code and projects from over 40

00:35:38,480 --> 00:35:42,720
microcontroller-based dev kits

00:35:40,320 --> 00:35:45,200
so you'll get a head start in starting

00:35:42,720 --> 00:35:47,200
your iot projects

00:35:45,200 --> 00:35:48,720
at any stage stage of your project

00:35:47,200 --> 00:35:50,560
whether it's you're building

00:35:48,720 --> 00:35:52,880
your evaluation board or you're

00:35:50,560 --> 00:35:54,480
deploying it or using ota feature

00:35:52,880 --> 00:35:56,160
if you face any technical issues and you

00:35:54,480 --> 00:35:58,720
need support for anything

00:35:56,160 --> 00:36:00,640
you can interact with us directly um by

00:35:58,720 --> 00:36:03,040
by using the free our task community

00:36:00,640 --> 00:36:04,160
community forums um it's uh it's

00:36:03,040 --> 00:36:07,079
basically the link is

00:36:04,160 --> 00:36:08,400
um here you can see it um on the screen

00:36:07,079 --> 00:36:10,000
forums.friata.org

00:36:08,400 --> 00:36:13,040
and we'll be happy to interact and help

00:36:10,000 --> 00:36:16,160
you out on any problems that you see

00:36:13,040 --> 00:36:18,400
um for documentation you'll find

00:36:16,160 --> 00:36:20,800
most of the api documentation

00:36:18,400 --> 00:36:22,560
applications and demos on friata.org

00:36:20,800 --> 00:36:24,000
but if you need other documentation

00:36:22,560 --> 00:36:27,440
types which are specific

00:36:24,000 --> 00:36:29,359
for specific to aws or think um

00:36:27,440 --> 00:36:31,599
you would need a porting guide for

00:36:29,359 --> 00:36:32,720
example how to port the iot libraries

00:36:31,599 --> 00:36:36,240
you can go to

00:36:32,720 --> 00:36:38,160
the docs.aws.amazon.com page and

00:36:36,240 --> 00:36:40,880
you'll find relevant documentation over

00:36:38,160 --> 00:36:44,160
there too

00:36:40,880 --> 00:36:45,839
at this point uh i'll stop and see if

00:36:44,160 --> 00:36:48,320
you have any questions

00:36:45,839 --> 00:36:50,640
uh that i can i i can answer that in the

00:36:48,320 --> 00:36:50,640
forum

00:36:50,880 --> 00:36:55,359
that's ny so thank you so much and this

00:36:53,760 --> 00:36:57,040
is a great chance to

00:36:55,359 --> 00:36:59,760
ask any questions you might have right

00:36:57,040 --> 00:37:02,640
now the qa is completely open

00:36:59,760 --> 00:37:03,200
um so anything you might be curious

00:37:02,640 --> 00:37:05,520
about

00:37:03,200 --> 00:37:07,280
please jump in the chat or the qa

00:37:05,520 --> 00:37:09,040
section

00:37:07,280 --> 00:37:10,480
and otherwise i'm just going to start

00:37:09,040 --> 00:37:13,359
asking a few questions because we've got

00:37:10,480 --> 00:37:13,359
a few minutes left

00:37:18,720 --> 00:37:22,400
so tim while we're waiting for oh here

00:37:20,560 --> 00:37:25,680
we have one question from andre

00:37:22,400 --> 00:37:28,800
um is the esp32 fully supported

00:37:25,680 --> 00:37:32,720
for free rtos

00:37:28,800 --> 00:37:34,079
um so yeah um there is a reference port

00:37:32,720 --> 00:37:36,160
for esp32

00:37:34,079 --> 00:37:37,839
so if you want to use esp32 you can

00:37:36,160 --> 00:37:39,599
actually come go to a reference

00:37:37,839 --> 00:37:40,079
integrations page you can download the

00:37:39,599 --> 00:37:41,839
uh

00:37:40,079 --> 00:37:43,680
download the code and you can build your

00:37:41,839 --> 00:37:46,320
applications on it you can use ota

00:37:43,680 --> 00:37:48,000
you can use ble the abstraction layer

00:37:46,320 --> 00:37:50,000
and wi-fi abstraction layer so

00:37:48,000 --> 00:37:51,920
so yes we have provided a reference

00:37:50,000 --> 00:37:55,359
integration but if you need

00:37:51,920 --> 00:37:58,320
um any specific information of about the

00:37:55,359 --> 00:37:59,440
bsps and the drivers um pertinent to the

00:37:58,320 --> 00:38:02,800
sp32

00:37:59,440 --> 00:38:04,000
chipset itself we are actually closely

00:38:02,800 --> 00:38:05,760
partnering with esp

00:38:04,000 --> 00:38:08,560
so we can help you out or especially can

00:38:05,760 --> 00:38:08,560
directly help you out

00:38:08,880 --> 00:38:13,359
excellent nice and then there was

00:38:11,599 --> 00:38:15,280
another request to repost the white

00:38:13,359 --> 00:38:17,200
paper in the chat actually i'll go ahead

00:38:15,280 --> 00:38:20,400
and do that here in a moment

00:38:17,200 --> 00:38:20,960
um and then oh one feature about zoom

00:38:20,400 --> 00:38:22,560
that

00:38:20,960 --> 00:38:24,640
i was actually just recently made aware

00:38:22,560 --> 00:38:26,560
of is there's three little dots

00:38:24,640 --> 00:38:28,800
down in the bottom of the chat area and

00:38:26,560 --> 00:38:30,560
you can click that to save the entire

00:38:28,800 --> 00:38:31,599
chat conversation which i found to be

00:38:30,560 --> 00:38:33,200
extremely

00:38:31,599 --> 00:38:35,440
helpful as i don't have to copy and

00:38:33,200 --> 00:38:37,119
paste furiously before the session ends

00:38:35,440 --> 00:38:38,960
um but i'll go ahead and repost that

00:38:37,119 --> 00:38:40,880
here essentially in one moment

00:38:38,960 --> 00:38:43,200
there's another question to enjoy how

00:38:40,880 --> 00:38:44,839
does aws recommend recovering from a

00:38:43,200 --> 00:38:47,440
failed ota

00:38:44,839 --> 00:38:50,720
update

00:38:47,440 --> 00:38:53,280
yeah so there are there are two aspects

00:38:50,720 --> 00:38:55,200
to it when you see a failed ota update

00:38:53,280 --> 00:38:56,800
it basically takes into consideration

00:38:55,200 --> 00:38:59,520
that

00:38:56,800 --> 00:39:01,359
when did the failure happen and what was

00:38:59,520 --> 00:39:03,520
the reason behind that

00:39:01,359 --> 00:39:04,800
for example uh if there was a network

00:39:03,520 --> 00:39:07,440
issue or the

00:39:04,800 --> 00:39:08,079
the um the ot update during the attack

00:39:07,440 --> 00:39:11,359
process

00:39:08,079 --> 00:39:13,599
was interrupted it goes back um

00:39:11,359 --> 00:39:14,560
to where it started from by default for

00:39:13,599 --> 00:39:16,720
example

00:39:14,560 --> 00:39:18,480
we have also added a feature that will

00:39:16,720 --> 00:39:21,680
help you get started

00:39:18,480 --> 00:39:22,240
from where you left so um for example if

00:39:21,680 --> 00:39:25,040
you have

00:39:22,240 --> 00:39:26,640
your 50 through and you want to start

00:39:25,040 --> 00:39:28,000
all over again you can do it from there

00:39:26,640 --> 00:39:30,560
there's a new feature that we have just

00:39:28,000 --> 00:39:32,240
added but that is that is one of the uh

00:39:30,560 --> 00:39:35,440
one of the things but if you don't

00:39:32,240 --> 00:39:37,760
find um the um

00:39:35,440 --> 00:39:39,440
the failed ot updated you can find don't

00:39:37,760 --> 00:39:40,480
find any of these reasons because of

00:39:39,440 --> 00:39:41,920
that happening

00:39:40,480 --> 00:39:43,280
you need to go into i mean that's a

00:39:41,920 --> 00:39:45,200
tricky process you need to go into the

00:39:43,280 --> 00:39:47,680
device logs to see what was the reason

00:39:45,200 --> 00:39:50,800
for the failed um what you update

00:39:47,680 --> 00:39:53,920
um the normal um the

00:39:50,800 --> 00:39:56,560
the logs that we see on the cloud

00:39:53,920 --> 00:39:58,160
is basically whether the success it has

00:39:56,560 --> 00:40:00,720
been successfully completed

00:39:58,160 --> 00:40:01,520
or whether it's executing or it's failed

00:40:00,720 --> 00:40:03,760
but when you see

00:40:01,520 --> 00:40:05,440
failed you need to dig in further to see

00:40:03,760 --> 00:40:07,280
and look at the device logs to see

00:40:05,440 --> 00:40:08,480
what actually happened whether it was

00:40:07,280 --> 00:40:11,839
something else or

00:40:08,480 --> 00:40:11,839
you need to dig deeper so yeah

00:40:12,160 --> 00:40:16,160
excellent thanks all right everybody

00:40:14,560 --> 00:40:17,359
we've got about four more minutes before

00:40:16,160 --> 00:40:19,119
this session ends

00:40:17,359 --> 00:40:20,960
uh if there's any more questions please

00:40:19,119 --> 00:40:22,880
don't hesitate to push that into the

00:40:20,960 --> 00:40:26,160
keyway of the chat

00:40:22,880 --> 00:40:28,400
um and then coming up next at 3

00:40:26,160 --> 00:40:29,920
30 we'll have uh nathan collins and you

00:40:28,400 --> 00:40:31,760
can stay in here and then

00:40:29,920 --> 00:40:34,079
we'll transfer that over but up until

00:40:31,760 --> 00:40:38,000
then another great opportunity to pick

00:40:34,079 --> 00:40:39,520
uh picked anyways brain

00:40:38,000 --> 00:40:40,720
i've i've got a question for you tamara

00:40:39,520 --> 00:40:43,040
what are you uh what are you reading

00:40:40,720 --> 00:40:46,400
these days

00:40:43,040 --> 00:40:48,560
oh i'm reading a lot of things um uh

00:40:46,400 --> 00:40:49,920
especially for the reinvent conference

00:40:48,560 --> 00:40:53,599
that's coming up

00:40:49,920 --> 00:40:55,760
um so re invent is basically

00:40:53,599 --> 00:40:56,880
aws's annual conference that's going to

00:40:55,760 --> 00:41:01,119
start next month

00:40:56,880 --> 00:41:02,640
uh 11 30. and uh the seven also later

00:41:01,119 --> 00:41:04,720
chat here so we can all uh all

00:41:02,640 --> 00:41:06,000
participate

00:41:04,720 --> 00:41:07,760
but it looks like we got one other

00:41:06,000 --> 00:41:09,119
question that uh two questions come in

00:41:07,760 --> 00:41:10,400
so we got three minutes let's see if we

00:41:09,119 --> 00:41:12,319
can get through them here

00:41:10,400 --> 00:41:13,599
bill farrow asks do most firmware

00:41:12,319 --> 00:41:16,720
projects use 2x

00:41:13,599 --> 00:41:19,520
images one that you are running and the

00:41:16,720 --> 00:41:22,079
one that you were upgrading to

00:41:19,520 --> 00:41:23,200
that is that is that is exactly right um

00:41:22,079 --> 00:41:25,760
so

00:41:23,200 --> 00:41:27,680
we split into two partitions one is the

00:41:25,760 --> 00:41:28,400
formula that is currently uh being used

00:41:27,680 --> 00:41:30,480
and one is

00:41:28,400 --> 00:41:32,480
um that is being currently chunked and

00:41:30,480 --> 00:41:34,400
put together into a second partition

00:41:32,480 --> 00:41:36,480
so we recommend whenever you're choosing

00:41:34,400 --> 00:41:37,359
um a microcontroller for otps

00:41:36,480 --> 00:41:40,880
applications

00:41:37,359 --> 00:41:42,319
you use twice the twice twice the memory

00:41:40,880 --> 00:41:45,760
allocation

00:41:42,319 --> 00:41:45,760
because you need to store two images

00:41:46,240 --> 00:41:50,400
excellent and then one more we got two

00:41:48,880 --> 00:41:52,880
minutes left here

00:41:50,400 --> 00:41:54,000
uh which is the smallest development

00:41:52,880 --> 00:41:57,599
board we can use

00:41:54,000 --> 00:42:01,520
to text aws iot

00:41:57,599 --> 00:42:01,520
uh smallest i mean

00:42:01,599 --> 00:42:09,440
you have you have several options um

00:42:05,839 --> 00:42:10,480
one of the things um one of the things

00:42:09,440 --> 00:42:13,119
that you can do is

00:42:10,480 --> 00:42:13,599
uh we have seen several um so people

00:42:13,119 --> 00:42:16,560
using

00:42:13,599 --> 00:42:17,760
esp32 as a starting point uh because it

00:42:16,560 --> 00:42:20,000
provides you a standpoint

00:42:17,760 --> 00:42:21,599
and we have seen nxp boards being used

00:42:20,000 --> 00:42:23,920
for several purposes

00:42:21,599 --> 00:42:25,920
uh but it's it's been we have seen a lot

00:42:23,920 --> 00:42:29,520
of customers using uh very different

00:42:25,920 --> 00:42:30,880
very many words for starting with it

00:42:29,520 --> 00:42:32,880
excellent so go check out the

00:42:30,880 --> 00:42:34,240
documentation there on that page

00:42:32,880 --> 00:42:35,920
all right two minutes let's see if we

00:42:34,240 --> 00:42:39,119
got the the

00:42:35,920 --> 00:42:42,800
few questions jumped in here uh question

00:42:39,119 --> 00:42:42,800
how do you upgrade the bootloader

00:42:43,200 --> 00:42:47,760
so um yeah this this is a process the

00:42:46,720 --> 00:42:49,920
bootloader is

00:42:47,760 --> 00:42:51,680
is from a microcontroller vendor and we

00:42:49,920 --> 00:42:52,880
do not upgrade the bootloader right now

00:42:51,680 --> 00:42:55,040
unless uh

00:42:52,880 --> 00:42:56,240
we need to specifically uh go into the

00:42:55,040 --> 00:42:59,599
form

00:42:56,240 --> 00:43:01,040
go into the device and upgrade the bsps

00:42:59,599 --> 00:43:04,480
so we use a bootloader from

00:43:01,040 --> 00:43:08,560
microcontroller vendors we uh

00:43:04,480 --> 00:43:08,560
using the ot update it's uh it's not

00:43:10,839 --> 00:43:14,560
done

00:43:12,480 --> 00:43:14,560

YouTube URL: https://www.youtube.com/watch?v=XjIMHT8F21s


