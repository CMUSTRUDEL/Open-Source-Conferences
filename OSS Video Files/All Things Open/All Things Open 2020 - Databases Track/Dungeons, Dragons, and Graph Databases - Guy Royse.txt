Title: Dungeons, Dragons, and Graph Databases - Guy Royse
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Databases Track
Description: 
	Presented by: Guy Royse, Redis Labs
Presented at All Things Open 2020 - Databases Track

Abstract: Are you an adventurer? Do you want gold? Experience? Levels? Of course you do! And where do you get these things? The dungeon, where else? That wonderful container of all things adventurous! But, unfortunately, dungeons aren't set up for the convenience of adventurers who wish to extract these fine things. It’s almost as if the dungeon master just made the dungeon up at random. And so you wander about and you get what you get.

But you’re also a developer. You could build a database of all the rooms with their shiny and monstrous content. Then you could query it and find the optimal route to get the gold and the experience and the levels. But how would you model this data and write these queries? The rooms. The corridors. The monsters. The sparkling hoozits. That’s a lot of entities to relate to each other. And that’s gonna be a monster of a SQL query. Whoa–look at that JOIN! Better get my text editor ready.

Or, you could use a graph database. A graph database allows you to model these relationships simply and intuitively with nodes and edges. Being schema-free, you can evolve your graph as you encounter new things such as traps or secret doors. And, using the Cypher query language, you can write elegant and easy to understand queries that find the best routes to get the stuff adventures desire most.

In this talk, I’ll use the aforementioned example to introduce you to the concepts of graph databases. I’ll compare how to solve this problem with a relational database and how a graph database makes it easier. I’ll show you how to query and modify your graph. And, as no talk would be complete without a live demo, I’ll do it all using a real-time procedurally generated random dungeon (I am a dungeon master after all).

So come, have a flagon of mead as you learn about graph databases, optimize your dungeon crawl, and equip another weapon in your quest for better software!
Captions: 
	00:00:05,359 --> 00:00:07,759
this is

00:00:05,920 --> 00:00:09,920
me i'm a developer advocate at redis

00:00:07,759 --> 00:00:11,040
labs uh here's my social information you

00:00:09,920 --> 00:00:14,719
can go check it out

00:00:11,040 --> 00:00:15,679
i've been a developer for um oh gosh a

00:00:14,719 --> 00:00:18,320
lot of years

00:00:15,679 --> 00:00:19,039
a couple decades and i've been playing d

00:00:18,320 --> 00:00:23,359
d for

00:00:19,039 --> 00:00:26,880
uh probably a decade more than that um

00:00:23,359 --> 00:00:29,679
and it's fun and you know so

00:00:26,880 --> 00:00:30,080
this is me right um but this is a talk

00:00:29,679 --> 00:00:32,800
about

00:00:30,080 --> 00:00:34,960
dungeons and dragons and graph databases

00:00:32,800 --> 00:00:37,200
and so i thought you know the standard

00:00:34,960 --> 00:00:38,399
you know guy royce developer redis labs

00:00:37,200 --> 00:00:39,840
social information

00:00:38,399 --> 00:00:41,440
please follow me on twitter stuff was

00:00:39,840 --> 00:00:43,200
was uh not enough

00:00:41,440 --> 00:00:45,039
and so i thought i'd share my character

00:00:43,200 --> 00:00:47,280
sheet uh

00:00:45,039 --> 00:00:48,320
this is me i'm a dwarf and bard level

00:00:47,280 --> 00:00:50,399
five

00:00:48,320 --> 00:00:51,760
um haven't you know i suppose

00:00:50,399 --> 00:00:53,039
technically i'm multi-class because i've

00:00:51,760 --> 00:00:54,399
been programming longer than i've been a

00:00:53,039 --> 00:00:55,680
developer advocate which is sort of a

00:00:54,399 --> 00:00:57,520
bard-like thing

00:00:55,680 --> 00:00:59,199
um i've got my abilities there you can

00:00:57,520 --> 00:01:01,199
see that i'm kind of average strength

00:00:59,199 --> 00:01:04,080
uh heartier than a little bit than

00:01:01,199 --> 00:01:05,600
normal i'm fat so i'm not very fast

00:01:04,080 --> 00:01:07,280
i'm not very smart or wise but my

00:01:05,600 --> 00:01:09,200
charisma is out of sight

00:01:07,280 --> 00:01:10,799
which means that this talk will be all

00:01:09,200 --> 00:01:12,400
sizzle and no steak

00:01:10,799 --> 00:01:14,000
so uh that will level set your

00:01:12,400 --> 00:01:15,520
expectations for the conference or for

00:01:14,000 --> 00:01:18,960
the talk

00:01:15,520 --> 00:01:22,159
um and you know as a d d player

00:01:18,960 --> 00:01:25,520
i've got a problem right

00:01:22,159 --> 00:01:27,360
uh i need to go into the dungeon

00:01:25,520 --> 00:01:28,640
and in the dungeon are the things that

00:01:27,360 --> 00:01:29,759
i'm looking for right there's a bunch of

00:01:28,640 --> 00:01:31,119
rooms and i want to try and hit all the

00:01:29,759 --> 00:01:33,200
rooms that i can i want to hit the rooms

00:01:31,119 --> 00:01:34,640
that make the most sense to hit

00:01:33,200 --> 00:01:37,040
and i want to figure out which rooms

00:01:34,640 --> 00:01:38,479
have the biggest monsters because maybe

00:01:37,040 --> 00:01:40,400
i want to maximize

00:01:38,479 --> 00:01:42,479
my experience points i want to farm the

00:01:40,400 --> 00:01:44,000
xp so i want to go to the room that has

00:01:42,479 --> 00:01:45,920
the big bad

00:01:44,000 --> 00:01:47,600
but i also want to maximize my treasure

00:01:45,920 --> 00:01:49,280
so that i can go out and

00:01:47,600 --> 00:01:50,880
up my gear so that i can get you know

00:01:49,280 --> 00:01:52,479
take my plus one sword and upgrade it to

00:01:50,880 --> 00:01:55,680
a plus two sword

00:01:52,479 --> 00:01:56,000
and so this is a problem right uh how do

00:01:55,680 --> 00:01:57,759
i

00:01:56,000 --> 00:02:00,000
find the best path through the dungeon

00:01:57,759 --> 00:02:02,719
how do i find the rooms to prioritize

00:02:00,000 --> 00:02:03,439
uh with the monsters that i want to uh

00:02:02,719 --> 00:02:06,719
to

00:02:03,439 --> 00:02:08,319
get the xp from and you know i thought

00:02:06,719 --> 00:02:08,800
well i'm a developer in addition to a

00:02:08,319 --> 00:02:10,479
gamer

00:02:08,800 --> 00:02:11,760
i'll just make a database with the

00:02:10,479 --> 00:02:13,120
dungeon and then i can query the

00:02:11,760 --> 00:02:14,800
database

00:02:13,120 --> 00:02:16,400
and so i thought well i could do that

00:02:14,800 --> 00:02:18,319
with a relational database

00:02:16,400 --> 00:02:19,760
uh but god that could be a monster of a

00:02:18,319 --> 00:02:22,480
sql statement

00:02:19,760 --> 00:02:23,360
um or i could check out this graph

00:02:22,480 --> 00:02:25,760
database thing

00:02:23,360 --> 00:02:26,640
and use a graph database and so that's

00:02:25,760 --> 00:02:28,000
what we're going to do today we're going

00:02:26,640 --> 00:02:30,720
to look at ways that we can

00:02:28,000 --> 00:02:32,239
build a dungeon and query uh paths

00:02:30,720 --> 00:02:33,200
through this dungeon and query things

00:02:32,239 --> 00:02:35,200
about the dungeon

00:02:33,200 --> 00:02:36,400
and we're going to use a use do it using

00:02:35,200 --> 00:02:38,080
a relational database and we're going to

00:02:36,400 --> 00:02:39,440
do it using a graph database we're going

00:02:38,080 --> 00:02:39,840
to compare and contrast you can kind of

00:02:39,440 --> 00:02:43,360
see

00:02:39,840 --> 00:02:46,160
how they work and so

00:02:43,360 --> 00:02:48,840
you know there's an obvious question

00:02:46,160 --> 00:02:52,959
what the heck's a graph database

00:02:48,840 --> 00:02:56,160
um and this is a good point for me

00:02:52,959 --> 00:02:57,680
to stop and say i uh i'm not an expert

00:02:56,160 --> 00:02:58,959
on graph databases i'm not really an

00:02:57,680 --> 00:02:59,920
expert on anything i tend to be a

00:02:58,959 --> 00:03:02,080
generalist

00:02:59,920 --> 00:03:04,080
uh but i am definitely a fan of graph

00:03:02,080 --> 00:03:06,560
databases i just think they're neat

00:03:04,080 --> 00:03:07,920
and so um when we talk about what's a

00:03:06,560 --> 00:03:10,560
graph database

00:03:07,920 --> 00:03:11,280
uh keep that in mind you know so i i can

00:03:10,560 --> 00:03:12,959
answer the

00:03:11,280 --> 00:03:14,560
the the easy questions but there's deep

00:03:12,959 --> 00:03:15,200
deep questions that deep experts can

00:03:14,560 --> 00:03:16,800
answer that

00:03:15,200 --> 00:03:18,640
i can't answer i'm not i'm never an

00:03:16,800 --> 00:03:18,959
expert i actually i hate the word expert

00:03:18,640 --> 00:03:21,599
because

00:03:18,959 --> 00:03:22,239
expert says so much and it doesn't say

00:03:21,599 --> 00:03:24,319
anything at all

00:03:22,239 --> 00:03:26,000
and you know anyone ever calls you an

00:03:24,319 --> 00:03:28,879
expert i'm

00:03:26,000 --> 00:03:30,080
you know there's that sense of i'm not

00:03:28,879 --> 00:03:31,519
actually an expert why do they think i'm

00:03:30,080 --> 00:03:32,799
an expert and the imposter syndrome

00:03:31,519 --> 00:03:36,000
kicks in right

00:03:32,799 --> 00:03:37,680
um but what's a graph database well in

00:03:36,000 --> 00:03:40,400
order to understand graph database we

00:03:37,680 --> 00:03:42,799
need to understand what's a graph

00:03:40,400 --> 00:03:43,519
um that's that's that's the underlying

00:03:42,799 --> 00:03:47,040
question

00:03:43,519 --> 00:03:50,400
and a graph is a mathematical structure

00:03:47,040 --> 00:03:53,760
uh it's made up of nodes or vertices and

00:03:50,400 --> 00:03:55,280
relationships or edges um and it can

00:03:53,760 --> 00:03:56,560
represent lots of things so this dye 20

00:03:55,280 --> 00:03:58,080
that we have on the screen here and the

00:03:56,560 --> 00:04:02,239
one i have in my hand

00:03:58,080 --> 00:04:04,799
is a graph the vertex

00:04:02,239 --> 00:04:07,040
is the points on that thing right that's

00:04:04,799 --> 00:04:10,159
the point on this di20

00:04:07,040 --> 00:04:11,599
uh the edge is well it's the thing that

00:04:10,159 --> 00:04:13,200
connects all the points the all the

00:04:11,599 --> 00:04:15,519
vertices together

00:04:13,200 --> 00:04:16,880
and so you've got a vertices and they're

00:04:15,519 --> 00:04:18,799
related to each other or connected to

00:04:16,880 --> 00:04:20,639
each other via edges

00:04:18,799 --> 00:04:22,240
and uh you know of course this works

00:04:20,639 --> 00:04:24,240
great for platonic solids

00:04:22,240 --> 00:04:26,080
uh you know polygons on a piece of paper

00:04:24,240 --> 00:04:28,080
you can think of it geometrically

00:04:26,080 --> 00:04:29,120
but it doesn't have to be geometry uh

00:04:28,080 --> 00:04:32,720
these can be

00:04:29,120 --> 00:04:35,360
as many dimensions or non-dimensional

00:04:32,720 --> 00:04:36,080
dimensionality is actually not really

00:04:35,360 --> 00:04:37,680
related to

00:04:36,080 --> 00:04:39,360
a graph necessarily unless you want it

00:04:37,680 --> 00:04:42,800
to be um

00:04:39,360 --> 00:04:44,800
they're really just nodes connected via

00:04:42,800 --> 00:04:47,120
relationships or vertices connected via

00:04:44,800 --> 00:04:47,120
edges

00:04:47,199 --> 00:04:52,880
the simplest graph is the null graph

00:04:50,320 --> 00:04:54,240
this is a graph that has no nodes and it

00:04:52,880 --> 00:04:56,320
has no edges

00:04:54,240 --> 00:04:57,919
no vertices no nodes no edges no

00:04:56,320 --> 00:05:02,000
relationships there's nothing in it

00:04:57,919 --> 00:05:03,840
nothing to see here move along um

00:05:02,000 --> 00:05:05,199
so that's a boring graph let's go do

00:05:03,840 --> 00:05:08,160
something more interesting

00:05:05,199 --> 00:05:08,800
let's add some nodes to our graph so now

00:05:08,160 --> 00:05:12,320
we've got

00:05:08,800 --> 00:05:14,479
um here nodes a through g

00:05:12,320 --> 00:05:16,320
this is a perfectly valid graph it's

00:05:14,479 --> 00:05:20,240
just points hanging space

00:05:16,320 --> 00:05:23,199
there's it's all vertices no uh edges

00:05:20,240 --> 00:05:24,560
but it's still a perfectly valid graph

00:05:23,199 --> 00:05:25,680
if you want to relate some of these

00:05:24,560 --> 00:05:28,400
things to each other

00:05:25,680 --> 00:05:29,199
you can add some relationships and now

00:05:28,400 --> 00:05:30,720
we've got

00:05:29,199 --> 00:05:32,400
something that's looking more of what we

00:05:30,720 --> 00:05:33,919
think of when we think of a graph right

00:05:32,400 --> 00:05:35,600
we've got some of these nodes are

00:05:33,919 --> 00:05:36,720
connected to each other node a is

00:05:35,600 --> 00:05:38,960
connected to node c

00:05:36,720 --> 00:05:40,000
and node d node e is out there all by

00:05:38,960 --> 00:05:42,639
its lonesome

00:05:40,000 --> 00:05:44,720
it's listening to paul simon saying no

00:05:42,639 --> 00:05:47,919
man is an island or something like that

00:05:44,720 --> 00:05:52,000
um i am a rock i am an island

00:05:47,919 --> 00:05:55,759
that's node e out there um

00:05:52,000 --> 00:05:57,600
so this is more graph-like but it's

00:05:55,759 --> 00:05:59,600
got some of these this this node he's

00:05:57,600 --> 00:06:01,680
he's isolated right there's no

00:05:59,600 --> 00:06:02,639
relationships to it it's just out on its

00:06:01,680 --> 00:06:04,479
own

00:06:02,639 --> 00:06:06,240
and actually uh all the parts of this

00:06:04,479 --> 00:06:08,160
graph are isolated because they're not

00:06:06,240 --> 00:06:11,759
connected completely to each other

00:06:08,160 --> 00:06:14,240
so uh this node b and f are isolated

00:06:11,759 --> 00:06:15,840
uh to each other as well they're to the

00:06:14,240 --> 00:06:17,600
larger graph as well and even the big

00:06:15,840 --> 00:06:18,960
part in the middle that's isolated too

00:06:17,600 --> 00:06:20,479
it being big doesn't mean it's any less

00:06:18,960 --> 00:06:21,759
isolated it just means it doesn't have a

00:06:20,479 --> 00:06:25,199
path connecting it to

00:06:21,759 --> 00:06:27,440
the rest of the graph to the rest of the

00:06:25,199 --> 00:06:31,199
nodes of course let's connect all the

00:06:27,440 --> 00:06:31,199
nodes and now we have a connected graph

00:06:31,280 --> 00:06:34,560
and a connected graph means that all of

00:06:32,960 --> 00:06:37,199
the nodes are connected to

00:06:34,560 --> 00:06:39,680
at least one other node and there's a

00:06:37,199 --> 00:06:43,039
path from any node to any node

00:06:39,680 --> 00:06:44,800
so node d can get to node f whereas

00:06:43,039 --> 00:06:47,440
before it couldn't

00:06:44,800 --> 00:06:48,880
and by way of a and b so it's connected

00:06:47,440 --> 00:06:50,800
you can also have a fully connected

00:06:48,880 --> 00:06:52,479
graph where literally every node is

00:06:50,800 --> 00:06:56,080
connected to every node

00:06:52,479 --> 00:06:58,400
um and i mean that's sort of the uh

00:06:56,080 --> 00:07:00,080
n times n minus one number of

00:06:58,400 --> 00:07:01,520
relationships in a network

00:07:00,080 --> 00:07:02,960
right you know networks tend to work

00:07:01,520 --> 00:07:04,400
that way i have a computer on the

00:07:02,960 --> 00:07:05,759
internet right now it can connect to any

00:07:04,400 --> 00:07:07,599
computer on the internet

00:07:05,759 --> 00:07:08,880
and so that's the number of and every

00:07:07,599 --> 00:07:12,000
node on the internet can do that so

00:07:08,880 --> 00:07:15,440
that's a fully connected graph

00:07:12,000 --> 00:07:17,280
um this graph is undirected

00:07:15,440 --> 00:07:18,560
what's undirected mean well that means

00:07:17,280 --> 00:07:21,520
the relationships between

00:07:18,560 --> 00:07:22,240
a and b and b and c and all the all the

00:07:21,520 --> 00:07:25,280
nodes

00:07:22,240 --> 00:07:26,960
don't have any um

00:07:25,280 --> 00:07:28,479
uh direction to them there's no

00:07:26,960 --> 00:07:30,479
directionality

00:07:28,479 --> 00:07:32,000
so a and b are related to each other but

00:07:30,479 --> 00:07:33,199
there's no additional information

00:07:32,000 --> 00:07:34,880
showing the direction of that

00:07:33,199 --> 00:07:35,840
relationship to say that a is connected

00:07:34,880 --> 00:07:39,120
to b

00:07:35,840 --> 00:07:41,440
but b isn't connected to a a

00:07:39,120 --> 00:07:42,639
directed graph solves that problem i

00:07:41,440 --> 00:07:44,080
mean we just put arrows on them that's

00:07:42,639 --> 00:07:44,879
all we do right it's just an extra bit

00:07:44,080 --> 00:07:46,960
of information

00:07:44,879 --> 00:07:48,960
on the graph instead of a and b related

00:07:46,960 --> 00:07:52,080
now we know that a

00:07:48,960 --> 00:07:53,840
relates to b but b doesn't relate to a

00:07:52,080 --> 00:07:55,680
and so this creates some directionality

00:07:53,840 --> 00:07:57,759
in that graph it's a directed graph

00:07:55,680 --> 00:08:00,800
uh graph databases the ones we're going

00:07:57,759 --> 00:08:00,800
to look at are directed

00:08:01,599 --> 00:08:05,360
when we're talking about nodes in a

00:08:03,440 --> 00:08:08,240
graph

00:08:05,360 --> 00:08:09,360
we can talk about degrees the degree of

00:08:08,240 --> 00:08:12,000
a node

00:08:09,360 --> 00:08:13,759
is the number of relationships it has if

00:08:12,000 --> 00:08:15,759
this is an undirected graph then that's

00:08:13,759 --> 00:08:17,680
just the number of relationships it has

00:08:15,759 --> 00:08:18,800
if it's a directed graph it's the number

00:08:17,680 --> 00:08:21,520
of relationships it has

00:08:18,800 --> 00:08:23,039
in or out so node a has a degree of

00:08:21,520 --> 00:08:26,160
three because it connects to

00:08:23,039 --> 00:08:29,039
b and d and c connects to it

00:08:26,160 --> 00:08:30,000
and we can subdivide that into an out

00:08:29,039 --> 00:08:31,919
degree

00:08:30,000 --> 00:08:33,519
and an in degree which is how many

00:08:31,919 --> 00:08:35,200
relationships we had heading out

00:08:33,519 --> 00:08:37,599
and how many relationships we have

00:08:35,200 --> 00:08:40,880
coming in

00:08:37,599 --> 00:08:42,880
and so like uh in our um our fully

00:08:40,880 --> 00:08:45,680
disconnected graph

00:08:42,880 --> 00:08:46,320
uh all the nodes had a degree of zero

00:08:45,680 --> 00:08:48,160
and here's

00:08:46,320 --> 00:08:50,080
we some of them have an in degree or an

00:08:48,160 --> 00:08:52,480
out degree of zero it's like node f

00:08:50,080 --> 00:08:53,839
or node e even has an out degree of zero

00:08:52,480 --> 00:08:56,080
and an in degree of 1.

00:08:53,839 --> 00:08:59,839
so it's just a way of talking about the

00:08:56,080 --> 00:09:01,920
degrees of nodes within a graph

00:08:59,839 --> 00:09:03,360
and there really aren't any rules about

00:09:01,920 --> 00:09:03,839
how these relationships can work and i

00:09:03,360 --> 00:09:04,880
kind of

00:09:03,839 --> 00:09:07,680
talked about earlier it doesn't have to

00:09:04,880 --> 00:09:10,080
be a platonic solid

00:09:07,680 --> 00:09:11,920
it doesn't have to map to any particular

00:09:10,080 --> 00:09:13,920
dimensionality at all

00:09:11,920 --> 00:09:15,360
um we write them on paper because it's

00:09:13,920 --> 00:09:17,120
convenient not because it's

00:09:15,360 --> 00:09:18,640
mathematically necessary

00:09:17,120 --> 00:09:20,560
and so you can have nodes that connect

00:09:18,640 --> 00:09:22,240
to each other so here we got a and b

00:09:20,560 --> 00:09:24,320
connecting to each other

00:09:22,240 --> 00:09:25,920
you can have nodes connect to itself so

00:09:24,320 --> 00:09:29,440
a has a relationship

00:09:25,920 --> 00:09:33,360
with itself i guess

00:09:29,440 --> 00:09:33,360
it's trying to be an island as well

00:09:33,839 --> 00:09:37,360
and so there really aren't any rules

00:09:35,519 --> 00:09:38,160
about what can connect to what no there

00:09:37,360 --> 00:09:42,080
are rules but

00:09:38,160 --> 00:09:44,000
um not a lot of them right

00:09:42,080 --> 00:09:45,120
you know and uh relationships have to

00:09:44,000 --> 00:09:46,720
connect nodes together that's by

00:09:45,120 --> 00:09:49,600
definition what they do

00:09:46,720 --> 00:09:50,640
but uh they can connect to themselves

00:09:49,600 --> 00:09:52,480
they can connect to the same thing

00:09:50,640 --> 00:09:53,120
multiple times so a to b can be

00:09:52,480 --> 00:09:56,080
connected to b

00:09:53,120 --> 00:09:59,519
five times doesn't matter no rules don't

00:09:56,080 --> 00:09:59,519
tell me how to build my graph

00:09:59,600 --> 00:10:03,760
so that's what a graph is a graph

00:10:02,079 --> 00:10:05,760
database

00:10:03,760 --> 00:10:06,959
is when we start laying data over top of

00:10:05,760 --> 00:10:10,720
it

00:10:06,959 --> 00:10:12,720
so here we have a uh that same graph but

00:10:10,720 --> 00:10:14,880
now uh these nodes aren't just

00:10:12,720 --> 00:10:16,480
abstract letters uh they're actually

00:10:14,880 --> 00:10:18,959
aspects of our dungeon here

00:10:16,480 --> 00:10:19,600
we've got some rooms uh that are in gray

00:10:18,959 --> 00:10:21,200
there

00:10:19,600 --> 00:10:22,720
we've got some monsters in red we've got

00:10:21,200 --> 00:10:25,200
some treasure

00:10:22,720 --> 00:10:26,720
in gold and so there's a little more

00:10:25,200 --> 00:10:28,720
information we're laying some data over

00:10:26,720 --> 00:10:30,800
top this graph structure

00:10:28,720 --> 00:10:32,000
and in fact we can give each of these

00:10:30,800 --> 00:10:34,240
things a label

00:10:32,000 --> 00:10:35,839
and attributes and so uh that first room

00:10:34,240 --> 00:10:37,920
there is the statue room

00:10:35,839 --> 00:10:40,240
because it's got a property an attribute

00:10:37,920 --> 00:10:44,399
of name which is the statue room

00:10:40,240 --> 00:10:46,800
uh it contains a monster named alice

00:10:44,399 --> 00:10:47,839
it has a relationship to a monster named

00:10:46,800 --> 00:10:50,240
alice

00:10:47,839 --> 00:10:51,279
alice the elf uh with a challenge rating

00:10:50,240 --> 00:10:54,640
of seven and

00:10:51,279 --> 00:10:56,640
350 experience points and so uh we can

00:10:54,640 --> 00:10:58,640
put these attributes on these nodes

00:10:56,640 --> 00:11:01,040
and uh the relationships themselves can

00:10:58,640 --> 00:11:06,480
be labeled or typed

00:11:01,040 --> 00:11:08,800
and so um the room contains a monster

00:11:06,480 --> 00:11:10,000
a room leads to another room and so

00:11:08,800 --> 00:11:12,000
these

00:11:10,000 --> 00:11:14,000
uh are extra data so the nodes can have

00:11:12,000 --> 00:11:17,200
data and uh the

00:11:14,000 --> 00:11:17,839
relationships can have data and this is

00:11:17,200 --> 00:11:20,720
a

00:11:17,839 --> 00:11:21,200
database worthy of mordor right uh this

00:11:20,720 --> 00:11:22,640
this is

00:11:21,200 --> 00:11:24,240
how this is what a graph database is

00:11:22,640 --> 00:11:25,839
it's that graph structure with data laid

00:11:24,240 --> 00:11:27,360
over top of it

00:11:25,839 --> 00:11:28,880
uh the nodes and relationships in a

00:11:27,360 --> 00:11:32,480
database

00:11:28,880 --> 00:11:34,560
excuse me the nodes tend to represent

00:11:32,480 --> 00:11:35,519
items or nouns i tend to think of them

00:11:34,560 --> 00:11:37,040
as nouns

00:11:35,519 --> 00:11:38,240
uh they have labels and they can have

00:11:37,040 --> 00:11:39,440
attributes they can actually have more

00:11:38,240 --> 00:11:42,880
than one label

00:11:39,440 --> 00:11:43,360
um so a node could be simultaneously a

00:11:42,880 --> 00:11:47,120
room

00:11:43,360 --> 00:11:48,720
and a chamber maybe um

00:11:47,120 --> 00:11:50,800
or it could be maybe a room and a

00:11:48,720 --> 00:11:52,320
corridor maybe you could do something

00:11:50,800 --> 00:11:53,360
like that so they could be more than one

00:11:52,320 --> 00:11:55,600
thing

00:11:53,360 --> 00:11:57,279
and uh nodes because they're nodes in a

00:11:55,600 --> 00:12:00,480
graph can be all by themselves they

00:11:57,279 --> 00:12:03,519
don't need relationships to work

00:12:00,480 --> 00:12:06,720
the relationships uh connect two nodes

00:12:03,519 --> 00:12:10,959
and they have a type like contains or

00:12:06,720 --> 00:12:13,040
leads to and they have a direction

00:12:10,959 --> 00:12:14,639
which we've already seen and they can

00:12:13,040 --> 00:12:16,399
also have attributes as well

00:12:14,639 --> 00:12:18,320
i generally don't put attributes on my

00:12:16,399 --> 00:12:20,000
relationships i find if i have an urge

00:12:18,320 --> 00:12:22,079
to put attributes on my relationships it

00:12:20,000 --> 00:12:24,000
probably means it's a node

00:12:22,079 --> 00:12:25,360
uh that's been what i've that's the

00:12:24,000 --> 00:12:27,279
pattern or the sort of the rule of thumb

00:12:25,360 --> 00:12:28,480
i've discovered so far

00:12:27,279 --> 00:12:29,839
uh but the most important thing about

00:12:28,480 --> 00:12:32,000
relationships is they can't exist

00:12:29,839 --> 00:12:34,720
without a node to connect to

00:12:32,000 --> 00:12:36,560
so uh if you delete a node like say you

00:12:34,720 --> 00:12:41,279
delete this vertex right here on this uh

00:12:36,560 --> 00:12:44,399
di20 then all the connections to it

00:12:41,279 --> 00:12:46,639
go away because there's nothing for them

00:12:44,399 --> 00:12:49,040
to connect to by definition

00:12:46,639 --> 00:12:49,839
an edge must connect two vertices a

00:12:49,040 --> 00:12:51,279
relationship

00:12:49,839 --> 00:12:53,120
connects two nodes and if one of those

00:12:51,279 --> 00:12:54,720
nodes goes away the relationship

00:12:53,120 --> 00:12:56,160
doesn't exist anymore because the thing

00:12:54,720 --> 00:12:59,440
it would exist with is gone

00:12:56,160 --> 00:13:00,639
and so those go away um and so that's

00:12:59,440 --> 00:13:01,600
important when you if you go deleting

00:13:00,639 --> 00:13:02,399
nodes you're like do i have to delete

00:13:01,600 --> 00:13:04,480
the relationship

00:13:02,399 --> 00:13:07,839
as well nope that'll go away on its own

00:13:04,480 --> 00:13:07,839
no problem

00:13:08,399 --> 00:13:12,000
and i think uh if you think about these

00:13:10,720 --> 00:13:13,040
relationships they kind of read like a

00:13:12,000 --> 00:13:15,120
sentence

00:13:13,040 --> 00:13:17,120
i hinted at this when i said they're um

00:13:15,120 --> 00:13:18,560
they're like a noun

00:13:17,120 --> 00:13:21,440
and and the relationships as it turns

00:13:18,560 --> 00:13:23,440
out are kind of like verbs

00:13:21,440 --> 00:13:24,720
and so here we have a room uh that

00:13:23,440 --> 00:13:26,240
contains a monster

00:13:24,720 --> 00:13:28,639
so the room contains a monster that

00:13:26,240 --> 00:13:30,800
reads like a sentence you know you got

00:13:28,639 --> 00:13:32,639
the subject the sentence is the room uh

00:13:30,800 --> 00:13:34,320
contains is a transitive verb

00:13:32,639 --> 00:13:36,160
and then monster is the direct object

00:13:34,320 --> 00:13:37,279
the room contains a monster

00:13:36,160 --> 00:13:39,920
you can actually flip this

00:13:37,279 --> 00:13:43,040
directionality and say the monster

00:13:39,920 --> 00:13:44,240
is contained by a room but then we're

00:13:43,040 --> 00:13:46,639
using the passive voice

00:13:44,240 --> 00:13:48,959
and as my english teacher taught me the

00:13:46,639 --> 00:13:50,800
passive voice is to be avoided

00:13:48,959 --> 00:13:53,519
so we're not going to do that makes it

00:13:50,800 --> 00:13:53,519
more confusing

00:13:54,160 --> 00:14:00,480
so that's the theory around graph and

00:13:56,000 --> 00:14:02,560
graph database let's uh get into uh

00:14:00,480 --> 00:14:03,680
you know the fact that we still have a

00:14:02,560 --> 00:14:05,519
problem that we want to solve

00:14:03,680 --> 00:14:07,279
so russell is asking can a relationship

00:14:05,519 --> 00:14:08,639
have multiple directions

00:14:07,279 --> 00:14:10,560
symmetrical or would that just be an

00:14:08,639 --> 00:14:12,000
indirect relationship at that point

00:14:10,560 --> 00:14:13,839
um you would just do a second

00:14:12,000 --> 00:14:15,920
relationship so uh

00:14:13,839 --> 00:14:17,760
node a connects is got a directionality

00:14:15,920 --> 00:14:19,199
to node b and then node b connects

00:14:17,760 --> 00:14:22,160
to node a and those are just two

00:14:19,199 --> 00:14:22,160
separate relationships

00:14:22,240 --> 00:14:24,800
and i think we're going to get some

00:14:23,199 --> 00:14:26,320
white noise in the background my furnace

00:14:24,800 --> 00:14:27,760
just kicked on because i'm in ohio and

00:14:26,320 --> 00:14:31,360
it's cold here

00:14:27,760 --> 00:14:34,079
so apologies for that um

00:14:31,360 --> 00:14:36,399
so uh enough theory we've still got a

00:14:34,079 --> 00:14:36,399
problem

00:14:36,800 --> 00:14:41,519
and that problem is that we want to find

00:14:38,639 --> 00:14:43,120
the rooms with the monsters and the gold

00:14:41,519 --> 00:14:45,120
and so how are we gonna solve this

00:14:43,120 --> 00:14:47,279
problem well we could

00:14:45,120 --> 00:14:49,279
do it with our relational database with

00:14:47,279 --> 00:14:50,959
the tables and the joins and the rows

00:14:49,279 --> 00:14:53,279
and the columns

00:14:50,959 --> 00:14:54,399
or we can do it with a graph database

00:14:53,279 --> 00:14:55,839
with the uh

00:14:54,399 --> 00:14:58,959
the nodes and the connections and the

00:14:55,839 --> 00:15:00,720
attributes and the labels

00:14:58,959 --> 00:15:02,480
and uh i'm going to go on a limb here

00:15:00,720 --> 00:15:03,839
and say that you probably have used a

00:15:02,480 --> 00:15:06,000
relational database at some point in

00:15:03,839 --> 00:15:09,040
your career

00:15:06,000 --> 00:15:11,519
it's a really common paradigm it's it's

00:15:09,040 --> 00:15:13,120
you know relate relational databases sql

00:15:11,519 --> 00:15:14,560
is the only language that i used

00:15:13,120 --> 00:15:16,160
that i learned in college that i still

00:15:14,560 --> 00:15:18,800
use in my job

00:15:16,160 --> 00:15:20,160
all right not a lot of them stick around

00:15:18,800 --> 00:15:21,839
that long have that longevity so

00:15:20,160 --> 00:15:24,160
relational databases are a thing you've

00:15:21,839 --> 00:15:26,000
probably touched it but

00:15:24,160 --> 00:15:27,360
when we do relational databases and when

00:15:26,000 --> 00:15:29,279
we talk to relational ideas when we

00:15:27,360 --> 00:15:32,399
query a relational database

00:15:29,279 --> 00:15:34,079
uh what we do is we use sql or sql

00:15:32,399 --> 00:15:37,040
depending on how you want to say it

00:15:34,079 --> 00:15:38,560
i will say both and we've got a basic

00:15:37,040 --> 00:15:40,160
select statement here that's selecting

00:15:38,560 --> 00:15:41,279
all the rooms and the treasures and

00:15:40,160 --> 00:15:43,440
monsters they're in

00:15:41,279 --> 00:15:45,199
and does a join all right so this is

00:15:43,440 --> 00:15:48,160
this is the language we use to query

00:15:45,199 --> 00:15:48,160
relational databases

00:15:50,079 --> 00:15:53,519
to query a graph database we're going to

00:15:51,920 --> 00:15:54,560
use a query language you might not be

00:15:53,519 --> 00:15:58,240
familiar with

00:15:54,560 --> 00:16:01,839
and that's called cipher cipher is a

00:15:58,240 --> 00:16:05,120
well it's sort of like the sql for uh

00:16:01,839 --> 00:16:06,800
for graph databases and it's in some

00:16:05,120 --> 00:16:09,839
ways has some similarities but

00:16:06,800 --> 00:16:11,680
has a lot of differences uh and the key

00:16:09,839 --> 00:16:13,759
thing that's different about cipher

00:16:11,680 --> 00:16:16,320
is that it does this has this matching

00:16:13,759 --> 00:16:16,320
syntax

00:16:16,399 --> 00:16:19,600
and so here we have the room that

00:16:17,839 --> 00:16:22,320
contains the monster

00:16:19,600 --> 00:16:23,600
and this matching syntax is the part of

00:16:22,320 --> 00:16:25,680
cipher that kind of looks like a cross

00:16:23,600 --> 00:16:28,399
between a query language

00:16:25,680 --> 00:16:29,360
and ascii art for lack of a better

00:16:28,399 --> 00:16:32,000
description

00:16:29,360 --> 00:16:34,399
so here we've got uh if we look again

00:16:32,000 --> 00:16:37,199
this little thing here matches a room

00:16:34,399 --> 00:16:38,399
right it's got parentheses which are

00:16:37,199 --> 00:16:39,279
round kind of like how we've been

00:16:38,399 --> 00:16:42,240
drawing

00:16:39,279 --> 00:16:43,680
uh the uh the nodes on our diagrams so

00:16:42,240 --> 00:16:44,959
those parentheses sort of suggest that

00:16:43,680 --> 00:16:46,880
roundness that we think of when we think

00:16:44,959 --> 00:16:50,560
of nodes in a graph

00:16:46,880 --> 00:16:54,079
and the colon room part uh says match a

00:16:50,560 --> 00:16:55,759
node that has a label of room

00:16:54,079 --> 00:16:58,480
and the r assigns it to a variable that

00:16:55,759 --> 00:16:58,480
we can use later

00:16:59,120 --> 00:17:02,320
same thing for the monster here we're

00:17:00,560 --> 00:17:03,600
matching a monster again you've got

00:17:02,320 --> 00:17:06,319
those parentheses

00:17:03,600 --> 00:17:08,400
that roundness that suggests the node uh

00:17:06,319 --> 00:17:11,439
we're looking for a label of monster

00:17:08,400 --> 00:17:13,520
assigning that to a value m

00:17:11,439 --> 00:17:14,880
and in the middle here we have an arrow

00:17:13,520 --> 00:17:18,880
right it's it's got

00:17:14,880 --> 00:17:20,160
square brackets um for the type of that

00:17:18,880 --> 00:17:22,160
relationship

00:17:20,160 --> 00:17:23,280
and we assign that that relationship to

00:17:22,160 --> 00:17:24,799
a variable c

00:17:23,280 --> 00:17:26,559
but it's got a little arrow there that

00:17:24,799 --> 00:17:29,440
shows you the directionality so it kind

00:17:26,559 --> 00:17:31,280
of looks like the way we would draw this

00:17:29,440 --> 00:17:33,280
and so it's it's got that ascii art like

00:17:31,280 --> 00:17:36,799
quality to it which i i think makes it

00:17:33,280 --> 00:17:37,120
frankly very very intuitive and so but

00:17:36,799 --> 00:17:39,280
this

00:17:37,120 --> 00:17:40,960
this matching pattern is a way of going

00:17:39,280 --> 00:17:43,440
through the graph and saying

00:17:40,960 --> 00:17:45,120
walk through the graph and find patterns

00:17:43,440 --> 00:17:46,720
in the graph that match

00:17:45,120 --> 00:17:48,559
the pattern i provided you that's why

00:17:46,720 --> 00:17:50,880
it's called a matching expression

00:17:48,559 --> 00:17:52,320
um and so this particular match would

00:17:50,880 --> 00:17:54,559
match any room

00:17:52,320 --> 00:17:56,480
that contains a monster and so if we had

00:17:54,559 --> 00:17:57,840
like say five rooms and five monsters

00:17:56,480 --> 00:17:59,200
and there's a monster in each room it

00:17:57,840 --> 00:18:01,679
would give us five results

00:17:59,200 --> 00:18:03,039
if we had a room that had five monsters

00:18:01,679 --> 00:18:04,720
we would also get five results because

00:18:03,039 --> 00:18:07,360
we get the room and the monster for

00:18:04,720 --> 00:18:07,840
each one and it would mat and those are

00:18:07,360 --> 00:18:10,960
all the

00:18:07,840 --> 00:18:11,679
paths or the structures in the database

00:18:10,960 --> 00:18:15,679
that match

00:18:11,679 --> 00:18:19,440
the match so we're going to look at

00:18:15,679 --> 00:18:19,840
uh crud operations the create read

00:18:19,440 --> 00:18:21,679
update

00:18:19,840 --> 00:18:23,440
delete and how we would do that with a

00:18:21,679 --> 00:18:23,760
relational database and how we would do

00:18:23,440 --> 00:18:26,080
that

00:18:23,760 --> 00:18:29,440
in a graph database to show how cipher

00:18:26,080 --> 00:18:31,919
works in greater detail

00:18:29,440 --> 00:18:33,360
so um let's look at creating a record we

00:18:31,919 --> 00:18:36,880
always create first because

00:18:33,360 --> 00:18:38,960
then we have something to read so um

00:18:36,880 --> 00:18:40,880
for creating a room we would have a room

00:18:38,960 --> 00:18:43,039
table which with an id and a name we've

00:18:40,880 --> 00:18:45,679
got our statue room as our first room

00:18:43,039 --> 00:18:47,200
barracks in an armory every good dungeon

00:18:45,679 --> 00:18:49,600
starts with a statue room

00:18:47,200 --> 00:18:51,039
and you got to spell armory with a u so

00:18:49,600 --> 00:18:52,880
that it feels british and therefore more

00:18:51,039 --> 00:18:55,679
dungeons and dragons right

00:18:52,880 --> 00:18:56,160
um and so here we're just doing a basic

00:18:55,679 --> 00:18:58,240
uh

00:18:56,160 --> 00:18:59,600
sql a statement that doesn't insert

00:18:58,240 --> 00:19:01,440
insert into the room

00:18:59,600 --> 00:19:03,360
the columns we want to mess with and the

00:19:01,440 --> 00:19:06,720
values for those columns

00:19:03,360 --> 00:19:09,200
uh this is sql 101

00:19:06,720 --> 00:19:12,080
uh to do that same or do an equivalent

00:19:09,200 --> 00:19:15,200
operation and graph to insert a node

00:19:12,080 --> 00:19:17,280
we use the create statement so we create

00:19:15,200 --> 00:19:18,880
a node notice the matching syntax we're

00:19:17,280 --> 00:19:20,720
saying create a node

00:19:18,880 --> 00:19:22,880
by using parentheses it knows it's a

00:19:20,720 --> 00:19:25,840
node and

00:19:22,880 --> 00:19:27,440
give it the label of room and then we'll

00:19:25,840 --> 00:19:28,320
assign that to r so we can do stuff with

00:19:27,440 --> 00:19:30,640
it later

00:19:28,320 --> 00:19:32,240
and that stuff later is set and so we

00:19:30,640 --> 00:19:34,400
will we have a set

00:19:32,240 --> 00:19:35,840
and then we do a comma delimited comma

00:19:34,400 --> 00:19:38,160
separated list of

00:19:35,840 --> 00:19:39,280
properties being set uh one interesting

00:19:38,160 --> 00:19:41,120
thing here is that

00:19:39,280 --> 00:19:43,600
the properties aren't baked into any

00:19:41,120 --> 00:19:45,440
schema graph doesn't have a schema

00:19:43,600 --> 00:19:47,120
and so we've got an id and a name that

00:19:45,440 --> 00:19:49,360
we're putting on this room uh

00:19:47,120 --> 00:19:51,120
id of one statutory room into the name

00:19:49,360 --> 00:19:52,240
but we could add another property called

00:19:51,120 --> 00:19:55,440
is trapped

00:19:52,240 --> 00:19:57,919
or uh contains

00:19:55,440 --> 00:19:59,760
uh mold or whatever whatever kind of

00:19:57,919 --> 00:20:00,799
dungeony thing you want to add to a room

00:19:59,760 --> 00:20:04,080
that would be a property

00:20:00,799 --> 00:20:07,440
or maybe the size and square foot square

00:20:04,080 --> 00:20:08,640
square feet um are actually being

00:20:07,440 --> 00:20:10,640
squares right this is d and d

00:20:08,640 --> 00:20:11,840
the size and hexes right because we're

00:20:10,640 --> 00:20:15,600
all doing hexes no

00:20:11,840 --> 00:20:17,919
not um but you could uh arbitrarily add

00:20:15,600 --> 00:20:19,679
properties here so there's no schema

00:20:17,919 --> 00:20:20,960
but we create that room creates a node

00:20:19,679 --> 00:20:22,080
if we stopped there and didn't do a set

00:20:20,960 --> 00:20:23,679
we'd have a

00:20:22,080 --> 00:20:25,600
node that's got the label room and

00:20:23,679 --> 00:20:26,960
that'd be it but with the set it adds

00:20:25,600 --> 00:20:28,480
extra properties to it or extra

00:20:26,960 --> 00:20:31,919
attributes

00:20:28,480 --> 00:20:31,919
so uh pretty easy

00:20:33,760 --> 00:20:38,880
so how do we read that room well in sql

00:20:36,799 --> 00:20:42,080
we use the classic select statement

00:20:38,880 --> 00:20:45,120
select columns from table where key

00:20:42,080 --> 00:20:46,000
equals value and this would give us the

00:20:45,120 --> 00:20:47,280
statue room

00:20:46,000 --> 00:20:49,679
if we want to get the statue room in a

00:20:47,280 --> 00:20:52,880
graph database uh we say

00:20:49,679 --> 00:20:54,240
match our colon room and so this again

00:20:52,880 --> 00:20:55,200
then we got this matching this node so

00:20:54,240 --> 00:20:57,280
match a node

00:20:55,200 --> 00:20:58,400
with a label of room put it in the

00:20:57,280 --> 00:20:59,760
variable r

00:20:58,400 --> 00:21:01,679
we did a crate before we're doing a

00:20:59,760 --> 00:21:02,880
match now and then we use a where clause

00:21:01,679 --> 00:21:04,480
to filter out

00:21:02,880 --> 00:21:06,000
because if you think about a graph if

00:21:04,480 --> 00:21:06,400
you've got a graph let's say 20 rooms in

00:21:06,000 --> 00:21:08,240
it

00:21:06,400 --> 00:21:10,559
our colon room is going to match all the

00:21:08,240 --> 00:21:12,880
rooms and so we filter it out

00:21:10,559 --> 00:21:14,240
uh to say no no filter that just give me

00:21:12,880 --> 00:21:17,039
the rooms where the id is one

00:21:14,240 --> 00:21:18,080
just give me the room number one and

00:21:17,039 --> 00:21:21,039
then we can return it

00:21:18,080 --> 00:21:24,159
we use return r and this will return the

00:21:21,039 --> 00:21:24,159
node and its attributes

00:21:25,679 --> 00:21:30,400
to update these rooms again on sql we

00:21:28,400 --> 00:21:34,000
have a classic update statement

00:21:30,400 --> 00:21:36,320
um update rooms set name equal to value

00:21:34,000 --> 00:21:37,760
where id equals one make sure you have

00:21:36,320 --> 00:21:40,480
the where clause on there otherwise all

00:21:37,760 --> 00:21:42,480
rooms are statue halls now

00:21:40,480 --> 00:21:43,679
in graph it's it's actually very similar

00:21:42,480 --> 00:21:45,120
and it's very similar to the previous

00:21:43,679 --> 00:21:46,000
one because again we're going to do a

00:21:45,120 --> 00:21:47,919
match where

00:21:46,000 --> 00:21:50,320
we're matching the room where the idea

00:21:47,919 --> 00:21:52,240
is one but instead of returning at this

00:21:50,320 --> 00:21:54,559
time we're going to set a property on it

00:21:52,240 --> 00:21:55,360
and so this would set or reset in this

00:21:54,559 --> 00:21:58,080
case the name

00:21:55,360 --> 00:21:59,600
from statue room to statue hall and you

00:21:58,080 --> 00:22:02,320
could also add additional properties

00:21:59,600 --> 00:22:02,320
this way as well

00:22:03,919 --> 00:22:07,280
and last but certainly not least

00:22:06,080 --> 00:22:09,919
everyone's favorite

00:22:07,280 --> 00:22:12,320
form of file compression deletion

00:22:09,919 --> 00:22:14,400
deletion is 100 file compression

00:22:12,320 --> 00:22:15,919
uh to delete uh from a relational

00:22:14,400 --> 00:22:19,760
database we delete from

00:22:15,919 --> 00:22:21,200
table where value key equals value

00:22:19,760 --> 00:22:22,559
so make sure that where clause is in

00:22:21,200 --> 00:22:23,440
there or you're going to be restoring

00:22:22,559 --> 00:22:27,760
from backups

00:22:23,440 --> 00:22:31,360
what you didn't have backups odos um

00:22:27,760 --> 00:22:33,039
in a graph in cypher again we're doing

00:22:31,360 --> 00:22:33,679
this match where you see this pattern a

00:22:33,039 --> 00:22:35,440
lot match

00:22:33,679 --> 00:22:37,360
where match work match this pattern

00:22:35,440 --> 00:22:39,520
filtering for value

00:22:37,360 --> 00:22:41,039
but instead of setting a value on what

00:22:39,520 --> 00:22:43,520
we return

00:22:41,039 --> 00:22:44,240
or instead of returning it we delete it

00:22:43,520 --> 00:22:47,039
and so

00:22:44,240 --> 00:22:48,080
we say match our coin room where r dot

00:22:47,039 --> 00:22:50,720
id equals one

00:22:48,080 --> 00:22:53,280
delete r that deletes the statue room

00:22:50,720 --> 00:22:56,559
bye bye

00:22:53,280 --> 00:22:58,080
so that's your basic crud operations for

00:22:56,559 --> 00:23:00,400
for nodes and we haven't talked about

00:22:58,080 --> 00:23:03,120
relationships yet we'll get to that

00:23:00,400 --> 00:23:04,720
um but there's a note here i want to

00:23:03,120 --> 00:23:06,880
talk about

00:23:04,720 --> 00:23:08,000
on those is uh where i'm using this

00:23:06,880 --> 00:23:10,000
syntax here where i say

00:23:08,000 --> 00:23:11,280
match r colon rooms where r dot id

00:23:10,000 --> 00:23:13,120
equals one

00:23:11,280 --> 00:23:15,440
uh there's another syntax you use for

00:23:13,120 --> 00:23:18,320
matching that doesn't use a where clause

00:23:15,440 --> 00:23:20,000
and use curly braces instead and do sort

00:23:18,320 --> 00:23:22,240
of a key value pairing

00:23:20,000 --> 00:23:25,039
much like a javascript object like a

00:23:22,240 --> 00:23:26,640
javascript object literal

00:23:25,039 --> 00:23:29,679
and you're saying well well you know

00:23:26,640 --> 00:23:31,200
match a room that has this attribute

00:23:29,679 --> 00:23:32,640
and if you can you can comma separate

00:23:31,200 --> 00:23:33,520
them for multiple attributes and get

00:23:32,640 --> 00:23:36,000
other things

00:23:33,520 --> 00:23:37,120
no problem that's another way of doing

00:23:36,000 --> 00:23:39,120
it without the where clause and then you

00:23:37,120 --> 00:23:41,840
just follow the sets or the deletes or

00:23:39,120 --> 00:23:41,840
whatever you want to do

00:23:42,799 --> 00:23:45,600
and you can use this with create as well

00:23:44,240 --> 00:23:47,039
instead of creating a room and then

00:23:45,600 --> 00:23:48,559
setting the ids

00:23:47,039 --> 00:23:52,159
you can create a room with the

00:23:48,559 --> 00:23:53,520
attributes you desire ahead of time

00:23:52,159 --> 00:23:55,600
and so then you don't need the following

00:23:53,520 --> 00:23:57,600
set

00:23:55,600 --> 00:23:59,919
so hopefully that makes sense so far

00:23:57,600 --> 00:24:01,520
this is just node manipulation

00:23:59,919 --> 00:24:03,039
and when we go to do this with monsters

00:24:01,520 --> 00:24:04,080
it's exactly the same pattern here you

00:24:03,039 --> 00:24:07,360
can see that i instead

00:24:04,080 --> 00:24:08,000
chose to do the uh the the other syntax

00:24:07,360 --> 00:24:09,840
here

00:24:08,000 --> 00:24:11,520
uh for the creations of monsters and

00:24:09,840 --> 00:24:12,799
treasure but it's exactly the same

00:24:11,520 --> 00:24:15,520
process we're just inserting

00:24:12,799 --> 00:24:15,520
records right

00:24:16,640 --> 00:24:20,720
so this is what our relational database

00:24:18,080 --> 00:24:22,559
looks like so far

00:24:20,720 --> 00:24:25,760
and uh this is uh what our graph

00:24:22,559 --> 00:24:25,760
database looks like so far

00:24:26,080 --> 00:24:29,840
so let's do something a little more

00:24:27,200 --> 00:24:31,919
sophisticated let's uh put a monster

00:24:29,840 --> 00:24:33,039
in a room we're gonna do that with a

00:24:31,919 --> 00:24:33,520
relational and we're gonna do that with

00:24:33,039 --> 00:24:35,279
graph

00:24:33,520 --> 00:24:36,799
so if we put a monster in a room with a

00:24:35,279 --> 00:24:38,799
relational database

00:24:36,799 --> 00:24:40,000
uh we've got a problem uh we don't have

00:24:38,799 --> 00:24:42,640
any way to do that

00:24:40,000 --> 00:24:44,320
and so we have to alter the table so we

00:24:42,640 --> 00:24:45,120
alter the monster table to add a new

00:24:44,320 --> 00:24:46,720
column

00:24:45,120 --> 00:24:49,440
to be the foreign key for the room that

00:24:46,720 --> 00:24:49,440
the monster's in

00:24:49,840 --> 00:24:52,880
and here we're updating the monsters

00:24:51,600 --> 00:24:56,559
then to uh

00:24:52,880 --> 00:24:57,919
set that foreign key um

00:24:56,559 --> 00:25:00,240
it looks like bobby ogre is supposed to

00:24:57,919 --> 00:25:01,840
be in room three but it says room two so

00:25:00,240 --> 00:25:03,520
ignore the fact that that's incorrect

00:25:01,840 --> 00:25:05,360
there

00:25:03,520 --> 00:25:07,279
but uh so we just update that table and

00:25:05,360 --> 00:25:08,720
this is a classic foreign key

00:25:07,279 --> 00:25:11,039
uh structure that creates a one to many

00:25:08,720 --> 00:25:15,520
in a relational database

00:25:11,039 --> 00:25:17,600
what's this look like in graph cipher

00:25:15,520 --> 00:25:18,880
well um we're going to create a

00:25:17,600 --> 00:25:22,400
relationship between the nodes

00:25:18,880 --> 00:25:23,840
and we do that by matching

00:25:22,400 --> 00:25:26,480
so we're going to match the node that we

00:25:23,840 --> 00:25:28,400
want to the two nodes that we want to

00:25:26,480 --> 00:25:29,520
relate so we're going to match the room

00:25:28,400 --> 00:25:31,360
for id one

00:25:29,520 --> 00:25:32,799
i'm going to monster match the monster

00:25:31,360 --> 00:25:34,320
with an id4 so you can do multiple

00:25:32,799 --> 00:25:35,840
matches in your cipher query

00:25:34,320 --> 00:25:37,679
so now we have a variable r that

00:25:35,840 --> 00:25:39,520
contains room one

00:25:37,679 --> 00:25:42,080
and variable m that contains monster

00:25:39,520 --> 00:25:44,000
four and then we create a relationship

00:25:42,080 --> 00:25:46,320
we create that larger piece

00:25:44,000 --> 00:25:47,440
um we say referencing that r that we

00:25:46,320 --> 00:25:50,400
used earlier we say

00:25:47,440 --> 00:25:52,320
relate r to m with a contains and here

00:25:50,400 --> 00:25:53,520
we've got that contains

00:25:52,320 --> 00:25:55,200
relationship and it's got the

00:25:53,520 --> 00:25:58,640
directionality it's got all those ascii

00:25:55,200 --> 00:25:58,640
art pieces that i talked about earlier

00:25:59,360 --> 00:26:02,480
so this is how we put a monster in a

00:26:00,880 --> 00:26:04,799
room and

00:26:02,480 --> 00:26:04,799
if we

00:26:06,720 --> 00:26:10,320
if we wanted to if our rooms and our

00:26:08,400 --> 00:26:12,640
monsters didn't exist already

00:26:10,320 --> 00:26:13,760
we could use this query here but there's

00:26:12,640 --> 00:26:15,679
a temptation to think

00:26:13,760 --> 00:26:17,440
well can i just bypass that matching and

00:26:15,679 --> 00:26:18,640
just create things and say match this

00:26:17,440 --> 00:26:19,360
match this and then create the thing in

00:26:18,640 --> 00:26:21,520
the middle

00:26:19,360 --> 00:26:22,400
that doesn't work what this query here

00:26:21,520 --> 00:26:24,559
does

00:26:22,400 --> 00:26:25,760
is it creates rooms and monsters with

00:26:24,559 --> 00:26:27,840
the same id

00:26:25,760 --> 00:26:29,279
because these are just attributes and

00:26:27,840 --> 00:26:30,559
then it relates them together

00:26:29,279 --> 00:26:32,640
and so if you want to use this sort of

00:26:30,559 --> 00:26:33,760
syntax there's a temptation to use this

00:26:32,640 --> 00:26:35,039
because i'm like i'm just going to match

00:26:33,760 --> 00:26:36,640
these things and then

00:26:35,039 --> 00:26:38,159
create the new thing it won't do that

00:26:36,640 --> 00:26:39,760
it'll create new stuff for you

00:26:38,159 --> 00:26:41,520
so you always want to match and then

00:26:39,760 --> 00:26:43,600
create the relationships

00:26:41,520 --> 00:26:45,520
that uh you want to between existing

00:26:43,600 --> 00:26:46,799
things if your nodes don't exist already

00:26:45,520 --> 00:26:47,840
then this totally works you can create a

00:26:46,799 --> 00:26:50,000
room id of one

00:26:47,840 --> 00:26:51,440
and a monster of uh with an id of four

00:26:50,000 --> 00:26:52,720
and create them and then you can create

00:26:51,440 --> 00:26:55,919
all three of those

00:26:52,720 --> 00:26:55,919
pieces in one fell swoop

00:26:56,080 --> 00:26:58,720
uh putting a treasure in a room of

00:26:57,279 --> 00:26:59,840
course is exactly the same thing we

00:26:58,720 --> 00:27:02,720
alter the table

00:26:59,840 --> 00:27:02,720
we update the table

00:27:03,039 --> 00:27:06,159
and then in the case of cipher we do a

00:27:05,200 --> 00:27:09,520
match

00:27:06,159 --> 00:27:11,120
and then a creative relationship there

00:27:09,520 --> 00:27:12,640
and so this is our relational database

00:27:11,120 --> 00:27:14,240
so far now we have that wonderful

00:27:12,640 --> 00:27:15,760
one-to-many relationship a room can

00:27:14,240 --> 00:27:21,120
contain many treasures

00:27:15,760 --> 00:27:22,799
uh a room can contain many monsters

00:27:21,120 --> 00:27:24,080
and this is our graph so far we don't

00:27:22,799 --> 00:27:25,919
have a bunch of nodes that are all

00:27:24,080 --> 00:27:27,760
isolated now now we have little sections

00:27:25,919 --> 00:27:30,559
of the graph that are isolated

00:27:27,760 --> 00:27:32,000
so the statue room has a monster the

00:27:30,559 --> 00:27:36,399
barracks have a treasure

00:27:32,000 --> 00:27:38,159
and the armory has both exciting

00:27:36,399 --> 00:27:39,679
so it's munchkin time we can start doing

00:27:38,159 --> 00:27:41,360
some interesting queries here

00:27:39,679 --> 00:27:43,279
uh both in relational and graph

00:27:41,360 --> 00:27:46,799
databases where we can go

00:27:43,279 --> 00:27:49,840
and find the most monsters or find the

00:27:46,799 --> 00:27:49,840
most treasure

00:27:50,240 --> 00:27:54,880
so if we want to farm all the xp uh from

00:27:53,120 --> 00:27:57,600
a relational database

00:27:54,880 --> 00:27:59,440
we just do a join this is a again a

00:27:57,600 --> 00:28:00,480
classic sql thing i keep saying classic

00:27:59,440 --> 00:28:02,159
sql right

00:28:00,480 --> 00:28:03,760
but it's a classic relational database

00:28:02,159 --> 00:28:04,720
move where we're gonna select from two

00:28:03,760 --> 00:28:06,799
tables

00:28:04,720 --> 00:28:08,159
matching that foreign key to the key of

00:28:06,799 --> 00:28:08,960
the primary table so we're gonna match

00:28:08,159 --> 00:28:11,679
the room id

00:28:08,960 --> 00:28:12,640
to the room id uh the radio the monster

00:28:11,679 --> 00:28:16,240
to the room

00:28:12,640 --> 00:28:18,720
uh for uh the room room

00:28:16,240 --> 00:28:20,159
and then we return uh our the id of the

00:28:18,720 --> 00:28:20,799
room the name of the room and the xp of

00:28:20,159 --> 00:28:22,799
the monster

00:28:20,799 --> 00:28:24,480
and we can order that so that the

00:28:22,799 --> 00:28:27,760
biggest room gets

00:28:24,480 --> 00:28:30,159
pulled out first in graph we can do

00:28:27,760 --> 00:28:32,000
something similar

00:28:30,159 --> 00:28:33,679
we can match rooms that contain monsters

00:28:32,000 --> 00:28:34,640
we've seen this pattern a couple times

00:28:33,679 --> 00:28:36,880
now right

00:28:34,640 --> 00:28:38,799
match a room that contains a monster

00:28:36,880 --> 00:28:41,760
this will find all the rooms

00:28:38,799 --> 00:28:42,559
that contain monsters it will return the

00:28:41,760 --> 00:28:44,320
id of the room

00:28:42,559 --> 00:28:46,799
the name of the room and the xp of the

00:28:44,320 --> 00:28:48,320
monster and then we can again order this

00:28:46,799 --> 00:28:49,520
is actually in some ways very similar to

00:28:48,320 --> 00:28:51,600
the sql statement

00:28:49,520 --> 00:28:53,120
uh just we're doing a match and a return

00:28:51,600 --> 00:28:59,520
but then we're doing that order by so we

00:28:53,120 --> 00:29:01,919
get the thing we care about most

00:28:59,520 --> 00:29:03,039
and same thing for the gold except a

00:29:01,919 --> 00:29:06,240
different table

00:29:03,039 --> 00:29:06,240
and different nodes

00:29:06,799 --> 00:29:10,000
i had to put these here because i'm a

00:29:08,399 --> 00:29:11,200
completionist even though they don't

00:29:10,000 --> 00:29:11,520
teach anything new but you know it's

00:29:11,200 --> 00:29:13,279
like

00:29:11,520 --> 00:29:15,120
we got to show it all i got to make sure

00:29:13,279 --> 00:29:16,480
we do the complete dungeon every single

00:29:15,120 --> 00:29:18,880
room right

00:29:16,480 --> 00:29:18,880
so um

00:29:19,679 --> 00:29:23,120
so far so good right uh we've done

00:29:21,760 --> 00:29:24,480
things with graph that we can do with

00:29:23,120 --> 00:29:27,200
relational databases

00:29:24,480 --> 00:29:28,799
but um well so what right so this is

00:29:27,200 --> 00:29:30,240
just another kind of relational database

00:29:28,799 --> 00:29:32,640
without a schema

00:29:30,240 --> 00:29:33,840
um well no no it's not it's it's

00:29:32,640 --> 00:29:35,200
actually something very different

00:29:33,840 --> 00:29:36,720
i actually think i don't want to

00:29:35,200 --> 00:29:40,080
understand the schema lessons that's

00:29:36,720 --> 00:29:41,360
actually can be very powerful um

00:29:40,080 --> 00:29:42,880
but uh we haven't done the really

00:29:41,360 --> 00:29:44,080
interesting thing which is connecting

00:29:42,880 --> 00:29:45,600
rooms to rooms

00:29:44,080 --> 00:29:47,440
because a dungeon is a series of

00:29:45,600 --> 00:29:49,919
connected rooms that contain

00:29:47,440 --> 00:29:52,159
things that done the adventurers want so

00:29:49,919 --> 00:29:53,600
let's connect some rooms

00:29:52,159 --> 00:29:56,080
and let's look at how we would do that

00:29:53,600 --> 00:29:57,840
with a relational database

00:29:56,080 --> 00:29:59,120
in a relational database to connect some

00:29:57,840 --> 00:30:02,640
rooms

00:29:59,120 --> 00:30:06,159
uh we need to create a new table uh that

00:30:02,640 --> 00:30:08,960
has the room to room relationship

00:30:06,159 --> 00:30:11,039
the connections between these rooms and

00:30:08,960 --> 00:30:15,679
so it has foreign keys for

00:30:11,039 --> 00:30:17,279
um each room and the room it goes to and

00:30:15,679 --> 00:30:18,720
and then you know both directions it's

00:30:17,279 --> 00:30:19,520
actually got directionality built into

00:30:18,720 --> 00:30:21,919
it

00:30:19,520 --> 00:30:23,840
um and we just insert into that table uh

00:30:21,919 --> 00:30:24,240
the key to foreign keys are the rooms

00:30:23,840 --> 00:30:25,919
and now

00:30:24,240 --> 00:30:28,320
the statue room is connected to the

00:30:25,919 --> 00:30:28,320
barracks

00:30:29,360 --> 00:30:32,960
um but we had to create a whole new

00:30:30,960 --> 00:30:33,760
table to do this if we want to do this

00:30:32,960 --> 00:30:35,360
with cipher

00:30:33,760 --> 00:30:37,600
and this is i think one of the things

00:30:35,360 --> 00:30:39,120
that is kind of exciting about graph

00:30:37,600 --> 00:30:40,640
it's actually not any different than any

00:30:39,120 --> 00:30:42,240
of the other relationships we've

00:30:40,640 --> 00:30:43,919
established

00:30:42,240 --> 00:30:45,440
we match on the two rooms we want to

00:30:43,919 --> 00:30:47,039
relate

00:30:45,440 --> 00:30:48,960
and then we create a relationship

00:30:47,039 --> 00:30:50,880
between them and so we go out and get

00:30:48,960 --> 00:30:52,960
room one and we go out and get room two

00:30:50,880 --> 00:30:54,960
and then we say we create room one leads

00:30:52,960 --> 00:30:58,240
to room two

00:30:54,960 --> 00:30:59,840
and so now we've got um the related

00:30:58,240 --> 00:31:01,519
rooms this is no different than putting

00:30:59,840 --> 00:31:02,000
a monster in a room this is no different

00:31:01,519 --> 00:31:04,000
than

00:31:02,000 --> 00:31:05,760
putting treasure in a room you're just

00:31:04,000 --> 00:31:08,240
connecting your room to another room

00:31:05,760 --> 00:31:09,760
because it's all relationships there's

00:31:08,240 --> 00:31:11,279
no there are no tables there are no

00:31:09,760 --> 00:31:13,360
schema

00:31:11,279 --> 00:31:16,080
and so relating rooms is no different

00:31:13,360 --> 00:31:18,320
than doing those things

00:31:16,080 --> 00:31:19,919
and so this is actually there's there's

00:31:18,320 --> 00:31:21,760
nothing new to see here we're doing the

00:31:19,919 --> 00:31:24,320
same thing we've been doing all along

00:31:21,760 --> 00:31:25,919
so here's our relational database so far

00:31:24,320 --> 00:31:26,720
it's gotten kind of big it's got four

00:31:25,919 --> 00:31:29,120
tables

00:31:26,720 --> 00:31:32,960
um we've got a fun many-to-many

00:31:29,120 --> 00:31:34,000
relationship from rooms to themselves

00:31:32,960 --> 00:31:35,200
and then we've got one to many

00:31:34,000 --> 00:31:37,039
relationships for the monsters and the

00:31:35,200 --> 00:31:38,799
treasures our graph database

00:31:37,039 --> 00:31:40,240
is now connected it's no longer got

00:31:38,799 --> 00:31:41,840
isolated pieces

00:31:40,240 --> 00:31:43,679
and so we've got room connecting to

00:31:41,840 --> 00:31:44,320
itself we've got rooms connecting to

00:31:43,679 --> 00:31:45,600
each other

00:31:44,320 --> 00:31:47,039
i kind of like how this works out

00:31:45,600 --> 00:31:48,880
because we've got the statue room which

00:31:47,039 --> 00:31:51,200
is clearly the entrance to the dungeon

00:31:48,880 --> 00:31:52,080
and it goes to uh the barracks and the

00:31:51,200 --> 00:31:53,279
armory

00:31:52,080 --> 00:31:54,640
but the armory's got a one-way

00:31:53,279 --> 00:31:56,159
connection from the barracks so the

00:31:54,640 --> 00:31:57,840
barracks goes straight to the armory

00:31:56,159 --> 00:31:58,720
it's almost like you know it's like all

00:31:57,840 --> 00:32:00,240
the soldiers are sleeping in the

00:31:58,720 --> 00:32:01,279
barracks and they jump on the flagpole

00:32:00,240 --> 00:32:02,480
and they go down really quick

00:32:01,279 --> 00:32:03,679
and then boom they're on the armoring

00:32:02,480 --> 00:32:04,640
ready to face the threat that's coming

00:32:03,679 --> 00:32:05,840
into the statue room which is the

00:32:04,640 --> 00:32:07,279
entrance to the dungeon

00:32:05,840 --> 00:32:10,080
so there's like a little story here

00:32:07,279 --> 00:32:11,600
isn't there um

00:32:10,080 --> 00:32:13,200
but yeah this is our graph database so

00:32:11,600 --> 00:32:15,200
far and so now we can be not just

00:32:13,200 --> 00:32:17,840
munchkins but super munchkins

00:32:15,200 --> 00:32:19,200
because now we have the means to query

00:32:17,840 --> 00:32:22,559
rooms

00:32:19,200 --> 00:32:26,840
and paths through the dungeon

00:32:22,559 --> 00:32:29,440
and in order to do this with sql is hard

00:32:26,840 --> 00:32:31,360
because well how many times are you

00:32:29,440 --> 00:32:32,720
going to join back on that same rooms

00:32:31,360 --> 00:32:35,360
table and the connections

00:32:32,720 --> 00:32:36,720
to you know find paths through the

00:32:35,360 --> 00:32:38,399
dungeons

00:32:36,720 --> 00:32:39,840
but graph makes it pretty easy and it

00:32:38,399 --> 00:32:42,399
does it using a

00:32:39,840 --> 00:32:43,279
variable length relationships so in

00:32:42,399 --> 00:32:45,440
cypher

00:32:43,279 --> 00:32:47,919
you've got this here that matches a room

00:32:45,440 --> 00:32:49,600
and this here that matches another room

00:32:47,919 --> 00:32:51,600
and then you've got a leads to with a

00:32:49,600 --> 00:32:55,840
star that little star

00:32:51,600 --> 00:32:59,200
that little asterisk means that

00:32:55,840 --> 00:33:00,480
make multiple hops so uh you can

00:32:59,200 --> 00:33:02,000
have a room that leads to a room that

00:33:00,480 --> 00:33:03,200
leads to a room that leads to a room

00:33:02,000 --> 00:33:04,799
that matches this pattern

00:33:03,200 --> 00:33:06,799
room that leads to room that matches

00:33:04,799 --> 00:33:07,279
this pattern room that leads to another

00:33:06,799 --> 00:33:09,919
room

00:33:07,279 --> 00:33:11,360
20 times over that matches this pattern

00:33:09,919 --> 00:33:15,200
and so it matches

00:33:11,360 --> 00:33:17,360
variable length relationships super cool

00:33:15,200 --> 00:33:18,640
and it allows you to then find paths

00:33:17,360 --> 00:33:20,000
through the dungeons because you're

00:33:18,640 --> 00:33:24,320
now you're recording paths as opposed to

00:33:20,000 --> 00:33:25,120
just one-to-one relationships and you

00:33:24,320 --> 00:33:27,039
can um

00:33:25,120 --> 00:33:29,279
specify how long you want these paths to

00:33:27,039 --> 00:33:30,480
be so here you can specify the minimum

00:33:29,279 --> 00:33:34,720
number of hops

00:33:30,480 --> 00:33:36,559
at least one not more than three

00:33:34,720 --> 00:33:38,159
and so this would find all the rooms

00:33:36,559 --> 00:33:40,080
that are within three hops of the

00:33:38,159 --> 00:33:43,600
current room you're in

00:33:40,080 --> 00:33:44,640
so i actually would find all the rooms

00:33:43,600 --> 00:33:46,720
are within

00:33:44,640 --> 00:33:48,399
one to three hops of any other room in

00:33:46,720 --> 00:33:50,640
all its permutations through the graph

00:33:48,399 --> 00:33:52,000
which would be a lot right if you've got

00:33:50,640 --> 00:33:53,760
20 nodes in your graph

00:33:52,000 --> 00:33:55,360
this could return tens of thousands of

00:33:53,760 --> 00:33:58,240
results

00:33:55,360 --> 00:34:00,080
um and so we can use this capability to

00:33:58,240 --> 00:34:03,279
find things like nearby rooms

00:34:00,080 --> 00:34:05,600
i'm in room one what rooms are nearby

00:34:03,279 --> 00:34:09,120
here i'm saying i'm in room one give me

00:34:05,600 --> 00:34:09,120
rooms that are one to three rooms away

00:34:10,159 --> 00:34:14,159
thank you very much christopher i

00:34:11,760 --> 00:34:17,280
appreciate that i try to make it fun

00:34:14,159 --> 00:34:18,879
um and so

00:34:17,280 --> 00:34:20,480
right we're we're finding rooms that are

00:34:18,879 --> 00:34:22,240
nearby what are where

00:34:20,480 --> 00:34:24,320
rooms that i could go to which is kind

00:34:22,240 --> 00:34:25,599
of interesting but it's even more

00:34:24,320 --> 00:34:27,280
interesting if we say

00:34:25,599 --> 00:34:29,280
what are the rooms that are nearby with

00:34:27,280 --> 00:34:33,200
gold

00:34:29,280 --> 00:34:33,200
right and so here we can match

00:34:33,520 --> 00:34:36,800
um a room that we're currently in is

00:34:35,599 --> 00:34:39,599
presumably we're in room one

00:34:36,800 --> 00:34:41,520
the statue room uh and we want to go up

00:34:39,599 --> 00:34:44,240
to three rooms away

00:34:41,520 --> 00:34:45,520
to any room that contains treasure if it

00:34:44,240 --> 00:34:46,720
doesn't contain treasure it won't match

00:34:45,520 --> 00:34:48,480
this pattern

00:34:46,720 --> 00:34:50,000
and then we return the id the name and

00:34:48,480 --> 00:34:51,119
the gold piece value of the treasure in

00:34:50,000 --> 00:34:52,800
that room

00:34:51,119 --> 00:34:53,919
we return and return those values we

00:34:52,800 --> 00:34:54,800
order it by the gold piece value

00:34:53,919 --> 00:34:56,560
descending

00:34:54,800 --> 00:34:58,079
which will give us the highest at top

00:34:56,560 --> 00:34:59,440
and you know for good measure let's be

00:34:58,079 --> 00:35:01,359
focused we'll limit it to one

00:34:59,440 --> 00:35:03,200
and that will just return us the room

00:35:01,359 --> 00:35:05,359
within three hops that has the most goal

00:35:03,200 --> 00:35:06,960
so now we know where we're going next

00:35:05,359 --> 00:35:10,160
going to that room that's got that

00:35:06,960 --> 00:35:10,960
1250 gold piece i a gem that's the i and

00:35:10,160 --> 00:35:14,160
the big statue

00:35:10,960 --> 00:35:14,640
right so so we can create these really

00:35:14,160 --> 00:35:17,760
cool

00:35:14,640 --> 00:35:19,200
optimized queries

00:35:17,760 --> 00:35:21,040
we can find the longest path through the

00:35:19,200 --> 00:35:21,920
dungeon i joked earlier i'm a

00:35:21,040 --> 00:35:24,079
completionist

00:35:21,920 --> 00:35:26,160
this would give you the longest path in

00:35:24,079 --> 00:35:27,200
the dungeon give me a room that leads to

00:35:26,160 --> 00:35:29,440
all the other rooms

00:35:27,200 --> 00:35:31,040
and match that and you might notice the

00:35:29,440 --> 00:35:35,119
p equals there

00:35:31,040 --> 00:35:36,640
um that's uh that captures the path

00:35:35,119 --> 00:35:37,839
just like you do an article in room

00:35:36,640 --> 00:35:38,560
captures the room and puts it in a

00:35:37,839 --> 00:35:41,200
variable

00:35:38,560 --> 00:35:42,000
the p equals cipher query or you know

00:35:41,200 --> 00:35:45,280
match

00:35:42,000 --> 00:35:46,640
uh returns um stores the path

00:35:45,280 --> 00:35:47,440
information as a variable that you can

00:35:46,640 --> 00:35:49,760
query

00:35:47,440 --> 00:35:52,079
and so we can get that path of every the

00:35:49,760 --> 00:35:53,359
path from every room to every room

00:35:52,079 --> 00:35:54,880
and then we can say well what are the

00:35:53,359 --> 00:35:56,640
nodes in that path what's what are the

00:35:54,880 --> 00:35:59,040
length of that path

00:35:56,640 --> 00:36:00,560
and then we can order that by the length

00:35:59,040 --> 00:36:03,200
uh descending which would put the

00:36:00,560 --> 00:36:05,200
longest path that touches every room

00:36:03,200 --> 00:36:06,800
in there at the top of the list and then

00:36:05,200 --> 00:36:09,280
we limit the one and then we find our

00:36:06,800 --> 00:36:13,040
longest path through the dungeon

00:36:09,280 --> 00:36:15,920
which is kind of cool

00:36:13,040 --> 00:36:18,000
uh so you're talking about using a a a

00:36:15,920 --> 00:36:19,760
graph as a back end to a mud

00:36:18,000 --> 00:36:21,200
uh i'm actually working on that on

00:36:19,760 --> 00:36:22,880
stream

00:36:21,200 --> 00:36:24,240
so i've got some code out there if you

00:36:22,880 --> 00:36:25,359
want to go play with it if you like

00:36:24,240 --> 00:36:27,359
javascript

00:36:25,359 --> 00:36:28,720
so uh go out to my github and guy ryzen

00:36:27,359 --> 00:36:29,839
go check that out so

00:36:28,720 --> 00:36:32,160
but yeah you're right kevin that's a

00:36:29,839 --> 00:36:33,200
great idea

00:36:32,160 --> 00:36:34,400
and you know it's a great idea because

00:36:33,200 --> 00:36:35,680
someone else thought of it that's always

00:36:34,400 --> 00:36:38,960
the litmus test

00:36:35,680 --> 00:36:40,000
so um so this finds the longest path

00:36:38,960 --> 00:36:41,680
through the dungeon

00:36:40,000 --> 00:36:42,800
uh this will find the path to the room

00:36:41,680 --> 00:36:44,400
with the biggest treasure from where

00:36:42,800 --> 00:36:45,520
you're currently at or not from where

00:36:44,400 --> 00:36:47,119
you're currently at

00:36:45,520 --> 00:36:48,640
but uh find the room with the biggest

00:36:47,119 --> 00:36:49,760
treasure this is new syntax we use a

00:36:48,640 --> 00:36:51,119
width

00:36:49,760 --> 00:36:53,440
and this is a way of sort of extracting

00:36:51,119 --> 00:36:55,760
a variable from a match

00:36:53,440 --> 00:36:57,760
we're saying you know get the max gold

00:36:55,760 --> 00:36:59,200
piece and that tells us the max value

00:36:57,760 --> 00:37:01,119
and then we can use that later in our

00:36:59,200 --> 00:37:02,880
where clause to filter it out

00:37:01,119 --> 00:37:04,240
so find all the treasure get the most

00:37:02,880 --> 00:37:07,040
valuable one

00:37:04,240 --> 00:37:08,800
and then um find all the rooms with

00:37:07,040 --> 00:37:10,720
treasure

00:37:08,800 --> 00:37:13,440
filter it by that max value and then

00:37:10,720 --> 00:37:13,440
return that one

00:37:15,200 --> 00:37:18,720
and uh most importantly the path to the

00:37:17,599 --> 00:37:20,400
gold

00:37:18,720 --> 00:37:22,079
this is sort of combining all the things

00:37:20,400 --> 00:37:24,800
i just talked about where

00:37:22,079 --> 00:37:25,920
we can find the most valuable treasure

00:37:24,800 --> 00:37:28,000
we find the room

00:37:25,920 --> 00:37:29,599
that has that most valuable treasure and

00:37:28,000 --> 00:37:31,119
again with a match with

00:37:29,599 --> 00:37:33,119
and then we get the path from the room

00:37:31,119 --> 00:37:36,079
we're in right now

00:37:33,119 --> 00:37:37,119
to the room we uh just discovered we

00:37:36,079 --> 00:37:38,800
want to go to

00:37:37,119 --> 00:37:40,400
and then we return the path to it so we

00:37:38,800 --> 00:37:44,079
can actually do uh

00:37:40,400 --> 00:37:47,200
really sophisticated queries here so

00:37:44,079 --> 00:37:47,920
i've got about seven minutes left i

00:37:47,200 --> 00:37:50,640
think

00:37:47,920 --> 00:37:53,040
so i've got a demo you guys want to see

00:37:50,640 --> 00:37:54,220
that this is actually real

00:37:53,040 --> 00:37:56,240
the answer is hell yes

00:37:54,220 --> 00:37:58,240
[Laughter]

00:37:56,240 --> 00:37:59,280
um collaborative interaction fiction and

00:37:58,240 --> 00:38:00,560
you know actually we can do instead of

00:37:59,280 --> 00:38:02,160
over the internet let's do it in person

00:38:00,560 --> 00:38:03,920
yeah

00:38:02,160 --> 00:38:05,440
so let's take a look at this over here

00:38:03,920 --> 00:38:08,320
hey hang on

00:38:05,440 --> 00:38:09,760
there we go so i've created a uh my

00:38:08,320 --> 00:38:11,680
apologies for looking to the side but my

00:38:09,760 --> 00:38:13,680
monitor over here has the code on it

00:38:11,680 --> 00:38:15,599
i've created a random dungeon generator

00:38:13,680 --> 00:38:17,040
here and i'm using a redis graph for

00:38:15,599 --> 00:38:18,160
this of course and i'm using our cloud

00:38:17,040 --> 00:38:19,599
version because

00:38:18,160 --> 00:38:20,880
i've got a tiny little underpowered

00:38:19,599 --> 00:38:22,400
macbook and then we've got a big

00:38:20,880 --> 00:38:23,440
powerful cloud and so i'm using that

00:38:22,400 --> 00:38:27,520
instead

00:38:23,440 --> 00:38:29,599
um so

00:38:27,520 --> 00:38:30,960
uh and this guy just generates a random

00:38:29,599 --> 00:38:32,640
dungeon i'm just gonna go ahead and run

00:38:30,960 --> 00:38:34,079
it really quick because it's totally

00:38:32,640 --> 00:38:38,160
unimpressive

00:38:34,079 --> 00:38:41,040
okay npm start it runs

00:38:38,160 --> 00:38:41,440
and it pauses and it finishes good it's

00:38:41,040 --> 00:38:44,079
done

00:38:41,440 --> 00:38:46,480
let's let's run it again i think it had

00:38:44,079 --> 00:38:48,320
to spin up

00:38:46,480 --> 00:38:49,599
now there we go so we've just generated

00:38:48,320 --> 00:38:54,640
a random dungeon

00:38:49,599 --> 00:38:58,240
um so thank you for attending my demo

00:38:54,640 --> 00:38:59,359
no just kidding um and um

00:38:58,240 --> 00:39:00,560
there's a whole bunch of javascript code

00:38:59,359 --> 00:39:01,359
which i don't really have time to go

00:39:00,560 --> 00:39:02,800
into

00:39:01,359 --> 00:39:04,720
uh and it's it's not particularly

00:39:02,800 --> 00:39:06,079
brilliant uh the main thing is is that

00:39:04,720 --> 00:39:08,640
it's using uh

00:39:06,079 --> 00:39:10,560
in here we're using redis graph there's

00:39:08,640 --> 00:39:13,359
a library for using that

00:39:10,560 --> 00:39:15,119
it's called rediscraft.js and i'm using

00:39:13,359 --> 00:39:17,920
that to uh

00:39:15,119 --> 00:39:19,200
run queries so i pass in a cipher query

00:39:17,920 --> 00:39:21,440
and i pass in the parameters

00:39:19,200 --> 00:39:22,800
and then this will return results from

00:39:21,440 --> 00:39:23,440
it so this is kind of the interesting

00:39:22,800 --> 00:39:25,200
part

00:39:23,440 --> 00:39:26,560
we can look at some of the queries here

00:39:25,200 --> 00:39:29,440
like here's where i create

00:39:26,560 --> 00:39:30,960
the dungeon here's where i create a room

00:39:29,440 --> 00:39:32,800
and so this is the same sort of cipher

00:39:30,960 --> 00:39:35,440
query we've been looking at

00:39:32,800 --> 00:39:35,920
um and the fun thing is is that i use

00:39:35,440 --> 00:39:39,200
totally

00:39:35,920 --> 00:39:42,320
random randomly generated

00:39:39,200 --> 00:39:44,480
uh names for things and so if we go out

00:39:42,320 --> 00:39:44,480
to

00:39:44,800 --> 00:39:49,680
redis insight which is a sort of a it's

00:39:47,440 --> 00:39:53,040
a it's a gooey client for redis

00:39:49,680 --> 00:39:55,280
we got one for graph i can do i can

00:39:53,040 --> 00:39:56,560
go out and query this so if i do match n

00:39:55,280 --> 00:39:58,400
return n

00:39:56,560 --> 00:39:59,839
that is sort of select star dot star

00:39:58,400 --> 00:40:02,000
select star from

00:39:59,839 --> 00:40:03,520
the graph right this will just return

00:40:02,000 --> 00:40:04,720
everything i hit enter

00:40:03,520 --> 00:40:06,160
and it creates this nice visual

00:40:04,720 --> 00:40:07,680
interface this is going to match all the

00:40:06,160 --> 00:40:09,920
nodes and return them

00:40:07,680 --> 00:40:13,440
and so this is my graph i go to a

00:40:09,920 --> 00:40:14,960
tabular view you can see we've got

00:40:13,440 --> 00:40:17,520
all the things that have these are all

00:40:14,960 --> 00:40:17,520
the nodes

00:40:17,680 --> 00:40:20,720
most of them just have names

00:40:21,119 --> 00:40:26,720
but not all of them do like here's

00:40:24,319 --> 00:40:27,920
a guy yeah sorry to interrupt but we

00:40:26,720 --> 00:40:30,000
have five minutes

00:40:27,920 --> 00:40:30,960
thank you very much uh we've got uh

00:40:30,000 --> 00:40:32,880
marla

00:40:30,960 --> 00:40:34,720
vlin the displacer beast with a

00:40:32,880 --> 00:40:37,599
challenge rating of 11 and

00:40:34,720 --> 00:40:38,560
66 experience points five giant rats

00:40:37,599 --> 00:40:40,480
there's gonna be some

00:40:38,560 --> 00:40:42,560
treasure here all kinds of fun stuff

00:40:40,480 --> 00:40:44,560
right uh but this view is actually kind

00:40:42,560 --> 00:40:47,280
of cooler

00:40:44,560 --> 00:40:48,319
and so we can do any query we want right

00:40:47,280 --> 00:40:51,520
we do match

00:40:48,319 --> 00:40:54,640
uh our colon room

00:40:51,520 --> 00:40:58,720
that we'll do the

00:40:54,640 --> 00:40:58,720
that contains

00:41:01,200 --> 00:41:10,400
aat pull on treasure

00:41:06,480 --> 00:41:13,520
return r dot name

00:41:10,400 --> 00:41:16,240
t dot name t dot

00:41:13,520 --> 00:41:18,480
gp so this will give us a list of rooms

00:41:16,240 --> 00:41:19,920
with treasure

00:41:18,480 --> 00:41:21,350
look here we have a minus one cursed

00:41:19,920 --> 00:41:24,000
lance who wants it

00:41:21,350 --> 00:41:26,319
[Laughter]

00:41:24,000 --> 00:41:26,319
um

00:41:27,119 --> 00:41:31,119
and one of the cool things here that i

00:41:28,960 --> 00:41:33,119
think with redis insight in particular

00:41:31,119 --> 00:41:34,720
is let's match let's go i created a

00:41:33,119 --> 00:41:35,599
dungeon note in the this generator which

00:41:34,720 --> 00:41:38,640
wasn't in my uh

00:41:35,599 --> 00:41:40,160
sample in the uh in the talk and there's

00:41:38,640 --> 00:41:41,280
only one of them and i know that so we

00:41:40,160 --> 00:41:43,920
can safely return it

00:41:41,280 --> 00:41:46,000
here's our dungeon right the forlorn

00:41:43,920 --> 00:41:50,000
castle of

00:41:46,000 --> 00:41:50,000
knuck-nog knog that's a great name

00:41:50,640 --> 00:41:57,839
yeah so all this code's up on github um

00:41:54,400 --> 00:42:01,119
and with here i can double click it

00:41:57,839 --> 00:42:01,920
and come on there we go and now it shows

00:42:01,119 --> 00:42:04,480
me the uh

00:42:01,920 --> 00:42:05,440
this is the exit and this is entrance

00:42:04,480 --> 00:42:06,880
we've got a red den

00:42:05,440 --> 00:42:09,200
if we click on that we can see that the

00:42:06,880 --> 00:42:10,640
red den has got three monsters and

00:42:09,200 --> 00:42:12,240
connections to two other rooms

00:42:10,640 --> 00:42:14,800
so we can kind of walk the gra walk the

00:42:12,240 --> 00:42:17,599
graph around here and here is

00:42:14,800 --> 00:42:18,560
grathsnar the displacer beast here's our

00:42:17,599 --> 00:42:20,560
red chasm which

00:42:18,560 --> 00:42:22,240
i guess is next to the red den it's got

00:42:20,560 --> 00:42:23,599
a bunch of treasure including the minus

00:42:22,240 --> 00:42:24,960
one cursed sling

00:42:23,599 --> 00:42:26,560
chest of coins and so you can kind of

00:42:24,960 --> 00:42:26,960
walk this thing around but let's do one

00:42:26,560 --> 00:42:29,359
of the

00:42:26,960 --> 00:42:30,880
interesting queries one of the big ones

00:42:29,359 --> 00:42:32,400
and i'm gonna cheat

00:42:30,880 --> 00:42:34,079
because i don't feel like typing this

00:42:32,400 --> 00:42:36,880
all in off top of my head

00:42:34,079 --> 00:42:38,720
let's find the uh shortest path let's

00:42:36,880 --> 00:42:40,079
find the longest path in a dungeon

00:42:38,720 --> 00:42:42,560
now let's do the shortest path to the

00:42:40,079 --> 00:42:45,839
most gold

00:42:42,560 --> 00:42:45,839
so copy that

00:42:46,000 --> 00:42:51,040
and we'll just paste that up here

00:42:49,280 --> 00:42:54,720
so this is that big long query that i

00:42:51,040 --> 00:42:54,720
showed you last and if i hit enter

00:42:55,599 --> 00:43:01,920
this is

00:42:58,720 --> 00:43:03,839
the shortest path to the most gold

00:43:01,920 --> 00:43:05,680
if we look at this at a table view it

00:43:03,839 --> 00:43:07,440
probably is easy easier to see we got

00:43:05,680 --> 00:43:08,960
five nodes

00:43:07,440 --> 00:43:10,640
and we go from node zero which is the

00:43:08,960 --> 00:43:12,160
dungeon

00:43:10,640 --> 00:43:13,839
and then we go from this room to this

00:43:12,160 --> 00:43:15,359
room to this room to this room

00:43:13,839 --> 00:43:17,200
so it goes from the dungeon through the

00:43:15,359 --> 00:43:20,000
entrance that makes the most sense

00:43:17,200 --> 00:43:20,720
and then finds the path to room five

00:43:20,000 --> 00:43:23,680
which

00:43:20,720 --> 00:43:25,680
has is the dusty stairs if we go back to

00:43:23,680 --> 00:43:27,119
the node view

00:43:25,680 --> 00:43:31,920
we should be able to look at the dusty

00:43:27,119 --> 00:43:31,920
stairs and see what treasures in it

00:43:32,640 --> 00:43:38,400
yeah it's got

00:43:35,839 --> 00:43:39,280
uh the minus one cursed lance and the

00:43:38,400 --> 00:43:42,480
axe

00:43:39,280 --> 00:43:44,160
of whatever

00:43:42,480 --> 00:43:46,800
which is worth a whopping 2 500 gold

00:43:44,160 --> 00:43:48,319
pieces so uh yep that's the link

00:43:46,800 --> 00:43:50,400
and i have a link in my slides to it as

00:43:48,319 --> 00:43:53,040
well uh derek thanks

00:43:50,400 --> 00:43:54,400
um so that's our uh that's our little

00:43:53,040 --> 00:43:55,680
graph here let me finish up the talks

00:43:54,400 --> 00:43:57,200
here at the slides here

00:43:55,680 --> 00:43:58,800
so uh this is a fun application but

00:43:57,200 --> 00:44:01,520
there's lots of practical applications

00:43:58,800 --> 00:44:03,440
social networks are an obvious one hey

00:44:01,520 --> 00:44:05,200
i'm friends with so-and-so i follow so

00:44:03,440 --> 00:44:05,920
and so this is this is these are natural

00:44:05,200 --> 00:44:08,400
graph

00:44:05,920 --> 00:44:10,240
problems genealogy is just sort of like

00:44:08,400 --> 00:44:11,520
social network but with your relatives

00:44:10,240 --> 00:44:13,760
and over time

00:44:11,520 --> 00:44:15,200
um transportation networks are a natural

00:44:13,760 --> 00:44:17,200
graph roads

00:44:15,200 --> 00:44:18,960
and intersections are you know those are

00:44:17,200 --> 00:44:21,119
nodes and connections

00:44:18,960 --> 00:44:22,560
and uh for logistics you can have lots

00:44:21,119 --> 00:44:22,880
of interesting problems with logistics

00:44:22,560 --> 00:44:24,880
where

00:44:22,880 --> 00:44:27,200
you're tracking like farms and trucks

00:44:24,880 --> 00:44:29,599
and stores and deliveries and all sorts

00:44:27,200 --> 00:44:31,359
of stuff

00:44:29,599 --> 00:44:33,200
uh here's some resources to go check out

00:44:31,359 --> 00:44:35,200
of course uh i would love it if you go

00:44:33,200 --> 00:44:38,640
check out redis graph

00:44:35,200 --> 00:44:40,400
but you know um there are other

00:44:38,640 --> 00:44:41,920
other graph databases are available all

00:44:40,400 --> 00:44:43,920
these are open source

00:44:41,920 --> 00:44:45,839
uh redis graph is completely open source

00:44:43,920 --> 00:44:47,520
redis itself of course is open source

00:44:45,839 --> 00:44:49,839
uh cipher query language is created by

00:44:47,520 --> 00:44:51,359
neo4j i can't talk about a graph without

00:44:49,839 --> 00:44:53,119
talking about neo4j they created this

00:44:51,359 --> 00:44:54,480
query language we're talking about

00:44:53,119 --> 00:44:55,760
uh so you go check them out check that

00:44:54,480 --> 00:44:56,880
out if you want to know more about how

00:44:55,760 --> 00:44:59,920
cipher works

00:44:56,880 --> 00:45:00,960
um and then i've got a blog post here

00:44:59,920 --> 00:45:02,560
that i wrote on graph and

00:45:00,960 --> 00:45:05,440
just some useful resources to go check

00:45:02,560 --> 00:45:06,800
out um i work for redis labs go check

00:45:05,440 --> 00:45:08,000
out our discord server i'm always

00:45:06,800 --> 00:45:10,319
hanging out on there

00:45:08,000 --> 00:45:11,760
uh and it has the word gm kachoo so it

00:45:10,319 --> 00:45:13,359
kind of feels d d

00:45:11,760 --> 00:45:15,359
and here's our community forums and our

00:45:13,359 --> 00:45:16,560
redis university link for free classes

00:45:15,359 --> 00:45:18,240
so go check that out

00:45:16,560 --> 00:45:20,319
here's the qr code that totally doesn't

00:45:18,240 --> 00:45:21,839
rick roll you but takes you to the this

00:45:20,319 --> 00:45:23,920
url which has already been conveniently

00:45:21,839 --> 00:45:26,240
posted in the chat so thank you

00:45:23,920 --> 00:45:27,520
and that's what i got on guy royce

00:45:26,240 --> 00:45:28,800
please give me a follow on twitter i

00:45:27,520 --> 00:45:29,920
always appreciate that please go check

00:45:28,800 --> 00:45:33,839
out her stuff

00:45:29,920 --> 00:45:33,839
and uh thanks for attending my talk

00:45:35,680 --> 00:45:39,760
very good we have a couple questions um

00:45:38,480 --> 00:45:40,800
i guess we can go through and answer

00:45:39,760 --> 00:45:42,480
them real quick

00:45:40,800 --> 00:45:45,119
uh first question is what's the syntax

00:45:42,480 --> 00:45:46,720
to end a statement in cypher

00:45:45,119 --> 00:45:48,960
what's the syntax to uh let me see if i

00:45:46,720 --> 00:45:51,200
can look for syntax

00:45:48,960 --> 00:45:53,200
go ahead sorry yes it's in the question

00:45:51,200 --> 00:45:54,880
and answer is what's the syntax to end a

00:45:53,200 --> 00:45:58,319
statement in cipher

00:45:54,880 --> 00:46:02,000
to end the statement um yes

00:45:58,319 --> 00:46:03,839
it's just carried return um

00:46:02,000 --> 00:46:05,200
there is no uh need to like there's no

00:46:03,839 --> 00:46:06,319
semicolon or anything like that to that

00:46:05,200 --> 00:46:09,920
you need to end the statement

00:46:06,319 --> 00:46:12,079
so okay another one

00:46:09,920 --> 00:46:13,280
how would you do the equivalent of

00:46:12,079 --> 00:46:15,599
grouping in graph

00:46:13,280 --> 00:46:16,560
example if there were multiple enemies

00:46:15,599 --> 00:46:19,839
there might be

00:46:16,560 --> 00:46:20,240
more xp in another room yeah so uh

00:46:19,839 --> 00:46:22,079
there's

00:46:20,240 --> 00:46:23,520
several aggregation functions i touched

00:46:22,079 --> 00:46:24,480
on one briefly towards the end there

00:46:23,520 --> 00:46:25,920
with the uh

00:46:24,480 --> 00:46:27,920
with the with statement where you could

00:46:25,920 --> 00:46:30,720
say with like max xp

00:46:27,920 --> 00:46:32,160
you can do you can do a match uh for say

00:46:30,720 --> 00:46:33,839
all the monsters in a room

00:46:32,160 --> 00:46:35,760
and then you can do instead of max you

00:46:33,839 --> 00:46:37,680
could do some of the xp

00:46:35,760 --> 00:46:39,280
or some of the treasure value those

00:46:37,680 --> 00:46:41,119
would actually be better queries for the

00:46:39,280 --> 00:46:42,640
particular goal i'm having but you know

00:46:41,119 --> 00:46:44,000
they also are harder to talk about so

00:46:42,640 --> 00:46:45,680
they were distractions so i didn't

00:46:44,000 --> 00:46:48,560
use that specific example but it works

00:46:45,680 --> 00:46:48,560
exactly the same way

00:46:49,520 --> 00:46:53,920
okay and another we have to do relation

00:46:52,800 --> 00:46:56,720
databases not

00:46:53,920 --> 00:46:58,880
notograph or dbas how would you suggest

00:46:56,720 --> 00:47:03,040
responding to the rdbms

00:46:58,880 --> 00:47:03,040
disciples um

00:47:03,440 --> 00:47:07,280
i would say that uh graph isn't the

00:47:05,599 --> 00:47:08,640
solution to everything and so they they

00:47:07,280 --> 00:47:09,359
may be right and saying no we don't want

00:47:08,640 --> 00:47:12,160
to do graph

00:47:09,359 --> 00:47:14,079
right lots of times relational databases

00:47:12,160 --> 00:47:15,520
are fine document databases are fine key

00:47:14,079 --> 00:47:17,520
value stores are fine it really depends

00:47:15,520 --> 00:47:19,839
on the problem you're trying to solve

00:47:17,520 --> 00:47:21,200
graph databases emphasize relationships

00:47:19,839 --> 00:47:23,040
heavily and so if you've got something

00:47:21,200 --> 00:47:26,400
that's really relational heavy

00:47:23,040 --> 00:47:28,720
uh it's a good choice um and so

00:47:26,400 --> 00:47:30,079
uh the the argument if you want to make

00:47:28,720 --> 00:47:31,200
a case for using graph database in your

00:47:30,079 --> 00:47:32,160
application is is

00:47:31,200 --> 00:47:34,079
you know you just need to find a

00:47:32,160 --> 00:47:35,359
justification as to you know why do i

00:47:34,079 --> 00:47:36,000
want to use a graph database well it's

00:47:35,359 --> 00:47:37,599
because

00:47:36,000 --> 00:47:39,280
i'm building a social graph okay well

00:47:37,599 --> 00:47:42,720
then that's a really good reason right

00:47:39,280 --> 00:47:43,200
um if your reason is is i think they're

00:47:42,720 --> 00:47:46,160
cool

00:47:43,200 --> 00:47:47,440
well that's not really a reason right i

00:47:46,160 --> 00:47:48,319
hope that's not your reason i hope i

00:47:47,440 --> 00:47:52,079
didn't just insult you

00:47:48,319 --> 00:47:54,319
inadvertently but um i think that said

00:47:52,079 --> 00:47:56,079
uh the metaphor for a graph database is

00:47:54,319 --> 00:47:57,359
really suitable for a lot of problems

00:47:56,079 --> 00:47:58,240
and i think it's more intuitive to work

00:47:57,359 --> 00:48:00,319
with

00:47:58,240 --> 00:48:02,000
and so um if you've got a small to

00:48:00,319 --> 00:48:03,200
medium-sized problem that might be a

00:48:02,000 --> 00:48:06,319
good option

00:48:03,200 --> 00:48:08,480
um and so it's you know

00:48:06,319 --> 00:48:09,839
yeah it kind of means the dba doesn't

00:48:08,480 --> 00:48:11,440
have a thing to do with it

00:48:09,839 --> 00:48:13,200
they don't have a thing they need to do

00:48:11,440 --> 00:48:16,319
uh which i suppose doesn't make

00:48:13,200 --> 00:48:21,040
graph databases popular with dbase

00:48:16,319 --> 00:48:22,720
so um but yeah so any other questions

00:48:21,040 --> 00:48:24,240
yes so following up on that same

00:48:22,720 --> 00:48:26,400
question how efficient are the

00:48:24,240 --> 00:48:30,960
implementations of graph databases

00:48:26,400 --> 00:48:33,280
compared to mature relational databases

00:48:30,960 --> 00:48:34,800
um i'd say uh graph databases the way

00:48:33,280 --> 00:48:38,079
they're represented internally

00:48:34,800 --> 00:48:39,920
makes them it makes them slower than a

00:48:38,079 --> 00:48:41,440
relational database because there's just

00:48:39,920 --> 00:48:44,160
i mean depends on the query of course

00:48:41,440 --> 00:48:45,280
but um because of the way they're stored

00:48:44,160 --> 00:48:46,400
you use uh

00:48:45,280 --> 00:48:48,079
there's a couple different ways to store

00:48:46,400 --> 00:48:48,800
them one way is really compact but it's

00:48:48,079 --> 00:48:51,839
slow

00:48:48,800 --> 00:48:54,400
another way is very fast but

00:48:51,839 --> 00:48:55,599
it takes up a huge amount of space and

00:48:54,400 --> 00:48:58,800
so you end up with like

00:48:55,599 --> 00:48:59,680
geometric increasing increasing of your

00:48:58,800 --> 00:49:01,280
space

00:48:59,680 --> 00:49:03,440
and so uh the way redis graph

00:49:01,280 --> 00:49:05,280
specifically does it is we use a sparse

00:49:03,440 --> 00:49:07,520
matrices which is sort of a uh

00:49:05,280 --> 00:49:09,280
it's a balanced approach and so most

00:49:07,520 --> 00:49:12,640
queries are pretty fast

00:49:09,280 --> 00:49:13,920
um but as

00:49:12,640 --> 00:49:15,599
you start getting like millions and

00:49:13,920 --> 00:49:16,800
millions of nodes graph databases are

00:49:15,599 --> 00:49:19,599
going to get slower

00:49:16,800 --> 00:49:21,280
and so if you've got really really big

00:49:19,599 --> 00:49:22,960
things it turns into an analytical

00:49:21,280 --> 00:49:24,480
database at that point as opposed to an

00:49:22,960 --> 00:49:26,800
operational data store

00:49:24,480 --> 00:49:27,920
for smaller and medium-sized problems i

00:49:26,800 --> 00:49:29,599
think you can get away with using

00:49:27,920 --> 00:49:31,280
graph database for as an operational

00:49:29,599 --> 00:49:32,000
data store but you need to have a good

00:49:31,280 --> 00:49:33,760
use case to

00:49:32,000 --> 00:49:35,440
again justify it because there is a

00:49:33,760 --> 00:49:37,599
trade-off there uh

00:49:35,440 --> 00:49:39,200
i could do some queries against this

00:49:37,599 --> 00:49:41,760
graph that i created which only has like

00:49:39,200 --> 00:49:45,119
20 rooms it's got maybe 50 nodes in it

00:49:41,760 --> 00:49:48,160
which my little laptop can't run

00:49:45,119 --> 00:49:48,880
so i very easily do queries like that so

00:49:48,160 --> 00:49:51,599
of course you can do that with a

00:49:48,880 --> 00:49:53,440
relational databases too can't you so

00:49:51,599 --> 00:49:54,800
so i hope i hope that answers the

00:49:53,440 --> 00:49:56,640
question

00:49:54,800 --> 00:49:59,119
okay we have one more how does one

00:49:56,640 --> 00:50:01,119
prevent type errors in a graph database

00:49:59,119 --> 00:50:03,440
monster leads to monster or room rather

00:50:01,119 --> 00:50:07,359
than room leads to room

00:50:03,440 --> 00:50:07,359
uh well you need to select um

00:50:07,680 --> 00:50:11,200
so yeah there's no reason you can't

00:50:09,599 --> 00:50:12,400
build a graph that has a monster leading

00:50:11,200 --> 00:50:14,880
to a room

00:50:12,400 --> 00:50:15,440
um you could or a monster containing a

00:50:14,880 --> 00:50:17,440
treasure

00:50:15,440 --> 00:50:19,440
maybe it was really hungry i don't know

00:50:17,440 --> 00:50:22,160
uh but

00:50:19,440 --> 00:50:22,800
uh your code has to do that right uh so

00:50:22,160 --> 00:50:25,920
they're uh

00:50:22,800 --> 00:50:27,040
it's schema-less and so that's just part

00:50:25,920 --> 00:50:28,400
of the territory

00:50:27,040 --> 00:50:30,079
the short answer is you can't do that

00:50:28,400 --> 00:50:32,079
you do that in your code

00:50:30,079 --> 00:50:33,839
um in some ways i said it's kind of like

00:50:32,079 --> 00:50:34,800
the schema versus schema is kind of like

00:50:33,839 --> 00:50:36,559
the distinction between

00:50:34,800 --> 00:50:37,920
strongly typed language versus loosely

00:50:36,559 --> 00:50:39,760
typed language uh

00:50:37,920 --> 00:50:41,040
loosely typed languages you have to take

00:50:39,760 --> 00:50:42,559
measures to make sure that that doesn't

00:50:41,040 --> 00:50:44,000
happen

00:50:42,559 --> 00:50:46,079
where strongly typed languages do that

00:50:44,000 --> 00:50:48,160
for you similar for graph databases

00:50:46,079 --> 00:50:50,640
versus relational databases or document

00:50:48,160 --> 00:50:52,400
databases

00:50:50,640 --> 00:50:53,760
okay one final question just came in at

00:50:52,400 --> 00:50:55,599
scale where ultimately

00:50:53,760 --> 00:50:57,760
everything can be connected to anything

00:50:55,599 --> 00:51:01,200
else can redis graphs be

00:50:57,760 --> 00:51:04,960
sharded uh can you shard red this graph

00:51:01,200 --> 00:51:07,760
i actually um well yeah the answer is no

00:51:04,960 --> 00:51:08,559
actually um i haven't played around with

00:51:07,760 --> 00:51:10,640
that much but

00:51:08,559 --> 00:51:12,240
uh the graph is a single key in the

00:51:10,640 --> 00:51:13,760
redis graph in the database

00:51:12,240 --> 00:51:15,599
and so that key is going to exist on a

00:51:13,760 --> 00:51:17,119
single shard so uh

00:51:15,599 --> 00:51:19,040
sharding it it doesn't work you can

00:51:17,119 --> 00:51:21,119
replicate it um

00:51:19,040 --> 00:51:22,720
that totally works uh although i'm sure

00:51:21,119 --> 00:51:24,000
there's a whole ton of caveats there

00:51:22,720 --> 00:51:25,680
just like there is with replication in

00:51:24,000 --> 00:51:27,440
general just like replicating a hash

00:51:25,680 --> 00:51:30,480
it's got a similar problem

00:51:27,440 --> 00:51:31,839
um and so there is you know some

00:51:30,480 --> 00:51:34,480
subtlety there

00:51:31,839 --> 00:51:37,839
but uh now for sharding the graph exists

00:51:34,480 --> 00:51:37,839

YouTube URL: https://www.youtube.com/watch?v=X59DEx-4i74


