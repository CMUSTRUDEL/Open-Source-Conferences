Title: Building Streaming Data Apps with Pac-Man - Ricardo Ferreira
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Databases Track
Description: 
	Presented by: Ricardo Ferreira, Elastic
Presented at All Things Open 2020 - Databases Track

Abstract: Since Pac-Man was originally released in the ’80s, it has been a beacon of fun and joy for people of all ages. What few people know is that this game can also be used to inspire developers on how to build streaming data applications. In this near-zero-slides talk, attendees will get to play the game to generate events. As they play, the presenter will write from scratch a scoreboard using ksqlDB — an open-source streaming database built for Apache Kafka. After building the scoreboard, it will be discussed the different strategies to send the generated scoreboard to ElasticSearch and Kibana — where the real action actually happens.
Captions: 
	00:00:05,440 --> 00:00:10,080
evening morning uh everybody that's

00:00:07,520 --> 00:00:11,679
uh coming here i appreciate you coming i

00:00:10,080 --> 00:00:11,920
hope you are enjoying this conference as

00:00:11,679 --> 00:00:14,320
i

00:00:11,920 --> 00:00:15,280
am because all things open is one of the

00:00:14,320 --> 00:00:17,680
best conference for

00:00:15,280 --> 00:00:19,039
learning technology so uh i think that's

00:00:17,680 --> 00:00:20,720
great for all of us that

00:00:19,039 --> 00:00:23,199
this year we were able to do that even

00:00:20,720 --> 00:00:24,000
online so this session is going to be

00:00:23,199 --> 00:00:26,880
about

00:00:24,000 --> 00:00:28,000
uh streaming data right uh i'm gonna

00:00:26,880 --> 00:00:30,000
spend a little

00:00:28,000 --> 00:00:31,279
kind of five minutes explaining like

00:00:30,000 --> 00:00:32,559
what streaming data is

00:00:31,279 --> 00:00:34,320
for those of you that never heard about

00:00:32,559 --> 00:00:37,120
the term four and

00:00:34,320 --> 00:00:37,840
the way we are going to present this is

00:00:37,120 --> 00:00:41,520
using

00:00:37,840 --> 00:00:42,800
the game pacman as um as a technique for

00:00:41,520 --> 00:00:43,440
making things a little easier to

00:00:42,800 --> 00:00:44,879
understand

00:00:43,440 --> 00:00:46,800
right because streaming data is usually

00:00:44,879 --> 00:00:47,120
kind of a very complicated uh thing to

00:00:46,800 --> 00:00:49,760
uh

00:00:47,120 --> 00:00:50,719
to observe so uh this is something that

00:00:49,760 --> 00:00:52,879
i felt

00:00:50,719 --> 00:00:54,239
that using a metaphor like pacman it

00:00:52,879 --> 00:00:57,520
helps us to

00:00:54,239 --> 00:00:59,760
digest a little easier right so uh

00:00:57,520 --> 00:01:02,320
my name for those of you that don't know

00:00:59,760 --> 00:01:04,799
me uh my name is ricardo ferreira

00:01:02,320 --> 00:01:05,439
um here we go all right the clicker is

00:01:04,799 --> 00:01:07,040
not

00:01:05,439 --> 00:01:08,479
all right backing part my name is

00:01:07,040 --> 00:01:10,000
ricardo ferreira and i work as a

00:01:08,479 --> 00:01:12,400
developer advocate

00:01:10,000 --> 00:01:13,920
uh so i'd like to explain that my job is

00:01:12,400 --> 00:01:17,280
primarily to connect

00:01:13,920 --> 00:01:19,680
people with knowledge right so

00:01:17,280 --> 00:01:21,200
uh i'm currently working at elastic so

00:01:19,680 --> 00:01:22,799
uh probably have heard about elastic

00:01:21,200 --> 00:01:24,320
before last week is the company that's

00:01:22,799 --> 00:01:27,280
behind the elastic stack

00:01:24,320 --> 00:01:28,560
uh bono like stash uh beats and

00:01:27,280 --> 00:01:30,799
elasticsearch

00:01:28,560 --> 00:01:32,799
uh previously i've worked it in other

00:01:30,799 --> 00:01:34,320
technology vendors such as confluent and

00:01:32,799 --> 00:01:36,640
oracle and red hat

00:01:34,320 --> 00:01:38,479
and primarily the type of technology

00:01:36,640 --> 00:01:41,200
that i like to uh work with

00:01:38,479 --> 00:01:41,680
and talk about it is streaming data big

00:01:41,200 --> 00:01:44,000
data

00:01:41,680 --> 00:01:45,920
analytics nosql and cloud so those are

00:01:44,000 --> 00:01:47,759
the things that if you're interested in

00:01:45,920 --> 00:01:49,360
learning a little bit more i'm more than

00:01:47,759 --> 00:01:51,759
welcome to do it um

00:01:49,360 --> 00:01:52,880
i prefer all my contacts like my email

00:01:51,759 --> 00:01:55,600
from elastic

00:01:52,880 --> 00:01:56,560
and my personal email as well as my blog

00:01:55,600 --> 00:01:58,000
here on the bottom

00:01:56,560 --> 00:01:59,840
right and for those of you that use

00:01:58,000 --> 00:02:01,680
twitter please go ahead and

00:01:59,840 --> 00:02:02,880
follow me on twitter use from time to

00:02:01,680 --> 00:02:05,040
time i kind of share some

00:02:02,880 --> 00:02:06,159
interesting content right there as well

00:02:05,040 --> 00:02:09,280
right so

00:02:06,159 --> 00:02:09,759
let's get to it uh what is streaming

00:02:09,280 --> 00:02:12,319
data

00:02:09,759 --> 00:02:13,520
right so streaming data is basically an

00:02:12,319 --> 00:02:15,840
architecture style

00:02:13,520 --> 00:02:17,280
right uh it's usually known as well as a

00:02:15,840 --> 00:02:19,840
streaming data architecture

00:02:17,280 --> 00:02:21,360
right so the whole reason why this

00:02:19,840 --> 00:02:24,400
architecture style has been

00:02:21,360 --> 00:02:28,239
built and concept is

00:02:24,400 --> 00:02:31,120
to solve the problem of how do we

00:02:28,239 --> 00:02:33,760
don't let data to perish right so there

00:02:31,120 --> 00:02:33,760
is this um

00:02:34,160 --> 00:02:38,239
kind of a report from forrester is

00:02:36,400 --> 00:02:41,200
called perishable insights

00:02:38,239 --> 00:02:42,640
that basically evaluates in a timeline

00:02:41,200 --> 00:02:45,120
where the data becomes

00:02:42,640 --> 00:02:45,920
perishable right so when data becomes

00:02:45,120 --> 00:02:49,040
stale

00:02:45,920 --> 00:02:52,000
per se so if you consider the

00:02:49,040 --> 00:02:53,840
the exact moment when the data happens

00:02:52,000 --> 00:02:56,720
right when the data was created

00:02:53,840 --> 00:02:57,440
or generated by some application right

00:02:56,720 --> 00:03:00,720
uh

00:02:57,440 --> 00:03:01,200
if you take the decision up to the

00:03:00,720 --> 00:03:04,560
window

00:03:01,200 --> 00:03:08,000
of real time or even seconds minutes or

00:03:04,560 --> 00:03:10,640
perhaps we might can think about some

00:03:08,000 --> 00:03:11,840
like streaming data scenarios consider

00:03:10,640 --> 00:03:13,760
hours as well

00:03:11,840 --> 00:03:16,000
it could be considered streaming data as

00:03:13,760 --> 00:03:18,400
as although not so fast as

00:03:16,000 --> 00:03:19,040
seconds and minutes is where you can

00:03:18,400 --> 00:03:21,920
actually

00:03:19,040 --> 00:03:23,760
uh take advantage of what actually

00:03:21,920 --> 00:03:26,239
happened in a given point in time

00:03:23,760 --> 00:03:28,159
right uh but if you contrast and compare

00:03:26,239 --> 00:03:30,000
about how we actually implement this

00:03:28,159 --> 00:03:30,480
type of analytics architecture these

00:03:30,000 --> 00:03:32,720
days

00:03:30,480 --> 00:03:35,760
right and how we've been doing for the

00:03:32,720 --> 00:03:37,599
last probably i don't know 30 years

00:03:35,760 --> 00:03:39,280
is we've been using this traditional bat

00:03:37,599 --> 00:03:41,519
oriented analytics where

00:03:39,280 --> 00:03:43,599
all the data is actually analyzes in a

00:03:41,519 --> 00:03:47,519
sphere of days and or months

00:03:43,599 --> 00:03:49,760
right uh the the justification by

00:03:47,519 --> 00:03:51,599
why we're doing this uh varies a lot uh

00:03:49,760 --> 00:03:53,519
i've heard of people saying that yeah

00:03:51,599 --> 00:03:55,200
the problem is that we cannot process as

00:03:53,519 --> 00:03:57,200
in as the data happens

00:03:55,200 --> 00:03:59,120
by the time they happen because our

00:03:57,200 --> 00:04:02,080
systems are going to slow down

00:03:59,120 --> 00:04:03,760
if we if we do this right or perhaps oh

00:04:02,080 --> 00:04:06,080
no maybe we're trying to

00:04:03,760 --> 00:04:07,360
like first gather the data store it and

00:04:06,080 --> 00:04:08,560
then we're gonna

00:04:07,360 --> 00:04:10,640
we're gonna figure out what to do with

00:04:08,560 --> 00:04:12,640
the data later so you name it i mean

00:04:10,640 --> 00:04:15,599
there's a lot of uh

00:04:12,640 --> 00:04:16,880
scenarios where the justification is we

00:04:15,599 --> 00:04:18,959
have to process the data

00:04:16,880 --> 00:04:20,400
but the problem is by the time we

00:04:18,959 --> 00:04:23,520
process the data later

00:04:20,400 --> 00:04:25,840
maybe we're leaving aside some window of

00:04:23,520 --> 00:04:28,880
opportunity or maybe a threat

00:04:25,840 --> 00:04:30,800
that could be identified in a spot right

00:04:28,880 --> 00:04:31,280
so that's why streaming data come into

00:04:30,800 --> 00:04:33,759
place

00:04:31,280 --> 00:04:34,560
right so as i mentioned before streaming

00:04:33,759 --> 00:04:36,720
data is uh

00:04:34,560 --> 00:04:38,320
architecture style and like any

00:04:36,720 --> 00:04:40,720
architecture is comprised of

00:04:38,320 --> 00:04:42,639
layers so uh there's the source data

00:04:40,720 --> 00:04:44,320
layer which is basically represents the

00:04:42,639 --> 00:04:45,520
data that is being generated by some

00:04:44,320 --> 00:04:47,759
application right

00:04:45,520 --> 00:04:49,360
uh there's the string ingestion layer

00:04:47,759 --> 00:04:50,800
which is essentially the layer that's

00:04:49,360 --> 00:04:53,919
going to take care of

00:04:50,800 --> 00:04:56,639
uh it knows how to handle and read the

00:04:53,919 --> 00:04:57,520
source data somehow and it's going to be

00:04:56,639 --> 00:05:00,240
responsible for

00:04:57,520 --> 00:05:01,360
injustice into something that we call

00:05:00,240 --> 00:05:03,840
the stream

00:05:01,360 --> 00:05:05,039
storage or stream buffer some some

00:05:03,840 --> 00:05:07,120
technologies out there

00:05:05,039 --> 00:05:08,320
or some vendors like to call stream

00:05:07,120 --> 00:05:10,080
buffer as well

00:05:08,320 --> 00:05:11,600
i like it to call stream stars because

00:05:10,080 --> 00:05:14,320
it makes sense because it is

00:05:11,600 --> 00:05:14,960
it's literally a storage for uh data

00:05:14,320 --> 00:05:16,880
right

00:05:14,960 --> 00:05:18,960
and why you're going to start that right

00:05:16,880 --> 00:05:21,280
it is basically a buffer because

00:05:18,960 --> 00:05:23,199
furthermore you're going to process

00:05:21,280 --> 00:05:24,880
you're going to process those streams

00:05:23,199 --> 00:05:26,400
right you're going to shape those

00:05:24,880 --> 00:05:29,039
streams somehow

00:05:26,400 --> 00:05:29,759
for the purpose of doing analytics right

00:05:29,039 --> 00:05:31,360
so

00:05:29,759 --> 00:05:33,120
uh the way to interpret this

00:05:31,360 --> 00:05:35,680
architecture style over here is that

00:05:33,120 --> 00:05:37,680
this is the end this is the end game

00:05:35,680 --> 00:05:39,280
doing analytics is what you want to do

00:05:37,680 --> 00:05:40,960
right but before you actually do an

00:05:39,280 --> 00:05:41,919
analytics you have to transform your

00:05:40,960 --> 00:05:45,199
source data

00:05:41,919 --> 00:05:47,360
into a shape into a format that can be

00:05:45,199 --> 00:05:48,320
like uh you can handle easier in the

00:05:47,360 --> 00:05:50,240
analytics layer

00:05:48,320 --> 00:05:52,240
where you no longer have to do some

00:05:50,240 --> 00:05:52,880
transformation some aggregations some

00:05:52,240 --> 00:05:55,360
enrichments

00:05:52,880 --> 00:05:56,400
and things like that right you just play

00:05:55,360 --> 00:05:59,280
with the data

00:05:56,400 --> 00:06:00,960
right i know this is very complicated

00:05:59,280 --> 00:06:01,840
like but the first time i started uh

00:06:00,960 --> 00:06:03,280
studying this

00:06:01,840 --> 00:06:04,880
concept before this is the phase that

00:06:03,280 --> 00:06:07,600
i've done right and

00:06:04,880 --> 00:06:09,199
streaming data architectures are fairly

00:06:07,600 --> 00:06:10,319
kind of a complicated to understand and

00:06:09,199 --> 00:06:12,400
that's why

00:06:10,319 --> 00:06:14,800
i've created this kind of a it's more

00:06:12,400 --> 00:06:17,840
than an approach it's more like a demo

00:06:14,800 --> 00:06:20,960
right that i call the pac-man dev right

00:06:17,840 --> 00:06:22,560
it's a way to teach complicated um

00:06:20,960 --> 00:06:24,720
subjects such as extra media

00:06:22,560 --> 00:06:27,120
architectures right so the way i

00:06:24,720 --> 00:06:28,319
choose to present this uh session here

00:06:27,120 --> 00:06:30,720
specifically today

00:06:28,319 --> 00:06:32,160
is i'm gonna let you literally play the

00:06:30,720 --> 00:06:34,880
game pac-man here so

00:06:32,160 --> 00:06:36,639
you're gonna actually grab your devices

00:06:34,880 --> 00:06:38,720
or computers if you have it

00:06:36,639 --> 00:06:40,560
and you're gonna get to play the game

00:06:38,720 --> 00:06:43,360
and why you're gonna do this right

00:06:40,560 --> 00:06:44,160
because the first thing you're gonna

00:06:43,360 --> 00:06:46,160
actually help

00:06:44,160 --> 00:06:47,199
me with this demonstration is to

00:06:46,160 --> 00:06:49,919
generate

00:06:47,199 --> 00:06:51,120
what i call before the source data right

00:06:49,919 --> 00:06:52,960
so the search data

00:06:51,120 --> 00:06:54,720
will come from events that will come

00:06:52,960 --> 00:06:56,560
from your games right

00:06:54,720 --> 00:06:58,479
um so what i'm going to do what's going

00:06:56,560 --> 00:07:00,479
to be my responsibility right

00:06:58,479 --> 00:07:02,639
so i'm going to transform that source

00:07:00,479 --> 00:07:06,080
data that will end up

00:07:02,639 --> 00:07:06,720
into my stream buffer or stream storage

00:07:06,080 --> 00:07:09,360
layer which

00:07:06,720 --> 00:07:11,440
happens to be kafka in this demo right

00:07:09,360 --> 00:07:14,639
and i will create

00:07:11,440 --> 00:07:16,000
this let's call application for now but

00:07:14,639 --> 00:07:19,039
i'm going to create this

00:07:16,000 --> 00:07:20,720
scoreboard application right so the

00:07:19,039 --> 00:07:21,599
scoreboard application the purpose is

00:07:20,720 --> 00:07:23,280
real simple

00:07:21,599 --> 00:07:25,039
it's going to list all the players that

00:07:23,280 --> 00:07:26,800
are playing or have played

00:07:25,039 --> 00:07:28,479
before right because it handles

00:07:26,800 --> 00:07:31,520
historical data as well

00:07:28,479 --> 00:07:32,319
and it's going to sort them in such a

00:07:31,520 --> 00:07:34,960
way that

00:07:32,319 --> 00:07:35,440
the players who have the highest score

00:07:34,960 --> 00:07:38,639
or

00:07:35,440 --> 00:07:39,520
the highest level or have not lost too

00:07:38,639 --> 00:07:41,759
much

00:07:39,520 --> 00:07:42,639
is going to be handed and uh in the

00:07:41,759 --> 00:07:44,720
first positions

00:07:42,639 --> 00:07:46,160
right and you're going to see that this

00:07:44,720 --> 00:07:49,039
is going to happen in near

00:07:46,160 --> 00:07:50,960
real time as you play the scoreboard is

00:07:49,039 --> 00:07:53,120
going to be automatically computed

00:07:50,960 --> 00:07:54,400
and redisplayed that's the goal that's

00:07:53,120 --> 00:07:56,240
what we are going to build

00:07:54,400 --> 00:07:58,479
over here right but as i mentioned

00:07:56,240 --> 00:08:00,160
before first thing we need to do

00:07:58,479 --> 00:08:01,919
before actually playing and implementing

00:08:00,160 --> 00:08:05,440
anything we need data

00:08:01,919 --> 00:08:06,800
right so let me explain the architecture

00:08:05,440 --> 00:08:07,680
of this application it's not very

00:08:06,800 --> 00:08:10,000
complicated

00:08:07,680 --> 00:08:12,080
uh once you understand the relationship

00:08:10,000 --> 00:08:14,479
between the source data

00:08:12,080 --> 00:08:15,919
the string buffer or the string storage

00:08:14,479 --> 00:08:18,080
the stream processors

00:08:15,919 --> 00:08:19,280
and the analytics layer right so the

00:08:18,080 --> 00:08:20,879
source data what's going to be the

00:08:19,280 --> 00:08:21,919
source data as i mentioned before the

00:08:20,879 --> 00:08:24,080
search data is going to be

00:08:21,919 --> 00:08:25,680
uh what the events that we're coming

00:08:24,080 --> 00:08:27,039
from out of your phones

00:08:25,680 --> 00:08:28,879
so you're going to have you're going to

00:08:27,039 --> 00:08:30,560
play with your tablet

00:08:28,879 --> 00:08:32,240
phone computer whatever you want to

00:08:30,560 --> 00:08:33,519
choose as advice right

00:08:32,240 --> 00:08:35,440
and as you play basically the

00:08:33,519 --> 00:08:38,560
application has been built

00:08:35,440 --> 00:08:41,279
to invoke some apis everything is

00:08:38,560 --> 00:08:43,680
running on aws right now right

00:08:41,279 --> 00:08:44,880
so it's gonna invoke some apis that are

00:08:43,680 --> 00:08:47,600
being exposed

00:08:44,880 --> 00:08:48,399
by an api gateway that have provision on

00:08:47,600 --> 00:08:51,040
aws

00:08:48,399 --> 00:08:51,760
right so it is a rast api ultimately

00:08:51,040 --> 00:08:53,920
right

00:08:51,760 --> 00:08:55,120
so by the time this api is actually

00:08:53,920 --> 00:08:57,120
executed

00:08:55,120 --> 00:08:58,320
the back-end implementation of this api

00:08:57,120 --> 00:09:01,360
is a lambda function

00:08:58,320 --> 00:09:02,000
right which is i happen to wrote this in

00:09:01,360 --> 00:09:03,680
java

00:09:02,000 --> 00:09:04,959
right but it could be anything right i

00:09:03,680 --> 00:09:06,320
could have written this in any

00:09:04,959 --> 00:09:08,640
programming language

00:09:06,320 --> 00:09:10,399
uh i've chose write java just because

00:09:08,640 --> 00:09:13,440
this is my thing right this is

00:09:10,399 --> 00:09:15,200
what i'm best at it uh and then the job

00:09:13,440 --> 00:09:16,399
of this lambda function is essentially

00:09:15,200 --> 00:09:19,519
to grab the event

00:09:16,399 --> 00:09:22,160
and to write into a kafka topic

00:09:19,519 --> 00:09:24,240
right kafka is being used here in this

00:09:22,160 --> 00:09:26,000
demo as my stores layer

00:09:24,240 --> 00:09:27,360
so all the layers on the application

00:09:26,000 --> 00:09:30,640
basically communicate

00:09:27,360 --> 00:09:32,320
through each other using kafka right so

00:09:30,640 --> 00:09:34,000
uh i'm going to call this input data

00:09:32,320 --> 00:09:36,800
right so the input data is going to be

00:09:34,000 --> 00:09:38,000
written here and then my job as i

00:09:36,800 --> 00:09:40,560
mentioned before it just

00:09:38,000 --> 00:09:42,320
is to transform this raw data into

00:09:40,560 --> 00:09:43,200
something that can be look like into a

00:09:42,320 --> 00:09:45,680
scoreboard

00:09:43,200 --> 00:09:48,000
right and for that i'm going to use a

00:09:45,680 --> 00:09:50,399
stream processor technology

00:09:48,000 --> 00:09:52,160
it's it's actually a database uh it can

00:09:50,399 --> 00:09:55,200
be considered a database called

00:09:52,160 --> 00:09:58,320
k sql db right uh

00:09:55,200 --> 00:09:59,600
although the name db stands for

00:09:58,320 --> 00:10:02,399
obviously database

00:09:59,600 --> 00:10:03,760
right uh key security b is what we call

00:10:02,399 --> 00:10:05,760
a streaming database

00:10:03,760 --> 00:10:06,800
right a streaming database is a new type

00:10:05,760 --> 00:10:10,240
of database

00:10:06,800 --> 00:10:13,360
where it's totally and 100 driven by

00:10:10,240 --> 00:10:15,200
events and streams coming in and then

00:10:13,360 --> 00:10:17,760
the purpose of this database is to

00:10:15,200 --> 00:10:21,360
reliably and durably store those events

00:10:17,760 --> 00:10:23,680
and process them as they happen right so

00:10:21,360 --> 00:10:25,440
k sigo db is has been built on top of

00:10:23,680 --> 00:10:27,279
apache kafka right so

00:10:25,440 --> 00:10:29,120
uh if you ask me where the data is

00:10:27,279 --> 00:10:30,800
actually stored where the data is

00:10:29,120 --> 00:10:32,320
actually being uh it's going to end up

00:10:30,800 --> 00:10:34,959
after the processing kafka

00:10:32,320 --> 00:10:35,839
right so you have the concept of input

00:10:34,959 --> 00:10:37,440
topics

00:10:35,839 --> 00:10:39,920
you're going to have your processors

00:10:37,440 --> 00:10:42,800
that are going to handle the input topic

00:10:39,920 --> 00:10:43,120
and whatever the processors uh came out

00:10:42,800 --> 00:10:46,399
as

00:10:43,120 --> 00:10:46,959
output is going to be flush into let's

00:10:46,399 --> 00:10:50,079
call

00:10:46,959 --> 00:10:50,480
output topic ultimately every all the

00:10:50,079 --> 00:10:54,000
data

00:10:50,480 --> 00:10:55,600
input and output lives on kafka right so

00:10:54,000 --> 00:10:57,040
this is one of the key characteristics

00:10:55,600 --> 00:10:59,360
of implement

00:10:57,040 --> 00:11:00,240
uh streaming data architectures using uh

00:10:59,360 --> 00:11:03,360
k squared b

00:11:00,240 --> 00:11:07,120
and kafka right so kafka is your

00:11:03,360 --> 00:11:09,920
stars layer right okay so

00:11:07,120 --> 00:11:10,480
let's start with the fun part which is

00:11:09,920 --> 00:11:13,200
you

00:11:10,480 --> 00:11:15,200
actually playing the game right so what

00:11:13,200 --> 00:11:17,200
i would like ask everybody to do right

00:11:15,200 --> 00:11:19,600
now is to grab your devices either

00:11:17,200 --> 00:11:20,480
phones or tablets right i've i've tested

00:11:19,600 --> 00:11:22,800
this basically

00:11:20,480 --> 00:11:24,720
pretty much with all devices if you

00:11:22,800 --> 00:11:26,959
happen to use a device that

00:11:24,720 --> 00:11:28,480
don't work let me know right because

00:11:26,959 --> 00:11:30,720
this is gonna be like a pr

00:11:28,480 --> 00:11:32,000
for this project that i've created uh

00:11:30,720 --> 00:11:33,120
but hopefully it's gonna work for

00:11:32,000 --> 00:11:35,200
everybody so

00:11:33,120 --> 00:11:37,040
uh this is a web application you don't

00:11:35,200 --> 00:11:39,040
have to stall anything right so

00:11:37,040 --> 00:11:41,200
scan this barcode over here and you're

00:11:39,040 --> 00:11:44,160
gonna be able to actually um

00:11:41,200 --> 00:11:46,000
let's see the game right and the game is

00:11:44,160 --> 00:11:48,160
going to ask you to provide a name right

00:11:46,000 --> 00:11:49,920
which can be either your name itself

00:11:48,160 --> 00:11:52,320
or it can be your nickname or something

00:11:49,920 --> 00:11:53,519
that uniquely identifies you right this

00:11:52,320 --> 00:11:54,639
is going to be important for the

00:11:53,519 --> 00:11:57,360
scoreboard so

00:11:54,639 --> 00:11:58,160
you can see uh your name the scoreboard

00:11:57,360 --> 00:12:00,880
right

00:11:58,160 --> 00:12:02,160
uh please be nice right because you and

00:12:00,880 --> 00:12:03,040
the application you can write whatever

00:12:02,160 --> 00:12:04,800
you want to

00:12:03,040 --> 00:12:06,480
uh be polite with whatever you write

00:12:04,800 --> 00:12:07,839
there because because it's gonna show up

00:12:06,480 --> 00:12:09,360
here in my screen so

00:12:07,839 --> 00:12:11,279
i would like to confirm with the

00:12:09,360 --> 00:12:12,560
policies of the good behavior of the

00:12:11,279 --> 00:12:15,360
conference so

00:12:12,560 --> 00:12:15,839
please uh help me out over here right uh

00:12:15,360 --> 00:12:18,160
so

00:12:15,839 --> 00:12:19,920
yeah uh for those of you that maybe

00:12:18,160 --> 00:12:22,320
would like to use computers

00:12:19,920 --> 00:12:23,440
uh i'm gonna share right now here on the

00:12:22,320 --> 00:12:25,600
chat

00:12:23,440 --> 00:12:27,279
the url of the game so you don't have to

00:12:25,600 --> 00:12:29,440
actually scan the power cord so

00:12:27,279 --> 00:12:30,800
i'm gonna stop sharing just for a second

00:12:29,440 --> 00:12:33,920
right i'm gonna

00:12:30,800 --> 00:12:36,160
do this and this is the url

00:12:33,920 --> 00:12:39,839
of the game i'm gonna put here on the

00:12:36,160 --> 00:12:44,000
chat for everybody

00:12:39,839 --> 00:12:47,680
all panelists so this is the

00:12:44,000 --> 00:12:50,720
pac-man game url so

00:12:47,680 --> 00:12:53,519
uh here's the the url

00:12:50,720 --> 00:12:54,079
and while you're there i'm gonna

00:12:53,519 --> 00:12:56,480
actually

00:12:54,079 --> 00:12:59,040
monitor to see if there if there is

00:12:56,480 --> 00:13:02,399
somebody actually playing here

00:12:59,040 --> 00:13:04,079
using this window over here i'm gonna

00:13:02,399 --> 00:13:07,440
explain what i'm using right now

00:13:04,079 --> 00:13:09,680
later on but for now just see this as my

00:13:07,440 --> 00:13:09,680
uh

00:13:09,920 --> 00:13:13,600
troubleshooting engine yeah there are

00:13:12,720 --> 00:13:17,440
some people playing

00:13:13,600 --> 00:13:19,680
that's good like to see that and

00:13:17,440 --> 00:13:21,120
let me know if you still want to have

00:13:19,680 --> 00:13:23,680
the barcode somewhere

00:13:21,120 --> 00:13:25,360
but the url it's on the chat so you can

00:13:23,680 --> 00:13:28,320
grab from there from there as well

00:13:25,360 --> 00:13:28,959
so i'm gonna give you like uh two

00:13:28,320 --> 00:13:31,360
minutes

00:13:28,959 --> 00:13:32,639
to play because we have to have data

00:13:31,360 --> 00:13:34,240
right in order to actually start

00:13:32,639 --> 00:13:37,839
building anything useful

00:13:34,240 --> 00:13:37,839
so just have fun

00:13:39,920 --> 00:13:44,880
can you send the link to the show yes uh

00:13:42,399 --> 00:13:48,079
page i'm gonna resend the link

00:13:44,880 --> 00:13:51,600
bear with me for a second uh

00:13:48,079 --> 00:14:03,839
and let me know page if you got it

00:13:51,600 --> 00:14:03,839
right so otherwise i can say it again

00:14:09,920 --> 00:14:13,600
so you you can continue to play just

00:14:12,399 --> 00:14:17,279
hear me out

00:14:13,600 --> 00:14:18,880
uh when i said that streaming data

00:14:17,279 --> 00:14:20,720
architecture is comprised by the first

00:14:18,880 --> 00:14:21,519
layer that's called the source data

00:14:20,720 --> 00:14:23,519
right

00:14:21,519 --> 00:14:24,560
where i was referring to literally is

00:14:23,519 --> 00:14:27,279
this so

00:14:24,560 --> 00:14:28,399
this bunch of characters that are coming

00:14:27,279 --> 00:14:31,839
in continuously

00:14:28,399 --> 00:14:34,000
is what we call the stream theta right

00:14:31,839 --> 00:14:35,600
why string data because the main

00:14:34,000 --> 00:14:37,519
characteristics of streams

00:14:35,600 --> 00:14:39,199
is that they happen continuously they

00:14:37,519 --> 00:14:42,560
never stop there's no

00:14:39,199 --> 00:14:44,959
oh yeah no there's a batch window of

00:14:42,560 --> 00:14:45,760
eight hours where we're gonna cut that

00:14:44,959 --> 00:14:47,519
off and then

00:14:45,760 --> 00:14:49,600
we're gonna process whatever has been

00:14:47,519 --> 00:14:50,320
comprised of that widow there's no batch

00:14:49,600 --> 00:14:52,800
in here

00:14:50,320 --> 00:14:54,000
there's no windows now that's the main

00:14:52,800 --> 00:14:57,839
characteristics of

00:14:54,000 --> 00:15:00,720
a streaming database versus a standard

00:14:57,839 --> 00:15:03,199
relational or nosql database where

00:15:00,720 --> 00:15:05,839
you and those type of databases you

00:15:03,199 --> 00:15:08,000
handle what we call a point in time

00:15:05,839 --> 00:15:10,000
uh data right with data that has been

00:15:08,000 --> 00:15:13,440
captured in a given point in time

00:15:10,000 --> 00:15:15,920
of uh of life right and a streaming

00:15:13,440 --> 00:15:17,920
database

00:15:15,920 --> 00:15:19,199
all the data happens continuously all

00:15:17,920 --> 00:15:22,399
the time there's no

00:15:19,199 --> 00:15:24,399
finish right so that's why the industry

00:15:22,399 --> 00:15:26,160
had to create a new technology to handle

00:15:24,399 --> 00:15:28,399
that type of situation because

00:15:26,160 --> 00:15:30,079
the existing database were not able to

00:15:28,399 --> 00:15:32,320
handle that right

00:15:30,079 --> 00:15:34,560
you can try to implement using a

00:15:32,320 --> 00:15:37,440
relational database for example

00:15:34,560 --> 00:15:39,040
probably it's going to work like you can

00:15:37,440 --> 00:15:40,079
try to come up with some sort of a

00:15:39,040 --> 00:15:42,320
polling mechanism

00:15:40,079 --> 00:15:43,199
that keeps like reading the database and

00:15:42,320 --> 00:15:46,399
hitting the

00:15:43,199 --> 00:15:48,399
database every one second for example uh

00:15:46,399 --> 00:15:49,759
that worked yeah okay but it's not

00:15:48,399 --> 00:15:51,279
streaming right

00:15:49,759 --> 00:15:53,199
and in the end of the day you are still

00:15:51,279 --> 00:15:57,440
handed a window of one second

00:15:53,199 --> 00:15:57,440
right so it's not continuous right

00:15:58,320 --> 00:16:03,279
oh okay so paige um sorry i didn't see

00:16:01,519 --> 00:16:06,880
your

00:16:03,279 --> 00:16:10,320
okay so let me try to send that data

00:16:06,880 --> 00:16:12,320
oh i am sorry paige that was my fault

00:16:10,320 --> 00:16:13,600
my apologies because i was sending only

00:16:12,320 --> 00:16:16,079
to the panelists

00:16:13,600 --> 00:16:16,800
not for the panelists and the attendees

00:16:16,079 --> 00:16:20,160
so

00:16:16,800 --> 00:16:23,839
you should have right now

00:16:20,160 --> 00:16:23,839
just let me know

00:16:40,079 --> 00:16:46,800
you're welcome okay so um

00:16:44,000 --> 00:16:48,800
because i've made a mistake i've not

00:16:46,800 --> 00:16:51,120
shared with everybody i'm going to

00:16:48,800 --> 00:16:52,079
give you like two minutes one minute and

00:16:51,120 --> 00:16:55,360
a half to play

00:16:52,079 --> 00:17:05,839
okay and then we can

00:16:55,360 --> 00:17:05,839
continue from there

00:17:48,320 --> 00:17:56,400
all right so 45 seconds left

00:17:52,880 --> 00:18:00,320
and then i'll ask everybody to

00:17:56,400 --> 00:18:03,919
please stop playing for a bit and then

00:18:00,320 --> 00:18:03,919
so you can see the implementation of the

00:18:12,840 --> 00:18:15,840
scoreboard

00:18:32,799 --> 00:18:36,320
okay so let me ask you this for

00:18:35,039 --> 00:18:38,720
everybody could

00:18:36,320 --> 00:18:39,360
everybody right now stop playing for a

00:18:38,720 --> 00:18:41,440
second

00:18:39,360 --> 00:18:42,640
and i want you to look at here to my

00:18:41,440 --> 00:18:45,919
screen

00:18:42,640 --> 00:18:48,799
so what should happen is that no no new

00:18:45,919 --> 00:18:48,799
entry should come in

00:18:49,039 --> 00:18:55,600
so i can see that there is a person call

00:18:53,039 --> 00:18:56,400
they call itself no worries and as well

00:18:55,600 --> 00:18:59,280
page

00:18:56,400 --> 00:19:00,559
are still working okay they've stopped

00:18:59,280 --> 00:19:03,200
playing right now

00:19:00,559 --> 00:19:04,720
they're worse okay so that's you see

00:19:03,200 --> 00:19:05,280
that's the beauty of streaming data

00:19:04,720 --> 00:19:06,960
right

00:19:05,280 --> 00:19:08,799
uh because they happen continuously you

00:19:06,960 --> 00:19:09,360
can actually monitor what's real time or

00:19:08,799 --> 00:19:11,440
not

00:19:09,360 --> 00:19:14,320
so by the time nobody actually playing

00:19:11,440 --> 00:19:17,120
no events should come in right now right

00:19:14,320 --> 00:19:18,559
so no words is too plain so i would say

00:19:17,120 --> 00:19:20,160
to no worries no worries

00:19:18,559 --> 00:19:21,840
okay just keep in mind that i would

00:19:20,160 --> 00:19:22,400
start inflammation this cardboard right

00:19:21,840 --> 00:19:24,960
now and

00:19:22,400 --> 00:19:25,440
you you probably want to not visit this

00:19:24,960 --> 00:19:26,720
but

00:19:25,440 --> 00:19:28,640
anyway if you want to play that no

00:19:26,720 --> 00:19:30,160
worries so

00:19:28,640 --> 00:19:32,080
i'm gonna actually uh decrease the

00:19:30,160 --> 00:19:34,000
screen a little bit

00:19:32,080 --> 00:19:35,440
let me know just give me the feedback

00:19:34,000 --> 00:19:37,039
right now about this

00:19:35,440 --> 00:19:38,480
the font size because we're gonna see

00:19:37,039 --> 00:19:40,720
some code right

00:19:38,480 --> 00:19:41,600
so it's the font size that i'm using

00:19:40,720 --> 00:19:44,960
here

00:19:41,600 --> 00:19:45,600
okay like uh just put in the chat good

00:19:44,960 --> 00:19:47,440
enough

00:19:45,600 --> 00:19:48,960
thank you for the feedback frontside's

00:19:47,440 --> 00:19:52,320
good robin thank you

00:19:48,960 --> 00:19:55,679
okay so i'm going to stop this

00:19:52,320 --> 00:19:57,520
all right so first things first okay

00:19:55,679 --> 00:19:58,720
remember when i told you that i'm going

00:19:57,520 --> 00:20:00,240
to use k sql db

00:19:58,720 --> 00:20:01,520
to actually implement this pipeline

00:20:00,240 --> 00:20:02,960
application because security visa is

00:20:01,520 --> 00:20:05,679
streaming database but

00:20:02,960 --> 00:20:06,000
curiously enough uh although the data is

00:20:05,679 --> 00:20:08,159
stored

00:20:06,000 --> 00:20:10,320
on kafka what do you actually build on

00:20:08,159 --> 00:20:12,480
streaming on k sequel to b is not

00:20:10,320 --> 00:20:13,360
a database you actually build a

00:20:12,480 --> 00:20:15,679
application

00:20:13,360 --> 00:20:16,720
or actually in a plural form you build

00:20:15,679 --> 00:20:18,480
applications

00:20:16,720 --> 00:20:20,720
right so what we're going to do here is

00:20:18,480 --> 00:20:23,280
actually build a set of applications

00:20:20,720 --> 00:20:24,799
that's going to take the raw data we're

00:20:23,280 --> 00:20:27,520
going to shape them out

00:20:24,799 --> 00:20:29,520
so we're going to produce uh output

00:20:27,520 --> 00:20:29,919
that's going to be used as a scoreboard

00:20:29,520 --> 00:20:32,480
right

00:20:29,919 --> 00:20:33,679
so i have a sql db cluster running on

00:20:32,480 --> 00:20:36,159
aws right now

00:20:33,679 --> 00:20:39,039
right so what i've done here before that

00:20:36,159 --> 00:20:41,760
i did it real quick but i didn't explain

00:20:39,039 --> 00:20:42,880
is i'm using this cli which is installed

00:20:41,760 --> 00:20:45,440
on my machine right

00:20:42,880 --> 00:20:46,400
locally that is pointing to this cluster

00:20:45,440 --> 00:20:48,960
on aws

00:20:46,400 --> 00:20:50,640
right so ultimately you can actually uh

00:20:48,960 --> 00:20:52,080
develop on your machine

00:20:50,640 --> 00:20:53,679
point into a cluster that's running

00:20:52,080 --> 00:20:54,320
somewhere else right or maybe a docker

00:20:53,679 --> 00:20:55,840
container

00:20:54,320 --> 00:20:57,760
maybe on kubernetes or something or

00:20:55,840 --> 00:21:01,200
something like this right

00:20:57,760 --> 00:21:02,400
so i'm gonna connect it uh and

00:21:01,200 --> 00:21:04,640
what i'm going to do right now is

00:21:02,400 --> 00:21:07,440
basically a a half check

00:21:04,640 --> 00:21:07,760
right so i'm going to list the streams

00:21:07,440 --> 00:21:10,559
and

00:21:07,760 --> 00:21:12,960
tables that i currently have ignore for

00:21:10,559 --> 00:21:15,039
a second this k sql processing log

00:21:12,960 --> 00:21:17,600
this is a stream but this is kind of a

00:21:15,039 --> 00:21:18,159
built-in strain that comes with kc go to

00:21:17,600 --> 00:21:20,320
be so

00:21:18,159 --> 00:21:22,720
you don't take this into consideration

00:21:20,320 --> 00:21:25,120
so technically we don't have any streams

00:21:22,720 --> 00:21:26,799
and we don't have any tables at this

00:21:25,120 --> 00:21:29,919
point what we do have

00:21:26,799 --> 00:21:31,919
is topics which is essentially the kafka

00:21:29,919 --> 00:21:33,600
topics that are available in the kafka

00:21:31,919 --> 00:21:36,480
cluster right

00:21:33,600 --> 00:21:38,400
the data that you were seeing before is

00:21:36,480 --> 00:21:42,159
stored on this topic here called

00:21:38,400 --> 00:21:45,919
user game so if we print the topic

00:21:42,159 --> 00:21:48,400
user game from

00:21:45,919 --> 00:21:48,400
beginning

00:21:49,440 --> 00:21:53,679
we should see all the data that has been

00:21:51,760 --> 00:21:54,480
stored there until the beginning of the

00:21:53,679 --> 00:21:56,799
day

00:21:54,480 --> 00:21:58,080
until now right so no worries is it

00:21:56,799 --> 00:22:01,120
still playing don't worry

00:21:58,080 --> 00:22:03,120
okay so i'm gonna stop it so this is

00:22:01,120 --> 00:22:05,679
what i call the source data right so

00:22:03,120 --> 00:22:07,679
before you actually start with kcodb you

00:22:05,679 --> 00:22:09,600
have to shape the data into a format

00:22:07,679 --> 00:22:11,440
that you can handle it right

00:22:09,600 --> 00:22:14,080
and one of one of the most amazing

00:22:11,440 --> 00:22:15,280
things that kcodb does is to bring you a

00:22:14,080 --> 00:22:17,280
notation

00:22:15,280 --> 00:22:19,039
that looks like a lock with this so

00:22:17,280 --> 00:22:22,159
famous language called

00:22:19,039 --> 00:22:23,840
sql or strict required language so

00:22:22,159 --> 00:22:26,559
what we're gonna do now is actually

00:22:23,840 --> 00:22:28,400
create our first stream

00:22:26,559 --> 00:22:30,400
and the notation is great stream you're

00:22:28,400 --> 00:22:31,280
gonna name it usually the name of the

00:22:30,400 --> 00:22:33,280
first stream

00:22:31,280 --> 00:22:35,840
is the same name of the input topic

00:22:33,280 --> 00:22:38,880
which also happens to be user game

00:22:35,840 --> 00:22:42,159
and then you can set a structure

00:22:38,880 --> 00:22:44,880
of or a schema if you will

00:22:42,159 --> 00:22:46,640
that's going to shape the format of that

00:22:44,880 --> 00:22:47,360
data which happens to be json in this

00:22:46,640 --> 00:22:49,600
case but

00:22:47,360 --> 00:22:51,679
uh it could be any other format because

00:22:49,600 --> 00:22:54,000
one of the cute things about uh

00:22:51,679 --> 00:22:56,240
kafka is that kafka is essentially

00:22:54,000 --> 00:22:57,039
schema-less right kafka stores ahead of

00:22:56,240 --> 00:23:00,000
bytes

00:22:57,039 --> 00:23:01,840
so uh you could deal with any format

00:23:00,000 --> 00:23:02,559
that can actually be supported here in

00:23:01,840 --> 00:23:05,840
case equal to b

00:23:02,559 --> 00:23:08,400
which can be csv json protobuf avro

00:23:05,840 --> 00:23:09,919
or you can plug your implementation if

00:23:08,400 --> 00:23:12,400
you are handling something that you are

00:23:09,919 --> 00:23:13,520
not so common right so now we have a

00:23:12,400 --> 00:23:15,840
stream

00:23:13,520 --> 00:23:17,200
okay called user game and then because

00:23:15,840 --> 00:23:20,159
we have a stream

00:23:17,200 --> 00:23:20,880
um actually i'm let me do this i'm going

00:23:20,159 --> 00:23:24,559
to drop this

00:23:20,880 --> 00:23:26,320
stream for a second because i forgot to

00:23:24,559 --> 00:23:28,159
do something really really important

00:23:26,320 --> 00:23:28,880
which is for those of you that know

00:23:28,159 --> 00:23:30,640
kafka

00:23:28,880 --> 00:23:33,360
you're gonna recognize this command over

00:23:30,640 --> 00:23:36,720
here i'm gonna move the offset

00:23:33,360 --> 00:23:38,960
of my kafka for the earliest which means

00:23:36,720 --> 00:23:42,080
that whatever i create over here

00:23:38,960 --> 00:23:44,240
is going to consider the existing data

00:23:42,080 --> 00:23:45,520
and the new data that's coming in right

00:23:44,240 --> 00:23:47,279
if you don't do this

00:23:45,520 --> 00:23:48,960
it's going to work obviously but it's

00:23:47,279 --> 00:23:49,600
only going to consider the data that's

00:23:48,960 --> 00:23:52,720
coming in

00:23:49,600 --> 00:23:54,960
right now at the moment okay so

00:23:52,720 --> 00:23:55,760
now that i have done this i can actually

00:23:54,960 --> 00:23:58,240
repeat

00:23:55,760 --> 00:23:59,120
the statement of creating the streams

00:23:58,240 --> 00:24:01,600
okay

00:23:59,120 --> 00:24:02,240
and now i can actually select that

00:24:01,600 --> 00:24:06,400
stream

00:24:02,240 --> 00:24:10,159
user game right user game

00:24:06,400 --> 00:24:12,400
and what you should see here is

00:24:10,159 --> 00:24:13,600
the same data the the data sets going to

00:24:12,400 --> 00:24:15,840
be the same right

00:24:13,600 --> 00:24:17,760
although now we are dealing with a

00:24:15,840 --> 00:24:19,200
format that we can handle using this

00:24:17,760 --> 00:24:21,919
notation called sql

00:24:19,200 --> 00:24:22,880
right so this is the data that has been

00:24:21,919 --> 00:24:24,799
stored before

00:24:22,880 --> 00:24:26,640
plus the data that's still coming in

00:24:24,799 --> 00:24:26,960
right probably is a lot of data so i'm

00:24:26,640 --> 00:24:32,159
just

00:24:26,960 --> 00:24:34,640
hit counter c right and then

00:24:32,159 --> 00:24:36,080
another topic that i've i haven't

00:24:34,640 --> 00:24:38,960
explained yet but it's called

00:24:36,080 --> 00:24:40,640
user losses right so in the game there

00:24:38,960 --> 00:24:43,120
is this concept of game over

00:24:40,640 --> 00:24:45,520
right so what is good game over you

00:24:43,120 --> 00:24:47,520
start the pac-man game with three lives

00:24:45,520 --> 00:24:49,760
if you lose all the three lives you're

00:24:47,520 --> 00:24:52,559
gonna game over the game right so

00:24:49,760 --> 00:24:53,279
every time you as a you as a player game

00:24:52,559 --> 00:24:55,840
over

00:24:53,279 --> 00:24:56,320
is going to emit an event to this topic

00:24:55,840 --> 00:24:59,039
called

00:24:56,320 --> 00:25:00,960
user losses right so now that i have a

00:24:59,039 --> 00:25:05,120
stream user losses as well

00:25:00,960 --> 00:25:08,480
let's query this user losses topic

00:25:05,120 --> 00:25:10,720
to see if someone had already

00:25:08,480 --> 00:25:11,840
came over in the game right so the name

00:25:10,720 --> 00:25:14,320
of the user should

00:25:11,840 --> 00:25:15,840
show up here i'm sorry too actually

00:25:14,320 --> 00:25:16,480
there's a lot of people acting the game

00:25:15,840 --> 00:25:18,559
over so

00:25:16,480 --> 00:25:21,039
there's no shame for everybody so that's

00:25:18,559 --> 00:25:23,600
good right so i'm going to pause

00:25:21,039 --> 00:25:24,480
it's working so far now that's the

00:25:23,600 --> 00:25:27,520
interesting part

00:25:24,480 --> 00:25:30,480
right or key sequel to be

00:25:27,520 --> 00:25:30,960
also supports the concept of tables

00:25:30,480 --> 00:25:32,640
right

00:25:30,960 --> 00:25:34,640
uh so far we have been dealing with

00:25:32,640 --> 00:25:36,400
streams right what what our streams are

00:25:34,640 --> 00:25:38,640
things are continuously happening over

00:25:36,400 --> 00:25:42,000
time right there's no end

00:25:38,640 --> 00:25:45,440
but if you want to create a point

00:25:42,000 --> 00:25:48,480
in time representation of a data set

00:25:45,440 --> 00:25:51,600
right that is if it is a fix it window

00:25:48,480 --> 00:25:53,679
right it is continuously updated right

00:25:51,600 --> 00:25:56,400
because the source is a stream

00:25:53,679 --> 00:25:57,360
but is a point in time representation of

00:25:56,400 --> 00:26:00,880
a data set

00:25:57,360 --> 00:26:02,880
you can create tables right so right now

00:26:00,880 --> 00:26:04,480
i'm going to create a table that i'm

00:26:02,880 --> 00:26:08,000
going to call stats for user

00:26:04,480 --> 00:26:10,400
and i'm basically going to select

00:26:08,000 --> 00:26:12,000
the previous stream that i've created

00:26:10,400 --> 00:26:12,559
right i'm going to come up with the

00:26:12,000 --> 00:26:15,919
column

00:26:12,559 --> 00:26:18,960
user and look at that i'm actually can

00:26:15,919 --> 00:26:21,200
uh navigate to a structured

00:26:18,960 --> 00:26:22,159
uh type that basically i have a field

00:26:21,200 --> 00:26:24,240
called game

00:26:22,159 --> 00:26:26,400
that has an inner field because it's a

00:26:24,240 --> 00:26:28,480
json inner json payload

00:26:26,400 --> 00:26:30,960
i can actually use that notation just

00:26:28,480 --> 00:26:32,880
using this arrow over here to navigate

00:26:30,960 --> 00:26:34,000
through that strictly right so i'm going

00:26:32,880 --> 00:26:35,679
to come up with

00:26:34,000 --> 00:26:37,120
this is an aggregation operation

00:26:35,679 --> 00:26:38,159
obviously right i'm going to come up

00:26:37,120 --> 00:26:39,840
with the highest score

00:26:38,159 --> 00:26:41,360
and the highest level and i'm going to

00:26:39,840 --> 00:26:45,039
group by user

00:26:41,360 --> 00:26:46,080
right so the table has been created

00:26:45,039 --> 00:26:49,039
let's check it out

00:26:46,080 --> 00:26:51,039
so we should have one table now let's

00:26:49,039 --> 00:26:54,400
square this table to see

00:26:51,039 --> 00:26:57,679
the contents of it so stats

00:26:54,400 --> 00:26:57,679
per user

00:26:59,360 --> 00:27:06,000
so you're going to see that now we're

00:27:02,640 --> 00:27:08,799
not going to have the uh the fuzzy

00:27:06,000 --> 00:27:10,159
the the noise representation of all

00:27:08,799 --> 00:27:13,760
those streams coming in

00:27:10,159 --> 00:27:16,480
but now we have something more uh like

00:27:13,760 --> 00:27:17,520
easy to use which is a table right that

00:27:16,480 --> 00:27:20,000
we can actually

00:27:17,520 --> 00:27:21,679
work with the columns and for forever

00:27:20,000 --> 00:27:24,399
user for example i'm gonna pick uh

00:27:21,679 --> 00:27:26,080
pick myself over here ricardo uh my

00:27:24,399 --> 00:27:28,559
highest score when i was testing this

00:27:26,080 --> 00:27:31,600
earlier was uh 1360

00:27:28,559 --> 00:27:33,919
and i wasn't level one right so

00:27:31,600 --> 00:27:35,440
uh now you can actually use that data

00:27:33,919 --> 00:27:36,399
that's going to be the scratch of the

00:27:35,440 --> 00:27:39,039
scoreboard

00:27:36,399 --> 00:27:39,919
right so that's what we're going to do

00:27:39,039 --> 00:27:41,840
now

00:27:39,919 --> 00:27:44,080
the scoreboard actually is going to be a

00:27:41,840 --> 00:27:45,360
mix of this information over here the

00:27:44,080 --> 00:27:48,240
stats per user

00:27:45,360 --> 00:27:49,440
with the information of how many game

00:27:48,240 --> 00:27:52,799
overs

00:27:49,440 --> 00:27:53,919
each user have done right so we have the

00:27:52,799 --> 00:27:56,720
stats per user

00:27:53,919 --> 00:27:57,840
good now we have to create the losses

00:27:56,720 --> 00:28:00,840
per user

00:27:57,840 --> 00:28:02,080
so i'm going to create another table

00:28:00,840 --> 00:28:05,200
right

00:28:02,080 --> 00:28:08,080
so now we have created and then

00:28:05,200 --> 00:28:12,240
i'm going to actually select the losses

00:28:08,080 --> 00:28:12,240
per user to see if the data is there

00:28:13,039 --> 00:28:18,720
okay so we should have user and the

00:28:15,600 --> 00:28:18,720
count of losses

00:28:23,200 --> 00:28:30,720
so good all right so we we already have

00:28:27,279 --> 00:28:33,279
the stats for user with represents 50

00:28:30,720 --> 00:28:33,840
of our scoreboard now we have to pick up

00:28:33,279 --> 00:28:36,880
this

00:28:33,840 --> 00:28:37,760
stats per user that we already have and

00:28:36,880 --> 00:28:39,679
this

00:28:37,760 --> 00:28:40,880
losses per users that obviously we

00:28:39,679 --> 00:28:44,799
already have as well

00:28:40,880 --> 00:28:48,159
and we have to join them to come up

00:28:44,799 --> 00:28:51,679
with a new data set that represents

00:28:48,159 --> 00:28:53,840
a single view of a scoreboard that has

00:28:51,679 --> 00:28:55,600
the the stats per user and the losses

00:28:53,840 --> 00:28:56,080
per user and how we're going to join

00:28:55,600 --> 00:28:57,679
them

00:28:56,080 --> 00:28:59,600
because there's a common information

00:28:57,679 --> 00:29:01,440
about in these two tables which is

00:28:59,600 --> 00:29:03,360
the name of the user we're going to use

00:29:01,440 --> 00:29:05,760
the name of the user as our

00:29:03,360 --> 00:29:07,440
let's it's not it's not applicable in

00:29:05,760 --> 00:29:10,159
this terms of a streaming word

00:29:07,440 --> 00:29:10,720
but we're going to use as a primary key

00:29:10,159 --> 00:29:13,760
and a

00:29:10,720 --> 00:29:15,200
foreign key right but i mean it's more

00:29:13,760 --> 00:29:17,200
like a metaphor than actually a

00:29:15,200 --> 00:29:20,159
technical term on the streaming word

00:29:17,200 --> 00:29:22,000
because this is not what actually uh

00:29:20,159 --> 00:29:24,640
happens behind the scenes

00:29:22,000 --> 00:29:25,440
uh this is not a relational database

00:29:24,640 --> 00:29:28,480
right

00:29:25,440 --> 00:29:32,399
so i'm going to create a

00:29:28,480 --> 00:29:35,360
new table that as you can see here

00:29:32,399 --> 00:29:37,600
we're actually selecting two tables

00:29:35,360 --> 00:29:40,080
we're selecting stats per user

00:29:37,600 --> 00:29:41,840
and we're performing here left join

00:29:40,080 --> 00:29:45,120
against the losses per user

00:29:41,840 --> 00:29:46,880
right and then we're basically selecting

00:29:45,120 --> 00:29:47,440
the user the highest score the highest

00:29:46,880 --> 00:29:50,000
level

00:29:47,440 --> 00:29:50,880
and the total losses but as you can see

00:29:50,000 --> 00:29:53,760
here i kind of

00:29:50,880 --> 00:29:54,960
created this case when statement just

00:29:53,760 --> 00:29:57,520
for the sake of

00:29:54,960 --> 00:29:58,640
coolness because we want to treat the

00:29:57,520 --> 00:30:01,760
the scenarios where

00:29:58,640 --> 00:30:04,080
if there are no uh game game overs

00:30:01,760 --> 00:30:04,960
there's going to be no and instead of

00:30:04,080 --> 00:30:07,520
showing no

00:30:04,960 --> 00:30:08,640
in the table i want to show simply zero

00:30:07,520 --> 00:30:10,640
right so you can actually

00:30:08,640 --> 00:30:12,399
handle this with with the case when

00:30:10,640 --> 00:30:15,840
statement so i'm gonna create it

00:30:12,399 --> 00:30:16,799
right now right and obviously like we've

00:30:15,840 --> 00:30:19,279
done before

00:30:16,799 --> 00:30:20,480
we should test it to see if the data is

00:30:19,279 --> 00:30:25,120
there so

00:30:20,480 --> 00:30:28,240
we're going to select everything from

00:30:25,120 --> 00:30:30,240
score board

00:30:28,240 --> 00:30:32,159
and you have been seeing that i'm using

00:30:30,240 --> 00:30:32,640
this clause here called emit changes

00:30:32,159 --> 00:30:34,799
right

00:30:32,640 --> 00:30:36,080
so what that does let me just explain

00:30:34,799 --> 00:30:38,399
because this is a k

00:30:36,080 --> 00:30:39,200
sql db thing right it's not a very

00:30:38,399 --> 00:30:42,880
common in

00:30:39,200 --> 00:30:44,799
uh nc92 sql any changes when

00:30:42,880 --> 00:30:46,960
you were dealing with something that

00:30:44,799 --> 00:30:49,919
because it's continuously happen

00:30:46,960 --> 00:30:50,799
happening and being updated right you

00:30:49,919 --> 00:30:54,399
want to

00:30:50,799 --> 00:30:55,679
show the output but you want to you want

00:30:54,399 --> 00:30:57,919
to show in a way that

00:30:55,679 --> 00:30:58,880
you keep emitting though all the changes

00:30:57,919 --> 00:31:01,360
that happen

00:30:58,880 --> 00:31:02,240
after you executed that query statement

00:31:01,360 --> 00:31:04,960
right

00:31:02,240 --> 00:31:06,640
so it's like we want to leverage the the

00:31:04,960 --> 00:31:08,559
best of both worlds right we are dealing

00:31:06,640 --> 00:31:10,640
with something that is a static

00:31:08,559 --> 00:31:12,399
but we wanted the continuous updates at

00:31:10,640 --> 00:31:13,039
the same time right so that's what the

00:31:12,399 --> 00:31:16,559
meat change

00:31:13,039 --> 00:31:19,760
uh has to do right so look at that

00:31:16,559 --> 00:31:23,440
now we have our actual scoreboard right

00:31:19,760 --> 00:31:24,240
and because we've created a scoreboard

00:31:23,440 --> 00:31:27,919
you can actually

00:31:24,240 --> 00:31:32,240
see this on on your game because

00:31:27,919 --> 00:31:35,360
let me pick up the url of the game again

00:31:32,240 --> 00:31:36,159
uh okay this is the url i'm gonna click

00:31:35,360 --> 00:31:38,240
it

00:31:36,159 --> 00:31:39,600
and it should pop up here in some

00:31:38,240 --> 00:31:42,480
browser here you go

00:31:39,600 --> 00:31:44,720
hopefully you can see my screen come on

00:31:42,480 --> 00:31:46,399
lastpass i've authenticated this morning

00:31:44,720 --> 00:31:47,200
i don't have to provide my credentials

00:31:46,399 --> 00:31:50,399
again

00:31:47,200 --> 00:31:53,440
right so ignore it so

00:31:50,399 --> 00:31:56,080
i'm going to actually come up with my

00:31:53,440 --> 00:31:56,559
username which is ricardo and look at

00:31:56,080 --> 00:31:58,159
this

00:31:56,559 --> 00:32:00,080
look at this i wanted you pay attention

00:31:58,159 --> 00:32:02,640
on this so as you can see here

00:32:00,080 --> 00:32:03,519
i'm gonna run the scoreboard again i

00:32:02,640 --> 00:32:07,279
want to retrieve

00:32:03,519 --> 00:32:11,039
my exactly last score

00:32:07,279 --> 00:32:15,519
which should be something like 1360

00:32:11,039 --> 00:32:18,240
is that correct yeah 1260 so

00:32:15,519 --> 00:32:19,360
this application actually uh sorry this

00:32:18,240 --> 00:32:22,480
game actually work

00:32:19,360 --> 00:32:22,880
as an application so your name is your

00:32:22,480 --> 00:32:25,440
key

00:32:22,880 --> 00:32:27,600
of your session right so that means that

00:32:25,440 --> 00:32:30,880
if i click play right now

00:32:27,600 --> 00:32:32,240
right the game will start right uh after

00:32:30,880 --> 00:32:35,360
this animation

00:32:32,240 --> 00:32:38,960
and in the bottom i'm sorry in the top

00:32:35,360 --> 00:32:42,000
of the game i should see my own score

00:32:38,960 --> 00:32:44,480
right which represent my last

00:32:42,000 --> 00:32:47,279
stored store right just like you would

00:32:44,480 --> 00:32:47,279
do in a database

00:32:49,039 --> 00:32:52,080
so you can see here i'm going to pause

00:32:51,039 --> 00:32:53,600
the game because

00:32:52,080 --> 00:32:55,600
now i want to play right now you see

00:32:53,600 --> 00:32:58,720
here that now i have a

00:32:55,600 --> 00:33:00,720
1 390 and it should should

00:32:58,720 --> 00:33:02,559
show up here because i used to call emit

00:33:00,720 --> 00:33:03,519
change so it's continuously being

00:33:02,559 --> 00:33:06,320
updated

00:33:03,519 --> 00:33:07,519
but what i was telling before is that

00:33:06,320 --> 00:33:09,600
from your game

00:33:07,519 --> 00:33:10,720
you can actually click here on the

00:33:09,600 --> 00:33:13,120
scoreboard

00:33:10,720 --> 00:33:14,480
if you click you're going to see all the

00:33:13,120 --> 00:33:17,200
players

00:33:14,480 --> 00:33:18,640
with the same data that is this

00:33:17,200 --> 00:33:21,919
scoreboard

00:33:18,640 --> 00:33:24,320
table is presenting but in a sorted

00:33:21,919 --> 00:33:27,519
fashion right because here uh

00:33:24,320 --> 00:33:28,720
no worries which is funny that no words

00:33:27,519 --> 00:33:31,360
is called no words because

00:33:28,720 --> 00:33:33,919
it's definitely the best player so far

00:33:31,360 --> 00:33:37,360
uh so congratulations to universe

00:33:33,919 --> 00:33:40,240
uh because as you can see here

00:33:37,360 --> 00:33:41,120
all the players are sorted against their

00:33:40,240 --> 00:33:44,080
score

00:33:41,120 --> 00:33:45,600
level and losses right so this is one of

00:33:44,080 --> 00:33:48,399
the cool things about

00:33:45,600 --> 00:33:50,080
uh i mean if you if you pay attention

00:33:48,399 --> 00:33:52,799
about what we have done in the last 10

00:33:50,080 --> 00:33:53,679
minutes right now we started from the

00:33:52,799 --> 00:33:56,159
raw data

00:33:53,679 --> 00:33:57,039
right which is basically the events come

00:33:56,159 --> 00:33:59,760
from the game

00:33:57,039 --> 00:34:00,559
that were being stored on a topic called

00:33:59,760 --> 00:34:03,679
user game

00:34:00,559 --> 00:34:06,799
right and then for that topic from that

00:34:03,679 --> 00:34:09,760
raw data we start actually creating

00:34:06,799 --> 00:34:11,679
something that can be easily recognized

00:34:09,760 --> 00:34:15,520
by any database developer

00:34:11,679 --> 00:34:18,399
called etl pipeline right etl stands for

00:34:15,520 --> 00:34:19,359
uh extract transform load right uh

00:34:18,399 --> 00:34:21,200
although

00:34:19,359 --> 00:34:22,960
we're we did not necessarily did an

00:34:21,200 --> 00:34:26,079
extract perform load per se

00:34:22,960 --> 00:34:29,119
right but in a sense of uh we had the

00:34:26,079 --> 00:34:30,079
input data coming in and input user game

00:34:29,119 --> 00:34:32,399
topic

00:34:30,079 --> 00:34:34,720
we were able to actually create new

00:34:32,399 --> 00:34:37,839
views of the same data mutate

00:34:34,720 --> 00:34:40,320
the data augment the data and reach

00:34:37,839 --> 00:34:41,119
the data aggregate the data filter the

00:34:40,320 --> 00:34:43,040
data

00:34:41,119 --> 00:34:45,119
and we were able to actually come up

00:34:43,040 --> 00:34:48,800
with a new data set

00:34:45,119 --> 00:34:51,119
that can be seen right is in a near real

00:34:48,800 --> 00:34:53,679
time and when i say new real time

00:34:51,119 --> 00:34:54,399
i'm not sure if someone actually uh

00:34:53,679 --> 00:34:57,200
could i ask

00:34:54,399 --> 00:34:57,200
everybody to

00:34:58,160 --> 00:35:01,520
play again like i'm gonna give you two

00:35:00,640 --> 00:35:04,320
minutes

00:35:01,520 --> 00:35:06,480
because i want to see here the data

00:35:04,320 --> 00:35:10,000
actually being shown alive

00:35:06,480 --> 00:35:12,320
all right so go ahead and play again

00:35:10,000 --> 00:35:17,839
so this should be like updated

00:35:12,320 --> 00:35:17,839
continuously all the time

00:35:36,160 --> 00:35:45,839
yep it's been updated

00:35:50,240 --> 00:35:54,240
ultimately one of the key one of the key

00:35:52,320 --> 00:35:57,040
characteristics of uh

00:35:54,240 --> 00:35:57,680
imagine that you were starting a project

00:35:57,040 --> 00:36:00,160
a data

00:35:57,680 --> 00:36:01,520
oriented product right now and you are

00:36:00,160 --> 00:36:04,000
in doubt if you are used

00:36:01,520 --> 00:36:05,200
you're going to use a standard

00:36:04,000 --> 00:36:07,920
relational

00:36:05,200 --> 00:36:08,880
no sql or standard database for your

00:36:07,920 --> 00:36:12,400
project

00:36:08,880 --> 00:36:14,160
or if you want to use this path of using

00:36:12,400 --> 00:36:16,560
a streaming database such as

00:36:14,160 --> 00:36:18,800
a sql right and you're writing down

00:36:16,560 --> 00:36:20,240
about which option to choose right to

00:36:18,800 --> 00:36:23,359
choose from

00:36:20,240 --> 00:36:26,880
i would say that if you are interested

00:36:23,359 --> 00:36:28,800
in seeing this which is what what is

00:36:26,880 --> 00:36:30,800
this what we are looking at here right

00:36:28,800 --> 00:36:34,800
now we're looking

00:36:30,800 --> 00:36:37,440
to a data set that is alive

00:36:34,800 --> 00:36:39,760
right that you don't need to keep

00:36:37,440 --> 00:36:40,000
calling the database to keep updating

00:36:39,760 --> 00:36:43,119
all

00:36:40,000 --> 00:36:47,359
the time you don't need to keep like a

00:36:43,119 --> 00:36:49,200
batch jobs that run every midnight

00:36:47,359 --> 00:36:51,680
to process the data from the the

00:36:49,200 --> 00:36:53,599
business hours and then you can uh plot

00:36:51,680 --> 00:36:55,599
and show that data in the next business

00:36:53,599 --> 00:36:55,839
day right you want to see something that

00:36:55,599 --> 00:36:57,599
i

00:36:55,839 --> 00:36:58,880
actually represent what's happening

00:36:57,599 --> 00:37:00,560
right now

00:36:58,880 --> 00:37:03,280
what's happening at these exactly

00:37:00,560 --> 00:37:04,720
moments so if this is your requirement

00:37:03,280 --> 00:37:06,560
this is going to be the motivator the

00:37:04,720 --> 00:37:06,960
architecture and motivation for picking

00:37:06,560 --> 00:37:10,240
up

00:37:06,960 --> 00:37:11,760
streaming databases so this is basically

00:37:10,240 --> 00:37:12,160
the recommendation that i would have for

00:37:11,760 --> 00:37:13,839
you

00:37:12,160 --> 00:37:15,760
uh regardless of the implementation

00:37:13,839 --> 00:37:18,240
technology there's a lot of them

00:37:15,760 --> 00:37:19,599
uh i'm um particularly like i like a lot

00:37:18,240 --> 00:37:21,760
kc db

00:37:19,599 --> 00:37:23,680
because not only it's a technology that

00:37:21,760 --> 00:37:25,520
is produced by the one of the companies

00:37:23,680 --> 00:37:28,160
that i used to work which is confluent

00:37:25,520 --> 00:37:30,240
right which is a great company but it is

00:37:28,160 --> 00:37:32,560
a very simple to use technology but

00:37:30,240 --> 00:37:34,079
it is there's no there's not necessarily

00:37:32,560 --> 00:37:35,839
only key sequel to be available there's

00:37:34,079 --> 00:37:37,040
a bunch of other stream processors

00:37:35,839 --> 00:37:40,400
frameworks available

00:37:37,040 --> 00:37:42,880
right so um i would say uh

00:37:40,400 --> 00:37:44,480
stick to the architecture principles of

00:37:42,880 --> 00:37:47,680
what you were trying to accomplish

00:37:44,480 --> 00:37:51,520
which is a new real-time data set that

00:37:47,680 --> 00:37:53,680
is live okay so

00:37:51,520 --> 00:37:55,040
uh before we actually wrap up we have

00:37:53,680 --> 00:37:58,160
two minutes and a half

00:37:55,040 --> 00:37:59,119
i would please just stop playing for a

00:37:58,160 --> 00:38:00,960
second

00:37:59,119 --> 00:38:02,320
just hear me out over here because i

00:38:00,960 --> 00:38:03,440
want to show something really really

00:38:02,320 --> 00:38:06,079
really cool

00:38:03,440 --> 00:38:06,640
because right now this application over

00:38:06,079 --> 00:38:09,839
here

00:38:06,640 --> 00:38:12,480
let me come back so

00:38:09,839 --> 00:38:13,520
as you can see here obviously the no

00:38:12,480 --> 00:38:16,320
worries which is

00:38:13,520 --> 00:38:18,720
currently the best player so far uh has

00:38:16,320 --> 00:38:20,000
the highest score but if i play again my

00:38:18,720 --> 00:38:23,200
game over here

00:38:20,000 --> 00:38:25,760
right can you see here that

00:38:23,200 --> 00:38:27,119
there are i'm gonna pause so you can see

00:38:25,760 --> 00:38:30,079
what i'm talking about

00:38:27,119 --> 00:38:30,880
uh there is the score which represents

00:38:30,079 --> 00:38:33,280
my score

00:38:30,880 --> 00:38:34,640
obviously right and there's this field

00:38:33,280 --> 00:38:37,680
here on the ui

00:38:34,640 --> 00:38:41,520
called highest score right that it

00:38:37,680 --> 00:38:43,200
should conceptually show the score of no

00:38:41,520 --> 00:38:46,000
worries which is the best player

00:38:43,200 --> 00:38:46,720
right but it's not working right now

00:38:46,000 --> 00:38:49,280
because

00:38:46,720 --> 00:38:50,320
the table that actually computes the

00:38:49,280 --> 00:38:53,119
highest score

00:38:50,320 --> 00:38:54,560
haven't been created so far so let's

00:38:53,119 --> 00:38:56,240
create this last table

00:38:54,560 --> 00:38:58,480
right so we can actually wrap up this

00:38:56,240 --> 00:39:01,680
presentation so

00:38:58,480 --> 00:39:02,240
in here we have this last table that

00:39:01,680 --> 00:39:05,599
basically

00:39:02,240 --> 00:39:06,640
performs a select calculating the max of

00:39:05,599 --> 00:39:09,200
the high score

00:39:06,640 --> 00:39:10,400
and grouping by i just come up with a

00:39:09,200 --> 00:39:13,520
key here that i could

00:39:10,400 --> 00:39:15,119
use it for searching purposes right i'm

00:39:13,520 --> 00:39:19,280
going to create

00:39:15,119 --> 00:39:21,839
this uh last table it has been created

00:39:19,280 --> 00:39:22,800
already so we should see a new table

00:39:21,839 --> 00:39:26,839
here

00:39:22,800 --> 00:39:30,640
so high score is here oops

00:39:26,839 --> 00:39:31,520
okay and then i'm going to actually come

00:39:30,640 --> 00:39:33,599
back

00:39:31,520 --> 00:39:35,680
to the main screen i'm going to just

00:39:33,599 --> 00:39:36,320
force a refresher just to be on a safe

00:39:35,680 --> 00:39:38,000
side

00:39:36,320 --> 00:39:39,760
but what should happen right now is that

00:39:38,000 --> 00:39:42,800
i should see my old score

00:39:39,760 --> 00:39:46,560
and the no is scoreboard so

00:39:42,800 --> 00:39:48,690
let's see if that works yay

00:39:46,560 --> 00:39:50,160
it works right so

00:39:48,690 --> 00:39:52,320
[Music]

00:39:50,160 --> 00:39:53,599
damn no worries you are ahead you

00:39:52,320 --> 00:39:56,160
actually have a

00:39:53,599 --> 00:39:56,640
very good high score so the high score

00:39:56,160 --> 00:40:01,359
here

00:39:56,640 --> 00:40:03,359
is 54 480 and

00:40:01,359 --> 00:40:04,560
probably still belongs to no words let's

00:40:03,359 --> 00:40:08,079
see here yep

00:40:04,560 --> 00:40:09,040
it belongs to i'm not sure if it's him

00:40:08,079 --> 00:40:11,520
or her

00:40:09,040 --> 00:40:12,640
apologies because i don't know i'm not

00:40:11,520 --> 00:40:15,680
looking at you

00:40:12,640 --> 00:40:17,760
uh but yeah so now we can actually

00:40:15,680 --> 00:40:20,240
can you see that actually the even the

00:40:17,760 --> 00:40:24,319
application becomes more responsive

00:40:20,240 --> 00:40:25,680
right so we're dealing with data that is

00:40:24,319 --> 00:40:28,240
actually right now

00:40:25,680 --> 00:40:29,119
and we're shaping new data sets as we as

00:40:28,240 --> 00:40:30,880
they come

00:40:29,119 --> 00:40:32,400
and then the applications simply

00:40:30,880 --> 00:40:33,520
translate what's happening right

00:40:32,400 --> 00:40:36,800
obviously right

00:40:33,520 --> 00:40:38,960
uh so yeah my time's over uh we're gonna

00:40:36,800 --> 00:40:42,079
open up for q a right now but

00:40:38,960 --> 00:40:44,880
uh just to wrap up what i was saying um

00:40:42,079 --> 00:40:46,079
you can actually build really responsive

00:40:44,880 --> 00:40:48,160
applications

00:40:46,079 --> 00:40:50,000
using the concept of streaming databases

00:40:48,160 --> 00:40:51,280
right so that's that's the final word i

00:40:50,000 --> 00:40:54,640
would like to share with you

00:40:51,280 --> 00:40:59,280
so without further ado i would like to

00:40:54,640 --> 00:40:59,280
open up for questions if you have any

00:41:01,359 --> 00:41:08,960
and you can unmute yourself

00:41:06,160 --> 00:41:09,920
you can i'm looking here to the q a tab

00:41:08,960 --> 00:41:12,160
as well

00:41:09,920 --> 00:41:12,160
so

00:41:13,680 --> 00:41:17,760
just let me know if there's something i

00:41:15,680 --> 00:41:20,079
could clarify about this presentation

00:41:17,760 --> 00:41:21,920
something that you have some technical

00:41:20,079 --> 00:41:23,200
questions about kafka or case equality

00:41:21,920 --> 00:41:26,000
so since we have one question now

00:41:23,200 --> 00:41:26,000
changes the topic

00:41:29,040 --> 00:41:35,680
okay so there's a question on the q a

00:41:32,480 --> 00:41:38,400
that is is a table and or a stream

00:41:35,680 --> 00:41:39,359
just a topic with more metadata for

00:41:38,400 --> 00:41:43,920
kafka

00:41:39,359 --> 00:41:47,200
uh yes ultimately a stream

00:41:43,920 --> 00:41:48,720
or a table ultimately is just another

00:41:47,200 --> 00:41:51,760
topic on kafka

00:41:48,720 --> 00:41:53,599
right so uh long story short

00:41:51,760 --> 00:41:54,880
k secretary b has been built on top of

00:41:53,599 --> 00:41:57,920
kafka streams

00:41:54,880 --> 00:42:01,599
which uses a transient layer uh

00:41:57,920 --> 00:42:03,760
basic on a nosql database um

00:42:01,599 --> 00:42:05,599
that basically kind of uh materialize

00:42:03,760 --> 00:42:06,720
all the temporary data right you is

00:42:05,599 --> 00:42:08,880
being processed

00:42:06,720 --> 00:42:10,000
but it's going to ultimately flush into

00:42:08,880 --> 00:42:13,040
a kafka topic

00:42:10,000 --> 00:42:14,880
right so yes a stream and a table

00:42:13,040 --> 00:42:17,359
ultimately is a kafka topic right with

00:42:14,880 --> 00:42:20,240
metadata right there's some metadata

00:42:17,359 --> 00:42:20,240
related as well

00:42:24,480 --> 00:42:31,839
any other questions

00:42:51,520 --> 00:42:54,560
it seems there's just one question that

00:42:53,200 --> 00:42:56,240
came in on the chat

00:42:54,560 --> 00:42:59,839
what are some of use cases you've

00:42:56,240 --> 00:42:59,839
encountered in the wow

00:43:00,640 --> 00:43:04,720
oh okay in the chat right okay what are

00:43:03,200 --> 00:43:05,040
some use cases you've encountered in the

00:43:04,720 --> 00:43:07,920
y

00:43:05,040 --> 00:43:09,040
right so yeah i think one of the most

00:43:07,920 --> 00:43:12,480
famous use cases

00:43:09,040 --> 00:43:13,760
is um ultimately you want to work with a

00:43:12,480 --> 00:43:16,880
data lake

00:43:13,760 --> 00:43:17,200
right or a data warehouse but you want

00:43:16,880 --> 00:43:18,880
to

00:43:17,200 --> 00:43:20,240
actually handle data that is

00:43:18,880 --> 00:43:22,079
continuously coming in

00:43:20,240 --> 00:43:23,280
right but the only thing that this data

00:43:22,079 --> 00:43:26,079
lake understands

00:43:23,280 --> 00:43:27,280
and the data warehouse understands are

00:43:26,079 --> 00:43:29,119
data that is a

00:43:27,280 --> 00:43:30,480
finite right it's a point in time

00:43:29,119 --> 00:43:32,640
queries so

00:43:30,480 --> 00:43:34,560
you usually come up with a streaming

00:43:32,640 --> 00:43:37,040
data architecture that sits

00:43:34,560 --> 00:43:38,880
in front of your data house or data lake

00:43:37,040 --> 00:43:40,160
that is going to actually come up with a

00:43:38,880 --> 00:43:42,160
new data set

00:43:40,160 --> 00:43:44,319
that's going to be stored on your let's

00:43:42,160 --> 00:43:46,800
call analytics layer right

00:43:44,319 --> 00:43:48,160
uh typical use case for this is having

00:43:46,800 --> 00:43:50,079
using like a kibana

00:43:48,160 --> 00:43:51,839
or elastic search for this analytics

00:43:50,079 --> 00:43:53,520
layer right or if you were an account

00:43:51,839 --> 00:43:54,240
provider maybe you were using like a

00:43:53,520 --> 00:43:57,440
bigquery

00:43:54,240 --> 00:43:59,359
on google or using um

00:43:57,440 --> 00:44:00,640
i forgot name of the data house solution

00:43:59,359 --> 00:44:03,680
for an aws

00:44:00,640 --> 00:44:05,359
redshift right so

00:44:03,680 --> 00:44:06,720
you use the streaming data architectures

00:44:05,359 --> 00:44:09,520
too like a let's call

00:44:06,720 --> 00:44:10,160
ease up right the job of the deal

00:44:09,520 --> 00:44:12,880
warehouse

00:44:10,160 --> 00:44:13,920
right so this is a very typical one case

00:44:12,880 --> 00:44:16,160
uh iot

00:44:13,920 --> 00:44:17,839
right in the iot world you usually

00:44:16,160 --> 00:44:19,680
actually has a lot of events that needs

00:44:17,839 --> 00:44:22,560
to be computed in real time

00:44:19,680 --> 00:44:23,200
to produce something that uh the users

00:44:22,560 --> 00:44:25,599
can handle

00:44:23,200 --> 00:44:27,280
right so in the iot world it's usually

00:44:25,599 --> 00:44:28,800
very common to apply extremely data

00:44:27,280 --> 00:44:32,240
architectures as well

00:44:28,800 --> 00:44:34,160
um and yeah i've used

00:44:32,240 --> 00:44:36,000
also some banks starting to use

00:44:34,160 --> 00:44:39,760
streaming databases to handle

00:44:36,000 --> 00:44:41,839
like fraud detection as well um

00:44:39,760 --> 00:44:43,200
it's very unorthodox because banks are

00:44:41,839 --> 00:44:45,359
very very conservative

00:44:43,200 --> 00:44:46,960
in terms of how they handle data but

00:44:45,359 --> 00:44:47,839
yeah there are some banks even in the

00:44:46,960 --> 00:44:50,160
u.s

00:44:47,839 --> 00:44:52,319
that are actually investing or streaming

00:44:50,160 --> 00:45:05,839
data architectures for it so

00:44:52,319 --> 00:45:05,839
it's growing a lot

00:45:11,520 --> 00:45:19,839
it seems that we don't have more

00:45:13,920 --> 00:45:19,839
questions right

00:45:29,599 --> 00:45:34,319
okay so with that said i would like to

00:45:32,960 --> 00:45:36,720
thank you everybody for

00:45:34,319 --> 00:45:37,839
uh participating on the session i look

00:45:36,720 --> 00:45:40,079
forward to see you

00:45:37,839 --> 00:45:40,960
when it's possible next year on the of

00:45:40,079 --> 00:45:44,319
all things

00:45:40,960 --> 00:45:47,839
open and stay safe

00:45:44,319 --> 00:45:47,839

YouTube URL: https://www.youtube.com/watch?v=bYn0VLWpWJM


