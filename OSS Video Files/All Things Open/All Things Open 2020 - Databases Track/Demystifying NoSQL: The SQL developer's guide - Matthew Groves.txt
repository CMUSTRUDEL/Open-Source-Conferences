Title: Demystifying NoSQL: The SQL developer's guide - Matthew Groves
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Databases Track
Description: 
	Presented by: Matthew Groves, Couchbase
Presented at All Things Open 2020 - Databases Track

Abstract: We’ve been using relational databases like SQL Server, Postgres, MySQL, and Oracle for a long time. Tables are practically ingrained into our thought processes. But many organizations and businesses are turning to NoSQL options to solve problems of scale, performance, and flexibility. What is a long-time relational database-using developer supposed to do? Do I just forget about all that SQL that I learned? (Spoiler alert: NO). Come to this session with all your burning questions about data modeling, transactions, schema, migration, how to get started, and more. Let’s find out if a NoSQL tool like Couchbase, CosmosDb, Mongo, etc, is the right fit for your next project.
Captions: 
	00:00:05,600 --> 00:00:08,080
thank you for all things open for having

00:00:06,879 --> 00:00:10,480
me as a speaker here

00:00:08,080 --> 00:00:12,000
it's been a great event so far and uh

00:00:10,480 --> 00:00:13,280
this is just to reiterate what i've been

00:00:12,000 --> 00:00:15,440
saying before the

00:00:13,280 --> 00:00:16,800
session started here this is a nice qr

00:00:15,440 --> 00:00:18,080
code if you want to scan

00:00:16,800 --> 00:00:20,080
scan that but it'll just go to

00:00:18,080 --> 00:00:22,720
pigeonhole dot atp slash

00:00:20,080 --> 00:00:24,240
ato 2020 and i know it may be weird to

00:00:22,720 --> 00:00:25,680
ask questions up front but i want to get

00:00:24,240 --> 00:00:28,160
the interactivity started i want to know

00:00:25,680 --> 00:00:30,000
your burning questions

00:00:28,160 --> 00:00:31,439
and so especially when i do this in

00:00:30,000 --> 00:00:32,640
person sometimes not everyone wants to

00:00:31,439 --> 00:00:34,800
raise their hands

00:00:32,640 --> 00:00:36,079
uh or uh if you think of something later

00:00:34,800 --> 00:00:38,399
i don't you know don't be on

00:00:36,079 --> 00:00:40,800
spot from the group so this is i think a

00:00:38,399 --> 00:00:44,399
helpful tool to kind of help

00:00:40,800 --> 00:00:46,239
help get the questions going and uh

00:00:44,399 --> 00:00:48,399
and so if you have uh if you can do this

00:00:46,239 --> 00:00:49,920
on your phone as well if you have uh

00:00:48,399 --> 00:00:51,680
uh just one screen or you can do a

00:00:49,920 --> 00:00:52,879
second monitor and the url is going to

00:00:51,680 --> 00:00:54,160
be on the bottom of all the slides so

00:00:52,879 --> 00:00:55,600
you don't have to memorize this link

00:00:54,160 --> 00:00:55,920
either if you think of something later

00:00:55,600 --> 00:00:58,320
on

00:00:55,920 --> 00:01:00,160
don't worry the link will be there so if

00:00:58,320 --> 00:01:01,920
you're like me

00:01:00,160 --> 00:01:03,199
when you're interacting with data for

00:01:01,920 --> 00:01:05,600
most of your career

00:01:03,199 --> 00:01:06,960
you've used a relational database so

00:01:05,600 --> 00:01:09,520
this is a question

00:01:06,960 --> 00:01:11,280
i often a question i get why would i

00:01:09,520 --> 00:01:13,040
ever use nosql

00:01:11,280 --> 00:01:15,840
but not only that that why would i use

00:01:13,040 --> 00:01:19,280
this or that nosql database

00:01:15,840 --> 00:01:21,759
uh and so to that question i kind of say

00:01:19,280 --> 00:01:22,880
uh well first of all i don't like the

00:01:21,759 --> 00:01:24,640
nosql

00:01:22,880 --> 00:01:26,320
term it's just it's just a buzzword it's

00:01:24,640 --> 00:01:29,759
not even terribly useful

00:01:26,320 --> 00:01:30,960
in a real discussion because it really

00:01:29,759 --> 00:01:32,159
only means that something

00:01:30,960 --> 00:01:34,240
something other than relational

00:01:32,159 --> 00:01:35,920
databases and when you define a term by

00:01:34,240 --> 00:01:36,880
what something isn't that's only going

00:01:35,920 --> 00:01:39,439
to be useful

00:01:36,880 --> 00:01:41,119
for a little while and honestly as we

00:01:39,439 --> 00:01:41,840
might see today it's not even accurate

00:01:41,119 --> 00:01:44,880
anymore

00:01:41,840 --> 00:01:46,240
to say uh to say no sql databases don't

00:01:44,880 --> 00:01:47,759
even have sql

00:01:46,240 --> 00:01:49,439
and the last point i want to make here

00:01:47,759 --> 00:01:52,479
before we get going is that

00:01:49,439 --> 00:01:54,240
it does not mean anti-sequel it just

00:01:52,479 --> 00:01:55,280
means that you recognize databases are

00:01:54,240 --> 00:01:58,159
not one size

00:01:55,280 --> 00:01:59,520
fits all for every use case so this is

00:01:58,159 --> 00:02:01,040
all the agenda i have for today we're

00:01:59,520 --> 00:02:01,840
going to have a few slides of nosql

00:02:01,040 --> 00:02:04,000
history

00:02:01,840 --> 00:02:05,920
maybe get the questions flowing a little

00:02:04,000 --> 00:02:07,680
more give you some ideas for questions

00:02:05,920 --> 00:02:09,599
and then it's going to be literally a

00:02:07,680 --> 00:02:10,720
slide full of links and we're going to

00:02:09,599 --> 00:02:12,480
click around and

00:02:10,720 --> 00:02:14,720
try to answer all the questions that you

00:02:12,480 --> 00:02:16,160
have and then i'll wrap up and give you

00:02:14,720 --> 00:02:18,640
some next steps and

00:02:16,160 --> 00:02:20,239
uh and that's it so let's talk about

00:02:18,640 --> 00:02:22,400
nosql history a little bit

00:02:20,239 --> 00:02:24,720
kind of the really big picture here uh

00:02:22,400 --> 00:02:26,560
before relational databases existed

00:02:24,720 --> 00:02:28,319
um there there was something before

00:02:26,560 --> 00:02:30,000
relational databases

00:02:28,319 --> 00:02:31,840
and we're talking computerized databases

00:02:30,000 --> 00:02:34,480
here but these databases

00:02:31,840 --> 00:02:35,360
all had kind of really poor ad hoc query

00:02:34,480 --> 00:02:37,200
capability

00:02:35,360 --> 00:02:38,800
um you had to use the low-level

00:02:37,200 --> 00:02:39,360
languages or tooling basically whatever

00:02:38,800 --> 00:02:40,720
the

00:02:39,360 --> 00:02:42,640
database was written in you had to use

00:02:40,720 --> 00:02:45,120
that language to query data

00:02:42,640 --> 00:02:45,760
and then a lack of interoperability so

00:02:45,120 --> 00:02:48,239
if you have

00:02:45,760 --> 00:02:49,519
a database from one company taking that

00:02:48,239 --> 00:02:50,000
knowledge to another company is not

00:02:49,519 --> 00:02:53,519
necessarily

00:02:50,000 --> 00:02:55,840
going to work very well and so

00:02:53,519 --> 00:02:57,680
because of these problems we had uh the

00:02:55,840 --> 00:02:58,480
idea of relational databases come along

00:02:57,680 --> 00:03:00,400
and this is

00:02:58,480 --> 00:03:01,920
this guy here ef cod you may have heard

00:03:00,400 --> 00:03:04,239
of him hopefully you've heard of them

00:03:01,920 --> 00:03:05,040
he invented or described the relational

00:03:04,239 --> 00:03:08,400
model

00:03:05,040 --> 00:03:10,239
of storing data and his constraint was

00:03:08,400 --> 00:03:11,200
at the time was to kind of optimize for

00:03:10,239 --> 00:03:13,280
limited disk space

00:03:11,200 --> 00:03:14,480
disks were very very expensive and very

00:03:13,280 --> 00:03:16,800
very large

00:03:14,480 --> 00:03:18,800
and so we want to store our data in a

00:03:16,800 --> 00:03:21,840
way that kind of

00:03:18,800 --> 00:03:23,760
addresses that constraint if you read

00:03:21,840 --> 00:03:26,560
his original paper though

00:03:23,760 --> 00:03:28,560
he's even making a prediction i'm just

00:03:26,560 --> 00:03:32,560
paraphrasing here but basically he said

00:03:28,560 --> 00:03:34,799
if disk space is cheaper than storing

00:03:32,560 --> 00:03:36,319
variations of the data outside of

00:03:34,799 --> 00:03:38,319
relational format

00:03:36,319 --> 00:03:40,239
might make sense and he predicted this

00:03:38,319 --> 00:03:42,080
way back in 1970 so

00:03:40,239 --> 00:03:43,440
very cool he kind of predicted the idea

00:03:42,080 --> 00:03:45,840
of of nosql

00:03:43,440 --> 00:03:46,879
and alternatives to relational data and

00:03:45,840 --> 00:03:49,920
he at the time

00:03:46,879 --> 00:03:53,040
created a language to query data

00:03:49,920 --> 00:03:54,720
called alpha and it was it kind of looks

00:03:53,040 --> 00:03:56,400
like sql a little bit but this is this

00:03:54,720 --> 00:03:59,040
is before sql was invented

00:03:56,400 --> 00:04:01,360
and it was never really implemented um

00:03:59,040 --> 00:04:01,760
uh in any sort of real piece of software

00:04:01,360 --> 00:04:04,640
but

00:04:01,760 --> 00:04:05,040
it kind of gave some ideas to uh this

00:04:04,640 --> 00:04:06,959
guy

00:04:05,040 --> 00:04:08,080
and uh his partner don chamberlain and

00:04:06,959 --> 00:04:09,920
raymond boyce this is

00:04:08,080 --> 00:04:11,280
don chamberlain here raymond boyce is no

00:04:09,920 --> 00:04:14,400
longer with us

00:04:11,280 --> 00:04:17,440
but uh he went along and created the sql

00:04:14,400 --> 00:04:19,600
language designed to be english friendly

00:04:17,440 --> 00:04:21,359
and if you've ever heard bcnf a voice

00:04:19,600 --> 00:04:23,120
cod normal form now you know where those

00:04:21,359 --> 00:04:24,960
two names come from

00:04:23,120 --> 00:04:27,440
and but these days of course even though

00:04:24,960 --> 00:04:29,280
sql was invented apart from relational

00:04:27,440 --> 00:04:30,560
it was invented for relational but as a

00:04:29,280 --> 00:04:32,560
separate effort

00:04:30,560 --> 00:04:34,160
these days we say sequel what we really

00:04:32,560 --> 00:04:36,880
mean is relational

00:04:34,160 --> 00:04:38,479
and it's maybe a fine point to make but

00:04:36,880 --> 00:04:40,880
i think it's an important one is that

00:04:38,479 --> 00:04:42,080
sql and relational are not exactly

00:04:40,880 --> 00:04:44,479
coupled there are two different

00:04:42,080 --> 00:04:45,919
terms that oftentimes we just sort of

00:04:44,479 --> 00:04:47,040
mix together as if they were the same

00:04:45,919 --> 00:04:49,600
thing

00:04:47,040 --> 00:04:50,880
and over those years since relational

00:04:49,600 --> 00:04:52,400
databases have you know

00:04:50,880 --> 00:04:54,639
really been dominating the database

00:04:52,400 --> 00:04:56,000
field there's course been criticisms

00:04:54,639 --> 00:04:57,680
and of course there's always trade-offs

00:04:56,000 --> 00:04:59,040
of any piece of software of the

00:04:57,680 --> 00:05:00,800
relational world

00:04:59,040 --> 00:05:02,479
and uh these are these are a few of them

00:05:00,800 --> 00:05:05,360
you may have seen or heard or maybe

00:05:02,479 --> 00:05:07,039
dealt with yourself before

00:05:05,360 --> 00:05:09,840
so i want to talk about scaling really

00:05:07,039 --> 00:05:12,479
quickly what does scaling actually mean

00:05:09,840 --> 00:05:13,360
there's two types of scaling and one of

00:05:12,479 --> 00:05:15,199
them is called vertical

00:05:13,360 --> 00:05:17,520
is where we have a database we have a

00:05:15,199 --> 00:05:19,600
machine and we want to scale it up to

00:05:17,520 --> 00:05:20,720
handle more traffic more i o more

00:05:19,600 --> 00:05:22,800
operations whatever

00:05:20,720 --> 00:05:24,000
so we put on the bigger machine and we

00:05:22,800 --> 00:05:26,400
keep doing that make it bigger

00:05:24,000 --> 00:05:27,840
and bigger and bigger um until it gets

00:05:26,400 --> 00:05:30,080
really really expensive

00:05:27,840 --> 00:05:32,639
or it's uh it's just it's not going to

00:05:30,080 --> 00:05:34,080
help to get on a bigger machine

00:05:32,639 --> 00:05:35,680
the other type of scaling is called

00:05:34,080 --> 00:05:36,479
horizontal scaling this is where instead

00:05:35,680 --> 00:05:38,320
of adding

00:05:36,479 --> 00:05:39,840
or instead of moving to a bigger machine

00:05:38,320 --> 00:05:42,400
we add additional machines

00:05:39,840 --> 00:05:42,960
and these machines all coordinate with

00:05:42,400 --> 00:05:44,320
each other

00:05:42,960 --> 00:05:45,840
and communicate with each other and

00:05:44,320 --> 00:05:47,280
they're all part of the same what's

00:05:45,840 --> 00:05:49,360
called a cluster

00:05:47,280 --> 00:05:53,039
and so we can keep adding machines as we

00:05:49,360 --> 00:05:55,520
need more capacity and more operations

00:05:53,039 --> 00:05:57,280
and the reason that vertical scaling

00:05:55,520 --> 00:05:59,680
doesn't always solve the problem anymore

00:05:57,280 --> 00:06:00,880
is kind of related to this paper here

00:05:59,680 --> 00:06:02,240
the free lunch is over

00:06:00,880 --> 00:06:04,240
you may have heard about this or at

00:06:02,240 --> 00:06:06,319
least seen this diagram before

00:06:04,240 --> 00:06:07,280
but it basically says that moore's law

00:06:06,319 --> 00:06:10,080
is starting to

00:06:07,280 --> 00:06:11,120
kind of uh plateau a little bit and

00:06:10,080 --> 00:06:14,479
therefore the

00:06:11,120 --> 00:06:17,039
solution is not more transistors but uh

00:06:14,479 --> 00:06:17,919
parallel computing or more more cores

00:06:17,039 --> 00:06:20,880
and

00:06:17,919 --> 00:06:22,319
multi-threading and multi-processor

00:06:20,880 --> 00:06:24,800
distributed computing basically or

00:06:22,319 --> 00:06:26,080
distributed databases as the case may be

00:06:24,800 --> 00:06:27,840
so that's a reason why horizontal

00:06:26,080 --> 00:06:30,000
scaling might help you

00:06:27,840 --> 00:06:31,600
solve your problem another criticism is

00:06:30,000 --> 00:06:33,440
impedance mismatch and this is

00:06:31,600 --> 00:06:35,039
one that's as developers you've probably

00:06:33,440 --> 00:06:35,759
dealt with before at least in some

00:06:35,039 --> 00:06:37,120
capacity

00:06:35,759 --> 00:06:39,120
you may not have heard the fancy term

00:06:37,120 --> 00:06:41,440
for it impedance mismatch but

00:06:39,120 --> 00:06:42,720
basically it's just that the way you

00:06:41,440 --> 00:06:44,400
store your data in relational is

00:06:42,720 --> 00:06:46,639
different than the way you access or use

00:06:44,400 --> 00:06:48,080
your data inside your program

00:06:46,639 --> 00:06:49,919
and so you have on the left there i've

00:06:48,080 --> 00:06:52,479
got two shopping carts

00:06:49,919 --> 00:06:54,160
uh in two different tables in five

00:06:52,479 --> 00:06:56,160
different pieces

00:06:54,160 --> 00:06:57,840
or more but in my application i have a

00:06:56,160 --> 00:06:59,520
shopping cart class

00:06:57,840 --> 00:07:01,919
and it contains a list of shopping cart

00:06:59,520 --> 00:07:03,120
items and so that little blue arrow in

00:07:01,919 --> 00:07:04,720
the middle that really

00:07:03,120 --> 00:07:06,160
simple looking arrow is actually the

00:07:04,720 --> 00:07:08,080
domain of uh

00:07:06,160 --> 00:07:09,280
some pieces of software called orms like

00:07:08,080 --> 00:07:11,840
entity framework or

00:07:09,280 --> 00:07:12,880
and hibernate or hibernate or other

00:07:11,840 --> 00:07:16,080
tools like that that

00:07:12,880 --> 00:07:17,680
attempt to address or solve the best

00:07:16,080 --> 00:07:19,120
they can that impedance mismatch and

00:07:17,680 --> 00:07:21,759
they do a pretty good job of this

00:07:19,120 --> 00:07:22,160
um most the time uh the rest of the time

00:07:21,759 --> 00:07:23,919
it's

00:07:22,160 --> 00:07:25,680
quite something you have to fight with

00:07:23,919 --> 00:07:27,840
quite a bit

00:07:25,680 --> 00:07:29,039
and then inflexibility is another

00:07:27,840 --> 00:07:31,759
criticism of

00:07:29,039 --> 00:07:33,840
relational databases is that yeah a

00:07:31,759 --> 00:07:34,720
question like laravel laravel has an orm

00:07:33,840 --> 00:07:36,240
built into it i

00:07:34,720 --> 00:07:38,400
forget what it's called off the top of

00:07:36,240 --> 00:07:41,120
my head but it has an orm yes

00:07:38,400 --> 00:07:42,560
absolutely inflexibility is where you

00:07:41,120 --> 00:07:43,039
know in relational databases we have

00:07:42,560 --> 00:07:45,280
this

00:07:43,039 --> 00:07:46,639
schema that we define up front and

00:07:45,280 --> 00:07:49,280
making changes to it

00:07:46,639 --> 00:07:50,639
sometimes it seems easy um but some you

00:07:49,280 --> 00:07:51,759
know maybe we just need to add a table

00:07:50,639 --> 00:07:54,400
with a foreign key

00:07:51,759 --> 00:07:55,520
move some data over and so on but i'm

00:07:54,400 --> 00:07:57,919
guessing most people

00:07:55,520 --> 00:07:59,120
deal with much larger schemas than you

00:07:57,919 --> 00:08:02,160
know five tables and

00:07:59,120 --> 00:08:04,240
and maybe a dozen or two columns here

00:08:02,160 --> 00:08:06,319
and that can be a real problem when it

00:08:04,240 --> 00:08:08,479
comes to upgrading uh

00:08:06,319 --> 00:08:10,400
leads to what i call the sunday morning

00:08:08,479 --> 00:08:12,560
2am problem where we're going to come in

00:08:10,400 --> 00:08:15,199
and well we used to have to come in but

00:08:12,560 --> 00:08:18,000
we gotta wake up 2 a.m on a sunday and

00:08:15,199 --> 00:08:19,120
do some sort of maintenance work or or

00:08:18,000 --> 00:08:20,319
deal with some

00:08:19,120 --> 00:08:22,400
maintenance work that's failed for

00:08:20,319 --> 00:08:23,919
instance or just babysit a process to

00:08:22,400 --> 00:08:26,800
make sure nothing goes down

00:08:23,919 --> 00:08:28,319
at 2am so um that can be a real problem

00:08:26,800 --> 00:08:30,479
and when it comes to schema as well

00:08:28,319 --> 00:08:31,919
now before i go any further here i don't

00:08:30,479 --> 00:08:33,519
want you to think that this is a

00:08:31,919 --> 00:08:35,680
session where i'm going to stand up here

00:08:33,519 --> 00:08:37,200
or well sit sit up here i guess

00:08:35,680 --> 00:08:38,159
and say that relational is terrible and

00:08:37,200 --> 00:08:38,800
you should never use it you should

00:08:38,159 --> 00:08:40,959
always use

00:08:38,800 --> 00:08:42,000
no sql database relational database may

00:08:40,959 --> 00:08:44,320
be perfectly fine

00:08:42,000 --> 00:08:45,519
for your use case if you're not having

00:08:44,320 --> 00:08:47,040
these problems you're not experiencing

00:08:45,519 --> 00:08:49,839
these problems

00:08:47,040 --> 00:08:50,560
then okay that's fine there's no reason

00:08:49,839 --> 00:08:53,040
to

00:08:50,560 --> 00:08:54,320
drop relational just because something

00:08:53,040 --> 00:08:56,399
else exists out there

00:08:54,320 --> 00:08:57,360
uh but as uh i think we're always seeing

00:08:56,399 --> 00:09:00,000
some questions

00:08:57,360 --> 00:09:01,200
in the uh in pigeonhole and the chat and

00:09:00,000 --> 00:09:03,200
stuff is

00:09:01,200 --> 00:09:04,800
well why would i want to uh what are

00:09:03,200 --> 00:09:07,120
some use cases where i'd want to

00:09:04,800 --> 00:09:08,560
use a nosql database and i've kind of

00:09:07,120 --> 00:09:09,680
addressed a few of those kind of high

00:09:08,560 --> 00:09:11,680
level

00:09:09,680 --> 00:09:12,880
when it comes to scaling and high

00:09:11,680 --> 00:09:15,440
availability

00:09:12,880 --> 00:09:17,440
and some cases performance or

00:09:15,440 --> 00:09:18,959
flexibility of data

00:09:17,440 --> 00:09:20,800
and those are kind of all the big

00:09:18,959 --> 00:09:23,519
reasons for it

00:09:20,800 --> 00:09:24,880
okay so that is that's my intro at this

00:09:23,519 --> 00:09:26,640
point it's literally choose your own

00:09:24,880 --> 00:09:28,800
adventure i promise this would be

00:09:26,640 --> 00:09:30,320
be here it's a bunch of links to other

00:09:28,800 --> 00:09:31,200
slides in my deck so we're not going to

00:09:30,320 --> 00:09:32,399
have time

00:09:31,200 --> 00:09:35,040
to get through all these today and i

00:09:32,399 --> 00:09:38,240
just want to make sure that i have until

00:09:35,040 --> 00:09:42,240
uh what is it uh 3 20 i believe

00:09:38,240 --> 00:09:44,800
uh is that correct uh or is it uh 3 30

00:09:42,240 --> 00:09:45,760
um kiana if you're still there i want to

00:09:44,800 --> 00:09:49,440
make sure i know what my

00:09:45,760 --> 00:09:51,680
my time limit is here uh 3 15.

00:09:49,440 --> 00:09:53,040
3 15. okay well even less time all right

00:09:51,680 --> 00:09:54,399
so i'm going to take a look here and

00:09:53,040 --> 00:09:55,600
and if you're at if you're at the pigeon

00:09:54,399 --> 00:09:57,360
hole site you can see questions i've

00:09:55,600 --> 00:09:58,959
already started to roll in here and

00:09:57,360 --> 00:10:01,200
uh the votes really help me because i

00:09:58,959 --> 00:10:01,920
can see which is the most popular

00:10:01,200 --> 00:10:04,480
question

00:10:01,920 --> 00:10:05,839
there's also a question that came in on

00:10:04,480 --> 00:10:10,240
zoom q a

00:10:05,839 --> 00:10:12,320
uh so i'm going to look at that as well

00:10:10,240 --> 00:10:13,680
and another question uh well most more

00:10:12,320 --> 00:10:15,279
of a comment just came in on the chat

00:10:13,680 --> 00:10:15,760
and uh that's very interesting so i'm

00:10:15,279 --> 00:10:17,200
going to

00:10:15,760 --> 00:10:19,360
start with this first one here on

00:10:17,200 --> 00:10:20,959
pigeonhole how do i determine

00:10:19,360 --> 00:10:22,880
that nosql is appropriate for the

00:10:20,959 --> 00:10:25,600
problem i'm trying to solve

00:10:22,880 --> 00:10:26,079
well so uh i mentioned those those four

00:10:25,600 --> 00:10:29,680
things

00:10:26,079 --> 00:10:30,240
so if the problem you have is going to

00:10:29,680 --> 00:10:33,200
require

00:10:30,240 --> 00:10:34,560
a large scale potentially large scale so

00:10:33,200 --> 00:10:35,920
lots and lots of users like a public

00:10:34,560 --> 00:10:40,240
website for instance

00:10:35,920 --> 00:10:41,839
or it's going to be a a case where

00:10:40,240 --> 00:10:43,360
data flexibility so let me go to the use

00:10:41,839 --> 00:10:45,440
cases link here

00:10:43,360 --> 00:10:48,880
where data flexibility is important and

00:10:45,440 --> 00:10:51,120
what i mean by data flexibility

00:10:48,880 --> 00:10:51,920
iot for instance where you're ingesting

00:10:51,120 --> 00:10:53,839
data from

00:10:51,920 --> 00:10:55,600
lots and lots of different devices and

00:10:53,839 --> 00:10:58,480
the data you're ingesting

00:10:55,600 --> 00:10:59,519
may differ may vary from device to

00:10:58,480 --> 00:11:01,600
device

00:10:59,519 --> 00:11:03,440
and so trying to address that with a

00:11:01,600 --> 00:11:05,839
schema a big upfront schema

00:11:03,440 --> 00:11:07,920
can be really problematic uh customer

00:11:05,839 --> 00:11:08,640
360 is a very similar use case to that

00:11:07,920 --> 00:11:10,399
where

00:11:08,640 --> 00:11:12,480
you're in a large enterprise and you're

00:11:10,399 --> 00:11:14,640
trying to put together a

00:11:12,480 --> 00:11:17,200
like a single pane of glass a single

00:11:14,640 --> 00:11:18,800
view of a given customer so if they call

00:11:17,200 --> 00:11:20,800
into customer support

00:11:18,800 --> 00:11:22,399
and they have an issue or a question you

00:11:20,800 --> 00:11:25,360
can see all their information

00:11:22,399 --> 00:11:27,360
sort of on one one single screen and

00:11:25,360 --> 00:11:27,680
that sounds really great except that in

00:11:27,360 --> 00:11:29,279
large

00:11:27,680 --> 00:11:31,279
enterprises you have customers

00:11:29,279 --> 00:11:34,160
information split out amongst

00:11:31,279 --> 00:11:34,880
you know 15 30 different systems and so

00:11:34,160 --> 00:11:36,480
ingesting

00:11:34,880 --> 00:11:38,720
data from those systems on a regular

00:11:36,480 --> 00:11:41,360
basis where the schema may change

00:11:38,720 --> 00:11:42,399
over and over it really is helpful to

00:11:41,360 --> 00:11:44,720
have a

00:11:42,399 --> 00:11:45,760
flexible uh ingest effects flexible way

00:11:44,720 --> 00:11:47,600
to ingest data

00:11:45,760 --> 00:11:50,000
that's not going to break when there's a

00:11:47,600 --> 00:11:51,519
you know even a minor schema change

00:11:50,000 --> 00:11:53,360
so that's the really flexibility there

00:11:51,519 --> 00:11:54,480
content management catalog very similar

00:11:53,360 --> 00:11:56,000
because content

00:11:54,480 --> 00:11:58,240
and catalog and you know items in a

00:11:56,000 --> 00:12:00,480
catalog can vary a lot

00:11:58,240 --> 00:12:01,519
you know a catalog at a clothing store

00:12:00,480 --> 00:12:04,639
for instance

00:12:01,519 --> 00:12:06,480
um it might have a i might have a size

00:12:04,639 --> 00:12:09,600
it might not have a size

00:12:06,480 --> 00:12:10,480
it might have you know a color or might

00:12:09,600 --> 00:12:11,839
not come in a color

00:12:10,480 --> 00:12:14,800
right so lots of different variations

00:12:11,839 --> 00:12:18,240
there where a flexible model can

00:12:14,800 --> 00:12:19,839
really be helpful um

00:12:18,240 --> 00:12:21,680
mainframe offloading so this is kind of

00:12:19,839 --> 00:12:23,600
the performance use case is where we

00:12:21,680 --> 00:12:24,160
have an expensive mainframe system or

00:12:23,600 --> 00:12:26,399
database

00:12:24,160 --> 00:12:27,600
and it's just doesn't make sense for us

00:12:26,399 --> 00:12:29,040
right now to

00:12:27,600 --> 00:12:31,279
try to migrate off of that and we've

00:12:29,040 --> 00:12:32,720
seen that recently this year with

00:12:31,279 --> 00:12:34,560
some increased demand for cobalt

00:12:32,720 --> 00:12:37,120
developers so

00:12:34,560 --> 00:12:39,120
but if we if we want to you know give

00:12:37,120 --> 00:12:40,800
that data

00:12:39,120 --> 00:12:42,399
to a public website for instance we

00:12:40,800 --> 00:12:44,000
don't want to give the website direct

00:12:42,399 --> 00:12:45,920
access to the mainframe so

00:12:44,000 --> 00:12:48,240
maybe just offloading it into a system

00:12:45,920 --> 00:12:50,560
that is again good at ingesting data

00:12:48,240 --> 00:12:51,680
in a flexible way would be a great use

00:12:50,560 --> 00:12:53,600
case for that

00:12:51,680 --> 00:12:55,279
and lots of other situations on here so

00:12:53,600 --> 00:12:58,160
gaming is one that has been

00:12:55,279 --> 00:12:59,839
nosql for a long time travel is one that

00:12:58,160 --> 00:13:00,560
i know specifically couchbase it deals

00:12:59,839 --> 00:13:04,000
with a lot of

00:13:00,560 --> 00:13:07,120
travel fraud monitoring is

00:13:04,000 --> 00:13:07,360
especially good for graph databases uh

00:13:07,120 --> 00:13:09,040
and

00:13:07,360 --> 00:13:10,880
and uh the the bottom three there

00:13:09,040 --> 00:13:12,720
finance e-commerce and inventory these

00:13:10,880 --> 00:13:13,760
are actually relatively new use cases to

00:13:12,720 --> 00:13:16,399
nosql but

00:13:13,760 --> 00:13:17,200
this is because nosql has been maturing

00:13:16,399 --> 00:13:20,560
a lot

00:13:17,200 --> 00:13:24,079
uh and adding things like um better

00:13:20,560 --> 00:13:25,760
uh better tracing and

00:13:24,079 --> 00:13:27,360
acid transactions things like that for

00:13:25,760 --> 00:13:30,320
instance so

00:13:27,360 --> 00:13:31,600
the comment here from jenna is that i

00:13:30,320 --> 00:13:33,279
was always told if you find yourself

00:13:31,600 --> 00:13:35,120
adding new columns to a table and most

00:13:33,279 --> 00:13:37,600
of the data in the columns are blank

00:13:35,120 --> 00:13:38,480
you might want to think mongodb might be

00:13:37,600 --> 00:13:41,440
a good choice

00:13:38,480 --> 00:13:43,440
mongodb is a document database so isn't

00:13:41,440 --> 00:13:46,399
always right there's other

00:13:43,440 --> 00:13:47,440
document databases out there but i mean

00:13:46,399 --> 00:13:49,600
that's not a bad

00:13:47,440 --> 00:13:51,279
rule of thumb you might also want to

00:13:49,600 --> 00:13:53,120
look at again depending on your use case

00:13:51,279 --> 00:13:55,440
i'll look at a wide column

00:13:53,120 --> 00:13:56,639
database as well if if you see a lot of

00:13:55,440 --> 00:13:58,160
nulls in your

00:13:56,639 --> 00:14:01,279
your tables a lot of sparse data for

00:13:58,160 --> 00:14:04,320
instance a document or a wide column

00:14:01,279 --> 00:14:04,800
might work again depends on your the way

00:14:04,320 --> 00:14:07,279
you

00:14:04,800 --> 00:14:07,920
the way you want to access your data so

00:14:07,279 --> 00:14:10,240
hopefully

00:14:07,920 --> 00:14:11,600
um you know like we could spend a lot of

00:14:10,240 --> 00:14:14,480
time talking about

00:14:11,600 --> 00:14:15,440
specific problems and uh is no sql good

00:14:14,480 --> 00:14:17,040
fit for those

00:14:15,440 --> 00:14:20,480
but i hopefully i've given that answer

00:14:17,040 --> 00:14:22,240
pretty good overview there

00:14:20,480 --> 00:14:24,399
so the next question i'm going to go to

00:14:22,240 --> 00:14:24,399
the

00:14:24,480 --> 00:14:28,880
to the question and answer window here

00:14:27,440 --> 00:14:31,040
from

00:14:28,880 --> 00:14:32,240
branch uh i'm i'm gonna butcher the

00:14:31,040 --> 00:14:34,240
first name michelle or

00:14:32,240 --> 00:14:36,240
mike michael branch how would you

00:14:34,240 --> 00:14:40,079
transition from a sql server shop

00:14:36,240 --> 00:14:44,720
to nosql well that is quite a question

00:14:40,079 --> 00:14:47,680
um i mean there's lots of issues there

00:14:44,720 --> 00:14:48,639
uh first of all is is though is let me

00:14:47,680 --> 00:14:50,240
see if i can find this

00:14:48,639 --> 00:14:51,839
data migration synchronization let's go

00:14:50,240 --> 00:14:53,680
to this slide here because

00:14:51,839 --> 00:14:57,440
my first question is why why do you want

00:14:53,680 --> 00:15:00,480
to go from a sql server to a nosql shop

00:14:57,440 --> 00:15:02,000
um so i i think about this and

00:15:00,480 --> 00:15:03,519
that's kind of goes back to the question

00:15:02,000 --> 00:15:05,279
about you know how do i

00:15:03,519 --> 00:15:07,040
figure out if this is the problem i want

00:15:05,279 --> 00:15:08,880
to address

00:15:07,040 --> 00:15:10,560
and uh it's pronounced michelle okay

00:15:08,880 --> 00:15:14,000
thank you michelle

00:15:10,560 --> 00:15:14,800
sorry about that and um but i think the

00:15:14,000 --> 00:15:16,880
question also

00:15:14,800 --> 00:15:18,079
is a little bit of a loaded question

00:15:16,880 --> 00:15:20,560
because

00:15:18,079 --> 00:15:21,839
you don't necessarily have to ditch sql

00:15:20,560 --> 00:15:24,399
server

00:15:21,839 --> 00:15:27,120
to get advan get some benefits from a

00:15:24,399 --> 00:15:29,519
nosql database

00:15:27,120 --> 00:15:31,920
you could use them both together in fact

00:15:29,519 --> 00:15:34,079
i just gave a presentation

00:15:31,920 --> 00:15:34,959
last week i believe a couple times last

00:15:34,079 --> 00:15:39,279
week

00:15:34,959 --> 00:15:42,320
about using using a nosql database

00:15:39,279 --> 00:15:43,839
with your.net application and a

00:15:42,320 --> 00:15:45,360
nosql database like couchbase for

00:15:43,839 --> 00:15:46,000
instance can be a really good utility

00:15:45,360 --> 00:15:49,250
player

00:15:46,000 --> 00:15:50,399
so it can handle things like caching and

00:15:49,250 --> 00:15:52,639
[Music]

00:15:50,399 --> 00:15:53,519
session store and maybe background

00:15:52,639 --> 00:15:55,680
processing

00:15:53,519 --> 00:15:56,560
user profile things like that where you

00:15:55,680 --> 00:15:58,320
can leave

00:15:56,560 --> 00:15:59,600
uh you know the rest of it to a sql

00:15:58,320 --> 00:16:01,279
server database and

00:15:59,600 --> 00:16:03,199
maybe you can split out a single part of

00:16:01,279 --> 00:16:04,560
your functionality you know if you're

00:16:03,199 --> 00:16:06,160
doing a microsource architecture for

00:16:04,560 --> 00:16:08,720
instance or an soa

00:16:06,160 --> 00:16:10,079
you can take a single slice where you

00:16:08,720 --> 00:16:11,519
know maybe not the whole system's having

00:16:10,079 --> 00:16:13,839
the scaling problem maybe it's just the

00:16:11,519 --> 00:16:15,600
user profile maybe it's just the catalog

00:16:13,839 --> 00:16:17,199
and take that little slice and put it

00:16:15,600 --> 00:16:19,279
into a no sql database and see if that

00:16:17,199 --> 00:16:20,880
helps things

00:16:19,279 --> 00:16:22,399
but there i mean so this is kind of what

00:16:20,880 --> 00:16:24,720
i was showing here i should have

00:16:22,399 --> 00:16:25,759
advanced the slide but you can try to

00:16:24,720 --> 00:16:28,480
migrate from

00:16:25,759 --> 00:16:29,040
everything using relational to you know

00:16:28,480 --> 00:16:31,120
just

00:16:29,040 --> 00:16:33,199
almost everything using relational for

00:16:31,120 --> 00:16:34,639
instance

00:16:33,199 --> 00:16:36,480
there are tools to help you actually do

00:16:34,639 --> 00:16:36,880
the data migration over although this is

00:16:36,480 --> 00:16:39,199
not

00:16:36,880 --> 00:16:42,000
exactly always going to be a

00:16:39,199 --> 00:16:43,120
straightforward copy and paste process

00:16:42,000 --> 00:16:44,399
but there are some tools that can help

00:16:43,120 --> 00:16:45,120
you so here's a few of them on the

00:16:44,399 --> 00:16:46,880
screen there

00:16:45,120 --> 00:16:48,240
i particularly like apache nifi it's a

00:16:46,880 --> 00:16:50,959
very cool

00:16:48,240 --> 00:16:51,759
ui data flow program um if you take

00:16:50,959 --> 00:16:53,360
nothing else away

00:16:51,759 --> 00:16:55,199
go and check out apache nifi it's very

00:16:53,360 --> 00:16:56,880
cool it's very fun actually

00:16:55,199 --> 00:16:59,519
to move data around actually see the

00:16:56,880 --> 00:17:01,040
flow chart of data it's very cool

00:16:59,519 --> 00:17:03,199
okay so i hope that answered that

00:17:01,040 --> 00:17:05,360
question okay let's go back

00:17:03,199 --> 00:17:07,199
over here to pigeonhole and look at the

00:17:05,360 --> 00:17:09,120
next question how can we

00:17:07,199 --> 00:17:12,640
achieve primary key foreign key

00:17:09,120 --> 00:17:15,280
relationships in a nosql database

00:17:12,640 --> 00:17:16,839
okay so for this one i'm going to focus

00:17:15,280 --> 00:17:20,400
on just

00:17:16,839 --> 00:17:21,120
documents and by the way if you have

00:17:20,400 --> 00:17:23,280
questions about

00:17:21,120 --> 00:17:24,799
wide table there's a session coming up

00:17:23,280 --> 00:17:26,400
after mine which is

00:17:24,799 --> 00:17:28,160
i think all about cassandra and white

00:17:26,400 --> 00:17:29,919
table and there was a session earlier

00:17:28,160 --> 00:17:30,799
today i think on graph so you might want

00:17:29,919 --> 00:17:33,360
to go and

00:17:30,799 --> 00:17:33,840
check out those but uh with a foreign

00:17:33,360 --> 00:17:35,360
key

00:17:33,840 --> 00:17:37,039
relationship you might think of data

00:17:35,360 --> 00:17:37,760
like this in a relational database and

00:17:37,039 --> 00:17:39,520
this is

00:17:37,760 --> 00:17:41,039
this is why i made this session you know

00:17:39,520 --> 00:17:43,679
for uh

00:17:41,039 --> 00:17:45,039
sql uh for you know for relational

00:17:43,679 --> 00:17:47,760
developers is because this is

00:17:45,039 --> 00:17:49,120
often the question uh that comes into

00:17:47,760 --> 00:17:50,640
play is

00:17:49,120 --> 00:17:51,679
how do i do this same sort of thing

00:17:50,640 --> 00:17:53,360
where i have a shopping cart that

00:17:51,679 --> 00:17:54,559
contains shopping cart items or i have a

00:17:53,360 --> 00:17:56,960
twitter user that has

00:17:54,559 --> 00:17:56,960
tweets

00:17:57,760 --> 00:18:01,039
and so i guess my first answer is do you

00:18:00,559 --> 00:18:03,280
need

00:18:01,039 --> 00:18:04,240
to have a foreign key primary key

00:18:03,280 --> 00:18:07,039
relationship

00:18:04,240 --> 00:18:07,919
can you just embed data into a single

00:18:07,039 --> 00:18:09,840
document

00:18:07,919 --> 00:18:11,280
so in this case in relation i'd

00:18:09,840 --> 00:18:12,240
represent this as two tables and they're

00:18:11,280 --> 00:18:14,400
foreign key

00:18:12,240 --> 00:18:16,080
in a document database my shopping cart

00:18:14,400 --> 00:18:17,600
i can just put it all in one document

00:18:16,080 --> 00:18:19,360
i don't need a foreign key because all

00:18:17,600 --> 00:18:21,840
the data is now domestic to the

00:18:19,360 --> 00:18:21,840
documents

00:18:22,799 --> 00:18:26,480
so oftentimes if you just consolidate

00:18:25,120 --> 00:18:29,520
and aggregate data down

00:18:26,480 --> 00:18:31,760
to documents you can reduce the need for

00:18:29,520 --> 00:18:34,400
those kinds of constraints

00:18:31,760 --> 00:18:35,200
uh you can still model your data in the

00:18:34,400 --> 00:18:36,799
same way

00:18:35,200 --> 00:18:38,400
though so for instance if we're talking

00:18:36,799 --> 00:18:40,000
a twitter account it doesn't make sense

00:18:38,400 --> 00:18:41,039
for me to aggregate all the tweets into

00:18:40,000 --> 00:18:44,080
one document because there's

00:18:41,039 --> 00:18:46,480
to be lots and lots of them

00:18:44,080 --> 00:18:47,120
so you can still kind of model it in the

00:18:46,480 --> 00:18:49,039
same way

00:18:47,120 --> 00:18:50,559
right so all these individual tweets

00:18:49,039 --> 00:18:51,840
point to

00:18:50,559 --> 00:18:54,240
the same user there they all have the

00:18:51,840 --> 00:18:55,039
same user id it's not a foreign key

00:18:54,240 --> 00:18:57,440
constraint

00:18:55,039 --> 00:19:00,799
but is still representing a relationship

00:18:57,440 --> 00:19:00,799
between the two pieces of data

00:19:01,440 --> 00:19:05,039
so i mean hopefully that helps answer

00:19:02,960 --> 00:19:07,280
the question but i mean literally i

00:19:05,039 --> 00:19:10,400
don't know of

00:19:07,280 --> 00:19:12,480
many distributed databases that

00:19:10,400 --> 00:19:14,240
actually have a foreign key constraint

00:19:12,480 --> 00:19:15,520
into them and that's just one of the

00:19:14,240 --> 00:19:17,280
one of the trade-offs of having a

00:19:15,520 --> 00:19:19,039
distributed nosql database

00:19:17,280 --> 00:19:21,280
now a graph database might give you

00:19:19,039 --> 00:19:23,280
something similar but again i don't know

00:19:21,280 --> 00:19:24,960
if i'd call it a constraint

00:19:23,280 --> 00:19:26,320
it's just more of a way to represent

00:19:24,960 --> 00:19:27,919
relationships

00:19:26,320 --> 00:19:29,840
your question was about constraints so

00:19:27,919 --> 00:19:31,440
hopefully uh

00:19:29,840 --> 00:19:33,919
that helps to answer at least at least

00:19:31,440 --> 00:19:36,320
partially

00:19:33,919 --> 00:19:38,000
okay advantages of nosql over something

00:19:36,320 --> 00:19:39,280
like sqlite

00:19:38,000 --> 00:19:41,280
well actually there's another question

00:19:39,280 --> 00:19:44,080
here in the chat let me see maybe this

00:19:41,280 --> 00:19:44,080
is just a comment

00:19:44,799 --> 00:19:48,480
uh okay yeah uh you couldn't get it to

00:19:47,520 --> 00:19:50,960
connect so you're doing

00:19:48,480 --> 00:19:52,160
a progress sequel i assume you mean

00:19:50,960 --> 00:19:55,360
postgres sql

00:19:52,160 --> 00:19:56,559
or postgresql yeah i have to happy to

00:19:55,360 --> 00:19:57,679
talk with you about that later again i'm

00:19:56,559 --> 00:19:59,679
not a

00:19:57,679 --> 00:20:01,200
guy i i'm i have a couch-based employee

00:19:59,679 --> 00:20:03,120
but i'm happy to talk about it

00:20:01,200 --> 00:20:04,480
with you at the booth if you want to

00:20:03,120 --> 00:20:06,000
stop by later

00:20:04,480 --> 00:20:07,679
advantages of nosql are something like

00:20:06,000 --> 00:20:10,480
sql lite so

00:20:07,679 --> 00:20:10,880
um again this depends on your use case

00:20:10,480 --> 00:20:12,559
so

00:20:10,880 --> 00:20:16,000
if we're talking sqlite maybe we're

00:20:12,559 --> 00:20:16,000
talking about mobile development

00:20:16,400 --> 00:20:18,880
because if we're not talking about

00:20:17,440 --> 00:20:20,720
mobile development then really it's the

00:20:18,880 --> 00:20:22,000
same sort of question is why would i use

00:20:20,720 --> 00:20:23,919
relational versus

00:20:22,000 --> 00:20:26,159
no sql so i'm going to assume you mean

00:20:23,919 --> 00:20:27,120
mobile and i think i have a slide here

00:20:26,159 --> 00:20:30,400
on mobile

00:20:27,120 --> 00:20:33,200
yet right here so uh

00:20:30,400 --> 00:20:34,320
one of the advantages i think of nosql

00:20:33,200 --> 00:20:36,480
is uh

00:20:34,320 --> 00:20:37,919
this is a use case here i'm going to

00:20:36,480 --> 00:20:40,240
describe now on on

00:20:37,919 --> 00:20:42,080
a device and we all have mobile devices

00:20:40,240 --> 00:20:44,640
just like this one i assume

00:20:42,080 --> 00:20:46,880
scale is not as a big a concern because

00:20:44,640 --> 00:20:48,559
it's just a single device right

00:20:46,880 --> 00:20:50,320
and high availability takes on a

00:20:48,559 --> 00:20:52,799
different meaning it basically means

00:20:50,320 --> 00:20:53,440
can i write to read and write for my

00:20:52,799 --> 00:20:55,600
data

00:20:53,440 --> 00:20:56,640
if i don't have signal or if i'm offline

00:20:55,600 --> 00:20:58,000
first and someone

00:20:56,640 --> 00:20:59,840
i talked to the booth that yesterday

00:20:58,000 --> 00:21:03,120
about a use case where

00:20:59,840 --> 00:21:03,840
it was agricultural use case and most of

00:21:03,120 --> 00:21:07,840
the users

00:21:03,840 --> 00:21:09,760
are in spotty or areas where there is no

00:21:07,840 --> 00:21:10,880
reception no internet access so they

00:21:09,760 --> 00:21:13,679
needed to have this

00:21:10,880 --> 00:21:15,360
sort of offline first high availability

00:21:13,679 --> 00:21:17,200
now performance is not as

00:21:15,360 --> 00:21:18,960
a big concern when it comes to

00:21:17,200 --> 00:21:20,799
concurrency because it's probably just

00:21:18,960 --> 00:21:24,159
going to be one user at a time

00:21:20,799 --> 00:21:27,440
on a single device right but flexibility

00:21:24,159 --> 00:21:30,080
can be a huge boon here when it comes to

00:21:27,440 --> 00:21:30,640
nosql compared to sql lights so think

00:21:30,080 --> 00:21:32,559
about

00:21:30,640 --> 00:21:33,760
uh if you're if you're you know if

00:21:32,559 --> 00:21:36,480
you're building mobile apps

00:21:33,760 --> 00:21:37,679
uh using sql lite you have to create

00:21:36,480 --> 00:21:40,080
schema migrations

00:21:37,679 --> 00:21:41,840
when you're deploying to an app store

00:21:40,080 --> 00:21:43,520
and so no sql database doesn't need

00:21:41,840 --> 00:21:45,440
those or doesn't need as many

00:21:43,520 --> 00:21:47,760
so this may save you some cycles waiting

00:21:45,440 --> 00:21:49,520
uh for approval in the app store

00:21:47,760 --> 00:21:51,280
and also we're back to that same

00:21:49,520 --> 00:21:53,200
impedance mismatch issue so we don't

00:21:51,280 --> 00:21:55,520
have that in nosql

00:21:53,200 --> 00:21:57,679
so we can always just write this

00:21:55,520 --> 00:22:00,320
document right to the phone

00:21:57,679 --> 00:22:00,960
and and read it right from the phone uh

00:22:00,320 --> 00:22:02,159
you know

00:22:00,960 --> 00:22:03,679
if it's available if it's highly

00:22:02,159 --> 00:22:04,640
available then it's even if there's no

00:22:03,679 --> 00:22:06,480
service

00:22:04,640 --> 00:22:08,080
even if there's no bars we can still

00:22:06,480 --> 00:22:10,400
read and write the data

00:22:08,080 --> 00:22:12,159
and so the other part of this is kind of

00:22:10,400 --> 00:22:15,840
cool actually is synchronization

00:22:12,159 --> 00:22:17,200
so if we have a uh the cloud or the edge

00:22:15,840 --> 00:22:20,240
or whatever you want to call it

00:22:17,200 --> 00:22:22,880
um we want to get our data

00:22:20,240 --> 00:22:24,000
replicated or synced to a data center

00:22:22,880 --> 00:22:25,280
from our phone we want to

00:22:24,000 --> 00:22:28,320
copy it back and forth and get the

00:22:25,280 --> 00:22:29,919
latest data and and save the latest data

00:22:28,320 --> 00:22:31,360
i'm going to ask you a question and this

00:22:29,919 --> 00:22:32,320
is kind of rhetorical is have you ever

00:22:31,360 --> 00:22:34,320
tried doing this

00:22:32,320 --> 00:22:35,919
yourself and doing the building the

00:22:34,320 --> 00:22:39,039
synchronization yourself because i

00:22:35,919 --> 00:22:40,640
i have tried this i did this when i

00:22:39,039 --> 00:22:42,880
worked as a consultant

00:22:40,640 --> 00:22:44,240
previously and it was a very very simple

00:22:42,880 --> 00:22:45,520
website honestly it wasn't that

00:22:44,240 --> 00:22:47,200
complicated it was it was

00:22:45,520 --> 00:22:49,039
mainly this content and this was a

00:22:47,200 --> 00:22:50,799
nightmare for us to do this we spent

00:22:49,039 --> 00:22:54,000
probably eight nine months

00:22:50,799 --> 00:22:55,440
trying to get this to work um

00:22:54,000 --> 00:22:56,880
because of all the edge cases i mean it

00:22:55,440 --> 00:22:58,640
seems simple at first we'll just oh

00:22:56,880 --> 00:23:01,520
we'll just if it's if it's old we'll

00:22:58,640 --> 00:23:02,880
we'll post it to an api and if it's not

00:23:01,520 --> 00:23:03,760
then we'll just pull the latest or

00:23:02,880 --> 00:23:05,200
whatever

00:23:03,760 --> 00:23:06,960
there's a lot more to it than that that

00:23:05,200 --> 00:23:08,080
is there's conflict resolution all those

00:23:06,960 --> 00:23:09,280
sorts of things

00:23:08,080 --> 00:23:11,760
and those edge cases really start to

00:23:09,280 --> 00:23:13,679
pile up now a nosql database really

00:23:11,760 --> 00:23:15,600
lends itself to efficient replication

00:23:13,679 --> 00:23:17,039
because of the isolated nature

00:23:15,600 --> 00:23:19,440
of the data the same reason that it

00:23:17,039 --> 00:23:22,799
scales really well so we can

00:23:19,440 --> 00:23:23,760
scale this individual piece of data and

00:23:22,799 --> 00:23:25,200
you know there still might be some

00:23:23,760 --> 00:23:27,039
conflicts but we can resolve those

00:23:25,200 --> 00:23:29,600
automatically or we can put in some

00:23:27,039 --> 00:23:31,200
some logic to deal with this and i know

00:23:29,600 --> 00:23:33,440
sql database i think is a good fit for

00:23:31,200 --> 00:23:33,440
this

00:23:33,679 --> 00:23:36,880
and i will say couchbase specifically it

00:23:35,760 --> 00:23:38,640
has this

00:23:36,880 --> 00:23:40,640
already built so called couchbase sync

00:23:38,640 --> 00:23:43,760
gateway so all that work is done

00:23:40,640 --> 00:23:44,960
for you already folks

00:23:43,760 --> 00:23:47,360
okay so hopefully that helped with the

00:23:44,960 --> 00:23:50,480
sql lights uh why is

00:23:47,360 --> 00:23:51,279
let's see why is node-red syntax for

00:23:50,480 --> 00:23:53,039
nosql

00:23:51,279 --> 00:23:54,400
different than mongodb syntax when

00:23:53,039 --> 00:23:56,880
they're both nosql

00:23:54,400 --> 00:23:57,760
i don't know what node red is uh that's

00:23:56,880 --> 00:24:00,240
a new one on me

00:23:57,760 --> 00:24:01,279
so if you could uh maybe provide some

00:24:00,240 --> 00:24:04,000
more information

00:24:01,279 --> 00:24:05,200
on that on what what do you mean by the

00:24:04,000 --> 00:24:06,559
syntax

00:24:05,200 --> 00:24:09,360
because i don't know what node red is

00:24:06,559 --> 00:24:09,360
that's something new to me

00:24:09,840 --> 00:24:12,880
um so i'm seeing a lot of questions

00:24:11,840 --> 00:24:15,279
about mongodb

00:24:12,880 --> 00:24:16,720
um very specific mongodb questions i'm

00:24:15,279 --> 00:24:18,559
not a mongodb

00:24:16,720 --> 00:24:19,840
rep so if it's really specific

00:24:18,559 --> 00:24:20,799
stuff i don't know if i can help you too

00:24:19,840 --> 00:24:22,559
much but i can

00:24:20,799 --> 00:24:24,240
i can kind of give you some more general

00:24:22,559 --> 00:24:27,120
answers about no sequel

00:24:24,240 --> 00:24:28,320
could you talk about tv mongodb

00:24:27,120 --> 00:24:30,400
table join

00:24:28,320 --> 00:24:32,480
so just like couch base there's no

00:24:30,400 --> 00:24:34,640
tables in there um

00:24:32,480 --> 00:24:36,880
it's it's a collections collections and

00:24:34,640 --> 00:24:38,720
documents

00:24:36,880 --> 00:24:40,960
um so let's see if i have anything about

00:24:38,720 --> 00:24:45,279
joins

00:24:40,960 --> 00:24:45,279
um i don't know i'll see uh

00:24:45,360 --> 00:24:48,640
key value data let's see access patterns

00:24:47,279 --> 00:24:50,240
i think let's look at access patterns i

00:24:48,640 --> 00:24:52,400
think this is where we're going to

00:24:50,240 --> 00:24:53,279
find the most helpful slides so we're

00:24:52,400 --> 00:24:56,480
going to skip the

00:24:53,279 --> 00:24:59,520
mapreduce one um so

00:24:56,480 --> 00:25:00,880
if you're talking about accessing nosql

00:24:59,520 --> 00:25:03,039
data document

00:25:00,880 --> 00:25:04,960
data then there's lots of different

00:25:03,039 --> 00:25:06,960
choices out there

00:25:04,960 --> 00:25:07,919
so mongodb has their own query language

00:25:06,960 --> 00:25:08,640
i'm not sure what it's called it's

00:25:07,919 --> 00:25:10,559
called

00:25:08,640 --> 00:25:11,679
mql or something but it kind of looks

00:25:10,559 --> 00:25:12,960
like this it's a little bit like

00:25:11,679 --> 00:25:16,159
javascript

00:25:12,960 --> 00:25:18,000
json kind of looking thing and uh you

00:25:16,159 --> 00:25:19,520
can you can't really do what are

00:25:18,000 --> 00:25:21,200
they don't call them joins they're like

00:25:19,520 --> 00:25:24,799
lookups or something it's kind of the

00:25:21,200 --> 00:25:26,080
the same idea there to join documents to

00:25:24,799 --> 00:25:28,320
each other

00:25:26,080 --> 00:25:29,440
dynamodb has their own query language as

00:25:28,320 --> 00:25:32,480
well and

00:25:29,440 --> 00:25:34,880
couchdb has one called mango by the way

00:25:32,480 --> 00:25:37,600
couchdb is not same as couchbase

00:25:34,880 --> 00:25:39,679
um but it's inspired by obviously

00:25:37,600 --> 00:25:42,080
because they call it mango

00:25:39,679 --> 00:25:43,039
what i prefer as an access pattern for

00:25:42,080 --> 00:25:45,120
querying is

00:25:43,039 --> 00:25:46,240
what i call sql plus plus or sql for

00:25:45,120 --> 00:25:47,679
json

00:25:46,240 --> 00:25:48,880
and so if you're using couchbase for

00:25:47,679 --> 00:25:50,080
instance you can just write a select

00:25:48,880 --> 00:25:51,919
query

00:25:50,080 --> 00:25:54,320
and that includes joins that includes

00:25:51,919 --> 00:25:57,520
unions includes common table expressions

00:25:54,320 --> 00:25:58,320
and all the kind of good stuff you you'd

00:25:57,520 --> 00:26:02,000
expect from

00:25:58,320 --> 00:26:04,159
from sql cosmos db from microsoft azure

00:26:02,000 --> 00:26:05,440
has a sql language as well it's a very

00:26:04,159 --> 00:26:07,760
small subset of it

00:26:05,440 --> 00:26:09,760
no joins for instance but similar

00:26:07,760 --> 00:26:12,960
looking

00:26:09,760 --> 00:26:16,080
relatively new solution from amazon

00:26:12,960 --> 00:26:16,320
is called uh particle and they also have

00:26:16,080 --> 00:26:19,919
a

00:26:16,320 --> 00:26:23,200
sql implementation there as well so

00:26:19,919 --> 00:26:25,120
um that's i mean to me that's

00:26:23,200 --> 00:26:27,039
i think what i like most about something

00:26:25,120 --> 00:26:28,080
like couchbase or or cosmos is that i

00:26:27,039 --> 00:26:29,919
can actually write

00:26:28,080 --> 00:26:31,919
the language that i've spent most of my

00:26:29,919 --> 00:26:34,720
career working in

00:26:31,919 --> 00:26:36,000
uh so i'm going to skip ahead back to

00:26:34,720 --> 00:26:39,120
skipping the graph and

00:26:36,000 --> 00:26:41,360
wide table stuff okay

00:26:39,120 --> 00:26:43,600
uh so i still know about the node-red

00:26:41,360 --> 00:26:45,840
thing um

00:26:43,600 --> 00:26:47,200
node-red has a mongodb plug-in okay i

00:26:45,840 --> 00:26:50,240
don't know what that means

00:26:47,200 --> 00:26:51,279
but there you go like ands and lookups

00:26:50,240 --> 00:26:53,200
our arrays

00:26:51,279 --> 00:26:55,120
of true is sort of a way to do table

00:26:53,200 --> 00:26:58,000
joins in yeah

00:26:55,120 --> 00:26:58,799
and again there's no tables uh in no sql

00:26:58,000 --> 00:27:00,640
databases

00:26:58,799 --> 00:27:03,760
it's not there's no defined schema no

00:27:00,640 --> 00:27:06,640
relation no relational there

00:27:03,760 --> 00:27:07,840
okay uh mongodb mongodb's bad rep seems

00:27:06,640 --> 00:27:09,279
to have been repaired somewhat these

00:27:07,840 --> 00:27:11,120
days however is there a compelling use

00:27:09,279 --> 00:27:12,320
case to use as opposed to other

00:27:11,120 --> 00:27:13,520
no-sql solutions

00:27:12,320 --> 00:27:14,720
if there was i'm not going to give one

00:27:13,520 --> 00:27:16,400
to you because i'm a couch-based

00:27:14,720 --> 00:27:18,480
employee we're a competitor

00:27:16,400 --> 00:27:19,600
but i will say one of the things with

00:27:18,480 --> 00:27:21,520
the manga's bad

00:27:19,600 --> 00:27:23,120
rep has probably been security so i do

00:27:21,520 --> 00:27:25,760
want to talk about security

00:27:23,120 --> 00:27:26,320
uh briefly uh first of all if you're

00:27:25,760 --> 00:27:29,039
using

00:27:26,320 --> 00:27:30,480
nosql don't panic uh if you think about

00:27:29,039 --> 00:27:31,600
no signal don't panic but

00:27:30,480 --> 00:27:33,520
you've probably seen a lot of these

00:27:31,600 --> 00:27:36,399
types of stories out there where

00:27:33,520 --> 00:27:38,880
there's security issues uh this is a

00:27:36,399 --> 00:27:42,080
 article this is one about redis

00:27:38,880 --> 00:27:44,320
had some security issues there um

00:27:42,080 --> 00:27:46,320
let's see i've got uh this is one about

00:27:44,320 --> 00:27:48,320
aws elasticsearch

00:27:46,320 --> 00:27:49,440
and another one this is more recent

00:27:48,320 --> 00:27:53,279
about

00:27:49,440 --> 00:27:56,159
and has to do with the russian stuff

00:27:53,279 --> 00:27:57,520
um so the the problem is that

00:27:56,159 --> 00:27:58,240
historically speaking i think you're

00:27:57,520 --> 00:28:00,559
right to say

00:27:58,240 --> 00:28:02,480
uh they're bad rep i don't know if it's

00:28:00,559 --> 00:28:04,640
repaired but uh

00:28:02,480 --> 00:28:06,559
may not be as deserved as it used to be

00:28:04,640 --> 00:28:08,720
because these databases

00:28:06,559 --> 00:28:09,679
initially traded off ease of use for

00:28:08,720 --> 00:28:12,240
security

00:28:09,679 --> 00:28:13,440
and so they were kind of insecure by

00:28:12,240 --> 00:28:16,480
default

00:28:13,440 --> 00:28:17,600
um redis and others right but

00:28:16,480 --> 00:28:19,360
unfortunately the

00:28:17,600 --> 00:28:20,799
the newer versions they're not as bad

00:28:19,360 --> 00:28:22,640
but there's still older versions

00:28:20,799 --> 00:28:24,880
floating around out there

00:28:22,640 --> 00:28:26,480
so don't make these some assumption that

00:28:24,880 --> 00:28:30,240
your version is safe and secure

00:28:26,480 --> 00:28:32,399
just check um and assume that it's

00:28:30,240 --> 00:28:33,520
it's uh not secure until you verify

00:28:32,399 --> 00:28:34,960
otherwise

00:28:33,520 --> 00:28:36,799
i'm not even talking about zero day

00:28:34,960 --> 00:28:38,640
exploits here that's the thing this is

00:28:36,799 --> 00:28:40,559
this is more like basic stuff of

00:28:38,640 --> 00:28:42,640
oh we've got to put a password on it for

00:28:40,559 --> 00:28:45,520
instance so it's just completely open

00:28:42,640 --> 00:28:46,480
to administrator access anonymously out

00:28:45,520 --> 00:28:48,159
there on the internet

00:28:46,480 --> 00:28:49,760
and you can still find a lot of these if

00:28:48,159 --> 00:28:50,720
you if you know the right websites to go

00:28:49,760 --> 00:28:52,159
to

00:28:50,720 --> 00:28:53,840
and just putting it behind a firewall

00:28:52,159 --> 00:28:55,440
isn't necessarily enough either because

00:28:53,840 --> 00:28:58,720
if someone gets access

00:28:55,440 --> 00:28:59,600
from some other compromised piece of

00:28:58,720 --> 00:29:01,120
software

00:28:59,600 --> 00:29:03,520
behind your firewall well now you're in

00:29:01,120 --> 00:29:05,440
the same exact situation so

00:29:03,520 --> 00:29:07,440
when it comes to security it's just the

00:29:05,440 --> 00:29:09,360
new stories you you see are all about

00:29:07,440 --> 00:29:11,520
really basic stuff of forgetting to put

00:29:09,360 --> 00:29:14,320
a password on there or just using

00:29:11,520 --> 00:29:17,120
you know old versions or and or default

00:29:14,320 --> 00:29:17,120
security settings

00:29:17,200 --> 00:29:21,039
okay uh some questions here can you

00:29:19,520 --> 00:29:22,080
describe basic working structure of

00:29:21,039 --> 00:29:25,360
nosql

00:29:22,080 --> 00:29:27,520
um that's from josh

00:29:25,360 --> 00:29:29,760
uh that's that's a really broad question

00:29:27,520 --> 00:29:31,039
um i can maybe focus on one of these

00:29:29,760 --> 00:29:33,919
four types here

00:29:31,039 --> 00:29:35,039
key value uh document graph or wide

00:29:33,919 --> 00:29:36,960
column if you want to

00:29:35,039 --> 00:29:38,480
have some more focus on that do you have

00:29:36,960 --> 00:29:40,720
some performance benchmark to see how

00:29:38,480 --> 00:29:44,880
couch-based compared to traditional

00:29:40,720 --> 00:29:48,960
dbms ah yes the old benchmark question

00:29:44,880 --> 00:29:51,039
okay so uh in my mind

00:29:48,960 --> 00:29:52,320
benchmarks are really something that you

00:29:51,039 --> 00:29:54,559
do yourself

00:29:52,320 --> 00:29:55,520
you try something you benchmark it you

00:29:54,559 --> 00:29:56,559
make a change

00:29:55,520 --> 00:29:58,240
and you see how it compares to the

00:29:56,559 --> 00:29:59,520
benchmark i mean that's literally like

00:29:58,240 --> 00:30:00,720
that you literally put marks on the

00:29:59,520 --> 00:30:02,159
bench

00:30:00,720 --> 00:30:04,159
and if you're building database software

00:30:02,159 --> 00:30:05,840
like couch base you can and should

00:30:04,159 --> 00:30:07,679
automate this as much as possible so for

00:30:05,840 --> 00:30:09,120
instance these are couch bases totally

00:30:07,679 --> 00:30:12,320
public benchmarks

00:30:09,120 --> 00:30:13,600
of all of our uh our internal builds

00:30:12,320 --> 00:30:15,679
and so you can see i don't know how old

00:30:13,600 --> 00:30:17,520
this screenshot is but you can see uh

00:30:15,679 --> 00:30:18,960
kind of as the version numbers go along

00:30:17,520 --> 00:30:21,279
like the rise and fall

00:30:18,960 --> 00:30:22,640
of operations per second but it's really

00:30:21,279 --> 00:30:25,279
complicated

00:30:22,640 --> 00:30:26,720
to to do this because if you notice if

00:30:25,279 --> 00:30:28,559
you look closely

00:30:26,720 --> 00:30:31,360
there's specific configurations here so

00:30:28,559 --> 00:30:34,159
these are two nodes and 50 50 read write

00:30:31,360 --> 00:30:35,039
use cases and the jstone size is 512

00:30:34,159 --> 00:30:37,440
bytes

00:30:35,039 --> 00:30:39,279
etc so there's so many different

00:30:37,440 --> 00:30:40,880
variations and so many so many variants

00:30:39,279 --> 00:30:42,960
on that

00:30:40,880 --> 00:30:44,240
and so what people ask me like you have

00:30:42,960 --> 00:30:45,279
just done uh hey do you have some

00:30:44,240 --> 00:30:47,200
benchmarks

00:30:45,279 --> 00:30:48,720
to show couch base compared to

00:30:47,200 --> 00:30:51,120
traditional dbms

00:30:48,720 --> 00:30:52,559
and so marketing gets a hold of that

00:30:51,120 --> 00:30:55,440
question and says okay

00:30:52,559 --> 00:30:57,039
here's our benchmarks uh the green ones

00:30:55,440 --> 00:30:58,720
those are the losers right those are our

00:30:57,039 --> 00:31:00,080
competitors and so are the yellow ones

00:30:58,720 --> 00:31:01,919
those guys are the chumps

00:31:00,080 --> 00:31:04,240
and we're we're the best ones of course

00:31:01,919 --> 00:31:08,559
we have the tallest histogram here

00:31:04,240 --> 00:31:10,399
so we have the best performance um

00:31:08,559 --> 00:31:11,919
so these the problem with this is that

00:31:10,399 --> 00:31:13,600
these are these are kind of benchmarks

00:31:11,919 --> 00:31:16,320
that are published by

00:31:13,600 --> 00:31:17,519
us by the company who's telling you that

00:31:16,320 --> 00:31:18,640
we're the best and we're not going to

00:31:17,519 --> 00:31:21,360
publish a benchmark

00:31:18,640 --> 00:31:22,320
that makes ourselves look bad so you

00:31:21,360 --> 00:31:24,159
know there's there's tools out there

00:31:22,320 --> 00:31:26,399
like why csb

00:31:24,159 --> 00:31:27,679
for instance that have a variety of

00:31:26,399 --> 00:31:29,840
different workloads

00:31:27,679 --> 00:31:31,679
and we may score really well in some we

00:31:29,840 --> 00:31:32,000
may score average on some we may score

00:31:31,679 --> 00:31:34,000
below

00:31:32,000 --> 00:31:35,279
average on some so it's a lot more

00:31:34,000 --> 00:31:37,519
complicated than just here's some

00:31:35,279 --> 00:31:39,200
benchmarks look how great we are

00:31:37,519 --> 00:31:40,720
the answer is really it's depends and

00:31:39,200 --> 00:31:41,919
it's complicated so don't ignore these

00:31:40,720 --> 00:31:44,640
benchmarks but

00:31:41,919 --> 00:31:45,840
consider the source look at the details

00:31:44,640 --> 00:31:47,440
and think about doing them as part of

00:31:45,840 --> 00:31:48,320
your own project because you know your

00:31:47,440 --> 00:31:49,360
use case

00:31:48,320 --> 00:31:51,600
you know how many nodes we're going to

00:31:49,360 --> 00:31:53,120
run what's the size of our data

00:31:51,600 --> 00:31:54,720
how many reads versus how many writes

00:31:53,120 --> 00:31:57,200
things like that you know that better

00:31:54,720 --> 00:31:59,279
than than we ever will

00:31:57,200 --> 00:32:00,640
and so look at the architecture so

00:31:59,279 --> 00:32:02,640
things like

00:32:00,640 --> 00:32:04,240
how does your this database use memory

00:32:02,640 --> 00:32:06,799
how does it use disk

00:32:04,240 --> 00:32:08,240
how does it do buffering uh what about

00:32:06,799 --> 00:32:10,240
cloud deployments you know

00:32:08,240 --> 00:32:11,840
what's the latency going to be between

00:32:10,240 --> 00:32:12,559
different points different data servers

00:32:11,840 --> 00:32:14,960
things like that

00:32:12,559 --> 00:32:15,840
what what about our indexes are indexes

00:32:14,960 --> 00:32:18,240
tuned enough

00:32:15,840 --> 00:32:19,519
how much concurrency is there for a use

00:32:18,240 --> 00:32:21,840
case is there going to be a

00:32:19,519 --> 00:32:23,679
big load during uh black friday

00:32:21,840 --> 00:32:24,799
something like that for instance

00:32:23,679 --> 00:32:28,960
those are the sorts of things that i

00:32:24,799 --> 00:32:32,559
care about more than than benchmarks

00:32:28,960 --> 00:32:33,840
okay uh what else man a lot of questions

00:32:32,559 --> 00:32:37,039
coming i really love this

00:32:33,840 --> 00:32:37,519
i love these questions okay um how do we

00:32:37,039 --> 00:32:40,720
maintain

00:32:37,519 --> 00:32:42,320
acid properties in no sql databases so

00:32:40,720 --> 00:32:44,320
this is one of my favorite topics i get

00:32:42,320 --> 00:32:46,080
asked about it a lot

00:32:44,320 --> 00:32:47,200
so i talked about this example before

00:32:46,080 --> 00:32:48,640
with the shopping cart you have the two

00:32:47,200 --> 00:32:49,440
different tables and this is basically

00:32:48,640 --> 00:32:52,320
why

00:32:49,440 --> 00:32:53,440
you need acid right because if you're

00:32:52,320 --> 00:32:54,799
going to add

00:32:53,440 --> 00:32:56,559
create a shopping cart with three items

00:32:54,799 --> 00:32:58,480
in it you want that to all happen

00:32:56,559 --> 00:32:59,919
or none of it to happen it needs to be

00:32:58,480 --> 00:33:01,360
an acid transaction

00:32:59,919 --> 00:33:02,960
and that's usually what people when they

00:33:01,360 --> 00:33:05,279
say acid properties they mean

00:33:02,960 --> 00:33:06,799
acid transactions now acid is a lot more

00:33:05,279 --> 00:33:08,559
than just transactions

00:33:06,799 --> 00:33:10,080
but this is often the question that

00:33:08,559 --> 00:33:11,919
people ask me

00:33:10,080 --> 00:33:13,279
and so then you might say take that same

00:33:11,919 --> 00:33:15,440
approach

00:33:13,279 --> 00:33:17,200
do it in no sequel and this is kind of a

00:33:15,440 --> 00:33:17,440
naive approach i've called it this this

00:33:17,200 --> 00:33:19,039
is

00:33:17,440 --> 00:33:21,440
this is the approach i first took for

00:33:19,039 --> 00:33:22,080
instance i can model it the same way one

00:33:21,440 --> 00:33:24,159
document

00:33:22,080 --> 00:33:26,320
and for the cart and three documents for

00:33:24,159 --> 00:33:28,399
items and

00:33:26,320 --> 00:33:29,600
you've kind of already seen uh the

00:33:28,399 --> 00:33:30,880
reasoning for this why would i do it

00:33:29,600 --> 00:33:33,120
this way when i could just

00:33:30,880 --> 00:33:35,039
store them all as one single item and if

00:33:33,120 --> 00:33:37,279
i have one single item

00:33:35,039 --> 00:33:39,600
i don't necessarily need a transaction

00:33:37,279 --> 00:33:40,080
because a read and write to a one single

00:33:39,600 --> 00:33:43,440
item

00:33:40,080 --> 00:33:46,320
is is acid uh acid uh

00:33:43,440 --> 00:33:48,720
gives you the acid we call them acid

00:33:46,320 --> 00:33:53,440
principles acid properties

00:33:48,720 --> 00:33:56,480
with that one operation that being said

00:33:53,440 --> 00:33:57,440
not every use case can be aggregated

00:33:56,480 --> 00:34:00,799
into one document

00:33:57,440 --> 00:34:02,880
so uh recently uh a lot of the major

00:34:00,799 --> 00:34:04,640
vendors have been adding acid capability

00:34:02,880 --> 00:34:07,039
acid transaction capabilities to their

00:34:04,640 --> 00:34:09,760
nosql databases so mongo's got them

00:34:07,039 --> 00:34:12,480
couchbase has introduced them and raven

00:34:09,760 --> 00:34:15,200
for instance has them as well

00:34:12,480 --> 00:34:16,960
but i think ultimately these are nice

00:34:15,200 --> 00:34:18,480
things to have

00:34:16,960 --> 00:34:20,240
but if you're really making the move to

00:34:18,480 --> 00:34:23,839
a nosql database you you're going to

00:34:20,240 --> 00:34:23,839
find that you don't need them as much

00:34:24,240 --> 00:34:28,399
and that might surprise you but i think

00:34:26,000 --> 00:34:34,560
that's just the truth

00:34:28,399 --> 00:34:36,320
okay let's see uh what else um uh

00:34:34,560 --> 00:34:38,079
yeah someone's asking about performance

00:34:36,320 --> 00:34:39,520
any common relational db practices ought

00:34:38,079 --> 00:34:40,560
to be avoided so the one i just showed

00:34:39,520 --> 00:34:42,000
you

00:34:40,560 --> 00:34:44,240
if you're going to split your data up

00:34:42,000 --> 00:34:46,480
it's going to be more operations

00:34:44,240 --> 00:34:48,079
aggregate to a document as best as you

00:34:46,480 --> 00:34:51,520
can and that will improve

00:34:48,079 --> 00:34:52,879
your performance um

00:34:51,520 --> 00:34:55,520
can you describe the difference between

00:34:52,879 --> 00:34:57,440
these four types key value etc wow okay

00:34:55,520 --> 00:34:59,280
josh josh is being really persistent on

00:34:57,440 --> 00:35:00,480
this so i've got some time

00:34:59,280 --> 00:35:02,720
i'll go through all the different types

00:35:00,480 --> 00:35:04,400
here briefly so we'll start with key

00:35:02,720 --> 00:35:07,599
value this is the simplest one

00:35:04,400 --> 00:35:10,720
a pure key value database

00:35:07,599 --> 00:35:12,079
is one that you just have uh it's a big

00:35:10,720 --> 00:35:13,920
dictionary basically

00:35:12,079 --> 00:35:15,200
so you have a bunch of keys they're all

00:35:13,920 --> 00:35:16,960
unique

00:35:15,200 --> 00:35:19,440
and they all correspond to some piece of

00:35:16,960 --> 00:35:21,280
data and all your access all your data

00:35:19,440 --> 00:35:22,079
access is based on keys so you look up

00:35:21,280 --> 00:35:24,560
data by key

00:35:22,079 --> 00:35:25,680
you delete data by key update data by

00:35:24,560 --> 00:35:27,839
key etc

00:35:25,680 --> 00:35:29,599
and again a pure key value database it

00:35:27,839 --> 00:35:30,560
doesn't matter what the data is it could

00:35:29,599 --> 00:35:33,040
be xml

00:35:30,560 --> 00:35:33,680
it could be emojis could be text doesn't

00:35:33,040 --> 00:35:36,800
matter

00:35:33,680 --> 00:35:38,880
it's all just key based access all right

00:35:36,800 --> 00:35:40,880
so that's the really the simplest form

00:35:38,880 --> 00:35:41,920
of a nosql database is a key value

00:35:40,880 --> 00:35:43,760
lookup

00:35:41,920 --> 00:35:45,599
document will take that a step further

00:35:43,760 --> 00:35:47,359
and we say it's basically a key value

00:35:45,599 --> 00:35:48,480
database but our value now is a

00:35:47,359 --> 00:35:50,480
well-defined

00:35:48,480 --> 00:35:52,880
type of data so typically this means

00:35:50,480 --> 00:35:55,119
json it could mean xml i guess

00:35:52,880 --> 00:35:56,640
but each piece of data has a key and

00:35:55,119 --> 00:35:57,599
follows that structured or

00:35:56,640 --> 00:36:00,480
semi-structured

00:35:57,599 --> 00:36:01,599
everyone think of it format each piece

00:36:00,480 --> 00:36:03,359
of data is

00:36:01,599 --> 00:36:05,680
self-contained it's uh it can be

00:36:03,359 --> 00:36:07,839
isolated it can live on any server

00:36:05,680 --> 00:36:09,280
in that cluster which is one of the

00:36:07,839 --> 00:36:10,400
things that makes horizontal scaling

00:36:09,280 --> 00:36:12,240
much much easier

00:36:10,400 --> 00:36:13,520
it's also one of the trade-offs one of

00:36:12,240 --> 00:36:16,079
the workarounds that makes asset

00:36:13,520 --> 00:36:18,400
transactions more difficult

00:36:16,079 --> 00:36:20,079
so there's also no rules that say that

00:36:18,400 --> 00:36:22,320
every document has to conform to a

00:36:20,079 --> 00:36:23,920
certain set of fields

00:36:22,320 --> 00:36:26,320
so hypothetically you could have two

00:36:23,920 --> 00:36:29,119
documents like this in the same database

00:36:26,320 --> 00:36:32,079
one of them has age one of them does not

00:36:29,119 --> 00:36:33,359
and so for some people this is oh no way

00:36:32,079 --> 00:36:35,200
this is not acceptable

00:36:33,359 --> 00:36:37,839
for some people this is this is amazing

00:36:35,200 --> 00:36:40,160
this is this exactly solves my problem

00:36:37,839 --> 00:36:42,240
so there's a trade-off here in

00:36:40,160 --> 00:36:43,200
flexibility and horizontal scaling

00:36:42,240 --> 00:36:45,599
and but you have a little more

00:36:43,200 --> 00:36:47,359
responsibility to make sure the data is

00:36:45,599 --> 00:36:48,960
uh conforms to how you want it to

00:36:47,359 --> 00:36:50,160
conform because the database isn't going

00:36:48,960 --> 00:36:52,000
to

00:36:50,160 --> 00:36:53,359
do that conforming for you and by the

00:36:52,000 --> 00:36:54,000
way if you've used relational for any

00:36:53,359 --> 00:36:56,480
period of time

00:36:54,000 --> 00:36:58,000
you know that even relational

00:36:56,480 --> 00:37:01,119
constraints don't always solve

00:36:58,000 --> 00:37:03,599
problems with ugly data

00:37:01,119 --> 00:37:05,119
let's just say i've seen it i'm sure you

00:37:03,599 --> 00:37:07,200
have too

00:37:05,119 --> 00:37:09,119
okay so that's document we'll talk about

00:37:07,200 --> 00:37:10,400
graph and there's a session earlier on

00:37:09,119 --> 00:37:10,960
this you might want to go and refer to

00:37:10,400 --> 00:37:12,320
that one

00:37:10,960 --> 00:37:14,880
i think it was by guy royce the great

00:37:12,320 --> 00:37:18,000
guy royce also from here in central ohio

00:37:14,880 --> 00:37:19,920
the graph databases are very cool it's

00:37:18,000 --> 00:37:21,440
it's a different way to think about data

00:37:19,920 --> 00:37:23,359
it's

00:37:21,440 --> 00:37:24,800
the connections between data themselves

00:37:23,359 --> 00:37:26,960
are also data

00:37:24,800 --> 00:37:28,960
so you have nodes it's little circles

00:37:26,960 --> 00:37:31,200
here that have some data in them

00:37:28,960 --> 00:37:33,599
and you have edges that define a

00:37:31,200 --> 00:37:35,280
relationship between two pieces of data

00:37:33,599 --> 00:37:37,040
and they're directional so notice the

00:37:35,280 --> 00:37:38,720
the arrows there

00:37:37,040 --> 00:37:40,400
and this allows you to do some very

00:37:38,720 --> 00:37:42,720
interesting queries uh in terms of

00:37:40,400 --> 00:37:44,160
relationships so i could say

00:37:42,720 --> 00:37:46,160
in a very easy way with the graph

00:37:44,160 --> 00:37:49,280
database which of these nodes

00:37:46,160 --> 00:37:52,960
are enemies of luke

00:37:49,280 --> 00:37:54,960
that also appear in the force awakens

00:37:52,960 --> 00:37:56,079
and doing that in relational database is

00:37:54,960 --> 00:37:59,040
possible

00:37:56,079 --> 00:38:01,119
but just note that every type of of

00:37:59,040 --> 00:38:01,839
these arrows might be its own separate

00:38:01,119 --> 00:38:03,920
table

00:38:01,839 --> 00:38:05,440
and you could have a huge mess of joins

00:38:03,920 --> 00:38:06,560
and foreign keys and constraints and

00:38:05,440 --> 00:38:07,920
it's just going to be

00:38:06,560 --> 00:38:09,359
really really difficult to pull off and

00:38:07,920 --> 00:38:10,720
a graph database just does it so much

00:38:09,359 --> 00:38:13,280
better

00:38:10,720 --> 00:38:14,720
and the last one is wide column so

00:38:13,280 --> 00:38:16,000
cassandra there's a session after this

00:38:14,720 --> 00:38:18,160
one i highly recommend you check that

00:38:16,000 --> 00:38:19,359
one out for more details on cassandra

00:38:18,160 --> 00:38:21,440
you could think of it kind of like a

00:38:19,359 --> 00:38:24,000
table but it's not really a table

00:38:21,440 --> 00:38:24,720
each row has a key again and some number

00:38:24,000 --> 00:38:26,880
of

00:38:24,720 --> 00:38:28,480
let's call them columns and you can add

00:38:26,880 --> 00:38:30,720
columns on the fly

00:38:28,480 --> 00:38:32,880
so the data is not json but it can still

00:38:30,720 --> 00:38:35,359
be semi-structured i could put an array

00:38:32,880 --> 00:38:36,000
in favorite foods there for instance and

00:38:35,359 --> 00:38:38,800
then

00:38:36,000 --> 00:38:39,520
in terms of cassandra the actual uh

00:38:38,800 --> 00:38:41,920
partition

00:38:39,520 --> 00:38:44,079
key comes into play here so that decides

00:38:41,920 --> 00:38:46,960
which node it goes on

00:38:44,079 --> 00:38:49,839
and there's an emphasis here on uh

00:38:46,960 --> 00:38:51,440
denormalization and data duplication

00:38:49,839 --> 00:38:53,200
uh which some people find to be

00:38:51,440 --> 00:38:53,520
problematic but for the right use case

00:38:53,200 --> 00:38:56,800
it's

00:38:53,520 --> 00:38:58,079
it's totally fine um because the there's

00:38:56,800 --> 00:39:00,000
in terms of querying there's not really

00:38:58,079 --> 00:39:01,680
a concept of a join so you have to

00:39:00,000 --> 00:39:03,680
write the data as you want to read it

00:39:01,680 --> 00:39:06,000
back out which could mean

00:39:03,680 --> 00:39:07,200
some duplication we can talk about that

00:39:06,000 --> 00:39:08,960
in querying if you really want to know

00:39:07,200 --> 00:39:11,760
or again i'd recommend checking out the

00:39:08,960 --> 00:39:13,119
cassandra session after this one

00:39:11,760 --> 00:39:15,920
so hopefully that helps a little bit

00:39:13,119 --> 00:39:17,599
josh with the overview

00:39:15,920 --> 00:39:19,119
are you going to share your slides links

00:39:17,599 --> 00:39:22,240
after the presentation

00:39:19,119 --> 00:39:23,839
uh i suppose i can do that i can come by

00:39:22,240 --> 00:39:26,800
the couch base booth and i will

00:39:23,839 --> 00:39:27,440
upload them and give you a link jenna

00:39:26,800 --> 00:39:30,720
was that

00:39:27,440 --> 00:39:31,359
who asked that question okay uh i have

00:39:30,720 --> 00:39:35,520
time for maybe

00:39:31,359 --> 00:39:37,440
one or two quick ones here let's see

00:39:35,520 --> 00:39:38,720
uh graph databases any thought on the

00:39:37,440 --> 00:39:40,400
use of graph databases

00:39:38,720 --> 00:39:42,400
uh so i covered this earlier on but i

00:39:40,400 --> 00:39:44,079
think one of the most the coolest use of

00:39:42,400 --> 00:39:45,040
graph database is fraud monitoring

00:39:44,079 --> 00:39:47,680
because

00:39:45,040 --> 00:39:48,400
you can really in a very easy way

00:39:47,680 --> 00:39:51,839
identify

00:39:48,400 --> 00:39:53,599
outliers um in a system with uh with

00:39:51,839 --> 00:39:56,800
fraud monitoring and a graph database

00:39:53,599 --> 00:39:58,320
very cool stuff um so

00:39:56,800 --> 00:40:00,480
that's what i really like is a fraud

00:39:58,320 --> 00:40:02,079
monitoring or uh similarly the flip side

00:40:00,480 --> 00:40:02,480
of that is like recommendations engines

00:40:02,079 --> 00:40:04,240
where

00:40:02,480 --> 00:40:05,839
you know amazon says like oh you we

00:40:04,240 --> 00:40:06,720
notice you like this maybe you'll also

00:40:05,839 --> 00:40:08,480
like this

00:40:06,720 --> 00:40:10,319
i think graph database is good for that

00:40:08,480 --> 00:40:12,240
kind of stuff

00:40:10,319 --> 00:40:14,480
are there any use cases any clear use

00:40:12,240 --> 00:40:15,520
cases where nosql is just a bad idea and

00:40:14,480 --> 00:40:19,040
we should stick to

00:40:15,520 --> 00:40:20,480
sql so i want to reiterate that no sql

00:40:19,040 --> 00:40:23,359
databases

00:40:20,480 --> 00:40:24,960
uh and well sql and relation were two

00:40:23,359 --> 00:40:26,960
different things i made this point early

00:40:24,960 --> 00:40:28,480
on that sql is a language

00:40:26,960 --> 00:40:30,800
and so i'm going to assume you mean

00:40:28,480 --> 00:40:34,000
stick to relational

00:40:30,800 --> 00:40:36,000
um i would say

00:40:34,000 --> 00:40:37,280
if it's a if if you don't have those

00:40:36,000 --> 00:40:38,720
main problems right and

00:40:37,280 --> 00:40:40,319
and maybe this isn't what you mean by

00:40:38,720 --> 00:40:42,079
clear right but

00:40:40,319 --> 00:40:44,400
if you don't have the scaling issues if

00:40:42,079 --> 00:40:48,079
you don't have the high availability

00:40:44,400 --> 00:40:51,520
needs if you don't have large data needs

00:40:48,079 --> 00:40:53,119
even then a relational database can be

00:40:51,520 --> 00:40:57,200
totally fine

00:40:53,119 --> 00:40:59,680
um and in fact if you like some of those

00:40:57,200 --> 00:41:02,720
flexibility benefits but you don't have

00:40:59,680 --> 00:41:06,079
real clear need for high availability or

00:41:02,720 --> 00:41:07,599
you know large-scale applications

00:41:06,079 --> 00:41:09,200
this is something this is kind of a

00:41:07,599 --> 00:41:12,240
half-measure approach

00:41:09,200 --> 00:41:15,280
is postgres and others have been trying

00:41:12,240 --> 00:41:17,920
to adopt parts of the sql 2016

00:41:15,280 --> 00:41:19,599
specification which includes a way to

00:41:17,920 --> 00:41:22,319
handle json so you can have

00:41:19,599 --> 00:41:22,720
columns that have json and you can parse

00:41:22,319 --> 00:41:25,920
them

00:41:22,720 --> 00:41:27,599
and you know modify them with some json

00:41:25,920 --> 00:41:29,920
functions

00:41:27,599 --> 00:41:31,359
and so that might be a good half measure

00:41:29,920 --> 00:41:33,119
but and there's some problems

00:41:31,359 --> 00:41:34,960
with that approach you know sometimes

00:41:33,119 --> 00:41:35,520
people ask me is postgres the new no

00:41:34,960 --> 00:41:38,160
sequel

00:41:35,520 --> 00:41:40,480
and uh my answer of course is yes it is

00:41:38,160 --> 00:41:43,119
uh all knowledgeable companies suggest

00:41:40,480 --> 00:41:44,880
pack it up uh but no the real answer is

00:41:43,119 --> 00:41:46,079
it depends and it's complicated that's

00:41:44,880 --> 00:41:47,599
the question that's the answer to every

00:41:46,079 --> 00:41:49,119
question in computers right

00:41:47,599 --> 00:41:51,200
and if you want to read more on this

00:41:49,119 --> 00:41:54,319
this is a a blog post

00:41:51,200 --> 00:41:55,040
by dennis rosa who's speaking at another

00:41:54,319 --> 00:41:57,920
conference

00:41:55,040 --> 00:42:00,000
today but some of the things that he

00:41:57,920 --> 00:42:01,760
determined might be an issue

00:42:00,000 --> 00:42:03,599
are things like querying limits and

00:42:01,760 --> 00:42:05,119
indexing could be a problem

00:42:03,599 --> 00:42:06,640
uh some of the tooling is not quite

00:42:05,119 --> 00:42:07,280
there documentation's not quite there

00:42:06,640 --> 00:42:08,800
yet

00:42:07,280 --> 00:42:10,800
and you might say hold on a second

00:42:08,800 --> 00:42:12,000
that's a couch based link obviously he's

00:42:10,800 --> 00:42:14,800
going to trash

00:42:12,000 --> 00:42:16,560
competitor right well actually no this

00:42:14,800 --> 00:42:18,800
actually has been very well received by

00:42:16,560 --> 00:42:20,160
the postgres community

00:42:18,800 --> 00:42:21,599
and it's been touted and like

00:42:20,160 --> 00:42:23,520
newsletters and stuff by postgres

00:42:21,599 --> 00:42:26,400
community it's a pretty fair

00:42:23,520 --> 00:42:27,599
comparison of the two and if you want

00:42:26,400 --> 00:42:29,280
more than that

00:42:27,599 --> 00:42:30,640
this guy here don chamberlain i

00:42:29,280 --> 00:42:33,119
mentioned him earlier

00:42:30,640 --> 00:42:35,119
today one of the inventors of sql wrote

00:42:33,119 --> 00:42:36,560
a white paper as well that weighs in on

00:42:35,119 --> 00:42:38,480
sql 2016

00:42:36,560 --> 00:42:39,839
versus the sequel for json approach

00:42:38,480 --> 00:42:42,079
google plus plus

00:42:39,839 --> 00:42:44,640
and he's made that uh that white paper

00:42:42,079 --> 00:42:46,640
that small book i think you'd call it

00:42:44,640 --> 00:42:48,640
available for free if you go to bitly

00:42:46,640 --> 00:42:49,599
slash comparing sql i'll go and put that

00:42:48,640 --> 00:42:53,920
into the chat

00:42:49,599 --> 00:42:53,920
so you don't have to type it yourself

00:42:54,560 --> 00:42:58,000
there you go so i'd recommend reading

00:42:57,200 --> 00:43:00,160
that as well it's

00:42:58,000 --> 00:43:02,400
it's you know he he's uh technically

00:43:00,160 --> 00:43:04,960
he's a couch-based employee as well he's

00:43:02,400 --> 00:43:05,920
on the tech advisory board at couch base

00:43:04,960 --> 00:43:07,359
but uh he's

00:43:05,920 --> 00:43:09,280
he's weighed in on that and who better

00:43:07,359 --> 00:43:10,240
than the inventor of sql to weigh in on

00:43:09,280 --> 00:43:13,119
that issue

00:43:10,240 --> 00:43:14,800
um i don't have time to cover this i'm

00:43:13,119 --> 00:43:16,319
going to have to wrap up here i got till

00:43:14,800 --> 00:43:17,760
3 15

00:43:16,319 --> 00:43:19,359
so these are all great questions i

00:43:17,760 --> 00:43:21,520
really appreciate them all

00:43:19,359 --> 00:43:22,800
i appreciate your votes uh and

00:43:21,520 --> 00:43:24,240
everything

00:43:22,800 --> 00:43:25,680
you can please come to the couch-based

00:43:24,240 --> 00:43:27,440
booth afterwards i'll be there and my

00:43:25,680 --> 00:43:29,760
colleague will be there and we can

00:43:27,440 --> 00:43:31,680
we can try to uh if you can just chat me

00:43:29,760 --> 00:43:33,040
in the six connects platform

00:43:31,680 --> 00:43:35,760
i'm happy to answer these questions for

00:43:33,040 --> 00:43:37,839
you just gonna sum up here real quick

00:43:35,760 --> 00:43:39,599
scaling kind of the whole reason for

00:43:37,839 --> 00:43:40,640
nosql in the first place was designed to

00:43:39,599 --> 00:43:42,240
solve scaling

00:43:40,640 --> 00:43:44,240
it's evolved and matured a lot since

00:43:42,240 --> 00:43:46,880
then but that's kind of the

00:43:44,240 --> 00:43:48,560
core reason it exists nosql is a lousy

00:43:46,880 --> 00:43:51,440
buzzword

00:43:48,560 --> 00:43:51,760
nosql can still use sql it just means

00:43:51,440 --> 00:43:53,680
that

00:43:51,760 --> 00:43:54,960
databases are not one size fits all and

00:43:53,680 --> 00:43:57,920
really gotta drill down

00:43:54,960 --> 00:43:59,599
like josh uh wanted me to do today into

00:43:57,920 --> 00:44:02,240
the more specific types of it

00:43:59,599 --> 00:44:03,040
and think about the why what problems do

00:44:02,240 --> 00:44:04,720
you have

00:44:03,040 --> 00:44:06,560
what database problems do you have is it

00:44:04,720 --> 00:44:08,079
scaling is it flexibility performance

00:44:06,560 --> 00:44:10,400
high availability

00:44:08,079 --> 00:44:11,760
what would help you solve them do a

00:44:10,400 --> 00:44:12,960
proof of concept and try these things

00:44:11,760 --> 00:44:14,400
out

00:44:12,960 --> 00:44:16,720
and and just try them on your own and

00:44:14,400 --> 00:44:18,240
see what you think and try benchmarks on

00:44:16,720 --> 00:44:19,520
your own

00:44:18,240 --> 00:44:20,800
uh if anything looks interesting to you

00:44:19,520 --> 00:44:21,520
in these slides like i said you can you

00:44:20,800 --> 00:44:24,400
can chat me

00:44:21,520 --> 00:44:25,599
here in all things open uh you know the

00:44:24,400 --> 00:44:27,599
chat platform

00:44:25,599 --> 00:44:29,280
um you can also contact me on twitter

00:44:27,599 --> 00:44:32,240
there i'm also on twitch

00:44:29,280 --> 00:44:33,280
from time to time uh i also i love to

00:44:32,240 --> 00:44:34,800
answer questions like this

00:44:33,280 --> 00:44:36,480
all the time on twitch we just do

00:44:34,800 --> 00:44:37,839
basically live q a

00:44:36,480 --> 00:44:40,160
sessions on twitch all the time they're

00:44:37,839 --> 00:44:42,160
not formal slide presentations like this

00:44:40,160 --> 00:44:43,839
it's just hang out code

00:44:42,160 --> 00:44:45,200
discuss some things and of course you

00:44:43,839 --> 00:44:46,480
can email me at couchbase

00:44:45,200 --> 00:44:48,880
i want to say thank you to all things

00:44:46,480 --> 00:44:51,040
open for having me speak again thank you

00:44:48,880 --> 00:44:52,160
kiane for moderate moderating i really

00:44:51,040 --> 00:44:53,839
appreciate uh

00:44:52,160 --> 00:44:54,960
the opportunity to speak to all things

00:44:53,839 --> 00:44:56,000
open again one of my favorite

00:44:54,960 --> 00:44:57,520
conferences

00:44:56,000 --> 00:45:05,760
thank you all for coming and i hope you

00:44:57,520 --> 00:45:05,760

YouTube URL: https://www.youtube.com/watch?v=ZVGp9n7VCzU


