Title: Understanding MySQL Concepts - Matthias Crauwels
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Databases Track
Description: 
	Presented by: Matthias Crauwels, Pythian
Presented at All Things Open 2020 - Databases Track

Abstract: MySQL is the largest open-source database in the world. I will guide you through the basic concepts from architecture to replication and installation of the product. We'll discuss features and we'll go into some details about what we experience as the strong points and what are the weaknesses. I will focus on the latest release of MySQL Community Edition, version 8.0,  but we'll go into some of the differences with popular forks such as MariaDB and Percona Server.
Captions: 
	00:00:05,040 --> 00:00:10,240
hey everybody

00:00:06,399 --> 00:00:12,160
um since mysql56 the default storage

00:00:10,240 --> 00:00:14,080
engine is in adb

00:00:12,160 --> 00:00:16,320
and since five five the recommendation

00:00:14,080 --> 00:00:19,039
has always been to use idb for general

00:00:16,320 --> 00:00:21,439
purpose workloads there are

00:00:19,039 --> 00:00:24,480
exams where you can choose for something

00:00:21,439 --> 00:00:29,359
else but for general purpose workloads

00:00:24,480 --> 00:00:32,000
iodb is should be your first choice

00:00:29,359 --> 00:00:33,360
before five six the defaults uh what's

00:00:32,000 --> 00:00:36,160
my item

00:00:33,360 --> 00:00:37,520
uh however the mysql system tables like

00:00:36,160 --> 00:00:39,120
where your users are starting your

00:00:37,520 --> 00:00:39,920
grants are stored and all those things

00:00:39,120 --> 00:00:42,480
are stored

00:00:39,920 --> 00:00:43,040
before mysql eight they were also still

00:00:42,480 --> 00:00:46,000
using

00:00:43,040 --> 00:00:48,079
my item however everybody recommended to

00:00:46,000 --> 00:00:52,879
use id for everything

00:00:48,079 --> 00:00:56,960
mysql internally was still using my item

00:00:52,879 --> 00:00:57,440
since mysql8 that has been changed so

00:00:56,960 --> 00:01:00,800
there's

00:00:57,440 --> 00:01:03,199
new data dictionary in mysql8

00:01:00,800 --> 00:01:05,199
and now all those system tables are also

00:01:03,199 --> 00:01:08,159
using inodb

00:01:05,199 --> 00:01:09,520
and since 80s is the first time ever

00:01:08,159 --> 00:01:13,840
that you can

00:01:09,520 --> 00:01:14,320
disable and there's also the first time

00:01:13,840 --> 00:01:17,520
ever

00:01:14,320 --> 00:01:20,400
that there was a feature removed from

00:01:17,520 --> 00:01:20,880
the from the server as part as an

00:01:20,400 --> 00:01:23,680
upgrade

00:01:20,880 --> 00:01:24,960
so from the search engine so the table

00:01:23,680 --> 00:01:26,720
exporting

00:01:24,960 --> 00:01:29,119
and how you use the storage engine is

00:01:26,720 --> 00:01:30,960
fairly simple so you have a create table

00:01:29,119 --> 00:01:32,560
statement and you basically say

00:01:30,960 --> 00:01:34,400
which engine you want to use if you

00:01:32,560 --> 00:01:35,759
don't specify an engine it will use the

00:01:34,400 --> 00:01:38,880
default

00:01:35,759 --> 00:01:40,320
but you could specify the engine type

00:01:38,880 --> 00:01:41,920
that you want to use so for example

00:01:40,320 --> 00:01:44,479
create table blah blah blah

00:01:41,920 --> 00:01:45,280
engine equals ion db and then your table

00:01:44,479 --> 00:01:49,759
will be using an

00:01:45,280 --> 00:01:50,399
ebs search engine a little bit about my

00:01:49,759 --> 00:01:53,119
isom

00:01:50,399 --> 00:01:53,840
and this is the the search engine that

00:01:53,119 --> 00:01:55,920
is

00:01:53,840 --> 00:01:57,759
has initiated the holy wars because

00:01:55,920 --> 00:02:00,399
everybody was saying like hey

00:01:57,759 --> 00:02:02,240
mysql does not have transactions it does

00:02:00,399 --> 00:02:04,240
not have foreign keys it does not

00:02:02,240 --> 00:02:05,600
only have table level locking and all

00:02:04,240 --> 00:02:08,879
those things

00:02:05,600 --> 00:02:10,000
that was true my isom didn't have all

00:02:08,879 --> 00:02:12,720
those things

00:02:10,000 --> 00:02:14,160
but for a very long time ionodb was

00:02:12,720 --> 00:02:16,160
already existing

00:02:14,160 --> 00:02:18,480
and for a long time it was like a

00:02:16,160 --> 00:02:22,080
plug-in to the server that you had to

00:02:18,480 --> 00:02:26,160
specifically enable since five five

00:02:22,080 --> 00:02:29,920
the iowdb plugin has been the default

00:02:26,160 --> 00:02:32,560
inside the server and that has made

00:02:29,920 --> 00:02:34,720
things a lot more easy to configure and

00:02:32,560 --> 00:02:36,239
to use

00:02:34,720 --> 00:02:38,080
the only the only other thing that i

00:02:36,239 --> 00:02:40,879
will say about myasm is if you

00:02:38,080 --> 00:02:42,319
uh if you look at your uh your data

00:02:40,879 --> 00:02:44,239
directory

00:02:42,319 --> 00:02:45,440
where the data is stored my item stores

00:02:44,239 --> 00:02:48,720
your tables

00:02:45,440 --> 00:02:51,360
into two different files uh so the key

00:02:48,720 --> 00:02:53,680
that the table name dot myd is contains

00:02:51,360 --> 00:02:54,720
your data and then the myi contains your

00:02:53,680 --> 00:02:56,879
indexes

00:02:54,720 --> 00:02:58,080
and then before ado there was also an

00:02:56,879 --> 00:03:01,280
frm file

00:02:58,080 --> 00:03:04,159
which is the uh the data dictionary

00:03:01,280 --> 00:03:04,879
it was the place where the metadata

00:03:04,159 --> 00:03:09,280
about

00:03:04,879 --> 00:03:12,720
the the schema was stored

00:03:09,280 --> 00:03:15,599
um the current default search engine

00:03:12,720 --> 00:03:18,080
idb general purpose search engine it has

00:03:15,599 --> 00:03:21,120
uh full asset compliant transactions

00:03:18,080 --> 00:03:24,159
it supports multiversion concurrency

00:03:21,120 --> 00:03:26,879
you can have row level locking there's

00:03:24,159 --> 00:03:29,040
oracle style consistent reads you have

00:03:26,879 --> 00:03:32,159
foreign keys compression encryption

00:03:29,040 --> 00:03:35,440
and a single table can hold up to 64.

00:03:32,159 --> 00:03:35,920
terabytes of storage which is quite a

00:03:35,440 --> 00:03:39,120
lot

00:03:35,920 --> 00:03:42,560
if you want to put

00:03:39,120 --> 00:03:44,080
46 terabytes of storage in mysql and and

00:03:42,560 --> 00:03:47,680
be

00:03:44,080 --> 00:03:50,000
fair and work with that very um

00:03:47,680 --> 00:03:52,480
fluently that will be will require a lot

00:03:50,000 --> 00:03:56,000
of uh horsepower in your server

00:03:52,480 --> 00:03:56,400
uh this slide alone uh is is a two hour

00:03:56,000 --> 00:03:58,400
talk

00:03:56,400 --> 00:03:59,680
talk so i'm not going to go into too

00:03:58,400 --> 00:04:01,840
much details

00:03:59,680 --> 00:04:04,640
but you can see that there's in memory

00:04:01,840 --> 00:04:06,640
structures and on disk structures

00:04:04,640 --> 00:04:08,959
on disk is obviously where your data is

00:04:06,640 --> 00:04:10,879
stored so you have the system tablespace

00:04:08,959 --> 00:04:12,879
which is the default place where data is

00:04:10,879 --> 00:04:16,000
stored but you can also have

00:04:12,879 --> 00:04:18,880
um other general table spaces or

00:04:16,000 --> 00:04:20,000
file per tables tablespace if file per

00:04:18,880 --> 00:04:22,320
table is on

00:04:20,000 --> 00:04:23,680
and then each table gets its own table

00:04:22,320 --> 00:04:26,800
space on disk

00:04:23,680 --> 00:04:28,080
the most important in memory structure

00:04:26,800 --> 00:04:30,479
is the buffer pool

00:04:28,080 --> 00:04:32,240
everything you read or writes to inode b

00:04:30,479 --> 00:04:36,000
will go through the buffer pool

00:04:32,240 --> 00:04:37,040
uh and so the defaults is still 128

00:04:36,000 --> 00:04:40,080
megabytes

00:04:37,040 --> 00:04:42,400
so in in either way if you have more

00:04:40,080 --> 00:04:42,400
than

00:04:42,520 --> 00:04:47,680
256 megabytes of memory

00:04:45,280 --> 00:04:49,520
available in your server which most

00:04:47,680 --> 00:04:52,000
servers have nowadays

00:04:49,520 --> 00:04:53,680
you should change the buffer pool to a

00:04:52,000 --> 00:04:56,240
higher number

00:04:53,680 --> 00:04:59,600
because everything your reader writes in

00:04:56,240 --> 00:04:59,600
itunes db goes through it

00:04:59,680 --> 00:05:04,320
some best practices for indb always

00:05:01,840 --> 00:05:07,280
define a primary key

00:05:04,320 --> 00:05:09,360
use the most frequently queried columns

00:05:07,280 --> 00:05:09,759
if no obvious primary key can be found

00:05:09,360 --> 00:05:11,680
then

00:05:09,759 --> 00:05:15,280
use an auto increment column so it's

00:05:11,680 --> 00:05:17,440
just a counter that goes up from one to

00:05:15,280 --> 00:05:18,800
uh to the maximum value of your of your

00:05:17,440 --> 00:05:21,039
data type

00:05:18,800 --> 00:05:22,560
um turn off autocommits committing

00:05:21,039 --> 00:05:25,440
hundreds of times per seconds puts

00:05:22,560 --> 00:05:27,680
really a cap on performance

00:05:25,440 --> 00:05:29,280
it limits it's limited by the write

00:05:27,680 --> 00:05:32,639
speed of your storage device so

00:05:29,280 --> 00:05:34,800
every commit needs to be persisted

00:05:32,639 --> 00:05:36,880
to a log file to a reader log file maybe

00:05:34,800 --> 00:05:40,560
to a data file

00:05:36,880 --> 00:05:42,000
so uh try to turn off auto commits and

00:05:40,560 --> 00:05:45,039
try to group your

00:05:42,000 --> 00:05:47,840
your mod your dml so any change

00:05:45,039 --> 00:05:49,280
to the data in a transaction using begin

00:05:47,840 --> 00:05:51,199
or start transaction

00:05:49,280 --> 00:05:53,280
and then at the end commit or roll back

00:05:51,199 --> 00:05:55,759
if you want to roll it back

00:05:53,280 --> 00:05:56,960
but it really will make an imp a very

00:05:55,759 --> 00:05:59,440
big

00:05:56,960 --> 00:06:00,319
improvement on your on your performance

00:05:59,440 --> 00:06:02,639
um

00:06:00,319 --> 00:06:04,240
if you if you use transactions and not

00:06:02,639 --> 00:06:07,280
use just autocommit

00:06:04,240 --> 00:06:07,600
where every uh every query on its own is

00:06:07,280 --> 00:06:10,080
a

00:06:07,600 --> 00:06:11,759
is a transaction and so that really puts

00:06:10,080 --> 00:06:14,240
a limit on what you can do

00:06:11,759 --> 00:06:16,319
and i know eb file per table it's also

00:06:14,240 --> 00:06:19,520
something very very useful

00:06:16,319 --> 00:06:23,360
to not have one giant ib data file

00:06:19,520 --> 00:06:25,120
but have all your tables in a separate

00:06:23,360 --> 00:06:28,880
data file

00:06:25,120 --> 00:06:32,479
which will improve performance also

00:06:28,880 --> 00:06:35,120
and it will be better for

00:06:32,479 --> 00:06:35,520
for all of things it's default since 5.6

00:06:35,120 --> 00:06:37,440
but

00:06:35,520 --> 00:06:39,120
if you're migrating an older version

00:06:37,440 --> 00:06:42,319
then you probably

00:06:39,120 --> 00:06:42,319
will want to turn this on

00:06:42,560 --> 00:06:47,039
other storage engines very quickly ndb

00:06:44,720 --> 00:06:48,479
cluster storage engine is used by mysql

00:06:47,039 --> 00:06:51,120
ndb cluster which i

00:06:48,479 --> 00:06:51,840
briefly touched in my introductory slide

00:06:51,120 --> 00:06:56,240
it's the

00:06:51,840 --> 00:06:58,960
cluster solution it's an enterprise

00:06:56,240 --> 00:07:00,479
edition feature so i'm not going to into

00:06:58,960 --> 00:07:02,000
much detail

00:07:00,479 --> 00:07:04,080
you have the memory storage engine

00:07:02,000 --> 00:07:06,560
source data in memory but not on disk

00:07:04,080 --> 00:07:08,240
obviously then black hole is very funny

00:07:06,560 --> 00:07:11,280
it redirects your data to death now

00:07:08,240 --> 00:07:14,240
so if you do create table engine

00:07:11,280 --> 00:07:16,000
black hole then you can write a lot of

00:07:14,240 --> 00:07:17,680
data to the table it will be very

00:07:16,000 --> 00:07:19,680
performant but it will never be stored

00:07:17,680 --> 00:07:23,759
on any disk

00:07:19,680 --> 00:07:26,800
csv you can use comma separated values

00:07:23,759 --> 00:07:29,680
federated sorry archive

00:07:26,800 --> 00:07:31,360
for a large amount of index data you

00:07:29,680 --> 00:07:33,039
cannot delete or update

00:07:31,360 --> 00:07:34,800
anything in the archive search engine

00:07:33,039 --> 00:07:37,919
but if you have like

00:07:34,800 --> 00:07:40,160
a lot of writes um that you

00:07:37,919 --> 00:07:41,840
only sometimes read and they can never

00:07:40,160 --> 00:07:43,360
be changed the archive search engine is

00:07:41,840 --> 00:07:45,919
there for you

00:07:43,360 --> 00:07:47,919
federated it allows you to access tables

00:07:45,919 --> 00:07:51,199
on a remote mysql server

00:07:47,919 --> 00:07:53,599
be aware that this might be fairly slow

00:07:51,199 --> 00:07:54,960
so if you want to use this there's use

00:07:53,599 --> 00:07:57,280
cases for it

00:07:54,960 --> 00:07:58,400
but think about it very carefully before

00:07:57,280 --> 00:08:01,280
you use this

00:07:58,400 --> 00:08:02,960
uh roxdb is some is developed as a new

00:08:01,280 --> 00:08:05,520
search engine based on my

00:08:02,960 --> 00:08:07,120
uh myrocks is the mysql variants it's

00:08:05,520 --> 00:08:09,599
based on roxdb

00:08:07,120 --> 00:08:10,400
it's uh whereas all the other search

00:08:09,599 --> 00:08:13,840
engines are

00:08:10,400 --> 00:08:16,479
b3 based storage engines

00:08:13,840 --> 00:08:18,000
are the roxdb is the lock structured

00:08:16,479 --> 00:08:20,560
merge tree

00:08:18,000 --> 00:08:23,599
search engine it's optimized for rights

00:08:20,560 --> 00:08:26,400
and storage space efficiency

00:08:23,599 --> 00:08:30,080
it was developed by facebook they have

00:08:26,400 --> 00:08:30,080
presentations about that in the open

00:08:30,560 --> 00:08:35,039
it saves them about 50 on this space and

00:08:33,440 --> 00:08:36,479
if you're their size

00:08:35,039 --> 00:08:38,880
then obviously that makes a big

00:08:36,479 --> 00:08:41,919
difference it's not available in the

00:08:38,880 --> 00:08:45,360
default community server

00:08:41,919 --> 00:08:47,600
it is bundled with mariadb since 10 2

00:08:45,360 --> 00:08:49,680
and 10 3

00:08:47,600 --> 00:08:53,680
and it's available as a separate package

00:08:49,680 --> 00:08:55,839
if you use epikuna server since 5.7

00:08:53,680 --> 00:08:59,920
so if you want to use roxdb uh you

00:08:55,839 --> 00:08:59,920
should use either maria abracona server

00:09:00,640 --> 00:09:05,519
but it it really is optimized for write

00:09:03,600 --> 00:09:07,760
and storage space if you have a specific

00:09:05,519 --> 00:09:12,640
need for an lsm3 based

00:09:07,760 --> 00:09:12,640
storage engine roxdb or myrocks is there

00:09:12,880 --> 00:09:17,279
given that this talk was originally

00:09:14,240 --> 00:09:21,279
written for oracle

00:09:17,279 --> 00:09:22,959
dbas mysql does not support pl sql

00:09:21,279 --> 00:09:25,200
there's a basic implementation of stored

00:09:22,959 --> 00:09:28,640
procedures and events

00:09:25,200 --> 00:09:30,399
and my speculation is that this will not

00:09:28,640 --> 00:09:31,760
come in oracle mysql

00:09:30,399 --> 00:09:34,240
because they have their big brother

00:09:31,760 --> 00:09:37,200
oracle database and

00:09:34,240 --> 00:09:37,760
i don't think that there will be much

00:09:37,200 --> 00:09:40,000
traction

00:09:37,760 --> 00:09:42,800
inside oracle to start implementing

00:09:40,000 --> 00:09:45,519
something like this in mysql

00:09:42,800 --> 00:09:48,320
mariadb understands a subset of pl sql

00:09:45,519 --> 00:09:51,360
it does not fully support it

00:09:48,320 --> 00:09:54,160
there's an sql mode called oracle uh

00:09:51,360 --> 00:09:56,240
in in since mariadb 103. and there's

00:09:54,160 --> 00:09:58,080
just that's a list of aliases to support

00:09:56,240 --> 00:09:59,040
oracle sql dialect like stored

00:09:58,080 --> 00:10:01,360
procedures

00:09:59,040 --> 00:10:02,480
things like that uh if you want to

00:10:01,360 --> 00:10:05,600
select from dual

00:10:02,480 --> 00:10:08,720
uh like you could do in in oracle

00:10:05,600 --> 00:10:11,839
oracle sql mode support in mariadb

00:10:08,720 --> 00:10:11,839
but yeah

00:10:12,000 --> 00:10:15,920
next major subject and i still have 15

00:10:14,640 --> 00:10:19,040
minutes which is good

00:10:15,920 --> 00:10:21,680
is replication um replication

00:10:19,040 --> 00:10:22,320
enables data from one mysql database

00:10:21,680 --> 00:10:24,079
server

00:10:22,320 --> 00:10:26,079
which used to be called the master but

00:10:24,079 --> 00:10:29,760
since uh

00:10:26,079 --> 00:10:32,399
the recent inclusive inclusivity um

00:10:29,760 --> 00:10:34,240
jargon changes they are now starting to

00:10:32,399 --> 00:10:36,320
refer to the source server

00:10:34,240 --> 00:10:38,720
to be copied to one or more database

00:10:36,320 --> 00:10:41,839
servers which they call the replicas

00:10:38,720 --> 00:10:43,839
replication is asynchronous by default

00:10:41,839 --> 00:10:46,240
replicas do not need to be connected

00:10:43,839 --> 00:10:47,600
permanently to receive updates depending

00:10:46,240 --> 00:10:49,839
on the configuration

00:10:47,600 --> 00:10:52,079
you can replicate all selected databases

00:10:49,839 --> 00:10:54,399
if you select the tables

00:10:52,079 --> 00:10:57,120
advantages of replication you can do

00:10:54,399 --> 00:10:59,120
reach scale out your data is

00:10:57,120 --> 00:11:00,959
you can write on one place and reach

00:10:59,120 --> 00:11:02,720
from many other places

00:11:00,959 --> 00:11:05,200
you have data security because your data

00:11:02,720 --> 00:11:08,000
is no longer in a single server

00:11:05,200 --> 00:11:09,200
you have multiple servers where you can

00:11:08,000 --> 00:11:12,320
read the data from

00:11:09,200 --> 00:11:15,120
you can use it for analytics like if you

00:11:12,320 --> 00:11:18,000
have really big analytics queries that

00:11:15,120 --> 00:11:20,560
you want to run but you do not want to

00:11:18,000 --> 00:11:21,920
take away resources from your your

00:11:20,560 --> 00:11:24,959
production or your

00:11:21,920 --> 00:11:27,279
oltp services you can just set up an

00:11:24,959 --> 00:11:29,680
analytics replica

00:11:27,279 --> 00:11:30,480
and run your your slow queries there and

00:11:29,680 --> 00:11:33,200
none of the other

00:11:30,480 --> 00:11:34,240
uh installations will be will be

00:11:33,200 --> 00:11:36,640
impacted

00:11:34,240 --> 00:11:38,399
or you can do it for long distance data

00:11:36,640 --> 00:11:39,600
distribution if you have slow links

00:11:38,399 --> 00:11:42,640
between

00:11:39,600 --> 00:11:46,000
uh between data centers uh asynchronous

00:11:42,640 --> 00:11:47,279
uh helps there uh the the source server

00:11:46,000 --> 00:11:50,880
does never have to wait

00:11:47,279 --> 00:11:54,320
on the on the replica before uh going on

00:11:50,880 --> 00:11:56,320
moving on um so yeah there's some

00:11:54,320 --> 00:11:58,240
some statements there you can use to

00:11:56,320 --> 00:12:00,880
configure applications so you do change

00:11:58,240 --> 00:12:02,399
master too and this will probably be

00:12:00,880 --> 00:12:03,600
changed to change source to in the

00:12:02,399 --> 00:12:05,440
future

00:12:03,600 --> 00:12:07,440
um then you can do start stop

00:12:05,440 --> 00:12:09,200
replication start slave or

00:12:07,440 --> 00:12:11,200
start or stop slave which will become

00:12:09,200 --> 00:12:13,760
start to stop replica

00:12:11,200 --> 00:12:14,880
and to diagnose replication you can run

00:12:13,760 --> 00:12:16,560
show slave status

00:12:14,880 --> 00:12:18,320
in the future that will be show replica

00:12:16,560 --> 00:12:22,240
status

00:12:18,320 --> 00:12:22,240
but for now this this will still work

00:12:23,440 --> 00:12:27,279
to support replication mysql has

00:12:25,680 --> 00:12:30,560
something called binary logs

00:12:27,279 --> 00:12:32,480
and each dml so any modification or data

00:12:30,560 --> 00:12:34,720
ddl data definition

00:12:32,480 --> 00:12:36,639
is written to a log file called the

00:12:34,720 --> 00:12:40,000
binary log if it's enabled

00:12:36,639 --> 00:12:42,000
it's not enabled by default but our

00:12:40,000 --> 00:12:45,440
general recommendation is to enable

00:12:42,000 --> 00:12:48,320
um binary logging

00:12:45,440 --> 00:12:49,519
um no information about the user

00:12:48,320 --> 00:12:52,320
executing the query stored

00:12:49,519 --> 00:12:53,279
so it's not suitable for audit logging

00:12:52,320 --> 00:12:56,000
but

00:12:53,279 --> 00:12:56,880
and events are identified by a file and

00:12:56,000 --> 00:12:59,360
a position so

00:12:56,880 --> 00:13:00,240
in the file the event that you're

00:12:59,360 --> 00:13:01,760
referring to

00:13:00,240 --> 00:13:03,279
is stored in a specific file on a

00:13:01,760 --> 00:13:05,200
specific position

00:13:03,279 --> 00:13:06,399
and replicas are configured with this

00:13:05,200 --> 00:13:08,079
file and position to

00:13:06,399 --> 00:13:09,680
know where to start reading the binary

00:13:08,079 --> 00:13:11,760
logs from

00:13:09,680 --> 00:13:12,880
there's three formats basically well

00:13:11,760 --> 00:13:15,040
there's two formats

00:13:12,880 --> 00:13:17,120
of binary logs you have statement based

00:13:15,040 --> 00:13:19,360
uh replication statement based

00:13:17,120 --> 00:13:22,000
uh by reload format and then in the

00:13:19,360 --> 00:13:23,600
binary logs there are statements written

00:13:22,000 --> 00:13:25,920
the same way as they were processed on

00:13:23,600 --> 00:13:28,720
the source server and the replica just

00:13:25,920 --> 00:13:29,279
re-executes the same statement if you

00:13:28,720 --> 00:13:32,560
have

00:13:29,279 --> 00:13:35,360
a row binary log format then the changed

00:13:32,560 --> 00:13:37,440
row data is written to the binary log

00:13:35,360 --> 00:13:39,760
and the replica will just need to update

00:13:37,440 --> 00:13:41,360
the row information on its local copy

00:13:39,760 --> 00:13:43,440
and not need to execute the entire

00:13:41,360 --> 00:13:44,160
statement again so no optimizer anymore

00:13:43,440 --> 00:13:45,920
no

00:13:44,160 --> 00:13:47,519
it will just update the rows that it

00:13:45,920 --> 00:13:50,399
needs to

00:13:47,519 --> 00:13:51,040
mix mixed replication is a combination

00:13:50,399 --> 00:13:53,199
of both

00:13:51,040 --> 00:13:54,240
so it uses statement based replication

00:13:53,199 --> 00:13:55,680
by default

00:13:54,240 --> 00:13:58,240
except when it detects something

00:13:55,680 --> 00:14:00,880
non-deterministic and it switches to row

00:13:58,240 --> 00:14:02,079
what's the danger with with statement

00:14:00,880 --> 00:14:04,720
based if your statement

00:14:02,079 --> 00:14:05,760
has something called like a uuid

00:14:04,720 --> 00:14:10,160
function so you do

00:14:05,760 --> 00:14:12,079
insert into table ui values uuid

00:14:10,160 --> 00:14:13,519
if you do that if you actually get it on

00:14:12,079 --> 00:14:14,959
the master that will give you a

00:14:13,519 --> 00:14:16,560
different result than if you have

00:14:14,959 --> 00:14:19,600
executed on the slave

00:14:16,560 --> 00:14:22,079
there are some mitigations done in the

00:14:19,600 --> 00:14:24,399
binary log format or in the by reload

00:14:22,079 --> 00:14:25,680
specification to mitigate some things

00:14:24,399 --> 00:14:28,800
like now

00:14:25,680 --> 00:14:29,360
or or things like that but still there

00:14:28,800 --> 00:14:32,480
are

00:14:29,360 --> 00:14:33,600
queries where it will be a problem like

00:14:32,480 --> 00:14:36,560
if you do an insert

00:14:33,600 --> 00:14:38,079
insert into select from um if the select

00:14:36,560 --> 00:14:40,000
returns a different result on the

00:14:38,079 --> 00:14:42,399
replica then on the mast on the

00:14:40,000 --> 00:14:43,120
on the source then there will be

00:14:42,399 --> 00:14:45,920
difference

00:14:43,120 --> 00:14:47,440
in your inserts and with row based

00:14:45,920 --> 00:14:50,160
replication

00:14:47,440 --> 00:14:51,760
that will never happen because you store

00:14:50,160 --> 00:14:53,279
in the binary logs the data that is

00:14:51,760 --> 00:14:56,880
changed that is written that is actually

00:14:53,279 --> 00:15:00,720
written on the site on the

00:14:56,880 --> 00:15:03,040
source server so binary logs

00:15:00,720 --> 00:15:05,360
are like a stream of all the changes

00:15:03,040 --> 00:15:07,760
that occur inside the mysql server

00:15:05,360 --> 00:15:08,800
and each event also has a timestamp

00:15:07,760 --> 00:15:11,440
attached to it

00:15:08,800 --> 00:15:12,000
so it can be used for point in time

00:15:11,440 --> 00:15:15,199
recovery

00:15:12,000 --> 00:15:17,120
so if you have for example a developer

00:15:15,199 --> 00:15:18,959
doing a delete on a table without a

00:15:17,120 --> 00:15:20,639
where clause and if all the data in the

00:15:18,959 --> 00:15:23,760
table is gone

00:15:20,639 --> 00:15:26,480
you can restore up to the point where

00:15:23,760 --> 00:15:27,040
that delete happens so to do that you

00:15:26,480 --> 00:15:28,880
you

00:15:27,040 --> 00:15:30,399
obviously need to have a backup first of

00:15:28,880 --> 00:15:32,959
all the data

00:15:30,399 --> 00:15:34,880
so you you restore the latest backup

00:15:32,959 --> 00:15:38,160
that that you have available

00:15:34,880 --> 00:15:40,320
and then you identify the binary log

00:15:38,160 --> 00:15:43,759
position where that delete happens and

00:15:40,320 --> 00:15:45,120
now you replay uh all the binary logs

00:15:43,759 --> 00:15:46,639
from your backup

00:15:45,120 --> 00:15:48,560
from the point that your backup sets

00:15:46,639 --> 00:15:51,120
that it it was uh

00:15:48,560 --> 00:15:51,920
created so the binary position at that

00:15:51,120 --> 00:15:54,160
time

00:15:51,920 --> 00:15:55,279
right until the position just before

00:15:54,160 --> 00:15:57,600
your delete

00:15:55,279 --> 00:15:58,880
and now you have the exact same state of

00:15:57,600 --> 00:16:00,720
the table

00:15:58,880 --> 00:16:03,759
that had to delete and you can use that

00:16:00,720 --> 00:16:05,839
now to to restore your original table

00:16:03,759 --> 00:16:08,800
or you can use this instance to continue

00:16:05,839 --> 00:16:11,199
your work

00:16:08,800 --> 00:16:13,040
in order to do that you must have your

00:16:11,199 --> 00:16:14,720
binary logs around

00:16:13,040 --> 00:16:16,800
long enough until you have successful

00:16:14,720 --> 00:16:18,880
backup so

00:16:16,800 --> 00:16:20,639
backups are important but it's also

00:16:18,880 --> 00:16:22,560
important to back up your binary logs or

00:16:20,639 --> 00:16:24,079
at least keep them around

00:16:22,560 --> 00:16:26,079
until you have confirmed that your

00:16:24,079 --> 00:16:28,639
backup is successful

00:16:26,079 --> 00:16:30,000
once the backup is is there although all

00:16:28,639 --> 00:16:32,800
the binary logs

00:16:30,000 --> 00:16:33,519
before that are becoming irrelevant

00:16:32,800 --> 00:16:36,000
because

00:16:33,519 --> 00:16:38,000
all the data is already in the backup

00:16:36,000 --> 00:16:40,079
but

00:16:38,000 --> 00:16:42,880
everything after that point in time that

00:16:40,079 --> 00:16:45,279
the backups completed

00:16:42,880 --> 00:16:46,880
you don't have and so it's important to

00:16:45,279 --> 00:16:49,920
keep the binary locks around

00:16:46,880 --> 00:16:51,920
and we usually recommend please back up

00:16:49,920 --> 00:16:53,759
your binary log so in case something

00:16:51,920 --> 00:16:54,480
goes wrong we can reconstruct many of

00:16:53,759 --> 00:16:57,120
the things

00:16:54,480 --> 00:16:57,120
that we had

00:16:57,600 --> 00:17:04,480
since five six there's a a new

00:17:01,360 --> 00:17:06,160
uh aid for replication which is called a

00:17:04,480 --> 00:17:08,640
global transaction ids

00:17:06,160 --> 00:17:10,799
and file and position are still the

00:17:08,640 --> 00:17:13,280
primary coordinates of the binary log

00:17:10,799 --> 00:17:14,959
but a global transaction id can make

00:17:13,280 --> 00:17:15,919
identifying these coordinates more

00:17:14,959 --> 00:17:18,240
easily

00:17:15,919 --> 00:17:19,439
so each transaction gets a unique

00:17:18,240 --> 00:17:21,520
identifier

00:17:19,439 --> 00:17:23,760
which is also written to the binary log

00:17:21,520 --> 00:17:26,240
and all the servers in the topology

00:17:23,760 --> 00:17:27,520
will keep track of the gtids they have

00:17:26,240 --> 00:17:31,440
executed

00:17:27,520 --> 00:17:33,360
and when a slave connects to a master

00:17:31,440 --> 00:17:34,640
so when a replica connects to an origin

00:17:33,360 --> 00:17:36,640
outer source

00:17:34,640 --> 00:17:38,000
um i still have to change the slide it

00:17:36,640 --> 00:17:40,559
seems uh the

00:17:38,000 --> 00:17:44,080
the uh the or the source server

00:17:40,559 --> 00:17:44,080
announced the list of gtids

00:17:44,240 --> 00:17:47,760
it has executed and the slave says this

00:17:46,640 --> 00:17:50,000
is what i have

00:17:47,760 --> 00:17:52,720
and so the difference between those two

00:17:50,000 --> 00:17:55,600
sets is what the replica will need

00:17:52,720 --> 00:17:57,120
um to from the master to to get itself

00:17:55,600 --> 00:17:59,360
up to date

00:17:57,120 --> 00:18:01,840
and this is one of the major breaking

00:17:59,360 --> 00:18:04,559
points where mysql and mariadb

00:18:01,840 --> 00:18:05,679
are no longer dropping replacements

00:18:04,559 --> 00:18:08,960
because they both have

00:18:05,679 --> 00:18:10,960
different implementation of gtid

00:18:08,960 --> 00:18:12,799
and so you cannot replicate from one to

00:18:10,960 --> 00:18:15,600
the other

00:18:12,799 --> 00:18:16,000
when you have gtids enabled and gta

00:18:15,600 --> 00:18:19,360
these

00:18:16,000 --> 00:18:20,480
do make your life a lot easier so i will

00:18:19,360 --> 00:18:23,440
quickly show you

00:18:20,480 --> 00:18:26,640
why this is a different so in mysql

00:18:23,440 --> 00:18:29,760
oracle mysql community edition

00:18:26,640 --> 00:18:30,240
gtid has the format of the server uuid

00:18:29,760 --> 00:18:33,280
which is

00:18:30,240 --> 00:18:34,080
the the uid like you like you can see

00:18:33,280 --> 00:18:36,799
here

00:18:34,080 --> 00:18:38,640
and then the sequence number and the the

00:18:36,799 --> 00:18:39,600
server uid is generated at initial

00:18:38,640 --> 00:18:43,039
startup

00:18:39,600 --> 00:18:44,080
and each transaction starts with the uid

00:18:43,039 --> 00:18:46,640
of the server

00:18:44,080 --> 00:18:48,000
where it originally occurs so if you run

00:18:46,640 --> 00:18:51,200
a query

00:18:48,000 --> 00:18:54,960
an insert an update to create whatever

00:18:51,200 --> 00:18:57,520
whenever it gets binary locked there's a

00:18:54,960 --> 00:19:00,320
a unique transaction number added to it

00:18:57,520 --> 00:19:02,640
and it uses the server uid of the server

00:19:00,320 --> 00:19:04,320
where that transaction happened and then

00:19:02,640 --> 00:19:05,760
there's an ever incrementing number of

00:19:04,320 --> 00:19:08,240
transactions executed

00:19:05,760 --> 00:19:09,120
which is called a sequence number and so

00:19:08,240 --> 00:19:11,760
you can have

00:19:09,120 --> 00:19:13,039
a gtid looking like this so you have the

00:19:11,760 --> 00:19:16,080
uid and then

00:19:13,039 --> 00:19:18,559
transaction number 23. you can

00:19:16,080 --> 00:19:20,240
sometimes people talk about gtid sets

00:19:18,559 --> 00:19:22,960
it's a collection of gtids

00:19:20,240 --> 00:19:24,000
so in this case it has the same source

00:19:22,960 --> 00:19:26,240
uuid

00:19:24,000 --> 00:19:28,640
but in this case you have transactions 1

00:19:26,240 --> 00:19:33,440
2 and 3 then transaction 11

00:19:28,640 --> 00:19:35,679
47 and 48 and 49 are in this gtid set

00:19:33,440 --> 00:19:37,600
and instead of specifying a master log

00:19:35,679 --> 00:19:39,360
file in the master lock position

00:19:37,600 --> 00:19:40,720
in the change master command you can now

00:19:39,360 --> 00:19:42,640
use

00:19:40,720 --> 00:19:44,160
master auto position equals one and then

00:19:42,640 --> 00:19:47,679
the server will figure out file and

00:19:44,160 --> 00:19:50,080
position based on the executed gtid sets

00:19:47,679 --> 00:19:52,960
now when you look at mariadb gti these

00:19:50,080 --> 00:19:56,160
are a total different form

00:19:52,960 --> 00:20:00,480
so mourinho b has

00:19:56,160 --> 00:20:02,880
basically three integer values x y and z

00:20:00,480 --> 00:20:04,480
and the x is the domain id and it

00:20:02,880 --> 00:20:06,080
usually defaults to one

00:20:04,480 --> 00:20:08,159
unless you have a multi-source

00:20:06,080 --> 00:20:09,600
replication where you have a replica

00:20:08,159 --> 00:20:12,720
from multiple masters

00:20:09,600 --> 00:20:15,360
multiple sources

00:20:12,720 --> 00:20:16,159
but in in most cases this will be just

00:20:15,360 --> 00:20:19,520
one so you

00:20:16,159 --> 00:20:21,120
you have only one there then the second

00:20:19,520 --> 00:20:23,760
number is the server id

00:20:21,120 --> 00:20:25,280
it's the unique id of the server where

00:20:23,760 --> 00:20:28,320
the transaction occurred instead of

00:20:25,280 --> 00:20:30,400
using something new uh like a uuid

00:20:28,320 --> 00:20:32,559
mariadb has chosen to use what was

00:20:30,400 --> 00:20:35,440
already there which is the server id

00:20:32,559 --> 00:20:36,480
and then the z the last number is

00:20:35,440 --> 00:20:39,200
basically

00:20:36,480 --> 00:20:40,320
the same as with mysql gt ids it's an

00:20:39,200 --> 00:20:42,720
ever incrementing

00:20:40,320 --> 00:20:42,720
value

00:20:45,440 --> 00:20:51,679
that you that you uh that that just

00:20:48,880 --> 00:20:52,559
auto increments on each transaction so

00:20:51,679 --> 00:20:55,280
there's a global

00:20:52,559 --> 00:20:57,120
variable called gtid slave bus and you

00:20:55,280 --> 00:20:58,159
can set this value when you load it in

00:20:57,120 --> 00:21:02,480
the server

00:20:58,159 --> 00:21:06,799
for example when you load a backup

00:21:02,480 --> 00:21:06,799
in the backup metadata there will be

00:21:07,200 --> 00:21:10,799
a slave position and you can you use

00:21:09,360 --> 00:21:12,720
change that value to

00:21:10,799 --> 00:21:15,280
to whatever your metadata if your backup

00:21:12,720 --> 00:21:17,760
says and once this is set

00:21:15,280 --> 00:21:20,000
you can use uh you have the option to

00:21:17,760 --> 00:21:22,559
use a master use gtid

00:21:20,000 --> 00:21:24,320
and you use a slave position in the

00:21:22,559 --> 00:21:26,960
change master command so you set

00:21:24,320 --> 00:21:28,320
a master use gtid equals slave position

00:21:26,960 --> 00:21:31,280
and then it will use the

00:21:28,320 --> 00:21:34,240
position that it has into its values

00:21:31,280 --> 00:21:37,440
from the metadata which you loaded

00:21:34,240 --> 00:21:40,799
um to start replicating um

00:21:37,440 --> 00:21:41,760
gtids are enabled uh by default uh since

00:21:40,799 --> 00:21:44,720
tenno

00:21:41,760 --> 00:21:46,720
10.0 and in an existing replication

00:21:44,720 --> 00:21:48,720
topology when you have replication

00:21:46,720 --> 00:21:50,159
running

00:21:48,720 --> 00:21:52,080
and everything is up to date you can

00:21:50,159 --> 00:21:54,320
just do stop slave change

00:21:52,080 --> 00:21:55,600
master 2 and then use gtid set to

00:21:54,320 --> 00:21:56,960
current position

00:21:55,600 --> 00:21:58,880
and then you just start slaving it

00:21:56,960 --> 00:22:01,360
continues from where it left off

00:21:58,880 --> 00:22:03,440
but from now on it will identify uh

00:22:01,360 --> 00:22:05,520
transactions using the gtid

00:22:03,440 --> 00:22:07,520
instead of just the file and position

00:22:05,520 --> 00:22:12,480
which will make it much easier

00:22:07,520 --> 00:22:15,760
to track where everything is in

00:22:12,480 --> 00:22:18,240
in your uh in your topology

00:22:15,760 --> 00:22:20,320
uh as i said in in the beginning

00:22:18,240 --> 00:22:23,360
replication is asynchronous so

00:22:20,320 --> 00:22:25,200
uh by default um it means that the

00:22:23,360 --> 00:22:26,799
source server executes a statement

00:22:25,200 --> 00:22:28,640
it writes it to the binary log as an

00:22:26,799 --> 00:22:30,799
event the replica

00:22:28,640 --> 00:22:32,080
has two threads it has an io thread and

00:22:30,799 --> 00:22:34,240
an sql thread

00:22:32,080 --> 00:22:35,280
and it pulls the source for new events

00:22:34,240 --> 00:22:37,200
constantly

00:22:35,280 --> 00:22:38,799
stores them locally in a relay log and

00:22:37,200 --> 00:22:40,960
then the replica has a threat

00:22:38,799 --> 00:22:42,159
that replays the relay lagoon's local

00:22:40,960 --> 00:22:44,400
data copy

00:22:42,159 --> 00:22:46,720
there are no guarantees that the replica

00:22:44,400 --> 00:22:49,760
will will be able to execute the event

00:22:46,720 --> 00:22:52,080
the table that it's trying to change

00:22:49,760 --> 00:22:53,760
might not be there there's no guarantees

00:22:52,080 --> 00:22:54,320
the master doesn't care about all of

00:22:53,760 --> 00:22:57,760
that

00:22:54,320 --> 00:22:59,760
or the source um

00:22:57,760 --> 00:23:02,960
and it's also there's also no guarantee

00:22:59,760 --> 00:23:06,480
when or how fast a replica will execute

00:23:02,960 --> 00:23:09,280
this event it can be immediate it can be

00:23:06,480 --> 00:23:10,480
an hour later it can be five hours later

00:23:09,280 --> 00:23:12,080
it all depends

00:23:10,480 --> 00:23:14,159
and that's what they call replication

00:23:12,080 --> 00:23:16,960
lag

00:23:14,159 --> 00:23:18,880
and so or delay and that is inherent to

00:23:16,960 --> 00:23:20,960
this principle of asynchronous

00:23:18,880 --> 00:23:23,520
there's no such thing as no replication

00:23:20,960 --> 00:23:26,080
lag in an ideal world you keep your

00:23:23,520 --> 00:23:28,640
application lag below one second

00:23:26,080 --> 00:23:30,880
that means that your servers are in sync

00:23:28,640 --> 00:23:32,559
but there will always be microseconds or

00:23:30,880 --> 00:23:36,000
milliseconds

00:23:32,559 --> 00:23:37,919
of replication delay in any asynchronous

00:23:36,000 --> 00:23:40,400
replication topology

00:23:37,919 --> 00:23:41,840
beyond asynchronous there's the option

00:23:40,400 --> 00:23:45,120
um

00:23:41,840 --> 00:23:46,720
to go semi-synchronous it's a plug-in to

00:23:45,120 --> 00:23:49,200
mysql and this

00:23:46,720 --> 00:23:50,240
helps to guarantee durability and

00:23:49,200 --> 00:23:52,720
semi-sink will

00:23:50,240 --> 00:23:54,000
only successfully commit a transaction

00:23:52,720 --> 00:23:57,039
on the source

00:23:54,000 --> 00:23:57,919
as long as at least at least one replica

00:23:57,039 --> 00:24:01,120
acknowledges

00:23:57,919 --> 00:24:03,360
that it has received the event so before

00:24:01,120 --> 00:24:05,279
actually getting written and persisted

00:24:03,360 --> 00:24:06,640
at least one replica has to acknowledge

00:24:05,279 --> 00:24:09,360
that it has received so

00:24:06,640 --> 00:24:10,799
the the source server will wait for that

00:24:09,360 --> 00:24:12,880
still there are no guarantees that it

00:24:10,799 --> 00:24:15,520
will be able to execute it

00:24:12,880 --> 00:24:16,320
but it is at least received there and

00:24:15,520 --> 00:24:19,360
the data is

00:24:16,320 --> 00:24:21,919
somewhere else also and in the

00:24:19,360 --> 00:24:23,279
best practice is to keep the slave as an

00:24:21,919 --> 00:24:26,799
identical copy

00:24:23,279 --> 00:24:28,960
and so if your gt ids match and you have

00:24:26,799 --> 00:24:30,720
a row based replication you can

00:24:28,960 --> 00:24:33,679
theoretically guarantee that the servers

00:24:30,720 --> 00:24:36,720
are in sync

00:24:33,679 --> 00:24:39,279
but there's more there are since

00:24:36,720 --> 00:24:41,600
bicycle 5.7 there's ionodb cluster and

00:24:39,279 --> 00:24:44,559
it's in high availability solution

00:24:41,600 --> 00:24:45,039
which is native to mysql it's available

00:24:44,559 --> 00:24:47,200
since

00:24:45,039 --> 00:24:48,320
seven but it's much improved in 80 so if

00:24:47,200 --> 00:24:52,640
you want to use

00:24:48,320 --> 00:24:55,200
indb cluster please use 80 do not go 457

00:24:52,640 --> 00:24:56,080
because most of the bug fixes and and

00:24:55,200 --> 00:24:59,840
features

00:24:56,080 --> 00:25:01,360
they are not present in in 5.7

00:24:59,840 --> 00:25:03,760
under the hood this uses technology

00:25:01,360 --> 00:25:06,960
called idb group replication

00:25:03,760 --> 00:25:08,720
and it it makes you

00:25:06,960 --> 00:25:10,960
make the cluster will work together as

00:25:08,720 --> 00:25:13,360
one logical entity instead of individual

00:25:10,960 --> 00:25:15,840
servers with asynchronous replication

00:25:13,360 --> 00:25:17,760
it uses a group communication system

00:25:15,840 --> 00:25:20,559
based on the pexas communication

00:25:17,760 --> 00:25:22,880
engine if you have questions please feel

00:25:20,559 --> 00:25:26,840
free to reach me on twitter

00:25:22,880 --> 00:25:29,840
thank you for being here and until next

00:25:26,840 --> 00:25:29,840
time

00:25:32,640 --> 00:25:34,720

YouTube URL: https://www.youtube.com/watch?v=yZMP2sk8qKI


