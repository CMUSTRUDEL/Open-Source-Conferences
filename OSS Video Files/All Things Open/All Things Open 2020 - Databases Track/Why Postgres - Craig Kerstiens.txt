Title: Why Postgres - Craig Kerstiens
Publication date: 2020-12-10
Playlist: All Things Open 2020 - Databases Track
Description: 
	Presented by: Craig Kerstiens, Crunchy Data
Presented at All Things Open 2020 - Databases Track

Abstract: Postgres is moving beyond it's olden days of being a stodgy relational database. Once upon a time SQL was doomed and relational databases were going to give way to more modern NoSQL data stores. Fast forward to today and Postgres has rich document support with JSONB, has full text search support, geospatial support, and even more. We'll take a look at where it came from, and what's in the box today. 

It'll be a whirlwind tour of all the shiny features that make it an ever more loved database.
Captions: 
	00:00:05,040 --> 00:00:09,440
a little bit of

00:00:05,759 --> 00:00:10,240
background on myself uh i've mostly been

00:00:09,440 --> 00:00:12,320
working with

00:00:10,240 --> 00:00:14,719
developer companies or data companies

00:00:12,320 --> 00:00:15,120
for the last a little over a decade or

00:00:14,719 --> 00:00:17,039
so

00:00:15,120 --> 00:00:18,400
i was a product manager back at heroku

00:00:17,039 --> 00:00:20,880
back in the day

00:00:18,400 --> 00:00:21,840
primarily built heroku postgres uh spent

00:00:20,880 --> 00:00:23,519
a lot of time

00:00:21,840 --> 00:00:26,160
uh launching a bunch of core languages

00:00:23,519 --> 00:00:27,760
there spent some time at cytus data that

00:00:26,160 --> 00:00:29,439
was acquired by microsoft and now at

00:00:27,760 --> 00:00:31,199
crunchy data running our recently

00:00:29,439 --> 00:00:33,600
launched cloud database

00:00:31,199 --> 00:00:35,040
if uh any of you are postgres fans

00:00:33,600 --> 00:00:36,239
already um

00:00:35,040 --> 00:00:38,960
may want to take a look at postpress

00:00:36,239 --> 00:00:42,480
weekly it's a weekly newsletter i curate

00:00:38,960 --> 00:00:42,960
uh really targeted at app devs not dbas

00:00:42,480 --> 00:00:44,800
not

00:00:42,960 --> 00:00:46,000
kind of the devops side but uh hey i

00:00:44,800 --> 00:00:47,920
want to learn about the cool features in

00:00:46,000 --> 00:00:49,760
postgres and leverage them

00:00:47,920 --> 00:00:51,280
it's usually about five to ten articles

00:00:49,760 --> 00:00:53,760
each week so

00:00:51,280 --> 00:00:54,719
not too much to get through overall um

00:00:53,760 --> 00:00:57,280
but for those of you

00:00:54,719 --> 00:00:58,879
that maybe aren't postgres fans um

00:00:57,280 --> 00:01:00,719
hopefully there's a few of you here so i

00:00:58,879 --> 00:01:02,719
can change your mind throughout

00:01:00,719 --> 00:01:04,960
we're going to go into a a kind of

00:01:02,719 --> 00:01:06,400
whirlwind tour of what's in postgres

00:01:04,960 --> 00:01:08,640
why it's interesting what makes it

00:01:06,400 --> 00:01:12,560
unique against other databases

00:01:08,640 --> 00:01:15,600
so first a little bit of history uh

00:01:12,560 --> 00:01:18,320
postgres was released in 1989

00:01:15,600 --> 00:01:19,200
uh that's that's over 30 years now it's

00:01:18,320 --> 00:01:22,720
really old

00:01:19,200 --> 00:01:23,840
uh it has a lot of roots as um like the

00:01:22,720 --> 00:01:26,880
grandfathers of

00:01:23,840 --> 00:01:28,880
databases so if you look at its name

00:01:26,880 --> 00:01:30,640
it means post ingress it came out of uc

00:01:28,880 --> 00:01:32,000
berkeley ingress was one of the early

00:01:30,640 --> 00:01:33,840
databases there

00:01:32,000 --> 00:01:35,920
a number of databases are based off

00:01:33,840 --> 00:01:39,840
ingress i think it's db2

00:01:35,920 --> 00:01:41,520
um i'd have to check maybe cybase

00:01:39,840 --> 00:01:44,240
i don't believe oracle has roots there

00:01:41,520 --> 00:01:45,280
but sql server does so a lot of

00:01:44,240 --> 00:01:47,920
databases come back

00:01:45,280 --> 00:01:49,759
out of the same core postgres didn't

00:01:47,920 --> 00:01:52,320
pick up the sql part till later

00:01:49,759 --> 00:01:53,520
but still that core database is over 30

00:01:52,320 --> 00:01:54,880
years old

00:01:53,520 --> 00:01:56,880
it generally takes quite a while to

00:01:54,880 --> 00:01:58,159
mature a relational database and

00:01:56,880 --> 00:02:01,680
when you're building on postgres you're

00:01:58,159 --> 00:02:04,799
building on a pretty solid foundation

00:02:01,680 --> 00:02:07,119
another little bit into the archives

00:02:04,799 --> 00:02:07,840
tom lane is a top contributor to

00:02:07,119 --> 00:02:10,959
postgres

00:02:07,840 --> 00:02:12,080
and a whole lot of open source um he

00:02:10,959 --> 00:02:16,239
helped create

00:02:12,080 --> 00:02:18,239
jpeg tiff uh png uh

00:02:16,239 --> 00:02:19,920
worked on those specs co-authored lib

00:02:18,239 --> 00:02:21,599
jpeg libpng

00:02:19,920 --> 00:02:23,040
and then about 20 years ago he got bored

00:02:21,599 --> 00:02:24,400
with image formats and said hey what's

00:02:23,040 --> 00:02:27,680
this database thing i'm going to give my

00:02:24,400 --> 00:02:31,120
my hand edit

00:02:27,680 --> 00:02:32,160
and uh this is one of the most common

00:02:31,120 --> 00:02:34,560
mistakes i see made

00:02:32,160 --> 00:02:36,000
is uh it's kind of a fun email from the

00:02:34,560 --> 00:02:39,440
the mailing list

00:02:36,000 --> 00:02:41,200
uh almost coming up on 25 years now

00:02:39,440 --> 00:02:41,920
we're saying hey we made a big mistake

00:02:41,200 --> 00:02:44,640
we shouldn't have

00:02:41,920 --> 00:02:46,160
you know added the sequel on the end of

00:02:44,640 --> 00:02:48,080
it when we added support for sql we

00:02:46,160 --> 00:02:50,959
should have just left it postgres

00:02:48,080 --> 00:02:52,800
um that's the easiest way to not butcher

00:02:50,959 --> 00:02:55,200
the pronunciation just call it postgres

00:02:52,800 --> 00:02:56,480
um the other acceptable form is

00:02:55,200 --> 00:02:59,599
postgresql

00:02:56,480 --> 00:02:59,599
not postgresql

00:03:00,560 --> 00:03:05,120
so under the covers postgres is just a

00:03:03,200 --> 00:03:08,080
giant append only log

00:03:05,120 --> 00:03:09,440
um when you write data it adds data to

00:03:08,080 --> 00:03:11,120
the log so if you think about

00:03:09,440 --> 00:03:13,280
updating a new record what it does is

00:03:11,120 --> 00:03:15,120
essentially mark that record as sturdied

00:03:13,280 --> 00:03:16,400
and then it writes a new one when you

00:03:15,120 --> 00:03:18,239
delete a record

00:03:16,400 --> 00:03:20,159
it actually just marks that as 30 and

00:03:18,239 --> 00:03:21,599
comes through later and cleans that up

00:03:20,159 --> 00:03:23,599
um this is helpful when you look at

00:03:21,599 --> 00:03:24,400
things like vacuum and bloat and that

00:03:23,599 --> 00:03:25,680
sort of thing

00:03:24,400 --> 00:03:27,680
but you really can just think of

00:03:25,680 --> 00:03:29,280
postgres as one appendedly log and

00:03:27,680 --> 00:03:30,840
underneath there's a

00:03:29,280 --> 00:03:33,120
actual log file called the right ahead

00:03:30,840 --> 00:03:36,400
log which is useful for things like

00:03:33,120 --> 00:03:36,400
disaster recovery and otherwise

00:03:37,040 --> 00:03:40,879
so stepping back and pausing for a

00:03:39,440 --> 00:03:43,840
minute um

00:03:40,879 --> 00:03:46,239
you know there's a lot of talks at this

00:03:43,840 --> 00:03:47,040
conference about open source and there's

00:03:46,239 --> 00:03:48,239
going to be people that are going to

00:03:47,040 --> 00:03:50,400
debate licenses

00:03:48,239 --> 00:03:52,000
and debate you know how do we leverage

00:03:50,400 --> 00:03:54,560
open source what's the you know

00:03:52,000 --> 00:03:57,120
way to be a good steward how do you give

00:03:54,560 --> 00:03:58,879
back in the right way

00:03:57,120 --> 00:04:00,239
to me open source is a really really

00:03:58,879 --> 00:04:01,120
loaded term and i don't want to get into

00:04:00,239 --> 00:04:02,959
that i'm sure there's going to be a

00:04:01,120 --> 00:04:04,799
bunch of talks that cover that

00:04:02,959 --> 00:04:06,159
but what is interesting i think is is

00:04:04,799 --> 00:04:09,519
postgres

00:04:06,159 --> 00:04:11,439
is unique as open source um open

00:04:09,519 --> 00:04:13,280
source just means hey the code is open

00:04:11,439 --> 00:04:16,160
you can take read it

00:04:13,280 --> 00:04:16,560
change it possibly do something with it

00:04:16,160 --> 00:04:18,560
um

00:04:16,560 --> 00:04:20,160
postpress goes one step further where

00:04:18,560 --> 00:04:23,360
it's actually community-led

00:04:20,160 --> 00:04:25,680
community-run community-owned

00:04:23,360 --> 00:04:26,479
if you look at something like a mysql or

00:04:25,680 --> 00:04:29,280


00:04:26,479 --> 00:04:30,800
open source yet they're still own and

00:04:29,280 --> 00:04:32,560
run by a single company

00:04:30,800 --> 00:04:34,400
whereas postgrads it's a little bit

00:04:32,560 --> 00:04:37,040
different um

00:04:34,400 --> 00:04:37,840
it's probably more similar to linux with

00:04:37,040 --> 00:04:40,320
no

00:04:37,840 --> 00:04:42,400
benevolent dictator there's a core team

00:04:40,320 --> 00:04:44,479
which is really just a small steering

00:04:42,400 --> 00:04:46,800
committee they handle things like

00:04:44,479 --> 00:04:50,160
licensing non-code items but

00:04:46,800 --> 00:04:51,199
um it's that team is split up there's no

00:04:50,160 --> 00:04:53,360
more than

00:04:51,199 --> 00:04:54,479
two people from one company on on the

00:04:53,360 --> 00:04:56,800
core team

00:04:54,479 --> 00:04:58,000
you've got a whole bunch of committers

00:04:56,800 --> 00:04:59,199
uh it takes a while to get your

00:04:58,000 --> 00:05:00,639
commitment to postgres it's not

00:04:59,199 --> 00:05:01,039
something you're doing in a week or two

00:05:00,639 --> 00:05:04,080
it's a

00:05:01,039 --> 00:05:05,120
multi-year project um that's just the

00:05:04,080 --> 00:05:07,440
ability to commit

00:05:05,120 --> 00:05:08,400
a patch you've got major contributors

00:05:07,440 --> 00:05:09,919
that will write

00:05:08,400 --> 00:05:11,440
major features but not actually have

00:05:09,919 --> 00:05:13,199
that commitment

00:05:11,440 --> 00:05:14,639
committers tend to show up and take a

00:05:13,199 --> 00:05:15,840
while to get there but then stick around

00:05:14,639 --> 00:05:17,280
for quite a while

00:05:15,840 --> 00:05:18,479
and you've got minor contributors as

00:05:17,280 --> 00:05:21,120
well you know someone that's written

00:05:18,479 --> 00:05:21,120
something small

00:05:21,360 --> 00:05:25,520
not kind of a headline feature but but

00:05:23,120 --> 00:05:28,880
added a nice feature to postgres

00:05:25,520 --> 00:05:30,240
um features get contributed based on

00:05:28,880 --> 00:05:32,720
what engineers want to work on

00:05:30,240 --> 00:05:34,400
it's not driven by large companies now

00:05:32,720 --> 00:05:36,240
those committers are distributed across

00:05:34,400 --> 00:05:38,880
a whole bunch of companies

00:05:36,240 --> 00:05:40,560
it's not just a you know amazon and

00:05:38,880 --> 00:05:43,600
google and microsoft where hey

00:05:40,560 --> 00:05:45,039
the project came out of there um it's

00:05:43,600 --> 00:05:47,360
quite a global team

00:05:45,039 --> 00:05:48,560
um i would venture to say there's

00:05:47,360 --> 00:05:50,479
probably at least

00:05:48,560 --> 00:05:52,400
representation of 20 different companies

00:05:50,479 --> 00:05:55,440
there but i'd have to check

00:05:52,400 --> 00:05:57,440
um activity happenings on the mailing

00:05:55,440 --> 00:05:58,880
lists

00:05:57,440 --> 00:06:01,199
if you want to go and learn about

00:05:58,880 --> 00:06:03,120
postgres the pg sql users

00:06:01,199 --> 00:06:05,360
mailing list is a good one to go and

00:06:03,120 --> 00:06:06,720
read there's people looking at debugging

00:06:05,360 --> 00:06:09,280
and that sort of thing

00:06:06,720 --> 00:06:11,440
um if you want to fall asleep at night

00:06:09,280 --> 00:06:12,240
the pg sql hackers list is where i would

00:06:11,440 --> 00:06:14,960
go

00:06:12,240 --> 00:06:16,720
um that's where the internal development

00:06:14,960 --> 00:06:19,600
happens people show up with patches

00:06:16,720 --> 00:06:20,800
deep debugging that sort of thing um if

00:06:19,600 --> 00:06:24,400
you want to learn about the interns of

00:06:20,800 --> 00:06:24,400
postgres it's a fascinating read

00:06:24,800 --> 00:06:31,840
uh so really quickly um

00:06:28,880 --> 00:06:34,479
i uh i'm a fan of p sequel it's the

00:06:31,840 --> 00:06:37,440
command line that ships with postgres

00:06:34,479 --> 00:06:39,840
uh if you work on a command line much

00:06:37,440 --> 00:06:41,759
you probably have like a bash rc set up

00:06:39,840 --> 00:06:43,919
uh with p sequel you can do the exact

00:06:41,759 --> 00:06:45,680
same thing and have like custom commands

00:06:43,919 --> 00:06:46,960
set up automatically that are really

00:06:45,680 --> 00:06:49,599
useful and helpful and

00:06:46,960 --> 00:06:51,039
will give you more power one really

00:06:49,599 --> 00:06:52,560
handy one is timing

00:06:51,039 --> 00:06:54,240
this will automatically report the

00:06:52,560 --> 00:06:55,440
timing that it takes when you every time

00:06:54,240 --> 00:06:58,800
you run a query

00:06:55,440 --> 00:07:00,319
uh backslash x auto uh it's really nice

00:06:58,800 --> 00:07:02,800
for auto formatting the

00:07:00,319 --> 00:07:04,400
the text on your screen backslash watch

00:07:02,800 --> 00:07:05,840
we'll just re-run your query and output

00:07:04,400 --> 00:07:07,120
that result every two seconds so if

00:07:05,840 --> 00:07:07,599
you're running a query and want to wait

00:07:07,120 --> 00:07:09,840
and see

00:07:07,599 --> 00:07:10,880
for the results to change really really

00:07:09,840 --> 00:07:13,759
handy

00:07:10,880 --> 00:07:14,960
if you do backslash e it'll open up the

00:07:13,759 --> 00:07:16,880
query that you're working on

00:07:14,960 --> 00:07:18,479
in your default editor you could

00:07:16,880 --> 00:07:20,479
actually set this up as like a

00:07:18,479 --> 00:07:22,080
sublime text or vs code or something

00:07:20,479 --> 00:07:24,639
like that it'll auto

00:07:22,080 --> 00:07:25,120
open that query when you close and save

00:07:24,639 --> 00:07:26,800
that

00:07:25,120 --> 00:07:28,560
it'll pipe that back to psql and

00:07:26,800 --> 00:07:30,160
automatically run that so if you don't

00:07:28,560 --> 00:07:30,960
want to work in the cli for editing your

00:07:30,160 --> 00:07:32,800
sql

00:07:30,960 --> 00:07:34,240
just set up your editor environment

00:07:32,800 --> 00:07:37,440
variable and use backslash e

00:07:34,240 --> 00:07:40,720
really really handy so

00:07:37,440 --> 00:07:41,759
when i think about postgres um i like to

00:07:40,720 --> 00:07:44,800
steal this term

00:07:41,759 --> 00:07:47,039
from the django community uh

00:07:44,800 --> 00:07:48,720
i like django it's a nice web framework

00:07:47,039 --> 00:07:50,240
um and they have this logo i think

00:07:48,720 --> 00:07:52,000
they're starting to do away with it more

00:07:50,240 --> 00:07:53,599
but they had this logo for years called

00:07:52,000 --> 00:07:56,080
you know batteries included

00:07:53,599 --> 00:07:58,400
and the idea was everything you needed

00:07:56,080 --> 00:08:00,160
to get up and running with the web app

00:07:58,400 --> 00:08:01,599
you didn't have to go grab anything else

00:08:00,160 --> 00:08:02,960
off the shelf you needed authentication

00:08:01,599 --> 00:08:05,120
you needed session management

00:08:02,960 --> 00:08:07,280
csrf projection you needed an admin

00:08:05,120 --> 00:08:08,560
screen all these things that you would

00:08:07,280 --> 00:08:09,680
need in building a web app that were

00:08:08,560 --> 00:08:10,879
really common

00:08:09,680 --> 00:08:12,160
well they were there in the framework

00:08:10,879 --> 00:08:14,639
itself you didn't have to go grab them

00:08:12,160 --> 00:08:17,039
for something else

00:08:14,639 --> 00:08:18,479
and when i look at postgres it's really

00:08:17,039 --> 00:08:19,599
really rich and we're going to get try

00:08:18,479 --> 00:08:20,319
to get through a lot of this really

00:08:19,599 --> 00:08:22,000
quickly

00:08:20,319 --> 00:08:24,240
there's a rich set of data types which

00:08:22,000 --> 00:08:27,680
is really useful in and of its own

00:08:24,240 --> 00:08:29,759
regard rich indexing um there's

00:08:27,680 --> 00:08:31,199
more batteries there there's extensions

00:08:29,759 --> 00:08:32,240
foreign data wrappers so we're gonna get

00:08:31,199 --> 00:08:33,680
through

00:08:32,240 --> 00:08:35,360
hopefully most of this it's gonna be

00:08:33,680 --> 00:08:37,519
kind of a whirlwind tour

00:08:35,360 --> 00:08:38,719
um but it'll give you you know hopefully

00:08:37,519 --> 00:08:39,919
something you didn't know about even if

00:08:38,719 --> 00:08:40,719
you know a little bit about postgres

00:08:39,919 --> 00:08:42,000
already

00:08:40,719 --> 00:08:44,000
and then you can go and kind of dig in

00:08:42,000 --> 00:08:47,519
deeper from there

00:08:44,000 --> 00:08:47,519
so first on data types

00:08:50,480 --> 00:08:55,519
postgres has a really open liberal

00:08:53,440 --> 00:08:57,120
approach to adding data types

00:08:55,519 --> 00:08:58,640
it's not we've got our five data types

00:08:57,120 --> 00:09:00,399
and that's all we ever need

00:08:58,640 --> 00:09:02,000
uh they'll come in and add things like

00:09:00,399 --> 00:09:05,360
time stamps um

00:09:02,000 --> 00:09:08,000
you know shapes for geospatial stuff

00:09:05,360 --> 00:09:09,519
range types is really useful um

00:09:08,000 --> 00:09:11,200
basically you'll see a new data type

00:09:09,519 --> 00:09:12,800
appear every couple years in postgres

00:09:11,200 --> 00:09:14,640
and for the early years there are a lot

00:09:12,800 --> 00:09:17,760
showing up really quickly

00:09:14,640 --> 00:09:18,800
uh a few to highlight um i'm gonna start

00:09:17,760 --> 00:09:22,320
on a bad one

00:09:18,800 --> 00:09:24,959
money just don't use it uh

00:09:22,320 --> 00:09:26,720
it's not great about precision um it

00:09:24,959 --> 00:09:29,040
only really knows a single currency

00:09:26,720 --> 00:09:29,760
so you you know if you are working in a

00:09:29,040 --> 00:09:32,000
global sense

00:09:29,760 --> 00:09:33,839
not quite so useful there um the

00:09:32,000 --> 00:09:35,600
precision is not as good

00:09:33,839 --> 00:09:37,040
most modern frameworks don't use the

00:09:35,600 --> 00:09:38,560
money data type

00:09:37,040 --> 00:09:40,959
it's one that admittedly should be done

00:09:38,560 --> 00:09:44,000
away with but uh it's there

00:09:40,959 --> 00:09:46,160
people use it i'd stay away from it

00:09:44,000 --> 00:09:47,839
um serial here's one that if you're

00:09:46,160 --> 00:09:50,320
using uh

00:09:47,839 --> 00:09:52,000
unique identifiers for primary keys i

00:09:50,320 --> 00:09:53,839
would actually say skip it

00:09:52,000 --> 00:09:56,080
a lot of people really like it it's an

00:09:53,839 --> 00:09:58,720
auto incrementing primary key

00:09:56,080 --> 00:10:00,959
it has some limits if you use a bigot

00:09:58,720 --> 00:10:02,800
you're in a better shape here

00:10:00,959 --> 00:10:04,079
personally i really like uuids which

00:10:02,800 --> 00:10:07,440
postgres has a

00:10:04,079 --> 00:10:09,600
built-in type for um

00:10:07,440 --> 00:10:11,279
the purists of postgres will disagree

00:10:09,600 --> 00:10:12,959
with me here saying oh no it's a little

00:10:11,279 --> 00:10:14,880
bit larger to index

00:10:12,959 --> 00:10:17,279
if you're not at instagram tick tock

00:10:14,880 --> 00:10:20,640
facebook scale you're absolutely fine

00:10:17,279 --> 00:10:22,640
um i've run many large scale database

00:10:20,640 --> 00:10:25,680
into literally the hundreds of terabytes

00:10:22,640 --> 00:10:27,600
and uuids work great for primary keys

00:10:25,680 --> 00:10:29,680
as you start to expose these in places

00:10:27,600 --> 00:10:31,440
for like urls and otherwise

00:10:29,680 --> 00:10:32,720
then you're not leaking the ids it's a

00:10:31,440 --> 00:10:34,079
really kind of nice way

00:10:32,720 --> 00:10:35,920
it's not saying you don't secure things

00:10:34,079 --> 00:10:39,440
there but it's hey you're not leaking a

00:10:35,920 --> 00:10:39,440
little bit of information which is nice

00:10:39,920 --> 00:10:45,600
there's a whole set of shapes there's

00:10:42,560 --> 00:10:47,680
boxes there's polygons there's points

00:10:45,600 --> 00:10:49,279
you can use these basic ones for really

00:10:47,680 --> 00:10:50,959
really short hey what's the distance

00:10:49,279 --> 00:10:52,640
from this point to this point

00:10:50,959 --> 00:10:55,279
um there's a handy function earth

00:10:52,640 --> 00:10:57,680
distance for that you also have postgis

00:10:55,279 --> 00:11:00,000
which we'll talk about in a little bit

00:10:57,680 --> 00:11:01,279
not in crazy detail because it's we can

00:11:00,000 --> 00:11:03,360
go pretty deep on it

00:11:01,279 --> 00:11:05,680
um but we'll definitely hit on it a

00:11:03,360 --> 00:11:05,680
little bit

00:11:06,880 --> 00:11:11,920
so xml this is a really fun one and i'm

00:11:09,760 --> 00:11:14,880
entirely just kidding here

00:11:11,920 --> 00:11:15,600
except for um when i talk with some of

00:11:14,880 --> 00:11:18,240
the

00:11:15,600 --> 00:11:19,839
the database kind of graveyard people

00:11:18,240 --> 00:11:23,920
that have been working on the system for

00:11:19,839 --> 00:11:24,399
truly 20 30 years um i had conversations

00:11:23,920 --> 00:11:27,600
with them

00:11:24,399 --> 00:11:31,360
about 10 years ago now about json

00:11:27,600 --> 00:11:34,240
and and json came to postgres in 9.2

00:11:31,360 --> 00:11:35,680
in 9.2 we kind of cheated don't tell

00:11:34,240 --> 00:11:38,959
anyone but we did

00:11:35,680 --> 00:11:40,880
we validated json as it came in and

00:11:38,959 --> 00:11:44,079
shoved it into a text field

00:11:40,880 --> 00:11:46,399
there is no extra kind of compression or

00:11:44,079 --> 00:11:48,240
what normally comes with json it was

00:11:46,399 --> 00:11:50,160
literally we validated that it was valid

00:11:48,240 --> 00:11:51,519
json as it came in and shoved it at a

00:11:50,160 --> 00:11:54,079
text field

00:11:51,519 --> 00:11:54,560
white space and all a couple years later

00:11:54,079 --> 00:11:57,279
we got

00:11:54,560 --> 00:11:58,800
json b my colleague says the b stands

00:11:57,279 --> 00:12:00,959
for better

00:11:58,800 --> 00:12:02,880
but it's a binary representation on disk

00:12:00,959 --> 00:12:05,360
this is much more of what you get with

00:12:02,880 --> 00:12:06,639
manga where it's compressed you can

00:12:05,360 --> 00:12:08,720
index into it

00:12:06,639 --> 00:12:10,639
you usually want json b when you're

00:12:08,720 --> 00:12:12,320
using json in an application

00:12:10,639 --> 00:12:13,680
but 10 years ago i was having a

00:12:12,320 --> 00:12:15,600
conversation with one of the people that

00:12:13,680 --> 00:12:17,760
contributes to postgres and they said

00:12:15,600 --> 00:12:19,440
oh yeah json it's going to come and go

00:12:17,760 --> 00:12:21,680
i've seen this before

00:12:19,440 --> 00:12:23,200
there was a time 20 years ago when

00:12:21,680 --> 00:12:24,079
document databases were going to take

00:12:23,200 --> 00:12:26,880
over the world

00:12:24,079 --> 00:12:28,000
and we have these xml single built

00:12:26,880 --> 00:12:30,399
databases

00:12:28,000 --> 00:12:31,920
and uh they're like yeah we added xml

00:12:30,399 --> 00:12:34,720
now we've got to maintain it and it's

00:12:31,920 --> 00:12:36,160
annoying and no one uses it

00:12:34,720 --> 00:12:38,000
i think they i'm glad they saw the light

00:12:36,160 --> 00:12:40,399
on json json much

00:12:38,000 --> 00:12:41,519
much more broadly useful obviously

00:12:40,399 --> 00:12:42,639
hopefully some people out there are

00:12:41,519 --> 00:12:44,880
using it

00:12:42,639 --> 00:12:45,760
i use it in almost every application

00:12:44,880 --> 00:12:46,880
it's really useful

00:12:45,760 --> 00:12:48,959
when you just want to have some extra

00:12:46,880 --> 00:12:49,920
data or some flexibility there the fact

00:12:48,959 --> 00:12:53,120
that you can index

00:12:49,920 --> 00:12:56,560
all the keys and values within it

00:12:53,120 --> 00:12:58,720
really really really handy there

00:12:56,560 --> 00:12:59,839
but uh personally i do claim that with

00:12:58,720 --> 00:13:03,360
xml coming

00:12:59,839 --> 00:13:05,839
uh 15 years ago 20 years ago or so in

00:13:03,360 --> 00:13:07,600
postgres it was technically a document

00:13:05,839 --> 00:13:08,959
database way back then so it was the

00:13:07,600 --> 00:13:12,240
first document database that's still

00:13:08,959 --> 00:13:12,240
around today is my claim

00:13:15,279 --> 00:13:22,480
so a few other ones uh time stamps

00:13:18,959 --> 00:13:25,760
uh with time zone really useful we'll do

00:13:22,480 --> 00:13:27,600
a basic uh time zone conversion for you

00:13:25,760 --> 00:13:29,120
really handy when you know you know

00:13:27,600 --> 00:13:31,040
connecting in one place and want to know

00:13:29,120 --> 00:13:33,920
what time it is versus another place

00:13:31,040 --> 00:13:35,680
um it'll save the state based on hey

00:13:33,920 --> 00:13:37,760
your web server where it connects

00:13:35,680 --> 00:13:39,920
where's it running at that sort of thing

00:13:37,760 --> 00:13:41,040
really really useful for basic time zone

00:13:39,920 --> 00:13:44,160
math

00:13:41,040 --> 00:13:45,760
um intervals really handy when you're

00:13:44,160 --> 00:13:48,000
saying hey i want to see all the users

00:13:45,760 --> 00:13:49,600
that have signed up in the last hour you

00:13:48,000 --> 00:13:51,360
can grab now which is a literal

00:13:49,600 --> 00:13:53,839
and it'll basically you know grab the

00:13:51,360 --> 00:13:54,720
time for now and subtract one hour as an

00:13:53,839 --> 00:13:57,279
interval from it

00:13:54,720 --> 00:13:58,959
you can do minutes days etc really

00:13:57,279 --> 00:14:00,639
really handy and you know

00:13:58,959 --> 00:14:03,040
quick reporting for hey users that have

00:14:00,639 --> 00:14:05,839
signed up in the last week

00:14:03,040 --> 00:14:07,199
array is really useful i'm a big fan of

00:14:05,839 --> 00:14:09,600
if i'm using a data type in my

00:14:07,199 --> 00:14:11,279
application can i use it in my database

00:14:09,600 --> 00:14:13,440
uh arrays are useful for things like

00:14:11,279 --> 00:14:17,120
tags um

00:14:13,440 --> 00:14:18,240
if you want a you know tags categories

00:14:17,120 --> 00:14:19,519
that sort of thing

00:14:18,240 --> 00:14:22,079
really handy without having to join

00:14:19,519 --> 00:14:24,880
against a whole other table

00:14:22,079 --> 00:14:26,240
range types are a special purpose type

00:14:24,880 --> 00:14:27,600
of array

00:14:26,240 --> 00:14:29,440
they have a start and they have an n

00:14:27,600 --> 00:14:30,000
value they can be open-ended so it can

00:14:29,440 --> 00:14:32,240
be a start with

00:14:30,000 --> 00:14:34,800
no end but if you're doing anything with

00:14:32,240 --> 00:14:37,760
calendaring this is really really useful

00:14:34,800 --> 00:14:38,560
you can set um constraints then so that

00:14:37,760 --> 00:14:40,240
hey

00:14:38,560 --> 00:14:41,680
we're only allowed to have 30 people

00:14:40,240 --> 00:14:43,440
attend the talk at a time because we've

00:14:41,680 --> 00:14:44,079
only got 30 seats when we eventually can

00:14:43,440 --> 00:14:46,959
go back

00:14:44,079 --> 00:14:48,399
to a room with chairs and so people can

00:14:46,959 --> 00:14:49,600
register for this and then as soon as

00:14:48,399 --> 00:14:52,399
that person you know

00:14:49,600 --> 00:14:53,680
registers above that 30 mark great but

00:14:52,399 --> 00:14:56,399
they also can't register

00:14:53,680 --> 00:14:57,920
for overlapping uh talks at the same

00:14:56,399 --> 00:14:59,440
time you know they can't occupy two

00:14:57,920 --> 00:15:01,360
seats so they've got to pick hey

00:14:59,440 --> 00:15:02,880
if this overlaps another range that

00:15:01,360 --> 00:15:04,240
you're signed up for

00:15:02,880 --> 00:15:06,880
you know if you're a college scheduling

00:15:04,240 --> 00:15:08,480
application this is really really useful

00:15:06,880 --> 00:15:10,399
because otherwise you can get race

00:15:08,480 --> 00:15:13,839
conditions here which get pretty hard to

00:15:10,399 --> 00:15:13,839
clean up

00:15:14,560 --> 00:15:18,720
so uh if you're using an applique a data

00:15:17,600 --> 00:15:20,399
type in your application

00:15:18,720 --> 00:15:22,000
i highly recommend take a look and see

00:15:20,399 --> 00:15:23,600
if there's a postgres data type it's

00:15:22,000 --> 00:15:26,399
really really useful if you think oh i

00:15:23,600 --> 00:15:28,480
wonder if it's there it probably is

00:15:26,399 --> 00:15:29,920
it'll be performant it'll give you extra

00:15:28,480 --> 00:15:30,399
functionality when leveraging and

00:15:29,920 --> 00:15:34,160
querying

00:15:30,399 --> 00:15:34,160
it really really really handy

00:15:35,040 --> 00:15:41,759
all right onto indexing postgres

00:15:38,800 --> 00:15:43,279
has a lot of indexes most databases

00:15:41,759 --> 00:15:44,880
you'll just see one type

00:15:43,279 --> 00:15:47,279
postgres seems to show up with a new

00:15:44,880 --> 00:15:48,399
index type about every year and every

00:15:47,279 --> 00:15:51,440
year and a half kind of

00:15:48,399 --> 00:15:53,120
um some years we'll skip one and it's

00:15:51,440 --> 00:15:54,959
the second year but

00:15:53,120 --> 00:15:56,240
it seems to be almost a new index type

00:15:54,959 --> 00:15:59,279
every year

00:15:56,240 --> 00:16:00,000
um if you go through the docs and you

00:15:59,279 --> 00:16:02,160
read this

00:16:00,000 --> 00:16:03,920
uh your reaction is probably a little

00:16:02,160 --> 00:16:05,839
like this

00:16:03,920 --> 00:16:07,279
i've read the docs it took me a little

00:16:05,839 --> 00:16:08,880
while to get the

00:16:07,279 --> 00:16:10,320
the dumbed down version that i could

00:16:08,880 --> 00:16:12,240
understand of you know when to use all

00:16:10,320 --> 00:16:13,279
these indexes and i'm still not perfect

00:16:12,240 --> 00:16:16,720
on it

00:16:13,279 --> 00:16:18,480
um usually

00:16:16,720 --> 00:16:20,880
uh if you're doing standard text

00:16:18,480 --> 00:16:23,680
standard numbers just really basic

00:16:20,880 --> 00:16:24,800
column types um you just want something

00:16:23,680 --> 00:16:26,320
to go faster

00:16:24,800 --> 00:16:28,560
this is probably what you want a b3

00:16:26,320 --> 00:16:29,600
index this is what you learn about in cs

00:16:28,560 --> 00:16:30,720
school

00:16:29,600 --> 00:16:32,880
you don't know any better if you just

00:16:30,720 --> 00:16:33,839
say create index this is what you get

00:16:32,880 --> 00:16:35,680
and it's usually

00:16:33,839 --> 00:16:37,519
okay it's when you start to leverage

00:16:35,680 --> 00:16:39,360
more of the other data types or you have

00:16:37,519 --> 00:16:40,959
really large data and complex problems

00:16:39,360 --> 00:16:43,279
that you want to dive a little bit

00:16:40,959 --> 00:16:43,279
deeper

00:16:44,240 --> 00:16:51,360
a gen index a generalized inverted index

00:16:47,839 --> 00:16:53,279
really useful for arrays json so anytime

00:16:51,360 --> 00:16:55,120
i create a json b

00:16:53,279 --> 00:16:57,199
data type i usually go through a gen

00:16:55,120 --> 00:16:58,800
index on it that's going to index all my

00:16:57,199 --> 00:17:00,000
keys and values so when i query it's

00:16:58,800 --> 00:17:01,920
going to be able to use that index

00:17:00,000 --> 00:17:03,440
instead of scanning all of that text and

00:17:01,920 --> 00:17:05,919
parsing it out

00:17:03,440 --> 00:17:07,600
um really useful basically anytime you

00:17:05,919 --> 00:17:08,880
have multiple values in a single column

00:17:07,600 --> 00:17:11,039
right so in arrays you could have

00:17:08,880 --> 00:17:12,720
multiple categories in json you've got

00:17:11,039 --> 00:17:18,079
you know multiple keys and values and it

00:17:12,720 --> 00:17:21,120
can get pretty well nested there

00:17:18,079 --> 00:17:22,559
just uh really useful for full text

00:17:21,120 --> 00:17:23,839
search and shapes

00:17:22,559 --> 00:17:25,919
if you think about it when you've got

00:17:23,839 --> 00:17:28,960
values that span across a boundary

00:17:25,919 --> 00:17:29,919
so if you've got like polygons that uh

00:17:28,960 --> 00:17:31,520
have different

00:17:29,919 --> 00:17:33,120
shapes and you can have points within

00:17:31,520 --> 00:17:34,000
the polygon points with out of the

00:17:33,120 --> 00:17:35,440
polygon right

00:17:34,000 --> 00:17:37,760
and you want to know where does a point

00:17:35,440 --> 00:17:39,919
fall does it fall in that polygon or out

00:17:37,760 --> 00:17:41,360
uh just is really useful for that kind

00:17:39,919 --> 00:17:42,640
of thing um

00:17:41,360 --> 00:17:44,000
full text search where you've got

00:17:42,640 --> 00:17:45,600
paragraphs and paragraphs and you want

00:17:44,000 --> 00:17:46,000
to index all of it but you only want to

00:17:45,600 --> 00:17:49,360
search

00:17:46,000 --> 00:17:52,799
for certain parts of speech

00:17:49,360 --> 00:17:52,799
so really really useful there

00:17:56,960 --> 00:18:01,360
if you're looking at you know the other

00:17:58,720 --> 00:18:05,360
ones these are much much more useful

00:18:01,360 --> 00:18:07,919
on uh really large data sets primarily

00:18:05,360 --> 00:18:09,679
um i've asked the postgres core kind of

00:18:07,919 --> 00:18:10,640
contributors and committers a number of

00:18:09,679 --> 00:18:12,960
times

00:18:10,640 --> 00:18:14,720
uh to get a simplified answer the use

00:18:12,960 --> 00:18:16,000
case i've heard for spjs is basically

00:18:14,720 --> 00:18:18,000
phone numbers

00:18:16,000 --> 00:18:19,360
um essentially where you've got data

00:18:18,000 --> 00:18:20,480
that kind of naturally cluster

00:18:19,360 --> 00:18:22,559
clusters together if you think about

00:18:20,480 --> 00:18:24,799
phone numbers you've got a

00:18:22,559 --> 00:18:26,320
uh area code then usually three digits

00:18:24,799 --> 00:18:29,120
to kind of cluster together then you've

00:18:26,320 --> 00:18:30,720
got the unique four digits there as well

00:18:29,120 --> 00:18:33,600
so there's kind of natural clustering

00:18:30,720 --> 00:18:36,240
blocks that's similar for block range

00:18:33,600 --> 00:18:37,760
index block range is truly billions and

00:18:36,240 --> 00:18:38,960
billions of record most commonly in the

00:18:37,760 --> 00:18:41,440
table

00:18:38,960 --> 00:18:42,000
that naturally cluster together these

00:18:41,440 --> 00:18:43,840
are much more

00:18:42,000 --> 00:18:45,280
specialized i'd say like you're digging

00:18:43,840 --> 00:18:45,919
pretty deep if you're starting to use

00:18:45,280 --> 00:18:47,440
these

00:18:45,919 --> 00:18:48,880
or you're working with some postgres

00:18:47,440 --> 00:18:49,520
consultant that's really kind of got

00:18:48,880 --> 00:18:51,360
some

00:18:49,520 --> 00:18:57,120
some large tables and some gnarly

00:18:51,360 --> 00:19:00,480
performance optimization uh to do there

00:18:57,120 --> 00:19:02,480
um so when i say batteries included um

00:19:00,480 --> 00:19:04,000
there's a uh a blog post that was

00:19:02,480 --> 00:19:06,240
written a couple years ago

00:19:04,000 --> 00:19:07,840
that the title is uh postgres full text

00:19:06,240 --> 00:19:10,720
search is good enough

00:19:07,840 --> 00:19:12,480
and it it summarized it really well they

00:19:10,720 --> 00:19:12,960
basically said hey i needed to add full

00:19:12,480 --> 00:19:15,840
text

00:19:12,960 --> 00:19:17,280
search to my application i i was going

00:19:15,840 --> 00:19:19,360
to go to use elastic and i started

00:19:17,280 --> 00:19:23,440
digging in and here it is with postgres

00:19:19,360 --> 00:19:25,840
and it absolutely works um

00:19:23,440 --> 00:19:27,600
it's built for a lot of languages um

00:19:25,840 --> 00:19:28,960
you've got you know common ones english

00:19:27,600 --> 00:19:31,919
french german russian

00:19:28,960 --> 00:19:32,480
it doesn't do a lot of the the asian

00:19:31,919 --> 00:19:34,559
language

00:19:32,480 --> 00:19:36,160
japanese chinese there are extensions

00:19:34,559 --> 00:19:37,840
specifically to do that

00:19:36,160 --> 00:19:39,919
just because of the kind of lexical

00:19:37,840 --> 00:19:41,520
nature of those them is very different

00:19:39,919 --> 00:19:43,200
but you've got all the common things in

00:19:41,520 --> 00:19:44,400
full text search stimming you can you

00:19:43,200 --> 00:19:47,039
know rank and you know

00:19:44,400 --> 00:19:47,440
boost fuzzy search if you want to look

00:19:47,039 --> 00:19:49,679
for

00:19:47,440 --> 00:19:50,880
misspellings right of hey it was it's

00:19:49,679 --> 00:19:54,000
kind of close to this

00:19:50,880 --> 00:19:55,919
how does it rank and compare you build

00:19:54,000 --> 00:19:57,760
your text document with ts vector so you

00:19:55,919 --> 00:19:59,360
can combine different columns for your

00:19:57,760 --> 00:20:01,679
document

00:19:59,360 --> 00:20:02,960
and then you search with ts query really

00:20:01,679 --> 00:20:04,799
really useful

00:20:02,960 --> 00:20:06,799
the docs are good on this if you need

00:20:04,799 --> 00:20:08,480
full text search in your application

00:20:06,799 --> 00:20:10,159
and you're not building a you know

00:20:08,480 --> 00:20:11,760
custom built search engine

00:20:10,159 --> 00:20:13,679
i'd say it's really useful to just try

00:20:11,760 --> 00:20:15,039
to dig in here a lot of the times when

00:20:13,679 --> 00:20:17,280
you need to add something to postgres

00:20:15,039 --> 00:20:18,720
you can go get a whole new system

00:20:17,280 --> 00:20:20,640
or you can say well let's see what

00:20:18,720 --> 00:20:21,360
postgres can do and usually it's good

00:20:20,640 --> 00:20:22,640
enough

00:20:21,360 --> 00:20:25,280
which means now you don't have to worry

00:20:22,640 --> 00:20:26,559
about etl and keeping things in sync

00:20:25,280 --> 00:20:28,640
you don't have one more system to

00:20:26,559 --> 00:20:30,880
maintain really really useful in that

00:20:28,640 --> 00:20:33,360
regards

00:20:30,880 --> 00:20:35,520
another huge one is postgis and i have

00:20:33,360 --> 00:20:38,400
one really small slide here that

00:20:35,520 --> 00:20:40,400
doesn't do it justice at all and the

00:20:38,400 --> 00:20:42,799
reality is once i go down this path of

00:20:40,400 --> 00:20:45,360
post gis i'll be talking for the next 45

00:20:42,799 --> 00:20:47,280
minutes just about post gis

00:20:45,360 --> 00:20:48,799
it is well regarded by pretty much

00:20:47,280 --> 00:20:50,400
everyone is the richest open source

00:20:48,799 --> 00:20:52,480
geospatial database

00:20:50,400 --> 00:20:53,679
it has more features than oracle

00:20:52,480 --> 00:20:55,039
geospatial

00:20:53,679 --> 00:20:57,039
probably the only thing that really

00:20:55,039 --> 00:21:00,799
beats it out is is esri a

00:20:57,039 --> 00:21:02,720
commercial licensed geospatial database

00:21:00,799 --> 00:21:04,480
when you install the extension you get

00:21:02,720 --> 00:21:06,240
new data types you get new functions

00:21:04,480 --> 00:21:08,080
you've got things like pg routing for

00:21:06,240 --> 00:21:09,520
for finding paths right along streets

00:21:08,080 --> 00:21:11,760
and mapping that sort of thing

00:21:09,520 --> 00:21:12,880
you can do rastering within the database

00:21:11,760 --> 00:21:16,240
actually

00:21:12,880 --> 00:21:18,240
really really rich uh extension probably

00:21:16,240 --> 00:21:21,280
the most feature-rich extension that

00:21:18,240 --> 00:21:24,320
exists within postgres and

00:21:21,280 --> 00:21:24,720
um there's an entire kind of community

00:21:24,320 --> 00:21:27,520
that

00:21:24,720 --> 00:21:28,799
develops alongside the postgresql

00:21:27,520 --> 00:21:31,280
community so they've got their own

00:21:28,799 --> 00:21:33,360
release schedule on cadence own set of

00:21:31,280 --> 00:21:35,760
contributors and committers

00:21:33,360 --> 00:21:36,799
um a pretty large coast base in and of

00:21:35,760 --> 00:21:38,880
itself that

00:21:36,799 --> 00:21:41,360
works with the postgres committers and

00:21:38,880 --> 00:21:42,840
community but also has its own separate

00:21:41,360 --> 00:21:45,360
parallel track so really really

00:21:42,840 --> 00:21:48,559
fascinating

00:21:45,360 --> 00:21:50,400
um i mentioned jsonv already a little

00:21:48,559 --> 00:21:51,760
while back we had hdr if you see any

00:21:50,400 --> 00:21:52,960
older applications you may have it

00:21:51,760 --> 00:21:54,960
laying around

00:21:52,960 --> 00:21:56,960
it's a key value store data type that

00:21:54,960 --> 00:21:59,919
predated json

00:21:56,960 --> 00:22:02,240
then we got json json is actually really

00:21:59,919 --> 00:22:04,000
useful if you're just recording a lot of

00:22:02,240 --> 00:22:05,840
json text really fast

00:22:04,000 --> 00:22:07,760
things like if you want to record logs

00:22:05,840 --> 00:22:08,799
or api inputs they'll preserve white

00:22:07,760 --> 00:22:10,240
space

00:22:08,799 --> 00:22:12,480
that can be useful if you're looking to

00:22:10,240 --> 00:22:13,760
go replay logs but most of the time you

00:22:12,480 --> 00:22:15,440
want json b

00:22:13,760 --> 00:22:18,320
so really you've got like a document

00:22:15,440 --> 00:22:21,520
database directly inside postgres

00:22:18,320 --> 00:22:21,520
really really powerful there

00:22:23,360 --> 00:22:27,840
so continuing on on this journey uh

00:22:26,080 --> 00:22:29,919
postgres to me is really interesting

00:22:27,840 --> 00:22:32,240
because of batteries included

00:22:29,919 --> 00:22:34,080
in the last five years ago or so it's

00:22:32,240 --> 00:22:35,679
become even more interesting because of

00:22:34,080 --> 00:22:37,760
extensions so post gis

00:22:35,679 --> 00:22:39,600
is one of those extensions are really

00:22:37,760 --> 00:22:40,000
really low level hooks that allow you to

00:22:39,600 --> 00:22:42,400
change

00:22:40,000 --> 00:22:43,039
how postpress is working and behaving so

00:22:42,400 --> 00:22:44,960
you can change

00:22:43,039 --> 00:22:47,360
really deep into the internals you can

00:22:44,960 --> 00:22:49,679
change add new data types new functions

00:22:47,360 --> 00:22:51,520
you can change the query planner so you

00:22:49,679 --> 00:22:52,400
can make it go to like dev null if you

00:22:51,520 --> 00:22:55,039
wanted to

00:22:52,400 --> 00:22:55,840
um really fascinating that you can go

00:22:55,039 --> 00:22:58,080
and make it be in

00:22:55,840 --> 00:22:59,679
like an entirely other database so

00:22:58,080 --> 00:23:01,440
people have gone and kind of

00:22:59,679 --> 00:23:02,960
changed postgres to be time series

00:23:01,440 --> 00:23:04,480
related to bgo spatial

00:23:02,960 --> 00:23:06,960
all of these things with this extension

00:23:04,480 --> 00:23:08,159
framework and i kind of hate the name

00:23:06,960 --> 00:23:10,159
extensions because you know

00:23:08,159 --> 00:23:12,080
everything has extensions or plugins or

00:23:10,159 --> 00:23:13,760
something like that

00:23:12,080 --> 00:23:15,600
this is truly unique i haven't seen

00:23:13,760 --> 00:23:19,120
something that goes this deep

00:23:15,600 --> 00:23:20,480
in other databases so a really brief

00:23:19,120 --> 00:23:23,039
tour

00:23:20,480 --> 00:23:24,159
one everyone should know about is pg

00:23:23,039 --> 00:23:26,240
stat statements

00:23:24,159 --> 00:23:28,000
it comes with postgres you may need to

00:23:26,240 --> 00:23:30,640
turn it on that's just create

00:23:28,000 --> 00:23:31,200
extension pg stat statements really

00:23:30,640 --> 00:23:33,200
useful

00:23:31,200 --> 00:23:35,280
for identifying performance issues later

00:23:33,200 --> 00:23:37,840
and recording a whole lot of data

00:23:35,280 --> 00:23:39,520
what it's going to do is record every

00:23:37,840 --> 00:23:42,320
query that runs against your database

00:23:39,520 --> 00:23:43,679
and a whole bunch of data about it so

00:23:42,320 --> 00:23:45,760
you can see if this you know i'm looking

00:23:43,679 --> 00:23:50,559
for this query where you know select

00:23:45,760 --> 00:23:52,480
from something from users equals email

00:23:50,559 --> 00:23:54,559
uh it's gonna record how many times this

00:23:52,480 --> 00:23:56,720
ran uh

00:23:54,559 --> 00:23:58,240
the total time it took how many rows it

00:23:56,720 --> 00:24:00,720
typically returns

00:23:58,240 --> 00:24:01,360
all this data about the the heap

00:24:00,720 --> 00:24:03,120
underneath

00:24:01,360 --> 00:24:05,760
and you know how many blocks it dirty

00:24:03,120 --> 00:24:07,600
how many it wrote all that sort of thing

00:24:05,760 --> 00:24:09,279
what's nice about this is you can do

00:24:07,600 --> 00:24:10,080
some things like aggregate queries like

00:24:09,279 --> 00:24:12,880
this

00:24:10,080 --> 00:24:13,279
where i can say give me the total time

00:24:12,880 --> 00:24:15,600
uh

00:24:13,279 --> 00:24:17,760
that this query ran give me the time it

00:24:15,600 --> 00:24:19,279
took on average and let's order by the

00:24:17,760 --> 00:24:20,480
total time consumed against my

00:24:19,279 --> 00:24:22,080
application

00:24:20,480 --> 00:24:24,320
so i can get something really really

00:24:22,080 --> 00:24:27,360
useful with this one query to say oh

00:24:24,320 --> 00:24:29,440
what are my most expensive queries here

00:24:27,360 --> 00:24:30,400
i've got one that runs on average in 10

00:24:29,440 --> 00:24:32,159
milliseconds

00:24:30,400 --> 00:24:33,679
i've got one on an average that runs in

00:24:32,159 --> 00:24:35,840
80. uh

00:24:33,679 --> 00:24:38,559
from what i know generally i can get a

00:24:35,840 --> 00:24:41,440
query down to one millisecond or so

00:24:38,559 --> 00:24:43,520
um so in total this one consumed 295

00:24:41,440 --> 00:24:45,600
seconds this one's 200 seconds

00:24:43,520 --> 00:24:47,120
i could actually go and you know add an

00:24:45,600 --> 00:24:47,919
index here and probably get an order of

00:24:47,120 --> 00:24:49,279
magnitude back

00:24:47,919 --> 00:24:51,679
and get a lot more performance out of my

00:24:49,279 --> 00:24:52,960
database really really useful if you

00:24:51,679 --> 00:24:54,880
haven't already turned it on

00:24:52,960 --> 00:24:56,640
turn it on when you do want to do

00:24:54,880 --> 00:24:58,159
performance investigation

00:24:56,640 --> 00:25:00,640
a lot of tools for postgres out there

00:24:58,159 --> 00:25:02,559
are going to leverage it

00:25:00,640 --> 00:25:04,159
you can google and find a bunch of basic

00:25:02,559 --> 00:25:06,960
queries to give you really good insights

00:25:04,159 --> 00:25:06,960
right out of the box

00:25:08,640 --> 00:25:12,960
another one just as an example pg part

00:25:11,440 --> 00:25:14,880
man

00:25:12,960 --> 00:25:17,039
i mentioned batteries included you've

00:25:14,880 --> 00:25:18,960
got post gis which is an extension

00:25:17,039 --> 00:25:21,760
you've got external ones pg apartments

00:25:18,960 --> 00:25:23,840
one of those really for time series data

00:25:21,760 --> 00:25:25,360
um time partitioning is becoming more

00:25:23,840 --> 00:25:28,159
and more native in postgres

00:25:25,360 --> 00:25:29,919
but until it's perfect pg partner helps

00:25:28,159 --> 00:25:31,200
with a lot of that

00:25:29,919 --> 00:25:33,039
i'm going to kind of fly through this

00:25:31,200 --> 00:25:36,320
code example because we're about midway

00:25:33,039 --> 00:25:36,320
and a little over mid time

00:25:36,400 --> 00:25:41,520
here if i've got a table i want to set

00:25:38,640 --> 00:25:43,120
up i've got an events table for iot data

00:25:41,520 --> 00:25:45,360
i've got some payload that's coming in

00:25:43,120 --> 00:25:47,039
here with json b and some actors coming

00:25:45,360 --> 00:25:49,039
in with json b

00:25:47,039 --> 00:25:51,520
i want to pay partition by the created

00:25:49,039 --> 00:25:53,360
at right typical time based partitioning

00:25:51,520 --> 00:25:54,559
my events are coming in i want to create

00:25:53,360 --> 00:25:56,640
a

00:25:54,559 --> 00:25:59,600
partition for maybe the you know each

00:25:56,640 --> 00:26:00,799
day each five minutes each hour

00:25:59,600 --> 00:26:02,320
i'm going to create this table like

00:26:00,799 --> 00:26:05,360
normal and then just say partition by

00:26:02,320 --> 00:26:07,039
range which is needed to postgres

00:26:05,360 --> 00:26:08,960
then i'm going to come in here to pd

00:26:07,039 --> 00:26:10,080
part man and tell it how to

00:26:08,960 --> 00:26:11,360
automatically set up all those

00:26:10,080 --> 00:26:13,919
partitions for me so what it's going to

00:26:11,360 --> 00:26:15,760
do is monitor when data is coming in and

00:26:13,919 --> 00:26:16,960
create those partitions ahead of time so

00:26:15,760 --> 00:26:18,480
it's going to create four

00:26:16,960 --> 00:26:20,400
in front of the data that i have so

00:26:18,480 --> 00:26:21,679
they're already created ready to ingest

00:26:20,400 --> 00:26:27,520
data

00:26:21,679 --> 00:26:27,520
i can prune off data if i want so i can

00:26:28,000 --> 00:26:31,039
get rid of old data after it's been

00:26:29,679 --> 00:26:33,600
there a month or i can

00:26:31,039 --> 00:26:34,320
keep it for all the time so here i'm

00:26:33,600 --> 00:26:37,360
setting it to

00:26:34,320 --> 00:26:39,039
infinite data really really useful

00:26:37,360 --> 00:26:40,480
under the covers i'm going to have an

00:26:39,039 --> 00:26:41,679
events table and i'm going to have all

00:26:40,480 --> 00:26:43,120
these other tables

00:26:41,679 --> 00:26:44,720
it's up to you how you want to reference

00:26:43,120 --> 00:26:46,400
this you can just query events

00:26:44,720 --> 00:26:47,679
postgres is automatically going to do

00:26:46,400 --> 00:26:48,880
the right thing of joining you can see

00:26:47,679 --> 00:26:50,640
we've got here

00:26:48,880 --> 00:26:52,880
five minute partitions you can go and

00:26:50,640 --> 00:26:54,080
look at the raw data it's automatically

00:26:52,880 --> 00:26:55,039
going to do this and take care of this

00:26:54,080 --> 00:26:58,320
for you

00:26:55,039 --> 00:27:00,720
um one really nice thing that i do like

00:26:58,320 --> 00:27:02,799
personally about pg part man

00:27:00,720 --> 00:27:04,480
all of its config is directly in the

00:27:02,799 --> 00:27:06,640
database like this is just a table you

00:27:04,480 --> 00:27:08,960
can query it you can update it and

00:27:06,640 --> 00:27:11,520
now you suddenly have intervals of you

00:27:08,960 --> 00:27:13,840
know 10 minutes instead of five

00:27:11,520 --> 00:27:15,200
you can change all sorts of things about

00:27:13,840 --> 00:27:18,080
it

00:27:15,200 --> 00:27:19,440
there's probably about 20 25 configs the

00:27:18,080 --> 00:27:20,799
docs are really good about saying you

00:27:19,440 --> 00:27:21,520
know which ones you need to set up right

00:27:20,799 --> 00:27:23,200
away

00:27:21,520 --> 00:27:24,559
things like pre-making your partitions

00:27:23,200 --> 00:27:26,559
so that when new data comes in you don't

00:27:24,559 --> 00:27:30,640
have to do that on the fly

00:27:26,559 --> 00:27:32,159
really really useful so extensions i can

00:27:30,640 --> 00:27:33,840
go on for a really long time i think

00:27:32,159 --> 00:27:34,480
they're a fascinating area within

00:27:33,840 --> 00:27:36,799
postgres

00:27:34,480 --> 00:27:37,679
they don't get enough attention there's

00:27:36,799 --> 00:27:39,919
some that come

00:27:37,679 --> 00:27:42,000
right out of the box uh there's some

00:27:39,919 --> 00:27:45,120
that you need to go install yourself

00:27:42,000 --> 00:27:46,799
um on crunchy bridge or databases or

00:27:45,120 --> 00:27:48,480
service these are one of the big areas

00:27:46,799 --> 00:27:51,360
we're really invested in

00:27:48,480 --> 00:27:53,679
um adding new extensions allowing you to

00:27:51,360 --> 00:27:55,520
do new things so the postgres core can

00:27:53,679 --> 00:27:56,960
can be this really stable piece of

00:27:55,520 --> 00:27:58,880
reliable software

00:27:56,960 --> 00:28:01,120
it focuses on not losing data making

00:27:58,880 --> 00:28:03,120
performance faster

00:28:01,120 --> 00:28:04,640
at the same time people want more and

00:28:03,120 --> 00:28:06,240
more features but they maybe don't

00:28:04,640 --> 00:28:09,120
belong in core or they do

00:28:06,240 --> 00:28:10,320
it's in time so just a few to quickly

00:28:09,120 --> 00:28:12,480
highlight

00:28:10,320 --> 00:28:13,840
pg stats statements turn it on if it's

00:28:12,480 --> 00:28:15,840
not already on your database

00:28:13,840 --> 00:28:17,360
if you want time partitioning you've got

00:28:15,840 --> 00:28:18,880
pg part man really useful

00:28:17,360 --> 00:28:21,200
if you're doing geospatial stuff you've

00:28:18,880 --> 00:28:23,760
probably heard about postgis

00:28:21,200 --> 00:28:24,799
zombo db is a fascinating one that

00:28:23,760 --> 00:28:26,640
allows you to

00:28:24,799 --> 00:28:28,480
index your data in elastic search from

00:28:26,640 --> 00:28:30,159
within postgres so it'll keep all your

00:28:28,480 --> 00:28:31,760
data in sync from postgres over to

00:28:30,159 --> 00:28:34,799
elasticsearch

00:28:31,760 --> 00:28:37,760
then inside standard sql you can use

00:28:34,799 --> 00:28:39,200
standard postgres to query the data and

00:28:37,760 --> 00:28:40,960
it will leverage a

00:28:39,200 --> 00:28:43,279
elastic search index really really

00:28:40,960 --> 00:28:45,120
interesting if you want to go and curl

00:28:43,279 --> 00:28:47,120
and scrape a bunch of websites

00:28:45,120 --> 00:28:49,039
http you just hit an api endpoint and

00:28:47,120 --> 00:28:51,120
get data back in json

00:28:49,039 --> 00:28:52,880
really really interesting simple but

00:28:51,120 --> 00:28:54,799
really potentially useful

00:28:52,880 --> 00:28:56,799
uh c-store is a columnar store for

00:28:54,799 --> 00:28:58,480
compression and postgres

00:28:56,799 --> 00:29:00,320
and then madlib madlib is another really

00:28:58,480 --> 00:29:01,919
old one like post gis

00:29:00,320 --> 00:29:03,360
it's been around over 10 years came out

00:29:01,919 --> 00:29:07,279
uc berkeley it's an

00:29:03,360 --> 00:29:09,440
entire like ai data science ml library

00:29:07,279 --> 00:29:10,480
it has unsupervised learning supervised

00:29:09,440 --> 00:29:12,240
learning

00:29:10,480 --> 00:29:14,000
almost everything you could want to do

00:29:12,240 --> 00:29:15,520
optimize and see directly in your

00:29:14,000 --> 00:29:17,200
database you don't have to go write this

00:29:15,520 --> 00:29:18,880
from scratch yourself

00:29:17,200 --> 00:29:20,159
really really fascinating one that i'm

00:29:18,880 --> 00:29:21,120
surprised more people haven't been

00:29:20,159 --> 00:29:23,279
talking about

00:29:21,120 --> 00:29:25,279
that's been around for for 10 years and

00:29:23,279 --> 00:29:27,200
it's quite mature actually so

00:29:25,279 --> 00:29:29,600
um if you want to dig into the data

00:29:27,200 --> 00:29:31,360
science world and don't want to have to

00:29:29,600 --> 00:29:34,880
write the algorithm yourself it's

00:29:31,360 --> 00:29:34,880
probably there in matlab already for you

00:29:35,360 --> 00:29:38,480
there's also another really special

00:29:36,960 --> 00:29:40,240
category uh

00:29:38,480 --> 00:29:42,559
foreign data wrappers that allow you to

00:29:40,240 --> 00:29:45,039
connect from postgres to something else

00:29:42,559 --> 00:29:45,679
really natively um you've got ones to

00:29:45,039 --> 00:29:48,159
connect to

00:29:45,679 --> 00:29:50,799
redis to you've got c-store which

00:29:48,159 --> 00:29:53,360
is the columnar one

00:29:50,799 --> 00:29:54,960
really pretty simple to set up you you

00:29:53,360 --> 00:29:58,000
create a foreign server

00:29:54,960 --> 00:29:59,760
um this is a specific kind of foreign

00:29:58,000 --> 00:30:01,360
data wrapper api

00:29:59,760 --> 00:30:03,919
you say hey what's my connection string

00:30:01,360 --> 00:30:05,840
to it um

00:30:03,919 --> 00:30:07,360
you create the foreign table which is

00:30:05,840 --> 00:30:10,559
just a mapping from that

00:30:07,360 --> 00:30:12,320
so you can map specific documents

00:30:10,559 --> 00:30:14,080
here you know redis it's just key value

00:30:12,320 --> 00:30:16,559
so we're just mapping it to some

00:30:14,080 --> 00:30:18,480
foreign table and then you you know how

00:30:16,559 --> 00:30:21,200
do you access this what's the

00:30:18,480 --> 00:30:23,039
you know the user and password and then

00:30:21,200 --> 00:30:25,120
as i describe my table

00:30:23,039 --> 00:30:27,600
i've got my standard postgres tables and

00:30:25,120 --> 00:30:30,640
i've got this foreign table here

00:30:27,600 --> 00:30:32,480
i can just query that select star from

00:30:30,640 --> 00:30:34,159
my redis table and i get data back

00:30:32,480 --> 00:30:36,080
directly from redis

00:30:34,159 --> 00:30:37,360
now it's worth mentioning that the redis

00:30:36,080 --> 00:30:39,039
one is not optimized

00:30:37,360 --> 00:30:41,440
every time you query this it's going to

00:30:39,039 --> 00:30:43,360
pull back everything from redis

00:30:41,440 --> 00:30:45,039
um there are some that are much more

00:30:43,360 --> 00:30:46,480
optimized so like there's a postgresql

00:30:45,039 --> 00:30:48,159
data wrapper for connecting two

00:30:46,480 --> 00:30:49,679
different postgres databases

00:30:48,159 --> 00:30:51,440
this is optimized and i'll do things

00:30:49,679 --> 00:30:53,679
like query push down

00:30:51,440 --> 00:30:56,000
really really useful and handy uh for

00:30:53,679 --> 00:30:58,880
like occasional etl

00:30:56,000 --> 00:31:00,640
occasionally migrating data um really

00:30:58,880 --> 00:31:02,320
really handy there's one for oracle

00:31:00,640 --> 00:31:04,480
there's one for

00:31:02,320 --> 00:31:06,720
really useful when you're querying uh

00:31:04,480 --> 00:31:08,559
disparate systems

00:31:06,720 --> 00:31:10,000
and then i can join this so for redis

00:31:08,559 --> 00:31:11,760
everything comes back as text i've got

00:31:10,000 --> 00:31:15,200
to do some casting here

00:31:11,760 --> 00:31:16,080
um to join but you can see i can query

00:31:15,200 --> 00:31:17,600
my users table

00:31:16,080 --> 00:31:19,600
join this against reddit's where i'm

00:31:17,600 --> 00:31:20,880
keeping track of visitors

00:31:19,600 --> 00:31:22,960
and i'm looking for anyone that's come

00:31:20,880 --> 00:31:24,720
to my website you know more than 40

00:31:22,960 --> 00:31:26,640
times maybe i want to run an ad for them

00:31:24,720 --> 00:31:28,960
maybe i want to run an email campaign

00:31:26,640 --> 00:31:33,760
but really handy to not have to go you

00:31:28,960 --> 00:31:37,440
know do some etl process on this

00:31:33,760 --> 00:31:39,679
um a little bit of uh detour

00:31:37,440 --> 00:31:41,440
um to me sequel is a really powerful

00:31:39,679 --> 00:31:45,039
language um

00:31:41,440 --> 00:31:47,120
i i value sql uh

00:31:45,039 --> 00:31:49,360
a lot of times when i'm in a room giving

00:31:47,120 --> 00:31:50,960
a talk i ask people to raise their hands

00:31:49,360 --> 00:31:53,120
i don't know how quickly or easy that is

00:31:50,960 --> 00:31:54,640
to do here um

00:31:53,120 --> 00:31:56,159
feel free to kind of virtually raise

00:31:54,640 --> 00:31:59,840
your hand if you you know

00:31:56,159 --> 00:32:01,519
enjoy writing sql usually i'll see like

00:31:59,840 --> 00:32:03,039
five or ten hands out of a hundred to

00:32:01,519 --> 00:32:05,200
two hundred people

00:32:03,039 --> 00:32:06,960
um then i typically shift the question

00:32:05,200 --> 00:32:08,399
of who likes reading sequel

00:32:06,960 --> 00:32:10,240
especially sequel that someone else has

00:32:08,399 --> 00:32:13,679
written um

00:32:10,240 --> 00:32:15,760
and it usually drops to one and uh

00:32:13,679 --> 00:32:17,919
that person and i go have a nice long

00:32:15,760 --> 00:32:19,120
kind of commemorating you know drink in

00:32:17,919 --> 00:32:21,840
the evening

00:32:19,120 --> 00:32:24,000
uh on the awful sequel you've seen other

00:32:21,840 --> 00:32:26,320
people write

00:32:24,000 --> 00:32:27,919
sql is a really powerful language you

00:32:26,320 --> 00:32:29,200
can definitely write better sql and i

00:32:27,919 --> 00:32:32,640
encourage people to do that

00:32:29,200 --> 00:32:35,279
um a few kind of basics uh

00:32:32,640 --> 00:32:37,279
indent it use casing use comments you

00:32:35,279 --> 00:32:38,480
can comment inline sql just like you do

00:32:37,279 --> 00:32:40,880
in your code

00:32:38,480 --> 00:32:42,399
probably most of the people listening

00:32:40,880 --> 00:32:43,679
have some level of comments in their

00:32:42,399 --> 00:32:45,360
code

00:32:43,679 --> 00:32:46,960
i'm really curious for how many actually

00:32:45,360 --> 00:32:48,320
have comments in your sql

00:32:46,960 --> 00:32:50,480
you can do this there's no reason you

00:32:48,320 --> 00:32:51,200
shouldn't there's another thing that's

00:32:50,480 --> 00:32:53,760
really useful

00:32:51,200 --> 00:32:54,799
for more readable sql which is common

00:32:53,760 --> 00:32:56,640
table expressions

00:32:54,799 --> 00:32:59,039
these are like logical blocks and views

00:32:56,640 --> 00:33:01,039
that you can build up queries over

00:32:59,039 --> 00:33:02,960
logical steps and reference the previous

00:33:01,039 --> 00:33:04,880
ones so it's not always going to be

00:33:02,960 --> 00:33:06,480
super optimized for performance

00:33:04,880 --> 00:33:08,080
but when you're writing a report that

00:33:06,480 --> 00:33:09,760
it's more about readability when someone

00:33:08,080 --> 00:33:11,840
comes back in six months and a year to

00:33:09,760 --> 00:33:15,440
try to figure out what you were doing

00:33:11,840 --> 00:33:17,519
really really really useful um

00:33:15,440 --> 00:33:18,559
a quick kind of look at this this is a

00:33:17,519 --> 00:33:20,880
lot of

00:33:18,559 --> 00:33:22,559
sequel on the screen but i'm quickly

00:33:20,880 --> 00:33:24,000
gonna gonna flip through this to give

00:33:22,559 --> 00:33:26,159
some idea you can see here

00:33:24,000 --> 00:33:28,159
that i've got an initial comment right

00:33:26,159 --> 00:33:29,440
here this is inline not going to execute

00:33:28,159 --> 00:33:32,240
but you can see that

00:33:29,440 --> 00:33:33,760
i'm doing a really basic query here from

00:33:32,240 --> 00:33:35,840
three different tables

00:33:33,760 --> 00:33:37,360
i'm joining my users and my projects to

00:33:35,840 --> 00:33:40,240
get back a list of

00:33:37,360 --> 00:33:40,799
all the task lists uh for a specific

00:33:40,240 --> 00:33:43,919
project

00:33:40,799 --> 00:33:46,000
by uh by the individual user

00:33:43,919 --> 00:33:47,679
and i come later and actually group that

00:33:46,000 --> 00:33:49,120
so i'm gonna do a separate one and

00:33:47,679 --> 00:33:52,000
calculate the total

00:33:49,120 --> 00:33:54,080
of each task for the project so nice

00:33:52,000 --> 00:33:56,399
inline comment here you can actually see

00:33:54,080 --> 00:33:58,559
my indentation pretty easy to follow

00:33:56,399 --> 00:33:59,519
that my key sql pieces are here together

00:33:58,559 --> 00:34:01,840
and like the

00:33:59,519 --> 00:34:03,360
columns coming out are all the same line

00:34:01,840 --> 00:34:05,200
easily come through if i wanted to

00:34:03,360 --> 00:34:07,440
delete or find the next one not all in

00:34:05,200 --> 00:34:09,599
the same line

00:34:07,440 --> 00:34:10,960
uh i'm gonna come back in here again and

00:34:09,599 --> 00:34:12,879
again i'm flying through this

00:34:10,960 --> 00:34:14,240
the example will be online so you can

00:34:12,879 --> 00:34:18,480
feel free to come and

00:34:14,240 --> 00:34:22,399
look through this here i'm gonna

00:34:18,480 --> 00:34:23,760
get the projects per each user again

00:34:22,399 --> 00:34:25,839
i don't have to read through the sql and

00:34:23,760 --> 00:34:26,720
say oh what what task am i you know

00:34:25,839 --> 00:34:29,839
referencing

00:34:26,720 --> 00:34:32,720
um easily grouped in an

00:34:29,839 --> 00:34:34,159
ability to parse this and then what i'm

00:34:32,720 --> 00:34:36,960
gonna do is filter for

00:34:34,159 --> 00:34:37,919
all of my users that have over 50 of the

00:34:36,960 --> 00:34:39,839
task assigned

00:34:37,919 --> 00:34:41,200
basically which users are carrying the

00:34:39,839 --> 00:34:44,000
heavy load in my

00:34:41,200 --> 00:34:45,440
they uh my project kind of tracking

00:34:44,000 --> 00:34:48,560
application so

00:34:45,440 --> 00:34:50,000
um who's doing most of the work where we

00:34:48,560 --> 00:34:51,040
should figure it out and distribute it

00:34:50,000 --> 00:34:53,119
what's my you know

00:34:51,040 --> 00:34:54,960
bottleneck how can i offload work to

00:34:53,119 --> 00:34:56,480
someone

00:34:54,960 --> 00:34:57,839
and in the end i'm going to reference

00:34:56,480 --> 00:34:58,560
these two different tables that i

00:34:57,839 --> 00:35:00,560
created

00:34:58,560 --> 00:35:02,320
basically these views that only exist

00:35:00,560 --> 00:35:05,440
for this cte

00:35:02,320 --> 00:35:07,359
so user task and overloaded users and i

00:35:05,440 --> 00:35:08,720
want to find and get all those tasks and

00:35:07,359 --> 00:35:10,800
say hey can we take some of these tasks

00:35:08,720 --> 00:35:14,240
and give them out to someone else

00:35:10,800 --> 00:35:14,720
so again a pretty long query i flew

00:35:14,240 --> 00:35:16,240
through that

00:35:14,720 --> 00:35:17,839
not sure if people are able to easily

00:35:16,240 --> 00:35:19,839
follow but

00:35:17,839 --> 00:35:21,200
you know easily in a couple more minutes

00:35:19,839 --> 00:35:22,240
you could go and grop what's going on

00:35:21,200 --> 00:35:25,920
here and this is you know

00:35:22,240 --> 00:35:26,960
40 lines or so of sql normally if i were

00:35:25,920 --> 00:35:30,160
to do this in the most

00:35:26,960 --> 00:35:31,599
optimized compressed way um your eyes

00:35:30,160 --> 00:35:32,560
are just going to kind of go blurry and

00:35:31,599 --> 00:35:33,760
you're not going to be able to parse

00:35:32,560 --> 00:35:34,960
what's going on it's going to take you a

00:35:33,760 --> 00:35:36,880
lot more time so

00:35:34,960 --> 00:35:39,280
tte is a really useful tool for writing

00:35:36,880 --> 00:35:41,440
better sql

00:35:39,280 --> 00:35:42,880
uh there's another one that is my latest

00:35:41,440 --> 00:35:46,560
fascination

00:35:42,880 --> 00:35:49,040
so if you're writing procedural sql um

00:35:46,560 --> 00:35:51,200
functions and that sort of thing um a

00:35:49,040 --> 00:35:52,640
lot of this is plpg sql

00:35:51,200 --> 00:35:56,079
there's other options there's things

00:35:52,640 --> 00:35:59,200
like plva pl python plr

00:35:56,079 --> 00:36:00,880
uh pl python is my latest in infatuation

00:35:59,200 --> 00:36:02,160
of like i wonder if i can do this in my

00:36:00,880 --> 00:36:04,240
database

00:36:02,160 --> 00:36:05,359
um at first i'm like this is probably

00:36:04,240 --> 00:36:07,119
not a good idea

00:36:05,359 --> 00:36:08,720
um then i started thinking about it and

00:36:07,119 --> 00:36:10,000
the more i think maybe it's actually not

00:36:08,720 --> 00:36:12,400
so crazy

00:36:10,000 --> 00:36:14,960
um i started a couple months ago with a

00:36:12,400 --> 00:36:17,920
tweet saying hey i've got pl python

00:36:14,960 --> 00:36:20,720
i just wonder if i could go and create a

00:36:17,920 --> 00:36:23,359
recommendation engine inside my database

00:36:20,720 --> 00:36:23,760
and so i i started there's a lot of code

00:36:23,359 --> 00:36:25,280
here

00:36:23,760 --> 00:36:26,960
i'm going to try to jump to a couple of

00:36:25,280 --> 00:36:30,160
smaller blocks of it

00:36:26,960 --> 00:36:30,880
um first thing i was doing is like well

00:36:30,160 --> 00:36:33,440
can i install

00:36:30,880 --> 00:36:35,680
pandas directly inside my database can i

00:36:33,440 --> 00:36:36,880
go and run pandas directly from inside

00:36:35,680 --> 00:36:39,440
postgres

00:36:36,880 --> 00:36:40,079
and have that do a basic kind of

00:36:39,440 --> 00:36:42,079
recommendation

00:36:40,079 --> 00:36:43,280
engine um and so for there i'm gonna

00:36:42,079 --> 00:36:45,920
pass in all the

00:36:43,280 --> 00:36:46,720
order past orders i'm gonna pass in you

00:36:45,920 --> 00:36:48,640
know

00:36:46,720 --> 00:36:50,320
the products that are in a customer's

00:36:48,640 --> 00:36:52,240
cart and then i'm basically gonna do the

00:36:50,320 --> 00:36:55,359
rest of the work in pandas

00:36:52,240 --> 00:36:58,000
uh again a little tight on time here so

00:36:55,359 --> 00:36:58,800
not gonna i think drill too deep through

00:36:58,000 --> 00:37:00,720
the code here

00:36:58,800 --> 00:37:01,839
um if you're a python person come back

00:37:00,720 --> 00:37:03,599
through read this

00:37:01,839 --> 00:37:05,119
probably tell me how i did it horribly

00:37:03,599 --> 00:37:08,880
and efficient from a

00:37:05,119 --> 00:37:09,599
pandas perspective but really really to

00:37:08,880 --> 00:37:12,800
me a

00:37:09,599 --> 00:37:14,240
hey can i create a recommendation engine

00:37:12,800 --> 00:37:17,839
directly inside postgres

00:37:14,240 --> 00:37:20,640
and about two hours later in 20 lines of

00:37:17,839 --> 00:37:21,680
pl python and pandas i had a

00:37:20,640 --> 00:37:25,359
recommendation engine

00:37:21,680 --> 00:37:27,760
that i could live feed in my my table

00:37:25,359 --> 00:37:28,560
feed in what's in a customer's cart and

00:37:27,760 --> 00:37:30,640
then get back

00:37:28,560 --> 00:37:33,119
a hey you should recommend these

00:37:30,640 --> 00:37:35,119
products to this person

00:37:33,119 --> 00:37:36,160
um this is also going to be a lot more

00:37:35,119 --> 00:37:39,839
readable than writing

00:37:36,160 --> 00:37:41,839
plpg sql so uh i think a really

00:37:39,839 --> 00:37:44,000
interesting you've got a lot of options

00:37:41,839 --> 00:37:46,320
uh with postgres you've got things like

00:37:44,000 --> 00:37:47,760
plv8 which is javascript directly inside

00:37:46,320 --> 00:37:49,280
your postgres database

00:37:47,760 --> 00:37:51,119
so if you've got a lot of json b and

00:37:49,280 --> 00:37:54,079
want to do interesting stuff there

00:37:51,119 --> 00:37:56,800
you can operate on it in javascript uh

00:37:54,079 --> 00:37:58,800
pl python plr

00:37:56,800 --> 00:37:59,680
really handy r for a lot of data science

00:37:58,800 --> 00:38:01,040
that you could do directly in the

00:37:59,680 --> 00:38:02,720
database

00:38:01,040 --> 00:38:04,400
it simplifies a lot of the stack if you

00:38:02,720 --> 00:38:07,839
don't want to have to do etl

00:38:04,400 --> 00:38:10,000
into a kafka out to spark to have your

00:38:07,839 --> 00:38:10,560
data like to feed it back in to redis or

00:38:10,000 --> 00:38:12,720
postgres

00:38:10,560 --> 00:38:16,400
and then target the user you could do a

00:38:12,720 --> 00:38:16,400
lot of this directly inside postgres

00:38:17,599 --> 00:38:22,400
so what's the future hold for postgres

00:38:19,920 --> 00:38:22,400
um

00:38:23,280 --> 00:38:27,119
the most recent i think big advancement

00:38:25,200 --> 00:38:30,240
is is pluggable storage

00:38:27,119 --> 00:38:31,280
uh in development now there are a couple

00:38:30,240 --> 00:38:33,839
different backends so

00:38:31,280 --> 00:38:35,440
postgres got pluggable storage that you

00:38:33,839 --> 00:38:36,640
can come in and change the storage type

00:38:35,440 --> 00:38:39,040
storage engine

00:38:36,640 --> 00:38:39,839
there's two in active development one z

00:38:39,040 --> 00:38:42,079
heap

00:38:39,839 --> 00:38:43,440
uh which are some improvements to

00:38:42,079 --> 00:38:46,480
postgres uh

00:38:43,440 --> 00:38:48,240
for auto vacuum there's another one

00:38:46,480 --> 00:38:49,280
z-store which is native calendar storage

00:38:48,240 --> 00:38:50,720
i think this is going to be really

00:38:49,280 --> 00:38:53,200
interesting for the coming years

00:38:50,720 --> 00:38:54,320
pluggable at storage itself is directly

00:38:53,200 --> 00:38:56,640
in core

00:38:54,320 --> 00:38:58,400
um in development are these other

00:38:56,640 --> 00:39:01,839
engines that you can come in and

00:38:58,400 --> 00:39:01,839
do other things

00:39:02,400 --> 00:39:08,960
uh for the the core itself i expect the

00:39:06,480 --> 00:39:09,839
postgres core to move at a steady stable

00:39:08,960 --> 00:39:12,000
pace

00:39:09,839 --> 00:39:13,280
postgres is really feature rich

00:39:12,000 --> 00:39:15,599
hopefully that came across

00:39:13,280 --> 00:39:16,960
throughout the last you know 40-minute

00:39:15,599 --> 00:39:19,839
whirlwind tour

00:39:16,960 --> 00:39:21,520
um hopefully there is something everyone

00:39:19,839 --> 00:39:23,920
didn't realize postgresql could do

00:39:21,520 --> 00:39:25,280
that there is this option for now

00:39:23,920 --> 00:39:27,920
whether it's full text search or

00:39:25,280 --> 00:39:31,359
geospatial or

00:39:27,920 --> 00:39:33,760
crazy extensions or just the data types

00:39:31,359 --> 00:39:36,960
even the the basic of the performance

00:39:33,760 --> 00:39:38,880
analysis you can do directly in postgres

00:39:36,960 --> 00:39:40,160
postgres is going to get more plugable

00:39:38,880 --> 00:39:41,520
we're going to expose more and more of

00:39:40,160 --> 00:39:43,200
those hooks and we're just going to keep

00:39:41,520 --> 00:39:45,200
improving performance performance always

00:39:43,200 --> 00:39:46,640
matter when it comes to your database

00:39:45,200 --> 00:39:50,079
we're just going to keep advancing more

00:39:46,640 --> 00:39:50,079
and more and more along that lines

00:39:51,680 --> 00:39:56,240
sorry to interrupt but we have five

00:39:53,040 --> 00:39:59,040
minutes left perfect

00:39:56,240 --> 00:40:00,960
outside of core um i think we're gonna

00:39:59,040 --> 00:40:03,440
see a lot of extensions right

00:40:00,960 --> 00:40:05,280
um more that you can tack on that you

00:40:03,440 --> 00:40:07,200
can extend you can enhance you could do

00:40:05,280 --> 00:40:08,960
interesting things and over time

00:40:07,200 --> 00:40:10,800
the really useful ones that are broadly

00:40:08,960 --> 00:40:12,240
applicable will come into core

00:40:10,800 --> 00:40:14,319
others will stay outside and can be

00:40:12,240 --> 00:40:16,160
easily installed

00:40:14,319 --> 00:40:18,720
so as i kind of wrap up on that initial

00:40:16,160 --> 00:40:20,480
question why postgres right

00:40:18,720 --> 00:40:22,720
where i s you know it's really feature

00:40:20,480 --> 00:40:25,280
rich but i do think

00:40:22,720 --> 00:40:26,560
this idea of open source and community

00:40:25,280 --> 00:40:28,400
managed community led

00:40:26,560 --> 00:40:30,240
community developed community owned no

00:40:28,400 --> 00:40:32,000
one else can ever actually own

00:40:30,240 --> 00:40:33,359
postgres it's not like in my sequel

00:40:32,000 --> 00:40:34,960
where you can have someone come in and

00:40:33,359 --> 00:40:38,079
own the copyright

00:40:34,960 --> 00:40:40,720
um it's truly unique in that fashion

00:40:38,079 --> 00:40:42,640
from most other projects that i know of

00:40:40,720 --> 00:40:43,440
most other projects come out of a single

00:40:42,640 --> 00:40:45,040
company and are

00:40:43,440 --> 00:40:47,119
still run and maintained by a single

00:40:45,040 --> 00:40:47,760
company you've got some exceptions to

00:40:47,119 --> 00:40:49,440
that in the

00:40:47,760 --> 00:40:51,280
javascript world where they eventually

00:40:49,440 --> 00:40:53,680
evolve and a ton of contributors

00:40:51,280 --> 00:40:55,440
but for something like postgres i want a

00:40:53,680 --> 00:40:57,200
high bar of a contributor i don't want

00:40:55,440 --> 00:40:58,880
any random person showing up and saying

00:40:57,200 --> 00:41:00,400
oh yeah let's change this index type

00:40:58,880 --> 00:41:01,119
because it's my data and you could lose

00:41:00,400 --> 00:41:03,359
it

00:41:01,119 --> 00:41:04,960
but at the same time i you know want

00:41:03,359 --> 00:41:06,560
more contributions so you've got people

00:41:04,960 --> 00:41:07,760
contributing to docs and community in a

00:41:06,560 --> 00:41:10,480
lot of ways

00:41:07,760 --> 00:41:13,119
but that uh community-owned aspect of it

00:41:10,480 --> 00:41:14,960
is really fascinating

00:41:13,119 --> 00:41:16,560
and then you know there's a whole lot

00:41:14,960 --> 00:41:18,560
inside the box um

00:41:16,560 --> 00:41:20,640
that's i think where i my end is you

00:41:18,560 --> 00:41:21,280
know you know why postgres because it

00:41:20,640 --> 00:41:23,599
can do

00:41:21,280 --> 00:41:24,400
pretty much everything should it do

00:41:23,599 --> 00:41:26,240
everything

00:41:24,400 --> 00:41:28,000
some things maybe are crazy i've seen

00:41:26,240 --> 00:41:29,119
you know crazy extensions and foreign

00:41:28,000 --> 00:41:30,480
data wrappers

00:41:29,119 --> 00:41:32,000
but i think that's part of the fun of

00:41:30,480 --> 00:41:33,599
you know what we get to do as developers

00:41:32,000 --> 00:41:34,880
of like let's imagine the crazy and see

00:41:33,599 --> 00:41:37,040
if it works and

00:41:34,880 --> 00:41:38,240
sometimes it's not as crazy as we think

00:41:37,040 --> 00:41:40,160
so uh

00:41:38,240 --> 00:41:42,560
just a couple minutes for questions here

00:41:40,160 --> 00:41:45,040
in the end so feel free to drop them in

00:41:42,560 --> 00:41:46,960
um it looks like there's one already

00:41:45,040 --> 00:41:48,160
around you know is there a pl python

00:41:46,960 --> 00:41:51,040
editor that does correct

00:41:48,160 --> 00:41:52,000
syntax highlighting that is a wonderful

00:41:51,040 --> 00:41:55,599
question

00:41:52,000 --> 00:41:57,119
um i would say write your pl python

00:41:55,599 --> 00:41:58,400
probably directly in your standard

00:41:57,119 --> 00:42:00,480
python editor

00:41:58,400 --> 00:42:02,000
um a lot of it you've got your you know

00:42:00,480 --> 00:42:02,800
function call kind of wrapper on the

00:42:02,000 --> 00:42:05,359
outside

00:42:02,800 --> 00:42:07,280
but then the rest of it is mostly just

00:42:05,359 --> 00:42:09,760
python and i would expect that to parse

00:42:07,280 --> 00:42:12,800
in a standard editor like a

00:42:09,760 --> 00:42:14,800
um like vs code or something like that

00:42:12,800 --> 00:42:16,079
but let me also go back and check i

00:42:14,800 --> 00:42:17,680
don't know that there's a place that i

00:42:16,079 --> 00:42:19,040
would say this is where i always edit my

00:42:17,680 --> 00:42:22,400
pl python

00:42:19,040 --> 00:42:24,160
um so uh

00:42:22,400 --> 00:42:25,599
i would try vs code and see how that

00:42:24,160 --> 00:42:28,319
works um

00:42:25,599 --> 00:42:28,319
and start there

00:42:29,520 --> 00:42:32,400
there is one comment roll tide i

00:42:31,119 --> 00:42:33,359
appreciate that i'm actually out in

00:42:32,400 --> 00:42:34,960
california

00:42:33,359 --> 00:42:37,040
i'm originally from alabama and i wear

00:42:34,960 --> 00:42:38,720
the head all the time if you see me

00:42:37,040 --> 00:42:40,480
maybe next year in person at all things

00:42:38,720 --> 00:42:42,079
open feel free to come say hi

00:42:40,480 --> 00:42:44,160
uh sorry to miss people in person this

00:42:42,079 --> 00:42:46,240
year but uh yeah i don't get a lot of

00:42:44,160 --> 00:42:53,920
roll tides out on the west coast so i do

00:42:46,240 --> 00:42:53,920

YouTube URL: https://www.youtube.com/watch?v=C5hd8HyC0YI


