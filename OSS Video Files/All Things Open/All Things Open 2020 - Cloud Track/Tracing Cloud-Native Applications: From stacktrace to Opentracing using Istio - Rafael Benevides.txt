Title: Tracing Cloud-Native Applications: From stacktrace to Opentracing using Istio - Rafael Benevides
Publication date: 2020-12-11
Playlist: All Things Open 2020 - Cloud Track
Description: 
	Presented by: Rafael Benevides, Oracle
Presented at All Things Open 2020 - Cloud Track

Abstract: We, developers, were used to debug applications on thread at a time. However, with the advent of microservices architectures, what used to be a single stack trace in a single machine became many stack traces spread among computers. Come to this session to see how to perform a distributed tracing in your application using Jaeger with Opentracing. In this presentation's demo we use Java and NodeJS and run them on containers using Kubernetes and Istio.
Captions: 
	00:00:05,040 --> 00:00:09,679
perfect let me start by

00:00:06,560 --> 00:00:13,519
sharing my screen so

00:00:09,679 --> 00:00:16,240
hold on a second yep

00:00:13,519 --> 00:00:17,039
and here we have my slides by the way if

00:00:16,240 --> 00:00:19,199
you want to have

00:00:17,039 --> 00:00:21,119
access to these slides at this moment

00:00:19,199 --> 00:00:25,279
you can go to this link here

00:00:21,119 --> 00:00:27,760
bitly slash cncf open tracing okay

00:00:25,279 --> 00:00:29,439
uh some information about me my name is

00:00:27,760 --> 00:00:32,559
rafael benavidez i work

00:00:29,439 --> 00:00:33,920
at oracle as a cloud native development

00:00:32,559 --> 00:00:37,360
advocate

00:00:33,920 --> 00:00:41,200
and essentially i'm a java developer

00:00:37,360 --> 00:00:44,239
with a little bit of passion for node.js

00:00:41,200 --> 00:00:47,760
okay so before

00:00:44,239 --> 00:00:50,879
starting let me tell you a story

00:00:47,760 --> 00:00:52,640
this story may uh sound a little bit

00:00:50,879 --> 00:00:57,039
familiar to you

00:00:52,640 --> 00:01:01,039
because in a in a

00:00:57,039 --> 00:01:04,879
in a not very distant past

00:01:01,039 --> 00:01:07,680
we what we saw on the i.t in industry

00:01:04,879 --> 00:01:08,720
is that developers were throwing their

00:01:07,680 --> 00:01:12,240
package their

00:01:08,720 --> 00:01:14,799
effects uh over the what's called

00:01:12,240 --> 00:01:16,000
wall of confusion so the ops was

00:01:14,799 --> 00:01:18,720
responsible

00:01:16,000 --> 00:01:19,439
to place the artifact on the on

00:01:18,720 --> 00:01:21,920
production

00:01:19,439 --> 00:01:24,159
and make it work and that worked very

00:01:21,920 --> 00:01:28,159
very well for many many years

00:01:24,159 --> 00:01:31,840
while the server was up right

00:01:28,159 --> 00:01:34,560
but everything went went fine

00:01:31,840 --> 00:01:36,000
until we received a message that the

00:01:34,560 --> 00:01:39,520
website is down

00:01:36,000 --> 00:01:40,079
when that happens everybody starts

00:01:39,520 --> 00:01:43,439
screaming

00:01:40,079 --> 00:01:46,000
thinking that is the end of the world so

00:01:43,439 --> 00:01:46,799
everybody starts to be in panic

00:01:46,000 --> 00:01:50,320
screaming

00:01:46,799 --> 00:01:53,840
and yelling uh what's happening uh

00:01:50,320 --> 00:01:56,399
who should we call who should we contact

00:01:53,840 --> 00:02:00,159
to fix that problem

00:01:56,399 --> 00:02:02,079
and of course the operation people say

00:02:00,159 --> 00:02:03,200
okay that's not a problem because we

00:02:02,079 --> 00:02:06,840
have monitory

00:02:03,200 --> 00:02:09,599
we are aware that the website is down

00:02:06,840 --> 00:02:11,920
okay uh

00:02:09,599 --> 00:02:12,720
it's it does not it does not solve the

00:02:11,920 --> 00:02:15,920
problem

00:02:12,720 --> 00:02:19,520
but what ops sees is

00:02:15,920 --> 00:02:22,560
that uh it's just a red

00:02:19,520 --> 00:02:25,040
flag on their dashboard they just

00:02:22,560 --> 00:02:26,480
they are just aware that something bad

00:02:25,040 --> 00:02:29,599
happens

00:02:26,480 --> 00:02:33,519
and what developers usually do in this

00:02:29,599 --> 00:02:36,160
uh in this situation calmly

00:02:33,519 --> 00:02:36,959
they ask to the opera to the operation

00:02:36,160 --> 00:02:40,400
people

00:02:36,959 --> 00:02:43,599
what does the log show and

00:02:40,400 --> 00:02:47,200
when they uh the ops people

00:02:43,599 --> 00:02:50,319
read the logs they see

00:02:47,200 --> 00:02:51,840
just a bunch of words just like in

00:02:50,319 --> 00:02:53,599
matrix

00:02:51,840 --> 00:02:55,040
they don't understand anything about the

00:02:53,599 --> 00:02:56,800
logs and

00:02:55,040 --> 00:02:58,319
at that moment you can imagine the

00:02:56,800 --> 00:03:00,720
developers screaming

00:02:58,319 --> 00:03:02,239
so show me the logs give me the logs so

00:03:00,720 --> 00:03:04,480
i can analyze them

00:03:02,239 --> 00:03:06,800
and then with the logs in their hands

00:03:04,480 --> 00:03:10,400
developers can

00:03:06,800 --> 00:03:12,480
easily analyze the stack trace and find

00:03:10,400 --> 00:03:15,440
the cause of the problem

00:03:12,480 --> 00:03:15,760
and it's just like matrix movie again

00:03:15,440 --> 00:03:19,360
the

00:03:15,760 --> 00:03:22,239
developers can see uh

00:03:19,360 --> 00:03:23,440
more than just words they see the real

00:03:22,239 --> 00:03:26,959
information behind

00:03:23,440 --> 00:03:29,280
all those characters on the screen

00:03:26,959 --> 00:03:30,400
that was what happened in the past but

00:03:29,280 --> 00:03:32,560
let's

00:03:30,400 --> 00:03:34,560
let's back to the present and see what's

00:03:32,560 --> 00:03:37,840
happening what's happening now

00:03:34,560 --> 00:03:40,319
in the id industry well

00:03:37,840 --> 00:03:41,120
first of all what's very important is

00:03:40,319 --> 00:03:43,519
that

00:03:41,120 --> 00:03:44,640
death and ops are working together there

00:03:43,519 --> 00:03:47,280
is no more

00:03:44,640 --> 00:03:48,319
more the wall of confusion there are

00:03:47,280 --> 00:03:51,360
there are no more

00:03:48,319 --> 00:03:54,640
silos that they that places them

00:03:51,360 --> 00:03:57,360
apart that's really important and what

00:03:54,640 --> 00:03:57,920
and another thing that changed is that

00:03:57,360 --> 00:04:01,360
we are

00:03:57,920 --> 00:04:04,400
seeing microservices we are seeing

00:04:01,360 --> 00:04:05,200
cloud native applications and those

00:04:04,400 --> 00:04:07,439
applications

00:04:05,200 --> 00:04:08,480
those microservices they don't reside

00:04:07,439 --> 00:04:11,680
together

00:04:08,480 --> 00:04:16,560
on a single server instead they are

00:04:11,680 --> 00:04:19,199
spread over a network of services

00:04:16,560 --> 00:04:19,919
connected to each other talking to each

00:04:19,199 --> 00:04:23,440
other

00:04:19,919 --> 00:04:26,720
and of course some of them

00:04:23,440 --> 00:04:29,520
they have their own database okay so

00:04:26,720 --> 00:04:30,960
what we saw in the old school is a

00:04:29,520 --> 00:04:33,120
monolithic application

00:04:30,960 --> 00:04:34,400
in in this new school we see

00:04:33,120 --> 00:04:38,400
microservices

00:04:34,400 --> 00:04:41,440
uh deployed inside containers uh

00:04:38,400 --> 00:04:44,639
running on top of kubernetes as they are

00:04:41,440 --> 00:04:47,840
uh orchestration platform okay

00:04:44,639 --> 00:04:48,479
but some things never change like for

00:04:47,840 --> 00:04:52,800
example

00:04:48,479 --> 00:04:56,880
we still have more monitoring and

00:04:52,800 --> 00:05:00,639
that still still works very well

00:04:56,880 --> 00:05:04,000
but we don't call a monitoring anymore

00:05:00,639 --> 00:05:06,400
it's now the the word that we see

00:05:04,000 --> 00:05:07,280
is observability and i think that's

00:05:06,400 --> 00:05:10,960
really nice

00:05:07,280 --> 00:05:14,080
this tweeter from cindy

00:05:10,960 --> 00:05:16,639
uh it's it says

00:05:14,080 --> 00:05:18,000
observability because devs don't like to

00:05:16,639 --> 00:05:20,479
do monitoring

00:05:18,000 --> 00:05:22,160
we need to package it in a new normal

00:05:20,479 --> 00:05:25,440
clip normal collector

00:05:22,160 --> 00:05:28,800
to make it palatable and trendy so

00:05:25,440 --> 00:05:31,840
uh what we see nowadays about

00:05:28,800 --> 00:05:33,280
uh oops uh about monitoring is that it's

00:05:31,840 --> 00:05:36,800
called observability

00:05:33,280 --> 00:05:38,000
but in fact observability is more than

00:05:36,800 --> 00:05:41,360
just monitoring

00:05:38,000 --> 00:05:44,560
it it consists on three pillars uh

00:05:41,360 --> 00:05:48,240
it consists of metrics it consists of

00:05:44,560 --> 00:05:50,960
logging and it consists of tracing

00:05:48,240 --> 00:05:52,560
and the focus of this presentation is

00:05:50,960 --> 00:05:54,720
about tracing

00:05:52,560 --> 00:05:55,840
okay because for example suppose that

00:05:54,720 --> 00:05:59,120
you see

00:05:55,840 --> 00:06:02,240
this uh this diagram

00:05:59,120 --> 00:06:04,800
in your screen can you

00:06:02,240 --> 00:06:06,240
spot the invocation order suppose that

00:06:04,800 --> 00:06:09,039
you don't see these numbers here

00:06:06,240 --> 00:06:10,080
one two three four five six seven eight

00:06:09,039 --> 00:06:13,840
can you

00:06:10,080 --> 00:06:16,880
uh just guess the order or the latest

00:06:13,840 --> 00:06:20,000
latency how how long it took to execute

00:06:16,880 --> 00:06:23,199
how each one of these microservices

00:06:20,000 --> 00:06:26,960
or these components or in a

00:06:23,199 --> 00:06:29,120
cause of an error who caused that error

00:06:26,960 --> 00:06:30,720
okay of course if you change that

00:06:29,120 --> 00:06:33,680
diagram just a little bit

00:06:30,720 --> 00:06:35,440
and transform that in a timeline view

00:06:33,680 --> 00:06:38,000
things will get more clear

00:06:35,440 --> 00:06:38,800
you can see now in this timeline view

00:06:38,000 --> 00:06:43,360
how long

00:06:38,800 --> 00:06:44,800
it took to invoke each component um

00:06:43,360 --> 00:06:47,840
you can see that there are no no

00:06:44,800 --> 00:06:50,400
warehouse it's a serial invocation

00:06:47,840 --> 00:06:52,479
and each one of them were called we can

00:06:50,400 --> 00:06:55,360
see how long it took

00:06:52,479 --> 00:06:57,039
and we saw the order how long and that

00:06:55,360 --> 00:07:00,080
there are no no waivers

00:06:57,039 --> 00:07:02,160
so tracing isn't very important to

00:07:00,080 --> 00:07:04,240
understand your application you can

00:07:02,160 --> 00:07:06,960
understand the critical path

00:07:04,240 --> 00:07:08,479
you can understand the latency and in a

00:07:06,960 --> 00:07:12,080
case of failure

00:07:08,479 --> 00:07:16,400
you can understand why did it fail

00:07:12,080 --> 00:07:18,639
why it failed okay and the

00:07:16,400 --> 00:07:20,240
as i said the focus of this present this

00:07:18,639 --> 00:07:23,120
presentation is tracing

00:07:20,240 --> 00:07:25,120
and i will talk about open tracing so

00:07:23,120 --> 00:07:26,000
what is the open trade or what is open

00:07:25,120 --> 00:07:28,720
tracing

00:07:26,000 --> 00:07:29,440
open tracing is is a specification

00:07:28,720 --> 00:07:31,440
developed

00:07:29,440 --> 00:07:32,639
to address the problem of api

00:07:31,440 --> 00:07:34,800
incompatibility

00:07:32,639 --> 00:07:36,639
between different distributing tracing

00:07:34,800 --> 00:07:39,120
systems there there were

00:07:36,639 --> 00:07:40,639
many initiatives to to perform

00:07:39,120 --> 00:07:44,800
distributed tracing

00:07:40,639 --> 00:07:46,720
the we can mention zipking jagger

00:07:44,800 --> 00:07:48,400
there are many others that i can't

00:07:46,720 --> 00:07:51,520
recall at this moment

00:07:48,400 --> 00:07:54,960
but the idea is to create a unique

00:07:51,520 --> 00:07:57,919
api and this api

00:07:54,960 --> 00:07:59,360
was specified and became what's called

00:07:57,919 --> 00:08:01,680
open tracing

00:07:59,360 --> 00:08:03,759
open tracing is the specification the

00:08:01,680 --> 00:08:07,360
open tracing specification is part

00:08:03,759 --> 00:08:07,840
of cncf and the idea of the api is to

00:08:07,360 --> 00:08:10,960
have

00:08:07,840 --> 00:08:14,400
no relation to platforms or vendors

00:08:10,960 --> 00:08:16,560
okay but to understand the open trace

00:08:14,400 --> 00:08:17,759
specification we need to understand some

00:08:16,560 --> 00:08:20,879
terminologies

00:08:17,759 --> 00:08:25,199
like for example what is a trace

00:08:20,879 --> 00:08:27,599
so a trace is is for example a click

00:08:25,199 --> 00:08:29,280
on a button when you click on a button

00:08:27,599 --> 00:08:33,039
it will spam

00:08:29,280 --> 00:08:33,839
several operations that is a single

00:08:33,039 --> 00:08:37,039
trace

00:08:33,839 --> 00:08:40,000
so the trace covers this that request

00:08:37,039 --> 00:08:41,839
across all services each touch it

00:08:40,000 --> 00:08:42,640
consists of the all dispense for the

00:08:41,839 --> 00:08:45,920
request

00:08:42,640 --> 00:08:48,959
okay so what is a spam well

00:08:45,920 --> 00:08:52,160
they spam is basically

00:08:48,959 --> 00:08:55,279
the operation so it consists of the

00:08:52,160 --> 00:08:56,959
the operation name they start and finish

00:08:55,279 --> 00:09:00,560
timestamps

00:08:56,959 --> 00:09:01,200
tags logs and a reference so what is a

00:09:00,560 --> 00:09:05,200
reference

00:09:01,200 --> 00:09:08,640
is a relationship with other spans

00:09:05,200 --> 00:09:10,959
how so uh span relationships

00:09:08,640 --> 00:09:12,959
well we can have parallel invocation so

00:09:10,959 --> 00:09:15,600
a reference

00:09:12,959 --> 00:09:16,480
from one span to another will be the

00:09:15,600 --> 00:09:19,600
child off

00:09:16,480 --> 00:09:23,040
so i spent can have multiple children

00:09:19,600 --> 00:09:26,320
so each span will be child of

00:09:23,040 --> 00:09:26,959
a parent's pen so usually it's made for

00:09:26,320 --> 00:09:30,240
parallel

00:09:26,959 --> 00:09:31,440
invocation or a serial invocation can be

00:09:30,240 --> 00:09:35,200
follows from

00:09:31,440 --> 00:09:38,399
so i spend will be will follows from

00:09:35,200 --> 00:09:39,920
another spam so that's a a relationship

00:09:38,399 --> 00:09:43,120
for a spam

00:09:39,920 --> 00:09:46,640
well i said that expanse contains

00:09:43,120 --> 00:09:50,480
uh contained logs so what is aspen logs

00:09:46,640 --> 00:09:53,920
well it's a just it's a key value pair

00:09:50,480 --> 00:09:57,600
that just like the name says gives you

00:09:53,920 --> 00:10:00,000
uh log information for so for example uh

00:09:57,600 --> 00:10:02,800
message opening a connection to my sql

00:10:00,000 --> 00:10:02,800
server at

00:10:02,839 --> 00:10:06,320
127.001 or can't connect to my sql

00:10:05,440 --> 00:10:09,519
server

00:10:06,320 --> 00:10:12,880
uh and their error message so

00:10:09,519 --> 00:10:15,279
again this the log is used for

00:10:12,880 --> 00:10:16,000
a debugging purpose or information

00:10:15,279 --> 00:10:17,760
purpose

00:10:16,000 --> 00:10:20,000
for the for the application or for the

00:10:17,760 --> 00:10:24,079
tracing itself

00:10:20,000 --> 00:10:26,640
you can also create tags tags are also

00:10:24,079 --> 00:10:27,440
a key value pair but they are user

00:10:26,640 --> 00:10:29,680
defined

00:10:27,440 --> 00:10:30,560
there there is a semantic convention let

00:10:29,680 --> 00:10:33,680
me open it

00:10:30,560 --> 00:10:36,560
here for you so you can see that

00:10:33,680 --> 00:10:38,000
you can have a tag called component

00:10:36,560 --> 00:10:40,480
which the type is string

00:10:38,000 --> 00:10:42,480
and you can say what is the component

00:10:40,480 --> 00:10:45,200
that performs that operation

00:10:42,480 --> 00:10:48,399
or the b instance the b statement the b

00:10:45,200 --> 00:10:51,519
type is it the sequel cassandra h bass

00:10:48,399 --> 00:10:52,320
reddish the b user there her message or

00:10:51,519 --> 00:10:55,519
the oh

00:10:52,320 --> 00:10:58,560
sorry the error is it true or false

00:10:55,519 --> 00:11:02,000
the htp method and so on so here you

00:10:58,560 --> 00:11:05,040
you can see some examples of

00:11:02,000 --> 00:11:07,440
tags again you have the key

00:11:05,040 --> 00:11:08,399
which is the which follows a semantic

00:11:07,440 --> 00:11:11,040
convention

00:11:08,399 --> 00:11:11,600
and the value which specifies what is

00:11:11,040 --> 00:11:13,760
the db

00:11:11,600 --> 00:11:14,959
instance what is the http method or

00:11:13,760 --> 00:11:18,640
status code or

00:11:14,959 --> 00:11:22,160
error and so on okay

00:11:18,640 --> 00:11:24,640
and you can have also a baggage which is

00:11:22,160 --> 00:11:26,839
also key value pair but the idea of the

00:11:24,640 --> 00:11:28,399
baggage is that you can place an

00:11:26,839 --> 00:11:30,880
information on an

00:11:28,399 --> 00:11:32,399
up on a specific operation and then you

00:11:30,880 --> 00:11:35,920
can capture

00:11:32,399 --> 00:11:38,800
that information in another operation

00:11:35,920 --> 00:11:39,839
so it's a cross pro across process

00:11:38,800 --> 00:11:43,680
boundaries

00:11:39,839 --> 00:11:44,160
okay so here you have an example of a

00:11:43,680 --> 00:11:46,800
span

00:11:44,160 --> 00:11:48,880
so we have operation name db query so we

00:11:46,800 --> 00:11:53,200
have an idea that it performs

00:11:48,880 --> 00:11:56,320
a database query you have a timespan

00:11:53,200 --> 00:11:58,720
timestamp for the time that it begun

00:11:56,320 --> 00:11:59,600
or in the time that it finished you have

00:11:58,720 --> 00:12:02,399
the tags

00:11:59,600 --> 00:12:02,720
so you can see here that this instance

00:12:02,399 --> 00:12:05,839
is

00:12:02,720 --> 00:12:08,160
customers and this statement was select

00:12:05,839 --> 00:12:10,639
from my table where full equals bar

00:12:08,160 --> 00:12:12,639
you'll have the log message so in this

00:12:10,639 --> 00:12:15,120
case we know that this operation

00:12:12,639 --> 00:12:16,160
uh we're not able to complete because it

00:12:15,120 --> 00:12:18,959
could not connect

00:12:16,160 --> 00:12:20,800
connect to my sql server you have also

00:12:18,959 --> 00:12:24,639
the spam context

00:12:20,800 --> 00:12:27,760
so what is the trace id that uh

00:12:24,639 --> 00:12:30,639
what is this span id and also though the

00:12:27,760 --> 00:12:32,240
the baggage items that you will someone

00:12:30,639 --> 00:12:36,240
the developer places

00:12:32,240 --> 00:12:39,360
in this spam okay well

00:12:36,240 --> 00:12:39,920
so if open tracing is a specification we

00:12:39,360 --> 00:12:42,959
need

00:12:39,920 --> 00:12:46,480
an implementation in this

00:12:42,959 --> 00:12:49,600
talk i will use jagger

00:12:46,480 --> 00:12:52,320
uh jagger was inspired by dave dapper

00:12:49,600 --> 00:12:54,000
and open zip thinking open zipkin and

00:12:52,320 --> 00:12:57,120
it's a distributed system released

00:12:54,000 --> 00:12:59,920
and as an open source by uber

00:12:57,120 --> 00:13:01,680
uh open trade uh it's open tracing

00:12:59,920 --> 00:13:04,079
compatible as i said it's an

00:13:01,680 --> 00:13:05,600
implementation of open tracing and there

00:13:04,079 --> 00:13:10,160
are several libraries like

00:13:05,600 --> 00:13:13,519
gold java node python and c plus plus

00:13:10,160 --> 00:13:16,240
look here the architecture of jagger

00:13:13,519 --> 00:13:16,720
so you have your application and you

00:13:16,240 --> 00:13:20,000
will

00:13:16,720 --> 00:13:21,839
use a jagger client on depending of the

00:13:20,000 --> 00:13:24,079
language of your application so if you

00:13:21,839 --> 00:13:27,839
wrote a java application you

00:13:24,079 --> 00:13:28,639
you will use a java client a jagger

00:13:27,839 --> 00:13:31,760
client

00:13:28,639 --> 00:13:35,600
or a node jagger client this

00:13:31,760 --> 00:13:39,600
jagger client will send the expense

00:13:35,600 --> 00:13:42,560
through a udp through the udp protocol

00:13:39,600 --> 00:13:43,199
to a jagger agent the jagger agent will

00:13:42,560 --> 00:13:45,680
collect

00:13:43,199 --> 00:13:46,480
those spams and send it to the jagger

00:13:45,680 --> 00:13:48,720
collector

00:13:46,480 --> 00:13:49,519
the jagger collector restored that up

00:13:48,720 --> 00:13:52,160
they they

00:13:49,519 --> 00:13:54,720
expands uh in a database that's

00:13:52,160 --> 00:13:57,839
maintained by the spark jobs

00:13:54,720 --> 00:14:01,440
and there is also a jagger query

00:13:57,839 --> 00:14:05,279
that gives you an ui so you can

00:14:01,440 --> 00:14:09,519
consume those information okay

00:14:05,279 --> 00:14:12,800
and why jagger uh

00:14:09,519 --> 00:14:14,160
people who used to uh work with

00:14:12,800 --> 00:14:18,160
distributed systems

00:14:14,160 --> 00:14:21,199
they they saw zipkin uh

00:14:18,160 --> 00:14:23,440
much more than jagger and the answer is

00:14:21,199 --> 00:14:26,079
here that i took from this blog post

00:14:23,440 --> 00:14:28,000
despite zipping being around for a while

00:14:26,079 --> 00:14:30,240
longer and being more mature

00:14:28,000 --> 00:14:32,959
jagger has seen some good adoption

00:14:30,240 --> 00:14:36,240
thanks to several factors such as a good

00:14:32,959 --> 00:14:37,360
language covered coverage of open trades

00:14:36,240 --> 00:14:40,639
compatible clients

00:14:37,360 --> 00:14:44,560
as we saw go java node

00:14:40,639 --> 00:14:48,000
c plus plus python low memory footprint

00:14:44,560 --> 00:14:48,560
in a modern and modern and scalable

00:14:48,000 --> 00:14:51,440
design

00:14:48,560 --> 00:14:52,160
as we saw here so that's why i'm

00:14:51,440 --> 00:14:55,760
focusing

00:14:52,160 --> 00:14:59,040
on jagger as an implementation so

00:14:55,760 --> 00:14:59,680
my favorite part of the this talk is to

00:14:59,040 --> 00:15:03,279
show

00:14:59,680 --> 00:15:06,240
a demo and for the demo i will open here

00:15:03,279 --> 00:15:07,199
the jagger ui so you can see this is the

00:15:06,240 --> 00:15:10,480
jagger ui

00:15:07,199 --> 00:15:11,120
and i will perform an invocation on an

00:15:10,480 --> 00:15:13,360
end point

00:15:11,120 --> 00:15:14,560
i will not explain to you what this

00:15:13,360 --> 00:15:17,760
endpoint is doing

00:15:14,560 --> 00:15:19,839
because i want you to follow me and

00:15:17,760 --> 00:15:22,639
analyze the tracing information

00:15:19,839 --> 00:15:24,000
and then we will figure out what this

00:15:22,639 --> 00:15:26,480
the application is doing

00:15:24,000 --> 00:15:27,519
okay so i invoked i invoked the end

00:15:26,480 --> 00:15:29,920
point

00:15:27,519 --> 00:15:31,120
so you can see here microservice a

00:15:29,920 --> 00:15:34,240
received the parameter

00:15:31,120 --> 00:15:37,440
raphael called microserve b saved

00:15:34,240 --> 00:15:39,839
database saved to kafka and invoked

00:15:37,440 --> 00:15:40,959
the microsoft c that says real hello

00:15:39,839 --> 00:15:43,360
rafael

00:15:40,959 --> 00:15:45,279
let's see it's that information so here

00:15:43,360 --> 00:15:46,800
in the jagger ui

00:15:45,279 --> 00:15:48,880
we can analyze for example the

00:15:46,800 --> 00:15:52,880
dependencies we can see that

00:15:48,880 --> 00:15:55,199
microservice a called microservice b

00:15:52,880 --> 00:15:56,240
microservice a called 12 times

00:15:55,199 --> 00:15:59,199
microservices b

00:15:56,240 --> 00:16:00,560
and microservice b called microsoft c

00:15:59,199 --> 00:16:04,560
four times so we can

00:16:00,560 --> 00:16:08,240
see uh this diagram okay

00:16:04,560 --> 00:16:10,800
uh and then we have here the services

00:16:08,240 --> 00:16:11,680
we have microsoft a b and c let's start

00:16:10,800 --> 00:16:14,880
by microsoft

00:16:11,680 --> 00:16:18,000
a i can uh filter by

00:16:14,880 --> 00:16:21,120
operations let me bring everything

00:16:18,000 --> 00:16:22,880
i can bring what has been captured the

00:16:21,120 --> 00:16:26,000
last hour last two hours

00:16:22,880 --> 00:16:28,560
last 24 hours and so on

00:16:26,000 --> 00:16:29,519
so let me keep less the hour and give me

00:16:28,560 --> 00:16:32,959
the

00:16:29,519 --> 00:16:35,759
limit of 20 results so i have here

00:16:32,959 --> 00:16:36,560
i did some tests before starting my the

00:16:35,759 --> 00:16:38,959
presentation

00:16:36,560 --> 00:16:42,079
and i have here the invocation that i

00:16:38,959 --> 00:16:45,519
just performed

00:16:42,079 --> 00:16:47,440
if i click in this http request we can

00:16:45,519 --> 00:16:50,560
analyze the application here

00:16:47,440 --> 00:16:53,680
we can see that microservice

00:16:50,560 --> 00:16:56,560
a received uh

00:16:53,680 --> 00:16:57,519
request in this path slash serials live

00:16:56,560 --> 00:17:01,040
raphael

00:16:57,519 --> 00:17:02,800
it it did work because we have a http

00:17:01,040 --> 00:17:06,000
status code of 200.

00:17:02,800 --> 00:17:06,319
the component invoked here was the held

00:17:06,000 --> 00:17:09,439
on

00:17:06,319 --> 00:17:12,799
web server and we have some

00:17:09,439 --> 00:17:14,640
log information that was uh captured by

00:17:12,799 --> 00:17:18,480
these handles here

00:17:14,640 --> 00:17:21,679
okay then we have uh some other

00:17:18,480 --> 00:17:24,559
interceptors security interceptors and

00:17:21,679 --> 00:17:27,439
finally my the class that i wrote which

00:17:24,559 --> 00:17:30,240
is called.rafabani dot resource

00:17:27,439 --> 00:17:31,440
and the method is serial received the

00:17:30,240 --> 00:17:35,360
request

00:17:31,440 --> 00:17:38,400
on its jaxx rs server so we know that

00:17:35,360 --> 00:17:41,840
it's a java application using the jax

00:17:38,400 --> 00:17:46,400
rs rs which is an api for

00:17:41,840 --> 00:17:49,520
rest resources on the server and then

00:17:46,400 --> 00:17:52,559
before calling the microservice b we had

00:17:49,520 --> 00:17:56,640
we had that class and this method

00:17:52,559 --> 00:17:56,640
calling another method

00:17:56,799 --> 00:18:04,160
uh called call microservice vis serial

00:18:00,799 --> 00:18:07,760
then we have an interceptor and we have

00:18:04,160 --> 00:18:10,880
the jax is client invoking this

00:18:07,760 --> 00:18:14,559
endpoint microservice b 8080 slash db

00:18:10,880 --> 00:18:17,200
slash raphael interceptor for microsoft

00:18:14,559 --> 00:18:18,720
a and then finally microservice b

00:18:17,200 --> 00:18:21,120
received the request

00:18:18,720 --> 00:18:22,000
on the java web servlet so we know that

00:18:21,120 --> 00:18:24,400
microservice b

00:18:22,000 --> 00:18:29,039
was written in java because the java

00:18:24,400 --> 00:18:31,679
server received the request um

00:18:29,039 --> 00:18:33,440
and then we performed some opera some

00:18:31,679 --> 00:18:36,640
database operation here

00:18:33,440 --> 00:18:39,919
we can see here that even the

00:18:36,640 --> 00:18:43,280
database calls were traced

00:18:39,919 --> 00:18:44,160
so we have a component java jdbc we have

00:18:43,280 --> 00:18:46,559
the

00:18:44,160 --> 00:18:48,400
database instance called open tracing

00:18:46,559 --> 00:18:49,760
and we can see here that it's a my

00:18:48,400 --> 00:18:52,880
sequel so we know that

00:18:49,760 --> 00:18:57,360
this the information was the database

00:18:52,880 --> 00:19:00,160
behind this application is a mysql

00:18:57,360 --> 00:19:02,000
and the statement is here select next

00:19:00,160 --> 00:19:04,480
ball from hibernate sequence for

00:19:02,000 --> 00:19:06,320
update so again we know that this

00:19:04,480 --> 00:19:09,760
application is a java

00:19:06,320 --> 00:19:13,360
using my sequel connected through

00:19:09,760 --> 00:19:14,559
hibernate then we called the update

00:19:13,360 --> 00:19:17,919
sequence

00:19:14,559 --> 00:19:20,799
and finally even the insert

00:19:17,919 --> 00:19:22,080
into message the values we can see it

00:19:20,799 --> 00:19:26,240
here

00:19:22,080 --> 00:19:29,520
okay uh let me see what else i can

00:19:26,240 --> 00:19:32,960
i can find it here

00:19:29,520 --> 00:19:35,919
oh for example uh i also place it

00:19:32,960 --> 00:19:36,960
in the microservice a a log information

00:19:35,919 --> 00:19:39,919
so i can

00:19:36,960 --> 00:19:40,320
even open here the log the parameter

00:19:39,919 --> 00:19:42,960
that i

00:19:40,320 --> 00:19:44,640
received is raphael so i placed that

00:19:42,960 --> 00:19:48,080
information for log purpose

00:19:44,640 --> 00:19:50,480
so i can uh make sure i can make

00:19:48,080 --> 00:19:52,799
uh make sure that i'm working on the

00:19:50,480 --> 00:19:55,280
proper requests

00:19:52,799 --> 00:19:56,080
and then after invoking the microservice

00:19:55,280 --> 00:19:58,640
b

00:19:56,080 --> 00:19:59,440
we have microservice microservice a

00:19:58,640 --> 00:20:02,400
calling b

00:19:59,440 --> 00:20:03,280
again but another endpoint this endpoint

00:20:02,400 --> 00:20:06,880
here

00:20:03,280 --> 00:20:09,440
calls a kafika topic so

00:20:06,880 --> 00:20:11,039
we have a component here called java

00:20:09,440 --> 00:20:13,919
kafka

00:20:11,039 --> 00:20:14,720
i'm using i'm producing a message and

00:20:13,919 --> 00:20:17,760
place it

00:20:14,720 --> 00:20:21,120
placing it in a topic called

00:20:17,760 --> 00:20:25,360
my topic and finally microsoft's

00:20:21,120 --> 00:20:26,000
b called microsoft c so we can see it

00:20:25,360 --> 00:20:28,240
here

00:20:26,000 --> 00:20:29,600
the server receiving the requests we

00:20:28,240 --> 00:20:33,280
have the logs

00:20:29,600 --> 00:20:36,320
request received event hello

00:20:33,280 --> 00:20:39,280
rafael and that gives

00:20:36,320 --> 00:20:39,679
give us an a really nice idea of what

00:20:39,280 --> 00:20:42,240
this

00:20:39,679 --> 00:20:44,240
application is doing microservice a

00:20:42,240 --> 00:20:45,760
calls microsoft b and saves to database

00:20:44,240 --> 00:20:47,840
microservice a

00:20:45,760 --> 00:20:50,000
calls microservice b and save to kafka

00:20:47,840 --> 00:20:51,600
and microservice a calls microservice b

00:20:50,000 --> 00:20:54,320
that calls microsoft c

00:20:51,600 --> 00:20:56,640
only by looking at this information we

00:20:54,320 --> 00:20:59,919
can have that idea

00:20:56,640 --> 00:21:00,880
i will do something interesting here i

00:20:59,919 --> 00:21:03,840
will

00:21:00,880 --> 00:21:04,720
stop a service because i started all

00:21:03,840 --> 00:21:07,840
those servers

00:21:04,720 --> 00:21:10,960
here using docker compose so you can

00:21:07,840 --> 00:21:13,840
can see here microservice a b

00:21:10,960 --> 00:21:16,000
and c we have my sequel and we have a

00:21:13,840 --> 00:21:19,919
kafka and we have jagger

00:21:16,000 --> 00:21:22,640
using the all-in-one linux image

00:21:19,919 --> 00:21:23,919
this image runs all those uh

00:21:22,640 --> 00:21:26,960
architectures part of

00:21:23,919 --> 00:21:29,039
their of jagger in a single image so let

00:21:26,960 --> 00:21:32,480
me stop here

00:21:29,039 --> 00:21:36,400
docker compose is called my sequel okay

00:21:32,480 --> 00:21:39,200
let's see what what happens if my sequel

00:21:36,400 --> 00:21:39,200
is stopped

00:21:40,320 --> 00:21:44,159
so now my sql is stopped let's perform a

00:21:43,120 --> 00:21:47,600
request

00:21:44,159 --> 00:21:48,159
in our endpoint there is a timeout that

00:21:47,600 --> 00:21:52,559
i placed

00:21:48,159 --> 00:21:52,559
on microservice a so microserver a

00:21:53,039 --> 00:21:59,440
gives me a timeout

00:21:56,880 --> 00:22:00,880
but microservice b is still is still

00:21:59,440 --> 00:22:04,159
trying to connect

00:22:00,880 --> 00:22:06,159
to to

00:22:04,159 --> 00:22:07,280
to my sequel you can see it's in the log

00:22:06,159 --> 00:22:09,679
information

00:22:07,280 --> 00:22:10,480
so what we see here is the microservice

00:22:09,679 --> 00:22:14,000
a only

00:22:10,480 --> 00:22:14,240
because b is uh is still working but if

00:22:14,000 --> 00:22:18,960
i

00:22:14,240 --> 00:22:23,120
update uh now we have microsoft's b

00:22:18,960 --> 00:22:25,280
called uh because it report finally

00:22:23,120 --> 00:22:26,159
gave up of trying to connect to my

00:22:25,280 --> 00:22:29,280
sequel

00:22:26,159 --> 00:22:31,760
now we can see that this invocation

00:22:29,280 --> 00:22:33,280
happened with an error so there are four

00:22:31,760 --> 00:22:36,640
errors here

00:22:33,280 --> 00:22:39,679
and that it's really nice to debug or to

00:22:36,640 --> 00:22:42,240
monitor our application so

00:22:39,679 --> 00:22:42,880
if something went wrong we can find what

00:22:42,240 --> 00:22:45,919
gives the

00:22:42,880 --> 00:22:47,760
give us an error and we can open and see

00:22:45,919 --> 00:22:51,039
all those four errors here

00:22:47,760 --> 00:22:54,400
i have the general error which

00:22:51,039 --> 00:22:59,440
was the http 500 which i received here

00:22:54,400 --> 00:22:59,440
xp 500 i also have

00:22:59,679 --> 00:23:07,039
my error where my jax is component tried

00:23:03,520 --> 00:23:09,919
tried to connect and of course

00:23:07,039 --> 00:23:10,880
there was uh a processing exception

00:23:09,919 --> 00:23:14,080
because i placed

00:23:10,880 --> 00:23:17,390
a timeout and microservice be

00:23:14,080 --> 00:23:18,799
tried to connect to to

00:23:17,390 --> 00:23:21,280
[Music]

00:23:18,799 --> 00:23:22,640
my sql but in this case suppose that i

00:23:21,280 --> 00:23:25,760
don't know that my sequel is

00:23:22,640 --> 00:23:29,200
is stopped i can even come here

00:23:25,760 --> 00:23:32,559
to the log message and see here

00:23:29,200 --> 00:23:35,039
that uh there is a

00:23:32,559 --> 00:23:35,600
gdbc connection exception enable which

00:23:35,039 --> 00:23:39,760
acquires

00:23:35,600 --> 00:23:42,000
jdbc connection and could not open gpa

00:23:39,760 --> 00:23:45,039
hd manager

00:23:42,000 --> 00:23:45,039
and what else

00:23:46,960 --> 00:23:51,039
unable to acquire jdbc connection

00:23:49,120 --> 00:23:52,960
connection not available communication

00:23:51,039 --> 00:23:55,520
link failure

00:23:52,960 --> 00:23:56,240
communication link failure my sequel

00:23:55,520 --> 00:23:59,600
name on

00:23:56,240 --> 00:24:02,159
ourselves not known so

00:23:59,600 --> 00:24:04,159
again we are able to really really

00:24:02,159 --> 00:24:06,960
really understand what the

00:24:04,159 --> 00:24:08,400
application is doing inside debugging

00:24:06,960 --> 00:24:11,520
the application itself because

00:24:08,400 --> 00:24:14,960
it was really well traced by

00:24:11,520 --> 00:24:18,320
uh the open tracing

00:24:14,960 --> 00:24:23,919
api let's start

00:24:18,320 --> 00:24:23,919
mysql again let's perform a new request

00:24:24,480 --> 00:24:30,960
okay everything's working

00:24:27,840 --> 00:24:34,960
and we can see now that the new trace

00:24:30,960 --> 00:24:38,080
has no errors okay that gives you an

00:24:34,960 --> 00:24:42,000
idea but i believe that you might be

00:24:38,080 --> 00:24:43,919
interested on understand how to use the

00:24:42,000 --> 00:24:46,159
open tracing api

00:24:43,919 --> 00:24:47,840
well it's really easy to all use the

00:24:46,159 --> 00:24:49,520
open tracing api

00:24:47,840 --> 00:24:51,919
first you need to instantiate

00:24:49,520 --> 00:24:54,080
instantiate a tracer

00:24:51,919 --> 00:24:55,840
different there are different approaches

00:24:54,080 --> 00:24:57,919
by language or framework

00:24:55,840 --> 00:25:00,080
so once that you have a tracer to create

00:24:57,919 --> 00:25:03,279
a spam you will use tracer

00:25:00,080 --> 00:25:04,240
pawn dot build span with the name of the

00:25:03,279 --> 00:25:07,760
operation and

00:25:04,240 --> 00:25:11,440
start active to make that span active

00:25:07,760 --> 00:25:14,799
in a tread local context so they span

00:25:11,440 --> 00:25:17,440
uh it will be the same while until you

00:25:14,799 --> 00:25:18,559
you finish this pan and while you are in

00:25:17,440 --> 00:25:20,240
the same thread

00:25:18,559 --> 00:25:22,720
while you are in the same thread the

00:25:20,240 --> 00:25:26,000
span context is the same

00:25:22,720 --> 00:25:28,480
to create a tag or a log you will call

00:25:26,000 --> 00:25:29,679
the method setpack with the name of the

00:25:28,480 --> 00:25:33,919
tag and the value

00:25:29,679 --> 00:25:36,480
or log with the uh the log information

00:25:33,919 --> 00:25:38,799
to work with baggage items you can call

00:25:36,480 --> 00:25:41,440
set baggage item or get back

00:25:38,799 --> 00:25:42,240
item and at the end of the operation you

00:25:41,440 --> 00:25:45,760
will call

00:25:42,240 --> 00:25:49,440
spam dot finish when you finish the spam

00:25:45,760 --> 00:25:52,559
the api will send the spam to the jagger

00:25:49,440 --> 00:25:52,559
agent okay

00:25:55,200 --> 00:26:01,600
well but you saw that uh

00:25:58,559 --> 00:26:04,320
this this pen context

00:26:01,600 --> 00:26:05,440
has been propagated from a service a to

00:26:04,320 --> 00:26:07,520
a service b

00:26:05,440 --> 00:26:09,039
how that was possible if i just said

00:26:07,520 --> 00:26:11,919
that the expand context

00:26:09,039 --> 00:26:13,039
is thread local well you can propagate

00:26:11,919 --> 00:26:16,799
the context

00:26:13,039 --> 00:26:20,159
by using some http headers

00:26:16,799 --> 00:26:24,080
the default is to use the

00:26:20,159 --> 00:26:25,279
uh one of the first implementations that

00:26:24,080 --> 00:26:29,360
came from zipton

00:26:25,279 --> 00:26:32,000
is to use the b3 headers so uh

00:26:29,360 --> 00:26:32,799
a client tracer before calling the next

00:26:32,000 --> 00:26:36,240
server

00:26:32,799 --> 00:26:37,279
it injects in the request of all those

00:26:36,240 --> 00:26:40,480
headers here

00:26:37,279 --> 00:26:43,760
xb3 trace id xb3 pattern span id

00:26:40,480 --> 00:26:46,640
dispen id and samples and then when the

00:26:43,760 --> 00:26:47,679
server tracer receives the request it

00:26:46,640 --> 00:26:50,320
extracts

00:26:47,679 --> 00:26:52,880
the information and then it knows the

00:26:50,320 --> 00:26:53,919
trace id parent span id is an id and so

00:26:52,880 --> 00:26:57,760
on

00:26:53,919 --> 00:27:00,240
okay but there are there's also another

00:26:57,760 --> 00:27:02,080
format here which is the uber headers

00:27:00,240 --> 00:27:03,600
which is much more simple you have just

00:27:02,080 --> 00:27:06,799
one header called

00:27:03,600 --> 00:27:10,000
uber tracer trace id

00:27:06,799 --> 00:27:13,440
it's composed by a trace id ice pan id

00:27:10,000 --> 00:27:17,679
the parent span id and the flags okay

00:27:13,440 --> 00:27:20,960
if you look here at the logs you can see

00:27:17,679 --> 00:27:22,000
let me look here span reported so we

00:27:20,960 --> 00:27:24,559
have here

00:27:22,000 --> 00:27:26,320
the parents pen id you can see that's

00:27:24,559 --> 00:27:30,000
the same

00:27:26,320 --> 00:27:30,000
then you have this pen id

00:27:30,960 --> 00:27:35,840
what else then the parent span id which

00:27:33,919 --> 00:27:39,039
is also the same

00:27:35,840 --> 00:27:40,559
for this expanse here and then the flags

00:27:39,039 --> 00:27:42,880
here it's just the number one as the

00:27:40,559 --> 00:27:45,600
flag which i really don't know what

00:27:42,880 --> 00:27:46,960
what's the meaning of the flag flag is

00:27:45,600 --> 00:27:50,399
being won

00:27:46,960 --> 00:27:52,240
okay and it's also good to know that

00:27:50,399 --> 00:27:55,360
there is an initiative

00:27:52,240 --> 00:27:58,559
to create trace specific uh

00:27:55,360 --> 00:28:01,200
headers under the w3c

00:27:58,559 --> 00:28:01,600
specification okay so this is the link

00:28:01,200 --> 00:28:05,279
that

00:28:01,600 --> 00:28:08,720
shows that this this work of having

00:28:05,279 --> 00:28:12,240
a specific tracer tracing headers

00:28:08,720 --> 00:28:15,600
uh as a standard

00:28:12,240 --> 00:28:19,200
for for tracing propagation

00:28:15,600 --> 00:28:20,799
okay well now suppose that you are a

00:28:19,200 --> 00:28:25,760
java developer and you

00:28:20,799 --> 00:28:28,720
are using java micro profile

00:28:25,760 --> 00:28:29,440
if you are using java micro profile to

00:28:28,720 --> 00:28:31,760
every

00:28:29,440 --> 00:28:33,520
request every request that you read that

00:28:31,760 --> 00:28:35,919
your server receives

00:28:33,520 --> 00:28:37,600
on that jax is server is traced

00:28:35,919 --> 00:28:39,520
automatically

00:28:37,600 --> 00:28:41,840
and the context propagation suppose that

00:28:39,520 --> 00:28:44,640
you use a jax is client

00:28:41,840 --> 00:28:46,559
uh or a micro profile rest client the

00:28:44,640 --> 00:28:49,039
requests on the server are traced

00:28:46,559 --> 00:28:50,480
also automatic automatically so you

00:28:49,039 --> 00:28:53,840
don't need to

00:28:50,480 --> 00:28:56,080
uh call call any api to inject the

00:28:53,840 --> 00:28:57,360
uber headers on the request those

00:28:56,080 --> 00:29:00,000
requests are

00:28:57,360 --> 00:29:00,480
automatically propagated by the jazz ios

00:29:00,000 --> 00:29:03,679
client

00:29:00,480 --> 00:29:05,520
or rest client method calls you must use

00:29:03,679 --> 00:29:08,799
the traced annotation

00:29:05,520 --> 00:29:12,240
and a synchronous call you the the

00:29:08,799 --> 00:29:14,159
server spam must be activated via api

00:29:12,240 --> 00:29:16,320
in the asynchronous thread so let me

00:29:14,159 --> 00:29:21,360
show you those examples

00:29:16,320 --> 00:29:21,360
let me open here open here some source

00:29:24,840 --> 00:29:29,200
code

00:29:26,080 --> 00:29:34,399
and let me get

00:29:29,200 --> 00:29:34,399
this the service here

00:29:34,480 --> 00:29:43,360
okay so um

00:29:40,000 --> 00:29:43,360
note here that to evoke

00:29:43,600 --> 00:29:47,039
let me see here glue call microservice

00:29:46,720 --> 00:29:49,679
be

00:29:47,039 --> 00:29:49,679
serial

00:29:52,399 --> 00:29:56,559
hold on a second let me understand here

00:29:58,559 --> 00:30:06,320
yeah here i'm using a

00:30:01,679 --> 00:30:08,320
microprofile uh rest client

00:30:06,320 --> 00:30:09,520
okay note here that this is just an

00:30:08,320 --> 00:30:13,360
interface

00:30:09,520 --> 00:30:16,559
when i call that interface here

00:30:13,360 --> 00:30:18,640
those the the endpoint methods i didn't

00:30:16,559 --> 00:30:22,159
need to

00:30:18,640 --> 00:30:24,960
uh do anything to propagate

00:30:22,159 --> 00:30:26,480
the context i just invoked it's

00:30:24,960 --> 00:30:29,120
automatically performed

00:30:26,480 --> 00:30:30,240
i just needed to place traces to make

00:30:29,120 --> 00:30:33,279
this method

00:30:30,240 --> 00:30:37,840
uh trace it as you saw

00:30:33,279 --> 00:30:37,840
here call me

00:30:38,480 --> 00:30:42,320
call microservice be serial i it was

00:30:41,840 --> 00:30:44,399
traced

00:30:42,320 --> 00:30:45,840
because i placed this annotation

00:30:44,399 --> 00:30:48,640
annotation traces

00:30:45,840 --> 00:30:50,399
here because i use uh parallel

00:30:48,640 --> 00:30:51,120
invocation so i have a synchronous

00:30:50,399 --> 00:30:54,080
thread

00:30:51,120 --> 00:30:54,799
i had to get the server spam and inside

00:30:54,080 --> 00:30:58,240
the thread

00:30:54,799 --> 00:31:01,360
i had to activate the service pen inside

00:30:58,240 --> 00:31:05,600
this thread so it's really easy to use

00:31:01,360 --> 00:31:07,760
and really really handy

00:31:05,600 --> 00:31:09,279
but if you suppose that you are a spring

00:31:07,760 --> 00:31:11,840
boot developer

00:31:09,279 --> 00:31:12,720
again every method with the annotation

00:31:11,840 --> 00:31:15,679
rest controller

00:31:12,720 --> 00:31:16,399
is traced automatically but their spring

00:31:15,679 --> 00:31:18,640
boot

00:31:16,399 --> 00:31:19,600
or spring does not have the trace

00:31:18,640 --> 00:31:22,880
annotation

00:31:19,600 --> 00:31:23,440
although they are creating one you will

00:31:22,880 --> 00:31:26,960
have

00:31:23,440 --> 00:31:30,840
it here open for since 2018

00:31:26,960 --> 00:31:33,840
and they are working on that annotation

00:31:30,840 --> 00:31:37,919
okay

00:31:33,840 --> 00:31:40,240
so if you want to uh instead of

00:31:37,919 --> 00:31:41,120
using the traced annotation you can get

00:31:40,240 --> 00:31:44,559
the tracer

00:31:41,120 --> 00:31:47,600
and build your uh your own span

00:31:44,559 --> 00:31:49,760
and activate it okay

00:31:47,600 --> 00:31:52,960
for context propagation in the rest

00:31:49,760 --> 00:31:56,799
template you need to

00:31:52,960 --> 00:31:59,679
to use a tracing rest and plate

00:31:56,799 --> 00:32:03,039
interceptor so for example

00:31:59,679 --> 00:32:03,039
here in the microservice b

00:32:04,640 --> 00:32:09,120
i created let me see where

00:32:12,960 --> 00:32:17,120
here uh for the rest templates i create

00:32:16,000 --> 00:32:20,080
i

00:32:17,120 --> 00:32:21,679
used this set interceptor to use a

00:32:20,080 --> 00:32:24,720
tracing rest template

00:32:21,679 --> 00:32:28,799
interceptor okay it's also

00:32:24,720 --> 00:32:32,399
it's part of uh uh an api

00:32:28,799 --> 00:32:35,679
to that works that integrates

00:32:32,399 --> 00:32:38,320
open tracing with a spring okay

00:32:35,679 --> 00:32:38,880
and the same way for a synchronous call

00:32:38,320 --> 00:32:41,760
you have

00:32:38,880 --> 00:32:45,200
to activate the service button span

00:32:41,760 --> 00:32:45,200
inside the synchronous thread

00:32:50,960 --> 00:32:58,240
just okay

00:32:55,039 --> 00:33:00,799
well what about that database for a

00:32:58,240 --> 00:33:03,600
database there is also another library

00:33:00,799 --> 00:33:04,399
that you just uh it's a java jdbc

00:33:03,600 --> 00:33:07,120
library

00:33:04,399 --> 00:33:07,919
where you just use the class uh the

00:33:07,120 --> 00:33:10,960
driver the

00:33:07,919 --> 00:33:13,760
driver the gdbc driver class

00:33:10,960 --> 00:33:14,559
as i open tracing contrib jdbc tracing

00:33:13,760 --> 00:33:17,519
driver

00:33:14,559 --> 00:33:18,240
and for the connection string you just

00:33:17,519 --> 00:33:22,640
use

00:33:18,240 --> 00:33:25,679
the tracing as part of it so again

00:33:22,640 --> 00:33:29,279
if you look here uh in my

00:33:25,679 --> 00:33:31,360
spring boot application i use the

00:33:29,279 --> 00:33:33,200
driver class name as i open tracing

00:33:31,360 --> 00:33:36,640
contrib etc

00:33:33,200 --> 00:33:39,919
and the connection string is

00:33:36,640 --> 00:33:43,360
here jdbc tracing mysql

00:33:39,919 --> 00:33:44,000
i just need to do that and all dbc calls

00:33:43,360 --> 00:33:47,679
will be

00:33:44,000 --> 00:33:52,000
traced automatically if you are using

00:33:47,679 --> 00:33:54,159
uh with kafika again you just need to

00:33:52,000 --> 00:33:55,440
override the consumer factory or the

00:33:54,159 --> 00:33:58,080
producer factory

00:33:55,440 --> 00:34:00,159
to use a tracing consumer factory or or

00:33:58,080 --> 00:34:03,200
a tracing producer factory

00:34:00,159 --> 00:34:05,679
placing using

00:34:03,200 --> 00:34:06,960
in the constructor the the tracer that

00:34:05,679 --> 00:34:10,720
you got somehow

00:34:06,960 --> 00:34:10,720
you can see that here

00:34:10,800 --> 00:34:14,399
let me see yeah because i'm using a

00:34:13,520 --> 00:34:17,440
producer

00:34:14,399 --> 00:34:22,159
i created a tracing producer factory

00:34:17,440 --> 00:34:25,040
getting the tracer okay

00:34:22,159 --> 00:34:26,960
suppose that you're a nodejs developer

00:34:25,040 --> 00:34:30,399
if you're a node.js developer there is

00:34:26,960 --> 00:34:32,960
there is uh a library called

00:34:30,399 --> 00:34:35,200
uh jagger client that integrates really

00:34:32,960 --> 00:34:35,200
well

00:34:37,760 --> 00:34:40,960
there's a library called express open

00:34:39,520 --> 00:34:44,079
tracing that integrates

00:34:40,960 --> 00:34:46,879
express with uh

00:34:44,079 --> 00:34:50,000
with open tracing so you just need to uh

00:34:46,879 --> 00:34:53,119
to uh

00:34:50,000 --> 00:34:56,240
to inform to express that you are using

00:34:53,119 --> 00:34:57,040
a new mirror informing what is the

00:34:56,240 --> 00:34:59,839
tracer

00:34:57,040 --> 00:35:02,000
so you can get the tracing tracer using

00:34:59,839 --> 00:35:05,280
the jagger clients

00:35:02,000 --> 00:35:06,000
uh so i'm not it's also good to be aware

00:35:05,280 --> 00:35:08,560
how do you

00:35:06,000 --> 00:35:09,680
configure jagger jagger can be

00:35:08,560 --> 00:35:13,040
configured

00:35:09,680 --> 00:35:15,359
uh using some environment variables

00:35:13,040 --> 00:35:16,480
uh there is a small detail here for the

00:35:15,359 --> 00:35:20,160
host

00:35:16,480 --> 00:35:23,280
because uh usually you you will use the

00:35:20,160 --> 00:35:26,079
port 6821 but for

00:35:23,280 --> 00:35:26,920
nodejs applications you you need to use

00:35:26,079 --> 00:35:30,400
the port

00:35:26,920 --> 00:35:33,680
6832 because because of a

00:35:30,400 --> 00:35:36,480
small difference in the protocol

00:35:33,680 --> 00:35:38,480
then you can use environment variables

00:35:36,480 --> 00:35:42,720
to configure the name of the servers

00:35:38,480 --> 00:35:45,839
then the name of the service uh how

00:35:42,720 --> 00:35:48,800
frequently you will consume

00:35:45,839 --> 00:35:50,320
the expense is it for all requests or 10

00:35:48,800 --> 00:35:52,400
of the requests or 50

00:35:50,320 --> 00:35:54,800
of the requests and then you will say

00:35:52,400 --> 00:35:57,839
where is the jagger agent running

00:35:54,800 --> 00:35:59,920
you can see that here for example if you

00:35:57,839 --> 00:36:02,960
open my docker compose here

00:35:59,920 --> 00:36:04,480
i have all the information for my

00:36:02,960 --> 00:36:07,680
microservice a

00:36:04,480 --> 00:36:10,880
so i have i inform here that

00:36:07,680 --> 00:36:13,520
that i'm sending the expanse to to a

00:36:10,880 --> 00:36:15,920
jagger host called jagger which is the

00:36:13,520 --> 00:36:18,640
this name here

00:36:15,920 --> 00:36:19,200
the name of the service uh of course

00:36:18,640 --> 00:36:21,680
different

00:36:19,200 --> 00:36:22,640
apis can change the name a little bit so

00:36:21,680 --> 00:36:24,880
for example for

00:36:22,640 --> 00:36:26,480
uh spring boot you can see that it's a

00:36:24,880 --> 00:36:30,800
little bit different

00:36:26,480 --> 00:36:31,920
uh i uh there is a prefix here open

00:36:30,800 --> 00:36:35,119
tracing

00:36:31,920 --> 00:36:37,040
jagger udp udp sender host jagger the

00:36:35,119 --> 00:36:40,160
port 6831

00:36:37,040 --> 00:36:43,200
and this microsoft c which is written

00:36:40,160 --> 00:36:46,400
in in node.js

00:36:43,200 --> 00:36:49,440
uses the port 6832

00:36:46,400 --> 00:36:53,119
this is really good because

00:36:49,440 --> 00:36:56,640
you can run

00:36:53,119 --> 00:36:58,800
open tracing inside a kubernetes cluster

00:36:56,640 --> 00:37:00,480
for uh for example you can integrate

00:36:58,800 --> 00:37:02,560
that with istio

00:37:00,480 --> 00:37:03,839
i don't know how many of you are aware

00:37:02,560 --> 00:37:07,040
of istio but

00:37:03,839 --> 00:37:09,200
before easter istio we place discovery

00:37:07,040 --> 00:37:10,640
load balancer resilience metrics and

00:37:09,200 --> 00:37:14,160
even tracing

00:37:10,640 --> 00:37:16,079
uh as libraries as external libraries

00:37:14,160 --> 00:37:19,520
for our application

00:37:16,079 --> 00:37:22,800
now with istio we can

00:37:19,520 --> 00:37:26,880
have all those things running inside

00:37:22,800 --> 00:37:30,000
sidecar containers the good thing

00:37:26,880 --> 00:37:33,760
is that jagger is already part

00:37:30,000 --> 00:37:36,720
of istio so you will have

00:37:33,760 --> 00:37:38,640
tracing for free but there are some

00:37:36,720 --> 00:37:42,320
things that you need to be aware

00:37:38,640 --> 00:37:45,280
first the istio sidecar

00:37:42,320 --> 00:37:46,240
which is uh based on envoy which is

00:37:45,280 --> 00:37:50,079
envoy

00:37:46,240 --> 00:37:52,560
generates b3 header is not uber headers

00:37:50,079 --> 00:37:53,599
so uh if they are not provided by

00:37:52,560 --> 00:37:57,359
requests

00:37:53,599 --> 00:38:00,800
so if you want to work uh with

00:37:57,359 --> 00:38:03,599
that with open tracing

00:38:00,800 --> 00:38:04,400
inside instill remember to use b3

00:38:03,599 --> 00:38:07,280
headers

00:38:04,400 --> 00:38:08,800
another information here although an

00:38:07,280 --> 00:38:11,599
istio sidecar will process

00:38:08,800 --> 00:38:12,240
both inbound and outbound requests for

00:38:11,599 --> 00:38:14,880
an

00:38:12,240 --> 00:38:16,160
associated application instance it has

00:38:14,880 --> 00:38:18,720
no implicit ways

00:38:16,160 --> 00:38:19,760
of correlation the outbound the outbound

00:38:18,720 --> 00:38:22,160
requests

00:38:19,760 --> 00:38:23,280
to the inbound request that calls them

00:38:22,160 --> 00:38:25,839
the only way

00:38:23,280 --> 00:38:28,560
this correlation can be achieved is if

00:38:25,839 --> 00:38:29,680
the application propagates relevant

00:38:28,560 --> 00:38:32,480
information

00:38:29,680 --> 00:38:34,640
uh in that case headers from the inbound

00:38:32,480 --> 00:38:38,160
requests to the outbound request

00:38:34,640 --> 00:38:38,720
so you gain you can have if you adopt

00:38:38,160 --> 00:38:41,599
these two

00:38:38,720 --> 00:38:42,079
you will have uh jagger and tracing for

00:38:41,599 --> 00:38:44,800
free

00:38:42,079 --> 00:38:45,280
but your application needs to correlate

00:38:44,800 --> 00:38:48,000
the

00:38:45,280 --> 00:38:48,320
inbound and outbound b3 headers that

00:38:48,000 --> 00:38:51,359
your

00:38:48,320 --> 00:38:53,280
information provides like for example uh

00:38:51,359 --> 00:38:55,440
if you go here to this

00:38:53,280 --> 00:38:56,960
i have here a deployment email for

00:38:55,440 --> 00:39:00,480
kubernetes

00:38:56,960 --> 00:39:04,720
you can see that i had to configure

00:39:00,480 --> 00:39:09,520
uh my application to use b3 headers

00:39:04,720 --> 00:39:09,520
okay the same thing happened for

00:39:09,860 --> 00:39:15,359
[Music]

00:39:11,760 --> 00:39:18,400
for the other microservices let me find

00:39:15,359 --> 00:39:21,599
it here kubernetes deployment

00:39:18,400 --> 00:39:24,480
yeah microservice v uh

00:39:21,599 --> 00:39:25,359
enable b3 propagation true so every time

00:39:24,480 --> 00:39:27,920
that i'm using

00:39:25,359 --> 00:39:29,760
with ease2 i need to use b3 headers and

00:39:27,920 --> 00:39:32,880
it's just simple just configure

00:39:29,760 --> 00:39:35,440
open tracing okay uh

00:39:32,880 --> 00:39:36,240
if you want to know more there is an

00:39:35,440 --> 00:39:39,280
excellent

00:39:36,240 --> 00:39:43,040
open tracing tutorials in this link here

00:39:39,280 --> 00:39:45,680
you have

00:39:43,040 --> 00:39:47,280
you have tutorials for c-sharp gold java

00:39:45,680 --> 00:39:49,599
node.js and python

00:39:47,280 --> 00:39:51,760
and for each one of them you will have

00:39:49,599 --> 00:39:53,760
lessons like the basic hello world

00:39:51,760 --> 00:39:54,960
context and tracing functions tracing

00:39:53,760 --> 00:39:58,079
rpc requests

00:39:54,960 --> 00:39:59,680
baggage and extra credit so if you are a

00:39:58,079 --> 00:40:01,599
node.js developer you

00:39:59,680 --> 00:40:04,319
you will have essentially the same

00:40:01,599 --> 00:40:05,359
lessons or if you are a c-sharp

00:40:04,319 --> 00:40:07,520
developer

00:40:05,359 --> 00:40:10,800
essentially the same lessons it's a

00:40:07,520 --> 00:40:13,839
really nice resource

00:40:10,800 --> 00:40:15,200
and also if you want to use a really

00:40:13,839 --> 00:40:18,000
simple demo

00:40:15,200 --> 00:40:19,680
just like i i presented to you you can

00:40:18,000 --> 00:40:22,640
go to my repository

00:40:19,680 --> 00:40:24,000
slash rafabani slash tracing demo where

00:40:22,640 --> 00:40:27,280
you can see the source code

00:40:24,000 --> 00:40:29,440
for uh micro java

00:40:27,280 --> 00:40:31,119
and my java and micro profile in the

00:40:29,440 --> 00:40:33,520
microservice a

00:40:31,119 --> 00:40:35,359
or java with a spring boot in

00:40:33,520 --> 00:40:39,760
microservice b

00:40:35,359 --> 00:40:43,040
and microsoft c using nodejs

00:40:39,760 --> 00:40:46,160
okay uh

00:40:43,040 --> 00:40:47,760
so i hope that you enjoyed if you want

00:40:46,160 --> 00:40:51,040
to

00:40:47,760 --> 00:40:54,720
i suggest to you that ghost that go to

00:40:51,040 --> 00:40:56,960
my uh to twitter and follow me

00:40:54,720 --> 00:40:58,720
using this twitter handle at rafabani

00:40:56,960 --> 00:41:01,200
which is my twitter handle

00:40:58,720 --> 00:41:04,400
and i will stop now to answer the

00:41:01,200 --> 00:41:04,400
questions that you might have

00:41:04,839 --> 00:41:07,839
okay

00:41:09,200 --> 00:41:12,240
questions can be posed in the chat

00:41:11,040 --> 00:41:15,200
function q a

00:41:12,240 --> 00:41:15,200
or raising your hand

00:41:18,880 --> 00:41:23,280
nice so no questions so far

00:41:31,520 --> 00:41:35,119
okay pop up some new questions so is

00:41:33,839 --> 00:41:38,560
there an integration

00:41:35,119 --> 00:41:41,359
with prometheus there is an integration

00:41:38,560 --> 00:41:42,640
uh is still has an integration of with

00:41:41,359 --> 00:41:47,359
prometheus

00:41:42,640 --> 00:41:47,359
but open tracing does not have

00:41:47,680 --> 00:41:55,520
open tracing focus only on on tracing

00:41:52,800 --> 00:41:56,000
implemented by jagger in this case you

00:41:55,520 --> 00:41:58,880
can use

00:41:56,000 --> 00:42:00,560
zipkin but not with prometheus as i am

00:41:58,880 --> 00:42:04,160
aware prometheus

00:42:00,560 --> 00:42:04,880
is just for metrics and it does not

00:42:04,160 --> 00:42:08,000
consume

00:42:04,880 --> 00:42:08,560
expands so that it can create that

00:42:08,000 --> 00:42:11,760
graphic

00:42:08,560 --> 00:42:15,119
with the spam relationship

00:42:11,760 --> 00:42:16,960
okay but with easter you can have jagger

00:42:15,119 --> 00:42:20,480
prometheus graffana

00:42:16,960 --> 00:42:24,240
and everything very well integrated

00:42:20,480 --> 00:42:27,040
okay from chen

00:42:24,240 --> 00:42:29,119
will application code for open tracing

00:42:27,040 --> 00:42:30,079
needs to be completely rewritten through

00:42:29,119 --> 00:42:33,440
supporting

00:42:30,079 --> 00:42:34,720
to support open telemetry well i'm not

00:42:33,440 --> 00:42:37,710
aware of that

00:42:34,720 --> 00:42:39,200
because i i have not i

00:42:37,710 --> 00:42:42,400
[Music]

00:42:39,200 --> 00:42:46,079
i didn't dig in in open telemetry

00:42:42,400 --> 00:42:47,040
i i hear a lot about that but i have

00:42:46,079 --> 00:42:50,800
never worked with

00:42:47,040 --> 00:42:51,440
it so i i really cannot answer that okay

00:42:50,800 --> 00:42:58,960
tim so

00:42:51,440 --> 00:43:02,000
so sorry

00:42:58,960 --> 00:43:03,760
okay so it seems to be the end

00:43:02,000 --> 00:43:05,359
oh there is one more question that's

00:43:03,760 --> 00:43:08,480
really nice

00:43:05,359 --> 00:43:10,960
if we are using a sas monitoring service

00:43:08,480 --> 00:43:12,800
are there adapter available yeah that's

00:43:10,960 --> 00:43:15,119
a really good question because

00:43:12,800 --> 00:43:18,000
there are some adapters let me see if i

00:43:15,119 --> 00:43:22,400
can find it online

00:43:18,000 --> 00:43:22,400
open tracing adapters

00:43:25,200 --> 00:43:28,800
because i know that there are there are

00:43:27,280 --> 00:43:41,839
several

00:43:28,800 --> 00:43:41,839
uh adapters

00:43:42,079 --> 00:43:48,240
let me see i think it's in a

00:43:45,680 --> 00:43:51,119
in a repository called contrib concrete

00:43:48,240 --> 00:43:51,119
open tracing

00:43:52,000 --> 00:43:55,440
yeah third part open tracing

00:43:53,440 --> 00:43:57,280
contributors so let me open here

00:43:55,440 --> 00:43:59,839
my share my screen again so you can have

00:43:57,280 --> 00:43:59,839
an idea

00:44:00,400 --> 00:44:04,079
so you can see here the third part open

00:44:02,800 --> 00:44:07,200
tracing api

00:44:04,079 --> 00:44:10,800
contributions so we have java with

00:44:07,200 --> 00:44:14,400
jmx spring spring jagger springett cloud

00:44:10,800 --> 00:44:18,400
java jdbc java java trace with slower

00:44:14,400 --> 00:44:23,280
kafka client review with speak client

00:44:18,400 --> 00:44:26,960
wow a lot of java aws sdk

00:44:23,280 --> 00:44:30,400
reddies there's one minute left

00:44:26,960 --> 00:44:34,560
okay thank you for making me aware

00:44:30,400 --> 00:44:37,920
uh for python c network so yeah

00:44:34,560 --> 00:44:39,440
you can just browse this more than 100

00:44:37,920 --> 00:44:42,319
repositories probably

00:44:39,440 --> 00:44:42,720
you will find something that might fit

00:44:42,319 --> 00:44:45,520
you

00:44:42,720 --> 00:44:47,520
or you can contribute and become one

00:44:45,520 --> 00:44:49,760
more contributor

00:44:47,520 --> 00:44:51,280
okay so this is the end i don't think i

00:44:49,760 --> 00:44:54,640
have time to answer

00:44:51,280 --> 00:45:04,079
one one more question and i really

00:44:54,640 --> 00:45:04,079

YouTube URL: https://www.youtube.com/watch?v=FrFnUh_qN9I


