Title: Ryan Levick - Rust at Microsoft
Publication date: 2020-05-18
Playlist: Open Source 101 at Home 2020
Description: 
	Rust at Microsoft

Presented at: Open Source 101 at Home 2020
Presented by: Ryan Levick, Microsoft

Abstract: The software industry has a billion dollar problem: the base of our mission critical systems are usually written in memory unsafe languages that are susceptible to expensive and dangerous security vulnerabilities. But a new programming language is on the horizon that may help the industry address this issue: Rust. In this talk weâ€™ll examine why Microsoft is becoming more and more interested in Rust and why we see it as a potential game changer for systems programming across the industry.

For more info: https://opensource101.com/
Captions: 
	00:00:05,400 --> 00:00:12,420
[Music]

00:00:09,200 --> 00:00:14,190
good evening to everybody and good

00:00:12,420 --> 00:00:15,839
afternoon good morning and good night

00:00:14,190 --> 00:00:17,970
depending on where you are in the world

00:00:15,839 --> 00:00:21,810
this is very cool we're gonna get

00:00:17,970 --> 00:00:30,510
started here so I hope everybody sit

00:00:21,810 --> 00:00:31,009
back relax and ready to go all right

00:00:30,510 --> 00:00:33,270
great

00:00:31,009 --> 00:00:36,239
so today I'm going to be talking about

00:00:33,270 --> 00:00:38,309
rust at Microsoft rust the programming

00:00:36,239 --> 00:00:40,800
language for those not familiar the cute

00:00:38,309 --> 00:00:44,239
little crab that's running around their

00:00:40,800 --> 00:00:47,760
name is Faris so it's the mascot of rust

00:00:44,239 --> 00:00:49,289
everybody say hello to Faris and Faris

00:00:47,760 --> 00:00:52,469
will be guiding us on our journey while

00:00:49,289 --> 00:00:54,809
we talk about rust at Microsoft first of

00:00:52,469 --> 00:00:57,360
all a little bit about me

00:00:54,809 --> 00:01:00,000
my name is Ryan Lubbock I'm a cloud

00:00:57,360 --> 00:01:02,010
developer advocates at Microsoft and

00:01:00,000 --> 00:01:09,060
during my day job I basically do

00:01:02,010 --> 00:01:10,320
everything rust at Microsoft and today

00:01:09,060 --> 00:01:13,710
we're gonna be talking about why

00:01:10,320 --> 00:01:16,170
Microsoft is interested in rust why we

00:01:13,710 --> 00:01:18,180
believe at Microsoft that the industry

00:01:16,170 --> 00:01:20,070
as a whole should be interested in the

00:01:18,180 --> 00:01:21,869
language and a little bit about the

00:01:20,070 --> 00:01:24,900
problem that we are facing as an

00:01:21,869 --> 00:01:30,210
industry why we believe rust is a

00:01:24,900 --> 00:01:32,939
possible solution to that problem all

00:01:30,210 --> 00:01:34,560
right so what is this problem that I'm

00:01:32,939 --> 00:01:36,150
alluding to well it all starts with the

00:01:34,560 --> 00:01:38,880
simple fact our systems are more

00:01:36,150 --> 00:01:41,780
interconnected and performing more and

00:01:38,880 --> 00:01:44,549
more important tasks every single day

00:01:41,780 --> 00:01:46,860
and really what this translates to is

00:01:44,549 --> 00:01:48,630
that our systems are more vulnerable and

00:01:46,860 --> 00:01:51,810
attackers have even more incentive to

00:01:48,630 --> 00:01:54,479
attack those systems over time so keep

00:01:51,810 --> 00:01:58,340
this in mind where we're growing our

00:01:54,479 --> 00:02:01,799
systems together and with that comes the

00:01:58,340 --> 00:02:04,409
incentive for attacking from nefarious

00:02:01,799 --> 00:02:06,689
parties so what does that look like in

00:02:04,409 --> 00:02:09,209
terms of numbers well if we have a graph

00:02:06,689 --> 00:02:11,610
of CVEs and for those who are not aware

00:02:09,209 --> 00:02:13,890
CVE stands for common vulnerability and

00:02:11,610 --> 00:02:15,510
exposure these are kind of

00:02:13,890 --> 00:02:16,940
security vulnerabilities is how you can

00:02:15,510 --> 00:02:19,290
think about them severe security

00:02:16,940 --> 00:02:23,640
vulnerabilities if we graph them over

00:02:19,290 --> 00:02:25,800
time from 2006 and to 2018 this is what

00:02:23,640 --> 00:02:28,080
the graph looks like it keeps going up

00:02:25,800 --> 00:02:31,140
and up and up now I mean the lucky part

00:02:28,080 --> 00:02:32,700
of this story is that the reason that's

00:02:31,140 --> 00:02:33,930
going up is because we're more

00:02:32,700 --> 00:02:35,850
aggressively looking for these things

00:02:33,930 --> 00:02:39,360
ahead of time we're writing a lot more

00:02:35,850 --> 00:02:42,060
software things like that so kind of to

00:02:39,360 --> 00:02:44,220
be expected that they would go up but I

00:02:42,060 --> 00:02:46,739
think the thing to take away from from

00:02:44,220 --> 00:02:49,010
this graph it's that the problem is

00:02:46,739 --> 00:02:50,910
definitely not getting better we are

00:02:49,010 --> 00:02:53,730
introducing more security

00:02:50,910 --> 00:02:56,120
vulnerabilities over time there might be

00:02:53,730 --> 00:02:59,610
reasons for that but we are definitely

00:02:56,120 --> 00:03:01,470
seeing more of them over time and now

00:02:59,610 --> 00:03:02,940
these are Microsoft specific numbers and

00:03:01,470 --> 00:03:05,150
you know I didn't give the exact numbers

00:03:02,940 --> 00:03:08,580
here because that's kind of irrelevant

00:03:05,150 --> 00:03:10,680
but we also see no reason why a graph of

00:03:08,580 --> 00:03:14,130
any other company would be any different

00:03:10,680 --> 00:03:18,060
than the one at Microsoft so this is

00:03:14,130 --> 00:03:20,459
really an industry-wide problem ok so

00:03:18,060 --> 00:03:23,459
how much does this actually cost in

00:03:20,459 --> 00:03:26,370
dollar terms then well if we look at a

00:03:23,459 --> 00:03:27,930
dollar a dollar figure one that we can

00:03:26,370 --> 00:03:28,890
come up with based on some research that

00:03:27,930 --> 00:03:31,739
we've done there's a hundred and fifty

00:03:28,890 --> 00:03:33,750
thousand dollars and now that's per

00:03:31,739 --> 00:03:36,690
incident and then by the way this

00:03:33,750 --> 00:03:38,519
figures from about 2004 and it's

00:03:36,690 --> 00:03:40,590
adjusted for inflation but there's

00:03:38,519 --> 00:03:42,510
absolutely zero reason to believe that

00:03:40,590 --> 00:03:46,200
this is not an extremely conservative

00:03:42,510 --> 00:03:50,190
estimate and so if you're looking at 150

00:03:46,200 --> 00:03:52,410
thousand dollars per per incident that's

00:03:50,190 --> 00:03:54,450
that's pretty severe and and I should

00:03:52,410 --> 00:03:57,030
also mention that these are these are

00:03:54,450 --> 00:04:00,209
just direct costs to Microsoft in

00:03:57,030 --> 00:04:01,530
mitigating these vulnerabilities and so

00:04:00,209 --> 00:04:04,019
we're not taking into account things

00:04:01,530 --> 00:04:06,630
like loss of reputation to Microsoft

00:04:04,019 --> 00:04:07,829
which surely costs a lot more than this

00:04:06,630 --> 00:04:09,720
we're not talking about cost of

00:04:07,829 --> 00:04:11,880
customers who are affected by this which

00:04:09,720 --> 00:04:14,519
is definitely much larger than this and

00:04:11,880 --> 00:04:17,150
so the dollar figure right that you see

00:04:14,519 --> 00:04:20,519
right here is is absolutely conservative

00:04:17,150 --> 00:04:21,870
in its scope and so you know the next

00:04:20,519 --> 00:04:24,980
question becomes okay how many issues

00:04:21,870 --> 00:04:28,570
are we facing per year

00:04:24,980 --> 00:04:32,090
and one figure that we have from 2018 is

00:04:28,570 --> 00:04:34,280
468 which if you do some simple math on

00:04:32,090 --> 00:04:35,540
kind of like the real base cost of this

00:04:34,280 --> 00:04:40,040
thing you know you're upwards of the

00:04:35,540 --> 00:04:41,840
hundreds of millions that you can are

00:04:40,040 --> 00:04:43,460
into the tens of millions and then if

00:04:41,840 --> 00:04:45,890
you extrapolate out from there into the

00:04:43,460 --> 00:04:49,460
hundreds of millions of costs when it

00:04:45,890 --> 00:04:51,320
comes to cost to us as a company of

00:04:49,460 --> 00:04:55,970
Microsoft and costs our customers as

00:04:51,320 --> 00:04:57,620
well but really I mean you know 468 is

00:04:55,970 --> 00:04:58,940
it's pretty bad and if you do the math

00:04:57,620 --> 00:05:01,430
that you end up with a figure that's

00:04:58,940 --> 00:05:03,020
that's you know fairly bad but I

00:05:01,430 --> 00:05:04,850
wouldn't call it catastrophic but of

00:05:03,020 --> 00:05:06,770
course this is kind of the low end of

00:05:04,850 --> 00:05:10,070
our estimation the question then becomes

00:05:06,770 --> 00:05:12,950
can the cost be even higher and the

00:05:10,070 --> 00:05:14,570
answer is definitely yes there's been a

00:05:12,950 --> 00:05:17,770
number of issues in the past that have

00:05:14,570 --> 00:05:21,680
easily cost way way way beyond this

00:05:17,770 --> 00:05:23,630
$150,000 figure that we know of the one

00:05:21,680 --> 00:05:26,450
that's that's displayed here on your

00:05:23,630 --> 00:05:30,140
screen is the one a cry exploit which

00:05:26,450 --> 00:05:32,870
was derived from from an NSA derived

00:05:30,140 --> 00:05:36,320
exploit it was used as an a worm as a

00:05:32,870 --> 00:05:39,080
worm to infect pcs and upwards of 150

00:05:36,320 --> 00:05:41,060
different countries and the thing to

00:05:39,080 --> 00:05:44,000
remember about here was that the bug was

00:05:41,060 --> 00:05:48,380
found and patched before the public was

00:05:44,000 --> 00:05:49,850
aware of loner cry but still two hundred

00:05:48,380 --> 00:05:54,110
thousand computers were infected and

00:05:49,850 --> 00:05:56,300
they were infected because people did

00:05:54,110 --> 00:05:58,790
not patch their system quick enough so

00:05:56,300 --> 00:06:00,290
keep that in mind it's not purely about

00:05:58,790 --> 00:06:02,930
finding things and then fixing them

00:06:00,290 --> 00:06:04,220
because people oftentimes will not go

00:06:02,930 --> 00:06:08,240
ahead and patch their software

00:06:04,220 --> 00:06:09,830
afterwards and and so you know it's it's

00:06:08,240 --> 00:06:11,960
kind of hard to get an estimate of

00:06:09,830 --> 00:06:14,480
exactly how much this cost humanity as a

00:06:11,960 --> 00:06:17,240
whole but kind of the back of the napkin

00:06:14,480 --> 00:06:20,510
math that we like to do at Microsoft for

00:06:17,240 --> 00:06:23,120
this type of thing is that it could have

00:06:20,510 --> 00:06:28,700
cost upwards of four billion US dollars

00:06:23,120 --> 00:06:31,070
for Microsoft and for four customers who

00:06:28,700 --> 00:06:32,720
are using the software and again I want

00:06:31,070 --> 00:06:35,090
to reiterate that this is basically

00:06:32,720 --> 00:06:37,759
after the the problem had been patched

00:06:35,090 --> 00:06:40,160
so one can only imagine what

00:06:37,759 --> 00:06:43,310
what it would have cost if the problem

00:06:40,160 --> 00:06:44,750
had not been found in time and then

00:06:43,310 --> 00:06:47,030
specifically if you look at some

00:06:44,750 --> 00:06:50,389
examples like the national healthcare

00:06:47,030 --> 00:06:52,310
system and the UK the NHS I believe it

00:06:50,389 --> 00:06:54,380
cost somewhere around 92 million pounds

00:06:52,310 --> 00:06:56,120
just for them to fix this problem in

00:06:54,380 --> 00:06:59,449
their own systems and that's that's one

00:06:56,120 --> 00:07:01,940
one country in one kind of entity in

00:06:59,449 --> 00:07:05,389
that country dealing with its problem so

00:07:01,940 --> 00:07:08,180
it's so it's quite big and really when

00:07:05,389 --> 00:07:13,310
we're looking at this the core of this

00:07:08,180 --> 00:07:16,539
problem comes down to memory safety the

00:07:13,310 --> 00:07:20,030
the the fact of the matter is is that

00:07:16,539 --> 00:07:23,180
memory safety issues account for a large

00:07:20,030 --> 00:07:25,820
majority of CVEs that we account the

00:07:23,180 --> 00:07:28,550
wild now what is memory safety for those

00:07:25,820 --> 00:07:30,889
who are C++ programmers or C programmers

00:07:28,550 --> 00:07:33,590
you'll be familiar with this but I asked

00:07:30,889 --> 00:07:36,259
others but if not done C or C++ in a

00:07:33,590 --> 00:07:38,270
while to think back when you have done

00:07:36,259 --> 00:07:40,160
it you've probably run into issues when

00:07:38,270 --> 00:07:42,520
coding like you Savannah and

00:07:40,160 --> 00:07:44,960
uninitialized memory use after free

00:07:42,520 --> 00:07:47,419
double free buffer overruns it's

00:07:44,960 --> 00:07:49,400
basically the use of memory incorrectly

00:07:47,419 --> 00:07:51,680
you're doing something where you should

00:07:49,400 --> 00:07:54,320
not be doing you're doing something you

00:07:51,680 --> 00:07:55,669
should not be doing with memory um but

00:07:54,320 --> 00:07:57,650
there are other issues that kind of fall

00:07:55,669 --> 00:07:59,630
under this info of memory safety that

00:07:57,650 --> 00:08:02,449
aren't typically assigned to that label

00:07:59,630 --> 00:08:05,990
and one of them for instance is data

00:08:02,449 --> 00:08:08,720
races where you have kind of you have

00:08:05,990 --> 00:08:11,870
access to two areas of memory that are

00:08:08,720 --> 00:08:14,539
not kind of that are not reliably or

00:08:11,870 --> 00:08:16,280
predictably accessed in a way through

00:08:14,539 --> 00:08:18,169
things like locks or something like that

00:08:16,280 --> 00:08:20,120
so you kind of have these races where

00:08:18,169 --> 00:08:22,610
you don't know until after it happens

00:08:20,120 --> 00:08:24,860
exactly who reads and writes and in what

00:08:22,610 --> 00:08:29,930
order and this can also lead to two

00:08:24,860 --> 00:08:32,270
extreme cases of memory safety and if

00:08:29,930 --> 00:08:34,760
we're looking at the the graph of of

00:08:32,270 --> 00:08:37,760
memory safety versus not memory safety

00:08:34,760 --> 00:08:40,270
that we have at Microsoft if you the the

00:08:37,760 --> 00:08:44,240
y-axis here it's the percent of CDEs

00:08:40,270 --> 00:08:46,100
that we have and in orange is how many

00:08:44,240 --> 00:08:48,370
of those CDs are memory safety related

00:08:46,100 --> 00:08:50,570
and and the yellow is not memories

00:08:48,370 --> 00:08:50,900
memory safety related and you can see

00:08:50,570 --> 00:08:55,130
that Oh

00:08:50,900 --> 00:08:56,930
time 70% of CVS at Microsoft are memory

00:08:55,130 --> 00:08:58,880
safety issues and this is not going down

00:08:56,930 --> 00:09:01,310
there is no real trend it's just saying

00:08:58,880 --> 00:09:03,260
the exact same so and this is not

00:09:01,310 --> 00:09:06,440
despite massive efforts on our part to

00:09:03,260 --> 00:09:11,750
fix this issue it still seems to be a

00:09:06,440 --> 00:09:14,080
common common thing we'll talk a little

00:09:11,750 --> 00:09:15,590
bit about those efforts in the future

00:09:14,080 --> 00:09:19,040
all right

00:09:15,590 --> 00:09:21,110
so and this is where you know the part

00:09:19,040 --> 00:09:24,950
that I don't like to do but at the core

00:09:21,110 --> 00:09:26,600
of this really is a C++ this is not to

00:09:24,950 --> 00:09:28,310
tabash on the language or anything like

00:09:26,600 --> 00:09:29,930
that it's a great language has done a

00:09:28,310 --> 00:09:31,970
lot built a lot of great software out

00:09:29,930 --> 00:09:34,820
there but the the fact of the matter is

00:09:31,970 --> 00:09:37,270
is that C++ at its core it's not a safe

00:09:34,820 --> 00:09:40,630
language it definitely provides

00:09:37,270 --> 00:09:44,570
especially a more modern variants of C++

00:09:40,630 --> 00:09:47,480
ways of protecting yourself against some

00:09:44,570 --> 00:09:49,160
of these issues but the C++ is not a

00:09:47,480 --> 00:09:53,510
memory safe language and no one would

00:09:49,160 --> 00:09:56,240
really pretend that it is and so this is

00:09:53,510 --> 00:09:58,760
a bit concerning because C++ and C are

00:09:56,240 --> 00:10:01,940
used to build the very very core of our

00:09:58,760 --> 00:10:04,480
foundation of our systems the systems

00:10:01,940 --> 00:10:08,630
that truly run the world and we're using

00:10:04,480 --> 00:10:11,030
languages that are because they are

00:10:08,630 --> 00:10:13,580
quite old and come from a different era

00:10:11,030 --> 00:10:16,640
do not provide us the ability to protect

00:10:13,580 --> 00:10:20,450
ourselves from from these kinds of

00:10:16,640 --> 00:10:22,190
vulnerabilities and so you know long

00:10:20,450 --> 00:10:24,440
before I ever joined Microsoft people

00:10:22,190 --> 00:10:28,880
started looking at this question and

00:10:24,440 --> 00:10:31,190
started asking ok how do we fix this and

00:10:28,880 --> 00:10:34,310
if there's been a lot of great ideas and

00:10:31,190 --> 00:10:37,160
I'm gonna go through some of them I want

00:10:34,310 --> 00:10:39,590
to reiterate that these ideas are not

00:10:37,160 --> 00:10:43,730
necessarily bad ideas they're just not

00:10:39,590 --> 00:10:45,800
holistic solutions and so it's not that

00:10:43,730 --> 00:10:48,500
I'm saying that we shouldn't do some of

00:10:45,800 --> 00:10:50,570
this stuff it's that it's not enough and

00:10:48,500 --> 00:10:55,370
the first one of these is a kind of

00:10:50,570 --> 00:10:56,780
hacker News's favorite mantra when when

00:10:55,370 --> 00:11:00,260
these things come up is we need better

00:10:56,780 --> 00:11:02,300
programmers which I am absolutely for

00:11:00,260 --> 00:11:04,490
training people and that's a wonderful

00:11:02,300 --> 00:11:06,339
thing to do but the

00:11:04,490 --> 00:11:10,310
for the matter is there is zero evidence

00:11:06,339 --> 00:11:12,920
that doing holistic training of C and

00:11:10,310 --> 00:11:16,279
C++ developers will actually fix this

00:11:12,920 --> 00:11:17,630
issue in any significant way and and you

00:11:16,279 --> 00:11:21,589
should better believe that we are doing

00:11:17,630 --> 00:11:23,420
a lot of training at Microsoft to make

00:11:21,589 --> 00:11:26,240
sure that people do not introduce these

00:11:23,420 --> 00:11:29,240
kinds of bugs and as you saw before 70

00:11:26,240 --> 00:11:33,350
percent are still introduced a year over

00:11:29,240 --> 00:11:35,089
year so this is not really a way that we

00:11:33,350 --> 00:11:38,649
can fix it and one other thing I want to

00:11:35,089 --> 00:11:40,399
add too is you know a lot of people find

00:11:38,649 --> 00:11:42,470
sometimes they're personally attacked

00:11:40,399 --> 00:11:44,300
when when this is suggested well you

00:11:42,470 --> 00:11:47,529
know I'm a good programmer why can't you

00:11:44,300 --> 00:11:49,790
just be a good programmer - and you know

00:11:47,529 --> 00:11:52,240
besides the problems I have with that

00:11:49,790 --> 00:11:54,339
kind of sentiment in the first place

00:11:52,240 --> 00:11:56,420
we're not even really talking about

00:11:54,339 --> 00:12:00,290
individual programmers here it's very

00:11:56,420 --> 00:12:03,500
possible - for two components written in

00:12:00,290 --> 00:12:05,630
in a memory unsafe language that in

00:12:03,500 --> 00:12:06,950
isolation worked perfectly fine and when

00:12:05,630 --> 00:12:08,510
they're composed together they don't

00:12:06,950 --> 00:12:10,040
compose properly because they make

00:12:08,510 --> 00:12:12,140
different assumptions about how how

00:12:10,040 --> 00:12:13,490
memory should be treated and so this

00:12:12,140 --> 00:12:16,100
isn't really about individual

00:12:13,490 --> 00:12:19,880
programmers but rather about kind of

00:12:16,100 --> 00:12:23,510
this at scale so another idea that we

00:12:19,880 --> 00:12:26,089
have is we need to use better static

00:12:23,510 --> 00:12:28,270
analysis tools and this is great idea

00:12:26,089 --> 00:12:30,700
static analysis can get you pretty far

00:12:28,270 --> 00:12:33,110
but there's a lot of problems with it

00:12:30,700 --> 00:12:35,089
first of all static analysis is not on

00:12:33,110 --> 00:12:36,709
by default it requires that you make

00:12:35,089 --> 00:12:38,810
sure that it's included in the build

00:12:36,709 --> 00:12:41,630
system that it's run on every pull

00:12:38,810 --> 00:12:43,160
request it slows things down and so

00:12:41,630 --> 00:12:45,500
there's a lot of incentive not to on

00:12:43,160 --> 00:12:47,450
static analysis and so there's a lot of

00:12:45,500 --> 00:12:49,970
kind of overhead of process that needs

00:12:47,450 --> 00:12:54,140
to be put in place to get this up and

00:12:49,970 --> 00:12:56,329
running and by all means more of this

00:12:54,140 --> 00:12:59,810
should happen it really does help with

00:12:56,329 --> 00:13:02,360
the issue but at the end of the day if

00:12:59,810 --> 00:13:05,630
it's not on by default it won't it won't

00:13:02,360 --> 00:13:07,910
help a large amount of cases and static

00:13:05,630 --> 00:13:11,779
analysis is limited when you're working

00:13:07,910 --> 00:13:13,850
with a with a memory unsafe language you

00:13:11,779 --> 00:13:15,410
know it doesn't have all the annotations

00:13:13,850 --> 00:13:17,060
that it needs for a static analysis tool

00:13:15,410 --> 00:13:18,050
to be able to figure out if something

00:13:17,060 --> 00:13:20,569
that has happened

00:13:18,050 --> 00:13:22,399
is correct or not and so really you need

00:13:20,569 --> 00:13:24,319
something kind of built in to the

00:13:22,399 --> 00:13:30,379
language to make sure that everything is

00:13:24,319 --> 00:13:32,540
caught and so really with this the the

00:13:30,379 --> 00:13:34,129
last idea and the only idea that we

00:13:32,540 --> 00:13:35,869
think that will work is that we need to

00:13:34,129 --> 00:13:39,199
make these issues and possible to

00:13:35,869 --> 00:13:41,269
introduce this is the only thing that

00:13:39,199 --> 00:13:43,699
can possibly help happen is if

00:13:41,269 --> 00:13:45,529
programmers just do not have the ability

00:13:43,699 --> 00:13:46,999
to introduce these issues in the very

00:13:45,529 --> 00:13:49,339
first place and at the end of the day

00:13:46,999 --> 00:13:51,259
what it comes down to is the cost of

00:13:49,339 --> 00:13:53,329
above compile time is orders of

00:13:51,259 --> 00:13:56,119
magnitude less costly than one in

00:13:53,329 --> 00:13:58,369
production and I feel like I should do

00:13:56,119 --> 00:14:00,739
orders of orders of magnitude because it

00:13:58,369 --> 00:14:03,199
truly is the case we want to catch

00:14:00,739 --> 00:14:05,660
things early on because as soon as they

00:14:03,199 --> 00:14:08,119
get out into the wild as we saw with

00:14:05,660 --> 00:14:10,699
with one a crime it doesn't matter how

00:14:08,119 --> 00:14:14,480
quickly you find it and patch it things

00:14:10,699 --> 00:14:16,970
will still go wrong in in reality okay

00:14:14,480 --> 00:14:18,939
so so how do we do this well one thing

00:14:16,970 --> 00:14:22,579
that we can do is is run time checking

00:14:18,939 --> 00:14:24,290
and this is great the problem with this

00:14:22,579 --> 00:14:26,600
and some memory unsafe languages is that

00:14:24,290 --> 00:14:29,749
it again requires discipline so you need

00:14:26,600 --> 00:14:31,490
the programmer to to know when to use

00:14:29,749 --> 00:14:33,290
these constructs and make sure that they

00:14:31,490 --> 00:14:35,540
use them at all times and sometimes it's

00:14:33,290 --> 00:14:38,860
impossible or it's very least extremely

00:14:35,540 --> 00:14:40,730
hard to know when runtime checking

00:14:38,860 --> 00:14:43,100
contracts are used and when they're not

00:14:40,730 --> 00:14:45,529
and and which ones should be used one

00:14:43,100 --> 00:14:48,290
and so you're you're back to static

00:14:45,529 --> 00:14:49,759
analysis with its imperfections and so

00:14:48,290 --> 00:14:53,480
again runtime checks have their place

00:14:49,759 --> 00:14:54,980
but they also you know introduce runtime

00:14:53,480 --> 00:15:00,769
overhead that might not be appropriate

00:14:54,980 --> 00:15:02,360
for for specific use cases okay next we

00:15:00,769 --> 00:15:05,660
have garbage collection which again is

00:15:02,360 --> 00:15:07,639
also wonderful and I definitely think

00:15:05,660 --> 00:15:09,529
that people should look into garbage

00:15:07,639 --> 00:15:12,199
collection if it works for your use case

00:15:09,529 --> 00:15:15,589
and this doesn't just mean kind of you

00:15:12,199 --> 00:15:18,009
know Java style or c-sharp style tracing

00:15:15,589 --> 00:15:21,439
garbage collection but also things like

00:15:18,009 --> 00:15:24,589
reference counting and the sort are

00:15:21,439 --> 00:15:26,329
definitely useful so if you can use

00:15:24,589 --> 00:15:28,819
something like c-sharp and by all means

00:15:26,329 --> 00:15:31,490
go ahead and do it but what we're

00:15:28,819 --> 00:15:31,760
talking about here is system software so

00:15:31,490 --> 00:15:33,560
we're not

00:15:31,760 --> 00:15:35,480
about the software at the very the very

00:15:33,560 --> 00:15:38,630
base of what we're writing we're really

00:15:35,480 --> 00:15:40,730
we only have kind of assembly below it

00:15:38,630 --> 00:15:43,730
to really kind of get closer to the

00:15:40,730 --> 00:15:45,590
machine and so things like garbage

00:15:43,730 --> 00:15:47,950
collection are oftentimes not acceptable

00:15:45,590 --> 00:15:51,290
and runtime checks are not acceptable

00:15:47,950 --> 00:15:52,370
and so with this in mind keep in mind

00:15:51,290 --> 00:15:54,110
when we're talking about this we're

00:15:52,370 --> 00:15:55,910
really talking about system software so

00:15:54,110 --> 00:15:57,680
basically anything where a garbage

00:15:55,910 --> 00:15:59,210
collector is not acceptable so if your

00:15:57,680 --> 00:16:01,160
mind starts going back to garbage

00:15:59,210 --> 00:16:03,260
collection you can just forget about it

00:16:01,160 --> 00:16:06,410
because by definition we're talking

00:16:03,260 --> 00:16:08,600
about non garbage collected systems and

00:16:06,410 --> 00:16:10,490
so with that in mind the Microsoft

00:16:08,600 --> 00:16:13,520
Security Response Center which I will

00:16:10,490 --> 00:16:16,190
refer to as nsrc they're the team that's

00:16:13,520 --> 00:16:18,850
in charge of of these kinds of security

00:16:16,190 --> 00:16:20,990
related issues inside of Microsoft

00:16:18,850 --> 00:16:23,360
decided to form the safe systems

00:16:20,990 --> 00:16:25,550
programming language's initiative which

00:16:23,360 --> 00:16:28,790
is an initiative to try and address this

00:16:25,550 --> 00:16:31,070
issue by by making our systems

00:16:28,790 --> 00:16:33,230
programming languages safer and so the

00:16:31,070 --> 00:16:35,780
first prong of that is making C++ safer

00:16:33,230 --> 00:16:37,580
when we can but we know that that is

00:16:35,780 --> 00:16:40,490
kind of has limited returns and we're

00:16:37,580 --> 00:16:41,570
kind of reaching the wall when it comes

00:16:40,490 --> 00:16:44,450
to that

00:16:41,570 --> 00:16:46,160
the second is developing new programming

00:16:44,450 --> 00:16:49,370
languages or programming constructs that

00:16:46,160 --> 00:16:52,370
allows two systems level programming in

00:16:49,370 --> 00:16:54,590
a safe way and recently the Verona

00:16:52,370 --> 00:16:56,930
project which is from MSR Microsoft

00:16:54,590 --> 00:16:59,570
Research was just released as a very

00:16:56,930 --> 00:17:01,520
very early version as a possible kind of

00:16:59,570 --> 00:17:05,060
it's a research project for in how you

00:17:01,520 --> 00:17:07,280
can do systems level programming and in

00:17:05,060 --> 00:17:08,839
a safe way but the third prong is kind

00:17:07,280 --> 00:17:12,470
of the one that were most keen on right

00:17:08,839 --> 00:17:15,650
now and that is adopting the the

00:17:12,470 --> 00:17:16,520
industry's best chance for addressing

00:17:15,650 --> 00:17:20,209
this issue head-on

00:17:16,520 --> 00:17:21,470
and we believe that to be rust and so by

00:17:20,209 --> 00:17:24,079
the way for those that don't know this

00:17:21,470 --> 00:17:26,420
is this is ferrous and ferrous will be

00:17:24,079 --> 00:17:29,030
telling us a little bit about what rust

00:17:26,420 --> 00:17:32,540
offers us so the first thing is

00:17:29,030 --> 00:17:34,100
performance we need performance and when

00:17:32,540 --> 00:17:35,840
it comes to performance the way you can

00:17:34,100 --> 00:17:41,330
think about rust is that it is on par

00:17:35,840 --> 00:17:42,500
with CNN C++ in the and the components

00:17:41,330 --> 00:17:44,580
that we've already started doing some

00:17:42,500 --> 00:17:48,149
rewrites on or development and

00:17:44,580 --> 00:17:50,880
we see performance on par with C++ and

00:17:48,149 --> 00:17:53,039
if if we had to pick is it faster or

00:17:50,880 --> 00:17:54,690
slower it's very hard to say because we

00:17:53,039 --> 00:17:58,140
you know it requires a kind of

00:17:54,690 --> 00:17:59,789
large-scale study but it seems to lean

00:17:58,140 --> 00:18:05,130
towards faster we have a couple of

00:17:59,789 --> 00:18:07,049
components that because of certain very

00:18:05,130 --> 00:18:09,450
technical issues they they came out to

00:18:07,049 --> 00:18:12,600
be slightly faster than the C++

00:18:09,450 --> 00:18:13,980
component was now of course the C++

00:18:12,600 --> 00:18:15,750
component could have been rewritten to

00:18:13,980 --> 00:18:17,880
be probably just as fast so it's it's

00:18:15,750 --> 00:18:21,149
not necessarily important whether rust

00:18:17,880 --> 00:18:23,399
in C++ how they how they differ in

00:18:21,149 --> 00:18:25,049
performance characteristics it comes

00:18:23,399 --> 00:18:26,429
down to the fact that they're similar

00:18:25,049 --> 00:18:29,370
and should be thought of in similar

00:18:26,429 --> 00:18:32,370
terms and the next point is correctness

00:18:29,370 --> 00:18:33,720
so this is a very hand wavy thing but

00:18:32,370 --> 00:18:36,919
it's something that kind of if you've

00:18:33,720 --> 00:18:40,110
programmed in rust before have have seen

00:18:36,919 --> 00:18:43,139
typically you end up debugging rust

00:18:40,110 --> 00:18:44,700
programs at runtime less often because

00:18:43,139 --> 00:18:47,250
it has a lot of those compiled time

00:18:44,700 --> 00:18:48,870
constructs that allow for correct

00:18:47,250 --> 00:18:50,279
programs programs that just don't have

00:18:48,870 --> 00:18:51,929
bugs in them and of course it's very

00:18:50,279 --> 00:18:54,169
possible to write bugs in and rust I

00:18:51,929 --> 00:18:57,980
would I don't want to to act otherwise

00:18:54,169 --> 00:19:02,100
but but rust that definitely excels in

00:18:57,980 --> 00:19:06,210
in creating programs that tend to run

00:19:02,100 --> 00:19:07,679
correctly when when they compile and and

00:19:06,210 --> 00:19:10,010
features that allow that are things like

00:19:07,679 --> 00:19:14,220
it doesn't have nulls

00:19:10,010 --> 00:19:17,700
so that's all checked for you it allows

00:19:14,220 --> 00:19:20,580
you to encapsulate unsafe api's and safe

00:19:17,700 --> 00:19:23,070
api so that even if you have to do nasty

00:19:20,580 --> 00:19:28,200
bits you you don't have to worry too

00:19:23,070 --> 00:19:30,299
much about you know things going wrong

00:19:28,200 --> 00:19:31,860
you can you can encapsulate it in a safe

00:19:30,299 --> 00:19:34,110
API that others will be able to use

00:19:31,860 --> 00:19:37,590
correctly all but I mean things like

00:19:34,110 --> 00:19:39,690
rust doesn't have exceptions so if

00:19:37,590 --> 00:19:43,080
something can fail you kind of know from

00:19:39,690 --> 00:19:44,490
its from its function signature whether

00:19:43,080 --> 00:19:46,019
it can fail and you're kind of forced

00:19:44,490 --> 00:19:47,580
towards handling that or at least

00:19:46,019 --> 00:19:49,470
acknowledging the fact that it can

00:19:47,580 --> 00:19:50,399
happen which can help you build more

00:19:49,470 --> 00:19:53,190
robust systems

00:19:50,399 --> 00:19:54,899
I mean lastly you know I think

00:19:53,190 --> 00:19:56,909
productivity is important to point out

00:19:54,899 --> 00:19:58,830
rust does have a steep learning curve

00:19:56,909 --> 00:20:00,809
so you won't be productive at the

00:19:58,830 --> 00:20:02,580
beginning but once you get over that

00:20:00,809 --> 00:20:04,919
learning curve it definitely pays off in

00:20:02,580 --> 00:20:07,440
dividends and we're seeing that across

00:20:04,919 --> 00:20:09,359
the board it's hard to quantify that

00:20:07,440 --> 00:20:11,999
but I think it's it's without

00:20:09,359 --> 00:20:15,149
controversy to say they go once you get

00:20:11,999 --> 00:20:17,669
up to speed a seasoned C++ developer can

00:20:15,149 --> 00:20:19,769
be just as productive and rust and and

00:20:17,669 --> 00:20:21,779
it seems like they can be more

00:20:19,769 --> 00:20:25,169
productive because of this kind of more

00:20:21,779 --> 00:20:27,359
correct property that we talked about

00:20:25,169 --> 00:20:30,479
before of but you know it's hard to

00:20:27,359 --> 00:20:33,090
prove these things so we hesitant to

00:20:30,479 --> 00:20:35,970
kind of clean that out right and and

00:20:33,090 --> 00:20:37,320
again rust also has things like modern

00:20:35,970 --> 00:20:39,389
tooling like a package manager and

00:20:37,320 --> 00:20:42,210
built-in test framework and things like

00:20:39,389 --> 00:20:44,239
that that kind of people outside of the

00:20:42,210 --> 00:20:46,590
system space have come accustomed to

00:20:44,239 --> 00:20:48,929
well it turns out systems programmers

00:20:46,590 --> 00:20:52,679
can have nice things too and and this

00:20:48,929 --> 00:20:54,929
really shows when Stack Overflow comes

00:20:52,679 --> 00:20:56,700
out with a survey every year of the most

00:20:54,929 --> 00:20:58,109
loved programming languages and rusts

00:20:56,700 --> 00:21:00,929
has been number one for the past four

00:20:58,109 --> 00:21:03,690
years and you know it doesn't seem like

00:21:00,929 --> 00:21:05,970
the trend is ending I don't know how to

00:21:03,690 --> 00:21:07,889
go beyond that other than I feel the

00:21:05,970 --> 00:21:10,169
same way as well

00:21:07,889 --> 00:21:12,239
and so I think the thing to take away

00:21:10,169 --> 00:21:14,789
from this is that it's it's definitely

00:21:12,239 --> 00:21:16,799
not a pain to adopt rust as a from a

00:21:14,789 --> 00:21:20,340
programmers perspective people tend to

00:21:16,799 --> 00:21:22,559
enjoy it but but this is all well and

00:21:20,340 --> 00:21:25,349
good and this is definitely a reasons

00:21:22,559 --> 00:21:27,509
for you as a as a programmer to go out

00:21:25,349 --> 00:21:29,309
and check out rust because you want to

00:21:27,509 --> 00:21:31,379
get into it and and you might be

00:21:29,309 --> 00:21:33,869
interested in it but kind of as an

00:21:31,379 --> 00:21:35,549
organization as large as Microsoft all

00:21:33,869 --> 00:21:38,340
this is a little bit too fuzzy and a

00:21:35,549 --> 00:21:40,710
little bit too flowery and we we need

00:21:38,340 --> 00:21:42,210
some kind of better justification for

00:21:40,710 --> 00:21:45,629
adopting the language and that comes

00:21:42,210 --> 00:21:47,399
back to safety that rust is a completely

00:21:45,629 --> 00:21:49,919
memory safe language by default without

00:21:47,399 --> 00:21:52,649
garbage collection with minimal runtime

00:21:49,919 --> 00:21:54,720
checking so really only where when time

00:21:52,649 --> 00:21:56,879
checking is kind of necessary will you

00:21:54,720 --> 00:21:58,529
end up doing runtime checking and it's

00:21:56,879 --> 00:22:01,739
all opt-in and very obvious where you're

00:21:58,529 --> 00:22:04,769
doing that and it's free of things like

00:22:01,739 --> 00:22:07,049
Dane races which you know this is not

00:22:04,769 --> 00:22:09,770
really a feature of any language that I

00:22:07,049 --> 00:22:12,410
know of maybe outside

00:22:09,770 --> 00:22:14,660
elixir Erlang has adopted an industry

00:22:12,410 --> 00:22:17,630
that has this property where you are

00:22:14,660 --> 00:22:21,110
definitely forced to to deal with red

00:22:17,630 --> 00:22:26,060
safety and and unthread safe programs

00:22:21,110 --> 00:22:27,920
just don't don't compile and if you have

00:22:26,060 --> 00:22:30,050
a I think the most important thing here

00:22:27,920 --> 00:22:31,970
is the ability to to wrap on safe usage

00:22:30,050 --> 00:22:34,100
so Russ does have an unsafe keyword that

00:22:31,970 --> 00:22:35,390
allows you to do the nasty things that

00:22:34,100 --> 00:22:37,790
you might have to do as a systems

00:22:35,390 --> 00:22:40,550
programmer you know if you're writing a

00:22:37,790 --> 00:22:45,530
device driver Russ doesn't know that

00:22:40,550 --> 00:22:48,590
writing to memory address 0 X 1 7 3 4 a

00:22:45,530 --> 00:22:51,110
B is the right place to write to but you

00:22:48,590 --> 00:22:52,670
can encapsulate that in the safe API and

00:22:51,110 --> 00:22:55,240
then people who are using your code

00:22:52,670 --> 00:22:58,280
don't have to worry about that nastiness

00:22:55,240 --> 00:23:00,350
they can use it without fear and if they

00:22:58,280 --> 00:23:02,330
use it incorrectly the code simply won't

00:23:00,350 --> 00:23:04,400
compile and this is really what we talk

00:23:02,330 --> 00:23:06,140
about when we think of Russ 10x

00:23:04,400 --> 00:23:09,800
improvement the thing that makes it

00:23:06,140 --> 00:23:12,860
worth investing in is that it is it

00:23:09,800 --> 00:23:14,690
seems to be at least 10 times better

00:23:12,860 --> 00:23:17,480
than what we currently have and that's

00:23:14,690 --> 00:23:19,640
kind of the threshold that we've seen

00:23:17,480 --> 00:23:21,110
Jeremy Fitz Harding here from from

00:23:19,640 --> 00:23:22,010
Facebook talked about this in his talk

00:23:21,110 --> 00:23:24,800
at Wes conf

00:23:22,010 --> 00:23:29,000
last year how at Facebook they they also

00:23:24,800 --> 00:23:32,300
see this as as Russ 10x improvement that

00:23:29,000 --> 00:23:33,950
allows justifies that investment and and

00:23:32,300 --> 00:23:37,460
what we mean by that is if you take a C

00:23:33,950 --> 00:23:39,020
or C++ code base and you ask yourself

00:23:37,460 --> 00:23:41,180
how much of that code base do we need to

00:23:39,020 --> 00:23:43,430
secure the audit for memory safety

00:23:41,180 --> 00:23:45,740
issues specifically and the answer of

00:23:43,430 --> 00:23:47,900
course is 100% you have to look at every

00:23:45,740 --> 00:23:50,480
single line of the C++ code to know

00:23:47,900 --> 00:23:52,910
whether you're doing something funny or

00:23:50,480 --> 00:23:55,160
not and something that you shouldn't do

00:23:52,910 --> 00:23:59,600
when it comes to memory safety and with

00:23:55,160 --> 00:24:01,340
rust the answer is much smaller and you

00:23:59,600 --> 00:24:03,410
know it's hard we don't have exact

00:24:01,340 --> 00:24:06,440
figures right now for the software that

00:24:03,410 --> 00:24:08,030
we write but just looking out at what's

00:24:06,440 --> 00:24:11,030
currently been written in the rust

00:24:08,030 --> 00:24:13,790
ecosystem it seems to be that for kind

00:24:11,030 --> 00:24:17,120
of fundamental fundamental rust packages

00:24:13,790 --> 00:24:18,890
that exists today around 1% of the code

00:24:17,120 --> 00:24:21,230
is unsafe so that means you have to look

00:24:18,890 --> 00:24:23,360
at that 1% of the code and as long as

00:24:21,230 --> 00:24:23,570
it's doing the right thing which you can

00:24:23,360 --> 00:24:26,540
tell

00:24:23,570 --> 00:24:29,870
locally then you can be sure that the

00:24:26,540 --> 00:24:32,210
rest of that code that 99% is completely

00:24:29,870 --> 00:24:34,310
free of memory safety issues which is

00:24:32,210 --> 00:24:36,050
which is really great and so the issue

00:24:34,310 --> 00:24:38,260
that we really say is for security

00:24:36,050 --> 00:24:42,380
critical software of C++ is no longer

00:24:38,260 --> 00:24:44,240
acceptable in this regard and the bet

00:24:42,380 --> 00:24:46,130
then is Russ allows us to write

00:24:44,240 --> 00:24:50,660
performance security critical components

00:24:46,130 --> 00:24:52,880
safely but you know at the end of the

00:24:50,660 --> 00:24:56,150
day this is all well and good but the

00:24:52,880 --> 00:24:58,340
real challenge here is integrating rust

00:24:56,150 --> 00:25:00,440
instead of rewriting the entire world we

00:24:58,340 --> 00:25:03,050
have a lot of C++ at Microsoft way a lot

00:25:00,440 --> 00:25:03,860
of C and C++ in the world and that code

00:25:03,050 --> 00:25:06,800
is not going anywhere

00:25:03,860 --> 00:25:08,360
and in fact in microsoft c++ continues

00:25:06,800 --> 00:25:11,810
to be written and will continue to be

00:25:08,360 --> 00:25:15,590
written for for a while to come if not

00:25:11,810 --> 00:25:18,470
forever and and the real challenge then

00:25:15,590 --> 00:25:20,150
is to see if we can get rust integrated

00:25:18,470 --> 00:25:25,040
into that world so that we can make sure

00:25:20,150 --> 00:25:26,690
that that you know we benefit from rust

00:25:25,040 --> 00:25:28,460
without having to just do everything all

00:25:26,690 --> 00:25:31,220
once and rewrite the entire world so

00:25:28,460 --> 00:25:34,850
let's look at a few of those challenges

00:25:31,220 --> 00:25:36,980
specifically the first one that we have

00:25:34,850 --> 00:25:39,140
here is existing tooling and

00:25:36,980 --> 00:25:42,650
specifically assumptions or that we have

00:25:39,140 --> 00:25:45,620
around MSV c so restaurants on LLVM we

00:25:42,650 --> 00:25:47,840
are almost exclusively an MS vc shop at

00:25:45,620 --> 00:25:51,970
Microsoft although has changed a little

00:25:47,840 --> 00:25:53,840
bit with with the new edge browser and

00:25:51,970 --> 00:25:57,560
you know we have some tooling that

00:25:53,840 --> 00:25:59,960
assumes MSV C binaries and when you

00:25:57,560 --> 00:26:02,960
build with LLVM you get something

00:25:59,960 --> 00:26:04,580
different now Russ uses the same link or

00:26:02,960 --> 00:26:07,460
the MSC C linker and so that helps a

00:26:04,580 --> 00:26:10,640
bunch but there's definitely some

00:26:07,460 --> 00:26:12,920
challenges there beyond that build

00:26:10,640 --> 00:26:16,340
systems cargo is Russ built in built

00:26:12,920 --> 00:26:19,070
system cargo playing Ron around with

00:26:16,340 --> 00:26:22,940
existing build systems can definitely be

00:26:19,070 --> 00:26:25,220
a challenge and cargo is wonderful for

00:26:22,940 --> 00:26:26,900
kind of pure rust projects or rust

00:26:25,220 --> 00:26:29,210
projects with that one occasional C

00:26:26,900 --> 00:26:32,180
dependency but when rust is the new

00:26:29,210 --> 00:26:35,960
person in town and Russ needs to play

00:26:32,180 --> 00:26:37,330
along with with vast amount of of

00:26:35,960 --> 00:26:39,430
existing sequel

00:26:37,330 --> 00:26:41,590
Plus code things can get challenging and

00:26:39,430 --> 00:26:45,040
so we're figuring out ways to get around

00:26:41,590 --> 00:26:47,170
this another one is it is interrupt so

00:26:45,040 --> 00:26:50,230
we have it as we said a ton of existing

00:26:47,170 --> 00:26:51,970
C++ code you know we have things in the

00:26:50,230 --> 00:26:53,710
rest community like bind gen which allow

00:26:51,970 --> 00:26:57,190
you to kind of it's a tool that reads

00:26:53,710 --> 00:26:59,260
rust code and produces C and C++ headers

00:26:57,190 --> 00:27:02,040
and C Bundren is the other way the law

00:26:59,260 --> 00:27:05,200
reads C++ headers and can generate

00:27:02,040 --> 00:27:08,080
breast code and so this works well for

00:27:05,200 --> 00:27:10,630
simple API is for particularly for C

00:27:08,080 --> 00:27:13,030
api's but we have a lot of rich C++ code

00:27:10,630 --> 00:27:14,380
so how can we interact with rust that

00:27:13,030 --> 00:27:16,420
doesn't have this kind of native C++

00:27:14,380 --> 00:27:20,680
interrupt and so we're looking at things

00:27:16,420 --> 00:27:24,150
like interrupting using calm or WinRT

00:27:20,680 --> 00:27:26,410
that are these kind of a BIS custom API

00:27:24,150 --> 00:27:28,710
interrupt layers that already existed

00:27:26,410 --> 00:27:31,060
and are widely used at Microsoft and

00:27:28,710 --> 00:27:33,940
making sure that we can use them from

00:27:31,060 --> 00:27:36,460
from rusts code as well and then there's

00:27:33,940 --> 00:27:39,340
some some kind of weird stuff we have to

00:27:36,460 --> 00:27:40,870
have a trusted tool chain rust was

00:27:39,340 --> 00:27:44,470
originally built with Oh camel it's now

00:27:40,870 --> 00:27:46,900
built in itself do we go back and build

00:27:44,470 --> 00:27:48,640
a no camel compiler and then you know

00:27:46,900 --> 00:27:50,470
compile all the Russell compilers all

00:27:48,640 --> 00:27:52,150
the way up till till today we'd be doing

00:27:50,470 --> 00:27:54,430
that for a very long time so we have to

00:27:52,150 --> 00:27:56,560
build a trusted tool chain luckily

00:27:54,430 --> 00:27:59,380
there's a project out there for compiler

00:27:56,560 --> 00:28:01,270
Russ compiler written in C++ that does

00:27:59,380 --> 00:28:03,820
very minimal stuff it's not complete but

00:28:01,270 --> 00:28:07,780
it's enough to to build the compiler

00:28:03,820 --> 00:28:09,820
itself and then we can use that C++

00:28:07,780 --> 00:28:12,280
generator bus compiler to kind of get us

00:28:09,820 --> 00:28:14,440
up to the latest version which is very

00:28:12,280 --> 00:28:16,150
interesting we have binary security

00:28:14,440 --> 00:28:18,670
policies that need to be follow that

00:28:16,150 --> 00:28:23,200
followed in compliance is just its own

00:28:18,670 --> 00:28:24,930
thing and then you know humans I think

00:28:23,200 --> 00:28:27,220
this is the last and the greatest

00:28:24,930 --> 00:28:29,080
challenge that we have with rust is

00:28:27,220 --> 00:28:30,760
convincing others we have a lot of

00:28:29,080 --> 00:28:33,580
people who have dedicated a long time to

00:28:30,760 --> 00:28:36,580
C++ and you know naturally there is

00:28:33,580 --> 00:28:38,470
resistance to adopting new things can we

00:28:36,580 --> 00:28:40,210
convince them to give this a try and and

00:28:38,470 --> 00:28:43,420
and most of all can we train them to do

00:28:40,210 --> 00:28:45,100
the right thing we typically see

00:28:43,420 --> 00:28:46,900
excitement but we know that as we scale

00:28:45,100 --> 00:28:48,910
this out more and more that that

00:28:46,900 --> 00:28:50,110
excitement will wane and there will be

00:28:48,910 --> 00:28:51,020
some people that just want to get their

00:28:50,110 --> 00:28:52,340
job done

00:28:51,020 --> 00:28:53,990
in the language that they already know

00:28:52,340 --> 00:28:56,140
and so this will definitely be

00:28:53,990 --> 00:29:00,200
definitely be a challenge going forward

00:28:56,140 --> 00:29:03,320
a little bit about the rusts use in

00:29:00,200 --> 00:29:05,450
industry of course Microsoft we are

00:29:03,320 --> 00:29:09,740
starting to use at Facebook seems to be

00:29:05,450 --> 00:29:12,350
adopting it's quite a bit amazon has

00:29:09,740 --> 00:29:13,670
said that they are using Apple we we

00:29:12,350 --> 00:29:18,140
know for a fact that they're using it

00:29:13,670 --> 00:29:20,420
for for lambda the the runtime that runs

00:29:18,140 --> 00:29:23,720
in some lambda is written in rust and

00:29:20,420 --> 00:29:25,760
they have also said that stuff inside of

00:29:23,720 --> 00:29:27,440
ec2 and things like that is written in

00:29:25,760 --> 00:29:29,360
rust as well so we're seeing that there

00:29:27,440 --> 00:29:31,070
Google as adopted it Dropbox has

00:29:29,360 --> 00:29:32,720
rewritten their sync file sync in June

00:29:31,070 --> 00:29:37,460
minute until an arm are both

00:29:32,720 --> 00:29:39,800
investigating CloudFlare is a huge user

00:29:37,460 --> 00:29:42,200
and they kind of smaller cloud based

00:29:39,800 --> 00:29:44,530
company Mozilla the original creator of

00:29:42,200 --> 00:29:47,840
rust is still using it quite a bit and

00:29:44,530 --> 00:29:50,000
also the likes of companies like discord

00:29:47,840 --> 00:29:53,120
as well using it so there's there is

00:29:50,000 --> 00:29:55,190
adoption of rust happening and we

00:29:53,120 --> 00:29:58,700
definitely hope to be at the forefront

00:29:55,190 --> 00:30:00,110
of that and so a little bit real quick

00:29:58,700 --> 00:30:01,100
about resources if you're if you're

00:30:00,110 --> 00:30:04,070
interested in learning the language

00:30:01,100 --> 00:30:05,510
because I assume a lot of us out there

00:30:04,070 --> 00:30:08,360
are devs and we just want to get our

00:30:05,510 --> 00:30:10,340
hands in some code enough with you know

00:30:08,360 --> 00:30:13,700
the management talk here these are some

00:30:10,340 --> 00:30:16,610
great resources the book is fantastic

00:30:13,700 --> 00:30:17,930
it's deep lab Nick was speaking today at

00:30:16,610 --> 00:30:19,700
this conference he is the co-author of

00:30:17,930 --> 00:30:21,800
this book I definitely recommend

00:30:19,700 --> 00:30:22,760
starting with the book it's a it's a

00:30:21,800 --> 00:30:24,950
really great resource for learning

00:30:22,760 --> 00:30:26,870
language and then next you have rust by

00:30:24,950 --> 00:30:29,680
example which takes you through example

00:30:26,870 --> 00:30:32,380
rust code to get to know it better and

00:30:29,680 --> 00:30:35,000
wrestling this is a kind of interactive

00:30:32,380 --> 00:30:36,260
command-line interface for for learning

00:30:35,000 --> 00:30:37,730
rust which is really great there's a

00:30:36,260 --> 00:30:39,770
bunch of others so just go ahead and

00:30:37,730 --> 00:30:42,710
search out there there's more books and

00:30:39,770 --> 00:30:45,740
tutorials give it a try and see what you

00:30:42,710 --> 00:30:50,050
see if you like it and we I think we as

00:30:45,740 --> 00:30:52,880
an industry in general need to be very

00:30:50,050 --> 00:30:55,430
very aware of this language and give it

00:30:52,880 --> 00:30:58,250
an honest shot because we have a problem

00:30:55,430 --> 00:31:00,680
that we have not been able to fix for a

00:30:58,250 --> 00:31:03,290
very long time and rust might be the way

00:31:00,680 --> 00:31:05,390
that we go ahead and fix that and with

00:31:03,290 --> 00:31:10,430
that I'm going to end it here

00:31:05,390 --> 00:31:11,720
with any questions let me know if you

00:31:10,430 --> 00:31:15,410
have anything anything you want to talk

00:31:11,720 --> 00:31:19,300
about anything that might be of interest

00:31:15,410 --> 00:31:22,310
to you hmm

00:31:19,300 --> 00:31:24,350
we I saw one question here do

00:31:22,310 --> 00:31:26,990
garbage-collected languages experienced

00:31:24,350 --> 00:31:31,490
more or less memory Seavey's

00:31:26,990 --> 00:31:35,450
than rust that's a very hard question to

00:31:31,490 --> 00:31:38,000
answer I'll tell you my gut opinion and

00:31:35,450 --> 00:31:41,780
take it with a big old grain of salt I

00:31:38,000 --> 00:31:44,240
would imagine that there will be more

00:31:41,780 --> 00:31:45,740
memory CDs and rust than in garbage

00:31:44,240 --> 00:31:48,940
collector languages because of the

00:31:45,740 --> 00:31:51,470
nature of work that rust is meant to do

00:31:48,940 --> 00:31:53,750
in garbage-collected languages you

00:31:51,470 --> 00:31:56,570
typically don't have to do very low

00:31:53,750 --> 00:31:59,390
level programming where you are writing

00:31:56,570 --> 00:32:01,280
to arbitrary places the memory where

00:31:59,390 --> 00:32:05,180
you're potentially doing in line

00:32:01,280 --> 00:32:06,980
assembly where you don't have an

00:32:05,180 --> 00:32:10,310
operating system to do anything for you

00:32:06,980 --> 00:32:11,930
you are the operating system most times

00:32:10,310 --> 00:32:13,580
you use a garbage collected language you

00:32:11,930 --> 00:32:16,280
can rely on that infrastructure being

00:32:13,580 --> 00:32:17,540
there and and oftentimes with rust you

00:32:16,280 --> 00:32:20,030
don't have that so you might have to end

00:32:17,540 --> 00:32:23,000
up writing unsafe code and with that

00:32:20,030 --> 00:32:26,690
unsafe code I don't want to say all bets

00:32:23,000 --> 00:32:29,570
are off because you know unsafe rust is

00:32:26,690 --> 00:32:30,740
a superset of safe rust so you still

00:32:29,570 --> 00:32:32,960
have all the production there but it

00:32:30,740 --> 00:32:35,540
allows you to do things that are not

00:32:32,960 --> 00:32:38,480
safe that you I should say that you

00:32:35,540 --> 00:32:40,820
should verify you need to verify are

00:32:38,480 --> 00:32:43,070
safe and we all know humans will make

00:32:40,820 --> 00:32:46,760
mistakes so there will be CDs written

00:32:43,070 --> 00:32:50,000
and rust now if the question is is there

00:32:46,760 --> 00:32:51,980
the same amount of CDs and safe rust and

00:32:50,000 --> 00:32:55,220
garbage collected languages of just the

00:32:51,980 --> 00:32:58,430
safe subsets of rust then I would say

00:32:55,220 --> 00:33:09,050
probably they're about equal he's

00:32:58,430 --> 00:33:10,700
hovering around zero so so with

00:33:09,050 --> 00:33:12,470
Microsoft investing and developing the

00:33:10,700 --> 00:33:16,540
rust inspired language Verona's am i

00:33:12,470 --> 00:33:18,210
still interested in adopting the rust so

00:33:16,540 --> 00:33:22,790
verona is a research

00:33:18,210 --> 00:33:25,590
project it's very interesting where

00:33:22,790 --> 00:33:29,700
where Verona will ultimately end up as a

00:33:25,590 --> 00:33:30,930
is a question that I'm first of all I'm

00:33:29,700 --> 00:33:34,140
not qualified answer because I'm not

00:33:30,930 --> 00:33:35,460
working on it but technical I hope I'm

00:33:34,140 --> 00:33:38,310
not overstepping my boundaries when I

00:33:35,460 --> 00:33:41,310
say we have no idea what her owner will

00:33:38,310 --> 00:33:43,200
turn into one possibility is that it

00:33:41,310 --> 00:33:44,940
goes nowhere and other possibility is

00:33:43,200 --> 00:33:48,690
that the ideas that are taken from it

00:33:44,940 --> 00:33:49,980
are adopted into rust itself and the

00:33:48,690 --> 00:33:52,170
third possibility is that it becomes a

00:33:49,980 --> 00:33:55,350
language in its own outright I don't

00:33:52,170 --> 00:33:58,950
believe that Verona will fill every

00:33:55,350 --> 00:34:00,900
single nish that rust fills and so even

00:33:58,950 --> 00:34:04,080
if that third possibility turns into

00:34:00,900 --> 00:34:06,210
reality I think that rust and Verona

00:34:04,080 --> 00:34:08,670
would exist next to each other but

00:34:06,210 --> 00:34:11,400
that's a big if so it's way too early to

00:34:08,670 --> 00:34:13,770
tell that and if you're interested in

00:34:11,400 --> 00:34:15,360
these things head over to github and and

00:34:13,770 --> 00:34:22,470
check it out there and see what you

00:34:15,360 --> 00:34:24,270
think this may be a session in itself

00:34:22,470 --> 00:34:26,100
but can you speak to the language

00:34:24,270 --> 00:34:29,580
features that make it inherently safe

00:34:26,100 --> 00:34:32,070
while still performant that is 100% a

00:34:29,580 --> 00:34:35,010
session in its own I'll try to do it I

00:34:32,070 --> 00:34:41,790
maybe I could have prepared some code to

00:34:35,010 --> 00:34:43,800
show you rust has a a system built into

00:34:41,790 --> 00:34:49,050
its compiler called the the borrow

00:34:43,800 --> 00:34:52,770
checker that checks ownership of values

00:34:49,050 --> 00:34:55,080
and so statically it knows who owns a

00:34:52,770 --> 00:34:57,900
value who owns the memory of a

00:34:55,080 --> 00:35:00,210
particular value and it knows when to

00:34:57,900 --> 00:35:07,140
destroy it and so this is kind of

00:35:00,210 --> 00:35:10,410
related to ra Ã­Ã­- from c++ you it knows

00:35:07,140 --> 00:35:13,560
when to to destroy that value beyond

00:35:10,410 --> 00:35:16,410
that it also knows if you borrow a

00:35:13,560 --> 00:35:18,390
particular value like take a pointer to

00:35:16,410 --> 00:35:20,820
it for instance it knows how long that

00:35:18,390 --> 00:35:23,460
are LS or and can statically check that

00:35:20,820 --> 00:35:25,020
you do not drop the value don't destroy

00:35:23,460 --> 00:35:29,700
the value while you still have borrows

00:35:25,020 --> 00:35:31,559
out and beyond that it also enforces the

00:35:29,700 --> 00:35:33,329
reader/writer paradigm where

00:35:31,559 --> 00:35:34,499
there can be multiple readers of values

00:35:33,329 --> 00:35:38,479
through pointers so you can have

00:35:34,499 --> 00:35:43,489
multiple immutable references to things

00:35:38,479 --> 00:35:47,549
or and this is an exclusive or or

00:35:43,489 --> 00:35:49,289
mutable borrows to a specific value and

00:35:47,549 --> 00:35:53,160
this has a whole bunch of emergent

00:35:49,289 --> 00:35:56,999
properties that allow purely at runtime

00:35:53,160 --> 00:35:58,499
to verify things like that pointers are

00:35:56,999 --> 00:36:01,829
always valid in pointing to the other

00:35:58,499 --> 00:36:03,449
memory that you are not mutating

00:36:01,829 --> 00:36:06,719
something that you have a constant point

00:36:03,449 --> 00:36:08,430
or two that you are not mutating

00:36:06,719 --> 00:36:10,859
something on one thread while you're

00:36:08,430 --> 00:36:12,749
reading it on another a whole bunch of

00:36:10,859 --> 00:36:15,150
things and it all comes from this system

00:36:12,749 --> 00:36:16,829
of borrow checking and that all happens

00:36:15,150 --> 00:36:20,939
in the compiler at compile time

00:36:16,829 --> 00:36:23,699
and it falls away during runtime I think

00:36:20,939 --> 00:36:26,849
that's as best as I can do just talking

00:36:23,699 --> 00:36:28,439
here today but give the book a read and

00:36:26,849 --> 00:36:31,170
I think you'll you'll definitely come

00:36:28,439 --> 00:36:33,209
out of it with a better impression of of

00:36:31,170 --> 00:36:37,709
how rust accomplishes some of these

00:36:33,209 --> 00:36:39,239
things next question I see here is rust

00:36:37,709 --> 00:36:41,880
common enough that we're starting to see

00:36:39,239 --> 00:36:43,589
smaller open source projects adopted or

00:36:41,880 --> 00:36:45,329
is it still seen as an obscure enough

00:36:43,589 --> 00:36:48,509
language that it will discourage

00:36:45,329 --> 00:36:56,939
contributions that's a tough question to

00:36:48,509 --> 00:37:02,219
answer because I think how can I answer

00:36:56,939 --> 00:37:04,559
this I personally and again salt being

00:37:02,219 --> 00:37:06,599
thrown around here grains of it I

00:37:04,559 --> 00:37:08,189
personally have not seen people

00:37:06,599 --> 00:37:11,279
discouraged from contributing to a

00:37:08,189 --> 00:37:13,589
project because it's written in rust but

00:37:11,279 --> 00:37:16,049
I have seen people drawn to a project

00:37:13,589 --> 00:37:18,239
because it is written in rust I am sure

00:37:16,049 --> 00:37:20,099
that there are people who come to a

00:37:18,239 --> 00:37:23,279
project and see it written in this

00:37:20,099 --> 00:37:25,859
language and go I have no interest but

00:37:23,279 --> 00:37:28,739
that's probably true of every language I

00:37:25,859 --> 00:37:32,939
don't particularly want to contribute to

00:37:28,739 --> 00:37:39,269
a project in Pascal nothing against

00:37:32,939 --> 00:37:40,380
Pascal or let's let's take a more modern

00:37:39,269 --> 00:37:43,799
language or at least language that's

00:37:40,380 --> 00:37:45,270
used quite a bit Java I sorry I know I

00:37:43,799 --> 00:37:48,870
don't want to get into language bashing

00:37:45,270 --> 00:37:51,030
your job is great it's just not for me

00:37:48,870 --> 00:37:54,210
I wouldn't contribute to a project in

00:37:51,030 --> 00:37:56,160
Java is that javis fault is it you know

00:37:54,210 --> 00:37:57,420
does that mean Java is less valuable no

00:37:56,160 --> 00:37:59,430
there are plenty of people who would

00:37:57,420 --> 00:38:01,110
contribute to it so it's kind of hard to

00:37:59,430 --> 00:38:04,260
know these things

00:38:01,110 --> 00:38:07,380
rust has a an adoption level that I

00:38:04,260 --> 00:38:12,870
think it can it's definitely not an

00:38:07,380 --> 00:38:15,660
esoteric language there is data both

00:38:12,870 --> 00:38:19,380
public and not public that would suggest

00:38:15,660 --> 00:38:22,280
that is by it's by no means a super

00:38:19,380 --> 00:38:27,390
widely adopted language like JavaScript

00:38:22,280 --> 00:38:34,500
but that it is a adopted language in the

00:38:27,390 --> 00:38:36,830
same realm as as as a NGO or Swift or or

00:38:34,500 --> 00:38:41,490
Kotlin kind of these new and upcoming

00:38:36,830 --> 00:38:44,120
languages that don't have the huge broad

00:38:41,490 --> 00:38:48,150
industry adoption like Java or C sharp

00:38:44,120 --> 00:38:50,880
does but are still definitely definitely

00:38:48,150 --> 00:38:55,590
used for sure

00:38:50,880 --> 00:38:57,870
so hard to tell but I I can't say that I

00:38:55,590 --> 00:39:02,450
believe that rust is is still considered

00:38:57,870 --> 00:39:02,450
an esoteric language by a by any means

00:39:04,790 --> 00:39:09,450
saying if I missed any questions it had

00:39:07,920 --> 00:39:11,820
any additional questions and I haven't

00:39:09,450 --> 00:39:15,330
gotten to him yet please pop them down

00:39:11,820 --> 00:39:17,130
in the bottom of chat we have about five

00:39:15,330 --> 00:39:21,870
more minutes and I'm happy to keep

00:39:17,130 --> 00:39:24,450
talking about rust or if anybody wants

00:39:21,870 --> 00:39:29,550
to know how to learn the language more

00:39:24,450 --> 00:39:30,990
what what are some good use cases for

00:39:29,550 --> 00:39:32,550
them for the language as well where

00:39:30,990 --> 00:39:34,710
where does rust excel and where it

00:39:32,550 --> 00:39:38,970
doesn't Excel I'm happy to talk to that

00:39:34,710 --> 00:39:40,380
as well I will mention for instance we

00:39:38,970 --> 00:39:42,510
already talked about Steve cloud Nick

00:39:40,380 --> 00:39:44,910
giving a talk today on webassembly

00:39:42,510 --> 00:39:46,950
web assembly is definitely a very new

00:39:44,910 --> 00:39:49,290
technology that where a lot of

00:39:46,950 --> 00:39:51,120
development is happening in rust and so

00:39:49,290 --> 00:39:54,510
as far as new kind of up-and-coming

00:39:51,120 --> 00:39:56,820
technologies where rust is dominant that

00:39:54,510 --> 00:39:58,140
would definitely be a big one and we

00:39:56,820 --> 00:39:59,970
have a project

00:39:58,140 --> 00:40:02,309
Microsoft right now that I've helped out

00:39:59,970 --> 00:40:04,529
with for running webassembly work floats

00:40:02,309 --> 00:40:09,660
and kubernetes where we chose to write

00:40:04,529 --> 00:40:13,710
that in in rust instead of go for the

00:40:09,660 --> 00:40:15,359
reasons that one webassembly is is the

00:40:13,710 --> 00:40:17,760
rust dominated field currently and so

00:40:15,359 --> 00:40:20,700
you know there was a lot of tooling that

00:40:17,760 --> 00:40:22,589
would have been easier to adopt him and

00:40:20,700 --> 00:40:25,140
rust and two we just wanted to know what

00:40:22,589 --> 00:40:28,529
kubernetes twilly written in another

00:40:25,140 --> 00:40:31,589
language like rust would be like and it

00:40:28,529 --> 00:40:33,839
turns out it was really nice we there

00:40:31,589 --> 00:40:35,809
was a blog post recently posted from one

00:40:33,839 --> 00:40:38,549
of the engineers there talking about why

00:40:35,809 --> 00:40:40,170
why rust was adopted and and kind of

00:40:38,549 --> 00:40:41,990
general feelings about it and overall

00:40:40,170 --> 00:40:45,359
they were quite positive

00:40:41,990 --> 00:40:47,160
so is rust being used in any release

00:40:45,359 --> 00:40:49,819
microsoft products as of now and which

00:40:47,160 --> 00:40:53,099
if it is not secret so as far as

00:40:49,819 --> 00:40:56,609
publicly known projects where rust is

00:40:53,099 --> 00:40:59,160
being used as your iot is a iot solution

00:40:56,609 --> 00:41:04,099
that we have where rust is being used on

00:40:59,160 --> 00:41:06,569
device and also in the backend as well

00:41:04,099 --> 00:41:10,200
some of that code is open source so

00:41:06,569 --> 00:41:12,779
there's no secret there i would say a

00:41:10,200 --> 00:41:14,910
large majority of rust code that is

00:41:12,779 --> 00:41:17,130
going to be developed in the next year

00:41:14,910 --> 00:41:18,990
or has started to be developed now is

00:41:17,130 --> 00:41:21,210
just behind the scenes stuff that we

00:41:18,990 --> 00:41:23,309
hope you never have to care about other

00:41:21,210 --> 00:41:25,980
than that it's more secure because we

00:41:23,309 --> 00:41:28,410
wrote it in the secure language but

00:41:25,980 --> 00:41:31,079
there are a few other small things where

00:41:28,410 --> 00:41:32,900
us is being used one is the project the

00:41:31,079 --> 00:41:36,930
kubernetes project I just mentioned

00:41:32,900 --> 00:41:38,630
another one is vs code as some small I

00:41:36,930 --> 00:41:41,970
think the Installer is written and rust

00:41:38,630 --> 00:41:44,369
the regular expression program that they

00:41:41,970 --> 00:41:46,769
use is written in rust for doing search

00:41:44,369 --> 00:41:50,279
and things like that so so there's not a

00:41:46,769 --> 00:41:52,259
ton publicly known right now but I did I

00:41:50,279 --> 00:41:53,609
expect them to change some but I think a

00:41:52,259 --> 00:41:57,210
lot of the software that we all write

00:41:53,609 --> 00:41:59,309
and rust will be kind of private you

00:41:57,210 --> 00:42:04,019
know behind the scenes Magica going

00:41:59,309 --> 00:42:05,970
forward question of how does rust

00:42:04,019 --> 00:42:09,029
compare with going in terms of its

00:42:05,970 --> 00:42:10,349
features and target audience so I think

00:42:09,029 --> 00:42:11,270
the biggest thing to mention is that go

00:42:10,349 --> 00:42:16,970
has a garbage collector

00:42:11,270 --> 00:42:20,630
and so I think if you have a some kind

00:42:16,970 --> 00:42:22,340
of workloads that cannot stand a garbage

00:42:20,630 --> 00:42:25,340
collector then goes out of the question

00:42:22,340 --> 00:42:27,020
and then rust might be the tool that

00:42:25,340 --> 00:42:30,020
you're looking for I think that's kind

00:42:27,020 --> 00:42:32,990
of the biggest one all the other

00:42:30,020 --> 00:42:37,010
comparisons of rust Ingo are a little

00:42:32,990 --> 00:42:38,830
bit more mm up for opinion and kind of

00:42:37,010 --> 00:42:43,070
what what you how you think about

00:42:38,830 --> 00:42:45,670
engineering software engineering go has

00:42:43,070 --> 00:42:48,980
a richer standard library than rust does

00:42:45,670 --> 00:42:52,820
rust ended up adopting a less rich

00:42:48,980 --> 00:42:56,060
standard library so that third party

00:42:52,820 --> 00:42:57,920
people could experiment with things so

00:42:56,060 --> 00:42:59,300
for instance rust does not have an HTTP

00:42:57,920 --> 00:43:01,190
implementation in its standard library

00:42:59,300 --> 00:43:03,680
you have to take in a third-party

00:43:01,190 --> 00:43:05,510
dependency for that which you know it's

00:43:03,680 --> 00:43:07,760
quite easy to do but but it's not

00:43:05,510 --> 00:43:09,440
built-in and there there's a choice that

00:43:07,760 --> 00:43:12,170
you have to make there with go you don't

00:43:09,440 --> 00:43:16,760
have that go compiles faster than rust

00:43:12,170 --> 00:43:19,010
does but but go has has a less rich

00:43:16,760 --> 00:43:21,710
programming experience it doesn't have

00:43:19,010 --> 00:43:24,380
generics it's it doesn't have that

00:43:21,710 --> 00:43:26,570
strong of the type system or that rich

00:43:24,380 --> 00:43:29,660
the type system I should say those were

00:43:26,570 --> 00:43:31,760
places where rust really shines but go

00:43:29,660 --> 00:43:35,510
is easier to learn so there there are

00:43:31,760 --> 00:43:37,130
trade-offs there and I think I you know

00:43:35,510 --> 00:43:40,040
I only feel comfortable really saying if

00:43:37,130 --> 00:43:41,540
you need a garbage collector if you

00:43:40,040 --> 00:43:45,410
can't use the garbage collector use rust

00:43:41,540 --> 00:43:47,420
and otherwise you know I don't know pick

00:43:45,410 --> 00:43:50,480
one

00:43:47,420 --> 00:43:51,910
I think the target audience for kind of

00:43:50,480 --> 00:43:54,050
people who are creating quick

00:43:51,910 --> 00:43:55,940
microservices something I think is still

00:43:54,050 --> 00:43:58,460
something where go definitely beats rust

00:43:55,940 --> 00:43:59,510
at the current time I don't know if that

00:43:58,460 --> 00:44:04,369
will always be true though

00:43:59,510 --> 00:44:06,530
so we'll see any more questions that we

00:44:04,369 --> 00:44:09,140
can end out the day with doesn't look

00:44:06,530 --> 00:44:10,880
like so we're at the end of the session

00:44:09,140 --> 00:44:12,170
I want to thank everybody for for their

00:44:10,880 --> 00:44:14,630
attention it was really great

00:44:12,170 --> 00:44:15,740
please reach out to me online I think

00:44:14,630 --> 00:44:18,200
the best place to reach me is

00:44:15,740 --> 00:44:20,390
twitter.com slash Ryan underscore

00:44:18,200 --> 00:44:24,140
Levesque my first and last name with an

00:44:20,390 --> 00:44:24,470
underscore between them on Twitter I'm

00:44:24,140 --> 00:44:25,910
how

00:44:24,470 --> 00:44:28,190
they'd answer questions I'll be sticking

00:44:25,910 --> 00:44:31,250
around a little bit longer inside of the

00:44:28,190 --> 00:44:32,869
chat for for anybody who's curious and I

00:44:31,250 --> 00:44:35,330
hope you all enjoy the rest of the

00:44:32,869 --> 00:44:37,840
conference today so have a have a good

00:44:35,330 --> 00:44:37,840

YouTube URL: https://www.youtube.com/watch?v=NQBVUjdkLAA


