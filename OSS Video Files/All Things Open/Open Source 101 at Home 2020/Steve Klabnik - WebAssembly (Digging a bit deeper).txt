Title: Steve Klabnik - WebAssembly (Digging a bit deeper)
Publication date: 2020-05-20
Playlist: Open Source 101 at Home 2020
Description: 
	WebAssembly: Digging a bit deeper

Presented at: Open Source 101 at Home 2020
Presented by: Steve Klabnik, Cloudflare

Abstract: Unlike JavaScript, WebAssembly is distributed in binary form, not source form. In this talk, Steve will show you the inner workings of the WebAssembly format, talk about some challenges with debugging WebAssembly code, and talk about possible future improvements in this area.

For more info: https://opensource101.com
Captions: 
	00:00:05,400 --> 00:00:10,400
[Music]

00:00:10,000 --> 00:00:11,840
um

00:00:10,400 --> 00:00:13,519
all right so let's talk a little about

00:00:11,840 --> 00:00:15,519
some webassembly stuff

00:00:13,519 --> 00:00:16,960
um basically the first thing that we're

00:00:15,519 --> 00:00:20,080
going to talk about today is

00:00:16,960 --> 00:00:23,439
the webassembly format itself um

00:00:20,080 --> 00:00:24,560
so uh basically like wasm is a binary

00:00:23,439 --> 00:00:25,760
format we're going to talk about what

00:00:24,560 --> 00:00:26,640
that means we're going to talk about

00:00:25,760 --> 00:00:28,000
what's in it

00:00:26,640 --> 00:00:29,679
i think a lot of web developers haven't

00:00:28,000 --> 00:00:30,400
dealt with binary formats before so

00:00:29,679 --> 00:00:32,800
we're going to like

00:00:30,400 --> 00:00:33,840
demystify it a little bit and then we're

00:00:32,800 --> 00:00:35,840
going to talk about how

00:00:33,840 --> 00:00:37,840
webassembly has some challenges when it

00:00:35,840 --> 00:00:39,360
comes to debugging

00:00:37,840 --> 00:00:40,800
it's definitely not impossible it's just

00:00:39,360 --> 00:00:42,000
a little different and there's a bunch

00:00:40,800 --> 00:00:43,200
of stuff going on there

00:00:42,000 --> 00:00:45,280
and as part of that we're going to be

00:00:43,200 --> 00:00:48,320
talking about some things called elf

00:00:45,280 --> 00:00:49,760
dwarf and source maps um i made a little

00:00:48,320 --> 00:00:52,559
tolkien joke there

00:00:49,760 --> 00:00:53,680
uh there's there's some some good puns

00:00:52,559 --> 00:00:56,160
going on in this space

00:00:53,680 --> 00:00:57,360
uh around these kind of tools so um

00:00:56,160 --> 00:00:59,199
that's kind of what we're gonna get into

00:00:57,360 --> 00:01:02,640
is like the details of the wisem format

00:00:59,199 --> 00:01:05,760
stuff about debugging that kind of thing

00:01:02,640 --> 00:01:08,960
so uh what is the

00:01:05,760 --> 00:01:12,320
dot wasm format in the first place

00:01:08,960 --> 00:01:13,680
so we didn't really like

00:01:12,320 --> 00:01:15,360
i sort of assumed there's like this

00:01:13,680 --> 00:01:16,720
dawson format but let's talk about like

00:01:15,360 --> 00:01:17,520
what that means now it fits into

00:01:16,720 --> 00:01:20,240
webassembly

00:01:17,520 --> 00:01:21,680
so webassembly is a specification that

00:01:20,240 --> 00:01:24,640
is standard by the

00:01:21,680 --> 00:01:26,320
w3c um like many other web standards

00:01:24,640 --> 00:01:27,759
although the watt wg

00:01:26,320 --> 00:01:30,560
is also doing some standardization

00:01:27,759 --> 00:01:33,680
nowadays uh the w3c is the

00:01:30,560 --> 00:01:36,479
like you know sort of og standards body

00:01:33,680 --> 00:01:37,680
and so um as that means that in some

00:01:36,479 --> 00:01:38,799
sense webassembly is like a

00:01:37,680 --> 00:01:39,759
specification

00:01:38,799 --> 00:01:41,920
and then there's software that

00:01:39,759 --> 00:01:43,680
implements that specification so

00:01:41,920 --> 00:01:45,520
that means there's a lot of like details

00:01:43,680 --> 00:01:46,399
and stuff that's kind of like outside of

00:01:45,520 --> 00:01:48,640
the spec

00:01:46,399 --> 00:01:50,479
that still is practical when it comes to

00:01:48,640 --> 00:01:52,880
actually using a thing right like

00:01:50,479 --> 00:01:53,680
standard says like this is what exists

00:01:52,880 --> 00:01:55,040
but you

00:01:53,680 --> 00:01:56,960
don't that doesn't necessarily mean that

00:01:55,040 --> 00:01:58,640
it covers everything that matters to

00:01:56,960 --> 00:02:00,320
like day-to-day development when you're

00:01:58,640 --> 00:02:02,240
actually using the technology

00:02:00,320 --> 00:02:03,680
um and so this talk is kind of a little

00:02:02,240 --> 00:02:04,399
bit the first part is about what's in

00:02:03,680 --> 00:02:05,920
the standard

00:02:04,399 --> 00:02:07,520
the second part is about all this stuff

00:02:05,920 --> 00:02:09,119
that's being done outside of the

00:02:07,520 --> 00:02:10,080
standard to make it sort of usable for

00:02:09,119 --> 00:02:13,280
many people

00:02:10,080 --> 00:02:15,599
um and uh i'm gonna be

00:02:13,280 --> 00:02:17,680
uh like talking a lot about the spec the

00:02:15,599 --> 00:02:19,200
specification is really good

00:02:17,680 --> 00:02:21,200
um if you haven't read a lot of

00:02:19,200 --> 00:02:22,879
specifications before um i think the

00:02:21,200 --> 00:02:25,040
webassembly standard is a great way to

00:02:22,879 --> 00:02:27,599
get started learning specifications

00:02:25,040 --> 00:02:29,200
maybe i've read too many older or bad

00:02:27,599 --> 00:02:31,040
specifications before

00:02:29,200 --> 00:02:33,040
but i really really like the webassembly

00:02:31,040 --> 00:02:34,640
spec and i think it's fantastic for

00:02:33,040 --> 00:02:36,319
getting started

00:02:34,640 --> 00:02:38,080
if you haven't read specs before you may

00:02:36,319 --> 00:02:39,360
find it like a little bit confusing like

00:02:38,080 --> 00:02:39,840
obviously if you give it a try and you

00:02:39,360 --> 00:02:41,760
struggle

00:02:39,840 --> 00:02:42,879
don't worry about it but it's just it's

00:02:41,760 --> 00:02:44,800
more manageable than other

00:02:42,879 --> 00:02:46,480
specifications from what i found

00:02:44,800 --> 00:02:48,400
especially given the like amount of

00:02:46,480 --> 00:02:50,000
detail that it goes into which is

00:02:48,400 --> 00:02:52,000
helpful when you're trying to learn

00:02:50,000 --> 00:02:54,000
about the details but it can also be a

00:02:52,000 --> 00:02:56,640
little overwhelming for times

00:02:54,000 --> 00:02:58,239
and so you can read all of it on the web

00:02:56,640 --> 00:03:00,000
i'm going to be posting some screenshots

00:02:58,239 --> 00:03:03,120
of it in this presentation

00:03:00,000 --> 00:03:04,879
but if you go to webassembly.github.io

00:03:03,120 --> 00:03:06,080
spec you can actually read the whole

00:03:04,879 --> 00:03:08,159
thing and when i have screenshots

00:03:06,080 --> 00:03:11,519
they're from various parts

00:03:08,159 --> 00:03:13,599
of that specification so

00:03:11,519 --> 00:03:15,280
there's sort of these actually the

00:03:13,599 --> 00:03:16,239
webassembly spec defines these sort of

00:03:15,280 --> 00:03:18,560
two big

00:03:16,239 --> 00:03:19,360
situations um not really the right word

00:03:18,560 --> 00:03:21,280
but whatever

00:03:19,360 --> 00:03:22,480
um it defines webassembly itself but

00:03:21,280 --> 00:03:23,519
also this thing called a host

00:03:22,480 --> 00:03:24,799
environment

00:03:23,519 --> 00:03:26,400
and this is one of the things i really

00:03:24,799 --> 00:03:27,519
love about webassembly is that it's very

00:03:26,400 --> 00:03:30,159
forward thinking

00:03:27,519 --> 00:03:32,799
so um so webassmently spec defines

00:03:30,159 --> 00:03:34,720
webassembly itself and

00:03:32,799 --> 00:03:36,560
that has a number of these sort of like

00:03:34,720 --> 00:03:38,480
tops top level sections

00:03:36,560 --> 00:03:40,239
and they sort of describe what makes up

00:03:38,480 --> 00:03:42,879
webassembly so there's kind of

00:03:40,239 --> 00:03:43,519
the structure of what webassembly is and

00:03:42,879 --> 00:03:45,519
then

00:03:43,519 --> 00:03:47,040
validation which is a really interesting

00:03:45,519 --> 00:03:49,360
thing i'll get to in a second

00:03:47,040 --> 00:03:51,360
how webassembly is executed and then

00:03:49,360 --> 00:03:53,120
finally two different formats one is a

00:03:51,360 --> 00:03:53,840
binary format and one is a textual

00:03:53,120 --> 00:03:56,239
format

00:03:53,840 --> 00:03:57,120
the binary format uses the dot wasm

00:03:56,239 --> 00:04:00,159
extension

00:03:57,120 --> 00:04:02,720
and the text uses the wot extension

00:04:00,159 --> 00:04:04,159
for web assembly text but is also kind

00:04:02,720 --> 00:04:06,000
of just a general joke

00:04:04,159 --> 00:04:07,760
um i think that the the folks that made

00:04:06,000 --> 00:04:09,200
wasm knew that would be kind of funny

00:04:07,760 --> 00:04:09,760
and so they uh they ended up picking

00:04:09,200 --> 00:04:13,280
that

00:04:09,760 --> 00:04:15,040
um so most of the time you would like

00:04:13,280 --> 00:04:17,199
so it's important to understand this

00:04:15,040 --> 00:04:20,400
distinction because there's kind of like

00:04:17,199 --> 00:04:22,560
the structure of a webassembly program

00:04:20,400 --> 00:04:24,080
is sort of like abstract and then the

00:04:22,560 --> 00:04:26,000
binary and text formats

00:04:24,080 --> 00:04:28,000
are the like representation of how that

00:04:26,000 --> 00:04:29,520
format is defined in the computer but

00:04:28,000 --> 00:04:30,800
you could make alternate formats if you

00:04:29,520 --> 00:04:32,720
wanted to and in fact there was a

00:04:30,800 --> 00:04:33,520
competing textual format for a little

00:04:32,720 --> 00:04:36,560
while

00:04:33,520 --> 00:04:39,759
um but it sort of coalesced around this

00:04:36,560 --> 00:04:41,440
dot watt format um so like they did a

00:04:39,759 --> 00:04:42,000
really nice job of splitting out the

00:04:41,440 --> 00:04:44,080
sort of like

00:04:42,000 --> 00:04:46,320
abstract description from the actual

00:04:44,080 --> 00:04:48,800
bits of how you represent that abstract

00:04:46,320 --> 00:04:50,800
description which is really cool

00:04:48,800 --> 00:04:52,479
it also means like this validation

00:04:50,800 --> 00:04:54,560
section is really cool because

00:04:52,479 --> 00:04:55,919
webassembly has several ways that you

00:04:54,560 --> 00:04:57,120
can sort of like validate that it's

00:04:55,919 --> 00:04:59,919
well-formed

00:04:57,120 --> 00:05:01,039
in the first place so as sort of an

00:04:59,919 --> 00:05:03,520
example

00:05:01,039 --> 00:05:05,360
you can verify that the types that are

00:05:03,520 --> 00:05:06,800
in because webassembly is typed i don't

00:05:05,360 --> 00:05:08,800
really talk about that

00:05:06,800 --> 00:05:10,720
exactly but you can validate that all

00:05:08,800 --> 00:05:13,440
the types match up without actually

00:05:10,720 --> 00:05:14,800
executing any of the webassembly itself

00:05:13,440 --> 00:05:16,320
this is really important for

00:05:14,800 --> 00:05:18,080
security properties on the web for

00:05:16,320 --> 00:05:18,960
example it's really important that

00:05:18,080 --> 00:05:20,960
you're able to check

00:05:18,960 --> 00:05:24,080
that certain properties exist ahead of

00:05:20,960 --> 00:05:26,080
time and that's like a really cool

00:05:24,080 --> 00:05:27,520
aspect and so they describe how you

00:05:26,080 --> 00:05:28,880
would go about validating

00:05:27,520 --> 00:05:30,960
a bunch of these properties without

00:05:28,880 --> 00:05:32,720
actually needing to run the code itself

00:05:30,960 --> 00:05:35,120
and then the execution describes a

00:05:32,720 --> 00:05:36,639
little bit about the how the webassembly

00:05:35,120 --> 00:05:37,840
programs are actually executed

00:05:36,639 --> 00:05:39,520
you can do this in a number of different

00:05:37,840 --> 00:05:40,400
ways and we'll get into that in a little

00:05:39,520 --> 00:05:43,440
bit

00:05:40,400 --> 00:05:45,199
so that's like webassembly proper and

00:05:43,440 --> 00:05:47,440
uh then there's also this host

00:05:45,199 --> 00:05:49,199
environment so

00:05:47,440 --> 00:05:50,960
it's it's like webassembly is always

00:05:49,199 --> 00:05:52,400
defined as running in the context of

00:05:50,960 --> 00:05:54,080
some other thing

00:05:52,400 --> 00:05:56,000
which sounds sort of weird until you

00:05:54,080 --> 00:05:57,440
think about regular programs right like

00:05:56,000 --> 00:05:59,680
regular programs

00:05:57,440 --> 00:06:01,520
very rarely run on their own they're

00:05:59,680 --> 00:06:04,960
almost always run in the context of say

00:06:01,520 --> 00:06:05,840
an operating system some programs are

00:06:04,960 --> 00:06:08,000
operating systems

00:06:05,840 --> 00:06:09,440
they run in the context of hardware so

00:06:08,000 --> 00:06:11,680
we're kind of like almost always

00:06:09,440 --> 00:06:13,199
inside of some other thing when we're

00:06:11,680 --> 00:06:14,319
talking about software and webassembly

00:06:13,199 --> 00:06:16,080
makes that explicit

00:06:14,319 --> 00:06:17,360
and separate which is really cool

00:06:16,080 --> 00:06:18,319
because it means that things are more

00:06:17,360 --> 00:06:20,240
flexible

00:06:18,319 --> 00:06:21,440
and so there's kind of this running joke

00:06:20,240 --> 00:06:24,880
that like web assembly

00:06:21,440 --> 00:06:26,960
is neither web nor assembly um and so

00:06:24,880 --> 00:06:28,240
like webassembly is actually broader

00:06:26,960 --> 00:06:29,759
than the web itself

00:06:28,240 --> 00:06:32,080
because the people who wrote the spec

00:06:29,759 --> 00:06:34,319
were able to separate out the web parts

00:06:32,080 --> 00:06:36,240
from the non-web parts um so

00:06:34,319 --> 00:06:38,960
like the spec talks about having an

00:06:36,240 --> 00:06:42,160
embedder that embeds the webassembly

00:06:38,960 --> 00:06:44,479
like runtime inside of itself

00:06:42,160 --> 00:06:45,680
and how those boundaries operate and so

00:06:44,479 --> 00:06:48,080
there's kind of two

00:06:45,680 --> 00:06:49,759
embedders that are in the specification

00:06:48,080 --> 00:06:52,880
itself as well

00:06:49,759 --> 00:06:55,360
this is the javascript and web embedders

00:06:52,880 --> 00:06:56,240
but anyone can sort of like define their

00:06:55,360 --> 00:06:58,800
own

00:06:56,240 --> 00:06:59,919
um other sort of embedding framework and

00:06:58,800 --> 00:07:02,160
we're going to talk about at least one

00:06:59,919 --> 00:07:03,919
more of those later in this presentation

00:07:02,160 --> 00:07:04,960
but um kind of the way you might think

00:07:03,919 --> 00:07:06,160
about like what's the difference between

00:07:04,960 --> 00:07:08,479
javascript and web

00:07:06,160 --> 00:07:10,560
well it's sort of the same way that like

00:07:08,479 --> 00:07:12,400
you have node in the browser

00:07:10,560 --> 00:07:13,680
you know javascript is also broader than

00:07:12,400 --> 00:07:16,560
the web and can run

00:07:13,680 --> 00:07:18,319
outside of a web browser context so they

00:07:16,560 --> 00:07:19,680
very cleanly separated out the stuff

00:07:18,319 --> 00:07:21,759
that's needed for

00:07:19,680 --> 00:07:22,800
a javascript embedding in a pure

00:07:21,759 --> 00:07:24,160
javascript setting

00:07:22,800 --> 00:07:26,319
and then one that would be in the

00:07:24,160 --> 00:07:27,120
context of the web platform and how that

00:07:26,319 --> 00:07:28,639
would happen

00:07:27,120 --> 00:07:30,160
so a lot of people tend to think about

00:07:28,639 --> 00:07:31,840
webassembly as being this thing that's

00:07:30,160 --> 00:07:33,440
built into the web platform

00:07:31,840 --> 00:07:35,199
but it's it's significantly broader and

00:07:33,440 --> 00:07:36,720
kind of always has been um

00:07:35,199 --> 00:07:38,720
you know javascript was built inside the

00:07:36,720 --> 00:07:40,319
web platform and kind of pulled out

00:07:38,720 --> 00:07:42,160
the foresight was there to actually make

00:07:40,319 --> 00:07:43,440
it separate in the first place

00:07:42,160 --> 00:07:44,639
and this distinction is going to become

00:07:43,440 --> 00:07:45,599
very important when we talk about

00:07:44,639 --> 00:07:48,080
debugging

00:07:45,599 --> 00:07:50,080
because how debugging works is different

00:07:48,080 --> 00:07:51,680
based on what host environment you have

00:07:50,080 --> 00:07:53,120
um so that's part of this challenge

00:07:51,680 --> 00:07:54,240
which is why i bring this up

00:07:53,120 --> 00:07:55,680
this is one of my favorite aspects of

00:07:54,240 --> 00:07:57,039
webassembly but it's not just because i

00:07:55,680 --> 00:07:58,240
love it it's because it's actually like

00:07:57,039 --> 00:07:59,120
relevant to the stuff we're going to be

00:07:58,240 --> 00:08:02,400
talking about

00:07:59,120 --> 00:08:03,840
uh here pretty soon so i sort of gave a

00:08:02,400 --> 00:08:05,199
small overview of these already but i'm

00:08:03,840 --> 00:08:07,280
going to talk about each of these four

00:08:05,199 --> 00:08:08,400
sections just briefly um so it's

00:08:07,280 --> 00:08:10,000
structure like

00:08:08,400 --> 00:08:12,000
webassembly is its own programming

00:08:10,000 --> 00:08:14,160
language in a sense

00:08:12,000 --> 00:08:15,599
but it has different actual concrete

00:08:14,160 --> 00:08:16,560
representations like i said the binary

00:08:15,599 --> 00:08:18,400
and text format

00:08:16,560 --> 00:08:19,759
and so they have a common structure so

00:08:18,400 --> 00:08:21,680
that's what this like part of the

00:08:19,759 --> 00:08:24,800
specification

00:08:21,680 --> 00:08:27,039
talks about is this abstract structure

00:08:24,800 --> 00:08:28,400
so i mentioned before the validation is

00:08:27,039 --> 00:08:29,919
important because you can check that

00:08:28,400 --> 00:08:32,800
certain things make sense

00:08:29,919 --> 00:08:35,120
um and so like there's like this type

00:08:32,800 --> 00:08:37,200
system that's involved and it specifies

00:08:35,120 --> 00:08:38,959
all of the things that happen inside

00:08:37,200 --> 00:08:40,320
um and so one of the things i think is

00:08:38,959 --> 00:08:41,599
really cool though and

00:08:40,320 --> 00:08:43,519
the cool thing about the webassembly

00:08:41,599 --> 00:08:45,760
spec is that

00:08:43,519 --> 00:08:47,040
it says here all rules are given in two

00:08:45,760 --> 00:08:48,880
equivalent forms

00:08:47,040 --> 00:08:50,959
in prose describing the meaning in an

00:08:48,880 --> 00:08:52,959
intuitive form and a formal notation

00:08:50,959 --> 00:08:54,880
describing it in mathematical form

00:08:52,959 --> 00:08:56,880
so a lot of specifications choose one or

00:08:54,880 --> 00:08:57,519
the other webassembly decided to choose

00:08:56,880 --> 00:08:59,120
both

00:08:57,519 --> 00:09:00,560
if you're a mathy kind of person you

00:08:59,120 --> 00:09:01,440
want to do the like formal version

00:09:00,560 --> 00:09:03,519
that's like great

00:09:01,440 --> 00:09:05,440
it's much more concise but if you're not

00:09:03,519 --> 00:09:07,200
really a mathy person like i'm not

00:09:05,440 --> 00:09:09,440
really that mathy of a person to be

00:09:07,200 --> 00:09:10,959
honest with you i tend to read the prose

00:09:09,440 --> 00:09:11,760
version of this which sort of describes

00:09:10,959 --> 00:09:13,760
it in words

00:09:11,760 --> 00:09:15,279
and they consider both of them canonical

00:09:13,760 --> 00:09:16,560
so if there's a bug

00:09:15,279 --> 00:09:18,240
if there's something that diverges

00:09:16,560 --> 00:09:19,440
between these two explanations they

00:09:18,240 --> 00:09:20,800
consider that a bug

00:09:19,440 --> 00:09:22,959
this is i think really helpful for

00:09:20,800 --> 00:09:24,880
making the spec accessible to folks

00:09:22,959 --> 00:09:26,800
it's just like really nice it's cool to

00:09:24,880 --> 00:09:27,760
see them put in the work to do both

00:09:26,800 --> 00:09:31,200
versions

00:09:27,760 --> 00:09:32,800
um so executing so what happens is

00:09:31,200 --> 00:09:35,200
um webassembly has this thing called

00:09:32,800 --> 00:09:36,000
modules so the unit in webassembly as a

00:09:35,200 --> 00:09:38,000
module

00:09:36,000 --> 00:09:39,839
and so webassembly code gets executed

00:09:38,000 --> 00:09:42,880
when you instantiate a module

00:09:39,839 --> 00:09:44,320
and then you call a function and so that

00:09:42,880 --> 00:09:46,000
is like kind of what kicks off the

00:09:44,320 --> 00:09:47,519
process of running things

00:09:46,000 --> 00:09:48,800
in languages that have like a main

00:09:47,519 --> 00:09:50,240
function you could imagine that being

00:09:48,800 --> 00:09:51,839
something like maine

00:09:50,240 --> 00:09:53,519
in languages that don't you can imagine

00:09:51,839 --> 00:09:55,519
that as being when you load up a file

00:09:53,519 --> 00:09:57,440
into your interpreter or whatever

00:09:55,519 --> 00:09:59,440
and so this describes like how the thing

00:09:57,440 --> 00:10:01,279
gets executed and importantly this is

00:09:59,440 --> 00:10:03,200
also described in relatively abstract

00:10:01,279 --> 00:10:05,839
terms

00:10:03,200 --> 00:10:07,600
and so uh this allows you to have

00:10:05,839 --> 00:10:08,560
multiple different implementations so

00:10:07,600 --> 00:10:10,480
for example

00:10:08,560 --> 00:10:12,399
browsers tend to implement webassembly

00:10:10,480 --> 00:10:14,240
in terms of the javascript to runtime

00:10:12,399 --> 00:10:15,040
they reuse parts of their javascript

00:10:14,240 --> 00:10:17,040
virtual machine

00:10:15,040 --> 00:10:18,560
to to implement webassembly but folks

00:10:17,040 --> 00:10:21,680
have actually built their own

00:10:18,560 --> 00:10:23,279
webassembly runtimes that exist totally

00:10:21,680 --> 00:10:24,880
separate from everything else and that's

00:10:23,279 --> 00:10:27,040
enabled by building out this like

00:10:24,880 --> 00:10:28,480
execution specification

00:10:27,040 --> 00:10:30,480
and so that's like another really cool

00:10:28,480 --> 00:10:32,880
area of flexibility

00:10:30,480 --> 00:10:34,560
if you happen to know what this means uh

00:10:32,880 --> 00:10:37,600
this is a positive thing but

00:10:34,560 --> 00:10:39,200
uh web assembly is a stack machine um

00:10:37,600 --> 00:10:40,240
so if you don't know what that means

00:10:39,200 --> 00:10:41,519
don't worry about it it's not that

00:10:40,240 --> 00:10:42,480
really that important

00:10:41,519 --> 00:10:45,360
we're not going to talk about that

00:10:42,480 --> 00:10:46,000
aspect of wasm but there are other talks

00:10:45,360 --> 00:10:47,600
you can get into

00:10:46,000 --> 00:10:49,040
that sort of talk about what that means

00:10:47,600 --> 00:10:49,839
basically in virtual machines there's

00:10:49,040 --> 00:10:51,440
two major

00:10:49,839 --> 00:10:53,360
kind of like architectures one is a

00:10:51,440 --> 00:10:54,480
stack architecture and one's a register

00:10:53,360 --> 00:10:56,959
architecture

00:10:54,480 --> 00:10:58,399
and uh wasm is a stack machine not a

00:10:56,959 --> 00:10:59,519
registered machine

00:10:58,399 --> 00:11:00,959
i don't have enough time to talk about

00:10:59,519 --> 00:11:02,640
the details there but that's just like

00:11:00,959 --> 00:11:04,880
kind of an interesting side effect

00:11:02,640 --> 00:11:06,480
um same thing here prose and formal

00:11:04,880 --> 00:11:09,839
definition which is really cool

00:11:06,480 --> 00:11:11,920
um finally the binary and text format um

00:11:09,839 --> 00:11:12,880
so the binary format uh basically is

00:11:11,920 --> 00:11:16,399
just like put

00:11:12,880 --> 00:11:19,519
the syntax into binary and then the uh

00:11:16,399 --> 00:11:21,519
watt format uh is the text format and it

00:11:19,519 --> 00:11:24,640
turns things into s expressions

00:11:21,519 --> 00:11:25,760
so if you loved lisp then lisp lives on

00:11:24,640 --> 00:11:26,959
inside of webassembly

00:11:25,760 --> 00:11:28,880
there's sort of an interesting history

00:11:26,959 --> 00:11:30,399
here where javascript was like

00:11:28,880 --> 00:11:31,680
some people wanted it to be a lisp in

00:11:30,399 --> 00:11:33,279
the first place and a lot of the folks

00:11:31,680 --> 00:11:34,160
who wrote early javascript are very big

00:11:33,279 --> 00:11:35,680
list people

00:11:34,160 --> 00:11:38,000
this is kind of like a joke the lisp's

00:11:35,680 --> 00:11:38,640
revenge is that uh webassembly is like

00:11:38,000 --> 00:11:41,360
has this

00:11:38,640 --> 00:11:43,360
s expression style syntax but um we're

00:11:41,360 --> 00:11:45,200
going to look at both of these formats

00:11:43,360 --> 00:11:46,399
in the rest of the presentation but an

00:11:45,200 --> 00:11:47,200
interesting property of it when it comes

00:11:46,399 --> 00:11:49,120
to debugging

00:11:47,200 --> 00:11:50,800
is that these formats are equivalent so

00:11:49,120 --> 00:11:51,680
you can take the text format and turn it

00:11:50,800 --> 00:11:53,120
into binary

00:11:51,680 --> 00:11:55,600
and you can take the binary format and

00:11:53,120 --> 00:11:57,279
turn it into text and so

00:11:55,600 --> 00:11:59,360
the advantage of the binary format is

00:11:57,279 --> 00:12:00,720
that it is smaller and more compact

00:11:59,360 --> 00:12:02,560
and if you think about you know when

00:12:00,720 --> 00:12:03,760
you're downloading an asset over the

00:12:02,560 --> 00:12:04,959
internet you want it to be as small and

00:12:03,760 --> 00:12:06,959
compact as possible

00:12:04,959 --> 00:12:08,320
so that is tends to be how things are

00:12:06,959 --> 00:12:10,240
used in that sense

00:12:08,320 --> 00:12:12,000
but if you want to read it you know many

00:12:10,240 --> 00:12:13,519
people don't read binary

00:12:12,000 --> 00:12:15,040
um although there are some embedded

00:12:13,519 --> 00:12:16,720
folks who uh you know

00:12:15,040 --> 00:12:18,240
work with it every day and so develop a

00:12:16,720 --> 00:12:18,800
certain amount of ability to kind of

00:12:18,240 --> 00:12:21,920
like

00:12:18,800 --> 00:12:22,959
see the code as you will um but uh most

00:12:21,920 --> 00:12:24,399
people would want to look at stuff in

00:12:22,959 --> 00:12:26,560
the text format and so

00:12:24,399 --> 00:12:28,480
being able to make this happen is

00:12:26,560 --> 00:12:30,480
something that like is important

00:12:28,480 --> 00:12:31,519
and was like a really key part of making

00:12:30,480 --> 00:12:33,839
sure that

00:12:31,519 --> 00:12:35,600
you know the web like you can read the

00:12:33,839 --> 00:12:38,480
javascript code that is running in your

00:12:35,600 --> 00:12:40,880
browser at least in theory um and so it

00:12:38,480 --> 00:12:44,240
was important there be a text format too

00:12:40,880 --> 00:12:47,279
to keep that kind of property

00:12:44,240 --> 00:12:48,880
okay so host environments i talked a

00:12:47,279 --> 00:12:51,200
little bit about the browser earlier and

00:12:48,880 --> 00:12:53,519
you can run webassembly in your browser

00:12:51,200 --> 00:12:55,600
this is following all the w3 c3

00:12:53,519 --> 00:12:58,320
specifications around the browser

00:12:55,600 --> 00:12:59,839
host environment and there's more work

00:12:58,320 --> 00:13:00,560
to be done here that's actually very

00:12:59,839 --> 00:13:01,839
interesting

00:13:00,560 --> 00:13:03,839
the one that everyone loves to talk

00:13:01,839 --> 00:13:06,240
about is dom access

00:13:03,839 --> 00:13:07,920
and so like right now web assembly can't

00:13:06,240 --> 00:13:09,680
directly access the dom

00:13:07,920 --> 00:13:11,279
it can call into javascript code though

00:13:09,680 --> 00:13:12,160
and javascript can touch the dom so you

00:13:11,279 --> 00:13:13,680
kind of get this

00:13:12,160 --> 00:13:15,360
chain process where if you want

00:13:13,680 --> 00:13:16,800
webassembly to do dom manipulation it

00:13:15,360 --> 00:13:17,760
calls into javascript and javascript

00:13:16,800 --> 00:13:19,440
does the work

00:13:17,760 --> 00:13:21,200
there's a proposal that would let

00:13:19,440 --> 00:13:22,639
webassembly sort of not just

00:13:21,200 --> 00:13:24,399
interact with the dom directly but

00:13:22,639 --> 00:13:26,000
interact with sort of any kind of like

00:13:24,399 --> 00:13:27,440
external resource that the host might

00:13:26,000 --> 00:13:28,639
want to expose

00:13:27,440 --> 00:13:30,880
and it's called the host bindings

00:13:28,639 --> 00:13:31,680
proposal and so that will be a thing

00:13:30,880 --> 00:13:33,920
that

00:13:31,680 --> 00:13:35,360
happens that allows this to work but

00:13:33,920 --> 00:13:36,639
there's a bunch of other stuff you can

00:13:35,360 --> 00:13:38,079
imagine that would be useful

00:13:36,639 --> 00:13:39,839
inside of webassembly that does not

00:13:38,079 --> 00:13:41,519
exist today so there's more work

00:13:39,839 --> 00:13:42,720
happening in that um in that browser

00:13:41,519 --> 00:13:44,720
environment

00:13:42,720 --> 00:13:46,240
there's also what's i'm calling sort of

00:13:44,720 --> 00:13:48,399
like the system environment

00:13:46,240 --> 00:13:49,680
so i mentioned before that like uh you

00:13:48,399 --> 00:13:50,240
know you can run wasm outside of a

00:13:49,680 --> 00:13:52,560
browser

00:13:50,240 --> 00:13:53,680
and you need to define you know ways of

00:13:52,560 --> 00:13:55,680
making that happen

00:13:53,680 --> 00:13:57,519
um mozilla and other folks have come up

00:13:55,680 --> 00:13:59,680
with a specification called wazi which

00:13:57,519 --> 00:14:02,079
stands for webassembly systems interface

00:13:59,680 --> 00:14:04,320
and it kind of defines the ability for

00:14:02,079 --> 00:14:06,320
webassembly to talk to file systems

00:14:04,320 --> 00:14:07,440
the network on its own without dealing

00:14:06,320 --> 00:14:10,639
with the browser

00:14:07,440 --> 00:14:11,920
graphics audio input encryption like all

00:14:10,639 --> 00:14:12,959
this other kind of stuff that you might

00:14:11,920 --> 00:14:15,680
expect from

00:14:12,959 --> 00:14:16,000
a application that's running natively as

00:14:15,680 --> 00:14:18,240
opposed

00:14:16,000 --> 00:14:20,560
to in the browser um and so this has

00:14:18,240 --> 00:14:20,959
been kind of like a um there's several

00:14:20,560 --> 00:14:22,720
other

00:14:20,959 --> 00:14:24,240
people that are involved in this spec

00:14:22,720 --> 00:14:25,600
and it's kind of gaining steam as sort

00:14:24,240 --> 00:14:27,839
of the de facto

00:14:25,600 --> 00:14:29,680
way to run webassembly programs outside

00:14:27,839 --> 00:14:31,040
of the browser

00:14:29,680 --> 00:14:33,839
and so this is kind of really really

00:14:31,040 --> 00:14:35,680
cool and so we get the ability to like

00:14:33,839 --> 00:14:37,360
run webassembly programs um

00:14:35,680 --> 00:14:38,959
outside of the browser as well and

00:14:37,360 --> 00:14:39,360
there's tons of reasons why that might

00:14:38,959 --> 00:14:41,760
be

00:14:39,360 --> 00:14:43,120
valuable valuable to folks i don't have

00:14:41,760 --> 00:14:44,880
time to get into them

00:14:43,120 --> 00:14:46,480
entirely in this talk so i'm just going

00:14:44,880 --> 00:14:47,440
to kind of say that's useful and sort of

00:14:46,480 --> 00:14:50,639
leave it at that

00:14:47,440 --> 00:14:52,079
um as part of this uh there

00:14:50,639 --> 00:14:54,000
all of these things i just covered could

00:14:52,079 --> 00:14:55,760
be its own talk on its own if i moved a

00:14:54,000 --> 00:14:57,519
little quickly and you got a little lost

00:14:55,760 --> 00:14:59,360
don't worry because there's just so so

00:14:57,519 --> 00:15:01,279
so many things going on here and there's

00:14:59,360 --> 00:15:03,600
a rich amount of information to learn

00:15:01,279 --> 00:15:05,199
and so i could give a 45 minute talk

00:15:03,600 --> 00:15:07,279
about almost every single one of these

00:15:05,199 --> 00:15:09,760
probably multiple talks about many parts

00:15:07,279 --> 00:15:11,360
of all the stuff that i just described

00:15:09,760 --> 00:15:13,519
we're going to focus on one particular

00:15:11,360 --> 00:15:14,160
aspect though which is the binary format

00:15:13,519 --> 00:15:16,079
itself

00:15:14,160 --> 00:15:17,519
and how that impacts debugging because

00:15:16,079 --> 00:15:18,959
as i mentioned like if you're doing

00:15:17,519 --> 00:15:20,480
webassembly stuff in a browser you're

00:15:18,959 --> 00:15:22,000
probably downloading the binary format

00:15:20,480 --> 00:15:23,279
and executing it because you want that

00:15:22,000 --> 00:15:25,839
small

00:15:23,279 --> 00:15:26,800
size that a binary format affords you

00:15:25,839 --> 00:15:28,399
and you're probably going to want to be

00:15:26,800 --> 00:15:30,399
able to like debug your application

00:15:28,399 --> 00:15:31,680
so you sort of need to confront this and

00:15:30,399 --> 00:15:32,959
i think this is an area where

00:15:31,680 --> 00:15:35,360
it's a lot of interesting and active

00:15:32,959 --> 00:15:37,360
development um and so

00:15:35,360 --> 00:15:38,480
this also i think really matters because

00:15:37,360 --> 00:15:41,199
as i sort of mentioned

00:15:38,480 --> 00:15:42,560
briefly before a lot of people as i made

00:15:41,199 --> 00:15:43,759
up this kind of quote on the right hand

00:15:42,560 --> 00:15:45,680
side here

00:15:43,759 --> 00:15:47,360
a lot of people think that like they're

00:15:45,680 --> 00:15:48,959
fearful about webassembly because they

00:15:47,360 --> 00:15:50,560
know that javascript

00:15:48,959 --> 00:15:51,759
you're able to read the code that comes

00:15:50,560 --> 00:15:53,600
into your browser and that's like an

00:15:51,759 --> 00:15:55,519
important property of them

00:15:53,600 --> 00:15:57,120
and so that's also sort of basically a

00:15:55,519 --> 00:15:58,800
version of debugging like i want to know

00:15:57,120 --> 00:15:59,920
what my browser is executing i'll be

00:15:58,800 --> 00:16:01,920
able to read it that's like

00:15:59,920 --> 00:16:03,440
fundamentally a debugging process and so

00:16:01,920 --> 00:16:04,800
i think that

00:16:03,440 --> 00:16:07,360
talking about debugging is really

00:16:04,800 --> 00:16:08,959
important for getting the folks that are

00:16:07,360 --> 00:16:10,240
a little worried about this on board

00:16:08,959 --> 00:16:11,279
with webassembly is kind of like a

00:16:10,240 --> 00:16:14,639
general thing

00:16:11,279 --> 00:16:17,040
um okay so uh

00:16:14,639 --> 00:16:18,560
dot wasm files the binary format how do

00:16:17,040 --> 00:16:20,240
you get a dot wasm file

00:16:18,560 --> 00:16:21,680
well fundamentally what happens is you

00:16:20,240 --> 00:16:24,000
compile a program

00:16:21,680 --> 00:16:25,759
into a wasm file and i say compile

00:16:24,000 --> 00:16:26,480
because you need to sort of ahead of

00:16:25,759 --> 00:16:28,160
time

00:16:26,480 --> 00:16:30,000
generate the whole thing if you have a

00:16:28,160 --> 00:16:31,600
language that's not compiled ahead of

00:16:30,000 --> 00:16:33,120
time or i should say an implementation

00:16:31,600 --> 00:16:34,720
because languages can be both but like

00:16:33,120 --> 00:16:36,240
whatever you get it

00:16:34,720 --> 00:16:37,839
if you have sort of an interpreter with

00:16:36,240 --> 00:16:39,360
your language you also need to compile

00:16:37,839 --> 00:16:41,279
that interpreter as well

00:16:39,360 --> 00:16:42,880
and so you kind of get larger binaries

00:16:41,279 --> 00:16:43,680
with languages that need to have an

00:16:42,880 --> 00:16:45,279
interpreter

00:16:43,680 --> 00:16:47,839
and that's a whole other section about

00:16:45,279 --> 00:16:49,279
webassembly that's not part of this talk

00:16:47,839 --> 00:16:51,040
but just like you get everything your

00:16:49,279 --> 00:16:52,560
program needs so you get a ruby program

00:16:51,040 --> 00:16:54,320
you want to compile to webassembly you

00:16:52,560 --> 00:16:55,360
compile not just your ruby but also the

00:16:54,320 --> 00:16:58,560
ruby interpreter

00:16:55,360 --> 00:17:01,199
it produces a big giant.wasm file um

00:16:58,560 --> 00:17:02,880
and then an implementation will actually

00:17:01,199 --> 00:17:04,079
execute that according to execution

00:17:02,880 --> 00:17:06,640
section and the spec so

00:17:04,079 --> 00:17:08,319
you hand that wasm file to some sort of

00:17:06,640 --> 00:17:10,559
implementation and it runs it

00:17:08,319 --> 00:17:12,079
um and so this makes debugging really

00:17:10,559 --> 00:17:13,600
interesting because

00:17:12,079 --> 00:17:15,120
you know if you compile your program

00:17:13,600 --> 00:17:17,280
into wasm

00:17:15,120 --> 00:17:18,400
you don't have the source code anymore

00:17:17,280 --> 00:17:19,919
and so this is like

00:17:18,400 --> 00:17:21,919
step number one that's the big problem

00:17:19,919 --> 00:17:23,760
is you sort of lose in translation

00:17:21,919 --> 00:17:25,360
um you know if you think about a a

00:17:23,760 --> 00:17:26,319
dynamically typed scripting language

00:17:25,360 --> 00:17:28,640
like say

00:17:26,319 --> 00:17:29,760
javascript or ruby or python or perl or

00:17:28,640 --> 00:17:31,520
any of those other languages

00:17:29,760 --> 00:17:33,679
you sort of like execute the source code

00:17:31,520 --> 00:17:35,360
to some degree obviously there's jits

00:17:33,679 --> 00:17:36,559
and compilers and all this other stuff

00:17:35,360 --> 00:17:37,919
but like you step through the source

00:17:36,559 --> 00:17:38,880
code and you see the source code kind of

00:17:37,919 --> 00:17:41,120
like running

00:17:38,880 --> 00:17:42,559
when you're debugging stuff but if you

00:17:41,120 --> 00:17:44,400
compile this into webassembly

00:17:42,559 --> 00:17:46,559
all that information is gone so like

00:17:44,400 --> 00:17:48,799
what do we do about that um

00:17:46,559 --> 00:17:51,039
i'm going to be using this tool called

00:17:48,799 --> 00:17:52,480
wasm code explorer i put the link down

00:17:51,039 --> 00:17:53,600
here at the bottom

00:17:52,480 --> 00:17:55,520
this is a really useful way of

00:17:53,600 --> 00:17:57,440
visualizing the binary format

00:17:55,520 --> 00:17:58,559
and i put it here because i didn't have

00:17:57,440 --> 00:18:00,000
room on all the slides that i'm going to

00:17:58,559 --> 00:18:00,320
use it for later so i just wanted to

00:18:00,000 --> 00:18:02,080
like

00:18:00,320 --> 00:18:03,520
mention briefly that that's a really

00:18:02,080 --> 00:18:06,720
great tool that i use all the time to

00:18:03,520 --> 00:18:08,160
like look at webassembly binary output

00:18:06,720 --> 00:18:10,240
so let's take a look at an actual

00:18:08,160 --> 00:18:12,000
example of this happening so here's

00:18:10,240 --> 00:18:13,440
a rust program you don't really need to

00:18:12,000 --> 00:18:14,000
know rust for this presentation this is

00:18:13,440 --> 00:18:15,919
the only rest

00:18:14,000 --> 00:18:17,440
code in the slide but i had to pick a

00:18:15,919 --> 00:18:19,039
language and rust has put a lot of work

00:18:17,440 --> 00:18:21,919
into making web assembly great

00:18:19,039 --> 00:18:22,640
so um here on line one we use this wasm

00:18:21,919 --> 00:18:24,559
bind gen

00:18:22,640 --> 00:18:26,320
which is a thing that generates bindings

00:18:24,559 --> 00:18:28,000
to webassembly

00:18:26,320 --> 00:18:29,760
and then on line four we make a function

00:18:28,000 --> 00:18:30,320
called add one that takes a 32-bit

00:18:29,760 --> 00:18:32,400
number

00:18:30,320 --> 00:18:34,559
and returns a 32-bit number and we add

00:18:32,400 --> 00:18:37,120
one to it it's pretty straightforward

00:18:34,559 --> 00:18:38,400
um and that line three that annotation

00:18:37,120 --> 00:18:39,360
says hey we want to expose this to

00:18:38,400 --> 00:18:40,640
webassembly

00:18:39,360 --> 00:18:42,960
so this is an example like you could

00:18:40,640 --> 00:18:43,520
write this program in vs code or

00:18:42,960 --> 00:18:46,320
whatever

00:18:43,520 --> 00:18:46,640
i'm using code here and then you compile

00:18:46,320 --> 00:18:49,440
it

00:18:46,640 --> 00:18:50,640
um via tool uh depending on you know

00:18:49,440 --> 00:18:52,799
what language you're using

00:18:50,640 --> 00:18:54,320
um in this case i use wasm pack which is

00:18:52,799 --> 00:18:56,080
a great tool written to

00:18:54,320 --> 00:18:57,919
help do rust and webassembly stuff and

00:18:56,080 --> 00:19:00,559
then you get a wasm file out

00:18:57,919 --> 00:19:01,039
um what does that wasm file look like

00:19:00,559 --> 00:19:03,840
well

00:19:01,039 --> 00:19:05,360
here is that uh wasm explorer tool i was

00:19:03,840 --> 00:19:07,760
showing you before

00:19:05,360 --> 00:19:08,799
it shows you all of this binary kind of

00:19:07,760 --> 00:19:10,880
like on the left

00:19:08,799 --> 00:19:11,840
and then what it renders like into ascii

00:19:10,880 --> 00:19:12,640
on the right which is kind of

00:19:11,840 --> 00:19:14,799
interesting

00:19:12,640 --> 00:19:16,000
but it also color codes all of the

00:19:14,799 --> 00:19:17,679
individual

00:19:16,000 --> 00:19:19,679
sections or in talk about sections in a

00:19:17,679 --> 00:19:21,200
second and then like highlights them as

00:19:19,679 --> 00:19:22,080
you move your mouse over so you see that

00:19:21,200 --> 00:19:23,600
one that's like that

00:19:22,080 --> 00:19:24,960
light blue color because i was

00:19:23,600 --> 00:19:25,760
highlighting my mouse over when i took

00:19:24,960 --> 00:19:27,600
the screenshot

00:19:25,760 --> 00:19:29,360
but you kind of get this um all this

00:19:27,600 --> 00:19:32,640
binary code and so this

00:19:29,360 --> 00:19:34,080
is the what the rust compiler put out i

00:19:32,640 --> 00:19:35,919
actually come about it this morning

00:19:34,080 --> 00:19:36,960
um this is the like the outcome that

00:19:35,919 --> 00:19:38,720
comes out of the compiler when you

00:19:36,960 --> 00:19:39,520
compile that previous program you get

00:19:38,720 --> 00:19:42,720
this

00:19:39,520 --> 00:19:43,919
um and so uh

00:19:42,720 --> 00:19:45,440
this is like what we're going to talk

00:19:43,919 --> 00:19:46,240
about is how does this format actually

00:19:45,440 --> 00:19:49,520
like work

00:19:46,240 --> 00:19:51,200
um this is the equivalent.what to that

00:19:49,520 --> 00:19:53,280
wasm so it gives you kind of this

00:19:51,200 --> 00:19:54,559
better text representation you can see

00:19:53,280 --> 00:19:55,360
all the parentheses because the s

00:19:54,559 --> 00:19:57,520
expression

00:19:55,360 --> 00:19:59,039
and they're kind of all these little

00:19:57,520 --> 00:20:00,559
sections in between so we're going to go

00:19:59,039 --> 00:20:02,559
back and forth and talk about

00:20:00,559 --> 00:20:04,320
both of these things i don't have time

00:20:02,559 --> 00:20:05,600
to explain all of the details from this

00:20:04,320 --> 00:20:06,000
example because i want to talk about

00:20:05,600 --> 00:20:08,320
debugging

00:20:06,000 --> 00:20:11,120
stuff but um this is kind of like the

00:20:08,320 --> 00:20:13,200
sort of hello world if you will of wasm

00:20:11,120 --> 00:20:14,799
formats so you see that first line says

00:20:13,200 --> 00:20:16,400
module and then everything else goes

00:20:14,799 --> 00:20:19,280
inside of it as i mentioned

00:20:16,400 --> 00:20:21,200
a webassembly like a dot wasm file

00:20:19,280 --> 00:20:22,559
defines some sort of wasm module

00:20:21,200 --> 00:20:24,400
and inside the module are all these

00:20:22,559 --> 00:20:25,200
other things called sections so we have

00:20:24,400 --> 00:20:28,640
type memory

00:20:25,200 --> 00:20:29,039
export export func and data and those

00:20:28,640 --> 00:20:30,559
are

00:20:29,039 --> 00:20:32,080
sections you can also have custom

00:20:30,559 --> 00:20:33,200
sections and there's other types of

00:20:32,080 --> 00:20:35,440
sections that are in here

00:20:33,200 --> 00:20:37,039
but the rough structure is like the file

00:20:35,440 --> 00:20:39,200
defines a module and then inside the

00:20:37,039 --> 00:20:40,799
module is defines all these sections

00:20:39,200 --> 00:20:42,880
and the sections all define different

00:20:40,799 --> 00:20:45,760
stuff so as you can imagine that func

00:20:42,880 --> 00:20:46,240
section defines that function that we

00:20:45,760 --> 00:20:48,720
are

00:20:46,240 --> 00:20:49,520
uh you know calling to add one and then

00:20:48,720 --> 00:20:50,960
the export

00:20:49,520 --> 00:20:53,039
you can see right above it there's a

00:20:50,960 --> 00:20:53,600
export add one that exports that

00:20:53,039 --> 00:20:55,679
function

00:20:53,600 --> 00:20:57,360
so it's like saying hey i'm i want

00:20:55,679 --> 00:20:58,880
somebody outside of this module to be

00:20:57,360 --> 00:21:01,200
able to call this function

00:20:58,880 --> 00:21:02,240
um like i said there's a lot going on

00:21:01,200 --> 00:21:03,039
here we're not going to get all the

00:21:02,240 --> 00:21:06,320
details

00:21:03,039 --> 00:21:08,159
um but uh yeah so that's kind of like

00:21:06,320 --> 00:21:09,600
this is what's inside your computer and

00:21:08,159 --> 00:21:10,799
then this is what you can like produce

00:21:09,600 --> 00:21:12,080
from it to like make something that's a

00:21:10,799 --> 00:21:15,039
little more readable

00:21:12,080 --> 00:21:16,320
um so here's an example from the spec

00:21:15,039 --> 00:21:19,360
describing modules

00:21:16,320 --> 00:21:20,480
so uh it says like hey there is a an

00:21:19,360 --> 00:21:22,080
encoding of a module

00:21:20,480 --> 00:21:23,520
starts with a preamble that contains a

00:21:22,080 --> 00:21:26,559
four byte magic number

00:21:23,520 --> 00:21:28,400
which is a string backslash zero asm

00:21:26,559 --> 00:21:30,080
and then a version field the current

00:21:28,400 --> 00:21:32,720
version is one uh

00:21:30,080 --> 00:21:33,120
it's then followed by sections um and

00:21:32,720 --> 00:21:34,320
like

00:21:33,120 --> 00:21:36,640
you know you can do whatever you want

00:21:34,320 --> 00:21:37,039
and so it says magic here zero x zero

00:21:36,640 --> 00:21:39,679
zero

00:21:37,039 --> 00:21:40,480
zero x six one zero x seven three zero x

00:21:39,679 --> 00:21:42,159
sixty

00:21:40,480 --> 00:21:43,679
um and then version is one and then a

00:21:42,159 --> 00:21:44,000
bunch of zeros and then the module

00:21:43,679 --> 00:21:46,400
section

00:21:44,000 --> 00:21:47,679
afterwards so if you were looking at the

00:21:46,400 --> 00:21:49,600
spec and you're like okay

00:21:47,679 --> 00:21:51,760
how do i map this to the binary code

00:21:49,600 --> 00:21:54,640
that's actually in the dot wasm file

00:21:51,760 --> 00:21:55,280
well maybe it's a little small um if you

00:21:54,640 --> 00:21:56,960
double click

00:21:55,280 --> 00:21:58,720
on this on the slides you get a little

00:21:56,960 --> 00:22:00,080
bigger but you can see that that exact

00:21:58,720 --> 00:22:03,919
same stuff the zero zero

00:22:00,080 --> 00:22:05,360
six one seven three six d that dot asm

00:22:03,919 --> 00:22:08,320
that's the first four

00:22:05,360 --> 00:22:10,240
bytes of the file and then that version

00:22:08,320 --> 00:22:11,440
is the next byte so zero one zero zero

00:22:10,240 --> 00:22:13,600
zero zero zero zero

00:22:11,440 --> 00:22:15,440
so we can see how that spec corresponds

00:22:13,600 --> 00:22:17,840
directly to this binary output

00:22:15,440 --> 00:22:19,440
and um you know in lots of languages you

00:22:17,840 --> 00:22:20,640
don't necessarily deal with binary files

00:22:19,440 --> 00:22:22,080
a whole ton

00:22:20,640 --> 00:22:23,600
and i wanted to whip up an example here

00:22:22,080 --> 00:22:24,960
but i felt it was getting a little long

00:22:23,600 --> 00:22:26,000
but the point is you can just open up

00:22:24,960 --> 00:22:28,159
the file and read it

00:22:26,000 --> 00:22:29,679
byte by byte in whatever programming

00:22:28,159 --> 00:22:30,000
language you want and if you wanted to

00:22:29,679 --> 00:22:33,039
see

00:22:30,000 --> 00:22:34,320
like is a program a webassembly file you

00:22:33,039 --> 00:22:36,480
would need to look at the first four

00:22:34,320 --> 00:22:38,640
bytes and see do they match up with this

00:22:36,480 --> 00:22:40,000
magic number um and that would let you

00:22:38,640 --> 00:22:40,880
know that it's a webassembly file and

00:22:40,000 --> 00:22:41,600
then you can see what version of

00:22:40,880 --> 00:22:43,039
webassembly

00:22:41,600 --> 00:22:44,960
it's encoded with by looking at the next

00:22:43,039 --> 00:22:46,320
four bytes and so kind of the process of

00:22:44,960 --> 00:22:47,280
stepping through and working with a

00:22:46,320 --> 00:22:48,799
binary file

00:22:47,280 --> 00:22:50,799
is literally just matching up the words

00:22:48,799 --> 00:22:52,159
in the spec to the structure here you

00:22:50,799 --> 00:22:53,600
can think of it just like json right

00:22:52,159 --> 00:22:55,679
like you parse some json

00:22:53,600 --> 00:22:56,960
you pull out the very first thing you

00:22:55,679 --> 00:22:58,400
you know compare how it like

00:22:56,960 --> 00:23:00,320
looks to whatever you're expecting and

00:22:58,400 --> 00:23:02,000
you go through it exact same process

00:23:00,320 --> 00:23:03,840
just like a little more compact

00:23:02,000 --> 00:23:06,159
and maybe in a way that's like slightly

00:23:03,840 --> 00:23:09,440
more awkward from higher level languages

00:23:06,159 --> 00:23:12,080
um but uh but yeah so then

00:23:09,440 --> 00:23:12,480
um it's like uh this is again the like

00:23:12,080 --> 00:23:14,960
uh

00:23:12,480 --> 00:23:16,880
the code that we had we're going to uh

00:23:14,960 --> 00:23:19,440
now talk about this section so

00:23:16,880 --> 00:23:21,120
the very first bit here the type section

00:23:19,440 --> 00:23:22,720
so webassembly is typed

00:23:21,120 --> 00:23:24,240
and so this is saying hey there's a

00:23:22,720 --> 00:23:27,039
function that takes in a 30

00:23:24,240 --> 00:23:28,080
i32 as a parameter and returns an i32 as

00:23:27,039 --> 00:23:29,520
a result

00:23:28,080 --> 00:23:31,679
it happens that rust and webassembly

00:23:29,520 --> 00:23:32,880
both share the i32 type so even though

00:23:31,679 --> 00:23:36,240
it was in the rust code this is the

00:23:32,880 --> 00:23:38,400
webassembly i32 type just to be clear

00:23:36,240 --> 00:23:40,159
but this how is this actually

00:23:38,400 --> 00:23:41,760
represented in the webassembly file

00:23:40,159 --> 00:23:43,440
well i'm not going to get into all the

00:23:41,760 --> 00:23:45,840
details because this is not just like

00:23:43,440 --> 00:23:49,279
steve reads the webassembly spec to you

00:23:45,840 --> 00:23:49,600
but if you look at the next bytes that

00:23:49,279 --> 00:23:50,799
come

00:23:49,600 --> 00:23:52,640
after so we talked about the magic

00:23:50,799 --> 00:23:54,720
number we talked about the version field

00:23:52,640 --> 00:23:56,240
the very next section says zero one zero

00:23:54,720 --> 00:23:58,720
six and

00:23:56,240 --> 00:23:59,440
in the spec i didn't actually copy paste

00:23:58,720 --> 00:24:02,240
to this yet

00:23:59,440 --> 00:24:04,400
um it says hey the type uh section

00:24:02,240 --> 00:24:06,400
starts with the number zero one

00:24:04,400 --> 00:24:08,159
so you would like expect that like okay

00:24:06,400 --> 00:24:09,600
i need to see what

00:24:08,159 --> 00:24:11,360
section is the first section of this

00:24:09,600 --> 00:24:13,600
module so i read the first byte

00:24:11,360 --> 00:24:14,640
it's zero one oh that means that this is

00:24:13,600 --> 00:24:18,000
a type section

00:24:14,640 --> 00:24:20,480
and the zero six um that corresponds

00:24:18,000 --> 00:24:21,360
to the rest of it so if you count here

00:24:20,480 --> 00:24:24,400
this one two

00:24:21,360 --> 00:24:26,640
three four five six there are six bytes

00:24:24,400 --> 00:24:27,520
in the sort of like body of the type

00:24:26,640 --> 00:24:29,840
section

00:24:27,520 --> 00:24:30,559
and so that number six is what's

00:24:29,840 --> 00:24:33,120
encoding

00:24:30,559 --> 00:24:34,400
how how long like how big is this

00:24:33,120 --> 00:24:36,559
particular section

00:24:34,400 --> 00:24:38,320
and so every section follows this kind

00:24:36,559 --> 00:24:40,159
of rule if you look on the second line

00:24:38,320 --> 00:24:42,880
there you'll see o302

00:24:40,159 --> 00:24:43,840
and then two purple bits after the o2

00:24:42,880 --> 00:24:46,000
it's the same deal

00:24:43,840 --> 00:24:47,840
zero three is a section that corresponds

00:24:46,000 --> 00:24:48,400
to a different part of the webassembly

00:24:47,840 --> 00:24:50,720
spec

00:24:48,400 --> 00:24:52,240
and then there are two bytes long so we

00:24:50,720 --> 00:24:53,200
say okay there are going to be two bytes

00:24:52,240 --> 00:24:55,840
for the next module

00:24:53,200 --> 00:24:56,400
and it repeats um so you say like type

00:24:55,840 --> 00:24:58,320
and then

00:24:56,400 --> 00:25:00,320
the length and then you say what the

00:24:58,320 --> 00:25:02,080
length is um

00:25:00,320 --> 00:25:03,760
and so that's kind of like how the rough

00:25:02,080 --> 00:25:05,360
structure of this whole file is

00:25:03,760 --> 00:25:07,520
formatted you have like

00:25:05,360 --> 00:25:08,880
magic byte version then a list of

00:25:07,520 --> 00:25:11,520
sections where it goes

00:25:08,880 --> 00:25:12,720
section type section length however many

00:25:11,520 --> 00:25:14,400
bytes is in the length

00:25:12,720 --> 00:25:16,000
section type section length however many

00:25:14,400 --> 00:25:16,480
bytes in the length and you just keep

00:25:16,000 --> 00:25:18,960
going

00:25:16,480 --> 00:25:20,480
and going and going and so all of these

00:25:18,960 --> 00:25:20,960
the different color codes map to

00:25:20,480 --> 00:25:22,640
different

00:25:20,960 --> 00:25:24,320
parts of the spec but fundamentally

00:25:22,640 --> 00:25:25,760
that's like how the file is structured

00:25:24,320 --> 00:25:27,919
and that's all that it is

00:25:25,760 --> 00:25:29,840
so um you know once you get comfortable

00:25:27,919 --> 00:25:31,440
with your language's ability to read

00:25:29,840 --> 00:25:32,720
bytes and compare them to things

00:25:31,440 --> 00:25:34,559
like you can whip up something that

00:25:32,720 --> 00:25:35,360
reads the structure at least the

00:25:34,559 --> 00:25:36,720
structure of like

00:25:35,360 --> 00:25:38,480
how many sections are there and what are

00:25:36,720 --> 00:25:38,960
their types is like pretty easy to get

00:25:38,480 --> 00:25:41,919
going

00:25:38,960 --> 00:25:43,360
um i did it in like a weekend basically

00:25:41,919 --> 00:25:44,880
and i didn't even need to like spend all

00:25:43,360 --> 00:25:46,720
weekend to do it it was just like in my

00:25:44,880 --> 00:25:49,200
spare time i happened to go through

00:25:46,720 --> 00:25:50,400
um and so it's it's like not that bad

00:25:49,200 --> 00:25:51,440
once you get into it and then it feels

00:25:50,400 --> 00:25:53,360
like magic because

00:25:51,440 --> 00:25:54,799
for some reason even though like json is

00:25:53,360 --> 00:25:57,200
also stored as binary on

00:25:54,799 --> 00:25:58,640
on the disk working with binary formats

00:25:57,200 --> 00:25:59,279
feels harder than working with text

00:25:58,640 --> 00:26:00,960
formats

00:25:59,279 --> 00:26:02,320
um but like once you get into it it's

00:26:00,960 --> 00:26:05,600
not it's not that bad

00:26:02,320 --> 00:26:09,360
um okay so

00:26:05,600 --> 00:26:10,480
uh this is the the example code again

00:26:09,360 --> 00:26:12,159
you would imagine we go to the memory

00:26:10,480 --> 00:26:13,279
section after the type section blah blah

00:26:12,159 --> 00:26:16,080
all those kind of things

00:26:13,279 --> 00:26:16,720
all right so that's kind of like the the

00:26:16,080 --> 00:26:18,640
rough

00:26:16,720 --> 00:26:20,000
um talking about these two formats how

00:26:18,640 --> 00:26:20,880
they relate to each other and how the

00:26:20,000 --> 00:26:22,640
encoding goes

00:26:20,880 --> 00:26:23,919
you can read the rest of the spec to see

00:26:22,640 --> 00:26:25,120
the details about how all the other

00:26:23,919 --> 00:26:26,080
sections work

00:26:25,120 --> 00:26:27,679
i'm not going to get into those right

00:26:26,080 --> 00:26:30,799
now because i want to talk about

00:26:27,679 --> 00:26:34,159
challenges with debugging this thing

00:26:30,799 --> 00:26:35,919
so obviously you wrote your rust code or

00:26:34,159 --> 00:26:37,760
ruby code or python code or

00:26:35,919 --> 00:26:39,039
javascript code or whatever javascript

00:26:37,760 --> 00:26:42,080
doesn't compile wasm yet

00:26:39,039 --> 00:26:43,360
sorta it's complicated um but uh

00:26:42,080 --> 00:26:45,200
you probably want to be able to debug

00:26:43,360 --> 00:26:46,159
your program so there's gonna be some

00:26:45,200 --> 00:26:47,760
issues there

00:26:46,159 --> 00:26:48,799
first of all the main the big issue in

00:26:47,760 --> 00:26:50,000
the first place is different people

00:26:48,799 --> 00:26:52,320
debug differently

00:26:50,000 --> 00:26:53,200
so some people use printf debugging as

00:26:52,320 --> 00:26:54,720
it's called um

00:26:53,200 --> 00:26:56,400
printf being the way that you print

00:26:54,720 --> 00:26:58,720
strings to the screen and see

00:26:56,400 --> 00:27:00,559
um this is actually surprisingly tricky

00:26:58,720 --> 00:27:02,480
uh in in webassembly

00:27:00,559 --> 00:27:03,919
uh i'll get into that in a second uh the

00:27:02,480 --> 00:27:04,480
second one is like debugging in the

00:27:03,919 --> 00:27:05,840
browser

00:27:04,480 --> 00:27:06,880
so you know if you have a web

00:27:05,840 --> 00:27:08,320
application you've written some

00:27:06,880 --> 00:27:08,559
webassembly you want to be able to debug

00:27:08,320 --> 00:27:09,600
it

00:27:08,559 --> 00:27:12,240
you probably want to do that in the

00:27:09,600 --> 00:27:13,600
browser um how does that work

00:27:12,240 --> 00:27:15,760
you can do printf debugging in the

00:27:13,600 --> 00:27:18,320
browser sometimes called console.log

00:27:15,760 --> 00:27:19,360
debugging but you know you also might

00:27:18,320 --> 00:27:21,039
want to do something a little more

00:27:19,360 --> 00:27:22,720
complicated as well

00:27:21,039 --> 00:27:24,399
and how does that work and then finally

00:27:22,720 --> 00:27:25,840
like debugging outside of the browser

00:27:24,399 --> 00:27:27,200
you don't have any of the affordances

00:27:25,840 --> 00:27:28,880
the browser has and like you don't

00:27:27,200 --> 00:27:29,520
necessarily like know how to print stuff

00:27:28,880 --> 00:27:30,880
to the screen

00:27:29,520 --> 00:27:34,080
because you know you would need the

00:27:30,880 --> 00:27:35,679
format to like describe that um and so

00:27:34,080 --> 00:27:37,120
i think the the real key here is that

00:27:35,679 --> 00:27:38,000
debugging means different things to

00:27:37,120 --> 00:27:39,760
different people

00:27:38,000 --> 00:27:41,279
and they do it in different environments

00:27:39,760 --> 00:27:42,720
and so that's fundamentally what makes

00:27:41,279 --> 00:27:44,799
this challenging is that like

00:27:42,720 --> 00:27:46,159
you can't just say like okay this is how

00:27:44,799 --> 00:27:47,760
we're going to debug the code

00:27:46,159 --> 00:27:48,960
you need to be able to support people in

00:27:47,760 --> 00:27:50,320
whatever way they want to do the

00:27:48,960 --> 00:27:51,760
debugging and whatever environment they

00:27:50,320 --> 00:27:53,120
want to do debugging in

00:27:51,760 --> 00:27:54,480
so we talk about working on debugging

00:27:53,120 --> 00:27:55,679
for webassembly that's going to be like

00:27:54,480 --> 00:27:56,480
one of the largest challenges that

00:27:55,679 --> 00:27:59,200
happens

00:27:56,480 --> 00:28:00,559
um there's also some other challenges

00:27:59,200 --> 00:28:02,640
too beyond that part

00:28:00,559 --> 00:28:04,720
um so we as we have mentioned earlier we

00:28:02,640 --> 00:28:06,159
don't have the source code the wasm file

00:28:04,720 --> 00:28:07,600
does not store the source code of our

00:28:06,159 --> 00:28:08,799
program at all and we've sort of lost

00:28:07,600 --> 00:28:10,559
that in translation

00:28:08,799 --> 00:28:11,760
but when we do our debugging we don't

00:28:10,559 --> 00:28:12,320
probably want to look at the actual

00:28:11,760 --> 00:28:14,960
output

00:28:12,320 --> 00:28:16,399
we want to uh look at the source code of

00:28:14,960 --> 00:28:19,919
the language that we wrote it in so

00:28:16,399 --> 00:28:19,919
that's also like a problem

00:28:21,600 --> 00:28:24,320
and as i mentioned before we have

00:28:22,960 --> 00:28:25,039
different environments browsers

00:28:24,320 --> 00:28:27,200
different dev

00:28:25,039 --> 00:28:29,039
don't have dev tools or like capital d

00:28:27,200 --> 00:28:30,159
capital t dev tools right like i think

00:28:29,039 --> 00:28:30,960
it only makes sense in the context of

00:28:30,159 --> 00:28:33,919
the browser

00:28:30,960 --> 00:28:34,720
um but uh when you think about these

00:28:33,919 --> 00:28:36,640
problems like

00:28:34,720 --> 00:28:38,240
another like sort of big issue here is

00:28:36,640 --> 00:28:40,240
there's even different like

00:28:38,240 --> 00:28:41,360
amounts of instructions so when i wrote

00:28:40,240 --> 00:28:43,679
the rust i said x

00:28:41,360 --> 00:28:45,840
plus one but if you look at the body of

00:28:43,679 --> 00:28:48,480
the the webassembly text format

00:28:45,840 --> 00:28:48,880
that x plus one is actually kind of like

00:28:48,480 --> 00:28:50,720
two

00:28:48,880 --> 00:28:52,640
or even three instructions depending on

00:28:50,720 --> 00:28:55,279
how you think about it um there's the

00:28:52,640 --> 00:28:57,120
get the value of the local variable

00:28:55,279 --> 00:28:59,760
which is the argument that's passed in

00:28:57,120 --> 00:29:00,720
then there's the like push one onto the

00:28:59,760 --> 00:29:02,080
stack

00:29:00,720 --> 00:29:04,000
uh with the second line there and then

00:29:02,080 --> 00:29:04,320
there's add which pops those two numbers

00:29:04,000 --> 00:29:06,320
off

00:29:04,320 --> 00:29:07,840
adds them and pushes the result back on

00:29:06,320 --> 00:29:10,080
so these kind of three steps

00:29:07,840 --> 00:29:11,760
in the webassembly thing correspond to

00:29:10,080 --> 00:29:14,320
one step in our source code

00:29:11,760 --> 00:29:15,840
so like if we wanted to step through the

00:29:14,320 --> 00:29:17,360
webassembly instructions

00:29:15,840 --> 00:29:19,360
do we like keep the source one at the

00:29:17,360 --> 00:29:20,960
same line do we step through the source

00:29:19,360 --> 00:29:22,799
code but we jump in number of

00:29:20,960 --> 00:29:23,279
webassembly instructions like this is

00:29:22,799 --> 00:29:24,960
also

00:29:23,279 --> 00:29:26,240
a kind of an interesting challenge

00:29:24,960 --> 00:29:27,440
whenever you're translating back and

00:29:26,240 --> 00:29:28,799
forth between formats

00:29:27,440 --> 00:29:31,200
even in this kind of very small

00:29:28,799 --> 00:29:31,919
webassembly file we run into this

00:29:31,200 --> 00:29:34,720
problem

00:29:31,919 --> 00:29:36,159
um so that's kind of like the the

00:29:34,720 --> 00:29:37,919
problem set here

00:29:36,159 --> 00:29:39,679
um and we're going to talk about how

00:29:37,919 --> 00:29:41,440
people are solving that currently

00:29:39,679 --> 00:29:43,440
so um i'm going to explain the current

00:29:41,440 --> 00:29:44,080
state but what i want to also impress on

00:29:43,440 --> 00:29:45,440
you is that

00:29:44,080 --> 00:29:47,039
this is a really active area of

00:29:45,440 --> 00:29:48,720
development in a web assembly and so a

00:29:47,039 --> 00:29:50,320
lot of stuff is in flux

00:29:48,720 --> 00:29:52,080
this may not be the stuff i'm talking

00:29:50,320 --> 00:29:53,279
about like may not be the final story

00:29:52,080 --> 00:29:56,399
we're actually going to talk about

00:29:53,279 --> 00:29:57,279
one sort of like false start um and so

00:29:56,399 --> 00:29:58,880
it looks like

00:29:57,279 --> 00:30:00,559
people are in a decent place but we're

00:29:58,880 --> 00:30:01,760
not done yet and there's some

00:30:00,559 --> 00:30:02,960
some reasons why that's true and we're

00:30:01,760 --> 00:30:04,399
going to talk about it um and then

00:30:02,960 --> 00:30:05,760
finally like there's a lot of work left

00:30:04,399 --> 00:30:08,720
to do

00:30:05,760 --> 00:30:09,440
all this is kind of like demo quality i

00:30:08,720 --> 00:30:11,360
would say

00:30:09,440 --> 00:30:13,200
um people have not really done a whole

00:30:11,360 --> 00:30:15,520
lot of this like in production

00:30:13,200 --> 00:30:16,960
and so uh you know that means that

00:30:15,520 --> 00:30:18,000
things might change based on that sort

00:30:16,960 --> 00:30:19,679
of feedback so

00:30:18,000 --> 00:30:21,520
um you know this is like very very a

00:30:19,679 --> 00:30:23,360
cutting edge kind of area

00:30:21,520 --> 00:30:24,640
that leads us to our third section elf

00:30:23,360 --> 00:30:28,320
dwarf and source maps

00:30:24,640 --> 00:30:29,600
um so uh as i've been talking about this

00:30:28,320 --> 00:30:31,600
i've kind of been presenting this as

00:30:29,600 --> 00:30:32,080
like a novel problem but you may be like

00:30:31,600 --> 00:30:34,240
hey

00:30:32,080 --> 00:30:36,000
we also compile our javascript not just

00:30:34,240 --> 00:30:37,679
in like the sense that v8 has a jit and

00:30:36,000 --> 00:30:39,600
does just in time compilation

00:30:37,679 --> 00:30:41,120
but also like we transpile and minify

00:30:39,600 --> 00:30:42,399
our javascript and so that's like a kind

00:30:41,120 --> 00:30:44,000
of compilation on its own

00:30:42,399 --> 00:30:46,399
and we don't have the original source

00:30:44,000 --> 00:30:48,320
code whenever we send our compiled or

00:30:46,399 --> 00:30:50,799
minified and transpiled javascript

00:30:48,320 --> 00:30:51,600
to the browser and people needed to

00:30:50,799 --> 00:30:53,279
debug those

00:30:51,600 --> 00:30:54,640
applications and to do that they added

00:30:53,279 --> 00:30:56,480
source maps

00:30:54,640 --> 00:30:59,039
and so source maps kind of like it says

00:30:56,480 --> 00:31:01,360
uh it maps the source code to

00:30:59,039 --> 00:31:03,279
the like output it's javascript source

00:31:01,360 --> 00:31:05,279
code and that's how your browser's dev

00:31:03,279 --> 00:31:07,360
tools is able to kind of like

00:31:05,279 --> 00:31:09,679
understand where in your original code

00:31:07,360 --> 00:31:13,200
the new javascripts you know

00:31:09,679 --> 00:31:15,279
what it respon corresponds to so the

00:31:13,200 --> 00:31:17,120
um the initial thought behind how to

00:31:15,279 --> 00:31:19,039
debug webassembly is like hey

00:31:17,120 --> 00:31:21,039
we do this we have this problem in

00:31:19,039 --> 00:31:23,120
javascript we solved it with source maps

00:31:21,039 --> 00:31:24,640
so why not use source maps with wasm and

00:31:23,120 --> 00:31:28,399
that seems totally fine

00:31:24,640 --> 00:31:31,840
mozilla actually did this back in 2017

00:31:28,399 --> 00:31:32,559
this is a tweet from flocky who works

00:31:31,840 --> 00:31:34,720
mozilla

00:31:32,559 --> 00:31:36,720
on uh and talking about showing this

00:31:34,720 --> 00:31:39,200
like uh person was presenting

00:31:36,720 --> 00:31:40,320
uh that in firefox nightly you could use

00:31:39,200 --> 00:31:43,679
source maps to

00:31:40,320 --> 00:31:45,120
show uh you know webassembly um being

00:31:43,679 --> 00:31:46,880
uh in the browser and so you can see

00:31:45,120 --> 00:31:49,679
some rust code there in the web

00:31:46,880 --> 00:31:51,279
firefox dev tools um and so that like

00:31:49,679 --> 00:31:52,080
totally worked and people were excited

00:31:51,279 --> 00:31:54,240
about it

00:31:52,080 --> 00:31:55,200
there's just one problem uh it's

00:31:54,240 --> 00:31:58,480
actually

00:31:55,200 --> 00:32:01,360
not great um and uh this is a quote from

00:31:58,480 --> 00:32:02,159
ingvar uh sometimes known as reverser on

00:32:01,360 --> 00:32:04,000
the internet

00:32:02,159 --> 00:32:05,440
uh we're gonna talk a little more about

00:32:04,000 --> 00:32:06,320
where this quote comes from in a second

00:32:05,440 --> 00:32:08,559
but basically

00:32:06,320 --> 00:32:09,519
source maps were designed uh for

00:32:08,559 --> 00:32:11,360
javascript

00:32:09,519 --> 00:32:12,640
and so there's some things about them

00:32:11,360 --> 00:32:13,679
i'm not gonna get into what those things

00:32:12,640 --> 00:32:14,000
are but just the point is when you

00:32:13,679 --> 00:32:15,519
design

00:32:14,000 --> 00:32:17,279
something for javascript but you need to

00:32:15,519 --> 00:32:19,039
use it for something else it may not be

00:32:17,279 --> 00:32:19,919
as good at that something else as it was

00:32:19,039 --> 00:32:23,519
for javascript

00:32:19,919 --> 00:32:24,880
and that's tricky so basically

00:32:23,519 --> 00:32:26,720
there's a bunch of problems with this

00:32:24,880 --> 00:32:28,480
approach and so a lot of people said you

00:32:26,720 --> 00:32:30,480
know what we don't actually really want

00:32:28,480 --> 00:32:33,679
to use source maps to solve this problem

00:32:30,480 --> 00:32:35,039
so what do you do well also during the

00:32:33,679 --> 00:32:36,960
beginning of the presentation if you do

00:32:35,039 --> 00:32:38,640
a lot of native tooling you may be like

00:32:36,960 --> 00:32:39,760
hey

00:32:38,640 --> 00:32:41,519
people have had to deal with these

00:32:39,760 --> 00:32:42,000
problems for a long time like when you

00:32:41,519 --> 00:32:43,919
compile

00:32:42,000 --> 00:32:46,320
your c code into a binary and run it you

00:32:43,919 --> 00:32:48,000
don't have the c source code anymore

00:32:46,320 --> 00:32:49,600
so like that's the same problem we're

00:32:48,000 --> 00:32:51,600
talking about it's not a novel problem

00:32:49,600 --> 00:32:53,519
it's existed for a really long time

00:32:51,600 --> 00:32:55,360
c has existed for a long time and other

00:32:53,519 --> 00:32:56,880
languages that uh you know weren't see

00:32:55,360 --> 00:32:59,039
also like anything that's compiled in a

00:32:56,880 --> 00:33:00,720
binary directly has this problem

00:32:59,039 --> 00:33:02,240
um and people have been debugging for a

00:33:00,720 --> 00:33:03,760
very long time so

00:33:02,240 --> 00:33:05,039
why don't we take the problem the stuff

00:33:03,760 --> 00:33:06,720
that they use to solve their problems

00:33:05,039 --> 00:33:08,320
and apply it to webassembly instead so

00:33:06,720 --> 00:33:10,240
rather than copying javascript

00:33:08,320 --> 00:33:12,720
maybe we should copy c in other native

00:33:10,240 --> 00:33:15,679
languages um

00:33:12,720 --> 00:33:16,960
so this actually sort of is kind of true

00:33:15,679 --> 00:33:19,039
with webassembly itself

00:33:16,960 --> 00:33:20,399
this idea of like sections in a binary

00:33:19,039 --> 00:33:21,039
i'm sure it comes from a lot of places

00:33:20,399 --> 00:33:22,480
but

00:33:21,039 --> 00:33:24,080
there's this thing called elf which is

00:33:22,480 --> 00:33:24,880
short for the executable and linkable

00:33:24,080 --> 00:33:27,360
format

00:33:24,880 --> 00:33:28,080
and this is the the way that programs

00:33:27,360 --> 00:33:31,200
that run

00:33:28,080 --> 00:33:32,320
on your linux system um or other similar

00:33:31,200 --> 00:33:34,240
like unix systems

00:33:32,320 --> 00:33:36,480
this is the format they follow so just

00:33:34,240 --> 00:33:38,799
like webassembly binary as a structure

00:33:36,480 --> 00:33:40,640
your programs like the binary files on

00:33:38,799 --> 00:33:42,240
your hard drive also have a structure

00:33:40,640 --> 00:33:43,840
and if there are linux programs they'll

00:33:42,240 --> 00:33:45,679
follow this elf format

00:33:43,840 --> 00:33:47,200
um and so webassembly share some

00:33:45,679 --> 00:33:48,640
similarities i think some of this is

00:33:47,200 --> 00:33:50,240
just due to direct experience some of

00:33:48,640 --> 00:33:53,200
this is also just cause like it's worked

00:33:50,240 --> 00:33:55,840
since the 70s so our 80s i guess

00:33:53,200 --> 00:33:57,200
um and so like uh why reinvent all the

00:33:55,840 --> 00:33:59,279
wheels and like these

00:33:57,200 --> 00:34:00,880
time-tested solutions to problems so

00:33:59,279 --> 00:34:02,080
there's differences obviously but like a

00:34:00,880 --> 00:34:03,279
lot of there's a lot of similarities

00:34:02,080 --> 00:34:07,200
especially if you squint

00:34:03,279 --> 00:34:08,560
um and so uh like that's how binaries

00:34:07,200 --> 00:34:09,919
are done there so that's how binaries

00:34:08,560 --> 00:34:10,720
are done so what does elf use for

00:34:09,919 --> 00:34:12,399
debugging

00:34:10,720 --> 00:34:13,760
well because the people who made these

00:34:12,399 --> 00:34:15,679
formats are giant nerds

00:34:13,760 --> 00:34:17,520
uh elf has a debugging format called

00:34:15,679 --> 00:34:19,919
dwarf because

00:34:17,520 --> 00:34:21,119
that's a funny joke elves and dwarves

00:34:19,919 --> 00:34:23,599
and so dwarf

00:34:21,119 --> 00:34:24,800
uh you know does is this debugging

00:34:23,599 --> 00:34:27,760
format that's used

00:34:24,800 --> 00:34:28,159
uh to figure out debugging information

00:34:27,760 --> 00:34:31,760
from

00:34:28,159 --> 00:34:35,839
a particular elf uh program um and so

00:34:31,760 --> 00:34:35,839
in the rust world we kept

00:34:36,639 --> 00:34:39,919
by uh using packages like christmas elf

00:34:39,200 --> 00:34:42,159
which uh

00:34:39,919 --> 00:34:43,280
is a library for dealing with elf data

00:34:42,159 --> 00:34:45,919
um in rust

00:34:43,280 --> 00:34:47,839
and then gimli which is a library for

00:34:45,919 --> 00:34:49,919
using dwarf

00:34:47,839 --> 00:34:51,280
because ziemly's dwarf you're a tolkien

00:34:49,919 --> 00:34:53,280
fan um

00:34:51,280 --> 00:34:54,639
and so uh so yeah so there's a rich

00:34:53,280 --> 00:34:55,839
amount of puns in this area and that's

00:34:54,639 --> 00:34:57,200
how you know something is good the more

00:34:55,839 --> 00:35:00,800
jokes it has right

00:34:57,200 --> 00:35:02,320
um so anyway uh so wasm learned a lot

00:35:00,800 --> 00:35:04,000
from elf like i said and so

00:35:02,320 --> 00:35:06,160
why shouldn't debugging like learn from

00:35:04,000 --> 00:35:07,680
dwarf um it's a format it's been used

00:35:06,160 --> 00:35:09,520
for a long time it's pretty good

00:35:07,680 --> 00:35:11,280
um you know dwarf tends to be a very

00:35:09,520 --> 00:35:12,480
unique centered thing uh windows has its

00:35:11,280 --> 00:35:15,599
own thing called pe

00:35:12,480 --> 00:35:16,000
to deal with this um but like uh you

00:35:15,599 --> 00:35:17,680
know

00:35:16,000 --> 00:35:18,880
if it worked once why not do it again

00:35:17,680 --> 00:35:20,160
and so this is kind of the direction

00:35:18,880 --> 00:35:23,119
that things are going it seems like

00:35:20,160 --> 00:35:23,119
people think that using

00:35:23,359 --> 00:35:27,440
since then uh using source maps and so

00:35:25,680 --> 00:35:30,640
there's these attempts to move stuff

00:35:27,440 --> 00:35:32,480
into uh that so like the brow like

00:35:30,640 --> 00:35:33,920
dwarf there's like great tools for

00:35:32,480 --> 00:35:35,920
debugging with dwarf uh

00:35:33,920 --> 00:35:37,520
on the native platform but not a web

00:35:35,920 --> 00:35:39,200
browser so we're kind of in this funny

00:35:37,520 --> 00:35:44,400
kind of opposite situation where

00:35:39,200 --> 00:35:45,680
webassembly was originally made

00:35:44,400 --> 00:35:47,200
we're kind of moving the tooling from

00:35:45,680 --> 00:35:47,599
outside the browser into the browser and

00:35:47,200 --> 00:35:49,119
some

00:35:47,599 --> 00:35:50,800
web applications have only really dealt

00:35:49,119 --> 00:35:53,119
with source maps before um

00:35:50,800 --> 00:35:55,280
so they don't like have native format

00:35:53,119 --> 00:35:56,960
support for dwarf like many other

00:35:55,280 --> 00:35:58,880
native tools do but since they do

00:35:56,960 --> 00:36:00,880
similar things like we can make it work

00:35:58,880 --> 00:36:02,160
and so that's the approach that google

00:36:00,880 --> 00:36:04,960
has been taking lately

00:36:02,160 --> 00:36:06,160
um by basically this is invar so the

00:36:04,960 --> 00:36:07,839
quote from earlier was

00:36:06,160 --> 00:36:10,000
from this blog post called improved

00:36:07,839 --> 00:36:12,720
webassembly debugging chrome dev tools

00:36:10,000 --> 00:36:15,040
but uh devtools and chrome have been

00:36:12,720 --> 00:36:16,880
like basically adding support for dwarf

00:36:15,040 --> 00:36:18,720
so you'd be able to load up those things

00:36:16,880 --> 00:36:20,240
and so it kind of feels very similar in

00:36:18,720 --> 00:36:21,280
many ways the same way where if you want

00:36:20,240 --> 00:36:22,720
people to be able to debug in the

00:36:21,280 --> 00:36:24,079
browser you ship source maps

00:36:22,720 --> 00:36:26,320
this is like instead if you want to be

00:36:24,079 --> 00:36:26,880
able to debug the browser you ship dwarf

00:36:26,320 --> 00:36:29,920
and then

00:36:26,880 --> 00:36:31,920
the you're able to do that um but

00:36:29,920 --> 00:36:34,320
it's not totally done yet while the

00:36:31,920 --> 00:36:35,760
basics work and you can check it out

00:36:34,320 --> 00:36:37,040
there's some additional problems that

00:36:35,760 --> 00:36:38,800
are being worked through to make it more

00:36:37,040 --> 00:36:39,280
robust and also to support some other

00:36:38,800 --> 00:36:41,839
things

00:36:39,280 --> 00:36:43,359
so for example when i ran wasm pack it

00:36:41,839 --> 00:36:45,040
not only generated the web assembly but

00:36:43,359 --> 00:36:45,920
then optimized it by shrinking stuff

00:36:45,040 --> 00:36:47,920
even further

00:36:45,920 --> 00:36:49,200
and so the problem is the dwarf will get

00:36:47,920 --> 00:36:51,280
generated on the first step

00:36:49,200 --> 00:36:53,040
but then we transformed the binary more

00:36:51,280 --> 00:36:53,520
and we didn't update the dwarf so it's

00:36:53,040 --> 00:36:55,680
wrong

00:36:53,520 --> 00:36:57,599
so you like end up with weird results so

00:36:55,680 --> 00:36:59,040
there's work needed to be done in all of

00:36:57,599 --> 00:37:00,240
these tools to kind of like plumb

00:36:59,040 --> 00:37:00,960
everything through the stack in the

00:37:00,240 --> 00:37:02,160
right way

00:37:00,960 --> 00:37:04,320
to make sure that things are like

00:37:02,160 --> 00:37:06,000
working out um and that's true also of

00:37:04,320 --> 00:37:07,280
chrome's implementation itself it's not

00:37:06,000 --> 00:37:08,880
complete and not done

00:37:07,280 --> 00:37:10,480
and you know putting it in other

00:37:08,880 --> 00:37:12,320
browsers and things as well so this is

00:37:10,480 --> 00:37:13,599
very much an active area of development

00:37:12,320 --> 00:37:15,280
and that's kind of the intention is that

00:37:13,599 --> 00:37:17,200
hopefully you just ship these debugging

00:37:15,280 --> 00:37:18,800
files along with your web application

00:37:17,200 --> 00:37:21,200
and you'll be able to use all of your

00:37:18,800 --> 00:37:22,320
native debugging tools in the browser to

00:37:21,200 --> 00:37:22,960
be able to debug webassembly in the

00:37:22,320 --> 00:37:25,520
browser

00:37:22,960 --> 00:37:27,119
and then you can use gdb or lldb or any

00:37:25,520 --> 00:37:29,359
of your other native debuggers

00:37:27,119 --> 00:37:30,640
with that dwarf as well to debug things

00:37:29,359 --> 00:37:31,920
that are outside of the browser and

00:37:30,640 --> 00:37:33,599
we've kind of like

00:37:31,920 --> 00:37:36,000
unified the universe everything works

00:37:33,599 --> 00:37:37,599
and is happy um

00:37:36,000 --> 00:37:39,920
but i think one thing that's interesting

00:37:37,599 --> 00:37:41,440
about this and uh basically this is i'm

00:37:39,920 --> 00:37:43,280
done here but i wanted to mention like

00:37:41,440 --> 00:37:45,440
yeah this is all a work in progress

00:37:43,280 --> 00:37:46,320
there's tons of room to like improve

00:37:45,440 --> 00:37:48,160
these tools

00:37:46,320 --> 00:37:50,079
and we'll see maybe there'll be a bigger

00:37:48,160 --> 00:37:53,520
problem with dwarf and people decide to

00:37:50,079 --> 00:37:55,520
invent a new format instead google seems

00:37:53,520 --> 00:37:58,240
to be really pursuing this

00:37:55,520 --> 00:37:59,359
approach and doing a lot of work on it

00:37:58,240 --> 00:38:01,520
and then but there's also like

00:37:59,359 --> 00:38:03,119
webassembly outside of the browser

00:38:01,520 --> 00:38:04,560
there's lots of buzz mozilla seems to be

00:38:03,119 --> 00:38:05,839
more focused these days on outside of

00:38:04,560 --> 00:38:07,280
the browser than in the browser

00:38:05,839 --> 00:38:09,599
this is kind of like me looking from the

00:38:07,280 --> 00:38:11,200
outside like i don't know what these

00:38:09,599 --> 00:38:12,480
organizations are doing but it seems to

00:38:11,200 --> 00:38:14,240
me like google's really working on

00:38:12,480 --> 00:38:14,720
browser wasm and brazil is working on

00:38:14,240 --> 00:38:16,480
like

00:38:14,720 --> 00:38:17,839
wazzy stuff and that's really cool

00:38:16,480 --> 00:38:18,480
because it's great to use webassembly

00:38:17,839 --> 00:38:20,240
everywhere

00:38:18,480 --> 00:38:22,000
but it's also interesting because the

00:38:20,240 --> 00:38:24,320
the tools are a little bit better

00:38:22,000 --> 00:38:26,079
in native than not um and so i think

00:38:24,320 --> 00:38:27,760
there's more interest in working on wazi

00:38:26,079 --> 00:38:29,760
itself natively rather than worrying

00:38:27,760 --> 00:38:30,800
about dwarf right now so it's like kind

00:38:29,760 --> 00:38:32,400
of unclear

00:38:30,800 --> 00:38:33,920
how much this is going to get sorted out

00:38:32,400 --> 00:38:34,480
on what time frame but there are people

00:38:33,920 --> 00:38:37,359
working on

00:38:34,480 --> 00:38:38,560
all sorts of aspects of this problem and

00:38:37,359 --> 00:38:40,320
so i think that we're going to see a

00:38:38,560 --> 00:38:41,839
very healthy ecosystem for wasm both

00:38:40,320 --> 00:38:42,800
inside and outside of the browser

00:38:41,839 --> 00:38:44,880
and we'll need to deal with the

00:38:42,800 --> 00:38:46,079
debugging problems in both ways and so

00:38:44,880 --> 00:38:47,040
it's great that

00:38:46,079 --> 00:38:48,240
all these different companies are

00:38:47,040 --> 00:38:49,280
working on this stuff and all the

00:38:48,240 --> 00:38:50,960
different people who work at those

00:38:49,280 --> 00:38:53,359
companies they're working on this stuff

00:38:50,960 --> 00:38:54,000
um so with that that is the end of my

00:38:53,359 --> 00:38:56,079
talk

00:38:54,000 --> 00:38:57,119
uh thanks so much for listening and i

00:38:56,079 --> 00:38:59,839
have five more minutes

00:38:57,119 --> 00:39:00,880
i'm happy to answer more questions uh if

00:38:59,839 --> 00:39:02,800
you have any

00:39:00,880 --> 00:39:04,079
we can talk about the question you had

00:39:02,800 --> 00:39:05,520
mike before the talk happened if you

00:39:04,079 --> 00:39:08,400
want to know more about that or

00:39:05,520 --> 00:39:10,240
just like kind of anything in general um

00:39:08,400 --> 00:39:14,560
i'm happy to like give this last five

00:39:10,240 --> 00:39:16,640
minutes to talk about stuff

00:39:14,560 --> 00:39:18,160
cool i'm glad that makes sense yeah

00:39:16,640 --> 00:39:19,599
there's basically ways to transpile

00:39:18,160 --> 00:39:21,200
javascript in or was them into

00:39:19,599 --> 00:39:22,240
javascript and so you can kind of do

00:39:21,200 --> 00:39:29,839
some of that stuff

00:39:22,240 --> 00:39:29,839
it's i'm not sure how reliable it is

00:39:40,839 --> 00:39:43,839
okay

00:39:51,680 --> 00:39:54,320
one interesting thing about this chat

00:39:52,960 --> 00:39:55,920
thing is it doesn't show if anyone is

00:39:54,320 --> 00:39:56,640
typing which i think is normally good

00:39:55,920 --> 00:39:58,160
but uh

00:39:56,640 --> 00:39:59,920
it's also kind of funny because i can't

00:39:58,160 --> 00:40:00,400
tell if anybody's even trying to ask a

00:39:59,920 --> 00:40:02,320
question

00:40:00,400 --> 00:40:04,000
we were in a normal conference i would

00:40:02,320 --> 00:40:07,040
see if anyone had their hands raised

00:40:04,000 --> 00:40:11,839
um oh you're very welcome oleg

00:40:07,040 --> 00:40:11,839
glad i'm glad i met your expectations

00:40:15,599 --> 00:40:20,240
uh okay so um derek asked uh what's the

00:40:18,960 --> 00:40:21,200
issue around compiling javascript to

00:40:20,240 --> 00:40:24,640
webassembly

00:40:21,200 --> 00:40:28,079
so what's interesting is that like

00:40:24,640 --> 00:40:29,520
because browsers are implementing uh

00:40:28,079 --> 00:40:31,599
webassembly as part of the javascript

00:40:29,520 --> 00:40:32,640
runtime there's not a lot of pressure to

00:40:31,599 --> 00:40:34,800
compile javascript

00:40:32,640 --> 00:40:36,000
into wasm because if you want to support

00:40:34,800 --> 00:40:37,920
wasm and javascript

00:40:36,000 --> 00:40:39,760
you basically use v8 or use spider

00:40:37,920 --> 00:40:42,319
monkey and you get both languages

00:40:39,760 --> 00:40:43,760
so um so there's like not as much

00:40:42,319 --> 00:40:45,520
pressure there as there are in other

00:40:43,760 --> 00:40:47,280
places like with other languages

00:40:45,520 --> 00:40:48,960
um and so it's kind of funny because a

00:40:47,280 --> 00:40:50,240
lot of people like would assume that

00:40:48,960 --> 00:40:51,440
javascript would be the first language

00:40:50,240 --> 00:40:52,640
you compile in a wasm

00:40:51,440 --> 00:40:54,160
but i'm not actually aware of a

00:40:52,640 --> 00:40:55,760
production ready implementation of

00:40:54,160 --> 00:40:57,520
compiling javascript into wasm because

00:40:55,760 --> 00:40:58,160
like it sort of doesn't make as much

00:40:57,520 --> 00:40:59,359
sense

00:40:58,160 --> 00:41:00,880
i do think there's sort of an

00:40:59,359 --> 00:41:02,640
interesting idea of maybe eventually

00:41:00,880 --> 00:41:04,240
going all in on wasm and everything is

00:41:02,640 --> 00:41:06,400
only a wasm interpreter

00:41:04,240 --> 00:41:08,000
but uh it's more that like javascript

00:41:06,400 --> 00:41:10,480
tends to be that host environment

00:41:08,000 --> 00:41:11,839
and then the wasm is inside of it rather

00:41:10,480 --> 00:41:13,760
than it being like

00:41:11,839 --> 00:41:15,200
truly universal platform but we'll just

00:41:13,760 --> 00:41:16,640
see where it goes like i don't know i

00:41:15,200 --> 00:41:18,960
think it's very interesting

00:41:16,640 --> 00:41:20,160
and uh you know we'll see what happens

00:41:18,960 --> 00:41:22,880
um

00:41:20,160 --> 00:41:23,599
uh yeah cool glad to answer your

00:41:22,880 --> 00:41:27,119
question

00:41:23,599 --> 00:41:28,400
uh matthew you asked uh why russ seems

00:41:27,119 --> 00:41:29,599
to be ahead of the game compared to go

00:41:28,400 --> 00:41:30,160
and other languages with their was on

00:41:29,599 --> 00:41:31,680
work

00:41:30,160 --> 00:41:33,680
i think there's sort of like two

00:41:31,680 --> 00:41:36,720
different uh things

00:41:33,680 --> 00:41:38,400
the first one is that rust does not have

00:41:36,720 --> 00:41:40,319
a large run time there's no garbage

00:41:38,400 --> 00:41:42,160
collection and so earlier when i

00:41:40,319 --> 00:41:43,920
mentioned that if you compile a program

00:41:42,160 --> 00:41:45,520
you need to also compile that's kind of

00:41:43,920 --> 00:41:47,440
like a runtimey stuff

00:41:45,520 --> 00:41:49,760
and so rust is able to give you these

00:41:47,440 --> 00:41:51,760
very small binaries because you can only

00:41:49,760 --> 00:41:53,359
compile in just your own code and not a

00:41:51,760 --> 00:41:55,200
whole lot of support code

00:41:53,359 --> 00:41:57,119
that's not universally true so for

00:41:55,200 --> 00:41:59,440
example when i was working on this demo

00:41:57,119 --> 00:42:00,240
i actually forgot to assert an

00:41:59,440 --> 00:42:02,480
annotation

00:42:00,240 --> 00:42:04,720
and included all of the standard library

00:42:02,480 --> 00:42:06,880
in my code as well and so my wasm binary

00:42:04,720 --> 00:42:09,440
was like one megabyte instead of like

00:42:06,880 --> 00:42:11,280
84 bytes as i think how big the uh the

00:42:09,440 --> 00:42:13,520
version i showed you here today is

00:42:11,280 --> 00:42:14,800
so that's one advantage that that rust

00:42:13,520 --> 00:42:16,000
has is that you can get these small

00:42:14,800 --> 00:42:18,800
binaries and so that

00:42:16,000 --> 00:42:19,760
tends to be very positive the second one

00:42:18,800 --> 00:42:21,760
is that

00:42:19,760 --> 00:42:22,880
we identified so i'm on the russ core

00:42:21,760 --> 00:42:24,960
team

00:42:22,880 --> 00:42:26,720
we identified that we wanted we knew web

00:42:24,960 --> 00:42:28,560
assembly seemed like a cool technology

00:42:26,720 --> 00:42:30,800
and we wanted russ to work with it

00:42:28,560 --> 00:42:32,560
and so the better more serious reason

00:42:30,800 --> 00:42:34,160
why russ is ahead on the webassembly

00:42:32,560 --> 00:42:35,920
support than a lot of other languages

00:42:34,160 --> 00:42:38,000
is because a lot of people who to be

00:42:35,920 --> 00:42:39,760
clear or not me have put in a lot of

00:42:38,000 --> 00:42:41,760
time and effort and work

00:42:39,760 --> 00:42:44,160
into making that experience really nice

00:42:41,760 --> 00:42:47,119
and making sure that that works properly

00:42:44,160 --> 00:42:48,640
um that's really like a lot of what it

00:42:47,119 --> 00:42:50,079
takes to make these things like work

00:42:48,640 --> 00:42:51,280
really well there's a lot of languages

00:42:50,079 --> 00:42:53,599
that have like demo

00:42:51,280 --> 00:42:55,040
level webassembly support like i think i

00:42:53,599 --> 00:42:56,160
saw a program to compile ruby into

00:42:55,040 --> 00:42:57,599
webassembly once

00:42:56,160 --> 00:43:00,079
but it's not something that ruby team is

00:42:57,599 --> 00:43:02,000
focused on or is like prioritizing

00:43:00,079 --> 00:43:03,680
they have a lot of other stuff to do um

00:43:02,000 --> 00:43:05,200
and so i think that's part of it is just

00:43:03,680 --> 00:43:05,920
like people who are willing to put in

00:43:05,200 --> 00:43:07,599
the work

00:43:05,920 --> 00:43:08,960
um and so i think other languages over

00:43:07,599 --> 00:43:10,800
time will get better here

00:43:08,960 --> 00:43:12,560
c-sharp especially is like really

00:43:10,800 --> 00:43:14,240
trailblazing the way with blazor

00:43:12,560 --> 00:43:16,160
um and i think that's like a big part of

00:43:14,240 --> 00:43:18,160
it um so i hope that that helps sort of

00:43:16,160 --> 00:43:21,760
the two things small binaries plus

00:43:18,160 --> 00:43:24,160
uh that that part um

00:43:21,760 --> 00:43:25,280
so uh oh like you asked about why i'm

00:43:24,160 --> 00:43:26,560
outside the browser

00:43:25,280 --> 00:43:27,920
i think the most interesting thing is

00:43:26,560 --> 00:43:28,960
using as a replacement for virtual

00:43:27,920 --> 00:43:31,359
machines

00:43:28,960 --> 00:43:32,480
so uh the guy who made docker originally

00:43:31,359 --> 00:43:34,560
uh had said

00:43:32,480 --> 00:43:36,240
that uh if wasim has existed when he

00:43:34,560 --> 00:43:37,280
made docker he may not have made docker

00:43:36,240 --> 00:43:38,160
in the first place

00:43:37,280 --> 00:43:40,960
and a lot of people were sort of

00:43:38,160 --> 00:43:43,440
confused by that i gave a talk called

00:43:40,960 --> 00:43:44,880
webassembly rust in the future of

00:43:43,440 --> 00:43:46,079
serverless that like kind of goes into

00:43:44,880 --> 00:43:48,240
this argument in general

00:43:46,079 --> 00:43:49,359
but basically like webassembly because

00:43:48,240 --> 00:43:50,000
it's designed to be embedded in a

00:43:49,359 --> 00:43:51,680
browser

00:43:50,000 --> 00:43:53,200
you can also embed it everywhere else

00:43:51,680 --> 00:43:54,000
and so you could actually like kind of

00:43:53,200 --> 00:43:56,319
use webassembly

00:43:54,000 --> 00:43:58,319
as a way of isolating programs from each

00:43:56,319 --> 00:44:00,160
other and that kind of gets into virtual

00:43:58,319 --> 00:44:02,319
machine slash docker

00:44:00,160 --> 00:44:04,000
territory and so there's kind of this

00:44:02,319 --> 00:44:04,880
really interesting possibilities in the

00:44:04,000 --> 00:44:08,160
future over there

00:44:04,880 --> 00:44:09,760
we'll sort of see how it goes and uh

00:44:08,160 --> 00:44:11,680
last david in this last minute we got

00:44:09,760 --> 00:44:12,480
here i'm glad that answers a question

00:44:11,680 --> 00:44:14,560
for you matthew

00:44:12,480 --> 00:44:15,920
uh david you asked how source code would

00:44:14,560 --> 00:44:16,640
be available with the developer tools of

00:44:15,920 --> 00:44:19,040
the browser

00:44:16,640 --> 00:44:20,160
so what the formats like dwarf do is

00:44:19,040 --> 00:44:23,280
they basically say

00:44:20,160 --> 00:44:25,680
like this function exists at this

00:44:23,280 --> 00:44:29,520
position in a file that has this name

00:44:25,680 --> 00:44:32,079
so it'll say like source lib.rs

00:44:29,520 --> 00:44:34,079
line 3 position 0 and that would be like

00:44:32,079 --> 00:44:35,920
the zeroth column in the file

00:44:34,079 --> 00:44:37,920
and so your tools would need to be able

00:44:35,920 --> 00:44:40,640
to map like what's in there

00:44:37,920 --> 00:44:42,319
to the source code itself so um i'm not

00:44:40,640 --> 00:44:44,000
actually 100 sure how this works in the

00:44:42,319 --> 00:44:46,319
browser specifically

00:44:44,000 --> 00:44:47,760
um but like that's the rough way that

00:44:46,319 --> 00:44:49,280
these things connect is basically the

00:44:47,760 --> 00:44:50,720
debug info says

00:44:49,280 --> 00:44:52,880
the function that lives at this part of

00:44:50,720 --> 00:44:55,200
the binary corresponds to this line

00:44:52,880 --> 00:44:57,119
and column of the source code and so i'm

00:44:55,200 --> 00:44:57,599
imagining that the protocol has some way

00:44:57,119 --> 00:45:00,480
of like

00:44:57,599 --> 00:45:00,800
also grabbing the source code out too

00:45:00,480 --> 00:45:02,400
but

00:45:00,800 --> 00:45:04,240
uh actually i haven't i haven't thought

00:45:02,400 --> 00:45:05,920
about that directly i'm used to it being

00:45:04,240 --> 00:45:06,800
in native tools where it loads it from

00:45:05,920 --> 00:45:08,880
the file system

00:45:06,800 --> 00:45:10,160
um but i think that there's like some

00:45:08,880 --> 00:45:12,400
way of uh

00:45:10,160 --> 00:45:13,440
of also producing like giving the source

00:45:12,400 --> 00:45:15,599
code um

00:45:13,440 --> 00:45:16,880
so yeah that's kind of like the the

00:45:15,599 --> 00:45:18,400
rough way that it works

00:45:16,880 --> 00:45:20,319
um but you're right that i don't know if

00:45:18,400 --> 00:45:22,240
you also then serve the source code

00:45:20,319 --> 00:45:24,400
or if maybe it's running locally you're

00:45:22,240 --> 00:45:25,920
able to like get it somehow

00:45:24,400 --> 00:45:27,760
i'm not actually 100 sure to be honest

00:45:25,920 --> 00:45:30,160
with you

00:45:27,760 --> 00:45:31,760
cool cool well my time is up thanks so

00:45:30,160 --> 00:45:33,280
much again everybody

00:45:31,760 --> 00:45:41,599
have a great rest of the conference and

00:45:33,280 --> 00:45:41,599

YouTube URL: https://www.youtube.com/watch?v=CY8fiOUqA1U


