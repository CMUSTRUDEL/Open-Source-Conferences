Title: Veer Muchandi - Securing Applications and Pipelines on a Container Platform
Publication date: 2020-05-20
Playlist: Open Source 101 at Home 2020
Description: 
	Securing Applications and Pipelines on a Container Platform

Presented at: Open Source 101 at Home 2020
Presented by: Veer Muchandi, Red Hat Inc

Abstract: While everyone wants to do Containers and Kubernetes, they don’t know what they are getting into from Security perspective. This session intends to take you from “I don’t know what I don’t know” to “I know what I don’t know”. This helps you to make informed choices on Application Security.

Kubernetes as a Container Platform is becoming a de facto for every enterprise. In my interactions with enterprises adopting container platform, I come across common questions: 

- How does application security work on this platform? What all do I need to secure? 
- How do I implement security in pipelines? 
- What about vulnerabilities discovered at a later point in time? 
- What are newer technologies like Istio Service Mesh bring to table?

In this session, I will be addressing these commonly asked questions that every enterprise trying to adopt an Enterprise Kubernetes Platform needs to know so that they can make informed decisions.

For more info: https://opensource101.com
Captions: 
	00:00:05,400 --> 00:00:12,150
[Music]

00:00:09,769 --> 00:00:16,350
all right it's 2:00 p.m. let's get

00:00:12,150 --> 00:00:16,920
started hello everyone my name is veer

00:00:16,350 --> 00:00:18,779
Micelli

00:00:16,920 --> 00:00:22,020
I'm chief architect for continuous

00:00:18,779 --> 00:00:25,260
solutions with Red Hat

00:00:22,020 --> 00:00:29,010
today's topic securing applications on a

00:00:25,260 --> 00:00:32,430
container platform when I say container

00:00:29,010 --> 00:00:36,000
platform here I specifically mean a

00:00:32,430 --> 00:00:39,899
kubernetes based container platform off

00:00:36,000 --> 00:00:42,329
late in in the last couple of years have

00:00:39,899 --> 00:00:44,789
all known windows have switched on to

00:00:42,329 --> 00:00:46,920
kubernetes so I'm going to be focused on

00:00:44,789 --> 00:00:50,730
securing applications on a kubernetes

00:00:46,920 --> 00:00:55,010
platform the goals of our session today

00:00:50,730 --> 00:00:58,079
we will talk about will quickly look at

00:00:55,010 --> 00:01:01,050
containers and how they work and then

00:00:58,079 --> 00:01:02,789
we'll look at how can how we can deal

00:01:01,050 --> 00:01:05,250
with continuous security at the host

00:01:02,789 --> 00:01:07,170
operating system level we will think

00:01:05,250 --> 00:01:10,409
about how continuous security works at

00:01:07,170 --> 00:01:13,409
Build time how continuous security works

00:01:10,409 --> 00:01:15,210
at runtime and then we'll look at water

00:01:13,409 --> 00:01:17,850
additional features we should be looking

00:01:15,210 --> 00:01:19,970
at a platform at kubernetes based

00:01:17,850 --> 00:01:25,920
platform and what can we expect from it

00:01:19,970 --> 00:01:30,030
now the the intent of this session is

00:01:25,920 --> 00:01:31,860
for the audience to go from where we

00:01:30,030 --> 00:01:35,100
don't know what we don't know in terms

00:01:31,860 --> 00:01:37,259
of securing applications on a kubernetes

00:01:35,100 --> 00:01:39,479
platform to at least to a state where we

00:01:37,259 --> 00:01:41,100
know what to look for right so we don't

00:01:39,479 --> 00:01:42,329
know what what we don't know do we know

00:01:41,100 --> 00:01:45,509
what we don't know kind of thing right

00:01:42,329 --> 00:01:47,280
so this is not a session where I'm going

00:01:45,509 --> 00:01:49,530
to give all answers to all your

00:01:47,280 --> 00:01:51,149
questions as more of you know what wrote

00:01:49,530 --> 00:01:53,759
the lists of questions is that's the

00:01:51,149 --> 00:01:56,310
intent of the session so let's end this

00:01:53,759 --> 00:01:58,130
let's spend a quick few minutes to

00:01:56,310 --> 00:02:00,270
understand how containers work and why

00:01:58,130 --> 00:02:02,479
this will give us the ground to

00:02:00,270 --> 00:02:05,579
understand why continuous security is

00:02:02,479 --> 00:02:07,799
extremely important so in order to

00:02:05,579 --> 00:02:11,660
understand how continual continuous work

00:02:07,799 --> 00:02:13,810
we will compare containers with

00:02:11,660 --> 00:02:15,940
virtualization for

00:02:13,810 --> 00:02:17,740
so think about virtualization this is

00:02:15,940 --> 00:02:20,110
something that you all know about but

00:02:17,740 --> 00:02:21,940
I'm just trying to put the thought in

00:02:20,110 --> 00:02:23,950
your mind so that you can clearly

00:02:21,940 --> 00:02:25,840
visualize how things are right so we

00:02:23,950 --> 00:02:28,150
have a physical infrastructure on the

00:02:25,840 --> 00:02:30,670
top of which we run hypervisor in case

00:02:28,150 --> 00:02:32,740
of virtualization that hypervisor allows

00:02:30,670 --> 00:02:35,530
us to share the physical resources

00:02:32,740 --> 00:02:37,450
across multiple sandboxes which we call

00:02:35,530 --> 00:02:39,459
as virtual machines and each virtual

00:02:37,450 --> 00:02:41,470
machine will run its own operating

00:02:39,459 --> 00:02:43,690
system and on the top of that operating

00:02:41,470 --> 00:02:45,250
system we here we install libraries we

00:02:43,690 --> 00:02:48,700
install malware we install our own

00:02:45,250 --> 00:02:51,610
applications and run now each VM has its

00:02:48,700 --> 00:02:53,980
own full complete operating system and

00:02:51,610 --> 00:02:55,989
for example we and one could be running

00:02:53,980 --> 00:02:57,910
Red Hat Enterprise Linux VM two could be

00:02:55,989 --> 00:03:00,250
running Windows VM three could be

00:02:57,910 --> 00:03:02,890
running Ubuntu and things like that all

00:03:00,250 --> 00:03:04,959
of them can coexist peacefully on the

00:03:02,890 --> 00:03:06,820
same infrastructure now come to the

00:03:04,959 --> 00:03:09,160
world of containers things are a little

00:03:06,820 --> 00:03:10,630
different here the underlying

00:03:09,160 --> 00:03:12,610
infrastructure could be a physical

00:03:10,630 --> 00:03:14,019
machine or a virtual machine it doesn't

00:03:12,610 --> 00:03:16,660
matter now

00:03:14,019 --> 00:03:18,640
on that host you are running an

00:03:16,660 --> 00:03:21,549
operating system which is called a host

00:03:18,640 --> 00:03:23,380
operating system from the container

00:03:21,549 --> 00:03:25,269
standpoint and you run a bunch of

00:03:23,380 --> 00:03:28,870
containers on the top of that host and

00:03:25,269 --> 00:03:31,000
all these containers include all the

00:03:28,870 --> 00:03:32,890
layers that you need your application to

00:03:31,000 --> 00:03:35,769
run so for example if your application

00:03:32,890 --> 00:03:37,150
is a Java app and it expects some middle

00:03:35,769 --> 00:03:38,560
way to run let's say Tomcat that's

00:03:37,150 --> 00:03:41,320
included inside the container and the

00:03:38,560 --> 00:03:42,940
Tomcat expects a Java runtime that's

00:03:41,320 --> 00:03:44,769
included inside the container and the

00:03:42,940 --> 00:03:46,269
Java Runtime expects some operating

00:03:44,769 --> 00:03:49,269
system libraries that's also included

00:03:46,269 --> 00:03:50,799
inside the container however all the

00:03:49,269 --> 00:03:54,160
containers that are running on a post

00:03:50,799 --> 00:03:55,989
will share the kernel coming from that

00:03:54,160 --> 00:03:59,290
host operating system that year that

00:03:55,989 --> 00:04:01,720
that is set up on that box as opposed to

00:03:59,290 --> 00:04:03,519
in the world of VMs every VM will gets

00:04:01,720 --> 00:04:05,560
its own kernel because VM gets a

00:04:03,519 --> 00:04:07,660
complete operating system right that's

00:04:05,560 --> 00:04:10,780
the key difference now with that being

00:04:07,660 --> 00:04:13,060
said one of there is a common

00:04:10,780 --> 00:04:16,180
misunderstanding on how containers run

00:04:13,060 --> 00:04:18,459
on the top of a container host so think

00:04:16,180 --> 00:04:20,440
about a continued host as a host with

00:04:18,459 --> 00:04:22,330
the host operating system which includes

00:04:20,440 --> 00:04:24,669
a kernel right on the top of which a

00:04:22,330 --> 00:04:26,720
bunch of processes run non container

00:04:24,669 --> 00:04:29,630
processes any game on

00:04:26,720 --> 00:04:31,790
let's say sshd or FTB or anything like

00:04:29,630 --> 00:04:34,520
that least non-contingent processes

00:04:31,790 --> 00:04:36,770
running on that host and you also have a

00:04:34,520 --> 00:04:40,040
container engine that runs containers

00:04:36,770 --> 00:04:41,750
but the common misconception is that the

00:04:40,040 --> 00:04:43,160
containers will run on the top of

00:04:41,750 --> 00:04:46,730
container again this is this is

00:04:43,160 --> 00:04:49,670
incorrect so what is right so containers

00:04:46,730 --> 00:04:51,500
are like regular non continual processes

00:04:49,670 --> 00:04:54,650
that run on the top of the container

00:04:51,500 --> 00:04:56,660
post container engine will talk to the

00:04:54,650 --> 00:04:58,070
kernel and spin up those continue

00:04:56,660 --> 00:05:00,020
processes that's the role of container

00:04:58,070 --> 00:05:01,790
Union it is not that the containers are

00:05:00,020 --> 00:05:03,950
processes that are running on top of

00:05:01,790 --> 00:05:07,010
container engine that's in current now

00:05:03,950 --> 00:05:08,990
if that's the if that's how the

00:05:07,010 --> 00:05:10,940
containers run if they are actually

00:05:08,990 --> 00:05:12,560
running on the top of the kernel and

00:05:10,940 --> 00:05:15,410
shearing the kernel along with other

00:05:12,560 --> 00:05:17,450
processes then there are some issues

00:05:15,410 --> 00:05:19,400
that we that come to mind in terms of

00:05:17,450 --> 00:05:22,700
security right so think about think

00:05:19,400 --> 00:05:24,590
about it this way let's say you are a

00:05:22,700 --> 00:05:26,630
developer and you have built a container

00:05:24,590 --> 00:05:29,390
and you are running on is a container

00:05:26,630 --> 00:05:31,910
host and I am another developer but this

00:05:29,390 --> 00:05:34,070
case in this case let's say I'm a rogue

00:05:31,910 --> 00:05:37,460
developer and you are a angel developer

00:05:34,070 --> 00:05:40,250
right so as a rogue developer I built a

00:05:37,460 --> 00:05:42,080
container my container is sharing

00:05:40,250 --> 00:05:45,260
colonel along with your container what

00:05:42,080 --> 00:05:47,390
prevents my container from not going and

00:05:45,260 --> 00:05:49,310
tampering your resources your container

00:05:47,390 --> 00:05:51,620
resources in fact what provides my

00:05:49,310 --> 00:05:54,230
container process from not going in

00:05:51,620 --> 00:05:55,640
tampering system resources right because

00:05:54,230 --> 00:05:57,740
I'm sure we are both sharing the same

00:05:55,640 --> 00:05:59,630
kernel and I'm saying the kernel along

00:05:57,740 --> 00:06:01,400
with the rest of the system so what

00:05:59,630 --> 00:06:03,440
prevents me from going and hacking into

00:06:01,400 --> 00:06:06,410
the system itself right that's question

00:06:03,440 --> 00:06:08,870
a move on kristan number two let's say I

00:06:06,410 --> 00:06:11,419
am a bad program at this time you're

00:06:08,870 --> 00:06:14,300
still a good program right we have our

00:06:11,419 --> 00:06:16,960
containers running on the same host what

00:06:14,300 --> 00:06:20,540
prevents my badly-written program to

00:06:16,960 --> 00:06:22,940
from not consuming all the resources on

00:06:20,540 --> 00:06:25,730
that host like CPU memory and all and

00:06:22,940 --> 00:06:26,840
grow bigger and rigor and know what

00:06:25,730 --> 00:06:28,370
prevents it from choking other

00:06:26,840 --> 00:06:33,050
containers right that's question number

00:06:28,370 --> 00:06:35,539
two question three we are both good

00:06:33,050 --> 00:06:38,390
programmers this time right but you are

00:06:35,539 --> 00:06:40,090
writing your code and let's say PHP I am

00:06:38,390 --> 00:06:41,710
writing my code in JavaScript

00:06:40,090 --> 00:06:43,210
these are different technologies running

00:06:41,710 --> 00:06:45,700
on the same host and different

00:06:43,210 --> 00:06:48,040
containers but how can this co-exist

00:06:45,700 --> 00:06:50,650
together at the same time what if my

00:06:48,040 --> 00:06:52,630
version of Java gets upgraded which is

00:06:50,650 --> 00:06:56,169
going to impact me or impact you right

00:06:52,630 --> 00:06:58,120
can how can they exist on the same host

00:06:56,169 --> 00:06:59,410
without fighting with each other in

00:06:58,120 --> 00:07:01,300
terms of the libraries that they are

00:06:59,410 --> 00:07:02,710
going to use version of libraries that

00:07:01,300 --> 00:07:05,230
they are going to use and all that right

00:07:02,710 --> 00:07:07,300
who provides that isolation that's

00:07:05,230 --> 00:07:09,639
question number three so let's think

00:07:07,300 --> 00:07:12,490
about how the containers will share the

00:07:09,639 --> 00:07:16,840
same kernel and how container security

00:07:12,490 --> 00:07:18,970
is works in in order to control access

00:07:16,840 --> 00:07:21,400
to the kernel as well as protect the

00:07:18,970 --> 00:07:23,470
host and other containers on the top of

00:07:21,400 --> 00:07:25,660
the host right so let's think about how

00:07:23,470 --> 00:07:26,770
container technology works in this way

00:07:25,660 --> 00:07:31,570
from the host operating system

00:07:26,770 --> 00:07:33,970
perspective host operating system is the

00:07:31,570 --> 00:07:36,310
most important thing when it comes to

00:07:33,970 --> 00:07:39,070
container the kind of host operating

00:07:36,310 --> 00:07:40,660
system you are using is extremely

00:07:39,070 --> 00:07:43,570
important from continuous security

00:07:40,660 --> 00:07:46,510
standpoint because containers are things

00:07:43,570 --> 00:07:48,010
that are enabled by the core

00:07:46,510 --> 00:07:49,690
technologies that are provided by the

00:07:48,010 --> 00:07:52,780
host operating system let's look at what

00:07:49,690 --> 00:07:56,530
these are so from host OS perspective

00:07:52,780 --> 00:08:00,010
you have things like Linux link spaces

00:07:56,530 --> 00:08:01,539
Linux control groups sa Linux and a

00:08:00,010 --> 00:08:03,160
bunch of other things well I will

00:08:01,539 --> 00:08:06,880
explain this in a little bit more detail

00:08:03,160 --> 00:08:09,490
the last problem that I talked about

00:08:06,880 --> 00:08:11,410
isolation where the containers can run

00:08:09,490 --> 00:08:13,360
in their own realm without impacting

00:08:11,410 --> 00:08:16,090
each other how is that possible that was

00:08:13,360 --> 00:08:18,789
possible because we have this concept

00:08:16,090 --> 00:08:21,850
called Linux namespaces that the Linux

00:08:18,789 --> 00:08:23,620
operating system provides there are

00:08:21,850 --> 00:08:27,610
different kinds of namespaces I give you

00:08:23,620 --> 00:08:29,710
a couple of examples feed namespaces for

00:08:27,610 --> 00:08:31,900
example it's called it's also called

00:08:29,710 --> 00:08:33,820
process namespaces so if you think about

00:08:31,900 --> 00:08:35,530
the processes running on your Linux

00:08:33,820 --> 00:08:37,000
system so let's say you log on to your

00:08:35,530 --> 00:08:39,909
Linux system as a system administrator

00:08:37,000 --> 00:08:42,550
and you type in PS you will see a list

00:08:39,909 --> 00:08:44,500
of process IDs of all the processes that

00:08:42,550 --> 00:08:46,930
are running on that box every process

00:08:44,500 --> 00:08:48,580
will have its ID right now your

00:08:46,930 --> 00:08:50,320
container if it is a process that also

00:08:48,580 --> 00:08:52,420
gets a process ID let's say that

00:08:50,320 --> 00:08:56,050
continuous process IDs

00:08:52,420 --> 00:08:59,440
1,050 let's assume that right now if you

00:08:56,050 --> 00:09:01,269
go into the container and then type in

00:08:59,440 --> 00:09:03,370
the peers inside the container itself

00:09:01,269 --> 00:09:06,370
you will see that first process of

00:09:03,370 --> 00:09:08,709
container is for society number one this

00:09:06,370 --> 00:09:10,449
is possible because each Linux process

00:09:08,709 --> 00:09:15,250
can be assigned more than one process ID

00:09:10,449 --> 00:09:17,589
and Linux the the feet namespace makes

00:09:15,250 --> 00:09:19,600
use of that so each process the

00:09:17,589 --> 00:09:21,850
container process gets to process IDs

00:09:19,600 --> 00:09:23,230
one from the system admins perspective

00:09:21,850 --> 00:09:25,930
and the other thing from the containers

00:09:23,230 --> 00:09:27,940
own perspective and any processes that

00:09:25,930 --> 00:09:29,560
are spun up by this containers root

00:09:27,940 --> 00:09:32,290
puzzle which is for society number one

00:09:29,560 --> 00:09:34,420
will get a separate process ID so you

00:09:32,290 --> 00:09:36,820
have your own process tree that is found

00:09:34,420 --> 00:09:39,070
inside a container and if you are

00:09:36,820 --> 00:09:41,529
getting to a container and run peers

00:09:39,070 --> 00:09:43,870
you'll only see the process tree that is

00:09:41,529 --> 00:09:45,220
spun up by that containers root process

00:09:43,870 --> 00:09:47,709
not anything else that is running on the

00:09:45,220 --> 00:09:49,750
system so even though you have multiple

00:09:47,709 --> 00:09:52,300
containers running on that host you will

00:09:49,750 --> 00:09:54,910
not see all those processes when you

00:09:52,300 --> 00:09:57,940
type in PS inside a container you'll see

00:09:54,910 --> 00:10:00,160
only those processes or process IDs that

00:09:57,940 --> 00:10:03,070
belong to that containers process tree

00:10:00,160 --> 00:10:05,140
and with its own set of cross societies

00:10:03,070 --> 00:10:07,510
that's how big namespace works so you

00:10:05,140 --> 00:10:09,670
now understood all the process isolation

00:10:07,510 --> 00:10:12,820
works with big namespaces right in the

00:10:09,670 --> 00:10:14,680
same way there is Network namespaces

00:10:12,820 --> 00:10:17,769
which provides network size network

00:10:14,680 --> 00:10:21,370
isolation with individual virtual

00:10:17,769 --> 00:10:22,959
network stack for each container so in

00:10:21,370 --> 00:10:25,360
the same way there are different kinds

00:10:22,959 --> 00:10:27,640
of namespaces mod namespaces UTS

00:10:25,360 --> 00:10:29,709
namespaces IPC namespaces the recent

00:10:27,640 --> 00:10:31,480
introduction is username spaces which

00:10:29,709 --> 00:10:34,300
allows you to have your own set of user

00:10:31,480 --> 00:10:37,839
ID is that are mapped to your own

00:10:34,300 --> 00:10:40,390
container from from from the user IDs

00:10:37,839 --> 00:10:43,360
that are given on the hosts so a user ID

00:10:40,390 --> 00:10:46,360
on the host could be 10,000 but in your

00:10:43,360 --> 00:10:48,339
container that could be mapped as root

00:10:46,360 --> 00:10:50,319
user right so you can have your own

00:10:48,339 --> 00:10:51,760
route inside the container that acts as

00:10:50,319 --> 00:10:54,250
a route inside the container front but

00:10:51,760 --> 00:10:57,850
from the hosts perspective it is user ID

00:10:54,250 --> 00:10:59,589
10,000 so even if the user escapes out

00:10:57,850 --> 00:11:02,110
of the container process and gets to the

00:10:59,589 --> 00:11:03,610
host that user doesn't have the root

00:11:02,110 --> 00:11:05,690
privileges from that perspective right

00:11:03,610 --> 00:11:07,760
that's how user name spaces are use

00:11:05,690 --> 00:11:09,320
user names phases are not used much but

00:11:07,760 --> 00:11:11,030
I just wanted to let you know that these

00:11:09,320 --> 00:11:13,700
there are different kinds of namespaces

00:11:11,030 --> 00:11:16,340
that provide you isolation so this set

00:11:13,700 --> 00:11:18,110
of namespaces coming together is make is

00:11:16,340 --> 00:11:22,750
what is making containers possible

00:11:18,110 --> 00:11:25,940
number one we look at this other issue

00:11:22,750 --> 00:11:27,770
what prevents my badly-written container

00:11:25,940 --> 00:11:29,570
from choking all your other Patino's

00:11:27,770 --> 00:11:31,970
right this is where another technology

00:11:29,570 --> 00:11:33,980
learn X technology called less control

00:11:31,970 --> 00:11:36,820
groups comes into play what does this do

00:11:33,980 --> 00:11:39,530
Linux control groups ensures that a

00:11:36,820 --> 00:11:41,390
contain you are sitting upper limits in

00:11:39,530 --> 00:11:43,130
terms of how much CPU how much memory

00:11:41,390 --> 00:11:45,260
how much network bandwidth they can a

00:11:43,130 --> 00:11:49,280
particular container can use and once

00:11:45,260 --> 00:11:51,500
you set those those limits kernel visa

00:11:49,280 --> 00:11:54,920
will enforce those limits so when you

00:11:51,500 --> 00:11:57,230
spin up a container a the next host will

00:11:54,920 --> 00:11:59,360
set up a control groups setting in terms

00:11:57,230 --> 00:12:01,010
of how much you can't your container can

00:11:59,360 --> 00:12:03,860
consume and how much it can go to a

00:12:01,010 --> 00:12:06,500
maximum right and then the kernel will

00:12:03,860 --> 00:12:09,410
enforce those limits the third

00:12:06,500 --> 00:12:12,950
technology which is not applicable for

00:12:09,410 --> 00:12:15,080
all for all kinds of containers and all

00:12:12,950 --> 00:12:17,120
operating systems the reason why I said

00:12:15,080 --> 00:12:19,300
choosing the right of operating system

00:12:17,120 --> 00:12:24,170
is important this is more of a

00:12:19,300 --> 00:12:26,240
additional additional protection around

00:12:24,170 --> 00:12:29,840
your containers like jail in which is

00:12:26,240 --> 00:12:32,030
provided by is a Linux and with type

00:12:29,840 --> 00:12:34,880
informal enforcement what does this do

00:12:32,030 --> 00:12:35,990
it applies mandatory access control in

00:12:34,880 --> 00:12:37,730
addition to the disks which

00:12:35,990 --> 00:12:40,580
discretionary access control that we

00:12:37,730 --> 00:12:42,770
already use what does that mean so in

00:12:40,580 --> 00:12:44,990
case of discretionary access control we

00:12:42,770 --> 00:12:48,740
are actually preventing access to

00:12:44,990 --> 00:12:50,270
resources or provide allowing access and

00:12:48,740 --> 00:12:53,210
preventing access to the resources based

00:12:50,270 --> 00:12:55,190
on user group and others we are all

00:12:53,210 --> 00:12:58,730
aware of how to make those settings

00:12:55,190 --> 00:13:01,070
right so but in the world of is in Linux

00:12:58,730 --> 00:13:03,080
we use a technology called money - the

00:13:01,070 --> 00:13:04,850
access control which means that by

00:13:03,080 --> 00:13:08,090
default you don't have any access and we

00:13:04,850 --> 00:13:10,730
allow access by a process of labeling

00:13:08,090 --> 00:13:11,450
the system every when you have a

00:13:10,730 --> 00:13:13,940
sillyness

00:13:11,450 --> 00:13:17,060
running and enforcing more every

00:13:13,940 --> 00:13:19,550
resource will get a label and every

00:13:17,060 --> 00:13:22,880
process gets a label and you set up

00:13:19,550 --> 00:13:26,089
policy is called SELinux policies that

00:13:22,880 --> 00:13:28,459
allow processes with so insoluble to

00:13:26,089 --> 00:13:30,050
access resources with so in Salado so

00:13:28,459 --> 00:13:32,089
when your container processes get

00:13:30,050 --> 00:13:35,360
created they will be running with the

00:13:32,089 --> 00:13:37,820
type S word Aleksey next T right this

00:13:35,360 --> 00:13:41,390
will this will be the label assigned to

00:13:37,820 --> 00:13:43,730
the process and the container content

00:13:41,390 --> 00:13:46,040
all the resources that are inside the

00:13:43,730 --> 00:13:48,529
container will be given s word sandbox

00:13:46,040 --> 00:13:51,140
file T now policies are set up so that

00:13:48,529 --> 00:13:53,089
the processes with so-and-so label can

00:13:51,140 --> 00:13:56,630
access these resources was so insoluble

00:13:53,089 --> 00:13:58,899
what this helps you to do is that the

00:13:56,630 --> 00:14:01,970
container process cannot actually go and

00:13:58,899 --> 00:14:03,560
steal data or make any manipulations

00:14:01,970 --> 00:14:05,690
with the system resources because a

00:14:03,560 --> 00:14:10,459
salinas will not allow it so even if

00:14:05,690 --> 00:14:12,950
there is a issue a vulnerability that

00:14:10,459 --> 00:14:15,410
someone gets out of the container

00:14:12,950 --> 00:14:16,430
process and tries to access the system

00:14:15,410 --> 00:14:18,170
and make some changes

00:14:16,430 --> 00:14:19,940
a salinas will come in the way and

00:14:18,170 --> 00:14:21,589
prevent it because this is an additional

00:14:19,940 --> 00:14:24,649
layer of protection it's a jail around

00:14:21,589 --> 00:14:26,329
the container now how do we protect one

00:14:24,649 --> 00:14:28,250
container from another container there

00:14:26,329 --> 00:14:31,130
is another technology called multi

00:14:28,250 --> 00:14:34,310
category security mcs for short which

00:14:31,130 --> 00:14:37,130
assigns a unique random level to each

00:14:34,310 --> 00:14:39,529
container process using which a specific

00:14:37,130 --> 00:14:41,540
container can only access its own

00:14:39,529 --> 00:14:43,790
resources not somebody else's resources

00:14:41,540 --> 00:14:45,589
right this is how containers are

00:14:43,790 --> 00:14:47,779
protected with each other so esse Linux

00:14:45,589 --> 00:14:50,510
protects system resources from the

00:14:47,779 --> 00:14:52,880
container processes and meta category

00:14:50,510 --> 00:14:55,160
security in association with SL NS will

00:14:52,880 --> 00:14:59,540
provide will protect containers from

00:14:55,160 --> 00:15:02,750
each other so I will be sharing this

00:14:59,540 --> 00:15:04,730
presentation later but if you want to

00:15:02,750 --> 00:15:07,370
take a photograph I will wait for a few

00:15:04,730 --> 00:15:09,680
seconds right this is a very good book

00:15:07,370 --> 00:15:20,510
where you can learn in detail about a

00:15:09,680 --> 00:15:22,610
syllabus all right moving on Linux

00:15:20,510 --> 00:15:25,160
capabilities this is another thing that

00:15:22,610 --> 00:15:30,380
we need to be aware of at the operating

00:15:25,160 --> 00:15:33,379
system level the route if you say I have

00:15:30,380 --> 00:15:36,979
a root user write with

00:15:33,379 --> 00:15:39,049
Linux kernel 2.2 root privileges are

00:15:36,979 --> 00:15:40,369
divided into thirty two distinct

00:15:39,049 --> 00:15:44,149
capabilities now actually it is

00:15:40,369 --> 00:15:48,379
increased to 37 now these capabilities

00:15:44,149 --> 00:15:50,659
are the ones that a root user with all

00:15:48,379 --> 00:15:54,319
the capabilities enable is actually a

00:15:50,659 --> 00:15:56,059
root in in in the Linux today right but

00:15:54,319 --> 00:15:57,769
out of all these keep already certain

00:15:56,059 --> 00:16:00,739
capabilities are extremely dangerous

00:15:57,769 --> 00:16:03,229
like Nick admin which allows you to

00:16:00,739 --> 00:16:05,299
configure the network status admin this

00:16:03,229 --> 00:16:07,069
is more or less like getting the root

00:16:05,299 --> 00:16:09,379
access right these are there are some

00:16:07,069 --> 00:16:11,569
powerful capabilities so when it comes

00:16:09,379 --> 00:16:13,579
to running the containers it becomes

00:16:11,569 --> 00:16:15,709
very important in terms of what

00:16:13,579 --> 00:16:18,109
capabilities is that container running

00:16:15,709 --> 00:16:21,409
with so the process that is run in the

00:16:18,109 --> 00:16:23,809
container with what user ID is it

00:16:21,409 --> 00:16:25,519
running and what what is it allowed to

00:16:23,809 --> 00:16:28,279
do the default capabilities that are

00:16:25,519 --> 00:16:32,829
available to a container are extremely

00:16:28,279 --> 00:16:35,779
important so when docker container was a

00:16:32,829 --> 00:16:38,779
build with this this is overview of time

00:16:35,779 --> 00:16:41,629
right so 14 default capabilities were

00:16:38,779 --> 00:16:44,299
made available in a docker container now

00:16:41,629 --> 00:16:45,739
the ones that you are seeing on the

00:16:44,299 --> 00:16:49,269
screen are those 14 different

00:16:45,739 --> 00:16:52,519
capabilities having said that these

00:16:49,269 --> 00:16:55,549
these are made very generic so that any

00:16:52,519 --> 00:16:57,619
container can run without any issues

00:16:55,549 --> 00:16:59,419
right but do we really need all these

00:16:57,619 --> 00:17:01,669
putting different capabilities so for

00:16:59,419 --> 00:17:04,339
example look at that audit right where

00:17:01,669 --> 00:17:07,610
you can write messages to audit log

00:17:04,339 --> 00:17:11,269
right the audit subsystem this was

00:17:07,610 --> 00:17:13,579
enable - so that you can actually run an

00:17:11,269 --> 00:17:15,500
SSH daemon daemon inside the container

00:17:13,579 --> 00:17:17,569
because in the initial days they thought

00:17:15,500 --> 00:17:19,939
that it's a set you would want to SSH

00:17:17,569 --> 00:17:21,740
into a container but eventually you

00:17:19,939 --> 00:17:25,309
don't need a need that actually you can

00:17:21,740 --> 00:17:27,620
use for example docker exact or Godman

00:17:25,309 --> 00:17:29,990
except to get into the container attack

00:17:27,620 --> 00:17:33,590
it is actually it is awfully it actually

00:17:29,990 --> 00:17:35,210
not encouraged to have our nobody runs

00:17:33,590 --> 00:17:37,610
as such a demon inside the container off

00:17:35,210 --> 00:17:40,029
right so that capability can easily be

00:17:37,610 --> 00:17:42,649
disabled so having unnecessary

00:17:40,029 --> 00:17:44,029
capabilities enabled is it is a problem

00:17:42,649 --> 00:17:45,889
so one of the things you didn't to be

00:17:44,029 --> 00:17:46,790
thinking about is when I am running on a

00:17:45,889 --> 00:17:49,190
container plot

00:17:46,790 --> 00:17:52,510
the tools that are coming with the

00:17:49,190 --> 00:17:54,860
platform do they allow me to and

00:17:52,510 --> 00:17:57,260
completely disable all the capabilities

00:17:54,860 --> 00:17:59,300
and only add those capabilities that are

00:17:57,260 --> 00:18:01,460
needed by my container right that's a

00:17:59,300 --> 00:18:04,610
thing you need to keep in mind so for

00:18:01,460 --> 00:18:06,160
example Ford Man is a tool this is also

00:18:04,610 --> 00:18:08,270
allowed with docker where you can

00:18:06,160 --> 00:18:10,900
specifically enable particular

00:18:08,270 --> 00:18:15,440
capability the capabilities with Quebec

00:18:10,900 --> 00:18:17,140
if you are building a container using a

00:18:15,440 --> 00:18:19,580
docker file you can actually

00:18:17,140 --> 00:18:21,350
specifically specifically say that these

00:18:19,580 --> 00:18:24,260
capabilities are enabled for my

00:18:21,350 --> 00:18:26,000
container by labeling that by adding a

00:18:24,260 --> 00:18:28,850
label dot IO dot containers to our

00:18:26,000 --> 00:18:31,760
capabilities right so when your

00:18:28,850 --> 00:18:33,290
container gets built it will ask for

00:18:31,760 --> 00:18:35,510
those specific capabilities to be

00:18:33,290 --> 00:18:37,310
enabled so you can specifically declare

00:18:35,510 --> 00:18:38,990
which capabilities are needed all other

00:18:37,310 --> 00:18:42,680
capabilities can be disabled when you

00:18:38,990 --> 00:18:46,880
are on here and the next thing the

00:18:42,680 --> 00:18:48,830
system calls so your container is a

00:18:46,880 --> 00:18:53,600
process and every process as you know

00:18:48,830 --> 00:18:55,970
makes the system cause now which calls

00:18:53,600 --> 00:18:58,940
are allowed from your container to the

00:18:55,970 --> 00:19:02,180
system that that also has important

00:18:58,940 --> 00:19:05,900
implications on security so you can use

00:19:02,180 --> 00:19:09,710
Berkley packet filter system BPF right

00:19:05,900 --> 00:19:12,410
to filter those cause that are not

00:19:09,710 --> 00:19:15,710
really required right but how do I apply

00:19:12,410 --> 00:19:17,600
that that's where the SiC comp profiles

00:19:15,710 --> 00:19:20,360
come into play when you are running your

00:19:17,600 --> 00:19:22,340
container you can tell that container

00:19:20,360 --> 00:19:25,220
that it is running with so and so second

00:19:22,340 --> 00:19:27,710
profile so that only those calls that

00:19:25,220 --> 00:19:29,870
are allowed by that profile are allowed

00:19:27,710 --> 00:19:32,450
to go into the system now next question

00:19:29,870 --> 00:19:34,700
from your psyche would be how do I know

00:19:32,450 --> 00:19:36,620
which cause which system calls should be

00:19:34,700 --> 00:19:38,570
allowed by this container this will

00:19:36,620 --> 00:19:41,060
become the responsibility I mean this is

00:19:38,570 --> 00:19:42,770
still work in progress but this is this

00:19:41,060 --> 00:19:45,800
will become the responsibility of a

00:19:42,770 --> 00:19:48,320
container developer so the developer

00:19:45,800 --> 00:19:50,390
after building their container would

00:19:48,320 --> 00:19:53,090
when they are testing one of the things

00:19:50,390 --> 00:19:54,950
that they can test is use a second

00:19:53,090 --> 00:19:56,990
filter generator there are tools like

00:19:54,950 --> 00:19:59,450
that which are being being built and

00:19:56,990 --> 00:20:00,820
using this generator you can let's say

00:19:59,450 --> 00:20:03,279
you you district

00:20:00,820 --> 00:20:07,360
all possible news cases right and you

00:20:03,279 --> 00:20:10,179
see what sis calls are being made by

00:20:07,360 --> 00:20:12,460
this container you capture those and you

00:20:10,179 --> 00:20:15,039
create a profile out of it a second

00:20:12,460 --> 00:20:18,250
profile and provide that profile along

00:20:15,039 --> 00:20:19,630
with your container now view and you're

00:20:18,250 --> 00:20:22,059
running your container along with a

00:20:19,630 --> 00:20:24,250
second profile only those specific calls

00:20:22,059 --> 00:20:26,320
that you said are should be allowed are

00:20:24,250 --> 00:20:28,539
allowed now how is that going to help

00:20:26,320 --> 00:20:30,190
let's say if a hacker gets into a

00:20:28,539 --> 00:20:32,500
container and takes hold of your

00:20:30,190 --> 00:20:35,080
container and if the hacker is trying to

00:20:32,500 --> 00:20:37,240
make system pass to the kernel and

00:20:35,080 --> 00:20:40,480
trying to get hold of the kernel right

00:20:37,240 --> 00:20:43,240
that will not happen because your second

00:20:40,480 --> 00:20:45,909
profile will prevent unnecessary cause

00:20:43,240 --> 00:20:47,980
system calls from going going from your

00:20:45,909 --> 00:20:50,139
container process to the kernel right

00:20:47,980 --> 00:20:51,879
that's how that will be prevented so you

00:20:50,139 --> 00:20:54,340
need to be thinking about which

00:20:51,879 --> 00:20:57,250
container platforms would allow me to

00:20:54,340 --> 00:20:58,840
supply my own sick calm profile when I'm

00:20:57,250 --> 00:21:00,690
running my containers this this is

00:20:58,840 --> 00:21:02,980
important when you are actually running

00:21:00,690 --> 00:21:07,509
applications especially in secure

00:21:02,980 --> 00:21:10,899
environments next read only mode points

00:21:07,509 --> 00:21:12,850
operating system has several mount

00:21:10,899 --> 00:21:15,610
points which are actually required where

00:21:12,850 --> 00:21:18,250
your containers to continue environment

00:21:15,610 --> 00:21:20,019
to run but fortunately these most of

00:21:18,250 --> 00:21:22,899
these can be mounted as read-only and

00:21:20,019 --> 00:21:24,909
there are platforms that will prevent

00:21:22,899 --> 00:21:26,730
they'll block the ability of your

00:21:24,909 --> 00:21:28,990
privilege continuous processes from

00:21:26,730 --> 00:21:30,519
remounting these file systems are as

00:21:28,990 --> 00:21:31,750
read/write so for example if you're

00:21:30,519 --> 00:21:33,549
running a continued process as a

00:21:31,750 --> 00:21:36,039
privileged container and some if someone

00:21:33,549 --> 00:21:37,210
hacks hacks it they may be able to go

00:21:36,039 --> 00:21:38,980
and change it

00:21:37,210 --> 00:21:40,990
remount that file system to read right

00:21:38,980 --> 00:21:45,279
right so some problems like openshift

00:21:40,990 --> 00:21:47,200
will stop you from doing that so you

00:21:45,279 --> 00:21:49,120
need to be aware of that as well so so

00:21:47,200 --> 00:21:51,669
far we talked about different things

00:21:49,120 --> 00:21:53,679
that are relevant from the host

00:21:51,669 --> 00:21:55,299
operating system perspective only what

00:21:53,679 --> 00:21:57,820
what do you need to keep in mind right

00:21:55,299 --> 00:22:02,110
now let's get into the build time

00:21:57,820 --> 00:22:03,879
security so from bin perspective what is

00:22:02,110 --> 00:22:05,860
included inside your container is

00:22:03,879 --> 00:22:07,539
extremely important right so what is

00:22:05,860 --> 00:22:09,309
your container made up off and where the

00:22:07,539 --> 00:22:11,559
continual transit so we talked about the

00:22:09,309 --> 00:22:14,100
host operating system your container

00:22:11,559 --> 00:22:16,169
itself includes some operating system

00:22:14,100 --> 00:22:18,929
your container runtimes and then comes

00:22:16,169 --> 00:22:20,549
your application so if if there is an

00:22:18,929 --> 00:22:22,080
application developer the application

00:22:20,549 --> 00:22:23,610
developer is just writing their code

00:22:22,080 --> 00:22:25,980
they may be writing the code in whatever

00:22:23,610 --> 00:22:28,080
language they are doing no J's or Java

00:22:25,980 --> 00:22:29,820
or whatever that is right they only know

00:22:28,080 --> 00:22:33,090
about that but they don't know about

00:22:29,820 --> 00:22:34,500
other layers of the container that they

00:22:33,090 --> 00:22:38,429
are using to deploy that application

00:22:34,500 --> 00:22:42,090
into so am I getting these container

00:22:38,429 --> 00:22:44,100
images with which I am providing to my

00:22:42,090 --> 00:22:46,770
developers on my developer is using this

00:22:44,100 --> 00:22:49,710
container images are these images coming

00:22:46,770 --> 00:22:52,140
from trusted sources that's something

00:22:49,710 --> 00:22:56,299
that's extremely important are these

00:22:52,140 --> 00:22:59,190
containers that are running running on a

00:22:56,299 --> 00:23:01,350
non-clustered platform which includes

00:22:59,190 --> 00:23:02,490
has clustered host operating system we

00:23:01,350 --> 00:23:05,010
already talked about the host operating

00:23:02,490 --> 00:23:06,659
system right so that becomes extremely

00:23:05,010 --> 00:23:09,570
important on where you source your

00:23:06,659 --> 00:23:12,149
container images from the base container

00:23:09,570 --> 00:23:14,510
images from where you will add your

00:23:12,149 --> 00:23:20,039
application code on the top of right

00:23:14,510 --> 00:23:22,620
then then it's not just the first time

00:23:20,039 --> 00:23:24,679
thing right your container images that

00:23:22,620 --> 00:23:28,169
you are getting from those known sources

00:23:24,679 --> 00:23:30,809
are those sources also exposing or

00:23:28,169 --> 00:23:33,450
providing some kind of a health index

00:23:30,809 --> 00:23:37,950
because the vulnerabilities can change

00:23:33,450 --> 00:23:39,990
everyday you are not if the container is

00:23:37,950 --> 00:23:41,610
secure today that doesn't mean that it

00:23:39,990 --> 00:23:45,690
is secure tomorrow right there may be

00:23:41,610 --> 00:23:48,120
newer issues new vulnerabilities so is

00:23:45,690 --> 00:23:50,399
the source that is providing you this

00:23:48,120 --> 00:23:53,039
container images also providing a health

00:23:50,399 --> 00:23:55,140
index they are they measuring the issues

00:23:53,039 --> 00:23:57,630
that are this the vulnerabilities that

00:23:55,140 --> 00:24:00,899
are available on D to be delayed day to

00:23:57,630 --> 00:24:03,270
day basis and showing you with the

00:24:00,899 --> 00:24:05,700
container health indexes right so that's

00:24:03,270 --> 00:24:08,090
also important so when you choose a

00:24:05,700 --> 00:24:10,770
source you also think about other

00:24:08,090 --> 00:24:14,130
sources clearly telling me what kind of

00:24:10,770 --> 00:24:15,840
security data is available around these

00:24:14,130 --> 00:24:17,750
containers and how it is changing on a

00:24:15,840 --> 00:24:22,830
day to day basis

00:24:17,750 --> 00:24:24,750
third prominence of an image so is is

00:24:22,830 --> 00:24:27,299
where is this image coming from who

00:24:24,750 --> 00:24:30,649
created it is the image

00:24:27,299 --> 00:24:33,330
signed by the source that has created

00:24:30,649 --> 00:24:35,279
right these are all important because

00:24:33,330 --> 00:24:38,549
you need to know where this container

00:24:35,279 --> 00:24:40,350
the complete prominence of the image not

00:24:38,549 --> 00:24:43,019
just that you also should have the

00:24:40,350 --> 00:24:44,460
ability to sign the image and the

00:24:43,019 --> 00:24:46,619
platform on which you are running the

00:24:44,460 --> 00:24:48,389
container should be able to verify that

00:24:46,619 --> 00:24:51,239
image and run only trusted containers

00:24:48,389 --> 00:24:53,879
right so does the platform support all

00:24:51,239 --> 00:24:57,330
these features that's another thing to

00:24:53,879 --> 00:25:00,779
keep in mind so what you're seeing here

00:24:57,330 --> 00:25:05,090
is an example of how you can use tools

00:25:00,779 --> 00:25:05,090
like pod Man to sign in/sign a container

00:25:05,840 --> 00:25:14,129
private registries when you create the

00:25:11,129 --> 00:25:15,690
containers and you use the containers in

00:25:14,129 --> 00:25:19,859
your enterprise you may not be actually

00:25:15,690 --> 00:25:21,779
willing to push your IP your container

00:25:19,859 --> 00:25:25,980
images for your applications into a

00:25:21,779 --> 00:25:27,869
public registry right so how do I what

00:25:25,980 --> 00:25:30,950
kind of private registries am I going to

00:25:27,869 --> 00:25:33,899
use can I set up my own Enterprise

00:25:30,950 --> 00:25:38,940
registry how do I ensure that the

00:25:33,899 --> 00:25:41,730
registry is always up I'm how can can I

00:25:38,940 --> 00:25:43,799
use both a private registry that that I

00:25:41,730 --> 00:25:49,019
can install within my Enterprise as well

00:25:43,799 --> 00:25:52,109
as some private private section of the

00:25:49,019 --> 00:25:53,759
registry on a on a public resource

00:25:52,109 --> 00:25:56,249
things like that things that you need to

00:25:53,759 --> 00:26:00,419
keep in mind in terms of how where do I

00:25:56,249 --> 00:26:02,279
save my container images and what kind

00:26:00,419 --> 00:26:04,080
of registry I am I'm using what kind of

00:26:02,279 --> 00:26:05,519
features are available in these

00:26:04,080 --> 00:26:07,799
registries there are different kinds of

00:26:05,519 --> 00:26:10,950
private registers that are possible so

00:26:07,799 --> 00:26:12,259
you have choices to choose from but you

00:26:10,950 --> 00:26:15,299
would want to evaluate different

00:26:12,259 --> 00:26:17,480
registry technologies and and make those

00:26:15,299 --> 00:26:17,480
choices

00:26:19,580 --> 00:26:35,159
next just want to make sure that there

00:26:23,759 --> 00:26:37,580
are no issues ok restricting the

00:26:35,159 --> 00:26:40,289
registry sources so you have the

00:26:37,580 --> 00:26:40,920
developers who are using your container

00:26:40,289 --> 00:26:43,590
platform

00:26:40,920 --> 00:26:45,600
and they are using this technologies the

00:26:43,590 --> 00:26:48,560
container images could be stored

00:26:45,600 --> 00:26:52,320
anywhere right can you can your platform

00:26:48,560 --> 00:26:55,040
stop the developers from pulling images

00:26:52,320 --> 00:26:59,760
from wherever they want can you actually

00:26:55,040 --> 00:27:01,320
specify the registries that are that are

00:26:59,760 --> 00:27:03,150
allowed and the registries that are

00:27:01,320 --> 00:27:05,430
blocked in your container platform

00:27:03,150 --> 00:27:07,860
that's also important so when you are

00:27:05,430 --> 00:27:10,380
evaluating a container platform keep

00:27:07,860 --> 00:27:13,890
this in mind on whether I am able to

00:27:10,380 --> 00:27:15,570
restrict or or block the registries that

00:27:13,890 --> 00:27:19,500
I don't want my developers to pull

00:27:15,570 --> 00:27:23,550
images from image management

00:27:19,500 --> 00:27:25,830
responsibilities so I have who best what

00:27:23,550 --> 00:27:30,060
in in the world of container platform so

00:27:25,830 --> 00:27:31,940
I have my operations team my

00:27:30,060 --> 00:27:35,850
infrastructure administrators who are

00:27:31,940 --> 00:27:38,730
who have been controlling the trusted

00:27:35,850 --> 00:27:41,010
base images for the operating system can

00:27:38,730 --> 00:27:43,950
they continue to do that right can they

00:27:41,010 --> 00:27:49,320
can they be the people who choose the OS

00:27:43,950 --> 00:27:51,540
layer off of my containers second my

00:27:49,320 --> 00:27:53,520
middleware engineering team are the ones

00:27:51,540 --> 00:27:56,160
who decide what kind of middleware is

00:27:53,520 --> 00:27:59,190
appropriate for use in mind price can

00:27:56,160 --> 00:28:00,930
they continue to choose that can they be

00:27:59,190 --> 00:28:04,020
actually building tools and technologies

00:28:00,930 --> 00:28:05,730
to build the containers that the

00:28:04,020 --> 00:28:07,530
developers would create so developers

00:28:05,730 --> 00:28:10,770
are just writing the code how is that

00:28:07,530 --> 00:28:13,080
code getting compiled and built into a

00:28:10,770 --> 00:28:16,530
container can that process be predefined

00:28:13,080 --> 00:28:18,930
in the world of open shift and Red Hat

00:28:16,530 --> 00:28:21,930
we call that source to image process and

00:28:18,930 --> 00:28:23,910
there are there are build processes that

00:28:21,930 --> 00:28:26,130
are available with many different

00:28:23,910 --> 00:28:28,650
technologies and controlling that build

00:28:26,130 --> 00:28:31,710
process is extremely important and who

00:28:28,650 --> 00:28:35,040
does that can that be can that be

00:28:31,710 --> 00:28:37,740
defined in an enterprise-wide way so

00:28:35,040 --> 00:28:39,330
that it can be done in a secured fashion

00:28:37,740 --> 00:28:41,730
can the will happen in a secure fashion

00:28:39,330 --> 00:28:44,280
in a controlled fashion right that's

00:28:41,730 --> 00:28:47,400
that's important and who does that

00:28:44,280 --> 00:28:50,070
middleware engineering team development

00:28:47,400 --> 00:28:51,570
team would be only worried about writing

00:28:50,070 --> 00:28:53,010
their code that meets the business

00:28:51,570 --> 00:28:54,040
requirements the business use cases

00:28:53,010 --> 00:28:57,190
right so that

00:28:54,040 --> 00:29:00,070
the topmost layer so they will be

00:28:57,190 --> 00:29:02,800
ensuring that the core is clean there

00:29:00,070 --> 00:29:04,990
are no new static code analysis of their

00:29:02,800 --> 00:29:08,380
own written code and all that so if we

00:29:04,990 --> 00:29:10,510
can divide the responsibilities of the

00:29:08,380 --> 00:29:13,120
container image itself which layer comes

00:29:10,510 --> 00:29:16,600
from or which layer is managed by which

00:29:13,120 --> 00:29:19,540
team that and and if the platform allows

00:29:16,600 --> 00:29:21,460
you to make those images available so

00:29:19,540 --> 00:29:23,110
that the developers can consume easily

00:29:21,460 --> 00:29:25,720
for example if they are building a

00:29:23,110 --> 00:29:27,910
spring good application can the spring

00:29:25,720 --> 00:29:33,540
boot trusted image we made available

00:29:27,910 --> 00:29:36,430
inside a catalog in my in my Enterprise

00:29:33,540 --> 00:29:40,300
Service Catalog so that I can pull that

00:29:36,430 --> 00:29:42,190
image and write my java code add that

00:29:40,300 --> 00:29:44,560
layer on the top of that image and then

00:29:42,190 --> 00:29:46,600
deployed right if that is the kind of

00:29:44,560 --> 00:29:49,300
experience developers can get that's the

00:29:46,600 --> 00:29:50,950
best to look for rather than expecting

00:29:49,300 --> 00:29:53,220
the developers to build everything from

00:29:50,950 --> 00:29:56,470
bottom to top inside a container right

00:29:53,220 --> 00:29:58,440
so that's another thing to keep in mind

00:29:56,470 --> 00:30:01,930
from the build time security perspective

00:29:58,440 --> 00:30:05,710
now let's move on to continuous scanning

00:30:01,930 --> 00:30:08,560
identifying vulnerabilities so from

00:30:05,710 --> 00:30:10,570
scanning perspective think about when do

00:30:08,560 --> 00:30:14,080
I scan containers for vulnerabilities

00:30:10,570 --> 00:30:17,200
what should be the frequency there are

00:30:14,080 --> 00:30:19,960
different ways of doing it and multiple

00:30:17,200 --> 00:30:21,250
waves are important so you want to scan

00:30:19,960 --> 00:30:22,570
your containers as soon as they are

00:30:21,250 --> 00:30:24,550
created because if there are any

00:30:22,570 --> 00:30:26,350
vulnerabilities you would want to fix

00:30:24,550 --> 00:30:28,930
them even before the container gets into

00:30:26,350 --> 00:30:31,810
the next cycle of testing let's say from

00:30:28,930 --> 00:30:33,760
development scan containers that get

00:30:31,810 --> 00:30:35,800
into enterprise registry there are

00:30:33,760 --> 00:30:38,920
technologies that are available today's

00:30:35,800 --> 00:30:40,630
day where you push your image into a

00:30:38,920 --> 00:30:42,400
container registry and as soon as it

00:30:40,630 --> 00:30:45,580
gets pushed it gets scanned immediately

00:30:42,400 --> 00:30:47,320
you can also set up that scanner to run

00:30:45,580 --> 00:30:49,330
every once in a while to identify any

00:30:47,320 --> 00:30:51,070
new vulnerabilities or a period of time

00:30:49,330 --> 00:30:53,500
ongoing basis how do I identify

00:30:51,070 --> 00:30:55,420
vulnerabilities for my running

00:30:53,500 --> 00:30:57,670
application on my platform these are

00:30:55,420 --> 00:30:59,650
different things to keep in mind in

00:30:57,670 --> 00:31:01,480
terms of when to identify

00:30:59,650 --> 00:31:02,620
vulnerabilities if there are new orlean

00:31:01,480 --> 00:31:05,500
abilities that I didn't know about

00:31:02,620 --> 00:31:07,870
yesterday how do i how do I figure that

00:31:05,500 --> 00:31:09,550
out how do I stop a

00:31:07,870 --> 00:31:12,490
vacations that are vulnerable from

00:31:09,550 --> 00:31:16,090
running interruption if I if it has to

00:31:12,490 --> 00:31:18,220
right things like that so scanning

00:31:16,090 --> 00:31:20,290
containers at the time of creation so

00:31:18,220 --> 00:31:22,840
what you are seeing right now is an

00:31:20,290 --> 00:31:25,990
example of a pipeline right so you have

00:31:22,840 --> 00:31:28,059
for example you may be doing a build

00:31:25,990 --> 00:31:29,800
process where you are building the

00:31:28,059 --> 00:31:32,260
artifacts and then saving those

00:31:29,800 --> 00:31:33,790
artifacts and you are pulling the source

00:31:32,260 --> 00:31:35,950
code from the git repo building the

00:31:33,790 --> 00:31:39,309
artifacts and you archive the artifacts

00:31:35,950 --> 00:31:45,070
into a into an artifact repository like

00:31:39,309 --> 00:31:48,730
Nexus and maybe after that you do the

00:31:45,070 --> 00:31:52,480
unit testing and static code analysis

00:31:48,730 --> 00:31:54,700
maybe after that you do a build of a

00:31:52,480 --> 00:31:57,580
container as soon as the container gets

00:31:54,700 --> 00:31:59,679
built you may be deploying that into a

00:31:57,580 --> 00:32:01,179
development environment but before that

00:31:59,679 --> 00:32:03,790
you may be actually pushing that into a

00:32:01,179 --> 00:32:06,400
registry as soon as that it gets pushed

00:32:03,790 --> 00:32:09,550
into a registry registry is like Red

00:32:06,400 --> 00:32:12,010
Hat's Quay have tools like clave scanner

00:32:09,550 --> 00:32:13,780
which will go and run the scanning on

00:32:12,010 --> 00:32:15,100
the top of it and identify if there are

00:32:13,780 --> 00:32:18,910
any vulnerabilities and show you

00:32:15,100 --> 00:32:21,130
directly eventually in the build process

00:32:18,910 --> 00:32:22,780
before once you are done with testing

00:32:21,130 --> 00:32:25,000
before you actually move it into the

00:32:22,780 --> 00:32:28,030
next environment you may actually want

00:32:25,000 --> 00:32:30,280
to scan that image to identify any

00:32:28,030 --> 00:32:32,200
vulnerabilities with other kind of

00:32:30,280 --> 00:32:34,809
scanning tools it could be open scab

00:32:32,200 --> 00:32:41,280
scanning it could be scanners coming

00:32:34,809 --> 00:32:45,820
with the tools like j4r x-ray or or

00:32:41,280 --> 00:32:47,500
black dot called chrislam right there

00:32:45,820 --> 00:32:51,090
are many technologies available today

00:32:47,500 --> 00:32:55,120
that come with their own repositories of

00:32:51,090 --> 00:32:58,120
the vulnerabilities and issues that are

00:32:55,120 --> 00:33:00,580
possible in open source and the scanners

00:32:58,120 --> 00:33:03,309
can go against those registries and scan

00:33:00,580 --> 00:33:05,350
and provide you a report of what kind of

00:33:03,309 --> 00:33:07,929
issues can exist in your code right I

00:33:05,350 --> 00:33:09,400
mean that with that container and when

00:33:07,929 --> 00:33:11,230
you are happy with that that's when it

00:33:09,400 --> 00:33:15,400
gets into the next stage of life cycle

00:33:11,230 --> 00:33:18,610
where it goes from from dev to QA for

00:33:15,400 --> 00:33:20,770
example so you can incorporate scanning

00:33:18,610 --> 00:33:21,590
as part of your registry you can

00:33:20,770 --> 00:33:23,659
incorporate

00:33:21,590 --> 00:33:28,039
scanning as part as part of your

00:33:23,659 --> 00:33:30,080
pipeline itself there are different

00:33:28,039 --> 00:33:31,400
kinds of scanning tools available in the

00:33:30,080 --> 00:33:34,760
market today

00:33:31,400 --> 00:33:38,140
cleared for example is an open source

00:33:34,760 --> 00:33:41,990
scanner that comes with Red Hat's Quay

00:33:38,140 --> 00:33:44,779
black duck is black that Jeff rock x-ray

00:33:41,990 --> 00:33:47,059
a twist lock cystic all these different

00:33:44,779 --> 00:33:49,760
tool vendors provide their own container

00:33:47,059 --> 00:33:52,309
scanning solutions these technologies

00:33:49,760 --> 00:33:54,289
not only scan when you want it to scan

00:33:52,309 --> 00:33:56,090
but they are also running on the

00:33:54,289 --> 00:33:57,799
platform on a kubernetes platform all

00:33:56,090 --> 00:34:00,679
the time and they are continuously

00:33:57,799 --> 00:34:02,600
scanning against the known

00:34:00,679 --> 00:34:04,250
vulnerabilities at any point of time and

00:34:02,600 --> 00:34:09,050
they can report if there are issues at

00:34:04,250 --> 00:34:12,710
any point of time let's move on to the

00:34:09,050 --> 00:34:16,450
next sting what else can we expect from

00:34:12,710 --> 00:34:20,659
container platforms so one of the things

00:34:16,450 --> 00:34:26,119
is policy-based godness there are tools

00:34:20,659 --> 00:34:28,010
for example red hats ECM advanced

00:34:26,119 --> 00:34:30,080
cluster management tool includes

00:34:28,010 --> 00:34:32,470
features where you can do policy based

00:34:30,080 --> 00:34:35,780
governance and risk and compliance

00:34:32,470 --> 00:34:37,310
monitoring from a central tool this ECM

00:34:35,780 --> 00:34:39,500
has features to manage multiple

00:34:37,310 --> 00:34:41,659
kubernetes clusters from a single

00:34:39,500 --> 00:34:45,139
location and at the same time you can

00:34:41,659 --> 00:34:47,839
also enforce policies you can say

00:34:45,139 --> 00:34:51,500
cluster number one will have to meet so

00:34:47,839 --> 00:34:53,570
in source policy standard and at that

00:34:51,500 --> 00:34:55,369
point of time from that point of time

00:34:53,570 --> 00:34:58,010
that custer cluster will be configured

00:34:55,369 --> 00:35:01,339
to meet that that compliance policy and

00:34:58,010 --> 00:35:02,750
if there are any issues this tool can

00:35:01,339 --> 00:35:05,150
show you from a centralized location

00:35:02,750 --> 00:35:06,680
right these are kind of additional

00:35:05,150 --> 00:35:10,580
features that some of the container

00:35:06,680 --> 00:35:12,010
platforms will provide you from the

00:35:10,580 --> 00:35:14,930
authentication and authorization

00:35:12,010 --> 00:35:17,869
perspective we all know that kubernetes

00:35:14,930 --> 00:35:21,710
includes an OAuth server which with

00:35:17,869 --> 00:35:24,470
which you can integrate with well-known

00:35:21,710 --> 00:35:27,770
other identity providers outside

00:35:24,470 --> 00:35:29,630
these include LDAP did have it lab

00:35:27,770 --> 00:35:32,300
Google authentication any of those

00:35:29,630 --> 00:35:35,000
sources right so you would want to do

00:35:32,300 --> 00:35:38,000
the authentication with your

00:35:35,000 --> 00:35:41,090
authentication identity provider so that

00:35:38,000 --> 00:35:44,140
the authentication is delegated to those

00:35:41,090 --> 00:35:47,450
identity providers and for authorization

00:35:44,140 --> 00:35:51,700
kubernetes includes authorization by

00:35:47,450 --> 00:35:54,590
using rule bindings at the individual

00:35:51,700 --> 00:35:59,300
namespace level as well as as the at the

00:35:54,590 --> 00:36:01,730
cluster level so when community is the

00:35:59,300 --> 00:36:03,470
containers will in in the part they run

00:36:01,730 --> 00:36:05,660
with they're all assigned to a specific

00:36:03,470 --> 00:36:08,240
user called a service account this

00:36:05,660 --> 00:36:10,160
service account concept was initially

00:36:08,240 --> 00:36:12,859
there in in openshift

00:36:10,160 --> 00:36:15,470
and eventually it got pushed into

00:36:12,859 --> 00:36:18,260
kubernetes as well so make use of this

00:36:15,470 --> 00:36:20,240
feature where you can control which

00:36:18,260 --> 00:36:23,000
particular service account can do what

00:36:20,240 --> 00:36:25,960
on your cluster right that way you can

00:36:23,000 --> 00:36:28,700
set authorization settings to control

00:36:25,960 --> 00:36:31,840
what a service of a specific container

00:36:28,700 --> 00:36:34,400
can do and what it is not allowed to do

00:36:31,840 --> 00:36:38,450
there is another thing that got added

00:36:34,400 --> 00:36:41,800
into kubernetes called for security

00:36:38,450 --> 00:36:44,599
policies this was done last year and the

00:36:41,800 --> 00:36:47,660
this comes from the root of this comes

00:36:44,599 --> 00:36:49,970
from a security context constraints this

00:36:47,660 --> 00:36:51,800
again this is a feature that has been

00:36:49,970 --> 00:36:56,690
been there in open shipped for many

00:36:51,800 --> 00:37:00,080
years and eventually reached a part of

00:36:56,690 --> 00:37:04,160
it is now part of kubernetes called for

00:37:00,080 --> 00:37:06,440
security policies make use of this

00:37:04,160 --> 00:37:09,170
because this will allow you to your

00:37:06,440 --> 00:37:11,540
administrator to set up policies in such

00:37:09,170 --> 00:37:14,420
a way that a container when it comes up

00:37:11,540 --> 00:37:16,160
by default you don't want your container

00:37:14,420 --> 00:37:18,230
to have privileged access that you want

00:37:16,160 --> 00:37:20,450
you want very very restricted access to

00:37:18,230 --> 00:37:23,180
you and for your container and if

00:37:20,450 --> 00:37:25,580
required yeah that means you can

00:37:23,180 --> 00:37:27,500
alleviate the security as long as you

00:37:25,580 --> 00:37:30,020
justify on why your container would need

00:37:27,500 --> 00:37:32,450
some specific additional permissions so

00:37:30,020 --> 00:37:34,609
for example in case of security context

00:37:32,450 --> 00:37:38,020
constraints there are different kinds of

00:37:34,609 --> 00:37:40,250
SS SCC is available the default is

00:37:38,020 --> 00:37:43,940
restricted in an open shipped cluster

00:37:40,250 --> 00:37:45,770
and if you want to with restricted if

00:37:43,940 --> 00:37:48,390
let's say you are trying to run a

00:37:45,770 --> 00:37:50,700
container that requires to run as a rule

00:37:48,390 --> 00:37:53,789
that container will not even come up the

00:37:50,700 --> 00:37:56,579
container platform which SCC is

00:37:53,789 --> 00:37:58,049
restricted by default will not allow a

00:37:56,579 --> 00:38:00,930
container that is running as a

00:37:58,049 --> 00:38:04,049
privileged user to come up at all if you

00:38:00,930 --> 00:38:05,849
have a proper reason that you can go and

00:38:04,049 --> 00:38:07,470
justify with your cluster administrator

00:38:05,849 --> 00:38:09,299
then the cluster administrator will

00:38:07,470 --> 00:38:12,119
verify that and would be able to change

00:38:09,299 --> 00:38:15,660
the ACC for US service account with

00:38:12,119 --> 00:38:17,400
which your pod is running to a different

00:38:15,660 --> 00:38:20,519
level so for example if you want to run

00:38:17,400 --> 00:38:22,349
the your container has privileged then

00:38:20,519 --> 00:38:25,650
he can any if again if you can justify

00:38:22,349 --> 00:38:27,569
it then the administrator can change the

00:38:25,650 --> 00:38:30,720
service accounts SEC has privileged

00:38:27,569 --> 00:38:32,730
right that way there is a control way of

00:38:30,720 --> 00:38:35,130
elevating the privileges for those

00:38:32,730 --> 00:38:39,510
specific poor clothes that you can just

00:38:35,130 --> 00:38:41,519
define now let's talk about application

00:38:39,510 --> 00:38:44,519
level security where applications are

00:38:41,519 --> 00:38:47,279
running s containers you can do micro

00:38:44,519 --> 00:38:49,589
segmentation by using a technology

00:38:47,279 --> 00:38:53,579
called Network policy objects again you

00:38:49,589 --> 00:38:56,609
have to look at your container platform

00:38:53,579 --> 00:38:58,259
and the software-defined networking

00:38:56,609 --> 00:39:00,480
solution that comes with your container

00:38:58,259 --> 00:39:03,180
platform on whether it supports network

00:39:00,480 --> 00:39:07,109
policy objects or not what it allows you

00:39:03,180 --> 00:39:10,170
to do is set up policies so that only

00:39:07,109 --> 00:39:12,720
specific calls from specific services

00:39:10,170 --> 00:39:14,309
are allowed so for example let's say

00:39:12,720 --> 00:39:16,920
this is an application that includes a

00:39:14,309 --> 00:39:19,049
bunch of micro services say Mike there

00:39:16,920 --> 00:39:21,119
are a few different micro services here

00:39:19,049 --> 00:39:23,279
for example this particular micro

00:39:21,119 --> 00:39:26,130
service that is running in Tomcat is not

00:39:23,279 --> 00:39:28,500
allowed to talk to a my sequel database

00:39:26,130 --> 00:39:29,910
because it's this database is private to

00:39:28,500 --> 00:39:32,730
this particular service called email

00:39:29,910 --> 00:39:35,309
micro service right now how do you

00:39:32,730 --> 00:39:36,720
prevent those kind of calls random calls

00:39:35,309 --> 00:39:38,910
from happening right that's where

00:39:36,720 --> 00:39:41,039
Network policy of this comments coming

00:39:38,910 --> 00:39:43,650
to play you lock down everything by

00:39:41,039 --> 00:39:46,500
default and you add specific policies

00:39:43,650 --> 00:39:48,569
that will allow specific calls to happen

00:39:46,500 --> 00:39:50,700
based on how you define your application

00:39:48,569 --> 00:39:52,799
and that's how you can implement micro

00:39:50,700 --> 00:39:55,019
segmentation with network policy objects

00:39:52,799 --> 00:39:57,329
these are policies this policy is

00:39:55,019 --> 00:39:59,579
applied as simple Hamel files on the top

00:39:57,329 --> 00:40:02,190
of you once you deploy your application

00:39:59,579 --> 00:40:05,130
so you can log down everything

00:40:02,190 --> 00:40:07,980
by just applying a llamo and you can

00:40:05,130 --> 00:40:09,720
open up specific connections by again

00:40:07,980 --> 00:40:14,040
applying those policies which are just

00:40:09,720 --> 00:40:15,690
animals right so the this will allow you

00:40:14,040 --> 00:40:23,820
to do micro segmentation for your

00:40:15,690 --> 00:40:26,130
applications now SSL SSL gap is possible

00:40:23,820 --> 00:40:28,140
with your kubernetes workloads

00:40:26,130 --> 00:40:30,210
specifically in the world of open shift

00:40:28,140 --> 00:40:32,820
open shell provides something called a

00:40:30,210 --> 00:40:36,540
OpenShift router that allows three

00:40:32,820 --> 00:40:38,490
different kinds of SSL termination one

00:40:36,540 --> 00:40:41,580
is the H termination where the router

00:40:38,490 --> 00:40:43,440
has a certificate and the client has a

00:40:41,580 --> 00:40:45,270
certificate and SSL is between the

00:40:43,440 --> 00:40:46,770
client and the router and between the

00:40:45,270 --> 00:40:48,420
router and your application that is

00:40:46,770 --> 00:40:51,930
running as containers on on your

00:40:48,420 --> 00:40:53,730
platform that that is unsecured the

00:40:51,930 --> 00:40:55,560
other way in which you can deploy it is

00:40:53,730 --> 00:41:00,180
called pass-through termination where

00:40:55,560 --> 00:41:02,010
the the decryption is not done by the

00:41:00,180 --> 00:41:03,780
router and it has to be handled by your

00:41:02,010 --> 00:41:06,510
replication that means you're building

00:41:03,780 --> 00:41:08,400
the SSL encryption decryption into your

00:41:06,510 --> 00:41:10,680
application itself and that's where you

00:41:08,400 --> 00:41:13,080
can use pass through the third is

00:41:10,680 --> 00:41:14,810
re-encrypt where you are using separate

00:41:13,080 --> 00:41:18,450
certificate between the router and your

00:41:14,810 --> 00:41:19,980
your client and between the router and

00:41:18,450 --> 00:41:22,140
your application you have a separate

00:41:19,980 --> 00:41:26,220
private certificate right so that's how

00:41:22,140 --> 00:41:30,540
we encrypt will work now this is all at

00:41:26,220 --> 00:41:33,780
the edge level right what about and then

00:41:30,540 --> 00:41:35,880
what about if I want to whitelist only

00:41:33,780 --> 00:41:40,200
specific IP addresses through my ingress

00:41:35,880 --> 00:41:42,750
the router also has ability to whitelist

00:41:40,200 --> 00:41:44,640
specific IP addresses so that all calls

00:41:42,750 --> 00:41:47,130
are not allowed inside only specific

00:41:44,640 --> 00:41:49,010
calls coming from specific IP addresses

00:41:47,130 --> 00:41:53,130
are allowed that way you can restrict

00:41:49,010 --> 00:41:56,130
where the calls are made from then what

00:41:53,130 --> 00:41:57,780
about my end-to-end security all the

00:41:56,130 --> 00:41:59,640
micro services that I that I have

00:41:57,780 --> 00:42:02,040
deployed on my cluster should be

00:41:59,640 --> 00:42:04,950
protected if that's the case you can

00:42:02,040 --> 00:42:06,570
always implement your mutual TLS between

00:42:04,950 --> 00:42:08,760
the micro services deployed on your

00:42:06,570 --> 00:42:11,550
cluster by you on your own but if you

00:42:08,760 --> 00:42:15,240
are using tools like SEO a service mesh

00:42:11,550 --> 00:42:15,869
service mesh provides has capabilities

00:42:15,240 --> 00:42:20,369
by

00:42:15,869 --> 00:42:23,609
using STR it's it has been renamed as

00:42:20,369 --> 00:42:25,380
Citadel which will actually use the same

00:42:23,609 --> 00:42:27,900
service account community service

00:42:25,380 --> 00:42:29,789
account and generate certificates and it

00:42:27,900 --> 00:42:31,799
will assign those certificates to the

00:42:29,789 --> 00:42:33,599
sidecar proxies that are running

00:42:31,799 --> 00:42:36,809
alongside with your application in each

00:42:33,599 --> 00:42:39,029
part and mutual TLS can be enabled

00:42:36,809 --> 00:42:41,670
between any microt services running on

00:42:39,029 --> 00:42:44,130
on on your cluster on your history or

00:42:41,670 --> 00:42:46,650
cluster this way you can easily enable

00:42:44,130 --> 00:42:50,130
mutual TLS across your micro services

00:42:46,650 --> 00:42:54,029
running on your cluster now this will

00:42:50,130 --> 00:42:55,980
also do the certificate rotation you can

00:42:54,029 --> 00:43:01,440
also configure pin your dick rotation of

00:42:55,980 --> 00:43:03,980
the keys and all that secrets to store

00:43:01,440 --> 00:43:07,349
sensitive data you have passwords

00:43:03,980 --> 00:43:09,269
configuration files docker configs and

00:43:07,349 --> 00:43:12,059
things like that that are used by your

00:43:09,269 --> 00:43:14,960
application kubernetes provides secrets

00:43:12,059 --> 00:43:18,420
don't just mount this as regular data

00:43:14,960 --> 00:43:20,039
into your container save it as secrets

00:43:18,420 --> 00:43:22,890
use the right tools for right things

00:43:20,039 --> 00:43:25,009
right when you are using secrets they

00:43:22,890 --> 00:43:27,539
will never come to rest on the nodes and

00:43:25,009 --> 00:43:30,869
they are stored in a CD and they are

00:43:27,539 --> 00:43:34,950
encrypted so secrets can also be stored

00:43:30,869 --> 00:43:36,839
in in what kind of solutions and they

00:43:34,950 --> 00:43:39,869
can be pulled only at the time at

00:43:36,839 --> 00:43:42,720
runtime if desired so you can storage

00:43:39,869 --> 00:43:44,880
house Secrets number one and if if your

00:43:42,720 --> 00:43:47,130
security requirements are strange and

00:43:44,880 --> 00:43:51,539
then also explore the possibility of

00:43:47,130 --> 00:43:54,119
using solutions like wall let's get to

00:43:51,539 --> 00:43:56,220
egress so I have my applications running

00:43:54,119 --> 00:43:59,190
as containers on the top of a container

00:43:56,220 --> 00:44:00,930
platform but this application is these

00:43:59,190 --> 00:44:02,789
applications are also making calls to

00:44:00,930 --> 00:44:05,009
external systems that are running

00:44:02,789 --> 00:44:08,700
outside these external systems could be

00:44:05,009 --> 00:44:10,880
let us say databases or my ERP ESCP

00:44:08,700 --> 00:44:14,549
system that is running outside my

00:44:10,880 --> 00:44:16,289
outside my cluster right how do I make

00:44:14,549 --> 00:44:18,480
sure that the calls go outside in a

00:44:16,289 --> 00:44:21,690
secured fashion can can they be passed

00:44:18,480 --> 00:44:24,089
through a firewall if so how do I make

00:44:21,690 --> 00:44:27,539
sure that the IP address that is coming

00:44:24,089 --> 00:44:29,220
out of this is is something that is

00:44:27,539 --> 00:44:33,330
consistent which I can block

00:44:29,220 --> 00:44:36,660
using a firewall again in this

00:44:33,330 --> 00:44:38,910
particular case the solution is there

00:44:36,660 --> 00:44:40,560
with an open shift kind of a cluster I'm

00:44:38,910 --> 00:44:43,170
not sure if there is anything like that

00:44:40,560 --> 00:44:46,700
from a kubernetes cluster where open

00:44:43,170 --> 00:44:49,380
shift provides is that it it gives a

00:44:46,700 --> 00:44:52,440
egress mechanism where you can configure

00:44:49,380 --> 00:44:54,680
a IP at individual namespace

00:44:52,440 --> 00:44:56,609
level or project level and any

00:44:54,680 --> 00:44:58,650
communications that are going from any

00:44:56,609 --> 00:45:00,869
parts within that project will adopt

00:44:58,650 --> 00:45:03,420
that particular IP address the TP gross

00:45:00,869 --> 00:45:06,210
IP address so when your firewall gets

00:45:03,420 --> 00:45:08,040
the call it sees that IP address and if

00:45:06,210 --> 00:45:09,720
that IP address is allowed to reach this

00:45:08,040 --> 00:45:12,840
external system that call can be allowed

00:45:09,720 --> 00:45:15,030
so you can still use firewalls with for

00:45:12,840 --> 00:45:18,830
egress traffic coming out of your

00:45:15,030 --> 00:45:18,830
cluster with this kind of a mechanism

00:45:19,099 --> 00:45:27,030
another feature egress fire was to limit

00:45:23,150 --> 00:45:29,670
access to specific system so you can do

00:45:27,030 --> 00:45:32,640
things like a pod can't ask to talk to a

00:45:29,670 --> 00:45:34,410
specific host outside your cluster but

00:45:32,640 --> 00:45:36,990
it cannot connect to the public internet

00:45:34,410 --> 00:45:40,170
all your pod can actually connect to

00:45:36,990 --> 00:45:42,960
public internet but it cannot talk to

00:45:40,170 --> 00:45:45,990
other things or you can provide

00:45:42,960 --> 00:45:48,240
connections to specific subnets outside

00:45:45,990 --> 00:45:50,670
your cluster right these kind of things

00:45:48,240 --> 00:45:52,980
are possible in on specific platforms

00:45:50,670 --> 00:45:55,500
like open shipped so you would want to

00:45:52,980 --> 00:45:58,380
think about your requirements from your

00:45:55,500 --> 00:46:00,630
applications III perspective and keep

00:45:58,380 --> 00:46:05,460
those things in mind when you are

00:46:00,630 --> 00:46:08,070
thinking about a container platform so

00:46:05,460 --> 00:46:10,410
from application security perspective we

00:46:08,070 --> 00:46:13,050
talked about API management we talked

00:46:10,410 --> 00:46:17,010
about SSL Secrets connecting to external

00:46:13,050 --> 00:46:18,930
services so I think I have reached the

00:46:17,010 --> 00:46:20,640
end of my time if there are any quick

00:46:18,930 --> 00:46:24,080
questions you can type them on the on

00:46:20,640 --> 00:46:24,080

YouTube URL: https://www.youtube.com/watch?v=YpyKOBKd1_A


