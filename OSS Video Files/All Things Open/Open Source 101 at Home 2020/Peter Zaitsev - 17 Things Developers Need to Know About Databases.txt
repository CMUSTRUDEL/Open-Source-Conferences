Title: Peter Zaitsev - 17 Things Developers Need to Know About Databases
Publication date: 2020-05-19
Playlist: Open Source 101 at Home 2020
Description: 
	17 Things Developers Need to Know About Databases

Presented at: Open Source 101 at Home 2020
Presented by: Peter Zaitsev, Percona

Abstract: Most applications use databases, yet many fail to follow even the most basic best practices causing poor performance, downtime and security incidents.   

In this presentation, we will look into the foundational best practices you as a Developer should know about databases, with particular focus on the most popular Open Source Databases - MySQL, PostgreSQL, and MongoDB.

For more info: https://opensource101.com
Captions: 
	00:00:09,800 --> 00:00:19,770
okay well my clock says it's time it's

00:00:16,650 --> 00:00:22,710
time for us to get started so unless you

00:00:19,770 --> 00:00:25,289
can't really hear me which would be a

00:00:22,710 --> 00:00:29,330
problem at this point then you'll get

00:00:25,289 --> 00:00:32,369
started and we will talk about 17 things

00:00:29,330 --> 00:00:36,510
developers should know about about

00:00:32,369 --> 00:00:40,440
databases and it might be more or less

00:00:36,510 --> 00:00:43,860
than 17 things I just had to pick a

00:00:40,440 --> 00:00:48,840
number anyway let's get the going and

00:00:43,860 --> 00:00:52,110
let me start with if a freaking joke in

00:00:48,840 --> 00:00:55,770
this case which I think some of you may

00:00:52,110 --> 00:00:59,370
have seen that about the front-end

00:00:55,770 --> 00:01:02,180
developer and their knowledge of for SQL

00:00:59,370 --> 00:01:05,070
why front-end developers eat alone or

00:01:02,180 --> 00:01:07,979
well because we don't know how to join

00:01:05,070 --> 00:01:12,000
tables right and I think this is very

00:01:07,979 --> 00:01:15,470
relevant because indeed in the modern

00:01:12,000 --> 00:01:19,470
technical community we have a huge huge

00:01:15,470 --> 00:01:22,560
split of a different knowledge right

00:01:19,470 --> 00:01:25,110
there are some people who really know

00:01:22,560 --> 00:01:28,320
database and SQL language pretty well

00:01:25,110 --> 00:01:31,860
and there are also some the other

00:01:28,320 --> 00:01:34,710
developers which are really writing

00:01:31,860 --> 00:01:39,119
applications they which may not know

00:01:34,710 --> 00:01:42,899
they're a database technology that well

00:01:39,119 --> 00:01:45,899
write including the you know what is a

00:01:42,899 --> 00:01:49,079
joint now if you think about the most

00:01:45,899 --> 00:01:53,390
teams what I commonly see is kind of a

00:01:49,079 --> 00:01:57,600
great split between the developers and

00:01:53,390 --> 00:02:00,810
the technical technical operations now

00:01:57,600 --> 00:02:04,790
if you think about operations these are

00:02:00,810 --> 00:02:09,479
folks which are focus on the database

00:02:04,790 --> 00:02:12,660
write something like DBA S or database

00:02:09,479 --> 00:02:13,400
architects or database reliability

00:02:12,660 --> 00:02:16,459
engineer

00:02:13,400 --> 00:02:18,620
titles have been evolved or grass some

00:02:16,459 --> 00:02:21,140
generalists which are also in charge of

00:02:18,620 --> 00:02:23,390
a data database as a part of a whole

00:02:21,140 --> 00:02:28,280
likes asad means site reliability

00:02:23,390 --> 00:02:31,659
engineers and so on and so forth right

00:02:28,280 --> 00:02:35,049
we have as kind of two classes of people

00:02:31,659 --> 00:02:37,220
now if you look at where a lot of

00:02:35,049 --> 00:02:41,000
organizations especially larger ones

00:02:37,220 --> 00:02:46,120
receiver is a lot of tension between the

00:02:41,000 --> 00:02:49,069
developers and ops right now if you

00:02:46,120 --> 00:02:52,280
think about that there is a modern

00:02:49,069 --> 00:02:54,340
concept well not super modern browser is

00:02:52,280 --> 00:02:58,639
right I mean it's more than five years

00:02:54,340 --> 00:03:00,650
old called dev ops which was recognizing

00:02:58,639 --> 00:03:04,030
that and exactly focused on bridging the

00:03:00,650 --> 00:03:06,590
gap within devs and ops right in reality

00:03:04,030 --> 00:03:09,470
we see not all the organization

00:03:06,590 --> 00:03:12,319
specialized one easily adopted that very

00:03:09,470 --> 00:03:15,829
well especially when it comes to the

00:03:12,319 --> 00:03:18,859
databases because it databases they kind

00:03:15,829 --> 00:03:22,690
of its own often special snowflake

00:03:18,859 --> 00:03:25,370
compared to other parts of

00:03:22,690 --> 00:03:28,549
infrastructure right so for example one

00:03:25,370 --> 00:03:32,030
of our approaches before mmm DevOps you

00:03:28,549 --> 00:03:35,000
think about their continuous deployment

00:03:32,030 --> 00:03:37,069
then you know you can really deploy

00:03:35,000 --> 00:03:38,599
things quickly if you break something

00:03:37,069 --> 00:03:40,940
you can quickly fix it

00:03:38,599 --> 00:03:43,599
that is not how things work with

00:03:40,940 --> 00:03:46,340
database especially large one if you

00:03:43,599 --> 00:03:48,829
drop the table you didn't intend to well

00:03:46,340 --> 00:03:50,659
chances are it will take a time to

00:03:48,829 --> 00:03:54,560
recover it from backup if you need to

00:03:50,659 --> 00:03:57,799
run the alter table right - you know I

00:03:54,560 --> 00:04:00,229
don't index or column - chances are that

00:03:57,799 --> 00:04:03,019
will take significant point of time

00:04:00,229 --> 00:04:05,780
right so with databases still require a

00:04:03,019 --> 00:04:07,069
special care even if the organization's

00:04:05,780 --> 00:04:10,940
we showed that having that DevOps

00:04:07,069 --> 00:04:15,290
approach now what I think is even more

00:04:10,940 --> 00:04:17,060
interesting is if you look at their very

00:04:15,290 --> 00:04:20,780
large operations you often have an

00:04:17,060 --> 00:04:23,180
Operations team which is very silent as

00:04:20,780 --> 00:04:26,599
well right like we may have focus who

00:04:23,180 --> 00:04:26,930
are focused on storage and network and

00:04:26,599 --> 00:04:29,750
but you

00:04:26,930 --> 00:04:33,669
a grading system right and if certain

00:04:29,750 --> 00:04:37,639
things are not working right and maybe

00:04:33,669 --> 00:04:40,759
pointing finger to everyone right and

00:04:37,639 --> 00:04:44,919
then there is also security folks which

00:04:40,759 --> 00:04:50,840
can you know establish some additional

00:04:44,919 --> 00:04:56,270
roadblocks be other security rules or

00:04:50,840 --> 00:04:58,960
policies and so on in the natural very

00:04:56,270 --> 00:05:02,840
often see the developers thinking about

00:04:58,960 --> 00:05:06,349
the database that can be explained this

00:05:02,840 --> 00:05:09,830
simple way right from developer side it

00:05:06,349 --> 00:05:13,449
is like the question of why this stupid

00:05:09,830 --> 00:05:16,130
database is always a problem why it's

00:05:13,449 --> 00:05:17,630
always stopped working and I am not

00:05:16,130 --> 00:05:19,520
doing anything wrong

00:05:17,630 --> 00:05:22,099
because from development standpoint they

00:05:19,520 --> 00:05:23,810
are or if you don't understand how a

00:05:22,099 --> 00:05:26,419
database works internally they just you

00:05:23,810 --> 00:05:29,030
know sending queries and one query may

00:05:26,419 --> 00:05:32,240
not be different from another from our

00:05:29,030 --> 00:05:35,150
standpoint but in reality changing you

00:05:32,240 --> 00:05:39,380
know some sin single clause from end to

00:05:35,150 --> 00:05:41,300
or may make query thousand times more

00:05:39,380 --> 00:05:44,270
complicated right and take thousand

00:05:41,300 --> 00:05:46,400
times longer to complete from operations

00:05:44,270 --> 00:05:48,199
people or and I mean in this case the

00:05:46,400 --> 00:05:51,650
people who really understand and care

00:05:48,199 --> 00:05:54,169
about the databases there is always a

00:05:51,650 --> 00:05:56,240
question about developers why you do not

00:05:54,169 --> 00:05:58,820
learn the database design why do you

00:05:56,240 --> 00:06:02,930
create a tables if no proper indexes and

00:05:58,820 --> 00:06:05,000
then you know scream bleeding bloody

00:06:02,930 --> 00:06:07,729
murder many things do not work right

00:06:05,000 --> 00:06:10,669
why do not write optimized queries right

00:06:07,729 --> 00:06:13,639
like go through a process of assessing

00:06:10,669 --> 00:06:16,070
how optimal query is before put in that

00:06:13,639 --> 00:06:18,470
interaction why don't you think about a

00:06:16,070 --> 00:06:23,060
capacity planning right again in a lot

00:06:18,470 --> 00:06:25,190
of cases I see developers think you know

00:06:23,060 --> 00:06:26,740
databases can magically handle that

00:06:25,190 --> 00:06:31,130
right not really

00:06:26,740 --> 00:06:36,020
assessing how much for clothes data

00:06:31,130 --> 00:06:39,650
queries it can happen and all that gets

00:06:36,020 --> 00:06:40,820
to their conflict now if you look at one

00:06:39,650 --> 00:06:43,370
thing I want you to take

00:06:40,820 --> 00:06:45,680
away from this presentation before we go

00:06:43,370 --> 00:06:48,860
at the practices for developers is what

00:06:45,680 --> 00:06:50,810
if you look at successful database

00:06:48,860 --> 00:06:54,620
operations right if you really want to

00:06:50,810 --> 00:06:56,540
build the large-scale successful

00:06:54,620 --> 00:06:58,940
database bar application you need to

00:06:56,540 --> 00:07:01,670
understand what database responsibility

00:06:58,940 --> 00:07:06,740
is a shared responsibility between devs

00:07:01,670 --> 00:07:09,710
and Ops right and folks need to work

00:07:06,740 --> 00:07:13,550
that together right to resolve the

00:07:09,710 --> 00:07:18,560
problem nothing else really will will

00:07:13,550 --> 00:07:22,270
work okay now with that out of the way

00:07:18,560 --> 00:07:26,150
let's go and talk about some photography

00:07:22,270 --> 00:07:29,480
recommendations I have for our four

00:07:26,150 --> 00:07:31,430
developers now the first thing is what

00:07:29,480 --> 00:07:33,740
you really need to understand how a

00:07:31,430 --> 00:07:37,760
database works at least on a high level

00:07:33,740 --> 00:07:39,560
or on a high level all right if you

00:07:37,760 --> 00:07:41,510
really think a database is a black box

00:07:39,560 --> 00:07:43,130
and you're you know just going to Google

00:07:41,510 --> 00:07:45,710
and just copy paste those create

00:07:43,130 --> 00:07:49,460
statements and some queries you won't be

00:07:45,710 --> 00:07:51,350
able to build the life scale

00:07:49,460 --> 00:07:54,950
applications right maybe you will be

00:07:51,350 --> 00:07:59,420
able to go by with some you know tiny

00:07:54,950 --> 00:08:03,080
demos but it will all crashing down

00:07:59,420 --> 00:08:06,710
sumer sooner then you would hope right

00:08:03,080 --> 00:08:10,430
because of all that complexity which

00:08:06,710 --> 00:08:12,310
database entails specifically you want

00:08:10,430 --> 00:08:15,080
to you want to learn the schema design

00:08:12,310 --> 00:08:18,590
there are power of database language

00:08:15,080 --> 00:08:22,420
such as SQL and in particular how the

00:08:18,590 --> 00:08:24,580
database mmm execute

00:08:22,420 --> 00:08:30,820
require at least in high level details

00:08:24,580 --> 00:08:34,760
so here is example of a database

00:08:30,820 --> 00:08:39,349
relational schema right MySQL pause

00:08:34,760 --> 00:08:42,080
gross Oracle on a higher level or it is

00:08:39,349 --> 00:08:45,410
a relational schema is the same this is

00:08:42,080 --> 00:08:48,040
a set of tables with relationships

00:08:45,410 --> 00:08:51,650
between them I think it is very

00:08:48,040 --> 00:08:54,500
important to be able to understand and

00:08:51,650 --> 00:08:59,810
represent your schema as

00:08:54,500 --> 00:09:02,090
assai a side set of set of tables now if

00:08:59,810 --> 00:09:04,070
you look at the very execution I would

00:09:02,090 --> 00:09:06,920
encourage you to understand clear

00:09:04,070 --> 00:09:10,550
execution at least on on this level this

00:09:06,920 --> 00:09:12,860
is how a query executed on MySQL side

00:09:10,550 --> 00:09:15,590
from McKean very high level point of

00:09:12,860 --> 00:09:18,590
view but this is already very helpful

00:09:15,590 --> 00:09:21,250
because it explains you for example what

00:09:18,590 --> 00:09:24,170
Hager is a parser which create give each

00:09:21,250 --> 00:09:26,390
part of the query very is something but

00:09:24,170 --> 00:09:29,390
optimizes for query and come by with a

00:09:26,390 --> 00:09:34,220
query optimizer query execution plan

00:09:29,390 --> 00:09:39,560
which is later and executed right a lot

00:09:34,220 --> 00:09:42,820
all for developers I met so they are not

00:09:39,560 --> 00:09:46,340
really able to explain the database

00:09:42,820 --> 00:09:49,820
operation database query execution even

00:09:46,340 --> 00:09:52,130
on this very high level the very

00:09:49,820 --> 00:09:55,430
important piece if you really want to

00:09:52,130 --> 00:09:59,810
have one thing you as developer need to

00:09:55,430 --> 00:10:05,000
know about a database is they explain

00:09:59,810 --> 00:10:08,480
how query is executed right and you need

00:10:05,000 --> 00:10:12,590
to have know two things about explain a

00:10:08,480 --> 00:10:16,580
how your current query is is executed

00:10:12,590 --> 00:10:18,790
and B how things will change with your

00:10:16,580 --> 00:10:21,650
application changes right because

00:10:18,790 --> 00:10:23,300
typically the test queries in a test

00:10:21,650 --> 00:10:28,190
environment with maybe some very small

00:10:23,300 --> 00:10:31,820
data set and as database gets larger

00:10:28,190 --> 00:10:33,620
then you know certain things certain

00:10:31,820 --> 00:10:36,050
queries can become substantially slower

00:10:33,620 --> 00:10:38,630
right which actually if you analyze if

00:10:36,050 --> 00:10:40,880
you take it careful look at explain you

00:10:38,630 --> 00:10:43,190
often will be able to see that this is a

00:10:40,880 --> 00:10:45,890
visually visualize the Datagram which is

00:10:43,190 --> 00:10:47,810
from my school board bench which has

00:10:45,890 --> 00:10:51,110
this fantastic very visualization tool

00:10:47,810 --> 00:10:56,180
and then also you can read about

00:10:51,110 --> 00:10:58,640
execution plan information and manual to

00:10:56,180 --> 00:11:02,720
read explain better right I don't have a

00:10:58,640 --> 00:11:06,040
time specifically to go into that the

00:11:02,720 --> 00:11:08,170
PostgreSQL now obviously has

00:11:06,040 --> 00:11:15,550
has a similar feature right like in this

00:11:08,170 --> 00:11:18,240
case I am using the tool called 2 P AV

00:11:15,550 --> 00:11:23,920
right for his a link down there which

00:11:18,240 --> 00:11:30,160
shows how you can visualize a plan right

00:11:23,920 --> 00:11:31,990
again very very good tool and both those

00:11:30,160 --> 00:11:35,620
visualization tools they're basically

00:11:31,990 --> 00:11:39,310
for for convenience it is I think even

00:11:35,620 --> 00:11:42,150
better to get the skills to execute the

00:11:39,310 --> 00:11:45,130
raw textual output plan as a database

00:11:42,150 --> 00:11:48,520
mmm a database generates right they

00:11:45,130 --> 00:11:54,610
don't have to excel I on this additional

00:11:48,520 --> 00:11:58,450
level of parson from percona side view

00:11:54,610 --> 00:12:01,900
are helping you to understand the

00:11:58,450 --> 00:12:04,600
queries for all the open source database

00:12:01,900 --> 00:12:07,120
we support with our tools called TMM the

00:12:04,600 --> 00:12:09,940
corner more interent and and management

00:12:07,120 --> 00:12:12,430
which can show you or what queries are

00:12:09,940 --> 00:12:14,260
causing the lord on the system or you

00:12:12,430 --> 00:12:15,610
can also see whatever slowest square is

00:12:14,260 --> 00:12:19,800
what queries are causing temporary

00:12:15,610 --> 00:12:22,690
tables and so on and so forth as well as

00:12:19,800 --> 00:12:25,810
why you're very causing this load there

00:12:22,690 --> 00:12:35,950
you can take a look at specific query

00:12:25,810 --> 00:12:41,980
and understand what is mm of what a what

00:12:35,950 --> 00:12:44,890
is this the the what is the query taking

00:12:41,980 --> 00:12:49,480
right it like in this case we can see

00:12:44,890 --> 00:12:52,450
for example what this query takes disk

00:12:49,480 --> 00:12:55,000
i/o takes only 3% of a query execution

00:12:52,450 --> 00:12:56,800
time that means I did more memory or

00:12:55,000 --> 00:12:59,950
getting faster disk is not going to

00:12:56,800 --> 00:13:02,500
improve that very performance and also

00:12:59,950 --> 00:13:06,160
how to optimize in this query

00:13:02,500 --> 00:13:08,710
performance which we do by providing the

00:13:06,160 --> 00:13:12,490
most important information about the

00:13:08,710 --> 00:13:15,250
query such as query example it's so you

00:13:12,490 --> 00:13:19,480
understand what query optimizing their

00:13:15,250 --> 00:13:21,430
query output explained output and show

00:13:19,480 --> 00:13:23,589
create table for new involve tables

00:13:21,430 --> 00:13:27,250
right typically using that information

00:13:23,589 --> 00:13:31,029
you are able to understand how to

00:13:27,250 --> 00:13:34,089
optimize your query so if you want to

00:13:31,029 --> 00:13:38,110
check out even more here is a demo

00:13:34,089 --> 00:13:43,240
remember Conrad come here you can I do a

00:13:38,110 --> 00:13:44,980
lot of stuff without you know check out

00:13:43,240 --> 00:13:47,680
a lot of the features of thousand stolen

00:13:44,980 --> 00:13:51,250
that and also just yesterday we released

00:13:47,680 --> 00:13:54,870
a new version experiment two to six if

00:13:51,250 --> 00:13:59,589
you are want to check that out okay

00:13:54,870 --> 00:14:03,880
moving on the next thing which you need

00:13:59,589 --> 00:14:07,389
to understand about query execution is

00:14:03,880 --> 00:14:10,769
how queries are executed on a very high

00:14:07,389 --> 00:14:14,589
level right and again for some of them

00:14:10,769 --> 00:14:18,029
MySQL all-timer so that's maybe look

00:14:14,589 --> 00:14:23,529
like a stupid question right a very

00:14:18,029 --> 00:14:25,630
basic question but a lot of new hmm

00:14:23,529 --> 00:14:29,470
developers coming into the system it no

00:14:25,630 --> 00:14:32,949
have a preconceived notions they may not

00:14:29,470 --> 00:14:35,230
really expect every behavior which many

00:14:32,949 --> 00:14:37,120
databases have right think about that

00:14:35,230 --> 00:14:41,920
you have a database cluster for example

00:14:37,120 --> 00:14:44,260
over five nodes which each has have you

00:14:41,920 --> 00:14:47,230
know tens for CPU cores and if you throw

00:14:44,260 --> 00:14:49,750
the complicated query on this cluster as

00:14:47,230 --> 00:14:53,829
a reasonable person how would you Excel

00:14:49,750 --> 00:15:00,040
expect that to be executed well probably

00:14:53,829 --> 00:15:01,839
you would expect that to be executed by

00:15:00,040 --> 00:15:06,519
using all the resources which are

00:15:01,839 --> 00:15:08,350
available on that cluster well indeed

00:15:06,519 --> 00:15:10,060
that is how things work with some of the

00:15:08,350 --> 00:15:14,290
database technologies like if you think

00:15:10,060 --> 00:15:17,050
something like Hadoop or click house

00:15:14,290 --> 00:15:19,839
indeed when you send the query in it can

00:15:17,050 --> 00:15:22,690
use all CPU cores like all resources on

00:15:19,839 --> 00:15:26,170
all the nodes which correspond to a

00:15:22,690 --> 00:15:29,140
cluster but that is not how my SQL or

00:15:26,170 --> 00:15:32,980
Postgres works the Postgres actually has

00:15:29,140 --> 00:15:36,850
a parallel query hmm of

00:15:32,980 --> 00:15:40,240
she's right that means it's can you

00:15:36,850 --> 00:15:43,420
typically use all the resources on the

00:15:40,240 --> 00:15:50,790
scene single node right over all the CPU

00:15:43,420 --> 00:15:53,130
cores right if some level of efficiency

00:15:50,790 --> 00:15:56,380
where you look at the my school though

00:15:53,130 --> 00:16:01,690
it does not write and this and they're

00:15:56,380 --> 00:16:03,940
complicated select queries or some you

00:16:01,690 --> 00:16:07,269
know large-scale update queries either

00:16:03,940 --> 00:16:10,899
table they all are executed essentially

00:16:07,269 --> 00:16:13,690
in a single thread bound by a single CPU

00:16:10,899 --> 00:16:16,720
core right which is which is an

00:16:13,690 --> 00:16:19,269
important limitation of that technology

00:16:16,720 --> 00:16:21,760
and as your built in your application

00:16:19,269 --> 00:16:23,560
you need to know that because you don't

00:16:21,760 --> 00:16:26,639
want to happen is you don't want to be

00:16:23,560 --> 00:16:29,980
developing your system on a single

00:16:26,639 --> 00:16:31,540
single node let's say for CPU core

00:16:29,980 --> 00:16:35,079
system are thinking oh you don't want

00:16:31,540 --> 00:16:39,040
it's no problem I can make my queries a

00:16:35,079 --> 00:16:41,500
lot faster by getting 64 node box and

00:16:39,040 --> 00:16:45,130
then finding out what's now we're on

00:16:41,500 --> 00:16:47,639
because single query can only run on a

00:16:45,130 --> 00:16:53,199
single CPU core in a technology you mM

00:16:47,639 --> 00:16:55,569
that you have chosen indexes within

00:16:53,199 --> 00:16:57,750
about the indexes is indexes are

00:16:55,569 --> 00:17:02,050
absolutely critical when it comes to or

00:16:57,750 --> 00:17:05,290
to conventional relational database

00:17:02,050 --> 00:17:08,069
right so you really need to make sure

00:17:05,290 --> 00:17:11,020
your performance critical queries have

00:17:08,069 --> 00:17:14,589
indexes they need at the same time

00:17:11,020 --> 00:17:17,709
indexes are expensive indexes slow

00:17:14,589 --> 00:17:21,040
things down right slow things down when

00:17:17,709 --> 00:17:24,309
a query cannot use yours those indexes

00:17:21,040 --> 00:17:30,309
now a lot of people understand what

00:17:24,309 --> 00:17:33,730
indexes slow down queries as update

00:17:30,309 --> 00:17:37,150
queries right or modifications in cells

00:17:33,730 --> 00:17:40,210
deletes because when I am updating the

00:17:37,150 --> 00:17:43,090
data I potentially need to update all my

00:17:40,210 --> 00:17:44,440
indexes and the more indexes hair I have

00:17:43,090 --> 00:17:46,750
the slow things are going to become

00:17:44,440 --> 00:17:49,780
right that is

00:17:46,750 --> 00:17:52,929
oh pretty clear at the same time that

00:17:49,780 --> 00:17:55,299
also after applies to selects because

00:17:52,929 --> 00:17:58,419
more indexes you have the more your data

00:17:55,299 --> 00:18:01,780
size will take so possibly it will not

00:17:58,419 --> 00:18:08,169
have as a good cache a hit anymore

00:18:01,780 --> 00:18:11,440
and then also the optimizer will have to

00:18:08,169 --> 00:18:16,090
do a lot more work figuring out what

00:18:11,440 --> 00:18:19,659
indexes what indexes to use right so in

00:18:16,090 --> 00:18:23,500
the so do add indexes but do not add the

00:18:19,659 --> 00:18:25,659
indexes you do not need actually this

00:18:23,500 --> 00:18:28,210
brings us to a very kind of telltale

00:18:25,659 --> 00:18:31,230
Syal about that indexes practices right

00:18:28,210 --> 00:18:33,760
there are two if you give me their

00:18:31,230 --> 00:18:38,409
database schema dump like MySQL dump

00:18:33,760 --> 00:18:41,110
often I can very easily spot when folks

00:18:38,409 --> 00:18:46,240
do not have proper indexing skills in

00:18:41,110 --> 00:18:49,030
the team the first one is if I see

00:18:46,240 --> 00:18:51,850
pretty much only primary key is created

00:18:49,030 --> 00:18:54,070
in the system right that means people do

00:18:51,850 --> 00:18:56,080
not understand indexes we create primary

00:18:54,070 --> 00:18:58,330
keys because we had to or because we

00:18:56,080 --> 00:19:02,530
have been automatically created for them

00:18:58,330 --> 00:19:06,190
now the second thing is if I see almost

00:19:02,530 --> 00:19:09,789
every column indexed right because some

00:19:06,190 --> 00:19:11,919
people the very take a very simplified

00:19:09,789 --> 00:19:14,590
approach to index and we go to google

00:19:11,919 --> 00:19:17,260
and in google they see well if you have

00:19:14,590 --> 00:19:20,380
the column as a part of a where clause

00:19:17,260 --> 00:19:23,530
I should index that that is a that as a

00:19:20,380 --> 00:19:26,140
bad idea don't index all comma all

00:19:23,530 --> 00:19:29,049
columns and in many cases you want to

00:19:26,140 --> 00:19:30,549
build the multi-column indexes for

00:19:29,049 --> 00:19:32,890
better performance notes building

00:19:30,549 --> 00:19:38,440
indexes separately on all the different

00:19:32,890 --> 00:19:42,070
platforms the next thing is capacity

00:19:38,440 --> 00:19:44,950
planning no database really have

00:19:42,070 --> 00:19:48,280
unlimited scale right you always have to

00:19:44,950 --> 00:19:50,110
defer the design for the lord you have

00:19:48,280 --> 00:19:53,650
and this guy and they're also

00:19:50,110 --> 00:19:55,780
scalability is a very application

00:19:53,650 --> 00:19:57,789
dependent now what is interested in in

00:19:55,780 --> 00:20:00,690
this case is you can tell well there are

00:19:57,789 --> 00:20:04,530
some technologies provided by the

00:20:00,690 --> 00:20:07,740
cloud vendors being you know dynamodb or

00:20:04,530 --> 00:20:10,740
Google spanner cause must be right which

00:20:07,740 --> 00:20:13,950
promise pretty much unlimited some

00:20:10,740 --> 00:20:18,270
scalability well the thing I promise you

00:20:13,950 --> 00:20:20,730
is what you run out of money faster than

00:20:18,270 --> 00:20:23,640
they run out of scalability resources

00:20:20,730 --> 00:20:26,160
right there is actually some design

00:20:23,640 --> 00:20:28,160
goals and those systems are not

00:20:26,160 --> 00:20:33,330
unlimited in scale well frankly where is

00:20:28,160 --> 00:20:35,520
the limit to the scale or for those

00:20:33,330 --> 00:20:39,500
cloud vendor scale right and we actually

00:20:35,520 --> 00:20:42,210
have seen what during the early days of

00:20:39,500 --> 00:20:44,580
Kovach pandemics many cloud vendors

00:20:42,210 --> 00:20:47,450
experienced the capacity limits right

00:20:44,580 --> 00:20:49,980
because people try to who have been

00:20:47,450 --> 00:20:53,940
increased in a traffic I've been trying

00:20:49,980 --> 00:20:56,400
to scale the instances and they couldn't

00:20:53,940 --> 00:20:59,660
right now another thing to understand is

00:20:56,400 --> 00:21:02,340
what the scalability is a very very

00:20:59,660 --> 00:21:05,490
application dependent right it may not

00:21:02,340 --> 00:21:07,500
be just about a database system but in

00:21:05,490 --> 00:21:13,650
terms of how your application works so

00:21:07,500 --> 00:21:16,260
for example if you want to you know

00:21:13,650 --> 00:21:20,580
control some of those cloud vendors you

00:21:16,260 --> 00:21:22,950
can ask somebody saying hey does your

00:21:20,580 --> 00:21:24,960
database support meeting updates a

00:21:22,950 --> 00:21:28,310
second right and you probably would say

00:21:24,960 --> 00:21:30,960
oh sure for google spanner cosmos DB

00:21:28,310 --> 00:21:32,550
wherever that is not a problem at all

00:21:30,960 --> 00:21:35,310
right but then you can say well you know

00:21:32,550 --> 00:21:38,070
what I need all those updates to happen

00:21:35,310 --> 00:21:40,680
to exactly the same row right and then

00:21:38,070 --> 00:21:44,730
you probably say oops that is not going

00:21:40,680 --> 00:21:47,540
to work because serialized updates to

00:21:44,730 --> 00:21:52,620
the single row right they really have

00:21:47,540 --> 00:21:56,280
well they really have a serialization

00:21:52,620 --> 00:21:58,290
problem right which introduces the

00:21:56,280 --> 00:22:01,770
scalability limits in this case now of

00:21:58,290 --> 00:22:03,780
course your application is unlikely to

00:22:01,770 --> 00:22:07,350
be that application where all load is

00:22:03,780 --> 00:22:09,630
just hitting all updates on one row but

00:22:07,350 --> 00:22:12,620
it is also probably is not going to that

00:22:09,630 --> 00:22:14,230
perfectly scalable application which

00:22:12,620 --> 00:22:17,290
vendors

00:22:14,230 --> 00:22:19,540
to use as a showcase for however

00:22:17,290 --> 00:22:21,760
technology scales so what you want to

00:22:19,540 --> 00:22:24,970
make sure is you always take those

00:22:21,760 --> 00:22:27,309
promises with a grain of salt and do

00:22:24,970 --> 00:22:31,000
your own measurements right do your own

00:22:27,309 --> 00:22:32,590
measurements in terms of whatever extent

00:22:31,000 --> 00:22:37,059
the scalability of your systems for you

00:22:32,590 --> 00:22:39,190
also pay attention to efficiency right

00:22:37,059 --> 00:22:41,650
why is that important because if you

00:22:39,190 --> 00:22:44,320
look at them at they're in the cloud

00:22:41,650 --> 00:22:47,500
space especially go into a higher

00:22:44,320 --> 00:22:49,750
instance size or larger number of

00:22:47,500 --> 00:22:51,940
instances is a fair play in terms of

00:22:49,750 --> 00:22:54,179
accumulation right it's kind of called

00:22:51,940 --> 00:22:58,510
tuning by the credit card in many cases

00:22:54,179 --> 00:23:01,390
but that is something which can really

00:22:58,510 --> 00:23:05,080
take you down a very wrong path there

00:23:01,390 --> 00:23:06,700
Yosi application will be working and may

00:23:05,080 --> 00:23:09,280
be working with a good performance but

00:23:06,700 --> 00:23:12,220
it will be horrendously inefficient and

00:23:09,280 --> 00:23:15,460
that means it will be bad for your

00:23:12,220 --> 00:23:18,580
wallet and the and bad for environment

00:23:15,460 --> 00:23:22,960
tools you know wasting all those CPU

00:23:18,580 --> 00:23:24,640
cycles another thing when you you need

00:23:22,960 --> 00:23:27,640
to know when you talk about scaling is

00:23:24,640 --> 00:23:31,690
this difference between a vertical

00:23:27,640 --> 00:23:33,520
scaling and horizontal scaling right

00:23:31,690 --> 00:23:37,150
these are typically two important

00:23:33,520 --> 00:23:40,570
approaches which we talk about scale and

00:23:37,150 --> 00:23:42,760
data data centers now if you think about

00:23:40,570 --> 00:23:44,919
those approaches the only one which

00:23:42,760 --> 00:23:48,549
takes you to extreme scale is horizontal

00:23:44,919 --> 00:23:52,270
scale you cannot build the Facebook

00:23:48,549 --> 00:23:54,700
scale application for example by buying

00:23:52,270 --> 00:23:58,360
a very large single server there is not

00:23:54,700 --> 00:24:00,490
such a large single server for sale but

00:23:58,360 --> 00:24:02,980
for many small and medium scale

00:24:00,490 --> 00:24:07,419
applications which are majority by the

00:24:02,980 --> 00:24:10,929
numbers you can actually get by with

00:24:07,419 --> 00:24:15,429
them single powerful ends the instance

00:24:10,929 --> 00:24:18,820
often have in your architecture much

00:24:15,429 --> 00:24:22,650
more simple and cost effective because

00:24:18,820 --> 00:24:25,419
of that right that's why scalability and

00:24:22,650 --> 00:24:27,700
analysis and performance and capacity

00:24:25,419 --> 00:24:30,010
planning is important because may

00:24:27,700 --> 00:24:33,519
you don't need a complexity for a scale

00:24:30,010 --> 00:24:38,559
you are targeting for a foreseeable

00:24:33,519 --> 00:24:41,710
future right I think it's also good to

00:24:38,559 --> 00:24:46,230
point out what the scalable and

00:24:41,710 --> 00:24:48,909
efficient that are kind of maybe often

00:24:46,230 --> 00:24:52,210
seen by people as a similar terms but

00:24:48,909 --> 00:24:56,639
they are very different and in fact many

00:24:52,210 --> 00:25:00,159
systems which you which focus extreme

00:24:56,639 --> 00:25:02,289
scalability they are not very efficient

00:25:00,159 --> 00:25:04,630
at that because from software

00:25:02,289 --> 00:25:07,419
engineering choices right it's extremely

00:25:04,630 --> 00:25:10,450
hard not export impossible but extremely

00:25:07,419 --> 00:25:14,289
hard to build the systems which are very

00:25:10,450 --> 00:25:19,779
scalable and very efficient at the same

00:25:14,289 --> 00:25:22,059
time now and I think which I another

00:25:19,779 --> 00:25:25,120
terms which I hear people use it

00:25:22,059 --> 00:25:28,899
interchangeably is the throughput and

00:25:25,120 --> 00:25:31,059
latency again is a very important and

00:25:28,899 --> 00:25:33,610
different especially for distributed

00:25:31,059 --> 00:25:36,460
systems right like for example you may

00:25:33,610 --> 00:25:38,830
hear something like oh yeah my storage

00:25:36,460 --> 00:25:40,870
can handle ten thousand I of the second

00:25:38,830 --> 00:25:45,580
which sounds like fast right

00:25:40,870 --> 00:25:49,630
but and that well may happen with let's

00:25:45,580 --> 00:25:51,909
say five millisecond latency which means

00:25:49,630 --> 00:25:53,980
it will require a lot of concurrent I

00:25:51,909 --> 00:25:57,610
ops to achieve at number and the five

00:25:53,980 --> 00:26:01,210
millisecond latency your storage will

00:25:57,610 --> 00:26:04,809
not be very fast from a storage from a

00:26:01,210 --> 00:26:08,470
user experience right again understand

00:26:04,809 --> 00:26:12,669
the difference between between mmm

00:26:08,470 --> 00:26:15,279
between those things and test to

00:26:12,669 --> 00:26:17,470
understand what exactly you're here

00:26:15,279 --> 00:26:19,659
you're hearing right and why this is

00:26:17,470 --> 00:26:22,840
important because in marketing materials

00:26:19,659 --> 00:26:27,909
you often would hear claims about fro

00:26:22,840 --> 00:26:31,590
put because fro put is easier to reach

00:26:27,909 --> 00:26:35,679
when latency right and especially

00:26:31,590 --> 00:26:39,629
predictable low latency that is a really

00:26:35,679 --> 00:26:41,610
hard problem here is something which is

00:26:39,629 --> 00:26:43,020
relatively unrelated to it

00:26:41,610 --> 00:26:46,559
of presentation but I think that is a

00:26:43,020 --> 00:26:52,620
fantastic picture for many of us to to

00:26:46,559 --> 00:26:55,860
know is the latency right or the timing

00:26:52,620 --> 00:26:57,840
for a different operator different

00:26:55,860 --> 00:26:59,820
operations and if encoder is especially

00:26:57,840 --> 00:27:02,460
cool is if you go to the website they

00:26:59,820 --> 00:27:04,500
have a diagram how those latencies have

00:27:02,460 --> 00:27:08,730
changed through different years so you

00:27:04,500 --> 00:27:12,030
can really see what not every component

00:27:08,730 --> 00:27:12,960
is improving the same speed right

00:27:12,030 --> 00:27:16,230
they're the same rate

00:27:12,960 --> 00:27:19,710
like for example speed of light is not

00:27:16,230 --> 00:27:22,950
getting any faster right so a lot of

00:27:19,710 --> 00:27:26,160
things when transmitting data at

00:27:22,950 --> 00:27:28,380
distance concern you may be you know

00:27:26,160 --> 00:27:30,090
dreaming little bits of latency through

00:27:28,380 --> 00:27:33,030
as it goes through some processing

00:27:30,090 --> 00:27:37,679
hardware but there is very little we can

00:27:33,030 --> 00:27:39,179
do in terms of a distance getting back

00:27:37,679 --> 00:27:42,540
to a specifically speed of light

00:27:39,179 --> 00:27:44,370
limitations that is where you really

00:27:42,540 --> 00:27:49,230
need to consider that for have ability

00:27:44,370 --> 00:27:51,960
choices because the holy grail of high

00:27:49,230 --> 00:27:55,590
ability is to say well you know what I

00:27:51,960 --> 00:27:58,110
want to have a system where I have nodes

00:27:55,590 --> 00:28:01,410
in different countries one and let's say

00:27:58,110 --> 00:28:04,530
us either in Europe third in South

00:28:01,410 --> 00:28:07,500
America right for example so it's really

00:28:04,530 --> 00:28:11,280
reliable right and then I want to make

00:28:07,500 --> 00:28:13,380
sure I have my rights and they're very

00:28:11,280 --> 00:28:16,380
fast as well well it doesn't really work

00:28:13,380 --> 00:28:18,270
with sway right you have to choose if

00:28:16,380 --> 00:28:20,520
you're using a synchronous replication

00:28:18,270 --> 00:28:25,410
in this case propagation will be delayed

00:28:20,520 --> 00:28:30,690
or you will have to pay for latency

00:28:25,410 --> 00:28:34,650
right it's a 1 a 1 / 2 and in many cases

00:28:30,690 --> 00:28:37,080
what makes sense actually is to build

00:28:34,650 --> 00:28:39,179
the cluster for example if in a same

00:28:37,080 --> 00:28:41,549
region multiple availability zone with

00:28:39,179 --> 00:28:43,919
synchronous replication and then for

00:28:41,549 --> 00:28:45,960
disaster recovery use a synchronous

00:28:43,919 --> 00:28:49,049
replication to propagate data to some

00:28:45,960 --> 00:28:53,230
entirely different region in case a

00:28:49,049 --> 00:28:55,120
whole region fails

00:28:53,230 --> 00:28:57,100
especially you need to understand what

00:28:55,120 --> 00:28:58,720
the wide area network so networks which

00:28:57,100 --> 00:29:01,660
operate between different regions

00:28:58,720 --> 00:29:05,620
different continents they are different

00:29:01,660 --> 00:29:09,730
from your local networks they tend not

00:29:05,620 --> 00:29:11,740
to be as as reliable especially when it

00:29:09,730 --> 00:29:13,780
comes to a single packet delivery right

00:29:11,740 --> 00:29:16,990
and you should expect increased jitter

00:29:13,780 --> 00:29:19,360
me and sometimes your latency spikes 10

00:29:16,990 --> 00:29:21,100
times from when it's normal right for

00:29:19,360 --> 00:29:24,850
five minutes and then go back to normal

00:29:21,100 --> 00:29:27,790
or maybe you know things will go down

00:29:24,850 --> 00:29:30,480
for 30 seconds and then recover it's

00:29:27,790 --> 00:29:34,720
normal for wide area networks but it's

00:29:30,480 --> 00:29:37,059
probably not for your local area network

00:29:34,720 --> 00:29:40,870
and you need a special e in data central

00:29:37,059 --> 00:29:45,130
level and you'd need to make sure the

00:29:40,870 --> 00:29:47,440
system you deploy is ready for that and

00:29:45,130 --> 00:29:49,360
I think things which latency drives is

00:29:47,440 --> 00:29:53,290
what the connections to the database are

00:29:49,360 --> 00:29:56,080
expensive especially if you use SSL or

00:29:53,290 --> 00:29:59,110
TLS and the query latency add up

00:29:56,080 --> 00:30:01,900
especially on the real network even in a

00:29:59,110 --> 00:30:03,160
data center not on your local laptop

00:30:01,900 --> 00:30:05,740
right there

00:30:03,160 --> 00:30:08,710
there is almost no latency going from

00:30:05,740 --> 00:30:10,990
your you know nodejs to your database

00:30:08,710 --> 00:30:14,049
server is running and in the same place

00:30:10,990 --> 00:30:17,500
right query latency that is something

00:30:14,049 --> 00:30:19,510
which as example I have seen some

00:30:17,500 --> 00:30:22,030
developers they have extremely high

00:30:19,510 --> 00:30:25,450
number of queries because they just

00:30:22,030 --> 00:30:27,070
don't want to learn SQL features right I

00:30:25,450 --> 00:30:29,410
have seen people instead of having one

00:30:27,070 --> 00:30:32,080
query with maybe a couple of joins to

00:30:29,410 --> 00:30:34,299
fetch at the table they would

00:30:32,080 --> 00:30:37,059
essentially have series of queries for

00:30:34,299 --> 00:30:40,600
every single cell of a table

00:30:37,059 --> 00:30:42,669
very droll and creating tens of

00:30:40,600 --> 00:30:45,130
thousands of queries for a single page

00:30:42,669 --> 00:30:48,250
you write very bad practice very

00:30:45,130 --> 00:30:52,260
inefficient a lot of load on database

00:30:48,250 --> 00:30:55,270
high latency and so on and so forth now

00:30:52,260 --> 00:30:58,090
many frameworks those days they are

00:30:55,270 --> 00:31:00,520
using an OEM called like all object

00:30:58,090 --> 00:31:04,270
relational mapping and some people hate

00:31:00,520 --> 00:31:06,570
or Ram some people absolutely love them

00:31:04,270 --> 00:31:07,950
right reality it is a fun time

00:31:06,570 --> 00:31:10,350
stick to in terms of its allowing

00:31:07,950 --> 00:31:12,269
developers to create a database without

00:31:10,350 --> 00:31:14,130
the need to understand the scale but it

00:31:12,269 --> 00:31:16,440
also can create SQL which is

00:31:14,130 --> 00:31:20,389
horrifically inefficient what is

00:31:16,440 --> 00:31:23,549
important here is what you want to learn

00:31:20,389 --> 00:31:27,679
your framework many of them support

00:31:23,549 --> 00:31:32,850
hints to help the SQL generation and

00:31:27,679 --> 00:31:35,399
also be ready to mine you write SQL if

00:31:32,850 --> 00:31:37,320
there is no choice there are questions

00:31:35,399 --> 00:31:39,179
even the most modern best Orion

00:31:37,320 --> 00:31:41,399
framework where screw up and going to

00:31:39,179 --> 00:31:45,210
have a horrible horrible SQL your

00:31:41,399 --> 00:31:49,500
database will not be able to handle well

00:31:45,210 --> 00:31:52,830
guess what if it can handle it wants it

00:31:49,500 --> 00:31:54,720
won't fly you just need to get rid of

00:31:52,830 --> 00:31:58,799
that SQL and rewrite that manually write

00:31:54,720 --> 00:32:03,899
or tune your OEM framework for the doing

00:31:58,799 --> 00:32:07,529
that another little tip do not leave

00:32:03,899 --> 00:32:09,230
transactions open because open

00:32:07,529 --> 00:32:12,570
transactions are very expensive

00:32:09,230 --> 00:32:15,450
you know bad for database can introduce

00:32:12,570 --> 00:32:20,100
a lot of bad bad side effects so make

00:32:15,450 --> 00:32:22,759
sure to always close transaction right

00:32:20,100 --> 00:32:27,419
when you are interacting with for

00:32:22,759 --> 00:32:30,960
refuser another thing I think which is

00:32:27,419 --> 00:32:33,600
very good to understand for developers

00:32:30,960 --> 00:32:35,129
is understanding what every database

00:32:33,600 --> 00:32:37,590
like actually every system has an

00:32:35,129 --> 00:32:44,039
optimal concurrency right what that

00:32:37,590 --> 00:32:46,379
means is if you let's say create certain

00:32:44,039 --> 00:32:50,190
amount of threads and use the database

00:32:46,379 --> 00:32:53,190
from all those threads it will perform

00:32:50,190 --> 00:32:55,470
at the optimal level if you could create

00:32:53,190 --> 00:32:57,360
much more fred's you know go to

00:32:55,470 --> 00:32:59,940
thousands of ten of thousands of threads

00:32:57,360 --> 00:33:02,610
when performance actually will go down

00:32:59,940 --> 00:33:05,159
because all that effort which is needed

00:33:02,610 --> 00:33:07,500
to coordinate those fred's synchronize

00:33:05,159 --> 00:33:11,909
them and so on and so forth right that

00:33:07,500 --> 00:33:16,289
is the consequence of Gunter's Universal

00:33:11,909 --> 00:33:18,840
scalability law I decided here and you

00:33:16,289 --> 00:33:20,059
better to have idea at least in a high

00:33:18,840 --> 00:33:22,090
level what is that

00:33:20,059 --> 00:33:26,080
optimal concurrency for a database

00:33:22,090 --> 00:33:29,809
typically it's going to be tense or

00:33:26,080 --> 00:33:34,489
maybe hundreds or maybe hundred right o

00:33:29,809 --> 00:33:37,279
of active queries going on at the same

00:33:34,489 --> 00:33:40,309
time it's not going to the thousands now

00:33:37,279 --> 00:33:43,279
how do you deal with that how do you

00:33:40,309 --> 00:33:45,710
keep your database operating and a level

00:33:43,279 --> 00:33:48,219
well you want to make sure what you

00:33:45,710 --> 00:33:52,549
embrace queueing that means what you are

00:33:48,219 --> 00:33:55,359
not sending the quest to they're not

00:33:52,549 --> 00:33:59,839
sending all requests to a database but

00:33:55,359 --> 00:34:03,379
maintaining the optimal concurrency in

00:33:59,839 --> 00:34:06,109
some some case sometimes a vacuum can be

00:34:03,379 --> 00:34:08,869
done from you know normal cute sometimes

00:34:06,109 --> 00:34:10,819
the queueing kind of magically happens

00:34:08,869 --> 00:34:14,089
when you're using the connection pooling

00:34:10,819 --> 00:34:17,240
right so for example if I am developing

00:34:14,089 --> 00:34:21,589
in Java and I limit my connection pool -

00:34:17,240 --> 00:34:24,379
I would say 64 and 128 if you have a

00:34:21,589 --> 00:34:26,029
spiky fellow then I need thousands of

00:34:24,379 --> 00:34:27,950
database connections well I can actually

00:34:26,029 --> 00:34:30,889
wait for a connection to become

00:34:27,950 --> 00:34:32,240
available from a pool right and limit

00:34:30,889 --> 00:34:36,230
that load

00:34:32,240 --> 00:34:42,220
mmm this way or I can use tools like a

00:34:36,230 --> 00:34:44,659
proxy SQL to do that finally in a

00:34:42,220 --> 00:34:51,559
software such as pork on a server or

00:34:44,659 --> 00:34:53,480
MySQL Enterprise there is there a thread

00:34:51,559 --> 00:34:56,809
pool functionality built in then you can

00:34:53,480 --> 00:35:00,829
can essentially do that connection

00:34:56,809 --> 00:35:03,470
pooling on there on the database now on

00:35:00,829 --> 00:35:05,809
a database size if you think about proxy

00:35:03,470 --> 00:35:09,230
SQL and other database technologies

00:35:05,809 --> 00:35:14,329
whereas also similar technologies exist

00:35:09,230 --> 00:35:19,640
like PostgreSQL has tools like PG pool

00:35:14,329 --> 00:35:23,000
PG bound balancer or DC right and few

00:35:19,640 --> 00:35:25,700
hours in general all those practices I

00:35:23,000 --> 00:35:28,940
would sum up like like this right I

00:35:25,700 --> 00:35:31,270
would say they're low of a gravity as it

00:35:28,940 --> 00:35:33,680
applies to application development there

00:35:31,270 --> 00:35:36,350
sheet application at scale

00:35:33,680 --> 00:35:38,440
we'll bring down any database right the

00:35:36,350 --> 00:35:41,810
best humans the most expensive

00:35:38,440 --> 00:35:48,250
open-source commercial doesn't matter

00:35:41,810 --> 00:35:53,560
that is the universal law of gravity

00:35:48,250 --> 00:35:56,930
okay a few more tips a scale matters

00:35:53,560 --> 00:35:58,520
right what you want to make sure is what

00:35:56,930 --> 00:36:00,920
if you're developing and testing of toy

00:35:58,520 --> 00:36:03,230
database you're probably not knowing how

00:36:00,920 --> 00:36:05,410
clear is going to perform in many cases

00:36:03,230 --> 00:36:06,920
it's very convenient right you can do it

00:36:05,410 --> 00:36:08,930
very quickly

00:36:06,920 --> 00:36:10,820
you know reload the database if you need

00:36:08,930 --> 00:36:13,070
and so on as a fall fright but make sure

00:36:10,820 --> 00:36:15,800
you don't go from toy database to

00:36:13,070 --> 00:36:18,620
production make sure you have some

00:36:15,800 --> 00:36:22,160
staging database or whatever which has a

00:36:18,620 --> 00:36:25,130
data set which is a similar size and

00:36:22,160 --> 00:36:27,580
similar kind of a relationship as a

00:36:25,130 --> 00:36:29,980
production database you expect all right

00:36:27,580 --> 00:36:32,750
especially this is important because

00:36:29,980 --> 00:36:35,420
slowest queries may slow down most

00:36:32,750 --> 00:36:37,430
rapidly right and you may see some of

00:36:35,420 --> 00:36:38,960
your bad queries to become a thousand

00:36:37,430 --> 00:36:43,610
times slower when you increase the data

00:36:38,960 --> 00:36:45,680
size only by ten times memory disk that

00:36:43,610 --> 00:36:47,690
is related issue right there if data is

00:36:45,680 --> 00:36:50,690
in memory it's much faster even then

00:36:47,690 --> 00:36:53,240
they're speaking about modern SSDs so if

00:36:50,690 --> 00:36:55,490
you are having a small data set which

00:36:53,240 --> 00:36:57,680
fits in memory or in the test box and

00:36:55,490 --> 00:36:59,840
then you go into much larger data set

00:36:57,680 --> 00:37:02,150
which is additionally it doesn't fit in

00:36:59,840 --> 00:37:03,980
memory require disk i/o performance

00:37:02,150 --> 00:37:08,840
difference schedule be multiplied

00:37:03,980 --> 00:37:12,770
because of that newer is not always

00:37:08,840 --> 00:37:16,610
faster right upgrading to new software

00:37:12,770 --> 00:37:19,610
and hardware now it does not always give

00:37:16,610 --> 00:37:22,070
the performance benefit so make sure to

00:37:19,610 --> 00:37:24,890
test it out in certain cases defaults

00:37:22,070 --> 00:37:26,630
are to blame like for example some of

00:37:24,890 --> 00:37:29,060
the new Linux kernels have became more

00:37:26,630 --> 00:37:32,390
secure by default right the in terms of

00:37:29,060 --> 00:37:34,250
all those you know security issues

00:37:32,390 --> 00:37:37,460
before the processor support over the

00:37:34,250 --> 00:37:42,700
last couple of years but that may also

00:37:37,460 --> 00:37:46,370
made them made them slow right and

00:37:42,700 --> 00:37:48,230
defaults those are often to blame so

00:37:46,370 --> 00:37:51,870
make sure you

00:37:48,230 --> 00:37:52,470
you're dressed you dress it out right

00:37:51,870 --> 00:37:54,900
now

00:37:52,470 --> 00:37:57,870
the upgrades when it comes to a

00:37:54,900 --> 00:38:01,460
databases this is where you store data

00:37:57,870 --> 00:38:05,610
so T so running the database which is

00:38:01,460 --> 00:38:10,050
out of past end-of-life and often not an

00:38:05,610 --> 00:38:11,760
option because of security risks right

00:38:10,050 --> 00:38:15,210
because there may be some security holes

00:38:11,760 --> 00:38:20,060
found and there is no patch coming out

00:38:15,210 --> 00:38:21,300
for for something like MySQL 51 right or

00:38:20,060 --> 00:38:24,420
PostgreSQL

00:38:21,300 --> 00:38:28,350
8 at the same time the major upgrades

00:38:24,420 --> 00:38:32,820
often require application changes so

00:38:28,350 --> 00:38:35,220
make sure to be to be ready for that and

00:38:32,820 --> 00:38:38,070
plan in the life cycle of the

00:38:35,220 --> 00:38:43,140
application team to support with

00:38:38,070 --> 00:38:45,500
database upgrades after the after

00:38:43,140 --> 00:38:51,320
application stop maybe being developed

00:38:45,500 --> 00:38:53,340
developed actively right character sets

00:38:51,320 --> 00:38:55,350
that is another interesting thing

00:38:53,340 --> 00:38:57,900
because it has a huge performance impact

00:38:55,350 --> 00:38:59,850
it's also paying to change after you set

00:38:57,900 --> 00:39:02,490
it and also if you have a wrong

00:38:59,850 --> 00:39:06,930
character set all characters that mix

00:39:02,490 --> 00:39:18,920
match within your application and and

00:39:06,930 --> 00:39:18,920
database right then that can cause there

00:39:20,000 --> 00:39:30,030
because they can cause the data loss

00:39:24,750 --> 00:39:33,390
right here is also an interest in pin

00:39:30,030 --> 00:39:35,040
for MySQL in this case about the impact

00:39:33,390 --> 00:39:38,100
of a character set performance and you

00:39:35,040 --> 00:39:43,250
could see in a MySQL five seven actually

00:39:38,100 --> 00:39:46,740
going from Lawton want utf-8 had a quite

00:39:43,250 --> 00:39:49,380
different for different performance in

00:39:46,740 --> 00:39:54,060
MySQL eight a lot of that performance

00:39:49,380 --> 00:39:59,250
gap was was closed and MySQL eight

00:39:54,060 --> 00:40:00,150
actually has utf-8 or by by default

00:39:59,250 --> 00:40:01,420
right

00:40:00,150 --> 00:40:04,359
my point is are

00:40:01,420 --> 00:40:08,859
it is relating to a change in default

00:40:04,359 --> 00:40:12,250
some people do complain about my SQL aid

00:40:08,859 --> 00:40:13,990
performance in benchmarks but they don't

00:40:12,250 --> 00:40:15,880
recognize that my SQL aid has a

00:40:13,990 --> 00:40:18,339
different default for character set

00:40:15,880 --> 00:40:20,859
actually much better one because so much

00:40:18,339 --> 00:40:22,920
applications use smiles those days right

00:40:20,859 --> 00:40:27,000
and so on and so forth which only

00:40:22,920 --> 00:40:31,059
represented well in utf-8 character set

00:40:27,000 --> 00:40:33,849
enough into to consider is the

00:40:31,059 --> 00:40:35,890
operational overhead in many cases when

00:40:33,849 --> 00:40:39,339
you speak about capacity planning or

00:40:35,890 --> 00:40:40,690
time which is needed it's all focused

00:40:39,339 --> 00:40:43,420
about the normal order database

00:40:40,690 --> 00:40:47,799
operations but if you think about where

00:40:43,420 --> 00:40:51,400
things like the you know the live scale

00:40:47,799 --> 00:40:53,829
database of backups or upgrade even add

00:40:51,400 --> 00:40:56,549
in the table they take time which cost

00:40:53,829 --> 00:40:59,079
money it introduces additional overhead

00:40:56,549 --> 00:41:02,260
variance and you need to make sure is

00:40:59,079 --> 00:41:04,630
enough scale capacity to do that I have

00:41:02,260 --> 00:41:07,000
seen so many people saying well you know

00:41:04,630 --> 00:41:08,890
what we can't actually run backup on our

00:41:07,000 --> 00:41:11,380
database well because when you run

00:41:08,890 --> 00:41:14,559
backup our applications in tips over

00:41:11,380 --> 00:41:16,690
well that is not a good capacity

00:41:14,559 --> 00:41:22,000
planning in practice when you can't

00:41:16,690 --> 00:41:24,819
really can't really run backup on the

00:41:22,000 --> 00:41:26,319
automation now after Meishan is

00:41:24,819 --> 00:41:28,329
something which is interesting right

00:41:26,319 --> 00:41:30,549
from one extent it's of course is

00:41:28,329 --> 00:41:32,799
absolutely master it we are not able

00:41:30,549 --> 00:41:37,660
just to manually install and manage the

00:41:32,799 --> 00:41:40,510
database anymore because many of us have

00:41:37,660 --> 00:41:42,700
to manage way too many databases right

00:41:40,510 --> 00:41:46,119
this way so optimation is critical at

00:41:42,700 --> 00:41:47,980
the same time that means what mistakes

00:41:46,119 --> 00:41:50,470
in the automation can really destroy

00:41:47,980 --> 00:41:55,140
database at scale I have seen so many

00:41:50,470 --> 00:41:57,970
people running the script let's say on

00:41:55,140 --> 00:42:01,410
production instead of test accidentally

00:41:57,970 --> 00:42:05,740
and ruining the database on hundreds of

00:42:01,410 --> 00:42:09,339
instances right what you need to do to

00:42:05,740 --> 00:42:11,500
avoid this is you want to make sure what

00:42:09,339 --> 00:42:13,569
there is a lot of testing done for

00:42:11,500 --> 00:42:15,220
automation framework and practice which

00:42:13,569 --> 00:42:17,740
prevent you from runyan

00:42:15,220 --> 00:42:19,540
other scripts in development production

00:42:17,740 --> 00:42:23,070
some force proxies are pretty simple

00:42:19,540 --> 00:42:25,510
like for example do not use the same

00:42:23,070 --> 00:42:27,760
passwords for developing a production

00:42:25,510 --> 00:42:29,410
that means even if you accidentally

00:42:27,760 --> 00:42:34,780
point your script in their own way

00:42:29,410 --> 00:42:37,630
well it's it'll fail right oh and and

00:42:34,780 --> 00:42:39,730
also make sure your QA do code reviews

00:42:37,630 --> 00:42:43,390
right and so on on your automation from

00:42:39,730 --> 00:42:49,030
a framework because it is needs to be

00:42:43,390 --> 00:42:52,090
absolutely solid then we are finished

00:42:49,030 --> 00:42:54,849
enough with our security right

00:42:52,090 --> 00:42:56,670
but databases is very most the sensitive

00:42:54,849 --> 00:43:01,330
data tends to live right I think that is

00:42:56,670 --> 00:43:03,490
pretty obvious and taking care of that

00:43:01,330 --> 00:43:06,240
data is a shared responsibility of devs

00:43:03,490 --> 00:43:08,320
and ops in so many times I've seen

00:43:06,240 --> 00:43:10,810
developer thinking well database

00:43:08,320 --> 00:43:14,800
security is OP suspense ability they

00:43:10,810 --> 00:43:16,810
change password replace it they patch it

00:43:14,800 --> 00:43:18,400
and so on and so forth right but that

00:43:16,810 --> 00:43:21,869
doesn't quite work with say for example

00:43:18,400 --> 00:43:27,160
SQL injections and other bugs which come

00:43:21,869 --> 00:43:29,770
therefore with buggy applications they

00:43:27,160 --> 00:43:32,800
cannot be efficiently solved by Oaks

00:43:29,770 --> 00:43:35,980
people right we need to have make sure

00:43:32,800 --> 00:43:39,250
that security conversation is head and

00:43:35,980 --> 00:43:44,290
there's an observer 'king working

00:43:39,250 --> 00:43:47,140
together to resolve it ok with that I

00:43:44,290 --> 00:43:47,560
also had a couple of announcements to

00:43:47,140 --> 00:43:49,780
make

00:43:47,560 --> 00:43:52,930
now if you really want to learn more

00:43:49,780 --> 00:43:56,280
about the databases greater corner also

00:43:52,930 --> 00:43:59,890
taken our conference online next week as

00:43:56,280 --> 00:44:03,030
Turkana live online and that will be the

00:43:59,890 --> 00:44:05,290
sindelle track 24-hour around the world

00:44:03,030 --> 00:44:08,320
event so we're doing a really different

00:44:05,290 --> 00:44:11,560
format but I think that's going to be a

00:44:08,320 --> 00:44:14,410
lot of fun so check it out and register

00:44:11,560 --> 00:44:19,510
if you like we have speakers from a lot

00:44:14,410 --> 00:44:22,000
of a very very cool company right and

00:44:19,510 --> 00:44:24,910
we'll also share some new developments

00:44:22,000 --> 00:44:28,089
in with your corner software and also I

00:44:24,910 --> 00:44:28,580
have a little favor to ask we are doing

00:44:28,089 --> 00:44:34,460
the

00:44:28,580 --> 00:44:36,740
open-source database theory right they

00:44:34,460 --> 00:44:39,800
really want to know how you using the

00:44:36,740 --> 00:44:44,720
open-source database so we can now help

00:44:39,800 --> 00:44:46,970
you you know will will help us to serve

00:44:44,720 --> 00:44:49,250
you better to be more focused on

00:44:46,970 --> 00:44:52,190
software development and also we are

00:44:49,250 --> 00:44:54,560
going to share on all the results under

00:44:52,190 --> 00:44:57,320
a Creative Commons license right so

00:44:54,560 --> 00:44:59,960
there is a link yeah I think you have

00:44:57,320 --> 00:45:03,200
like a five minutes before closing

00:44:59,960 --> 00:45:06,350
keynotes if you open it up on the side

00:45:03,200 --> 00:45:12,980
and complete right now I would not mind

00:45:06,350 --> 00:45:19,370
and if that's the fat I had a comment a

00:45:12,980 --> 00:45:21,760
question from Debbie yes I think the

00:45:19,370 --> 00:45:26,990
point here on whatever it's Postgres or

00:45:21,760 --> 00:45:29,240
other databases it did the old version

00:45:26,990 --> 00:45:33,860
they tend to have a very high stability

00:45:29,240 --> 00:45:38,060
and maturity but sooner or later they

00:45:33,860 --> 00:45:40,760
are not going to be getting bug fixes

00:45:38,060 --> 00:45:43,880
right even security by security bug

00:45:40,760 --> 00:45:48,340
fixes and that means if something

00:45:43,880 --> 00:45:51,200
something change changes that becomes

00:45:48,340 --> 00:45:54,710
problematic right having said that I

00:45:51,200 --> 00:45:57,260
think there is a lot or for PostgreSQL

00:45:54,710 --> 00:46:00,410
MySQL replication which applications

00:45:57,260 --> 00:46:04,100
which have been you know working fine on

00:46:00,410 --> 00:46:10,250
the database which is like 10 years old

00:46:04,100 --> 00:46:14,720
so old plus right they just I don't have

00:46:10,250 --> 00:46:16,550
to follow that the security compliance

00:46:14,720 --> 00:46:22,340
practices right or just have been like

00:46:16,550 --> 00:46:25,730
you okay well so Nancy what a probe I

00:46:22,340 --> 00:46:27,730
think I am pretty much out of time here

00:46:25,730 --> 00:46:33,370
there is a few minutes for you to

00:46:27,730 --> 00:46:37,940
transition to their closing remarks at

00:46:33,370 --> 00:46:40,530
4:50 Eastern ok Thank You Nick I am glad

00:46:37,940 --> 00:46:47,570
you like the talk

00:46:40,530 --> 00:46:52,350
thank mikaël Tina and so many so many

00:46:47,570 --> 00:46:55,470
others oh yeah

00:46:52,350 --> 00:46:57,690
Thank You Abdul for acknowledging a

00:46:55,470 --> 00:47:01,320
problem on same posture and development

00:46:57,690 --> 00:47:08,310
and production that's really takes guts

00:47:01,320 --> 00:47:08,610
to do it in public okay well thank you

00:47:08,310 --> 00:47:13,070
everyone

00:47:08,610 --> 00:47:13,070

YouTube URL: https://www.youtube.com/watch?v=HOho4HyKqTE


