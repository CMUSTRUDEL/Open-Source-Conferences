Title: All Things Open 2015 | Yehuda Katz - Tilde | Ember.js
Publication date: 2015-11-19
Playlist: All Things Open 2015
Description: 
	All Things Open 2015, October 19th and 20th, Raleigh NC.
Captions: 
	00:00:00,000 --> 00:00:09,990
I guess before I start raised around if

00:00:06,839 --> 00:00:11,309
you already use ember okay so like most

00:00:09,990 --> 00:00:13,530
people here aren't already using ember

00:00:11,309 --> 00:00:18,240
so in fact the title of my talk is is

00:00:13,530 --> 00:00:20,039
relevant so I actually find myself when

00:00:18,240 --> 00:00:23,130
I give talks about ember sort of going

00:00:20,039 --> 00:00:25,140
back and forth between giving the talk

00:00:23,130 --> 00:00:27,449
looks like a demo of ember which is not

00:00:25,140 --> 00:00:29,369
what I'm doing today and doing something

00:00:27,449 --> 00:00:32,669
that I find said I have to do at all

00:00:29,369 --> 00:00:34,230
which is to be sometimes the heels of

00:00:32,669 --> 00:00:35,910
like the lonely job of being the

00:00:34,230 --> 00:00:39,149
defender of abstractions in front end

00:00:35,910 --> 00:00:40,559
JavaScript and I say that it's easy to

00:00:39,149 --> 00:00:42,450
laugh at that and say of course everyone

00:00:40,559 --> 00:00:44,969
agrees abstractions are a good idea we

00:00:42,450 --> 00:00:47,309
should have shared solutions etc but for

00:00:44,969 --> 00:00:49,500
some reason in especially the case in

00:00:47,309 --> 00:00:51,530
front of JavaScript but it's just a

00:00:49,500 --> 00:00:53,489
flashy idea in general the idea that

00:00:51,530 --> 00:00:55,530
abstractions are the thing that has have

00:00:53,489 --> 00:00:57,210
gotten us down abstractions of the

00:00:55,530 --> 00:00:59,129
reason why I would exhaust abstractions

00:00:57,210 --> 00:01:00,449
are the reason why you struggle really

00:00:59,129 --> 00:01:02,010
what you should do is every application

00:01:00,449 --> 00:01:04,979
should build everything from scratch and

00:01:02,010 --> 00:01:06,689
I find myself often defending the

00:01:04,979 --> 00:01:09,119
position that that is not really correct

00:01:06,689 --> 00:01:10,229
and today I'm going to sort of do that

00:01:09,119 --> 00:01:14,540
at a higher level i'm going to talk

00:01:10,229 --> 00:01:17,150
about what things like ember do for you

00:01:14,540 --> 00:01:20,280
across a whole variety of different

00:01:17,150 --> 00:01:22,830
situations so the first thing is that in

00:01:20,280 --> 00:01:24,570
order to understand writing software in

00:01:22,830 --> 00:01:25,890
general and your own experiences so i've

00:01:24,570 --> 00:01:27,750
been writing software now for 10 years

00:01:25,890 --> 00:01:29,310
for the first like three years I said

00:01:27,750 --> 00:01:30,570
surprisingly I have not only the rent

00:01:29,310 --> 00:01:32,150
software for three years now I've ready

00:01:30,570 --> 00:01:34,229
for 10 years I can't say that anymore

00:01:32,150 --> 00:01:34,979
but I've been writing software for 10

00:01:34,229 --> 00:01:36,329
years there are people who have a

00:01:34,979 --> 00:01:38,939
writing software a lot longer than that

00:01:36,329 --> 00:01:40,530
and probably the biggest breakthrough

00:01:38,939 --> 00:01:41,939
that I personally had about software

00:01:40,530 --> 00:01:43,920
writing is to understand the concept of

00:01:41,939 --> 00:01:46,680
cognitive depletion and that's the idea

00:01:43,920 --> 00:01:48,270
that you have a certain amount of

00:01:46,680 --> 00:01:49,890
cognitive resources your brain has a

00:01:48,270 --> 00:01:51,840
certain amount of power in it basically

00:01:49,890 --> 00:01:53,250
and a bunch of different things depleted

00:01:51,840 --> 00:01:56,520
this is very good science around this

00:01:53,250 --> 00:01:58,259
and things that depleted are things that

00:01:56,520 --> 00:02:01,950
don't seem very connected things like

00:01:58,259 --> 00:02:03,630
solving making trivial decisions or

00:02:01,950 --> 00:02:05,130
having an argument those two things

00:02:03,630 --> 00:02:07,259
actually draw from the same pool so if

00:02:05,130 --> 00:02:07,860
you have an argument with your wife in

00:02:07,259 --> 00:02:09,090
the morning

00:02:07,860 --> 00:02:10,920
and then go to work and have to make a

00:02:09,090 --> 00:02:12,660
trivial decision it turns out that the

00:02:10,920 --> 00:02:14,010
set of resources that you have to use to

00:02:12,660 --> 00:02:15,810
make the trivial decision are already

00:02:14,010 --> 00:02:18,390
depleted it doesn't seem connected but

00:02:15,810 --> 00:02:20,910
what it is and really the hard thing

00:02:18,390 --> 00:02:22,500
about writing software is that because a

00:02:20,910 --> 00:02:24,180
lot of software is written when we are

00:02:22,500 --> 00:02:26,190
in a cognitively depleted state you know

00:02:24,180 --> 00:02:27,870
you write one-fifth of all your software

00:02:26,190 --> 00:02:30,780
on Friday and one-fifth of all your

00:02:27,870 --> 00:02:32,460
software after two or three pm right a

00:02:30,780 --> 00:02:34,200
lot of your software is written in a

00:02:32,460 --> 00:02:35,640
cognitively depleted sake we really

00:02:34,200 --> 00:02:37,110
can't get away with requiring ourselves

00:02:35,640 --> 00:02:40,680
to be perfect all the time so really the

00:02:37,110 --> 00:02:43,140
argument against abstractions a lot of

00:02:40,680 --> 00:02:44,550
times is that well if we just decide

00:02:43,140 --> 00:02:46,500
what is the right way to write software

00:02:44,550 --> 00:02:47,760
if we tell everyone what the right way

00:02:46,500 --> 00:02:50,280
is well give people a style driver

00:02:47,760 --> 00:02:51,540
patterns buffer then we can just make

00:02:50,280 --> 00:02:53,580
sure that all the developers on your

00:02:51,540 --> 00:02:54,690
team and you when you're tired always do

00:02:53,580 --> 00:02:56,310
the right thing but in practice you

00:02:54,690 --> 00:02:58,410
cannot do that in practice nobody's

00:02:56,310 --> 00:02:59,820
perfect and even if you think you're

00:02:58,410 --> 00:03:00,780
personally perfect and you could do the

00:02:59,820 --> 00:03:03,390
right thing every minute of every day

00:03:00,780 --> 00:03:05,970
what about the rest of your team so I'd

00:03:03,390 --> 00:03:07,980
like to say sloppy code is basically

00:03:05,970 --> 00:03:09,780
just physics of software development you

00:03:07,980 --> 00:03:12,450
can't legislate it away you can't make

00:03:09,780 --> 00:03:14,549
it disappear by simply trying to say by

00:03:12,450 --> 00:03:17,459
Fiat nobody on my team is allowed to

00:03:14,549 --> 00:03:19,650
write sloppy code it's just how it is so

00:03:17,459 --> 00:03:21,209
what do we do how do we deal with the

00:03:19,650 --> 00:03:23,670
fact that floppy code is a law of

00:03:21,209 --> 00:03:24,900
physics so it turns out that we've been

00:03:23,670 --> 00:03:27,900
struggling with this from the beginning

00:03:24,900 --> 00:03:30,840
from literally the very beginning and

00:03:27,900 --> 00:03:33,209
the answer for how we deal with sloppy

00:03:30,840 --> 00:03:34,880
code is some kind of isolation mechanism

00:03:33,209 --> 00:03:37,799
so in the very very beginning the first

00:03:34,880 --> 00:03:39,750
software was ever written was basically

00:03:37,799 --> 00:03:41,730
a series of machine instructions all of

00:03:39,750 --> 00:03:42,989
which were written flat right so a big

00:03:41,730 --> 00:03:44,400
program it's just a bunch of the scene

00:03:42,989 --> 00:03:45,870
machine instructions if you want to do

00:03:44,400 --> 00:03:47,820
something in a loop no problem just jump

00:03:45,870 --> 00:03:49,820
back to where it started from use some

00:03:47,820 --> 00:03:52,110
structures that let you jump away etc

00:03:49,820 --> 00:03:54,450
but over time what happened is people

00:03:52,110 --> 00:03:55,530
said well if I do that then every line

00:03:54,450 --> 00:03:56,190
of code has to know about every other

00:03:55,530 --> 00:03:58,290
one

00:03:56,190 --> 00:03:59,220
very annoying so instead what we're

00:03:58,290 --> 00:04:01,050
going to do is we're going to create the

00:03:59,220 --> 00:04:02,880
concept of a function function is a

00:04:01,050 --> 00:04:04,470
piece of code that you can be a little

00:04:02,880 --> 00:04:06,390
sloppy inside of because you know that

00:04:04,470 --> 00:04:07,980
the sloppiness inside of it doesn't leak

00:04:06,390 --> 00:04:10,380
out so things like the concept of

00:04:07,980 --> 00:04:11,400
lexical scope are really big

00:04:10,380 --> 00:04:13,350
improvements to software development

00:04:11,400 --> 00:04:15,570
purely because of the fact that they let

00:04:13,350 --> 00:04:16,890
you be a little bit sloppy inside the

00:04:15,570 --> 00:04:18,959
area of code without messing with

00:04:16,890 --> 00:04:21,120
everything else so really the hard the

00:04:18,959 --> 00:04:22,620
thing that helps us write software in a

00:04:21,120 --> 00:04:23,970
scalable and I don't mean you know

00:04:22,620 --> 00:04:25,290
scalable crossing machines I just mean

00:04:23,970 --> 00:04:27,150
you can write a lot of software and have

00:04:25,290 --> 00:04:30,090
it run in a single program how do you

00:04:27,150 --> 00:04:31,770
write Photoshop the way that we do that

00:04:30,090 --> 00:04:33,750
is by breaking things up into pieces

00:04:31,770 --> 00:04:36,540
that we know can't really mess with each

00:04:33,750 --> 00:04:39,660
other so a good example of this in the

00:04:36,540 --> 00:04:41,670
domain that word in this room for is in

00:04:39,660 --> 00:04:44,820
basically every web framework components

00:04:41,670 --> 00:04:46,380
own a Dom element right now in the DOM

00:04:44,820 --> 00:04:48,870
is a big blob of shared mutable state

00:04:46,380 --> 00:04:50,340
just like your system resources on and

00:04:48,870 --> 00:04:51,600
not in an operating system is a big blob

00:04:50,340 --> 00:04:53,460
of shared mutable state right when you

00:04:51,600 --> 00:04:55,440
read from a socket the socket is a

00:04:53,460 --> 00:04:57,680
virtual thing in reality there's

00:04:55,440 --> 00:05:01,110
something real that everybody is sharing

00:04:57,680 --> 00:05:03,120
but in the web framework the framework

00:05:01,110 --> 00:05:04,860
or the library is responsible for

00:05:03,120 --> 00:05:06,120
slicing up the big blob with shared

00:05:04,860 --> 00:05:07,650
mutable state which is the entire Tom

00:05:06,120 --> 00:05:10,740
and giving each component just one

00:05:07,650 --> 00:05:14,250
element to write so this is how it works

00:05:10,740 --> 00:05:17,100
an ember you subclass from member

00:05:14,250 --> 00:05:18,870
components using es6 and sexy or so in

00:05:17,100 --> 00:05:21,740
today's amber world basically everything

00:05:18,870 --> 00:05:24,120
use es6 we ship that will by default etc

00:05:21,740 --> 00:05:26,760
anyway so here we have a subclass of

00:05:24,120 --> 00:05:29,370
amber are components and the dynastar

00:05:26,760 --> 00:05:31,800
elements hook basically gets called and

00:05:29,370 --> 00:05:33,510
inside of it you have access to this dot

00:05:31,800 --> 00:05:35,940
dollar or the stun elements and both

00:05:33,510 --> 00:05:37,110
those things are restricted to just the

00:05:35,940 --> 00:05:38,490
element that you're supposed to be

00:05:37,110 --> 00:05:41,580
writing on and actually in this case

00:05:38,490 --> 00:05:43,500
what's interesting is that there's

00:05:41,580 --> 00:05:45,840
nothing stopping you from saying dot

00:05:43,500 --> 00:05:47,490
parent or like going into one of your

00:05:45,840 --> 00:05:48,990
child components you can absolutely do

00:05:47,490 --> 00:05:51,120
that and that is absolutely a thing that

00:05:48,990 --> 00:05:52,290
you can mess up with but even just

00:05:51,120 --> 00:05:53,730
adding a little bit of friction that

00:05:52,290 --> 00:05:54,930
tells you the right thing to do here is

00:05:53,730 --> 00:05:57,180
to work with your element not somebody

00:05:54,930 --> 00:05:58,800
else's element helps a lot it helps it

00:05:57,180 --> 00:06:00,990
helps people right Soph components that

00:05:58,800 --> 00:06:02,520
are isolated from each other without the

00:06:00,990 --> 00:06:04,140
problem of you know all of a sudden

00:06:02,520 --> 00:06:04,740
everyone has to worry about every other

00:06:04,140 --> 00:06:06,720
component

00:06:04,740 --> 00:06:09,060
me the biggest question that I asked to

00:06:06,720 --> 00:06:11,400
November successful when I go into a big

00:06:09,060 --> 00:06:13,919
project so few weeks ago I went to

00:06:11,400 --> 00:06:15,360
intercom which has a pretty big amber

00:06:13,919 --> 00:06:16,560
app and I looked at their code base i

00:06:15,360 --> 00:06:18,240
basically the full auditor their code

00:06:16,560 --> 00:06:21,539
base and one of the questions that I ask

00:06:18,240 --> 00:06:23,099
myself is not for a particular screen or

00:06:21,539 --> 00:06:26,039
particular component is this component

00:06:23,099 --> 00:06:27,630
good is it well written is it fast those

00:06:26,039 --> 00:06:29,280
are all good questions but those are

00:06:27,630 --> 00:06:32,280
pretty generic the question I asked

00:06:29,280 --> 00:06:34,289
myself an emperor is does this composite

00:06:32,280 --> 00:06:35,759
component here mess with this component

00:06:34,289 --> 00:06:36,979
over here does this screen over here

00:06:35,759 --> 00:06:39,389
mess with this screen over there and

00:06:36,979 --> 00:06:40,500
generally speaking they emphasize of

00:06:39,389 --> 00:06:41,970
abstraction that we give you an ember

00:06:40,500 --> 00:06:43,409
mean that no matter how messy a

00:06:41,970 --> 00:06:45,360
particular screen or particular

00:06:43,409 --> 00:06:46,470
component got the answer is almost

00:06:45,360 --> 00:06:49,470
always it does not mess with another

00:06:46,470 --> 00:06:52,050
screen or another component and that's

00:06:49,470 --> 00:06:54,569
source of pride for me um so

00:06:52,050 --> 00:06:56,280
fundamentally what this example shows is

00:06:54,569 --> 00:06:58,830
that frameworks help you resolve this

00:06:56,280 --> 00:07:01,590
poor tension between a desire for

00:06:58,830 --> 00:07:03,240
isolation desired to have little pieces

00:07:01,590 --> 00:07:04,919
that you can get you know if you give an

00:07:03,240 --> 00:07:06,360
intern please write this component and

00:07:04,919 --> 00:07:07,789
know that they're not messing with the

00:07:06,360 --> 00:07:10,680
rest of the world and the fact that

00:07:07,789 --> 00:07:12,539
applications all applications across all

00:07:10,680 --> 00:07:14,250
domains are fundamentally operating on a

00:07:12,539 --> 00:07:15,990
blog of mutable state the reason why

00:07:14,250 --> 00:07:18,000
this is true is because there is always

00:07:15,990 --> 00:07:19,710
something in the real world you were

00:07:18,000 --> 00:07:21,719
trying to do right if your application

00:07:19,710 --> 00:07:23,250
had nothing to do with the real world it

00:07:21,719 --> 00:07:24,690
would be a very boring application with

00:07:23,250 --> 00:07:26,969
run in an ivory tower somewhere but it

00:07:24,690 --> 00:07:28,740
wouldn't matter at minimum time is the

00:07:26,969 --> 00:07:30,719
thing that exists in all programs right

00:07:28,740 --> 00:07:32,009
so there's always some kind of shared

00:07:30,719 --> 00:07:33,840
mutable state that exists that you were

00:07:32,009 --> 00:07:35,190
operating against and there's a tension

00:07:33,840 --> 00:07:36,569
between the fact that that is a real

00:07:35,190 --> 00:07:38,159
thing that exists in the real world and

00:07:36,569 --> 00:07:41,130
the fact that in order to get a good do

00:07:38,159 --> 00:07:43,289
a good job with programming and having a

00:07:41,130 --> 00:07:47,370
team and having bad days you really need

00:07:43,289 --> 00:07:50,430
some kind of isolation and probably a

00:07:47,370 --> 00:07:51,479
really good analogy to this is memory

00:07:50,430 --> 00:07:53,159
and I'm going to have a bunch of

00:07:51,479 --> 00:07:54,650
analogies here is memory and an

00:07:53,159 --> 00:07:56,849
operating system right so the very first

00:07:54,650 --> 00:07:59,819
operating systems didn't do anything

00:07:56,849 --> 00:08:01,889
special memory there was just I'm so

00:07:59,819 --> 00:08:02,940
there's 640k although there were periods

00:08:01,889 --> 00:08:04,680
of time when it was less but there was a

00:08:02,940 --> 00:08:06,930
long time where 640k was the amount of

00:08:04,680 --> 00:08:07,750
memory that existed and you just that

00:08:06,930 --> 00:08:09,250
was the main memory

00:08:07,750 --> 00:08:12,100
in every application just dealt with the

00:08:09,250 --> 00:08:13,870
same 640k and if you were like I have a

00:08:12,100 --> 00:08:15,250
game it means all the 640k you would

00:08:13,870 --> 00:08:16,240
just like put in a floppy disk and it

00:08:15,250 --> 00:08:17,230
wouldn't boot up and then it would be

00:08:16,240 --> 00:08:20,980
the operating system you would have

00:08:17,230 --> 00:08:23,680
always 640k right and the thing once we

00:08:20,980 --> 00:08:25,210
got out of having only 6 40 k which is a

00:08:23,680 --> 00:08:27,580
very small amount of memory in today's

00:08:25,210 --> 00:08:29,230
terms it's a very lot of Madam at that

00:08:27,580 --> 00:08:31,480
time today's service is very small

00:08:29,230 --> 00:08:33,490
amounts is we said instead of having

00:08:31,480 --> 00:08:35,860
every application work with the same big

00:08:33,490 --> 00:08:37,599
64 the same blob of memory we're going

00:08:35,860 --> 00:08:40,030
to give each application each process a

00:08:37,599 --> 00:08:41,890
slice of memory that it could pretend is

00:08:40,030 --> 00:08:43,450
to all the memory in the world right so

00:08:41,890 --> 00:08:44,830
when you're in the process and you've

00:08:43,450 --> 00:08:46,240
probably experienced this at some point

00:08:44,830 --> 00:08:47,350
you don't have to worry about where the

00:08:46,240 --> 00:08:48,580
memory is you don't have to care maybe

00:08:47,350 --> 00:08:50,440
it's swapped off to this you'll have to

00:08:48,580 --> 00:08:51,730
care about that right you just pretend

00:08:50,440 --> 00:08:53,230
you have a slice of logging there where

00:08:51,730 --> 00:08:54,460
you ask the allocator for some memory

00:08:53,230 --> 00:08:56,290
and give me a megabyte you get it you

00:08:54,460 --> 00:08:58,600
work with it starts from zero and ends

00:08:56,290 --> 00:09:00,370
at a megaphone right and that that is

00:08:58,600 --> 00:09:01,510
solving a similar my problem where we

00:09:00,370 --> 00:09:03,220
would like to be able to let people

00:09:01,510 --> 00:09:04,840
write processes that don't mess with

00:09:03,220 --> 00:09:06,490
each other we don't want my little

00:09:04,840 --> 00:09:07,990
program to mess with chrome because that

00:09:06,490 --> 00:09:10,480
would be very bad cific chrome

00:09:07,990 --> 00:09:12,850
developers are much better than me but

00:09:10,480 --> 00:09:15,610
we do need Zoe so we don't we need

00:09:12,850 --> 00:09:17,710
isolation but we also in reality are

00:09:15,610 --> 00:09:22,030
working on a real blob of memory that

00:09:17,710 --> 00:09:23,230
exists in the real world right so now

00:09:22,030 --> 00:09:25,420
one of the things that's interesting is

00:09:23,230 --> 00:09:28,060
so you could just say imagine you're

00:09:25,420 --> 00:09:29,080
writing an operating system you could

00:09:28,060 --> 00:09:30,190
just say every time someone has to

00:09:29,080 --> 00:09:32,230
remember I'm just going to slice the

00:09:30,190 --> 00:09:33,700
next megabyte and give it to them but

00:09:32,230 --> 00:09:36,330
the problem is if you do it like this

00:09:33,700 --> 00:09:38,290
what's going to happen is there's a

00:09:36,330 --> 00:09:39,700
hypothetical optimizations that you can

00:09:38,290 --> 00:09:42,010
do you could for example notice that an

00:09:39,700 --> 00:09:43,330
application isn't running anymore hasn't

00:09:42,010 --> 00:09:45,250
asked it hasn't done anything in a while

00:09:43,330 --> 00:09:47,110
you could hypothetically take that

00:09:45,250 --> 00:09:49,750
memory to give it to somebody else but

00:09:47,110 --> 00:09:50,830
in order to do that you really there's

00:09:49,750 --> 00:09:52,900
sort of this tension because the

00:09:50,830 --> 00:09:54,970
application the one that asks for the

00:09:52,900 --> 00:09:56,680
memory that isn't around anymore doesn't

00:09:54,970 --> 00:09:58,600
really know that it's part of this big

00:09:56,680 --> 00:10:00,580
world right so you can't give any

00:09:58,600 --> 00:10:02,650
individual application responsibility

00:10:00,580 --> 00:10:04,750
for these kinds of optimizations because

00:10:02,650 --> 00:10:06,100
the whole point of the solution that we

00:10:04,750 --> 00:10:07,630
just described is that they don't know

00:10:06,100 --> 00:10:09,580
that they're part of a big world right

00:10:07,630 --> 00:10:11,950
so the whole idea behind isolation is

00:10:09,580 --> 00:10:13,570
you think you're the whole world but in

00:10:11,950 --> 00:10:14,980
reality or not the whole world and if

00:10:13,570 --> 00:10:18,040
you try to just slice things up and give

00:10:14,980 --> 00:10:19,300
people little chunks what ends up

00:10:18,040 --> 00:10:21,459
is that you end up with duplicated work

00:10:19,300 --> 00:10:23,320
you end up with global optimization that

00:10:21,459 --> 00:10:25,480
you could in theory do that you can't do

00:10:23,320 --> 00:10:26,620
anymore and so what's kind of

00:10:25,480 --> 00:10:28,180
interesting is that this is a real

00:10:26,620 --> 00:10:29,740
tension that exists in pretty much all

00:10:28,180 --> 00:10:33,100
domains and one of the first things that

00:10:29,740 --> 00:10:35,259
happens is that people say the problem

00:10:33,100 --> 00:10:36,940
is abstraction the problem is

00:10:35,259 --> 00:10:39,069
abstraction the problem is you're making

00:10:36,940 --> 00:10:41,259
me work against a system that is giving

00:10:39,069 --> 00:10:42,880
me a little blob of memory if you just

00:10:41,259 --> 00:10:44,259
let me control the whole universe then I

00:10:42,880 --> 00:10:46,630
can do a better job than your stupid

00:10:44,259 --> 00:10:49,480
colonel and so this is the idea behind

00:10:46,630 --> 00:10:50,949
life the XO curls is I can do a better

00:10:49,480 --> 00:10:56,500
job in your stupid Colonel if you just

00:10:50,949 --> 00:10:57,730
gave me all the power and I sort of i

00:10:56,500 --> 00:10:59,500
think that this is sort of missing the

00:10:57,730 --> 00:11:00,730
point and I'll to illustrate it I want

00:10:59,500 --> 00:11:02,470
to use a different example which is

00:11:00,730 --> 00:11:03,639
sockets in an operating system so I

00:11:02,470 --> 00:11:05,170
already sort of talked about the fact

00:11:03,639 --> 00:11:06,399
that there's a global optimization with

00:11:05,170 --> 00:11:07,660
memory where you can start reusing

00:11:06,399 --> 00:11:10,089
things that aren't heavily in used

00:11:07,660 --> 00:11:13,240
sockets are another example is which is

00:11:10,089 --> 00:11:15,180
if you want to open a socket and read

00:11:13,240 --> 00:11:18,009
from it of course from an IT perspective

00:11:15,180 --> 00:11:20,199
you can open the socket to connect to

00:11:18,009 --> 00:11:21,339
another server read some data you can

00:11:20,199 --> 00:11:22,630
read it that whenever you want you can

00:11:21,339 --> 00:11:25,389
read it into your buffer or whatever is

00:11:22,630 --> 00:11:27,040
great but in reality in on any given

00:11:25,389 --> 00:11:29,260
system there's usually many many many

00:11:27,040 --> 00:11:31,839
open sockets or files at a given time

00:11:29,260 --> 00:11:33,399
reading a whole bunch of there in a

00:11:31,839 --> 00:11:34,959
whole bunch of different ways and the

00:11:33,399 --> 00:11:37,899
right way to do that across the entire

00:11:34,959 --> 00:11:39,819
system is to have a shared buffer that's

00:11:37,899 --> 00:11:41,709
global right so you have one global

00:11:39,819 --> 00:11:43,810
shared buffer and somebody somewhere

00:11:41,709 --> 00:11:45,699
says oh I see that all these 50

00:11:43,810 --> 00:11:47,760
processes of ask for data instead of

00:11:45,699 --> 00:11:50,050
having 50 open buffers for all 50

00:11:47,760 --> 00:11:51,519
request I'll wait until I have some data

00:11:50,050 --> 00:11:52,720
I'll read it into my shared buffer and

00:11:51,519 --> 00:11:56,050
then I'll give it to the user when they

00:11:52,720 --> 00:11:57,519
ask for and the problem is that so this

00:11:56,050 --> 00:11:59,649
is an optimization that pretty much all

00:11:57,519 --> 00:12:02,680
modern operating systems based on unix

00:11:59,649 --> 00:12:05,110
do but it's an optimization that you

00:12:02,680 --> 00:12:06,910
fundamentally cannot do in a process

00:12:05,110 --> 00:12:08,380
because the process does not know about

00:12:06,910 --> 00:12:10,600
the other process so there's really no

00:12:08,380 --> 00:12:12,760
way for my process and your process to

00:12:10,600 --> 00:12:14,199
say I know that we're both waiting for

00:12:12,760 --> 00:12:16,360
some memory I know that we're both

00:12:14,199 --> 00:12:18,759
waiting for some for some data from the

00:12:16,360 --> 00:12:20,170
from the server from another server just

00:12:18,759 --> 00:12:21,189
share a single buffer because we're not

00:12:20,170 --> 00:12:22,300
allowed to know about each other's

00:12:21,189 --> 00:12:23,350
buffers we're not allowed to know about

00:12:22,300 --> 00:12:25,520
each other's remember we're not allowed

00:12:23,350 --> 00:12:27,200
to know about each other songs and this

00:12:25,520 --> 00:12:28,790
fundamentally just a conflict between

00:12:27,200 --> 00:12:30,140
the fact that weed is very important

00:12:28,790 --> 00:12:31,250
that I cannot know about your process

00:12:30,140 --> 00:12:32,720
that we are not allowed to know about

00:12:31,250 --> 00:12:34,790
other that's how the security system

00:12:32,720 --> 00:12:36,920
works that's how just not not only

00:12:34,790 --> 00:12:38,900
security but just having programs that

00:12:36,920 --> 00:12:40,040
actually work it can scale and I could

00:12:38,900 --> 00:12:41,120
download a program about the internet

00:12:40,040 --> 00:12:42,920
and running on my computer and not have

00:12:41,120 --> 00:12:44,270
to crash my web browser right that is

00:12:42,920 --> 00:12:45,830
fundamentally the process isolation

00:12:44,270 --> 00:12:48,140
model is important but also

00:12:45,830 --> 00:12:49,790
fundamentally we're working on real

00:12:48,140 --> 00:12:51,110
things that exist in the real world we

00:12:49,790 --> 00:12:53,990
need to find some way of doing the

00:12:51,110 --> 00:12:55,160
global optimization another example is

00:12:53,990 --> 00:12:57,200
method calls in a programming language

00:12:55,160 --> 00:12:58,850
and all eventually get back to how this

00:12:57,200 --> 00:13:01,430
all ties together to web frameworks but

00:12:58,850 --> 00:13:02,660
in a programming language if you have a

00:13:01,430 --> 00:13:03,980
function that calls a function of calls

00:13:02,660 --> 00:13:05,180
a function that calls a function it's

00:13:03,980 --> 00:13:07,160
very important that each of those

00:13:05,180 --> 00:13:08,660
functions doesn't know that they're

00:13:07,160 --> 00:13:10,160
actually running inside of a particular

00:13:08,660 --> 00:13:11,300
context right so when you write a

00:13:10,160 --> 00:13:13,190
function it's very important that it be

00:13:11,300 --> 00:13:15,140
allowed to run from anywhere anybody can

00:13:13,190 --> 00:13:16,400
call it but in reality it's only

00:13:15,140 --> 00:13:18,710
actually being called from a small

00:13:16,400 --> 00:13:20,060
number of places and in reality there's

00:13:18,710 --> 00:13:21,470
a global optimization that you could

00:13:20,060 --> 00:13:23,420
perform which is called inlining and

00:13:21,470 --> 00:13:24,800
that's a gatekeeper optimization for a

00:13:23,420 --> 00:13:26,360
whole bunch of other optimizations that

00:13:24,800 --> 00:13:27,800
you would like to be able to perform but

00:13:26,360 --> 00:13:30,320
you could only perform it when you know

00:13:27,800 --> 00:13:31,640
the whole picture right so on the one

00:13:30,320 --> 00:13:33,110
hand it's very important that when I

00:13:31,640 --> 00:13:35,090
write a function I can't assume anything

00:13:33,110 --> 00:13:37,040
about who's calling me on the other hand

00:13:35,090 --> 00:13:38,600
in order to get optimal performance the

00:13:37,040 --> 00:13:40,990
thing that's actually running the code

00:13:38,600 --> 00:13:45,290
has to be able to know the whole story

00:13:40,990 --> 00:13:46,730
and then and to get back to the web

00:13:45,290 --> 00:13:48,800
there's sort of the same story here

00:13:46,730 --> 00:13:51,920
there's a single thumb there's a single

00:13:48,800 --> 00:13:54,380
network layer and we would like to be

00:13:51,920 --> 00:13:55,970
able to i would like to be able to

00:13:54,380 --> 00:13:56,990
manipulate my dom without messing with

00:13:55,970 --> 00:13:58,520
your dom i would like to be able to

00:13:56,990 --> 00:13:59,960
install an add-on it's my ember app and

00:13:58,520 --> 00:14:01,100
haven't worked with a little chunk of

00:13:59,960 --> 00:14:02,360
don and not having mess with the entire

00:14:01,100 --> 00:14:04,340
system like i said that's a source of

00:14:02,360 --> 00:14:06,740
pride to me that that works but on the

00:14:04,340 --> 00:14:08,570
other hand there's a lot of people

00:14:06,740 --> 00:14:10,130
touching a lot of bomb and there's

00:14:08,570 --> 00:14:11,810
probably some optimizations that we can

00:14:10,130 --> 00:14:16,070
do to make it work better and i'll get

00:14:11,810 --> 00:14:17,210
to that in a second and and similar with

00:14:16,070 --> 00:14:19,400
the network if you're talkin to the same

00:14:17,210 --> 00:14:20,600
server and you could patch things into

00:14:19,400 --> 00:14:22,280
one request you would like to be able to

00:14:20,600 --> 00:14:23,480
do that but everybody making a network

00:14:22,280 --> 00:14:24,800
requests and not suppose it's not

00:14:23,480 --> 00:14:26,300
supposed to know that everybody else

00:14:24,800 --> 00:14:27,500
making a network request because if you

00:14:26,300 --> 00:14:29,420
do that it becomes hard to actually

00:14:27,500 --> 00:14:31,550
write programs that are any size right

00:14:29,420 --> 00:14:33,470
so that all that was just sort of to say

00:14:31,550 --> 00:14:34,560
there is a fundamental tension in

00:14:33,470 --> 00:14:36,270
software it's not just about

00:14:34,560 --> 00:14:37,410
amber or operating systems or

00:14:36,270 --> 00:14:38,550
programming languages fundamental

00:14:37,410 --> 00:14:41,430
tension between the fact that in order

00:14:38,550 --> 00:14:42,900
to rights software that is any size you

00:14:41,430 --> 00:14:44,490
have to write software an isolated

00:14:42,900 --> 00:14:45,990
chunks and but the fact that those

00:14:44,490 --> 00:14:47,610
isolated chunks are fundamentally not

00:14:45,990 --> 00:14:49,470
supposed to know about each other makes

00:14:47,610 --> 00:14:50,790
it very hard to do the kinds of global

00:14:49,470 --> 00:14:54,330
optimizations you need to do to make

00:14:50,790 --> 00:14:57,540
things fast so how do what it has a spin

00:14:54,330 --> 00:14:59,730
in tamper so it turns out that in on web

00:14:57,540 --> 00:15:01,980
frameworks there is basically one shrink

00:14:59,730 --> 00:15:03,089
that is how you do an optimization and

00:15:01,980 --> 00:15:04,350
you should do this if you were writing

00:15:03,089 --> 00:15:07,680
everything without isolation from

00:15:04,350 --> 00:15:10,170
scratch let me give you an example so

00:15:07,680 --> 00:15:12,240
here's an ember component and all that

00:15:10,170 --> 00:15:14,910
it does is whenever you click on the

00:15:12,240 --> 00:15:16,320
Ember components it increments it's it's

00:15:14,910 --> 00:15:18,120
counter property so there's a counter

00:15:16,320 --> 00:15:20,160
property starts at zero every time you

00:15:18,120 --> 00:15:21,870
click it increments it and then you have

00:15:20,160 --> 00:15:24,750
a component template that says show me

00:15:21,870 --> 00:15:27,540
the value of the counter so what happens

00:15:24,750 --> 00:15:31,680
when I render when I render the first

00:15:27,540 --> 00:15:33,900
time what happens is I you know create a

00:15:31,680 --> 00:15:35,490
div and I create zero and I close the

00:15:33,900 --> 00:15:37,200
different foot into the done but now

00:15:35,490 --> 00:15:39,720
what happens when you click on the give

00:15:37,200 --> 00:15:42,120
what happens is it calls this click

00:15:39,720 --> 00:15:45,330
handler the click handler sets counter

00:15:42,120 --> 00:15:48,290
what that does in ember and in other

00:15:45,330 --> 00:15:53,280
frameworks that do this optimization is

00:15:48,290 --> 00:15:55,200
it says instead of saying okay I will

00:15:53,280 --> 00:15:56,430
immediately go so very naive frame is

00:15:55,200 --> 00:15:58,320
what they do is they immediately go

00:15:56,430 --> 00:16:00,720
sorry they immediately go and just

00:15:58,320 --> 00:16:02,400
update that little red circle but what

00:16:00,720 --> 00:16:03,930
less naive frameworks do the ones that

00:16:02,400 --> 00:16:05,880
are doing the one weird trick is they

00:16:03,930 --> 00:16:08,100
just remember that that node has to be

00:16:05,880 --> 00:16:10,170
that it is dirty they remember that that

00:16:08,100 --> 00:16:12,630
is a thing that has to be updated later

00:16:10,170 --> 00:16:14,220
now imagine that somewhere else in the

00:16:12,630 --> 00:16:15,570
tree during the same kick in the

00:16:14,220 --> 00:16:17,790
response to the same click handler I

00:16:15,570 --> 00:16:20,850
modify some other node so I'm load up

00:16:17,790 --> 00:16:22,500
there that also doesn't update the node

00:16:20,850 --> 00:16:24,510
right away it instead just remembers

00:16:22,500 --> 00:16:28,080
that there's something to do and later

00:16:24,510 --> 00:16:30,240
on what happens is we just walked in

00:16:28,080 --> 00:16:31,350
tree we say okay here on the top node is

00:16:30,240 --> 00:16:32,850
this dirty no it's not dirty okay

00:16:31,350 --> 00:16:34,980
nothing to do what about this note no

00:16:32,850 --> 00:16:37,709
nothing to do ah this notice dirty so

00:16:34,980 --> 00:16:39,390
let's update it great this known as

00:16:37,709 --> 00:16:41,160
dirty let's update it awesome what about

00:16:39,390 --> 00:16:44,070
this node no I'm not 30 nothing to do

00:16:41,160 --> 00:16:45,130
agree now that might not seem so

00:16:44,070 --> 00:16:46,450
important

00:16:45,130 --> 00:16:47,800
in this example because in this example

00:16:46,450 --> 00:16:49,630
those two nodes were disconnected from

00:16:47,800 --> 00:16:52,060
each other so in this case it wouldn't

00:16:49,630 --> 00:16:53,440
have mattered if we did it at at the

00:16:52,060 --> 00:16:56,650
moment when the thing happened or later

00:16:53,440 --> 00:16:58,540
but what's very very common is that what

00:16:56,650 --> 00:17:00,520
happens is that the top that one of the

00:16:58,540 --> 00:17:02,080
parent nodes actually goes away gets

00:17:00,520 --> 00:17:04,690
destroyed right so what happens is

00:17:02,080 --> 00:17:05,800
instead of just random notes getting

00:17:04,690 --> 00:17:07,720
changed that you can just fire and

00:17:05,800 --> 00:17:09,730
render whatever you want what happens is

00:17:07,720 --> 00:17:11,949
in your tree some nodes get destroyed

00:17:09,730 --> 00:17:13,449
and other nodes get updated so imagine

00:17:11,949 --> 00:17:16,030
that you have like a conditional that

00:17:13,449 --> 00:17:18,130
says if the name exists render the name

00:17:16,030 --> 00:17:19,480
you've changed the name right what's

00:17:18,130 --> 00:17:21,130
going to happen is if you just do it in

00:17:19,480 --> 00:17:22,930
any order what might happen is you

00:17:21,130 --> 00:17:24,130
update the name but then a second later

00:17:22,930 --> 00:17:25,360
you delete the entire gone what you

00:17:24,130 --> 00:17:26,439
would like to be able to do is delete

00:17:25,360 --> 00:17:27,430
the DOM and then notice that you don't

00:17:26,439 --> 00:17:30,250
even have to care about the child

00:17:27,430 --> 00:17:32,140
anymore and so there's a goal that's

00:17:30,250 --> 00:17:34,690
just a very small example but it happens

00:17:32,140 --> 00:17:35,860
in spades in the real world is that and

00:17:34,690 --> 00:17:37,810
you've probably noticed if you've ever

00:17:35,860 --> 00:17:39,760
written back one app that what starts to

00:17:37,810 --> 00:17:40,990
happen over time is like you're like why

00:17:39,760 --> 00:17:42,700
is my render method getting called so

00:17:40,990 --> 00:17:44,710
many times in one tick I would like to

00:17:42,700 --> 00:17:46,090
have it come up it's like oh no prob you

00:17:44,710 --> 00:17:47,350
can use the balance but now you're the

00:17:46,090 --> 00:17:49,060
balance is perhaps conflicting if

00:17:47,350 --> 00:17:51,700
someone else's be balanced and comes

00:17:49,060 --> 00:17:53,920
very hard to match right so really the

00:17:51,700 --> 00:17:56,470
trick the one weird trick here is that

00:17:53,920 --> 00:17:58,630
when you say i would like to update this

00:17:56,470 --> 00:18:00,580
download it doesn't actually update the

00:17:58,630 --> 00:18:02,620
download it just remembers that the

00:18:00,580 --> 00:18:04,960
download has to be updated and then

00:18:02,620 --> 00:18:07,390
later on there's a global thing the

00:18:04,960 --> 00:18:11,290
framework that is responsible for doing

00:18:07,390 --> 00:18:12,790
the optimal solution and actually that's

00:18:11,290 --> 00:18:15,730
what this is about how many people have

00:18:12,790 --> 00:18:17,350
seen this website CSS triggers okay go

00:18:15,730 --> 00:18:21,190
check it out so what this website is

00:18:17,350 --> 00:18:22,990
basically saying is which things when

00:18:21,190 --> 00:18:25,330
you change them so for example if you

00:18:22,990 --> 00:18:27,910
change a line content the CSS property

00:18:25,330 --> 00:18:29,650
it forces the browser to flush so the

00:18:27,910 --> 00:18:31,270
browser internally has the same similar

00:18:29,650 --> 00:18:33,520
version of this which is that when you

00:18:31,270 --> 00:18:34,990
go you change the CSS property or you

00:18:33,520 --> 00:18:36,310
change the Dom most of the time it

00:18:34,990 --> 00:18:37,540
doesn't do anything at all it just

00:18:36,310 --> 00:18:39,940
remembers that there's something to do

00:18:37,540 --> 00:18:41,650
later and then later on like after your

00:18:39,940 --> 00:18:43,540
JavaScript code is done running it

00:18:41,650 --> 00:18:44,830
basically relays out the whole page and

00:18:43,540 --> 00:18:46,540
what that lets you do is it lets you

00:18:44,830 --> 00:18:48,400
make a lot of Dom manipulations and then

00:18:46,540 --> 00:18:49,660
it will do something smart at the end so

00:18:48,400 --> 00:18:52,180
effectively the browser is doing the

00:18:49,660 --> 00:18:54,070
same one weird trick however there the

00:18:52,180 --> 00:18:56,770
browser have made a mistake like

00:18:54,070 --> 00:18:58,900
years ago and certain properties if you

00:18:56,770 --> 00:19:00,970
ask like what is the value of my offset

00:18:58,900 --> 00:19:02,680
left it has to give you the answer right

00:19:00,970 --> 00:19:03,670
now so what that means is that there's a

00:19:02,680 --> 00:19:05,320
certain properties and there's a big

00:19:03,670 --> 00:19:07,780
list on this website that if you try to

00:19:05,320 --> 00:19:10,090
update them or look them up it forces

00:19:07,780 --> 00:19:11,710
the flushing to happen right now so you

00:19:10,090 --> 00:19:14,590
don't want to call those things because

00:19:11,710 --> 00:19:17,110
they defeat the trick ember doesn't have

00:19:14,590 --> 00:19:19,720
any such things you cannot force us to

00:19:17,110 --> 00:19:21,820
relay up just you just get a sale value

00:19:19,720 --> 00:19:23,200
can try to get the fuel value but the

00:19:21,820 --> 00:19:25,210
key point here is that in you I

00:19:23,200 --> 00:19:28,180
programming this is unrelated to ember

00:19:25,210 --> 00:19:30,550
or react or angular or backbone or the

00:19:28,180 --> 00:19:32,230
browser or cocoa the main trick that you

00:19:30,550 --> 00:19:34,360
have for making things performance is

00:19:32,230 --> 00:19:36,730
when you think that you want to update

00:19:34,360 --> 00:19:37,900
something don't actually update it just

00:19:36,730 --> 00:19:39,790
remember that something needs to be

00:19:37,900 --> 00:19:41,470
updated and then have a global thing

00:19:39,790 --> 00:19:44,020
that is not your component that does the

00:19:41,470 --> 00:19:45,520
updating now what are the benefits of

00:19:44,020 --> 00:19:48,040
the optimization so first of all you can

00:19:45,520 --> 00:19:49,570
guarantee for any given render that the

00:19:48,040 --> 00:19:51,010
render only happens once per user

00:19:49,570 --> 00:19:52,510
interaction so if the user clicks on

00:19:51,010 --> 00:19:54,160
something you can guarantee that every

00:19:52,510 --> 00:19:56,770
one of those notes only renders at most

00:19:54,160 --> 00:19:58,810
one time like I said before if something

00:19:56,770 --> 00:20:00,490
above you is removed you're going to

00:19:58,810 --> 00:20:02,740
automatically tear down everything below

00:20:00,490 --> 00:20:04,330
it and skip it because the framework is

00:20:02,740 --> 00:20:06,160
actually rendering from top down it's

00:20:04,330 --> 00:20:08,620
not rendering in whatever order exactly

00:20:06,160 --> 00:20:09,850
happening and also you can make a lot of

00:20:08,620 --> 00:20:11,440
assumptions about the state of the world

00:20:09,850 --> 00:20:12,880
in your life cycle looks right so your

00:20:11,440 --> 00:20:14,740
life cycle looks know you know are

00:20:12,880 --> 00:20:18,040
running and a very precise time that the

00:20:14,740 --> 00:20:20,500
framework has told you and really the

00:20:18,040 --> 00:20:23,530
point of this is just to say you really

00:20:20,500 --> 00:20:25,720
want your components to be isolated from

00:20:23,530 --> 00:20:27,490
each other but when you do that if you

00:20:25,720 --> 00:20:29,140
do that in the most naive way possible

00:20:27,490 --> 00:20:30,610
you end up with performance problem so

00:20:29,140 --> 00:20:31,570
you really need something coordinating

00:20:30,610 --> 00:20:33,910
you you need some kind of global

00:20:31,570 --> 00:20:35,230
coordination coordination also an

00:20:33,910 --> 00:20:37,690
emperors is a bunch of other things that

00:20:35,230 --> 00:20:40,630
were kind of the same way so Boone and

00:20:37,690 --> 00:20:42,820
initialization are are not something

00:20:40,630 --> 00:20:44,500
that you do by telling us to boot you

00:20:42,820 --> 00:20:46,930
tell us what to do when boot happens and

00:20:44,500 --> 00:20:48,280
what this means is that add-ons can do

00:20:46,930 --> 00:20:49,240
the same thing so every mad on can say

00:20:48,280 --> 00:20:50,830
here's what should happen during the

00:20:49,240 --> 00:20:51,880
initialization process and what that

00:20:50,830 --> 00:20:53,320
means that when you install an add-on

00:20:51,880 --> 00:20:55,120
you don't have to worry about fighting

00:20:53,320 --> 00:20:55,750
with your add-on for it's trying to do

00:20:55,120 --> 00:20:57,010
something I'm trying

00:20:55,750 --> 00:20:58,420
something gets registering doc ready

00:20:57,010 --> 00:21:00,130
hands on registry back right here and

00:20:58,420 --> 00:21:01,270
there's what's happening right basically

00:21:00,130 --> 00:21:03,700
there's a predictable way that the

00:21:01,270 --> 00:21:05,020
initialization process happens similarly

00:21:03,700 --> 00:21:06,700
with navigation when you click on a link

00:21:05,020 --> 00:21:08,260
so when you click on a link in a regular

00:21:06,700 --> 00:21:10,330
server-side rendering app it's

00:21:08,260 --> 00:21:12,520
everything works totally fine because

00:21:10,330 --> 00:21:14,920
you tear down the entire page you

00:21:12,520 --> 00:21:17,050
lightly free the memory and start over

00:21:14,920 --> 00:21:18,160
but in a client-side render that you

00:21:17,050 --> 00:21:19,690
haven't freed the members so there needs

00:21:18,160 --> 00:21:21,670
to be some way to predictably tear down

00:21:19,690 --> 00:21:22,870
what you set up and that's actually with

00:21:21,670 --> 00:21:24,880
the Ember routing system this for the

00:21:22,870 --> 00:21:27,400
Ember erotic system says every route

00:21:24,880 --> 00:21:29,110
represents a page and again unlike on

00:21:27,400 --> 00:21:30,370
the server if you set some stayed up

00:21:29,110 --> 00:21:31,330
when you enter a paging these etheric

00:21:30,370 --> 00:21:33,820
down when you leave and there's a very

00:21:31,330 --> 00:21:36,700
predictable way to do that similarly

00:21:33,820 --> 00:21:38,290
with data right there's a when you ask

00:21:36,700 --> 00:21:39,700
for data if you already ask for the same

00:21:38,290 --> 00:21:43,930
batter before you get the same data back

00:21:39,700 --> 00:21:46,060
if I ask for 15 IDs from 15 different

00:21:43,930 --> 00:21:46,990
components that gets cold lesson to a

00:21:46,060 --> 00:21:48,850
single request on the server

00:21:46,990 --> 00:21:50,890
automatically right and these are all

00:21:48,850 --> 00:21:52,690
things that they're dealing with the

00:21:50,890 --> 00:21:54,070
tension between the fact that you would

00:21:52,690 --> 00:21:55,780
like components to not know that they're

00:21:54,070 --> 00:21:57,010
part of a world and the fact that in the

00:21:55,780 --> 00:21:58,450
real world you're making Network

00:21:57,010 --> 00:22:00,700
requests and you're manipulating the Dom

00:21:58,450 --> 00:22:02,770
right so you need to have some global

00:22:00,700 --> 00:22:04,720
story that help that takes these

00:22:02,770 --> 00:22:06,400
isolated components and gives you an

00:22:04,720 --> 00:22:08,640
optimal solution without making the

00:22:06,400 --> 00:22:11,710
components and know about each other and

00:22:08,640 --> 00:22:13,330
really what this means and it's true

00:22:11,710 --> 00:22:14,890
about all these analogies is that you

00:22:13,330 --> 00:22:15,990
have to give up control to somebody else

00:22:14,890 --> 00:22:18,130
if people don't like giving up control

00:22:15,990 --> 00:22:20,260
they like to think that if they have

00:22:18,130 --> 00:22:21,910
control they can do a better job but the

00:22:20,260 --> 00:22:23,680
thing is that that's actually just not

00:22:21,910 --> 00:22:25,540
true because even though you might be

00:22:23,680 --> 00:22:27,640
able to do a better job in your isolated

00:22:25,540 --> 00:22:29,170
world you can never do a better global

00:22:27,640 --> 00:22:30,700
job because if the whole point of the

00:22:29,170 --> 00:22:32,650
program model and this is not something

00:22:30,700 --> 00:22:33,940
that is special to ember for example in

00:22:32,650 --> 00:22:35,710
backbone which has the opposite

00:22:33,940 --> 00:22:36,850
programming model you still have

00:22:35,710 --> 00:22:38,050
isolated components that are not

00:22:36,850 --> 00:22:40,150
supposed to know about each other right

00:22:38,050 --> 00:22:42,400
so though it is actually fundamental to

00:22:40,150 --> 00:22:44,950
making the programming model scale that

00:22:42,400 --> 00:22:47,470
components and processes and I frames

00:22:44,950 --> 00:22:49,210
and all you know all these analogies to

00:22:47,470 --> 00:22:50,200
the same story it is fundamental that

00:22:49,210 --> 00:22:51,160
they don't know about each other and

00:22:50,200 --> 00:22:53,440
you're not supposed to know about each

00:22:51,160 --> 00:22:55,420
other so I think at the end of the day

00:22:53,440 --> 00:22:57,940
if you want that benefit which it allows

00:22:55,420 --> 00:22:59,740
you to write bigger programs you need to

00:22:57,940 --> 00:23:00,210
give up some control it's fundamental to

00:22:59,740 --> 00:23:01,500
avoid

00:23:00,210 --> 00:23:04,890
duplicated work between components that

00:23:01,500 --> 00:23:06,540
don't know about each other programming

00:23:04,890 --> 00:23:08,070
languages use jits right so what age it

00:23:06,540 --> 00:23:09,180
does is it says okay I see that you have

00:23:08,070 --> 00:23:10,680
all these different functions but at

00:23:09,180 --> 00:23:12,120
runtime i'm going to figure out or maybe

00:23:10,680 --> 00:23:13,650
an alt compiler i'm going to figure out

00:23:12,120 --> 00:23:15,300
how these things actually connected i'm

00:23:13,650 --> 00:23:16,890
going to do a global optimization that

00:23:15,300 --> 00:23:18,180
you the writer of the function wasn't

00:23:16,890 --> 00:23:19,350
allowed to do because you're not allowed

00:23:18,180 --> 00:23:20,760
to know who calls you it's actually

00:23:19,350 --> 00:23:24,690
important to the function programming

00:23:20,760 --> 00:23:27,600
model similarly up in OSS it's important

00:23:24,690 --> 00:23:29,340
to the isolated process model frost

00:23:27,600 --> 00:23:30,300
isolation model that the process does

00:23:29,340 --> 00:23:33,660
not know about each other but the

00:23:30,300 --> 00:23:35,100
colonel is allowed to and frameworks are

00:23:33,660 --> 00:23:37,320
sort of the same story they globally

00:23:35,100 --> 00:23:38,970
manage side effects but they relieve you

00:23:37,320 --> 00:23:42,420
from having to worry about that those

00:23:38,970 --> 00:23:44,430
global concerns in each component and so

00:23:42,420 --> 00:23:47,040
the idea the fundamental story here is

00:23:44,430 --> 00:23:48,810
that kernels are about dealing with

00:23:47,040 --> 00:23:50,070
shared mutable state the real world

00:23:48,810 --> 00:23:51,600
they're about dealing with the real

00:23:50,070 --> 00:23:53,610
world which is why we write programs I

00:23:51,600 --> 00:23:55,020
think sometimes people forget this when

00:23:53,610 --> 00:23:57,020
they get into a very purest state of

00:23:55,020 --> 00:24:00,330
mind they forget that in the real world

00:23:57,020 --> 00:24:01,710
like hi I'm a human I have a body I have

00:24:00,330 --> 00:24:03,630
shared mutable state time is going on

00:24:01,710 --> 00:24:04,910
right we cannot describe things that

00:24:03,630 --> 00:24:08,280
people care about in the real world

00:24:04,910 --> 00:24:10,020
purely but we would like our programs as

00:24:08,280 --> 00:24:12,120
much as possible to not have to worry

00:24:10,020 --> 00:24:16,440
about the global shared mutable state

00:24:12,120 --> 00:24:18,030
and so what happens is the colonel is

00:24:16,440 --> 00:24:20,220
managing tribute will stay in fact the

00:24:18,030 --> 00:24:21,720
colonel is allowed to do things like you

00:24:20,220 --> 00:24:22,920
asked me to read from a socket it's a

00:24:21,720 --> 00:24:25,260
lot to put the universe into an

00:24:22,920 --> 00:24:26,610
inconsistent state as long as it makes

00:24:25,260 --> 00:24:28,200
sure that by the time it actually talks

00:24:26,610 --> 00:24:29,820
to your process the universe is back in

00:24:28,200 --> 00:24:31,140
a consistent state that also lets you do

00:24:29,820 --> 00:24:32,940
a lot of optimizations that you not be

00:24:31,140 --> 00:24:37,290
able allowed to do inside of an

00:24:32,940 --> 00:24:39,510
individual process and the way I like to

00:24:37,290 --> 00:24:42,120
describe this idea and it's sort of the

00:24:39,510 --> 00:24:43,800
different from the very purist mindset

00:24:42,120 --> 00:24:45,660
is that what the way I like the right

00:24:43,800 --> 00:24:47,100
programs is that I'd like to be allowed

00:24:45,660 --> 00:24:50,550
to write sloppy in the small and

00:24:47,100 --> 00:24:52,110
rigorous and a large um what I mean by

00:24:50,550 --> 00:24:54,030
that is that once you have isolated

00:24:52,110 --> 00:24:55,410
boundaries you have function boundaries

00:24:54,030 --> 00:24:57,900
and module boundaries and process

00:24:55,410 --> 00:24:59,460
boundaries and machine boundaries when

00:24:57,900 --> 00:25:01,500
you're talk about security computing it

00:24:59,460 --> 00:25:03,270
lets you be a little more sloppy in the

00:25:01,500 --> 00:25:05,010
smallest pieces right so the smaller you

00:25:03,270 --> 00:25:06,150
get the more sloppy you can get it

00:25:05,010 --> 00:25:06,419
doesn't really matter that much if

00:25:06,150 --> 00:25:08,039
you're

00:25:06,419 --> 00:25:09,720
should have spaghetti code in it because

00:25:08,039 --> 00:25:11,609
the function has a very clear boundary

00:25:09,720 --> 00:25:14,220
between somebody else so might be 20

00:25:11,609 --> 00:25:16,230
line monster but as long as it is only

00:25:14,220 --> 00:25:18,600
minute and working with its own internal

00:25:16,230 --> 00:25:20,159
state and it works with inputs and

00:25:18,600 --> 00:25:22,049
return values it's a really matter how

00:25:20,159 --> 00:25:24,509
sloppy that is and some people like

00:25:22,049 --> 00:25:25,679
they're they're very they really want

00:25:24,509 --> 00:25:27,869
every line of code they have a right to

00:25:25,679 --> 00:25:29,429
be pure but like I said before and I

00:25:27,869 --> 00:25:30,779
don't mean in this case I don't need

00:25:29,429 --> 00:25:32,279
pure in the functional way I just mean

00:25:30,779 --> 00:25:34,109
they like it to be very nothing like it

00:25:32,279 --> 00:25:36,419
to be nice they like it to be rigorous

00:25:34,109 --> 00:25:37,799
but in reality we have to be honest

00:25:36,419 --> 00:25:39,480
about the fact that we write code when

00:25:37,799 --> 00:25:40,769
we're cognitively depleted so a lot of

00:25:39,480 --> 00:25:42,960
the time we're going to be sloppy and

00:25:40,769 --> 00:25:45,600
the story is that we should not be in

00:25:42,960 --> 00:25:47,970
charge so your job is to write the small

00:25:45,600 --> 00:25:49,169
code you should not be in charge of

00:25:47,970 --> 00:25:50,369
making the isolation boundary so that's

00:25:49,169 --> 00:25:52,320
another mistake that people make they

00:25:50,369 --> 00:25:53,879
say well I agree with this idea but

00:25:52,320 --> 00:25:55,320
basically you cannot define the

00:25:53,879 --> 00:25:57,480
isolation boundary for me I should make

00:25:55,320 --> 00:25:59,399
my own but we can see in other

00:25:57,480 --> 00:26:01,440
situations like with processes you would

00:25:59,399 --> 00:26:02,789
not want every application every process

00:26:01,440 --> 00:26:04,259
to be allowed to define its process

00:26:02,789 --> 00:26:05,879
isolation boundary that wouldn't make a

00:26:04,259 --> 00:26:07,649
lot of sense right because then any

00:26:05,879 --> 00:26:08,970
process that made a mistake could mess

00:26:07,649 --> 00:26:10,980
with every other process could

00:26:08,970 --> 00:26:12,629
accidentally imagine a process allowed

00:26:10,980 --> 00:26:15,210
to just look at the underlying kernel

00:26:12,629 --> 00:26:16,590
buffer if it feels like and the answer

00:26:15,210 --> 00:26:18,480
is you're not supposed to do that you're

00:26:16,590 --> 00:26:19,799
supposed to I will give you a pattern

00:26:18,480 --> 00:26:21,210
book and the pattern book tells you not

00:26:19,799 --> 00:26:22,289
to do that what's going to happen is

00:26:21,210 --> 00:26:23,369
someone's going to be on a deadline or

00:26:22,289 --> 00:26:24,659
going to hire an intern and they're

00:26:23,369 --> 00:26:26,309
going to forget to do that pattern and

00:26:24,659 --> 00:26:27,570
then all of a sudden literally every

00:26:26,309 --> 00:26:29,639
other process in the entire system is

00:26:27,570 --> 00:26:32,129
going to crash right so we can't really

00:26:29,639 --> 00:26:33,509
say it's everybody's job I'm a good

00:26:32,129 --> 00:26:35,850
programmer I can make the isolation

00:26:33,509 --> 00:26:38,129
boundaries isolation boundaries are

00:26:35,850 --> 00:26:40,320
exactly the place where frameworks and

00:26:38,129 --> 00:26:43,830
operating systems do the job that it's

00:26:40,320 --> 00:26:46,739
where they decide what to do now

00:26:43,830 --> 00:26:48,720
interestingly this feeds into a really

00:26:46,739 --> 00:26:51,230
big difference in versioning between

00:26:48,720 --> 00:26:54,659
frameworks and languages and libraries

00:26:51,230 --> 00:26:56,999
so libraries actually can make can

00:26:54,659 --> 00:26:58,409
basically make a version 1 and then if

00:26:56,999 --> 00:27:00,179
the version 1 is in good they can just

00:26:58,409 --> 00:27:01,950
use make another library right so you

00:27:00,179 --> 00:27:03,989
can you can make an XML processing

00:27:01,950 --> 00:27:05,789
library and the XML process and library

00:27:03,989 --> 00:27:07,399
turned out to have the wrong abstraction

00:27:05,789 --> 00:27:09,739
no problem just make another eczema bras

00:27:07,399 --> 00:27:12,649
library like in Ruby limb XML to the

00:27:09,739 --> 00:27:14,570
process Rex ml wasn't very good so live

00:27:12,649 --> 00:27:15,830
XML to game LOL to wasn't very good no

00:27:14,570 --> 00:27:19,460
Kabir it came out and that doesn't have

00:27:15,830 --> 00:27:21,169
that much cost but frameworks and the

00:27:19,460 --> 00:27:22,489
reason for that is that freight they're

00:27:21,169 --> 00:27:23,479
not really providing any kind of

00:27:22,489 --> 00:27:25,190
isolation they're just giving you

00:27:23,479 --> 00:27:28,489
utilities so if you want to process your

00:27:25,190 --> 00:27:30,769
XML in different ways no big deal but

00:27:28,489 --> 00:27:33,710
programming languages actually do

00:27:30,769 --> 00:27:35,509
provide you with isolation primitives

00:27:33,710 --> 00:27:37,039
which means that switching from one

00:27:35,509 --> 00:27:38,479
framework to another or one language to

00:27:37,039 --> 00:27:41,389
another 10 us to another is actually a

00:27:38,479 --> 00:27:42,589
big project because the framework is the

00:27:41,389 --> 00:27:43,700
thing that gave me the isolation

00:27:42,589 --> 00:27:45,349
boundaries to begin with which is what

00:27:43,700 --> 00:27:47,210
allows you to build a big program and

00:27:45,349 --> 00:27:48,259
then and then if you want to switch to

00:27:47,210 --> 00:27:49,969
something else you need to learn the

00:27:48,259 --> 00:27:51,619
isolation story from the other things if

00:27:49,969 --> 00:27:53,629
you want to switch from unix the windows

00:27:51,619 --> 00:27:55,460
it's not hard because win32 is at

00:27:53,629 --> 00:27:56,869
different API of analytics API it's

00:27:55,460 --> 00:27:59,899
different because the process model is

00:27:56,869 --> 00:28:01,460
different that's what makes it hard the

00:27:59,899 --> 00:28:06,559
i/o model is actually fundamentally

00:28:01,460 --> 00:28:09,289
different it's hard so when I say

00:28:06,559 --> 00:28:11,149
version 2 what I mean is not the second

00:28:09,289 --> 00:28:12,559
version the second numbered version that

00:28:11,149 --> 00:28:14,210
a programming language or language ever

00:28:12,559 --> 00:28:16,219
makes I mean the first time that you

00:28:14,210 --> 00:28:18,289
take the thing the first version one is

00:28:16,219 --> 00:28:19,759
always sort of sloppy Ruby the first

00:28:18,289 --> 00:28:23,089
version review is an ast walking

00:28:19,759 --> 00:28:28,059
interpreter the first version of ember

00:28:23,089 --> 00:28:30,019
was a string bass templating engine I

00:28:28,059 --> 00:28:32,769
you can observe that all these things

00:28:30,019 --> 00:28:35,089
also have the same one and two property

00:28:32,769 --> 00:28:37,009
so what version 2 really is is a

00:28:35,089 --> 00:28:38,359
fundamental shift in how the internals

00:28:37,009 --> 00:28:39,320
of your library or framework workers so

00:28:38,359 --> 00:28:41,330
you have this if you have a framework

00:28:39,320 --> 00:28:42,469
internally it works in one way all of a

00:28:41,330 --> 00:28:44,659
sudden you want it to work a completely

00:28:42,469 --> 00:28:47,389
different way and it's usually based on

00:28:44,659 --> 00:28:48,289
the shift in the landscape which is

00:28:47,389 --> 00:28:50,479
basically what's happening right now

00:28:48,289 --> 00:28:51,889
with the with the web framework world or

00:28:50,479 --> 00:28:54,440
it could be based on the maturing of the

00:28:51,889 --> 00:28:56,629
core tube so in Ruby's case it was easy

00:28:54,440 --> 00:28:57,679
for master ibs-c walking interpreter but

00:28:56,629 --> 00:28:58,729
then eventually the courts you've got

00:28:57,679 --> 00:28:59,899
more mature and they said that's not

00:28:58,729 --> 00:29:04,129
really the right way to do this we would

00:28:59,899 --> 00:29:05,749
prefer to make a different vm and the

00:29:04,129 --> 00:29:07,489
interesting question that you ask is

00:29:05,749 --> 00:29:09,289
when some when you arrive at the

00:29:07,489 --> 00:29:10,729
decision to make a v2 and everyone does

00:29:09,289 --> 00:29:11,490
arrive at it right if you look at the

00:29:10,729 --> 00:29:13,410
stimulus

00:29:11,490 --> 00:29:16,440
everybody arrives it at some points the

00:29:13,410 --> 00:29:18,929
question is what do you do do you say

00:29:16,440 --> 00:29:20,460
well the internals are completely

00:29:18,929 --> 00:29:22,110
different so obviously compatibility is

00:29:20,460 --> 00:29:23,520
impossible we should just give up a

00:29:22,110 --> 00:29:25,110
compatibility and tell everyone that's

00:29:23,520 --> 00:29:29,760
going to be a hard transition and you

00:29:25,110 --> 00:29:31,140
can see that some people did that or you

00:29:29,760 --> 00:29:33,240
can say we're going to try really hard

00:29:31,140 --> 00:29:35,940
signing perfect because the internal or

00:29:33,240 --> 00:29:37,170
difference was going to be hard but

00:29:35,940 --> 00:29:40,980
we're going to try really hard to make

00:29:37,170 --> 00:29:43,230
things compatible and the interesting

00:29:40,980 --> 00:29:47,040
thing is that people that were more in

00:29:43,230 --> 00:29:49,080
the first place attracted to what not

00:29:47,040 --> 00:29:50,790
how i'm going to i'm going to write

00:29:49,080 --> 00:29:52,620
abstractions that teach you that haven't

00:29:50,790 --> 00:29:56,490
let you say what you're trying to do not

00:29:52,620 --> 00:29:58,590
how you're trying to do it those api's

00:29:56,490 --> 00:29:59,700
are much more resilient to changes in

00:29:58,590 --> 00:30:00,840
the internals right because the

00:29:59,700 --> 00:30:03,330
internals were just an implementation

00:30:00,840 --> 00:30:05,730
detail the more the first version of

00:30:03,330 --> 00:30:07,200
something was telling you I hear i'm

00:30:05,730 --> 00:30:08,970
going to directly manipulate the shared

00:30:07,200 --> 00:30:10,830
mutable state the more that was your

00:30:08,970 --> 00:30:14,220
original api the harder the transition

00:30:10,830 --> 00:30:16,620
ends up e so for example python has this

00:30:14,220 --> 00:30:19,200
api which is sis and restore get frame

00:30:16,620 --> 00:30:20,640
which is like give me a frame for the

00:30:19,200 --> 00:30:22,410
current like on the current stack which

00:30:20,640 --> 00:30:23,640
if you like know how to implement a

00:30:22,410 --> 00:30:25,320
program like we just like an insane

00:30:23,640 --> 00:30:26,580
thing to provide however it's a very

00:30:25,320 --> 00:30:28,230
easy mistake to make because when you

00:30:26,580 --> 00:30:32,309
write an interpreter you have a lying

00:30:28,230 --> 00:30:33,570
around so you may as well the problem is

00:30:32,309 --> 00:30:34,830
that if you make API is based on I

00:30:33,570 --> 00:30:36,510
happen to have a line around my

00:30:34,830 --> 00:30:37,290
implementation what's going to happen is

00:30:36,510 --> 00:30:38,820
when you decide to change your

00:30:37,290 --> 00:30:42,450
implementation your api's are going to

00:30:38,820 --> 00:30:44,040
change so Linux and I think ember and

00:30:42,450 --> 00:30:45,809
Ruby did a pretty good job of not

00:30:44,040 --> 00:30:47,490
exposing too many details of the

00:30:45,809 --> 00:30:49,500
internals for example the Ruby garbage

00:30:47,490 --> 00:30:51,570
collector API is very is just

00:30:49,500 --> 00:30:54,179
conservative garbage collector doesn't

00:30:51,570 --> 00:30:55,890
really spoke link into the capi all so

00:30:54,179 --> 00:30:58,140
in see you just write normalcy code it

00:30:55,890 --> 00:31:01,050
happens to work in Python all the C code

00:30:58,140 --> 00:31:02,010
has to do stuff with reference count and

00:31:01,050 --> 00:31:02,670
what that means is that if you want to

00:31:02,010 --> 00:31:04,800
change the garbage collector

00:31:02,670 --> 00:31:07,950
implementation of Python it breaks a lot

00:31:04,800 --> 00:31:09,450
of TV is a lot of C code and that is not

00:31:07,950 --> 00:31:10,710
true about Ruby so it was easy for Ruby

00:31:09,450 --> 00:31:12,000
to upgrade to a better garbage about

00:31:10,710 --> 00:31:13,500
their implementation it's now like a

00:31:12,000 --> 00:31:16,230
generational incremental oh blah blah

00:31:13,500 --> 00:31:17,970
blah sort of top-of-the-line garbage

00:31:16,230 --> 00:31:19,080
collector because of the fact that Ruby

00:31:17,970 --> 00:31:20,350
decided from the beginning that a

00:31:19,080 --> 00:31:21,880
constraint was when

00:31:20,350 --> 00:31:25,600
Elite this implementation detail into

00:31:21,880 --> 00:31:27,250
the code raft of Rights so that actually

00:31:25,600 --> 00:31:29,650
has it been important it ends up being

00:31:27,250 --> 00:31:32,910
important to try to write your v1 in a

00:31:29,650 --> 00:31:35,049
way that is mostly about what not have

00:31:32,910 --> 00:31:37,630
unfortunately if you make your be one

00:31:35,049 --> 00:31:39,490
about what 90 it tends to be slower so

00:31:37,630 --> 00:31:41,679
you can look at job up for example the

00:31:39,490 --> 00:31:43,090
first version of Java was pretty slow as

00:31:41,679 --> 00:31:45,039
a bytecode interpreter it was not the

00:31:43,090 --> 00:31:47,919
optimal implementation and it was pretty

00:31:45,039 --> 00:31:49,179
slow but the idea of the of java boys

00:31:47,919 --> 00:31:50,620
we're going to eventually be fast so

00:31:49,179 --> 00:31:51,669
we're giving you a higher level way of

00:31:50,620 --> 00:31:54,010
describing what you're doing which is

00:31:51,669 --> 00:31:55,179
java bytecode and will eventually figure

00:31:54,010 --> 00:31:56,650
out how to make it fast but there's

00:31:55,179 --> 00:31:58,900
always a period of time in the beginning

00:31:56,650 --> 00:32:00,309
in v1 where it feels like I could just

00:31:58,900 --> 00:32:03,520
do better myself it's obvious that I

00:32:00,309 --> 00:32:04,900
could do better myself and something

00:32:03,520 --> 00:32:06,309
that I've learned now after years of

00:32:04,900 --> 00:32:07,600
doing this and making the same mistake

00:32:06,309 --> 00:32:10,179
over and over again basically the job

00:32:07,600 --> 00:32:12,070
would be one mistake is that really when

00:32:10,179 --> 00:32:14,200
you make to be one of your thing you

00:32:12,070 --> 00:32:15,789
really need to expose pretty good escape

00:32:14,200 --> 00:32:17,679
valves so in ember we have things like

00:32:15,789 --> 00:32:19,360
dinosaur elements which are pretty good

00:32:17,679 --> 00:32:20,350
skate bells but you have to be pretty

00:32:19,360 --> 00:32:23,409
willing to have a lot of different

00:32:20,350 --> 00:32:26,320
escape valves so that people feel like

00:32:23,409 --> 00:32:27,730
oh I can't really get the job done I'm

00:32:26,320 --> 00:32:29,140
trying to do I'm trying to do something

00:32:27,730 --> 00:32:32,409
but the framework is not giving me

00:32:29,140 --> 00:32:34,480
enough tools you give people ways of

00:32:32,409 --> 00:32:35,860
getting around it now the thing that's

00:32:34,480 --> 00:32:37,390
important about these escape valves is

00:32:35,860 --> 00:32:38,620
that you really need to give them escape

00:32:37,390 --> 00:32:39,850
valves that don't break the isolation

00:32:38,620 --> 00:32:40,929
model right so you don't really want to

00:32:39,850 --> 00:32:42,549
give people an escape valve that's like

00:32:40,929 --> 00:32:44,350
just touch whatever Dom node you want

00:32:42,549 --> 00:32:45,460
because if they do that and that escape

00:32:44,350 --> 00:32:46,960
valve is going to not going to be very

00:32:45,460 --> 00:32:49,260
forward compatible it's like the fist

00:32:46,960 --> 00:32:51,610
underscore get framed problem right so

00:32:49,260 --> 00:32:54,370
an example in operating systems is

00:32:51,610 --> 00:32:57,490
direct mode right so in early versions

00:32:54,370 --> 00:32:58,750
of the operating of Linux there was

00:32:57,490 --> 00:33:00,700
always a way to say like give me some

00:32:58,750 --> 00:33:02,559
bites from the disk but the first

00:33:00,700 --> 00:33:04,090
versions of Linux were pretty bad at

00:33:02,559 --> 00:33:05,830
that if you want to build like Photoshop

00:33:04,090 --> 00:33:06,909
or database so you'd be like give me

00:33:05,830 --> 00:33:10,270
some place from a disk and it would be

00:33:06,909 --> 00:33:11,200
slow so Linux has this single direct

00:33:10,270 --> 00:33:12,700
mode where you're like just let me

00:33:11,200 --> 00:33:14,679
control it directly just give me the

00:33:12,700 --> 00:33:16,059
exact don't try to any smart caching

00:33:14,679 --> 00:33:17,950
just give me exactly what I want and

00:33:16,059 --> 00:33:20,260
that's a good thing to do in like Linux

00:33:17,950 --> 00:33:21,520
do you want because linux p1 is how has

00:33:20,260 --> 00:33:23,770
a way of explaining what you're trying

00:33:21,520 --> 00:33:25,480
to do but it's slow but it's important

00:33:23,770 --> 00:33:27,070
to recognize that in all systems that

00:33:25,480 --> 00:33:29,799
are go with this in mind which is a

00:33:27,070 --> 00:33:31,999
small handful systems of its some status

00:33:29,799 --> 00:33:33,679
what's going to eventually happen is

00:33:31,999 --> 00:33:35,089
that the colonel is going to get smarter

00:33:33,679 --> 00:33:36,739
and saying okay you're reading 20 bytes

00:33:35,089 --> 00:33:38,179
this other process of reading so the

00:33:36,739 --> 00:33:39,679
first version I'm reading 20 x 30

00:33:38,179 --> 00:33:40,879
reading 20 bytes the colonel is not very

00:33:39,679 --> 00:33:43,190
smart at all it just doesn't do anything

00:33:40,879 --> 00:33:44,690
good but eventually what happens is I'm

00:33:43,190 --> 00:33:47,029
reading 20 by 20 reading 20 by 20

00:33:44,690 --> 00:33:49,339
reading 20 bytes let's imagine we have a

00:33:47,029 --> 00:33:51,529
disk with an arm on it the Colonel's

00:33:49,339 --> 00:33:53,599
eventually oh i see that i can i can

00:33:51,529 --> 00:33:55,459
send the arm to the right place on the

00:33:53,599 --> 00:33:56,929
spinning disk to do the right thing for

00:33:55,459 --> 00:33:58,249
the global optimization if i had the

00:33:56,929 --> 00:34:00,049
ability to control the arm directly

00:33:58,249 --> 00:34:01,339
perhaps that the entire operating system

00:34:00,049 --> 00:34:03,409
was just photoshop i could do a better

00:34:01,339 --> 00:34:04,549
job than the operating system but when

00:34:03,409 --> 00:34:06,139
the photoshop is running alongside

00:34:04,549 --> 00:34:08,389
chrome that's probably not going to be

00:34:06,139 --> 00:34:09,589
the right answer unfortunately in v1 of

00:34:08,389 --> 00:34:11,329
any of these systems it ends up being

00:34:09,589 --> 00:34:15,260
you don't you get the worst of both

00:34:11,329 --> 00:34:17,389
worlds if you want right you get slow

00:34:15,260 --> 00:34:19,190
abstraction and the non global

00:34:17,389 --> 00:34:20,450
optimization but over time the fact that

00:34:19,190 --> 00:34:21,950
most people are writing to the slow

00:34:20,450 --> 00:34:25,010
abstraction means you get the global

00:34:21,950 --> 00:34:27,200
optimization so monkey patching and

00:34:25,010 --> 00:34:29,389
dynamic languages direct mode for disk

00:34:27,200 --> 00:34:31,269
operating systems for distant operating

00:34:29,389 --> 00:34:34,099
systems didn't certain element in ember

00:34:31,269 --> 00:34:36,200
build RS and cargo which is the rust

00:34:34,099 --> 00:34:37,399
package manager these are all escape

00:34:36,200 --> 00:34:39,349
valves that let you do things that are

00:34:37,399 --> 00:34:41,059
not already supported by the abstraction

00:34:39,349 --> 00:34:42,079
but we really kind of have to have the

00:34:41,059 --> 00:34:43,669
knowledge that what you're doing is

00:34:42,079 --> 00:34:44,809
going to eventually be slower than the

00:34:43,669 --> 00:34:47,029
thing that is able to the global

00:34:44,809 --> 00:34:48,349
optimization the thing that's really

00:34:47,029 --> 00:34:49,819
great about escape valves is that they

00:34:48,349 --> 00:34:51,710
give you a corpus of real-world usage

00:34:49,819 --> 00:34:53,629
right so if you ember was just had no

00:34:51,710 --> 00:34:54,889
escape valves some people would be able

00:34:53,629 --> 00:34:55,940
to use ember but everyone else wouldn't

00:34:54,889 --> 00:34:57,170
and they would just go use something

00:34:55,940 --> 00:34:59,990
else and we wouldn't actually know what

00:34:57,170 --> 00:35:02,119
the missing pieces were right or direct

00:34:59,990 --> 00:35:03,380
mode in in Linux right the Linux could

00:35:02,119 --> 00:35:04,759
look at the recommend see why are people

00:35:03,380 --> 00:35:06,349
using direct what is the reason they're

00:35:04,759 --> 00:35:07,609
doing it ah we can see that they're

00:35:06,349 --> 00:35:08,990
doing this or that therefore if we make

00:35:07,609 --> 00:35:11,150
our optimizations target those use cases

00:35:08,990 --> 00:35:12,859
we can do a good job for the guy using

00:35:11,150 --> 00:35:14,750
direct mode and also not screw the guy

00:35:12,859 --> 00:35:16,849
not using direct mode right so having

00:35:14,750 --> 00:35:18,200
escape valves is a pretty nice way of

00:35:16,849 --> 00:35:20,839
figuring out what's happening in the

00:35:18,200 --> 00:35:22,910
real world and then when it comes time

00:35:20,839 --> 00:35:24,589
to do v2 which always happens you have a

00:35:22,910 --> 00:35:26,539
big corpus of things that people have

00:35:24,589 --> 00:35:28,160
done that you can fold into the global

00:35:26,539 --> 00:35:29,809
optimization so when it comes time to do

00:35:28,160 --> 00:35:33,289
the global optimization you can do with

00:35:29,809 --> 00:35:35,359
a lot more knowledge the thing about v1

00:35:33,289 --> 00:35:36,970
and this is unfortunate because if you

00:35:35,359 --> 00:35:38,349
look at the v1 of something like

00:35:36,970 --> 00:35:40,570
versus the V was something like back

00:35:38,349 --> 00:35:41,950
home at the time that they're both v1

00:35:40,570 --> 00:35:44,320
they look very similar to each other

00:35:41,950 --> 00:35:45,910
right but really the difference between

00:35:44,320 --> 00:35:47,640
embers of you wanted backbones we want

00:35:45,910 --> 00:35:49,930
is that backbone still v1 is the end

00:35:47,640 --> 00:35:51,280
we're going to ship some abstractions we

00:35:49,930 --> 00:35:52,690
trust you as the user to do the right

00:35:51,280 --> 00:35:54,119
thing this was actually the rhetoric

00:35:52,690 --> 00:35:56,859
right you could do a better job than me

00:35:54,119 --> 00:35:58,660
you as a user to do a better job npm

00:35:56,859 --> 00:36:01,540
does a similar thing now at the m3 with

00:35:58,660 --> 00:36:02,890
peer dependencies you application author

00:36:01,540 --> 00:36:05,260
can do a better job resolving peer

00:36:02,890 --> 00:36:09,099
dependencies than us mpm I don't buy

00:36:05,260 --> 00:36:10,780
that either but the idea is that v1 in

00:36:09,099 --> 00:36:12,520
systems like Amber and Linux our

00:36:10,780 --> 00:36:14,680
intention and Java are intentionally

00:36:12,520 --> 00:36:16,690
kind of sloppy they mostly focus on

00:36:14,680 --> 00:36:18,400
giving users good tools for expressing

00:36:16,690 --> 00:36:20,410
what they want to happen from the

00:36:18,400 --> 00:36:21,700
perspective of sort of hypothetically

00:36:20,410 --> 00:36:23,590
what kind of duplicated work could we

00:36:21,700 --> 00:36:26,220
avoid so you say okay I'm gonna give you

00:36:23,590 --> 00:36:28,750
an API lets you read from a socket and

00:36:26,220 --> 00:36:30,040
the idea is I could imagine some

00:36:28,750 --> 00:36:32,890
optimizations if a lot of people are

00:36:30,040 --> 00:36:34,630
using that API that I can do in the view

00:36:32,890 --> 00:36:35,920
layer the templates templates an ember

00:36:34,630 --> 00:36:37,480
give you a high level understanding of

00:36:35,920 --> 00:36:39,190
the DOM and in principle there are

00:36:37,480 --> 00:36:40,300
optimizations that we could do but amber

00:36:39,190 --> 00:36:42,970
1 point 0 didn't do a lot of them

00:36:40,300 --> 00:36:44,560
actually similar principles apply in the

00:36:42,970 --> 00:36:49,359
amber routing layer the Emperor model

00:36:44,560 --> 00:36:50,560
etc but crucially v1 systems that are

00:36:49,359 --> 00:36:53,080
intentionally trying to go down this

00:36:50,560 --> 00:36:55,560
path are usually somewhat painful Ruby

00:36:53,080 --> 00:36:57,940
one was very slow because it was it was

00:36:55,560 --> 00:37:00,040
the implementation wasn't very good even

00:36:57,940 --> 00:37:03,339
though it had a very high level story

00:37:00,040 --> 00:37:05,349
right ember d1 was also pretty slow

00:37:03,339 --> 00:37:07,630
didn't have good optimizations didn't

00:37:05,349 --> 00:37:10,089
have amazing escape valves but and this

00:37:07,630 --> 00:37:11,740
is because the list of actions that the

00:37:10,089 --> 00:37:13,000
colonel supports is still pretty limited

00:37:11,740 --> 00:37:15,790
right so the first time when I right

00:37:13,000 --> 00:37:16,869
number v1 or Linux p 1 i'm thinking that

00:37:15,790 --> 00:37:19,060
what I'm doing is describing a

00:37:16,869 --> 00:37:20,890
declarative system UI give you 16 things

00:37:19,060 --> 00:37:22,420
you're allowed to do but the 16 things

00:37:20,890 --> 00:37:25,000
is not a very big list and probably I

00:37:22,420 --> 00:37:26,680
messed up on these scales too right so

00:37:25,000 --> 00:37:28,300
what happens is that when you're a user

00:37:26,680 --> 00:37:30,490
who's using something like ember or

00:37:28,300 --> 00:37:32,680
Linux v1 you find yourself using this

00:37:30,490 --> 00:37:34,000
gate valves a lot you say oh I'm using

00:37:32,680 --> 00:37:36,070
Linux but I have to use the recommend

00:37:34,000 --> 00:37:37,359
every single day so in the 90s the idea

00:37:36,070 --> 00:37:39,640
of like exokernel became very popular

00:37:37,359 --> 00:37:41,260
like oh basically Linux has failed

00:37:39,640 --> 00:37:43,330
there's a hacker news post about this

00:37:41,260 --> 00:37:45,730
this week literally Linux is a failure

00:37:43,330 --> 00:37:47,079
it is not a fast operating system the

00:37:45,730 --> 00:37:50,079
only way to get good perform

00:37:47,079 --> 00:37:52,239
basically outsource it to users that two

00:37:50,079 --> 00:37:54,489
processes because they can do a better

00:37:52,239 --> 00:37:55,660
job than these rinky-dink kernels that

00:37:54,489 --> 00:37:57,430
face you have no idea what's going on

00:37:55,660 --> 00:37:59,529
and that is always every single time

00:37:57,430 --> 00:38:01,180
what people say about me once I can do a

00:37:59,529 --> 00:38:02,410
better job than this idiot kernel that

00:38:01,180 --> 00:38:03,849
basically doesn't do anything tomorrow

00:38:02,410 --> 00:38:06,969
and it's just making you go through this

00:38:03,849 --> 00:38:08,499
bloated abstraction every time right and

00:38:06,969 --> 00:38:12,089
the only question that you have to ask

00:38:08,499 --> 00:38:14,349
yourself is is there going to be a v2

00:38:12,089 --> 00:38:15,940
because if there's going to be a v2

00:38:14,349 --> 00:38:17,529
what's going to happen is you're going

00:38:15,940 --> 00:38:20,950
to put up with some amount of pain and

00:38:17,529 --> 00:38:22,539
v1 but all your be one program which has

00:38:20,950 --> 00:38:24,130
the proper isolation model so remember

00:38:22,539 --> 00:38:25,749
if we go back that's the point of all

00:38:24,130 --> 00:38:27,849
this the point of all this is to provide

00:38:25,749 --> 00:38:29,890
good isolation models v1 has a good

00:38:27,849 --> 00:38:33,759
isolation model and v2 can be compatible

00:38:29,890 --> 00:38:36,069
so so for example ember v2 and ruby 1.9

00:38:33,759 --> 00:38:39,700
and all versions of Java because they

00:38:36,069 --> 00:38:41,349
were careful in v1 to be yes slow but

00:38:39,700 --> 00:38:43,959
also more declarative more high-level

00:38:41,349 --> 00:38:46,239
more about describing what you're trying

00:38:43,959 --> 00:38:48,339
to do they were able to slowly build up

00:38:46,239 --> 00:38:50,259
something that was faster and nicer and

00:38:48,339 --> 00:38:51,430
did the kind of global optimization that

00:38:50,259 --> 00:38:54,759
you'd expect without breaking

00:38:51,430 --> 00:38:56,499
compatibility the goal of V tues and

00:38:54,759 --> 00:38:57,940
systems like this is to add more to ship

00:38:56,499 --> 00:38:59,680
versions that maintain support for the

00:38:57,940 --> 00:39:01,209
set of old operations while adding

00:38:59,680 --> 00:39:04,809
support for new ones so a good example

00:39:01,209 --> 00:39:07,539
this is signals and unix right the first

00:39:04,809 --> 00:39:10,150
version of UNIX ever have signals that

00:39:07,539 --> 00:39:12,309
were processed global you could say give

00:39:10,150 --> 00:39:13,779
me a signal and you would like switch to

00:39:12,309 --> 00:39:15,279
some sea stack it will be in the same

00:39:13,779 --> 00:39:16,749
thread there were no threads actually

00:39:15,279 --> 00:39:19,779
and it was just crazy if you try to do

00:39:16,749 --> 00:39:21,219
that API you would cry a lot but over

00:39:19,779 --> 00:39:22,749
time more important files were added

00:39:21,219 --> 00:39:25,089
that made signals more powerful so

00:39:22,749 --> 00:39:27,249
eventually we added signals with threads

00:39:25,089 --> 00:39:28,690
and then signal information so you can

00:39:27,249 --> 00:39:31,089
find out what signal actually happened

00:39:28,690 --> 00:39:32,859
what did and you could ask say like wait

00:39:31,089 --> 00:39:34,269
for a signal with a timeout that's a

00:39:32,859 --> 00:39:35,709
good thing to be allowed to do and more

00:39:34,269 --> 00:39:36,789
recently you could say I am waiting for

00:39:35,709 --> 00:39:39,249
some I oh I also want to wait for a

00:39:36,789 --> 00:39:40,569
signal at the same time and then crucial

00:39:39,249 --> 00:39:42,999
thing about signals and units is not

00:39:40,569 --> 00:39:44,619
that we said ah that number one that's

00:39:42,999 --> 00:39:45,849
garbage let's throw that out it's

00:39:44,619 --> 00:39:48,219
terrible how would you ever do that

00:39:45,849 --> 00:39:49,959
let's remove it the crucial thing is

00:39:48,219 --> 00:39:52,930
that number one on that list still works

00:39:49,959 --> 00:39:56,079
today and the Space Jam website still

00:39:52,930 --> 00:39:57,759
works today right because it is possible

00:39:56,079 --> 00:39:58,270
to add more support for more actions

00:39:57,759 --> 00:40:01,150
without break

00:39:58,270 --> 00:40:03,040
and I think the way place where people

00:40:01,150 --> 00:40:05,530
make mistake i'ma stay here is that they

00:40:03,040 --> 00:40:07,240
assume that because idioms fundamentally

00:40:05,530 --> 00:40:08,740
change as we as a community learn more

00:40:07,240 --> 00:40:11,020
things we are forced to break

00:40:08,740 --> 00:40:12,220
compatibility and I saw last year so a

00:40:11,020 --> 00:40:13,960
lot of articles that said something like

00:40:12,220 --> 00:40:15,130
this like the web is changing we're

00:40:13,960 --> 00:40:16,870
getting service worker that means we

00:40:15,130 --> 00:40:17,980
have to rewrite all our frameworks but

00:40:16,870 --> 00:40:20,170
there's actually no reason for that we

00:40:17,980 --> 00:40:23,530
can change the idioms that we use we can

00:40:20,170 --> 00:40:25,180
make better idioms without breaking

00:40:23,530 --> 00:40:27,610
fundamental compatibility we can keep

00:40:25,180 --> 00:40:30,130
compatibility for the old stuff while

00:40:27,610 --> 00:40:31,990
adding support for new stuff a good

00:40:30,130 --> 00:40:34,450
example of this is width in JavaScript

00:40:31,990 --> 00:40:35,590
so within JavaScript was added for sort

00:40:34,450 --> 00:40:37,540
of the same reason that underscore get

00:40:35,590 --> 00:40:38,620
frame was added content it's easy we

00:40:37,540 --> 00:40:41,170
have an interpreter we can make it work

00:40:38,620 --> 00:40:42,910
but it was pretty much a disaster it's

00:40:41,170 --> 00:40:46,540
almost impossible to optimize equates

00:40:42,910 --> 00:40:48,670
the universe is terrible and what

00:40:46,540 --> 00:40:51,070
JavaScript and then basically did was

00:40:48,670 --> 00:40:52,660
that they said or not we can't remove it

00:40:51,070 --> 00:40:54,640
was a lot of code relies on it make it

00:40:52,660 --> 00:40:57,490
work but we won't make it fast and if

00:40:54,640 --> 00:40:58,990
you try to use within today's JavaScript

00:40:57,490 --> 00:41:01,300
engines you are basically pressing the

00:40:58,990 --> 00:41:02,800
anti turbo button the slow button right

00:41:01,300 --> 00:41:04,480
you're basically telling the engine

00:41:02,800 --> 00:41:06,610
please don't try to do any optimizations

00:41:04,480 --> 00:41:09,040
I'm doing a slow thing please be slow

00:41:06,610 --> 00:41:11,680
and that is the thing that you can do

00:41:09,040 --> 00:41:13,270
right so if you notice that well v1 made

00:41:11,680 --> 00:41:14,620
a mistake in I've exposed something that

00:41:13,270 --> 00:41:17,140
we shouldn't have exposed a lot of times

00:41:14,620 --> 00:41:18,670
you can fix you can continue to support

00:41:17,140 --> 00:41:20,680
it in a way that is not performing a

00:41:18,670 --> 00:41:22,480
good example is an ember is synchronous

00:41:20,680 --> 00:41:24,370
observers synchronous observers an ember

00:41:22,480 --> 00:41:25,810
we should never have supported we even

00:41:24,370 --> 00:41:27,430
said it be 1 point 0 that we're probably

00:41:25,810 --> 00:41:29,320
I can support for that long we ended up

00:41:27,430 --> 00:41:31,390
supporting for that long but we probably

00:41:29,320 --> 00:41:33,190
can't remove them but we can make them

00:41:31,390 --> 00:41:34,870
we can coordinate off into a space that

00:41:33,190 --> 00:41:36,430
says if you're using synchronous

00:41:34,870 --> 00:41:38,350
observers as opposed to ASA course

00:41:36,430 --> 00:41:42,790
observers will make it work but we won't

00:41:38,350 --> 00:41:43,900
make it fast browsers have been doing

00:41:42,790 --> 00:41:45,610
this for years I I find it extremely

00:41:43,900 --> 00:41:47,530
ironic that people use the pace of

00:41:45,610 --> 00:41:48,820
innovation in browsers as a reason to

00:41:47,530 --> 00:41:50,680
change things all the time because

00:41:48,820 --> 00:41:52,480
browsers are actually a prime example of

00:41:50,680 --> 00:41:54,520
the colonel and user space pack right

00:41:52,480 --> 00:41:56,890
the tavern where browsers the first four

00:41:54,520 --> 00:41:58,450
HTML one was very small HTML to was a

00:41:56,890 --> 00:41:59,890
super citation through the super super

00:41:58,450 --> 00:42:01,900
super serve people look at they say oh

00:41:59,890 --> 00:42:02,980
my god hacks on hacks on ax is crazy but

00:42:01,900 --> 00:42:04,450
that's not really what's going on in

00:42:02,980 --> 00:42:07,300
this too much the same way that you can

00:42:04,450 --> 00:42:09,160
easily decry x86 for being hacked some

00:42:07,300 --> 00:42:09,430
hats on hats but it's really just a way

00:42:09,160 --> 00:42:10,690
of

00:42:09,430 --> 00:42:12,609
not adding stuff without breaking

00:42:10,690 --> 00:42:16,030
existing stuff and this was really

00:42:12,609 --> 00:42:18,760
fundamentally what Bill Gates really

00:42:16,030 --> 00:42:20,470
figure out the 80s was and and the Intel

00:42:18,760 --> 00:42:21,940
guys figured out in the eighties was yes

00:42:20,470 --> 00:42:23,829
you could always build a better thing if

00:42:21,940 --> 00:42:25,480
you could throw a legacy but throwing

00:42:23,829 --> 00:42:26,740
away legacy means that you will have to

00:42:25,480 --> 00:42:28,450
reboot the universe and leave everybody

00:42:26,740 --> 00:42:29,800
behind if you don't leave everyone line

00:42:28,450 --> 00:42:33,970
that people can transition slowly you

00:42:29,800 --> 00:42:36,700
end up with in a better place so really

00:42:33,970 --> 00:42:39,280
what I'm saying is that frameworks give

00:42:36,700 --> 00:42:40,510
you one japanee by describing what you

00:42:39,280 --> 00:42:42,940
want to happen rather than how to

00:42:40,510 --> 00:42:44,530
accomplish it exactly by describing I

00:42:42,940 --> 00:42:45,670
would like this Don boat to be updated

00:42:44,530 --> 00:42:47,530
to this rather than actually

00:42:45,670 --> 00:42:49,240
manipulating it directly we can keep

00:42:47,530 --> 00:42:50,349
swapping out the implementation under

00:42:49,240 --> 00:42:52,329
the hood and we've done this an ember

00:42:50,349 --> 00:42:55,059
like four times now while leaving your

00:42:52,329 --> 00:42:56,440
app intact and if you want to Bill

00:42:55,059 --> 00:42:57,490
people working on an app for more than a

00:42:56,440 --> 00:43:00,130
year or two and those are the kinds of

00:42:57,490 --> 00:43:01,660
apps I like to work on you really do you

00:43:00,130 --> 00:43:02,980
really do need to get a bit more high

00:43:01,660 --> 00:43:04,720
level and describing what it is that

00:43:02,980 --> 00:43:06,220
you're trying to do instead of inlining

00:43:04,720 --> 00:43:09,309
the exact implementation in your code

00:43:06,220 --> 00:43:11,079
all the time on ember is for apps that

00:43:09,309 --> 00:43:12,910
want to be around for a few years we

00:43:11,079 --> 00:43:14,319
fundamentally reject the idea that you

00:43:12,910 --> 00:43:16,089
have to rewrite your app every year or

00:43:14,319 --> 00:43:17,680
two just to keep up because that's not

00:43:16,089 --> 00:43:19,240
the way any of the apps that we work on

00:43:17,680 --> 00:43:21,030
is people in amber core team and the

00:43:19,240 --> 00:43:23,260
surrounding community actually work

00:43:21,030 --> 00:43:24,819
nobody on the amber core team nobody in

00:43:23,260 --> 00:43:27,099
the community is building apps that we

00:43:24,819 --> 00:43:29,500
write every year or two so I guess what

00:43:27,099 --> 00:43:31,180
I would say is I think you should build

00:43:29,500 --> 00:43:32,770
apps that last I think you should build

00:43:31,180 --> 00:43:36,599
apps that are going to be around for for

00:43:32,770 --> 00:43:36,599

YouTube URL: https://www.youtube.com/watch?v=Eaaa182aYQg


