Title: All Things Open 2015 | Brad Blake - Phase2 | Performance Profiling Tools and Tricks
Publication date: 2015-11-19
Playlist: All Things Open 2015
Description: 
	All Things Open 2014 All Things Open 2015, October 19th and 20th, Raleigh NC. All Things Open 2015, October 19th and 20th, Raleigh NC.
Captions: 
	00:00:05,210 --> 00:00:08,940
alright I think we're about at

00:00:07,109 --> 00:00:11,790
two-thirty so i'm going to go ahead and

00:00:08,940 --> 00:00:14,490
get started welcome to performance

00:00:11,790 --> 00:00:17,070
profiling tools and tricks I'm your

00:00:14,490 --> 00:00:20,039
guide my name is Brad Blake I'm a

00:00:17,070 --> 00:00:21,480
software architect at phase two and

00:00:20,039 --> 00:00:22,859
there's my email that's a good way to

00:00:21,480 --> 00:00:27,570
get a hold of me if you have any

00:00:22,859 --> 00:00:29,910
feedback or questions after the talk so

00:00:27,570 --> 00:00:31,470
I'm going to talk about profiling but

00:00:29,910 --> 00:00:33,360
first I'm going to talk about what

00:00:31,470 --> 00:00:35,489
profiling isn't because I think there's

00:00:33,360 --> 00:00:39,750
some misconceptions about what profiling

00:00:35,489 --> 00:00:42,540
is so profiling is not the same as

00:00:39,750 --> 00:00:44,399
benchmarking in benchmarking you're kind

00:00:42,540 --> 00:00:46,050
of looking at how your system performs

00:00:44,399 --> 00:00:48,539
under certain conditions like load

00:00:46,050 --> 00:00:50,670
you're looking at the big picture like

00:00:48,539 --> 00:00:53,820
throughput you know concurrent users

00:00:50,670 --> 00:00:56,850
things like that profiling is sort of

00:00:53,820 --> 00:00:58,890
more granular than that it's also not

00:00:56,850 --> 00:01:01,680
the same as debugging like when you're

00:00:58,890 --> 00:01:03,989
profiling you can certainly expose bugs

00:01:01,680 --> 00:01:06,390
in your code and the need to do some

00:01:03,989 --> 00:01:09,420
debugging to find it but there's sort of

00:01:06,390 --> 00:01:12,659
two separate actions and the last thing

00:01:09,420 --> 00:01:14,880
is it's not a dark art like profiling

00:01:12,659 --> 00:01:16,740
gets this reputation as like it's you

00:01:14,880 --> 00:01:18,240
know it might be tough to do and you

00:01:16,740 --> 00:01:20,700
know there might be like one guy on your

00:01:18,240 --> 00:01:22,110
team that can do it but that's not the

00:01:20,700 --> 00:01:24,090
truth you're not just going to go send

00:01:22,110 --> 00:01:26,220
somebody into a closet and say like fix

00:01:24,090 --> 00:01:28,080
this problem make it faster like there

00:01:26,220 --> 00:01:31,799
are tools and techniques that make sure

00:01:28,080 --> 00:01:35,310
that anyone can do it so what is

00:01:31,799 --> 00:01:38,159
profiling generally it's gathering data

00:01:35,310 --> 00:01:40,079
on the performance of a system so you're

00:01:38,159 --> 00:01:42,030
looking at like CPU and memory usage

00:01:40,079 --> 00:01:44,100
you're looking at function calls and

00:01:42,030 --> 00:01:47,250
times and things like that and a whole

00:01:44,100 --> 00:01:48,720
host of other metrics and the goal is

00:01:47,250 --> 00:01:51,240
really to find where the system is

00:01:48,720 --> 00:01:53,610
spending its time because once you have

00:01:51,240 --> 00:01:55,350
that data then you can combine that with

00:01:53,610 --> 00:01:57,210
you know your knowledge of the

00:01:55,350 --> 00:02:00,030
application and you can dive in and fix

00:01:57,210 --> 00:02:02,009
the problem and when I say fix the

00:02:00,030 --> 00:02:04,290
problem i'm talking about refactoring

00:02:02,009 --> 00:02:06,060
your code your app whatever i'm not

00:02:04,290 --> 00:02:08,489
talking about you know enhancing a bunch

00:02:06,060 --> 00:02:09,899
of functionality and changing a lot of

00:02:08,489 --> 00:02:13,440
things around i'm talking about just

00:02:09,899 --> 00:02:16,020
changing with what the problem is

00:02:13,440 --> 00:02:18,810
for any my little pony fans out there or

00:02:16,020 --> 00:02:21,960
parents or whatever profiling also

00:02:18,810 --> 00:02:25,470
should be fun like maybe not Pinkie Pie

00:02:21,960 --> 00:02:30,390
fun I'm a dad not a brownie my wife

00:02:25,470 --> 00:02:32,280
asked me to clarify but it's fun it's

00:02:30,390 --> 00:02:34,230
like something you know that you don't

00:02:32,280 --> 00:02:36,480
get to do every day it's a chance to

00:02:34,230 --> 00:02:38,280
learn you know new techniques new tools

00:02:36,480 --> 00:02:40,410
do something that's out of the ordinary

00:02:38,280 --> 00:02:42,900
right so you should be excited about

00:02:40,410 --> 00:02:44,340
getting the profile your code even

00:02:42,900 --> 00:02:45,960
though that means that generally

00:02:44,340 --> 00:02:50,490
something is broken or not performing

00:02:45,960 --> 00:02:53,100
right so there's two types of profiling

00:02:50,490 --> 00:02:56,040
that I'm going to talk about the first

00:02:53,100 --> 00:02:57,990
is event-based profiling and that's

00:02:56,040 --> 00:02:59,910
where you're gathering data that's

00:02:57,990 --> 00:03:01,410
triggered by specific events like every

00:02:59,910 --> 00:03:03,990
time a function is called you're going

00:03:01,410 --> 00:03:06,000
to gather data and that type of

00:03:03,990 --> 00:03:07,980
profiling is generally slower because

00:03:06,000 --> 00:03:09,750
you're performing that action a lot more

00:03:07,980 --> 00:03:12,450
times you're gathering a lot more data

00:03:09,750 --> 00:03:14,670
the trade-off is obviously you have more

00:03:12,450 --> 00:03:17,820
data it's going to be more accurate so

00:03:14,670 --> 00:03:18,900
event-based profilers generally can't be

00:03:17,820 --> 00:03:21,270
like use in a production environment

00:03:18,900 --> 00:03:23,030
because of that reason but they're

00:03:21,270 --> 00:03:25,440
really good to track down the problem

00:03:23,030 --> 00:03:28,650
and then there's sampler sampling

00:03:25,440 --> 00:03:30,420
profiles or statistical profiles and

00:03:28,650 --> 00:03:32,880
that's where you're going to record data

00:03:30,420 --> 00:03:34,800
at specific intervals like you know

00:03:32,880 --> 00:03:36,270
every tenth of a second every second

00:03:34,800 --> 00:03:38,760
you're going to trap some data like the

00:03:36,270 --> 00:03:42,750
call stack and then you're going to use

00:03:38,760 --> 00:03:44,519
that to debug those are generally less

00:03:42,750 --> 00:03:46,110
accurate in specific like you're going

00:03:44,519 --> 00:03:47,900
to be missing some data like what

00:03:46,110 --> 00:03:50,790
happens in between the sampling windows

00:03:47,900 --> 00:03:53,190
but they're less intrusive as well so

00:03:50,790 --> 00:03:55,350
you can use a lot of these profilers on

00:03:53,190 --> 00:04:00,030
production environments with limited

00:03:55,350 --> 00:04:02,760
overhead some things to consider before

00:04:00,030 --> 00:04:04,920
you start like number one is do you

00:04:02,760 --> 00:04:07,560
really have a performance issue you know

00:04:04,920 --> 00:04:10,050
if the CEO drops his head in your cube

00:04:07,560 --> 00:04:11,640
and says the site slow does that really

00:04:10,050 --> 00:04:13,500
mean the slightest slow or does that

00:04:11,640 --> 00:04:15,480
mean he's got his network settings all

00:04:13,500 --> 00:04:17,430
screwed up and you know if you run

00:04:15,480 --> 00:04:19,680
traceroute everything is good or you fix

00:04:17,430 --> 00:04:21,479
his computer everything's good like do

00:04:19,680 --> 00:04:23,010
you have data that actually indicates

00:04:21,479 --> 00:04:23,790
you have a performance problem rather

00:04:23,010 --> 00:04:27,300
than anecdote

00:04:23,790 --> 00:04:29,550
evidence and also how big of an issue is

00:04:27,300 --> 00:04:30,870
it like is it something that you can

00:04:29,550 --> 00:04:32,910
live with is it something that only

00:04:30,870 --> 00:04:34,950
happens for administrative users you

00:04:32,910 --> 00:04:36,900
know some pages are slow or is this

00:04:34,950 --> 00:04:38,880
affecting everyone you know where does

00:04:36,900 --> 00:04:41,370
it rank in terms of priorities for the

00:04:38,880 --> 00:04:43,410
site you know our new feature is more

00:04:41,370 --> 00:04:47,580
important for the business than making

00:04:43,410 --> 00:04:50,730
the site faster or vice versa you might

00:04:47,580 --> 00:04:52,890
want to benchmark to to get out sort of

00:04:50,730 --> 00:04:54,660
look before pictures so you can compare

00:04:52,890 --> 00:04:57,780
it with the after you know some of the

00:04:54,660 --> 00:05:00,030
tools I use a bee or Apache bench that's

00:04:57,780 --> 00:05:04,110
pretty much standard on all systems sort

00:05:00,030 --> 00:05:07,680
of limited HTT / actually said that

00:05:04,110 --> 00:05:09,810
right is a little more advanced one of

00:05:07,680 --> 00:05:11,940
the nice features is it'll keep sending

00:05:09,810 --> 00:05:14,250
requests to your system even after it's

00:05:11,940 --> 00:05:15,960
overloaded and not responding so you can

00:05:14,250 --> 00:05:17,850
sort of simulate real-world like what

00:05:15,960 --> 00:05:21,600
will actually happen when your site gets

00:05:17,850 --> 00:05:23,370
overloaded siege is like Apache bench

00:05:21,600 --> 00:05:25,770
but you can do multiple URLs because

00:05:23,370 --> 00:05:27,450
it's multi-threaded so instead of you

00:05:25,770 --> 00:05:29,100
know just giving it one URL you can give

00:05:27,450 --> 00:05:32,310
it a bunch and throw traffic at a bunch

00:05:29,100 --> 00:05:34,800
of URLs and jmeter is sort of the old

00:05:32,310 --> 00:05:36,480
standby right of like actually doing a

00:05:34,800 --> 00:05:38,850
good load test getting some good

00:05:36,480 --> 00:05:40,380
benchmark tools because you can sort of

00:05:38,850 --> 00:05:43,080
simulate what users are going to do on

00:05:40,380 --> 00:05:45,030
your site and the last thing is

00:05:43,080 --> 00:05:46,800
determine what your goal is and it

00:05:45,030 --> 00:05:49,200
doesn't need to be a specific number a

00:05:46,800 --> 00:05:51,120
specific percentage you just have to

00:05:49,200 --> 00:05:54,030
know when you're done like what's the

00:05:51,120 --> 00:05:56,730
definition of done to put on my p.m. hat

00:05:54,030 --> 00:06:01,800
or agile had like when will you know

00:05:56,730 --> 00:06:03,570
that you've accomplished your goal so

00:06:01,800 --> 00:06:05,040
some things to look at get to a

00:06:03,570 --> 00:06:07,170
functional system quickly and then

00:06:05,040 --> 00:06:09,180
measure it but it needs to be a real

00:06:07,170 --> 00:06:11,970
system if you're trying to profile demo

00:06:09,180 --> 00:06:14,580
where or something that's half done you

00:06:11,970 --> 00:06:16,650
start a wasting time because again the

00:06:14,580 --> 00:06:18,660
alternative is to prematurely optimize

00:06:16,650 --> 00:06:21,900
and we know that prematurely optimizing

00:06:18,660 --> 00:06:24,060
is the root of all evil that might be a

00:06:21,900 --> 00:06:25,890
little harsh but when you prematurely

00:06:24,060 --> 00:06:28,380
optimize you're just guessing and you're

00:06:25,890 --> 00:06:31,560
probably going to waste time be

00:06:28,380 --> 00:06:33,390
data-driven having data is the only way

00:06:31,560 --> 00:06:37,409
to fix was really wrong with your

00:06:33,390 --> 00:06:39,509
program tail especially dash

00:06:37,409 --> 00:06:41,369
is your friend like don't be afraid to

00:06:39,509 --> 00:06:43,050
open up ten different windows tailing

00:06:41,369 --> 00:06:45,179
ten different log files at the same time

00:06:43,050 --> 00:06:47,869
you want to find the error message you

00:06:45,179 --> 00:06:51,089
want to get as much data as you can did

00:06:47,869 --> 00:06:53,099
go after items with the highest cost and

00:06:51,089 --> 00:06:54,749
that's not necessarily the outliers so

00:06:53,099 --> 00:06:58,050
just look just because something is the

00:06:54,749 --> 00:06:59,969
slowest doesn't mean that's the worst so

00:06:58,050 --> 00:07:03,449
if you execute something you know 50

00:06:59,969 --> 00:07:05,999
times a page load and I hope you don't

00:07:03,449 --> 00:07:08,099
execute 50 something something 50 times

00:07:05,999 --> 00:07:10,169
a page load but if you do you know

00:07:08,099 --> 00:07:11,309
making that a fraction better is

00:07:10,169 --> 00:07:14,669
probably going to be better than making

00:07:11,309 --> 00:07:18,059
one thing a lot better and test after

00:07:14,669 --> 00:07:19,499
each change you know so that you make

00:07:18,059 --> 00:07:20,999
sure you know what actually fixed the

00:07:19,499 --> 00:07:27,439
problem you're not combining different

00:07:20,999 --> 00:07:29,369
things so this is my don't assume slide

00:07:27,439 --> 00:07:30,899
sometimes and this is the fact of the

00:07:29,369 --> 00:07:33,929
future reference predicting the Cubs

00:07:30,899 --> 00:07:36,059
you're going to win this year I hope but

00:07:33,929 --> 00:07:37,589
anyway sometimes when you assume or gas

00:07:36,059 --> 00:07:41,300
or predict you're actually going to be

00:07:37,589 --> 00:07:43,649
right but most of the time you're not so

00:07:41,300 --> 00:07:45,209
we don't want to make assumptions we

00:07:43,649 --> 00:07:47,360
want to be empirical right we want to go

00:07:45,209 --> 00:07:49,499
with what the data tells us to go with

00:07:47,360 --> 00:07:51,179
and we don't want to assume that the

00:07:49,499 --> 00:07:54,509
data won't change this is especially

00:07:51,179 --> 00:07:56,309
applicable with like queries but with

00:07:54,509 --> 00:07:58,379
data and the system in general like the

00:07:56,309 --> 00:07:59,550
more data you get you're going to expose

00:07:58,379 --> 00:08:02,639
different things that are going to

00:07:59,550 --> 00:08:05,909
become real performance problems don't

00:08:02,639 --> 00:08:07,649
assume you're caching is working so if

00:08:05,909 --> 00:08:09,869
you've got a performance problem like

00:08:07,649 --> 00:08:13,019
don't assume akamai's caching or varnish

00:08:09,869 --> 00:08:14,849
or memcache or Redis or whatever check

00:08:13,019 --> 00:08:16,559
to make sure that the headers show it's

00:08:14,849 --> 00:08:19,409
cashing check to make sure your dad is

00:08:16,559 --> 00:08:23,189
getting stored query cache is actually

00:08:19,409 --> 00:08:26,039
working you know we had the we have a

00:08:23,189 --> 00:08:28,469
site launch and we've done all of our

00:08:26,039 --> 00:08:31,110
testing you know Akamai varnish

00:08:28,469 --> 00:08:33,709
everything was great right and we turn

00:08:31,110 --> 00:08:36,269
the switches and the servers go on fire

00:08:33,709 --> 00:08:37,800
and so we're all scrambling around you

00:08:36,269 --> 00:08:39,149
know meetings upon meetings upon

00:08:37,800 --> 00:08:41,639
meetings trying to figure out what the

00:08:39,149 --> 00:08:43,379
problem is and then we're in a

00:08:41,639 --> 00:08:46,709
conference call and I look and I'm like

00:08:43,379 --> 00:08:50,009
oh hey guys like Akamai showing a pass

00:08:46,709 --> 00:08:50,760
and so is varnish no no no I can't be

00:08:50,009 --> 00:08:53,790
the problem right

00:08:50,760 --> 00:08:55,260
we tested that it actually turned out it

00:08:53,790 --> 00:08:58,200
was the problem somebody made a change

00:08:55,260 --> 00:09:02,250
which disabled ball caching and servers

00:08:58,200 --> 00:09:06,410
on fire so you know we had assumed that

00:09:02,250 --> 00:09:13,200
everything was working so don't assume

00:09:06,410 --> 00:09:16,140
why no is not Obamacare and had nothing

00:09:13,200 --> 00:09:17,940
to do with that and don't prematurely

00:09:16,140 --> 00:09:23,040
optimize I'll say it again because I

00:09:17,940 --> 00:09:25,260
can't say it enough don't over optimize

00:09:23,040 --> 00:09:27,090
like unless speed is mission critical to

00:09:25,260 --> 00:09:29,250
you there's going to be a point at which

00:09:27,090 --> 00:09:31,470
the cost benefits of actually continuing

00:09:29,250 --> 00:09:35,370
the optimized or actually going to be

00:09:31,470 --> 00:09:38,160
not in your favor I'm a big data

00:09:35,370 --> 00:09:40,590
migration guy do it early in the life

00:09:38,160 --> 00:09:42,870
cycle of a project or use realistic

00:09:40,590 --> 00:09:45,360
substitute data and the key is realistic

00:09:42,870 --> 00:09:48,390
when you actually get real data in your

00:09:45,360 --> 00:09:50,790
app instead of you know no data or fake

00:09:48,390 --> 00:09:52,050
data you're going to expose a lot of

00:09:50,790 --> 00:09:54,150
performance issues and you're going to

00:09:52,050 --> 00:09:57,210
need to profile and it's a lot easier to

00:09:54,150 --> 00:10:01,140
profile before you launch then after you

00:09:57,210 --> 00:10:03,890
launch have a good test suite we found

00:10:01,140 --> 00:10:06,900
that like using Jenkins with like B hat

00:10:03,890 --> 00:10:09,420
is really good you can measure how long

00:10:06,900 --> 00:10:11,070
the B hat test take and then if you have

00:10:09,420 --> 00:10:14,100
like a nightly build or you run the test

00:10:11,070 --> 00:10:15,810
nightly you can chart in graphs like how

00:10:14,100 --> 00:10:17,670
long the tests are taking the runs you

00:10:15,810 --> 00:10:20,070
can see if there's a point at which your

00:10:17,670 --> 00:10:21,900
tests all of a sudden spike and then you

00:10:20,070 --> 00:10:23,850
can trace it back and you can actually

00:10:21,900 --> 00:10:26,970
have sort of a frame of reference to

00:10:23,850 --> 00:10:28,800
look for when you're profiling bonus

00:10:26,970 --> 00:10:31,050
points if you have something email you

00:10:28,800 --> 00:10:32,940
when something gets really out of bounds

00:10:31,050 --> 00:10:34,530
so that you don't have to go to remember

00:10:32,940 --> 00:10:37,290
to look at the Jenkins graphs you can

00:10:34,530 --> 00:10:39,210
actually just check your email and

00:10:37,290 --> 00:10:42,120
figure that you might need to dump your

00:10:39,210 --> 00:10:44,250
data from the beginning don't anger your

00:10:42,120 --> 00:10:47,070
sis admins and dump everything to the

00:10:44,250 --> 00:10:49,740
logs to make syslog grow they will yell

00:10:47,070 --> 00:10:51,690
at you but make sure that it's

00:10:49,740 --> 00:10:56,460
configurable you might need to dump your

00:10:51,690 --> 00:10:57,930
data at some point increasing memory is

00:10:56,460 --> 00:11:00,870
not a fix if you're running out of

00:10:57,930 --> 00:11:03,120
memory increasing memory won't help you

00:11:00,870 --> 00:11:04,529
but if you get out of memory errors

00:11:03,120 --> 00:11:06,300
think about what you're

00:11:04,529 --> 00:11:08,040
system has a lot of like does it have a

00:11:06,300 --> 00:11:09,689
lot of loops is loading a lot of data

00:11:08,040 --> 00:11:13,709
and that can point you in the right

00:11:09,689 --> 00:11:15,389
direction understand Big O concepts i'm

00:11:13,709 --> 00:11:17,399
not talking about interviewing at Google

00:11:15,389 --> 00:11:18,930
where you need to like memorize big o of

00:11:17,399 --> 00:11:21,360
like all the different sorting

00:11:18,930 --> 00:11:23,430
mechanisms and whatever but understand

00:11:21,360 --> 00:11:26,360
that like as your data grow with certain

00:11:23,430 --> 00:11:29,639
functions will scale better than others

00:11:26,360 --> 00:11:32,160
and match production settings doesn't

00:11:29,639 --> 00:11:36,089
matter which you use profile on prod or

00:11:32,160 --> 00:11:38,459
a reasonable facsimile thereof so I

00:11:36,089 --> 00:11:42,360
mentioned tools what are some of the

00:11:38,459 --> 00:11:45,629
tools that we can use to do profiling in

00:11:42,360 --> 00:11:48,899
PHP there's a couple main ones XH prop

00:11:45,629 --> 00:11:51,149
and XP bug there's also a new relic

00:11:48,899 --> 00:11:54,749
which I threw on the PHP slide because

00:11:51,149 --> 00:11:56,430
I've used it for PHP but I it's a

00:11:54,749 --> 00:11:58,230
service that those real-time monitoring

00:11:56,430 --> 00:12:02,639
and profiling of a lot of things

00:11:58,230 --> 00:12:05,699
including Ruby Python PHP note it even

00:12:02,639 --> 00:12:12,059
does docker containers now so it's a

00:12:05,699 --> 00:12:14,040
pretty nice service XH proc prof is the

00:12:12,059 --> 00:12:15,930
first one I was going to talk about it

00:12:14,040 --> 00:12:17,610
was created by Facebook originally and

00:12:15,930 --> 00:12:20,779
it's available on pekel so you can just

00:12:17,610 --> 00:12:23,910
install it it'll get you some basic

00:12:20,779 --> 00:12:25,290
statistics and it can do sampling which

00:12:23,910 --> 00:12:28,110
is really nice because you can generate

00:12:25,290 --> 00:12:30,329
flame graphs from it another nice

00:12:28,110 --> 00:12:33,720
feature that I love is you can do a diff

00:12:30,329 --> 00:12:36,120
of different runs and you can aggregate

00:12:33,720 --> 00:12:38,430
runs you can generate stats from like

00:12:36,120 --> 00:12:40,199
you know not a full day's worth runs

00:12:38,430 --> 00:12:41,910
hopefully but like you know you can run

00:12:40,199 --> 00:12:44,220
it for a short period of time get a lot

00:12:41,910 --> 00:12:48,089
of data aggregated and see if there's a

00:12:44,220 --> 00:12:50,730
commonality of things that are slow I'm

00:12:48,089 --> 00:12:52,410
sort of a Drupal guy so it's nice it's

00:12:50,730 --> 00:12:54,540
got modules and plugins for Drupal and

00:12:52,410 --> 00:12:58,350
WordPress so if you are in that space

00:12:54,540 --> 00:13:00,329
you can just drop it in the thing I'm

00:12:58,350 --> 00:13:04,379
not totally I don't totally love about

00:13:00,329 --> 00:13:06,839
XH prof is the GUI isn't the best it's

00:13:04,379 --> 00:13:09,059
pretty basic it's functional is a nice

00:13:06,839 --> 00:13:11,429
way to put it there are some side

00:13:09,059 --> 00:13:15,740
projects like XH GUI which do you make

00:13:11,429 --> 00:13:15,740
it better and sort of more modern

00:13:16,600 --> 00:13:23,690
XD bug is a good debugger and profiler

00:13:19,700 --> 00:13:25,790
it gets you a lot of data and the output

00:13:23,690 --> 00:13:27,920
can be used in K cash grind if anyone

00:13:25,790 --> 00:13:31,520
has used that or Q cash grind if you're

00:13:27,920 --> 00:13:33,710
using it on a mac and K cash grind is

00:13:31,520 --> 00:13:36,140
like a nice visualization tool for call

00:13:33,710 --> 00:13:38,839
stack data that you can just with a

00:13:36,140 --> 00:13:41,150
couple steps you know brew install a

00:13:38,839 --> 00:13:43,670
couple things on your Mac and then you

00:13:41,150 --> 00:13:46,640
can go and open anything in it any call

00:13:43,670 --> 00:13:48,740
stack data it's also integrated in

00:13:46,640 --> 00:13:54,080
phpstorm which is why a lot of people

00:13:48,740 --> 00:13:56,240
use it for Ruby there's a built-in

00:13:54,080 --> 00:13:58,339
profiler module but it's really not

00:13:56,240 --> 00:14:02,240
worth using it doesn't give you much

00:13:58,339 --> 00:14:04,550
data it's pretty basic so what do you

00:14:02,240 --> 00:14:07,130
use Ruby prof is sort of the gold

00:14:04,550 --> 00:14:09,950
standard the Ruby prof gem it's an

00:14:07,130 --> 00:14:11,660
event-based profiler it gets you a whole

00:14:09,950 --> 00:14:14,540
lot of different reports different

00:14:11,660 --> 00:14:17,690
options you can get text in HTML reports

00:14:14,540 --> 00:14:21,350
of a variety of different things call

00:14:17,690 --> 00:14:22,880
graphs call stacks flat profiles it's

00:14:21,350 --> 00:14:25,100
really easy to set up and you can

00:14:22,880 --> 00:14:27,290
profile your whole app or just specific

00:14:25,100 --> 00:14:29,300
chunks of it you can wrap specific

00:14:27,290 --> 00:14:31,820
blocks of code and like profiler lines

00:14:29,300 --> 00:14:33,470
and then see how that's performing or

00:14:31,820 --> 00:14:37,580
you can start up your server with it and

00:14:33,470 --> 00:14:40,580
profile your whole app this is just an

00:14:37,580 --> 00:14:43,580
example of a couple of graphs so I can

00:14:40,580 --> 00:14:47,029
set up something later a flat profile

00:14:43,580 --> 00:14:49,490
graph and a call stack graph as you can

00:14:47,029 --> 00:14:54,620
see they're not the prettiest they take

00:14:49,490 --> 00:14:57,680
some interpreting perf 20 RB might be my

00:14:54,620 --> 00:15:01,130
favorite it's a sampling profiler it's a

00:14:57,680 --> 00:15:02,959
fork of google perf tools for Ruby it's

00:15:01,130 --> 00:15:05,089
got a ton of different output modes

00:15:02,959 --> 00:15:08,120
including call grind if you want to use

00:15:05,089 --> 00:15:10,850
K cash grind it's also really easy to

00:15:08,120 --> 00:15:13,970
set up and if you're doing rails we've

00:15:10,850 --> 00:15:16,070
got rack perf tools profiler it's got

00:15:13,970 --> 00:15:18,260
more limited output modes but the really

00:15:16,070 --> 00:15:20,630
nice thing is it puts everything to the

00:15:18,260 --> 00:15:24,110
browser so if you just go to your appt

00:15:20,630 --> 00:15:25,790
you know your Ruby app and you put a

00:15:24,110 --> 00:15:28,400
profile equals true in the browser

00:15:25,790 --> 00:15:29,600
you'll get your output from the profiler

00:15:28,400 --> 00:15:31,940
instead of whatever you were

00:15:29,600 --> 00:15:33,620
supposed to output so you don't have to

00:15:31,940 --> 00:15:35,750
go digging around in the file system or

00:15:33,620 --> 00:15:40,639
anything like that and it look after you

00:15:35,750 --> 00:15:43,639
txt gif or PDF output so you can just go

00:15:40,639 --> 00:15:45,440
save it and use it you can also do

00:15:43,639 --> 00:15:47,480
things like in the query parameters

00:15:45,440 --> 00:15:49,399
change the frequency of the sampling

00:15:47,480 --> 00:15:53,269
change the mode for a variety of

00:15:49,399 --> 00:16:00,500
different things that's another sort of

00:15:53,269 --> 00:16:01,819
ugly call graph node has probably enough

00:16:00,500 --> 00:16:04,269
that we could fill the whole conference

00:16:01,819 --> 00:16:06,949
of people talking about node profilers

00:16:04,269 --> 00:16:09,740
some of the ones that I like a node

00:16:06,949 --> 00:16:13,130
WebKit agent is pretty good to set up

00:16:09,740 --> 00:16:15,829
and download webstorm is the JavaScript

00:16:13,130 --> 00:16:20,120
IDE it's got some profiling built into

00:16:15,829 --> 00:16:22,459
it strong loop arc and node source or

00:16:20,120 --> 00:16:25,310
services that also allow you to do

00:16:22,459 --> 00:16:27,199
profiling the latter one node source

00:16:25,310 --> 00:16:29,360
just came out with a new release that

00:16:27,199 --> 00:16:31,970
has a lot of incredible visualizations

00:16:29,360 --> 00:16:33,860
for your data so that one's worth

00:16:31,970 --> 00:16:40,130
checking out and I believe that's that's

00:16:33,860 --> 00:16:44,180
free to use for developers so flame

00:16:40,130 --> 00:16:47,660
graphs who here has used flame graphs or

00:16:44,180 --> 00:16:53,209
heard of them just a couple of you

00:16:47,660 --> 00:16:55,569
grades so this is a flame graph as the

00:16:53,209 --> 00:16:57,980
title of slide indicates it's pretty

00:16:55,569 --> 00:16:59,630
it's not like developer or designer

00:16:57,980 --> 00:17:02,689
pretty but we're not at a design

00:16:59,630 --> 00:17:04,510
conference so I shouldn't get things

00:17:02,689 --> 00:17:07,490
thrown at me for saying this is pretty

00:17:04,510 --> 00:17:10,059
but it's a lot better than all of the

00:17:07,490 --> 00:17:12,589
other graphs I showed it's more readable

00:17:10,059 --> 00:17:18,140
and you can figure things out a lot

00:17:12,589 --> 00:17:21,949
better so what is a flame graph and my

00:17:18,140 --> 00:17:25,819
mouth is over here it's a visual

00:17:21,949 --> 00:17:27,079
representation of profiled software for

00:17:25,819 --> 00:17:28,700
our purposes we're going to be talking

00:17:27,079 --> 00:17:31,900
about the call stack but you can make a

00:17:28,700 --> 00:17:36,409
flame graph out of just about anything

00:17:31,900 --> 00:17:37,970
each layer is a function and each column

00:17:36,409 --> 00:17:41,540
is the amount of time spent in the

00:17:37,970 --> 00:17:43,250
function so it's pretty basic that's all

00:17:41,540 --> 00:17:47,550
you need to know

00:17:43,250 --> 00:17:51,090
so why am I can use this thing that you

00:17:47,550 --> 00:17:54,210
showed me one is it's easy for

00:17:51,090 --> 00:17:55,920
non-technical people to see it if I show

00:17:54,210 --> 00:17:58,620
them a really ugly graph they're

00:17:55,920 --> 00:18:01,950
probably going to not have any idea what

00:17:58,620 --> 00:18:04,770
I'm talking about but I can show a CEO

00:18:01,950 --> 00:18:06,300
or something like this this and with a

00:18:04,770 --> 00:18:07,860
little bit of explaining they can see

00:18:06,300 --> 00:18:09,960
what the problem is and they'll have a

00:18:07,860 --> 00:18:11,940
lot more buy-in into why they need to

00:18:09,960 --> 00:18:16,590
spend the money and the resources to fix

00:18:11,940 --> 00:18:19,500
a problem it's also easy to diagnose

00:18:16,590 --> 00:18:21,210
quick problems um it's not going to be

00:18:19,500 --> 00:18:23,220
your end-all be-all and I see flame

00:18:21,210 --> 00:18:25,380
graphs kind of criticized a lot for like

00:18:23,220 --> 00:18:27,270
well you know it doesn't give me all the

00:18:25,380 --> 00:18:29,880
info but it's not really supposed to

00:18:27,270 --> 00:18:32,150
it's supposed to in one shot be able to

00:18:29,880 --> 00:18:34,500
show you if there's any glaring problem

00:18:32,150 --> 00:18:37,320
so it'll show you like what was on the

00:18:34,500 --> 00:18:39,810
cpu at each interval so you can see if

00:18:37,320 --> 00:18:42,150
something is on the cpu like 10 straight

00:18:39,810 --> 00:18:43,530
intervals for a second and you think it

00:18:42,150 --> 00:18:47,490
should be a lot faster than that you've

00:18:43,530 --> 00:18:50,270
got a problem too low overhead you can

00:18:47,490 --> 00:18:52,860
pretty much you know run a perl script

00:18:50,270 --> 00:18:56,610
generate an SVG and there's your flame

00:18:52,860 --> 00:18:59,130
graph and again they're pretty like

00:18:56,610 --> 00:19:03,260
don't underestimate the value of pretty

00:18:59,130 --> 00:19:03,260
or nice in explaining things to people

00:19:03,860 --> 00:19:09,840
so these flame graphs are cool how do i

00:19:07,230 --> 00:19:12,630
generate them there's a library here on

00:19:09,840 --> 00:19:16,770
github by a netflix engineer Brendan

00:19:12,630 --> 00:19:18,990
Greg which has all the scripts you'll

00:19:16,770 --> 00:19:21,120
need to create flame graphs it also has

00:19:18,990 --> 00:19:24,090
a lot of good documentation on how to do

00:19:21,120 --> 00:19:26,280
so you basically just need call stack

00:19:24,090 --> 00:19:28,860
data that's been converted to the right

00:19:26,280 --> 00:19:30,900
format and these scripts here available

00:19:28,860 --> 00:19:36,240
on github and you can get started

00:19:30,900 --> 00:19:38,990
generating them so for PHP there's a

00:19:36,240 --> 00:19:42,300
nice XH prof flame graph library here

00:19:38,990 --> 00:19:46,610
where you can take output from XH prof

00:19:42,300 --> 00:19:50,610
and create a flame graph readable input

00:19:46,610 --> 00:19:52,200
X debug has a lot of different libraries

00:19:50,610 --> 00:19:54,110
that will create flame graphs or flame

00:19:52,200 --> 00:19:57,960
graph data

00:19:54,110 --> 00:20:00,270
drupal has XH prof sample and XH pop

00:19:57,960 --> 00:20:05,550
flame graph modules you can just drop in

00:20:00,270 --> 00:20:09,150
and get flame graphs of any page ruby

00:20:05,550 --> 00:20:12,000
has rack mini profiler which is an ice

00:20:09,150 --> 00:20:14,130
profiler in and of itself it'll give you

00:20:12,000 --> 00:20:16,920
like a speed badge on your page where

00:20:14,130 --> 00:20:19,140
you can see how long each template each

00:20:16,920 --> 00:20:22,380
partial was taking the render all your

00:20:19,140 --> 00:20:24,510
sequel queries but I mention it here

00:20:22,380 --> 00:20:27,270
because you can also combine it with the

00:20:24,510 --> 00:20:29,760
flame graph gem and create flame graphs

00:20:27,270 --> 00:20:34,410
as long as long as you're using Ruby to

00:20:29,760 --> 00:20:35,970
end up and node in addition to some of

00:20:34,410 --> 00:20:39,090
the services i mentioned before which

00:20:35,970 --> 00:20:43,470
all have flame graphs you can use the

00:20:39,090 --> 00:20:47,100
perf library on Linux and generate flame

00:20:43,470 --> 00:20:50,670
graphs you can also use this github

00:20:47,100 --> 00:20:52,860
library node staff is the downside of

00:20:50,670 --> 00:20:55,290
that is it requires dtrace on your

00:20:52,860 --> 00:21:01,470
system so if you don't have that on your

00:20:55,290 --> 00:21:04,410
system you can't use this one so what

00:21:01,470 --> 00:21:06,150
does a healthy flame graph look like one

00:21:04,410 --> 00:21:09,630
of my colleagues at the phase two booths

00:21:06,150 --> 00:21:11,970
sort of likens it to a cardiologist you

00:21:09,630 --> 00:21:16,110
go through a lot of training to figure

00:21:11,970 --> 00:21:18,510
out what a normal EKG looks like right

00:21:16,110 --> 00:21:20,640
and so once you know what a normal one

00:21:18,510 --> 00:21:23,730
looks like anything else that doesn't

00:21:20,640 --> 00:21:25,350
fit that is bad and the same thing is

00:21:23,730 --> 00:21:28,320
kind of true with flame graphs so what

00:21:25,350 --> 00:21:31,290
am I looking for here um the main things

00:21:28,320 --> 00:21:34,020
I'm looking for are there shouldn't be

00:21:31,290 --> 00:21:36,780
anything at the top of the flame graph

00:21:34,020 --> 00:21:39,360
that goes on for a long time unless I

00:21:36,780 --> 00:21:41,400
expected and they're also shouldn't be

00:21:39,360 --> 00:21:44,309
anything anything that shows up that I

00:21:41,400 --> 00:21:46,170
don't expect so this one is pretty

00:21:44,309 --> 00:21:49,080
evenly spaced none of the call stacks

00:21:46,170 --> 00:21:52,290
are too high everything looks pretty

00:21:49,080 --> 00:21:54,000
even and in terms of this like each

00:21:52,290 --> 00:21:56,790
column is a tenth of a second

00:21:54,000 --> 00:21:58,770
measurement and then the call stack goes

00:21:56,790 --> 00:22:02,550
up so whatever is at the top was on the

00:21:58,770 --> 00:22:05,010
cpu whenever the sample was taken so

00:22:02,550 --> 00:22:05,930
what does a bad one look like like this

00:22:05,010 --> 00:22:11,250
one

00:22:05,930 --> 00:22:14,400
this was taken in Drupal i believe it's

00:22:11,250 --> 00:22:18,300
something like 220 samples so the page

00:22:14,400 --> 00:22:20,760
took about 22 seconds to load and so we

00:22:18,300 --> 00:22:24,000
see there's this giant PDO statement at

00:22:20,760 --> 00:22:25,740
the top and so obviously that's a pretty

00:22:24,000 --> 00:22:28,580
big problem but then we can trace it

00:22:25,740 --> 00:22:31,920
down and go okay what's calling that

00:22:28,580 --> 00:22:34,590
tracing even down farther and I see this

00:22:31,920 --> 00:22:37,440
Drupal cron run at the bottom that's

00:22:34,590 --> 00:22:39,810
taking up almost the entire time I

00:22:37,440 --> 00:22:43,380
wouldn't expect a cron run normally to

00:22:39,810 --> 00:22:46,110
be happening during a page load but

00:22:43,380 --> 00:22:49,440
Drupal has this thing where you can set

00:22:46,110 --> 00:22:51,270
Crohn's to happen every three hours six

00:22:49,440 --> 00:22:52,800
hours or whatever during page loads

00:22:51,270 --> 00:22:55,050
because if you don't have access to

00:22:52,800 --> 00:22:57,390
crontab on your system or on your

00:22:55,050 --> 00:23:00,840
provider you know it'll run it for you

00:22:57,390 --> 00:23:02,910
so you know pretty easy if I have the

00:23:00,840 --> 00:23:05,250
sampling data I create a flame graph

00:23:02,910 --> 00:23:07,530
like it doesn't take longer than about

00:23:05,250 --> 00:23:09,690
15 seconds to trace this thing down and

00:23:07,530 --> 00:23:12,120
figure out the problem click a setting

00:23:09,690 --> 00:23:14,490
in the UI and I fix the problem right

00:23:12,120 --> 00:23:15,420
and so you know with other things I

00:23:14,490 --> 00:23:21,990
might have had to do a lot more

00:23:15,420 --> 00:23:26,550
investigation than this the other thing

00:23:21,990 --> 00:23:29,940
to note is that the functions can get

00:23:26,550 --> 00:23:32,160
squashed together so this PDO statement

00:23:29,940 --> 00:23:34,290
executes at the top over here doesn't

00:23:32,160 --> 00:23:38,390
mean that's one statement it just means

00:23:34,290 --> 00:23:41,550
that each time the same flirt took data

00:23:38,390 --> 00:23:43,350
apdo statement was at the top and so

00:23:41,550 --> 00:23:46,350
what it did instead of showing us like

00:23:43,350 --> 00:23:48,180
you know PDO statement pd it just

00:23:46,350 --> 00:23:52,620
squashed the vault squashed it all

00:23:48,180 --> 00:23:55,410
together for us this is another

00:23:52,620 --> 00:23:59,580
unhealthy one you can see that again

00:23:55,410 --> 00:24:01,440
like there's some things f read which is

00:23:59,580 --> 00:24:04,200
sort of unexpectedly on the top for a

00:24:01,440 --> 00:24:07,710
long time turns out or make each making

00:24:04,200 --> 00:24:11,220
HTTP requests which we probably don't

00:24:07,710 --> 00:24:13,740
want to do but again like I can look at

00:24:11,220 --> 00:24:16,320
it you like this is unhealthy what

00:24:13,740 --> 00:24:17,639
exactly is calling one and then get a

00:24:16,320 --> 00:24:19,649
good idea of

00:24:17,639 --> 00:24:24,570
of if you have any glaring problems with

00:24:19,649 --> 00:24:28,019
your app the last thing I wanted to

00:24:24,570 --> 00:24:32,789
mention is query tuning because a lot of

00:24:28,019 --> 00:24:35,969
the times what I see is we've isolated

00:24:32,789 --> 00:24:38,969
the problem to be MySQL would be our

00:24:35,969 --> 00:24:41,339
queries or something like that so it's

00:24:38,969 --> 00:24:44,039
like okay what's the problem well this

00:24:41,339 --> 00:24:45,809
thing's got a lot of joins are like it's

00:24:44,039 --> 00:24:49,169
got an outer join it must be the problem

00:24:45,809 --> 00:24:51,649
right but as I mentioned before if you

00:24:49,169 --> 00:24:55,769
don't have data and you're just guessing

00:24:51,649 --> 00:24:58,799
so how do we get data to figure out why

00:24:55,769 --> 00:25:03,799
our queries are bad and what queries are

00:24:58,799 --> 00:25:07,859
bad so we have the slow query log in

00:25:03,799 --> 00:25:12,869
mysql i use the slow query log and slow

00:25:07,859 --> 00:25:14,879
query log file settings and you can turn

00:25:12,869 --> 00:25:18,059
on the slow query log and that's going

00:25:14,879 --> 00:25:19,769
to log all your queries that satisfy a

00:25:18,059 --> 00:25:22,739
couple conditions that they take at

00:25:19,769 --> 00:25:25,829
least X number of seconds and examine at

00:25:22,739 --> 00:25:28,950
least X number of rows I believed by

00:25:25,829 --> 00:25:31,289
default this is 10 seconds and euro rose

00:25:28,950 --> 00:25:34,769
so it's probably not going to capture a

00:25:31,289 --> 00:25:36,389
lot of queries and any MySQL or

00:25:34,769 --> 00:25:37,769
proponent people in the audience feel

00:25:36,389 --> 00:25:42,539
free to heckle me if I say something

00:25:37,769 --> 00:25:46,489
wrong it's not going to get your admin

00:25:42,539 --> 00:25:49,769
statements like altar drop create etc

00:25:46,489 --> 00:25:52,259
and there is what sounds like a nice

00:25:49,769 --> 00:25:55,289
little switch called log queries not

00:25:52,259 --> 00:25:56,549
using indexes and you would think well I

00:25:55,289 --> 00:25:58,169
want to turn I want to see all my

00:25:56,549 --> 00:26:00,149
queries that don't use indexes right so

00:25:58,169 --> 00:26:01,889
those are probably going to be bad but

00:26:00,149 --> 00:26:05,190
you're going to get a lot of extra data

00:26:01,889 --> 00:26:08,329
using this because sometimes mysql

00:26:05,190 --> 00:26:11,629
things you know doing a full table scan

00:26:08,329 --> 00:26:14,190
is going to be the best way to go a

00:26:11,629 --> 00:26:17,429
query that doesn't use indexes doesn't

00:26:14,190 --> 00:26:18,989
mean it's a bad query or a slow query so

00:26:17,429 --> 00:26:20,729
just know that if you decide to log

00:26:18,989 --> 00:26:23,209
everything not using indexes you're

00:26:20,729 --> 00:26:26,489
going to get a lot of false positives

00:26:23,209 --> 00:26:29,760
 you can turn on profiling as well

00:26:26,489 --> 00:26:32,520
DB that's that profile filing level

00:26:29,760 --> 00:26:37,530
and it stores your profile data in the

00:26:32,520 --> 00:26:40,140
system that profile collection you can

00:26:37,530 --> 00:26:43,110
also use show process list or show full

00:26:40,140 --> 00:26:44,490
process list in mysql and that will show

00:26:43,110 --> 00:26:46,590
you the queries that are currently

00:26:44,490 --> 00:26:48,000
executing and what state they're in so

00:26:46,590 --> 00:26:51,030
if you have something that looks like a

00:26:48,000 --> 00:26:53,520
tongue you can go show full process list

00:26:51,030 --> 00:26:55,020
and see all your queries and see what

00:26:53,520 --> 00:26:57,810
state they're in and some of the conduct

00:26:55,020 --> 00:26:59,600
common States sending data which means

00:26:57,810 --> 00:27:03,300
it's sending data back to the client

00:26:59,600 --> 00:27:06,600
copying to temp table locked for certain

00:27:03,300 --> 00:27:09,750
engines so that's pretty useful if

00:27:06,600 --> 00:27:12,150
you've got some long running queries my

00:27:09,750 --> 00:27:16,470
sequel dumb slow will parse your slow

00:27:12,150 --> 00:27:18,390
query log and show you sort of some

00:27:16,470 --> 00:27:21,630
group together queries show you some

00:27:18,390 --> 00:27:24,870
stats percona has something that's even

00:27:21,630 --> 00:27:26,400
better called PT query digest which in

00:27:24,870 --> 00:27:28,680
addition to doing some of the things my

00:27:26,400 --> 00:27:31,260
sequel dumps flow will do will actually

00:27:28,680 --> 00:27:33,840
show you that the queries that have the

00:27:31,260 --> 00:27:35,910
highest aggregate total so when I talk

00:27:33,840 --> 00:27:38,310
about like you want to focus in on some

00:27:35,910 --> 00:27:40,700
of the things that run more frequently

00:27:38,310 --> 00:27:43,500
because they might be better to optimize

00:27:40,700 --> 00:27:46,860
PT query digest will help you sort of

00:27:43,500 --> 00:27:49,220
hone in on which queries those are and

00:27:46,860 --> 00:27:51,960
logging in your app like a lot of apps

00:27:49,220 --> 00:27:53,910
have logging enabled where you can like

00:27:51,960 --> 00:28:01,890
see all the slow queries or see all the

00:27:53,910 --> 00:28:03,780
queries so why is my query slow this in

00:28:01,890 --> 00:28:06,660
and of itself can be like a three-hour

00:28:03,780 --> 00:28:10,230
session or more some of the common

00:28:06,660 --> 00:28:13,440
things though are there's just too much

00:28:10,230 --> 00:28:17,400
data so you might be fetching too many

00:28:13,440 --> 00:28:20,520
columns or rows a common problem is like

00:28:17,400 --> 00:28:21,810
select star so if you select star you're

00:28:20,520 --> 00:28:24,390
going to get all the columns in the

00:28:21,810 --> 00:28:26,700
table and that's bad for a couple

00:28:24,390 --> 00:28:29,760
reasons one is you're not going to be

00:28:26,700 --> 00:28:31,320
able to use a covering index so instead

00:28:29,760 --> 00:28:32,760
of being able to read the data that you

00:28:31,320 --> 00:28:35,730
really need from an index you're

00:28:32,760 --> 00:28:37,710
probably going to go to disk and the

00:28:35,730 --> 00:28:40,020
other is you're just sending a lot of

00:28:37,710 --> 00:28:43,240
data you don't need to send back to the

00:28:40,020 --> 00:28:46,990
client and examining too many

00:28:43,240 --> 00:28:48,730
rose so if mysql has to examine too many

00:28:46,990 --> 00:28:52,080
rows that's going to make things slow as

00:28:48,730 --> 00:28:57,100
well like common examples of that are

00:28:52,080 --> 00:28:59,530
few he forgot a limit if you have aware

00:28:57,100 --> 00:29:02,320
and you have to generate all the results

00:28:59,530 --> 00:29:05,620
before you throw some things out if you

00:29:02,320 --> 00:29:07,660
don't have proper indexes mysql is going

00:29:05,620 --> 00:29:12,520
to examine more rows than you really

00:29:07,660 --> 00:29:13,660
need to a poorly designed schema the

00:29:12,520 --> 00:29:15,850
thing I'm going to mention here is that

00:29:13,660 --> 00:29:18,070
shorter rows are generally better so use

00:29:15,850 --> 00:29:20,920
the smallest data type you need for

00:29:18,070 --> 00:29:23,380
whatever your columns are some things

00:29:20,920 --> 00:29:25,390
when they create temp tables will use

00:29:23,380 --> 00:29:28,150
all the available space regardless of

00:29:25,390 --> 00:29:30,429
how much data there actually is so the

00:29:28,150 --> 00:29:32,110
larger your data types the larger your

00:29:30,429 --> 00:29:35,320
temp table is going to be and the slower

00:29:32,110 --> 00:29:38,950
your performance in those cases and the

00:29:35,320 --> 00:29:41,800
lock lack of proper indexes note I

00:29:38,950 --> 00:29:44,530
didn't say the lack of indexes because

00:29:41,800 --> 00:29:46,960
adding an index is not necessarily going

00:29:44,530 --> 00:29:50,710
to fix your problem adding a proper

00:29:46,960 --> 00:29:52,929
index can fix your problem and what do I

00:29:50,710 --> 00:29:55,330
mean by that I mean you want to make

00:29:52,929 --> 00:29:58,450
sure that the columns you're joining on

00:29:55,330 --> 00:30:03,160
are indexed you want to make sure that

00:29:58,450 --> 00:30:05,020
if you have let's see an order by that

00:30:03,160 --> 00:30:07,929
that you have an index on that as well

00:30:05,020 --> 00:30:09,850
in the proper order you want to make

00:30:07,929 --> 00:30:13,179
sure that you can use a covering index

00:30:09,850 --> 00:30:15,250
in some cases and that's an index that

00:30:13,179 --> 00:30:17,170
has all of the columns that you need to

00:30:15,250 --> 00:30:19,480
select so you can just go to the index

00:30:17,170 --> 00:30:23,610
and grab your data instead of having to

00:30:19,480 --> 00:30:27,040
go and fetch all the data from the disk

00:30:23,610 --> 00:30:30,160
too many indexes is actually also a

00:30:27,040 --> 00:30:31,809
problem on inserts the more indexes you

00:30:30,160 --> 00:30:35,710
have the slower your inserts are going

00:30:31,809 --> 00:30:37,660
to be so be judicious with your indexes

00:30:35,710 --> 00:30:39,100
don't just create one for every column

00:30:37,660 --> 00:30:43,090
that's probably going to be not

00:30:39,100 --> 00:30:46,600
beneficial in the long run inefficient

00:30:43,090 --> 00:30:48,130
sequel is another reason so I hear a lot

00:30:46,600 --> 00:30:51,250
of light should this be a sub-query

00:30:48,130 --> 00:30:54,010
should this be a join the answer is I

00:30:51,250 --> 00:30:55,990
don't know like it really depends on

00:30:54,010 --> 00:30:56,899
your situation this is sort of where

00:30:55,990 --> 00:31:00,769
trial and error

00:30:56,899 --> 00:31:02,299
will work for you in general joins are

00:31:00,769 --> 00:31:04,779
probably going to be better but in some

00:31:02,299 --> 00:31:09,229
cases sub queries are going to be better

00:31:04,779 --> 00:31:12,589
count star is probably going to be slow

00:31:09,229 --> 00:31:14,149
unless you're on my I Sam which and

00:31:12,589 --> 00:31:15,919
you're not using a where clause in which

00:31:14,149 --> 00:31:18,109
case you can just look at the table

00:31:15,919 --> 00:31:20,570
stats and going does how many rows there

00:31:18,109 --> 00:31:21,830
are in all are there cases you're

00:31:20,570 --> 00:31:26,749
probably gonna have to generate the full

00:31:21,830 --> 00:31:28,729
results set so that's something where if

00:31:26,749 --> 00:31:30,769
you can get away without using count and

00:31:28,729 --> 00:31:32,210
just you know get an estimate or

00:31:30,769 --> 00:31:35,899
something like that you might be better

00:31:32,210 --> 00:31:39,679
off hi offsets if you do something like

00:31:35,899 --> 00:31:41,059
limit 5,000 come attend you're just

00:31:39,679 --> 00:31:42,739
going to generate a lot of data and

00:31:41,059 --> 00:31:44,719
throw it away you're better off

00:31:42,739 --> 00:31:48,440
rewriting your query is a range query

00:31:44,719 --> 00:31:50,059
like using between or even better like

00:31:48,440 --> 00:31:52,039
figuring out what the last thing you got

00:31:50,059 --> 00:31:54,320
was and then sticking that in the we're

00:31:52,039 --> 00:31:58,339
like you know where this is greater than

00:31:54,320 --> 00:32:02,539
blah limit 10 that's going to have a lot

00:31:58,339 --> 00:32:04,639
better performance disk versus memory

00:32:02,539 --> 00:32:06,679
obviously fetching things from memory is

00:32:04,639 --> 00:32:08,509
faster than disk so make sure that

00:32:06,679 --> 00:32:10,700
you've got enough memory allocated and

00:32:08,509 --> 00:32:14,299
that whatever you need to fit in memory

00:32:10,700 --> 00:32:16,460
can fit in there sorting can be slow so

00:32:14,299 --> 00:32:19,399
make sure you've got columns you're

00:32:16,460 --> 00:32:22,129
going to be ordering by indexed and that

00:32:19,399 --> 00:32:24,769
they're actually able to be used the

00:32:22,129 --> 00:32:27,440
query cache believe it or not can slow

00:32:24,769 --> 00:32:30,559
things down what actually the query

00:32:27,440 --> 00:32:32,389
cache does is if you've got two turned

00:32:30,559 --> 00:32:34,729
on when a query comes in it does a

00:32:32,389 --> 00:32:38,089
case-insensitive hash look up and says

00:32:34,729 --> 00:32:41,059
have I seen this query before and if so

00:32:38,089 --> 00:32:43,039
return the results that if not then i

00:32:41,059 --> 00:32:45,799
have to go execute the query and store

00:32:43,039 --> 00:32:48,499
the result set and then every insert

00:32:45,799 --> 00:32:50,210
after that has to not only do its

00:32:48,499 --> 00:32:52,339
inserts but then it goes through and

00:32:50,210 --> 00:32:55,369
says okay all the tables i just modified

00:32:52,339 --> 00:32:57,139
i have to invalidate all the entries in

00:32:55,369 --> 00:32:59,599
the query cache which use these tables

00:32:57,139 --> 00:33:01,909
so you're doing a lot of overhead on

00:32:59,599 --> 00:33:05,389
both sides on the select and on the

00:33:01,909 --> 00:33:07,339
insert and the question is is that going

00:33:05,389 --> 00:33:09,810
to be better than or is that going to be

00:33:07,339 --> 00:33:12,540
worse than like taking advantage of the

00:33:09,810 --> 00:33:17,040
cash so like for right heavy sites query

00:33:12,540 --> 00:33:19,260
cache generally bad for sites that have

00:33:17,040 --> 00:33:22,710
a lot of complex queries that have small

00:33:19,260 --> 00:33:24,120
result sets query cache good sort of the

00:33:22,710 --> 00:33:26,250
answer of whether you should turn it on

00:33:24,120 --> 00:33:31,140
or not is depends on the types of

00:33:26,250 --> 00:33:33,720
queries that you have so how do i get

00:33:31,140 --> 00:33:35,670
data about what the queries actually

00:33:33,720 --> 00:33:37,500
doing what the problem might be you just

00:33:35,670 --> 00:33:39,750
listed like eight different problems and

00:33:37,500 --> 00:33:42,870
there's probably actually hundreds you

00:33:39,750 --> 00:33:44,900
can use explain so in MySQL you can

00:33:42,870 --> 00:33:47,580
prefix your select query with explain

00:33:44,900 --> 00:33:49,650
and it will give you the execution path

00:33:47,580 --> 00:33:52,410
that the optimizer chose for that

00:33:49,650 --> 00:33:54,960
particular query postgrads has something

00:33:52,410 --> 00:33:57,000
similar explained and explained analyze

00:33:54,960 --> 00:33:59,940
which will show you what path it

00:33:57,000 --> 00:34:02,070
actually took by executing the query

00:33:59,940 --> 00:34:05,730
 has something similar pretty much

00:34:02,070 --> 00:34:07,290
every database has something similar so

00:34:05,730 --> 00:34:10,230
you mentioned this optimize your thing

00:34:07,290 --> 00:34:12,780
like what does it do so when you send a

00:34:10,230 --> 00:34:14,460
query in the my SQL optimizer will

00:34:12,780 --> 00:34:17,100
choose the execution paths with the

00:34:14,460 --> 00:34:20,040
lowest cost that's not necessarily the

00:34:17,100 --> 00:34:22,860
fastest query that's looking at the

00:34:20,040 --> 00:34:25,680
number of rows the indexes cardinality

00:34:22,860 --> 00:34:28,530
key length etc and figuring out what it

00:34:25,680 --> 00:34:32,430
thinks is the lowest cost to execute the

00:34:28,530 --> 00:34:34,440
query in five dot six there's a nice

00:34:32,430 --> 00:34:37,530
thing called optimizer trace which will

00:34:34,440 --> 00:34:40,170
actually show you a lot of info about

00:34:37,530 --> 00:34:43,290
why it made decisions it made and what

00:34:40,170 --> 00:34:45,450
the various costs were and then 57

00:34:43,290 --> 00:34:47,280
there's something called explain format

00:34:45,450 --> 00:34:49,560
equals JSON which will give you JSON

00:34:47,280 --> 00:34:51,420
output with a lot of that same data so

00:34:49,560 --> 00:34:54,950
you can see like what the various costs

00:34:51,420 --> 00:34:57,390
were of various various types of queries

00:34:54,950 --> 00:34:59,880
and figure out why it shows the path

00:34:57,390 --> 00:35:02,070
that did and then the optimizer does

00:34:59,880 --> 00:35:04,530
things like reorder and convert joins

00:35:02,070 --> 00:35:10,050
sub query optimization it does a lot of

00:35:04,530 --> 00:35:12,000
things so what's the output look like so

00:35:10,050 --> 00:35:15,840
I've got a basic query here I've got to

00:35:12,000 --> 00:35:18,240
select a couple joins a sub query and my

00:35:15,840 --> 00:35:21,670
from that'll create a drive table you

00:35:18,240 --> 00:35:24,970
know and then aware in the limit and

00:35:21,670 --> 00:35:27,369
so when I run explain what's at the top

00:35:24,970 --> 00:35:29,290
is sort of what I got and you can get

00:35:27,369 --> 00:35:31,750
different output if you if you put /

00:35:29,290 --> 00:35:35,680
capital G it'll show you like more

00:35:31,750 --> 00:35:38,770
vertical output I like horizontal and so

00:35:35,680 --> 00:35:41,079
what are these columns look like so ID

00:35:38,770 --> 00:35:43,420
the first column is the Select that the

00:35:41,079 --> 00:35:45,369
road belongs to it's usually one unless

00:35:43,420 --> 00:35:49,000
you've got sub query usually unions or

00:35:45,369 --> 00:35:51,790
something like that select type will

00:35:49,000 --> 00:35:54,549
tell you whether it's simple in the case

00:35:51,790 --> 00:35:56,799
of a normal select or complex and if

00:35:54,549 --> 00:36:00,280
it's complex it'll give you like primary

00:35:56,799 --> 00:36:04,150
which is the outermost query derived

00:36:00,280 --> 00:36:06,099
which is like a sub query and from union

00:36:04,150 --> 00:36:09,369
or there's a bunch of other types but

00:36:06,099 --> 00:36:11,829
those are sort of the most common table

00:36:09,369 --> 00:36:15,400
the third column is the table name or

00:36:11,829 --> 00:36:17,500
alias and then type the fourth column is

00:36:15,400 --> 00:36:19,660
probably one of the couple most

00:36:17,500 --> 00:36:24,849
important and that's the access type or

00:36:19,660 --> 00:36:27,970
how mysql is going to access the rows so

00:36:24,849 --> 00:36:29,829
I see a couple here that's all and

00:36:27,970 --> 00:36:32,230
that's usually a full table scan and

00:36:29,829 --> 00:36:38,079
it's generally bad unless you have a

00:36:32,230 --> 00:36:40,329
small table index does a full full scan

00:36:38,079 --> 00:36:41,980
of the index and range does a limited

00:36:40,329 --> 00:36:46,089
index scan that's like when you're doing

00:36:41,980 --> 00:36:49,299
between on an index column you can have

00:36:46,089 --> 00:36:52,630
Raph or eqe Raph knows both refer to

00:36:49,299 --> 00:36:55,030
like how the things are joined so eq

00:36:52,630 --> 00:36:57,040
raft is one of the best types that's

00:36:55,030 --> 00:36:59,980
when you join a unique non-null index

00:36:57,040 --> 00:37:02,829
like a primary key and an indexed field

00:36:59,980 --> 00:37:05,619
so you've only got one one possible row

00:37:02,829 --> 00:37:07,540
that's going to match and const or a

00:37:05,619 --> 00:37:09,250
constant is going to only return one

00:37:07,540 --> 00:37:11,740
value from an index it's like when

00:37:09,250 --> 00:37:13,299
you're selecting something from a from a

00:37:11,740 --> 00:37:18,609
primary key and you actually give the

00:37:13,299 --> 00:37:20,380
value in the where clause possible keys

00:37:18,609 --> 00:37:22,809
here that'll show you which possible

00:37:20,380 --> 00:37:27,220
indexes the optimizer thought it could

00:37:22,809 --> 00:37:31,180
use key is which index actually is going

00:37:27,220 --> 00:37:32,980
to be used fun note the key doesn't have

00:37:31,180 --> 00:37:34,780
to appear in the list of possible keys

00:37:32,980 --> 00:37:37,610
sometimes it won't

00:37:34,780 --> 00:37:39,830
key length is the bytes of the index

00:37:37,610 --> 00:37:41,720
that was used so if it's a large index

00:37:39,830 --> 00:37:43,430
you can see how you know based on how

00:37:41,720 --> 00:37:47,750
many bytes were used which columns it

00:37:43,430 --> 00:37:49,790
was looking at and then Raph sort of the

00:37:47,750 --> 00:37:54,470
feel that used to look up values in the

00:37:49,790 --> 00:37:56,930
index or the constant rose is probably

00:37:54,470 --> 00:37:58,910
number two in the biggies that's an

00:37:56,930 --> 00:38:02,150
estimate of the rows my sequel will need

00:37:58,910 --> 00:38:06,680
to read sometimes that can be wildly

00:38:02,150 --> 00:38:09,680
inaccurate for certain engines but again

00:38:06,680 --> 00:38:12,830
it's an estimate it's also a cartesian

00:38:09,680 --> 00:38:14,780
product so to get the number of rows

00:38:12,830 --> 00:38:17,870
it's going to have to scan you multiply

00:38:14,780 --> 00:38:20,480
all of them together not add see you

00:38:17,870 --> 00:38:24,050
that's probably above my math abilities

00:38:20,480 --> 00:38:26,930
but that's a really big number extra is

00:38:24,050 --> 00:38:30,110
going to have everything else so notes

00:38:26,930 --> 00:38:32,150
about using filesort which means that my

00:38:30,110 --> 00:38:35,510
sequel is going to do the sorting itself

00:38:32,150 --> 00:38:37,730
rather than read from an index using

00:38:35,510 --> 00:38:40,190
temporary means it's using a temporary

00:38:37,730 --> 00:38:43,310
table it doesn't mean on disk it could

00:38:40,190 --> 00:38:45,080
be in memory using filesort and using

00:38:43,310 --> 00:38:47,120
temporary together is sort of a double

00:38:45,080 --> 00:38:48,680
whammy of creating a temporary table to

00:38:47,120 --> 00:38:51,020
hold the full results set and then

00:38:48,680 --> 00:38:54,110
sorting it so if you see that you

00:38:51,020 --> 00:38:57,950
probably want to try to fix it using

00:38:54,110 --> 00:38:59,810
where basically means that yes it's

00:38:57,950 --> 00:39:01,580
using a where clause but it's generating

00:38:59,810 --> 00:39:05,780
a lot of results and throwing a lot of

00:39:01,580 --> 00:39:08,930
them away and then using index is

00:39:05,780 --> 00:39:11,080
different than index in the type that

00:39:08,930 --> 00:39:14,930
means it's using a covering index

00:39:11,080 --> 00:39:21,230
there's a lot more those are some of the

00:39:14,930 --> 00:39:25,700
most common and explain sometimes lies

00:39:21,230 --> 00:39:27,740
or is inaccurate so one of the reasons

00:39:25,700 --> 00:39:29,720
is the table statistics are wrong you

00:39:27,740 --> 00:39:32,120
can run analyze table to update the

00:39:29,720 --> 00:39:35,090
stats and that might make the optimizer

00:39:32,120 --> 00:39:37,970
choose a different path or it can

00:39:35,090 --> 00:39:40,520
estimate every possible plan based on

00:39:37,970 --> 00:39:42,620
the number of like joins you have it's

00:39:40,520 --> 00:39:45,350
going to be n factorial where n is the

00:39:42,620 --> 00:39:47,900
number of joins so sometimes it can I

00:39:45,350 --> 00:39:52,910
estimate every possible plan

00:39:47,900 --> 00:39:55,430
so if you think it's wrong and I would

00:39:52,910 --> 00:39:58,760
tread carefully there you can use

00:39:55,430 --> 00:40:01,309
straight join in your select and that'll

00:39:58,760 --> 00:40:03,109
say you know hey optimizer do all the

00:40:01,309 --> 00:40:06,230
joins in the order I tell you not the

00:40:03,109 --> 00:40:09,500
order you think is best you can also

00:40:06,230 --> 00:40:13,369
tell it to use an index ignore an index

00:40:09,500 --> 00:40:16,250
or force an index the difference between

00:40:13,369 --> 00:40:18,589
use and forces use will say hey out of

00:40:16,250 --> 00:40:22,309
these indexes you can choose these and

00:40:18,589 --> 00:40:24,319
force will say you have to use this one

00:40:22,309 --> 00:40:27,470
even if you think a full table scan is

00:40:24,319 --> 00:40:30,289
better because the amount of rows use

00:40:27,470 --> 00:40:34,039
this index I've only had to use these a

00:40:30,289 --> 00:40:36,529
couple of times so i would i would avoid

00:40:34,039 --> 00:40:41,329
these unless you know for sure that the

00:40:36,529 --> 00:40:44,529
optimizer is being silly I think that's

00:40:41,329 --> 00:40:44,529

YouTube URL: https://www.youtube.com/watch?v=hsj0clNybng


