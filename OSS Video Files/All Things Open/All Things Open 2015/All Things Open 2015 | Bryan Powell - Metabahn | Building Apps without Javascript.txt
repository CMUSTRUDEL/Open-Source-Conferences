Title: All Things Open 2015 | Bryan Powell - Metabahn | Building Apps without Javascript
Publication date: 2015-11-19
Playlist: All Things Open 2015
Description: 
	All Things Open 2015, October 19th and 20th, Raleigh NC.
Captions: 
	00:00:04,069 --> 00:00:09,500
this is a topic that's sort of been on

00:00:07,109 --> 00:00:12,660
my mind a lot the last couple of years

00:00:09,500 --> 00:00:16,260
done a lot of thinking this talk sort of

00:00:12,660 --> 00:00:18,990
encompasses a lot of that thinking so

00:00:16,260 --> 00:00:21,270
where I want to start is kind of with

00:00:18,990 --> 00:00:24,060
the current state of web development how

00:00:21,270 --> 00:00:25,619
we build things today I want to describe

00:00:24,060 --> 00:00:28,289
briefly sort of where I think it's

00:00:25,619 --> 00:00:30,539
lacking then I'm going to show an

00:00:28,289 --> 00:00:33,500
alternate way of building these sort of

00:00:30,539 --> 00:00:36,030
modern real-time how do I paying

00:00:33,500 --> 00:00:37,680
applications I mean I completely

00:00:36,030 --> 00:00:38,820
different a new way that you're probably

00:00:37,680 --> 00:00:43,290
used to and I think you're going to like

00:00:38,820 --> 00:00:44,520
it so this talk is sort of promised on

00:00:43,290 --> 00:00:49,170
this idea that the web should not be

00:00:44,520 --> 00:00:51,629
single page so as temperatures Lisa

00:00:49,170 --> 00:00:52,860
River originally defined the web it was

00:00:51,629 --> 00:00:55,710
a collection of these hyperlink

00:00:52,860 --> 00:00:59,670
documents so by its very nature the

00:00:55,710 --> 00:01:02,340
web's not a single page thing and so in

00:00:59,670 --> 00:01:05,159
today's environment we sort of built all

00:01:02,340 --> 00:01:06,780
kinds of different things for the web we

00:01:05,159 --> 00:01:08,400
build applications that happen to be

00:01:06,780 --> 00:01:10,110
delivered through the browser and then

00:01:08,400 --> 00:01:11,939
we build some more traditional content

00:01:10,110 --> 00:01:18,330
focused websites and we all call me call

00:01:11,939 --> 00:01:19,439
this all the web the second real point

00:01:18,330 --> 00:01:22,470
that I'm trying to make is I think we

00:01:19,439 --> 00:01:23,939
need a better way to build the web so to

00:01:22,470 --> 00:01:26,880
sort of make this distinction a little

00:01:23,939 --> 00:01:29,579
bit more clear this is slack how many

00:01:26,880 --> 00:01:32,790
people here use slack yes I use fight

00:01:29,579 --> 00:01:35,939
every day i love slack slack isn't

00:01:32,790 --> 00:01:38,640
really what i call a web though so by my

00:01:35,939 --> 00:01:40,229
definition slack is an application it's

00:01:38,640 --> 00:01:41,549
built using web technologies it's

00:01:40,229 --> 00:01:45,140
delivered over the internet through a

00:01:41,549 --> 00:01:47,909
web browser but it is really the web

00:01:45,140 --> 00:01:51,299
slack doesn't work without JavaScript

00:01:47,909 --> 00:01:53,670
that's great that's fine it's a windows

00:01:51,299 --> 00:01:55,350
a single page app and I think that you

00:01:53,670 --> 00:01:56,969
could make the argument that that's the

00:01:55,350 --> 00:01:58,210
best way to build slack slack is not a

00:01:56,969 --> 00:02:02,020
content delivery

00:01:58,210 --> 00:02:05,200
platform or tool slack exists so that I

00:02:02,020 --> 00:02:07,360
can collaborate really effectively and

00:02:05,200 --> 00:02:08,740
quickly with my coworkers it's a

00:02:07,360 --> 00:02:12,400
collaboration tool not a content

00:02:08,740 --> 00:02:15,489
delivery platform on the other hand we

00:02:12,400 --> 00:02:18,700
have something like the New York Times

00:02:15,489 --> 00:02:20,530
this is just an example and I think we

00:02:18,700 --> 00:02:25,150
all agree the New York Times is not a

00:02:20,530 --> 00:02:29,050
web app it's a website the New York

00:02:25,150 --> 00:02:31,480
Times is itself sort of this collection

00:02:29,050 --> 00:02:34,420
of hyper these documents they linked to

00:02:31,480 --> 00:02:36,550
one another these documents link out to

00:02:34,420 --> 00:02:43,630
other aspects of the web and other parts

00:02:36,550 --> 00:02:45,190
the web link back to it fortunately New

00:02:43,630 --> 00:02:46,900
York Times isn't implemented as a single

00:02:45,190 --> 00:02:50,050
page web app it's more traditional

00:02:46,900 --> 00:02:53,320
server rendered the New York Times works

00:02:50,050 --> 00:02:55,840
without javascript and well for the most

00:02:53,320 --> 00:02:58,120
part nothing's perfect right in fact if

00:02:55,840 --> 00:03:00,069
you turn off any layer of enhancement

00:02:58,120 --> 00:03:02,350
only york times you still get access to

00:03:00,069 --> 00:03:04,930
your content so you turn off javascript

00:03:02,350 --> 00:03:07,600
as a user I can still read an article we

00:03:04,930 --> 00:03:10,060
turn off CSS I as a user can still read

00:03:07,600 --> 00:03:11,950
the article it's not as doesn't look as

00:03:10,060 --> 00:03:13,600
nice maybe but I can still get access to

00:03:11,950 --> 00:03:15,790
the content that I'm after if you turn

00:03:13,600 --> 00:03:17,890
off them into the same story via the alt

00:03:15,790 --> 00:03:19,840
tag i can understand sir the context

00:03:17,890 --> 00:03:25,030
behind these images so that sort of

00:03:19,840 --> 00:03:28,660
points to what this part of the web

00:03:25,030 --> 00:03:30,190
really prioritizes because consta

00:03:28,660 --> 00:03:32,290
content first because that's the thing

00:03:30,190 --> 00:03:35,890
that's accessible no matter what I as

00:03:32,290 --> 00:03:38,590
the user do so i would say content is an

00:03:35,890 --> 00:03:40,540
ultimate concern here so we have these

00:03:38,590 --> 00:03:44,230
sort of two very different types of

00:03:40,540 --> 00:03:45,700
applications we have applications like

00:03:44,230 --> 00:03:46,260
slack that prioritize something other

00:03:45,700 --> 00:03:48,299
than

00:03:46,260 --> 00:03:50,459
in slacks case they prioritize a

00:03:48,299 --> 00:03:53,250
collaboration of a Content then we have

00:03:50,459 --> 00:03:56,370
more traditional websites like the New

00:03:53,250 --> 00:03:59,640
York Times and they put content front

00:03:56,370 --> 00:04:01,349
center and for the purpose of this talk

00:03:59,640 --> 00:04:03,060
I'd like to stop sort of conflating

00:04:01,349 --> 00:04:05,610
these two very different things they

00:04:03,060 --> 00:04:06,840
both are valid they're both great they

00:04:05,610 --> 00:04:10,500
serve very different purposes and have

00:04:06,840 --> 00:04:12,239
very different goals so the last few

00:04:10,500 --> 00:04:14,040
years of web development specifically

00:04:12,239 --> 00:04:15,689
two or three years have really been

00:04:14,040 --> 00:04:18,810
focused on better ways of bullying

00:04:15,689 --> 00:04:22,320
better slacks right better single page

00:04:18,810 --> 00:04:25,410
applications ember comes to mind as a

00:04:22,320 --> 00:04:28,169
great way of doing that so we've seen a

00:04:25,410 --> 00:04:30,240
lot of good progress but I would argue

00:04:28,169 --> 00:04:31,830
not everything really fits within that

00:04:30,240 --> 00:04:33,750
model not everything should be

00:04:31,830 --> 00:04:35,400
implemented a single page wouldn't make

00:04:33,750 --> 00:04:38,729
sense i don't think to build the new

00:04:35,400 --> 00:04:41,460
york times as a single page web app so

00:04:38,729 --> 00:04:44,220
what is someone like the new york times

00:04:41,460 --> 00:04:47,340
to do if they want to add some more

00:04:44,220 --> 00:04:49,919
modern real-time features into their

00:04:47,340 --> 00:04:53,460
website without going completely single

00:04:49,919 --> 00:04:56,910
page so in exploring this question i

00:04:53,460 --> 00:04:58,080
built a little demo it'll start running

00:04:56,910 --> 00:05:01,919
behind you so you'll see these two

00:04:58,080 --> 00:05:04,260
counters one blue one gray they'll start

00:05:01,919 --> 00:05:07,410
incrementing and the blue counter

00:05:04,260 --> 00:05:09,720
represents the number of current users

00:05:07,410 --> 00:05:12,870
on this website the gray one indicates

00:05:09,720 --> 00:05:19,380
the number of total views then we have a

00:05:12,870 --> 00:05:26,160
comment system as well so I'm sorry no I

00:05:19,380 --> 00:05:28,320
can't really apologize so as you can

00:05:26,160 --> 00:05:29,880
kind of see we've got a lot of users

00:05:28,320 --> 00:05:32,580
that are starting to enter this bit of

00:05:29,880 --> 00:05:35,460
content we'll start seeing the counter

00:05:32,580 --> 00:05:39,000
go back down and this is you know it's a

00:05:35,460 --> 00:05:41,330
pretty real-time fueling application as

00:05:39,000 --> 00:05:44,729
a user I don't have to reload the page

00:05:41,330 --> 00:05:47,490
to get new state it all sort of appears

00:05:44,729 --> 00:05:51,129
right in front of me and you notice as

00:05:47,490 --> 00:05:52,899
comets ratted the counters kept counting

00:05:51,129 --> 00:05:56,529
so there's no page refresh going on for

00:05:52,899 --> 00:05:58,539
any aspect of this so let's just say

00:05:56,529 --> 00:05:59,709
hypothetically the New York Times wanted

00:05:58,539 --> 00:06:02,979
to build something like this into their

00:05:59,709 --> 00:06:07,449
articles they had some internal argument

00:06:02,979 --> 00:06:09,669
that adding real-time counters and

00:06:07,449 --> 00:06:11,800
comments that felt more like a chat

00:06:09,669 --> 00:06:15,149
would increase your engagement or

00:06:11,800 --> 00:06:21,569
something like that what would they do

00:06:15,149 --> 00:06:21,569
now without going single page so

00:06:22,619 --> 00:06:28,929
predictably they could do this sort of

00:06:26,069 --> 00:06:31,240
hybridized client-server approach right

00:06:28,929 --> 00:06:32,619
so they want to make sure that the users

00:06:31,240 --> 00:06:35,919
have access to the content no matter

00:06:32,619 --> 00:06:38,619
what so they might render the article on

00:06:35,919 --> 00:06:41,110
the server side so as a user I make a

00:06:38,619 --> 00:06:43,209
request the article server renders the

00:06:41,110 --> 00:06:47,259
the content for the article pushes the

00:06:43,209 --> 00:06:50,559
back down to the browser and the counter

00:06:47,259 --> 00:06:52,989
and the comments might be implemented as

00:06:50,559 --> 00:06:54,969
client-side components so when the page

00:06:52,989 --> 00:06:58,439
is rendered in my browser those two

00:06:54,969 --> 00:07:00,759
components could boot up they could

00:06:58,439 --> 00:07:02,889
request the state from the back end

00:07:00,759 --> 00:07:05,319
application and then perform rendering

00:07:02,889 --> 00:07:08,439
locally and then perhaps they even open

00:07:05,319 --> 00:07:09,429
up a socket to the backend and state

00:07:08,439 --> 00:07:13,089
change would be streamed out of the

00:07:09,429 --> 00:07:15,099
client and presented at real time and so

00:07:13,089 --> 00:07:17,529
this is completely valid now I want to

00:07:15,099 --> 00:07:20,729
point out though that introduces some

00:07:17,529 --> 00:07:22,839
complexity within our program so we have

00:07:20,729 --> 00:07:24,459
rendering logic not only on the server

00:07:22,839 --> 00:07:26,019
we've moved part of it down to the

00:07:24,459 --> 00:07:28,959
client for these two real timing

00:07:26,019 --> 00:07:30,550
components and because we have rendering

00:07:28,959 --> 00:07:32,110
logic on both the server side and the

00:07:30,550 --> 00:07:37,179
client side we also have to deal with

00:07:32,110 --> 00:07:38,829
state in two places so we have stayed on

00:07:37,179 --> 00:07:40,569
our server we have stayed on our on our

00:07:38,829 --> 00:07:42,459
client we actually have three problems

00:07:40,569 --> 00:07:47,079
now because sometimes the state doesn't

00:07:42,459 --> 00:07:48,909
match up and no one no one here likes

00:07:47,079 --> 00:07:52,360
dealing with state it's one of the

00:07:48,909 --> 00:07:54,699
hardest things to deal with so this sort

00:07:52,360 --> 00:07:57,789
of hybrid approach it works I wouldn't

00:07:54,699 --> 00:07:58,880
call it elegant I believe it adds a lot

00:07:57,789 --> 00:08:01,430
of complexity turn out

00:07:58,880 --> 00:08:03,200
Asians and I think that really this is

00:08:01,430 --> 00:08:05,630
what drove the introduction of single

00:08:03,200 --> 00:08:08,330
page apps to begin with right it's

00:08:05,630 --> 00:08:11,750
difficult dealing with two sets of code

00:08:08,330 --> 00:08:13,490
to code bases two sets of business logic

00:08:11,750 --> 00:08:15,950
two sets of state so let's just move

00:08:13,490 --> 00:08:17,750
everything of client great solves a lot

00:08:15,950 --> 00:08:22,850
of problems for the kinds of apps that

00:08:17,750 --> 00:08:24,890
fit within that that scheme the second

00:08:22,850 --> 00:08:27,800
problem I like to describe as the

00:08:24,890 --> 00:08:29,030
spinning wheel problem so because we're

00:08:27,800 --> 00:08:31,760
not doing a full render on the server

00:08:29,030 --> 00:08:34,729
when the page is loaded in the browser

00:08:31,760 --> 00:08:37,190
we're waiting on as a user I'm waiting

00:08:34,729 --> 00:08:39,440
on the two client-side components to

00:08:37,190 --> 00:08:41,030
boot up right they don't have everything

00:08:39,440 --> 00:08:43,039
they need they weren't rendered on the

00:08:41,030 --> 00:08:45,170
server so they've got to request the

00:08:43,039 --> 00:08:46,670
JavaScript once they get the JavaScript

00:08:45,170 --> 00:08:49,220
they boot up they request the state from

00:08:46,670 --> 00:08:50,390
the server they establish a socket when

00:08:49,220 --> 00:08:53,150
it's certainly have to wait on all of

00:08:50,390 --> 00:08:56,920
these things if any of those things goes

00:08:53,150 --> 00:08:59,420
wrong as a user I see a spinning wheel

00:08:56,920 --> 00:09:01,460
and this happens all too often

00:08:59,420 --> 00:09:04,670
especially in circumstances of flaky

00:09:01,460 --> 00:09:06,170
connections things like that so this

00:09:04,670 --> 00:09:08,120
really kind of gets into the argument of

00:09:06,170 --> 00:09:09,800
progressive enhancement right and I'm

00:09:08,120 --> 00:09:11,210
not going to talk a lot about

00:09:09,800 --> 00:09:12,350
progressive enhancement I don't want to

00:09:11,210 --> 00:09:14,690
start an argument about progressive

00:09:12,350 --> 00:09:18,260
enhancement I really want to make I only

00:09:14,690 --> 00:09:20,530
want to make one point and that is it's

00:09:18,260 --> 00:09:23,380
still necessary when content is

00:09:20,530 --> 00:09:25,400
prioritised above anything else slack

00:09:23,380 --> 00:09:27,710
should not care about progressive

00:09:25,400 --> 00:09:30,140
enhancement it should not work without

00:09:27,710 --> 00:09:32,210
JavaScript whatsoever New York Times

00:09:30,140 --> 00:09:35,510
needs to continue because they really

00:09:32,210 --> 00:09:39,650
put the content first there's a lot of

00:09:35,510 --> 00:09:41,150
sort of debate an argument about this

00:09:39,650 --> 00:09:43,280
and I think that a lot of it stems from

00:09:41,150 --> 00:09:47,410
sort of the old school web standards

00:09:43,280 --> 00:09:49,640
guys that's more of my background

00:09:47,410 --> 00:09:51,900
building these content driven

00:09:49,640 --> 00:09:53,430
applications and then

00:09:51,900 --> 00:09:56,160
we're building all kinds of new things

00:09:53,430 --> 00:09:58,290
on the web that don't prioritize content

00:09:56,160 --> 00:10:00,240
shouldn't prioritize content and so

00:09:58,290 --> 00:10:02,100
they're building these applications with

00:10:00,240 --> 00:10:04,680
totally different goals and totally

00:10:02,100 --> 00:10:06,180
different focuses one side says we need

00:10:04,680 --> 00:10:07,920
progressive enhancement across all of

00:10:06,180 --> 00:10:10,290
these the other one says no we don't and

00:10:07,920 --> 00:10:13,650
they're both right for their specific

00:10:10,290 --> 00:10:17,790
use case so I think web standards will

00:10:13,650 --> 00:10:23,760
win on this for applications websites

00:10:17,790 --> 00:10:25,800
that prioritize content first so sort of

00:10:23,760 --> 00:10:30,000
to combatant this both the first low

00:10:25,800 --> 00:10:31,860
problem to help well some of the fears

00:10:30,000 --> 00:10:33,600
about progressive enhancement there's

00:10:31,860 --> 00:10:36,690
this new thing that we started doing

00:10:33,600 --> 00:10:40,160
cold isomorphic JavaScript and basically

00:10:36,690 --> 00:10:42,450
for those who don't wear sure most are

00:10:40,160 --> 00:10:43,560
evaluate all of your code do all the

00:10:42,450 --> 00:10:45,330
rendering on the back end for the

00:10:43,560 --> 00:10:47,700
initial request push it down to the

00:10:45,330 --> 00:10:49,500
server to the client rather where it's

00:10:47,700 --> 00:10:50,850
all rendered at once and then your

00:10:49,500 --> 00:10:54,180
client side components would take over

00:10:50,850 --> 00:10:57,240
an update the new state I tweeted this

00:10:54,180 --> 00:11:00,300
out a few weeks ago about isomorphic a

00:10:57,240 --> 00:11:03,720
script in my life this is sort of what

00:11:00,300 --> 00:11:06,750
it feels like to me and at least 51

00:11:03,720 --> 00:11:08,730
people agree so I would sort of

00:11:06,750 --> 00:11:10,740
summarize my feelings on ice and repeat

00:11:08,730 --> 00:11:12,780
JavaScript as it's not elegant

00:11:10,740 --> 00:11:14,100
potentially dangerous and it's the

00:11:12,780 --> 00:11:17,760
really kind of the wrong tool for the

00:11:14,100 --> 00:11:22,020
job so please don't please don't hurt

00:11:17,760 --> 00:11:25,830
yourself so what are we really left with

00:11:22,020 --> 00:11:28,170
here so I would say this there's two

00:11:25,830 --> 00:11:29,640
goals and what we want to build one of

00:11:28,170 --> 00:11:31,830
whether it follows a single page apps

00:11:29,640 --> 00:11:34,320
for our use case and we want to avoid

00:11:31,830 --> 00:11:35,940
the pitfalls of client-side components

00:11:34,320 --> 00:11:38,640
this sort of hybrid client-server bridge

00:11:35,940 --> 00:11:40,620
where we have our state in multiple

00:11:38,640 --> 00:11:42,570
places and our rendering logic that

00:11:40,620 --> 00:11:46,300
yield of that state of multiple place

00:11:42,570 --> 00:11:47,590
so sort of what we're left with is the

00:11:46,300 --> 00:11:49,630
only option as we're going to do a full

00:11:47,590 --> 00:11:52,780
server memory and then we're going to

00:11:49,630 --> 00:11:54,070
add real time as a layer so every aspect

00:11:52,780 --> 00:11:56,050
of the page including the dynamic

00:11:54,070 --> 00:11:59,290
aspects would be rendered on the initial

00:11:56,050 --> 00:12:01,660
request pushed back in the response to

00:11:59,290 --> 00:12:03,610
the browser where it's rendered and then

00:12:01,660 --> 00:12:06,760
the whole page boots up and establishes

00:12:03,610 --> 00:12:07,750
sort of this real-time layer I would say

00:12:06,760 --> 00:12:11,250
it's real time as progressive

00:12:07,750 --> 00:12:15,700
enhancement because if anything fails

00:12:11,250 --> 00:12:17,050
fails to work such as a WebSocket

00:12:15,700 --> 00:12:19,660
connection can't be established or

00:12:17,050 --> 00:12:22,390
something of that nature as a user I

00:12:19,660 --> 00:12:24,910
still have access to my content it's

00:12:22,390 --> 00:12:26,770
just in our case I don't see these

00:12:24,910 --> 00:12:28,270
autumn of the encounters or maybe my

00:12:26,770 --> 00:12:30,160
comments don't show up immediately

00:12:28,270 --> 00:12:32,230
without a page refresh and those sorts

00:12:30,160 --> 00:12:34,240
of things but I can still access the

00:12:32,230 --> 00:12:38,620
content which is the thing that I'm

00:12:34,240 --> 00:12:42,910
concerned about is a user the second

00:12:38,620 --> 00:12:44,940
thing here is that it allows us to keep

00:12:42,910 --> 00:12:47,950
the business logic on the server side

00:12:44,940 --> 00:12:50,830
right now javaScript and it was much

00:12:47,950 --> 00:12:53,110
rejoicing I love JavaScript was one of

00:12:50,830 --> 00:12:55,000
the first languages I learned but I

00:12:53,110 --> 00:12:56,770
don't like having to write it for my

00:12:55,000 --> 00:13:01,480
applications the less code that I have

00:12:56,770 --> 00:13:06,010
to write the better in my opinion okay

00:13:01,480 --> 00:13:09,160
so how are we going to do this so i want

00:13:06,010 --> 00:13:10,720
to show an example now and i don't want

00:13:09,160 --> 00:13:13,390
anyone here to think i'm completely

00:13:10,720 --> 00:13:16,360
trolling you this isn't all high-level

00:13:13,390 --> 00:13:17,320
conceptual things the video you saw

00:13:16,360 --> 00:13:18,190
earlier will have a real application

00:13:17,320 --> 00:13:20,790
running

00:13:18,190 --> 00:13:24,070
production server it actually works

00:13:20,790 --> 00:13:26,170
everything that powers this sort of a

00:13:24,070 --> 00:13:29,200
new approach is open source it's MIT

00:13:26,170 --> 00:13:31,570
license it's on github today there's a

00:13:29,200 --> 00:13:33,880
link to the example talk at the end of

00:13:31,570 --> 00:13:36,220
the talk or the example app at the end

00:13:33,880 --> 00:13:42,700
of the talk you can pull it down you can

00:13:36,220 --> 00:13:46,720
use it you can sell it you want it to so

00:13:42,700 --> 00:13:48,160
nothing hypothetical so we're going to

00:13:46,720 --> 00:13:51,670
start kind of in a weird place with this

00:13:48,160 --> 00:13:54,370
this example at least it might feel a

00:13:51,670 --> 00:13:56,590
little weird so we're going to start on

00:13:54,370 --> 00:13:57,610
the view template side which isn't

00:13:56,590 --> 00:14:00,760
really the first thing we start thinking

00:13:57,610 --> 00:14:03,210
about its app developers necessarily but

00:14:00,760 --> 00:14:06,100
really this is where it all starts so

00:14:03,210 --> 00:14:08,980
here's the source code for the content

00:14:06,100 --> 00:14:10,840
statistics part of our example I want to

00:14:08,980 --> 00:14:11,860
kind of isolate this by itself and we'll

00:14:10,840 --> 00:14:14,050
talk about this we will talk about

00:14:11,860 --> 00:14:16,330
comments later so you'll notice these

00:14:14,050 --> 00:14:20,500
three weird data dash star attributes

00:14:16,330 --> 00:14:21,940
and what these do is they they note 8 or

00:14:20,500 --> 00:14:24,490
mark the nodes that represent the

00:14:21,940 --> 00:14:25,600
underlying state of our program sort of

00:14:24,490 --> 00:14:31,470
kind of think of it like a state

00:14:25,600 --> 00:14:31,470
notation so this first one datascope

00:14:32,040 --> 00:14:39,640
describes this node as representing an

00:14:36,250 --> 00:14:41,410
object of our program here represents

00:14:39,640 --> 00:14:44,800
the just the content statistics in our

00:14:41,410 --> 00:14:47,350
program the next node nested under the

00:14:44,800 --> 00:14:51,400
scope is a prop which represent the type

00:14:47,350 --> 00:14:54,880
of our statistics here the snow

00:14:51,400 --> 00:14:56,450
represents active and then of course the

00:14:54,880 --> 00:15:00,200
same thing for total

00:14:56,450 --> 00:15:02,320
so in this system this is all the view

00:15:00,200 --> 00:15:04,580
template is there's nothing more to it

00:15:02,320 --> 00:15:06,560
notice there's complete absence of you

00:15:04,580 --> 00:15:09,020
logic which begs the question how in the

00:15:06,560 --> 00:15:10,940
world do you render this thing and it's

00:15:09,020 --> 00:15:13,340
a good question I hope hope hopefully

00:15:10,940 --> 00:15:14,780
have a good answer rendering is a

00:15:13,340 --> 00:15:16,700
completely external action that's

00:15:14,780 --> 00:15:19,670
performed on top of this view rather

00:15:16,700 --> 00:15:22,310
than the logic being mixed in and sort

00:15:19,670 --> 00:15:24,080
of compiled so for example stay we

00:15:22,310 --> 00:15:26,390
wanted to render this data so this is

00:15:24,080 --> 00:15:30,200
the hash as to he's active in total and

00:15:26,390 --> 00:15:33,890
two values three and 42 and we want to

00:15:30,200 --> 00:15:35,830
kind of map these in so I kind of broke

00:15:33,890 --> 00:15:38,090
the data out so that it would it would

00:15:35,830 --> 00:15:41,120
match with a structure that you a good

00:15:38,090 --> 00:15:43,190
one and you can kind of see reason about

00:15:41,120 --> 00:15:45,590
how we might do this we could match the

00:15:43,190 --> 00:15:46,970
active key to the active prop and the

00:15:45,590 --> 00:15:49,970
total key to the total crop and just

00:15:46,970 --> 00:15:52,480
insert the values and you'd be correct

00:15:49,970 --> 00:15:55,280
there's some logic this is written Ruby

00:15:52,480 --> 00:15:59,390
that does just that so let's step

00:15:55,280 --> 00:16:02,000
through it the first bit of our logic is

00:15:59,390 --> 00:16:04,150
view which is obvious right we want to

00:16:02,000 --> 00:16:08,600
address our view which in this case is

00:16:04,150 --> 00:16:10,250
our content statistics the second bit of

00:16:08,600 --> 00:16:12,530
our logic we're sort of reducing our

00:16:10,250 --> 00:16:14,060
scope we say this is the scope that

00:16:12,530 --> 00:16:15,920
we're concerned about in our template

00:16:14,060 --> 00:16:18,050
for our statistics because that's the

00:16:15,920 --> 00:16:22,010
data that we're wondering and then

00:16:18,050 --> 00:16:24,350
finally we call apply with our data so

00:16:22,010 --> 00:16:26,470
apply I won't go into all the specifics

00:16:24,350 --> 00:16:29,660
by hog words that you can think of it as

00:16:26,470 --> 00:16:31,280
it mate it makes your view template

00:16:29,660 --> 00:16:34,160
match your data structure and then it

00:16:31,280 --> 00:16:36,290
maps the values on so here there you

00:16:34,160 --> 00:16:38,050
know the data already matches our view

00:16:36,290 --> 00:16:41,090
structure so it's simply a matter of

00:16:38,050 --> 00:16:43,970
mapping the values so we can see after

00:16:41,090 --> 00:16:45,650
apply is called the active and total

00:16:43,970 --> 00:16:48,470
values from our data are represented

00:16:45,650 --> 00:16:51,500
accurately interview so this is called

00:16:48,470 --> 00:16:53,900
non-destructive rendering its

00:16:51,500 --> 00:16:56,930
non-destructive because after rendering

00:16:53,900 --> 00:17:00,290
we still know what the underlying intent

00:16:56,930 --> 00:17:01,920
of our view is of our interview after

00:17:00,290 --> 00:17:03,750
rendering we still know which node

00:17:01,920 --> 00:17:06,449
represents the statistics we know which

00:17:03,750 --> 00:17:09,990
node represents the property of our

00:17:06,449 --> 00:17:12,839
statistics the active in total and this

00:17:09,990 --> 00:17:14,850
separation between the structure of our

00:17:12,839 --> 00:17:16,439
template and the logic of rendering is

00:17:14,850 --> 00:17:18,510
extremely important we need to preserve

00:17:16,439 --> 00:17:19,679
this so we'll see why that's so

00:17:18,510 --> 00:17:23,150
important here in just a few minutes

00:17:19,679 --> 00:17:23,150
when we get into the real time aspect

00:17:26,020 --> 00:17:33,130
before we talk about real time though I

00:17:28,960 --> 00:17:34,720
want to show this in context so in this

00:17:33,130 --> 00:17:36,400
bit of code there's three concepts

00:17:34,720 --> 00:17:39,550
represented there is routing rendering

00:17:36,400 --> 00:17:42,280
and data access so routing is sort of

00:17:39,550 --> 00:17:43,690
the first high-level thing so what this

00:17:42,280 --> 00:17:47,590
bit of code again this is all written

00:17:43,690 --> 00:17:51,760
roomie what this code is saying is for

00:17:47,590 --> 00:17:53,410
get requests to the URL we want to

00:17:51,760 --> 00:17:57,970
execute everything between the jewel in

00:17:53,410 --> 00:17:59,800
the end so when a request comes then a

00:17:57,970 --> 00:18:01,420
get request to the riu RL the first bit

00:17:59,800 --> 00:18:03,970
of code different execute source

00:18:01,420 --> 00:18:06,490
familiar to us right we're saying with

00:18:03,970 --> 00:18:09,310
us cope stats so we're dressing our

00:18:06,490 --> 00:18:12,610
viewer reducing scope to stats we call a

00:18:09,310 --> 00:18:14,920
render so when we call our display

00:18:12,610 --> 00:18:16,990
brender or the render display it's

00:18:14,920 --> 00:18:19,150
actually invoking something called it a

00:18:16,990 --> 00:18:21,700
ringer right so you can think of a

00:18:19,150 --> 00:18:24,640
renderer as an abstraction of our view

00:18:21,700 --> 00:18:27,280
logic so what we had before you don't

00:18:24,640 --> 00:18:28,780
apply with our data set that's

00:18:27,280 --> 00:18:30,580
abstracted away and if this thing hold

00:18:28,780 --> 00:18:33,130
at this flavor in room so when our route

00:18:30,580 --> 00:18:34,690
we simply say what should happen we

00:18:33,130 --> 00:18:38,500
don't describe anything about how it

00:18:34,690 --> 00:18:40,900
happens that's abstract of the way so we

00:18:38,500 --> 00:18:44,530
invoke our display renderer with a data

00:18:40,900 --> 00:18:49,360
set we want our statistic data and we

00:18:44,530 --> 00:18:50,560
want all of it so again this this is

00:18:49,360 --> 00:18:52,890
something abstraction so we've

00:18:50,560 --> 00:18:55,810
abstracted away all of the data access

00:18:52,890 --> 00:18:59,200
into this data access layer that we can

00:18:55,810 --> 00:19:01,780
simply say what data set that we want to

00:18:59,200 --> 00:19:03,550
render instead of describing how we go

00:19:01,780 --> 00:19:04,960
about getting it behind the scenes in

00:19:03,550 --> 00:19:06,750
this example is actually using Redis at

00:19:04,960 --> 00:19:10,140
the data store it doesn't matter

00:19:06,750 --> 00:19:16,260
and then finally we call subscribe what

00:19:10,140 --> 00:19:18,600
subscribe does is it says I as the

00:19:16,260 --> 00:19:21,600
developer I'm interested in this

00:19:18,600 --> 00:19:24,000
rendered view staying up to date with

00:19:21,600 --> 00:19:26,090
any changes in state that occur on the

00:19:24,000 --> 00:19:30,210
backend that would affect its rendering

00:19:26,090 --> 00:19:32,040
okay so this basically is saying

00:19:30,210 --> 00:19:37,710
subscribe to view to any changes that

00:19:32,040 --> 00:19:41,010
occur so that it stays ins so what this

00:19:37,710 --> 00:19:44,070
looks like now once our statistics are

00:19:41,010 --> 00:19:45,750
rendered a generic JavaScript library

00:19:44,070 --> 00:19:47,670
takes over establishes a WebSocket

00:19:45,750 --> 00:19:49,800
connection with the server and so now

00:19:47,670 --> 00:19:52,680
both of both our server and recliner

00:19:49,800 --> 00:19:54,150
sort of in a waiting state so our

00:19:52,680 --> 00:19:56,520
clients waiting on instructions from the

00:19:54,150 --> 00:19:57,840
server new state our service waiting on

00:19:56,520 --> 00:19:59,640
the stake to change so that it can tell

00:19:57,840 --> 00:20:02,670
the client hey you need to update

00:19:59,640 --> 00:20:07,050
yourself so eventually a state change

00:20:02,670 --> 00:20:09,000
comes in say somebody joins the server

00:20:07,050 --> 00:20:12,750
is made aware of it and the server goes

00:20:09,000 --> 00:20:14,040
through a rear ndering stuff so what

00:20:12,750 --> 00:20:16,080
this rerender looks like it's not

00:20:14,040 --> 00:20:18,480
actually rendering the HTML again so

00:20:16,080 --> 00:20:20,430
what it's actually doing is building up

00:20:18,480 --> 00:20:23,540
a set of transformation instructions

00:20:20,430 --> 00:20:26,850
these are generic instructions for how

00:20:23,540 --> 00:20:28,800
to update a rendered view to match the

00:20:26,850 --> 00:20:30,420
new state so those transformations are

00:20:28,800 --> 00:20:32,730
built up push back down website to the

00:20:30,420 --> 00:20:34,410
JavaScript library which applies those

00:20:32,730 --> 00:20:37,050
transformations to the view so that the

00:20:34,410 --> 00:20:39,840
view represent represents accurately the

00:20:37,050 --> 00:20:41,070
new state of the application that's an

00:20:39,840 --> 00:20:43,500
example of what an instruction would

00:20:41,070 --> 00:20:47,990
look like in our case see realized as

00:20:43,500 --> 00:20:47,990
JSON simply saying apply this data

00:20:49,140 --> 00:20:55,230
which the JavaScript library would would

00:20:51,360 --> 00:20:56,520
perform this instructions on the team so

00:20:55,230 --> 00:20:59,070
this is called the view transformation

00:20:56,520 --> 00:21:00,390
protocol the view transformation

00:20:59,070 --> 00:21:04,640
protocols a way of representing view

00:21:00,390 --> 00:21:04,640
rendering is set of data transformations

00:21:04,790 --> 00:21:09,390
what this allows us to do is to write

00:21:07,110 --> 00:21:12,060
our business logic once and evaluated

00:21:09,390 --> 00:21:14,190
only on the server side so our

00:21:12,060 --> 00:21:16,440
JavaScript library in this case sort of

00:21:14,190 --> 00:21:18,360
understands generally speaks the same

00:21:16,440 --> 00:21:20,310
language as the server right it

00:21:18,360 --> 00:21:23,070
understands how these are rendered and

00:21:20,310 --> 00:21:25,110
how to update them but it knows nothing

00:21:23,070 --> 00:21:26,670
specific about the business logic of our

00:21:25,110 --> 00:21:28,890
application about how these views are

00:21:26,670 --> 00:21:30,810
rendered that's always evaluate on the

00:21:28,890 --> 00:21:32,370
server side and which builds up these

00:21:30,810 --> 00:21:37,770
transformations when it can be applied

00:21:32,370 --> 00:21:39,210
generically by our client library the

00:21:37,770 --> 00:21:40,200
view transformation protocol is faster

00:21:39,210 --> 00:21:42,060
because we only have to render the

00:21:40,200 --> 00:21:44,910
changes so when this transformations

00:21:42,060 --> 00:21:47,100
receive we can do it dip and we can say

00:21:44,910 --> 00:21:48,210
these are the nodes that have changed so

00:21:47,100 --> 00:21:50,940
we don't have to rip everything out and

00:21:48,210 --> 00:21:53,400
rebuild it from scratch the only time

00:21:50,940 --> 00:21:54,720
nodes are added it's when new data is

00:21:53,400 --> 00:21:57,600
added that wasn't represented before

00:21:54,720 --> 00:21:59,940
only time they're destroyed is when data

00:21:57,600 --> 00:22:01,620
was rendered and now shouldn't be

00:21:59,940 --> 00:22:04,620
because it was deleted in them in our

00:22:01,620 --> 00:22:07,560
state of our program there's no

00:22:04,620 --> 00:22:08,880
replacement of nodes and you

00:22:07,560 --> 00:22:11,280
transformation protocol is really the

00:22:08,880 --> 00:22:16,080
real time web expressed is progressive

00:22:11,280 --> 00:22:18,000
answer so it allows all of our rendering

00:22:16,080 --> 00:22:19,620
to a chroma server so we don't have the

00:22:18,000 --> 00:22:21,960
first request problem everything's

00:22:19,620 --> 00:22:23,430
rendered upfront and if for some reason

00:22:21,960 --> 00:22:25,130
we can't establish a WebSocket

00:22:23,430 --> 00:22:27,210
connection to the server no big deal I

00:22:25,130 --> 00:22:28,980
as the user still have access to my

00:22:27,210 --> 00:22:32,090
content maybe it's just not as nice but

00:22:28,980 --> 00:22:32,090
nothing really appears broken

00:22:35,830 --> 00:22:42,350
so I want to move on to comments now so

00:22:39,559 --> 00:22:45,499
as you saw before as comments are

00:22:42,350 --> 00:22:48,769
created the counters keep counting so

00:22:45,499 --> 00:22:49,820
there's no pay to refresh going on so

00:22:48,769 --> 00:22:54,440
how do we do this without writing

00:22:49,820 --> 00:22:57,429
JavaScript so this introduces this

00:22:54,440 --> 00:22:59,629
concept called Newell and mutable is

00:22:57,429 --> 00:23:01,909
another aspect of the client library

00:22:59,629 --> 00:23:05,149
what mutable is is a JavaScript

00:23:01,909 --> 00:23:07,759
component that observes a user's

00:23:05,149 --> 00:23:10,429
interaction with a node and understands

00:23:07,759 --> 00:23:12,320
which interactions will cause a change

00:23:10,429 --> 00:23:15,889
in the underlying state of our

00:23:12,320 --> 00:23:18,230
application so in this case we describe

00:23:15,889 --> 00:23:20,359
our form or comment form as being a

00:23:18,230 --> 00:23:22,730
beautiful object and beautiful smart

00:23:20,359 --> 00:23:25,129
enough to know all right when that forms

00:23:22,730 --> 00:23:28,879
submitted that's changing the state of

00:23:25,129 --> 00:23:33,200
our program so as the user I type my

00:23:28,879 --> 00:23:34,850
comment I submit the form and mutable

00:23:33,200 --> 00:23:37,840
takes over hijacks the form submission

00:23:34,850 --> 00:23:40,700
avoiding the full page refresh pushes

00:23:37,840 --> 00:23:43,190
that state transformation up the

00:23:40,700 --> 00:23:45,889
WebSocket to the server triggering the

00:23:43,190 --> 00:23:49,070
rebuild of our transformations which

00:23:45,889 --> 00:23:52,249
pushed back down to the client so that

00:23:49,070 --> 00:23:56,389
the Comets rendered and those it's like

00:23:52,249 --> 00:23:58,059
a nice circular pattern here so this is

00:23:56,389 --> 00:24:00,139
called simple state propagation and

00:23:58,059 --> 00:24:02,690
simple state propagation really is just

00:24:00,139 --> 00:24:04,220
an easier way of dealing with you I

00:24:02,690 --> 00:24:08,570
interactions and state changes that

00:24:04,220 --> 00:24:11,149
originate from a client it's not really

00:24:08,570 --> 00:24:13,190
obvious in that diagram but an important

00:24:11,149 --> 00:24:15,919
aspect of simple state propagation is

00:24:13,190 --> 00:24:17,389
that all changes in the viewstate come

00:24:15,919 --> 00:24:19,999
from the server so there's no local

00:24:17,389 --> 00:24:24,859
render step in the case of creating a

00:24:19,999 --> 00:24:26,869
comment something like emperor say how

00:24:24,859 --> 00:24:28,909
they might approach it as when the forms

00:24:26,869 --> 00:24:30,950
submitted they would change their local

00:24:28,909 --> 00:24:33,619
state do it rear-ender locally so that

00:24:30,950 --> 00:24:35,989
it's represented immediately then tell a

00:24:33,619 --> 00:24:38,389
server about it and then once the server

00:24:35,989 --> 00:24:39,580
accepts that change in state it tells

00:24:38,389 --> 00:24:41,830
all other clients

00:24:39,580 --> 00:24:46,510
this Cullman was created so there's this

00:24:41,830 --> 00:24:48,310
little blip in time where my local state

00:24:46,510 --> 00:24:52,150
doesn't match the true state of the

00:24:48,310 --> 00:24:54,130
server and that can cause problems in

00:24:52,150 --> 00:24:57,330
some situations especially for these

00:24:54,130 --> 00:25:00,910
types of applications how many times

00:24:57,330 --> 00:25:02,680
have you you know done something that

00:25:00,910 --> 00:25:04,840
renders immediately refresh the page and

00:25:02,680 --> 00:25:06,610
it's you know it's not the same thing

00:25:04,840 --> 00:25:08,170
it's not there for some reason the

00:25:06,610 --> 00:25:13,620
server getting created or something

00:25:08,170 --> 00:25:17,110
happened this avoids that completely so

00:25:13,620 --> 00:25:20,560
in simple state propagation is server

00:25:17,110 --> 00:25:21,850
contains ultimate truth always and the

00:25:20,560 --> 00:25:25,300
server is always responsible for

00:25:21,850 --> 00:25:29,620
instructing clients on how to perform

00:25:25,300 --> 00:25:31,750
new renders of new state so that applies

00:25:29,620 --> 00:25:35,680
even to the originator of a state change

00:25:31,750 --> 00:25:37,840
and what this allows us to do is

00:25:35,680 --> 00:25:40,150
prioritize user trust over performance

00:25:37,840 --> 00:25:44,110
so for these types of applications the

00:25:40,150 --> 00:25:46,990
nonce lacks where we really care that

00:25:44,110 --> 00:25:49,810
what the user sees is accurate always so

00:25:46,990 --> 00:25:53,200
there isn't a blip in time where local

00:25:49,810 --> 00:25:55,900
state doesn't match server state this

00:25:53,200 --> 00:25:57,190
this provides for that it's not as

00:25:55,900 --> 00:25:59,290
performant we have to wait on the server

00:25:57,190 --> 00:26:02,290
to accept the state change and tell us

00:25:59,290 --> 00:26:04,930
how to update the view but it guarantees

00:26:02,290 --> 00:26:09,760
that what the user sees is true at any

00:26:04,930 --> 00:26:10,930
given time so I said there was open

00:26:09,760 --> 00:26:13,720
source project behind this on there is

00:26:10,930 --> 00:26:15,220
it's called pacquiao it's been out for a

00:26:13,720 --> 00:26:17,890
couple of years it's a web framework for

00:26:15,220 --> 00:26:19,990
Ruby it does everything that you saw

00:26:17,890 --> 00:26:23,320
today the example that was built on top

00:26:19,990 --> 00:26:26,930
of this framework spent out for a couple

00:26:23,320 --> 00:26:28,970
of years there's few dozen contributors

00:26:26,930 --> 00:26:30,950
and we just recently started making the

00:26:28,970 --> 00:26:32,660
real time aspect of the framework

00:26:30,950 --> 00:26:34,850
available for use which does all they

00:26:32,660 --> 00:26:37,520
have thought of updating views from the

00:26:34,850 --> 00:26:38,780
server side we've been using it

00:26:37,520 --> 00:26:40,850
internally at my company for several

00:26:38,780 --> 00:26:44,810
months we're excited to finally push it

00:26:40,850 --> 00:26:46,640
out there for the world so take a look

00:26:44,810 --> 00:26:49,310
try it out maybe user for your next

00:26:46,640 --> 00:26:50,900
project you can find me on Twitter at

00:26:49,310 --> 00:26:54,080
Brian P again please check out Pacquiao

00:26:50,900 --> 00:26:58,550
love your feedback meta bond is my

00:26:54,080 --> 00:27:01,310
company we build custom apps or lots of

00:26:58,550 --> 00:27:02,630
happy customers and if you're interested

00:27:01,310 --> 00:27:04,760
in seeing the source for this talk it's

00:27:02,630 --> 00:27:06,890
about a hundred lines i didn't i didn't

00:27:04,760 --> 00:27:08,540
do an official help but it's around a

00:27:06,890 --> 00:27:12,170
hundred lines of code you will see no

00:27:08,540 --> 00:27:16,310
JavaScript you can find it again yo calm

00:27:12,170 --> 00:27:21,700
/ brian p / real-time dash talk i'd love

00:27:16,310 --> 00:27:21,700

YouTube URL: https://www.youtube.com/watch?v=GczaIFH0wIY


