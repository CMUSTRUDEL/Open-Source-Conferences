Title: PromCon 2016: Lightning Talks - An Exploration of the Formal Properties of PromQL - Brian Brazil
Publication date: 2016-09-04
Playlist: PromCon 2016
Description: 
	* Abstract:

Brian Brazil from Robust Perception talks about the formal properties of PromQL.

* PromCon website:

https://promcon.io/
Captions: 
	00:00:03,230 --> 00:00:08,149
hello today I would like to present you

00:00:06,020 --> 00:00:11,600
an exploration of the formal properties

00:00:08,149 --> 00:00:13,910
of from ql now you probably don't know

00:00:11,600 --> 00:00:15,980
me I'm actually a computer scientist and

00:00:13,910 --> 00:00:17,360
I work in the field of expanding

00:00:15,980 --> 00:00:19,460
computer science particularly as it

00:00:17,360 --> 00:00:22,279
applies to operational monitoring I'm

00:00:19,460 --> 00:00:24,830
the winner of the victor double grand

00:00:22,279 --> 00:00:26,210
prize for pure mathematics a scholar of

00:00:24,830 --> 00:00:28,429
computer science of Tralee Dublin and

00:00:26,210 --> 00:00:29,660
Google I worked actually primarily on

00:00:28,429 --> 00:00:31,999
expanding the horizons of what was

00:00:29,660 --> 00:00:34,070
possible with monitoring tools there's

00:00:31,999 --> 00:00:35,989
also some monitoring system I work on is

00:00:34,070 --> 00:00:40,760
purely of academic interest because you

00:00:35,989 --> 00:00:44,930
know it uses pull back at scale so from

00:00:40,760 --> 00:00:46,969
ql em has three parts it has a data

00:00:44,930 --> 00:00:49,370
model it has a query language and it has

00:00:46,969 --> 00:00:52,280
an execution environment which is pretty

00:00:49,370 --> 00:00:54,980
common across any language so the data

00:00:52,280 --> 00:00:57,920
model and it is based on this idea of

00:00:54,980 --> 00:01:01,070
labels and samples combining them into

00:00:57,920 --> 00:01:02,989
time series a time series is a new

00:01:01,070 --> 00:01:06,170
technique set of labels and one or more

00:01:02,989 --> 00:01:08,090
samples labels are a set of pairs of

00:01:06,170 --> 00:01:11,270
strings and the first of each pair has

00:01:08,090 --> 00:01:14,000
to be unique within a label one time

00:01:11,270 --> 00:01:17,330
series and a sample then is a pair of a

00:01:14,000 --> 00:01:18,800
name 64 and a float64 and within a time

00:01:17,330 --> 00:01:22,100
series the first set of hair is again

00:01:18,800 --> 00:01:23,930
unique so what can we describe with this

00:01:22,100 --> 00:01:27,080
model well computer science standpoint

00:01:23,930 --> 00:01:29,570
we can get to a list by using these

00:01:27,080 --> 00:01:31,250
labels to number Tings and then we've

00:01:29,570 --> 00:01:33,500
got your not using n64 is using the

00:01:31,250 --> 00:01:36,110
float will note it supports full float64

00:01:33,500 --> 00:01:37,580
and so you can have man you can have in

00:01:36,110 --> 00:01:39,440
you let's do a grid by going two

00:01:37,580 --> 00:01:42,500
dimensional now you can do like all your

00:01:39,440 --> 00:01:46,100
other structures like this query

00:01:42,500 --> 00:01:47,240
language 10 and it selects time series

00:01:46,100 --> 00:01:50,270
based on the existence and non-existence

00:01:47,240 --> 00:01:52,220
of these labels and and from there

00:01:50,270 --> 00:01:54,320
there's a whole pile of operators and

00:01:52,220 --> 00:01:56,240
functions so there is relational algebra

00:01:54,320 --> 00:01:58,100
based on the labels across multiple time

00:01:56,240 --> 00:01:59,900
series you can do what in one time

00:01:58,100 --> 00:02:02,060
series you can slice the other way and

00:01:59,900 --> 00:02:04,070
do fact samples functions of service

00:02:02,060 --> 00:02:05,960
within them and our operations of

00:02:04,070 --> 00:02:08,539
functions on single samples across time

00:02:05,960 --> 00:02:10,819
series such as aggregation there are

00:02:08,539 --> 00:02:13,280
type conversion functions as we know the

00:02:10,819 --> 00:02:16,219
prom qo is both strongly and sat be

00:02:13,280 --> 00:02:16,819
typed and there are some display related

00:02:16,219 --> 00:02:18,230
functions which

00:02:16,819 --> 00:02:20,560
particularly interesting there's also

00:02:18,230 --> 00:02:22,459
one function to manipulate labels and

00:02:20,560 --> 00:02:24,650
because this turns out to be kind of

00:02:22,459 --> 00:02:26,299
important normally you can only work

00:02:24,650 --> 00:02:28,480
with labels that are the same I do

00:02:26,299 --> 00:02:30,650
relational algebra based on them and

00:02:28,480 --> 00:02:32,959
because you can work for example these

00:02:30,650 --> 00:02:34,489
ones x equals 1 y cuz one next equals 2y

00:02:32,959 --> 00:02:37,189
equals 2 because both of y equals one

00:02:34,489 --> 00:02:39,620
the label replace function allows us to

00:02:37,189 --> 00:02:41,599
change the 1 into a 2 via regular

00:02:39,620 --> 00:02:43,129
expressions now obviously regular

00:02:41,599 --> 00:02:44,540
expressions are a dirty word inform

00:02:43,129 --> 00:02:47,299
computer science but you know you do

00:02:44,540 --> 00:02:49,819
what you must now the execution

00:02:47,299 --> 00:02:52,129
environment is a little bit weird I'm

00:02:49,819 --> 00:02:53,689
not sure where it came from so the

00:02:52,129 --> 00:02:56,419
execution environment there is a counter

00:02:53,689 --> 00:02:58,370
a single counter and when you're looking

00:02:56,419 --> 00:03:01,370
up time series what it does is it looks

00:02:58,370 --> 00:03:03,409
at all the time series and it looks for

00:03:01,370 --> 00:03:05,359
sample values that are between the value

00:03:03,409 --> 00:03:08,569
of the counter and the counter minus

00:03:05,359 --> 00:03:11,150
minus three hundred thousand yeah it's

00:03:08,569 --> 00:03:13,189
weird and out of those assignment will

00:03:11,150 --> 00:03:14,449
the highest first value highest in 64

00:03:13,189 --> 00:03:17,000
will be the one that's presented to you

00:03:14,449 --> 00:03:18,919
and in each execution cycle because it

00:03:17,000 --> 00:03:20,239
runs in cycle this counter increases by

00:03:18,919 --> 00:03:26,120
a number that's usually between a

00:03:20,239 --> 00:03:28,159
t'ousand and 60,000 odd system and you

00:03:26,120 --> 00:03:30,379
can execute expression stateless lee and

00:03:28,159 --> 00:03:33,680
also stateful e and put the answers back

00:03:30,379 --> 00:03:35,720
in note however that there is no

00:03:33,680 --> 00:03:37,009
ordering on those expressions and and

00:03:35,720 --> 00:03:39,530
they may refer to one's in the current

00:03:37,009 --> 00:03:43,549
cycle or the previous one as so there's

00:03:39,530 --> 00:03:45,349
no atomicity here at all so the big

00:03:43,549 --> 00:03:47,720
question you always have to ask as a

00:03:45,349 --> 00:03:50,540
computer scientist is how powerful is

00:03:47,720 --> 00:03:51,949
this language now we can model a list we

00:03:50,540 --> 00:03:53,509
can do relational algebra we can record

00:03:51,949 --> 00:03:55,069
any results then you know we could

00:03:53,509 --> 00:03:56,599
create some form of take for the list

00:03:55,069 --> 00:03:58,699
entitled finite state machine on top of

00:03:56,599 --> 00:04:02,900
that but to be honest being there don't

00:03:58,699 --> 00:04:04,250
dash that's so 2007 so what else we do

00:04:02,900 --> 00:04:06,169
is powerful but a little more

00:04:04,250 --> 00:04:07,849
aesthetically pleasing well we could

00:04:06,169 --> 00:04:09,739
build the grid and do some form of

00:04:07,849 --> 00:04:11,780
simple two-dimensional senators Holland

00:04:09,739 --> 00:04:14,689
on top of it you know simple grad

00:04:11,780 --> 00:04:16,280
student project so let's go for

00:04:14,689 --> 00:04:19,849
something very simple and keep it basic

00:04:16,280 --> 00:04:21,349
nice and binary states 0 and 1 using

00:04:19,849 --> 00:04:23,030
regular expressions to manipulate

00:04:21,349 --> 00:04:24,650
decimals is not going to be easy

00:04:23,030 --> 00:04:26,510
particularly as the decimals could be of

00:04:24,650 --> 00:04:29,090
arbitrary linked so we're going to use

00:04:26,510 --> 00:04:30,169
an unary numbering system so binary has

00:04:29,090 --> 00:04:33,319
two digits

00:04:30,169 --> 00:04:37,430
has three decimal has ten unary has one

00:04:33,319 --> 00:04:41,449
so one is a one two is one one tree is

00:04:37,430 --> 00:04:44,270
111 and so on and so forth yeah this is

00:04:41,449 --> 00:04:46,400
an actual thing to be clear and then we

00:04:44,270 --> 00:04:47,710
can have a time series and we're just

00:04:46,400 --> 00:04:49,999
going to have a convention of using

00:04:47,710 --> 00:04:51,909
underscore underscore name underscore

00:04:49,999 --> 00:04:54,499
underscore to be the name of things and

00:04:51,909 --> 00:04:56,840
call it in ish and that's the size of

00:04:54,499 --> 00:04:59,090
the grid we want and all value 1 and the

00:04:56,840 --> 00:05:01,699
grid itself will store it in grid now

00:04:59,090 --> 00:05:03,710
for the edges of the grade and we can do

00:05:01,699 --> 00:05:06,110
some manipulation of the counter to do

00:05:03,710 --> 00:05:07,550
random ish values as there's no real

00:05:06,110 --> 00:05:09,680
random number generator and bit with a

00:05:07,550 --> 00:05:11,270
little prompt UL apparently people want

00:05:09,680 --> 00:05:12,439
the things the deterministic doesn't

00:05:11,270 --> 00:05:15,740
help at all with de Monte Carlo

00:05:12,439 --> 00:05:17,029
simulations I'm so here are the rules so

00:05:15,740 --> 00:05:19,370
the first rule we're going to have is

00:05:17,029 --> 00:05:21,349
that if you have exactly three neighbors

00:05:19,370 --> 00:05:23,779
or one become one and I think it's

00:05:21,349 --> 00:05:25,039
fairly obvious what this does so it just

00:05:23,779 --> 00:05:27,770
basically goes through each of the cells

00:05:25,039 --> 00:05:30,050
around it and if it's not present it

00:05:27,770 --> 00:05:33,650
pulls in around the number based on the

00:05:30,050 --> 00:05:37,610
counter and yeah if that's equal to

00:05:33,650 --> 00:05:39,649
three it puts you into one great and at

00:05:37,610 --> 00:05:41,330
this point actually I just reading the

00:05:39,649 --> 00:05:46,460
first slide just a public health warning

00:05:41,330 --> 00:05:55,610
on these slides and so yeah you all

00:05:46,460 --> 00:05:58,479
signed the waiver right yeah okay so

00:05:55,610 --> 00:06:01,430
that's the decisions taken care of and

00:05:58,479 --> 00:06:03,649
the second rule is that if you are one

00:06:01,430 --> 00:06:05,689
you or and exactly two neighbors are one

00:06:03,649 --> 00:06:08,360
then you stay one once again is the same

00:06:05,689 --> 00:06:09,860
formula again and it's equal to two and

00:06:08,360 --> 00:06:12,009
this one is checking a course the grid

00:06:09,860 --> 00:06:14,930
position itself is equal to one first

00:06:12,009 --> 00:06:18,289
the final rule and is with trivial

00:06:14,930 --> 00:06:20,149
otherwise 00 now we want to join these

00:06:18,289 --> 00:06:23,270
together and the or operator is

00:06:20,149 --> 00:06:24,860
basically rafter left join and will be

00:06:23,270 --> 00:06:26,479
nice have separate expressions and then

00:06:24,860 --> 00:06:29,509
do your together but due to the fact

00:06:26,479 --> 00:06:30,830
that oh i rue the expressions and

00:06:29,509 --> 00:06:32,899
putting it back into the system on each

00:06:30,830 --> 00:06:34,729
cycle is done simultaneously no ordering

00:06:32,899 --> 00:06:37,520
that doesn't work so we have to do a

00:06:34,729 --> 00:06:40,370
little bit of beta reduction now what

00:06:37,520 --> 00:06:41,479
does this give us is an output and the

00:06:40,370 --> 00:06:43,719
answer is it gives us something like

00:06:41,479 --> 00:06:43,719
this

00:06:55,360 --> 00:07:02,439
the academic world is still on web one

00:06:58,310 --> 00:07:02,439
point oh that is the HTTP meta refresh

00:07:02,919 --> 00:07:09,590
yes so this is what's known as a

00:07:06,289 --> 00:07:12,169
Conway's life which was advised in 1970

00:07:09,590 --> 00:07:14,060
by John Conway a mathematician it is

00:07:12,169 --> 00:07:17,180
known to be sure incapable which Conway

00:07:14,060 --> 00:07:19,340
showed in 1982 and full Turing machines

00:07:17,180 --> 00:07:23,060
have been implemented in college life by

00:07:19,340 --> 00:07:25,189
two poles in an atom into thousands now

00:07:23,060 --> 00:07:26,719
for those of you who are not you know

00:07:25,189 --> 00:07:30,590
form of you know science researchers

00:07:26,719 --> 00:07:32,870
like myself and if something is future

00:07:30,590 --> 00:07:34,550
incapable that means that it can compute

00:07:32,870 --> 00:07:38,810
anything possible and it is as powerful

00:07:34,550 --> 00:07:42,110
as a language as lisp or haskell or no

00:07:38,810 --> 00:07:43,580
Jas or even go so this means that there

00:07:42,110 --> 00:07:45,949
is no more advantageous in heaven

00:07:43,580 --> 00:07:48,589
language is more powerful than from ql i

00:07:45,949 --> 00:07:51,409
think that the orders of that will be

00:07:48,589 --> 00:07:53,000
rather happy to say so here's some

00:07:51,409 --> 00:07:54,889
resources so as an information war and

00:07:53,000 --> 00:07:56,180
how this goes on there is a live demo

00:07:54,889 --> 00:07:58,490
that's been running continuously for

00:07:56,180 --> 00:08:02,860
almost a year and more information about

00:07:58,490 --> 00:08:02,860
myself and my academic adventures thank

00:08:07,270 --> 00:08:09,330

YouTube URL: https://www.youtube.com/watch?v=lrfTpnzq3Kw


