Title: PromCon EU 2019: PromQL for Mere Mortals
Publication date: 2019-12-29
Playlist: PromCon EU 2019
Description: 
	Speaker: Ian Billett

PromQL can feel intimidating at first for those new to the Prometheus ecosystem, but it is an essential skill to learn when starting out monitoring and alerting in the Prometheus ecosystem. In this beginner-focused, demo-driven talk Ian Billett will walk through the thought processes, mental models and coping strategies he uses to tame PromQL and effectively query metrics data. We will demystify instant vector selectors from range vector selectors, understand how aggregate functions work, and, time-permitting, even touch on some PromQL engine internals.

Slides: https://promcon.io/2019-munich/slides/promql-for-mere-mortals.pdf
Captions: 
	00:00:00,650 --> 00:00:08,910
[Music]

00:00:10,299 --> 00:00:14,830
so my name is Ian billet I'm an engineer

00:00:13,269 --> 00:00:16,930
at improbable where I work on our

00:00:14,830 --> 00:00:19,720
internal platform observability team and

00:00:16,930 --> 00:00:22,000
the title of this talk is from ql for

00:00:19,720 --> 00:00:24,099
mere mortals and this talk is about the

00:00:22,000 --> 00:00:26,619
fundamentals a prompt you are it's about

00:00:24,099 --> 00:00:27,969
helping people out there to develop the

00:00:26,619 --> 00:00:29,649
right mental models and thought

00:00:27,969 --> 00:00:31,899
processes they're going to help them

00:00:29,649 --> 00:00:34,300
really get to grips with prompt QL and

00:00:31,899 --> 00:00:36,489
this talk is primarily aimed at kind of

00:00:34,300 --> 00:00:38,440
the more the new the new people in the

00:00:36,489 --> 00:00:40,539
ecosystem but I hope that even the more

00:00:38,440 --> 00:00:43,210
experienced among you can take something

00:00:40,539 --> 00:00:45,370
away and so this talk is gonna be full

00:00:43,210 --> 00:00:48,430
of mistakes that I've made which is good

00:00:45,370 --> 00:00:50,560
and if any of you go away from this talk

00:00:48,430 --> 00:00:52,329
and don't make one of the mistakes that

00:00:50,560 --> 00:00:56,440
I made then this talk has been a wrong

00:00:52,329 --> 00:00:57,820
success and so this was me maybe nine

00:00:56,440 --> 00:01:00,430
ten months ago when I started out with

00:00:57,820 --> 00:01:03,989
pom QL and I'm not sure how much has

00:01:00,430 --> 00:01:06,189
changed since then so a quick agenda

00:01:03,989 --> 00:01:08,159
we're gonna start with the very basics

00:01:06,189 --> 00:01:10,780
we're going to talk about time series

00:01:08,159 --> 00:01:12,310
instant vectors range vectors and we're

00:01:10,780 --> 00:01:15,119
going to use it as a foundation to build

00:01:12,310 --> 00:01:17,530
up to talking about gauges counters

00:01:15,119 --> 00:01:19,899
operators functions then we're going to

00:01:17,530 --> 00:01:22,479
tie it all together with a demo at the

00:01:19,899 --> 00:01:26,590
end so the first thing to say is that

00:01:22,479 --> 00:01:30,340
prompt QL is important of queries alerts

00:01:26,590 --> 00:01:32,319
dashboards any anywhere in the ecosystem

00:01:30,340 --> 00:01:34,689
that requires the retrieval of metrics

00:01:32,319 --> 00:01:37,859
data will necessarily involve prompt QL

00:01:34,689 --> 00:01:40,560
in some capacity but at the same time

00:01:37,859 --> 00:01:44,979
it's an intimidating technologies alone

00:01:40,560 --> 00:01:47,619
this spicy nugget was one of the first

00:01:44,979 --> 00:01:49,929
alerting rules I had to dig into and

00:01:47,619 --> 00:01:53,049
even now I couldn't easily tell you what

00:01:49,929 --> 00:01:55,329
is going on there and in the early days

00:01:53,049 --> 00:01:57,579
of using prompt QL my workflow was very

00:01:55,329 --> 00:02:00,159
much just fine some queries kind of mash

00:01:57,579 --> 00:02:02,579
them together add some square brackets

00:02:00,159 --> 00:02:05,919
and then to keep trying that until the

00:02:02,579 --> 00:02:08,020
console stopped complaining at me this

00:02:05,919 --> 00:02:09,369
wasn't a very sophisticated approach and

00:02:08,020 --> 00:02:11,260
definitely did not demonstrate an

00:02:09,369 --> 00:02:13,810
understanding of the fundamentals of

00:02:11,260 --> 00:02:17,020
this language but in all seriousness low

00:02:13,810 --> 00:02:18,760
prompt QL is essential but it also means

00:02:17,020 --> 00:02:23,569
it's a barrier to entry to the ecosystem

00:02:18,760 --> 00:02:25,459
and we must not lose sight of that so

00:02:23,569 --> 00:02:27,709
time-series first of all so a time

00:02:25,459 --> 00:02:30,890
series is a stream of time some value

00:02:27,709 --> 00:02:32,930
pairs like this and each time series is

00:02:30,890 --> 00:02:35,209
uniquely identified by the identifier

00:02:32,930 --> 00:02:37,849
and this identifier is a set of key

00:02:35,209 --> 00:02:40,010
value pairs that looks like this in the

00:02:37,849 --> 00:02:41,659
UI which is just syntactic sugar for a

00:02:40,010 --> 00:02:47,120
kind of a I think it is just like

00:02:41,659 --> 00:02:48,769
adjacent objects basically so when you

00:02:47,120 --> 00:02:51,230
set off on your adventure into the

00:02:48,769 --> 00:02:52,849
prompt QL documentation the first thing

00:02:51,230 --> 00:02:54,709
you bump into are the four fundamental

00:02:52,849 --> 00:02:57,400
data types in prompt QL these are

00:02:54,709 --> 00:03:00,019
strings yeah we all know what those are

00:02:57,400 --> 00:03:02,959
scalars weird name but that's just a

00:03:00,019 --> 00:03:04,939
float to me then you bump into insert

00:03:02,959 --> 00:03:08,959
vectors and range vectors huh

00:03:04,939 --> 00:03:10,639
what are these so a brief bit of context

00:03:08,959 --> 00:03:12,260
now to absolve me of looking like a

00:03:10,639 --> 00:03:14,299
complete idiot in the next section

00:03:12,260 --> 00:03:17,870
prompt your lives my third query

00:03:14,299 --> 00:03:20,560
language after SQL jaql although I've

00:03:17,870 --> 00:03:26,299
never publicly admit to knowing in jqr

00:03:20,560 --> 00:03:28,040
and prompt you up and so as as a human

00:03:26,299 --> 00:03:29,810
learning a new skill it is the most

00:03:28,040 --> 00:03:31,699
natural thing to take the menÃ­s models

00:03:29,810 --> 00:03:33,260
you have for something else and try to

00:03:31,699 --> 00:03:34,790
the next nearest thing and try to apply

00:03:33,260 --> 00:03:38,180
that to the new thing you're trying to

00:03:34,790 --> 00:03:39,409
learn and in my case that was SQL and my

00:03:38,180 --> 00:03:41,750
knowledge of relational databases I

00:03:39,409 --> 00:03:43,819
tried to pick that up and put that kind

00:03:41,750 --> 00:03:47,229
of rationalized time series with respect

00:03:43,819 --> 00:03:49,489
to that which has kind of hilarious

00:03:47,229 --> 00:03:58,010
disastrous and often frustrating

00:03:49,489 --> 00:03:59,209
consequences so firstly so this is the

00:03:58,010 --> 00:04:01,250
definition of an instant vector from the

00:03:59,209 --> 00:04:04,519
documentation and I look at that and I

00:04:01,250 --> 00:04:07,280
think huh okay we have a set of time

00:04:04,519 --> 00:04:09,489
series we have a timestamp and we have a

00:04:07,280 --> 00:04:12,379
value for each time stamped series pair

00:04:09,489 --> 00:04:13,970
so the SQL lobe in my brain kind of

00:04:12,379 --> 00:04:16,220
starts throbbing at this point and I

00:04:13,970 --> 00:04:17,750
immediately think of this kind of makes

00:04:16,220 --> 00:04:20,299
sense right we have a set of time series

00:04:17,750 --> 00:04:22,970
have a timestamp and we have a value for

00:04:20,299 --> 00:04:23,919
each series timestamp pair kind of seems

00:04:22,970 --> 00:04:28,340
sensible right

00:04:23,919 --> 00:04:29,840
okay so range vectors so and then this

00:04:28,340 --> 00:04:32,990
is what the internet does look like in

00:04:29,840 --> 00:04:35,360
the Prometheus UI range vectors now so

00:04:32,990 --> 00:04:37,249
again this is the definition of a range

00:04:35,360 --> 00:04:40,009
vector from documentation

00:04:37,249 --> 00:04:42,259
I read that and I think huh okay we have

00:04:40,009 --> 00:04:44,059
a set of time series we have a range of

00:04:42,259 --> 00:04:47,449
time stamps and for that range for each

00:04:44,059 --> 00:04:49,549
series we have a range of values again

00:04:47,449 --> 00:04:51,229
the sequel over my head kind of starts

00:04:49,549 --> 00:04:54,259
throbbing and kicking in here and I

00:04:51,229 --> 00:04:56,359
think of this so here we have a set of

00:04:54,259 --> 00:04:58,459
tits a set of x theory is that a series

00:04:56,359 --> 00:05:00,259
across the top we have time decreasing

00:04:58,459 --> 00:05:02,659
the left-hand side and we have a range

00:05:00,259 --> 00:05:05,929
of values for each time series it's kind

00:05:02,659 --> 00:05:07,549
of seem sensible right so at this point

00:05:05,929 --> 00:05:11,899
again sorry this is what it looks like

00:05:07,549 --> 00:05:16,610
in the previous UI so at this point I

00:05:11,899 --> 00:05:19,389
was confused I was really confused given

00:05:16,610 --> 00:05:23,149
the mental models I described to you and

00:05:19,389 --> 00:05:25,189
I had some questions like if we had a

00:05:23,149 --> 00:05:27,589
range vector with only one sample in it

00:05:25,189 --> 00:05:28,849
is that actually an instant vector are

00:05:27,589 --> 00:05:30,729
we really not asking like what is the

00:05:28,849 --> 00:05:33,559
difference between an array and a matrix

00:05:30,729 --> 00:05:35,059
and this one led me to the asked the

00:05:33,559 --> 00:05:36,769
question of are they really that

00:05:35,059 --> 00:05:38,929
different and the answer to this

00:05:36,769 --> 00:05:45,619
question is emphatically yes they are

00:05:38,929 --> 00:05:47,049
very very different and so the problem

00:05:45,619 --> 00:05:49,159
here was that I was fundamentally

00:05:47,049 --> 00:05:51,589
misunderstanding the Prometheus dates

00:05:49,159 --> 00:05:52,969
model I was trying to take the mental

00:05:51,589 --> 00:05:54,649
models that served me very well in the

00:05:52,969 --> 00:05:56,869
SQL in the relational database world and

00:05:54,649 --> 00:05:59,899
trying to apply them to the to the time

00:05:56,869 --> 00:06:02,689
series world so let me now introduce to

00:05:59,899 --> 00:06:04,099
you all the way that because the mental

00:06:02,689 --> 00:06:06,319
models are I've constructed for myself

00:06:04,099 --> 00:06:08,419
to help me really understand and the

00:06:06,319 --> 00:06:09,649
previous data model and I'm a very very

00:06:08,419 --> 00:06:11,389
visual learner so I hope this is going

00:06:09,649 --> 00:06:14,149
to help some of you as well so it looks

00:06:11,389 --> 00:06:15,949
like this we have a set of time series

00:06:14,149 --> 00:06:17,629
across the top we have time decreasing

00:06:15,949 --> 00:06:21,289
on the left hand side and each point

00:06:17,629 --> 00:06:23,329
here is a value is a timestamp value in

00:06:21,289 --> 00:06:25,549
that series the important thing to

00:06:23,329 --> 00:06:26,989
notice here though is that none of the

00:06:25,549 --> 00:06:29,029
points occur at exactly the same time

00:06:26,989 --> 00:06:30,499
and this is exactly how Prometheus works

00:06:29,029 --> 00:06:32,629
so Prometheus will go off to a scrape

00:06:30,499 --> 00:06:34,369
target retrieve some data and insert it

00:06:32,629 --> 00:06:36,319
into the TS DV it's likely a lot of

00:06:34,369 --> 00:06:37,519
these going on at same time and none of

00:06:36,319 --> 00:06:40,279
these scrapes going to be happening at

00:06:37,519 --> 00:06:44,989
exactly the same time so when we have

00:06:40,279 --> 00:06:46,489
this in mind thinking about instant

00:06:44,989 --> 00:06:50,449
vectors and range vectors it becomes

00:06:46,489 --> 00:06:51,530
obvious it's the vectors for example we

00:06:50,449 --> 00:06:54,250
have in

00:06:51,530 --> 00:06:57,680
and into the vector will return to you

00:06:54,250 --> 00:07:01,910
the most recent sample for each series

00:06:57,680 --> 00:07:02,900
and then we look at range vectors so

00:07:01,910 --> 00:07:04,880
with range vectors you tend to

00:07:02,900 --> 00:07:07,670
effectively give prompt QL to timestamps

00:07:04,880 --> 00:07:09,140
and promptly I'll return to you all of

00:07:07,670 --> 00:07:12,110
the values that occurred between those

00:07:09,140 --> 00:07:13,640
two timestamps okay this could be 0 it

00:07:12,110 --> 00:07:15,130
could be 1 it could be 10 it could be

00:07:13,640 --> 00:07:17,330
any number

00:07:15,130 --> 00:07:20,720
so to label this point home one last

00:07:17,330 --> 00:07:24,140
time instant vectors you're guaranteed

00:07:20,720 --> 00:07:25,850
to get one value per time series and

00:07:24,140 --> 00:07:27,410
with range vectors you're going to get

00:07:25,850 --> 00:07:35,750
any number of values between the two

00:07:27,410 --> 00:07:37,790
timestamps so with this foundation with

00:07:35,750 --> 00:07:39,530
time series with range vectors with

00:07:37,790 --> 00:07:41,210
instant vectors we can now use this to

00:07:39,530 --> 00:07:44,510
start talking about more complex topics

00:07:41,210 --> 00:07:47,270
so counters engages firstly counters a

00:07:44,510 --> 00:07:49,640
counter is a valve is a value in the

00:07:47,270 --> 00:07:51,230
time series where the number is only

00:07:49,640 --> 00:07:53,570
ever increasing it's going up it

00:07:51,230 --> 00:07:56,450
monotonically increasing to use the

00:07:53,570 --> 00:07:58,490
phrase I don't fully understand and the

00:07:56,450 --> 00:08:01,070
Kansas this is a gauge and engage is a

00:07:58,490 --> 00:08:03,380
metric value that can go up or down the

00:08:01,070 --> 00:08:06,110
tricky thing here with counters is that

00:08:03,380 --> 00:08:08,330
the the instance that is serving this

00:08:06,110 --> 00:08:10,250
metric to you if that instance crashes

00:08:08,330 --> 00:08:12,200
that counter is going to be reset from

00:08:10,250 --> 00:08:14,750
zero and it's going to start kind of is

00:08:12,200 --> 00:08:16,610
gonna start increasing from there on and

00:08:14,750 --> 00:08:21,710
this is gonna be important later in this

00:08:16,610 --> 00:08:25,190
talk operators okay there are two types

00:08:21,710 --> 00:08:26,360
of operators the first one is there it's

00:08:25,190 --> 00:08:30,140
the aggregation operators in the binary

00:08:26,360 --> 00:08:32,420
operators aggregation operators first so

00:08:30,140 --> 00:08:34,910
aggregation operators only take instant

00:08:32,420 --> 00:08:37,070
vectors as input and they only return

00:08:34,910 --> 00:08:39,590
into that this is output there's also an

00:08:37,070 --> 00:08:42,979
obvious meet at start so give it a time

00:08:39,590 --> 00:08:44,510
series is set to time series the

00:08:42,979 --> 00:08:47,870
aggregation operators will return to you

00:08:44,510 --> 00:08:50,210
and you a new instant vector where the

00:08:47,870 --> 00:08:52,790
labels of a new inspector owns you told

00:08:50,210 --> 00:08:54,830
it to care about and the value at each

00:08:52,790 --> 00:08:58,850
of those series is the aggregation

00:08:54,830 --> 00:09:00,890
operator applied to the group of values

00:08:58,850 --> 00:09:01,760
that you told it to care about that

00:09:00,890 --> 00:09:03,170
doesn't make any sense

00:09:01,760 --> 00:09:03,870
we'll do a demo and I'll make a lot of

00:09:03,170 --> 00:09:06,660
sense

00:09:03,870 --> 00:09:14,339
and the usual suspects here by some min

00:09:06,660 --> 00:09:15,690
max etc binary operators so there are

00:09:14,339 --> 00:09:18,420
three types of binary operators in from

00:09:15,690 --> 00:09:20,520
QL arithmetic comparison set operators

00:09:18,420 --> 00:09:21,360
these are the usual suspects in

00:09:20,520 --> 00:09:23,779
programming languages

00:09:21,360 --> 00:09:26,400
I'm sure you're all fairly familiar and

00:09:23,779 --> 00:09:29,010
binary operators surprise surprise they

00:09:26,400 --> 00:09:31,710
operate between two operands these can

00:09:29,010 --> 00:09:33,900
either be scalars or insert vectors so

00:09:31,710 --> 00:09:36,240
when we have two scalars the result is a

00:09:33,900 --> 00:09:37,980
scalar we have a scalar and an insta

00:09:36,240 --> 00:09:39,630
better the result is an instant vector

00:09:37,980 --> 00:09:41,820
when we have an instant vector an

00:09:39,630 --> 00:09:43,529
instant vector the result is also an

00:09:41,820 --> 00:09:46,950
instant vector but this is where I get

00:09:43,529 --> 00:09:48,540
spicy because when you're operating

00:09:46,950 --> 00:09:50,910
between two instant vectors you need to

00:09:48,540 --> 00:09:53,520
be very very careful about the label

00:09:50,910 --> 00:09:56,430
sets on both sides from QL is very very

00:09:53,520 --> 00:09:58,290
picky about and matching those label set

00:09:56,430 --> 00:10:03,000
we're going to see this in our demo in

00:09:58,290 --> 00:10:05,029
just a bit functions there are a bunch

00:10:03,000 --> 00:10:07,680
of functions available to you from QL

00:10:05,029 --> 00:10:09,360
they either take an instep actor's input

00:10:07,680 --> 00:10:11,040
I'm turning into vector or they take a

00:10:09,360 --> 00:10:14,070
range vector as input and return an it's

00:10:11,040 --> 00:10:19,110
in fact but there is one function that

00:10:14,070 --> 00:10:22,430
rules them all there is one function

00:10:19,110 --> 00:10:25,380
that will account for 90 plus percent of

00:10:22,430 --> 00:10:29,580
your use of your use cases in prompt QL

00:10:25,380 --> 00:10:32,339
and that is rate so rate is a function

00:10:29,580 --> 00:10:33,900
which takes a range vector as input and

00:10:32,339 --> 00:10:36,959
returns you an instan Becker is output

00:10:33,900 --> 00:10:39,240
and it basically it calculates the per

00:10:36,959 --> 00:10:41,070
second increase of your cancer rate must

00:10:39,240 --> 00:10:42,959
only be used with a count available in

00:10:41,070 --> 00:10:45,990
every gauge variable it makes no sense

00:10:42,959 --> 00:10:48,150
to use it with a gauge variable and this

00:10:45,990 --> 00:10:49,890
is the most common pattern you'll see in

00:10:48,150 --> 00:10:52,200
prom queue up anywhere and you need to

00:10:49,890 --> 00:10:54,720
get it kind of branded into your brain

00:10:52,200 --> 00:10:57,240
it's very very common but rate the rate

00:10:54,720 --> 00:10:59,580
function is also magic and the reason

00:10:57,240 --> 00:11:01,709
why it's magic is because of the way it

00:10:59,580 --> 00:11:04,740
handles counter resets like I mentioned

00:11:01,709 --> 00:11:08,520
before and what's magic about this is

00:11:04,740 --> 00:11:10,470
say for example you had your a target

00:11:08,520 --> 00:11:12,300
that was exposing a metric and that went

00:11:10,470 --> 00:11:14,339
for two and then it crashed and reset

00:11:12,300 --> 00:11:16,860
one three the rate function would be

00:11:14,339 --> 00:11:17,640
smart enough to interpret this as four

00:11:16,860 --> 00:11:20,880
six seven

00:11:17,640 --> 00:11:22,760
9 ok so the rate function using the rate

00:11:20,880 --> 00:11:26,340
function protects you against

00:11:22,760 --> 00:11:27,810
inadvertently seeing the world in in a

00:11:26,340 --> 00:11:32,730
way that you're kind of not expecting to

00:11:27,810 --> 00:11:36,110
see it it's very important ok so we

00:11:32,730 --> 00:11:40,170
talked about counters talked about

00:11:36,110 --> 00:11:42,470
gauges we've talked about operators and

00:11:40,170 --> 00:11:44,700
I've talked about functions so now I

00:11:42,470 --> 00:11:49,740
haven't sacrificed anything for demo

00:11:44,700 --> 00:11:54,510
gods today so bear with me sorry I have

00:11:49,740 --> 00:12:00,840
a spoon so you know and Brian please

00:11:54,510 --> 00:12:03,060
don't take down your testing server ok

00:12:00,840 --> 00:12:04,410
so the the the the realistic demo we're

00:12:03,060 --> 00:12:08,190
gonna create for ourselves here is we

00:12:04,410 --> 00:12:11,250
want to figure out on our CPU cores on a

00:12:08,190 --> 00:12:14,870
machine how much time I walk portion at

00:12:11,250 --> 00:12:18,210
the time is that CPU spent in idle mode

00:12:14,870 --> 00:12:22,530
okay and so we're gonna use this metric

00:12:18,210 --> 00:12:24,420
here node CPU seconds total okay and we

00:12:22,530 --> 00:12:27,750
can inspect this metric and we see okay

00:12:24,420 --> 00:12:30,690
we have the CPU label instance job and

00:12:27,750 --> 00:12:33,060
mode label okay so if we want to figure

00:12:30,690 --> 00:12:35,580
out the proportion of our time spent in

00:12:33,060 --> 00:12:38,130
a certain mode we need to take the time

00:12:35,580 --> 00:12:41,880
spent in that mode divide it by the time

00:12:38,130 --> 00:12:44,490
the toe see the CPU spent running okay

00:12:41,880 --> 00:12:46,410
and so we would do this so first thing

00:12:44,490 --> 00:12:48,600
we'll figure out how long the CPU was

00:12:46,410 --> 00:12:49,980
spent in the idle mode so if I miss

00:12:48,600 --> 00:12:53,400
metree okay we'll see we have some

00:12:49,980 --> 00:12:56,250
fairly large numbers here I'm like okay

00:12:53,400 --> 00:12:58,920
cool so now I want to aggregate these

00:12:56,250 --> 00:13:02,430
metrics such that I've only got the CPU

00:12:58,920 --> 00:13:04,020
label at the end and I might do

00:13:02,430 --> 00:13:06,990
something like this so if I evaluate

00:13:04,020 --> 00:13:07,230
this that's wrong that doesn't look

00:13:06,990 --> 00:13:08,970
right

00:13:07,230 --> 00:13:11,250
we've got a we got a response returned

00:13:08,970 --> 00:13:12,510
to us but there's no labels on the left

00:13:11,250 --> 00:13:14,580
hand side and it's quite a large number

00:13:12,510 --> 00:13:16,230
on the right hand side so the problem

00:13:14,580 --> 00:13:18,360
here is that we weren't telling our

00:13:16,230 --> 00:13:20,460
aggregation operator which labels we

00:13:18,360 --> 00:13:21,990
care about and so if if you don't tell

00:13:20,460 --> 00:13:23,280
it it just assumes oh you don't care

00:13:21,990 --> 00:13:24,390
about any of them we're not going to

00:13:23,280 --> 00:13:26,310
give you any back and that's exactly

00:13:24,390 --> 00:13:28,590
what's happened here so to get around

00:13:26,310 --> 00:13:31,170
this what we do is we use the by

00:13:28,590 --> 00:13:33,779
operator the by operator tells

00:13:31,170 --> 00:13:36,029
aggregation operator hey aggregates only

00:13:33,779 --> 00:13:37,470
buy these labels that I tell you there

00:13:36,029 --> 00:13:39,630
is a complementary operator called the

00:13:37,470 --> 00:13:40,980
without operator which says hey I gotta

00:13:39,630 --> 00:13:43,170
get like all the labels without

00:13:40,980 --> 00:13:45,300
including these ones I'm gonna tell you

00:13:43,170 --> 00:13:48,930
about so for you just evaluate this

00:13:45,300 --> 00:13:52,019
query we can see we get the result that

00:13:48,930 --> 00:13:55,970
we're expecting and this seems kind of

00:13:52,019 --> 00:13:58,440
sensible right no this is not sensible

00:13:55,970 --> 00:14:01,380
and this is a very subtle point that

00:13:58,440 --> 00:14:02,970
took me a long time to figure out the

00:14:01,380 --> 00:14:05,940
problem here is that we're summing on a

00:14:02,970 --> 00:14:09,029
raw cancer okay and this is a big no-no

00:14:05,940 --> 00:14:11,370
because counters can be reset so you

00:14:09,029 --> 00:14:13,320
might be inadvertently seeing a state of

00:14:11,370 --> 00:14:15,750
the world where some of your scrape

00:14:13,320 --> 00:14:17,040
targets have been reset and so you could

00:14:15,750 --> 00:14:18,930
be think the state the world is like it

00:14:17,040 --> 00:14:21,300
is but actually something crashed you're

00:14:18,930 --> 00:14:23,639
seeing much lower values so how do we

00:14:21,300 --> 00:14:26,940
protect ourselves against this we use

00:14:23,639 --> 00:14:28,829
our handy rate function rate functions

00:14:26,940 --> 00:14:32,250
they they know how to deal with counter

00:14:28,829 --> 00:14:34,350
resets and you should always use it in

00:14:32,250 --> 00:14:35,370
this pattern as I said the most common

00:14:34,350 --> 00:14:37,410
pattern you're going to see in prompt

00:14:35,370 --> 00:14:40,410
Cuba so we'll evaluate that

00:14:37,410 --> 00:14:42,750
that looks very sensible and then we're

00:14:40,410 --> 00:14:43,170
going to wrap rates function up in a sum

00:14:42,750 --> 00:14:47,220
function

00:14:43,170 --> 00:14:48,290
you always sum a rate never ever rate a

00:14:47,220 --> 00:14:51,170
son

00:14:48,290 --> 00:14:53,850
Danny's be in your heads as well

00:14:51,170 --> 00:14:57,390
subtlety but an important one so when

00:14:53,850 --> 00:14:59,790
you evaluate this query we get the we

00:14:57,390 --> 00:15:01,829
get the result we're expecting but also

00:14:59,790 --> 00:15:06,510
we are robust against counter resets

00:15:01,829 --> 00:15:08,760
here okay so now we have the numerator

00:15:06,510 --> 00:15:11,519
of our equation we need to figure out

00:15:08,760 --> 00:15:14,970
the denominator of our equation as we

00:15:11,519 --> 00:15:18,269
want to divide this now by the total CPU

00:15:14,970 --> 00:15:20,640
time and we're going to take the rates

00:15:18,269 --> 00:15:22,949
again to be robust and in this query we

00:15:20,640 --> 00:15:24,120
have CP on the left hand side but also

00:15:22,949 --> 00:15:27,329
gonna have two CPU on the right hand

00:15:24,120 --> 00:15:31,110
side so this is gonna work right right

00:15:27,329 --> 00:15:32,970
no this is not gonna work at all problem

00:15:31,110 --> 00:15:35,459
here is we're using binary operators and

00:15:32,970 --> 00:15:37,410
as I said binary operators are very very

00:15:35,459 --> 00:15:39,420
picky about what labels are on the left

00:15:37,410 --> 00:15:41,819
hand side and the right hand side on the

00:15:39,420 --> 00:15:43,680
left hand side here we have only CPU

00:15:41,819 --> 00:15:44,610
label but on the right hand side here we

00:15:43,680 --> 00:15:47,579
have CPU

00:15:44,610 --> 00:15:49,380
you instance job labels so prompt email

00:15:47,579 --> 00:15:54,269
doesn't know what to do in this in this

00:15:49,380 --> 00:15:55,680
instance so to get around this we're

00:15:54,269 --> 00:15:59,250
gonna just apply the aggregation

00:15:55,680 --> 00:16:02,670
operator to our denominator and tell it

00:15:59,250 --> 00:16:05,190
to aggregate by the CPU label and we

00:16:02,670 --> 00:16:07,560
evaluate that and we get the result

00:16:05,190 --> 00:16:09,060
we're looking for whilst being robust to

00:16:07,560 --> 00:16:13,260
a class of problems that you might

00:16:09,060 --> 00:16:18,300
otherwise forget about awesome let me

00:16:13,260 --> 00:16:21,540
just switch back to my slides okay so

00:16:18,300 --> 00:16:24,720
just to recap these gotchas in the last

00:16:21,540 --> 00:16:26,790
demo tell your aggregation operators

00:16:24,720 --> 00:16:28,560
about which labels you care about

00:16:26,790 --> 00:16:33,510
otherwise you might get unexpected

00:16:28,560 --> 00:16:36,120
results number two never compare raw

00:16:33,510 --> 00:16:37,950
counters okay this is kind of this isn't

00:16:36,120 --> 00:16:39,899
a meaningless thing to do because of the

00:16:37,950 --> 00:16:43,920
kinds of reset problem always wrap them

00:16:39,899 --> 00:16:45,390
up in rate finally be careful with your

00:16:43,920 --> 00:16:49,230
label sets when you're using binary

00:16:45,390 --> 00:16:51,209
operators okay yeah you're gonna get

00:16:49,230 --> 00:16:54,600
unexpected results and frustrating

00:16:51,209 --> 00:16:56,970
results for a lot of time okay so that's

00:16:54,600 --> 00:16:59,699
the most of what I have to say resources

00:16:56,970 --> 00:17:02,760
for prompt QL and the robust perception

00:16:59,699 --> 00:17:05,910
blog is excellent the blog posts are

00:17:02,760 --> 00:17:07,949
short and easily guessable and best

00:17:05,910 --> 00:17:09,750
practice go and look there the

00:17:07,949 --> 00:17:11,490
Prometheus up and running book is also

00:17:09,750 --> 00:17:14,720
excellent and the documentation

00:17:11,490 --> 00:17:16,380
obviously that goes without saying

00:17:14,720 --> 00:17:18,630
that's everything I have to say

00:17:16,380 --> 00:17:20,880
obligatory we are hiring

00:17:18,630 --> 00:17:22,169
everyone is hiring who isn't coming talk

00:17:20,880 --> 00:17:24,780
to me for my talk about improbable or

00:17:22,169 --> 00:17:26,929
anything and that's it thank you very

00:17:24,780 --> 00:17:26,929
much

00:17:30,059 --> 00:17:37,779
thank you any questions

00:17:32,110 --> 00:17:39,639
oh there's one hello

00:17:37,779 --> 00:17:42,309
so what is the difference between AI

00:17:39,639 --> 00:17:47,289
rate and rate between AI rates and rates

00:17:42,309 --> 00:17:49,899
oh I believe I'm irate so when you have

00:17:47,289 --> 00:17:52,990
an intake rate it gives us the per

00:17:49,899 --> 00:17:54,759
second average for all the samples in

00:17:52,990 --> 00:17:56,649
that range but I rate I believe only

00:17:54,759 --> 00:17:58,690
takes that only does the cupcakes the

00:17:56,649 --> 00:18:06,460
rate between the last two samples is

00:17:58,690 --> 00:18:08,320
that right yep okay perfect I can ask a

00:18:06,460 --> 00:18:23,049
question about staleness in five minutes

00:18:08,320 --> 00:18:26,139
oh I've seen a pattern of doing the sum

00:18:23,049 --> 00:18:27,490
of a rate of a histogram do you know

00:18:26,139 --> 00:18:28,509
what that does I know that it's

00:18:27,490 --> 00:18:29,320
something you do but I've never

00:18:28,509 --> 00:18:41,019
understood it

00:18:29,320 --> 00:18:43,240
sum of a rate of a histogram is anyone I

00:18:41,019 --> 00:18:45,309
can try to give a quick explanation

00:18:43,240 --> 00:18:48,909
every bucket of a histogram is just a

00:18:45,309 --> 00:18:52,620
counter of how many observations you've

00:18:48,909 --> 00:18:56,200
made of that latency category so a

00:18:52,620 --> 00:18:59,049
counter if you did the if you try to

00:18:56,200 --> 00:19:00,909
calculate quantile from that histogram

00:18:59,049 --> 00:19:02,769
over all time that that counter

00:19:00,909 --> 00:19:04,029
increased you'd get like the average

00:19:02,769 --> 00:19:06,399
overall time right

00:19:04,029 --> 00:19:08,919
including counter resets etc so that

00:19:06,399 --> 00:19:10,870
wouldn't work so what you really want to

00:19:08,919 --> 00:19:12,940
look at is usually the latency averaged

00:19:10,870 --> 00:19:17,379
over the last five minutes or so right

00:19:12,940 --> 00:19:20,740
and so by taking the rate over each of

00:19:17,379 --> 00:19:23,200
the individual bins the buckets you see

00:19:20,740 --> 00:19:24,879
their relative increases during the last

00:19:23,200 --> 00:19:27,250
five minutes right so you get again a

00:19:24,879 --> 00:19:29,830
histogram as an output but now it's

00:19:27,250 --> 00:19:31,809
basically over the last five minutes and

00:19:29,830 --> 00:19:33,460
the absolute values of the buckets don't

00:19:31,809 --> 00:19:35,559
really matter anymore because for the

00:19:33,460 --> 00:19:38,619
quantile calculation we only care about

00:19:35,559 --> 00:19:40,690
the relative amounts in each bucket so

00:19:38,619 --> 00:19:41,500
that's that's my attempt at an

00:19:40,690 --> 00:19:45,570
explanation

00:19:41,500 --> 00:19:45,570
you just as proof he's not a mere mortal

00:19:46,050 --> 00:19:57,820
more questions so I know you folks in

00:19:55,080 --> 00:20:00,580
improbably used honest and I believe

00:19:57,820 --> 00:20:03,640
that effectiveness of bronchial and

00:20:00,580 --> 00:20:08,260
you're recording also loading rules is

00:20:03,640 --> 00:20:11,920
somewhat important for you at least

00:20:08,260 --> 00:20:15,820
that's what I face in my daily life how

00:20:11,920 --> 00:20:17,620
do you assess effectiveness of other

00:20:15,820 --> 00:20:18,610
ting rules and recording tools and do

00:20:17,620 --> 00:20:21,700
you do it at all

00:20:18,610 --> 00:20:23,620
and how do iterate on these oh gosh

00:20:21,700 --> 00:20:26,170
there's a lot to to duck to dissect

00:20:23,620 --> 00:20:31,030
there so the effectiveness of alerting

00:20:26,170 --> 00:20:34,450
rules is a topic you could do a whole

00:20:31,030 --> 00:20:36,250
day's worth of talking I think the

00:20:34,450 --> 00:20:37,780
alerting rule I would only point you to

00:20:36,250 --> 00:20:39,640
kind of alerting best practices you know

00:20:37,780 --> 00:20:42,490
page level alerts only if it's

00:20:39,640 --> 00:20:45,840
actionable immediately something that

00:20:42,490 --> 00:20:45,840
looks bad but can wait till the morning

00:20:46,500 --> 00:20:59,980
okay effectiveness in terms of if they

00:20:58,720 --> 00:21:01,390
take too long lists kind of not really a

00:20:59,980 --> 00:21:02,500
huge amount you can do about it it

00:21:01,390 --> 00:21:03,780
depends entirely on the amount of data

00:21:02,500 --> 00:21:07,240
that is querying the backend

00:21:03,780 --> 00:21:08,620
effectiveness I mean prom kale is tricky

00:21:07,240 --> 00:21:10,870
because it's not that like the easiest

00:21:08,620 --> 00:21:13,840
thing to to read and to interpret and to

00:21:10,870 --> 00:21:17,770
grok so that's definitely something that

00:21:13,840 --> 00:21:19,210
you know is something that kind of needs

00:21:17,770 --> 00:21:21,760
to be thought about and have things put

00:21:19,210 --> 00:21:25,840
in place um I'm afraid I don't have much

00:21:21,760 --> 00:21:27,120
else to say about that any more

00:21:25,840 --> 00:21:30,370
questions

00:21:27,120 --> 00:21:31,260
i-if prompt UL is nice for mere mortal

00:21:30,370 --> 00:21:34,240
mortals

00:21:31,260 --> 00:21:37,780
what can we do from the documentation

00:21:34,240 --> 00:21:39,850
perspective to make it clear is there

00:21:37,780 --> 00:21:41,350
anything that we can do I mean funk us

00:21:39,850 --> 00:21:44,050
for mere mortals clearly because if I'm

00:21:41,350 --> 00:21:45,730
using it then gosh I'm the flesh and

00:21:44,050 --> 00:21:49,570
bones human being last time I checked

00:21:45,730 --> 00:21:52,060
and so with the documentation as I said

00:21:49,570 --> 00:21:54,760
I'm a very very visual learner like

00:21:52,060 --> 00:21:55,330
diagrams speak word like speak words to

00:21:54,760 --> 00:21:57,610
me as it

00:21:55,330 --> 00:21:58,899
I mean if those we could take these

00:21:57,610 --> 00:22:01,210
diagrams and put them in documentation

00:21:58,899 --> 00:22:03,129
it might have helped me not go through

00:22:01,210 --> 00:22:04,929
this process that I outlined to you all

00:22:03,129 --> 00:22:07,269
yeah that'd be a great thing I really

00:22:04,929 --> 00:22:08,919
think more diagrams and documentation is

00:22:07,269 --> 00:22:10,989
better than less but that's just me and

00:22:08,919 --> 00:22:12,519
you know can be interpreted in different

00:22:10,989 --> 00:22:14,559
ways so that has to be a discussion with

00:22:12,519 --> 00:22:22,419
with the community that I offer

00:22:14,559 --> 00:22:24,639
trainings um I I did not really

00:22:22,419 --> 00:22:26,350
understand what what was the number we

00:22:24,639 --> 00:22:30,899
were calculating with the with the

00:22:26,350 --> 00:22:33,840
Kaveri there it was in Weston 0.4 what

00:22:30,899 --> 00:22:37,389
okay so the the metric using was nodes

00:22:33,840 --> 00:22:42,639
CPU and seconds total and so we were

00:22:37,389 --> 00:22:45,129
calculating the how what proportion of

00:22:42,639 --> 00:22:46,330
time our CPU spends in idle mode because

00:22:45,129 --> 00:22:48,100
in a CPU there's a bunch of different

00:22:46,330 --> 00:22:50,499
modes there's like interrupt mode

00:22:48,100 --> 00:22:53,320
there's user modes like whatever and we

00:22:50,499 --> 00:22:56,259
were calculating the time the proportion

00:22:53,320 --> 00:23:00,730
of time we spent in an idle mode

00:22:56,259 --> 00:23:02,710
basically and it was kinda not the

00:23:00,730 --> 00:23:04,179
greatest and I think because the answer

00:23:02,710 --> 00:23:05,830
we had midway through is the answer we

00:23:04,179 --> 00:23:07,179
had at the ends but that's just a

00:23:05,830 --> 00:23:09,279
function fact that its second when you

00:23:07,179 --> 00:23:11,080
can't like a per second on a metric that

00:23:09,279 --> 00:23:13,539
seconds you're going to get like the

00:23:11,080 --> 00:23:15,070
proportion there but for completeness if

00:23:13,539 --> 00:23:17,499
the metric we weren't using didn't have

00:23:15,070 --> 00:23:18,720
this property we would absolutely have

00:23:17,499 --> 00:23:21,759
to do something like that something like

00:23:18,720 --> 00:23:24,249
HTTP requests total at the proportion

00:23:21,759 --> 00:23:35,259
that were 500s on a different endpoint

00:23:24,249 --> 00:23:39,190
you'd need to do something like that no

00:23:35,259 --> 00:23:43,330
great talk so me as well as anyone I

00:23:39,190 --> 00:23:48,179
think I'm using the rate function for

00:23:43,330 --> 00:23:50,409
CPU but I have troubles deciding what

00:23:48,179 --> 00:23:52,720
interval should I take for example you

00:23:50,409 --> 00:23:55,570
yeah I saw that you take ten minutes but

00:23:52,720 --> 00:23:57,489
I I want to take one minute but then

00:23:55,570 --> 00:23:59,739
there are too many spikes so what what

00:23:57,489 --> 00:24:03,340
are you talk okay that's a really good

00:23:59,739 --> 00:24:06,059
question um so when you're choosing how

00:24:03,340 --> 00:24:08,970
long to write over the one absolute

00:24:06,059 --> 00:24:12,870
golden rule you must always follow is

00:24:08,970 --> 00:24:15,150
the time frame must be at least four

00:24:12,870 --> 00:24:17,940
times your scrape interval in prometheus

00:24:15,150 --> 00:24:20,610
the reason this is because you know

00:24:17,940 --> 00:24:22,470
scrapes are valuable they will fail and

00:24:20,610 --> 00:24:24,390
if using a rape function you need at

00:24:22,470 --> 00:24:27,870
least two points to calculate that rate

00:24:24,390 --> 00:24:31,110
so Prometheus out of the box is 15

00:24:27,870 --> 00:24:31,890
seconds so minimum one minute for these

00:24:31,110 --> 00:24:34,530
kind of things to get accurate

00:24:31,890 --> 00:24:36,570
measurements but obviously like the

00:24:34,530 --> 00:24:41,540
longer time frame the smoother it's

00:24:36,570 --> 00:24:41,540
going to be so you know it's up to you

00:24:42,530 --> 00:24:49,890
any more questions yep hmm

00:24:46,380 --> 00:24:53,580
if some of rate is so common and we need

00:24:49,890 --> 00:24:57,150
to smooth the curve decision with the

00:24:53,580 --> 00:24:58,710
first derivative is there something

00:24:57,150 --> 00:25:01,440
prometheus can do to make the queries

00:24:58,710 --> 00:25:05,280
easier and faster to avoid that run

00:25:01,440 --> 00:25:07,110
around and so can you make the querying

00:25:05,280 --> 00:25:08,310
faster like I think that's kind of

00:25:07,110 --> 00:25:10,350
beside the point it's gonna do the

00:25:08,310 --> 00:25:11,490
calculation it needs to do there's

00:25:10,350 --> 00:25:13,050
there's an interesting question there

00:25:11,490 --> 00:25:15,480
about kind of the syntactic sugar of

00:25:13,050 --> 00:25:17,550
some rate because that allows you just

00:25:15,480 --> 00:25:19,260
to mess it up every time if you don't

00:25:17,550 --> 00:25:22,410
know rate some some rate What did he say

00:25:19,260 --> 00:25:24,480
that's all I can't remember so then

00:25:22,410 --> 00:25:26,310
maybe it's that is a very good reason

00:25:24,480 --> 00:25:30,630
and it doesn't come to my mind now I

00:25:26,310 --> 00:25:33,750
think but yeah that's down at the prompt

00:25:30,630 --> 00:25:45,180
ql language level and i'm not quite that

00:25:33,750 --> 00:25:47,400
level yet how do you deal with metrics

00:25:45,180 --> 00:25:50,910
that sometimes exist and sometimes

00:25:47,400 --> 00:25:53,520
doesn't some metrics sometimes exist for

00:25:50,910 --> 00:25:56,070
example the binary operators with

00:25:53,520 --> 00:26:00,110
metrics that doesn't exist binary

00:25:56,070 --> 00:26:03,600
operators with metrics that don't exist

00:26:00,110 --> 00:26:05,730
so if you're operating between a metric

00:26:03,600 --> 00:26:08,550
that doesn't exist you not gonna be

00:26:05,730 --> 00:26:11,070
opera like not operating between it um

00:26:08,550 --> 00:26:14,850
I'm not sure I understand the question

00:26:11,070 --> 00:26:17,010
fully their contacts me later on yeah

00:26:14,850 --> 00:26:18,450
there's two blog posts from Brian robust

00:26:17,010 --> 00:26:20,340
perception that might be interesting for

00:26:18,450 --> 00:26:22,270
this one is called a zing existential

00:26:20,340 --> 00:26:23,470
issues with metrics

00:26:22,270 --> 00:26:27,610
and I think there's another one using

00:26:23,470 --> 00:26:30,670
time series as thresholds which kind of

00:26:27,610 --> 00:26:32,110
touch that a bit like when when some

00:26:30,670 --> 00:26:34,120
metrics are sometimes missing you want

00:26:32,110 --> 00:26:37,480
to fill it up with a default value or

00:26:34,120 --> 00:26:39,370
something like this the more useful blog

00:26:37,480 --> 00:26:41,230
posts in this case are absolutely

00:26:39,370 --> 00:26:45,970
learning for jobs and absent alerting

00:26:41,230 --> 00:26:49,210
for scraped metrics cool yeah all right

00:26:45,970 --> 00:26:51,790
the absent function I think we're out of

00:26:49,210 --> 00:26:52,490
time so thank you very much thanks very

00:26:51,790 --> 00:26:55,500
much

00:26:52,490 --> 00:27:05,210
[Applause]

00:26:55,500 --> 00:27:05,210

YouTube URL: https://www.youtube.com/watch?v=hTjHuoWxsks


