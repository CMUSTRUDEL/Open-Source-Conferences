Title: PromCon 2017: Using TSDB as a library - Goutham Veeramachaneni
Publication date: 2017-09-01
Playlist: PromCon 2017
Description: 
	* Abstract:

This talk will be an introductory talk about using the new datastore as a library. It will be based on this blog: https://geekon.tech/content/post/tsdb-embeddable-timeseries-database/ with clearer and more verbose examples and a simple REST based timeseries demo at the end.

People will leave with:

* A clear understanding of how to use tsdb.
* The fundamentals that are needed to start contributing to the tsdb to Prometheus layer.

* Speaker biography:

I am a Student and a developer from India. But I like Ops more than Dev and Go more than all! My enthusiasm for Ops got me an internship on the infra team of a large company last summer where I worked on Production infrastructure and built the company's monitoring system on top of Prometheus.

That was my first encounter with production systems and Prometheus, and recently I started contributing to Prometheus again on the side and am now interning with CoreOS working on Prometheus' new storage engine.

* Slides:

https://promcon.io/2017-munich/slides/using-tsdb-as-a-library.pdf

* PromCon website:

https://promcon.io/
Captions: 
	00:00:00,380 --> 00:00:08,350
[Music]

00:00:12,889 --> 00:00:19,890
all right so now welcome Gotham who is a

00:00:17,100 --> 00:00:23,130
new contributor he started noticing

00:00:19,890 --> 00:00:27,090
Prometheus when fabian built the new TST

00:00:23,130 --> 00:00:29,160
beat for Prometheus - and like record

00:00:27,090 --> 00:00:31,439
speed learned how it all works and is

00:00:29,160 --> 00:00:33,270
already know improving it in various

00:00:31,439 --> 00:00:36,570
ways and he's going to now tell you how

00:00:33,270 --> 00:00:39,020
to use the TST B package outside of

00:00:36,570 --> 00:00:42,390
Prometheus for other purposes

00:00:39,020 --> 00:00:45,149
hello hi I'm Gautam I'm currently a

00:00:42,390 --> 00:00:47,250
bachelor student at IIT Hyderabad until

00:00:45,149 --> 00:00:48,930
exactly 10 days back I was an intern

00:00:47,250 --> 00:00:51,899
with core OS where I got to work on the

00:00:48,930 --> 00:00:53,190
two-pointer engine with Fabian so I have

00:00:51,899 --> 00:00:57,539
a question how many of you here are

00:00:53,190 --> 00:01:02,070
students Wow ok nice

00:00:57,539 --> 00:01:04,229
so yeah PSDB so this is the DSD B repo

00:01:02,070 --> 00:01:06,060
and this is Prometheus 2.0 storage

00:01:04,229 --> 00:01:08,369
engine and it's actually a library

00:01:06,060 --> 00:01:10,590
rendered by Prometheus this is was a

00:01:08,369 --> 00:01:13,200
conscious design decision which means

00:01:10,590 --> 00:01:15,570
you guys can embed it in your golang

00:01:13,200 --> 00:01:18,360
applications but why would you want to

00:01:15,570 --> 00:01:20,430
do that type I think time series is

00:01:18,360 --> 00:01:22,560
everywhere and I think this is a very

00:01:20,430 --> 00:01:24,750
nice API to deal with large data sets

00:01:22,560 --> 00:01:27,000
for example take weather data all of

00:01:24,750 --> 00:01:28,950
weather data is just time series and we

00:01:27,000 --> 00:01:31,979
probably want to do correlation and a

00:01:28,950 --> 00:01:34,259
lot of other data science stuff and you

00:01:31,979 --> 00:01:36,930
might be like oh I have big data I need

00:01:34,259 --> 00:01:39,540
a Hadoop cluster but from fabian stock

00:01:36,930 --> 00:01:41,700
we know that we can compress 1 billion

00:01:39,540 --> 00:01:43,619
points into one point just 1 point 2 GB

00:01:41,700 --> 00:01:46,719
so I don't think your big data is that

00:01:43,619 --> 00:01:56,750
big if you use tsdp

00:01:46,719 --> 00:01:59,450
so anyways so I'm gonna take you through

00:01:56,750 --> 00:02:01,579
so some people launch products at a

00:01:59,450 --> 00:02:02,869
conference I'm launching a startup

00:02:01,579 --> 00:02:06,890
I'm gonna take you through a crazy

00:02:02,869 --> 00:02:08,149
startup idea Prometheus with push so how

00:02:06,890 --> 00:02:10,580
many of you when you initially

00:02:08,149 --> 00:02:12,019
configured Prometheus thought why just

00:02:10,580 --> 00:02:14,209
Prometheus need to discover my services

00:02:12,019 --> 00:02:16,160
why can't I just push data oh my god

00:02:14,209 --> 00:02:18,319
service discovery reliable complex how

00:02:16,160 --> 00:02:20,120
many of you friend that oops

00:02:18,319 --> 00:02:22,610
how many of you are stupid enough to

00:02:20,120 --> 00:02:28,549
write an aggregator well you can push

00:02:22,610 --> 00:02:30,110
your data I did that anyways anyways we

00:02:28,549 --> 00:02:32,150
get a lot of requests for this at least

00:02:30,110 --> 00:02:34,489
are you when I was looking into it there

00:02:32,150 --> 00:02:36,739
were some requests so Prometheus has a

00:02:34,489 --> 00:02:37,160
lot of users if I capture 5% of those

00:02:36,739 --> 00:02:38,829
users

00:02:37,160 --> 00:02:44,780
I have a multi-million dollar startup

00:02:38,829 --> 00:02:46,400
introducing ROM flux so you you you in

00:02:44,780 --> 00:02:48,349
just influx line protocol which means

00:02:46,400 --> 00:02:50,540
all your client libraries are there and

00:02:48,349 --> 00:02:53,780
you query using chrome QL which we all

00:02:50,540 --> 00:03:08,480
know how cool it is and I'm not joking I

00:02:53,780 --> 00:03:12,440
even made a logo so no that is not how

00:03:08,480 --> 00:03:14,329
Prometheus works and I I spent it's been

00:03:12,440 --> 00:03:15,769
a long time since I touched a production

00:03:14,329 --> 00:03:17,450
Prometheus so all these terms are being

00:03:15,769 --> 00:03:19,910
products done by an amateur don't do it

00:03:17,450 --> 00:03:21,380
in production but the real reason I'm

00:03:19,910 --> 00:03:23,120
not doing that the money doesn't

00:03:21,380 --> 00:03:25,700
interest me is because this is the Brian

00:03:23,120 --> 00:03:30,739
I know and if I do this this is the

00:03:25,700 --> 00:03:32,829
Brian Elmo yeah but life is short Brian

00:03:30,739 --> 00:03:35,900
Brazil never heard of him let's do this

00:03:32,829 --> 00:03:37,730
so some basics from Fabian stock we know

00:03:35,900 --> 00:03:39,380
what a time series is a time season is

00:03:37,730 --> 00:03:41,599
basically a bunch of values each mark by

00:03:39,380 --> 00:03:43,489
time like weather in Berlin weather in

00:03:41,599 --> 00:03:46,130
Munich so five o'clock it's 10 10

00:03:43,489 --> 00:03:48,019
degrees 5 15 X 20 degrees so on and you

00:03:46,130 --> 00:03:49,700
can have several hundred thousand cups

00:03:48,019 --> 00:03:51,160
of time series like weather in Berlin

00:03:49,700 --> 00:03:53,840
weather in Munich weather in Hyderabad

00:03:51,160 --> 00:03:57,950
the rain the humidity a bunch of time

00:03:53,840 --> 00:03:59,180
series and this is how it looks inside

00:03:57,950 --> 00:04:01,939
prometheus

00:03:59,180 --> 00:04:04,250
and but Prometheus essentially maps it

00:04:01,939 --> 00:04:05,840
to a bunch of label-value pairs and it

00:04:04,250 --> 00:04:06,739
has this magic label name called

00:04:05,840 --> 00:04:09,650
underscore underscore name underscore

00:04:06,739 --> 00:04:12,739
underscore th DB doesn't have that th DB

00:04:09,650 --> 00:04:14,569
just has label value pairs and there's

00:04:12,739 --> 00:04:18,160
literally no math magic involved here so

00:04:14,569 --> 00:04:21,380
even this is a valid series inside TS DB

00:04:18,160 --> 00:04:23,389
yep so if now that I'm building prom

00:04:21,380 --> 00:04:25,400
flocks on top of th DB so this is a

00:04:23,389 --> 00:04:29,479
Prometheus metric and this is a prom

00:04:25,400 --> 00:04:31,820
flux metric so and this is how you

00:04:29,479 --> 00:04:34,699
select in Prometheus so you give that a

00:04:31,820 --> 00:04:36,289
name this essentially transforms to you

00:04:34,699 --> 00:04:38,720
adding a name key value pair and then

00:04:36,289 --> 00:04:40,520
selecting on the name just some basics

00:04:38,720 --> 00:04:42,740
so if you want to actually search by

00:04:40,520 --> 00:04:46,520
name and a selector you pass the name

00:04:42,740 --> 00:04:47,990
and the selector yep so this is

00:04:46,520 --> 00:04:49,430
simplified line protocol you have a name

00:04:47,990 --> 00:04:52,070
and a bunch of key value pairs and then

00:04:49,430 --> 00:04:55,849
the value field which essentially maps

00:04:52,070 --> 00:05:00,880
to this inside prompt flux or TS DB now

00:04:55,849 --> 00:05:00,880
let's get to the code I hope this works

00:05:01,180 --> 00:05:07,370
yeah this is the initial commit hello

00:05:07,070 --> 00:05:11,780
world

00:05:07,370 --> 00:05:15,979
okay can you see this now can you see

00:05:11,780 --> 00:05:18,080
this yeah okay sorry about that yep so

00:05:15,979 --> 00:05:19,909
hello world yeah I'm not really

00:05:18,080 --> 00:05:35,300
launching my startup it's secret

00:05:19,909 --> 00:05:36,919
but let's build it yep sorry yep so I

00:05:35,300 --> 00:05:38,990
were structured it into three parts

00:05:36,919 --> 00:05:40,340
creation of the database inserting data

00:05:38,990 --> 00:05:42,560
into the database and how you can query

00:05:40,340 --> 00:05:45,380
the database the creation part so this

00:05:42,560 --> 00:05:47,419
is how the API looks like so you have

00:05:45,380 --> 00:05:50,090
the open function which gives you the DB

00:05:47,419 --> 00:05:51,830
object and you pass the data directory

00:05:50,090 --> 00:05:53,930
which you want to create or is already

00:05:51,830 --> 00:05:56,270
there the logger we are good people we

00:05:53,930 --> 00:05:57,560
pass an explicit logger and the

00:05:56,270 --> 00:05:59,659
Prometheus registry where you want to

00:05:57,560 --> 00:06:01,580
register your matrix and the options so

00:05:59,659 --> 00:06:03,320
from Fabian stock we heard that we used

00:06:01,580 --> 00:06:04,250
to write a headlock how frequently do we

00:06:03,320 --> 00:06:06,530
want to flush that right right a

00:06:04,250 --> 00:06:07,820
headlock so if it's 10 seconds you flush

00:06:06,530 --> 00:06:09,200
the right headlock every 10 seconds

00:06:07,820 --> 00:06:11,539
which means you can lose 10 seconds of

00:06:09,200 --> 00:06:13,440
data if you set it to zero you always

00:06:11,539 --> 00:06:15,090
flush before you say the right is

00:06:13,440 --> 00:06:16,350
the retention duration the same

00:06:15,090 --> 00:06:18,660
Prometheus filtration duration how long

00:06:16,350 --> 00:06:20,729
do you want your data to be there and we

00:06:18,660 --> 00:06:23,039
know that we now from Fabian stock we

00:06:20,729 --> 00:06:29,210
know we compact the blocks what sizes of

00:06:23,039 --> 00:06:29,210
the blocks do we want so back to code

00:06:29,930 --> 00:06:41,759
scripts can you guys see this yep so TS

00:06:38,370 --> 00:06:43,410
DB dot open we pass the data path we

00:06:41,759 --> 00:06:44,610
pass is very simple longer we just blow

00:06:43,410 --> 00:06:47,820
up to stand out we pass a new

00:06:44,610 --> 00:06:49,530
Prometheus's history and the options so

00:06:47,820 --> 00:06:51,389
the we want to flush every 10 seconds

00:06:49,530 --> 00:06:52,979
which is the default in Prometheus we

00:06:51,389 --> 00:06:55,830
want to sort 15 days of data in

00:06:52,979 --> 00:06:57,810
milliseconds and then we want to our

00:06:55,830 --> 00:07:00,300
blocks then that have to be compacted to

00:06:57,810 --> 00:07:01,800
6 star blocks 24 hours and 72 us you

00:07:00,300 --> 00:07:04,500
don't need to explicitly mention this we

00:07:01,800 --> 00:07:07,289
have a helper for this and then you

00:07:04,500 --> 00:07:09,830
don't definitely panic you handle the

00:07:07,289 --> 00:07:13,740
error but back to the presentation

00:07:09,830 --> 00:07:16,560
inserting data so insertion works like

00:07:13,740 --> 00:07:18,870
this so you call an offender and you add

00:07:16,560 --> 00:07:20,729
all your data so basically you add

00:07:18,870 --> 00:07:21,120
series it's like suppose if Prometheus

00:07:20,729 --> 00:07:23,699
crêpes

00:07:21,120 --> 00:07:25,409
it says series 1 timestamp and value so

00:07:23,699 --> 00:07:26,190
you just add one by one and then you

00:07:25,409 --> 00:07:29,060
call commit

00:07:26,190 --> 00:07:32,460
so essentially oh one more caveat is

00:07:29,060 --> 00:07:34,400
here the samples of each series need to

00:07:32,460 --> 00:07:37,800
be ordered which means you can add 10 15

00:07:34,400 --> 00:07:39,240
20 but not 12 but you can add out of

00:07:37,800 --> 00:07:41,220
water in other series like series 2

00:07:39,240 --> 00:07:45,360
should have greater than 10 next time

00:07:41,220 --> 00:07:46,919
you add it so yeah it has to be ordered

00:07:45,360 --> 00:07:50,490
which is why I'm not happy with Tom

00:07:46,919 --> 00:07:52,979
removing ordering in remote storage but

00:07:50,490 --> 00:07:55,110
anyways this is how it works so we have

00:07:52,979 --> 00:07:57,690
our data and then we create our appender

00:07:55,110 --> 00:08:00,570
we slowly add one by one all our metrics

00:07:57,690 --> 00:08:02,880
and then once we call commit this gets

00:08:00,570 --> 00:08:04,440
added notice there are two steps this is

00:08:02,880 --> 00:08:06,900
not atomic and Brian will be talking

00:08:04,440 --> 00:08:11,039
about it and boom we have our data

00:08:06,900 --> 00:08:13,860
inside th DB before we jump into the

00:08:11,039 --> 00:08:15,449
code some utilities so I wrote a

00:08:13,860 --> 00:08:18,030
function that converts line to matrix

00:08:15,449 --> 00:08:19,500
and a matrix metric is again all the

00:08:18,030 --> 00:08:24,710
labels and the timestamp and the value

00:08:19,500 --> 00:08:24,710
and now code

00:08:31,820 --> 00:08:36,810
so we have the same thing but we have an

00:08:34,740 --> 00:08:39,960
insert handler here now what is the

00:08:36,810 --> 00:08:43,890
insert handler do it reads the body it

00:08:39,960 --> 00:08:49,260
converts the line matrix to the psdb

00:08:43,890 --> 00:08:51,420
matrix then this is the add logic so we

00:08:49,260 --> 00:08:52,920
have we create a map ender we are called

00:08:51,420 --> 00:08:55,290
the data to the defender and finally we

00:08:52,920 --> 00:08:57,420
call commit you might see that there's

00:08:55,290 --> 00:09:00,510
also an add first function here

00:08:57,420 --> 00:09:03,060
so how dsdp does add yes so when you

00:09:00,510 --> 00:09:04,860
pass it all the labels it does a hash of

00:09:03,060 --> 00:09:07,320
it it gets the series ID it goes to the

00:09:04,860 --> 00:09:09,030
series ID and then adds data now this is

00:09:07,320 --> 00:09:10,860
C computationally intensive you are

00:09:09,030 --> 00:09:12,270
hashing every series if you are if you

00:09:10,860 --> 00:09:15,720
are like millions of samples you have to

00:09:12,270 --> 00:09:17,490
hash millions of times a second and that

00:09:15,720 --> 00:09:19,890
can be avoided if you can somehow cache

00:09:17,490 --> 00:09:25,400
it and this is how kind of Prometheus

00:09:19,890 --> 00:09:25,400
2.0 reduced its CPU by having a cache

00:09:25,760 --> 00:09:29,580
instead of just passing the series you

00:09:27,990 --> 00:09:30,690
pass the reference and how do you get

00:09:29,580 --> 00:09:32,990
the reference to pass the series the

00:09:30,690 --> 00:09:39,420
first time then you store the reference

00:09:32,990 --> 00:09:40,380
and okay now you insert a data now it

00:09:39,420 --> 00:09:43,620
comes the best part

00:09:40,380 --> 00:09:45,840
how do we query using prompt QL so first

00:09:43,620 --> 00:09:47,610
we have a bunch of series and we have a

00:09:45,840 --> 00:09:49,350
prompt Kuehl expression but what is a

00:09:47,610 --> 00:09:50,790
prompt q expression expression it's a

00:09:49,350 --> 00:09:52,950
neighbor name and a constraint on the

00:09:50,790 --> 00:09:55,680
label value how do we actually put it

00:09:52,950 --> 00:09:57,900
into code we have so basically we have

00:09:55,680 --> 00:09:59,610
like we need a equal matcher or like a

00:09:57,900 --> 00:10:02,250
regular expression match or prefix match

00:09:59,610 --> 00:10:04,590
how do we actually Express this we use

00:10:02,250 --> 00:10:06,990
golang interfaces so we have a matcher

00:10:04,590 --> 00:10:08,700
interface that returns the neighbor name

00:10:06,990 --> 00:10:11,490
and if the label value matches a certain

00:10:08,700 --> 00:10:13,050
constraint so if you actually give this

00:10:11,490 --> 00:10:15,170
to the database it is a database table

00:10:13,050 --> 00:10:18,660
job to give you all the cities that

00:10:15,170 --> 00:10:20,400
satisfy this match up for example the

00:10:18,660 --> 00:10:23,490
equal matcher name equal to Prometheus

00:10:20,400 --> 00:10:24,930
you just create an equal matcher and it

00:10:23,490 --> 00:10:28,140
will actually give you all the theories

00:10:24,930 --> 00:10:30,450
that have name which is Prometheus the

00:10:28,140 --> 00:10:33,390
regular expression match up name from

00:10:30,450 --> 00:10:35,040
dot star so these are just examples of

00:10:33,390 --> 00:10:36,660
match up but the essential thing is you

00:10:35,040 --> 00:10:38,670
have a bunch of matches and you pass it

00:10:36,660 --> 00:10:40,200
down to the database in this format

00:10:38,670 --> 00:10:43,950
all the matches that you want to satisfy

00:10:40,200 --> 00:10:46,080
and you get a city set going back we

00:10:43,950 --> 00:10:47,940
have a bunch of series how do we read

00:10:46,080 --> 00:10:49,410
them as I said you might have a billion

00:10:47,940 --> 00:10:51,510
points you might have ten billion points

00:10:49,410 --> 00:10:53,190
which means essentially your query could

00:10:51,510 --> 00:10:54,630
get written you gigabytes of data you

00:10:53,190 --> 00:10:56,850
don't want to read all of it into memory

00:10:54,630 --> 00:10:58,770
and then give it to the reader so you

00:10:56,850 --> 00:11:00,570
want to do it iteratively like read all

00:10:58,770 --> 00:11:02,940
the date of series one then read out the

00:11:00,570 --> 00:11:04,620
night of series two and so on but series

00:11:02,940 --> 00:11:06,780
one in itself can have hundreds of

00:11:04,620 --> 00:11:08,250
embiez of data you don't want to read

00:11:06,780 --> 00:11:09,600
all of that into memory either so you

00:11:08,250 --> 00:11:11,610
want to also iterate through the values

00:11:09,600 --> 00:11:12,960
so essentially this is what you want to

00:11:11,610 --> 00:11:16,200
do go to see this one iterate through

00:11:12,960 --> 00:11:18,150
the values and so on so this is what the

00:11:16,200 --> 00:11:20,520
code is going to look like slightly

00:11:18,150 --> 00:11:22,260
involved so you call the query a

00:11:20,520 --> 00:11:23,460
function with the mean time and Max time

00:11:22,260 --> 00:11:25,290
you don't want to query all of history

00:11:23,460 --> 00:11:29,250
you just want to create query from min

00:11:25,290 --> 00:11:31,200
time and Max time and then you pass down

00:11:29,250 --> 00:11:33,750
all the matches and you get a series set

00:11:31,200 --> 00:11:35,700
what is a series set a series set is

00:11:33,750 --> 00:11:38,190
next at and ever this is the iterator

00:11:35,700 --> 00:11:40,710
pattern so ad will give you the current

00:11:38,190 --> 00:11:42,330
series the first one and next will move

00:11:40,710 --> 00:11:43,890
you to the next series and the movement

00:11:42,330 --> 00:11:48,330
next return false you are at the end of

00:11:43,890 --> 00:11:49,890
your series then what is a series a

00:11:48,330 --> 00:11:53,640
series is the labels and the iterator

00:11:49,890 --> 00:11:55,770
you used to read the values an iterator

00:11:53,640 --> 00:11:57,750
again looks like the same there's at and

00:11:55,770 --> 00:12:00,060
there's a next and so when you call at

00:11:57,750 --> 00:12:02,250
you get the current timestamp in value

00:12:00,060 --> 00:12:04,650
and when you call next you move to the

00:12:02,250 --> 00:12:05,880
next value so on until you reach the end

00:12:04,650 --> 00:12:08,730
until next returns false

00:12:05,880 --> 00:12:10,710
a couple more utilities prompt ql2

00:12:08,730 --> 00:12:12,990
matches you give the prompt expression

00:12:10,710 --> 00:12:15,240
and then you get the match out and then

00:12:12,990 --> 00:12:18,000
we are going to return all the points

00:12:15,240 --> 00:12:20,700
that match the query which is it is a

00:12:18,000 --> 00:12:23,370
series of series or which is a slice of

00:12:20,700 --> 00:12:28,100
series and series is again labels and

00:12:23,370 --> 00:12:28,100
points so the final code

00:12:39,180 --> 00:12:44,350
yep you have your database and then you

00:12:42,070 --> 00:12:46,390
have the insert query me insert Handler

00:12:44,350 --> 00:12:48,270
and now you have the query handler let's

00:12:46,390 --> 00:12:51,220
look at how the query handler looks like

00:12:48,270 --> 00:12:52,950
yep so before that this is how the query

00:12:51,220 --> 00:12:55,660
will come like we are actually expecting

00:12:52,950 --> 00:12:57,970
post-post data which is like you ask you

00:12:55,660 --> 00:13:01,690
send the prompt QL the mean time and Max

00:12:57,970 --> 00:13:06,070
time response is a bunch of series and

00:13:01,690 --> 00:13:07,780
series of just labels and points so you

00:13:06,070 --> 00:13:09,520
essentially decode the query you get or

00:13:07,780 --> 00:13:12,730
you get the query object from the post

00:13:09,520 --> 00:13:15,160
body and now here comes the code so you

00:13:12,730 --> 00:13:19,270
want to have all the match series you

00:13:15,160 --> 00:13:23,020
create your courier you get your matches

00:13:19,270 --> 00:13:27,670
and then you call select and get your

00:13:23,020 --> 00:13:30,670
series set now for each series for each

00:13:27,670 --> 00:13:32,860
series in the series set you get the

00:13:30,670 --> 00:13:34,570
current series you get its labels and

00:13:32,860 --> 00:13:36,460
you get all the points from the iterator

00:13:34,570 --> 00:13:39,480
and then add it to the map series and

00:13:36,460 --> 00:13:43,660
finally you return the series any

00:13:39,480 --> 00:13:52,200
questions until here ok did I lose you

00:13:43,660 --> 00:13:52,200
guys oops ok sorry for the bunch of code

00:13:52,440 --> 00:13:58,840
anyways so basically it's quite simple

00:13:56,110 --> 00:14:00,160
so this is in three parts again the

00:13:58,840 --> 00:14:02,140
creation of the database which is pretty

00:14:00,160 --> 00:14:03,430
easy inserting data you create an

00:14:02,140 --> 00:14:05,680
offender you add all the data and you

00:14:03,430 --> 00:14:07,210
create you say commit and querying yes

00:14:05,680 --> 00:14:08,350
you get the series set and then go

00:14:07,210 --> 00:14:14,050
through each series and get all the

00:14:08,350 --> 00:14:15,550
values and now for the demo I'm deleting

00:14:14,050 --> 00:14:26,560
the data directory to that create a new

00:14:15,550 --> 00:14:29,080
directory and yeah so this is the line

00:14:26,560 --> 00:14:30,640
protocol data and you send a post

00:14:29,080 --> 00:14:32,740
request you just push the data to

00:14:30,640 --> 00:14:35,860
Prometheus and it will mean prom flux

00:14:32,740 --> 00:14:38,380
and it'll return success and then you do

00:14:35,860 --> 00:14:41,320
your prom ql query which says i want all

00:14:38,380 --> 00:14:43,510
the values which match name equal to

00:14:41,320 --> 00:14:45,390
whether and minty mean time and match

00:14:43,510 --> 00:14:49,310
time is basically essentially infinity

00:14:45,390 --> 00:14:52,680
and you get all your series

00:14:49,310 --> 00:14:55,110
okay all your series and each series so

00:14:52,680 --> 00:15:06,000
I inserted four series so there should

00:14:55,110 --> 00:15:08,190
be four in the answer oops anyways this

00:15:06,000 --> 00:15:10,530
is a simple query now we want to use the

00:15:08,190 --> 00:15:12,120
full reg X matching so you can

00:15:10,530 --> 00:15:14,970
essentially ask for everything that

00:15:12,120 --> 00:15:26,850
matches location that looks like US mint

00:15:14,970 --> 00:15:29,280
dot star yep so there are two series

00:15:26,850 --> 00:15:35,820
that match it and all the values that

00:15:29,280 --> 00:15:37,860
match up I think I am quite early oops

00:15:35,820 --> 00:15:39,270
but any questions here anywhere that I

00:15:37,860 --> 00:15:48,600
lost you guys that I can go back to

00:15:39,270 --> 00:15:52,200
because I have enough time yep thanks so

00:15:48,600 --> 00:15:58,080
please show the code when you calculate

00:15:52,200 --> 00:16:00,440
ranges so with so mean and Max how the

00:15:58,080 --> 00:16:03,720
code looks like when you use this

00:16:00,440 --> 00:16:06,990
parameters oh so it's quite simple so

00:16:03,720 --> 00:16:10,860
when you create the courier you actually

00:16:06,990 --> 00:16:13,770
pass in the mean time in max time yeah

00:16:10,860 --> 00:16:15,750
you actually don't do any of the merging

00:16:13,770 --> 00:16:24,570
the database internally does the merging

00:16:15,750 --> 00:16:26,910
for you any other questions is your

00:16:24,570 --> 00:16:28,650
example code online somewhere so we can

00:16:26,910 --> 00:16:38,100
use that for I will push it along with

00:16:28,650 --> 00:16:40,590
my slides that would be awesome thank

00:16:38,100 --> 00:16:43,220
you for the talk very interesting how

00:16:40,590 --> 00:16:45,570
when I went to integrate tears to be

00:16:43,220 --> 00:16:49,470
what are the requirements when I want to

00:16:45,570 --> 00:16:54,930
close it cleanly in the next things I

00:16:49,470 --> 00:16:57,540
need to do so okay like a good question

00:16:54,930 --> 00:16:59,220
basically you just need to exit because

00:16:57,540 --> 00:17:00,720
you have a write a head lock if you

00:16:59,220 --> 00:17:01,700
don't want to lose any data use you

00:17:00,720 --> 00:17:04,040
could right

00:17:01,700 --> 00:17:06,800
flush interval to zero you won't lose

00:17:04,040 --> 00:17:08,660
anything but if you actually exit in the

00:17:06,800 --> 00:17:10,819
middle you panic or somehow you still

00:17:08,660 --> 00:17:13,939
lose the ten ten seconds of data but

00:17:10,819 --> 00:17:16,160
that's the max you lose so all the

00:17:13,939 --> 00:17:18,140
blocks are like all the positional

00:17:16,160 --> 00:17:19,250
clocks are never modified and the

00:17:18,140 --> 00:17:20,870
valleys just append-only

00:17:19,250 --> 00:17:22,970
and if there is some corruption we

00:17:20,870 --> 00:17:27,620
actually can truncate the rest of the

00:17:22,970 --> 00:17:32,480
values so your data is safe so you can

00:17:27,620 --> 00:17:34,010
exit happily hello so what exactly the

00:17:32,480 --> 00:17:38,150
database so you can you have multiple

00:17:34,010 --> 00:17:40,010
databases also so no so it's actually

00:17:38,150 --> 00:17:42,740
one database and you put all your series

00:17:40,010 --> 00:17:44,600
in it and it doesn't really matter for

00:17:42,740 --> 00:17:46,880
you to charge the databases because you

00:17:44,600 --> 00:17:49,460
can get arbitrary arbitrarily wide you

00:17:46,880 --> 00:17:50,780
know like in one database but if you

00:17:49,460 --> 00:17:52,220
actually want to do it just pass in

00:17:50,780 --> 00:17:54,200
another folder those would be two

00:17:52,220 --> 00:17:56,720
independent databases so you mean here

00:17:54,200 --> 00:17:58,250
the folder is it actually a database yes

00:17:56,720 --> 00:18:00,800
the folder will have all the all the

00:17:58,250 --> 00:18:03,290
data for the database but at any at any

00:18:00,800 --> 00:18:05,360
movement or at runtime only it supports

00:18:03,290 --> 00:18:07,420
single database right you can create two

00:18:05,360 --> 00:18:08,570
DB objects for the two different folders

00:18:07,420 --> 00:18:10,370
okay

00:18:08,570 --> 00:18:12,290
and then you you insert into whichever

00:18:10,370 --> 00:18:14,660
you want that's fine but whenever I'm

00:18:12,290 --> 00:18:18,320
querying the data I will not say which

00:18:14,660 --> 00:18:19,880
database right so yep so there's no way

00:18:18,320 --> 00:18:22,460
you can join the data so these are two

00:18:19,880 --> 00:18:24,620
independent databases that's why still

00:18:22,460 --> 00:18:26,900
my question is while querying

00:18:24,620 --> 00:18:30,170
I cannot specify the database I always

00:18:26,900 --> 00:18:32,330
talk to the default database right so

00:18:30,170 --> 00:18:34,970
what what's the rationale in that case

00:18:32,330 --> 00:18:38,510
to have two folder or having two

00:18:34,970 --> 00:18:40,190
databases yeah so you if you want to

00:18:38,510 --> 00:18:41,450
have multiple users and you don't want

00:18:40,190 --> 00:18:43,820
to mix their data you can have two

00:18:41,450 --> 00:18:47,720
databases for each user that's good and

00:18:43,820 --> 00:18:50,570
whatever the database you created so it

00:18:47,720 --> 00:18:52,520
supports HTTP interface or we need to

00:18:50,570 --> 00:18:56,300
code like the code which you demonstrate

00:18:52,520 --> 00:18:59,240
it you actually adding a rest layer or a

00:18:56,300 --> 00:19:00,620
patter to say HTTP layer yes on top of

00:18:59,240 --> 00:19:03,740
that you are adding up the two loads

00:19:00,620 --> 00:19:05,840
right yes so whenever we deploy this so

00:19:03,740 --> 00:19:08,450
we need to deploy this code or but

00:19:05,840 --> 00:19:10,250
whenever we yes so the use case for this

00:19:08,450 --> 00:19:13,190
is so you have some application and you

00:19:10,250 --> 00:19:14,149
want to actually you write and read time

00:19:13,190 --> 00:19:16,279
series data

00:19:14,149 --> 00:19:18,409
so you use this to write and read but

00:19:16,279 --> 00:19:20,029
you deploy your application here from

00:19:18,409 --> 00:19:25,459
flux is the example application just

00:19:20,029 --> 00:19:28,609
don't deploy it okay thanks yeah hi a

00:19:25,459 --> 00:19:29,389
question about the API that we see no on

00:19:28,609 --> 00:19:32,089
the screen

00:19:29,389 --> 00:19:34,669
yes it's something specific to your TSP

00:19:32,089 --> 00:19:37,459
beam layer or is it the same API that

00:19:34,669 --> 00:19:39,469
Prometheus uses internally yes this is

00:19:37,459 --> 00:19:41,899
the same this is the RTS DB API layer

00:19:39,469 --> 00:19:44,119
which is Prometheus uses so Prometheus

00:19:41,899 --> 00:19:50,829
vendors TS DB and then uses this okay

00:19:44,119 --> 00:19:55,249
thank you hi here is possible to resolve

00:19:50,829 --> 00:20:00,229
labels into low level serious IDs and

00:19:55,249 --> 00:20:03,259
use that IDs to select data because I

00:20:00,229 --> 00:20:10,339
think resolving labels it's quite quite

00:20:03,259 --> 00:20:22,789
expensive good question but whoops sorry

00:20:10,339 --> 00:20:25,219
about that okay yeah so the thing is you

00:20:22,789 --> 00:20:27,289
actually want to have the series IDs

00:20:25,219 --> 00:20:30,049
exposed so that you can query faster yes

00:20:27,289 --> 00:20:31,969
but if you actually look at prom QL or

00:20:30,049 --> 00:20:34,609
the use case you actually pass the

00:20:31,969 --> 00:20:37,069
matches if you already so somehow you

00:20:34,609 --> 00:20:40,099
will on the on the client side you will

00:20:37,069 --> 00:20:41,959
maintain the mapping that is not

00:20:40,099 --> 00:20:44,209
currently exposed and I don't think that

00:20:41,959 --> 00:20:47,029
will be exposed as the API but what if I

00:20:44,209 --> 00:20:51,639
want to build some analytics maybe it's

00:20:47,029 --> 00:20:55,969
not quite good example for this but I

00:20:51,639 --> 00:21:00,879
want to resolve all my time series and I

00:20:55,969 --> 00:21:05,329
just want to exact data up quite

00:21:00,879 --> 00:21:08,139
frequently for exam yep I get it

00:21:05,329 --> 00:21:10,969
yeah there could be a direct fast path

00:21:08,139 --> 00:21:13,369
access which could be enabled but I'm

00:21:10,969 --> 00:21:18,499
not sure it will be okay thank you

00:21:13,369 --> 00:21:21,789
and what about becomes so can I

00:21:18,499 --> 00:21:24,820
automatically pick up all database

00:21:21,789 --> 00:21:26,229
or take a snapshot yes so there is

00:21:24,820 --> 00:21:28,809
another function that I did not cover in

00:21:26,229 --> 00:21:31,929
this talk so Prometheus uses that so

00:21:28,809 --> 00:21:34,269
Prometheus 2.0 beta 2 as an API endpoint

00:21:31,929 --> 00:21:36,850
which you hit and that actually calls DB

00:21:34,269 --> 00:21:39,309
dot snapshot and that stretches it out

00:21:36,850 --> 00:21:45,419
to a directory so the functionality is

00:21:39,309 --> 00:21:45,419
there thank you any more questions

00:21:48,680 --> 00:22:01,560
[Music]

00:22:01,389 --> 00:22:04,700
you

00:22:01,560 --> 00:22:04,700

YouTube URL: https://www.youtube.com/watch?v=AYnXeMGAZes


