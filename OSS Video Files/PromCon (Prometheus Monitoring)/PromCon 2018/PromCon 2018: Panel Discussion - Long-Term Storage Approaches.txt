Title: PromCon 2018: Panel Discussion - Long-Term Storage Approaches
Publication date: 2018-11-10
Playlist: PromCon 2018
Description: 
	Panel Discussion: Prometheus Long-Term Storage Approaches
In this panel, we will explore some of the emerging and competing approaches to Prometheus scalable long-term storage.

Speakers:

Julius Volz (moderator)
Fabian Reinartz, Thanos
Nikunj Aggarwal, M3DB
Paul Dix, InfluxDB
Tom Wilkie, Cortex
Captions: 
	00:00:10,250 --> 00:00:16,980
so quiet thank you

00:00:14,970 --> 00:00:18,600
so the next thing actually is like

00:00:16,980 --> 00:00:20,970
really dear in new to my heart because I

00:00:18,600 --> 00:00:22,260
have been borrowing people for ages that

00:00:20,970 --> 00:00:30,240
we should have panel discussions and

00:00:22,260 --> 00:00:32,580
there's as a panel discussion so today's

00:00:30,240 --> 00:00:34,260
panel will be about long-term storage we

00:00:32,580 --> 00:00:36,600
have Fabian representing tennis we have

00:00:34,260 --> 00:00:37,710
tom representing cortex we have Julius

00:00:36,600 --> 00:00:39,720
doing the moderation we have good

00:00:37,710 --> 00:00:42,120
Nichkhun should be representing m3/d by

00:00:39,720 --> 00:00:43,850
uber and we have Paul from in flux thank

00:00:42,120 --> 00:00:49,140
you very much

00:00:43,850 --> 00:00:52,290
0g thank you thought I was going to do

00:00:49,140 --> 00:00:53,790
the intros yep this is us you might be

00:00:52,290 --> 00:00:55,640
wondering how did we get into this

00:00:53,790 --> 00:00:59,909
situation

00:00:55,640 --> 00:01:03,000
so I'm joyous one of the initial like

00:00:59,909 --> 00:01:05,489
authors of Prometheus so I'll give some

00:01:03,000 --> 00:01:06,570
context about you know the history of

00:01:05,489 --> 00:01:08,520
storage

00:01:06,570 --> 00:01:10,650
Richie already introduced the others

00:01:08,520 --> 00:01:13,189
we'll get more details about their

00:01:10,650 --> 00:01:16,670
long-term storage approaches later on

00:01:13,189 --> 00:01:19,289
and basically you know the goal of the

00:01:16,670 --> 00:01:22,079
whole panel is to give people a bit of

00:01:19,289 --> 00:01:24,329
an idea of why do all these different

00:01:22,079 --> 00:01:26,070
storage solutions exist what are the

00:01:24,329 --> 00:01:29,670
differences between them which one might

00:01:26,070 --> 00:01:31,619
be the right one for you and yeah

00:01:29,670 --> 00:01:33,180
so let me start off by saying you know

00:01:31,619 --> 00:01:37,680
when we initially created promises at

00:01:33,180 --> 00:01:39,780
SoundCloud we didn't initially care so

00:01:37,680 --> 00:01:43,500
much about long-term storage we needed a

00:01:39,780 --> 00:01:47,009
tool to give us actionable alerts right

00:01:43,500 --> 00:01:48,960
now and maybe you know make it all so

00:01:47,009 --> 00:01:51,899
easy to make them highly available just

00:01:48,960 --> 00:01:53,429
by running - and it's nice thing that

00:01:51,899 --> 00:01:55,499
there's also some data that you can

00:01:53,429 --> 00:01:57,270
query nicely but we didn't care so much

00:01:55,499 --> 00:01:59,429
about you know keeping data for years

00:01:57,270 --> 00:02:01,140
and you know having gazillions of time

00:01:59,429 --> 00:02:02,369
series or you know just split up your

00:02:01,140 --> 00:02:05,490
primitive servers but then there were

00:02:02,369 --> 00:02:09,179
actual other users and they had all

00:02:05,490 --> 00:02:11,790
kinds of other different requirements so

00:02:09,179 --> 00:02:13,860
in the end we still said well we want to

00:02:11,790 --> 00:02:15,420
keep the primitive server itself simple

00:02:13,860 --> 00:02:18,740
because you know building a big

00:02:15,420 --> 00:02:22,320
clustered system with possibly consensus

00:02:18,740 --> 00:02:23,550
algorithms and so on that would be a bit

00:02:22,320 --> 00:02:25,680
of an antithesis to

00:02:23,550 --> 00:02:28,770
Prometheus which we want to keep simple

00:02:25,680 --> 00:02:32,430
and want to have a focus on the right

00:02:28,770 --> 00:02:35,120
now alerting and monitoring but we

00:02:32,430 --> 00:02:36,960
wanted to enable other people to build

00:02:35,120 --> 00:02:38,820
long-term storage

00:02:36,960 --> 00:02:40,020
use cases or even just you know even if

00:02:38,820 --> 00:02:42,180
you're not storing them maybe you want

00:02:40,020 --> 00:02:43,620
to ship every sample somewhere else and

00:02:42,180 --> 00:02:46,380
do something with it

00:02:43,620 --> 00:02:49,020
so we built a set of generic interfaces

00:02:46,380 --> 00:02:51,000
which is called the generic remote read

00:02:49,020 --> 00:02:53,550
and remote write interfaces where you

00:02:51,000 --> 00:02:55,920
can configure Prometheus to basically

00:02:53,550 --> 00:02:58,080
send on every sample that it scrapes to

00:02:55,920 --> 00:02:59,700
some remote URL endpoint and that could

00:02:58,080 --> 00:03:02,340
be a storage could be a stream process

00:02:59,700 --> 00:03:04,740
or whatever and for the reading the same

00:03:02,340 --> 00:03:06,420
thing you can point Prometheus to a

00:03:04,740 --> 00:03:08,850
remote end point where it can request

00:03:06,420 --> 00:03:11,640
samples based on a set of label mattress

00:03:08,850 --> 00:03:16,920
and the querying the prom QL still

00:03:11,640 --> 00:03:19,590
happens within Prometheus now I think in

00:03:16,920 --> 00:03:22,530
kind of Wow yeah in some of the

00:03:19,590 --> 00:03:24,180
solutions here they are basically really

00:03:22,530 --> 00:03:24,960
based on this remote write and read

00:03:24,180 --> 00:03:26,610
interface

00:03:24,960 --> 00:03:28,880
I think Fanus is probably the most

00:03:26,610 --> 00:03:32,510
different one will we hear about that

00:03:28,880 --> 00:03:34,980
but yeah so maybe my first question to

00:03:32,510 --> 00:03:36,930
actually the audience is who is already

00:03:34,980 --> 00:03:41,160
using some kind of remote storage

00:03:36,930 --> 00:03:43,770
solution with Prometheus that looks like

00:03:41,160 --> 00:03:46,050
man like v maybe I don't know something

00:03:43,770 --> 00:03:48,989
like this who really who isn't yet but

00:03:46,050 --> 00:03:50,370
really wants one but just isn't hasn't

00:03:48,989 --> 00:03:52,110
tried or isn't happy yet with the

00:03:50,370 --> 00:03:54,560
existing ones okay that's actually the

00:03:52,110 --> 00:03:59,760
same amount of people okay let's see

00:03:54,560 --> 00:04:01,709
yeah why is everyone else here okay so

00:03:59,760 --> 00:04:04,830
maybe my first question to each of the

00:04:01,709 --> 00:04:08,850
panelists would be like why does your

00:04:04,830 --> 00:04:10,770
solution exist and what like what what

00:04:08,850 --> 00:04:13,050
are the prime use cases that it solves I

00:04:10,770 --> 00:04:14,610
mean maybe you know Thanos you can keep

00:04:13,050 --> 00:04:17,250
it short because of course we just had

00:04:14,610 --> 00:04:18,810
the big talk but yeah yeah I guess the

00:04:17,250 --> 00:04:20,430
main goal was to sent us to actually

00:04:18,810 --> 00:04:22,860
keep the operation simplicity of

00:04:20,430 --> 00:04:25,250
Prometheus so basically assuming that

00:04:22,860 --> 00:04:27,480
people don't really one of the others

00:04:25,250 --> 00:04:29,190
operating a monitoring system they just

00:04:27,480 --> 00:04:31,080
want to get the value out of it so

00:04:29,190 --> 00:04:33,390
what's like the minimum solution we can

00:04:31,080 --> 00:04:35,280
get to give people all the sort of

00:04:33,390 --> 00:04:37,700
missing features that without adding any

00:04:35,280 --> 00:04:37,700
more headache

00:04:39,900 --> 00:04:44,310
so I wrote I'm representing cortex here

00:04:41,909 --> 00:04:45,569
which is a project we started two and a

00:04:44,310 --> 00:04:48,330
half years ago I think now who was at

00:04:45,569 --> 00:04:50,129
last year's prom calm okay so you all

00:04:48,330 --> 00:04:51,810
saw the cortex talk for those who didn't

00:04:50,129 --> 00:04:54,659
there's some excellent videos out there

00:04:51,810 --> 00:04:57,090
the main aim for cortex was to as a

00:04:54,659 --> 00:04:59,849
service provider offer hosted Prometheus

00:04:57,090 --> 00:05:02,490
so we wanted to offload the long-term

00:04:59,849 --> 00:05:04,379
storage for your Prometheus to to us

00:05:02,490 --> 00:05:06,199
basically and then obviously charging

00:05:04,379 --> 00:05:08,340
money for it

00:05:06,199 --> 00:05:10,740
we did this as an open source project

00:05:08,340 --> 00:05:12,389
though so you can run your own and we're

00:05:10,740 --> 00:05:13,590
kind of pleasantly surprised when a

00:05:12,389 --> 00:05:17,430
whole bunch of people start running

00:05:13,590 --> 00:05:18,810
their own and so there's now I don't

00:05:17,430 --> 00:05:20,909
know maybe four or five people you can

00:05:18,810 --> 00:05:22,529
go and buy a cortex instance off of and

00:05:20,909 --> 00:05:25,349
the same again people who run it

00:05:22,529 --> 00:05:27,240
internally inside their own organization

00:05:25,349 --> 00:05:28,830
for long term storage but yeah for us it

00:05:27,240 --> 00:05:34,139
was mainly long-term storage we built it

00:05:28,830 --> 00:05:37,199
for so I'm representing uber so at uber

00:05:34,139 --> 00:05:39,479
we have a lot of metrics so the kind of

00:05:37,199 --> 00:05:42,389
scale I'm talking about is so I recently

00:05:39,479 --> 00:05:45,629
took some numbers so we do about 400

00:05:42,389 --> 00:05:48,029
million raw samples every second so

00:05:45,629 --> 00:05:49,259
that's like kind of our scale and so we

00:05:48,029 --> 00:05:51,779
wanted something which is extremely

00:05:49,259 --> 00:05:53,370
reliable and extremely performant so a

00:05:51,779 --> 00:05:55,620
lot of people talked about how

00:05:53,370 --> 00:05:57,750
system metrics are important and they

00:05:55,620 --> 00:05:59,639
are at uber as well so you want to know

00:05:57,750 --> 00:06:02,339
how well your service is doing in terms

00:05:59,639 --> 00:06:04,529
of latency you know it is any host down

00:06:02,339 --> 00:06:06,569
or things like that but we also have a

00:06:04,529 --> 00:06:09,509
lot of business metrics and what you've

00:06:06,569 --> 00:06:11,339
seen at uber is a lot of products have

00:06:09,509 --> 00:06:13,529
actually come up using our metrics

00:06:11,339 --> 00:06:16,199
platform with an uber so there's a

00:06:13,529 --> 00:06:17,939
product which actually looks at number

00:06:16,199 --> 00:06:20,099
of trips happening in every region and

00:06:17,939 --> 00:06:21,629
you use that to forecast how many crops

00:06:20,099 --> 00:06:23,849
are going to happen next week things

00:06:21,629 --> 00:06:25,919
like that so we needed a system which is

00:06:23,849 --> 00:06:29,069
extremely performant actually reliable

00:06:25,919 --> 00:06:35,279
which can work for longer-term metrics

00:06:29,069 --> 00:06:39,089
as well and that's why we build n3 so

00:06:35,279 --> 00:06:41,969
I'm representing influx so initially the

00:06:39,089 --> 00:06:44,490
long term stories influx is support for

00:06:41,969 --> 00:06:46,500
long-term storage started with this

00:06:44,490 --> 00:06:48,870
conference last year I gave a talk about

00:06:46,500 --> 00:06:50,999
the integration stuff of integrating

00:06:48,870 --> 00:06:52,469
Prometheus an influx DB and

00:06:50,999 --> 00:06:54,479
I wasn't presenting any code that we had

00:06:52,469 --> 00:06:58,769
written but code that Julius had written

00:06:54,479 --> 00:07:01,649
about pairing he basically created like

00:06:58,769 --> 00:07:03,929
a long-term storage gateway to influx

00:07:01,649 --> 00:07:06,449
and the reception at this conference was

00:07:03,929 --> 00:07:08,099
so good that we decided to actually add

00:07:06,449 --> 00:07:11,219
first-class support to the database to

00:07:08,099 --> 00:07:12,809
that so now in flux TB supports both in

00:07:11,219 --> 00:07:15,899
the open source and in our commercial

00:07:12,809 --> 00:07:21,269
stuff the remote read and remote right

00:07:15,899 --> 00:07:23,699
endpoints yeah yeah and I believe yours

00:07:21,269 --> 00:07:26,069
M 3 DB does as well right remote read

00:07:23,699 --> 00:07:27,929
and remote right yeah that's great oh

00:07:26,069 --> 00:07:35,399
I've missed that but I guess six also

00:07:27,929 --> 00:07:37,349
does thanos is its own beast yeah I was

00:07:35,399 --> 00:07:41,189
wondering so we have some of these

00:07:37,349 --> 00:07:44,669
solutions which go for this horizontally

00:07:41,189 --> 00:07:46,889
scalable clustered approach I think in

00:07:44,669 --> 00:07:49,229
flux DB M 3 DB cortex are all

00:07:46,889 --> 00:07:52,139
representative of that Pano's takes a

00:07:49,229 --> 00:07:54,449
really different approach of going like

00:07:52,139 --> 00:07:57,869
oh yeah you keep your Prometheus set up

00:07:54,449 --> 00:07:59,489
as it is and you just add little side

00:07:57,869 --> 00:08:02,639
cards everywhere and then you kind of

00:07:59,489 --> 00:08:04,829
you know ton of scales together with

00:08:02,639 --> 00:08:06,949
Prometheus but that has upsides and the

00:08:04,829 --> 00:08:11,669
downsides of Prometheus

00:08:06,949 --> 00:08:15,889
what do the yeah I wonder what my

00:08:11,669 --> 00:08:20,549
question really is leading the witness

00:08:15,889 --> 00:08:25,829
no I was wondering like what you think

00:08:20,549 --> 00:08:27,959
let's say for example Paul about the

00:08:25,829 --> 00:08:31,550
trade-off between having or actually no

00:08:27,959 --> 00:08:34,039
Tom because tom was the the original

00:08:31,550 --> 00:08:36,269
cortex was the first big you know

00:08:34,039 --> 00:08:38,129
long-term storage for Prometheus which

00:08:36,269 --> 00:08:40,019
took this completely different set of

00:08:38,129 --> 00:08:41,639
trade-offs where you say well we're

00:08:40,019 --> 00:08:44,129
going to build a big clustered system

00:08:41,639 --> 00:08:47,670
instead of many little in the individual

00:08:44,129 --> 00:08:50,160
independent nodes that don't have to

00:08:47,670 --> 00:08:51,720
coordinate tightly with each other yeah

00:08:50,160 --> 00:08:54,660
so from my point of view that

00:08:51,720 --> 00:08:57,629
fundamental trade-off was we needed a

00:08:54,660 --> 00:08:59,610
product that when people pointed their

00:08:57,629 --> 00:09:01,649
data at it they would instantly see

00:08:59,610 --> 00:09:03,839
their data in the hosted platform you

00:09:01,649 --> 00:09:04,750
know it's not particularly acceptable to

00:09:03,839 --> 00:09:06,040
a

00:09:04,750 --> 00:09:07,630
you know a service provider if it's like

00:09:06,040 --> 00:09:10,780
oh just wait two hours for a block to

00:09:07,630 --> 00:09:11,920
upload for instance with Thanos and that

00:09:10,780 --> 00:09:13,900
I thinks the big difference right we

00:09:11,920 --> 00:09:15,790
were aimed at providing a service to

00:09:13,900 --> 00:09:16,930
users and Thanos is aimed you as you

00:09:15,790 --> 00:09:18,190
said it really well like growing with

00:09:16,930 --> 00:09:21,040
your Prometheus cluster and so it can

00:09:18,190 --> 00:09:23,530
take a really different approach and

00:09:21,040 --> 00:09:24,850
that meant we had to do the samples

00:09:23,530 --> 00:09:26,290
there wasn't really any other option in

00:09:24,850 --> 00:09:27,660
fact the only other option that's now

00:09:26,290 --> 00:09:30,160
coming up you might want to talk about

00:09:27,660 --> 00:09:31,150
yeah is is sunny the fabulous working

00:09:30,160 --> 00:09:38,590
which I think it's awesome when we want

00:09:31,150 --> 00:09:40,300
to support so like my problem was the

00:09:38,590 --> 00:09:43,420
remote whereas I was kind of been that

00:09:40,300 --> 00:09:44,590
it's yeah flaky let's say or if you have

00:09:43,420 --> 00:09:46,270
a network plague or something you're

00:09:44,590 --> 00:09:47,860
losing data in the end right you can

00:09:46,270 --> 00:09:50,020
buffer samples up in memory to a degree

00:09:47,860 --> 00:09:52,240
that's maybe five minutes but eventually

00:09:50,020 --> 00:09:54,340
you just have to drop data that's always

00:09:52,240 --> 00:09:57,370
seems like suboptimal because network is

00:09:54,340 --> 00:09:58,570
flaky so what I always figured is with

00:09:57,370 --> 00:10:00,640
this new storage we have every word I

00:09:58,570 --> 00:10:02,140
have dog which is essentially yeah it's

00:10:00,640 --> 00:10:03,790
a persistent bar for all the data for

00:10:02,140 --> 00:10:05,830
your written at least for a couple of

00:10:03,790 --> 00:10:06,820
hours and would be ideal if we could

00:10:05,830 --> 00:10:08,470
just stream this right ahead talk

00:10:06,820 --> 00:10:11,350
somewhere else and if we have a

00:10:08,470 --> 00:10:11,680
connection fader and line for like 10

00:10:11,350 --> 00:10:13,900
minutes

00:10:11,680 --> 00:10:16,180
we just come back and just take pictures

00:10:13,900 --> 00:10:17,740
right ahead book back off where we left

00:10:16,180 --> 00:10:21,100
essentially and then we don't lose data

00:10:17,740 --> 00:10:24,940
at least for quite large time window

00:10:21,100 --> 00:10:27,130
this is a new development right so

00:10:24,940 --> 00:10:29,260
basically the challenges always between

00:10:27,130 --> 00:10:31,750
either you ship your samples immediately

00:10:29,260 --> 00:10:33,310
as I get scraped to some remote system

00:10:31,750 --> 00:10:35,710
then they're safe they're durable you

00:10:33,310 --> 00:10:37,140
know that's awesome but then you're

00:10:35,710 --> 00:10:39,070
sending them in the most inefficient

00:10:37,140 --> 00:10:40,870
representation ever you need to marshal

00:10:39,070 --> 00:10:41,410
them each sample to protobuf send it

00:10:40,870 --> 00:10:46,450
over the network

00:10:41,410 --> 00:10:48,730
yada yada and that's cool but yeah then

00:10:46,450 --> 00:10:50,230
you know you if you don't buffer it also

00:10:48,730 --> 00:10:52,930
locally you're not resilient its

00:10:50,230 --> 00:10:53,470
inefficient etc it's really efficient

00:10:52,930 --> 00:10:56,410
the way

00:10:53,470 --> 00:10:58,210
thanos ships full compressed blocks as

00:10:56,410 --> 00:11:00,160
one thing you know once they're

00:10:58,210 --> 00:11:04,420
persisted to disk but yeah then it takes

00:11:00,160 --> 00:11:06,040
hours for them to actually migrate to to

00:11:04,420 --> 00:11:07,480
the destination storage where they're

00:11:06,040 --> 00:11:08,589
where they're safe and durable and if

00:11:07,480 --> 00:11:13,560
you lose your premier server in the

00:11:08,589 --> 00:11:15,820
meantime you kind of out of luck and

00:11:13,560 --> 00:11:17,110
yeah I was wondering so now you have

00:11:15,820 --> 00:11:18,740
this intermediate approach where you say

00:11:17,110 --> 00:11:21,290
well we ship the

00:11:18,740 --> 00:11:25,580
locks but in between we also want to

00:11:21,290 --> 00:11:27,709
ship the wall or you just do the wall

00:11:25,580 --> 00:11:28,970
now that's that's your idea in the

00:11:27,709 --> 00:11:31,250
future well yeah so that's actually

00:11:28,970 --> 00:11:33,529
design back out there a long time ago

00:11:31,250 --> 00:11:35,120
for example is a sector of a case where

00:11:33,529 --> 00:11:36,800
we want to get data from from ETS into

00:11:35,120 --> 00:11:38,899
stackdriver we could use the remote part

00:11:36,800 --> 00:11:41,029
as well turns out that has some missing

00:11:38,899 --> 00:11:42,740
features like metadata etc and target

00:11:41,029 --> 00:11:44,240
information so we want to have something

00:11:42,740 --> 00:11:47,209
better and also at this additional data

00:11:44,240 --> 00:11:48,770
and that's why we owed this what a

00:11:47,209 --> 00:11:50,330
headlock based approach but it's not

00:11:48,770 --> 00:11:52,550
public yet but you can actually look at

00:11:50,330 --> 00:11:53,810
the design Doc's yeah

00:11:52,550 --> 00:11:55,399
the benefit is that you have this

00:11:53,810 --> 00:11:57,290
Brazilians and basically you are the

00:11:55,399 --> 00:11:59,029
total among data support you need

00:11:57,290 --> 00:12:00,589
significant it goes down because the

00:11:59,029 --> 00:12:02,450
remote without now you have to send the

00:12:00,589 --> 00:12:04,250
entire label set and the data point and

00:12:02,450 --> 00:12:06,100
we write a head lock in theory you just

00:12:04,250 --> 00:12:08,480
have to send basically the series ID

00:12:06,100 --> 00:12:10,610
after you sent the series itself once

00:12:08,480 --> 00:12:13,040
and then just the time cement the value

00:12:10,610 --> 00:12:14,899
which sort of probably reduce your data

00:12:13,040 --> 00:12:16,850
swoop of at index just I just wanted to

00:12:14,899 --> 00:12:20,690
defend the remote write code a little

00:12:16,850 --> 00:12:22,459
bit it was it was never meant to be like

00:12:20,690 --> 00:12:24,110
the you know it's never meant to be as

00:12:22,459 --> 00:12:26,540
widely used like Julis I think you wrote

00:12:24,110 --> 00:12:30,320
the first implementation remote read

00:12:26,540 --> 00:12:32,720
okay one one of the two of us right yeah

00:12:30,320 --> 00:12:34,970
right was Brian one of the three of

00:12:32,720 --> 00:12:38,270
those I did the sharding code which is

00:12:34,970 --> 00:12:39,529
pretty crappy as well and like it was

00:12:38,270 --> 00:12:40,880
always supposed to be a prototype and we

00:12:39,529 --> 00:12:42,500
were just super impressed when like as

00:12:40,880 --> 00:12:44,390
Paul alluded to like last prom con

00:12:42,500 --> 00:12:46,220
seemed like a lot more people were using

00:12:44,390 --> 00:12:47,839
it than we were ever expecting to be

00:12:46,220 --> 00:12:52,910
honest and so I really welcome the new

00:12:47,839 --> 00:12:56,649
right had long approach and we're gonna

00:12:52,910 --> 00:13:00,649
sport in cortex when it's public cool oh

00:12:56,649 --> 00:13:01,970
yeah so just to put forward the side of

00:13:00,649 --> 00:13:04,339
the story I mean you went through the

00:13:01,970 --> 00:13:07,610
clustered solution because as I said I

00:13:04,339 --> 00:13:09,140
mean our QPS was extremely high so we

00:13:07,610 --> 00:13:10,970
want so first thing was we wanted to

00:13:09,140 --> 00:13:13,490
advocate in a streaming fashion rather

00:13:10,970 --> 00:13:15,380
than like later on aggregate in like a

00:13:13,490 --> 00:13:17,360
bad fashion so actually we did some

00:13:15,380 --> 00:13:20,300
analysis if you actually did the bad

00:13:17,360 --> 00:13:22,100
fashion then eradicated I should never

00:13:20,300 --> 00:13:24,860
gonna be able to keep up with the load

00:13:22,100 --> 00:13:27,860
so that was one interesting and then the

00:13:24,860 --> 00:13:29,750
other thing we noticed was it's a really

00:13:27,860 --> 00:13:31,790
nice property to have an alerts are

00:13:29,750 --> 00:13:32,570
actually working off your aggregated

00:13:31,790 --> 00:13:34,820
data so

00:13:32,570 --> 00:13:36,740
we actually are really later on our

00:13:34,820 --> 00:13:38,150
alerts will have to fat like fetch all

00:13:36,740 --> 00:13:40,640
those queries and apply the aggregation

00:13:38,150 --> 00:13:43,970
later so those were some unique things

00:13:40,640 --> 00:13:47,150
and then we wanted to be really reliable

00:13:43,970 --> 00:13:50,240
so we do replication and all that like

00:13:47,150 --> 00:13:52,190
so in actually uber production we have a

00:13:50,240 --> 00:13:53,180
replication factor of three so I don't

00:13:52,190 --> 00:13:55,100
know if any of the system has

00:13:53,180 --> 00:13:57,590
replication but for us it was kind of

00:13:55,100 --> 00:14:02,510
valuable so all these kind of made us

00:13:57,590 --> 00:14:04,430
move towards that cluster solution yeah

00:14:02,510 --> 00:14:06,830
yeah there yeah they all do basically

00:14:04,430 --> 00:14:11,030
you've got big table or dynamo and

00:14:06,830 --> 00:14:13,790
you've got us three um but no everything

00:14:11,030 --> 00:14:17,330
is go based right yeah go go go go go go

00:14:13,790 --> 00:14:19,850
yeah that's it's the future until we all

00:14:17,330 --> 00:14:26,420
switch to rusty it's the past no I mean

00:14:19,850 --> 00:14:27,650
that's interesting like yeah so I want

00:14:26,420 --> 00:14:31,760
to comment on the clustering thing to

00:14:27,650 --> 00:14:34,550
just briefly which is in flux as a

00:14:31,760 --> 00:14:38,600
project is it's not just scope to

00:14:34,550 --> 00:14:40,280
metrics and monitoring data so we went

00:14:38,600 --> 00:14:42,020
with the clustered solution because we

00:14:40,280 --> 00:14:44,270
want to behave like a database which is

00:14:42,020 --> 00:14:45,530
people have expectations of when they

00:14:44,270 --> 00:14:47,300
write and they get a response it's

00:14:45,530 --> 00:14:49,490
durable and it's replicated and all this

00:14:47,300 --> 00:14:51,080
other stuff so if you can avoid

00:14:49,490 --> 00:14:52,880
clustering I would by all means

00:14:51,080 --> 00:14:57,890
recommend that because it's the worst

00:14:52,880 --> 00:15:00,200
thing to do whatever um question since M

00:14:57,890 --> 00:15:01,640
3 DB is the newest one out here just I

00:15:00,200 --> 00:15:03,410
think the blog post came out yesterday

00:15:01,640 --> 00:15:06,230
or the day before yes

00:15:03,410 --> 00:15:08,870
3 DB but M 3 which is the actual like

00:15:06,230 --> 00:15:11,930
Prometheus integration with an uber what

00:15:08,870 --> 00:15:14,210
are your hopes for the open with like

00:15:11,930 --> 00:15:16,070
combined with the open sourcing like are

00:15:14,210 --> 00:15:17,840
you what what was the first reaction you

00:15:16,070 --> 00:15:20,240
got from the community are you getting a

00:15:17,840 --> 00:15:22,400
lot of interest already what would you

00:15:20,240 --> 00:15:23,000
like to get out of that yeah that's a

00:15:22,400 --> 00:15:25,330
good question

00:15:23,000 --> 00:15:28,640
so one thing I want to point out is

00:15:25,330 --> 00:15:30,620
making money out of database is not over

00:15:28,640 --> 00:15:31,940
his business right so we wanted to make

00:15:30,620 --> 00:15:34,730
an open source with the primary

00:15:31,940 --> 00:15:37,310
objective that we're providing different

00:15:34,730 --> 00:15:39,410
components as part of m3 and people can

00:15:37,310 --> 00:15:41,420
pick which component they want so people

00:15:39,410 --> 00:15:42,920
can use the primary side car for example

00:15:41,420 --> 00:15:44,930
or they can use mtdb

00:15:42,920 --> 00:15:46,400
or later on we might open source the

00:15:44,930 --> 00:15:48,529
aggregation here so they can use

00:15:46,400 --> 00:15:50,890
so we kind of provide a way for people

00:15:48,529 --> 00:15:53,480
to pick and choose what they want and

00:15:50,890 --> 00:15:55,970
regarding the reaction I think when we

00:15:53,480 --> 00:15:58,880
put out the block-post I initial desire

00:15:55,970 --> 00:16:00,110
was oh we want to be on the first page

00:15:58,880 --> 00:16:02,779
it's like hacking users or something

00:16:00,110 --> 00:16:05,380
right and we got got there and then yeah

00:16:02,779 --> 00:16:08,600
we got positive response and people

00:16:05,380 --> 00:16:11,480
never heard about in 3db before like a

00:16:08,600 --> 00:16:13,580
lot of people who talk to us so one big

00:16:11,480 --> 00:16:16,850
push we're doing is kind of educating

00:16:13,580 --> 00:16:18,830
people about it so previously so we had

00:16:16,850 --> 00:16:21,980
had this system running a lot with an

00:16:18,830 --> 00:16:23,600
uber and it has been working but we

00:16:21,980 --> 00:16:25,370
never really pushed it into open source

00:16:23,600 --> 00:16:28,160
world so this is something new we're

00:16:25,370 --> 00:16:30,350
drawing and now we think they're at a

00:16:28,160 --> 00:16:32,210
stage that it's kind of easy to use for

00:16:30,350 --> 00:16:35,000
people and it we definitely believe it's

00:16:32,210 --> 00:16:37,400
usable so yeah now we're just trying to

00:16:35,000 --> 00:16:41,660
educate and put our faces out and talk

00:16:37,400 --> 00:16:44,690
about n3 as much as again cool let's see

00:16:41,660 --> 00:16:46,610
how much time we have we have time but I

00:16:44,690 --> 00:16:47,720
mean are they already audience questions

00:16:46,610 --> 00:16:48,740
because those are always more

00:16:47,720 --> 00:16:53,120
interesting than mine

00:16:48,740 --> 00:16:54,880
I have prom coins as well oh yeah thank

00:16:53,120 --> 00:16:58,100
you by the way

00:16:54,880 --> 00:16:59,750
all right great great content so far

00:16:58,100 --> 00:17:03,560
that's just one question why are there

00:16:59,750 --> 00:17:05,809
five dudes yes this is a very good

00:17:03,560 --> 00:17:07,610
question it's I think not only good

00:17:05,809 --> 00:17:09,470
question for this panel but for the

00:17:07,610 --> 00:17:16,880
entire community and the set of

00:17:09,470 --> 00:17:18,770
maintainer so I think yeah I don't know

00:17:16,880 --> 00:17:22,579
if I can give the best answer to this

00:17:18,770 --> 00:17:24,890
but for this specific panel of course

00:17:22,579 --> 00:17:26,750
it's like okay who do we know who

00:17:24,890 --> 00:17:31,880
created each of the individual remote

00:17:26,750 --> 00:17:34,640
storage implementations for the broader

00:17:31,880 --> 00:17:38,660
question I think this is of making the

00:17:34,640 --> 00:17:42,110
community more welcoming and helping

00:17:38,660 --> 00:17:45,230
newcomers get into the project but also

00:17:42,110 --> 00:17:47,059
without feeling I think I mean I could

00:17:45,230 --> 00:17:52,670
start a whole community discussion now I

00:17:47,059 --> 00:17:57,500
think often we are a bit maybe a bit of

00:17:52,670 --> 00:18:00,380
a harsh community a bit of a community

00:17:57,500 --> 00:18:05,960
that looks the same in a lot of ways

00:18:00,380 --> 00:18:07,160
and yeah I would really like to see

00:18:05,960 --> 00:18:09,740
improvements in that as well

00:18:07,160 --> 00:18:15,590
I'm doing privately some things that I

00:18:09,740 --> 00:18:18,140
can do but I would sometimes yeah also I

00:18:15,590 --> 00:18:20,570
mean it's yeah I I don't I don't think I

00:18:18,140 --> 00:18:22,429
can answer give you like a perfect

00:18:20,570 --> 00:18:34,940
answer to that question right now

00:18:22,429 --> 00:18:36,919
that we yeah I mean that's yeah it's a

00:18:34,940 --> 00:18:38,360
good thing but also we have to improve a

00:18:36,919 --> 00:18:41,720
lot on that front

00:18:38,360 --> 00:18:43,549
yeah so my question is about

00:18:41,720 --> 00:18:45,280
multi-tenancy I know the core tech

00:18:43,549 --> 00:18:48,260
supports multi-tenancy out of the box

00:18:45,280 --> 00:18:50,210
how far away are your are the other

00:18:48,260 --> 00:18:52,130
long-term storage solutions from being

00:18:50,210 --> 00:18:54,830
able to provide a multi-tenant storage

00:18:52,130 --> 00:18:57,770
solution Bob works for fresh tracks who

00:18:54,830 --> 00:19:04,970
also runs cortex so he's definitely a

00:18:57,770 --> 00:19:08,390
plant here fancy I think Bartok told me

00:19:04,970 --> 00:19:10,340
that he's working on something like sort

00:19:08,390 --> 00:19:12,169
of a curry gateway that allows you to

00:19:10,340 --> 00:19:14,600
basically do tenancy based on the label

00:19:12,169 --> 00:19:16,809
selectors that seems like their way to

00:19:14,600 --> 00:19:16,809
go

00:19:31,460 --> 00:19:36,150
Paris

00:19:32,760 --> 00:19:37,680
so Bartok said that improbable and Greta

00:19:36,150 --> 00:19:38,910
are both interested in this stuff and

00:19:37,680 --> 00:19:40,560
they're probably going to work on it and

00:19:38,910 --> 00:19:44,180
they both have a lot of different power

00:19:40,560 --> 00:19:44,180
so that's hopefully going to happen I

00:19:54,170 --> 00:19:59,670
just want to comment that yes

00:19:56,490 --> 00:20:01,170
Prometheus invited a lot of us diversity

00:19:59,670 --> 00:20:04,260
people here I guess I come from the

00:20:01,170 --> 00:20:06,600
state so thank you and from this all

00:20:04,260 --> 00:20:09,720
being brand new for me I'm still in

00:20:06,600 --> 00:20:11,130
school I don't know what m3 is and my

00:20:09,720 --> 00:20:14,130
other question to the panel its how do

00:20:11,130 --> 00:20:16,500
you find time to innovate and create I

00:20:14,130 --> 00:20:20,460
was just asking my colleague and for me

00:20:16,500 --> 00:20:22,980
I work a lot and so how do you carve out

00:20:20,460 --> 00:20:24,270
that time so that you know one day we

00:20:22,980 --> 00:20:26,010
could be up at the stage is like hey I

00:20:24,270 --> 00:20:30,630
created something cool named after

00:20:26,010 --> 00:20:32,850
Marvel how do we do that can can can can

00:20:30,630 --> 00:20:35,420
actually try to give a tentative answer

00:20:32,850 --> 00:20:38,610
to that because I have been mentoring

00:20:35,420 --> 00:20:40,650
candidates like a candidate by itself as

00:20:38,610 --> 00:20:42,300
never diverse a candidate can improve

00:20:40,650 --> 00:20:44,640
the diversity of a group and I've been

00:20:42,300 --> 00:20:45,810
mentoring some candidate some people who

00:20:44,640 --> 00:20:49,950
are interested in contributing to

00:20:45,810 --> 00:20:51,530
parameters for example who would make us

00:20:49,950 --> 00:20:54,060
richer and more diverse and more

00:20:51,530 --> 00:20:56,190
inclusive hopefully I mean that's more

00:20:54,060 --> 00:21:00,440
on us who already there that's sometimes

00:20:56,190 --> 00:21:02,760
the problem and and a lot of times I see

00:21:00,440 --> 00:21:05,160
like they're interested and it's great

00:21:02,760 --> 00:21:08,730
but then there's not a lot of follow up

00:21:05,160 --> 00:21:10,110
because without actual funding which I

00:21:08,730 --> 00:21:12,240
also know from my personal experience

00:21:10,110 --> 00:21:14,850
it's really hard to unless you're like a

00:21:12,240 --> 00:21:17,850
super nerd and after you work you still

00:21:14,850 --> 00:21:22,020
feel like coding to actually keep added

00:21:17,850 --> 00:21:23,640
so I think it's I think the unless

00:21:22,020 --> 00:21:26,310
you're that kind of person

00:21:23,640 --> 00:21:28,620
it's we need more funding for this kind

00:21:26,310 --> 00:21:31,920
of thing we need to be we need companies

00:21:28,620 --> 00:21:35,880
to employ more junior people and to be

00:21:31,920 --> 00:21:38,200
more welcoming to them and yeah

00:21:35,880 --> 00:21:40,240
basically more mentoring and that

00:21:38,200 --> 00:21:41,740
kind of thing because we need people to

00:21:40,240 --> 00:21:43,090
get paid to do this kind of thing

00:21:41,740 --> 00:21:45,460
because we have like billion-dollar

00:21:43,090 --> 00:21:49,870
companies using the software in the end

00:21:45,460 --> 00:21:51,580
and and yeah yeah I'm gonna like I'm

00:21:49,870 --> 00:21:53,050
gonna say something and maybe a little

00:21:51,580 --> 00:21:55,450
bit controversial but at least like

00:21:53,050 --> 00:21:56,800
early on in my career if I wanted to do

00:21:55,450 --> 00:22:00,130
open source stuff that was all during my

00:21:56,800 --> 00:22:02,110
free time and weekends which was great

00:22:00,130 --> 00:22:03,820
the vast majority people were writing

00:22:02,110 --> 00:22:05,200
code aren't doing it for open source

00:22:03,820 --> 00:22:06,160
companies and they aren't writing open

00:22:05,200 --> 00:22:07,900
source code right

00:22:06,160 --> 00:22:11,620
the vast majority code that gets written

00:22:07,900 --> 00:22:13,030
is closed source so I mean for those of

00:22:11,620 --> 00:22:15,790
us who did get to write open source code

00:22:13,030 --> 00:22:17,680
full time like in my case like I did a

00:22:15,790 --> 00:22:19,120
bait-and-switch with some VCS and raised

00:22:17,680 --> 00:22:21,850
some money it got them to pay me to do

00:22:19,120 --> 00:22:23,920
open source other people get other big

00:22:21,850 --> 00:22:27,340
companies to get them so if you can do

00:22:23,920 --> 00:22:29,410
open source code full time but for me at

00:22:27,340 --> 00:22:32,470
least doing open source was basically

00:22:29,410 --> 00:22:36,160
the gateway to events like this and all

00:22:32,470 --> 00:22:38,140
that other kind of stuff for me was also

00:22:36,160 --> 00:22:40,810
always a mix but it helps I noticed

00:22:38,140 --> 00:22:43,660
myself for example now I'm freelancing

00:22:40,810 --> 00:22:45,540
instead of being employed and I get to

00:22:43,660 --> 00:22:47,710
do way less upstream stuff because

00:22:45,540 --> 00:22:50,410
customers tend to be more interested in

00:22:47,710 --> 00:22:53,110
support training and whatever features

00:22:50,410 --> 00:22:55,510
exactly they need for their company yeah

00:22:53,110 --> 00:22:58,780
I wanted to go back to the multi-tenancy

00:22:55,510 --> 00:23:01,210
earth thing really quick but one thing

00:22:58,780 --> 00:23:03,250
so we have asked the maintainer panel

00:23:01,210 --> 00:23:06,250
tomorrow where you will encounter the

00:23:03,250 --> 00:23:09,340
same problem with you'll see it all on

00:23:06,250 --> 00:23:11,500
stage but I would be very happy actually

00:23:09,340 --> 00:23:15,940
if we could continue this conversation

00:23:11,500 --> 00:23:21,160
there all right I'm not I'm

00:23:15,940 --> 00:23:22,300
multi-tenancy really quickly so most

00:23:21,160 --> 00:23:24,160
databases aren't designed to be

00:23:22,300 --> 00:23:26,500
multi-tenant usually you layer that in

00:23:24,160 --> 00:23:28,300
the application layer right like you

00:23:26,500 --> 00:23:30,280
have your application layer protect your

00:23:28,300 --> 00:23:32,200
my sequel data database against a bunch

00:23:30,280 --> 00:23:33,430
of tenants that you have in it usually

00:23:32,200 --> 00:23:34,780
when people do multi-tenancy and

00:23:33,430 --> 00:23:37,390
databases what they actually do is they

00:23:34,780 --> 00:23:38,560
deploy it on separate VMs and it looks

00:23:37,390 --> 00:23:39,910
like a multi-tenant system but

00:23:38,560 --> 00:23:43,330
ultimately you're talking about single

00:23:39,910 --> 00:23:45,160
tenant deploys now the next version of

00:23:43,330 --> 00:23:47,950
in flux DB is gonna have this idea of

00:23:45,160 --> 00:23:49,270
multi-tenancy built into the API but to

00:23:47,950 --> 00:23:51,160
actually make that operationally

00:23:49,270 --> 00:23:52,000
feasible is something that I think is

00:23:51,160 --> 00:23:55,120
only kind of

00:23:52,000 --> 00:23:57,730
come up over the last like five years of

00:23:55,120 --> 00:23:59,560
infrastructure software which is I don't

00:23:57,730 --> 00:24:00,730
think we've yet seen a database that was

00:23:59,560 --> 00:24:03,220
designed from the ground up to be

00:24:00,730 --> 00:24:05,530
containerized I think containerization

00:24:03,220 --> 00:24:07,180
is actually what can lead to actual

00:24:05,530 --> 00:24:09,940
multi-tenancy within a database system

00:24:07,180 --> 00:24:13,420
so one of the efforts that we have with

00:24:09,940 --> 00:24:15,130
flux was to decouple processing from the

00:24:13,420 --> 00:24:16,660
actual storage of the data and the

00:24:15,130 --> 00:24:18,970
reason we wanted to do that is because

00:24:16,660 --> 00:24:21,520
we wanted to spin up new processing

00:24:18,970 --> 00:24:23,230
agents in containers that could be

00:24:21,520 --> 00:24:25,450
sandboxed so that we could have a

00:24:23,230 --> 00:24:27,670
multi-tenant system that actually was a

00:24:25,450 --> 00:24:31,890
bit more reliable than a standard

00:24:27,670 --> 00:24:31,890
database but I wouldn't call it easy

00:24:35,430 --> 00:24:42,400
okay I'm sorry to go back to the remote

00:24:39,700 --> 00:24:44,440
region right thing the issue I have is

00:24:42,400 --> 00:24:46,840
that when you in just a sample you lose

00:24:44,440 --> 00:24:49,030
the metric type so when you're writing

00:24:46,840 --> 00:24:52,120
it remote storage you lose the fact that

00:24:49,030 --> 00:24:54,220
is for example histogram and when you

00:24:52,120 --> 00:24:59,770
have native Quay prom credit query it's

00:24:54,220 --> 00:25:01,420
easy but when you don't you lose the

00:24:59,770 --> 00:25:05,800
fact that this metric is an Instagram

00:25:01,420 --> 00:25:08,470
and that you have to treat it I found

00:25:05,800 --> 00:25:16,240
that missing the typing information in

00:25:08,470 --> 00:25:23,860
the metric is for long for long term

00:25:16,240 --> 00:25:26,860
storage yeah yeah that's the same issue

00:25:23,860 --> 00:25:29,800
we ran into that's actually part of the

00:25:26,860 --> 00:25:32,680
reason why we new approach for the stack

00:25:29,800 --> 00:25:33,790
we're doing because simply yeah we need

00:25:32,680 --> 00:25:37,090
type information you want target

00:25:33,790 --> 00:25:38,980
information etc etc and yeah once we

00:25:37,090 --> 00:25:40,570
publish what we have that's probably be

00:25:38,980 --> 00:25:42,850
insightful and because we actually added

00:25:40,570 --> 00:25:44,260
API super Macias that expose the type

00:25:42,850 --> 00:25:46,090
and target information and we use a

00:25:44,260 --> 00:25:47,680
tailored right ahead talk to get the

00:25:46,090 --> 00:25:54,190
data out and then we join this again

00:25:47,680 --> 00:25:55,990
with these api's anyway exactly that's a

00:25:54,190 --> 00:25:58,690
problem yeah so yeah Prometheus doesn't

00:25:55,990 --> 00:26:00,700
store that data anyway so technically

00:25:58,690 --> 00:26:02,770
that data is worthless like it's just as

00:26:00,700 --> 00:26:04,810
useful in Prometheus or in a long term

00:26:02,770 --> 00:26:05,830
storage solution which is the fact that

00:26:04,810 --> 00:26:07,750
it's a histogram is

00:26:05,830 --> 00:26:09,370
recognized by what the labels look like

00:26:07,750 --> 00:26:11,470
yeah but it'd be incredibly useful for

00:26:09,370 --> 00:26:13,120
instance to hint it in the UI right

00:26:11,470 --> 00:26:14,890
that's one of the one of the main

00:26:13,120 --> 00:26:16,840
reasons we want that data is so that we

00:26:14,890 --> 00:26:18,940
can tell users if they're rating a

00:26:16,840 --> 00:26:21,039
counter right oh we're not writing a

00:26:18,940 --> 00:26:22,269
counter or tell users like that this is

00:26:21,039 --> 00:26:25,809
a histogram and should be treated as

00:26:22,269 --> 00:26:30,880
such so the question I have then is

00:26:25,809 --> 00:26:33,390
we're not allowed to post questions I'm

00:26:30,880 --> 00:26:36,519
going to do it on behalf of the audience

00:26:33,390 --> 00:26:38,169
which is okay so that's that's storing

00:26:36,519 --> 00:26:40,240
the the type information for long-term

00:26:38,169 --> 00:26:42,519
storage but are there plans to put

00:26:40,240 --> 00:26:44,470
storing type information about the

00:26:42,519 --> 00:26:46,990
metrics within Prometheus itself and

00:26:44,470 --> 00:26:52,570
adding API endpoints so you can query

00:26:46,990 --> 00:26:55,690
that so I would love to do that but they

00:26:52,570 --> 00:26:57,159
accept more requests indeed yeah we had

00:26:55,690 --> 00:26:59,440
a discussion about full-time jobs and

00:26:57,159 --> 00:27:00,429
things earlier yeah I think it's

00:26:59,440 --> 00:27:02,740
something we should do it now you've put

00:27:00,429 --> 00:27:05,110
the api's in there's yeah we actually

00:27:02,740 --> 00:27:08,169
briefly considered sort of adding this

00:27:05,110 --> 00:27:09,760
to the storage layer but like it seemed

00:27:08,169 --> 00:27:12,220
like a lot of effort to be honest poor

00:27:09,760 --> 00:27:13,960
like just our use case so far that we

00:27:12,220 --> 00:27:15,730
would get value out of it so I think we

00:27:13,960 --> 00:27:17,860
need more data points that this is

00:27:15,730 --> 00:27:19,240
valuable because it booyah drastic

00:27:17,860 --> 00:27:21,760
change and we have to convince Brian

00:27:19,240 --> 00:27:30,490
which probably will take not to us we

00:27:21,760 --> 00:27:33,789
yes yes so the reason why so many people

00:27:30,490 --> 00:27:35,289
are it is is because it's not driven by

00:27:33,789 --> 00:27:37,870
a company's even by lots of different

00:27:35,289 --> 00:27:40,360
people we worked together to achieve the

00:27:37,870 --> 00:27:41,769
same goal but when I look at you guys it

00:27:40,360 --> 00:27:43,750
looks like there is always like a

00:27:41,769 --> 00:27:46,149
company behind that I would like to know

00:27:43,750 --> 00:27:47,980
a bit more about the governance and if

00:27:46,149 --> 00:27:50,049
we choose long term storage we want the

00:27:47,980 --> 00:27:52,269
the project to be supported to the long

00:27:50,049 --> 00:27:54,460
term as well so that we have two years

00:27:52,269 --> 00:27:57,159
of data but the software is it is still

00:27:54,460 --> 00:28:02,889
like used and maintained maybe each of

00:27:57,159 --> 00:28:04,899
you just give a quick reply to that now

00:28:02,889 --> 00:28:06,760
oh yeah I mean well promises governance

00:28:04,899 --> 00:28:08,710
is sort of but I think he's wondering

00:28:06,760 --> 00:28:11,049
about the governance of each of your

00:28:08,710 --> 00:28:13,360
rights likes because it's like all of

00:28:11,049 --> 00:28:15,159
them are like paid by a company that we

00:28:13,360 --> 00:28:17,620
don't know it we'd be there in three

00:28:15,159 --> 00:28:19,440
years for example like in primitives we

00:28:17,620 --> 00:28:21,419
know that maybe the VP we left

00:28:19,440 --> 00:28:24,779
but we have confidence that permit is

00:28:21,419 --> 00:28:26,279
really be there in two or three years in

00:28:24,779 --> 00:28:28,440
my case I think I work for five

00:28:26,279 --> 00:28:31,500
different companies on prometheus over

00:28:28,440 --> 00:28:33,029
time I just always try to have the best

00:28:31,500 --> 00:28:34,559
for the project in mind while at the

00:28:33,029 --> 00:28:36,929
same time sort of satisfying my

00:28:34,559 --> 00:28:38,340
employers goals let's say so for that

00:28:36,929 --> 00:28:40,919
works pretty well I think most companies

00:28:38,340 --> 00:28:42,389
today are quite open to being nice to

00:28:40,919 --> 00:28:47,519
open-source and doing things right

00:28:42,389 --> 00:28:53,610
so it's bit young but maybe about a case

00:28:47,519 --> 00:28:56,460
already yeah from Tom's perspective I

00:28:53,610 --> 00:28:59,850
think well we designed tunnels because

00:28:56,460 --> 00:29:02,309
we had this issue on our own so I think

00:28:59,850 --> 00:29:04,649
it's safe to say that improbable will

00:29:02,309 --> 00:29:07,200
support the darkness because we are

00:29:04,649 --> 00:29:10,159
using it and that's our future plan and

00:29:07,200 --> 00:29:12,419
we are completely transparent on that

00:29:10,159 --> 00:29:15,600
everything there is no hidden like

00:29:12,419 --> 00:29:17,340
roadmaps or hidden you know discussion

00:29:15,600 --> 00:29:20,070
everything is happening in github and

00:29:17,340 --> 00:29:22,350
we'd like to be as open as possible so

00:29:20,070 --> 00:29:26,250
yeah that's an improbable state input

00:29:22,350 --> 00:29:28,679
standpoint and for tennis yeah same for

00:29:26,250 --> 00:29:30,299
same for cortex really so I originally

00:29:28,679 --> 00:29:31,529
started coralista I originally started

00:29:30,299 --> 00:29:33,960
cortex at weave works

00:29:31,529 --> 00:29:35,730
I left Dubai and startup based on cortex

00:29:33,960 --> 00:29:38,730
and now work for qivana labs and so

00:29:35,730 --> 00:29:40,940
we've been through we've adopted CNI the

00:29:38,730 --> 00:29:43,049
container network interfaces like

00:29:40,940 --> 00:29:45,690
governance just because it was short and

00:29:43,049 --> 00:29:47,129
you know sweet and it's got a whole

00:29:45,690 --> 00:29:49,519
bunch of companies involved so it's

00:29:47,129 --> 00:29:49,519
going pretty well

00:29:51,169 --> 00:29:55,370
sorry I can keep talking if you like

00:30:05,299 --> 00:30:12,870
okay so for uber I mean we be running

00:30:09,539 --> 00:30:27,860
three for obras metrics so it's not like

00:30:12,870 --> 00:30:27,860
always going away anywhere so yeah and

00:30:28,440 --> 00:30:35,800
so and and what we're doing now is as I

00:30:32,920 --> 00:30:37,600
said earlier that we build m3 m3 DB and

00:30:35,800 --> 00:30:39,310
the other other layers internally and

00:30:37,600 --> 00:30:41,170
you're open sourcing it but going

00:30:39,310 --> 00:30:43,290
forward we're actually planning to use

00:30:41,170 --> 00:30:46,750
the open source components directly

00:30:43,290 --> 00:30:50,170
within our actual internal systems so

00:30:46,750 --> 00:30:52,180
that way it's it kind of gives us a

00:30:50,170 --> 00:30:53,980
motivation to keep developing towards

00:30:52,180 --> 00:30:55,600
open source and that kind of answer it

00:30:53,980 --> 00:30:56,800
also answers the other question Rin how

00:30:55,600 --> 00:31:00,490
do you manage time I mean it's my

00:30:56,800 --> 00:31:01,930
full-time job not to develop the open

00:31:00,490 --> 00:31:05,260
source solution because we're gonna use

00:31:01,930 --> 00:31:06,550
it for our actual business so yeah that

00:31:05,260 --> 00:31:11,230
in that way we're kind of unique because

00:31:06,550 --> 00:31:14,110
it's driving our business and yeah yeah

00:31:11,230 --> 00:31:19,270
so speaking is the one representative

00:31:14,110 --> 00:31:21,640
who is selling a database we we try to

00:31:19,270 --> 00:31:23,110
we I mean in terms of this like we try

00:31:21,640 --> 00:31:25,240
to conform to whatever api's our

00:31:23,110 --> 00:31:27,160
standard this is one of the reasons why

00:31:25,240 --> 00:31:28,930
I'm excited about open metrics is like a

00:31:27,160 --> 00:31:30,100
standard we want to support those

00:31:28,930 --> 00:31:32,830
standards like we don't want to hold

00:31:30,100 --> 00:31:34,030
people's data hostage but regardless of

00:31:32,830 --> 00:31:36,430
which project you're using for a long

00:31:34,030 --> 00:31:38,620
term storage the simple fact is like

00:31:36,430 --> 00:31:41,800
data has gravity and the more data you

00:31:38,620 --> 00:31:43,330
have the more gravity it has so even if

00:31:41,800 --> 00:31:45,550
your based on a totally open solution

00:31:43,330 --> 00:31:46,240
it's totally free it's based on

00:31:45,550 --> 00:31:47,890
standards

00:31:46,240 --> 00:31:49,480
you're going to have lock in with

00:31:47,890 --> 00:31:52,870
wherever your platform is wherever your

00:31:49,480 --> 00:32:00,310
hosting is so the idea of no lock-in

00:31:52,870 --> 00:32:02,560
it's a myth don't please I hide I think

00:32:00,310 --> 00:32:04,450
we have the answer from Thanos but how

00:32:02,560 --> 00:32:11,500
did the rest of you handle right back in

00:32:04,450 --> 00:32:13,150
the right back in the Iran between your

00:32:11,500 --> 00:32:14,920
Prometheus's and your cortex foster you

00:32:13,150 --> 00:32:16,720
mean yep yeah so there's a smaller

00:32:14,920 --> 00:32:18,450
memory buffer in prometheus

00:32:16,720 --> 00:32:20,470
if that gets exhausted you drop data

00:32:18,450 --> 00:32:22,660
we're hoping that the right head locks

00:32:20,470 --> 00:32:24,960
work the fabián doing will solve that

00:32:22,660 --> 00:32:24,960
problem

00:32:32,890 --> 00:32:36,830
sorry it's way more interesting but we

00:32:35,150 --> 00:32:39,380
don't have time to talk about what

00:32:36,830 --> 00:32:40,970
happens within like what happens we have

00:32:39,380 --> 00:32:42,380
a different replication scheme and we

00:32:40,970 --> 00:32:44,060
can do all sorts of different tricks too

00:32:42,380 --> 00:32:46,730
like if you can't reach certain parts of

00:32:44,060 --> 00:32:48,430
the system so what he's saying is you

00:32:46,730 --> 00:32:53,780
don't get a token for this question I

00:32:48,430 --> 00:32:55,070
think he's out anyway I was going to

00:32:53,780 --> 00:32:58,250
follow up on what you were saying before

00:32:55,070 --> 00:33:01,010
about the long term support of systems I

00:32:58,250 --> 00:33:03,500
think this applies to most systems out

00:33:01,010 --> 00:33:06,350
there that are offered as free software

00:33:03,500 --> 00:33:08,510
open source in general my rule of thumb

00:33:06,350 --> 00:33:11,270
is like I will trust a lot more a

00:33:08,510 --> 00:33:12,620
project as community managed there's not

00:33:11,270 --> 00:33:14,240
tied to a single company and I think

00:33:12,620 --> 00:33:17,720
commit is a great example of that

00:33:14,240 --> 00:33:19,610
I started in one place but it was not

00:33:17,720 --> 00:33:20,990
managed by the company and then we can

00:33:19,610 --> 00:33:22,460
complete independence but you're right

00:33:20,990 --> 00:33:27,080
go sorry

00:33:22,460 --> 00:33:32,660
do you write go code yeah yeah and which

00:33:27,080 --> 00:33:37,940
company manages that project it's not

00:33:32,660 --> 00:33:39,770
perfect yeah in general is my point of

00:33:37,940 --> 00:33:41,210
view is that I will trust more a project

00:33:39,770 --> 00:33:43,100
that has a governess independent

00:33:41,210 --> 00:33:44,180
independent a company yeah I mean I

00:33:43,100 --> 00:33:46,700
think it's a good point but these

00:33:44,180 --> 00:33:47,990
communities take time to build yes right

00:33:46,700 --> 00:33:49,520
I think phalluses community is going

00:33:47,990 --> 00:33:52,250
pretty well like even though it's it's

00:33:49,520 --> 00:33:53,380
done by improbable like communities got

00:33:52,250 --> 00:33:55,040
quite a lot of contributions right

00:33:53,380 --> 00:33:56,330
cortex something going for two and a

00:33:55,040 --> 00:33:58,160
half years and we're still a relatively

00:33:56,330 --> 00:34:00,170
small community but there's four or five

00:33:58,160 --> 00:34:04,760
companies involved in it I guess like

00:34:00,170 --> 00:34:05,900
yeah yeah I mean actually I mean once

00:34:04,760 --> 00:34:07,940
you have a community we will actually

00:34:05,900 --> 00:34:10,130
prefer registering with C and C F and

00:34:07,940 --> 00:34:12,110
being completely community built you

00:34:10,130 --> 00:34:13,670
know I mean it's not like we want to own

00:34:12,110 --> 00:34:15,560
a database I mean you're not a database

00:34:13,670 --> 00:34:17,630
company so it's just that we had to

00:34:15,560 --> 00:34:19,910
build a database because at that point

00:34:17,630 --> 00:34:21,740
there was no other alternative we saw

00:34:19,910 --> 00:34:23,090
which could solve a problem but right

00:34:21,740 --> 00:34:25,030
now we'll be happy to make it a

00:34:23,090 --> 00:34:27,050
completely community turbine project

00:34:25,030 --> 00:34:33,470
please don't thinking it's a personal

00:34:27,050 --> 00:34:35,540
attack oh I mean right now as I said we

00:34:33,470 --> 00:34:38,270
just published a blog post right and now

00:34:35,540 --> 00:34:41,030
we're trying to tell people about m3 so

00:34:38,270 --> 00:34:42,650
first educate people about m3 and then

00:34:41,030 --> 00:34:43,700
trying to build a community so we have

00:34:42,650 --> 00:34:45,379
like

00:34:43,700 --> 00:34:47,720
I think a glittery channel where people

00:34:45,379 --> 00:34:50,629
can come in and like give thought and

00:34:47,720 --> 00:34:52,579
you know always open to contributions I

00:34:50,629 --> 00:34:54,290
mean but all that comes later on with

00:34:52,579 --> 00:34:56,329
people actually know what I'm you know

00:34:54,290 --> 00:34:58,460
like so we be happy to take in any

00:34:56,329 --> 00:35:01,130
contribution any like issues you want to

00:34:58,460 --> 00:35:02,810
open up I mean completely and later on

00:35:01,130 --> 00:35:05,359
when we feel it's the right time then we

00:35:02,810 --> 00:35:07,130
can consider registering with CN CF I

00:35:05,359 --> 00:35:10,670
mean if we feel we get accepted I mean

00:35:07,130 --> 00:35:13,250
if you guys or we can submit it yeah

00:35:10,670 --> 00:35:15,530
sorry i sorry i didn't mean to be

00:35:13,250 --> 00:35:17,869
flippant about the community thing i

00:35:15,530 --> 00:35:21,380
mean different governance models you

00:35:17,869 --> 00:35:24,260
know like kubernetes and CN CF there's

00:35:21,380 --> 00:35:26,240
be DFL ultimately I think open-source

00:35:24,260 --> 00:35:27,680
thrives off of continued contribution

00:35:26,240 --> 00:35:29,810
and continued community effort

00:35:27,680 --> 00:35:32,480
regardless of what the governance model

00:35:29,810 --> 00:35:33,829
is I think go-go doesn't have that sort

00:35:32,480 --> 00:35:35,900
of community governance model but I

00:35:33,829 --> 00:35:37,760
think it's so successful because there's

00:35:35,900 --> 00:35:40,070
just so much effort getting put into it

00:35:37,760 --> 00:35:41,480
and they do seem to try to listen to the

00:35:40,070 --> 00:35:45,230
community even though sometimes there

00:35:41,480 --> 00:35:46,579
are issues but I ultimately for any open

00:35:45,230 --> 00:35:49,490
source project I think it lives and dies

00:35:46,579 --> 00:35:54,829
by people's continued effort to improve

00:35:49,490 --> 00:35:57,020
it and and move it forward so unless you

00:35:54,829 --> 00:36:03,319
want to see me make your distinct cons

00:35:57,020 --> 00:36:05,390
maybe ask more questions so Richie

00:36:03,319 --> 00:36:07,970
already pulled a prank on me which I

00:36:05,390 --> 00:36:09,650
have to tell my name on my on my badges

00:36:07,970 --> 00:36:11,300
holes instead of Falls because there's

00:36:09,650 --> 00:36:14,480
like a funny YouTube video or it's means

00:36:11,300 --> 00:36:17,300
wooden and then he lost my real badge

00:36:14,480 --> 00:36:18,859
and now he can't find it anymore so yeah

00:36:17,300 --> 00:36:20,900
I'm stuck with this one so in case you

00:36:18,859 --> 00:36:21,710
were wondering why my last name is weird

00:36:20,900 --> 00:36:27,800
on here

00:36:21,710 --> 00:36:29,839
it's a sexual name hi and this is my P a

00:36:27,800 --> 00:36:31,339
bit of a naive question and we're just

00:36:29,839 --> 00:36:35,170
starting out when it's Prometheus and

00:36:31,339 --> 00:36:37,550
obviously they like everything you hear

00:36:35,170 --> 00:36:39,319
the original Prometheus families like

00:36:37,550 --> 00:36:42,109
you know there is this quite simple

00:36:39,319 --> 00:36:44,920
thing with local storage but at the same

00:36:42,109 --> 00:36:48,230
time we're looking at building out into

00:36:44,920 --> 00:36:50,990
keeping that is and ephemeral a more

00:36:48,230 --> 00:36:53,180
ephemeral instances is is this the way

00:36:50,990 --> 00:36:57,230
forward if you want does this unlucky

00:36:53,180 --> 00:36:59,530
you in your ability to have

00:36:57,230 --> 00:37:03,710
more scalable more dynamic prometheus

00:36:59,530 --> 00:37:07,970
floating to and long-term storage and

00:37:03,710 --> 00:37:11,990
all their patterns around this who would

00:37:07,970 --> 00:37:18,290
most like to answer this question maybe

00:37:11,990 --> 00:37:19,970
the Prometheus trying to ascent the

00:37:18,290 --> 00:37:21,740
question you're thinking like you have

00:37:19,970 --> 00:37:25,100
promises service that are not around for

00:37:21,740 --> 00:37:26,510
like a long time and okay yeah I think

00:37:25,100 --> 00:37:28,369
in this case right now you're better off

00:37:26,510 --> 00:37:30,080
as a remote right solution because they

00:37:28,369 --> 00:37:32,060
die get out immunity right antennas

00:37:30,080 --> 00:37:33,109
currently the status that you have to

00:37:32,060 --> 00:37:35,030
wait for like two hours so you would

00:37:33,109 --> 00:37:37,010
have to sort of turn on the keep the

00:37:35,030 --> 00:37:39,470
previous server life and then wait and

00:37:37,010 --> 00:37:41,119
so this data gets shipped and that's

00:37:39,470 --> 00:37:44,570
something it's on the issue tracker I

00:37:41,119 --> 00:37:45,890
think to sort of get worked out um but I

00:37:44,570 --> 00:37:49,850
would hope in the long term that's not a

00:37:45,890 --> 00:37:52,280
problem for any of these solutions needs

00:37:49,850 --> 00:37:53,960
to live somewhere right and all of us

00:37:52,280 --> 00:37:55,760
rely on a very similar technique for

00:37:53,960 --> 00:37:57,920
building up these chunks and getting

00:37:55,760 --> 00:38:00,890
this compression and that's how we all

00:37:57,920 --> 00:38:02,150
get very similar costs so you need to

00:38:00,890 --> 00:38:04,359
have something running for some length

00:38:02,150 --> 00:38:08,450
of time that can build these chunks yes

00:38:04,359 --> 00:38:10,600
yes but at least for the time being you

00:38:08,450 --> 00:38:12,890
still have to care about these

00:38:10,600 --> 00:38:14,480
Prometheus instances that you've got

00:38:12,890 --> 00:38:16,369
running again you're given a disclosure

00:38:14,480 --> 00:38:17,690
yeah if you use tunnels do you have to

00:38:16,369 --> 00:38:19,250
care about those if you use cortex you

00:38:17,690 --> 00:38:21,680
have to care about cortex just like to

00:38:19,250 --> 00:38:23,660
care about something hmm yeah I remember

00:38:21,680 --> 00:38:25,400
with promises one we were able to switch

00:38:23,660 --> 00:38:28,430
off the local storage completely and

00:38:25,400 --> 00:38:30,590
only have it in forwarding mode to

00:38:28,430 --> 00:38:35,330
remote right that isn't really possible

00:38:30,590 --> 00:38:36,950
anymore with the current 2.0 storage so

00:38:35,330 --> 00:38:38,359
you can configure it to like minimal

00:38:36,950 --> 00:38:43,250
retention you still need to have like

00:38:38,359 --> 00:38:46,340
some in like like memory file system or

00:38:43,250 --> 00:38:49,340
something to to make it work but yeah so

00:38:46,340 --> 00:38:50,990
we there there was this approach already

00:38:49,340 --> 00:38:56,630
about to make basically like a storage

00:38:50,990 --> 00:38:58,670
less Prometheus so I know that most

00:38:56,630 --> 00:39:02,270
monitoring systems tend to fall in

00:38:58,670 --> 00:39:04,270
either as I managed to stand up most

00:39:02,270 --> 00:39:07,070
monitoring systems fall into either

00:39:04,270 --> 00:39:10,710
operational making sure things are

00:39:07,070 --> 00:39:13,080
running properly or into data analysis

00:39:10,710 --> 00:39:13,860
predictive let's explore and see what's

00:39:13,080 --> 00:39:15,840
going on

00:39:13,860 --> 00:39:17,910
Prometheus obviously is mostly for

00:39:15,840 --> 00:39:21,150
operational stuff and I'm wondering for

00:39:17,910 --> 00:39:24,420
the longer term storage if you have a

00:39:21,150 --> 00:39:26,910
particular focus on on one kind of way

00:39:24,420 --> 00:39:31,800
to consume the data and the implications

00:39:26,910 --> 00:39:33,270
of designing for that I think you

00:39:31,800 --> 00:39:35,280
probably have more interesting ways of

00:39:33,270 --> 00:39:36,900
consuming that at least yeah I I mean I

00:39:35,280 --> 00:39:38,880
have an opinion this doesn't really

00:39:36,900 --> 00:39:43,260
reflect where we are now but where I

00:39:38,880 --> 00:39:45,420
would like us to go which is and this is

00:39:43,260 --> 00:39:48,120
one of the things why mention aro why

00:39:45,420 --> 00:39:50,790
I'm excited about it is because arrow is

00:39:48,120 --> 00:39:53,160
a perfect like interchange format to to

00:39:50,790 --> 00:39:55,140
send off to other systems like Hadoop or

00:39:53,160 --> 00:39:58,290
spark or whatever if you want to do like

00:39:55,140 --> 00:40:00,870
large-scale analytical type processing

00:39:58,290 --> 00:40:03,930
and stuff like that influx by and large

00:40:00,870 --> 00:40:05,670
is is built as like a real-time kind of

00:40:03,930 --> 00:40:08,570
database so it's mostly like you're

00:40:05,670 --> 00:40:10,860
querying frequent or recent data but

00:40:08,570 --> 00:40:13,710
what I would like to see us do

00:40:10,860 --> 00:40:16,050
eventually is support data formats that

00:40:13,710 --> 00:40:17,910
can be shipped to other systems that are

00:40:16,050 --> 00:40:21,120
better at doing like analytical

00:40:17,910 --> 00:40:25,550
processing or stuff like that I'd like

00:40:21,120 --> 00:40:27,900
to help add that support to Prometheus

00:40:25,550 --> 00:40:33,240
if I understand the question correctly I

00:40:27,900 --> 00:40:35,010
mean so we as I mentioned earlier we we

00:40:33,240 --> 00:40:37,710
want to provide a platform which can

00:40:35,010 --> 00:40:40,530
give you quick access to metrics however

00:40:37,710 --> 00:40:42,600
long retention you want and using that

00:40:40,530 --> 00:40:44,760
we've already have had different ways to

00:40:42,600 --> 00:40:46,800
consume data so we've had a product

00:40:44,760 --> 00:40:49,830
which can forecast trips you know using

00:40:46,800 --> 00:40:52,500
the last two months of trip data we have

00:40:49,830 --> 00:40:54,420
anomaly detection using our matrix

00:40:52,500 --> 00:40:57,030
platform so I don't know if that's what

00:40:54,420 --> 00:41:05,580
you're referring as to consume data in

00:40:57,030 --> 00:41:08,070
different ways so you all play with its

00:41:05,580 --> 00:41:10,380
me you all play with remote reach remote

00:41:08,070 --> 00:41:12,600
rate interfaces except honest format

00:41:10,380 --> 00:41:16,050
understood but how would we what would

00:41:12,600 --> 00:41:17,970
you improve them and maybe would we

00:41:16,050 --> 00:41:20,130
promote them to be like used by other

00:41:17,970 --> 00:41:22,560
systems or infirmity so that you can

00:41:20,130 --> 00:41:24,940
make interaction between primitives or

00:41:22,560 --> 00:41:27,190
in fact appear where fight or any other

00:41:24,940 --> 00:41:30,280
system out there so that the parentheses

00:41:27,190 --> 00:41:34,060
sir can be like changed with someone

00:41:30,280 --> 00:41:36,520
something else I mean one thing we've

00:41:34,060 --> 00:41:39,880
noticed is that remote remote read/write

00:41:36,520 --> 00:41:41,890
is kind of like best effort I mean if it

00:41:39,880 --> 00:41:44,680
has a buffer but eventually we'll drop

00:41:41,890 --> 00:41:46,840
data so that is one of the concerns we

00:41:44,680 --> 00:41:48,730
have so that is something we'd want to

00:41:46,840 --> 00:41:49,900
improve and then there are other things

00:41:48,730 --> 00:41:53,050
which you talked about earlier like

00:41:49,900 --> 00:41:55,330
maybe supporting type information or

00:41:53,050 --> 00:41:57,760
like for cross DC there are some things

00:41:55,330 --> 00:42:01,540
which we want to add to the API so yeah

00:41:57,760 --> 00:42:02,980
I mean there are some things the read

00:42:01,540 --> 00:42:04,840
can quite easily your from easiest

00:42:02,980 --> 00:42:06,369
server if you're not careful so that's

00:42:04,840 --> 00:42:07,570
that and it clearly needs fixing right

00:42:06,369 --> 00:42:08,860
we need to move to a Streamy interface

00:42:07,570 --> 00:42:11,410
there I mean that's what the sidecar

00:42:08,860 --> 00:42:15,520
does basically so we need to do that

00:42:11,410 --> 00:42:17,530
like yeah the reads the read-only really

00:42:15,520 --> 00:42:19,720
a prototype I don't know anyone who

00:42:17,530 --> 00:42:21,400
actually uses it anger yeah the yeah the

00:42:19,720 --> 00:42:23,590
read interface is basically you send

00:42:21,400 --> 00:42:25,810
HTTP a request with like a batcher and a

00:42:23,590 --> 00:42:27,550
start and stop time and it sends like a

00:42:25,810 --> 00:42:29,109
batch of the data so basically it has to

00:42:27,550 --> 00:42:31,060
marshal the entire result in memory

00:42:29,109 --> 00:42:33,700
before it sends it back to you and it's

00:42:31,060 --> 00:42:34,990
just like protobuf blob so the thing

00:42:33,700 --> 00:42:38,290
that I'm actually interested in adding

00:42:34,990 --> 00:42:41,200
to prometheus itself or whatever to

00:42:38,290 --> 00:42:44,770
define is like a remote read protocol is

00:42:41,200 --> 00:42:46,750
essentially still G RPC but instead of

00:42:44,770 --> 00:42:49,510
sending one block design it more as like

00:42:46,750 --> 00:42:51,670
a batches like micro batches where it

00:42:49,510 --> 00:42:53,950
can stream the data out in chunks so you

00:42:51,670 --> 00:42:55,630
could theoretically send a query to a

00:42:53,950 --> 00:42:57,609
Prometheus server where you want to do a

00:42:55,630 --> 00:42:59,260
remote read and you do a remote read of

00:42:57,609 --> 00:43:01,240
the entire contents of the data store

00:42:59,260 --> 00:43:03,040
and it could just stream that out right

00:43:01,240 --> 00:43:05,950
whereas right now like if it was a large

00:43:03,040 --> 00:43:08,410
data store you'd blow up your server is

00:43:05,950 --> 00:43:09,340
anyone thinking yet off completely

00:43:08,410 --> 00:43:11,859
fettering

00:43:09,340 --> 00:43:15,369
like distributing out queries in the

00:43:11,859 --> 00:43:18,430
sense of doing local aggregations yes

00:43:15,369 --> 00:43:20,380
yeah yeah so actually that's one thing

00:43:18,430 --> 00:43:22,119
I'd like to see like right now the

00:43:20,380 --> 00:43:24,460
remote read is you push down the matcher

00:43:22,119 --> 00:43:27,340
and the range what I'd like to see is

00:43:24,460 --> 00:43:30,240
being able to push down other things

00:43:27,340 --> 00:43:32,380
like aggregates and stuff like that and

00:43:30,240 --> 00:43:34,510
that's what we're doing like in the

00:43:32,380 --> 00:43:36,400
influx DB design with the flux engine is

00:43:34,510 --> 00:43:37,900
it's basically you can think of it as

00:43:36,400 --> 00:43:38,109
like a MapReduce that gets run on the

00:43:37,900 --> 00:43:41,140
floor

00:43:38,109 --> 00:43:43,450
I wear the mat phase would get run on

00:43:41,140 --> 00:43:45,670
each of the Promethea or whatever

00:43:43,450 --> 00:43:48,549
service that supports the prometheus

00:43:45,670 --> 00:43:51,220
remote read logic and then the reduce

00:43:48,549 --> 00:43:52,839
would just be done by in our case the

00:43:51,220 --> 00:43:57,369
flux node the coordinator node

00:43:52,839 --> 00:43:58,269
essentially yeah I'm kind of against

00:43:57,369 --> 00:43:59,890
this at this point

00:43:58,269 --> 00:44:01,359
I mean not in general as approach but

00:43:59,890 --> 00:44:03,849
from easiest

00:44:01,359 --> 00:44:06,190
like what we notice in tennis was the

00:44:03,849 --> 00:44:08,079
data I should not that big like even for

00:44:06,190 --> 00:44:11,200
big highways like hundreds of megabytes

00:44:08,079 --> 00:44:13,089
even the gigabytes of gigabytes it's not

00:44:11,200 --> 00:44:14,319
that much data to be honest you can ship

00:44:13,089 --> 00:44:16,150
this somewhere and process it right the

00:44:14,319 --> 00:44:17,230
processing will take longer so it would

00:44:16,150 --> 00:44:19,059
make sense to actually shorten the

00:44:17,230 --> 00:44:20,559
processing but then employees you have

00:44:19,059 --> 00:44:23,499
this problem that actually you have

00:44:20,559 --> 00:44:25,059
aggregations over time and how do we

00:44:23,499 --> 00:44:28,029
solve that if your data is child up at

00:44:25,059 --> 00:44:29,140
time then if two sort of the overlapping

00:44:28,029 --> 00:44:32,319
ranges you have to ship them around

00:44:29,140 --> 00:44:38,460
actually get the different education

00:44:32,319 --> 00:44:40,599
right I mean vertically works kinda but

00:44:38,460 --> 00:44:42,460
yeah it depends on what charting

00:44:40,599 --> 00:44:44,650
mechanism you do and what aggregation

00:44:42,460 --> 00:44:45,999
but like tea digest for example or if

00:44:44,650 --> 00:44:48,640
you're gonna use hyper log log for

00:44:45,999 --> 00:44:50,259
counts right those those can be

00:44:48,640 --> 00:44:51,519
distributed across shards and then you

00:44:50,259 --> 00:44:54,190
can combine them up in the resulting

00:44:51,519 --> 00:44:55,480
node it depends basically I mean

00:44:54,190 --> 00:44:58,210
definitely make sense in general but I

00:44:55,480 --> 00:45:00,519
think Prometheus like it's not at the

00:44:58,210 --> 00:45:01,930
stage is there's one type of query which

00:45:00,519 --> 00:45:03,400
I've encountered with the customers

00:45:01,930 --> 00:45:05,769
where they're using Panos

00:45:03,400 --> 00:45:07,239
they have like millions of metrics in

00:45:05,769 --> 00:45:09,519
the parameter server pointing Thanos at

00:45:07,239 --> 00:45:11,499
it and then the problem is like if you

00:45:09,519 --> 00:45:13,749
want to run a debug like where we like

00:45:11,499 --> 00:45:16,119
give me the count for every metric name

00:45:13,749 --> 00:45:17,980
which has a low output cardinality but

00:45:16,119 --> 00:45:20,529
you need to ship over the identity even

00:45:17,980 --> 00:45:22,960
if it's just the right now timestamp to

00:45:20,529 --> 00:45:24,849
the query er it needs to go to like

00:45:22,960 --> 00:45:27,190
through the room wrote read marshaled

00:45:24,849 --> 00:45:28,809
into finest G RPC and I think it would

00:45:27,190 --> 00:45:31,599
be similar problem with with the other

00:45:28,809 --> 00:45:33,489
with some of the other approaches so

00:45:31,599 --> 00:45:35,559
just that give me that summary at the

00:45:33,489 --> 00:45:38,799
current timestamp which metrics have how

00:45:35,559 --> 00:45:40,509
many series isn't isn't possible and it

00:45:38,799 --> 00:45:42,160
runs very easily with the local storage

00:45:40,509 --> 00:45:46,210
because it can do like lazy evaluation

00:45:42,160 --> 00:45:47,920
of iterators and all that so so yeah I

00:45:46,210 --> 00:45:51,040
think there's there's more need for

00:45:47,920 --> 00:45:53,590
distributed querying then

00:45:51,040 --> 00:45:56,050
that particular case comes up a lot like

00:45:53,590 --> 00:45:57,460
this particular query and I think it's

00:45:56,050 --> 00:45:59,080
like it's metadata right you don't want

00:45:57,460 --> 00:46:04,690
to you don't care what the times data in

00:45:59,080 --> 00:46:06,790
this case right but but yeah yeah I mean

00:46:04,690 --> 00:46:09,070
yeah it's it's a debug style query but

00:46:06,790 --> 00:46:10,900
if we could like totally ship all over

00:46:09,070 --> 00:46:12,790
that query like we just get the result

00:46:10,900 --> 00:46:17,770
back it would be ricci but shipping all

00:46:12,790 --> 00:46:20,470
the data to the Thanos courier kills the

00:46:17,770 --> 00:46:24,130
query API we can just ship the query to

00:46:20,470 --> 00:46:25,930
the yes even so yeah I mean I think the

00:46:24,130 --> 00:46:27,370
the the the question there is more like

00:46:25,930 --> 00:46:32,170
how do you combine results in a

00:46:27,370 --> 00:46:35,080
distributed manner problem so actually

00:46:32,170 --> 00:46:37,120
adding to what Fabien said you're also

00:46:35,080 --> 00:46:40,840
building our query engine now like a new

00:46:37,120 --> 00:46:42,670
query engine in open source and we this

00:46:40,840 --> 00:46:45,190
is a topic we discussed at length

00:46:42,670 --> 00:46:49,000
whether to ship computation off to

00:46:45,190 --> 00:46:50,500
remote storage nodes but after we

00:46:49,000 --> 00:46:53,200
analyze the data I mean the actual

00:46:50,500 --> 00:46:55,090
compressed data is super small so one

00:46:53,200 --> 00:46:57,820
gray one thing we found we can do

00:46:55,090 --> 00:46:59,620
instead is to actually ship back the

00:46:57,820 --> 00:47:02,200
only the compressed data so we don't

00:46:59,620 --> 00:47:04,420
decompress data and return back all the

00:47:02,200 --> 00:47:06,130
compressed data and be able to

00:47:04,420 --> 00:47:08,050
decompress it on the fly so that

00:47:06,130 --> 00:47:10,480
actually reduces the memory footprint at

00:47:08,050 --> 00:47:12,430
the core he knows a lot so that after

00:47:10,480 --> 00:47:15,400
doing that we actually found this I know

00:47:12,430 --> 00:47:17,740
you'll need to do distribute computation

00:47:15,400 --> 00:47:19,900
and it also solves the problem of how do

00:47:17,740 --> 00:47:22,300
you like do integrate like how do you

00:47:19,900 --> 00:47:24,370
stitch together different data pieces so

00:47:22,300 --> 00:47:26,350
that's something you can think about is

00:47:24,370 --> 00:47:35,440
the same it strips around compressed

00:47:26,350 --> 00:47:36,820
trunks oh it sucks to ok cortex it's not

00:47:35,440 --> 00:47:38,470
that big a deal we pretty much do the

00:47:36,820 --> 00:47:41,170
same thing we fetch the query of fetch

00:47:38,470 --> 00:47:44,850
compressed jungles all right we don't

00:47:41,170 --> 00:47:44,850
wait for the last 15 minutes

00:47:46,410 --> 00:47:50,440
no we iterate through them now I though

00:47:48,580 --> 00:47:52,530
that only changed in the last like six

00:47:50,440 --> 00:47:52,530
weeks

00:47:53,130 --> 00:47:59,860
we're probably nearing the end of the

00:47:55,870 --> 00:48:02,430
slot Ritchie what do you say okay much

00:47:59,860 --> 00:48:04,450
more questions I there's one there okay

00:48:02,430 --> 00:48:07,540
one question when

00:48:04,450 --> 00:48:10,380
talk about the remote storage also would

00:48:07,540 --> 00:48:13,960
be interesting then mr. Paul mentions

00:48:10,380 --> 00:48:16,329
open format and I'm not sure if one year

00:48:13,960 --> 00:48:18,910
ago there was some ideas that it will be

00:48:16,329 --> 00:48:23,670
published but I haven't seen any things

00:48:18,910 --> 00:48:28,030
that would enable to use any of those

00:48:23,670 --> 00:48:30,550
databases to insert as from other

00:48:28,030 --> 00:48:32,290
sources the data into the time series

00:48:30,550 --> 00:48:37,290
data bit and then you can fetch them and

00:48:32,290 --> 00:48:40,270
analyze and make it more transparent

00:48:37,290 --> 00:48:43,780
transparent yeah transparent or overall

00:48:40,270 --> 00:48:46,510
and so my question is when you plan to

00:48:43,780 --> 00:48:49,839
release maybe I don't know open stuff

00:48:46,510 --> 00:48:51,550
open standards that maybe we can like oh

00:48:49,839 --> 00:49:00,880
is it somewhere discussions going on

00:48:51,550 --> 00:49:02,650
that we can like contribute into it yeah

00:49:00,880 --> 00:49:05,470
I mean I I think the problem is right

00:49:02,650 --> 00:49:06,640
now like so Thanos and the Prometheus

00:49:05,470 --> 00:49:08,280
format are basically the same which is

00:49:06,640 --> 00:49:11,710
the blocks right the compressed blocks

00:49:08,280 --> 00:49:13,390
m3 DB I think uses its own influx uses

00:49:11,710 --> 00:49:14,530
its own which are these are all just

00:49:13,390 --> 00:49:17,319
variants of the same thing which is

00:49:14,530 --> 00:49:19,180
basically the gorilla compression so the

00:49:17,319 --> 00:49:21,369
question is like can we all figure out

00:49:19,180 --> 00:49:23,380
when to standardize on or is there like

00:49:21,369 --> 00:49:25,150
I think it's not just the blocks itself

00:49:23,380 --> 00:49:27,400
but the other pieces of like metadata

00:49:25,150 --> 00:49:29,470
that have to be standardized and like I

00:49:27,400 --> 00:49:30,640
said I'm particularly - arrow but the

00:49:29,470 --> 00:49:33,160
problem is arrow doesn't specify

00:49:30,640 --> 00:49:36,190
compressed types which is an issue so

00:49:33,160 --> 00:49:38,170
that's something that we may be asking

00:49:36,190 --> 00:49:39,190
them about but yeah it's also a question

00:49:38,170 --> 00:49:41,319
of how you go around building these

00:49:39,190 --> 00:49:43,359
standards right I mean we we know we put

00:49:41,319 --> 00:49:45,369
out the read and write format for

00:49:43,359 --> 00:49:46,240
Prometheus and they're open standards as

00:49:45,369 --> 00:49:48,339
if you like you know they're just a

00:49:46,240 --> 00:49:49,569
prototype after description but we also

00:49:48,339 --> 00:49:51,310
know they're pretty weak in certain

00:49:49,569 --> 00:49:54,040
areas and we kind of discouraging people

00:49:51,310 --> 00:49:55,540
from holding them up too high like we've

00:49:54,040 --> 00:49:56,890
got met which he's going to talk to more

00:49:55,540 --> 00:49:59,170
about open metrics which is more in the

00:49:56,890 --> 00:50:00,369
ingestion side like we want to build you

00:49:59,170 --> 00:50:02,500
know you build these standards by

00:50:00,369 --> 00:50:04,839
getting a consensus among like people

00:50:02,500 --> 00:50:06,520
and there's not really I don't think the

00:50:04,839 --> 00:50:08,680
push to do that like it's not in

00:50:06,520 --> 00:50:10,900
necessarily any of our interest to do

00:50:08,680 --> 00:50:11,890
that at the moment and I'd know these

00:50:10,900 --> 00:50:13,119
things are quite simple and quite

00:50:11,890 --> 00:50:14,290
interoperable as they are you know

00:50:13,119 --> 00:50:15,880
there's little adapters that live all

00:50:14,290 --> 00:50:18,340
over the place so it might be a pain in

00:50:15,880 --> 00:50:20,020
the ass to to join them to

00:50:18,340 --> 00:50:21,730
but it does exist like you can make

00:50:20,020 --> 00:50:25,420
influx talk to Prometheus and from

00:50:21,730 --> 00:50:27,310
easiest door to influx and yeah I think

00:50:25,420 --> 00:50:28,600
the thing that sucks about that and

00:50:27,310 --> 00:50:29,950
again it's why I keep coming back to

00:50:28,600 --> 00:50:31,690
arrow is like to integrate these things

00:50:29,950 --> 00:50:33,850
you have to decompress the block and

00:50:31,690 --> 00:50:35,500
then recompress it and translate it and

00:50:33,850 --> 00:50:37,180
whatever the nice thing with Thanos and

00:50:35,500 --> 00:50:39,160
Prometheus together is like they can

00:50:37,180 --> 00:50:41,200
just ship compressed blocks around with

00:50:39,160 --> 00:50:43,270
actually out ha without having to

00:50:41,200 --> 00:50:45,670
analyze them right so you can get like

00:50:43,270 --> 00:50:48,190
zero copy semantics which is again like

00:50:45,670 --> 00:50:49,900
because arrows focused on zero copy

00:50:48,190 --> 00:50:51,370
semantics that's like if you had

00:50:49,900 --> 00:50:53,530
compression with that I think it could

00:50:51,370 --> 00:50:55,390
be but it would take a lot of effort to

00:50:53,530 --> 00:50:57,130
get everybody to get everyone to use

00:50:55,390 --> 00:50:59,170
that same format and for what benefit

00:50:57,130 --> 00:51:01,120
like most of most its but most of my

00:50:59,170 --> 00:51:04,060
customers are going to just use one or

00:51:01,120 --> 00:51:06,010
maybe two sorry one or maybe two formats

00:51:04,060 --> 00:51:07,960
and it's very hard to build a build a

00:51:06,010 --> 00:51:10,380
case to put a lot of effort into you

00:51:07,960 --> 00:51:12,870
know a big anyway compatible format

00:51:10,380 --> 00:51:19,000
sorry like you know it'd be cool but

00:51:12,870 --> 00:51:21,820
like so my question is to the audience

00:51:19,000 --> 00:51:26,740
in you know is anybody actually just

00:51:21,820 --> 00:51:27,780
using prometheus storage long term yeah

00:51:26,740 --> 00:51:31,750
me too

00:51:27,780 --> 00:51:40,660
it's working great so it's already built

00:51:31,750 --> 00:51:47,200
in you know long term storage how can I

00:51:40,660 --> 00:51:49,030
ask you how long is long term 10 years 9

00:51:47,200 --> 00:51:50,290
months good yeah cuz you've got some

00:51:49,030 --> 00:51:53,350
really big Prometheus service haven't

00:51:50,290 --> 00:52:01,540
you dove right so that's what three

00:51:53,350 --> 00:52:04,300
years yeah I think it's a valid point

00:52:01,540 --> 00:52:05,290
but do you do you back it up right yeah

00:52:04,300 --> 00:52:07,440
I mean that's a good strategy

00:52:05,290 --> 00:52:07,440
right

00:52:12,100 --> 00:52:19,210
for those without my keys how big was it

00:52:13,600 --> 00:52:23,110
just under a terabyte I mean we design

00:52:19,210 --> 00:52:24,700
and code the local storage a bit with a

00:52:23,110 --> 00:52:26,560
fact in mind that that it's not meant

00:52:24,700 --> 00:52:28,360
for that long I mean people do it but

00:52:26,560 --> 00:52:31,600
then once in a while we're like okay

00:52:28,360 --> 00:52:33,130
maybe we do breaking change or maybe you

00:52:31,600 --> 00:52:35,050
know we don't care so much about

00:52:33,130 --> 00:52:36,760
durability and replication and so on so

00:52:35,050 --> 00:52:38,650
now you have to have like multiple

00:52:36,760 --> 00:52:40,780
replicas on your own to make sure that

00:52:38,650 --> 00:52:42,550
the data really sticks around maybe you

00:52:40,780 --> 00:52:46,150
need to operate older primitive versions

00:52:42,550 --> 00:52:48,370
migrate somehow or so yeah so just yours

00:52:46,150 --> 00:52:53,440
a bit more on your own when doing that

00:52:48,370 --> 00:52:56,260
yeah I have a question more like a

00:52:53,440 --> 00:52:59,710
request we know about cortex and we just

00:52:56,260 --> 00:53:03,250
learned about tano's so I would like to

00:52:59,710 --> 00:53:12,660
see a lightning talk on m3 perhaps later

00:53:03,250 --> 00:53:12,660
this evening I mean I submitted it so

00:53:14,520 --> 00:53:20,140
it's number eight on the list we will

00:53:17,200 --> 00:53:23,680
get this relation to the standardization

00:53:20,140 --> 00:53:25,870
as tom says remote read/write are pretty

00:53:23,680 --> 00:53:27,940
weak and this is by design they are

00:53:25,870 --> 00:53:30,280
literally the stupidest team they will

00:53:27,940 --> 00:53:32,050
work and because the thing is we don't

00:53:30,280 --> 00:53:33,640
want to describe how you design all this

00:53:32,050 --> 00:53:35,170
stuff if we prescribe how the block

00:53:33,640 --> 00:53:36,760
looks like that would mean that we're

00:53:35,170 --> 00:53:38,350
deciding how all these are most storages

00:53:36,760 --> 00:53:39,940
will end up working instead we're saying

00:53:38,350 --> 00:53:42,250
here's something really really dumb it's

00:53:39,940 --> 00:53:43,930
a prototype and now like we figured out

00:53:42,250 --> 00:53:47,200
actually without right is a really bad

00:53:43,930 --> 00:53:48,340
idea let's use Wales wonderful even I

00:53:47,200 --> 00:53:49,750
solve that and we can do the same with

00:53:48,340 --> 00:53:51,340
Reed and we'll refer this all out and

00:53:49,750 --> 00:53:53,850
figure it out by everyone trying stuff

00:53:51,340 --> 00:53:57,070
and making it better

00:53:53,850 --> 00:53:59,290
thank you for solving that very big

00:53:57,070 --> 00:54:02,650
issue that we have in primitive is long

00:53:59,290 --> 00:54:04,630
term storage but in a fewers what would

00:54:02,650 --> 00:54:06,220
be for you the next big thing to solve

00:54:04,630 --> 00:54:11,400
after we have solved the long term

00:54:06,220 --> 00:54:14,500
storage issues for prometheus roaming oh

00:54:11,400 --> 00:54:18,060
maybe what let other people answer that

00:54:14,500 --> 00:54:18,060
who wants to answer that Brian

00:54:18,450 --> 00:54:21,840
future completed

00:54:23,200 --> 00:54:28,420
I don't know like I think Anna outwitted

00:54:26,380 --> 00:54:29,470
us two or three months so I will hand

00:54:28,420 --> 00:54:31,630
this question up to someone who has been

00:54:29,470 --> 00:54:33,850
involved I mean outside of Prometheus

00:54:31,630 --> 00:54:36,070
I'm working on logging like I think

00:54:33,850 --> 00:54:38,500
that's the next thing yeah I mean that's

00:54:36,070 --> 00:54:40,720
the the scope of Prometheus so far is

00:54:38,500 --> 00:54:43,060
pretty well defined and we don't want it

00:54:40,720 --> 00:54:44,620
to blow up into something that is too

00:54:43,060 --> 00:54:47,290
far beyond that because the simplicity

00:54:44,620 --> 00:54:48,910
is a lot of its strengths as Paul also

00:54:47,290 --> 00:54:51,490
mentioned you know saying no to some

00:54:48,910 --> 00:54:54,310
things there's still some road map map

00:54:51,490 --> 00:54:58,330
items like making metadata making better

00:54:54,310 --> 00:55:00,790
use of metadata of time series like if

00:54:58,330 --> 00:55:02,620
you go to the docs and then introduction

00:55:00,790 --> 00:55:05,320
and road map there's some items but

00:55:02,620 --> 00:55:10,450
they're fairly minor yeah I think the

00:55:05,320 --> 00:55:13,720
general scope is do you guys have plans

00:55:10,450 --> 00:55:15,730
to enhance the query engine or cuz right

00:55:13,720 --> 00:55:17,770
now it has a limit and some people have

00:55:15,730 --> 00:55:20,350
asked if you can increase the series

00:55:17,770 --> 00:55:23,620
limit all the 11 K points limit yeah

00:55:20,350 --> 00:55:25,060
well that so yeah I mean so you can

00:55:23,620 --> 00:55:27,400
actually get more points out if you want

00:55:25,060 --> 00:55:29,440
to have raw export by doing an instant

00:55:27,400 --> 00:55:32,110
query with a range vector for raw series

00:55:29,440 --> 00:55:34,450
you can do that just if you do a graph

00:55:32,110 --> 00:55:40,110
query for an actual graph then it is

00:55:34,450 --> 00:55:40,110
limiting you to 11,000 output points but

00:55:41,100 --> 00:55:45,220
okay so long time storage storage what

00:55:43,960 --> 00:55:47,710
I'm hearing that this may be an

00:55:45,220 --> 00:55:51,250
alternative from using a it's a Azure

00:55:47,710 --> 00:55:53,410
storage and if it is what is the

00:55:51,250 --> 00:55:59,890
capacity I mean can we hold a petabyte

00:55:53,410 --> 00:56:01,630
of data and can it be secure I could

00:55:59,890 --> 00:56:06,340
probably even answer that you mean like

00:56:01,630 --> 00:56:08,680
with any of these solutions yeah I think

00:56:06,340 --> 00:56:11,470
who trusts themselves to handle a

00:56:08,680 --> 00:56:19,080
petabyte yeah I mean we do better by it

00:56:11,470 --> 00:56:21,820
easily I mean it but it all depends on

00:56:19,080 --> 00:56:24,430
how big your boxes are and how many you

00:56:21,820 --> 00:56:26,790
have right I mean we are we have a lot

00:56:24,430 --> 00:56:30,040
of boxes I mean to give you an example I

00:56:26,790 --> 00:56:33,670
think one of our clusters has 250 nodes

00:56:30,040 --> 00:56:35,410
so we have 250 commodity boxes running 1

00:56:33,670 --> 00:56:35,869
& 3 DB cluster and we can add more and

00:56:35,410 --> 00:56:45,410
then

00:56:35,869 --> 00:56:47,900
give it more capacity so this is so we

00:56:45,410 --> 00:56:49,730
actually support variable retention and

00:56:47,900 --> 00:56:52,910
resolutions so the same cluster is

00:56:49,730 --> 00:56:56,329
handling different ones a default is 10

00:56:52,910 --> 00:57:04,460
seconds but we're sorry resolution is 10

00:56:56,329 --> 00:57:07,490
seconds and and retention is 2 weeks and

00:57:04,460 --> 00:57:09,829
we also do resolution one minute and

00:57:07,490 --> 00:57:12,529
retention one month but we actually have

00:57:09,829 --> 00:57:14,690
a use case wherein we provide five years

00:57:12,529 --> 00:57:18,220
worth of retention so that's the one

00:57:14,690 --> 00:57:18,220
which does the trip forecasting

00:57:30,020 --> 00:57:35,420
yeah I mean you can easily do one minute

00:57:32,690 --> 00:57:37,369
in six months if you like so I think one

00:57:35,420 --> 00:57:40,130
minute ability is a pretty reasonable

00:57:37,369 --> 00:57:41,869
resolution and I think more than six

00:57:40,130 --> 00:57:43,760
months of data you really need some

00:57:41,869 --> 00:57:46,460
other system needing it otherwise you

00:57:43,760 --> 00:57:48,440
don't really want to look at it I have a

00:57:46,460 --> 00:57:50,930
somewhat flippant answer which is tell

00:57:48,440 --> 00:57:52,730
them how much it's going to cost a lot

00:57:50,930 --> 00:57:55,030
of times people say I want maximum

00:57:52,730 --> 00:57:57,560
precision for infinite amount of time

00:57:55,030 --> 00:58:01,090
and say yes you can get that for this

00:57:57,560 --> 00:58:01,090
price and then they'll change their mind

00:58:01,240 --> 00:58:05,119
so we have we're pretty much out of time

00:58:03,860 --> 00:58:08,390
but we have one last question which

00:58:05,119 --> 00:58:10,430
already was assigned so go ahead yeah so

00:58:08,390 --> 00:58:12,670
just quickly I wanted to follow up on

00:58:10,430 --> 00:58:18,500
something that was just mentioned before

00:58:12,670 --> 00:58:21,670
about the various formats that I used to

00:58:18,500 --> 00:58:23,930
store like there was v1 now it's v2 and

00:58:21,670 --> 00:58:26,540
with long-term storage of course you

00:58:23,930 --> 00:58:29,720
have to ask yourself okay and now there

00:58:26,540 --> 00:58:32,180
is format these three parameters stops

00:58:29,720 --> 00:58:33,830
supporting all the older formats is it

00:58:32,180 --> 00:58:36,740
something that I don't know for your

00:58:33,830 --> 00:58:38,630
various versions of remote storage

00:58:36,740 --> 00:58:40,340
something that you already thought about

00:58:38,630 --> 00:58:43,520
how will you deal with this

00:58:40,340 --> 00:58:45,380
how will you convert all data or

00:58:43,520 --> 00:58:47,570
continue supporting the old storage

00:58:45,380 --> 00:58:49,550
format I think the only solution that

00:58:47,570 --> 00:58:51,230
has kind of problems that is tennis

00:58:49,550 --> 00:58:55,550
because you all have your own father in

00:58:51,230 --> 00:58:57,230
the end right yeah but you're basically

00:58:55,550 --> 00:59:05,270
free to decide when you change anything

00:58:57,230 --> 00:59:06,890
about it right yeah yeah and Thanos

00:59:05,270 --> 00:59:09,170
basic is actually copying the data in

00:59:06,890 --> 00:59:11,630
the storage format SS which can be a

00:59:09,170 --> 00:59:13,310
problem yes but it formed this Authority

00:59:11,630 --> 00:59:16,280
version right so whenever we add a new

00:59:13,310 --> 00:59:17,960
version we just leave another TCB

00:59:16,280 --> 00:59:20,330
library into thine house and then we can

00:59:17,960 --> 00:59:22,340
also read the new format that's so far a

00:59:20,330 --> 00:59:23,930
theory and you of course have to be

00:59:22,340 --> 00:59:24,890
careful that you don't upgrade your

00:59:23,930 --> 00:59:27,130
promises so what they don't produce

00:59:24,890 --> 00:59:30,680
unreadable data before you operate

00:59:27,130 --> 00:59:32,480
faster right and in theory if at some

00:59:30,680 --> 00:59:34,490
point Prometheus totally changes its

00:59:32,480 --> 00:59:35,960
format yeah then do you have to see

00:59:34,490 --> 00:59:42,550
what's gonna happen but I think that's

00:59:35,960 --> 00:59:42,550
very far away okay thank you very much

00:59:42,660 --> 00:59:49,620

YouTube URL: https://www.youtube.com/watch?v=3pTG_N8yGSU


