Title: PromCon 2018: Anatomy of a Prometheus Client Library
Publication date: 2018-11-10
Playlist: PromCon 2018
Description: 
	Speaker: Brian Brazil

Prometheus client libraries are notably different from most other options in the space. In order to get the best insights into your applications it helps to know how they are designed, and why they are designed that way. This talk will look at how client libraries are structured, how that makes them easy to use, some tips for instrumentation, and why you should use them even if you aren't using Prometheus.
Captions: 
	00:00:10,140 --> 00:00:16,320
I wasn't gonna quite cover - struck but

00:00:12,870 --> 00:00:18,630
how they're designed so I imagine most

00:00:16,320 --> 00:00:19,770
of you know me by now if there's

00:00:18,630 --> 00:00:21,330
something you like about paradius

00:00:19,770 --> 00:00:23,550
there's a good chance I had my hand in

00:00:21,330 --> 00:00:26,060
this if there's something you don't like

00:00:23,550 --> 00:00:26,060
about prometheus

00:00:28,250 --> 00:00:34,020
so client libraries are the core there

00:00:32,520 --> 00:00:36,230
of what actually generates these metrics

00:00:34,020 --> 00:00:39,270
that Prometheus and everyone else uses

00:00:36,230 --> 00:00:40,590
we've been building them and myself and

00:00:39,270 --> 00:00:42,329
many others like they existed before I

00:00:40,590 --> 00:00:45,270
was involved radius which is about four

00:00:42,329 --> 00:00:47,789
years ago and but by now we have a

00:00:45,270 --> 00:00:49,440
pretty good idea of how to design a

00:00:47,789 --> 00:00:51,539
client library what'd it look like

00:00:49,440 --> 00:00:52,620
we haven't figured out every single

00:00:51,539 --> 00:00:54,960
detail of what they should look like

00:00:52,620 --> 00:00:57,120
well we have most of the main stuff

00:00:54,960 --> 00:01:00,090
figured out so we're gonna dig into that

00:00:57,120 --> 00:01:02,550
a bit more so there's this notion that I

00:01:00,090 --> 00:01:03,809
call direct instrumentation and I think

00:01:02,550 --> 00:01:06,480
by now everyone else has figured out

00:01:03,809 --> 00:01:08,520
what I mean by that and but that is

00:01:06,480 --> 00:01:10,350
where you're using the counter type they

00:01:08,520 --> 00:01:12,030
a gauge type the history I'm and summary

00:01:10,350 --> 00:01:13,770
type the objects coming from a client

00:01:12,030 --> 00:01:15,420
library directly your application code

00:01:13,770 --> 00:01:17,939
your instantiation them you're using

00:01:15,420 --> 00:01:19,380
them directly this is against something

00:01:17,939 --> 00:01:21,630
called custom collectors which is

00:01:19,380 --> 00:01:23,280
basically an exporter where it's pulling

00:01:21,630 --> 00:01:25,500
it from some other monitoring system or

00:01:23,280 --> 00:01:27,869
some other instrumentation system so in

00:01:25,500 --> 00:01:30,119
the ideal world everyone is using direct

00:01:27,869 --> 00:01:32,490
instrumentation we do not live in an

00:01:30,119 --> 00:01:34,409
ideal world cuz we end up with things

00:01:32,490 --> 00:01:38,340
like yes a nippy exporter I maintain

00:01:34,409 --> 00:01:40,680
great fun but one principle we have then

00:01:38,340 --> 00:01:43,049
is okay here we have yet another

00:01:40,680 --> 00:01:46,140
instrumentation client one of the at

00:01:43,049 --> 00:01:47,610
least twenty that are out there what

00:01:46,140 --> 00:01:48,810
makes this one different uttered in fact

00:01:47,610 --> 00:01:51,060
that it has the word Prometheus in the

00:01:48,810 --> 00:01:53,009
name so one of the principles we have is

00:01:51,060 --> 00:01:55,200
that instrumentation should be as easy

00:01:53,009 --> 00:01:56,820
as possible all right you want to get

00:01:55,200 --> 00:01:57,930
instrumentation out of the way so you

00:01:56,820 --> 00:01:59,939
can actually implement your business

00:01:57,930 --> 00:02:01,350
logic because let's be honest most of us

00:01:59,939 --> 00:02:03,000
our job is not the right instrument

00:02:01,350 --> 00:02:06,990
ation it's to do something else that

00:02:03,000 --> 00:02:10,410
gives us money most of your metrics

00:02:06,990 --> 00:02:11,730
there will not have labels now most your

00:02:10,410 --> 00:02:13,860
time series will that's called the

00:02:11,730 --> 00:02:16,290
cardinality explosion however most your

00:02:13,860 --> 00:02:17,880
metrics don't so you should make simple

00:02:16,290 --> 00:02:20,340
things simple and being able to just

00:02:17,880 --> 00:02:23,550
sprinkle metrics of that labels across

00:02:20,340 --> 00:02:26,010
your code base should be trivial so here

00:02:23,550 --> 00:02:28,140
have a simple example of a counter cold

00:02:26,010 --> 00:02:30,120
my failures total which has some

00:02:28,140 --> 00:02:32,160
description we push it in an object

00:02:30,120 --> 00:02:33,990
called fails or capital because I happen

00:02:32,160 --> 00:02:36,060
to use PI for this example and be

00:02:33,990 --> 00:02:37,710
incremented and then you've got this you

00:02:36,060 --> 00:02:39,420
know normally this metric definition

00:02:37,710 --> 00:02:41,490
would be at the file or class level

00:02:39,420 --> 00:02:43,380
depending on your language and then you

00:02:41,490 --> 00:02:45,570
do the increment increment drink in your

00:02:43,380 --> 00:02:49,950
actual code that runs you know during

00:02:45,570 --> 00:02:54,000
runtime so looks nice and simple things

00:02:49,950 --> 00:02:56,130
to note slide 1 so what I did there is

00:02:54,000 --> 00:02:57,480
we created a counter cap the reference

00:02:56,130 --> 00:03:00,060
to its memory address so it's a counter

00:02:57,480 --> 00:03:01,530
object there and then later we use that

00:03:00,060 --> 00:03:02,970
reference to call a method honest using

00:03:01,530 --> 00:03:04,640
presumably a virtual lookup table or

00:03:02,970 --> 00:03:07,680
whoever pythons implemented internally

00:03:04,640 --> 00:03:10,580
what we don't do is go from ETS thought

00:03:07,680 --> 00:03:13,470
Inc my counter name and then the value

00:03:10,580 --> 00:03:16,290
so there are instrument labrys out there

00:03:13,470 --> 00:03:20,070
to do this now the reason why we don't

00:03:16,290 --> 00:03:22,560
do this is that it's slower because if

00:03:20,070 --> 00:03:24,030
I'm passing a metric name I now need to

00:03:22,560 --> 00:03:25,620
look that up in some form of tread safe

00:03:24,030 --> 00:03:28,560
map to find the object to then

00:03:25,620 --> 00:03:30,330
incremented which is you know it's gonna

00:03:28,560 --> 00:03:33,330
cost you 30 nanoseconds at least an

00:03:30,330 --> 00:03:35,700
enormous fermentation event is 1012

00:03:33,330 --> 00:03:37,230
nanoseconds not in Python unfortunately

00:03:35,700 --> 00:03:40,110
because Python new taxes are slow they

00:03:37,230 --> 00:03:44,010
take a microsecond but anyway in Java

00:03:40,110 --> 00:03:45,480
and go it's much faster the second thing

00:03:44,010 --> 00:03:47,160
is that if you have this sort of pattern

00:03:45,480 --> 00:03:48,450
where you're passing in that name rather

00:03:47,160 --> 00:03:51,180
than just having the reference already

00:03:48,450 --> 00:03:54,870
it kind of encourages having the same

00:03:51,180 --> 00:03:57,630
metric name in different files now there

00:03:54,870 --> 00:04:00,060
are cases extremely rare like I came

00:03:57,630 --> 00:04:00,959
across to ever I think or it is okay to

00:04:00,060 --> 00:04:03,300
have the same metric name in different

00:04:00,959 --> 00:04:05,430
files well by and large different file

00:04:03,300 --> 00:04:07,440
different metric name because any metric

00:04:05,430 --> 00:04:09,630
name you have is fundamentally licking

00:04:07,440 --> 00:04:11,970
linking back to a piece of code in a

00:04:09,630 --> 00:04:13,410
file so how can refer to two different

00:04:11,970 --> 00:04:16,530
files with two different sets of logic

00:04:13,410 --> 00:04:18,030
and semantics and implications another

00:04:16,530 --> 00:04:20,940
advantage of the formaiities approach is

00:04:18,030 --> 00:04:22,860
let's say that whatever be the code this

00:04:20,940 --> 00:04:24,960
with some weird error path that is never

00:04:22,860 --> 00:04:26,520
meant to happen because you know it's

00:04:24,960 --> 00:04:28,050
good to have some form of

00:04:26,520 --> 00:04:30,480
instrumentation where it be a log line

00:04:28,050 --> 00:04:31,919
or a metric or something saying hey this

00:04:30,480 --> 00:04:37,340
weird thing never meant to happen it

00:04:31,919 --> 00:04:38,810
happened if you have a previous approach

00:04:37,340 --> 00:04:41,090
can say hey this metric has been

00:04:38,810 --> 00:04:43,310
instantiated we'll set it to zero so we

00:04:41,090 --> 00:04:44,630
know it exists well the error approach

00:04:43,310 --> 00:04:46,310
when you only learn about the existence

00:04:44,630 --> 00:04:49,010
of the metric when you increment it that

00:04:46,310 --> 00:04:50,330
doesn't happen and that's difficult to

00:04:49,010 --> 00:04:52,010
deal with impromptu are in general

00:04:50,330 --> 00:04:52,729
because you know what metrics do and

00:04:52,010 --> 00:04:54,889
don't exist

00:04:52,729 --> 00:04:57,050
you can't graph something if you don't

00:04:54,889 --> 00:04:58,340
know its name at least it's something

00:04:57,050 --> 00:05:03,770
later on but fine I can do something

00:04:58,340 --> 00:05:05,419
fancy we're just another thing that I

00:05:03,770 --> 00:05:06,940
showed my example for some reason I was

00:05:05,419 --> 00:05:09,169
in incrementing my failure count by 4

00:05:06,940 --> 00:05:10,790
which is nonsensical normally because

00:05:09,169 --> 00:05:13,760
it's one at a time but I needed an

00:05:10,790 --> 00:05:16,760
example so per Matthias it's also 64 is

00:05:13,760 --> 00:05:18,710
internally so it means we were counters

00:05:16,760 --> 00:05:20,450
contract Tings other than hey how many

00:05:18,710 --> 00:05:22,280
errors we can have and say hey how many

00:05:20,450 --> 00:05:24,710
records did I just process how many

00:05:22,280 --> 00:05:28,160
bytes was it how long did this take so

00:05:24,710 --> 00:05:30,320
you can track more than just a ting

00:05:28,160 --> 00:05:32,960
happened a ting happened at ting happen

00:05:30,320 --> 00:05:35,960
who say I Ching happened and it took 20

00:05:32,960 --> 00:05:37,550
seconds to process four records so we

00:05:35,960 --> 00:05:39,650
can get more information into the system

00:05:37,550 --> 00:05:40,850
now the other thing is those two lines

00:05:39,650 --> 00:05:43,220
of code which you can see again there

00:05:40,850 --> 00:05:44,750
that's everything there is no more code

00:05:43,220 --> 00:05:46,550
required for instant Asian you don't

00:05:44,750 --> 00:05:48,350
have to implement any shredding or

00:05:46,550 --> 00:05:50,570
concurrency or bookkeeping it's all

00:05:48,350 --> 00:05:52,520
taken care of for you so it's just two

00:05:50,570 --> 00:05:54,950
lines cause probably an import to get

00:05:52,520 --> 00:05:56,870
everything working so those two lines

00:05:54,950 --> 00:05:58,520
they have a lot of details in there like

00:05:56,870 --> 00:06:03,590
five different aspects in just two lines

00:05:58,520 --> 00:06:05,289
of code now in addition to the counter

00:06:03,590 --> 00:06:07,910
it is also de gauged in the summary

00:06:05,289 --> 00:06:09,200
internally all of these are just a set

00:06:07,910 --> 00:06:12,260
of phone quick numbers I'm just an

00:06:09,200 --> 00:06:14,450
asterisk there and we just adjust these

00:06:12,260 --> 00:06:16,190
numbers up or down or set them okay

00:06:14,450 --> 00:06:18,320
something that people get confused by

00:06:16,190 --> 00:06:19,910
often is that per medias internally is

00:06:18,320 --> 00:06:21,470
not remembering every single increment

00:06:19,910 --> 00:06:23,330
it doesn't buffering things up a memory

00:06:21,470 --> 00:06:25,490
because this is not an event based

00:06:23,330 --> 00:06:27,380
system it's a metric space system so

00:06:25,490 --> 00:06:29,389
increment basically looks like fashion

00:06:27,380 --> 00:06:31,520
we take the current value and we add

00:06:29,389 --> 00:06:34,039
onto it that's all that's true to

00:06:31,520 --> 00:06:35,330
increment bus thread safety plus making

00:06:34,039 --> 00:06:39,860
sure to by use it you know zero or

00:06:35,330 --> 00:06:41,240
larger in terms of the summary like the

00:06:39,860 --> 00:06:42,800
gauge is a single float great number

00:06:41,240 --> 00:06:44,900
nice and simple the summary is two

00:06:42,800 --> 00:06:46,490
counters and potentially client-side

00:06:44,900 --> 00:06:49,010
quantiles which are complicated and

00:06:46,490 --> 00:06:51,200
welcome to touch and history I'm is two

00:06:49,010 --> 00:06:52,670
counters plus the counter for buckets so

00:06:51,200 --> 00:06:54,500
it's just a big pile of counters in

00:06:52,670 --> 00:06:56,360
gauges basically for everything and

00:06:54,500 --> 00:06:57,920
wanting to watch the history um

00:06:56,360 --> 00:07:00,230
exhibition format it heat is cumulative

00:06:57,920 --> 00:07:02,210
the Ali stands for less than or equal to

00:07:00,230 --> 00:07:05,030
and but in memory we keep it

00:07:02,210 --> 00:07:05,900
non-cumulative except in Ruby AB just to

00:07:05,030 --> 00:07:08,690
reduce contention

00:07:05,900 --> 00:07:09,830
so that can confuse many people it's

00:07:08,690 --> 00:07:10,970
like it's an to be accumulative but it's

00:07:09,830 --> 00:07:12,980
up in the code it's like yeah but you

00:07:10,970 --> 00:07:15,500
switch it over here implementation

00:07:12,980 --> 00:07:18,260
details and one of the downsides of our

00:07:15,500 --> 00:07:19,790
choice of how we make his drums work

00:07:18,260 --> 00:07:22,880
with our constraints is that the book is

00:07:19,790 --> 00:07:26,740
mostly free chosen people don't like

00:07:22,880 --> 00:07:26,740
that but it makes sense for reasons

00:07:26,890 --> 00:07:30,590
we've got constraints you know there's

00:07:29,120 --> 00:07:31,690
other designs out there by way front of

00:07:30,590 --> 00:07:33,560
an interesting design for example

00:07:31,690 --> 00:07:37,880
interesting isn't good to be here

00:07:33,560 --> 00:07:39,740
and now what something it's different

00:07:37,880 --> 00:07:40,910
because I've looked at a whole pile of

00:07:39,740 --> 00:07:43,010
instrumentation libraries out there

00:07:40,910 --> 00:07:45,350
mostly to figure out how do we get data

00:07:43,010 --> 00:07:48,050
from this instrumentation system into

00:07:45,350 --> 00:07:49,460
Prometheus or vice versa and like one of

00:07:48,050 --> 00:07:51,770
those popular libraries out there is

00:07:49,460 --> 00:07:52,880
drop wizard and it has a whole pile of

00:07:51,770 --> 00:07:55,820
derivatives and all sorts of languages

00:07:52,880 --> 00:07:58,130
and so an interesting thing like the way

00:07:55,820 --> 00:07:59,960
I view drop Wizard is that it's metrics

00:07:58,130 --> 00:08:02,300
types are defined by the API they offer

00:07:59,960 --> 00:08:05,150
not the actual semantics when it

00:08:02,300 --> 00:08:07,160
actually lands inside the database so in

00:08:05,150 --> 00:08:09,410
drop wizard a counter can be incremented

00:08:07,160 --> 00:08:12,680
or decremented by one that's all you can

00:08:09,410 --> 00:08:14,180
do it and a gauge is something that has

00:08:12,680 --> 00:08:16,960
a callback that you have gonna have to

00:08:14,180 --> 00:08:19,070
implement all your tread safety for in

00:08:16,960 --> 00:08:20,570
prometheus both of those are gauges

00:08:19,070 --> 00:08:22,820
because well it's a thing that can go up

00:08:20,570 --> 00:08:24,350
and down because we think about a gauges

00:08:22,820 --> 00:08:26,600
go up and down calendars we care about

00:08:24,350 --> 00:08:29,090
how fast are increasing so it's not kind

00:08:26,600 --> 00:08:30,680
of mismatch there of just what we say

00:08:29,090 --> 00:08:32,540
metric type what are we're talking at

00:08:30,680 --> 00:08:33,770
the API we're using or whether we're

00:08:32,540 --> 00:08:35,720
talking about the actual semantics of

00:08:33,770 --> 00:08:36,830
the number that comes out of it there's

00:08:35,720 --> 00:08:38,450
something we'll be aware of because it's

00:08:36,830 --> 00:08:40,250
one of those impedance mismatches like

00:08:38,450 --> 00:08:41,390
the red kimono string or logging or

00:08:40,250 --> 00:08:43,910
different people who mean different

00:08:41,390 --> 00:08:46,250
things and this brings us to the

00:08:43,910 --> 00:08:48,470
question of where is the timer type in a

00:08:46,250 --> 00:08:50,840
previous client library there isn't one

00:08:48,470 --> 00:08:53,600
because well timers are just a special

00:08:50,840 --> 00:08:55,730
case of tracking events as an event size

00:08:53,600 --> 00:08:56,750
which is how long it takes so you got

00:08:55,730 --> 00:08:58,700
the summary of the histogram for that

00:08:56,750 --> 00:08:59,900
already and what we do rather than

00:08:58,700 --> 00:09:02,240
having a special timer

00:08:59,900 --> 00:09:03,770
we just say hey here's a poly utility

00:09:02,240 --> 00:09:04,940
Matt it's to make it easier to work with

00:09:03,770 --> 00:09:07,370
times and so

00:09:04,940 --> 00:09:09,020
mr. M because let's be honest the vast

00:09:07,370 --> 00:09:11,600
majority of some reason histories are

00:09:09,020 --> 00:09:14,150
used for timing Tings so here's a Python

00:09:11,600 --> 00:09:15,740
example we just got a context manager

00:09:14,150 --> 00:09:17,450
there and the other languages have their

00:09:15,740 --> 00:09:18,920
own equivalents like this was a try

00:09:17,450 --> 00:09:19,340
resources in job we managed to get

00:09:18,920 --> 00:09:21,500
working

00:09:19,340 --> 00:09:23,180
and in general we all used to use

00:09:21,500 --> 00:09:25,520
seconds in Prometheus because you just

00:09:23,180 --> 00:09:27,410
need a standard how many people have

00:09:25,520 --> 00:09:29,510
looked at a graph and any monitoring

00:09:27,410 --> 00:09:34,580
system and you have no idea whatever

00:09:29,510 --> 00:09:36,830
it's milliseconds or seconds yeah so

00:09:34,580 --> 00:09:38,300
yeah but the premedia says seconds is

00:09:36,830 --> 00:09:40,460
the convention please push to metric

00:09:38,300 --> 00:09:42,410
came in anyway and remember no one's

00:09:40,460 --> 00:09:44,330
perfect on show pretty at one point

00:09:42,410 --> 00:09:46,460
three DS itself was exporting four

00:09:44,330 --> 00:09:48,680
different time units nanoseconds

00:09:46,460 --> 00:09:53,090
microseconds 30 seconds and seconds as

00:09:48,680 --> 00:09:55,870
if I tink to to tree we only have

00:09:53,090 --> 00:09:57,950
seconds it only took three years to fix

00:09:55,870 --> 00:09:59,360
but you know this is the sort of thing

00:09:57,950 --> 00:10:03,230
where it just causes confusion and it's

00:09:59,360 --> 00:10:04,970
like what units that again and now I

00:10:03,230 --> 00:10:06,320
haven't touched labels yes which next

00:10:04,970 --> 00:10:08,180
week here are a killer feature of

00:10:06,320 --> 00:10:10,190
Prometheus because of the analysis they

00:10:08,180 --> 00:10:12,260
allowed you to do and they're well

00:10:10,190 --> 00:10:14,150
they're key value pairs and here we've

00:10:12,260 --> 00:10:15,860
an example this is once again a Titan

00:10:14,150 --> 00:10:17,900
example it's got one label called path

00:10:15,860 --> 00:10:20,480
and to use it that line when the

00:10:17,900 --> 00:10:22,850
monitors is really nice we just go fails

00:10:20,480 --> 00:10:26,060
dot labels or /foo than your normal

00:10:22,850 --> 00:10:27,770
increment wanting to be aware of as you

00:10:26,060 --> 00:10:30,200
can see here in the definition I must

00:10:27,770 --> 00:10:31,640
provide my label Ames the reason why is

00:10:30,200 --> 00:10:33,050
well if you don't know your de baloneys

00:10:31,640 --> 00:10:34,640
in advance you're probably doing event

00:10:33,050 --> 00:10:36,230
logging because we're not working with

00:10:34,640 --> 00:10:37,910
arbitrary data I can change over time

00:10:36,230 --> 00:10:39,620
working metrics which have some

00:10:37,910 --> 00:10:43,940
structure and some continuity over time

00:10:39,620 --> 00:10:47,420
and then we get to a little human tation

00:10:43,940 --> 00:10:49,810
detail for whatever reason whatever I

00:10:47,420 --> 00:10:52,820
was drinking is time it was probably t

00:10:49,810 --> 00:10:55,550
return value of a labels call or if

00:10:52,820 --> 00:10:57,560
you're using go it'll be the with label

00:10:55,550 --> 00:11:00,020
values netted there it's called the

00:10:57,560 --> 00:11:03,710
child because it's I forget why I call

00:11:00,020 --> 00:11:05,600
the dash and then internally each metric

00:11:03,710 --> 00:11:09,320
in has at read safe map that it looks

00:11:05,600 --> 00:11:11,060
these up in um and you know it doesn't

00:11:09,320 --> 00:11:11,990
exist it'll create one because normally

00:11:11,060 --> 00:11:13,460
you don't want have to go and have a

00:11:11,990 --> 00:11:15,290
separate call and habits you like four

00:11:13,460 --> 00:11:18,230
lines of code captioning exception to

00:11:15,290 --> 00:11:20,360
create it it does it for you

00:11:18,230 --> 00:11:23,270
it is safe to Castries child objects and

00:11:20,360 --> 00:11:25,130
in some cases you know as I said

00:11:23,270 --> 00:11:27,230
previously you don't want to look up by

00:11:25,130 --> 00:11:28,880
metric name every time in the same way

00:11:27,230 --> 00:11:31,400
you don't want to look up by label value

00:11:28,880 --> 00:11:33,650
every time which isn't always possible

00:11:31,400 --> 00:11:36,470
but sometimes it is like let's say you

00:11:33,650 --> 00:11:38,720
had a Catholic half a client that was

00:11:36,470 --> 00:11:40,580
talking to one topic and your metrics

00:11:38,720 --> 00:11:42,500
are written written out by topic well

00:11:40,580 --> 00:11:44,630
your Kafka object already knows the name

00:11:42,500 --> 00:11:46,400
of topic so it can then just say hey I'm

00:11:44,630 --> 00:11:48,230
gonna cash all the metrics all the

00:11:46,400 --> 00:11:50,810
child's for that topic and and then it's

00:11:48,230 --> 00:11:52,490
a free lookup if you got a HTTP user

00:11:50,810 --> 00:11:53,440
well your path is gonna vary all the

00:11:52,490 --> 00:11:55,580
time you can't do that

00:11:53,440 --> 00:11:57,890
and remember to go here is to avoid

00:11:55,580 --> 00:11:59,720
potentially a lookup in a map so there's

00:11:57,890 --> 00:12:01,160
no point creating a map because that's

00:11:59,720 --> 00:12:04,210
what we were trying to avoid you just

00:12:01,160 --> 00:12:07,580
have to take that three nine a second -

00:12:04,210 --> 00:12:09,980
and then the child's in general like in

00:12:07,580 --> 00:12:11,960
principle in the ideal world or

00:12:09,980 --> 00:12:13,970
everything's rainbows and unicorns and

00:12:11,960 --> 00:12:16,190
we would assure that every time series

00:12:13,970 --> 00:12:18,740
you care about it starts to exist from

00:12:16,190 --> 00:12:20,050
the process starts and it continues to

00:12:18,740 --> 00:12:22,910
exist until the process terminates

00:12:20,050 --> 00:12:25,460
that's the right deal world because

00:12:22,910 --> 00:12:26,960
metrics step never exists or only exists

00:12:25,460 --> 00:12:31,040
sometimes are really really annoying to

00:12:26,960 --> 00:12:32,570
deal with so in the case of well writing

00:12:31,040 --> 00:12:33,830
client you which are just at your

00:12:32,570 --> 00:12:36,500
definition time if you're certain labels

00:12:33,830 --> 00:12:39,020
you know exist tell us they exist the

00:12:36,500 --> 00:12:40,970
reason why is let's say that you had and

00:12:39,020 --> 00:12:43,940
this is not recommended for among this

00:12:40,970 --> 00:12:46,370
reason a counter broken out by successes

00:12:43,940 --> 00:12:48,410
and failures and you were calculating

00:12:46,370 --> 00:12:49,880
your failure ratio for an orange so

00:12:48,410 --> 00:12:54,920
that's failure is over successes plus

00:12:49,880 --> 00:12:58,300
failures if you have no successes the

00:12:54,920 --> 00:13:02,720
child for successes will never exist and

00:12:58,300 --> 00:13:06,020
empty vector and failures recluses empty

00:13:02,720 --> 00:13:09,170
vector failure is divided by empty

00:13:06,020 --> 00:13:10,670
vector is empty vector if you put hast

00:13:09,170 --> 00:13:14,300
into an empty vector into a learning

00:13:10,670 --> 00:13:15,530
rule you get no alerts so you can

00:13:14,300 --> 00:13:17,090
imagine other ways that can happen like

00:13:15,530 --> 00:13:18,380
that's the worst case but you try to

00:13:17,090 --> 00:13:20,780
want to make sure there's at least one

00:13:18,380 --> 00:13:23,720
child in there so at least something's

00:13:20,780 --> 00:13:25,130
there and there is also to mention there

00:13:23,720 --> 00:13:27,860
is a remove message as well you should

00:13:25,130 --> 00:13:30,170
get rid of childs and I've come across

00:13:27,860 --> 00:13:31,400
two valid use cases for this ever one of

00:13:30,170 --> 00:13:34,070
them was presented here last year

00:13:31,400 --> 00:13:37,190
and but generally only ever used after

00:13:34,070 --> 00:13:39,500
unit tests now we're talking about all

00:13:37,190 --> 00:13:40,700
these objects that we have and let's be

00:13:39,500 --> 00:13:42,920
honest I have a gauge in the counter

00:13:40,700 --> 00:13:44,900
sitting in memory that's not

00:13:42,920 --> 00:13:48,140
particularly useful I want to get that

00:13:44,900 --> 00:13:49,850
data into Prometheus somehow and then so

00:13:48,140 --> 00:13:53,030
I can get a pages and so on and get paid

00:13:49,850 --> 00:13:54,170
and the exact details vary by library

00:13:53,030 --> 00:13:56,270
but there's an earnest thing called a

00:13:54,170 --> 00:13:58,010
registry or in Java it's called a

00:13:56,270 --> 00:13:59,770
collector registry because I wasn't

00:13:58,010 --> 00:14:02,870
being consistent that day unfortunately

00:13:59,770 --> 00:14:04,430
and registers do power sanity checks and

00:14:02,870 --> 00:14:05,870
they hold all these metrics objects all

00:14:04,430 --> 00:14:07,340
these counters and gauges are registered

00:14:05,870 --> 00:14:09,860
in there which is why it's called a

00:14:07,340 --> 00:14:11,930
registry and it also note from a

00:14:09,860 --> 00:14:13,510
responsibility standpoint registries do

00:14:11,930 --> 00:14:16,130
not produce the exhibition format

00:14:13,510 --> 00:14:17,810
instead what they do is they just have a

00:14:16,130 --> 00:14:19,130
list of stuff and you say hey give me

00:14:17,810 --> 00:14:21,620
all your metrics and it gives there to

00:14:19,130 --> 00:14:23,930
some internal representation and then

00:14:21,620 --> 00:14:25,310
you can do things with that and I was

00:14:23,930 --> 00:14:27,230
mentioning the word collector there and

00:14:25,310 --> 00:14:28,610
I'm not gonna explain what collector

00:14:27,230 --> 00:14:31,610
actually is because you really shouldn't

00:14:28,610 --> 00:14:33,620
use words before defining them because

00:14:31,610 --> 00:14:35,000
all counters summaries gauges and so on

00:14:33,620 --> 00:14:37,280
those are a type of collector that

00:14:35,000 --> 00:14:39,320
return one metric and are nice and

00:14:37,280 --> 00:14:40,820
simple but you can also have the custom

00:14:39,320 --> 00:14:43,160
collectors which is just a terminology

00:14:40,820 --> 00:14:46,070
and they can return as many things as

00:14:43,160 --> 00:14:47,060
they like and they do things that you

00:14:46,070 --> 00:14:48,530
just cannot do with direct

00:14:47,060 --> 00:14:50,240
instrumentation which is basically

00:14:48,530 --> 00:14:52,670
proxying data from other instrumentation

00:14:50,240 --> 00:14:53,990
and monitoring systems and this entire

00:14:52,670 --> 00:14:56,000
system is all meant to be call back

00:14:53,990 --> 00:14:57,350
based because well Prometheus comes in

00:14:56,000 --> 00:14:59,120
and scrapes we fetched it outta do all

00:14:57,350 --> 00:15:01,670
the callbacks marshallers all up and

00:14:59,120 --> 00:15:04,370
send it back through medias so one

00:15:01,670 --> 00:15:07,040
example of a collector custom collector

00:15:04,370 --> 00:15:08,180
is the standard exports which I really

00:15:07,040 --> 00:15:09,620
should have named standard collectors

00:15:08,180 --> 00:15:12,890
but oh well that was several years ago

00:15:09,620 --> 00:15:15,110
and so if you would notice pretty much

00:15:12,890 --> 00:15:16,400
any Prometheus binary or Prometheus

00:15:15,110 --> 00:15:17,960
instrumented binary if it is running in

00:15:16,400 --> 00:15:20,540
the mix anyway but of a metric called

00:15:17,960 --> 00:15:22,940
process CPU seconds total now you'll

00:15:20,540 --> 00:15:25,490
remember you know about 15 slides and 20

00:15:22,940 --> 00:15:26,870
years ago I mentioned that you know you

00:15:25,490 --> 00:15:27,920
should never have the same metric name

00:15:26,870 --> 00:15:29,810
and come from two different pieces of

00:15:27,920 --> 00:15:31,850
code but some of these are coming from

00:15:29,810 --> 00:15:33,490
the Java client from the go client from

00:15:31,850 --> 00:15:35,870
the Python client the Ruby client and

00:15:33,490 --> 00:15:36,830
the reason why you cannot have things

00:15:35,870 --> 00:15:38,510
sharing the same metric name is

00:15:36,830 --> 00:15:41,060
different code is because they have soft

00:15:38,510 --> 00:15:42,550
least different semantics in the case of

00:15:41,060 --> 00:15:44,810
these process underscore metrics

00:15:42,550 --> 00:15:46,779
basically there is a standard defi

00:15:44,810 --> 00:15:50,330
and that these have these exact meanings

00:15:46,779 --> 00:15:51,620
that on a UNIX system so then anyone

00:15:50,330 --> 00:15:54,020
who's using these names has to follow

00:15:51,620 --> 00:15:56,029
these exact semantics so that's how

00:15:54,020 --> 00:15:57,320
those work and client libraries also

00:15:56,029 --> 00:15:59,810
normally have stuff like what version

00:15:57,320 --> 00:16:01,760
ago you used and you know what version

00:15:59,810 --> 00:16:05,360
the JVM and so on that's garbage

00:16:01,760 --> 00:16:07,220
collection now there is a default

00:16:05,360 --> 00:16:08,720
registry that normally if you create a

00:16:07,220 --> 00:16:10,160
metric depending on client library

00:16:08,720 --> 00:16:12,980
because different languages are

00:16:10,160 --> 00:16:15,290
different and you register in two - all

00:16:12,980 --> 00:16:16,610
happens off by magic you can use a

00:16:15,290 --> 00:16:18,440
custom registry from usually more

00:16:16,610 --> 00:16:21,410
special you pretty much have to use that

00:16:18,440 --> 00:16:23,870
push gateway and well let's be honest a

00:16:21,410 --> 00:16:26,750
default global registry is global

00:16:23,870 --> 00:16:29,750
mutable stage and global mutable state

00:16:26,750 --> 00:16:30,800
has been abused horrendously over the

00:16:29,750 --> 00:16:34,580
last several decades

00:16:30,800 --> 00:16:36,680
like since before I was born so there

00:16:34,580 --> 00:16:38,690
are people who say you know this is w

00:16:36,680 --> 00:16:41,210
mutable state therefore is automatically

00:16:38,690 --> 00:16:43,250
bad I say don't say that if you don't

00:16:41,210 --> 00:16:44,660
like this design that's fine you can use

00:16:43,250 --> 00:16:46,550
your custom registries and pass them all

00:16:44,660 --> 00:16:49,280
the way true but be aware there are pros

00:16:46,550 --> 00:16:51,080
and cons don't just slate design just

00:16:49,280 --> 00:16:55,250
because well other people have similar

00:16:51,080 --> 00:16:57,650
designs that were a bad idea and though

00:16:55,250 --> 00:17:00,560
we actually need the out push so you

00:16:57,650 --> 00:17:02,300
know it's HTTP request we take it in we

00:17:00,560 --> 00:17:04,280
get the metrics and we write where the

00:17:02,300 --> 00:17:05,839
output and as I mentioned this is a

00:17:04,280 --> 00:17:08,089
public API the registry this is no

00:17:05,839 --> 00:17:09,800
private internal interface so you can do

00:17:08,089 --> 00:17:11,390
whatever you want with this if you don't

00:17:09,800 --> 00:17:13,040
want to send it out to Prometheus you

00:17:11,390 --> 00:17:15,199
could you know if you're marshalling

00:17:13,040 --> 00:17:17,089
dope net ryx or you could send it to

00:17:15,199 --> 00:17:19,010
graphite sheave examples for because in

00:17:17,089 --> 00:17:20,750
general Prometheus giants are not trying

00:17:19,010 --> 00:17:22,490
to lock you in we I really like

00:17:20,750 --> 00:17:24,199
personally that we had like cystic on

00:17:22,490 --> 00:17:25,850
earlier talking about how it saves them

00:17:24,199 --> 00:17:27,800
so much effort having to write all these

00:17:25,850 --> 00:17:29,870
exporters and that's wonderful because

00:17:27,800 --> 00:17:31,520
with all these monitoring systems both

00:17:29,870 --> 00:17:33,440
closed and open let's compete on

00:17:31,520 --> 00:17:36,070
interesting things else who is the best

00:17:33,440 --> 00:17:36,070
stamp collection

00:17:36,100 --> 00:17:41,030
now previous is very opinionated and

00:17:39,140 --> 00:17:43,310
there are things the client libraries

00:17:41,030 --> 00:17:45,590
explicitly do not do because they don't

00:17:43,310 --> 00:17:47,330
make sense so for example setting a

00:17:45,590 --> 00:17:49,100
metric name prefix on all your exposed

00:17:47,330 --> 00:17:51,710
metrics or adding a label to all exposed

00:17:49,100 --> 00:17:53,270
metrics whoa in previous terms that's

00:17:51,710 --> 00:17:54,980
called a target table which is you do

00:17:53,270 --> 00:17:57,410
really abling on the previous side so

00:17:54,980 --> 00:17:58,610
client libraries don't - - you can't

00:17:57,410 --> 00:17:59,720
very label names in the metric

00:17:58,610 --> 00:18:01,790
because that's something for event

00:17:59,720 --> 00:18:03,650
logging being able to set a counter does

00:18:01,790 --> 00:18:05,630
not make sense the only increment is you

00:18:03,650 --> 00:18:07,610
want a custom collector pushing

00:18:05,630 --> 00:18:08,600
regularly to push gateway committee this

00:18:07,610 --> 00:18:10,730
is a pool bait system

00:18:08,600 --> 00:18:13,070
don't try - and setting a time stamp on

00:18:10,730 --> 00:18:14,299
direct instrumentation generally there

00:18:13,070 --> 00:18:15,590
are cases for using time stamps it

00:18:14,299 --> 00:18:16,940
shouldn't generally be doing it you're

00:18:15,590 --> 00:18:20,750
probably looking for a push system or

00:18:16,940 --> 00:18:22,190
not setting a time stamp to look a bit

00:18:20,750 --> 00:18:24,679
towards the future so you already had to

00:18:22,190 --> 00:18:26,299
talk about open metrics and weirdish you

00:18:24,679 --> 00:18:27,890
know over the last three years years

00:18:26,299 --> 00:18:29,450
there have been some patterns that have

00:18:27,890 --> 00:18:30,770
appeared in Prometheus and we were

00:18:29,450 --> 00:18:33,320
basically now making them first-class

00:18:30,770 --> 00:18:34,940
within the client libraries basically

00:18:33,320 --> 00:18:36,440
ways of dealing with strings which are

00:18:34,940 --> 00:18:37,610
the info metrics like per medias build

00:18:36,440 --> 00:18:40,190
info you might be familiar with and

00:18:37,610 --> 00:18:42,140
enums so these roles are there's also a

00:18:40,190 --> 00:18:44,000
gauge histogram which has come up like

00:18:42,140 --> 00:18:46,340
three times I might have seen a fort in

00:18:44,000 --> 00:18:47,660
one of the slides um but this is

00:18:46,340 --> 00:18:49,309
basically gonna be a transparent change

00:18:47,660 --> 00:18:51,530
you will not notice the difference

00:18:49,309 --> 00:18:53,120
someday you'll upgrade your client

00:18:51,530 --> 00:18:54,860
libraries and Prometheus and they'll

00:18:53,120 --> 00:18:59,299
start talking open metrics and you will

00:18:54,860 --> 00:19:00,919
not notice except and the one difference

00:18:59,299 --> 00:19:02,750
that you're actually all likely to

00:19:00,919 --> 00:19:04,580
notice if you have counters that are

00:19:02,750 --> 00:19:06,950
currently missing or underscore total

00:19:04,580 --> 00:19:08,809
that's going to be there now so that's

00:19:06,950 --> 00:19:10,730
the only breaking change that's really

00:19:08,809 --> 00:19:12,860
gonna affect people just but there's

00:19:10,730 --> 00:19:14,690
reasons we need to do this but otherwise

00:19:12,860 --> 00:19:18,110
this is gonna be transparent change and

00:19:14,690 --> 00:19:22,610
everyone will be happy so here I have

00:19:18,110 --> 00:19:25,360
links and if anyone has questions 18

00:19:22,610 --> 00:19:25,360
minutes wonderful

00:19:28,720 --> 00:19:39,530
first time I ran this talk to 22 minutes

00:19:31,970 --> 00:19:44,570
second was 20 minutes this look 18 that

00:19:39,530 --> 00:19:47,750
was me try to speak slowly heights you

00:19:44,570 --> 00:19:50,510
mentioned that internally all client

00:19:47,750 --> 00:19:52,550
libraries have their histograms saved in

00:19:50,510 --> 00:19:56,809
a non cumulative fashion except for the

00:19:52,550 --> 00:19:58,370
Ruby one out of curiosity why well the

00:19:56,809 --> 00:19:59,660
Ruby giant has no locking at the moment

00:19:58,370 --> 00:20:02,240
and that's just the way it's implemented

00:19:59,660 --> 00:20:04,220
it just increments all the buckets

00:20:02,240 --> 00:20:06,770
yeah the Ruby client it needs to be

00:20:04,220 --> 00:20:08,750
reworked at some point I did Java client

00:20:06,770 --> 00:20:10,130
all got rewritten as well like over the

00:20:08,750 --> 00:20:11,540
three and a half years ago by me because

00:20:10,130 --> 00:20:14,690
you know we just need to be updated for

00:20:11,540 --> 00:20:18,140
the future at the time was just the same

00:20:14,690 --> 00:20:20,570
confuses people regularly hi thanks for

00:20:18,140 --> 00:20:22,250
the talk you mentioned that we shouldn't

00:20:20,570 --> 00:20:24,309
be adding base labels to things like

00:20:22,250 --> 00:20:27,950
those consider kind of an anti-pattern

00:20:24,309 --> 00:20:29,840
but this is kind of the examples that

00:20:27,950 --> 00:20:31,250
you've even work in a shared memory sort

00:20:29,840 --> 00:20:32,960
of process but when you have something

00:20:31,250 --> 00:20:34,790
like a forking server and you don't have

00:20:32,960 --> 00:20:36,380
shared memory between them what's your

00:20:34,790 --> 00:20:38,059
advice for kind of aggregating those

00:20:36,380 --> 00:20:42,080
metrics and exposing them from all the

00:20:38,059 --> 00:20:46,280
individual processes yeah so and this is

00:20:42,080 --> 00:20:48,290
a yeah so this is a complex problem

00:20:46,280 --> 00:20:49,460
because Prometheus is designed for a

00:20:48,290 --> 00:20:51,350
model where your language is

00:20:49,460 --> 00:20:54,320
multi-threaded and we can share memory

00:20:51,350 --> 00:20:57,410
and then you get things like unicorn and

00:20:54,320 --> 00:20:59,809
so on so the solution guy I've proposed

00:20:57,410 --> 00:21:01,700
over in Python is basically every

00:20:59,809 --> 00:21:03,590
process ends up with an ax mapped file

00:21:01,700 --> 00:21:05,150
that we didn't kind of merge together at

00:21:03,590 --> 00:21:07,640
scrape time because one of the things

00:21:05,150 --> 00:21:09,230
you don't want to do is in my opinion is

00:21:07,640 --> 00:21:11,540
you want similar performance to doing

00:21:09,230 --> 00:21:13,370
the treaded model which means you can't

00:21:11,540 --> 00:21:14,960
call out to the kernel to send network

00:21:13,370 --> 00:21:18,140
packets which means you can't lock via

00:21:14,960 --> 00:21:19,700
you know kernel primitives so that's why

00:21:18,140 --> 00:21:21,820
I ended up doing for that approach which

00:21:19,700 --> 00:21:24,520
has its upsides it has its downsides

00:21:21,820 --> 00:21:27,140
because I want instrumentation be cheap

00:21:24,520 --> 00:21:29,900
yeah there I found a couple of different

00:21:27,140 --> 00:21:32,510
techniques but yeah and map files it's

00:21:29,900 --> 00:21:35,000
how we do it for the our unicorn library

00:21:32,510 --> 00:21:37,330
yeah you're gonna give those changes to

00:21:35,000 --> 00:21:40,610
Ruby as well right

00:21:37,330 --> 00:21:42,210
okay my question is what's the most

00:21:40,610 --> 00:21:46,320
exotic technology

00:21:42,210 --> 00:21:48,240
which you have seen client library one

00:21:46,320 --> 00:22:04,650
of my customers wrote a client library

00:21:48,240 --> 00:22:06,600
in TCL it's the file memory mapping

00:22:04,650 --> 00:22:08,370
implemented in the Python client

00:22:06,600 --> 00:22:11,130
directly could that be used from there

00:22:08,370 --> 00:22:11,760
directly uh yep soap item itself has an

00:22:11,130 --> 00:22:13,830
apple

00:22:11,760 --> 00:22:16,710
so yeah it's implemented has been for

00:22:13,830 --> 00:22:20,520
like year and a half or something yeah

00:22:16,710 --> 00:22:23,700
so my company get lab we implemented an

00:22:20,520 --> 00:22:25,080
EM map for the Ruby library as well but

00:22:23,700 --> 00:22:27,840
there's also I was looking into some

00:22:25,080 --> 00:22:30,360
other techniques like some people use

00:22:27,840 --> 00:22:33,690
like a little agent binary so that you

00:22:30,360 --> 00:22:37,590
do a local memory push or pushing over a

00:22:33,690 --> 00:22:40,020
UNIX socket there's also a POSIX shared

00:22:37,590 --> 00:22:41,910
memory segments that is Pat's possible

00:22:40,020 --> 00:22:43,290
to use haven't seen anyone trying done I

00:22:41,910 --> 00:22:45,780
should mention as well that the work to

00:22:43,290 --> 00:22:47,360
do DM up stuff in Titan and was funded

00:22:45,780 --> 00:22:53,580
by github

00:22:47,360 --> 00:22:58,770
thanks Ben github Birgit lab lab I don't

00:22:53,580 --> 00:23:01,050
think you were ploy by damage I don't

00:22:58,770 --> 00:23:04,950
know I I wasn't I didn't I didn't work

00:23:01,050 --> 00:23:08,670
through when they did that more

00:23:04,950 --> 00:23:12,380
questions all right

00:23:08,670 --> 00:23:20,760
oh you got a break and we'll be back at

00:23:12,380 --> 00:23:22,440
1:30 no 3:30 right yeah so also is there

00:23:20,760 --> 00:23:28,530
any diversity attendee who has not

00:23:22,440 --> 00:23:29,220
gotten the book yet and otherwise there

00:23:28,530 --> 00:23:31,470
are some books here

00:23:29,220 --> 00:23:34,730
and I'm giving ret I have the final six

00:23:31,470 --> 00:23:39,080
book so if you come up where is first oh

00:23:34,730 --> 00:23:41,970
yeah do it do you have it do we have

00:23:39,080 --> 00:23:43,440
well we'll do it we'll do it come up

00:23:41,970 --> 00:23:44,690
with some calm cure quiz questions and

00:23:43,440 --> 00:23:45,930
we'll do it then

00:23:44,690 --> 00:23:47,550
[Music]

00:23:45,930 --> 00:23:51,690
we'll do it when we come back from break

00:23:47,550 --> 00:23:52,740
oh okay go for it we get we got to but

00:23:51,690 --> 00:24:05,490
yeah we still got like five minutes

00:23:52,740 --> 00:24:08,130
before we break sir that's something

00:24:05,490 --> 00:24:11,400
last year I didn't know just like why

00:24:08,130 --> 00:24:13,620
would you ever add that um let's see

00:24:11,400 --> 00:24:15,210
first one what is the dimension number

00:24:13,620 --> 00:24:19,370
of points that a query arranged to

00:24:15,210 --> 00:24:22,830
return Kusum you're not allowed apply

00:24:19,370 --> 00:24:24,600
Tom you're not allowed yeah it was

00:24:22,830 --> 00:24:33,420
mentioned so it's a fair question you

00:24:24,600 --> 00:24:38,340
already got a book eleven thousand the

00:24:33,420 --> 00:24:40,740
reason why that's fair so into sign is

00:24:38,340 --> 00:24:42,720
still is I messed up once and I managed

00:24:40,740 --> 00:24:45,750
to get it once per second from the UNIX

00:24:42,720 --> 00:24:47,820
epoch till that day and that killed

00:24:45,750 --> 00:24:49,800
Prometheus so I taught wash number is

00:24:47,820 --> 00:24:52,140
large enough to no one should every hey

00:24:49,800 --> 00:24:54,540
Tish and you know our resolution for a

00:24:52,140 --> 00:24:56,640
week sounds pretty good to me and that's

00:24:54,540 --> 00:24:58,020
like ten thousand than a bish so it's

00:24:56,640 --> 00:25:00,410
like eleven thousand that's where the

00:24:58,020 --> 00:25:00,410
number comes from

00:25:01,820 --> 00:25:15,500
for now we'll fix that I once again

00:25:09,450 --> 00:25:17,610
Richie not a medical professional okay I

00:25:15,500 --> 00:25:20,460
remember some doctor ten years ago I

00:25:17,610 --> 00:25:21,809
came up with weird questions and named

00:25:20,460 --> 00:25:32,429
the tree ways you can access from few

00:25:21,809 --> 00:25:33,630
out because there are tree contexts in

00:25:32,429 --> 00:25:36,450
which you can run pump QL

00:25:33,630 --> 00:25:42,470
so one of them is the HTTP API what are

00:25:36,450 --> 00:25:42,470
the other two no Gozen

00:25:43,160 --> 00:25:49,559
now the HT API is one yeah rule

00:25:47,880 --> 00:25:57,450
evaluations is one you already have a

00:25:49,559 --> 00:25:58,520
book what is the other one you just said

00:25:57,450 --> 00:26:00,870
that

00:25:58,520 --> 00:26:04,530
the third way you can run so we have the

00:26:00,870 --> 00:26:14,040
HCP API we have recording rules yep you

00:26:04,530 --> 00:26:15,570
already got a book yeah the summaries in

00:26:14,040 --> 00:26:17,250
the rules okay I'll give you a console

00:26:15,570 --> 00:26:19,170
templates which is the same code both in

00:26:17,250 --> 00:26:24,980
alerting and recording rule annotations

00:26:19,170 --> 00:26:27,059
and in actual yeah console templates

00:26:24,980 --> 00:26:31,350
console temp is the first fighter I

00:26:27,059 --> 00:26:34,049
added we need to let go or no it's time

00:26:31,350 --> 00:26:36,260
to time to go on break and we have 20

00:26:34,049 --> 00:26:36,260
minutes

00:26:36,980 --> 00:26:42,830

YouTube URL: https://www.youtube.com/watch?v=D2OFAWV8aO8


