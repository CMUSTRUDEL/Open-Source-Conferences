Title: An overview of language support in Nix (NixCon 2019)
Publication date: 2019-10-29
Playlist: NixCon 2019 (Brno)
Description: 
	Most mainstream programming languages have several build platforms available. Which one should you use? Which one will your mugle coworker hate you for?

Build platforms generally strike a balance between "usability" (will nix-build succeed if npm build succeed?) and "incrementality" (will nix-build finish in the next hour after I tweaked a comment?). In this talk we look at the support for various languages and the nuances in their builds, from "fixed-output" builds (where the developer must update a hash on every code change) to "fully incremental" builds (where Nix rebuilds only as much as the language's own build tools).

We will compare the different approaches used in the Nix community today, point out the general features of mainstream languages' build tools, and briefly talk about how "recursive Nix" can solve some of today's problems.

In particular we will look at the some approaches in the Nix community today:

    Fixed-output derivation: any language
    Fixed-output derivation for dependencies: rustPlatform, python
    Code generation: carnix, yarn2nix, stack2nix, bundix, pypi2nix
    Package-set (snapshots) with upstream checksum database: haskellPackages
    Pure, lockfile-based: napalm, naersk
    File-level incremental: snack

For each we'll look at the following metrics: * Is the platform consistent with the developer's workflow (and does it Just Work) * What level of incrementality does the platform provide * Does the platform work within the Nix sandbox * Does the platform use "Import From Derivation" * How much does the platform stress the Nix evaluator
Captions: 
	00:00:00,360 --> 00:00:08,290
the next talk is from Nikolas mafia and

00:00:04,690 --> 00:00:20,109
it's an overview of language support in

00:00:08,290 --> 00:00:21,789
NICs so let's start hi everyone so

00:00:20,109 --> 00:00:24,580
thanks for coming first of all a bit of

00:00:21,789 --> 00:00:27,160
background I started using Nick's at

00:00:24,580 --> 00:00:28,779
work about three years ago and I was

00:00:27,160 --> 00:00:30,460
suffering from Nick Sabet was a bit of a

00:00:28,779 --> 00:00:32,950
Knicks hostage but then two years ago

00:00:30,460 --> 00:00:34,870
went to the Knicks cut in Munich and

00:00:32,950 --> 00:00:36,550
kind of open my eyes so I'm still

00:00:34,870 --> 00:00:41,500
suffering now but I got a bit of a

00:00:36,550 --> 00:00:43,390
Stockholm Syndrome so I'm enjoying it so

00:00:41,500 --> 00:00:46,870
the talk today is about language support

00:00:43,390 --> 00:00:48,309
in X it's gonna be not I'm trying to

00:00:46,870 --> 00:00:50,739
make it not tied to any language in

00:00:48,309 --> 00:00:53,260
particular but I have a background in

00:00:50,739 --> 00:00:55,530
high school and a bit of rust so there

00:00:53,260 --> 00:00:57,460
might be a few language specific things

00:00:55,530 --> 00:00:59,079
and it's gonna be in three parts

00:00:57,460 --> 00:01:00,670
basically the first part is gonna be the

00:00:59,079 --> 00:01:02,800
basics just so that we all agree in the

00:01:00,670 --> 00:01:04,479
vocabulary and what's happening what's

00:01:02,800 --> 00:01:06,549
the compiler what's the build tool the

00:01:04,479 --> 00:01:09,070
difference between the two and then the

00:01:06,549 --> 00:01:11,740
approaches so the approaches are used in

00:01:09,070 --> 00:01:14,140
X packages and elsewhere nowadays to

00:01:11,740 --> 00:01:16,780
actually package nix code package

00:01:14,140 --> 00:01:17,770
language codes in needs and then the

00:01:16,780 --> 00:01:20,229
last one is gonna be a bit of an

00:01:17,770 --> 00:01:22,780
overview and if you take aways from

00:01:20,229 --> 00:01:25,900
what's right now where we could go in

00:01:22,780 --> 00:01:29,799
the future and the best approaches so I

00:01:25,900 --> 00:01:31,450
start with the basics enter the matrix

00:01:29,799 --> 00:01:34,720
we're gonna kind of articulate

00:01:31,450 --> 00:01:36,040
everything around a few axes so on the

00:01:34,720 --> 00:01:37,930
left hand we have the fixed output

00:01:36,040 --> 00:01:38,920
derivation code generation log file

00:01:37,930 --> 00:01:41,200
based in pure Nicks

00:01:38,920 --> 00:01:45,399
these are all general approaches used

00:01:41,200 --> 00:01:47,979
nowadays and we kind of try to mix them

00:01:45,399 --> 00:01:51,549
and match them with three key aspects or

00:01:47,979 --> 00:01:54,970
three metrics the first one is the UX so

00:01:51,549 --> 00:01:57,700
how easy is it to use any of these

00:01:54,970 --> 00:01:58,930
approaches so does it just work this is

00:01:57,700 --> 00:02:01,030
very important most of the time because

00:01:58,930 --> 00:02:02,560
you wanna if you want to build something

00:02:01,030 --> 00:02:04,180
you package something you want it to

00:02:02,560 --> 00:02:07,329
work you don't want to have to debug it

00:02:04,180 --> 00:02:09,520
or figure out new flags and you want it

00:02:07,329 --> 00:02:11,620
to just work and the second one which I

00:02:09,520 --> 00:02:13,069
think is important is is it consistent

00:02:11,620 --> 00:02:15,349
with the user workflow

00:02:13,069 --> 00:02:19,010
that is if your user is using for

00:02:15,349 --> 00:02:22,579
instance cargo to build rusts or cabal

00:02:19,010 --> 00:02:24,590
to build Haskell code is this build I'm

00:02:22,579 --> 00:02:26,269
gonna use the same tools or is it going

00:02:24,590 --> 00:02:28,730
to be some special mechanism that's

00:02:26,269 --> 00:02:31,519
going to try to recreate the logic so

00:02:28,730 --> 00:02:33,140
ideally it would just work and the

00:02:31,519 --> 00:02:36,500
result is the same as using the native

00:02:33,140 --> 00:02:39,620
tools then the big problem it next

00:02:36,500 --> 00:02:42,680
particular is incrementality if you

00:02:39,620 --> 00:02:43,909
change a single command somewhere are

00:02:42,680 --> 00:02:46,849
you gonna have to wait an hour for

00:02:43,909 --> 00:02:49,609
everything to rebuild incrementality is

00:02:46,849 --> 00:02:53,299
about making builds as short as possible

00:02:49,609 --> 00:02:55,099
when possible and this is usually

00:02:53,299 --> 00:02:58,099
handled by the build tools themselves

00:02:55,099 --> 00:02:59,090
they did pretty well but in X it's

00:02:58,099 --> 00:03:01,790
always a question because you have this

00:02:59,090 --> 00:03:04,069
derivation which is okay here's the lock

00:03:01,790 --> 00:03:05,150
step if you change any input then the

00:03:04,069 --> 00:03:07,099
whole derivation is going to be rebuilt

00:03:05,150 --> 00:03:09,939
so we try to meet the derivations as

00:03:07,099 --> 00:03:12,500
small as possible for incremental T and

00:03:09,939 --> 00:03:15,709
then the evaluation something it's not

00:03:12,500 --> 00:03:17,750
really talked about much in X but it's

00:03:15,709 --> 00:03:20,180
basically the row overhead that next

00:03:17,750 --> 00:03:23,510
brings on top of the build tool so it's

00:03:20,180 --> 00:03:26,060
all the next evaluation that happens

00:03:23,510 --> 00:03:29,540
before your code or your build Co has

00:03:26,060 --> 00:03:31,159
actually run so for instance if you have

00:03:29,540 --> 00:03:32,989
mixed packages Nick's needs to go

00:03:31,159 --> 00:03:36,169
through everything evaluate the packages

00:03:32,989 --> 00:03:38,629
and be like ok I'm go and pull this one

00:03:36,169 --> 00:03:41,090
and then tell you okay I'm gonna fetch

00:03:38,629 --> 00:03:45,919
this and I'm gonna run these commands so

00:03:41,090 --> 00:03:48,129
the evaluation is the first step so the

00:03:45,919 --> 00:03:51,500
first and simplest approach Oh

00:03:48,129 --> 00:03:54,669
vocabulary first my bad we're going to

00:03:51,500 --> 00:03:58,189
talk about compilers build tools and

00:03:54,669 --> 00:04:00,430
that's pretty much it the compiler is

00:03:58,189 --> 00:04:02,569
the thing actually compiles your code

00:04:00,430 --> 00:04:05,060
this is something that you can't get

00:04:02,569 --> 00:04:07,069
away with the build tool is the thing

00:04:05,060 --> 00:04:09,379
that kind of puts the pieces together

00:04:07,069 --> 00:04:13,430
and cause the compiler here for the

00:04:09,379 --> 00:04:15,319
build outputs there and sometimes you

00:04:13,430 --> 00:04:17,150
can actually get rid of it in Nix we'll

00:04:15,319 --> 00:04:19,009
talk about it more later but the

00:04:17,150 --> 00:04:20,060
compiler is something you never want to

00:04:19,009 --> 00:04:22,430
re-implement the nicks

00:04:20,060 --> 00:04:24,650
whereas the build tool

00:04:22,430 --> 00:04:27,110
the build tool as we'll see it's

00:04:24,650 --> 00:04:32,810
possible even though it might not be

00:04:27,110 --> 00:04:35,360
nice so let's go with your proaches the

00:04:32,810 --> 00:04:39,440
very first one is the fixed output

00:04:35,360 --> 00:04:41,949
derivation if you don't want to spend

00:04:39,440 --> 00:04:44,270
any time thinking about it you do that

00:04:41,949 --> 00:04:46,100
so you're on the command your command

00:04:44,270 --> 00:04:49,669
can do anything you want you can call

00:04:46,100 --> 00:04:52,550
Network it can fire missiles everything

00:04:49,669 --> 00:04:54,889
you want and it just kind of tell Nicks

00:04:52,550 --> 00:04:57,440
hey Nicks listen the output is gonna

00:04:54,889 --> 00:05:00,229
have this hash trust me on this and if

00:04:57,440 --> 00:05:03,080
the output actually has the when hashed

00:05:00,229 --> 00:05:07,729
gets the exact output hash the neck is

00:05:03,080 --> 00:05:09,229
going to say fine I'm going with you but

00:05:07,729 --> 00:05:11,660
so even though it's the simplest to

00:05:09,229 --> 00:05:16,130
implement for anything it has a few

00:05:11,660 --> 00:05:18,050
drawbacks first evaluation is super fast

00:05:16,130 --> 00:05:20,810
because next doesn't have to do any job

00:05:18,050 --> 00:05:23,449
it just checks the checksum and if

00:05:20,810 --> 00:05:26,630
everything is good fine there's no no

00:05:23,449 --> 00:05:29,120
special logic there incrementality is

00:05:26,630 --> 00:05:32,930
pretty bad because whenever you change

00:05:29,120 --> 00:05:37,090
anything you'll have to rerun and I'll

00:05:32,930 --> 00:05:39,830
go more into that in a second but the UX

00:05:37,090 --> 00:05:42,979
for me is the worst because what happens

00:05:39,830 --> 00:05:44,990
is that whenever you have a single input

00:05:42,979 --> 00:05:47,930
changing in your builds so for instance

00:05:44,990 --> 00:05:51,590
your user adds dependency for a node.js

00:05:47,930 --> 00:05:53,330
program or anything you're gonna have to

00:05:51,590 --> 00:05:56,180
change the hash by hands the check

00:05:53,330 --> 00:05:58,310
server and it gets even worse if you

00:05:56,180 --> 00:05:59,539
forget to change it because next is

00:05:58,310 --> 00:06:01,250
gonna just look up the hash it's gonna

00:05:59,539 --> 00:06:04,220
be like already have this in the story

00:06:01,250 --> 00:06:06,560
so fine your bed is fine even though in

00:06:04,220 --> 00:06:11,000
practice it would generate a new build

00:06:06,560 --> 00:06:13,340
with new bailout output and so the

00:06:11,000 --> 00:06:16,340
question is can we improve this so that

00:06:13,340 --> 00:06:19,130
you don't have this huge lock step and

00:06:16,340 --> 00:06:21,110
this huge fixed output derivation and

00:06:19,130 --> 00:06:23,900
you can say well most of the time the

00:06:21,110 --> 00:06:25,160
local code changes when you edit you

00:06:23,900 --> 00:06:26,630
might add a function and change some

00:06:25,160 --> 00:06:29,030
things but our dependencies that you

00:06:26,630 --> 00:06:31,580
pull in those rarely change they change

00:06:29,030 --> 00:06:33,280
maybe once a week or once a day but

00:06:31,580 --> 00:06:35,120
that's not too often

00:06:33,280 --> 00:06:36,380
so this

00:06:35,120 --> 00:06:39,410
something we're going to look at in a

00:06:36,380 --> 00:06:40,729
second but first a few warning so next

00:06:39,410 --> 00:06:43,190
is not meant as a content addressable

00:06:40,729 --> 00:06:45,770
store so when you have those hashes in a

00:06:43,190 --> 00:06:50,510
Nick store they're based on the inputs

00:06:45,770 --> 00:06:53,960
of the belt not the actual output and so

00:06:50,510 --> 00:06:57,530
using the hash as a as a key it's kind

00:06:53,960 --> 00:06:59,780
of against the next model what's very

00:06:57,530 --> 00:07:01,070
dangerous is that you have to trust a

00:06:59,780 --> 00:07:03,590
lot of things first you have to make

00:07:01,070 --> 00:07:05,150
sure they didn't screw your build phase

00:07:03,590 --> 00:07:07,220
that your build phase is always going to

00:07:05,150 --> 00:07:08,949
call the same functions are always gonna

00:07:07,220 --> 00:07:10,729
run the compiler in the exact same way

00:07:08,949 --> 00:07:12,260
then you have to trust the reroute

00:07:10,729 --> 00:07:13,490
content if you're pulling dependencies

00:07:12,260 --> 00:07:16,370
from somewhere you have to make sure

00:07:13,490 --> 00:07:19,070
that was the URL that you use they're

00:07:16,370 --> 00:07:21,940
always gonna give you the same bytes

00:07:19,070 --> 00:07:23,870
otherwise your bills gonna change and

00:07:21,940 --> 00:07:26,080
you have to trust compile the

00:07:23,870 --> 00:07:28,130
reproducibility so if your compiler

00:07:26,080 --> 00:07:29,870
decides to generate different outputs

00:07:28,130 --> 00:07:36,500
depending on the day of the week for

00:07:29,870 --> 00:07:37,850
instance as GHC d at some point then you

00:07:36,500 --> 00:07:40,280
might have something that works for you

00:07:37,850 --> 00:07:41,780
and then you give it to your coworker

00:07:40,280 --> 00:07:44,990
you're like hey here's the six code it's

00:07:41,780 --> 00:07:46,460
gonna it's gonna work just fine but at

00:07:44,990 --> 00:07:48,169
the end of the day their code is gonna

00:07:46,460 --> 00:07:49,639
be different they're generated outputs

00:07:48,169 --> 00:07:51,830
gonna be different it's gonna have a

00:07:49,639 --> 00:07:53,960
different hash that doesn't match the

00:07:51,830 --> 00:07:55,460
one that you put and so your coworker is

00:07:53,960 --> 00:07:58,460
gonna be angry at you and it's something

00:07:55,460 --> 00:08:09,650
you don't want so about those

00:07:58,460 --> 00:08:11,599
dependencies no dependencies so another

00:08:09,650 --> 00:08:13,400
approach where we don't use the fixed up

00:08:11,599 --> 00:08:15,320
with derivation is that you just run

00:08:13,400 --> 00:08:17,240
some external tool that pulls these

00:08:15,320 --> 00:08:18,830
dependencies for you and compiles the

00:08:17,240 --> 00:08:21,710
hashes for you this is an approach

00:08:18,830 --> 00:08:24,260
that's used widely next it's the food

00:08:21,710 --> 00:08:28,940
tunics so we have stack tunics pi PI

00:08:24,260 --> 00:08:31,520
tunics yarn tunics and in this case you

00:08:28,940 --> 00:08:33,709
have a tool like Bendix for Ruby that

00:08:31,520 --> 00:08:34,190
you call and it just generates nyx files

00:08:33,709 --> 00:08:36,589
for you

00:08:34,190 --> 00:08:40,860
these nyx files you then import them in

00:08:36,589 --> 00:08:45,029
your code and use it but

00:08:40,860 --> 00:08:48,089
there's a problem because first you have

00:08:45,029 --> 00:08:50,610
to check in all these generated code so

00:08:48,089 --> 00:08:53,339
that everyone uses the same so in terms

00:08:50,610 --> 00:08:54,570
of UX it's not very good then that means

00:08:53,339 --> 00:08:56,640
that you have your NYX build for the

00:08:54,570 --> 00:08:58,380
builds you might have an NPM build when

00:08:56,640 --> 00:08:59,700
you build locally but on top of that you

00:08:58,380 --> 00:09:01,649
have an extra step that you need to run

00:08:59,700 --> 00:09:05,130
every time which generates this next

00:09:01,649 --> 00:09:07,200
code on the other hand the

00:09:05,130 --> 00:09:09,320
incrementality can be good it depends on

00:09:07,200 --> 00:09:12,029
how the generated code generated

00:09:09,320 --> 00:09:16,649
generated code works sorry I'm stumbling

00:09:12,029 --> 00:09:19,170
a bit and the evaluation time depends

00:09:16,649 --> 00:09:23,310
also a lot because it depends on the

00:09:19,170 --> 00:09:26,940
jury data code so all these for me are

00:09:23,310 --> 00:09:29,610
not ideal because you have this this big

00:09:26,940 --> 00:09:30,930
Nix code that was generated and we're in

00:09:29,610 --> 00:09:32,970
a time where most programming languages

00:09:30,930 --> 00:09:35,459
actually provide log files so the log

00:09:32,970 --> 00:09:38,399
file actually tells you hey this is the

00:09:35,459 --> 00:09:41,370
URL of this dependency here is the char

00:09:38,399 --> 00:09:43,980
for this dependency and maybe in order

00:09:41,370 --> 00:09:46,829
to improve on this terrible UX we can

00:09:43,980 --> 00:09:49,350
actually use these log files and this is

00:09:46,829 --> 00:09:50,310
next approach I'm going to present which

00:09:49,350 --> 00:09:54,440
is a bit of a self plug because

00:09:50,310 --> 00:09:54,440
something I've been doing a lot lately

00:09:57,050 --> 00:10:05,850
and the focus is really user experience

00:10:03,170 --> 00:10:08,640
so only way you want is to have a single

00:10:05,850 --> 00:10:10,200
function that you call on some source or

00:10:08,640 --> 00:10:12,390
in some projects in the has a log file

00:10:10,200 --> 00:10:16,170
and the build it just works you have

00:10:12,390 --> 00:10:18,149
nothing else to do so nurse is one I

00:10:16,170 --> 00:10:19,410
wrote for rusts and I think elko did

00:10:18,149 --> 00:10:22,890
something similar is about some point

00:10:19,410 --> 00:10:29,070
and napalm Nepal is for JavaScript of

00:10:22,890 --> 00:10:30,839
course and so as you can see just load

00:10:29,070 --> 00:10:33,060
the library or say it's in expect it is

00:10:30,839 --> 00:10:37,320
just call the function and everything

00:10:33,060 --> 00:10:40,949
just works now how does that compare Oh

00:10:37,320 --> 00:10:42,899
how does it work first on the left you

00:10:40,949 --> 00:10:46,170
have an example log file that one is a

00:10:42,899 --> 00:10:50,399
cargo log file which is Domo and as you

00:10:46,170 --> 00:10:51,930
can see you have the URL where cargo is

00:10:50,399 --> 00:10:53,340
actually gonna grab the dependency from

00:10:51,930 --> 00:10:57,630
or the raw code

00:10:53,340 --> 00:10:59,430
and it also gives you the checksum so

00:10:57,630 --> 00:10:59,790
technically NYX would be just happy with

00:10:59,430 --> 00:11:04,050
that

00:10:59,790 --> 00:11:08,010
and indeed so when nurse works in a

00:11:04,050 --> 00:11:09,360
cargo project it's gonna generate in

00:11:08,010 --> 00:11:11,190
memory so it's not gonna generate code

00:11:09,360 --> 00:11:12,600
but it's gonna generate something very

00:11:11,190 --> 00:11:15,810
similar to this so you have to make

00:11:12,600 --> 00:11:18,779
derivation you tell it hey the URL is

00:11:15,810 --> 00:11:20,520
this the SHA is this and next is gonna

00:11:18,779 --> 00:11:23,310
be okay I'm gonna pull it don't know its

00:11:20,520 --> 00:11:25,170
dependency checksum everything is good

00:11:23,310 --> 00:11:33,420
and there you go there's no code that's

00:11:25,170 --> 00:11:36,000
being generated so the problem here is

00:11:33,420 --> 00:11:39,810
the evaluation because you have Nicks

00:11:36,000 --> 00:11:41,970
you're asking Nick's to parse JSON if it

00:11:39,810 --> 00:11:45,360
stays a lot for Tomo if it's double log

00:11:41,970 --> 00:11:47,490
file and this can actually impact the

00:11:45,360 --> 00:11:50,160
evaluator quite a bit you might have

00:11:47,490 --> 00:11:53,450
well long-running evaluations before

00:11:50,160 --> 00:11:56,790
which makes built any code

00:11:53,450 --> 00:11:57,770
incrementality is okay because most of

00:11:56,790 --> 00:12:00,930
the time you can get away with having

00:11:57,770 --> 00:12:02,910
per dependency incrementality so if one

00:12:00,930 --> 00:12:05,490
dependency changes the next just repost

00:12:02,910 --> 00:12:07,320
this one if you do things well enough it

00:12:05,490 --> 00:12:09,330
can even build the dependency as opposed

00:12:07,320 --> 00:12:10,800
to just grabbing a source code and then

00:12:09,330 --> 00:12:14,460
you don't have to rebuild and append see

00:12:10,800 --> 00:12:15,870
that wasn't affected in terms of UX

00:12:14,460 --> 00:12:17,850
it's basically the best in class because

00:12:15,870 --> 00:12:20,700
when you have it in user coming you tell

00:12:17,850 --> 00:12:23,430
them hey just do Nick's build and it's

00:12:20,700 --> 00:12:25,440
gonna work if you change code file it's

00:12:23,430 --> 00:12:27,480
still gonna work if you add dependencies

00:12:25,440 --> 00:12:29,490
edit the log file fine it's still gonna

00:12:27,480 --> 00:12:32,930
be the same dependencies that you used

00:12:29,490 --> 00:12:32,930
when running cargo for instance

00:12:35,610 --> 00:12:41,920
so this is very good but incrementality

00:12:39,910 --> 00:12:48,339
is still kind of lacking it's just okay

00:12:41,920 --> 00:12:52,750
so if we go now one step further is what

00:12:48,339 --> 00:12:54,850
I call the pure NYX approach and it's

00:12:52,750 --> 00:12:58,089
something experimented with in Haskell

00:12:54,850 --> 00:12:59,920
particular and the idea is that you

00:12:58,089 --> 00:13:03,070
don't have per dependency incrementality

00:12:59,920 --> 00:13:05,320
we have per file if you modify one file

00:13:03,070 --> 00:13:07,630
just this files going to be rebuilt if

00:13:05,320 --> 00:13:09,339
this file is depending on by other files

00:13:07,630 --> 00:13:09,910
okay and these files are gonna be

00:13:09,339 --> 00:13:11,860
dependent

00:13:09,910 --> 00:13:14,410
gonna be rebuilt as well but generally

00:13:11,860 --> 00:13:16,300
you don't have this big oh wait I have

00:13:14,410 --> 00:13:18,880
to wait three minutes because I change

00:13:16,300 --> 00:13:23,019
one comments because cabal has to

00:13:18,880 --> 00:13:25,690
rebuild the whole dependency and it's

00:13:23,019 --> 00:13:27,940
kind of magic but actually in practice

00:13:25,690 --> 00:13:30,510
it works pretty well so on the left you

00:13:27,940 --> 00:13:33,790
have some kind of description of a build

00:13:30,510 --> 00:13:36,540
or you say okay this is my source it's

00:13:33,790 --> 00:13:41,019
in this folder I have a main module and

00:13:36,540 --> 00:13:42,820
I have some dependencies but what Nix is

00:13:41,019 --> 00:13:44,500
actually gonna generate what Nick is

00:13:42,820 --> 00:13:47,560
gonna run is something similar to this

00:13:44,500 --> 00:13:49,420
where by the way the clicker doesn't

00:13:47,560 --> 00:13:52,510
work so I have to use my finger to point

00:13:49,420 --> 00:13:54,610
oh that's okay for you the important

00:13:52,510 --> 00:13:56,440
part is that this make derivation okay

00:13:54,610 --> 00:13:58,690
in the name you use the module name that

00:13:56,440 --> 00:14:00,760
depends only on the module then you have

00:13:58,690 --> 00:14:02,560
the built phase well you have the module

00:14:00,760 --> 00:14:05,019
source which is the path to for instance

00:14:02,560 --> 00:14:08,079
a Haskell file that depends the module

00:14:05,019 --> 00:14:10,570
then the module name again fine and then

00:14:08,079 --> 00:14:12,250
the bell steps so it depends only on the

00:14:10,570 --> 00:14:16,569
module itself and the module

00:14:12,250 --> 00:14:18,819
dependencies so nothing else and then

00:14:16,569 --> 00:14:22,209
you kind of baked together at the top

00:14:18,819 --> 00:14:26,800
module so you create a graph of all the

00:14:22,209 --> 00:14:27,699
module a dependency graph and you just

00:14:26,800 --> 00:14:30,850
link everything together

00:14:27,699 --> 00:14:32,800
if one module changes only a specific

00:14:30,850 --> 00:14:35,260
path in that graph is gonna be changed

00:14:32,800 --> 00:14:37,300
it's gonna have to be rebuilt but the

00:14:35,260 --> 00:14:38,980
rests all the other modules all the

00:14:37,300 --> 00:14:41,829
other object files are still gonna be

00:14:38,980 --> 00:14:43,600
there and you can reuse them this fairly

00:14:41,829 --> 00:14:46,120
nice because you have basically the same

00:14:43,600 --> 00:14:55,750
level of incrementally T as cabal

00:14:46,120 --> 00:15:01,630
or cargo outside of NICs now there's an

00:14:55,750 --> 00:15:03,730
evaluation problem I wrote snack about a

00:15:01,630 --> 00:15:05,830
year ago and a few months later a

00:15:03,730 --> 00:15:07,570
company approached me and said hey I

00:15:05,830 --> 00:15:10,150
really love this snack thing this is

00:15:07,570 --> 00:15:12,760
really the right way to do stuff and it

00:15:10,150 --> 00:15:16,839
works actually compiles we just have a

00:15:12,760 --> 00:15:24,460
single problem the evaluation took seven

00:15:16,839 --> 00:15:27,310
days so I never have too much into how

00:15:24,460 --> 00:15:30,400
the next evaluator works I'm not very

00:15:27,310 --> 00:15:32,740
good in performance work in general so I

00:15:30,400 --> 00:15:37,330
believe this is fixable but by someone

00:15:32,740 --> 00:15:38,740
else than me but in general this is the

00:15:37,330 --> 00:15:41,110
big problem because you're telega ting

00:15:38,740 --> 00:15:43,450
all the work to nix nix is an evaluated

00:15:41,110 --> 00:15:45,670
language compared to for instance cargo

00:15:43,450 --> 00:15:48,400
which is just built in rust so it's all

00:15:45,670 --> 00:15:51,130
machine code just checking the end times

00:15:48,400 --> 00:15:54,910
checking the checksums of some files so

00:15:51,130 --> 00:15:56,529
now everything happens index on the

00:15:54,910 --> 00:16:01,600
other hand incrementality is

00:15:56,529 --> 00:16:03,610
best-in-class if you think about it for

00:16:01,600 --> 00:16:07,860
a Haskell oh my way how many Haskell is

00:16:03,610 --> 00:16:09,790
do we have here okay this is beautiful

00:16:07,860 --> 00:16:12,310
incrementality is even better than that

00:16:09,790 --> 00:16:14,260
of cabal because in COBOL if you have a

00:16:12,310 --> 00:16:16,450
couple library we change a single file

00:16:14,260 --> 00:16:18,250
and you depend that library

00:16:16,450 --> 00:16:19,720
what cabal is gonna decide I have to

00:16:18,250 --> 00:16:22,300
rebuild this library

00:16:19,720 --> 00:16:24,250
whereas in snack it's just gonna look at

00:16:22,300 --> 00:16:25,270
the module dependency and most of the

00:16:24,250 --> 00:16:27,790
library won't be rebuilt

00:16:25,270 --> 00:16:29,860
especially if it's a top-level file it's

00:16:27,790 --> 00:16:32,220
just gonna really compile that file and

00:16:29,860 --> 00:16:34,480
then only your files that depends

00:16:32,220 --> 00:16:39,010
transitively on that file so this is

00:16:34,480 --> 00:16:42,190
kind of beautiful how's the UX it's

00:16:39,010 --> 00:16:45,970
complicated because the way snack works

00:16:42,190 --> 00:16:50,459
is it's basically a big Knicks library

00:16:45,970 --> 00:16:54,090
and a tiny executable around it and

00:16:50,459 --> 00:16:56,520
executable cell calls next build

00:16:54,090 --> 00:16:59,370
so UX is pretty good if you could be

00:16:56,520 --> 00:17:01,440
executable right but there's some cost

00:16:59,370 --> 00:17:03,180
because then your engineers needs to

00:17:01,440 --> 00:17:06,450
learn how to work with snack you can't

00:17:03,180 --> 00:17:08,340
tell them oh use cabal because cabal is

00:17:06,450 --> 00:17:10,530
just not gonna work there so you have to

00:17:08,340 --> 00:17:12,870
teach them a new tool and you basically

00:17:10,530 --> 00:17:19,230
have to get it right which I didn't

00:17:12,870 --> 00:17:21,000
snack so we have all these approaches

00:17:19,230 --> 00:17:22,680
that go from something very

00:17:21,000 --> 00:17:24,240
coarse-grained when you had to fix out

00:17:22,680 --> 00:17:26,550
the derivation that just rebuilds

00:17:24,240 --> 00:17:28,770
everything and it may be you can just

00:17:26,550 --> 00:17:30,840
abstract away the dependencies have

00:17:28,770 --> 00:17:33,630
these in a fixed output derivation and

00:17:30,840 --> 00:17:38,340
then rebuild your local local projects

00:17:33,630 --> 00:17:41,490
much faster then we had generated codes

00:17:38,340 --> 00:17:42,930
then we have the log file based and then

00:17:41,490 --> 00:17:45,210
we have the pure Nix approach so they

00:17:42,930 --> 00:17:48,630
all have different trade-offs some are

00:17:45,210 --> 00:17:52,460
good some some have fast evaluation some

00:17:48,630 --> 00:17:55,860
are incremental we basically have this

00:17:52,460 --> 00:17:57,330
for the fixed output the UX is terrible

00:17:55,860 --> 00:17:59,360
once again because you need to change

00:17:57,330 --> 00:18:03,170
the hash whenever anything changes

00:17:59,360 --> 00:18:07,760
incrementality ouch bad as well

00:18:03,170 --> 00:18:07,760
evaluation on the other hand is fast

00:18:08,390 --> 00:18:12,360
fixed output with depth it's pretty much

00:18:11,190 --> 00:18:14,220
the same except we have better

00:18:12,360 --> 00:18:16,890
incrementality because the hash changes

00:18:14,220 --> 00:18:18,630
only when any dependencies changes but

00:18:16,890 --> 00:18:20,820
not when your top-level projects the one

00:18:18,630 --> 00:18:23,570
you work on locally changes an

00:18:20,820 --> 00:18:27,150
evaluation is still fast so that's good

00:18:23,570 --> 00:18:28,620
code generation UX once again is pretty

00:18:27,150 --> 00:18:30,570
bad because you have to rerun an

00:18:28,620 --> 00:18:35,570
external tool whenever you have a change

00:18:30,570 --> 00:18:39,020
in your code incrementality depends

00:18:35,570 --> 00:18:43,230
depends how the generative code works

00:18:39,020 --> 00:18:46,230
depends on many factors which might

00:18:43,230 --> 00:18:48,690
depend on the tool so if it's stacked in

00:18:46,230 --> 00:18:50,160
X might be good if it's Bendix might be

00:18:48,690 --> 00:18:53,460
bad might be the other way around

00:18:50,160 --> 00:18:57,030
depends very much evaluation is pretty

00:18:53,460 --> 00:18:59,250
much the same for the log file UX is

00:18:57,030 --> 00:19:03,150
great you have the same comments that

00:18:59,250 --> 00:19:04,350
run as in cargo but in X incrementality

00:19:03,150 --> 00:19:06,680
is okay

00:19:04,350 --> 00:19:08,050
depending on how you you cut it up

00:19:06,680 --> 00:19:13,080
evaluation is

00:19:08,050 --> 00:19:15,250
and the pure index once again UX

00:19:13,080 --> 00:19:18,040
complicated because you need to build

00:19:15,250 --> 00:19:23,080
new tools and incrementality

00:19:18,040 --> 00:19:26,470
is amazing but evaluation is bad so the

00:19:23,080 --> 00:19:29,890
main takeaway here is a wall NYX doesn't

00:19:26,470 --> 00:19:31,420
work right wait we call or you can have

00:19:29,890 --> 00:19:36,270
all them we're gonna have the cake and

00:19:31,420 --> 00:19:36,270
eat it so what do we do

00:19:36,660 --> 00:19:41,680
it's actually more interesting question

00:19:38,920 --> 00:19:44,980
which is well maybe we don't need to

00:19:41,680 --> 00:19:49,480
have a single approach for everything

00:19:44,980 --> 00:19:51,550
and maybe we should split the approaches

00:19:49,480 --> 00:19:54,040
by users so for instance we have a

00:19:51,550 --> 00:19:56,440
newcomer someone who's just discovered

00:19:54,040 --> 00:19:59,590
next actually like it is actually

00:19:56,440 --> 00:20:01,330
interested in using necks and well for

00:19:59,590 --> 00:20:03,690
him it should just work right because

00:20:01,330 --> 00:20:06,430
you told him hey it's gonna just work

00:20:03,690 --> 00:20:08,200
but then that person might not care very

00:20:06,430 --> 00:20:10,030
much about evaluation time or increment

00:20:08,200 --> 00:20:13,090
ality they're gonna try Nick's build

00:20:10,030 --> 00:20:14,560
it's gonna build to a huge Java project

00:20:13,090 --> 00:20:19,120
that I never managed to get compiled

00:20:14,560 --> 00:20:22,210
before and they're happy then you have

00:20:19,120 --> 00:20:23,500
the power user which a thing is most of

00:20:22,210 --> 00:20:26,050
the people in this room you like you

00:20:23,500 --> 00:20:27,700
really like necks and you don't mind

00:20:26,050 --> 00:20:29,920
adapting your tools to make you don't

00:20:27,700 --> 00:20:32,500
mind writing wrappers around necks you

00:20:29,920 --> 00:20:34,930
you're happy with anything but you use

00:20:32,500 --> 00:20:37,450
it very very often so that means that

00:20:34,930 --> 00:20:39,310
evaluation and incrementality must be

00:20:37,450 --> 00:20:43,270
very good because next then becomes your

00:20:39,310 --> 00:20:45,880
primary tool and then you have a

00:20:43,270 --> 00:20:48,610
different user which is not a real user

00:20:45,880 --> 00:20:49,980
bits machine user I'll call it which is

00:20:48,610 --> 00:20:53,260
the package there in Nick's packages

00:20:49,980 --> 00:20:55,570
these are usually not built by hand on

00:20:53,260 --> 00:20:58,480
your machine they tend to be cached the

00:20:55,570 --> 00:21:01,300
problem is for evaluation for instance

00:20:58,480 --> 00:21:03,730
if you poor or if you evaluate Nick's

00:21:01,300 --> 00:21:05,020
packages you want this to be fast you

00:21:03,730 --> 00:21:06,460
want it to be extremely fast because

00:21:05,020 --> 00:21:08,230
you're gonna be evaluating tons and tons

00:21:06,460 --> 00:21:10,030
of packages you might have foreigner

00:21:08,230 --> 00:21:12,010
dependencies for your single local

00:21:10,030 --> 00:21:15,100
project so this step you want it to be

00:21:12,010 --> 00:21:17,050
extremely fast the rest back you'll

00:21:15,100 --> 00:21:19,270
require about it you might have bots

00:21:17,050 --> 00:21:21,370
that generate code that's then checked

00:21:19,270 --> 00:21:21,789
in Nick's packages but that's fine you

00:21:21,370 --> 00:21:25,419
as

00:21:21,789 --> 00:21:27,929
you have to care about it and then you

00:21:25,419 --> 00:21:30,100
have the Knicks hostage

00:21:27,929 --> 00:21:31,690
the Knicks hostage is the guy at your

00:21:30,100 --> 00:21:33,759
company who you told

00:21:31,690 --> 00:21:38,350
neck's is gonna be amazing let's use

00:21:33,759 --> 00:21:39,609
necks and this person needs perfect UX

00:21:38,350 --> 00:21:42,909
because they don't want to care about

00:21:39,609 --> 00:21:44,649
necks they want fast evaluation because

00:21:42,909 --> 00:21:47,350
you told them yes of course you can use

00:21:44,649 --> 00:21:50,200
it to your primary build tool it needs

00:21:47,350 --> 00:21:51,489
to be incremental otherwise they're

00:21:50,200 --> 00:22:00,399
gonna complain about CI which they

00:21:51,489 --> 00:22:04,330
usually do so can we kind of have all

00:22:00,399 --> 00:22:07,269
this well they're kind of tensions

00:22:04,330 --> 00:22:09,489
incrementality for instance most of the

00:22:07,269 --> 00:22:11,320
time you require build tool knowledge so

00:22:09,489 --> 00:22:13,330
if you want to have per dependency

00:22:11,320 --> 00:22:15,820
increment allottee you need to know for

00:22:13,330 --> 00:22:18,039
instance how npm works how does it

00:22:15,820 --> 00:22:21,399
actually insert dependencies in its

00:22:18,039 --> 00:22:25,210
cache if you go with the extreme of the

00:22:21,399 --> 00:22:26,799
pure NYX snack like approach then you

00:22:25,210 --> 00:22:30,159
need to know even how the compiler works

00:22:26,799 --> 00:22:32,979
and how what Flags accepts how it's

00:22:30,159 --> 00:22:36,849
expecting its dependencies or the the

00:22:32,979 --> 00:22:39,369
pre-built object files and then the more

00:22:36,849 --> 00:22:41,830
incremental you gets the more you're

00:22:39,369 --> 00:22:44,129
gonna get the evaluator to work so this

00:22:41,830 --> 00:22:47,139
is something that I really care about

00:22:44,129 --> 00:22:48,340
and then you have these next hostages

00:22:47,139 --> 00:22:52,359
that need the best of all possible

00:22:48,340 --> 00:22:53,979
worlds so maybe we should have a multi

00:22:52,359 --> 00:22:56,830
tier approach in the next packages and

00:22:53,979 --> 00:22:59,590
elsewhere where you could have mixed

00:22:56,830 --> 00:23:02,979
packages that has some very fast fixed

00:22:59,590 --> 00:23:05,830
output derivation like builds and then

00:23:02,979 --> 00:23:08,649
you might have a lock file like a

00:23:05,830 --> 00:23:11,799
snapshot all dependencies they can

00:23:08,649 --> 00:23:13,330
choose from and it's gonna be whatever

00:23:11,799 --> 00:23:16,720
tool you use is going to read that file

00:23:13,330 --> 00:23:18,639
check the checks terms and then build

00:23:16,720 --> 00:23:21,309
all your dependencies using that but

00:23:18,639 --> 00:23:22,840
only the dependencies and then for your

00:23:21,309 --> 00:23:25,599
local build you might have something

00:23:22,840 --> 00:23:27,309
that's very pure Nik stoic so this is

00:23:25,599 --> 00:23:29,169
pretty much what snack does right now

00:23:27,309 --> 00:23:30,999
and I think it's something that tweak we

00:23:29,169 --> 00:23:33,909
discovered recently with basil where

00:23:30,999 --> 00:23:35,170
they have dependencies that come built

00:23:33,909 --> 00:23:38,410
with COBOL the

00:23:35,170 --> 00:23:41,380
like stack age snapshots but then for

00:23:38,410 --> 00:23:45,490
day-to-day uses you only rebuild your

00:23:41,380 --> 00:23:48,550
packages fast with built-in base of

00:23:45,490 --> 00:23:51,970
primitives and I think this is something

00:23:48,550 --> 00:23:53,410
that's quite quite interesting even more

00:23:51,970 --> 00:23:55,750
interesting would be if we could have

00:23:53,410 --> 00:24:00,640
that without the user knowing about it

00:23:55,750 --> 00:24:03,040
so maybe you could have two or three

00:24:00,640 --> 00:24:05,050
different mechanisms I kind of switch if

00:24:03,040 --> 00:24:07,900
Nick's realize is that this is

00:24:05,050 --> 00:24:09,010
dependency you don't use often then it's

00:24:07,900 --> 00:24:11,350
gonna push it back it's going to use the

00:24:09,010 --> 00:24:12,850
more fixed output derivation like builds

00:24:11,350 --> 00:24:14,740
and if it's something you change

00:24:12,850 --> 00:24:21,490
regularly then it's gonna use the

00:24:14,740 --> 00:24:24,580
pureness implementation so this was

00:24:21,490 --> 00:24:27,960
pretty much yet but there's one

00:24:24,580 --> 00:24:27,960
interesting question which is can

00:24:28,020 --> 00:24:32,680
recursive Nick's help with this so I'm

00:24:31,390 --> 00:24:36,880
gonna let you read the code for a second

00:24:32,680 --> 00:24:39,480
that have appeared on github issue for

00:24:36,880 --> 00:24:39,480
recursive Nick's

00:24:46,200 --> 00:24:54,060
what it says basically so it's a

00:24:48,360 --> 00:24:56,280
statement but any solution that being

00:24:54,060 --> 00:24:57,920
criminal build problem that involves the

00:24:56,280 --> 00:24:59,790
build system is going to be brittle

00:24:57,920 --> 00:25:02,400
which is very true

00:24:59,790 --> 00:25:04,260
that's what happened to snack and it's

00:25:02,400 --> 00:25:07,020
going to essentially reimplemented

00:25:04,260 --> 00:25:09,800
illogic of any build system in Nix and

00:25:07,020 --> 00:25:14,280
once again Nix is evaluated it's slow

00:25:09,800 --> 00:25:17,670
and yeah this is not something you want

00:25:14,280 --> 00:25:19,710
to do for every language or if you want

00:25:17,670 --> 00:25:21,480
to do it you got to spend a lot of time

00:25:19,710 --> 00:25:25,740
and resources on it to make it work

00:25:21,480 --> 00:25:27,510
right and now that we're talking more

00:25:25,740 --> 00:25:29,570
and more about recursive necks and that

00:25:27,510 --> 00:25:34,230
the implementation is coming

00:25:29,570 --> 00:25:37,650
you could have Nix as the new C cache so

00:25:34,230 --> 00:25:41,490
C cache is a speed up for the for GCC or

00:25:37,650 --> 00:25:45,180
any GCC like compiler where if it

00:25:41,490 --> 00:25:47,280
realizes that it's the arguments have

00:25:45,180 --> 00:25:49,230
already been used in prison coal is

00:25:47,280 --> 00:25:50,370
going to say hey wait a second I already

00:25:49,230 --> 00:25:52,200
have the build output somewhere over

00:25:50,370 --> 00:25:54,450
there which technically is what Nix does

00:25:52,200 --> 00:25:56,640
right because Nix will hash all its

00:25:54,450 --> 00:25:58,380
inputs and if all this happened already

00:25:56,640 --> 00:26:02,550
is going to say yeah reuse this

00:25:58,380 --> 00:26:06,480
derivation that was built X days ago so

00:26:02,550 --> 00:26:08,550
maybe recursive Nix would be a good

00:26:06,480 --> 00:26:10,830
solution for this where say you have a

00:26:08,550 --> 00:26:11,610
build tool like cargo or make or

00:26:10,830 --> 00:26:15,840
anything like that

00:26:11,610 --> 00:26:18,660
and you kind of lie to it you say hey

00:26:15,840 --> 00:26:21,120
make instead of calling GCC here just

00:26:18,660 --> 00:26:24,780
call Nix and you have this in your next

00:26:21,120 --> 00:26:26,970
build and basically when I started the

00:26:24,780 --> 00:26:29,400
talk I said well the build tool is

00:26:26,970 --> 00:26:31,620
something we can emulate in Nix whereas

00:26:29,400 --> 00:26:33,770
the compiler is something it's a given

00:26:31,620 --> 00:26:36,450
it's not something we can get rid of

00:26:33,770 --> 00:26:38,880
maybe with recursive Nix we kind of can

00:26:36,450 --> 00:26:42,240
we leave the build tools to actually

00:26:38,880 --> 00:26:45,990
drive the builds but we plug in next as

00:26:42,240 --> 00:26:47,070
the compiler if Nick's doesn't have

00:26:45,990 --> 00:26:49,650
their deviation pre-built

00:26:47,070 --> 00:26:52,500
then fine you recall the compiler but in

00:26:49,650 --> 00:26:54,180
general most of the time your object

00:26:52,500 --> 00:26:55,410
files are going to be just fresh from

00:26:54,180 --> 00:27:00,640
the cache

00:26:55,410 --> 00:27:02,180
and that's pretty much it thank you for

00:27:00,640 --> 00:27:10,080
your time

00:27:02,180 --> 00:27:13,410
[Applause]

00:27:10,080 --> 00:27:18,280
any questions

00:27:13,410 --> 00:27:21,549
hey great talk so what do you think

00:27:18,280 --> 00:27:24,400
about so the there's a coach and option

00:27:21,549 --> 00:27:26,890
right but I think if you start using

00:27:24,400 --> 00:27:30,760
import from the relation there you kind

00:27:26,890 --> 00:27:35,980
of gain the UX back in in that option

00:27:30,760 --> 00:27:37,179
have you considered that so you're

00:27:35,980 --> 00:27:39,130
saying that if you use import for

00:27:37,179 --> 00:27:42,250
derivation for directly importing Knicks

00:27:39,130 --> 00:27:43,870
code then you don't have to check in the

00:27:42,250 --> 00:27:46,510
generated code yeah yeah and you don't

00:27:43,870 --> 00:27:48,669
have to do so ESCO ESCO Nexus is

00:27:46,510 --> 00:27:52,000
essentially that approach I think the

00:27:48,669 --> 00:27:55,270
talk is tomorrow so but I think you you

00:27:52,000 --> 00:27:58,090
get good UX and you get say my ok

00:27:55,270 --> 00:28:00,340
evaluation times again depending on what

00:27:58,090 --> 00:28:01,960
you're doing yeah so I think it's the

00:28:00,340 --> 00:28:05,260
sweet spot but of course all the

00:28:01,960 --> 00:28:07,480
incrementality is is not there so so I

00:28:05,260 --> 00:28:09,040
think this one is actually or Haskell

00:28:07,480 --> 00:28:12,400
technics in general is closer to the

00:28:09,040 --> 00:28:14,710
lockfile approach because if you don't

00:28:12,400 --> 00:28:16,540
use a log file then okay you might

00:28:14,710 --> 00:28:20,669
generate codes we still need to figure

00:28:16,540 --> 00:28:23,470
out the hashes right the checksums so I

00:28:20,669 --> 00:28:26,679
think it's different from the the cogent

00:28:23,470 --> 00:28:29,799
that I talked about here does that make

00:28:26,679 --> 00:28:33,669
sense yeah I mean I mean it makes sense

00:28:29,799 --> 00:28:35,190
so you can't use that without any table

00:28:33,669 --> 00:28:37,360
of hashes that you had before right

00:28:35,190 --> 00:28:39,100
yeah I think it's somewhere in the

00:28:37,360 --> 00:28:41,980
middle so some things you have the

00:28:39,100 --> 00:28:43,950
hashes from like there's a snapshots of

00:28:41,980 --> 00:28:46,360
hackage and stack age and all of that

00:28:43,950 --> 00:28:48,160
but if it's coming from gates for

00:28:46,360 --> 00:28:50,970
example then you don't have it right so

00:28:48,160 --> 00:28:52,720
it's somewhere in the middle yeah yeah I

00:28:50,970 --> 00:28:54,250
didn't talk about the Haskell

00:28:52,720 --> 00:28:55,990
infrastructure at all actually because

00:28:54,250 --> 00:28:58,540
quite complex never really wrapped my

00:28:55,990 --> 00:29:00,700
head around it but there's lots of smart

00:28:58,540 --> 00:29:03,540
stuff there which wasn't covered at all

00:29:00,700 --> 00:29:08,559
on this talk I was just wondering if you

00:29:03,540 --> 00:29:09,820
thought about the IFD so yeah okay it

00:29:08,559 --> 00:29:15,360
was a question in the back or maybe was

00:29:09,820 --> 00:29:19,020
a an answer yeah a follow up comment

00:29:15,360 --> 00:29:21,300
Ascalon Nix does both I think one

00:29:19,020 --> 00:29:24,870
problem with the pier lock file approach

00:29:21,300 --> 00:29:27,390
is that the build tools themselves don't

00:29:24,870 --> 00:29:30,540
just use the lock file they also can

00:29:27,390 --> 00:29:34,740
consult the cargo dot Tom wall or cabal

00:29:30,540 --> 00:29:37,290
file or other thing so if the point is

00:29:34,740 --> 00:29:39,510
doing the things the way the tool would

00:29:37,290 --> 00:29:42,120
go from the plan I think you do need to

00:29:39,510 --> 00:29:43,910
ingest both or Lobby them to work

00:29:42,120 --> 00:29:46,980
differently upstream pick your poison

00:29:43,910 --> 00:29:49,740
but yeah I think that the IFD should

00:29:46,980 --> 00:29:52,140
help a lot in if you do enough little

00:29:49,740 --> 00:29:55,290
ones that should even be pretty good for

00:29:52,140 --> 00:30:02,430
the evaluation incrementality so fingers

00:29:55,290 --> 00:30:03,840
crossed yeah thank you at one point you

00:30:02,430 --> 00:30:07,170
really have to keep in mind when you do

00:30:03,840 --> 00:30:10,380
dynamic recursive Nick's with dynamic

00:30:07,170 --> 00:30:13,320
dependencies that you like in while

00:30:10,380 --> 00:30:15,180
evaluating the tree or the graph of what

00:30:13,320 --> 00:30:16,800
you have to build you don't know

00:30:15,180 --> 00:30:18,540
everything in front so you have to

00:30:16,800 --> 00:30:19,710
generate parts of the graph while you

00:30:18,540 --> 00:30:22,170
are building because you have to build

00:30:19,710 --> 00:30:23,790
something and IFD already does that but

00:30:22,170 --> 00:30:25,860
it has the restriction that can't access

00:30:23,790 --> 00:30:28,410
network while doing it right so you have

00:30:25,860 --> 00:30:30,540
to check in the lock file and then maybe

00:30:28,410 --> 00:30:33,630
generate Nick's code on the fly in the

00:30:30,540 --> 00:30:36,630
build and then evaluate that but you

00:30:33,630 --> 00:30:40,290
really have to be careful like what what

00:30:36,630 --> 00:30:42,870
you require from the generated graph you

00:30:40,290 --> 00:30:45,570
want to generate on the fly I think the

00:30:42,870 --> 00:30:48,380
best but of all worlds right now is to

00:30:45,570 --> 00:30:51,030
do this integrate package managers and

00:30:48,380 --> 00:30:53,550
use the log files that's like the best

00:30:51,030 --> 00:30:56,340
approach I really really need to go

00:30:53,550 --> 00:30:59,190
upstream and notch the package manager

00:30:56,340 --> 00:31:00,990
creators to produce log files that we

00:30:59,190 --> 00:31:03,210
can actually use because for example for

00:31:00,990 --> 00:31:05,640
yarn sometimes there's only a good hash

00:31:03,210 --> 00:31:09,050
for of a good Rev and no output of the

00:31:05,640 --> 00:31:12,930
gates repository so you still need

00:31:09,050 --> 00:31:16,770
network to generate the next file again

00:31:12,930 --> 00:31:19,020
so that's yeah completely agree so it

00:31:16,770 --> 00:31:22,050
seems to be a trend in a build files or

00:31:19,020 --> 00:31:25,850
build tools to not output a get hash for

00:31:22,050 --> 00:31:28,980
our hash for key dependencies and I

00:31:25,850 --> 00:31:32,700
completely agree we need to find a way

00:31:28,980 --> 00:31:34,610
to tell build tools Hey please guys some

00:31:32,700 --> 00:31:37,020
people might actually need this and

00:31:34,610 --> 00:31:40,440
maybe as NYX grows and because it

00:31:37,020 --> 00:31:41,640
becomes more used widely then we're

00:31:40,440 --> 00:31:44,340
gonna have more ways to actually

00:31:41,640 --> 00:31:48,620
convince them to add checksums pretty

00:31:44,340 --> 00:31:48,620
much everywhere yeah that would be ideal

00:31:56,150 --> 00:31:59,690
I want to just say I think that's

00:31:57,740 --> 00:32:01,760
already happening I think that I mean we

00:31:59,690 --> 00:32:03,890
do see build tools doing more

00:32:01,760 --> 00:32:09,289
I mean cabal now is calling itself NYX

00:32:03,890 --> 00:32:13,039
style and I think that the the the value

00:32:09,289 --> 00:32:14,659
is clear and as we as NYX gets bigger it

00:32:13,039 --> 00:32:16,789
you know it did we don't have to do

00:32:14,659 --> 00:32:19,130
everything ourselves people will build

00:32:16,789 --> 00:32:21,169
tools that integrate better with NYX and

00:32:19,130 --> 00:32:23,929
I think that's a good Avenue to approach

00:32:21,169 --> 00:32:26,049
yeah in a particular case of cabal I

00:32:23,929 --> 00:32:28,700
think they were in the wrong direction

00:32:26,049 --> 00:32:30,860
instead of making it easier for next to

00:32:28,700 --> 00:32:34,270
use they kind of grabbed the ideas from

00:32:30,860 --> 00:32:38,000
NYX and messed up their UX is in time

00:32:34,270 --> 00:32:39,679
related so you mentioned that evaluator

00:32:38,000 --> 00:32:41,419
performance is often very slow did you

00:32:39,679 --> 00:32:44,230
do any investigation into whether there

00:32:41,419 --> 00:32:47,330
are easy speed ups for this nope but uh

00:32:44,230 --> 00:32:50,960
some people have and a few people here

00:32:47,330 --> 00:32:52,159
at Nick's gone so I think they're mostly

00:32:50,960 --> 00:32:54,260
low-hanging fruits because I think was

00:32:52,159 --> 00:32:56,630
the case in uh X packages and a few

00:32:54,260 --> 00:32:58,880
other projects so this is not too much

00:32:56,630 --> 00:33:00,770
of a worry for me if we're getting to

00:32:58,880 --> 00:33:02,120
more pure next builds where Nick's

00:33:00,770 --> 00:33:03,740
actually replaced the build tool I'm

00:33:02,120 --> 00:33:05,510
pretty sure there are solutions to the

00:33:03,740 --> 00:33:07,750
evaluation problem so a follow-up

00:33:05,510 --> 00:33:10,220
question to this in most languages

00:33:07,750 --> 00:33:12,799
compiling an individual translation unit

00:33:10,220 --> 00:33:14,960
is generally very fast so tools like C

00:33:12,799 --> 00:33:16,700
cache have this constraint where it is

00:33:14,960 --> 00:33:18,380
often more expensive to determine if the

00:33:16,700 --> 00:33:20,299
cache has something that it can replace

00:33:18,380 --> 00:33:24,110
than it is to just compile it with GCC

00:33:20,299 --> 00:33:25,399
for most translation units do you so do

00:33:24,110 --> 00:33:28,039
you think it's feasible to get the NICS

00:33:25,399 --> 00:33:29,929
evaluator to be so fast that it is you

00:33:28,039 --> 00:33:31,700
know close to as fast as C cache it

00:33:29,929 --> 00:33:37,309
determining whether it has a translation

00:33:31,700 --> 00:33:38,600
unit replacement I have no idea but it's

00:33:37,309 --> 00:33:40,070
even worse than that because every

00:33:38,600 --> 00:33:42,080
single makes the revision especially if

00:33:40,070 --> 00:33:44,960
you built in sandbox there's a lot of

00:33:42,080 --> 00:33:47,360
infrastructure happening first setting

00:33:44,960 --> 00:33:49,190
up the sandbox and then only kicking in

00:33:47,360 --> 00:33:50,840
the build so yeah these are all things

00:33:49,190 --> 00:33:53,210
we should keep in mind if we're going to

00:33:50,840 --> 00:34:03,100
get something that's close in

00:33:53,210 --> 00:34:03,100
performance and C cash thank you hostage

00:34:06,380 --> 00:34:11,929
a question about the the the pure Nik

00:34:09,590 --> 00:34:13,280
solution because if I understand

00:34:11,929 --> 00:34:15,679
correctly does this mean that's for

00:34:13,280 --> 00:34:19,070
every object file in your system you get

00:34:15,679 --> 00:34:26,300
an entry into next build and they saw

00:34:19,070 --> 00:34:27,859
into next storm yes this sounds scary at

00:34:26,300 --> 00:34:28,399
first but in practice it's not much of a

00:34:27,859 --> 00:34:31,220
problem

00:34:28,399 --> 00:34:33,619
most of these object files are are small

00:34:31,220 --> 00:34:38,899
and actually there are some questions

00:34:33,619 --> 00:34:40,940
there like an we can we improve the

00:34:38,899 --> 00:34:43,280
garbage collector Enix to make sure that

00:34:40,940 --> 00:34:46,460
okay maybe all these small files maybe

00:34:43,280 --> 00:34:48,889
we can tag them as discarded because if

00:34:46,460 --> 00:34:50,389
you change you're a complete module then

00:34:48,889 --> 00:34:52,129
you could say well these are definitely

00:34:50,389 --> 00:34:53,810
not going to be used in a tool like

00:34:52,129 --> 00:34:55,070
appearance implementation could say I'm

00:34:53,810 --> 00:34:57,050
pretty sure I'm not gonna need these

00:34:55,070 --> 00:34:59,330
anymore so please get rid of them as

00:34:57,050 --> 00:35:01,750
fast as possible I'll be very

00:34:59,330 --> 00:35:01,750
interesting

00:35:05,370 --> 00:35:09,540
all right thank you everyone

00:35:11,310 --> 00:35:18,099

YouTube URL: https://www.youtube.com/watch?v=nXDumHZI2zg


