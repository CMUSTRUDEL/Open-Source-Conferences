Title: Nixery - A Nix-backed container registry (NixCon 2019)
Publication date: 2019-12-14
Playlist: NixCon 2019 (Brno)
Description: 
	Nixery builds container images on-demand via Nix and serves them via the standard Docker registry protocol. In this talk we look at how it works, which implementation challenges came up and how it is useful in the so-called "real world".
Captions: 
	00:00:06,620 --> 00:00:23,130
four three two one

00:00:10,950 --> 00:00:24,359
I actually didn't count hi right I'm

00:00:23,130 --> 00:00:26,250
gonna be doing a little bit of dual

00:00:24,359 --> 00:00:27,900
microphone I've noticed kind of

00:00:26,250 --> 00:00:31,199
throughout the course of the conference

00:00:27,900 --> 00:00:32,550
that very few people are doing demos so

00:00:31,199 --> 00:00:34,440
I'm a little bit afraid that the demo

00:00:32,550 --> 00:00:37,770
gods might actually be striking down all

00:00:34,440 --> 00:00:39,629
of their vengeance upon me today because

00:00:37,770 --> 00:00:42,050
I have four so we'll see how that goes

00:00:39,629 --> 00:00:45,420
right

00:00:42,050 --> 00:00:55,910
hello everyone my name is Vincent I

00:00:45,420 --> 00:01:03,570
think I know probably how test123 okay

00:00:55,910 --> 00:01:05,400
it's a good start right let's do it this

00:01:03,570 --> 00:01:07,189
way um my name is Vincent I think I know

00:01:05,400 --> 00:01:09,510
about half of the people in this room

00:01:07,189 --> 00:01:11,159
testin is my username that's probably

00:01:09,510 --> 00:01:12,630
the name by which people know me better

00:01:11,159 --> 00:01:15,150
than my real name

00:01:12,630 --> 00:01:16,830
so yeah it's the same username and

00:01:15,150 --> 00:01:19,170
github Twitter IRC whatever so that's

00:01:16,830 --> 00:01:20,729
how you can reach out to me cool

00:01:19,170 --> 00:01:23,790
so I'm I'm here to talk to you about

00:01:20,729 --> 00:01:26,490
Nick Suri my fresh and healthy way of

00:01:23,790 --> 00:01:27,630
building container images and to kind of

00:01:26,490 --> 00:01:29,220
kick that off I want to give you a

00:01:27,630 --> 00:01:31,439
little bit of an overview over what the

00:01:29,220 --> 00:01:36,570
container ecosystem looks like at the

00:01:31,439 --> 00:01:38,880
moment on a very high level so quick

00:01:36,570 --> 00:01:43,259
show of hands who has never used docker

00:01:38,880 --> 00:01:45,540
or anything like it okay very few people

00:01:43,259 --> 00:01:47,430
cool I'm not gonna go into what

00:01:45,540 --> 00:01:49,079
containers are and so on but I'll say a

00:01:47,430 --> 00:01:50,640
little bit about how the tooling works

00:01:49,079 --> 00:01:52,770
because that's kind of all the

00:01:50,640 --> 00:01:55,350
background that you're going to need so

00:01:52,770 --> 00:01:57,240
docker has a concept of images that are

00:01:55,350 --> 00:01:59,369
basically like root file systems of a

00:01:57,240 --> 00:02:01,290
distribution that are made up of a bunch

00:01:59,369 --> 00:02:03,600
of different tar balls called layers

00:02:01,290 --> 00:02:05,610
that are distributed over a registry

00:02:03,600 --> 00:02:08,190
protocol the details of how this works

00:02:05,610 --> 00:02:10,440
under the hood don't really matter but

00:02:08,190 --> 00:02:11,940
the the important thing is that there

00:02:10,440 --> 00:02:13,620
are different layers that get merged

00:02:11,940 --> 00:02:15,720
together so if you have

00:02:13,620 --> 00:02:18,060
if you have a sequential list of tower

00:02:15,720 --> 00:02:19,860
bolts that contain non overlapping paths

00:02:18,060 --> 00:02:22,170
and it will be squashed into one file

00:02:19,860 --> 00:02:23,909
system if you have overlapping paths and

00:02:22,170 --> 00:02:25,620
the ones from the latter ones in the

00:02:23,909 --> 00:02:27,890
order of the image manifest appearance

00:02:25,620 --> 00:02:30,629
other ones that take precedence

00:02:27,890 --> 00:02:33,870
so this syntax over here is what's

00:02:30,629 --> 00:02:36,030
called a docker file this is the default

00:02:33,870 --> 00:02:38,400
method of building docker images you

00:02:36,030 --> 00:02:40,680
specify the base image that you have at

00:02:38,400 --> 00:02:43,019
the top which in this case is Ubuntu and

00:02:40,680 --> 00:02:43,980
then you run individual commands and

00:02:43,019 --> 00:02:46,049
there's a bunch of additional

00:02:43,980 --> 00:02:48,870
instructions such as n which sets

00:02:46,049 --> 00:02:50,970
environment variables and so on what

00:02:48,870 --> 00:02:52,650
happens when you execute this is that

00:02:50,970 --> 00:02:54,989
docker goes and it takes every single

00:02:52,650 --> 00:02:57,209
instruction in this docker file and it

00:02:54,989 --> 00:02:59,459
executes it and it takes the resulting

00:02:57,209 --> 00:03:01,640
diff of file systems and turns it into a

00:02:59,459 --> 00:03:04,319
layer what this means is that this is

00:03:01,640 --> 00:03:06,690
inherently extremely stateful because

00:03:04,319 --> 00:03:09,629
there is no caretaking to make sure that

00:03:06,690 --> 00:03:11,310
things like timestamps on files are in

00:03:09,629 --> 00:03:12,690
any way normalized so things that we

00:03:11,310 --> 00:03:15,659
deal with in Nix on a very fundamental

00:03:12,690 --> 00:03:18,030
level just kind of don't exist

00:03:15,659 --> 00:03:19,919
conceptually in this world so I actually

00:03:18,030 --> 00:03:23,010
took this particular docker phone I ran

00:03:19,919 --> 00:03:25,919
it twice earlier today and here the

00:03:23,010 --> 00:03:28,079
hashes resulting from from the two image

00:03:25,919 --> 00:03:30,419
bills as you can see they have nothing

00:03:28,079 --> 00:03:35,040
to do with each other at all this was

00:03:30,419 --> 00:03:36,359
kind of my reaction and a while back I

00:03:35,040 --> 00:03:38,340
already started thinking about whether

00:03:36,359 --> 00:03:40,799
or not there might be a better way to do

00:03:38,340 --> 00:03:44,609
this um those of you talked to me at the

00:03:40,799 --> 00:03:46,290
next cone in 2018 probably heard my

00:03:44,609 --> 00:03:47,760
ideas about the kubernetes controller

00:03:46,290 --> 00:03:49,889
for Nix I will get to that in a second

00:03:47,760 --> 00:03:52,440
but also there have been other people

00:03:49,889 --> 00:03:54,169
working on very similar things for a

00:03:52,440 --> 00:03:56,699
while so there was an initial attempt

00:03:54,169 --> 00:03:59,250
actually not an attempt it works to

00:03:56,699 --> 00:04:01,169
build a docker image via Nix called just

00:03:59,250 --> 00:04:03,120
build image that's in darker tools that

00:04:01,169 --> 00:04:05,639
build image and what that does the way I

00:04:03,120 --> 00:04:07,560
understand it is it spins up a qmu

00:04:05,639 --> 00:04:09,209
installs the things that you want in it

00:04:07,560 --> 00:04:11,430
and takes a snapshot of that file system

00:04:09,209 --> 00:04:13,620
plus some extra information that was the

00:04:11,430 --> 00:04:15,510
first first idea for building docker

00:04:13,620 --> 00:04:18,440
images Nixon actually worked reasonably

00:04:15,510 --> 00:04:21,539
well and then graham see is he here

00:04:18,440 --> 00:04:23,130
somewhere he is maybe not in this room

00:04:21,539 --> 00:04:24,750
right now anyways he he wrote a thing

00:04:23,130 --> 00:04:26,200
called build layered image they will be

00:04:24,750 --> 00:04:29,530
referencing a couple of times

00:04:26,200 --> 00:04:31,180
the talk which takes a more pure Knicks

00:04:29,530 --> 00:04:33,550
approach to the construction of the

00:04:31,180 --> 00:04:35,650
layers so instead of spinning up virtual

00:04:33,550 --> 00:04:37,510
machines and snapshotting their discs it

00:04:35,650 --> 00:04:42,430
actually uses Knicks to construct the

00:04:37,510 --> 00:04:45,820
tower walls themselves right so but a

00:04:42,430 --> 00:04:47,440
year and a half ago I had this idea for

00:04:45,820 --> 00:04:49,150
what what would the world look like if

00:04:47,440 --> 00:04:51,400
we didn't actually have to build these

00:04:49,150 --> 00:04:53,350
container images explicitly and we just

00:04:51,400 --> 00:04:54,790
have some sort of content specification

00:04:53,350 --> 00:04:56,980
that tells us what we want in an image

00:04:54,790 --> 00:04:59,050
and the image is built based on that so

00:04:56,980 --> 00:05:00,820
here's a mock-up of something that I

00:04:59,050 --> 00:05:03,490
kind of prototyped in the beginning

00:05:00,820 --> 00:05:05,560
where we added an extra resource to the

00:05:03,490 --> 00:05:07,120
kubernetes api that's that's something

00:05:05,560 --> 00:05:09,640
that is supported in kubernetes you can

00:05:07,120 --> 00:05:11,680
see that up here and then we had this

00:05:09,640 --> 00:05:13,870
simple UML specification where each of

00:05:11,680 --> 00:05:15,730
the keys referred to a top-level entry

00:05:13,870 --> 00:05:17,830
in nick's packages and you kind of

00:05:15,730 --> 00:05:19,810
submitted this into your cluster and

00:05:17,830 --> 00:05:21,640
then a daemon kind of ran in the back of

00:05:19,810 --> 00:05:23,140
the cluster built an image out of this

00:05:21,640 --> 00:05:25,510
pushed it into your registry and did

00:05:23,140 --> 00:05:27,550
this whole normal stateful kind of dance

00:05:25,510 --> 00:05:31,060
but abstracted away for the user by just

00:05:27,550 --> 00:05:32,440
creating an image with this name after

00:05:31,060 --> 00:05:35,320
building this an interesting thing

00:05:32,440 --> 00:05:37,450
happened so I try to demo this to people

00:05:35,320 --> 00:05:39,040
and it turns out that when you're

00:05:37,450 --> 00:05:40,750
demoing this there's a lot of moving

00:05:39,040 --> 00:05:42,910
parts and you need to like write a Yama

00:05:40,750 --> 00:05:45,220
file you need to submit the ml file to a

00:05:42,910 --> 00:05:46,390
kubernetes cluster then a thing needs to

00:05:45,220 --> 00:05:48,340
run in the background and build the

00:05:46,390 --> 00:05:51,250
image and push it into a registry and

00:05:48,340 --> 00:05:52,720
then kubernetes launches pods that pull

00:05:51,250 --> 00:05:54,850
the image from there so you've got got

00:05:52,720 --> 00:05:56,500
an end of six seven things that can go

00:05:54,850 --> 00:05:58,510
wrong and they all take a little bit of

00:05:56,500 --> 00:05:59,920
time so it's the kind of demo where you

00:05:58,510 --> 00:06:01,510
try to show it to someone you make a few

00:05:59,920 --> 00:06:03,160
typos and they're kind of half falling

00:06:01,510 --> 00:06:04,720
asleep me and I could trust me this is a

00:06:03,160 --> 00:06:05,880
valuable concept that I'm trying to get

00:06:04,720 --> 00:06:09,310
across

00:06:05,880 --> 00:06:11,770
so so I actually invented on the fly at

00:06:09,310 --> 00:06:15,130
some point this is this idea of a demo

00:06:11,770 --> 00:06:17,530
mode for the controller so the idea here

00:06:15,130 --> 00:06:19,450
was that instead of having a

00:06:17,530 --> 00:06:21,610
specification pre heart of what goes

00:06:19,450 --> 00:06:24,640
into the image we just use the

00:06:21,610 --> 00:06:25,480
components of the image to describe what

00:06:24,640 --> 00:06:29,170
should go into it

00:06:25,480 --> 00:06:31,210
so they're kind of two main parts here

00:06:29,170 --> 00:06:32,770
there's the host name which is just the

00:06:31,210 --> 00:06:34,660
address at which Daka should look up the

00:06:32,770 --> 00:06:36,730
image that you're downloading then we've

00:06:34,660 --> 00:06:38,950
got a section that describes the

00:06:36,730 --> 00:06:39,529
packages and the first ones in here are

00:06:38,950 --> 00:06:41,389
called

00:06:39,529 --> 00:06:44,269
packages which is kind of a shorthand

00:06:41,389 --> 00:06:46,669
for sets of packages so she'll for

00:06:44,269 --> 00:06:49,009
example gives you a batch interactive

00:06:46,669 --> 00:06:50,629
Ayana Etsy and like all these kinds of

00:06:49,009 --> 00:06:52,699
things that you probably want if you

00:06:50,629 --> 00:06:55,279
want to shell environment and then you

00:06:52,699 --> 00:06:57,079
can specify paths separated other

00:06:55,279 --> 00:06:59,659
packages that should go into this image

00:06:57,079 --> 00:07:00,889
so I built this demo mode and then I

00:06:59,659 --> 00:07:02,689
realized it it's actually a much better

00:07:00,889 --> 00:07:04,339
idea than the first one I had and then I

00:07:02,689 --> 00:07:06,559
kind of scrapped the actual controller

00:07:04,339 --> 00:07:10,879
and was just like this is the this is

00:07:06,559 --> 00:07:12,619
the way forward right um before we talk

00:07:10,879 --> 00:07:14,149
about this slide I'm gonna start doing

00:07:12,619 --> 00:07:15,949
my first little demo just to show you

00:07:14,149 --> 00:07:18,019
what this thing actually looks like in

00:07:15,949 --> 00:07:21,739
practice okay

00:07:18,019 --> 00:07:23,599
microphone number two so here's the

00:07:21,739 --> 00:07:25,519
public instance of Nick sorry it's

00:07:23,599 --> 00:07:27,169
available at Nick's reader dev and this

00:07:25,519 --> 00:07:30,499
is kind of like a public service you can

00:07:27,169 --> 00:07:33,769
go and play with um so just to remember

00:07:30,499 --> 00:07:35,839
that I can I can you don't actually need

00:07:33,769 --> 00:07:37,489
to read this and just trying to show the

00:07:35,839 --> 00:07:39,799
logo as often as I can because I spent

00:07:37,489 --> 00:07:43,879
countless hours designing this as you

00:07:39,799 --> 00:07:46,099
can see so let's do a little demo of

00:07:43,879 --> 00:07:49,249
this um here's here's the standard

00:07:46,099 --> 00:07:56,089
darker CLI what this command says is

00:07:49,249 --> 00:07:57,649
that readable enough okay excellent what

00:07:56,089 --> 00:07:59,149
this says is we're gonna run a container

00:07:57,649 --> 00:08:00,889
we're gonna attach a TTY

00:07:59,149 --> 00:08:02,779
interactively we're going to remove the

00:08:00,889 --> 00:08:04,399
container after we're done and then we

00:08:02,779 --> 00:08:06,019
will pull the image from Nick's reader

00:08:04,399 --> 00:08:10,009
dev and we want an image containing

00:08:06,019 --> 00:08:12,019
shell so as per the previous slide this

00:08:10,009 --> 00:08:14,959
is going to give us an image that just

00:08:12,019 --> 00:08:17,659
contains a basic bash environment in a

00:08:14,959 --> 00:08:21,589
second so and I need to actually tell it

00:08:17,659 --> 00:08:24,739
what to run so here we go here's a bash

00:08:21,589 --> 00:08:26,359
it's got core utils and and all sorts of

00:08:24,739 --> 00:08:28,039
things installed but no additional

00:08:26,359 --> 00:08:29,509
programs if I tried to run htough which

00:08:28,039 --> 00:08:31,969
I didn't specify in the image it's not

00:08:29,509 --> 00:08:34,909
going to be included so what I can do I

00:08:31,969 --> 00:08:37,309
can exit out of this and I can edit it

00:08:34,909 --> 00:08:39,079
to include additional programs again

00:08:37,309 --> 00:08:41,059
these are just referencing keys in

00:08:39,079 --> 00:08:43,249
Nick's packages and then an image is

00:08:41,059 --> 00:08:45,980
built on the fly and kind of sent to me

00:08:43,249 --> 00:08:48,860
and now I have a shell in which I can

00:08:45,980 --> 00:08:52,339
actually run each other so that's the

00:08:48,860 --> 00:08:52,889
basic mode of operation in this public

00:08:52,339 --> 00:08:54,749
instance

00:08:52,889 --> 00:08:56,879
it's running at Nick's rated F I track

00:08:54,749 --> 00:08:58,639
whichever is the latest Nick's West

00:08:56,879 --> 00:09:02,850
channel and I do updates for this

00:08:58,639 --> 00:09:04,439
roughly once or twice a week but it

00:09:02,850 --> 00:09:05,850
turns out that what's actually a much

00:09:04,439 --> 00:09:07,049
more interesting use case than just

00:09:05,850 --> 00:09:08,730
having a thing that can give you these

00:09:07,049 --> 00:09:11,279
arbitrary images at heart it's the

00:09:08,730 --> 00:09:12,959
ability to add your own private services

00:09:11,279 --> 00:09:17,489
into it and see how this can be useful

00:09:12,959 --> 00:09:20,239
for CI in organisations so there's

00:09:17,489 --> 00:09:22,850
something about I have to show I

00:09:20,239 --> 00:09:26,639
personally am a mana rapper person and

00:09:22,850 --> 00:09:28,889
here is the default of Nicks of my

00:09:26,639 --> 00:09:30,629
personal infrastructure repository it

00:09:28,889 --> 00:09:33,720
contains stuff like my blog and so on

00:09:30,629 --> 00:09:34,889
and this is mostly standard Nick stuff

00:09:33,720 --> 00:09:37,980
so there's nothing like super

00:09:34,889 --> 00:09:39,629
interesting to show here I import Nick's

00:09:37,980 --> 00:09:41,339
packages from a pin commit and then I

00:09:39,629 --> 00:09:44,579
have an overlay that overlays my

00:09:41,339 --> 00:09:45,809
standard packages on top of it if you if

00:09:44,579 --> 00:09:47,069
you want to know how this works in

00:09:45,809 --> 00:09:48,869
detail and have discussions about

00:09:47,069 --> 00:09:51,059
pinning channels and so on we can do

00:09:48,869 --> 00:09:53,970
that after the tour because it's a

00:09:51,059 --> 00:09:55,889
slightly different thing anyways in here

00:09:53,970 --> 00:09:58,709
I have a thing that I built which is the

00:09:55,889 --> 00:10:01,799
NYX demo I'm using enmity as where

00:09:58,709 --> 00:10:04,919
is he also somewhere excellent Nash

00:10:01,799 --> 00:10:06,419
which builds which builds rust based on

00:10:04,919 --> 00:10:10,379
locked file specifications huge fan of

00:10:06,419 --> 00:10:13,799
that and they wrote a tiny that's the

00:10:10,379 --> 00:10:15,689
wrong one I wrote a tiny demo which just

00:10:13,799 --> 00:10:17,910
looks like this it can either run as a

00:10:15,689 --> 00:10:20,009
webserver showing showing me this nice

00:10:17,910 --> 00:10:22,350
message I hope for the check people here

00:10:20,009 --> 00:10:25,110
that I spelled that correctly trusting

00:10:22,350 --> 00:10:26,429
the internet um or run with the CLI

00:10:25,110 --> 00:10:27,779
argument it doesn't really matter what

00:10:26,429 --> 00:10:29,939
this program does I just want to show

00:10:27,779 --> 00:10:31,169
you that there's an actual actual thing

00:10:29,939 --> 00:10:33,839
going on here

00:10:31,169 --> 00:10:35,999
so I'm importing that into my into my

00:10:33,839 --> 00:10:38,910
next package set and then I have it

00:10:35,999 --> 00:10:41,429
available in my overlay of packages so

00:10:38,910 --> 00:10:44,249
down here I have a shell in which DRM

00:10:41,429 --> 00:10:45,839
has just thanks to Zumba has just loaded

00:10:44,249 --> 00:10:49,079
some environment variables for me and

00:10:45,839 --> 00:10:51,720
one of them is it's the one called Nick

00:10:49,079 --> 00:10:53,429
Suri packages path so I support multiple

00:10:51,720 --> 00:10:55,619
different sources for importing package

00:10:53,429 --> 00:10:57,989
sets into Nick's tree and one of them is

00:10:55,619 --> 00:10:59,699
using git repositories and one of them

00:10:57,989 --> 00:11:01,799
is using local file paths in this case

00:10:59,699 --> 00:11:03,329
I'm just using the file path of the

00:11:01,799 --> 00:11:04,970
check out of my repository so I'm

00:11:03,329 --> 00:11:06,530
telling Nick Suri that

00:11:04,970 --> 00:11:08,240
the package set from which I want you to

00:11:06,530 --> 00:11:13,160
build images is the one I have at this

00:11:08,240 --> 00:11:17,740
place on my disk so what I can do now is

00:11:13,160 --> 00:11:19,790
I can go and spin up an x-ray in here

00:11:17,740 --> 00:11:22,760
which looks like that

00:11:19,790 --> 00:11:24,980
and then over here on the other side I

00:11:22,760 --> 00:11:29,390
can do the same thing I was doing before

00:11:24,980 --> 00:11:31,160
with my with my shell but instead of

00:11:29,390 --> 00:11:32,870
pulling from NYX reader dev I'm pulling

00:11:31,160 --> 00:11:36,200
from local house so this is the local

00:11:32,870 --> 00:11:37,580
instance I've running so this one wasn't

00:11:36,200 --> 00:11:39,800
particularly interesting because it was

00:11:37,580 --> 00:11:42,170
cached already I think but yeah I just

00:11:39,800 --> 00:11:45,140
want to show that there is nothing in

00:11:42,170 --> 00:11:47,470
here right now so there's no program

00:11:45,140 --> 00:11:52,190
called Nick scan demo and I'm going to

00:11:47,470 --> 00:11:53,480
remove that image just to prove to you

00:11:52,190 --> 00:11:56,870
that I'm not going to try and hit any

00:11:53,480 --> 00:12:00,140
caches here I don't actually I would

00:11:56,870 --> 00:12:01,730
help if I could spell I don't have it so

00:12:00,140 --> 00:12:08,530
then we can go and run this command

00:12:01,730 --> 00:12:10,120
again and add this one to the image yeah

00:12:08,530 --> 00:12:16,810
here we go

00:12:10,120 --> 00:12:19,460
could not find Nick's package Thanks

00:12:16,810 --> 00:12:20,930
here we go okay so what was supposed to

00:12:19,460 --> 00:12:23,930
happen is that I pulled an image down

00:12:20,930 --> 00:12:26,840
now and it contains the the binary that

00:12:23,930 --> 00:12:28,340
I've added here quick show of hands how

00:12:26,840 --> 00:12:30,680
much time should I spend working on

00:12:28,340 --> 00:12:35,240
getting that demo up and running whereas

00:12:30,680 --> 00:12:38,050
it's not okay I'll give it I'll give it

00:12:35,240 --> 00:12:38,050
20 seconds

00:12:42,790 --> 00:12:50,920
that looks correct to me and then here

00:12:46,300 --> 00:12:55,269
at the top somewhere yep

00:12:50,920 --> 00:12:59,560
oh okay it's just called Nick's cone

00:12:55,269 --> 00:13:02,320
here we go right and now I have my NYX

00:12:59,560 --> 00:13:04,690
condom oh thing in here built from the

00:13:02,320 --> 00:13:09,130
package set overlaid into my local

00:13:04,690 --> 00:13:10,990
configuration cool so so that works and

00:13:09,130 --> 00:13:14,649
it actually turns into kind of

00:13:10,990 --> 00:13:17,649
interesting way of deploying services

00:13:14,649 --> 00:13:20,290
because in the in the configuration mode

00:13:17,649 --> 00:13:22,360
where I let you specify git repository

00:13:20,290 --> 00:13:24,730
instead of a file path I can translate

00:13:22,360 --> 00:13:26,649
tags into git commits which we will see

00:13:24,730 --> 00:13:28,510
in a bit and then you kind of start

00:13:26,649 --> 00:13:30,850
getting the ability to build CI

00:13:28,510 --> 00:13:32,470
pipelines out of this before I show that

00:13:30,850 --> 00:13:34,750
I want to talk about something that I

00:13:32,470 --> 00:13:36,550
spend way too much time on because a

00:13:34,750 --> 00:13:37,810
sort of premature optimization but it

00:13:36,550 --> 00:13:40,360
was an interesting thing to go through

00:13:37,810 --> 00:13:41,680
and this is something that Graham kind

00:13:40,360 --> 00:13:45,339
of kicked off when you started building

00:13:41,680 --> 00:13:47,860
build layered image um for historical

00:13:45,339 --> 00:13:49,600
reasons docker has a maximum number of

00:13:47,860 --> 00:13:54,430
layers that you can have in an image

00:13:49,600 --> 00:13:56,290
it's around 125 for some reason and it

00:13:54,430 --> 00:13:57,790
turns out that even using up all of

00:13:56,290 --> 00:14:00,069
those is not a very good idea because

00:13:57,790 --> 00:14:01,870
you share this this layer restriction

00:14:00,069 --> 00:14:04,029
with your user so if you have users have

00:14:01,870 --> 00:14:06,639
want to pull an image and extend it by

00:14:04,029 --> 00:14:09,639
adding additional files you can't if the

00:14:06,639 --> 00:14:12,870
if there's already 125 layers in the

00:14:09,639 --> 00:14:16,389
image so Graham had this initial idea of

00:14:12,870 --> 00:14:18,760
creating a graph of all the dependencies

00:14:16,389 --> 00:14:21,100
that our given image needs and then

00:14:18,760 --> 00:14:22,870
counting the popularity of individual

00:14:21,100 --> 00:14:24,940
things inside of that graphs if you have

00:14:22,870 --> 00:14:27,130
more than one derivation that references

00:14:24,940 --> 00:14:29,949
something like gilepsy then gilepsy

00:14:27,130 --> 00:14:32,380
becomes more popular and eventually you

00:14:29,949 --> 00:14:34,300
saw it by this popularity and kind of

00:14:32,380 --> 00:14:35,620
pick the most important ones from the

00:14:34,300 --> 00:14:38,139
top and hope that those are going to

00:14:35,620 --> 00:14:41,709
match but in this case you have a

00:14:38,139 --> 00:14:44,139
maximum of one derivation or one closure

00:14:41,709 --> 00:14:46,660
per image layer but there are many

00:14:44,139 --> 00:14:48,850
situations in which some kind of thing

00:14:46,660 --> 00:14:50,769
depends on let's say we have a program

00:14:48,850 --> 00:14:52,630
called foo and it depends on food data

00:14:50,769 --> 00:14:53,980
there is never really a good reason to

00:14:52,630 --> 00:14:55,269
split foo and food data

00:14:53,980 --> 00:14:56,180
apart from each other so we want to

00:14:55,269 --> 00:14:57,680
actually put

00:14:56,180 --> 00:14:59,779
in the same layer and make sure that we

00:14:57,680 --> 00:15:03,350
get kind of optimal caching here doing

00:14:59,779 --> 00:15:04,880
the builds so I'm gonna walk you quickly

00:15:03,350 --> 00:15:06,230
through how that works and there's some

00:15:04,880 --> 00:15:11,029
more detailed write-up for those of you

00:15:06,230 --> 00:15:12,500
that like graphs right I suspect that

00:15:11,029 --> 00:15:14,120
some of this is not going to be readable

00:15:12,500 --> 00:15:16,279
all the way from the back but I'm going

00:15:14,120 --> 00:15:18,080
to very quickly talk through this so I

00:15:16,279 --> 00:15:20,300
had to find something that doesn't have

00:15:18,080 --> 00:15:22,370
a whole lot of dependencies to actually

00:15:20,300 --> 00:15:24,350
demo this it turns out my initial

00:15:22,370 --> 00:15:26,029
attempt was to use git but get depends

00:15:24,350 --> 00:15:27,709
on literally the entire universe and

00:15:26,029 --> 00:15:31,670
every single pearl package that exists

00:15:27,709 --> 00:15:33,620
so that's a lot of packages what we have

00:15:31,670 --> 00:15:36,110
here is you see a blue node at the top

00:15:33,620 --> 00:15:37,820
that's called the image root and then

00:15:36,110 --> 00:15:39,680
there's a few arrows that go from that

00:15:37,820 --> 00:15:41,540
to the to the top level of this graph

00:15:39,680 --> 00:15:43,220
which are images which have packages

00:15:41,540 --> 00:15:46,220
that the user requested specifically

00:15:43,220 --> 00:15:47,750
here there's H top and there's nano and

00:15:46,220 --> 00:15:49,670
there's a shell somewhere and that's

00:15:47,750 --> 00:15:52,240
kind of kind of it for this image um

00:15:49,670 --> 00:15:54,800
actually Nano is part of the shell alias

00:15:52,240 --> 00:15:56,570
and then if we look at this there's a

00:15:54,800 --> 00:15:59,779
few interesting things in here so for

00:15:56,570 --> 00:16:01,760
example pearl is only referenced once by

00:15:59,779 --> 00:16:04,100
the more utils from up there but

00:16:01,760 --> 00:16:05,900
parallel itself actually turns out to be

00:16:04,100 --> 00:16:07,760
a very popular package there's a lot of

00:16:05,900 --> 00:16:09,470
things that depend on pearl so we would

00:16:07,760 --> 00:16:11,510
like to use this information and kind of

00:16:09,470 --> 00:16:13,790
make sure that Pearl ends have not

00:16:11,510 --> 00:16:15,500
bundled together with more utils and

00:16:13,790 --> 00:16:17,029
similarly we can see that G Lipsy is

00:16:15,500 --> 00:16:20,660
extremely popular it's got a lot of

00:16:17,029 --> 00:16:22,250
arrows going into it so so what I

00:16:20,660 --> 00:16:24,560
started doing at this point is is

00:16:22,250 --> 00:16:26,690
together with with a few people on IRC

00:16:24,560 --> 00:16:29,029
and also at work we devised an algorithm

00:16:26,690 --> 00:16:31,640
for counting the popularity of all

00:16:29,029 --> 00:16:33,650
packages and Knicks packages by just

00:16:31,640 --> 00:16:35,270
checking how many runtime references

00:16:33,650 --> 00:16:37,160
there are to any given derivation and

00:16:35,270 --> 00:16:39,529
then creating a kind of popularity

00:16:37,160 --> 00:16:42,410
metric by multiplying that with the size

00:16:39,529 --> 00:16:44,810
of the closure so that we can get kind

00:16:42,410 --> 00:16:47,779
of the best cache hit performance in

00:16:44,810 --> 00:16:50,720
terms of data transferred and whatnot so

00:16:47,779 --> 00:16:53,000
the way this works is that the red ones

00:16:50,720 --> 00:16:56,200
here have been identified by Nick Sri as

00:16:53,000 --> 00:16:59,209
popular packages and we go and we draw

00:16:56,200 --> 00:17:00,980
extra edges from the route to those

00:16:59,209 --> 00:17:02,930
popular packages which in the case of

00:17:00,980 --> 00:17:05,569
pearl for example now means that there

00:17:02,930 --> 00:17:08,569
are two paths going into inter pearl

00:17:05,569 --> 00:17:10,279
that's the red one up here and then we

00:17:08,569 --> 00:17:12,649
create what's called a Dominator tree of

00:17:10,279 --> 00:17:16,339
this which is which is a relay outing of

00:17:12,649 --> 00:17:18,559
a graph into a tree in which every node

00:17:16,339 --> 00:17:20,839
is preceded by the ones that all paths

00:17:18,559 --> 00:17:22,729
to it must pass through if that was

00:17:20,839 --> 00:17:25,429
confusing the Wikipedia article will

00:17:22,729 --> 00:17:27,169
explain it to you that ends up looking

00:17:25,429 --> 00:17:29,799
like this and suddenly we have a very

00:17:27,169 --> 00:17:31,970
ordered graph of how these things look

00:17:29,799 --> 00:17:34,309
so we have the image route and then we

00:17:31,970 --> 00:17:36,229
have a top layer which actually matches

00:17:34,309 --> 00:17:37,999
very well with the images at the image

00:17:36,229 --> 00:17:40,279
layer so we would like to stick into the

00:17:37,999 --> 00:17:42,409
same table and then stuff like more

00:17:40,279 --> 00:17:44,029
utils which depends on some of these not

00:17:42,409 --> 00:17:45,769
very popular perl libraries and

00:17:44,029 --> 00:17:48,259
relatively speaking to the rest of the

00:17:45,769 --> 00:17:50,989
ecosystem anyways and we can bundle

00:17:48,259 --> 00:17:52,159
these together into the same layout so

00:17:50,989 --> 00:17:54,409
once we get to this point we can

00:17:52,159 --> 00:17:56,389
calculate the ideal layer layout which

00:17:54,409 --> 00:17:58,340
looks like this and then based on that

00:17:56,389 --> 00:18:00,349
budget we have available for layers we

00:17:58,340 --> 00:18:02,269
can start merging in the least popular

00:18:00,349 --> 00:18:05,749
things together and then we actually get

00:18:02,269 --> 00:18:07,460
pretty good built cashing out of it cool

00:18:05,749 --> 00:18:09,379
and does this make sense so far so

00:18:07,460 --> 00:18:13,460
anybody would like to inject a question

00:18:09,379 --> 00:18:16,460
at this point right let's move on so

00:18:13,460 --> 00:18:18,349
what about image tags one component of

00:18:16,460 --> 00:18:20,119
image names who didn't mention before is

00:18:18,349 --> 00:18:23,450
this yellow one here at the end it's the

00:18:20,119 --> 00:18:25,070
image tag for for darker this is

00:18:23,450 --> 00:18:26,779
commonly versions that people add to

00:18:25,070 --> 00:18:29,210
things so they will have something like

00:18:26,779 --> 00:18:30,830
Ubuntu : and then in a bun to release

00:18:29,210 --> 00:18:33,109
version or whatever but I realized so we

00:18:30,830 --> 00:18:34,489
can actually use this information and

00:18:33,109 --> 00:18:36,499
map it onto something else

00:18:34,489 --> 00:18:38,989
specifically get commits so if you're

00:18:36,499 --> 00:18:40,729
pointing Nik Surrey at at the public

00:18:38,989 --> 00:18:42,859
next packages wrapper you could use this

00:18:40,729 --> 00:18:45,169
to get arbitrary references like

00:18:42,859 --> 00:18:46,340
specific channels or specific commits if

00:18:45,169 --> 00:18:49,099
you're pointing it at a private

00:18:46,340 --> 00:18:51,889
repository you can start having your CI

00:18:49,099 --> 00:18:53,859
substitute these parameters and then you

00:18:51,889 --> 00:18:59,749
can use this as your deployment strategy

00:18:53,859 --> 00:19:02,389
so to quickly show that I will show you

00:18:59,749 --> 00:19:03,859
a demo involving kubernetes and this is

00:19:02,389 --> 00:19:06,840
going to be the one that will definitely

00:19:03,859 --> 00:19:10,799
fail so wish me luck

00:19:06,840 --> 00:19:14,519
right but I basically want to show first

00:19:10,799 --> 00:19:17,730
of all is the deployment manifest for my

00:19:14,519 --> 00:19:20,220
blog so my blog which most of you

00:19:17,730 --> 00:19:21,960
haven't read and I don't really post to

00:19:20,220 --> 00:19:23,700
it so whatever it's an interesting

00:19:21,960 --> 00:19:26,759
experimental playground for new

00:19:23,700 --> 00:19:29,249
technology I have this discriminatees

00:19:26,759 --> 00:19:31,620
manifest that deploys the blog for those

00:19:29,249 --> 00:19:32,909
of you not familiar with kubernetes most

00:19:31,620 --> 00:19:35,399
of the fields in here don't really

00:19:32,909 --> 00:19:37,679
matter it's just a kind of verbose thing

00:19:35,399 --> 00:19:38,070
the primary line in here is this one

00:19:37,679 --> 00:19:40,649
here

00:19:38,070 --> 00:19:42,059
it specifies the image to run I'm going

00:19:40,649 --> 00:19:45,509
to zoom in a little bit just to make

00:19:42,059 --> 00:19:46,919
sure that people can see this where

00:19:45,509 --> 00:19:48,269
what's basically going on is that I am

00:19:46,919 --> 00:19:50,549
pulling an image from Nick's reader

00:19:48,269 --> 00:19:52,289
local which is a private DNS name

00:19:50,549 --> 00:19:54,690
pointing to an extra instance running

00:19:52,289 --> 00:19:55,529
inside of my cluster how to do this is

00:19:54,690 --> 00:19:57,330
something I'm currently writing

00:19:55,529 --> 00:19:58,919
documentation for us that people will be

00:19:57,330 --> 00:20:02,220
able to start doing that on their own

00:19:58,919 --> 00:20:04,559
very soon and then I want the attribute

00:20:02,220 --> 00:20:07,799
astronaut blog which is the the

00:20:04,559 --> 00:20:10,499
derivation for my blog and I specify the

00:20:07,799 --> 00:20:12,419
version as get head get head so this

00:20:10,499 --> 00:20:14,909
syntax here is from a templating tool

00:20:12,419 --> 00:20:17,070
that I use called contemplate which

00:20:14,909 --> 00:20:20,539
basically just inserts the current get

00:20:17,070 --> 00:20:25,289
commit of the repository that you're in

00:20:20,539 --> 00:20:27,779
right so what I can show you at this

00:20:25,289 --> 00:20:29,999
point is I can describe the deployment

00:20:27,779 --> 00:20:31,649
for my blog in kubernetes this is live

00:20:29,999 --> 00:20:33,749
speaking to the kubernetes cluster in

00:20:31,649 --> 00:20:36,570
which I deploy my personal things and we

00:20:33,749 --> 00:20:38,879
can see that the image is currently some

00:20:36,570 --> 00:20:41,100
commits in this git repository I can

00:20:38,879 --> 00:20:42,869
take this commit and look at what it is

00:20:41,100 --> 00:20:46,549
exactly and I know that this is the one

00:20:42,869 --> 00:20:50,070
on which this particular image was built

00:20:46,549 --> 00:20:54,360
so to do something a little interactive

00:20:50,070 --> 00:20:56,220
now I have spun up Nick Suri inside of

00:20:54,360 --> 00:20:59,490
the cluster here's the LifeLock stream

00:20:56,220 --> 00:21:03,179
from from Nick Suri and I'm going to

00:20:59,490 --> 00:21:04,679
first of all run a container inside of

00:21:03,179 --> 00:21:08,970
kubernetes and attach to it

00:21:04,679 --> 00:21:11,190
interactively and and then we will do

00:21:08,970 --> 00:21:12,869
something more interesting so the way

00:21:11,190 --> 00:21:14,759
this works here is syntactically very

00:21:12,869 --> 00:21:16,440
similar to docker so if you saw the

00:21:14,759 --> 00:21:18,299
previous command and understood it it's

00:21:16,440 --> 00:21:19,910
pretty much the same thing we're running

00:21:18,299 --> 00:21:21,740
a container we're attaching

00:21:19,910 --> 00:21:23,419
a TTY we're doing this interactively

00:21:21,740 --> 00:21:24,890
we're giving it some randomly generated

00:21:23,419 --> 00:21:27,049
name because I don't want to conflict

00:21:24,890 --> 00:21:28,580
with not restarting it and we're pulling

00:21:27,049 --> 00:21:30,830
the image from Nick Street at local

00:21:28,580 --> 00:21:34,309
snare shells it's just going to give me

00:21:30,830 --> 00:21:35,570
the standard bash environment now if I

00:21:34,309 --> 00:21:37,970
run this down here

00:21:35,570 --> 00:21:42,590
I will see that a demo container is now

00:21:37,970 --> 00:21:45,830
creating and after a couple of seconds I

00:21:42,590 --> 00:21:47,480
get the shell out of it cool so there's

00:21:45,830 --> 00:21:49,010
nothing nothing in here as before

00:21:47,480 --> 00:21:51,830
there's no extra commands I'm not going

00:21:49,010 --> 00:21:53,390
to demo HT up again instead I'm just

00:21:51,830 --> 00:21:54,919
going to let you know that this Nick's

00:21:53,390 --> 00:21:57,380
tree instance is pointing at the

00:21:54,919 --> 00:22:00,980
repository I was showing you earlier so

00:21:57,380 --> 00:22:03,230
I can actually go and pull the Nick's

00:22:00,980 --> 00:22:07,429
con demo that I was showing up for a

00:22:03,230 --> 00:22:11,450
second into this instance and deploy a

00:22:07,429 --> 00:22:13,940
container with it just kind of go ahead

00:22:11,450 --> 00:22:18,159
and do that for talking too much about

00:22:13,940 --> 00:22:18,159
it and now we should start seeing

00:22:18,400 --> 00:22:22,700
messages from Nick Suri here so we just

00:22:21,230 --> 00:22:23,840
to make sure that this dream is not dead

00:22:22,700 --> 00:22:26,030
yeah here we go

00:22:23,840 --> 00:22:28,880
so they also now have build happening

00:22:26,030 --> 00:22:30,260
and if dolmen is doing its job well and

00:22:28,880 --> 00:22:32,480
Kasich's is up and running

00:22:30,260 --> 00:22:34,580
then this should hit the binary cash if

00:22:32,480 --> 00:22:36,679
it doesn't it's going to be interesting

00:22:34,580 --> 00:22:38,330
because this is a rust thing and the

00:22:36,679 --> 00:22:39,980
rust compiler is not the fastest one and

00:22:38,330 --> 00:22:41,600
I'm probably going to end up in a

00:22:39,980 --> 00:22:45,860
situation like yesterday with the high

00:22:41,600 --> 00:22:51,950
school demo so let's let's give it a

00:22:45,860 --> 00:22:53,900
moment and see what happens actually on

00:22:51,950 --> 00:22:55,940
the topic of caches in this case what I

00:22:53,900 --> 00:22:59,480
found to be a very effective way of

00:22:55,940 --> 00:23:01,429
working with this is having a CI set up

00:22:59,480 --> 00:23:04,130
on your system that populates the binary

00:23:01,429 --> 00:23:06,110
cash something like Kasich's on every

00:23:04,130 --> 00:23:07,909
push so that all the things are already

00:23:06,110 --> 00:23:09,710
pre-built when next three tries to go

00:23:07,909 --> 00:23:12,470
and fetch them from a binary cash um

00:23:09,710 --> 00:23:14,780
Nick sorry can in theory go and and

00:23:12,470 --> 00:23:17,120
start building everything from scratch

00:23:14,780 --> 00:23:18,890
but you probably don't want it to be

00:23:17,120 --> 00:23:20,870
spending a couple of hours building your

00:23:18,890 --> 00:23:22,429
Haskell services so it's nice to have

00:23:20,870 --> 00:23:24,740
that done already when you get to the

00:23:22,429 --> 00:23:26,539
point of deployment what we're

00:23:24,740 --> 00:23:31,370
interested in here is not not

00:23:26,539 --> 00:23:33,320
necessarily having having everything

00:23:31,370 --> 00:23:34,610
pre-cached on an image level because we

00:23:33,320 --> 00:23:36,590
want to be able to dynamically modify

00:23:34,610 --> 00:23:38,690
what goes into an image for example by

00:23:36,590 --> 00:23:40,340
adding debugging tools but it's still

00:23:38,690 --> 00:23:41,990
nice to actually have offloaded the

00:23:40,340 --> 00:23:45,050
caching of stuff like your actual

00:23:41,990 --> 00:23:48,320
service builds to Nixon okay here we go

00:23:45,050 --> 00:23:49,760
the next build is done a bunch of stuff

00:23:48,320 --> 00:23:51,440
happened under the hood and now we have

00:23:49,760 --> 00:23:54,920
a command prompt here that should

00:23:51,440 --> 00:23:59,990
actually give me the next come demo and

00:23:54,920 --> 00:24:06,380
now if I forward let's see if we can get

00:23:59,990 --> 00:24:12,200
this to work if we forward something

00:24:06,380 --> 00:24:22,340
like pard 4242 into this container and i

00:24:12,200 --> 00:24:25,190
should be able to write that demo worked

00:24:22,340 --> 00:24:28,390
I'm surprised the trivial first one well

00:24:25,190 --> 00:24:32,990
that's how it always goes right cool

00:24:28,390 --> 00:24:35,510
so kubernetes is pretty much one of the

00:24:32,990 --> 00:24:38,450
ideal ways of using this in production

00:24:35,510 --> 00:24:39,740
and that's kind of a base of the origin

00:24:38,450 --> 00:24:44,060
of the idea where this whole thing came

00:24:39,740 --> 00:24:46,160
from and the deployment of Nick Suri

00:24:44,060 --> 00:24:48,170
into a cluster is relatively simple like

00:24:46,160 --> 00:24:51,650
I was saying these are going this is

00:24:48,170 --> 00:24:53,300
going to be documented on my page you

00:24:51,650 --> 00:24:54,740
basically just run an extra instance and

00:24:53,300 --> 00:24:55,850
add some environment variables to

00:24:54,740 --> 00:24:58,310
configure it there's nothing really

00:24:55,850 --> 00:25:00,080
special about it the one restriction

00:24:58,310 --> 00:25:02,240
that is in place at the moment simply

00:25:00,080 --> 00:25:04,160
because I don't have time to implement

00:25:02,240 --> 00:25:06,220
support for everything is that this only

00:25:04,160 --> 00:25:09,260
runs on Google cloud platform right now

00:25:06,220 --> 00:25:11,180
there is a mode coming up for just being

00:25:09,260 --> 00:25:13,460
able to use a local file system instead

00:25:11,180 --> 00:25:16,370
of serving image layers from from our

00:25:13,460 --> 00:25:18,410
storage system and once that happens you

00:25:16,370 --> 00:25:20,090
can actually run this anywhere also

00:25:18,410 --> 00:25:22,190
contributions welcome if somebody wants

00:25:20,090 --> 00:25:23,870
to implement that the issue on the issue

00:25:22,190 --> 00:25:25,700
tracker describes how it should work

00:25:23,870 --> 00:25:27,560
yeah and once you have that up and

00:25:25,700 --> 00:25:29,660
running you can create these kinds of

00:25:27,560 --> 00:25:33,110
things too to solidify the deployment

00:25:29,660 --> 00:25:35,030
infrastructure using the service right

00:25:33,110 --> 00:25:37,250
that's kind of the primary things who

00:25:35,030 --> 00:25:38,960
wants to say here are my contact details

00:25:37,250 --> 00:25:42,410
and where to find source code and all

00:25:38,960 --> 00:25:44,450
that kind of thing yes

00:25:42,410 --> 00:25:46,940
and I want to say thanks to Sarah and

00:25:44,450 --> 00:25:49,070
EDF for coming up with with the the

00:25:46,940 --> 00:25:51,860
broccoli alias which we kind of picked

00:25:49,070 --> 00:26:09,920
up late yesterday evening right

00:25:51,860 --> 00:26:11,900
questions so two questions first in the

00:26:09,920 --> 00:26:16,210
URL you specify the path and you specify

00:26:11,900 --> 00:26:19,220
packages or deviations use using slash

00:26:16,210 --> 00:26:22,880
did you try to or did you consider using

00:26:19,220 --> 00:26:25,220
annex expressions yes I'm the primary

00:26:22,880 --> 00:26:26,930
issue is that there are restrictions in

00:26:25,220 --> 00:26:29,060
the docker registry protocol and which

00:26:26,930 --> 00:26:31,370
characters are allowed and it's quite

00:26:29,060 --> 00:26:32,900
restrictive so for example an

00:26:31,370 --> 00:26:34,700
interesting fact there's an issue on the

00:26:32,900 --> 00:26:37,460
issue tracker about this you cannot have

00:26:34,700 --> 00:26:39,280
uppercase characters in there and next

00:26:37,460 --> 00:26:41,870
packages has things like Haskell

00:26:39,280 --> 00:26:43,550
packages which is an uppercase thing but

00:26:41,870 --> 00:26:45,170
you might want to refer to packages

00:26:43,550 --> 00:26:48,200
inside of that that are actually binary

00:26:45,170 --> 00:26:50,060
so what I did is I tried to do a first

00:26:48,200 --> 00:26:51,590
look up with the exact name that the

00:26:50,060 --> 00:26:53,270
user specified and if that doesn't work

00:26:51,590 --> 00:26:54,770
and normalize the casing of all

00:26:53,270 --> 00:26:56,150
attributes and then do a lookup with

00:26:54,770 --> 00:26:58,160
that and some of you are probably

00:26:56,150 --> 00:27:00,650
guessing this right now yes there are

00:26:58,160 --> 00:27:02,870
name clashes based on casing inside of

00:27:00,650 --> 00:27:05,060
next packages fortunately at the top

00:27:02,870 --> 00:27:06,620
level this this only affects things that

00:27:05,060 --> 00:27:08,330
are actually aliases for each other but

00:27:06,620 --> 00:27:09,740
inside of Haskell packages there are

00:27:08,330 --> 00:27:12,110
actually different pieces of software

00:27:09,740 --> 00:27:15,800
with names that are only different in

00:27:12,110 --> 00:27:17,240
the casing so wait for those I just

00:27:15,800 --> 00:27:18,650
don't have a solution at the moment if

00:27:17,240 --> 00:27:20,060
you need one of those I don't know make

00:27:18,650 --> 00:27:24,530
a private wrapper on alias it is

00:27:20,060 --> 00:27:26,480
something same with the original

00:27:24,530 --> 00:27:27,980
kubernetes controller idea I also

00:27:26,480 --> 00:27:29,990
considered adding a field just to

00:27:27,980 --> 00:27:32,300
straight at annex expression in there

00:27:29,990 --> 00:27:33,380
but since that ideas kind of been

00:27:32,300 --> 00:27:34,970
dropped I thought that it's probably

00:27:33,380 --> 00:27:36,770
more reasonable to actually keep those

00:27:34,970 --> 00:27:39,980
in the next repository rather than

00:27:36,770 --> 00:27:42,110
inside of the deployment manifest okay

00:27:39,980 --> 00:27:44,780
thank you good and the second question

00:27:42,110 --> 00:27:48,350
will be how you set up private private

00:27:44,780 --> 00:27:51,650
keys repository with like mostly with

00:27:48,350 --> 00:27:53,510
the keys so I'm using the built-ins

00:27:51,650 --> 00:27:55,730
fetch gate functionality to fetch the

00:27:53,510 --> 00:27:57,500
repo and built-ins fetch code uses the

00:27:55,730 --> 00:27:59,900
SSH configuration of your environment

00:27:57,500 --> 00:28:01,610
it's impure which means that as long as

00:27:59,900 --> 00:28:03,440
the environment in which Nick Suri is

00:28:01,610 --> 00:28:05,240
running is configured with appropriate

00:28:03,440 --> 00:28:11,980
SSH credentials and everything will just

00:28:05,240 --> 00:28:11,980
kind of work yes all right anything else

00:28:14,080 --> 00:28:20,630
perhaps I have missed that bit but I

00:28:17,360 --> 00:28:25,280
wonder and the docker file has a lot

00:28:20,630 --> 00:28:29,510
more to express like mount points X X

00:28:25,280 --> 00:28:32,030
whatever is that handled with Nick sorry

00:28:29,510 --> 00:28:35,270
or do you have to build some kind

00:28:32,030 --> 00:28:36,920
command line yet so at the moment most

00:28:35,270 --> 00:28:38,720
of those things because they kind of

00:28:36,920 --> 00:28:40,760
only metadata outsourced to kubernetes

00:28:38,720 --> 00:28:42,830
so you specify stuff like the entry

00:28:40,760 --> 00:28:47,150
point inside of the of the deployment

00:28:42,830 --> 00:28:48,980
manifest there is an effort in progress

00:28:47,150 --> 00:28:51,260
in Nick's packages right now to add

00:28:48,980 --> 00:28:53,030
metadata to every derivation it contains

00:28:51,260 --> 00:28:55,520
binaries that tells us what is the

00:28:53,030 --> 00:28:56,690
primary binary in this package and once

00:28:55,520 --> 00:28:59,360
that is in place we can actually

00:28:56,690 --> 00:29:01,010
automatically generate entry points but

00:28:59,360 --> 00:29:04,610
then there's also a discussion of if

00:29:01,010 --> 00:29:07,160
somebody writes shell slash nginx /n

00:29:04,610 --> 00:29:09,020
gerak which one do they actually want to

00:29:07,160 --> 00:29:11,090
run right so at some point you still

00:29:09,020 --> 00:29:12,770
have to defer to the user as for

00:29:11,090 --> 00:29:16,850
environment variables and that kind of

00:29:12,770 --> 00:29:18,620
thing in theory the next builder that we

00:29:16,850 --> 00:29:21,140
have to do this kind of stuff supports

00:29:18,620 --> 00:29:22,640
them but there is currently no surface

00:29:21,140 --> 00:29:24,500
in the API where you can actually attach

00:29:22,640 --> 00:29:26,420
that it we might come up with something

00:29:24,500 --> 00:29:28,040
later there's a few issues about a

00:29:26,420 --> 00:29:30,760
related things on the tracker feel free

00:29:28,040 --> 00:29:30,760
to give some input

00:29:37,200 --> 00:29:42,010
are there examples of other meta

00:29:39,490 --> 00:29:44,350
packages besides shell and what can you

00:29:42,010 --> 00:29:46,360
do with those many packages yeah so

00:29:44,350 --> 00:29:48,250
shell is the only one that the public

00:29:46,360 --> 00:29:50,529
instance supports at the moment the next

00:29:48,250 --> 00:29:55,210
one that I'm currently working on is arm

00:29:50,529 --> 00:29:56,890
64 to serve your arm 64 binaries the the

00:29:55,210 --> 00:30:00,580
thing with that is that the the docker

00:29:56,890 --> 00:30:02,620
registry protocol has sort of support

00:30:00,580 --> 00:30:04,059
for switching architectures but it does

00:30:02,620 --> 00:30:06,370
it in the form of serving you one

00:30:04,059 --> 00:30:08,440
manifest that contains hashes for all

00:30:06,370 --> 00:30:09,970
architectures so if you were to use that

00:30:08,440 --> 00:30:12,159
functionality you would have to build

00:30:09,970 --> 00:30:14,470
all things for all architectures on

00:30:12,159 --> 00:30:16,720
every request which is probably not what

00:30:14,470 --> 00:30:18,760
the user wants so I'm thinking that meta

00:30:16,720 --> 00:30:20,919
packages is the first element are kind

00:30:18,760 --> 00:30:23,309
of a more sane way of toggling that

00:30:20,919 --> 00:30:23,309
behavior

00:30:29,940 --> 00:30:36,589
all right thank you very much

00:30:32,670 --> 00:30:36,589

YouTube URL: https://www.youtube.com/watch?v=pOI9H4oeXqA


