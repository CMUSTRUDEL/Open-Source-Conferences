Title: Jack Cummings: Assembling SOCs with Nix (NixCon 2015)
Publication date: 2020-10-29
Playlist: NixCon 2015 (Berlin)
Description: 
	
Captions: 
	00:00:05,200 --> 00:00:10,400
today we will start with

00:00:07,279 --> 00:00:13,519
jack cummings um

00:00:10,400 --> 00:00:16,960
he's a he's been a linux

00:00:13,519 --> 00:00:20,640
user for about 20 years yeah

00:00:16,960 --> 00:00:24,320
using nixo as for the last two three

00:00:20,640 --> 00:00:27,599
he works at intel on solid state drives

00:00:24,320 --> 00:00:28,800
socs team so i think this is going to be

00:00:27,599 --> 00:00:31,840
a very interesting

00:00:28,800 --> 00:00:31,840
presentation so

00:00:32,960 --> 00:00:37,469
different at least

00:00:34,320 --> 00:00:37,469
[Applause]

00:00:41,440 --> 00:00:47,280
all right like rock said my name is jack

00:00:45,360 --> 00:00:49,280
i work in vancouver british columbia

00:00:47,280 --> 00:00:51,760
canada um

00:00:49,280 --> 00:00:52,960
that's the view from our lab actually um

00:00:51,760 --> 00:00:55,440
so

00:00:52,960 --> 00:00:56,840
um that's not the view from my cubicle i

00:00:55,440 --> 00:00:59,600
wish but

00:00:56,840 --> 00:01:01,920
um so

00:00:59,600 --> 00:01:03,039
what we do in our office we do a lot of

00:01:01,920 --> 00:01:04,400
things but i'm part of the team that

00:01:03,039 --> 00:01:07,840
designs the

00:01:04,400 --> 00:01:09,920
ssd controller a6 and if you don't know

00:01:07,840 --> 00:01:11,280
what socs are it stands for system on a

00:01:09,920 --> 00:01:12,960
chip

00:01:11,280 --> 00:01:14,320
part of mer's law as we're going forward

00:01:12,960 --> 00:01:15,759
is we integrate more and more into a

00:01:14,320 --> 00:01:17,520
chip and previously where it would take

00:01:15,759 --> 00:01:20,159
whatever 10 ships to run a computer now

00:01:17,520 --> 00:01:20,159
it takes one

00:01:20,240 --> 00:01:26,640
so the controller asic for these

00:01:23,439 --> 00:01:28,720
things is getting bigger and bigger and

00:01:26,640 --> 00:01:32,400
having more and more stuff put on it

00:01:28,720 --> 00:01:34,079
but i spent a lot of my time at work um

00:01:32,400 --> 00:01:35,520
figuring out how to be more productive

00:01:34,079 --> 00:01:37,439
how to make people work with be more

00:01:35,520 --> 00:01:39,680
productive how to make the computers

00:01:37,439 --> 00:01:41,520
that we have be more productive and just

00:01:39,680 --> 00:01:44,880
be able to

00:01:41,520 --> 00:01:48,640
do more so this

00:01:44,880 --> 00:01:50,079
is an soc i worked on it i had the

00:01:48,640 --> 00:01:52,159
project name sage peak someone was

00:01:50,079 --> 00:01:54,560
mentioning earlier that they use

00:01:52,159 --> 00:01:56,240
birds for project names um that's what

00:01:54,560 --> 00:02:01,360
uh arm does actually

00:01:56,240 --> 00:02:03,040
but um we use places they're kind of uh

00:02:01,360 --> 00:02:04,799
there's no meaning associated with them

00:02:03,040 --> 00:02:05,840
so it kind of provides a convenient

00:02:04,799 --> 00:02:07,280
thing to talk about that no one can

00:02:05,840 --> 00:02:10,800
figure out what we're talking

00:02:07,280 --> 00:02:14,640
but this is um this asic went into a

00:02:10,800 --> 00:02:19,280
product called fultondale which um is

00:02:14,640 --> 00:02:19,280
an nvm express ssd um

00:02:19,760 --> 00:02:23,200
nvm express is in itself kind of a

00:02:21,360 --> 00:02:24,640
fascinating technology that we worked

00:02:23,200 --> 00:02:26,000
with actually the linux kernel

00:02:24,640 --> 00:02:30,480
developers

00:02:26,000 --> 00:02:31,599
and developing a lower latency i o stack

00:02:30,480 --> 00:02:33,280
so there's actually a whole bunch of

00:02:31,599 --> 00:02:33,599
these things on on the market right now

00:02:33,280 --> 00:02:36,160
so

00:02:33,599 --> 00:02:36,720
samsung has a few we have a few there's

00:02:36,160 --> 00:02:40,480
some more

00:02:36,720 --> 00:02:42,160
more people generating them um

00:02:40,480 --> 00:02:43,519
if you want to talk more about why this

00:02:42,160 --> 00:02:45,599
is really nifty

00:02:43,519 --> 00:02:46,640
over sata or sas or other kinds of

00:02:45,599 --> 00:02:50,239
technologies that

00:02:46,640 --> 00:02:52,239
uh the right person to talk to um so

00:02:50,239 --> 00:02:54,560
back to what a system-on-chip is

00:02:52,239 --> 00:02:55,840
um there are integrated circuits as you

00:02:54,560 --> 00:02:57,599
can see there everything is in that one

00:02:55,840 --> 00:02:59,040
little package there on actually in this

00:02:57,599 --> 00:03:03,120
case a single die

00:02:59,040 --> 00:03:05,599
um it integrates all the components of a

00:03:03,120 --> 00:03:06,400
assist of a regular computer onto a

00:03:05,599 --> 00:03:08,720
single chip

00:03:06,400 --> 00:03:10,080
so this includes all of the ios which

00:03:08,720 --> 00:03:11,599
are input output

00:03:10,080 --> 00:03:13,280
basically electrical things that turn

00:03:11,599 --> 00:03:16,080
digital signals into these

00:03:13,280 --> 00:03:16,080
analog signals

00:03:17,200 --> 00:03:20,640
socs everywhere um they're in phones

00:03:20,159 --> 00:03:23,280
they're

00:03:20,640 --> 00:03:24,560
you know in like the internet of things

00:03:23,280 --> 00:03:27,760
all based on socs

00:03:24,560 --> 00:03:30,560
computers now um so uh

00:03:27,760 --> 00:03:30,959
it's it's kind of a big business right

00:03:30,560 --> 00:03:34,239
there's

00:03:30,959 --> 00:03:34,239
billions of these things made every year

00:03:35,360 --> 00:03:40,080
all right what are socs assembled from

00:03:38,000 --> 00:03:43,440
well it turns out lots of things

00:03:40,080 --> 00:03:46,799
the part that we do most of is

00:03:43,440 --> 00:03:50,080
digital logic and digital logic is still

00:03:46,799 --> 00:03:51,760
analog electrics it's just that we

00:03:50,080 --> 00:03:53,360
do some statistical proofs and

00:03:51,760 --> 00:03:54,799
characterizations and analysis to make

00:03:53,360 --> 00:03:57,040
sure that things behave

00:03:54,799 --> 00:03:58,959
digitally that you know it's either on

00:03:57,040 --> 00:04:01,680
or off

00:03:58,959 --> 00:04:02,720
we also don't actually do on the i guess

00:04:01,680 --> 00:04:06,400
that'd be your right

00:04:02,720 --> 00:04:06,400
is uh a um

00:04:06,560 --> 00:04:10,799
the what we call a registered transfer

00:04:08,080 --> 00:04:12,159
level uh code for

00:04:10,799 --> 00:04:14,159
what is the diagram there which is

00:04:12,159 --> 00:04:16,079
actually an inverter

00:04:14,159 --> 00:04:18,160
so you can't really see it from the

00:04:16,079 --> 00:04:19,840
slide here but there's a pin called in

00:04:18,160 --> 00:04:22,320
on the left and a pin called out on the

00:04:19,840 --> 00:04:24,080
right and that is actually what looks

00:04:22,320 --> 00:04:27,199
like in silicon

00:04:24,080 --> 00:04:30,000
that's crib from a magic

00:04:27,199 --> 00:04:31,280
schematic and so the the code there is

00:04:30,000 --> 00:04:33,280
actually what infers there

00:04:31,280 --> 00:04:35,680
um and you can tell there's a fair bit

00:04:33,280 --> 00:04:37,440
of boilerplate logic here that the logic

00:04:35,680 --> 00:04:39,120
and the input and output are actually

00:04:37,440 --> 00:04:41,440
the wires and the

00:04:39,120 --> 00:04:43,040
always com says that whenever the input

00:04:41,440 --> 00:04:45,680
changes the output should change too and

00:04:43,040 --> 00:04:47,759
it should be the opposite of the input

00:04:45,680 --> 00:04:48,960
that's kind of the definition of a

00:04:47,759 --> 00:04:53,520
trivial example

00:04:48,960 --> 00:04:55,360
but um there this is a single gate and

00:04:53,520 --> 00:04:57,120
some of the designs we work on go into

00:04:55,360 --> 00:05:00,000
the order of 50 million gates

00:04:57,120 --> 00:05:00,800
so what happens is when you stitch all

00:05:00,000 --> 00:05:01,919
this stuff together

00:05:00,800 --> 00:05:03,039
and you stitch these things together

00:05:01,919 --> 00:05:05,039
into something called a netlist it's

00:05:03,039 --> 00:05:08,560
actually just a humongous graph

00:05:05,039 --> 00:05:10,639
where your your nodes are

00:05:08,560 --> 00:05:13,520
logic gates and your elements or primary

00:05:10,639 --> 00:05:17,520
edges are actually wires

00:05:13,520 --> 00:05:20,800
so we use verilog and system verilog

00:05:17,520 --> 00:05:24,000
they're both terrible

00:05:20,800 --> 00:05:24,960
organically grown languages kind of

00:05:24,000 --> 00:05:26,960
remind me a bit of c

00:05:24,960 --> 00:05:28,160
plus you know it's not a nice pure

00:05:26,960 --> 00:05:29,600
design language it's something that's

00:05:28,160 --> 00:05:32,240
kind of evolved over time and grown all

00:05:29,600 --> 00:05:32,240
kind of warts

00:05:32,800 --> 00:05:36,479
so we also don't do the actual place and

00:05:35,919 --> 00:05:39,600
route

00:05:36,479 --> 00:05:42,400
as uh at our office so we

00:05:39,600 --> 00:05:44,080
do um generate a net list that contains

00:05:42,400 --> 00:05:45,280
all the standard cells which are the and

00:05:44,080 --> 00:05:47,280
gates and or gates and

00:05:45,280 --> 00:05:48,560
flip-flops and everything else and hand

00:05:47,280 --> 00:05:50,479
that off to another team and i'll get a

00:05:48,560 --> 00:05:54,720
bit into why that's important later

00:05:50,479 --> 00:05:59,360
but um that in it itself is a huge job

00:05:54,720 --> 00:06:01,520
all right just a bit of talking about uh

00:05:59,360 --> 00:06:02,800
who um the problem that i solved and the

00:06:01,520 --> 00:06:06,000
solution i came up with

00:06:02,800 --> 00:06:09,199
using nyx and some of what

00:06:06,000 --> 00:06:09,199
made it better than we had before

00:06:09,680 --> 00:06:15,039
so our one of the problems in hardware

00:06:12,800 --> 00:06:18,639
design is the cost of

00:06:15,039 --> 00:06:20,080
screwing up is really high so we tend to

00:06:18,639 --> 00:06:22,000
spend a lot of time making sure we got

00:06:20,080 --> 00:06:24,960
it right the first time

00:06:22,000 --> 00:06:26,880
because the cost of once we ship

00:06:24,960 --> 00:06:29,039
something off to the fab or the foundry

00:06:26,880 --> 00:06:30,880
or

00:06:29,039 --> 00:06:31,919
to actually be manufactured into a real

00:06:30,880 --> 00:06:33,199
thing and that's kind of what's neat

00:06:31,919 --> 00:06:34,080
about this is you write code that turns

00:06:33,199 --> 00:06:36,880
into something you can

00:06:34,080 --> 00:06:37,680
see well with the big enough microscope

00:06:36,880 --> 00:06:41,840
but but

00:06:37,680 --> 00:06:43,600
um once you do that it's uh that takes

00:06:41,840 --> 00:06:44,960
months for them to get through all the

00:06:43,600 --> 00:06:47,919
wafer processing stuff

00:06:44,960 --> 00:06:48,960
and yeah it's very expensive so if you

00:06:47,919 --> 00:06:51,520
have a bug

00:06:48,960 --> 00:06:52,960
like you know back here if i forgot that

00:06:51,520 --> 00:06:54,639
little tilde in front of end

00:06:52,960 --> 00:06:56,160
right that's no longer an inverter

00:06:54,639 --> 00:06:56,960
that's an and gate or apparently it's a

00:06:56,160 --> 00:06:59,280
buffer

00:06:56,960 --> 00:07:01,840
um so that wouldn't work then you know

00:06:59,280 --> 00:07:03,440
that could be a seriously critical bug

00:07:01,840 --> 00:07:05,199
so anyways the

00:07:03,440 --> 00:07:06,880
we're fairly rigorous about our design

00:07:05,199 --> 00:07:09,919
flow

00:07:06,880 --> 00:07:11,039
so we start from requirements and look

00:07:09,919 --> 00:07:12,960
at these requirements figure out how

00:07:11,039 --> 00:07:14,080
we're going to

00:07:12,960 --> 00:07:16,080
meet those requirements and that's

00:07:14,080 --> 00:07:17,919
called architecture we write a

00:07:16,080 --> 00:07:18,960
specification meet requirements

00:07:17,919 --> 00:07:20,720
and then we do something that's

00:07:18,960 --> 00:07:22,479
incredibly valuable and this is actually

00:07:20,720 --> 00:07:24,639
the reason why things work is we hand

00:07:22,479 --> 00:07:26,240
the same specification off to two people

00:07:24,639 --> 00:07:27,280
we hand it off to a designer who

00:07:26,240 --> 00:07:28,639
actually writes the code

00:07:27,280 --> 00:07:30,479
and we hand it off to a verification

00:07:28,639 --> 00:07:33,039
engineer who will then

00:07:30,479 --> 00:07:34,800
write a verification in environment for

00:07:33,039 --> 00:07:36,319
it a model as it were

00:07:34,800 --> 00:07:37,919
and then when they get to various

00:07:36,319 --> 00:07:38,880
checkpoints along the way or whenever

00:07:37,919 --> 00:07:40,160
they feel comfortable they start

00:07:38,880 --> 00:07:42,080
comparing the two

00:07:40,160 --> 00:07:43,520
and make sure that they both agreed on

00:07:42,080 --> 00:07:45,520
what the specification was

00:07:43,520 --> 00:07:46,560
and that the design meets the

00:07:45,520 --> 00:07:49,120
specification

00:07:46,560 --> 00:07:50,639
it turns out that that is a huge part of

00:07:49,120 --> 00:07:51,599
what we do it's incredibly labor

00:07:50,639 --> 00:07:54,639
intensive

00:07:51,599 --> 00:07:56,319
and it's you know it's very difficult to

00:07:54,639 --> 00:07:58,879
converge on i'm sure that

00:07:56,319 --> 00:08:00,400
everyone knows testing is hard and it's

00:07:58,879 --> 00:08:02,560
really hard to test everything but we

00:08:00,400 --> 00:08:04,080
kind of have to

00:08:02,560 --> 00:08:05,599
we have a special methodology we've

00:08:04,080 --> 00:08:07,280
developed that um

00:08:05,599 --> 00:08:09,440
at least knows what lets us know what

00:08:07,280 --> 00:08:11,360
we've done and when we're done

00:08:09,440 --> 00:08:13,440
so once we've done the verification we

00:08:11,360 --> 00:08:14,000
have the rtl and the rtl is actually the

00:08:13,440 --> 00:08:16,639
code

00:08:14,000 --> 00:08:18,160
that we can synthesize into place gates

00:08:16,639 --> 00:08:21,360
and hand off to be

00:08:18,160 --> 00:08:22,000
implemented and so the actual synthesis

00:08:21,360 --> 00:08:24,479
is a bit like

00:08:22,000 --> 00:08:26,000
compiling code except that you add

00:08:24,479 --> 00:08:28,000
additional constraints about

00:08:26,000 --> 00:08:29,120
you know it must run at this frequency

00:08:28,000 --> 00:08:31,440
it must be in

00:08:29,120 --> 00:08:32,240
fit inside this area and it must use

00:08:31,440 --> 00:08:36,320
these certain

00:08:32,240 --> 00:08:37,519
standard cells and then we make sure

00:08:36,320 --> 00:08:39,919
because we don't trust our tools because

00:08:37,519 --> 00:08:42,479
they're actually quite crap

00:08:39,919 --> 00:08:43,599
they we have another tool that we run to

00:08:42,479 --> 00:08:46,320
make sure that

00:08:43,599 --> 00:08:47,279
what the first tool did was right and

00:08:46,320 --> 00:08:48,560
then

00:08:47,279 --> 00:08:50,959
we generate this netlist which we hand

00:08:48,560 --> 00:08:52,560
off to layout team and they do their

00:08:50,959 --> 00:08:54,959
layout and then hand us back

00:08:52,560 --> 00:08:56,240
place gates and then we run that tool

00:08:54,959 --> 00:08:57,680
again on it to make sure they didn't

00:08:56,240 --> 00:09:00,320
wreck the thing when they're

00:08:57,680 --> 00:09:00,320
doing layout

00:09:00,720 --> 00:09:05,360
so we get this

00:09:03,839 --> 00:09:07,360
working for intel has certain advantages

00:09:05,360 --> 00:09:10,240
we get some

00:09:07,360 --> 00:09:11,680
what they call super skus of a processor

00:09:10,240 --> 00:09:12,720
so they'll take a high-end xeon

00:09:11,680 --> 00:09:15,680
processor

00:09:12,720 --> 00:09:16,560
cut out um half of the cores that are

00:09:15,680 --> 00:09:18,880
too slow

00:09:16,560 --> 00:09:20,000
disable hyper threading and crank the

00:09:18,880 --> 00:09:20,560
clock frequency on the others because

00:09:20,000 --> 00:09:22,640
they're all

00:09:20,560 --> 00:09:23,839
especially spring skilled silicon so

00:09:22,640 --> 00:09:27,120
these are uh

00:09:23,839 --> 00:09:30,399
ivy bridge ep

00:09:27,120 --> 00:09:32,240
um compute servers that are running at

00:09:30,399 --> 00:09:33,519
four and four and a half gigahertz

00:09:32,240 --> 00:09:34,480
they're really good at single threaded

00:09:33,519 --> 00:09:36,160
performance stuff they're

00:09:34,480 --> 00:09:39,120
they probably have less throughput than

00:09:36,160 --> 00:09:41,040
uh the newer broadwell ep stuff but

00:09:39,120 --> 00:09:42,320
you know when none of our cad tools

00:09:41,040 --> 00:09:43,440
vendors understand how to do threading

00:09:42,320 --> 00:09:45,760
properly so

00:09:43,440 --> 00:09:46,640
it's still a single third performance

00:09:45,760 --> 00:09:48,959
and

00:09:46,640 --> 00:09:50,480
interesting enough because our cad tool

00:09:48,959 --> 00:09:51,519
vendors don't like changing operating

00:09:50,480 --> 00:09:54,080
systems so much

00:09:51,519 --> 00:09:55,519
that um yeah we have to run with these

00:09:54,080 --> 00:09:58,800
archaic kernels

00:09:55,519 --> 00:10:00,240
like i think yeah that's i'm not kidding

00:09:58,800 --> 00:10:01,360
that that thing is what six years old

00:10:00,240 --> 00:10:04,480
now

00:10:01,360 --> 00:10:06,640
uh yeah and you know i

00:10:04,480 --> 00:10:08,240
have no idea like it's been patched i

00:10:06,640 --> 00:10:10,320
don't know it's either seven thousand

00:10:08,240 --> 00:10:13,760
times or seven or a thousand times

00:10:10,320 --> 00:10:13,760
uh yeah i don't know it's

00:10:14,720 --> 00:10:18,480
so this actually causes unique problems

00:10:16,399 --> 00:10:21,200
and with nyx sauce stuff because

00:10:18,480 --> 00:10:22,320
glibc 2.19 is the last glib see that

00:10:21,200 --> 00:10:23,680
supports kernels that old

00:10:22,320 --> 00:10:25,519
so i had to have to have a special

00:10:23,680 --> 00:10:29,680
version of nyx packages that

00:10:25,519 --> 00:10:31,440
used an older gwc so

00:10:29,680 --> 00:10:32,959
this is the way we used to do things we

00:10:31,440 --> 00:10:36,480
typically use make

00:10:32,959 --> 00:10:38,079
in isolation for various tasks and since

00:10:36,480 --> 00:10:39,519
some of our tasks have multiple other

00:10:38,079 --> 00:10:40,800
files we use touch files

00:10:39,519 --> 00:10:42,640
we have a bunch of shell scripts written

00:10:40,800 --> 00:10:44,880
by engineers and engineers aren't really

00:10:42,640 --> 00:10:46,880
good at writing code

00:10:44,880 --> 00:10:49,120
the and then we have these pearl scripts

00:10:46,880 --> 00:10:52,160
at party pars the output of make

00:10:49,120 --> 00:10:55,120
debug which is fragile

00:10:52,160 --> 00:10:55,760
and kind of horrific um and there's more

00:10:55,120 --> 00:10:58,720
confusion

00:10:55,760 --> 00:11:00,000
and so to get around all this we have

00:10:58,720 --> 00:11:01,440
checklists that we follow to make sure

00:11:00,000 --> 00:11:03,120
that everything was done right

00:11:01,440 --> 00:11:04,399
um which usually means you have to go

00:11:03,120 --> 00:11:05,760
back and try and figure out why your

00:11:04,399 --> 00:11:09,200
make scripts failed

00:11:05,760 --> 00:11:12,880
um and more confusion and yeah

00:11:09,200 --> 00:11:13,920
so it's usually of course by the time

00:11:12,880 --> 00:11:16,079
everything's coming together right

00:11:13,920 --> 00:11:17,519
before you meet your deadlines is

00:11:16,079 --> 00:11:19,200
when there's the most stress and then

00:11:17,519 --> 00:11:20,640
finding that oh dear we forgot to

00:11:19,200 --> 00:11:22,880
compile that in or you know somehow we

00:11:20,640 --> 00:11:26,720
got the wrong version of something else

00:11:22,880 --> 00:11:29,839
can lead to tragedy all right this is

00:11:26,720 --> 00:11:31,120
an example this is a bit um i'll come

00:11:29,839 --> 00:11:33,680
back to this what this is doing

00:11:31,120 --> 00:11:34,800
um and there is a bug in here actually i

00:11:33,680 --> 00:11:36,000
just discovered i was going through this

00:11:34,800 --> 00:11:38,880
the slides this morning

00:11:36,000 --> 00:11:40,000
um and if someone pointed out and when i

00:11:38,880 --> 00:11:43,200
come back to the slide

00:11:40,000 --> 00:11:47,279
i'll be very interested but um this

00:11:43,200 --> 00:11:49,200
is verification um and it has all kinds

00:11:47,279 --> 00:11:50,320
of nice things in it that nyx does

00:11:49,200 --> 00:11:53,279
there's a

00:11:50,320 --> 00:11:54,720
map reduced um so you can see here on

00:11:53,279 --> 00:11:56,800
line 22 the regression is actually

00:11:54,720 --> 00:11:59,519
mapping

00:11:56,800 --> 00:12:00,000
the attribute up top there against

00:11:59,519 --> 00:12:03,200
building

00:12:00,000 --> 00:12:04,079
a function to build simulations and then

00:12:03,200 --> 00:12:05,680
reducing

00:12:04,079 --> 00:12:08,399
all of the outputs of the simulations

00:12:05,680 --> 00:12:09,680
into a coverage database

00:12:08,399 --> 00:12:11,519
and this is something that it's neat to

00:12:09,680 --> 00:12:15,040
see that it's just well

00:12:11,519 --> 00:12:16,800
okay maybe it's not just there but uh

00:12:15,040 --> 00:12:18,399
it's these kind of things are built into

00:12:16,800 --> 00:12:19,519
next and it's really easy to just be

00:12:18,399 --> 00:12:20,959
able to use them

00:12:19,519 --> 00:12:23,200
doing a map reduce and make is a lot

00:12:20,959 --> 00:12:25,839
more work um that's kind of hard to tell

00:12:23,200 --> 00:12:25,839
what you're doing

00:12:26,320 --> 00:12:29,600
so i'm going to talk a bit more about

00:12:28,340 --> 00:12:31,440
[Applause]

00:12:29,600 --> 00:12:33,040
the design partitioning and the design

00:12:31,440 --> 00:12:33,839
process we do because it is kind of

00:12:33,040 --> 00:12:36,880
important and

00:12:33,839 --> 00:12:37,519
the reason we talk about it is you when

00:12:36,880 --> 00:12:39,040
you

00:12:37,519 --> 00:12:40,720
start looking at the design flow you can

00:12:39,040 --> 00:12:42,320
kind of kind of also almost start

00:12:40,720 --> 00:12:44,320
picking derivations out

00:12:42,320 --> 00:12:46,639
of the design flow it's like well you

00:12:44,320 --> 00:12:48,480
know the doing an elaboration is just

00:12:46,639 --> 00:12:52,240
the derivation

00:12:48,480 --> 00:12:54,320
anyways uh there's in the process of

00:12:52,240 --> 00:12:55,519
um the design folder is kind of a dual

00:12:54,320 --> 00:12:58,560
of partitioning and

00:12:55,519 --> 00:13:01,680
and the actual tasks so the point of

00:12:58,560 --> 00:13:03,600
partitioning is we want to give

00:13:01,680 --> 00:13:05,440
individual engineers a block that they

00:13:03,600 --> 00:13:06,959
completely understand

00:13:05,440 --> 00:13:08,240
so that they can take ownership of it

00:13:06,959 --> 00:13:09,600
and this is kind of an important thing

00:13:08,240 --> 00:13:11,600
for engineering is

00:13:09,600 --> 00:13:12,880
engineers work better when they take

00:13:11,600 --> 00:13:15,920
ownership of things

00:13:12,880 --> 00:13:18,399
when you have four owners for something

00:13:15,920 --> 00:13:20,240
it's people don't have the same quality

00:13:18,399 --> 00:13:20,639
of code they put into you then if you

00:13:20,240 --> 00:13:22,639
know

00:13:20,639 --> 00:13:24,160
they own this block it is theirs if

00:13:22,639 --> 00:13:27,120
there's a bug in it then it's

00:13:24,160 --> 00:13:27,760
their responsibility to fix it but the

00:13:27,120 --> 00:13:29,120
problem is

00:13:27,760 --> 00:13:30,880
our designs are too big to give

00:13:29,120 --> 00:13:32,560
ownership of everything to one person so

00:13:30,880 --> 00:13:34,320
we have a hierarchical process

00:13:32,560 --> 00:13:37,920
where we recursively partition things

00:13:34,320 --> 00:13:37,920
down to get to

00:13:38,800 --> 00:13:42,560
blocks that individual engineers can

00:13:41,040 --> 00:13:46,160
deal with

00:13:42,560 --> 00:13:47,839
it's important because it binds

00:13:46,160 --> 00:13:50,000
bounds the complexity of design and

00:13:47,839 --> 00:13:53,199
balance of complexity of verification

00:13:50,000 --> 00:13:56,399
so they're a hand-waving mathematical

00:13:53,199 --> 00:13:58,079
proof is like the this the possible

00:13:56,399 --> 00:14:00,160
state inside of these blocks is two to

00:13:58,079 --> 00:14:02,000
the power of the state vector inside

00:14:00,160 --> 00:14:03,440
so if you uh but when you're doing

00:14:02,000 --> 00:14:05,120
verification you can we do

00:14:03,440 --> 00:14:06,720
black box verification so you can only

00:14:05,120 --> 00:14:08,560
actually really stimulate the outside

00:14:06,720 --> 00:14:10,160
of the block right so it's kind of a

00:14:08,560 --> 00:14:11,839
perimeter versus area thing so

00:14:10,160 --> 00:14:13,440
the bigger the area of your block is the

00:14:11,839 --> 00:14:13,920
harder it is to reach all the state

00:14:13,440 --> 00:14:15,920
inside

00:14:13,920 --> 00:14:17,279
so if you have too much if your block is

00:14:15,920 --> 00:14:18,880
too big it starts becoming very

00:14:17,279 --> 00:14:21,360
difficult to actually exercise all the

00:14:18,880 --> 00:14:25,519
state inside

00:14:21,360 --> 00:14:28,240
so um back to the design tasks um

00:14:25,519 --> 00:14:29,360
so we this is that we we apply

00:14:28,240 --> 00:14:31,600
recursively

00:14:29,360 --> 00:14:32,399
to the blocks so the interesting thing

00:14:31,600 --> 00:14:35,360
here is

00:14:32,399 --> 00:14:37,120
requirements uh pardon me a

00:14:35,360 --> 00:14:38,320
specification for a higher level block

00:14:37,120 --> 00:14:38,800
becomes requirements for a low level

00:14:38,320 --> 00:14:41,839
block

00:14:38,800 --> 00:14:43,600
so you can do this recursively forever

00:14:41,839 --> 00:14:45,199
until you get down to the size i guess

00:14:43,600 --> 00:14:48,079
is your fixed point is

00:14:45,199 --> 00:14:50,399
you uh reach something a person can a

00:14:48,079 --> 00:14:52,320
single person can deal with

00:14:50,399 --> 00:14:54,560
and then when you roll those back up you

00:14:52,320 --> 00:14:56,800
have different levels of hierarchy

00:14:54,560 --> 00:14:58,399
subsystems and then a ship level so this

00:14:56,800 --> 00:14:59,680
was the chip level lead for the last

00:14:58,399 --> 00:15:00,480
chip i was working on this so i don't

00:14:59,680 --> 00:15:01,920
understand how

00:15:00,480 --> 00:15:03,519
the individual details of the blocks

00:15:01,920 --> 00:15:04,480
work but i know they meet their

00:15:03,519 --> 00:15:05,519
specifications i know where their

00:15:04,480 --> 00:15:07,199
specifications are and i know they've

00:15:05,519 --> 00:15:10,160
been verified so i don't need to know

00:15:07,199 --> 00:15:11,199
um we don't do code reviews surprisingly

00:15:10,160 --> 00:15:12,639
because

00:15:11,199 --> 00:15:14,320
we verify that it meets the

00:15:12,639 --> 00:15:15,680
specification i actually don't really

00:15:14,320 --> 00:15:18,720
care what's in the blocks

00:15:15,680 --> 00:15:19,100
as long as they synthesize yeah all

00:15:18,720 --> 00:15:20,399
right

00:15:19,100 --> 00:15:23,040
[Applause]

00:15:20,399 --> 00:15:24,480
this is we've gone through this same

00:15:23,040 --> 00:15:26,399
chart a few times

00:15:24,480 --> 00:15:28,000
so this is what implemented index we

00:15:26,399 --> 00:15:29,680
could actually implement the

00:15:28,000 --> 00:15:31,839
the architecture and layout stages too

00:15:29,680 --> 00:15:33,519
and the hooks are there but the

00:15:31,839 --> 00:15:34,959
architecture is actually kind of fuzzy

00:15:33,519 --> 00:15:35,440
the process we're doing that and layout

00:15:34,959 --> 00:15:38,800
isn't

00:15:35,440 --> 00:15:40,320
something we have a third party do so

00:15:38,800 --> 00:15:42,399
the design verification implementation

00:15:40,320 --> 00:15:44,560
and formal equivalence checks um

00:15:42,399 --> 00:15:47,519
are all done with nics on the on the

00:15:44,560 --> 00:15:47,519
project they did um

00:15:48,160 --> 00:15:50,959
and this is actually

00:15:51,279 --> 00:15:57,519
the entire tasks of what i did it's

00:15:54,880 --> 00:16:00,320
a bit of an eye chart let's see if i can

00:15:57,519 --> 00:16:04,800
zoom in a bit you can actually see the

00:16:00,320 --> 00:16:08,320
the derivations oh come on events

00:16:04,800 --> 00:16:09,680
so uh you can see the verification desk

00:16:08,320 --> 00:16:10,959
here you can see all the different lab

00:16:09,680 --> 00:16:13,120
all the different derivations that get

00:16:10,959 --> 00:16:15,440
used as we grind through here

00:16:13,120 --> 00:16:17,440
so and you'll see notice you'll

00:16:15,440 --> 00:16:21,759
recognize some of these from the

00:16:17,440 --> 00:16:25,120
up above showing

00:16:21,759 --> 00:16:29,199
so why nyx works for us

00:16:25,120 --> 00:16:30,560
um it's nice and nice and pure it does

00:16:29,199 --> 00:16:31,360
lazy evaluation which is important

00:16:30,560 --> 00:16:32,639
because

00:16:31,360 --> 00:16:34,639
some of these derivations will be

00:16:32,639 --> 00:16:35,600
incredibly expensive um it does find

00:16:34,639 --> 00:16:38,320
grain dependencies which

00:16:35,600 --> 00:16:39,920
actually uh really helps with only

00:16:38,320 --> 00:16:42,160
building what you need to

00:16:39,920 --> 00:16:42,160
um

00:16:43,040 --> 00:16:48,240
the i after

00:16:46,959 --> 00:16:50,800
one of the presentations yesterday i

00:16:48,240 --> 00:16:51,920
changed the good documentation to good

00:16:50,800 --> 00:16:54,000
reference documentation

00:16:51,920 --> 00:16:55,519
um because because the language

00:16:54,000 --> 00:16:56,480
specification is actually really nice

00:16:55,519 --> 00:16:58,399
that they're all

00:16:56,480 --> 00:17:00,480
all of the built-ins or are well

00:16:58,399 --> 00:17:02,720
described

00:17:00,480 --> 00:17:04,240
how everything works is really nice the

00:17:02,720 --> 00:17:04,880
assertions and nyx are actually awesome

00:17:04,240 --> 00:17:07,039
i love them

00:17:04,880 --> 00:17:08,720
um and that that's important when you

00:17:07,039 --> 00:17:12,400
have a lot of different types of vari

00:17:08,720 --> 00:17:12,400
of derivations so

00:17:14,240 --> 00:17:18,559
all right um talk a bit about design

00:17:16,720 --> 00:17:19,439
tasks because it kind of gives an idea

00:17:18,559 --> 00:17:21,439
of

00:17:19,439 --> 00:17:22,799
what things are like at the bottom so

00:17:21,439 --> 00:17:24,640
this is what a directory structure would

00:17:22,799 --> 00:17:27,760
work like we have these dot v files

00:17:24,640 --> 00:17:29,120
and the dot svh files

00:17:27,760 --> 00:17:31,039
which our dot view files are actually

00:17:29,120 --> 00:17:35,600
verilog files with extension of verilog

00:17:31,039 --> 00:17:38,000
verilog looks a lot like c with teeth

00:17:35,600 --> 00:17:40,799
so this direction restriction is

00:17:38,000 --> 00:17:41,919
important because we use a mercurial

00:17:40,799 --> 00:17:44,080
or we could use git doesn't really

00:17:41,919 --> 00:17:45,760
matter

00:17:44,080 --> 00:17:47,360
for our blocks each block lives in its

00:17:45,760 --> 00:17:49,760
own branch

00:17:47,360 --> 00:17:50,960
and then when a designer decides that

00:17:49,760 --> 00:17:53,520
they're at a particular

00:17:50,960 --> 00:17:54,480
good good point to release something

00:17:53,520 --> 00:17:56,160
they tag it

00:17:54,480 --> 00:17:57,760
and then when we integrate stuff we just

00:17:56,160 --> 00:18:00,559
merge in tags so

00:17:57,760 --> 00:18:01,039
that works nicely because all the stuff

00:18:00,559 --> 00:18:03,440
for this

00:18:01,039 --> 00:18:04,480
matte block is its own directory

00:18:03,440 --> 00:18:05,760
structure and when you merge it with

00:18:04,480 --> 00:18:08,240
some other block then there's no

00:18:05,760 --> 00:18:08,240
conflicts

00:18:09,280 --> 00:18:14,640
so and also the way this works is

00:18:12,640 --> 00:18:16,080
at the higher like a subsystem level i

00:18:14,640 --> 00:18:19,120
can actually i just

00:18:16,080 --> 00:18:21,200
import that meh.nx file

00:18:19,120 --> 00:18:22,799
which contains all the information about

00:18:21,200 --> 00:18:25,600
all those rtl files

00:18:22,799 --> 00:18:29,280
so what's going on here is i use a

00:18:25,600 --> 00:18:30,799
probably lesser known feature in nics

00:18:29,280 --> 00:18:32,480
this mostly gets used in nyx packages

00:18:30,799 --> 00:18:36,720
for patch files that are

00:18:32,480 --> 00:18:38,960
loaded in the in the next package

00:18:36,720 --> 00:18:40,559
itself or version control and index

00:18:38,960 --> 00:18:42,559
packages repository itself

00:18:40,559 --> 00:18:43,760
is if you reference a bear file in nix

00:18:42,559 --> 00:18:45,919
it just

00:18:43,760 --> 00:18:47,360
copies that file into into this store

00:18:45,919 --> 00:18:50,960
and then gives you uh

00:18:47,360 --> 00:18:52,799
the variable uh then becomes the path

00:18:50,960 --> 00:18:55,039
to what it copied to in the store and

00:18:52,799 --> 00:18:57,360
this one's really helpful because

00:18:55,039 --> 00:18:59,520
when you're iterating on stuff as soon

00:18:57,360 --> 00:19:00,960
as you do a next build

00:18:59,520 --> 00:19:02,080
it's copied everything into the store

00:19:00,960 --> 00:19:03,440
and you can go back to editing your

00:19:02,080 --> 00:19:05,840
workspace you don't need to worry about

00:19:03,440 --> 00:19:08,640
uh interface interfering with the build

00:19:05,840 --> 00:19:08,640
that's currently working

00:19:09,120 --> 00:19:15,679
do so this is what uh

00:19:12,799 --> 00:19:17,360
one of those net.next files looks like

00:19:15,679 --> 00:19:19,120
um the only real complicated thing here

00:19:17,360 --> 00:19:21,440
is this compile units

00:19:19,120 --> 00:19:24,160
um which kind of begins to look like we

00:19:21,440 --> 00:19:26,160
i'm using nyx like make here

00:19:24,160 --> 00:19:28,720
this is a simple compile unit it is a

00:19:26,160 --> 00:19:30,160
list of attribute sets

00:19:28,720 --> 00:19:32,480
and the reason for this is it's a

00:19:30,160 --> 00:19:33,039
verilog lrm thing it deals with the

00:19:32,480 --> 00:19:34,720
scope

00:19:33,039 --> 00:19:36,320
of which the compiler will pay attention

00:19:34,720 --> 00:19:38,640
to includes

00:19:36,320 --> 00:19:39,679
and because includes our terrible source

00:19:38,640 --> 00:19:43,120
of impurity

00:19:39,679 --> 00:19:44,559
um we i try to very carefully bound that

00:19:43,120 --> 00:19:48,800
and to the point where

00:19:44,559 --> 00:19:50,160
um if you want to pound include a file

00:19:48,800 --> 00:19:52,160
[Applause]

00:19:50,160 --> 00:19:53,520
you actually have to specified here in

00:19:52,160 --> 00:19:54,880
the includes what the file you want

00:19:53,520 --> 00:19:56,880
the list of files you want to include

00:19:54,880 --> 00:19:58,240
are so that you don't

00:19:56,880 --> 00:19:59,520
including something out of some random

00:19:58,240 --> 00:20:00,799
spot in the environment that's not

00:19:59,520 --> 00:20:02,720
tracked by nyx

00:20:00,799 --> 00:20:03,760
when it's building stuff so that it if

00:20:02,720 --> 00:20:04,400
you change something in that include

00:20:03,760 --> 00:20:05,919
file

00:20:04,400 --> 00:20:08,960
that your hashes will change and nix

00:20:05,919 --> 00:20:13,120
knows needs to rebuild everything

00:20:08,960 --> 00:20:17,440
so there are a couple of useful uh

00:20:13,120 --> 00:20:21,200
attributes in this net.nx file

00:20:17,440 --> 00:20:23,679
the lib attribute and the lab attribute

00:20:21,200 --> 00:20:24,240
the lib attribute is basically compiles

00:20:23,679 --> 00:20:27,120
everything

00:20:24,240 --> 00:20:29,120
into a library which is a big binary

00:20:27,120 --> 00:20:30,720
file that's specific to the simulator

00:20:29,120 --> 00:20:32,640
and that is what we will use at a higher

00:20:30,720 --> 00:20:34,080
level so we just include like we just

00:20:32,640 --> 00:20:35,200
start using the dot lib file from all

00:20:34,080 --> 00:20:36,799
these little blocks and then we don't

00:20:35,200 --> 00:20:40,159
need to recompile things

00:20:36,799 --> 00:20:44,000
and excuse me the elaboration

00:20:40,159 --> 00:20:46,159
is i suppose the analogy is

00:20:44,000 --> 00:20:47,760
is linking a binary to make sure that

00:20:46,159 --> 00:20:48,000
all of your your symbols are resolved

00:20:47,760 --> 00:20:49,200
and

00:20:48,000 --> 00:20:50,799
in the case here this makes sure that

00:20:49,200 --> 00:20:51,600
all your ports match up and that

00:20:50,799 --> 00:20:54,400
everything kind of

00:20:51,600 --> 00:20:56,000
fits where it's supposed to they're

00:20:54,400 --> 00:20:59,520
relatively cheap things to do

00:20:56,000 --> 00:21:03,840
and they catch a lot of problems so

00:20:59,520 --> 00:21:03,840
when we want to use this meh block

00:21:04,240 --> 00:21:07,919
higher level this is something that

00:21:06,559 --> 00:21:11,280
instantiates

00:21:07,919 --> 00:21:12,320
the maha block it has compiled units too

00:21:11,280 --> 00:21:14,159
because it needs to instantiate it

00:21:12,320 --> 00:21:16,159
somewhere

00:21:14,159 --> 00:21:17,360
and it has a lib to you because it has

00:21:16,159 --> 00:21:19,520
code but

00:21:17,360 --> 00:21:21,120
um the interesting thing about it is

00:21:19,520 --> 00:21:22,480
during the elaboration you notice that

00:21:21,120 --> 00:21:25,840
the libraries now has

00:21:22,480 --> 00:21:29,440
pulls the meh.lib attribute

00:21:25,840 --> 00:21:30,960
out of here so

00:21:29,440 --> 00:21:32,720
what that does then is when it does the

00:21:30,960 --> 00:21:34,320
elaboration it says okay pull

00:21:32,720 --> 00:21:36,559
this elaboration library out of the

00:21:34,320 --> 00:21:36,559
store

00:21:37,600 --> 00:21:41,280
all right um and then i've got a bunch

00:21:39,520 --> 00:21:44,400
of regular stuff

00:21:41,280 --> 00:21:46,559
um regular ip that's kind of derpy

00:21:44,400 --> 00:21:48,240
um that we get from third parties and

00:21:46,559 --> 00:21:49,840
those just use

00:21:48,240 --> 00:21:51,440
standard derivations for putting that

00:21:49,840 --> 00:21:53,360
stuff in spots and

00:21:51,440 --> 00:21:55,120
of course since everyone packages their

00:21:53,360 --> 00:21:56,720
ip differently if you want to put

00:21:55,120 --> 00:21:58,799
the models or the specifications in a

00:21:56,720 --> 00:22:01,840
whole spot you have to have different

00:21:58,799 --> 00:22:01,840
derivations for all of them

00:22:01,919 --> 00:22:05,679
all right verification flow this one's

00:22:04,400 --> 00:22:08,559
talked a bit about before

00:22:05,679 --> 00:22:09,679
but basically what it comes down to is

00:22:08,559 --> 00:22:12,320
this is

00:22:09,679 --> 00:22:13,600
probably the core of what makes us do

00:22:12,320 --> 00:22:15,760
socs without

00:22:13,600 --> 00:22:16,880
many revisions i'm not going to spend a

00:22:15,760 --> 00:22:18,559
lot of time talking about it because i

00:22:16,880 --> 00:22:21,039
don't really have a lot of time but

00:22:18,559 --> 00:22:21,760
um basically we extract requirements

00:22:21,039 --> 00:22:24,320
from

00:22:21,760 --> 00:22:25,280
from specifications we map those what we

00:22:24,320 --> 00:22:26,400
call design requirements into

00:22:25,280 --> 00:22:28,080
verification requirements

00:22:26,400 --> 00:22:29,840
which are based the things we want to

00:22:28,080 --> 00:22:31,840
see the one things we want to check

00:22:29,840 --> 00:22:34,320
uh we map those verification

00:22:31,840 --> 00:22:37,120
requirements into into tests

00:22:34,320 --> 00:22:37,440
and we run the run those tests and this

00:22:37,120 --> 00:22:39,280
really

00:22:37,440 --> 00:22:40,960
describes part of what we do because

00:22:39,280 --> 00:22:42,640
this is all just directed tests

00:22:40,960 --> 00:22:44,400
which is probably more of what's

00:22:42,640 --> 00:22:47,760
understood in the software world

00:22:44,400 --> 00:22:51,200
but the majority of our coverage of

00:22:47,760 --> 00:22:53,280
things uh functional coverage

00:22:51,200 --> 00:22:54,720
is comes from random constrained

00:22:53,280 --> 00:22:57,679
simulations

00:22:54,720 --> 00:22:58,799
so uh when i talk about coverage i'm not

00:22:57,679 --> 00:23:00,240
talking about code coverage i'm talking

00:22:58,799 --> 00:23:01,600
about functional coverage and functional

00:23:00,240 --> 00:23:05,120
coverage means that

00:23:01,600 --> 00:23:06,400
we gave the design the stimulus we want

00:23:05,120 --> 00:23:08,159
it did the right thing when it gave that

00:23:06,400 --> 00:23:11,200
synthesis and

00:23:08,159 --> 00:23:12,480
we saw it so this is

00:23:11,200 --> 00:23:14,159
important because what you really care

00:23:12,480 --> 00:23:15,440
about is the thing did what you wanted

00:23:14,159 --> 00:23:17,679
it to

00:23:15,440 --> 00:23:19,360
um oh as a quick question does anyone

00:23:17,679 --> 00:23:21,600
know the difference between verification

00:23:19,360 --> 00:23:25,200
and validation

00:23:21,600 --> 00:23:26,960
anyone all right uh okay verification

00:23:25,200 --> 00:23:28,240
is a design meets a specification

00:23:26,960 --> 00:23:30,559
validation is

00:23:28,240 --> 00:23:31,919
a design is suitable for a purpose and

00:23:30,559 --> 00:23:32,240
they're not quite the same thing because

00:23:31,919 --> 00:23:33,520
not

00:23:32,240 --> 00:23:35,679
we don't always get the specifications

00:23:33,520 --> 00:23:36,000
right which is kind of outside of what

00:23:35,679 --> 00:23:39,520
we do

00:23:36,000 --> 00:23:42,400
but so

00:23:39,520 --> 00:23:43,440
uh that comes this brings us back to

00:23:42,400 --> 00:23:48,320
this

00:23:43,440 --> 00:23:50,320
so anyone figure out what the bug was

00:23:48,320 --> 00:24:05,840
it's a it's an off by one this is

00:23:50,320 --> 00:24:08,799
supposed to be a one

00:24:05,840 --> 00:24:08,799
testing all right

00:24:12,240 --> 00:24:14,640
pardon me

00:24:15,679 --> 00:24:22,640
okay so uh

00:24:20,000 --> 00:24:23,600
what we're doing here is we have five or

00:24:22,640 --> 00:24:25,039
five different tests there

00:24:23,600 --> 00:24:27,760
and they run a whole bunch of seeds for

00:24:25,039 --> 00:24:30,480
because they have uh

00:24:27,760 --> 00:24:32,640
um random components um and our

00:24:30,480 --> 00:24:35,840
simulations have

00:24:32,640 --> 00:24:37,279
uh random stability meaning that

00:24:35,840 --> 00:24:38,480
as long as the design doesn't change the

00:24:37,279 --> 00:24:39,520
same seed will generate the same

00:24:38,480 --> 00:24:40,880
stimulus

00:24:39,520 --> 00:24:42,720
that's kind of important for debugging

00:24:40,880 --> 00:24:45,440
is when something crashes you want to be

00:24:42,720 --> 00:24:46,960
able to figure out why it crashed

00:24:45,440 --> 00:24:49,039
but also you notice there's a bunch of

00:24:46,960 --> 00:24:50,320
skips in there that's because

00:24:49,039 --> 00:24:51,600
you may notice that when you're

00:24:50,320 --> 00:24:52,559
designing something or testing something

00:24:51,600 --> 00:24:54,880
often your test

00:24:52,559 --> 00:24:55,840
your bugs are actually in your tests not

00:24:54,880 --> 00:24:58,159
in your design

00:24:55,840 --> 00:24:59,360
or your code so this is just

00:24:58,159 --> 00:25:01,679
acknowledging the fact that

00:24:59,360 --> 00:25:02,799
you know often when you start really

00:25:01,679 --> 00:25:04,480
testing things

00:25:02,799 --> 00:25:05,760
especially random tests you come across

00:25:04,480 --> 00:25:06,400
all kinds of things you never expected

00:25:05,760 --> 00:25:09,679
you'd come

00:25:06,400 --> 00:25:12,880
across like address collisions and

00:25:09,679 --> 00:25:16,559
all kinds of stuff so

00:25:12,880 --> 00:25:19,760
um the reason this is a

00:25:16,559 --> 00:25:22,960
uh supposed to be a one is because

00:25:19,760 --> 00:25:24,799
when you do a range from 0 to 200 you're

00:25:22,960 --> 00:25:26,240
actually that's 201 elements not 200

00:25:24,799 --> 00:25:29,840
elements so

00:25:26,240 --> 00:25:29,840
um yeah

00:25:30,480 --> 00:25:34,000
so what this does is pulls runs runs all

00:25:33,039 --> 00:25:37,360
the simulations

00:25:34,000 --> 00:25:39,840
so this regression attribute here is

00:25:37,360 --> 00:25:41,679
a big list or a list of lists of all of

00:25:39,840 --> 00:25:43,919
the simulation elements were

00:25:41,679 --> 00:25:45,200
generated with this build regression sim

00:25:43,919 --> 00:25:48,400
uh function

00:25:45,200 --> 00:25:51,360
and then we merge everything

00:25:48,400 --> 00:25:52,799
into with this coverage thing here and

00:25:51,360 --> 00:25:55,600
what this does is

00:25:52,799 --> 00:25:56,000
when we there's stuff built into our

00:25:55,600 --> 00:25:58,400
language

00:25:56,000 --> 00:25:59,679
that says when you see something say

00:25:58,400 --> 00:26:01,360
that you saw it and it keeps the

00:25:59,679 --> 00:26:03,200
database of what it saw

00:26:01,360 --> 00:26:04,559
and then we merge across all the

00:26:03,200 --> 00:26:06,640
simulations we run

00:26:04,559 --> 00:26:08,720
to see what we saw everywhere and that

00:26:06,640 --> 00:26:09,840
worked and then if we say we saw

00:26:08,720 --> 00:26:12,880
everything we wanted to say

00:26:09,840 --> 00:26:16,400
see we're done and it worked

00:26:12,880 --> 00:26:17,120
so this also means if you know we didn't

00:26:16,400 --> 00:26:19,360
see

00:26:17,120 --> 00:26:21,120
for this essay we didn't see a read

00:26:19,360 --> 00:26:22,640
followed by a write ever that worked

00:26:21,120 --> 00:26:24,480
then that's a pretty good place to look

00:26:22,640 --> 00:26:25,520
to say oh there might be a bug there

00:26:24,480 --> 00:26:27,679
because we probably generated the

00:26:25,520 --> 00:26:30,799
stimulus for a read followed by a right

00:26:27,679 --> 00:26:33,120
but we never saw one working yeah it's

00:26:30,799 --> 00:26:35,679
it's kind of a fascinating way of

00:26:33,120 --> 00:26:35,679
looking at things

00:26:35,760 --> 00:26:40,480
all right talk a bit about one of the

00:26:39,039 --> 00:26:44,640
simple derivations

00:26:40,480 --> 00:26:46,400
this is they're all basically uh

00:26:44,640 --> 00:26:48,320
based on the standard environment make

00:26:46,400 --> 00:26:52,000
derivation stuff um

00:26:48,320 --> 00:26:52,799
i had to i was saying how the assertions

00:26:52,000 --> 00:26:54,400
are pretty awesome

00:26:52,799 --> 00:26:55,840
um you can actually read those

00:26:54,400 --> 00:26:57,120
assertions they actually kind of make

00:26:55,840 --> 00:27:00,480
sense what they're doing

00:26:57,120 --> 00:27:03,200
um like the built-ins is list sure

00:27:00,480 --> 00:27:04,240
make sure that the a laptop is a valid

00:27:03,200 --> 00:27:06,960
module name

00:27:04,240 --> 00:27:08,400
if you for instance if you have a space

00:27:06,960 --> 00:27:09,120
and a module name it's not a legal

00:27:08,400 --> 00:27:12,720
verilog

00:27:09,120 --> 00:27:13,919
module name um the next two

00:27:12,720 --> 00:27:16,640
are kind of important for the way the

00:27:13,919 --> 00:27:19,679
tool flow works is you could

00:27:16,640 --> 00:27:21,440
since the libraries is a list you could

00:27:19,679 --> 00:27:23,600
give it a list of strings and

00:27:21,440 --> 00:27:24,880
those are if you try to feed those into

00:27:23,600 --> 00:27:29,279
the simulator it would just

00:27:24,880 --> 00:27:31,279
yeah it's it's going to crash but um

00:27:29,279 --> 00:27:32,559
the assertion here goes through and

00:27:31,279 --> 00:27:33,919
checks this

00:27:32,559 --> 00:27:36,240
cad type thing and all of the

00:27:33,919 --> 00:27:39,360
derivations to make sure that it matches

00:27:36,240 --> 00:27:41,279
um and the next assertion

00:27:39,360 --> 00:27:42,399
is if you have two libraries discover

00:27:41,279 --> 00:27:43,840
this one a while

00:27:42,399 --> 00:27:44,960
in is you have two libraries of the same

00:27:43,840 --> 00:27:45,679
name it doesn't pay attention to the

00:27:44,960 --> 00:27:47,760
first one

00:27:45,679 --> 00:27:49,039
but you might it's probably an error in

00:27:47,760 --> 00:27:50,480
one year of derivation somewhere else

00:27:49,039 --> 00:27:53,440
but it's kind of annoying that you lost

00:27:50,480 --> 00:27:53,440
half your design somehow

00:27:53,600 --> 00:27:56,880
so the reason for doing these

00:27:55,120 --> 00:27:59,039
derivations is

00:27:56,880 --> 00:28:01,760
there are there's an ecosystem of cad

00:27:59,039 --> 00:28:05,760
tools and there are certain

00:28:01,760 --> 00:28:07,520
points which we divide things on that uh

00:28:05,760 --> 00:28:09,039
like the compile units for instance

00:28:07,520 --> 00:28:10,320
there are logical partitioning where you

00:28:09,039 --> 00:28:12,960
can swap out tools

00:28:10,320 --> 00:28:14,240
so the idea being is this is using a

00:28:12,960 --> 00:28:15,360
tool called modelsum for doing

00:28:14,240 --> 00:28:16,559
elaboration

00:28:15,360 --> 00:28:18,159
but there are many other tools to do

00:28:16,559 --> 00:28:19,679
elaboration many different simulators

00:28:18,159 --> 00:28:21,360
for instance there's the open source

00:28:19,679 --> 00:28:23,520
icarus verilog simulator and

00:28:21,360 --> 00:28:24,559
a few other ones so that the idea being

00:28:23,520 --> 00:28:27,600
is

00:28:24,559 --> 00:28:29,200
if you go back to the meh dot next file

00:28:27,600 --> 00:28:30,799
it just calls make a lab it doesn't care

00:28:29,200 --> 00:28:32,799
which simulator you're using

00:28:30,799 --> 00:28:34,240
so you could swap out in the back end

00:28:32,799 --> 00:28:36,080
here you could swap out to use icarus

00:28:34,240 --> 00:28:37,360
now or you could swap out to use vcs or

00:28:36,080 --> 00:28:39,360
ncsam or

00:28:37,360 --> 00:28:41,120
whatever other simulator you want and it

00:28:39,360 --> 00:28:43,600
takes the same arguments

00:28:41,120 --> 00:28:44,799
it takes the same compile units it just

00:28:43,600 --> 00:28:47,840
does something different under the hood

00:28:44,799 --> 00:28:47,840
generates a different derivation

00:28:49,200 --> 00:28:53,679
to talk about something the reason i put

00:28:52,799 --> 00:28:54,320
this in here because this is using

00:28:53,679 --> 00:28:57,360
another

00:28:54,320 --> 00:29:01,200
nifty thing i discovered in

00:28:57,360 --> 00:29:01,520
mnix we do these things called ecos

00:29:01,200 --> 00:29:03,760
which

00:29:01,520 --> 00:29:05,919
stands for engineering change order once

00:29:03,760 --> 00:29:06,640
so what happens is once we ship off this

00:29:05,919 --> 00:29:08,320
netlist

00:29:06,640 --> 00:29:10,159
hand off the layout we actually can't

00:29:08,320 --> 00:29:12,480
resynthesize anymore like once

00:29:10,159 --> 00:29:14,399
we've handed that one off it takes like

00:29:12,480 --> 00:29:16,480
12 weeks for them to finish their

00:29:14,399 --> 00:29:17,440
doing all the layout but if we find a

00:29:16,480 --> 00:29:18,720
bug

00:29:17,440 --> 00:29:20,480
that we need to fix in the net list we

00:29:18,720 --> 00:29:22,080
can't just re synthesize it

00:29:20,480 --> 00:29:24,960
so what we have to do is we have to

00:29:22,080 --> 00:29:27,840
write a script that disconnects wires

00:29:24,960 --> 00:29:29,279
rewires standard cells you know

00:29:27,840 --> 00:29:31,919
instantiates new standard cells

00:29:29,279 --> 00:29:34,000
and the netlist itself and this is kind

00:29:31,919 --> 00:29:35,840
of complicated because

00:29:34,000 --> 00:29:37,120
we don't simulate the actual net list

00:29:35,840 --> 00:29:38,480
because it's not worth doing because

00:29:37,120 --> 00:29:39,200
it's incredibly painful to simulate

00:29:38,480 --> 00:29:41,360
gates

00:29:39,200 --> 00:29:42,240
just don't do it there's no value in it

00:29:41,360 --> 00:29:44,159
because it

00:29:42,240 --> 00:29:45,679
you don't actually get any knowledge and

00:29:44,159 --> 00:29:48,320
just spend a lot for doing it

00:29:45,679 --> 00:29:50,080
so we simulate the actual rtl code so

00:29:48,320 --> 00:29:51,760
what we end up doing here is

00:29:50,080 --> 00:29:53,200
is let's say we have this netlist

00:29:51,760 --> 00:29:55,200
handoff that we're related

00:29:53,200 --> 00:29:56,799
and it turns out that we shipped it and

00:29:55,200 --> 00:30:01,600
then the verification team in their

00:29:56,799 --> 00:30:04,080
last simulations discovers a bug

00:30:01,600 --> 00:30:05,760
so what we have to do is you have to go

00:30:04,080 --> 00:30:08,080
write an eco against the rtl

00:30:05,760 --> 00:30:09,840
so just fix the code and verify that

00:30:08,080 --> 00:30:11,440
they fixed it

00:30:09,840 --> 00:30:14,000
and so that gives us okay verification's

00:30:11,440 --> 00:30:16,080
good you fix the bug and then we have to

00:30:14,000 --> 00:30:18,000
patch the net list and then the patch to

00:30:16,080 --> 00:30:20,159
place gates

00:30:18,000 --> 00:30:22,000
and then the problem with that is then

00:30:20,159 --> 00:30:23,360
we need to make sure that those fixes

00:30:22,000 --> 00:30:26,880
were equivalent

00:30:23,360 --> 00:30:28,240
is so um

00:30:26,880 --> 00:30:30,080
that is actually what we use those form

00:30:28,240 --> 00:30:31,039
equivalence tools for so this part of

00:30:30,080 --> 00:30:33,039
the flow isn't

00:30:31,039 --> 00:30:34,559
as labor intensive as the verification

00:30:33,039 --> 00:30:36,799
flow because uh

00:30:34,559 --> 00:30:39,120
once you go into a more rigid formalism

00:30:36,799 --> 00:30:42,320
you can use more powerful tools like the

00:30:39,120 --> 00:30:43,840
the um the placed gates and netlists are

00:30:42,320 --> 00:30:45,120
quite rigid formalisms that you know

00:30:43,840 --> 00:30:46,720
you're just all now in the realm of

00:30:45,120 --> 00:30:50,040
boolean logic there isn't really

00:30:46,720 --> 00:30:51,279
any room for interpretation so

00:30:50,040 --> 00:30:53,840
[Applause]

00:30:51,279 --> 00:30:54,960
this is what the eco scripts look like

00:30:53,840 --> 00:30:57,919
um

00:30:54,960 --> 00:30:58,399
and the reason i brought this up is you

00:30:57,919 --> 00:31:00,640
you

00:30:58,399 --> 00:31:03,200
always end up doing more than one in

00:31:00,640 --> 00:31:06,799
this particular design there are 34.

00:31:03,200 --> 00:31:09,919
um and that's across the entire chip

00:31:06,799 --> 00:31:11,440
so uh what it is is you also have to

00:31:09,919 --> 00:31:12,720
apply them sequentially and this is just

00:31:11,440 --> 00:31:14,480
a fold left

00:31:12,720 --> 00:31:16,320
so you talk to take the original net

00:31:14,480 --> 00:31:19,440
list and apply

00:31:16,320 --> 00:31:22,320
eco sequentially and you know it all

00:31:19,440 --> 00:31:22,720
goes into that fold left and this

00:31:22,320 --> 00:31:24,240
actually

00:31:22,720 --> 00:31:26,240
is another place where nyx is really

00:31:24,240 --> 00:31:27,600
helpful because

00:31:26,240 --> 00:31:29,360
it's expensive to do these because you

00:31:27,600 --> 00:31:30,559
have to load the whole design in and

00:31:29,360 --> 00:31:31,360
each one of these scripts takes like

00:31:30,559 --> 00:31:35,360
five minutes

00:31:31,360 --> 00:31:37,919
to run so you can see there's 34 of them

00:31:35,360 --> 00:31:39,039
so 34 times five is a long time to

00:31:37,919 --> 00:31:40,320
actually generate all this stuff to make

00:31:39,039 --> 00:31:43,519
sure that it works

00:31:40,320 --> 00:31:44,559
so uh what i typically do after doing

00:31:43,519 --> 00:31:46,159
this is after

00:31:44,559 --> 00:31:47,760
you know i generate the last eco there

00:31:46,159 --> 00:31:49,919
and i push that into a binary cache

00:31:47,760 --> 00:31:52,720
which is accessible via nfs

00:31:49,919 --> 00:31:54,399
so that if someone has the unfortunate

00:31:52,720 --> 00:31:56,159
needs to add another eco then

00:31:54,399 --> 00:31:57,600
what happens is nix will just pull the

00:31:56,159 --> 00:31:59,679
intermediate

00:31:57,600 --> 00:32:00,640
generated netlist out of the binary

00:31:59,679 --> 00:32:04,240
cache which saves

00:32:00,640 --> 00:32:05,360
immense amounts of time we also um

00:32:04,240 --> 00:32:07,519
there's this ticket thing in here

00:32:05,360 --> 00:32:09,120
because part of when we find a bug we

00:32:07,519 --> 00:32:09,760
have to file a ticket so we have a nice

00:32:09,120 --> 00:32:11,279
place to

00:32:09,760 --> 00:32:14,640
put all the discussion of what the bug

00:32:11,279 --> 00:32:17,840
is and

00:32:14,640 --> 00:32:19,919
what happened with it um

00:32:17,840 --> 00:32:21,840
so we actually uh start putting uh th

00:32:19,919 --> 00:32:23,360
this applies here this ico

00:32:21,840 --> 00:32:26,000
actually puts in comments in the net

00:32:23,360 --> 00:32:29,840
list exactly which bugs are fixed in it

00:32:26,000 --> 00:32:29,840
which is kind of a handy tracking thing

00:32:30,480 --> 00:32:34,559
now on to the tools the tools are um cad

00:32:32,640 --> 00:32:38,080
tools are

00:32:34,559 --> 00:32:41,519
the worst software i've ever used um

00:32:38,080 --> 00:32:42,960
they yeah it's i don't know

00:32:41,519 --> 00:32:44,159
considering we pay an immense amount of

00:32:42,960 --> 00:32:46,399
money for them they're they're just

00:32:44,159 --> 00:32:50,880
horrible

00:32:46,399 --> 00:32:54,399
so the as you can see um

00:32:50,880 --> 00:32:54,399
what a part of what i do is i actually

00:32:54,480 --> 00:32:57,519
have something that looks like mixed

00:32:56,000 --> 00:32:57,919
packages but it imports next packages

00:32:57,519 --> 00:32:59,600
that i

00:32:57,919 --> 00:33:02,159
load the tools in out of their their tar

00:32:59,600 --> 00:33:05,760
bowls um patch off them all to use

00:33:02,159 --> 00:33:08,000
nicks and uh execute them from

00:33:05,760 --> 00:33:08,960
inside the next store just like regular

00:33:08,000 --> 00:33:11,679
next packages

00:33:08,960 --> 00:33:12,240
however they come across things like uh

00:33:11,679 --> 00:33:15,679
no one

00:33:12,240 --> 00:33:18,159
actually uses lib term cap anymore um

00:33:15,679 --> 00:33:19,279
and because i don't know 20 or 30 years

00:33:18,159 --> 00:33:21,279
ago

00:33:19,279 --> 00:33:22,799
ncrs has replaced it and it's actually

00:33:21,279 --> 00:33:25,919
abi compatible

00:33:22,799 --> 00:33:29,600
so um you can actually before patch elf

00:33:25,919 --> 00:33:33,600
grew the ability to change the r

00:33:29,600 --> 00:33:35,519
the dt needed in a l file

00:33:33,600 --> 00:33:38,799
i was actually using said to change the

00:33:35,519 --> 00:33:39,919
dt needed in a

00:33:38,799 --> 00:33:42,240
and i i don't know it's kind of

00:33:39,919 --> 00:33:44,240
satisfying to do great violence upon the

00:33:42,240 --> 00:33:47,279
tools because

00:33:44,240 --> 00:33:49,679
yeah in the future uh i'm

00:33:47,279 --> 00:33:50,640
very keen on the ffh street environment

00:33:49,679 --> 00:33:52,320
because that means i wouldn't need to do

00:33:50,640 --> 00:33:55,440
this anymore i can just create

00:33:52,320 --> 00:33:57,200
a red hat or centos uh

00:33:55,440 --> 00:33:58,320
if they say schrute environment throw

00:33:57,200 --> 00:33:59,360
the cad tool in there and run it from

00:33:58,320 --> 00:34:00,480
there

00:33:59,360 --> 00:34:01,440
unfortunately i can't really do that in

00:34:00,480 --> 00:34:02,880
the environment i have right now because

00:34:01,440 --> 00:34:04,840
i don't have root access so i can't use

00:34:02,880 --> 00:34:07,519
schrute

00:34:04,840 --> 00:34:09,599
so all right

00:34:07,519 --> 00:34:10,879
i mentioned this bit earlier but we have

00:34:09,599 --> 00:34:13,679
a lot of external ip

00:34:10,879 --> 00:34:14,480
we don't do everything ourselves and one

00:34:13,679 --> 00:34:17,520
of the problems

00:34:14,480 --> 00:34:18,560
is that when you have 400 pieces of

00:34:17,520 --> 00:34:20,320
external ip

00:34:18,560 --> 00:34:22,639
and you want to actually compile them

00:34:20,320 --> 00:34:24,480
all no one

00:34:22,639 --> 00:34:26,159
gives you things in the same format you

00:34:24,480 --> 00:34:29,440
can't ask them to give them all the

00:34:26,159 --> 00:34:30,800
with the files in the same spot so

00:34:29,440 --> 00:34:32,079
nyx is really good to be able to manage

00:34:30,800 --> 00:34:33,280
all of this because you just have

00:34:32,079 --> 00:34:34,639
different derivations for all of them

00:34:33,280 --> 00:34:36,000
you can imagine independently

00:34:34,639 --> 00:34:37,670
you can give them the version numbers

00:34:36,000 --> 00:34:39,359
that you can pull out of

00:34:37,670 --> 00:34:42,000
[Applause]

00:34:39,359 --> 00:34:43,359
the you know build time dependencies so

00:34:42,000 --> 00:34:43,919
you can figure out exactly what went

00:34:43,359 --> 00:34:46,960
into a

00:34:43,919 --> 00:34:46,960
particular derivation

00:34:47,520 --> 00:34:53,119
so that it makes the job that i had to

00:34:51,359 --> 00:34:56,000
do as a librarian a bit easier

00:34:53,119 --> 00:34:58,320
um because otherwise it just gets

00:34:56,000 --> 00:34:59,680
untenable pretty quickly

00:34:58,320 --> 00:35:02,720
normally we'd have to have one or two

00:34:59,680 --> 00:35:05,119
people doing this and so i did this

00:35:02,720 --> 00:35:06,240
uh the live librarian as well as

00:35:05,119 --> 00:35:08,960
actually writing the x and doing all the

00:35:06,240 --> 00:35:10,800
triple integration

00:35:08,960 --> 00:35:13,119
the other interest the other module in

00:35:10,800 --> 00:35:15,920
the next cad stuff that i wrote is

00:35:13,119 --> 00:35:16,720
this project module which um is kind of

00:35:15,920 --> 00:35:19,920
a meta layer

00:35:16,720 --> 00:35:21,040
on top of all of the cat the derivations

00:35:19,920 --> 00:35:22,800
you saw before

00:35:21,040 --> 00:35:24,079
which basically says what set of

00:35:22,800 --> 00:35:25,359
variations you use which

00:35:24,079 --> 00:35:27,440
cad tools to use and what versions of

00:35:25,359 --> 00:35:28,720
the cat tools to use because i think

00:35:27,440 --> 00:35:30,400
i went through brought 40 different

00:35:28,720 --> 00:35:32,960
versions of various cad tools throughout

00:35:30,400 --> 00:35:35,440
the project because they're so buggy

00:35:32,960 --> 00:35:36,720
um which standard cells to use because

00:35:35,440 --> 00:35:38,960
that you know they're

00:35:36,720 --> 00:35:40,400
when you think of and gates or gates and

00:35:38,960 --> 00:35:41,680
nor gates and exclusive or gates you

00:35:40,400 --> 00:35:43,440
think there's i don't know 20 or 30 of

00:35:41,680 --> 00:35:45,119
them

00:35:43,440 --> 00:35:46,480
i think we had about 6 000 standard

00:35:45,119 --> 00:35:47,440
cells because there's different drive

00:35:46,480 --> 00:35:49,200
strengths there's different

00:35:47,440 --> 00:35:50,480
um threshold voltages there's different

00:35:49,200 --> 00:35:52,079
sizes

00:35:50,480 --> 00:35:53,599
um the technology that you're

00:35:52,079 --> 00:35:55,200
implementing to you so the metal stack

00:35:53,599 --> 00:35:56,240
the silicon process

00:35:55,200 --> 00:35:58,320
that's all important when you're doing

00:35:56,240 --> 00:36:00,960
synthesis and operating conditions

00:35:58,320 --> 00:36:02,320
silicon i'm not sure if everyone send

00:36:00,960 --> 00:36:04,960
any overclocking stuff

00:36:02,320 --> 00:36:06,800
but there's a reason you uh cool things

00:36:04,960 --> 00:36:08,480
down to like negative 40 or

00:36:06,800 --> 00:36:10,160
liquid nitrogen cool processors to make

00:36:08,480 --> 00:36:11,119
them go faster is because silicon is

00:36:10,160 --> 00:36:13,040
faster

00:36:11,119 --> 00:36:14,960
cold it gets really slow when it gets

00:36:13,040 --> 00:36:16,880
hot and the difference in speed is like

00:36:14,960 --> 00:36:19,680
a factor of three or so

00:36:16,880 --> 00:36:21,200
so things that work in the fast corner

00:36:19,680 --> 00:36:22,480
don't work in the slow corner things

00:36:21,200 --> 00:36:23,760
that work in the slow corner don't work

00:36:22,480 --> 00:36:24,240
in the fast corner so you have to kind

00:36:23,760 --> 00:36:25,760
of

00:36:24,240 --> 00:36:29,599
meet timing across all these it's

00:36:25,760 --> 00:36:33,040
actually a fairly challenging task

00:36:29,599 --> 00:36:36,320
so i wrote a metrics module this is a

00:36:33,040 --> 00:36:40,000
area of a block so

00:36:36,320 --> 00:36:43,760
it's i have a bunch of

00:36:40,000 --> 00:36:45,680
hacky pro scripts that look at reports

00:36:43,760 --> 00:36:47,839
generated by various cad tools and

00:36:45,680 --> 00:36:49,280
write the json to feed into infox

00:36:47,839 --> 00:36:52,240
database

00:36:49,280 --> 00:36:54,720
which the people in influx database then

00:36:52,240 --> 00:36:56,800
promptly stopped using json um

00:36:54,720 --> 00:36:58,000
so they decided their json parser was

00:36:56,800 --> 00:36:59,040
using it was slowing them down so they

00:36:58,000 --> 00:37:01,680
went to a different format which

00:36:59,040 --> 00:37:02,800
means i have to rewrite all my scripts i

00:37:01,680 --> 00:37:06,160
used grafana

00:37:02,800 --> 00:37:07,920
to generate graphs um i think it's

00:37:06,160 --> 00:37:09,760
uh yaka it was yesterday i was talking

00:37:07,920 --> 00:37:10,880
about using grafana influx database so i

00:37:09,760 --> 00:37:14,000
thought was kind of interesting

00:37:10,880 --> 00:37:15,200
um use morgoth for anomaly detection um

00:37:14,000 --> 00:37:17,680
so there's a couple anomalies in that

00:37:15,200 --> 00:37:21,359
graph that are kind of interesting um

00:37:17,680 --> 00:37:22,880
so hydra during its constant evaluation

00:37:21,359 --> 00:37:24,320
evaluates blocks and extracts metrics

00:37:22,880 --> 00:37:25,839
from us and doing these blocks so you

00:37:24,320 --> 00:37:26,960
can look at i don't have to individually

00:37:25,839 --> 00:37:28,800
look at the output all these things i

00:37:26,960 --> 00:37:30,240
just look at a dashboard

00:37:28,800 --> 00:37:31,839
so when someone screws up one of their

00:37:30,240 --> 00:37:33,440
blocks and it synthesizes down to

00:37:31,839 --> 00:37:34,880
nothing because

00:37:33,440 --> 00:37:36,960
our synthesis tools are at least smart

00:37:34,880 --> 00:37:38,480
enough to know that

00:37:36,960 --> 00:37:40,240
if you tie the reset for a block off to

00:37:38,480 --> 00:37:41,359
zero it can never come at a reset so

00:37:40,240 --> 00:37:42,240
they don't bother implementing anything

00:37:41,359 --> 00:37:44,880
in there

00:37:42,240 --> 00:37:46,240
um so this chart is interesting because

00:37:44,880 --> 00:37:48,160
what it is is we

00:37:46,240 --> 00:37:50,000
synthesize both both the block level and

00:37:48,160 --> 00:37:51,599
the chip level and what's interesting to

00:37:50,000 --> 00:37:52,960
see is when we synthesize something the

00:37:51,599 --> 00:37:54,160
block level how much area it uses how

00:37:52,960 --> 00:37:56,079
many gates it has

00:37:54,160 --> 00:37:57,520
versus when you put it in the chip level

00:37:56,079 --> 00:37:57,920
and put it with all the other blocks how

00:37:57,520 --> 00:38:00,160
much

00:37:57,920 --> 00:38:03,359
area it has so the anomalies here are

00:38:00,160 --> 00:38:03,359
actually because

00:38:03,680 --> 00:38:07,359
are at the chip level because what had

00:38:05,359 --> 00:38:09,440
happened is

00:38:07,359 --> 00:38:10,720
in one of the register buses to read and

00:38:09,440 --> 00:38:12,960
write registers from

00:38:10,720 --> 00:38:15,200
in in the design to control what it does

00:38:12,960 --> 00:38:16,640
um there was a bug that made

00:38:15,200 --> 00:38:18,000
it so that it could never actually read

00:38:16,640 --> 00:38:18,560
or write registers so all those

00:38:18,000 --> 00:38:21,040
registers are

00:38:18,560 --> 00:38:22,160
blown away so you can see that it the

00:38:21,040 --> 00:38:24,320
block got like half

00:38:22,160 --> 00:38:25,520
half the size it was supposed to be

00:38:24,320 --> 00:38:29,200
which

00:38:25,520 --> 00:38:31,599
means something's badly broken

00:38:29,200 --> 00:38:32,480
and i have a special module for

00:38:31,599 --> 00:38:33,920
controlling

00:38:32,480 --> 00:38:35,599
when we have to make a handoff to

00:38:33,920 --> 00:38:37,440
someone so we build board support

00:38:35,599 --> 00:38:39,040
packages we build netlist deliverables

00:38:37,440 --> 00:38:40,960
we do eco deliveries

00:38:39,040 --> 00:38:42,720
so that we have a bundle of ecos we hand

00:38:40,960 --> 00:38:43,839
off to the people doing the layout so

00:38:42,720 --> 00:38:45,440
that they can

00:38:43,839 --> 00:38:47,040
you know see here are the scripts you

00:38:45,440 --> 00:38:48,160
need to run on the on the place gates to

00:38:47,040 --> 00:38:50,800
make sure it works

00:38:48,160 --> 00:38:52,240
um and for for the board sport packages

00:38:50,800 --> 00:38:52,640
here all the register header files all

00:38:52,240 --> 00:38:54,800
this

00:38:52,640 --> 00:38:56,160
all 300 specifications you need about

00:38:54,800 --> 00:38:59,359
all the ip

00:38:56,160 --> 00:39:00,000
um so those old things you want to kind

00:38:59,359 --> 00:39:03,520
of abstract

00:39:00,000 --> 00:39:06,720
a bit because everyone wants

00:39:03,520 --> 00:39:06,720
them a little differently

00:39:08,079 --> 00:39:15,119
we use hydra a lot so

00:39:11,680 --> 00:39:17,040
i had as a

00:39:15,119 --> 00:39:18,960
idea of basically the scope what we're

00:39:17,040 --> 00:39:22,240
doing here there are

00:39:18,960 --> 00:39:23,119
about 20 blocks four subsystems at top

00:39:22,240 --> 00:39:26,320
level

00:39:23,119 --> 00:39:28,800
um and the abort support packages

00:39:26,320 --> 00:39:29,440
so of each of the level blocks there are

00:39:28,800 --> 00:39:31,839
00:39:29,440 --> 00:39:34,079
derivations that get evaluated from just

00:39:31,839 --> 00:39:36,240
doing a elaboration the simulator

00:39:34,079 --> 00:39:37,440
um an operation in synthestool doing a

00:39:36,240 --> 00:39:39,680
synthesis to doing

00:39:37,440 --> 00:39:41,119
checking of a little power collateral to

00:39:39,680 --> 00:39:44,640
making sure it needs timing

00:39:41,119 --> 00:39:47,040
to linting do all kinds of stuff um

00:39:44,640 --> 00:39:48,000
the the subsystems have less because

00:39:47,040 --> 00:39:49,599
some of the substances are more

00:39:48,000 --> 00:39:50,960
difficult to synthesize by themselves

00:39:49,599 --> 00:39:52,240
and the chip level has more because

00:39:50,960 --> 00:39:53,119
there are more checks that we need to do

00:39:52,240 --> 00:39:56,720
at the top

00:39:53,119 --> 00:39:58,880
to make sure it all works so um

00:39:56,720 --> 00:39:59,839
yeah that doesn't look very pretty

00:39:58,880 --> 00:40:02,160
actually it's kind of a

00:39:59,839 --> 00:40:04,400
there's a lot of orange red and brown on

00:40:02,160 --> 00:40:04,400
there

00:40:04,640 --> 00:40:08,800
things are in a constant state of not

00:40:07,119 --> 00:40:10,240
working

00:40:08,800 --> 00:40:11,200
but that's okay because if everything

00:40:10,240 --> 00:40:12,480
worked all the time that means you

00:40:11,200 --> 00:40:15,599
should have shipped a while ago

00:40:12,480 --> 00:40:18,000
um uh so

00:40:15,599 --> 00:40:19,359
i'm in the process of open sourcing all

00:40:18,000 --> 00:40:20,480
this stuff i actually have approval from

00:40:19,359 --> 00:40:23,599
the

00:40:20,480 --> 00:40:25,839
from intel to do this um

00:40:23,599 --> 00:40:26,960
which was a presentation that i had to

00:40:25,839 --> 00:40:28,720
make to the

00:40:26,960 --> 00:40:30,160
i'm not sure if you guys know but intel

00:40:28,720 --> 00:40:31,440
i think this year became the

00:40:30,160 --> 00:40:33,599
single largest contributor to linux

00:40:31,440 --> 00:40:35,520
crawl um and

00:40:33,599 --> 00:40:37,680
so we have a lot of people that work on

00:40:35,520 --> 00:40:39,040
linux inside intel which is great they

00:40:37,680 --> 00:40:40,240
turn out to be the most knowledgeable

00:40:39,040 --> 00:40:42,400
people i know about how

00:40:40,240 --> 00:40:44,400
computers work i think it comes from

00:40:42,400 --> 00:40:45,839
having to

00:40:44,400 --> 00:40:46,960
know how good specifications how

00:40:45,839 --> 00:40:49,280
everything works and figure it out

00:40:46,960 --> 00:40:49,280
yourself

00:40:50,560 --> 00:40:54,800
so i i have approval to do this but the

00:40:52,720 --> 00:40:56,079
problem is i have to

00:40:54,800 --> 00:40:58,319
meet a bunch of legal requirements

00:40:56,079 --> 00:41:01,440
saying that i'm not using a

00:40:58,319 --> 00:41:04,079
commercial code or um

00:41:01,440 --> 00:41:05,760
what is this yeah or code that i'm not

00:41:04,079 --> 00:41:06,720
supposed to be that is an incompatible

00:41:05,760 --> 00:41:10,160
license site

00:41:06,720 --> 00:41:12,240
so um nyx packages is

00:41:10,160 --> 00:41:15,040
recentered mit license oh it's nick's

00:41:12,240 --> 00:41:17,680
calendar nit license because it

00:41:15,040 --> 00:41:18,640
it is a runtime user of nyx packages and

00:41:17,680 --> 00:41:20,480
it just kind of

00:41:18,640 --> 00:41:21,680
the suggestion from the the open source

00:41:20,480 --> 00:41:24,079
team was to use

00:41:21,680 --> 00:41:26,800
uh equivalent license to what the

00:41:24,079 --> 00:41:26,800
community is using

00:41:27,760 --> 00:41:30,800
one of the reasons i'm doing this is

00:41:29,200 --> 00:41:32,319
because i i don't

00:41:30,800 --> 00:41:34,480
honestly expect anyone else to pick this

00:41:32,319 --> 00:41:36,319
up immediately but i've noticed that the

00:41:34,480 --> 00:41:38,800
code i commit to next passages gets

00:41:36,319 --> 00:41:40,000
packages gets better like the zfs module

00:41:38,800 --> 00:41:40,800
i contributed i don't know three or four

00:41:40,000 --> 00:41:42,800
years ago

00:41:40,800 --> 00:41:44,240
has subsequently been evolved into

00:41:42,800 --> 00:41:46,240
something better

00:41:44,240 --> 00:41:48,319
because people use it and find ways to

00:41:46,240 --> 00:41:50,160
improve it and that's

00:41:48,319 --> 00:41:51,599
stark contrast to code i commit to

00:41:50,160 --> 00:41:54,880
internal repositories which is

00:41:51,599 --> 00:41:56,319
like rots until it breaks and then

00:41:54,880 --> 00:41:58,880
people get really angry at me instead of

00:41:56,319 --> 00:41:58,880
just fixing it

00:41:59,040 --> 00:42:02,720
the there's a couple of things in here

00:42:01,119 --> 00:42:04,240
that if someone else does use this

00:42:02,720 --> 00:42:06,000
and find a different way to do it it

00:42:04,240 --> 00:42:06,960
makes everyone's life better and that's

00:42:06,000 --> 00:42:08,960
actually

00:42:06,960 --> 00:42:12,079
something intel does a lot which is why

00:42:08,960 --> 00:42:14,319
intel develops linux is even though

00:42:12,079 --> 00:42:15,359
developing linux helps arc intel's

00:42:14,319 --> 00:42:17,520
competitors

00:42:15,359 --> 00:42:19,760
it also makes intel stuff better and it

00:42:17,520 --> 00:42:23,280
makes the entire ecosystem better so

00:42:19,760 --> 00:42:24,400
um it's a another thing is

00:42:23,280 --> 00:42:26,640
we demonstrate we're doing interesting

00:42:24,400 --> 00:42:30,000
things and that's

00:42:26,640 --> 00:42:32,800
important for uh

00:42:30,000 --> 00:42:33,200
site locally because we need good people

00:42:32,800 --> 00:42:35,200
um

00:42:33,200 --> 00:42:36,400
and good people are interested in doing

00:42:35,200 --> 00:42:37,680
interesting things

00:42:36,400 --> 00:42:38,880
so demonstration that we're doing

00:42:37,680 --> 00:42:40,640
interesting things means that you know

00:42:38,880 --> 00:42:42,720
maybe we'll get good applicants

00:42:40,640 --> 00:42:45,839
on that note if anyone will be hiring

00:42:42,720 --> 00:42:45,839
next year so if anyone's

00:42:46,000 --> 00:42:49,440
and i kind of like it it's kind of a bit

00:42:48,160 --> 00:42:50,319
of a special snowflake infrastructure

00:42:49,440 --> 00:42:51,440
right now and i kind of let it grow

00:42:50,319 --> 00:42:54,480
beyond that a bit

00:42:51,440 --> 00:42:55,920
um so

00:42:54,480 --> 00:42:57,680
the other thing i need to do is finish

00:42:55,920 --> 00:42:59,200
open sourcing the next chat i would i

00:42:57,680 --> 00:42:59,599
was planning on doing being done by this

00:42:59,200 --> 00:43:01,200
but i

00:42:59,599 --> 00:43:02,560
had a tape out in the way so i had a lot

00:43:01,200 --> 00:43:04,000
of work to do and i didn't have all the

00:43:02,560 --> 00:43:06,400
time especially to

00:43:04,000 --> 00:43:08,240
analyze this but the big reason was is i

00:43:06,400 --> 00:43:09,280
have to take like 10 hours of training

00:43:08,240 --> 00:43:10,480
to be able to use this course

00:43:09,280 --> 00:43:12,640
code scanning tool and the training is

00:43:10,480 --> 00:43:15,680
only offered every two weeks

00:43:12,640 --> 00:43:17,520
um i want more purity right now there is

00:43:15,680 --> 00:43:20,960
lots of opportunity for

00:43:17,520 --> 00:43:22,800
imperial impurities to come in because

00:43:20,960 --> 00:43:24,800
i'm not even shooting stuff so you could

00:43:22,800 --> 00:43:26,720
just be using

00:43:24,800 --> 00:43:28,240
random files off of people's home

00:43:26,720 --> 00:43:31,280
directories

00:43:28,240 --> 00:43:33,200
uh i would like to there's actually a a

00:43:31,280 --> 00:43:35,040
fairly vibrant community on

00:43:33,200 --> 00:43:36,400
github for doing open source hardware

00:43:35,040 --> 00:43:37,680
projects that probably port a few of

00:43:36,400 --> 00:43:41,040
those using

00:43:37,680 --> 00:43:42,079
github um the i put a higher heel

00:43:41,040 --> 00:43:43,040
constraints in there i'm not going to

00:43:42,079 --> 00:43:47,119
explain what that is

00:43:43,040 --> 00:43:48,880
uh take too long and the next thing i

00:43:47,119 --> 00:43:50,960
would love to be able to do is using the

00:43:48,880 --> 00:43:51,920
update operator to take an environment

00:43:50,960 --> 00:43:53,760
and

00:43:51,920 --> 00:43:55,280
update all the derivations in it to

00:43:53,760 --> 00:43:55,920
based on whatever tools you're using so

00:43:55,280 --> 00:43:57,520
you can

00:43:55,920 --> 00:43:58,960
stitch together whatever tool chain you

00:43:57,520 --> 00:44:01,119
want to be able to use

00:43:58,960 --> 00:44:02,560
um so the for instance environment first

00:44:01,119 --> 00:44:03,200
case is the environment we're kind of

00:44:02,560 --> 00:44:04,560
using which is

00:44:03,200 --> 00:44:05,760
a models images simulator design

00:44:04,560 --> 00:44:06,960
compiler which is a since this tool

00:44:05,760 --> 00:44:08,160
informality which is a formal event

00:44:06,960 --> 00:44:10,640
checking tool

00:44:08,160 --> 00:44:14,079
and you know if you don't have that yep

00:44:10,640 --> 00:44:14,079
i have one side left i think so

00:44:14,160 --> 00:44:17,680
and it'd be nice to be able to use open

00:44:15,359 --> 00:44:22,280
source tools

00:44:17,680 --> 00:44:25,379
so any questions

00:44:22,280 --> 00:44:25,379
[Applause]

00:44:29,790 --> 00:44:32,940
[Applause]

00:44:32,960 --> 00:44:37,839
thank you that was great how easy has it

00:44:36,079 --> 00:44:39,839
been to convince your colleagues to use

00:44:37,839 --> 00:44:42,160
this and get them up to speed on it

00:44:39,839 --> 00:44:45,599
and are you the only person on your team

00:44:42,160 --> 00:44:46,880
using it or is there a whole team

00:44:45,599 --> 00:44:48,960
so there's a couple interesting things

00:44:46,880 --> 00:44:50,160
there and this summer uh

00:44:48,960 --> 00:44:51,359
one nice thing about ringing for intel

00:44:50,160 --> 00:44:52,240
is every seven years you get an eight

00:44:51,359 --> 00:44:54,560
week spedical

00:44:52,240 --> 00:44:56,160
so i got my sabbatical this summer so i

00:44:54,560 --> 00:44:58,000
went on vacation for eight weeks and

00:44:56,160 --> 00:45:01,920
came back and people still using it so

00:44:58,000 --> 00:45:01,920
um it's

00:45:02,839 --> 00:45:07,680
um it turns out that

00:45:05,760 --> 00:45:08,880
because i could do a lot more of this

00:45:07,680 --> 00:45:09,359
stuff and maintain a lot more of this

00:45:08,880 --> 00:45:10,880
stuff

00:45:09,359 --> 00:45:12,160
that with the same amount of effort of

00:45:10,880 --> 00:45:13,119
maintaining once the descripts is broke

00:45:12,160 --> 00:45:13,680
all the time for doing one of these

00:45:13,119 --> 00:45:16,319
steps

00:45:13,680 --> 00:45:17,599
i can maintain this and mix doing like

00:45:16,319 --> 00:45:19,680
30 different steps

00:45:17,599 --> 00:45:21,359
with about the same amount of effort uh

00:45:19,680 --> 00:45:22,400
which means that

00:45:21,359 --> 00:45:23,920
people actually want to use it now

00:45:22,400 --> 00:45:24,800
because they have to do it themselves so

00:45:23,920 --> 00:45:26,880
it's

00:45:24,800 --> 00:45:32,960
a big productivity improvement for me to

00:45:26,880 --> 00:45:35,680
be able to sit on top of doing all this

00:45:32,960 --> 00:45:35,680
any more questions

00:45:40,319 --> 00:45:44,960
is there a technical reason for using

00:45:42,319 --> 00:45:49,440
this old kernel

00:45:44,960 --> 00:45:53,920
for using which this old candle oh

00:45:49,440 --> 00:45:56,240
it's it it's a somewhat unfortunate

00:45:53,920 --> 00:45:57,760
so the the cad tool the eda vendors the

00:45:56,240 --> 00:45:58,319
cad tool people write the cad tools say

00:45:57,760 --> 00:46:01,200
oh

00:45:58,319 --> 00:46:03,119
um arcad tool will only work on red hat

00:46:01,200 --> 00:46:05,359
enterprise linux 3 or something like

00:46:03,119 --> 00:46:07,359
that we're only ever tested on that

00:46:05,359 --> 00:46:09,200
because it turns out that compiling

00:46:07,359 --> 00:46:11,440
software is really hard

00:46:09,200 --> 00:46:12,960
and we don't want to test it anywhere

00:46:11,440 --> 00:46:15,280
else so they don't really want to change

00:46:12,960 --> 00:46:16,880
any of this stuff so what happens is

00:46:15,280 --> 00:46:19,680
speaking of the venn diagrams the only

00:46:16,880 --> 00:46:21,280
venn diagram that all these cad tools

00:46:19,680 --> 00:46:23,680
match is on like one particular version

00:46:21,280 --> 00:46:26,800
of linux which in this case was

00:46:23,680 --> 00:46:28,400
susa 10 or something that went out of

00:46:26,800 --> 00:46:30,240
support four years ago and i'm sure

00:46:28,400 --> 00:46:32,400
intel's paying susa a lot to

00:46:30,240 --> 00:46:34,319
get patches for all the security

00:46:32,400 --> 00:46:43,839
vulnerabilities in the kernel that old

00:46:34,319 --> 00:46:43,839
but um yeah

00:46:44,560 --> 00:46:57,200
any more questions okay

00:46:47,920 --> 00:46:57,200

YouTube URL: https://www.youtube.com/watch?v=0n3cAg0R22c


