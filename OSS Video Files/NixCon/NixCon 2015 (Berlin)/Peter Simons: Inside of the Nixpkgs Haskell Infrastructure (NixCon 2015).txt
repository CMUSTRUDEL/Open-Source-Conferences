Title: Peter Simons: Inside of the Nixpkgs Haskell Infrastructure (NixCon 2015)
Publication date: 2020-10-29
Playlist: NixCon 2015 (Berlin)
Description: 
	
Captions: 
	00:00:05,359 --> 00:00:10,880
okay so the next talk is going to be

00:00:06,960 --> 00:00:10,880
about the haskell infrastructure

00:00:11,519 --> 00:00:17,440
a little back story is that

00:00:14,639 --> 00:00:17,920
i discovered nick's last year because of

00:00:17,440 --> 00:00:20,400
uh

00:00:17,920 --> 00:00:21,439
rock's enthusiasm and then i discovered

00:00:20,400 --> 00:00:23,760
the guy was sitting

00:00:21,439 --> 00:00:24,720
across the table from me was actually

00:00:23,760 --> 00:00:27,599
one of the main

00:00:24,720 --> 00:00:29,039
knicks people namely peter simons so

00:00:27,599 --> 00:00:32,160
peter has been

00:00:29,039 --> 00:00:35,280
working on nyx for seven years now

00:00:32,160 --> 00:00:35,840
and he's gained a lot of fame in the

00:00:35,280 --> 00:00:39,280
last

00:00:35,840 --> 00:00:40,640
month because of his big efforts

00:00:39,280 --> 00:00:42,399
into improving the haskell

00:00:40,640 --> 00:00:43,920
infrastructure

00:00:42,399 --> 00:00:45,840
and that's what he's going to talk about

00:00:43,920 --> 00:00:48,160
today so

00:00:45,840 --> 00:00:50,480
please welcome everybody peter simons

00:00:48,160 --> 00:00:50,480
thank you

00:00:55,760 --> 00:01:00,320
okay the slides for this talk are online

00:00:58,559 --> 00:01:02,160
right now so in case you want to read

00:01:00,320 --> 00:01:04,080
ahead and don't wait until we get to the

00:01:02,160 --> 00:01:07,360
point you can do it

00:01:04,080 --> 00:01:10,320
um i think that right now

00:01:07,360 --> 00:01:12,799
the the haskell users in next packages

00:01:10,320 --> 00:01:16,400
are in a fairly happy place because the

00:01:12,799 --> 00:01:18,080
packages sort of appear mysteriously

00:01:16,400 --> 00:01:19,520
nobody really knows where they come from

00:01:18,080 --> 00:01:21,280
nobody has to worry about

00:01:19,520 --> 00:01:22,799
updating them they are just there and

00:01:21,280 --> 00:01:25,040
they are up to date

00:01:22,799 --> 00:01:26,320
and i want to look in this talk at the

00:01:25,040 --> 00:01:28,560
process that

00:01:26,320 --> 00:01:29,920
gets nix packages into that state how do

00:01:28,560 --> 00:01:31,600
packages end up

00:01:29,920 --> 00:01:33,119
in nix packages and how does the

00:01:31,600 --> 00:01:35,200
machinery work that

00:01:33,119 --> 00:01:36,880
makes this stuff build and make it makes

00:01:35,200 --> 00:01:40,159
it work for the user

00:01:36,880 --> 00:01:41,280
so i'm mostly interested actually in

00:01:40,159 --> 00:01:43,680
interesting aspects of the

00:01:41,280 --> 00:01:45,840
implementation i'm not going to look at

00:01:43,680 --> 00:01:48,159
the user side in a sense of how do you

00:01:45,840 --> 00:01:50,640
install a haskell package how do you

00:01:48,159 --> 00:01:52,960
compose an environment with libraries i

00:01:50,640 --> 00:01:56,479
don't won't cover that at all that's a

00:01:52,960 --> 00:01:59,280
a different talk okay the

00:01:56,479 --> 00:02:00,640
haskell packages when you when you're a

00:01:59,280 --> 00:02:02,079
user of nics and you have an

00:02:00,640 --> 00:02:03,360
installation that involves haskell

00:02:02,079 --> 00:02:05,680
packages then

00:02:03,360 --> 00:02:07,439
these are the the players the entities

00:02:05,680 --> 00:02:08,800
that are involved in getting that stuff

00:02:07,439 --> 00:02:11,200
onto your machine

00:02:08,800 --> 00:02:13,040
obviously a package i have it as a

00:02:11,200 --> 00:02:14,400
separate box there but it's obviously

00:02:13,040 --> 00:02:16,400
part of the internet like

00:02:14,400 --> 00:02:18,319
everything else but what i mean is that

00:02:16,400 --> 00:02:20,720
you have package which is the central

00:02:18,319 --> 00:02:23,520
repository of haskell packages

00:02:20,720 --> 00:02:25,760
so everything that's deemed worthy of

00:02:23,520 --> 00:02:28,400
being published to a worldwide audience

00:02:25,760 --> 00:02:31,680
is typically registered on package

00:02:28,400 --> 00:02:33,920
and then there is a separate ecosystem

00:02:31,680 --> 00:02:36,080
of packages that exist on

00:02:33,920 --> 00:02:38,000
github or sourceforge or whatever kind

00:02:36,080 --> 00:02:39,599
of servers people use where they also

00:02:38,000 --> 00:02:41,680
publish haskell packages

00:02:39,599 --> 00:02:42,800
but they don't necessarily register them

00:02:41,680 --> 00:02:45,200
on hackage

00:02:42,800 --> 00:02:46,640
and when you have nyx package you get

00:02:45,200 --> 00:02:48,800
packages from both

00:02:46,640 --> 00:02:50,800
so you have all of package all that's

00:02:48,800 --> 00:02:51,440
registered in the central repository is

00:02:50,800 --> 00:02:53,920
there

00:02:51,440 --> 00:02:54,560
and you get other package in addition to

00:02:53,920 --> 00:02:57,200
that

00:02:54,560 --> 00:03:00,080
which we pull in from other sources for

00:02:57,200 --> 00:03:03,360
instance the cabal to nyx utility which

00:03:00,080 --> 00:03:04,000
haskell users typically use that's not

00:03:03,360 --> 00:03:05,760
registered

00:03:04,000 --> 00:03:07,200
on hackage that's a tool that's

00:03:05,760 --> 00:03:08,959
specifically for us

00:03:07,200 --> 00:03:10,239
and so there seems to be no point of

00:03:08,959 --> 00:03:14,000
making it available or

00:03:10,239 --> 00:03:17,519
advertising its existence to to everyone

00:03:14,000 --> 00:03:20,400
so the the data flow is like this that

00:03:17,519 --> 00:03:20,959
packages show up on hackage then there

00:03:20,400 --> 00:03:22,879
is

00:03:20,959 --> 00:03:24,480
a separate effort which is called

00:03:22,879 --> 00:03:27,840
stackage which is called

00:03:24,480 --> 00:03:30,480
a stable package and what

00:03:27,840 --> 00:03:31,200
these people do is that they take a

00:03:30,480 --> 00:03:34,159
subset

00:03:31,200 --> 00:03:35,360
of package and make sure that they pick

00:03:34,159 --> 00:03:36,959
versions of all

00:03:35,360 --> 00:03:38,640
the relevant packages that are

00:03:36,959 --> 00:03:40,560
compatible with each other

00:03:38,640 --> 00:03:43,120
every haskell developer knows that that

00:03:40,560 --> 00:03:45,040
you can't just update one single package

00:03:43,120 --> 00:03:46,080
and everything still compiles that's not

00:03:45,040 --> 00:03:48,400
going to work

00:03:46,080 --> 00:03:49,280
because these packages are very

00:03:48,400 --> 00:03:51,040
intricately

00:03:49,280 --> 00:03:53,280
interwoven with each other and if you

00:03:51,040 --> 00:03:54,080
update one then this typically requires

00:03:53,280 --> 00:03:55,840
that you update

00:03:54,080 --> 00:03:57,680
others because they depend on the newer

00:03:55,840 --> 00:03:59,599
version and when you update those

00:03:57,680 --> 00:04:01,040
something else will not compile because

00:03:59,599 --> 00:04:02,159
it hasn't been updated for the new

00:04:01,040 --> 00:04:04,560
versions yet and

00:04:02,159 --> 00:04:05,200
it's a bit of a mess and the stackage

00:04:04,560 --> 00:04:08,000
people

00:04:05,200 --> 00:04:10,400
they resolve that for a subset of

00:04:08,000 --> 00:04:12,959
package and publish essentially a list

00:04:10,400 --> 00:04:14,400
of package names and versions and

00:04:12,959 --> 00:04:16,959
whenever you pick

00:04:14,400 --> 00:04:18,959
a package in that version from that list

00:04:16,959 --> 00:04:19,840
then you know it will work together with

00:04:18,959 --> 00:04:22,720
everything else

00:04:19,840 --> 00:04:24,720
on that list and we take advantage of

00:04:22,720 --> 00:04:28,080
these efforts to provide a

00:04:24,720 --> 00:04:30,479
stable user experience okay

00:04:28,080 --> 00:04:32,800
so we get packages directly from package

00:04:30,479 --> 00:04:34,560
we have obviously all of package not

00:04:32,800 --> 00:04:36,000
just the packages that are in stackage

00:04:34,560 --> 00:04:38,160
we have the rest too

00:04:36,000 --> 00:04:39,919
but from stackage we take the additional

00:04:38,160 --> 00:04:42,720
version of version information

00:04:39,919 --> 00:04:44,479
then we take additional packages from

00:04:42,720 --> 00:04:46,720
other places in the internet

00:04:44,479 --> 00:04:48,800
and we provide that inix packages to the

00:04:46,720 --> 00:04:50,800
user who then has the ability to

00:04:48,800 --> 00:04:53,600
configure local overrides

00:04:50,800 --> 00:04:54,240
at his own local packages add packages

00:04:53,600 --> 00:04:56,720
from

00:04:54,240 --> 00:04:58,560
we don't even know about to his his

00:04:56,720 --> 00:05:00,560
installation and use them within x all

00:04:58,560 --> 00:05:04,240
nicely integrated

00:05:00,560 --> 00:05:11,840
the process is

00:05:04,240 --> 00:05:11,840
pretty obvious

00:05:12,160 --> 00:05:18,000
so it works like this um

00:05:15,440 --> 00:05:18,639
a publish shows up on package from there

00:05:18,000 --> 00:05:22,160
it goes

00:05:18,639 --> 00:05:24,560
into this stackage arena which has

00:05:22,160 --> 00:05:25,919
one repository that's called all kabal

00:05:24,560 --> 00:05:28,560
hashes and that's

00:05:25,919 --> 00:05:30,880
a git repository that contains all of

00:05:28,560 --> 00:05:32,639
package but it's versioned in git

00:05:30,880 --> 00:05:34,400
you have to know that hackage does not

00:05:32,639 --> 00:05:36,000
provide that package does not provide

00:05:34,400 --> 00:05:37,759
any kind of

00:05:36,000 --> 00:05:39,840
versioning or anything like that they

00:05:37,759 --> 00:05:42,160
have this one tarball which contains

00:05:39,840 --> 00:05:44,240
everything they have and there you go

00:05:42,160 --> 00:05:46,160
and if you have this all cabal hashes

00:05:44,240 --> 00:05:48,160
repository that continuously

00:05:46,160 --> 00:05:49,199
downloads this tarball checks in the

00:05:48,160 --> 00:05:50,960
differences

00:05:49,199 --> 00:05:52,560
and so you have a git repository where

00:05:50,960 --> 00:05:53,680
you can actually see a bit of the

00:05:52,560 --> 00:05:56,319
history of

00:05:53,680 --> 00:05:58,479
when a package was added when a package

00:05:56,319 --> 00:06:00,400
was edited these kind of things

00:05:58,479 --> 00:06:02,639
are visible in that git repository but

00:06:00,400 --> 00:06:05,039
they are not visible on package

00:06:02,639 --> 00:06:06,000
so it's a service edited on top but it's

00:06:05,039 --> 00:06:09,039
essentially just

00:06:06,000 --> 00:06:11,120
hackage in the git repository another

00:06:09,039 --> 00:06:13,520
nice feature that they add is that they

00:06:11,120 --> 00:06:14,160
download all those tables and compute

00:06:13,520 --> 00:06:16,400
the

00:06:14,160 --> 00:06:17,840
sha hashes for those and add them into

00:06:16,400 --> 00:06:19,680
the repository

00:06:17,840 --> 00:06:21,440
so when we generate build instructions

00:06:19,680 --> 00:06:22,960
we don't have to download the packages

00:06:21,440 --> 00:06:24,720
to figure out those hashes

00:06:22,960 --> 00:06:26,400
but they are in there already i'll show

00:06:24,720 --> 00:06:29,120
you how it looks

00:06:26,400 --> 00:06:31,360
so that's the basis that the stackage

00:06:29,120 --> 00:06:34,639
people use to do their work and then

00:06:31,360 --> 00:06:37,280
every day they do a snapshot the

00:06:34,639 --> 00:06:39,280
stackage nightly snapshot they call it

00:06:37,280 --> 00:06:41,199
where they basically update everything

00:06:39,280 --> 00:06:43,840
to the latest version that they can

00:06:41,199 --> 00:06:45,039
then try to compile that then they run

00:06:43,840 --> 00:06:46,400
into errors and see

00:06:45,039 --> 00:06:48,160
this doesn't compile this doesn't

00:06:46,400 --> 00:06:51,440
compile and then they'll manually

00:06:48,160 --> 00:06:53,520
configure okay don't use this update yet

00:06:51,440 --> 00:06:56,080
or use this update but specify

00:06:53,520 --> 00:06:57,759
some special flag or disable the test

00:06:56,080 --> 00:06:59,759
suit or

00:06:57,759 --> 00:07:01,840
somehow mess with the build to make it

00:06:59,759 --> 00:07:03,840
work and then at the end of that process

00:07:01,840 --> 00:07:04,319
when everything compiles comes out this

00:07:03,840 --> 00:07:07,120
list

00:07:04,319 --> 00:07:08,080
of names and versions that is a nightly

00:07:07,120 --> 00:07:11,039
snapshot

00:07:08,080 --> 00:07:13,039
which is the most recent stable package

00:07:11,039 --> 00:07:15,280
set that you can get

00:07:13,039 --> 00:07:16,160
then there is on the same source there

00:07:15,280 --> 00:07:18,720
is another

00:07:16,160 --> 00:07:20,240
basically family of package sets which

00:07:18,720 --> 00:07:23,039
is the long term support

00:07:20,240 --> 00:07:25,039
haskell lts haskell package sets and

00:07:23,039 --> 00:07:27,520
these work like so

00:07:25,039 --> 00:07:28,560
they typically whenever a new compiler

00:07:27,520 --> 00:07:30,639
version comes out

00:07:28,560 --> 00:07:32,720
they start a new lts package set and

00:07:30,639 --> 00:07:35,919
then they call it lts packages

00:07:32,720 --> 00:07:37,440
3.0 and then they pick the latest

00:07:35,919 --> 00:07:39,199
versions from their nightly build

00:07:37,440 --> 00:07:41,520
whatever they have right now

00:07:39,199 --> 00:07:43,120
and then continuously every week they

00:07:41,520 --> 00:07:45,520
release a new version

00:07:43,120 --> 00:07:46,560
of that package set and they include

00:07:45,520 --> 00:07:49,680
only minor

00:07:46,560 --> 00:07:52,000
updates that don't break the api so when

00:07:49,680 --> 00:07:54,160
a new package comes out that changes the

00:07:52,000 --> 00:07:56,639
the interface of the library it will

00:07:54,160 --> 00:07:59,840
never end up in that package set

00:07:56,639 --> 00:08:00,879
so you as a user can say i follow this

00:07:59,840 --> 00:08:02,720
package set

00:08:00,879 --> 00:08:05,039
and i have production software that

00:08:02,720 --> 00:08:07,440
depends on the contents of those those

00:08:05,039 --> 00:08:09,840
those libraries then you will never get

00:08:07,440 --> 00:08:11,599
an update that requires you to modify

00:08:09,840 --> 00:08:13,599
your software in order to build right

00:08:11,599 --> 00:08:16,000
you have a stable api but if someone

00:08:13,599 --> 00:08:18,160
fixes a bug or fixes a security

00:08:16,000 --> 00:08:20,560
vulnerability in a way that's not

00:08:18,160 --> 00:08:21,919
exposed in the api then you will get

00:08:20,560 --> 00:08:23,840
that update

00:08:21,919 --> 00:08:26,000
so you're not stuck on a fixed version

00:08:23,840 --> 00:08:29,280
but you have stable updates

00:08:26,000 --> 00:08:32,000
right which is the the idea okay

00:08:29,280 --> 00:08:33,599
so these two build products the the

00:08:32,000 --> 00:08:36,560
stackage nightly and this

00:08:33,599 --> 00:08:38,479
family of package sets they all live in

00:08:36,560 --> 00:08:40,880
git repositories too

00:08:38,479 --> 00:08:42,640
and these are huge json files that

00:08:40,880 --> 00:08:44,399
basically say for every package

00:08:42,640 --> 00:08:46,720
this is the version you ought to choose

00:08:44,399 --> 00:08:48,959
these are the flags you ought to specify

00:08:46,720 --> 00:08:50,640
run the test suite yes no build ahead of

00:08:48,959 --> 00:08:53,120
documentation yes no

00:08:50,640 --> 00:08:53,680
all the information is in there and then

00:08:53,120 --> 00:08:56,720
we have

00:08:53,680 --> 00:08:58,880
a tool called hackage2nix

00:08:56,720 --> 00:09:01,760
which consumes all of this so it

00:08:58,880 --> 00:09:03,839
consumes the entire package repository

00:09:01,760 --> 00:09:06,080
it consumes the build information from

00:09:03,839 --> 00:09:09,519
the nightly snapshot and from the lts

00:09:06,080 --> 00:09:11,680
haskell snapshots and then it allocates

00:09:09,519 --> 00:09:12,640
some 30 gigabytes of memory because it's

00:09:11,680 --> 00:09:14,800
a haskell program

00:09:12,640 --> 00:09:16,320
and you are not a serious headquarter

00:09:14,800 --> 00:09:19,360
program if you don't allocate 30

00:09:16,320 --> 00:09:19,360
gigabytes of memory

00:09:20,800 --> 00:09:25,440
and then it writes a whole bunch of

00:09:22,720 --> 00:09:26,399
files into the the file system into the

00:09:25,440 --> 00:09:29,360
next package

00:09:26,399 --> 00:09:30,560
repository which contains these and

00:09:29,360 --> 00:09:32,240
there are

00:09:30,560 --> 00:09:34,000
obviously the one on top right the

00:09:32,240 --> 00:09:36,080
hackage packages.nx and these

00:09:34,000 --> 00:09:38,399
configuration files down at the top

00:09:36,080 --> 00:09:41,279
so those are generated by package to nyx

00:09:38,399 --> 00:09:44,399
these are automatically generated

00:09:41,279 --> 00:09:46,399
the hackage packages.nyx contains build

00:09:44,399 --> 00:09:47,120
instructions for every package that we

00:09:46,399 --> 00:09:49,600
contain

00:09:47,120 --> 00:09:50,240
so it's built instructions for every

00:09:49,600 --> 00:09:52,720
package

00:09:50,240 --> 00:09:54,800
almost every hackage package then there

00:09:52,720 --> 00:09:57,760
is a common configuration

00:09:54,800 --> 00:09:58,320
which modifies the build instructions in

00:09:57,760 --> 00:10:01,279
there with

00:09:58,320 --> 00:10:02,880
fixes so that stuff works that the auto

00:10:01,279 --> 00:10:04,000
generating tool doesn't know how to

00:10:02,880 --> 00:10:06,959
generate it correctly

00:10:04,000 --> 00:10:08,240
for some reason then there is another

00:10:06,959 --> 00:10:11,040
configuration layer

00:10:08,240 --> 00:10:12,720
which applies fixes that are required if

00:10:11,040 --> 00:10:15,360
you're building this package with a

00:10:12,720 --> 00:10:18,720
particular version of ghc

00:10:15,360 --> 00:10:21,279
and then finally there is the last

00:10:18,720 --> 00:10:21,839
step which configures the versions that

00:10:21,279 --> 00:10:23,920
you see

00:10:21,839 --> 00:10:25,920
in those package sets so that they match

00:10:23,920 --> 00:10:29,839
the specification from the lts

00:10:25,920 --> 00:10:32,720
haskell package set now users

00:10:29,839 --> 00:10:34,560
they basically cannot install any of

00:10:32,720 --> 00:10:36,399
this stuff directly it's not possible

00:10:34,560 --> 00:10:37,760
you can install the executables

00:10:36,399 --> 00:10:40,079
that's possible but if you have a

00:10:37,760 --> 00:10:41,760
haskell library you can't basically say

00:10:40,079 --> 00:10:44,560
yeah install this library and then you

00:10:41,760 --> 00:10:47,600
use it it's not feasible what you do is

00:10:44,560 --> 00:10:49,360
you build this ghc with packages

00:10:47,600 --> 00:10:51,600
environment in which you specify

00:10:49,360 --> 00:10:54,320
these other libraries i want to have and

00:10:51,600 --> 00:10:56,320
then nix builds you a ghc binary that

00:10:54,320 --> 00:10:57,200
knows exactly those libraries that you

00:10:56,320 --> 00:10:59,519
want

00:10:57,200 --> 00:11:00,320
and the place where you configure that

00:10:59,519 --> 00:11:03,760
is this

00:11:00,320 --> 00:11:06,480
overrides attribute set which is in your

00:11:03,760 --> 00:11:08,880
config.nix file in your home directory

00:11:06,480 --> 00:11:09,760
so there you choose packages either from

00:11:08,880 --> 00:11:11,760
the ghc

00:11:09,760 --> 00:11:13,279
specific package set or from the its

00:11:11,760 --> 00:11:15,600
specific package set

00:11:13,279 --> 00:11:16,959
and then you can optionally pull in

00:11:15,600 --> 00:11:18,560
additional packages

00:11:16,959 --> 00:11:20,560
where you generate instructions with

00:11:18,560 --> 00:11:22,720
cabal to nyx automatically

00:11:20,560 --> 00:11:24,399
and then this whole process ends up in a

00:11:22,720 --> 00:11:25,519
place where you can install it and then

00:11:24,399 --> 00:11:28,079
you have

00:11:25,519 --> 00:11:31,040
pretty much the entire haskell ecosystem

00:11:28,079 --> 00:11:31,040
at your fingertips

00:11:31,200 --> 00:11:36,240
so hackage um in the rest of the

00:11:34,640 --> 00:11:38,720
presentation i'm basically going

00:11:36,240 --> 00:11:39,839
through those boxes each one by one

00:11:38,720 --> 00:11:43,360
right

00:11:39,839 --> 00:11:47,040
so hackage it contains over 60 000

00:11:43,360 --> 00:11:48,160
cabal files which group into about 9000

00:11:47,040 --> 00:11:50,720
packages

00:11:48,160 --> 00:11:52,800
so this means that on average every

00:11:50,720 --> 00:11:53,839
package releases approximately nine

00:11:52,800 --> 00:11:56,560
versions

00:11:53,839 --> 00:11:58,639
seven versions there is this this box

00:11:56,560 --> 00:12:01,760
plot shows you that half of all

00:11:58,639 --> 00:12:03,760
packages lie within this range so

00:12:01,760 --> 00:12:05,120
if you take any random package from

00:12:03,760 --> 00:12:06,800
hacker chances

00:12:05,120 --> 00:12:08,800
are that it will have between two and

00:12:06,800 --> 00:12:11,519
eight versions released

00:12:08,800 --> 00:12:11,920
so there are some packages that rare

00:12:11,519 --> 00:12:15,120
that

00:12:11,920 --> 00:12:16,959
release 150 releases by now

00:12:15,120 --> 00:12:18,560
so they release i don't know once a week

00:12:16,959 --> 00:12:20,639
or something like that and there are

00:12:18,560 --> 00:12:22,639
packages that release a new version

00:12:20,639 --> 00:12:24,639
every couple of months and many never

00:12:22,639 --> 00:12:26,959
ever release a version

00:12:24,639 --> 00:12:28,480
a new version they have to have at least

00:12:26,959 --> 00:12:31,279
one otherwise they wouldn't be there

00:12:28,480 --> 00:12:32,480
right so the git repository that

00:12:31,279 --> 00:12:36,399
contains package

00:12:32,480 --> 00:12:38,480
is just a long long list of directories

00:12:36,399 --> 00:12:39,519
the directory always matches the name of

00:12:38,480 --> 00:12:41,279
the package

00:12:39,519 --> 00:12:42,800
in every directory you have another

00:12:41,279 --> 00:12:44,560
directory which matches

00:12:42,800 --> 00:12:46,160
the version number of the release and

00:12:44,560 --> 00:12:48,000
inside of the directory you have the

00:12:46,160 --> 00:12:49,040
kabal file which contains the build

00:12:48,000 --> 00:12:51,279
instructions

00:12:49,040 --> 00:12:52,560
and you have a json file which is added

00:12:51,279 --> 00:12:55,360
from by stackage

00:12:52,560 --> 00:12:56,639
which contains the hashes and these

00:12:55,360 --> 00:12:59,440
cabal files

00:12:56,639 --> 00:13:00,639
they look like this you have this

00:12:59,440 --> 00:13:03,680
general section

00:13:00,639 --> 00:13:05,920
which defines you see it right your home

00:13:03,680 --> 00:13:08,320
page the version number the package name

00:13:05,920 --> 00:13:10,480
general information about the package

00:13:08,320 --> 00:13:11,600
and then the components of the the

00:13:10,480 --> 00:13:13,680
package are defined

00:13:11,600 --> 00:13:14,880
below that you can define a library you

00:13:13,680 --> 00:13:17,440
can define

00:13:14,880 --> 00:13:20,079
executables you can define benchmarks

00:13:17,440 --> 00:13:23,040
test suits and they all have the same

00:13:20,079 --> 00:13:24,480
syntax and the same structure so

00:13:23,040 --> 00:13:26,959
typically if you have a library you

00:13:24,480 --> 00:13:28,000
define what publicly visible modules you

00:13:26,959 --> 00:13:29,839
expose

00:13:28,000 --> 00:13:31,040
you define what other packages you

00:13:29,839 --> 00:13:34,320
depend on and

00:13:31,040 --> 00:13:36,160
this here is uh the part that

00:13:34,320 --> 00:13:37,600
makes installing haskell packages so

00:13:36,160 --> 00:13:40,880
much fun

00:13:37,600 --> 00:13:43,600
you can very accurately restrict

00:13:40,880 --> 00:13:44,880
the versions of your dependencies so you

00:13:43,600 --> 00:13:47,199
can say

00:13:44,880 --> 00:13:48,959
in this case i want the base library

00:13:47,199 --> 00:13:52,399
only if it's

00:13:48,959 --> 00:13:54,800
older than version six so

00:13:52,399 --> 00:13:56,639
this is a convention in in haskell

00:13:54,800 --> 00:13:58,079
ecosystem you can't upload

00:13:56,639 --> 00:13:59,680
a package to hackage unless you

00:13:58,079 --> 00:14:03,600
configure that

00:13:59,680 --> 00:14:06,320
and okay but from my point of view

00:14:03,600 --> 00:14:07,360
why do you do that what why why does why

00:14:06,320 --> 00:14:10,320
do you say

00:14:07,360 --> 00:14:12,959
yeah if it's base version fine f5 then

00:14:10,320 --> 00:14:15,519
let okay compile but if it's version six

00:14:12,959 --> 00:14:16,560
it doesn't exist it's not there there is

00:14:15,519 --> 00:14:19,680
no version 6.

00:14:16,560 --> 00:14:21,519
then don't compile you have no idea

00:14:19,680 --> 00:14:24,079
whether version 6 is actually going to

00:14:21,519 --> 00:14:26,880
cause any problems or not

00:14:24,079 --> 00:14:27,839
but that's reason enough for them to say

00:14:26,880 --> 00:14:30,240
since we don't

00:14:27,839 --> 00:14:33,839
know that it will work will prevent you

00:14:30,240 --> 00:14:33,839
from using it just to be sure

00:14:36,880 --> 00:14:41,040
and since everybody does that and most

00:14:39,279 --> 00:14:42,959
people actually don't understand the

00:14:41,040 --> 00:14:44,800
implications of that right people have

00:14:42,959 --> 00:14:47,440
no idea what versions to choose

00:14:44,800 --> 00:14:49,199
if you have 10 dependencies and each of

00:14:47,440 --> 00:14:50,240
those dependencies has four different

00:14:49,199 --> 00:14:53,279
versions

00:14:50,240 --> 00:14:55,360
then you have a huge permutation of

00:14:53,279 --> 00:14:56,000
trees or things that you would have to

00:14:55,360 --> 00:14:57,360
test

00:14:56,000 --> 00:15:00,079
in order to have an accurate

00:14:57,360 --> 00:15:01,920
specification that reflects reality

00:15:00,079 --> 00:15:04,160
but obviously you can't do that so what

00:15:01,920 --> 00:15:05,760
people will do is yeah i restricted to

00:15:04,160 --> 00:15:07,199
the version i've been using and it's

00:15:05,760 --> 00:15:09,440
fine

00:15:07,199 --> 00:15:11,360
and so when people update the base

00:15:09,440 --> 00:15:13,360
library or transformers library or

00:15:11,360 --> 00:15:13,839
whatever then all those bills are going

00:15:13,360 --> 00:15:15,440
to say

00:15:13,839 --> 00:15:17,600
i won't compile because you have the

00:15:15,440 --> 00:15:19,680
wrong version and they would compile

00:15:17,600 --> 00:15:21,440
just fine if the restriction hadn't been

00:15:19,680 --> 00:15:25,360
there in the first place

00:15:21,440 --> 00:15:28,480
but they decided to arrow on the side of

00:15:25,360 --> 00:15:31,040
caution there is

00:15:28,480 --> 00:15:33,680
another important thing it's this line

00:15:31,040 --> 00:15:36,160
here it says that this is a simple build

00:15:33,680 --> 00:15:37,519
a simple build means that this build

00:15:36,160 --> 00:15:40,000
configuration is actually

00:15:37,519 --> 00:15:40,639
entirely declarative so this is a text

00:15:40,000 --> 00:15:42,560
file

00:15:40,639 --> 00:15:45,120
there's no code there's no code ever

00:15:42,560 --> 00:15:46,880
being executed and just by parsing

00:15:45,120 --> 00:15:48,560
that file we know everything about the

00:15:46,880 --> 00:15:51,040
build that there is to know

00:15:48,560 --> 00:15:52,720
which is extremely convenient if you

00:15:51,040 --> 00:15:54,320
want to translate these things into

00:15:52,720 --> 00:15:56,079
nick's instructions

00:15:54,320 --> 00:15:57,600
there is another build type which is

00:15:56,079 --> 00:15:59,279
called custom

00:15:57,600 --> 00:16:01,120
and when you have that build type then

00:15:59,279 --> 00:16:04,320
basically all bets are off

00:16:01,120 --> 00:16:06,160
what that means is that you ship an

00:16:04,320 --> 00:16:10,000
executable program the source code for

00:16:06,160 --> 00:16:12,079
an executable program called setup.hs

00:16:10,000 --> 00:16:13,040
and the haskell build system will

00:16:12,079 --> 00:16:15,120
compile that

00:16:13,040 --> 00:16:16,240
and run that to configure the build and

00:16:15,120 --> 00:16:18,399
do the build

00:16:16,240 --> 00:16:20,720
so at that point you can declare in the

00:16:18,399 --> 00:16:22,320
file basically whatever you want

00:16:20,720 --> 00:16:24,240
and then you can have the program do

00:16:22,320 --> 00:16:26,800
whatever it wants and those two things

00:16:24,240 --> 00:16:29,120
don't have to be related

00:16:26,800 --> 00:16:30,800
so basically when you have a custom

00:16:29,120 --> 00:16:34,320
build type there is no way

00:16:30,800 --> 00:16:37,120
to extract the information about the

00:16:34,320 --> 00:16:40,160
build from the file that you need

00:16:37,120 --> 00:16:41,920
that's bad for nics the good news is

00:16:40,160 --> 00:16:44,000
that the interface to this kind of

00:16:41,920 --> 00:16:45,920
custom build system is so complicated

00:16:44,000 --> 00:16:50,720
and so poorly documented

00:16:45,920 --> 00:16:52,639
that nobody ever uses it

00:16:50,720 --> 00:16:54,800
and if they use it they use it for like

00:16:52,639 --> 00:16:56,959
super super simple things like i want to

00:16:54,800 --> 00:16:58,720
add an additional compiler flag on the

00:16:56,959 --> 00:17:00,079
command line somewhere and that doesn't

00:16:58,720 --> 00:17:02,160
affect us so it's fine

00:17:00,079 --> 00:17:04,240
right but if they would do something

00:17:02,160 --> 00:17:06,640
that would affect us like we add

00:17:04,240 --> 00:17:09,120
additional dependencies or we make the

00:17:06,640 --> 00:17:10,880
existence of a dependency depend on some

00:17:09,120 --> 00:17:14,799
property of the system or not then we

00:17:10,880 --> 00:17:14,799
would have no way of figuring that out

00:17:15,280 --> 00:17:19,760
so this is the other file which is

00:17:17,280 --> 00:17:21,760
fairly obvious right it's just uh

00:17:19,760 --> 00:17:23,520
and there's are these tables which

00:17:21,760 --> 00:17:25,439
contain the software and then we have a

00:17:23,520 --> 00:17:28,000
whole bunch of hashes for those

00:17:25,439 --> 00:17:31,120
and we need them to generate the nyx

00:17:28,000 --> 00:17:34,720
expression which looks like this

00:17:31,120 --> 00:17:36,080
so this is essentially meta information

00:17:34,720 --> 00:17:38,240
we could do without that

00:17:36,080 --> 00:17:40,320
so we can describe that build

00:17:38,240 --> 00:17:43,600
essentially in those three lines

00:17:40,320 --> 00:17:45,200
that's all you need obviously we need um

00:17:43,600 --> 00:17:46,559
the package name the version and we need

00:17:45,200 --> 00:17:48,720
the hash of the

00:17:46,559 --> 00:17:50,240
tarball and then we have to specify the

00:17:48,720 --> 00:17:52,559
dependencies

00:17:50,240 --> 00:17:54,880
we distinguish between dependencies of

00:17:52,559 --> 00:17:57,200
the library components of the executable

00:17:54,880 --> 00:17:59,039
components and of the test components

00:17:57,200 --> 00:18:01,919
the reason why we do that is that when

00:17:59,039 --> 00:18:04,400
you run the build and you disable tests

00:18:01,919 --> 00:18:07,120
then we don't need the dependencies that

00:18:04,400 --> 00:18:09,200
are required purely for the test suit

00:18:07,120 --> 00:18:10,880
so we specify them separately and if you

00:18:09,200 --> 00:18:12,960
run the build without tests then the

00:18:10,880 --> 00:18:15,280
test dependencies will not be included

00:18:12,960 --> 00:18:17,280
and they won't be required which is why

00:18:15,280 --> 00:18:20,000
a lot of haskibles can be fixed

00:18:17,280 --> 00:18:22,160
by disabling the test suit because often

00:18:20,000 --> 00:18:23,919
times people update their software to

00:18:22,160 --> 00:18:25,840
cope with the new versions

00:18:23,919 --> 00:18:27,280
but they don't run their own test suit

00:18:25,840 --> 00:18:28,080
and they don't update their own test

00:18:27,280 --> 00:18:30,320
suit

00:18:28,080 --> 00:18:31,600
and then we run their test suit and say

00:18:30,320 --> 00:18:33,919
yeah man

00:18:31,600 --> 00:18:35,679
you haven't updated the test suit and

00:18:33,919 --> 00:18:38,080
then we just disable it and it

00:18:35,679 --> 00:18:42,320
still works right but it's uh they

00:18:38,080 --> 00:18:44,559
should probably have a good ci system

00:18:42,320 --> 00:18:45,600
there are a couple of things in package

00:18:44,559 --> 00:18:49,280
that make

00:18:45,600 --> 00:18:51,679
the packaging process very interesting

00:18:49,280 --> 00:18:53,039
one of the extremely nice features is

00:18:51,679 --> 00:18:55,600
destructive editing

00:18:53,039 --> 00:18:56,799
so what you can do is you upload a tar

00:18:55,600 --> 00:18:59,360
ball to hackage

00:18:56,799 --> 00:19:00,880
and that contains the kabal file plus

00:18:59,360 --> 00:19:01,919
all the source code that's the entire

00:19:00,880 --> 00:19:04,480
package

00:19:01,919 --> 00:19:05,039
and then you can go to the website and

00:19:04,480 --> 00:19:08,080
edit

00:19:05,039 --> 00:19:09,200
the kabal file and change it and what

00:19:08,080 --> 00:19:11,679
happens is that

00:19:09,200 --> 00:19:13,440
it's not going to get a new release but

00:19:11,679 --> 00:19:16,720
it's edited in place

00:19:13,440 --> 00:19:20,160
so the version changes so they did that

00:19:16,720 --> 00:19:22,799
then they realized gee this changes the

00:19:20,160 --> 00:19:24,400
hash of our release tarball this is bad

00:19:22,799 --> 00:19:26,000
and lots of people would complain about

00:19:24,400 --> 00:19:27,760
that so what they do is when you

00:19:26,000 --> 00:19:30,799
download the release tarball

00:19:27,760 --> 00:19:32,720
you get the old version and then

00:19:30,799 --> 00:19:34,160
you look into the cabal file and see

00:19:32,720 --> 00:19:36,400
that there is this x

00:19:34,160 --> 00:19:38,480
minus revision header and if it's there

00:19:36,400 --> 00:19:40,400
then this tells you that there is a new

00:19:38,480 --> 00:19:42,799
cabal file which you download

00:19:40,400 --> 00:19:45,120
extra and replace the existing one with

00:19:42,799 --> 00:19:45,120
that

00:19:45,440 --> 00:19:50,880
the good obviously there is nothing in

00:19:49,200 --> 00:19:52,880
place that prevents people from

00:19:50,880 --> 00:19:55,440
including that line in their cabal file

00:19:52,880 --> 00:19:57,840
when they upload in the first place

00:19:55,440 --> 00:19:59,600
which just breaks oh i think they fixed

00:19:57,840 --> 00:20:00,559
it by now but it broke a lot of software

00:19:59,600 --> 00:20:02,159
obviously

00:20:00,559 --> 00:20:04,720
the second thing is that this revision

00:20:02,159 --> 00:20:07,600
number it doesn't show up anywhere

00:20:04,720 --> 00:20:09,039
so when you install the package then you

00:20:07,600 --> 00:20:11,120
go to the website and see

00:20:09,039 --> 00:20:13,520
okay the build has been edited in some

00:20:11,120 --> 00:20:15,520
way right then there is no way to tell

00:20:13,520 --> 00:20:18,960
whether the version that you installed

00:20:15,520 --> 00:20:18,960
is the new one or the old one

00:20:19,440 --> 00:20:23,280
for nix obviously this is a bit of a

00:20:21,520 --> 00:20:26,159
nightmare so what we do

00:20:23,280 --> 00:20:26,720
is that we track this revision number we

00:20:26,159 --> 00:20:28,640
needed

00:20:26,720 --> 00:20:30,559
the revision number only to construct

00:20:28,640 --> 00:20:31,440
the url for the kabal file we don't use

00:20:30,559 --> 00:20:33,679
that information

00:20:31,440 --> 00:20:34,960
otherwise and we have the hash of the

00:20:33,679 --> 00:20:37,840
new cabal file

00:20:34,960 --> 00:20:39,760
and when you have a destructive edit um

00:20:37,840 --> 00:20:41,600
taking place then the build log will say

00:20:39,760 --> 00:20:42,880
something at the beginning okay i have a

00:20:41,600 --> 00:20:44,960
new kabul file

00:20:42,880 --> 00:20:46,559
and then this is downloaded and replaced

00:20:44,960 --> 00:20:48,720
and then

00:20:46,559 --> 00:20:50,720
yeah then you have in place editing

00:20:48,720 --> 00:20:51,520
because just making a new release would

00:20:50,720 --> 00:20:55,280
have been

00:20:51,520 --> 00:20:57,679
more difficult i suppose there is

00:20:55,280 --> 00:21:00,000
another nice feature and this is a

00:20:57,679 --> 00:21:03,280
particularly extreme example

00:21:00,000 --> 00:21:05,520
you can have all all the items in a

00:21:03,280 --> 00:21:08,000
cabal file can depend on things

00:21:05,520 --> 00:21:10,000
and make choices conditionally on the

00:21:08,000 --> 00:21:11,360
value of those things you can

00:21:10,000 --> 00:21:13,600
configure your build differently

00:21:11,360 --> 00:21:16,320
depending on whether you compile with a

00:21:13,600 --> 00:21:17,840
new or an old version of ghc you can

00:21:16,320 --> 00:21:19,679
change your behavior on the operating

00:21:17,840 --> 00:21:21,840
system right for instance here

00:21:19,679 --> 00:21:23,600
you say okay if i'm a windows build then

00:21:21,840 --> 00:21:26,880
i won't need that but if i'm not a

00:21:23,600 --> 00:21:30,159
windows build then i need that library

00:21:26,880 --> 00:21:32,480
and obviously this

00:21:30,159 --> 00:21:33,440
makes the interpretation of these files

00:21:32,480 --> 00:21:35,360
a little

00:21:33,440 --> 00:21:37,760
less straightforward because when we

00:21:35,360 --> 00:21:40,799
generate the build extractions

00:21:37,760 --> 00:21:42,880
the right choice would be to say okay we

00:21:40,799 --> 00:21:45,600
pass all those conditional trees

00:21:42,880 --> 00:21:47,520
and then we do some cool optimizing and

00:21:45,600 --> 00:21:50,080
filter out things that don't affect us

00:21:47,520 --> 00:21:52,080
and then we generate build extractions

00:21:50,080 --> 00:21:54,080
expressions that um cover those

00:21:52,080 --> 00:21:56,559
conditionals right we say

00:21:54,080 --> 00:21:58,000
if i am on system linox then add these

00:21:56,559 --> 00:21:59,440
dependencies and if i'm

00:21:58,000 --> 00:22:01,039
a system darwin then add these

00:21:59,440 --> 00:22:01,600
dependencies and we would basically

00:22:01,039 --> 00:22:04,080
capture

00:22:01,600 --> 00:22:05,919
capture that in nics it's just that

00:22:04,080 --> 00:22:09,760
doing that is actually

00:22:05,919 --> 00:22:12,240
difficult and so we don't what we do is

00:22:09,760 --> 00:22:13,520
we assume all bills run on linux using

00:22:12,240 --> 00:22:15,440
the latest ghc

00:22:13,520 --> 00:22:16,559
then we resolve all those conditionals

00:22:15,440 --> 00:22:18,640
and these are the build instructions

00:22:16,559 --> 00:22:22,080
that we generate

00:22:18,640 --> 00:22:24,640
so this means that we have builds that

00:22:22,080 --> 00:22:26,000
work fine on linux but if you run the

00:22:24,640 --> 00:22:29,120
exact same build on darwin

00:22:26,000 --> 00:22:30,880
it's not going to succeed fortunately

00:22:29,120 --> 00:22:33,280
these cases are rare

00:22:30,880 --> 00:22:34,320
and so rather than fixing our generator

00:22:33,280 --> 00:22:37,200
which is hard

00:22:34,320 --> 00:22:38,960
we added this level of configuration

00:22:37,200 --> 00:22:40,240
which i showed you right this config

00:22:38,960 --> 00:22:43,120
command where you can

00:22:40,240 --> 00:22:44,720
add build dependencies and mess with the

00:22:43,120 --> 00:22:47,120
built expressions in a

00:22:44,720 --> 00:22:49,039
manually edited way and we do that for

00:22:47,120 --> 00:22:49,679
most of the packages that need it and

00:22:49,039 --> 00:22:52,080
it's

00:22:49,679 --> 00:22:54,480
not that many fortunately but anyway

00:22:52,080 --> 00:22:57,200
this is an area where the

00:22:54,480 --> 00:22:58,320
cabal to nyx tool essentially has to be

00:22:57,200 --> 00:23:00,240
improved that it

00:22:58,320 --> 00:23:01,840
expresses this kind of intelligence in

00:23:00,240 --> 00:23:03,520
the build

00:23:01,840 --> 00:23:06,240
last but not least there is a feature

00:23:03,520 --> 00:23:08,000
which is perhaps the nastiest of all of

00:23:06,240 --> 00:23:11,120
them

00:23:08,000 --> 00:23:14,159
bills can say they can define

00:23:11,120 --> 00:23:16,960
flags these flags are boolean values

00:23:14,159 --> 00:23:18,000
a flag is anything it's just a string

00:23:16,960 --> 00:23:20,400
and then you can have

00:23:18,000 --> 00:23:22,400
conditionals based on whether this flag

00:23:20,400 --> 00:23:24,400
is set or not

00:23:22,400 --> 00:23:26,000
now what this build does first of all

00:23:24,400 --> 00:23:29,120
it's important to know that

00:23:26,000 --> 00:23:31,280
whether this flag is set or not is never

00:23:29,120 --> 00:23:33,280
visible after the build has run so

00:23:31,280 --> 00:23:35,760
you've run a build and then you wonder

00:23:33,280 --> 00:23:37,200
does it have https support and there is

00:23:35,760 --> 00:23:40,080
no way to tell

00:23:37,200 --> 00:23:41,039
except for trying an https url and see

00:23:40,080 --> 00:23:43,120
whether it works

00:23:41,039 --> 00:23:45,120
but the values of those flags are not

00:23:43,120 --> 00:23:46,720
visible in the version information

00:23:45,120 --> 00:23:48,960
there is also no way for haskell

00:23:46,720 --> 00:23:50,960
packages to depend on the library saying

00:23:48,960 --> 00:23:53,200
i want this version of the library but i

00:23:50,960 --> 00:23:53,840
need this flag enabled it's not possible

00:23:53,200 --> 00:23:58,080
i can't

00:23:53,840 --> 00:24:01,120
do it so it's a tricky feature

00:23:58,080 --> 00:24:03,760
the nice thing about those flags is that

00:24:01,120 --> 00:24:06,080
the value of those flags support users

00:24:03,760 --> 00:24:08,240
can specify it as a user you can say i

00:24:06,080 --> 00:24:08,960
want https support and then you enable

00:24:08,240 --> 00:24:11,760
it

00:24:08,960 --> 00:24:12,559
but if you don't do it then cabal will

00:24:11,760 --> 00:24:14,559
guess

00:24:12,559 --> 00:24:16,240
the value of the flag depending on your

00:24:14,559 --> 00:24:19,679
built environment

00:24:16,240 --> 00:24:20,880
so if you have these libraries installed

00:24:19,679 --> 00:24:24,240
in your environment

00:24:20,880 --> 00:24:24,799
then kabal will say aha i can use this

00:24:24,240 --> 00:24:28,000
branch

00:24:24,799 --> 00:24:32,240
and it will enable https and if you have

00:24:28,000 --> 00:24:34,240
this library but it's say version 2.1

00:24:32,240 --> 00:24:37,360
then it says yeah that's too new and

00:24:34,240 --> 00:24:39,600
then you don't have https support

00:24:37,360 --> 00:24:40,960
and also this is something that we can't

00:24:39,600 --> 00:24:42,960
express in nics

00:24:40,960 --> 00:24:44,400
right because sometimes people use these

00:24:42,960 --> 00:24:46,640
flags for something that's actually

00:24:44,400 --> 00:24:49,440
useful they say i don't know

00:24:46,640 --> 00:24:50,960
build with lavm and then they enable

00:24:49,440 --> 00:24:51,760
additional optimizations or something

00:24:50,960 --> 00:24:53,840
like that

00:24:51,760 --> 00:24:56,000
so we would like to offer our users the

00:24:53,840 --> 00:24:58,159
ability to say i want this package and i

00:24:56,000 --> 00:24:59,760
want it with llvm

00:24:58,159 --> 00:25:01,919
so our build instructions would

00:24:59,760 --> 00:25:04,320
technically have to contain

00:25:01,919 --> 00:25:06,400
some boolean parameter that's called

00:25:04,320 --> 00:25:09,120
https support

00:25:06,400 --> 00:25:10,559
and then as a user you can pass true or

00:25:09,120 --> 00:25:11,840
false and get the build with the

00:25:10,559 --> 00:25:14,240
appropriate flags set

00:25:11,840 --> 00:25:16,320
or disabled and this is also something

00:25:14,240 --> 00:25:18,559
we currently can't do

00:25:16,320 --> 00:25:19,679
what we do instead is that we have one

00:25:18,559 --> 00:25:21,679
global list

00:25:19,679 --> 00:25:24,799
of flags where we for every package

00:25:21,679 --> 00:25:27,679
specify the flags that are specified

00:25:24,799 --> 00:25:28,080
and for most parts we just let cabal

00:25:27,679 --> 00:25:31,679
guess

00:25:28,080 --> 00:25:35,279
and see what happens it works

00:25:31,679 --> 00:25:37,760
good enough okay

00:25:35,279 --> 00:25:39,039
the next box in this diagram was

00:25:37,760 --> 00:25:42,159
stackage

00:25:39,039 --> 00:25:43,200
stackage has about 18 percent of package

00:25:42,159 --> 00:25:45,039
covered

00:25:43,200 --> 00:25:46,720
when you want your package in stackage

00:25:45,039 --> 00:25:48,640
you actually have to register with them

00:25:46,720 --> 00:25:50,559
you have to say this is my email address

00:25:48,640 --> 00:25:51,840
this is my twitter name this is my

00:25:50,559 --> 00:25:53,679
github account

00:25:51,840 --> 00:25:55,760
these are the packages i'm responsible

00:25:53,679 --> 00:25:57,520
for you have to promise that you will

00:25:55,760 --> 00:25:59,520
fix build errors within a reasonable

00:25:57,520 --> 00:26:01,440
amount of time you have to have a backup

00:25:59,520 --> 00:26:02,720
administrator in case you're on vacation

00:26:01,440 --> 00:26:05,039
and then once

00:26:02,720 --> 00:26:07,600
you've are registered in the database

00:26:05,039 --> 00:26:09,840
your packages will be part of stackage

00:26:07,600 --> 00:26:11,279
and then you are part of a sort of

00:26:09,840 --> 00:26:13,360
automatic machinery

00:26:11,279 --> 00:26:14,880
that updates things and informs the

00:26:13,360 --> 00:26:16,640
authors if there are a problem and then

00:26:14,880 --> 00:26:18,240
they respond quickly and then

00:26:16,640 --> 00:26:20,240
you have this stable package set right

00:26:18,240 --> 00:26:24,240
this curated package set

00:26:20,240 --> 00:26:26,640
stackage runs all these builds in github

00:26:24,240 --> 00:26:27,600
travis ci which means it's only linux

00:26:26,640 --> 00:26:29,200
builds

00:26:27,600 --> 00:26:30,799
so when you get information from

00:26:29,200 --> 00:26:32,960
stackage that says

00:26:30,799 --> 00:26:34,320
this package in this version is going to

00:26:32,960 --> 00:26:36,400
build fine

00:26:34,320 --> 00:26:38,159
then it's not necessarily going to build

00:26:36,400 --> 00:26:41,600
fine on a mac

00:26:38,159 --> 00:26:43,600
because they don't test that next we

00:26:41,600 --> 00:26:46,400
do have a mac right we do have support

00:26:43,600 --> 00:26:48,480
for that platform so

00:26:46,400 --> 00:26:49,600
mac users or basically anything other

00:26:48,480 --> 00:26:52,240
than linux users

00:26:49,600 --> 00:26:53,120
don't get the full value out of this

00:26:52,240 --> 00:26:55,279
whole lts

00:26:53,120 --> 00:26:57,760
effort because their platforms aren't

00:26:55,279 --> 00:26:57,760
tested

00:26:58,799 --> 00:27:02,080
then there is i talked about that

00:27:00,240 --> 00:27:03,360
already the build products are these

00:27:02,080 --> 00:27:05,760
nightly snapshots

00:27:03,360 --> 00:27:07,600
which is the latest possible version so

00:27:05,760 --> 00:27:10,240
that everything compiles

00:27:07,600 --> 00:27:12,000
there are lts miner releases which are

00:27:10,240 --> 00:27:13,679
released every week and contain

00:27:12,000 --> 00:27:16,320
updates that don't break the eye and the

00:27:13,679 --> 00:27:17,760
major releases they may break apis but

00:27:16,320 --> 00:27:21,039
they are rare we are now

00:27:17,760 --> 00:27:23,200
at lts major version three

00:27:21,039 --> 00:27:24,399
so four is going to come out together

00:27:23,200 --> 00:27:28,000
with gcc

00:27:24,399 --> 00:27:31,600
7 12 3. i don't know

00:27:28,000 --> 00:27:31,600
we are not at 12 we are 10 right

00:27:31,760 --> 00:27:39,360
okay so the code or the the the program

00:27:35,919 --> 00:27:41,679
that does all the automatic stuff

00:27:39,360 --> 00:27:43,039
these are these two two tools kabaltonix

00:27:41,679 --> 00:27:46,000
and hackathonics

00:27:43,039 --> 00:27:47,120
they live on github and actually all the

00:27:46,000 --> 00:27:49,360
intelligence about

00:27:47,120 --> 00:27:50,240
how do you generate a build expression

00:27:49,360 --> 00:27:52,080
what kind of

00:27:50,240 --> 00:27:54,640
exceptions have to be configured in and

00:27:52,080 --> 00:27:56,799
so on is included in one library

00:27:54,640 --> 00:27:59,120
and then both of these executables are

00:27:56,799 --> 00:28:01,200
just front ends to that library

00:27:59,120 --> 00:28:02,960
the cabal to nyx tool is supposed to be

00:28:01,200 --> 00:28:04,559
used by users

00:28:02,960 --> 00:28:06,480
this is the tool where you say i have a

00:28:04,559 --> 00:28:07,440
cabal file give me a next expression

00:28:06,480 --> 00:28:10,000
that builds it

00:28:07,440 --> 00:28:12,080
that's what this does the hackathonics

00:28:10,000 --> 00:28:14,799
executable on the other hand says

00:28:12,080 --> 00:28:16,640
give me hackage stackage and then i

00:28:14,799 --> 00:28:18,880
generate your next package

00:28:16,640 --> 00:28:21,200
so it updates the whole package set and

00:28:18,880 --> 00:28:21,840
people are typically not supposed to use

00:28:21,200 --> 00:28:25,279
that

00:28:21,840 --> 00:28:26,799
instead we have this run this update nix

00:28:25,279 --> 00:28:29,840
packages script

00:28:26,799 --> 00:28:31,600
that's run automatically and so

00:28:29,840 --> 00:28:33,679
basically once an hour

00:28:31,600 --> 00:28:35,520
we take all the new versions all the new

00:28:33,679 --> 00:28:36,640
information generate a new version of

00:28:35,520 --> 00:28:39,200
nick's package

00:28:36,640 --> 00:28:41,039
commit it into a separate branch first

00:28:39,200 --> 00:28:42,960
of all so that there is some testing we

00:28:41,039 --> 00:28:44,799
have a hydra instance that

00:28:42,960 --> 00:28:46,799
continuously builds all that stuff and

00:28:44,799 --> 00:28:48,799
only after we have seen okay this stuff

00:28:46,799 --> 00:28:51,440
is really stable and it really works

00:28:48,799 --> 00:28:53,760
then we merge it into master so

00:28:51,440 --> 00:28:57,039
basically updates on master

00:28:53,760 --> 00:28:58,960
they could in theory appear once an hour

00:28:57,039 --> 00:29:00,720
so in theory if someone uploads a

00:28:58,960 --> 00:29:02,880
package to package we would have it 60

00:29:00,720 --> 00:29:05,840
minutes later at most

00:29:02,880 --> 00:29:06,960
the factor we merge to master i do it

00:29:05,840 --> 00:29:09,120
manually

00:29:06,960 --> 00:29:10,799
so whenever i think of it i merge it and

00:29:09,120 --> 00:29:12,240
it's every two or three days or

00:29:10,799 --> 00:29:15,200
something like that

00:29:12,240 --> 00:29:16,799
so basically if you're following the

00:29:15,200 --> 00:29:18,559
master branch of next package

00:29:16,799 --> 00:29:20,480
you have an accurate replica

00:29:18,559 --> 00:29:23,440
representation of package

00:29:20,480 --> 00:29:23,919
that's within two or three days which is

00:29:23,440 --> 00:29:27,520
i think

00:29:23,919 --> 00:29:31,360
pretty good okay

00:29:27,520 --> 00:29:34,399
so now the next package machinery

00:29:31,360 --> 00:29:36,320
is interesting in itself i just have to

00:29:34,399 --> 00:29:38,640
check the time because we're running out

00:29:36,320 --> 00:29:38,640
of time

00:29:38,880 --> 00:29:43,520
the package set there is what we have is

00:29:42,480 --> 00:29:45,919
we have this one

00:29:43,520 --> 00:29:47,360
attribute set which contains the bills

00:29:45,919 --> 00:29:50,559
for all the packages that we

00:29:47,360 --> 00:29:52,000
that we that we feature and

00:29:50,559 --> 00:29:54,320
what you see is this is what it looks

00:29:52,000 --> 00:29:56,240
like we defined for every package on an

00:29:54,320 --> 00:29:57,440
attribute that matches exactly the name

00:29:56,240 --> 00:29:58,880
of that package

00:29:57,440 --> 00:30:00,960
and then there is this whole call

00:29:58,880 --> 00:30:03,440
package thing that you probably know

00:30:00,960 --> 00:30:04,960
that how packages are defined in nics

00:30:03,440 --> 00:30:06,559
the only difference is that here we

00:30:04,960 --> 00:30:08,399
don't refer to a separate file but

00:30:06,559 --> 00:30:10,240
instead we have all the expressions in

00:30:08,399 --> 00:30:12,880
place so there is one file

00:30:10,240 --> 00:30:13,679
and it's completely self-contained and

00:30:12,880 --> 00:30:16,480
then we have

00:30:13,679 --> 00:30:18,480
for every package the latest version

00:30:16,480 --> 00:30:21,200
which is the one that has this

00:30:18,480 --> 00:30:22,000
only package name attribute and then we

00:30:21,200 --> 00:30:24,240
have typically

00:30:22,000 --> 00:30:25,520
older versions which are required for

00:30:24,240 --> 00:30:27,760
lts support

00:30:25,520 --> 00:30:28,640
and these have their version number

00:30:27,760 --> 00:30:31,360
added to them

00:30:28,640 --> 00:30:32,159
at the back so when dependencies are

00:30:31,360 --> 00:30:34,880
resolved

00:30:32,159 --> 00:30:36,320
only the packages without this kind of

00:30:34,880 --> 00:30:39,279
suffix are used

00:30:36,320 --> 00:30:41,120
so when you say i depend on mtl you will

00:30:39,279 --> 00:30:44,360
get the latest version

00:30:41,120 --> 00:30:46,559
and when you say i want to depend on mtl

00:30:44,360 --> 00:30:49,039
2.1.3.1 then you have to say that

00:30:46,559 --> 00:30:50,880
explicitly you get the latest version by

00:30:49,039 --> 00:30:54,159
default

00:30:50,880 --> 00:30:56,240
so this package set is

00:30:54,159 --> 00:30:58,480
implemented as a recursive function and

00:30:56,240 --> 00:31:00,480
this is a

00:30:58,480 --> 00:31:03,200
it's a lot of fun when you know about

00:31:00,480 --> 00:31:06,480
how it works but i suppose it's a

00:31:03,200 --> 00:31:08,960
new for for many people in uh the

00:31:06,480 --> 00:31:10,559
the idea is that this package set is a

00:31:08,960 --> 00:31:13,600
function

00:31:10,559 --> 00:31:13,840
that function produces a package set and

00:31:13,600 --> 00:31:16,720
as

00:31:13,840 --> 00:31:19,840
an argument it gets the package set that

00:31:16,720 --> 00:31:19,840
it's going to produce

00:31:20,559 --> 00:31:22,799
the

00:31:25,120 --> 00:31:28,559
the idea is

00:31:28,799 --> 00:31:32,880
here is a nice example where you can see

00:31:30,880 --> 00:31:33,679
how that works you have this package set

00:31:32,880 --> 00:31:36,960
which gets

00:31:33,679 --> 00:31:39,760
itself as an argument then it defines

00:31:36,960 --> 00:31:41,279
those two attributes and then it defines

00:31:39,760 --> 00:31:44,399
this attribute which

00:31:41,279 --> 00:31:48,320
refers to these attributes via

00:31:44,399 --> 00:31:50,960
itself right and so when you

00:31:48,320 --> 00:31:52,720
have when you compute a fixed point this

00:31:50,960 --> 00:31:56,000
is the point where

00:31:52,720 --> 00:31:59,120
the argument and the output are the same

00:31:56,000 --> 00:32:01,760
then you compute this function

00:31:59,120 --> 00:32:03,360
when you expand that self argument again

00:32:01,760 --> 00:32:06,640
and again and again you end up just

00:32:03,360 --> 00:32:08,320
repeatedly calling pspspspsps

00:32:06,640 --> 00:32:10,880
and at some point this package set

00:32:08,320 --> 00:32:13,039
contains normal reference to self

00:32:10,880 --> 00:32:14,880
and when it doesn't reference self self

00:32:13,039 --> 00:32:17,440
is not computed because it's

00:32:14,880 --> 00:32:20,000
lazy evaluated and then the computation

00:32:17,440 --> 00:32:20,000
finishes

00:32:23,039 --> 00:32:28,720
the yeah yeah i was you have this

00:32:26,399 --> 00:32:31,519
construct in nix you have this recursive

00:32:28,720 --> 00:32:32,960
attribute set but the recursive

00:32:31,519 --> 00:32:36,640
attribute set doesn't work

00:32:32,960 --> 00:32:38,720
this nicely because um

00:32:36,640 --> 00:32:40,080
i have to go it will be clear after this

00:32:38,720 --> 00:32:42,399
example

00:32:40,080 --> 00:32:44,240
one thing why we do this why we

00:32:42,399 --> 00:32:45,919
structure the package set in this way is

00:32:44,240 --> 00:32:48,640
that this makes it really

00:32:45,919 --> 00:32:49,440
convenient to modify the package set in

00:32:48,640 --> 00:32:52,480
a way

00:32:49,440 --> 00:32:53,840
that looks like object of oriented

00:32:52,480 --> 00:32:55,600
inheritance

00:32:53,840 --> 00:32:57,120
so what you have is you have this

00:32:55,600 --> 00:33:00,320
function which as

00:32:57,120 --> 00:33:02,880
arguments takes a recursive package set

00:33:00,320 --> 00:33:03,440
and it takes another function and this

00:33:02,880 --> 00:33:06,960
function

00:33:03,440 --> 00:33:10,320
takes a recursive package set

00:33:06,960 --> 00:33:12,399
and then it computes changes it's going

00:33:10,320 --> 00:33:14,559
to make to that package set

00:33:12,399 --> 00:33:16,960
and returns the result as another

00:33:14,559 --> 00:33:21,279
recursive package set

00:33:16,960 --> 00:33:23,039
so when you when you take this example

00:33:21,279 --> 00:33:24,880
and you compute the fixed point without

00:33:23,039 --> 00:33:28,320
any customization you will get

00:33:24,880 --> 00:33:30,880
fubar as a result but when you apply

00:33:28,320 --> 00:33:32,320
this function to modify it this function

00:33:30,880 --> 00:33:34,000
here

00:33:32,320 --> 00:33:35,519
then you have the function right it has

00:33:34,000 --> 00:33:38,720
its own output

00:33:35,519 --> 00:33:41,279
it has its input and this is a change

00:33:38,720 --> 00:33:42,799
it specifies to be applied to the thing

00:33:41,279 --> 00:33:46,080
so in here we replace

00:33:42,799 --> 00:33:48,080
foo with the value of foo reversed

00:33:46,080 --> 00:33:50,240
and when we apply this we get this

00:33:48,080 --> 00:33:53,120
output

00:33:50,240 --> 00:33:55,120
so we have modified the package set if

00:33:53,120 --> 00:33:56,320
this had been a recursive attribute set

00:33:55,120 --> 00:33:58,240
in the next sense

00:33:56,320 --> 00:33:59,679
then this self argument wouldn't have

00:33:58,240 --> 00:34:01,840
been necessary right

00:33:59,679 --> 00:34:02,720
but in this case this would have been

00:34:01,840 --> 00:34:04,640
this would have bound

00:34:02,720 --> 00:34:07,440
tighter than any modification you could

00:34:04,640 --> 00:34:09,359
make if you would modify the full value

00:34:07,440 --> 00:34:11,760
of that package set you would not

00:34:09,359 --> 00:34:13,919
modify fubar because this has already

00:34:11,760 --> 00:34:16,639
been bound

00:34:13,919 --> 00:34:18,639
yeah so you can basically whenever you

00:34:16,639 --> 00:34:20,079
want to modify the packet set you can

00:34:18,639 --> 00:34:22,480
choose between

00:34:20,079 --> 00:34:23,119
give me the value from above and then

00:34:22,480 --> 00:34:26,560
modify

00:34:23,119 --> 00:34:27,200
it and return it as a result or you can

00:34:26,560 --> 00:34:29,520
say

00:34:27,200 --> 00:34:30,639
give me the result of another

00:34:29,520 --> 00:34:33,839
modification

00:34:30,639 --> 00:34:36,720
so you can refer to your to basically a

00:34:33,839 --> 00:34:39,119
series of of overrides that happen

00:34:36,720 --> 00:34:42,240
and you can hear the inner one refer to

00:34:39,119 --> 00:34:44,720
a result that's going to compute it here

00:34:42,240 --> 00:34:45,599
so this is an extremely flexible

00:34:44,720 --> 00:34:48,079
construct

00:34:45,599 --> 00:34:49,440
and the package set here we have i'm

00:34:48,079 --> 00:34:53,200
going to come to an end

00:34:49,440 --> 00:34:56,480
and the package said this is it

00:34:53,200 --> 00:34:58,160
that's the actual code um we have

00:34:56,480 --> 00:34:59,839
the haskell package list this is the

00:34:58,160 --> 00:35:01,680
file that i showed you which contains

00:34:59,839 --> 00:35:03,599
all the build expressions

00:35:01,680 --> 00:35:05,040
to that we apply this common

00:35:03,599 --> 00:35:07,839
configuration which

00:35:05,040 --> 00:35:09,760
fixes missing dependencies that we

00:35:07,839 --> 00:35:11,760
couldn't extract or which adds

00:35:09,760 --> 00:35:13,760
other libraries that we want to enable

00:35:11,760 --> 00:35:15,839
flags during compilation

00:35:13,760 --> 00:35:17,440
then we extend that with the compiler

00:35:15,839 --> 00:35:19,760
specific configuration

00:35:17,440 --> 00:35:21,359
then we extend that with the package set

00:35:19,760 --> 00:35:23,040
specific configuration that gives you

00:35:21,359 --> 00:35:25,119
the version information and then

00:35:23,040 --> 00:35:26,800
at the end we extend that with user

00:35:25,119 --> 00:35:27,839
configured overrides that you can

00:35:26,800 --> 00:35:30,960
specify

00:35:27,839 --> 00:35:32,160
to change it and then we say fix then we

00:35:30,960 --> 00:35:34,240
get a result where

00:35:32,160 --> 00:35:36,079
this original package set that we once

00:35:34,240 --> 00:35:37,680
generated automatically may look

00:35:36,079 --> 00:35:39,599
completely different it has

00:35:37,680 --> 00:35:41,119
different versions different build

00:35:39,599 --> 00:35:44,240
inputs you can

00:35:41,119 --> 00:35:48,240
do with it whatever you please

00:35:44,240 --> 00:35:51,760
okay and this stuff all the other three

00:35:48,240 --> 00:35:51,760
slides i'll save for another talk

00:35:56,839 --> 00:35:59,839
okay

00:36:02,480 --> 00:36:06,560
thanks for the talk peter we have a

00:36:04,960 --> 00:36:07,839
couple of minutes to understand what the

00:36:06,560 --> 00:36:13,839
fixed point is

00:36:07,839 --> 00:36:13,839
so should should

00:36:14,720 --> 00:36:17,440
don't be shy

00:36:23,760 --> 00:36:30,320
i'm here uh where are you yeah okay

00:36:27,119 --> 00:36:33,520
um what

00:36:30,320 --> 00:36:35,280
i think i already asked you probably a

00:36:33,520 --> 00:36:37,440
few months ago but

00:36:35,280 --> 00:36:40,560
how could we reuse this functionality

00:36:37,440 --> 00:36:42,560
which extends and overrides and

00:36:40,560 --> 00:36:44,800
into other languages as well because

00:36:42,560 --> 00:36:45,520
it's it's i see it as a common piece

00:36:44,800 --> 00:36:47,760
that

00:36:45,520 --> 00:36:48,720
if you generate something from whatever

00:36:47,760 --> 00:36:52,720
stackage or

00:36:48,720 --> 00:36:55,520
pipeline or uh bundler statement

00:36:52,720 --> 00:36:56,720
everything right everybody use that and

00:36:55,520 --> 00:36:59,680
then you build this uh

00:36:56,720 --> 00:37:00,160
set and you need to override well few in

00:36:59,680 --> 00:37:02,000
few

00:37:00,160 --> 00:37:03,200
different layers could we then kind of

00:37:02,000 --> 00:37:07,599
abstract this and kind of

00:37:03,200 --> 00:37:10,000
create this more unified way how to

00:37:07,599 --> 00:37:10,640
approach languages and import them would

00:37:10,000 --> 00:37:14,800
that be

00:37:10,640 --> 00:37:15,520
an option technically it's absolutely

00:37:14,800 --> 00:37:19,040
feasible

00:37:15,520 --> 00:37:20,880
um when you the basically the entire

00:37:19,040 --> 00:37:22,720
infrastructure that you need for this

00:37:20,880 --> 00:37:24,480
are those two functions this is this is

00:37:22,720 --> 00:37:26,720
the real thing they don't

00:37:24,480 --> 00:37:28,960
are not more complicated than this um

00:37:26,720 --> 00:37:29,359
this code is in in the package set it's

00:37:28,960 --> 00:37:31,680
there

00:37:29,359 --> 00:37:32,400
it can be reused right so everybody is

00:37:31,680 --> 00:37:34,400
free

00:37:32,400 --> 00:37:36,079
to use that approach and structure the

00:37:34,400 --> 00:37:37,200
packages in such a way that you have

00:37:36,079 --> 00:37:39,520
this base

00:37:37,200 --> 00:37:40,480
package set which is kind of the bare

00:37:39,520 --> 00:37:42,160
default

00:37:40,480 --> 00:37:44,480
and then you can have layers of

00:37:42,160 --> 00:37:47,440
configuration added on top of it

00:37:44,480 --> 00:37:47,680
and it's not difficult to do the thing

00:37:47,440 --> 00:37:50,000
is

00:37:47,680 --> 00:37:52,079
it's it's effort right you have to do it

00:37:50,000 --> 00:37:53,440
um for instance i also generated the

00:37:52,079 --> 00:37:56,240
package set for um

00:37:53,440 --> 00:37:57,440
r for the r utility and it's some i

00:37:56,240 --> 00:37:59,680
don't know 7 000

00:37:57,440 --> 00:38:00,960
packages in there and it's not

00:37:59,680 --> 00:38:03,839
structured in this way

00:38:00,960 --> 00:38:05,680
because um at the time when i did that i

00:38:03,839 --> 00:38:08,240
had no idea about this stuff

00:38:05,680 --> 00:38:10,079
so these days every time i have to work

00:38:08,240 --> 00:38:11,760
with the our package set i think man

00:38:10,079 --> 00:38:19,839
this is a mess and it should really be

00:38:11,760 --> 00:38:19,839
cleaned up

00:38:25,520 --> 00:38:30,320
um actually i once grabbed next packages

00:38:28,960 --> 00:38:32,560
for fix and cons

00:38:30,320 --> 00:38:34,000
and such functions and there are maybe

00:38:32,560 --> 00:38:35,599
three or four places where

00:38:34,000 --> 00:38:37,680
those functions are defined because

00:38:35,599 --> 00:38:42,079
they're so useful so maybe

00:38:37,680 --> 00:38:42,079
include them in the library

00:38:49,200 --> 00:38:52,400
yeah so actually i think we should

00:38:51,200 --> 00:38:54,560
probably use this

00:38:52,400 --> 00:38:57,760
for nick's packages at the top level

00:38:54,560 --> 00:39:00,400
because right now nick's packages has a

00:38:57,760 --> 00:39:01,280
pretty ad-hoc override mechanism which

00:39:00,400 --> 00:39:03,599
is really a

00:39:01,280 --> 00:39:04,720
undisciplined way of doing this so there

00:39:03,599 --> 00:39:07,440
is sort of

00:39:04,720 --> 00:39:08,960
as a next package is actually defined by

00:39:07,440 --> 00:39:12,400
passing itself

00:39:08,960 --> 00:39:12,800
into itself and then some complications

00:39:12,400 --> 00:39:15,520
for

00:39:12,800 --> 00:39:16,000
being able to refer to the unoverwritten

00:39:15,520 --> 00:39:19,280
uh

00:39:16,000 --> 00:39:20,720
version so yeah this this would be much

00:39:19,280 --> 00:39:22,960
better so

00:39:20,720 --> 00:39:23,760
we should probably look into how we can

00:39:22,960 --> 00:39:27,599
do that

00:39:23,760 --> 00:39:30,500
yeah somebody should do that

00:39:27,599 --> 00:39:34,120
we should we should open a github issue

00:39:30,500 --> 00:39:34,120
[Laughter]

00:39:38,560 --> 00:39:42,640
that's right niklas has actually taking

00:39:41,599 --> 00:39:45,839
the

00:39:42,640 --> 00:39:45,839
effort upon himself here

00:39:46,480 --> 00:39:48,880
handy

00:39:50,960 --> 00:39:55,119
i think there may have been some start

00:39:54,320 --> 00:39:57,760
already

00:39:55,119 --> 00:39:59,760
by factoring out the package overrides

00:39:57,760 --> 00:40:03,440
mechanism which is

00:39:59,760 --> 00:40:06,720
well it's the same mechanism again or

00:40:03,440 --> 00:40:09,760
very similar and there have been

00:40:06,720 --> 00:40:13,760
some changes recently by jen

00:40:09,760 --> 00:40:17,200
that this yeah well let's factor that

00:40:13,760 --> 00:40:20,560
into a function i think that you can say

00:40:17,200 --> 00:40:24,000
i want these packages and

00:40:20,560 --> 00:40:25,280
apply package overrides and get it as a

00:40:24,000 --> 00:40:27,920
package set

00:40:25,280 --> 00:40:29,760
no not just in the general way that you

00:40:27,920 --> 00:40:33,839
edit it somewhere in

00:40:29,760 --> 00:40:33,839
dot next package config

00:40:46,000 --> 00:40:49,760
hey i'm sorry i have very practical

00:40:47,839 --> 00:40:52,960
question the older versions

00:40:49,760 --> 00:40:55,599
of of libraries we keep them just for

00:40:52,960 --> 00:40:58,160
lts so we can't rely on them being

00:40:55,599 --> 00:40:59,119
in mixed packages like tomorrow or like

00:40:58,160 --> 00:41:04,319
rather

00:40:59,119 --> 00:41:06,720
after the next release of lts um

00:41:04,319 --> 00:41:09,200
theoretically we could say we drop

00:41:06,720 --> 00:41:10,000
support for lts haskell zero point

00:41:09,200 --> 00:41:12,400
something

00:41:10,000 --> 00:41:14,240
and if we did then packages required

00:41:12,400 --> 00:41:16,160
only by that version would go away

00:41:14,240 --> 00:41:18,400
that's true

00:41:16,160 --> 00:41:20,000
the reality is however that the number

00:41:18,400 --> 00:41:23,760
of versions we ship is only

00:41:20,000 --> 00:41:26,319
going up so personally

00:41:23,760 --> 00:41:26,960
i think that this whole intelligence

00:41:26,319 --> 00:41:29,119
that

00:41:26,960 --> 00:41:30,800
selects which package to include and

00:41:29,119 --> 00:41:32,640
which one's not

00:41:30,800 --> 00:41:34,319
that should go away entirely we should

00:41:32,640 --> 00:41:35,440
just say we have every version on

00:41:34,319 --> 00:41:38,400
hackage period

00:41:35,440 --> 00:41:39,440
right that's what we should do it's uh

00:41:38,400 --> 00:41:42,160
only a matter of

00:41:39,440 --> 00:41:44,880
um what's the implication on the next

00:41:42,160 --> 00:41:46,960
tools in terms of memory requirements

00:41:44,880 --> 00:41:49,040
parser performance these kind of things

00:41:46,960 --> 00:41:51,520
we have to figure out right but

00:41:49,040 --> 00:41:52,640
i think that the versions we distribute

00:41:51,520 --> 00:41:54,000
the number of versions that we

00:41:52,640 --> 00:41:58,400
distribute is going to go

00:41:54,000 --> 00:41:58,400
up only it's not going down i think so

00:42:00,560 --> 00:42:04,640
all right um actually i have two

00:42:02,400 --> 00:42:07,200
questions um

00:42:04,640 --> 00:42:07,760
like the first question would be uh what

00:42:07,200 --> 00:42:11,040
does the

00:42:07,760 --> 00:42:15,440
stack tool um like do you have any

00:42:11,040 --> 00:42:16,960
thoughts on this um the stack utility is

00:42:15,440 --> 00:42:19,599
a kind of um

00:42:16,960 --> 00:42:21,680
advanced version of kabal install it's a

00:42:19,599 --> 00:42:22,480
build driver so you can write a very

00:42:21,680 --> 00:42:25,520
simple

00:42:22,480 --> 00:42:25,920
json file yaml file where you specify i

00:42:25,520 --> 00:42:27,760
have

00:42:25,920 --> 00:42:29,680
this package i have these dependencies

00:42:27,760 --> 00:42:31,200
and then you just say stack build and

00:42:29,680 --> 00:42:32,240
it's doing everything automatically it

00:42:31,200 --> 00:42:34,319
downloads the

00:42:32,240 --> 00:42:35,520
packages compiles the dependencies sets

00:42:34,319 --> 00:42:38,000
up a sandbox for you

00:42:35,520 --> 00:42:39,920
it's all very convenient and it's very

00:42:38,000 --> 00:42:42,960
nice and i use it myself it's a

00:42:39,920 --> 00:42:45,680
great tool it interacts

00:42:42,960 --> 00:42:46,640
perfectly with with nix there is no no

00:42:45,680 --> 00:42:49,760
problem

00:42:46,640 --> 00:42:52,000
if you have if you use nics to install a

00:42:49,760 --> 00:42:54,880
compiler in a library environment

00:42:52,000 --> 00:42:56,880
and stack sees that it needs some of

00:42:54,880 --> 00:42:57,680
those libraries that you already have

00:42:56,880 --> 00:42:59,520
installed

00:42:57,680 --> 00:43:00,800
then it will reuse them and it won't

00:42:59,520 --> 00:43:03,119
compile them

00:43:00,800 --> 00:43:04,319
so in theory you could say in your stack

00:43:03,119 --> 00:43:07,839
file i use

00:43:04,319 --> 00:43:10,880
lts version 3.3 and then you

00:43:07,839 --> 00:43:13,599
configure a ghc environment in the lts

00:43:10,880 --> 00:43:15,200
3.3 package set which contains exactly

00:43:13,599 --> 00:43:16,720
those packages that you need

00:43:15,200 --> 00:43:18,480
and then you would run stack build and

00:43:16,720 --> 00:43:21,280
it wouldn't compile anything

00:43:18,480 --> 00:43:22,240
because it's already there so in a way

00:43:21,280 --> 00:43:24,160
um

00:43:22,240 --> 00:43:25,839
the two tools complement each other

00:43:24,160 --> 00:43:27,839
right it's

00:43:25,839 --> 00:43:31,440
i guess the advantage of stack is that

00:43:27,839 --> 00:43:33,200
it's very ad hockish you don't have to

00:43:31,440 --> 00:43:35,280
write a nics expression save it

00:43:33,200 --> 00:43:36,240
somewhere enter a nick shell leave in

00:43:35,280 --> 00:43:38,079
excel you don't

00:43:36,240 --> 00:43:39,520
have to bother you can just run stack

00:43:38,079 --> 00:43:43,119
and it works but

00:43:39,520 --> 00:43:44,319
um i think it's uh if people want to

00:43:43,119 --> 00:43:46,160
develop with stack and

00:43:44,319 --> 00:43:49,280
use nyx at the same time it's just

00:43:46,160 --> 00:43:51,680
working just fine no problem at all

00:43:49,280 --> 00:43:52,800
and thank you and my second question

00:43:51,680 --> 00:43:55,520
would be

00:43:52,800 --> 00:43:57,440
when you clone next packages what's the

00:43:55,520 --> 00:44:00,640
percentage of high school packages

00:43:57,440 --> 00:44:03,440
and i

00:44:00,640 --> 00:44:05,280
actually actually wrote an email about

00:44:03,440 --> 00:44:06,160
that a while ago but i don't recall the

00:44:05,280 --> 00:44:09,520
numbers it's

00:44:06,160 --> 00:44:11,359
it's significant i think we have haskell

00:44:09,520 --> 00:44:15,599
packages are something like 12

00:44:11,359 --> 00:44:19,040
000 i think at nix packages as a whole

00:44:15,599 --> 00:44:22,079
has maybe 15 000 or something like that

00:44:19,040 --> 00:44:25,200
not including the haskell packages

00:44:22,079 --> 00:44:28,480
so it's a large large

00:44:25,200 --> 00:44:30,880
chunk right but

00:44:28,480 --> 00:44:33,040
in terms of how much space it takes up

00:44:30,880 --> 00:44:34,880
in a repository i think the

00:44:33,040 --> 00:44:36,800
it's probably even even bigger the

00:44:34,880 --> 00:44:39,760
percentage of haskell packages

00:44:36,800 --> 00:44:41,599
because we have home pages synopsis all

00:44:39,760 --> 00:44:43,920
this stuff that we take from the gabify

00:44:41,599 --> 00:44:46,480
which many packages don't have so

00:44:43,920 --> 00:44:47,359
it's hard to say but it's a fairly good

00:44:46,480 --> 00:44:50,960
part of the

00:44:47,359 --> 00:44:54,010
distribution yeah

00:44:50,960 --> 00:44:54,010

YouTube URL: https://www.youtube.com/watch?v=a22y82ROKyA


