Title: Eelco Dolstra - the Nix roadmap (NixCon 2018)
Publication date: 2018-10-27
Playlist: NixCon 2018 (London)
Description: 
	Our BDFL will be talking about the Nix roadmap --- Bio: Eelco is a senior software engineer at Tweag I/O. He obtained a PhD in Computer Science from Utrecht University in 2006 and was a postdoctoral researcher at Utrecht University and Delft University. As part of his PhD research project at Utrecht University, he developed Nix, the purely functional package manager, which forms the basis of the NixOS Linux distribution. He previously worked at LogicBlox and Infor.
Captions: 
	00:00:03,529 --> 00:00:10,200
all right so first up is the it's the

00:00:08,730 --> 00:00:12,300
man who doesn't need an introduction but

00:00:10,200 --> 00:00:15,450
gets one anyway

00:00:12,300 --> 00:00:18,150
so first up we've got we've got echo and

00:00:15,450 --> 00:00:19,470
for those who maybe don't know yet

00:00:18,150 --> 00:00:21,150
because I did see a couple of ends of

00:00:19,470 --> 00:00:23,279
people attending an ex-con for the first

00:00:21,150 --> 00:00:25,470
time echo is the person that we have to

00:00:23,279 --> 00:00:26,910
thank for for for the initiation of

00:00:25,470 --> 00:00:31,080
nick's basically because he worked on

00:00:26,910 --> 00:00:33,600
that during his PhD research and today

00:00:31,080 --> 00:00:35,820
is however not the time to look back but

00:00:33,600 --> 00:00:38,730
today echo is gonna tell us about what

00:00:35,820 --> 00:00:40,320
lies ahead for Nix the road map of the

00:00:38,730 --> 00:00:41,340
future of leaks basically right so

00:00:40,320 --> 00:00:55,079
please give them a hand

00:00:41,340 --> 00:00:58,350
echo thank you so I guess this work can

00:00:55,079 --> 00:01:01,829
you hear me okay great okay so first of

00:00:58,350 --> 00:01:04,790
all thanks to the organizers and apart

00:01:01,829 --> 00:01:06,810
from that let me say that's a talk about

00:01:04,790 --> 00:01:09,180
external monitors being hard to

00:01:06,810 --> 00:01:11,670
configure in a NIC so as is fake news I

00:01:09,180 --> 00:01:15,540
just plugged it in and it works its

00:01:11,670 --> 00:01:18,740
magic yeah so this this talk is was

00:01:15,540 --> 00:01:21,689
originally called a mix roadmap but

00:01:18,740 --> 00:01:24,530
there is no Nick's roadmap it's towards

00:01:21,689 --> 00:01:24,530
or Nick's roadmap

00:01:24,789 --> 00:01:29,289
because this should really be a

00:01:26,799 --> 00:01:33,969
community effort so this is sort of a

00:01:29,289 --> 00:01:35,829
starting point towards a roadmap so

00:01:33,969 --> 00:01:39,219
people have been saying for years that

00:01:35,829 --> 00:01:41,200
we should have a road map so lately I've

00:01:39,219 --> 00:01:42,789
been doing a lot of roughs programming

00:01:41,200 --> 00:01:45,099
I've been really drinking the rushed

00:01:42,789 --> 00:01:47,409
kool-aid so whenever I have a problem

00:01:45,099 --> 00:01:50,500
now I ask myself what would rust to do

00:01:47,409 --> 00:01:51,939
so it turns out rust a they have an RFC

00:01:50,500 --> 00:01:55,659
for everything they have a beautiful

00:01:51,939 --> 00:01:57,310
process for everything so yeah so why

00:01:55,659 --> 00:02:02,229
should you have a roadmap to begin with

00:01:57,310 --> 00:02:03,789
well so they answer that so it's so the

00:02:02,229 --> 00:02:06,280
main thing is that it allows the world

00:02:03,789 --> 00:02:08,739
to see what are sort of the long-term

00:02:06,280 --> 00:02:11,370
plans and destroyed strategic priorities

00:02:08,739 --> 00:02:14,200
and it allows all the developers to

00:02:11,370 --> 00:02:17,459
hopefully get behind that and so

00:02:14,200 --> 00:02:17,459
everybody is hopefully

00:02:20,720 --> 00:02:27,050
so hopefully then everybody is kind of

00:02:24,170 --> 00:02:31,070
pointing in the same direction and

00:02:27,050 --> 00:02:33,950
another thing they mentioned is that so

00:02:31,070 --> 00:02:37,780
they have a rapid release cycle but it

00:02:33,950 --> 00:02:41,540
turns out that that kind of men stats

00:02:37,780 --> 00:02:45,110
sort of bigger features as sort of

00:02:41,540 --> 00:02:47,450
long-term projects were sort of falling

00:02:45,110 --> 00:02:52,120
by the wayside because they don't really

00:02:47,450 --> 00:02:54,850
fit into that rapid release cycle so

00:02:52,120 --> 00:02:57,530
establishing annual goals as though in

00:02:54,850 --> 00:03:00,380
2018 where we're going to make the

00:02:57,530 --> 00:03:04,940
compiler fast that's a that's a way to

00:03:00,380 --> 00:03:08,390
really get people behind it and ensure

00:03:04,940 --> 00:03:09,710
that they spend time on that so that at

00:03:08,390 --> 00:03:14,840
the end of the year they don't have to

00:03:09,710 --> 00:03:16,280
say we fail to reach our goals so the

00:03:14,840 --> 00:03:17,900
process that they have and I'm not

00:03:16,280 --> 00:03:21,520
necessarily saying that we should follow

00:03:17,900 --> 00:03:24,920
that but so they have an annual roadmap

00:03:21,520 --> 00:03:28,400
and so they have a process for for

00:03:24,920 --> 00:03:32,170
creating that roadmap so they have they

00:03:28,400 --> 00:03:35,660
write a an RFC where they get our

00:03:32,170 --> 00:03:37,730
problems that the community has and then

00:03:35,660 --> 00:03:41,810
from that they extract a bunch of goals

00:03:37,730 --> 00:03:43,970
so that sounds like a reasonable thing

00:03:41,810 --> 00:03:47,330
to do and and and then that they have a

00:03:43,970 --> 00:03:49,010
whole plan for the year so in say

00:03:47,330 --> 00:03:50,900
February they start planning how to

00:03:49,010 --> 00:03:53,269
reach those goals and then they start

00:03:50,900 --> 00:03:55,430
implementing them so I'm not saying that

00:03:53,269 --> 00:04:02,890
that necessarily makes a lot of sense

00:03:55,430 --> 00:04:07,250
for us but at least having a roadmap for

00:04:02,890 --> 00:04:10,760
say 2019 saying these are the goals that

00:04:07,250 --> 00:04:15,950
we want fornix that that sounds like a

00:04:10,760 --> 00:04:18,650
very valuable thing to have so in the

00:04:15,950 --> 00:04:20,720
rest of the talk I'm just going to do a

00:04:18,650 --> 00:04:25,400
brain dump of some things that I think

00:04:20,720 --> 00:04:27,380
are problems with Nicks and and and from

00:04:25,400 --> 00:04:30,740
that it follows that there are some

00:04:27,380 --> 00:04:32,139
goals that that we should implement but

00:04:30,740 --> 00:04:35,560
this is just

00:04:32,139 --> 00:04:38,499
sort of my IDs and so so I would like to

00:04:35,560 --> 00:04:40,300
do kind of this RFC process and get

00:04:38,499 --> 00:04:48,629
everybody's inputs and from that

00:04:40,300 --> 00:04:48,629
hopefully we can get a roadmap for 2019

00:04:48,810 --> 00:04:57,340
okay all right

00:04:53,499 --> 00:04:58,870
so some problem statements so so these

00:04:57,340 --> 00:05:01,779
are just some things that are currently

00:04:58,870 --> 00:05:04,029
problematic with Nick so for example or

00:05:01,779 --> 00:05:06,189
things that I would like to do but I

00:05:04,029 --> 00:05:08,409
can't at the moment so one is I would

00:05:06,189 --> 00:05:11,529
like to use Nick's as a make replacement

00:05:08,409 --> 00:05:13,240
or a basil replacement so and Nick's is

00:05:11,529 --> 00:05:15,669
all these nice features a purely

00:05:13,240 --> 00:05:19,180
functional language reproducible builds

00:05:15,669 --> 00:05:21,580
isolation and we do this for sort of

00:05:19,180 --> 00:05:23,919
large things like packages and for very

00:05:21,580 --> 00:05:27,219
small things like configuration files in

00:05:23,919 --> 00:05:29,919
Nick's OS so it seems like it should be

00:05:27,219 --> 00:05:32,439
a perfect bill tool as well so for

00:05:29,919 --> 00:05:33,939
building things like see source files or

00:05:32,439 --> 00:05:36,129
whatever other language you want to

00:05:33,939 --> 00:05:39,250
build but there are a bunch of reasons

00:05:36,129 --> 00:05:41,610
that currently you can't really do that

00:05:39,250 --> 00:05:44,439
at the moment so I'll come back to that

00:05:41,610 --> 00:05:46,839
so that's one problem another Nick's

00:05:44,439 --> 00:05:49,810
package options are not easily

00:05:46,839 --> 00:05:51,129
discoverable or configurable so right

00:05:49,810 --> 00:05:54,430
now

00:05:51,129 --> 00:05:58,870
Nick's packages have all sorts of

00:05:54,430 --> 00:06:02,969
options so for example a package

00:05:58,870 --> 00:06:05,399
function might have an enable foo

00:06:02,969 --> 00:06:07,810
arguments but this is completely

00:06:05,399 --> 00:06:10,930
undiscoverable except by reading the

00:06:07,810 --> 00:06:14,080
next packages source code and and it's

00:06:10,930 --> 00:06:17,800
also not configurable via an X and for

00:06:14,080 --> 00:06:23,319
any other tool so this is not very good

00:06:17,800 --> 00:06:25,659
UX another problem is that this is and

00:06:23,319 --> 00:06:27,490
this is an increasingly big problem is

00:06:25,659 --> 00:06:30,430
that Nick's packages and Nick's Wes

00:06:27,490 --> 00:06:33,490
evaluation is slow and it's getting

00:06:30,430 --> 00:06:35,409
slower all the time because the the sort

00:06:33,490 --> 00:06:37,529
of the level of abstractions that are

00:06:35,409 --> 00:06:42,580
used in the expected ease are increasing

00:06:37,529 --> 00:06:44,110
and it uses a lot of RAM so and actually

00:06:42,580 --> 00:06:45,409
it turns out that this problem is kind

00:06:44,110 --> 00:06:51,110
of related to the preview

00:06:45,409 --> 00:06:52,669
problem another one that comes up a lot

00:06:51,110 --> 00:06:55,729
is that Knicks currently has no way to

00:06:52,669 --> 00:06:59,479
handle secrets so things like passwords

00:06:55,729 --> 00:07:00,979
or keys you don't want to store it I was

00:06:59,479 --> 00:07:04,039
in the Knicks store because then their

00:07:00,979 --> 00:07:09,139
world readable which is bad so you need

00:07:04,039 --> 00:07:11,209
to some way to to deal with them or so

00:07:09,139 --> 00:07:12,769
another problem as an unprivileged so

00:07:11,209 --> 00:07:15,139
right now if you want to pull something

00:07:12,769 --> 00:07:17,659
from the binary cash from an arbitrary

00:07:15,139 --> 00:07:19,699
binary cash so you cannot do that as an

00:07:17,659 --> 00:07:25,969
unprivileged user how things need to be

00:07:19,699 --> 00:07:28,579
signed by a a key configured by the

00:07:25,969 --> 00:07:31,009
administrator so if you just want to

00:07:28,579 --> 00:07:32,959
pull some something from some arbitrary

00:07:31,009 --> 00:07:40,369
cash you cannot do that as an arbitrary

00:07:32,959 --> 00:07:43,879
user another one so closure bloat so

00:07:40,369 --> 00:07:47,749
this is a fairly big issue so in Knicks

00:07:43,879 --> 00:07:51,279
it's very easy to end up with a package

00:07:47,749 --> 00:07:57,079
that has way more runtime dependencies

00:07:51,279 --> 00:08:00,349
then it's then it actually needs also

00:07:57,079 --> 00:08:02,469
give an example of that later so yeah

00:08:00,349 --> 00:08:05,479
these are just some random problems so

00:08:02,469 --> 00:08:10,099
probably many of you have other problems

00:08:05,479 --> 00:08:12,469
so we interested to hear them but so

00:08:10,099 --> 00:08:15,139
here are some goals just give something

00:08:12,469 --> 00:08:17,029
yeah so here are some goals that that

00:08:15,139 --> 00:08:18,379
you can extract from those problem

00:08:17,029 --> 00:08:20,059
statements so these are more at a

00:08:18,379 --> 00:08:22,819
technical level so by the way if you

00:08:20,059 --> 00:08:28,269
look at the the rust goals there also a

00:08:22,819 --> 00:08:34,009
lot of non-technical goals there like

00:08:28,269 --> 00:08:36,380
improve documentation eventual eyes in

00:08:34,009 --> 00:08:41,110
certain communities make the community

00:08:36,380 --> 00:08:44,029
more diverse so that's all great as well

00:08:41,110 --> 00:08:46,759
yeah but but here I'm more focusing on

00:08:44,029 --> 00:08:48,230
on technical stuff but we should

00:08:46,759 --> 00:08:53,449
definitely not restrict ourselves to

00:08:48,230 --> 00:08:55,610
that's in the roadmap yeah so make NICs

00:08:53,449 --> 00:08:57,320
a compelling build tools or compelling

00:08:55,610 --> 00:09:02,170
replacement for

00:08:57,320 --> 00:09:05,780
NIC's or basil of make or basil or

00:09:02,170 --> 00:09:08,420
something that can actually compliment

00:09:05,780 --> 00:09:10,250
those tools make the next or

00:09:08,420 --> 00:09:12,500
content-addressable so that's a very

00:09:10,250 --> 00:09:14,960
technical goal but it's it's kind of

00:09:12,500 --> 00:09:16,790
related to all the others making

00:09:14,960 --> 00:09:20,510
expected is discoverable and

00:09:16,790 --> 00:09:24,080
configurable improve the evaluation

00:09:20,510 --> 00:09:26,600
efficiency provide mechanisms to prevent

00:09:24,080 --> 00:09:29,570
closure bloat prevent provide a way to

00:09:26,600 --> 00:09:32,600
store secrets in the Nick store so yeah

00:09:29,570 --> 00:09:37,490
these are just some goals that I would

00:09:32,600 --> 00:09:41,080
like to work on in the next year and to

00:09:37,490 --> 00:09:46,690
some extent I have been working on them

00:09:41,080 --> 00:09:51,530
so the rest of this talk is just some

00:09:46,690 --> 00:09:56,930
random brain dump on on how these goals

00:09:51,530 --> 00:10:00,650
could be achieved so yeah so first the

00:09:56,930 --> 00:10:03,590
gold Nick's as a build tool so so what

00:10:00,650 --> 00:10:05,180
do we need to get to that so in a way

00:10:03,590 --> 00:10:07,010
you can already do this in fact you

00:10:05,180 --> 00:10:08,930
could do that ten years ago in fact

00:10:07,010 --> 00:10:12,230
there is a Nick's make repository

00:10:08,930 --> 00:10:18,770
somewhere which has a bunch of functions

00:10:12,230 --> 00:10:23,060
for building C or C++ projects and and

00:10:18,770 --> 00:10:24,830
that works fine but the problem is so

00:10:23,060 --> 00:10:29,300
now you have your project and you're

00:10:24,830 --> 00:10:32,660
using these Nick's make functions so you

00:10:29,300 --> 00:10:34,700
can run Nick's build to have incremental

00:10:32,660 --> 00:10:35,240
builds for your project and that's so

00:10:34,700 --> 00:10:37,670
great

00:10:35,240 --> 00:10:39,710
so now you want to package this thing

00:10:37,670 --> 00:10:41,660
and put it in the expect juice so you

00:10:39,710 --> 00:10:44,000
make a tarball containing your source

00:10:41,660 --> 00:10:45,920
code and your nick's expression and now

00:10:44,000 --> 00:10:49,460
you want to write an X expression in X

00:10:45,920 --> 00:10:51,800
packages that extracts this tar ball and

00:10:49,460 --> 00:10:53,660
builds it and there you run into the

00:10:51,800 --> 00:10:56,480
problem that you need to be able to call

00:10:53,660 --> 00:10:59,840
Nick's from inside an X build because

00:10:56,480 --> 00:11:01,730
you're using an X expression to to build

00:10:59,840 --> 00:11:05,260
your project so instead of a make file

00:11:01,730 --> 00:11:07,990
so previously you would call make right

00:11:05,260 --> 00:11:09,610
but now you have an annex expression

00:11:07,990 --> 00:11:11,830
that builds your project so you need to

00:11:09,610 --> 00:11:15,460
be able to call Nick's built but you're

00:11:11,830 --> 00:11:18,310
inside a Nick's build already and so so

00:11:15,460 --> 00:11:20,290
and then and Nick's derivation doesn't

00:11:18,310 --> 00:11:22,570
actually have arbitrary right access to

00:11:20,290 --> 00:11:26,440
the next door in fact it only has write

00:11:22,570 --> 00:11:28,450
access to its outputs so so this doesn't

00:11:26,440 --> 00:11:32,740
work so now you have a very embarrassing

00:11:28,450 --> 00:11:35,290
situation so you have a a package that's

00:11:32,740 --> 00:11:37,540
written that has a build system written

00:11:35,290 --> 00:11:39,820
in Nick's but you can't actually put it

00:11:37,540 --> 00:11:41,530
in the next packages you could put it in

00:11:39,820 --> 00:11:45,190
Debian probably but you can't put it in

00:11:41,530 --> 00:11:50,430
the expected system so so this is not

00:11:45,190 --> 00:11:53,970
good so you need need recursive Nick's

00:11:50,430 --> 00:11:58,060
so that's kind of a required feature

00:11:53,970 --> 00:12:01,500
another not essential but very nice to

00:11:58,060 --> 00:12:06,700
have features content address ability

00:12:01,500 --> 00:12:09,940
which I'll come back to and caching of

00:12:06,700 --> 00:12:12,910
copying files to the store so a tool

00:12:09,940 --> 00:12:15,310
like so if you have your project which

00:12:12,910 --> 00:12:17,650
might consist of thousands of source

00:12:15,310 --> 00:12:20,320
files so now every time you run Nick's

00:12:17,650 --> 00:12:22,990
built it has to read all those source

00:12:20,320 --> 00:12:24,790
files and copy them to the Nick store or

00:12:22,990 --> 00:12:27,190
at least check whether they already are

00:12:24,790 --> 00:12:30,310
in the next door so that's a lot of i/o

00:12:27,190 --> 00:12:35,290
and it's slow so a tool like make

00:12:30,310 --> 00:12:37,960
prevent avoids that by only checking

00:12:35,290 --> 00:12:42,220
timestamps and even that can get slow

00:12:37,960 --> 00:12:43,870
for very large projects but yeah Nick's

00:12:42,220 --> 00:12:46,870
needs to hash all these files so it

00:12:43,870 --> 00:12:48,670
actually needs to read all of them so

00:12:46,870 --> 00:12:51,280
you you want to have some kind of

00:12:48,670 --> 00:12:54,670
caching for that and maybe in something

00:12:51,280 --> 00:12:58,210
like an I notify daemon to efficiently

00:12:54,670 --> 00:13:01,680
notice when files change but this is in

00:12:58,210 --> 00:13:01,680
nice-to-haves category

00:13:02,649 --> 00:13:09,170
right so the content addressability this

00:13:05,600 --> 00:13:12,649
is has kind of been uh could say a Holy

00:13:09,170 --> 00:13:16,520
Grail for many years so this is the

00:13:12,649 --> 00:13:19,640
property that should step back for a

00:13:16,520 --> 00:13:22,600
second so if you remember so a Knicks

00:13:19,640 --> 00:13:25,610
store bath contains a cryptographic hash

00:13:22,600 --> 00:13:27,950
but that cryptographic hash is a hash of

00:13:25,610 --> 00:13:29,870
the derivation that built that path it's

00:13:27,950 --> 00:13:34,190
not actually a hash of the content of

00:13:29,870 --> 00:13:37,640
that path and and and this is why you

00:13:34,190 --> 00:13:40,850
need signatures on binary caches because

00:13:37,640 --> 00:13:43,250
you need to trust that some store path

00:13:40,850 --> 00:13:46,730
was actually produced by the derivation

00:13:43,250 --> 00:13:49,190
that it claims to be built by and that

00:13:46,730 --> 00:13:54,830
could be a lie so somebody could set up

00:13:49,190 --> 00:13:57,350
a binary cache where so you you you you

00:13:54,830 --> 00:13:59,240
get a legitimate NICs expression so

00:13:57,350 --> 00:14:01,190
that's for example builds Firefox and

00:13:59,240 --> 00:14:02,540
then you pull a binder from the cache

00:14:01,190 --> 00:14:04,070
that actually contains something

00:14:02,540 --> 00:14:08,180
completely different like a Trojan

00:14:04,070 --> 00:14:13,040
version of Firefox so that's why you

00:14:08,180 --> 00:14:16,459
need signatures so in a content

00:14:13,040 --> 00:14:18,589
reversible store the store path so the

00:14:16,459 --> 00:14:21,200
hash in the store path is actually a

00:14:18,589 --> 00:14:24,410
hash of the contents of that path so you

00:14:21,200 --> 00:14:26,360
no longer need to trust anything so you

00:14:24,410 --> 00:14:29,330
can just verify that for example in a

00:14:26,360 --> 00:14:32,029
path like this Nick stores cash you just

00:14:29,330 --> 00:14:36,830
check that the cryptographic hash of the

00:14:32,029 --> 00:14:39,230
contents of this path is this so a path

00:14:36,830 --> 00:14:45,160
basically contains its own proof of

00:14:39,230 --> 00:14:49,270
integrity so if you have this then yeah

00:14:45,160 --> 00:14:53,720
unprivileged users can install things

00:14:49,270 --> 00:14:55,490
from arbitrary binary caches another

00:14:53,720 --> 00:15:01,040
very big advantage is that you get

00:14:55,490 --> 00:15:02,899
deduplication so for example if you say

00:15:01,040 --> 00:15:05,180
you make an irrelevant change to

00:15:02,899 --> 00:15:09,020
something in the dependency graph like

00:15:05,180 --> 00:15:11,810
you you make a whitespace change to G

00:15:09,020 --> 00:15:15,710
Lipsy so currently that causes the

00:15:11,810 --> 00:15:17,690
entire system to be rebuilt which is bad

00:15:15,710 --> 00:15:22,490
and and actually yeah not just rebuilt

00:15:17,690 --> 00:15:27,080
but duplicated in the nick store so you

00:15:22,490 --> 00:15:30,170
need twice the storage space now whereas

00:15:27,080 --> 00:15:31,910
with a content-addressable store so

00:15:30,170 --> 00:15:33,350
because this change is irrelevant it

00:15:31,910 --> 00:15:36,260
doesn't actually change anything to the

00:15:33,350 --> 00:15:39,529
output of a build it ends up being

00:15:36,260 --> 00:15:42,620
stored in the same location so that's

00:15:39,529 --> 00:15:44,980
that's much nicer and in fact it it does

00:15:42,620 --> 00:15:47,990
prevent rebuilds because if for instance

00:15:44,980 --> 00:15:50,660
so you make that change to GFC you still

00:15:47,990 --> 00:15:53,570
need to recompile gilepsy to discover

00:15:50,660 --> 00:15:55,490
that that change doesn't matter but

00:15:53,570 --> 00:15:58,760
after that you don't need to rebuild

00:15:55,490 --> 00:16:02,000
anything that depends on it because

00:15:58,760 --> 00:16:06,560
you've already discovered that yeah this

00:16:02,000 --> 00:16:09,170
GFC is actually the same so so so so it

00:16:06,560 --> 00:16:15,320
sort of acts as a barrier in the in the

00:16:09,170 --> 00:16:17,839
dependency graph yeah so this is why

00:16:15,320 --> 00:16:20,390
content addressability would be a great

00:16:17,839 --> 00:16:21,650
feature to have there's a few

00:16:20,390 --> 00:16:24,290
interesting things about content

00:16:21,650 --> 00:16:28,750
addressability it to make this work

00:16:24,290 --> 00:16:30,950
properly it really needs perfect binary

00:16:28,750 --> 00:16:33,980
reproducibility so that's currently not

00:16:30,950 --> 00:16:36,290
the case with Nix packages so if you

00:16:33,980 --> 00:16:39,050
build a package twice you might actually

00:16:36,290 --> 00:16:40,970
end up with slightly different results

00:16:39,050 --> 00:16:45,080
so for example if a binary stores a

00:16:40,970 --> 00:16:48,890
timestamp somewhere but yeah a lot of

00:16:45,080 --> 00:16:50,720
people are at work to improve that so

00:16:48,890 --> 00:16:51,200
for example there's a whole reproducible

00:16:50,720 --> 00:16:57,310
builds

00:16:51,200 --> 00:17:00,770
or ik project that's that's yeah

00:16:57,310 --> 00:17:04,280
basically improving all sorts of

00:17:00,770 --> 00:17:10,689
packages and build systems to to

00:17:04,280 --> 00:17:10,689
eliminate sources of binary impurity

00:17:11,660 --> 00:17:19,890
okay so for the other thing so yeah

00:17:14,579 --> 00:17:21,510
prevent preventing closure bloat so this

00:17:19,890 --> 00:17:24,800
is something of an obsession of mine

00:17:21,510 --> 00:17:29,220
sorry about it

00:17:24,800 --> 00:17:31,710
so NYX because of the way it detects it

00:17:29,220 --> 00:17:33,840
finds dependencies it's very easy to

00:17:31,710 --> 00:17:36,930
have an accidental dependency so this is

00:17:33,840 --> 00:17:39,510
not the case in say Debian where you

00:17:36,930 --> 00:17:42,450
specify the dependency so you don't end

00:17:39,510 --> 00:17:45,360
up with an accidental runtime dependency

00:17:42,450 --> 00:17:47,540
and say the C compiler so here for

00:17:45,360 --> 00:17:51,060
example there was a situation where

00:17:47,540 --> 00:17:53,670
Thunderbird was storing its build

00:17:51,060 --> 00:17:56,100
configuration so you can do about config

00:17:53,670 --> 00:17:58,320
in the URL bar and it will show you the

00:17:56,100 --> 00:18:02,610
path to the C compiler used to compile

00:17:58,320 --> 00:18:06,690
it which is of course kind of a useless

00:18:02,610 --> 00:18:11,540
thing but it does add twelve hundred

00:18:06,690 --> 00:18:14,030
megabytes of blow to the closure and

00:18:11,540 --> 00:18:16,170
yeah so this can happen very

00:18:14,030 --> 00:18:19,560
accidentally you don't get any errors if

00:18:16,170 --> 00:18:24,210
you do that so yeah we need better tools

00:18:19,560 --> 00:18:25,830
to - yeah detect when this happens so we

00:18:24,210 --> 00:18:28,620
already have some attributes that you

00:18:25,830 --> 00:18:30,390
can specify in in Nick's expressions for

00:18:28,620 --> 00:18:33,390
example you can say disallowed

00:18:30,390 --> 00:18:36,900
requisites to say that something should

00:18:33,390 --> 00:18:40,770
not have a runtime reference to say the

00:18:36,900 --> 00:18:42,180
C compiler but this is very limited for

00:18:40,770 --> 00:18:45,090
example you cannot do any pattern

00:18:42,180 --> 00:18:47,760
matching and you would like to say this

00:18:45,090 --> 00:18:52,170
thing should not have any references to

00:18:47,760 --> 00:18:54,840
developer outputs and it should be per

00:18:52,170 --> 00:18:57,480
output because for example your death

00:18:54,840 --> 00:19:02,040
output probably should be allowed to

00:18:57,480 --> 00:19:03,990
have references to other def outputs and

00:19:02,040 --> 00:19:06,660
and you might want to have a size check

00:19:03,990 --> 00:19:10,410
so for example if say the Nexus ISO

00:19:06,660 --> 00:19:16,200
suddenly gets a gigabyte bigger than we

00:19:10,410 --> 00:19:19,350
would like to get some error so what I

00:19:16,200 --> 00:19:20,880
recently implemented partially not all

00:19:19,350 --> 00:19:22,290
of this works yet is that you can

00:19:20,880 --> 00:19:25,350
specify

00:19:22,290 --> 00:19:29,250
per output check so for example you can

00:19:25,350 --> 00:19:31,799
say the outputs the out output should

00:19:29,250 --> 00:19:33,990
not have a closure bigger than 256

00:19:31,799 --> 00:19:36,570
megabytes it should not be should not

00:19:33,990 --> 00:19:40,380
reference the C compiler or any def

00:19:36,570 --> 00:19:43,440
output but the DEF output itself can

00:19:40,380 --> 00:19:47,940
reference anything but it should not be

00:19:43,440 --> 00:19:53,250
larger than 128 kilobytes as a random

00:19:47,940 --> 00:19:55,710
example so yeah so we can start putting

00:19:53,250 --> 00:19:57,750
these things in NYX packages it could

00:19:55,710 --> 00:19:59,780
even be a generic thing so for example

00:19:57,750 --> 00:20:03,570
the rule that things should not allow

00:19:59,780 --> 00:20:05,010
should not be allowed to reference def

00:20:03,570 --> 00:20:09,780
outputs is something you could actually

00:20:05,010 --> 00:20:15,590
put in standard and so as a general

00:20:09,780 --> 00:20:15,590
policy so yeah that would be very nice

00:20:16,520 --> 00:20:24,070
am i doing on time actually I can just

00:20:20,580 --> 00:20:28,899
check okay

00:20:24,070 --> 00:20:31,929
Wow right so yeah now I come to the

00:20:28,899 --> 00:20:38,379
really wild and paper where part of to

00:20:31,929 --> 00:20:40,629
talk so so yeah really a big issue is

00:20:38,379 --> 00:20:43,539
discoverability and efficiency like I

00:20:40,629 --> 00:20:45,669
mentioned so NYX packages have basically

00:20:43,539 --> 00:20:48,399
no discoverability well I mean you can

00:20:45,669 --> 00:20:50,979
discover that they exist sometimes I

00:20:48,399 --> 00:20:53,679
mean nixon's doesn't necessarily recurse

00:20:50,979 --> 00:20:55,509
into everything but so you can see that

00:20:53,679 --> 00:21:00,129
packages exist we can see what options

00:20:55,509 --> 00:21:03,999
they have and customizing packages is

00:21:00,129 --> 00:21:06,070
also very ad hoc it sort of evolved it's

00:21:03,999 --> 00:21:08,619
not really a properly designed thing so

00:21:06,070 --> 00:21:14,529
if these things like dot overrides dot

00:21:08,619 --> 00:21:17,279
over I derivation config and and in fact

00:21:14,529 --> 00:21:21,279
this this whole dot override thing is

00:21:17,279 --> 00:21:25,090
kind of disastrous for for performance

00:21:21,279 --> 00:21:27,399
so it's really one of them it's one of

00:21:25,090 --> 00:21:31,299
the two main reasons why Nicks

00:21:27,399 --> 00:21:35,080
evaluation takes a lot of memory so so

00:21:31,299 --> 00:21:37,389
dot overrides basically destroys the

00:21:35,080 --> 00:21:39,789
ability of the garbage collector at

00:21:37,389 --> 00:21:42,609
runtime to actually collect any garbage

00:21:39,789 --> 00:21:45,099
because you call a function so you pass

00:21:42,609 --> 00:21:47,440
it some arguments which can be very big

00:21:45,099 --> 00:21:53,859
because there are arbitrary dependencies

00:21:47,440 --> 00:21:55,960
or large graph and and then the output

00:21:53,859 --> 00:21:59,320
just contains the inputs so the inputs

00:21:55,960 --> 00:22:02,259
can never be garbage collected so this

00:21:59,320 --> 00:22:08,190
is this was yeah kind of a bad idea but

00:22:02,259 --> 00:22:08,190
we don't really have anything better so

00:22:09,289 --> 00:22:15,080
it's kind of a meta issue here of all

00:22:12,710 --> 00:22:17,570
these things so somewhere along the way

00:22:15,080 --> 00:22:22,179
we forgot that NYX is intended as a

00:22:17,570 --> 00:22:25,100
domain-specific language for specifying

00:22:22,179 --> 00:22:29,510
build graphs and configurations like

00:22:25,100 --> 00:22:31,789
like knixwear systems but as a DSL it's

00:22:29,510 --> 00:22:33,860
not really doing a great job so for

00:22:31,789 --> 00:22:37,090
example it has no concept of a package

00:22:33,860 --> 00:22:40,370
or an option or a configuration or

00:22:37,090 --> 00:22:42,710
things like plugins so any sort of

00:22:40,370 --> 00:22:46,460
feature issue or concepts you might

00:22:42,710 --> 00:22:50,809
expect in a DSL intended for doing these

00:22:46,460 --> 00:22:55,480
things so so maybe we need to get back

00:22:50,809 --> 00:22:58,519
to what we need to improve NICs as a DSL

00:22:55,480 --> 00:23:04,460
so so one thing that I've been thinking

00:22:58,519 --> 00:23:06,470
about is so essentially turning the NIC

00:23:04,460 --> 00:23:08,830
Soyuz module system or an improved

00:23:06,470 --> 00:23:11,720
version of it into a language feature

00:23:08,830 --> 00:23:13,880
into something called a configuration

00:23:11,720 --> 00:23:16,429
which you can really think of as an

00:23:13,880 --> 00:23:18,789
attribute set an extensible attribute

00:23:16,429 --> 00:23:21,559
set which is really what an XS

00:23:18,789 --> 00:23:25,279
configuration is it's it's a bunch of

00:23:21,559 --> 00:23:27,559
attributes that you can change and so if

00:23:25,279 --> 00:23:35,690
you change one attribute it can trigger

00:23:27,559 --> 00:23:37,580
other attributes to change yeah so so a

00:23:35,690 --> 00:23:38,929
configuration is attribute set which

00:23:37,580 --> 00:23:41,899
contains attributes called

00:23:38,929 --> 00:23:43,750
options that can be set and they can be

00:23:41,899 --> 00:23:47,960
overwritten later

00:23:43,750 --> 00:23:50,269
but unlike attribute set and like mixes

00:23:47,960 --> 00:23:53,240
options they can have types and

00:23:50,269 --> 00:23:54,710
documentation and merge functions and

00:23:53,240 --> 00:23:58,639
and that's the thing that gives you

00:23:54,710 --> 00:24:01,490
discoverability so things like package

00:23:58,639 --> 00:24:03,830
options can be expressed in this way and

00:24:01,490 --> 00:24:08,330
because they have things like a

00:24:03,830 --> 00:24:09,980
description and a type tools goods can

00:24:08,330 --> 00:24:12,649
discover them and present them to the

00:24:09,980 --> 00:24:16,140
user and then allow them to be changed

00:24:12,649 --> 00:24:21,809
program act programmatically

00:24:16,140 --> 00:24:24,390
so so the sketchy design for this

00:24:21,809 --> 00:24:27,059
language feature is a bit like this so a

00:24:24,390 --> 00:24:29,760
configuration looks a lot like an

00:24:27,059 --> 00:24:33,929
attribute set only it uses angled

00:24:29,760 --> 00:24:40,530
brackets my change don't get too angry

00:24:33,929 --> 00:24:42,090
or NSTIC about the syntax but yeah so

00:24:40,530 --> 00:24:43,559
it's a you could think of it as an

00:24:42,090 --> 00:24:46,110
attribute set so we have an attribute

00:24:43,559 --> 00:24:49,050
foo natural bar and an attribute ABC

00:24:46,110 --> 00:24:51,110
that actually refers to foo and bar so

00:24:49,050 --> 00:24:55,380
it's a recursive it's like a rec

00:24:51,110 --> 00:24:59,100
attribute set so if from this thing you

00:24:55,380 --> 00:25:03,300
select the ABC attribute you would get a

00:24:59,100 --> 00:25:07,559
value 1 2 3 because bar is true so if if

00:25:03,300 --> 00:25:11,429
true then 1 2 3 right but what you can

00:25:07,559 --> 00:25:15,929
now do is take that configuration module

00:25:11,429 --> 00:25:19,590
and apply an a new module to it that

00:25:15,929 --> 00:25:23,040
sets bar to false and so now if from

00:25:19,590 --> 00:25:28,710
this module you select ABC then it will

00:25:23,040 --> 00:25:32,429
return a false then it goes to 1 2 3

00:25:28,710 --> 00:25:35,010
times 2 so it will return to 4 6 so this

00:25:32,429 --> 00:25:42,480
is pretty much exactly the behavior of

00:25:35,010 --> 00:25:44,190
the mixers module system yeah and then

00:25:42,480 --> 00:25:47,250
the idea is that you can have some sort

00:25:44,190 --> 00:25:52,800
of syntax which I'm not sure about

00:25:47,250 --> 00:25:55,640
but to attach fields or annotations to

00:25:52,800 --> 00:25:58,620
those to those options like

00:25:55,640 --> 00:26:04,350
documentation a type default value and

00:25:58,620 --> 00:26:06,390
so on merge functions priorities yeah

00:26:04,350 --> 00:26:08,190
all that sort of thing Oh basically all

00:26:06,390 --> 00:26:10,580
the finish within the mixers module

00:26:08,190 --> 00:26:10,580
system

00:26:13,250 --> 00:26:19,200
right but now the idea is that we can

00:26:16,080 --> 00:26:22,610
apply this to building packages so

00:26:19,200 --> 00:26:27,360
rather than having packages as functions

00:26:22,610 --> 00:26:30,090
which have the problem that well there's

00:26:27,360 --> 00:26:31,590
no override mechanism I mean no good

00:26:30,090 --> 00:26:37,110
override mechanism there's no

00:26:31,590 --> 00:26:40,110
documentation and so on we can basically

00:26:37,110 --> 00:26:43,380
treat packages in the same way as the

00:26:40,110 --> 00:26:46,080
Nexus module system treats system

00:26:43,380 --> 00:26:48,890
configurations so you you build a

00:26:46,080 --> 00:26:51,390
package in sort of a modular way by

00:26:48,890 --> 00:26:54,900
combining a bunch of modules so for

00:26:51,390 --> 00:26:57,290
example you could have a very sort of at

00:26:54,900 --> 00:27:00,150
the bottom you have a module that

00:26:57,290 --> 00:27:03,299
captures the concept of a derivation so

00:27:00,150 --> 00:27:06,150
what is a derivation well derivation

00:27:03,299 --> 00:27:08,640
niks as a name and a version and it has

00:27:06,150 --> 00:27:11,970
a builder and it's as arguments and it

00:27:08,640 --> 00:27:14,460
as an environment and if you set those

00:27:11,970 --> 00:27:19,020
things then you can evaluate a

00:27:14,460 --> 00:27:23,700
derivation attribute which produces a

00:27:19,020 --> 00:27:27,000
low level derivation so so this is very

00:27:23,700 --> 00:27:29,340
low level but now you can build higher

00:27:27,000 --> 00:27:31,830
level modules on top of that so for

00:27:29,340 --> 00:27:35,130
example this thing basically expresses

00:27:31,830 --> 00:27:40,080
the basic standard environment so the

00:27:35,130 --> 00:27:42,870
concept of phases and dependencies on

00:27:40,080 --> 00:27:45,059
our packages so this thing adds a an

00:27:42,870 --> 00:27:49,320
option called built inputs and an option

00:27:45,059 --> 00:27:53,100
called phases and it's it implements

00:27:49,320 --> 00:27:56,910
this on top of the lower level

00:27:53,100 --> 00:28:03,360
derivation module by setting builder and

00:27:56,910 --> 00:28:07,140
arcs and NF and that's causes derivation

00:28:03,360 --> 00:28:10,890
to be computed yeah that uses these

00:28:07,140 --> 00:28:13,049
things so just to continue this a bit so

00:28:10,890 --> 00:28:15,270
you could have a module that captures

00:28:13,049 --> 00:28:17,250
the concept of a package or package has

00:28:15,270 --> 00:28:19,650
a description and the home page and so

00:28:17,250 --> 00:28:21,450
on and all these things have had

00:28:19,650 --> 00:28:24,820
descriptions and they have types so

00:28:21,450 --> 00:28:26,860
they're they're discoverable

00:28:24,820 --> 00:28:30,010
and and you get error message if so for

00:28:26,860 --> 00:28:31,960
example if if you use this previous so

00:28:30,010 --> 00:28:35,039
currently with derivation Ziff for

00:28:31,960 --> 00:28:38,250
example you you misspelled build inputs

00:28:35,039 --> 00:28:41,260
you're not going to get an error because

00:28:38,250 --> 00:28:44,610
nix derivation is basically just a bunch

00:28:41,260 --> 00:28:47,620
of environments variable bindings so

00:28:44,610 --> 00:28:51,130
yeah so there's no checking whatsoever

00:28:47,620 --> 00:28:54,940
there but here if you set an an option

00:28:51,130 --> 00:28:56,409
that hasn't been declared then you get

00:28:54,940 --> 00:29:01,710
an error message it's just like in the

00:28:56,409 --> 00:29:03,940
in the module system yeah so you can

00:29:01,710 --> 00:29:05,529
build higher and higher level

00:29:03,940 --> 00:29:09,370
abstractions on this so for example you

00:29:05,529 --> 00:29:11,230
can extend the sort of generic standard

00:29:09,370 --> 00:29:13,360
environment with the concept of a UNIX

00:29:11,230 --> 00:29:15,820
package which for example has a

00:29:13,360 --> 00:29:19,809
configure face and because it runs a

00:29:15,820 --> 00:29:22,330
configure script yeah and then finally

00:29:19,809 --> 00:29:24,429
you can define a package so a package is

00:29:22,330 --> 00:29:27,179
something that extends the UNIX package

00:29:24,429 --> 00:29:33,340
module with something that sets a name

00:29:27,179 --> 00:29:37,000
description source but it also has its

00:29:33,340 --> 00:29:39,600
own option namely enable GUI so in this

00:29:37,000 --> 00:29:43,270
fictional example a hello world has a

00:29:39,600 --> 00:29:48,549
gtk support so now you can say built-in

00:29:43,270 --> 00:29:50,940
Putz's if enabled GUI then use gtk and

00:29:48,549 --> 00:29:54,460
and this thing is now discoverable so

00:29:50,940 --> 00:29:57,010
you could have say a next query package

00:29:54,460 --> 00:30:00,549
command which will show that this thing

00:29:57,010 --> 00:30:04,659
has an enable GUI option and you could

00:30:00,549 --> 00:30:10,720
have an ex install command that that

00:30:04,659 --> 00:30:12,940
allows you to set that option so yeah

00:30:10,720 --> 00:30:14,919
and and you could overwrite things using

00:30:12,940 --> 00:30:20,919
the exact same module system so that's

00:30:14,919 --> 00:30:23,649
just like in Nix OS so that's about it

00:30:20,919 --> 00:30:26,169
so there are lots of other things you

00:30:23,649 --> 00:30:30,070
could imagine for the roadmap I'll skip

00:30:26,169 --> 00:30:33,679
that so yeah so what I should do is

00:30:30,070 --> 00:30:38,630
create a sort of a roadmap issue

00:30:33,679 --> 00:30:40,340
and where everybody can go wild with IDs

00:30:38,630 --> 00:30:43,520
and suggestions and then we should try

00:30:40,340 --> 00:30:51,429
to synthesize something workable from

00:30:43,520 --> 00:30:51,429
that yeah that's it

00:30:52,370 --> 00:31:02,420
[Applause]

00:31:17,980 --> 00:31:23,080
so for the configurations idea use it

00:31:21,490 --> 00:31:24,399
doing overrides how does that solve the

00:31:23,080 --> 00:31:26,620
memory issue don't you still need to

00:31:24,399 --> 00:31:30,480
hold on to the references it's all the

00:31:26,620 --> 00:31:35,830
inputs no because as soon as you

00:31:30,480 --> 00:31:37,600
evaluates the dot DRV attribute you

00:31:35,830 --> 00:31:41,159
don't need anything else anymore you can

00:31:37,600 --> 00:31:43,539
add that after that you can just discard

00:31:41,159 --> 00:31:46,690
everything that went into it so that's

00:31:43,539 --> 00:31:50,110
like an express if you evaluate system

00:31:46,690 --> 00:31:53,830
dot bill dot top-level you get a

00:31:50,110 --> 00:31:55,630
derivation out of that and a and at that

00:31:53,830 --> 00:31:56,649
point you can garbage collects all the

00:31:55,630 --> 00:31:58,210
inputs to that thing

00:31:56,649 --> 00:31:59,590
so like the when when you're passing

00:31:58,210 --> 00:32:01,360
something as an input to something else

00:31:59,590 --> 00:32:05,950
you're passing in the dot DRV not the

00:32:01,360 --> 00:32:11,529
composable right so presumably this is

00:32:05,950 --> 00:32:16,860
all fiction so so here this gtk thing

00:32:11,529 --> 00:32:19,860
would trigger an evaluation of gtk DRV

00:32:16,860 --> 00:32:19,860
implicitly

00:32:23,660 --> 00:32:28,140
on the slide about the Knicks is a bill

00:32:26,370 --> 00:32:32,190
to you have been talking about avoiding

00:32:28,140 --> 00:32:36,060
rebuilds and similar properties have you

00:32:32,190 --> 00:32:38,760
looked in to the recent paper built

00:32:36,060 --> 00:32:41,160
systems a la carte by new mutual Simon

00:32:38,760 --> 00:32:43,380
Johnson Andrey Markov they're analyzing

00:32:41,160 --> 00:32:44,340
variable system there and it is one of

00:32:43,380 --> 00:32:48,900
them and Knicks

00:32:44,340 --> 00:32:52,020
tix of almost all features of the Ultima

00:32:48,900 --> 00:32:58,620
build system was that the ICF P paper

00:32:52,020 --> 00:33:01,620
yes okay it's okay please take a look at

00:32:58,620 --> 00:33:03,600
this it gives very good names a good

00:33:01,620 --> 00:33:06,890
glossary to talk about properties it's a

00:33:03,600 --> 00:33:06,890
great paper thank you

00:33:11,520 --> 00:33:29,040
so the configuration options it excites

00:33:18,810 --> 00:33:30,660
the type system in me is the also so the

00:33:29,040 --> 00:33:34,200
NIC service module system also supports

00:33:30,660 --> 00:33:37,070
the notion of overlays this is their

00:33:34,200 --> 00:33:40,590
version of this also in this or is this

00:33:37,070 --> 00:33:42,960
extension yeah probably so that sort of

00:33:40,590 --> 00:33:44,940
a high-level thing that I haven't

00:33:42,960 --> 00:33:49,710
figured out yet so how he actually put

00:33:44,940 --> 00:33:54,150
these things together so I but you need

00:33:49,710 --> 00:33:59,550
some way to do that and yeah so I don't

00:33:54,150 --> 00:34:05,640
know yet okay yeah I think we've got to

00:33:59,550 --> 00:34:08,159
move maybe one more last one it's more

00:34:05,640 --> 00:34:11,700
of a policy question I've seen a lot of

00:34:08,159 --> 00:34:14,850
commits like fixing Thunderbird like you

00:34:11,700 --> 00:34:18,360
showed and there has been committed for

00:34:14,850 --> 00:34:21,179
every separate packages

00:34:18,360 --> 00:34:23,850
why don't you enforce this kind of like

00:34:21,179 --> 00:34:26,550
do not reference GCC for all the

00:34:23,850 --> 00:34:28,200
packages by default and then if some

00:34:26,550 --> 00:34:31,020
package really needs GCC then you could

00:34:28,200 --> 00:34:32,970
enable it right well that's kind of the

00:34:31,020 --> 00:34:35,940
point so we don't have a way really to

00:34:32,970 --> 00:34:36,920
enforce that yet so right now it's

00:34:35,940 --> 00:34:41,450
really only if

00:34:36,920 --> 00:34:46,640
sort of notice that suddenly a closure

00:34:41,450 --> 00:34:49,310
has become much bigger so you can use

00:34:46,640 --> 00:34:51,560
these disallowed requisites attributes

00:34:49,310 --> 00:34:54,410
but very few packages do that but you

00:34:51,560 --> 00:34:56,300
could use that by default like under 2m

00:34:54,410 --> 00:34:58,250
key derivation and then by default just

00:34:56,300 --> 00:35:00,470
do not difference GCC there is no reason

00:34:58,250 --> 00:35:03,740
for most packages to do so right and so

00:35:00,470 --> 00:35:05,540
probably for GCC that would work but you

00:35:03,740 --> 00:35:08,450
really want to say things like it should

00:35:05,540 --> 00:35:09,920
not reference any death output and and

00:35:08,450 --> 00:35:11,750
that doesn't work at the moment because

00:35:09,920 --> 00:35:13,820
death output should be allowed to

00:35:11,750 --> 00:35:18,290
reference half output so you can't use

00:35:13,820 --> 00:35:19,790
the existing attributes for that and but

00:35:18,290 --> 00:35:21,800
yeah so I would definitely like to have

00:35:19,790 --> 00:35:26,030
an index West for example that we say

00:35:21,800 --> 00:35:28,070
that all the Knicks OS VM tests could

00:35:26,030 --> 00:35:34,030
just check that their closures don't

00:35:28,070 --> 00:35:37,850
have any def outputs in them and and now

00:35:34,030 --> 00:35:40,540
GCC or clang so that that would already

00:35:37,850 --> 00:35:45,260
help quite a bit

00:35:40,540 --> 00:35:46,860
ok already so thank you again for your

00:35:45,260 --> 00:35:52,949
talk

00:35:46,860 --> 00:35:52,949

YouTube URL: https://www.youtube.com/watch?v=8M6yvJC00J4


