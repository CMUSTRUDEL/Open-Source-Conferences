Title: Shea Levy - require.nix: dependency management for your favorite (NixCon 2018)
Publication date: 2018-11-06
Playlist: NixCon 2018 (London)
Description: 
	Nix is a fantastic tool for managing the dependencies of your development projects, but ironically the Nix language itself has very limited facilities for modular code reuse and composition. In this talk, I will present on my recent experiments with a system, inspired by node.js's "require" mechanism, to define packages of nix language code that can depend on other packages. Together with conventions encouraging detailed documentation, good error messages, and clean interfaces, I hope this project can form the seed for a robust ecosystem of libraries and tools that can help move us past the monolith of nixpkgs and enable us to more easily benefit from each others' work. --- Bio: Shea is a lead engineer at Target's data science and optimization group, whose production stack is built with Nix. He has been part of the NixOS community since 2010, has been working professionally with Nix since 2012, and is part of the Nix core team.
Captions: 
	00:00:00,000 --> 00:00:06,500
all righty so next up is Shay Shay is

00:00:02,460 --> 00:00:12,030
working at Target one of our sponsors

00:00:06,500 --> 00:00:15,509
and Shay is also Linux core team that

00:00:12,030 --> 00:00:17,789
was created not too long ago and Shay is

00:00:15,509 --> 00:00:19,529
gonna take us on some sort of inception

00:00:17,789 --> 00:00:22,170
kind of right talking about the

00:00:19,529 --> 00:00:24,480
dependency manager for the dependency

00:00:22,170 --> 00:00:34,050
manager I'm looking forward to it give

00:00:24,480 --> 00:00:36,750
him a round of applause hi thank you as

00:00:34,050 --> 00:00:39,350
I said I'm Shay work at Target been

00:00:36,750 --> 00:00:41,250
working with Nix for quite a while and

00:00:39,350 --> 00:00:43,739
required it next as a project that's

00:00:41,250 --> 00:00:45,329
come out of problems I've seen using

00:00:43,739 --> 00:00:47,789
Nick's especially in professional

00:00:45,329 --> 00:00:50,640
settings for managing development and

00:00:47,789 --> 00:00:52,170
deployment life cycles so before I get

00:00:50,640 --> 00:00:53,129
to what to work for acquired at next is

00:00:52,170 --> 00:00:56,550
I'm gonna go through some of the

00:00:53,129 --> 00:00:59,820
problems I've seen that inspired it so

00:00:56,550 --> 00:01:02,820
first status quo of what exists in the

00:00:59,820 --> 00:01:05,850
next world today is we're a community of

00:01:02,820 --> 00:01:07,260
monolithic entry points so almost every

00:01:05,850 --> 00:01:09,420
Nick's expression in the world outside

00:01:07,260 --> 00:01:11,640
of next packages has this line at the

00:01:09,420 --> 00:01:14,430
top and all of the useful interesting

00:01:11,640 --> 00:01:15,630
functionality is pulled from there or

00:01:14,430 --> 00:01:17,130
maybe if you're a little bit more

00:01:15,630 --> 00:01:19,110
sophisticated you'll have built-ins dot

00:01:17,130 --> 00:01:21,390
fetch get or your company will have its

00:01:19,110 --> 00:01:23,310
own mixed packages fork or sometimes

00:01:21,390 --> 00:01:24,930
you'll have a company Nick's repo or if

00:01:23,310 --> 00:01:27,780
your company has a mono repo then it'll

00:01:24,930 --> 00:01:30,390
have a big mono repo but either way this

00:01:27,780 --> 00:01:32,250
is really for the most part your Nix

00:01:30,390 --> 00:01:35,040
projects will all revolve around some

00:01:32,250 --> 00:01:39,540
big central repository of all Nick's

00:01:35,040 --> 00:01:42,000
functionality why this is a problem just

00:01:39,540 --> 00:01:44,130
this is about to get political I'm gonna

00:01:42,000 --> 00:01:46,710
make a stand on mono repo versus poly

00:01:44,130 --> 00:01:52,110
repo for our context in this world not

00:01:46,710 --> 00:01:53,820
in general mana our current workflow or

00:01:52,110 --> 00:01:55,409
especially next packages but even

00:01:53,820 --> 00:01:58,259
outside of it leads to very tightly

00:01:55,409 --> 00:01:59,520
coupled development all everything

00:01:58,259 --> 00:02:02,250
within Nick's packages is kind of

00:01:59,520 --> 00:02:03,420
updated at once atomically which sort of

00:02:02,250 --> 00:02:04,829
makes sense because you want everything

00:02:03,420 --> 00:02:06,750
to work together but it means the

00:02:04,829 --> 00:02:08,610
interfaces between our components are

00:02:06,750 --> 00:02:10,649
very blurred if you make a standard end

00:02:08,610 --> 00:02:12,240
change you can just change all of the

00:02:10,649 --> 00:02:13,590
packages that breaks in one commit

00:02:12,240 --> 00:02:15,660
and you never have to think about like

00:02:13,590 --> 00:02:18,390
was that a good interface to begin with

00:02:15,660 --> 00:02:21,390
and is this change going to be usable

00:02:18,390 --> 00:02:23,760
for external users etc it's hard to

00:02:21,390 --> 00:02:25,380
compose in the sense of we have many

00:02:23,760 --> 00:02:28,200
different functionalities within NICs

00:02:25,380 --> 00:02:30,870
packages and I can't easily say I want

00:02:28,200 --> 00:02:33,780
the I certainly can't say I want like

00:02:30,870 --> 00:02:35,430
the Haskell builder from 1803 but within

00:02:33,780 --> 00:02:37,020
the package set of 1809 that's certainly

00:02:35,430 --> 00:02:38,760
not possible but even the Haskell

00:02:37,020 --> 00:02:40,770
builder of a few weeks ago probably

00:02:38,760 --> 00:02:45,270
won't work and it's also technically

00:02:40,770 --> 00:02:47,010
very difficult to actually plug it in we

00:02:45,270 --> 00:02:48,810
also kind of accumulate a bunch of

00:02:47,010 --> 00:02:51,150
responsibilities within next packages so

00:02:48,810 --> 00:02:53,370
we do experiment and we also have our

00:02:51,150 --> 00:02:55,080
stable package set and we have a lot of

00:02:53,370 --> 00:02:56,820
different kind of functionalities and

00:02:55,080 --> 00:02:59,640
different components as I was saying

00:02:56,820 --> 00:03:02,250
about and they all exist within one file

00:02:59,640 --> 00:03:05,190
system tree one set of process for

00:03:02,250 --> 00:03:07,890
managing the system for stable stable

00:03:05,190 --> 00:03:10,470
updates for pull requests for governance

00:03:07,890 --> 00:03:13,890
all of that everything is kind of bound

00:03:10,470 --> 00:03:16,260
by the same system when we have this

00:03:13,890 --> 00:03:17,730
sort of mix of things so for example I

00:03:16,260 --> 00:03:19,640
don't know if you guys have been

00:03:17,730 --> 00:03:21,930
following John Erickson's work on

00:03:19,640 --> 00:03:24,450
improving cross compilation and standard

00:03:21,930 --> 00:03:27,450
and a big difficulty he's run into that

00:03:24,450 --> 00:03:29,250
I've seen is he has to kind of shove the

00:03:27,450 --> 00:03:30,660
work he's doing into the flow of Nyx

00:03:29,250 --> 00:03:33,330
packages without breaking too many

00:03:30,660 --> 00:03:35,460
things and without causing too much

00:03:33,330 --> 00:03:37,020
disruption at once because there's no

00:03:35,460 --> 00:03:42,110
good way for him to iterate on standard

00:03:37,020 --> 00:03:44,730
and independently of of Nyx packages and

00:03:42,110 --> 00:03:47,220
kind of back to a rock was talking about

00:03:44,730 --> 00:03:48,750
earlier to in his talk maybe was

00:03:47,220 --> 00:03:52,170
yesterday I can't even remember where

00:03:48,750 --> 00:03:54,090
within the next world we can get the

00:03:52,170 --> 00:03:56,370
benefits of a mono repo without a

00:03:54,090 --> 00:04:00,000
without actually having a mono repo by

00:03:56,370 --> 00:04:02,250
tying everything together at the top in

00:04:00,000 --> 00:04:03,750
principle we could do that same kind of

00:04:02,250 --> 00:04:05,700
thing with Nix packages where Nix

00:04:03,750 --> 00:04:07,620
packages remains where everything is

00:04:05,700 --> 00:04:11,120
integrated in together and the actual

00:04:07,620 --> 00:04:13,350
sort of trusted said of the world but

00:04:11,120 --> 00:04:15,890
the individual components are built

00:04:13,350 --> 00:04:18,210
independently on their own time frame so

00:04:15,890 --> 00:04:20,910
this is the main thing that pushed me

00:04:18,210 --> 00:04:22,890
but there are a few other things that I

00:04:20,910 --> 00:04:24,650
think can be solved with required an

00:04:22,890 --> 00:04:26,400
expert I also have not yet described

00:04:24,650 --> 00:04:28,070
first and

00:04:26,400 --> 00:04:30,750
tations and by annotations I mean

00:04:28,070 --> 00:04:33,150
documentation types what are the flags

00:04:30,750 --> 00:04:34,830
how do i given it given some data what's

00:04:33,150 --> 00:04:36,780
the metadata associated with that

00:04:34,830 --> 00:04:39,449
whether that's a function definition or

00:04:36,780 --> 00:04:42,060
whether that's a package definition we

00:04:39,449 --> 00:04:44,370
have some conventions for I mean it's

00:04:42,060 --> 00:04:46,740
been set especially for metadata but for

00:04:44,370 --> 00:04:48,690
package metadata but no we don't have

00:04:46,740 --> 00:04:50,490
general conventions for this and we

00:04:48,690 --> 00:04:52,470
don't have Discoverer we don't have

00:04:50,490 --> 00:04:55,139
discoverability around those annotations

00:04:52,470 --> 00:04:56,850
or discoverability for what

00:04:55,139 --> 00:04:58,830
functionality is even available it's

00:04:56,850 --> 00:05:00,870
pretty hard to say does this package

00:04:58,830 --> 00:05:02,820
exist unless you know enough about how

00:05:00,870 --> 00:05:06,210
niks packages is laid out to already

00:05:02,820 --> 00:05:08,039
know most of the answer you know for if

00:05:06,210 --> 00:05:10,199
you go through the attributes in in like

00:05:08,039 --> 00:05:12,360
the top level packages set how do you

00:05:10,199 --> 00:05:14,729
like how do you know which of those is a

00:05:12,360 --> 00:05:16,229
package versus a sub package set versus

00:05:14,729 --> 00:05:18,840
a library instead of library

00:05:16,229 --> 00:05:20,729
functionality versus some combination of

00:05:18,840 --> 00:05:22,949
all the above we don't have that

00:05:20,729 --> 00:05:25,590
available to us within nix packages very

00:05:22,949 --> 00:05:28,020
easily and finally open sourcing is

00:05:25,590 --> 00:05:29,880
actually very difficult at least in my

00:05:28,020 --> 00:05:33,599
experience because again we have these

00:05:29,880 --> 00:05:35,910
monolithic company nix repos and they

00:05:33,599 --> 00:05:38,220
combine functionality that we would love

00:05:35,910 --> 00:05:39,720
to share that is completely generic but

00:05:38,220 --> 00:05:41,490
it's also like all tied up with

00:05:39,720 --> 00:05:43,889
functionality like our private package

00:05:41,490 --> 00:05:45,150
sets and all that and if we open sourced

00:05:43,889 --> 00:05:46,830
it we would have to break out that

00:05:45,150 --> 00:05:48,150
functionality and we wouldn't use the

00:05:46,830 --> 00:05:50,310
thing we open-source because we have no

00:05:48,150 --> 00:05:55,020
way to combine it in with our big mono

00:05:50,310 --> 00:05:57,539
repo so this is this is a problem that I

00:05:55,020 --> 00:05:59,520
kind of was looking at and sat down did

00:05:57,539 --> 00:06:01,740
some design sessions and I think the

00:05:59,520 --> 00:06:04,770
answer what we need in Nix which we

00:06:01,740 --> 00:06:06,539
don't have packages and modules and not

00:06:04,770 --> 00:06:08,520
packages and modules in the sense that

00:06:06,539 --> 00:06:10,650
Nix means them but I mean in the sense

00:06:08,520 --> 00:06:13,229
of normal programming language packages

00:06:10,650 --> 00:06:14,610
and modules like Python has a module and

00:06:13,229 --> 00:06:16,229
package

00:06:14,610 --> 00:06:18,030
exports those modules and you import

00:06:16,229 --> 00:06:20,639
that and you get your definitions from

00:06:18,030 --> 00:06:23,010
that and so required annex is a system

00:06:20,639 --> 00:06:25,020
to provide packages and modules for the

00:06:23,010 --> 00:06:26,909
next language so there's some kind of

00:06:25,020 --> 00:06:28,830
core technical capabilities like a

00:06:26,909 --> 00:06:30,659
package specification saying you know

00:06:28,830 --> 00:06:33,150
this is the required at next package

00:06:30,659 --> 00:06:35,550
itself it's got a description it's got

00:06:33,150 --> 00:06:37,409
versions a you know this is these are

00:06:35,550 --> 00:06:39,870
the packages I depend on with version

00:06:37,409 --> 00:06:40,590
ranges and things like that I can define

00:06:39,870 --> 00:06:43,260
my

00:06:40,590 --> 00:06:45,630
what modules I export and kind of some

00:06:43,260 --> 00:06:47,280
formatting and just a heads up for all

00:06:45,630 --> 00:06:48,570
of these things these are like the first

00:06:47,280 --> 00:06:50,250
thing I could think of that would cover

00:06:48,570 --> 00:06:52,320
exactly what I needed and nothing more

00:06:50,250 --> 00:06:54,720
so I'm not saying this format is great

00:06:52,320 --> 00:06:56,220
I'm saying we have a format it gives

00:06:54,720 --> 00:06:57,770
metadata it gives you everything you

00:06:56,220 --> 00:07:00,030
need to know to consume the package

00:06:57,770 --> 00:07:02,300
similarly we could have locked files to

00:07:00,030 --> 00:07:07,050
say ok you depend on the base library

00:07:02,300 --> 00:07:10,800
this for this repo use this version of

00:07:07,050 --> 00:07:12,930
base from this revision of github and

00:07:10,800 --> 00:07:15,240
just a note about how I've kind of built

00:07:12,930 --> 00:07:16,680
the lock files so far they not only need

00:07:15,240 --> 00:07:18,660
to contain your direct dependencies they

00:07:16,680 --> 00:07:21,300
need to contain your whole dependency

00:07:18,660 --> 00:07:24,180
set but kind of going back to what Adam

00:07:21,300 --> 00:07:26,010
was talking about earlier it still fails

00:07:24,180 --> 00:07:28,290
if you try to import a module not in

00:07:26,010 --> 00:07:30,240
your dependency list so you don't have

00:07:28,290 --> 00:07:31,770
that problem that Note has but you still

00:07:30,240 --> 00:07:32,940
have a top-level kind of tying

00:07:31,770 --> 00:07:34,500
everything together these are the

00:07:32,940 --> 00:07:36,600
specific versions I'm using in my

00:07:34,500 --> 00:07:38,940
package and it also happens to allow for

00:07:36,600 --> 00:07:40,470
circular dependencies but I don't think

00:07:38,940 --> 00:07:43,470
anybody's gonna use that and if they did

00:07:40,470 --> 00:07:45,450
that's on their head in my opinion and

00:07:43,470 --> 00:07:47,970
the implementation I have written also

00:07:45,450 --> 00:07:49,440
allows for local lock files that like

00:07:47,970 --> 00:07:51,120
it's expected you add them to your good

00:07:49,440 --> 00:07:54,210
ignore so you can kind of override

00:07:51,120 --> 00:07:55,260
locally and also we use these locks we

00:07:54,210 --> 00:07:56,700
use a separate lock file for

00:07:55,260 --> 00:07:58,500
bootstrapping required annex itself

00:07:56,700 --> 00:08:00,540
which hopefully will go away and we get

00:07:58,500 --> 00:08:01,740
some like custom tooling and then here's

00:08:00,540 --> 00:08:04,830
how we actually use it and this is where

00:08:01,740 --> 00:08:09,000
the name comes from inspired by nodejs

00:08:04,830 --> 00:08:10,500
is require a module a module within the

00:08:09,000 --> 00:08:12,540
required at Nix world is a function that

00:08:10,500 --> 00:08:15,120
takes this require function and then you

00:08:12,540 --> 00:08:16,860
can call require to import a module and

00:08:15,120 --> 00:08:18,690
if you if you ignore the module if you

00:08:16,860 --> 00:08:20,640
omit the module here it'll import like

00:08:18,690 --> 00:08:22,950
the top-level module so I'm importing

00:08:20,640 --> 00:08:27,150
the trivial module from base and then

00:08:22,950 --> 00:08:28,740
I'm and think of this as like the which

00:08:27,150 --> 00:08:30,570
identifiers you're importing it's an

00:08:28,740 --> 00:08:32,490
just an inherit but I think this kind of

00:08:30,570 --> 00:08:33,690
pattern will probably be common so I'm

00:08:32,490 --> 00:08:35,760
saying okay get me the identity function

00:08:33,690 --> 00:08:38,040
from base and then in my module is gonna

00:08:35,760 --> 00:08:40,950
define identity function specialized to

00:08:38,040 --> 00:08:43,710
lists so that's really the core

00:08:40,950 --> 00:08:46,170
technical innovation of require that

00:08:43,710 --> 00:08:48,120
next but as I was saying there's also

00:08:46,170 --> 00:08:50,670
this is an opportunity to kind of

00:08:48,120 --> 00:08:53,100
improve on conventions around how we

00:08:50,670 --> 00:08:53,850
build our projects if we're going to be

00:08:53,100 --> 00:08:55,319
Bill

00:08:53,850 --> 00:08:57,839
this new we're gonna be building new

00:08:55,319 --> 00:08:59,310
libraries in this new system we might as

00:08:57,839 --> 00:09:03,029
well take advantage of that opportunity

00:08:59,310 --> 00:09:06,060
to do things more standardized in a kind

00:09:03,029 --> 00:09:08,430
of more conventional way so first

00:09:06,060 --> 00:09:11,579
convention that I like and I think this

00:09:08,430 --> 00:09:14,389
would probably be the most controversial

00:09:11,579 --> 00:09:16,380
of my conventions is going for

00:09:14,389 --> 00:09:20,130
declarative or like plain old data

00:09:16,380 --> 00:09:21,990
domain specific types for everything

00:09:20,130 --> 00:09:24,420
we're representing so here this is this

00:09:21,990 --> 00:09:27,149
is an instance of a type I call source

00:09:24,420 --> 00:09:28,500
specification so instead of doing

00:09:27,149 --> 00:09:30,720
everything in paths and doing like

00:09:28,500 --> 00:09:32,940
built-ins not fetch get this and then

00:09:30,720 --> 00:09:35,610
I'm gonna get the subdirectory here and

00:09:32,940 --> 00:09:38,190
then I'm gonna filter that you represent

00:09:35,610 --> 00:09:40,649
what your path is at a in a declarative

00:09:38,190 --> 00:09:42,810
way and then only at the very edges when

00:09:40,649 --> 00:09:45,240
you need to go to a NYX built-in or

00:09:42,810 --> 00:09:47,730
something else I have a timer on my at

00:09:45,240 --> 00:09:49,380
the time our measurement if going to

00:09:47,730 --> 00:09:51,329
Nick's built-in or something else that

00:09:49,380 --> 00:09:54,779
you actually need to convert it to a

00:09:51,329 --> 00:09:58,019
path so you you fort you represent all

00:09:54,779 --> 00:09:59,189
of your your data in the in the domain

00:09:58,019 --> 00:10:01,079
that you want to think about it in so

00:09:59,189 --> 00:10:03,089
there's this is for sources you could

00:10:01,079 --> 00:10:05,730
also have it for packages like a COBOL

00:10:03,089 --> 00:10:07,319
package is different from a c++ package

00:10:05,730 --> 00:10:08,850
and in today's world what we do to

00:10:07,319 --> 00:10:10,709
express that difference is we have a

00:10:08,850 --> 00:10:12,660
different function we call but if

00:10:10,709 --> 00:10:15,120
instead we just passed around like these

00:10:12,660 --> 00:10:17,009
are the these are the fields that define

00:10:15,120 --> 00:10:19,259
my COBOL package these are the fields

00:10:17,009 --> 00:10:21,509
that define my C++ package and only when

00:10:19,259 --> 00:10:24,240
I actually need to consume it in a

00:10:21,509 --> 00:10:25,470
derivation generic way do I call the

00:10:24,240 --> 00:10:27,779
function that converts it into a

00:10:25,470 --> 00:10:29,189
derivation this is sort of related to

00:10:27,779 --> 00:10:29,730
some of what Elko is doing whether the

00:10:29,189 --> 00:10:31,889
DRV

00:10:29,730 --> 00:10:33,899
field of the modules only it's only

00:10:31,889 --> 00:10:36,720
consumed at the end but you're operating

00:10:33,899 --> 00:10:38,990
over you're operating over this kind of

00:10:36,720 --> 00:10:41,730
generic this domain-specific

00:10:38,990 --> 00:10:43,050
representation rather so one of the one

00:10:41,730 --> 00:10:44,699
of the reasons I like this kind of

00:10:43,050 --> 00:10:47,610
approach is it lets you sort of

00:10:44,699 --> 00:10:49,410
efficiently compose and and and

00:10:47,610 --> 00:10:52,620
sufficiently insanely compose or

00:10:49,410 --> 00:10:54,209
transform or query your data so like in

00:10:52,620 --> 00:10:57,240
in Nix packages as some of you may know

00:10:54,209 --> 00:10:59,100
there's this way to do composable filter

00:10:57,240 --> 00:11:00,959
source and it's sort of ad hoc and it's

00:10:59,100 --> 00:11:02,370
only for one thing if you if you

00:11:00,959 --> 00:11:05,040
actually just try to do filter source

00:11:02,370 --> 00:11:06,300
multiple times you'll add to store

00:11:05,040 --> 00:11:07,510
multiple times and actually won't even

00:11:06,300 --> 00:11:09,040
work because you have to

00:11:07,510 --> 00:11:11,290
contexts and all of that but even if you

00:11:09,040 --> 00:11:12,940
omit that part you still are adding the

00:11:11,290 --> 00:11:15,580
path to the store over and over and over

00:11:12,940 --> 00:11:17,920
again if but in practice what you often

00:11:15,580 --> 00:11:20,950
have in some of these these systems is

00:11:17,920 --> 00:11:22,300
you have a source you have a the

00:11:20,950 --> 00:11:24,220
representation of your project source

00:11:22,300 --> 00:11:25,960
and then you're gonna call Cobalts annex

00:11:24,220 --> 00:11:27,970
so I want a filter source that just has

00:11:25,960 --> 00:11:29,410
the COBOL file in it but I don't but

00:11:27,970 --> 00:11:31,510
then I also want the top-level source

00:11:29,410 --> 00:11:33,130
thing and then maybe I actually have a

00:11:31,510 --> 00:11:35,080
source with multiple projects in it and

00:11:33,130 --> 00:11:38,380
so I want to recurse into each one and

00:11:35,080 --> 00:11:40,090
if if each time I change the path I was

00:11:38,380 --> 00:11:42,580
reading it to the store that'd be very

00:11:40,090 --> 00:11:44,140
inefficient if I make all do all of my

00:11:42,580 --> 00:11:46,900
transformations on this representation

00:11:44,140 --> 00:11:50,440
then only and then only at the end when

00:11:46,900 --> 00:11:51,970
I actually need to consume it kind of

00:11:50,440 --> 00:11:54,820
close the loop it back to annex

00:11:51,970 --> 00:11:56,170
primitive then you get things are much

00:11:54,820 --> 00:11:58,270
more efficient and it's also much easier

00:11:56,170 --> 00:12:00,430
to look at a path and see what it's

00:11:58,270 --> 00:12:02,260
doing and what it means so this is this

00:12:00,430 --> 00:12:05,350
is four paths but I think we should be

00:12:02,260 --> 00:12:09,070
doing it for everything I think you know

00:12:05,350 --> 00:12:10,360
the the attribute sets that we so using

00:12:09,070 --> 00:12:12,580
make derivation and then using dot

00:12:10,360 --> 00:12:13,960
override or maybe it's cabal don't make

00:12:12,580 --> 00:12:16,390
generation and dot override for that

00:12:13,960 --> 00:12:17,740
instead and trying to kind of keep in

00:12:16,390 --> 00:12:20,050
mind those things instead of just having

00:12:17,740 --> 00:12:23,110
a standard of this is what the types

00:12:20,050 --> 00:12:25,000
look like I think is would really help

00:12:23,110 --> 00:12:28,150
kind of people use Nick's packages

00:12:25,000 --> 00:12:30,570
especially people who and one of the

00:12:28,150 --> 00:12:33,070
things I really want to support is

00:12:30,570 --> 00:12:34,780
developers owning their own Nick's

00:12:33,070 --> 00:12:37,240
expressions even if they're not people

00:12:34,780 --> 00:12:39,130
into packaging and giving them a

00:12:37,240 --> 00:12:40,510
language that is as close to how they

00:12:39,130 --> 00:12:43,770
want to think about things as possible

00:12:40,510 --> 00:12:47,110
is a huge way to get there and then also

00:12:43,770 --> 00:12:48,160
it this again going to what Elko was

00:12:47,110 --> 00:12:50,680
talking about yesterday

00:12:48,160 --> 00:12:52,900
this could eventually lead into tooling

00:12:50,680 --> 00:12:55,420
that lets you discover what what are the

00:12:52,900 --> 00:12:57,460
flags for this package because the you'd

00:12:55,420 --> 00:12:58,570
have like a simple Flags field of like

00:12:57,460 --> 00:12:59,950
what it is and what they mean with

00:12:58,570 --> 00:13:01,960
metadata that you want to do it and then

00:12:59,950 --> 00:13:04,810
you can say okay I want to install less

00:13:01,960 --> 00:13:07,720
with the secure flag great

00:13:04,810 --> 00:13:09,610
I might my my install tool knows how to

00:13:07,720 --> 00:13:12,850
parse out the flags from a package and

00:13:09,610 --> 00:13:14,110
call that in so that's one thing another

00:13:12,850 --> 00:13:16,750
thing that I think everybody will be on

00:13:14,110 --> 00:13:18,880
board with is documentation and here

00:13:16,750 --> 00:13:20,470
documentation structured in a way so the

00:13:18,880 --> 00:13:21,699
resolve function is from the source

00:13:20,470 --> 00:13:25,269
specifications library

00:13:21,699 --> 00:13:27,459
and so the module which is exporting

00:13:25,269 --> 00:13:29,619
resolved will also have a metadata field

00:13:27,459 --> 00:13:32,049
and you could have metadata like module

00:13:29,619 --> 00:13:34,989
level description metadata but also

00:13:32,049 --> 00:13:37,449
annotations per whatever is exported

00:13:34,989 --> 00:13:39,249
there so this is just a very in it and

00:13:37,449 --> 00:13:41,589
you know the description here is

00:13:39,249 --> 00:13:42,819
intentionally long and detailed and the

00:13:41,589 --> 00:13:44,259
idea is you should be able to look at it

00:13:42,819 --> 00:13:47,199
and kind of understand what it's doing

00:13:44,259 --> 00:13:47,559
without needing to kind of jump jump a

00:13:47,199 --> 00:13:48,730
lot

00:13:47,559 --> 00:13:50,410
I mean sometimes you're gonna have to

00:13:48,730 --> 00:13:52,419
cross-reference but I think this

00:13:50,410 --> 00:13:53,439
documentation in terms of length is

00:13:52,419 --> 00:13:56,859
something we want to look at I think

00:13:53,439 --> 00:13:59,649
having every identifier having every

00:13:56,859 --> 00:14:02,769
exported top-level identifier have its

00:13:59,649 --> 00:14:05,230
own description this could have you know

00:14:02,769 --> 00:14:07,209
this could be doc book or some kind of

00:14:05,230 --> 00:14:08,589
markup I don't have strong opinions on

00:14:07,209 --> 00:14:10,540
that I think we should just choose

00:14:08,589 --> 00:14:12,519
something in standardize it and then of

00:14:10,540 --> 00:14:14,139
course given if we're going to break

00:14:12,519 --> 00:14:15,399
things out into separate projects and

00:14:14,139 --> 00:14:17,019
separate libraries the libraries

00:14:15,399 --> 00:14:19,149
themselves should have really good

00:14:17,019 --> 00:14:20,169
top-level documentation of like just

00:14:19,149 --> 00:14:21,309
like you would have in anything of the

00:14:20,169 --> 00:14:23,109
project like this is what this library

00:14:21,309 --> 00:14:24,549
is for this is how its organized this is

00:14:23,109 --> 00:14:28,059
how you should think about it these are

00:14:24,549 --> 00:14:29,439
the top-level concepts etc next thing

00:14:28,059 --> 00:14:32,319
that I know a lot of people are have

00:14:29,439 --> 00:14:33,699
been interested in is type annotation so

00:14:32,319 --> 00:14:36,279
in addition to human readable

00:14:33,699 --> 00:14:39,100
descriptions this is a machine readable

00:14:36,279 --> 00:14:42,970
description of the type of a function

00:14:39,100 --> 00:14:46,929
and so I've come up with a way to encode

00:14:42,970 --> 00:14:49,720
kind of very generally encode types with

00:14:46,929 --> 00:14:52,059
as niks values so you know this is

00:14:49,720 --> 00:14:53,799
saying resolve as a function the input

00:14:52,059 --> 00:14:55,629
type is a source specification a source

00:14:53,799 --> 00:14:59,199
specification is sort of defined in some

00:14:55,629 --> 00:15:02,230
other types module and the output is a

00:14:59,199 --> 00:15:03,970
result type and result is like if you're

00:15:02,230 --> 00:15:05,410
familiar with rusts result type or it's

00:15:03,970 --> 00:15:09,279
in either where you've got an error

00:15:05,410 --> 00:15:12,189
condition or a success condition and say

00:15:09,279 --> 00:15:14,410
okay if if this succeeded then you will

00:15:12,189 --> 00:15:15,779
give back a path if it failed will give

00:15:14,410 --> 00:15:18,220
back some structured error type

00:15:15,779 --> 00:15:19,959
describing what the failure was and then

00:15:18,220 --> 00:15:21,249
the structured error the reason I gave

00:15:19,959 --> 00:15:22,989
this examples I also wanted to say

00:15:21,249 --> 00:15:25,209
structured errors as opposed to just

00:15:22,989 --> 00:15:27,519
throwing is often a better way to go

00:15:25,209 --> 00:15:29,169
because then you can pass information

00:15:27,519 --> 00:15:31,239
higher up the chain until the error

00:15:29,169 --> 00:15:34,389
message actually shows the context that

00:15:31,239 --> 00:15:35,480
the user is going to want so this the

00:15:34,389 --> 00:15:37,759
type definition I've

00:15:35,480 --> 00:15:39,799
the the type language I came up with is

00:15:37,759 --> 00:15:41,449
rich enough to have like sums and record

00:15:39,799 --> 00:15:43,339
types and also as you can see has

00:15:41,449 --> 00:15:45,529
function applications and function

00:15:43,339 --> 00:15:47,419
parameters it's way too general for what

00:15:45,529 --> 00:15:49,279
we're actually want to do but I just

00:15:47,419 --> 00:15:52,819
kind of again started with the basic

00:15:49,279 --> 00:15:55,850
thing that would work so and then the

00:15:52,819 --> 00:15:58,699
last thing that we can do is build

00:15:55,850 --> 00:16:02,209
tooling on top of all of this so again

00:15:58,699 --> 00:16:03,859
all that documentation stuff and the

00:16:02,209 --> 00:16:05,809
types could be rendered in some nice way

00:16:03,859 --> 00:16:08,139
we could have you know some hosted

00:16:05,809 --> 00:16:10,429
documentation for all of our libraries

00:16:08,139 --> 00:16:13,160
we could expose configurations the tools

00:16:10,429 --> 00:16:15,709
as I mentioned earlier if if your

00:16:13,160 --> 00:16:17,779
package has some slags then your your

00:16:15,709 --> 00:16:19,850
install script could use those flags to

00:16:17,779 --> 00:16:21,619
do things and we could build tooling

00:16:19,850 --> 00:16:24,559
that's sort of native to require that

00:16:21,619 --> 00:16:26,689
next right now to like resolve that

00:16:24,559 --> 00:16:28,189
package description in the lock file

00:16:26,689 --> 00:16:30,379
that I was talking about earlier right

00:16:28,189 --> 00:16:32,149
now to do that I have some like Genki

00:16:30,379 --> 00:16:36,139
bootstrap code that reads it all in and

00:16:32,149 --> 00:16:37,549
then a small subset of the stuff that

00:16:36,139 --> 00:16:39,259
required at Nix itself uses is

00:16:37,549 --> 00:16:41,660
implemented twice once within the

00:16:39,259 --> 00:16:43,339
required X's repo so it can read the

00:16:41,660 --> 00:16:44,660
file enough to fetch it it's real

00:16:43,339 --> 00:16:46,759
dependencies and then bootstrap itself

00:16:44,660 --> 00:16:48,799
but if we had that that the only reason

00:16:46,759 --> 00:16:51,049
I do that is so that you can just write

00:16:48,799 --> 00:16:53,089
a default on Nix and use Nix instantiate

00:16:51,049 --> 00:16:54,319
or annex build like you normally do but

00:16:53,089 --> 00:16:56,239
if we had required that Nix native

00:16:54,319 --> 00:16:58,009
tooling it could do the job of parsing

00:16:56,239 --> 00:17:00,889
these package definitions and these lock

00:16:58,009 --> 00:17:02,569
files it could be smarter about how it

00:17:00,889 --> 00:17:05,299
fetches the dependencies and shares them

00:17:02,569 --> 00:17:07,819
and it can it can also give you a nice

00:17:05,299 --> 00:17:09,799
repple experience where for any given

00:17:07,819 --> 00:17:11,149
identifier you can easily find okay give

00:17:09,799 --> 00:17:13,390
me the doc string for this or show me

00:17:11,149 --> 00:17:21,220
the type of this

00:17:13,390 --> 00:17:23,380
and all of that so yeah so now I want to

00:17:21,220 --> 00:17:25,959
kind of go into so this is the idea this

00:17:23,380 --> 00:17:27,760
is where I want to go and the big

00:17:25,959 --> 00:17:31,150
question is what's what's coming next

00:17:27,760 --> 00:17:33,670
and really the reason the reason what I

00:17:31,150 --> 00:17:35,679
don't have actually I have stuff locally

00:17:33,670 --> 00:17:37,420
on my machine that works and it's proven

00:17:35,679 --> 00:17:40,360
the concept for me the reason I haven't

00:17:37,420 --> 00:17:42,580
gone much further with it is this is not

00:17:40,360 --> 00:17:45,820
a viable project unless there's buy-in

00:17:42,580 --> 00:17:48,309
from the community and unless and and I

00:17:45,820 --> 00:17:50,590
personally am NOT a PAC a sort of

00:17:48,309 --> 00:17:52,360
language packaging expert I don't know

00:17:50,590 --> 00:17:53,650
what the right conventions should be I

00:17:52,360 --> 00:17:55,809
don't know what the right field should

00:17:53,650 --> 00:17:57,580
be so I have a number of things that I

00:17:55,809 --> 00:17:59,020
would love for people to be looking at

00:17:57,580 --> 00:18:00,460
in the near future possibly even the

00:17:59,020 --> 00:18:02,200
hackathon if you guys are here and

00:18:00,460 --> 00:18:03,460
things that I also want to be looking at

00:18:02,200 --> 00:18:05,020
but I'm mostly interested in following

00:18:03,460 --> 00:18:07,750
where there's actually community

00:18:05,020 --> 00:18:11,020
interests so one set of things we can do

00:18:07,750 --> 00:18:12,549
is make some libraries so we could have

00:18:11,020 --> 00:18:14,440
language specific libraries you know

00:18:12,549 --> 00:18:15,580
we've got we've got the Haskell

00:18:14,440 --> 00:18:16,600
infrastructure we've got the perl

00:18:15,580 --> 00:18:17,710
infrastructure we've got the rust

00:18:16,600 --> 00:18:19,360
infrastructure they all have their own

00:18:17,710 --> 00:18:20,980
builders many of them have their own

00:18:19,360 --> 00:18:22,780
kind of ways to generate expressions

00:18:20,980 --> 00:18:24,730
they have their own package sets maybe

00:18:22,780 --> 00:18:26,530
we could break those out and just as a

00:18:24,730 --> 00:18:28,090
note I have some opinions on how that

00:18:26,530 --> 00:18:30,309
should be done I kind of a disagree with

00:18:28,090 --> 00:18:32,500
the love for the yarn shinnok's approach

00:18:30,309 --> 00:18:35,470
I think cobalt UNIX is actually closer

00:18:32,500 --> 00:18:36,520
to the the one true path but ask me

00:18:35,470 --> 00:18:39,309
later if you want to hear more about

00:18:36,520 --> 00:18:40,990
that and just as a little teaser this is

00:18:39,309 --> 00:18:42,940
something that we're using within target

00:18:40,990 --> 00:18:44,410
and yeah these these are probably

00:18:42,940 --> 00:18:47,110
proprietary names I shouldn't be sharing

00:18:44,410 --> 00:18:49,450
but oh well where we have a single repo

00:18:47,110 --> 00:18:51,940
with a bunch of packages defined in a

00:18:49,450 --> 00:18:54,280
COBOL dot project and we just passed

00:18:51,940 --> 00:18:55,690
this list and a given tag for that repo

00:18:54,280 --> 00:18:57,130
and it just pulls them all in and we

00:18:55,690 --> 00:18:58,740
have them available in our package set

00:18:57,130 --> 00:19:01,090
and this is something we would love to

00:18:58,740 --> 00:19:02,950
we would love to open source this this

00:19:01,090 --> 00:19:05,049
functionality is not target specific at

00:19:02,950 --> 00:19:06,730
all but again we don't have a nice

00:19:05,049 --> 00:19:08,020
haskell library to plug it into and it

00:19:06,730 --> 00:19:12,850
would be kind of weird within nix

00:19:08,020 --> 00:19:14,710
packages proper also just nixed packages

00:19:12,850 --> 00:19:16,270
library all of the kind of like basic

00:19:14,710 --> 00:19:20,020
stuff that's in there could be broken

00:19:16,270 --> 00:19:22,300
out in particular kind of like the basic

00:19:20,020 --> 00:19:25,000
trivial stuff could easily be broken out

00:19:22,300 --> 00:19:26,410
into its own base module of just this is

00:19:25,000 --> 00:19:27,130
this is the kind of stuff you want to do

00:19:26,410 --> 00:19:30,130
if you're doing basic

00:19:27,130 --> 00:19:32,590
stuff with nicks standard ends like the

00:19:30,130 --> 00:19:33,790
core concept of what is part of the

00:19:32,590 --> 00:19:35,440
standard environment and what is the

00:19:33,790 --> 00:19:37,270
interface to make derivation and all of

00:19:35,440 --> 00:19:39,280
those things could be separated out and

00:19:37,270 --> 00:19:40,840
iterated and experimented upon and

00:19:39,280 --> 00:19:43,570
Knicks packages could do the actual

00:19:40,840 --> 00:19:45,430
bootstrapping and definition of what the

00:19:43,570 --> 00:19:47,170
standard end of is for next packages now

00:19:45,430 --> 00:19:49,000
but you could come along and plug your

00:19:47,170 --> 00:19:52,570
own in or plug your own in just for some

00:19:49,000 --> 00:19:54,340
packages and kind of explore with that

00:19:52,570 --> 00:19:57,190
and the Knicks west module system is

00:19:54,340 --> 00:19:59,650
another significant candidate for you

00:19:57,190 --> 00:20:01,240
know it's it's not really Nick's package

00:19:59,650 --> 00:20:03,190
is specific it's not really Nick so as

00:20:01,240 --> 00:20:05,290
specific as we learned earlier today

00:20:03,190 --> 00:20:08,050
it's a complete standalone Knicks

00:20:05,290 --> 00:20:10,030
language functionality that could be in

00:20:08,050 --> 00:20:12,820
its own place and be experimented on and

00:20:10,030 --> 00:20:14,530
developed on its own path the other

00:20:12,820 --> 00:20:17,230
thing and this is I think where I need

00:20:14,530 --> 00:20:18,580
more help on is the all those

00:20:17,230 --> 00:20:20,800
standardizations I talked about earlier

00:20:18,580 --> 00:20:22,000
I don't know what they should be I don't

00:20:20,800 --> 00:20:24,310
know what the right answers on these

00:20:22,000 --> 00:20:26,050
things I really what I want to do is

00:20:24,310 --> 00:20:28,060
import best practices from other

00:20:26,050 --> 00:20:29,680
communities and get the people who are

00:20:28,060 --> 00:20:32,050
experts who care about these things to

00:20:29,680 --> 00:20:34,060
kind of help us figure out what to do so

00:20:32,050 --> 00:20:35,830
what should the package format be what

00:20:34,060 --> 00:20:37,690
should the LOC format be what should our

00:20:35,830 --> 00:20:39,070
conventions be and in particular with

00:20:37,690 --> 00:20:41,470
conventions one thing I have completely

00:20:39,070 --> 00:20:43,240
not gotten to is tests and test Suites

00:20:41,470 --> 00:20:45,160
like how are we how do we want to

00:20:43,240 --> 00:20:46,660
represent those judo's go in the package

00:20:45,160 --> 00:20:48,460
format or they some kind of separate

00:20:46,660 --> 00:20:51,700
thing what kind of tooling would we need

00:20:48,460 --> 00:20:53,440
to run these tests and all of that and

00:20:51,700 --> 00:20:55,570
then of course the one last project I

00:20:53,440 --> 00:20:56,770
want to do is publish these slides and

00:20:55,570 --> 00:20:59,050
announce that this is happening but

00:20:56,770 --> 00:21:01,500
again that depends on if people are

00:20:59,050 --> 00:21:03,790
interested and want to make it happen so

00:21:01,500 --> 00:21:06,700
that's all I had

00:21:03,790 --> 00:21:10,140
thank you guys and we've got about 10

00:21:06,700 --> 00:21:10,140
minutes it looks like for questions so

00:21:12,110 --> 00:21:15,250
[Applause]

00:21:16,970 --> 00:21:25,380
so are there any questions or is

00:21:19,470 --> 00:21:27,480
everything already entirely clear and hi

00:21:25,380 --> 00:21:30,179
thanks for the talk

00:21:27,480 --> 00:21:32,549
I have a couple of questions so that's

00:21:30,179 --> 00:21:36,870
just one and maybe I'll raise my hand

00:21:32,549 --> 00:21:40,769
again so this is all nice and it's a

00:21:36,870 --> 00:21:42,600
great idea pros and cons as you

00:21:40,769 --> 00:21:45,990
mentioned with mono repo and libraries

00:21:42,600 --> 00:21:49,110
but do you or have you thought about

00:21:45,990 --> 00:21:51,360
like a migration path because we all

00:21:49,110 --> 00:21:53,250
have the next packages as they are and

00:21:51,360 --> 00:21:56,549
we use it as they are and it's a lot of

00:21:53,250 --> 00:21:58,289
work that's been put into it so you know

00:21:56,549 --> 00:21:59,519
you want to don't want to break

00:21:58,289 --> 00:22:01,649
backwards-compatibility

00:21:59,519 --> 00:22:04,409
and so on yeah so I mean I think for

00:22:01,649 --> 00:22:06,809
migration path one one thing that I've

00:22:04,409 --> 00:22:09,179
thought of to start with is start with

00:22:06,809 --> 00:22:10,980
this kind of functionality it doesn't

00:22:09,179 --> 00:22:12,510
really make sense in mix packages to

00:22:10,980 --> 00:22:14,429
begin with like it's not core to how you

00:22:12,510 --> 00:22:17,250
use Nix OS but it may be it's how you

00:22:14,429 --> 00:22:18,600
use Nixon development so like this like

00:22:17,250 --> 00:22:20,370
this had nice stuff we have for building

00:22:18,600 --> 00:22:21,720
Haskell package sets right it doesn't

00:22:20,370 --> 00:22:23,220
really need to be Nix packages Nick's

00:22:21,720 --> 00:22:25,320
packages has its Haskell package set

00:22:23,220 --> 00:22:27,870
it's fine so we could start with those

00:22:25,320 --> 00:22:30,840
libraries validate validate the concepts

00:22:27,870 --> 00:22:32,309
validate the tooling go with what works

00:22:30,840 --> 00:22:34,500
the one thing I'm hesitant to say on

00:22:32,309 --> 00:22:35,880
that though is I'd rather just go with

00:22:34,500 --> 00:22:37,440
where people are interested in willing

00:22:35,880 --> 00:22:39,299
to do the implementation and so I'm not

00:22:37,440 --> 00:22:41,010
gonna say no to people who if there's

00:22:39,299 --> 00:22:43,110
interest in kind of jumping straight to

00:22:41,010 --> 00:22:45,090
standard and in terms of migration like

00:22:43,110 --> 00:22:47,010
once we're ready to do that I think

00:22:45,090 --> 00:22:48,809
that's going to be kind of it's gonna

00:22:47,010 --> 00:22:50,789
need a community-wide consideration

00:22:48,809 --> 00:22:52,289
because it's kind of fun going to

00:22:50,789 --> 00:22:54,179
fundamentally change what happens when

00:22:52,289 --> 00:22:56,519
you import Nix packages and how it's all

00:22:54,179 --> 00:22:59,760
tied together the one nice thing though

00:22:56,519 --> 00:23:01,169
is that from a on a surface level at

00:22:59,760 --> 00:23:04,169
least this will all be opaque to the

00:23:01,169 --> 00:23:06,090
user because though the default Nix will

00:23:04,169 --> 00:23:08,070
still work it'll just kind of import

00:23:06,090 --> 00:23:09,899
it'll have some library dependencies and

00:23:08,070 --> 00:23:11,399
in its package but the default next

00:23:09,899 --> 00:23:13,500
we'll handle the bootstrapping for you

00:23:11,399 --> 00:23:15,120
and pull it all together so it's only

00:23:13,500 --> 00:23:16,559
once you get to the point of people want

00:23:15,120 --> 00:23:18,210
to override it or developers how they

00:23:16,559 --> 00:23:21,090
want to use it and I don't have good

00:23:18,210 --> 00:23:24,240
thoughts there on what exactly that path

00:23:21,090 --> 00:23:26,410
is again that depends on buy-in and

00:23:24,240 --> 00:23:30,760
okay let's take a question from the

00:23:26,410 --> 00:23:32,470
internet why do the log files not

00:23:30,760 --> 00:23:35,440
contain the hash of the next file that

00:23:32,470 --> 00:23:37,240
is being imported I mean in principle

00:23:35,440 --> 00:23:38,860
they could accept as first of all it's

00:23:37,240 --> 00:23:42,760
not an X file that's being imported its

00:23:38,860 --> 00:23:47,770
entire it's an entire package right so

00:23:42,760 --> 00:23:51,820
let's go back to the where is it I

00:23:47,770 --> 00:23:55,810
wrapped so basically this this kind of

00:23:51,820 --> 00:23:58,810
gets back to the question of there's a

00:23:55,810 --> 00:23:59,170
trade-off in usability versus kind of

00:23:58,810 --> 00:24:02,230
power

00:23:59,170 --> 00:24:05,020
I guess not really power but this this

00:24:02,230 --> 00:24:06,820
is a format that kind of I trust as at a

00:24:05,020 --> 00:24:08,580
high level I trust that if I'm

00:24:06,820 --> 00:24:10,510
referencing a tag that it's

00:24:08,580 --> 00:24:12,520
referentially transparent in the

00:24:10,510 --> 00:24:14,980
meaningful in a meaningful way like this

00:24:12,520 --> 00:24:17,350
I trust the owner of this repo not to

00:24:14,980 --> 00:24:19,690
update the tag and so this gives a

00:24:17,350 --> 00:24:21,250
unique name now it's true that this is

00:24:19,690 --> 00:24:23,110
sort of cheating this is this is not

00:24:21,250 --> 00:24:25,750
good enough for Nicks but it's good

00:24:23,110 --> 00:24:27,610
enough for me the question is if we

00:24:25,750 --> 00:24:29,770
force hashes if we force people to

00:24:27,610 --> 00:24:32,260
calculate all these things in practice I

00:24:29,770 --> 00:24:34,570
have a genuinely seen people give up

00:24:32,260 --> 00:24:36,070
nicks over little issues like this like

00:24:34,570 --> 00:24:38,680
they have to update the hash every time

00:24:36,070 --> 00:24:41,710
and so the question and I'm I'm not I

00:24:38,680 --> 00:24:44,290
guess I'll say I'm not kind of Wed to

00:24:41,710 --> 00:24:47,230
this completely but my my assumption my

00:24:44,290 --> 00:24:49,480
current gut feel is if we can define

00:24:47,230 --> 00:24:54,280
things at a domain-specific level in a

00:24:49,480 --> 00:24:57,100
way that lets people that that that it

00:24:54,280 --> 00:25:00,220
that we the concept of purity makes

00:24:57,100 --> 00:25:03,490
sense for that domain we'll get a huge

00:25:00,220 --> 00:25:07,420
win on usability and the loss on purity

00:25:03,490 --> 00:25:11,230
will be slim to none one more Internet

00:25:07,420 --> 00:25:13,030
question how much time of any Nick's

00:25:11,230 --> 00:25:16,780
come on depends on fetching requires

00:25:13,030 --> 00:25:18,790
from the network I mean so basically the

00:25:16,780 --> 00:25:20,290
way the way it'll work the way it

00:25:18,790 --> 00:25:22,050
currently works is they it just kind of

00:25:20,290 --> 00:25:25,780
fetches everything in the lock up front

00:25:22,050 --> 00:25:29,200
so you know it's I guess get that that's

00:25:25,780 --> 00:25:32,410
a a question so we're I'm currently

00:25:29,200 --> 00:25:34,420
using the the fetch get from targets and

00:25:32,410 --> 00:25:35,860
X fetchers repo which has some pretty

00:25:34,420 --> 00:25:37,029
good caching so once you've already

00:25:35,860 --> 00:25:38,709
fetched it once it's ax

00:25:37,029 --> 00:25:40,419
it's actually pretty fast to kind of

00:25:38,709 --> 00:25:41,499
validate that oh it's already there and

00:25:40,419 --> 00:25:43,509
I'm fine

00:25:41,499 --> 00:25:45,369
NYX the built-in fetch kid also does

00:25:43,509 --> 00:25:47,469
that if you provide a revision but since

00:25:45,369 --> 00:25:51,849
we're just providing tags the that

00:25:47,469 --> 00:25:53,199
sometimes has to refetch but so it's not

00:25:51,849 --> 00:25:54,939
too long I haven't actually timed the

00:25:53,199 --> 00:25:57,939
whole thing and I but I do think this is

00:25:54,939 --> 00:26:00,309
a place where standalone required NYX

00:25:57,939 --> 00:26:02,019
native tooling would help because we it

00:26:00,309 --> 00:26:03,579
could do smart things about fetching and

00:26:02,019 --> 00:26:06,279
knowing when it needs to fetch and and

00:26:03,579 --> 00:26:10,949
how it all handles that outside of a NYX

00:26:06,279 --> 00:26:13,389
evaluation yeah just a small point on

00:26:10,949 --> 00:26:15,189
what was just discussed in terms of

00:26:13,389 --> 00:26:17,319
putting hashes there for tags for

00:26:15,189 --> 00:26:20,259
example so I have seen people push tags

00:26:17,319 --> 00:26:22,299
to a different version so I would be a

00:26:20,259 --> 00:26:24,309
big proponent of saying ok do put the

00:26:22,299 --> 00:26:26,259
shots in there but I think what would

00:26:24,309 --> 00:26:28,209
solve the problem much more nicely is

00:26:26,259 --> 00:26:29,799
that if you have something like this

00:26:28,209 --> 00:26:31,779
where you have a thing where I okay I

00:26:29,799 --> 00:26:35,169
understand what a what did you call it

00:26:31,779 --> 00:26:37,089
source source specification is right

00:26:35,169 --> 00:26:39,579
just put a little bit of tooling into

00:26:37,089 --> 00:26:40,209
the next tool that says your hash is

00:26:39,579 --> 00:26:42,879
different

00:26:40,209 --> 00:26:44,529
press yes to update right and it writes

00:26:42,879 --> 00:26:46,689
your thing it's much easier and I think

00:26:44,529 --> 00:26:48,069
it gets us both so but well the other so

00:26:46,689 --> 00:26:51,399
the other thing is I what I will say

00:26:48,069 --> 00:26:55,089
here is this kind of format also has a

00:26:51,399 --> 00:26:57,129
mode for specifying a branch and a get

00:26:55,089 --> 00:26:59,709
revision and so as long as you trust

00:26:57,129 --> 00:27:01,599
gets revisions you can just use those it

00:26:59,709 --> 00:27:03,909
still doesn't require a hash of the file

00:27:01,599 --> 00:27:08,589
system contents though but yeah we could

00:27:03,909 --> 00:27:15,609
also we could do that discussions are

00:27:08,589 --> 00:27:16,959
already starting it's good to see

00:27:15,609 --> 00:27:18,579
someone else thinking about these sort

00:27:16,959 --> 00:27:19,689
of workflows cuz I have a couple similar

00:27:18,579 --> 00:27:21,219
things where I want to use certain

00:27:19,689 --> 00:27:22,599
library functions out of mix packages

00:27:21,219 --> 00:27:24,969
but not the actual packages themselves

00:27:22,599 --> 00:27:27,039
and in my case I've actually found what

00:27:24,969 --> 00:27:28,389
works really well is at the top to have

00:27:27,039 --> 00:27:31,089
a let binding that says something like

00:27:28,389 --> 00:27:34,269
let licences equals built-in stuff fetch

00:27:31,089 --> 00:27:36,849
tarball mix packages by sha-256 dot Lib

00:27:34,269 --> 00:27:38,829
dot licenses in which case I fetched a

00:27:36,849 --> 00:27:40,569
small sub component of mix packages in a

00:27:38,829 --> 00:27:42,669
deterministic way from the mono repo

00:27:40,569 --> 00:27:45,399
creating in effect my own library

00:27:42,669 --> 00:27:47,349
without busting up the mono repo and

00:27:45,399 --> 00:27:49,269
introducing version dependencies for

00:27:47,349 --> 00:27:50,050
upstream testing and discoverability

00:27:49,269 --> 00:27:51,490
issues

00:27:50,050 --> 00:27:54,250
have you tried this approachin is it

00:27:51,490 --> 00:27:56,560
working yeah I mean so the one thing

00:27:54,250 --> 00:27:58,390
that it doesn't support is when I want

00:27:56,560 --> 00:27:59,920
to push when I like oh if I want to push

00:27:58,390 --> 00:28:01,930
changes that I in my opinion don't

00:27:59,920 --> 00:28:03,580
really make sense in NYX packages except

00:28:01,930 --> 00:28:05,800
for the fact that NYX packages is kind

00:28:03,580 --> 00:28:07,330
of the central place doesn't really help

00:28:05,800 --> 00:28:09,880
that and it doesn't help with a couple

00:28:07,330 --> 00:28:12,220
deployment development aspect of the

00:28:09,880 --> 00:28:13,870
mono repo actually causes problems and

00:28:12,220 --> 00:28:15,100
one thing I actually wanted to say that

00:28:13,870 --> 00:28:17,230
I didn't mention at the time is of

00:28:15,100 --> 00:28:19,240
course all of these things I'm talking

00:28:17,230 --> 00:28:20,800
about are about kind of practice in

00:28:19,240 --> 00:28:23,320
policy and in principle you can

00:28:20,800 --> 00:28:25,630
implement policies that don't have these

00:28:23,320 --> 00:28:27,130
problems within a mono repo but I do but

00:28:25,630 --> 00:28:29,440
I believe in my experience has been that

00:28:27,130 --> 00:28:31,710
the mono repo that we have in the

00:28:29,440 --> 00:28:35,200
palette that practically sort of

00:28:31,710 --> 00:28:38,500
practices we follow encourage this kind

00:28:35,200 --> 00:28:41,470
of lack of clean interfaces between

00:28:38,500 --> 00:28:44,020
components and that sort of thing any

00:28:41,470 --> 00:28:47,980
more questions from someone who hasn't

00:28:44,020 --> 00:28:56,920
already asked a question right two

00:28:47,980 --> 00:29:00,250
minutes it's more of statements I think

00:28:56,920 --> 00:29:01,960
this is a brilliant idea and something

00:29:00,250 --> 00:29:04,780
that hasn't been mentioned is that if it

00:29:01,960 --> 00:29:07,720
gets adopted packages could provide

00:29:04,780 --> 00:29:10,780
you're required at NYX file and then as

00:29:07,720 --> 00:29:14,830
next packages contributor we could just

00:29:10,780 --> 00:29:15,490
imports the derivation directly yeah

00:29:14,830 --> 00:29:17,290
exactly

00:29:15,490 --> 00:29:18,610
you could you could Poirot require that

00:29:17,290 --> 00:29:20,680
next file within your package or a

00:29:18,610 --> 00:29:22,960
package set that like gives a list of

00:29:20,680 --> 00:29:24,730
overlays so it could either import its

00:29:22,960 --> 00:29:26,170
own mixed packages or it could give an

00:29:24,730 --> 00:29:28,570
overlay list that you can apply to your

00:29:26,170 --> 00:29:32,800
own mix packages and that sort of thing

00:29:28,570 --> 00:29:38,500
yeah any more sentences with question

00:29:32,800 --> 00:29:39,880
marks today and so another similar point

00:29:38,500 --> 00:29:41,230
that I've seen a handful of people in

00:29:39,880 --> 00:29:42,550
the community struggle with is if you

00:29:41,230 --> 00:29:44,530
have a package that you don't intend to

00:29:42,550 --> 00:29:46,660
upstream to nix packages there's some

00:29:44,530 --> 00:29:48,730
duplication between the default Nicks in

00:29:46,660 --> 00:29:51,160
the repository of the package the shell

00:29:48,730 --> 00:29:53,080
duck Nix the release Nix and potentially

00:29:51,160 --> 00:29:54,820
your company's mono repo or potentially

00:29:53,080 --> 00:29:56,230
nix packages mono repo have you thought

00:29:54,820 --> 00:29:58,269
a little bit about solving this

00:29:56,230 --> 00:29:59,649
particular problem or do you ever knew

00:29:58,269 --> 00:30:01,779
I haven't I mean I have thought about

00:29:59,649 --> 00:30:03,509
that problem I don't know that this is a

00:30:01,779 --> 00:30:05,950
full solution to that but I do think

00:30:03,509 --> 00:30:08,169
having more abilities to kind of

00:30:05,950 --> 00:30:10,570
reference to stand alone libraries we'd

00:30:08,169 --> 00:30:16,239
have one place where the actual

00:30:10,570 --> 00:30:18,580
expression lives have you also worked on

00:30:16,239 --> 00:30:21,729
they say practical example in which you

00:30:18,580 --> 00:30:23,409
can demonstrate what value this model

00:30:21,729 --> 00:30:25,959
Association approach provides because I

00:30:23,409 --> 00:30:27,849
think I also agree with you we need we

00:30:25,959 --> 00:30:30,070
need very better modeler ization

00:30:27,849 --> 00:30:33,309
but I think it would help a lot if

00:30:30,070 --> 00:30:34,899
there's something you can show something

00:30:33,309 --> 00:30:37,149
really practical for which it makes

00:30:34,899 --> 00:30:38,320
sense have you thought about that I mean

00:30:37,149 --> 00:30:41,249
yeah so I've thought about in that and

00:30:38,320 --> 00:30:44,320
that's to me that's the next step to see

00:30:41,249 --> 00:30:45,759
what wasn't clear to me before talking

00:30:44,320 --> 00:30:47,769
about it this weekend is whether anybody

00:30:45,759 --> 00:30:50,109
else was on board now it seems like it

00:30:47,769 --> 00:30:53,440
is so yes my next step is polish up the

00:30:50,109 --> 00:30:55,329
Haskell the the sort of library of like

00:30:53,440 --> 00:30:57,129
nice Haskell functionality that we're

00:30:55,329 --> 00:30:59,499
using we're using some of it within

00:30:57,129 --> 00:31:01,119
target some of what I've used a previous

00:30:59,499 --> 00:31:03,669
companies and just kind of make it a

00:31:01,119 --> 00:31:05,409
nice clean standalone piece of

00:31:03,669 --> 00:31:08,079
functionality that's that's my next

00:31:05,409 --> 00:31:09,940
project unless again there's some big

00:31:08,079 --> 00:31:15,789
push for some other thing that I should

00:31:09,940 --> 00:31:17,950
help out with yeah any hope we're at

00:31:15,789 --> 00:31:21,050
negative 20 seconds anyway

00:31:17,950 --> 00:31:21,050
[Laughter]

00:31:21,070 --> 00:31:29,840
[Applause]

00:31:26,980 --> 00:31:31,960
are you are you up for answering one

00:31:29,840 --> 00:31:35,330
more question then let's go for it

00:31:31,960 --> 00:31:36,410
chuck all night yeah so I mean I thinks

00:31:35,330 --> 00:31:39,920
it sounds like a really create

00:31:36,410 --> 00:31:44,330
initiative one question I have around so

00:31:39,920 --> 00:31:47,570
I think I agree it's only too difficult

00:31:44,330 --> 00:31:50,000
to get as a metadata of stuff and this

00:31:47,570 --> 00:31:52,670
messes up the user experience and also

00:31:50,000 --> 00:31:55,400
tooling like for example nicks and query

00:31:52,670 --> 00:31:57,050
also basically was a and

00:31:55,400 --> 00:31:59,090
Nick search sort of improves but it

00:31:57,050 --> 00:32:01,250
needs a caching mechanism and it seems

00:31:59,090 --> 00:32:06,050
to me a lot of those difficulties could

00:32:01,250 --> 00:32:09,200
be ameliorated if we just use JSON or

00:32:06,050 --> 00:32:10,700
whatever to specify some known well it's

00:32:09,200 --> 00:32:12,350
the actual metadata stuff like the

00:32:10,700 --> 00:32:13,730
description as a chars because you don't

00:32:12,350 --> 00:32:15,890
actually want to compute them and having

00:32:13,730 --> 00:32:17,810
some as some static information that

00:32:15,890 --> 00:32:20,150
normal tooling can create and update

00:32:17,810 --> 00:32:23,120
automatically or so I think what improve

00:32:20,150 --> 00:32:25,010
or not so one question I have is how

00:32:23,120 --> 00:32:27,920
where that I use the idea of doing some

00:32:25,010 --> 00:32:29,360
stuff as Nix expressions I suppose if

00:32:27,920 --> 00:32:32,140
you consider to do consider doing

00:32:29,360 --> 00:32:33,950
something like I mean I meant to mention

00:32:32,140 --> 00:32:36,260
you'll notice both of these are

00:32:33,950 --> 00:32:37,420
completely representable as JSON that's

00:32:36,260 --> 00:32:42,080
not an accident

00:32:37,420 --> 00:32:44,570
so yes I'm with you possibly I'm open to

00:32:42,080 --> 00:32:46,550
the idea of saying the metadata for the

00:32:44,570 --> 00:32:50,030
packages themselves should be JSON so

00:32:46,550 --> 00:32:52,040
easier make tooling or just use H Nick's

00:32:50,030 --> 00:32:55,690
or are Nick's or the Nick's evaluator

00:32:52,040 --> 00:33:00,410
and C++ and import it that way but

00:32:55,690 --> 00:33:03,210
anything else cool okay already another

00:33:00,410 --> 00:33:07,960
wonderful pose thank you

00:33:03,210 --> 00:33:07,960

YouTube URL: https://www.youtube.com/watch?v=DHOLjsyXPtM


