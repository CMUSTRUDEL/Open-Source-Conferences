Title: Georges Dubus - Nix for data pipeline configuration (NixCon 2018)
Publication date: 2018-10-27
Playlist: NixCon 2018 (London)
Description: 
	My team develops a data pipeline to generate music recommendations. It consists of many batch jobs that read data from somewhere and write their output somewhere else, with complex dependencies and parameter tuning. Historically, we have configured these batch jobs with hand-written bash configuration, or with dedicated python-based tools such as Airflow. However, both lack flexibility, often forcing the developer to bypass them and to run jobs manually during development. The tasks of data pipeline configuration and package definition share some requirements: both imply running many programs in a specific order and with specific parameters. Since nix is a language dedicated to packages definition, which allows expressing packages in a succinct and highly flexible way, we decided to try to use it for data pipeline configuration. Nix-the-tool is too centered around package management for our use case, so we built our own tool around nix-the-language. It this talk, we’ll explore how to apply nix to data pipeline configuration. This will give us the opportunity to look at nix as a language, abstracted from its current ecosystem. We’ll also explore how to structure a nix codebase, encountering the same questions nixpkgs encountered a long time ago, but in a much smaller environment. The main goal of this talk is to share the different point of view of nix that comes from applying it to a different problem and starting from scratch. We also hope to serve as an inspiration to explore other nix-based DSLs. --- Bio: Georges is a Software Engineer at SoundCloud, in Berlin. He is part of the team that generates music recommendations. He loves exploring new ways to solve engineering problems, which led him to look into exciting technologies such as Haskell and NixOS. He contributed a few tools to the nix community, such as http://howoldis.herokuapp.com/ and the infamous Travis Nixpkgs integration. Some of his favorites hobbies are playing board games and learning German.
 Slides: https://drive.google.com/open?id=0B4r1oNPr9K9LWUtlMWdBenRhbGxEbWtvVmNRUGMyaWFkcmZF
Captions: 
	00:00:01,700 --> 00:00:09,590
all righty everyone let's continue so I

00:00:07,770 --> 00:00:14,849
hope you enjoyed lunch

00:00:09,590 --> 00:00:18,779
and there was enough for everyone so our

00:00:14,849 --> 00:00:23,970
next speaker is George and if you have

00:00:18,779 --> 00:00:26,699
ever used the Travis Nix integration and

00:00:23,970 --> 00:00:27,900
you enjoy using that then give George a

00:00:26,699 --> 00:00:30,779
hand afterwards because he's the one

00:00:27,900 --> 00:00:32,340
responsible for it but it's that is not

00:00:30,779 --> 00:00:34,020
the topic for today because today George

00:00:32,340 --> 00:00:35,880
is going to talk to us about an X for

00:00:34,020 --> 00:00:44,789
data pipeline configuration enjoying

00:00:35,880 --> 00:00:48,809
give him a hand and hello there can you

00:00:44,789 --> 00:00:50,640
hear me in the back yeah okay I'd like

00:00:48,809 --> 00:00:53,129
to start with a short show of hands is

00:00:50,640 --> 00:00:55,110
there anybody here that is working with

00:00:53,129 --> 00:00:59,250
something around data science or machine

00:00:55,110 --> 00:01:01,350
learning a Big Data some of you and any

00:00:59,250 --> 00:01:03,359
of you are any of you are using tools

00:01:01,350 --> 00:01:06,390
like Luigi or airflow that kind of

00:01:03,359 --> 00:01:08,939
things to schedule and and run your bad

00:01:06,390 --> 00:01:10,740
jobs a few of you so for the few of you

00:01:08,939 --> 00:01:13,229
the short version is ID I replaced that

00:01:10,740 --> 00:01:18,080
with Nix let's go for the long version

00:01:13,229 --> 00:01:21,659
so hi I'm Josh I already said that I

00:01:18,080 --> 00:01:23,490
work at Sound Cloud it's a music

00:01:21,659 --> 00:01:25,830
streaming platform where artists upload

00:01:23,490 --> 00:01:27,500
their own music themselves and what I do

00:01:25,830 --> 00:01:30,210
there is that I do recommendations

00:01:27,500 --> 00:01:32,159
because anybody can upload anything it's

00:01:30,210 --> 00:01:34,979
kind it can be quite hard to actually

00:01:32,159 --> 00:01:37,829
find content you like and my team and I

00:01:34,979 --> 00:01:39,860
we build tools that generate recommended

00:01:37,829 --> 00:01:42,180
playlists which contain you might like

00:01:39,860 --> 00:01:43,470
it's a very interesting topic come talk

00:01:42,180 --> 00:01:46,170
to me afterward if you want to know more

00:01:43,470 --> 00:01:47,759
with that but for the purpose of that

00:01:46,170 --> 00:01:50,640
talk only need to know that it's mostly

00:01:47,759 --> 00:01:51,450
mostly batch jobs which means it's

00:01:50,640 --> 00:01:54,119
long-running

00:01:51,450 --> 00:01:56,790
jobs that run on all of our users data

00:01:54,119 --> 00:01:59,880
they take hours they read data somewhere

00:01:56,790 --> 00:02:01,619
they write somewhere else and the reason

00:01:59,880 --> 00:02:05,430
I'm here today is that because I tried

00:02:01,619 --> 00:02:07,110
to use necks for my bad jobs so why why

00:02:05,430 --> 00:02:10,670
did I do that let me give you a little

00:02:07,110 --> 00:02:15,200
bit more context but what that is

00:02:10,670 --> 00:02:18,290
so I said earlier we have batch jobs

00:02:15,200 --> 00:02:21,170
they are at the lowest level there are

00:02:18,290 --> 00:02:22,880
commands we run we write name in various

00:02:21,170 --> 00:02:25,220
languages some of them is in Scala's

00:02:22,880 --> 00:02:27,350
motive it is in CN in the end is just to

00:02:25,220 --> 00:02:29,660
come and rerun giving it some input

00:02:27,350 --> 00:02:31,040
giving it its some output and we've got

00:02:29,660 --> 00:02:32,600
a bunch of them and they've got

00:02:31,040 --> 00:02:34,370
dependencies between them some of them

00:02:32,600 --> 00:02:37,100
will explain expect some other one to

00:02:34,370 --> 00:02:39,980
have run before and part of the job of

00:02:37,100 --> 00:02:41,630
having path of the part of having these

00:02:39,980 --> 00:02:43,820
batch jobs is to make sure that they're

00:02:41,630 --> 00:02:46,250
in the right order they run with the

00:02:43,820 --> 00:02:48,739
right output I don't want to

00:02:46,250 --> 00:02:51,890
accidentally run today's today's run

00:02:48,739 --> 00:02:53,750
with yesterday's data because I will get

00:02:51,890 --> 00:02:55,310
some weird results and I need to have

00:02:53,750 --> 00:02:57,200
some some fine control about how this

00:02:55,310 --> 00:02:58,700
runs this is an example it's a

00:02:57,200 --> 00:02:59,930
simplification of the thing we run in

00:02:58,700 --> 00:03:02,480
production we have a bunch of different

00:02:59,930 --> 00:03:04,700
jobs some of their share some of them

00:03:02,480 --> 00:03:07,370
share dependencies some of them do not

00:03:04,700 --> 00:03:10,220
and it's it can be kind of a mess to

00:03:07,370 --> 00:03:14,900
configure and to well to maintain and

00:03:10,220 --> 00:03:16,579
monitor just a bit more more context all

00:03:14,900 --> 00:03:18,920
the job we have all the data we have

00:03:16,579 --> 00:03:21,019
it's stored on on something called HDFS

00:03:18,920 --> 00:03:23,810
stands for Hadoop this reddit filesystem

00:03:21,019 --> 00:03:25,400
it's say it's a distributed file system

00:03:23,810 --> 00:03:26,690
a clustered file system so we have a

00:03:25,400 --> 00:03:29,150
bunch of machines and every machine

00:03:26,690 --> 00:03:32,540
holds some of the data the data is not

00:03:29,150 --> 00:03:34,190
centralized anywhere and that gives us

00:03:32,540 --> 00:03:36,019
an interesting property when we develop

00:03:34,190 --> 00:03:39,019
with that is that we don't care about

00:03:36,019 --> 00:03:41,840
the individual machine file systems we

00:03:39,019 --> 00:03:44,120
only care about that big central ID that

00:03:41,840 --> 00:03:46,250
big single turn the HDFS we don't care

00:03:44,120 --> 00:03:48,650
about this machine or that machine is

00:03:46,250 --> 00:03:50,480
just there is only one file system for

00:03:48,650 --> 00:03:54,230
us when we work with that which is kind

00:03:50,480 --> 00:03:56,150
of a nice simplification and this bad

00:03:54,230 --> 00:03:57,769
jobs we run them daily because we

00:03:56,150 --> 00:04:00,860
compute in your recommendation for users

00:03:57,769 --> 00:04:02,630
daily but we also run them multiple

00:04:00,860 --> 00:04:04,610
times a day while we are developing so

00:04:02,630 --> 00:04:07,220
we've got one production run a day and

00:04:04,610 --> 00:04:08,720
then I'm trying some new logic trying

00:04:07,220 --> 00:04:11,060
some new things I'm gonna run the job

00:04:08,720 --> 00:04:14,870
and run it again iterating multiple

00:04:11,060 --> 00:04:16,310
times and it's kind of this tension

00:04:14,870 --> 00:04:17,930
between the production run and the

00:04:16,310 --> 00:04:20,090
development run that that is kind of the

00:04:17,930 --> 00:04:23,240
source of this the initial annoyance

00:04:20,090 --> 00:04:24,410
that that led me to pursue this because

00:04:23,240 --> 00:04:28,160
for for production we

00:04:24,410 --> 00:04:30,290
the best jobs that we want them to be we

00:04:28,160 --> 00:04:31,940
want them to be nice to express we want

00:04:30,290 --> 00:04:33,680
them to be reliable we want them to run

00:04:31,940 --> 00:04:35,150
every day in production they run every

00:04:33,680 --> 00:04:36,650
night we don't want them to fail and

00:04:35,150 --> 00:04:40,820
come in the morning and realize we

00:04:36,650 --> 00:04:42,410
failed we want them to be maintainable I

00:04:40,820 --> 00:04:43,910
want to come back in months and and be

00:04:42,410 --> 00:04:46,070
able to still figure out what's

00:04:43,910 --> 00:04:48,230
happening but for the development size I

00:04:46,070 --> 00:04:50,570
care about about flexibility I care

00:04:48,230 --> 00:04:52,870
about doing as fast as possible some new

00:04:50,570 --> 00:04:55,430
thing trying something out in order to

00:04:52,870 --> 00:04:56,750
get to the next next in quickly and

00:04:55,430 --> 00:04:58,610
these two things don't really work

00:04:56,750 --> 00:05:00,530
together at least for the tools we

00:04:58,610 --> 00:05:02,840
currently have for this they either have

00:05:00,530 --> 00:05:04,670
some of the property of being stable and

00:05:02,840 --> 00:05:06,320
and good for production or being

00:05:04,670 --> 00:05:09,290
flexible and good for for development

00:05:06,320 --> 00:05:14,060
and I wanted to to try something that

00:05:09,290 --> 00:05:15,830
would kind of have both to give you a

00:05:14,060 --> 00:05:17,480
bit more of an idea of what I'm talking

00:05:15,830 --> 00:05:19,520
about when I talk about flexibility in

00:05:17,480 --> 00:05:21,680
tweaking here is an example of one of

00:05:19,520 --> 00:05:24,290
the pipeline we have so these are bunch

00:05:21,680 --> 00:05:26,060
of bad jobs it computes some recommended

00:05:24,290 --> 00:05:28,640
playlists and we start with a set of

00:05:26,060 --> 00:05:30,320
candidates candidates is what we call

00:05:28,640 --> 00:05:31,850
tracks that might end up in the user

00:05:30,320 --> 00:05:34,430
playlist but we are not sure yet

00:05:31,850 --> 00:05:36,410
and we have multiple batch jobs that

00:05:34,430 --> 00:05:37,850
will enrich them and filter them and

00:05:36,410 --> 00:05:40,760
then score them and finally make the

00:05:37,850 --> 00:05:44,030
final playlist and this is in production

00:05:40,760 --> 00:05:46,070
this runs every night but no I want to

00:05:44,030 --> 00:05:47,570
write some new filtering code because we

00:05:46,070 --> 00:05:50,120
realize the old one is rubbish and we

00:05:47,570 --> 00:05:51,620
can we can make it better and I've done

00:05:50,120 --> 00:05:53,390
it I've written the code I've compiled

00:05:51,620 --> 00:05:57,350
it it's on my laptop and I'm ready to

00:05:53,390 --> 00:05:59,480
run a new job and what I want is to run

00:05:57,350 --> 00:06:00,860
the new filtering code and then roll run

00:05:59,480 --> 00:06:02,540
the stuff that depend on it because I

00:06:00,860 --> 00:06:05,120
I'm actually interested in the final

00:06:02,540 --> 00:06:08,120
result what impact was my change to this

00:06:05,120 --> 00:06:11,960
job has on the final result of the whole

00:06:08,120 --> 00:06:14,270
pipeline and ideally I also want to do

00:06:11,960 --> 00:06:15,710
to do that without having to rerun

00:06:14,270 --> 00:06:17,180
candidates than average candidates

00:06:15,710 --> 00:06:20,290
because I I know there will be the same

00:06:17,180 --> 00:06:22,460
I did not change anything there and so

00:06:20,290 --> 00:06:24,140
sadly with the current tooling we have

00:06:22,460 --> 00:06:26,660
the only way I have to do that is to go

00:06:24,140 --> 00:06:29,120
to whatever tool I have in production

00:06:26,660 --> 00:06:31,910
look how how the filtered candidate job

00:06:29,120 --> 00:06:34,460
worth run copy that comment and then I

00:06:31,910 --> 00:06:36,140
did the parts I want to edit change the

00:06:34,460 --> 00:06:38,180
code change the path to the code I'm

00:06:36,140 --> 00:06:40,039
using change the past of the output in

00:06:38,180 --> 00:06:41,960
gfs and then i go to the next job

00:06:40,039 --> 00:06:44,090
discord candidate and I drew the thing I

00:06:41,960 --> 00:06:45,770
copy the the comment I changed the input

00:06:44,090 --> 00:06:48,550
path and the output path and I run it

00:06:45,770 --> 00:06:51,139
and and same for the last one which is

00:06:48,550 --> 00:06:53,120
which well first of all is a knowing but

00:06:51,139 --> 00:06:57,470
it's more that than knowing it it's

00:06:53,120 --> 00:06:58,610
unless unnecessarily out and the reason

00:06:57,470 --> 00:07:00,169
I really find it's a problem it's

00:06:58,610 --> 00:07:02,960
because it's bad incentive if we want

00:07:00,169 --> 00:07:04,400
the right thing to be we want the right

00:07:02,960 --> 00:07:07,340
thing to be easy the right thing is to

00:07:04,400 --> 00:07:10,130
test my job completely check the final

00:07:07,340 --> 00:07:11,840
result but if it's hard I will be a bit

00:07:10,130 --> 00:07:14,180
less likely to do it at some point I

00:07:11,840 --> 00:07:15,889
will just stop doing it and the quality

00:07:14,180 --> 00:07:18,199
will be reduced so it's really a matter

00:07:15,889 --> 00:07:20,599
of lining incentive threatening should

00:07:18,199 --> 00:07:22,759
be the the easy you want to do and

00:07:20,599 --> 00:07:25,070
that's what I want to reach here I want

00:07:22,759 --> 00:07:29,270
I'm testing the whole thing to be to be

00:07:25,070 --> 00:07:31,910
easy not hard and annoying and another

00:07:29,270 --> 00:07:34,190
example to show that it's not only a

00:07:31,910 --> 00:07:37,160
development versus production problem

00:07:34,190 --> 00:07:39,889
actually is I've not written my my new

00:07:37,160 --> 00:07:42,139
my new filtering logic and I want to

00:07:39,889 --> 00:07:45,110
well I'm not quite sure it's actually

00:07:42,139 --> 00:07:47,810
that better from the that better than

00:07:45,110 --> 00:07:49,550
the original one and to make sure it's

00:07:47,810 --> 00:07:52,430
actually better we're using a technique

00:07:49,550 --> 00:07:54,440
we use quite a lot which is testing a/b

00:07:52,430 --> 00:07:56,900
testing the ideas that I'm gonna take my

00:07:54,440 --> 00:07:58,639
old logic that generates my all

00:07:56,900 --> 00:07:59,990
recommendation and the new one that you

00:07:58,639 --> 00:08:02,449
know it's don't your recommendation and

00:07:59,990 --> 00:08:04,430
I'm gonna save both two different set of

00:08:02,449 --> 00:08:06,289
users and then I'm gonna compare how it

00:08:04,430 --> 00:08:08,330
performs for example if I'm interested

00:08:06,289 --> 00:08:10,430
in the listener the listening time in

00:08:08,330 --> 00:08:12,470
this playlist to see if user like them

00:08:10,430 --> 00:08:13,639
I'm going to compare the user of the all

00:08:12,470 --> 00:08:15,979
playlist and the user of the new

00:08:13,639 --> 00:08:18,979
playlist but in order to be able to do

00:08:15,979 --> 00:08:21,349
that I will need to we need to compute

00:08:18,979 --> 00:08:22,820
both that of playlist both that of

00:08:21,349 --> 00:08:24,770
recommendations so I will need to

00:08:22,820 --> 00:08:27,740
actually compute both branches of that

00:08:24,770 --> 00:08:29,900
pipeline and with the currently tools

00:08:27,740 --> 00:08:31,220
the chrome tools I've in in production

00:08:29,900 --> 00:08:32,900
the current tools I use to define my

00:08:31,220 --> 00:08:35,029
pipelines I have no choice but to just

00:08:32,900 --> 00:08:36,979
duplicate the paths I want to run twice

00:08:35,029 --> 00:08:38,510
I'm going to duplicate the filtered

00:08:36,979 --> 00:08:41,120
candidates to score candidates and the

00:08:38,510 --> 00:08:43,760
final playlists and just copy past them

00:08:41,120 --> 00:08:45,110
and then tweak the past to measure to

00:08:43,760 --> 00:08:47,270
make sure that they write two different

00:08:45,110 --> 00:08:49,130
two different places otherwise it's well

00:08:47,270 --> 00:08:51,570
just gonna be one one big mess that's

00:08:49,130 --> 00:08:57,660
gonna stop working or worse

00:08:51,570 --> 00:08:59,730
and and I find this well I found this

00:08:57,660 --> 00:09:01,949
annoying and I find find this hard and

00:08:59,730 --> 00:09:03,570
it's gonna be even worse to maintain

00:09:01,949 --> 00:09:05,519
because I have to make some changes in

00:09:03,570 --> 00:09:06,810
the future to one of the jobs I'm gonna

00:09:05,519 --> 00:09:08,130
have to do it twice all the way they're

00:09:06,810 --> 00:09:10,769
going to do that it's gonna be a

00:09:08,130 --> 00:09:13,529
maintenance nightmare and the thing I

00:09:10,769 --> 00:09:15,509
want to reach here that the code the

00:09:13,529 --> 00:09:16,920
code for to express my pipeline should

00:09:15,509 --> 00:09:18,810
be as simple as the idea I want to

00:09:16,920 --> 00:09:21,029
express if the idea of want to express

00:09:18,810 --> 00:09:22,769
this I want to run the whole thing but

00:09:21,029 --> 00:09:24,990
changing the filtering logic it should

00:09:22,769 --> 00:09:26,819
not be more it should not be oh I'm

00:09:24,990 --> 00:09:28,589
going to copy past it and then type some

00:09:26,819 --> 00:09:30,750
change here and there to make it work it

00:09:28,589 --> 00:09:32,220
should be expressing the whole thing but

00:09:30,750 --> 00:09:35,480
with a different filtering logic and

00:09:32,220 --> 00:09:38,779
that the thing I wanted to reach and

00:09:35,480 --> 00:09:42,420
well with that in mind and I turn to nix

00:09:38,779 --> 00:09:44,370
because next first of all because thinks

00:09:42,420 --> 00:09:47,910
it's it's a pretty nice language for

00:09:44,370 --> 00:09:51,480
package definitions next packages

00:09:47,910 --> 00:09:53,610
contains a it's it's very nice to

00:09:51,480 --> 00:09:54,990
contribute to Nick's packages to to make

00:09:53,610 --> 00:09:56,760
it change some package because the

00:09:54,990 --> 00:09:59,819
package definition is is actually very

00:09:56,760 --> 00:10:01,170
nice in Nick's but more than that and

00:09:59,819 --> 00:10:03,839
that's really the thing that made me

00:10:01,170 --> 00:10:05,760
look into into Nick's to work with that

00:10:03,839 --> 00:10:07,170
is is because it's it's a language that

00:10:05,760 --> 00:10:09,899
actually allows you to manipulate

00:10:07,170 --> 00:10:11,639
definitions if you want to change a

00:10:09,899 --> 00:10:13,470
package in Nick's you don't have to copy

00:10:11,639 --> 00:10:15,480
past the definition and then change it

00:10:13,470 --> 00:10:18,690
you can actually in the language itself

00:10:15,480 --> 00:10:20,670
make make tweaks make overrides in the

00:10:18,690 --> 00:10:22,709
previous example I had the package

00:10:20,670 --> 00:10:24,600
definition for the less package I can

00:10:22,709 --> 00:10:26,370
actually use that definition and say oh

00:10:24,600 --> 00:10:27,870
yeah but actually the uncursed

00:10:26,370 --> 00:10:30,300
dependency is gonna be another one is

00:10:27,870 --> 00:10:31,829
gonna be that different version and this

00:10:30,300 --> 00:10:34,260
looks very similar to the thing I

00:10:31,829 --> 00:10:37,050
actually want to reach so this is why I

00:10:34,260 --> 00:10:41,310
wanted to try and use Nick's for to

00:10:37,050 --> 00:10:44,029
solve it this problem of mine so let's

00:10:41,310 --> 00:10:47,250
talk about how I actually did it well

00:10:44,029 --> 00:10:49,680
what is the final result so I'd like to

00:10:47,250 --> 00:10:52,620
introduce you to to mix I'm very bad at

00:10:49,680 --> 00:10:54,329
naming so the thing is called mix which

00:10:52,620 --> 00:10:56,279
is an implement an implementation of

00:10:54,329 --> 00:10:58,199
Nick's dedicated to data pipeline I'm

00:10:56,279 --> 00:11:00,209
saying an implementation of Nick's but

00:10:58,199 --> 00:11:02,730
most of the actual implementation works

00:11:00,209 --> 00:11:05,130
happened in the hatch Nick HDX library

00:11:02,730 --> 00:11:07,590
that I'm using which turns all

00:11:05,130 --> 00:11:09,450
passing and the evaluation of Nik so I'm

00:11:07,590 --> 00:11:11,430
not actually re-implemented the whole of

00:11:09,450 --> 00:11:13,440
Nyx somebody else did that for me thank

00:11:11,430 --> 00:11:16,050
you very much

00:11:13,440 --> 00:11:18,750
and the reason we have this

00:11:16,050 --> 00:11:21,540
implementation is because the definition

00:11:18,750 --> 00:11:24,450
of the derivation in Nix it's not not

00:11:21,540 --> 00:11:27,210
quite what we need Nix has a very strong

00:11:24,450 --> 00:11:29,310
idea of of the nick story everything

00:11:27,210 --> 00:11:30,870
that you will build will gone will end

00:11:29,310 --> 00:11:32,280
up in the next or most of the time it's

00:11:30,870 --> 00:11:35,040
going to be the slash Nick slashed or

00:11:32,280 --> 00:11:37,530
path you could point next to something

00:11:35,040 --> 00:11:40,020
else but you will always have one single

00:11:37,530 --> 00:11:43,110
nick store in Nick's and that does not

00:11:40,020 --> 00:11:44,310
work very well in in our case first of

00:11:43,110 --> 00:11:45,990
all because the next store it's on your

00:11:44,310 --> 00:11:47,580
local fight system and we don't want to

00:11:45,990 --> 00:11:49,860
build stuff on our local file system we

00:11:47,580 --> 00:11:52,860
want to build stuff on on that HDFS and

00:11:49,860 --> 00:11:54,630
then where I work we have strong set of

00:11:52,860 --> 00:11:56,400
conventions around how stuff should be

00:11:54,630 --> 00:11:58,110
organized on HDFS every single team

00:11:56,400 --> 00:12:00,360
should have their own sub dere and

00:11:58,110 --> 00:12:01,140
different projects will also add their

00:12:00,360 --> 00:12:03,810
own sub dear

00:12:01,140 --> 00:12:06,180
so having having everything being built

00:12:03,810 --> 00:12:08,120
in one big store that contains

00:12:06,180 --> 00:12:11,250
everything is not not really an option

00:12:08,120 --> 00:12:14,160
so as a result that mix tool the the the

00:12:11,250 --> 00:12:17,430
new thing it its redefining derivation

00:12:14,160 --> 00:12:18,870
the derivation in mix are I very similar

00:12:17,430 --> 00:12:21,210
to the one in the classical Nick's but

00:12:18,870 --> 00:12:22,890
they also have they although the output

00:12:21,210 --> 00:12:24,420
to go pretty much everywhere in the file

00:12:22,890 --> 00:12:28,500
system and not just only in the mix

00:12:24,420 --> 00:12:32,430
store we also implement some very simple

00:12:28,500 --> 00:12:35,040
building very proof-of-concept level so

00:12:32,430 --> 00:12:36,870
we have we have these derivations and we

00:12:35,040 --> 00:12:38,550
we build them we build their

00:12:36,870 --> 00:12:41,910
dependencies we don't do any parallel

00:12:38,550 --> 00:12:43,860
building we don't do any any sandbox the

00:12:41,910 --> 00:12:45,480
most simple thing to get a proof of

00:12:43,860 --> 00:12:47,160
concept working

00:12:45,480 --> 00:12:49,620
we don't even sterilize the derivation

00:12:47,160 --> 00:12:51,990
we don't write them to disk or put them

00:12:49,620 --> 00:12:53,610
on a database we could that would

00:12:51,990 --> 00:12:55,440
definitely be very nice to make some

00:12:53,610 --> 00:12:57,870
some to linger around that but this

00:12:55,440 --> 00:13:00,210
version does not not no such thing it's

00:12:57,870 --> 00:13:04,260
mostly we are mostly interested in how

00:13:00,210 --> 00:13:07,530
to build the derivations the the last

00:13:04,260 --> 00:13:09,390
piece of that is that for this I decided

00:13:07,530 --> 00:13:10,770
to go with the Ning docker to specify

00:13:09,390 --> 00:13:12,840
how to build the derivations

00:13:10,770 --> 00:13:15,480
once again is because of pre-existing

00:13:12,840 --> 00:13:17,550
conventions where I work we did most

00:13:15,480 --> 00:13:19,030
about we build package and distribute

00:13:17,550 --> 00:13:20,860
most of our stuff with

00:13:19,030 --> 00:13:22,900
docker containers so the cud I need to

00:13:20,860 --> 00:13:24,280
use to build my pipelines is already

00:13:22,900 --> 00:13:27,700
available as the docker container all

00:13:24,280 --> 00:13:30,220
the tuning for that is used so this

00:13:27,700 --> 00:13:31,930
derivation on top of having of being

00:13:30,220 --> 00:13:33,610
able to have an output anywhere it will

00:13:31,930 --> 00:13:35,590
also have one more to reach with which

00:13:33,610 --> 00:13:37,930
is the container in which the derivation

00:13:35,590 --> 00:13:39,400
needs to be built it's mostly just a

00:13:37,930 --> 00:13:44,470
path through to the Builder which which

00:13:39,400 --> 00:13:46,840
will then end up calling docker and yeah

00:13:44,470 --> 00:13:48,790
we end up with this new tool in which we

00:13:46,840 --> 00:13:50,980
have a derivation primitive so this is

00:13:48,790 --> 00:13:52,870
next the language but it will not be

00:13:50,980 --> 00:13:57,070
interpreted by next the tool it will be

00:13:52,870 --> 00:13:58,510
interpreted by by mix this is nearly the

00:13:57,070 --> 00:14:00,550
same derivation function you would

00:13:58,510 --> 00:14:02,080
expect to see in in classical NICs

00:14:00,550 --> 00:14:04,030
except it has to attribute that you

00:14:02,080 --> 00:14:08,800
don't have in Nix it has this prefix

00:14:04,030 --> 00:14:10,480
which tells us where the where the the

00:14:08,800 --> 00:14:12,460
output is actually supposed to be and it

00:14:10,480 --> 00:14:16,170
has this container which tells us how to

00:14:12,460 --> 00:14:18,820
actually build build the derivation and

00:14:16,170 --> 00:14:21,070
when you run mix well it's it's gonna

00:14:18,820 --> 00:14:22,540
it's gonna do what you expect on the

00:14:21,070 --> 00:14:24,430
dairy is sorry from the derivation

00:14:22,540 --> 00:14:26,440
function it's gonna is gonna take the

00:14:24,430 --> 00:14:29,020
prefix and and the hash of the

00:14:26,440 --> 00:14:31,990
derivation and and the name and and it

00:14:29,020 --> 00:14:36,790
will give you the possibility to to

00:14:31,990 --> 00:14:39,130
build it I said that we don't sterilize

00:14:36,790 --> 00:14:40,930
the derivation this is the pretty

00:14:39,130 --> 00:14:45,340
printing of the memory representation of

00:14:40,930 --> 00:14:47,740
the derivation not nothing very fancy to

00:14:45,340 --> 00:14:49,990
see here it's it's nearly the same as

00:14:47,740 --> 00:14:52,210
what you would find in the dot div file

00:14:49,990 --> 00:14:56,110
in the in the next or accept it as a

00:14:52,210 --> 00:14:58,390
container a container attribute but it's

00:14:56,110 --> 00:15:00,760
very it's the same thing and as an usual

00:14:58,390 --> 00:15:01,870
dairy agent as an output and it tells

00:15:00,760 --> 00:15:03,940
you with the Builder args and

00:15:01,870 --> 00:15:08,650
environment variables what to run in

00:15:03,940 --> 00:15:11,830
order to to get that output okay so

00:15:08,650 --> 00:15:13,780
we've got this is very this tool this

00:15:11,830 --> 00:15:16,960
mix tool very close to NYX that is

00:15:13,780 --> 00:15:19,570
suitable to define our our batch jobs

00:15:16,960 --> 00:15:21,340
because it knows about HDFS and and it

00:15:19,570 --> 00:15:23,470
goes around the the restriction of next

00:15:21,340 --> 00:15:25,780
so it's it goes with that problem

00:15:23,470 --> 00:15:29,680
no we end up we have the issue of

00:15:25,780 --> 00:15:31,090
defining an NYX code base in the next

00:15:29,680 --> 00:15:33,310
code base being the definition of

00:15:31,090 --> 00:15:36,280
of the pipeline all my bad jobs and

00:15:33,310 --> 00:15:39,700
their dependencies we can start with the

00:15:36,280 --> 00:15:42,580
most simple way to do it we define a new

00:15:39,700 --> 00:15:45,220
derivation by just calling duration on a

00:15:42,580 --> 00:15:47,770
very raw call to derivation for my first

00:15:45,220 --> 00:15:49,450
job my candidates job I give the name

00:15:47,770 --> 00:15:51,190
the container the builder is gonna be

00:15:49,450 --> 00:15:53,560
bash and then the arguments I pass to

00:15:51,190 --> 00:15:55,270
bash the prefix and then some and very

00:15:53,560 --> 00:15:58,900
enviable I need to provide for further

00:15:55,270 --> 00:16:00,700
thing to work and and I can make my

00:15:58,900 --> 00:16:02,230
first derivation like that and it will

00:16:00,700 --> 00:16:04,180
look like this in memory

00:16:02,230 --> 00:16:05,680
nothing nothing fancy it's pretty much

00:16:04,180 --> 00:16:08,500
the same thing I had before I can see

00:16:05,680 --> 00:16:10,480
that the output was well it was filled

00:16:08,500 --> 00:16:13,090
with the prefix the hash and the name

00:16:10,480 --> 00:16:15,340
and I can run that it will it will build

00:16:13,090 --> 00:16:17,230
it it will run the actual spark submit

00:16:15,340 --> 00:16:20,080
comment which is the thing we need to

00:16:17,230 --> 00:16:22,480
run to to run small jobs and it will put

00:16:20,080 --> 00:16:26,440
the output in the output so far so good

00:16:22,480 --> 00:16:27,550
nothing no nothing super fancy it's it's

00:16:26,440 --> 00:16:32,470
not really better than just having

00:16:27,550 --> 00:16:33,190
written batch scripts so we want to make

00:16:32,470 --> 00:16:36,820
this better

00:16:33,190 --> 00:16:38,740
I know because I look any mix packages I

00:16:36,820 --> 00:16:41,620
know it's we can make expression of

00:16:38,740 --> 00:16:43,570
package is much nicer and I know we can

00:16:41,620 --> 00:16:45,010
we can have this override this tweaking

00:16:43,570 --> 00:16:49,690
thing when we were talking about earlier

00:16:45,010 --> 00:16:51,460
and so in order to see how to do that I

00:16:49,690 --> 00:16:54,130
I looked into well it's pretty much the

00:16:51,460 --> 00:16:56,830
only mix codebase I know it's the one

00:16:54,130 --> 00:17:00,790
definition of all the package around nix

00:16:56,830 --> 00:17:02,770
that that is next packages and III I

00:17:00,790 --> 00:17:04,330
looked into that and I I saw multiple

00:17:02,770 --> 00:17:06,550
multiple patterns that we could reuse in

00:17:04,330 --> 00:17:07,930
order to organize on our own mix code

00:17:06,550 --> 00:17:10,750
base in order to make it nicer and make

00:17:07,930 --> 00:17:14,140
it easier to express this these

00:17:10,750 --> 00:17:16,150
derivations is bad jobs and the first

00:17:14,140 --> 00:17:18,220
thing we do so here we are back with a

00:17:16,150 --> 00:17:19,420
very row or a definition the first thing

00:17:18,220 --> 00:17:21,850
we do is that we are going to notice

00:17:19,420 --> 00:17:24,190
that most of the jobs we want to build

00:17:21,850 --> 00:17:25,810
we want to build them with bash and the

00:17:24,190 --> 00:17:27,640
thing we actually run to write is this

00:17:25,810 --> 00:17:29,800
the difference between this one and that

00:17:27,640 --> 00:17:31,720
one is that I I just provide the command

00:17:29,800 --> 00:17:33,910
to run in passion I don't bother writing

00:17:31,720 --> 00:17:36,880
how to run bash and with with what word

00:17:33,910 --> 00:17:38,650
flags and to define this this bash

00:17:36,880 --> 00:17:40,240
derivation function

00:17:38,650 --> 00:17:42,370
this is actually a pattern that is very

00:17:40,240 --> 00:17:45,940
very common in next package it it's

00:17:42,370 --> 00:17:48,370
about defining defining a function Bosch

00:17:45,940 --> 00:17:51,610
elevation which will take a set of alpha

00:17:48,370 --> 00:17:53,230
tributes that will call derivation with

00:17:51,610 --> 00:17:55,500
these attributes but on top of doing

00:17:53,230 --> 00:17:58,920
that it's also pick some stuff out of

00:17:55,500 --> 00:18:02,500
these set of attributes and use them to

00:17:58,920 --> 00:18:04,930
inject some new arguments here so in

00:18:02,500 --> 00:18:06,370
this case we are mostly interesting in

00:18:04,930 --> 00:18:08,110
the common in the container that that

00:18:06,370 --> 00:18:10,330
are being passed and then we pass them

00:18:08,110 --> 00:18:11,710
to derivation but we also add the

00:18:10,330 --> 00:18:13,450
Builder that is gonna always going to be

00:18:11,710 --> 00:18:16,960
bash and the arcs which is are always

00:18:13,450 --> 00:18:18,880
gonna be - easy comment and this thing

00:18:16,960 --> 00:18:21,670
this pattern that is that is very very

00:18:18,880 --> 00:18:23,290
common in X packages allows us to well

00:18:21,670 --> 00:18:25,870
it allows us to have this badge

00:18:23,290 --> 00:18:27,790
derivation that that let us define this

00:18:25,870 --> 00:18:31,179
so know every single derivation I have

00:18:27,790 --> 00:18:33,700
that will that I will want to build with

00:18:31,179 --> 00:18:39,460
bash rather than just evoke in invoking

00:18:33,700 --> 00:18:41,710
the the Row the row builder I will be

00:18:39,460 --> 00:18:43,390
able to use that but we can go further

00:18:41,710 --> 00:18:44,679
because I know most of my job are going

00:18:43,390 --> 00:18:46,960
to be spark jobs and there's a lot of

00:18:44,679 --> 00:18:49,500
well if I look here there's a lot of

00:18:46,960 --> 00:18:52,900
stuff that are boilerplate to run spark

00:18:49,500 --> 00:18:55,750
so I wouldn't want to have my spark my

00:18:52,900 --> 00:18:57,640
spoke derivation definition and once

00:18:55,750 --> 00:18:59,530
again once again I will use the same

00:18:57,640 --> 00:19:01,870
pattern that function that takes a lot

00:18:59,530 --> 00:19:03,160
of that takes the attribute and extract

00:19:01,870 --> 00:19:05,230
some interesting out of them and then

00:19:03,160 --> 00:19:08,590
cause another function in this case

00:19:05,230 --> 00:19:10,510
called bash derivation not directly

00:19:08,590 --> 00:19:12,490
derivation but bash derivation so I can

00:19:10,510 --> 00:19:14,980
actually layer these abstractions or on

00:19:12,490 --> 00:19:16,330
top of each other and here I take a

00:19:14,980 --> 00:19:17,920
bunch of different arguments because

00:19:16,330 --> 00:19:20,700
there are a lot of things that I could

00:19:17,920 --> 00:19:23,740
want to configure in my in my spark jobs

00:19:20,700 --> 00:19:26,830
the jar in which to code is to class its

00:19:23,740 --> 00:19:29,380
this is Java world so the class that is

00:19:26,830 --> 00:19:30,820
the entry point of the code and and then

00:19:29,380 --> 00:19:33,070
some of the argument I might be

00:19:30,820 --> 00:19:35,380
interested in and we call by derivation

00:19:33,070 --> 00:19:39,160
with the comment that will use all these

00:19:35,380 --> 00:19:45,010
or all these possible arguments we can

00:19:39,160 --> 00:19:48,250
override and so we have we have now this

00:19:45,010 --> 00:19:50,200
nice way to define one one batch jobs in

00:19:48,250 --> 00:19:51,970
order to define all of them I can use a

00:19:50,200 --> 00:19:54,280
recursive set in Nick so I

00:19:51,970 --> 00:19:56,350
defined my first derivation my first

00:19:54,280 --> 00:19:58,570
bath job candidates by calling Spock

00:19:56,350 --> 00:20:01,900
derivation and then I will define the

00:19:58,570 --> 00:20:03,430
next one in rich candidate by also a

00:20:01,900 --> 00:20:06,370
call to Spock the revision that that can

00:20:03,430 --> 00:20:08,470
refer to candidates because it's a

00:20:06,370 --> 00:20:10,930
recursive set and because when you try

00:20:08,470 --> 00:20:14,080
when you refer to a derivation and you

00:20:10,930 --> 00:20:16,480
want it to be to be a string you will

00:20:14,080 --> 00:20:17,890
get the you will get the output of the

00:20:16,480 --> 00:20:21,430
derivation the output path where the

00:20:17,890 --> 00:20:25,450
derivation has actually be built you

00:20:21,430 --> 00:20:27,340
will also get a and a string with an

00:20:25,450 --> 00:20:28,600
attached context and an attached marker

00:20:27,340 --> 00:20:30,310
that says that this string actually

00:20:28,600 --> 00:20:32,140
comes from that derivation which allows

00:20:30,310 --> 00:20:36,730
next to know that enrich candidates

00:20:32,140 --> 00:20:39,430
actually depends on candidates and and

00:20:36,730 --> 00:20:40,840
yeah and that works I get my set of job

00:20:39,430 --> 00:20:43,810
this is this is actually my pipeline

00:20:40,840 --> 00:20:45,880
it's the set of all my batch jobs that

00:20:43,810 --> 00:20:48,880
depend on each other then I can run and

00:20:45,880 --> 00:20:50,680
and that is actually that that is

00:20:48,880 --> 00:20:52,480
already pretty nice it's already a

00:20:50,680 --> 00:20:54,370
pretty nice language to define my

00:20:52,480 --> 00:20:55,990
pipelines it allows me to have

00:20:54,370 --> 00:20:57,760
abstraction in order to refactor and

00:20:55,990 --> 00:20:59,770
reduce the code and can keep it clear

00:20:57,760 --> 00:21:04,620
and simple it's actually better than

00:20:59,770 --> 00:21:07,720
what I already have in prediction but

00:21:04,620 --> 00:21:09,760
but I wanted I I want more I want to

00:21:07,720 --> 00:21:11,110
actually tweak jobs because I've done

00:21:09,760 --> 00:21:12,490
nothing about these tweaking and and

00:21:11,110 --> 00:21:16,540
this flexibility I was talking about

00:21:12,490 --> 00:21:17,920
earlier what we want is this I want to

00:21:16,540 --> 00:21:21,550
have my weekly dot next file that

00:21:17,920 --> 00:21:23,560
contains all my production my prediction

00:21:21,550 --> 00:21:27,520
definition and I want to import it and I

00:21:23,560 --> 00:21:28,900
want to override it I want to take the

00:21:27,520 --> 00:21:31,060
candidate and say oh the important

00:21:28,900 --> 00:21:32,560
parameter should be should be set to 11

00:21:31,060 --> 00:21:35,440
instead of 10 because it's it's very

00:21:32,560 --> 00:21:38,560
important that it's set to 11 or at

00:21:35,440 --> 00:21:40,780
least I want to try it set to 11 and for

00:21:38,560 --> 00:21:43,090
this we can take this this abstraction

00:21:40,780 --> 00:21:46,300
that is that is present in UNIX packages

00:21:43,090 --> 00:21:48,250
the make over a table it's it's it's

00:21:46,300 --> 00:21:50,380
basically wrapper around the function it

00:21:48,250 --> 00:21:52,390
will when you call it you will still get

00:21:50,380 --> 00:21:54,160
the original result of the function but

00:21:52,390 --> 00:21:56,890
it will also injecting the result in the

00:21:54,160 --> 00:21:58,810
result set and never write function that

00:21:56,890 --> 00:22:00,820
will allow you to call again that

00:21:58,810 --> 00:22:03,040
function but overriding but tweaking the

00:22:00,820 --> 00:22:05,140
arguments which with it won't it was

00:22:03,040 --> 00:22:07,480
call in the first place

00:22:05,140 --> 00:22:09,040
an example of how to use it I've ever I

00:22:07,480 --> 00:22:11,020
have a very simple function here the

00:22:09,040 --> 00:22:12,790
make path that takes a prefix in the

00:22:11,020 --> 00:22:16,630
name and it can't get concatenate it

00:22:12,790 --> 00:22:18,130
with the slash in between if I make it a

00:22:16,630 --> 00:22:19,570
variable and then I call it so the

00:22:18,130 --> 00:22:22,330
perfect is slash user and the name is

00:22:19,570 --> 00:22:24,370
discovery which is the name of my team I

00:22:22,330 --> 00:22:26,950
get the path that contained the result

00:22:24,370 --> 00:22:28,710
but the path also as an a write function

00:22:26,950 --> 00:22:31,059
I can call with some additional argument

00:22:28,710 --> 00:22:33,270
that will be used to replace the

00:22:31,059 --> 00:22:37,240
original arguments of the function and

00:22:33,270 --> 00:22:38,830
so here I can call I can call the

00:22:37,240 --> 00:22:40,809
Passover adding just the name it will

00:22:38,830 --> 00:22:43,330
keep the original prefix and I get my

00:22:40,809 --> 00:22:46,540
new result which is my new name with my

00:22:43,330 --> 00:22:48,340
original prefix and this this technique

00:22:46,540 --> 00:22:52,030
we can use it on our definition of

00:22:48,340 --> 00:22:53,980
derivations I can actually make so first

00:22:52,030 --> 00:22:55,270
of all I have to change things a beta I

00:22:53,980 --> 00:22:56,799
need to make the definition of my

00:22:55,270 --> 00:22:59,020
derivation a function that will take the

00:22:56,799 --> 00:23:00,820
argument I want to overwrite so I change

00:22:59,020 --> 00:23:03,820
the important I make it a function

00:23:00,820 --> 00:23:05,350
important paradigm is now it's now an

00:23:03,820 --> 00:23:07,090
argument of that function it defaults to

00:23:05,350 --> 00:23:09,160
10 and it's used in the in the

00:23:07,090 --> 00:23:11,620
definition of the derivation and then I

00:23:09,160 --> 00:23:13,090
can make candidates I can make it over a

00:23:11,620 --> 00:23:15,520
table and get to candidates by calling

00:23:13,090 --> 00:23:17,140
make candidates and this allows me to

00:23:15,520 --> 00:23:19,809
write this this allows me to get my

00:23:17,140 --> 00:23:21,730
definition and write overrides sorry in

00:23:19,809 --> 00:23:23,080
call overrides on it too to change the

00:23:21,730 --> 00:23:25,419
value in the important parameter and get

00:23:23,080 --> 00:23:28,270
a new derivation that is exactly the

00:23:25,419 --> 00:23:32,530
same one as before except these specific

00:23:28,270 --> 00:23:34,570
parameters has been overridden and I can

00:23:32,530 --> 00:23:37,480
do that for parameter but I can also do

00:23:34,570 --> 00:23:39,700
that for dependencies him here I will

00:23:37,480 --> 00:23:42,130
make my enrich candidate or variable by

00:23:39,700 --> 00:23:44,440
setting candidate to be an argument of

00:23:42,130 --> 00:23:46,419
the function is the same thing and that

00:23:44,440 --> 00:23:49,450
allows me to do that

00:23:46,419 --> 00:23:51,280
also I can override what candidate is in

00:23:49,450 --> 00:23:53,740
the definition of enrich candidates I

00:23:51,280 --> 00:23:55,929
could make it another derivation or I

00:23:53,740 --> 00:23:58,179
could make it another how to the pass a

00:23:55,929 --> 00:23:59,950
string I have pre computed it I

00:23:58,179 --> 00:24:02,830
absolutely want to run it on that pre

00:23:59,950 --> 00:24:04,660
computed value I can do it that way this

00:24:02,830 --> 00:24:06,400
will return me a new derivation that is

00:24:04,660 --> 00:24:09,429
exactly the same as a rich candidate

00:24:06,400 --> 00:24:11,860
except the input the candidates input is

00:24:09,429 --> 00:24:15,850
this one instead of of whatever I had

00:24:11,860 --> 00:24:17,700
before that's already pretty nice I am

00:24:15,850 --> 00:24:20,160
now able to take any single

00:24:17,700 --> 00:24:22,350
that's job in a single derivation I have

00:24:20,160 --> 00:24:26,040
an ANOVA read it and tweak it and change

00:24:22,350 --> 00:24:28,110
one or multiple parameters in here but

00:24:26,040 --> 00:24:29,880
that's not yet what I want I remember I

00:24:28,110 --> 00:24:32,220
wanted to trick the entire pipeline I

00:24:29,880 --> 00:24:34,020
wanted to take derivation and change it

00:24:32,220 --> 00:24:37,590
and then get the final result that I

00:24:34,020 --> 00:24:39,230
don't have it yet so let's get it this

00:24:37,590 --> 00:24:42,380
is what I want to write I want to say

00:24:39,230 --> 00:24:45,990
import my production definitions and

00:24:42,380 --> 00:24:48,720
extend it by changing what candidates is

00:24:45,990 --> 00:24:50,610
in that set not just what candidates is

00:24:48,720 --> 00:24:52,740
for an original it died but rather but

00:24:50,610 --> 00:24:58,020
what it is in that specific in in that

00:24:52,740 --> 00:24:59,640
in that pipeline and the issue I

00:24:58,020 --> 00:25:02,810
encounter while doing that is that I

00:24:59,640 --> 00:25:06,600
defined all my jobs with a recursive set

00:25:02,810 --> 00:25:09,330
which means that once I evaluate Nix I

00:25:06,600 --> 00:25:12,780
get the setbacks the recursion is part

00:25:09,330 --> 00:25:14,280
of the syntax of Nix so I get a set that

00:25:12,780 --> 00:25:15,780
contains candidates in enriched

00:25:14,280 --> 00:25:19,020
candidates but there's nothing in that

00:25:15,780 --> 00:25:20,790
set that tells me that can the the

00:25:19,020 --> 00:25:22,380
attribute candidates in that set was

00:25:20,790 --> 00:25:24,870
used in the definition of any which

00:25:22,380 --> 00:25:26,610
candidates it is the case I use the

00:25:24,870 --> 00:25:28,320
attribute candidates here in the

00:25:26,610 --> 00:25:29,360
definition that when I get that back I

00:25:28,320 --> 00:25:31,830
have lost that piece of information

00:25:29,360 --> 00:25:33,900
which I will need if I want to actually

00:25:31,830 --> 00:25:35,550
do that that override and so the way to

00:25:33,900 --> 00:25:37,650
work around that is to is to do the

00:25:35,550 --> 00:25:40,620
recursion ourself instead of defining

00:25:37,650 --> 00:25:42,480
defining it as a set at a recursive set

00:25:40,620 --> 00:25:44,580
we define it as a function that takes a

00:25:42,480 --> 00:25:48,180
set and written and returns a set and

00:25:44,580 --> 00:25:49,470
that will use the input set to well to

00:25:48,180 --> 00:25:52,800
look into itself because we are going to

00:25:49,470 --> 00:25:54,870
call it by passing its output as as its

00:25:52,800 --> 00:25:58,500
own input it's a technique that is

00:25:54,870 --> 00:26:03,780
called it's the fixed point recursion

00:25:58,500 --> 00:26:07,380
it's it's pretty common in well in lazy

00:26:03,780 --> 00:26:09,180
functional programming it's and yeah it

00:26:07,380 --> 00:26:11,040
allows us to represent our set this way

00:26:09,180 --> 00:26:15,240
and get the exact same result we had

00:26:11,040 --> 00:26:17,490
before so if I turn my representation of

00:26:15,240 --> 00:26:19,560
my pipeline of my set to that I can

00:26:17,490 --> 00:26:21,870
define this Mac extensible and this is

00:26:19,560 --> 00:26:24,270
also something we can find in next

00:26:21,870 --> 00:26:27,570
packages I'll bet this one is a bit

00:26:24,270 --> 00:26:30,930
tweaked and it will return the fixed

00:26:27,570 --> 00:26:32,100
point of the set so the actual set of of

00:26:30,930 --> 00:26:33,840
derivation size

00:26:32,100 --> 00:26:37,799
plus an excellent function that will

00:26:33,840 --> 00:26:39,840
allow me to to well to modify to tweak

00:26:37,799 --> 00:26:42,830
the recursive set before actually

00:26:39,840 --> 00:26:45,179
applying the recursion which will which

00:26:42,830 --> 00:26:47,610
allows me to be exactly the thing I want

00:26:45,179 --> 00:26:48,779
it allows me to size I want the set but

00:26:47,610 --> 00:26:50,519
I want to modify something in the

00:26:48,779 --> 00:26:52,409
definition of the set and then all the

00:26:50,519 --> 00:26:54,210
stuff that our recursively defined

00:26:52,409 --> 00:26:57,360
depending on this will also be changed

00:26:54,210 --> 00:26:59,880
and the last two thing I was mentioning

00:26:57,360 --> 00:27:02,880
well I can use them together I can use

00:26:59,880 --> 00:27:04,740
that extent to change some to change the

00:27:02,880 --> 00:27:07,679
definition of the whole pipeline a and I

00:27:04,740 --> 00:27:10,769
can use that override to change one

00:27:07,679 --> 00:27:12,690
parameter and this is the thing I wanted

00:27:10,769 --> 00:27:14,519
this is actually the thing I wanted in

00:27:12,690 --> 00:27:17,429
the first place this allows me to say oh

00:27:14,519 --> 00:27:19,429
I want to take the definition I have for

00:27:17,429 --> 00:27:22,230
my production production pipeline and

00:27:19,429 --> 00:27:24,179
change the candidates and change the

00:27:22,230 --> 00:27:27,090
important param parameter of the

00:27:24,179 --> 00:27:30,659
candidate to this and get the final

00:27:27,090 --> 00:27:35,539
result that depend on this and and this

00:27:30,659 --> 00:27:35,539
this gives it to me I I actually have it

00:27:35,929 --> 00:27:41,429
so so so in conclusion well NYX is a

00:27:39,690 --> 00:27:44,039
pretty awesome DSL for data pipelines

00:27:41,429 --> 00:27:46,139
not not only does it give me a very nice

00:27:44,039 --> 00:27:48,720
way to express the data pipeline it also

00:27:46,139 --> 00:27:51,029
gives me that that overriding feature I

00:27:48,720 --> 00:27:53,669
want it and that I to be frank I have

00:27:51,029 --> 00:27:55,919
not found in any other tool for that

00:27:53,669 --> 00:27:59,580
that is usually used to to express data

00:27:55,919 --> 00:28:01,049
data pipelines but the other thing I

00:27:59,580 --> 00:28:02,880
want to conclude out of that is that

00:28:01,049 --> 00:28:06,090
data pipelines is great in laboratory

00:28:02,880 --> 00:28:08,460
fornix having this small set of packages

00:28:06,090 --> 00:28:11,460
a small set of batch jobs and there

00:28:08,460 --> 00:28:13,289
evasions allowed me to well to explore

00:28:11,460 --> 00:28:16,230
this abstraction and to actually

00:28:13,289 --> 00:28:17,730
understand them to explore this

00:28:16,230 --> 00:28:21,600
abstraction we have in Ex packages but

00:28:17,730 --> 00:28:24,059
in a much much smaller scope and to

00:28:21,600 --> 00:28:26,909
finish kind of on on the teaser or not

00:28:24,059 --> 00:28:28,799
it also allowed me to explore different

00:28:26,909 --> 00:28:32,549
techniques that are not used that I'm

00:28:28,799 --> 00:28:34,980
not yet used in indexed packages I've I

00:28:32,549 --> 00:28:36,690
took some inspiration from some design

00:28:34,980 --> 00:28:40,139
document around configurations around

00:28:36,690 --> 00:28:42,809
expressing derivations and expressing

00:28:40,139 --> 00:28:44,730
packages as as recursive recursive sets

00:28:42,809 --> 00:28:47,760
and I implemented another

00:28:44,730 --> 00:28:49,590
of my own pipeline definition but based

00:28:47,760 --> 00:28:53,460
on that idea based on having recursive

00:28:49,590 --> 00:28:55,410
sets and it works quite well it's it's

00:28:53,460 --> 00:28:57,030
actually nicer to you use and to express

00:28:55,410 --> 00:29:00,120
than the original thing and it allows me

00:28:57,030 --> 00:29:02,280
in the end to to do my my end derivation

00:29:00,120 --> 00:29:03,630
with that by saying this is a different

00:29:02,280 --> 00:29:05,520
definition of extent it's not the same

00:29:03,630 --> 00:29:07,290
words as before but to say I want to

00:29:05,520 --> 00:29:09,000
take my whole pipeline and I want to

00:29:07,290 --> 00:29:10,890
change candidates out important

00:29:09,000 --> 00:29:12,870
important parameter set it to 11 and

00:29:10,890 --> 00:29:15,750
another candidate that number of

00:29:12,870 --> 00:29:18,450
executors set to 500 and this is

00:29:15,750 --> 00:29:20,130
actually pretty nice because as as Elka

00:29:18,450 --> 00:29:22,830
mentioned earlier this is a way to get

00:29:20,130 --> 00:29:25,260
around the the restrictions or around

00:29:22,830 --> 00:29:26,730
overrides around override attribute with

00:29:25,260 --> 00:29:28,770
which I have not mentioned but is

00:29:26,730 --> 00:29:30,090
another way to override that you kind of

00:29:28,770 --> 00:29:32,250
have to get into also if you want to

00:29:30,090 --> 00:29:35,190
express every every single of a ride you

00:29:32,250 --> 00:29:38,340
want and yeah and it's actually pretty

00:29:35,190 --> 00:29:42,260
nice so that that's everything I have

00:29:38,340 --> 00:29:42,260
thank you very much for your attention

00:29:47,679 --> 00:29:50,539
hi guys thank you so much for your great

00:29:50,090 --> 00:29:53,720
talk

00:29:50,539 --> 00:29:55,869
do we have questions oh yes hands up

00:29:53,720 --> 00:29:55,869
already

00:29:56,240 --> 00:30:00,649
thank you for the salt was very

00:29:58,009 --> 00:30:05,119
interesting question so you you write

00:30:00,649 --> 00:30:07,580
your own logic in mix um how do you test

00:30:05,119 --> 00:30:11,720
it how can you prove that what you

00:30:07,580 --> 00:30:13,549
intend is actually happening Thanks

00:30:11,720 --> 00:30:16,009
that that's a very good question one

00:30:13,549 --> 00:30:17,809
when I have not solved yet it's actually

00:30:16,009 --> 00:30:21,559
a question that you have in every single

00:30:17,809 --> 00:30:23,990
data data pipeline configuration tool we

00:30:21,559 --> 00:30:26,029
in the current configuration we have we

00:30:23,990 --> 00:30:28,159
are very strict tests that test that to

00:30:26,029 --> 00:30:30,230
command the actual command rerun are the

00:30:28,159 --> 00:30:31,700
one we want to be running this is too

00:30:30,230 --> 00:30:33,169
much testing because every time we want

00:30:31,700 --> 00:30:35,809
to make a change in the pipeline we

00:30:33,169 --> 00:30:39,590
change the tests to reflect it without

00:30:35,809 --> 00:30:41,600
really thinking about it I don't have a

00:30:39,590 --> 00:30:43,940
good answer on how to actually test it

00:30:41,600 --> 00:30:45,710
in a way that is not just check that the

00:30:43,940 --> 00:30:50,299
output is exactly the thing that you

00:30:45,710 --> 00:30:52,730
want to run so I know upstream H Nix

00:30:50,299 --> 00:30:56,389
doesn't have string context yet how did

00:30:52,730 --> 00:30:58,940
you implement that and it does have

00:30:56,389 --> 00:31:03,249
string context just not being added to

00:30:58,940 --> 00:31:05,480
anything I kind of made the patch quick

00:31:03,249 --> 00:31:08,779
I was wondering if you had like a good

00:31:05,480 --> 00:31:12,080
solution there yeah so I am I

00:31:08,779 --> 00:31:15,499
implemented in a in the previous in the

00:31:12,080 --> 00:31:17,840
previous iteration of H Nix before all

00:31:15,499 --> 00:31:22,610
the Rikyu of the recursive thing where

00:31:17,840 --> 00:31:23,720
we're fixed and I reimplemented it it's

00:31:22,610 --> 00:31:24,919
got a pull request that is closed

00:31:23,720 --> 00:31:26,570
because it doesn't go in the right

00:31:24,919 --> 00:31:28,700
direction but it's good enough to work

00:31:26,570 --> 00:31:32,840
yet

00:31:28,700 --> 00:31:35,179
you are using this in production or I am

00:31:32,840 --> 00:31:38,450
not using this in production it's mostly

00:31:35,179 --> 00:31:40,940
in the proof-of-concept State for now

00:31:38,450 --> 00:31:43,820
mostly it's not because it's not good

00:31:40,940 --> 00:31:45,220
it's because the well the quality of the

00:31:43,820 --> 00:31:49,070
code I wrote to make it work is

00:31:45,220 --> 00:31:51,320
definitely not production great sub

00:31:49,070 --> 00:31:53,529
question did you show this to your

00:31:51,320 --> 00:31:55,639
co-workers and what did they say I

00:31:53,529 --> 00:31:59,139
showed this to my co-workers and they

00:31:55,639 --> 00:31:59,139
say why is this not yet in production

00:32:01,170 --> 00:32:07,810
any other questions yeah you may feel

00:32:06,460 --> 00:32:13,360
free to raise your hand so I actually

00:32:07,810 --> 00:32:16,200
see do you plan to open so at some point

00:32:13,360 --> 00:32:18,940
oh yeah I still have to untangle the

00:32:16,200 --> 00:32:21,220
part that are open so scible in the part

00:32:18,940 --> 00:32:23,620
that are really tied to the the stuff

00:32:21,220 --> 00:32:25,870
the the actual pipeline we run in that I

00:32:23,620 --> 00:32:27,610
cannot bike public but yeah I will

00:32:25,870 --> 00:32:31,870
definitely want to purchase that in the

00:32:27,610 --> 00:32:32,820
coming weeks good time for one last

00:32:31,870 --> 00:32:43,360
question

00:32:32,820 --> 00:32:46,630
yes I'm sorry this looks really great

00:32:43,360 --> 00:32:48,790
for like pure data pipelines do you have

00:32:46,630 --> 00:32:51,460
any way to integrate with asynchronous

00:32:48,790 --> 00:32:53,380
triggers like say another team provides

00:32:51,460 --> 00:32:57,840
some data or a human has to sign off on

00:32:53,380 --> 00:33:00,160
something or something like that no it's

00:32:57,840 --> 00:33:01,930
either imitation or at least something

00:33:00,160 --> 00:33:04,240
that is definitely not not solved by

00:33:01,930 --> 00:33:06,760
this in one of the previous version of

00:33:04,240 --> 00:33:09,100
my slide I I had some some list of off

00:33:06,760 --> 00:33:10,860
limitation but the the IDS this could be

00:33:09,100 --> 00:33:13,870
the basis to build some very nice

00:33:10,860 --> 00:33:15,760
building to not the building tool not

00:33:13,870 --> 00:33:17,830
all of the build tool itself or or

00:33:15,760 --> 00:33:20,290
rather job scheduling tool itself but

00:33:17,830 --> 00:33:21,760
the basis to build it there are still

00:33:20,290 --> 00:33:25,660
other problems you need to solve on top

00:33:21,760 --> 00:33:27,940
such as the one you say for now in my in

00:33:25,660 --> 00:33:29,860
my proof of concept the way I solved it

00:33:27,940 --> 00:33:31,720
is that I have some bad script that

00:33:29,860 --> 00:33:33,780
resolves external dependencies and and

00:33:31,720 --> 00:33:36,010
passed them as argument to the next code

00:33:33,780 --> 00:33:39,310
you you would definitely want something

00:33:36,010 --> 00:33:41,740
better for protection okay alrighty

00:33:39,310 --> 00:33:43,580
that's all the time we have so thank you

00:33:41,740 --> 00:33:52,500
so much for your wonderful talk

00:33:43,580 --> 00:33:52,500

YouTube URL: https://www.youtube.com/watch?v=tc5ApNqhAQ4


