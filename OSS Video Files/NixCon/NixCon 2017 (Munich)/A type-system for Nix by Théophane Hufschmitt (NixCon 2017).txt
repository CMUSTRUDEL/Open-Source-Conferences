Title: A type-system for Nix by Théophane Hufschmitt (NixCon 2017)
Publication date: 2017-10-31
Playlist: NixCon 2017 (Munich)
Description: 
	We present here the new tix tool, a type-checker for the Nix language whose goal is to make nix code easier to write and maintain.

Nix's strength comes from the ideas it borrows from functional programming: immutability, powerful abstraction capabilities, etc.., yet it misses one of the most emblematic and powerful feature of most functional programming languages: a strong static type-system, which becomes a problem given the increasing size of the Nix package collection. This proposal (which is the result of an internship funded by the Nix community and tweag I/O and supervised by Guiseppe Castagna) tries to fix this.

The resulting type-system and typechecker have been designed with two very important constraints in mind:

    The type-system must be able to offer as much safety as possible for the programmer.

    One must be able to reuse existing nix code with as few modifications as possible. This means that:
        Most of Nix idioms have to be supported by the type-system − in particular the presence of types at runtime and the dynamic fields in the records,
        There must be ways to bypass − up to some extent − the type-system, using e.g. gradual typing or by locally disabling certain errors.

In this talk, we will present the tool from the practical point of view of the nix user and discuss further improvements

Blog: https://typing-nix.regnat.ovh
Sources of the implementation: https://github.com/regnat/tix
Work notes: https://github.com/regnat/tix-paper

Slides: https://schedule.nixcon2017.org/system/event_attachments/attachments/000/000/003/original/main.pdf?1509274727
Captions: 
	00:00:00,030 --> 00:00:14,150
all right guys last talk for today this

00:00:09,179 --> 00:00:17,910
one is by French wits who contacted me

00:00:14,150 --> 00:00:20,010
just nine months ago versus me that and

00:00:17,910 --> 00:00:21,930
he wanted to do an internship at the

00:00:20,010 --> 00:00:25,859
Untied because he wants to work on next

00:00:21,930 --> 00:00:28,320
and then we organized a fundraiser or

00:00:25,859 --> 00:00:31,470
really surprised by the generosity of

00:00:28,320 --> 00:00:33,090
the community and now he's gonna talk to

00:00:31,470 --> 00:00:40,760
you about what he really wanted to do

00:00:33,090 --> 00:00:40,760
which is type in Nick's okay thank you

00:00:43,160 --> 00:00:49,289
so this is indeed the result of the

00:00:46,469 --> 00:00:53,489
internship I did with the help of Jonas

00:00:49,289 --> 00:00:56,850
and IO so the goal of this internship

00:00:53,489 --> 00:00:59,460
was to design a type system phonics so

00:00:56,850 --> 00:01:02,609
the first obvious question is why do we

00:00:59,460 --> 00:01:03,210
want to do that so there are two reasons

00:01:02,609 --> 00:01:07,170
for that

00:01:03,210 --> 00:01:10,070
the first one is that well before being

00:01:07,170 --> 00:01:14,700
that awesome - that everyone here uses

00:01:10,070 --> 00:01:16,680
Nick's was a nice experiment well the

00:01:14,700 --> 00:01:19,259
idea was where there are really cool

00:01:16,680 --> 00:01:21,540
stuff in programming languages what if

00:01:19,259 --> 00:01:24,990
we use it somewhere else like package

00:01:21,540 --> 00:01:27,750
management and so Nick's imported stuff

00:01:24,990 --> 00:01:31,229
like functional programming notability

00:01:27,750 --> 00:01:33,000
and so on and it worked very well but

00:01:31,229 --> 00:01:34,950
there's something that Nick didn't

00:01:33,000 --> 00:01:39,000
brought in which is quite pervasive in

00:01:34,950 --> 00:01:41,549
programming which is static typing so it

00:01:39,000 --> 00:01:44,220
should be a natural extension to try to

00:01:41,549 --> 00:01:46,950
add typing to this and see where it

00:01:44,220 --> 00:01:49,799
leads and there's also an or pragmatic

00:01:46,950 --> 00:01:52,680
reason which is that when you expect

00:01:49,799 --> 00:01:54,770
edgy stuff to be quite yeah so I'm

00:01:52,680 --> 00:01:58,020
usually around 1 million lines of code

00:01:54,770 --> 00:02:01,200
and when you have a cut bait that big

00:01:58,020 --> 00:02:03,930
you got Arab and they can be rather hard

00:02:01,200 --> 00:02:05,149
to spot and that's where typing can help

00:02:03,930 --> 00:02:10,410
a lot

00:02:05,149 --> 00:02:13,500
and so if typing is so useful the second

00:02:10,410 --> 00:02:13,860
question is why didn't anybody design a

00:02:13,500 --> 00:02:17,760
type

00:02:13,860 --> 00:02:21,030
distemper onyx the reason the main

00:02:17,760 --> 00:02:23,850
reason I think is that it's not totally

00:02:21,030 --> 00:02:28,440
obvious to do if you look for example as

00:02:23,850 --> 00:02:30,870
dysfunction so it's totally valid NYX

00:02:28,440 --> 00:02:33,690
card you take a function we take an

00:02:30,870 --> 00:02:35,760
argument you look at the first elements

00:02:33,690 --> 00:02:38,010
of the arguments which probably is

00:02:35,760 --> 00:02:40,530
supposed to be a list if the first one

00:02:38,010 --> 00:02:42,030
is a string you try to access to the

00:02:40,530 --> 00:02:45,000
field of the second one which is the

00:02:42,030 --> 00:02:46,140
value of this string otherwise you do

00:02:45,000 --> 00:02:48,510
the sum of birds

00:02:46,140 --> 00:02:51,630
well that's my pep example I hope

00:02:48,510 --> 00:02:54,840
nobody's writing things like that but

00:02:51,630 --> 00:02:57,090
you can do that in Nicks and if you try

00:02:54,840 --> 00:03:03,120
to write a type of this function even

00:02:57,090 --> 00:03:06,360
thy hand use stop becoming mad and now

00:03:03,120 --> 00:03:10,260
that well so that's not totally trivial

00:03:06,360 --> 00:03:11,130
to do and the second reason it hasn't

00:03:10,260 --> 00:03:13,620
been done yet

00:03:11,130 --> 00:03:16,760
well I quickly mention it Nick's

00:03:13,620 --> 00:03:19,500
packages are being quite big so I

00:03:16,760 --> 00:03:24,360
measured this last week you got 1

00:03:19,500 --> 00:03:26,760
million lines of code probably 90 90

00:03:24,360 --> 00:03:32,190
percent of it on Nick's actual Nick's

00:03:26,760 --> 00:03:34,920
code and so probably not up it is going

00:03:32,190 --> 00:03:36,860
to type-check at once probably almost

00:03:34,920 --> 00:03:40,290
nothing at it it's going to type check

00:03:36,860 --> 00:03:41,730
so that means that the type system or

00:03:40,290 --> 00:03:44,549
the type checker must be really flexible

00:03:41,730 --> 00:03:48,090
if you want to be able to run it unmix

00:03:44,549 --> 00:03:53,790
packages without it to crash at the

00:03:48,090 --> 00:03:57,239
first line of credit rates so we try to

00:03:53,790 --> 00:03:59,610
do it the requirement for this where the

00:03:57,239 --> 00:04:01,980
first one requirement is that we didn't

00:03:59,610 --> 00:04:03,750
want to write a new language which was

00:04:01,980 --> 00:04:06,810
well tight and which could compile to

00:04:03,750 --> 00:04:08,970
Nick's code I mean that's a valid ID but

00:04:06,810 --> 00:04:12,900
if you do that you can't use it and

00:04:08,970 --> 00:04:15,000
actually Nick's card and you that's kind

00:04:12,900 --> 00:04:16,590
of sad because well you don't want to

00:04:15,000 --> 00:04:21,540
rewrite Nick's packages in a new

00:04:16,590 --> 00:04:23,910
language no and as a consequence of it

00:04:21,540 --> 00:04:26,520
we didn't want to extend Nick's and tax

00:04:23,910 --> 00:04:27,860
in particular we if we want if we add

00:04:26,520 --> 00:04:32,199
Nick's annotation it

00:04:27,860 --> 00:04:34,699
valid Knicks guard and the two last

00:04:32,199 --> 00:04:36,919
requirements are first well obviously

00:04:34,699 --> 00:04:41,479
that we want to type as much code as

00:04:36,919 --> 00:04:43,330
possible while still being safe and the

00:04:41,479 --> 00:04:47,150
other one which is kind of weird is that

00:04:43,330 --> 00:04:49,129
even the cut that's not well type must

00:04:47,150 --> 00:04:51,770
still be acts somehow accepted by the

00:04:49,129 --> 00:04:55,280
type checker cause well as I said you

00:04:51,770 --> 00:04:57,199
probably won't get the whole of expect

00:04:55,280 --> 00:04:59,900
edges to type check whatever you type

00:04:57,199 --> 00:05:01,610
system is or maybe you can if your type

00:04:59,900 --> 00:05:04,580
system is just okay everybody type

00:05:01,610 --> 00:05:06,940
checked but that's not really useful but

00:05:04,580 --> 00:05:10,069
anyway we want to be able to say that

00:05:06,940 --> 00:05:12,680
ill typed code must be accepted by the

00:05:10,069 --> 00:05:16,159
type checker so that were our

00:05:12,680 --> 00:05:20,840
requirements and hopefully what we came

00:05:16,159 --> 00:05:22,340
up with nor let satisfy this so to

00:05:20,840 --> 00:05:25,310
satisfy the special issues showed

00:05:22,340 --> 00:05:29,120
requirements we need quite powerful type

00:05:25,310 --> 00:05:31,490
system so this is another annex function

00:05:29,120 --> 00:05:33,979
more reasonable that the first one I

00:05:31,490 --> 00:05:36,379
showed whether does it do it takes two

00:05:33,979 --> 00:05:38,599
arguments if the first one is an integer

00:05:36,379 --> 00:05:42,889
remake the Sun of birth otherwise it

00:05:38,599 --> 00:05:46,039
makes the boolean and so if you wanted

00:05:42,889 --> 00:05:50,089
IB Sri gonna be equal chuckles well it's

00:05:46,039 --> 00:05:52,610
like it has types intro intro in yeah

00:05:50,089 --> 00:05:56,659
but it's also as type Borobudur reboot

00:05:52,610 --> 00:06:00,310
and you can't really unify the books I

00:05:56,659 --> 00:06:03,050
mean how do we express the type of this

00:06:00,310 --> 00:06:06,949
well we can ask for help

00:06:03,050 --> 00:06:10,669
- back mathematic theory which is set

00:06:06,949 --> 00:06:12,650
theory if we look at set theory things

00:06:10,669 --> 00:06:15,319
are actually quite easy you want

00:06:12,650 --> 00:06:19,069
something to pick an element which is in

00:06:15,319 --> 00:06:21,169
the set a and in the set B where life is

00:06:19,069 --> 00:06:25,750
simple you just take an element which is

00:06:21,169 --> 00:06:29,599
in the intersection of both sorry

00:06:25,750 --> 00:06:32,900
actually well we can do almost the same

00:06:29,599 --> 00:06:34,849
thing with types while just we type the

00:06:32,900 --> 00:06:36,740
resist we like to give new names for

00:06:34,849 --> 00:06:38,779
other things so we can rename the

00:06:36,740 --> 00:06:40,430
symbols instead of Union intersection

00:06:38,779 --> 00:06:43,430
we're going to type the bull

00:06:40,430 --> 00:06:45,590
and and for instead of set containment

00:06:43,430 --> 00:06:48,650
we're going to take subtyping relation

00:06:45,590 --> 00:06:53,360
but essentially this is the same thing

00:06:48,650 --> 00:06:54,320
so and you doing said Tori we get for

00:06:53,360 --> 00:06:57,320
free

00:06:54,320 --> 00:06:59,780
singleton types so types with only one

00:06:57,320 --> 00:07:03,110
element for example a singleton type one

00:06:59,780 --> 00:07:07,160
which has only the constant one as an

00:07:03,110 --> 00:07:11,750
element and others which are going to be

00:07:07,160 --> 00:07:15,860
quite handful and with this notion of

00:07:11,750 --> 00:07:17,960
types we can type our F function it will

00:07:15,860 --> 00:07:21,680
simply have the intersection of both

00:07:17,960 --> 00:07:24,050
type we want index to express so we're

00:07:21,680 --> 00:07:29,420
happy we can type a lot of stuff with

00:07:24,050 --> 00:07:32,510
that but that's not going to be enough

00:07:29,420 --> 00:07:35,990
because still something that we can't

00:07:32,510 --> 00:07:37,910
type I mean every single day of that

00:07:35,990 --> 00:07:40,490
shape that would be simple but that's

00:07:37,910 --> 00:07:43,250
not the case so we had another element

00:07:40,490 --> 00:07:48,500
to our type system which is a gradual

00:07:43,250 --> 00:07:50,360
typing so gradual typing is a way to to

00:07:48,500 --> 00:07:53,960
express the fact that you can type

00:07:50,360 --> 00:07:56,330
something so you add a new type which is

00:07:53,960 --> 00:07:59,240
generally a question mark which

00:07:56,330 --> 00:08:02,180
represents you the type that you don't

00:07:59,240 --> 00:08:04,520
know and we can which can be used to

00:08:02,180 --> 00:08:08,750
type expression that you're not supposed

00:08:04,520 --> 00:08:11,510
to type so in this example the value of

00:08:08,750 --> 00:08:13,910
x can be any string because it's the

00:08:11,510 --> 00:08:16,940
value of the environment variable X so

00:08:13,910 --> 00:08:21,410
when we try to access to the field X of

00:08:16,940 --> 00:08:24,440
this record well it's supposed to be to

00:08:21,410 --> 00:08:27,650
fail or except in the very special case

00:08:24,440 --> 00:08:30,500
where X is equal to Y so this is not

00:08:27,650 --> 00:08:32,930
supposed to type check but if we want

00:08:30,500 --> 00:08:36,170
this to type check because it's already

00:08:32,930 --> 00:08:38,810
there and we don't want to change it we

00:08:36,170 --> 00:08:41,990
can say the tie to the type checker okay

00:08:38,810 --> 00:08:43,910
X will have type question mark and so

00:08:41,990 --> 00:08:45,980
don't bother what it is whenever you

00:08:43,910 --> 00:08:52,640
have two musics just assume that it has

00:08:45,980 --> 00:08:54,130
the right type and it works so we're

00:08:52,640 --> 00:08:57,400
happy we have a very

00:08:54,130 --> 00:09:00,190
expressive definition for all types

00:08:57,400 --> 00:09:02,320
which can be used to represent more or

00:09:00,190 --> 00:09:04,870
less everything in expect edges because

00:09:02,320 --> 00:09:07,120
when we can't express the type we want

00:09:04,870 --> 00:09:10,690
we just say it's gradual and we don't

00:09:07,120 --> 00:09:14,860
care but of course the problem with it

00:09:10,690 --> 00:09:17,920
is that well we can't always infer the

00:09:14,860 --> 00:09:21,220
types before example we try to run out

00:09:17,920 --> 00:09:23,800
type checker on the first example well

00:09:21,220 --> 00:09:26,110
obviously you want it one sir oh it's

00:09:23,800 --> 00:09:29,230
easy it's a function from integers to

00:09:26,110 --> 00:09:31,090
integers but actually it J which will

00:09:29,230 --> 00:09:33,340
just say no it's a function that takes

00:09:31,090 --> 00:09:35,830
something I don't know what but which

00:09:33,340 --> 00:09:38,470
returns an integer if you take the

00:09:35,830 --> 00:09:40,740
second one it will also say that it

00:09:38,470 --> 00:09:43,240
accepts something but don't know why I

00:09:40,740 --> 00:09:45,880
don't know what and it will return

00:09:43,240 --> 00:09:51,060
either an int is zero but that's the

00:09:45,880 --> 00:09:53,260
cool part at least that's precise so

00:09:51,060 --> 00:09:55,990
basically what the type checker does

00:09:53,260 --> 00:09:58,750
when he sees that he says okay yeah it's

00:09:55,990 --> 00:10:00,520
a function it takes an argument that I

00:09:58,750 --> 00:10:03,030
don't know anything about this argument

00:10:00,520 --> 00:10:05,710
so I'm going to assume it's gradual and

00:10:03,030 --> 00:10:10,510
then we try to type check the body of

00:10:05,710 --> 00:10:13,300
the function and in fairy-type for it so

00:10:10,510 --> 00:10:18,280
we need to help him and we can't help

00:10:13,300 --> 00:10:20,470
him we can annotate the types so this is

00:10:18,280 --> 00:10:23,230
the syntax for type annotation is just

00:10:20,470 --> 00:10:26,470
wrapped in two comments so that nick's

00:10:23,230 --> 00:10:28,720
doesn't doesn't see them and can

00:10:26,470 --> 00:10:32,590
continue to evaluate the file and here

00:10:28,720 --> 00:10:34,330
we say okay X is of type int and the

00:10:32,590 --> 00:10:36,820
type checker type check the function as

00:10:34,330 --> 00:10:39,550
it should we can do the same with the

00:10:36,820 --> 00:10:41,710
second function and it says its function

00:10:39,550 --> 00:10:45,070
that takes an integer or horribly and

00:10:41,710 --> 00:10:46,930
and returns an integer or a boolean but

00:10:45,070 --> 00:10:51,250
in fact that's not what we want if there

00:10:46,930 --> 00:10:53,980
occurs this function where this types

00:10:51,250 --> 00:10:56,980
mean is that if this function takes an

00:10:53,980 --> 00:10:59,830
integer it will return either an integer

00:10:56,980 --> 00:11:02,560
either a boolean which is true but not

00:10:59,830 --> 00:11:04,750
really useful in reality if this

00:11:02,560 --> 00:11:07,060
function takes an integer it will return

00:11:04,750 --> 00:11:07,590
an integer and it takes a boolean it

00:11:07,060 --> 00:11:10,440
will read

00:11:07,590 --> 00:11:13,500
boolean so that's not the most precise

00:11:10,440 --> 00:11:15,450
type we we are going to give to this

00:11:13,500 --> 00:11:17,790
function and we don't want to have ten

00:11:15,450 --> 00:11:21,570
precise types cause otherwise the type

00:11:17,790 --> 00:11:25,770
system is just useless so we need to

00:11:21,570 --> 00:11:29,070
help him further and to do that there's

00:11:25,770 --> 00:11:31,470
a wonderful technique called be

00:11:29,070 --> 00:11:33,570
directional typing which can give

00:11:31,470 --> 00:11:37,770
helpers giving a more precise type to

00:11:33,570 --> 00:11:39,930
this function to explain what it is I'll

00:11:37,770 --> 00:11:42,800
just quickly explain how most

00:11:39,930 --> 00:11:46,350
traditional type checking algorithm raj

00:11:42,800 --> 00:11:49,200
so let's assume you get an expression

00:11:46,350 --> 00:11:52,620
this is a syntactic tree for an

00:11:49,200 --> 00:11:55,500
expression so it's a function which

00:11:52,620 --> 00:11:57,630
takes two arguments x and y and return

00:11:55,500 --> 00:12:02,520
the express while of the plus function

00:11:57,630 --> 00:12:05,460
applied to x and y traditional type

00:12:02,520 --> 00:12:08,760
checking algorithms will type check this

00:12:05,460 --> 00:12:11,580
bottom-up so first trying to infer the

00:12:08,760 --> 00:12:13,860
type of the leaves and then go up in the

00:12:11,580 --> 00:12:17,490
trees until you have the type of the

00:12:13,860 --> 00:12:19,410
whole expression so for example the

00:12:17,490 --> 00:12:22,470
algorithm first we'll check the type of

00:12:19,410 --> 00:12:24,360
plus he will say okay I know plus it's a

00:12:22,470 --> 00:12:28,260
function it's in my environment that ice

00:12:24,360 --> 00:12:31,410
type int arrow int int then we child it

00:12:28,260 --> 00:12:33,360
will check X it will check okay X it

00:12:31,410 --> 00:12:34,800
hasn't I know it's in line and viral

00:12:33,360 --> 00:12:37,770
none because it has been defined before

00:12:34,800 --> 00:12:43,260
I don't know it's typed yet let's call

00:12:37,770 --> 00:12:47,010
it TX and then he'll go one step above

00:12:43,260 --> 00:12:49,950
and you will say okay we can have this

00:12:47,010 --> 00:12:53,820
type check if we say that TX is equal to

00:12:49,950 --> 00:12:56,940
int in which case we can apply plus 2x

00:12:53,820 --> 00:12:59,700
and the result will add int or interval

00:12:56,940 --> 00:13:03,000
in so it will give us the type int arrow

00:12:59,700 --> 00:13:06,840
int and it will add somewhere is a

00:13:03,000 --> 00:13:09,900
constraint that G is equal to a then he

00:13:06,840 --> 00:13:13,350
will do the same with out with white

00:13:09,900 --> 00:13:16,260
saying oh it has typed gy then it will

00:13:13,350 --> 00:13:19,440
do the application saying okay attach X

00:13:16,260 --> 00:13:20,670
is G 1 is equal to int and the result as

00:13:19,440 --> 00:13:24,300
type int

00:13:20,670 --> 00:13:26,550
that's good then one step above okay

00:13:24,300 --> 00:13:28,980
this is the function so it will up tight

00:13:26,550 --> 00:13:31,620
pinch or in because if y is an int it

00:13:28,980 --> 00:13:34,290
will return an int and still one step

00:13:31,620 --> 00:13:37,470
above if it's going to be a function of

00:13:34,290 --> 00:13:40,770
type int int the routine okay that's

00:13:37,470 --> 00:13:44,250
cool so now let's look at the function

00:13:40,770 --> 00:13:47,970
we had before so this is its expression

00:13:44,250 --> 00:13:49,500
tree it's a function which actually it's

00:13:47,970 --> 00:13:51,690
not the function we had before it's a

00:13:49,500 --> 00:13:55,800
simpler one so it's a function which

00:13:51,690 --> 00:13:58,140
takes an argument speaks if X isn't

00:13:55,800 --> 00:14:01,290
well if isn't examine it will return

00:13:58,140 --> 00:14:04,710
minus minus X tells it will return not

00:14:01,290 --> 00:14:07,200
fix and if we try to type check this

00:14:04,710 --> 00:14:09,090
using the same method we're going to

00:14:07,200 --> 00:14:12,210
have a problem because the algorithm

00:14:09,090 --> 00:14:15,150
will say okay I got many supplied to X

00:14:12,210 --> 00:14:18,390
so X is an integer okay I got not

00:14:15,150 --> 00:14:20,160
applied to X so X is a boolean so X is

00:14:18,390 --> 00:14:24,900
at the same time a boolean and an

00:14:20,160 --> 00:14:27,420
integer no that doesn't work but let's

00:14:24,900 --> 00:14:29,040
assume that the type checker already

00:14:27,420 --> 00:14:32,220
knows the type of this expression

00:14:29,040 --> 00:14:35,160
because for example the programmer give

00:14:32,220 --> 00:14:37,020
him a type annotation he will say ok I

00:14:35,160 --> 00:14:39,240
know that this is supposed to have type

00:14:37,020 --> 00:14:43,920
int arrow int intersection blue arrow

00:14:39,240 --> 00:14:46,680
bool how can I check that well to do

00:14:43,920 --> 00:14:49,410
that first we get an intersection of

00:14:46,680 --> 00:14:52,460
arrows that mean that we're in Brussels

00:14:49,410 --> 00:14:56,370
in both rows so let's try the first one

00:14:52,460 --> 00:14:59,220
this is a function so that means that if

00:14:56,370 --> 00:15:02,820
X has type int then the body has type

00:14:59,220 --> 00:15:06,180
int okay how do I check that this has

00:15:02,820 --> 00:15:09,060
the right type this is an evening else

00:15:06,180 --> 00:15:13,560
so I'll try to infer the type of the

00:15:09,060 --> 00:15:16,410
condition what it's the type of this so

00:15:13,560 --> 00:15:19,500
well we just do like we did before our

00:15:16,410 --> 00:15:21,480
classic inference we know the type of

00:15:19,500 --> 00:15:24,390
the easy int function it's a function

00:15:21,480 --> 00:15:27,120
that returns the singleton type true if

00:15:24,390 --> 00:15:29,970
it's argument is of type int and which

00:15:27,120 --> 00:15:32,100
returns a singleton type false if it's

00:15:29,970 --> 00:15:33,190
argument is of type not it's a little

00:15:32,100 --> 00:15:36,610
stuff like

00:15:33,190 --> 00:15:38,920
is boolean negation we also know the

00:15:36,610 --> 00:15:41,260
type of things because we decided that

00:15:38,920 --> 00:15:44,890
it will be an int so we know the type of

00:15:41,260 --> 00:15:49,120
this its subtype true the single turn

00:15:44,890 --> 00:15:50,650
type true okay we can continue we're

00:15:49,120 --> 00:15:53,890
going to check that

00:15:50,650 --> 00:15:56,740
Magnus sticks as type int well that's

00:15:53,890 --> 00:15:59,530
trivial we know that X has type int - X

00:15:56,740 --> 00:16:01,420
has type int and now we're going to

00:15:59,530 --> 00:16:03,250
check that no if you're not going to

00:16:01,420 --> 00:16:06,790
check that not success type in because

00:16:03,250 --> 00:16:08,620
we know that this the condition is

00:16:06,790 --> 00:16:10,900
always going to be true so we don't have

00:16:08,620 --> 00:16:14,140
a check for the second branch because

00:16:10,900 --> 00:16:16,180
it's never going to be reached so we are

00:16:14,140 --> 00:16:19,930
done we've checked that this function

00:16:16,180 --> 00:16:22,570
has the right type now we do it the same

00:16:19,930 --> 00:16:24,700
with the second with the second type in

00:16:22,570 --> 00:16:26,440
the intersection we support that this is

00:16:24,700 --> 00:16:28,930
a blah blah blah blah it's exactly the

00:16:26,440 --> 00:16:33,550
same thing and at the end we're happy

00:16:28,930 --> 00:16:36,310
with type check this function and we can

00:16:33,550 --> 00:16:38,470
indeed run it and an example and the

00:16:36,310 --> 00:16:41,460
type checker will be happy and say yeah

00:16:38,470 --> 00:16:45,000
it's interest intersection bull our bull

00:16:41,460 --> 00:16:47,920
so we are really happy we now got

00:16:45,000 --> 00:16:50,410
powerful system which care whose types

00:16:47,920 --> 00:16:54,030
can express a lot of things and which

00:16:50,410 --> 00:16:59,170
can in fair of check a lot of things too

00:16:54,030 --> 00:17:02,770
in fact the be directional typing can

00:16:59,170 --> 00:17:05,800
give us even more because if you look at

00:17:02,770 --> 00:17:08,530
this expression though so what do you

00:17:05,800 --> 00:17:11,620
have here we got a function that takes

00:17:08,530 --> 00:17:14,439
an argument X of type int and that

00:17:11,620 --> 00:17:17,949
returns the identity function applied to

00:17:14,439 --> 00:17:20,500
X now if we try to annotate it saying

00:17:17,949 --> 00:17:22,510
that the argument is supposed to be of

00:17:20,500 --> 00:17:25,120
type int and the return is supposed to

00:17:22,510 --> 00:17:27,250
be of type bool well you would expect

00:17:25,120 --> 00:17:28,720
the type checker to complain that it's

00:17:27,250 --> 00:17:30,910
false because when you apply the

00:17:28,720 --> 00:17:34,180
identity function to an inch you want to

00:17:30,910 --> 00:17:38,400
get an integer result but in fact it's

00:17:34,180 --> 00:17:42,640
gonna pass the relevant produce is that

00:17:38,400 --> 00:17:45,220
the y : y function which is the identity

00:17:42,640 --> 00:17:46,960
function will be tight as question mark

00:17:45,220 --> 00:17:49,629
over question mark called

00:17:46,960 --> 00:17:52,960
well it's not annotated the type checker

00:17:49,629 --> 00:17:57,039
can guess its type so by default it's

00:17:52,960 --> 00:17:59,440
going to type it a jewelry so X is an

00:17:57,039 --> 00:18:02,100
inch it can be passed as an argument for

00:17:59,440 --> 00:18:04,749
to a function which expects anything and

00:18:02,100 --> 00:18:08,499
the result of this application is going

00:18:04,749 --> 00:18:10,779
to be of type gradual and gradual can be

00:18:08,499 --> 00:18:16,269
passed where you expect a bull so it's

00:18:10,779 --> 00:18:19,210
fine now if we rewrite this you're doing

00:18:16,269 --> 00:18:20,860
the directional typing so we give the

00:18:19,210 --> 00:18:25,749
type of the function to the type checker

00:18:20,860 --> 00:18:28,450
then it's going to fail because the type

00:18:25,749 --> 00:18:30,909
checker so we will do at the beginning

00:18:28,450 --> 00:18:34,539
the same thing assume that X is an int

00:18:30,909 --> 00:18:37,539
trying to give a type to the body but

00:18:34,539 --> 00:18:39,639
inside of inferring it is going to try

00:18:37,539 --> 00:18:43,330
to check that the body has type bool and

00:18:39,639 --> 00:18:45,429
to do that well he knows that X has type

00:18:43,330 --> 00:18:48,220
int so is going to check that the

00:18:45,429 --> 00:18:51,490
identity function has type int arrow

00:18:48,220 --> 00:18:55,990
bool which means checking that if Y is

00:18:51,490 --> 00:18:59,100
an int then Y is a bull and well but

00:18:55,990 --> 00:19:02,080
he's able to get that it's wrong so

00:18:59,100 --> 00:19:05,919
thanks to this bidirectional typing

00:19:02,080 --> 00:19:09,090
stuff we get more precision and well

00:19:05,919 --> 00:19:15,549
that may not seem like a big deal but

00:19:09,090 --> 00:19:18,210
the really nice thing is that if your

00:19:15,549 --> 00:19:20,889
types if you do not annotate your code

00:19:18,210 --> 00:19:23,740
well the type checker will be very

00:19:20,889 --> 00:19:25,629
relaxed and he will say okay this is not

00:19:23,740 --> 00:19:29,320
annotated let's let's say that

00:19:25,629 --> 00:19:31,090
everything is gradually typed and more

00:19:29,320 --> 00:19:33,879
or less every cut you could imagine

00:19:31,090 --> 00:19:37,029
writings going to pass but if you

00:19:33,879 --> 00:19:38,740
somewhere put an annotation then the

00:19:37,029 --> 00:19:41,379
type checker will have some some type

00:19:38,740 --> 00:19:44,679
information that we we have that he will

00:19:41,379 --> 00:19:47,769
be able to propagate down in the in the

00:19:44,679 --> 00:19:49,899
expressions and if you have an actual

00:19:47,769 --> 00:19:52,779
type here or there it will be have

00:19:49,899 --> 00:19:55,389
enough information to catch it so that

00:19:52,779 --> 00:19:57,909
makes a natural way of separating code

00:19:55,389 --> 00:20:00,130
that you want to type from cut that you

00:19:57,909 --> 00:20:04,080
don't want to type and

00:20:00,130 --> 00:20:08,590
it's probably very practical in practice

00:20:04,080 --> 00:20:11,320
so hopefully we satisfied our

00:20:08,590 --> 00:20:15,070
requirements for simplified mixed

00:20:11,320 --> 00:20:18,970
language now anacs has mastered in

00:20:15,070 --> 00:20:22,150
particular or lists and arrays so we'll

00:20:18,970 --> 00:20:25,710
have to type these two for lists well

00:20:22,150 --> 00:20:28,419
the problem with Nik style lists is that

00:20:25,710 --> 00:20:33,250
they can have elements of different

00:20:28,419 --> 00:20:35,559
types in it which is which can be useful

00:20:33,250 --> 00:20:41,650
in practice that's why it is that which

00:20:35,559 --> 00:20:45,039
not that easy to type well in fact when

00:20:41,650 --> 00:20:48,070
you want to represent to describe some

00:20:45,039 --> 00:20:51,159
checks of text there's a powerful tool

00:20:48,070 --> 00:20:52,150
which is regular expressions well

00:20:51,159 --> 00:20:54,690
Nicholas

00:20:52,150 --> 00:20:57,970
our regular expressions can be wonderful

00:20:54,690 --> 00:21:01,179
and in fact you can have the same with

00:20:57,970 --> 00:21:03,580
types so you can type a list using your

00:21:01,179 --> 00:21:06,010
regular expressions that represents its

00:21:03,580 --> 00:21:09,419
element so for example the first list

00:21:06,010 --> 00:21:12,520
here when to true can have the type

00:21:09,419 --> 00:21:15,909
instance or any sequence of int followed

00:21:12,520 --> 00:21:19,929
by the singleton type true followed by

00:21:15,909 --> 00:21:23,380
the optional the shop here is what's

00:21:19,929 --> 00:21:25,059
usually a question mark in reg X is that

00:21:23,380 --> 00:21:27,700
question mark is already taken by the

00:21:25,059 --> 00:21:31,510
gradual type so followed by the optional

00:21:27,700 --> 00:21:34,169
bar string so this first list will have

00:21:31,510 --> 00:21:37,000
this type the second list is another

00:21:34,169 --> 00:21:39,820
element of this type also it's quite

00:21:37,000 --> 00:21:42,460
different indeed it has a sequence of

00:21:39,820 --> 00:21:45,400
entering this case 0 ins followed by

00:21:42,460 --> 00:21:49,090
true followed by the optional bar which

00:21:45,400 --> 00:21:52,330
is in this case present this general

00:21:49,090 --> 00:21:54,010
from probably not useful or not often

00:21:52,330 --> 00:21:56,530
useful because you don't want to write

00:21:54,010 --> 00:21:58,539
to have a function that accept any Lisa

00:21:56,530 --> 00:22:00,549
has this shape I don't know what you

00:21:58,539 --> 00:22:03,870
well maybe you have I did what you would

00:22:00,549 --> 00:22:06,730
want to do with this but I don't but

00:22:03,870 --> 00:22:11,770
there are so cool stuff is that first

00:22:06,730 --> 00:22:13,570
you can express the regular monomorphic

00:22:11,770 --> 00:22:15,220
list using this

00:22:13,570 --> 00:22:18,070
the list of whose elements will be

00:22:15,220 --> 00:22:22,690
applied a with just be a list of type a

00:22:18,070 --> 00:22:25,779
star and or two NYX has no tepals you

00:22:22,690 --> 00:22:29,080
can express step assuming this for

00:22:25,779 --> 00:22:31,929
example the list of type int bull the

00:22:29,080 --> 00:22:34,149
type list in bull will be the type of or

00:22:31,929 --> 00:22:36,009
list with two elements the first being

00:22:34,149 --> 00:22:39,639
an intent the second a bull

00:22:36,009 --> 00:22:42,580
so this is almost the same as the table

00:22:39,639 --> 00:22:47,940
int will which can be handy if you want

00:22:42,580 --> 00:22:52,149
to use step L and have them well typed

00:22:47,940 --> 00:22:56,139
okay so a lists raw fairly well no let's

00:22:52,149 --> 00:22:58,979
look at attribute set and there are

00:22:56,139 --> 00:23:03,460
several ways attribute sets are used in

00:22:58,979 --> 00:23:06,249
undies to that I know of the first one

00:23:03,460 --> 00:23:08,950
is what I call static attribute set so

00:23:06,249 --> 00:23:11,499
that when you know everything about your

00:23:08,950 --> 00:23:13,809
library so in this case for example you

00:23:11,499 --> 00:23:17,409
know that this attribute set will have

00:23:13,809 --> 00:23:20,499
three fields x y&z we know the names we

00:23:17,409 --> 00:23:25,059
know everything so this has a trivial

00:23:20,499 --> 00:23:28,200
type which is itself but as a type so

00:23:25,059 --> 00:23:31,269
that's really easy to do you'll be happy

00:23:28,200 --> 00:23:35,109
no we can be a little bit more fancy

00:23:31,269 --> 00:23:37,779
let's look at this function so it takes

00:23:35,109 --> 00:23:40,960
an argument and attribute set which must

00:23:37,779 --> 00:23:45,700
have an element X may have an element Y

00:23:40,960 --> 00:23:49,779
may have anything else well we also can

00:23:45,700 --> 00:23:51,879
touch it how we would we type it well we

00:23:49,779 --> 00:23:55,090
will say that it's argument must be a

00:23:51,879 --> 00:23:59,169
record with the first element X which is

00:23:55,090 --> 00:24:03,009
an int the second element Y MIT which

00:23:59,169 --> 00:24:05,409
may be present or not such what Z equal

00:24:03,009 --> 00:24:08,080
question mark means and if it's present

00:24:05,409 --> 00:24:12,309
it must be an int and which may have

00:24:08,080 --> 00:24:16,029
anything else after that so we can

00:24:12,309 --> 00:24:19,359
express this kind of thing now in mixed

00:24:16,029 --> 00:24:22,049
we can do some much rarer stuff so for

00:24:19,359 --> 00:24:26,860
example let's look at this attribute set

00:24:22,049 --> 00:24:30,760
it has probably two fields but we don't

00:24:26,860 --> 00:24:32,649
when their labels are we we know that

00:24:30,760 --> 00:24:35,350
are going to be strings otherwise it

00:24:32,649 --> 00:24:38,260
will then be valid but we don't really

00:24:35,350 --> 00:24:40,990
know so all we can sell you that it's

00:24:38,260 --> 00:24:42,159
going to be a recall where if you try to

00:24:40,990 --> 00:24:45,029
access a field

00:24:42,159 --> 00:24:47,409
well maybe it's going to be absent or

00:24:45,029 --> 00:24:51,370
maybe it's going to be present in which

00:24:47,409 --> 00:24:53,110
case it will be either 1 or true so

00:24:51,370 --> 00:24:55,690
that's all you can say about this record

00:24:53,110 --> 00:25:00,880
and we're quite happy because we can

00:24:55,690 --> 00:25:03,279
express this in this type system so we

00:25:00,880 --> 00:25:06,370
can extend our type system to manage

00:25:03,279 --> 00:25:10,139
these data structures and we are really

00:25:06,370 --> 00:25:17,169
happy about this the problem is that

00:25:10,139 --> 00:25:20,260
well I showed you the example with X : X

00:25:17,169 --> 00:25:22,419
function which is in fact an inside cast

00:25:20,260 --> 00:25:24,820
you can cast any value to any type

00:25:22,419 --> 00:25:27,250
without any problem the type checker

00:25:24,820 --> 00:25:30,789
will say okay I okay no problem I close

00:25:27,250 --> 00:25:34,539
my eyes do it and well sometimes it's

00:25:30,789 --> 00:25:36,490
way cool it's practical when you cut the

00:25:34,539 --> 00:25:38,769
when you don't want to bother about the

00:25:36,490 --> 00:25:41,860
typing but most of the time you don't

00:25:38,769 --> 00:25:45,399
want that so you want to be able to tell

00:25:41,860 --> 00:25:47,950
the type checker ok you could just a

00:25:45,399 --> 00:25:52,690
little bit more strict so that this

00:25:47,950 --> 00:25:55,269
doesn't pass it will be very nice so for

00:25:52,690 --> 00:25:58,539
this we added a strict mode to the type

00:25:55,269 --> 00:26:00,490
checker so this is basically a simpler

00:25:58,539 --> 00:26:03,580
version of the example I showed it's

00:26:00,490 --> 00:26:05,559
going to type check now we can save to

00:26:03,580 --> 00:26:08,529
the type checker ok this is going to be

00:26:05,559 --> 00:26:10,809
type checking strict mode and in this

00:26:08,529 --> 00:26:12,639
case it's not going to pass the type

00:26:10,809 --> 00:26:14,980
checker is going to say ok a your the

00:26:12,639 --> 00:26:15,909
function x : x I don't know anything

00:26:14,980 --> 00:26:18,940
about it

00:26:15,909 --> 00:26:20,950
argument let's say it's of type any so

00:26:18,940 --> 00:26:23,260
any is the type I don't know anything

00:26:20,950 --> 00:26:25,750
about it so the result is going to be of

00:26:23,260 --> 00:26:28,389
type any that's any other type I don't

00:26:25,750 --> 00:26:31,090
know anything about so in particular I

00:26:28,389 --> 00:26:33,789
don't know if it's a bool or not so I'm

00:26:31,090 --> 00:26:35,830
just going to fail and we're happy

00:26:33,789 --> 00:26:39,070
because that's what we wanted and if you

00:26:35,830 --> 00:26:40,490
want and that means that if we want

00:26:39,070 --> 00:26:43,190
that's kind of thing

00:26:40,490 --> 00:26:44,840
to type-check well no not that not that

00:26:43,190 --> 00:26:46,910
kind of thing but if we want to be able

00:26:44,840 --> 00:26:49,790
to use function in an effective way

00:26:46,910 --> 00:26:52,910
we'll have to annotate them and we can

00:26:49,790 --> 00:26:57,290
just let unsafe checks passed without

00:26:52,910 --> 00:27:00,230
noticing another feature of the street

00:26:57,290 --> 00:27:02,330
mode is that well if you remember the

00:27:00,230 --> 00:27:04,429
examples that I showed you about the

00:27:02,330 --> 00:27:07,580
record of this one which is very much

00:27:04,429 --> 00:27:09,679
the same well this type checks which

00:27:07,580 --> 00:27:12,050
will say that it's a record which we

00:27:09,679 --> 00:27:15,679
don't know about the label and so on but

00:27:12,050 --> 00:27:19,160
if x and y in fact are the same thing

00:27:15,679 --> 00:27:20,720
well evaluate to the same values this is

00:27:19,160 --> 00:27:23,210
not going to be accepted by the

00:27:20,720 --> 00:27:25,640
evaluator he's going to say oh no I got

00:27:23,210 --> 00:27:27,500
a record with where the same field is

00:27:25,640 --> 00:27:31,010
defined twice this is not valid and so

00:27:27,500 --> 00:27:34,340
on so in strict mode we also want to

00:27:31,010 --> 00:27:37,460
disable this and in fact if the type

00:27:34,340 --> 00:27:40,460
checker is not able to infer that all

00:27:37,460 --> 00:27:42,320
the fields will be distinct his nut is

00:27:40,460 --> 00:27:46,700
just going to yell at you and output an

00:27:42,320 --> 00:27:48,860
arrow so like why that not something we

00:27:46,700 --> 00:27:51,679
want by default because you make an

00:27:48,860 --> 00:27:55,309
encounter base and sometimes you want to

00:27:51,679 --> 00:28:00,250
write this that if you in a play that

00:27:55,309 --> 00:28:04,059
you control you may want to avoid this

00:28:00,250 --> 00:28:06,710
now we can even go a little bit further

00:28:04,059 --> 00:28:09,320
so this is already the same example a

00:28:06,710 --> 00:28:12,620
really cool example actually I can use

00:28:09,320 --> 00:28:19,130
it everywhere it's really handy so these

00:28:12,620 --> 00:28:21,290
type checks now we can say to the type

00:28:19,130 --> 00:28:23,630
checker okay I want to disable the

00:28:21,290 --> 00:28:26,270
special effect of the gradual type here

00:28:23,630 --> 00:28:28,790
so it's going to raise an error because

00:28:26,270 --> 00:28:31,490
cast will still be of type question mark

00:28:28,790 --> 00:28:34,970
or a question mark but now when we get

00:28:31,490 --> 00:28:37,220
this no gradual annotation has a

00:28:34,970 --> 00:28:39,740
question mark is going to lose its

00:28:37,220 --> 00:28:42,350
special features and just become a

00:28:39,740 --> 00:28:45,830
regular type like int like boo like

00:28:42,350 --> 00:28:48,890
string and so in particular an int is

00:28:45,830 --> 00:28:50,419
not going to be a gradual type the

00:28:48,890 --> 00:28:53,750
gradual type is not going to be a

00:28:50,419 --> 00:28:57,770
boolean and so this is going to fail

00:28:53,750 --> 00:28:59,630
and of course as we want to use even if

00:28:57,770 --> 00:29:01,700
we disable the gradual type we still

00:28:59,630 --> 00:29:04,130
have to use functions from the outside

00:29:01,700 --> 00:29:08,780
world which sometimes are gradually

00:29:04,130 --> 00:29:11,810
typing we will had couple of functions

00:29:08,780 --> 00:29:14,180
which allow you to explicitly insert the

00:29:11,810 --> 00:29:16,820
implicit casts that were added by the

00:29:14,180 --> 00:29:18,470
gradual type so if you want to tile

00:29:16,820 --> 00:29:22,010
check this you still can

00:29:18,470 --> 00:29:25,250
well it's not I wouldn't advise you to

00:29:22,010 --> 00:29:27,290
do that but it's false but you can do it

00:29:25,250 --> 00:29:29,780
and you can use functions from the

00:29:27,290 --> 00:29:32,770
untied world that are coming to use

00:29:29,780 --> 00:29:37,910
separate ID module with no gradual type

00:29:32,770 --> 00:29:40,240
so the nice thing about it is that you

00:29:37,910 --> 00:29:43,850
can add a write right range of

00:29:40,240 --> 00:29:46,730
strictness going from the default mode

00:29:43,850 --> 00:29:49,160
where almost every card is going to type

00:29:46,730 --> 00:29:51,770
check then you can add some annotations

00:29:49,160 --> 00:29:54,470
to restrict the immune there is the

00:29:51,770 --> 00:29:56,930
amount of cards that type checks and you

00:29:54,470 --> 00:29:59,780
can add some strict or on the gradual

00:29:56,930 --> 00:30:03,260
annotations to get some really strict

00:29:59,780 --> 00:30:05,720
cards that well if it type checks you're

00:30:03,260 --> 00:30:10,100
quite confident that it's going to run

00:30:05,720 --> 00:30:14,350
without zeros so currently that's more

00:30:10,100 --> 00:30:16,250
or less all there's a and

00:30:14,350 --> 00:30:20,450
implementation that I wrote from my

00:30:16,250 --> 00:30:24,380
internship in a KML almost all the type

00:30:20,450 --> 00:30:27,650
system is implemented but well I wrote

00:30:24,380 --> 00:30:30,860
the processor very quickly it's probably

00:30:27,650 --> 00:30:33,770
really big not probably I know it's

00:30:30,860 --> 00:30:37,160
bagillion it works on example but that's

00:30:33,770 --> 00:30:40,520
all and I've started a new rewrite in

00:30:37,160 --> 00:30:42,530
Haskell to use a Shh sneaks to avoid

00:30:40,520 --> 00:30:44,660
having to write my own parser because

00:30:42,530 --> 00:30:50,180
that's not the kind of stuff that I

00:30:44,660 --> 00:30:53,630
enjoy and but now that my internship is

00:30:50,180 --> 00:30:56,360
over I don't have the possibility to

00:30:53,630 --> 00:30:58,850
work on this full-time anymore so I'm

00:30:56,360 --> 00:31:01,130
gonna need some help and that's where

00:30:58,850 --> 00:31:03,710
you could help by participating to the

00:31:01,130 --> 00:31:05,900
development of this and by testing it

00:31:03,710 --> 00:31:07,610
while it's going to be in as soon as

00:31:05,900 --> 00:31:09,380
it's in a state where we stay

00:31:07,610 --> 00:31:14,870
stable because the development is just

00:31:09,380 --> 00:31:16,970
at the beginning so you're all Romney

00:31:14,870 --> 00:31:19,040
welcome to come and help for the

00:31:16,970 --> 00:31:34,580
development of the implementation thank

00:31:19,040 --> 00:31:36,140
you well first of all I'd like to say

00:31:34,580 --> 00:31:39,140
awesome work

00:31:36,140 --> 00:31:42,770
I see some very complicated challenges

00:31:39,140 --> 00:31:44,210
in indeed in the next type system have

00:31:42,770 --> 00:31:46,669
you thought about the actual error

00:31:44,210 --> 00:31:49,190
messages themselves do you have examples

00:31:46,669 --> 00:31:52,010
or is that not written yet

00:31:49,190 --> 00:31:55,040
well there are error messages that they

00:31:52,010 --> 00:31:58,010
are not really interesting no no this is

00:31:55,040 --> 00:32:00,830
some part I have been really time to

00:31:58,010 --> 00:32:03,530
work on because I have to focus on the

00:32:00,830 --> 00:32:06,200
purely typing parts but that's a really

00:32:03,530 --> 00:32:07,940
important part I agree and yeah we also

00:32:06,200 --> 00:32:11,059
have a lot of fraud especially since the

00:32:07,940 --> 00:32:13,130
type system is somewhat complicated if

00:32:11,059 --> 00:32:15,070
we got badly wrong messages it's going

00:32:13,130 --> 00:32:18,280
to be young users

00:32:15,070 --> 00:32:18,280
great work

00:32:24,340 --> 00:32:35,650
I were when experiments of using new

00:32:32,830 --> 00:32:36,190
towel language with Knicks like heavy

00:32:35,650 --> 00:32:43,029
hurdles

00:32:36,190 --> 00:32:45,429
I think its language for configurations

00:32:43,029 --> 00:32:47,820
with dependent chimes by Gabriel

00:32:45,429 --> 00:32:50,470
Gonzalez yeah

00:32:47,820 --> 00:32:52,510
doll well it's it's an interesting

00:32:50,470 --> 00:32:54,610
experiment too but quite different

00:32:52,510 --> 00:32:57,760
because well one of my first

00:32:54,610 --> 00:32:59,799
requirements was explicitly not to write

00:32:57,760 --> 00:33:03,250
in your language that will compile

00:32:59,799 --> 00:33:06,010
tunics because well nobody would like to

00:33:03,250 --> 00:33:08,289
rewrite the whole mix packages in valve

00:33:06,010 --> 00:33:11,679
especially since is that possible for

00:33:08,289 --> 00:33:13,840
technical reason but that is also

00:33:11,679 --> 00:33:18,159
interesting if you want to write your

00:33:13,840 --> 00:33:28,929
own private stuff they just don't have

00:33:18,159 --> 00:33:32,710
the same application field I think so if

00:33:28,929 --> 00:33:34,899
I if I write next code so the primary

00:33:32,710 --> 00:33:38,470
thing that I'm actually missing in terms

00:33:34,899 --> 00:33:40,480
of type systems is to make differences

00:33:38,470 --> 00:33:42,640
between things that are otherwise come

00:33:40,480 --> 00:33:46,029
considered equal something like new type

00:33:42,640 --> 00:33:47,950
and Haskell so you took the gradual

00:33:46,029 --> 00:33:51,880
typing approach here do you do you have

00:33:47,950 --> 00:33:53,590
any vision on like how depth could ever

00:33:51,880 --> 00:33:57,730
be extended with something like user

00:33:53,590 --> 00:34:00,130
defined data types the problem with user

00:33:57,730 --> 00:34:02,890
defined data types on you type if that

00:34:00,130 --> 00:34:05,740
it's quite hard to do without extending

00:34:02,890 --> 00:34:09,369
the language itself so that's why I

00:34:05,740 --> 00:34:12,879
didn't work on it at all it would be a

00:34:09,369 --> 00:34:16,149
great improvement that probably require

00:34:12,879 --> 00:34:19,260
changes in the language that we're out

00:34:16,149 --> 00:34:19,260
of scrap probably

00:34:25,640 --> 00:34:32,159
did you work on any polymorphic types

00:34:28,800 --> 00:34:34,550
yet hey that's the question I don't want

00:34:32,159 --> 00:34:34,550
to hear

00:34:36,530 --> 00:34:42,450
there's nobody immersive em yet

00:34:39,320 --> 00:34:45,740
especially because it doesn't works well

00:34:42,450 --> 00:34:49,710
with the gradual typing stuff actually

00:34:45,740 --> 00:34:52,200
the set theoretic types which serve as

00:34:49,710 --> 00:34:54,810
the basis for all the rest have been

00:34:52,200 --> 00:34:58,530
recently extended with polymorphism

00:34:54,810 --> 00:35:01,350
so hopefully we'll be able to work it

00:34:58,530 --> 00:35:05,760
out and add polymer freedom to this but

00:35:01,350 --> 00:35:08,780
that's not done yet and I I don't know

00:35:05,760 --> 00:35:11,490
if it's gonna be possible anytime soon

00:35:08,780 --> 00:35:14,940
well you still have some bounded

00:35:11,490 --> 00:35:17,190
polymorphism coil you can say that your

00:35:14,940 --> 00:35:19,530
identity function as type into range

00:35:17,190 --> 00:35:23,000
intersection bull horrible intersection

00:35:19,530 --> 00:35:34,620
string or string but you can have

00:35:23,000 --> 00:35:38,220
infinite freedom or freedom just more or

00:35:34,620 --> 00:35:44,430
less not in the general case so we could

00:35:38,220 --> 00:35:47,130
have some hacks or but we could check it

00:35:44,430 --> 00:35:49,800
in some cases that after that it's used

00:35:47,130 --> 00:35:51,660
it's not easy to use if you have a

00:35:49,800 --> 00:35:53,040
polymorphic function you don't always

00:35:51,660 --> 00:35:58,280
know how you're going to instantiate

00:35:53,040 --> 00:36:06,000
your types when you try to apply it so

00:35:58,280 --> 00:36:07,800
well it's still a research topic what

00:36:06,000 --> 00:36:12,480
does your type checker say about a very

00:36:07,800 --> 00:36:20,370
awesome function lambda X if X less than

00:36:12,480 --> 00:36:22,490
5 then X else lambda Y X plus y actually

00:36:20,370 --> 00:36:25,610
if you gave him the right annotations

00:36:22,490 --> 00:36:28,980
he's gonna say really cool things called

00:36:25,610 --> 00:36:31,980
one night things with set theoretic

00:36:28,980 --> 00:36:33,930
types that I didn't mention if that you

00:36:31,980 --> 00:36:35,630
have singleton types but you can also

00:36:33,930 --> 00:36:38,030
have arbitrary in

00:36:35,630 --> 00:36:40,360
all types so you can have the type for

00:36:38,030 --> 00:36:45,050
all integers that are greater than tithe

00:36:40,360 --> 00:36:51,890
for example so I don't remember exactly

00:36:45,050 --> 00:36:55,610
what your function is that yes so it's

00:36:51,890 --> 00:36:57,680
going to type it as they set the

00:36:55,610 --> 00:37:02,470
intervals of integer that are greater

00:36:57,680 --> 00:37:05,480
than 5 per row in I remember correctly

00:37:02,470 --> 00:37:08,690
intersection all the other integers or

00:37:05,480 --> 00:37:10,570
or something or or something but I think

00:37:08,690 --> 00:37:13,070
it can type check it quite effectively

00:37:10,570 --> 00:37:18,560
but I also think you don't want to write

00:37:13,070 --> 00:37:20,680
that function in practice alright last

00:37:18,560 --> 00:37:20,680
question

00:37:22,450 --> 00:37:37,640
maybe Elko wants to say all right I

00:37:32,930 --> 00:37:40,640
think the last very simple question what

00:37:37,640 --> 00:37:42,350
is the random complexity of the current

00:37:40,640 --> 00:37:46,040
typing system that you have is it just

00:37:42,350 --> 00:37:48,470
linear it's mostly linear or because

00:37:46,040 --> 00:37:51,650
we're just training through the ice to

00:37:48,470 --> 00:37:55,810
the syntactic tree and we are not trying

00:37:51,650 --> 00:37:58,370
to reconstruct anything so it can be

00:37:55,810 --> 00:38:01,460
well it's not exactly linear because if

00:37:58,370 --> 00:38:05,050
you have intersection types you can have

00:38:01,460 --> 00:38:07,970
to check many time the same cut path and

00:38:05,050 --> 00:38:14,030
probably if you write complex enough

00:38:07,970 --> 00:38:17,420
types it can blow up but well at most

00:38:14,030 --> 00:38:21,470
I'd say it's quadratic I didn't exactly

00:38:17,420 --> 00:38:23,180
check it but yeah and just in the same

00:38:21,470 --> 00:38:25,310
direction do you have

00:38:23,180 --> 00:38:26,810
did you already made it and did you

00:38:25,310 --> 00:38:29,000
already make any kind of performance

00:38:26,810 --> 00:38:31,730
evaluations whether it can very quickly

00:38:29,000 --> 00:38:33,470
type some an expression that is as large

00:38:31,730 --> 00:38:36,710
as next packages or is this something

00:38:33,470 --> 00:38:39,920
that would still have to be done and I

00:38:36,710 --> 00:38:43,190
tried to do some some time measurements

00:38:39,920 --> 00:38:46,430
the problem is that my processor that I

00:38:43,190 --> 00:38:49,570
wrote probably with my feet or I don't

00:38:46,430 --> 00:38:52,750
know how but it was itself so slow that

00:38:49,570 --> 00:38:54,460
only passing the file took several

00:38:52,750 --> 00:39:06,310
seconds and was longer than the

00:38:54,460 --> 00:39:08,680
type-checking itself so no and I forgot

00:39:06,310 --> 00:39:10,810
the most important part of this torque

00:39:08,680 --> 00:39:13,600
which was to say thank you to everyone

00:39:10,810 --> 00:39:15,430
who donated to the crowdfunding campaign

00:39:13,600 --> 00:39:17,580
because it's really helped a lot thank

00:39:15,430 --> 00:39:17,580
you

00:39:21,160 --> 00:39:23,949

YouTube URL: https://www.youtube.com/watch?v=79dL7HgmW_k


