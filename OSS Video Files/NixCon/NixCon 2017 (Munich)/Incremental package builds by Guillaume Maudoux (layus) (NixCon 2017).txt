Title: Incremental package builds by Guillaume Maudoux (layus) (NixCon 2017)
Publication date: 2017-10-31
Playlist: NixCon 2017 (Munich)
Description: 
	The current CI infrastructure around nixpkgs has difficulties to build the whole package set in due time. While there were attempts to build every pull requests, these are not enabled by default because it requires even more resources. We will explore how to optimize even more the build process to meet the size of nixpkgs. We will survey with state-of-the-art build systems like scons, bazel and tup to see how we could improve incremental builds in nix. Based on nix-make, we will describe how nix could cooperate with the build tool of a given package to bring incremental builds at a finer granularity. In particular, we will explore how the intensional store model (as used by bazel for example) could help avoiding some mass rebuilds.

Bazel: https://schedule.nixcon2017.org/https://bazel.build
Tup: https://schedule.nixcon2017.org/https://gittup.org/tup
Nix-Make: https://schedule.nixcon2017.org/https://github.com/edolstra/nix-make
Captions: 
	00:00:03,520 --> 00:00:09,640
next speaker is a gilma do you so know

00:00:05,980 --> 00:00:13,450
him as Laius on github he started using

00:00:09,640 --> 00:00:15,700
an exit Mozilla a few years ago now he's

00:00:13,450 --> 00:00:27,730
working on a PhD on incremental builds

00:00:15,700 --> 00:00:31,509
yes thank you okay so let's start with a

00:00:27,730 --> 00:00:35,800
small background on me so I do my PhD in

00:00:31,509 --> 00:00:37,750
Louisville on dev near Brussels and just

00:00:35,800 --> 00:00:40,899
for the story Luverne enough I was a

00:00:37,750 --> 00:00:44,730
huge biking event which is also the

00:00:40,899 --> 00:00:47,920
second biggest drinking event in Europe

00:00:44,730 --> 00:00:52,890
after the one in Vinick so you know

00:00:47,920 --> 00:00:56,379
everything about my user name okay it's

00:00:52,890 --> 00:00:59,500
it's like a pan with a French word but

00:00:56,379 --> 00:01:00,850
yeah it's not very good as an

00:00:59,500 --> 00:01:03,070
introduction to this presentation so

00:01:00,850 --> 00:01:06,390
please mind with one little difference

00:01:03,070 --> 00:01:10,890
and that's very important right I

00:01:06,390 --> 00:01:15,070
contribute tunics packages of course and

00:01:10,890 --> 00:01:18,430
my github picture is a stone like that

00:01:15,070 --> 00:01:21,240
this stone is a stone from that castle

00:01:18,430 --> 00:01:23,259
which are also contributed to build so

00:01:21,240 --> 00:01:27,460
now you already know that I like

00:01:23,259 --> 00:01:30,430
building stuff right so I started my PhD

00:01:27,460 --> 00:01:32,380
on incremental builds and I want to

00:01:30,430 --> 00:01:34,030
feedback on this presentation so this is

00:01:32,380 --> 00:01:35,409
very important to me do not easy to

00:01:34,030 --> 00:01:38,290
interrupt the presentation if something

00:01:35,409 --> 00:01:39,149
if you want to ask a question in the

00:01:38,290 --> 00:01:41,700
meantime

00:01:39,149 --> 00:01:47,020
so let's start the presentation

00:01:41,700 --> 00:01:49,030
incremental package built what is

00:01:47,020 --> 00:01:52,360
incremental I went to dictionary which

00:01:49,030 --> 00:01:53,710
is always a good way to start except

00:01:52,360 --> 00:01:56,590
that in this case it doesn't mean I

00:01:53,710 --> 00:01:59,680
think of incremental is something that

00:01:56,590 --> 00:02:03,189
occurs in increments okay come on

00:01:59,680 --> 00:02:06,100
so what is increments it's the amount of

00:02:03,189 --> 00:02:07,840
degree by which something changes okay

00:02:06,100 --> 00:02:11,200
we cannot do anything with the

00:02:07,840 --> 00:02:13,930
definition so I just came with mine an

00:02:11,200 --> 00:02:16,390
incremental build system is something

00:02:13,930 --> 00:02:19,510
that works with very small steps

00:02:16,390 --> 00:02:23,470
we can do eat them separately and work

00:02:19,510 --> 00:02:26,080
with them we can use all the build

00:02:23,470 --> 00:02:30,130
projects and we use them so we do not

00:02:26,080 --> 00:02:32,650
have to do things that's already done

00:02:30,130 --> 00:02:35,980
and we also of course need the ability

00:02:32,650 --> 00:02:37,750
to detect what needs to be done so this

00:02:35,980 --> 00:02:41,190
is the plan of this presentation where I

00:02:37,750 --> 00:02:44,410
will take three examples from real life

00:02:41,190 --> 00:02:48,270
one with Firefox one which I train the

00:02:44,410 --> 00:02:52,930
window manager and one with the store

00:02:48,270 --> 00:02:55,239
the file for example shows why it's

00:02:52,930 --> 00:02:59,140
important to have small steps if you

00:02:55,239 --> 00:03:01,989
ever try to build Firefox then the build

00:02:59,140 --> 00:03:05,500
phase takes one hour and everything else

00:03:01,989 --> 00:03:09,370
is basically negligible compared to the

00:03:05,500 --> 00:03:11,890
huge builds time I was playing with that

00:03:09,370 --> 00:03:14,590
package and I had to change the fix up

00:03:11,890 --> 00:03:17,530
phase and of course I made a typo in the

00:03:14,590 --> 00:03:17,950
bash script and then what everything was

00:03:17,530 --> 00:03:20,260
lost

00:03:17,950 --> 00:03:21,489
okay so we really need checkpoints I

00:03:20,260 --> 00:03:24,220
mean it's just like when you are doing

00:03:21,489 --> 00:03:26,410
rock climbing your client being okay and

00:03:24,220 --> 00:03:29,200
then at some points there is a problem

00:03:26,410 --> 00:03:33,489
and then if there is no checkpoint in

00:03:29,200 --> 00:03:36,430
WoW you have back 2.0 right so we really

00:03:33,489 --> 00:03:38,250
need that kind of stuff just not to lose

00:03:36,430 --> 00:03:41,860
everything all the time

00:03:38,250 --> 00:03:45,130
so how can we do that a very simple idea

00:03:41,860 --> 00:03:47,950
just okay we already have parts in every

00:03:45,130 --> 00:03:50,190
build we have different phases so we

00:03:47,950 --> 00:03:55,450
could split them in different packages

00:03:50,190 --> 00:03:58,090
so that we once one phase is finished I

00:03:55,450 --> 00:04:00,690
mean it's done we can work with you on

00:03:58,090 --> 00:04:02,880
the next one

00:04:00,690 --> 00:04:04,800
you know it doesn't always work for

00:04:02,880 --> 00:04:07,320
Firefox is good but if the failure

00:04:04,800 --> 00:04:08,760
occurs in the build phase then basically

00:04:07,320 --> 00:04:11,700
you have a still the same problem that

00:04:08,760 --> 00:04:13,590
you lose one hour of build phase it's

00:04:11,700 --> 00:04:16,320
not good for a store because you will

00:04:13,590 --> 00:04:19,860
have every phase in the store and what

00:04:16,320 --> 00:04:22,590
does it mean can that even work but

00:04:19,860 --> 00:04:25,260
these ideas are already been implemented

00:04:22,590 --> 00:04:26,790
in some places with wrappers Firefox for

00:04:25,260 --> 00:04:29,610
example as an external wrapper which is

00:04:26,790 --> 00:04:33,660
another package that just writes the

00:04:29,610 --> 00:04:35,610
wrapper that's where you can change the

00:04:33,660 --> 00:04:38,450
wrapper easily without changing Firefox

00:04:35,610 --> 00:04:38,450
all the time

00:04:39,200 --> 00:04:47,160
okay so incremental width abouts small

00:04:43,710 --> 00:04:49,200
steps and in fact Nix is incremental in

00:04:47,160 --> 00:04:50,880
some way it's just that it's incremental

00:04:49,200 --> 00:04:56,250
at the level of package okay and just

00:04:50,880 --> 00:04:58,800
more step phonics is a package at the

00:04:56,250 --> 00:05:01,460
other hand we have build systems they

00:04:58,800 --> 00:05:04,590
already manage incremental builds of

00:05:01,460 --> 00:05:06,990
package like Firefox as its own build

00:05:04,590 --> 00:05:10,080
system and it's also incremental but we

00:05:06,990 --> 00:05:11,790
are not able to use that now in mix

00:05:10,080 --> 00:05:13,320
because we want things to be very pure

00:05:11,790 --> 00:05:18,690
so there is no interaction with the

00:05:13,320 --> 00:05:21,840
external world but so the idea here is

00:05:18,690 --> 00:05:25,020
to use existing build systems and to

00:05:21,840 --> 00:05:27,180
make them interoperate with NYX so that

00:05:25,020 --> 00:05:30,240
we can achieve incremental builds within

00:05:27,180 --> 00:05:33,960
its first build system that everyone

00:05:30,240 --> 00:05:36,180
knows is make and well I will not speak

00:05:33,960 --> 00:05:37,770
too much about make because it works but

00:05:36,180 --> 00:05:41,190
there is nothing you can do that's

00:05:37,770 --> 00:05:44,220
correct or in the sense that we like it

00:05:41,190 --> 00:05:47,610
we make will never be pure that's not in

00:05:44,220 --> 00:05:49,470
the design basically it use timestamps

00:05:47,610 --> 00:05:52,169
and we do it one time Sam's in the store

00:05:49,470 --> 00:05:54,690
for example it requires to have the

00:05:52,169 --> 00:05:56,610
previous builds in the same tree or as

00:05:54,690 --> 00:05:57,930
file in the tree so you need to add that

00:05:56,610 --> 00:06:02,190
as an input to the package and

00:05:57,930 --> 00:06:04,140
everything gets early but there

00:06:02,190 --> 00:06:08,600
doors that are quite interesting like

00:06:04,140 --> 00:06:08,600
see cash we know see cash

00:06:09,310 --> 00:06:15,610
which people okay tsukishima is

00:06:13,450 --> 00:06:18,340
compilers invocation so you can wrap a

00:06:15,610 --> 00:06:20,320
compiler code with that and if the same

00:06:18,340 --> 00:06:23,400
compiler code has been made before it

00:06:20,320 --> 00:06:23,400
will fetch the widget from the cache

00:06:23,550 --> 00:06:27,460
even better

00:06:24,960 --> 00:06:30,900
Mozilla developed the shared seek a

00:06:27,460 --> 00:06:33,700
while this sketch of previously builds

00:06:30,900 --> 00:06:36,370
stuff is shared on the network so you

00:06:33,700 --> 00:06:41,650
can reuse a build that someone else did

00:06:36,370 --> 00:06:44,140
and well this is a very good and robust

00:06:41,650 --> 00:06:46,510
design because I mean it's the design

00:06:44,140 --> 00:06:49,390
behind Nix right there is a shirt cache

00:06:46,510 --> 00:06:52,750
a binary cage that you can use and we

00:06:49,390 --> 00:06:55,570
can that we are sharing and this is used

00:06:52,750 --> 00:07:00,040
to replace building of some packages if

00:06:55,570 --> 00:07:02,230
they were already built before so

00:07:00,040 --> 00:07:06,010
caching is very good idea that we will

00:07:02,230 --> 00:07:08,490
reuse later but I want to show a small

00:07:06,010 --> 00:07:12,480
project by alcohol which is Nix Meg and

00:07:08,490 --> 00:07:15,600
Nix Meg basically allows you to

00:07:12,480 --> 00:07:18,390
it's a build system at the moment it

00:07:15,600 --> 00:07:18,630
only works with very simple stuffs like

00:07:18,390 --> 00:07:21,180
that

00:07:18,630 --> 00:07:24,630
you see that it's 15 commits okay so

00:07:21,180 --> 00:07:27,380
it's not very active but you can still

00:07:24,630 --> 00:07:27,380
do things like that

00:07:27,700 --> 00:07:32,950
there is one derivation come by the C

00:07:30,790 --> 00:07:36,310
producer derivation and the derivation

00:07:32,950 --> 00:07:38,110
just generates dot o file and then there

00:07:36,310 --> 00:07:41,040
is the link derivation that just takes

00:07:38,110 --> 00:07:43,750
all the file and produce the binary so

00:07:41,040 --> 00:07:46,120
we can use Nick's to do incremental

00:07:43,750 --> 00:07:49,990
computation at a finer level than just

00:07:46,120 --> 00:07:51,700
packages bats okay is you can do very

00:07:49,990 --> 00:07:55,390
small steps it's compatible with Nick's

00:07:51,700 --> 00:07:58,660
of course but I mean it's even worse

00:07:55,390 --> 00:08:03,220
than before every single dot o files end

00:07:58,660 --> 00:08:04,840
up in ends up in the store and you also

00:08:03,220 --> 00:08:07,900
need to pause every project to Nick's

00:08:04,840 --> 00:08:10,450
make okay so if you're using whatever

00:08:07,900 --> 00:08:12,520
before like basil then you need to write

00:08:10,450 --> 00:08:13,650
another layer to port it to a next medic

00:08:12,520 --> 00:08:16,600
this is not feasible

00:08:13,650 --> 00:08:20,710
speaking about basil this is an amazing

00:08:16,600 --> 00:08:22,590
a tremendous project from Google look

00:08:20,710 --> 00:08:29,440
like they are very proud of the stuff

00:08:22,590 --> 00:08:33,460
fast or correct b2 and it's a project

00:08:29,440 --> 00:08:38,710
that as most of things right they

00:08:33,460 --> 00:08:40,960
managed to build every command they can

00:08:38,710 --> 00:08:43,720
basically cache every command and put

00:08:40,960 --> 00:08:46,420
that in a shared cache they can even ask

00:08:43,720 --> 00:08:50,380
another machine to compile that step and

00:08:46,420 --> 00:08:54,280
then get the result so this is something

00:08:50,380 --> 00:08:56,170
that we would like to have it's also

00:08:54,280 --> 00:08:58,800
really really correct there is

00:08:56,170 --> 00:09:02,370
sandboxing going in there

00:08:58,800 --> 00:09:04,589
but you know it's so good that it does

00:09:02,370 --> 00:09:06,899
exactly the same stuff as Nick's so we

00:09:04,589 --> 00:09:09,870
are when you try to make both of them

00:09:06,899 --> 00:09:11,519
work together they're fighting to take

00:09:09,870 --> 00:09:12,060
the control be the one that manages

00:09:11,519 --> 00:09:13,620
sundogs

00:09:12,060 --> 00:09:16,920
and do not let the others do other stuff

00:09:13,620 --> 00:09:19,170
so it's quite difficult to use it in

00:09:16,920 --> 00:09:21,209
fact it's used at Google and at Google

00:09:19,170 --> 00:09:24,180
everything use basil so it's quite easy

00:09:21,209 --> 00:09:25,320
but with Nick's and Nick's packages we

00:09:24,180 --> 00:09:28,740
have something that's much more

00:09:25,320 --> 00:09:31,320
a taraji news I mean the package with

00:09:28,740 --> 00:09:33,930
make package with SBT packages image and

00:09:31,320 --> 00:09:35,149
we cannot use just one build system to

00:09:33,930 --> 00:09:37,200
rule them all

00:09:35,149 --> 00:09:41,190
so is it possible to do something

00:09:37,200 --> 00:09:43,110
intermediates and my solution is okay we

00:09:41,190 --> 00:09:47,700
want caching we want to be able to cache

00:09:43,110 --> 00:09:50,519
smaller steps than just packages can we

00:09:47,700 --> 00:09:53,760
somehow allow the build system to access

00:09:50,519 --> 00:09:57,830
an external cache

00:09:53,760 --> 00:10:00,930
while remaining correct and to do that

00:09:57,830 --> 00:10:03,960
we may need the help of mix built to

00:10:00,930 --> 00:10:05,940
provide the same interface but in the

00:10:03,960 --> 00:10:07,170
first attempt if you do not care too

00:10:05,940 --> 00:10:09,240
much about correctness then it's very

00:10:07,170 --> 00:10:11,880
easy to implement basically you making

00:10:09,240 --> 00:10:15,030
you build not so pure allow access to an

00:10:11,880 --> 00:10:17,780
external store and allow for example ckh

00:10:15,030 --> 00:10:21,300
to access that store it looks like that

00:10:17,780 --> 00:10:24,780
you call make I mean next build stylist

00:10:21,300 --> 00:10:27,240
and box next works in de Courcey cache

00:10:24,780 --> 00:10:30,450
for example and then CK's shrubs in the

00:10:27,240 --> 00:10:33,150
environments a circuit to discuss with

00:10:30,450 --> 00:10:35,640
the external store as simple as that if

00:10:33,150 --> 00:10:37,650
you trust CK Street to do things

00:10:35,640 --> 00:10:39,900
correctly then you will have correct

00:10:37,650 --> 00:10:42,090
builds of course you cannot always trust

00:10:39,900 --> 00:10:44,490
the cache so we will have to implement

00:10:42,090 --> 00:10:46,920
some checking on top of it but this is

00:10:44,490 --> 00:10:48,420
the basic idea and if you start with

00:10:46,920 --> 00:10:50,430
something simple like that then you can

00:10:48,420 --> 00:10:52,680
port one package at a time try to make

00:10:50,430 --> 00:10:55,460
it work start maybe with big package

00:10:52,680 --> 00:10:55,460
like Firefox

00:10:56,370 --> 00:11:01,260
and yes this is my master plant this is

00:10:59,790 --> 00:11:05,610
something that I went to do for my PhD

00:11:01,260 --> 00:11:08,610
the ability to use

00:11:05,610 --> 00:11:12,390
incremental builds from the build system

00:11:08,610 --> 00:11:15,180
within these and to be able to go both

00:11:12,390 --> 00:11:17,220
direction to make them cooperate so at

00:11:15,180 --> 00:11:20,570
the end we should be able to rule over

00:11:17,220 --> 00:11:24,050
the world right with the system but

00:11:20,570 --> 00:11:27,710
still a work in progress

00:11:24,050 --> 00:11:31,100
okay any question about that maybe

00:11:27,710 --> 00:11:45,650
before the next part

00:11:31,100 --> 00:11:52,430
I mean you can see us questioning

00:11:45,650 --> 00:11:56,810
normally you have a does it do you have

00:11:52,430 --> 00:12:00,530
tends to work like this stuff by check

00:11:56,810 --> 00:12:04,940
output but do you have like one or two

00:12:00,530 --> 00:12:07,520
words how okay I can say two things

00:12:04,940 --> 00:12:12,730
yes the intention store would help I

00:12:07,520 --> 00:12:15,160
will speak about that later and

00:12:12,730 --> 00:12:17,050
what can I say basil or really does

00:12:15,160 --> 00:12:19,990
something like that much more advanced

00:12:17,050 --> 00:12:22,450
that was ckh does X ability there's a

00:12:19,990 --> 00:12:25,270
lot of other stuff that we do not want

00:12:22,450 --> 00:12:27,580
so we may need to import that part of

00:12:25,270 --> 00:12:30,670
the code and then know if it works for

00:12:27,580 --> 00:12:32,230
them it should work for us to write in

00:12:30,670 --> 00:12:34,450
if you want more correctness than what

00:12:32,230 --> 00:12:37,120
they achieve which is already quite AI

00:12:34,450 --> 00:12:42,640
then we may still work on it implemented

00:12:37,120 --> 00:12:45,130
the the interface here may not be just

00:12:42,640 --> 00:12:47,380
Rev access to files it may be okay I

00:12:45,130 --> 00:12:50,200
want to build to call that comment with

00:12:47,380 --> 00:12:54,280
these files with dis environments and

00:12:50,200 --> 00:12:56,860
then we let NICs build build run the

00:12:54,280 --> 00:12:58,150
command and produce a case result so if

00:12:56,860 --> 00:13:01,570
everything is in the ends of Nick's

00:12:58,150 --> 00:13:04,450
buildin should be clean okay but this is

00:13:01,570 --> 00:13:06,040
more strict and this needs more I mean

00:13:04,450 --> 00:13:07,960
it needs to change a bit of C cache

00:13:06,040 --> 00:13:09,490
works at the moment so the more

00:13:07,960 --> 00:13:11,970
cognizant want and the more work used to

00:13:09,490 --> 00:13:11,970
do of course

00:13:15,770 --> 00:13:27,050
okay

00:13:17,280 --> 00:13:27,050
I was just wondering if very results

00:13:27,390 --> 00:13:30,500
instead of putting them in

00:13:32,120 --> 00:13:38,990
okay so yeah the idea about this turf is

00:13:35,660 --> 00:13:41,480
that this is this is not defined this

00:13:38,990 --> 00:13:44,509
may be the next or this may not be it

00:13:41,480 --> 00:13:45,680
depends on what you want to do if this

00:13:44,509 --> 00:13:46,189
is the first time that I use something

00:13:45,680 --> 00:13:48,499
like that

00:13:46,189 --> 00:13:51,410
the out of you that want to have like

00:13:48,499 --> 00:13:52,970
yaki Celtic stores when you have one

00:13:51,410 --> 00:13:55,040
next door for the packages then one next

00:13:52,970 --> 00:13:56,300
door for other stuff that are less

00:13:55,040 --> 00:13:58,399
important that can be garbage collected

00:13:56,300 --> 00:14:02,600
more fun and maybe another nick store

00:13:58,399 --> 00:14:04,040
for custom projects I'm not sure that

00:14:02,600 --> 00:14:06,470
this idea of the Nick store is the

00:14:04,040 --> 00:14:07,999
perfect way of doing caching the idea of

00:14:06,470 --> 00:14:09,319
Nick storage to have when you need the

00:14:07,999 --> 00:14:12,079
directory because you need to access the

00:14:09,319 --> 00:14:15,769
files but it may may be more efficient

00:14:12,079 --> 00:14:18,079
to cache compressed versions of the

00:14:15,769 --> 00:14:20,720
files for example so you may not want to

00:14:18,079 --> 00:14:23,949
you may not want exactly a next door but

00:14:20,720 --> 00:14:23,949
you need some way to catch stuff

00:14:24,300 --> 00:14:30,130
okay let's continue anywhere you can ask

00:14:26,530 --> 00:14:32,680
questions later so I know the use case I

00:14:30,130 --> 00:14:34,510
had I was I had a problem which I tree

00:14:32,680 --> 00:14:35,830
which is my window manager and being the

00:14:34,510 --> 00:14:41,170
window manager is something that you

00:14:35,830 --> 00:14:45,630
need every all the time but to reproduce

00:14:41,170 --> 00:14:48,070
the bug I had to use it on my main

00:14:45,630 --> 00:14:50,260
laptop because basically the bug a pen

00:14:48,070 --> 00:14:52,630
when I unlocked it and docked it again

00:14:50,260 --> 00:14:56,680
so I mean this was the only way I found

00:14:52,630 --> 00:14:58,420
to reproduce that bag and so to test new

00:14:56,680 --> 00:15:02,410
versions of I tree

00:14:58,420 --> 00:15:06,160
I had to propagate them tunak tunak

00:15:02,410 --> 00:15:07,510
configuration I'm you all already had

00:15:06,160 --> 00:15:09,370
something like that's why you want to

00:15:07,510 --> 00:15:11,700
test something and it's very complex

00:15:09,370 --> 00:15:16,180
because it needs to go into the mixers

00:15:11,700 --> 00:15:17,880
configuration and how do I do that my

00:15:16,180 --> 00:15:21,190
typical Dybbuk session looks like that I

00:15:17,880 --> 00:15:24,790
use Nick's shell I try to patch see if

00:15:21,190 --> 00:15:27,550
it compiles etc if I can do that then I

00:15:24,790 --> 00:15:31,210
extracted this and then I generate an

00:15:27,550 --> 00:15:33,000
overlay to build a new package and I

00:15:31,210 --> 00:15:35,770
check that it builds with Nick's build

00:15:33,000 --> 00:15:39,820
then I insert that package in exercise

00:15:35,770 --> 00:15:42,510
and just I rebuild Nick service and then

00:15:39,820 --> 00:15:45,190
I will start I test and if it works I

00:15:42,510 --> 00:15:47,560
mean that's fine if I can reproduce the

00:15:45,190 --> 00:15:49,200
bug it's not that good and if it crashed

00:15:47,560 --> 00:15:52,510
everything that I need to rollback of

00:15:49,200 --> 00:15:54,250
course and then back again because it's

00:15:52,510 --> 00:15:56,050
a loop I mean when you are trying to

00:15:54,250 --> 00:15:58,480
debug something you have to insert the

00:15:56,050 --> 00:16:00,280
back statements then maybe it starts EVP

00:15:58,480 --> 00:16:03,700
stuff like that so it's quite complex I

00:16:00,280 --> 00:16:06,400
mean and it would be so simple if I

00:16:03,700 --> 00:16:08,230
could just you know compile ice ray and

00:16:06,400 --> 00:16:11,500
say okay put it in the store and use

00:16:08,230 --> 00:16:13,750
that I know it's not clean but then it

00:16:11,500 --> 00:16:15,640
would be easy right and there are

00:16:13,750 --> 00:16:16,900
solutions to do that should maybe not

00:16:15,640 --> 00:16:20,260
say that maybe we'll need to cut the

00:16:16,900 --> 00:16:25,510
video at some points but it is possible

00:16:20,260 --> 00:16:30,610
to among the next or with right but yeah

00:16:25,510 --> 00:16:32,620
okay you should do it more clean but

00:16:30,610 --> 00:16:34,720
very rocky solution is to insert a SIM

00:16:32,620 --> 00:16:36,160
link into the next or make a fake

00:16:34,720 --> 00:16:37,720
derivation that justice evening to

00:16:36,160 --> 00:16:39,370
somewhere else you are

00:16:37,720 --> 00:16:40,959
your own directory or you project the

00:16:39,370 --> 00:16:43,300
return then there are some

00:16:40,959 --> 00:16:46,569
technicalities which you know self loops

00:16:43,300 --> 00:16:49,480
and stuff like that but spasibo and yeah

00:16:46,569 --> 00:16:51,459
you can go straight to the solution say

00:16:49,480 --> 00:16:52,810
okay this service use that package okay

00:16:51,459 --> 00:16:54,579
I can override the service the necks of

00:16:52,810 --> 00:16:57,160
service and say okay use the package in

00:16:54,579 --> 00:16:59,620
my home environment that works too but

00:16:57,160 --> 00:17:00,910
then I mean it's not what we want we are

00:16:59,620 --> 00:17:02,050
used to something that's pure that's

00:17:00,910 --> 00:17:05,130
clean and then we are trying to achieve

00:17:02,050 --> 00:17:08,020
everything so this is indeed very active

00:17:05,130 --> 00:17:10,270
so I went to look for tools that allowed

00:17:08,020 --> 00:17:12,549
to do that and one of them is git rebase

00:17:10,270 --> 00:17:15,480
interactive when you do git rebase

00:17:12,549 --> 00:17:18,039
interactive it tries to apply all the

00:17:15,480 --> 00:17:20,169
commits and so on and when there is a

00:17:18,039 --> 00:17:21,699
conflict you are dropped in an

00:17:20,169 --> 00:17:24,250
environment that looks like it's a

00:17:21,699 --> 00:17:25,959
normal get repo but it's not really if

00:17:24,250 --> 00:17:29,799
you try to push that on a branch it will

00:17:25,959 --> 00:17:32,470
be strange etc but you can commit behave

00:17:29,799 --> 00:17:33,760
like you are normal commit environments

00:17:32,470 --> 00:17:36,929
and when you are done you suggest

00:17:33,760 --> 00:17:39,340
continue and it just continuous job

00:17:36,929 --> 00:17:41,250
integrating your modification that's

00:17:39,340 --> 00:17:43,480
something we would like with Nik shell

00:17:41,250 --> 00:17:45,820
basic Linux shell set up the right

00:17:43,480 --> 00:17:48,220
environment to build the stuff you can

00:17:45,820 --> 00:17:49,809
build it you can go to the end but when

00:17:48,220 --> 00:17:51,940
you are doing making style it doesn't

00:17:49,809 --> 00:17:54,669
install because you cannot access the

00:17:51,940 --> 00:17:58,269
next or why

00:17:54,669 --> 00:17:59,679
it would be interesting to you know be

00:17:58,269 --> 00:18:02,769
able to write in the next hour that

00:17:59,679 --> 00:18:05,470
point and produce a package and if you

00:18:02,769 --> 00:18:07,779
are annoyed about purity then just make

00:18:05,470 --> 00:18:10,690
Nick shell accept a high corruption and

00:18:07,779 --> 00:18:13,269
the Egyptian produce a derivation with a

00:18:10,690 --> 00:18:14,859
random input parameter so it doesn't

00:18:13,269 --> 00:18:18,580
conflict with the normal one the pure

00:18:14,859 --> 00:18:20,590
one and this random input says okay it

00:18:18,580 --> 00:18:23,019
represents the fact that a human can

00:18:20,590 --> 00:18:27,609
just tamper with the build so the human

00:18:23,019 --> 00:18:28,960
can add random stuff into the build but

00:18:27,609 --> 00:18:31,509
that would be very very nice because

00:18:28,960 --> 00:18:34,539
then we could insert basically anything

00:18:31,509 --> 00:18:38,289
in the store in way that's quite clean

00:18:34,539 --> 00:18:39,820
and corresponds to the Nick's model to

00:18:38,289 --> 00:18:42,970
explain that differently I have defined

00:18:39,820 --> 00:18:45,399
the Nick's OSI model which is not to be

00:18:42,970 --> 00:18:48,960
taken too seriously okay but we have

00:18:45,399 --> 00:18:51,909
layers and each of these layers are

00:18:48,960 --> 00:18:53,649
related to different tools so if you use

00:18:51,909 --> 00:18:56,019
Nick's build then you know nothing about

00:18:53,649 --> 00:18:57,940
Nick sauce basically if you use Nick

00:18:56,019 --> 00:19:00,009
sauce then you know nothing about serve

00:18:57,940 --> 00:19:04,119
about different servers like Nick's

00:19:00,009 --> 00:19:06,159
table does and if you use meg and then

00:19:04,119 --> 00:19:08,590
you know nothing about everything that's

00:19:06,159 --> 00:19:10,509
in Nick's right nowadays it's nearly

00:19:08,590 --> 00:19:13,149
impossible to just run make on a project

00:19:10,509 --> 00:19:15,639
you need an excel to get the right

00:19:13,149 --> 00:19:18,820
environments so basically what you do is

00:19:15,639 --> 00:19:21,039
you start at the next Shell level you

00:19:18,820 --> 00:19:23,900
open the zipper okay and then you enter

00:19:21,039 --> 00:19:26,900
an environment where you can just

00:19:23,900 --> 00:19:28,130
play with ITRI and you project and when

00:19:26,900 --> 00:19:30,470
you are done

00:19:28,130 --> 00:19:33,050
yeah when you're done you're gonna do

00:19:30,470 --> 00:19:34,340
that package but it would be nice if you

00:19:33,050 --> 00:19:37,280
could just close the zipper and say okay

00:19:34,340 --> 00:19:39,080
I have a package now I enter it and I

00:19:37,280 --> 00:19:42,110
can exit it

00:19:39,080 --> 00:19:43,940
of course there is you can go further

00:19:42,110 --> 00:19:46,220
and say okay let's add the hack comment

00:19:43,940 --> 00:19:48,980
to Nick's rebuild to an accessory build

00:19:46,220 --> 00:19:53,420
and then you would start higher in the

00:19:48,980 --> 00:19:56,809
hierarchy zip inside it and then go

00:19:53,420 --> 00:19:59,120
outside of so you could it would drop me

00:19:56,809 --> 00:20:01,730
for example in a shell where I can just

00:19:59,120 --> 00:20:03,800
edit a tree and then it would use that

00:20:01,730 --> 00:20:07,220
version of I tree only for that build of

00:20:03,800 --> 00:20:09,110
Nyx's okay it's not that clean but in

00:20:07,220 --> 00:20:10,970
the end it's correct because it's a

00:20:09,110 --> 00:20:12,410
diversion with a random input which

00:20:10,970 --> 00:20:15,980
correspond to the fact that I've shared

00:20:12,410 --> 00:20:20,720
something and I can easily enter and get

00:20:15,980 --> 00:20:23,360
back of the tree okay

00:20:20,720 --> 00:20:25,610
now for the extra step if you remember

00:20:23,360 --> 00:20:28,550
caching then we can still use caching in

00:20:25,610 --> 00:20:30,830
that okay if what I did in the nick

00:20:28,550 --> 00:20:32,000
shell was corresponds to what will be

00:20:30,830 --> 00:20:33,260
done by the next build

00:20:32,000 --> 00:20:35,780
then there is no reason annex build

00:20:33,260 --> 00:20:38,600
could not we use that okay if I was

00:20:35,780 --> 00:20:41,000
using correctly the API to the cache and

00:20:38,600 --> 00:20:42,710
that Nix build cached my bills then it

00:20:41,000 --> 00:20:47,030
could be reused so this is very

00:20:42,710 --> 00:20:49,220
efficient because we never never compile

00:20:47,030 --> 00:20:54,830
the same thing twice if you compile it

00:20:49,220 --> 00:20:58,000
twice then what what happened oh no crap

00:20:54,830 --> 00:20:58,000
[Music]

00:20:59,000 --> 00:21:03,560
if we compile the same thing twice then

00:21:01,960 --> 00:21:05,330
there was a bug

00:21:03,560 --> 00:21:13,030
you shouldn't this should never happen

00:21:05,330 --> 00:21:17,270
right okay so this is the the part about

00:21:13,030 --> 00:21:19,220
you know being a nicer interface strick

00:21:17,270 --> 00:21:21,920
is good but some time to strike is just

00:21:19,220 --> 00:21:24,410
I mean it gets in the way okay so I

00:21:21,920 --> 00:21:29,420
think we can go a bit further and

00:21:24,410 --> 00:21:33,980
improve the interface of Nyx to play

00:21:29,420 --> 00:21:36,350
nicely with users yes and this is the

00:21:33,980 --> 00:21:38,200
second part of my presentation so if you

00:21:36,350 --> 00:21:41,920
have questions on that parts precisely I

00:21:38,200 --> 00:21:41,920
will be able to take them

00:21:43,970 --> 00:21:50,390
the Navy question for you would you use

00:21:46,460 --> 00:21:52,070
a tool like that and I even know the

00:21:50,390 --> 00:21:55,130
question do you think it's easy to

00:21:52,070 --> 00:22:07,580
implement Wilco

00:21:55,130 --> 00:22:09,520
any ID okay I just some way there are

00:22:07,580 --> 00:22:11,720
already some hacky ways how you can

00:22:09,520 --> 00:22:14,710
roughly what you already mentioned so

00:22:11,720 --> 00:22:17,390
for example some larger Haskell birds

00:22:14,710 --> 00:22:18,950
problem that building them from scratch

00:22:17,390 --> 00:22:19,850
every time with a couple hundred

00:22:18,950 --> 00:22:25,220
packages

00:22:19,850 --> 00:22:26,930
each going so one way to work around it

00:22:25,220 --> 00:22:30,440
for example is to usually you're

00:22:26,930 --> 00:22:32,870
supposed to add build inputs like SRC

00:22:30,440 --> 00:22:36,110
right yours actually add only your

00:22:32,870 --> 00:22:38,510
sources but standard or you could claim

00:22:36,110 --> 00:22:41,810
a standard way in get this kind of

00:22:38,510 --> 00:22:43,670
caching concept as you have shown is

00:22:41,810 --> 00:22:45,890
that instead of just adding the sources

00:22:43,670 --> 00:22:48,260
you also just add build directory as

00:22:45,890 --> 00:22:50,600
well right because if you have a correct

00:22:48,260 --> 00:22:55,400
bit system for your language for example

00:22:50,600 --> 00:22:57,470
tht haskell and you have built directory

00:22:55,400 --> 00:22:59,450
present and it will resume from where

00:22:57,470 --> 00:23:01,220
left of last times you're basically

00:22:59,450 --> 00:23:02,840
taking your way in by saying your

00:23:01,220 --> 00:23:04,640
sources are not just the sources but

00:23:02,840 --> 00:23:06,710
actually the sources plus the build

00:23:04,640 --> 00:23:09,260
directory so that already works but of

00:23:06,710 --> 00:23:11,060
course it's pretty happy enough they're

00:23:09,260 --> 00:23:13,220
built directly here the directory can be

00:23:11,060 --> 00:23:15,320
Roger Lodge every time you do this kind

00:23:13,220 --> 00:23:17,480
of build you create lots of stuff in the

00:23:15,320 --> 00:23:19,460
next door so it would be really nice to

00:23:17,480 --> 00:23:21,920
have an official way to do that as you

00:23:19,460 --> 00:23:25,670
suggest such that you have same benefits

00:23:21,920 --> 00:23:29,240
but without the drawbacks of that kind

00:23:25,670 --> 00:23:32,060
of idea that in this concept extra data

00:23:29,240 --> 00:23:38,380
that is like source input but also like

00:23:32,060 --> 00:23:40,060
cash in zooming that the yes

00:23:38,380 --> 00:23:43,510
that's but if you are if you want to

00:23:40,060 --> 00:23:44,920
build a local project then more often

00:23:43,510 --> 00:23:47,080
than not every time you call Nick's

00:23:44,920 --> 00:23:49,480
build then it will fetch the sources and

00:23:47,080 --> 00:23:51,250
put them in the store and depending on

00:23:49,480 --> 00:23:53,710
your disk is maybe a very quite long

00:23:51,250 --> 00:23:55,330
operation already and then you still

00:23:53,710 --> 00:23:57,340
need to build it from scratch and this

00:23:55,330 --> 00:24:00,100
is stupid so one solution is to add the

00:23:57,340 --> 00:24:00,820
extra input like you say but then I mean

00:24:00,100 --> 00:24:03,280
you do it

00:24:00,820 --> 00:24:04,660
Nick's build will never acknowledge that

00:24:03,280 --> 00:24:07,000
it was the same thing that you built

00:24:04,660 --> 00:24:10,750
before so there is no way to make this

00:24:07,000 --> 00:24:13,580
work efficiently for building and you

00:24:10,750 --> 00:24:27,169
will never be able to share what you did

00:24:13,580 --> 00:24:29,320
but okay I think you're doing this yes

00:24:27,169 --> 00:24:31,970
yes exactly

00:24:29,320 --> 00:24:40,220
okay I will add that to my do not do

00:24:31,970 --> 00:24:41,720
that slide yeah there is a question or

00:24:40,220 --> 00:24:43,309
so in that environment would you be

00:24:41,720 --> 00:24:44,989
allowed to access the network or not and

00:24:43,309 --> 00:24:51,529
I guess we could have different versions

00:24:44,989 --> 00:24:55,960
of your and okay so next user story and

00:24:51,529 --> 00:24:55,960
this may be a bit more technical

00:24:56,940 --> 00:25:00,299
and I have a problem with the Knicks

00:24:58,739 --> 00:25:03,659
store it's not a big problem but it

00:25:00,299 --> 00:25:05,190
annoys me most of the time is that in my

00:25:03,659 --> 00:25:08,879
niche store there are so many package

00:25:05,190 --> 00:25:10,739
that are just basically the same okay if

00:25:08,879 --> 00:25:14,639
you take for example two popular data

00:25:10,739 --> 00:25:17,609
and you dip them the only difference is

00:25:14,639 --> 00:25:20,879
in the package config file okay and the

00:25:17,609 --> 00:25:23,479
yeah package config file and there is

00:25:20,879 --> 00:25:26,940
only the popular that idea and see flags

00:25:23,479 --> 00:25:29,849
and why are the difference because they

00:25:26,940 --> 00:25:35,070
reference the demo version itself okay

00:25:29,849 --> 00:25:38,220
so this is the out ash of the derivation

00:25:35,070 --> 00:25:40,169
here is not something no it's not an

00:25:38,220 --> 00:25:42,929
input that changed okay it's only the

00:25:40,169 --> 00:25:46,850
out ash that has changed that was

00:25:42,929 --> 00:25:48,260
written in the derivation

00:25:46,850 --> 00:25:50,930
what does that mean it means that

00:25:48,260 --> 00:25:52,220
because we gave two different out as to

00:25:50,930 --> 00:25:54,830
this derivation they end up being

00:25:52,220 --> 00:25:56,900
different but if they had the same out

00:25:54,830 --> 00:25:59,180
hash they would be the same these are

00:25:56,900 --> 00:26:00,320
exactly the same derivation except that

00:25:59,180 --> 00:26:03,770
this one is stored in a different

00:26:00,320 --> 00:26:07,940
location and this one and I mean this

00:26:03,770 --> 00:26:10,250
must be written into the file sir okay

00:26:07,940 --> 00:26:12,110
so

00:26:10,250 --> 00:26:15,980
this is what it looks like when there is

00:26:12,110 --> 00:26:19,429
no optimization right oh yeah sorry it's

00:26:15,980 --> 00:26:21,919
ITRI but could be any package you have

00:26:19,429 --> 00:26:25,039
this derivation file and then there is a

00:26:21,919 --> 00:26:26,990
various mole difference may be an input

00:26:25,039 --> 00:26:29,509
change but it's not important to the

00:26:26,990 --> 00:26:32,179
derivation doesn't change what gets

00:26:29,509 --> 00:26:33,950
built in the end and so you end up with

00:26:32,179 --> 00:26:36,019
two package two different package in the

00:26:33,950 --> 00:26:38,509
binary cage you will need to download

00:26:36,019 --> 00:26:39,799
this package two times if use both and

00:26:38,509 --> 00:26:42,460
then you end up with two package in your

00:26:39,799 --> 00:26:48,080
store and there are nearly identical

00:26:42,460 --> 00:26:51,940
so the first optimization and I was

00:26:48,080 --> 00:26:51,940
using an optimized store

00:26:52,100 --> 00:26:56,660
okay quite quite a lot of people though

00:26:54,520 --> 00:26:59,660
there is this nifty tool that's called

00:26:56,660 --> 00:27:01,970
disk usage and for a long time I did not

00:26:59,660 --> 00:27:04,340
understand why that very word where it

00:27:01,970 --> 00:27:07,700
reserved like that let's in fact the

00:27:04,340 --> 00:27:10,010
tool is very smart so an accounts the

00:27:07,700 --> 00:27:13,130
space that he does not counted yet okay

00:27:10,010 --> 00:27:15,590
so what happens here I asked for the

00:27:13,130 --> 00:27:17,390
space of three popular data derivation

00:27:15,590 --> 00:27:20,690
and the first one oops

00:27:17,390 --> 00:27:24,800
wels megabytes and the others are only

00:27:20,690 --> 00:27:26,990
60 K all right this is because the

00:27:24,800 --> 00:27:29,300
optimization of the store are links

00:27:26,990 --> 00:27:31,220
every file the files are the same

00:27:29,300 --> 00:27:32,870
together so all the files that were

00:27:31,220 --> 00:27:35,960
already counted for this derivation are

00:27:32,870 --> 00:27:39,110
not counted anymore for these ones okay

00:27:35,960 --> 00:27:41,120
this means that basically there is

00:27:39,110 --> 00:27:42,980
nothing in a it corresponds to our

00:27:41,120 --> 00:27:46,670
intuition that there is only one file

00:27:42,980 --> 00:27:49,040
that changes and in these derivations is

00:27:46,670 --> 00:27:52,610
3d revisions you have folders which

00:27:49,040 --> 00:27:54,770
cannot be are linked and are links to

00:27:52,610 --> 00:27:57,170
the same files okay so this is only

00:27:54,770 --> 00:27:59,720
counted in the first one

00:27:57,170 --> 00:28:05,060
what does it look like on my picture it

00:27:59,720 --> 00:28:09,500
looks like this right you are able to

00:28:05,060 --> 00:28:11,780
optimize use a little store usage but

00:28:09,500 --> 00:28:14,600
you only know that in the end when you

00:28:11,780 --> 00:28:16,550
have downloaded twice build it twice so

00:28:14,600 --> 00:28:19,420
it's not very efficient except for disk

00:28:16,550 --> 00:28:19,420
space on your machine

00:28:20,270 --> 00:28:28,020
and yes network usage is important

00:28:24,390 --> 00:28:30,480
every week or so we merged the unstable

00:28:28,020 --> 00:28:33,240
branch the unstable branch into master

00:28:30,480 --> 00:28:35,730
and unstable branch is the branch for us

00:28:33,240 --> 00:28:38,190
must reveal stuff must rebuild means

00:28:35,730 --> 00:28:39,600
that's mostly I at least alpha the

00:28:38,190 --> 00:28:41,460
package are impacted there is a huge

00:28:39,600 --> 00:28:43,050
impact if you have twitches like that

00:28:41,460 --> 00:28:46,800
you can be sure that you can download

00:28:43,050 --> 00:28:50,490
everything so if you are like me and

00:28:46,800 --> 00:28:51,840
that you update once amounts then every

00:28:50,490 --> 00:28:54,350
time you update you need to download a

00:28:51,840 --> 00:28:56,230
fully new distribution

00:28:54,350 --> 00:28:58,789
you need to download all the package and

00:28:56,230 --> 00:29:00,380
I think we can do better than that

00:28:58,789 --> 00:29:02,990
I mean we do not need to download

00:29:00,380 --> 00:29:06,110
everything most probably there is not a

00:29:02,990 --> 00:29:10,700
big change like a small change like we

00:29:06,110 --> 00:29:12,470
saw before to do that it's an idea that

00:29:10,700 --> 00:29:15,200
I would not implement but apparently

00:29:12,470 --> 00:29:19,700
existed at some point we could invent

00:29:15,200 --> 00:29:21,320
this idea of binary diff right say okay

00:29:19,700 --> 00:29:22,850
this derivation it looks like the

00:29:21,320 --> 00:29:24,950
previous one okay so be different but

00:29:22,850 --> 00:29:28,730
let's just only ship the diff and keep

00:29:24,950 --> 00:29:31,600
the diff into the binary cash I'd like

00:29:28,730 --> 00:29:33,860
to do that it's just a difference

00:29:31,600 --> 00:29:36,020
substitute that will be provided and it

00:29:33,860 --> 00:29:38,390
needs to be understand by NYX but it

00:29:36,020 --> 00:29:41,600
looks quite easy to do one question is

00:29:38,390 --> 00:29:45,049
okay what do you differ with which is

00:29:41,600 --> 00:29:48,169
the old package but this would help a

00:29:45,049 --> 00:29:49,830
lot to save bandwidth and space on I

00:29:48,169 --> 00:29:52,100
draw

00:29:49,830 --> 00:29:54,470
but there

00:29:52,100 --> 00:29:57,530
another option that I prefer and that's

00:29:54,470 --> 00:29:59,840
I will call content address storage ok

00:29:57,530 --> 00:30:03,080
because we all call it's intentional

00:29:59,840 --> 00:30:05,450
store and it's exactly not intentional

00:30:03,080 --> 00:30:07,789
it's exactly the opposite of that so

00:30:05,450 --> 00:30:11,990
let's keep its content address storage

00:30:07,789 --> 00:30:15,169
ok what merchants made a RFC for that

00:30:11,990 --> 00:30:17,539
and is not here I think so

00:30:15,169 --> 00:30:20,750
I'm bit sad because I wanted to work on

00:30:17,539 --> 00:30:24,470
that with him but anyway the idea is

00:30:20,750 --> 00:30:28,130
that if you can detect that's you build

00:30:24,470 --> 00:30:30,830
exactly the same package up to the self

00:30:28,130 --> 00:30:33,740
links then you can just use the same

00:30:30,830 --> 00:30:36,440
package and you're done it is very nice

00:30:33,740 --> 00:30:38,659
because when you are when you query I

00:30:36,440 --> 00:30:41,270
draw about okay what's the substitute

00:30:38,659 --> 00:30:42,590
for that I always say it is that one and

00:30:41,270 --> 00:30:45,409
then you will check in your store and

00:30:42,590 --> 00:30:48,830
say ok I receive it that's done there is

00:30:45,409 --> 00:30:51,080
nearly no network no bandwidth and there

00:30:48,830 --> 00:30:54,270
is a lot of space that is saved on

00:30:51,080 --> 00:30:57,450
either so

00:30:54,270 --> 00:30:57,450
[Music]

00:30:57,510 --> 00:31:06,310
yes what was the situation before if you

00:31:03,310 --> 00:31:08,550
have these standout environment and then

00:31:06,310 --> 00:31:11,800
okay from that you can build the X

00:31:08,550 --> 00:31:13,660
packages and then you build a tree okay

00:31:11,800 --> 00:31:15,820
you end up with three different packages

00:31:13,660 --> 00:31:17,260
in the end and then there is a very

00:31:15,820 --> 00:31:19,060
small change to the standard

00:31:17,260 --> 00:31:23,620
environments maybe it's not significant

00:31:19,060 --> 00:31:26,110
so he just I added an S in a comment in

00:31:23,620 --> 00:31:27,490
a bash script I nobody does that because

00:31:26,110 --> 00:31:31,870
we know that we will break a lot of

00:31:27,490 --> 00:31:33,370
stuff but it's not that important so I

00:31:31,870 --> 00:31:36,190
do the small change and I end up with a

00:31:33,370 --> 00:31:38,440
different set of packages with the

00:31:36,190 --> 00:31:41,680
content address storage I could do

00:31:38,440 --> 00:31:44,980
something like that okay I realize that

00:31:41,680 --> 00:31:47,230
okay STD end is exactly the same so I

00:31:44,980 --> 00:31:48,550
can deduce that all the package should

00:31:47,230 --> 00:31:50,860
be the same because they will be built

00:31:48,550 --> 00:31:52,900
from the from the same package all right

00:31:50,860 --> 00:31:54,910
there is no way they can change the real

00:31:52,900 --> 00:31:57,150
the actual input to this package is the

00:31:54,910 --> 00:31:57,150
same

00:32:00,230 --> 00:32:06,440
you build it and you look at the bytes

00:32:04,150 --> 00:32:09,490
and you say okay these are the same

00:32:06,440 --> 00:32:09,490
bytes it's the same package

00:32:13,080 --> 00:32:17,550
yep

00:32:15,490 --> 00:32:17,550
you

00:32:19,900 --> 00:32:23,700
needs to build it

00:32:21,990 --> 00:32:27,500
so there is no way I want that you need

00:32:23,700 --> 00:32:27,500
to build the package but once it built

00:32:31,460 --> 00:32:36,330
yeah I'm not changing the revision times

00:32:34,080 --> 00:32:40,649
you know basically changing the the

00:32:36,330 --> 00:32:43,590
built command or something like that but

00:32:40,649 --> 00:32:47,429
you may be surprised a lot of cases

00:32:43,590 --> 00:32:50,220
where this offense for example if you

00:32:47,429 --> 00:32:52,799
change DCC for example then GCC will

00:32:50,220 --> 00:32:54,809
rebuild your project but it may happen

00:32:52,799 --> 00:32:57,029
that's its exact same project that is

00:32:54,809 --> 00:32:58,590
built okay it's a new version of GCC but

00:32:57,029 --> 00:33:01,860
there is not much change in the bytecode

00:32:58,590 --> 00:33:04,710
is produced right so you may if that's

00:33:01,860 --> 00:33:05,010
kind of if you're more fun than you

00:33:04,710 --> 00:33:09,480
think

00:33:05,010 --> 00:33:12,059
but I must admit that I do not know now

00:33:09,480 --> 00:33:13,980
what's the actual impact of that so it

00:33:12,059 --> 00:33:17,630
would be nice to do some kind of impact

00:33:13,980 --> 00:33:17,630
analysis yes

00:33:43,140 --> 00:33:46,860
I'm happy that you asked the question

00:33:44,820 --> 00:33:51,150
because our you went to first of all

00:33:46,860 --> 00:33:55,200
that's the idea that's for the out pat

00:33:51,150 --> 00:33:58,200
yourself you need to strip that from the

00:33:55,200 --> 00:34:00,390
produced binary before asking them and

00:33:58,200 --> 00:34:02,580
this is the ash in which you will store

00:34:00,390 --> 00:34:09,390
your derivation okay then you can

00:34:02,580 --> 00:34:11,040
reinsert the out link yeah yes of course

00:34:09,390 --> 00:34:12,570
you need to do that and it's more

00:34:11,040 --> 00:34:14,850
complex than it looks like because often

00:34:12,570 --> 00:34:17,030
the out pads ends up in very strange

00:34:14,850 --> 00:34:19,919
location for example in a man page and

00:34:17,030 --> 00:34:22,350
that man page may be zipped so it may

00:34:19,919 --> 00:34:24,750
not be discovered by Nix build will it

00:34:22,350 --> 00:34:27,149
strip stuff and reinsert them so there

00:34:24,750 --> 00:34:30,169
is technicalities there that we need to

00:34:27,149 --> 00:34:30,169
think about

00:34:33,380 --> 00:34:40,500
yes it's linked to that of course so I

00:34:38,300 --> 00:34:44,070
mean it's interesting to see that okay

00:34:40,500 --> 00:34:46,649
let's let me change the derivation you

00:34:44,070 --> 00:34:48,630
know in some way that I'm sure cannot

00:34:46,649 --> 00:34:50,610
change the build some for example I

00:34:48,630 --> 00:34:53,100
could add a random variable to the

00:34:50,610 --> 00:34:55,620
environment that nobody should use right

00:34:53,100 --> 00:34:58,260
and if I'm not able to reproduce the

00:34:55,620 --> 00:35:00,540
exam say the exact same build there is a

00:34:58,260 --> 00:35:02,220
problem either which contain data

00:35:00,540 --> 00:35:05,400
storage detection or which

00:35:02,220 --> 00:35:12,130
reproducibility so it will maybe I

00:35:05,400 --> 00:35:14,190
helped to I lies yeah not stable package

00:35:12,130 --> 00:35:14,190
you

00:35:16,520 --> 00:35:22,160
okay so the main advantage is that you

00:35:18,470 --> 00:35:26,150
do not propagate change to the package

00:35:22,160 --> 00:35:29,690
you are able to better detect when the

00:35:26,150 --> 00:35:31,580
package is really the same as before so

00:35:29,690 --> 00:35:33,380
it means that you can do less compiling

00:35:31,580 --> 00:35:35,630
you do not need to compile all the

00:35:33,380 --> 00:35:38,960
dependent packets yes faster of this you

00:35:35,630 --> 00:35:43,369
don't need to download from I draw it is

00:35:38,960 --> 00:35:48,950
not too difficult to implement yeah not

00:35:43,369 --> 00:35:52,010
too difficult but I mean everything is

00:35:48,950 --> 00:35:55,760
in there we could do that with existing

00:35:52,010 --> 00:35:57,400
tools the real difficulty is with you

00:35:55,760 --> 00:36:02,000
know forward and backward compatibility

00:35:57,400 --> 00:36:03,830
if we do that then yes of course will

00:36:02,000 --> 00:36:05,570
change NICs in a major way so we need to

00:36:03,830 --> 00:36:08,660
investigate oh we can do that without

00:36:05,570 --> 00:36:10,100
breaking everything if we need if we

00:36:08,660 --> 00:36:12,290
break everything maybe we need to say

00:36:10,100 --> 00:36:15,080
okay this is very important yes you just

00:36:12,290 --> 00:36:18,080
went ages so okay let's break xn started

00:36:15,080 --> 00:36:20,150
getting over but I don't know yet so

00:36:18,080 --> 00:36:22,160
this is really a problem now with this

00:36:20,150 --> 00:36:28,190
ID that it's quite difficult to know

00:36:22,160 --> 00:36:30,680
what would be the real gain I would like

00:36:28,190 --> 00:36:34,600
to set up my own I draw and try to do

00:36:30,680 --> 00:36:39,580
tests with that but I mean it ask a huge

00:36:34,600 --> 00:36:43,560
computing power which I do not have yet

00:36:39,580 --> 00:36:43,560
maybe in two years for next next gun

00:36:44,280 --> 00:36:48,810
yes the reason why I was really

00:36:47,400 --> 00:36:51,660
interested in that is because I have

00:36:48,810 --> 00:36:55,589
this pull request that is now completely

00:36:51,660 --> 00:36:58,160
bit rotten but never mind I wanted to

00:36:55,589 --> 00:36:58,160
make

00:36:58,390 --> 00:37:02,410
standout environments that just trips

00:37:00,640 --> 00:37:04,869
everywhere everything everything that

00:37:02,410 --> 00:37:09,430
looks like an L F strip it's okay

00:37:04,869 --> 00:37:12,790
because we had issues like for exampie

00:37:09,430 --> 00:37:15,310
HP was storing libraries in very strange

00:37:12,790 --> 00:37:17,500
location we did not see that and so PHP

00:37:15,310 --> 00:37:20,520
was basically depending on DCC and I

00:37:17,500 --> 00:37:23,980
mean this was blowing the closure size

00:37:20,520 --> 00:37:25,540
for the story this was I mean this was

00:37:23,980 --> 00:37:28,780
there for so long that at some point

00:37:25,540 --> 00:37:32,830
Elco fixed the PHP stuff before I even

00:37:28,780 --> 00:37:35,350
merged this one it was easier to fix by

00:37:32,830 --> 00:37:37,540
hand that effective global the

00:37:35,350 --> 00:37:40,420
interesting part about this pull request

00:37:37,540 --> 00:37:41,040
is that for most packages it changes

00:37:40,420 --> 00:37:44,890
nothing

00:37:41,040 --> 00:37:46,480
okay and if the package changes then

00:37:44,890 --> 00:37:48,070
there was something that was not

00:37:46,480 --> 00:37:50,290
stripped before and the twist trip after

00:37:48,070 --> 00:37:53,140
so it's interesting to look into that

00:37:50,290 --> 00:37:55,000
package okay and even the ability to

00:37:53,140 --> 00:37:58,360
detect when package are exactly the same

00:37:55,000 --> 00:38:00,970
would help with refactorings okay you

00:37:58,360 --> 00:38:03,490
refactor something you build everything

00:38:00,970 --> 00:38:05,440
and you see what has changed this gives

00:38:03,490 --> 00:38:07,359
you some information about did I do

00:38:05,440 --> 00:38:09,369
something wrong is something that I

00:38:07,359 --> 00:38:10,420
really intended in the refactoring even

00:38:09,369 --> 00:38:13,260
though the refactoring should just

00:38:10,420 --> 00:38:13,260
listening as this

00:38:16,109 --> 00:38:22,049
okay so now we want to bridge the gap

00:38:19,769 --> 00:38:25,559
between all the ideas if we do this

00:38:22,049 --> 00:38:29,489
contain data storage and caching inside

00:38:25,559 --> 00:38:31,819
a build system that becomes quite

00:38:29,489 --> 00:38:31,819
complex

00:38:32,050 --> 00:38:37,950
[Music]

00:38:34,040 --> 00:38:40,410
if you cash buildin it becomes much less

00:38:37,950 --> 00:38:43,200
it may become less stable or it may

00:38:40,410 --> 00:38:44,700
become more stable so you have a lot of

00:38:43,200 --> 00:38:47,490
interactions in there that needs to be

00:38:44,700 --> 00:38:50,400
investigated and I think it would be fun

00:38:47,490 --> 00:38:51,300
that's maybe a bit complex so let's do

00:38:50,400 --> 00:38:54,359
one step at a time

00:38:51,300 --> 00:38:58,050
and it would help like we said before to

00:38:54,359 --> 00:39:00,960
to catch unstable bills right if the

00:38:58,050 --> 00:39:02,250
content the content ash changes who were

00:39:00,960 --> 00:39:05,700
friend and there is something that's not

00:39:02,250 --> 00:39:09,410
stable in the builds okay so I presented

00:39:05,700 --> 00:39:11,730
these three ideas of improvement UNIX I

00:39:09,410 --> 00:39:13,470
when I started I D feeling that you

00:39:11,730 --> 00:39:14,700
could not change Nix but it's not true

00:39:13,470 --> 00:39:16,619
there are a lot of things that we can

00:39:14,700 --> 00:39:18,610
improve and we can make it more

00:39:16,619 --> 00:39:20,500
user-friendly

00:39:18,610 --> 00:39:23,860
about kissing builds that's something

00:39:20,500 --> 00:39:25,480
that I'm working on for my PhD the

00:39:23,860 --> 00:39:27,610
content that we storage is something for

00:39:25,480 --> 00:39:29,140
which division RC so if you want to work

00:39:27,610 --> 00:39:32,290
on that you're welcome to contact what

00:39:29,140 --> 00:39:36,490
mountains and we can do it together

00:39:32,290 --> 00:39:38,860
the Nick shellacque with the zipper is

00:39:36,490 --> 00:39:41,890
something that's not being implemented

00:39:38,860 --> 00:39:47,940
all but I mean I would be happy to start

00:39:41,890 --> 00:39:47,940
that with someone and that's it

00:39:48,380 --> 00:40:03,700
[Applause]

00:39:59,970 --> 00:40:14,060
the behind the pillar over there over

00:40:03,700 --> 00:40:15,569
there ha

00:40:14,060 --> 00:40:17,770
[Music]

00:40:15,569 --> 00:40:19,540
the Philly thing is that I have been

00:40:17,770 --> 00:40:22,359
compiling build system to other build

00:40:19,540 --> 00:40:28,690
systems for two months now but not

00:40:22,359 --> 00:40:31,960
tunics I guess what I want to do is

00:40:28,690 --> 00:40:33,339
basically the same right because I asked

00:40:31,960 --> 00:40:36,000
the build system to just say what he

00:40:33,339 --> 00:40:39,280
wants to build and pass it to NYX build

00:40:36,000 --> 00:40:41,200
so he is basically exposing all he wants

00:40:39,280 --> 00:40:44,650
to do so I would like the build system

00:40:41,200 --> 00:40:47,020
to not compile tunics but to compile to

00:40:44,650 --> 00:40:49,839
a standard protocol that could be used

00:40:47,020 --> 00:40:52,390
for interpreting their operation with

00:40:49,839 --> 00:40:53,619
any other tools all right I would like

00:40:52,390 --> 00:40:55,990
something that's more global than just

00:40:53,619 --> 00:41:00,250
okay these tunics these two these two

00:40:55,990 --> 00:41:03,810
that etc I wants just one common

00:41:00,250 --> 00:41:03,810
protocol to build stuff

00:41:05,200 --> 00:41:11,110

YouTube URL: https://www.youtube.com/watch?v=AED-dgCa9GU


