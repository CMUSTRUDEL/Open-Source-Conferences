Title: FreeCodeCamp Vienna, Trending Webperformance Practices, February 2020
Publication date: 2020-02-07
Playlist: FreeCodeCamp Vienna
Description: 
	Talk by Annette Aubell and Tijana Maksimovic
In our shared pursuit to push the web to do more, we're running into a common problem: PERFORMANCE. How do we actually know where we stand in terms of performance, and what are common performance bottlenecks? Is it expensive JavaScript, heavy images, slow web font delivery or sluggish rendering? Is it worth exploring priority-hints, code-splitting and resource hints? And, most importantly, where do we even start improving performance and what web resources can help us on this journey? After visiting the recently held performance workshop of Harry Roberts in Linz, this presentation should help giving answers to those emerging questions concerning best Webperformance practices of 2019.
Captions: 
	00:00:00,030 --> 00:00:05,000
hello everybody I welcome you to my talk

00:00:03,330 --> 00:00:08,069
today about trending web performance

00:00:05,000 --> 00:00:11,309
practices my partner-in-crime Shoshana

00:00:08,069 --> 00:00:14,630
is unfortunately sick today so she

00:00:11,309 --> 00:00:17,310
planned to do a practical part today but

00:00:14,630 --> 00:00:19,590
sir today I will tell you a lot of

00:00:17,310 --> 00:00:21,720
theoretical stuff only about trending

00:00:19,590 --> 00:00:23,490
web performance practices but you will

00:00:21,720 --> 00:00:26,119
not leave this room without knowing

00:00:23,490 --> 00:00:29,429
anything new about it so don't be afraid

00:00:26,119 --> 00:00:30,269
how do I come to do a talk about web

00:00:29,429 --> 00:00:33,270
performance

00:00:30,269 --> 00:00:36,750
I was with Gianna who is also working at

00:00:33,270 --> 00:00:40,469
Epcot with me at the script 19 previous

00:00:36,750 --> 00:00:44,370
November and one day prior there was a

00:00:40,469 --> 00:00:46,410
full-day workshop with Harry Roberts who

00:00:44,370 --> 00:00:50,820
is also called a Twitter css3 so three

00:00:46,410 --> 00:00:53,850
does anyone know Harry Roberts is quite

00:00:50,820 --> 00:00:57,059
some people he's a rep performance

00:00:53,850 --> 00:01:00,809
expert overall and he taught us a full

00:00:57,059 --> 00:01:03,750
day just web performance it was really

00:01:00,809 --> 00:01:06,210
interesting but I thought I want to give

00:01:03,750 --> 00:01:10,439
in a small format what I learned in this

00:01:06,210 --> 00:01:13,080
meet up to you guys so overall what is

00:01:10,439 --> 00:01:15,150
first importance of performance I think

00:01:13,080 --> 00:01:17,490
every one of you know why why

00:01:15,150 --> 00:01:20,070
performance is important because we all

00:01:17,490 --> 00:01:24,509
know the struggle of a very slow website

00:01:20,070 --> 00:01:26,400
right and we have to see web performance

00:01:24,509 --> 00:01:29,310
also from the business side of the

00:01:26,400 --> 00:01:32,009
spectrum because when we look at WPIAL

00:01:29,310 --> 00:01:34,350
stats come you can see case studies and

00:01:32,009 --> 00:01:36,570
experiments demonstrating the impact of

00:01:34,350 --> 00:01:39,329
web performance optimization and user

00:01:36,570 --> 00:01:42,479
experience and business metrics and here

00:01:39,329 --> 00:01:46,259
you can see quite some nice information

00:01:42,479 --> 00:01:48,329
out there what some popular companies

00:01:46,259 --> 00:01:51,720
achieved with investing in performance

00:01:48,329 --> 00:01:53,460
for example Netflix are 43 percent

00:01:51,720 --> 00:01:57,570
decrease in the bandwidth bill after

00:01:53,460 --> 00:02:01,020
turning on tea sip alone or GQ cut load

00:01:57,570 --> 00:02:03,299
time by 80% and so on 80% increase in

00:02:01,020 --> 00:02:06,899
traffic median time spent on the site

00:02:03,299 --> 00:02:10,220
also increased by 32% so overall it

00:02:06,899 --> 00:02:12,959
really pays off to invest in performance

00:02:10,220 --> 00:02:13,740
what does performance have to do with

00:02:12,959 --> 00:02:17,520
morality

00:02:13,740 --> 00:02:20,910
well of course we can access websites

00:02:17,520 --> 00:02:24,090
pretty good but for example an on a

00:02:20,910 --> 00:02:26,250
person in India tells us another story

00:02:24,090 --> 00:02:28,560
for example his parents only consumed

00:02:26,250 --> 00:02:31,530
Internet food or smartphone and he

00:02:28,560 --> 00:02:34,410
himself has a lock top and connects via

00:02:31,530 --> 00:02:37,530
Wi-Fi to the Internet and opening Gmail

00:02:34,410 --> 00:02:39,780
in basic HTML takes 30 seconds to a

00:02:37,530 --> 00:02:43,950
minute to loads and this is unexpectable

00:02:39,780 --> 00:02:45,990
so and he says Google also optimizes a

00:02:43,950 --> 00:02:48,990
lot for slow connections so that

00:02:45,990 --> 00:02:52,620
definitely helps him but 30 seconds to 1

00:02:48,990 --> 00:02:55,260
minute is crazy so when we develop a

00:02:52,620 --> 00:02:57,630
website or a web application we have to

00:02:55,260 --> 00:03:02,730
think for which target audience we built

00:02:57,630 --> 00:03:04,860
this website and here you have a page

00:03:02,730 --> 00:03:07,590
where you can see that the web isn't

00:03:04,860 --> 00:03:12,780
experienced the same way everywhere and

00:03:07,590 --> 00:03:15,360
I want to show ok can i yeah I want to

00:03:12,780 --> 00:03:18,030
show you two very different countries

00:03:15,360 --> 00:03:19,560
one extreme is Afghanistan you see for

00:03:18,030 --> 00:03:25,140
example the fixed broadband

00:03:19,560 --> 00:03:27,090
subscriptions is around 1,000 1,500 here

00:03:25,140 --> 00:03:30,450
you can see the fixed broadband

00:03:27,090 --> 00:03:32,970
subscriptions in Austria is 2.4 million

00:03:30,450 --> 00:03:36,570
there is quite some interesting data

00:03:32,970 --> 00:03:40,790
it's insane how much difference there is

00:03:36,570 --> 00:03:40,790
between countries around the world so

00:03:42,950 --> 00:03:50,190
perfect so how do we actually measure

00:03:45,810 --> 00:03:52,320
performance you shouldn't think about

00:03:50,190 --> 00:03:54,870
page weight when it comes to performance

00:03:52,320 --> 00:03:57,660
because Netflix or Facebook are really

00:03:54,870 --> 00:03:59,610
big websites but overall they don't have

00:03:57,660 --> 00:04:01,710
really problems or perform with

00:03:59,610 --> 00:04:03,930
performance just because they have a big

00:04:01,710 --> 00:04:06,840
page weight overall the number of

00:04:03,930 --> 00:04:09,930
requests are also not really a good

00:04:06,840 --> 00:04:12,060
metric to measure performance we come

00:04:09,930 --> 00:04:14,700
closer when you think when is a web page

00:04:12,060 --> 00:04:16,770
actually for me fully loaded but to be

00:04:14,700 --> 00:04:19,049
honest would you be happy that after

00:04:16,770 --> 00:04:21,299
eight seconds you see all of a sudden

00:04:19,049 --> 00:04:24,000
the whole web page loading I don't think

00:04:21,299 --> 00:04:26,370
so a good metric would be the speed

00:04:24,000 --> 00:04:27,660
index this means how fast was the user

00:04:26,370 --> 00:04:30,570
experience overall

00:04:27,660 --> 00:04:32,760
this means when can I first interact

00:04:30,570 --> 00:04:35,910
with the website or see stuff happening

00:04:32,760 --> 00:04:38,160
on the page you can see quite a nice

00:04:35,910 --> 00:04:40,170
difference here on the right side the

00:04:38,160 --> 00:04:43,230
user is happy because he sees already

00:04:40,170 --> 00:04:44,730
after around half a second that

00:04:43,230 --> 00:04:48,000
something is happening on the screen

00:04:44,730 --> 00:04:50,400
quite a lot but the left user has to

00:04:48,000 --> 00:04:52,800
wait two seconds until something is even

00:04:50,400 --> 00:04:56,400
appearing on the screen so that's quite

00:04:52,800 --> 00:04:58,260
interesting what tools did we use to

00:04:56,400 --> 00:04:59,220
measure performance during the workshop

00:04:58,260 --> 00:05:01,890
with Harry Roberts

00:04:59,220 --> 00:05:03,600
first I think everyone of you know in

00:05:01,890 --> 00:05:06,270
the chrome inspector the network

00:05:03,600 --> 00:05:08,220
performance and audit step and we used

00:05:06,270 --> 00:05:11,670
like four five hours straight the

00:05:08,220 --> 00:05:13,320
webpagetest.org tool where we analyzed a

00:05:11,670 --> 00:05:16,350
thing for every person who was in the

00:05:13,320 --> 00:05:18,780
webshop like 30 minutes trades or

00:05:16,350 --> 00:05:20,730
websites but this is the part which

00:05:18,780 --> 00:05:24,050
Tianna would have showed you so I will

00:05:20,730 --> 00:05:27,060
not go into detail how webpagetest works

00:05:24,050 --> 00:05:29,340
when it comes to performance we have to

00:05:27,060 --> 00:05:32,610
think about network performance so I

00:05:29,340 --> 00:05:36,210
will show you how you measure weapon but

00:05:32,610 --> 00:05:38,400
how you can measure network performance

00:05:36,210 --> 00:05:40,950
well we're bound by physical and

00:05:38,400 --> 00:05:43,740
fundamental constraints there is little

00:05:40,950 --> 00:05:45,440
we can do about constraints that happen

00:05:43,740 --> 00:05:48,150
when it comes to network performance

00:05:45,440 --> 00:05:51,540
nonetheless there are some possibilities

00:05:48,150 --> 00:05:53,970
to justify the performance to our needs

00:05:51,540 --> 00:05:55,770
the which are constraints which hinder

00:05:53,970 --> 00:05:56,340
us when it comes to web performance over

00:05:55,770 --> 00:05:59,490
the network

00:05:56,340 --> 00:06:02,160
first there is latency which means how

00:05:59,490 --> 00:06:04,320
fast can a request go to the server and

00:06:02,160 --> 00:06:06,630
the server respond back to the user and

00:06:04,320 --> 00:06:08,520
then there is bandwidth which means how

00:06:06,630 --> 00:06:12,030
much data can we carry on the whole

00:06:08,520 --> 00:06:13,950
journey and quite interesting thing for

00:06:12,030 --> 00:06:15,960
me to know is that bandwidth makes

00:06:13,950 --> 00:06:19,110
little to no difference for the average

00:06:15,960 --> 00:06:21,360
Internet user and at slow times are slow

00:06:19,110 --> 00:06:25,110
load times are most strongly related to

00:06:21,360 --> 00:06:26,880
network delays a Cal latency bandwidth

00:06:25,110 --> 00:06:29,880
just matters when you really have to

00:06:26,880 --> 00:06:32,040
load very big pictures or stream videos

00:06:29,880 --> 00:06:35,400
but it doesn't matter when it comes to a

00:06:32,040 --> 00:06:37,890
small amount of CSS or JavaScript their

00:06:35,400 --> 00:06:39,260
latency is a bigger factor when it comes

00:06:37,890 --> 00:06:42,230
to performance

00:06:39,260 --> 00:06:44,960
and we sometimes think of the latency

00:06:42,230 --> 00:06:48,050
what happens when a request goes to the

00:06:44,960 --> 00:06:52,370
server and a response comes back overall

00:06:48,050 --> 00:06:54,830
you can see it's quite it's quite a

00:06:52,370 --> 00:06:59,890
journey because first you have to do a

00:06:54,830 --> 00:07:03,290
DNS lookup where you map domain name to

00:06:59,890 --> 00:07:05,810
IP address then there could be a TLS

00:07:03,290 --> 00:07:08,150
negotiation for a secure connection and

00:07:05,810 --> 00:07:12,530
you could do domain sharding meaning

00:07:08,150 --> 00:07:14,930
connecting to more servers and you see

00:07:12,530 --> 00:07:18,560
that each part of this network

00:07:14,930 --> 00:07:22,570
connection needs some time and this is

00:07:18,560 --> 00:07:22,570
time you need actually for performance

00:07:23,980 --> 00:07:30,050
what I really liked about Harry Roberts

00:07:26,720 --> 00:07:32,780
workshop was he in detail explained to

00:07:30,050 --> 00:07:35,870
us the difference between HTTP 1 vs.

00:07:32,780 --> 00:07:37,970
HTTP 2 how much of you do you think you

00:07:35,870 --> 00:07:41,900
know about the difference does anybody

00:07:37,970 --> 00:07:42,760
know ok so we'll tell you something

00:07:41,900 --> 00:07:46,460
about it

00:07:42,760 --> 00:07:48,650
HTTP is overall a protocol which changes

00:07:46,460 --> 00:07:51,100
information between a client computer

00:07:48,650 --> 00:07:56,660
and the local or remote web server and

00:07:51,100 --> 00:07:59,030
with HTTP 1.1 it was possible to send

00:07:56,660 --> 00:08:02,180
multiple requests over one TCP

00:07:59,030 --> 00:08:06,680
connection but it was limited to 6 to 8

00:08:02,180 --> 00:08:09,470
requests HTTP 1.1 was also able to do

00:08:06,680 --> 00:08:13,880
pipelining and cache control when it

00:08:09,470 --> 00:08:16,760
comes to HTTP 2 it requires HTTPS and

00:08:13,880 --> 00:08:20,030
it's also backward compatible to HTTP

00:08:16,760 --> 00:08:22,550
1.1 this means it can everything that

00:08:20,030 --> 00:08:25,250
basically this HTTP version can also do

00:08:22,550 --> 00:08:27,650
but it comes with a lot of improvements

00:08:25,250 --> 00:08:29,750
in speed first there is the compression

00:08:27,650 --> 00:08:32,450
of request headers then you have the

00:08:29,750 --> 00:08:34,430
server push then there's the request

00:08:32,450 --> 00:08:36,890
multiplexing over a single TCP

00:08:34,430 --> 00:08:39,710
connection and it has also better

00:08:36,890 --> 00:08:42,800
caching strategies I know a lot of weird

00:08:39,710 --> 00:08:45,710
stuff happening what does it mean so

00:08:42,800 --> 00:08:49,190
when you use server push normally when

00:08:45,710 --> 00:08:51,380
you want to request the index.html file

00:08:49,190 --> 00:08:52,010
you get this from the server back and

00:08:51,380 --> 00:08:54,710
when

00:08:52,010 --> 00:08:57,920
example just ICS us is also in the

00:08:54,710 --> 00:09:00,260
index.html file the browser first has to

00:08:57,920 --> 00:09:02,230
parse this document and then when it

00:09:00,260 --> 00:09:04,730
finds the star CSS file

00:09:02,230 --> 00:09:08,210
sends another request to the browser

00:09:04,730 --> 00:09:10,280
when you actually use server push it

00:09:08,210 --> 00:09:12,590
doesn't have to take the second round

00:09:10,280 --> 00:09:16,400
trip time because you can just say

00:09:12,590 --> 00:09:19,700
please push also the style CSS which is

00:09:16,400 --> 00:09:23,120
included in the index.html with the

00:09:19,700 --> 00:09:25,940
first response to the browser then you

00:09:23,120 --> 00:09:29,900
get both without doing a second request

00:09:25,940 --> 00:09:32,120
so this is quite practical also I talked

00:09:29,900 --> 00:09:36,020
about request multiplexing and here you

00:09:32,120 --> 00:09:39,790
can see what this actually is with HTTP

00:09:36,020 --> 00:09:42,590
1.1 you had the problem that when you

00:09:39,790 --> 00:09:46,400
make a TCP connection you can just

00:09:42,590 --> 00:09:48,350
download in parallel six connections at

00:09:46,400 --> 00:09:51,500
a time you had to wait until they were

00:09:48,350 --> 00:09:53,780
all done and then you had to make

00:09:51,500 --> 00:09:56,390
another TCP connection and though the

00:09:53,780 --> 00:10:03,320
next six resources and so on and so on

00:09:56,390 --> 00:10:06,560
and what HTTP 2.2 at HTTP 2 makes better

00:10:03,320 --> 00:10:08,420
is that you can reduce additional

00:10:06,560 --> 00:10:11,270
round-trip time and make your website

00:10:08,420 --> 00:10:14,990
load faster because you can just have to

00:10:11,270 --> 00:10:17,690
connect one time per TCP and then can

00:10:14,990 --> 00:10:24,340
load can request all resources you want

00:10:17,690 --> 00:10:27,500
at one time this is really a nice URL or

00:10:24,340 --> 00:10:28,940
you find here a lot of resources when it

00:10:27,500 --> 00:10:31,310
comes to high performance browser

00:10:28,940 --> 00:10:33,350
networking I can really recommend when

00:10:31,310 --> 00:10:35,540
you're interested in network performance

00:10:33,350 --> 00:10:39,410
that you take a look at it it's really

00:10:35,540 --> 00:10:41,990
interesting so next would be render

00:10:39,410 --> 00:10:44,510
blocking assets some assets block

00:10:41,990 --> 00:10:47,840
rendering means the users see nothing

00:10:44,510 --> 00:10:49,850
until all these resources arrive this

00:10:47,840 --> 00:10:52,700
means we need to get these assets over

00:10:49,850 --> 00:10:54,830
the wire immediately so to make the

00:10:52,700 --> 00:10:57,140
performance faster please check your

00:10:54,830 --> 00:11:00,530
needed resources eliminate what you

00:10:57,140 --> 00:11:02,780
don't need and mark resources for

00:11:00,530 --> 00:11:04,880
example your childhood as async or

00:11:02,780 --> 00:11:07,399
increase their priority

00:11:04,880 --> 00:11:10,819
what our render blocking resources first

00:11:07,399 --> 00:11:13,519
we have HTML and CSS so it's important

00:11:10,819 --> 00:11:16,190
that you optimize these JavaScript is

00:11:13,519 --> 00:11:18,170
also render blocking but it's not render

00:11:16,190 --> 00:11:20,389
blocking when you mark them as async or

00:11:18,170 --> 00:11:24,519
defer scripts this is really important

00:11:20,389 --> 00:11:28,370
and not blocking our images and fonts

00:11:24,519 --> 00:11:31,250
here you can see why HTML and CSS is

00:11:28,370 --> 00:11:34,279
indeed render blocking because when you

00:11:31,250 --> 00:11:36,920
wouldn't when you would start rendering

00:11:34,279 --> 00:11:38,959
without loading to HTML it would nothing

00:11:36,920 --> 00:11:41,449
be on your screen you need a Dom to

00:11:38,959 --> 00:11:46,819
render so you need to HTML beforehand

00:11:41,449 --> 00:11:48,529
and also we've CSS you when you when you

00:11:46,819 --> 00:11:52,910
start rendering the page and you don't

00:11:48,529 --> 00:11:55,130
have CSS but the HTML you would you

00:11:52,910 --> 00:11:58,490
would have such a page which you

00:11:55,130 --> 00:12:01,250
couldn't really use so how do I identify

00:11:58,490 --> 00:12:04,190
critical resources there is a coverage

00:12:01,250 --> 00:12:07,730
tab of the dev tools available and you

00:12:04,190 --> 00:12:10,009
can see here that the read resources are

00:12:07,730 --> 00:12:12,920
stars that apply to the content not

00:12:10,009 --> 00:12:15,319
immediately visible and code not being

00:12:12,920 --> 00:12:17,689
used in the pages core functionality and

00:12:15,319 --> 00:12:20,269
the green stuff are assets that are

00:12:17,689 --> 00:12:23,389
required for the first paint so you can

00:12:20,269 --> 00:12:28,310
look up which resources you could maybe

00:12:23,389 --> 00:12:30,310
load asynchronously now I want to also

00:12:28,310 --> 00:12:32,899
talk about free seas because

00:12:30,310 --> 00:12:35,029
concatenation compression and caching

00:12:32,899 --> 00:12:40,250
I'm also very important when it comes to

00:12:35,029 --> 00:12:42,889
web performance concatenation and was

00:12:40,250 --> 00:12:46,130
used to avoid a parallelization issue

00:12:42,889 --> 00:12:48,380
with HTTP 1 and this means to transport

00:12:46,130 --> 00:12:51,680
as few files as possible over the wire

00:12:48,380 --> 00:12:53,649
this means to concatenate your files but

00:12:51,680 --> 00:12:57,529
actually this should be avoided with

00:12:53,649 --> 00:13:00,350
HTTP 2 and I can give you the tip to

00:12:57,529 --> 00:13:02,750
break your files into high and low rate

00:13:00,350 --> 00:13:05,000
of change bundles because when you have

00:13:02,750 --> 00:13:07,399
low rate of change bundles they don't

00:13:05,000 --> 00:13:11,630
change frequently and you can cache

00:13:07,399 --> 00:13:14,899
those bundles better because they don't

00:13:11,630 --> 00:13:17,810
change large signifiers get a whole

00:13:14,899 --> 00:13:23,930
better compression than many small ones

00:13:17,810 --> 00:13:28,840
and overall you shoot with HTTP to send

00:13:23,930 --> 00:13:31,520
six to ten packages over to the server

00:13:28,840 --> 00:13:33,200
then compression is also a really

00:13:31,520 --> 00:13:35,839
interesting part when it comes to

00:13:33,200 --> 00:13:40,070
performance compression saves all a lot

00:13:35,839 --> 00:13:42,830
of data with little effort you have to

00:13:40,070 --> 00:13:45,080
take into consideration that you should

00:13:42,830 --> 00:13:47,120
just compress txt virus and not binary

00:13:45,080 --> 00:13:50,330
files because Spiner e files like images

00:13:47,120 --> 00:13:52,580
are already compressed types of the

00:13:50,330 --> 00:13:54,740
compression of our example gzip very

00:13:52,580 --> 00:13:56,630
well-known then there is a new one

00:13:54,740 --> 00:13:59,750
called broadly it's a new open source

00:13:56,630 --> 00:14:02,560
lossless data format and it overall gets

00:13:59,750 --> 00:14:04,970
you better results than cheese sip

00:14:02,560 --> 00:14:08,690
especially when it comes to CSS

00:14:04,970 --> 00:14:10,820
JavaScript and HTML files but you

00:14:08,690 --> 00:14:13,660
shouldn't use it too often because it

00:14:10,820 --> 00:14:17,540
has a lower compression speed and gzip

00:14:13,660 --> 00:14:19,339
and then there is caching caching stop

00:14:17,540 --> 00:14:21,740
the client having to go back to the

00:14:19,339 --> 00:14:23,960
server and overall the best request is

00:14:21,740 --> 00:14:27,440
the one that doesn't happen so don't

00:14:23,960 --> 00:14:29,120
rely on caching make use of it but don't

00:14:27,440 --> 00:14:32,030
assume it's always on your side

00:14:29,120 --> 00:14:34,700
why because devices just have finished

00:14:32,030 --> 00:14:36,500
storage limit and browser storing things

00:14:34,700 --> 00:14:41,180
from the cache whenever they feel like

00:14:36,500 --> 00:14:44,240
it really interesting for me was as

00:14:41,180 --> 00:14:46,100
Harry Roberts told us about resource

00:14:44,240 --> 00:14:47,750
hints who have you actually heard about

00:14:46,100 --> 00:14:50,780
resource hints when it comes to

00:14:47,750 --> 00:14:53,720
performance it actually looked like this

00:14:50,780 --> 00:14:56,839
also in our workshop so don't worry

00:14:53,720 --> 00:14:59,089
about it resource hints is a way to tell

00:14:56,839 --> 00:14:59,600
a browser what's likely to happen in the

00:14:59,089 --> 00:15:02,600
future

00:14:59,600 --> 00:15:05,300
well what resource you will get likely

00:15:02,600 --> 00:15:07,610
in the future browsers can factor that

00:15:05,300 --> 00:15:10,089
into its choice for how it loads this

00:15:07,610 --> 00:15:12,860
resource and it's very easy to implement

00:15:10,089 --> 00:15:15,529
it's a single line addition to prompt

00:15:12,860 --> 00:15:18,020
only activity and all this resource int

00:15:15,529 --> 00:15:21,410
you see down here I use the rel

00:15:18,020 --> 00:15:24,500
attribute of the link element and I want

00:15:21,410 --> 00:15:27,920
to go more in detail just at the pre

00:15:24,500 --> 00:15:30,170
loading event resource hint because it

00:15:27,920 --> 00:15:30,810
would take another presentation to go

00:15:30,170 --> 00:15:33,810
into T

00:15:30,810 --> 00:15:35,820
of all of them so when it comes to pre

00:15:33,810 --> 00:15:38,130
loading this tells the browser abour

00:15:35,820 --> 00:15:40,800
about an important asset without

00:15:38,130 --> 00:15:42,720
delaying the page onload event that

00:15:40,800 --> 00:15:45,090
means when you load a resource with

00:15:42,720 --> 00:15:48,210
preload it does it does not render

00:15:45,090 --> 00:15:50,279
blocking anymore that as attributes at

00:15:48,210 --> 00:15:52,830
the pre loading tag tells the browser

00:15:50,279 --> 00:15:56,370
what type of resource will be downloaded

00:15:52,830 --> 00:15:58,680
so it can be handled done correctly pre

00:15:56,370 --> 00:16:00,839
loading should be used for assets that

00:15:58,680 --> 00:16:03,600
are above the full content so for

00:16:00,839 --> 00:16:06,660
example images or fonts the user sees

00:16:03,600 --> 00:16:08,610
immediately and the resource is loaded

00:16:06,660 --> 00:16:09,450
with the same priority as it would

00:16:08,610 --> 00:16:12,480
otherwise

00:16:09,450 --> 00:16:14,940
but now the product the browser knows

00:16:12,480 --> 00:16:18,000
about it ahead of time allowing for the

00:16:14,940 --> 00:16:20,520
download to start earlier and when you

00:16:18,000 --> 00:16:22,230
preload things please also use this

00:16:20,520 --> 00:16:23,970
resource in your code because it would

00:16:22,230 --> 00:16:26,820
be extra performance if you wouldn't

00:16:23,970 --> 00:16:30,120
know if you wouldn't use this loaded

00:16:26,820 --> 00:16:32,430
resource for example you can see the

00:16:30,120 --> 00:16:34,800
difference of using preload here at the

00:16:32,430 --> 00:16:36,690
Shopify's page they switch to pre

00:16:34,800 --> 00:16:41,160
loading web fonts and saw a 50%

00:16:36,690 --> 00:16:43,680
improvement in time to text time to text

00:16:41,160 --> 00:16:45,900
paint on Chrome desktop and this removed

00:16:43,680 --> 00:16:48,600
the flesh of invisible text completely

00:16:45,900 --> 00:16:52,650
as you can see it's rather easy to

00:16:48,600 --> 00:16:54,660
implement but I think they also did pre

00:16:52,650 --> 00:16:58,740
load their images they had above the

00:16:54,660 --> 00:17:00,420
fold then there is another quite

00:16:58,740 --> 00:17:03,990
interesting thing I didn't know about

00:17:00,420 --> 00:17:08,160
it's called priority hints and priority

00:17:03,990 --> 00:17:11,280
hints set the importance of a resource

00:17:08,160 --> 00:17:13,620
to prioritize downloading it sooner or

00:17:11,280 --> 00:17:15,870
later so you have more flexibility by

00:17:13,620 --> 00:17:18,179
telling please give this important slow

00:17:15,870 --> 00:17:21,000
or please give this resource important

00:17:18,179 --> 00:17:22,980
high and currently web developers have

00:17:21,000 --> 00:17:25,620
very little control over the importance

00:17:22,980 --> 00:17:27,959
of loaded resources other than speeding

00:17:25,620 --> 00:17:29,150
up the discovery by using pre loads like

00:17:27,959 --> 00:17:31,560
I told you

00:17:29,150 --> 00:17:34,230
priorities depend also on the type of

00:17:31,560 --> 00:17:36,450
resource your load for example script

00:17:34,230 --> 00:17:39,510
will load faster than an image which is

00:17:36,450 --> 00:17:41,460
not render blocking etc and the location

00:17:39,510 --> 00:17:44,430
of the reference in the document and

00:17:41,460 --> 00:17:46,740
this priority hints were

00:17:44,430 --> 00:17:49,560
image tax link text and the fetch

00:17:46,740 --> 00:17:51,680
functionality of JavaScript this looks

00:17:49,560 --> 00:17:55,080
like this for example when you include

00:17:51,680 --> 00:17:58,050
carousel you want to show of course the

00:17:55,080 --> 00:18:00,510
first picture to the user because this

00:17:58,050 --> 00:18:02,970
is what you immediately see so you give

00:18:00,510 --> 00:18:05,670
this importance high and the other wants

00:18:02,970 --> 00:18:08,910
an importance logo for example and here

00:18:05,670 --> 00:18:11,370
you see two different scripts and here

00:18:08,910 --> 00:18:14,070
the user wants to load the home page GS

00:18:11,370 --> 00:18:16,800
first and then afterwards the chat GS

00:18:14,070 --> 00:18:20,070
with the importance tag and you have to

00:18:16,800 --> 00:18:21,750
also see he tries to preload this asset

00:18:20,070 --> 00:18:25,110
a synchronously so it's not random

00:18:21,750 --> 00:18:26,640
blocking what do we do when it comes to

00:18:25,110 --> 00:18:30,000
CSS and performance

00:18:26,640 --> 00:18:31,800
we already know that CSS is one of your

00:18:30,000 --> 00:18:33,750
biggest performance bottlenecks why

00:18:31,800 --> 00:18:35,940
because it is render blocking like

00:18:33,750 --> 00:18:37,860
you're already set your page will only

00:18:35,940 --> 00:18:40,740
render as quickly as your slowest

00:18:37,860 --> 00:18:43,230
stylesheet overall so this means get

00:18:40,740 --> 00:18:46,650
your CSS over the wire as soon as

00:18:43,230 --> 00:18:48,540
possible means just send as few fast as

00:18:46,650 --> 00:18:51,330
possible they should be as small as

00:18:48,540 --> 00:18:54,150
possible and the browser gives over all

00:18:51,330 --> 00:18:58,170
the CSS already a high priority leave it

00:18:54,150 --> 00:19:01,080
by that our real good tip is to identify

00:18:58,170 --> 00:19:03,540
all of the stars needed for start render

00:19:01,080 --> 00:19:05,220
which happens above the fold inline them

00:19:03,540 --> 00:19:07,830
in style tags in the head of your

00:19:05,220 --> 00:19:09,690
document and a synchronously load the

00:19:07,830 --> 00:19:11,850
remaining style sheets off of the

00:19:09,690 --> 00:19:15,300
critical path you want to make this

00:19:11,850 --> 00:19:17,160
especially with HTTP 1.1 because you

00:19:15,300 --> 00:19:23,130
don't have the server push which helps

00:19:17,160 --> 00:19:26,430
you another interesting function how you

00:19:23,130 --> 00:19:29,370
can load your CSS asynchronously as with

00:19:26,430 --> 00:19:31,650
media types you can split those into a

00:19:29,370 --> 00:19:33,900
different files organized by those media

00:19:31,650 --> 00:19:36,960
queries and the browser will still

00:19:33,900 --> 00:19:39,090
download all the CSS files but it will

00:19:36,960 --> 00:19:41,370
only be block rendering and fast needed

00:19:39,090 --> 00:19:43,710
to fulfill the current context in a

00:19:41,370 --> 00:19:47,910
current context is the context which you

00:19:43,710 --> 00:19:50,820
write into the media attribute and there

00:19:47,910 --> 00:19:53,280
is also a really interesting hack how

00:19:50,820 --> 00:19:56,040
you can load CSS s infamously in the

00:19:53,280 --> 00:19:58,170
whole document that you can see here you

00:19:56,040 --> 00:20:01,710
give it a really strange

00:19:58,170 --> 00:20:04,010
media query that doesn't exist but it

00:20:01,710 --> 00:20:06,540
will likely set download there's fires

00:20:04,010 --> 00:20:11,190
nonetheless and at their own load

00:20:06,540 --> 00:20:14,310
attribute you said this media to all how

00:20:11,190 --> 00:20:16,740
do we deal with JavaScript JavaScript is

00:20:14,310 --> 00:20:19,980
also like CSS a very expensive part of

00:20:16,740 --> 00:20:22,440
our site our roll the user does not only

00:20:19,980 --> 00:20:25,110
want to see the UI fast we also want to

00:20:22,440 --> 00:20:27,990
interact with it fast and I think we all

00:20:25,110 --> 00:20:30,030
know the problem when javascript is

00:20:27,990 --> 00:20:34,430
blocking the main thread and nothing

00:20:30,030 --> 00:20:37,500
else happens on it so although there is

00:20:34,430 --> 00:20:39,570
more there are more problems going on

00:20:37,500 --> 00:20:41,730
with the download and execution time

00:20:39,570 --> 00:20:45,090
there's other primary bottlenecks when

00:20:41,730 --> 00:20:48,870
it comes to JavaScript parsing time is

00:20:45,090 --> 00:20:52,260
pretty good in over all the browsers you

00:20:48,870 --> 00:20:54,900
should use async and defer scripts those

00:20:52,260 --> 00:20:59,640
get parsed on a separate thread and you

00:20:54,900 --> 00:21:02,670
can when you write async and defer you

00:20:59,640 --> 00:21:04,260
can load them asynchronously in the

00:21:02,670 --> 00:21:09,270
background so your javascript is not

00:21:04,260 --> 00:21:12,420
blocking the fret to see how this

00:21:09,270 --> 00:21:14,760
actually looks like when HTML is

00:21:12,420 --> 00:21:18,840
rendering you see when you include a

00:21:14,760 --> 00:21:21,540
regular script file your HTML is parsing

00:21:18,840 --> 00:21:24,660
and all of a sudden your javascript is

00:21:21,540 --> 00:21:26,790
downloading and this blocks HTML from

00:21:24,660 --> 00:21:29,310
rendering and also to executing

00:21:26,790 --> 00:21:31,260
executing of javascript is blocking the

00:21:29,310 --> 00:21:34,110
rendering of your chava script this is a

00:21:31,260 --> 00:21:36,570
problem then when you include your

00:21:34,110 --> 00:21:38,940
script asynchronously you can see that

00:21:36,570 --> 00:21:41,520
the download happens parallel to the

00:21:38,940 --> 00:21:43,640
parsing of your HTML this is a good

00:21:41,520 --> 00:21:46,950
thing but when it's finished downloading

00:21:43,640 --> 00:21:50,220
it executes right on the moment and this

00:21:46,950 --> 00:21:53,340
also blocks your HTML from parsing and

00:21:50,220 --> 00:21:57,480
when you use this defer attribute you

00:21:53,340 --> 00:22:00,450
can see your JavaScript downloads in

00:21:57,480 --> 00:22:03,810
parallel to your HTML and after all your

00:22:00,450 --> 00:22:07,190
HTML got parsed your javascript is

00:22:03,810 --> 00:22:10,050
executing without blocking the

00:22:07,190 --> 00:22:12,150
connection so what are recommendations

00:22:10,050 --> 00:22:15,270
that Harry Roberts gave

00:22:12,150 --> 00:22:18,510
for handling JavaScript reduce overall

00:22:15,270 --> 00:22:20,850
how much JavaScript you ship only load

00:22:18,510 --> 00:22:23,940
resources the user needs for the current

00:22:20,850 --> 00:22:26,760
route avoid shipping large bundles and

00:22:23,940 --> 00:22:30,180
take advantage of HTTP to parallelize

00:22:26,760 --> 00:22:32,670
ation avoid overall also large inline

00:22:30,180 --> 00:22:34,620
scripts the code has to be parsed in the

00:22:32,670 --> 00:22:37,800
main thread and this takes performance

00:22:34,620 --> 00:22:41,220
time also like you said previously pooja

00:22:37,800 --> 00:22:44,190
is code that is not frequently changing

00:22:41,220 --> 00:22:46,500
into separate vendor bundles because you

00:22:44,190 --> 00:22:49,050
can get a lot of caching benefit right

00:22:46,500 --> 00:22:51,780
here and on mobile you'll want to ship

00:22:49,050 --> 00:22:55,670
overall less script because you have 4

00:22:51,780 --> 00:22:58,920
CPU and your latency is also quite bad

00:22:55,670 --> 00:23:01,740
which tools can I use to make a real big

00:22:58,920 --> 00:23:04,110
imports visible I think some of you

00:23:01,740 --> 00:23:07,620
maybe know about web pack analyzer I

00:23:04,110 --> 00:23:11,340
used it myself it's quite neat here you

00:23:07,620 --> 00:23:15,900
can see web pack analyze the thing that

00:23:11,340 --> 00:23:17,460
you use huge loaded load a sh TS bundle

00:23:15,900 --> 00:23:20,250
which you don't actually need all

00:23:17,460 --> 00:23:22,890
functionality of and when you use the

00:23:20,250 --> 00:23:26,580
low - web pack plug-in you can actually

00:23:22,890 --> 00:23:29,400
tree shape this huge bundle and just

00:23:26,580 --> 00:23:33,540
used functionality you actually need and

00:23:29,400 --> 00:23:36,390
import them on their own to sum up my

00:23:33,540 --> 00:23:38,880
presentation a lot of today's best

00:23:36,390 --> 00:23:40,440
practices will become anti-patterns in

00:23:38,880 --> 00:23:44,700
the future you saw it with the

00:23:40,440 --> 00:23:48,000
differences about HTTP 1 and HTTP 2 and

00:23:44,700 --> 00:23:51,300
this will help also with performance in

00:23:48,000 --> 00:23:53,640
the future and I can recommend you when

00:23:51,300 --> 00:23:55,560
you want to keep up to date and go in

00:23:53,640 --> 00:23:56,370
detail about web performance this

00:23:55,560 --> 00:23:58,680
resource

00:23:56,370 --> 00:24:00,930
Smashing Magazine does a great job at

00:23:58,680 --> 00:24:05,100
actualizing its front end performance

00:24:00,930 --> 00:24:08,940
checklists so thank you

00:24:05,100 --> 00:24:08,940

YouTube URL: https://www.youtube.com/watch?v=h_rZxSu1up8


