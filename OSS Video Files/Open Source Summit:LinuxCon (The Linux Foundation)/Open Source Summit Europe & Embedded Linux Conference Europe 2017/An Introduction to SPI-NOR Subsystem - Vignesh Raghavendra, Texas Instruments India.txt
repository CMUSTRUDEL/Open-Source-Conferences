Title: An Introduction to SPI-NOR Subsystem - Vignesh Raghavendra, Texas Instruments India
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	An Introduction to SPI-NOR Subsystem - Vignesh Raghavendra, Texas Instruments India

Modern day embedded systems have dedicated SPI controllers to support NOR flashes. They have many hardware level features to increase the ease and efficiency of accessing SPI NOR flashes and also support different SPI bus widths and speeds. 

In order to support such advanced SPI NOR controllers, SPI-NOR framework was introduced under Memory Technology Devices(MTD). This presentation aims at providing an overview of SPI-NOR framework, different types of NOR flashes supported (like SPI/QSPI/OSPI) and interaction with SPI framework. It also provides an overview of how to write a new controller driver or add support for a new flash device. 

The presentation then covers generic improvements done and proposed while working on improving QSPI performance on a TI SoC, challenges associated when using DMA with these controllers and other limitations of the framework.

About Vignesh Raghavendra
Vignesh has been contributing to Linux Kernel since 2014 as part of Texas Instruments' Linux team. He mainly works on Quad SPI, UART and touchscreen drivers for TI platforms in upstream. He has contributed patches to TI QSPI driver development and is currently working on TI K2G QSPI support in kernel. He previously co-presented "Overview of PCIe Subsystem" at ELC Europe-2015.
Captions: 
	00:00:00,030 --> 00:00:04,890
good morning everyone welcome my name is

00:00:03,090 --> 00:00:07,500
Rick Nash I'm from Texas Instruments

00:00:04,890 --> 00:00:11,730
India and I will be presenting about the

00:00:07,500 --> 00:00:14,130
spine or subsystem to introduce myself

00:00:11,730 --> 00:00:16,260
I am part of the next team that works on

00:00:14,130 --> 00:00:19,109
supporting various dia sources in the

00:00:16,260 --> 00:00:22,320
mainline kernel I work on supporting

00:00:19,109 --> 00:00:25,199
peripheral iOS drivers like cue spy you

00:00:22,320 --> 00:00:27,269
are touchscreen and USB and this

00:00:25,199 --> 00:00:29,699
presentation is mainly based on my

00:00:27,269 --> 00:00:33,110
experience of getting you spider to work

00:00:29,699 --> 00:00:39,120
in TI platforms on the mainline kernel

00:00:33,110 --> 00:00:41,430
so let's begin today's presentation I

00:00:39,120 --> 00:00:44,309
will be talking about spine or flash

00:00:41,430 --> 00:00:47,160
devices and its types communicating with

00:00:44,309 --> 00:00:49,469
the spinal flashes spine or framework

00:00:47,160 --> 00:00:51,360
the spine or controller drivers and

00:00:49,469 --> 00:00:53,160
types off the spine or controller

00:00:51,360 --> 00:00:55,920
drivers supported under the spine or

00:00:53,160 --> 00:00:59,160
framework writing of controller driver

00:00:55,920 --> 00:01:01,699
and ongoing development work and what's

00:00:59,160 --> 00:01:11,250
missing today in the spine or framework

00:01:01,699 --> 00:01:13,740
so what's us by not where the storage

00:01:11,250 --> 00:01:16,530
cells behave like an or gate hence it's

00:01:13,740 --> 00:01:20,040
called an off flash nor flash are

00:01:16,530 --> 00:01:23,670
available in parallel interface or

00:01:20,040 --> 00:01:25,799
serial interface so serial nor flash are

00:01:23,670 --> 00:01:28,280
typically interface to associate is by

00:01:25,799 --> 00:01:31,020
bus hence they are called spine or flash

00:01:28,280 --> 00:01:33,600
these flashes have radius pin count when

00:01:31,020 --> 00:01:39,270
you compare with the normal parallel nor

00:01:33,600 --> 00:01:41,790
flash this table tries to compare spine

00:01:39,270 --> 00:01:44,520
or with nine and emmc which are the

00:01:41,790 --> 00:01:46,649
other two most common non-volatile

00:01:44,520 --> 00:01:49,770
storage media that you find on embedded

00:01:46,649 --> 00:01:52,170
boats in terms of capacity spine or

00:01:49,770 --> 00:01:54,869
flashes are in the range of megabytes

00:01:52,170 --> 00:01:59,759
whereas NAND and emmc are available in

00:01:54,869 --> 00:02:03,750
java bits of capacity nor flash have

00:01:59,759 --> 00:02:08,429
somewhere around 1 to 8 io lines but 9

00:02:03,750 --> 00:02:12,629
and EMC may have up to 16 or IO lines so

00:02:08,429 --> 00:02:13,500
the read speed when compared you see

00:02:12,629 --> 00:02:16,980
that

00:02:13,500 --> 00:02:20,040
spine or have fast random access that is

00:02:16,980 --> 00:02:23,070
the time taken to access the first byte

00:02:20,040 --> 00:02:29,040
is usually in the order of nanoseconds

00:02:23,070 --> 00:02:30,560
whereas NAND and emmc have a random read

00:02:29,040 --> 00:02:34,850
access speed in the order of

00:02:30,560 --> 00:02:38,280
microseconds so but in terms of right

00:02:34,850 --> 00:02:44,490
990 MMC are usually faster when compared

00:02:38,280 --> 00:02:47,160
to spine r9 technology has such is not

00:02:44,490 --> 00:02:49,650
quite reliable that is it suffers from

00:02:47,160 --> 00:02:52,980
random quick flips and poor write

00:02:49,650 --> 00:02:54,989
endurance then hence we need ECC and bad

00:02:52,980 --> 00:02:59,670
block management either in software or

00:02:54,989 --> 00:03:01,580
in Hardware emmc has such needs tuning

00:02:59,670 --> 00:03:04,680
to support higher speed of operations

00:03:01,580 --> 00:03:09,090
but Spiner has no such software

00:03:04,680 --> 00:03:11,400
overheads all this reliabilities fast

00:03:09,090 --> 00:03:15,150
random access and reduced number of pins

00:03:11,400 --> 00:03:17,790
makes by not an ideal boot media and

00:03:15,150 --> 00:03:20,850
it's mostly most commonly a primary

00:03:17,790 --> 00:03:26,400
built media or secondary or backup boot

00:03:20,850 --> 00:03:28,830
media in in embedded devices so this

00:03:26,400 --> 00:03:31,410
diagram shows a typical spine or flash

00:03:28,830 --> 00:03:34,019
connected to a spike controller the top

00:03:31,410 --> 00:03:36,180
three signals are common spy signals

00:03:34,019 --> 00:03:40,040
there is a clock running from controller

00:03:36,180 --> 00:03:43,160
to flash that has master or slave in and

00:03:40,040 --> 00:03:46,019
master and slave out

00:03:43,160 --> 00:03:49,140
mosa line is used by controller to send

00:03:46,019 --> 00:03:52,079
data to flash and the other line is used

00:03:49,140 --> 00:03:54,209
by flash to send data back to the master

00:03:52,079 --> 00:03:57,660
there's a chip select line to select the

00:03:54,209 --> 00:04:00,780
appropriate chip to talk to the right

00:03:57,660 --> 00:04:03,450
product and whole lines are mostly flash

00:04:00,780 --> 00:04:09,209
specific write-protect is used to make

00:04:03,450 --> 00:04:11,940
nor flash read only and not respond to

00:04:09,209 --> 00:04:15,299
write or erase commands whole line is

00:04:11,940 --> 00:04:18,989
used to pass a transaction without

00:04:15,299 --> 00:04:20,459
actually D selecting the nor flash so

00:04:18,989 --> 00:04:23,150
that you could pause and then resume the

00:04:20,459 --> 00:04:23,150
transaction

00:04:24,320 --> 00:04:29,930
this diagram shows a multi of your flash

00:04:27,020 --> 00:04:31,820
where there are four bi-directional IO

00:04:29,930 --> 00:04:35,690
lines connecting controller and the

00:04:31,820 --> 00:04:38,330
flash therefore we call the flashes

00:04:35,690 --> 00:04:41,390
quite spy flash and the controller is a

00:04:38,330 --> 00:04:44,410
quad spy controller in quiet mode the

00:04:41,390 --> 00:04:46,790
right product and i/o lines double has

00:04:44,410 --> 00:04:50,000
resided great product and whole line

00:04:46,790 --> 00:04:53,870
double has IO 2 and IO 3 lines making it

00:04:50,000 --> 00:04:56,300
for i/o lines there are also quite noir

00:04:53,870 --> 00:04:59,030
flashes with up to 800 lines which are

00:04:56,300 --> 00:05:02,240
called octal I of flash or you could

00:04:59,030 --> 00:05:04,250
have an or flash working with just 2 i/o

00:05:02,240 --> 00:05:06,770
lines i of 0 I on Io one in

00:05:04,250 --> 00:05:10,670
bi-directional mode such flashes are

00:05:06,770 --> 00:05:12,500
called dual I of flash so there to

00:05:10,670 --> 00:05:19,340
summarize there are dual i/o quite IO

00:05:12,500 --> 00:05:21,020
and octal I of flashes a little bit

00:05:19,340 --> 00:05:24,500
introduction to the spine or hardware

00:05:21,020 --> 00:05:28,370
itself a spy flash is composed of

00:05:24,500 --> 00:05:31,820
sectors and pages this sector is the

00:05:28,370 --> 00:05:35,980
smallest possible erase block size it

00:05:31,820 --> 00:05:39,190
may be 4k 32 k-6 to 4k or 256 KB in size

00:05:35,980 --> 00:05:43,070
the sectors are subdivided into pages

00:05:39,190 --> 00:05:45,470
page represents pages may be 256 bytes

00:05:43,070 --> 00:05:47,270
or fight well fetch a page represents

00:05:45,470 --> 00:05:49,280
what is the maximum number of bytes that

00:05:47,270 --> 00:05:53,240
can be programmed in a single write

00:05:49,280 --> 00:05:55,640
operation so before we do any write or

00:05:53,240 --> 00:05:58,220
read operation we have to sit right

00:05:55,640 --> 00:06:00,500
enable latch inside the flash this is

00:05:58,220 --> 00:06:04,640
done by sending write enable command

00:06:00,500 --> 00:06:11,210
this has to be sent for every sector or

00:06:04,640 --> 00:06:14,180
every page in term so most flash devices

00:06:11,210 --> 00:06:17,930
supports read ID command which is used

00:06:14,180 --> 00:06:20,960
to discover the flash read ID command is

00:06:17,930 --> 00:06:23,180
a jade X standard it the sending read ID

00:06:20,960 --> 00:06:26,660
command the flash will respond with the

00:06:23,180 --> 00:06:28,250
manufacturer ID device ID and unique ID

00:06:26,660 --> 00:06:33,640
of the flash this will help in

00:06:28,250 --> 00:06:33,640
discovering the flash in a unique way

00:06:35,039 --> 00:06:41,919
also a spy transaction between spy

00:06:38,319 --> 00:06:44,529
master and nor flash has for phase a

00:06:41,919 --> 00:06:48,669
command phase address face weight face

00:06:44,529 --> 00:06:50,949
and data phase during command face the

00:06:48,669 --> 00:06:52,779
master sends out the one-bite opcode

00:06:50,949 --> 00:06:56,080
which will represent whether it's a read

00:06:52,779 --> 00:06:58,960
write erase or accessing a flash

00:06:56,080 --> 00:07:00,789
register like configuration registers or

00:06:58,960 --> 00:07:03,309
status registers that are there within

00:07:00,789 --> 00:07:05,740
the flash this is followed by a drive

00:07:03,309 --> 00:07:08,169
phase which is three to four bytes long

00:07:05,740 --> 00:07:11,589
depending upon the opcode and flash

00:07:08,169 --> 00:07:14,199
configuration itself if it's a read

00:07:11,589 --> 00:07:16,629
operation and if the spy bus frequency

00:07:14,199 --> 00:07:19,599
is greater than fifty megahertz or if

00:07:16,629 --> 00:07:22,089
it's multi i/o operation like a lie or

00:07:19,599 --> 00:07:23,830
quieter or or octal high or it's there

00:07:22,089 --> 00:07:25,659
is an additional weight phase which is

00:07:23,830 --> 00:07:28,749
anywhere between eight cycle to and

00:07:25,659 --> 00:07:32,080
number of cycles as denoted in the flash

00:07:28,749 --> 00:07:33,999
data sheets during this phase there is

00:07:32,080 --> 00:07:36,849
no data exchange between master and

00:07:33,999 --> 00:07:39,009
slave but there is a clock running hence

00:07:36,849 --> 00:07:40,029
these clock cycles are called dummy

00:07:39,009 --> 00:07:46,360
clocks exits

00:07:40,029 --> 00:07:49,360
sorry dummy clock cycles and yeah during

00:07:46,360 --> 00:07:52,469
this phase the flash prepares itself to

00:07:49,360 --> 00:07:54,789
send data back to the controller and

00:07:52,469 --> 00:07:57,149
finally in the data phase depending upon

00:07:54,789 --> 00:08:00,279
whether it's read or write transaction

00:07:57,149 --> 00:08:11,439
the data is either sent from flash 235

00:08:00,279 --> 00:08:13,499
or device to the master moving on about

00:08:11,439 --> 00:08:16,180
the spine or controllers itself

00:08:13,499 --> 00:08:18,550
typically the controllers that are

00:08:16,180 --> 00:08:20,889
supported in Linux can be classified

00:08:18,550 --> 00:08:24,879
into three types for the ease of

00:08:20,889 --> 00:08:26,740
understanding traditional spy controller

00:08:24,879 --> 00:08:29,800
spine or controllers and the specialized

00:08:26,740 --> 00:08:31,809
spy controllers the traditional spy

00:08:29,800 --> 00:08:33,639
controllers provide direct access to the

00:08:31,809 --> 00:08:37,500
spy bus that is you could send any

00:08:33,639 --> 00:08:40,899
arbitrary data out on the spy bus and

00:08:37,500 --> 00:08:43,510
send it off spy slave so these devices

00:08:40,899 --> 00:08:45,730
can talk with any type of spy devices it

00:08:43,510 --> 00:08:48,399
might be spy flash or a normal spider

00:08:45,730 --> 00:08:51,250
device like a touchscreen

00:08:48,399 --> 00:08:54,190
these PI controllers don't usually have

00:08:51,250 --> 00:08:57,010
a very deep sea fo and hence cannot

00:08:54,190 --> 00:09:00,399
support a last burst of redirect read or

00:08:57,010 --> 00:09:02,440
write operations the second type of

00:09:00,399 --> 00:09:04,750
controllers are spine or controllers

00:09:02,440 --> 00:09:07,000
these controllers are aware of the fact

00:09:04,750 --> 00:09:10,690
that the slaves they are talking to is a

00:09:07,000 --> 00:09:13,209
spy slave and they only support talking

00:09:10,690 --> 00:09:16,060
to the spy slave device by flash slave

00:09:13,209 --> 00:09:18,040
devices and they are aware of the fact

00:09:16,060 --> 00:09:22,690
that the communication protocol has

00:09:18,040 --> 00:09:24,850
combined address and data face spine or

00:09:22,690 --> 00:09:27,130
controllers provide low latency access

00:09:24,850 --> 00:09:30,519
to flash either via memory mapped

00:09:27,130 --> 00:09:33,190
interface or any other accelerated

00:09:30,519 --> 00:09:36,160
interface in the memory mapped interface

00:09:33,190 --> 00:09:38,290
the entire queue spy or the flash device

00:09:36,160 --> 00:09:42,640
appears to be memory mapped inside the

00:09:38,290 --> 00:09:45,640
SOC address space and CPU could just do

00:09:42,640 --> 00:09:49,290
a mem copy read from that at this range

00:09:45,640 --> 00:09:52,149
and it will get the data from the flash

00:09:49,290 --> 00:09:53,880
these controllers also proper support

00:09:52,149 --> 00:09:57,010
read prefetch and have an internal

00:09:53,880 --> 00:09:59,320
Hardware buffers to accelerate the

00:09:57,010 --> 00:10:03,670
amount of data that can be fetched in

00:09:59,320 --> 00:10:06,910
one go but they don't provide access to

00:10:03,670 --> 00:10:08,709
spy bus directly which is the reason why

00:10:06,910 --> 00:10:10,540
these flashes can be sorry these

00:10:08,709 --> 00:10:15,459
controllers cannot directly talk to the

00:10:10,540 --> 00:10:16,959
spy devices other than flashes then

00:10:15,459 --> 00:10:18,790
there are specialized spy controllers

00:10:16,959 --> 00:10:20,529
which are like hybrid of traditional

00:10:18,790 --> 00:10:22,680
controllers in the spine or controllers

00:10:20,529 --> 00:10:24,520
they have be they will have interface

00:10:22,680 --> 00:10:26,790
which is similar to the traditional

00:10:24,520 --> 00:10:28,899
controller has fastened as well as an

00:10:26,790 --> 00:10:30,970
additional interface which would provide

00:10:28,899 --> 00:10:33,520
an accelerated of access to the spine or

00:10:30,970 --> 00:10:35,649
framework sorry spine or devices like

00:10:33,520 --> 00:10:42,040
memory mapped interface that I just

00:10:35,649 --> 00:10:44,260
talked about them coming to the spine or

00:10:42,040 --> 00:10:46,269
framework the spine or framework was

00:10:44,260 --> 00:10:49,540
introduced in kernel in order to support

00:10:46,269 --> 00:10:52,060
the second type of flash devices that I

00:10:49,540 --> 00:10:56,370
said dedicated spine or controllers

00:10:52,060 --> 00:11:00,730
which only talk about spy flash devices

00:10:56,370 --> 00:11:03,699
it was merged in v3 16 it is

00:11:00,730 --> 00:11:06,130
present another memory devices memory

00:11:03,699 --> 00:11:09,070
technology devices subsystem and this is

00:11:06,130 --> 00:11:11,380
the part to the source code this was

00:11:09,070 --> 00:11:14,519
derived from the pre-existing m25 PID

00:11:11,380 --> 00:11:20,350
flash driver code which was supporting

00:11:14,519 --> 00:11:23,079
all flashes under the on the spy bus it

00:11:20,350 --> 00:11:25,600
had code to support both flash and talk

00:11:23,079 --> 00:11:29,889
to the spy core and the flash specific

00:11:25,600 --> 00:11:33,970
part was refactored and spy not

00:11:29,889 --> 00:11:35,880
controller driver was done so what was

00:11:33,970 --> 00:11:38,160
the need for spy in our framework

00:11:35,880 --> 00:11:40,690
the main reason was to support

00:11:38,160 --> 00:11:45,519
controllers that only talk to spy flash

00:11:40,690 --> 00:11:47,620
devices and these flash the controllers

00:11:45,519 --> 00:11:49,839
needed to know information about the

00:11:47,620 --> 00:11:52,360
flash with which they're talking to and

00:11:49,839 --> 00:11:54,940
there was a need for a generic interface

00:11:52,360 --> 00:12:00,880
or generic framework that could supply

00:11:54,940 --> 00:12:03,040
this information so we'll go into each

00:12:00,880 --> 00:12:06,160
type of spy controllers in detail this

00:12:03,040 --> 00:12:08,740
is the traditional spy controllers these

00:12:06,160 --> 00:12:12,639
controllers are quite simple they have a

00:12:08,740 --> 00:12:15,160
TX v 4r x v4 and a shifter unit CPU our

00:12:12,639 --> 00:12:18,010
DMA would write data into the TX FIFO

00:12:15,160 --> 00:12:20,620
and whatever is written is just shifted

00:12:18,010 --> 00:12:22,209
out onto the spy bus and similarly the

00:12:20,620 --> 00:12:27,899
data that is received from the flash

00:12:22,209 --> 00:12:30,100
device is sent out by reading the FIFO

00:12:27,899 --> 00:12:34,440
since there is direct access to this

00:12:30,100 --> 00:12:37,029
FIFO the CPU can send any type of

00:12:34,440 --> 00:12:39,730
protocol here I mean CPU can implement

00:12:37,029 --> 00:12:42,819
any type of protocol and the same get

00:12:39,730 --> 00:12:45,209
shifted out on the bus hence making it

00:12:42,819 --> 00:12:49,389
possible to communicate with any type of

00:12:45,209 --> 00:12:53,980
flash devices or any type of spy devices

00:12:49,389 --> 00:12:55,899
like touchscreen etc so there is no

00:12:53,980 --> 00:12:59,130
notion of command phase address phase

00:12:55,899 --> 00:12:59,130
all data face anyway

00:13:03,170 --> 00:13:09,410
so this represents the kernel stack to

00:13:06,139 --> 00:13:13,160
access spy flash using the traditional

00:13:09,410 --> 00:13:16,220
spy controller that I just showed you at

00:13:13,160 --> 00:13:18,079
the top we have MTD framework which is

00:13:16,220 --> 00:13:20,569
the memory technology devices framework

00:13:18,079 --> 00:13:24,589
which abstract which abstract spoil type

00:13:20,569 --> 00:13:28,519
of draw flashes like nine or and similar

00:13:24,589 --> 00:13:31,549
devices MTD abstracts these devices and

00:13:28,519 --> 00:13:35,209
exposes them has character devices or

00:13:31,549 --> 00:13:37,809
block devices to the user space user

00:13:35,209 --> 00:13:40,519
space utilities like MTD utils or

00:13:37,809 --> 00:13:43,429
flash-based file systems can be mounted

00:13:40,519 --> 00:13:48,019
up on top of this carol device interface

00:13:43,429 --> 00:13:50,299
to read write and access the flash empty

00:13:48,019 --> 00:13:52,040
D also extracts flash specific

00:13:50,299 --> 00:13:53,839
properties like presence of strict

00:13:52,040 --> 00:13:58,999
sector page and also does the easy

00:13:53,839 --> 00:14:01,489
handling in case of say NAND flash it

00:13:58,999 --> 00:14:03,919
provides very leveling and bad block

00:14:01,489 --> 00:14:08,419
handling using the unsorted block images

00:14:03,919 --> 00:14:09,399
which is the basis for UB ifs file

00:14:08,419 --> 00:14:12,439
system

00:14:09,399 --> 00:14:14,809
it handles partitioning of flash storage

00:14:12,439 --> 00:14:19,790
space based on either command-line

00:14:14,809 --> 00:14:23,749
arguments or device tree data all the

00:14:19,790 --> 00:14:27,679
MTD devices in a system can be obtained

00:14:23,749 --> 00:14:31,160
by reading empty D proc FS entry you

00:14:27,679 --> 00:14:37,699
could do CAD /proc slash MTD and it

00:14:31,160 --> 00:14:39,980
lists all the devices so under this I'm

00:14:37,699 --> 00:14:42,559
greedy framework we have the spine or

00:14:39,980 --> 00:14:44,569
framework itself the spine or framework

00:14:42,559 --> 00:14:49,189
is responsible for implementing the

00:14:44,569 --> 00:14:51,049
spine or specific abstractions the read

00:14:49,189 --> 00:14:53,480
write and erase operations of the flash

00:14:51,049 --> 00:14:55,339
to detect the connected flash and

00:14:53,480 --> 00:14:59,660
configure the flash to operate in

00:14:55,339 --> 00:15:01,609
appropriate modes it provides the flash

00:14:59,660 --> 00:15:03,739
specific informations like array size

00:15:01,609 --> 00:15:09,139
page size to the MTD layer so that it

00:15:03,739 --> 00:15:10,999
could be used by the file systems and it

00:15:09,139 --> 00:15:14,600
also supports the dedicated spine or

00:15:10,999 --> 00:15:17,149
controllers which need to know slash

00:15:14,600 --> 00:15:19,189
specific information like what opcode

00:15:17,149 --> 00:15:21,230
what is the number of address bytes and

00:15:19,189 --> 00:15:24,740
the dummy cycle information and so on

00:15:21,230 --> 00:15:31,399
and finally implement support for multi

00:15:24,740 --> 00:15:34,540
area of hash devices so below the spine

00:15:31,399 --> 00:15:37,490
or framework we have m25 p80 driver

00:15:34,540 --> 00:15:41,660
which is basically a generic driver to

00:15:37,490 --> 00:15:44,480
access flash devices on the spy bus the

00:15:41,660 --> 00:15:46,519
m25 p80 driver acts as a translation

00:15:44,480 --> 00:15:49,850
layer between spinal framework and the

00:15:46,519 --> 00:15:52,910
spike or it implements the spine or

00:15:49,850 --> 00:15:56,480
interfaces and based on the information

00:15:52,910 --> 00:15:59,930
that spinal provides it generates spy

00:15:56,480 --> 00:16:02,089
transfer structures which would

00:15:59,930 --> 00:16:05,569
represent which would encompass all the

00:16:02,089 --> 00:16:08,329
command address data face and then pass

00:16:05,569 --> 00:16:11,120
it has a spy message object to the spike

00:16:08,329 --> 00:16:13,459
or all the communication within spike or

00:16:11,120 --> 00:16:17,809
or communication with spike or as always

00:16:13,459 --> 00:16:20,120
in terms of spy messages therefore m25

00:16:17,809 --> 00:16:22,939
p80 acts as a translation layer and

00:16:20,120 --> 00:16:25,100
generates those PI messages based on the

00:16:22,939 --> 00:16:31,160
parameter supplied by the spine or

00:16:25,100 --> 00:16:33,410
framework the spike or the some messages

00:16:31,160 --> 00:16:36,110
that are submitted by m25 PID will line

00:16:33,410 --> 00:16:38,360
in the spike or spike or validates

00:16:36,110 --> 00:16:40,429
queues and thus sends the spy messages

00:16:38,360 --> 00:16:44,360
from upper layer to the controller

00:16:40,429 --> 00:16:48,379
drivers the spy controller driver writes

00:16:44,360 --> 00:16:50,420
data to the TX and rx FIFO and whatever

00:16:48,379 --> 00:16:52,550
data that is received by a directs

00:16:50,420 --> 00:16:55,550
before you send along the same path back

00:16:52,550 --> 00:16:57,970
to the employee as Pienaar and MTD

00:16:55,550 --> 00:16:57,970
framework

00:17:00,800 --> 00:17:06,419
so this diagram shows the second type of

00:17:03,329 --> 00:17:09,419
spy controllers that is dedicated Spiner

00:17:06,419 --> 00:17:13,079
controllers with memory mapped i/o

00:17:09,419 --> 00:17:16,730
interface so the entire flash here would

00:17:13,079 --> 00:17:20,640
appear has memory mapped region for the

00:17:16,730 --> 00:17:24,480
SOC I'd predefined address range as

00:17:20,640 --> 00:17:27,120
specified by the SOC so the CPU would

00:17:24,480 --> 00:17:30,809
first configure the IP registers within

00:17:27,120 --> 00:17:35,010
the spine RI controller IP with flash

00:17:30,809 --> 00:17:38,700
specifically properties like the opcode

00:17:35,010 --> 00:17:41,940
to be used to read from the flash up

00:17:38,700 --> 00:17:44,460
code to use to write to the flash number

00:17:41,940 --> 00:17:46,049
of address bytes to use and the dummy

00:17:44,460 --> 00:17:48,510
cycle and all this information would be

00:17:46,049 --> 00:17:51,840
pre-configured in the IP registers then

00:17:48,510 --> 00:17:54,169
the CPU would do a mem copy operation to

00:17:51,840 --> 00:17:56,220
read data from the flash this

00:17:54,169 --> 00:17:59,970
transaction will land in the Speight

00:17:56,220 --> 00:18:02,340
command generator block the spy command

00:17:59,970 --> 00:18:04,950
generator would generate appropriate spy

00:18:02,340 --> 00:18:06,440
transaction on the spy bus based on the

00:18:04,950 --> 00:18:09,440
information that is supplied by the

00:18:06,440 --> 00:18:12,750
hyperion supplied at the IP resistors

00:18:09,440 --> 00:18:14,910
and the data that is received from the

00:18:12,750 --> 00:18:18,470
nor flash would be forwarded by either a

00:18:14,910 --> 00:18:21,120
memory map interface since the

00:18:18,470 --> 00:18:23,520
generation of spy transaction on the bus

00:18:21,120 --> 00:18:26,130
is handled by the hardware it is

00:18:23,520 --> 00:18:28,020
possible for the hardware to make 100%

00:18:26,130 --> 00:18:31,620
utilization of the spy bust cycles

00:18:28,020 --> 00:18:33,570
available here due to which you could

00:18:31,620 --> 00:18:38,790
achieve the maximum possible data rate

00:18:33,570 --> 00:18:40,740
on the spy bus so it need not be memory

00:18:38,790 --> 00:18:43,830
mapped interface some controllers would

00:18:40,740 --> 00:18:46,650
just provide a big internal SRAM or a

00:18:43,830 --> 00:18:50,490
FIFO and the data that is received from

00:18:46,650 --> 00:18:52,429
the flash is stored in the FIFO and CPU

00:18:50,490 --> 00:18:54,929
all DMA could read in a large bust

00:18:52,429 --> 00:18:57,380
therefore making event effective

00:18:54,929 --> 00:19:05,040
utilization of the available

00:18:57,380 --> 00:19:07,799
interconnect cycles as well so the stack

00:19:05,040 --> 00:19:10,290
shows this kernel stack shows how

00:19:07,799 --> 00:19:13,980
dedicated spine or controllers are

00:19:10,290 --> 00:19:16,290
supported in the kernel so the spine or

00:19:13,980 --> 00:19:19,169
instead of taking the traditional route

00:19:16,290 --> 00:19:23,280
no we'll stop talked directly to the

00:19:19,169 --> 00:19:24,660
spine or controller driver itself this

00:19:23,280 --> 00:19:26,700
will provide all the information

00:19:24,660 --> 00:19:28,290
required for the flash and the

00:19:26,700 --> 00:19:31,620
controller driver is responsible for

00:19:28,290 --> 00:19:34,890
programming the IP registers the

00:19:31,620 --> 00:19:38,150
controller driver sorry the controller

00:19:34,890 --> 00:19:40,980
driver would also provide and in I mean

00:19:38,150 --> 00:19:42,870
would also provide a way to write to the

00:19:40,980 --> 00:19:45,650
flash registers and read from the flash

00:19:42,870 --> 00:19:48,630
register and it will implement

00:19:45,650 --> 00:19:50,850
interfaces to read data from flash

00:19:48,630 --> 00:19:54,799
either by a memory mapped interface or

00:19:50,850 --> 00:19:54,799
some internal hardware buffers

00:20:01,220 --> 00:20:07,200
this diagram shows a specialized PI

00:20:04,200 --> 00:20:09,540
controllers which is the third type of

00:20:07,200 --> 00:20:13,890
controllers that I talked about these

00:20:09,540 --> 00:20:16,140
controllers provide two interfaces one

00:20:13,890 --> 00:20:18,540
would be a spy interface and another is

00:20:16,140 --> 00:20:22,049
an memory mapped interface using the spy

00:20:18,540 --> 00:20:25,260
interface which which will mark here as

00:20:22,049 --> 00:20:30,240
direct as path CPU can directly access

00:20:25,260 --> 00:20:33,030
TX and RX v for so therefore you could

00:20:30,240 --> 00:20:37,460
talk to any type of spy devices not just

00:20:33,030 --> 00:20:40,440
the flash using this direct access path

00:20:37,460 --> 00:20:42,240
but it also provides memory mapped

00:20:40,440 --> 00:20:45,330
interface which will help you to read

00:20:42,240 --> 00:20:47,160
data at a faster rate from the flash so

00:20:45,330 --> 00:20:49,169
the read transaction especially with

00:20:47,160 --> 00:20:51,780
respect to flash will go through memory

00:20:49,169 --> 00:20:54,240
mapped interface but all the write and

00:20:51,780 --> 00:20:58,350
erase transactions can go through the

00:20:54,240 --> 00:21:00,390
normal spy mode and also you could

00:20:58,350 --> 00:21:10,140
access other flash devices using the

00:21:00,390 --> 00:21:12,390
normal direct access path so this shows

00:21:10,140 --> 00:21:15,390
the stack for accessing such spy

00:21:12,390 --> 00:21:18,690
controllers so the hash as I said before

00:21:15,390 --> 00:21:20,640
the normal write transaction and erase

00:21:18,690 --> 00:21:23,760
transaction go through the m25 p80

00:21:20,640 --> 00:21:25,860
translation into the spy core and the

00:21:23,760 --> 00:21:27,480
actual spy controller driver will decide

00:21:25,860 --> 00:21:31,700
under the spy core itself

00:21:27,480 --> 00:21:31,700
and this caused by other normal paths

00:21:31,820 --> 00:21:39,000
but therefore the reap transaction m25

00:21:35,940 --> 00:21:42,060
p80 will call spy flash read API

00:21:39,000 --> 00:21:45,930
which is a special API provided by Spike

00:21:42,060 --> 00:21:48,870
or to talk to the spy controller drivers

00:21:45,930 --> 00:21:50,880
which memory mapped i/o interfaces the

00:21:48,870 --> 00:21:53,640
spy flash through the API is supplied

00:21:50,880 --> 00:21:55,380
with spy flash message structure which

00:21:53,640 --> 00:21:57,030
is similar to the spinal structure and

00:21:55,380 --> 00:22:00,450
this contains all the information

00:21:57,030 --> 00:22:07,680
required for the controller driver to

00:22:00,450 --> 00:22:09,360
access is the specific flash so the

00:22:07,680 --> 00:22:10,560
writes go through the normal interface

00:22:09,360 --> 00:22:13,260
but the reads

00:22:10,560 --> 00:22:15,930
go through the spy flash read API and

00:22:13,260 --> 00:22:23,550
the implementation of that API by spy

00:22:15,930 --> 00:22:27,060
controller drivers so let you put our

00:22:23,550 --> 00:22:28,770
driver if you if you have a spine or

00:22:27,060 --> 00:22:30,990
controller driver where would you put in

00:22:28,770 --> 00:22:33,420
one of these frameworks either in spy

00:22:30,990 --> 00:22:35,520
framework or spike frame spine or

00:22:33,420 --> 00:22:39,140
framework or on the spike framework it's

00:22:35,520 --> 00:22:42,830
decided by how you want to support

00:22:39,140 --> 00:22:45,740
devices on your spy bus if the spy

00:22:42,830 --> 00:22:50,420
framework sorry if the PI controller

00:22:45,740 --> 00:22:53,130
provides direct access to the bus and

00:22:50,420 --> 00:22:55,500
there are no accelerated interface as

00:22:53,130 --> 00:23:00,300
such then you would put such drivers on

00:22:55,500 --> 00:23:03,060
the spy framework if the controller IP

00:23:00,300 --> 00:23:05,760
supports only talking to spy flash

00:23:03,060 --> 00:23:08,190
devices and cannot talk to other type of

00:23:05,760 --> 00:23:12,360
devices then you would put them under

00:23:08,190 --> 00:23:14,550
spine or framework and if you have a

00:23:12,360 --> 00:23:16,350
controller which has both the spy

00:23:14,550 --> 00:23:19,950
interface and a memory mapped interface

00:23:16,350 --> 00:23:24,780
and your board or a so she has both type

00:23:19,950 --> 00:23:26,730
of devices in the spy bus that is you

00:23:24,780 --> 00:23:29,070
have a flash flash device as well as a

00:23:26,730 --> 00:23:31,680
normal spider vice then you would put

00:23:29,070 --> 00:23:37,200
the controller driver under the spy

00:23:31,680 --> 00:23:39,630
framework but implement both spy-related

00:23:37,200 --> 00:23:41,070
callbacks as well as implement spy flash

00:23:39,630 --> 00:23:44,550
read API interface

00:23:41,070 --> 00:23:48,050
so that you could access Flash reads why

00:23:44,550 --> 00:23:51,120
are this interface but access other

00:23:48,050 --> 00:24:03,750
other spy devices by other normal spy

00:23:51,120 --> 00:24:07,740
framework so how to write a spine or

00:24:03,750 --> 00:24:09,990
controller driver the spine or framework

00:24:07,740 --> 00:24:13,050
expects these for at least these four

00:24:09,990 --> 00:24:17,570
ApS to be implemented that is read read

00:24:13,050 --> 00:24:23,310
write read read and write ap ice so that

00:24:17,570 --> 00:24:27,470
read rich API you implement this API to

00:24:23,310 --> 00:24:30,150
read data from the flash that is either

00:24:27,470 --> 00:24:35,070
status resist or configuration resistors

00:24:30,150 --> 00:24:38,660
or the flash discovery ID that is read

00:24:35,070 --> 00:24:41,220
as to send read ID command or to read

00:24:38,660 --> 00:24:44,100
serial flash discoverable protocols and

00:24:41,220 --> 00:24:47,160
so on to send various I mean to treat

00:24:44,100 --> 00:24:49,740
various registers within the flash then

00:24:47,160 --> 00:24:51,450
you would implement the right rich API

00:24:49,740 --> 00:24:54,630
which is used to write to this

00:24:51,450 --> 00:24:58,860
resistance say to send write enable

00:24:54,630 --> 00:25:03,540
command or to set flash into Paideia

00:24:58,860 --> 00:25:08,520
mode and all all the right transactions

00:25:03,540 --> 00:25:11,520
to the spy configuration registers and

00:25:08,520 --> 00:25:14,220
finally implement readwrite ApS which is

00:25:11,520 --> 00:25:16,650
used to read the actual data from the

00:25:14,220 --> 00:25:18,600
flash either Y other memory mapped

00:25:16,650 --> 00:25:20,730
interface or any other accelerated

00:25:18,600 --> 00:25:22,610
interface that's Pienaar framework that

00:25:20,730 --> 00:25:25,860
the spy in our controller would provide

00:25:22,610 --> 00:25:29,580
so the spinous truck that's being passed

00:25:25,860 --> 00:25:34,260
here would would contain the details

00:25:29,580 --> 00:25:36,660
required to access the flash so in the

00:25:34,260 --> 00:25:41,430
probe of the controller driver you would

00:25:36,660 --> 00:25:44,820
call spine or scan the spine or scan

00:25:41,430 --> 00:25:48,960
will request the spy framework to send a

00:25:44,820 --> 00:25:51,450
read ID command that is decreed ID

00:25:48,960 --> 00:25:53,960
command to discover the manufacture ID

00:25:51,450 --> 00:25:56,570
and device ID of the flash

00:25:53,960 --> 00:25:59,090
based on this information there is a

00:25:56,570 --> 00:26:02,420
table within the spinal framework which

00:25:59,090 --> 00:26:05,990
will dictate for the given flash for the

00:26:02,420 --> 00:26:07,780
given flash device ID what is the size

00:26:05,990 --> 00:26:11,180
of the flash what is the array size

00:26:07,780 --> 00:26:14,960
sector size and page size of the flash

00:26:11,180 --> 00:26:18,170
and whether or not it supports quiet

00:26:14,960 --> 00:26:19,730
mode dual mode IO or octal mode and what

00:26:18,170 --> 00:26:23,210
are the of course that needs to be used

00:26:19,730 --> 00:26:26,750
for the specific flash so when spine or

00:26:23,210 --> 00:26:28,880
scan API is called the spy framework

00:26:26,750 --> 00:26:30,860
would based on the table populate the

00:26:28,880 --> 00:26:34,190
spinal structure with all the required

00:26:30,860 --> 00:26:36,470
details this will help the spy

00:26:34,190 --> 00:26:38,450
controller drivers whenever it wants to

00:26:36,470 --> 00:26:41,059
do a read or write operations to

00:26:38,450 --> 00:26:45,790
actually configure the IP registers

00:26:41,059 --> 00:26:48,470
which require address and address or

00:26:45,790 --> 00:26:50,390
sorry which which would require read or

00:26:48,470 --> 00:26:53,960
write of course to communicate with the

00:26:50,390 --> 00:26:56,740
flash so then you would call MTD device

00:26:53,960 --> 00:26:59,330
a resistor which will register the

00:26:56,740 --> 00:27:02,030
discovered flash with the MTD framework

00:26:59,330 --> 00:27:08,150
and result in creation of slash dev

00:27:02,030 --> 00:27:10,790
slash MTD interface so if there are

00:27:08,150 --> 00:27:14,330
multiple spine or devices connected to

00:27:10,790 --> 00:27:16,580
the controller at different chip selects

00:27:14,330 --> 00:27:19,040
you will have to call spine or scan for

00:27:16,580 --> 00:27:25,340
each of the chip selects and register

00:27:19,040 --> 00:27:28,220
each of the devices so this is an

00:27:25,340 --> 00:27:31,610
example for instantiating spine or

00:27:28,220 --> 00:27:34,360
controller driver using DD so this is an

00:27:31,610 --> 00:27:37,820
example from cadence cue spy

00:27:34,360 --> 00:27:41,809
so you this represents the controller

00:27:37,820 --> 00:27:43,910
note that is compatible which says by

00:27:41,809 --> 00:27:46,940
it's compatible with cadence plane or

00:27:43,910 --> 00:27:49,640
you can see there are two reg properties

00:27:46,940 --> 00:27:51,710
the first bridge property corresponds to

00:27:49,640 --> 00:27:54,050
the IP registers where you would

00:27:51,710 --> 00:27:58,550
actually configure splash specific data

00:27:54,050 --> 00:28:01,700
or other IP registered configuration and

00:27:58,550 --> 00:28:03,530
the second address range actually

00:28:01,700 --> 00:28:06,790
represents the memory mapped your

00:28:03,530 --> 00:28:09,700
interface using this interface

00:28:06,790 --> 00:28:12,880
one good eye so this is the address

00:28:09,700 --> 00:28:16,150
range from where CPU or DMA would do mem

00:28:12,880 --> 00:28:18,190
copy operation so that which gets

00:28:16,150 --> 00:28:21,910
translated to translator to spy in our

00:28:18,190 --> 00:28:26,200
messages and goes out on the spy bus and

00:28:21,910 --> 00:28:31,150
you would get data back of what is

00:28:26,200 --> 00:28:34,000
present on the spy flash so each of the

00:28:31,150 --> 00:28:38,940
flight spy flash devices would appear

00:28:34,000 --> 00:28:43,090
has child node to the controller driver

00:28:38,940 --> 00:28:43,900
you would say compatible is equal to GX

00:28:43,090 --> 00:28:48,490
Pienaar

00:28:43,900 --> 00:28:53,080
if the spy flash supports reading API

00:28:48,490 --> 00:28:55,210
and based on the flash that was

00:28:53,080 --> 00:28:58,150
discovered the spine or frame would take

00:28:55,210 --> 00:29:00,850
the appropriate actions the read is

00:28:58,150 --> 00:29:03,700
equal to zero this property will suggest

00:29:00,850 --> 00:29:06,910
that this flash is present at chip

00:29:03,700 --> 00:29:10,060
select zero and the Spy math.max

00:29:06,910 --> 00:29:14,290
frequency will dictate the spy bus rate

00:29:10,060 --> 00:29:17,080
at which the communication would happen

00:29:14,290 --> 00:29:19,930
between the flash and the slave sorry

00:29:17,080 --> 00:29:21,730
flash in the controller and similarly

00:29:19,930 --> 00:29:26,590
you would have other flash devices as

00:29:21,730 --> 00:29:31,480
well so if the controller if the flash

00:29:26,590 --> 00:29:34,000
doesn't support J decreed ID then you

00:29:31,480 --> 00:29:36,580
would have to supply the name of the

00:29:34,000 --> 00:29:40,030
flash as one of the parameter to the

00:29:36,580 --> 00:29:42,610
spine or scan API and if that flash is

00:29:40,030 --> 00:29:45,370
supported by the framework then it would

00:29:42,610 --> 00:29:49,810
do the appropriate configurations also

00:29:45,370 --> 00:29:52,540
spine or scan API will accept hardware

00:29:49,810 --> 00:29:54,220
capabilities of the nor flash controller

00:29:52,540 --> 00:29:57,600
driver that is whether or not it

00:29:54,220 --> 00:30:00,700
supports all the i/o modes or it just a

00:29:57,600 --> 00:30:03,370
single i/o device based on the

00:30:00,700 --> 00:30:06,850
properties of the discovered flash and

00:30:03,370 --> 00:30:09,880
has well as the properties of the

00:30:06,850 --> 00:30:14,880
controller the spine or APA would choose

00:30:09,880 --> 00:30:14,880
the appropriate IO mode to be used

00:30:23,290 --> 00:30:31,700
this table shows performance comparison

00:30:26,960 --> 00:30:35,690
between various framework that I talked

00:30:31,700 --> 00:30:40,160
about using D IQ spy controller on DRS

00:30:35,690 --> 00:30:42,470
7xs family sofa so see this the state

00:30:40,160 --> 00:30:44,870
used by controller is a dedicated mean

00:30:42,470 --> 00:30:47,510
specialized PI controller which can talk

00:30:44,870 --> 00:30:52,760
to both spy devices as well as spy nor

00:30:47,510 --> 00:30:55,670
flash devices so under spy framework

00:30:52,760 --> 00:30:58,460
with without any acceleration just going

00:30:55,670 --> 00:31:00,380
through the traditional route the read

00:30:58,460 --> 00:31:02,870
speed is around eight hundred kilobytes

00:31:00,380 --> 00:31:05,180
per second with a CPU load of seventy

00:31:02,870 --> 00:31:08,150
percent but under spine or controller

00:31:05,180 --> 00:31:10,180
driver half are using the spy course

00:31:08,150 --> 00:31:13,940
accelerated read interface which is

00:31:10,180 --> 00:31:15,710
memory mapped interface in case of tiq

00:31:13,940 --> 00:31:17,800
spy controllers the throughput is

00:31:15,710 --> 00:31:21,020
approximately four megabytes per second

00:31:17,800 --> 00:31:25,330
so one of the reason for this large jump

00:31:21,020 --> 00:31:28,570
is the fact that you spy controller

00:31:25,330 --> 00:31:31,850
doesn't support bus greater than four K

00:31:28,570 --> 00:31:34,820
in case of memory mapped interface the

00:31:31,850 --> 00:31:39,380
bus can be as long as I mean whatever is

00:31:34,820 --> 00:31:41,690
the length of the read but in normal spy

00:31:39,380 --> 00:31:45,440
mode it can only support up to four K

00:31:41,690 --> 00:31:49,070
bus such limitations actually lead to

00:31:45,440 --> 00:31:55,160
decrease in the read performance in in

00:31:49,070 --> 00:31:58,820
case of normal spy mode of access and

00:31:55,160 --> 00:32:00,650
then with DMA we see that so the

00:31:58,820 --> 00:32:04,400
controller actually doesn't support

00:32:00,650 --> 00:32:06,380
reading DMA reads from the FIFO that is

00:32:04,400 --> 00:32:08,360
it has no events going to the DMSO it's

00:32:06,380 --> 00:32:11,180
not possible to read data by other FIFO

00:32:08,360 --> 00:32:16,300
mode but if you use the memory map mode

00:32:11,180 --> 00:32:21,770
and use DMA we see a proxy approximately

00:32:16,300 --> 00:32:25,040
20 Mbps of read with 15% CPU load this

00:32:21,770 --> 00:32:27,970
is because when compared to CPU the DMA

00:32:25,040 --> 00:32:32,030
can do larger bus

00:32:27,970 --> 00:32:36,470
hence you could see that the speed

00:32:32,030 --> 00:32:39,770
increases further here but the spine or

00:32:36,470 --> 00:32:43,100
controller I mean the spinal framework

00:32:39,770 --> 00:32:44,870
itself has no support for the DMA I mean

00:32:43,100 --> 00:32:47,179
no generic support for the DNA but you

00:32:44,870 --> 00:32:51,290
could still implement the MEAP ice and

00:32:47,179 --> 00:32:53,929
would see the similar performance there

00:32:51,290 --> 00:32:56,330
is no increase in terms of write speed

00:32:53,929 --> 00:32:58,850
because in right most of the time is

00:32:56,330 --> 00:33:00,440
spent polling on the flash to know

00:32:58,850 --> 00:33:13,370
whether or not a write operation has

00:33:00,440 --> 00:33:15,290
completed talk about the ongoing

00:33:13,370 --> 00:33:20,150
development will work in spine or

00:33:15,290 --> 00:33:22,280
framework one of the main things that's

00:33:20,150 --> 00:33:26,200
being addressed is use of four byte

00:33:22,280 --> 00:33:29,780
addressing mode for opcodes flashes

00:33:26,200 --> 00:33:31,580
older flashes had sizes less than

00:33:29,780 --> 00:33:34,220
sixteen megabytes and just required

00:33:31,580 --> 00:33:36,080
three byte of addressing mode but your

00:33:34,220 --> 00:33:39,490
flashes have higher density and would

00:33:36,080 --> 00:33:42,500
require four byte of addressing mode and

00:33:39,490 --> 00:33:44,630
there are special op codes which expect

00:33:42,500 --> 00:33:46,429
four byte of addressing codes and there

00:33:44,630 --> 00:33:49,790
are of course we just take three bytes

00:33:46,429 --> 00:33:55,429
of address and flashes provide many ways

00:33:49,790 --> 00:33:57,919
to use the access the memory region

00:33:55,429 --> 00:34:00,340
above the sixteen megabytes that is you

00:33:57,919 --> 00:34:02,330
can enter a three by two addressing mode

00:34:00,340 --> 00:34:04,370
sorry you can enter a four byte

00:34:02,330 --> 00:34:06,860
addressing boil by setting up it within

00:34:04,370 --> 00:34:08,869
the flash and then all the three byte

00:34:06,860 --> 00:34:12,530
addressing of course would also expect

00:34:08,869 --> 00:34:15,830
four byte addresses or you could use the

00:34:12,530 --> 00:34:17,570
dedicated of course which will always

00:34:15,830 --> 00:34:19,190
expect four bytes of opcode in

00:34:17,570 --> 00:34:22,609
respective of what is the state of the

00:34:19,190 --> 00:34:23,990
flash so but we should make sure that

00:34:22,609 --> 00:34:27,109
the communication with the flash is

00:34:23,990 --> 00:34:30,919
stateless and there's no bit that is set

00:34:27,109 --> 00:34:34,280
within the flash to enter four byte

00:34:30,919 --> 00:34:36,290
address in mode or come out of four byte

00:34:34,280 --> 00:34:38,929
address anymore that's because it would

00:34:36,290 --> 00:34:40,490
create incompatibilities with the boot

00:34:38,929 --> 00:34:42,649
old boot loaders

00:34:40,490 --> 00:34:45,800
which would expect to be in three bite

00:34:42,649 --> 00:34:48,320
artists in more say for example because

00:34:45,800 --> 00:35:00,610
the boot lord bootloader might be

00:34:48,320 --> 00:35:04,430
residing within the so another thing

00:35:00,610 --> 00:35:06,800
that is being addressed is flash guns

00:35:04,430 --> 00:35:10,130
and sorry the controller can send

00:35:06,800 --> 00:35:11,630
command either on one wire or send

00:35:10,130 --> 00:35:14,450
command on all the four wires

00:35:11,630 --> 00:35:16,940
similarly address can also be sent on

00:35:14,450 --> 00:35:19,520
one wire or all the four wires so we

00:35:16,940 --> 00:35:21,680
call this as one one four one wire for

00:35:19,520 --> 00:35:23,930
address one wire for data in for by

00:35:21,680 --> 00:35:26,960
sorry one wire for command one wire for

00:35:23,930 --> 00:35:31,910
address and four wire for data and

00:35:26,960 --> 00:35:33,619
similarly four wires for address sorry

00:35:31,910 --> 00:35:39,530
for ways for up cord four wires for

00:35:33,619 --> 00:35:42,050
address and for voice for data the in

00:35:39,530 --> 00:35:44,600
order to work in quiet mode there is a

00:35:42,050 --> 00:35:47,020
bit within the flash which says quite

00:35:44,600 --> 00:35:50,480
enable you will have to set this more

00:35:47,020 --> 00:35:54,770
aside this bit before actually using

00:35:50,480 --> 00:35:56,960
quiet mode of operation but this bit

00:35:54,770 --> 00:36:00,560
behaves differently on different flashes

00:35:56,960 --> 00:36:03,530
like for example on span ssin with this

00:36:00,560 --> 00:36:06,770
bit said you could use the flash in this

00:36:03,530 --> 00:36:08,900
mode or this mode depending upon what

00:36:06,770 --> 00:36:11,390
command you are actually sending there

00:36:08,900 --> 00:36:13,700
are different commands for one one four

00:36:11,390 --> 00:36:17,030
more and four four four mode but on

00:36:13,700 --> 00:36:18,890
micron it's always four four four more

00:36:17,030 --> 00:36:24,980
that is separated with that is supported

00:36:18,890 --> 00:36:29,210
with quite bit enable sector so we could

00:36:24,980 --> 00:36:32,510
just not set quite enable bit and not

00:36:29,210 --> 00:36:40,490
worry about all type of flashes we will

00:36:32,510 --> 00:36:42,080
have to do some work for micron alone so

00:36:40,490 --> 00:36:46,310
the other thing is handling different

00:36:42,080 --> 00:36:49,880
sector sizes flash my support ether 32k

00:36:46,310 --> 00:36:51,440
64 K or 256 K sector size and optionally

00:36:49,880 --> 00:36:54,230
they also have support something called

00:36:51,440 --> 00:36:58,790
as small sectors which is 4k in size

00:36:54,230 --> 00:37:02,420
so there are dedicated of course for

00:36:58,790 --> 00:37:09,200
this and for this secretary raised was

00:37:02,420 --> 00:37:12,710
for K secretary raised and it is and

00:37:09,200 --> 00:37:16,099
there is what you call has serial flash

00:37:12,710 --> 00:37:21,650
discoverable parameters or table which

00:37:16,099 --> 00:37:26,030
is being supported in V 4.14 based on

00:37:21,650 --> 00:37:28,820
serial flashes Caravelle parameters we

00:37:26,030 --> 00:37:31,910
all I mean the serial flash discoverable

00:37:28,820 --> 00:37:34,880
parameters specifies a table called

00:37:31,910 --> 00:37:36,890
basic Flash parameter table this table

00:37:34,880 --> 00:37:41,390
contains all the information regarding

00:37:36,890 --> 00:37:43,570
whether the sector's for case exercises

00:37:41,390 --> 00:37:49,060
are supported and what is the opcode to

00:37:43,570 --> 00:37:50,180
erase a 4k sector and what are the

00:37:49,060 --> 00:37:53,599
opcodes

00:37:50,180 --> 00:37:55,940
to access in 1:1 for more or for for for

00:37:53,599 --> 00:37:58,490
more and so on there are different

00:37:55,940 --> 00:38:05,720
versions of serial flash discoverable

00:37:58,490 --> 00:38:08,420
parameters mainly 1.0 1.5 and 1.6 if the

00:38:05,720 --> 00:38:10,280
flash supports 1.6 that is the newest

00:38:08,420 --> 00:38:14,990
version it would have all the

00:38:10,280 --> 00:38:17,060
information but older Flash worsens I

00:38:14,990 --> 00:38:20,599
mean older flashes don't support the

00:38:17,060 --> 00:38:24,260
latest version and they still have to

00:38:20,599 --> 00:38:27,020
handle this in the framework finally

00:38:24,260 --> 00:38:29,960
there has been patches for supporting

00:38:27,020 --> 00:38:34,579
octal mode flashes and also a DTR that

00:38:29,960 --> 00:38:37,160
is double data rate mode wherein data is

00:38:34,579 --> 00:38:39,400
sent both on raising and falling edge of

00:38:37,160 --> 00:38:39,400
the clock

00:38:42,910 --> 00:38:49,210
so one of the things that is missing

00:38:45,290 --> 00:38:53,660
today in the framework as DMA support so

00:38:49,210 --> 00:38:56,300
classified the main reason why it's not

00:38:53,660 --> 00:38:58,580
so easy to support DMA with large

00:38:56,300 --> 00:39:01,490
controllers is the fact that the flat

00:38:58,580 --> 00:39:05,360
systems are the Fallas file systems

00:39:01,490 --> 00:39:08,960
which make use of the spine or flashes

00:39:05,360 --> 00:39:10,880
are not written with DMA in mind that is

00:39:08,960 --> 00:39:15,350
they make use of VM a lock buffers and

00:39:10,880 --> 00:39:18,050
it's generally not easy and safe to DMA

00:39:15,350 --> 00:39:22,130
into we may lack buffers it is known to

00:39:18,050 --> 00:39:24,050
cause issues with vi-vt caches and if

00:39:22,130 --> 00:39:26,240
the if it's a vapor lock buffers it's

00:39:24,050 --> 00:39:29,960
possible that the buffer may be from the

00:39:26,240 --> 00:39:32,480
LPI back memory region and if the dma

00:39:29,960 --> 00:39:35,960
engine is that's 32-bit in size then it

00:39:32,480 --> 00:39:38,600
cannot actually address the region's in

00:39:35,960 --> 00:39:42,340
I mean buffers in the LPA region which

00:39:38,600 --> 00:39:47,510
require more than 32 bit of addressing

00:39:42,340 --> 00:39:50,210
so the spike or tries to handle this we

00:39:47,510 --> 00:39:52,610
may lock buffers by mapping it to an st

00:39:50,210 --> 00:39:55,820
list and passing it on to the spy

00:39:52,610 --> 00:39:59,150
controller drivers but this still cannot

00:39:55,820 --> 00:40:04,370
deal with vi-vt caches or LPA memory

00:39:59,150 --> 00:40:06,850
back buffers so one of the solutions

00:40:04,370 --> 00:40:09,410
that is used as use of bonds buffers

00:40:06,850 --> 00:40:11,720
yakyu spy driver uses bonds buffers

00:40:09,410 --> 00:40:13,730
which is an intermediate buffer from

00:40:11,720 --> 00:40:17,510
which you copy data from Bheema lock

00:40:13,730 --> 00:40:19,130
regions to bounce buffer and then copy

00:40:17,510 --> 00:40:23,930
from the bones buffer to the actual

00:40:19,130 --> 00:40:29,060
destination buffer spy controllers which

00:40:23,930 --> 00:40:30,920
also make use of bounce buffers but this

00:40:29,060 --> 00:40:33,470
is spread all over the all over the

00:40:30,920 --> 00:40:37,520
drivers and there is no common

00:40:33,470 --> 00:40:40,550
implementation as such so one of the

00:40:37,520 --> 00:40:43,520
questions that keep coming up on spy or

00:40:40,550 --> 00:40:46,630
MTD mailing list is can DMA mapping da

00:40:43,520 --> 00:40:48,380
TMI mapping ApS that are generic

00:40:46,630 --> 00:40:50,030
implementations that are there in the

00:40:48,380 --> 00:40:53,570
kernel can that be modified to support

00:40:50,030 --> 00:40:56,120
the malach buffers for DMA

00:40:53,570 --> 00:41:00,760
in a same way so that it could

00:40:56,120 --> 00:41:03,500
with all the driver frameworks and if

00:41:00,760 --> 00:41:06,520
mapping such buffers is not possible

00:41:03,500 --> 00:41:08,840
whether it is possible to provide a

00:41:06,520 --> 00:41:11,000
bonds buffer generic bonds before

00:41:08,840 --> 00:41:13,520
implementation within the DMA framework

00:41:11,000 --> 00:41:26,690
itself so that all drivers can make use

00:41:13,520 --> 00:41:29,060
of it on its own this here are some of

00:41:26,690 --> 00:41:32,510
the references that I used to make this

00:41:29,060 --> 00:41:35,810
presentation and I would like to thank

00:41:32,510 --> 00:41:38,150
Texas Instruments for sponsoring my

00:41:35,810 --> 00:41:39,830
travel and the next foundation for

00:41:38,150 --> 00:41:43,370
giving me an opportunity to speak at

00:41:39,830 --> 00:41:46,120
this location and with that I opened for

00:41:43,370 --> 00:41:46,120
question answers

00:41:53,090 --> 00:41:55,690
yes

00:42:46,369 --> 00:42:51,019
yeah that's y'all start device I don't

00:42:48,979 --> 00:42:53,299
think there is support for any type of

00:42:51,019 --> 00:42:58,239
real stock devices I mean you all

00:42:53,299 --> 00:42:58,239
stacked spy devices as of today

00:42:58,390 --> 00:43:05,709
okay the question was there are by not

00:43:02,660 --> 00:43:10,130
flashes which are dual stock that is

00:43:05,709 --> 00:43:14,680
there are two spy chips connected to a

00:43:10,130 --> 00:43:17,799
single chip select so you could erase

00:43:14,680 --> 00:43:21,229
64k sector but it will actually erase

00:43:17,799 --> 00:43:26,019
128k and how do you support those things

00:43:21,229 --> 00:43:26,019
and spine or framework that was the

00:43:31,150 --> 00:43:48,079
spine 9 is it ok ok there is a spine and

00:43:44,779 --> 00:43:52,009
ApS that are now available which should

00:43:48,079 --> 00:43:53,599
work with spine lines but we will have

00:43:52,009 --> 00:43:55,699
to explore how that can be merged with

00:43:53,599 --> 00:44:00,039
spine or controller I don't think you

00:43:55,699 --> 00:44:00,039
could directly use it toward requires

00:44:11,940 --> 00:44:14,599
yeah

00:44:32,380 --> 00:44:37,790
yeah the question was whether we could

00:44:35,270 --> 00:44:40,760
support device that supports both spine

00:44:37,790 --> 00:44:45,410
lines and spine arts I guess we'll need

00:44:40,760 --> 00:44:48,200
a I mean some common interface that can

00:44:45,410 --> 00:44:51,230
talk to both spine nine versus lore as

00:44:48,200 --> 00:45:08,390
well although it subtract obstructed at

00:44:51,230 --> 00:45:10,400
MTD develop level but yeah yeah we will

00:45:08,390 --> 00:45:12,080
need an SPI flash subsystem which is

00:45:10,400 --> 00:45:16,330
more generic and doesn't distinguish

00:45:12,080 --> 00:45:16,330
between nine and not yeah

00:45:28,440 --> 00:45:35,610
sorry any more questions okay thank you

00:45:32,530 --> 00:45:35,610

YouTube URL: https://www.youtube.com/watch?v=GJay1MCUvfE


