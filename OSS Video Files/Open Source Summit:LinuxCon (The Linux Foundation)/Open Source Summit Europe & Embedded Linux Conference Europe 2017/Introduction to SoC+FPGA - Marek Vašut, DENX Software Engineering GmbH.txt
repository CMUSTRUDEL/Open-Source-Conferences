Title: Introduction to SoC+FPGA - Marek Vašut, DENX Software Engineering GmbH
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	Introduction to SoC+FPGA - Marek Vašut, DENX Software Engineering GmbH

In this talk, Marek introduces the increasingly popular single-chip SoC+FPGA solutions. At the beginning, the diverse chip offerings from multiple vendors are introduced, ranging from the smallest IoT-grade solutions all the way to large industrial-level chips with focus on their software support. Mainline U-Boot and Linux support for such chips is quite complete and already deployed in production. Marek demonstrates how to load and operate the FPGA part in both U-Boot and Linux, which recently gained FPGA manager support. Yet to fully leverage the potential of the FPGA manager in combination with Device Tree (DT) Overlays, patches are still needed. Marek explains how the FPGA manager and the DT Overlays work, how they fit together and how to use them to obtain a great experience on SoC+FPGA, while pointing out various pitfalls.

About Marek Vašut
I have been contracting for DENX Software Engineering for a couple of years now. My primary responsibility is designing and implementing customer specific functionality. One important aspect of my work is leveraging the benefits of working inside the mainline Linux, U-Boot and OE / Yocto Project, explaining our customers the benefits of pushing the newly produced code back into mainline and effectively doing the contributions. I am therefore heavily involved with both mainline U-Boot and Linux kernel, be it my role as SoCFPGA and USB maintainer for U-Boot, MTD co-maintainer in Linux or others. My speaking experience includes giving talks at ELCE, LinuxCon Japan, EmbeddedWorld and various smaller events across Europe.
Captions: 
	00:00:00,030 --> 00:00:07,080
let's get started today I'm gonna talk

00:00:04,440 --> 00:00:10,650
about introduction to suckles fpga

00:00:07,080 --> 00:00:13,320
solution my name is Marek washer and

00:00:10,650 --> 00:00:14,309
first of all I would like to introduce

00:00:13,320 --> 00:00:18,539
myself

00:00:14,309 --> 00:00:20,580
I work as a contractor for a couple of

00:00:18,539 --> 00:00:24,330
companies but mostly for dank software

00:00:20,580 --> 00:00:27,539
engineering for the most part of my day

00:00:24,330 --> 00:00:29,369
job I do a Linux kernel engineering you

00:00:27,539 --> 00:00:37,200
would boot loader work over embedded

00:00:29,369 --> 00:00:39,629
work and I'm a maintainer in some way or

00:00:37,200 --> 00:00:44,879
the other in these projects I also do

00:00:39,629 --> 00:00:48,450
FPGA work but while I do that my work I

00:00:44,879 --> 00:00:51,120
don't do it as a professional FPGA

00:00:48,450 --> 00:00:55,739
designer so that's pretty much about it

00:00:51,120 --> 00:00:59,879
about me now about this talk I'll

00:00:55,739 --> 00:01:01,199
structured in this six parts first of

00:00:59,879 --> 00:01:04,799
all I would like to introduce you to

00:01:01,199 --> 00:01:06,560
what the SOC is what the FPGAs are what

00:01:04,799 --> 00:01:09,630
the combination is how it looks like

00:01:06,560 --> 00:01:13,979
what an FPGA is and so on so you get

00:01:09,630 --> 00:01:15,540
like the basic knowledge and and then I

00:01:13,979 --> 00:01:18,240
would like to go through all the

00:01:15,540 --> 00:01:22,080
available saw FPGA solutions here the

00:01:18,240 --> 00:01:23,939
small ones the big ones and finally how

00:01:22,080 --> 00:01:28,439
do you get the big ones running with

00:01:23,939 --> 00:01:31,979
Linux the right way so let's get right

00:01:28,439 --> 00:01:34,140
to the first part what is on SOC so I

00:01:31,979 --> 00:01:36,540
guess since we are at the embedded Linux

00:01:34,140 --> 00:01:40,439
conference most of you knows what an SOC

00:01:36,540 --> 00:01:43,619
is and system-on-chip that would be some

00:01:40,439 --> 00:01:45,270
sort of CPU core today mostly an arm

00:01:43,619 --> 00:01:48,450
core but they can they're gonna be like

00:01:45,270 --> 00:01:50,399
a maps risk 5 whatever with some

00:01:48,450 --> 00:01:52,740
peripherals that's put on a single piece

00:01:50,399 --> 00:01:55,470
of silicon from which you have some pads

00:01:52,740 --> 00:01:57,630
you can put it on your on your board and

00:01:55,470 --> 00:01:59,399
run some code and on the CPU core

00:01:57,630 --> 00:02:03,570
communicate with the outside world

00:01:59,399 --> 00:02:05,460
and a standard thing write an FPGA this

00:02:03,570 --> 00:02:08,610
is a little bit more complicated

00:02:05,460 --> 00:02:11,430
that's a programmable logic solution so

00:02:08,610 --> 00:02:21,270
it's again to simplify it it's a chip

00:02:11,430 --> 00:02:23,550
which again has a lot of iOS but but you

00:02:21,270 --> 00:02:25,739
can put some sort of user-defined logic

00:02:23,550 --> 00:02:27,780
function into the programmable logic so

00:02:25,739 --> 00:02:30,450
the chip will do something which you

00:02:27,780 --> 00:02:34,010
want you can define that on your own

00:02:30,450 --> 00:02:36,300
think of for example a UART

00:02:34,010 --> 00:02:38,280
you know you can program UART internet

00:02:36,300 --> 00:02:40,560
FPGA it will behave like a new art that

00:02:38,280 --> 00:02:42,269
sort of thing you can obviously put more

00:02:40,560 --> 00:02:46,440
complex stuff in there I'll talk about

00:02:42,269 --> 00:02:49,940
that in a bit more detail shortly now if

00:02:46,440 --> 00:02:52,410
you combine on SOC and an FPGA together

00:02:49,940 --> 00:02:54,150
then you get benefit of both so

00:02:52,410 --> 00:02:55,769
basically you have a single piece of

00:02:54,150 --> 00:02:58,409
silicon on which you have a CPU core

00:02:55,769 --> 00:03:00,150
like a hardware CPU core and a

00:02:58,409 --> 00:03:03,750
programmable piece of logic into which

00:03:00,150 --> 00:03:05,489
you can put whatever you need so let's

00:03:03,750 --> 00:03:07,769
talk a little bit more about the F page

00:03:05,489 --> 00:03:09,269
yes so I said this programmable logic

00:03:07,769 --> 00:03:11,430
you can put whatever you want into it

00:03:09,269 --> 00:03:15,620
but what should you really envision

00:03:11,430 --> 00:03:18,030
under the term programmable logic well

00:03:15,620 --> 00:03:20,370
think of a device which is reasonably

00:03:18,030 --> 00:03:23,879
high speed we're talking like hundreds

00:03:20,370 --> 00:03:26,819
of megahertz on the logic side it has

00:03:23,879 --> 00:03:28,319
plenty of iOS like hundreds maybe

00:03:26,819 --> 00:03:30,480
thousands of i/o this is what we are

00:03:28,319 --> 00:03:34,909
talking about it's extremely parallel

00:03:30,480 --> 00:03:34,909
because well you have like these

00:03:35,030 --> 00:03:40,080
hundreds of thousands of blocks which

00:03:37,290 --> 00:03:42,959
you can program in the FPGA and chain

00:03:40,080 --> 00:03:45,140
them together somehow so like everything

00:03:42,959 --> 00:03:48,330
happens in parallel and the FPGA and

00:03:45,140 --> 00:03:50,940
it's extremely useful for stuff like you

00:03:48,330 --> 00:03:54,900
know paralyzed for clothes think video

00:03:50,940 --> 00:03:57,659
processing you get some video data from

00:03:54,900 --> 00:03:59,459
let's see some video encoder you just

00:03:57,659 --> 00:04:02,010
push it into the FPGA you can have some

00:03:59,459 --> 00:04:03,930
sort of filter in the FPGA so you pipe

00:04:02,010 --> 00:04:05,760
them through the FPGA the filter is

00:04:03,930 --> 00:04:09,720
applied you capture them on the other

00:04:05,760 --> 00:04:11,939
side or yeah crypto for example you know

00:04:09,720 --> 00:04:13,980
it push a lot of data into the FPGA the

00:04:11,939 --> 00:04:15,209
crypto happens in parallel you capture

00:04:13,980 --> 00:04:15,650
them on the other side that sort of

00:04:15,209 --> 00:04:17,759
thing

00:04:15,650 --> 00:04:19,709
but you can do pretty much anything with

00:04:17,759 --> 00:04:22,930
the FPGA ASIC prototyping is another

00:04:19,709 --> 00:04:25,449
thing you can synthesize custom hardware

00:04:22,930 --> 00:04:27,430
walks into the FPGA you know that sort

00:04:25,449 --> 00:04:30,039
of stuff if you need like bazillion you

00:04:27,430 --> 00:04:31,840
arts well yeah knock yourself out just

00:04:30,039 --> 00:04:35,710
put them in the FPGA and you get

00:04:31,840 --> 00:04:37,539
bazillion new words there are multiple

00:04:35,710 --> 00:04:39,580
vendors of the FPGA so there's a lot of

00:04:37,539 --> 00:04:42,070
stuff to choose from silence out there

00:04:39,580 --> 00:04:43,870
are the big ones and then there are a

00:04:42,070 --> 00:04:49,270
lot of specialized smaller players like

00:04:43,870 --> 00:04:51,490
latest micro semi Cypress and so on now

00:04:49,270 --> 00:04:55,539
if you look into the FPGA and a little

00:04:51,490 --> 00:04:56,740
bit more detail the FPGA wonders will

00:04:55,539 --> 00:04:59,669
tell you like it's super difficult

00:04:56,740 --> 00:05:04,599
technology and so on it actually is not

00:04:59,669 --> 00:05:07,000
so this on the left is a schematic of an

00:05:04,599 --> 00:05:09,220
FPGA it's kind of simplified but that's

00:05:07,000 --> 00:05:11,470
pretty much all there is in the FPGA

00:05:09,220 --> 00:05:14,169
it's not that difficult so as you can

00:05:11,470 --> 00:05:15,970
see you like these are the i/o pads this

00:05:14,169 --> 00:05:19,180
is what is actually physically coming

00:05:15,970 --> 00:05:23,229
out of the chip and there are some Iowa

00:05:19,180 --> 00:05:25,419
adaptational units so like you can get

00:05:23,229 --> 00:05:28,330
like differential pairs out of the FPGA

00:05:25,419 --> 00:05:30,520
that happens on the i/o block sides you

00:05:28,330 --> 00:05:32,680
can get multiple different voltages on

00:05:30,520 --> 00:05:35,949
the i/o path of the FPGA is also done by

00:05:32,680 --> 00:05:37,530
the i/o box but ultimately that is

00:05:35,949 --> 00:05:40,360
connected into this blue

00:05:37,530 --> 00:05:42,010
all-encompassing goo which is called the

00:05:40,360 --> 00:05:45,130
the global interconnect and it connects

00:05:42,010 --> 00:05:46,630
everything in the fpga together and it

00:05:45,130 --> 00:05:48,010
can be reprogrammed so you can wire it

00:05:46,630 --> 00:05:52,770
pretty much in any way you want it's

00:05:48,010 --> 00:05:54,940
like this massive big patch board now

00:05:52,770 --> 00:05:56,979
the other thing which is connected into

00:05:54,940 --> 00:05:59,919
the global interconnect is this red

00:05:56,979 --> 00:06:02,440
blobs which are the places where we

00:05:59,919 --> 00:06:04,599
synthesize your logic actually these are

00:06:02,440 --> 00:06:06,490
called the logic array blocks in all

00:06:04,599 --> 00:06:09,759
there are power lines in tilings I

00:06:06,490 --> 00:06:11,979
believe it is CL B's and this is

00:06:09,759 --> 00:06:13,870
actually where you define the logic

00:06:11,979 --> 00:06:15,430
functions now if you have these blocks

00:06:13,870 --> 00:06:17,490
where you can define your logic function

00:06:15,430 --> 00:06:19,659
and like combine them together by

00:06:17,490 --> 00:06:23,110
programming the global internet can

00:06:19,659 --> 00:06:25,210
effectively assemble together any sort

00:06:23,110 --> 00:06:27,220
of logical function so that's how the

00:06:25,210 --> 00:06:29,889
FPGA works internally

00:06:27,220 --> 00:06:31,990
actually if we look a little bit more in

00:06:29,889 --> 00:06:33,820
detail on this logic or I blog it's

00:06:31,990 --> 00:06:36,130
actually a little bit more complicated

00:06:33,820 --> 00:06:38,470
but not that much

00:06:36,130 --> 00:06:39,970
it's assembled from multiple logic

00:06:38,470 --> 00:06:42,970
elements which have the smallest

00:06:39,970 --> 00:06:44,770
building blocks you can see it here and

00:06:42,970 --> 00:06:46,960
this logic elements are actually

00:06:44,770 --> 00:06:48,280
connected together by local interconnect

00:06:46,960 --> 00:06:52,360
but that's like just a small

00:06:48,280 --> 00:06:55,660
optimization so that you avoid signal

00:06:52,360 --> 00:06:58,270
propagation delays if you go all the way

00:06:55,660 --> 00:06:59,950
down you reach the logic government

00:06:58,270 --> 00:07:02,080
which looks internally like that so it's

00:06:59,950 --> 00:07:04,930
just a lookup table with multiple inputs

00:07:02,080 --> 00:07:07,990
and optionally a register which allows

00:07:04,930 --> 00:07:11,080
you to assemble both combinatorial and

00:07:07,990 --> 00:07:15,100
sequential logic and ultimately if you

00:07:11,080 --> 00:07:17,940
change these together in some way which

00:07:15,100 --> 00:07:21,480
you need it you can assemble any sort of

00:07:17,940 --> 00:07:25,960
digital logic block from that be it

00:07:21,480 --> 00:07:27,970
simple thing is you are be it USB 3

00:07:25,960 --> 00:07:31,570
controller or whatever so that's how the

00:07:27,970 --> 00:07:34,240
FPGA is work now why would you want to

00:07:31,570 --> 00:07:40,990
have a sock to the FPGA on your on your

00:07:34,240 --> 00:07:46,660
like board right so you can look at it

00:07:40,990 --> 00:07:49,810
in two ways one way is you need

00:07:46,660 --> 00:07:52,840
something special like you need a CPU

00:07:49,810 --> 00:07:55,630
which has like crazy amount of whatever

00:07:52,840 --> 00:07:57,220
you are it's right so no one will make

00:07:55,630 --> 00:07:59,500
you such a CPU and if you would decided

00:07:57,220 --> 00:08:01,960
ok I want a nice egg it will be crazy

00:07:59,500 --> 00:08:04,930
expensive and if it's so small round

00:08:01,960 --> 00:08:07,830
it's more cost efficient to just put in

00:08:04,930 --> 00:08:10,570
a socket PGA put the CPU there with the

00:08:07,830 --> 00:08:14,640
FPGA and just synthesize the you arts

00:08:10,570 --> 00:08:18,000
into the FPGA right the other thing is

00:08:14,640 --> 00:08:19,930
why don't you put the CPU into the FPGA

00:08:18,000 --> 00:08:20,410
that's looking at it the other way

00:08:19,930 --> 00:08:23,560
around

00:08:20,410 --> 00:08:25,840
well the reason for that is if you put a

00:08:23,560 --> 00:08:27,520
CPU into the FPGA it will cost a

00:08:25,840 --> 00:08:31,150
tremendous amount of resources in the

00:08:27,520 --> 00:08:32,560
FPGA and I mentioned that the FPGA

00:08:31,150 --> 00:08:34,660
fabric is running in hundreds of

00:08:32,560 --> 00:08:37,690
megahertz range but if you put something

00:08:34,660 --> 00:08:39,700
complex in there the speed of the fabric

00:08:37,690 --> 00:08:41,530
kind of decreases because you need to

00:08:39,700 --> 00:08:44,169
handle signal propagation device through

00:08:41,530 --> 00:08:45,880
all the elements in the FPGA so

00:08:44,169 --> 00:08:48,640
ultimately the CPU will waste a lot of

00:08:45,880 --> 00:08:50,580
your FPGA resources and be slow so

00:08:48,640 --> 00:08:52,720
that's not great either

00:08:50,580 --> 00:08:54,340
but if you just need some specialized

00:08:52,720 --> 00:08:57,580
hardware the circuit BGA is kinda nice

00:08:54,340 --> 00:09:02,760
compromise now are there any questions

00:08:57,580 --> 00:09:02,760
to this intro sort of part force of FPGA

00:09:06,210 --> 00:09:13,990
no good so okay let's get to the second

00:09:11,500 --> 00:09:16,300
part what's available actually the

00:09:13,990 --> 00:09:18,370
entire landscape is covered so from the

00:09:16,300 --> 00:09:24,240
like super small devices all the way to

00:09:18,370 --> 00:09:28,720
the biggest ones with like our cortex

00:09:24,240 --> 00:09:29,950
a53 it's the big ones they aren't 64 so

00:09:28,720 --> 00:09:32,440
first of all I would like to go through

00:09:29,950 --> 00:09:34,330
the Cypress devices which are like super

00:09:32,440 --> 00:09:35,589
small they cannot actually run Linux but

00:09:34,330 --> 00:09:38,740
they are pretty interesting in my

00:09:35,589 --> 00:09:41,110
opinion originally this came from 8051

00:09:38,740 --> 00:09:43,960
with some analog blocks the background

00:09:41,110 --> 00:09:47,560
story is that these devices were using

00:09:43,960 --> 00:09:49,750
like smoke detectors and every smoke

00:09:47,560 --> 00:09:53,290
detector is kind of specific in its own

00:09:49,750 --> 00:09:55,330
way and like designing the analog

00:09:53,290 --> 00:09:58,570
circuitry over and over again was kind

00:09:55,330 --> 00:10:01,150
of boring right so what they came up

00:09:58,570 --> 00:10:03,580
with let's put a small CPU core into

00:10:01,150 --> 00:10:06,010
there and then programmable analog mash

00:10:03,580 --> 00:10:07,960
which can be configured in some way or

00:10:06,010 --> 00:10:11,650
the other and like the blocks could be

00:10:07,960 --> 00:10:13,450
chained together and tweaked so that the

00:10:11,650 --> 00:10:15,970
vendors of these smoke detectors could

00:10:13,450 --> 00:10:18,670
just buy one chip and then just load the

00:10:15,970 --> 00:10:20,200
programmable part of it now this was the

00:10:18,670 --> 00:10:23,250
beginning but right now they have like a

00:10:20,200 --> 00:10:25,810
newer bigger parts with arm cortex-m and

00:10:23,250 --> 00:10:28,180
they grew optional digital blocks

00:10:25,810 --> 00:10:29,650
Bluetooth le and so on it can run RTOS

00:10:28,180 --> 00:10:31,810
and it's pretty interesting in my

00:10:29,650 --> 00:10:35,370
opinion and you can get a kit for like

00:10:31,810 --> 00:10:38,500
10 bucks somewhere so the downside is

00:10:35,370 --> 00:10:42,310
the tool is Windows only to program

00:10:38,500 --> 00:10:44,380
these but in fact the to only generates

00:10:42,310 --> 00:10:48,190
like all the register block which you

00:10:44,380 --> 00:10:49,900
need to program into that well the piece

00:10:48,190 --> 00:10:51,250
OGG and then the programmable logic is

00:10:49,900 --> 00:10:51,640
loaded and then you can do whatever you

00:10:51,250 --> 00:10:55,270
want

00:10:51,640 --> 00:10:58,510
so technically if you export this book

00:10:55,270 --> 00:11:01,480
into your our gos there is no problem

00:10:58,510 --> 00:11:02,590
basically plus there is a project called

00:11:01,480 --> 00:11:04,900
the

00:11:02,590 --> 00:11:07,780
piece of tools which is working on

00:11:04,900 --> 00:11:11,260
mapping this programmable block so there

00:11:07,780 --> 00:11:13,900
will be an open source tool well there

00:11:11,260 --> 00:11:16,570
is kind of open source - available

00:11:13,900 --> 00:11:17,890
work-in-progress if you're interested in

00:11:16,570 --> 00:11:19,630
these small things definitely check the

00:11:17,890 --> 00:11:22,320
piece of tools it might actually already

00:11:19,630 --> 00:11:24,820
be able to do whatever you want

00:11:22,320 --> 00:11:28,060
back to the proprietary tool it's

00:11:24,820 --> 00:11:29,530
basically like a schematic entry for the

00:11:28,060 --> 00:11:33,070
programmable part to make it easy for

00:11:29,530 --> 00:11:35,250
people so this is how it looks this is a

00:11:33,070 --> 00:11:38,230
thermo meter actually so here are some

00:11:35,250 --> 00:11:39,310
really schematic entry blocks once

00:11:38,230 --> 00:11:42,010
you're done with that you just click

00:11:39,310 --> 00:11:44,740
compile it spits out some main.c and

00:11:42,010 --> 00:11:46,930
Basilio and other C files so you can

00:11:44,740 --> 00:11:51,610
call like convenience functions yeah

00:11:46,930 --> 00:11:53,380
that sort of thing but again you can

00:11:51,610 --> 00:11:56,380
also like pull out the register

00:11:53,380 --> 00:11:58,570
programming from this to put it into

00:11:56,380 --> 00:12:00,370
your own rtos there are BSP available

00:11:58,570 --> 00:12:03,310
for free our toes

00:12:00,370 --> 00:12:05,290
you see OS key oh I believe as well just

00:12:03,310 --> 00:12:07,570
put it in there then get into the RTOS

00:12:05,290 --> 00:12:12,220
main function and then do whatever you

00:12:07,570 --> 00:12:15,550
want now let's move on to another one

00:12:12,220 --> 00:12:18,070
which is micro semi smart fusion - this

00:12:15,550 --> 00:12:20,680
one is actually a little better in that

00:12:18,070 --> 00:12:25,810
it's still cortex-m but it has DDR

00:12:20,680 --> 00:12:28,090
memory so it can run Linux the footing

00:12:25,810 --> 00:12:32,320
of this the Linux kernel port is like

00:12:28,090 --> 00:12:34,840
ancient vendor kernel I don't know

00:12:32,320 --> 00:12:40,030
something ancient and still you see

00:12:34,840 --> 00:12:42,250
Linux so not super amazing and yeah too

00:12:40,030 --> 00:12:45,490
bad but it's also mostly targeted at

00:12:42,250 --> 00:12:47,800
running our TOS solutions you can get a

00:12:45,490 --> 00:12:50,500
kid for like hundred twenty-five bucks I

00:12:47,800 --> 00:12:52,540
actually tried getting this going

00:12:50,500 --> 00:12:54,900
I installed their development tool which

00:12:52,540 --> 00:12:59,290
is called the Barrow and here is how to

00:12:54,900 --> 00:13:01,960
how to get it installed it's kind of

00:12:59,290 --> 00:13:03,010
complicated so you might want to read it

00:13:01,960 --> 00:13:06,130
once I'm done with the presentation

00:13:03,010 --> 00:13:08,610
anyways but this is not all of it

00:13:06,130 --> 00:13:12,220
actually once you get through all this

00:13:08,610 --> 00:13:14,830
annoying stuff to get the Libero

00:13:12,220 --> 00:13:16,420
installed you then need to search the

00:13:14,830 --> 00:13:18,550
internet to find all this mess

00:13:16,420 --> 00:13:22,930
income tations and magic variables which

00:13:18,550 --> 00:13:26,110
you need to specify and your which you

00:13:22,930 --> 00:13:28,900
need to export in their shell to even

00:13:26,110 --> 00:13:30,700
allow the Libero to lounge and if you

00:13:28,900 --> 00:13:33,490
don't have all of them actually running

00:13:30,700 --> 00:13:37,740
and exported then libera will kind of

00:13:33,490 --> 00:13:40,330
start but it will fail at random places

00:13:37,740 --> 00:13:42,880
so yeah there is a lot of hassle with

00:13:40,330 --> 00:13:45,600
that and ultimately I wanted to show you

00:13:42,880 --> 00:13:48,580
how the u-boot and use linux works but

00:13:45,600 --> 00:13:51,850
even flashing the demo image didn't get

00:13:48,580 --> 00:13:54,430
me a serial console so I don't know

00:13:51,850 --> 00:13:56,620
maybe I'm getting something wrong yeah

00:13:54,430 --> 00:13:59,200
and obviously no upstream support for

00:13:56,620 --> 00:14:01,450
tests at all it would be real nice if

00:13:59,200 --> 00:14:02,950
someone actually bought that kit and

00:14:01,450 --> 00:14:05,710
caught it upstream that would be super

00:14:02,950 --> 00:14:07,840
nice and actually I would be super happy

00:14:05,710 --> 00:14:10,840
to help you out getting it upstream into

00:14:07,840 --> 00:14:13,690
u-boot maybe also Linux if I can help

00:14:10,840 --> 00:14:14,970
there so if you have any interest that

00:14:13,690 --> 00:14:18,100
would be amazing

00:14:14,970 --> 00:14:19,690
so that's pretty much it for the

00:14:18,100 --> 00:14:21,370
cortex-m ones for the small ones now

00:14:19,690 --> 00:14:23,260
let's go to the linux once

00:14:21,370 --> 00:14:28,590
is there any are there any questions for

00:14:23,260 --> 00:14:33,190
the cortex-m once is there anything No

00:14:28,590 --> 00:14:35,470
okay so getting to the cortex a once the

00:14:33,190 --> 00:14:36,940
altar of Sergey is like the first one I

00:14:35,470 --> 00:14:41,560
have in the list just because it's

00:14:36,940 --> 00:14:44,020
starting from a it's cortex a9 so it's a

00:14:41,560 --> 00:14:49,480
little bit older core but its ARM Cortex

00:14:44,020 --> 00:14:50,830
a they have it in both UMP and SMP

00:14:49,480 --> 00:14:55,140
configuration with the standard

00:14:50,830 --> 00:14:59,140
peripherals on the Sox I'd like an SPI

00:14:55,140 --> 00:15:00,790
DDR DRAM this sort of usual stuff ultra

00:14:59,140 --> 00:15:04,420
has an upcoming strat extend which will

00:15:00,790 --> 00:15:07,600
be arm 64 this stuff runs the usual

00:15:04,420 --> 00:15:10,720
stack so you boot Linux there are rtos

00:15:07,600 --> 00:15:13,870
offerings where it is but that's not the

00:15:10,720 --> 00:15:16,660
main target now there is another kind of

00:15:13,870 --> 00:15:18,520
interesting quirk for the Alta Ram it is

00:15:16,660 --> 00:15:20,800
capable of running in this a MP

00:15:18,520 --> 00:15:23,080
configuration which means you can run

00:15:20,800 --> 00:15:26,230
like Linux on one core and RTOS on the

00:15:23,080 --> 00:15:27,280
other so in case you need like some

00:15:26,230 --> 00:15:29,769
special

00:15:27,280 --> 00:15:31,959
real-time hard real-time control you can

00:15:29,769 --> 00:15:34,149
1cor and linux will be doing I don't

00:15:31,959 --> 00:15:37,629
know like some sort of you I think on

00:15:34,149 --> 00:15:39,610
the other core so if you delve into the

00:15:37,629 --> 00:15:42,670
Altera I will definitely run into the

00:15:39,610 --> 00:15:44,139
Quartus designed to now I believe it's

00:15:42,670 --> 00:15:47,170
called until I speciate was at this

00:15:44,139 --> 00:15:49,660
point its proprietary but unlike the

00:15:47,170 --> 00:15:54,279
previous design tools it runs fine on

00:15:49,660 --> 00:15:55,779
Linux for certain definitions of fine it

00:15:54,279 --> 00:15:57,699
doesn't crash out of the box and if you

00:15:55,779 --> 00:16:00,519
install it it actually starts and does

00:15:57,699 --> 00:16:02,319
its thing so it's not that terrible if

00:16:00,519 --> 00:16:03,910
you're interested in something open

00:16:02,319 --> 00:16:05,470
source in terms of all there are there's

00:16:03,910 --> 00:16:09,519
project typhoon so you might want to

00:16:05,470 --> 00:16:11,589
look it up or talk to me about that but

00:16:09,519 --> 00:16:13,179
once you get through the quarters you

00:16:11,589 --> 00:16:15,660
all obviously want to boot your device

00:16:13,179 --> 00:16:19,629
and I would like to talk about that a

00:16:15,660 --> 00:16:21,999
little so you have the obvious options

00:16:19,629 --> 00:16:24,069
you boot vendor you booth or main line

00:16:21,999 --> 00:16:27,040
you boot on Altera just go for main line

00:16:24,069 --> 00:16:28,720
new route unless you have Aria ten-four

00:16:27,040 --> 00:16:31,929
this is kind of work in progress and

00:16:28,720 --> 00:16:33,790
strat extend this is also submitted so

00:16:31,929 --> 00:16:36,610
all the generation 5 stuff that's

00:16:33,790 --> 00:16:39,249
support and main line you boot the FPGA

00:16:36,610 --> 00:16:40,779
loading works everything works if there

00:16:39,249 --> 00:16:44,259
is a bug in main line you it is actually

00:16:40,779 --> 00:16:46,179
back it's not a missing feature otherö

00:16:44,259 --> 00:16:49,269
has some you would butts like engine

00:16:46,179 --> 00:16:52,569
then it's just not worth even looking at

00:16:49,269 --> 00:16:54,429
it there is another thing if you're a

00:16:52,569 --> 00:16:56,860
super hostile to GPL there is a

00:16:54,429 --> 00:16:59,350
bootloader called MPL it's BSD license

00:16:56,860 --> 00:17:01,179
that's basically loads binary into Ram

00:16:59,350 --> 00:17:02,799
and I execute it and it's like super

00:17:01,179 --> 00:17:05,740
sucks because all the bugs which are

00:17:02,799 --> 00:17:07,750
fixed in this off there are vendor you

00:17:05,740 --> 00:17:09,339
booth and all the other bugs which are

00:17:07,750 --> 00:17:11,709
actually fixed in mainline are still

00:17:09,339 --> 00:17:14,789
there so sometimes it fails to calibrate

00:17:11,709 --> 00:17:14,789
Ram and this sort of thing

00:17:20,679 --> 00:17:28,039
whoa what happened is okay well yeah it

00:17:26,480 --> 00:17:29,720
seems to work I was just like getting

00:17:28,039 --> 00:17:34,250
ready to deliver the finishing blow for

00:17:29,720 --> 00:17:37,340
this bootloader and completely lost my

00:17:34,250 --> 00:17:47,179
traction here yeah so this one sucks

00:17:37,340 --> 00:17:49,539
I just don't use it okay so now let's

00:17:47,179 --> 00:17:51,230
get back to the external support

00:17:49,539 --> 00:17:53,059
situation is kind of the same but

00:17:51,230 --> 00:17:55,279
authorize doing the good thing that

00:17:53,059 --> 00:17:56,510
they're kind of tracking main line so

00:17:55,279 --> 00:17:58,370
the vendor care and all the releases are

00:17:56,510 --> 00:18:01,429
kind of close to main line there's like

00:17:58,370 --> 00:18:03,830
a couple of patches on top of it then

00:18:01,429 --> 00:18:05,570
again you can use mainline and there is

00:18:03,830 --> 00:18:08,360
not that much functionality missing in

00:18:05,570 --> 00:18:11,559
mainline what is missing for the most

00:18:08,360 --> 00:18:15,590
part on the sock side it's all there and

00:18:11,559 --> 00:18:19,330
I don't think anything is missing on the

00:18:15,590 --> 00:18:22,789
fpga side configure us DTO overlays

00:18:19,330 --> 00:18:24,950
definitely missing the FPGA manager is

00:18:22,789 --> 00:18:27,110
already in mainline I didn't update my

00:18:24,950 --> 00:18:29,270
slides properly so this isn't mainline

00:18:27,110 --> 00:18:31,730
yeah and I believe it's just the DTO

00:18:29,270 --> 00:18:34,730
support for like loading the FPGA and

00:18:31,730 --> 00:18:37,880
then finding the drivers to what's in

00:18:34,730 --> 00:18:41,830
the FPGA now actually there will be a

00:18:37,880 --> 00:18:45,169
device tree overlay buff now today at

00:18:41,830 --> 00:18:47,720
6:00 is it at 6:00 so if you're

00:18:45,169 --> 00:18:50,090
interested in like loading FPS with

00:18:47,720 --> 00:18:53,350
videos and details in general come to

00:18:50,090 --> 00:19:01,520
the buff definitely gonna be interesting

00:18:53,350 --> 00:19:03,380
so I'll get to that in a bit actually

00:19:01,520 --> 00:19:07,220
once I'm done with the thing I'll get to

00:19:03,380 --> 00:19:10,640
loading it with into there so yeah okay

00:19:07,220 --> 00:19:13,039
let me get through the sync now silence

00:19:10,640 --> 00:19:15,649
has two offerings cortex a9 and the

00:19:13,039 --> 00:19:19,789
that's the thing 7000 and the new one a

00:19:15,649 --> 00:19:22,039
syncope that's our v8 a 53 it's again

00:19:19,789 --> 00:19:26,780
the same thing on the sock side you get

00:19:22,039 --> 00:19:30,860
SD MMC SPI nor DD arc

00:19:26,780 --> 00:19:33,200
and the usual stuff actually signings

00:19:30,860 --> 00:19:34,640
decided that will sing MP they will put

00:19:33,200 --> 00:19:36,440
in more interesting stuff like

00:19:34,640 --> 00:19:39,560
multimedia stuff that's why they put in

00:19:36,440 --> 00:19:42,170
like a VP U and the GPU except the

00:19:39,560 --> 00:19:45,350
problem is they put in a r mali-400 GPU

00:19:42,170 --> 00:19:46,670
which is like ancient and it's kind of

00:19:45,350 --> 00:19:49,910
sucks because there is an open-source

00:19:46,670 --> 00:19:53,300
driver unlike for example imx6 which has

00:19:49,910 --> 00:19:55,850
the at Navi which is amazing so

00:19:53,300 --> 00:19:59,330
Damali that's basically just blobs and

00:19:55,850 --> 00:20:03,620
it's like ancient blobs GBM support is

00:19:59,330 --> 00:20:07,550
missing if you want to run like modern

00:20:03,620 --> 00:20:09,590
Linux 3d graphics stack just forget it

00:20:07,550 --> 00:20:12,830
you're basically stuck with either x11

00:20:09,590 --> 00:20:15,500
or battling the blobs so the upside is

00:20:12,830 --> 00:20:18,260
that recently there has been a new

00:20:15,500 --> 00:20:19,970
activity in the limo driver and it is

00:20:18,260 --> 00:20:22,220
now possible to actually use it on Xing

00:20:19,970 --> 00:20:24,920
MP and to such an extent that it can do

00:20:22,220 --> 00:20:26,150
off-screen rendering so if you are

00:20:24,920 --> 00:20:28,460
interested in that part you should

00:20:26,150 --> 00:20:31,400
definitely check the limo driver there

00:20:28,460 --> 00:20:34,400
is a guy from China actually writing a

00:20:31,400 --> 00:20:37,580
new shader compiler for the mali-400 and

00:20:34,400 --> 00:20:40,760
it's super exciting so this this is

00:20:37,580 --> 00:20:42,440
really making me happy to see that and

00:20:40,760 --> 00:20:46,160
with a little patch it can work on on

00:20:42,440 --> 00:20:49,760
the sink so that's great now except for

00:20:46,160 --> 00:20:51,380
the GPU the stack is usually same to you

00:20:49,760 --> 00:20:54,890
boot Linux I think really that

00:20:51,380 --> 00:20:58,460
interesting rtos sports again exists the

00:20:54,890 --> 00:21:00,710
cmp has the perk that it has cortex at 5

00:20:58,460 --> 00:21:05,540
I believe so if you need like an RTOS

00:21:00,710 --> 00:21:06,920
capable core use that one otherwise

00:21:05,540 --> 00:21:09,500
let's let's move on to the software

00:21:06,920 --> 00:21:12,200
support in case of tiling is Vivaro

00:21:09,500 --> 00:21:15,050
again it's kinda on par with the Altera

00:21:12,200 --> 00:21:17,810
stuff so for the exiling is Vivaro it's

00:21:15,050 --> 00:21:21,320
again proprietary it's big but it kind

00:21:17,810 --> 00:21:23,690
of works right now there is also open

00:21:21,320 --> 00:21:25,850
source solution for the zinc 7000 in the

00:21:23,690 --> 00:21:30,020
works so like they are analyzing the bed

00:21:25,850 --> 00:21:31,430
stream for Madam's work-in-progress it's

00:21:30,020 --> 00:21:36,740
actually done by the same guy who did

00:21:31,430 --> 00:21:38,510
the the ice storm project so if you're

00:21:36,740 --> 00:21:39,090
interested in that look around the store

00:21:38,510 --> 00:21:44,280
approach

00:21:39,090 --> 00:21:46,470
look for his using stuff now we're

00:21:44,280 --> 00:21:48,480
saying you have two options again with

00:21:46,470 --> 00:21:50,910
the bootloader again one of them is you

00:21:48,480 --> 00:21:53,630
boot if you have like zinc 7000 use

00:21:50,910 --> 00:21:57,750
mainline you boots just no-brainer its

00:21:53,630 --> 00:21:59,010
support is there and just works on those

00:21:57,750 --> 00:22:00,690
Ingham P things are a little more

00:21:59,010 --> 00:22:03,210
complicated because this is a new chip

00:22:00,690 --> 00:22:05,280
and the upstream support is still work

00:22:03,210 --> 00:22:08,070
in progress so it's like going into

00:22:05,280 --> 00:22:12,180
mainline but your mileage may or you may

00:22:08,070 --> 00:22:14,250
worry all at war if you think mainline

00:22:12,180 --> 00:22:16,920
has all you need for the Seng impede and

00:22:14,250 --> 00:22:19,290
just use mainline if not there is this

00:22:16,920 --> 00:22:21,960
combination of FSB l+ cubed which is

00:22:19,290 --> 00:22:24,630
what's eiling's recommends so they have

00:22:21,960 --> 00:22:26,550
their own patch to boot was the FSB L

00:22:24,630 --> 00:22:28,710
which is like a pre loader which in it's

00:22:26,550 --> 00:22:30,810
the chip loads the FPGA welds power

00:22:28,710 --> 00:22:34,080
management unit and then starts you boot

00:22:30,810 --> 00:22:35,610
basically so if you're missing something

00:22:34,080 --> 00:22:37,650
from mainline which is kind of critical

00:22:35,610 --> 00:22:39,330
and you cannot really use mainline you

00:22:37,650 --> 00:22:42,740
boot that's what you will have to use

00:22:39,330 --> 00:22:46,380
but this is only thing MP sort of thing

00:22:42,740 --> 00:22:48,150
Linux support yeah it's again comparable

00:22:46,380 --> 00:22:53,220
to out there are pretty much on the same

00:22:48,150 --> 00:22:55,410
7000 most of the IP blocks are supposed

00:22:53,220 --> 00:22:59,970
supported in mainline already in like

00:22:55,410 --> 00:23:01,830
recent four point x four point one X for

00:22:59,970 --> 00:23:05,820
the Singh MP e that's kind of coming in

00:23:01,830 --> 00:23:08,550
now as we speak it's just being fed into

00:23:05,820 --> 00:23:10,650
the mainline what is again missing is

00:23:08,550 --> 00:23:13,440
the configure vast support for loading

00:23:10,650 --> 00:23:15,420
the DTO s actually the FPGA manager is

00:23:13,440 --> 00:23:19,440
also in mainline both for the singing

00:23:15,420 --> 00:23:22,140
singing P the vendor Colonel well there

00:23:19,440 --> 00:23:26,250
is like a stack of 600 patches on the

00:23:22,140 --> 00:23:29,700
chi links you can probably cut it down

00:23:26,250 --> 00:23:31,500
to like 200 if you throw away everything

00:23:29,700 --> 00:23:33,780
which you don't need that's kind of the

00:23:31,500 --> 00:23:38,580
state of the exiling expander kernel on

00:23:33,780 --> 00:23:40,980
top of 4.9 so yeah to answer your

00:23:38,580 --> 00:23:43,230
question there we go right

00:23:40,980 --> 00:23:45,390
so how to get these words booting kind

00:23:43,230 --> 00:23:49,190
of comparative analysis together you

00:23:45,390 --> 00:23:51,360
would working on both of these sub FPGAs

00:23:49,190 --> 00:23:53,550
on Altera

00:23:51,360 --> 00:23:58,550
you start quarters just compile your

00:23:53,550 --> 00:24:02,220
project it allows you to then run this

00:23:58,550 --> 00:24:04,710
BSP editor tool which will generate you

00:24:02,220 --> 00:24:06,570
some header files use a qts filter

00:24:04,710 --> 00:24:08,070
script which is from mainline new boot

00:24:06,570 --> 00:24:10,140
there we go

00:24:08,070 --> 00:24:12,600
so this QT s filter will take these

00:24:10,140 --> 00:24:14,730
files generated by the Quartus BSP

00:24:12,600 --> 00:24:17,520
editor make them a little civilized so

00:24:14,730 --> 00:24:19,530
you can put them into the upstream you

00:24:17,520 --> 00:24:24,510
boots or three you put it into your like

00:24:19,530 --> 00:24:28,170
your board slash vendor slash board /

00:24:24,510 --> 00:24:29,550
qts then you just add sog avg AC and

00:24:28,170 --> 00:24:30,750
make file which you can copy from

00:24:29,550 --> 00:24:31,140
another board because there is nothing

00:24:30,750 --> 00:24:33,480
there

00:24:31,140 --> 00:24:34,950
everything else is controlled by device

00:24:33,480 --> 00:24:37,110
three you put in your device three and

00:24:34,950 --> 00:24:41,010
your board coefficient and type like

00:24:37,110 --> 00:24:44,160
make whoo defconn fake make it will

00:24:41,010 --> 00:24:46,440
generate this sort of SSP file you take

00:24:44,160 --> 00:24:50,420
this FB file and then like freighted

00:24:46,440 --> 00:24:53,280
either in your spi flash or put it into

00:24:50,420 --> 00:24:54,240
some specific offset on an SD card which

00:24:53,280 --> 00:24:56,070
i don't remember it's in the

00:24:54,240 --> 00:24:58,590
documentation for you boot so just check

00:24:56,070 --> 00:25:01,020
out the readme and then you like flick

00:24:58,590 --> 00:25:03,500
the port on and it starts everything

00:25:01,020 --> 00:25:05,970
works obviously because it's mainline

00:25:03,500 --> 00:25:09,090
then you use the fpga command to mode

00:25:05,970 --> 00:25:11,700
fpga if that's your thing but i would

00:25:09,090 --> 00:25:13,580
like advice against loading fpga and you

00:25:11,700 --> 00:25:16,710
boot if you don't have to just use the

00:25:13,580 --> 00:25:19,950
fpga manager and linux that's a better

00:25:16,710 --> 00:25:22,470
approach yet on the think it's quite

00:25:19,950 --> 00:25:25,560
similar fire up the design to without a

00:25:22,470 --> 00:25:28,790
compiler design click export hardware

00:25:25,560 --> 00:25:31,620
you get hdf file out of it

00:25:28,790 --> 00:25:34,170
yeah the HDF files actually secretly as

00:25:31,620 --> 00:25:37,380
a file so we just like type unzip who

00:25:34,170 --> 00:25:39,660
hdf it's just expands into a couple of

00:25:37,380 --> 00:25:42,270
files depending on which thing you have

00:25:39,660 --> 00:25:45,270
you get either PSU or PS seven in it

00:25:42,270 --> 00:25:47,720
files just again copy them into your

00:25:45,270 --> 00:25:50,370
board slash whatever

00:25:47,720 --> 00:25:53,160
copy and make file and couple of other

00:25:50,370 --> 00:25:57,390
missing files at config type make deaf

00:25:53,160 --> 00:26:00,390
config make you get a boot bin file this

00:25:57,390 --> 00:26:03,210
one again install either and to a fat

00:26:00,390 --> 00:26:04,680
per to fat partition on SD card that's a

00:26:03,210 --> 00:26:07,080
bit of a limitation i believe of the

00:26:04,680 --> 00:26:09,420
bootrom but this is something you'd have

00:26:07,080 --> 00:26:12,780
to check with skylynx or just put it on

00:26:09,420 --> 00:26:15,570
the beginning of SPI flash flick the

00:26:12,780 --> 00:26:20,490
board on it boots again use standard

00:26:15,570 --> 00:26:23,060
fpga command to load the fpga so does

00:26:20,490 --> 00:26:23,060
that answer your question

00:26:29,919 --> 00:26:32,919
right

00:26:33,920 --> 00:26:36,520
uh-huh

00:26:40,280 --> 00:26:50,750
Yeah right so you mean like thousand SD

00:26:43,730 --> 00:26:55,730
cards right right so yeah there will be

00:26:50,750 --> 00:26:57,170
definitely so the question is we have to

00:26:55,730 --> 00:26:58,970
manufacture like a thousand boards

00:26:57,170 --> 00:27:17,050
whether you put the initial you booth on

00:26:58,970 --> 00:27:17,050
those boards right okay right

00:27:28,490 --> 00:27:31,490
right

00:27:33,800 --> 00:27:36,980
yeah well if you have a script which

00:27:35,690 --> 00:27:40,340
programs your spi flash in the

00:27:36,980 --> 00:27:42,200
manufacturing then you just take this as

00:27:40,340 --> 00:27:44,830
a beef I'll just put it in this SPI

00:27:42,200 --> 00:27:44,830
flash that's it

00:27:47,710 --> 00:27:53,210
yeah actually with the Altera tools

00:27:50,180 --> 00:27:55,010
you said you use Aria right so with the

00:27:53,210 --> 00:27:56,540
alternative there is there's something

00:27:55,010 --> 00:27:58,940
which allows you to program the cue SPI

00:27:56,540 --> 00:28:03,560
flash directly do you say like this

00:27:58,940 --> 00:28:06,020
fubar to program cue SPI you need to

00:28:03,560 --> 00:28:09,200
jtech Portilla you actually need the

00:28:06,020 --> 00:28:11,900
blaster to for that but if you're like

00:28:09,200 --> 00:28:13,970
manufacturing it then you probably want

00:28:11,900 --> 00:28:18,640
some sort of like a toaster sort of

00:28:13,970 --> 00:28:18,640
device where you attach to the spi flash

00:28:19,210 --> 00:28:26,240
it's the same yeah thanks yeah right so

00:28:24,230 --> 00:28:30,170
I can move on from this one to the

00:28:26,240 --> 00:28:32,120
vendor can be a loading horror so thing

00:28:30,170 --> 00:28:34,310
is you want to reload the FPGA in the

00:28:32,120 --> 00:28:37,340
kernel right so the vendors came up with

00:28:34,310 --> 00:28:39,590
these interfaces like how do we do that

00:28:37,340 --> 00:28:41,180
well let's create a def interface into

00:28:39,590 --> 00:28:43,460
which you like you cat the bitstream in

00:28:41,180 --> 00:28:44,990
there and it programs the fhj and then

00:28:43,460 --> 00:28:46,880
let the user control the bridges between

00:28:44,990 --> 00:28:50,630
the FHA and and the SOC

00:28:46,880 --> 00:28:52,460
a problem is you kind of bind drivers to

00:28:50,630 --> 00:28:54,320
the stuff that's in the FPGA and you

00:28:52,460 --> 00:28:57,410
accidently reload the FPGA what happens

00:28:54,320 --> 00:29:00,530
there well it's game over it's like done

00:28:57,410 --> 00:29:03,020
so this doesn't work unless you have

00:29:00,530 --> 00:29:06,440
like a super especially strictly control

00:29:03,020 --> 00:29:08,090
the users switch you don't so there is a

00:29:06,440 --> 00:29:10,460
better way to do it and that's to use

00:29:08,090 --> 00:29:13,360
the device 3 overlays and again now

00:29:10,460 --> 00:29:17,180
Frank will probably bash me about that

00:29:13,360 --> 00:29:18,710
so device 3 overlays is a way to patch

00:29:17,180 --> 00:29:20,810
the device through which you load into

00:29:18,710 --> 00:29:22,990
your kernel to describe the hardware it

00:29:20,810 --> 00:29:26,660
so you can patch it at runtime with that

00:29:22,990 --> 00:29:28,760
and the idea is that you just described

00:29:26,660 --> 00:29:30,050
the additional part of the hardware

00:29:28,760 --> 00:29:32,810
which you are adding into the kernel

00:29:30,050 --> 00:29:34,670
just compile it like a usual device 3 it

00:29:32,810 --> 00:29:37,040
loaded into the kernel and something

00:29:34,670 --> 00:29:39,650
happens the kernel just recognizes the

00:29:37,040 --> 00:29:41,570
new hardware binds drivers and so on how

00:29:39,650 --> 00:29:43,070
does that look this entire process is

00:29:41,570 --> 00:29:46,130
actually super simple there is an

00:29:43,070 --> 00:29:47,240
example there so basically this is using

00:29:46,130 --> 00:29:50,809
the out of three

00:29:47,240 --> 00:29:53,870
don't forget us loader which is not

00:29:50,809 --> 00:29:56,690
gonna happen in mainline for a while but

00:29:53,870 --> 00:30:03,710
well it's kind of one of the only

00:29:56,690 --> 00:30:06,860
reasonable options now right yeah so the

00:30:03,710 --> 00:30:10,280
demo is that basically you create a sort

00:30:06,860 --> 00:30:12,890
of my detail directory in the configure

00:30:10,280 --> 00:30:16,429
bus device tree overlays compiler

00:30:12,890 --> 00:30:19,160
overlay just cat it into the CBO file

00:30:16,429 --> 00:30:22,160
the kernel has hoops for a that just

00:30:19,160 --> 00:30:24,200
loves the DTO patches its own device

00:30:22,160 --> 00:30:27,980
tree and the new devices basically pop

00:30:24,200 --> 00:30:29,929
up that's the gist of it anyway if you

00:30:27,980 --> 00:30:32,720
want to unload the DTO we can do that

00:30:29,929 --> 00:30:34,700
just remove the directory the overlay

00:30:32,720 --> 00:30:36,740
the right I don't know if that can be

00:30:34,700 --> 00:30:38,630
actually seen but you just do RM there

00:30:36,740 --> 00:30:39,350
on that directory and that's it it's

00:30:38,630 --> 00:30:43,610
that simple

00:30:39,350 --> 00:30:46,070
cool the rs3 overlay source looks pretty

00:30:43,610 --> 00:30:47,900
much a lot like a device tree just have

00:30:46,070 --> 00:30:50,900
this like plug-in annotation at the

00:30:47,900 --> 00:30:53,090
beginning and then you just describe the

00:30:50,900 --> 00:30:56,540
fragments which say okay a bachelor's

00:30:53,090 --> 00:30:59,330
Ethernet here what I want to add into

00:30:56,540 --> 00:31:01,520
this Ethernet node is that my mode this

00:30:59,330 --> 00:31:05,540
Archie mi I and I want to enable the

00:31:01,520 --> 00:31:08,690
ethernet this other case is that I want

00:31:05,540 --> 00:31:12,740
to add an 1891 EEPROM under and I Square

00:31:08,690 --> 00:31:15,380
C switch that's how it kind of DTO looks

00:31:12,740 --> 00:31:18,920
like now let's mix it up with the FPGA

00:31:15,380 --> 00:31:20,330
manager so FPGA manager is new framework

00:31:18,920 --> 00:31:22,160
and the Linux kernel which allows you to

00:31:20,330 --> 00:31:24,440
vote the bit streams into the FPGA yes

00:31:22,160 --> 00:31:27,500
it allows you to toggle the bridges

00:31:24,440 --> 00:31:30,020
correctly and if you combine it with the

00:31:27,500 --> 00:31:35,410
with the DT OS you are able to actually

00:31:30,020 --> 00:31:37,820
say okay so I have this bit stream and

00:31:35,410 --> 00:31:39,710
it creates devices under these bridges

00:31:37,820 --> 00:31:44,000
and they need to be enabled and they are

00:31:39,710 --> 00:31:46,460
like mapped like this and that so that's

00:31:44,000 --> 00:31:49,340
that's what I'm gonna show you now we

00:31:46,460 --> 00:31:52,190
actually have device 3 we actually have

00:31:49,340 --> 00:31:55,429
FPGA manager support for all the

00:31:52,190 --> 00:31:59,120
mainstream FPGA devices which is out

00:31:55,429 --> 00:32:00,920
there are everything tilings everything

00:31:59,120 --> 00:32:04,630
light as I see 40

00:32:00,920 --> 00:32:07,280
is there as well with SPI interface and

00:32:04,630 --> 00:32:11,600
yes it supports partial reconfiguration

00:32:07,280 --> 00:32:13,270
I haven't seen that used yet so how does

00:32:11,600 --> 00:32:16,640
it work okay

00:32:13,270 --> 00:32:19,700
again you describe what's in the FPGA in

00:32:16,640 --> 00:32:21,500
the DTO right you compile the DTO you

00:32:19,700 --> 00:32:23,480
load it into the kernel so first thing

00:32:21,500 --> 00:32:25,970
that happens is that the FPGA manager is

00:32:23,480 --> 00:32:27,860
actually triggered at lost the FPGA with

00:32:25,970 --> 00:32:30,580
the matching bit stream now the matching

00:32:27,860 --> 00:32:32,720
bit stream is fetched through the kernel

00:32:30,580 --> 00:32:34,070
firmware interface so it has to be

00:32:32,720 --> 00:32:36,470
somewhere in lit firm or something

00:32:34,070 --> 00:32:40,880
something RBF or something something bit

00:32:36,470 --> 00:32:42,740
Oryx eiling's the next thing is it

00:32:40,880 --> 00:32:45,950
enables the bridges between the SOC and

00:32:42,740 --> 00:32:46,700
the FPGA and finally only after that is

00:32:45,950 --> 00:32:48,860
already

00:32:46,700 --> 00:32:51,110
it can start binding the drivers now

00:32:48,860 --> 00:32:55,430
there's a quirk when you remove the DTO

00:32:51,110 --> 00:32:57,950
in that the bridges are shut well the

00:32:55,430 --> 00:33:00,500
drivers are unbound first then the

00:32:57,950 --> 00:33:02,150
bridges are shut off and ultimately the

00:33:00,500 --> 00:33:04,400
FPGA is not turned off

00:33:02,150 --> 00:33:06,380
the reason for that is that there can be

00:33:04,400 --> 00:33:08,750
something in the FPGA which you didn't

00:33:06,380 --> 00:33:10,550
describe and the device 3 overlay which

00:33:08,750 --> 00:33:13,520
can be super critical to the system and

00:33:10,550 --> 00:33:16,190
that can adjust down clock the FB here

00:33:13,520 --> 00:33:17,690
on program it because otherwise it could

00:33:16,190 --> 00:33:20,210
I don't know kill the system or kill

00:33:17,690 --> 00:33:22,250
somebody so that's why the FPGA remains

00:33:20,210 --> 00:33:25,790
programmed and running even after you

00:33:22,250 --> 00:33:28,940
unload the DTO so how does an FPGA

00:33:25,790 --> 00:33:32,680
manager dto looks like very similar to

00:33:28,940 --> 00:33:36,320
regular dto in this case I'm patching

00:33:32,680 --> 00:33:38,810
the bridge I create one FPGA area so

00:33:36,320 --> 00:33:41,930
that's the partial reconfiguration thing

00:33:38,810 --> 00:33:44,390
in this case I have only one area so the

00:33:41,930 --> 00:33:45,860
entire FPGA is populated by a single bit

00:33:44,390 --> 00:33:51,200
stream there we go

00:33:45,860 --> 00:33:54,080
in this case output file RPF and in this

00:33:51,200 --> 00:33:57,500
example I'm adding one single UART which

00:33:54,080 --> 00:34:00,950
is under this bridge which yes there we

00:33:57,500 --> 00:34:04,040
go yeah this bridge once I load this

00:34:00,950 --> 00:34:07,030
device 3 overlay this new you are will

00:34:04,040 --> 00:34:10,429
just pop up as the ftdi asks something

00:34:07,030 --> 00:34:11,870
that's the example now I should have

00:34:10,429 --> 00:34:13,280
some sort of conclusion but I just

00:34:11,870 --> 00:34:14,570
couldn't come up with what to put on

00:34:13,280 --> 00:34:17,750
this slide I have no idea

00:34:14,570 --> 00:34:20,120
well the mainline support for all the

00:34:17,750 --> 00:34:22,390
Soviet PJs is amazing obviously you

00:34:20,120 --> 00:34:26,630
should use it

00:34:22,390 --> 00:34:27,830
DTS upward while it's coming so thank

00:34:26,630 --> 00:34:38,290
you for your attention and do you have

00:34:27,830 --> 00:34:43,190
any questions thank you yeah okay so

00:34:38,290 --> 00:34:45,400
yeah yeah go ahead yeah go ahead yeah

00:34:43,190 --> 00:34:45,400
sure

00:34:53,010 --> 00:34:57,990
yeah

00:34:55,290 --> 00:34:59,850
yeah so the question was how does it

00:34:57,990 --> 00:35:01,410
work with the loading sequence so that

00:34:59,850 --> 00:35:04,950
the u-boot starts running and then what

00:35:01,410 --> 00:35:07,350
happens then right well I'll just use

00:35:04,950 --> 00:35:10,530
the altar as an example basically yes

00:35:07,350 --> 00:35:12,750
you boot comes up actually before you

00:35:10,530 --> 00:35:14,700
boot the CPU who comes up right it has

00:35:12,750 --> 00:35:19,500
to start reading from like address zero

00:35:14,700 --> 00:35:21,210
and this is in modern CPUs it's like a

00:35:19,500 --> 00:35:23,370
boot ROM in the CPU so there's like

00:35:21,210 --> 00:35:25,500
piece of code and baked into the CPU

00:35:23,370 --> 00:35:31,350
which cannot be replaced which is he PU

00:35:25,500 --> 00:35:36,120
starts executing from now that's there's

00:35:31,350 --> 00:35:37,500
actually hard cpu yeah as I said yeah so

00:35:36,120 --> 00:35:42,650
that starts executing from its internal

00:35:37,500 --> 00:35:45,270
boot ROM so to say now the boot ROM

00:35:42,650 --> 00:35:47,610
checks what the strapping of the CPU is

00:35:45,270 --> 00:35:51,120
and that X the boot media so in this

00:35:47,610 --> 00:35:52,860
case let's say SPI flash it loads some

00:35:51,120 --> 00:35:54,630
piece of the SPI flash into its own

00:35:52,860 --> 00:35:56,580
internal memory like an ass RAM or

00:35:54,630 --> 00:36:00,420
something from that it executes that's

00:35:56,580 --> 00:36:03,240
usually the you would SPL that thing

00:36:00,420 --> 00:36:03,900
initializes like the RAM basic pin

00:36:03,240 --> 00:36:05,640
muxing

00:36:03,900 --> 00:36:09,900
clocking that sort of stuff and then

00:36:05,640 --> 00:36:12,390
loads the actual you boot from again the

00:36:09,900 --> 00:36:14,280
boot media it can be the same it can be

00:36:12,390 --> 00:36:16,170
different depends on how we configure to

00:36:14,280 --> 00:36:18,930
SPL so the SPL is something which you

00:36:16,170 --> 00:36:22,500
can already replace is usually like 64

00:36:18,930 --> 00:36:24,800
okay again depends on the chip so once

00:36:22,500 --> 00:36:28,010
you have like the fool you boot running

00:36:24,800 --> 00:36:30,840
it's gonna can load whatever from

00:36:28,010 --> 00:36:32,580
whatever with media let's say the same

00:36:30,840 --> 00:36:34,950
boot media you can load Linux kernel

00:36:32,580 --> 00:36:37,230
from there you can load device 3 you can

00:36:34,950 --> 00:36:40,310
load FPGA bitstream whatever you want

00:36:37,230 --> 00:36:43,890
start a Linux kernel and from there it

00:36:40,310 --> 00:36:45,930
as usually yes it's not that surprising

00:36:43,890 --> 00:36:48,180
except for sometimes you need to load

00:36:45,930 --> 00:36:49,890
the FPGA you can do it in you boot you

00:36:48,180 --> 00:36:51,150
can do it in Linux it's preferred if you

00:36:49,890 --> 00:36:53,820
do it in Linux because then you have

00:36:51,150 --> 00:36:57,830
more control over this entire system

00:36:53,820 --> 00:36:57,830
that's so much more flexible

00:37:01,819 --> 00:37:06,749
that that's actually good question so

00:37:04,139 --> 00:37:08,489
yeah there was a question if the Linux

00:37:06,749 --> 00:37:10,709
and the FPGA are communicating through a

00:37:08,489 --> 00:37:11,069
regular CPU bus I should have mentioned

00:37:10,709 --> 00:37:15,149
that

00:37:11,069 --> 00:37:17,699
thank you there are actually AXI bridges

00:37:15,149 --> 00:37:20,219
on the altar aside and exiling site I

00:37:17,699 --> 00:37:31,789
believe there are also XE bridges right

00:37:20,219 --> 00:37:31,789
yeah so like standard bus yes right

00:37:32,180 --> 00:37:39,780
yes so the the common was that you can

00:37:35,640 --> 00:37:41,910
have also other like bridges in the FPGA

00:37:39,780 --> 00:37:43,589
it's like between AXI and SPI and the

00:37:41,910 --> 00:37:46,560
sort of thing yeah so you can synthesize

00:37:43,589 --> 00:37:49,470
anything into the FPGA done Thanks

00:37:46,560 --> 00:37:51,710
and the other questions yeah they're in

00:37:49,470 --> 00:37:51,710
the back

00:38:08,260 --> 00:38:12,340
yeah so the question is about high

00:38:09,910 --> 00:38:15,130
availability is it possible to like

00:38:12,340 --> 00:38:19,030
reboot this SOC without reloading the

00:38:15,130 --> 00:38:21,520
FPGA right now with the device three

00:38:19,030 --> 00:38:24,010
overlies it actually is not to my

00:38:21,520 --> 00:38:26,530
knowledge possible but what you can

00:38:24,010 --> 00:38:29,290
basically do is you can disable the dt

00:38:26,530 --> 00:38:32,830
OS and just say okay i load my fpga in

00:38:29,290 --> 00:38:35,980
you boot and keep it loaded and that's

00:38:32,830 --> 00:38:37,960
it right so just make linux not touch

00:38:35,980 --> 00:38:41,500
the fpga at all and just assume there is

00:38:37,960 --> 00:38:44,200
hardware there and if you reboot the

00:38:41,500 --> 00:38:47,350
system yeah just check whether the FPGA

00:38:44,200 --> 00:38:54,910
is loaded in you boot if not loaded if

00:38:47,350 --> 00:38:58,000
it is just use it you will have to check

00:38:54,910 --> 00:39:00,280
what state the bridges are in so if you

00:38:58,000 --> 00:39:01,480
want to access the content the FPGA you

00:39:00,280 --> 00:39:04,090
will have to make sure the bridges are

00:39:01,480 --> 00:39:05,800
enabled and you can do that once after

00:39:04,090 --> 00:39:08,859
you walk the FPGA and know that the

00:39:05,800 --> 00:39:11,109
content in the FPGA is valid then you

00:39:08,859 --> 00:39:14,740
can enable the bridges and just use the

00:39:11,109 --> 00:39:22,180
stuff in the FPGA thanks for the

00:39:14,740 --> 00:39:23,710
question does it always so there was a

00:39:22,180 --> 00:39:28,630
comment that Zink actually nukes the

00:39:23,710 --> 00:39:31,990
content of the FPGA on the reboot from

00:39:28,630 --> 00:39:33,790
someone in the in the audience I shall

00:39:31,990 --> 00:39:35,770
we can discuss that after the talk if

00:39:33,790 --> 00:39:41,190
you want some more does an interesting

00:39:35,770 --> 00:39:41,190
question thanks any more questions yeah

00:39:44,700 --> 00:39:50,089
I don't know it seems kind of died

00:39:55,830 --> 00:40:01,050
yeah so there was a comment from from

00:39:59,970 --> 00:40:04,080
friend mine

00:40:01,050 --> 00:40:06,180
he said that it's now called FPGA region

00:40:04,080 --> 00:40:10,470
or FPGA area because it just kind of

00:40:06,180 --> 00:40:18,950
changed thanks

00:40:10,470 --> 00:40:18,950
any more questions what

00:40:20,420 --> 00:40:24,760
yeah go ahead

00:40:46,220 --> 00:40:51,450
yes there was a question about the x86

00:40:49,200 --> 00:40:56,190
and device threes and the using videos

00:40:51,450 --> 00:40:58,440
and FPGAs so on x86 usually the FPGA is

00:40:56,190 --> 00:41:00,030
sitting on a PCI Express and you can

00:40:58,440 --> 00:41:03,720
definitely use device 3 for that right

00:41:00,030 --> 00:41:05,900
I'm you can describe PCI Express device

00:41:03,720 --> 00:41:14,670
in a device 3 no problem

00:41:05,900 --> 00:41:17,240
it's that flexible I didn't try it

00:41:14,670 --> 00:41:17,240
myself now

00:41:30,050 --> 00:41:33,050
super

00:41:34,670 --> 00:41:40,100
did you hear it back there otherwise

00:41:38,360 --> 00:41:42,950
just like come here we can discuss that

00:41:40,100 --> 00:41:45,140
because there is a guy who's digging in

00:41:42,950 --> 00:41:50,990
that stuff and it'd be great if we can

00:41:45,140 --> 00:41:52,580
discuss it together so if there are no

00:41:50,990 --> 00:41:54,820
more questions thank you for your

00:41:52,580 --> 00:41:54,820

YouTube URL: https://www.youtube.com/watch?v=R3gJhnGjjWY


