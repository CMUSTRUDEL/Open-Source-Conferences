Title: Using SoC Vendor HALs in the Zephyr Project - Maureen Helm, NXP Semiconductors
Publication date: 2017-10-25
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	Using SoC Vendor HALs in the Zephyr Project - Maureen Helm, NXP Semiconductors

The Zephyr OS is a small, scalable RTOS that supports a wide variety of SoCs, many of which have existing HALs provided by the SoC vendors, especially in the ARM Cortex-M world. These HALs provide peripheral register definitions and in many cases, include bare metal peripheral drivers. Rather than reinventing the wheel, the Zephyr Project decided to proactively reuse these vendor HALs whenever possible. This session will cover how and why the Zephyr Project uses SoC vendor HALs, what are the common problems, and how to address them.

About Maureen Helm
Maureen Helm is an MCU Software Architect at NXP Semiconductors and a member of the Zephyr Project TSC.
Captions: 
	00:00:00,000 --> 00:00:04,049
well thank you everybody for coming

00:00:01,140 --> 00:00:07,740
today my name is Maureen helm I'm a

00:00:04,049 --> 00:00:09,570
software engineer at nxb I've been

00:00:07,740 --> 00:00:11,730
working on this effort project for about

00:00:09,570 --> 00:00:13,259
a year and a half now maybe a little bit

00:00:11,730 --> 00:00:16,289
longer than that since we we launched

00:00:13,259 --> 00:00:17,460
last year at event world so today I

00:00:16,289 --> 00:00:20,460
wanted to come and talk to you guys

00:00:17,460 --> 00:00:23,430
about how we're using vendor house and

00:00:20,460 --> 00:00:25,529
the Zephyr project the last I think it

00:00:23,430 --> 00:00:26,730
was the last ELC maybe the previous one

00:00:25,529 --> 00:00:28,080
we had a number of people that were

00:00:26,730 --> 00:00:30,449
asking questions about why are we doing

00:00:28,080 --> 00:00:33,420
this what's what's the you know value in

00:00:30,449 --> 00:00:35,700
bringing in vendor housing to the front

00:00:33,420 --> 00:00:37,230
excuse me into the project so this is

00:00:35,700 --> 00:00:38,460
kind of a follow up to that action and

00:00:37,230 --> 00:00:40,860
to give you guys a little bit more

00:00:38,460 --> 00:00:43,730
insight into what we're doing why we're

00:00:40,860 --> 00:00:46,829
doing it and how we're doing it

00:00:43,730 --> 00:00:48,210
so to start off just a quick

00:00:46,829 --> 00:00:49,680
introduction about what the Zephyr

00:00:48,210 --> 00:00:51,930
project is for those of you that maybe

00:00:49,680 --> 00:00:54,000
aren't quite as familiar with it

00:00:51,930 --> 00:00:55,940
the Zephyr project is an open source

00:00:54,000 --> 00:00:58,680
project hosted by the Linux Foundation

00:00:55,940 --> 00:01:00,780
targeting small footprint are tosses so

00:00:58,680 --> 00:01:04,049
things like microcontrollers that can

00:01:00,780 --> 00:01:06,900
scale down into devices that have single

00:01:04,049 --> 00:01:10,049
digits or or so of kilobytes of flash

00:01:06,900 --> 00:01:12,540
and RAM and anywhere up that you might

00:01:10,049 --> 00:01:14,070
be interested in going it's a cross

00:01:12,540 --> 00:01:17,240
architecture project and so we have

00:01:14,070 --> 00:01:20,220
participation from a number of different

00:01:17,240 --> 00:01:22,670
companies across architectures so it's

00:01:20,220 --> 00:01:25,920
not just the arm ecosystem but also x86

00:01:22,670 --> 00:01:27,360
arc risk v extends architectures and so

00:01:25,920 --> 00:01:28,350
we have a lot of collaboration coming

00:01:27,360 --> 00:01:31,890
from different companies and different

00:01:28,350 --> 00:01:36,860
vendors all coming together to to build

00:01:31,890 --> 00:01:39,869
a common our toss for microcontrollers

00:01:36,860 --> 00:01:41,159
so the Zephyr ecosystem you can kind of

00:01:39,869 --> 00:01:45,149
look at it in sort of three different

00:01:41,159 --> 00:01:48,570
levels starting at the Zephyr OS itself

00:01:45,149 --> 00:01:51,390
this is the core scheduling kernel the

00:01:48,570 --> 00:01:55,229
threading model device or excuse me

00:01:51,390 --> 00:02:01,799
driver models that we have for go to the

00:01:55,229 --> 00:02:03,299
lowest level of hardware enablement so

00:02:01,799 --> 00:02:06,920
that includes things like platform

00:02:03,299 --> 00:02:09,959
specific drivers IO api's file systems

00:02:06,920 --> 00:02:12,360
networking and connectivity so tcp/ip

00:02:09,959 --> 00:02:13,900
Bluetooth things like that

00:02:12,360 --> 00:02:15,159
and so that that's what

00:02:13,900 --> 00:02:17,680
we think of when we talk about the

00:02:15,159 --> 00:02:19,860
zephyr OS so it's not just the so the

00:02:17,680 --> 00:02:23,769
vendor part but it's also building up

00:02:19,860 --> 00:02:26,190
middleware stacks that we all need and

00:02:23,769 --> 00:02:26,190
have in common

00:02:26,370 --> 00:02:32,680
going from the OS to the project we have

00:02:29,349 --> 00:02:34,420
a number of tools and and host SDKs that

00:02:32,680 --> 00:02:38,170
we use to help make it easier for the

00:02:34,420 --> 00:02:41,560
developer to build Zephyr so things like

00:02:38,170 --> 00:02:42,400
cross compilers and additional features

00:02:41,560 --> 00:02:44,019
like that so

00:02:42,400 --> 00:02:45,730
and lastly then there's the Zephyr

00:02:44,019 --> 00:02:47,709
community so things are that that we

00:02:45,730 --> 00:02:48,640
would think of as partner projects or

00:02:47,709 --> 00:02:51,879
there are things that are building on

00:02:48,640 --> 00:02:53,560
top of Zephyr that's where you know we

00:02:51,879 --> 00:02:55,959
kind of branch out into things like

00:02:53,560 --> 00:02:57,310
Zephyr j/s and micro Python and IO

00:02:55,959 --> 00:02:59,049
tivity and other projects like that

00:02:57,310 --> 00:03:03,220
they're kind of build on that framework

00:02:59,049 --> 00:03:06,129
that we that we construct and suffer so

00:03:03,220 --> 00:03:09,010
so my talk today is covering get the

00:03:06,129 --> 00:03:12,000
kind of the lowest level here I don't

00:03:09,010 --> 00:03:14,230
have a pointer but so the lowest level

00:03:12,000 --> 00:03:18,669
underneath the kernel and the driver

00:03:14,230 --> 00:03:20,380
model so why are we using that why are

00:03:18,669 --> 00:03:23,049
we using vendor house and and what

00:03:20,380 --> 00:03:27,609
exactly are they in in this particular

00:03:23,049 --> 00:03:30,250
case so the vendor house that we have at

00:03:27,609 --> 00:03:32,109
the at the very lowest level give us

00:03:30,250 --> 00:03:35,139
core and peripheral register definitions

00:03:32,109 --> 00:03:37,950
so a lot of these sots have hundreds or

00:03:35,139 --> 00:03:41,849
thousands even different registers

00:03:37,950 --> 00:03:44,799
register fields and things like that

00:03:41,849 --> 00:03:47,260
oftentimes these register definitions

00:03:44,799 --> 00:03:48,819
are part of standard enablement provided

00:03:47,260 --> 00:03:51,340
by the SOC vendor so that's something

00:03:48,819 --> 00:03:53,980
that we can easily leverage and not have

00:03:51,340 --> 00:03:57,430
to go and and and build ourselves it's a

00:03:53,980 --> 00:04:00,120
lot of kind of boring code I guess to

00:03:57,430 --> 00:04:02,440
say but it's pretty difficult to check

00:04:00,120 --> 00:04:03,370
so if it's something that we can reuse

00:04:02,440 --> 00:04:06,400
on them and they were definitely

00:04:03,370 --> 00:04:09,010
interested in reusing that sort of the

00:04:06,400 --> 00:04:11,739
next thing that we get out of vendor

00:04:09,010 --> 00:04:13,480
house are the what we call low level or

00:04:11,739 --> 00:04:17,709
stateless peripheral drivers so these

00:04:13,480 --> 00:04:20,500
are bare metal and it oftentimes are

00:04:17,709 --> 00:04:22,300
built upon the kind of abstract things

00:04:20,500 --> 00:04:24,490
like you're talking to a you are you

00:04:22,300 --> 00:04:26,260
know how would you set the baud rate for

00:04:24,490 --> 00:04:27,310
example so these are really low level

00:04:26,260 --> 00:04:29,110
they don't have any states

00:04:27,310 --> 00:04:30,940
kind of up to the next level either a

00:04:29,110 --> 00:04:32,860
higher level driver or an application to

00:04:30,940 --> 00:04:36,610
manage any kind of state for that

00:04:32,860 --> 00:04:40,000
peripheral and then lastly you'll see in

00:04:36,610 --> 00:04:41,080
some vendor house another level called

00:04:40,000 --> 00:04:42,669
what we think of as bare metal

00:04:41,080 --> 00:04:46,690
transactional drivers so they start to

00:04:42,669 --> 00:04:48,070
manage some of that peripheral state but

00:04:46,690 --> 00:04:49,630
they don't have any kind of artists

00:04:48,070 --> 00:04:52,060
awareness at this point so they're not

00:04:49,630 --> 00:04:57,960
aware of any kind of threading model and

00:04:52,060 --> 00:05:01,930
things like that so as I mentioned

00:04:57,960 --> 00:05:03,700
oftentimes these are these house are

00:05:01,930 --> 00:05:05,740
maintained and provided by the SOC

00:05:03,700 --> 00:05:08,139
vendors and so as new associates come

00:05:05,740 --> 00:05:10,990
out as bugs are found the vendors go and

00:05:08,139 --> 00:05:12,490
update these howls these are things that

00:05:10,990 --> 00:05:15,270
that we don't necessarily have to

00:05:12,490 --> 00:05:18,100
maintain at the zephyr project level

00:05:15,270 --> 00:05:19,360
typically we see that these howls are

00:05:18,100 --> 00:05:21,430
pretty permissive in terms with

00:05:19,360 --> 00:05:23,410
licensing I think the most common one

00:05:21,430 --> 00:05:25,740
there pretty few exceptions but most

00:05:23,410 --> 00:05:28,840
commonly we see a BSD three clause

00:05:25,740 --> 00:05:31,570
licensing model which is compatible with

00:05:28,840 --> 00:05:35,620
the Apache licensing model that we have

00:05:31,570 --> 00:05:37,240
in Zephyr and lastly these vendor house

00:05:35,620 --> 00:05:39,760
are using other projects so they're not

00:05:37,240 --> 00:05:41,500
unique to Zephyr and so what that means

00:05:39,760 --> 00:05:45,100
is that you can get additional maturity

00:05:41,500 --> 00:05:46,870
out of these this other usage right so

00:05:45,100 --> 00:05:49,710
they've been tested in other contexts

00:05:46,870 --> 00:05:52,690
they've been used in other ways and so

00:05:49,710 --> 00:05:54,700
oftentimes these drivers have a higher

00:05:52,690 --> 00:05:57,370
maturity level and have gone through QA

00:05:54,700 --> 00:06:00,310
testing so you know in a particular case

00:05:57,370 --> 00:06:03,370
of the an XP drivers that we have in

00:06:00,310 --> 00:06:05,800
suffer the the hell level you know we've

00:06:03,370 --> 00:06:08,560
gone through QA testing before we even

00:06:05,800 --> 00:06:10,510
release those drivers to the public so

00:06:08,560 --> 00:06:13,389
at the end of the day what we're really

00:06:10,510 --> 00:06:15,940
trying to do is simplifying the process

00:06:13,389 --> 00:06:21,370
of adding new soces and adding new

00:06:15,940 --> 00:06:22,660
drivers into Zephyr so naturally when

00:06:21,370 --> 00:06:26,080
you pull in something like this there

00:06:22,660 --> 00:06:28,180
are trade-offs and you know as I said

00:06:26,080 --> 00:06:29,800
you know having code maintained

00:06:28,180 --> 00:06:33,639
elsewhere right you know I said in the

00:06:29,800 --> 00:06:37,570
previous slide that ok if the vendor

00:06:33,639 --> 00:06:38,770
finds a bug in the excuse me you know

00:06:37,570 --> 00:06:41,200
updates are already made by the vendor

00:06:38,770 --> 00:06:43,510
but if we find it the project the

00:06:41,200 --> 00:06:45,970
perhaps there's a bug it's it's a quite

00:06:43,510 --> 00:06:50,620
a bit more difficult to go and update

00:06:45,970 --> 00:06:52,180
those things upstream occasionally we do

00:06:50,620 --> 00:06:54,790
sometimes see licences that aren't

00:06:52,180 --> 00:06:57,100
necessarily compatible or they're new

00:06:54,790 --> 00:06:59,110
I think the the one case that we've seen

00:06:57,100 --> 00:07:00,340
so far is that it was just a new license

00:06:59,110 --> 00:07:01,780
to Zephyr it wasn't something that we

00:07:00,340 --> 00:07:04,300
had seen before it was a standard

00:07:01,780 --> 00:07:08,530
open-source license but within the

00:07:04,300 --> 00:07:11,200
project we do try to have new code under

00:07:08,530 --> 00:07:13,270
the Apache 2 license and then imported

00:07:11,200 --> 00:07:16,510
code things like house we've generally

00:07:13,270 --> 00:07:17,800
accepted things like BSD 3 but you know

00:07:16,510 --> 00:07:19,540
if there's another license that we

00:07:17,800 --> 00:07:22,900
haven't seen before then we've had to go

00:07:19,540 --> 00:07:24,280
through the process of working with the

00:07:22,900 --> 00:07:27,220
Governing Board to say okay is this

00:07:24,280 --> 00:07:32,080
license acceptable for the project and

00:07:27,220 --> 00:07:33,310
do we want to use it and so the fact

00:07:32,080 --> 00:07:36,580
that code is used elsewhere can

00:07:33,310 --> 00:07:38,650
sometimes also be a trade off you might

00:07:36,580 --> 00:07:41,040
find that api's are not necessarily

00:07:38,650 --> 00:07:45,130
compatible it then becomes difficult to

00:07:41,040 --> 00:07:47,290
use a hal driver a transactional driver

00:07:45,130 --> 00:07:50,200
that the the the vendor provided and it

00:07:47,290 --> 00:07:52,750
just doesn't plug in to the zephyr

00:07:50,200 --> 00:07:54,340
driver mall that we might have sometimes

00:07:52,750 --> 00:07:55,570
you might see that the features might

00:07:54,340 --> 00:07:58,240
not be implemented there's a feature

00:07:55,570 --> 00:08:00,550
that that might be available at the API

00:07:58,240 --> 00:08:03,850
level within Zephyr that maybe isn't

00:08:00,550 --> 00:08:06,940
implemented in the lower level pal

00:08:03,850 --> 00:08:09,580
driver so you know we gain a lot of

00:08:06,940 --> 00:08:13,510
benefits from using these howls but you

00:08:09,580 --> 00:08:15,280
know there are some trade-offs so we've

00:08:13,510 --> 00:08:18,790
had quite a bit of success using a

00:08:15,280 --> 00:08:21,730
pretty wide range of house across the

00:08:18,790 --> 00:08:23,380
ecosystem this is an alphabetical order

00:08:21,730 --> 00:08:26,110
and so one thing you might notice is

00:08:23,380 --> 00:08:29,380
this is not unique to arm either we do

00:08:26,110 --> 00:08:31,810
see a lot of arm vendor halls that are

00:08:29,380 --> 00:08:34,840
all built on tops of something called

00:08:31,810 --> 00:08:37,330
census which I'll cover in a minute

00:08:34,840 --> 00:08:40,030
but you also see you know the Intel QMS

00:08:37,330 --> 00:08:41,590
I you know so we have quite a variety of

00:08:40,030 --> 00:08:46,180
Howells that we've been using

00:08:41,590 --> 00:08:49,570
successfully ranging from NXP to ste to

00:08:46,180 --> 00:08:52,960
Nordic to pretty much I'd say probably

00:08:49,570 --> 00:08:55,110
more SOC than not are actually using

00:08:52,960 --> 00:08:55,110
these

00:08:56,280 --> 00:09:01,000
there are generally three types of

00:08:58,630 --> 00:09:03,370
abstraction that we see when we're using

00:09:01,000 --> 00:09:05,170
these types of howls so the kind of

00:09:03,370 --> 00:09:07,090
highest level of abstraction would be a

00:09:05,170 --> 00:09:09,010
transactional driver where this is the

00:09:07,090 --> 00:09:12,430
the most amount of reuse that you would

00:09:09,010 --> 00:09:15,490
get from code that already exists and

00:09:12,430 --> 00:09:17,710
this is kind of the ideal case I think

00:09:15,490 --> 00:09:19,540
because it's a lot less custom code that

00:09:17,710 --> 00:09:20,980
we have to write for the project we can

00:09:19,540 --> 00:09:23,860
leverage something that's already been

00:09:20,980 --> 00:09:26,260
built that's already been tested and

00:09:23,860 --> 00:09:28,870
then this ends up being probably the

00:09:26,260 --> 00:09:31,270
thinnest type of driver at least in

00:09:28,870 --> 00:09:32,710
terms of Zephyr specific code that you

00:09:31,270 --> 00:09:35,860
would have to enable a particular

00:09:32,710 --> 00:09:39,550
peripheral peripheral or API in Zephyr

00:09:35,860 --> 00:09:42,850
and so this is the approach that we see

00:09:39,550 --> 00:09:48,430
for the what we call MCU x which is MCU

00:09:42,850 --> 00:09:56,280
expresso that applies to NXP OSS OCS as

00:09:48,430 --> 00:09:58,450
well as the x86 key MSI or the quark so

00:09:56,280 --> 00:10:01,420
sometimes as I said that you know these

00:09:58,450 --> 00:10:03,340
transactional level api's don't

00:10:01,420 --> 00:10:06,070
necessarily make sense or aren't the

00:10:03,340 --> 00:10:08,080
most optimal so what you sometimes see

00:10:06,070 --> 00:10:09,760
and some of the other drivers is kind of

00:10:08,080 --> 00:10:11,980
a lower level abstraction and in this

00:10:09,760 --> 00:10:14,680
case this is pretty common you'll see it

00:10:11,980 --> 00:10:16,390
in the ST parts where we take kind of

00:10:14,680 --> 00:10:18,970
the the stateless level drivers from the

00:10:16,390 --> 00:10:20,770
how or from the vendor and then build a

00:10:18,970 --> 00:10:25,480
slightly larger shim driver for his

00:10:20,770 --> 00:10:27,790
effort and then finally kind of the

00:10:25,480 --> 00:10:29,770
lowest level abstraction and the least

00:10:27,790 --> 00:10:32,170
amount of reuse would be just taking

00:10:29,770 --> 00:10:34,210
registered definitions only and in this

00:10:32,170 --> 00:10:36,610
case you end up the Zephyr driver is

00:10:34,210 --> 00:10:38,200
virtually a native driver really the

00:10:36,610 --> 00:10:40,930
only thing you're leveraging or things

00:10:38,200 --> 00:10:42,880
like the type def structures that define

00:10:40,930 --> 00:10:44,800
the peripheral registers and their

00:10:42,880 --> 00:10:47,590
fields and this is the approach that

00:10:44,800 --> 00:10:55,660
you'll see in the Atmel and the Nordic

00:10:47,590 --> 00:10:58,140
drivers so a note about Simpson Simpson

00:10:55,660 --> 00:11:01,450
stands for the cortex microcontroller

00:10:58,140 --> 00:11:04,300
system interface standard this is a

00:11:01,450 --> 00:11:06,529
standard that's defined by arm has a

00:11:04,300 --> 00:11:08,629
number of different components

00:11:06,529 --> 00:11:11,299
the most common one that you'll see is

00:11:08,629 --> 00:11:14,269
since is core but there are additional

00:11:11,299 --> 00:11:16,789
components that I list here the system

00:11:14,269 --> 00:11:19,459
view description and DSP driver model

00:11:16,789 --> 00:11:21,519
things like that but but for our case

00:11:19,459 --> 00:11:25,189
core is what we're most interested in

00:11:21,519 --> 00:11:28,639
this is a standardizing that the way

00:11:25,189 --> 00:11:30,769
that you define processor core access

00:11:28,639 --> 00:11:34,429
and peripheral definitions so what

00:11:30,769 --> 00:11:36,499
happens is that arm provides generic

00:11:34,429 --> 00:11:39,259
header files for their cortex and

00:11:36,499 --> 00:11:42,349
devices and so you'll see a cortex m0

00:11:39,259 --> 00:11:45,709
header file a cortex m4 header file and

00:11:42,349 --> 00:11:47,449
these header files describe all the

00:11:45,709 --> 00:11:49,879
registers that are common across that

00:11:47,449 --> 00:11:53,119
particular core so they're not unique to

00:11:49,879 --> 00:11:54,679
any of the vendors and then what the

00:11:53,119 --> 00:11:57,739
vendors do is they go and build on top

00:11:54,679 --> 00:11:59,859
of that they include the the core level

00:11:57,739 --> 00:12:02,809
header file from arm and then they add

00:11:59,859 --> 00:12:05,329
quite a few of all the peripheral

00:12:02,809 --> 00:12:07,129
definitions so you know you're you arts

00:12:05,329 --> 00:12:10,849
and you are itcs and whatever else

00:12:07,129 --> 00:12:14,089
you've included in that SOC so we use

00:12:10,849 --> 00:12:17,089
Simpson suffer in two different ways so

00:12:14,089 --> 00:12:20,949
the first way is the kernel port itself

00:12:17,089 --> 00:12:24,470
and so this is the sort of core part of

00:12:20,949 --> 00:12:26,989
of zephyr it's it's it's not specific to

00:12:24,470 --> 00:12:30,439
the any of the SOC s and so we do here

00:12:26,989 --> 00:12:34,489
is we can use Simpson register accesses

00:12:30,439 --> 00:12:36,259
to access the n vic or the SC b

00:12:34,489 --> 00:12:39,919
registers we say and the SUV dredge

00:12:36,259 --> 00:12:43,069
registers and then the next method of

00:12:39,919 --> 00:12:45,169
using Simpsons FRS at the driver level

00:12:43,069 --> 00:12:47,659
and so obviously this is where sort of

00:12:45,169 --> 00:12:49,309
the SOC level the system the peripheral

00:12:47,659 --> 00:12:56,959
register definitions come into play and

00:12:49,309 --> 00:12:58,909
so these are used in the drivers so a

00:12:56,959 --> 00:13:02,809
little bit more detail about what is the

00:12:58,909 --> 00:13:05,179
MSU expresso SDK you'll see an acronym

00:13:02,809 --> 00:13:07,909
in quite a few different places in

00:13:05,179 --> 00:13:10,939
Zephyr MCU X and so this is an

00:13:07,909 --> 00:13:12,049
abbreviation for the SDK for those of

00:13:10,939 --> 00:13:13,879
you that maybe have been around for a

00:13:12,049 --> 00:13:18,349
while this used to be the kinetise SDK

00:13:13,879 --> 00:13:19,620
or KSDK and when freescale was acquired

00:13:18,349 --> 00:13:22,050
by n XP we were

00:13:19,620 --> 00:13:25,350
merging the portfolios we have not just

00:13:22,050 --> 00:13:28,380
kinetise and cortex-m zero divided XM

00:13:25,350 --> 00:13:30,330
devices but we also had LPC devices and

00:13:28,380 --> 00:13:32,610
we started creating a common enablement

00:13:30,330 --> 00:13:33,960
across all of those and so we couldn't

00:13:32,610 --> 00:13:36,330
really call that the kinetise SDK

00:13:33,960 --> 00:13:39,180
anymore we started calling that the MCU

00:13:36,330 --> 00:13:44,520
expresso SDK so now you'll see common

00:13:39,180 --> 00:13:51,240
enablement across multiple families of

00:13:44,520 --> 00:13:52,800
SOC s from an XP so the SDK provides at

00:13:51,240 --> 00:13:54,150
the very core the the peripheral

00:13:52,800 --> 00:13:56,880
register definitions which are

00:13:54,150 --> 00:13:58,830
compatible with Simpsons core what's

00:13:56,880 --> 00:14:01,740
particularly interesting about these is

00:13:58,830 --> 00:14:03,510
that they're actually an artifact and

00:14:01,740 --> 00:14:06,900
what do I mean with that is that we have

00:14:03,510 --> 00:14:08,760
a database where we generate the not

00:14:06,900 --> 00:14:10,230
only the the Simpson's registered

00:14:08,760 --> 00:14:12,120
definitions but we also use that same

00:14:10,230 --> 00:14:16,050
database to generate our documentation

00:14:12,120 --> 00:14:17,730
and so to me this is a major reason to

00:14:16,050 --> 00:14:19,529
not go and write our own custom

00:14:17,730 --> 00:14:21,360
peripheral register definitions anymore

00:14:19,529 --> 00:14:22,470
because we're generating them now I

00:14:21,360 --> 00:14:24,660
think that's going to be a lot less

00:14:22,470 --> 00:14:27,980
error-prone it's using a lot more cases

00:14:24,660 --> 00:14:34,200
and so we very much want to leverage

00:14:27,980 --> 00:14:36,720
that artifact so in addition so we also

00:14:34,200 --> 00:14:40,290
have bare metal peripheral drivers and

00:14:36,720 --> 00:14:42,390
so these these drivers are interesting

00:14:40,290 --> 00:14:44,730
because they provide common or at least

00:14:42,390 --> 00:14:47,760
similar api's across the different

00:14:44,730 --> 00:14:50,640
families and one by mean by this is that

00:14:47,760 --> 00:14:53,760
we have multiple variants of the same

00:14:50,640 --> 00:14:54,570
type of IP and so for example I'm not

00:14:53,760 --> 00:14:55,920
sure if any of you guys are familiar

00:14:54,570 --> 00:14:57,990
with these little little details but

00:14:55,920 --> 00:15:00,420
I've got three different types of you

00:14:57,990 --> 00:15:03,360
arts listed here you art and lpu art an

00:15:00,420 --> 00:15:05,910
LPS CI I've got three different types of

00:15:03,360 --> 00:15:08,820
spy modules listed here a spy a DS by

00:15:05,910 --> 00:15:10,230
and LP spy so these all provide spy and

00:15:08,820 --> 00:15:12,209
UART capabilities but they have

00:15:10,230 --> 00:15:14,490
different register models which means

00:15:12,209 --> 00:15:17,850
that we have different drivers for them

00:15:14,490 --> 00:15:19,890
and so with the MSU expresso SDK does is

00:15:17,850 --> 00:15:22,230
provides a common or very similar type

00:15:19,890 --> 00:15:26,190
of driver model at the sort of bare

00:15:22,230 --> 00:15:28,200
Melvin bare metal level and what that

00:15:26,190 --> 00:15:29,700
means for Zephyr is that you know when

00:15:28,200 --> 00:15:31,560
we start building a shame on top of that

00:15:29,700 --> 00:15:33,360
that shame looks pretty similar so if

00:15:31,560 --> 00:15:36,480
you've seen a sham for a

00:15:33,360 --> 00:15:41,970
by doing another one for an LP spy

00:15:36,480 --> 00:15:44,070
should be pretty straightforward and

00:15:41,970 --> 00:15:45,420
then lastly you know this isn't

00:15:44,070 --> 00:15:47,940
something that we incorporate into

00:15:45,420 --> 00:15:50,940
Zephyr but I wanted to note it here and

00:15:47,940 --> 00:15:53,310
that's IDE example projects and what

00:15:50,940 --> 00:15:55,290
these serve to or the purpose of these

00:15:53,310 --> 00:15:58,200
projects are to demonstrate how to use

00:15:55,290 --> 00:15:59,760
these peripheral api's and so you know

00:15:58,200 --> 00:16:00,930
if it turns out that you know you stuck

00:15:59,760 --> 00:16:04,050
you don't understand how to use it

00:16:00,930 --> 00:16:06,120
you've got a buildable project using a

00:16:04,050 --> 00:16:08,370
couple of different tool chains out

00:16:06,120 --> 00:16:09,899
there that you can go and build it you

00:16:08,370 --> 00:16:12,510
can run it and so you have a working

00:16:09,899 --> 00:16:13,800
example of how that driver works and so

00:16:12,510 --> 00:16:15,570
the idea being that would be a lot

00:16:13,800 --> 00:16:18,149
simpler if you need to go and you know

00:16:15,570 --> 00:16:20,430
implement or need to use that driver in

00:16:18,149 --> 00:16:24,410
your own application you have something

00:16:20,430 --> 00:16:24,410
that that you can leverage and reference

00:16:25,279 --> 00:16:32,190
so note about the xed folder all of the

00:16:30,420 --> 00:16:34,050
externally maintained source code in

00:16:32,190 --> 00:16:38,010
Zephyr lives in a folder at the top

00:16:34,050 --> 00:16:40,740
level called xed and so as I talk today

00:16:38,010 --> 00:16:42,660
about you know SOC vendor house there

00:16:40,740 --> 00:16:45,209
are additional code components that

00:16:42,660 --> 00:16:47,730
we've imported into Zephyr that also

00:16:45,209 --> 00:16:52,410
live in the X folder so these comprise

00:16:47,730 --> 00:16:53,790
of Emma TLS tiny crypt edifice Sager RTT

00:16:52,410 --> 00:16:58,850
and there may be a couple of others that

00:16:53,790 --> 00:17:01,350
I might have missed in general these

00:16:58,850 --> 00:17:02,880
components are permissively licensed or

00:17:01,350 --> 00:17:05,400
licensed in a way that's that we

00:17:02,880 --> 00:17:08,250
consider compatible with Apache 2.0 but

00:17:05,400 --> 00:17:09,839
not it's not always the same and so I

00:17:08,250 --> 00:17:13,319
think the most common case that we see

00:17:09,839 --> 00:17:15,630
here is a bsd 3 clause but there are I

00:17:13,319 --> 00:17:19,380
think one or two others I think some are

00:17:15,630 --> 00:17:22,740
actually Apache 2 as well but anything

00:17:19,380 --> 00:17:25,140
we put a next we consider sort of a we

00:17:22,740 --> 00:17:27,120
imported as it is we don't modify it or

00:17:25,140 --> 00:17:29,070
we try to modify it as little as

00:17:27,120 --> 00:17:31,280
possible so we you know this is a

00:17:29,070 --> 00:17:36,660
downstream project it's not a forked a

00:17:31,280 --> 00:17:38,820
forked repo and finally anything we put

00:17:36,660 --> 00:17:40,380
in next we have exempted from this

00:17:38,820 --> 00:17:43,860
effort holding style it just doesn't

00:17:40,380 --> 00:17:46,240
make sense to go and apply a coding

00:17:43,860 --> 00:17:49,030
style that we've adopted for sort of the

00:17:46,240 --> 00:17:51,730
or zephyr Colonel kind of components or

00:17:49,030 --> 00:17:53,679
anything that's that's been coated

00:17:51,730 --> 00:17:55,750
specifically for his effort apply that

00:17:53,679 --> 00:18:02,440
same coding standard across all these

00:17:55,750 --> 00:18:05,770
other things that we wanted to reuse we

00:18:02,440 --> 00:18:10,179
do have a a formal process now to import

00:18:05,770 --> 00:18:13,990
new code components into Zephyr this is

00:18:10,179 --> 00:18:16,540
a process that was recently approved by

00:18:13,990 --> 00:18:20,620
the governing board and put into

00:18:16,540 --> 00:18:22,330
practice in the last month or so and

00:18:20,620 --> 00:18:26,020
basically what that process consists of

00:18:22,330 --> 00:18:27,850
is documenting what that code is that

00:18:26,020 --> 00:18:31,210
you want to import where did you get it

00:18:27,850 --> 00:18:33,340
from and then having it go through first

00:18:31,210 --> 00:18:38,350
the the TSC or the technical steering

00:18:33,340 --> 00:18:40,690
committee and if the TSC agrees that

00:18:38,350 --> 00:18:42,640
this is something that we do want to use

00:18:40,690 --> 00:18:45,309
within the project and they will send

00:18:42,640 --> 00:18:47,020
that to the governing board and then the

00:18:45,309 --> 00:18:51,040
governing board has two weeks to look it

00:18:47,020 --> 00:18:52,960
over it and discuss any potential patent

00:18:51,040 --> 00:18:55,750
issues or things like that that they

00:18:52,960 --> 00:18:57,520
might have concerns with about importing

00:18:55,750 --> 00:18:59,320
event into the project and so once

00:18:57,520 --> 00:19:01,809
either the governing board approves it

00:18:59,320 --> 00:19:04,690
or two weeks have passed then we have

00:19:01,809 --> 00:19:11,320
the go-ahead to import that code into

00:19:04,690 --> 00:19:13,390
the project so when you want to import a

00:19:11,320 --> 00:19:15,730
new component into the project there are

00:19:13,390 --> 00:19:18,580
a number of things that you need to

00:19:15,730 --> 00:19:20,020
document so obviously the origin where

00:19:18,580 --> 00:19:24,130
did you get that project or where did

00:19:20,020 --> 00:19:25,630
you get that code originally from why do

00:19:24,130 --> 00:19:27,160
you want to import it into the project

00:19:25,630 --> 00:19:29,200
however we using it what do we want to

00:19:27,160 --> 00:19:32,880
do with it

00:19:29,200 --> 00:19:37,890
and what kind of dependencies it has I

00:19:32,880 --> 00:19:37,890
think this is pretty self-explanatory so

00:19:40,020 --> 00:19:45,910
I wanted to kind of address a couple of

00:19:43,120 --> 00:19:47,590
questions that we commonly see when

00:19:45,910 --> 00:19:51,010
somebody is interested in adding a new

00:19:47,590 --> 00:19:53,350
SOC into Zephyr so I think the first

00:19:51,010 --> 00:19:56,520
question that you know you might want to

00:19:53,350 --> 00:19:58,690
ask yourself if you might ask you know

00:19:56,520 --> 00:20:00,190
somebody else in the community is is

00:19:58,690 --> 00:20:02,920
does this SOC

00:20:00,190 --> 00:20:06,010
to another family or series what's

00:20:02,920 --> 00:20:07,840
really common in these sort of small

00:20:06,010 --> 00:20:09,910
microcontroller devices is that you'll

00:20:07,840 --> 00:20:13,270
see a huge number of devices in the same

00:20:09,910 --> 00:20:15,550
family and so oftentimes you know you're

00:20:13,270 --> 00:20:17,620
not starting from scratch and so take a

00:20:15,550 --> 00:20:19,630
look at what's already there in terms of

00:20:17,620 --> 00:20:22,630
Zephyr and is there something that we

00:20:19,630 --> 00:20:26,560
could extend or leverage or you know

00:20:22,630 --> 00:20:29,650
follow suit to what's already there the

00:20:26,560 --> 00:20:31,360
next question that they often get is are

00:20:29,650 --> 00:20:33,280
there census headers available so if

00:20:31,360 --> 00:20:35,260
you're trying to import a new SOC into

00:20:33,280 --> 00:20:36,850
the project from a new for a new family

00:20:35,260 --> 00:20:38,200
that doesn't already exist so we've

00:20:36,850 --> 00:20:40,150
already established what to do for

00:20:38,200 --> 00:20:42,640
things like kinetise or the Nordic

00:20:40,150 --> 00:20:44,350
devices or the Atmel devices but if

00:20:42,640 --> 00:20:47,080
you've got something totally new a new

00:20:44,350 --> 00:20:49,030
family I think the first question that

00:20:47,080 --> 00:20:51,430
you'll get asked is is are there sims's

00:20:49,030 --> 00:20:56,890
headers available and if they are is the

00:20:51,430 --> 00:20:59,350
license compatible and then second you

00:20:56,890 --> 00:21:00,880
know are there driver level or are there

00:20:59,350 --> 00:21:02,380
transactional or stateless drivers

00:21:00,880 --> 00:21:04,510
available is there something that we can

00:21:02,380 --> 00:21:08,110
can leverage rather than starting from

00:21:04,510 --> 00:21:09,880
scratch of course is the license

00:21:08,110 --> 00:21:13,090
compatibles that question applies here

00:21:09,880 --> 00:21:15,190
as well oftentimes those are distributed

00:21:13,090 --> 00:21:16,810
in the same deployments that's the case

00:21:15,190 --> 00:21:18,700
for most of what we already have in the

00:21:16,810 --> 00:21:19,840
project but if they happen to be

00:21:18,700 --> 00:21:24,100
separate you need to ask that question

00:21:19,840 --> 00:21:26,200
separately are the api's compatible

00:21:24,100 --> 00:21:28,180
right so I covered the kind of three

00:21:26,200 --> 00:21:31,570
different levels of abstraction that

00:21:28,180 --> 00:21:33,400
you'll see and ideally you know can we

00:21:31,570 --> 00:21:36,250
reuse a transactional driver if we can

00:21:33,400 --> 00:21:37,720
great right that that's less new stuff

00:21:36,250 --> 00:21:39,490
that we need to do and more that we can

00:21:37,720 --> 00:21:42,970
leverage but that's not always possible

00:21:39,490 --> 00:21:44,350
it doesn't always make sense and so you

00:21:42,970 --> 00:21:48,340
know maybe you bump down to the

00:21:44,350 --> 00:21:50,830
stateless level driver model and then

00:21:48,340 --> 00:21:51,970
lastly I touched on this a second ago

00:21:50,830 --> 00:21:54,520
but can they be used for other

00:21:51,970 --> 00:21:57,070
Association the same family so I think

00:21:54,520 --> 00:21:59,890
this one's can be a little bit tricky in

00:21:57,070 --> 00:22:02,560
that sometimes what you'll see when

00:21:59,890 --> 00:22:04,210
somebody writes a new driver they'll say

00:22:02,560 --> 00:22:07,690
that that driver is you know this

00:22:04,210 --> 00:22:10,990
particular SOC su art driver but in

00:22:07,690 --> 00:22:13,060
reality you know that same UART module

00:22:10,990 --> 00:22:13,420
exists on multiple Association the

00:22:13,060 --> 00:22:16,300
saying

00:22:13,420 --> 00:22:17,950
family from that vendor and so you know

00:22:16,300 --> 00:22:21,670
we want to be able to reuse that driver

00:22:17,950 --> 00:22:23,710
if we can and so when you're importing

00:22:21,670 --> 00:22:25,810
it or when you're adding support for a

00:22:23,710 --> 00:22:27,580
new SOC into the project you need to

00:22:25,810 --> 00:22:28,960
think about you know maybe you're not

00:22:27,580 --> 00:22:30,760
adding other Association that same

00:22:28,960 --> 00:22:32,290
family yet but maybe the next person

00:22:30,760 --> 00:22:35,350
might want to come along and do it and

00:22:32,290 --> 00:22:36,610
so can you do it in such a way that they

00:22:35,350 --> 00:22:44,830
can leverage that work that you're doing

00:22:36,610 --> 00:22:47,020
today so in summary I think that you

00:22:44,830 --> 00:22:50,140
know we find that a lot of reuse and

00:22:47,020 --> 00:22:52,360
reduction in custom code is a major

00:22:50,140 --> 00:22:53,920
benefit to using these house when it's

00:22:52,360 --> 00:22:56,860
appropriate you know they're all

00:22:53,920 --> 00:22:58,810
different levels of abstraction we have

00:22:56,860 --> 00:23:04,000
had a lot of success with using these

00:22:58,810 --> 00:23:06,670
SOC howls Innes effort today and if you

00:23:04,000 --> 00:23:07,780
are you know interested in adding one

00:23:06,670 --> 00:23:09,100
yourself

00:23:07,780 --> 00:23:11,020
you know take a look at the input

00:23:09,100 --> 00:23:12,730
process take a look at the get history

00:23:11,020 --> 00:23:21,900
and talk with the maintainer as if you

00:23:12,730 --> 00:23:21,900
have questions and that's it questions

00:23:22,320 --> 00:23:29,109
[Applause]

00:23:32,529 --> 00:23:41,740
no this is this is something that's

00:23:35,179 --> 00:23:41,740
that's within an XP that we do yeah

00:23:45,730 --> 00:23:50,200
these are just NX pssh yeah

00:24:02,460 --> 00:24:09,730
no no the Shem lives in the standard

00:24:07,030 --> 00:24:12,760
driver folder we consider that as new

00:24:09,730 --> 00:24:16,800
code to to Zephir and so it lives with

00:24:12,760 --> 00:24:16,800
the rest of the sort of native code

00:24:32,980 --> 00:24:38,900
um don't think how to answer that

00:24:37,580 --> 00:24:40,700
question I mean so your application

00:24:38,900 --> 00:24:43,640
generally wouldn't be calling directly

00:24:40,700 --> 00:24:46,340
into the SDKs so that should

00:24:43,640 --> 00:24:48,230
theoretically be seamless you know in

00:24:46,340 --> 00:24:51,560
practice I don't think we've seen that

00:24:48,230 --> 00:24:54,800
problem yet I can think of one case

00:24:51,560 --> 00:24:57,170
where you know it's something the API

00:24:54,800 --> 00:24:58,940
and the MCU expresso SDK actually

00:24:57,170 --> 00:25:00,620
changed in the ethernet driver it was a

00:24:58,940 --> 00:25:01,850
pretty minor change and so I just made

00:25:00,620 --> 00:25:04,610
that change at the same time when I

00:25:01,850 --> 00:25:06,170
updated the SDK but at the the user

00:25:04,610 --> 00:25:08,060
level within Zephyr write your Zephyr

00:25:06,170 --> 00:25:10,910
application never directly calls that

00:25:08,060 --> 00:25:12,410
API and so from from its perspective it

00:25:10,910 --> 00:25:15,200
it was seamless it didn't see the

00:25:12,410 --> 00:25:19,160
difference but we don't maintain like

00:25:15,200 --> 00:25:27,100
multiple versions of the same SDK at one

00:25:19,160 --> 00:25:27,100
time maybe else

00:25:30,220 --> 00:25:41,029
um I have generally updated it when I'm

00:25:37,820 --> 00:25:44,360
importing a new SOC so we don't do a lot

00:25:41,029 --> 00:25:46,580
of real frequent releases of the msu

00:25:44,360 --> 00:25:49,909
expresso SDK it's generally add an SOC

00:25:46,580 --> 00:25:53,000
level like we don't provide it at nxp we

00:25:49,909 --> 00:25:54,890
don't deploy an entire SDK for all of

00:25:53,000 --> 00:25:57,919
the associate in our portfolio we look

00:25:54,890 --> 00:26:00,950
at it as an SOC bio so see basis and so

00:25:57,919 --> 00:26:03,260
what will happen is you know for the K

00:26:00,950 --> 00:26:06,830
64 for example and a couple of cases

00:26:03,260 --> 00:26:09,020
I've updated the SDK for that and then

00:26:06,830 --> 00:26:11,539
what generally happens is you know we

00:26:09,020 --> 00:26:13,909
added a new SOC there were new drivers

00:26:11,539 --> 00:26:21,710
or new versions of existing drivers that

00:26:13,909 --> 00:26:23,799
then I went and updated have vendor on

00:26:21,710 --> 00:26:27,429
any interest in contributing to these

00:26:23,799 --> 00:26:29,419
house living in this X directory or

00:26:27,429 --> 00:26:31,940
submitting updates

00:26:29,419 --> 00:26:33,730
I know adjusting that these halls to

00:26:31,940 --> 00:26:38,210
twos after somehow adjusting the house

00:26:33,730 --> 00:26:41,210
just if they shown an interest in the

00:26:38,210 --> 00:26:45,770
contributing possessor well I represent

00:26:41,210 --> 00:26:48,289
Avengers yeah I mean we have seen some

00:26:45,770 --> 00:26:49,909
other vendors you know it's not just an

00:26:48,289 --> 00:26:51,230
XP that's doing that but you know you

00:26:49,909 --> 00:26:54,169
had to question from Nordic there

00:26:51,230 --> 00:26:56,720
there's a somebody from it from st

00:26:54,169 --> 00:26:58,850
that's also been contributing and so

00:26:56,720 --> 00:27:02,529
there has been some representation from

00:26:58,850 --> 00:27:02,529
the vendors on that front

00:27:08,379 --> 00:27:31,070
when it's crap the question was what do

00:27:29,299 --> 00:27:36,700
you do when the vendor drivers crap

00:27:31,070 --> 00:27:41,320
I hope that's not my Treasuries um

00:27:36,700 --> 00:27:41,320
that's a good question I mean I guess I

00:27:44,230 --> 00:27:52,129
um I don't know I mean I guess you know

00:27:49,509 --> 00:27:53,929
I'd be interested in seeing the vendor

00:27:52,129 --> 00:27:55,340
would be interested in fixing the driver

00:27:53,929 --> 00:27:57,259
I think that'd be the first path I'd

00:27:55,340 --> 00:28:01,279
want to take that's not always easy to

00:27:57,259 --> 00:28:05,350
do but I'd rather at least try that

00:28:01,279 --> 00:28:05,350
first before reinventing something

00:28:16,370 --> 00:28:22,760
okay thank you all for what there no no

00:28:20,240 --> 00:28:23,710
that's not a hand alright thank you for

00:28:22,760 --> 00:28:27,450
coming

00:28:23,710 --> 00:28:27,450

YouTube URL: https://www.youtube.com/watch?v=BV7EYCzSXH0


