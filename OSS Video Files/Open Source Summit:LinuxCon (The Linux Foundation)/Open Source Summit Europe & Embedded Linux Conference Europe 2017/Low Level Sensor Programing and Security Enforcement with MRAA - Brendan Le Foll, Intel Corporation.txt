Title: Low Level Sensor Programing and Security Enforcement with MRAA - Brendan Le Foll, Intel Corporation
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	Low Level Sensor Programing and Security Enforcement with MRAA - Brendan Le Foll, Intel Corporation

MRAA is and it's companion library UPM is already enabling thousands of developers to control sensors and control devices in a platform independent way. Even Arduino is now using it on Linux based boards. With over 300 sensors supported by the libraries - it has become an easy way to add sensor support to large frameworks and OSs. When stringent security requirements mandate the use of arbiters between any operation with the real world mraa has been successfully adapted to suit those needs. I will then describe how the model has evolved to support remote sensor running on Arduino & FTDI hardware, then on Android of Things and more recently on AGL. A more detailed look at the last evolution will explain how the power of MRAA associated with AGL development tools offer a novel approach to sensor and control programming in a secured environment.

About Brendan Le Foll
Brendan holds a degree from the University of Kent, as a student he was the maintainer for the Meego TV reference UI. He started his careers at Intel UK in the customer enabling group, the success of MRAA and the Intel IoT developer kit allowed him to join the Intel Open Source group where he worked on the Yocto project focusing on I/O and javascript technologies in Linux embedded applications. He recently moved to Intel Germany to focus on development tools for IoT & embedded.
Captions: 
	00:00:00,030 --> 00:00:03,990
so welcome to low-level center

00:00:01,979 --> 00:00:06,870
programming and security enforcement

00:00:03,990 --> 00:00:09,240
with Raph I'm Brendan and I work for

00:00:06,870 --> 00:00:11,490
Intel in Germany focusing on developer

00:00:09,240 --> 00:00:13,980
tools specifically aimed at new Linux

00:00:11,490 --> 00:00:16,080
user space and sometimes if you are

00:00:13,980 --> 00:00:17,490
tagged along with like Zephyr I think

00:00:16,080 --> 00:00:19,320
they call it like a key or fog or

00:00:17,490 --> 00:00:23,850
something but I think we wonder what

00:00:19,320 --> 00:00:25,560
that really means so the agenda for

00:00:23,850 --> 00:00:29,039
today is we'll go through what lead

00:00:25,560 --> 00:00:29,970
morado IO is then what we're doing with

00:00:29,039 --> 00:00:32,399
it at the moment

00:00:29,970 --> 00:00:35,820
including our Google peripheral manager

00:00:32,399 --> 00:00:38,219
back-end and that we've done for um for

00:00:35,820 --> 00:00:41,399
brillo and then some of the work I've

00:00:38,219 --> 00:00:44,820
been doing on the ADL AFB bus for the

00:00:41,399 --> 00:00:49,500
automotive grade Linux AFE bus I kind of

00:00:44,820 --> 00:00:51,149
remember that stands for so the first

00:00:49,500 --> 00:00:54,449
thing we'll do is go for a little bit

00:00:51,149 --> 00:00:58,829
about what Mirai is in case gim hope you

00:00:54,449 --> 00:01:00,359
know you know and really the I couldn't

00:00:58,829 --> 00:01:02,730
understand for anything but I think the

00:01:00,359 --> 00:01:05,420
M is for monkey and I'll go through that

00:01:02,730 --> 00:01:09,140
a little bit more a little terminology

00:01:05,420 --> 00:01:12,360
we talked about lit Marah and Rada IO

00:01:09,140 --> 00:01:14,479
Rada IO is meant to be the API standard

00:01:12,360 --> 00:01:17,869
and Demerara first of the Linux

00:01:14,479 --> 00:01:19,470
implementation of the Mirada IO

00:01:17,869 --> 00:01:21,930
specification although never he got

00:01:19,470 --> 00:01:24,229
written down properly but the aim is

00:01:21,930 --> 00:01:28,950
that we have multiple Mirada io

00:01:24,229 --> 00:01:30,840
implementations for things like we've

00:01:28,950 --> 00:01:34,110
kind of got a Windows one we've got a

00:01:30,840 --> 00:01:35,670
few other weird and wonderful ones but

00:01:34,110 --> 00:01:38,970
Rudy here we're talking about Lib morale

00:01:35,670 --> 00:01:41,310
for Linux I started it

00:01:38,970 --> 00:01:44,189
a little while ago and really the

00:01:41,310 --> 00:01:47,189
specific need was code reuse for users

00:01:44,189 --> 00:01:49,950
base I hope a devices and we did a small

00:01:47,189 --> 00:01:53,909
hackathon and about Congress we'd like

00:01:49,950 --> 00:01:55,320
the in toggle air board and it was we

00:01:53,909 --> 00:01:57,270
thought was really cool we gave a little

00:01:55,320 --> 00:01:59,090
sea environment and Eclipse and it kind

00:01:57,270 --> 00:02:01,170
of it was relatively easy to program on

00:01:59,090 --> 00:02:02,850
but it turned out that you still need

00:02:01,170 --> 00:02:04,829
like hundred lines of code cloths to

00:02:02,850 --> 00:02:06,659
just make an LED flash on and off and

00:02:04,829 --> 00:02:09,440
turns out most developers thought I was

00:02:06,659 --> 00:02:12,629
pretty acceptable and it probably was

00:02:09,440 --> 00:02:13,300
and we had one little library all it did

00:02:12,629 --> 00:02:16,300
was

00:02:13,300 --> 00:02:18,670
can I to see LCD kind of work relatively

00:02:16,300 --> 00:02:21,250
easily with few lines of code and that

00:02:18,670 --> 00:02:22,750
was super super popular so we thought

00:02:21,250 --> 00:02:24,940
well we probably need a distraction

00:02:22,750 --> 00:02:26,800
layer to make reuse of that code so we

00:02:24,940 --> 00:02:27,660
can make more useful stuff that's kind

00:02:26,800 --> 00:02:30,190
of how it started

00:02:27,660 --> 00:02:33,220
so give you an impression this kind of

00:02:30,190 --> 00:02:36,130
made rapid prototyping for making i/o

00:02:33,220 --> 00:02:41,070
work as expected rather than the way it

00:02:36,130 --> 00:02:42,940
works when yes now the next board and

00:02:41,070 --> 00:02:45,160
then we kind of went a little bit

00:02:42,940 --> 00:02:47,560
further so the aim is to have an

00:02:45,160 --> 00:02:50,170
abstraction layer with a level of

00:02:47,560 --> 00:02:51,670
flexibility which is very very high as

00:02:50,170 --> 00:02:53,710
we can support a load of different

00:02:51,670 --> 00:02:55,210
boards we obviously wanted to be

00:02:53,710 --> 00:02:56,920
open-source license so we chose yeah

00:02:55,210 --> 00:02:59,470
mighty visors because it's just simple

00:02:56,920 --> 00:03:01,240
and easy and a lot of these been written

00:02:59,470 --> 00:03:03,310
by Intel employees but we've accepted

00:03:01,240 --> 00:03:04,930
pr's from just about everyone on github

00:03:03,310 --> 00:03:08,950
and we collaborate with loads of C

00:03:04,930 --> 00:03:10,690
vendors now talk about a little bit and

00:03:08,950 --> 00:03:12,700
what Murat's essentially does in Linux

00:03:10,690 --> 00:03:14,650
it's doing i/o that's typically reserved

00:03:12,700 --> 00:03:17,260
for the kernel and moving it into user

00:03:14,650 --> 00:03:19,420
space and bringing essentially the

00:03:17,260 --> 00:03:21,489
artery in a header that you see so

00:03:19,420 --> 00:03:23,530
commonly on Linux single board computers

00:03:21,489 --> 00:03:25,900
so you can use it really easily without

00:03:23,530 --> 00:03:27,520
any special magic just like you can on

00:03:25,900 --> 00:03:29,200
the microcontroller the aim is to make

00:03:27,520 --> 00:03:31,030
really that experience as easy is on a

00:03:29,200 --> 00:03:33,790
micro obviously it's not quite perfect

00:03:31,030 --> 00:03:35,350
but we're trying to get there we support

00:03:33,790 --> 00:03:38,770
all the common low speed our protocols

00:03:35,350 --> 00:03:40,360
GPIO I squared C Spire you are things

00:03:38,770 --> 00:03:42,280
like that we're pretty agnostic to

00:03:40,360 --> 00:03:44,590
kernel version that we support a load of

00:03:42,280 --> 00:03:47,050
different access methods so for example

00:03:44,590 --> 00:03:50,380
for GPIO we do a thing from Sisyphus we

00:03:47,050 --> 00:03:53,170
support WI o dev men for terrific boards

00:03:50,380 --> 00:03:55,290
and even GPIO of either nuke our dev

00:03:53,170 --> 00:03:59,230
interface and the kernel from full dot

00:03:55,290 --> 00:04:01,209
but which is way nicer and based on that

00:03:59,230 --> 00:04:02,890
we actually let you do full GPIO line

00:04:01,209 --> 00:04:05,260
access now which is much much more

00:04:02,890 --> 00:04:07,390
efficient but we still have a failover

00:04:05,260 --> 00:04:10,570
mode beyond safe s if you have an order

00:04:07,390 --> 00:04:14,950
colonel or an auto board we also have

00:04:10,570 --> 00:04:17,380
our own IO user space interface mostly

00:04:14,950 --> 00:04:18,940
it was initially done for a DC's because

00:04:17,380 --> 00:04:21,010
we typically don't suggest writing user

00:04:18,940 --> 00:04:22,780
space ADC drivers that's typically a bit

00:04:21,010 --> 00:04:25,000
inefficient

00:04:22,780 --> 00:04:28,870
and we also do you are and emulated one

00:04:25,000 --> 00:04:31,800
wire on you are and just as we emergence

00:04:28,870 --> 00:04:34,630
hatches from the Naro to add an eternal

00:04:31,800 --> 00:04:38,560
subsystem so we can do that directly

00:04:34,630 --> 00:04:40,750
from the broth and target audience

00:04:38,560 --> 00:04:42,820
really as monkeys so it's it's dumb it's

00:04:40,750 --> 00:04:45,160
easy and it just works that's really the

00:04:42,820 --> 00:04:47,440
the main concept we try to really

00:04:45,160 --> 00:04:49,750
emulate the easiness from the light

00:04:47,440 --> 00:04:51,160
control of the world and there's just a

00:04:49,750 --> 00:04:52,900
few things that because of that we can't

00:04:51,160 --> 00:04:55,840
do that's fine that's that's part of the

00:04:52,900 --> 00:04:57,630
limitations like I said it's for quick

00:04:55,840 --> 00:04:59,440
prototyping and with finding you know

00:04:57,630 --> 00:05:01,330
2017 no one really throws away a

00:04:59,440 --> 00:05:03,100
prototype anymore so we've kind of tried

00:05:01,330 --> 00:05:04,720
to adapt that into products and try to

00:05:03,100 --> 00:05:07,750
make few things to make actually easier

00:05:04,720 --> 00:05:09,190
to develop on and generally our users

00:05:07,750 --> 00:05:12,340
that are used to handling software a

00:05:09,190 --> 00:05:14,020
much higher level the Linux kernel so

00:05:12,340 --> 00:05:15,520
they may not have access the ability to

00:05:14,020 --> 00:05:18,160
rebuild our ink and all they might be on

00:05:15,520 --> 00:05:19,390
a specific vendor kernel they may not

00:05:18,160 --> 00:05:22,419
have the skills to rebuild occurs on

00:05:19,390 --> 00:05:25,000
this kernel to start with and and we're

00:05:22,419 --> 00:05:26,710
we're real-world so we often have vendor

00:05:25,000 --> 00:05:29,110
specific kernels things that are super

00:05:26,710 --> 00:05:30,729
clean and it's not always possible just

00:05:29,110 --> 00:05:36,580
upgrade to layers and all to get the

00:05:30,729 --> 00:05:40,180
card add subsystem for example and we

00:05:36,580 --> 00:05:43,330
have api's and c++ nodejs

00:05:40,180 --> 00:05:45,700
java and python and see what busses

00:05:43,330 --> 00:05:48,010
header only python is week with some

00:05:45,700 --> 00:05:50,830
typeface work and on OJ's kind of a

00:05:48,010 --> 00:05:52,450
halfway house with I was struggling a

00:05:50,830 --> 00:05:53,860
bit with no Jess seven support but we we

00:05:52,450 --> 00:05:56,310
have six support and we're looking at

00:05:53,860 --> 00:05:58,690
moving to from swig to n bind for that

00:05:56,310 --> 00:06:00,580
and we support loads and loads of boards

00:05:58,690 --> 00:06:01,120
and the aim is to abstract the platform

00:06:00,580 --> 00:06:03,520
quirks

00:06:01,120 --> 00:06:05,380
so really support the actual board as

00:06:03,520 --> 00:06:07,390
much as possible so that it reflects the

00:06:05,380 --> 00:06:09,250
hardware Daisy from the SOC or the board

00:06:07,390 --> 00:06:11,729
vendor and it's sometimes harder than

00:06:09,250 --> 00:06:11,729
you believe

00:06:12,450 --> 00:06:17,890
straight on here's the quick and ugly

00:06:15,130 --> 00:06:18,669
capi demo so you can see its context

00:06:17,890 --> 00:06:21,250
based

00:06:18,669 --> 00:06:23,500
once you initialize the context which we

00:06:21,250 --> 00:06:25,210
handle it's a hint pointer straat you

00:06:23,500 --> 00:06:28,090
can pass it around and you can close it

00:06:25,210 --> 00:06:29,710
with the aptly named closed function and

00:06:28,090 --> 00:06:31,090
next to its a little table that I got

00:06:29,710 --> 00:06:33,640
from a day is she from the Intel I

00:06:31,090 --> 00:06:35,380
discern as you can see this is one of

00:06:33,640 --> 00:06:37,630
the kernels which is slightly more weird

00:06:35,380 --> 00:06:38,830
and it gives you an idea of kind of what

00:06:37,630 --> 00:06:40,300
we actually do in the background when

00:06:38,830 --> 00:06:42,490
you actually do this call so when you

00:06:40,300 --> 00:06:44,110
actually go and ask for a GPIO we

00:06:42,490 --> 00:06:45,760
basically go look in a table for you

00:06:44,110 --> 00:06:47,410
will do the pin boxing for you if it's

00:06:45,760 --> 00:06:49,360
not on nice feet

00:06:47,410 --> 00:06:51,520
well essentially kind of fix it up so

00:06:49,360 --> 00:06:52,660
does the right thing on some platform

00:06:51,520 --> 00:06:54,610
there's actually even hard to get at the

00:06:52,660 --> 00:06:56,800
data sheet so it's kind of an essay nice

00:06:54,610 --> 00:06:59,760
and easy and we get a lot of people HP

00:06:56,800 --> 00:07:02,620
the user simply because of that you know

00:06:59,760 --> 00:07:05,440
and we find a lot of manufacturers do

00:07:02,620 --> 00:07:07,210
really good ste level IO support but

00:07:05,440 --> 00:07:08,710
then you get an OD and that turns up

00:07:07,210 --> 00:07:11,290
they make a random board they put a

00:07:08,710 --> 00:07:14,380
bunch of GPIO is on our control by

00:07:11,290 --> 00:07:17,080
normal means or normal ways and nothing

00:07:14,380 --> 00:07:18,460
like an or support course and it's

00:07:17,080 --> 00:07:22,150
especially common with a Don and

00:07:18,460 --> 00:07:27,790
daughter boards and som designs so stuck

00:07:22,150 --> 00:07:30,940
on module I won't name any one and then

00:07:27,790 --> 00:07:34,030
we have our C++ API which is a header

00:07:30,940 --> 00:07:36,190
Oni API it's not really fancy but what

00:07:34,030 --> 00:07:39,340
we do is we we change our context to be

00:07:36,190 --> 00:07:41,710
objects and all our swiggity eyes are

00:07:39,340 --> 00:07:44,260
based on this so previously we had swig

00:07:41,710 --> 00:07:46,900
generate objects using type maps and

00:07:44,260 --> 00:07:48,700
this was a massive massive mess so to

00:07:46,900 --> 00:07:50,500
reduce the size of our wrappers we

00:07:48,700 --> 00:07:53,770
started using this and it seems to be a

00:07:50,500 --> 00:07:56,350
bit easy to maintain we do actually have

00:07:53,770 --> 00:07:59,110
unsupported bindings for Haskell agro

00:07:56,350 --> 00:08:00,520
PHP and lower lower ones probably the

00:07:59,110 --> 00:08:02,320
only one that I get learnt at some point

00:08:00,520 --> 00:08:07,900
but if you're interested in one of those

00:08:02,320 --> 00:08:11,200
we could have a chat and then here's our

00:08:07,900 --> 00:08:13,230
Python API so kind of the same we even

00:08:11,200 --> 00:08:16,780
have some Python Docs that generated so

00:08:13,230 --> 00:08:19,180
can make weird reading we do Python 2

00:08:16,780 --> 00:08:22,810
and PI 3 separate binaries but they are

00:08:19,180 --> 00:08:26,260
built on the same sources and then some

00:08:22,810 --> 00:08:27,450
more Python and you can see that most of

00:08:26,260 --> 00:08:30,250
our calls are actually synchronous

00:08:27,450 --> 00:08:32,890
including for JavaScript which means we

00:08:30,250 --> 00:08:35,099
don't have that many fans and it's

00:08:32,890 --> 00:08:37,960
because we're really time sensitive so

00:08:35,099 --> 00:08:39,250
when we've benchmarked it we maybe made

00:08:37,960 --> 00:08:40,510
some asynchronous calls like some really

00:08:39,250 --> 00:08:42,340
basic stuff and we found that actually

00:08:40,510 --> 00:08:44,140
it was really really slow to make a

00:08:42,340 --> 00:08:46,089
thread and destroy just for one simple

00:08:44,140 --> 00:08:48,160
i/o operation and at the end of the day

00:08:46,089 --> 00:08:50,680
most eye operations require you to

00:08:48,160 --> 00:08:51,970
you get the result back and you kind of

00:08:50,680 --> 00:08:53,709
want it as soon as possible to get on

00:08:51,970 --> 00:08:56,500
the next thing so we found that it

00:08:53,709 --> 00:08:57,639
didn't really make that much sense but

00:08:56,500 --> 00:08:59,800
we're still curious to see why I was

00:08:57,639 --> 00:09:01,660
really so bad we do a few tests with

00:08:59,800 --> 00:09:03,940
some say non-trivial stuff and it was

00:09:01,660 --> 00:09:05,230
still pretty slow so we kind of

00:09:03,940 --> 00:09:07,360
recommend now making the sensor read

00:09:05,230 --> 00:09:10,149
completely async but not the i/o calls

00:09:07,360 --> 00:09:15,060
themselves obviously some people in the

00:09:10,149 --> 00:09:16,930
Jazz community disagree with us and

00:09:15,060 --> 00:09:18,790
finally one of the things that we would

00:09:16,930 --> 00:09:20,980
get asked is you know why unified API

00:09:18,790 --> 00:09:23,889
what's the point and all and have a cool

00:09:20,980 --> 00:09:26,529
demo that hopefully will convince you so

00:09:23,889 --> 00:09:29,139
we have this cool little JavaScript

00:09:26,529 --> 00:09:30,670
based web-based as deep Mehran

00:09:29,139 --> 00:09:33,490
fermentation which shows you the the

00:09:30,670 --> 00:09:35,079
jeaious implementation of raw and if I

00:09:33,490 --> 00:09:48,279
can type correctly which is a bit and

00:09:35,079 --> 00:09:50,819
ask we can basically make a GPIO we can

00:09:48,279 --> 00:09:50,819
write to it

00:09:53,290 --> 00:10:00,550
doesn't so that's let's say a fun way of

00:09:57,130 --> 00:10:01,959
showing why a unified API is kind of

00:10:00,550 --> 00:10:03,360
handy we can basically make it run on a

00:10:01,959 --> 00:10:06,370
web browser we can make it wrongly on

00:10:03,360 --> 00:10:10,300
any hardware and we have that same

00:10:06,370 --> 00:10:12,009
multiple implementations of it but

00:10:10,300 --> 00:10:15,000
really the the real big reason for doing

00:10:12,009 --> 00:10:18,009
this is excuse my looking at the screen

00:10:15,000 --> 00:10:20,649
is that on top of this we can basically

00:10:18,009 --> 00:10:23,829
put a bunch of sensors so on top of our

00:10:20,649 --> 00:10:25,449
API that it's kind of unified we managed

00:10:23,829 --> 00:10:28,089
to basically load a load of different

00:10:25,449 --> 00:10:29,980
sense libraries on top and what we did

00:10:28,089 --> 00:10:32,769
is we created upm which is useful

00:10:29,980 --> 00:10:34,720
plugins from raw and we made around 400

00:10:32,769 --> 00:10:37,240
sensors that are basically loaded on top

00:10:34,720 --> 00:10:39,250
of raw and we're constantly adding more

00:10:37,240 --> 00:10:42,160
and we take pull requests again this is

00:10:39,250 --> 00:10:43,600
again for the open source and you can

00:10:42,160 --> 00:10:46,180
basically go and look up any of the

00:10:43,600 --> 00:10:48,069
sensors that you like and try and add it

00:10:46,180 --> 00:10:49,620
to your project so for example my

00:10:48,069 --> 00:10:51,850
favorite temperature sensors the bmp-2

00:10:49,620 --> 00:10:53,250
80 and everyone should have a favorite

00:10:51,850 --> 00:10:58,180
temperature sensitive I think that's

00:10:53,250 --> 00:10:59,910
just like a basic and basically for this

00:10:58,180 --> 00:11:01,990
you get sometimes you get a nice picture

00:10:59,910 --> 00:11:04,920
yellow the description we have a link to

00:11:01,990 --> 00:11:08,620
the date she we have already I know it's

00:11:04,920 --> 00:11:10,389
some key specs and then down at the

00:11:08,620 --> 00:11:12,399
bottom we have basically examples of

00:11:10,389 --> 00:11:14,170
making it run in any language yeah

00:11:12,399 --> 00:11:16,120
they're not always perfect I mean they

00:11:14,170 --> 00:11:18,190
are also generate it's a little bit nice

00:11:16,120 --> 00:11:20,339
but the idea is you can get the basic

00:11:18,190 --> 00:11:22,690
idea of how you would run that sensor

00:11:20,339 --> 00:11:24,100
and again we'd be trying to make this as

00:11:22,690 --> 00:11:25,149
easy as possible so when you add a

00:11:24,100 --> 00:11:27,370
sensor and you give us a pull request

00:11:25,149 --> 00:11:29,380
from the documentation that you give us

00:11:27,370 --> 00:11:31,209
this is essentially auto-generated so

00:11:29,380 --> 00:11:33,730
again be nice it's not always super

00:11:31,209 --> 00:11:35,529
super nice and let me give you a few

00:11:33,730 --> 00:11:36,550
little examples on some platforms there

00:11:35,529 --> 00:11:38,410
might be something a little bit weird

00:11:36,550 --> 00:11:42,510
about that sensor so you need to make

00:11:38,410 --> 00:11:42,510
sure that something is celebrate

00:11:47,230 --> 00:11:57,620
okay that was the EDM slide so hopefully

00:11:55,190 --> 00:12:00,200
at this point you're thinking well this

00:11:57,620 --> 00:12:02,660
is cool how do I add my platform and

00:12:00,200 --> 00:12:04,760
what you support so here is a bunch of

00:12:02,660 --> 00:12:07,700
boards that we support rounding pictures

00:12:04,760 --> 00:12:09,350
no real order and what that means by the

00:12:07,700 --> 00:12:11,570
board supported is that we have the pins

00:12:09,350 --> 00:12:14,120
mapped and it all works out the box you

00:12:11,570 --> 00:12:17,510
get some Docs we've tested it a little

00:12:14,120 --> 00:12:18,710
bit and hopefully you'll notice it's

00:12:17,510 --> 00:12:19,850
it's much bigger than Intel you know

00:12:18,710 --> 00:12:20,750
we've bee support balls from all around

00:12:19,850 --> 00:12:24,410
the place

00:12:20,750 --> 00:12:26,240
we've got 96 boards from the Naro nice

00:12:24,410 --> 00:12:27,760
export spec most you dragon full

00:12:26,240 --> 00:12:29,870
tendency I think is one they're using

00:12:27,760 --> 00:12:33,290
mediatek I've just added two new boards

00:12:29,870 --> 00:12:36,110
just recently Google did the BeagleBone

00:12:33,290 --> 00:12:37,580
green which i think is on I and Phi Tech

00:12:36,110 --> 00:12:39,140
have their bugle bone clones

00:12:37,580 --> 00:12:41,170
I think they have slightly different

00:12:39,140 --> 00:12:43,310
there's a few little patches for them

00:12:41,170 --> 00:12:44,960
and we explore all the Raspberry Pi

00:12:43,310 --> 00:12:47,630
versions ok I remember how many there's

00:12:44,960 --> 00:12:51,430
loads of them and like for example the

00:12:47,630 --> 00:12:51,430
whole minute board series and support

00:12:53,530 --> 00:13:00,020
and we have a bunch of different ways to

00:12:56,990 --> 00:13:02,480
add platforms to lebra so the first

00:13:00,020 --> 00:13:03,710
method is what we call the raw platform

00:13:02,480 --> 00:13:05,030
and essentially it's not writing a

00:13:03,710 --> 00:13:07,220
platform it's similar to how you'd use

00:13:05,030 --> 00:13:08,990
GPIO libs we don't actually do any

00:13:07,220 --> 00:13:10,970
cleverness of mapping or try and work

00:13:08,990 --> 00:13:13,730
out what you have you just initialize

00:13:10,970 --> 00:13:18,440
pin numbers as they are in surface or

00:13:13,730 --> 00:13:20,540
you know as booted and it's pretty poor

00:13:18,440 --> 00:13:22,370
because one of the problems we get is

00:13:20,540 --> 00:13:24,560
for example you refer to device do see

00:13:22,370 --> 00:13:26,330
one but really when it boots it can be

00:13:24,560 --> 00:13:27,830
randomly assigned you can't actually

00:13:26,330 --> 00:13:31,610
guarantee the Delhi juice you want is

00:13:27,830 --> 00:13:33,440
going to be your device and stuff and

00:13:31,610 --> 00:13:36,980
based on further ways could change so

00:13:33,440 --> 00:13:38,360
internally we use this API but typically

00:13:36,980 --> 00:13:40,910
we don't advise it for anything that

00:13:38,360 --> 00:13:42,860
just development and playing around the

00:13:40,910 --> 00:13:44,480
main reason people use this is for the C

00:13:42,860 --> 00:13:47,450
platform config files and this is the

00:13:44,480 --> 00:13:48,830
main where we add thoughts and really we

00:13:47,450 --> 00:13:50,420
think it's relatively easy we've gotten

00:13:48,830 --> 00:13:53,450
a bunch of PRS with absolutely no help

00:13:50,420 --> 00:13:57,770
from nowhere to do this doesn't seem too

00:13:53,450 --> 00:13:58,940
difficult we sort them by archetype the

00:13:57,770 --> 00:14:02,480
my library tries to be

00:13:58,940 --> 00:14:04,550
portable across dev board so for example

00:14:02,480 --> 00:14:06,770
you can run on a mid abhorred copy over

00:14:04,550 --> 00:14:10,700
the binary and write on a cherry trail

00:14:06,770 --> 00:14:12,140
base up we do actually separate the

00:14:10,700 --> 00:14:13,880
architectures because there's no point

00:14:12,140 --> 00:14:16,100
in putting the arm support boards with

00:14:13,880 --> 00:14:19,550
the x86 pharmacy not going to copy the

00:14:16,100 --> 00:14:21,260
binary anyway and you can compile it for

00:14:19,550 --> 00:14:22,400
a specific board to reduce binary size

00:14:21,260 --> 00:14:25,460
we got loads of different compile

00:14:22,400 --> 00:14:26,990
options they let you do that the cool

00:14:25,460 --> 00:14:29,650
thing about this is you are able to

00:14:26,990 --> 00:14:32,000
override some of the more a specific

00:14:29,650 --> 00:14:33,650
functionality so we actually have our

00:14:32,000 --> 00:14:35,240
testing board which is the Mach 4 which

00:14:33,650 --> 00:14:37,550
overrides essentially everything the

00:14:35,240 --> 00:14:40,580
board does and triggers a bunch of tests

00:14:37,550 --> 00:14:42,680
rather than actually rely operations we

00:14:40,580 --> 00:14:46,300
do this for supporting boards for martyr

00:14:42,680 --> 00:14:49,220
based we support the D 2x x.f GTI driver

00:14:46,300 --> 00:14:50,900
things like that and then our last way

00:14:49,220 --> 00:14:53,420
of doing things is for our Jason

00:14:50,900 --> 00:14:55,580
platform API and this lets you add a

00:14:53,420 --> 00:14:56,870
relatively simple board this assumes

00:14:55,580 --> 00:14:59,870
that the kernel mostly works on your

00:14:56,870 --> 00:15:03,620
board and essentially you're able to

00:14:59,870 --> 00:15:06,230
define your board in a simple JSON JSON

00:15:03,620 --> 00:15:07,840
file and loaded it at runtime or set an

00:15:06,230 --> 00:15:10,280
environment variable to Rho load it up

00:15:07,840 --> 00:15:11,840
and we've done this actually for Intel

00:15:10,280 --> 00:15:15,710
Aero boards which is those little drones

00:15:11,840 --> 00:15:19,100
Intel has and I think they don't use it

00:15:15,710 --> 00:15:20,390
for now I hope not with for example

00:15:19,100 --> 00:15:22,250
things like the middle board turbot will

00:15:20,390 --> 00:15:23,810
load like this really easily and you

00:15:22,250 --> 00:15:26,120
don't need to actually do any actual

00:15:23,810 --> 00:15:30,890
coding inside Murat's so that's quite

00:15:26,120 --> 00:15:33,740
cool and then we come to the weird stuff

00:15:30,890 --> 00:15:37,550
so excuse me as I change gears a little

00:15:33,740 --> 00:15:41,839
bit so the the reason for this talk was

00:15:37,550 --> 00:15:44,089
really how do we apply Morar to instead

00:15:41,839 --> 00:15:45,170
of doing a direct kernel access which

00:15:44,089 --> 00:15:46,490
obviously requires us to have

00:15:45,170 --> 00:15:49,730
permissions that are a little bit

00:15:46,490 --> 00:15:51,260
dangerous we you know going samples will

00:15:49,730 --> 00:15:54,260
end up hitting death man which is

00:15:51,260 --> 00:15:57,250
obviously a big no-no but the UI or even

00:15:54,260 --> 00:15:59,960
surface can be a little bit tricky and

00:15:57,250 --> 00:16:01,790
others attempt to basically solve this

00:15:59,960 --> 00:16:03,650
problem was to use a demon could Aymara

00:16:01,790 --> 00:16:05,540
which would basically load on boot time

00:16:03,650 --> 00:16:08,410
and try and set the permissions for the

00:16:05,540 --> 00:16:10,210
various iOS with the

00:16:08,410 --> 00:16:13,090
that the users that you had said that

00:16:10,210 --> 00:16:14,470
would use these ayahs later and this

00:16:13,090 --> 00:16:16,120
kind of worked relatively well off a

00:16:14,470 --> 00:16:18,010
simple platform they didn't really scale

00:16:16,120 --> 00:16:19,840
and we had a lot of problems are more

00:16:18,010 --> 00:16:21,820
complex platforms and boxes where it

00:16:19,840 --> 00:16:23,530
wouldn't really work properly or it

00:16:21,820 --> 00:16:26,500
required real intricate knowledge of how

00:16:23,530 --> 00:16:28,780
it worked so then we work with Google on

00:16:26,500 --> 00:16:29,950
Android things and they had an

00:16:28,780 --> 00:16:31,030
interesting problem because there they

00:16:29,950 --> 00:16:33,700
created this thing called peripheral

00:16:31,030 --> 00:16:36,850
Manager Pio which is really based your

00:16:33,700 --> 00:16:39,580
demon and you request IO operations to

00:16:36,850 --> 00:16:41,710
be done with it through the Android

00:16:39,580 --> 00:16:43,600
binder and it checks that you're allowed

00:16:41,710 --> 00:16:46,150
to basically do this access that ya

00:16:43,600 --> 00:16:49,240
permissioned this boss or this specific

00:16:46,150 --> 00:16:51,190
device but they don't really have any

00:16:49,240 --> 00:16:52,510
sensors on it and like a lot of the new

00:16:51,190 --> 00:16:54,430
API is you know it was different it

00:16:52,510 --> 00:16:56,860
wasn't you didn't really have much I

00:16:54,430 --> 00:17:00,040
think they had two sensors examples on

00:16:56,860 --> 00:17:01,900
this and we did a dev kit with them and

00:17:00,040 --> 00:17:03,520
we thought well you know instead of

00:17:01,900 --> 00:17:05,589
porting all of our senses visually what

00:17:03,520 --> 00:17:08,560
they asked us to do initially we thought

00:17:05,589 --> 00:17:12,640
that's a lot of work so we'd do the lazy

00:17:08,560 --> 00:17:15,010
you know halfway around the pie and just

00:17:12,640 --> 00:17:16,750
make a back-end that actually calls the

00:17:15,010 --> 00:17:18,670
peripheral manager instead of actually

00:17:16,750 --> 00:17:20,680
calling the direct kernel functionality

00:17:18,670 --> 00:17:23,829
and then we'll let Pio how do you do

00:17:20,680 --> 00:17:25,620
that work and actually the Pio API

00:17:23,829 --> 00:17:28,870
luckily was very very similar to ours I

00:17:25,620 --> 00:17:31,150
dare say it's a copy and we may well be

00:17:28,870 --> 00:17:32,680
called kimura we like to prefix things

00:17:31,150 --> 00:17:37,240
in front of Marat we had like said Marat

00:17:32,680 --> 00:17:40,390
W Marat team wrong it's bad jokes but

00:17:37,240 --> 00:17:43,960
essentially what we did is instead of

00:17:40,390 --> 00:17:45,760
calling dev I to see n suddenly you were

00:17:43,960 --> 00:17:48,580
actually asking for the peripheral

00:17:45,760 --> 00:17:50,170
manager for I squared C plus N and then

00:17:48,580 --> 00:17:52,570
doing operations based on it through

00:17:50,170 --> 00:17:53,860
that and we use our Java bindings and

00:17:52,570 --> 00:17:54,880
especially when we we made our Java

00:17:53,860 --> 00:17:57,910
bindings way better than they were

00:17:54,880 --> 00:17:59,470
before and we added a few different

00:17:57,910 --> 00:18:01,660
little things like we added em Ryan it

00:17:59,470 --> 00:18:03,610
io cool that takes a string argument and

00:18:01,660 --> 00:18:06,300
returns you a heading context you can do

00:18:03,610 --> 00:18:09,550
something slightly more dynamic stuff

00:18:06,300 --> 00:18:11,560
and then because we increased and maybe

00:18:09,550 --> 00:18:14,890
Liam Ross back-end much better we were

00:18:11,560 --> 00:18:17,320
actually able to merge all that work

00:18:14,890 --> 00:18:19,470
back into the mainline marah so you can

00:18:17,320 --> 00:18:23,400
now based you compile a Android

00:18:19,470 --> 00:18:25,559
things wrong and one thing to know is

00:18:23,400 --> 00:18:27,120
when we talk about backends we have some

00:18:25,559 --> 00:18:29,400
backends that are unique

00:18:27,120 --> 00:18:33,120
so like Marah the peripheral manager one

00:18:29,400 --> 00:18:35,460
or even the FB one and we have others

00:18:33,120 --> 00:18:36,720
that are um treated as sub platforms so

00:18:35,460 --> 00:18:38,730
you can actually have two backends

00:18:36,720 --> 00:18:40,260
running in raw at the same time so when

00:18:38,730 --> 00:18:42,120
we run our multiple typically we

00:18:40,260 --> 00:18:45,350
consider that an add-on board so you're

00:18:42,120 --> 00:18:46,950
able to do IO directly on your SBC and

00:18:45,350 --> 00:18:48,929
then do i/o

00:18:46,950 --> 00:18:54,720
on the fanat aboard by basically adding

00:18:48,929 --> 00:18:56,730
a an offset to your IO numbers so when

00:18:54,720 --> 00:18:59,789
you ask for bus 512 you'll actually get

00:18:56,730 --> 00:19:02,400
the USB controlled for not a board or

00:18:59,789 --> 00:19:04,890
Bluetooth enabled bought instead of your

00:19:02,400 --> 00:19:06,539
native board but for peripheral manager

00:19:04,890 --> 00:19:08,520
of a CEO and you have one board so

00:19:06,539 --> 00:19:10,110
that's really the native board and we

00:19:08,520 --> 00:19:13,260
start the numbering just like they do in

00:19:10,110 --> 00:19:14,460
peripheral manager and so you can see

00:19:13,260 --> 00:19:16,049
that's kind of how the stack ends up

00:19:14,460 --> 00:19:19,760
looking you get your application in Java

00:19:16,049 --> 00:19:23,130
it calls Mirage Java and then it calls

00:19:19,760 --> 00:19:25,049
libera with the peripheral back-end

00:19:23,130 --> 00:19:27,090
which cools and cools the Android binder

00:19:25,049 --> 00:19:29,010
request basically access to things and

00:19:27,090 --> 00:19:30,780
the peripheral manages and she does the

00:19:29,010 --> 00:19:33,090
operation on the kernel directly so we

00:19:30,780 --> 00:19:40,679
don't actually ever touch the kernel in

00:19:33,090 --> 00:19:41,940
this case so now we move on to the aft

00:19:40,679 --> 00:19:45,950
part of the presentation which is the

00:19:41,940 --> 00:19:45,950
whole reason really I did this

00:19:48,480 --> 00:19:54,750
and so the base of it it's probably a

00:19:53,100 --> 00:19:56,430
whole presentation I hope some of you

00:19:54,750 --> 00:19:59,700
guys watch the HDR presentation next

00:19:56,430 --> 00:20:02,010
door but it's it's a way to connect

00:19:59,700 --> 00:20:12,570
applications to services promoted by um

00:20:02,010 --> 00:20:14,910
the automotive grade Linux group and and

00:20:12,570 --> 00:20:18,690
essentially the way it works is you have

00:20:14,910 --> 00:20:21,200
a security context which is ensured by

00:20:18,690 --> 00:20:23,490
smack and you run an application

00:20:21,200 --> 00:20:26,430
connected to a local binder and the

00:20:23,490 --> 00:20:29,250
binder runs on the same security context

00:20:26,430 --> 00:20:31,590
as your application and the binder lets

00:20:29,250 --> 00:20:34,320
you basically load dynamic libraries the

00:20:31,590 --> 00:20:36,420
few magic hooks which essentially load a

00:20:34,320 --> 00:20:39,540
service that you can call from your

00:20:36,420 --> 00:20:42,210
application and you can actually do this

00:20:39,540 --> 00:20:43,140
either on the same security context but

00:20:42,210 --> 00:20:45,540
actually you can do it in a different

00:20:43,140 --> 00:20:48,210
security context and you still call your

00:20:45,540 --> 00:20:49,560
local binder but it's actually going to

00:20:48,210 --> 00:20:51,000
call a service that's running in a

00:20:49,560 --> 00:20:53,250
different application in a different

00:20:51,000 --> 00:20:54,960
context and you can do this over the

00:20:53,250 --> 00:20:56,910
network you can do this completely

00:20:54,960 --> 00:20:59,640
locally and it's completely transparent

00:20:56,910 --> 00:21:01,230
to the calling application so the

00:20:59,640 --> 00:21:04,020
application always talks its local

00:21:01,230 --> 00:21:07,340
binder which are closed which exposes

00:21:04,020 --> 00:21:09,090
the bindings it's got access to and

00:21:07,340 --> 00:21:10,950
essentially though the finest can be

00:21:09,090 --> 00:21:12,720
connected via d-bus web sockets rather

00:21:10,950 --> 00:21:16,580
other connection types but it doesn't

00:21:12,720 --> 00:21:20,250
actually matter who as part of the the

00:21:16,580 --> 00:21:21,690
calling application and what's really

00:21:20,250 --> 00:21:24,150
cool about AFP is it doesn't actually

00:21:21,690 --> 00:21:25,920
require a GL there is a component of it

00:21:24,150 --> 00:21:27,990
so you can install it on virtually

00:21:25,920 --> 00:21:30,600
anything those running Linux which has a

00:21:27,990 --> 00:21:32,250
non ancient Jason see there's some

00:21:30,600 --> 00:21:34,020
packages you can do it in modern and

00:21:32,250 --> 00:21:35,730
common distros out of the box but it's

00:21:34,020 --> 00:21:37,440
basically a few minutes to compile

00:21:35,730 --> 00:21:38,700
that's really really easy it's just down

00:21:37,440 --> 00:21:41,520
to you mate nothing special

00:21:38,700 --> 00:21:43,380
and with the binder comes a few like

00:21:41,520 --> 00:21:45,000
utils and demo tools they're quite nice

00:21:43,380 --> 00:21:48,270
but really what we're interested in is

00:21:45,000 --> 00:21:50,850
the lib fews see some I like to explain

00:21:48,270 --> 00:21:53,310
that naming but it's it's what Marat

00:21:50,850 --> 00:21:56,360
uses to contact with local binder so

00:21:53,310 --> 00:21:58,260
it's really a pretty easy API and

00:21:56,360 --> 00:22:00,780
essentially you pay to be passed

00:21:58,260 --> 00:22:01,080
adjacency you adjacent message which

00:22:00,780 --> 00:22:04,140
goes

00:22:01,080 --> 00:22:06,750
Jesse and essentially Europe you're off

00:22:04,140 --> 00:22:09,030
to them to calling a function in your

00:22:06,750 --> 00:22:10,620
binding you can do this in C which is

00:22:09,030 --> 00:22:14,910
why did but you can apparently do it in

00:22:10,620 --> 00:22:18,270
Lua it's really easy I have a looked so

00:22:14,910 --> 00:22:21,210
look how it works so that's the the

00:22:18,270 --> 00:22:23,430
simple picture of how how you basically

00:22:21,210 --> 00:22:29,880
plug in rata AFB and the kind of cool

00:22:23,430 --> 00:22:32,220
thing is you've gone to Mars so the way

00:22:29,880 --> 00:22:34,560
it works we have one row with the back

00:22:32,220 --> 00:22:35,610
end and one bra that runs normally and

00:22:34,560 --> 00:22:37,620
here we put them all on the same

00:22:35,610 --> 00:22:39,300
security context to make it a little bit

00:22:37,620 --> 00:22:43,680
easier I'll show you the more complex

00:22:39,300 --> 00:22:45,570
one afterwards but the idea is the the

00:22:43,680 --> 00:22:48,150
application calls them raw with the back

00:22:45,570 --> 00:22:50,610
end with the AAP back end the AFB back

00:22:48,150 --> 00:22:52,800
end talks to the actual binder with the

00:22:50,610 --> 00:22:55,650
binding loaded and actually the binding

00:22:52,800 --> 00:22:57,330
is linked to libera the normal one and

00:22:55,650 --> 00:22:59,760
by normal I mean the one with the actual

00:22:57,330 --> 00:23:01,380
hardware platform support your AFB

00:22:59,760 --> 00:23:03,960
memorized compiled just for the AFB

00:23:01,380 --> 00:23:08,790
platform so you do have to do some magic

00:23:03,960 --> 00:23:10,440
to two libraries and the way it works is

00:23:08,790 --> 00:23:13,590
the the permissions are entirely handled

00:23:10,440 --> 00:23:15,480
by AFP by the binder so you can

00:23:13,590 --> 00:23:17,280
basically say well this application only

00:23:15,480 --> 00:23:19,230
has access to run this I squared C on

00:23:17,280 --> 00:23:23,580
this address so it's really quite

00:23:19,230 --> 00:23:26,400
perfect well two addresses but really

00:23:23,580 --> 00:23:28,560
you can only send receive messages that

00:23:26,400 --> 00:23:30,090
were intended for you and you can't

00:23:28,560 --> 00:23:31,950
access the bus directly anymore because

00:23:30,090 --> 00:23:34,410
it's hidden by a Saturday FB we're not

00:23:31,950 --> 00:23:37,020
able to access the local i/o and that's

00:23:34,410 --> 00:23:38,400
what's really cool so let me show you

00:23:37,020 --> 00:23:41,880
the more complex picture which actually

00:23:38,400 --> 00:23:48,630
does some of this and this is I try to

00:23:41,880 --> 00:23:49,500
make this kind of funky so if you guys

00:23:48,630 --> 00:23:51,630
shows a little bit more I'm talking

00:23:49,500 --> 00:23:54,900
about but in this diagram which actually

00:23:51,630 --> 00:23:56,640
the way I developed it we have a third

00:23:54,900 --> 00:23:58,320
martyr board so we're not actually

00:23:56,640 --> 00:23:59,610
hitting the little directly we're

00:23:58,320 --> 00:24:02,340
actually hitting a Fermata ball that's

00:23:59,610 --> 00:24:05,190
connected via you are and what we're

00:24:02,340 --> 00:24:07,680
doing is talking from our application to

00:24:05,190 --> 00:24:11,400
an I squared see you p.m. sensor like a

00:24:07,680 --> 00:24:13,440
BMP 280 and then that's talking to our

00:24:11,400 --> 00:24:14,820
libera with Aria be back-end which is

00:24:13,440 --> 00:24:17,610
making a binder cool

00:24:14,820 --> 00:24:20,490
or the airfryer binding once we do that

00:24:17,610 --> 00:24:22,080
we enter the the that binder security

00:24:20,490 --> 00:24:23,850
context so suddenly we're able to

00:24:22,080 --> 00:24:25,320
actually make a you are cool than before

00:24:23,850 --> 00:24:27,870
we don't have access to the you are of

00:24:25,320 --> 00:24:29,250
our colonel and suddenly from our for

00:24:27,870 --> 00:24:31,590
not enabled libera

00:24:29,250 --> 00:24:34,080
we're able to hit the you are and go and

00:24:31,590 --> 00:24:36,720
call often alter board so actually in

00:24:34,080 --> 00:24:39,330
this it's it's ready to you complex

00:24:36,720 --> 00:24:42,059
because we're actually going for an i2c

00:24:39,330 --> 00:24:43,590
mark all from you p.m. into the binder

00:24:42,059 --> 00:24:46,590
which is then transforming it into

00:24:43,590 --> 00:24:48,090
adjacent message passing it into two

00:24:46,590 --> 00:24:50,429
verbs that are being called on the air

00:24:48,090 --> 00:24:52,620
from our binding which then converts it

00:24:50,429 --> 00:24:55,440
to a MIDI message to be pass while you

00:24:52,620 --> 00:24:57,480
are and Fermata is a MIDI kind of based

00:24:55,440 --> 00:25:00,200
protocol which will actually then do the

00:24:57,480 --> 00:25:02,909
i/o operation so you can see it's

00:25:00,200 --> 00:25:04,500
relatively non-trivial but it all works

00:25:02,909 --> 00:25:06,750
actually relatively easily because we

00:25:04,500 --> 00:25:08,490
already have that part of the stack and

00:25:06,750 --> 00:25:13,320
all we need to do is basically transform

00:25:08,490 --> 00:25:14,909
the morale calls into Jason functions AF

00:25:13,320 --> 00:25:18,419
because of those essential function

00:25:14,909 --> 00:25:20,070
calls with the right arguments to the

00:25:18,419 --> 00:25:29,070
binding which actually cause the morale

00:25:20,070 --> 00:25:31,259
calls directly and so our feedback and

00:25:29,070 --> 00:25:32,879
basically works by extending them our

00:25:31,259 --> 00:25:34,769
IEP iwell overriding some of the

00:25:32,879 --> 00:25:36,779
functionalities so every liberar call

00:25:34,769 --> 00:25:40,679
actually has the possibility for

00:25:36,779 --> 00:25:42,269
overrides on this normal behavior so we

00:25:40,679 --> 00:25:44,789
usually you did this because of odd

00:25:42,269 --> 00:25:46,799
platforms like the X 1000 quite platform

00:25:44,789 --> 00:25:49,529
or non-standard kernels like some of

00:25:46,799 --> 00:25:52,200
your PI stuff well because we weren't

00:25:49,529 --> 00:25:54,509
talking to linux directly like the manta

00:25:52,200 --> 00:25:57,629
base platform z 2x x peripheral manager

00:25:54,509 --> 00:26:00,179
and the AGL platform is just an example

00:25:57,629 --> 00:26:03,450
of that so we compile it with the build

00:26:00,179 --> 00:26:05,669
art AFP this triggers all the calls to

00:26:03,450 --> 00:26:08,250
go to the FB bus rather than directly to

00:26:05,669 --> 00:26:09,929
the kernel and once we do that we

00:26:08,250 --> 00:26:11,460
override all the platform functionality

00:26:09,929 --> 00:26:13,049
so we no longer have basically a

00:26:11,460 --> 00:26:20,759
standard platform we have an eight GL

00:26:13,049 --> 00:26:22,620
star platform and I use a gel but

00:26:20,759 --> 00:26:25,110
basically when we ask the dev I to see n

00:26:22,620 --> 00:26:26,100
we really go off and we make a call via

00:26:25,110 --> 00:26:31,590
a

00:26:26,100 --> 00:26:33,600
BW s j1 core S which is asynchronous and

00:26:31,590 --> 00:26:35,340
that's a bit useless for us because we

00:26:33,600 --> 00:26:37,169
basically feat another response right

00:26:35,340 --> 00:26:39,030
away so we basically go and wait a

00:26:37,169 --> 00:26:41,010
little bit it's a bit inefficient we

00:26:39,030 --> 00:26:42,480
pointed to fix that but for example

00:26:41,010 --> 00:26:44,309
there are things that for the platform

00:26:42,480 --> 00:26:45,630
name for example we actually don't need

00:26:44,309 --> 00:26:47,340
permission for that one so we can go

00:26:45,630 --> 00:26:49,020
grab that directly there are some things

00:26:47,340 --> 00:26:50,669
that are done directly because we can do

00:26:49,020 --> 00:26:52,110
this directly from the binder and there

00:26:50,669 --> 00:26:55,289
are some things we actually go and query

00:26:52,110 --> 00:26:56,760
to the platform for but the cool thing

00:26:55,289 --> 00:26:58,350
as you can see now is that we can

00:26:56,760 --> 00:27:01,020
interconnect different applications

00:26:58,350 --> 00:27:03,570
through the binder and we can start

00:27:01,020 --> 00:27:05,340
queuing it we can start caching results

00:27:03,570 --> 00:27:06,960
for AIO calls we could start caching

00:27:05,340 --> 00:27:09,740
those results if we're asking for too

00:27:06,960 --> 00:27:09,740
much things like that

00:27:19,310 --> 00:27:25,310
and so DTF Mar binding is typically

00:27:22,490 --> 00:27:27,410
linked against static live Murat's them

00:27:25,310 --> 00:27:29,630
you can basically keep that easily

00:27:27,410 --> 00:27:31,010
available just for that binding and then

00:27:29,630 --> 00:27:32,360
all the other applications are linked

00:27:31,010 --> 00:27:34,820
against the dynamically parameters

00:27:32,360 --> 00:27:37,460
vailable on the system and it's

00:27:34,820 --> 00:27:39,230
obviously that version will be linked to

00:27:37,460 --> 00:27:40,850
the hardware specifically so it's really

00:27:39,230 --> 00:27:44,870
basically treat the hardware rather than

00:27:40,850 --> 00:27:46,940
the AFP bus all the AAV bus actually

00:27:44,870 --> 00:27:50,480
functionality is in the binding itself

00:27:46,940 --> 00:27:51,620
rather than in the in the libera so you

00:27:50,480 --> 00:27:52,670
get a little bit confusing because you

00:27:51,620 --> 00:27:54,170
essentially have two versions the

00:27:52,670 --> 00:27:57,710
library which means this talks a little

00:27:54,170 --> 00:28:01,090
bit of a mess but that's some part of

00:27:57,710 --> 00:28:01,090
what we'll fix in there in the future

00:28:02,290 --> 00:28:08,960
and now we get on to the future and what

00:28:06,620 --> 00:28:10,790
we're doing so there's a bunch of stuff

00:28:08,960 --> 00:28:13,840
left to do I didn't do quite as much as

00:28:10,790 --> 00:28:17,630
I wanted to before this presentation so

00:28:13,840 --> 00:28:19,730
currently the ADL platform in Marah has

00:28:17,630 --> 00:28:22,370
no real knowledge of what support on the

00:28:19,730 --> 00:28:24,830
platform we have no base introspection

00:28:22,370 --> 00:28:26,480
which we normally do on a platform so

00:28:24,830 --> 00:28:28,850
we're able to query what we have and

00:28:26,480 --> 00:28:31,760
what we can do currently is kind of

00:28:28,850 --> 00:28:33,500
let's say and ask and forget mode so

00:28:31,760 --> 00:28:35,300
you'll get refused if you're not able to

00:28:33,500 --> 00:28:36,830
of course but we basically don't have

00:28:35,300 --> 00:28:40,250
the ability to tell you what you can do

00:28:36,830 --> 00:28:42,710
it's not quite as nice and our binding

00:28:40,250 --> 00:28:45,530
is pretty simplistic it provides it's

00:28:42,710 --> 00:28:48,290
based on the version two of the AFB

00:28:45,530 --> 00:28:50,090
binder but it's pretty simplistic and

00:28:48,290 --> 00:28:52,820
that we only have two verbs we have dev

00:28:50,090 --> 00:28:54,560
in it and we have a command which is

00:28:52,820 --> 00:28:57,380
basically a morale command against an

00:28:54,560 --> 00:28:58,790
initialized context and I think in the

00:28:57,380 --> 00:29:00,290
future we'll try and clean that up so

00:28:58,790 --> 00:29:02,900
you can actually use the binding

00:29:00,290 --> 00:29:05,420
directly and actually use it without

00:29:02,900 --> 00:29:07,610
another librar you wanted to and do

00:29:05,420 --> 00:29:08,990
cause directly through that and

00:29:07,610 --> 00:29:10,460
currently you can but it's just a little

00:29:08,990 --> 00:29:15,020
bit ugly and we haven't made any effort

00:29:10,460 --> 00:29:17,570
to make that nice and one of the other

00:29:15,020 --> 00:29:19,370
things that currently are that the

00:29:17,570 --> 00:29:21,140
course AFP all asynchronous and we

00:29:19,370 --> 00:29:23,570
basically have to lock on that and

00:29:21,140 --> 00:29:25,880
that's a little bit nasty so we've got a

00:29:23,570 --> 00:29:29,150
bit of hack to do that nice and shiny

00:29:25,880 --> 00:29:31,160
but we'll probably just write a new year

00:29:29,150 --> 00:29:31,470
B call the let's do that directly just

00:29:31,160 --> 00:29:34,830
be

00:29:31,470 --> 00:29:36,120
yeah and the last thing is the we

00:29:34,830 --> 00:29:37,980
essentially have the I square Z function

00:29:36,120 --> 00:29:40,470
out you're working but we don't have any

00:29:37,980 --> 00:29:42,179
of the other bra I or protocols and this

00:29:40,470 --> 00:29:44,100
is more because I wanted to make one

00:29:42,179 --> 00:29:46,590
word nicely gets the feedback and see

00:29:44,100 --> 00:29:48,600
where it is going and as soon as we have

00:29:46,590 --> 00:29:51,270
that working nicely we'll move on to the

00:29:48,600 --> 00:29:52,080
other ones and some of the other

00:29:51,270 --> 00:29:53,309
protocols

00:29:52,080 --> 00:29:54,780
I think the I squares you want is

00:29:53,309 --> 00:29:56,700
probably one of those widely use that we

00:29:54,780 --> 00:29:59,520
have and it's it's probably one of the

00:29:56,700 --> 00:30:01,200
more complex ones anyway so we'll see

00:29:59,520 --> 00:30:02,880
where that goes from that hopefully the

00:30:01,200 --> 00:30:07,740
ones are for long relatively easily when

00:30:02,880 --> 00:30:10,080
we when we have that and then I've got

00:30:07,740 --> 00:30:12,870
some further reading and Docs if you

00:30:10,080 --> 00:30:16,559
want to look at more things so it's all

00:30:12,870 --> 00:30:18,690
on I'll get a page we have morale we

00:30:16,559 --> 00:30:20,789
have the raw binding which lives in a

00:30:18,690 --> 00:30:22,860
sigh different place we also have the

00:30:20,789 --> 00:30:25,730
UPN website and UPN is on the same

00:30:22,860 --> 00:30:28,320
github just GPM and you end up on there

00:30:25,730 --> 00:30:29,640
we're fairly active on github issues if

00:30:28,320 --> 00:30:31,530
you have any problems or you want to

00:30:29,640 --> 00:30:32,970
play with it there's a Doc's folder and

00:30:31,530 --> 00:30:36,059
rod that explains a little bit of the

00:30:32,970 --> 00:30:37,679
compilation and how to do that and we

00:30:36,059 --> 00:30:42,270
obviously have a free no tiles channel

00:30:37,679 --> 00:30:44,340
which I'm usually on a mailing list yeah

00:30:42,270 --> 00:30:47,640
github issue seems to be where people go

00:30:44,340 --> 00:30:51,950
oh yeah that's it's thanks a lot

00:30:47,640 --> 00:30:51,950
listening and any questions

00:30:56,670 --> 00:31:01,130
I don't have a microphone I apologize

00:31:01,730 --> 00:31:05,179
yeah okay here

00:31:30,880 --> 00:31:35,150
so we've not really tried to be real

00:31:33,530 --> 00:31:36,820
time because we're let's say way too far

00:31:35,150 --> 00:31:39,530
at the stack to really even pretend

00:31:36,820 --> 00:31:41,150
we're more hitting stuff that's not real

00:31:39,530 --> 00:31:43,070
time critical so there's plenty of

00:31:41,150 --> 00:31:44,510
sensor readings for example which aren't

00:31:43,070 --> 00:31:46,640
necessarily real time you need an answer

00:31:44,510 --> 00:31:50,390
let's say relatively quickly but exactly

00:31:46,640 --> 00:31:51,680
when is not necessarily required yeah if

00:31:50,390 --> 00:31:53,900
you want real-time stuff you're gonna

00:31:51,680 --> 00:31:55,370
need to be way deeper down I don't think

00:31:53,900 --> 00:32:00,290
this is gonna solve your need

00:31:55,370 --> 00:32:01,460
we are not mr. monistic I mean that's

00:32:00,290 --> 00:32:03,410
part of the game right so it's meant

00:32:01,460 --> 00:32:05,360
more at prototyping and doing fast dev

00:32:03,410 --> 00:32:07,190
not rebooting the kernel doing things

00:32:05,360 --> 00:32:08,840
quickly and then if you need to move

00:32:07,190 --> 00:32:10,280
further down then you do need to be

00:32:08,840 --> 00:32:12,920
deterministic then you need to move down

00:32:10,280 --> 00:32:15,560
the kernel and we that's why partly why

00:32:12,920 --> 00:32:17,450
we have the i/o stuff so we're able to

00:32:15,560 --> 00:32:20,270
do it user space binding on top of an

00:32:17,450 --> 00:32:22,490
i/o kernel sensor and I guess that could

00:32:20,270 --> 00:32:24,830
be relatively - deterministic depending

00:32:22,490 --> 00:32:26,600
how you compile your kernel we have done

00:32:24,830 --> 00:32:27,920
that for certain platforms that want

00:32:26,600 --> 00:32:29,780
that but even then I mean when you're

00:32:27,920 --> 00:32:32,860
calling that from user space you're back

00:32:29,780 --> 00:32:32,860
to not being terminus deck

00:33:02,460 --> 00:33:06,749
so it depends on which platform you look

00:33:04,649 --> 00:33:09,509
at there are definitely some when we're

00:33:06,749 --> 00:33:10,200
very hard coded there is someone we go

00:33:09,509 --> 00:33:14,820
and look

00:33:10,200 --> 00:33:16,110
PG ID stuff no we don't have a chat

00:33:14,820 --> 00:33:18,389
about which ones you looked at and what

00:33:16,110 --> 00:33:21,059
what you thought was bad but there's

00:33:18,389 --> 00:33:22,499
there's some magic that we do for

00:33:21,059 --> 00:33:23,789
example supporting different kernel

00:33:22,499 --> 00:33:25,649
versions like freeze up on the middle

00:33:23,789 --> 00:33:29,100
board max when the kernel changed the

00:33:25,649 --> 00:33:30,629
max NRG ko value so they see if we

00:33:29,100 --> 00:33:33,299
wanted to support two different kernels

00:33:30,629 --> 00:33:34,559
we have to be a bit of magic we can't

00:33:33,299 --> 00:33:37,259
actually get that value from the kernel

00:33:34,559 --> 00:33:38,549
so we have to do a bit of magic there

00:33:37,259 --> 00:33:41,820
are a few little things that we've not

00:33:38,549 --> 00:33:43,230
managed to get but yeah I mean some of

00:33:41,820 --> 00:33:44,820
those some of the platforms support is

00:33:43,230 --> 00:33:46,830
not always perfect especially I think

00:33:44,820 --> 00:33:51,179
the the Raspberry Pi one comes to mind

00:33:46,830 --> 00:33:52,320
is the one that's very nasty but you're

00:33:51,179 --> 00:33:55,490
more than welcome to file a bug if you

00:33:52,320 --> 00:33:55,490
see something that you think is nasty

00:34:07,560 --> 00:34:12,669
so yes yes support for both so we are

00:34:10,270 --> 00:34:13,839
support for their child ev although

00:34:12,669 --> 00:34:15,909
that's still on the branch so you have

00:34:13,839 --> 00:34:17,409
to go look for it but we have since they

00:34:15,909 --> 00:34:19,389
first we have Charter and then some

00:34:17,409 --> 00:34:21,790
platforms will use WI o if that's

00:34:19,389 --> 00:34:23,859
something that they specified but yeah

00:34:21,790 --> 00:34:27,159
we are looking to merge to child that

00:34:23,859 --> 00:34:29,649
stuff really soon but yeah that only you

00:34:27,159 --> 00:34:30,820
can work on your kernels obviously and

00:34:29,649 --> 00:34:34,649
that's still difficult and a lot of

00:34:30,820 --> 00:34:34,649
SBC's to run brand-new kernels

00:34:41,060 --> 00:34:44,380

YouTube URL: https://www.youtube.com/watch?v=uGkUelrzYcc


