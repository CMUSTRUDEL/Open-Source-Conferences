Title: printk() - The Most Useful Tool is Now Showing its Age - Steven Rostedt, VMware & Sergey Senozhatsky
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	printk() - The Most Useful Tool is Now Showing its Age - Steven Rostedt, VMware & Sergey Senozhatsky, Samsung Electronics

printk() has been the tool for debugging the Linux kernel and for being the display mechanism for Linux as long as Linux has been around. It's the first thing one sees as the life of the kernel begins, from the kernel banner and the last message at shutdown. It's critical as people take pictures of a kernel oops to send to the kernel developers to fix a bug, or to display on social media when that oops happens on the monitor on the back of an airplane seat in front of you.

But printk() is not a trivial utility. It serves many functionalities and some of them can be conflicting. Today with Linux running on machines with hundreds of CPUs, printk() can actually be the cause of live locks. This talk will discuss the history of printk, how it's grown, issues that have come about it, and why it is a pain that it is today.

About Steven Rostedt
Steven Rostedt currently works for VMware in their Open Source Technology Center. He's the maintainer of the stable releases for the Real Time patch (PREEMPT_RT). He is also one of the original developers for the Real Time patch. Steven is the main developer and maintainer for ftrace, the official tracer of the Linux kernel, as well as the user space tools trace-cmd and kernelshark. He also develops ktest.pl (in the kernel) and make localmodconfig.

About Sergey Senozhatsky
Sergey Senozhatsky currently works for Samsung Electronics, VD division, Korea.He is the co-maintainer of the printk() code. He is also a distinguished reviewer and developer for the upstream zsmalloc memory allocator and zram compressing block device driver.
Captions: 
	00:00:00,000 --> 00:00:05,370
welcome my name's Steve Ross Ted I work

00:00:01,829 --> 00:00:07,350
for VMware and I'm one of the reviewers

00:00:05,370 --> 00:00:09,660
for all print K patches that come

00:00:07,350 --> 00:00:10,740
through and I purposely made myself be a

00:00:09,660 --> 00:00:12,389
reviewer because I used print K

00:00:10,740 --> 00:00:14,160
extensively it's one things that you

00:00:12,389 --> 00:00:16,590
actually used to debug F trace with and

00:00:14,160 --> 00:00:18,830
I wanted to be reviewers so I could keep

00:00:16,590 --> 00:00:22,080
any crap out that I didn't want to think

00:00:18,830 --> 00:00:25,740
and I always do my little selfie in

00:00:22,080 --> 00:00:31,019
front of everyone I yeah I was pretty

00:00:25,740 --> 00:00:33,750
good anyway I have a lot of slides as

00:00:31,019 --> 00:00:36,899
those know me I've seen my talks before

00:00:33,750 --> 00:00:41,190
I usually sometimes make animation more

00:00:36,899 --> 00:00:43,200
than slot presentations so first I might

00:00:41,190 --> 00:00:45,030
start off with what is print K and I'm

00:00:43,200 --> 00:00:47,280
assume that most everyone here knows

00:00:45,030 --> 00:00:50,309
what print K is I mean okay anyone not

00:00:47,280 --> 00:00:51,690
know what print K is okay Oh what hand

00:00:50,309 --> 00:00:53,250
went up everyone else is afraid because

00:00:51,690 --> 00:00:55,770
I just said everyone knows Frank K so

00:00:53,250 --> 00:00:57,059
when I said no window or it goes raise

00:00:55,770 --> 00:00:59,309
your hand if you don't you're like wait

00:00:57,059 --> 00:01:02,489
everyone knows Frank K I'm gonna pretend

00:00:59,309 --> 00:01:04,470
I do too so that's not really fair to

00:01:02,489 --> 00:01:07,530
say it that way but brick K is basically

00:01:04,470 --> 00:01:09,090
the print F of the kernel and when I

00:01:07,530 --> 00:01:13,200
first started doing kernel development

00:01:09,090 --> 00:01:14,490
within back in 98 for my masters well

00:01:13,200 --> 00:01:15,990
actually it's going for my masters and

00:01:14,490 --> 00:01:19,159
one of the projects was working in the

00:01:15,990 --> 00:01:22,680
kernel and the people I was working with

00:01:19,159 --> 00:01:24,420
wanted they said how do we print to

00:01:22,680 --> 00:01:28,229
debug our code that we're modifying and

00:01:24,420 --> 00:01:29,549
they put in include standard IO into the

00:01:28,229 --> 00:01:33,030
header file compiled it didn't

00:01:29,549 --> 00:01:35,579
understand why it didn't work everything

00:01:33,030 --> 00:01:37,740
in the kernel is self-contained all

00:01:35,579 --> 00:01:41,400
functions are written within the kernel

00:01:37,740 --> 00:01:43,619
so there is no Lipsy so it's printf but

00:01:41,400 --> 00:01:44,909
I'm glad it's called print K some people

00:01:43,619 --> 00:01:46,409
said we should have called the printf

00:01:44,909 --> 00:01:48,329
and I'm like no I'm glad it's called

00:01:46,409 --> 00:01:50,610
print K and you always know a kernel

00:01:48,329 --> 00:01:52,020
developer when they do user space code

00:01:50,610 --> 00:01:57,960
because they always type print K and

00:01:52,020 --> 00:01:59,490
their code doesn't compile so basically

00:01:57,960 --> 00:02:00,810
it's print guys are pretty obviously

00:01:59,490 --> 00:02:03,659
thing is used to display information

00:02:00,810 --> 00:02:07,409
shows stack traces when your system

00:02:03,659 --> 00:02:09,989
crashes and panics I went back and did a

00:02:07,409 --> 00:02:12,720
little archeology or whatever everyone

00:02:09,989 --> 00:02:13,770
call it then into the Linux kernel

00:02:12,720 --> 00:02:18,870
history

00:02:13,770 --> 00:02:21,830
and i downloaded linux 1.0 and i said

00:02:18,870 --> 00:02:24,090
what does print k look like there and

00:02:21,830 --> 00:02:27,080
it's actually not much different than it

00:02:24,090 --> 00:02:28,410
does today first thing it happens is you

00:02:27,080 --> 00:02:30,840
copy

00:02:28,410 --> 00:02:32,790
if interrupts are on or off you save

00:02:30,840 --> 00:02:35,340
that's that first say flags means you

00:02:32,790 --> 00:02:37,830
know our interrupts enabled then clear

00:02:35,340 --> 00:02:40,530
save it to flags variable and then you

00:02:37,830 --> 00:02:41,970
clear interrupts you then this is

00:02:40,530 --> 00:02:43,470
actually familiar code that's you

00:02:41,970 --> 00:02:45,870
probably seen this in userspace by the

00:02:43,470 --> 00:02:47,700
way that vs printf is implemented in the

00:02:45,870 --> 00:02:50,190
kernel there's no library there the VI a

00:02:47,700 --> 00:02:51,720
star is kind of a compiler thing so it

00:02:50,190 --> 00:02:54,750
doesn't need to be implemented but the

00:02:51,720 --> 00:02:55,800
vs for F has to be implemented and it's

00:02:54,750 --> 00:02:59,970
kind of strange because we look at the

00:02:55,800 --> 00:03:06,420
buff +3 and I love this comment true

00:02:59,970 --> 00:03:08,640
Quality Assurance so then this we go

00:03:06,420 --> 00:03:12,330
through this loop starting with buff

00:03:08,640 --> 00:03:14,910
plus 3 strange and we go into a buff end

00:03:12,330 --> 00:03:16,290
and then we signed our message the

00:03:14,910 --> 00:03:19,320
message we're going to print is y equal

00:03:16,290 --> 00:03:21,510
to P and then we check this thing call

00:03:19,320 --> 00:03:23,010
the message level what's this message

00:03:21,510 --> 00:03:26,910
level but you notice it starts off at

00:03:23,010 --> 00:03:28,470
negative 1 so if message level is less

00:03:26,910 --> 00:03:30,690
than 0 that means this is the first

00:03:28,470 --> 00:03:33,180
iteration of this loop where we check

00:03:30,690 --> 00:03:35,670
message run or message level and we

00:03:33,180 --> 00:03:37,290
check to see for this is this thing that

00:03:35,670 --> 00:03:39,420
just was passed to print K start with a

00:03:37,290 --> 00:03:41,730
lesson sign followed by with some number

00:03:39,420 --> 00:03:43,590
between 0 and 7 followed by a greater

00:03:41,730 --> 00:03:47,610
than sign if it that's false we do this

00:03:43,590 --> 00:03:49,500
deep we say we create in that minus 3

00:03:47,610 --> 00:03:51,840
which is why we have the plus 3 we now

00:03:49,500 --> 00:03:54,330
do a minus 3 and we write in the lesson

00:03:51,840 --> 00:03:57,060
sign default message log level minus 1

00:03:54,330 --> 00:03:58,890
plus you know : 0 to get an actual

00:03:57,060 --> 00:04:01,710
number in there and put a greater than

00:03:58,890 --> 00:04:04,860
sign otherwise we just have the message

00:04:01,710 --> 00:04:08,100
jump over the the 3 characters that has

00:04:04,860 --> 00:04:11,700
that message level and then we say ok

00:04:08,100 --> 00:04:17,070
now P will now equal P 1 equals some

00:04:11,700 --> 00:04:18,299
number from 0 to 7 so we save that in

00:04:17,070 --> 00:04:21,570
our message level so when the loop comes

00:04:18,299 --> 00:04:23,250
around we know what to do this is the

00:04:21,570 --> 00:04:25,200
second half of print K it's not that big

00:04:23,250 --> 00:04:27,540
of a function I mean I have the full

00:04:25,200 --> 00:04:30,150
print K function from version 1.0 and

00:04:27,540 --> 00:04:32,790
- slides again we're going to start

00:04:30,150 --> 00:04:36,660
where pwill left off and go to the end

00:04:32,790 --> 00:04:39,270
and then we would look at the with this

00:04:36,660 --> 00:04:41,130
little thing does is the ring buffer log

00:04:39,270 --> 00:04:44,460
buff is the the ring buffer within the

00:04:41,130 --> 00:04:47,760
kernel in 1.0 and we did the old you

00:04:44,460 --> 00:04:50,090
know add the start plus the size and and

00:04:47,760 --> 00:04:53,880
it to a mask which has to be of course

00:04:50,090 --> 00:04:55,710
power of two and we when we copy

00:04:53,880 --> 00:04:57,870
whatever P is pointing to into that and

00:04:55,710 --> 00:05:00,090
we keep looping around here's a little

00:04:57,870 --> 00:05:01,080
luggage logic that does those normal

00:05:00,090 --> 00:05:03,030
ring buffers that you learned in school

00:05:01,080 --> 00:05:05,910
how to do if you have a fixed size array

00:05:03,030 --> 00:05:08,430
and you want to spin around you do the

00:05:05,910 --> 00:05:11,670
increments of the point of start pointer

00:05:08,430 --> 00:05:12,750
in the size and now if we hit a new line

00:05:11,670 --> 00:05:14,670
we're going to break out of this loop

00:05:12,750 --> 00:05:17,610
because our message is done we only do

00:05:14,670 --> 00:05:19,680
one message per line now here's that

00:05:17,610 --> 00:05:22,370
wire that message level came from we

00:05:19,680 --> 00:05:24,630
look at the message level we look at the

00:05:22,370 --> 00:05:28,500
console log level which is something

00:05:24,630 --> 00:05:30,780
that the user space has given us saying

00:05:28,500 --> 00:05:32,610
this is how much we want to print and

00:05:30,780 --> 00:05:34,860
I'll talk about this later and if it's

00:05:32,610 --> 00:05:37,170
less than this user space number and

00:05:34,860 --> 00:05:39,300
there's actually a print function that

00:05:37,170 --> 00:05:41,610
will do something with this yes those

00:05:39,300 --> 00:05:44,730
two have to be true then we're going to

00:05:41,610 --> 00:05:48,540
go ahead and call this code the temp

00:05:44,730 --> 00:05:51,630
records whatever is after that slash and

00:05:48,540 --> 00:05:53,070
or if it's zero so works you know the

00:05:51,630 --> 00:05:54,180
log puffs we're expecting the buffer

00:05:53,070 --> 00:05:55,620
here there might actually be off by one

00:05:54,180 --> 00:05:59,520
bug here I'm not I didn't really look

00:05:55,620 --> 00:06:01,380
into it but it's expects that we're at

00:05:59,520 --> 00:06:03,990
the end of our string and when I look at

00:06:01,380 --> 00:06:09,270
the one plus of had one character

00:06:03,990 --> 00:06:11,070
forward and if that character or what

00:06:09,270 --> 00:06:12,630
what's called we're gonna save that

00:06:11,070 --> 00:06:14,280
character because we put in a null

00:06:12,630 --> 00:06:16,290
terminating character so we could call

00:06:14,280 --> 00:06:18,150
this console print function that

00:06:16,290 --> 00:06:20,460
hopefully exists no it does exist now

00:06:18,150 --> 00:06:22,230
it's not null and we'll pass the message

00:06:20,460 --> 00:06:23,760
to it and the message will end with the

00:06:22,230 --> 00:06:27,240
novel's character so it prints properly

00:06:23,760 --> 00:06:28,860
and now here and then we put it back the

00:06:27,240 --> 00:06:31,620
character that we swapped out with the

00:06:28,860 --> 00:06:34,470
null character now at this point here we

00:06:31,620 --> 00:06:36,480
check to see if slash end because if it

00:06:34,470 --> 00:06:39,060
is a slash end we know we broke out of

00:06:36,480 --> 00:06:40,410
the loop without hitting an end of line

00:06:39,060 --> 00:06:41,280
we actually broke out because of slash

00:06:40,410 --> 00:06:42,630
which means there

00:06:41,280 --> 00:06:45,360
probably there might be another message

00:06:42,630 --> 00:06:47,360
behind it so we set message level back

00:06:45,360 --> 00:06:49,650
to negative one and repeat the process

00:06:47,360 --> 00:06:52,320
after that loop finally done we're done

00:06:49,650 --> 00:06:56,730
with all our messages we do this wake up

00:06:52,320 --> 00:06:58,320
of a task that's a log wait so prank K

00:06:56,730 --> 00:07:01,139
basically does everything but from there

00:06:58,320 --> 00:07:05,070
that's done is somewhat the same of what

00:07:01,139 --> 00:07:07,500
we do today it has log levels it has a

00:07:05,070 --> 00:07:10,500
fixed size ring buffer it sends to some

00:07:07,500 --> 00:07:12,360
console and it wakes up some user space

00:07:10,500 --> 00:07:15,510
tasks if it's waiting on information

00:07:12,360 --> 00:07:18,510
that the colonel wants to print the log

00:07:15,510 --> 00:07:21,870
levels which were from back then today

00:07:18,510 --> 00:07:24,240
today they're still from 0 to 7 the

00:07:21,870 --> 00:07:27,510
lower the number the more likely it will

00:07:24,240 --> 00:07:30,750
print in fact current emerge will always

00:07:27,510 --> 00:07:32,700
print that's we there's code to make

00:07:30,750 --> 00:07:35,280
sure that the log level is never less

00:07:32,700 --> 00:07:39,060
than 1 so the lowest log level you could

00:07:35,280 --> 00:07:41,250
put is 1 so it goes from 1 to 8 if you

00:07:39,060 --> 00:07:43,350
put an 8 that means print everything if

00:07:41,250 --> 00:07:47,400
you put in 1 it means just print when

00:07:43,350 --> 00:07:49,020
the system basically crashes so you can

00:07:47,400 --> 00:07:52,200
set this variable number on the kernel

00:07:49,020 --> 00:07:56,130
command line and there's also what's

00:07:52,200 --> 00:07:58,490
called the curl command line or sysctl I

00:07:56,130 --> 00:08:00,810
believe or proc file system somewhere

00:07:58,490 --> 00:08:02,070
log levels are usually when in the

00:08:00,810 --> 00:08:03,780
kernel if you look at the kernel you'll

00:08:02,070 --> 00:08:06,539
see something like print case like

00:08:03,780 --> 00:08:08,820
parentheses current warning followed by

00:08:06,539 --> 00:08:10,680
some sort of string and that current

00:08:08,820 --> 00:08:14,310
warning isn't defined if a like right

00:08:10,680 --> 00:08:17,610
there would be : for if you were to

00:08:14,310 --> 00:08:19,320
compile or run this preprocessor on your

00:08:17,610 --> 00:08:21,150
code but when you put in print K with

00:08:19,320 --> 00:08:22,890
the current warning on it it would the

00:08:21,150 --> 00:08:24,360
old way which show you with the lesson

00:08:22,890 --> 00:08:27,660
sign the nor for the greater than sign

00:08:24,360 --> 00:08:31,520
followed by some string which is why you

00:08:27,660 --> 00:08:33,510
saw that weird strange code in print K

00:08:31,520 --> 00:08:37,070
you don't have to put that in there

00:08:33,510 --> 00:08:38,969
remember back in the print K back here

00:08:37,070 --> 00:08:41,219
maybe I should have gone back there but

00:08:38,969 --> 00:08:42,839
let me see here you'll see that it adds

00:08:41,219 --> 00:08:45,030
that default log message so if you leave

00:08:42,839 --> 00:08:48,020
it off that default message will be your

00:08:45,030 --> 00:08:52,080
log level that you have at that time

00:08:48,020 --> 00:08:54,030
told you have a lot of slides the new

00:08:52,080 --> 00:08:55,110
way is they don't do the lesson sign

00:08:54,030 --> 00:08:58,320
they use one character

00:08:55,110 --> 00:09:00,660
which is nice it's just you know hex

00:08:58,320 --> 00:09:03,180
character one so it's not printable so

00:09:00,660 --> 00:09:05,160
it could now get to define by a single

00:09:03,180 --> 00:09:06,630
compare to check to say hey this has a

00:09:05,160 --> 00:09:10,140
log level if it's not there it's a

00:09:06,630 --> 00:09:13,950
message so the the ring buffer in the

00:09:10,140 --> 00:09:15,300
print keg it's a fixed size you could

00:09:13,950 --> 00:09:18,020
change the size on boot up with the

00:09:15,300 --> 00:09:20,700
kernel command line with log both length

00:09:18,020 --> 00:09:23,100
it's been recently changed not recently

00:09:20,700 --> 00:09:25,470
but it's been changed since one Oh from

00:09:23,100 --> 00:09:28,380
that simple ring buffer thing to a more

00:09:25,470 --> 00:09:31,830
complex actually passing in binary

00:09:28,380 --> 00:09:33,570
messages and such and now they contain

00:09:31,830 --> 00:09:36,330
us timestamp the log the log level is

00:09:33,570 --> 00:09:38,640
actually stored as a binary thing inside

00:09:36,330 --> 00:09:40,410
the the print gate ring buffer today

00:09:38,640 --> 00:09:42,030
them as a message it has some metadata

00:09:40,410 --> 00:09:43,410
they can add to it and then the data

00:09:42,030 --> 00:09:47,450
string that you want to attach to it

00:09:43,410 --> 00:09:50,700
today it's protected by spin locks so

00:09:47,450 --> 00:09:52,920
you can't call it from nmi what you do

00:09:50,700 --> 00:09:54,690
we do we can and where we have code

00:09:52,920 --> 00:09:58,500
coming up which we'll probably talk to

00:09:54,690 --> 00:10:00,750
in the next talk explain that by the way

00:09:58,500 --> 00:10:04,230
this is a two-part talk for some reason

00:10:00,750 --> 00:10:07,620
I submitted this talk to LC /

00:10:04,230 --> 00:10:09,060
OSS and they accepted it twice and then

00:10:07,620 --> 00:10:10,710
he said could you make it twice as thing

00:10:09,060 --> 00:10:12,810
but thank God Serkis came here he saw

00:10:10,710 --> 00:10:15,330
through the second half on this on

00:10:12,810 --> 00:10:16,650
Wednesday which will be after kernel

00:10:15,330 --> 00:10:18,990
summit tomorrow that where we're

00:10:16,650 --> 00:10:22,340
discussing the problems with print K and

00:10:18,990 --> 00:10:22,340
hopefully solve come up with a solution

00:10:24,260 --> 00:10:29,100
of course print K is useless if it

00:10:27,510 --> 00:10:31,140
doesn't go anywhere if you're writing it

00:10:29,100 --> 00:10:32,280
to a memory log buffer it's kind of

00:10:31,140 --> 00:10:33,720
useless sitting there unless you have

00:10:32,280 --> 00:10:36,930
kids that ka dump where you could go and

00:10:33,720 --> 00:10:39,810
retrieve it which K exact k dump you can

00:10:36,930 --> 00:10:41,670
do that with with the utility crash but

00:10:39,810 --> 00:10:42,960
most likely you want to see this as it's

00:10:41,670 --> 00:10:44,250
going on so it's got to go someplace

00:10:42,960 --> 00:10:45,900
this guy go to the monitor it's got to

00:10:44,250 --> 00:10:48,120
go to frame Bob or frame buffers could

00:10:45,900 --> 00:10:49,710
go to the suit serial port network

00:10:48,120 --> 00:10:54,570
console there's even a Braille console

00:10:49,710 --> 00:10:58,140
that you could get print came from in

00:10:54,570 --> 00:10:59,760
today's logic print K uses two different

00:10:58,140 --> 00:11:00,780
things uses a spin lock and a console

00:10:59,760 --> 00:11:03,210
lock and I'm going to talk about that a

00:11:00,780 --> 00:11:05,730
little bit later and another problem

00:11:03,210 --> 00:11:07,320
with print K with enemies at least is

00:11:05,730 --> 00:11:09,100
the counsels themselves good as bin

00:11:07,320 --> 00:11:13,270
locks that you have to watch out for

00:11:09,100 --> 00:11:13,960
worried about when a task wakes up which

00:11:13,270 --> 00:11:16,750
does today

00:11:13,960 --> 00:11:18,880
we usually wake up syslog D or some

00:11:16,750 --> 00:11:23,200
other utility that might be on most

00:11:18,880 --> 00:11:25,090
machines today and that what some

00:11:23,200 --> 00:11:26,500
usually when you have these kernel

00:11:25,090 --> 00:11:27,460
messages going out you want to put them

00:11:26,500 --> 00:11:29,050
someplace you want to put them some

00:11:27,460 --> 00:11:30,190
place where users could see him and

00:11:29,050 --> 00:11:31,540
don't have to actually use D message

00:11:30,190 --> 00:11:32,710
because D message is a fixed size ring

00:11:31,540 --> 00:11:35,170
buffer if you get too much information

00:11:32,710 --> 00:11:38,550
in it it blows it away so you want to

00:11:35,170 --> 00:11:38,550
record it while it's still available

00:11:39,420 --> 00:11:47,110
then multiprocessors happen so back in

00:11:44,290 --> 00:11:48,040
January as I did this whole get watch it

00:11:47,110 --> 00:11:49,930
was never get by sight because was

00:11:48,040 --> 00:11:52,240
before it get so I actually just kept

00:11:49,930 --> 00:11:53,860
downloading stable or not stable there I

00:11:52,240 --> 00:11:56,050
guess this is before stable existed but

00:11:53,860 --> 00:11:58,180
I downloaded a bunch of development

00:11:56,050 --> 00:12:00,280
trees and I did a bisect download

00:11:58,180 --> 00:12:02,800
finding where was the first time

00:12:00,280 --> 00:12:05,530
spinlock appeared in print k and i found

00:12:02,800 --> 00:12:07,480
it was in 1980 1998 and to 180 a

00:12:05,530 --> 00:12:08,620
spinlock was introduced to print k

00:12:07,480 --> 00:12:10,360
that's the first time I was actually be

00:12:08,620 --> 00:12:13,030
able to run on a multiprocessor system

00:12:10,360 --> 00:12:14,950
and all print K's were serialized it did

00:12:13,030 --> 00:12:16,570
a spin lock in the beginning did all the

00:12:14,950 --> 00:12:18,040
prints wrote to the council's everything

00:12:16,570 --> 00:12:20,830
else and then finally released that

00:12:18,040 --> 00:12:21,400
print came but that doesn't scale it has

00:12:20,830 --> 00:12:23,710
issues

00:12:21,400 --> 00:12:25,090
and remember print K could be very slow

00:12:23,710 --> 00:12:26,410
especially going over serial port and

00:12:25,090 --> 00:12:30,310
back then you know that everything was

00:12:26,410 --> 00:12:34,570
you know 115200 ball huge edge if you

00:12:30,310 --> 00:12:37,750
had 96 fog you know 9600 baud modem it

00:12:34,570 --> 00:12:39,130
really was slow so when you have a print

00:12:37,750 --> 00:12:40,450
k if you had three print k's that went

00:12:39,130 --> 00:12:42,430
off at the same time and the first one

00:12:40,450 --> 00:12:44,740
got got the got the print k lock and it

00:12:42,430 --> 00:12:46,420
did its printing and the second one's

00:12:44,740 --> 00:12:48,430
blocked has got to wait until the first

00:12:46,420 --> 00:12:49,840
one's done printing the third one I came

00:12:48,430 --> 00:12:51,430
off not only does that's wait for the

00:12:49,840 --> 00:12:53,200
first one it has to wait for the second

00:12:51,430 --> 00:12:54,310
one wait to the third one and this could

00:12:53,200 --> 00:12:55,630
get bigger and bigger and bigger

00:12:54,310 --> 00:12:57,460
depending on how many CPUs you have

00:12:55,630 --> 00:13:00,040
which shows you why this doesn't scale

00:12:57,460 --> 00:13:03,460
and it basically while this happens so

00:13:00,040 --> 00:13:05,290
if you had eight CPUs doing like a print

00:13:03,460 --> 00:13:07,780
k that the print cake could take easily

00:13:05,290 --> 00:13:09,520
10 milliseconds if it's a slow modem

00:13:07,780 --> 00:13:11,590
person like that but right there can you

00:13:09,520 --> 00:13:13,330
imagine your system with 10 CPUs to all

00:13:11,590 --> 00:13:14,800
eight times time you know it gets up

00:13:13,330 --> 00:13:17,740
there pretty fast and it's well it's

00:13:14,800 --> 00:13:20,200
linear' up there but it could the system

00:13:17,740 --> 00:13:21,490
stops the whole system is locked up and

00:13:20,200 --> 00:13:22,630
that caused that people don't really

00:13:21,490 --> 00:13:24,910
like it when

00:13:22,630 --> 00:13:26,890
you're in the middle of playing some

00:13:24,910 --> 00:13:28,120
sort of video online video gaming or

00:13:26,890 --> 00:13:28,960
just about to you know quake or whatever

00:13:28,120 --> 00:13:31,180
you just want to shoot the guy in your

00:13:28,960 --> 00:13:36,700
system locks up because everything's had

00:13:31,180 --> 00:13:39,760
to print and you get killed so the

00:13:36,700 --> 00:13:45,040
council lock semaphore was introduced in

00:13:39,760 --> 00:13:46,390
2001 and to 410 it was added and it - we

00:13:45,040 --> 00:13:50,950
have two locks now we have a log buff

00:13:46,390 --> 00:13:54,040
lock the the lock that protects that law

00:13:50,950 --> 00:13:55,390
in memory ring buffer is a spin lock a

00:13:54,040 --> 00:13:56,200
normal spin lock nothing different

00:13:55,390 --> 00:13:57,550
nothing special

00:13:56,200 --> 00:13:58,720
you grab the spin lock you write to the

00:13:57,550 --> 00:14:01,200
log buffer you really suspend lock

00:13:58,720 --> 00:14:05,310
everything's fine the council lock is

00:14:01,200 --> 00:14:05,310
just strange

00:14:05,880 --> 00:14:09,820
the first holder of the console lock

00:14:08,200 --> 00:14:13,090
does the printing everyone else does

00:14:09,820 --> 00:14:14,470
this okay thank you good bye and this

00:14:13,090 --> 00:14:18,070
guy who has the council lock Boop do the

00:14:14,470 --> 00:14:20,350
printing for everyone so when you look

00:14:18,070 --> 00:14:22,060
at the the council lock isn't the big

00:14:20,350 --> 00:14:25,750
deal you can easily get the console.log

00:14:22,060 --> 00:14:26,980
the magic is in the council unlock so

00:14:25,750 --> 00:14:28,540
when you look into print k if you go

00:14:26,980 --> 00:14:30,070
into today and you look at print k and

00:14:28,540 --> 00:14:31,420
you look at you find council like you'll

00:14:30,070 --> 00:14:33,730
see this thing you'll see this if

00:14:31,420 --> 00:14:38,230
statement right there where he says if

00:14:33,730 --> 00:14:39,010
council try lock the council unlock you

00:14:38,230 --> 00:14:40,750
know if you look at that you're like

00:14:39,010 --> 00:14:42,970
wait a minute why what are you

00:14:40,750 --> 00:14:45,750
protecting what is the purpose of that

00:14:42,970 --> 00:14:47,730
that's because council unlock is a

00:14:45,750 --> 00:14:51,550
behemoth

00:14:47,730 --> 00:14:53,020
this is council unlock the code with a

00:14:51,550 --> 00:14:55,000
lot removed from everywhere I stripped

00:14:53,020 --> 00:14:56,680
out all comets stripped out a bunch of

00:14:55,000 --> 00:14:58,180
stuff and in fact in that for loop I

00:14:56,680 --> 00:15:00,910
condensed it down to nothing I guess

00:14:58,180 --> 00:15:02,440
there's a lot of work in there too

00:15:00,910 --> 00:15:04,090
when you do council and lock first thing

00:15:02,440 --> 00:15:06,400
to do is is the council suspended if so

00:15:04,090 --> 00:15:10,900
release the semaphore and return do

00:15:06,400 --> 00:15:13,240
nothing else you're done then we say can

00:15:10,900 --> 00:15:15,670
the council scheduler schedule like are

00:15:13,240 --> 00:15:17,920
we in a preemptable state if we are then

00:15:15,670 --> 00:15:19,390
we might be able to we could do a we

00:15:17,920 --> 00:15:21,880
check to see if something else wants to

00:15:19,390 --> 00:15:24,550
run on our CPU so while we're printing

00:15:21,880 --> 00:15:26,170
these messages we'll check every so

00:15:24,550 --> 00:15:29,560
often oh we should schedule out and let

00:15:26,170 --> 00:15:31,860
someone else run while we're holding the

00:15:29,560 --> 00:15:31,860
council

00:15:34,740 --> 00:15:41,350
which is interesting after this

00:15:36,760 --> 00:15:42,640
so thanks we also want to see if we can

00:15:41,350 --> 00:15:44,890
use the console because consoles K this

00:15:42,640 --> 00:15:48,190
consoles can be turned off so then we

00:15:44,890 --> 00:15:50,050
have to unlock we do this for loop that

00:15:48,190 --> 00:15:51,670
go iterates through all the registered

00:15:50,050 --> 00:15:54,220
consoles so you could have multiple

00:15:51,670 --> 00:15:55,750
consoles you can have your video console

00:15:54,220 --> 00:15:58,600
you have a you are you can have special

00:15:55,750 --> 00:15:59,980
devices each one this is a little a for

00:15:58,600 --> 00:16:01,750
loop that goes through each one of these

00:15:59,980 --> 00:16:03,130
everything you registered that you put

00:16:01,750 --> 00:16:05,050
on the kernel command line console

00:16:03,130 --> 00:16:07,060
equals blah blah blah but you do that

00:16:05,050 --> 00:16:08,620
multiple times and it's my goes iterate

00:16:07,060 --> 00:16:10,779
through each one of those writing the

00:16:08,620 --> 00:16:11,950
data out to each one one at a time each

00:16:10,779 --> 00:16:13,960
time checking to see if it could

00:16:11,950 --> 00:16:16,720
schedule if it was in a scheduled

00:16:13,960 --> 00:16:17,740
context if preemption was disabled nope

00:16:16,720 --> 00:16:21,040
it's not going to when we finished

00:16:17,740 --> 00:16:23,020
everything the council lock variable

00:16:21,040 --> 00:16:24,940
gets set when you get to lock and it's a

00:16:23,020 --> 00:16:27,100
way to tell the rest of the kernel I the

00:16:24,940 --> 00:16:28,480
council is locked because there's logic

00:16:27,100 --> 00:16:28,960
in there that says oh if the console is

00:16:28,480 --> 00:16:31,930
locked

00:16:28,960 --> 00:16:33,130
Oh warn or let's warn on this that's

00:16:31,930 --> 00:16:34,450
usually if you do a search for this

00:16:33,130 --> 00:16:36,400
you'll find it like in the frame buffer

00:16:34,450 --> 00:16:38,200
code and such which is another big mess

00:16:36,400 --> 00:16:40,380
that I'm going talk about that's that's

00:16:38,200 --> 00:16:43,390
a full story in itself

00:16:40,380 --> 00:16:48,459
this exclusive console was something I

00:16:43,390 --> 00:16:54,100
just discovered well today I'll talk

00:16:48,459 --> 00:16:55,959
about that later not finally you

00:16:54,100 --> 00:16:57,730
released though are you unlocked the log

00:16:55,959 --> 00:17:00,100
buff cuz we had the log buff held on for

00:16:57,730 --> 00:17:02,140
when we were doing the some work and

00:17:00,100 --> 00:17:05,319
then we council and then grab the log

00:17:02,140 --> 00:17:07,329
buff and then we check to see if this is

00:17:05,319 --> 00:17:12,429
this magic that says hey you know

00:17:07,329 --> 00:17:15,250
someone wrote code so cuz we could we do

00:17:12,429 --> 00:17:17,050
this retry which is look at the council

00:17:15,250 --> 00:17:19,510
sequence and see if there's something

00:17:17,050 --> 00:17:21,339
new there lot this and we do this after

00:17:19,510 --> 00:17:22,510
we release the council log and then if

00:17:21,339 --> 00:17:23,949
you notice below there are those two

00:17:22,510 --> 00:17:26,050
that other red thing is I say okay if

00:17:23,949 --> 00:17:27,280
retry is set we try to grab to the

00:17:26,050 --> 00:17:28,420
council lock if we fail to grab the

00:17:27,280 --> 00:17:31,240
council act we know someone else did and

00:17:28,420 --> 00:17:32,770
they'll do this work but no if we get

00:17:31,240 --> 00:17:34,600
that we're the lucky one that gets the

00:17:32,770 --> 00:17:36,160
console lock again that means that

00:17:34,600 --> 00:17:38,470
someone wrote more data and we go

00:17:36,160 --> 00:17:40,870
backing said oh you're the one so you

00:17:38,470 --> 00:17:42,520
fill it up and then eventually we're

00:17:40,870 --> 00:17:46,770
going to wake up whatever's waiting and

00:17:42,520 --> 00:17:49,050
to read the council data so today and

00:17:46,770 --> 00:17:54,720
of having the whole system locked up we

00:17:49,050 --> 00:17:58,290
just lock up one CPU and if you have say

00:17:54,720 --> 00:18:01,620
180 CPUs and you have a driver that just

00:17:58,290 --> 00:18:04,590
loves to tell everyone that hey I'm did

00:18:01,620 --> 00:18:06,180
a timer and said hey I'm alive I could

00:18:04,590 --> 00:18:08,970
keep alive something or there's some

00:18:06,180 --> 00:18:12,960
really drivers that seem to like to tell

00:18:08,970 --> 00:18:16,250
everyone something so it just it wants

00:18:12,960 --> 00:18:16,250
to be known it what to be loved

00:18:17,510 --> 00:18:24,140
hey my kids are Millennials so I could

00:18:22,350 --> 00:18:27,810
kind of agree with that

00:18:24,140 --> 00:18:28,170
No so you the first guy comes in just a

00:18:27,810 --> 00:18:30,060
right

00:18:28,170 --> 00:18:31,710
the lucky one that gets to council toe

00:18:30,060 --> 00:18:33,930
gets member with the right login that

00:18:31,710 --> 00:18:35,150
kind of turquoise ish whatever color

00:18:33,930 --> 00:18:37,770
around the way you want to call it

00:18:35,150 --> 00:18:39,150
that's where the log buff is held it's a

00:18:37,770 --> 00:18:40,440
spin lock so no one could do it the same

00:18:39,150 --> 00:18:42,390
time so it's only those are that's

00:18:40,440 --> 00:18:45,120
serialize that's fine but when you get

00:18:42,390 --> 00:18:47,640
the console Trilok you keep running and

00:18:45,120 --> 00:18:49,230
you print your stuff well on task 2 on

00:18:47,640 --> 00:18:52,410
another CPU comes in does a write log

00:18:49,230 --> 00:18:54,480
and so you're like oh we got more data I

00:18:52,410 --> 00:18:56,250
write this guy's out task 3 comes in to

00:18:54,480 --> 00:18:58,200
some more data Oh got more data we're

00:18:56,250 --> 00:18:59,550
right test 2 comes back oh I want to

00:18:58,200 --> 00:19:01,740
another print k so you see this could go

00:18:59,550 --> 00:19:05,460
back on and that print K latency is

00:19:01,740 --> 00:19:07,620
unbounded it could go forever and this

00:19:05,460 --> 00:19:09,450
could happen inside and interrupt this

00:19:07,620 --> 00:19:12,600
could happen with interrupts disables

00:19:09,450 --> 00:19:15,720
with a preemption disabled so your CPU

00:19:12,600 --> 00:19:17,760
is now hard locked live locked it's not

00:19:15,720 --> 00:19:19,740
a deadlock is a live lock it's running

00:19:17,760 --> 00:19:22,230
it's doing work but it's not doing

00:19:19,740 --> 00:19:26,040
anything else but being the servant for

00:19:22,230 --> 00:19:28,230
all the other CPUs and what happens is

00:19:26,040 --> 00:19:30,300
you can have a watchdog timer go off

00:19:28,230 --> 00:19:33,450
saying hey interrupts haven't gotten the

00:19:30,300 --> 00:19:36,090
CPU in like seconds this CPU is locked

00:19:33,450 --> 00:19:43,920
up hard to a panic what does panic do

00:19:36,090 --> 00:19:49,010
cause break going back to exclusive

00:19:43,920 --> 00:19:51,030
counsel there's added in March of 2011

00:19:49,010 --> 00:19:52,200
what happen when they found out which

00:19:51,030 --> 00:19:53,970
was kind of weird if you had on your

00:19:52,200 --> 00:19:57,360
kernel command line you know counsel we

00:19:53,970 --> 00:19:59,640
go TTY Wan console equals TTY mft2

00:19:57,360 --> 00:20:00,540
whatever that is counsel equals ttys

00:19:59,640 --> 00:20:03,150
zero

00:20:00,540 --> 00:20:07,230
early per K equals Mrs T they all are

00:20:03,150 --> 00:20:08,160
registering consoles and this is

00:20:07,230 --> 00:20:10,710
actually I copied this from the

00:20:08,160 --> 00:20:13,620
changelog that I found the code from get

00:20:10,710 --> 00:20:16,680
blame and each console when it registers

00:20:13,620 --> 00:20:18,450
it it will reap a resets when you

00:20:16,680 --> 00:20:21,150
register council it resets the start

00:20:18,450 --> 00:20:24,150
counts start of the of the buffer back

00:20:21,150 --> 00:20:25,920
to their beginning and calls the council

00:20:24,150 --> 00:20:28,080
lock and the car it calls the council

00:20:25,920 --> 00:20:31,350
unlock to print everything out for that

00:20:28,080 --> 00:20:32,850
council well what's happening was you

00:20:31,350 --> 00:20:34,860
know he registered register the first

00:20:32,850 --> 00:20:37,230
guy it would there's a bunch of stuff in

00:20:34,860 --> 00:20:39,960
the print k and it would print out

00:20:37,230 --> 00:20:42,630
everything for the tty one you register

00:20:39,960 --> 00:20:44,130
the next council it says Oh reset it I

00:20:42,630 --> 00:20:45,780
need to take this new council to print

00:20:44,130 --> 00:20:47,040
everything else out so it will print

00:20:45,780 --> 00:20:48,540
everything else out but since that

00:20:47,040 --> 00:20:50,460
remember that council loop that went

00:20:48,540 --> 00:20:51,930
through all the council's well TTY one

00:20:50,460 --> 00:20:54,180
would print out everything again and

00:20:51,930 --> 00:20:55,890
then the you get the second Council the

00:20:54,180 --> 00:20:59,240
third register comes in or the third

00:20:55,890 --> 00:21:01,170
your ttyl zero comes in and it says oh

00:20:59,240 --> 00:21:03,450
we have to register another one let's

00:21:01,170 --> 00:21:05,460
reset it and let's call TTY one again

00:21:03,450 --> 00:21:07,650
now I have no thing in Council three and

00:21:05,460 --> 00:21:09,660
then early print K would come in so dgy

00:21:07,650 --> 00:21:14,250
one just printed everything out four

00:21:09,660 --> 00:21:16,320
times so the solution was to make this

00:21:14,250 --> 00:21:17,640
exclusive council set so when you

00:21:16,320 --> 00:21:20,810
register to council you put down

00:21:17,640 --> 00:21:23,520
exclusive council and you say equal to

00:21:20,810 --> 00:21:26,490
the council you have so in that loop

00:21:23,520 --> 00:21:27,990
you're going through the coop exclusive

00:21:26,490 --> 00:21:29,580
cause when we do the prints it was in

00:21:27,990 --> 00:21:31,950
there I said if I'm not the exclusive

00:21:29,580 --> 00:21:37,170
council skipped me don't print me out we

00:21:31,950 --> 00:21:39,630
were going to be the one but in 2012 of

00:21:37,170 --> 00:21:43,080
May which isn't that much further away

00:21:39,630 --> 00:21:45,000
from when this was added the whole this

00:21:43,080 --> 00:21:48,720
is where we went from a ring buffer type

00:21:45,000 --> 00:21:51,240
of normal simple memory ring buffer to

00:21:48,720 --> 00:21:52,530
that message layout because journal D

00:21:51,240 --> 00:21:54,540
needed some more information why it

00:21:52,530 --> 00:21:55,980
needed more power on how to read from

00:21:54,540 --> 00:21:57,480
the kernel buffer so I needed more

00:21:55,980 --> 00:21:59,670
metadata need messages so it was

00:21:57,480 --> 00:22:01,140
rewritten and the code there did the

00:21:59,670 --> 00:22:04,770
commissioning of a council no longer

00:22:01,140 --> 00:22:05,850
reset everything back so this exclusive

00:22:04,770 --> 00:22:08,730
council which so when you register

00:22:05,850 --> 00:22:10,500
something there's a race here now so if

00:22:08,730 --> 00:22:12,780
you register something now and print

00:22:10,500 --> 00:22:14,429
kazar happening and then you jump into

00:22:12,780 --> 00:22:15,749
the pre-k unlock

00:22:14,429 --> 00:22:17,249
only the exclusive counsel the one that

00:22:15,749 --> 00:22:19,080
just was registered would print anything

00:22:17,249 --> 00:22:22,619
all the other councils will miss that

00:22:19,080 --> 00:22:25,230
print cake but I'm looking at it the

00:22:22,619 --> 00:22:28,619
code it's obsolete its shouldn't be

00:22:25,230 --> 00:22:31,139
there why is it still there because no

00:22:28,619 --> 00:22:32,399
one noticed it was obsolete until I did

00:22:31,139 --> 00:22:35,610
this presentation and was reviewing the

00:22:32,399 --> 00:22:38,610
slides so I know what throwaway what's

00:22:35,610 --> 00:22:40,740
this for Oh some people say that the

00:22:38,610 --> 00:22:41,879
best way to do or there's so many bugs

00:22:40,740 --> 00:22:47,639
have been fixing the kernel by

00:22:41,879 --> 00:22:51,360
presentations the scheduler this is a

00:22:47,639 --> 00:22:52,710
fun one too we want print K to work

00:22:51,360 --> 00:22:54,539
everywhere because you know that's our

00:22:52,710 --> 00:22:59,580
debug thing and of course when something

00:22:54,539 --> 00:23:01,320
goes wrong how do we know print k so in

00:22:59,580 --> 00:23:02,309
the scheduler a lot could go wrong if

00:23:01,320 --> 00:23:04,139
you ever seen that code it's quite

00:23:02,309 --> 00:23:05,519
complex there's a lot of checks and to

00:23:04,139 --> 00:23:06,539
make sure things are going as we think

00:23:05,519 --> 00:23:09,749
they are if there's something that's

00:23:06,539 --> 00:23:11,580
wrong or if you turn on debugging it

00:23:09,749 --> 00:23:13,019
will check stuff and if you have

00:23:11,580 --> 00:23:14,669
something that gets scheduled you're

00:23:13,019 --> 00:23:17,309
scheduling with an atomic it'll print

00:23:14,669 --> 00:23:21,029
something but print K holds a run queue

00:23:17,309 --> 00:23:23,279
lock and the rent queue lock is the is

00:23:21,029 --> 00:23:26,879
the lock that prevents any scheduling to

00:23:23,279 --> 00:23:28,139
happen on that CPU and obviously it

00:23:26,879 --> 00:23:30,090
needs to do that because spring the

00:23:28,139 --> 00:23:31,740
scheduler needs to look at tasks and

00:23:30,090 --> 00:23:33,419
doesn't want people to add new tasks for

00:23:31,740 --> 00:23:35,820
the CPU when it determines what tasks to

00:23:33,419 --> 00:23:38,999
run next so the run queue lock is very

00:23:35,820 --> 00:23:41,340
important it's also to protect like said

00:23:38,999 --> 00:23:44,850
you don't want to add new tasks to those

00:23:41,340 --> 00:23:49,080
scheduler if you're about to do the

00:23:44,850 --> 00:23:52,769
schedule so you can't do a wake up the

00:23:49,080 --> 00:23:54,990
problem is council unlock remember it's

00:23:52,769 --> 00:23:57,840
a semaphore if there's something waiting

00:23:54,990 --> 00:23:58,980
on that council lock to say ok I'm

00:23:57,840 --> 00:24:00,659
waiting for you because it's not just

00:23:58,980 --> 00:24:03,419
print K that uses council lock there's

00:24:00,659 --> 00:24:06,539
other things the guy reading that wants

00:24:03,419 --> 00:24:08,820
to read the the log or the D message

00:24:06,539 --> 00:24:11,879
that blocks on council lock so I could

00:24:08,820 --> 00:24:13,619
get information as well and there's lots

00:24:11,879 --> 00:24:16,049
of things I could do council there uses

00:24:13,619 --> 00:24:17,610
council walking block so when you do

00:24:16,049 --> 00:24:19,769
with a print k2 council unlock and you

00:24:17,610 --> 00:24:22,169
release the semaphore you do a wake up

00:24:19,769 --> 00:24:25,919
and right here you know you do your

00:24:22,169 --> 00:24:27,840
scheduler you have your you do some sort

00:24:25,919 --> 00:24:29,730
of spin lock on the run keel

00:24:27,840 --> 00:24:31,710
you do something you call prank a franc

00:24:29,730 --> 00:24:33,330
aise might do council unlock which way

00:24:31,710 --> 00:24:35,669
cups where does the release of the

00:24:33,330 --> 00:24:37,020
semaphore which wakes a process which

00:24:35,669 --> 00:24:39,059
grabs your run which if that process

00:24:37,020 --> 00:24:44,400
happens to be on the same CPU it grabs

00:24:39,059 --> 00:24:46,140
the run key lock boom deadlock so to

00:24:44,400 --> 00:24:48,150
handle this case this is in the kernel

00:24:46,140 --> 00:24:51,630
this is there today we have something

00:24:48,150 --> 00:24:55,470
called print case get which is now

00:24:51,630 --> 00:24:57,960
called print K deferred it was

00:24:55,470 --> 00:25:02,039
originally had its own CPU buffers that

00:24:57,960 --> 00:25:03,630
was just kind of the CPU buffers would

00:25:02,039 --> 00:25:05,789
it would write the stuff into the CPU

00:25:03,630 --> 00:25:07,350
buffers and then later on it would wake

00:25:05,789 --> 00:25:08,720
up and read these CPU buffers and then

00:25:07,350 --> 00:25:10,950
do the actual print case on them I

00:25:08,720 --> 00:25:12,210
notice I said this is kind of a waste to

00:25:10,950 --> 00:25:13,440
have these extra buffers in there

00:25:12,210 --> 00:25:16,260
because I noticed that I said you know

00:25:13,440 --> 00:25:18,179
the actual buffer the buffer to the

00:25:16,260 --> 00:25:20,039
print K is just protected by normal spin

00:25:18,179 --> 00:25:22,919
locks not this magic council lock and

00:25:20,039 --> 00:25:24,510
the spin locks only protect that buffer

00:25:22,919 --> 00:25:27,179
and you don't call anything else when

00:25:24,510 --> 00:25:29,039
you hold these special spin locks so you

00:25:27,179 --> 00:25:30,630
can nest them inside a runt key lock I

00:25:29,039 --> 00:25:32,580
said you know instead of doing that

00:25:30,630 --> 00:25:34,890
prank K just just grab the normal vlog

00:25:32,580 --> 00:25:36,659
buff lock right to the print K log

00:25:34,890 --> 00:25:39,380
buffer and then release it and then

00:25:36,659 --> 00:25:41,490
later on make sure that gets flushed out

00:25:39,380 --> 00:25:43,350
well used to the flushing used to happen

00:25:41,490 --> 00:25:45,029
on the next jiffy tick so if you're you

00:25:43,350 --> 00:25:47,549
know if you're no hurt or your hurts is

00:25:45,029 --> 00:25:49,799
set to 100 so hundred times a second a

00:25:47,549 --> 00:25:51,779
tick goes off and doesn't work so the if

00:25:49,799 --> 00:25:53,490
something happens then print K you know

00:25:51,779 --> 00:25:55,289
you have yet hundred what's called

00:25:53,490 --> 00:25:56,580
microseconds later whoever is or 100

00:25:55,289 --> 00:25:58,620
abide by if it's ten Hertz or something

00:25:56,580 --> 00:26:02,010
over 10 10 milliseconds I think 10

00:25:58,620 --> 00:26:06,990
milliseconds later you would I think I

00:26:02,010 --> 00:26:09,419
just at 10,000 temps I paste it so if 10

00:26:06,990 --> 00:26:11,399
milliseconds later your print will

00:26:09,419 --> 00:26:12,600
happen so if something else happened and

00:26:11,399 --> 00:26:15,539
something crashes you won't get those

00:26:12,600 --> 00:26:17,669
prints in that 10 milliseconds so today

00:26:15,539 --> 00:26:19,110
we use irq work what IQ work does is it

00:26:17,669 --> 00:26:21,779
sets up a flag inside if the

00:26:19,110 --> 00:26:25,200
architecture support it x86 does you set

00:26:21,779 --> 00:26:27,960
off a flag and says okay well write to

00:26:25,200 --> 00:26:31,320
the buffer kick off irq work i or queue

00:26:27,960 --> 00:26:34,020
work will so will basically send an IP i

00:26:31,320 --> 00:26:36,270
to itself to your cpu so as soon as

00:26:34,020 --> 00:26:37,919
interrupts are enabled again it will

00:26:36,270 --> 00:26:40,169
take it the cpu will take into interrupt

00:26:37,919 --> 00:26:42,320
and then call the function that you sign

00:26:40,169 --> 00:26:44,460
in it will do the flushing

00:26:42,320 --> 00:26:46,260
but you still can't do the printing

00:26:44,460 --> 00:26:48,390
within the actual output to the

00:26:46,260 --> 00:26:51,720
council's within the run key lock that's

00:26:48,390 --> 00:26:53,880
today and wherever it was me and I'm

00:26:51,720 --> 00:26:56,450
eyes are another fun thing you know

00:26:53,880 --> 00:27:00,420
print cake it happened in an animai and

00:26:56,450 --> 00:27:04,800
used to be it was a crapshoot

00:27:00,420 --> 00:27:06,900
we had control a more L our sis

00:27:04,800 --> 00:27:10,140
controller starts this request key M or

00:27:06,900 --> 00:27:12,780
L I came here would what L since because

00:27:10,140 --> 00:27:17,220
L that's Emma's memory since request L

00:27:12,780 --> 00:27:20,760
so if you do echo L into /proc sISTAR Q

00:27:17,220 --> 00:27:23,370
- trigger it sends an IP I to all the

00:27:20,760 --> 00:27:25,650
CPUs or and all the CPUs will trigger a

00:27:23,370 --> 00:27:27,810
nm I go actually on your IP I it sends

00:27:25,650 --> 00:27:30,870
off a trigger to trigger nm is on every

00:27:27,810 --> 00:27:33,270
single CPU and what that does it will do

00:27:30,870 --> 00:27:34,980
a stack dump so basically if you find

00:27:33,270 --> 00:27:37,020
out your systems kind of like ok it's

00:27:34,980 --> 00:27:38,700
it's something's locked and 1 2 CPUs or

00:27:37,020 --> 00:27:40,800
you detect us in the kernel you could

00:27:38,700 --> 00:27:43,140
trigger a stack dump everywhere or you

00:27:40,800 --> 00:27:44,550
could do it from manually so you could

00:27:43,140 --> 00:27:45,690
manually say do it's like let me see

00:27:44,550 --> 00:27:46,980
where where everything is we're

00:27:45,690 --> 00:27:49,350
something spinning I don't know why it's

00:27:46,980 --> 00:27:51,090
spinning so much Collin nmi and it will

00:27:49,350 --> 00:27:52,500
it will send it mi to that CPU and

00:27:51,090 --> 00:27:54,330
animai non-maskable interrupt for those

00:27:52,500 --> 00:27:56,670
that don't know which means it will

00:27:54,330 --> 00:27:57,930
always trigger regardless of interrupts

00:27:56,670 --> 00:28:00,210
or enable they're disabled

00:27:57,930 --> 00:28:01,410
so when it calls to mi then mi will then

00:28:00,210 --> 00:28:04,740
do is stack dump and it shows you where

00:28:01,410 --> 00:28:09,960
everything is and it does that by prank

00:28:04,740 --> 00:28:11,730
a in the old days we we just were

00:28:09,960 --> 00:28:13,110
careful about doing that because you

00:28:11,730 --> 00:28:15,870
could just set it off and if the print K

00:28:13,110 --> 00:28:18,390
happened to happen during a print K or

00:28:15,870 --> 00:28:21,210
while the council lock was held you

00:28:18,390 --> 00:28:29,120
could crash the system actually I'm

00:28:21,210 --> 00:28:32,540
asking you if it's L it's on my slide so

00:28:29,120 --> 00:28:35,400
one of the solutions from 2 for 2 for 11

00:28:32,540 --> 00:28:39,600
was this awesome function called zap

00:28:35,400 --> 00:28:40,920
locks I think I believe we got rid of it

00:28:39,600 --> 00:28:45,720
which is sad because I just love the

00:28:40,920 --> 00:28:49,500
name it's it's this variable called oops

00:28:45,720 --> 00:28:54,150
in progress to 1 and it lets the system

00:28:49,500 --> 00:28:55,720
know I'm dying so don't worry about

00:28:54,150 --> 00:28:58,809
deadlocks don't worry

00:28:55,720 --> 00:29:01,770
about being consistent just get the

00:28:58,809 --> 00:29:06,460
information out why I'm dying

00:29:01,770 --> 00:29:09,940
so zap locks would kind of reinitialize

00:29:06,460 --> 00:29:12,010
the the buffer those spin locks although

00:29:09,940 --> 00:29:14,799
and reinitialize the council stem so if

00:29:12,010 --> 00:29:16,450
n mi goes off and says we're dying we're

00:29:14,799 --> 00:29:18,820
triggering something reinitialize

00:29:16,450 --> 00:29:22,120
anything so just in case I preempted the

00:29:18,820 --> 00:29:24,190
print K I'm later well whoever I

00:29:22,120 --> 00:29:26,409
preempted I might say no you don't own

00:29:24,190 --> 00:29:30,400
the lock anymore I'm gonna run and write

00:29:26,409 --> 00:29:33,039
everything out it's works great except

00:29:30,400 --> 00:29:35,049
it's not aware of the council locks so

00:29:33,039 --> 00:29:36,549
if it happened to happen during one of

00:29:35,049 --> 00:29:39,150
the council spin locks you're screwed

00:29:36,549 --> 00:29:44,679
anyway yeah crapshoot

00:29:39,150 --> 00:29:49,809
so to handle the the one situation where

00:29:44,679 --> 00:29:52,570
we use sis requests l I took a I took

00:29:49,809 --> 00:29:55,210
the seat buffer that's used by trace F

00:29:52,570 --> 00:29:58,870
trace and also use K like seek printing

00:29:55,210 --> 00:30:00,909
it's a way to pass a bunch of data from

00:29:58,870 --> 00:30:02,620
function to function like a string data

00:30:00,909 --> 00:30:04,030
so you could write to you could do like

00:30:02,620 --> 00:30:04,929
a printf or something and then pass it

00:30:04,030 --> 00:30:06,760
off to the next guy they could do a

00:30:04,929 --> 00:30:08,860
printf and you attach a lot of

00:30:06,760 --> 00:30:13,090
information like this I'll trace events

00:30:08,860 --> 00:30:15,070
work so I sign a know if I make this I

00:30:13,090 --> 00:30:19,390
could probably say Etta my stuff so if

00:30:15,070 --> 00:30:21,669
you do sis request L it will write I

00:30:19,390 --> 00:30:24,039
could I added a function pointer for

00:30:21,669 --> 00:30:26,140
print k to be able to switch per CPU so

00:30:24,039 --> 00:30:28,000
this when you did print K it didn't

00:30:26,140 --> 00:30:30,330
actually call the print K code it

00:30:28,000 --> 00:30:32,950
actually called a function a per CPU

00:30:30,330 --> 00:30:36,309
function pointer that would jump to the

00:30:32,950 --> 00:30:38,860
from K code now I was able to enter or

00:30:36,309 --> 00:30:39,760
set away when I went to nm I saying I'm

00:30:38,860 --> 00:30:41,830
doing a dump

00:30:39,760 --> 00:30:43,630
I'm always switch it to this other

00:30:41,830 --> 00:30:45,669
function that's not going to write to

00:30:43,630 --> 00:30:49,360
the council's but it's going right to

00:30:45,669 --> 00:30:50,830
the seek buffer and at the end when it's

00:30:49,360 --> 00:30:53,470
after all the seek buffers are done and

00:30:50,830 --> 00:30:55,600
when M eyes done is which is a per CPU

00:30:53,470 --> 00:30:59,140
pointer back to normal printf or print K

00:30:55,600 --> 00:31:01,179
and I have some other guy in a nice good

00:30:59,140 --> 00:31:03,610
context knowing that I can't preempt the

00:31:01,179 --> 00:31:06,370
console holder it will actually read all

00:31:03,610 --> 00:31:07,929
the end of my per CPU buffers and print

00:31:06,370 --> 00:31:10,220
it out nicely so there's no more

00:31:07,929 --> 00:31:12,780
deadlocks

00:31:10,220 --> 00:31:15,180
the way it worked was you do your sister

00:31:12,780 --> 00:31:17,760
Choiseul sends all the triggers animes

00:31:15,180 --> 00:31:19,680
runs to seek buff and there then I had

00:31:17,760 --> 00:31:23,690
like said save context for CPU so that's

00:31:19,680 --> 00:31:26,910
your visual of that simple

00:31:23,690 --> 00:31:28,950
well it doesn't solve normal enemy code

00:31:26,910 --> 00:31:30,240
because enemy code that determines oh

00:31:28,950 --> 00:31:32,520
we're about the crash or something like

00:31:30,240 --> 00:31:35,730
that we want that data out and we don't

00:31:32,520 --> 00:31:39,180
have the luxury of a safe context per se

00:31:35,730 --> 00:31:42,240
sort of so code is working on how to do

00:31:39,180 --> 00:31:45,630
that so if you have a panic or warned on

00:31:42,240 --> 00:31:51,600
or it's not you it's really still a

00:31:45,630 --> 00:31:54,210
crapshoot so in four seven and a my be

00:31:51,600 --> 00:31:55,830
print K was created and what happened

00:31:54,210 --> 00:31:58,110
was when you turned into or whenever you

00:31:55,830 --> 00:32:01,680
enter to enemy and there's functions

00:31:58,110 --> 00:32:03,420
whenever you enter a my there's a enemy

00:32:01,680 --> 00:32:05,790
enter code and there's my exit code it

00:32:03,420 --> 00:32:07,170
would call print KN Amaya so that am i

00:32:05,790 --> 00:32:08,610
entered would call print k and a my

00:32:07,170 --> 00:32:11,610
enter and then the end of my exit would

00:32:08,610 --> 00:32:13,200
call print k and my exit and what that

00:32:11,610 --> 00:32:15,540
would do would switch that function

00:32:13,200 --> 00:32:18,680
pointer to be this NM IV print cake

00:32:15,540 --> 00:32:19,970
which would do something different and

00:32:18,680 --> 00:32:23,460
[Music]

00:32:19,970 --> 00:32:26,310
then when the enemy happened it would

00:32:23,460 --> 00:32:28,080
write to the seek buff or a actually

00:32:26,310 --> 00:32:31,410
they now changed the buffer i used it

00:32:28,080 --> 00:32:34,020
the seek buffer wasn't they need a

00:32:31,410 --> 00:32:35,250
little bit more flexibility than what

00:32:34,020 --> 00:32:37,620
the seek buffer did so they added a

00:32:35,250 --> 00:32:39,180
little bit more lock or protection I

00:32:37,620 --> 00:32:41,730
guess atomic counters and stuff like

00:32:39,180 --> 00:32:44,960
that so changes but it's basically the

00:32:41,730 --> 00:32:48,960
same exact same design wear rights to a

00:32:44,960 --> 00:32:52,470
pre allocated buffer and at the end on

00:32:48,960 --> 00:32:54,690
the exit it switches it back and will

00:32:52,470 --> 00:32:56,730
then send it off through irq work so

00:32:54,690 --> 00:33:00,210
that when the enemy is done it will get

00:32:56,730 --> 00:33:02,370
to a safe safe state where the enemy

00:33:00,210 --> 00:33:06,210
will or the irq work will flush out all

00:33:02,370 --> 00:33:09,420
the enemies the problem is with this is

00:33:06,210 --> 00:33:12,060
if the system locks up hard you don't

00:33:09,420 --> 00:33:13,740
get your data out if nmi won't work I

00:33:12,060 --> 00:33:15,840
played with this a little bit and

00:33:13,740 --> 00:33:17,460
actually I found out was it would work

00:33:15,840 --> 00:33:21,400
mostly there's a case at least the

00:33:17,460 --> 00:33:24,100
latest stuff today will work

00:33:21,400 --> 00:33:26,740
if all see if there's one CPU still

00:33:24,100 --> 00:33:29,559
alive and it will that once if you could

00:33:26,740 --> 00:33:31,120
actually work but if all CPUs lock up or

00:33:29,559 --> 00:33:34,630
your any processor system you're screwed

00:33:31,120 --> 00:33:36,370
then someone noticed I think there's

00:33:34,630 --> 00:33:38,559
more Serkis work

00:33:36,370 --> 00:33:45,340
what about a print k within a print K

00:33:38,559 --> 00:33:47,290
which can happen remember we could do

00:33:45,340 --> 00:33:53,820
more neurons anywhere

00:33:47,290 --> 00:33:53,820
so yes was it

00:33:57,010 --> 00:34:07,590
was this wait Freudian slip

00:34:11,429 --> 00:34:20,950
reminds me of the drunken patch where I

00:34:16,120 --> 00:34:23,169
turn void to vid I'm changing a comment

00:34:20,950 --> 00:34:26,620
and Thomas collection was with me too

00:34:23,169 --> 00:34:27,760
and he acted and I sent out and I got

00:34:26,620 --> 00:34:31,230
all I did in the next day I got a

00:34:27,760 --> 00:34:31,230
message from Andrew Martin saying bah

00:34:31,440 --> 00:34:41,889
okay so what happens here on print K it

00:34:40,210 --> 00:34:46,330
does a console unlock does all your

00:34:41,889 --> 00:34:48,639
printing and then it wakes up a penny

00:34:46,330 --> 00:34:50,860
task but for say something happened

00:34:48,639 --> 00:34:53,050
where when it to the wake up we had some

00:34:50,860 --> 00:34:55,810
code wrong and that wake up caused a

00:34:53,050 --> 00:34:59,340
warning for some reason it would cause

00:34:55,810 --> 00:35:01,480
print k and would do a console Trilok

00:34:59,340 --> 00:35:04,480
remember we already upped the semaphore

00:35:01,480 --> 00:35:07,210
so it gets the lock because we only wake

00:35:04,480 --> 00:35:10,180
up after release the semaphore so we do

00:35:07,210 --> 00:35:12,700
that we get the lock and it doesn't rise

00:35:10,180 --> 00:35:16,900
lock but now it does the tries to get

00:35:12,700 --> 00:35:19,450
this wait oh sorry I have to go back let

00:35:16,900 --> 00:35:21,580
me change that when you unlock the

00:35:19,450 --> 00:35:24,070
semaphore the semaphore itself has a raw

00:35:21,580 --> 00:35:25,900
spin lock so it actually has a real spin

00:35:24,070 --> 00:35:27,610
lock so when you do the way it works is

00:35:25,900 --> 00:35:29,110
it does grabs a spin lock does the

00:35:27,610 --> 00:35:30,850
wakeup and then it releases the spin

00:35:29,110 --> 00:35:31,990
lock within the semaphore code that's

00:35:30,850 --> 00:35:34,630
why this is up you see the squealy

00:35:31,990 --> 00:35:37,210
bracket so you call the up so this we

00:35:34,630 --> 00:35:38,650
release the spit we released the the

00:35:37,210 --> 00:35:40,210
quote-unquote semaphore but now we're

00:35:38,650 --> 00:35:41,530
waking up with the next guy that's

00:35:40,210 --> 00:35:43,060
waiting on that set for us we have to

00:35:41,530 --> 00:35:44,620
wake up the waiter for the semaphore and

00:35:43,060 --> 00:35:46,330
then something happens or there's a

00:35:44,620 --> 00:35:47,830
print K lock but then it goes and grabs

00:35:46,330 --> 00:35:49,630
that semaphore lock again and now it

00:35:47,830 --> 00:35:52,170
locks dead lock so you can't actually

00:35:49,630 --> 00:35:55,230
deadlock with in print kay

00:35:52,170 --> 00:35:58,540
unfortunately lock Depp doesn't we

00:35:55,230 --> 00:36:02,680
locked up requires so validation and it

00:35:58,540 --> 00:36:04,060
could kind of detect this and I guess

00:36:02,680 --> 00:36:06,400
what happened was we kind of disabled

00:36:04,060 --> 00:36:07,330
lock dip validation within print k we're

00:36:06,400 --> 00:36:09,190
just like we understand there's a

00:36:07,330 --> 00:36:10,630
deadlock here but you know if you do

00:36:09,190 --> 00:36:10,870
this every time you to print cage locked

00:36:10,630 --> 00:36:12,550
up

00:36:10,870 --> 00:36:16,180
hey you could have a possible deadlock

00:36:12,550 --> 00:36:18,910
and it would just stop you're done

00:36:16,180 --> 00:36:20,410
checking lock DEP so the only way to get

00:36:18,910 --> 00:36:21,700
locked up to work is a turn off print

00:36:20,410 --> 00:36:22,660
kay but then if it detected something

00:36:21,700 --> 00:36:28,170
you'd never be able to know if it

00:36:22,660 --> 00:36:28,170
happened so that was a problem

00:36:29,010 --> 00:36:35,350
so print K has three different locks

00:36:32,890 --> 00:36:38,920
we have you're logged off lock console

00:36:35,350 --> 00:36:41,380
lock and console over lock and I said

00:36:38,920 --> 00:36:43,540
print K if it causes a deadlock it

00:36:41,380 --> 00:36:44,620
so if print K causes a deadlock because

00:36:43,540 --> 00:36:47,350
the console lock does something thing

00:36:44,620 --> 00:36:50,500
lock DEP also will print out a report

00:36:47,350 --> 00:36:52,740
and it uses a print k which will itself

00:36:50,500 --> 00:36:55,210
so block tip itself can now cause a

00:36:52,740 --> 00:36:58,450
deadlock itself which really would suck

00:36:55,210 --> 00:37:01,480
that your system would be running and

00:36:58,450 --> 00:37:03,760
would just die lock up and you're like

00:37:01,480 --> 00:37:05,920
you enable print K or locked up to

00:37:03,760 --> 00:37:07,780
figure out why it locked up and then

00:37:05,920 --> 00:37:09,580
print K itself caused the deadlock and

00:37:07,780 --> 00:37:11,500
then locked up trial or no print you the

00:37:09,580 --> 00:37:13,150
lock DEP would trip figure out that oh

00:37:11,500 --> 00:37:14,680
there's a deadlock here and it will

00:37:13,150 --> 00:37:16,840
print and then it would lock your system

00:37:14,680 --> 00:37:19,990
up without ever telling you what the

00:37:16,840 --> 00:37:21,480
problem was because it deadlocked before

00:37:19,990 --> 00:37:25,180
it could get the data

00:37:21,480 --> 00:37:26,470
so in 411 a new functionality came which

00:37:25,180 --> 00:37:31,360
was called print K safe which was

00:37:26,470 --> 00:37:34,300
similar to the enemy print K and this

00:37:31,360 --> 00:37:36,610
required to manually mark areas and

00:37:34,300 --> 00:37:38,920
within the print K code that can

00:37:36,610 --> 00:37:43,090
possibly recurse on itself and deadlock

00:37:38,920 --> 00:37:46,660
and it would use a counter to determine

00:37:43,090 --> 00:37:48,640
like unsafe region it would increment

00:37:46,660 --> 00:37:50,770
before going into an unsafe region and

00:37:48,640 --> 00:37:56,620
decrement when I leave the unsafe region

00:37:50,770 --> 00:37:59,020
and if if the value was greater than

00:37:56,620 --> 00:38:00,340
zero it would use a separate buffer it

00:37:59,020 --> 00:38:03,040
wouldn't or would do something different

00:38:00,340 --> 00:38:05,860
it would not do the normal print K it

00:38:03,040 --> 00:38:09,490
would not do the console lock because it

00:38:05,860 --> 00:38:12,490
says hey we're inside this what's a call

00:38:09,490 --> 00:38:14,980
if we go with in print K we'd say I'm

00:38:12,490 --> 00:38:22,650
talking my mind straight here the avoid

00:38:14,980 --> 00:38:22,650
totally threw me off so

00:38:23,000 --> 00:38:27,390
it would it just actually worked like

00:38:25,230 --> 00:38:28,410
nmi print Kok with inside the brink a

00:38:27,390 --> 00:38:33,810
let's just leave that that you can

00:38:28,410 --> 00:38:34,890
figure it out see that would make my so

00:38:33,810 --> 00:38:38,700
much shorter you just figure it out

00:38:34,890 --> 00:38:40,230
here's my slides goodbye so freaky was

00:38:38,700 --> 00:38:41,010
no longer a function pointer Maresa was

00:38:40,230 --> 00:38:42,930
a function where the switch back and

00:38:41,010 --> 00:38:45,720
forth but it turned it to a single

00:38:42,930 --> 00:38:47,430
function as a multiplexer it uses a

00:38:45,720 --> 00:38:49,710
person view of context where flags of a

00:38:47,430 --> 00:38:50,790
counter and what it that's what's used

00:38:49,710 --> 00:38:55,410
to determine what function should be

00:38:50,790 --> 00:39:03,240
used and we had to make sure to prevent

00:38:55,410 --> 00:39:04,650
this log buff thing so I guess I think

00:39:03,240 --> 00:39:06,210
it's done with anyway whenever you had

00:39:04,650 --> 00:39:07,230
to grab this log bus pin lock because

00:39:06,210 --> 00:39:08,430
that could cause when the deadlock see

00:39:07,230 --> 00:39:10,020
increment you had to use the print case

00:39:08,430 --> 00:39:12,090
safe and then decrement it outside the

00:39:10,020 --> 00:39:13,170
brink log buff lock this way that's

00:39:12,090 --> 00:39:16,100
right because he's needed do it for nm

00:39:13,170 --> 00:39:16,100
eyes as well

00:39:17,760 --> 00:39:22,530
and now the ni ikou we don't use the

00:39:20,280 --> 00:39:24,360
enema the the V print ami or the amide

00:39:22,530 --> 00:39:26,670
print K anymore this thing actually

00:39:24,360 --> 00:39:29,490
handles everything else so inside when

00:39:26,670 --> 00:39:31,350
enemy triggers we look at this print K

00:39:29,490 --> 00:39:36,750
context that has that increment variable

00:39:31,350 --> 00:39:40,160
and if we mask it against the counter

00:39:36,750 --> 00:39:43,830
and if it's set that means we're in a

00:39:40,160 --> 00:39:46,590
location where log buff can lock up so

00:39:43,830 --> 00:39:49,740
we checked is log buff locked if it is

00:39:46,590 --> 00:39:53,370
we're going to say hey let's go into

00:39:49,740 --> 00:39:54,690
this nmi context otherwise if via those

00:39:53,370 --> 00:39:57,090
cases are coming in we're going to into

00:39:54,690 --> 00:40:01,170
a nmi deferred context which goes back

00:39:57,090 --> 00:40:05,000
to the kind of the original way and when

00:40:01,170 --> 00:40:10,440
we exit we just clear out the flags so

00:40:05,000 --> 00:40:13,620
now when we do oh this is this is

00:40:10,440 --> 00:40:14,220
basically my English version of this of

00:40:13,620 --> 00:40:17,940
this code

00:40:14,220 --> 00:40:20,760
I forgot I did this so if print k safe

00:40:17,940 --> 00:40:22,710
is active if canto max mask is greater

00:40:20,760 --> 00:40:23,880
than zero then we're and log buff is

00:40:22,710 --> 00:40:27,090
lock then we're going to call the V

00:40:23,880 --> 00:40:31,560
print am I otherwise we call that VK

00:40:27,090 --> 00:40:33,630
print so the V print a function now is

00:40:31,560 --> 00:40:35,400
this is what all print K got cause so

00:40:33,630 --> 00:40:37,529
it's not I marry I said when you call

00:40:35,400 --> 00:40:38,880
prynt k pre-k now calls V print K

00:40:37,529 --> 00:40:40,490
directly it doesn't actually cause a

00:40:38,880 --> 00:40:43,950
function pointer it cause this

00:40:40,490 --> 00:40:46,680
multiplexer it checks the context and

00:40:43,950 --> 00:40:48,440
compares it to the enemy mask and if

00:40:46,680 --> 00:40:52,140
it's set well you want to do the enemy

00:40:48,440 --> 00:40:54,390
otherwise we if if that's not true we

00:40:52,140 --> 00:40:57,150
check to see if the we're in a nested

00:40:54,390 --> 00:40:59,760
local nested area position so we'll do

00:40:57,150 --> 00:41:02,069
the print case safe otherwise we're in a

00:40:59,760 --> 00:41:04,740
divert context we're going to print and

00:41:02,069 --> 00:41:06,390
print a deferred otherwise print K

00:41:04,740 --> 00:41:08,039
default which is what print K did

00:41:06,390 --> 00:41:15,319
basically all the way back to version

00:41:08,039 --> 00:41:17,940
1.0 well in the meantime like I said

00:41:15,319 --> 00:41:19,289
system D likes to write to print K this

00:41:17,940 --> 00:41:20,369
is kind of like all the issues that we

00:41:19,289 --> 00:41:23,640
have to deal with for print K so I

00:41:20,369 --> 00:41:26,400
wanted to bring this up so user space

00:41:23,640 --> 00:41:29,549
can write into that fixed size memory

00:41:26,400 --> 00:41:33,150
ring buffer it uses an interface of proc

00:41:29,549 --> 00:41:35,789
a message and unfortunately what happens

00:41:33,150 --> 00:41:37,319
is you could have a case where you if

00:41:35,789 --> 00:41:39,150
user space goes crazy or if there's a

00:41:37,319 --> 00:41:42,420
bug it just spits into the buffer and

00:41:39,150 --> 00:41:44,700
save it had a bug because there was a

00:41:42,420 --> 00:41:46,799
kernel bug the colonel bug could have

00:41:44,700 --> 00:41:48,869
done something did a print k something

00:41:46,799 --> 00:41:50,250
warned on then system decode it say oh

00:41:48,869 --> 00:41:51,869
something's not right and spend a bunch

00:41:50,250 --> 00:41:55,319
of debugging and there and you just lost

00:41:51,869 --> 00:41:59,789
the warrant on so this is one of the

00:41:55,319 --> 00:42:02,789
issues that we need to fix one thing

00:41:59,789 --> 00:42:06,450
that people love few developers really

00:42:02,789 --> 00:42:08,099
really love is early print cake now one

00:42:06,450 --> 00:42:10,589
of the questions that is given on I

00:42:08,099 --> 00:42:12,839
guess the links foundation teaching

00:42:10,589 --> 00:42:14,940
kernel development is like when does

00:42:12,839 --> 00:42:16,740
print K not work well it actually does

00:42:14,940 --> 00:42:17,910
work well and that's an early boot up

00:42:16,740 --> 00:42:19,890
before the council's are registered

00:42:17,910 --> 00:42:22,640
before there's any council there there's

00:42:19,890 --> 00:42:26,279
no print cake and if something dies

00:42:22,640 --> 00:42:27,779
during before councils of registers you

00:42:26,279 --> 00:42:30,420
just see a black screen on your machine

00:42:27,779 --> 00:42:33,420
when you boot it up where print K's are

00:42:30,420 --> 00:42:36,569
actually happening so we created early

00:42:33,420 --> 00:42:37,859
print K which actually writes to the log

00:42:36,569 --> 00:42:39,240
buffer or whatever but actually what

00:42:37,859 --> 00:42:40,859
early pre-k does is not only does it

00:42:39,240 --> 00:42:42,720
write to the log buffer it actually when

00:42:40,859 --> 00:42:44,549
you call print K it will write to

00:42:42,720 --> 00:42:46,920
wherever you said is my right to whether

00:42:44,549 --> 00:42:48,990
it's a serial VGA or whatever it will do

00:42:46,920 --> 00:42:50,520
the right at suit it doesn't care about

00:42:48,990 --> 00:42:53,369
the buffers it will write to the log

00:42:50,520 --> 00:42:54,750
buffer but will also write straight to

00:42:53,369 --> 00:42:57,570
the counsel as well without grabbing

00:42:54,750 --> 00:42:59,220
locks early print caves basically a

00:42:57,570 --> 00:43:00,930
little version of it's like a tight

00:42:59,220 --> 00:43:02,790
version says just write to the console

00:43:00,930 --> 00:43:04,590
if we blow everything if we if we mess

00:43:02,790 --> 00:43:06,450
up the buffers within the council where

00:43:04,590 --> 00:43:08,490
there's a serial port or whatever so bad

00:43:06,450 --> 00:43:10,920
to be we don't care we just want data

00:43:08,490 --> 00:43:15,600
going out when it happens force it no

00:43:10,920 --> 00:43:17,040
locks just write data the see reports

00:43:15,600 --> 00:43:19,170
rather easy to do because it's just a

00:43:17,040 --> 00:43:21,510
serial port where VGA buffers could be

00:43:19,170 --> 00:43:23,100
kind of a more of a more complex thing

00:43:21,510 --> 00:43:24,630
well usually serial is the one that you

00:43:23,100 --> 00:43:26,490
do because of just as a complexity of

00:43:24,630 --> 00:43:28,800
the output serial is really easy to

00:43:26,490 --> 00:43:30,600
write up but it's very slow which is a

00:43:28,800 --> 00:43:34,050
problem if everything you print your

00:43:30,600 --> 00:43:35,970
system stops until it prints out if you

00:43:34,050 --> 00:43:37,650
want early print K to exist after

00:43:35,970 --> 00:43:40,020
registered of councils because when the

00:43:37,650 --> 00:43:41,340
when councils are registered early pre-k

00:43:40,020 --> 00:43:42,720
will remove itself out because usually

00:43:41,340 --> 00:43:44,310
it was written just to be able to see

00:43:42,720 --> 00:43:45,840
the data before print K councils were

00:43:44,310 --> 00:43:47,940
there that's why it right straight out

00:43:45,840 --> 00:43:51,000
instead of going worrying about councils

00:43:47,940 --> 00:43:53,369
so if you want your early print K to

00:43:51,000 --> 00:43:54,810
still be there because print K is

00:43:53,369 --> 00:43:56,760
messing up for all these issues I've

00:43:54,810 --> 00:43:58,350
already talked about you put comma keep

00:43:56,760 --> 00:44:00,869
behind in your kernel command line and

00:43:58,350 --> 00:44:02,130
it will stay there right now one of the

00:44:00,869 --> 00:44:03,300
code that's being worked on I think we

00:44:02,130 --> 00:44:04,920
have patches there's lots of patches out

00:44:03,300 --> 00:44:06,930
already is force early break a to

00:44:04,920 --> 00:44:08,970
basically say don't bother with print k

00:44:06,930 --> 00:44:10,619
at all just call it early print K and

00:44:08,970 --> 00:44:12,630
actually 2000 sings print K goes in is

00:44:10,619 --> 00:44:16,560
just do that which might be part of the

00:44:12,630 --> 00:44:18,920
multiplexer unfortunately today is game

00:44:16,560 --> 00:44:21,540
much much more difficult to find a UART

00:44:18,920 --> 00:44:23,730
everyone here as a laptop anyone in this

00:44:21,540 --> 00:44:27,810
room that has your laptop has a serial

00:44:23,730 --> 00:44:28,859
interface not a single hand that's

00:44:27,810 --> 00:44:32,280
really sad

00:44:28,859 --> 00:44:34,650
this doesn't either it's really hard to

00:44:32,280 --> 00:44:37,109
debug your laptop if something crashes

00:44:34,650 --> 00:44:38,670
because or you this is where you do the

00:44:37,109 --> 00:44:40,619
camera take a picture of the last crash

00:44:38,670 --> 00:44:44,220
and you have to ok only see what you get

00:44:40,619 --> 00:44:46,590
which is a problem so we have to handle

00:44:44,220 --> 00:44:48,119
that all the methods we could do network

00:44:46,590 --> 00:44:49,619
console there's a delayed print k that's

00:44:48,119 --> 00:44:51,180
been there forever to where it will

00:44:49,619 --> 00:44:54,480
actually every print k will go out will

00:44:51,180 --> 00:44:56,070
pause and so if you don't mind waiting a

00:44:54,480 --> 00:44:57,960
long time for the system to boot up

00:44:56,070 --> 00:44:59,730
because it prints it pauses a couple

00:44:57,960 --> 00:45:01,530
seconds for every print k that line that

00:44:59,730 --> 00:45:04,040
goes out come-come how many print k

00:45:01,530 --> 00:45:06,620
lines are in your

00:45:04,040 --> 00:45:07,840
d message and then add a second for each

00:45:06,620 --> 00:45:10,760
one or something like that

00:45:07,840 --> 00:45:12,530
k exact K top I love it I use that all

00:45:10,760 --> 00:45:14,390
the time that's how I get my data they

00:45:12,530 --> 00:45:16,360
said he could read the the crash utility

00:45:14,390 --> 00:45:20,960
could read the log buffers for in-game

00:45:16,360 --> 00:45:24,020
so summary brigades a way to display

00:45:20,960 --> 00:45:25,490
information for you

00:45:24,020 --> 00:45:26,960
those kernel events so if everything

00:45:25,490 --> 00:45:29,360
else like that once it's the colonel

00:45:26,960 --> 00:45:31,790
wants to talk to you about it

00:45:29,360 --> 00:45:33,410
print k must retain serial order that's

00:45:31,790 --> 00:45:35,060
why I log Bluff is a single buffer we

00:45:33,410 --> 00:45:36,980
have we talked about having multiple

00:45:35,060 --> 00:45:39,140
buffers and so like that but people want

00:45:36,980 --> 00:45:40,670
the order of the actual when the print K

00:45:39,140 --> 00:45:41,750
happen we want that in order with every

00:45:40,670 --> 00:45:42,170
although the printer K does it happen

00:45:41,750 --> 00:45:44,870
now

00:45:42,170 --> 00:45:47,660
and ideally want as much information

00:45:44,870 --> 00:45:49,310
possible before the machine dies other

00:45:47,660 --> 00:45:53,240
than that I don't know if I've time or

00:45:49,310 --> 00:45:57,790
not I don't do bad thank you

00:45:53,240 --> 00:45:57,790

YouTube URL: https://www.youtube.com/watch?v=k32712WNOo8


