Title: Bluetooth Mesh with Zephyr OS and Linux - Johan Hedberg, Open Source Technology Center, Intel
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	Bluetooth Mesh with Zephyr OS and Linux - Johan Hedberg, Open Source Technology Center, Intel

Bluetooth Mesh is a new standard that opens a whole new wave of low-power wireless use cases. It extends the range of communication from a single peer-to-peer connection to a true mesh topology covering large areas, such as an entire building. This paves the way for both home and industrial automation applications. Typical home scenarios include things like controlling the lights in your apartment or adjusting the thermostat. Although Bluetooth 5 was released end of last year, Bluetooth Mesh can be implemented on any device supporting Bluetooth 4.0 or later. This means that we'll likely see very rapid market adoption of the feature.

The presentation will give an introduction to Bluetooth Mesh, covering how it works and what kind of features it provides. The talk will also give an overview of Bluetooth Mesh support in Zephyr OS and Linux and how to create wireless solutions with them.

About Johan Hedberg
I've been hacking on Linux for many years, both on my free time and professionally. I spent many years working on the Maemo and MeeGo projects at Nokia, and for the past five years my employer has been the Open Source Technology Center at Intel. I'm a maintainer for the Linux kernel Bluetooth subsystem and the BlueZ project, as well as the architect & lead developer for Bluetooth on Zephyr. I've presented at various Linux Foundation conferences in the past (Maemo/MeeGo, Tizen, ELC, etc).
Captions: 
	00:00:00,030 --> 00:00:04,350
my name is Johan Hedberg I work for

00:00:02,520 --> 00:00:07,710
Intel's open-source Technology Center

00:00:04,350 --> 00:00:08,760
and I've been doing with this stuff for

00:00:07,710 --> 00:00:12,840
about 15 years now

00:00:08,760 --> 00:00:15,540
most of that time has been on Linux I'm

00:00:12,840 --> 00:00:17,789
one of the maintainer of the Linux

00:00:15,540 --> 00:00:22,289
kernel booted subsystem and blue is a

00:00:17,789 --> 00:00:24,330
blue third stack but for the past I

00:00:22,289 --> 00:00:27,029
think two or three years I've been

00:00:24,330 --> 00:00:30,599
mostly focusing on zephyr and spending

00:00:27,029 --> 00:00:32,460
time there and in this talk I'll be

00:00:30,599 --> 00:00:34,350
talking about Bluetooth mesh

00:00:32,460 --> 00:00:37,550
it's something I've been involved in

00:00:34,350 --> 00:00:41,270
implementing now for the past year or so

00:00:37,550 --> 00:00:45,629
I'll go through the main details of the

00:00:41,270 --> 00:00:46,770
Bluetooth my specification going a

00:00:45,629 --> 00:00:50,309
little bit in detail on some of the

00:00:46,770 --> 00:00:53,100
technical aspects of it and then I'll be

00:00:50,309 --> 00:00:55,110
also going through what our current

00:00:53,100 --> 00:00:58,890
deployment ation status of Bluetooth

00:00:55,110 --> 00:01:01,670
meshes for zephyr and for Linux and a

00:00:58,890 --> 00:01:05,119
little bit also on what our plans are

00:01:01,670 --> 00:01:09,510
for the foreseeable future

00:01:05,119 --> 00:01:11,640
so Bluetooth mesh is a new specification

00:01:09,510 --> 00:01:15,210
that came up from the Bluetooth SIG this

00:01:11,640 --> 00:01:18,240
year it came out in the middle of July

00:01:15,210 --> 00:01:22,470
and for the first time it extends

00:01:18,240 --> 00:01:27,450
Bluetooth connections to a true mesh

00:01:22,470 --> 00:01:29,640
like many-to-many multi-hop topology it

00:01:27,450 --> 00:01:32,009
doesn't have any new demands on

00:01:29,640 --> 00:01:33,380
Bluetooth hardware so if any Bluetooth

00:01:32,009 --> 00:01:35,759
hardware which is capable of running

00:01:33,380 --> 00:01:40,340
Bluetooth Low Energy that is Bluetooth

00:01:35,759 --> 00:01:43,710
4.0 will be able to do Bluetooth mesh

00:01:40,340 --> 00:01:45,270
it's worth to mention though that in

00:01:43,710 --> 00:01:49,530
most cases it does require some

00:01:45,270 --> 00:01:52,590
operating system updates so for example

00:01:49,530 --> 00:01:55,409
current iOS and Android versions they're

00:01:52,590 --> 00:01:57,090
not able to do mesh natively yet I would

00:01:55,409 --> 00:02:02,100
expect them to get some updates at some

00:01:57,090 --> 00:02:04,189
point that there's a fundamental aspect

00:02:02,100 --> 00:02:08,069
of mesh which is broadcasting messages

00:02:04,189 --> 00:02:10,050
relaying them and it's basically kind of

00:02:08,069 --> 00:02:11,849
a managed flooding of messages the way

00:02:10,050 --> 00:02:13,879
that the messages go through a mesh

00:02:11,849 --> 00:02:13,879
network

00:02:14,519 --> 00:02:21,000
you don't get super high data transfer

00:02:18,580 --> 00:02:23,799
speeds with Bluetooth mesh so it's most

00:02:21,000 --> 00:02:26,049
suited for simple signaling small

00:02:23,799 --> 00:02:28,180
signaling packets you can of course do

00:02:26,049 --> 00:02:31,500
large data transfer with it but the

00:02:28,180 --> 00:02:34,390
transfer speed won't be that great

00:02:31,500 --> 00:02:36,310
message publication a subscription is a

00:02:34,390 --> 00:02:37,900
fundamental aspect also of mesh and it

00:02:36,310 --> 00:02:39,760
is something I'll go in a little bit

00:02:37,900 --> 00:02:41,530
more detail it's a way of kind of

00:02:39,760 --> 00:02:43,360
organizing who's sending messages and

00:02:41,530 --> 00:02:46,750
who's receiving messages in a Bluetooth

00:02:43,360 --> 00:02:48,910
mesh network and security is something

00:02:46,750 --> 00:02:50,290
that's built into the core of Bluetooth

00:02:48,910 --> 00:02:53,620
mesh and you'll find out that many

00:02:50,290 --> 00:02:56,049
different levels and layers in the mesh

00:02:53,620 --> 00:02:58,739
specification but I'll have some more on

00:02:56,049 --> 00:03:01,060
that also later in the presentation and

00:02:58,739 --> 00:03:04,000
one of the biggest benefits of course of

00:03:01,060 --> 00:03:05,829
mesh is that you get way more range that

00:03:04,000 --> 00:03:08,530
then you get with traditional Bluetooth

00:03:05,829 --> 00:03:11,019
which in most circumstances it's around

00:03:08,530 --> 00:03:12,400
10 meters or so whereas with booted mesh

00:03:11,019 --> 00:03:15,819
when you have the multiple hops you can

00:03:12,400 --> 00:03:21,549
get kilometres of range for a single

00:03:15,819 --> 00:03:25,049
message a little bit about how mesh fits

00:03:21,549 --> 00:03:27,489
into what's already there for Bluetooth

00:03:25,049 --> 00:03:28,959
the concept of pairing might be familiar

00:03:27,489 --> 00:03:30,549
to many of you and that's something

00:03:28,959 --> 00:03:32,079
that's existed from the very beginning

00:03:30,549 --> 00:03:33,370
with blue that exists for Bluetooth

00:03:32,079 --> 00:03:35,560
classic and it exists for Bluetooth Low

00:03:33,370 --> 00:03:37,540
Energy and that's basically as the name

00:03:35,560 --> 00:03:41,049
implies pairing up two devices for

00:03:37,540 --> 00:03:44,919
one-to-one connection and that's the

00:03:41,049 --> 00:03:47,650
kind of kind of way that you use most

00:03:44,919 --> 00:03:49,359
Bluetooth devices today blue this

00:03:47,650 --> 00:03:52,299
low-energy also brings the possibility

00:03:49,359 --> 00:03:55,660
of doing broadcasting from one device to

00:03:52,299 --> 00:03:57,669
many devices so you could have something

00:03:55,660 --> 00:03:58,870
to people called beacons where we have

00:03:57,669 --> 00:04:00,639
one device called casting and many

00:03:58,870 --> 00:04:03,879
devices who are then able to receive

00:04:00,639 --> 00:04:06,250
that and mesh now fills in the missing

00:04:03,879 --> 00:04:10,810
piece they're basically enabling

00:04:06,250 --> 00:04:13,019
many-to-many communication and typical

00:04:10,810 --> 00:04:16,810
use cases you will see this with will be

00:04:13,019 --> 00:04:19,539
building automation sensor networks in

00:04:16,810 --> 00:04:21,340
your home common use case that we

00:04:19,539 --> 00:04:22,419
actually already see devices in the

00:04:21,340 --> 00:04:23,979
market even though it's just a few

00:04:22,419 --> 00:04:26,500
months since the specification went

00:04:23,979 --> 00:04:29,170
public is smart lightning where

00:04:26,500 --> 00:04:32,760
have light switches and lights talking

00:04:29,170 --> 00:04:32,760
to each other through mesh network

00:04:33,730 --> 00:04:39,460
a little bit how much fits into the

00:04:37,320 --> 00:04:42,280
traditional roles that you have

00:04:39,460 --> 00:04:44,580
specified for Bluetooth Low Energy on a

00:04:42,280 --> 00:04:47,160
very high level you can categorize

00:04:44,580 --> 00:04:50,470
Bluetooth Low Energy roles into

00:04:47,160 --> 00:04:54,370
connection oriented and connectionless

00:04:50,470 --> 00:04:56,050
the connection oriented roles are the

00:04:54,370 --> 00:04:57,370
central and the peripheral where the

00:04:56,050 --> 00:04:59,620
central is the one initiating a

00:04:57,370 --> 00:05:03,880
connection to one or more peripheral

00:04:59,620 --> 00:05:08,230
devices a PC or phone would be or

00:05:03,880 --> 00:05:09,280
typical central where as sensors a heart

00:05:08,230 --> 00:05:11,350
rate monitor or something like that

00:05:09,280 --> 00:05:15,220
would be the peripheral but these are

00:05:11,350 --> 00:05:17,230
always one-to-one connections and then

00:05:15,220 --> 00:05:18,610
you have the connectionless roles in LA

00:05:17,230 --> 00:05:21,130
which is the observer and the

00:05:18,610 --> 00:05:23,910
broadcaster and as the name implies the

00:05:21,130 --> 00:05:27,669
observer is just sitting there passively

00:05:23,910 --> 00:05:30,010
waiting for packets to come and a

00:05:27,669 --> 00:05:33,150
broadcaster is broadcasting packets to

00:05:30,010 --> 00:05:37,240
anybody who might be interested and

00:05:33,150 --> 00:05:39,610
because of this feature of the observer

00:05:37,240 --> 00:05:41,320
broadcaster pair it's it's well suited

00:05:39,610 --> 00:05:44,860
for mesh and that's actually what

00:05:41,320 --> 00:05:46,780
Bluetooth mesh uses so every node in a

00:05:44,860 --> 00:05:49,000
Bluetooth mesh network is both an

00:05:46,780 --> 00:05:54,100
observer and the broadcaster in that

00:05:49,000 --> 00:05:56,919
sense a little overview of the kind of

00:05:54,100 --> 00:05:58,540
nodes that you will find in Bluetooth

00:05:56,919 --> 00:06:01,300
mesh network this is a completely

00:05:58,540 --> 00:06:02,740
imaginary example just for the purpose

00:06:01,300 --> 00:06:05,860
of highlighting all the different kinds

00:06:02,740 --> 00:06:10,630
of nodes that you can have participating

00:06:05,860 --> 00:06:11,800
in a mesh network at the root of a mesh

00:06:10,630 --> 00:06:14,350
network you have something called a

00:06:11,800 --> 00:06:16,150
provisioner and the provisioner is

00:06:14,350 --> 00:06:19,990
responsible for managing the address

00:06:16,150 --> 00:06:22,210
space of the mesh network and it's more

00:06:19,990 --> 00:06:23,620
responsible for taking any new mesh

00:06:22,210 --> 00:06:27,370
device into use and making it a

00:06:23,620 --> 00:06:31,120
functional node in the mesh network it

00:06:27,370 --> 00:06:34,120
will hand out the assign address or

00:06:31,120 --> 00:06:38,470
addresses to the nodes give the initial

00:06:34,120 --> 00:06:39,980
network key and and so on if you start

00:06:38,470 --> 00:06:44,480
going

00:06:39,980 --> 00:06:45,890
through this from the left there the gut

00:06:44,480 --> 00:06:48,560
client and got proxy

00:06:45,890 --> 00:06:50,600
let me first clarify God stands for

00:06:48,560 --> 00:06:53,390
generic attribute profile and it's the

00:06:50,600 --> 00:06:55,250
protocol that essentially all existing

00:06:53,390 --> 00:06:57,620
Bluetooth low-energy devices use to

00:06:55,250 --> 00:07:00,020
communicate with each other these

00:06:57,620 --> 00:07:02,210
features exist in Bluetooth mesh to

00:07:00,020 --> 00:07:06,040
enable compatibility with existing

00:07:02,210 --> 00:07:09,710
legacy devices that cannot talk the mesh

00:07:06,040 --> 00:07:12,740
advertising and scanning based protocol

00:07:09,710 --> 00:07:14,270
natively so that would be the current

00:07:12,740 --> 00:07:16,850
situation with your mobile phone

00:07:14,270 --> 00:07:19,520
OSs since you cannot actually with their

00:07:16,850 --> 00:07:21,200
current api's do the kind of advertising

00:07:19,520 --> 00:07:23,330
and scanning that's needed by mesh so

00:07:21,200 --> 00:07:25,490
you would have for example a an older

00:07:23,330 --> 00:07:26,810
phone acting as the goth client and then

00:07:25,490 --> 00:07:28,700
you would have a device called the goth

00:07:26,810 --> 00:07:32,390
proxy that's responsible for bridging

00:07:28,700 --> 00:07:34,970
this one-to-one connection to the actual

00:07:32,390 --> 00:07:37,850
mesh network and proxy messages back and

00:07:34,970 --> 00:07:43,340
forth there then you can have one or

00:07:37,850 --> 00:07:46,820
more devices actually works no one more

00:07:43,340 --> 00:07:50,390
device is acting as relay in the network

00:07:46,820 --> 00:07:52,670
responsible for forwarding messages and

00:07:50,390 --> 00:07:54,530
then you will often have pairs of

00:07:52,670 --> 00:07:57,470
devices called friends and low-power

00:07:54,530 --> 00:07:59,540
nodes I'll get into this in a bit more

00:07:57,470 --> 00:08:00,710
detail later but the general idea is

00:07:59,540 --> 00:08:02,480
that you have friend notes which are

00:08:00,710 --> 00:08:05,980
caching messages for lower power nodes

00:08:02,480 --> 00:08:08,270
which then ask the friend note that

00:08:05,980 --> 00:08:13,640
intervals like if there are any messages

00:08:08,270 --> 00:08:15,980
destined for the low power node a little

00:08:13,640 --> 00:08:18,830
bit about the various stages that the

00:08:15,980 --> 00:08:21,350
mesh node goes through when you buy a

00:08:18,830 --> 00:08:23,540
new device it will be on provisioned it

00:08:21,350 --> 00:08:25,310
will be completely unusable in a mesh

00:08:23,540 --> 00:08:27,100
network until you go ahead and use

00:08:25,310 --> 00:08:30,260
provision earth to provision it and

00:08:27,100 --> 00:08:32,090
during the provisioning you basically

00:08:30,260 --> 00:08:35,840
give the initial network key to the node

00:08:32,090 --> 00:08:36,860
you assign it an address this one thing

00:08:35,840 --> 00:08:38,990
missing here actually which is the

00:08:36,860 --> 00:08:41,900
device key which is a special applicator

00:08:38,990 --> 00:08:43,790
wise application key only between the

00:08:41,900 --> 00:08:45,620
provisioner and that one node which is

00:08:43,790 --> 00:08:48,440
then used for configuring and some other

00:08:45,620 --> 00:08:51,620
things once you provision it it's still

00:08:48,440 --> 00:08:53,750
not fully usable in the mesh network you

00:08:51,620 --> 00:08:55,670
need to assign it additional

00:08:53,750 --> 00:08:58,540
application keys you need to configure

00:08:55,670 --> 00:09:01,550
the publication and the subscription

00:08:58,540 --> 00:09:03,890
addresses and so on and the

00:09:01,550 --> 00:09:05,090
configuration is done using this device

00:09:03,890 --> 00:09:08,330
key that was given during the

00:09:05,090 --> 00:09:11,960
provisioning phase and once you complete

00:09:08,330 --> 00:09:14,240
doing the configuration then the node is

00:09:11,960 --> 00:09:15,560
kind of a full mesh network node and

00:09:14,240 --> 00:09:20,540
it's able to participate and do anything

00:09:15,560 --> 00:09:23,000
that you need to do with it now later on

00:09:20,540 --> 00:09:25,250
maybe you sell your device maybe you

00:09:23,000 --> 00:09:26,930
lose it something like that there's a

00:09:25,250 --> 00:09:30,350
feature in Bluetooth mesh called

00:09:26,930 --> 00:09:33,950
blacklisting which operates through a

00:09:30,350 --> 00:09:35,330
functionality called key refresh so what

00:09:33,950 --> 00:09:38,450
the provisioner can then do is that it

00:09:35,330 --> 00:09:40,280
can hand out new keys to the nodes in

00:09:38,450 --> 00:09:42,710
the network it will do those using the

00:09:40,280 --> 00:09:45,680
pairwise device key but can then

00:09:42,710 --> 00:09:46,760
selectively leave out specific notes

00:09:45,680 --> 00:09:48,730
that it doesn't want to give the new

00:09:46,760 --> 00:09:50,870
keys to and that way it essentially

00:09:48,730 --> 00:09:53,930
excludes those devices from the mesh

00:09:50,870 --> 00:09:55,610
network and once you do that to a mesh

00:09:53,930 --> 00:09:57,200
node it becomes unusable to kind of

00:09:55,610 --> 00:09:59,210
participate in the network until you go

00:09:57,200 --> 00:10:01,339
ahead and reset it and then it comes

00:09:59,210 --> 00:10:06,950
back into the I'm provisioned state

00:10:01,339 --> 00:10:10,250
again so basically full cycle now let's

00:10:06,950 --> 00:10:16,130
look a little bit at the kind of logical

00:10:10,250 --> 00:10:18,410
composition of nodes in a mesh network

00:10:16,130 --> 00:10:21,110
each node that's participating in a mesh

00:10:18,410 --> 00:10:24,350
network has one or more so-called

00:10:21,110 --> 00:10:26,060
elements and an element in a mesh

00:10:24,350 --> 00:10:28,910
network that's the smallest addressable

00:10:26,060 --> 00:10:31,370
entity that you can have so each element

00:10:28,910 --> 00:10:35,960
has a network address that you can send

00:10:31,370 --> 00:10:38,540
messages to it with and each element in

00:10:35,960 --> 00:10:40,670
turn consists of one or more more

00:10:38,540 --> 00:10:43,130
so-called models now what the model

00:10:40,670 --> 00:10:46,100
essentially is is just a collective

00:10:43,130 --> 00:10:49,339
collection of messages and states

00:10:46,100 --> 00:10:51,589
relating to those messages and the

00:10:49,339 --> 00:10:56,240
messages are identified using op codes

00:10:51,589 --> 00:10:59,540
and that's basically it on a higher

00:10:56,240 --> 00:11:01,750
level you could categorize the models to

00:10:59,540 --> 00:11:04,280
client models and the server models

00:11:01,750 --> 00:11:07,350
where current models are those that

00:11:04,280 --> 00:11:10,530
typically initiate sending messages

00:11:07,350 --> 00:11:11,940
requests and on the receiving side you

00:11:10,530 --> 00:11:13,860
have a server model that's receiving it

00:11:11,940 --> 00:11:18,350
and then responding typically with some

00:11:13,860 --> 00:11:18,350
kind of response message to the request

00:11:19,250 --> 00:11:24,540
about the various protocol layer so it's

00:11:22,020 --> 00:11:26,460
not super simple specification and there

00:11:24,540 --> 00:11:29,400
are several layers in the mesh

00:11:26,460 --> 00:11:30,750
specification if you start there from

00:11:29,400 --> 00:11:33,720
the bottom it might be simply to go

00:11:30,750 --> 00:11:36,540
bottom up instead of top down there's

00:11:33,720 --> 00:11:40,410
the transport layer or the barrier layer

00:11:36,540 --> 00:11:42,090
and for native mesh operation all you

00:11:40,410 --> 00:11:45,240
have is the advertising barrier that's

00:11:42,090 --> 00:11:47,400
kind of innate a native mesh transport

00:11:45,240 --> 00:11:49,200
but then if you have these legacy

00:11:47,400 --> 00:11:51,930
devices like you would have to do with

00:11:49,200 --> 00:11:54,450
your existing phone you have the option

00:11:51,930 --> 00:11:56,700
of using the goth bearer there instead

00:11:54,450 --> 00:11:58,830
of the advertising bearer to be able to

00:11:56,700 --> 00:12:01,590
talk to to mesh networks with legacy

00:11:58,830 --> 00:12:03,630
devices on top of that you have the

00:12:01,590 --> 00:12:06,180
network layer which takes care of the

00:12:03,630 --> 00:12:07,980
network layer addressing of devices so

00:12:06,180 --> 00:12:11,370
that's how we talk to specific elements

00:12:07,980 --> 00:12:13,200
in the mesh network you have the network

00:12:11,370 --> 00:12:15,350
layer encryption

00:12:13,200 --> 00:12:18,840
let's taking care of there and the

00:12:15,350 --> 00:12:20,520
authentication and there's some other

00:12:18,840 --> 00:12:22,220
details there which I'll go into later

00:12:20,520 --> 00:12:24,860
also which are part of the network layer

00:12:22,220 --> 00:12:28,080
then you have the upper and the lower

00:12:24,860 --> 00:12:30,090
transport layer there are some kind of

00:12:28,080 --> 00:12:32,460
generic functionalities that are taken

00:12:30,090 --> 00:12:33,960
care of there that are needed for the

00:12:32,460 --> 00:12:36,030
mesh network segmentation and reassembly

00:12:33,960 --> 00:12:39,690
is something the lower transport layers

00:12:36,030 --> 00:12:41,450
responsible for and in the upper

00:12:39,690 --> 00:12:45,360
transport layer there's things like

00:12:41,450 --> 00:12:48,360
Harpeth and friendship which I'll get

00:12:45,360 --> 00:12:50,820
into later the application layer

00:12:48,360 --> 00:12:54,270
encryption is also taken care on on the

00:12:50,820 --> 00:12:58,140
upper transport layer on top of that you

00:12:54,270 --> 00:12:59,850
have the multiplexing of messages into

00:12:58,140 --> 00:13:01,650
the specific models that implement those

00:12:59,850 --> 00:13:03,990
messages so the access layer will be

00:13:01,650 --> 00:13:06,660
looking at the opcode containing the

00:13:03,990 --> 00:13:08,040
message and then forwarding it to the

00:13:06,660 --> 00:13:10,110
relevant model in question that's

00:13:08,040 --> 00:13:12,990
supposed to handle that message and then

00:13:10,110 --> 00:13:16,770
at the very top you have the actual

00:13:12,990 --> 00:13:19,020
models that define the various states

00:13:16,770 --> 00:13:21,210
and messages and behavior related to

00:13:19,020 --> 00:13:23,010
those the

00:13:21,210 --> 00:13:25,470
the mayor specification itself actually

00:13:23,010 --> 00:13:29,280
comes with a couple of so-called

00:13:25,470 --> 00:13:31,710
foundation models which are used for

00:13:29,280 --> 00:13:33,060
their mandatory for every single node in

00:13:31,710 --> 00:13:35,670
a mesh network to implement they're used

00:13:33,060 --> 00:13:37,650
for example for configuring the mesh

00:13:35,670 --> 00:13:40,950
node giving it keys configuring the

00:13:37,650 --> 00:13:42,330
various addresses and so on and then

00:13:40,950 --> 00:13:43,980
there's a separate specification called

00:13:42,330 --> 00:13:45,270
the mesh model specification that was

00:13:43,980 --> 00:13:47,130
released at the same time and that one

00:13:45,270 --> 00:13:50,370
then has a bit more specialized models

00:13:47,130 --> 00:13:56,310
that not every node will be interested

00:13:50,370 --> 00:14:00,090
in implementing if you look at the main

00:13:56,310 --> 00:14:07,500
fields in a mesh network PDU it looks

00:14:00,090 --> 00:14:09,240
like this there is inherent replay

00:14:07,500 --> 00:14:11,550
protection in the mesh network where you

00:14:09,240 --> 00:14:14,040
have an ever-increasing index number

00:14:11,550 --> 00:14:16,620
combined with something called the ib

00:14:14,040 --> 00:14:19,620
index and the first bit there is

00:14:16,620 --> 00:14:23,280
actually just the least significant bit

00:14:19,620 --> 00:14:26,100
of the ib index that's used for the

00:14:23,280 --> 00:14:27,810
receiving device to know whether it's

00:14:26,100 --> 00:14:31,140
current ib index or the previous one

00:14:27,810 --> 00:14:34,890
that should be used to decrypt then you

00:14:31,140 --> 00:14:38,430
have a 7-bit network ID essentially all

00:14:34,890 --> 00:14:42,260
this is is kind of hash of the network

00:14:38,430 --> 00:14:47,040
key to allow for early filtering out of

00:14:42,260 --> 00:14:49,290
uninteresting mesh pockets so when a

00:14:47,040 --> 00:14:51,300
node is receiving mesh messages it would

00:14:49,290 --> 00:14:52,790
first look at those seven bits and if

00:14:51,300 --> 00:14:55,740
they don't match any of the known

00:14:52,790 --> 00:14:57,420
networks keys to the node it can just

00:14:55,740 --> 00:15:00,180
discard the message immediately it

00:14:57,420 --> 00:15:01,680
doesn't have to go through the process

00:15:00,180 --> 00:15:04,580
of trying to decrypt it and so on which

00:15:01,680 --> 00:15:06,720
would be consuming quite a lot of power

00:15:04,580 --> 00:15:08,460
then there's a bit for indicating

00:15:06,720 --> 00:15:10,770
whether it's it's like a signaling

00:15:08,460 --> 00:15:12,950
packet for generic network control like

00:15:10,770 --> 00:15:16,230
an acknowledgment of of segments or

00:15:12,950 --> 00:15:19,080
something like that there's a time to

00:15:16,230 --> 00:15:20,820
leave value that's used to make sure

00:15:19,080 --> 00:15:23,670
that the message eventually dies out

00:15:20,820 --> 00:15:25,620
when it gets relayed through the network

00:15:23,670 --> 00:15:27,420
there's the sequence number which gets

00:15:25,620 --> 00:15:29,490
incremented for every message when a

00:15:27,420 --> 00:15:33,030
node sends those out which is important

00:15:29,490 --> 00:15:35,100
for predicting as replay attack replay

00:15:33,030 --> 00:15:36,660
attacks when receiving the message

00:15:35,100 --> 00:15:41,670
the sequence numbers combined with the

00:15:36,660 --> 00:15:44,700
IB index which each node is aware of and

00:15:41,670 --> 00:15:47,010
the the first bit there the IBI bit is a

00:15:44,700 --> 00:15:48,120
hint of which of two possible IV indexes

00:15:47,010 --> 00:15:52,410
should be combined with the sequence

00:15:48,120 --> 00:15:55,590
number then to decrypt and verify

00:15:52,410 --> 00:15:57,120
against the replay protection then

00:15:55,590 --> 00:15:59,910
you've got the actual addresses so who

00:15:57,120 --> 00:16:02,130
is sending the message and who is the

00:15:59,910 --> 00:16:04,890
recipient of the message and after that

00:16:02,130 --> 00:16:08,670
you have the actual transport payload

00:16:04,890 --> 00:16:11,820
the application payload and at the very

00:16:08,670 --> 00:16:14,580
end of the message you have the network

00:16:11,820 --> 00:16:17,120
layer message integrity check which can

00:16:14,580 --> 00:16:21,150
be either four bytes or eight bytes

00:16:17,120 --> 00:16:22,920
usually the way this is done is that if

00:16:21,150 --> 00:16:25,110
you have an application payload that has

00:16:22,920 --> 00:16:27,330
its own message integrity check then

00:16:25,110 --> 00:16:30,090
that one will be four bytes and then in

00:16:27,330 --> 00:16:31,770
such a case the network message

00:16:30,090 --> 00:16:36,060
integrity check is also four bytes so

00:16:31,770 --> 00:16:39,300
you always have either four eight but so

00:16:36,060 --> 00:16:41,190
either four plus four or then eight you

00:16:39,300 --> 00:16:43,710
will use an eight in the case of having

00:16:41,190 --> 00:16:45,420
a local network control packet where you

00:16:43,710 --> 00:16:48,810
don't have an actual application layer

00:16:45,420 --> 00:16:53,790
encryption in that case the CTL bit will

00:16:48,810 --> 00:16:56,550
be set to one a little bit about the

00:16:53,790 --> 00:17:00,600
console addresses so as you saw mesh

00:16:56,550 --> 00:17:02,910
addresses are 16 bits and they have can

00:17:00,600 --> 00:17:07,440
be sub categorized into a couple of

00:17:02,910 --> 00:17:09,750
different types you have address 0 which

00:17:07,440 --> 00:17:11,250
is not used for anything else except to

00:17:09,750 --> 00:17:14,310
say that this is unassigned this is not

00:17:11,250 --> 00:17:16,020
used for anything it's never actually

00:17:14,310 --> 00:17:18,870
that's not ready it is sent over the air

00:17:16,020 --> 00:17:20,459
but mainly to indicate that this is like

00:17:18,870 --> 00:17:24,390
an invalid field or something like that

00:17:20,459 --> 00:17:26,880
in a message then you have an address

00:17:24,390 --> 00:17:28,170
that's unique for every element in the

00:17:26,880 --> 00:17:30,810
mesh network it's called a unicast

00:17:28,170 --> 00:17:33,960
address and that's the address handed

00:17:30,810 --> 00:17:36,780
over by the probationer to the notes

00:17:33,960 --> 00:17:39,090
that it's provisioning and then you have

00:17:36,780 --> 00:17:40,890
the group and the virtual address is

00:17:39,090 --> 00:17:45,900
also with the group address so that's

00:17:40,890 --> 00:17:48,690
basically an address that a node can

00:17:45,900 --> 00:17:51,390
either publish to or subscribe to and

00:17:48,690 --> 00:17:54,840
enables sending a message to multiple

00:17:51,390 --> 00:17:58,669
devices a virtual address is a special

00:17:54,840 --> 00:18:02,580
kind of group address it's in reality a

00:17:58,669 --> 00:18:05,429
128-bit so-called virtual label UUID

00:18:02,580 --> 00:18:07,890
that's only known internally by the

00:18:05,429 --> 00:18:11,039
notice 10% over the air and the virtual

00:18:07,890 --> 00:18:13,830
address the 16-bit is a kind of hash of

00:18:11,039 --> 00:18:15,390
that one and there's like extra

00:18:13,830 --> 00:18:18,000
authentication information passed when

00:18:15,390 --> 00:18:20,250
it when you're doing the the encryption

00:18:18,000 --> 00:18:22,260
of the message where you will include

00:18:20,250 --> 00:18:23,490
the full 128 bits there so the recipient

00:18:22,260 --> 00:18:26,850
can then verify that yes this was

00:18:23,490 --> 00:18:28,289
actually this 128 bits that that matches

00:18:26,850 --> 00:18:30,690
this virtual address that is not a

00:18:28,289 --> 00:18:37,610
collision of another virtual level you

00:18:30,690 --> 00:18:40,140
are in relaying which is fundamental to

00:18:37,610 --> 00:18:41,669
Bluetooth mesh basically the way it

00:18:40,140 --> 00:18:46,049
works is that you have the time to live

00:18:41,669 --> 00:18:48,990
value when a node receives a packet it

00:18:46,049 --> 00:18:51,690
will first of all it will decrypt the

00:18:48,990 --> 00:18:55,260
packet with its network key that way it

00:18:51,690 --> 00:18:58,380
gets access to all these most important

00:18:55,260 --> 00:19:01,260
Network layer headers one of which is

00:18:58,380 --> 00:19:04,559
the time to live it will decrypt it if

00:19:01,260 --> 00:19:07,020
the value is still greater than 0 it

00:19:04,559 --> 00:19:09,570
will go ahead and re encrypt it with

00:19:07,020 --> 00:19:12,510
with the new value and then broadcast it

00:19:09,570 --> 00:19:13,860
back out to the mesh network an

00:19:12,510 --> 00:19:16,260
important thing to notice here is that

00:19:13,860 --> 00:19:20,250
the application payload stays untouched

00:19:16,260 --> 00:19:22,260
when you're doing relaying so a relay

00:19:20,250 --> 00:19:23,400
device in a mesh network doesn't need to

00:19:22,260 --> 00:19:26,429
have any kind of knowledge of any

00:19:23,400 --> 00:19:28,200
application keys whatsoever which is a

00:19:26,429 --> 00:19:29,970
nice thing to have if you have some

00:19:28,200 --> 00:19:32,580
security sensitive messages that they

00:19:29,970 --> 00:19:34,740
are sending between two nodes if your

00:19:32,580 --> 00:19:35,970
relay or many relays get compromised

00:19:34,740 --> 00:19:37,590
they will never get access to the actual

00:19:35,970 --> 00:19:44,490
payload there because they don't have

00:19:37,590 --> 00:19:46,169
the application key in that case message

00:19:44,490 --> 00:19:47,700
publication and subscription I mention

00:19:46,169 --> 00:19:52,860
little bit earlier it's also a core

00:19:47,700 --> 00:19:57,020
feature of Bluetooth mesh abused here as

00:19:52,860 --> 00:20:00,179
an example the smart lightning case so

00:19:57,020 --> 00:20:02,050
you on the left there you will have your

00:20:00,179 --> 00:20:04,690
light switches

00:20:02,050 --> 00:20:06,790
right you have actual lights and the way

00:20:04,690 --> 00:20:10,810
we've group group them here is based on

00:20:06,790 --> 00:20:12,130
what room the lights are in so the way

00:20:10,810 --> 00:20:13,870
you would go about configuring the

00:20:12,130 --> 00:20:16,120
lights is that you configure a

00:20:13,870 --> 00:20:18,940
subscription address to them a group

00:20:16,120 --> 00:20:21,550
address that assigned to that specific

00:20:18,940 --> 00:20:23,230
room where the light is in and the

00:20:21,550 --> 00:20:26,770
switches in turn are configured to

00:20:23,230 --> 00:20:28,810
publish to specific group addresses and

00:20:26,770 --> 00:20:33,190
that's how you can reach the right room

00:20:28,810 --> 00:20:34,780
with from the right switches and the

00:20:33,190 --> 00:20:37,200
convenient thing with this is is that if

00:20:34,780 --> 00:20:39,430
you at some point you get a new light

00:20:37,200 --> 00:20:42,850
you don't need to go and reconfigure

00:20:39,430 --> 00:20:44,500
your light switches to make them talk to

00:20:42,850 --> 00:20:45,790
the new light instead I only need to do

00:20:44,500 --> 00:20:48,460
is you need to configure the new light

00:20:45,790 --> 00:20:50,740
to subscribe to the appropriate group

00:20:48,460 --> 00:20:52,650
address that's assigned to the room that

00:20:50,740 --> 00:20:55,300
they put the light in and it should work

00:20:52,650 --> 00:21:00,640
after that without touching the switches

00:20:55,300 --> 00:21:03,310
in any way then a little bit more detail

00:21:00,640 --> 00:21:06,010
about the security features that this

00:21:03,310 --> 00:21:07,330
mesh has so starting with the

00:21:06,010 --> 00:21:10,690
provisioning when you take a new device

00:21:07,330 --> 00:21:12,880
in to use intermesh network this is

00:21:10,690 --> 00:21:17,050
actually the mesh provisioning protocol

00:21:12,880 --> 00:21:20,350
is modeled based on the bluetooth

00:21:17,050 --> 00:21:23,700
pairing protocol so it uses the same

00:21:20,350 --> 00:21:26,590
security mechanisms this involves

00:21:23,700 --> 00:21:29,560
elliptic curve diffie-hellman where you

00:21:26,590 --> 00:21:31,060
receive the remote public key combine

00:21:29,560 --> 00:21:33,070
that with your own private key to

00:21:31,060 --> 00:21:36,450
generate a th key and then that one is

00:21:33,070 --> 00:21:39,220
used to have secure relationship there

00:21:36,450 --> 00:21:40,840
there are mechanisms for passing

00:21:39,220 --> 00:21:42,490
information over out the band so you can

00:21:40,840 --> 00:21:45,040
get the public key out of the band or

00:21:42,490 --> 00:21:46,750
you can get some other piece of

00:21:45,040 --> 00:21:48,550
information like like a pin code or

00:21:46,750 --> 00:21:51,130
something like like that outer band

00:21:48,550 --> 00:21:53,890
during the actual provisioning the same

00:21:51,130 --> 00:21:56,860
thing as you get with bluetooth pairing

00:21:53,890 --> 00:21:58,060
as well then wants to know this

00:21:56,860 --> 00:22:00,390
provision and it's part of a mesh

00:21:58,060 --> 00:22:03,010
network you have two layers of

00:22:00,390 --> 00:22:05,830
encryption going on there you have a

00:22:03,010 --> 00:22:07,900
network layer and you have the

00:22:05,830 --> 00:22:10,420
application layer and as I mentioned

00:22:07,900 --> 00:22:11,920
this is useful for example for for the

00:22:10,420 --> 00:22:14,590
relay use case where you don't need to

00:22:11,920 --> 00:22:15,860
give application keys to every single

00:22:14,590 --> 00:22:20,840
node in the network

00:22:15,860 --> 00:22:23,860
and since mesh uses broadcasting

00:22:20,840 --> 00:22:26,690
amenities that anybody can receive it's

00:22:23,860 --> 00:22:27,800
extremely simple if there wasn't some

00:22:26,690 --> 00:22:32,000
kind of protection makeups and

00:22:27,800 --> 00:22:33,860
mechanisms for it to implement a replay

00:22:32,000 --> 00:22:35,450
attack on a mesh network because you

00:22:33,860 --> 00:22:37,130
just you don't need to know what what

00:22:35,450 --> 00:22:39,290
the packet is you just hold on to it for

00:22:37,130 --> 00:22:41,470
some time and then you send it back out

00:22:39,290 --> 00:22:44,990
let's say you have a door lock and

00:22:41,470 --> 00:22:47,570
there's no replay protection so somebody

00:22:44,990 --> 00:22:50,420
unlocks the door your neighbor hears the

00:22:47,570 --> 00:22:52,490
packet doesn't do anything with it for

00:22:50,420 --> 00:22:55,310
hours or for a day and then the next day

00:22:52,490 --> 00:22:57,950
they go ahead and just send the packet

00:22:55,310 --> 00:22:59,720
back out and the door unlocks again so

00:22:57,950 --> 00:23:02,990
to protect against this there's a

00:22:59,720 --> 00:23:04,400
continuously incrementing number called

00:23:02,990 --> 00:23:09,680
the sequence number which is combined

00:23:04,400 --> 00:23:14,780
with the IV index in total these are 56

00:23:09,680 --> 00:23:17,620
bits long so it will take I think it's

00:23:14,780 --> 00:23:19,910
millions of years or something like that

00:23:17,620 --> 00:23:21,680
with your typical sending out the

00:23:19,910 --> 00:23:23,690
packets before they loop around and

00:23:21,680 --> 00:23:24,860
would actually cause a compromise so in

00:23:23,690 --> 00:23:29,270
practice that that should never happen

00:23:24,860 --> 00:23:31,040
and though IV index doesn't that does it

00:23:29,270 --> 00:23:33,800
never goes over the air itself there's

00:23:31,040 --> 00:23:37,610
only the one bit of it that that you saw

00:23:33,800 --> 00:23:39,320
earlier instead each note has an idea

00:23:37,610 --> 00:23:41,120
what the current IB index is and then

00:23:39,320 --> 00:23:43,430
there's a whole procedure called the IB

00:23:41,120 --> 00:23:45,140
index update procedure using which every

00:23:43,430 --> 00:23:46,970
node in the mesh network agrees that

00:23:45,140 --> 00:23:49,430
okay now they switched in the next IB

00:23:46,970 --> 00:23:51,350
index to use that I never knowed is

00:23:49,430 --> 00:23:53,120
always able to receive with the current

00:23:51,350 --> 00:23:54,920
one and the previous one in case they're

00:23:53,120 --> 00:23:56,150
a little bit out of sync somebody's

00:23:54,920 --> 00:23:58,220
using the new one somebody's using the

00:23:56,150 --> 00:24:02,060
old one but everything should still keep

00:23:58,220 --> 00:24:03,770
working all the time and then this thing

00:24:02,060 --> 00:24:05,240
if somebody steals your device to get

00:24:03,770 --> 00:24:05,990
access to the keys or you sell it or

00:24:05,240 --> 00:24:08,570
something like that

00:24:05,990 --> 00:24:10,760
you can do the key refresh procedure to

00:24:08,570 --> 00:24:17,560
exclude them from the network and that

00:24:10,760 --> 00:24:17,560
way not not be compromised

00:24:20,270 --> 00:24:30,440
the advertising packets that Bluetooth

00:24:24,860 --> 00:24:34,220
mesh uses they are small with before

00:24:30,440 --> 00:24:36,440
Bluetooth five which is what mesh relies

00:24:34,220 --> 00:24:39,500
on it builds on top of Bluetooth 4 you

00:24:36,440 --> 00:24:42,230
can have 31 bytes of advertising packet

00:24:39,500 --> 00:24:43,940
data and that means that the packets

00:24:42,230 --> 00:24:45,800
that get sent that they are small and it

00:24:43,940 --> 00:24:48,020
causes interesting challenges if you

00:24:45,800 --> 00:24:51,290
want to send any bigger chunks of data

00:24:48,020 --> 00:24:53,450
so there's the concept of segmentation

00:24:51,290 --> 00:24:55,610
and reassembly so if you have a message

00:24:53,450 --> 00:24:57,800
that's more than 15 bytes 15 bodies that

00:24:55,610 --> 00:25:00,350
is the biggest amount of payload that

00:24:57,800 --> 00:25:02,240
you can fit in an unscented message then

00:25:00,350 --> 00:25:05,000
you can go ahead and split up into

00:25:02,240 --> 00:25:08,860
segments and blue the mesh allows

00:25:05,000 --> 00:25:11,510
messages to be split up until 32

00:25:08,860 --> 00:25:13,160
segments the 32 comes from the fact that

00:25:11,510 --> 00:25:15,290
there there's a bit field of

00:25:13,160 --> 00:25:18,950
acknowledged segments that you keep

00:25:15,290 --> 00:25:21,110
track of and that then gives you of 384

00:25:18,950 --> 00:25:25,070
bytes of maximum maximum segment as a

00:25:21,110 --> 00:25:27,770
message payload size I was talking about

00:25:25,070 --> 00:25:29,570
the messages they're unreliable so you

00:25:27,770 --> 00:25:31,730
never get any kind of acknowledgment on

00:25:29,570 --> 00:25:34,550
this the way you can work around this is

00:25:31,730 --> 00:25:37,220
you can have a response message from the

00:25:34,550 --> 00:25:41,060
another unsegmented message from the

00:25:37,220 --> 00:25:42,320
server model a simple way to do this

00:25:41,060 --> 00:25:44,300
which doesn't require a kind of a

00:25:42,320 --> 00:25:47,120
changes on the higher layers is that if

00:25:44,300 --> 00:25:49,040
you have a payload that can fit into a

00:25:47,120 --> 00:25:51,440
non segmented message you go ahead and

00:25:49,040 --> 00:25:53,540
encode it anyway into a single segment a

00:25:51,440 --> 00:25:55,850
single segment segmented message and

00:25:53,540 --> 00:25:57,410
that way you force the receiving site to

00:25:55,850 --> 00:25:59,720
send you a segment acknowledgment that

00:25:57,410 --> 00:26:01,640
it has received the packet so this is a

00:25:59,720 --> 00:26:08,680
common trick to do if you want to have a

00:26:01,640 --> 00:26:14,450
reliable sending of a small message then

00:26:08,680 --> 00:26:16,640
about friendship so every mesh node in

00:26:14,450 --> 00:26:19,160
principle needs to be listening for

00:26:16,640 --> 00:26:21,110
message packets all the time in the mesh

00:26:19,160 --> 00:26:25,010
network and this can consume quite a lot

00:26:21,110 --> 00:26:27,140
of power so luckily there's a solution

00:26:25,010 --> 00:26:28,610
for this in the mesh specification to

00:26:27,140 --> 00:26:31,400
cover for those devices which are very

00:26:28,610 --> 00:26:33,170
limited power supply the general idea is

00:26:31,400 --> 00:26:36,200
that you pair up

00:26:33,170 --> 00:26:37,610
your low-power notes which we the ones

00:26:36,200 --> 00:26:39,170
with the limited power supply with

00:26:37,610 --> 00:26:40,240
something called friend notes friend

00:26:39,170 --> 00:26:42,980
notes are those that would have

00:26:40,240 --> 00:26:46,370
persistent power supply and the basic

00:26:42,980 --> 00:26:47,720
idea is that when you establish the

00:26:46,370 --> 00:26:51,230
friendship the low-power note says that

00:26:47,720 --> 00:26:54,800
I'm gonna wake up you know this period

00:26:51,230 --> 00:26:56,540
using this period and the friend then

00:26:54,800 --> 00:26:58,880
caches up messages for it and whenever

00:26:56,540 --> 00:27:00,530
the low-power note pulse the friend note

00:26:58,880 --> 00:27:03,910
will replay those messages to it and

00:27:00,530 --> 00:27:07,040
that way you can achieve really really

00:27:03,910 --> 00:27:09,320
small receive windows for the low-power

00:27:07,040 --> 00:27:11,630
it can wake up for just a couple of

00:27:09,320 --> 00:27:13,640
milliseconds every few days or something

00:27:11,630 --> 00:27:15,440
like that so you can really extend the

00:27:13,640 --> 00:27:17,330
battery life if you think about the the

00:27:15,440 --> 00:27:20,390
smart lightning use case I mentioned

00:27:17,330 --> 00:27:22,820
earlier this would be a perfect fit for

00:27:20,390 --> 00:27:26,120
that because your lights they will have

00:27:22,820 --> 00:27:28,160
a stable power source so they are the

00:27:26,120 --> 00:27:31,400
perfect friend notes where's your lights

00:27:28,160 --> 00:27:33,740
which is would typically have a small

00:27:31,400 --> 00:27:34,940
battery in them also the light switches

00:27:33,740 --> 00:27:36,890
they don't need to really receive

00:27:34,940 --> 00:27:38,270
messages that often they mostly they're

00:27:36,890 --> 00:27:41,720
just sending messages when you flick the

00:27:38,270 --> 00:27:43,490
switch so it's a perfect combination for

00:27:41,720 --> 00:27:46,250
the friendship you would make the lights

00:27:43,490 --> 00:27:52,160
be the friends and the switches be the

00:27:46,250 --> 00:27:56,060
low power notes so how far are we then

00:27:52,160 --> 00:27:58,070
with implementing support for this the

00:27:56,060 --> 00:27:59,300
Zephyr implementation it's it's

00:27:58,070 --> 00:28:00,830
something we were working on before the

00:27:59,300 --> 00:28:03,500
specification actually went public and

00:28:00,830 --> 00:28:05,810
we sent it for up-stream inclusion as

00:28:03,500 --> 00:28:09,290
soon as the image specification was

00:28:05,810 --> 00:28:13,280
released in in July and it's part of the

00:28:09,290 --> 00:28:14,810
latest zephyr 1.9 release it is all the

00:28:13,280 --> 00:28:16,220
features that are mandatory in the mid

00:28:14,810 --> 00:28:17,510
specification there are a couple of

00:28:16,220 --> 00:28:20,840
optional ones that we are still working

00:28:17,510 --> 00:28:23,540
on we've been testing that against tens

00:28:20,840 --> 00:28:25,930
of other implementations both before the

00:28:23,540 --> 00:28:29,750
spec went public as well as after it and

00:28:25,930 --> 00:28:33,070
actually another project minded project

00:28:29,750 --> 00:28:35,030
ported it over to them as well and

00:28:33,070 --> 00:28:37,340
they've been doing fixes there and

00:28:35,030 --> 00:28:40,640
sending back over to the effort so we've

00:28:37,340 --> 00:28:42,650
benefited from from that quite a lot we

00:28:40,640 --> 00:28:45,380
also have demos of the implementation on

00:28:42,650 --> 00:28:46,520
various boards we have a demo here at

00:28:45,380 --> 00:28:47,780
the

00:28:46,520 --> 00:28:50,300
friends if you come to this effort booth

00:28:47,780 --> 00:28:52,580
we have micro bit devices they're

00:28:50,300 --> 00:28:57,080
showing the basic functionality of

00:28:52,580 --> 00:28:59,000
Zephyr Bluetooth mesh and in particular

00:28:57,080 --> 00:29:00,650
because of the micro bit the BBC micro

00:28:59,000 --> 00:29:02,300
bit devices they only have 16 kilobytes

00:29:00,650 --> 00:29:04,930
of ROM that has forced us to really

00:29:02,300 --> 00:29:07,670
optimize the the memory footprint of

00:29:04,930 --> 00:29:09,200
Zephyr mesh so the simplest

00:29:07,670 --> 00:29:11,450
configuration that you can have with it

00:29:09,200 --> 00:29:13,280
it's about 12 kilobytes of RAM that it

00:29:11,450 --> 00:29:17,600
fits the entire Bluetooth stack the OS

00:29:13,280 --> 00:29:19,820
and the mesh support there on the Linux

00:29:17,600 --> 00:29:21,020
side we are a little bit behind but we

00:29:19,820 --> 00:29:23,450
are working on it

00:29:21,020 --> 00:29:26,240
the latest bluesy release already

00:29:23,450 --> 00:29:28,940
contains initial pieces of mesh support

00:29:26,240 --> 00:29:31,540
in terms of a mesh control tool this one

00:29:28,940 --> 00:29:34,400
however only implements they got

00:29:31,540 --> 00:29:37,010
functionality it has a got client with

00:29:34,400 --> 00:29:38,990
which you can configure other nodes and

00:29:37,010 --> 00:29:41,540
it can act as a got permission or the

00:29:38,990 --> 00:29:43,400
provisioning over got and we're hoping

00:29:41,540 --> 00:29:46,160
probably you're going to see the patches

00:29:43,400 --> 00:29:47,900
still on this year side but we're

00:29:46,160 --> 00:29:50,330
working on implementing a proper

00:29:47,900 --> 00:29:51,620
solution for the native mesh where the

00:29:50,330 --> 00:29:53,000
linux kernel will be responsible

00:29:51,620 --> 00:29:55,070
basically for the advertising and

00:29:53,000 --> 00:29:56,540
scanning and user space will be

00:29:55,070 --> 00:29:59,060
responsible for the rest we're gonna

00:29:56,540 --> 00:30:04,550
have a new demon they're called mesh d

00:29:59,060 --> 00:30:07,730
that then takes care of this we're

00:30:04,550 --> 00:30:10,040
working on doing some optimizations that

00:30:07,730 --> 00:30:12,140
standard the standard host controller

00:30:10,040 --> 00:30:15,890
interface of booted doesn't allow

00:30:12,140 --> 00:30:18,500
particularly for friendship using

00:30:15,890 --> 00:30:19,850
standard HCI from bluetooth 5 you cannot

00:30:18,500 --> 00:30:22,340
actually get the smallest possible

00:30:19,850 --> 00:30:24,770
timings that the friendship negotiation

00:30:22,340 --> 00:30:26,090
would allow for so we are going to be

00:30:24,770 --> 00:30:28,250
implementing these extensions in this

00:30:26,090 --> 00:30:30,440
effort controller to be able to do this

00:30:28,250 --> 00:30:32,270
and we're going to have support for them

00:30:30,440 --> 00:30:37,400
both in this effort bluetooth host as

00:30:32,270 --> 00:30:38,720
well as the bluesy on linux side and i'm

00:30:37,400 --> 00:30:40,130
currently quite busy implementing the

00:30:38,720 --> 00:30:42,920
friend support that's one of the missing

00:30:40,130 --> 00:30:44,420
pieces in zephyr so hopefully for the

00:30:42,920 --> 00:30:47,810
next separate release we're gonna have

00:30:44,420 --> 00:30:49,730
friend support and then we also started

00:30:47,810 --> 00:30:52,280
to look at the model space model

00:30:49,730 --> 00:30:54,260
specification to see if there's anything

00:30:52,280 --> 00:30:57,350
interesting there that could be

00:30:54,260 --> 00:30:59,330
implemented as part of a zephyr most of

00:30:57,350 --> 00:31:02,260
them I would expect to be on a per

00:30:59,330 --> 00:31:02,260
application basis

00:31:02,330 --> 00:31:07,460
and we also trying to come up with

00:31:04,159 --> 00:31:09,200
various demos to show off the mesh the

00:31:07,460 --> 00:31:10,340
one thing that we have here is the one

00:31:09,200 --> 00:31:13,940
using the micro bit so if you're

00:31:10,340 --> 00:31:19,000
interested just come to the Zephyr booth

00:31:13,940 --> 00:31:23,390
it's there across from the reception and

00:31:19,000 --> 00:31:28,419
with that I'm actually done are there

00:31:23,390 --> 00:31:28,419
any questions yes

00:31:36,630 --> 00:31:40,740
okay so the question was is possible to

00:31:38,430 --> 00:31:43,830
send custom data to nose yes

00:31:40,740 --> 00:31:47,580
so we expose a completely generic model

00:31:43,830 --> 00:31:49,260
mesh model interface and you can do any

00:31:47,580 --> 00:31:51,860
kind of custom model that you want with

00:31:49,260 --> 00:31:58,220
that to send anything receive anything

00:31:51,860 --> 00:31:58,220
yes yeah

00:32:02,330 --> 00:32:07,140
no they are kind of leaf leaf nodes so

00:32:05,910 --> 00:32:09,090
no they cannot

00:32:07,140 --> 00:32:11,430
so the question was about legacy legacy

00:32:09,090 --> 00:32:13,140
devices which talked to God so they can

00:32:11,430 --> 00:32:15,650
only send or receive but they cannot

00:32:13,140 --> 00:32:18,920
rely any any information in the network

00:32:15,650 --> 00:32:18,920
somewhere yes

00:32:19,190 --> 00:32:29,070
multiple multiple provisioners so

00:32:25,940 --> 00:32:30,720
there's currently I first I know there's

00:32:29,070 --> 00:32:32,850
there's no public specification for this

00:32:30,720 --> 00:32:35,430
how multiple provisioners would be able

00:32:32,850 --> 00:32:37,320
to share knowledge of the address space

00:32:35,430 --> 00:32:40,860
and what addresses have been signed what

00:32:37,320 --> 00:32:42,870
keys have been assigned so at the moment

00:32:40,860 --> 00:32:44,790
if you want to do it you need to have

00:32:42,870 --> 00:32:47,370
some custom solution for for it I know

00:32:44,790 --> 00:32:50,340
that there's work in progress to come

00:32:47,370 --> 00:32:51,990
out with a standard format for sharing

00:32:50,340 --> 00:32:53,790
provisioning information and that's but

00:32:51,990 --> 00:32:55,500
you can have multiple parishioners to do

00:32:53,790 --> 00:32:56,940
that so it's it's technically it's

00:32:55,500 --> 00:32:59,600
perfectly doable right now but there's

00:32:56,940 --> 00:33:07,740
no open standard for that at the moment

00:32:59,600 --> 00:33:09,330
yes well the provisioner it's only

00:33:07,740 --> 00:33:11,430
needed to be around the provision

00:33:09,330 --> 00:33:13,290
initially the devices after that it can

00:33:11,430 --> 00:33:16,830
go away and the devices will keep

00:33:13,290 --> 00:33:18,900
operating in the mesh network until you

00:33:16,830 --> 00:33:20,460
need to reconfigure something or hand

00:33:18,900 --> 00:33:23,430
out new keys it's only that many we need

00:33:20,460 --> 00:33:28,890
the provisioner did that ask you the

00:33:23,430 --> 00:33:30,690
question no no even need that version so

00:33:28,890 --> 00:33:31,980
in that sense it might be good to have

00:33:30,690 --> 00:33:33,180
some redundancy to share the

00:33:31,980 --> 00:33:38,210
provisioning information with other

00:33:33,180 --> 00:33:38,210
potential provisioners yes

00:33:41,929 --> 00:33:47,580
so there's I mean the specification is

00:33:45,480 --> 00:33:49,110
public you can find it first of all for

00:33:47,580 --> 00:33:50,279
for the emission amylose specification

00:33:49,110 --> 00:33:54,929
you can find it on Bluetooth the torque

00:33:50,279 --> 00:33:56,669
it has got things concepts like time

00:33:54,929 --> 00:34:00,090
synchronization across dimension network

00:33:56,669 --> 00:34:02,700
it has a concept of scenes where you can

00:34:00,090 --> 00:34:04,529
kind of save the current state of like

00:34:02,700 --> 00:34:05,820
how bright the lights are at the moment

00:34:04,529 --> 00:34:08,280
and then you can restore it later

00:34:05,820 --> 00:34:10,379
all the smart lightning models are part

00:34:08,280 --> 00:34:12,540
of the image model specification I think

00:34:10,379 --> 00:34:14,099
it does maybe 20 different models or so

00:34:12,540 --> 00:34:24,379
at the moment and they're gonna be

00:34:14,099 --> 00:34:24,379
creating more of them yes sorry

00:34:24,899 --> 00:34:30,859
the no not really path discovery there's

00:34:28,200 --> 00:34:33,240
a way to discover how many hopes away

00:34:30,859 --> 00:34:36,690
those are from each other that's done

00:34:33,240 --> 00:34:38,579
using the heartbeat where the message

00:34:36,690 --> 00:34:40,169
contains the initial TTL value and then

00:34:38,579 --> 00:34:41,609
you compare that with the received TTL

00:34:40,169 --> 00:34:43,879
and then you know how far it is but the

00:34:41,609 --> 00:34:46,770
actual path it took there's no kind of

00:34:43,879 --> 00:34:48,300
mark made on on the packets as they go

00:34:46,770 --> 00:34:50,040
through the network so no you would have

00:34:48,300 --> 00:34:54,859
to do that on gives you some higher

00:34:50,040 --> 00:34:54,859
level protocol if you want that yep

00:35:08,030 --> 00:35:12,660
so the question is how does how doesn't

00:35:10,470 --> 00:35:14,730
how isn't there too much back-and-forth

00:35:12,660 --> 00:35:16,950
bouncing of messages or something like

00:35:14,730 --> 00:35:19,530
that well the the replay protection list

00:35:16,950 --> 00:35:21,330
is one way that prevents it the time to

00:35:19,530 --> 00:35:23,970
leave is another way so it eventually

00:35:21,330 --> 00:35:27,570
dies out but what happens if you have

00:35:23,970 --> 00:35:32,460
two relays broadcasting or relay in the

00:35:27,570 --> 00:35:33,810
same packet twice when it really realize

00:35:32,460 --> 00:35:36,300
it it's it's still the same packet with

00:35:33,810 --> 00:35:38,850
the same sequence number so when another

00:35:36,300 --> 00:35:40,710
node sees those both relayed packets

00:35:38,850 --> 00:35:42,450
they will see the same sequence number

00:35:40,710 --> 00:35:44,790
in them and the way that the replay

00:35:42,450 --> 00:35:45,870
protection list works is that if you see

00:35:44,790 --> 00:35:48,060
the same sequence number that you've

00:35:45,870 --> 00:35:49,410
seen before or you see an older sequence

00:35:48,060 --> 00:35:52,110
number you discard the message you don't

00:35:49,410 --> 00:35:56,450
process it so that that's basically what

00:35:52,110 --> 00:35:56,450
happens when the same message is around

00:35:57,230 --> 00:36:00,230
yep

00:36:04,979 --> 00:36:13,299
it will show that there's a feature

00:36:09,549 --> 00:36:15,309
called secure network beacons in the

00:36:13,299 --> 00:36:17,769
mesh specification that most nodes will

00:36:15,309 --> 00:36:20,349
broadcast periodically and that beacon

00:36:17,769 --> 00:36:23,049
actually contains the current index

00:36:20,349 --> 00:36:25,899
number so if you've lost sync with the

00:36:23,049 --> 00:36:27,819
current IB index you listen for those

00:36:25,899 --> 00:36:30,219
beacons and you can have a guess at what

00:36:27,819 --> 00:36:35,099
the current index number is IB index

00:36:30,219 --> 00:36:35,099
number is like that yes

00:36:40,000 --> 00:36:50,420
well it uses packet flooding you mean

00:36:43,520 --> 00:36:51,680
somebody is saturating the well the

00:36:50,420 --> 00:36:53,270
Reaper protection list is supposed to

00:36:51,680 --> 00:36:55,280
protect against that I mean since

00:36:53,270 --> 00:36:57,560
everything has the message integrity

00:36:55,280 --> 00:36:59,210
check codes and you've got the Reaper

00:36:57,560 --> 00:37:01,190
protection list you can't just send

00:36:59,210 --> 00:37:02,600
random data it will be discarded

00:37:01,190 --> 00:37:04,550
immediately because it will not match to

00:37:02,600 --> 00:37:06,350
any of the keys in the network and so on

00:37:04,550 --> 00:37:08,150
and then and you cannot replay the same

00:37:06,350 --> 00:37:10,550
packet again either because of the

00:37:08,150 --> 00:37:19,700
secret seekers number and the replay

00:37:10,550 --> 00:37:21,380
protection list yeah yeah yeah that's

00:37:19,700 --> 00:37:24,110
true so if you have a if you have a

00:37:21,380 --> 00:37:25,970
rogue node that has ownership of the

00:37:24,110 --> 00:37:29,120
network key it can do bad things to the

00:37:25,970 --> 00:37:32,000
network it's limited it's not as bad as

00:37:29,120 --> 00:37:33,770
it's having all of the application keys

00:37:32,000 --> 00:37:38,570
I mean can do everything but you

00:37:33,770 --> 00:37:39,890
basically you need to do you can have

00:37:38,570 --> 00:37:42,110
multiple network keys first of all you

00:37:39,890 --> 00:37:43,970
can do a little bit distribution of what

00:37:42,110 --> 00:37:46,880
functionalities are available for what

00:37:43,970 --> 00:37:48,830
notes so you can limit the the impact if

00:37:46,880 --> 00:37:50,540
a node gets compromised and it's

00:37:48,830 --> 00:37:53,150
important also to do the provisioning

00:37:50,540 --> 00:37:54,650
procedure in a secure manual manner that

00:37:53,150 --> 00:38:01,930
you don't get many in the middle attacks

00:37:54,650 --> 00:38:04,310
there at that point yes yeah so every

00:38:01,930 --> 00:38:05,930
mesh packet goes out on all three

00:38:04,310 --> 00:38:07,940
advertising channels there's some work

00:38:05,930 --> 00:38:09,710
in progress to potentially do some

00:38:07,940 --> 00:38:11,150
improvements on this but at the moment

00:38:09,710 --> 00:38:12,380
you're scanning on all 300 thousand

00:38:11,150 --> 00:38:15,040
channels and you're sending each packet

00:38:12,380 --> 00:38:20,590
on all three advertising channels

00:38:15,040 --> 00:38:20,590
they're still yes

00:38:33,110 --> 00:38:39,920
it's a standard I'm not sure what you

00:38:34,760 --> 00:38:42,800
mean there's a standard Bluetooth

00:38:39,920 --> 00:38:45,200
specification that was released as a

00:38:42,800 --> 00:38:48,040
Bluetooth standard in July yeah that's

00:38:45,200 --> 00:38:53,560
that's what this presentation is about

00:38:48,040 --> 00:38:53,560
that's okay yes

00:38:56,080 --> 00:39:01,790
you don't need controller updates you

00:38:58,460 --> 00:39:03,140
need the host OS updates to get there

00:39:01,790 --> 00:39:06,110
though the whole stack updates to get

00:39:03,140 --> 00:39:08,630
the native mesh support for for Linux

00:39:06,110 --> 00:39:11,360
for iOS for Android and the distance the

00:39:08,630 --> 00:39:22,570
actual Bluetooth controller indoors that

00:39:11,360 --> 00:39:22,570
doesn't really need updates yep yep

00:39:32,900 --> 00:39:39,780
so the question was about legacy devices

00:39:35,970 --> 00:39:41,000
well why it's using God well first of

00:39:39,780 --> 00:39:43,740
all got this an API that's available

00:39:41,000 --> 00:39:47,160
with the existing Oasis so that's why

00:39:43,740 --> 00:39:51,180
God is the chosen legacy support method

00:39:47,160 --> 00:39:54,150
and you don't get to find enough

00:39:51,180 --> 00:39:55,590
granularity access to the scanning and

00:39:54,150 --> 00:39:57,600
advertising to be able to do native mesh

00:39:55,590 --> 00:40:00,750
you need some updates from the host for

00:39:57,600 --> 00:40:06,470
that all right we're starting to be out

00:40:00,750 --> 00:40:06,470
of time here but yes they were still

00:40:10,250 --> 00:40:13,250
yeah

00:40:15,170 --> 00:40:20,450
you're asking can mistake advantage of

00:40:17,359 --> 00:40:21,859
to make fire or so that's that's a

00:40:20,450 --> 00:40:24,349
chronic connection-oriented thing as his

00:40:21,859 --> 00:40:26,180
mesh uses advertising and scanning it

00:40:24,349 --> 00:40:27,769
cannot take actually advantage of that

00:40:26,180 --> 00:40:29,329
it will be able to take advantage of

00:40:27,769 --> 00:40:30,410
advertising extensions where you get

00:40:29,329 --> 00:40:32,299
more pale about the current made

00:40:30,410 --> 00:40:35,359
specification it just uses Bluetooth 4.0

00:40:32,299 --> 00:40:36,710
so it doesn't doesn't use that I think

00:40:35,359 --> 00:40:38,660
I'm gonna cut the questions there if

00:40:36,710 --> 00:40:40,489
you're interested to ask more questions

00:40:38,660 --> 00:40:42,890
just come to me I'll be happy to answer

00:40:40,489 --> 00:40:44,660
them but we're out of time right now but

00:40:42,890 --> 00:40:48,560
thank you for listening

00:40:44,660 --> 00:40:48,560

YouTube URL: https://www.youtube.com/watch?v=IC5htRbGElk


