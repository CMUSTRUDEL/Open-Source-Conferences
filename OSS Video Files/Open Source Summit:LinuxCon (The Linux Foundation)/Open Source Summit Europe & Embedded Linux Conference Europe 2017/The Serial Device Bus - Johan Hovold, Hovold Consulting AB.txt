Title: The Serial Device Bus - Johan Hovold, Hovold Consulting AB
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	The Serial Device Bus - Johan Hovold, Hovold Consulting AB

UARTs and RS-232 have been around since the 1960s, and despite the advent of technologies like USB and PCIe, it seems UART-attached devices aren't going away anytime soon. In embedded systems, UARTs are a commonly used peripheral interface (e.g. for Bluetooth, NFC, and GPS) even if the kernel infrastructure for dealing with such devices has been both limited in what it can provide (e.g. in terms of power management) and cumbersome to use (e.g. requiring user-space daemons).

This presentation will give an introduction to the recently merged Serial Device Bus, which aims to overcome some of these limitations by making UART-attached devices fit better into the Linux device model. After providing some historical background, the design and interfaces of the new bus will be reviewed, and some known limitations and possibilities for future enhancements will be discussed.

About Johan Hovold
Johan Hovold has been working with embedded Linux since 2002, and for the last ten years as a consultant. He recently spent two years on Google's Project Ara as kernel developer and tech lead for Greybus core. Johan is the maintainer of the kernel's USB Serial and Greybus subsystems.
Captions: 
	00:00:00,060 --> 00:00:13,349
let's start my name is you 100 volt and

00:00:10,860 --> 00:00:16,230
I work as a consultant during current

00:00:13,349 --> 00:00:18,210
work primarily with embedded systems

00:00:16,230 --> 00:00:21,090
I am the maintainer of the kernels use

00:00:18,210 --> 00:00:23,720
the serial system which is why I take an

00:00:21,090 --> 00:00:25,680
interest in the topic of today's talk I

00:00:23,720 --> 00:00:27,660
always been doing great buses together

00:00:25,680 --> 00:00:28,939
with Greg Hartmann great buzz for those

00:00:27,660 --> 00:00:31,199
who haven't heard about it it's the

00:00:28,939 --> 00:00:33,660
application layer for unit profit I came

00:00:31,199 --> 00:00:36,719
out of Google's Project ara we attempt

00:00:33,660 --> 00:00:38,730
to build a modular mobile phone and

00:00:36,719 --> 00:00:41,730
today I will talk about the serial

00:00:38,730 --> 00:00:44,700
device bus which executive summary being

00:00:41,730 --> 00:00:48,079
aims at making serial Attached devices

00:00:44,700 --> 00:00:51,030
fit better into the Lumix device model

00:00:48,079 --> 00:00:52,829
so you are - nurse truth - duze been

00:00:51,030 --> 00:00:54,570
around for a long time now it's at least

00:00:52,829 --> 00:00:57,149
since the 1960s and a few years before

00:00:54,570 --> 00:01:00,020
that and it's still a common interface

00:00:57,149 --> 00:01:03,840
but especially in an embedded system for

00:01:00,020 --> 00:01:07,680
Bluetooth NFC radio GPS devices and so

00:01:03,840 --> 00:01:09,479
on and the kernel provides a abstraction

00:01:07,680 --> 00:01:11,400
for the serial connection itself but it

00:01:09,479 --> 00:01:13,560
device is more than just communication

00:01:11,400 --> 00:01:15,810
interface you have associated resources

00:01:13,560 --> 00:01:18,600
like GPIO and interrupts and so on

00:01:15,810 --> 00:01:19,950
that you need to be able to manage not

00:01:18,600 --> 00:01:22,979
least for our power management purposes

00:01:19,950 --> 00:01:24,869
and unless you want to influence your

00:01:22,979 --> 00:01:27,570
driver entirely in userspace the kernel

00:01:24,869 --> 00:01:29,579
support so far has been more less

00:01:27,570 --> 00:01:31,500
limited to so-called line discipline

00:01:29,579 --> 00:01:33,509
drivers will in quotes because they're

00:01:31,500 --> 00:01:35,939
not really drivers in the linux driver

00:01:33,509 --> 00:01:37,560
model sense and they had two drawback

00:01:35,939 --> 00:01:41,280
that they must be configured and

00:01:37,560 --> 00:01:43,530
enlisted i initialize my user space so

00:01:41,280 --> 00:01:45,750
brief outline of the talk I'll start

00:01:43,530 --> 00:01:48,000
with giving a high-level introduction or

00:01:45,750 --> 00:01:49,950
overview of the tty layer and discuss

00:01:48,000 --> 00:01:52,020
those two options that have previously

00:01:49,950 --> 00:01:53,790
been available to us to write your

00:01:52,020 --> 00:01:56,009
driver and tiling user space using line

00:01:53,790 --> 00:01:57,600
easement drivers discuss some of the

00:01:56,009 --> 00:01:59,969
drawbacks and problems associated with

00:01:57,600 --> 00:02:01,680
those before introduced in cearÃ¡ dev

00:01:59,969 --> 00:02:04,350
talk a bit about how it's been

00:02:01,680 --> 00:02:08,700
implemented a driver interface is that

00:02:04,350 --> 00:02:12,360
anyone wanting to draw implement a city

00:02:08,700 --> 00:02:12,930
driver can use and after I'll talk some

00:02:12,360 --> 00:02:14,849
of the

00:02:12,930 --> 00:02:19,829
limitations that Syria has today and

00:02:14,849 --> 00:02:23,430
point out some issues for future work so

00:02:19,829 --> 00:02:25,819
the tty layer ultimately it provides

00:02:23,430 --> 00:02:27,989
this character device to use the space

00:02:25,819 --> 00:02:30,389
abstracting beyond the latency report

00:02:27,989 --> 00:02:32,639
Hardware beneath the character device we

00:02:30,389 --> 00:02:34,739
have the line disciplines which is an

00:02:32,639 --> 00:02:37,170
entity abstraction which deals with any

00:02:34,739 --> 00:02:39,450
kind of IR processing this is where at

00:02:37,170 --> 00:02:42,000
the canonical input mode its line

00:02:39,450 --> 00:02:44,099
editing facilities is implemented and

00:02:42,000 --> 00:02:47,790
use with echoing error handling parity

00:02:44,099 --> 00:02:50,030
framing but also things like emitting

00:02:47,790 --> 00:02:52,200
signals on very simple conditions

00:02:50,030 --> 00:02:55,560
beneath the line discipline we have the

00:02:52,200 --> 00:02:57,120
TTY ports layer which is a where the

00:02:55,560 --> 00:02:59,549
input buffering currently is implemented

00:02:57,120 --> 00:03:02,069
in the kernel and this is also a kind of

00:02:59,549 --> 00:03:04,439
abstraction layer for implementing

00:03:02,069 --> 00:03:06,389
common posting semantics for example an

00:03:04,439 --> 00:03:11,010
opening a port you need to raise the DTR

00:03:06,389 --> 00:03:12,840
yes lines and so on and beneath it all

00:03:11,010 --> 00:03:14,069
is the actual TTY driver which know how

00:03:12,840 --> 00:03:16,979
to speak to the actual hardware in

00:03:14,069 --> 00:03:19,590
question yeah in this picture I've

00:03:16,979 --> 00:03:21,510
divided is easy white driver into a TTY

00:03:19,590 --> 00:03:22,680
driver core bit and a lower-level driver

00:03:21,510 --> 00:03:26,669
because this is usually how its

00:03:22,680 --> 00:03:30,090
implemented the serial core would be the

00:03:26,669 --> 00:03:32,519
tty driver or USB serial core whereas an

00:03:30,090 --> 00:03:33,900
ohm up you our driver or the ftdi driver

00:03:32,519 --> 00:03:38,310
would be an example of a low-level

00:03:33,900 --> 00:03:40,530
driver and as I said this is a bit of an

00:03:38,310 --> 00:03:43,229
simplification you can reality there are

00:03:40,530 --> 00:03:45,540
some the line discipline actually calls

00:03:43,229 --> 00:03:51,019
down directly to the tty drivers as well

00:03:45,540 --> 00:03:53,699
but for our purposes this is sufficient

00:03:51,019 --> 00:03:55,500
so the use of space drivers you could

00:03:53,699 --> 00:03:57,229
implement your driver in China user

00:03:55,500 --> 00:03:59,250
space using the default line discipline

00:03:57,229 --> 00:04:00,930
this means obviously that your

00:03:59,250 --> 00:04:02,489
description of your system your hardware

00:04:00,930 --> 00:04:04,290
needs to live in user space as well the

00:04:02,489 --> 00:04:07,409
application is now which poor to open

00:04:04,290 --> 00:04:11,340
what line speed to use and if you have

00:04:07,409 --> 00:04:15,000
for example a simple reset line enabled

00:04:11,340 --> 00:04:18,180
switch you could use still do that in in

00:04:15,000 --> 00:04:20,930
user space because GPIO provides an

00:04:18,180 --> 00:04:23,070
interface for for user space to access

00:04:20,930 --> 00:04:24,750
but when you get to things like

00:04:23,070 --> 00:04:25,380
regulators and clocks they don't have a

00:04:24,750 --> 00:04:27,870
representation

00:04:25,380 --> 00:04:30,500
use a space there then you won't be able

00:04:27,870 --> 00:04:32,820
to trim for major driver in user space

00:04:30,500 --> 00:04:34,830
obviously you cannot use the Colonel's

00:04:32,820 --> 00:04:36,150
power management facilities you need to

00:04:34,830 --> 00:04:37,950
implement your own you need to deal with

00:04:36,150 --> 00:04:41,910
things like system suspend notifications

00:04:37,950 --> 00:04:44,580
which arise from from user space to

00:04:41,910 --> 00:04:47,700
start with wake up interrupt is another

00:04:44,580 --> 00:04:49,380
issue because you cannot specify an

00:04:47,700 --> 00:04:52,560
interrupted system wakeup interrupt

00:04:49,380 --> 00:04:54,030
through GPIO currently and obviously you

00:04:52,560 --> 00:04:59,760
can use the kernels infrastructure for

00:04:54,030 --> 00:05:01,410
firmware management so and for those

00:04:59,760 --> 00:05:02,700
reasons and also because you usually

00:05:01,410 --> 00:05:04,170
want to interact with other current

00:05:02,700 --> 00:05:06,150
subsystems you need to have your driver

00:05:04,170 --> 00:05:08,490
living in uses in kernel space and

00:05:06,150 --> 00:05:11,850
that's where the line is between drivers

00:05:08,490 --> 00:05:15,840
coming these services could be Bluetooth

00:05:11,850 --> 00:05:17,670
subsystem input NFC and so on and and

00:05:15,840 --> 00:05:19,380
the Landers have been in usually then

00:05:17,670 --> 00:05:22,170
registers further class devices which is

00:05:19,380 --> 00:05:23,430
the actual interface with which use the

00:05:22,170 --> 00:05:26,190
space will later use to access to

00:05:23,430 --> 00:05:28,680
hardware and this means that you need a

00:05:26,190 --> 00:05:31,410
user space daemon to initialize support

00:05:28,680 --> 00:05:33,840
switch the line discipline and to

00:05:31,410 --> 00:05:35,520
actually keep the port open because it's

00:05:33,840 --> 00:05:37,950
only wild line is when it's opened as

00:05:35,520 --> 00:05:41,910
these devices are accessible so we have

00:05:37,950 --> 00:05:43,590
these commonly known demons like LD

00:05:41,910 --> 00:05:45,930
attached input section HCI attached

00:05:43,590 --> 00:05:49,740
which is being replaced now by booting

00:05:45,930 --> 00:05:50,910
attach and comparisons using switch

00:05:49,740 --> 00:05:52,680
drivers this means that the current

00:05:50,910 --> 00:05:53,970
firmware infrastructure is available but

00:05:52,680 --> 00:05:55,830
there still are issues with power

00:05:53,970 --> 00:05:59,280
management and other resources like

00:05:55,830 --> 00:06:03,900
clocks and regulators so a quick example

00:05:59,280 --> 00:06:07,080
here Bluetooth this is essentially what

00:06:03,900 --> 00:06:09,500
the ACI attached demon needs to do open

00:06:07,080 --> 00:06:12,030
report configure the baud rate so on

00:06:09,500 --> 00:06:13,440
switch the line discipline and in the

00:06:12,030 --> 00:06:15,960
Bluetooth case you also need to specify

00:06:13,440 --> 00:06:17,430
which Bluetooth protocol to use and it's

00:06:15,960 --> 00:06:19,560
only when these last ir control is

00:06:17,430 --> 00:06:22,370
executed that the actual hei device is

00:06:19,560 --> 00:06:25,830
becomes available for user space to use

00:06:22,370 --> 00:06:28,650
so graphically we have something like

00:06:25,830 --> 00:06:31,350
this when the system is booted we have

00:06:28,650 --> 00:06:33,330
the lower level driver being bound to

00:06:31,350 --> 00:06:35,430
its device typically described in hard

00:06:33,330 --> 00:06:37,229
in firmware so the character device is

00:06:35,430 --> 00:06:38,559
available to use the space you need to

00:06:37,229 --> 00:06:43,629
first run your

00:06:38,559 --> 00:06:45,219
- demon application one here before the

00:06:43,629 --> 00:06:47,499
line is going switched and the class

00:06:45,219 --> 00:06:49,959
device becomes available for for example

00:06:47,499 --> 00:06:54,159
a Shia conflict to actually start up the

00:06:49,959 --> 00:06:55,989
the Bluetooth device so what's the

00:06:54,159 --> 00:06:57,129
problem here first of all the

00:06:55,989 --> 00:06:58,719
description of what's going on

00:06:57,129 --> 00:07:01,119
description of your hardware

00:06:58,719 --> 00:07:03,369
what is connected where and how lives in

00:07:01,119 --> 00:07:05,679
user space running to be encoded in

00:07:03,369 --> 00:07:08,469
firmer firmware being than typically

00:07:05,679 --> 00:07:10,239
device tree or a CPI and this means that

00:07:08,469 --> 00:07:12,189
you don't get any automatic discovery we

00:07:10,239 --> 00:07:13,779
need to launch these user space demons

00:07:12,189 --> 00:07:17,319
before we can actually access the

00:07:13,779 --> 00:07:18,759
Bluetooth device and because the your

00:07:17,319 --> 00:07:20,169
detach device doesn't have a firmware

00:07:18,759 --> 00:07:22,719
description we have a problem with

00:07:20,169 --> 00:07:26,469
describing and looking up these other

00:07:22,719 --> 00:07:29,439
associated resources GPIO a interrupts

00:07:26,469 --> 00:07:32,559
could be for reset wake up purposes ping

00:07:29,439 --> 00:07:34,659
control and so on and obviously this is

00:07:32,559 --> 00:07:38,649
a problem for power management we needs

00:07:34,659 --> 00:07:41,319
to be able to control such resources and

00:07:38,649 --> 00:07:43,959
a further issue here is that the port is

00:07:41,319 --> 00:07:46,089
always kept open so depending on how the

00:07:43,959 --> 00:07:48,989
underlying it sees where driver has been

00:07:46,089 --> 00:07:51,309
implemented this may prevent the

00:07:48,989 --> 00:07:54,069
imported via serial device from going

00:07:51,309 --> 00:07:56,349
into runtime suspended firmware loading

00:07:54,069 --> 00:07:58,719
is available but firmware loading

00:07:56,349 --> 00:08:00,159
typically involves toggling a reset line

00:07:58,719 --> 00:08:01,569
or something like that which then also

00:08:00,159 --> 00:08:06,039
depends on this fact that we cannot

00:08:01,569 --> 00:08:09,279
access CPI rose so that's the background

00:08:06,039 --> 00:08:13,929
and that's why the part of the problem

00:08:09,279 --> 00:08:15,939
that sort of is helping us solve so sir

00:08:13,929 --> 00:08:19,179
Dave is the new bus was implemented by

00:08:15,939 --> 00:08:21,849
repairing of Lenora and it's a generic

00:08:19,179 --> 00:08:23,589
bus figured attached devices I think the

00:08:21,849 --> 00:08:26,049
immediate aim here was to replace the TI

00:08:23,589 --> 00:08:28,959
shared transport driver and it's found a

00:08:26,049 --> 00:08:32,709
specific you I am demon but it's also

00:08:28,959 --> 00:08:34,990
based on earlier efforts typically

00:08:32,709 --> 00:08:39,809
driven by power management concerns

00:08:34,990 --> 00:08:42,429
there's been was an example of a GPS

00:08:39,809 --> 00:08:43,539
devices which needed to be power on and

00:08:42,429 --> 00:08:45,429
you didn't want to have it powered on

00:08:43,539 --> 00:08:48,370
unless the GPS daemon was running and

00:08:45,429 --> 00:08:50,740
the port was open typically those

00:08:48,370 --> 00:08:52,900
efforts aimed at adding this

00:08:50,740 --> 00:08:54,460
the Sierra core layer in the kernel

00:08:52,900 --> 00:08:57,490
rather than at the TT whiteboard layer

00:08:54,460 --> 00:08:59,740
so that's part of why that those efforts

00:08:57,490 --> 00:09:04,060
never got anywhere until Rob and others

00:08:59,740 --> 00:09:05,620
picked up the thread and the bus itself

00:09:04,060 --> 00:09:08,830
was mercy 411 but there were some

00:09:05,620 --> 00:09:13,810
initial problems with how it looked into

00:09:08,830 --> 00:09:15,520
the tty layer lifetime issues that so we

00:09:13,810 --> 00:09:16,930
needed to doubt that connection needed

00:09:15,520 --> 00:09:23,530
to be reverted and it was enabled only

00:09:16,930 --> 00:09:27,430
for serial core in 412 so CF introduces

00:09:23,530 --> 00:09:30,250
a new bus type its name serial not sir

00:09:27,430 --> 00:09:32,830
dev and the concepts of series of

00:09:30,250 --> 00:09:34,660
controllers and sedative devices and the

00:09:32,830 --> 00:09:37,450
serial devices also known as clients or

00:09:34,660 --> 00:09:39,580
slaves and it's basically because

00:09:37,450 --> 00:09:41,170
devices is such an overloaded term it

00:09:39,580 --> 00:09:42,640
may sometimes be more clear to refer to

00:09:41,170 --> 00:09:44,350
this as a client device of slave device

00:09:42,640 --> 00:09:47,530
and I will be going back and forth

00:09:44,350 --> 00:09:50,710
between these three as well so just be

00:09:47,530 --> 00:09:53,260
aware of that and there is only one to

00:09:50,710 --> 00:09:54,460
the white board set of controller

00:09:53,260 --> 00:09:57,580
implemented in the current today and

00:09:54,460 --> 00:09:59,560
it's the tty port Saratov controller so

00:09:57,580 --> 00:10:03,190
that means that sometimes we wrongly

00:09:59,560 --> 00:10:05,650
identify it with Saratov itself the this

00:10:03,190 --> 00:10:08,920
controller works as follows when so when

00:10:05,650 --> 00:10:11,370
a TTY driver is registering its ports if

00:10:08,920 --> 00:10:14,110
there are any clients defined then a

00:10:11,370 --> 00:10:18,700
serial control will register instead of

00:10:14,110 --> 00:10:20,080
the typical character device and the

00:10:18,700 --> 00:10:21,580
clients that done described by firmware

00:10:20,080 --> 00:10:24,850
they are currently defined by device

00:10:21,580 --> 00:10:28,720
tree but in 4.15 we will have a CPI

00:10:24,850 --> 00:10:31,630
support as well so if we return to the

00:10:28,720 --> 00:10:34,660
example with Bluetooth we have something

00:10:31,630 --> 00:10:36,580
like this now as before when the system

00:10:34,660 --> 00:10:39,730
starts we go out of parse our device

00:10:36,580 --> 00:10:42,340
tree we find that we have a serial port

00:10:39,730 --> 00:10:45,100
described in firmware we bind the OMAP

00:10:42,340 --> 00:10:48,220
serial driver in this case it goes out

00:10:45,100 --> 00:10:51,160
and registers with the c2 a layer which

00:10:48,220 --> 00:10:53,650
we now call into an assertive core and

00:10:51,160 --> 00:10:56,350
go out and look if we have any serial

00:10:53,650 --> 00:10:58,360
Attached devices defining firmware if

00:10:56,350 --> 00:11:00,670
that's the case we'll register assertive

00:10:58,360 --> 00:11:03,370
controller and assertive device client

00:11:00,670 --> 00:11:04,950
instead and once the server client is

00:11:03,370 --> 00:11:07,960
bound to its driver

00:11:04,950 --> 00:11:09,700
it can register the HEI device so that

00:11:07,960 --> 00:11:12,100
once the system is booted the Bluetooth

00:11:09,700 --> 00:11:15,220
device is already accessible and we can

00:11:12,100 --> 00:11:16,780
run a check on fit immediately so we

00:11:15,220 --> 00:11:20,050
compared to the old situation here we've

00:11:16,780 --> 00:11:22,510
done away with the daemon application

00:11:20,050 --> 00:11:24,400
one in the rights and there we're

00:11:22,510 --> 00:11:28,000
bypassing the line discipline entirely

00:11:24,400 --> 00:11:30,490
and we'd no longer have a character

00:11:28,000 --> 00:11:31,930
device representation in user space this

00:11:30,490 --> 00:11:34,420
also means that the port is no longer

00:11:31,930 --> 00:11:35,800
being kept open unless the state of

00:11:34,420 --> 00:11:41,200
trial actually needs to have the port

00:11:35,800 --> 00:11:43,510
open and most importantly the server

00:11:41,200 --> 00:11:46,560
client has a firmer representation in

00:11:43,510 --> 00:11:49,990
firmware so we now solve the problem of

00:11:46,560 --> 00:11:56,040
describing these associated resources

00:11:49,990 --> 00:11:59,080
that the client may need to use so as

00:11:56,040 --> 00:12:01,780
some bit of details on how the tty port

00:11:59,080 --> 00:12:04,900
control has been implemented I mentioned

00:12:01,780 --> 00:12:06,880
before that it it's a TTY drivers

00:12:04,900 --> 00:12:08,080
responsibility to actually register

00:12:06,880 --> 00:12:11,440
these controllers and that's been done

00:12:08,080 --> 00:12:15,790
by hooking into the tty port register

00:12:11,440 --> 00:12:17,680
device helper so when there's a client

00:12:15,790 --> 00:12:19,120
to find this will register controller in

00:12:17,680 --> 00:12:22,690
the slave instead of the TTY class

00:12:19,120 --> 00:12:24,850
device and the white boards struct in

00:12:22,690 --> 00:12:27,580
the kernel has been amended with two new

00:12:24,850 --> 00:12:30,550
fields here it's 2d WIPO client

00:12:27,580 --> 00:12:32,500
operations and client data and the

00:12:30,550 --> 00:12:34,270
default client operations simply

00:12:32,500 --> 00:12:36,720
forwards data to the line discipline but

00:12:34,270 --> 00:12:39,400
when we have a serial controller

00:12:36,720 --> 00:12:42,460
registered it will forward it's written

00:12:39,400 --> 00:12:45,940
to the slave device and in the other

00:12:42,460 --> 00:12:47,610
direction the controller interface is

00:12:45,940 --> 00:12:49,810
implemented by using these TTY

00:12:47,610 --> 00:12:56,160
operations that I mentioned in the

00:12:49,810 --> 00:12:59,200
beginning device tree bindings for

00:12:56,160 --> 00:13:01,270
serial Attached device device tree

00:12:59,200 --> 00:13:03,190
serial Attached node is simply a child

00:13:01,270 --> 00:13:05,140
of a serial port node and the only

00:13:03,190 --> 00:13:09,730
requirement is that it has a compatible

00:13:05,140 --> 00:13:11,440
property and there is a max B property

00:13:09,730 --> 00:13:13,510
defined as well it's optional and it's

00:13:11,440 --> 00:13:14,980
not typically supposed to be it's not

00:13:13,510 --> 00:13:16,480
supposed to be used to a specify the

00:13:14,980 --> 00:13:20,380
actual baud rate to be used but

00:13:16,480 --> 00:13:22,540
to lower the maximum butter the driver

00:13:20,380 --> 00:13:25,060
is supposed to know how to what

00:13:22,540 --> 00:13:26,740
capabilities the hardware has and but

00:13:25,060 --> 00:13:28,570
it's only if there are issues with the

00:13:26,740 --> 00:13:30,760
actual physical board that you can cap

00:13:28,570 --> 00:13:32,860
that max speed by using this property

00:13:30,760 --> 00:13:35,920
and this is also where you would specify

00:13:32,860 --> 00:13:37,149
your GPIO s and clocks and so on so in

00:13:35,920 --> 00:13:39,490
this example it's a it's a Bluetooth

00:13:37,149 --> 00:13:43,480
note it's being defined as a child of

00:13:39,490 --> 00:13:47,920
the Lord one it's has a TI compatible

00:13:43,480 --> 00:13:49,720
property and GPIO and talked and it's

00:13:47,920 --> 00:13:53,560
sisyphus this would show up as something

00:13:49,720 --> 00:13:56,260
like this we have here two serial ports

00:13:53,560 --> 00:13:58,360
both are being driven by ohm abort the

00:13:56,260 --> 00:14:00,550
first one does not have a child loading

00:13:58,360 --> 00:14:03,190
device tree so that we get there the

00:14:00,550 --> 00:14:05,949
character device me registered class

00:14:03,190 --> 00:14:07,930
device and in the other case we're using

00:14:05,949 --> 00:14:10,180
the snippets from the preview slide so

00:14:07,930 --> 00:14:15,519
we end up with a period of controller

00:14:10,180 --> 00:14:18,190
serial zero it has one slave serial 0.00

00:14:15,519 --> 00:14:21,910
and it's only when that driver has been

00:14:18,190 --> 00:14:25,269
bound on the serial bus its serial bus

00:14:21,910 --> 00:14:31,569
that the HDI device shows up in the

00:14:25,269 --> 00:14:34,690
system so um if you want to write your

00:14:31,569 --> 00:14:36,040
own spirit of driver this the interface

00:14:34,690 --> 00:14:37,540
that you're going to be using it

00:14:36,040 --> 00:14:39,069
resembles that of the line discipline

00:14:37,540 --> 00:14:40,480
operations which is fairly natural

00:14:39,069 --> 00:14:44,019
because we're replacing the line

00:14:40,480 --> 00:14:45,579
discipline so you have functionality for

00:14:44,019 --> 00:14:48,399
opening and closing a port changing

00:14:45,579 --> 00:14:50,050
terminal settings writing data changing

00:14:48,399 --> 00:14:54,250
and reading back to modem control

00:14:50,050 --> 00:14:56,110
signals and to callbacks for when you

00:14:54,250 --> 00:14:58,420
have incoming data and when there is

00:14:56,110 --> 00:15:00,370
more room in the outgoing buffer there

00:14:58,420 --> 00:15:03,519
are a few additional helpers implement

00:15:00,370 --> 00:15:05,800
around ease but this is in fact the

00:15:03,519 --> 00:15:08,230
basic set of primitives that you have

00:15:05,800 --> 00:15:10,480
open closed set baud rates enable

00:15:08,230 --> 00:15:12,730
Hardware flow control writing a buffer

00:15:10,480 --> 00:15:15,300
waiting until it's been sent flushing

00:15:12,730 --> 00:15:18,160
and changed in the motor control signals

00:15:15,300 --> 00:15:20,019
the thing to note here is that there is

00:15:18,160 --> 00:15:22,029
no write serialization enforced by

00:15:20,019 --> 00:15:24,069
serial core this shouldn't be a problem

00:15:22,029 --> 00:15:27,850
TTY drivers as opposed to deal with the

00:15:24,069 --> 00:15:29,140
concurrent calls to write but since the

00:15:27,850 --> 00:15:30,100
character device implementation

00:15:29,140 --> 00:15:32,139
typically takes care

00:15:30,100 --> 00:15:34,829
that may not have been fully tested so

00:15:32,139 --> 00:15:36,910
you may run into some problems there

00:15:34,829 --> 00:15:39,699
another thing is that there is no

00:15:36,910 --> 00:15:43,449
operational force ordering enforce by by

00:15:39,699 --> 00:15:46,389
serial Corps at all the only ordering

00:15:43,449 --> 00:15:48,910
that's been enforced is actually that

00:15:46,389 --> 00:15:50,889
you cannot write the buffer before

00:15:48,910 --> 00:15:53,380
you've opened a port if you're using the

00:15:50,889 --> 00:15:55,410
tty port controller but there's nothing

00:15:53,380 --> 00:15:57,819
preventing you from calling you to set

00:15:55,410 --> 00:16:00,220
terminal settings before you've opened a

00:15:57,819 --> 00:16:04,000
port and so on and this will probably

00:16:00,220 --> 00:16:05,829
break some serial drivers and all these

00:16:04,000 --> 00:16:09,880
functions except right buffer right room

00:16:05,829 --> 00:16:11,949
may sleep in the other direction we have

00:16:09,880 --> 00:16:13,839
a couple of callbacks again it's a

00:16:11,949 --> 00:16:17,139
receiver for right but wake up call

00:16:13,839 --> 00:16:19,720
backs receive off is called in work

00:16:17,139 --> 00:16:20,920
queue contacts you can sleep and it

00:16:19,720 --> 00:16:23,319
should return the number of bytes that

00:16:20,920 --> 00:16:26,290
the serial client has accepted and

00:16:23,319 --> 00:16:32,620
processed right wake up typically called

00:16:26,290 --> 00:16:36,670
an atomic contact so you can't sleep so

00:16:32,620 --> 00:16:40,029
a quick example of what a Saratov driver

00:16:36,670 --> 00:16:42,040
may look like you have a serial device

00:16:40,029 --> 00:16:43,689
driver struct you need to fill in and

00:16:42,040 --> 00:16:45,459
has an embedded device driver struct as

00:16:43,689 --> 00:16:47,500
usual you set the name you set your

00:16:45,459 --> 00:16:50,019
match table this is where you specify

00:16:47,500 --> 00:16:52,060
power management operations so you can

00:16:50,019 --> 00:16:53,470
implement proper power management other

00:16:52,060 --> 00:16:55,839
than that it's just a programmable

00:16:53,470 --> 00:16:58,089
function and we have a communities macro

00:16:55,839 --> 00:17:02,920
for defining a modular slave device

00:16:58,089 --> 00:17:04,530
driver and shared of a prop function

00:17:02,920 --> 00:17:06,549
would typically look something like this

00:17:04,530 --> 00:17:08,439
you'd allocate your private data is

00:17:06,549 --> 00:17:09,880
usually you now have access to a

00:17:08,439 --> 00:17:12,429
firmware description which means that

00:17:09,880 --> 00:17:14,890
you can use calls like Clark gets to go

00:17:12,429 --> 00:17:18,909
out and look up a clock resource or

00:17:14,890 --> 00:17:20,679
access the Oh F node directly you'd

00:17:18,909 --> 00:17:22,000
store a pointer in your private data to

00:17:20,679 --> 00:17:24,039
the serial device that you can use in

00:17:22,000 --> 00:17:27,370
your class device callbacks and set the

00:17:24,039 --> 00:17:28,870
driver data to this private data the

00:17:27,370 --> 00:17:30,429
important thing to note is that you need

00:17:28,870 --> 00:17:32,950
to set your client operations this is

00:17:30,429 --> 00:17:35,890
the callbacks for incoming data right

00:17:32,950 --> 00:17:37,480
wake up before you open the port and if

00:17:35,890 --> 00:17:39,159
your application if it makes sense for

00:17:37,480 --> 00:17:40,990
your application you would open your

00:17:39,159 --> 00:17:43,679
port here as well before registering

00:17:40,990 --> 00:17:43,679
your class device

00:17:44,400 --> 00:17:51,580
so certif gives us solves the problem

00:17:49,360 --> 00:17:53,470
but there are still some things to be

00:17:51,580 --> 00:17:56,080
implemented and some some caveats for

00:17:53,470 --> 00:17:58,990
using it as I mentioned before it's

00:17:56,080 --> 00:18:00,820
sirak or only and that has to do with

00:17:58,990 --> 00:18:03,280
these lifetime issues I mentioned in the

00:18:00,820 --> 00:18:04,690
beginning but primarily it's because I

00:18:03,280 --> 00:18:08,080
said it doesn't have any half-block

00:18:04,690 --> 00:18:10,720
support at all and this was simply not a

00:18:08,080 --> 00:18:12,220
use case for the people who implemented

00:18:10,720 --> 00:18:16,420
it so it was something that left to be

00:18:12,220 --> 00:18:18,370
decided for later and I'll get back to

00:18:16,420 --> 00:18:20,680
how plugging in a minute it's also

00:18:18,370 --> 00:18:22,660
single slave only there's currently no

00:18:20,680 --> 00:18:28,360
support for any kind of maxing protocols

00:18:22,660 --> 00:18:30,190
or using rs-485 and 200 issues to watch

00:18:28,360 --> 00:18:31,870
out for is that there is no input flow

00:18:30,190 --> 00:18:34,090
control implemented I said you can

00:18:31,870 --> 00:18:35,710
enable Hardware flow control but it only

00:18:34,090 --> 00:18:38,680
works in the outcome direction if you're

00:18:35,710 --> 00:18:40,660
using something like auto CD s because

00:18:38,680 --> 00:18:42,970
there's no pushback implemented so if

00:18:40,660 --> 00:18:43,450
your client can't keep up data will be

00:18:42,970 --> 00:18:47,170
lost

00:18:43,450 --> 00:18:49,300
there will be no pushback to the

00:18:47,170 --> 00:18:54,880
underlying TTY driver which can lower

00:18:49,300 --> 00:18:56,590
the RTS signal for example also since

00:18:54,880 --> 00:18:57,670
we're not doing an input processing you

00:18:56,590 --> 00:18:59,950
don't have access to things like

00:18:57,670 --> 00:19:02,410
software flow control apparently framing

00:18:59,950 --> 00:19:06,510
over on errors aren't propagated up and

00:19:02,410 --> 00:19:06,510
you don't have any brake signaling

00:19:07,560 --> 00:19:13,420
serial hub plugging it's currently

00:19:10,360 --> 00:19:15,250
implementing using TTY hang-ups and file

00:19:13,420 --> 00:19:16,750
operations in the tty layer but

00:19:15,250 --> 00:19:20,350
sincerely doesn't use any file

00:19:16,750 --> 00:19:22,330
operations where this this is simply

00:19:20,350 --> 00:19:24,070
won't work so this will require some

00:19:22,330 --> 00:19:27,400
changes to to see why driver to

00:19:24,070 --> 00:19:30,940
basically have a call back to quiesce

00:19:27,400 --> 00:19:34,900
I'll flush out any operations before you

00:19:30,940 --> 00:19:36,850
can do register the clients and this is

00:19:34,900 --> 00:19:40,330
as I mentioned a part of reason for the

00:19:36,850 --> 00:19:43,500
initial revert we can't have CF enabled

00:19:40,330 --> 00:19:45,940
for USB serial until it's been solved

00:19:43,500 --> 00:19:49,000
obviously we still have PCI hot-plug and

00:19:45,940 --> 00:19:51,130
some PCI devices you could actually rip

00:19:49,000 --> 00:19:52,840
out your your PCI card and you will

00:19:51,130 --> 00:19:54,470
trigger these issues but it's fairly

00:19:52,840 --> 00:19:57,270
unlikely you try that

00:19:54,470 --> 00:20:00,300
another issue with the hot plugging is

00:19:57,270 --> 00:20:03,210
that we don't have any way of describing

00:20:00,300 --> 00:20:06,150
these dynamic buses currently only USB

00:20:03,210 --> 00:20:10,470
has some kind of rudimentary and vise

00:20:06,150 --> 00:20:13,260
tree support and for specifying

00:20:10,470 --> 00:20:14,580
basically static things like if you have

00:20:13,260 --> 00:20:18,120
an Ethernet controller or something

00:20:14,580 --> 00:20:19,710
that's connected over USB we could be

00:20:18,120 --> 00:20:21,450
able to use device tree overlays but

00:20:19,710 --> 00:20:23,700
obviously we don't need some way to get

00:20:21,450 --> 00:20:24,660
those into the kernel and that's not

00:20:23,700 --> 00:20:28,500
available at the moment

00:20:24,660 --> 00:20:31,470
and as someone pointed out when I have

00:20:28,500 --> 00:20:34,290
let's talk a few weeks ago there is some

00:20:31,470 --> 00:20:38,400
devices are entirely self described we

00:20:34,290 --> 00:20:41,250
have an example here of a HDMI CC USB

00:20:38,400 --> 00:20:43,470
device which brings enter cells to do to

00:20:41,250 --> 00:20:46,320
use a space or to the kernel and really

00:20:43,470 --> 00:20:48,780
as a an SEM device it's handled by CDC

00:20:46,320 --> 00:20:51,480
ACM but you need to run the input attach

00:20:48,780 --> 00:20:54,660
daemon to actually be able to speak the

00:20:51,480 --> 00:20:56,940
protocol pulsate protocol which would in

00:20:54,660 --> 00:20:59,580
turn register a dev CC device that you

00:20:56,940 --> 00:21:03,330
can use to turn on and off your your TV

00:20:59,580 --> 00:21:07,020
for example it should be possible to

00:21:03,330 --> 00:21:12,270
pass just a matching data from the CDC

00:21:07,020 --> 00:21:14,250
ACM driver but this should be solved in

00:21:12,270 --> 00:21:15,660
a generic way which probably means that

00:21:14,250 --> 00:21:18,360
we still want to be using something like

00:21:15,660 --> 00:21:19,650
overlays and but in this simple case it

00:21:18,360 --> 00:21:22,620
would be enough to simply pass a

00:21:19,650 --> 00:21:28,290
compatible string to set up to be able

00:21:22,620 --> 00:21:33,150
to do will be the final matching some

00:21:28,290 --> 00:21:36,450
smaller issues there is no line

00:21:33,150 --> 00:21:38,190
discipline allocated sorry there is

00:21:36,450 --> 00:21:39,450
still a line discipline being allocated

00:21:38,190 --> 00:21:41,730
even though we're not supposed to use it

00:21:39,450 --> 00:21:44,690
we are allocating it and it's actually

00:21:41,730 --> 00:21:46,890
being called into TTY layer is

00:21:44,690 --> 00:21:48,900
complicated and no one else is actually

00:21:46,890 --> 00:21:51,720
what's going on everywhere and it's easy

00:21:48,900 --> 00:21:53,220
that you have some case you haven't

00:21:51,720 --> 00:21:56,340
thought about yet the notes you got a

00:21:53,220 --> 00:21:57,810
callback and another thing is that the

00:21:56,340 --> 00:22:00,180
sheraton controller is always being

00:21:57,810 --> 00:22:02,400
registered so for every port in your

00:22:00,180 --> 00:22:04,470
system there will be during boot and

00:22:02,400 --> 00:22:06,390
when it's probed a controller will be

00:22:04,470 --> 00:22:07,770
registered only then will we go out and

00:22:06,390 --> 00:22:07,980
look in the firmware as if we have any

00:22:07,770 --> 00:22:10,710
choice

00:22:07,980 --> 00:22:12,360
notes if we don't we'll do register the

00:22:10,710 --> 00:22:15,059
allocate and the character device will

00:22:12,360 --> 00:22:18,000
be registered so that's inefficient at

00:22:15,059 --> 00:22:20,309
least obviously you don't have any

00:22:18,000 --> 00:22:22,590
character choice some people have been a

00:22:20,309 --> 00:22:26,160
bit surprised about that but it's really

00:22:22,590 --> 00:22:27,720
a feature more than a bug and the

00:22:26,160 --> 00:22:30,410
operation ordering I mentioned you need

00:22:27,720 --> 00:22:33,840
to watch out for another thing is that

00:22:30,410 --> 00:22:35,669
we don't have any bus power management

00:22:33,840 --> 00:22:38,010
for example run time power management

00:22:35,669 --> 00:22:40,470
isn't enabled for the controllers which

00:22:38,010 --> 00:22:42,240
means that the clients run time p.m.

00:22:40,470 --> 00:22:44,460
stairs won't be propagated up the tree

00:22:42,240 --> 00:22:46,760
this shouldn't be a problem because it's

00:22:44,460 --> 00:22:52,080
essentially equivalent to having the

00:22:46,760 --> 00:22:53,970
ignore child children flag sets because

00:22:52,080 --> 00:22:55,890
you you really want to have your report

00:22:53,970 --> 00:22:59,309
be able to go into run to and suspend

00:22:55,890 --> 00:23:01,440
independently of your child of Isis and

00:22:59,309 --> 00:23:03,090
then when you're doing IO that's when

00:23:01,440 --> 00:23:06,600
you bring up with the power on day in

00:23:03,090 --> 00:23:09,299
the serial port and there's also a

00:23:06,600 --> 00:23:10,799
possibility of running into some issues

00:23:09,299 --> 00:23:12,210
record applications the backwards

00:23:10,799 --> 00:23:13,500
compatibility because we have a number

00:23:12,210 --> 00:23:17,669
of line discipline which can now be

00:23:13,500 --> 00:23:19,320
converted over to to serve but we still

00:23:17,669 --> 00:23:22,440
need to support the line disciplines for

00:23:19,320 --> 00:23:25,890
backwards compatibility reasons for

00:23:22,440 --> 00:23:27,780
Bluetooth this has a man and resulted in

00:23:25,890 --> 00:23:29,429
the fact that we've copied part of the

00:23:27,780 --> 00:23:31,010
implementation from the line discipline

00:23:29,429 --> 00:23:33,570
implementation we now have two competing

00:23:31,010 --> 00:23:37,950
implementations which may need to be

00:23:33,570 --> 00:23:39,720
unified there are some naming

00:23:37,950 --> 00:23:41,610
inconsistencies to watch out for for

00:23:39,720 --> 00:23:45,510
example the bus is actually named serial

00:23:41,610 --> 00:23:50,540
rather than CF and it's assertive device

00:23:45,510 --> 00:23:50,540
client slave being used interchangeably

00:23:51,500 --> 00:23:57,630
another thing to watch out for k config

00:23:54,980 --> 00:23:58,260
we have two symbols for sort of it's

00:23:57,630 --> 00:24:02,220
both

00:23:58,260 --> 00:24:04,559
to enable the bus and set of core and to

00:24:02,220 --> 00:24:08,340
enable this particular TTY port

00:24:04,559 --> 00:24:09,990
controller and you really cannot use ser

00:24:08,340 --> 00:24:12,570
dev or any of these Bluetooth drivers

00:24:09,990 --> 00:24:15,780
for example that emerged without having

00:24:12,570 --> 00:24:17,700
both enabled but the thing to watch out

00:24:15,780 --> 00:24:20,760
for here is that the bus is can be built

00:24:17,700 --> 00:24:21,360
as a module where whereas the tty port

00:24:20,760 --> 00:24:23,790
controller

00:24:21,360 --> 00:24:27,210
Hansol tty which is compiled in only its

00:24:23,790 --> 00:24:28,860
yes or no boolean and this means that

00:24:27,210 --> 00:24:31,070
this option won't even show up with you

00:24:28,860 --> 00:24:34,470
if you choose there to be modular and

00:24:31,070 --> 00:24:37,220
this is the only tty port controller a

00:24:34,470 --> 00:24:39,540
seraph controller really ought to be

00:24:37,220 --> 00:24:47,790
defaulting to yes and that will change

00:24:39,540 --> 00:24:49,770
starting from 415 so current uses of

00:24:47,790 --> 00:24:51,900
this we have three bluetooth device

00:24:49,770 --> 00:24:55,610
drivers merged and a library function

00:24:51,900 --> 00:24:59,520
against mentioned based on hgil disk

00:24:55,610 --> 00:25:04,919
it's for Broadcom TI devices and Nokia

00:24:59,520 --> 00:25:09,290
and there's one Ethernet over UART

00:25:04,919 --> 00:25:12,990
drivers man for Qualcomm chip I think

00:25:09,290 --> 00:25:14,760
and one of these drivers than H IBM I

00:25:12,990 --> 00:25:17,780
want to say a few words and that that's

00:25:14,760 --> 00:25:20,700
basically a sort of precursor to serve

00:25:17,780 --> 00:25:23,520
because it depended on some power

00:25:20,700 --> 00:25:27,330
management hacks which relied on having

00:25:23,520 --> 00:25:28,700
a child node child platform device of

00:25:27,330 --> 00:25:31,890
the year of the iord

00:25:28,700 --> 00:25:35,730
device being described in a Cir platform

00:25:31,890 --> 00:25:38,669
code this device would be the one that's

00:25:35,730 --> 00:25:40,169
has associated GPIO some clocks and it

00:25:38,669 --> 00:25:43,559
would be when the platform device was

00:25:40,169 --> 00:25:44,970
probed you'd register the classroom

00:25:43,559 --> 00:25:47,460
device in a global list in the driver

00:25:44,970 --> 00:25:49,530
and then when you get your H I call

00:25:47,460 --> 00:25:52,380
backs to the sibling device really they

00:25:49,530 --> 00:25:53,910
would go to this global list match on

00:25:52,380 --> 00:25:56,130
the parent we have the same parent and

00:25:53,910 --> 00:25:59,010
then call into the sibling device this

00:25:56,130 --> 00:26:00,299
is layering issue at best it's a hack

00:25:59,010 --> 00:26:01,530
but it's the kind of thing that you were

00:26:00,299 --> 00:26:06,710
forced to do if you wanted to implement

00:26:01,530 --> 00:26:09,630
power management before Saratov now this

00:26:06,710 --> 00:26:13,080
driver is gaining has gained halls

00:26:09,630 --> 00:26:15,090
together has done some some work adding

00:26:13,080 --> 00:26:17,160
a API properties by and power management

00:26:15,090 --> 00:26:21,380
support for the CF version of this

00:26:17,160 --> 00:26:24,210
driver and it's been merged for 415 but

00:26:21,380 --> 00:26:26,370
there are some possibilities that we run

00:26:24,210 --> 00:26:27,720
into regressions here one thing being if

00:26:26,370 --> 00:26:29,910
you haven't enabled your theory of

00:26:27,720 --> 00:26:31,770
controller you can still use the line

00:26:29,910 --> 00:26:33,350
discipline but your power management

00:26:31,770 --> 00:26:37,570
won't work anymore

00:26:33,350 --> 00:26:40,759
and it's you you can't really tell you

00:26:37,570 --> 00:26:42,080
can still access there's still a chance

00:26:40,759 --> 00:26:44,720
that you can access the Bluetooth device

00:26:42,080 --> 00:26:46,580
but power management won't work and we

00:26:44,720 --> 00:26:48,980
just discovered as well at the HEI intel

00:26:46,580 --> 00:26:50,120
has copied these kind of hacks and it

00:26:48,980 --> 00:26:51,529
doesn't have any power management

00:26:50,120 --> 00:26:53,330
support facility of yet that I will

00:26:51,529 --> 00:26:56,090
definitely break if you have one of

00:26:53,330 --> 00:27:02,450
those devices using a CPI with hei endo

00:26:56,090 --> 00:27:04,639
and stuff that's coming and so I

00:27:02,450 --> 00:27:09,320
mentioned a CBI support was merged it

00:27:04,639 --> 00:27:13,279
was merged only four days ago Friday by

00:27:09,320 --> 00:27:15,289
Frederic Denis and the risk here is that

00:27:13,279 --> 00:27:17,690
we'll have some issues with HIV see I'm

00:27:15,289 --> 00:27:20,090
a giant old but it's been decided that

00:27:17,690 --> 00:27:24,529
this is the way forward so we'll deal

00:27:20,090 --> 00:27:27,139
with that when it happens and there's a

00:27:24,529 --> 00:27:30,559
patch sirs posted a few months ago

00:27:27,139 --> 00:27:32,929
adding a mock support assertive it's

00:27:30,559 --> 00:27:34,879
based on the Newmark subsystem and adds

00:27:32,929 --> 00:27:38,539
a reg property to these device tree

00:27:34,879 --> 00:27:40,669
notes which is the marks index there are

00:27:38,539 --> 00:27:42,169
some issues with this Arius it doesn't

00:27:40,669 --> 00:27:44,779
do any flushing when it's switching from

00:27:42,169 --> 00:27:46,970
one sort of client to the other and

00:27:44,779 --> 00:27:50,240
there's no locking in those i/o paths so

00:27:46,970 --> 00:27:52,490
things will definitely break in this

00:27:50,240 --> 00:27:54,019
series this is an example of a I screw C

00:27:52,490 --> 00:27:56,240
control drivers you have a nice cracy

00:27:54,019 --> 00:27:58,250
controller connected over you aren't and

00:27:56,240 --> 00:28:00,169
it adds some basic power to support just

00:27:58,250 --> 00:28:02,450
to switch on parity checking but again

00:28:00,169 --> 00:28:03,830
Sarah doesn't propagate any errors of

00:28:02,450 --> 00:28:08,539
the stack so you won't figure out if

00:28:03,830 --> 00:28:12,320
something went wrong and another driver

00:28:08,539 --> 00:28:15,259
and MFT driver for in doing some kind of

00:28:12,320 --> 00:28:17,149
supervisory I think it's for an

00:28:15,259 --> 00:28:22,009
in-flight system you have a watchdog

00:28:17,149 --> 00:28:24,980
back like Inlet components and they are

00:28:22,009 --> 00:28:28,279
all accessed over this this supervisory

00:28:24,980 --> 00:28:32,450
processor and it's implemented enough an

00:28:28,279 --> 00:28:35,090
MFT driver and there's some earlier

00:28:32,450 --> 00:28:40,460
examples of a GPS and Bluetooth slave

00:28:35,090 --> 00:28:42,110
device driver is posted future work and

00:28:40,460 --> 00:28:44,779
would be obviously to acquire address

00:28:42,110 --> 00:28:45,980
those quirks and limitations that I've

00:28:44,779 --> 00:28:47,750
listed

00:28:45,980 --> 00:28:50,360
specifically adding hot-plug supports

00:28:47,750 --> 00:28:52,279
it's the one that I care about because I

00:28:50,360 --> 00:28:57,399
don't want enable syrup for us becerril

00:28:52,279 --> 00:28:57,399
before and this has been fixed and

00:28:59,110 --> 00:29:04,460
lifting the limitation of only having a

00:29:02,000 --> 00:29:06,049
single slide would be good too it might

00:29:04,460 --> 00:29:08,929
be possible to implement some kind of

00:29:06,049 --> 00:29:13,519
generic rs-485 support based on this

00:29:08,929 --> 00:29:15,350
this MUX work but someone need to dig

00:29:13,519 --> 00:29:17,419
into that because it's it may be better

00:29:15,350 --> 00:29:21,289
way to do this on with a dedicated

00:29:17,419 --> 00:29:23,120
driver and we have further Bluetooth

00:29:21,289 --> 00:29:25,669
protocol drivers that can be converted a

00:29:23,120 --> 00:29:28,880
giant list top priority one because we

00:29:25,669 --> 00:29:31,070
now know it's broken for a CPI other

00:29:28,880 --> 00:29:33,110
line disciplined drivers would be for

00:29:31,070 --> 00:29:36,409
NFC there's a line exception driver for

00:29:33,110 --> 00:29:38,179
canvas the TI share transfer driver you

00:29:36,409 --> 00:29:40,610
can use now the Bluetooth component but

00:29:38,179 --> 00:29:43,639
there are some it's shared transport so

00:29:40,610 --> 00:29:45,529
maybe the marketing subsystem can be

00:29:43,639 --> 00:29:48,860
used here to get the static component

00:29:45,529 --> 00:29:52,010
supported I mentioned a CC device and

00:29:48,860 --> 00:29:57,409
there are other cRIO drivers that could

00:29:52,010 --> 00:30:00,919
probably benefit from assertive and if

00:29:57,409 --> 00:30:02,870
you want to do some further studying in

00:30:00,919 --> 00:30:06,580
this I recommend looking at the code

00:30:02,870 --> 00:30:09,799
it's only these three files basically

00:30:06,580 --> 00:30:12,830
include file in two files on the drivers

00:30:09,799 --> 00:30:15,590
tty CF and it's not really that much

00:30:12,830 --> 00:30:17,659
code to to process device tree bindings

00:30:15,590 --> 00:30:19,519
have been defined where they should and

00:30:17,659 --> 00:30:21,409
there are bindings in there the thing to

00:30:19,519 --> 00:30:22,789
watch out for with accepted bindings for

00:30:21,409 --> 00:30:25,669
things that aren't implemented yet so

00:30:22,789 --> 00:30:27,500
you could have talked resources and so

00:30:25,669 --> 00:30:30,769
I'm being defined but the driver won't

00:30:27,500 --> 00:30:34,039
actually use them in it and if you want

00:30:30,769 --> 00:30:35,510
to read some more about the background

00:30:34,039 --> 00:30:39,320
about all this this in the article

00:30:35,510 --> 00:30:41,330
burning a brown on lwn which was written

00:30:39,320 --> 00:30:44,990
while Sarah was being developed and sort

00:30:41,330 --> 00:30:46,309
of iterates some of the the history and

00:30:44,990 --> 00:30:51,559
some of the concerns of some of the

00:30:46,309 --> 00:30:54,110
previous attempts it's doing this yeah

00:30:51,559 --> 00:30:58,820
that was it thanks

00:30:54,110 --> 00:30:58,820
[Applause]

00:31:00,350 --> 00:31:20,850
any questions so I have few questions

00:31:18,450 --> 00:31:25,170
about run time p.m. you probably could

00:31:20,850 --> 00:31:33,420
correct me any driver could try to use

00:31:25,170 --> 00:31:37,110
it but it will not work correct if I

00:31:33,420 --> 00:31:44,580
implement in the each slave or control

00:31:37,110 --> 00:31:46,050
driver okay so the second question is it

00:31:44,580 --> 00:31:50,580
does not cover console

00:31:46,050 --> 00:32:00,420
I mean kernel console is not covered by

00:31:50,580 --> 00:32:03,960
that okay and what about what about DMA

00:32:00,420 --> 00:32:07,860
support could you elaborate a bit about

00:32:03,960 --> 00:32:09,840
GMI support do you may I mean that

00:32:07,860 --> 00:32:12,600
that's something that's dealt with by

00:32:09,840 --> 00:32:16,170
the underlaying TTY driver so sort of

00:32:12,600 --> 00:32:18,750
wouldn't be involved in in DMA row you'd

00:32:16,170 --> 00:32:20,790
only get your when you know when you do

00:32:18,750 --> 00:32:22,560
you may interrupt triggers you get your

00:32:20,790 --> 00:32:23,820
receive buffer being propagated up the

00:32:22,560 --> 00:32:26,670
stack through these callbacks I

00:32:23,820 --> 00:32:29,340
mentioned but Syria wouldn't be involved

00:32:26,670 --> 00:32:31,110
at that level it's built on top of the

00:32:29,340 --> 00:32:40,320
serial drivers and on top of the tty

00:32:31,110 --> 00:32:42,930
ports so first of all about the history

00:32:40,320 --> 00:32:45,120
the initial reason was the Nokia driver

00:32:42,930 --> 00:32:47,760
they triggered everything because I

00:32:45,120 --> 00:32:49,560
tried to commit a driver similar to the

00:32:47,760 --> 00:32:52,950
brought home one and got a neck for that

00:32:49,560 --> 00:32:55,530
one and secondly about run time core

00:32:52,950 --> 00:32:57,440
management if you just enable run time

00:32:55,530 --> 00:32:59,430
comment on the host controller

00:32:57,440 --> 00:33:01,200
independently of the slave and this

00:32:59,430 --> 00:33:02,220
slave tries to write something then

00:33:01,200 --> 00:33:05,120
might be missed

00:33:02,220 --> 00:33:08,130
that's why it's currently not enabled

00:33:05,120 --> 00:33:11,580
because at least on a map if you if you

00:33:08,130 --> 00:33:13,440
wake up from getting data on the Cu line

00:33:11,580 --> 00:33:15,880
then the first few bites I missed

00:33:13,440 --> 00:33:17,529
which might be a problem or might not be

00:33:15,880 --> 00:33:21,460
a problem it depends on what is

00:33:17,529 --> 00:33:26,860
connected so more thinking is required

00:33:21,460 --> 00:33:28,330
on that one I mean form up the runtime

00:33:26,860 --> 00:33:31,240
power management for the OMA viewer

00:33:28,330 --> 00:33:34,659
driver and that that device first of all

00:33:31,240 --> 00:33:37,210
it's always enabled and when you don't

00:33:34,659 --> 00:33:39,429
have a runtime power management enabled

00:33:37,210 --> 00:33:43,980
for its child of ice which would be the

00:33:39,429 --> 00:33:47,200
serial controller this simply means that

00:33:43,980 --> 00:33:49,330
the child devices status won't be

00:33:47,200 --> 00:33:51,549
propagated up it will still work the the

00:33:49,330 --> 00:34:02,130
port is always on one and sopin

00:33:51,549 --> 00:34:02,130
currently any other questions

00:34:05,800 --> 00:34:12,789
all right thank you

00:34:08,070 --> 00:34:12,789

YouTube URL: https://www.youtube.com/watch?v=wIQPb1NkZbQ


