Title: Develop Your Embedded Applications Faster: Comparing C and Golang - Marcin Pasinski, Mender.io
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	Develop Your Embedded Applications Faster: Comparing C and Golang - Marcin Pasinski, Mender.io

As a strategy, time-to-market for embedded applications is nearly as obvious as maximizing scoring in a sports game. Thus we will focus on a more pragmatic approach for delivering applications faster while maintaining a quality-first approach. Specifically, we will compare and contrast Golang and C as programming languages for developing embedded applications.

We will also cover the learning curve for C programmers, as well as the key similarities and differences of C and Golang to provide context for developers considering a new language.

We will also demonstrate an example of a small embedded application with Go on a Yocto distribution with the BeagleBone with a new image deployment. As with any decision, it is rarely black-and-white and we will cover the trade-offs, to make sure you have the most critical information needed to decide.
Captions: 
	00:00:00,030 --> 00:00:09,090
right so I think we can slowly start so

00:00:04,350 --> 00:00:12,210
I really didn't expect so many of you so

00:00:09,090 --> 00:00:15,630
early in the morning so hope you grab

00:00:12,210 --> 00:00:18,300
your morning coffee and we can start so

00:00:15,630 --> 00:00:20,640
the session today will be about go

00:00:18,300 --> 00:00:23,189
language I'll try to present our

00:00:20,640 --> 00:00:27,080
experience using go and compare it and

00:00:23,189 --> 00:00:29,789
contrast it so a little bit with C and

00:00:27,080 --> 00:00:34,950
before I start how many of you have been

00:00:29,789 --> 00:00:44,550
using go before okay how many in

00:00:34,950 --> 00:00:46,710
production right in a lot so I hope

00:00:44,550 --> 00:00:50,149
after this talk we'll have a bit better

00:00:46,710 --> 00:00:53,579
overview of what the goal is and what

00:00:50,149 --> 00:00:57,050
its limitations are and what are the

00:00:53,579 --> 00:00:57,050
advantages as well so

00:01:02,760 --> 00:01:09,360
let me start with my personal view on go

00:01:06,720 --> 00:01:11,370
it's very subjective opinion but also

00:01:09,360 --> 00:01:16,290
supported by my colleagues or you're

00:01:11,370 --> 00:01:17,670
also using go I really think it's a very

00:01:16,290 --> 00:01:19,620
productive programming language

00:01:17,670 --> 00:01:22,590
especially when it comes to some kind of

00:01:19,620 --> 00:01:25,080
network programming and I'm not

00:01:22,590 --> 00:01:28,680
necessarily mean it's any kind of like

00:01:25,080 --> 00:01:31,020
heavy server programming but rather any

00:01:28,680 --> 00:01:35,790
kind of application where you're using

00:01:31,020 --> 00:01:39,930
network for communicating and I am by

00:01:35,790 --> 00:01:41,970
any means not claiming that go is a

00:01:39,930 --> 00:01:45,810
replacement for C because there are many

00:01:41,970 --> 00:01:49,220
places you cannot replace C and it's not

00:01:45,810 --> 00:01:53,130
go it's any language in general like

00:01:49,220 --> 00:01:55,860
when you are doing some kind of like are

00:01:53,130 --> 00:01:58,020
no hard real-time systems operating

00:01:55,860 --> 00:02:01,950
systems device drivers all those places

00:01:58,020 --> 00:02:05,850
are you're replaceable by any other

00:02:01,950 --> 00:02:09,060
language I think and during this talk I

00:02:05,850 --> 00:02:11,870
would start with telling you a bit about

00:02:09,060 --> 00:02:14,960
go itself and our experience with

00:02:11,870 --> 00:02:18,840
selecting go as a programming language

00:02:14,960 --> 00:02:21,830
then we look at basics and some code

00:02:18,840 --> 00:02:25,650
samples and finally I'll present you

00:02:21,830 --> 00:02:27,870
some demarcation I'm having bigger bone

00:02:25,650 --> 00:02:30,330
with a simple go application running a

00:02:27,870 --> 00:02:35,459
couple of sensors here so I will try to

00:02:30,330 --> 00:02:37,800
show that and a little bit about me so

00:02:35,459 --> 00:02:39,480
my name is marcin paczynski I've been

00:02:37,800 --> 00:02:40,310
doing software development for more than

00:02:39,480 --> 00:02:44,670
ten years

00:02:40,310 --> 00:02:47,550
it was mostly C and C++ but recently I'm

00:02:44,670 --> 00:02:49,770
doing also go development there my

00:02:47,550 --> 00:02:53,310
contact details there it won't reach me

00:02:49,770 --> 00:02:56,340
out of the representation and at the

00:02:53,310 --> 00:03:00,380
moment I'm working for nor turn to tech

00:02:56,340 --> 00:03:03,349
and the two very relevant for the stock

00:03:00,380 --> 00:03:05,819
products we are developing our meander

00:03:03,349 --> 00:03:08,580
which is already our updater for

00:03:05,819 --> 00:03:10,800
embedded Linux devices it's integrated

00:03:08,580 --> 00:03:14,240
with the octo I know how many of you

00:03:10,800 --> 00:03:14,240
have heard about the octo before

00:03:15,240 --> 00:03:20,590
so it's it's fully integrated with the

00:03:17,980 --> 00:03:23,050
octo it's written in go and we are

00:03:20,590 --> 00:03:25,630
having both at this conference and later

00:03:23,050 --> 00:03:27,790
today we will have a buff as well so if

00:03:25,630 --> 00:03:30,880
you are interested and feel free to join

00:03:27,790 --> 00:03:34,540
and the other product we are developing

00:03:30,880 --> 00:03:38,890
is cfengine someone heard about ship

00:03:34,540 --> 00:03:42,100
engine before okay people so this is

00:03:38,890 --> 00:03:45,490
written in C it's actually right now

00:03:42,100 --> 00:03:49,270
it's like 25 ursery of the product so

00:03:45,490 --> 00:03:51,880
it's there for a long time and I've been

00:03:49,270 --> 00:03:54,540
involved in developing both so I feel I

00:03:51,880 --> 00:03:58,840
have quite a nice experience with

00:03:54,540 --> 00:04:01,180
developing both go and C code so a

00:03:58,840 --> 00:04:03,670
little bit on go timelines so it's a

00:04:01,180 --> 00:04:08,200
fairly new programming language it was

00:04:03,670 --> 00:04:13,650
conceived in 2007 at Google and was

00:04:08,200 --> 00:04:16,750
announced in November 2009 and go is

00:04:13,650 --> 00:04:19,270
it's been started by writing a language

00:04:16,750 --> 00:04:20,950
specification so it was possible to

00:04:19,270 --> 00:04:26,170
start some independent work on writing

00:04:20,950 --> 00:04:30,130
front-end for GCC by Ian Taylor in 2008

00:04:26,170 --> 00:04:33,970
and then the first official release was

00:04:30,130 --> 00:04:38,260
in 2012 and go guys are trying to keep

00:04:33,970 --> 00:04:41,290
like healthier release schedules so 5

00:04:38,260 --> 00:04:46,180
years later we have go 1.9 release

00:04:41,290 --> 00:04:47,860
August this year and some of you might

00:04:46,180 --> 00:04:50,200
ask why do we need yet another

00:04:47,860 --> 00:04:51,750
programming language we have plenty

00:04:50,200 --> 00:04:55,990
already

00:04:51,750 --> 00:04:58,810
so go was created by Google to meet the

00:04:55,990 --> 00:05:00,610
needs of Google developers basically and

00:04:58,810 --> 00:05:04,360
it's supported by Google all the time

00:05:00,610 --> 00:05:07,930
and I really do think that all the

00:05:04,360 --> 00:05:10,780
programming languages reflect somehow

00:05:07,930 --> 00:05:14,650
the philosophy of the creator's so go

00:05:10,780 --> 00:05:17,470
was born to fix somehow improve the

00:05:14,650 --> 00:05:20,290
issue of the system suffering from an

00:05:17,470 --> 00:05:23,110
explosion of complexity at Google so

00:05:20,290 --> 00:05:25,229
simplicity together with efficient

00:05:23,110 --> 00:05:28,900
compilation efficient execution and

00:05:25,229 --> 00:05:32,440
easiness of pro

00:05:28,900 --> 00:05:35,830
were three main principles for creating

00:05:32,440 --> 00:05:38,650
go now

00:05:35,830 --> 00:05:41,730
let's move on to why we've selected to

00:05:38,650 --> 00:05:45,160
go for a developing our new product so

00:05:41,730 --> 00:05:48,790
when we started discussing and

00:05:45,160 --> 00:05:52,420
decision-making process we somehow

00:05:48,790 --> 00:05:57,040
divided the requirements into two groups

00:05:52,420 --> 00:06:01,090
and in the first one we've placed all

00:05:57,040 --> 00:06:03,040
the things which are somehow facing the

00:06:01,090 --> 00:06:07,720
end users and the second one was more

00:06:03,040 --> 00:06:11,110
internal points so I would like expand a

00:06:07,720 --> 00:06:15,550
little bit on both so at the point when

00:06:11,110 --> 00:06:17,890
we started developing our new product we

00:06:15,550 --> 00:06:20,410
knew that our application will be

00:06:17,890 --> 00:06:21,820
running on a meta devices and that we

00:06:20,410 --> 00:06:25,890
want to provide easy integration with

00:06:21,820 --> 00:06:28,750
Yocto so in the first group we've put

00:06:25,890 --> 00:06:31,630
size requirements on the device so the

00:06:28,750 --> 00:06:32,290
smaller the better then we knew the octo

00:06:31,630 --> 00:06:34,630
fink

00:06:32,290 --> 00:06:36,610
and we knew that it will run on embedded

00:06:34,630 --> 00:06:38,820
devices so possibility of cross

00:06:36,610 --> 00:06:43,810
compiling for different architectures

00:06:38,820 --> 00:06:46,919
was a must and then in the other group

00:06:43,810 --> 00:06:50,380
we put more internal things so

00:06:46,919 --> 00:06:52,600
competences in the company obviously the

00:06:50,380 --> 00:06:54,430
more people know the technology the

00:06:52,600 --> 00:06:57,280
better then we've been discussing

00:06:54,430 --> 00:07:00,180
possibility of sharing and reusing the

00:06:57,280 --> 00:07:05,050
existing code base we've been having and

00:07:00,180 --> 00:07:07,570
then development speed so I'm just

00:07:05,050 --> 00:07:11,520
wondering how many of you have faced

00:07:07,570 --> 00:07:11,520
pressure to add new features fast

00:07:12,170 --> 00:07:17,610
to like shape the code quickly it's

00:07:15,390 --> 00:07:21,150
great if you always have time to do the

00:07:17,610 --> 00:07:23,390
simple nice code but it's not always the

00:07:21,150 --> 00:07:25,620
case so very often you need to neglect

00:07:23,390 --> 00:07:29,220
simplicity you need to do some kind of

00:07:25,620 --> 00:07:32,070
like workarounds and stuff so go is

00:07:29,220 --> 00:07:34,470
really productive language and this was

00:07:32,070 --> 00:07:38,040
a big point for us and then we knew that

00:07:34,470 --> 00:07:40,380
our device will be so-called IOT device

00:07:38,040 --> 00:07:42,420
so some kind of network connectivity

00:07:40,380 --> 00:07:46,020
will be needed so we've been looking for

00:07:42,420 --> 00:07:50,730
access to like Network libraries like

00:07:46,020 --> 00:07:53,640
HTTP and SSL JSON and then we've been

00:07:50,730 --> 00:07:56,190
also discussing some kind of like things

00:07:53,640 --> 00:07:59,400
that will make the programming easier

00:07:56,190 --> 00:08:00,930
and less error-prone like automatic

00:07:59,400 --> 00:08:04,410
memory management for example or

00:08:00,930 --> 00:08:07,380
security and a blurs things like buffer

00:08:04,410 --> 00:08:10,800
overflow protection and and stuff like

00:08:07,380 --> 00:08:13,950
that so based on our findings

00:08:10,800 --> 00:08:18,990
we've created a comparison of couple of

00:08:13,950 --> 00:08:23,100
languages and C C++ and go word tree to

00:08:18,990 --> 00:08:25,350
somehow go to the final round and you

00:08:23,100 --> 00:08:27,420
can see here how those compare to each

00:08:25,350 --> 00:08:31,620
other and how they fulfilled our

00:08:27,420 --> 00:08:35,360
requirements and this is the state us

00:08:31,620 --> 00:08:38,270
when we discussed all the things so

00:08:35,360 --> 00:08:40,560
right now couple of things changed like

00:08:38,270 --> 00:08:45,600
competences in the company so more

00:08:40,560 --> 00:08:49,140
people now go right now and then when we

00:08:45,600 --> 00:08:54,030
started with go we needed extra layer in

00:08:49,140 --> 00:08:58,220
Yocto but right now yeah there is the

00:08:54,030 --> 00:09:01,110
small asterisk us from octo pyro release

00:08:58,220 --> 00:09:03,000
go is fully integrated with the octo so

00:09:01,110 --> 00:09:08,180
you don't need any extra layers for a

00:09:03,000 --> 00:09:11,430
developing go code and then we did some

00:09:08,180 --> 00:09:15,000
more tests using cocteau so been we've

00:09:11,430 --> 00:09:16,830
been checking like image size then image

00:09:15,000 --> 00:09:19,100
size with network stack because we knew

00:09:16,830 --> 00:09:22,100
that only some kind of network

00:09:19,100 --> 00:09:24,520
connectivity and then we've been also

00:09:22,100 --> 00:09:29,020
discussing how we are delivery

00:09:24,520 --> 00:09:31,360
the and artifact devices so Yocto is can

00:09:29,020 --> 00:09:32,860
be actually statically compiled to the

00:09:31,360 --> 00:09:35,860
single binary so we don't need any

00:09:32,860 --> 00:09:38,460
virtual machines and any extra

00:09:35,860 --> 00:09:41,410
dependencies running on your device to

00:09:38,460 --> 00:09:47,740
use the the go code you've been

00:09:41,410 --> 00:09:51,030
developing and after heated discussions

00:09:47,740 --> 00:09:56,590
we finally decided that we'll go with go

00:09:51,030 --> 00:09:58,990
so the main reasons were that go is

00:09:56,590 --> 00:10:01,960
having extremely reached standard

00:09:58,990 --> 00:10:04,630
library so a lot of features there and

00:10:01,960 --> 00:10:07,270
it allows fast development of

00:10:04,630 --> 00:10:10,620
applications then in turn out that

00:10:07,270 --> 00:10:13,900
learning curve from C to go lonk is not

00:10:10,620 --> 00:10:15,930
very steep and in fact from C go is

00:10:13,900 --> 00:10:20,070
inheriting a lot of things like

00:10:15,930 --> 00:10:24,820
expression syntax control for statements

00:10:20,070 --> 00:10:30,220
data structures pointers passing by

00:10:24,820 --> 00:10:34,030
value called by value parameter parsing

00:10:30,220 --> 00:10:37,240
so a lot of things and also if you know

00:10:34,030 --> 00:10:42,430
Python like string handling is kind of

00:10:37,240 --> 00:10:45,190
like Python ease and go is also compiled

00:10:42,430 --> 00:10:48,010
language so go is having optimized

00:10:45,190 --> 00:10:52,300
compiler and runs natively on embedded

00:10:48,010 --> 00:10:55,110
devices can be statically linked I'll

00:10:52,300 --> 00:10:58,420
expand on this a little bit later and

00:10:55,110 --> 00:11:02,290
then there is really nice coverage for a

00:10:58,420 --> 00:11:05,290
cross compilation and we've been also

00:11:02,290 --> 00:11:07,360
doing some tests with size of go

00:11:05,290 --> 00:11:11,140
application and we've been trying to

00:11:07,360 --> 00:11:13,180
compare it with static C binaries so as

00:11:11,140 --> 00:11:16,990
you'll see there are not such a big

00:11:13,180 --> 00:11:20,110
differences and we've been also fairly

00:11:16,990 --> 00:11:22,330
important thing for us was that we could

00:11:20,110 --> 00:11:23,620
develop both backends and the client in

00:11:22,330 --> 00:11:25,560
the same language so we've been

00:11:23,620 --> 00:11:30,900
discussing all the possibilities of like

00:11:25,560 --> 00:11:34,180
sharing the code sharing developers and

00:11:30,900 --> 00:11:38,080
I'll expand a little bit on both size

00:11:34,180 --> 00:11:42,540
and performance of go application so

00:11:38,080 --> 00:11:45,070
the first example here is the smallest

00:11:42,540 --> 00:11:48,160
application you can write it's hello

00:11:45,070 --> 00:11:53,140
world and it's using built-in print line

00:11:48,160 --> 00:11:57,880
function and after stripping debugging

00:11:53,140 --> 00:12:01,150
symbols it's 600 kilobytes so this is

00:11:57,880 --> 00:12:05,230
basically what's the go runtime overhead

00:12:01,150 --> 00:12:07,780
ease but if you are trying to write like

00:12:05,230 --> 00:12:10,560
through hello world application what

00:12:07,780 --> 00:12:14,290
you'll do is you'll include fund package

00:12:10,560 --> 00:12:16,090
so then the binary is much bigger but

00:12:14,290 --> 00:12:19,030
font package is having a lot of

00:12:16,090 --> 00:12:21,370
dependencies so like 10 each packages

00:12:19,030 --> 00:12:26,020
are included when you are compiling the

00:12:21,370 --> 00:12:28,410
code we've found package included and to

00:12:26,020 --> 00:12:30,820
compare with see if you are building

00:12:28,410 --> 00:12:34,300
dynamically linked library then it's

00:12:30,820 --> 00:12:36,280
really tiny like 8 kilobytes but

00:12:34,300 --> 00:12:39,880
obviously it has a lot of dependencies

00:12:36,280 --> 00:12:42,820
and if you do the same

00:12:39,880 --> 00:12:45,490
static abstract from the fact if it's

00:12:42,820 --> 00:12:47,500
good idea or not then it's it's bigger

00:12:45,490 --> 00:12:51,670
so after stripping debugging symbols

00:12:47,500 --> 00:12:56,290
it's 800 kilobytes so even bigger than

00:12:51,670 --> 00:13:01,150
don't go binary and then a little bit on

00:12:56,290 --> 00:13:04,360
go speed so initially the title of this

00:13:01,150 --> 00:13:08,200
side was performance but I'm going to

00:13:04,360 --> 00:13:10,200
talk about the speed in general so if

00:13:08,200 --> 00:13:12,790
you are interested in a performance then

00:13:10,200 --> 00:13:16,030
maybe you're familiar with this computer

00:13:12,790 --> 00:13:19,420
language benchmarks game so you can

00:13:16,030 --> 00:13:21,310
follow the link and see the detailed

00:13:19,420 --> 00:13:24,310
benchmarks of various programming

00:13:21,310 --> 00:13:26,950
languages so you can see how go compares

00:13:24,310 --> 00:13:32,410
to other languages how's doing with

00:13:26,950 --> 00:13:35,020
executing various algorithms but in

00:13:32,410 --> 00:13:38,970
general goal is fully garbage collected

00:13:35,020 --> 00:13:42,940
so this slows down living things and

00:13:38,970 --> 00:13:46,210
there are ways to switch the garbage

00:13:42,940 --> 00:13:48,310
collection of but I'm not experimenting

00:13:46,210 --> 00:13:50,680
with this stuff and I'm not sure if it's

00:13:48,310 --> 00:13:54,880
a good idea

00:13:50,680 --> 00:13:58,930
then you cannot really say where the

00:13:54,880 --> 00:14:00,550
variable will be allocated so we see you

00:13:58,930 --> 00:14:01,990
can decide that you want to allocate the

00:14:00,550 --> 00:14:04,899
variables on the stack or on the heap

00:14:01,990 --> 00:14:07,089
with go compiler is trying to make some

00:14:04,899 --> 00:14:10,180
educated decision where the variable

00:14:07,089 --> 00:14:12,399
should be you can see where the variable

00:14:10,180 --> 00:14:15,339
will be allocated if you pass correct

00:14:12,399 --> 00:14:18,100
build flags but you cannot force

00:14:15,339 --> 00:14:22,420
compiler to use the like stack only for

00:14:18,100 --> 00:14:25,959
example but on the pros go is providing

00:14:22,420 --> 00:14:29,200
really extremely fast compilation so our

00:14:25,959 --> 00:14:31,570
source code for example is 15,000 lines

00:14:29,200 --> 00:14:34,209
of code it's the client only and a

00:14:31,570 --> 00:14:38,800
complete compilation takes like 1.4

00:14:34,209 --> 00:14:41,830
seconds and if you're doing some kind of

00:14:38,800 --> 00:14:44,320
like concurrent programming then go is

00:14:41,830 --> 00:14:46,540
really well designed for for doing this

00:14:44,320 --> 00:14:49,870
it's very easy and it's very Performa

00:14:46,540 --> 00:14:51,279
below and then the thing we've been

00:14:49,870 --> 00:14:54,370
discussing caller ID like the speed of

00:14:51,279 --> 00:14:56,080
developer so I really do think that go

00:14:54,370 --> 00:14:59,640
is productive language and you can

00:14:56,080 --> 00:15:02,709
develop your applications fast so

00:14:59,640 --> 00:15:05,440
turning your attention on go itself

00:15:02,709 --> 00:15:07,080
we'll talk about couple of things why I

00:15:05,440 --> 00:15:10,860
like go

00:15:07,080 --> 00:15:15,430
so among the others the standard library

00:15:10,860 --> 00:15:18,670
so go is the standard library is having

00:15:15,430 --> 00:15:25,110
like more than hundred packages and just

00:15:18,670 --> 00:15:28,360
naming the few like runtime you can like

00:15:25,110 --> 00:15:31,140
set some runtime things like garbage

00:15:28,360 --> 00:15:34,390
collection you can switch it off you can

00:15:31,140 --> 00:15:36,910
select how many threats you want to

00:15:34,390 --> 00:15:40,570
always threats you want to use then flag

00:15:36,910 --> 00:15:42,550
for using for building command line

00:15:40,570 --> 00:15:44,770
interfaces for parsing comm line

00:15:42,550 --> 00:15:49,180
arguments net for any network

00:15:44,770 --> 00:15:52,209
communication then various data types

00:15:49,180 --> 00:15:55,000
with an encoding package really rich

00:15:52,209 --> 00:15:58,930
crypto package so a lot of things you

00:15:55,000 --> 00:16:01,000
can do there then unsafe and cisco at

00:15:58,930 --> 00:16:03,059
the end very useful if you are doing any

00:16:01,000 --> 00:16:07,769
kind of like embedded is

00:16:03,059 --> 00:16:12,089
development then go comes with a lot of

00:16:07,769 --> 00:16:16,049
building tools like fund for formatting

00:16:12,089 --> 00:16:20,419
the code so go forces you to use some

00:16:16,049 --> 00:16:22,919
and only one correct coding standard

00:16:20,419 --> 00:16:26,059
then there is test package we've

00:16:22,919 --> 00:16:31,619
discovered some profiling tool go doc

00:16:26,059 --> 00:16:33,599
for creating documentation from inline

00:16:31,619 --> 00:16:36,659
code comments so it's kind of similar

00:16:33,599 --> 00:16:39,299
like doxygen then go vet for doing

00:16:36,659 --> 00:16:41,939
static code analysis raise detector and

00:16:39,299 --> 00:16:46,409
really many more there's there is lot of

00:16:41,939 --> 00:16:49,589
tools coming with go by default and then

00:16:46,409 --> 00:16:52,229
a little bit on computation itself so

00:16:49,589 --> 00:16:55,769
there are two Co compilers you can use

00:16:52,229 --> 00:16:59,129
the original one is called GC and it's

00:16:55,769 --> 00:17:02,609
written and maintained by Google it's

00:16:59,129 --> 00:17:05,399
part of of default go installation but

00:17:02,609 --> 00:17:10,679
there is also GCC go which is front-end

00:17:05,399 --> 00:17:15,449
for GCC and this one works fairly nice

00:17:10,679 --> 00:17:18,089
but is lagging a little bit behind GC so

00:17:15,449 --> 00:17:20,279
right now GCC 7 supports go one point

00:17:18,089 --> 00:17:23,129
eight point one but I think this you see

00:17:20,279 --> 00:17:27,659
eight will support go one point 10 so

00:17:23,129 --> 00:17:29,190
it's not very far behind GC and as I

00:17:27,659 --> 00:17:31,169
mentioned already compilation is

00:17:29,190 --> 00:17:35,070
extremely fast and this was one of the

00:17:31,169 --> 00:17:39,929
principles of creating go then you can

00:17:35,070 --> 00:17:41,730
create single binary file no extra

00:17:39,929 --> 00:17:44,850
dependencies no virtual machines but

00:17:41,730 --> 00:17:47,700
we'll talk about this a little bit later

00:17:44,850 --> 00:17:50,909
as well and you can still use make files

00:17:47,700 --> 00:17:55,379
if you want so the link shows an example

00:17:50,909 --> 00:17:57,929
of our make file we are using and cross

00:17:55,379 --> 00:18:00,899
compilation so a lot of platforms

00:17:57,929 --> 00:18:03,600
supported so to cross compile the go

00:18:00,899 --> 00:18:06,600
application you need to like set two

00:18:03,600 --> 00:18:11,309
flags go S which is operating system and

00:18:06,600 --> 00:18:14,540
go arc and then just type go build and

00:18:11,309 --> 00:18:20,300
it will cross compile the binary for a

00:18:14,540 --> 00:18:24,370
even OS and given architecture so quite

00:18:20,300 --> 00:18:29,360
wide selection of both Isis and and

00:18:24,370 --> 00:18:33,650
platforms supported then a little bit on

00:18:29,360 --> 00:18:36,740
debugging so you can still use gdb if

00:18:33,650 --> 00:18:40,700
you want but there are some corner cases

00:18:36,740 --> 00:18:44,450
where jilebi don't work extremely nice

00:18:40,700 --> 00:18:47,530
with go particularly heavy concurrent

00:18:44,450 --> 00:18:51,740
applications gdb is having some issues

00:18:47,530 --> 00:18:55,310
when trying to debug those but there is

00:18:51,740 --> 00:18:58,160
dedicated go compiler called delve very

00:18:55,310 --> 00:19:04,190
similar to gdb almost the same user

00:18:58,160 --> 00:19:07,460
interface then testing it's extremely

00:19:04,190 --> 00:19:09,680
easy to add unit tests and benchmarks to

00:19:07,460 --> 00:19:12,710
go code so testing is built in the

00:19:09,680 --> 00:19:17,120
language and all you need is to create a

00:19:12,710 --> 00:19:20,720
file with a test suffix and then at a

00:19:17,120 --> 00:19:23,480
test prefix to your function import

00:19:20,720 --> 00:19:26,240
testing package and then the only thing

00:19:23,480 --> 00:19:27,890
you need to do is run go test and all

00:19:26,240 --> 00:19:32,050
your tests will be automatically picked

00:19:27,890 --> 00:19:35,330
up from your source and execute it so

00:19:32,050 --> 00:19:38,300
right now I'll go very quickly through

00:19:35,330 --> 00:19:41,840
some code samples so you can find it in

00:19:38,300 --> 00:19:45,160
many places but just to give you some

00:19:41,840 --> 00:19:47,690
overview how goes index looks like so

00:19:45,160 --> 00:19:50,450
here you can see how to declare

00:19:47,690 --> 00:19:54,350
variables and variables are pretty much

00:19:50,450 --> 00:19:57,680
the same as in in C the basic ones so

00:19:54,350 --> 00:20:00,140
it's different is at the end you have

00:19:57,680 --> 00:20:02,960
this F colon equals one so this is like

00:20:00,140 --> 00:20:05,390
shortened syntax for declaring variables

00:20:02,960 --> 00:20:08,630
and then you can do like topple

00:20:05,390 --> 00:20:14,690
assignments so multiple variables having

00:20:08,630 --> 00:20:16,400
multiple values functions I guess what I

00:20:14,690 --> 00:20:18,380
want to emphasize here is that you can

00:20:16,400 --> 00:20:21,380
have multiple return values which is

00:20:18,380 --> 00:20:24,550
very useful so you can return the value

00:20:21,380 --> 00:20:24,550
and error for example

00:20:25,110 --> 00:20:32,310
yeah we are using this this a lot

00:20:28,710 --> 00:20:34,140
then go is not object-oriented language

00:20:32,310 --> 00:20:37,530
or at least this is something that

00:20:34,140 --> 00:20:41,340
Google guys are claiming but there are

00:20:37,530 --> 00:20:44,070
some object-oriented principles in the

00:20:41,340 --> 00:20:47,670
language so you can create a struct and

00:20:44,070 --> 00:20:53,190
then you can create a method on distract

00:20:47,670 --> 00:20:56,640
so the func s square yuria so square is

00:20:53,190 --> 00:21:00,330
a receiver so it's kind of like this

00:20:56,640 --> 00:21:05,120
pointer in C++ so you can call this

00:21:00,330 --> 00:21:11,240
function on the square object and

00:21:05,120 --> 00:21:15,900
interfaces are also some kind of like

00:21:11,240 --> 00:21:17,760
object-oriented principle so those are

00:21:15,900 --> 00:21:20,550
not defined explicitly like in Java for

00:21:17,760 --> 00:21:25,400
example like this object implements this

00:21:20,550 --> 00:21:25,400
interface so in go

00:21:26,340 --> 00:21:35,790
if type has given function it satisfies

00:21:33,030 --> 00:21:38,580
the interface implicitly and then you

00:21:35,790 --> 00:21:42,090
can have like if you see the main

00:21:38,580 --> 00:21:44,370
snippet you can call the function on

00:21:42,090 --> 00:21:46,110
behalf of the interface so you don't

00:21:44,370 --> 00:21:48,300
necessarily know in the runtime what

00:21:46,110 --> 00:21:51,720
kind of object what kind of type this is

00:21:48,300 --> 00:21:53,640
but as long as it implements the print

00:21:51,720 --> 00:21:56,540
function then it satisfies the print

00:21:53,640 --> 00:22:00,690
interface and you can use it dynamically

00:21:56,540 --> 00:22:04,200
and then a little bit on concurrency so

00:22:00,690 --> 00:22:06,410
go is having two built-in mechanisms the

00:22:04,200 --> 00:22:11,100
routines and channels so goroutines are

00:22:06,410 --> 00:22:13,340
kind of like lightweight threads but the

00:22:11,100 --> 00:22:16,350
initial size is only two kilobytes and

00:22:13,340 --> 00:22:21,510
go is having its own internal scheduler

00:22:16,350 --> 00:22:24,210
so goroutines are multiplexed like m2 n2

00:22:21,510 --> 00:22:29,700
OS threads and then there are channels

00:22:24,210 --> 00:22:32,220
so those are like pipes for exchanging

00:22:29,700 --> 00:22:37,549
messages between various cover teens and

00:22:32,220 --> 00:22:41,870
you can have blocked and non blocking

00:22:37,549 --> 00:22:46,080
buffered unbuffered very useful way of

00:22:41,870 --> 00:22:48,600
exchanging messages and those are used a

00:22:46,080 --> 00:22:51,030
lot for us synchronizing the threads the

00:22:48,600 --> 00:22:53,940
go routines as well and it's very easy

00:22:51,030 --> 00:22:56,190
to create a goroutine the only thing you

00:22:53,940 --> 00:22:58,980
need to do is to add the goal in front

00:22:56,190 --> 00:23:01,980
of the function and when you do this the

00:22:58,980 --> 00:23:05,010
function is executed concurrently and

00:23:01,980 --> 00:23:07,200
the channel is also very easy to create

00:23:05,010 --> 00:23:10,290
it's make John and the type of the

00:23:07,200 --> 00:23:12,270
channel and then there are two operators

00:23:10,290 --> 00:23:14,940
to write to the channel it's this like

00:23:12,270 --> 00:23:22,370
our to the channel and then to read from

00:23:14,940 --> 00:23:27,929
the channel so you can also use your C

00:23:22,370 --> 00:23:30,809
code with go so there are some bindings

00:23:27,929 --> 00:23:33,570
for C applications so the only thing you

00:23:30,809 --> 00:23:37,890
need to do is import C and then go is

00:23:33,570 --> 00:23:40,110
creating this virtual C package so when

00:23:37,890 --> 00:23:42,450
you are using any packets in go the

00:23:40,110 --> 00:23:45,030
syntax is like package name dot and the

00:23:42,450 --> 00:23:48,480
method or the like type from the package

00:23:45,030 --> 00:23:53,100
so it's the same with C so if you're

00:23:48,480 --> 00:23:56,730
using C packets then you're like calling

00:23:53,100 --> 00:24:00,630
C dot something to do some C function

00:23:56,730 --> 00:24:01,559
and quite important note here is that go

00:24:00,630 --> 00:24:04,169
is garbage-collected

00:24:01,559 --> 00:24:07,400
but see it's not so if you're using any

00:24:04,169 --> 00:24:10,950
c variables in a go code which are

00:24:07,400 --> 00:24:14,790
allocated on the heap inside c code you

00:24:10,950 --> 00:24:20,840
need to explicitly free those variables

00:24:14,790 --> 00:24:24,390
inside go and then you can also use C++

00:24:20,840 --> 00:24:26,490
inside go code I haven't been using this

00:24:24,390 --> 00:24:29,429
myself but there is this simplified

00:24:26,490 --> 00:24:34,710
wrapper and interface generator so this

00:24:29,429 --> 00:24:38,429
was created to kind of bind C and C++

00:24:34,710 --> 00:24:41,330
with languages like Python for example

00:24:38,429 --> 00:24:45,120
interpreted languages so there is also

00:24:41,330 --> 00:24:50,520
go module to c plus path so we can use

00:24:45,120 --> 00:24:53,940
C++ inside go code and then I said that

00:24:50,520 --> 00:24:59,820
go is compiled to a single binary but

00:24:53,940 --> 00:25:03,810
you can also use the shared libraries so

00:24:59,820 --> 00:25:08,000
it's working on x86 architecture only at

00:25:03,810 --> 00:25:11,010
the moment but you can both create like

00:25:08,000 --> 00:25:13,740
go shared library that will be used

00:25:11,010 --> 00:25:15,510
inside C code and you can create like

00:25:13,740 --> 00:25:19,620
goal shared library that you can use

00:25:15,510 --> 00:25:21,270
inside other go applications so very

00:25:19,620 --> 00:25:24,030
useful when for example you want to

00:25:21,270 --> 00:25:25,910
replace only a parts of your C

00:25:24,030 --> 00:25:29,700
application so you can easily create

00:25:25,910 --> 00:25:32,220
shared goal library and then you can use

00:25:29,700 --> 00:25:37,920
this library include this library and

00:25:32,220 --> 00:25:43,500
link against your C application and a

00:25:37,920 --> 00:25:47,840
little bit on embedded go so I as I said

00:25:43,500 --> 00:25:51,360
before you cannot really force go to

00:25:47,840 --> 00:25:53,660
like you stack only or you cannot say

00:25:51,360 --> 00:25:59,340
where the variable will be allocated but

00:25:53,660 --> 00:26:02,820
you can see if you provide this - juicy

00:25:59,340 --> 00:26:06,390
talks - M arguments where the variable

00:26:02,820 --> 00:26:09,030
will be allocated so go is based on the

00:26:06,390 --> 00:26:12,650
size of the object and go is doing

00:26:09,030 --> 00:26:15,750
something called escape analyzes to see

00:26:12,650 --> 00:26:19,080
it tries to avoid dangling pointers so

00:26:15,750 --> 00:26:20,670
you can have a local variable inside a

00:26:19,080 --> 00:26:23,100
function but you can return this

00:26:20,670 --> 00:26:25,320
variable so in C you'll have a dangling

00:26:23,100 --> 00:26:27,030
pointer we've go go is trying to be

00:26:25,320 --> 00:26:28,920
smart enough to allocate this variable

00:26:27,030 --> 00:26:31,560
on the heap and then inside our

00:26:28,920 --> 00:26:36,810
functions you can still reference that

00:26:31,560 --> 00:26:39,720
variable and then unsafe code so if you

00:26:36,810 --> 00:26:42,870
want to write something directly to

00:26:39,720 --> 00:26:46,350
memory in C you can whatever you like

00:26:42,870 --> 00:26:49,740
the syntax or not you can use it but in

00:26:46,350 --> 00:26:52,950
go it's also possible to manipulate

00:26:49,740 --> 00:26:59,480
Hardware directly but it's intentionally

00:26:52,950 --> 00:27:02,490
hard so here is the sample of

00:26:59,480 --> 00:27:07,590
manipulating GPIO Raspberry Pi and its

00:27:02,490 --> 00:27:12,030
memory mapped GPIO so as you can see you

00:27:07,590 --> 00:27:15,060
can access call map and then map the

00:27:12,030 --> 00:27:19,170
file and then you're using a lot of like

00:27:15,060 --> 00:27:22,620
unsaved pointer things to to address

00:27:19,170 --> 00:27:26,610
memory directly so it's there it's

00:27:22,620 --> 00:27:32,670
possible it's also not pretty but but

00:27:26,610 --> 00:27:35,010
you can use it and I would like to talk

00:27:32,670 --> 00:27:41,190
a bit about our experience with go so

00:27:35,010 --> 00:27:45,350
far so there is a lot of like positive

00:27:41,190 --> 00:27:48,900
things about go we like but there also

00:27:45,350 --> 00:27:52,950
like things I personally think could be

00:27:48,900 --> 00:27:55,740
done better so when you are using

00:27:52,950 --> 00:27:58,850
third-party libraries there is no

00:27:55,740 --> 00:28:01,620
standardized tool for for this so

00:27:58,850 --> 00:28:06,510
there's plenty of third-party tools for

00:28:01,620 --> 00:28:10,110
rendering external dependencies a little

00:28:06,510 --> 00:28:13,230
bit messy could be improved but I think

00:28:10,110 --> 00:28:16,830
go guys are working on this actively to

00:28:13,230 --> 00:28:19,740
create some built-in tools for for

00:28:16,830 --> 00:28:22,770
fixing this issue then there is quite a

00:28:19,740 --> 00:28:27,300
lot external libraries out there but

00:28:22,770 --> 00:28:28,890
there is a lot of really bad ones so you

00:28:27,300 --> 00:28:33,360
need to be very careful what kind of

00:28:28,890 --> 00:28:36,450
libraries you're using and then when we

00:28:33,360 --> 00:28:41,060
started with go and the octo we've been

00:28:36,450 --> 00:28:45,480
having some issue with like building

00:28:41,060 --> 00:28:49,860
octo images because you're close not

00:28:45,480 --> 00:28:54,090
supporting go natively so we had to use

00:28:49,860 --> 00:28:57,380
some third-party layers to build go code

00:28:54,090 --> 00:28:59,790
we've been fixing those layers a lot

00:28:57,380 --> 00:29:02,640
because not everything was working out

00:28:59,790 --> 00:29:05,520
of the box for us and then before we go

00:29:02,640 --> 00:29:07,560
on point five there's been also like

00:29:05,520 --> 00:29:11,640
issue with bootstrapping the go code so

00:29:07,560 --> 00:29:13,320
it wasn't like extremely walk in the

00:29:11,640 --> 00:29:16,950
park to build the go binary

00:29:13,320 --> 00:29:18,690
but right now go layer is integrated

00:29:16,950 --> 00:29:20,519
with Yocto so all the issues we've been

00:29:18,690 --> 00:29:24,630
facing at the very beginning two years

00:29:20,519 --> 00:29:26,399
ago are gone right now and I've been

00:29:24,630 --> 00:29:29,880
also mentioning about like extremely

00:29:26,399 --> 00:29:33,169
nice compiling and cross compiling so

00:29:29,880 --> 00:29:36,210
this is gone when you're using C go so

00:29:33,169 --> 00:29:41,070
when you have some C bindings inside

00:29:36,210 --> 00:29:45,830
your go code then it's not as easily as

00:29:41,070 --> 00:29:48,509
as when building go only applications so

00:29:45,830 --> 00:29:53,279
when you have C bindings then you need

00:29:48,509 --> 00:29:55,289
to provide all like C infrastructure

00:29:53,279 --> 00:30:01,259
cross compiler and stuff for for

00:29:55,289 --> 00:30:04,220
building C part of coop Legation but at

00:30:01,259 --> 00:30:08,879
the same time there is a lot of things

00:30:04,220 --> 00:30:13,879
that we like in go so it was very easy

00:30:08,879 --> 00:30:17,669
to do the transition from C and Python

00:30:13,879 --> 00:30:20,669
so it's like literally took a couple of

00:30:17,669 --> 00:30:25,470
days to be fairly productive with go and

00:30:20,669 --> 00:30:27,659
then we are using go tools and standard

00:30:25,470 --> 00:30:31,350
library a lot and those are really nice

00:30:27,659 --> 00:30:34,950
tools so we are not in fact using a lot

00:30:31,350 --> 00:30:38,759
of external tools for doing the stuff we

00:30:34,950 --> 00:30:40,759
need and we've been also discussing at

00:30:38,759 --> 00:30:44,220
the beginning before we started

00:30:40,759 --> 00:30:46,470
developing our product ingo that we'll

00:30:44,220 --> 00:30:48,840
be able to exchange some kind of tasks

00:30:46,470 --> 00:30:52,679
between pack and team and a client team

00:30:48,840 --> 00:30:55,350
this hasn't happened a lot but we have

00:30:52,679 --> 00:30:58,850
some shared libraries we are using our

00:30:55,350 --> 00:31:02,399
shared code bases and we've been able to

00:30:58,850 --> 00:31:04,620
use a lot of infrastructure so for

00:31:02,399 --> 00:31:06,450
example CIE looks more or less the same

00:31:04,620 --> 00:31:09,919
for the back end and for the client with

00:31:06,450 --> 00:31:12,750
some you know like small differences and

00:31:09,919 --> 00:31:16,110
I really do think that go is very

00:31:12,750 --> 00:31:18,450
productive language so if you need to

00:31:16,110 --> 00:31:20,639
develop your application fast and if you

00:31:18,450 --> 00:31:22,889
need to include some kind of network

00:31:20,639 --> 00:31:24,320
communication then it's it's very

00:31:22,889 --> 00:31:29,000
productive

00:31:24,320 --> 00:31:30,620
and this is kind of like mixed feeling

00:31:29,000 --> 00:31:32,509
the last point so a lot of people

00:31:30,620 --> 00:31:34,480
disagree with this and a lot of people

00:31:32,509 --> 00:31:37,399
don't like this but I really think that

00:31:34,480 --> 00:31:40,909
first cutting standard is a really nice

00:31:37,399 --> 00:31:42,950
idea because like no matter what kind of

00:31:40,909 --> 00:31:46,309
code you are looking at it's always the

00:31:42,950 --> 00:31:48,830
same it looks the same so and also you

00:31:46,309 --> 00:31:50,990
don't have to spend like hours before

00:31:48,830 --> 00:31:54,529
you start developing should we use this

00:31:50,990 --> 00:31:57,889
coding standard or something else it's

00:31:54,529 --> 00:32:00,799
there it's only one way of developing

00:31:57,889 --> 00:32:04,970
applications in go and its first so it's

00:32:00,799 --> 00:32:07,669
very easy to read the code and right now

00:32:04,970 --> 00:32:11,120
we have still like 10 minutes so I'll

00:32:07,669 --> 00:32:16,669
try to show you demo of a medical

00:32:11,120 --> 00:32:19,519
application so I'm having here a

00:32:16,669 --> 00:32:23,059
BeagleBone we've probably it's hard to

00:32:19,519 --> 00:32:26,600
see at the back but I'm having dht11

00:32:23,059 --> 00:32:28,940
like temperature and humidity sensor and

00:32:26,600 --> 00:32:32,149
then I'm having infrared distance sensor

00:32:28,940 --> 00:32:33,590
here and a small butter as well it was

00:32:32,149 --> 00:32:44,029
disconnected from the power but maybe

00:32:33,590 --> 00:32:49,309
I'll connect it now and I'm running here

00:32:44,029 --> 00:32:53,210
a link application that experts all the

00:32:49,309 --> 00:32:55,190
readings through web interface so we can

00:32:53,210 --> 00:32:57,490
see how this works we can take a look at

00:32:55,190 --> 00:32:57,490
the code

00:33:12,690 --> 00:33:17,619
so this is how I'm compiling my

00:33:15,489 --> 00:33:20,259
application so if you are familiar with

00:33:17,619 --> 00:33:24,070
Yocto it's very standard we don't need

00:33:20,259 --> 00:33:26,139
any extra go layers right now any extra

00:33:24,070 --> 00:33:27,729
commands it's like feedback and I'm

00:33:26,139 --> 00:33:31,659
building an image for my application

00:33:27,729 --> 00:33:33,789
it's taking a while so maybe while it's

00:33:31,659 --> 00:33:36,570
building I will show you a little bit of

00:33:33,789 --> 00:33:36,570
source code

00:34:00,980 --> 00:34:11,030
so this is may not go file so it's like

00:34:05,630 --> 00:34:14,119
first file that it's compiled or inside

00:34:11,030 --> 00:34:15,829
this file go is looking for the main

00:34:14,119 --> 00:34:23,510
function so this is where everything

00:34:15,829 --> 00:34:27,589
starts so here I'm initializing some

00:34:23,510 --> 00:34:31,250
in-memory store for like storing a

00:34:27,589 --> 00:34:39,940
couple of last readings and then we are

00:34:31,250 --> 00:34:42,740
creating a channel for reading data from

00:34:39,940 --> 00:34:46,750
humidity and temperature sensor and then

00:34:42,740 --> 00:34:50,450
this you can see go here so this is

00:34:46,750 --> 00:34:55,760
co-routine so functions run concurrently

00:34:50,450 --> 00:35:01,970
and this function is waiting blocked

00:34:55,760 --> 00:35:04,520
waiting for the data from this dht11

00:35:01,970 --> 00:35:09,410
sensor and then stores the data inside

00:35:04,520 --> 00:35:15,319
the memory and then this coverage tht

00:35:09,410 --> 00:35:21,010
function defined later is actually

00:35:15,319 --> 00:35:21,010
calling read humid temp so

00:35:34,310 --> 00:35:42,170
this HIO model is the one created with C

00:35:40,160 --> 00:35:46,700
go so I'm having a couple of C and H

00:35:42,170 --> 00:35:51,260
files and here the HT go

00:35:46,700 --> 00:35:55,550
so I'm importing C and for reading the

00:35:51,260 --> 00:35:59,710
data from the dht11 sensor I'm simply

00:35:55,550 --> 00:36:04,880
calling this C function and then I'm

00:35:59,710 --> 00:36:07,070
converting the return values to go ones

00:36:04,880 --> 00:36:13,030
and I'm returning this from the function

00:36:07,070 --> 00:36:19,960
so quite easy to do this stuff and

00:36:13,030 --> 00:36:19,960
where's my mouse here you can see also

00:36:20,650 --> 00:36:30,590
how easy it is to start a web server so

00:36:26,360 --> 00:36:33,620
the start server you are creating a

00:36:30,590 --> 00:36:36,740
handlers so what kind of functions will

00:36:33,620 --> 00:36:40,760
be executed when different reg X will be

00:36:36,740 --> 00:36:43,130
matched and then the only thing you need

00:36:40,760 --> 00:36:51,260
to do is listen and surf and provide the

00:36:43,130 --> 00:36:54,320
port on which your listening so my

00:36:51,260 --> 00:36:57,050
application is is built so now I can

00:36:54,320 --> 00:37:01,600
update my device to like start this

00:36:57,050 --> 00:37:01,600
application so to do this

00:37:13,670 --> 00:37:17,380
to do this I will use men there

00:37:28,320 --> 00:37:35,400
so I can see I have a couple of devices

00:37:30,360 --> 00:37:37,670
here so I'm accepting my device and once

00:37:35,400 --> 00:37:44,640
it will be authorized I'll be able to

00:37:37,670 --> 00:37:46,440
create a update for this device so this

00:37:44,640 --> 00:37:48,800
is my below but BeagleBone and it's

00:37:46,440 --> 00:37:54,210
running release to you at the moment and

00:37:48,800 --> 00:38:07,560
first I need to upload artifact so it

00:37:54,210 --> 00:38:10,890
will be this one okay then devices again

00:38:07,560 --> 00:38:13,280
and I want to create a deployment for

00:38:10,890 --> 00:38:13,280
this device

00:38:20,460 --> 00:38:27,250
okay now deployment spending so device

00:38:23,140 --> 00:38:29,410
will first try to connect with the

00:38:27,250 --> 00:38:32,650
server and figure out that okay there is

00:38:29,410 --> 00:38:35,109
deployment for this device and right now

00:38:32,650 --> 00:38:37,390
it's downloading the image so it

00:38:35,109 --> 00:38:40,089
probably should take like less than a

00:38:37,390 --> 00:38:44,380
second I'm gonna local network I could

00:38:40,089 --> 00:38:46,359
do SSH as well to copy the binary but in

00:38:44,380 --> 00:38:48,819
this particular case the device is here

00:38:46,359 --> 00:38:52,480
so I can do like even as the image CD

00:38:48,819 --> 00:38:54,849
and then copy to the SD card but usually

00:38:52,480 --> 00:38:56,950
in our CI for example the devices are

00:38:54,849 --> 00:38:58,990
out there somewhere so this is the way

00:38:56,950 --> 00:39:03,280
we are updating the devices to test the

00:38:58,990 --> 00:39:06,389
applications and our application as well

00:39:03,280 --> 00:39:06,389
[Music]

00:39:06,569 --> 00:39:12,280
so the whole image is is pretty big

00:39:10,200 --> 00:39:19,930
probably that's why it's taking some

00:39:12,280 --> 00:39:22,420
time to download it but once device will

00:39:19,930 --> 00:39:26,430
be once it will download the image it

00:39:22,420 --> 00:39:28,809
will reboot the device because it's like

00:39:26,430 --> 00:39:30,190
copied to inactive producing device is

00:39:28,809 --> 00:39:33,520
having two operations active and

00:39:30,190 --> 00:39:36,280
inactive and then this is for doing some

00:39:33,520 --> 00:39:38,849
kind of like failover if something goes

00:39:36,280 --> 00:39:38,849
bad

00:39:56,420 --> 00:40:01,660
regardless hope you'll finish in a

00:39:58,970 --> 00:40:01,660
result I'm

00:40:18,980 --> 00:40:27,079
okay you can see this sound so devices

00:40:23,500 --> 00:40:30,970
is running with a new image may well

00:40:27,079 --> 00:40:30,970
disconnect this for a second

00:40:31,450 --> 00:40:36,410
so device is ruling right now and once

00:40:34,310 --> 00:40:38,690
you've Isis tributed will see that the

00:40:36,410 --> 00:40:41,119
new applications is new application is

00:40:38,690 --> 00:40:46,070
in solin device and i will show you what

00:40:41,119 --> 00:40:49,060
this application is doing so let's give

00:40:46,070 --> 00:40:50,300
it like a couple more seconds okay

00:40:49,060 --> 00:40:58,180
success

00:40:50,300 --> 00:41:01,460
so device is updated and right now I can

00:40:58,180 --> 00:41:04,820
ok so right now we can see the latest

00:41:01,460 --> 00:41:06,680
reading from the dht11 sensor so the

00:41:04,820 --> 00:41:09,680
temperature here is like twenty two

00:41:06,680 --> 00:41:14,900
point eight degrees ounds about right

00:41:09,680 --> 00:41:22,070
and the humidity is 59% we can also see

00:41:14,900 --> 00:41:24,290
like history so this is some graphs how

00:41:22,070 --> 00:41:28,250
temperature and the community was

00:41:24,290 --> 00:41:30,589
changing over time we can do the data

00:41:28,250 --> 00:41:32,569
export for example and this is to show

00:41:30,589 --> 00:41:34,910
how easy it is this was like literally

00:41:32,569 --> 00:41:42,859
three lines to convert the binary data

00:41:34,910 --> 00:41:46,310
to JSON and export it so those are the

00:41:42,859 --> 00:41:49,400
last ten readings of temperature so JSON

00:41:46,310 --> 00:41:56,089
data you can use it in like whatever you

00:41:49,400 --> 00:41:59,329
want and then I have inference distant

00:41:56,089 --> 00:42:01,520
sensor so hopefully if something will be

00:41:59,329 --> 00:42:03,530
in range of the sensors a sensor you'll

00:42:01,520 --> 00:42:07,280
see the red circle and if it's out of

00:42:03,530 --> 00:42:12,200
range then you'll see that the green one

00:42:07,280 --> 00:42:14,980
so let's try okay it's kind of working

00:42:12,200 --> 00:42:17,720
so I'm using WebSockets here so when I

00:42:14,980 --> 00:42:21,550
I'm close to the sensor then you can see

00:42:17,720 --> 00:42:25,790
okay it's there and it's out of range so

00:42:21,550 --> 00:42:28,780
this is basically it so any questions

00:42:25,790 --> 00:42:28,780
comments

00:42:30,150 --> 00:42:33,329
[Music]

00:42:34,590 --> 00:42:44,280
yeah so the question was if the history

00:42:36,510 --> 00:42:47,430
is kept on device yes it's like right

00:42:44,280 --> 00:42:49,410
now I'm having probably like 80 geeks as

00:42:47,430 --> 00:42:53,040
the memory card so quite a lot of

00:42:49,410 --> 00:42:55,860
readings but I've implemented like

00:42:53,040 --> 00:42:57,870
in-memory cyclic buffer for restoring 10

00:42:55,860 --> 00:43:00,150
last measurements but you can use some

00:42:57,870 --> 00:43:01,770
kind of like database for restoring the

00:43:00,150 --> 00:43:29,310
data so it's like actually your

00:43:01,770 --> 00:43:32,130
implementation so the question was about

00:43:29,310 --> 00:43:34,050
crypto librarian go if it's implemented

00:43:32,130 --> 00:43:38,490
by go developers or if they're using

00:43:34,050 --> 00:43:40,800
some third party things so I I think

00:43:38,490 --> 00:43:43,470
it's a mix so some of the things are

00:43:40,800 --> 00:43:47,930
like go natively implemented but there

00:43:43,470 --> 00:43:47,930
are some like bindings to other things

00:43:55,930 --> 00:44:03,940
so question about licensing of go code

00:44:00,090 --> 00:44:06,220
it's some kind of like open-source

00:44:03,940 --> 00:44:10,780
license but I'm not sure about yours

00:44:06,220 --> 00:44:27,150
I think it's GPL three but I might be

00:44:10,780 --> 00:44:30,130
wrong we have a colleague of mine is

00:44:27,150 --> 00:44:32,320
like more into the license and he's

00:44:30,130 --> 00:44:36,360
dealing with this all licensing stuff so

00:44:32,320 --> 00:44:40,530
I'm sure it's sorted out somehow but

00:44:36,360 --> 00:44:40,530
yeah so it's BSD license

00:44:41,140 --> 00:44:44,290
[Music]

00:44:58,079 --> 00:45:04,230
so the question was that my demo is by

00:45:01,230 --> 00:45:06,029
some channels and if it's easy to use

00:45:04,230 --> 00:45:12,029
the channels to communicate with

00:45:06,029 --> 00:45:14,519
external applications so not channels in

00:45:12,029 --> 00:45:16,170
particular but you can use any kind of

00:45:14,519 --> 00:45:18,900
like inter process communication so you

00:45:16,170 --> 00:45:23,150
can use socket or you can use pipe think

00:45:18,900 --> 00:45:25,259
but channels are natively used by

00:45:23,150 --> 00:45:27,539
applications for communicating between

00:45:25,259 --> 00:45:29,009
different go routines so we cannot use

00:45:27,539 --> 00:45:31,730
the channels to communicate with other

00:45:29,009 --> 00:45:31,730
applications

00:45:47,940 --> 00:45:52,260
so the question was I mentioned

00:45:50,700 --> 00:45:54,270
initially that we've been having some

00:45:52,260 --> 00:45:58,800
issues with integrating our code with

00:45:54,270 --> 00:46:03,570
the octo and what's my impression with

00:45:58,800 --> 00:46:05,609
the latest octo releases so it's working

00:46:03,570 --> 00:46:08,510
extremely smoothly we don't have any

00:46:05,609 --> 00:46:20,220
issues with like latest co releases and

00:46:08,510 --> 00:46:22,260
by compiling go code yeah so the

00:46:20,220 --> 00:46:23,609
question was it if if it covers all the

00:46:22,260 --> 00:46:28,800
dependencies we are having in our

00:46:23,609 --> 00:46:32,490
application yes so we are using like

00:46:28,800 --> 00:46:35,369
besides of our extra layers for

00:46:32,490 --> 00:46:37,650
configuring the device we don't need any

00:46:35,369 --> 00:46:41,960
extra layers for compiling both go and

00:46:37,650 --> 00:46:41,960
see bindings we're using inside Co code

00:46:47,480 --> 00:46:57,230
okay any other questions okay thank you

00:46:53,760 --> 00:47:02,820
very much and good luck we go

00:46:57,230 --> 00:47:02,820

YouTube URL: https://www.youtube.com/watch?v=L4LqurhleyE


