Title: An Overview of the Linux Kernel Crypto Subsystem - Boris Brezillon, Free Electrons
Publication date: 2017-10-24
Playlist: Open Source Summit Europe & Embedded Linux Conference Europe 2017
Description: 
	An Overview of the Linux Kernel Crypto Subsystem - Boris Brezillon, Free Electrons

The Linux kernel has long provided cryptographic support for in-kernel users (like the network or storage stacks) and has been pushed to open these cryptographic capabities to user-space along the way.

But what is exactly inside this subsystem, and how can it be used by kernel users? What is the official userspace interface exposing these features and what are non-upstream alternatives? When should we use a HW engine compared to a purely software based implementation? What's inside a crypto engine driver and what precautions should be taken when developing one?

These are some of the questions we'll answer throughout this talk, after having given a short introduction to cryptographic algorithms.

About Boris Brezillon
Since 2014, Boris works at Free Electrons, a company offering development, consulting and training services to embedded Linux system developers worldwide. He has been working on embedded systems since 2008, mostly Linux on ARM. Boris has written and upstreamed a Linux kernel driver for the Marvell CESA cryptographic engine, he is the maintainer of the MTD NAND subsystem, and has contributed to support for Atmel and Allwinner ARM SoCs in the Linux kernel.
Captions: 
	00:00:00,000 --> 00:00:05,430
hello everyone I'm Boris Brazil and I'm

00:00:03,240 --> 00:00:08,670
working for free electron for almost

00:00:05,430 --> 00:00:10,679
four years now as part of my job for

00:00:08,670 --> 00:00:14,340
fragran I'm actually doing a lot of

00:00:10,679 --> 00:00:16,560
stuff around our me associates and one

00:00:14,340 --> 00:00:20,340
of these drivers I have developed for

00:00:16,560 --> 00:00:22,949
Marvel it so see as the Krypton giant

00:00:20,340 --> 00:00:28,710
driver which has what I'm gonna talk

00:00:22,949 --> 00:00:31,710
about today so let's see what we'll see

00:00:28,710 --> 00:00:34,950
during this talk first I'll try to

00:00:31,710 --> 00:00:38,730
introduce various cryptographic concepts

00:00:34,950 --> 00:00:41,489
so this will be a short introduction to

00:00:38,730 --> 00:00:44,640
those conception and I don't pretend to

00:00:41,489 --> 00:00:45,950
be explaining everything about

00:00:44,640 --> 00:00:49,680
cryptography here

00:00:45,950 --> 00:00:52,110
then I'll try to explain what kind of

00:00:49,680 --> 00:00:56,940
services the the crypto the internal

00:00:52,110 --> 00:01:01,440
crypto API provides so you can use those

00:00:56,940 --> 00:01:04,979
services after that will dig a bit into

00:01:01,440 --> 00:01:09,119
the crypto API to develop kryptonite

00:01:04,979 --> 00:01:11,070
driver and finally I'd like to share my

00:01:09,119 --> 00:01:14,070
experience the experience I had while

00:01:11,070 --> 00:01:17,540
developing the the marvel's Krypton

00:01:14,070 --> 00:01:21,840
giant driver so let's start with the

00:01:17,540 --> 00:01:24,299
basic concepts of course if you only

00:01:21,840 --> 00:01:27,030
heard about a Lisa Bob I guess you don't

00:01:24,299 --> 00:01:29,700
need this introduction that further ado

00:01:27,030 --> 00:01:33,450
we would no know these people

00:01:29,700 --> 00:01:36,079
damn I tried to sum up a bit what group

00:01:33,450 --> 00:01:38,820
of the cryptography is about so

00:01:36,079 --> 00:01:41,280
cryptography is about ensuring that a

00:01:38,820 --> 00:01:46,439
communication with two people or more

00:01:41,280 --> 00:01:49,170
than two people is protected and this

00:01:46,439 --> 00:01:52,159
protection is actually separating and

00:01:49,170 --> 00:01:55,290
three main concepts so the first one is

00:01:52,159 --> 00:01:58,590
confidentiality which means that no one

00:01:55,290 --> 00:02:01,219
else can spy on the communication which

00:01:58,590 --> 00:02:03,780
is happening with between those people

00:02:01,219 --> 00:02:06,659
the second one is the thing integrity

00:02:03,780 --> 00:02:08,099
which means no one else supposed to

00:02:06,659 --> 00:02:10,770
modify the content of the communication

00:02:08,099 --> 00:02:13,510
or at least if someone modifies the

00:02:10,770 --> 00:02:17,530
content then all the poll

00:02:13,510 --> 00:02:19,810
no TSM decide to close the channel and

00:02:17,530 --> 00:02:23,200
the last one is making sure that when

00:02:19,810 --> 00:02:25,480
someone sends you a message this message

00:02:23,200 --> 00:02:30,370
is actually coming from this person and

00:02:25,480 --> 00:02:32,700
not from someone else why how do you do

00:02:30,370 --> 00:02:35,470
we do that it's basically we're just

00:02:32,700 --> 00:02:38,680
manipulating input and output data

00:02:35,470 --> 00:02:42,040
adding some metadata to yet and then

00:02:38,680 --> 00:02:47,170
thanks to that we can ensure those three

00:02:42,040 --> 00:02:51,459
things so the first thing we'll see in

00:02:47,170 --> 00:02:55,209
cryptography is the cryptographic ash or

00:02:51,459 --> 00:02:57,129
what is called some time digest and this

00:02:55,209 --> 00:03:01,409
is the part which is supposed to

00:02:57,129 --> 00:03:04,989
guarantee the integrity of your data so

00:03:01,409 --> 00:03:08,500
ashing functions basically operate on a

00:03:04,989 --> 00:03:13,120
random number of input data and then

00:03:08,500 --> 00:03:15,900
it's generating a unique fixed size data

00:03:13,120 --> 00:03:19,560
which is most of the time shorter than

00:03:15,900 --> 00:03:24,280
the input data so for example you have

00:03:19,560 --> 00:03:27,730
shot you share one md5 you have a lot

00:03:24,280 --> 00:03:31,419
more so the main things that we want

00:03:27,730 --> 00:03:35,160
from an ash algorithm is that we want

00:03:31,419 --> 00:03:39,760
the probability to have two exact same

00:03:35,160 --> 00:03:40,810
areas from two different input to be as

00:03:39,760 --> 00:03:43,930
low as possible

00:03:40,810 --> 00:03:47,680
and ideally we would like this to be new

00:03:43,930 --> 00:03:51,160
but that's almost impossible we also

00:03:47,680 --> 00:03:53,859
wanted to make it impossible for a user

00:03:51,160 --> 00:03:57,220
to regenerate the input data from the

00:03:53,859 --> 00:04:00,099
earth and the last thing we want is that

00:03:57,220 --> 00:04:04,000
if we do tiny modification in the input

00:04:00,099 --> 00:04:08,379
stream we want the output ash the ash

00:04:04,000 --> 00:04:15,639
result to be as far as possible from the

00:04:08,379 --> 00:04:21,870
initial the next thing we need when were

00:04:15,639 --> 00:04:24,300
doing cryptography is the cipher element

00:04:21,870 --> 00:04:26,550
so cipher is supposed to ensure

00:04:24,300 --> 00:04:28,979
confidentiality

00:04:26,550 --> 00:04:34,830
it's basically using a private key or a

00:04:28,979 --> 00:04:38,400
key to encrypt and decrypt data so you

00:04:34,830 --> 00:04:42,229
can have two types of ciphers the stream

00:04:38,400 --> 00:04:46,050
cipher which which kind of operates on a

00:04:42,229 --> 00:04:48,300
random number of data and the block

00:04:46,050 --> 00:04:52,710
ciphers which are meant to be used on

00:04:48,300 --> 00:04:56,669
the fixed size block then you also have

00:04:52,710 --> 00:04:59,639
the notion of symmetry and asymmetry so

00:04:56,669 --> 00:05:02,310
symmetric ciphers are supposed to use

00:04:59,639 --> 00:05:04,860
the same key for both decryption and

00:05:02,310 --> 00:05:07,050
encryption which means all the people

00:05:04,860 --> 00:05:09,479
which want to take part to communication

00:05:07,050 --> 00:05:13,860
after you share the exact same private

00:05:09,479 --> 00:05:17,699
key of course that's not really secure

00:05:13,860 --> 00:05:21,599
because if one of these people get this

00:05:17,699 --> 00:05:27,120
key group stolen then that means the

00:05:21,599 --> 00:05:30,000
world communication is as unsecure so to

00:05:27,120 --> 00:05:33,630
address that we also have a symmetric

00:05:30,000 --> 00:05:35,759
ciphers which are using a pair of public

00:05:33,630 --> 00:05:38,819
and private keys so the private key is

00:05:35,759 --> 00:05:42,300
kept secret and only the creator of the

00:05:38,819 --> 00:05:45,000
key keeps it then it can also it can

00:05:42,300 --> 00:05:48,960
send the public key to anyone who wants

00:05:45,000 --> 00:05:51,419
to communicate this with this person all

00:05:48,960 --> 00:05:53,729
the messages are actually encrypted with

00:05:51,419 --> 00:05:56,039
using the public key and only the owner

00:05:53,729 --> 00:05:59,969
of the private key can decrypt the

00:05:56,039 --> 00:06:03,840
messages so we tend to use symmetric

00:05:59,969 --> 00:06:06,330
ciphers or to enforce security when we

00:06:03,840 --> 00:06:10,469
don't know exactly we will communicate

00:06:06,330 --> 00:06:14,460
we'll afterwards but it's also a lot

00:06:10,469 --> 00:06:17,969
more expensive than symmetric ciphers so

00:06:14,460 --> 00:06:20,819
it's kind of a compromise here a few

00:06:17,969 --> 00:06:24,180
example so for symmetric ciphers we have

00:06:20,819 --> 00:06:30,389
AES and for a symmetric ciphers we are

00:06:24,180 --> 00:06:32,569
for example era C so I said that we have

00:06:30,389 --> 00:06:35,759
a stream ciphers and block ciphers and

00:06:32,569 --> 00:06:38,310
even when you when we use block ciphers

00:06:35,759 --> 00:06:40,340
most of the time I want you be able to

00:06:38,310 --> 00:06:43,460
use those block ciphers for

00:06:40,340 --> 00:06:45,770
a random number of blocks and in order

00:06:43,460 --> 00:06:49,490
to do that in a secure way we will have

00:06:45,770 --> 00:06:52,699
to choose a specific block cipher and

00:06:49,490 --> 00:06:56,300
the block cipher is just something that

00:06:52,699 --> 00:07:03,710
describes or you can add crypt or

00:06:56,300 --> 00:07:07,820
encrypt several blocks of data so for

00:07:03,710 --> 00:07:10,130
example you have the ECB block block

00:07:07,820 --> 00:07:12,260
cipher mod which is very simple it just

00:07:10,130 --> 00:07:16,700
takes a key some input data and then

00:07:12,260 --> 00:07:18,889
there's some operation on it and provide

00:07:16,700 --> 00:07:21,139
the output data which has been encrypted

00:07:18,889 --> 00:07:26,090
with the key and you have more advanced

00:07:21,139 --> 00:07:28,940
cipher mode which are getting the result

00:07:26,090 --> 00:07:31,880
of the previous encryption and using

00:07:28,940 --> 00:07:34,490
that as an initialization vector to

00:07:31,880 --> 00:07:36,350
encrypt the next block which ensure that

00:07:34,490 --> 00:07:39,919
the data you are transmitted are

00:07:36,350 --> 00:07:42,500
actually obfuscated so you cannot guess

00:07:39,919 --> 00:07:48,200
exactly what what has to be translated

00:07:42,500 --> 00:07:51,169
by observing the communication another

00:07:48,200 --> 00:07:53,840
thing we have in cryptography is what we

00:07:51,169 --> 00:07:58,520
call Mac which stands for message

00:07:53,840 --> 00:08:04,880
authentication codes these is actually

00:07:58,520 --> 00:08:08,150
used to to authenticate the we actually

00:08:04,880 --> 00:08:11,030
send the mistake so what it does is it

00:08:08,150 --> 00:08:14,000
takes a private key then it does some

00:08:11,030 --> 00:08:19,010
transformation on the the input data and

00:08:14,000 --> 00:08:21,710
generate some output data which are put

00:08:19,010 --> 00:08:24,860
next to the the data so that the the

00:08:21,710 --> 00:08:30,580
receiver can then verify that the sender

00:08:24,860 --> 00:08:34,099
actually is the one we would lames it is

00:08:30,580 --> 00:08:36,979
so most of the time the Mac algorithm

00:08:34,099 --> 00:08:42,890
are based on our algorithm and that's

00:08:36,979 --> 00:08:47,450
why we call them as Mac and then we have

00:08:42,890 --> 00:08:49,760
the advanced block we use in

00:08:47,450 --> 00:08:52,010
cryptography which is doing all of the

00:08:49,760 --> 00:08:53,930
things we've seen so far in a single

00:08:52,010 --> 00:08:56,690
step so this means the

00:08:53,930 --> 00:09:01,250
these kind of algorithms are taking some

00:08:56,690 --> 00:09:03,640
data generating data to ensure data

00:09:01,250 --> 00:09:05,899
integrity to ensure confusion

00:09:03,640 --> 00:09:09,470
confidentiality and to ensure the

00:09:05,899 --> 00:09:13,220
negation and most of the time those are

00:09:09,470 --> 00:09:20,300
actually based on simple blocks like H

00:09:13,220 --> 00:09:22,790
mark CBC and so on so this was really a

00:09:20,300 --> 00:09:24,620
short introduction to those crypto some

00:09:22,790 --> 00:09:28,970
concepts if you want you know more about

00:09:24,620 --> 00:09:32,690
these the things I am talking about here

00:09:28,970 --> 00:09:34,940
you should watch the talk from Gilad ben

00:09:32,690 --> 00:09:38,230
yosef and i think it was giving a talk

00:09:34,940 --> 00:09:42,560
this week so if you want to go see as

00:09:38,230 --> 00:09:46,070
presentation I think it's a good one

00:09:42,560 --> 00:09:49,459
then I'm switch to what we really what

00:09:46,070 --> 00:09:54,709
we're already interested in here the

00:09:49,459 --> 00:09:56,779
Linux crypto framework so let's see a

00:09:54,709 --> 00:09:59,120
bit how it works internally before

00:09:56,779 --> 00:10:02,720
seeing how to use it and how to develop

00:09:59,120 --> 00:10:05,690
a driver so internally everything in the

00:10:02,720 --> 00:10:08,089
crypto framework is about transforming

00:10:05,690 --> 00:10:10,610
data in order to generate something else

00:10:08,089 --> 00:10:12,709
and that's why you'll see a lot of

00:10:10,610 --> 00:10:15,620
places where we are talking about

00:10:12,709 --> 00:10:18,400
transformation so there are two main

00:10:15,620 --> 00:10:22,430
objects we have the transformation

00:10:18,400 --> 00:10:25,070
implementation which is the base class

00:10:22,430 --> 00:10:27,589
which Institute's you implement a

00:10:25,070 --> 00:10:30,680
specific algorithm and then you have

00:10:27,589 --> 00:10:34,880
transformation objects which are the

00:10:30,680 --> 00:10:36,950
instance dot or provided by a specific

00:10:34,880 --> 00:10:41,529
transformation implementation when

00:10:36,950 --> 00:10:44,510
someone asks to create such an instance

00:10:41,529 --> 00:10:47,240
so if I actually make an analogy with an

00:10:44,510 --> 00:10:49,190
object-oriented language I'd said that

00:10:47,240 --> 00:10:51,890
the transformation implementation is

00:10:49,190 --> 00:10:54,740
actually a factory and which is about to

00:10:51,890 --> 00:10:57,320
generate transformation objects and then

00:10:54,740 --> 00:11:00,529
these are the objects the crypto user

00:10:57,320 --> 00:11:04,130
will use to do all kind of

00:11:00,529 --> 00:11:06,140
transformation so everything and the

00:11:04,130 --> 00:11:07,550
crypto pheromone actually any rates from

00:11:06,140 --> 00:11:14,690
those two in

00:11:07,550 --> 00:11:17,000
phrases crypto argh and crypto GSM the

00:11:14,690 --> 00:11:18,080
crypto framework supports bench of

00:11:17,000 --> 00:11:21,399
algorism

00:11:18,080 --> 00:11:27,620
so you have a lot of ciphers algorithm

00:11:21,399 --> 00:11:29,600
algorithm I D algorithm H Mac and you

00:11:27,620 --> 00:11:32,209
also have one I don't know exactly why

00:11:29,600 --> 00:11:34,579
weights here but you also have

00:11:32,209 --> 00:11:38,450
compression another reason which are

00:11:34,579 --> 00:11:42,170
nothing to do with crypto up all but I

00:11:38,450 --> 00:11:44,209
think it was feeling well in the crypto

00:11:42,170 --> 00:11:48,550
firmly and this is why they decided to

00:11:44,209 --> 00:11:55,100
implement it there so these are the base

00:11:48,550 --> 00:11:58,089
class of crypt object then based on that

00:11:55,100 --> 00:12:00,680
you will be able to generate complex

00:11:58,089 --> 00:12:03,019
objects which are combining different

00:12:00,680 --> 00:12:06,260
elements so for example you will be able

00:12:03,019 --> 00:12:10,160
to generate an ashmac function which is

00:12:06,260 --> 00:12:14,000
using internally the sha-1 protocol or

00:12:10,160 --> 00:12:20,480
you will be able to use the is AES block

00:12:14,000 --> 00:12:24,399
cipher using in CBC mode or you will

00:12:20,480 --> 00:12:28,300
even be able to create an AEA D

00:12:24,399 --> 00:12:34,100
algorithm made on a schmuck and Sascha

00:12:28,300 --> 00:12:36,500
sha-1 and CBC a yes so as you can see we

00:12:34,100 --> 00:12:38,450
always start from simple blocks and then

00:12:36,500 --> 00:12:42,500
build something more complicated from

00:12:38,450 --> 00:12:46,250
from there so okay how can you use the

00:12:42,500 --> 00:12:48,500
crypto framework the first thing you'll

00:12:46,250 --> 00:12:52,399
start to do when you want to do some

00:12:48,500 --> 00:12:57,050
crypt operation is allocate an algorithm

00:12:52,399 --> 00:12:59,420
instance what we call the CFM object so

00:12:57,050 --> 00:13:02,990
this is done with a call to a

00:12:59,420 --> 00:13:06,350
lock and then you pass the all types you

00:13:02,990 --> 00:13:12,500
fix so you have a cipher for symmetry a

00:13:06,350 --> 00:13:15,560
cipher a a a child for our algorithm and

00:13:12,500 --> 00:13:18,170
so on to this function you will pass the

00:13:15,560 --> 00:13:21,530
algorithm names we will see later what

00:13:18,170 --> 00:13:23,780
should be passed here then you will pass

00:13:21,530 --> 00:13:26,420
I'm still not sure what this type is

00:13:23,780 --> 00:13:28,520
about because obviously the type is

00:13:26,420 --> 00:13:32,210
already known in the function traffic's

00:13:28,520 --> 00:13:34,760
but still you have a type parameter and

00:13:32,210 --> 00:13:37,240
then you have a mask which is saying the

00:13:34,760 --> 00:13:40,010
Krypton giant what kind of immigration

00:13:37,240 --> 00:13:41,770
implementation you want to avoid so for

00:13:40,010 --> 00:13:45,380
example you want to have a avoid

00:13:41,770 --> 00:13:47,540
implementation which are doing things a

00:13:45,380 --> 00:13:50,120
synchronously because you want when you

00:13:47,540 --> 00:13:52,520
trigger a crypto operation you want the

00:13:50,120 --> 00:13:54,980
result to be available when the function

00:13:52,520 --> 00:13:57,710
returns and then that's the kind of

00:13:54,980 --> 00:14:03,020
thing you will be able to ask when you

00:13:57,710 --> 00:14:04,790
instantiate the gfm object once you have

00:14:03,020 --> 00:14:08,480
this gfm object you will be able to

00:14:04,790 --> 00:14:11,630
create crypto requests and this is done

00:14:08,480 --> 00:14:15,640
with the request a log functions so

00:14:11,630 --> 00:14:22,070
again always prefixed with the archetype

00:14:15,640 --> 00:14:24,740
and with this request object you will be

00:14:22,070 --> 00:14:26,750
able to assign a specific robotic

00:14:24,740 --> 00:14:29,870
callback that will be called every time

00:14:26,750 --> 00:14:32,240
a crypto operation is complete you will

00:14:29,870 --> 00:14:35,480
be able to pass a few flags for example

00:14:32,240 --> 00:14:38,480
whether you allow the crypto framework

00:14:35,480 --> 00:14:40,490
to queue the request to the backlog if

00:14:38,480 --> 00:14:43,190
there are already too many requests

00:14:40,490 --> 00:14:47,089
inside the crypto queue and and other

00:14:43,190 --> 00:14:49,880
things like that so that for the init

00:14:47,089 --> 00:14:52,310
part of the the creation once you have

00:14:49,880 --> 00:14:55,250
that you won't use you will want to set

00:14:52,310 --> 00:14:57,770
the context of your transformation

00:14:55,250 --> 00:14:59,960
object and most of the time the context

00:14:57,770 --> 00:15:02,690
is about setting the private key or the

00:14:59,960 --> 00:15:06,350
public key or whatever you want you used

00:15:02,690 --> 00:15:09,620
to do this crypto operation so here

00:15:06,350 --> 00:15:13,250
you'll use the crypto alcott I'll type

00:15:09,620 --> 00:15:17,680
set the context you want to set so most

00:15:13,250 --> 00:15:17,680
of the time it's little something set

00:15:19,810 --> 00:15:25,720
once you have setup everything

00:15:21,920 --> 00:15:29,420
you can start passing data to the crypto

00:15:25,720 --> 00:15:32,810
instance so to do that you will use the

00:15:29,420 --> 00:15:34,910
request set crypt which you will pass

00:15:32,810 --> 00:15:38,630
the input a third

00:15:34,910 --> 00:15:41,000
put buffer in the lens of the buffer and

00:15:38,630 --> 00:15:43,730
you will be able to trigger the tripped

00:15:41,000 --> 00:15:47,360
operation so this time it will be done

00:15:43,730 --> 00:15:49,190
using crypto then Alec type then the

00:15:47,360 --> 00:15:51,080
name of the operation so for example

00:15:49,190 --> 00:15:54,680
foreign cipher it will be encrypt or

00:15:51,080 --> 00:15:57,020
decrypt and you can do that many times

00:15:54,680 --> 00:15:59,990
as many times as you want say that you

00:15:57,020 --> 00:16:02,630
have several blocks of data to encrypt

00:15:59,990 --> 00:16:05,600
then you can repeat that over and over

00:16:02,630 --> 00:16:09,500
until you're done with encrypting or

00:16:05,600 --> 00:16:12,560
decrypting data and once you're done you

00:16:09,500 --> 00:16:16,970
can then free the was the request and

00:16:12,560 --> 00:16:17,300
crypto engine context so that's how it's

00:16:16,970 --> 00:16:20,240
done

00:16:17,300 --> 00:16:25,390
so let's see a real example of God do

00:16:20,240 --> 00:16:25,390
you see how it interacts with the rest

00:16:25,810 --> 00:16:33,800
yeah the color I'm gonna show here is

00:16:29,390 --> 00:16:35,780
naturally to be used in real setup so

00:16:33,800 --> 00:16:39,290
this is just to show all the different

00:16:35,780 --> 00:16:41,390
steps you have to do but that you

00:16:39,290 --> 00:16:45,110
shouldn't base your development and that

00:16:41,390 --> 00:16:49,640
if you really need to key to develop

00:16:45,110 --> 00:16:52,840
something that uses the crypto API so

00:16:49,640 --> 00:16:55,700
let's look at the right of the screen

00:16:52,840 --> 00:16:57,830
we're looking at the encrypt function

00:16:55,700 --> 00:16:59,960
which is the main entry part so this

00:16:57,830 --> 00:17:03,860
function is supposed to encrypt some

00:16:59,960 --> 00:17:06,170
some data you will be you will pass it

00:17:03,860 --> 00:17:08,120
the key the private key when he used it

00:17:06,170 --> 00:17:10,910
will pass it the the data you want to

00:17:08,120 --> 00:17:14,780
encrypt so this is this serves both of

00:17:10,910 --> 00:17:17,390
the input buffer and output buffer and

00:17:14,780 --> 00:17:21,010
you will pass the size the first thing

00:17:17,390 --> 00:17:25,670
you have to do is allocate the crypto

00:17:21,010 --> 00:17:28,340
context then set up the you request and

00:17:25,670 --> 00:17:30,950
so on so well call the Internet function

00:17:28,340 --> 00:17:34,120
which is doing which is calling the

00:17:30,950 --> 00:17:38,840
crypto Alex SK safer so allocating

00:17:34,120 --> 00:17:41,720
symmetric key cipher algorithm we then

00:17:38,840 --> 00:17:45,140
use the request a lock to create a new

00:17:41,720 --> 00:17:47,480
request then we specify the callback we

00:17:45,140 --> 00:17:48,670
want to be called when the when the

00:17:47,480 --> 00:17:52,580
operation is complete

00:17:48,670 --> 00:17:56,030
and finally we initialize a completion

00:17:52,580 --> 00:18:00,170
element once we are done with that we

00:17:56,030 --> 00:18:04,790
set up the key so we use the crypto SK

00:18:00,170 --> 00:18:08,030
cipher set key and we set up also the

00:18:04,790 --> 00:18:13,220
data to pass through the crypto API so

00:18:08,030 --> 00:18:17,420
we after you pass it using an SG element

00:18:13,220 --> 00:18:20,330
scatter Gaza list then we just call

00:18:17,420 --> 00:18:22,490
request set script you say that this is

00:18:20,330 --> 00:18:24,440
me my input buffer this is my output

00:18:22,490 --> 00:18:26,600
buffer and this is the length of the

00:18:24,440 --> 00:18:28,760
buffer and once this is done you just

00:18:26,600 --> 00:18:33,920
regard the the crypto request you

00:18:28,760 --> 00:18:38,570
calling crypto SK cipher encrypts so by

00:18:33,920 --> 00:18:42,550
design the crypto API is a synchronous

00:18:38,570 --> 00:18:44,990
which means when these functions returns

00:18:42,550 --> 00:18:47,450
you are not guaranteed that the

00:18:44,990 --> 00:18:50,390
operation is actually done and this is

00:18:47,450 --> 00:18:52,820
why the crypto API can return in

00:18:50,390 --> 00:18:55,580
progress or Buzz the errors and in this

00:18:52,820 --> 00:18:58,970
case you shouldn't consider that as a

00:18:55,580 --> 00:19:00,950
real error you should just wait for the

00:18:58,970 --> 00:19:04,520
actual operation to be it should be done

00:19:00,950 --> 00:19:07,160
and this is simply done by calling wait

00:19:04,520 --> 00:19:09,020
for completion on the completion object

00:19:07,160 --> 00:19:12,560
you have initialized in the init

00:19:09,020 --> 00:19:15,740
function so once this is done you get

00:19:12,560 --> 00:19:19,340
back the error clean up everything and

00:19:15,740 --> 00:19:22,520
then return the return code so this is a

00:19:19,340 --> 00:19:25,100
simple example of the different steps

00:19:22,520 --> 00:19:31,810
you'll have to follow to use the crypto

00:19:25,100 --> 00:19:35,960
API inside the kernel of course this was

00:19:31,810 --> 00:19:37,670
just a dummy example if you want to look

00:19:35,960 --> 00:19:40,280
at real example you just have to grab

00:19:37,670 --> 00:19:43,340
for crypto log something and you should

00:19:40,280 --> 00:19:45,590
find different elements which are using

00:19:43,340 --> 00:19:48,200
crypto for example we have DM crypt

00:19:45,590 --> 00:19:50,690
which is doing discovery encryption we

00:19:48,200 --> 00:19:53,630
have various Network protocols which are

00:19:50,690 --> 00:19:57,440
using crypto file systems device drivers

00:19:53,630 --> 00:20:00,260
and I guess you can find more so really

00:19:57,440 --> 00:20:03,070
the the crypto API is used all over the

00:20:00,260 --> 00:20:03,070
kernel

00:20:03,360 --> 00:20:09,210
now we have a specific user some people

00:20:06,660 --> 00:20:15,480
want to use the crypto in Giants from

00:20:09,210 --> 00:20:18,660
user space and so they pushed for a long

00:20:15,480 --> 00:20:21,180
time to have something inside the kernel

00:20:18,660 --> 00:20:24,080
to expose those script of features to

00:20:21,180 --> 00:20:28,220
use the space so we have currently two

00:20:24,080 --> 00:20:31,590
competing solutions the crypto they have

00:20:28,220 --> 00:20:37,140
approach which has not been aligned so

00:20:31,590 --> 00:20:42,570
that's not so good and we have the AFR

00:20:37,140 --> 00:20:45,660
which is in line so let's see Amit ow

00:20:42,570 --> 00:20:48,000
boss solution converts the first

00:20:45,660 --> 00:20:50,250
solutions you have emerged is crypt 11

00:20:48,000 --> 00:20:54,540
it's actually taken from the OpenBSD

00:20:50,250 --> 00:20:57,450
word this solution is actually exposing

00:20:54,540 --> 00:20:59,100
a device under slash dev and every time

00:20:57,450 --> 00:21:01,980
we want to do something from user space

00:20:59,100 --> 00:21:06,270
you just use iocked roles to set up the

00:21:01,980 --> 00:21:08,040
context then send data and so on the

00:21:06,270 --> 00:21:10,380
main problem with this solution is that

00:21:08,040 --> 00:21:12,810
it's maintainer as an apt of three

00:21:10,380 --> 00:21:17,160
modules rather than that of three module

00:21:12,810 --> 00:21:18,570
and will never be a main line simply

00:21:17,160 --> 00:21:24,300
because we have something and run

00:21:18,570 --> 00:21:26,220
language in Devils which exposes crypto

00:21:24,300 --> 00:21:30,450
features to the user base and this is

00:21:26,220 --> 00:21:34,560
called a a frog instead of exposing

00:21:30,450 --> 00:21:37,020
things to through they have slash dev

00:21:34,560 --> 00:21:40,920
slash something device it's exposing

00:21:37,020 --> 00:21:45,570
things through Netflix socket the main

00:21:40,920 --> 00:21:49,770
problem with AFR is that most use space

00:21:45,570 --> 00:21:51,690
crypto library or not using it for

00:21:49,770 --> 00:21:53,670
example open SSL azan out of three

00:21:51,690 --> 00:21:56,430
module for a file which is fully

00:21:53,670 --> 00:21:59,330
maintained but in the other hand on the

00:21:56,430 --> 00:22:02,310
other hand it has native support for

00:21:59,330 --> 00:22:05,730
crypto tip so you don't have to make a

00:22:02,310 --> 00:22:07,590
choice whether you want to add an out of

00:22:05,730 --> 00:22:12,650
three module inside the kernel or

00:22:07,590 --> 00:22:14,890
whether you want to add support for AFL

00:22:12,650 --> 00:22:22,110
in Europe a necessarily

00:22:14,890 --> 00:22:25,930
biding amount of free library so before

00:22:22,110 --> 00:22:30,960
actually I I didn't try to understand

00:22:25,930 --> 00:22:34,600
how they work internally but I tried to

00:22:30,960 --> 00:22:36,700
see all the defer what kind of

00:22:34,600 --> 00:22:39,970
performance is they can provide most

00:22:36,700 --> 00:22:42,760
both of them can provide um there was an

00:22:39,970 --> 00:22:46,180
assumption that what is it is written

00:22:42,760 --> 00:22:49,210
everywhere on the internet that crypto

00:22:46,180 --> 00:22:51,490
dev is performing better than AFI so I

00:22:49,210 --> 00:22:54,010
wanted to make sure that with my Krypton

00:22:51,490 --> 00:22:58,420
giant the Marvel one this was the case

00:22:54,010 --> 00:23:03,310
and actually it's the case for 8k blocks

00:22:58,420 --> 00:23:05,430
on a a has CBC algorithm then you see

00:23:03,310 --> 00:23:08,410
that the crypto they have algorithm is

00:23:05,430 --> 00:23:11,170
performing better but you also see that

00:23:08,410 --> 00:23:13,600
for very small blocks it's almost

00:23:11,170 --> 00:23:16,590
useless to use the internal

00:23:13,600 --> 00:23:18,640
implementation compared to the to the

00:23:16,590 --> 00:23:24,640
user space implementation

00:23:18,640 --> 00:23:26,940
um then I decided to test the user space

00:23:24,640 --> 00:23:31,330
implementation which is probably using

00:23:26,940 --> 00:23:33,940
the processor optimization so I assembly

00:23:31,330 --> 00:23:38,700
instructions but still it's worth

00:23:33,940 --> 00:23:43,210
looking at the results so as you can see

00:23:38,700 --> 00:23:48,730
even crypto dev is outperform that by by

00:23:43,210 --> 00:23:52,590
the software implementation so I decided

00:23:48,730 --> 00:23:55,930
to run the same test and launch a few

00:23:52,590 --> 00:23:58,960
threads in parallel because my engine is

00:23:55,930 --> 00:24:01,330
able to queue things at the DMA level

00:23:58,960 --> 00:24:05,890
and the more I have requests the better

00:24:01,330 --> 00:24:10,240
it it reacts it it scales and actually

00:24:05,890 --> 00:24:13,720
you had to create 228 threads to get

00:24:10,240 --> 00:24:16,500
better results with the internal

00:24:13,720 --> 00:24:19,930
implementation and interestingly it was

00:24:16,500 --> 00:24:21,340
achieved with the AF al implementation

00:24:19,930 --> 00:24:24,700
and not with the cryptid every

00:24:21,340 --> 00:24:26,380
implementation but still when you are

00:24:24,700 --> 00:24:28,600
asking yourself whether you should use

00:24:26,380 --> 00:24:30,580
crypto dev of a

00:24:28,600 --> 00:24:33,100
actually the first thing you should ask

00:24:30,580 --> 00:24:36,549
yourself is whether you want to use any

00:24:33,100 --> 00:24:39,549
of them because when you compare the

00:24:36,549 --> 00:24:43,029
results to the pure software

00:24:39,549 --> 00:24:45,759
implementation then it's not so good and

00:24:43,029 --> 00:24:49,419
I also add a look at the CPU consumption

00:24:45,759 --> 00:24:51,669
because every time you use a no external

00:24:49,419 --> 00:24:54,399
engine they one of the thing you want is

00:24:51,669 --> 00:24:58,409
that you don't want you you want you

00:24:54,399 --> 00:25:02,889
offload the CPU and actually even the

00:24:58,409 --> 00:25:06,279
version using the other engine is using

00:25:02,889 --> 00:25:09,820
quite a lot of CPU so it's using around

00:25:06,279 --> 00:25:11,769
60% of the CPU compared to 100% when you

00:25:09,820 --> 00:25:16,450
use the pure software and potential

00:25:11,769 --> 00:25:20,620
implementation so really I don't think

00:25:16,450 --> 00:25:23,679
in most cases it makes sense to use your

00:25:20,620 --> 00:25:26,289
router in giant from user space the only

00:25:23,679 --> 00:25:30,700
case where it might be interesting is

00:25:26,289 --> 00:25:33,039
when you have a lot of requests which

00:25:30,700 --> 00:25:35,700
are coming in parallel but other than

00:25:33,039 --> 00:25:39,190
that you should think twice before

00:25:35,700 --> 00:25:44,379
trying to use those Hardware in Giants

00:25:39,190 --> 00:25:50,139
form from user space so now let's have a

00:25:44,379 --> 00:25:54,850
look at how to develop a crypto engine

00:25:50,139 --> 00:25:58,360
driver so from the crypto API point of

00:25:54,850 --> 00:26:00,190
view a Krypton giant is just an

00:25:58,360 --> 00:26:02,980
information and implementation of a

00:26:00,190 --> 00:26:06,519
specific algorithm and the crypto API

00:26:02,980 --> 00:26:10,059
does not distinguish between pure

00:26:06,519 --> 00:26:12,940
software implementation and those which

00:26:10,059 --> 00:26:15,370
are using dedicated engines so they

00:26:12,940 --> 00:26:18,940
developing a Krypton giant driver is

00:26:15,370 --> 00:26:22,990
just about implementing and registering

00:26:18,940 --> 00:26:24,879
a crypto AAG interface so most of the

00:26:22,990 --> 00:26:26,769
time you don't implement crypto all

00:26:24,879 --> 00:26:29,169
directly you implement something that

00:26:26,769 --> 00:26:31,539
inherits from Krypton because as I said

00:26:29,169 --> 00:26:34,120
crypto algis base class the base

00:26:31,539 --> 00:26:39,039
interface and then you have to inherit

00:26:34,120 --> 00:26:42,130
from it so you implement it you register

00:26:39,039 --> 00:26:44,650
it using crypto register something

00:26:42,130 --> 00:26:49,809
and the something is the type of crypto

00:26:44,650 --> 00:26:55,809
algorithm so we will see a simple

00:26:49,809 --> 00:26:57,880
example with a CBC AES driver we studied

00:26:55,809 --> 00:26:59,460
this one because it's quite simple now

00:26:57,880 --> 00:27:04,090
if you want you ever look at our

00:26:59,460 --> 00:27:06,100
algorithm or advance a e ad algorithm

00:27:04,090 --> 00:27:08,080
then I recommend that you look at

00:27:06,100 --> 00:27:10,690
existing drivers to see how its

00:27:08,080 --> 00:27:13,000
implemented so the first thing you have

00:27:10,690 --> 00:27:18,429
to do when you implement a crypto

00:27:13,000 --> 00:27:20,530
algorithm or crypto and join support the

00:27:18,429 --> 00:27:22,720
first thing you have to do is fill in

00:27:20,530 --> 00:27:25,480
the crypto alga

00:27:22,720 --> 00:27:30,789
so the first name the first field you'll

00:27:25,480 --> 00:27:34,120
have to pass is the crypto algorithm so

00:27:30,789 --> 00:27:36,850
this one is standardized and you always

00:27:34,120 --> 00:27:40,510
have to use the real name of the

00:27:36,850 --> 00:27:43,809
algorithm so for example this is CBC

00:27:40,510 --> 00:27:46,780
based on e AE s so this is the name

00:27:43,809 --> 00:27:50,289
you'll after pass then you will pass the

00:27:46,780 --> 00:27:54,340
driver name so this time you don't use

00:27:50,289 --> 00:27:58,450
parentheses you just use - and then you

00:27:54,340 --> 00:28:02,679
prefix it with the driver name so xxx is

00:27:58,450 --> 00:28:04,750
just the name of the driver the next

00:28:02,679 --> 00:28:11,130
field you'll have to to specify as the

00:28:04,750 --> 00:28:15,190
priority the priority is supposed to be

00:28:11,130 --> 00:28:18,880
representing well the engine is behaving

00:28:15,190 --> 00:28:21,520
compared to other implementation so

00:28:18,880 --> 00:28:25,210
basically by conversion we have this

00:28:21,520 --> 00:28:28,360
rule which is our word giants always our

00:28:25,210 --> 00:28:31,360
priority then arch optimized

00:28:28,360 --> 00:28:34,659
implementation which of our priorities

00:28:31,360 --> 00:28:39,700
than plain C so normally we have our one

00:28:34,659 --> 00:28:41,950
giant which have a priority of 300 then

00:28:39,700 --> 00:28:45,130
you pass some flags which are this

00:28:41,950 --> 00:28:47,980
fanging which kind of algorithm you are

00:28:45,130 --> 00:28:52,450
implementing and the different things

00:28:47,980 --> 00:28:55,960
the algorithm supports so for example if

00:28:52,450 --> 00:28:58,630
your algorithm is behaving

00:28:55,960 --> 00:29:03,030
is doing things are secure honestly then

00:28:58,630 --> 00:29:08,620
you have to pass the crypto are guessing

00:29:03,030 --> 00:29:10,540
or if the crypto engine is not directly

00:29:08,620 --> 00:29:14,740
accessible to you space you'll have to

00:29:10,540 --> 00:29:17,470
pass the crypto driver only which allows

00:29:14,740 --> 00:29:20,320
the system to know when it chooses when

00:29:17,470 --> 00:29:24,070
it should expose the the algorithm to

00:29:20,320 --> 00:29:27,720
the used space interface the next thing

00:29:24,070 --> 00:29:30,640
you have to do for the for block

00:29:27,720 --> 00:29:33,900
algorithm is to specify the block size

00:29:30,640 --> 00:29:36,610
which this algorithm is operating on

00:29:33,900 --> 00:29:39,310
then you have the context which is

00:29:36,610 --> 00:29:41,140
representing your driver specific

00:29:39,310 --> 00:29:43,150
context so every time you have a new

00:29:41,140 --> 00:29:45,400
instance you will have a new context

00:29:43,150 --> 00:29:47,890
allocated and this context is actually

00:29:45,400 --> 00:29:49,900
allocated by the crypto a crypto

00:29:47,890 --> 00:29:52,180
framework so the creep of the crypto

00:29:49,900 --> 00:29:54,840
framework needs to know all merge data

00:29:52,180 --> 00:29:57,580
you need for your own private data and

00:29:54,840 --> 00:29:59,980
this is why you have to specify the

00:29:57,580 --> 00:30:03,970
context size and the last thing you'll

00:29:59,980 --> 00:30:06,040
have to specify is the descriptor and on

00:30:03,970 --> 00:30:08,080
structural methods which are called

00:30:06,040 --> 00:30:13,090
every time a new instance is created or

00:30:08,080 --> 00:30:16,300
destroyed so let's have a look at the

00:30:13,090 --> 00:30:20,200
the part of the crypto algorithm which

00:30:16,300 --> 00:30:22,540
is specific so here the SK cipher

00:30:20,200 --> 00:30:24,640
algorithm is in a rating from the crypto

00:30:22,540 --> 00:30:29,230
log and you'll have to implement a few

00:30:24,640 --> 00:30:31,240
flee fills in this SK cipher the first

00:30:29,230 --> 00:30:34,500
one we'll have to implement is the set

00:30:31,240 --> 00:30:37,750
key because this is a cipher algorithm

00:30:34,500 --> 00:30:41,200
then you have to implement two methods

00:30:37,750 --> 00:30:43,300
and Crips and decrypt and then some

00:30:41,200 --> 00:30:48,820
information about the the key size and

00:30:43,300 --> 00:30:51,520
the IV size if the needs an IV then

00:30:48,820 --> 00:30:54,780
inside your function you just do what he

00:30:51,520 --> 00:30:58,630
has to be done to encrypt decrypt or

00:30:54,780 --> 00:31:00,910
assign the key to to the context so all

00:30:58,630 --> 00:31:04,090
those functions have to be driver

00:31:00,910 --> 00:31:07,290
specific because each engine is ending

00:31:04,090 --> 00:31:07,290
things differently

00:31:07,480 --> 00:31:13,360
and once you have done that you just go

00:31:10,590 --> 00:31:17,110
the crypto register or something and

00:31:13,360 --> 00:31:19,570
that's all we should be done um your

00:31:17,110 --> 00:31:22,419
driver your Krypton Jen should be

00:31:19,570 --> 00:31:25,149
exposed so when the framework is

00:31:22,419 --> 00:31:27,250
supposed a crypto in China and someone

00:31:25,149 --> 00:31:32,159
wants to use this crypto and join it

00:31:27,250 --> 00:31:37,710
well either you ask the crypto API to

00:31:32,159 --> 00:31:41,700
allocate an instance based on the usual

00:31:37,710 --> 00:31:44,500
algorithm name so here CBC AES and

00:31:41,700 --> 00:31:46,630
depending on all the engines which are

00:31:44,500 --> 00:31:49,570
registered to the system and based on

00:31:46,630 --> 00:31:52,720
the priority then the crypto API will

00:31:49,570 --> 00:31:55,899
decide which one you should use the IO

00:31:52,720 --> 00:31:58,090
priority the the anti with the IO

00:31:55,899 --> 00:32:00,429
priority will be chosen over give also

00:31:58,090 --> 00:32:03,730
if you want to really use one specific

00:32:00,429 --> 00:32:05,799
enjoin because you know this is the one

00:32:03,730 --> 00:32:07,899
you want to use then you can also pass

00:32:05,799 --> 00:32:11,889
directly the driver name when you

00:32:07,899 --> 00:32:14,279
request crypto in sense but usually most

00:32:11,889 --> 00:32:17,409
of the time the users don't want you

00:32:14,279 --> 00:32:22,450
after you specify a specific enzyme that

00:32:17,409 --> 00:32:26,830
just passed the algorithm name so that's

00:32:22,450 --> 00:32:29,320
all I have on the crypto framework part

00:32:26,830 --> 00:32:31,960
now I'd like to share a few things that

00:32:29,320 --> 00:32:34,059
have been completely complicated to deal

00:32:31,960 --> 00:32:34,620
with during the development of the

00:32:34,059 --> 00:32:39,250
driver

00:32:34,620 --> 00:32:42,490
so first the framework is really complex

00:32:39,250 --> 00:32:42,909
and actually it's complex for a good

00:32:42,490 --> 00:32:45,370
reason

00:32:42,909 --> 00:32:47,409
when you look at the number of

00:32:45,370 --> 00:32:51,610
algorithms which are supported in there

00:32:47,409 --> 00:32:54,610
and how easy it is you to add a new

00:32:51,610 --> 00:32:58,269
algorithm to do the to the framework

00:32:54,610 --> 00:33:02,559
then it explains why it became it became

00:32:58,269 --> 00:33:05,620
so complex and also one of the good

00:33:02,559 --> 00:33:09,130
thing and that even so it's really

00:33:05,620 --> 00:33:11,860
complex you have an extensive test with

00:33:09,130 --> 00:33:13,929
so every time you add a driver for a

00:33:11,860 --> 00:33:19,120
crypto and join then you can run the

00:33:13,929 --> 00:33:21,669
test suite and and make sure that your

00:33:19,120 --> 00:33:26,510
driver is is actually

00:33:21,669 --> 00:33:29,960
behaving correctly well the bad aspects

00:33:26,510 --> 00:33:32,570
is that it's so open that most of the

00:33:29,960 --> 00:33:34,820
time you have several ways to do the

00:33:32,570 --> 00:33:38,000
same thing and one examples for example

00:33:34,820 --> 00:33:42,260
how you can explain implement a Krypton

00:33:38,000 --> 00:33:45,529
giant for an sk cipher algorithm when

00:33:42,260 --> 00:33:48,169
you actually have two ways right now so

00:33:45,529 --> 00:33:51,110
I think SK cipher is the right way to do

00:33:48,169 --> 00:33:54,500
it but we still have drivers which have

00:33:51,110 --> 00:33:57,620
not been converted converted yet also

00:33:54,500 --> 00:34:00,830
out generate from base class is not

00:33:57,620 --> 00:34:04,190
really clear you have at least two ways

00:34:00,830 --> 00:34:06,679
to generate from it we some some time

00:34:04,190 --> 00:34:11,240
you there is a union inside the base

00:34:06,679 --> 00:34:12,980
class with different inside the Union

00:34:11,240 --> 00:34:15,909
you have these different interfaces and

00:34:12,980 --> 00:34:18,470
sometimes the the the child class is

00:34:15,909 --> 00:34:21,440
embedding directly the base class so

00:34:18,470 --> 00:34:25,280
it's not clear what kind of inheritance

00:34:21,440 --> 00:34:27,500
you want you to do here also it's hard

00:34:25,280 --> 00:34:30,619
to tell what are the good practices

00:34:27,500 --> 00:34:32,810
because one the framework involves then

00:34:30,619 --> 00:34:35,659
the new drivers are switching to the new

00:34:32,810 --> 00:34:41,119
method but the old drivers are usually

00:34:35,659 --> 00:34:44,030
staying like they were and the last

00:34:41,119 --> 00:34:46,339
thing is that there are some aspect that

00:34:44,030 --> 00:34:48,409
can be discovered the hard way for

00:34:46,339 --> 00:34:52,099
example I didn't know at the beginning

00:34:48,409 --> 00:34:55,190
that the complete code back as to add to

00:34:52,099 --> 00:35:00,020
be cold with the soft I use disabled

00:34:55,190 --> 00:35:02,540
which is actually logic because most one

00:35:00,020 --> 00:35:05,770
of the big user of the crypto API is the

00:35:02,540 --> 00:35:08,960
network stack and in the network stack

00:35:05,770 --> 00:35:11,030
almost everything is done in a soft IQ

00:35:08,960 --> 00:35:14,720
context when it comes to handling

00:35:11,030 --> 00:35:16,880
packets so it needs when you do a crypto

00:35:14,720 --> 00:35:21,680
operation it needs to be done in the

00:35:16,880 --> 00:35:24,680
soft irq context but wow this is not the

00:35:21,680 --> 00:35:27,680
only subsystem where it's not completely

00:35:24,680 --> 00:35:29,599
consistent and I'm probably not the good

00:35:27,680 --> 00:35:33,940
person to complain about that because in

00:35:29,599 --> 00:35:33,940
the non framework it's even worse

00:35:34,190 --> 00:35:41,220
um that's not something we can address

00:35:37,770 --> 00:35:43,860
easily so it requires cooperation from

00:35:41,220 --> 00:35:47,130
both the maintainer and and all the

00:35:43,860 --> 00:35:49,320
driver developers and maintain errs so

00:35:47,130 --> 00:35:53,420
it takes a lot of time to emigrate all

00:35:49,320 --> 00:35:56,580
drivers to new methods to do things

00:35:53,420 --> 00:36:00,270
another problem I had when developing

00:35:56,580 --> 00:36:03,960
the driver and testing it is that there

00:36:00,270 --> 00:36:08,070
is no way to use Boeing when you are

00:36:03,960 --> 00:36:13,470
under a V load under AV crypto old which

00:36:08,070 --> 00:36:16,020
means even so you have nappy activated

00:36:13,470 --> 00:36:19,320
and in that level which allows the

00:36:16,020 --> 00:36:25,080
network stack to do things in a threat

00:36:19,320 --> 00:36:28,110
context and then poor for the and and do

00:36:25,080 --> 00:36:31,620
that to all the packet alien threat

00:36:28,110 --> 00:36:33,690
context then you will have the crypto

00:36:31,620 --> 00:36:36,450
API which will generate a lot of

00:36:33,690 --> 00:36:39,020
interrupts which kind of defeats the war

00:36:36,450 --> 00:36:43,250
purpose of nappy

00:36:39,020 --> 00:36:48,690
so in this is a driver we addressed that

00:36:43,250 --> 00:36:51,360
manually by creating as ready RFQ then

00:36:48,690 --> 00:36:53,250
doing a bit of polling after the last

00:36:51,360 --> 00:36:55,890
crypto request has been done to see if

00:36:53,250 --> 00:37:00,000
the next one can be on the and all after

00:36:55,890 --> 00:37:01,740
that but still it's a bit icky and I

00:37:00,000 --> 00:37:05,280
wonder if we shouldn't find a better

00:37:01,740 --> 00:37:08,220
solution like maybe add something to

00:37:05,280 --> 00:37:12,000
support nappy like interface in the

00:37:08,220 --> 00:37:14,190
crypto API so I'm not sure about that

00:37:12,000 --> 00:37:19,380
it's really questioned you to the

00:37:14,190 --> 00:37:24,870
audience and the last one the last point

00:37:19,380 --> 00:37:28,610
we with we fought with was the load

00:37:24,870 --> 00:37:33,240
balancing issue so in Marvel so C's

00:37:28,610 --> 00:37:37,080
usually usually have two to crypto

00:37:33,240 --> 00:37:40,020
engines which are exactly the same base

00:37:37,080 --> 00:37:43,740
using the private eBay selection of the

00:37:40,020 --> 00:37:45,300
engine you cannot use the single one so

00:37:43,740 --> 00:37:46,170
every time this is the first one which

00:37:45,300 --> 00:37:49,830
is chosen to

00:37:46,170 --> 00:37:52,050
to do things also if you say you have in

00:37:49,830 --> 00:37:55,020
the same system different crypto and

00:37:52,050 --> 00:37:56,910
giants with which are not exactly the

00:37:55,020 --> 00:38:01,110
same but still can be used in parallel

00:37:56,910 --> 00:38:03,960
then actually only one of them will be

00:38:01,110 --> 00:38:05,730
able to handle requests because only the

00:38:03,960 --> 00:38:08,750
one with the highest priority will be

00:38:05,730 --> 00:38:13,020
chosen when something needs to be done

00:38:08,750 --> 00:38:17,090
so the question is should we introduce

00:38:13,020 --> 00:38:21,170
some kind of load balancing mechanism

00:38:17,090 --> 00:38:24,560
while it's not so simple to do because

00:38:21,170 --> 00:38:29,460
the framework is not designed to do that

00:38:24,560 --> 00:38:31,350
from the beginning so if we need to do

00:38:29,460 --> 00:38:33,600
that we need to introduce and you can

00:38:31,350 --> 00:38:36,720
set which is crypto and giant concept

00:38:33,600 --> 00:38:42,600
and hqm time engine is able to expose

00:38:36,720 --> 00:38:45,660
different algorithm we also need to find

00:38:42,600 --> 00:38:47,880
a way to assign a load to each request

00:38:45,660 --> 00:38:52,200
because each request will be queued to

00:38:47,880 --> 00:38:55,650
specific enzyme so we can easily find a

00:38:52,200 --> 00:38:58,350
way to calculate something which is

00:38:55,650 --> 00:39:01,260
rather complicated based on the request

00:38:58,350 --> 00:39:03,900
type the request length and the engine

00:39:01,260 --> 00:39:06,990
ET it is queued - or we can just do

00:39:03,900 --> 00:39:10,860
something as simple as the load equal

00:39:06,990 --> 00:39:13,410
the length of the request and of course

00:39:10,860 --> 00:39:17,010
we need to keep track of the total load

00:39:13,410 --> 00:39:19,970
of each crypto engine and the last thing

00:39:17,010 --> 00:39:23,130
we need journal is our teaming rates

00:39:19,970 --> 00:39:25,560
requests from one end right into it and

00:39:23,130 --> 00:39:28,170
also because every time you want to

00:39:25,560 --> 00:39:30,570
switch to a different and Ryan you need

00:39:28,170 --> 00:39:32,940
to allocate a new context which is

00:39:30,570 --> 00:39:34,740
driver specific and then under allocate

00:39:32,940 --> 00:39:41,850
a new request which is also driver

00:39:34,740 --> 00:39:45,870
specific so this is just an idea how it

00:39:41,850 --> 00:39:47,580
would look like but really there is no

00:39:45,870 --> 00:39:50,880
proof of concept or nothing like that

00:39:47,580 --> 00:39:54,120
but I think we can keep the upper layer

00:39:50,880 --> 00:39:57,540
and change meaning that the crypto a

00:39:54,120 --> 00:39:59,780
user could still request the crypto API

00:39:57,540 --> 00:40:03,860
to allocate a specific

00:39:59,780 --> 00:40:07,550
a specific instance based on the

00:40:03,860 --> 00:40:09,920
priority and then below that we could

00:40:07,550 --> 00:40:13,580
add some the notion of load balancer

00:40:09,920 --> 00:40:15,350
which you would gather all crypto

00:40:13,580 --> 00:40:18,230
engines which implement a specific

00:40:15,350 --> 00:40:20,570
algorithm and then at the load balancer

00:40:18,230 --> 00:40:22,940
level decide which one should be used

00:40:20,570 --> 00:40:31,040
depending on the current load on each

00:40:22,940 --> 00:40:35,830
engine so yeah that's some IDs that's

00:40:31,040 --> 00:40:35,830
all I have about the Crito API I am

00:40:36,700 --> 00:40:44,800
telling stuff yeah so do you have any

00:40:39,980 --> 00:40:44,800
question or suggestion or comments yep

00:40:53,020 --> 00:40:58,730
okay so you want to access the the

00:40:55,730 --> 00:41:00,680
question is what's it's a comment you

00:40:58,730 --> 00:41:02,900
want to directly access the hardware and

00:41:00,680 --> 00:41:07,190
join directly from user space so you're

00:41:02,900 --> 00:41:09,620
not using Linux yeah actually it should

00:41:07,190 --> 00:41:12,860
give good performances compared to the

00:41:09,620 --> 00:41:15,050
numbers I gave here because it's

00:41:12,860 --> 00:41:17,210
complete completely bypassing all the

00:41:15,050 --> 00:41:19,100
the kind of stuff and all the overhead

00:41:17,210 --> 00:41:26,390
you can have when you're switching to

00:41:19,100 --> 00:41:33,160
Jesus modern and so on yeah actually I'm

00:41:26,390 --> 00:41:37,480
not the one you should ask to it yeah

00:41:33,160 --> 00:41:37,480
you should talk to Albert

00:41:41,850 --> 00:41:53,530
yeah why not

00:41:43,510 --> 00:41:55,780
I mean so anyway it would be a nursing

00:41:53,530 --> 00:41:58,240
Cronus scripts are engine wicked cue

00:41:55,780 --> 00:42:02,170
some requests and then wait for does

00:41:58,240 --> 00:42:04,000
request you to be complete so it I think

00:42:02,170 --> 00:42:09,600
it will it would it would feel pretty

00:42:04,000 --> 00:42:14,820
well in the crypto API I can tell I

00:42:09,600 --> 00:42:18,160
think if you are using the FPGA to you

00:42:14,820 --> 00:42:20,410
access to to provide things to the use

00:42:18,160 --> 00:42:22,750
space then you would have also poor

00:42:20,410 --> 00:42:25,570
performances because you still have all

00:42:22,750 --> 00:42:27,190
the the stacked you to go through every

00:42:25,570 --> 00:42:31,950
time you want to do crypto requests

00:42:27,190 --> 00:42:31,950
which is where the overhead is

00:42:42,920 --> 00:42:47,690
no actually you just after you and so

00:42:44,990 --> 00:42:51,050
the question is what has to be done to

00:42:47,690 --> 00:42:54,820
enable the crypto manager test self test

00:42:51,050 --> 00:42:57,500
actually it's just an option to enable

00:42:54,820 --> 00:43:00,640
by default all the tests are disabled

00:42:57,500 --> 00:43:03,640
just just enable an option and it's done

00:43:00,640 --> 00:43:03,640
yep

00:43:07,030 --> 00:43:10,180
absolutely not

00:43:21,270 --> 00:43:27,570
okay so the question is did I consider

00:43:24,060 --> 00:43:31,619
the pork consumption when doing my test

00:43:27,570 --> 00:43:34,160
and the answer is no actually the

00:43:31,619 --> 00:43:36,869
comment is that some enzymes are

00:43:34,160 --> 00:43:39,480
consuming less than the CPU so even if

00:43:36,869 --> 00:43:41,610
the CPU is a bit more elite in the end

00:43:39,480 --> 00:43:44,960
it would be interesting to use the crypt

00:43:41,610 --> 00:43:48,000
engine is that right yeah

00:43:44,960 --> 00:43:54,710
yeah I don't know I I had I would have

00:43:48,000 --> 00:43:54,710
to do more tests you to test that yep

00:44:16,280 --> 00:44:24,800
okay I think we there the world crypto

00:44:19,760 --> 00:44:28,510
API is based on SG scatter list so it's

00:44:24,800 --> 00:44:31,040
or it should already be ready for DMA I

00:44:28,510 --> 00:44:33,680
think what you want is to have

00:44:31,040 --> 00:44:35,810
everything contiguously allocated so I

00:44:33,680 --> 00:44:38,930
don't know if there are solutions you

00:44:35,810 --> 00:44:41,500
allocate the crypto requests and no

00:44:38,930 --> 00:44:41,500
contribution

00:44:52,170 --> 00:44:56,760
actually this is the crypto user which

00:44:54,660 --> 00:45:03,329
is allocating the data to be encrypted

00:44:56,760 --> 00:45:05,700
or decrypted or whatever yeah so you

00:45:03,329 --> 00:45:08,970
want to have an interface you ask the

00:45:05,700 --> 00:45:12,299
driver to allocate the data okay I don't

00:45:08,970 --> 00:45:14,910
know if it's planned but yeah that would

00:45:12,299 --> 00:45:17,869
be a solution if you want to use a

00:45:14,910 --> 00:45:23,869
pre-allocated pool in order to have

00:45:17,869 --> 00:45:23,869
things in a specific area of the memory

00:45:26,059 --> 00:45:29,059
okay

00:45:35,240 --> 00:45:37,869
okay

00:45:39,540 --> 00:45:44,270
any questions any more questions yeah

00:45:48,890 --> 00:45:59,519
yeah so I didn't mention that is cortex

00:45:52,500 --> 00:46:02,759
a9 for course so basically when you have

00:45:59,519 --> 00:46:05,579
this test it's only using one core this

00:46:02,759 --> 00:46:09,809
one sorry it's only using one core and

00:46:05,579 --> 00:46:14,430
when you have the 128 threads it's using

00:46:09,809 --> 00:46:18,269
the four cores to do the operation but

00:46:14,430 --> 00:46:23,329
still it's it's still performing better

00:46:18,269 --> 00:46:23,329
than the hardware in China

00:46:47,569 --> 00:46:52,599
there is a fine /proc something

00:47:16,340 --> 00:47:25,150
mmm no I am no answer to that sorry

00:47:22,150 --> 00:47:25,150
yeah

00:47:28,380 --> 00:47:31,940
sorry I don't hear you

00:47:32,130 --> 00:47:37,319
actually the OpenSSL tests are only

00:47:34,440 --> 00:47:40,700
doing tests on maximum eight kilobytes

00:47:37,319 --> 00:47:44,069
so I didn't test on more than a kilobyte

00:47:40,700 --> 00:47:47,910
but I think it's since the engine is

00:47:44,069 --> 00:47:58,319
acting on 2k Knox shouldn't change that

00:47:47,910 --> 00:48:01,670
much in our case sorry I don't hear it

00:47:58,319 --> 00:48:01,670
can you come closer

00:48:13,820 --> 00:48:18,480
yep

00:48:15,200 --> 00:48:20,810
Wiki we could do that then yeah it

00:48:18,480 --> 00:48:20,810
should

00:48:40,290 --> 00:48:42,860
yeah

00:48:53,690 --> 00:48:56,890
okay No

00:49:04,250 --> 00:49:20,800
how does yeah it's it's an algorithm

00:49:16,520 --> 00:49:23,450
which is arch optimized so it's using

00:49:20,800 --> 00:49:27,200
assembly specific instructions so it's

00:49:23,450 --> 00:49:29,720
basically implementing using an S case

00:49:27,200 --> 00:49:33,650
for R which is relying on specific

00:49:29,720 --> 00:49:34,040
instructions is that what you were

00:49:33,650 --> 00:49:37,430
asking

00:49:34,040 --> 00:49:40,250
yeah so yeah everything every

00:49:37,430 --> 00:49:44,590
implementation which our arc optimized

00:49:40,250 --> 00:49:49,730
are also exposed as crypto Ally that's

00:49:44,590 --> 00:49:53,920
that's using the same interface yeah

00:49:49,730 --> 00:49:53,920
wait maybe last one okay

00:50:14,110 --> 00:50:25,540
yeah I think there is a way to do the

00:50:17,260 --> 00:50:32,980
okapi I didn't dig into it okay but not

00:50:25,540 --> 00:50:36,790
the other way okay I don't know you

00:50:32,980 --> 00:50:39,480
should ask the crypto maintainer for

00:50:36,790 --> 00:50:42,080
that sorry

00:50:39,480 --> 00:50:47,590
Thanks

00:50:42,080 --> 00:50:47,590

YouTube URL: https://www.youtube.com/watch?v=2JRgBr_5jsI


