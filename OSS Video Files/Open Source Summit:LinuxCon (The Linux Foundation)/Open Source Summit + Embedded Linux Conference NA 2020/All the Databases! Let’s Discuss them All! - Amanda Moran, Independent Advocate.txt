Title: All the Databases! Letâ€™s Discuss them All! - Amanda Moran, Independent Advocate
Publication date: 2020-09-08
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	All the Databases! Letâ€™s Discuss them All! - Amanda Moran, Independent Advocate
Captions: 
	00:00:02,960 --> 00:00:06,480
hi there everyone thank you for

00:00:04,640 --> 00:00:08,320
joining my talk today we're going to

00:00:06,480 --> 00:00:08,800
talk about all the databases and we're

00:00:08,320 --> 00:00:11,920
going to

00:00:08,800 --> 00:00:14,799
discuss them all um so

00:00:11,920 --> 00:00:15,599
let's jump right into it so i like to

00:00:14,799 --> 00:00:17,279
have an agenda

00:00:15,599 --> 00:00:18,960
in my talks i know some folks don't like

00:00:17,279 --> 00:00:21,439
them they think they're too basic

00:00:18,960 --> 00:00:22,160
but i do like them and for me the type

00:00:21,439 --> 00:00:24,800
of learner i

00:00:22,160 --> 00:00:26,000
am i like to have an overview or a high

00:00:24,800 --> 00:00:28,480
level before i

00:00:26,000 --> 00:00:30,080
i go into the deep and you know the more

00:00:28,480 --> 00:00:31,039
technical information so i like an

00:00:30,080 --> 00:00:32,559
overview

00:00:31,039 --> 00:00:33,520
it kind of gives my brain like a basis

00:00:32,559 --> 00:00:34,880
of what we're going to talk about so

00:00:33,520 --> 00:00:36,719
that's what we're going to do

00:00:34,880 --> 00:00:38,800
so we're going to talk about the basics

00:00:36,719 --> 00:00:39,760
uh and database history

00:00:38,800 --> 00:00:41,760
because we're going to talk about all

00:00:39,760 --> 00:00:43,200
databases and i love history so we'll

00:00:41,760 --> 00:00:44,320
talk a little bit about history

00:00:43,200 --> 00:00:46,559
we're going to talk about relational

00:00:44,320 --> 00:00:49,120
databases and use an example

00:00:46,559 --> 00:00:49,920
postgres and mysql we're going to talk

00:00:49,120 --> 00:00:52,320
about

00:00:49,920 --> 00:00:52,960
nosql databases we're going to use as

00:00:52,320 --> 00:00:55,840
our example

00:00:52,960 --> 00:00:57,039
apache cassandra and foundationdb and

00:00:55,840 --> 00:00:58,800
then we're going to talk about graph

00:00:57,039 --> 00:00:59,760
databases and we're going to talk about

00:00:58,800 --> 00:01:01,760
as our example

00:00:59,760 --> 00:01:03,120
apache tinker pop then we're going to go

00:01:01,760 --> 00:01:06,240
through some next steps

00:01:03,120 --> 00:01:08,799
of this is just a very introductory talk

00:01:06,240 --> 00:01:10,840
so it's going to help guide you on you

00:01:08,799 --> 00:01:12,560
know where to take this learning even

00:01:10,840 --> 00:01:14,799
further

00:01:12,560 --> 00:01:17,200
so uh and just one thing before we jump

00:01:14,799 --> 00:01:19,600
into uh here let me go back one

00:01:17,200 --> 00:01:20,560
um before we talk about me of course we

00:01:19,600 --> 00:01:22,720
want to talk about me

00:01:20,560 --> 00:01:24,240
but for each one of these database types

00:01:22,720 --> 00:01:25,360
we're going to explore like i said a

00:01:24,240 --> 00:01:26,560
little bit of history

00:01:25,360 --> 00:01:29,280
we're going to show an open source

00:01:26,560 --> 00:01:31,040
example of that type of database

00:01:29,280 --> 00:01:32,799
we're going to talk about when to use

00:01:31,040 --> 00:01:34,880
that type of database and when not to

00:01:32,799 --> 00:01:36,560
use that type of database

00:01:34,880 --> 00:01:38,240
and we're going to talk about a bit

00:01:36,560 --> 00:01:40,400
about like the open source communities

00:01:38,240 --> 00:01:42,320
that are around these databases

00:01:40,400 --> 00:01:44,240
and actually even ways that you can kind

00:01:42,320 --> 00:01:46,240
of contribute and continue to learn

00:01:44,240 --> 00:01:48,079
uh and again just get us thinking and

00:01:46,240 --> 00:01:49,920
talking about this

00:01:48,079 --> 00:01:51,360
so let me introduce myself first now

00:01:49,920 --> 00:01:53,119
that we kind of have a idea of what

00:01:51,360 --> 00:01:54,159
we're going to spend our next 40 minutes

00:01:53,119 --> 00:01:56,399
talking about

00:01:54,159 --> 00:01:58,320
so i have a master's in computer science

00:01:56,399 --> 00:02:00,560
from santa clara university

00:01:58,320 --> 00:02:01,840
and before that i actually have a bs in

00:02:00,560 --> 00:02:02,880
biology

00:02:01,840 --> 00:02:04,799
that i got from the university of

00:02:02,880 --> 00:02:05,200
washington i worked in silicon valley

00:02:04,799 --> 00:02:07,119
for

00:02:05,200 --> 00:02:08,640
over eight years now many different

00:02:07,119 --> 00:02:11,920
companies from big

00:02:08,640 --> 00:02:14,080
very big companies like hp and teradata

00:02:11,920 --> 00:02:15,440
to even very small startups with only 30

00:02:14,080 --> 00:02:18,000
people um

00:02:15,440 --> 00:02:19,360
so in that journey i've worked on five

00:02:18,000 --> 00:02:20,480
different databases

00:02:19,360 --> 00:02:23,200
so i've worked on three different

00:02:20,480 --> 00:02:25,360
proprietary databases such as that hp

00:02:23,200 --> 00:02:27,040
and at teradata and then i work on two

00:02:25,360 --> 00:02:29,920
different open source databases such as

00:02:27,040 --> 00:02:31,519
apache tripodium and apache cassandra

00:02:29,920 --> 00:02:33,040
and even from there i've worked on two

00:02:31,519 --> 00:02:35,040
different distributed systems

00:02:33,040 --> 00:02:36,720
which is apache spargan and kubernetes

00:02:35,040 --> 00:02:38,720
so i'm well versed in

00:02:36,720 --> 00:02:40,480
the different types of databases and the

00:02:38,720 --> 00:02:43,120
different types of distributed systems

00:02:40,480 --> 00:02:45,519
also some of you may know me every once

00:02:43,120 --> 00:02:46,879
in a while i get someone who um

00:02:45,519 --> 00:02:48,160
who comes up to me and says you're my

00:02:46,879 --> 00:02:49,599
teacher and i have no idea what they're

00:02:48,160 --> 00:02:52,239
talking about and that's because they

00:02:49,599 --> 00:02:53,519
have taken the udacity data engineering

00:02:52,239 --> 00:02:55,200
course

00:02:53,519 --> 00:02:56,640
and i've taught the data modeling

00:02:55,200 --> 00:02:58,000
portion of that course

00:02:56,640 --> 00:02:59,840
so hopefully you know a little bit about

00:02:58,000 --> 00:03:01,120
me and some of my credentials of why i'm

00:02:59,840 --> 00:03:02,640
here to talk to you about these things

00:03:01,120 --> 00:03:05,120
today

00:03:02,640 --> 00:03:06,879
so what i also want to talk about is why

00:03:05,120 --> 00:03:10,000
should you care about this

00:03:06,879 --> 00:03:12,480
so first and foremost uh for me

00:03:10,000 --> 00:03:14,319
i find uh the technology itself around

00:03:12,480 --> 00:03:15,840
databases which doesn't sound very

00:03:14,319 --> 00:03:17,599
you know cool and interesting it

00:03:15,840 --> 00:03:19,599
actually really is so

00:03:17,599 --> 00:03:21,040
um i took a quite a few years ago a

00:03:19,599 --> 00:03:23,360
stanford database course

00:03:21,040 --> 00:03:24,720
by professor jennifer whitham uh the

00:03:23,360 --> 00:03:27,040
course is still available i

00:03:24,720 --> 00:03:28,319
actually link it in the uh in the slide

00:03:27,040 --> 00:03:30,080
notes

00:03:28,319 --> 00:03:31,840
it's a great course it gives you we're

00:03:30,080 --> 00:03:34,159
just just like lightly

00:03:31,840 --> 00:03:36,239
touching the surface she goes into such

00:03:34,159 --> 00:03:37,680
depth it's an amazing class i'm so glad

00:03:36,239 --> 00:03:38,720
that i took it and it kind of started me

00:03:37,680 --> 00:03:40,560
on this journey

00:03:38,720 --> 00:03:42,239
um and it was free online it was one of

00:03:40,560 --> 00:03:43,519
the first free online courses and it's

00:03:42,239 --> 00:03:44,879
still three online today it's just a

00:03:43,519 --> 00:03:46,000
little bit different than it was before

00:03:44,879 --> 00:03:47,360
i was just checking that out the other

00:03:46,000 --> 00:03:48,560
day it's a little bit broken up

00:03:47,360 --> 00:03:50,720
a little bit differently but the

00:03:48,560 --> 00:03:53,120
contents all there

00:03:50,720 --> 00:03:54,000
but it's really all about the data right

00:03:53,120 --> 00:03:56,560
that's what's

00:03:54,000 --> 00:03:57,760
uh important here so where your data is

00:03:56,560 --> 00:04:00,720
persisted

00:03:57,760 --> 00:04:02,799
where your data is being analyzed how

00:04:00,720 --> 00:04:05,760
your data is being quickly served to you

00:04:02,799 --> 00:04:08,239
this is all done by the the back end and

00:04:05,760 --> 00:04:11,519
the underlying databases

00:04:08,239 --> 00:04:13,200
and then also your job depends on it

00:04:11,519 --> 00:04:15,439
so that sounds a little dramatic but

00:04:13,200 --> 00:04:16,239
it's very true so for example if you're

00:04:15,439 --> 00:04:18,239
a full stack

00:04:16,239 --> 00:04:21,359
engineer you have to know how to be able

00:04:18,239 --> 00:04:22,960
to interact uh with these databases

00:04:21,359 --> 00:04:24,560
it's just part of the stack and you're

00:04:22,960 --> 00:04:26,160
going to have to know how to interact

00:04:24,560 --> 00:04:27,840
with it and depending on the type of

00:04:26,160 --> 00:04:29,120
database that you're interacting with

00:04:27,840 --> 00:04:31,040
you may get to choose that

00:04:29,120 --> 00:04:32,560
you probably don't get to choose that

00:04:31,040 --> 00:04:34,240
and so you need to understand some of

00:04:32,560 --> 00:04:35,360
the basics of that so that you can

00:04:34,240 --> 00:04:38,000
interact with it

00:04:35,360 --> 00:04:39,759
in your application properly also for

00:04:38,000 --> 00:04:42,240
devops i mean it's pretty obvious

00:04:39,759 --> 00:04:43,520
you're doing the maintenance work you

00:04:42,240 --> 00:04:44,320
have to have an understanding of these

00:04:43,520 --> 00:04:45,840
databases

00:04:44,320 --> 00:04:48,479
so that you can actually most of the

00:04:45,840 --> 00:04:50,800
time when your application engineers are

00:04:48,479 --> 00:04:52,160
filing issues with you and tickets

00:04:50,800 --> 00:04:53,360
you're going to have to explain to them

00:04:52,160 --> 00:04:54,000
these high-level concepts so they

00:04:53,360 --> 00:04:55,199
understand

00:04:54,000 --> 00:04:56,479
why they can't do the certain things

00:04:55,199 --> 00:04:58,080
they can do with that particular

00:04:56,479 --> 00:05:01,039
database

00:04:58,080 --> 00:05:02,560
also for folks in analytics and machine

00:05:01,039 --> 00:05:03,840
learning like machine learning engineers

00:05:02,560 --> 00:05:05,440
and data scientists

00:05:03,840 --> 00:05:07,039
again this is something that's important

00:05:05,440 --> 00:05:08,320
to you as well because this is where

00:05:07,039 --> 00:05:11,120
you're going to be grabbing your data

00:05:08,320 --> 00:05:12,560
from um and so because of that that's

00:05:11,120 --> 00:05:14,320
going to make implications on how you're

00:05:12,560 --> 00:05:16,560
building your models how often you're

00:05:14,320 --> 00:05:18,080
you're bringing in that data be it batch

00:05:16,560 --> 00:05:19,280
be it streaming et cetera

00:05:18,080 --> 00:05:22,560
you're going to have to understand these

00:05:19,280 --> 00:05:24,560
different databases also at some point

00:05:22,560 --> 00:05:25,919
like i said your job depends on it you

00:05:24,560 --> 00:05:27,280
may have to choose one of these

00:05:25,919 --> 00:05:28,800
databases for your

00:05:27,280 --> 00:05:30,560
for your project and so you want to make

00:05:28,800 --> 00:05:31,919
sure you have a solid understanding

00:05:30,560 --> 00:05:33,280
of the different types of these so you

00:05:31,919 --> 00:05:34,400
can choose the right one for the right

00:05:33,280 --> 00:05:35,600
use case and for the right

00:05:34,400 --> 00:05:37,600
for the right job that you're trying to

00:05:35,600 --> 00:05:39,600
do

00:05:37,600 --> 00:05:41,840
okay so let's talk a little bit about

00:05:39,600 --> 00:05:43,520
the history of databases

00:05:41,840 --> 00:05:45,360
so this is this timeline here that i'm

00:05:43,520 --> 00:05:47,039
showing you uh it's a little different

00:05:45,360 --> 00:05:48,960
than ones i've kind of shown in the past

00:05:47,039 --> 00:05:50,560
um i i have a photo credit here

00:05:48,960 --> 00:05:52,800
uh i really like this because it just

00:05:50,560 --> 00:05:53,440
kind of makes it it makes you stop and

00:05:52,800 --> 00:05:56,000
think

00:05:53,440 --> 00:05:57,520
uh a little bit about how uh what's

00:05:56,000 --> 00:05:58,560
being represented here and it really

00:05:57,520 --> 00:06:00,160
gets you like

00:05:58,560 --> 00:06:01,919
just really paying attention to it so

00:06:00,160 --> 00:06:05,039
that's why i really liked it

00:06:01,919 --> 00:06:06,080
but as you can see here that relational

00:06:05,039 --> 00:06:08,080
databases uh

00:06:06,080 --> 00:06:10,080
started being researched and developed

00:06:08,080 --> 00:06:11,759
and so it shows the time of popularity

00:06:10,080 --> 00:06:13,039
for relational databases is around like

00:06:11,759 --> 00:06:14,720
the 1980s

00:06:13,039 --> 00:06:18,240
but they were researched and developed

00:06:14,720 --> 00:06:20,080
long before that in the 1970s at ibm

00:06:18,240 --> 00:06:22,240
and like i said you can see they got to

00:06:20,080 --> 00:06:24,479
be very popular in the 80s and 90s

00:06:22,240 --> 00:06:25,440
and they're still very popular uh don't

00:06:24,479 --> 00:06:27,440
get me wrong

00:06:25,440 --> 00:06:29,680
uh so this this doesn't mean that these

00:06:27,440 --> 00:06:31,440
are now as they trend down in time that

00:06:29,680 --> 00:06:33,199
these are still not hugely popular

00:06:31,440 --> 00:06:36,160
because they they really are

00:06:33,199 --> 00:06:36,800
so relational database management

00:06:36,160 --> 00:06:39,759
systems

00:06:36,800 --> 00:06:41,840
otherwise known as rda bms are these

00:06:39,759 --> 00:06:44,400
powerful systems that are generally

00:06:41,840 --> 00:06:47,120
very large systems that have um they

00:06:44,400 --> 00:06:49,280
don't generally have easy ways to scale

00:06:47,120 --> 00:06:50,240
um they certainly can't scale

00:06:49,280 --> 00:06:52,880
horizontally

00:06:50,240 --> 00:06:54,080
and when they're scaling vertically they

00:06:52,880 --> 00:06:58,319
can do that but it's

00:06:54,080 --> 00:07:00,880
it's difficult um so because of that

00:06:58,319 --> 00:07:02,080
you actually have to have data modeling

00:07:00,880 --> 00:07:05,120
concepts

00:07:02,080 --> 00:07:06,880
uh around that um that kind of limit

00:07:05,120 --> 00:07:08,960
your data you can only have

00:07:06,880 --> 00:07:10,319
uh it's not that they're small but you

00:07:08,960 --> 00:07:12,319
need to make sure that you you don't

00:07:10,319 --> 00:07:13,360
have a lot of data redundancy it affects

00:07:12,319 --> 00:07:14,720
your data model

00:07:13,360 --> 00:07:17,199
and you're wanting to make sure that you

00:07:14,720 --> 00:07:19,919
have data integrity

00:07:17,199 --> 00:07:21,599
so um you want to make sure when i say

00:07:19,919 --> 00:07:23,280
data integrity that your data is only in

00:07:21,599 --> 00:07:25,039
one place

00:07:23,280 --> 00:07:26,800
and also um you want to make sure that

00:07:25,039 --> 00:07:28,479
you're reducing the actual space because

00:07:26,800 --> 00:07:30,160
you're you're not able to scale out

00:07:28,479 --> 00:07:31,199
horizontally only vertically so you want

00:07:30,160 --> 00:07:34,479
to make sure that you're

00:07:31,199 --> 00:07:36,960
you're you know taking that for account

00:07:34,479 --> 00:07:38,639
so um with the exploding of the internet

00:07:36,960 --> 00:07:40,400
in the 2000s

00:07:38,639 --> 00:07:42,479
that's when you saw nosql databases

00:07:40,400 --> 00:07:44,160
really starting to to get traction

00:07:42,479 --> 00:07:45,680
and they had been in research and

00:07:44,160 --> 00:07:47,520
development long before that but you

00:07:45,680 --> 00:07:49,280
really start to see them get traction

00:07:47,520 --> 00:07:50,879
as an internet explodes and data

00:07:49,280 --> 00:07:52,560
explodes

00:07:50,879 --> 00:07:53,919
so there's a variety and you'll see here

00:07:52,560 --> 00:07:55,120
in this graphic there's a variety of

00:07:53,919 --> 00:07:58,479
different types

00:07:55,120 --> 00:07:58,800
of nosql databases that help you scale

00:07:58,479 --> 00:08:01,520
out

00:07:58,800 --> 00:08:02,319
horizontally like i was saying before um

00:08:01,520 --> 00:08:04,160
and help

00:08:02,319 --> 00:08:05,440
you know serve your application you know

00:08:04,160 --> 00:08:06,960
with much

00:08:05,440 --> 00:08:09,919
to get that data much quicker with lower

00:08:06,960 --> 00:08:11,680
latencies and so the different types of

00:08:09,919 --> 00:08:14,800
nosql implementations

00:08:11,680 --> 00:08:15,520
as you can see here are key value column

00:08:14,800 --> 00:08:17,759
oriented

00:08:15,520 --> 00:08:19,759
document oriented and also as you kind

00:08:17,759 --> 00:08:21,360
of see is a little

00:08:19,759 --> 00:08:23,199
it's also nosql database it's a little

00:08:21,360 --> 00:08:24,479
bit different which is a graph database

00:08:23,199 --> 00:08:25,520
and we're going to talk about that as

00:08:24,479 --> 00:08:27,199
well

00:08:25,520 --> 00:08:29,120
so like i said before we're going to

00:08:27,199 --> 00:08:31,680
focus on apache cassandra and

00:08:29,120 --> 00:08:32,479
foundation db foundation dv is a key

00:08:31,680 --> 00:08:35,039
value

00:08:32,479 --> 00:08:35,599
uh database and apache cassandra is

00:08:35,039 --> 00:08:38,000
actually

00:08:35,599 --> 00:08:39,279
a partition rose store uh which isn't

00:08:38,000 --> 00:08:41,839
listed here

00:08:39,279 --> 00:08:43,680
so most people call it a columner that's

00:08:41,839 --> 00:08:44,959
fine it's really a partition row store

00:08:43,680 --> 00:08:48,000
but for the sake of this we'll just

00:08:44,959 --> 00:08:50,880
we'll just put it in the columner

00:08:48,000 --> 00:08:52,160
category because most most books do so

00:08:50,880 --> 00:08:53,200
then also you can see the graph

00:08:52,160 --> 00:08:54,880
databases

00:08:53,200 --> 00:08:57,040
they've started to become more popular

00:08:54,880 --> 00:08:59,600
here in recent years

00:08:57,040 --> 00:09:00,880
because all around analytics right it's

00:08:59,600 --> 00:09:02,640
all about

00:09:00,880 --> 00:09:04,240
understanding the relationships between

00:09:02,640 --> 00:09:06,320
your data and we'll dive into that here

00:09:04,240 --> 00:09:08,080
in a little bit but now that data is

00:09:06,320 --> 00:09:09,839
really at the forefront

00:09:08,080 --> 00:09:11,200
of what we're doing it's not just about

00:09:09,839 --> 00:09:13,040
persisting the data

00:09:11,200 --> 00:09:14,399
or serving you know some data to a

00:09:13,040 --> 00:09:15,839
website it's about also

00:09:14,399 --> 00:09:18,160
analyzing it and so that's where graph

00:09:15,839 --> 00:09:19,680
databases come in so that now that you

00:09:18,160 --> 00:09:21,120
know a little bit of your database

00:09:19,680 --> 00:09:23,040
history

00:09:21,120 --> 00:09:24,959
we're going to now start talking about

00:09:23,040 --> 00:09:26,800
each one of these databases

00:09:24,959 --> 00:09:28,399
and really the reaction to the error

00:09:26,800 --> 00:09:31,760
that they were in and

00:09:28,399 --> 00:09:31,760
help us shape our understanding

00:09:32,800 --> 00:09:36,480
so uh and also in this talk we're going

00:09:34,640 --> 00:09:38,800
to focus on open source

00:09:36,480 --> 00:09:39,600
so open source has been proven you know

00:09:38,800 --> 00:09:41,760
to have one

00:09:39,600 --> 00:09:42,800
and i actually link an article here uh

00:09:41,760 --> 00:09:46,240
as well

00:09:42,800 --> 00:09:47,120
um it's really proven to win in the in

00:09:46,240 --> 00:09:49,760
the community

00:09:47,120 --> 00:09:51,839
in the industry so companies feel safer

00:09:49,760 --> 00:09:55,839
investing in a technology that has

00:09:51,839 --> 00:09:57,440
a strong community behind it um

00:09:55,839 --> 00:09:59,279
they don't want to be locked in that's

00:09:57,440 --> 00:10:00,160
why they care about you know using open

00:09:59,279 --> 00:10:02,880
source

00:10:00,160 --> 00:10:04,079
and it's it's easier to hire experts as

00:10:02,880 --> 00:10:05,519
well when you're talking about open

00:10:04,079 --> 00:10:08,800
source technologies

00:10:05,519 --> 00:10:10,640
um also

00:10:08,800 --> 00:10:12,160
um companies like to have a little bit

00:10:10,640 --> 00:10:14,320
of you know

00:10:12,160 --> 00:10:15,920
say over the road map of a particular

00:10:14,320 --> 00:10:17,920
technology as well which is what you get

00:10:15,920 --> 00:10:20,160
with open source if you contribute to it

00:10:17,920 --> 00:10:21,839
you can become part of that community

00:10:20,160 --> 00:10:23,279
and and help shape you know the way the

00:10:21,839 --> 00:10:24,800
product actually goes whereas when

00:10:23,279 --> 00:10:25,519
you're buying a proprietary product you

00:10:24,800 --> 00:10:28,079
have to be

00:10:25,519 --> 00:10:29,760
a very large customer uh to have that

00:10:28,079 --> 00:10:32,480
kind of sway

00:10:29,760 --> 00:10:32,800
right also just here's just another note

00:10:32,480 --> 00:10:35,600
um

00:10:32,800 --> 00:10:37,200
about open source uh and the community

00:10:35,600 --> 00:10:39,040
communities are amazing

00:10:37,200 --> 00:10:40,320
um it's not just the contributors who

00:10:39,040 --> 00:10:40,880
commit you know committing the code

00:10:40,320 --> 00:10:43,279
which is

00:10:40,880 --> 00:10:44,079
also incredible but there's so much

00:10:43,279 --> 00:10:47,600
support there

00:10:44,079 --> 00:10:50,640
in training tutorials documentation

00:10:47,600 --> 00:10:52,959
mailing lists and all for free

00:10:50,640 --> 00:10:55,040
um so many of the communities i've been

00:10:52,959 --> 00:10:57,440
a part of especially in the apache

00:10:55,040 --> 00:10:58,240
apache projects i've been a part of the

00:10:57,440 --> 00:11:00,880
you know you can

00:10:58,240 --> 00:11:02,240
do right to the mailing list and post

00:11:00,880 --> 00:11:03,600
questions to get support from the

00:11:02,240 --> 00:11:05,279
community and generally

00:11:03,600 --> 00:11:06,800
i mean there's no slas around that but

00:11:05,279 --> 00:11:07,519
you generally get people responding to

00:11:06,800 --> 00:11:09,839
you within

00:11:07,519 --> 00:11:11,519
hours just out of the goodness of their

00:11:09,839 --> 00:11:13,600
heart so

00:11:11,519 --> 00:11:15,120
it's really impressive and it's really

00:11:13,600 --> 00:11:18,000
great to be around these these

00:11:15,120 --> 00:11:18,000
type of communities

00:11:18,480 --> 00:11:22,480
all right so let's jump in here to our

00:11:21,120 --> 00:11:23,440
very first database

00:11:22,480 --> 00:11:25,760
and we're going to start talking about

00:11:23,440 --> 00:11:27,360
relational database so this is the one

00:11:25,760 --> 00:11:30,880
that you're most likely to be

00:11:27,360 --> 00:11:33,040
familiar with like i said in that date

00:11:30,880 --> 00:11:34,560
of the very first database course i took

00:11:33,040 --> 00:11:36,079
um of course it was all around

00:11:34,560 --> 00:11:37,839
relational databases

00:11:36,079 --> 00:11:40,839
so like i said you know when it was

00:11:37,839 --> 00:11:43,279
developed in the 70s

00:11:40,839 --> 00:11:45,519
um at ibm

00:11:43,279 --> 00:11:47,519
from cod and his team they actually

00:11:45,519 --> 00:11:49,920
developed not just the technology

00:11:47,519 --> 00:11:50,959
but the 12 rules of what makes a

00:11:49,920 --> 00:11:54,160
relational database

00:11:50,959 --> 00:11:56,720
a relational database so i

00:11:54,160 --> 00:11:57,519
really like focused here on rule one

00:11:56,720 --> 00:12:00,000
which is all

00:11:57,519 --> 00:12:01,760
information in a relational database is

00:12:00,000 --> 00:12:04,399
represented explicitly

00:12:01,760 --> 00:12:06,800
at the logical level in exactly one way

00:12:04,399 --> 00:12:08,399
by values in tables

00:12:06,800 --> 00:12:10,079
so here you can see it's a little bit

00:12:08,399 --> 00:12:12,320
small here on my slide

00:12:10,079 --> 00:12:13,600
but you can see we have our relation

00:12:12,320 --> 00:12:15,680
which is our table

00:12:13,600 --> 00:12:17,440
then we have our attributes right

00:12:15,680 --> 00:12:18,720
attributes of you know whatever we're

00:12:17,440 --> 00:12:20,959
trying to represent

00:12:18,720 --> 00:12:22,880
um that's normally our columns and then

00:12:20,959 --> 00:12:26,720
our tuple which is our row

00:12:22,880 --> 00:12:29,440
right so um

00:12:26,720 --> 00:12:31,519
so from there one of the other rules of

00:12:29,440 --> 00:12:33,279
having a relational database is it must

00:12:31,519 --> 00:12:36,240
have acid transactions

00:12:33,279 --> 00:12:37,440
and asset transactions are around

00:12:36,240 --> 00:12:40,560
automaticity

00:12:37,440 --> 00:12:42,160
consistency isolation and durability

00:12:40,560 --> 00:12:43,760
and we'll just talk with just a second

00:12:42,160 --> 00:12:45,200
let me just break down each one of those

00:12:43,760 --> 00:12:48,320
for you

00:12:45,200 --> 00:12:49,839
so really think about um asset

00:12:48,320 --> 00:12:51,279
transactions are all around data

00:12:49,839 --> 00:12:53,680
integrity

00:12:51,279 --> 00:12:55,519
it's making sure thinking about a good

00:12:53,680 --> 00:12:56,320
example of data integrity and asset

00:12:55,519 --> 00:12:58,639
transactions

00:12:56,320 --> 00:12:59,360
is around like a bank transfer right if

00:12:58,639 --> 00:13:02,720
i'm moving

00:12:59,360 --> 00:13:04,560
money from one savings to checking

00:13:02,720 --> 00:13:06,160
that all has to happen within a

00:13:04,560 --> 00:13:08,560
transaction in one

00:13:06,160 --> 00:13:10,399
one fail swoop has to happen because if

00:13:08,560 --> 00:13:12,320
anything gets messed up along the way

00:13:10,399 --> 00:13:13,440
and it's not in a single transaction i

00:13:12,320 --> 00:13:15,440
may have um

00:13:13,440 --> 00:13:17,120
you know it deducts the money but then

00:13:15,440 --> 00:13:18,560
doesn't put it into my checking

00:13:17,120 --> 00:13:20,320
right and so now i'm just lost this

00:13:18,560 --> 00:13:20,800
money right and banks can't have that

00:13:20,320 --> 00:13:22,320
and

00:13:20,800 --> 00:13:24,399
we can't have that we can't handle that

00:13:22,320 --> 00:13:25,519
kind of stress so

00:13:24,399 --> 00:13:28,240
that's why you have to have an asset

00:13:25,519 --> 00:13:31,360
transaction so

00:13:28,240 --> 00:13:33,200
as a transaction like you said um

00:13:31,360 --> 00:13:35,040
it makes sure that every every step

00:13:33,200 --> 00:13:37,760
along the way is correct

00:13:35,040 --> 00:13:39,279
and it guarantees uh validity even in

00:13:37,760 --> 00:13:42,720
the event of errors

00:13:39,279 --> 00:13:44,399
or power failures things like that so

00:13:42,720 --> 00:13:46,240
it's a set of operations to make sure

00:13:44,399 --> 00:13:48,959
that transaction happens

00:13:46,240 --> 00:13:50,079
so with atomicity it's it's all around

00:13:48,959 --> 00:13:52,240
all or nothing

00:13:50,079 --> 00:13:54,000
right so either it all happens or it

00:13:52,240 --> 00:13:56,399
doesn't and it rolls back

00:13:54,000 --> 00:13:57,920
with consistency the data has to fit the

00:13:56,399 --> 00:13:59,760
rules of the database

00:13:57,920 --> 00:14:02,560
and the column so if i'm trying to

00:13:59,760 --> 00:14:03,920
insert a string into a boolean column

00:14:02,560 --> 00:14:05,040
it's not going to let me do that right

00:14:03,920 --> 00:14:07,040
it's just going to kick that out and say

00:14:05,040 --> 00:14:10,399
yeah no sorry

00:14:07,040 --> 00:14:13,120
um with isolation this is around

00:14:10,399 --> 00:14:14,160
the transactions are done as a single

00:14:13,120 --> 00:14:16,399
unit

00:14:14,160 --> 00:14:17,839
and not in any particular order so just

00:14:16,399 --> 00:14:20,079
because i submit

00:14:17,839 --> 00:14:22,720
one query and then a second query those

00:14:20,079 --> 00:14:25,600
are completely independent

00:14:22,720 --> 00:14:27,600
uh and from there with durability that's

00:14:25,600 --> 00:14:28,639
really around the transactions are saved

00:14:27,600 --> 00:14:30,639
or persisted

00:14:28,639 --> 00:14:32,160
so after the transaction is complete i

00:14:30,639 --> 00:14:34,160
could go ahead and pull the plug

00:14:32,160 --> 00:14:35,680
and my database could crash and go down

00:14:34,160 --> 00:14:37,839
but when i split it back up

00:14:35,680 --> 00:14:39,440
because that's been persisted it will be

00:14:37,839 --> 00:14:41,839
there

00:14:39,440 --> 00:14:43,440
so relational databases so not only do

00:14:41,839 --> 00:14:46,079
they have these two rules

00:14:43,440 --> 00:14:47,120
they also use sql as their primary query

00:14:46,079 --> 00:14:48,800
language

00:14:47,120 --> 00:14:50,480
so that's what you're going to see most

00:14:48,800 --> 00:14:52,480
of the time and here's just a little bit

00:14:50,480 --> 00:14:54,079
of sql that i wrote for you

00:14:52,480 --> 00:14:55,760
that we're probably all familiar with

00:14:54,079 --> 00:14:56,880
something like select star from my

00:14:55,760 --> 00:14:59,120
really cool table

00:14:56,880 --> 00:15:02,560
or the conference equals virtual and

00:14:59,120 --> 00:15:02,560
that's going to get me back a result

00:15:02,959 --> 00:15:07,279
all right so let's talk about the two

00:15:04,560 --> 00:15:10,320
examples of relational databases here

00:15:07,279 --> 00:15:11,600
so first off we have post postgres i

00:15:10,320 --> 00:15:14,639
call it postgres

00:15:11,600 --> 00:15:18,480
it can also be called uh

00:15:14,639 --> 00:15:20,880
i've heard it called uh post cql or

00:15:18,480 --> 00:15:22,480
post ql a lot of different names for it

00:15:20,880 --> 00:15:24,160
i call it postgres

00:15:22,480 --> 00:15:25,760
i was looking at the documentation and

00:15:24,160 --> 00:15:27,760
it sounds like there's um

00:15:25,760 --> 00:15:29,279
some debate on what it's on what it's

00:15:27,760 --> 00:15:31,440
called uh

00:15:29,279 --> 00:15:33,360
but you can call it uh in any one of

00:15:31,440 --> 00:15:35,839
those um

00:15:33,360 --> 00:15:37,440
so postgres and now uh here i'm gonna go

00:15:35,839 --> 00:15:38,000
into a little bit of comparison between

00:15:37,440 --> 00:15:40,720
the two

00:15:38,000 --> 00:15:42,800
because these two technologies um have

00:15:40,720 --> 00:15:44,639
some have a lot of similarities

00:15:42,800 --> 00:15:45,519
um and then they also have some

00:15:44,639 --> 00:15:47,120
differences so i just wanted to

00:15:45,519 --> 00:15:49,279
highlight those differences

00:15:47,120 --> 00:15:52,399
so uh postgres is developed by the

00:15:49,279 --> 00:15:54,160
postgres global development group

00:15:52,399 --> 00:15:56,399
so there's not just one company behind

00:15:54,160 --> 00:15:57,759
it they're uh they're not backed by any

00:15:56,399 --> 00:15:59,360
particular one company

00:15:57,759 --> 00:16:01,920
it's just a lot of developers coming

00:15:59,360 --> 00:16:05,120
together um to collaborate on this

00:16:01,920 --> 00:16:06,720
on this system uh and so it's actually

00:16:05,120 --> 00:16:07,199
it's not just a relational database but

00:16:06,720 --> 00:16:09,040
it's an

00:16:07,199 --> 00:16:10,240
object relational database and we'll

00:16:09,040 --> 00:16:11,920
kind of dig into a little bit of what

00:16:10,240 --> 00:16:15,519
that means here in a second

00:16:11,920 --> 00:16:18,160
and then mysql it was actually

00:16:15,519 --> 00:16:20,160
originally developed at sun microsystems

00:16:18,160 --> 00:16:20,880
and when sun microsystems was bought by

00:16:20,160 --> 00:16:24,079
oracle

00:16:20,880 --> 00:16:27,040
now oracle actually maintains my sequel

00:16:24,079 --> 00:16:28,079
so there was actually multiple forks of

00:16:27,040 --> 00:16:30,959
my sequel

00:16:28,079 --> 00:16:32,160
after the oracle acquisition so a really

00:16:30,959 --> 00:16:37,440
good example of that is

00:16:32,160 --> 00:16:40,160
uh maria db which was a fork

00:16:37,440 --> 00:16:41,839
of my sequel right at the acquisition

00:16:40,160 --> 00:16:43,839
from oracle

00:16:41,839 --> 00:16:45,759
so my sequel is actually from what i was

00:16:43,839 --> 00:16:48,000
reading uh doing some research

00:16:45,759 --> 00:16:49,199
it's uh significantly more popular than

00:16:48,000 --> 00:16:51,279
postgres

00:16:49,199 --> 00:16:53,040
uh in this report and i've linked it

00:16:51,279 --> 00:16:54,399
here it says 39 percent of developers

00:16:53,040 --> 00:16:55,680
use my sequel

00:16:54,399 --> 00:16:57,199
um so that's you know that's pretty

00:16:55,680 --> 00:16:58,880
substantial especially when as a

00:16:57,199 --> 00:16:59,360
developer you know there's so many tools

00:16:58,880 --> 00:17:01,199
out there

00:16:59,360 --> 00:17:03,040
it's hardest to get it's hard to get us

00:17:01,199 --> 00:17:04,880
you know on board on one thing

00:17:03,040 --> 00:17:07,280
at any one time so it's actually pretty

00:17:04,880 --> 00:17:09,120
impressive and it does have

00:17:07,280 --> 00:17:11,439
more third-party tools because it is

00:17:09,120 --> 00:17:13,439
more popular than postgres

00:17:11,439 --> 00:17:16,559
but let's go back to that the idea of

00:17:13,439 --> 00:17:18,640
being a an object-oriented database

00:17:16,559 --> 00:17:20,480
so not only is it object-oriented it's

00:17:18,640 --> 00:17:22,880
still a relational database

00:17:20,480 --> 00:17:23,600
um like i said both are very popular

00:17:22,880 --> 00:17:26,400
open source

00:17:23,600 --> 00:17:28,079
databases um at the research that i was

00:17:26,400 --> 00:17:31,360
doing at the time

00:17:28,079 --> 00:17:32,000
uh postgres for quite a bit of time had

00:17:31,360 --> 00:17:35,120
significantly

00:17:32,000 --> 00:17:36,880
better performance than my sequel but uh

00:17:35,120 --> 00:17:39,679
over the last couple of releases

00:17:36,880 --> 00:17:40,000
my sequel has really uh kind of decided

00:17:39,679 --> 00:17:42,320
to

00:17:40,000 --> 00:17:43,440
focus on performance and so they've been

00:17:42,320 --> 00:17:44,080
able to bring up those performance

00:17:43,440 --> 00:17:45,360
numbers so

00:17:44,080 --> 00:17:46,640
from what i was reading it seems like

00:17:45,360 --> 00:17:48,160
the performance is actually kind of

00:17:46,640 --> 00:17:51,919
comparable now

00:17:48,160 --> 00:17:55,120
um both use sql as their as their

00:17:51,919 --> 00:17:58,640
primary language to query with uh

00:17:55,120 --> 00:18:00,080
postgres has uh kind of less of a user

00:17:58,640 --> 00:18:03,280
base as we talked about before because

00:18:00,080 --> 00:18:03,280
it's not quite as popular

00:18:03,520 --> 00:18:07,120
but it does have functionality

00:18:07,360 --> 00:18:11,120
the different functionality than mysql

00:18:09,039 --> 00:18:14,080
because it has this object oriented

00:18:11,120 --> 00:18:16,480
ability so it allows for functionality

00:18:14,080 --> 00:18:19,440
of like more complex data types

00:18:16,480 --> 00:18:22,160
than uh than just rows and and columns

00:18:19,440 --> 00:18:25,919
than mysql has

00:18:22,160 --> 00:18:26,799
so also i read that read workloads can

00:18:25,919 --> 00:18:28,720
be a little bit

00:18:26,799 --> 00:18:30,400
because of this object-oriented nature

00:18:28,720 --> 00:18:31,440
when you have a heavy read workload

00:18:30,400 --> 00:18:33,600
sometimes postgres

00:18:31,440 --> 00:18:35,520
uh the performance is a little bit uh

00:18:33,600 --> 00:18:37,440
degraded over my sequel so it's

00:18:35,520 --> 00:18:39,679
something to consider

00:18:37,440 --> 00:18:41,360
so this isn't really a statement on on

00:18:39,679 --> 00:18:42,559
either which one of these to use i'm

00:18:41,360 --> 00:18:44,480
just kind of highlighting

00:18:42,559 --> 00:18:46,320
how well they do seem very similar there

00:18:44,480 --> 00:18:48,960
are a few differences

00:18:46,320 --> 00:18:50,559
um i also i've linked here in the the

00:18:48,960 --> 00:18:53,440
speaker notes and a nice article that

00:18:50,559 --> 00:18:53,440
compares them as well

00:18:54,000 --> 00:18:58,000
so just a word uh since we're talking

00:18:56,240 --> 00:18:59,600
about relational databases

00:18:58,000 --> 00:19:01,039
and databases in general it's good to

00:18:59,600 --> 00:19:05,200
just have a word on

00:19:01,039 --> 00:19:07,600
um o-l-a-p olap versus o-l-t-p

00:19:05,200 --> 00:19:08,559
and i always say that wrong i always

00:19:07,600 --> 00:19:11,919
want to say olaf

00:19:08,559 --> 00:19:15,440
instead of olap olaf's like from

00:19:11,919 --> 00:19:16,720
frozen but anyway one is the online

00:19:15,440 --> 00:19:18,320
analytical processing

00:19:16,720 --> 00:19:19,919
and one is online transactional

00:19:18,320 --> 00:19:22,799
processing

00:19:19,919 --> 00:19:24,640
so uh you can have relational databases

00:19:22,799 --> 00:19:26,160
or even non-relational databases

00:19:24,640 --> 00:19:28,640
they kind of fall in either one of these

00:19:26,160 --> 00:19:31,120
two categories larger categories

00:19:28,640 --> 00:19:33,200
so you use the analytical processing for

00:19:31,120 --> 00:19:35,520
doing analytics for doing a lot of

00:19:33,200 --> 00:19:37,039
ad hoc queries that are really optimized

00:19:35,520 --> 00:19:38,480
for reads

00:19:37,039 --> 00:19:40,799
you're not really looking to do high

00:19:38,480 --> 00:19:42,720
rights uh the data

00:19:40,799 --> 00:19:45,440
normally is loaded in batches not

00:19:42,720 --> 00:19:47,440
necessarily but that's some

00:19:45,440 --> 00:19:48,799
places i've worked that's kind of the

00:19:47,440 --> 00:19:50,080
lends itself to that

00:19:48,799 --> 00:19:51,360
and you're gonna have a lot of joints

00:19:50,080 --> 00:19:53,120
you know you're bringing tables together

00:19:51,360 --> 00:19:55,679
bringing information together

00:19:53,120 --> 00:19:56,400
now the online transactional processing

00:19:55,679 --> 00:19:59,440
that

00:19:56,400 --> 00:20:00,080
has normally less significant complex

00:19:59,440 --> 00:20:01,360
queries

00:20:00,080 --> 00:20:04,000
but you're gonna have many many many

00:20:01,360 --> 00:20:08,640
queries um rapid throughput

00:20:04,000 --> 00:20:08,640
so lots of read insert update and delete

00:20:08,799 --> 00:20:12,240
okay so when should i use a relational

00:20:11,280 --> 00:20:15,200
database

00:20:12,240 --> 00:20:15,840
so first and foremost if you want to use

00:20:15,200 --> 00:20:20,480
uh

00:20:15,840 --> 00:20:22,240
sql standard sql ansi sql uh

00:20:20,480 --> 00:20:23,520
there's there's some relational

00:20:22,240 --> 00:20:26,000
databases out there that

00:20:23,520 --> 00:20:27,280
have the ability to put you know maybe a

00:20:26,000 --> 00:20:29,600
sql layer on top

00:20:27,280 --> 00:20:31,919
or or things like that or they have

00:20:29,600 --> 00:20:34,480
languages that are similar to sql

00:20:31,919 --> 00:20:34,960
but if your skills really rely with sql

00:20:34,480 --> 00:20:37,840
and

00:20:34,960 --> 00:20:38,640
you um kind of also some of these other

00:20:37,840 --> 00:20:40,559
things i'm going to list

00:20:38,640 --> 00:20:42,240
as well you don't want to just use oh i

00:20:40,559 --> 00:20:43,120
only know sql so even though i have a

00:20:42,240 --> 00:20:45,679
huge workload

00:20:43,120 --> 00:20:47,360
you know uh that needs to span multiple

00:20:45,679 --> 00:20:48,880
regions and hor you know have

00:20:47,360 --> 00:20:50,320
high throughput and all these types of

00:20:48,880 --> 00:20:51,919
things but i only know sql so i should

00:20:50,320 --> 00:20:54,799
just go with that well no

00:20:51,919 --> 00:20:55,679
uh but it's something to consider also

00:20:54,799 --> 00:20:57,840
the ability to do

00:20:55,679 --> 00:20:58,960
joins and aggregations and analytics

00:20:57,840 --> 00:21:00,799
that's probably when you want to

00:20:58,960 --> 00:21:02,960
consider using a relational database

00:21:00,799 --> 00:21:04,880
we haven't talked anything about joins

00:21:02,960 --> 00:21:06,000
um if you're familiar with sql you're

00:21:04,880 --> 00:21:08,080
familiar with joins

00:21:06,000 --> 00:21:10,240
but it's basically the ability to take

00:21:08,080 --> 00:21:11,120
two tables and to enjoy them together

00:21:10,240 --> 00:21:13,120
and have

00:21:11,120 --> 00:21:15,039
all that information on a common key

00:21:13,120 --> 00:21:16,480
that exists between the two tables

00:21:15,039 --> 00:21:18,320
so it's actually one of my favorite

00:21:16,480 --> 00:21:22,000
database jokes

00:21:18,320 --> 00:21:25,280
and yes there are jokes about databases

00:21:22,000 --> 00:21:27,760
so a sql query walks into a bar

00:21:25,280 --> 00:21:28,880
and the query walks over to two tables

00:21:27,760 --> 00:21:32,159
and he says

00:21:28,880 --> 00:21:34,640
may i join you so

00:21:32,159 --> 00:21:35,919
okay i'll just leave time for everyone

00:21:34,640 --> 00:21:36,240
to just be laughing their heads off

00:21:35,919 --> 00:21:39,120
right

00:21:36,240 --> 00:21:40,720
so funny but all jokes aside joins are

00:21:39,120 --> 00:21:43,360
actually very costly

00:21:40,720 --> 00:21:44,480
uh in resources and they do slow down

00:21:43,360 --> 00:21:47,919
performance

00:21:44,480 --> 00:21:48,559
so no sql databases uh they don't they

00:21:47,919 --> 00:21:50,400
don't provide

00:21:48,559 --> 00:21:52,159
joints for that very reason and we're

00:21:50,400 --> 00:21:53,760
going to talk about as we if we

00:21:52,159 --> 00:21:55,280
move into nosql databases we're going to

00:21:53,760 --> 00:21:58,320
talk about why that is

00:21:55,280 --> 00:21:59,919
um but

00:21:58,320 --> 00:22:01,840
uh and you're gonna have to do your data

00:21:59,919 --> 00:22:05,120
modeling uh to kind of

00:22:01,840 --> 00:22:08,159
work around that as well so they also

00:22:05,120 --> 00:22:10,240
um they don't provide aggregations or uh

00:22:08,159 --> 00:22:12,000
you can do analytics on nosql databases

00:22:10,240 --> 00:22:14,159
i don't wanna say that you can't but

00:22:12,000 --> 00:22:15,679
it's just not really the use case for it

00:22:14,159 --> 00:22:18,080
so generally also

00:22:15,679 --> 00:22:20,159
when you have smaller data so you don't

00:22:18,080 --> 00:22:22,320
have big data you just have smaller data

00:22:20,159 --> 00:22:23,919
relational is probably going to fit well

00:22:22,320 --> 00:22:27,440
if you need a lot of flexibility

00:22:23,919 --> 00:22:27,840
in your queries so you need to be able

00:22:27,440 --> 00:22:30,320
to do

00:22:27,840 --> 00:22:31,600
ad hoc queries you know your manager

00:22:30,320 --> 00:22:33,840
comes down and he says

00:22:31,600 --> 00:22:35,039
i need to know x y and z you know right

00:22:33,840 --> 00:22:37,600
now um

00:22:35,039 --> 00:22:39,200
then you probably want to lean towards a

00:22:37,600 --> 00:22:40,640
relational database where you can just

00:22:39,200 --> 00:22:42,320
you know fire off that query and wait

00:22:40,640 --> 00:22:44,000
for the results to come back

00:22:42,320 --> 00:22:46,159
as we talk about nosql you'll see how

00:22:44,000 --> 00:22:47,120
that's not impossible you can do that

00:22:46,159 --> 00:22:48,080
but it's just a little bit more

00:22:47,120 --> 00:22:51,440
difficult

00:22:48,080 --> 00:22:53,280
um if you need acid transactions

00:22:51,440 --> 00:22:55,280
so if you need that consistent data you

00:22:53,280 --> 00:22:56,960
can't have eventually consistent

00:22:55,280 --> 00:22:59,039
data then you want to stick with

00:22:56,960 --> 00:23:00,880
relational and also just

00:22:59,039 --> 00:23:02,880
as we've seen it's pretty simple there's

00:23:00,880 --> 00:23:04,400
a lot of simplicity there

00:23:02,880 --> 00:23:06,799
so you know you might want to lean

00:23:04,400 --> 00:23:09,679
towards that if that's what you need

00:23:06,799 --> 00:23:10,320
so when not to use our relational so if

00:23:09,679 --> 00:23:13,840
you have

00:23:10,320 --> 00:23:16,880
uh large amounts of data um

00:23:13,840 --> 00:23:19,039
if you have a need for high availability

00:23:16,880 --> 00:23:19,919
so with relational databases a lot of

00:23:19,039 --> 00:23:21,840
times

00:23:19,919 --> 00:23:23,919
you can have a single point of failure

00:23:21,840 --> 00:23:25,600
and need to have like a hot swap

00:23:23,919 --> 00:23:28,159
you'll have like a primary and a

00:23:25,600 --> 00:23:29,679
secondary and the primary is functioning

00:23:28,159 --> 00:23:36,400
and then if it goes down the secondary

00:23:29,679 --> 00:23:40,240
comes online

00:23:36,400 --> 00:23:41,840
uh the the secondary will come online um

00:23:40,240 --> 00:23:43,360
but that takes time so you're gonna have

00:23:41,840 --> 00:23:45,039
a tiny bit of downtime

00:23:43,360 --> 00:23:46,400
uh but you know when you have a tiny bit

00:23:45,039 --> 00:23:48,320
of downtime uh

00:23:46,400 --> 00:23:49,679
depending on you know your use case that

00:23:48,320 --> 00:23:51,520
could be very significant

00:23:49,679 --> 00:23:53,440
right so you want to if you need high

00:23:51,520 --> 00:23:54,640
availability you know your database

00:23:53,440 --> 00:23:57,039
never goes down

00:23:54,640 --> 00:23:58,480
uh then then relational you know it

00:23:57,039 --> 00:23:59,600
depends you can you can make it work

00:23:58,480 --> 00:24:01,039
like i don't want to i don't want to act

00:23:59,600 --> 00:24:02,159
like you can't and like there's probably

00:24:01,039 --> 00:24:03,120
some of you out there they're like i

00:24:02,159 --> 00:24:04,480
make this work

00:24:03,120 --> 00:24:06,400
i have high availability high

00:24:04,480 --> 00:24:08,320
availability with my relational database

00:24:06,400 --> 00:24:09,440
and that's true but just as a high level

00:24:08,320 --> 00:24:11,120
talking point

00:24:09,440 --> 00:24:12,559
uh the high availability generally comes

00:24:11,120 --> 00:24:15,039
with no sql

00:24:12,559 --> 00:24:17,120
so if you need a higher read performance

00:24:15,039 --> 00:24:19,600
so like we talked about with joins

00:24:17,120 --> 00:24:21,919
you know acid is great uh those acid

00:24:19,600 --> 00:24:25,200
transactions and joins and all that

00:24:21,919 --> 00:24:25,200
but it will slow you down

00:24:25,919 --> 00:24:29,919
so if you uh need flexibility in your

00:24:28,559 --> 00:24:32,000
schemas

00:24:29,919 --> 00:24:33,279
uh so relational as we saw you know when

00:24:32,000 --> 00:24:35,760
you create that table

00:24:33,279 --> 00:24:37,440
um and you create those those those

00:24:35,760 --> 00:24:38,880
columns uh there's generally not a lot

00:24:37,440 --> 00:24:42,320
of flexibility

00:24:38,880 --> 00:24:45,039
um so with nosql as we'll see you know

00:24:42,320 --> 00:24:46,240
you can actually add columns uh only for

00:24:45,039 --> 00:24:49,279
rows that

00:24:46,240 --> 00:24:50,720
uh that need it uh and so you're able to

00:24:49,279 --> 00:24:51,440
save on space that way whereas

00:24:50,720 --> 00:24:53,360
relational

00:24:51,440 --> 00:24:55,120
uh you're gonna have to you know provide

00:24:53,360 --> 00:24:56,720
a value for that if you have that or

00:24:55,120 --> 00:24:58,240
you're gonna have to put a null value

00:24:56,720 --> 00:24:59,760
which in other databases you don't have

00:24:58,240 --> 00:25:02,320
to also

00:24:59,760 --> 00:25:02,960
the ability to store different types of

00:25:02,320 --> 00:25:05,919
data

00:25:02,960 --> 00:25:08,640
and data formats you can do with nosql

00:25:05,919 --> 00:25:11,279
that you cannot do with relational

00:25:08,640 --> 00:25:12,480
so as you're kind of seeing as i take

00:25:11,279 --> 00:25:15,120
you through this journey

00:25:12,480 --> 00:25:17,120
you're kind of seeing how one set of

00:25:15,120 --> 00:25:19,360
technologies worked for a period of time

00:25:17,120 --> 00:25:21,840
and then as things started to change

00:25:19,360 --> 00:25:24,240
you know now we're moving into uh the

00:25:21,840 --> 00:25:26,640
issues that there were with relational

00:25:24,240 --> 00:25:29,440
they're basically solved in some way

00:25:26,640 --> 00:25:31,279
with some trade-offs with no sql

00:25:29,440 --> 00:25:32,559
but you know again don't forget the

00:25:31,279 --> 00:25:36,320
reasons why you would need

00:25:32,559 --> 00:25:39,600
relational or nosql is is weaker right

00:25:36,320 --> 00:25:40,799
so uh like i said nosql was a reaction

00:25:39,600 --> 00:25:43,440
to the limitations

00:25:40,799 --> 00:25:46,159
of relational databases so what you get

00:25:43,440 --> 00:25:48,880
with nosql is that a high scalability

00:25:46,159 --> 00:25:50,880
you can easily add nodes uh horizontally

00:25:48,880 --> 00:25:52,880
you don't have to be trying to add you

00:25:50,880 --> 00:25:54,240
know memory and cpu vertically

00:25:52,880 --> 00:25:56,880
right you just add another machine

00:25:54,240 --> 00:26:00,159
bootstrap it in and you're good to go

00:25:56,880 --> 00:26:02,559
you're going to have high availability

00:26:00,159 --> 00:26:03,600
it's made for big data has fast

00:26:02,559 --> 00:26:05,919
performance

00:26:03,600 --> 00:26:10,480
and generally there's a very easy

00:26:05,919 --> 00:26:13,360
automatic data replication

00:26:10,480 --> 00:26:15,279
so also with nosql your data is not

00:26:13,360 --> 00:26:17,039
necessarily in tables

00:26:15,279 --> 00:26:18,159
and you're going to see that when we

00:26:17,039 --> 00:26:19,360
talk about the difference between like

00:26:18,159 --> 00:26:21,440
cassandra

00:26:19,360 --> 00:26:23,760
and foundation db so they don't

00:26:21,440 --> 00:26:27,840
necessarily reside in tables

00:26:23,760 --> 00:26:29,520
no sql it can mean no sql not only sql

00:26:27,840 --> 00:26:31,360
or non-relational all those terms are

00:26:29,520 --> 00:26:34,559
kind of interchangeable so you may hear

00:26:31,360 --> 00:26:35,520
any one of those there's many different

00:26:34,559 --> 00:26:39,120
data types

00:26:35,520 --> 00:26:41,120
with different data strengths

00:26:39,120 --> 00:26:42,960
or different strengths i should say so

00:26:41,120 --> 00:26:43,760
like what we talked about before there's

00:26:42,960 --> 00:26:47,120
the columnar

00:26:43,760 --> 00:26:48,400
key value graph

00:26:47,120 --> 00:26:49,760
each one of those is going to have a

00:26:48,400 --> 00:26:52,880
particular strength for what you're

00:26:49,760 --> 00:26:54,960
trying to do so the different

00:26:52,880 --> 00:26:56,080
data structures and the data modeling

00:26:54,960 --> 00:26:57,440
that you're going to do you're going to

00:26:56,080 --> 00:26:58,880
do different data modeling we didn't

00:26:57,440 --> 00:27:00,559
talk much about data modeling when we're

00:26:58,880 --> 00:27:02,320
talking about relational

00:27:00,559 --> 00:27:04,159
but if you're familiar with relational

00:27:02,320 --> 00:27:07,279
you know that you have to follow

00:27:04,159 --> 00:27:08,640
um basically you know getting that data

00:27:07,279 --> 00:27:10,320
redundancy down

00:27:08,640 --> 00:27:11,760
and normally that's done by achieving

00:27:10,320 --> 00:27:14,720
third normal form

00:27:11,760 --> 00:27:15,279
with no sql um you actually don't want

00:27:14,720 --> 00:27:16,320
to do

00:27:15,279 --> 00:27:18,720
anything like that you want to have

00:27:16,320 --> 00:27:19,120
denormalized tables um and you're going

00:27:18,720 --> 00:27:22,320
to be

00:27:19,120 --> 00:27:24,399
fitting your data modeling

00:27:22,320 --> 00:27:25,760
to your application into your queries as

00:27:24,399 --> 00:27:27,200
opposed to

00:27:25,760 --> 00:27:28,480
getting it into third normal form and

00:27:27,200 --> 00:27:31,120
when you do that it's actually going to

00:27:28,480 --> 00:27:33,919
allow for faster operations

00:27:31,120 --> 00:27:35,200
also nosql a lot of them were you know

00:27:33,919 --> 00:27:37,679
they were built

00:27:35,200 --> 00:27:38,720
uh either for the cloud directly or with

00:27:37,679 --> 00:27:43,600
the cloud in mind

00:27:38,720 --> 00:27:43,600
so um many many of them are cloud native

00:27:44,640 --> 00:27:48,080
so yeah let's talk about a little bit

00:27:46,399 --> 00:27:49,440
about each one of these uh these

00:27:48,080 --> 00:27:53,360
different types

00:27:49,440 --> 00:27:55,440
so we have um the document

00:27:53,360 --> 00:27:58,480
type of database so a good example is

00:27:55,440 --> 00:27:59,760
mongodb is a document database

00:27:58,480 --> 00:28:01,840
and i'm going to show you actually just

00:27:59,760 --> 00:28:02,320
a query that you can uh here in the next

00:28:01,840 --> 00:28:03,679
slide

00:28:02,320 --> 00:28:06,080
uh showing you kind of the difference

00:28:03,679 --> 00:28:08,080
between these two or these three

00:28:06,080 --> 00:28:09,360
uh key value which we talked about for

00:28:08,080 --> 00:28:11,520
foundation db

00:28:09,360 --> 00:28:12,480
and then like i said before columnar

00:28:11,520 --> 00:28:14,080
family

00:28:12,480 --> 00:28:15,760
i put apache cassandra even though it's

00:28:14,080 --> 00:28:16,799
really a partition row store but this

00:28:15,760 --> 00:28:18,720
graphic kind of

00:28:16,799 --> 00:28:20,159
kind of outlines out for you kind of the

00:28:18,720 --> 00:28:22,720
difference between each

00:28:20,159 --> 00:28:22,720
each one

00:28:24,000 --> 00:28:27,919
okay so let's just take a look at

00:28:26,559 --> 00:28:31,120
because i mentioned that

00:28:27,919 --> 00:28:32,480
these different nosql databases they

00:28:31,120 --> 00:28:35,600
don't use sql

00:28:32,480 --> 00:28:37,760
no sql right so they have generally they

00:28:35,600 --> 00:28:40,799
have their own unique query language

00:28:37,760 --> 00:28:43,440
per the different type of database so

00:28:40,799 --> 00:28:44,799
um they also have an n sql and

00:28:43,440 --> 00:28:46,799
relational databases have this as well

00:28:44,799 --> 00:28:48,640
but they also have a lot of drivers

00:28:46,799 --> 00:28:50,320
that you don't uh that'll wrap around

00:28:48,640 --> 00:28:52,799
and you don't have to necessarily use

00:28:50,320 --> 00:28:54,159
the query language you can use a driver

00:28:52,799 --> 00:28:56,240
uh to then interact with your

00:28:54,159 --> 00:28:57,840
application you know in python or c plus

00:28:56,240 --> 00:29:00,000
plus et

00:28:57,840 --> 00:29:01,840
so if we just look at this query select

00:29:00,000 --> 00:29:04,000
star from my cool table

00:29:01,840 --> 00:29:04,960
right so that's just gonna you know uh

00:29:04,000 --> 00:29:07,120
it's gonna give me

00:29:04,960 --> 00:29:08,640
all this information for my cool table

00:29:07,120 --> 00:29:10,559
so in mongodb

00:29:08,640 --> 00:29:12,480
uh you see that the the syntax is quite

00:29:10,559 --> 00:29:16,480
a bit different from that

00:29:12,480 --> 00:29:18,159
so it's db dot my cool table so my cool

00:29:16,480 --> 00:29:20,960
my cool table that lives in a database

00:29:18,159 --> 00:29:22,480
named db i'm going to do a find

00:29:20,960 --> 00:29:23,760
and then in this particular case because

00:29:22,480 --> 00:29:24,720
i'm doing a select star which means

00:29:23,760 --> 00:29:26,240
select everything

00:29:24,720 --> 00:29:28,559
that's what this this syntax here is

00:29:26,240 --> 00:29:30,640
saying is select everything

00:29:28,559 --> 00:29:31,679
now if i move over to apache cassandra

00:29:30,640 --> 00:29:34,399
which uses the

00:29:31,679 --> 00:29:35,760
uh it's called cql which is cassandra

00:29:34,399 --> 00:29:38,159
query language

00:29:35,760 --> 00:29:39,200
so i can do that select star from my

00:29:38,159 --> 00:29:41,600
cool table

00:29:39,200 --> 00:29:43,279
but i have to have a where clause so in

00:29:41,600 --> 00:29:45,760
cassandra

00:29:43,279 --> 00:29:47,919
the way the data is partitioned across

00:29:45,760 --> 00:29:50,640
the cluster and across

00:29:47,919 --> 00:29:52,799
the various nodes you actually have to

00:29:50,640 --> 00:29:54,159
help it in pinpointing where your data

00:29:52,799 --> 00:29:56,320
resides by a particular

00:29:54,159 --> 00:29:58,399
value so in this particular case i'm

00:29:56,320 --> 00:30:00,720
just pretending that my data

00:29:58,399 --> 00:30:03,039
with cassandra is partitioned by state

00:30:00,720 --> 00:30:04,640
just because this is just an example

00:30:03,039 --> 00:30:07,039
um and then i'm going to have to use

00:30:04,640 --> 00:30:09,600
that partition value or partition key

00:30:07,039 --> 00:30:12,080
to grab you know my information so i

00:30:09,600 --> 00:30:14,399
can't just do with a with a cluster like

00:30:12,080 --> 00:30:16,640
um or the database like apache cassandra

00:30:14,399 --> 00:30:18,640
you can't just do a select star from

00:30:16,640 --> 00:30:20,320
and just get all your data and the

00:30:18,640 --> 00:30:21,360
difference is when we talked about

00:30:20,320 --> 00:30:23,360
earlier about

00:30:21,360 --> 00:30:24,960
why relational databases are good for

00:30:23,360 --> 00:30:26,480
small data because

00:30:24,960 --> 00:30:28,080
likely you just have a small amount of

00:30:26,480 --> 00:30:29,279
data you can do the select star and you

00:30:28,080 --> 00:30:30,480
can get back all your data in a

00:30:29,279 --> 00:30:32,000
particular table it's not really

00:30:30,480 --> 00:30:35,200
anything to worry about

00:30:32,000 --> 00:30:38,080
with when you're doing nosql

00:30:35,200 --> 00:30:38,480
we have these very large uh potentially

00:30:38,080 --> 00:30:40,799
you know

00:30:38,480 --> 00:30:41,679
thousands and thousands of nodes uh

00:30:40,799 --> 00:30:43,440
clusters

00:30:41,679 --> 00:30:45,039
and your table is spanning all those

00:30:43,440 --> 00:30:46,960
thousands of nodes

00:30:45,039 --> 00:30:48,399
and all that information you could just

00:30:46,960 --> 00:30:49,600
you know you're going to be just flooded

00:30:48,399 --> 00:30:50,080
with information back to your

00:30:49,600 --> 00:30:51,840
application

00:30:50,080 --> 00:30:54,640
back to your driver and so because of

00:30:51,840 --> 00:30:55,919
that cassandra and other nosql databases

00:30:54,640 --> 00:30:58,559
don't allow for that so you're just

00:30:55,919 --> 00:31:00,399
going to have to take a subset of that

00:30:58,559 --> 00:31:02,559
and then so let's just talk about a

00:31:00,399 --> 00:31:05,760
second about foundation db

00:31:02,559 --> 00:31:07,840
so now with foundation db um

00:31:05,760 --> 00:31:08,960
they actually don't really have a query

00:31:07,840 --> 00:31:10,320
language they only

00:31:08,960 --> 00:31:12,399
they do have and we'll talk about

00:31:10,320 --> 00:31:14,000
foundation db here in a minute uh they

00:31:12,399 --> 00:31:15,679
have a core and then they have layers on

00:31:14,000 --> 00:31:17,440
top of that where they add functionality

00:31:15,679 --> 00:31:20,320
and they do have a sequel

00:31:17,440 --> 00:31:21,440
uh layer um but i don't think it's

00:31:20,320 --> 00:31:23,360
highly used

00:31:21,440 --> 00:31:25,760
um from what from my research that i was

00:31:23,360 --> 00:31:26,399
doing i just only just recently started

00:31:25,760 --> 00:31:29,120
working with

00:31:26,399 --> 00:31:29,440
foundation db uh it's it's pretty cool

00:31:29,120 --> 00:31:32,000
but

00:31:29,440 --> 00:31:32,720
um yeah so it was a it doesn't have that

00:31:32,000 --> 00:31:34,399
same

00:31:32,720 --> 00:31:36,000
uh query language that i'm kind of used

00:31:34,399 --> 00:31:38,000
to it uses this api

00:31:36,000 --> 00:31:39,279
so as you can see here you basically

00:31:38,000 --> 00:31:41,360
have to you know

00:31:39,279 --> 00:31:43,039
instigate a transaction and then from

00:31:41,360 --> 00:31:46,240
there from that transaction

00:31:43,039 --> 00:31:47,679
you take your table and then you're

00:31:46,240 --> 00:31:49,279
going to unpack it

00:31:47,679 --> 00:31:50,720
so again you're doing that select star

00:31:49,279 --> 00:31:52,799
you're going to iterate over

00:31:50,720 --> 00:31:54,080
everything in that table and you're

00:31:52,799 --> 00:31:56,240
going to get each and remember it's a

00:31:54,080 --> 00:31:58,080
key value store so you're going to get

00:31:56,240 --> 00:32:00,399
if i want everything which is what i

00:31:58,080 --> 00:32:03,760
want a select star i have to

00:32:00,399 --> 00:32:07,120
unpack so iterate out over all the rows

00:32:03,760 --> 00:32:08,799
and then give me that key and that value

00:32:07,120 --> 00:32:10,960
so it's very interesting to see each one

00:32:08,799 --> 00:32:11,919
of these these are just three examples

00:32:10,960 --> 00:32:13,760
that i'm showing you

00:32:11,919 --> 00:32:15,519
and there's far more no sql databases

00:32:13,760 --> 00:32:16,799
than that and they all each have a

00:32:15,519 --> 00:32:18,399
different language so

00:32:16,799 --> 00:32:20,559
remember when we were talking about with

00:32:18,399 --> 00:32:22,640
relational databases the the nicety of

00:32:20,559 --> 00:32:24,880
having sql and having simplicity

00:32:22,640 --> 00:32:25,760
well with no sql not that these aren't

00:32:24,880 --> 00:32:28,000
uh

00:32:25,760 --> 00:32:30,000
well they're not simplistic they are a

00:32:28,000 --> 00:32:32,080
little bit more complicated but

00:32:30,000 --> 00:32:33,279
once you learn them and you get to love

00:32:32,080 --> 00:32:35,440
them then it's

00:32:33,279 --> 00:32:37,679
it's very straightforward so let's just

00:32:35,440 --> 00:32:40,320
talk a minute about apache cassandra

00:32:37,679 --> 00:32:41,600
so it was actually donated to the apache

00:32:40,320 --> 00:32:43,679
foundation

00:32:41,600 --> 00:32:44,720
roughly 10 years ago so it's 10 years

00:32:43,679 --> 00:32:46,320
old

00:32:44,720 --> 00:32:48,799
it's supported by many different

00:32:46,320 --> 00:32:51,760
companies

00:32:48,799 --> 00:32:53,120
not just just one single single company

00:32:51,760 --> 00:32:55,200
behind it many different companies

00:32:53,120 --> 00:32:57,679
contribute to it use it

00:32:55,200 --> 00:32:58,720
many many customers it has a leaderless

00:32:57,679 --> 00:33:00,399
architecture

00:32:58,720 --> 00:33:02,640
so it has that remember we're talking

00:33:00,399 --> 00:33:05,039
about with nosql that high availability

00:33:02,640 --> 00:33:06,720
the ease to scale the fast reads and

00:33:05,039 --> 00:33:09,279
writes it does use eq

00:33:06,720 --> 00:33:12,000
ql which we talked about and essentially

00:33:09,279 --> 00:33:14,559
uh all the big apps that you

00:33:12,000 --> 00:33:15,919
have on your phone's home screen right

00:33:14,559 --> 00:33:18,960
think about on your phone you have

00:33:15,919 --> 00:33:22,960
netflix you have twitter

00:33:18,960 --> 00:33:24,559
you have um uber or lyft

00:33:22,960 --> 00:33:26,000
not so much right now in the times that

00:33:24,559 --> 00:33:27,679
we live in but you definitely have

00:33:26,000 --> 00:33:30,720
netflix and twitter

00:33:27,679 --> 00:33:31,519
and all of those use apache cassandra

00:33:30,720 --> 00:33:34,880
underlying

00:33:31,519 --> 00:33:34,880
to serve those applications

00:33:35,039 --> 00:33:38,240
so let's take a second to talk about

00:33:36,720 --> 00:33:40,320
foundation db

00:33:38,240 --> 00:33:41,760
again like i said it's a key value

00:33:40,320 --> 00:33:43,679
database it was actually

00:33:41,760 --> 00:33:45,679
open sourced by apple after an

00:33:43,679 --> 00:33:48,240
acquisition so it was originally

00:33:45,679 --> 00:33:49,600
uh a part of an acquisition called found

00:33:48,240 --> 00:33:50,720
i believe the company was called

00:33:49,600 --> 00:33:52,320
foundation db

00:33:50,720 --> 00:33:54,720
don't quote me on that but it was called

00:33:52,320 --> 00:33:55,519
foundation db they developed this open

00:33:54,720 --> 00:33:58,159
source

00:33:55,519 --> 00:33:59,200
um database and once they were purchased

00:33:58,159 --> 00:34:02,559
by apple

00:33:59,200 --> 00:34:04,159
um apple then continued to uh open

00:34:02,559 --> 00:34:05,200
source it as well so it's open source

00:34:04,159 --> 00:34:06,640
today

00:34:05,200 --> 00:34:08,720
like i said it doesn't have a query

00:34:06,640 --> 00:34:10,879
language it uses that api

00:34:08,720 --> 00:34:11,839
instead and like i was talking about

00:34:10,879 --> 00:34:13,359
with the simplicity

00:34:11,839 --> 00:34:14,960
it's a little it's a little hard to get

00:34:13,359 --> 00:34:16,639
your head wrapped around it first it's a

00:34:14,960 --> 00:34:18,240
tiny bit difficult at first

00:34:16,639 --> 00:34:19,760
but once you get the hang of hang of it

00:34:18,240 --> 00:34:21,200
it's very powerful

00:34:19,760 --> 00:34:23,040
and like i said it has a layered

00:34:21,200 --> 00:34:25,599
architecture so it has its core

00:34:23,040 --> 00:34:27,599
functionality in what they call the core

00:34:25,599 --> 00:34:28,399
and then it layers functionality on top

00:34:27,599 --> 00:34:31,440
of that like

00:34:28,399 --> 00:34:33,440
for example there's a mongodb connector

00:34:31,440 --> 00:34:34,639
um that is one of the layers and then

00:34:33,440 --> 00:34:37,679
another layer

00:34:34,639 --> 00:34:40,240
is a sql connector etc and what's

00:34:37,679 --> 00:34:43,119
actually unique about foundation db

00:34:40,240 --> 00:34:45,040
is that it supports acid transactions so

00:34:43,119 --> 00:34:47,679
that's actually something to consider

00:34:45,040 --> 00:34:48,240
if the only reason stopping you from

00:34:47,679 --> 00:34:49,839
using

00:34:48,240 --> 00:34:51,280
a nosql database and getting all the

00:34:49,839 --> 00:34:53,280
benefits of that

00:34:51,280 --> 00:34:54,399
is for asset transactions maybe

00:34:53,280 --> 00:34:57,520
something you want to consider is

00:34:54,399 --> 00:35:02,400
is is looking you know more in-depth at

00:34:57,520 --> 00:35:03,920
 or not maybe foundation tv so

00:35:02,400 --> 00:35:06,240
um i think we've kind of already kind of

00:35:03,920 --> 00:35:09,359
talked about this quite a bit

00:35:06,240 --> 00:35:10,320
excuse me but when do you use a nosql

00:35:09,359 --> 00:35:12,240
database

00:35:10,320 --> 00:35:13,920
so just kind of going over these high

00:35:12,240 --> 00:35:15,520
level points again if you need that high

00:35:13,920 --> 00:35:17,280
availability

00:35:15,520 --> 00:35:19,200
um i wish i could spend more time and

00:35:17,280 --> 00:35:20,880
time to talk about the architectures

00:35:19,200 --> 00:35:22,400
of how you get high availability with

00:35:20,880 --> 00:35:24,560
nosql databases because

00:35:22,400 --> 00:35:25,520
for me that was really the key because

00:35:24,560 --> 00:35:27,200
when you hear

00:35:25,520 --> 00:35:28,960
a lot of these high-level concepts

00:35:27,200 --> 00:35:30,240
sometimes it

00:35:28,960 --> 00:35:32,240
can tend to sometimes sound like

00:35:30,240 --> 00:35:34,160
marketing speak uh but

00:35:32,240 --> 00:35:36,320
what's cool about nosql is like once you

00:35:34,160 --> 00:35:38,240
dive into that architecture you see why

00:35:36,320 --> 00:35:39,760
a lot of these things are true and and

00:35:38,240 --> 00:35:41,520
it makes a lot of sense so

00:35:39,760 --> 00:35:42,800
maybe that's my next talk because some

00:35:41,520 --> 00:35:46,000
more architecture i know

00:35:42,800 --> 00:35:47,040
nosql databases but if you have really

00:35:46,000 --> 00:35:49,440
big data

00:35:47,040 --> 00:35:50,880
if you need linear scalability if you

00:35:49,440 --> 00:35:53,359
have uh you need a

00:35:50,880 --> 00:35:54,640
low latency and you need fast reads and

00:35:53,359 --> 00:35:56,240
writes

00:35:54,640 --> 00:35:58,320
and you need flexibility with your

00:35:56,240 --> 00:36:00,560
schema now some of those

00:35:58,320 --> 00:36:01,440
um like like for example apache

00:36:00,560 --> 00:36:04,240
cassandra

00:36:01,440 --> 00:36:05,040
it has uh some flexibility with this

00:36:04,240 --> 00:36:07,119
schema

00:36:05,040 --> 00:36:08,240
but it's not as flexible as as other

00:36:07,119 --> 00:36:09,920
databases so

00:36:08,240 --> 00:36:11,839
it really depends which nosql database

00:36:09,920 --> 00:36:13,119
you're using and how much flexibility

00:36:11,839 --> 00:36:14,960
you need in your schema

00:36:13,119 --> 00:36:16,800
it's like for cassandra it's more

00:36:14,960 --> 00:36:18,960
flexible than relational but less than

00:36:16,800 --> 00:36:20,720
some of these others

00:36:18,960 --> 00:36:22,720
also if you have distributed users

00:36:20,720 --> 00:36:24,480
because you're able to

00:36:22,720 --> 00:36:26,720
scale out horizontally and also have

00:36:24,480 --> 00:36:28,880
ease of replication across

00:36:26,720 --> 00:36:30,880
all those different nodes so you know

00:36:28,880 --> 00:36:32,480
you can have users coming in from

00:36:30,880 --> 00:36:34,640
a variety of places and getting that low

00:36:32,480 --> 00:36:36,560
latency instead of just one box

00:36:34,640 --> 00:36:38,240
you know somewhere here in california

00:36:36,560 --> 00:36:40,800
right

00:36:38,240 --> 00:36:41,599
and um if you know your queries in

00:36:40,800 --> 00:36:43,520
advance

00:36:41,599 --> 00:36:44,800
for your applications because i kind of

00:36:43,520 --> 00:36:46,160
mentioned that briefly when i was

00:36:44,800 --> 00:36:49,280
talking about data modeling

00:36:46,160 --> 00:36:50,480
for nosql you have to know your queries

00:36:49,280 --> 00:36:52,160
in advance to use

00:36:50,480 --> 00:36:53,520
a nosql database you can't really do

00:36:52,160 --> 00:36:56,720
those ad hoc queries

00:36:53,520 --> 00:36:57,680
so if you have those and you know what

00:36:56,720 --> 00:36:58,960
you're going to need to do for your

00:36:57,680 --> 00:37:00,720
application

00:36:58,960 --> 00:37:02,160
then you're in really good shape if you

00:37:00,720 --> 00:37:03,520
you're not going to know those you you

00:37:02,160 --> 00:37:05,359
know they're going to be ad hoc

00:37:03,520 --> 00:37:06,880
that's where this nosql it really you

00:37:05,359 --> 00:37:10,240
know it gets difficult to use

00:37:06,880 --> 00:37:11,680
in that way now also just a quick word

00:37:10,240 --> 00:37:13,760
on that as well

00:37:11,680 --> 00:37:15,200
it sounds almost impossible when i say

00:37:13,760 --> 00:37:16,320
know your queries in advance like how am

00:37:15,200 --> 00:37:17,520
i going to know all my queries from my

00:37:16,320 --> 00:37:19,440
application in advance

00:37:17,520 --> 00:37:21,520
but actually when you sit down with your

00:37:19,440 --> 00:37:22,960
team and you really start detailing

00:37:21,520 --> 00:37:24,160
it out you know just on the whiteboard

00:37:22,960 --> 00:37:25,520
just you know having an offsite and

00:37:24,160 --> 00:37:26,960
talking about it

00:37:25,520 --> 00:37:28,880
it actually comes into focus much

00:37:26,960 --> 00:37:30,880
quicker than you would think of the

00:37:28,880 --> 00:37:34,400
queries that you actually need

00:37:30,880 --> 00:37:35,440
so it's something to explore uh so when

00:37:34,400 --> 00:37:38,480
not to use

00:37:35,440 --> 00:37:39,839
so if you need to use uh sql now there's

00:37:38,480 --> 00:37:42,240
ways around this like i kind of

00:37:39,839 --> 00:37:43,839
touched on before um if you do need

00:37:42,240 --> 00:37:44,560
those acid transactions and for some

00:37:43,839 --> 00:37:45,920
reason you don't

00:37:44,560 --> 00:37:47,839
you know foundation db isn't going to

00:37:45,920 --> 00:37:49,040
fit your needs you know then no sql may

00:37:47,839 --> 00:37:50,720
not be right for you

00:37:49,040 --> 00:37:52,079
you need the ability to do joins on

00:37:50,720 --> 00:37:54,320
those tables

00:37:52,079 --> 00:37:55,520
you just need that more flexibility you

00:37:54,320 --> 00:37:58,079
have to do you know you need

00:37:55,520 --> 00:37:59,119
ad hoc queries and if you have small

00:37:58,079 --> 00:38:02,480
data

00:37:59,119 --> 00:38:04,400
so i've advised um multiple folks and

00:38:02,480 --> 00:38:06,720
customers i've worked with in the past

00:38:04,400 --> 00:38:08,320
you know if you have small data you

00:38:06,720 --> 00:38:11,680
don't really need the headache

00:38:08,320 --> 00:38:13,040
of uh you know using a database that's

00:38:11,680 --> 00:38:14,720
really built for big data

00:38:13,040 --> 00:38:16,800
you could just go for something very

00:38:14,720 --> 00:38:17,599
simple like using you know postgres or

00:38:16,800 --> 00:38:18,880
mysql

00:38:17,599 --> 00:38:22,560
you don't really have to deal with all

00:38:18,880 --> 00:38:22,560
this added complexity

00:38:22,960 --> 00:38:26,480
um oh so just a quick word of warning

00:38:25,520 --> 00:38:28,000
around uh

00:38:26,480 --> 00:38:29,119
a no sequel because like i'm saying you

00:38:28,000 --> 00:38:31,040
know it's kind of a journey from

00:38:29,119 --> 00:38:33,680
relational to nosql

00:38:31,040 --> 00:38:34,960
so be aware when moving from rdbms to

00:38:33,680 --> 00:38:37,119
nosql

00:38:34,960 --> 00:38:38,160
um because like we were talking about

00:38:37,119 --> 00:38:39,760
with data modeling

00:38:38,160 --> 00:38:41,599
you can't just you can't just move over

00:38:39,760 --> 00:38:43,839
your data model in your tables

00:38:41,599 --> 00:38:45,200
just as is it seems like you can because

00:38:43,839 --> 00:38:46,480
you can just do a create

00:38:45,200 --> 00:38:48,160
you know create table and create the

00:38:46,480 --> 00:38:49,599
exact same table and it seems like okay

00:38:48,160 --> 00:38:51,520
i migrated all my data

00:38:49,599 --> 00:38:52,880
everything's great it's more about the

00:38:51,520 --> 00:38:55,359
query so you're going to have to do

00:38:52,880 --> 00:38:56,560
different different queries on that data

00:38:55,359 --> 00:38:57,760
and what's going to be supported like

00:38:56,560 --> 00:39:00,400
for example when i was talking about

00:38:57,760 --> 00:39:01,680
patchy cassandra with that where cloth

00:39:00,400 --> 00:39:03,520
so there is a little bit more of a

00:39:01,680 --> 00:39:04,880
learning curve

00:39:03,520 --> 00:39:07,280
you have to think about your queries and

00:39:04,880 --> 00:39:09,200
your application first

00:39:07,280 --> 00:39:12,400
so it's not anything to scare anyone off

00:39:09,200 --> 00:39:12,400
but it's just something to consider

00:39:13,040 --> 00:39:17,760
so then lastly i just want to touch here

00:39:15,119 --> 00:39:20,560
on graph databases

00:39:17,760 --> 00:39:22,079
so here is this a really nice definition

00:39:20,560 --> 00:39:25,520
from wikipedia

00:39:22,079 --> 00:39:27,599
so uses uh graph structures for semantic

00:39:25,520 --> 00:39:30,400
queries with nodes and edges

00:39:27,599 --> 00:39:31,599
and properties to re represent and store

00:39:30,400 --> 00:39:33,680
data

00:39:31,599 --> 00:39:34,640
so with a graph database and you can see

00:39:33,680 --> 00:39:37,359
here so uh

00:39:34,640 --> 00:39:37,760
in the graphic you see the node and then

00:39:37,359 --> 00:39:39,440
uh

00:39:37,760 --> 00:39:41,440
it has data within it like in this case

00:39:39,440 --> 00:39:42,960
the name is peter

00:39:41,440 --> 00:39:44,640
and then from there we have edges that

00:39:42,960 --> 00:39:47,839
go out from that

00:39:44,640 --> 00:39:49,599
piece uh that node right so in this

00:39:47,839 --> 00:39:52,240
particular case we can already see

00:39:49,599 --> 00:39:53,040
that the attribute on the edge is

00:39:52,240 --> 00:39:54,880
follows

00:39:53,040 --> 00:39:56,800
so obviously this is a graph database

00:39:54,880 --> 00:39:59,920
around who your followers are

00:39:56,800 --> 00:40:02,480
on social media right so

00:39:59,920 --> 00:40:04,400
with a graph database it's really all

00:40:02,480 --> 00:40:09,599
around relationships

00:40:04,400 --> 00:40:12,319
within between the the data points right

00:40:09,599 --> 00:40:15,119
so exactly what i said yeah so the key

00:40:12,319 --> 00:40:17,920
is it's a relationship between the data

00:40:15,119 --> 00:40:18,880
uh dependencies between the data is very

00:40:17,920 --> 00:40:21,359
clear

00:40:18,880 --> 00:40:23,440
so like for example like you know the

00:40:21,359 --> 00:40:24,319
attributes between those that hook the

00:40:23,440 --> 00:40:27,680
data together

00:40:24,319 --> 00:40:28,400
right it's not always that clear in a

00:40:27,680 --> 00:40:30,400
relational

00:40:28,400 --> 00:40:32,560
or nosql database the dependencies

00:40:30,400 --> 00:40:35,839
between the data

00:40:32,560 --> 00:40:37,200
so when you have when you are trying to

00:40:35,839 --> 00:40:40,319
do queries to get

00:40:37,200 --> 00:40:42,720
relationships between

00:40:40,319 --> 00:40:44,160
the data in relational or nosql those

00:40:42,720 --> 00:40:46,000
queries can actually end up being

00:40:44,160 --> 00:40:47,680
extremely complicated because you're

00:40:46,000 --> 00:40:48,400
having to do extremely complicated

00:40:47,680 --> 00:40:50,560
things

00:40:48,400 --> 00:40:52,400
because your data is not represented as

00:40:50,560 --> 00:40:55,520
a relationship graph

00:40:52,400 --> 00:40:58,079
like it is with a graph database so

00:40:55,520 --> 00:40:59,680
in a graph database there's really fast

00:40:58,079 --> 00:41:01,119
ways to query especially when you're

00:40:59,680 --> 00:41:02,640
trying to look about those relationships

00:41:01,119 --> 00:41:05,359
between the data

00:41:02,640 --> 00:41:06,000
and to retrieve that data so going on a

00:41:05,359 --> 00:41:09,440
traversal

00:41:06,000 --> 00:41:12,400
or or walking the graph as they say um

00:41:09,440 --> 00:41:12,960
and uh graph databases i i don't know if

00:41:12,400 --> 00:41:15,280
i would say

00:41:12,960 --> 00:41:16,000
all of them use gremlin they probably

00:41:15,280 --> 00:41:19,119
don't

00:41:16,000 --> 00:41:22,000
um but gremlin is

00:41:19,119 --> 00:41:22,319
a a very common query language out there

00:41:22,000 --> 00:41:24,400
for

00:41:22,319 --> 00:41:27,119
traversing graphs and that's the graph

00:41:24,400 --> 00:41:27,119
query language

00:41:28,480 --> 00:41:32,400
so here's an example of gremlin here and

00:41:31,440 --> 00:41:34,160
you'll see

00:41:32,400 --> 00:41:35,520
straight away the difference so if i

00:41:34,160 --> 00:41:37,359
have a sql query like

00:41:35,520 --> 00:41:38,720
select star from my cool table where

00:41:37,359 --> 00:41:41,200
conference equals

00:41:38,720 --> 00:41:42,160
open source summit and then gremlin

00:41:41,200 --> 00:41:42,640
you're going to see it's a little bit

00:41:42,160 --> 00:41:45,520
different

00:41:42,640 --> 00:41:46,800
so instead i called it my cool graph but

00:41:45,520 --> 00:41:48,079
it could be my cool table it doesn't

00:41:46,800 --> 00:41:51,119
matter the name

00:41:48,079 --> 00:41:53,760
um then you want to uh

00:41:51,119 --> 00:41:54,880
you're basically going to traverse the

00:41:53,760 --> 00:41:56,800
vertices

00:41:54,880 --> 00:41:58,560
you're going to start a particular start

00:41:56,800 --> 00:42:00,240
node and then you're going to walk those

00:41:58,560 --> 00:42:04,319
vertices and you're looking for

00:42:00,240 --> 00:42:08,880
if it has the label open source summit

00:42:04,319 --> 00:42:10,880
so like i said before um

00:42:08,880 --> 00:42:13,440
very complex sql queries can easily

00:42:10,880 --> 00:42:14,160
reduce down to very simple gremlin

00:42:13,440 --> 00:42:17,839
queries

00:42:14,160 --> 00:42:17,839
because of the nature of the data

00:42:18,960 --> 00:42:24,079
so just a word here on apache tinker pop

00:42:22,240 --> 00:42:26,640
which is a great open source graph

00:42:24,079 --> 00:42:29,200
database it was started in 2009

00:42:26,640 --> 00:42:31,200
in los alamos national lab and it

00:42:29,200 --> 00:42:32,640
graduated to a top-level apache project

00:42:31,200 --> 00:42:34,480
in 2016.

00:42:32,640 --> 00:42:35,920
has a very active community as you can

00:42:34,480 --> 00:42:39,760
see here just as a little

00:42:35,920 --> 00:42:39,760
graphic i can i showed you from github

00:42:39,920 --> 00:42:43,040
and there's a lot of nice trainings as

00:42:42,640 --> 00:42:45,920
well

00:42:43,040 --> 00:42:48,400
and a lot of nice training using uh

00:42:45,920 --> 00:42:48,400
gremlin

00:42:49,520 --> 00:42:53,280
so when should you use a graph database

00:42:52,240 --> 00:42:54,720
like i said it's all around

00:42:53,280 --> 00:42:57,359
relationships so when trying to

00:42:54,720 --> 00:42:59,760
understand relationships

00:42:57,359 --> 00:43:02,240
graph database may be good for that when

00:42:59,760 --> 00:43:03,920
you need a better performance

00:43:02,240 --> 00:43:05,599
when you have very long you know very

00:43:03,920 --> 00:43:07,200
complex joins

00:43:05,599 --> 00:43:08,720
you can actually just walk the graph

00:43:07,200 --> 00:43:10,079
instead now

00:43:08,720 --> 00:43:12,079
it's not necessarily going to get you

00:43:10,079 --> 00:43:14,319
better performance for all

00:43:12,079 --> 00:43:15,680
queries but when it's relationship

00:43:14,319 --> 00:43:19,680
driven queries

00:43:15,680 --> 00:43:21,119
kind of node and edges type um

00:43:19,680 --> 00:43:22,800
queries then you're going to get better

00:43:21,119 --> 00:43:25,040
performance of the craft database

00:43:22,800 --> 00:43:27,119
so you know if you're thinking about you

00:43:25,040 --> 00:43:28,240
know do i need a graph database or can i

00:43:27,119 --> 00:43:30,160
just use something else

00:43:28,240 --> 00:43:31,520
you should really try the whiteboard

00:43:30,160 --> 00:43:32,720
test um

00:43:31,520 --> 00:43:33,920
get up on the whiteboard and start

00:43:32,720 --> 00:43:35,040
drawing out your data and the

00:43:33,920 --> 00:43:37,599
relationship between it

00:43:35,040 --> 00:43:40,079
if it starts to look like a graph then

00:43:37,599 --> 00:43:41,440
it might fit well in a graph database

00:43:40,079 --> 00:43:43,200
so this is a really great talk and

00:43:41,440 --> 00:43:44,560
article and i've linked it here

00:43:43,200 --> 00:43:46,079
actually it's kind of funny with our

00:43:44,560 --> 00:43:46,880
open source communities and all of our

00:43:46,079 --> 00:43:50,240
communities

00:43:46,880 --> 00:43:52,160
um i clicked on this and this uh this

00:43:50,240 --> 00:43:53,920
article and videos along with is

00:43:52,160 --> 00:43:54,400
actually a really good friend of mine

00:43:53,920 --> 00:43:56,079
who was

00:43:54,400 --> 00:43:57,520
uh i just happened to pop on it and

00:43:56,079 --> 00:43:59,200
let's go there's somebody that i know

00:43:57,520 --> 00:43:59,599
and someone it's nice someone you can

00:43:59,200 --> 00:44:02,720
trust

00:43:59,599 --> 00:44:04,000
right you know it's good information all

00:44:02,720 --> 00:44:05,359
right so when not to use the graph

00:44:04,000 --> 00:44:07,520
database

00:44:05,359 --> 00:44:09,520
so if you have disconnected data you

00:44:07,520 --> 00:44:11,599
know it's not relationship driven data

00:44:09,520 --> 00:44:12,800
then or the relationships even if they

00:44:11,599 --> 00:44:14,079
are there they're just not important to

00:44:12,800 --> 00:44:15,359
what you're doing you may not need a

00:44:14,079 --> 00:44:17,359
graph database

00:44:15,359 --> 00:44:18,960
if you have very right heavy workloads

00:44:17,359 --> 00:44:21,440
you're going to be writing a lot

00:44:18,960 --> 00:44:22,000
um then this is probably not right for

00:44:21,440 --> 00:44:24,640
you

00:44:22,000 --> 00:44:25,520
if you're using it as a key value store

00:44:24,640 --> 00:44:27,760
also really

00:44:25,520 --> 00:44:29,440
not not really what it is intended for

00:44:27,760 --> 00:44:31,680
go think about using a key value store

00:44:29,440 --> 00:44:34,240
database right

00:44:31,680 --> 00:44:35,520
if your data is not from a known point

00:44:34,240 --> 00:44:36,000
so right you need to kind of know where

00:44:35,520 --> 00:44:37,920
to start

00:44:36,000 --> 00:44:39,440
to start working your graph if you don't

00:44:37,920 --> 00:44:40,160
know what that is or you don't think you

00:44:39,440 --> 00:44:42,880
ever will

00:44:40,160 --> 00:44:44,160
it's probably not going to work um also

00:44:42,880 --> 00:44:45,440
there is a little bit of overhead in

00:44:44,160 --> 00:44:47,440
creating the graph

00:44:45,440 --> 00:44:49,760
adding the edges i don't say i would say

00:44:47,440 --> 00:44:50,800
that's necessarily when not to use

00:44:49,760 --> 00:44:52,480
but it's just something i thought i'd

00:44:50,800 --> 00:44:53,680
bring up because it is a little bit

00:44:52,480 --> 00:44:54,880
different than what we're used to with

00:44:53,680 --> 00:44:58,560
these other

00:44:54,880 --> 00:45:00,240
databases alrighty so just to kind of

00:44:58,560 --> 00:45:03,200
wrap up here

00:45:00,240 --> 00:45:05,119
so relational versus nosql versus graph

00:45:03,200 --> 00:45:09,040
it's really not either or

00:45:05,119 --> 00:45:11,760
um most organizations have

00:45:09,040 --> 00:45:12,640
all of these and honestly most

00:45:11,760 --> 00:45:14,720
organizations have

00:45:12,640 --> 00:45:16,319
multiples of each one of these so

00:45:14,720 --> 00:45:18,240
they'll have you know

00:45:16,319 --> 00:45:19,680
foundation db they also have cassandra

00:45:18,240 --> 00:45:21,040
they also have because they all fit

00:45:19,680 --> 00:45:23,119
particular use case and i didn't have

00:45:21,040 --> 00:45:25,839
enough time here in my talk to go over

00:45:23,119 --> 00:45:26,400
you know in depth each one of those um

00:45:25,839 --> 00:45:27,680
but

00:45:26,400 --> 00:45:28,960
you know they all serve a very

00:45:27,680 --> 00:45:30,319
particular purpose and most

00:45:28,960 --> 00:45:33,440
organizations have all want to

00:45:30,319 --> 00:45:35,359
have each one each have their own

00:45:33,440 --> 00:45:36,720
benefits and drawbacks

00:45:35,359 --> 00:45:38,480
so you really want to make sure you get

00:45:36,720 --> 00:45:39,680
informed before choosing

00:45:38,480 --> 00:45:41,839
so now we've just kind of talked about

00:45:39,680 --> 00:45:42,880
the high level between relational no sql

00:45:41,839 --> 00:45:45,599
and graph

00:45:42,880 --> 00:45:47,280
but you know really kind of diving into

00:45:45,599 --> 00:45:48,640
now once you know that the difference is

00:45:47,280 --> 00:45:50,800
between each one of those

00:45:48,640 --> 00:45:52,400
types within those they're all really

00:45:50,800 --> 00:45:53,520
easy to explore on your laptop

00:45:52,400 --> 00:45:54,720
so that's kind of the cool and the

00:45:53,520 --> 00:45:56,000
benefit of open source you can just

00:45:54,720 --> 00:45:59,119
download it and start like just

00:45:56,000 --> 00:46:01,280
exploring and um also

00:45:59,119 --> 00:46:02,960
just a i mean something to consider you

00:46:01,280 --> 00:46:04,480
might want to consider managed platforms

00:46:02,960 --> 00:46:06,240
that are based on open source

00:46:04,480 --> 00:46:07,839
um those are nice ways so that you don't

00:46:06,240 --> 00:46:10,079
have to do all the operations

00:46:07,839 --> 00:46:11,920
behind hosting necessarily uh these

00:46:10,079 --> 00:46:13,119
databases something to consider

00:46:11,920 --> 00:46:15,280
again you know make sure you do your

00:46:13,119 --> 00:46:16,720
research also always consider your use

00:46:15,280 --> 00:46:17,839
cases when you're choosing which one of

00:46:16,720 --> 00:46:19,280
these database

00:46:17,839 --> 00:46:20,720
reach out to other groups within your

00:46:19,280 --> 00:46:22,560
organization and reach out to the

00:46:20,720 --> 00:46:24,960
mailing lists and the boards

00:46:22,560 --> 00:46:26,319
um you know to get to get some

00:46:24,960 --> 00:46:28,319
information about that and you know say

00:46:26,319 --> 00:46:31,119
hey does my use case fit this database

00:46:28,319 --> 00:46:32,160
people love to be able to answer that so

00:46:31,119 --> 00:46:33,760
what do you do next

00:46:32,160 --> 00:46:35,680
so keep learning and make sure you get

00:46:33,760 --> 00:46:37,119
hands-on as well so i've just listed

00:46:35,680 --> 00:46:38,560
some resources here for you so you can

00:46:37,119 --> 00:46:39,599
just start diving in and getting more

00:46:38,560 --> 00:46:40,960
information

00:46:39,599 --> 00:46:42,480
so thank you all for your time i hope

00:46:40,960 --> 00:46:43,839
this was helpful and i really enjoyed

00:46:42,480 --> 00:46:45,200
pulling all this information together

00:46:43,839 --> 00:46:45,839
for you it was a lot of learning for me

00:46:45,200 --> 00:46:53,760
as well

00:46:45,839 --> 00:46:53,760

YouTube URL: https://www.youtube.com/watch?v=zIQ75H90UlE


