Title: A Disciplined Approach to Debugging - Lev Iserovich, D. E. Shaw Research
Publication date: 2020-09-10
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	A Disciplined Approach to Debugging - Lev Iserovich, D. E. Shaw Research
Captions: 
	00:00:03,120 --> 00:00:08,320
hello everybody

00:00:04,720 --> 00:00:11,440
um welcome to

00:00:08,320 --> 00:00:13,200
my talk my name is uh lavish ravich and

00:00:11,440 --> 00:00:16,000
i work at the show research and

00:00:13,200 --> 00:00:17,199
uh today we're gonna be talking about a

00:00:16,000 --> 00:00:20,320
disciplined approach

00:00:17,199 --> 00:00:23,519
to debugging so

00:00:20,320 --> 00:00:27,039
um first a quick word about

00:00:23,519 --> 00:00:30,960
uh myself and my company

00:00:27,039 --> 00:00:34,160
um so i work at d show research it's a

00:00:30,960 --> 00:00:34,640
independent research lab founded in 2002

00:00:34,160 --> 00:00:38,399
by

00:00:34,640 --> 00:00:41,120
david shaw he

00:00:38,399 --> 00:00:41,440
used to manage a hedge fund also called

00:00:41,120 --> 00:00:45,280
the

00:00:41,440 --> 00:00:48,320
shop but now she wants to advance

00:00:45,280 --> 00:00:49,200
science and specifically using molecular

00:00:48,320 --> 00:00:52,079
dynamics

00:00:49,200 --> 00:00:53,840
so the high level goal is to advance to

00:00:52,079 --> 00:00:55,360
make an impact in the fields of biology

00:00:53,840 --> 00:00:57,280
and chemistry

00:00:55,360 --> 00:00:59,520
using computer science and computer

00:00:57,280 --> 00:01:02,160
hardware specifically we built

00:00:59,520 --> 00:01:04,960
a supercomputer called danton for

00:01:02,160 --> 00:01:06,080
molecular dynamics simulation

00:01:04,960 --> 00:01:08,880
i'm not going to be talking about very

00:01:06,080 --> 00:01:11,920
much of that in this talk

00:01:08,880 --> 00:01:12,960
but what i do is systems software so

00:01:11,920 --> 00:01:15,280
basically

00:01:12,960 --> 00:01:16,000
kind of operating system level software

00:01:15,280 --> 00:01:19,119
for this

00:01:16,000 --> 00:01:21,759
supercomputer that we built and during

00:01:19,119 --> 00:01:24,159
the course of this there's definitely

00:01:21,759 --> 00:01:26,240
a lot of things break and you have to

00:01:24,159 --> 00:01:28,080
debug a lot of things

00:01:26,240 --> 00:01:30,000
i've generally had about 20 years of

00:01:28,080 --> 00:01:34,400
experience in the field

00:01:30,000 --> 00:01:37,280
working at places like hp and

00:01:34,400 --> 00:01:37,600
sienna networking company so i've worked

00:01:37,280 --> 00:01:38,960
for

00:01:37,600 --> 00:01:41,439
everything from like little embedded

00:01:38,960 --> 00:01:45,040
devices to obviously supercomputers

00:01:41,439 --> 00:01:47,280
and uh hopefully i could provide some

00:01:45,040 --> 00:01:49,200
good background on debugging techniques

00:01:47,280 --> 00:01:52,320
and tools specifically under linux and

00:01:49,200 --> 00:01:54,960
embedded linux more particularly

00:01:52,320 --> 00:01:56,159
so first of all why do we want to talk

00:01:54,960 --> 00:01:58,799
about debugging at all

00:01:56,159 --> 00:01:59,759
well about half if you're a programmer

00:01:58,799 --> 00:02:03,360
about half your time

00:01:59,759 --> 00:02:06,320
is spent doing administration tasks so

00:02:03,360 --> 00:02:08,080
things like you know filing bug reports

00:02:06,320 --> 00:02:10,800
talking to other people

00:02:08,080 --> 00:02:11,920
hr and you know all sorts of things that

00:02:10,800 --> 00:02:14,080
go along with

00:02:11,920 --> 00:02:16,000
working in an office or at home as the

00:02:14,080 --> 00:02:19,360
case may be now

00:02:16,000 --> 00:02:22,560
and uh uh

00:02:19,360 --> 00:02:23,120
half and half of the time that you

00:02:22,560 --> 00:02:25,360
actually

00:02:23,120 --> 00:02:26,800
spend programming half that time is

00:02:25,360 --> 00:02:28,800
actually spent debugging

00:02:26,800 --> 00:02:30,879
the so these statistics you should

00:02:28,800 --> 00:02:33,599
probably take with a grain of salt but

00:02:30,879 --> 00:02:35,200
um there's about 100 1.5 million

00:02:33,599 --> 00:02:38,000
software developers in the us

00:02:35,200 --> 00:02:39,599
and the total wages estimated by the us

00:02:38,000 --> 00:02:41,440
department of labor statistics is about

00:02:39,599 --> 00:02:43,920
150 billion so

00:02:41,440 --> 00:02:46,000
about 37 billion at least to spend

00:02:43,920 --> 00:02:48,560
debugging in the us

00:02:46,000 --> 00:02:49,280
and yet there's not that many resources

00:02:48,560 --> 00:02:51,680
really

00:02:49,280 --> 00:02:53,360
formally to teach debugging if you look

00:02:51,680 --> 00:02:55,120
at the mit course catalog

00:02:53,360 --> 00:02:59,200
the word debugging only appears three

00:02:55,120 --> 00:02:59,200
times out of ten thousand words

00:03:00,480 --> 00:03:05,120
i'm seeing some questions that people

00:03:03,680 --> 00:03:08,480
can't hear me is

00:03:05,120 --> 00:03:12,720
can is everybody can uh

00:03:08,480 --> 00:03:15,120
people uh speak up if or

00:03:12,720 --> 00:03:16,840
type in a question if anybody else can't

00:03:15,120 --> 00:03:19,920
hear me

00:03:16,840 --> 00:03:22,159
okay sorry about that

00:03:19,920 --> 00:03:23,120
great thank you very much i see some

00:03:22,159 --> 00:03:25,040
responses that

00:03:23,120 --> 00:03:27,120
we can hear you so whoever can that must

00:03:25,040 --> 00:03:29,920
be something on your end

00:03:27,120 --> 00:03:29,920
sorry about that

00:03:31,440 --> 00:03:35,760
okay so let's continue um so before we

00:03:35,200 --> 00:03:39,760
even

00:03:35,760 --> 00:03:43,040
uh start talking about debugging um

00:03:39,760 --> 00:03:45,360
it's you really want to start first by

00:03:43,040 --> 00:03:46,720
testing and uh you know even before you

00:03:45,360 --> 00:03:47,440
do any debugging you should probably do

00:03:46,720 --> 00:03:50,239
testing

00:03:47,440 --> 00:03:53,440
unit tests integration tests basically

00:03:50,239 --> 00:03:53,440
the more expensive your

00:03:53,920 --> 00:03:57,840
software the more testing you want to do

00:03:56,319 --> 00:03:58,879
because debugging is always more

00:03:57,840 --> 00:04:01,920
expensive than

00:03:58,879 --> 00:04:03,920
testing in the beginning

00:04:01,920 --> 00:04:05,680
and generally about writing software i

00:04:03,920 --> 00:04:08,400
love this quote from brian kernighan

00:04:05,680 --> 00:04:09,840
one of the authors of the original book

00:04:08,400 --> 00:04:11,040
on c

00:04:09,840 --> 00:04:12,640
he says that everybody knows that

00:04:11,040 --> 00:04:14,400
debugging is twice as hard as writing a

00:04:12,640 --> 00:04:15,280
program in the first place so if you're

00:04:14,400 --> 00:04:17,840
as clever

00:04:15,280 --> 00:04:18,639
as you are when you write it as can be

00:04:17,840 --> 00:04:21,919
when you write it

00:04:18,639 --> 00:04:23,280
how will you ever debug it um

00:04:21,919 --> 00:04:25,040
on the question of will these slides be

00:04:23,280 --> 00:04:28,240
available yes i'll uh

00:04:25,040 --> 00:04:29,919
ask the um the

00:04:28,240 --> 00:04:31,759
linux foundation organizers and we'll

00:04:29,919 --> 00:04:34,880
i'll make them available after the talk

00:04:31,759 --> 00:04:38,000
on the skip page

00:04:34,880 --> 00:04:40,479
uh so basically my

00:04:38,000 --> 00:04:42,080
approach to debugging is basically i

00:04:40,479 --> 00:04:46,240
wanted to give it a clever title

00:04:42,080 --> 00:04:50,320
so to reproduce observe and bisect

00:04:46,240 --> 00:04:52,160
which spells rob and this apparently is

00:04:50,320 --> 00:04:55,120
a character in the

00:04:52,160 --> 00:04:56,320
nintendo video game called drop but

00:04:55,120 --> 00:04:57,680
basically the idea is we want to

00:04:56,320 --> 00:04:59,600
reproduce the problem that

00:04:57,680 --> 00:05:01,360
we're seeing we want to observe and get

00:04:59,600 --> 00:05:04,080
as much visibility as we can

00:05:01,360 --> 00:05:04,639
into the problem and bisect is to find

00:05:04,080 --> 00:05:08,000
where

00:05:04,639 --> 00:05:10,320
the problem lies so what why do you want

00:05:08,000 --> 00:05:11,759
to reproduce instead of just starting to

00:05:10,320 --> 00:05:14,320
debug right away

00:05:11,759 --> 00:05:17,440
well generally when the users report

00:05:14,320 --> 00:05:17,440
bugs or when you see

00:05:18,000 --> 00:05:21,680
you know when you see a bug happen you

00:05:20,479 --> 00:05:22,960
generally are missing a lot of

00:05:21,680 --> 00:05:25,199
information

00:05:22,960 --> 00:05:26,479
there's a very low signal noise ratio

00:05:25,199 --> 00:05:29,520
users don't really know

00:05:26,479 --> 00:05:31,120
what you want to know about the bug or

00:05:29,520 --> 00:05:32,320
why it happens they just say oh this

00:05:31,120 --> 00:05:34,720
broke

00:05:32,320 --> 00:05:37,840
so to properly instrument and observe

00:05:34,720 --> 00:05:39,520
and figure out what happened you really

00:05:37,840 --> 00:05:41,440
like the most important step is to

00:05:39,520 --> 00:05:44,800
reproduce the problem

00:05:41,440 --> 00:05:46,639
in fact even if you think that you can

00:05:44,800 --> 00:05:47,199
look at the code and find the fix and

00:05:46,639 --> 00:05:48,479
say oh

00:05:47,199 --> 00:05:50,240
you know i'm pretty sure this is what

00:05:48,479 --> 00:05:50,880
happened you don't really know that you

00:05:50,240 --> 00:05:53,360
fixed it

00:05:50,880 --> 00:05:54,000
until you've reproduced it then tested

00:05:53,360 --> 00:05:57,199
it

00:05:54,000 --> 00:05:58,800
after you fixed the bug and said yeah

00:05:57,199 --> 00:05:59,360
this really fixes the problem a lot of

00:05:58,800 --> 00:06:01,440
times

00:05:59,360 --> 00:06:03,120
you can think that you found the problem

00:06:01,440 --> 00:06:04,880
but you didn't actually so until you

00:06:03,120 --> 00:06:08,240
produce you can't actually

00:06:04,880 --> 00:06:12,160
know for sure that you fixed it

00:06:08,240 --> 00:06:15,280
so observe what am i

00:06:12,160 --> 00:06:16,160
talking about here basically you want

00:06:15,280 --> 00:06:18,160
visibility

00:06:16,160 --> 00:06:19,919
so the visibility is the the first most

00:06:18,160 --> 00:06:21,840
important thing is to produce a problem

00:06:19,919 --> 00:06:23,520
and the second is to

00:06:21,840 --> 00:06:26,160
have visibility into the program into

00:06:23,520 --> 00:06:28,800
what you're trying to

00:06:26,160 --> 00:06:30,160
debug so the picture over here is the

00:06:28,800 --> 00:06:34,240
very first bug

00:06:30,160 --> 00:06:36,000
found in a uh computer in the 1950s i

00:06:34,240 --> 00:06:38,240
believe it was in the iniak

00:06:36,000 --> 00:06:39,840
um and it was an actual bug that got

00:06:38,240 --> 00:06:42,400
fried in one of the relays

00:06:39,840 --> 00:06:43,199
and uh created the short and the little

00:06:42,400 --> 00:06:44,720
bug was

00:06:43,199 --> 00:06:47,199
taped over there a little piece of tape

00:06:44,720 --> 00:06:49,520
to the paper

00:06:47,199 --> 00:06:50,960
so uh to find these bugs you need

00:06:49,520 --> 00:06:52,560
visibility into the program

00:06:50,960 --> 00:06:54,560
you could use it in lots of different

00:06:52,560 --> 00:06:56,000
ways you know the simplest one is just

00:06:54,560 --> 00:06:58,080
put a lot of print statements in your

00:06:56,000 --> 00:07:00,160
program um a better way is to use a

00:06:58,080 --> 00:07:03,120
logging framework i have some links here

00:07:00,160 --> 00:07:04,240
to some very nice ones like nc c c plus

00:07:03,120 --> 00:07:06,560
pluses google's g

00:07:04,240 --> 00:07:08,319
log and python there is a great logging

00:07:06,560 --> 00:07:10,319
module included

00:07:08,319 --> 00:07:12,720
you can log to the system log from the

00:07:10,319 --> 00:07:14,479
shell using the logger command

00:07:12,720 --> 00:07:16,240
or just redirect all your output to a

00:07:14,479 --> 00:07:18,240
file you you don't want

00:07:16,240 --> 00:07:19,759
things to disappear so whenever you have

00:07:18,240 --> 00:07:20,639
something that could produce output you

00:07:19,759 --> 00:07:25,039
want to drop it

00:07:20,639 --> 00:07:28,800
some dropped output somewhere and uh

00:07:25,039 --> 00:07:30,800
when there is logging aggregators like

00:07:28,800 --> 00:07:33,759
splunk or elasticsearch

00:07:30,800 --> 00:07:34,000
i really like splunk it's uh very nice

00:07:33,759 --> 00:07:35,919
and

00:07:34,000 --> 00:07:37,280
it's a way to aggregate logs from lots

00:07:35,919 --> 00:07:39,680
of machines and then you can

00:07:37,280 --> 00:07:39,680
kind of

00:07:40,639 --> 00:07:43,360
see what's happening on many different

00:07:42,160 --> 00:07:44,400
machines at the same time if you're

00:07:43,360 --> 00:07:47,599
writing in a cluster

00:07:44,400 --> 00:07:50,319
and so forth and the last point is

00:07:47,599 --> 00:07:51,599
asserts asserts are your friends if

00:07:50,319 --> 00:07:53,120
you're sure that

00:07:51,599 --> 00:07:55,120
something is true at a certain point of

00:07:53,120 --> 00:07:57,520
the program put an assert there

00:07:55,120 --> 00:07:58,879
because you never know what can go wrong

00:07:57,520 --> 00:08:01,120
and it'll provide

00:07:58,879 --> 00:08:03,919
use a useful stopping point if things

00:08:01,120 --> 00:08:03,919
have gotten the same

00:08:04,319 --> 00:08:08,639
so one of some there's lots of great

00:08:06,240 --> 00:08:10,960
tools in linux i think in linux

00:08:08,639 --> 00:08:12,960
basically you have tons and tons of

00:08:10,960 --> 00:08:14,720
tools to have visibility and

00:08:12,960 --> 00:08:16,560
the biggest problem is like which tools

00:08:14,720 --> 00:08:17,840
they actually use to get visibility into

00:08:16,560 --> 00:08:20,160
your program

00:08:17,840 --> 00:08:22,400
um the best so the first thing i do

00:08:20,160 --> 00:08:24,000
generally when i need to debug a

00:08:22,400 --> 00:08:26,400
linux application is to use s trace

00:08:24,000 --> 00:08:30,800
which traces the polar system calls

00:08:26,400 --> 00:08:32,959
that a program is making

00:08:30,800 --> 00:08:34,000
gdb of course there's quite lots of

00:08:32,959 --> 00:08:36,640
great resources

00:08:34,000 --> 00:08:38,839
about gdb uh gdp is also useful for

00:08:36,640 --> 00:08:40,159
debugging core files if a program

00:08:38,839 --> 00:08:42,959
crashes um

00:08:40,159 --> 00:08:43,680
don't forget to debug with to compile

00:08:42,959 --> 00:08:46,000
sorry with

00:08:43,680 --> 00:08:46,720
debug symbols so there's the dash g

00:08:46,000 --> 00:08:49,120
option to

00:08:46,720 --> 00:08:50,480
gcc you could do a man gcc and it will

00:08:49,120 --> 00:08:51,519
describe all the various debugging

00:08:50,480 --> 00:08:54,959
options but

00:08:51,519 --> 00:08:56,480
in general debug symbols don't add

00:08:54,959 --> 00:08:58,640
they add a little bit of size to your

00:08:56,480 --> 00:09:00,320
executable they don't slow down your

00:08:58,640 --> 00:09:02,399
program at all

00:09:00,320 --> 00:09:03,360
so if unless you're in a very tight

00:09:02,399 --> 00:09:05,360
embedded system

00:09:03,360 --> 00:09:08,240
you really do want to compile with

00:09:05,360 --> 00:09:11,040
symbols another trick that you can do is

00:09:08,240 --> 00:09:11,839
if you are uh if your executable space

00:09:11,040 --> 00:09:14,959
is very tight

00:09:11,839 --> 00:09:16,080
on your platform you can compile once

00:09:14,959 --> 00:09:17,920
with symbols

00:09:16,080 --> 00:09:19,680
and once without so once you compile

00:09:17,920 --> 00:09:22,399
with minus g and once without

00:09:19,680 --> 00:09:23,680
the two binaries will actually be

00:09:22,399 --> 00:09:26,880
interoperable meaning

00:09:23,680 --> 00:09:27,519
you can if you use gdb server on the

00:09:26,880 --> 00:09:31,040
target

00:09:27,519 --> 00:09:33,519
and the gdp client on on the

00:09:31,040 --> 00:09:35,519
on your developing platform you can

00:09:33,519 --> 00:09:38,080
actually use the

00:09:35,519 --> 00:09:39,360
program file with symbols to debug the

00:09:38,080 --> 00:09:41,600
one without symbols

00:09:39,360 --> 00:09:44,240
you can load up the symbol file from a

00:09:41,600 --> 00:09:46,640
different file

00:09:44,240 --> 00:09:48,160
you can also use the file command in gdp

00:09:46,640 --> 00:09:50,080
so if you

00:09:48,160 --> 00:09:51,200
started running your program with the

00:09:50,080 --> 00:09:54,000
one without symbols

00:09:51,200 --> 00:09:56,800
you can then use the file command gdp to

00:09:54,000 --> 00:10:00,800
load up the symbols from

00:09:56,800 --> 00:10:01,760
from one i have a question is how can we

00:10:00,800 --> 00:10:04,880
debug

00:10:01,760 --> 00:10:05,760
if from pankaj i believe how can we

00:10:04,880 --> 00:10:08,399
debug if

00:10:05,760 --> 00:10:10,000
linux is stuck in booting for that you

00:10:08,399 --> 00:10:12,959
need kgdb

00:10:10,000 --> 00:10:14,320
there's good resources on that but

00:10:12,959 --> 00:10:15,839
you'll need the second computer to

00:10:14,320 --> 00:10:18,640
attach to the first computer

00:10:15,839 --> 00:10:19,839
or you can use the built-in kgdb

00:10:18,640 --> 00:10:22,480
debugger

00:10:19,839 --> 00:10:23,839
so you should just google kgdb and the

00:10:22,480 --> 00:10:27,600
follow the

00:10:23,839 --> 00:10:30,560
instructions there always use wall

00:10:27,600 --> 00:10:33,040
and w error so that's to turn on all

00:10:30,560 --> 00:10:34,480
warnings and all errors in gcc

00:10:33,040 --> 00:10:36,160
they're generally super useful it

00:10:34,480 --> 00:10:38,959
doesn't hurt to turn them on

00:10:36,160 --> 00:10:40,079
and the things it's fine sometimes seem

00:10:38,959 --> 00:10:41,519
pedantic but

00:10:40,079 --> 00:10:45,279
it's generally a good idea to fix all of

00:10:41,519 --> 00:10:48,399
them a word on

00:10:45,279 --> 00:10:50,160
uh reverse debugging um it's pretty cool

00:10:48,399 --> 00:10:51,440
but i practically haven't found it

00:10:50,160 --> 00:10:53,920
really super useful

00:10:51,440 --> 00:10:54,640
um once you kind of know what you're

00:10:53,920 --> 00:10:56,399
looking for

00:10:54,640 --> 00:10:58,079
you can like restart your program and

00:10:56,399 --> 00:11:00,160
get to that place from the

00:10:58,079 --> 00:11:01,680
from the beginning instead of going back

00:11:00,160 --> 00:11:03,519
other people may have had different

00:11:01,680 --> 00:11:05,279
experiences gdp does support some level

00:11:03,519 --> 00:11:08,240
of reverse debugging there's also a

00:11:05,279 --> 00:11:09,920
tool called undo dp i will also talk

00:11:08,240 --> 00:11:12,079
about wireshark and tcp dump

00:11:09,920 --> 00:11:14,160
and uh if you're debugging any hardware

00:11:12,079 --> 00:11:16,399
you want to

00:11:14,160 --> 00:11:18,880
you want to get visibility into that

00:11:16,399 --> 00:11:18,880
protocol

00:11:22,160 --> 00:11:27,920
okay um skip that

00:11:25,600 --> 00:11:30,320
so this is a linux performance

00:11:27,920 --> 00:11:32,399
observability tools from brendan gregg

00:11:30,320 --> 00:11:34,079
uh he's an engineer at netflix and he

00:11:32,399 --> 00:11:36,240
has some great resources in his webpage

00:11:34,079 --> 00:11:39,200
about all the possible visibility tools

00:11:36,240 --> 00:11:40,880
in linux there's way too much to go into

00:11:39,200 --> 00:11:42,079
right now but you can definitely go on

00:11:40,880 --> 00:11:44,800
his website he gets

00:11:42,079 --> 00:11:46,880
gives great overviews of uh what to look

00:11:44,800 --> 00:11:46,880
at

00:11:48,240 --> 00:11:52,000
and finally bisect so the idea is you

00:11:50,720 --> 00:11:56,639
want to do a binary search

00:11:52,000 --> 00:11:58,639
once you find that there is a

00:11:56,639 --> 00:11:59,680
problem once you've reproduced it and

00:11:58,639 --> 00:12:01,120
you can observe it

00:11:59,680 --> 00:12:03,040
you now want to do a binary search to

00:12:01,120 --> 00:12:04,320
find out like where in the code the

00:12:03,040 --> 00:12:08,240
problem actually is

00:12:04,320 --> 00:12:09,920
so one way to do is is to kind of say

00:12:08,240 --> 00:12:11,600
if you don't have an idea make an

00:12:09,920 --> 00:12:12,800
educated guess if you don't have an idea

00:12:11,600 --> 00:12:14,800
where it is just

00:12:12,800 --> 00:12:15,920
guess you know first half or second half

00:12:14,800 --> 00:12:17,120
of the program

00:12:15,920 --> 00:12:18,959
and then you could just disable the

00:12:17,120 --> 00:12:19,680
other half run it again see if you hit

00:12:18,959 --> 00:12:22,160
the bug

00:12:19,680 --> 00:12:23,040
and uh iterate uh you can do other

00:12:22,160 --> 00:12:25,200
things to

00:12:23,040 --> 00:12:26,959
like switch things up you could switch

00:12:25,200 --> 00:12:28,639
compiler optimization levels you could

00:12:26,959 --> 00:12:30,639
switch two versions

00:12:28,639 --> 00:12:31,839
generally whenever you do these things

00:12:30,639 --> 00:12:33,600
do one at a time

00:12:31,839 --> 00:12:34,800
don't try to switch too many things at a

00:12:33,600 --> 00:12:37,680
time because then you won't know which

00:12:34,800 --> 00:12:39,519
one of those actually caused the problem

00:12:37,680 --> 00:12:41,440
and you also generally want to what i

00:12:39,519 --> 00:12:44,079
like to call a trust stack

00:12:41,440 --> 00:12:45,360
you should trust your program the least

00:12:44,079 --> 00:12:48,160
you should trust

00:12:45,360 --> 00:12:49,760
libraries that you're using or probably

00:12:48,160 --> 00:12:51,120
have been tested by more people than

00:12:49,760 --> 00:12:52,000
just you so they're probably more

00:12:51,120 --> 00:12:54,320
trustworthy

00:12:52,000 --> 00:12:55,279
the compiler the os and the hardware in

00:12:54,320 --> 00:12:57,920
that order

00:12:55,279 --> 00:12:58,720
are less at fault it's always you know

00:12:57,920 --> 00:13:01,440
kind of

00:12:58,720 --> 00:13:02,240
you always want to blame the computer or

00:13:01,440 --> 00:13:05,040
the hardware

00:13:02,240 --> 00:13:08,000
or the os of being wrong but most of the

00:13:05,040 --> 00:13:11,040
time that's not the case

00:13:08,000 --> 00:13:14,160
although sometimes it is so

00:13:11,040 --> 00:13:16,639
i like to classify bugs into

00:13:14,160 --> 00:13:18,320
hard and soft errors so the hard errors

00:13:16,639 --> 00:13:20,160
are actually easy to find the harder is

00:13:18,320 --> 00:13:20,800
when you have a crash or unrecoverable

00:13:20,160 --> 00:13:22,560
error

00:13:20,800 --> 00:13:23,920
so things just go off the rails and

00:13:22,560 --> 00:13:26,000
break and

00:13:23,920 --> 00:13:27,519
it's generally pretty easy to produce

00:13:26,000 --> 00:13:29,040
and

00:13:27,519 --> 00:13:31,360
easy to figure out what happened the

00:13:29,040 --> 00:13:32,720
soft air is kind of an intermittent

00:13:31,360 --> 00:13:35,040
there and those are terrible

00:13:32,720 --> 00:13:36,000
because you don't really know that you

00:13:35,040 --> 00:13:38,480
fixed it

00:13:36,000 --> 00:13:39,600
because maybe it just didn't get lucky

00:13:38,480 --> 00:13:41,760
and didn't happen again

00:13:39,600 --> 00:13:43,360
so what you want to what you want to do

00:13:41,760 --> 00:13:45,040
is you want to try as hard

00:13:43,360 --> 00:13:47,199
as you can to reproduce the air and to

00:13:45,040 --> 00:13:50,480
turn that soft air into

00:13:47,199 --> 00:13:52,560
a hard error so how do you do that

00:13:50,480 --> 00:13:54,639
well tracing and logging i'll give you

00:13:52,560 --> 00:13:58,000
an idea

00:13:54,639 --> 00:13:58,000
you could look at external events

00:13:58,639 --> 00:14:04,000
like logs network cpu load

00:14:02,560 --> 00:14:06,240
uh you could try to replicate the error

00:14:04,000 --> 00:14:07,440
message that you see you could stress

00:14:06,240 --> 00:14:10,079
test the application

00:14:07,440 --> 00:14:12,320
or of course you can use gdb or the bug

00:14:10,079 --> 00:14:12,320
error

00:14:13,040 --> 00:14:16,399
so i'll give a few examples and then

00:14:15,519 --> 00:14:18,160
i've i'm going to

00:14:16,399 --> 00:14:19,600
answer see how there's a lot of

00:14:18,160 --> 00:14:21,120
questions i'm going to try to answer

00:14:19,600 --> 00:14:23,680
most of them at the end

00:14:21,120 --> 00:14:24,480
uh so this was an error that we saw that

00:14:23,680 --> 00:14:27,120
it's a

00:14:24,480 --> 00:14:28,399
weird error um it's a it looks like an

00:14:27,120 --> 00:14:29,440
io error in the program so it's

00:14:28,399 --> 00:14:32,240
highlighted there in

00:14:29,440 --> 00:14:34,399
red you could see the output so we run

00:14:32,240 --> 00:14:36,639
an executable and it says

00:14:34,399 --> 00:14:37,519
boost file system reports input output

00:14:36,639 --> 00:14:40,720
error so

00:14:37,519 --> 00:14:42,480
input output error is caused by an eio

00:14:40,720 --> 00:14:44,399
and generally this is very hard to

00:14:42,480 --> 00:14:47,199
produce because it's generally

00:14:44,399 --> 00:14:48,000
only caused by bad hardware or bad

00:14:47,199 --> 00:14:51,440
network

00:14:48,000 --> 00:14:53,519
nfs shares um it's

00:14:51,440 --> 00:14:55,199
intermittent meaning when it's bad

00:14:53,519 --> 00:14:55,519
hardware it won't always give you the i

00:14:55,199 --> 00:14:57,279
o

00:14:55,519 --> 00:14:58,959
so how do you reproduce something like

00:14:57,279 --> 00:15:01,120
this

00:14:58,959 --> 00:15:02,800
well i actually tried to reproduce this

00:15:01,120 --> 00:15:04,959
first by just removing the file

00:15:02,800 --> 00:15:06,160
but it does not result in the same

00:15:04,959 --> 00:15:08,399
failure

00:15:06,160 --> 00:15:10,000
the call works just fine and says the

00:15:08,399 --> 00:15:12,240
file is not there and doesn't cause

00:15:10,000 --> 00:15:14,000
i o error or anything that causes the

00:15:12,240 --> 00:15:17,360
program to crash

00:15:14,000 --> 00:15:19,360
well i looked at airno.h

00:15:17,360 --> 00:15:21,519
that can be found in user include has

00:15:19,360 --> 00:15:23,920
some generic air node.h and any linux

00:15:21,519 --> 00:15:25,040
distribution just look for an error code

00:15:23,920 --> 00:15:27,760
that's similar

00:15:25,040 --> 00:15:29,040
there's one called e-loop too many

00:15:27,760 --> 00:15:31,199
symbolic links

00:15:29,040 --> 00:15:33,120
you can simulate that by making two

00:15:31,199 --> 00:15:34,639
links you link file a to file b

00:15:33,120 --> 00:15:36,959
and there's another thing from file b

00:15:34,639 --> 00:15:38,399
back to file a and then when you cat a

00:15:36,959 --> 00:15:40,480
you get this error too many levels of

00:15:38,399 --> 00:15:42,480
symbolic links well

00:15:40,480 --> 00:15:43,519
we could run try running your program

00:15:42,480 --> 00:15:45,519
against that

00:15:43,519 --> 00:15:47,120
and then i wrote here a test program

00:15:45,519 --> 00:15:49,040
that does this the call that failed

00:15:47,120 --> 00:15:52,639
boost file system exists

00:15:49,040 --> 00:15:54,880
on an unexisting file foo and in red

00:15:52,639 --> 00:15:56,320
try it on a on this too many symbolic

00:15:54,880 --> 00:15:58,560
links file a

00:15:56,320 --> 00:15:59,680
when we run the program the first line

00:15:58,560 --> 00:16:02,240
outputs

00:15:59,680 --> 00:16:03,279
normally foo does not exist but on the

00:16:02,240 --> 00:16:05,199
second one

00:16:03,279 --> 00:16:07,600
it throws an error and says terminate

00:16:05,199 --> 00:16:10,560
called so that that shows you that

00:16:07,600 --> 00:16:10,880
c plus threw an exception now why would

00:16:10,560 --> 00:16:13,040
it

00:16:10,880 --> 00:16:14,399
why would checking for existence of a

00:16:13,040 --> 00:16:16,160
file throw an exception

00:16:14,399 --> 00:16:17,600
well if you look at the documentation

00:16:16,160 --> 00:16:19,519
for boost it turns out that somebody

00:16:17,600 --> 00:16:22,880
decided that it's a really good idea

00:16:19,519 --> 00:16:25,440
to return one if something exists

00:16:22,880 --> 00:16:26,160
zero something doesn't exist and in some

00:16:25,440 --> 00:16:28,320
cases

00:16:26,160 --> 00:16:30,320
as specified in a whole different long

00:16:28,320 --> 00:16:32,320
legalese page of cold air recording in

00:16:30,320 --> 00:16:34,000
some cases will throw errors

00:16:32,320 --> 00:16:36,800
this is a really terrible idea i think

00:16:34,000 --> 00:16:39,120
but you know um

00:16:36,800 --> 00:16:40,000
but we found what the error was and uh

00:16:39,120 --> 00:16:42,240
there's a different

00:16:40,000 --> 00:16:44,000
version of the exist call this does not

00:16:42,240 --> 00:16:46,240
throw exceptions or just switch to using

00:16:44,000 --> 00:16:46,240
that

00:16:46,480 --> 00:16:53,519
i don't know why they decided to do that

00:16:50,000 --> 00:16:56,399
a different bug we start a program and

00:16:53,519 --> 00:16:58,560
it fails to start and it gives us useful

00:16:56,399 --> 00:16:59,680
error message saying that intel mkl

00:16:58,560 --> 00:17:03,279
which is the intel

00:16:59,680 --> 00:17:05,600
math library could not load this

00:17:03,279 --> 00:17:07,439
uh library well you know that's

00:17:05,600 --> 00:17:10,240
straightforward enough but then you

00:17:07,439 --> 00:17:11,600
check is that library actually there oh

00:17:10,240 --> 00:17:14,880
yes it is

00:17:11,600 --> 00:17:15,679
what how why is it not failing to load

00:17:14,880 --> 00:17:18,720
the library

00:17:15,679 --> 00:17:21,919
this library is not on nfs it's not

00:17:18,720 --> 00:17:24,000
it's on a regular disk so why would the

00:17:21,919 --> 00:17:28,319
program fail to start

00:17:24,000 --> 00:17:28,319
when that library is actually present

00:17:28,720 --> 00:17:32,400
so second step would be to observe to

00:17:31,200 --> 00:17:34,240
try to figure out

00:17:32,400 --> 00:17:35,760
what is going on here so like i

00:17:34,240 --> 00:17:36,320
mentioned before s trace is great for

00:17:35,760 --> 00:17:38,480
doing that

00:17:36,320 --> 00:17:39,600
you could look you can run your program

00:17:38,480 --> 00:17:42,880
under s trace

00:17:39,600 --> 00:17:43,840
if it's reproducible um you'll see what

00:17:42,880 --> 00:17:47,200
it's trying to do

00:17:43,840 --> 00:17:51,039
so i took an s trace of a working

00:17:47,200 --> 00:17:52,400
run of this program and a

00:17:51,039 --> 00:17:54,240
failing one and when they begin to

00:17:52,400 --> 00:17:56,160
diverge is that first red line when it

00:17:54,240 --> 00:17:58,400
doesn't get cwd

00:17:56,160 --> 00:18:00,160
get cwd is a system called it gets the

00:17:58,400 --> 00:18:03,840
current working directory

00:18:00,160 --> 00:18:05,520
so when you type pwd in your shell

00:18:03,840 --> 00:18:07,919
that's what it does it says where are we

00:18:05,520 --> 00:18:10,240
right now in the file system

00:18:07,919 --> 00:18:12,240
and it's getting an email end there's no

00:18:10,240 --> 00:18:14,640
such file or directory

00:18:12,240 --> 00:18:15,760
so that's weird that it's checking its

00:18:14,640 --> 00:18:17,120
current directory and the current

00:18:15,760 --> 00:18:18,799
directory does not exist and then soon

00:18:17,120 --> 00:18:20,720
after you see the right call

00:18:18,799 --> 00:18:22,080
intel mkl fail error which is the one

00:18:20,720 --> 00:18:26,080
we're looking for

00:18:22,080 --> 00:18:28,400
so why um

00:18:26,080 --> 00:18:30,480
why did that happen it looks as though

00:18:28,400 --> 00:18:32,960
something in the mka library

00:18:30,480 --> 00:18:34,320
really really wants to know which

00:18:32,960 --> 00:18:36,480
directory you're in

00:18:34,320 --> 00:18:38,080
and if it can't find if it gets an

00:18:36,480 --> 00:18:38,880
innovant on the current working

00:18:38,080 --> 00:18:40,880
directory

00:18:38,880 --> 00:18:42,320
it fails with a really confusing error

00:18:40,880 --> 00:18:45,440
message

00:18:42,320 --> 00:18:48,559
so let's try to

00:18:45,440 --> 00:18:49,440
to uh find to check that this is really

00:18:48,559 --> 00:18:51,360
the problem

00:18:49,440 --> 00:18:53,280
so when you base sect we make like an

00:18:51,360 --> 00:18:53,840
educated guess let's make an educated

00:18:53,280 --> 00:18:55,919
guess and

00:18:53,840 --> 00:18:58,880
write a test program so this little bash

00:18:55,919 --> 00:19:01,760
script makes a directory test

00:18:58,880 --> 00:19:02,240
uh the parentheses here say in a sub

00:19:01,760 --> 00:19:05,679
shell

00:19:02,240 --> 00:19:07,600
you wait for a one second and then you

00:19:05,679 --> 00:19:08,960
run the program that was the failing

00:19:07,600 --> 00:19:11,120
program for us

00:19:08,960 --> 00:19:12,720
meanwhile in the top shell script and

00:19:11,120 --> 00:19:14,640
that's the ampersand here

00:19:12,720 --> 00:19:16,559
says do this in the background so it's

00:19:14,640 --> 00:19:17,760
going to execute another sub shell

00:19:16,559 --> 00:19:19,120
in that sub shell it's going to wait a

00:19:17,760 --> 00:19:20,640
little bit and run the program in that

00:19:19,120 --> 00:19:22,720
directory meanwhile in the main program

00:19:20,640 --> 00:19:25,120
we're going to remove the directory

00:19:22,720 --> 00:19:27,200
that that sub-shell is executing under

00:19:25,120 --> 00:19:28,640
and then we wait for everything to exit

00:19:27,200 --> 00:19:30,880
and sure enough when we run this shell

00:19:28,640 --> 00:19:34,080
script we get the failing error message

00:19:30,880 --> 00:19:37,120
so now we've reproduced it and found

00:19:34,080 --> 00:19:37,679
the actual error so mkl really doesn't

00:19:37,120 --> 00:19:41,440
like

00:19:37,679 --> 00:19:41,440
when you remove the underlying directory

00:19:43,039 --> 00:19:50,400
homer simpson is very upset

00:19:46,480 --> 00:19:53,919
so gdb so gdp is really great

00:19:50,400 --> 00:19:54,720
at um debugging anything it can actually

00:19:53,919 --> 00:19:57,280
debug

00:19:54,720 --> 00:19:59,039
probably any language you can think of

00:19:57,280 --> 00:20:02,240
anything that's compiled by

00:19:59,039 --> 00:20:04,640
gcc which is not the new c compiler but

00:20:02,240 --> 00:20:07,039
now the new compiler collection

00:20:04,640 --> 00:20:07,919
which compiles basically a new language

00:20:07,039 --> 00:20:11,039
and it can also

00:20:07,919 --> 00:20:14,880
uh debug things with llvm

00:20:11,039 --> 00:20:18,159
if i'm not mistaken um so you can

00:20:14,880 --> 00:20:19,840
gdp a live process as well as

00:20:18,159 --> 00:20:21,200
um you know start you can start a new

00:20:19,840 --> 00:20:23,200
program for debugging or if you have a

00:20:21,200 --> 00:20:26,240
process that's running you can gdb

00:20:23,200 --> 00:20:27,919
the process with the bit um you do have

00:20:26,240 --> 00:20:30,960
to be careful because when you do that

00:20:27,919 --> 00:20:33,679
it um but it stops the process so

00:20:30,960 --> 00:20:35,039
if it's something that's important to

00:20:33,679 --> 00:20:36,799
keep running you probably don't want to

00:20:35,039 --> 00:20:38,320
run gdp on it directly

00:20:36,799 --> 00:20:39,840
however what you can do is you can use

00:20:38,320 --> 00:20:41,600
the g chord tool

00:20:39,840 --> 00:20:43,280
um that will generate a core dump a

00:20:41,600 --> 00:20:44,720
quart up is basically an image of the

00:20:43,280 --> 00:20:45,440
register the memory of the running

00:20:44,720 --> 00:20:48,559
process

00:20:45,440 --> 00:20:51,840
so g core will cause the

00:20:48,559 --> 00:20:53,360
uh program to dump core to generate that

00:20:51,840 --> 00:20:55,280
image without stopping

00:20:53,360 --> 00:20:56,480
the process and then afterwards you can

00:20:55,280 --> 00:20:59,280
use gdb

00:20:56,480 --> 00:21:00,960
to debug it in fact gdp from the core

00:20:59,280 --> 00:21:03,120
file can even pick up which executable

00:21:00,960 --> 00:21:04,400
it was so if you're not even sure

00:21:03,120 --> 00:21:06,640
if you don't remember which version of

00:21:04,400 --> 00:21:08,640
the executable or which one you ran

00:21:06,640 --> 00:21:09,840
the path physics you will be in the car

00:21:08,640 --> 00:21:12,080
file

00:21:09,840 --> 00:21:14,640
it has really good thread support you

00:21:12,080 --> 00:21:18,000
can look at the man pages it just

00:21:14,640 --> 00:21:21,280
you could do um commands

00:21:18,000 --> 00:21:22,880
that to look at all the threads or apply

00:21:21,280 --> 00:21:24,240
a command to all the threads

00:21:22,880 --> 00:21:26,480
for example the bottom one here is a

00:21:24,240 --> 00:21:29,360
thread apply all back trace

00:21:26,480 --> 00:21:30,720
so the backtrace command will then be

00:21:29,360 --> 00:21:33,440
done on all the threads

00:21:30,720 --> 00:21:33,440
in your program

00:21:34,320 --> 00:21:37,919
um it's it has very good support for

00:21:36,960 --> 00:21:39,520
debugging embedded

00:21:37,919 --> 00:21:41,120
programs which is particularly useful

00:21:39,520 --> 00:21:44,240
for this um

00:21:41,120 --> 00:21:45,760
for this conference for embedded systems

00:21:44,240 --> 00:21:47,840
you want to run something called gdb

00:21:45,760 --> 00:21:50,960
server which is this very small

00:21:47,840 --> 00:21:53,440
several kilobyte stub

00:21:50,960 --> 00:21:54,400
that can just trace the program and then

00:21:53,440 --> 00:21:56,799
all the

00:21:54,400 --> 00:22:00,240
command line and all the other

00:21:56,799 --> 00:22:03,360
processing in gdp is done on a client

00:22:00,240 --> 00:22:04,240
um so the gdb connect command you could

00:22:03,360 --> 00:22:06,080
uh look

00:22:04,240 --> 00:22:07,440
up the manual pages for gdp server and

00:22:06,080 --> 00:22:10,480
i'll explain exactly

00:22:07,440 --> 00:22:12,159
how to do this a very useful feature if

00:22:10,480 --> 00:22:13,919
you have memory corruption

00:22:12,159 --> 00:22:16,240
this happens a lot where you know that

00:22:13,919 --> 00:22:18,320
you've some memory has been trashed

00:22:16,240 --> 00:22:19,919
there is something called watch points

00:22:18,320 --> 00:22:20,480
so this is kind of like breakpoints

00:22:19,919 --> 00:22:23,280
except

00:22:20,480 --> 00:22:23,919
they break if something has written or

00:22:23,280 --> 00:22:27,280
read

00:22:23,919 --> 00:22:27,840
a certain value in memory this is super

00:22:27,280 --> 00:22:30,400
useful

00:22:27,840 --> 00:22:32,000
for um when you know that in your

00:22:30,400 --> 00:22:33,360
program something is going to corrupt

00:22:32,000 --> 00:22:35,200
some something's got a right memory but

00:22:33,360 --> 00:22:36,640
you don't know what it is

00:22:35,200 --> 00:22:38,000
you should keep in mind that what you

00:22:36,640 --> 00:22:38,799
really want to use are hardware watch

00:22:38,000 --> 00:22:40,559
points

00:22:38,799 --> 00:22:42,000
the x86 architecture provides four

00:22:40,559 --> 00:22:43,840
hardware watch points

00:22:42,000 --> 00:22:45,919
um other architectures provides

00:22:43,840 --> 00:22:47,440
different numbers some don't have any

00:22:45,919 --> 00:22:49,440
you really don't want to if you use more

00:22:47,440 --> 00:22:51,200
than four or if your architecture does

00:22:49,440 --> 00:22:53,200
not provide any hardware watch points

00:22:51,200 --> 00:22:54,799
your program will get really slow

00:22:53,200 --> 00:22:56,640
because then gdp has to intercept

00:22:54,799 --> 00:22:58,559
basically every memory access

00:22:56,640 --> 00:23:00,640
and check if it's it for the address

00:22:58,559 --> 00:23:02,559
that you're watching for

00:23:00,640 --> 00:23:04,880
um but if you're using the hardware

00:23:02,559 --> 00:23:07,600
watch points then the processor

00:23:04,880 --> 00:23:08,000
at native speed will just check every

00:23:07,600 --> 00:23:10,880
memory

00:23:08,000 --> 00:23:12,559
access and break if uh if you've tripped

00:23:10,880 --> 00:23:14,159
on a watch point

00:23:12,559 --> 00:23:16,400
conditional breakpoints are also super

00:23:14,159 --> 00:23:18,880
useful you can break

00:23:16,400 --> 00:23:20,320
on a certain location right this like a

00:23:18,880 --> 00:23:21,840
regular breakpoint and you can give it a

00:23:20,320 --> 00:23:23,679
condition so you say any condition

00:23:21,840 --> 00:23:26,640
that's evaluable by gdp

00:23:23,679 --> 00:23:28,080
so my variable equals five so you say

00:23:26,640 --> 00:23:30,480
break on this location

00:23:28,080 --> 00:23:31,120
if and then you give the condition to

00:23:30,480 --> 00:23:33,280
give

00:23:31,120 --> 00:23:34,480
just uh keep in mind that gdp will

00:23:33,280 --> 00:23:36,159
actually take the break point and

00:23:34,480 --> 00:23:36,960
evaluate the condition every time so if

00:23:36,159 --> 00:23:38,559
it's something

00:23:36,960 --> 00:23:40,080
it will slow down if you're going to be

00:23:38,559 --> 00:23:43,520
hitting that breakpoint

00:23:40,080 --> 00:23:45,440
many many times you can observe you can

00:23:43,520 --> 00:23:47,360
do commands at a breakpoint so if you

00:23:45,440 --> 00:23:48,880
want to print out a bunch of things

00:23:47,360 --> 00:23:50,799
every time you hit that breakpoint you

00:23:48,880 --> 00:23:52,240
can use the command keyword and give it

00:23:50,799 --> 00:23:56,080
a bunch of lines

00:23:52,240 --> 00:23:59,120
to do after that breakpoint

00:23:56,080 --> 00:24:00,799
finally the useful feature is catch

00:23:59,120 --> 00:24:02,400
this is useful for c plus plus

00:24:00,799 --> 00:24:04,080
specifically but

00:24:02,400 --> 00:24:05,919
could also be used to catch forks or

00:24:04,080 --> 00:24:07,360
signals and the c plus plus it's very

00:24:05,919 --> 00:24:09,840
useful to catch exceptions

00:24:07,360 --> 00:24:10,720
um it will it will breakpoint you as

00:24:09,840 --> 00:24:13,919
soon as anything

00:24:10,720 --> 00:24:13,919
throws any exception

00:24:15,360 --> 00:24:20,240
so here's an example of debugging a

00:24:18,320 --> 00:24:22,480
hanging process with gdb

00:24:20,240 --> 00:24:24,480
so we had a periodic hang where we run

00:24:22,480 --> 00:24:27,440
this big application and

00:24:24,480 --> 00:24:29,200
every like 10 000 jobs and this

00:24:27,440 --> 00:24:33,440
application runs for

00:24:29,200 --> 00:24:34,159
like 30 minutes and periodically we see

00:24:33,440 --> 00:24:36,240
a hang

00:24:34,159 --> 00:24:38,240
where it just stops there and we have a

00:24:36,240 --> 00:24:41,120
timeout after two hours

00:24:38,240 --> 00:24:43,679
that kills the application so the first

00:24:41,120 --> 00:24:46,720
thing we try to do is to reproduce

00:24:43,679 --> 00:24:49,279
but we couldn't figure out which

00:24:46,720 --> 00:24:50,559
which inputs would uh actually cause it

00:24:49,279 --> 00:24:52,480
to hang

00:24:50,559 --> 00:24:53,919
so we added code on the scheduler level

00:24:52,480 --> 00:24:57,039
so that's the the

00:24:53,919 --> 00:24:59,120
process that starts our application to

00:24:57,039 --> 00:24:59,760
monitor the application and if we see no

00:24:59,120 --> 00:25:02,640
output

00:24:59,760 --> 00:25:03,120
for about 10 minutes then we use g core

00:25:02,640 --> 00:25:04,799
to

00:25:03,120 --> 00:25:06,240
ask to get a core down public

00:25:04,799 --> 00:25:09,200
application and we can debug

00:25:06,240 --> 00:25:10,400
debug offline later now core files that

00:25:09,200 --> 00:25:12,840
are produced they're really big

00:25:10,400 --> 00:25:14,159
because there's lots of memory that a

00:25:12,840 --> 00:25:17,440
replication

00:25:14,159 --> 00:25:18,960
uses however they zip very well in fact

00:25:17,440 --> 00:25:20,400
when your program runs

00:25:18,960 --> 00:25:22,799
it'll use a lot of memory but a lot of

00:25:20,400 --> 00:25:25,360
that memory will be zeros or repeating

00:25:22,799 --> 00:25:27,279
bits of text and gzip will compress it

00:25:25,360 --> 00:25:29,760
really well

00:25:27,279 --> 00:25:31,840
so we use gdb to analyze the core down

00:25:29,760 --> 00:25:34,960
file of this hung process

00:25:31,840 --> 00:25:36,720
and uh when we get into gdb you

00:25:34,960 --> 00:25:38,320
type info threads which will tell you

00:25:36,720 --> 00:25:39,840
where each thread and application is

00:25:38,320 --> 00:25:43,279
this one has lots of threads

00:25:39,840 --> 00:25:46,240
all of them are in one thread

00:25:43,279 --> 00:25:47,360
one is doing something interesting the

00:25:46,240 --> 00:25:49,039
rest of them are in p

00:25:47,360 --> 00:25:50,799
thread can't wait they're waiting on

00:25:49,039 --> 00:25:51,440
some p threat condition and one of them

00:25:50,799 --> 00:25:54,559
is stuck

00:25:51,440 --> 00:25:55,039
in read now read is a blocking system

00:25:54,559 --> 00:25:57,360
call

00:25:55,039 --> 00:25:58,720
meaning when you call read you will not

00:25:57,360 --> 00:25:59,360
return until you get the results of the

00:25:58,720 --> 00:26:01,679
read

00:25:59,360 --> 00:26:03,200
so that's interesting to follow up that

00:26:01,679 --> 00:26:06,080
could be a reason why it's hanging

00:26:03,200 --> 00:26:08,400
what is the read blocking on so we'll

00:26:06,080 --> 00:26:11,840
switch to thread number three

00:26:08,400 --> 00:26:14,960
the one that was uh blocked and

00:26:11,840 --> 00:26:15,279
um see what's going on now you see this

00:26:14,960 --> 00:26:18,320
is

00:26:15,279 --> 00:26:20,240
in the loop p thread implementation that

00:26:18,320 --> 00:26:22,000
is not compiled with debug symbols so it

00:26:20,240 --> 00:26:25,679
can't tell us which

00:26:22,000 --> 00:26:28,880
registers um or sorry which uh

00:26:25,679 --> 00:26:31,279
what the what the arguments sorry

00:26:28,880 --> 00:26:32,640
what the arguments for the read call

00:26:31,279 --> 00:26:36,640
currently are

00:26:32,640 --> 00:26:36,640
however we could um

00:26:37,279 --> 00:26:40,559
oh i have a question how do we know it's

00:26:38,880 --> 00:26:41,840
stuck and read well the reason we don't

00:26:40,559 --> 00:26:43,120
really know a second read but we can

00:26:41,840 --> 00:26:45,840
look at things that

00:26:43,120 --> 00:26:47,600
we think it could be stuck in lab 64 is

00:26:45,840 --> 00:26:50,080
the only other function here that's

00:26:47,600 --> 00:26:50,840
not the thread count weight and glove64

00:26:50,080 --> 00:26:53,919
is a very

00:26:50,840 --> 00:26:55,440
simple function so that

00:26:53,919 --> 00:26:57,919
doesn't seem to be something that would

00:26:55,440 --> 00:27:00,000
be stuck in read is the only

00:26:57,919 --> 00:27:02,720
function here that should take any

00:27:00,000 --> 00:27:02,720
amount of time

00:27:04,000 --> 00:27:07,440
so if you look at read what you can do

00:27:05,760 --> 00:27:09,279
is you can type info registers when a

00:27:07,440 --> 00:27:11,120
core dump is generated it also dumps all

00:27:09,279 --> 00:27:13,360
the registers at the time

00:27:11,120 --> 00:27:15,360
and if you look at the wikipedia page

00:27:13,360 --> 00:27:18,080
for the x86 calling conventions

00:27:15,360 --> 00:27:20,320
it will tell you which registers are

00:27:18,080 --> 00:27:21,440
used in a system call or actually in any

00:27:20,320 --> 00:27:24,080
function call

00:27:21,440 --> 00:27:25,360
i've highlighted them here in green blue

00:27:24,080 --> 00:27:28,720
and purple

00:27:25,360 --> 00:27:30,000
and it read takes three arguments and if

00:27:28,720 --> 00:27:31,760
we look at the registers of those

00:27:30,000 --> 00:27:34,480
arguments in that thread

00:27:31,760 --> 00:27:35,039
the green one rdi is zero the blue one

00:27:34,480 --> 00:27:37,520
the second

00:27:35,039 --> 00:27:38,880
argument is some pointer and the purple

00:27:37,520 --> 00:27:41,919
one

00:27:38,880 --> 00:27:43,679
our dx is four so that corresponds to

00:27:41,919 --> 00:27:45,919
file descriptor zero

00:27:43,679 --> 00:27:46,799
some pointer to a buffer and a count of

00:27:45,919 --> 00:27:48,640
four

00:27:46,799 --> 00:27:50,000
and in fact application does have a read

00:27:48,640 --> 00:27:51,520
of four bytes but

00:27:50,000 --> 00:27:54,799
it's supposed to be reading from a

00:27:51,520 --> 00:27:57,039
socket but file descriptor zero

00:27:54,799 --> 00:27:58,320
is standard in and that's a good

00:27:57,039 --> 00:28:00,080
explanation of

00:27:58,320 --> 00:28:02,240
why it's waiting it's waiting for input

00:28:00,080 --> 00:28:04,799
and standard in which is not actually

00:28:02,240 --> 00:28:07,360
connected to anything this is a offline

00:28:04,799 --> 00:28:07,360
application

00:28:08,240 --> 00:28:13,120
so looking at our server it turns out

00:28:11,200 --> 00:28:15,520
what happened was on this

00:28:13,120 --> 00:28:17,679
in this application which is a server

00:28:15,520 --> 00:28:21,279
there was a cleanup function

00:28:17,679 --> 00:28:23,840
that closed the socket and

00:28:21,279 --> 00:28:24,880
a different thread that was in a loop

00:28:23,840 --> 00:28:26,960
and waiting for

00:28:24,880 --> 00:28:28,559
the thread to exit every time in through

00:28:26,960 --> 00:28:30,320
the loop it would do a read

00:28:28,559 --> 00:28:32,399
if the read returns an error it would

00:28:30,320 --> 00:28:32,960
exit otherwise it will go and process

00:28:32,399 --> 00:28:35,120
the data

00:28:32,960 --> 00:28:36,799
and basically there was a race condition

00:28:35,120 --> 00:28:38,559
on exit

00:28:36,799 --> 00:28:40,320
if you close the socket and then cleaned

00:28:38,559 --> 00:28:43,279
up the c plus plus object

00:28:40,320 --> 00:28:43,279
the m socket

00:28:43,440 --> 00:28:46,720
variable could then be reused by

00:28:45,200 --> 00:28:49,840
something else

00:28:46,720 --> 00:28:51,039
the thread that was looping will then

00:28:49,840 --> 00:28:54,640
use the m socket

00:28:51,039 --> 00:28:57,039
it turns out that something set after

00:28:54,640 --> 00:28:58,240
the main thread exited something you

00:28:57,039 --> 00:29:02,000
reuse the memory

00:28:58,240 --> 00:29:04,480
and set the m socket variable to zero

00:29:02,000 --> 00:29:06,320
which is just some garbage value and the

00:29:04,480 --> 00:29:07,760
read from any other garbage value would

00:29:06,320 --> 00:29:10,799
have returned an error right away

00:29:07,760 --> 00:29:12,799
and the reader thread would have exited

00:29:10,799 --> 00:29:14,320
however a read from zero from standard

00:29:12,799 --> 00:29:15,840
in would get stuck

00:29:14,320 --> 00:29:19,360
waiting for somebody to type something

00:29:15,840 --> 00:29:19,360
in on the console

00:29:19,520 --> 00:29:23,279
the fix here was easy was the two green

00:29:22,080 --> 00:29:27,039
lines that added

00:29:23,279 --> 00:29:30,159
an exit flag and a wait for the

00:29:27,039 --> 00:29:30,159
reader thread to exit

00:29:30,320 --> 00:29:33,600
so i promise they talk a little bit

00:29:32,000 --> 00:29:36,080
about wireshark

00:29:33,600 --> 00:29:37,919
i'll try to get a little bit of that in

00:29:36,080 --> 00:29:40,320
wireshark is great at debugging any sort

00:29:37,919 --> 00:29:42,000
of network events when you have

00:29:40,320 --> 00:29:43,360
anything you have to dump with a network

00:29:42,000 --> 00:29:46,480
you have to do with the network

00:29:43,360 --> 00:29:49,679
you can use tcp dump which uses which

00:29:46,480 --> 00:29:50,960
is a command line tool to gather

00:29:49,679 --> 00:29:53,279
network packets and then you can

00:29:50,960 --> 00:29:55,440
visualize them with wireshark

00:29:53,279 --> 00:29:56,880
keep in mind that the language to

00:29:55,440 --> 00:29:58,320
specify what you're capturing is

00:29:56,880 --> 00:29:59,039
slightly different for tcp dump and

00:29:58,320 --> 00:30:01,120
wireshark

00:29:59,039 --> 00:30:02,720
and in fact wireshark uses the same

00:30:01,120 --> 00:30:04,399
little pcap which is the underlying

00:30:02,720 --> 00:30:06,000
library that tcp dump uses so the

00:30:04,399 --> 00:30:07,120
capture language and wireshark is also

00:30:06,000 --> 00:30:10,559
going to be different

00:30:07,120 --> 00:30:13,279
than the filtering language for viewing

00:30:10,559 --> 00:30:15,120
so you could do a man 7 and pcap filter

00:30:13,279 --> 00:30:16,880
that's for capturing and then for

00:30:15,120 --> 00:30:18,559
wireshark filter that's for

00:30:16,880 --> 00:30:19,840
viewing they're very similar but

00:30:18,559 --> 00:30:21,520
slightly different as you can see in the

00:30:19,840 --> 00:30:23,679
slides

00:30:21,520 --> 00:30:25,600
but you can capture a specific port than

00:30:23,679 --> 00:30:27,200
a specific host

00:30:25,600 --> 00:30:28,880
and then analyze it later you want to

00:30:27,200 --> 00:30:30,720
capture as much as you can without

00:30:28,880 --> 00:30:32,799
overwhelming the network without

00:30:30,720 --> 00:30:34,880
it overwhelming the kernel sorry when

00:30:32,799 --> 00:30:36,799
it's uh capturing all the packets so it

00:30:34,880 --> 00:30:39,200
doesn't drop packets

00:30:36,799 --> 00:30:40,720
and then you can analyze later to see

00:30:39,200 --> 00:30:42,799
what you see

00:30:40,720 --> 00:30:43,840
conveniently wireshark when you open it

00:30:42,799 --> 00:30:45,520
it's a nice gui

00:30:43,840 --> 00:30:46,960
it'll break down all the packets for you

00:30:45,520 --> 00:30:48,399
and show you in different colors

00:30:46,960 --> 00:30:50,080
all the various things you can follow

00:30:48,399 --> 00:30:52,559
tcp streams even

00:30:50,080 --> 00:30:53,679
we could give you the whole conversation

00:30:52,559 --> 00:30:55,919
so over here

00:30:53,679 --> 00:30:57,120
i'm not sure if anybody can see it's

00:30:55,919 --> 00:30:58,880
pretty busy

00:30:57,120 --> 00:31:00,960
but uh the idea is you want to look for

00:30:58,880 --> 00:31:01,679
the red red and black things are the

00:31:00,960 --> 00:31:05,760
errors

00:31:01,679 --> 00:31:07,840
so over here there's a get of a http get

00:31:05,760 --> 00:31:08,320
which wireshark conveniently decodes and

00:31:07,840 --> 00:31:11,600
prints

00:31:08,320 --> 00:31:14,559
over here circled in blue

00:31:11,600 --> 00:31:16,080
and then a few times later we see a tcp

00:31:14,559 --> 00:31:18,640
retransmission

00:31:16,080 --> 00:31:19,360
so it's highlighted by wireshark and

00:31:18,640 --> 00:31:22,399
i've

00:31:19,360 --> 00:31:24,880
put a little red

00:31:22,399 --> 00:31:26,480
highlight around it basically when you

00:31:24,880 --> 00:31:28,159
see a tcp or transmission that means the

00:31:26,480 --> 00:31:31,200
previous packet was lost

00:31:28,159 --> 00:31:33,840
so um we see there's packet loss on this

00:31:31,200 --> 00:31:33,840
link

00:31:34,000 --> 00:31:39,039
finally a word about hardware debugging

00:31:37,279 --> 00:31:40,480
again observability is what you really

00:31:39,039 --> 00:31:43,519
really want if you're debugging

00:31:40,480 --> 00:31:45,679
i squared c pcie any sort of usb any

00:31:43,519 --> 00:31:48,799
sort of

00:31:45,679 --> 00:31:49,360
hardware interface you want to get the

00:31:48,799 --> 00:31:51,519
tool

00:31:49,360 --> 00:31:52,880
that can give you visibility on that

00:31:51,519 --> 00:31:54,640
hardware interface

00:31:52,880 --> 00:31:57,200
for i squared c i've listed several

00:31:54,640 --> 00:32:00,640
debuggers saily or beagle analyzers

00:31:57,200 --> 00:32:02,640
are all good usb a little known fact is

00:32:00,640 --> 00:32:05,919
that wireshark can actually

00:32:02,640 --> 00:32:07,679
uh display usb traffic and you can snoop

00:32:05,919 --> 00:32:09,600
traffic on the usb bus

00:32:07,679 --> 00:32:10,720
with the following commands you do mod

00:32:09,600 --> 00:32:13,600
probe usb mon

00:32:10,720 --> 00:32:14,640
and then tcp dump and the interface is

00:32:13,600 --> 00:32:17,600
going to be usb 1

00:32:14,640 --> 00:32:18,720
1 2 3 or 5 depending on the number of

00:32:17,600 --> 00:32:20,159
your usb bus

00:32:18,720 --> 00:32:22,080
so your computer can actually snoop

00:32:20,159 --> 00:32:24,480
traffic on the usb bus

00:32:22,080 --> 00:32:25,440
output into a file like a regular tcp

00:32:24,480 --> 00:32:27,840
dump

00:32:25,440 --> 00:32:29,760
on the network it could just dump usb

00:32:27,840 --> 00:32:33,360
packets and wireshark supports

00:32:29,760 --> 00:32:36,000
looking at those packets afterwards

00:32:33,360 --> 00:32:37,360
if you're using pcie or nvme sata any

00:32:36,000 --> 00:32:40,480
sort of high-speed interface

00:32:37,360 --> 00:32:43,120
you can use a logic protocol analyzer

00:32:40,480 --> 00:32:44,000
lacroix makes great protocol analyzers

00:32:43,120 --> 00:32:47,039
for pcie

00:32:44,000 --> 00:32:49,919
i've used them they're super useful also

00:32:47,039 --> 00:32:49,919
super expensive

00:32:50,240 --> 00:32:55,360
um so i'll give one example of a

00:32:53,679 --> 00:32:58,640
hardware debugger

00:32:55,360 --> 00:33:00,799
so we had a xilinx fpga that was

00:32:58,640 --> 00:33:03,760
controlling an i squared c bus

00:33:00,799 --> 00:33:05,360
once every several days in production we

00:33:03,760 --> 00:33:06,159
would have devices that would just stop

00:33:05,360 --> 00:33:09,440
responding

00:33:06,159 --> 00:33:11,760
and we didn't know what was going on so

00:33:09,440 --> 00:33:13,200
the one step was to reproduce and figure

00:33:11,760 --> 00:33:14,480
out what the heck is going on in this

00:33:13,200 --> 00:33:16,640
ice cream c bus

00:33:14,480 --> 00:33:18,240
so we increased the polling frequency of

00:33:16,640 --> 00:33:20,080
our temperature sensors and so forth

00:33:18,240 --> 00:33:23,279
that were on iceberg sea bus

00:33:20,080 --> 00:33:25,360
and uh to sense them every second um

00:33:23,279 --> 00:33:26,960
every sorry tenth of a second instead of

00:33:25,360 --> 00:33:28,640
every 10 seconds so that increased the

00:33:26,960 --> 00:33:31,200
probability of hitting the air

00:33:28,640 --> 00:33:32,399
about 100 times now we got hangs like

00:33:31,200 --> 00:33:34,880
every few minutes

00:33:32,399 --> 00:33:36,240
and we can actually reproduce this in

00:33:34,880 --> 00:33:39,840
the lab and attach a

00:33:36,240 --> 00:33:41,760
i squared c analyzer or a logic analyzer

00:33:39,840 --> 00:33:44,000
to this

00:33:41,760 --> 00:33:46,559
uh we couldn't get visibility into the

00:33:44,000 --> 00:33:48,399
xilinx fpga because the ip block was

00:33:46,559 --> 00:33:50,159
encrypted

00:33:48,399 --> 00:33:51,600
so we used an external logic analyzer

00:33:50,159 --> 00:33:52,960
and just hooked the probes onto the

00:33:51,600 --> 00:33:54,559
wires of a square t-bus

00:33:52,960 --> 00:33:56,799
and i squared c is slow enough that you

00:33:54,559 --> 00:33:58,960
could do this on a regular analyzer

00:33:56,799 --> 00:34:00,480
now this is not the capture from the

00:33:58,960 --> 00:34:02,000
actual analyzer that we took

00:34:00,480 --> 00:34:04,240
but this is a very similar problem i

00:34:02,000 --> 00:34:06,480
found online

00:34:04,240 --> 00:34:08,079
so on the top in yellow you could see

00:34:06,480 --> 00:34:10,560
the clock the clock

00:34:08,079 --> 00:34:11,679
is uh one the dice party has two lines

00:34:10,560 --> 00:34:13,520
clock and data

00:34:11,679 --> 00:34:14,720
basically clock will always clog up down

00:34:13,520 --> 00:34:17,040
up down and down

00:34:14,720 --> 00:34:21,839
and the data will be ones or zeros as

00:34:17,040 --> 00:34:21,839
you can see on the green at the bottom

00:34:22,560 --> 00:34:28,800
so if you look at the zoom region that

00:34:26,879 --> 00:34:31,359
highlighted in red

00:34:28,800 --> 00:34:32,480
as the clock here is rising pretty

00:34:31,359 --> 00:34:34,720
slowly

00:34:32,480 --> 00:34:36,320
and as it rises past the threshold of

00:34:34,720 --> 00:34:38,000
where it switches from the clock

00:34:36,320 --> 00:34:40,240
switches from a zero to a one

00:34:38,000 --> 00:34:41,839
there's a little glitch there you could

00:34:40,240 --> 00:34:44,800
kind of see where

00:34:41,839 --> 00:34:47,040
it glitches past now if your device and

00:34:44,800 --> 00:34:49,520
a lot of spirit devices are supposed to

00:34:47,040 --> 00:34:51,440
unbleach this they're supposed to allow

00:34:49,520 --> 00:34:54,399
for slow rise times but

00:34:51,440 --> 00:34:56,320
not all of them really do if you see

00:34:54,399 --> 00:34:58,800
glitches on your clock line

00:34:56,320 --> 00:35:00,000
like this you could get an extra clock

00:34:58,800 --> 00:35:01,839
cycle detected

00:35:00,000 --> 00:35:03,280
by your hardware so your hardware thinks

00:35:01,839 --> 00:35:05,200
that another clock

00:35:03,280 --> 00:35:06,880
has been issued on the bus and then

00:35:05,200 --> 00:35:08,960
everything is off by one

00:35:06,880 --> 00:35:10,400
because the thing that's sending the

00:35:08,960 --> 00:35:12,720
right square c signal

00:35:10,400 --> 00:35:14,240
thinks that it's only clocked once and

00:35:12,720 --> 00:35:16,640
the thing receiving it thinks that

00:35:14,240 --> 00:35:18,480
things got clocked twice and everything

00:35:16,640 --> 00:35:20,560
breaks

00:35:18,480 --> 00:35:22,160
once we saw this there was a very easy

00:35:20,560 --> 00:35:23,520
solution which is to put more pull-up

00:35:22,160 --> 00:35:26,480
resistors on the bus

00:35:23,520 --> 00:35:28,720
to increase the rise time there's a good

00:35:26,480 --> 00:35:30,800
link here from debugging squad c from

00:35:28,720 --> 00:35:34,480
texas instruments that

00:35:30,800 --> 00:35:36,160
discusses similar problems to this

00:35:34,480 --> 00:35:37,839
so again the point of this is you want

00:35:36,160 --> 00:35:40,320
as much observability

00:35:37,839 --> 00:35:41,920
on the busts that you're developing as

00:35:40,320 --> 00:35:43,280
you can we would have never caught this

00:35:41,920 --> 00:35:44,560
just in software without actually

00:35:43,280 --> 00:35:47,520
looking at the

00:35:44,560 --> 00:35:47,520
logic analyzer

00:35:47,839 --> 00:35:52,640
so that's all i got in the time allotted

00:35:51,040 --> 00:35:55,839
and now let me try to go through some

00:35:52,640 --> 00:35:57,520
questions that we had i think i answered

00:35:55,839 --> 00:36:00,720
some of them but uh

00:35:57,520 --> 00:36:03,440
we'll go through some of them

00:36:00,720 --> 00:36:06,160
so i'm not sorry advanced famous

00:36:03,440 --> 00:36:06,160
pronounce your name

00:36:07,119 --> 00:36:10,560
so let's see here

00:36:11,119 --> 00:36:16,960
uh we have some comments from

00:36:13,730 --> 00:36:16,960
[Music]

00:36:17,040 --> 00:36:24,560
a second okay are the slides going to be

00:36:20,560 --> 00:36:24,560
available yes we'll post the slides

00:36:24,839 --> 00:36:27,839
um

00:36:28,240 --> 00:36:32,640
uh so there's a comment that's saying

00:36:30,880 --> 00:36:35,839
that from steve

00:36:32,640 --> 00:36:38,839
um that a cert is actually

00:36:35,839 --> 00:36:40,480
really easy to use and it doesn't really

00:36:38,839 --> 00:36:44,320
provide a

00:36:40,480 --> 00:36:47,680
runtime cost because it compiles away in

00:36:44,320 --> 00:36:50,400
a release build that's a very good

00:36:47,680 --> 00:36:50,400
point to make

00:36:51,440 --> 00:36:54,560
if you have a release build where you

00:36:53,359 --> 00:36:56,960
really want this cert

00:36:54,560 --> 00:36:58,400
to keep your certain release build you

00:36:56,960 --> 00:36:59,920
want to have your own

00:36:58,400 --> 00:37:02,800
implementation of assert that won't get

00:36:59,920 --> 00:37:06,160
compiled away in the release build

00:37:02,800 --> 00:37:08,000
um how does leandro asks how does llvm

00:37:06,160 --> 00:37:09,440
clan compare the gcc in terms of

00:37:08,000 --> 00:37:12,720
debugging

00:37:09,440 --> 00:37:16,400
it gdb supports solo vm

00:37:12,720 --> 00:37:20,160
clang i think i think there is

00:37:16,400 --> 00:37:21,680
basically no difference in lvm clang but

00:37:20,160 --> 00:37:23,599
i could be wrong i don't have that much

00:37:21,680 --> 00:37:25,520
experience with llvm

00:37:23,599 --> 00:37:27,040
um steve also points out that there's

00:37:25,520 --> 00:37:30,240
other useful warnings from

00:37:27,040 --> 00:37:32,800
gcc like uh w shadow

00:37:30,240 --> 00:37:33,359
and wl doesn't turn them all on that's

00:37:32,800 --> 00:37:36,560
true

00:37:33,359 --> 00:37:37,359
um wol is basically a good starting

00:37:36,560 --> 00:37:39,200
point

00:37:37,359 --> 00:37:41,280
it'll turn on most of the warnings that

00:37:39,200 --> 00:37:42,000
you care about there are other warnings

00:37:41,280 --> 00:37:43,520
you might be

00:37:42,000 --> 00:37:46,880
more pedantic about and there's also

00:37:43,520 --> 00:37:48,720
other code coverage tools like coverity

00:37:46,880 --> 00:37:50,400
and other tools that you could use to do

00:37:48,720 --> 00:37:50,960
static analysis on your code that could

00:37:50,400 --> 00:37:56,079
catch

00:37:50,960 --> 00:37:56,079
a bit more things uh

00:37:56,640 --> 00:38:01,200
locken i think sorry

00:37:59,760 --> 00:38:03,280
asks if i can elaborate on reverse

00:38:01,200 --> 00:38:06,880
debugging so reverse debugging

00:38:03,280 --> 00:38:08,800
is um basically it will allow you to

00:38:06,880 --> 00:38:10,560
step your program backwards it

00:38:08,800 --> 00:38:13,200
as your program executes it records

00:38:10,560 --> 00:38:16,160
state of basically how everything was

00:38:13,200 --> 00:38:17,760
and then you can you can step backwards

00:38:16,160 --> 00:38:21,359
so instead of doing next in gtb

00:38:17,760 --> 00:38:24,160
the previous it'll step back in time

00:38:21,359 --> 00:38:25,280
this does incur a cost because it has to

00:38:24,160 --> 00:38:27,680
record the

00:38:25,280 --> 00:38:29,280
state of your program at every point and

00:38:27,680 --> 00:38:30,960
it can't undo things like

00:38:29,280 --> 00:38:32,960
packets you send in the network you can

00:38:30,960 --> 00:38:34,320
take those back i'm not sure if it can

00:38:32,960 --> 00:38:36,960
then do file rights

00:38:34,320 --> 00:38:38,560
that also seems difficult in practice i

00:38:36,960 --> 00:38:40,720
really haven't found it to be super

00:38:38,560 --> 00:38:44,079
useful

00:38:40,720 --> 00:38:47,280
uh braha

00:38:44,079 --> 00:38:48,000
rafa dumball sorry if i mispronounced

00:38:47,280 --> 00:38:50,400
your name

00:38:48,000 --> 00:38:51,839
asks will g-core work even when the

00:38:50,400 --> 00:38:54,320
process is hung

00:38:51,839 --> 00:38:54,960
uh yes g-core will work even if your

00:38:54,320 --> 00:38:57,359
process

00:38:54,960 --> 00:38:58,240
is hung in fact that's very useful um if

00:38:57,359 --> 00:39:00,400
your process is

00:38:58,240 --> 00:39:01,920
however you can cause you can just

00:39:00,400 --> 00:39:03,680
attach to it with gdp

00:39:01,920 --> 00:39:07,520
directly you don't need to take a cordon

00:39:03,680 --> 00:39:07,520
but if you do need to you can use g4

00:39:07,920 --> 00:39:14,400
um gavin asks i experience rare

00:39:11,359 --> 00:39:15,760
3 memory corruption that is caused by a

00:39:14,400 --> 00:39:17,680
task race condition on the mips

00:39:15,760 --> 00:39:18,400
processor is there a good case for gdb

00:39:17,680 --> 00:39:21,760
server

00:39:18,400 --> 00:39:21,760
and hardware watch points

00:39:22,240 --> 00:39:25,680
yes if you have memory correction watch

00:39:24,320 --> 00:39:27,119
points are great

00:39:25,680 --> 00:39:29,839
make sure that your hardware again

00:39:27,119 --> 00:39:32,960
supports watch points because

00:39:29,839 --> 00:39:34,400
your uh otherwise you're going to impact

00:39:32,960 --> 00:39:37,680
the timing and your program will

00:39:34,400 --> 00:39:39,440
run really slowly

00:39:37,680 --> 00:39:41,520
you could you don't need gdb server if

00:39:39,440 --> 00:39:43,200
you can run gdb natively on the target

00:39:41,520 --> 00:39:44,560
if your target again is too small then

00:39:43,200 --> 00:39:46,880
you want to run your

00:39:44,560 --> 00:39:48,480
program under ggb server and then use a

00:39:46,880 --> 00:39:50,480
gdp client to connect to it

00:39:48,480 --> 00:39:52,079
and then it'll work just like regular

00:39:50,480 --> 00:39:53,680
gdp then in the client

00:39:52,079 --> 00:39:57,040
there's just a bunch of setup that you

00:39:53,680 --> 00:39:59,359
have to do

00:39:57,040 --> 00:39:59,359
um

00:40:00,480 --> 00:40:04,160
f hamson asks what correlates the two

00:40:02,880 --> 00:40:07,839
log entries i think

00:40:04,160 --> 00:40:11,520
you're referring to the tcp

00:40:07,839 --> 00:40:13,040
entries here i think what correlates

00:40:11,520 --> 00:40:14,319
them is you have to look at the

00:40:13,040 --> 00:40:17,359
addresses

00:40:14,319 --> 00:40:17,920
of the sender and the receiver so look

00:40:17,359 --> 00:40:20,800
at the

00:40:17,920 --> 00:40:21,680
ip address of the source and the

00:40:20,800 --> 00:40:25,119
destination

00:40:21,680 --> 00:40:28,319
and the port so basically your tuple in

00:40:25,119 --> 00:40:30,079
tcp is your source destination source

00:40:28,319 --> 00:40:33,119
port and destination port

00:40:30,079 --> 00:40:34,000
and those those are going to define a

00:40:33,119 --> 00:40:35,920
connection

00:40:34,000 --> 00:40:37,599
and wireshark can also filter you could

00:40:35,920 --> 00:40:38,640
just like right click on any one of

00:40:37,599 --> 00:40:40,800
these

00:40:38,640 --> 00:40:42,640
entries and say follow tcp stream and

00:40:40,800 --> 00:40:44,800
then it'll only give you packets

00:40:42,640 --> 00:40:46,880
that correspond to those particular

00:40:44,800 --> 00:40:51,920
posts in that particular

00:40:46,880 --> 00:40:52,319
combination particular tcp conversation

00:40:51,920 --> 00:40:55,040
joe

00:40:52,319 --> 00:40:57,520
asks does any packet sniffer support io

00:40:55,040 --> 00:41:01,200
on windows

00:40:57,520 --> 00:41:02,560
um i don't know

00:41:01,200 --> 00:41:07,599
i honestly don't know i don't have that

00:41:02,560 --> 00:41:11,040
much windows experience i'm sorry uh

00:41:07,599 --> 00:41:14,480
shiva marthy asks am i covering f trace

00:41:11,040 --> 00:41:16,880
um i am not in this talk but there is

00:41:14,480 --> 00:41:18,640
uh lots of great resources uh you could

00:41:16,880 --> 00:41:20,160
look on brendan greg's website like i

00:41:18,640 --> 00:41:24,160
mentioned before

00:41:20,160 --> 00:41:25,760
or you can you can you can um

00:41:24,160 --> 00:41:27,280
just google it there was a good talk

00:41:25,760 --> 00:41:29,839
yesterday

00:41:27,280 --> 00:41:30,480
on the debugging gdp tutorial that

00:41:29,839 --> 00:41:33,200
covered

00:41:30,480 --> 00:41:34,400
f trace as well if there's going to be a

00:41:33,200 --> 00:41:37,200
uh

00:41:34,400 --> 00:41:38,000
um like an offline way to watch it i

00:41:37,200 --> 00:41:42,079
would suggest

00:41:38,000 --> 00:41:44,000
watching that uh

00:41:42,079 --> 00:41:45,920
funkage asks why were the glitches in

00:41:44,000 --> 00:41:48,079
scl line occurring so this is

00:41:45,920 --> 00:41:49,599
in a nice currency basically the more

00:41:48,079 --> 00:41:53,760
devices and iceberg c

00:41:49,599 --> 00:41:56,319
is a passive bus the active device

00:41:53,760 --> 00:41:58,319
pulls down the line and then when it's

00:41:56,319 --> 00:42:00,640
not using the line it lets go

00:41:58,319 --> 00:42:03,440
of the line and lets it float back up to

00:42:00,640 --> 00:42:04,800
uh to its full voltage that's why

00:42:03,440 --> 00:42:06,000
the resistors on those lines are called

00:42:04,800 --> 00:42:08,240
pull up resistors because they're

00:42:06,000 --> 00:42:11,359
pulling the voltage back up from zero

00:42:08,240 --> 00:42:13,760
to um uh to the

00:42:11,359 --> 00:42:14,960
line voltage the more devices you put on

00:42:13,760 --> 00:42:16,560
there the more

00:42:14,960 --> 00:42:18,079
the more capacitance there is in the

00:42:16,560 --> 00:42:21,119
line and the slower

00:42:18,079 --> 00:42:23,680
it will take to read to get back

00:42:21,119 --> 00:42:24,640
from voltage of zero to your desired

00:42:23,680 --> 00:42:28,000
voltage

00:42:24,640 --> 00:42:29,440
um so you need a lower resistance on the

00:42:28,000 --> 00:42:32,560
line basically

00:42:29,440 --> 00:42:33,760
to pull it up quicker this happens quite

00:42:32,560 --> 00:42:36,079
a lot

00:42:33,760 --> 00:42:37,839
in iceberg t buses there is different

00:42:36,079 --> 00:42:40,800
solutions that are discussed in that

00:42:37,839 --> 00:42:40,800
ti document

00:42:43,359 --> 00:42:46,640
he also says the drive strength of gpio

00:42:45,280 --> 00:42:50,400
could have changed the rise time

00:42:46,640 --> 00:42:53,359
that's true um however again the

00:42:50,400 --> 00:42:54,400
the uh iceberg c is driven low not

00:42:53,359 --> 00:42:56,880
driven high

00:42:54,400 --> 00:42:59,200
so your drive strength would have caused

00:42:56,880 --> 00:42:59,839
the second but the drop-off line to be

00:42:59,200 --> 00:43:01,599
slower

00:42:59,839 --> 00:43:05,040
here the drop-off line is pretty fast

00:43:01,599 --> 00:43:05,040
but the rise time is pretty slow

00:43:05,280 --> 00:43:10,839
uh rachel asks do i use fault injection

00:43:07,839 --> 00:43:13,200
testing to support debugging

00:43:10,839 --> 00:43:16,319
um yes there um

00:43:13,200 --> 00:43:18,480
in fact the the tcp error

00:43:16,319 --> 00:43:19,440
here was done using fault injection

00:43:18,480 --> 00:43:21,520
testing

00:43:19,440 --> 00:43:22,720
i find doc docker containers are super

00:43:21,520 --> 00:43:24,800
useful for this

00:43:22,720 --> 00:43:26,720
you can start things up in a docker

00:43:24,800 --> 00:43:28,960
container and

00:43:26,720 --> 00:43:30,480
cause it to drop packets you can cause

00:43:28,960 --> 00:43:33,760
it to

00:43:30,480 --> 00:43:35,839
power off the machine entirely or to

00:43:33,760 --> 00:43:37,200
hang it or to hold it or to cause all

00:43:35,839 --> 00:43:39,680
sorts of errors

00:43:37,200 --> 00:43:42,160
they are a bit messy and annoying to set

00:43:39,680 --> 00:43:44,160
up and they're not super useful on

00:43:42,160 --> 00:43:45,680
embedded systems because it's kind of

00:43:44,160 --> 00:43:46,880
hard to set up a docker container for a

00:43:45,680 --> 00:43:49,119
different architecture

00:43:46,880 --> 00:43:50,880
on the host architecture but if you're

00:43:49,119 --> 00:43:53,359
debugging in the same architecture

00:43:50,880 --> 00:43:54,720
i think containers are super useful for

00:43:53,359 --> 00:43:58,400
false injection

00:43:54,720 --> 00:44:00,960
testing jorge asks how do you analyze a

00:43:58,400 --> 00:44:00,960
core dump

00:44:01,920 --> 00:44:08,000
so basically what a core dump does is

00:44:05,520 --> 00:44:10,560
it it takes a snapshot in time and then

00:44:08,000 --> 00:44:12,800
when you run gdb you run gdb

00:44:10,560 --> 00:44:14,000
your program and the core dump and the

00:44:12,800 --> 00:44:15,920
gdb

00:44:14,000 --> 00:44:17,920
will load up your program as though it

00:44:15,920 --> 00:44:19,440
was instantiated at that point in time

00:44:17,920 --> 00:44:20,880
when the core dump was taken

00:44:19,440 --> 00:44:22,400
and then you can look at the registers

00:44:20,880 --> 00:44:23,359
you could look at memory you can't

00:44:22,400 --> 00:44:25,599
advance

00:44:23,359 --> 00:44:27,200
time because it's just again a snapshot

00:44:25,599 --> 00:44:28,880
in time but you can use a

00:44:27,200 --> 00:44:30,640
look at the current state of the entire

00:44:28,880 --> 00:44:31,520
program and examine all the variables

00:44:30,640 --> 00:44:33,119
and

00:44:31,520 --> 00:44:34,960
registers and threads and what

00:44:33,119 --> 00:44:37,040
everything was going on

00:44:34,960 --> 00:44:38,319
on the time back traces will work it'll

00:44:37,040 --> 00:44:42,000
tell you like

00:44:38,319 --> 00:44:43,680
for each um thread you can see what the

00:44:42,000 --> 00:44:45,680
back trace is who called

00:44:43,680 --> 00:44:48,240
who and what your stack looks like at

00:44:45,680 --> 00:44:51,760
that point

00:44:48,240 --> 00:44:53,119
uh emile asks uh recommendations for

00:44:51,760 --> 00:44:55,200
tools for debugging multi-threaded

00:44:53,119 --> 00:44:57,839
applications well gdb is really good

00:44:55,200 --> 00:44:59,359
at threat support um if you have race

00:44:57,839 --> 00:45:02,720
conditions and things like that

00:44:59,359 --> 00:45:04,960
you can use uh valgrind and hellogrind

00:45:02,720 --> 00:45:06,640
helgren is a subset tool of valgrind

00:45:04,960 --> 00:45:08,400
that tries to detect race conditions in

00:45:06,640 --> 00:45:10,160
your code and it's generally pretty good

00:45:08,400 --> 00:45:12,640
it does slow down your code a lot by

00:45:10,160 --> 00:45:17,520
like 100 times because it's effectively

00:45:12,640 --> 00:45:17,520
oh it's almost like emulating the cpu

00:45:17,599 --> 00:45:21,680
jeremy asks are there any tools for

00:45:19,760 --> 00:45:24,319
debugging pc transactions besides the

00:45:21,680 --> 00:45:26,319
pcie analyzer

00:45:24,319 --> 00:45:27,680
um are there any tools that can record

00:45:26,319 --> 00:45:30,079
data in the past that could

00:45:27,680 --> 00:45:31,520
be seen by the root complex i'm not

00:45:30,079 --> 00:45:34,800
aware of anything

00:45:31,520 --> 00:45:38,160
you need a really fast snoop

00:45:34,800 --> 00:45:40,160
sort of capability to log what's going

00:45:38,160 --> 00:45:41,680
on in the pcie bus and most processors

00:45:40,160 --> 00:45:44,800
don't have

00:45:41,680 --> 00:45:47,680
that much that visibility into the

00:45:44,800 --> 00:45:48,000
pcie bus so other than a pci analyzer

00:45:47,680 --> 00:45:49,920
i'm

00:45:48,000 --> 00:45:51,280
not aware of anything that would capture

00:45:49,920 --> 00:45:55,200
all the transactions

00:45:51,280 --> 00:45:55,200
on a pcie bus unfortunately

00:45:58,640 --> 00:46:03,839
we have a question of uh thomas askgb

00:46:02,480 --> 00:46:06,000
has a lot of hidden power but there's

00:46:03,839 --> 00:46:06,480
very many accessible and clear resources

00:46:06,000 --> 00:46:08,079
for

00:46:06,480 --> 00:46:10,160
isn't very many accessible clear

00:46:08,079 --> 00:46:14,160
resource resources for discovering

00:46:10,160 --> 00:46:16,560
it um gdp has a super useful

00:46:14,160 --> 00:46:17,440
help interface so just typing help in

00:46:16,560 --> 00:46:19,760
gdb

00:46:17,440 --> 00:46:21,359
and then reusing the different sections

00:46:19,760 --> 00:46:21,920
that it gives you section on breakpoints

00:46:21,359 --> 00:46:24,240
and

00:46:21,920 --> 00:46:26,160
trace points and watch points are all

00:46:24,240 --> 00:46:28,400
really useful though the online manual

00:46:26,160 --> 00:46:30,480
is actually quite good

00:46:28,400 --> 00:46:31,920
i would also just check out the gdp

00:46:30,480 --> 00:46:35,280
documentation on the

00:46:31,920 --> 00:46:36,079
new website there's a good o'reilly book

00:46:35,280 --> 00:46:38,400
on gdp

00:46:36,079 --> 00:46:38,400
as well

00:46:40,800 --> 00:46:44,560
andreas asks is there any tool to dump

00:46:42,640 --> 00:46:46,560
and observe https traffic

00:46:44,560 --> 00:46:47,920
unfortunately because of the nature of

00:46:46,560 --> 00:46:49,520
https

00:46:47,920 --> 00:46:52,400
uh unless you capture it before it's

00:46:49,520 --> 00:46:54,960
encrypted there's really no good way to

00:46:52,400 --> 00:46:56,079
observe https it's supposed to be secure

00:46:54,960 --> 00:46:59,440
to prevent

00:46:56,079 --> 00:46:59,440
you from observing it

00:47:00,560 --> 00:47:03,839
orlan asks are there any tools with a

00:47:02,400 --> 00:47:06,079
gui on top of gdb

00:47:03,839 --> 00:47:07,359
yes there are several guise on top of

00:47:06,079 --> 00:47:10,319
gdb the

00:47:07,359 --> 00:47:12,000
most common one is dtd the data display

00:47:10,319 --> 00:47:12,880
debugger i believe it's pretty old and

00:47:12,000 --> 00:47:16,960
clunky but

00:47:12,880 --> 00:47:19,520
it it's workable uh eclipse supports gdp

00:47:16,960 --> 00:47:21,839
as a back-end so it can be a hdb gui

00:47:19,520 --> 00:47:22,640
microsoft visual studio code supports

00:47:21,839 --> 00:47:24,880
gdp

00:47:22,640 --> 00:47:26,559
and it can be the front the gui for gdp

00:47:24,880 --> 00:47:29,680
users so lots of tools

00:47:26,559 --> 00:47:32,160
uh support gdb on the back end

00:47:29,680 --> 00:47:33,760
uh you use your gdp text interface i

00:47:32,160 --> 00:47:35,440
just like to use the text interface but

00:47:33,760 --> 00:47:38,559
i know other people prefer

00:47:35,440 --> 00:47:39,359
the gui in fact gdb has a kind of gui

00:47:38,559 --> 00:47:42,960
text mode

00:47:39,359 --> 00:47:45,200
i think it's minus q um it shows you

00:47:42,960 --> 00:47:49,040
your program in like a curses window so

00:47:45,200 --> 00:47:50,960
it's a combination of text mode and gui

00:47:49,040 --> 00:47:53,200
andry asks do you recommend using

00:47:50,960 --> 00:47:57,440
debugging flags on production

00:47:53,200 --> 00:48:00,800
baseline calculations um i

00:47:57,440 --> 00:48:03,040
you should always do minus g

00:48:00,800 --> 00:48:04,240
that doesn't really add any time to your

00:48:03,040 --> 00:48:06,559
program

00:48:04,240 --> 00:48:07,599
it does add symbols so it adds a little

00:48:06,559 --> 00:48:11,119
bit in your

00:48:07,599 --> 00:48:13,280
image size um compiling with less

00:48:11,119 --> 00:48:15,040
optimization however

00:48:13,280 --> 00:48:17,119
will make it easier to debug because

00:48:15,040 --> 00:48:17,839
things will be more sane as you step

00:48:17,119 --> 00:48:20,960
through them

00:48:17,839 --> 00:48:22,160
but it will add a lot of you know it'll

00:48:20,960 --> 00:48:25,599
slow down your programs i don't

00:48:22,160 --> 00:48:25,599
recommend doing that in production

00:48:26,000 --> 00:48:28,319
um

00:48:31,119 --> 00:48:36,480
so legend asks is there um in general

00:48:35,119 --> 00:48:38,319
standpoint are there any formal

00:48:36,480 --> 00:48:41,440
techniques to debug a program

00:48:38,319 --> 00:48:44,800
uh like instead of test observe

00:48:41,440 --> 00:48:48,000
locate we can infer a bug for how a

00:48:44,800 --> 00:48:49,760
program was written formally

00:48:48,000 --> 00:48:52,480
there are there is some research about

00:48:49,760 --> 00:48:54,240
it i don't know if anybody who actually

00:48:52,480 --> 00:48:55,680
does this much there's basically static

00:48:54,240 --> 00:49:00,319
analysis tools that

00:48:55,680 --> 00:49:02,480
try to catch bugs

00:49:00,319 --> 00:49:04,400
basically this is a you know a way to

00:49:02,480 --> 00:49:06,880
write code that

00:49:04,400 --> 00:49:09,040
that's less buggy it's what probably

00:49:06,880 --> 00:49:11,200
you're looking for

00:49:09,040 --> 00:49:12,720
ah there is some research on that but

00:49:11,200 --> 00:49:13,119
it's beyond the scope of the stock as

00:49:12,720 --> 00:49:16,800
you've

00:49:13,119 --> 00:49:18,400
mentioned uh encore asks are there any

00:49:16,800 --> 00:49:19,359
recommendations about debugging linux

00:49:18,400 --> 00:49:22,400
kernel

00:49:19,359 --> 00:49:25,839
driver interrupt related issues

00:49:22,400 --> 00:49:29,119
uh kgdb which is built into

00:49:25,839 --> 00:49:30,800
the kernel is is useful uh the kernel

00:49:29,119 --> 00:49:33,200
generally provides

00:49:30,800 --> 00:49:34,800
um one interesting thing in debugging

00:49:33,200 --> 00:49:38,319
the kernel is there's a

00:49:34,800 --> 00:49:39,920
proc k core file um that will give you

00:49:38,319 --> 00:49:44,319
the current core and you can use

00:49:39,920 --> 00:49:47,040
if you have your linux build you can use

00:49:44,319 --> 00:49:48,559
you can use gdp to actually debug the

00:49:47,040 --> 00:49:50,319
live kernel

00:49:48,559 --> 00:49:52,000
you can't step through it obviously but

00:49:50,319 --> 00:49:54,160
you can look at the current

00:49:52,000 --> 00:49:55,599
effect of the core dump of the kernel

00:49:54,160 --> 00:49:58,240
and see what its

00:49:55,599 --> 00:49:59,760
state is or you can use the built-in

00:49:58,240 --> 00:50:02,160
kgdb

00:49:59,760 --> 00:50:04,720
tool i'm going to do one more question

00:50:02,160 --> 00:50:06,960
and then i think we're out of time

00:50:04,720 --> 00:50:06,960
um

00:50:09,760 --> 00:50:15,040
so asks

00:50:13,280 --> 00:50:16,640
in some cases the process may get hung

00:50:15,040 --> 00:50:18,079
in the kernel that could prevent user

00:50:16,640 --> 00:50:19,680
space down from either happening or

00:50:18,079 --> 00:50:21,200
completing a full kernel dump should be

00:50:19,680 --> 00:50:23,440
used in cases like that

00:50:21,200 --> 00:50:23,440
right

00:50:25,119 --> 00:50:28,800
uh that is a good point you can try to

00:50:28,000 --> 00:50:31,839
use the

00:50:28,800 --> 00:50:32,720
proc k core which gives you the uh the

00:50:31,839 --> 00:50:35,520
kernel

00:50:32,720 --> 00:50:36,240
core file well if you're if you're in a

00:50:35,520 --> 00:50:39,040
state where

00:50:36,240 --> 00:50:40,640
your kernel is fun it's pretty bad uh

00:50:39,040 --> 00:50:43,440
generally those watch

00:50:40,640 --> 00:50:44,000
but dogs effectively in the kernel that

00:50:43,440 --> 00:50:45,680
uh

00:50:44,000 --> 00:50:47,440
tasks that get scheduled periodically

00:50:45,680 --> 00:50:50,480
and will print out

00:50:47,440 --> 00:50:54,160
um back traces in your uh

00:50:50,480 --> 00:50:57,040
var log messages or warlock current

00:50:54,160 --> 00:50:58,400
for d message so all of those are kernel

00:50:57,040 --> 00:51:01,839
login

00:50:58,400 --> 00:51:03,680
locations um and

00:51:01,839 --> 00:51:05,839
you can you can try to analyze what

00:51:03,680 --> 00:51:06,880
happened for bugs and the draw in

00:51:05,839 --> 00:51:10,400
drivers

00:51:06,880 --> 00:51:13,920
and so forth so i think we're

00:51:10,400 --> 00:51:17,359
coming to the end a lot

00:51:13,920 --> 00:51:18,960
and time of the talk um

00:51:17,359 --> 00:51:21,440
if there is more questions i see there's

00:51:18,960 --> 00:51:24,960
a few more that i wasn't able to get to

00:51:21,440 --> 00:51:28,400
you can continue the conversation in

00:51:24,960 --> 00:51:31,200
slack there's a 2-track dash

00:51:28,400 --> 00:51:31,200
embedded linux

00:51:31,839 --> 00:51:37,680
track slack channel for this track

00:51:35,440 --> 00:51:38,720
where i'll i'll monitor it for a while

00:51:37,680 --> 00:51:41,920
and if anybody

00:51:38,720 --> 00:51:44,079
has specific questions they can ask me

00:51:41,920 --> 00:51:46,559
there

00:51:44,079 --> 00:51:47,119
thank you very much for attending i hope

00:51:46,559 --> 00:51:48,240
you

00:51:47,119 --> 00:51:50,800
learned something during this

00:51:48,240 --> 00:51:54,559
presentation and

00:51:50,800 --> 00:51:57,599
i hope to see everybody

00:51:54,559 --> 00:52:05,839
in a year from now at an actual

00:51:57,599 --> 00:52:05,839
in-person conference thank you very much

00:52:09,599 --> 00:52:11,680

YouTube URL: https://www.youtube.com/watch?v=kJMc_R5ZQZ8


