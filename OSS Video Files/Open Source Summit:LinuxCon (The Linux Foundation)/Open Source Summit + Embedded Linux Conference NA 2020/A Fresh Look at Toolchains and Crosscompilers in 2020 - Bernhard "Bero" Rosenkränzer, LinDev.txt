Title: A Fresh Look at Toolchains and Crosscompilers in 2020 - Bernhard "Bero" Rosenkränzer, LinDev
Publication date: 2020-09-08
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	A Fresh Look at Toolchains and Crosscompilers in 2020 - Bernhard "Bero" Rosenkränzer, LinDev
Captions: 
	00:00:06,319 --> 00:00:10,480
hello

00:00:07,200 --> 00:00:12,960
welcome to the session this is

00:00:10,480 --> 00:00:14,320
a little bit unusual i thought i'd be at

00:00:12,960 --> 00:00:17,279
the conference

00:00:14,320 --> 00:00:18,640
then everyone was told um it's going to

00:00:17,279 --> 00:00:20,800
be from home

00:00:18,640 --> 00:00:22,480
and then when i was prepared to do a

00:00:20,800 --> 00:00:24,240
conference session from home

00:00:22,480 --> 00:00:25,920
i got a call from my father that he

00:00:24,240 --> 00:00:27,920
needed me there so

00:00:25,920 --> 00:00:30,000
i'm actually doing this talk from my

00:00:27,920 --> 00:00:33,920
childhood bedroom which is

00:00:30,000 --> 00:00:36,160
kind of unusual but it's

00:00:33,920 --> 00:00:38,399
a good room actually related this is

00:00:36,160 --> 00:00:41,520
where i met my first computer

00:00:38,399 --> 00:00:41,520
and it's still around

00:00:42,000 --> 00:00:48,160
so this is very have my current computer

00:00:45,520 --> 00:00:51,520
and my first computer together for the

00:00:48,160 --> 00:00:51,520
first time in a long time

00:00:52,160 --> 00:00:55,680
yeah i guess most people who are

00:00:53,840 --> 00:00:59,840
interested should be in by now

00:00:55,680 --> 00:00:59,840
so we can get started

00:00:59,920 --> 00:01:03,199
this talk is obviously going to be about

00:01:02,320 --> 00:01:06,400
tool chains

00:01:03,199 --> 00:01:08,479
and cross compilers and what has changed

00:01:06,400 --> 00:01:10,000
because not everything is the same it

00:01:08,479 --> 00:01:13,840
used to be

00:01:10,000 --> 00:01:13,840
some 20 years ago

00:01:14,799 --> 00:01:18,240
so the current situation when it comes

00:01:16,560 --> 00:01:20,720
down to tool chains

00:01:18,240 --> 00:01:22,320
course compilers and everything is that

00:01:20,720 --> 00:01:25,360
there's one really well known

00:01:22,320 --> 00:01:26,000
well documented slightly complicated way

00:01:25,360 --> 00:01:29,280
to build it

00:01:26,000 --> 00:01:32,880
all which is of course

00:01:29,280 --> 00:01:34,720
get big utils get gcc get gillipsie

00:01:32,880 --> 00:01:36,560
build them all in the right order and

00:01:34,720 --> 00:01:38,799
build them again

00:01:36,560 --> 00:01:40,159
to get all the features we'll get back

00:01:38,799 --> 00:01:41,360
to that in a bit

00:01:40,159 --> 00:01:44,320
and there's also a couple of

00:01:41,360 --> 00:01:44,320
alternatives but

00:01:44,479 --> 00:01:48,880
not a lot of people are aware of them or

00:01:46,320 --> 00:01:50,479
not a lot of people have used them

00:01:48,880 --> 00:01:52,320
they're certainly not as widely known as

00:01:50,479 --> 00:01:54,079
the traditional way and we are going to

00:01:52,320 --> 00:01:56,399
take a look at

00:01:54,079 --> 00:01:58,159
what those alternatives are that makes

00:01:56,399 --> 00:01:59,520
sense to use them and where it makes

00:01:58,159 --> 00:02:01,119
sense to

00:01:59,520 --> 00:02:03,439
stay with the traditional way of doing

00:02:01,119 --> 00:02:03,439
things

00:02:04,479 --> 00:02:08,160
so the best known way is obviously to

00:02:06,960 --> 00:02:12,000
grab bin utils

00:02:08,160 --> 00:02:14,239
then gcc build a minimal gcc compiler

00:02:12,000 --> 00:02:15,280
for your target platform that has only

00:02:14,239 --> 00:02:18,400
seen

00:02:15,280 --> 00:02:20,239
no threads probably no support for

00:02:18,400 --> 00:02:23,599
shared libraries

00:02:20,239 --> 00:02:24,879
then you build gillipsy and then

00:02:23,599 --> 00:02:27,840
when you are done with that you built

00:02:24,879 --> 00:02:29,680
gcc again enabling a few more features

00:02:27,840 --> 00:02:31,519
including liber cdc plus plus if you

00:02:29,680 --> 00:02:33,760
want c plus plus support including

00:02:31,519 --> 00:02:36,560
threading and all the other advanced

00:02:33,760 --> 00:02:39,360
compiler features you may need lto

00:02:36,560 --> 00:02:42,720
is another thing that's usually not in

00:02:39,360 --> 00:02:42,720
the first stage compiler

00:02:43,280 --> 00:02:46,400
and of course this approach still has

00:02:45,040 --> 00:02:49,440
some advantages

00:02:46,400 --> 00:02:50,160
it's by far the most widespread most of

00:02:49,440 --> 00:02:52,319
the first

00:02:50,160 --> 00:02:54,560
third-party libraries and applications

00:02:52,319 --> 00:02:57,599
have been tested in this setup it's

00:02:54,560 --> 00:02:59,519
what's at the core of almost every

00:02:57,599 --> 00:03:00,879
at least desktop distribution or server

00:02:59,519 --> 00:03:02,720
distribution out there

00:03:00,879 --> 00:03:04,959
some embedded devices have gone another

00:03:02,720 --> 00:03:06,879
way already but

00:03:04,959 --> 00:03:09,120
most of those devices are devices where

00:03:06,879 --> 00:03:12,080
you don't actually get to look

00:03:09,120 --> 00:03:13,280
at what they're doing and of course

00:03:12,080 --> 00:03:16,080
along with that

00:03:13,280 --> 00:03:19,120
comes the fact that people you are

00:03:16,080 --> 00:03:21,360
talking to on irc emailing lists forms

00:03:19,120 --> 00:03:22,239
have done this and will be able to help

00:03:21,360 --> 00:03:26,000
you out with

00:03:22,239 --> 00:03:27,280
any problems there you will probably

00:03:26,000 --> 00:03:29,360
also find people to help

00:03:27,280 --> 00:03:31,360
out with alternatives but they may be a

00:03:29,360 --> 00:03:33,440
bit harder to find

00:03:31,360 --> 00:03:36,400
so let's take a look at what some of the

00:03:33,440 --> 00:03:36,400
alternatives are

00:03:37,760 --> 00:03:43,519
first you will need a compiler which is

00:03:40,159 --> 00:03:45,280
gcc in the traditional option

00:03:43,519 --> 00:03:46,560
there's one compiler that is equally

00:03:45,280 --> 00:03:50,080
good which is clang

00:03:46,560 --> 00:03:52,560
which comes from the llvm suite

00:03:50,080 --> 00:03:53,599
llvm also has replacements for bin utils

00:03:52,560 --> 00:03:56,799
so you can

00:03:53,599 --> 00:03:59,760
skip the bin util step as well

00:03:56,799 --> 00:04:00,560
in lvm before version 10 that was a bit

00:03:59,760 --> 00:04:02,560
complicated

00:04:00,560 --> 00:04:04,560
because the linker that came with it

00:04:02,560 --> 00:04:08,080
just wasn't good enough

00:04:04,560 --> 00:04:09,519
and couldn't replace ld but in llvm10

00:04:08,080 --> 00:04:12,480
that has changed you can

00:04:09,519 --> 00:04:14,159
build pretty much everything with lld

00:04:12,480 --> 00:04:17,040
these days

00:04:14,159 --> 00:04:20,320
so if you're opting for clang you don't

00:04:17,040 --> 00:04:23,680
really need bin utils anymore

00:04:20,320 --> 00:04:27,440
oh and before i forget there is the

00:04:23,680 --> 00:04:30,320
q a session that you can see

00:04:27,440 --> 00:04:31,520
it in the default setup it's under the

00:04:30,320 --> 00:04:33,600
video window

00:04:31,520 --> 00:04:36,160
feel free to type questions there at any

00:04:33,600 --> 00:04:38,400
time interrupt me when you feel like it

00:04:36,160 --> 00:04:39,360
i can't guarantee that i'll notice it

00:04:38,400 --> 00:04:41,680
immediately

00:04:39,360 --> 00:04:44,479
but i'll try to answer questions in a

00:04:41,680 --> 00:04:44,479
timely manner

00:04:44,560 --> 00:04:50,639
okay back to the topic

00:04:47,600 --> 00:04:52,800
yeah lld has become good enough to

00:04:50,639 --> 00:04:54,639
replace binyutils so

00:04:52,800 --> 00:04:56,080
instead of compile binyutils and then

00:04:54,639 --> 00:05:00,880
compile gcc you can

00:04:56,080 --> 00:05:00,880
opt to just compile llvm and clang

00:05:02,000 --> 00:05:05,759
one of the interesting things about

00:05:03,680 --> 00:05:08,080
clang is that it's a cross compiler by

00:05:05,759 --> 00:05:11,120
design so

00:05:08,080 --> 00:05:12,880
with gcc and a lot of other compilers

00:05:11,120 --> 00:05:15,280
you have to build the compiler once for

00:05:12,880 --> 00:05:17,280
every target you want to support

00:05:15,280 --> 00:05:19,919
whereas clang can be built for any

00:05:17,280 --> 00:05:23,759
supported platform at the same time

00:05:19,919 --> 00:05:27,520
so unless you want to uh

00:05:23,759 --> 00:05:29,919
you don't build uh

00:05:27,520 --> 00:05:31,840
all the platforms that you you don't

00:05:29,919 --> 00:05:35,199
build different compilers for

00:05:31,840 --> 00:05:37,120
all the platforms you just build all the

00:05:35,199 --> 00:05:38,240
targets you want into one clan compiler

00:05:37,120 --> 00:05:41,680
and then you specify

00:05:38,240 --> 00:05:43,600
clang dash target with the triplet you

00:05:41,680 --> 00:05:47,759
want to support and then

00:05:43,600 --> 00:05:47,759
the same version of clang will build the

00:05:48,560 --> 00:05:52,800
binary for whatever architecture you're

00:05:51,759 --> 00:05:56,479
targeting with the

00:05:52,800 --> 00:05:57,840
target switch another advantage of clang

00:05:56,479 --> 00:06:00,560
is that its

00:05:57,840 --> 00:06:02,319
code is a lot easier to get into than

00:06:00,560 --> 00:06:05,520
gcc's

00:06:02,319 --> 00:06:07,759
so if you are interested in hacking on

00:06:05,520 --> 00:06:10,319
the compiler itself

00:06:07,759 --> 00:06:10,880
but you are not already a gcc expert it

00:06:10,319 --> 00:06:12,800
is

00:06:10,880 --> 00:06:15,120
much easier to get started in the clang

00:06:12,800 --> 00:06:16,800
world

00:06:15,120 --> 00:06:18,960
so we have a question on the channel

00:06:16,800 --> 00:06:22,880
which is the which is better with

00:06:18,960 --> 00:06:24,800
respect to time between gcc and clang

00:06:22,880 --> 00:06:26,080
that is a question that is hard to

00:06:24,800 --> 00:06:27,600
answer because it

00:06:26,080 --> 00:06:29,360
kind of depends on the code you are

00:06:27,600 --> 00:06:32,000
using it on

00:06:29,360 --> 00:06:33,520
there used to be the situation that in

00:06:32,000 --> 00:06:35,440
general

00:06:33,520 --> 00:06:36,800
clang would be much faster at compiling

00:06:35,440 --> 00:06:39,840
things but

00:06:36,800 --> 00:06:43,120
gcc would produce faster binaries

00:06:39,840 --> 00:06:45,440
that has changed a bit as clang has been

00:06:43,120 --> 00:06:48,639
adding more optimizations

00:06:45,440 --> 00:06:51,120
it got a lot slower at compiling things

00:06:48,639 --> 00:06:54,560
but the binaries got a lot better

00:06:51,120 --> 00:06:57,280
so these days i'd say they are roughly

00:06:54,560 --> 00:07:02,400
the same speed both at compiling and

00:06:57,280 --> 00:07:05,280
running the stuff that was compiled

00:07:02,400 --> 00:07:08,479
i hope that answers the question if not

00:07:05,280 --> 00:07:08,479
please post a follow-up

00:07:08,800 --> 00:07:16,639
okay um getting back to what clan can do

00:07:13,360 --> 00:07:17,680
it has a lot of targets so does gcc but

00:07:16,639 --> 00:07:20,560
clang has some

00:07:17,680 --> 00:07:23,440
interesting additional things like

00:07:20,560 --> 00:07:26,240
targets for various gpus

00:07:23,440 --> 00:07:27,759
so that's interesting especially if

00:07:26,240 --> 00:07:30,160
you're trying to

00:07:27,759 --> 00:07:34,160
do anything where you're trying to split

00:07:30,160 --> 00:07:34,160
workloads between the cpu and the gpu

00:07:34,240 --> 00:07:38,240
yeah we already covered the next point

00:07:36,800 --> 00:07:40,080
in the question

00:07:38,240 --> 00:07:43,199
there are special cases where one

00:07:40,080 --> 00:07:47,440
compiler will perform better

00:07:43,199 --> 00:07:47,440
um on average the performance is similar

00:07:48,319 --> 00:07:52,400
clang is trying to be a drop-in

00:07:49,919 --> 00:07:55,039
replacement for gcc

00:07:52,400 --> 00:07:56,720
so it implements a lot of gcc extensions

00:07:55,039 --> 00:07:58,720
if you have some code that was

00:07:56,720 --> 00:08:00,960
not developed for standards in mind that

00:07:58,720 --> 00:08:02,560
was developed only for gcc

00:08:00,960 --> 00:08:04,000
there's a good chance it will work with

00:08:02,560 --> 00:08:05,599
clang anyway

00:08:04,000 --> 00:08:08,160
not a hundred percent chance but a

00:08:05,599 --> 00:08:11,360
pretty good one

00:08:08,160 --> 00:08:16,319
thing was initially released in 2012 so

00:08:11,360 --> 00:08:16,319
it's 8 years old that

00:08:16,639 --> 00:08:22,080
is pretty much a cause for a lot of

00:08:19,360 --> 00:08:24,080
differences we're seeing

00:08:22,080 --> 00:08:26,080
it doesn't have to care about all the

00:08:24,080 --> 00:08:29,039
old standards and so that gcc

00:08:26,080 --> 00:08:30,240
keeps carrying around it was built on a

00:08:29,039 --> 00:08:33,279
more modern base

00:08:30,240 --> 00:08:34,399
but it also has to catch up on a couple

00:08:33,279 --> 00:08:38,839
of things

00:08:34,399 --> 00:08:41,839
gcc has been doing for almost 40 years

00:08:38,839 --> 00:08:43,839
longer

00:08:41,839 --> 00:08:45,839
another thing that differs between those

00:08:43,839 --> 00:08:50,320
two compilers is the license

00:08:45,839 --> 00:08:52,640
gcc is gpl clang is apache 2.0 which

00:08:50,320 --> 00:08:55,200
essentially means do whatever you like

00:08:52,640 --> 00:08:57,200
except that you wrote it

00:08:55,200 --> 00:08:58,800
which has both advantages and drawbacks

00:08:57,200 --> 00:09:01,279
i mean

00:08:58,800 --> 00:09:02,560
i personally prefer the gpa option

00:09:01,279 --> 00:09:05,600
because it makes people

00:09:02,560 --> 00:09:07,200
contribute back but if you're doing

00:09:05,600 --> 00:09:09,120
something very specific

00:09:07,200 --> 00:09:11,360
and you just don't want to bother

00:09:09,120 --> 00:09:14,800
releasing any code

00:09:11,360 --> 00:09:17,920
you might opt for the apache license

00:09:14,800 --> 00:09:19,519
thing by default but

00:09:17,920 --> 00:09:22,560
in terms of the compiler that really

00:09:19,519 --> 00:09:25,040
shouldn't be a primary consideration

00:09:22,560 --> 00:09:28,399
they are both open they are both good

00:09:25,040 --> 00:09:29,839
pick whatever works better

00:09:28,399 --> 00:09:32,560
and of course there's a good chance you

00:09:29,839 --> 00:09:35,600
will need llvm stuff anyway

00:09:32,560 --> 00:09:38,480
it's used by mesa and other things

00:09:35,600 --> 00:09:40,080
will probably want on a system unless

00:09:38,480 --> 00:09:42,880
you are building some very specific

00:09:40,080 --> 00:09:42,880
embedded device

00:09:44,000 --> 00:09:47,920
of course there's also reasons why you

00:09:45,680 --> 00:09:49,680
might need gcc anyway

00:09:47,920 --> 00:09:53,279
for example you might have want to have

00:09:49,680 --> 00:09:56,959
flip stdc plus plus or lip gs

00:09:53,279 --> 00:09:58,240
so whether or not the compiler you are

00:09:56,959 --> 00:10:00,240
opting for

00:09:58,240 --> 00:10:02,720
has all the things that you need for the

00:10:00,240 --> 00:10:04,720
system you are trying to build

00:10:02,720 --> 00:10:07,360
is another consideration that you should

00:10:04,720 --> 00:10:07,360
be looking at

00:10:09,839 --> 00:10:12,880
so one of the pieces of good news is

00:10:12,560 --> 00:10:15,760
that

00:10:12,880 --> 00:10:16,160
clang and gcc are binary compatible you

00:10:15,760 --> 00:10:18,880
can

00:10:16,160 --> 00:10:19,279
link a library built by one compiler to

00:10:18,880 --> 00:10:22,399
a

00:10:19,279 --> 00:10:24,640
code built with the other and

00:10:22,399 --> 00:10:26,880
you can even mix them inside the same

00:10:24,640 --> 00:10:29,120
project so you compile one object file

00:10:26,880 --> 00:10:30,959
with gcc and another with clang

00:10:29,120 --> 00:10:32,399
and you link them together and it will

00:10:30,959 --> 00:10:34,800
work

00:10:32,399 --> 00:10:35,839
there's usually not much of a reason to

00:10:34,800 --> 00:10:37,760
do that

00:10:35,839 --> 00:10:39,920
there might be some special cases for

00:10:37,760 --> 00:10:42,399
example if you've observed

00:10:39,920 --> 00:10:43,279
gcc optimizing one particular function a

00:10:42,399 --> 00:10:45,360
lot better and

00:10:43,279 --> 00:10:46,399
trying optimizing another function a lot

00:10:45,360 --> 00:10:49,680
better

00:10:46,399 --> 00:10:50,959
you might opt for a version where you

00:10:49,680 --> 00:10:53,360
compile the

00:10:50,959 --> 00:10:55,120
file with that's optimized better with

00:10:53,360 --> 00:10:57,040
gcc with one compiler

00:10:55,120 --> 00:10:59,360
and you compile the other file with

00:10:57,040 --> 00:11:01,440
clang and then link them together to get

00:10:59,360 --> 00:11:03,920
the best performance

00:11:01,440 --> 00:11:05,839
but usually the the performance

00:11:03,920 --> 00:11:07,839
differences are not big enough for that

00:11:05,839 --> 00:11:11,200
to matter

00:11:07,839 --> 00:11:14,320
if you do want to mix compilers that way

00:11:11,200 --> 00:11:17,360
you have to use gcc support libraries

00:11:14,320 --> 00:11:19,040
so libgcc and grt's version of the crt

00:11:17,360 --> 00:11:21,839
object files

00:11:19,040 --> 00:11:23,839
um because clan can handle gcc's

00:11:21,839 --> 00:11:25,920
versions but

00:11:23,839 --> 00:11:27,760
if you want to use clank's versions so

00:11:25,920 --> 00:11:29,360
if you want to use compiler rt instead

00:11:27,760 --> 00:11:33,360
of flip gcc

00:11:29,360 --> 00:11:35,760
with gcc it's possible but

00:11:33,360 --> 00:11:39,120
quite a bit tricky so that's something

00:11:35,760 --> 00:11:39,120
you probably want to avoid

00:11:40,880 --> 00:11:48,560
another alternative compiler is tiny cc

00:11:45,120 --> 00:11:50,560
which as the name already tells you is

00:11:48,560 --> 00:11:54,000
one of the smallest implementations of

00:11:50,560 --> 00:11:55,920
the full c999 compiler you can get

00:11:54,000 --> 00:11:57,839
the compiler source itself is smaller

00:11:55,920 --> 00:11:59,920
than four megabytes compared to

00:11:57,839 --> 00:12:01,680
multiple hundreds of megabytes for both

00:11:59,920 --> 00:12:03,360
gcc and clang

00:12:01,680 --> 00:12:06,000
and it takes only a few seconds to

00:12:03,360 --> 00:12:08,639
compile and manage to compile tiny cc

00:12:06,000 --> 00:12:10,079
in less than 10 seconds on a relatively

00:12:08,639 --> 00:12:12,079
fast box

00:12:10,079 --> 00:12:13,680
but it doesn't optimize as strongly as

00:12:12,079 --> 00:12:15,680
clang or gcc

00:12:13,680 --> 00:12:17,360
and it's also limited to see it doesn't

00:12:15,680 --> 00:12:19,920
support any of the other languages

00:12:17,360 --> 00:12:23,200
supported by the two other compilers so

00:12:19,920 --> 00:12:24,000
no c plus plus no fortran no whatever

00:12:23,200 --> 00:12:27,040
else you might want

00:12:24,000 --> 00:12:28,720
to use but it is certainly another

00:12:27,040 --> 00:12:30,160
interesting option for small embedded

00:12:28,720 --> 00:12:32,160
devices

00:12:30,160 --> 00:12:34,240
and another interesting thing is yeah

00:12:32,160 --> 00:12:35,680
that you can embed the compiler and

00:12:34,240 --> 00:12:37,760
essentially

00:12:35,680 --> 00:12:39,519
make it you see as a scripting language

00:12:37,760 --> 00:12:41,680
inside your application

00:12:39,519 --> 00:12:44,160
so even if you don't end up using it as

00:12:41,680 --> 00:12:46,000
the primary compiler for your project

00:12:44,160 --> 00:12:48,639
it might be worth look depending on what

00:12:46,000 --> 00:12:48,639
you want to do

00:12:50,399 --> 00:12:53,839
another interesting compiler well or at

00:12:52,959 --> 00:12:55,279
least

00:12:53,839 --> 00:12:56,959
another compiler that might be

00:12:55,279 --> 00:13:00,000
interesting at some point is

00:12:56,959 --> 00:13:03,279
open arc so far it's vaporware

00:13:00,000 --> 00:13:05,760
but it was announced by huawei last year

00:13:03,279 --> 00:13:08,079
it's supposed to become a c c plus plus

00:13:05,760 --> 00:13:10,399
java kotlin and javascript compiler that

00:13:08,079 --> 00:13:12,480
generates native code

00:13:10,399 --> 00:13:13,839
and they promise it will be fully open

00:13:12,480 --> 00:13:15,839
at some point

00:13:13,839 --> 00:13:18,839
but so far they've only released a bit

00:13:15,839 --> 00:13:20,240
of code that can compile java to arc64

00:13:18,839 --> 00:13:23,200
assembly

00:13:20,240 --> 00:13:24,399
and it does that by calling into a

00:13:23,200 --> 00:13:27,120
binary blob

00:13:24,399 --> 00:13:27,760
so if you're interested in open compiler

00:13:27,120 --> 00:13:30,800
there's

00:13:27,760 --> 00:13:33,519
not much there yet but

00:13:30,800 --> 00:13:35,120
if they stick to their promise it could

00:13:33,519 --> 00:13:36,880
really become an interesting option in

00:13:35,120 --> 00:13:38,720
the future especially if you have to mix

00:13:36,880 --> 00:13:41,440
languages

00:13:38,720 --> 00:13:42,639
but right now it's not there yet so

00:13:41,440 --> 00:13:46,160
we'll have to see

00:13:42,639 --> 00:13:46,160
whether or not it goes anywhere

00:13:47,839 --> 00:13:51,440
another option that you will probably

00:13:50,000 --> 00:13:53,760
have if you are working with

00:13:51,440 --> 00:13:55,440
embedded devices is using a board

00:13:53,760 --> 00:13:59,920
support package that

00:13:55,440 --> 00:14:02,399
comes with the board but usually

00:13:59,920 --> 00:14:04,800
those board support packages contain a

00:14:02,399 --> 00:14:06,399
fork of a really outdated version of gcc

00:14:04,800 --> 00:14:09,920
or clang

00:14:06,399 --> 00:14:12,320
and usually both of those compilers have

00:14:09,920 --> 00:14:13,680
in the meantime already added much

00:14:12,320 --> 00:14:15,519
better support for the hardware

00:14:13,680 --> 00:14:17,279
investment than that

00:14:15,519 --> 00:14:20,079
fork that comes with the board might

00:14:17,279 --> 00:14:22,000
have so unless you are working on a very

00:14:20,079 --> 00:14:24,720
special device there that is not yet

00:14:22,000 --> 00:14:27,120
supported by the upstream compilers

00:14:24,720 --> 00:14:28,880
it's usually the best option to just

00:14:27,120 --> 00:14:30,079
ignore whatever is in the board support

00:14:28,880 --> 00:14:32,160
packages

00:14:30,079 --> 00:14:33,199
maybe pick a couple of libraries or so

00:14:32,160 --> 00:14:35,920
from there

00:14:33,199 --> 00:14:39,519
but ignore the compilers and just go

00:14:35,920 --> 00:14:41,040
with the latest version of clang or gcc

00:14:39,519 --> 00:14:42,800
sometimes that means you have to add a

00:14:41,040 --> 00:14:45,519
few kernel patches to

00:14:42,800 --> 00:14:47,600
make sure whatever outdated corner comes

00:14:45,519 --> 00:14:49,120
with the board supports the count tool

00:14:47,600 --> 00:14:51,440
chains

00:14:49,120 --> 00:14:52,480
but those patches are usually already

00:14:51,440 --> 00:14:55,360
written because

00:14:52,480 --> 00:14:58,079
they exist in count kernels and they

00:14:55,360 --> 00:14:59,760
tend to be easy to find so

00:14:58,079 --> 00:15:01,440
we can just look at the kernel git

00:14:59,760 --> 00:15:03,199
repository and

00:15:01,440 --> 00:15:05,680
look at the log for the file that's

00:15:03,199 --> 00:15:08,560
refusing to compile

00:15:05,680 --> 00:15:09,120
in general i think it's probably best to

00:15:08,560 --> 00:15:12,959
avoid

00:15:09,120 --> 00:15:16,720
any compiler that is not based on gcc

00:15:12,959 --> 00:15:18,639
8 or later or in clang 9 or later

00:15:16,720 --> 00:15:21,839
earlier versions of those compilers are

00:15:18,639 --> 00:15:21,839
just not as good

00:15:22,639 --> 00:15:27,600
so summing it up gcc and clang are both

00:15:26,480 --> 00:15:30,720
good options there's

00:15:27,600 --> 00:15:32,480
no clear winner tiny cc is also

00:15:30,720 --> 00:15:34,399
interesting to look at depending on what

00:15:32,480 --> 00:15:36,480
you're doing but just

00:15:34,399 --> 00:15:38,320
not that great a general purpose

00:15:36,480 --> 00:15:40,240
compiler

00:15:38,320 --> 00:15:42,639
both of the big compilers have been used

00:15:40,240 --> 00:15:45,680
to compile full systems

00:15:42,639 --> 00:15:47,839
now even including the kernel

00:15:45,680 --> 00:15:50,079
most linux distributions that you're

00:15:47,839 --> 00:15:52,800
using on your desktop on the server will

00:15:50,079 --> 00:15:54,880
probably have been built with gcc

00:15:52,800 --> 00:15:55,839
there's a few like openmandriva and

00:15:54,880 --> 00:15:58,480
android and

00:15:55,839 --> 00:16:00,959
some of the bsds that are built mostly

00:15:58,480 --> 00:16:00,959
with clang

00:16:01,040 --> 00:16:05,600
in some distributions that like to build

00:16:04,079 --> 00:16:08,480
everything from source

00:16:05,600 --> 00:16:11,279
you're offered both options so both

00:16:08,480 --> 00:16:13,120
compilers have had a lot of testing

00:16:11,279 --> 00:16:15,680
with all the standard open source

00:16:13,120 --> 00:16:15,680
components

00:16:19,199 --> 00:16:23,680
so it's really hard to make a choice

00:16:22,160 --> 00:16:26,000
there

00:16:23,680 --> 00:16:29,279
clang makes it a bit easier to add new

00:16:26,000 --> 00:16:31,519
architectures new languages

00:16:29,279 --> 00:16:32,320
it's generally built as a library so

00:16:31,519 --> 00:16:34,000
it's easier to

00:16:32,320 --> 00:16:36,320
embed parts of the compiler in your own

00:16:34,000 --> 00:16:38,720
code if you want to do that

00:16:36,320 --> 00:16:39,440
if you are planning to add architectures

00:16:38,720 --> 00:16:41,759
or

00:16:39,440 --> 00:16:43,920
new language in the front end or you

00:16:41,759 --> 00:16:47,600
want to embed the compiler somewhere

00:16:43,920 --> 00:16:49,279
chances are you'll be happier with clang

00:16:47,600 --> 00:16:51,759
on the other hand if you are using

00:16:49,279 --> 00:16:53,680
gillipsie that currently can't be built

00:16:51,759 --> 00:16:55,120
with anything but gcc even though

00:16:53,680 --> 00:16:56,320
there's a couple of patches floating

00:16:55,120 --> 00:16:59,680
around

00:16:56,320 --> 00:17:02,320
we'll get back to that a bit later

00:16:59,680 --> 00:17:04,559
and if you don't need any of the extra

00:17:02,320 --> 00:17:06,240
other extras offered by clang

00:17:04,559 --> 00:17:08,480
you may want to go with gcc for

00:17:06,240 --> 00:17:11,600
everything as well they're really

00:17:08,480 --> 00:17:11,600
both good compilers

00:17:12,480 --> 00:17:16,640
so let's look at the next component

00:17:14,480 --> 00:17:18,559
which is libsy

00:17:16,640 --> 00:17:20,079
which is basically the core library

00:17:18,559 --> 00:17:23,120
containing such calls as

00:17:20,079 --> 00:17:23,600
open close and everything else that you

00:17:23,120 --> 00:17:25,520
will

00:17:23,600 --> 00:17:27,039
end up using in every application out

00:17:25,520 --> 00:17:29,200
there

00:17:27,039 --> 00:17:31,280
glibc is the default option it's what

00:17:29,200 --> 00:17:34,559
has been around forever

00:17:31,280 --> 00:17:36,640
it's the most complete lipsy out there

00:17:34,559 --> 00:17:38,240
it's the most standard compliant version

00:17:36,640 --> 00:17:40,000
because it

00:17:38,240 --> 00:17:41,520
really tries to support all the relevant

00:17:40,000 --> 00:17:45,120
standards out there

00:17:41,520 --> 00:17:47,440
including the really old ones like c89

00:17:45,120 --> 00:17:50,640
it has had a lot of testing because it

00:17:47,440 --> 00:17:52,880
was for a long time the only option

00:17:50,640 --> 00:17:53,679
it has the most complete architecture

00:17:52,880 --> 00:17:55,280
support

00:17:53,679 --> 00:17:57,440
i'm not going to read off the entire

00:17:55,280 --> 00:17:59,840
list but if you care just

00:17:57,440 --> 00:18:01,679
look at the slides or look at the glibc

00:17:59,840 --> 00:18:03,600
code

00:18:01,679 --> 00:18:06,160
but it also has a couple of drawbacks

00:18:03,600 --> 00:18:08,640
its code is not very readable

00:18:06,160 --> 00:18:09,760
it can only be compiled with gcc so if

00:18:08,640 --> 00:18:12,400
you are opting for

00:18:09,760 --> 00:18:13,760
a different compiler you will have to

00:18:12,400 --> 00:18:17,039
use gcc for

00:18:13,760 --> 00:18:20,000
glibc anyway there is a set of patches

00:18:17,039 --> 00:18:22,480
that makes it compile with clang but

00:18:20,000 --> 00:18:24,880
it's based on an old version of glibc

00:18:22,480 --> 00:18:28,320
which is 229

00:18:24,880 --> 00:18:30,240
so it might be an interesting project to

00:18:28,320 --> 00:18:33,679
uh look at those patches and port them

00:18:30,240 --> 00:18:36,160
over to country lipsy

00:18:33,679 --> 00:18:37,840
another drawback for gillipsie is that

00:18:36,160 --> 00:18:39,280
it's not very optimized for small

00:18:37,840 --> 00:18:41,120
systems

00:18:39,280 --> 00:18:43,600
it's rather big so roughly four

00:18:41,120 --> 00:18:45,840
megabytes for ldso lipsy lip m

00:18:43,600 --> 00:18:48,000
lippy thread which are the main

00:18:45,840 --> 00:18:49,440
components you will need anyway

00:18:48,000 --> 00:18:51,919
of course if you are targeting a

00:18:49,440 --> 00:18:54,640
high-end desktop or high-end server

00:18:51,919 --> 00:18:55,120
four megabytes really don't matter so

00:18:54,640 --> 00:18:57,360
that's

00:18:55,120 --> 00:19:00,080
not a big deal but if you're targeting

00:18:57,360 --> 00:19:01,679
an embedded system or a low-end desktop

00:19:00,080 --> 00:19:03,280
where you really want to save a lot of

00:19:01,679 --> 00:19:05,360
memory like

00:19:03,280 --> 00:19:08,400
if you want to get anything to work on

00:19:05,360 --> 00:19:08,400
my old friend here

00:19:08,559 --> 00:19:12,559
you probably don't want to use gillipsie

00:19:14,960 --> 00:19:18,799
one alternative that has come up lately

00:19:16,880 --> 00:19:21,440
is muzzle

00:19:18,799 --> 00:19:22,799
which is interesting because it's also

00:19:21,440 --> 00:19:27,200
very complete

00:19:22,799 --> 00:19:29,440
it's fast it's relatively small only 785

00:19:27,200 --> 00:19:31,120
kilobytes compared to gillipsies four

00:19:29,440 --> 00:19:34,559
megabytes

00:19:31,120 --> 00:19:36,320
it was written with c11 and posix 2008

00:19:34,559 --> 00:19:39,120
compliance and main in mind

00:19:36,320 --> 00:19:41,039
instead of also targeting all the older

00:19:39,120 --> 00:19:42,880
standards

00:19:41,039 --> 00:19:45,440
but it does support a lot of commonly

00:19:42,880 --> 00:19:46,960
used gillipsy and linux and bsd

00:19:45,440 --> 00:19:49,039
extensions

00:19:46,960 --> 00:19:50,960
so most of the code you see out there

00:19:49,039 --> 00:19:54,559
will compile against muscle

00:19:50,960 --> 00:19:56,480
without problems it also has

00:19:54,559 --> 00:19:59,120
pretty good architecture support not

00:19:56,480 --> 00:20:01,039
quite the full list that glitzy has

00:19:59,120 --> 00:20:03,760
but pretty much all the interesting

00:20:01,039 --> 00:20:05,919
architectures are covered

00:20:03,760 --> 00:20:07,280
in terms of architecture support one

00:20:05,919 --> 00:20:09,440
really interesting thing

00:20:07,280 --> 00:20:11,120
in muscle is that it's the only lips you

00:20:09,440 --> 00:20:15,200
have seen that

00:20:11,120 --> 00:20:16,000
supports open risk i don't know if open

00:20:15,200 --> 00:20:18,799
risk will

00:20:16,000 --> 00:20:21,039
ever really go anywhere but it's an

00:20:18,799 --> 00:20:23,200
interesting architecture and so far

00:20:21,039 --> 00:20:24,240
if you want to use that architecture you

00:20:23,200 --> 00:20:28,080
are stuck with

00:20:24,240 --> 00:20:31,120
muscle only another key advantage of

00:20:28,080 --> 00:20:32,960
muscle is that it has readable code so

00:20:31,120 --> 00:20:34,960
if you want to figure out how your lipsy

00:20:32,960 --> 00:20:37,120
works muscle is probably the best option

00:20:34,960 --> 00:20:39,440
to look at

00:20:37,120 --> 00:20:41,360
gellipsia is rather complicated to

00:20:39,440 --> 00:20:45,200
understand so is

00:20:41,360 --> 00:20:48,320
useless which is the next option

00:20:45,200 --> 00:20:53,120
muscle has been around since 2011.

00:20:48,320 --> 00:20:55,919
so it looks like it's there to stay

00:20:53,120 --> 00:20:58,080
which is certainly a reason to consider

00:20:55,919 --> 00:20:58,080
it

00:20:58,720 --> 00:21:04,320
another option is ucla cng

00:21:01,760 --> 00:21:06,000
which is another relatively complete

00:21:04,320 --> 00:21:09,520
fast and small

00:21:06,000 --> 00:21:11,360
lipsy implementation it's about one

00:21:09,520 --> 00:21:15,600
megabyte in a full config but

00:21:11,360 --> 00:21:18,640
the interesting thing in ucla c is

00:21:15,600 --> 00:21:20,960
it can be stripped down easily it has a

00:21:18,640 --> 00:21:22,480
make a config target that is just like

00:21:20,960 --> 00:21:24,720
the kernel's config

00:21:22,480 --> 00:21:27,760
then you get a list of all sorts of

00:21:24,720 --> 00:21:29,919
optional features

00:21:27,760 --> 00:21:31,280
optional functions that tend to be quite

00:21:29,919 --> 00:21:33,200
big

00:21:31,280 --> 00:21:34,720
you can throw them out easily by just

00:21:33,200 --> 00:21:37,440
saying okay i want this and this and

00:21:34,720 --> 00:21:39,919
this and i don't want that and then that

00:21:37,440 --> 00:21:41,200
so if you're building an embedded system

00:21:39,919 --> 00:21:44,080
and you're not using all the

00:21:41,200 --> 00:21:48,640
functionality from libsy

00:21:44,080 --> 00:21:50,480
the stripping out stuff is acceptable

00:21:48,640 --> 00:21:53,919
then you see the cng might be an

00:21:50,480 --> 00:21:53,919
interesting project to look at

00:21:55,440 --> 00:22:01,039
another one is calebc which was written

00:21:58,240 --> 00:22:03,039
for early buddha process

00:22:01,039 --> 00:22:04,559
some distributions most debian

00:22:03,039 --> 00:22:07,280
derivatives use

00:22:04,559 --> 00:22:08,640
caleb c for their initial mfs in early

00:22:07,280 --> 00:22:10,840
boot up process

00:22:08,640 --> 00:22:12,000
which is what it was actually written

00:22:10,840 --> 00:22:14,400
for

00:22:12,000 --> 00:22:17,280
it's only a subset of lipsy functions

00:22:14,400 --> 00:22:19,840
optimized for size over performance

00:22:17,280 --> 00:22:21,840
it uses kernel structures directly to

00:22:19,840 --> 00:22:23,760
avoid type conversions

00:22:21,840 --> 00:22:26,559
so for example the kernel has its own

00:22:23,760 --> 00:22:29,440
idea of struct stat and

00:22:26,559 --> 00:22:30,000
most liberties have their own idea and

00:22:29,440 --> 00:22:32,480
when you

00:22:30,000 --> 00:22:34,480
uh calls that an ellipsis there will be

00:22:32,480 --> 00:22:36,640
some conversion going on

00:22:34,480 --> 00:22:41,200
whereas in calypsi you just use the

00:22:36,640 --> 00:22:42,960
kernel structstat and it gets passed on

00:22:41,200 --> 00:22:44,320
this type of thing makes caleb see

00:22:42,960 --> 00:22:47,679
extremely small it's only

00:22:44,320 --> 00:22:49,600
75 kilo kilobytes

00:22:47,679 --> 00:22:51,679
but it's not powerful enough to act as a

00:22:49,600 --> 00:22:54,640
real world ellipses uh

00:22:51,679 --> 00:22:58,559
it doesn't have all the functions that

00:22:54,640 --> 00:22:58,559
you will need to compile a full system

00:22:58,640 --> 00:23:02,960
it might be good enough for some

00:23:00,320 --> 00:23:05,200
embedded systems

00:23:02,960 --> 00:23:06,559
one thing to look out there is it uses

00:23:05,200 --> 00:23:08,720
gpi kernel headers

00:23:06,559 --> 00:23:09,760
and that results in a kernel license

00:23:08,720 --> 00:23:13,280
situation

00:23:09,760 --> 00:23:15,840
that is not completely clear

00:23:13,280 --> 00:23:17,440
so you might end up putting your entire

00:23:15,840 --> 00:23:19,760
system under the gpa

00:23:17,440 --> 00:23:20,559
making it problematic if someone wants

00:23:19,760 --> 00:23:23,440
to run

00:23:20,559 --> 00:23:24,799
any non-free applications on top of it

00:23:23,440 --> 00:23:27,039
which of course

00:23:24,799 --> 00:23:28,080
if you are trying to push open software

00:23:27,039 --> 00:23:30,400
heavily

00:23:28,080 --> 00:23:31,919
might be a good thing but if you are

00:23:30,400 --> 00:23:34,559
targeting people who

00:23:31,919 --> 00:23:37,840
might be doing anything that's the

00:23:34,559 --> 00:23:37,840
reason to avoid it

00:23:39,440 --> 00:23:44,799
there's another thing um much like the

00:23:43,200 --> 00:23:47,600
opener compiler we've talked about

00:23:44,799 --> 00:23:50,880
before this is vaporware for now

00:23:47,600 --> 00:23:54,080
but uh there's some code there

00:23:50,880 --> 00:23:55,120
it's the llvm libsy it's in really early

00:23:54,080 --> 00:23:58,159
stages

00:23:55,120 --> 00:24:02,480
there's some code you can look at

00:23:58,159 --> 00:24:04,159
but it doesn't do a lot yet

00:24:02,480 --> 00:24:07,360
i wouldn't usually have listed this

00:24:04,159 --> 00:24:09,039
because it's still in early stages

00:24:07,360 --> 00:24:10,720
but it has some really interesting

00:24:09,039 --> 00:24:12,720
features like it's designed from the

00:24:10,720 --> 00:24:14,080
grounds up to work with sanitizers and

00:24:12,720 --> 00:24:16,240
fast testing

00:24:14,080 --> 00:24:19,039
so you will likely not end up running

00:24:16,240 --> 00:24:21,279
into all sorts of bugs that

00:24:19,039 --> 00:24:22,720
have been plaguing other lepsis for

00:24:21,279 --> 00:24:25,760
decades

00:24:22,720 --> 00:24:28,000
it's targeting only c17 and up so

00:24:25,760 --> 00:24:32,240
you won't have to carry around all the

00:24:28,000 --> 00:24:35,120
prehistoric craft

00:24:32,240 --> 00:24:38,880
one design goal of it given that it is

00:24:35,120 --> 00:24:42,240
just like the clan compiler part of llvm

00:24:38,880 --> 00:24:45,440
is to use source based implementations

00:24:42,240 --> 00:24:48,960
so write everything in the

00:24:45,440 --> 00:24:50,559
libsy in the sea itself instead of

00:24:48,960 --> 00:24:52,240
going down to the level of writing

00:24:50,559 --> 00:24:55,360
assembly that you will find in

00:24:52,240 --> 00:24:58,880
most other ellipses

00:24:55,360 --> 00:24:59,679
and while edit fixed compiler to

00:24:58,880 --> 00:25:01,279
generate

00:24:59,679 --> 00:25:02,880
code that is just as good as the hand

00:25:01,279 --> 00:25:05,039
crafted assembly code you will find

00:25:02,880 --> 00:25:07,279
another ellipses

00:25:05,039 --> 00:25:10,320
so if nothing else this libsy will help

00:25:07,279 --> 00:25:12,799
make the compilers better

00:25:10,320 --> 00:25:14,480
and of course it does come out of a

00:25:12,799 --> 00:25:16,480
project that has a track record of

00:25:14,480 --> 00:25:18,640
delivering good options

00:25:16,480 --> 00:25:19,919
so i'm pretty sure they will get there

00:25:18,640 --> 00:25:22,159
eventually

00:25:19,919 --> 00:25:24,720
it's not like it's just some project

00:25:22,159 --> 00:25:26,640
that has sprung out of nowhere saying

00:25:24,720 --> 00:25:28,480
okay we're doing this and we will be

00:25:26,640 --> 00:25:30,080
better than everything else

00:25:28,480 --> 00:25:32,799
and then it will disappear in a couple

00:25:30,080 --> 00:25:32,799
of days again

00:25:34,080 --> 00:25:39,360
there is another option which is bionic

00:25:37,600 --> 00:25:42,720
if you've ever looked at android source

00:25:39,360 --> 00:25:44,480
code you have seen this one

00:25:42,720 --> 00:25:45,760
it's originally based on the bsd

00:25:44,480 --> 00:25:48,240
ellipsis it

00:25:45,760 --> 00:25:49,520
contains some code from freebsd some

00:25:48,240 --> 00:25:52,960
from openbsd

00:25:49,520 --> 00:25:55,200
some from netbst and some written for

00:25:52,960 --> 00:25:57,520
bionic itself

00:25:55,200 --> 00:25:59,120
it currently only supports the most

00:25:57,520 --> 00:26:03,760
relevant architectures

00:25:59,120 --> 00:26:05,840
32 and 64-bit versions of x86 and arm

00:26:03,760 --> 00:26:07,600
it is quite optimized because a lot of

00:26:05,840 --> 00:26:10,480
vendors put a lot of effort into

00:26:07,600 --> 00:26:12,400
optimizing android

00:26:10,480 --> 00:26:14,400
in the early stages it used to be

00:26:12,400 --> 00:26:15,600
totally unusable for building a regular

00:26:14,400 --> 00:26:18,159
linux system like it

00:26:15,600 --> 00:26:20,480
didn't have system 5 shared memory which

00:26:18,159 --> 00:26:22,480
was needed for x11

00:26:20,480 --> 00:26:23,600
but it has largely caught up on that and

00:26:22,480 --> 00:26:27,120
it's by now

00:26:23,600 --> 00:26:28,080
a fully usable libsy but unfortunately

00:26:27,120 --> 00:26:30,240
at the same time

00:26:28,080 --> 00:26:31,200
they've added a lot of things to it that

00:26:30,240 --> 00:26:33,919
are

00:26:31,200 --> 00:26:35,120
really not existent in stuff outside of

00:26:33,919 --> 00:26:37,279
android

00:26:35,120 --> 00:26:38,880
so there's the apex stuff which

00:26:37,279 --> 00:26:42,640
essentially it tries to

00:26:38,880 --> 00:26:44,080
mount any files as directories and look

00:26:42,640 --> 00:26:46,400
at what's in there which is part of

00:26:44,080 --> 00:26:49,760
android's package manager

00:26:46,400 --> 00:26:51,760
and then there's system properties that

00:26:49,760 --> 00:26:54,640
last time i checked your light on

00:26:51,760 --> 00:26:56,159
android's init implementation to work

00:26:54,640 --> 00:26:58,240
then the build system is tied to the

00:26:56,159 --> 00:27:01,679
android tree

00:26:58,240 --> 00:27:03,520
so it is kind of complicated to

00:27:01,679 --> 00:27:07,840
rip out bionic and build some

00:27:03,520 --> 00:27:07,840
non-android system on top of it

00:27:08,080 --> 00:27:12,480
but of course doing that gives you a

00:27:10,320 --> 00:27:14,000
couple of interesting options like yeah

00:27:12,480 --> 00:27:16,640
using closed drivers that have been

00:27:14,000 --> 00:27:18,320
written for android

00:27:16,640 --> 00:27:21,440
without having to go through hacks like

00:27:18,320 --> 00:27:25,120
the early pipers

00:27:21,440 --> 00:27:25,600
and the it may be interesting if you're

00:27:25,120 --> 00:27:28,880
building

00:27:25,600 --> 00:27:31,919
the linux android hybrid system which in

00:27:28,880 --> 00:27:31,919
some ways makes sense

00:27:32,000 --> 00:27:38,000
there's one comment in the q a

00:27:36,080 --> 00:27:39,679
which says actually of course to langi

00:27:38,000 --> 00:27:41,600
can build bionics so you don't need

00:27:39,679 --> 00:27:43,440
android's build system that's really

00:27:41,600 --> 00:27:45,679
good news i'm definitely going to check

00:27:43,440 --> 00:27:47,440
that out

00:27:45,679 --> 00:27:50,000
i must have missed that when it was

00:27:47,440 --> 00:27:51,600
added and i hope it targets current

00:27:50,000 --> 00:27:53,600
versions of bionic that could make

00:27:51,600 --> 00:27:57,679
things a lot easier

00:27:53,600 --> 00:28:03,840
so i'll definitely check it out and

00:27:57,679 --> 00:28:03,840
maybe talk about that next year i'll see

00:28:04,799 --> 00:28:08,000
there's a few more options

00:28:08,320 --> 00:28:13,039
but i'm not going to consider those for

00:28:11,120 --> 00:28:13,600
full ellipses for a system there's new

00:28:13,039 --> 00:28:17,360
lib

00:28:13,600 --> 00:28:18,799
which is limited to static linking so

00:28:17,360 --> 00:28:21,039
you might want to look at it if you

00:28:18,799 --> 00:28:23,279
don't need dynamic linking but

00:28:21,039 --> 00:28:25,120
pretty much everything except super low

00:28:23,279 --> 00:28:26,480
and embedded devices will want dynamic

00:28:25,120 --> 00:28:29,679
linking

00:28:26,480 --> 00:28:32,799
which pretty much rules it out and then

00:28:29,679 --> 00:28:35,679
there's diet lipsy which is another

00:28:32,799 --> 00:28:37,440
very optimized for size lipsy but it's

00:28:35,679 --> 00:28:38,399
not very actively maintained the last

00:28:37,440 --> 00:28:42,320
release was

00:28:38,399 --> 00:28:42,320
i think two or three years ago

00:28:42,720 --> 00:28:46,880
another drawback of this one is that

00:28:45,039 --> 00:28:49,360
it's gpl licensed which

00:28:46,880 --> 00:28:51,760
for applications is great but for

00:28:49,360 --> 00:28:53,760
something as low level as ellipsey

00:28:51,760 --> 00:28:55,600
is probably going a bit too early to

00:28:53,760 --> 00:28:57,440
extreme because that

00:28:55,600 --> 00:28:59,360
puts your users into questionable

00:28:57,440 --> 00:29:01,200
situations if they want to run anything

00:28:59,360 --> 00:29:05,200
non-free on top of it

00:29:01,200 --> 00:29:05,840
like trying to build steam or something

00:29:05,200 --> 00:29:10,799
on top of

00:29:05,840 --> 00:29:14,320
the gp ellipses would be problematic

00:29:10,799 --> 00:29:16,080
so that's probably another one you may

00:29:14,320 --> 00:29:17,600
want to look at if you have some special

00:29:16,080 --> 00:29:19,279
needs but

00:29:17,600 --> 00:29:21,679
it's not as general purpose as the

00:29:19,279 --> 00:29:21,679
others

00:29:23,200 --> 00:29:31,200
so what's the best choice to make

00:29:28,080 --> 00:29:33,200
again there's no super clear winner

00:29:31,200 --> 00:29:34,240
if you need maximum compatibility with

00:29:33,200 --> 00:29:36,320
all the standards

00:29:34,240 --> 00:29:38,960
if you need binary compatibility with

00:29:36,320 --> 00:29:42,080
the big distributions out there

00:29:38,960 --> 00:29:44,000
you pretty much have to go with glibc if

00:29:42,080 --> 00:29:46,799
you need something full-fledged but

00:29:44,000 --> 00:29:50,000
smaller more memory efficient you

00:29:46,799 --> 00:29:52,840
probably want to go with muzzle

00:29:50,000 --> 00:29:55,440
if you want to if all you need is a

00:29:52,840 --> 00:29:57,120
subset and you can strip out unneeded

00:29:55,440 --> 00:29:58,480
components if it's clear what you won't

00:29:57,120 --> 00:30:00,320
be needing

00:29:58,480 --> 00:30:02,399
you see the cng might be an interesting

00:30:00,320 --> 00:30:03,039
choice because that makes stripping out

00:30:02,399 --> 00:30:06,559
parts

00:30:03,039 --> 00:30:08,320
easiest and bionic is obviously

00:30:06,559 --> 00:30:10,240
interesting if you want to experiment

00:30:08,320 --> 00:30:12,799
with android features

00:30:10,240 --> 00:30:17,039
or if you are looking at a code that has

00:30:12,799 --> 00:30:17,039
been optimized already by android guys

00:30:19,840 --> 00:30:26,080
next up we have c plus plus support

00:30:24,240 --> 00:30:27,679
there's a couple of implementations of

00:30:26,080 --> 00:30:30,640
the standard template library

00:30:27,679 --> 00:30:32,320
stl which is part of the c plus plus

00:30:30,640 --> 00:30:34,720
standard

00:30:32,320 --> 00:30:36,720
the first option is libes tdc plus plus

00:30:34,720 --> 00:30:39,760
which is part of gcc

00:30:36,720 --> 00:30:40,960
so that is used by almost all the linux

00:30:39,760 --> 00:30:42,480
distributions

00:30:40,960 --> 00:30:44,159
even the ones that use clang as their

00:30:42,480 --> 00:30:47,279
primary compiler

00:30:44,159 --> 00:30:49,039
the only notable exception is android

00:30:47,279 --> 00:30:52,720
and i think the bsds as well but they

00:30:49,039 --> 00:30:52,720
are not in linux distribution so

00:30:53,360 --> 00:30:57,679
in the context of linux distributions

00:30:55,120 --> 00:31:00,960
they don't count

00:30:57,679 --> 00:31:02,720
and pretty much everything that's being

00:31:00,960 --> 00:31:03,279
developed in the open world is developed

00:31:02,720 --> 00:31:05,519
against

00:31:03,279 --> 00:31:07,840
liberty ddc plus plus so if you want to

00:31:05,519 --> 00:31:09,760
avoid tweaking code by adding missing

00:31:07,840 --> 00:31:12,799
includes or something that happens to be

00:31:09,760 --> 00:31:16,559
ignored by labels tdc plus

00:31:12,799 --> 00:31:16,559
this is what you want to use

00:31:16,720 --> 00:31:19,919
but there's also lip c plus plus which

00:31:18,880 --> 00:31:23,600
is part of

00:31:19,919 --> 00:31:25,919
llvm uh comes with clang

00:31:23,600 --> 00:31:28,960
it's newer and smaller than the c plus

00:31:25,919 --> 00:31:31,679
plus than the best tdc plus plus

00:31:28,960 --> 00:31:34,000
it carries less craft that's needed only

00:31:31,679 --> 00:31:36,240
to support ancient code

00:31:34,000 --> 00:31:38,080
most benchmarks should perform better

00:31:36,240 --> 00:31:39,760
and also show it to be more memory

00:31:38,080 --> 00:31:41,679
efficient

00:31:39,760 --> 00:31:44,480
but there's a problem there you can't

00:31:41,679 --> 00:31:45,519
mix the labor cdc plus plus on dip c

00:31:44,480 --> 00:31:47,600
plus plus

00:31:45,519 --> 00:31:49,039
because they export the same symbols but

00:31:47,600 --> 00:31:52,559
they are not

00:31:49,039 --> 00:31:52,880
fully binary compatible so you get into

00:31:52,559 --> 00:31:54,640
an

00:31:52,880 --> 00:31:57,440
interesting situation when you have for

00:31:54,640 --> 00:31:58,240
example qt built against slip c plus

00:31:57,440 --> 00:32:00,159
plus

00:31:58,240 --> 00:32:02,080
and then you grab a binary that was

00:32:00,159 --> 00:32:04,000
built on some other distribution

00:32:02,080 --> 00:32:05,679
with the qt that was built against

00:32:04,000 --> 00:32:07,919
libba's tdc plus plus

00:32:05,679 --> 00:32:09,360
then that binary wants to call into

00:32:07,919 --> 00:32:12,159
functions from both

00:32:09,360 --> 00:32:13,360
stl implementations and that's not going

00:32:12,159 --> 00:32:17,120
to work that's just

00:32:13,360 --> 00:32:19,919
going to crash so

00:32:17,120 --> 00:32:21,760
if you expect running into a situation

00:32:19,919 --> 00:32:24,080
where your user

00:32:21,760 --> 00:32:26,640
will end up running third-party binaries

00:32:24,080 --> 00:32:28,320
built against something else

00:32:26,640 --> 00:32:30,559
that's the main reason why you don't

00:32:28,320 --> 00:32:32,320
want to use lipstick plus that's why we

00:32:30,559 --> 00:32:35,279
aren't using it in openmandriva even

00:32:32,320 --> 00:32:35,279
though we'd like to

00:32:36,240 --> 00:32:40,399
one interesting thing is that

00:32:37,760 --> 00:32:42,320
third-party applications like chromium

00:32:40,399 --> 00:32:44,080
increasingly just embed their own copy

00:32:42,320 --> 00:32:46,080
of lipsy plus plus

00:32:44,080 --> 00:32:47,840
obviously they can do it because they

00:32:46,080 --> 00:32:50,080
don't expect anything else to link

00:32:47,840 --> 00:32:52,799
against their binaries

00:32:50,080 --> 00:32:55,600
so they make sure that anything that is

00:32:52,799 --> 00:32:57,760
linked against it is

00:32:55,600 --> 00:32:58,880
not linked against any system library

00:32:57,760 --> 00:33:02,159
that

00:32:58,880 --> 00:33:03,679
would be using a different stl so if you

00:33:02,159 --> 00:33:06,159
want to go their way of

00:33:03,679 --> 00:33:08,080
essentially including an entire

00:33:06,159 --> 00:33:11,200
distribution in your binary

00:33:08,080 --> 00:33:13,840
bibc plus is certainly also a really

00:33:11,200 --> 00:33:13,840
good option

00:33:14,880 --> 00:33:18,799
for the sake of completeness there's

00:33:16,640 --> 00:33:21,360
ucla c plus plus

00:33:18,799 --> 00:33:22,840
which was an attempt for to write an stl

00:33:21,360 --> 00:33:24,799
implementation to go along with your

00:33:22,840 --> 00:33:28,640
sealebc

00:33:24,799 --> 00:33:30,399
the an interesting feature there is that

00:33:28,640 --> 00:33:33,200
you can

00:33:30,399 --> 00:33:36,840
strip out some parts of the stl but the

00:33:33,200 --> 00:33:38,640
last commit to it was in 2016

00:33:36,840 --> 00:33:40,960
so there's

00:33:38,640 --> 00:33:43,679
no good chance you don't want to use

00:33:40,960 --> 00:33:43,679
this anymore

00:33:44,960 --> 00:33:50,840
um we have some more questions

00:33:48,559 --> 00:33:52,240
one is can we use g lips or muscle with

00:33:50,840 --> 00:33:55,039
clang

00:33:52,240 --> 00:33:55,360
the answer for muscle is yes it works

00:33:55,039 --> 00:33:58,240
with

00:33:55,360 --> 00:34:00,159
either compiler you can probably even

00:33:58,240 --> 00:34:01,440
build it with tiny cc if you feel like

00:34:00,159 --> 00:34:04,399
it i haven't tried it but

00:34:01,440 --> 00:34:06,480
i don't see why it wouldn't work and for

00:34:04,399 --> 00:34:08,639
g lipsy

00:34:06,480 --> 00:34:10,639
the answer is not at the moment but

00:34:08,639 --> 00:34:13,040
there's a couple of patches for an older

00:34:10,639 --> 00:34:16,480
version

00:34:13,040 --> 00:34:19,520
that make it sort of work so

00:34:16,480 --> 00:34:22,480
if someone wants to port those patches

00:34:19,520 --> 00:34:25,599
to account ellipses

00:34:22,480 --> 00:34:26,079
that would make it possible and that

00:34:25,599 --> 00:34:28,720
would

00:34:26,079 --> 00:34:29,440
definitely be interesting for the future

00:34:28,720 --> 00:34:31,839
and i'll

00:34:29,440 --> 00:34:35,839
probably try to do that at some point

00:34:31,839 --> 00:34:35,839
but right now i just don't have the time

00:34:37,280 --> 00:34:42,480
the other one is how muscle provides

00:34:39,839 --> 00:34:45,440
better memory efficient lipsy

00:34:42,480 --> 00:34:46,159
the which i guess is why is muscle

00:34:45,440 --> 00:34:50,639
smaller than

00:34:46,159 --> 00:34:53,119
the gillipsie essentially it's

00:34:50,639 --> 00:34:54,240
mostly by the air leaving out the

00:34:53,119 --> 00:34:57,440
support for

00:34:54,240 --> 00:34:59,040
older obsolete standards and by having

00:34:57,440 --> 00:35:02,240
smaller implementations of

00:34:59,040 --> 00:35:04,160
some of the functions

00:35:02,240 --> 00:35:05,359
i hope that answers all the questions so

00:35:04,160 --> 00:35:09,040
far

00:35:05,359 --> 00:35:09,040
let's go on to the next thing

00:35:10,320 --> 00:35:16,880
conclusions for c plus support is

00:35:13,520 --> 00:35:18,720
essentially if binary compatibility

00:35:16,880 --> 00:35:21,280
with other linux distributions is a big

00:35:18,720 --> 00:35:22,400
concern you really want to go with flip

00:35:21,280 --> 00:35:25,040
stdc plus

00:35:22,400 --> 00:35:26,880
because that's what everyone is using

00:35:25,040 --> 00:35:28,960
but if you're using clang and you care

00:35:26,880 --> 00:35:30,640
about performance and memory efficiency

00:35:28,960 --> 00:35:32,880
modern compatibility

00:35:30,640 --> 00:35:35,359
libc plus is something you clearly want

00:35:32,880 --> 00:35:35,359
to look at

00:35:37,040 --> 00:35:42,839
okay lastly we want to take a look at

00:35:40,320 --> 00:35:44,000
what the right thing to do is in a

00:35:42,839 --> 00:35:45,920
distribution

00:35:44,000 --> 00:35:47,119
given there's no clear best option for

00:35:45,920 --> 00:35:48,800
everything

00:35:47,119 --> 00:35:50,400
a distribution should try to support

00:35:48,800 --> 00:35:54,560
developers for all

00:35:50,400 --> 00:35:55,839
options i'm going to talk about some

00:35:54,560 --> 00:35:57,680
things we've already done in

00:35:55,839 --> 00:36:00,880
openmantriva and that you can be doing

00:35:57,680 --> 00:36:02,560
in your favorite distribution as well

00:36:00,880 --> 00:36:04,560
and a few things that we are planning to

00:36:02,560 --> 00:36:07,680
do in the next couple of versions

00:36:04,560 --> 00:36:12,480
that would also be good to be

00:36:07,680 --> 00:36:14,400
adopted a bit more rightly one thing you

00:36:12,480 --> 00:36:15,440
want to do is keep your cross compilers

00:36:14,400 --> 00:36:17,599
up to date

00:36:15,440 --> 00:36:19,359
with clang that is something that

00:36:17,599 --> 00:36:20,400
happens automatically because the cross

00:36:19,359 --> 00:36:24,320
compilers are

00:36:20,400 --> 00:36:28,000
all in the same binary anyway

00:36:24,320 --> 00:36:29,839
but with gcc you often end up

00:36:28,000 --> 00:36:32,560
packaging one cross compiler and then

00:36:29,839 --> 00:36:35,520
leaving it there it works it works and

00:36:32,560 --> 00:36:37,119
you update the system gcc you update the

00:36:35,520 --> 00:36:38,640
system gcc again and the

00:36:37,119 --> 00:36:40,640
cross compiler remains at the old

00:36:38,640 --> 00:36:43,839
version that's just

00:36:40,640 --> 00:36:46,160
not the way it should be done so

00:36:43,839 --> 00:36:47,440
the best way to do it is to build the

00:36:46,160 --> 00:36:49,680
cross compilers

00:36:47,440 --> 00:36:50,960
if you are packaging any from the same

00:36:49,680 --> 00:36:54,320
source as the

00:36:50,960 --> 00:36:57,359
main version of gcc um that

00:36:54,320 --> 00:36:59,359
can be done quite easily

00:36:57,359 --> 00:37:01,200
we figured out how to do it in the open

00:36:59,359 --> 00:37:03,839
driver packages if you want to

00:37:01,200 --> 00:37:04,480
see how we've done it i've put a link to

00:37:03,839 --> 00:37:07,680
the

00:37:04,480 --> 00:37:10,640
package source in

00:37:07,680 --> 00:37:12,320
the slides this is using rpm but

00:37:10,640 --> 00:37:13,520
obviously you can do the same thing with

00:37:12,320 --> 00:37:17,520
other package managers

00:37:13,520 --> 00:37:20,560
and essentially the idea is simply

00:37:17,520 --> 00:37:22,160
using a ford loop that

00:37:20,560 --> 00:37:24,400
builds all the cross compilers at the

00:37:22,160 --> 00:37:25,760
same time from the same source with the

00:37:24,400 --> 00:37:27,760
same patches

00:37:25,760 --> 00:37:30,240
so you will always keep your tool chains

00:37:27,760 --> 00:37:30,240
in sync

00:37:30,800 --> 00:37:36,240
next up is file system changes we used

00:37:34,079 --> 00:37:37,119
to have the situation that is just user

00:37:36,240 --> 00:37:40,240
lib and then

00:37:37,119 --> 00:37:43,520
some distributions added user lib64 some

00:37:40,240 --> 00:37:47,280
added user lib32 to make sure that

00:37:43,520 --> 00:37:50,480
64-bit and 32-bit binaries can co-exist

00:37:47,280 --> 00:37:53,200
but that's really no longer sufficient

00:37:50,480 --> 00:37:54,079
there's multiple apis so for example on

00:37:53,200 --> 00:37:57,680
arm you have

00:37:54,079 --> 00:38:00,880
one 64-bit api but there's

00:37:57,680 --> 00:38:01,760
multiple 32-bit uh like you have eabi

00:38:00,880 --> 00:38:05,839
versus the

00:38:01,760 --> 00:38:09,040
old api you have neon versus non-neon

00:38:05,839 --> 00:38:11,760
and you might need to have more than two

00:38:09,040 --> 00:38:14,880
of those on one system

00:38:11,760 --> 00:38:16,640
and of course qemu bin fmt is coming

00:38:14,880 --> 00:38:18,720
along really nicely making it

00:38:16,640 --> 00:38:21,440
possible to run code for different cpus

00:38:18,720 --> 00:38:23,520
without the user even noticing it

00:38:21,440 --> 00:38:25,040
so if only you had all the libraries in

00:38:23,520 --> 00:38:27,839
the right place

00:38:25,040 --> 00:38:28,560
you could run x86 windows applications

00:38:27,839 --> 00:38:31,200
and vine

00:38:28,560 --> 00:38:33,839
on an arm box the user wouldn't even

00:38:31,200 --> 00:38:33,839
have to notice

00:38:35,680 --> 00:38:41,440
so some distributions

00:38:38,720 --> 00:38:42,240
most of the debian derivatives have

00:38:41,440 --> 00:38:45,359
already

00:38:42,240 --> 00:38:47,359
opted for a solution there they are now

00:38:45,359 --> 00:38:50,320
creating user lib triplet

00:38:47,359 --> 00:38:52,960
uh so you have for example user lib x86

00:38:50,320 --> 00:38:54,240
linux canoe and user lib air 64 linux

00:38:52,960 --> 00:38:56,000
canoe

00:38:54,240 --> 00:38:57,680
which is a step in the right direction

00:38:56,000 --> 00:39:00,880
but i think

00:38:57,680 --> 00:39:03,839
there's a way to do it even better

00:39:00,880 --> 00:39:06,240
which is going for user triplet lib

00:39:03,839 --> 00:39:08,480
instead of user lit triplet

00:39:06,240 --> 00:39:09,839
because this allows combining the real

00:39:08,480 --> 00:39:12,160
file system you have for the cross

00:39:09,839 --> 00:39:15,599
compiler this root so essentially

00:39:12,160 --> 00:39:18,560
your user arc 64 linux new is

00:39:15,599 --> 00:39:20,079
at the same time this root for your ax64

00:39:18,560 --> 00:39:23,040
cross compiler

00:39:20,079 --> 00:39:23,839
and a place for libraries that will be

00:39:23,040 --> 00:39:27,119
picked up by

00:39:23,839 --> 00:39:30,320
qmu if you try to run an

00:39:27,119 --> 00:39:30,320
arm 64 binary

00:39:31,599 --> 00:39:41,119
you can also put includes that are the

00:39:36,640 --> 00:39:43,760
not the architecture independent

00:39:41,119 --> 00:39:46,640
for example headers that uh hard code

00:39:43,760 --> 00:39:49,359
32-bit or 64-bit references

00:39:46,640 --> 00:39:51,839
in include directory the uh that belongs

00:39:49,359 --> 00:39:53,520
there and you can override binaries

00:39:51,839 --> 00:39:56,079
for the couple of places where it's

00:39:53,520 --> 00:39:57,839
necessary to have different binaries

00:39:56,079 --> 00:40:00,400
thankfully that's only needed for a few

00:39:57,839 --> 00:40:03,520
libraries so for example

00:40:00,400 --> 00:40:05,440
some older libraries don't use pkg

00:40:03,520 --> 00:40:06,480
configure so to find stuff but they have

00:40:05,440 --> 00:40:10,079
some

00:40:06,480 --> 00:40:12,480
whatever library dash config binary that

00:40:10,079 --> 00:40:14,240
gets all the information and then you

00:40:12,480 --> 00:40:16,400
don't typically want to use the

00:40:14,240 --> 00:40:19,760
64-bit version to compile a 32-bit

00:40:16,400 --> 00:40:19,760
binary or vice versa

00:40:23,119 --> 00:40:31,359
in it this type of file system change

00:40:28,160 --> 00:40:32,400
also makes it possible to keep all the

00:40:31,359 --> 00:40:35,200
compatibility with

00:40:32,400 --> 00:40:38,319
all the systems you want because you can

00:40:35,200 --> 00:40:41,920
just create a sim linked uh

00:40:38,319 --> 00:40:44,319
that links the triplet slash lib

00:40:41,920 --> 00:40:45,119
directory that you created and this

00:40:44,319 --> 00:40:48,720
changed

00:40:45,119 --> 00:40:53,839
to the traditional directory name

00:40:48,720 --> 00:40:53,839
whether that was slip or lip 32 or lip64

00:40:55,920 --> 00:40:59,200
so that's pretty much what i had to say

00:40:58,319 --> 00:41:02,000
about

00:40:59,200 --> 00:41:03,040
tool chain options i'm still going to

00:41:02,000 --> 00:41:06,240
take questions

00:41:03,040 --> 00:41:08,079
feedback obviously if you have any spare

00:41:06,240 --> 00:41:11,599
specs of cash

00:41:08,079 --> 00:41:12,880
so now is a good time to ask or you can

00:41:11,599 --> 00:41:16,560
email me

00:41:12,880 --> 00:41:16,560
or find me on dislike channels in the

00:41:18,839 --> 00:41:21,839
conference

00:41:33,440 --> 00:41:38,400
okay it doesn't look like we are getting

00:41:35,520 --> 00:41:38,400
more questions

00:41:38,800 --> 00:41:41,839
oh it does something

00:41:42,720 --> 00:41:49,040
let me see okay that's

00:41:47,520 --> 00:41:52,400
there's actually some questions coming

00:41:49,040 --> 00:41:55,920
in i just didn't spot them because uh

00:41:52,400 --> 00:41:56,400
the window was scrolled out so one was

00:41:55,920 --> 00:41:58,720
what does

00:41:56,400 --> 00:41:59,760
stl mean it's the standard template

00:41:58,720 --> 00:42:02,800
library

00:41:59,760 --> 00:42:05,359
that's just did c

00:42:02,800 --> 00:42:07,440
plus plus standard library so standard

00:42:05,359 --> 00:42:09,200
template library libra cdc plus plus

00:42:07,440 --> 00:42:12,880
slip c plus plus

00:42:09,200 --> 00:42:17,280
all the same so

00:42:12,880 --> 00:42:19,440
another question was um

00:42:17,280 --> 00:42:22,160
can glipscy be built leaving out the

00:42:19,440 --> 00:42:25,440
older legacy functionality

00:42:22,160 --> 00:42:26,640
not by itself but obviously if you're

00:42:25,440 --> 00:42:30,960
comfortable with

00:42:26,640 --> 00:42:34,880
tweaking make files editing stuff

00:42:30,960 --> 00:42:38,160
you can adjust it the code is open so

00:42:34,880 --> 00:42:40,640
if you want to do it certainly

00:42:38,160 --> 00:42:40,640
you can

00:42:42,160 --> 00:42:47,119
next question what do you think about

00:42:44,240 --> 00:42:48,880
function multiversioning to support

00:42:47,119 --> 00:42:51,440
for support of multiple args in one

00:42:48,880 --> 00:42:55,520
binary is this a possible solution that

00:42:51,440 --> 00:42:58,079
could minimize os file system size

00:42:55,520 --> 00:42:58,880
i haven't actually seen an option that

00:42:58,079 --> 00:43:01,920
would allow

00:42:58,880 --> 00:43:05,359
the multi-versioning

00:43:01,920 --> 00:43:08,240
for completely different architectures

00:43:05,359 --> 00:43:10,560
like that would allow a 64-bit arm in

00:43:08,240 --> 00:43:12,000
the 32-bit x86 version of the same

00:43:10,560 --> 00:43:15,920
function in the same

00:43:12,000 --> 00:43:19,359
library i might be wrong about this

00:43:15,920 --> 00:43:19,359
i've certainly never seen it

00:43:19,440 --> 00:43:23,040
but the drawback of that obviously is

00:43:22,160 --> 00:43:24,640
that it

00:43:23,040 --> 00:43:26,880
makes it hard to strip out stuff you

00:43:24,640 --> 00:43:30,160
don't need so for example

00:43:26,880 --> 00:43:30,160
if you're building the

00:43:30,720 --> 00:43:35,280
distribution for an album system and you

00:43:32,880 --> 00:43:38,880
want vine to run

00:43:35,280 --> 00:43:41,839
the so you need to x86 32 and

00:43:38,880 --> 00:43:41,839
64.

00:43:46,880 --> 00:43:53,280
there's no way the user could

00:43:50,319 --> 00:43:54,000
just decide i don't want to use wine

00:43:53,280 --> 00:43:56,480
anyway so

00:43:54,000 --> 00:43:57,520
let me just strip out all the x86 crap

00:43:56,480 --> 00:44:00,720
of the

00:43:57,520 --> 00:44:04,079
from the library so

00:44:00,720 --> 00:44:06,400
for this particular thing i don't think

00:44:04,079 --> 00:44:10,640
that's really much of an option

00:44:06,400 --> 00:44:12,960
obviously it is interesting for stuff um

00:44:10,640 --> 00:44:15,760
that you are targeting for example in

00:44:12,960 --> 00:44:18,319
intel x86 and amd x86

00:44:15,760 --> 00:44:19,760
with slightly different options where

00:44:18,319 --> 00:44:21,440
most of the functions

00:44:19,760 --> 00:44:25,200
can actually be the same and you just

00:44:21,440 --> 00:44:28,960
want specific functions optimized for

00:44:25,200 --> 00:44:28,960
for one particular processor

00:44:33,839 --> 00:44:39,200
okay i think that's all of this there's

00:44:37,119 --> 00:44:42,240
a couple more

00:44:39,200 --> 00:44:45,359
so-called questions saying thank you

00:44:42,240 --> 00:44:48,640
well of course i'm returning that

00:44:45,359 --> 00:45:05,839
thank you all too and

00:44:48,640 --> 00:45:05,839
i keep checking for messages for a bit

00:45:31,680 --> 00:45:37,280
okay unless i've missed anything the uh

00:45:34,560 --> 00:45:40,560
you got all the questions covered

00:45:37,280 --> 00:45:46,880
so thanks for attending and

00:45:40,560 --> 00:45:48,560
of it the new question just came in

00:45:46,880 --> 00:45:51,839
which is clang supporting new

00:45:48,560 --> 00:45:55,280
instructions for arm x86

00:45:51,839 --> 00:45:57,839
the answer to that is yes

00:45:55,280 --> 00:45:59,040
it generally adds support for them quite

00:45:57,839 --> 00:46:01,520
quickly

00:45:59,040 --> 00:46:03,920
occasionally the head of gcc mostly a

00:46:01,520 --> 00:46:07,359
little bit behind gcc

00:46:03,920 --> 00:46:08,560
but yeah usually the support is in quite

00:46:07,359 --> 00:46:11,760
quickly you can use

00:46:08,560 --> 00:46:14,970
stuff like dash march equals

00:46:11,760 --> 00:46:16,560
zen version 2 or march equals

00:46:14,970 --> 00:46:19,680
[Music]

00:46:16,560 --> 00:46:19,680
skylake or whatever

00:46:23,119 --> 00:46:26,160
okay another one is

00:46:26,720 --> 00:46:29,920
any idea why biltrude doesn't support

00:46:28,640 --> 00:46:33,839
clang yet

00:46:29,920 --> 00:46:36,720
um unfortunately no i have no idea

00:46:33,839 --> 00:46:41,280
probably because the maintainer doesn't

00:46:36,720 --> 00:46:43,680
like it or likes gcc better

00:46:41,280 --> 00:46:44,720
but uh i'm pretty sure if someone wants

00:46:43,680 --> 00:46:48,800
to they would

00:46:44,720 --> 00:46:49,119
take a patch okay and there's another

00:46:48,800 --> 00:46:53,280
one

00:46:49,119 --> 00:46:55,680
any word on debuggers essentially

00:46:53,280 --> 00:46:57,839
we have gdb which has been the default

00:46:55,680 --> 00:47:00,880
for for a long time

00:46:57,839 --> 00:47:01,280
we also have lldb which is the version

00:47:00,880 --> 00:47:05,680
of

00:47:01,280 --> 00:47:08,800
that comes with llvm the

00:47:05,680 --> 00:47:11,599
essentially the that is getting there as

00:47:08,800 --> 00:47:13,839
well i haven't used it a lot yet

00:47:11,599 --> 00:47:16,079
but it looks promising as well so those

00:47:13,839 --> 00:47:17,599
two are certainly things to keep in mind

00:47:16,079 --> 00:47:19,920
and

00:47:17,599 --> 00:47:23,440
i'm not aware of any options that are

00:47:19,920 --> 00:47:26,720
not based on either of those but

00:47:23,440 --> 00:47:28,079
there might be any i just haven't had

00:47:26,720 --> 00:47:29,119
much of a need to go looking for

00:47:28,079 --> 00:47:31,920
anything else because

00:47:29,119 --> 00:47:34,160
gdb and lldb do pretty much everything i

00:47:31,920 --> 00:47:34,160
need

00:47:36,720 --> 00:47:42,640
okay i think i've caught up so let's

00:47:40,559 --> 00:47:45,520
check for a second longer if there's new

00:47:42,640 --> 00:47:45,520
questions coming in

00:47:46,720 --> 00:47:55,359
but i think we are done

00:47:52,079 --> 00:47:57,280
others another one what would you say is

00:47:55,359 --> 00:47:59,760
the more stable variant of lipsy for

00:47:57,280 --> 00:48:01,920
embedded use

00:47:59,760 --> 00:48:04,480
that's a good question they are all

00:48:01,920 --> 00:48:04,480
pretty good

00:48:04,800 --> 00:48:11,680
um so embedded use

00:48:08,160 --> 00:48:15,119
obviously can mean anything

00:48:11,680 --> 00:48:16,160
from a cortex-m to a relatively high-end

00:48:15,119 --> 00:48:20,480
device like

00:48:16,160 --> 00:48:22,559
a modern smartphone um

00:48:20,480 --> 00:48:24,559
there it really makes sense to look at

00:48:22,559 --> 00:48:27,359
the exact things you need

00:48:24,559 --> 00:48:28,319
glibc is obviously the option that has

00:48:27,359 --> 00:48:30,960
been used on

00:48:28,319 --> 00:48:33,200
everything for a long time so that is a

00:48:30,960 --> 00:48:36,880
good default but

00:48:33,200 --> 00:48:38,720
if you need to save more space muscle is

00:48:36,880 --> 00:48:40,640
probably more interesting

00:48:38,720 --> 00:48:42,319
possibly also you see lipsy if you want

00:48:40,640 --> 00:48:44,240
to strip out parts but if you're looking

00:48:42,319 --> 00:48:49,839
for a full-fledged one

00:48:44,240 --> 00:48:49,839
i'd go with muscle

00:48:49,920 --> 00:48:54,559
if you're building a phone then maybe

00:48:52,559 --> 00:48:57,520
bionic is also

00:48:54,559 --> 00:48:58,880
an interesting option because thanks to

00:48:57,520 --> 00:49:01,520
android that has a lot of

00:48:58,880 --> 00:49:04,160
that has had a lot of testing in that

00:49:01,520 --> 00:49:04,160
context

00:49:11,359 --> 00:49:17,839
okay let's see

00:49:23,520 --> 00:49:26,800
okay it doesn't look like new stuff is

00:49:25,760 --> 00:49:30,160
coming in right now

00:49:26,800 --> 00:49:33,280
so i think we are done and if you have

00:49:30,160 --> 00:49:34,160
oh wait there's another one it's a

00:49:33,280 --> 00:49:35,920
comment saying

00:49:34,160 --> 00:49:37,680
muzzle is a nice option because of its

00:49:35,920 --> 00:49:39,359
mit license you can build static

00:49:37,680 --> 00:49:41,200
binaries without the constraints of the

00:49:39,359 --> 00:49:45,440
lgbl license

00:49:41,200 --> 00:49:48,720
yeah that's true obviously the

00:49:45,440 --> 00:49:50,960
being an open source guy i think that

00:49:48,720 --> 00:49:51,839
regardless of what the license forces

00:49:50,960 --> 00:49:56,160
you to do

00:49:51,839 --> 00:49:58,000
you should be releasing your code but

00:49:56,160 --> 00:50:00,000
if for some reason you can't do that

00:49:58,000 --> 00:50:12,640
obviously the mit license is another

00:50:00,000 --> 00:50:14,640
reason to go with muzzle

00:50:12,640 --> 00:50:17,359
okay so we've had a couple of questions

00:50:14,640 --> 00:50:17,920
some feedback no bags of cash yet so you

00:50:17,359 --> 00:50:21,040
still

00:50:17,920 --> 00:50:21,040
might want to send those

00:50:22,160 --> 00:50:26,079
ah another thing coming in ah just

00:50:25,200 --> 00:50:28,880
thanks well

00:50:26,079 --> 00:50:28,880
thanks to you too

00:50:36,240 --> 00:50:42,480
okay and then i guess we are done

00:50:39,359 --> 00:50:44,079
thank you for attending and hope to see

00:50:42,480 --> 00:50:47,440
you at the next tlc

00:50:44,079 --> 00:50:50,880
whether it's virtual oreo

00:50:47,440 --> 00:50:53,359
and have a nice rest of the day

00:50:50,880 --> 00:50:54,319
and if you have anything else feel free

00:50:53,359 --> 00:50:56,559
to

00:50:54,319 --> 00:50:57,839
contact me by email or find me on the

00:50:56,559 --> 00:51:09,839
slack channel

00:50:57,839 --> 00:51:09,839
which would be two track linux systems

00:51:13,520 --> 00:51:15,599

YouTube URL: https://www.youtube.com/watch?v=BHaXqXzAs0Y


