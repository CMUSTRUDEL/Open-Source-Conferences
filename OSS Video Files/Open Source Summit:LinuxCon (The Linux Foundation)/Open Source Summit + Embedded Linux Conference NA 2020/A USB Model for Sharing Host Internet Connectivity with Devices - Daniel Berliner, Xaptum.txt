Title: A USB Model for Sharing Host Internet Connectivity with Devices - Daniel Berliner, Xaptum
Publication date: 2020-09-08
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	A USB Model for Sharing Host Internet Connectivity with Devices - Daniel Berliner, Xaptum
Captions: 
	00:00:02,800 --> 00:00:06,480
all right let's get started

00:00:04,480 --> 00:00:08,880
uh in this talk we're going to be going

00:00:06,480 --> 00:00:10,880
over a new protocol i've been working on

00:00:08,880 --> 00:00:14,480
at zapdom called host stock

00:00:10,880 --> 00:00:16,640
host socket sharing or hss

00:00:14,480 --> 00:00:18,320
this allows a usb host to share its

00:00:16,640 --> 00:00:19,279
internet connection with the connected

00:00:18,320 --> 00:00:20,800
device

00:00:19,279 --> 00:00:23,920
before jumping into that i want to

00:00:20,800 --> 00:00:26,320
briefly introduce myself

00:00:23,920 --> 00:00:28,840
my name is daniel berliner and i am a

00:00:26,320 --> 00:00:30,080
principal product engineer at zapdom in

00:00:28,840 --> 00:00:32,880
chicago

00:00:30,080 --> 00:00:35,840
i mostly work on our firmware linux

00:00:32,880 --> 00:00:38,320
drivers and other linux needs

00:00:35,840 --> 00:00:39,280
at zapdom we provide a highly scalable

00:00:38,320 --> 00:00:43,040
solution for

00:00:39,280 --> 00:00:44,559
iot devices to connect to a secure ipv6

00:00:43,040 --> 00:00:46,960
overlay network

00:00:44,559 --> 00:00:48,079
that is globally routable but publicly

00:00:46,960 --> 00:00:50,480
invisible

00:00:48,079 --> 00:00:51,199
however contrary to what the sales team

00:00:50,480 --> 00:00:53,360
told me

00:00:51,199 --> 00:00:55,520
i'm here to present hss from a much more

00:00:53,360 --> 00:00:59,840
generic standpoint rather than going too

00:00:55,520 --> 00:00:59,840
far into our use cases for it

00:01:01,840 --> 00:01:05,920
in this talk i'm going to introduce the

00:01:03,680 --> 00:01:07,360
idea of having a usb host

00:01:05,920 --> 00:01:09,119
share its internet connection with the

00:01:07,360 --> 00:01:10,960
device discuss

00:01:09,119 --> 00:01:12,799
use cases where this approach is

00:01:10,960 --> 00:01:14,640
advantageous

00:01:12,799 --> 00:01:16,240
go over the protocol we wrote for

00:01:14,640 --> 00:01:17,759
accomplishing this

00:01:16,240 --> 00:01:20,960
and give an overview of the

00:01:17,759 --> 00:01:22,640
implementation we wrote for this as well

00:01:20,960 --> 00:01:24,640
the other reason that i'm giving this

00:01:22,640 --> 00:01:25,920
talk is to engage the open source

00:01:24,640 --> 00:01:27,799
community

00:01:25,920 --> 00:01:30,079
to look for ideas either on

00:01:27,799 --> 00:01:32,320
implementation or

00:01:30,079 --> 00:01:35,439
on the concept of this to see if we can

00:01:32,320 --> 00:01:37,600
make it more useful for more people

00:01:35,439 --> 00:01:38,720
during the talk if you have a question

00:01:37,600 --> 00:01:40,960
please do just

00:01:38,720 --> 00:01:43,759
send it i like to address questions as

00:01:40,960 --> 00:01:43,759
soon as they come in

00:01:45,040 --> 00:01:48,240
all right so the problem we're trying to

00:01:46,880 --> 00:01:51,119
solve here is

00:01:48,240 --> 00:01:51,759
to get a usb device to have an internet

00:01:51,119 --> 00:01:55,840
connection

00:01:51,759 --> 00:01:55,840
provided by the host it's plugged into

00:01:56,960 --> 00:02:03,840
this seems simple enough usb has

00:02:00,399 --> 00:02:06,840
ethernet over usb protocols and you can

00:02:03,840 --> 00:02:12,239
also do internet connection sharing over

00:02:06,840 --> 00:02:12,239
usb which is yeah one of the um

00:02:14,000 --> 00:02:17,040
yes yeah you could do some of the

00:02:15,280 --> 00:02:20,319
tethering over usb as

00:02:17,040 --> 00:02:21,440
sofia has commented uh however there's a

00:02:20,319 --> 00:02:23,760
few drawbacks

00:02:21,440 --> 00:02:25,280
internet connection sharing over a usb

00:02:23,760 --> 00:02:28,080
link requires uh

00:02:25,280 --> 00:02:28,480
nat or bridging which requires you to

00:02:28,080 --> 00:02:33,280
either

00:02:28,480 --> 00:02:35,200
select an ip subnet to use or run dhcp

00:02:33,280 --> 00:02:38,080
if you're going to be using any of the

00:02:35,200 --> 00:02:39,840
cdc classes

00:02:38,080 --> 00:02:42,160
those present difficulty going from

00:02:39,840 --> 00:02:42,879
device to host they were fundamentally

00:02:42,160 --> 00:02:46,400
designed

00:02:42,879 --> 00:02:46,800
from host to device the most common use

00:02:46,400 --> 00:02:49,040
case

00:02:46,800 --> 00:02:50,000
being a network interface card either

00:02:49,040 --> 00:02:53,200
through an ethernet

00:02:50,000 --> 00:02:55,280
port or through a wi-fi device

00:02:53,200 --> 00:02:57,040
they're also specific to ethernet if

00:02:55,280 --> 00:02:57,680
you're forwarding ethernet packets over

00:02:57,040 --> 00:02:59,519
the network

00:02:57,680 --> 00:03:00,959
you do have to know quite a bit about

00:02:59,519 --> 00:03:03,280
the network

00:03:00,959 --> 00:03:06,879
so neither of those are are easy

00:03:03,280 --> 00:03:06,879
solutions for what we're trying to do

00:03:10,239 --> 00:03:14,480
um primarily because they're not plug

00:03:12,560 --> 00:03:16,560
and play

00:03:14,480 --> 00:03:18,800
we need a solution that's idiot proof

00:03:16,560 --> 00:03:20,720
and user friendly

00:03:18,800 --> 00:03:23,360
you need to be able to just plug it in

00:03:20,720 --> 00:03:25,159
and have the connection

00:03:23,360 --> 00:03:26,400
without requiring a lot of user

00:03:25,159 --> 00:03:28,319
configuration

00:03:26,400 --> 00:03:31,280
or custom user space software on the

00:03:28,319 --> 00:03:35,040
host to manage it

00:03:31,280 --> 00:03:37,680
quad asks uh could we also use ipv6

00:03:35,040 --> 00:03:41,599
yes uh the purpose of this is for either

00:03:37,680 --> 00:03:41,599
ipv4 or ipv6

00:03:45,200 --> 00:03:49,760
all right so what we what we got

00:03:47,200 --> 00:03:50,480
together to solve this was a protocol we

00:03:49,760 --> 00:03:53,519
call host

00:03:50,480 --> 00:03:55,840
socket sharing this is a protocol that

00:03:53,519 --> 00:03:57,360
allows the connected device to open

00:03:55,840 --> 00:04:00,400
sockets on the host

00:03:57,360 --> 00:04:02,560
and virtually manage them this has a

00:04:00,400 --> 00:04:04,319
number of key advantages

00:04:02,560 --> 00:04:06,480
uh no special networking uh

00:04:04,319 --> 00:04:09,439
configuration is required

00:04:06,480 --> 00:04:11,519
the host can use the sorry the device

00:04:09,439 --> 00:04:14,000
can use the hosts internet connection

00:04:11,519 --> 00:04:16,320
as is even if it's a complex setup that

00:04:14,000 --> 00:04:19,840
requires quite a bit of negotiating with

00:04:16,320 --> 00:04:21,440
the routers furthermore any firewall

00:04:19,840 --> 00:04:24,880
rules are implicitly

00:04:21,440 --> 00:04:26,320
also applied to the device this meets

00:04:24,880 --> 00:04:28,240
our idiot-proof requirements

00:04:26,320 --> 00:04:29,680
you can just plug it in and have it work

00:04:28,240 --> 00:04:31,360
you don't need to know anything about

00:04:29,680 --> 00:04:33,520
the network

00:04:31,360 --> 00:04:34,800
and you most importantly don't need to

00:04:33,520 --> 00:04:37,360
change the network

00:04:34,800 --> 00:04:39,440
to send things over it this is an

00:04:37,360 --> 00:04:40,560
inversion from a lot of protocols you

00:04:39,440 --> 00:04:42,960
may be familiar with

00:04:40,560 --> 00:04:43,919
because it starts at the device and goes

00:04:42,960 --> 00:04:47,120
to the host

00:04:43,919 --> 00:04:50,400
rather than the other way around

00:04:47,120 --> 00:04:52,960
this operates by having a a driver on

00:04:50,400 --> 00:04:54,720
the device

00:04:52,960 --> 00:04:56,960
i'm sorry this operates by having a

00:04:54,720 --> 00:05:01,759
driver on the host that creates

00:04:56,960 --> 00:05:04,160
sockets on ip or ipv6 for tcp or udp

00:05:01,759 --> 00:05:05,039
and operates them at the request of the

00:05:04,160 --> 00:05:07,680
device

00:05:05,039 --> 00:05:09,840
usb is used to relay the data and

00:05:07,680 --> 00:05:12,160
commands over the wire from one to the

00:05:09,840 --> 00:05:12,160
other

00:05:13,759 --> 00:05:18,479
what kind of devices would want this

00:05:16,479 --> 00:05:20,160
well there's a number of use cases if

00:05:18,479 --> 00:05:22,560
you have a usb printer

00:05:20,160 --> 00:05:23,680
scanner or other interaction device that

00:05:22,560 --> 00:05:26,000
wants to

00:05:23,680 --> 00:05:27,440
download firmware updates or communicate

00:05:26,000 --> 00:05:29,120
with the cloud

00:05:27,440 --> 00:05:30,560
they could benefit from this so that

00:05:29,120 --> 00:05:33,360
they don't have to write

00:05:30,560 --> 00:05:35,199
custom specific drivers to the machine

00:05:33,360 --> 00:05:37,039
that they're running on

00:05:35,199 --> 00:05:39,680
many of these devices already use

00:05:37,039 --> 00:05:41,759
generic drivers for their purposes

00:05:39,680 --> 00:05:44,240
and could benefit from a standard model

00:05:41,759 --> 00:05:46,880
to handle network connections

00:05:44,240 --> 00:05:48,800
and i certainly know i would not miss

00:05:46,880 --> 00:05:50,320
setting up wi-fi on a printer

00:05:48,800 --> 00:05:52,560
i'm sure anyone who's done that would

00:05:50,320 --> 00:05:54,479
not miss it iot

00:05:52,560 --> 00:05:55,840
sensors connected to a gateway are

00:05:54,479 --> 00:05:57,840
another use case

00:05:55,840 --> 00:05:59,919
they often know what they need they know

00:05:57,840 --> 00:06:00,960
where they need it but they may lack the

00:05:59,919 --> 00:06:03,520
ability

00:06:00,960 --> 00:06:05,680
to connect themselves either through not

00:06:03,520 --> 00:06:08,639
having hardware or their hardware not

00:06:05,680 --> 00:06:10,639
being sufficient for the environment

00:06:08,639 --> 00:06:13,199
so a generic solution to communicate

00:06:10,639 --> 00:06:14,800
with their gateway would be helpful

00:06:13,199 --> 00:06:17,520
another use case we thought we've

00:06:14,800 --> 00:06:19,520
thought of is a hardware vpn dongle

00:06:17,520 --> 00:06:20,560
this is something that you'd send data

00:06:19,520 --> 00:06:23,680
into

00:06:20,560 --> 00:06:24,080
it would encrypt packetize and send data

00:06:23,680 --> 00:06:26,560
back

00:06:24,080 --> 00:06:27,360
out through its own uh secure key

00:06:26,560 --> 00:06:31,680
storage

00:06:27,360 --> 00:06:31,680
perhaps a tpm or its own crypto

00:06:32,840 --> 00:06:38,080
processors

00:06:35,680 --> 00:06:39,199
uh before we move on to discussing what

00:06:38,080 --> 00:06:40,880
this looks like or

00:06:39,199 --> 00:06:43,280
do we have any questions from a

00:06:40,880 --> 00:06:48,400
conceptual standpoint

00:06:43,280 --> 00:06:50,400
kind of from a high level

00:06:48,400 --> 00:06:52,479
all right well from the devices

00:06:50,400 --> 00:06:55,840
perspective

00:06:52,479 --> 00:07:00,639
um its user space applications will send

00:06:55,840 --> 00:07:03,120
data to a new socket family called afhss

00:07:00,639 --> 00:07:04,880
this outwardly behaves as if it were an

00:07:03,120 --> 00:07:07,440
inet socket

00:07:04,880 --> 00:07:10,240
but internally it bypasses the network

00:07:07,440 --> 00:07:11,039
stack and sends all its data through usb

00:07:10,240 --> 00:07:16,720
so it can be

00:07:11,039 --> 00:07:19,759
sent to the internet by the host

00:07:16,720 --> 00:07:20,560
from the host's perspective it has a usb

00:07:19,759 --> 00:07:22,960
driver

00:07:20,560 --> 00:07:24,880
that sits listening to the other side of

00:07:22,960 --> 00:07:27,599
the connection

00:07:24,880 --> 00:07:30,560
and forwarding these operations and data

00:07:27,599 --> 00:07:33,280
over the actual inet and inet 6 sockets

00:07:30,560 --> 00:07:33,280
it creates

00:07:34,319 --> 00:07:38,160
it also actively listens to all of these

00:07:36,720 --> 00:07:40,560
sockets

00:07:38,160 --> 00:07:41,680
and forwards the data it gets back

00:07:40,560 --> 00:07:44,240
asynchronously

00:07:41,680 --> 00:07:47,919
the device doesn't pull or ask if it has

00:07:44,240 --> 00:07:47,919
data to be read it just gets sent

00:07:49,039 --> 00:07:53,919
to accomplish this we created a

00:07:51,840 --> 00:07:56,080
relatively straightforward standard

00:07:53,919 --> 00:07:57,599
defining a number of commands data

00:07:56,080 --> 00:08:00,560
structures

00:07:57,599 --> 00:08:02,720
and algorithms for processing the data

00:08:00,560 --> 00:08:06,479
along with a few rules on

00:08:02,720 --> 00:08:09,199
which side can process what

00:08:06,479 --> 00:08:11,360
looks like we got another question here

00:08:09,199 --> 00:08:12,160
can the host firewall restrict packets

00:08:11,360 --> 00:08:16,080
by the device

00:08:12,160 --> 00:08:18,960
identity can usb devices be uniquely

00:08:16,080 --> 00:08:18,960
identified

00:08:19,039 --> 00:08:24,400
um i'm there's probably a way to write

00:08:22,319 --> 00:08:26,000
the host drivers that the firewall knows

00:08:24,400 --> 00:08:28,800
it's coming from one of the usb

00:08:26,000 --> 00:08:31,120
devices yes but that isn't a use case

00:08:28,800 --> 00:08:33,519
we've considered yet

00:08:31,120 --> 00:08:35,120
the usb devices can be uniquely

00:08:33,519 --> 00:08:37,839
identified

00:08:35,120 --> 00:08:39,919
and there may be a way to have to have

00:08:37,839 --> 00:08:41,760
the host socket manager pass that data

00:08:39,919 --> 00:08:43,360
onto the firewall so yes that that is

00:08:41,760 --> 00:08:45,360
certainly something that should be able

00:08:43,360 --> 00:08:48,320
to be accomplished

00:08:45,360 --> 00:08:48,320
a great question

00:08:48,560 --> 00:08:53,200
another one from jan could this be used

00:08:50,880 --> 00:08:57,120
to let the device listen on a port

00:08:53,200 --> 00:08:58,640
such as for a web ui yes it could that

00:08:57,120 --> 00:09:01,440
again would be something we'd have to

00:08:58,640 --> 00:09:02,640
expand into but that that definitely is

00:09:01,440 --> 00:09:09,839
a good use case

00:09:02,640 --> 00:09:09,839
uh i could see

00:09:10,480 --> 00:09:14,240
all right i'm going to try to keep this

00:09:12,080 --> 00:09:16,080
section relatively brief

00:09:14,240 --> 00:09:17,519
because reading a bunch of packet

00:09:16,080 --> 00:09:20,959
definitions to you

00:09:17,519 --> 00:09:24,240
doesn't make for a very interesting talk

00:09:20,959 --> 00:09:25,440
um the hss packets that we use here all

00:09:24,240 --> 00:09:29,040
have the same 12

00:09:25,440 --> 00:09:31,360
byte header this header consists of an

00:09:29,040 --> 00:09:34,720
op code describing the operation

00:09:31,360 --> 00:09:36,080
being done a message id that's used for

00:09:34,720 --> 00:09:37,920
acknowledgements to link an

00:09:36,080 --> 00:09:41,839
acknowledgement to the original

00:09:37,920 --> 00:09:44,720
command a sock id to identify

00:09:41,839 --> 00:09:45,760
which sock is being operated on and a

00:09:44,720 --> 00:09:47,600
payload length

00:09:45,760 --> 00:09:49,680
indicating if there's any additional

00:09:47,600 --> 00:09:53,760
data to the packet payload data

00:09:49,680 --> 00:09:56,240
immediately precedes the actual packet

00:09:53,760 --> 00:09:57,279
for all packets all numbers are unsigned

00:09:56,240 --> 00:10:00,080
integers and

00:09:57,279 --> 00:10:05,839
all multi-byte fields are little endian

00:10:00,080 --> 00:10:05,839
unless otherwise specified

00:10:06,079 --> 00:10:09,680
uh there's two types of commands here

00:10:08,079 --> 00:10:11,360
there's there's two types of packets

00:10:09,680 --> 00:10:13,839
there are command packets that have a

00:10:11,360 --> 00:10:16,240
maximum payload of 52 bytes so we'll

00:10:13,839 --> 00:10:18,240
discuss why in a few minutes

00:10:16,240 --> 00:10:21,120
these are your open close shutdown

00:10:18,240 --> 00:10:23,200
connect commands and acknowledgements

00:10:21,120 --> 00:10:24,640
and then there's data packets which have

00:10:23,200 --> 00:10:27,680
an arbitrary length

00:10:24,640 --> 00:10:29,760
and are ideal for uh

00:10:27,680 --> 00:10:33,839
and are ideal for sending larger amounts

00:10:29,760 --> 00:10:33,839
of data

00:10:35,040 --> 00:10:39,200
the first type of command we we have is

00:10:38,000 --> 00:10:41,200
an open command

00:10:39,200 --> 00:10:43,440
this is the first thing that initially

00:10:41,200 --> 00:10:44,240
creates a socket on the host this is

00:10:43,440 --> 00:10:47,680
always sent

00:10:44,240 --> 00:10:49,600
by the device to the host in addition to

00:10:47,680 --> 00:10:50,959
the header it always has a nine byte

00:10:49,600 --> 00:10:53,279
payload indicating

00:10:50,959 --> 00:10:55,519
the id of the socket for future

00:10:53,279 --> 00:10:58,399
operations that's handle

00:10:55,519 --> 00:10:59,279
the address family protocol and type as

00:10:58,399 --> 00:11:01,440
well

00:10:59,279 --> 00:11:03,600
this pretty closely mirrors the posix

00:11:01,440 --> 00:11:06,000
interface for the open command on a

00:11:03,600 --> 00:11:06,000
socket

00:11:06,240 --> 00:11:10,959
the next type of packet is the close

00:11:09,120 --> 00:11:13,600
command

00:11:10,959 --> 00:11:14,399
this closes a socket and can be sent by

00:11:13,600 --> 00:11:17,519
either side

00:11:14,399 --> 00:11:20,240
when sent by the host it indicates the

00:11:17,519 --> 00:11:22,640
remote pier has closed the socket

00:11:20,240 --> 00:11:25,279
when sent by the device it orders the

00:11:22,640 --> 00:11:27,040
host to close the socket

00:11:25,279 --> 00:11:28,320
these return an acknowledgement but like

00:11:27,040 --> 00:11:32,000
the posix interface

00:11:28,320 --> 00:11:32,000
don't have an actual return code

00:11:34,959 --> 00:11:38,079
the next command is shutdown this is

00:11:37,040 --> 00:11:40,079
this is a lot like

00:11:38,079 --> 00:11:42,160
close except it only indicates one

00:11:40,079 --> 00:11:44,079
direction if sent by the device

00:11:42,160 --> 00:11:46,640
it means the device will no longer send

00:11:44,079 --> 00:11:49,920
data if sent by the host it means the

00:11:46,640 --> 00:11:52,959
remote peer will no longer send data

00:11:49,920 --> 00:11:53,360
looks like we have another question i'm

00:11:52,959 --> 00:11:56,800
sorry

00:11:53,360 --> 00:11:59,839
i misread that

00:11:56,800 --> 00:12:02,160
that packet again returns an

00:11:59,839 --> 00:12:03,839
acknowledgement but it doesn't have a

00:12:02,160 --> 00:12:05,839
return code just like the posix

00:12:03,839 --> 00:12:09,519
interface

00:12:05,839 --> 00:12:10,000
next is connect this this connects to an

00:12:09,519 --> 00:12:12,959
address

00:12:10,000 --> 00:12:14,000
on an already open socket and like open

00:12:12,959 --> 00:12:17,040
is only sent

00:12:14,000 --> 00:12:20,240
from the device to the host uh

00:12:17,040 --> 00:12:22,240
in the case of an ipv4 address uh it

00:12:20,240 --> 00:12:24,480
contains an eight byte payload

00:12:22,240 --> 00:12:25,839
indicating the family the port and the

00:12:24,480 --> 00:12:27,519
ip address

00:12:25,839 --> 00:12:30,160
it's important to note that connect

00:12:27,519 --> 00:12:31,360
packets always send their addresses in

00:12:30,160 --> 00:12:33,279
network byte order

00:12:31,360 --> 00:12:34,480
because no matter what the endian-ness

00:12:33,279 --> 00:12:39,040
of the host

00:12:34,480 --> 00:12:41,839
it is expected to be in that format

00:12:39,040 --> 00:12:44,160
the connect for ipv6 is very similar

00:12:41,839 --> 00:12:47,760
except it accommodates the much larger

00:12:44,160 --> 00:12:51,279
ipv6 address with the family

00:12:47,760 --> 00:12:55,200
port flow info scope and the um

00:12:51,279 --> 00:12:55,200
the ipv6 address

00:12:56,079 --> 00:12:59,120
we've alluded to an acknowledgement a

00:12:57,839 --> 00:13:01,680
few times already

00:12:59,120 --> 00:13:02,720
and that that is the ack command it

00:13:01,680 --> 00:13:05,600
acknowledges

00:13:02,720 --> 00:13:06,800
a given op code and either sends a one

00:13:05,600 --> 00:13:09,760
byte

00:13:06,800 --> 00:13:12,240
response or a custom payload depending

00:13:09,760 --> 00:13:14,720
on the op code it's responding to

00:13:12,240 --> 00:13:15,760
uh right now we're mostly responding to

00:13:14,720 --> 00:13:17,680
these one bytes

00:13:15,760 --> 00:13:21,360
not not defining terribly complex

00:13:17,680 --> 00:13:23,600
returns but it has the ability

00:13:21,360 --> 00:13:25,200
finally there's the transmit command

00:13:23,600 --> 00:13:27,120
this sends and receives

00:13:25,200 --> 00:13:28,560
actual data from one side to the other

00:13:27,120 --> 00:13:30,399
for the sockets

00:13:28,560 --> 00:13:35,519
this is the header with an arbitrary

00:13:30,399 --> 00:13:38,560
payload that has the actual data on it

00:13:35,519 --> 00:13:42,880
looks like a question came in

00:13:38,560 --> 00:13:43,510
what about link scope ipv6 addresses

00:13:42,880 --> 00:13:46,399
you went to

00:13:43,510 --> 00:13:48,720
[Music]

00:13:46,399 --> 00:13:50,959
uh sorry let me go back on that slide

00:13:48,720 --> 00:13:50,959
there

00:13:55,199 --> 00:13:59,839
um this has this has all the fields that

00:13:57,519 --> 00:14:02,800
you that you use to connect as far as

00:13:59,839 --> 00:14:07,120
the um

00:14:02,800 --> 00:14:10,079
as far as the link scope goes i am not

00:14:07,120 --> 00:14:12,959
exactly familiar with what that is uh

00:14:10,079 --> 00:14:15,040
what we can talk about that afterwards

00:14:12,959 --> 00:14:17,839
um i can't spend too much time on that

00:14:15,040 --> 00:14:17,839
right now

00:14:22,320 --> 00:14:25,839
all right do you have any other

00:14:23,360 --> 00:14:30,000
questions about the packets before we

00:14:25,839 --> 00:14:32,079
move on

00:14:30,000 --> 00:14:34,000
my apologies i'm having a little trouble

00:14:32,079 --> 00:14:36,720
sifting through questions here the way

00:14:34,000 --> 00:14:36,720
they're coming up

00:14:39,199 --> 00:14:43,440
okay yeah claudia let's discuss this

00:14:41,199 --> 00:14:48,639
afterwards if i've made an omission

00:14:43,440 --> 00:14:48,639
i will make sure to uh to correct that

00:14:49,760 --> 00:14:55,040
all right in terms of requirements um

00:14:52,240 --> 00:14:56,480
this requires usb 2.0 although

00:14:55,040 --> 00:14:58,480
if you're dealing with anything that's

00:14:56,480 --> 00:15:00,480
remotely fast you're going to want usb

00:14:58,480 --> 00:15:03,279
3.0

00:15:00,480 --> 00:15:05,199
it requires two bulk endpoints for

00:15:03,279 --> 00:15:07,440
transferring the data packets

00:15:05,199 --> 00:15:10,880
and two interrupt end points for

00:15:07,440 --> 00:15:12,480
transferring the command packets

00:15:10,880 --> 00:15:14,079
because not everyone's here is going to

00:15:12,480 --> 00:15:16,480
be too familiar with usb

00:15:14,079 --> 00:15:17,519
development uh it's worth quickly going

00:15:16,480 --> 00:15:20,399
on in the side of

00:15:17,519 --> 00:15:22,000
what is an end point uh in usb driver

00:15:20,399 --> 00:15:24,639
development an endpoint

00:15:22,000 --> 00:15:26,000
is a buffer provided by usb to

00:15:24,639 --> 00:15:29,279
communicate from one side

00:15:26,000 --> 00:15:31,279
to the other these are unidirectional

00:15:29,279 --> 00:15:33,360
buffers and have a few different

00:15:31,279 --> 00:15:36,720
types that give you different guarantees

00:15:33,360 --> 00:15:39,519
with different restrictions

00:15:36,720 --> 00:15:41,279
bulk endpoints are ideal for handling

00:15:39,519 --> 00:15:43,839
large data packets without

00:15:41,279 --> 00:15:44,959
tight latency requirements writing data

00:15:43,839 --> 00:15:47,440
to a flash drive

00:15:44,959 --> 00:15:48,800
is a great example of this you don't

00:15:47,440 --> 00:15:50,639
particularly care

00:15:48,800 --> 00:15:52,320
how many milliseconds it takes for the

00:15:50,639 --> 00:15:54,720
packet to get there

00:15:52,320 --> 00:15:57,600
but you do care how quickly it can

00:15:54,720 --> 00:15:59,839
transfer a large final

00:15:57,600 --> 00:16:02,480
interrupt packets are ideal for small

00:15:59,839 --> 00:16:06,079
packets that need to arrive very quickly

00:16:02,480 --> 00:16:08,800
as the name suggests it triggers an

00:16:06,079 --> 00:16:11,440
actual interrupt on the usb interface

00:16:08,800 --> 00:16:14,240
and causes them to be read quickly there

00:16:11,440 --> 00:16:17,360
are interfaces that restrict these

00:16:14,240 --> 00:16:19,199
packets to 64 bytes thus the 52 byte

00:16:17,360 --> 00:16:21,680
requirement

00:16:19,199 --> 00:16:23,199
that i mentioned a bit earlier while we

00:16:21,680 --> 00:16:25,360
don't deal with them there's also

00:16:23,199 --> 00:16:26,639
iso synchronous packets that deal with

00:16:25,360 --> 00:16:28,480
data streams

00:16:26,639 --> 00:16:30,160
they lack a transmission guarantee so

00:16:28,480 --> 00:16:32,800
they're completely unsuitable for these

00:16:30,160 --> 00:16:32,800
purposes

00:16:33,199 --> 00:16:36,959
and then there's command packets or

00:16:35,279 --> 00:16:38,880
command end points which are used for

00:16:36,959 --> 00:16:41,360
configuring the device

00:16:38,880 --> 00:16:41,920
for more detailed info you can go to the

00:16:41,360 --> 00:16:44,639
usb

00:16:41,920 --> 00:16:47,440
standard chapter 5 describes this in a

00:16:44,639 --> 00:16:47,440
lot of detail

00:16:48,720 --> 00:16:52,480
anyway so for this implementation you

00:16:51,759 --> 00:16:55,440
need

00:16:52,480 --> 00:16:56,959
the two data the two bulk endpoints for

00:16:55,440 --> 00:16:58,880
transferring data packets

00:16:56,959 --> 00:17:01,199
and two interrupt endpoints for

00:16:58,880 --> 00:17:03,759
transferring command packets

00:17:01,199 --> 00:17:05,199
you also need a way to direct traffic

00:17:03,759 --> 00:17:08,240
from the device side

00:17:05,199 --> 00:17:10,480
socket onto the usb link we've

00:17:08,240 --> 00:17:11,520
for our purposes we've created a new

00:17:10,480 --> 00:17:15,439
type of socket

00:17:11,520 --> 00:17:17,360
that does that i do have any questions

00:17:15,439 --> 00:17:19,839
on the implementation

00:17:17,360 --> 00:17:19,839
so far

00:17:25,520 --> 00:17:30,799
why do you need why do you need two

00:17:28,799 --> 00:17:33,840
extra interrupt endpoints for the

00:17:30,799 --> 00:17:36,960
command could the command also be used

00:17:33,840 --> 00:17:37,520
over the bulk uh the answer is yes you

00:17:36,960 --> 00:17:39,280
could

00:17:37,520 --> 00:17:41,520
but the data end points may be

00:17:39,280 --> 00:17:44,640
transferring a large amount of data

00:17:41,520 --> 00:17:46,240
and you want to relay these much smaller

00:17:44,640 --> 00:17:47,840
commands with tighter latency

00:17:46,240 --> 00:17:50,720
requirements

00:17:47,840 --> 00:17:52,559
it does raise the resource requirements

00:17:50,720 --> 00:17:54,160
of the device a little

00:17:52,559 --> 00:17:55,840
but we didn't want to make these

00:17:54,160 --> 00:17:57,760
commands wait a long time for

00:17:55,840 --> 00:17:59,679
other sockets that may be processing

00:17:57,760 --> 00:18:02,320
some large portion of data

00:17:59,679 --> 00:18:02,320
good question

00:18:07,919 --> 00:18:11,919
all right then now i'm going to um sorry

00:18:10,400 --> 00:18:15,600
one more question

00:18:11,919 --> 00:18:17,039
from sofia sorry when we're popped up

00:18:15,600 --> 00:18:19,520
and i'm having some trouble reading the

00:18:17,039 --> 00:18:19,520
interface

00:18:26,960 --> 00:18:30,480
i'm sorry i'm just going to continue i'm

00:18:29,600 --> 00:18:33,760
going to get into

00:18:30,480 --> 00:18:36,000
our implementation right now um

00:18:33,760 --> 00:18:38,559
for this there's four basic components

00:18:36,000 --> 00:18:42,080
there's the network driver on the device

00:18:38,559 --> 00:18:45,200
side a usb driver on each side

00:18:42,080 --> 00:18:46,799
and a host hss driver that connects to

00:18:45,200 --> 00:18:48,880
the actual internet

00:18:46,799 --> 00:18:49,919
all these components are bi-directional

00:18:48,880 --> 00:18:53,280
in that they send

00:18:49,919 --> 00:18:56,000
and receive data the

00:18:53,280 --> 00:18:58,400
hss network driver on the device side

00:18:56,000 --> 00:18:59,919
operates the socket that the user space

00:18:58,400 --> 00:19:02,160
devices talk to

00:18:59,919 --> 00:19:03,760
it exports a number of functions that

00:19:02,160 --> 00:19:06,080
the usb driver

00:19:03,760 --> 00:19:06,799
knows to call and it accepts an

00:19:06,080 --> 00:19:09,280
interface

00:19:06,799 --> 00:19:10,080
for the usb driver to provide callbacks

00:19:09,280 --> 00:19:13,440
to be sent

00:19:10,080 --> 00:19:15,600
data the usb driver on the host

00:19:13,440 --> 00:19:17,679
and device do essentially the same thing

00:19:15,600 --> 00:19:18,880
they connect they maintain the usb

00:19:17,679 --> 00:19:21,919
interface

00:19:18,880 --> 00:19:25,039
and they pass data to their respective

00:19:21,919 --> 00:19:28,160
hss drivers on the host

00:19:25,039 --> 00:19:29,360
the hss driver is split into two logical

00:19:28,160 --> 00:19:33,520
parts there's one that

00:19:29,360 --> 00:19:37,280
unpacks the packets handles the

00:19:33,520 --> 00:19:40,799
handles the operation and

00:19:37,280 --> 00:19:42,799
has a manager to has a manager to deal

00:19:40,799 --> 00:19:53,840
with the actual inept sockets

00:19:42,799 --> 00:19:53,840
on the device side

00:19:54,240 --> 00:19:58,799
so for the device network driver as i've

00:19:57,200 --> 00:20:02,559
mentioned a few times already

00:19:58,799 --> 00:20:05,679
um it presents a new type of domain uh

00:20:02,559 --> 00:20:06,960
located on our tree at the net hss

00:20:05,679 --> 00:20:09,840
directory

00:20:06,960 --> 00:20:11,200
it behaves as similar as we can to an to

00:20:09,840 --> 00:20:12,720
an inet socket

00:20:11,200 --> 00:20:14,720
when dealing with user space

00:20:12,720 --> 00:20:17,360
applications

00:20:14,720 --> 00:20:19,200
however after that it behaves quite

00:20:17,360 --> 00:20:21,840
differently rather than packetizing

00:20:19,200 --> 00:20:22,880
things in tcp or udp and sending them to

00:20:21,840 --> 00:20:25,280
the ip layer

00:20:22,880 --> 00:20:26,960
it sends them sorry it packetizes them

00:20:25,280 --> 00:20:31,840
as hss

00:20:26,960 --> 00:20:31,840
and sends them to the usb driver

00:20:32,080 --> 00:20:35,840
it also has to keep track of socks so it

00:20:34,240 --> 00:20:37,360
knows um

00:20:35,840 --> 00:20:40,240
what it's dealing with when it gets an

00:20:37,360 --> 00:20:40,240
incoming packet

00:20:40,480 --> 00:20:46,080
the host and usb driver as i mentioned

00:20:42,799 --> 00:20:46,080
just maintained the channels

00:20:46,559 --> 00:20:54,000
and the host hss proxy

00:20:49,919 --> 00:20:54,000
i went over the slide here

00:20:58,000 --> 00:21:01,520
my apologies i made some last minute

00:20:59,760 --> 00:21:04,159
changes to these slides

00:21:01,520 --> 00:21:05,600
before i go into what the endpoints look

00:21:04,159 --> 00:21:07,360
like as they connect

00:21:05,600 --> 00:21:10,480
have i are there any questions on what

00:21:07,360 --> 00:21:10,480
i'm talking about so far

00:21:13,360 --> 00:21:17,280
all right well let's continue that um

00:21:15,600 --> 00:21:20,559
the flow of this happening

00:21:17,280 --> 00:21:22,960
when a usb device is plugged in is that

00:21:20,559 --> 00:21:24,159
the usb driver obviously is the first

00:21:22,960 --> 00:21:25,840
software to

00:21:24,159 --> 00:21:27,919
get the in to get the knowledge that

00:21:25,840 --> 00:21:31,200
it's been plugged in

00:21:27,919 --> 00:21:33,679
so the host usb driver

00:21:31,200 --> 00:21:35,280
sets everything up with the device usb

00:21:33,679 --> 00:21:37,280
driver

00:21:35,280 --> 00:21:38,960
and you have your end points the device

00:21:37,280 --> 00:21:41,679
usb driver

00:21:38,960 --> 00:21:44,559
calls the exported functions from the

00:21:41,679 --> 00:21:46,960
hss driver on the device

00:21:44,559 --> 00:21:49,280
and registers some of its functions for

00:21:46,960 --> 00:21:50,960
callback purposes that's how the hss

00:21:49,280 --> 00:21:54,320
driver knows

00:21:50,960 --> 00:21:56,400
how to send data to usb

00:21:54,320 --> 00:21:58,080
and at this point both sides are ready

00:21:56,400 --> 00:22:00,480
to send and receive

00:21:58,080 --> 00:22:00,480
data

00:22:02,159 --> 00:22:06,559
let's go through the flow of a open

00:22:04,000 --> 00:22:06,960
packet that would be used to initially

00:22:06,559 --> 00:22:10,080
set

00:22:06,960 --> 00:22:11,919
up a socket for communication

00:22:10,080 --> 00:22:14,080
this is identical to the flow of other

00:22:11,919 --> 00:22:17,280
packets but this is probably

00:22:14,080 --> 00:22:19,280
one of the simplest to go through

00:22:17,280 --> 00:22:21,600
the first thing that happens is on the

00:22:19,280 --> 00:22:22,799
device a socket command is made with the

00:22:21,600 --> 00:22:26,720
hss

00:22:22,799 --> 00:22:29,760
socket type

00:22:26,720 --> 00:22:31,120
the hss driver stores the new id with

00:22:29,760 --> 00:22:33,280
this socket

00:22:31,120 --> 00:22:34,799
and uses the callbacks that were given

00:22:33,280 --> 00:22:39,360
to it by the

00:22:34,799 --> 00:22:42,080
usb driver to send an open packet

00:22:39,360 --> 00:22:44,400
the usb driver receives the open packet

00:22:42,080 --> 00:22:47,520
and sends it over the wire to the host

00:22:44,400 --> 00:22:50,000
usb driver the host usb

00:22:47,520 --> 00:22:50,640
driver passes the packet onto the host

00:22:50,000 --> 00:22:53,520
hss

00:22:50,640 --> 00:22:54,559
proxy which will also store the socket

00:22:53,520 --> 00:22:57,200
id

00:22:54,559 --> 00:22:59,840
and correlate it to a new actual inet

00:22:57,200 --> 00:23:02,159
socket it creates

00:22:59,840 --> 00:23:03,280
upon completion it will either succeed

00:23:02,159 --> 00:23:05,600
or fail and

00:23:03,280 --> 00:23:06,640
create an ack packet indicating what

00:23:05,600 --> 00:23:08,799
happened

00:23:06,640 --> 00:23:11,200
this ack packet is passed back to the

00:23:08,799 --> 00:23:13,760
usb driver

00:23:11,200 --> 00:23:15,039
on the host transported to the usb

00:23:13,760 --> 00:23:18,320
driver

00:23:15,039 --> 00:23:21,440
on the device which passes it to

00:23:18,320 --> 00:23:24,799
the hss driver on the device which

00:23:21,440 --> 00:23:27,200
looks up the socket in its database and

00:23:24,799 --> 00:23:28,159
returns to the actual socket either by

00:23:27,200 --> 00:23:30,720
unblocking

00:23:28,159 --> 00:23:33,600
or updating its information so the next

00:23:30,720 --> 00:23:33,600
time it pulls

00:23:33,919 --> 00:23:38,240
it will return either success or failure

00:23:39,360 --> 00:23:42,400
all right that's uh that's the portion i

00:23:41,600 --> 00:23:44,159
had

00:23:42,400 --> 00:23:51,840
to describe the way we're implementing

00:23:44,159 --> 00:23:54,240
this are there any questions on this

00:23:51,840 --> 00:23:56,559
all right well there's um well moving

00:23:54,240 --> 00:23:58,640
forward there's a few challenges we have

00:23:56,559 --> 00:24:00,240
in terms of trying to integrate this

00:23:58,640 --> 00:24:02,799
with what other people are doing and

00:24:00,240 --> 00:24:05,200
perhaps even upstreaming the software

00:24:02,799 --> 00:24:07,360
the first and probably most uh looks

00:24:05,200 --> 00:24:10,559
like we have another question

00:24:07,360 --> 00:24:12,880
um is this hss change

00:24:10,559 --> 00:24:14,480
related code proprietary or are we going

00:24:12,880 --> 00:24:16,720
to upstream the changes

00:24:14,480 --> 00:24:18,640
uh this is all open source i am going to

00:24:16,720 --> 00:24:19,840
link to our github repos in just a

00:24:18,640 --> 00:24:21,840
minute

00:24:19,840 --> 00:24:25,360
we would love to see this up streamed as

00:24:21,840 --> 00:24:25,360
the project becomes more mature

00:24:25,440 --> 00:24:28,880
uh the most fundamental difference

00:24:27,279 --> 00:24:33,600
between this and

00:24:28,880 --> 00:24:34,159
other usb usb software is that usb is a

00:24:33,600 --> 00:24:37,600
very

00:24:34,159 --> 00:24:40,080
um a very directional protocol

00:24:37,600 --> 00:24:41,520
there is a master there is a slave and

00:24:40,080 --> 00:24:44,880
the device does not

00:24:41,520 --> 00:24:47,520
usually provide or sorry the host does

00:24:44,880 --> 00:24:49,600
not usually provide functionality to its

00:24:47,520 --> 00:24:51,360
device it's the other way around

00:24:49,600 --> 00:24:55,120
that makes this very different than

00:24:51,360 --> 00:24:55,120
other cdc protocols

00:24:55,200 --> 00:24:58,400
the other main difference from cdc

00:24:57,120 --> 00:25:00,240
protocols is that

00:24:58,400 --> 00:25:02,159
we are dealing with transport layer

00:25:00,240 --> 00:25:05,360
packets instead

00:25:02,159 --> 00:25:08,960
of instead of the physical

00:25:05,360 --> 00:25:11,039
ethernet packets furthermore from an

00:25:08,960 --> 00:25:14,320
implementation standpoint

00:25:11,039 --> 00:25:16,240
network drivers and usb drivers don't

00:25:14,320 --> 00:25:19,039
typically talk together

00:25:16,240 --> 00:25:20,480
the cdc classes have a relatively

00:25:19,039 --> 00:25:23,840
inflexible

00:25:20,480 --> 00:25:25,440
uh glue between it and ethernet and it

00:25:23,840 --> 00:25:27,120
isn't really designed to go the other

00:25:25,440 --> 00:25:29,200
way around but drivers

00:25:27,120 --> 00:25:30,400
do make direct calls to the network

00:25:29,200 --> 00:25:32,880
lawyer

00:25:30,400 --> 00:25:35,120
another question we have how is dns

00:25:32,880 --> 00:25:37,279
resolution handled

00:25:35,120 --> 00:25:38,720
uh that is a problem for the host to

00:25:37,279 --> 00:25:43,120
resolve you're sending

00:25:38,720 --> 00:25:45,200
you're sending um data to tcp udp and

00:25:43,120 --> 00:25:48,080
other sockets on the host

00:25:45,200 --> 00:25:50,799
however it handles dns resolution is the

00:25:48,080 --> 00:25:50,799
answer to that

00:25:51,360 --> 00:25:57,120
and we only have one user us

00:25:55,360 --> 00:25:58,640
we're very excited to hear what other

00:25:57,120 --> 00:26:02,640
people might have and

00:25:58,640 --> 00:26:02,640
uh use cases that they could bring

00:26:04,559 --> 00:26:08,400
moving forward there are still a few

00:26:06,880 --> 00:26:10,400
more features we

00:26:08,400 --> 00:26:11,760
we need to build to get this ready for

00:26:10,400 --> 00:26:14,080
production

00:26:11,760 --> 00:26:16,240
uh there's traffic flow control we have

00:26:14,080 --> 00:26:18,000
a couple ideas for this

00:26:16,240 --> 00:26:20,159
but i didn't have time to implement them

00:26:18,000 --> 00:26:22,720
before the talk

00:26:20,159 --> 00:26:24,880
things to apply tcp back pressure or

00:26:22,720 --> 00:26:28,080
other things to make sure that the usb

00:26:24,880 --> 00:26:30,159
link doesn't flood one side or the other

00:26:28,080 --> 00:26:32,559
considerations for high traffic systems

00:26:30,159 --> 00:26:35,440
are another thing so for larger

00:26:32,559 --> 00:26:37,600
uh large embedded devices having many

00:26:35,440 --> 00:26:40,000
bulk pairs to transport data across

00:26:37,600 --> 00:26:40,000
socks

00:26:41,360 --> 00:26:46,480
a question from robert is the hss proxy

00:26:44,320 --> 00:26:48,080
running in linux user space or as a part

00:26:46,480 --> 00:26:50,240
of the kernel

00:26:48,080 --> 00:26:53,840
because it's a new type of socket it has

00:26:50,240 --> 00:26:53,840
to run as a part of the kernel

00:26:56,480 --> 00:27:00,400
another thing we do need to add is

00:26:58,400 --> 00:27:01,520
handling i o controls and a few other

00:27:00,400 --> 00:27:03,840
socket

00:27:01,520 --> 00:27:07,840
operations we also need to make our

00:27:03,840 --> 00:27:07,840
distribution a bit more mature

00:27:08,400 --> 00:27:11,600
in that a better way to distribute hss

00:27:10,799 --> 00:27:14,799
until we are

00:27:11,600 --> 00:27:16,840
upstreamed because a new network device

00:27:14,799 --> 00:27:19,440
does does require some kernel

00:27:16,840 --> 00:27:21,039
modifications

00:27:19,440 --> 00:27:23,279
uh looks like we have another question

00:27:21,039 --> 00:27:25,120
from brett

00:27:23,279 --> 00:27:28,399
uh what can i do with this that i cannot

00:27:25,120 --> 00:27:30,799
accomplish with existing cdc protocols

00:27:28,399 --> 00:27:32,960
the primary benefit to this is that you

00:27:30,799 --> 00:27:35,200
don't have to know a lot about the

00:27:32,960 --> 00:27:38,159
device or sorry about the local network

00:27:35,200 --> 00:27:38,159
that you're talking to

00:27:38,240 --> 00:27:42,240
uh if you're sending ethernet packets

00:27:40,399 --> 00:27:43,600
you usually have to have some identity

00:27:42,240 --> 00:27:46,159
with the router and an

00:27:43,600 --> 00:27:48,480
embedded device may not want to have to

00:27:46,159 --> 00:27:50,880
do that this provides a very generic

00:27:48,480 --> 00:27:53,279
plug-and-play way to send data over your

00:27:50,880 --> 00:27:57,679
network

00:27:53,279 --> 00:27:59,840
um from william use case usb armory

00:27:57,679 --> 00:28:02,799
a usb armboard that would benefit

00:27:59,840 --> 00:28:05,120
greatly when can device requests be made

00:28:02,799 --> 00:28:05,919
shoot me an email or contact me on slack

00:28:05,120 --> 00:28:08,799
after this

00:28:05,919 --> 00:28:08,799
i'll see what i can do

00:28:11,120 --> 00:28:14,720
um from sofia as a user tethering this

00:28:14,320 --> 00:28:18,159
room

00:28:14,720 --> 00:28:18,159
or sorry that's an old comment

00:28:18,559 --> 00:28:21,600
all right and yeah and again part of the

00:28:19,840 --> 00:28:23,520
purpose of this is to see what we want

00:28:21,600 --> 00:28:25,279
to do moving forward the comments i'm

00:28:23,520 --> 00:28:27,520
getting from you all are excellent so

00:28:25,279 --> 00:28:27,520
far

00:28:27,679 --> 00:28:32,799
so where to find it the the zapdom hss

00:28:32,080 --> 00:28:35,919
repo

00:28:32,799 --> 00:28:38,240
has the host side implementation and the

00:28:35,919 --> 00:28:41,120
actual standard as a pdf it goes into

00:28:38,240 --> 00:28:45,039
more detail about some of the packets

00:28:41,120 --> 00:28:47,679
and some algorithms to provide

00:28:45,039 --> 00:28:49,679
guarantees for which side processes what

00:28:47,679 --> 00:28:52,559
our device side implementation

00:28:49,679 --> 00:28:54,880
uh we currently have on top of our uh on

00:28:52,559 --> 00:28:58,320
top of the linux distribution we use

00:28:54,880 --> 00:29:00,799
to deal with our use case i want to have

00:28:58,320 --> 00:29:02,720
this moved into the hss repo at some

00:29:00,799 --> 00:29:03,840
point but i wasn't able to get a good

00:29:02,720 --> 00:29:07,039
way

00:29:03,840 --> 00:29:09,039
to integrate that in time for the speech

00:29:07,039 --> 00:29:10,559
but these are the two places you can go

00:29:09,039 --> 00:29:13,840
to

00:29:10,559 --> 00:29:13,840
to find the software

00:29:15,520 --> 00:29:19,600
all right and if you want to contact me

00:29:18,000 --> 00:29:22,480
this is my contact info

00:29:19,600 --> 00:29:24,799
information up here someone's indicating

00:29:22,480 --> 00:29:26,000
that the first link is broken i will

00:29:24,799 --> 00:29:27,360
look into that immediate

00:29:26,000 --> 00:29:29,039
i will get into that as soon as i'm done

00:29:27,360 --> 00:29:31,760
with this slide and try to provide a

00:29:29,039 --> 00:29:33,840
correction during the talk

00:29:31,760 --> 00:29:35,440
all right if you want to contact me my

00:29:33,840 --> 00:29:38,080
email github and

00:29:35,440 --> 00:29:39,760
mostly empty personal website is up here

00:29:38,080 --> 00:29:42,240
and my employer who is

00:29:39,760 --> 00:29:44,559
paying me to be here and uh sponsoring

00:29:42,240 --> 00:29:48,320
obviously the production of this project

00:29:44,559 --> 00:29:55,840
zapdom i can take any further questions

00:29:48,320 --> 00:29:55,840
uh before ending the talk here

00:29:58,080 --> 00:30:02,000
all right well it looks like um it looks

00:30:01,279 --> 00:30:04,480
like that's it

00:30:02,000 --> 00:30:05,440
thank you very much for uh coming out to

00:30:04,480 --> 00:30:07,520
hear the talk

00:30:05,440 --> 00:30:08,799
i am going to look into the link being

00:30:07,520 --> 00:30:11,840
broken and post

00:30:08,799 --> 00:30:13,120
something in slack as soon as i as soon

00:30:11,840 --> 00:30:13,760
as i figure out what's going on with

00:30:13,120 --> 00:30:23,760
that

00:30:13,760 --> 00:30:26,559
thank you

00:30:23,760 --> 00:30:26,559
thank you marvin

00:30:35,520 --> 00:30:50,640
let me see if i can quickly figure out

00:30:37,120 --> 00:30:52,960
the link right here

00:30:50,640 --> 00:30:54,960
uh i just typed the link in and it

00:30:52,960 --> 00:30:56,640
appears to be working without any

00:30:54,960 --> 00:30:56,960
problems maybe there's an issue if

00:30:56,640 --> 00:30:58,320
you're

00:30:56,960 --> 00:31:00,159
if you're clicking on the actual

00:30:58,320 --> 00:31:01,279
powerpoint perhaps it's pointing to the

00:31:00,159 --> 00:31:05,760
wrong

00:31:01,279 --> 00:31:07,600
uh location yes there is a single quote

00:31:05,760 --> 00:31:19,840
at the beginning of that address in the

00:31:07,600 --> 00:31:19,840
actual powerpoint my apologies for that

00:31:24,399 --> 00:31:26,480

YouTube URL: https://www.youtube.com/watch?v=uIGHXYgqyUI


