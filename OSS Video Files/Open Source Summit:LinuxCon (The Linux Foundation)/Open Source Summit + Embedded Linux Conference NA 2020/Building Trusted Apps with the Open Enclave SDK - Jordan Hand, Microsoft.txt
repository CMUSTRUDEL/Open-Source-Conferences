Title: Building Trusted Apps with the Open Enclave SDK - Jordan Hand, Microsoft
Publication date: 2020-09-03
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	Building Trusted Apps with the Open Enclave SDK - Jordan Hand, Microsoft
Captions: 
	00:00:02,240 --> 00:00:06,640
hello everybody

00:00:03,679 --> 00:00:08,480
my name is jordan hand i'm a developer

00:00:06,640 --> 00:00:10,719
on the open enclave sdk

00:00:08,480 --> 00:00:12,080
project and today we're going to talk a

00:00:10,719 --> 00:00:14,559
little bit about

00:00:12,080 --> 00:00:17,039
what the open enclave sdk is what

00:00:14,559 --> 00:00:19,279
problems it solves

00:00:17,039 --> 00:00:20,480
what we as a project have been doing for

00:00:19,279 --> 00:00:23,680
the last

00:00:20,480 --> 00:00:25,519
12 months where we're headed and then um

00:00:23,680 --> 00:00:27,279
we're going to take some time to to go

00:00:25,519 --> 00:00:29,199
through a demo of what does it look like

00:00:27,279 --> 00:00:30,160
to develop an application with the open

00:00:29,199 --> 00:00:33,200
enclose sdk

00:00:30,160 --> 00:00:33,760
run it debug it and just kind of dive

00:00:33,200 --> 00:00:36,640
into

00:00:33,760 --> 00:00:39,840
some of the tooling around how to

00:00:36,640 --> 00:00:39,840
develop these applications

00:00:40,000 --> 00:00:46,480
so um i'm going to start by just framing

00:00:44,640 --> 00:00:47,920
what is the problem that the open

00:00:46,480 --> 00:00:51,039
enclave sdk

00:00:47,920 --> 00:00:53,440
seeks to solve if you've seen

00:00:51,039 --> 00:00:54,640
another presentation on confidential

00:00:53,440 --> 00:00:57,440
computing if you saw

00:00:54,640 --> 00:00:59,120
stephen wally's talk on monday you've

00:00:57,440 --> 00:01:01,039
probably heard some of these concepts

00:00:59,120 --> 00:01:03,039
before but i just want to

00:01:01,039 --> 00:01:05,439
go over them for a minute and so that we

00:01:03,039 --> 00:01:09,119
have a baseline for

00:01:05,439 --> 00:01:12,799
talking about all the other topics so

00:01:09,119 --> 00:01:15,840
for a long time we've

00:01:12,799 --> 00:01:18,320
known how to protect data when it's at

00:01:15,840 --> 00:01:21,200
rest so this is like on disk when you're

00:01:18,320 --> 00:01:22,320
when you turn your computer off you can

00:01:21,200 --> 00:01:24,840
encrypt the disk

00:01:22,320 --> 00:01:26,240
and when you reboot you enter some

00:01:24,840 --> 00:01:29,600
password

00:01:26,240 --> 00:01:32,960
that can be used to decrypt data on disk

00:01:29,600 --> 00:01:34,079
um moving to in transit this is things

00:01:32,960 --> 00:01:37,680
like

00:01:34,079 --> 00:01:39,280
tls you know you can encrypt data from

00:01:37,680 --> 00:01:41,600
point a to point b

00:01:39,280 --> 00:01:42,799
but then once it's on the the

00:01:41,600 --> 00:01:46,079
destination computer

00:01:42,799 --> 00:01:48,880
or the source computer it is decrypted

00:01:46,079 --> 00:01:50,000
when it's used so the problem that we're

00:01:48,880 --> 00:01:52,960
trying to solve

00:01:50,000 --> 00:01:53,600
is how do you protect data when it's in

00:01:52,960 --> 00:01:56,640
use

00:01:53,600 --> 00:01:59,920
in in memory um

00:01:56,640 --> 00:02:03,040
and how do you protect it from

00:01:59,920 --> 00:02:06,000
maybe components that are on on the same

00:02:03,040 --> 00:02:06,000
physical hardware

00:02:06,560 --> 00:02:10,560
because to operate on the data you need

00:02:08,800 --> 00:02:12,239
to

00:02:10,560 --> 00:02:14,480
to be able to hold in memory so that's

00:02:12,239 --> 00:02:17,040
kind of the

00:02:14,480 --> 00:02:18,160
the framing of the what the problem

00:02:17,040 --> 00:02:21,360
solves and there's

00:02:18,160 --> 00:02:24,400
a number of hardware technologies

00:02:21,360 --> 00:02:27,920
intel sgx arm trust zone

00:02:24,400 --> 00:02:30,319
um kind of a different model but

00:02:27,920 --> 00:02:32,239
amd's sav technologies kind of operate

00:02:30,319 --> 00:02:35,360
in this space and this is

00:02:32,239 --> 00:02:38,720
hardware isolation of

00:02:35,360 --> 00:02:40,640
some memory cpu state

00:02:38,720 --> 00:02:41,760
um it kind of depends on on the hardware

00:02:40,640 --> 00:02:46,000
technology but

00:02:41,760 --> 00:02:47,599
um protection from

00:02:46,000 --> 00:02:50,640
other parts in the system so how can you

00:02:47,599 --> 00:02:53,120
silo off code and data

00:02:50,640 --> 00:02:54,480
to so that it can't be viewed can't be

00:02:53,120 --> 00:02:58,239
modified

00:02:54,480 --> 00:02:58,239
by other parts of the system

00:02:59,519 --> 00:03:04,239
so that brings us to the open enclose

00:03:02,720 --> 00:03:07,599
sdk so what is it

00:03:04,239 --> 00:03:10,800
it's a cnc plus sdk

00:03:07,599 --> 00:03:13,840
for developing apps that target these

00:03:10,800 --> 00:03:16,000
hardware platforms so

00:03:13,840 --> 00:03:17,200
if you want to build an sgx app if you

00:03:16,000 --> 00:03:20,560
want to build

00:03:17,200 --> 00:03:24,159
an app on arm trust zone we provide

00:03:20,560 --> 00:03:25,840
libraries we provide a consistent api

00:03:24,159 --> 00:03:31,440
interface

00:03:25,840 --> 00:03:34,879
to run deploy that application

00:03:31,440 --> 00:03:37,519
on those platforms so

00:03:34,879 --> 00:03:39,440
uh another principle that we've kind of

00:03:37,519 --> 00:03:41,360
sought out to

00:03:39,440 --> 00:03:42,799
to make as a part of the sdk is that we

00:03:41,360 --> 00:03:45,040
want it to be fully

00:03:42,799 --> 00:03:46,319
open source and transparent and not tied

00:03:45,040 --> 00:03:49,519
to

00:03:46,319 --> 00:03:52,480
a specific cloud vendor or a specific

00:03:49,519 --> 00:03:52,480
hardware vendor

00:03:53,200 --> 00:03:57,280
and we want to make sure that all the

00:03:55,599 --> 00:04:01,360
code running

00:03:57,280 --> 00:04:04,400
with your trusted application code is

00:04:01,360 --> 00:04:07,439
auditable by users and

00:04:04,400 --> 00:04:08,319
by anyone who wants to look at it so we

00:04:07,439 --> 00:04:10,400
provide

00:04:08,319 --> 00:04:12,000
libraries that run inside of this

00:04:10,400 --> 00:04:12,799
trusted environment that i'm talking

00:04:12,000 --> 00:04:16,720
about this

00:04:12,799 --> 00:04:20,560
this trusted code and data silo um

00:04:16,720 --> 00:04:22,960
all of that should be auditable by

00:04:20,560 --> 00:04:24,560
whoever the the trusted party is this is

00:04:22,960 --> 00:04:26,639
the application developer the person

00:04:24,560 --> 00:04:30,880
running the application

00:04:26,639 --> 00:04:33,120
we also don't want to tie

00:04:30,880 --> 00:04:34,080
these applications to a specific cloud

00:04:33,120 --> 00:04:37,520
vendor so

00:04:34,080 --> 00:04:40,639
obviously i work for microsoft but we

00:04:37,520 --> 00:04:44,479
want these applications to be usable

00:04:40,639 --> 00:04:48,000
anywhere where this hardware exists

00:04:44,479 --> 00:04:51,440
um beyond that we want the

00:04:48,000 --> 00:04:53,759
trusted compute base so this is like

00:04:51,440 --> 00:04:55,520
the amount you can basically think of it

00:04:53,759 --> 00:04:58,639
as the amount of attack surface

00:04:55,520 --> 00:05:00,320
of an application we want that to be

00:04:58,639 --> 00:05:02,880
potentially as small as possible but

00:05:00,320 --> 00:05:03,280
also we want it to be composable so that

00:05:02,880 --> 00:05:06,080
means

00:05:03,280 --> 00:05:07,360
that if you have different components

00:05:06,080 --> 00:05:10,160
maybe your application

00:05:07,360 --> 00:05:12,160
needs certain components like we're

00:05:10,160 --> 00:05:14,240
going to talk later about maybe you want

00:05:12,160 --> 00:05:16,240
libsy access you want access to the

00:05:14,240 --> 00:05:19,680
standard c apis

00:05:16,240 --> 00:05:22,880
um because your application is very

00:05:19,680 --> 00:05:25,840
challenging to write without it you can

00:05:22,880 --> 00:05:27,280
add that as a layer to your open enclave

00:05:25,840 --> 00:05:29,600
sdk application

00:05:27,280 --> 00:05:30,560
along with other libraries that you may

00:05:29,600 --> 00:05:32,720
need

00:05:30,560 --> 00:05:33,600
but we also want to make it possible for

00:05:32,720 --> 00:05:37,039
applications

00:05:33,600 --> 00:05:38,479
that don't necessarily need these things

00:05:37,039 --> 00:05:42,479
they're maybe doing

00:05:38,479 --> 00:05:46,400
something pretty trivial inside of

00:05:42,479 --> 00:05:48,240
of the enclave we want to be able to

00:05:46,400 --> 00:05:51,039
allow them to reduce the code size of

00:05:48,240 --> 00:05:53,759
the application as much as possible

00:05:51,039 --> 00:05:54,639
and that just helps with a auditability

00:05:53,759 --> 00:05:56,639
of the code

00:05:54,639 --> 00:05:58,160
can you make sure that all the code

00:05:56,639 --> 00:06:01,280
running inside your application is

00:05:58,160 --> 00:06:05,039
secure it's really hard to do that when

00:06:01,280 --> 00:06:06,160
you have a very large tcp a very large

00:06:05,039 --> 00:06:09,759
amount of code running

00:06:06,160 --> 00:06:12,560
in inside of an enclave

00:06:09,759 --> 00:06:14,880
and then we also want support for

00:06:12,560 --> 00:06:17,199
multiple platforms so we target

00:06:14,880 --> 00:06:18,400
windows and linux and we try our best to

00:06:17,199 --> 00:06:21,680
keep

00:06:18,400 --> 00:06:23,759
feature parity with both of those

00:06:21,680 --> 00:06:27,120
platforms

00:06:23,759 --> 00:06:29,520
and we just want to provide

00:06:27,120 --> 00:06:30,400
a single experience that doesn't change

00:06:29,520 --> 00:06:33,199
too much

00:06:30,400 --> 00:06:34,000
um when you cross os platforms and so

00:06:33,199 --> 00:06:38,160
we'll talk a little bit

00:06:34,000 --> 00:06:38,160
later about about what that means

00:06:39,360 --> 00:06:42,560
so this is kind of the basic structure

00:06:42,160 --> 00:06:44,400
and we'll

00:06:42,560 --> 00:06:47,360
we'll dive more into this in a minute

00:06:44,400 --> 00:06:50,400
but this is the basic structure of an

00:06:47,360 --> 00:06:52,080
enclave application so you have

00:06:50,400 --> 00:06:53,759
normal application code you can think of

00:06:52,080 --> 00:06:55,120
this as just like you know you write

00:06:53,759 --> 00:06:58,240
your main function in c

00:06:55,120 --> 00:07:00,400
and and you run it this is just regular

00:06:58,240 --> 00:07:02,720
application code

00:07:00,400 --> 00:07:03,520
as part of that application code you

00:07:02,720 --> 00:07:05,680
have an

00:07:03,520 --> 00:07:07,440
untrusted host component so everything

00:07:05,680 --> 00:07:11,360
in red is

00:07:07,440 --> 00:07:14,479
not trusted in terms of

00:07:11,360 --> 00:07:15,120
of hardware isolation so it's outside of

00:07:14,479 --> 00:07:19,039
the hardware

00:07:15,120 --> 00:07:20,479
isolation boundary um untrusted host

00:07:19,039 --> 00:07:24,479
that kind of

00:07:20,479 --> 00:07:27,039
serves as a connector between

00:07:24,479 --> 00:07:27,520
the enclave application and the rest of

00:07:27,039 --> 00:07:30,080
the

00:07:27,520 --> 00:07:31,360
machine and so we'll talk a minute um in

00:07:30,080 --> 00:07:34,880
a minute about

00:07:31,360 --> 00:07:38,080
more about that um

00:07:34,880 --> 00:07:38,800
the host os including the colonel is

00:07:38,080 --> 00:07:41,919
also

00:07:38,800 --> 00:07:45,599
untrusted but there it can do some

00:07:41,919 --> 00:07:48,479
some operations on our behalf without

00:07:45,599 --> 00:07:49,520
still without having access to the data

00:07:48,479 --> 00:07:53,039
so

00:07:49,520 --> 00:07:53,840
the only part that is trusted in terms

00:07:53,039 --> 00:07:56,160
of inside

00:07:53,840 --> 00:07:58,000
the hardware isolation boundary is the

00:07:56,160 --> 00:08:02,000
enclave application so this is

00:07:58,000 --> 00:08:04,080
this green piece and so this includes

00:08:02,000 --> 00:08:05,680
some runtime libraries that the open

00:08:04,080 --> 00:08:07,840
enclave sdk provides

00:08:05,680 --> 00:08:10,160
as well as the application code that the

00:08:07,840 --> 00:08:11,759
developer writes

00:08:10,160 --> 00:08:13,440
and something else just to note really

00:08:11,759 --> 00:08:15,599
quick is that

00:08:13,440 --> 00:08:17,440
if you have multiple enclaves running on

00:08:15,599 --> 00:08:20,879
the same machine

00:08:17,440 --> 00:08:21,919
um again it is maybe hardware depending

00:08:20,879 --> 00:08:25,360
but typically

00:08:21,919 --> 00:08:28,319
these applications are isolated from

00:08:25,360 --> 00:08:28,319
each other as well

00:08:28,960 --> 00:08:37,519
um so then

00:08:33,519 --> 00:08:40,959
the open enclave sdk seeks to abstract

00:08:37,519 --> 00:08:42,800
most platform specific details so you

00:08:40,959 --> 00:08:45,760
can see

00:08:42,800 --> 00:08:46,720
the the green pieces are what the open

00:08:45,760 --> 00:08:50,480
enclave sdk

00:08:46,720 --> 00:08:52,880
offers and then the orange pieces

00:08:50,480 --> 00:08:54,399
we typically take from other projects so

00:08:52,880 --> 00:08:58,480
for

00:08:54,399 --> 00:09:01,279
sgx we use intel's

00:08:58,480 --> 00:09:02,640
platform software libraries their dcap

00:09:01,279 --> 00:09:04,080
libraries which are used for out of

00:09:02,640 --> 00:09:07,040
station

00:09:04,080 --> 00:09:09,839
we use their linux kernel driver their

00:09:07,040 --> 00:09:13,920
windows kernel drivers

00:09:09,839 --> 00:09:16,000
so we we seek to

00:09:13,920 --> 00:09:17,839
for sp hardware specific stuff keep that

00:09:16,000 --> 00:09:21,040
out of the project

00:09:17,839 --> 00:09:22,560
um similarly on trustzone we

00:09:21,040 --> 00:09:24,880
build pretty much entirely on top of

00:09:22,560 --> 00:09:28,640
opti and so we

00:09:24,880 --> 00:09:28,640
leverage that project pretty heavily

00:09:30,560 --> 00:09:34,800
so one thing that

00:09:34,880 --> 00:09:40,320
is important to note is that an

00:09:38,000 --> 00:09:42,399
enclave application running just in

00:09:40,320 --> 00:09:43,519
complete isolation is often not very

00:09:42,399 --> 00:09:46,160
useful

00:09:43,519 --> 00:09:48,560
you need some connection out to your

00:09:46,160 --> 00:09:52,000
normal world

00:09:48,560 --> 00:09:53,360
so that you can do things like i have

00:09:52,000 --> 00:09:56,959
data that is

00:09:53,360 --> 00:10:00,080
encrypted i operated it on on it

00:09:56,959 --> 00:10:01,760
inside the enclave application now i

00:10:00,080 --> 00:10:02,800
want to send it over the network to

00:10:01,760 --> 00:10:04,079
another machine

00:10:02,800 --> 00:10:06,800
it's encrypted but i want to send it

00:10:04,079 --> 00:10:08,399
over the network to another machine

00:10:06,800 --> 00:10:10,320
if i'm just running inside the enclave i

00:10:08,399 --> 00:10:13,920
can't do that so we

00:10:10,320 --> 00:10:17,760
need to provide a way for

00:10:13,920 --> 00:10:20,800
the enclave application to talk to the

00:10:17,760 --> 00:10:23,279
outside host application and so

00:10:20,800 --> 00:10:23,839
if you're familiar with sgx great that's

00:10:23,279 --> 00:10:27,600
easy

00:10:23,839 --> 00:10:30,320
the enclave actually has access to

00:10:27,600 --> 00:10:33,839
all of the host memory for the the

00:10:30,320 --> 00:10:36,640
containing process so the enclave lives

00:10:33,839 --> 00:10:38,000
has as a carved out section of memory in

00:10:36,640 --> 00:10:41,279
the process

00:10:38,000 --> 00:10:43,040
and it can access um

00:10:41,279 --> 00:10:44,640
anything outside that's also in the

00:10:43,040 --> 00:10:48,000
process for

00:10:44,640 --> 00:10:50,880
trustzone that's not so simple um there

00:10:48,000 --> 00:10:52,720
there is not a shared you know the

00:10:50,880 --> 00:10:58,079
simple shared memory model

00:10:52,720 --> 00:11:01,200
and so for the oe sdk we wanted to

00:10:58,079 --> 00:11:03,120
wrap that up so that

00:11:01,200 --> 00:11:07,200
so that it looks consistent across all

00:11:03,120 --> 00:11:07,200
platforms we want to restrict

00:11:07,600 --> 00:11:11,760
how communication between the enclave

00:11:10,880 --> 00:11:14,640
and the host

00:11:11,760 --> 00:11:15,760
works to what will work on every

00:11:14,640 --> 00:11:18,399
platform

00:11:15,760 --> 00:11:19,040
so what we have is a tool called edge

00:11:18,399 --> 00:11:22,480
that

00:11:19,040 --> 00:11:23,200
is called oedegerator it takes in a

00:11:22,480 --> 00:11:26,160
definition

00:11:23,200 --> 00:11:28,800
file which is basically just a list of

00:11:26,160 --> 00:11:31,440
functions that are e calls so these are

00:11:28,800 --> 00:11:33,519
calls from the host to the enclave

00:11:31,440 --> 00:11:35,920
and oh calls these are calls from the

00:11:33,519 --> 00:11:38,320
enclave back to the host

00:11:35,920 --> 00:11:39,760
and we'll take a look later just at what

00:11:38,320 --> 00:11:40,959
one of those files looks like but you

00:11:39,760 --> 00:11:42,640
can basically think of it as

00:11:40,959 --> 00:11:44,079
a header file we just provide function

00:11:42,640 --> 00:11:46,480
definitions

00:11:44,079 --> 00:11:47,600
and then the oederator tool will

00:11:46,480 --> 00:11:53,519
generate

00:11:47,600 --> 00:11:56,160
um basically glue code so code that will

00:11:53,519 --> 00:11:58,399
do on different platforms different

00:11:56,160 --> 00:12:02,079
things potentially

00:11:58,399 --> 00:12:06,639
an ipc call potentially

00:12:02,079 --> 00:12:07,920
marshaling memory between

00:12:06,639 --> 00:12:10,079
the host of the enclave and the

00:12:07,920 --> 00:12:11,040
important part is that it does a lot of

00:12:10,079 --> 00:12:12,880
things for you

00:12:11,040 --> 00:12:15,120
that if you were to try to do on your

00:12:12,880 --> 00:12:17,120
own would be easy to mess up so for

00:12:15,120 --> 00:12:19,279
example marshalling

00:12:17,120 --> 00:12:21,200
data from the host so data from the host

00:12:19,279 --> 00:12:23,519
is inherently untrusted

00:12:21,200 --> 00:12:26,480
in sgx if you want to you could just

00:12:23,519 --> 00:12:30,720
read data directly from the host

00:12:26,480 --> 00:12:33,120
but if you're that leaves you success

00:12:30,720 --> 00:12:34,240
susceptible to type of text time of

00:12:33,120 --> 00:12:37,440
check time abuse

00:12:34,240 --> 00:12:41,279
attacks you could

00:12:37,440 --> 00:12:45,760
well yeah that that's basically it so

00:12:41,279 --> 00:12:48,560
the the edge code the glue code will

00:12:45,760 --> 00:12:49,839
marshal data so that it it's copied from

00:12:48,560 --> 00:12:50,480
the host to the enclave when you're

00:12:49,839 --> 00:12:52,560
operating

00:12:50,480 --> 00:12:54,480
on it in the enclave you can be sure

00:12:52,560 --> 00:12:55,760
that once you've validated the data once

00:12:54,480 --> 00:12:58,399
you've

00:12:55,760 --> 00:12:59,040
ensured that there's no dangerous

00:12:58,399 --> 00:13:02,320
pointers

00:12:59,040 --> 00:13:04,839
no potential for leaking data

00:13:02,320 --> 00:13:07,839
that it is all inside the enclave memory

00:13:04,839 --> 00:13:07,839
space

00:13:08,639 --> 00:13:12,959
so this is basically what the enclave

00:13:11,680 --> 00:13:15,440
runtime

00:13:12,959 --> 00:13:16,320
libraries look like so we have a core

00:13:15,440 --> 00:13:19,120
library the

00:13:16,320 --> 00:13:20,480
open enclave core library which

00:13:19,120 --> 00:13:23,680
basically serves

00:13:20,480 --> 00:13:26,720
as an adapter between

00:13:23,680 --> 00:13:30,240
the platform specific libraries and

00:13:26,720 --> 00:13:32,880
the rest of the oe sdk libraries

00:13:30,240 --> 00:13:35,920
so on like i said before on stx we have

00:13:32,880 --> 00:13:39,360
the intel platform software libraries

00:13:35,920 --> 00:13:42,079
on trustzone we have the

00:13:39,360 --> 00:13:43,839
opti apis and so we try to build a

00:13:42,079 --> 00:13:46,320
consistent interface

00:13:43,839 --> 00:13:49,839
on top of that that then uses platform

00:13:46,320 --> 00:13:53,279
specific apis as needed

00:13:49,839 --> 00:13:54,399
above that we have a syscall layer so

00:13:53,279 --> 00:13:57,839
this is we've

00:13:54,399 --> 00:14:01,040
tried to implement a large number

00:13:57,839 --> 00:14:03,120
of posix syscalls

00:14:01,040 --> 00:14:04,399
and on windows this is actually the

00:14:03,120 --> 00:14:06,639
exact same

00:14:04,399 --> 00:14:08,240
we even though it's running on windows

00:14:06,639 --> 00:14:11,839
from inside the enclave

00:14:08,240 --> 00:14:14,160
you still use posix apis

00:14:11,839 --> 00:14:14,160
um

00:14:15,199 --> 00:14:22,639
and that's that's in again an attempt to

00:14:19,279 --> 00:14:24,800
uh make the experience the same across

00:14:22,639 --> 00:14:26,880
multiple platforms so you can actually

00:14:24,800 --> 00:14:29,120
take an enclave application they're all

00:14:26,880 --> 00:14:30,160
all enclave applications the code

00:14:29,120 --> 00:14:33,680
running in the enclave

00:14:30,160 --> 00:14:35,360
is an elf binary and you can actually

00:14:33,680 --> 00:14:36,399
take the same alpha binary that you're

00:14:35,360 --> 00:14:37,680
running on linux

00:14:36,399 --> 00:14:40,639
and run it on windows without

00:14:37,680 --> 00:14:43,519
recompiling the same exact binary

00:14:40,639 --> 00:14:44,720
so we have the posix syscall layer which

00:14:43,519 --> 00:14:48,639
is

00:14:44,720 --> 00:14:51,040
primarily a a number of

00:14:48,639 --> 00:14:52,399
oh calls uh calls from the enclave to

00:14:51,040 --> 00:14:55,839
the host

00:14:52,399 --> 00:14:56,959
and then the syscalls are actually run

00:14:55,839 --> 00:14:58,560
on the host and the result

00:14:56,959 --> 00:15:00,079
is returned to the enclave so these are

00:14:58,560 --> 00:15:02,720
primarily

00:15:00,079 --> 00:15:03,760
untrusted calls but they serve an

00:15:02,720 --> 00:15:06,959
important purpose for

00:15:03,760 --> 00:15:09,920
accessing disk accessing a

00:15:06,959 --> 00:15:11,440
network so we provide other libraries

00:15:09,920 --> 00:15:12,320
inside the enclave to help you do that

00:15:11,440 --> 00:15:16,240
securely

00:15:12,320 --> 00:15:17,040
but this is primarily a layer that

00:15:16,240 --> 00:15:21,040
leverages

00:15:17,040 --> 00:15:24,560
the untrusted host operating system

00:15:21,040 --> 00:15:27,120
we have a version of muscle libsy

00:15:24,560 --> 00:15:29,360
that you can build your enclave

00:15:27,120 --> 00:15:30,959
application on top of so

00:15:29,360 --> 00:15:32,800
we want it to look as close to

00:15:30,959 --> 00:15:35,279
developing a normal c application as

00:15:32,800 --> 00:15:35,279
possible

00:15:35,600 --> 00:15:42,240
um as part of that we have

00:15:39,199 --> 00:15:44,320
libraries that that call into the cisco

00:15:42,240 --> 00:15:45,279
you know the muscle library calls into

00:15:44,320 --> 00:15:48,800
the cisco layer

00:15:45,279 --> 00:15:52,240
for doing and many of the

00:15:48,800 --> 00:15:55,279
standard c functions and

00:15:52,240 --> 00:15:57,120
we also provide we publish

00:15:55,279 --> 00:15:59,680
you know what these syscalls are as part

00:15:57,120 --> 00:16:01,839
of the sdk and so you can

00:15:59,680 --> 00:16:03,519
choose which syscalls you want to use um

00:16:01,839 --> 00:16:06,800
which syscalls you

00:16:03,519 --> 00:16:11,040
want to not

00:16:06,800 --> 00:16:14,079
you know not allow um

00:16:11,040 --> 00:16:16,399
so then on top of that we have a

00:16:14,079 --> 00:16:17,920
again a version of embed tls for

00:16:16,399 --> 00:16:20,800
cryptography

00:16:17,920 --> 00:16:21,199
operations and then on top of that we

00:16:20,800 --> 00:16:24,160
have

00:16:21,199 --> 00:16:26,959
an attestation layer so this is for

00:16:24,160 --> 00:16:26,959
generating

00:16:27,360 --> 00:16:35,839
attestation evidence so this is you know

00:16:31,040 --> 00:16:39,440
in sgx this is often an attestation

00:16:35,839 --> 00:16:42,560
um and then finally we

00:16:39,440 --> 00:16:46,399
provide a c plus plus library

00:16:42,560 --> 00:16:47,920
built that we run on top of muscle mc

00:16:46,399 --> 00:16:49,680
so you that you can actually write c

00:16:47,920 --> 00:16:52,000
plus plus applications inside of the on

00:16:49,680 --> 00:16:52,000
clip

00:16:53,600 --> 00:16:59,680
so i mostly went through all of these so

00:16:57,519 --> 00:17:05,520
we'll just kind of

00:16:59,680 --> 00:17:07,839
skip through each of these slides um

00:17:05,520 --> 00:17:09,039
something else that we provide is host

00:17:07,839 --> 00:17:12,480
libraries for

00:17:09,039 --> 00:17:14,240
things like enclave creation um

00:17:12,480 --> 00:17:17,199
interfacing with platform-specific

00:17:14,240 --> 00:17:20,240
libraries like i talked about before

00:17:17,199 --> 00:17:24,160
um and

00:17:20,240 --> 00:17:24,640
as well as uh the kind of primitives for

00:17:24,160 --> 00:17:28,640
doing

00:17:24,640 --> 00:17:30,559
the the enclave to host communication

00:17:28,640 --> 00:17:32,960
additionally we have a separate host

00:17:30,559 --> 00:17:35,360
verify library and so this is for

00:17:32,960 --> 00:17:36,000
evidence that is attestation evidence

00:17:35,360 --> 00:17:38,000
that is

00:17:36,000 --> 00:17:39,919
generated from within an enclave we have

00:17:38,000 --> 00:17:40,880
a standalone library that can be run on

00:17:39,919 --> 00:17:42,960
any

00:17:40,880 --> 00:17:44,400
any machine that can verify that

00:17:42,960 --> 00:17:46,400
evidence

00:17:44,400 --> 00:17:47,679
and so there's actually a lot of current

00:17:46,400 --> 00:17:51,520
work going on

00:17:47,679 --> 00:17:54,960
to standardize this across

00:17:51,520 --> 00:17:55,679
um trusted execution environment

00:17:54,960 --> 00:17:57,440
platforms

00:17:55,679 --> 00:17:59,200
um because attestation evidence looks

00:17:57,440 --> 00:18:01,600
different for different hardware vendors

00:17:59,200 --> 00:18:03,280
different platforms

00:18:01,600 --> 00:18:06,000
and so we want to provide a consistent

00:18:03,280 --> 00:18:08,000
api to

00:18:06,000 --> 00:18:09,760
generate this evidence and then verify

00:18:08,000 --> 00:18:11,039
the evidence so that's actually some

00:18:09,760 --> 00:18:13,280
some really cool work that people are

00:18:11,039 --> 00:18:16,880
doing in the project right now and we're

00:18:13,280 --> 00:18:16,880
kind of defining what that looks like

00:18:17,919 --> 00:18:22,880
um something else that we've

00:18:21,039 --> 00:18:24,480
strived to do that i talked about a

00:18:22,880 --> 00:18:26,480
little bit um

00:18:24,480 --> 00:18:27,679
is make the cons the experience look

00:18:26,480 --> 00:18:30,720
consistent on

00:18:27,679 --> 00:18:34,720
regardless of the host os

00:18:30,720 --> 00:18:36,080
because the idea is that the host os

00:18:34,720 --> 00:18:37,760
doesn't really matter what you care

00:18:36,080 --> 00:18:40,160
about is the

00:18:37,760 --> 00:18:42,000
the code running inside the trusted

00:18:40,160 --> 00:18:45,679
execution environment

00:18:42,000 --> 00:18:47,200
and so we don't want the application to

00:18:45,679 --> 00:18:48,320
really have to care about what the host

00:18:47,200 --> 00:18:51,520
looks like

00:18:48,320 --> 00:18:54,110
so we've provided again

00:18:51,520 --> 00:18:55,200
a consistent api layer that then

00:18:54,110 --> 00:18:57,600
[Music]

00:18:55,200 --> 00:18:59,520
calls into platform-specific libraries

00:18:57,600 --> 00:19:02,799
on

00:18:59,520 --> 00:19:03,280
um on linux or windows so for example

00:19:02,799 --> 00:19:07,200
for the

00:19:03,280 --> 00:19:07,200
host verify library we have

00:19:07,600 --> 00:19:14,480
the cryptographic operations on windows

00:19:11,120 --> 00:19:16,000
use bcrypt they use win32 apis they use

00:19:14,480 --> 00:19:18,880
the windows

00:19:16,000 --> 00:19:21,280
c runtime on linux they use openssl they

00:19:18,880 --> 00:19:24,480
use posix apis

00:19:21,280 --> 00:19:26,480
but from the application from the

00:19:24,480 --> 00:19:30,720
oe application none of that really

00:19:26,480 --> 00:19:30,720
matters they just use oe specific api

00:19:33,520 --> 00:19:40,160
and then we i talked about this

00:19:37,360 --> 00:19:40,480
at the beginning with kind of composable

00:19:40,160 --> 00:19:43,919
uh

00:19:40,480 --> 00:19:46,000
tcb size but we want to allow

00:19:43,919 --> 00:19:47,440
application developers to make the

00:19:46,000 --> 00:19:49,600
choice between

00:19:47,440 --> 00:19:51,440
code size and attack surface and

00:19:49,600 --> 00:19:54,640
usability and that's not

00:19:51,440 --> 00:19:55,919
a yes or no decision that's often a

00:19:54,640 --> 00:19:58,640
spectrum of

00:19:55,919 --> 00:20:02,160
my application is is just too hard to

00:19:58,640 --> 00:20:02,160
write without certain libraries

00:20:02,320 --> 00:20:06,640
but at the same time i don't want to

00:20:05,039 --> 00:20:08,880
just allow any code to run in the

00:20:06,640 --> 00:20:12,080
enclave

00:20:08,880 --> 00:20:14,640
so giving application developers the

00:20:12,080 --> 00:20:18,000
ability to make choices about

00:20:14,640 --> 00:20:18,799
what what code is running in their

00:20:18,000 --> 00:20:21,600
enclave

00:20:18,799 --> 00:20:22,000
and being able to add or take away from

00:20:21,600 --> 00:20:24,480
that

00:20:22,000 --> 00:20:27,520
code size is is an important kind of

00:20:24,480 --> 00:20:27,520
tenant of the sdk

00:20:28,240 --> 00:20:34,480
so another thing that the open enclave

00:20:31,520 --> 00:20:36,000
project seeks to provide is kind of

00:20:34,480 --> 00:20:38,159
tooling to make

00:20:36,000 --> 00:20:40,000
developing these applications a lot

00:20:38,159 --> 00:20:43,520
easier

00:20:40,000 --> 00:20:46,720
so we want tooling

00:20:43,520 --> 00:20:49,760
for for signing and for

00:20:46,720 --> 00:20:53,039
quote verification and

00:20:49,760 --> 00:20:54,799
compilation to be pretty pretty much the

00:20:53,039 --> 00:20:56,720
same across platforms

00:20:54,799 --> 00:20:58,640
that's another thing that is kind of in

00:20:56,720 --> 00:21:02,799
progress right now

00:20:58,640 --> 00:21:03,840
um integration with debugger platforms

00:21:02,799 --> 00:21:07,440
and

00:21:03,840 --> 00:21:11,360
and ides to

00:21:07,440 --> 00:21:14,840
make whatever tools you're using um

00:21:11,360 --> 00:21:16,400
work with enclave applications and then

00:21:14,840 --> 00:21:20,320
uh

00:21:16,400 --> 00:21:23,840
modes for simulation and emulation to

00:21:20,320 --> 00:21:24,960
when you don't have access to sgx

00:21:23,840 --> 00:21:27,200
hardware or

00:21:24,960 --> 00:21:29,039
trustzone enabled hardware that you can

00:21:27,200 --> 00:21:31,919
still

00:21:29,039 --> 00:21:32,559
test your application develop rapidly

00:21:31,919 --> 00:21:35,919
and then

00:21:32,559 --> 00:21:39,440
when you can deploy on hardware you just

00:21:35,919 --> 00:21:41,120
pick it up and it works so

00:21:39,440 --> 00:21:42,960
um some really exciting work that we've

00:21:41,120 --> 00:21:46,480
been doing in the last 12 months

00:21:42,960 --> 00:21:50,000
is adding support for debuggers

00:21:46,480 --> 00:21:53,280
to more platforms so we have a gdb

00:21:50,000 --> 00:21:54,320
plug-in that kind of has been the the

00:21:53,280 --> 00:21:57,600
mainstay of

00:21:54,320 --> 00:22:01,280
debugging for oe applications

00:21:57,600 --> 00:22:03,919
and i'll demo that in a little bit

00:22:01,280 --> 00:22:05,120
recently we've also come out with a

00:22:03,919 --> 00:22:08,080
winddbg

00:22:05,120 --> 00:22:08,880
plugin visual studio plugin so you can

00:22:08,080 --> 00:22:12,720
see in the bottom

00:22:08,880 --> 00:22:16,000
left our visual studio code plugin

00:22:12,720 --> 00:22:20,240
a lot just works the same as as any

00:22:16,000 --> 00:22:20,240
cnc plus plus debugging

00:22:20,320 --> 00:22:24,080
that you would be used to and we have

00:22:22,640 --> 00:22:27,840
the same experience on

00:22:24,080 --> 00:22:30,559
full visual studio as well

00:22:27,840 --> 00:22:32,720
and then we i talked a little bit about

00:22:30,559 --> 00:22:34,000
simulation and emulation so on sgx we

00:22:32,720 --> 00:22:38,159
have a

00:22:34,000 --> 00:22:41,200
almost full simulation mode so we

00:22:38,159 --> 00:22:44,640
basically have implemented

00:22:41,200 --> 00:22:48,000
everything that sgx would do itself

00:22:44,640 --> 00:22:51,280
um and we've we've written a simulator

00:22:48,000 --> 00:22:53,679
so that pretty much everything behaves

00:22:51,280 --> 00:22:54,480
the same as it does in sgx but running

00:22:53,679 --> 00:22:58,559
on

00:22:54,480 --> 00:22:58,559
any x86 hardware

00:22:58,720 --> 00:23:04,480
i'd say pretty much we don't support

00:23:01,679 --> 00:23:08,640
attestation

00:23:04,480 --> 00:23:10,559
primarily because keys are

00:23:08,640 --> 00:23:11,679
typically in hardware and there's really

00:23:10,559 --> 00:23:15,440
no

00:23:11,679 --> 00:23:17,360
no secure way to generate something

00:23:15,440 --> 00:23:19,679
that that you could use that would

00:23:17,360 --> 00:23:23,600
really be usable

00:23:19,679 --> 00:23:27,840
um and then on the trust zone opti side

00:23:23,600 --> 00:23:31,600
we have instructions for

00:23:27,840 --> 00:23:33,360
running in a qmu emulator

00:23:31,600 --> 00:23:35,039
and so that's kind of the same thing you

00:23:33,360 --> 00:23:38,720
don't need you don't even need

00:23:35,039 --> 00:23:41,360
arm hardware to run an oe application

00:23:38,720 --> 00:23:41,360
for opti

00:23:42,880 --> 00:23:47,600
so what do we want to do in the project

00:23:45,679 --> 00:23:51,520
looking forward

00:23:47,600 --> 00:23:53,520
one thing that we've really

00:23:51,520 --> 00:23:56,080
looked into recently we've been

00:23:53,520 --> 00:23:58,400
discussing a lot in our meetings

00:23:56,080 --> 00:23:59,840
and i'll talk a little bit later but

00:23:58,400 --> 00:24:02,000
everyone is welcome

00:23:59,840 --> 00:24:04,559
the community is welcome to to join in

00:24:02,000 --> 00:24:08,880
on any of these discussions

00:24:04,559 --> 00:24:12,080
um is a consistent plug-in api so that

00:24:08,880 --> 00:24:15,120
a new trusted execution environment

00:24:12,080 --> 00:24:17,919
can add support and

00:24:15,120 --> 00:24:19,120
add support for that platform to the oe

00:24:17,919 --> 00:24:22,240
sdk

00:24:19,120 --> 00:24:23,600
in a consistent way so we want to

00:24:22,240 --> 00:24:27,200
provide

00:24:23,600 --> 00:24:27,200
a set of apis that

00:24:27,440 --> 00:24:31,279
a platform must implement to then

00:24:30,640 --> 00:24:32,720
support

00:24:31,279 --> 00:24:35,360
all the other features i talked about

00:24:32,720 --> 00:24:39,120
the layer on top of that

00:24:35,360 --> 00:24:41,440
um another thing is is a discoverable

00:24:39,120 --> 00:24:44,880
support matrix so

00:24:41,440 --> 00:24:47,120
we support maybe some features are

00:24:44,880 --> 00:24:48,880
can be supported on sgx and then some

00:24:47,120 --> 00:24:50,240
features

00:24:48,880 --> 00:24:52,400
you know some of those same features

00:24:50,240 --> 00:24:54,159
don't work on

00:24:52,400 --> 00:24:56,559
trustzone for a number of reasons maybe

00:24:54,159 --> 00:24:58,960
the the memory model is too different to

00:24:56,559 --> 00:25:00,240
support a certain feature

00:24:58,960 --> 00:25:02,559
but we want to make sure that the

00:25:00,240 --> 00:25:04,320
application can figure out

00:25:02,559 --> 00:25:06,320
which features are supported on which

00:25:04,320 --> 00:25:08,640
platforms um

00:25:06,320 --> 00:25:09,440
preferably at runtime and then the

00:25:08,640 --> 00:25:12,080
application can

00:25:09,440 --> 00:25:13,200
can make decisions based on on that

00:25:12,080 --> 00:25:14,799
support matrix

00:25:13,200 --> 00:25:17,120
and then another thing we're striving

00:25:14,799 --> 00:25:19,200
towards in the the coming months is a

00:25:17,120 --> 00:25:22,880
stable public api so we are a

00:25:19,200 --> 00:25:25,760
pre v1 project and so

00:25:22,880 --> 00:25:27,600
so far we try to keep the api as stable

00:25:25,760 --> 00:25:29,840
as possible but

00:25:27,600 --> 00:25:31,360
some things we just realized that hey we

00:25:29,840 --> 00:25:33,039
did this two years ago and this doesn't

00:25:31,360 --> 00:25:36,960
make sense anymore

00:25:33,039 --> 00:25:39,039
so we've had to make some breaking

00:25:36,960 --> 00:25:41,120
changes to the api but

00:25:39,039 --> 00:25:44,559
we want to in the next couple releases

00:25:41,120 --> 00:25:46,320
get to a point where that api is stable

00:25:44,559 --> 00:25:49,679
and so those are also discussions that

00:25:46,320 --> 00:25:52,960
are that are going on right now so

00:25:49,679 --> 00:25:56,159
this is actually from a diagram from

00:25:52,960 --> 00:26:00,240
one of the designs for creating

00:25:56,159 --> 00:26:03,520
a plug-in api for plot for

00:26:00,240 --> 00:26:04,640
various platforms and i've actually i've

00:26:03,520 --> 00:26:07,120
linked the

00:26:04,640 --> 00:26:08,080
the markdown file for this design so all

00:26:07,120 --> 00:26:12,159
of our designs

00:26:08,080 --> 00:26:13,120
go into they're reviewed as markdown

00:26:12,159 --> 00:26:17,600
files

00:26:13,120 --> 00:26:19,679
in prs they go into the repo you can

00:26:17,600 --> 00:26:21,440
go take a look at any of those designs

00:26:19,679 --> 00:26:23,600
and so

00:26:21,440 --> 00:26:25,600
we really want to invite people to to

00:26:23,600 --> 00:26:29,919
come be a part of the project

00:26:25,600 --> 00:26:33,120
and help us make these decisions if you

00:26:29,919 --> 00:26:35,279
want to develop applications for

00:26:33,120 --> 00:26:36,720
for these platforms but maybe you see a

00:26:35,279 --> 00:26:38,640
feature that

00:26:36,720 --> 00:26:40,159
isn't there or some something that you'd

00:26:38,640 --> 00:26:41,039
like to behave differently we want to

00:26:40,159 --> 00:26:42,240
invite people to

00:26:41,039 --> 00:26:44,159
to come join us because these

00:26:42,240 --> 00:26:47,919
discussions are happening right now

00:26:44,159 --> 00:26:47,919
pretty much none of this is set in stone

00:26:48,480 --> 00:26:55,039
so let's talk about something that is

00:26:51,679 --> 00:26:56,159
is fun for me to look at is how the

00:26:55,039 --> 00:26:59,279
project has

00:26:56,159 --> 00:26:59,919
grown and changed in the last 12 months

00:26:59,279 --> 00:27:02,400
so

00:26:59,919 --> 00:27:02,960
um some of the other contributors to the

00:27:02,400 --> 00:27:06,080
project

00:27:02,960 --> 00:27:07,760
gave a presentation on

00:27:06,080 --> 00:27:09,679
on the open enclave sdk at this

00:27:07,760 --> 00:27:12,080
conference last year

00:27:09,679 --> 00:27:13,039
um and so i want to take a look at what

00:27:12,080 --> 00:27:16,960
has changed

00:27:13,039 --> 00:27:19,120
in that time and

00:27:16,960 --> 00:27:21,039
kind of what what the project looks like

00:27:19,120 --> 00:27:24,480
now so

00:27:21,039 --> 00:27:26,480
we're seeing about 20 to 60 commits

00:27:24,480 --> 00:27:29,520
per week that's actually down a little

00:27:26,480 --> 00:27:33,679
bit from 2019

00:27:29,520 --> 00:27:36,640
that's 1200 commits in total

00:27:33,679 --> 00:27:38,480
which is down actually quite a bit from

00:27:36,640 --> 00:27:40,080
2019 and you would think you would look

00:27:38,480 --> 00:27:42,799
at that and you'd say

00:27:40,080 --> 00:27:44,399
well does i mean are people leaving the

00:27:42,799 --> 00:27:46,840
project what's going on

00:27:44,399 --> 00:27:48,080
but i actually think it points more to

00:27:46,840 --> 00:27:51,600
stability

00:27:48,080 --> 00:27:52,000
in the last 12 months there's been a lot

00:27:51,600 --> 00:27:54,159
less

00:27:52,000 --> 00:27:56,880
churn than the previous 12 months in

00:27:54,159 --> 00:28:00,240
kind of core pieces of the code base

00:27:56,880 --> 00:28:02,640
and so there was kind of a

00:28:00,240 --> 00:28:03,360
period where there were tons of changes

00:28:02,640 --> 00:28:06,559
going in

00:28:03,360 --> 00:28:07,120
um lots of of moving pieces lots of

00:28:06,559 --> 00:28:11,279
things

00:28:07,120 --> 00:28:13,679
just didn't didn't work quite right we

00:28:11,279 --> 00:28:14,720
also added a large number of features we

00:28:13,679 --> 00:28:16,799
added

00:28:14,720 --> 00:28:18,480
support for opti so that was just a lot

00:28:16,799 --> 00:28:21,120
of churn in the code base and we're kind

00:28:18,480 --> 00:28:24,320
of settling down to a point where

00:28:21,120 --> 00:28:27,600
we don't we don't need quite so many

00:28:24,320 --> 00:28:29,600
uh commits per weekly

00:28:27,600 --> 00:28:31,200
things things are actually pretty stable

00:28:29,600 --> 00:28:32,880
at this point and so we're just trying

00:28:31,200 --> 00:28:34,960
to to refine it more

00:28:32,880 --> 00:28:36,000
and you can see that the project is is

00:28:34,960 --> 00:28:39,440
growing in that

00:28:36,000 --> 00:28:41,679
um there we have

00:28:39,440 --> 00:28:42,480
over double the number of forks from

00:28:41,679 --> 00:28:45,840
00:28:42,480 --> 00:28:47,679
we've done four releases um

00:28:45,840 --> 00:28:49,279
in the last 12 months and we're looking

00:28:47,679 --> 00:28:51,279
to

00:28:49,279 --> 00:28:52,559
kind of come up with a consistent

00:28:51,279 --> 00:28:57,600
release cadence

00:28:52,559 --> 00:29:00,799
um to get consistent releases out there

00:28:57,600 --> 00:29:02,799
so this year we had 61

00:29:00,799 --> 00:29:05,120
unique contributors to the project

00:29:02,799 --> 00:29:06,799
something amazing is we actually had 63

00:29:05,120 --> 00:29:09,120
unique reviewers so that means that

00:29:06,799 --> 00:29:10,559
almost everybody who's contributing to

00:29:09,120 --> 00:29:12,159
the project who's submitting gold

00:29:10,559 --> 00:29:15,279
requests who's writing code

00:29:12,159 --> 00:29:16,720
is also reviewing other people's code

00:29:15,279 --> 00:29:18,240
and i think that's really cool for a

00:29:16,720 --> 00:29:20,559
project that's maybe not something you

00:29:18,240 --> 00:29:24,559
see in a lot of projects

00:29:20,559 --> 00:29:26,960
that people are really interested in

00:29:24,559 --> 00:29:28,080
in helping out others um i think we have

00:29:26,960 --> 00:29:30,960
a really cool culture

00:29:28,080 --> 00:29:31,919
of accepting new contributions new

00:29:30,960 --> 00:29:33,840
contributors

00:29:31,919 --> 00:29:36,640
and really helping out new contributors

00:29:33,840 --> 00:29:37,200
to to get them started on the project so

00:29:36,640 --> 00:29:39,600
that's

00:29:37,200 --> 00:29:41,520
that's actually really cool to see we

00:29:39,600 --> 00:29:45,039
also have committers from

00:29:41,520 --> 00:29:45,039
five different organizations

00:29:45,200 --> 00:29:49,120
so this is a project that started out as

00:29:47,200 --> 00:29:51,360
a microsoft project

00:29:49,120 --> 00:29:53,279
was donated to the linux foundation

00:29:51,360 --> 00:29:56,399
about a year ago

00:29:53,279 --> 00:29:57,120
and we're seeing the the contributors to

00:29:56,399 --> 00:29:59,360
the project

00:29:57,120 --> 00:30:02,320
grow outside of the bounds of microsoft

00:29:59,360 --> 00:30:02,320
and that's really cool to see

00:30:03,039 --> 00:30:06,720
um something else that we've been kind

00:30:05,600 --> 00:30:09,760
of working towards

00:30:06,720 --> 00:30:12,000
is making all of our communications open

00:30:09,760 --> 00:30:13,600
when you start as a project inside of a

00:30:12,000 --> 00:30:16,000
company

00:30:13,600 --> 00:30:17,520
sometimes that that growing into the

00:30:16,000 --> 00:30:19,919
open can be challenging

00:30:17,520 --> 00:30:21,440
um but i think we've done a great job of

00:30:19,919 --> 00:30:22,799
we've recently made

00:30:21,440 --> 00:30:26,080
every meeting that we have about the

00:30:22,799 --> 00:30:28,480
project is completely open to the public

00:30:26,080 --> 00:30:31,760
we provide links on our mailing list

00:30:28,480 --> 00:30:34,240
links on our github repository

00:30:31,760 --> 00:30:36,399
and there's a calendar of when these

00:30:34,240 --> 00:30:38,640
meetings occur

00:30:36,399 --> 00:30:41,520
so anyone in the community can join any

00:30:38,640 --> 00:30:43,279
meeting we have about the project

00:30:41,520 --> 00:30:45,440
we've created a number of special

00:30:43,279 --> 00:30:48,880
interest groups around

00:30:45,440 --> 00:30:52,080
out-of-station apis and architecture

00:30:48,880 --> 00:30:52,880
testing and tooling and so these groups

00:30:52,080 --> 00:30:54,559
kind of have their

00:30:52,880 --> 00:30:56,559
their own separate meetings that again

00:30:54,559 --> 00:31:00,399
anyone can attend

00:30:56,559 --> 00:31:04,240
and we it's it's allowed the project to

00:31:00,399 --> 00:31:06,559
move a lot faster in that

00:31:04,240 --> 00:31:09,440
as as a smaller group maybe you make

00:31:06,559 --> 00:31:11,919
decisions about attestation

00:31:09,440 --> 00:31:13,440
you have people in these meetings that

00:31:11,919 --> 00:31:16,159
all have a background

00:31:13,440 --> 00:31:16,880
in in the code base they understand what

00:31:16,159 --> 00:31:19,679
the needs

00:31:16,880 --> 00:31:23,200
of at the station are and that allows

00:31:19,679 --> 00:31:24,799
those discussions to move a lot faster

00:31:23,200 --> 00:31:26,640
and then something else we're moving

00:31:24,799 --> 00:31:30,880
towards is openci

00:31:26,640 --> 00:31:33,200
so this is anyone can

00:31:30,880 --> 00:31:34,799
access any of our ci runs and we're

00:31:33,200 --> 00:31:36,159
trying to get to a point where anyone

00:31:34,799 --> 00:31:39,760
can actually

00:31:36,159 --> 00:31:43,279
run their own ci runs on

00:31:39,760 --> 00:31:43,279
on the project's infrastructure

00:31:43,919 --> 00:31:48,640
um yeah so

00:31:46,960 --> 00:31:50,320
for the rest of the time i'm gonna go

00:31:48,640 --> 00:31:50,720
through a demo and we're just gonna look

00:31:50,320 --> 00:31:53,360
at

00:31:50,720 --> 00:31:54,960
what does it look like to develop an oe

00:31:53,360 --> 00:31:57,679
application

00:31:54,960 --> 00:31:59,039
um what does it look like to to debug an

00:31:57,679 --> 00:32:00,960
application what is that tool in one

00:31:59,039 --> 00:32:03,440
like so

00:32:00,960 --> 00:32:06,240
let's see if i can switch over pretty

00:32:03,440 --> 00:32:06,240
seamlessly

00:32:10,480 --> 00:32:12,960
all right

00:32:13,600 --> 00:32:21,600
so sorry just a minute

00:32:17,440 --> 00:32:23,279
so here i have a demo application um

00:32:21,600 --> 00:32:24,799
that i wrote a little bit ago it's

00:32:23,279 --> 00:32:28,320
pretty simple

00:32:24,799 --> 00:32:31,279
um we have

00:32:28,320 --> 00:32:33,120
a host side so let's look at that first

00:32:31,279 --> 00:32:38,080
because that's going to be the most

00:32:33,120 --> 00:32:38,080
familiar to most people just a minute

00:32:40,840 --> 00:32:46,159
okay so

00:32:44,159 --> 00:32:49,120
we have a main function this is just you

00:32:46,159 --> 00:32:52,880
know your your standard c application

00:32:49,120 --> 00:32:54,320
um we have some creation code so this is

00:32:52,880 --> 00:32:58,640
setting up the application

00:32:54,320 --> 00:33:02,159
the uh enclave telling it which

00:32:58,640 --> 00:33:04,640
what's the enclave binary i want to run

00:33:02,159 --> 00:33:06,480
some flags so you can see i've passed a

00:33:04,640 --> 00:33:11,120
debug flag

00:33:06,480 --> 00:33:11,600
and simulation flag so this allows me to

00:33:11,120 --> 00:33:15,360
run

00:33:11,600 --> 00:33:17,440
in simulation mode um and this allows me

00:33:15,360 --> 00:33:19,919
to attach a debugger to

00:33:17,440 --> 00:33:20,480
my enclave code and then i just pass all

00:33:19,919 --> 00:33:24,559
that to

00:33:20,480 --> 00:33:25,360
a create and that create that creates a

00:33:24,559 --> 00:33:29,840
siloed

00:33:25,360 --> 00:33:33,200
um section of of code and data

00:33:29,840 --> 00:33:34,799
for me to run my enclave in and then

00:33:33,200 --> 00:33:36,640
we'll come back to this in a minute but

00:33:34,799 --> 00:33:39,760
we also have

00:33:36,640 --> 00:33:43,360
a call into the enclave

00:33:39,760 --> 00:33:44,799
and we get a value out and we

00:33:43,360 --> 00:33:48,080
print it out and that's it that's all

00:33:44,799 --> 00:33:48,080
the application does at this point

00:33:50,080 --> 00:33:54,320
and let's look at what how how i'm going

00:33:53,360 --> 00:33:57,360
to build that

00:33:54,320 --> 00:34:01,279
host application it it will look pretty

00:33:57,360 --> 00:34:02,880
pretty familiar the only thing that

00:34:01,279 --> 00:34:04,799
maybe looks different from your

00:34:02,880 --> 00:34:06,480
traditional application

00:34:04,799 --> 00:34:08,320
is that you can see this tool that i

00:34:06,480 --> 00:34:09,440
talked about earlier this oedgerator

00:34:08,320 --> 00:34:13,839
tool

00:34:09,440 --> 00:34:17,359
um and i'm gonna pass it my my

00:34:13,839 --> 00:34:19,919
interface definition file and

00:34:17,359 --> 00:34:21,599
it will generate a c file that

00:34:19,919 --> 00:34:23,040
implements that glue code that i talked

00:34:21,599 --> 00:34:26,079
about earlier

00:34:23,040 --> 00:34:28,879
otherwise it's it's just pretty much

00:34:26,079 --> 00:34:29,200
what you would expect so let's take a

00:34:28,879 --> 00:34:32,839
look

00:34:29,200 --> 00:34:37,280
at the interface

00:34:32,839 --> 00:34:40,879
definition so you can see i have

00:34:37,280 --> 00:34:44,560
um it is kind of like a

00:34:40,879 --> 00:34:44,560
pseudo c-like language but

00:34:44,879 --> 00:34:51,359
i can define trusted

00:34:48,159 --> 00:34:54,399
function calls so this is called from

00:34:51,359 --> 00:34:57,680
the host to the enclave

00:34:54,399 --> 00:35:01,359
and this is just it will

00:34:57,680 --> 00:35:04,880
this is to provide edgerater some

00:35:01,359 --> 00:35:04,880
definition for how it will

00:35:05,359 --> 00:35:14,160
generate the the glue code i could

00:35:08,800 --> 00:35:16,240
also write an untrusted function

00:35:14,160 --> 00:35:17,839
which is a call from the enclave to the

00:35:16,240 --> 00:35:21,760
host

00:35:17,839 --> 00:35:21,760
and it basically looks the same

00:35:24,240 --> 00:35:27,680
so i can give parameters

00:35:28,160 --> 00:35:33,040
i can pass pointers you know etc

00:35:34,960 --> 00:35:39,030
so then

00:35:35,930 --> 00:35:39,030
[Music]

00:35:40,000 --> 00:35:44,000
in the enclave you can see all i have is

00:35:43,200 --> 00:35:47,119
a definition

00:35:44,000 --> 00:35:49,920
for whatever e calls whatever enclave

00:35:47,119 --> 00:35:52,079
calls i defined in edl

00:35:49,920 --> 00:35:54,960
so i defined the interface in edl and

00:35:52,079 --> 00:35:56,720
then here i have

00:35:54,960 --> 00:35:58,560
what the implementation of that function

00:35:56,720 --> 00:36:00,960
does so i have a function that just

00:35:58,560 --> 00:36:02,400
adds two numbers that were passed in as

00:36:00,960 --> 00:36:04,160
parameters

00:36:02,400 --> 00:36:08,000
and you can see that edgerator also

00:36:04,160 --> 00:36:10,480
generated a header file for me

00:36:08,000 --> 00:36:12,480
which defines this function and it

00:36:10,480 --> 00:36:14,480
generates a host side header file as

00:36:12,480 --> 00:36:17,680
well

00:36:14,480 --> 00:36:21,920
so on the enclave there's a little more

00:36:17,680 --> 00:36:25,040
interesting things going on in the build

00:36:21,920 --> 00:36:25,040
so you can see

00:36:25,599 --> 00:36:29,119
here it looks kind of the same as the

00:36:27,680 --> 00:36:32,880
host we generated

00:36:29,119 --> 00:36:34,560
some we generated a c step file for the

00:36:32,880 --> 00:36:38,400
enclave side

00:36:34,560 --> 00:36:43,119
um we're compiling you know the same

00:36:38,400 --> 00:36:45,760
same way we did before and then

00:36:43,119 --> 00:36:47,119
on the unclear side we also want to sign

00:36:45,760 --> 00:36:50,800
the binary so that

00:36:47,119 --> 00:36:54,640
when it's loaded by sgx

00:36:50,800 --> 00:36:54,640
the signature is validated

00:36:55,280 --> 00:37:01,599
by to be a trusted

00:36:58,720 --> 00:37:03,280
party and in the attestation report for

00:37:01,599 --> 00:37:05,440
the enclave it will show

00:37:03,280 --> 00:37:06,640
who signed it what was the the signature

00:37:05,440 --> 00:37:10,240
contents

00:37:06,640 --> 00:37:13,839
what was the hash of the binary that was

00:37:10,240 --> 00:37:17,280
loaded into the enclave um

00:37:13,839 --> 00:37:17,680
so those can all be validated at runtime

00:37:17,280 --> 00:37:19,760
by

00:37:17,680 --> 00:37:21,359
by some other party that wants to to

00:37:19,760 --> 00:37:24,000
trust the

00:37:21,359 --> 00:37:24,960
enclave running so here we just

00:37:24,000 --> 00:37:28,560
generated

00:37:24,960 --> 00:37:30,160
a key pair and used the oe sign tool

00:37:28,560 --> 00:37:33,920
which will

00:37:30,160 --> 00:37:39,359
generate a platform-specific signature

00:37:33,920 --> 00:37:43,599
for the binary um actually really quick

00:37:39,359 --> 00:37:43,599
you also notice that there is a

00:37:43,839 --> 00:37:48,240
pump file that i passed at signing time

00:37:48,720 --> 00:37:53,680
and this defines some basic things about

00:37:52,079 --> 00:37:57,520
the enclave so this is

00:37:53,680 --> 00:38:00,400
how many memory pages i'm going to load

00:37:57,520 --> 00:38:02,079
um how many thread structures i have and

00:38:00,400 --> 00:38:03,920
this is kind of platform specific

00:38:02,079 --> 00:38:06,880
information

00:38:03,920 --> 00:38:08,480
is the enclave debuggable if i don't

00:38:06,880 --> 00:38:11,680
allow it to be debuggable then

00:38:08,480 --> 00:38:13,680
i can't pass that debug flag that we saw

00:38:11,680 --> 00:38:15,200
earlier and i can't attach a debugger so

00:38:13,680 --> 00:38:16,960
there's kind of some

00:38:15,200 --> 00:38:18,400
some configurations you can do at

00:38:16,960 --> 00:38:22,079
signing time so

00:38:18,400 --> 00:38:25,119
that if you want to sign an application

00:38:22,079 --> 00:38:26,320
for debug mode or for you know your

00:38:25,119 --> 00:38:28,720
production mode

00:38:26,320 --> 00:38:30,480
you can do that without changing the

00:38:28,720 --> 00:38:32,400
code

00:38:30,480 --> 00:38:34,480
so let's go ahead and build this

00:38:32,400 --> 00:38:39,839
application

00:38:34,480 --> 00:38:43,040
um i'm going to just

00:38:39,839 --> 00:38:46,320
we already i previously installed

00:38:43,040 --> 00:38:49,359
the oe sdk

00:38:46,320 --> 00:38:50,000
um at this location at this open enclave

00:38:49,359 --> 00:38:52,160
location

00:38:50,000 --> 00:38:54,800
and this file that i'm sourcing is just

00:38:52,160 --> 00:39:01,200
to set up my path so that i can find

00:38:54,800 --> 00:39:03,839
my package config files basically

00:39:01,200 --> 00:39:05,359
okay so that was pretty easy i built the

00:39:03,839 --> 00:39:07,359
application and then let's go ahead and

00:39:05,359 --> 00:39:11,520
run it

00:39:07,359 --> 00:39:11,520
so i we can see in our host

00:39:12,720 --> 00:39:17,040
we just told the enclave add the number

00:39:14,800 --> 00:39:19,440
one and two

00:39:17,040 --> 00:39:20,800
and print the result and so you can see

00:39:19,440 --> 00:39:22,400
we added the number one and two and we

00:39:20,800 --> 00:39:25,760
got three

00:39:22,400 --> 00:39:26,240
um so let's look at what does it look

00:39:25,760 --> 00:39:29,359
like

00:39:26,240 --> 00:39:32,160
to attach a debugger to

00:39:29,359 --> 00:39:34,320
separate points so we have this oegdb

00:39:32,160 --> 00:39:38,079
which is basically just a thin wrapper

00:39:34,320 --> 00:39:38,079
and a python plug-in to gdb

00:39:39,839 --> 00:39:43,839
and we will go ahead and run it

00:39:44,160 --> 00:39:47,520
run the application under that

00:39:50,000 --> 00:39:57,839
sorry i can't quite see the bottom there

00:39:51,760 --> 00:39:57,839
we go

00:40:04,240 --> 00:40:08,480
so let's go ahead and just break on main

00:40:07,040 --> 00:40:10,720
really quick

00:40:08,480 --> 00:40:11,680
so this is in the untrusted portion this

00:40:10,720 --> 00:40:14,720
is you know

00:40:11,680 --> 00:40:18,079
no no oe plug-in magic going on here

00:40:14,720 --> 00:40:18,079
this is just a normal gdp

00:40:18,560 --> 00:40:25,839
okay great so we have um

00:40:26,560 --> 00:40:29,680
we have our our main application we we

00:40:28,800 --> 00:40:33,839
break them

00:40:29,680 --> 00:40:33,839
so let's look at

00:40:34,160 --> 00:40:38,319
can we set a breakpoint inside the

00:40:36,839 --> 00:40:40,400
enclave

00:40:38,319 --> 00:40:41,920
we want to check out what is what is

00:40:40,400 --> 00:40:42,560
this function doing obviously this is

00:40:41,920 --> 00:40:47,119
very simple

00:40:42,560 --> 00:40:47,520
but you can see how it would be useful

00:40:47,119 --> 00:40:51,599
in

00:40:47,520 --> 00:40:56,079
in other cases so we are going to

00:40:51,599 --> 00:40:56,079
set a breakpoint on the add numbs equal

00:41:01,520 --> 00:41:05,040
this is actually you can see it set a

00:41:04,400 --> 00:41:08,640
breakpoint

00:41:05,040 --> 00:41:10,880
in sample underscore u.c

00:41:08,640 --> 00:41:12,079
that's actually still on the host

00:41:10,880 --> 00:41:14,160
anything

00:41:12,079 --> 00:41:15,520
the underscore u is the generated host

00:41:14,160 --> 00:41:16,960
code

00:41:15,520 --> 00:41:18,880
so we're actually going to break really

00:41:16,960 --> 00:41:23,119
quick in

00:41:18,880 --> 00:41:26,560
the glue code um but if we continue

00:41:23,119 --> 00:41:28,160
again we see that we have a

00:41:26,560 --> 00:41:30,400
a corresponding function inside the

00:41:28,160 --> 00:41:34,640
enclave that we've uh broken on

00:41:30,400 --> 00:41:37,920
so we're gonna a print b

00:41:34,640 --> 00:41:37,920
we got the values we expected

00:41:39,839 --> 00:41:46,880
continue and we we exit normally so

00:41:44,240 --> 00:41:48,640
this is basically looks you know as

00:41:46,880 --> 00:41:50,880
you'd expect this is the exact same

00:41:48,640 --> 00:41:52,319
as attaching gdb to any other

00:41:50,880 --> 00:41:54,480
application

00:41:52,319 --> 00:41:56,560
under the hood there's a lot more going

00:41:54,480 --> 00:41:59,839
on um

00:41:56,560 --> 00:41:59,839
for how do you

00:42:00,400 --> 00:42:03,520
you know make the stack look the same

00:42:02,400 --> 00:42:07,119
across

00:42:03,520 --> 00:42:10,079
the you know the host to enclave

00:42:07,119 --> 00:42:11,200
function called boundary how do you

00:42:10,079 --> 00:42:14,240
marshal parameters

00:42:11,200 --> 00:42:16,079
et cetera um but from

00:42:14,240 --> 00:42:17,680
a usability perspective it basically

00:42:16,079 --> 00:42:20,079
just looks the same

00:42:17,680 --> 00:42:20,079
so cool

00:42:22,720 --> 00:42:27,040
so that is pretty much all i have you

00:42:25,520 --> 00:42:30,800
can start

00:42:27,040 --> 00:42:33,280
dropping questions in

00:42:30,800 --> 00:42:36,560
oh just a minute you can start dropping

00:42:33,280 --> 00:42:38,000
questions in the chat and i will

00:42:36,560 --> 00:42:40,400
answer them as they come in thanks

00:42:38,000 --> 00:42:40,400
everybody

00:42:43,599 --> 00:42:48,720
okay so first question is

00:42:46,720 --> 00:42:50,960
is this only targeted for cloud or does

00:42:48,720 --> 00:42:52,880
this apply generically such as to

00:42:50,960 --> 00:42:55,359
embedded systems

00:42:52,880 --> 00:42:56,319
so it kind of depends on what hardware

00:42:55,359 --> 00:43:00,720
you want to

00:42:56,319 --> 00:43:04,000
target so for um the arm trust zone

00:43:00,720 --> 00:43:07,040
uh opti support this is

00:43:04,000 --> 00:43:09,119
primarily on

00:43:07,040 --> 00:43:10,560
embedded systems iot devices i don't

00:43:09,119 --> 00:43:14,000
really

00:43:10,560 --> 00:43:17,119
i haven't seen much use of

00:43:14,000 --> 00:43:19,119
opti outside of of that space um

00:43:17,119 --> 00:43:20,880
maybe maybe it exists but not that i

00:43:19,119 --> 00:43:24,640
have seen um

00:43:20,880 --> 00:43:27,920
a lot of sgx usage is

00:43:24,640 --> 00:43:32,079
in in cloud on server class devices but

00:43:27,920 --> 00:43:34,640
um there is also sgx support on

00:43:32,079 --> 00:43:36,000
client devices so so it's pretty much to

00:43:34,640 --> 00:43:36,960
answer your question no it's not just

00:43:36,000 --> 00:43:38,560
for cloud

00:43:36,960 --> 00:43:40,480
it just kind of depends on on what

00:43:38,560 --> 00:43:41,280
hardware you want to target but the sdk

00:43:40,480 --> 00:43:45,680
in general

00:43:41,280 --> 00:43:48,240
is is aimed at

00:43:45,680 --> 00:43:51,599
any any enclave applications you want to

00:43:48,240 --> 00:43:51,599
develop for any hardware problem

00:43:52,839 --> 00:43:55,920
um this is kind of a similar question

00:43:55,440 --> 00:43:58,560
does

00:43:55,920 --> 00:43:58,960
open enclave target microcontrollers

00:43:58,560 --> 00:44:02,079
like

00:43:58,960 --> 00:44:05,599
arms tf-m um

00:44:02,079 --> 00:44:06,839
we target any arm platforms that support

00:44:05,599 --> 00:44:09,680
opti

00:44:06,839 --> 00:44:13,040
so i don't know

00:44:09,680 --> 00:44:14,800
a ton about the the armboard space

00:44:13,040 --> 00:44:17,760
but anywhere you can run opti you can

00:44:14,800 --> 00:44:17,760
run open enclave

00:44:18,640 --> 00:44:22,000
okay does the project use some kind of

00:44:21,359 --> 00:44:27,040
security

00:44:22,000 --> 00:44:27,040
test verification on the code so

00:44:27,119 --> 00:44:33,040
we have a number of people that

00:44:30,800 --> 00:44:33,040
do

00:44:33,920 --> 00:44:40,480
security audits of

00:44:36,960 --> 00:44:42,480
the code we don't have

00:44:40,480 --> 00:44:44,000
i guess i don't i don't know exactly

00:44:42,480 --> 00:44:44,480
what the question is asking if there's a

00:44:44,000 --> 00:44:47,530
more

00:44:44,480 --> 00:44:49,359
maybe formal security verification

00:44:47,530 --> 00:44:53,119
[Music]

00:44:49,359 --> 00:44:55,680
that you're looking for there's that i'm

00:44:53,119 --> 00:44:57,920
not familiar with but we do have people

00:44:55,680 --> 00:45:01,040
looking at the code

00:44:57,920 --> 00:45:03,359
um looking for security vulnerabilities

00:45:01,040 --> 00:45:04,400
we address them as they come up

00:45:03,359 --> 00:45:08,240
i don't know if that answers the

00:45:04,400 --> 00:45:11,599
question what are some of the milestones

00:45:08,240 --> 00:45:13,119
on the roadmap for the oe sdk in general

00:45:11,599 --> 00:45:14,720
so this is pretty much what i talked

00:45:13,119 --> 00:45:18,160
about earlier this is

00:45:14,720 --> 00:45:21,280
a stable api is a really big one

00:45:18,160 --> 00:45:23,920
the as as an

00:45:21,280 --> 00:45:25,920
sdk platform we that wants to kind of

00:45:23,920 --> 00:45:29,040
target multiple hardware vendors

00:45:25,920 --> 00:45:31,119
and make it

00:45:29,040 --> 00:45:33,280
easy for anyone to write an application

00:45:31,119 --> 00:45:35,760
and run it wherever

00:45:33,280 --> 00:45:37,119
having an api that doesn't change is

00:45:35,760 --> 00:45:40,000
pretty important for that

00:45:37,119 --> 00:45:42,400
um we don't want to be breaking our

00:45:40,000 --> 00:45:44,400
users on every release so that's

00:45:42,400 --> 00:45:46,400
i would say a pretty big milestone that

00:45:44,400 --> 00:45:49,520
we're shooting for

00:45:46,400 --> 00:45:51,040
um another

00:45:49,520 --> 00:45:53,040
another thing that we're shooting for is

00:45:51,040 --> 00:45:55,040
making it easy for

00:45:53,040 --> 00:45:57,040
hardware vendors or people that want to

00:45:55,040 --> 00:45:59,680
add support for more platforms

00:45:57,040 --> 00:46:00,400
to come in and do that in a consistent

00:45:59,680 --> 00:46:03,359
way

00:46:00,400 --> 00:46:04,800
um how can you know what's the advice we

00:46:03,359 --> 00:46:07,760
give to people what is the

00:46:04,800 --> 00:46:08,640
are the platforms and tool the tooling

00:46:07,760 --> 00:46:15,839
we give

00:46:08,640 --> 00:46:15,839
to allow people to implement that

00:46:16,240 --> 00:46:22,079
okay so for the question earlier about

00:46:19,839 --> 00:46:25,760
um does open enclave target

00:46:22,079 --> 00:46:29,280
microcontrollers like arms tf-m

00:46:25,760 --> 00:46:33,040
um someone dave on the project has

00:46:29,280 --> 00:46:35,760
answered that we only support tf-a not

00:46:33,040 --> 00:46:35,760
tf-m

00:46:35,839 --> 00:46:41,040
what os is run inside the enclave so

00:46:39,440 --> 00:46:42,880
again it depends like i said on

00:46:41,040 --> 00:46:46,079
trustzone it's

00:46:42,880 --> 00:46:48,400
running it's running off the os on sgx

00:46:46,079 --> 00:46:51,760
there really is no operating system

00:46:48,400 --> 00:46:54,880
we actually have specifically

00:46:51,760 --> 00:46:56,560
built the

00:46:54,880 --> 00:46:59,119
you know the libsy and the in the

00:46:56,560 --> 00:47:03,119
library layering just

00:46:59,119 --> 00:47:07,280
directly on top of oe um

00:47:03,119 --> 00:47:10,000
library code so

00:47:07,280 --> 00:47:12,079
the the kind of syscall layer that i

00:47:10,000 --> 00:47:13,760
talked about earlier relies primarily on

00:47:12,079 --> 00:47:15,359
the host operating system

00:47:13,760 --> 00:47:19,760
but other than that there's no operating

00:47:15,359 --> 00:47:19,760
system running inside of the sgx enclave

00:47:22,839 --> 00:47:28,960
um

00:47:25,280 --> 00:47:31,599
okay that's all i'm seeing

00:47:28,960 --> 00:47:31,599
so far

00:47:33,920 --> 00:47:38,240
so i'll give i think we only have like a

00:47:36,559 --> 00:47:39,119
couple minutes left but i'll give a

00:47:38,240 --> 00:47:42,400
couple minutes

00:47:39,119 --> 00:47:44,480
to wait for any other questions to come

00:47:42,400 --> 00:47:44,480
in

00:47:47,440 --> 00:47:53,040
is there already any use case in other

00:47:50,839 --> 00:47:56,000
projects

00:47:53,040 --> 00:47:56,960
um i don't quite know what this was

00:47:56,000 --> 00:48:00,400
asking i guess

00:47:56,960 --> 00:48:02,720
does it oh i see is the open enclave sdk

00:48:00,400 --> 00:48:06,240
used by other projects so we do have

00:48:02,720 --> 00:48:09,440
um a few projects that we do know

00:48:06,240 --> 00:48:11,119
use the open enclose sdk as as the basis

00:48:09,440 --> 00:48:14,240
for their

00:48:11,119 --> 00:48:17,920
projects so that is the the ccf

00:48:14,240 --> 00:48:19,520
confidential computing framework um

00:48:17,920 --> 00:48:23,599
you can go check that out on github they

00:48:19,520 --> 00:48:25,599
are built on top of the open enclave sdk

00:48:23,599 --> 00:48:26,880
there's also a project that was

00:48:25,599 --> 00:48:30,559
announced recently

00:48:26,880 --> 00:48:31,520
called sgxlkl and this is an attempt to

00:48:30,559 --> 00:48:35,200
run

00:48:31,520 --> 00:48:38,319
the uh linux kernel

00:48:35,200 --> 00:48:40,800
as as the linux kernel library um which

00:48:38,319 --> 00:48:43,119
is a library os that

00:48:40,800 --> 00:48:45,200
mostly reuses all the linux kernel code

00:48:43,119 --> 00:48:45,839
to run that inside of sgx so that you

00:48:45,200 --> 00:48:48,400
can run

00:48:45,839 --> 00:48:50,720
unmodified linux applications inside of

00:48:48,400 --> 00:48:53,680
an sgx enclave

00:48:50,720 --> 00:48:57,119
and that that project is built on top of

00:48:53,680 --> 00:48:57,119
the open enclave sdk as well

00:49:00,319 --> 00:49:03,599
all right so it looks like that's about

00:49:01,680 --> 00:49:06,240
it for questions

00:49:03,599 --> 00:49:06,720
um thanks everybody for attending uh i

00:49:06,240 --> 00:49:08,160
will

00:49:06,720 --> 00:49:09,920
probably be in slack for a little bit

00:49:08,160 --> 00:49:12,640
after this and

00:49:09,920 --> 00:49:13,920
i'll be in the confidential computing

00:49:12,640 --> 00:49:17,839
consortium booth

00:49:13,920 --> 00:49:17,839
for about an hour

00:49:17,920 --> 00:49:30,559
in a couple of hours here so thanks

00:49:20,319 --> 00:49:30,559

YouTube URL: https://www.youtube.com/watch?v=rIWD3Euudws


