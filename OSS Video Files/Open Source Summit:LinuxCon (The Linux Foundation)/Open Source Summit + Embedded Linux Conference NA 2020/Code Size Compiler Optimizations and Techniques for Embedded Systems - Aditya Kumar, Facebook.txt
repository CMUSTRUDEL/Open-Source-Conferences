Title: Code Size Compiler Optimizations and Techniques for Embedded Systems - Aditya Kumar, Facebook
Publication date: 2020-09-08
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	Code Size Compiler Optimizations and Techniques for Embedded Systems - Aditya Kumar, Facebook
Captions: 
	00:00:01,120 --> 00:00:04,560
two one

00:00:10,240 --> 00:00:16,080
hello everyone i am aditya

00:00:13,599 --> 00:00:16,720
i work as a software engineer at

00:00:16,080 --> 00:00:19,439
facebook

00:00:16,720 --> 00:00:19,840
i mostly work on software engineering

00:00:19,439 --> 00:00:23,279
and

00:00:19,840 --> 00:00:23,279
performance optimizations

00:00:23,439 --> 00:00:30,240
in the in the recent years code size of

00:00:26,880 --> 00:00:30,880
a binary has become critical especially

00:00:30,240 --> 00:00:34,800
on

00:00:30,880 --> 00:00:38,399
embedded systems mobile devices etc

00:00:34,800 --> 00:00:39,200
because we as a user we want more

00:00:38,399 --> 00:00:41,520
features

00:00:39,200 --> 00:00:43,200
and developers put more features into

00:00:41,520 --> 00:00:46,719
the mobile applications

00:00:43,200 --> 00:00:49,920
or um any constraint devices

00:00:46,719 --> 00:00:52,719
more features means more code

00:00:49,920 --> 00:00:53,600
and the amount of code keeps piling up

00:00:52,719 --> 00:00:56,879
and that

00:00:53,600 --> 00:00:57,680
results in download increased download

00:00:56,879 --> 00:01:00,800
size

00:00:57,680 --> 00:01:04,799
it results in slow startup time

00:01:00,800 --> 00:01:06,720
etc so as a performance engineer

00:01:04,799 --> 00:01:08,400
or people who work on software software

00:01:06,720 --> 00:01:11,439
engineering of the code base

00:01:08,400 --> 00:01:13,680
we need to take care of the code size of

00:01:11,439 --> 00:01:16,240
applications

00:01:13,680 --> 00:01:17,360
now here we will discuss what are the

00:01:16,240 --> 00:01:19,680
commonly

00:01:17,360 --> 00:01:22,159
well known techniques that can be used

00:01:19,680 --> 00:01:25,840
to reduce code size

00:01:22,159 --> 00:01:29,280
most of these you can do right

00:01:25,840 --> 00:01:32,400
by using the features of compiler or

00:01:29,280 --> 00:01:37,439
standard software engineering techniques

00:01:32,400 --> 00:01:37,439
so let's go to the next idea

00:01:38,880 --> 00:01:46,159
here today i will be discussing

00:01:42,880 --> 00:01:49,439
different methodologies of com

00:01:46,159 --> 00:01:49,439
of code size reduction

00:01:49,680 --> 00:01:53,360
the first one is using compiler

00:01:51,520 --> 00:01:55,439
optimizations

00:01:53,360 --> 00:01:57,840
then the second one is c plus plus

00:01:55,439 --> 00:01:59,759
library optimizations

00:01:57,840 --> 00:02:01,280
especially c plus plus because we know

00:01:59,759 --> 00:02:04,159
we have templates etc

00:02:01,280 --> 00:02:05,520
and that results in a lot of code bloat

00:02:04,159 --> 00:02:09,840
the third one is

00:02:05,520 --> 00:02:09,840
source code optimizations

00:02:10,640 --> 00:02:15,200
and the fourth one is by getting insight

00:02:13,760 --> 00:02:17,120
into the software

00:02:15,200 --> 00:02:18,879
like introspecting into the code base

00:02:17,120 --> 00:02:23,840
and seeing what

00:02:18,879 --> 00:02:23,840
how we can improve the code size there

00:02:36,080 --> 00:02:38,800
okay yeah

00:02:40,800 --> 00:02:46,160
so let's start with code size

00:02:42,959 --> 00:02:46,160
optimization flags

00:02:47,040 --> 00:02:50,400
there are many different code size

00:02:48,560 --> 00:02:52,640
optimization flags but i'll

00:02:50,400 --> 00:02:54,879
discuss some of the popular ones that

00:02:52,640 --> 00:02:57,840
can that are easy to understand

00:02:54,879 --> 00:03:00,239
the first one is the compiler flag os

00:02:57,840 --> 00:03:03,040
this one is well known to many people

00:03:00,239 --> 00:03:04,239
so if you just are not using this

00:03:03,040 --> 00:03:06,720
optimization flag

00:03:04,239 --> 00:03:08,720
you can just go and change your existing

00:03:06,720 --> 00:03:12,159
compiler optimization flag to dash

00:03:08,720 --> 00:03:14,000
os this is supported in both gcc and

00:03:12,159 --> 00:03:16,640
llvm compilers

00:03:14,000 --> 00:03:18,000
what it does is it does not it doesn't

00:03:16,640 --> 00:03:20,080
try to compromise speed

00:03:18,000 --> 00:03:21,680
with code size so it will only reduce

00:03:20,080 --> 00:03:23,599
code size when

00:03:21,680 --> 00:03:25,680
it is possible without sacrificing the

00:03:23,599 --> 00:03:28,000
speed of course this is all

00:03:25,680 --> 00:03:28,959
static analysis of compiler so there can

00:03:28,000 --> 00:03:31,040
be some

00:03:28,959 --> 00:03:32,959
performance degradation or improvements

00:03:31,040 --> 00:03:34,640
depending on the

00:03:32,959 --> 00:03:36,239
depending on the workload and the code

00:03:34,640 --> 00:03:38,239
base

00:03:36,239 --> 00:03:39,519
llvm has additional compiler

00:03:38,239 --> 00:03:43,200
optimization called

00:03:39,519 --> 00:03:46,000
dash oz which which

00:03:43,200 --> 00:03:46,720
optimizes for code size so even if the

00:03:46,000 --> 00:03:48,799
speed

00:03:46,720 --> 00:03:51,040
of the runtime performance of an

00:03:48,799 --> 00:03:53,040
application will get compromised

00:03:51,040 --> 00:03:55,840
it will still do that optimization in

00:03:53,040 --> 00:03:58,799
order to save code size

00:03:55,840 --> 00:04:00,400
this is very helpful in many

00:03:58,799 --> 00:04:02,000
applications where

00:04:00,400 --> 00:04:04,239
the app size is becoming larger and

00:04:02,000 --> 00:04:07,040
larger and most of the code

00:04:04,239 --> 00:04:07,760
part of the code base are not very

00:04:07,040 --> 00:04:11,040
exercised

00:04:07,760 --> 00:04:12,879
during the usage so

00:04:11,040 --> 00:04:15,519
optimizing for code size make a lot of

00:04:12,879 --> 00:04:18,400
sense in that cases

00:04:15,519 --> 00:04:19,040
these are the popular ones uh the third

00:04:18,400 --> 00:04:22,400
one is

00:04:19,040 --> 00:04:23,680
f no function sections what happens is

00:04:22,400 --> 00:04:27,040
when we

00:04:23,680 --> 00:04:28,160
compile program using uh like cc plus

00:04:27,040 --> 00:04:31,600
plus programs

00:04:28,160 --> 00:04:34,639
um using like gcc or llvm

00:04:31,600 --> 00:04:37,759
there are situations where functions are

00:04:34,639 --> 00:04:39,280
placed in their own sections

00:04:37,759 --> 00:04:41,199
this doesn't happen all the time but

00:04:39,280 --> 00:04:42,479
there can be situation where it is

00:04:41,199 --> 00:04:44,320
possible

00:04:42,479 --> 00:04:47,360
and this is very helpful for debugging

00:04:44,320 --> 00:04:49,440
purposes profiling purposes

00:04:47,360 --> 00:04:50,400
but when we deploy the code on in

00:04:49,440 --> 00:04:54,720
production

00:04:50,400 --> 00:04:57,360
this is not very code size friendly it

00:04:54,720 --> 00:04:58,479
increases the code size quite a bit so

00:04:57,360 --> 00:05:01,919
if by mistake

00:04:58,479 --> 00:05:04,000
or by some build system rules you have

00:05:01,919 --> 00:05:07,440
this flag enabled you want to

00:05:04,000 --> 00:05:09,680
add if no function sections so

00:05:07,440 --> 00:05:10,880
the original flag is f function sections

00:05:09,680 --> 00:05:13,680
that says

00:05:10,880 --> 00:05:15,199
put every function in a separate section

00:05:13,680 --> 00:05:16,000
so you want to get rid of that you want

00:05:15,199 --> 00:05:19,680
to

00:05:16,000 --> 00:05:22,880
add f no function sections similarly

00:05:19,680 --> 00:05:23,440
the fourth one is f no unroll loops loop

00:05:22,880 --> 00:05:25,600
unrolling

00:05:23,440 --> 00:05:27,360
is a very well known optimization it

00:05:25,600 --> 00:05:29,120
increases the code size but

00:05:27,360 --> 00:05:31,919
but it improves the performance quite a

00:05:29,120 --> 00:05:34,720
bit on many uh workloads

00:05:31,919 --> 00:05:36,840
but as we are talking about code size so

00:05:34,720 --> 00:05:38,400
we do not want a lot of loops to be

00:05:36,840 --> 00:05:40,880
unrolled

00:05:38,400 --> 00:05:41,520
so if we add fno unroll loops compiler

00:05:40,880 --> 00:05:45,120
will not

00:05:41,520 --> 00:05:48,560
unroll any loop now the thing is

00:05:45,120 --> 00:05:50,960
if you if your application has different

00:05:48,560 --> 00:05:52,080
components some of them are performance

00:05:50,960 --> 00:05:55,759
critical

00:05:52,080 --> 00:05:58,960
let's say if there are code which have

00:05:55,759 --> 00:06:02,000
like which are um like some kind of

00:05:58,960 --> 00:06:02,960
um dsp algorithm or some kind of camera

00:06:02,000 --> 00:06:06,160
algorithm

00:06:02,960 --> 00:06:08,319
they need to be fast even if you your

00:06:06,160 --> 00:06:10,560
app size want to be small but you still

00:06:08,319 --> 00:06:13,120
want those parts of the code to be fast

00:06:10,560 --> 00:06:14,160
so some careful analysis is required

00:06:13,120 --> 00:06:18,000
there

00:06:14,160 --> 00:06:21,759
okay now

00:06:18,000 --> 00:06:24,960
the fifth one is

00:06:21,759 --> 00:06:24,960
f no exceptions

00:06:26,720 --> 00:06:33,199
what happens is in c plus applications

00:06:30,000 --> 00:06:34,080
exceptions are enabled by default so we

00:06:33,199 --> 00:06:36,800
have try block

00:06:34,080 --> 00:06:37,919
catch block many of the c standard

00:06:36,800 --> 00:06:40,960
library functions

00:06:37,919 --> 00:06:43,360
are have exceptions enabled by default

00:06:40,960 --> 00:06:44,000
what happens is now the compiler needs

00:06:43,360 --> 00:06:45,840
to emit

00:06:44,000 --> 00:06:47,680
runtime code this is the abstraction

00:06:45,840 --> 00:06:51,759
penalty of exceptions

00:06:47,680 --> 00:06:56,000
to handle when an exception is thrown

00:06:51,759 --> 00:06:58,319
and that adds a lot of code size so

00:06:56,000 --> 00:06:59,919
we can add this flag it is not trivial

00:06:58,319 --> 00:07:02,800
because if you have

00:06:59,919 --> 00:07:03,280
throw statements in your code base if no

00:07:02,800 --> 00:07:05,520
exception

00:07:03,280 --> 00:07:06,560
and the compilation will just fail so

00:07:05,520 --> 00:07:08,479
some some

00:07:06,560 --> 00:07:10,479
software restructuring is required as

00:07:08,479 --> 00:07:11,520
well you can partition the code base

00:07:10,479 --> 00:07:14,160
into parts which

00:07:11,520 --> 00:07:15,840
can throw and which do not and get

00:07:14,160 --> 00:07:18,160
advantage of this function but it's

00:07:15,840 --> 00:07:19,919
slightly non-trivial

00:07:18,160 --> 00:07:22,080
but it will save you a lot of code size

00:07:19,919 --> 00:07:23,440
if you have a decent amount of c plus

00:07:22,080 --> 00:07:26,560
plus code base

00:07:23,440 --> 00:07:30,240
if it is purely c based code then

00:07:26,560 --> 00:07:33,599
it won't help i guess

00:07:30,240 --> 00:07:36,160
the next one is f no rtti this is also c

00:07:33,599 --> 00:07:39,360
plus plus specific

00:07:36,160 --> 00:07:41,599
f no rtti uh so let me explain this flag

00:07:39,360 --> 00:07:43,599
a little bit in c plus plus we have

00:07:41,599 --> 00:07:44,960
run time polymorphism where we can do

00:07:43,599 --> 00:07:47,360
dynamic cast

00:07:44,960 --> 00:07:48,080
to typecast from base class to derived

00:07:47,360 --> 00:07:51,440
class

00:07:48,080 --> 00:07:52,720
a specific type derived class in some

00:07:51,440 --> 00:07:56,000
cases it requires

00:07:52,720 --> 00:07:57,919
runtime in information like there are

00:07:56,000 --> 00:08:00,479
there is some runtime code emitted to

00:07:57,919 --> 00:08:03,840
get information about the type

00:08:00,479 --> 00:08:05,759
such that the dynamic cache will succeed

00:08:03,840 --> 00:08:07,199
uh so it says that the dynamic cast is

00:08:05,759 --> 00:08:10,479
precise

00:08:07,199 --> 00:08:13,599
so for that the compiler will um

00:08:10,479 --> 00:08:17,039
put some um some extra data

00:08:13,599 --> 00:08:19,840
into the code base now it'll

00:08:17,039 --> 00:08:20,560
the compiler does not know that where uh

00:08:19,840 --> 00:08:22,560
um

00:08:20,560 --> 00:08:24,319
like which one which how many times we

00:08:22,560 --> 00:08:27,039
are using dynamic cast on which type

00:08:24,319 --> 00:08:27,919
it will just add rtti for many of the

00:08:27,039 --> 00:08:30,639
classes

00:08:27,919 --> 00:08:31,360
as long as they have virtual functions

00:08:30,639 --> 00:08:34,000
so

00:08:31,360 --> 00:08:35,839
and that will just increase the code

00:08:34,000 --> 00:08:38,959
size so what we want to do is

00:08:35,839 --> 00:08:40,000
if we put fno rtti will save a lot of

00:08:38,959 --> 00:08:41,919
code size

00:08:40,000 --> 00:08:43,039
but some of the dynamic cost will not be

00:08:41,919 --> 00:08:45,519
legal then

00:08:43,039 --> 00:08:46,640
the compiler will give you error in that

00:08:45,519 --> 00:08:50,560
cases

00:08:46,640 --> 00:08:50,560
amount of work required in that case

00:08:50,880 --> 00:08:58,720
okay the seventh

00:08:54,000 --> 00:09:01,920
one is f inline limit in gcc and in llvm

00:08:58,720 --> 00:09:05,839
that same flag is called as dash

00:09:01,920 --> 00:09:08,160
mlvm inline threshold equals n

00:09:05,839 --> 00:09:10,720
so function inlining is again a very

00:09:08,160 --> 00:09:14,800
common optimization

00:09:10,720 --> 00:09:15,839
what it does is when we are calling a

00:09:14,800 --> 00:09:17,839
function

00:09:15,839 --> 00:09:19,440
from within another function so we have

00:09:17,839 --> 00:09:22,560
two functions one is the caller

00:09:19,440 --> 00:09:26,480
and the other one is calli the caller

00:09:22,560 --> 00:09:28,640
calls the colleen now

00:09:26,480 --> 00:09:31,279
it is possible for compiler to inline

00:09:28,640 --> 00:09:34,640
the callee into the caller

00:09:31,279 --> 00:09:38,000
that helps improve performance because

00:09:34,640 --> 00:09:40,240
the a branch is avoided and some of the

00:09:38,000 --> 00:09:41,519
functions set up and restored can be

00:09:40,240 --> 00:09:43,360
just deleted

00:09:41,519 --> 00:09:44,800
so there is a lot of improvement in

00:09:43,360 --> 00:09:46,480
performance inlinings

00:09:44,800 --> 00:09:48,959
is one of the most commonly used

00:09:46,480 --> 00:09:51,040
compiler optimizations

00:09:48,959 --> 00:09:52,959
now for co it can increase the code size

00:09:51,040 --> 00:09:54,080
quite a bit because when the function is

00:09:52,959 --> 00:09:56,640
inlined

00:09:54,080 --> 00:09:58,560
the existing function still the existing

00:09:56,640 --> 00:10:00,640
callee still remains because there can

00:09:58,560 --> 00:10:03,200
be other callers

00:10:00,640 --> 00:10:05,839
so in that case now you have duplicate

00:10:03,200 --> 00:10:07,440
code in many places

00:10:05,839 --> 00:10:09,120
it does improve performance but it hurts

00:10:07,440 --> 00:10:11,360
code size quite a bit

00:10:09,120 --> 00:10:12,240
what we can do is we can limit the

00:10:11,360 --> 00:10:15,040
number of

00:10:12,240 --> 00:10:17,279
the size of function that can be inlined

00:10:15,040 --> 00:10:19,680
and this is the flag

00:10:17,279 --> 00:10:21,760
meant to do that so if we do not want

00:10:19,680 --> 00:10:24,160
very large functions to be inline we can

00:10:21,760 --> 00:10:26,079
limit the code uh the number of

00:10:24,160 --> 00:10:29,760
instructions by changing

00:10:26,079 --> 00:10:31,040
the value n there you need to play a

00:10:29,760 --> 00:10:33,600
little bit with this

00:10:31,040 --> 00:10:34,320
uh flag to see where is the golden spot

00:10:33,600 --> 00:10:37,200
because

00:10:34,320 --> 00:10:39,040
if we put f inland limit to like zero or

00:10:37,200 --> 00:10:42,800
one like very small number

00:10:39,040 --> 00:10:45,120
it'll just stop inlining and it can

00:10:42,800 --> 00:10:46,640
affect the performance as well so these

00:10:45,120 --> 00:10:49,360
are the uh like there's some

00:10:46,640 --> 00:10:53,920
experimentation required

00:10:49,360 --> 00:10:56,800
and the last one is f no jump tables

00:10:53,920 --> 00:10:58,320
when we write switch statements in like

00:10:56,800 --> 00:11:00,079
most programming languages support

00:10:58,320 --> 00:11:03,279
switch statements

00:11:00,079 --> 00:11:06,320
switch statements can be emitted in the

00:11:03,279 --> 00:11:07,600
assembly as a

00:11:06,320 --> 00:11:09,600
in different ways there are many

00:11:07,600 --> 00:11:12,800
algorithms one of them is

00:11:09,600 --> 00:11:15,680
by by means of a jump table

00:11:12,800 --> 00:11:17,680
and the most trivial is a bunch of if

00:11:15,680 --> 00:11:18,640
else statements you can imagine a switch

00:11:17,680 --> 00:11:22,320
statement

00:11:18,640 --> 00:11:24,800
as a collection of if else statements

00:11:22,320 --> 00:11:25,360
but to make it more efficient there are

00:11:24,800 --> 00:11:28,399
like

00:11:25,360 --> 00:11:30,640
very like well-known algorithms and jump

00:11:28,399 --> 00:11:33,279
table is one of them

00:11:30,640 --> 00:11:34,800
now jump table in my experience

00:11:33,279 --> 00:11:37,680
increases code size

00:11:34,800 --> 00:11:38,560
it might seem counter intuitive in some

00:11:37,680 --> 00:11:41,440
cases

00:11:38,560 --> 00:11:42,560
but it does so if you add fno jump

00:11:41,440 --> 00:11:48,560
tables

00:11:42,560 --> 00:11:48,560
you might see reduction in code size

00:11:49,200 --> 00:11:51,519
okay

00:11:54,720 --> 00:12:00,560
there are some compiler flags which are

00:11:57,040 --> 00:12:00,560
only specific to gcc

00:12:01,600 --> 00:12:04,720
and these are some of them are

00:12:03,519 --> 00:12:07,680
architecture specific

00:12:04,720 --> 00:12:08,399
but some of them are um will help you

00:12:07,680 --> 00:12:11,200
tune

00:12:08,399 --> 00:12:12,160
quite a bit these are um not very well

00:12:11,200 --> 00:12:14,480
known so i

00:12:12,160 --> 00:12:15,600
i would try to discuss them separately

00:12:14,480 --> 00:12:19,440
the first one is

00:12:15,600 --> 00:12:22,959
dash m call prologues this one is

00:12:19,440 --> 00:12:26,000
only supported by avr instructions

00:12:22,959 --> 00:12:28,000
as far as i could find uh if it is

00:12:26,000 --> 00:12:30,000
supported for x86 i don't know

00:12:28,000 --> 00:12:31,680
uh it can be implemented quite easily in

00:12:30,000 --> 00:12:33,600
the compiler so if you're

00:12:31,680 --> 00:12:35,360
if you have compiler team please ask

00:12:33,600 --> 00:12:36,720
them to do that and that will save a lot

00:12:35,360 --> 00:12:40,079
of code size

00:12:36,720 --> 00:12:43,279
so what this flag does is if we see

00:12:40,079 --> 00:12:45,360
any function the call frame of any the

00:12:43,279 --> 00:12:48,480
layout of any function in assembly

00:12:45,360 --> 00:12:51,440
or in the machine code there are

00:12:48,480 --> 00:12:52,320
few instructions in the beginning which

00:12:51,440 --> 00:12:55,519
save

00:12:52,320 --> 00:12:56,240
the colleagues uh the quality saved

00:12:55,519 --> 00:12:58,079
registers

00:12:56,240 --> 00:12:59,440
okay some of the regis there is a

00:12:58,079 --> 00:13:02,160
calling convention

00:12:59,440 --> 00:13:04,160
in when we emit the binary and in the

00:13:02,160 --> 00:13:06,079
calling conventions there is a protocol

00:13:04,160 --> 00:13:07,680
that some of the registers are meant to

00:13:06,079 --> 00:13:09,519
be saved by kali

00:13:07,680 --> 00:13:10,959
and some of them registers are meant to

00:13:09,519 --> 00:13:12,880
be saved by caller

00:13:10,959 --> 00:13:14,320
so in the frame setup in the beginning

00:13:12,880 --> 00:13:15,920
of the function that is called the

00:13:14,320 --> 00:13:17,760
prolog

00:13:15,920 --> 00:13:20,880
the sequence of instructions are almost

00:13:17,760 --> 00:13:22,720
identical in many functions

00:13:20,880 --> 00:13:24,800
so instead of emitting the same

00:13:22,720 --> 00:13:26,320
duplicate code in over and over and

00:13:24,800 --> 00:13:29,279
every function

00:13:26,320 --> 00:13:29,680
we can have a standard function call and

00:13:29,279 --> 00:13:32,000
just

00:13:29,680 --> 00:13:33,120
call to that function it will do the

00:13:32,000 --> 00:13:36,560
frame setup for

00:13:33,120 --> 00:13:38,800
us like basically it will save some

00:13:36,560 --> 00:13:39,680
registers that the function intends to

00:13:38,800 --> 00:13:40,959
use

00:13:39,680 --> 00:13:43,519
throughout the life cycle of that

00:13:40,959 --> 00:13:46,079
function and at the end

00:13:43,519 --> 00:13:46,880
it restores those registers so that the

00:13:46,079 --> 00:13:51,120
caller

00:13:46,880 --> 00:13:51,839
can basically use them as they it was

00:13:51,120 --> 00:13:54,079
intended

00:13:51,839 --> 00:13:56,639
and this is the abi the contract between

00:13:54,079 --> 00:13:58,800
the caller and colleen

00:13:56,639 --> 00:14:01,040
so in the in the epilogue of the

00:13:58,800 --> 00:14:03,120
function it is the same situation we

00:14:01,040 --> 00:14:03,600
have a set of instructions which can be

00:14:03,120 --> 00:14:05,040
just

00:14:03,600 --> 00:14:07,360
which are duplicate across many

00:14:05,040 --> 00:14:09,760
functions by having

00:14:07,360 --> 00:14:11,600
just two functions we can get rid of all

00:14:09,760 --> 00:14:13,279
the frame setup and frame destroy of all

00:14:11,600 --> 00:14:16,480
the functions

00:14:13,279 --> 00:14:18,959
it does reduce code size but um

00:14:16,480 --> 00:14:19,920
not in a very small application uh the

00:14:18,959 --> 00:14:21,839
application should be

00:14:19,920 --> 00:14:23,440
like decently large enough like if you

00:14:21,839 --> 00:14:24,240
are suffering from code size this is a

00:14:23,440 --> 00:14:27,120
flag to go

00:14:24,240 --> 00:14:28,399
otherwise it is not worth it ah also it

00:14:27,120 --> 00:14:30,079
is not supported for all the

00:14:28,399 --> 00:14:31,519
architecture so you might want to check

00:14:30,079 --> 00:14:33,600
again

00:14:31,519 --> 00:14:34,959
the second flag i wanted to discuss in

00:14:33,600 --> 00:14:38,240
gcc is called

00:14:34,959 --> 00:14:40,240
dash m8

00:14:38,240 --> 00:14:44,399
what it does is it assumes that the

00:14:40,240 --> 00:14:46,399
integer has only eight bits it does not

00:14:44,399 --> 00:14:49,839
make a lot of sense in many cases

00:14:46,399 --> 00:14:52,480
but if you know that the integer

00:14:49,839 --> 00:14:53,519
values that are being used in an

00:14:52,480 --> 00:14:56,639
application

00:14:53,519 --> 00:14:57,199
will not uh get values larger than 8

00:14:56,639 --> 00:15:00,480
bits

00:14:57,199 --> 00:15:02,399
or you make careful uh you write code in

00:15:00,480 --> 00:15:05,839
a careful way it is possible

00:15:02,399 --> 00:15:06,240
so instead of like commonly used 32 bits

00:15:05,839 --> 00:15:08,240
you'll

00:15:06,240 --> 00:15:10,000
have only eight bits so that will save a

00:15:08,240 --> 00:15:12,800
lot of code size as well

00:15:10,000 --> 00:15:14,240
it is slightly risky i agree but uh if

00:15:12,800 --> 00:15:16,240
you are like

00:15:14,240 --> 00:15:18,480
like desperate for code size this is one

00:15:16,240 --> 00:15:18,480
of them

00:15:18,560 --> 00:15:22,079
the third one is m save restore so this

00:15:21,680 --> 00:15:24,800
flag

00:15:22,079 --> 00:15:25,920
m save restore is the same as m call pro

00:15:24,800 --> 00:15:29,040
prologues

00:15:25,920 --> 00:15:31,600
and but this m save restore is supported

00:15:29,040 --> 00:15:33,040
only for risk five architectures

00:15:31,600 --> 00:15:34,880
so the same thing it will have two

00:15:33,040 --> 00:15:36,959
functions in the beginning like

00:15:34,880 --> 00:15:38,240
uh if you call a function and the end it

00:15:36,959 --> 00:15:40,240
will of a function

00:15:38,240 --> 00:15:43,040
it will call another frame destroy

00:15:40,240 --> 00:15:45,759
function so it will save code size

00:15:43,040 --> 00:15:47,920
um i am still surprised that they have

00:15:45,759 --> 00:15:51,360
two different flags for similar things

00:15:47,920 --> 00:15:51,360
um i don't know why they did that

00:15:51,839 --> 00:15:57,360
the fourth one is called f reordered

00:15:54,399 --> 00:15:57,360
blocks algorithm

00:15:57,759 --> 00:16:02,959
so when the compiler is analyzing a

00:16:01,920 --> 00:16:06,560
function

00:16:02,959 --> 00:16:08,160
each a function can be assumed to be a

00:16:06,560 --> 00:16:10,079
set of basic blocks

00:16:08,160 --> 00:16:11,440
basic block is a set of function set of

00:16:10,079 --> 00:16:14,160
instructions

00:16:11,440 --> 00:16:15,759
which execute in sequence and at the end

00:16:14,160 --> 00:16:16,720
of the basic block there can be a branch

00:16:15,759 --> 00:16:19,199
like

00:16:16,720 --> 00:16:20,079
think of them as like if else branch but

00:16:19,199 --> 00:16:22,560
all the instructions

00:16:20,079 --> 00:16:24,800
in base in a basic block will execute in

00:16:22,560 --> 00:16:27,920
sequence

00:16:24,800 --> 00:16:28,959
now we can think of a function as a

00:16:27,920 --> 00:16:32,560
graph

00:16:28,959 --> 00:16:34,480
right and when the and

00:16:32,560 --> 00:16:36,240
most of the compiler optimizations work

00:16:34,480 --> 00:16:38,480
on the notion of a graph which is called

00:16:36,240 --> 00:16:41,600
a control flow graph

00:16:38,480 --> 00:16:43,600
when the functions are when we emit the

00:16:41,600 --> 00:16:46,480
assembly code

00:16:43,600 --> 00:16:48,399
each basic block has to be laid out in a

00:16:46,480 --> 00:16:51,120
specific sequence right

00:16:48,399 --> 00:16:53,120
and changing the sequence can have

00:16:51,120 --> 00:16:54,959
overhead of a code size

00:16:53,120 --> 00:16:56,560
like think of an if else statement like

00:16:54,959 --> 00:16:57,759
if you do not have an else statement

00:16:56,560 --> 00:17:00,959
there is a follow through

00:16:57,759 --> 00:17:04,319
right so there is a follow through

00:17:00,959 --> 00:17:05,760
so we do not have to have a both if and

00:17:04,319 --> 00:17:07,199
like two branches like if and else

00:17:05,760 --> 00:17:09,120
branch we can have only one branch and

00:17:07,199 --> 00:17:10,480
the default is the fall down uh the fall

00:17:09,120 --> 00:17:13,039
through

00:17:10,480 --> 00:17:14,079
so uh like if you generalize this idea

00:17:13,039 --> 00:17:16,640
like uh

00:17:14,079 --> 00:17:17,679
across a control flow graph reordering

00:17:16,640 --> 00:17:20,880
basic blocks can

00:17:17,679 --> 00:17:24,079
incur code size overhead

00:17:20,880 --> 00:17:25,039
so we can change the algorithm of basic

00:17:24,079 --> 00:17:28,880
block reordering

00:17:25,039 --> 00:17:31,200
and improve code size these are

00:17:28,880 --> 00:17:32,160
some of the parameters which can which

00:17:31,200 --> 00:17:34,880
are

00:17:32,160 --> 00:17:36,000
which affect the basic block reordering

00:17:34,880 --> 00:17:38,000
algorithm

00:17:36,000 --> 00:17:39,679
i don't want to discuss all of them but

00:17:38,000 --> 00:17:41,440
i'll just want to

00:17:39,679 --> 00:17:44,720
highlight some of them like the first

00:17:41,440 --> 00:17:49,760
one is called inline minimum speed up

00:17:44,720 --> 00:17:49,760
then maximum inline instructions sure

00:17:49,919 --> 00:17:55,200
okay there is a mistake here uh the

00:17:52,960 --> 00:17:56,640
reorder basic block algorithm uh there

00:17:55,200 --> 00:17:58,880
are only two algorithms like

00:17:56,640 --> 00:18:00,880
simple and there is one i forgot the

00:17:58,880 --> 00:18:02,880
name

00:18:00,880 --> 00:18:04,640
they changed the layout of the algot

00:18:02,880 --> 00:18:07,679
layout layout of the

00:18:04,640 --> 00:18:11,120
control flow graph the dash dash param

00:18:07,679 --> 00:18:12,000
is for inlining um i apologize for that

00:18:11,120 --> 00:18:15,120
this is a separate

00:18:12,000 --> 00:18:18,320
um bullet point

00:18:15,120 --> 00:18:20,640
so when we inline the function

00:18:18,320 --> 00:18:22,000
gcc allows us more control over the

00:18:20,640 --> 00:18:24,400
inlining

00:18:22,000 --> 00:18:25,120
and that inlining can be controlled by

00:18:24,400 --> 00:18:27,600
passing

00:18:25,120 --> 00:18:28,880
dash dash param followed by the flags

00:18:27,600 --> 00:18:31,120
which i have listed

00:18:28,880 --> 00:18:32,720
so the first one is inline minimum speed

00:18:31,120 --> 00:18:35,679
up

00:18:32,720 --> 00:18:36,960
what it does is we can specify if a

00:18:35,679 --> 00:18:40,320
percentage there like

00:18:36,960 --> 00:18:43,360
20 it or 70 something like that

00:18:40,320 --> 00:18:45,520
what it will do is uh it will change the

00:18:43,360 --> 00:18:47,120
static analysis algorithm within the

00:18:45,520 --> 00:18:50,000
compiler so it will

00:18:47,120 --> 00:18:50,960
uh it will affect the inlining algorithm

00:18:50,000 --> 00:18:52,960
itself

00:18:50,960 --> 00:18:54,559
the second one is maximum inline

00:18:52,960 --> 00:18:57,039
instruction single

00:18:54,559 --> 00:18:58,720
what that is like that 400 is the

00:18:57,039 --> 00:19:01,919
default value

00:18:58,720 --> 00:19:03,520
if you change uh it to like 300 you will

00:19:01,919 --> 00:19:06,400
get less inlining

00:19:03,520 --> 00:19:08,240
so less inlining means a reduction in

00:19:06,400 --> 00:19:11,840
the code size as well

00:19:08,240 --> 00:19:14,880
similarly if you see um maximum

00:19:11,840 --> 00:19:18,480
grow copy basic block instructions so

00:19:14,880 --> 00:19:19,200
it it'll not copy basic blocks which has

00:19:18,480 --> 00:19:22,400
more than

00:19:19,200 --> 00:19:24,799
eight instructions things like that

00:19:22,400 --> 00:19:25,760
so these are the flags to control the

00:19:24,799 --> 00:19:29,200
inlining of

00:19:25,760 --> 00:19:31,919
a inlining algorithm

00:19:29,200 --> 00:19:31,919
in gcc

00:19:34,960 --> 00:19:39,280
okay here i discussed some compiler

00:19:37,919 --> 00:19:42,640
optimizations

00:19:39,280 --> 00:19:45,120
which are not widely used but that

00:19:42,640 --> 00:19:46,000
they can also have impact on code size

00:19:45,120 --> 00:19:49,919
some of them are

00:19:46,000 --> 00:19:53,440
in gcc and some of them are in llbm

00:19:49,919 --> 00:19:56,080
the first one is f lto lto

00:19:53,440 --> 00:19:57,120
is the link time optimization so what it

00:19:56,080 --> 00:19:59,440
does is

00:19:57,120 --> 00:20:01,039
uh when we write cc plus plus code right

00:19:59,440 --> 00:20:04,480
we have

00:20:01,039 --> 00:20:05,760
one c dot c file that is treated as one

00:20:04,480 --> 00:20:09,760
translation unit

00:20:05,760 --> 00:20:13,840
including all their header files now

00:20:09,760 --> 00:20:16,559
uh in a project you have several

00:20:13,840 --> 00:20:16,960
source files so the compiler compiles

00:20:16,559 --> 00:20:19,760
each

00:20:16,960 --> 00:20:22,159
source file like dot c dot cpp file

00:20:19,760 --> 00:20:25,039
individually and then combine them

00:20:22,159 --> 00:20:26,240
during the link linkage process during

00:20:25,039 --> 00:20:29,679
the link time all these

00:20:26,240 --> 00:20:31,679
modules are combined to produce a binary

00:20:29,679 --> 00:20:33,679
the problem with this approach like this

00:20:31,679 --> 00:20:36,559
is a traditional approach the problem is

00:20:33,679 --> 00:20:38,559
we do not have visibility across modules

00:20:36,559 --> 00:20:40,960
or across translation units

00:20:38,559 --> 00:20:42,240
so we lose a lot of optimization

00:20:40,960 --> 00:20:45,600
opportunities

00:20:42,240 --> 00:20:50,240
code size as well as performance

00:20:45,600 --> 00:20:53,600
by having by telling the compiler to

00:20:50,240 --> 00:20:54,080
use link time optimization what it does

00:20:53,600 --> 00:20:56,720
is

00:20:54,080 --> 00:20:57,840
it allows visibility across translation

00:20:56,720 --> 00:21:01,600
units

00:20:57,840 --> 00:21:03,679
think of lto as imagine if you copy

00:21:01,600 --> 00:21:05,760
paste all your dot c file and include

00:21:03,679 --> 00:21:07,679
into one giant file

00:21:05,760 --> 00:21:09,200
and then run the compiler on one single

00:21:07,679 --> 00:21:11,200
file it will

00:21:09,200 --> 00:21:13,039
have all visibility across many

00:21:11,200 --> 00:21:14,960
different functions so

00:21:13,039 --> 00:21:17,679
most of the compiler optimization

00:21:14,960 --> 00:21:20,720
algorithm will benefit quite a bit

00:21:17,679 --> 00:21:21,280
it reduces quartz code size as well so

00:21:20,720 --> 00:21:25,360
this can

00:21:21,280 --> 00:21:28,640
be helpful the other flag is

00:21:25,360 --> 00:21:31,200
flto equals thin this is llvm specific

00:21:28,640 --> 00:21:34,559
compiler flag

00:21:31,200 --> 00:21:38,159
thin lto is a

00:21:34,559 --> 00:21:41,520
is slightly less efficient than lto but

00:21:38,159 --> 00:21:42,880
very close but it has faster compile

00:21:41,520 --> 00:21:44,320
time

00:21:42,880 --> 00:21:45,919
in the traditional link time

00:21:44,320 --> 00:21:49,440
optimization when we press

00:21:45,919 --> 00:21:50,720
flto when we copy all the object files

00:21:49,440 --> 00:21:53,120
into one

00:21:50,720 --> 00:21:54,720
it increases compile time by quite a bit

00:21:53,120 --> 00:21:55,840
because the memory footprint grows

00:21:54,720 --> 00:21:57,679
dramatically

00:21:55,840 --> 00:21:58,960
and all the algorithms most of the

00:21:57,679 --> 00:22:02,080
compiler algorithms

00:21:58,960 --> 00:22:04,320
which are uh sophisticated they are uh

00:22:02,080 --> 00:22:05,520
some of them are quadratic some of them

00:22:04,320 --> 00:22:07,919
have

00:22:05,520 --> 00:22:08,640
uh like exponential behavior but with a

00:22:07,919 --> 00:22:10,960
very small

00:22:08,640 --> 00:22:12,320
constant so like register allocation

00:22:10,960 --> 00:22:15,679
those things are

00:22:12,320 --> 00:22:19,039
have um like quadratic or more like

00:22:15,679 --> 00:22:22,320
more complex behavior so by putting

00:22:19,039 --> 00:22:23,120
all these uh modules together the memory

00:22:22,320 --> 00:22:25,679
footprint

00:22:23,120 --> 00:22:27,360
grows quite a bit and that slows down

00:22:25,679 --> 00:22:32,159
the compile time

00:22:27,360 --> 00:22:34,559
thin lto tries to fix this problem

00:22:32,159 --> 00:22:37,600
by only sharing information that are

00:22:34,559 --> 00:22:40,240
relevant for linkedin optimization

00:22:37,600 --> 00:22:42,480
for example register allocation doesn't

00:22:40,240 --> 00:22:44,720
need to know about other functions

00:22:42,480 --> 00:22:46,000
register allocation is purely localized

00:22:44,720 --> 00:22:47,679
within a function

00:22:46,000 --> 00:22:49,120
there are many other optimizations which

00:22:47,679 --> 00:22:52,320
are very specific to a

00:22:49,120 --> 00:22:55,840
function so we don't need a link time

00:22:52,320 --> 00:22:59,039
information there on the other hand um

00:22:55,840 --> 00:23:01,120
like optimizations like inlining cross

00:22:59,039 --> 00:23:04,080
module d virtualization

00:23:01,120 --> 00:23:06,320
and a few more they are they are

00:23:04,080 --> 00:23:08,640
relevant across translation units

00:23:06,320 --> 00:23:10,320
so only those optimizations need to be

00:23:08,640 --> 00:23:12,000
uh need some information across

00:23:10,320 --> 00:23:16,240
translation

00:23:12,000 --> 00:23:19,600
now in thin lto there is um

00:23:16,240 --> 00:23:22,159
you can find the resources online but it

00:23:19,600 --> 00:23:25,039
reduces compile time dramatically but it

00:23:22,159 --> 00:23:26,720
still gives you very close

00:23:25,039 --> 00:23:28,960
performance numbers which are very close

00:23:26,720 --> 00:23:32,960
to the link time optimization

00:23:28,960 --> 00:23:34,000
and similarly it is the same for code

00:23:32,960 --> 00:23:36,240
size as well

00:23:34,000 --> 00:23:38,080
so link time thin lto will give you

00:23:36,240 --> 00:23:40,480
reduction in code size

00:23:38,080 --> 00:23:41,919
uh but it doesn't hurt the compile time

00:23:40,480 --> 00:23:46,720
as bad as the

00:23:41,919 --> 00:23:49,200
the full f lto okay

00:23:46,720 --> 00:23:50,640
the third one is identical code folding

00:23:49,200 --> 00:23:55,039
this is one of the

00:23:50,640 --> 00:23:58,159
aggressive code size optimizations

00:23:55,039 --> 00:23:59,200
it is quite common for many functions to

00:23:58,159 --> 00:24:03,279
have

00:23:59,200 --> 00:24:06,960
a shared piece of code

00:24:03,279 --> 00:24:09,440
especially in c plus plus where even

00:24:06,960 --> 00:24:10,240
engineers are careful enough templates

00:24:09,440 --> 00:24:12,320
will cause

00:24:10,240 --> 00:24:14,720
code duplication across many translation

00:24:12,320 --> 00:24:14,720
units

00:24:14,880 --> 00:24:18,880
so compilers can help there they can

00:24:17,520 --> 00:24:20,640
they analyze functions

00:24:18,880 --> 00:24:22,000
and look for functions which are

00:24:20,640 --> 00:24:24,720
identical

00:24:22,000 --> 00:24:26,240
and they can be merged so we can just

00:24:24,720 --> 00:24:29,440
de-duplicate those functions

00:24:26,240 --> 00:24:32,880
and fix the branches fix the calls

00:24:29,440 --> 00:24:34,640
and basically get

00:24:32,880 --> 00:24:36,960
reduction like huge reduction in code

00:24:34,640 --> 00:24:40,960
size in gcc it is called

00:24:36,960 --> 00:24:41,760
fipa equals icf icf means identical code

00:24:40,960 --> 00:24:46,480
folding

00:24:41,760 --> 00:24:49,279
in llvm it is called f merge functions

00:24:46,480 --> 00:24:51,039
recently there was no there is an

00:24:49,279 --> 00:24:53,440
optimization called much similar

00:24:51,039 --> 00:24:53,440
functions

00:24:53,919 --> 00:24:57,600
what it does is it doesn't look for

00:24:55,679 --> 00:24:59,360
complete ident identical

00:24:57,600 --> 00:25:01,840
structure it if the functions have

00:24:59,360 --> 00:25:01,840
slightly

00:25:02,159 --> 00:25:06,400
if the function has slight differences

00:25:04,799 --> 00:25:08,240
we can still merge them

00:25:06,400 --> 00:25:09,440
and by putting appropriate if else

00:25:08,240 --> 00:25:12,960
statements

00:25:09,440 --> 00:25:14,000
um this this optimization is used in

00:25:12,960 --> 00:25:15,840
some of the

00:25:14,000 --> 00:25:17,279
well-known industrial compilers but it

00:25:15,840 --> 00:25:20,559
is not in

00:25:17,279 --> 00:25:23,120
uh supported in trunk llpm

00:25:20,559 --> 00:25:24,159
i have a patch uh so the link i have

00:25:23,120 --> 00:25:27,200
pasted there

00:25:24,159 --> 00:25:28,159
it enables mud similar functions in the

00:25:27,200 --> 00:25:31,440
thin lto

00:25:28,159 --> 00:25:33,679
so you get uh code duplication

00:25:31,440 --> 00:25:35,360
across translation units so it can save

00:25:33,679 --> 00:25:39,760
quite a bit of code size

00:25:35,360 --> 00:25:43,200
if you're curious i encourage you to try

00:25:39,760 --> 00:25:46,559
the other optimization is called

00:25:43,200 --> 00:25:50,080
it in llvm it is called gvn hoist

00:25:46,559 --> 00:25:52,240
so imagine a if else statement

00:25:50,080 --> 00:25:53,919
where the else branch and the then

00:25:52,240 --> 00:25:56,960
branch both the branches have

00:25:53,919 --> 00:25:58,720
similar code a similar instructions what

00:25:56,960 --> 00:25:59,679
we can do is we can hoist those common

00:25:58,720 --> 00:26:03,120
instructions

00:25:59,679 --> 00:26:05,600
on the parent and save code size it

00:26:03,120 --> 00:26:08,000
helps in performance as well it reduces

00:26:05,600 --> 00:26:10,080
register pressure as well it is pretty

00:26:08,000 --> 00:26:11,919
i implemented this optimization a few

00:26:10,080 --> 00:26:14,880
years ago in llvm

00:26:11,919 --> 00:26:15,360
it is not enabled by default so uh but

00:26:14,880 --> 00:26:18,480
uh

00:26:15,360 --> 00:26:21,360
if you use this flag dab dash mlvm

00:26:18,480 --> 00:26:23,120
that's just enabled as gb and hoist you

00:26:21,360 --> 00:26:24,960
can use this flag um

00:26:23,120 --> 00:26:26,799
you can get advantage of gb and hoist

00:26:24,960 --> 00:26:28,720
code size optimization

00:26:26,799 --> 00:26:30,320
it is not a very aggressive uh

00:26:28,720 --> 00:26:31,440
optimization like others but it will

00:26:30,320 --> 00:26:33,039
give you still

00:26:31,440 --> 00:26:35,039
it may give one or two percent code size

00:26:33,039 --> 00:26:37,520
reduction

00:26:35,039 --> 00:26:39,120
similarly the another optimization is

00:26:37,520 --> 00:26:41,120
called gvn sync

00:26:39,120 --> 00:26:43,120
it is the opposite of gvn hoist it

00:26:41,120 --> 00:26:46,240
basically syncs common instructions

00:26:43,120 --> 00:26:49,600
in the common um

00:26:46,240 --> 00:26:51,200
post dominator instruction so basically

00:26:49,600 --> 00:26:54,000
if

00:26:51,200 --> 00:26:55,120
if the then and else branch has an

00:26:54,000 --> 00:26:57,120
identical instruction

00:26:55,120 --> 00:26:58,960
it you can sync them into the common

00:26:57,120 --> 00:27:02,240
successor

00:26:58,960 --> 00:27:05,440
of those two basic blocks it also

00:27:02,240 --> 00:27:09,120
gives slight uh reduction in code size

00:27:05,440 --> 00:27:09,120
so you can try that

00:27:10,080 --> 00:27:15,760
the uh the sixth one is machine outliner

00:27:12,880 --> 00:27:19,120
we can enable machine outliner

00:27:15,760 --> 00:27:20,159
what it does is it does what is opposite

00:27:19,120 --> 00:27:23,200
of inlining

00:27:20,159 --> 00:27:25,360
that's why it is called outlining

00:27:23,200 --> 00:27:26,799
in a function we can see if there are

00:27:25,360 --> 00:27:29,840
few instructions

00:27:26,799 --> 00:27:32,720
which are commonly found across

00:27:29,840 --> 00:27:34,480
many functions we can just outline those

00:27:32,720 --> 00:27:35,840
set of instructions into a separate

00:27:34,480 --> 00:27:39,440
function call

00:27:35,840 --> 00:27:41,279
and save code size so if we do this

00:27:39,440 --> 00:27:43,039
only for one function it will not reduce

00:27:41,279 --> 00:27:46,000
code size because it will actually add

00:27:43,039 --> 00:27:49,679
some overhead of branches across

00:27:46,000 --> 00:27:52,720
as a call now if we know that

00:27:49,679 --> 00:27:54,240
as if a certain set of instructions are

00:27:52,720 --> 00:27:56,720
very common

00:27:54,240 --> 00:27:58,640
so if we outline from one function and

00:27:56,720 --> 00:28:00,000
it is quite likely that the same set of

00:27:58,640 --> 00:28:01,120
instructions are there in another

00:28:00,000 --> 00:28:04,080
function

00:28:01,120 --> 00:28:06,000
and hence will have some commonality of

00:28:04,080 --> 00:28:08,320
code

00:28:06,000 --> 00:28:11,039
that we will reduce the code size this

00:28:08,320 --> 00:28:14,080
is also enabled in llvm

00:28:11,039 --> 00:28:15,919
you can i think it is not enabled by

00:28:14,080 --> 00:28:16,240
default so you have to add that flag

00:28:15,919 --> 00:28:18,640
dash

00:28:16,240 --> 00:28:20,640
enable dash machine outliner to get

00:28:18,640 --> 00:28:24,000
advantage of code size it gives

00:28:20,640 --> 00:28:26,559
quite a bit of code size reduction

00:28:24,000 --> 00:28:27,840
however i think it is only supported for

00:28:26,559 --> 00:28:31,520
arm 64.

00:28:27,840 --> 00:28:34,240
it might be supported for risk 5

00:28:31,520 --> 00:28:35,679
but i don't know because the work was

00:28:34,240 --> 00:28:38,640
going on very recently

00:28:35,679 --> 00:28:40,880
so you have to check it out the last one

00:28:38,640 --> 00:28:42,240
is hot cold splitting

00:28:40,880 --> 00:28:44,240
this is basically a performance

00:28:42,240 --> 00:28:45,840
optimization but it can give code size

00:28:44,240 --> 00:28:48,399
reduction as well

00:28:45,840 --> 00:28:50,880
it is very similar to outliner but this

00:28:48,399 --> 00:28:52,880
is supported for all architectures

00:28:50,880 --> 00:28:55,520
because this optimization is enabled in

00:28:52,880 --> 00:28:58,480
the middle end of the compiler

00:28:55,520 --> 00:29:00,480
i implemented this only for uh mostly

00:28:58,480 --> 00:29:02,240
keeping in mind the performance

00:29:00,480 --> 00:29:04,240
but imagine if the same sequence of

00:29:02,240 --> 00:29:06,159
instructions are found in many functions

00:29:04,240 --> 00:29:07,120
then we'll have code deduplication as

00:29:06,159 --> 00:29:09,440
well

00:29:07,120 --> 00:29:10,880
hardcore splitting and merge functions

00:29:09,440 --> 00:29:14,240
from the previous slide

00:29:10,880 --> 00:29:16,080
they if we if you

00:29:14,240 --> 00:29:20,000
work with them in the right way you can

00:29:16,080 --> 00:29:20,000
see a good code size reduction

00:29:23,279 --> 00:29:29,039
all right c plus library optimization

00:29:27,039 --> 00:29:30,640
there are many c plus plus libraries

00:29:29,039 --> 00:29:32,720
which are widely used especially the

00:29:30,640 --> 00:29:33,840
standard c plus plus library libc plus

00:29:32,720 --> 00:29:36,880
plus or lip standard c

00:29:33,840 --> 00:29:39,039
plus plus they have a lot of templated

00:29:36,880 --> 00:29:39,679
code and we use them quite aggressively

00:29:39,039 --> 00:29:42,720
across

00:29:39,679 --> 00:29:46,159
c plus code bases they

00:29:42,720 --> 00:29:48,640
cause lot of code duplication and

00:29:46,159 --> 00:29:49,679
um the problem with code duplication it

00:29:48,640 --> 00:29:52,960
hurts code size

00:29:49,679 --> 00:29:54,799
quite a bit so if we have custom lip c

00:29:52,960 --> 00:29:56,720
plus plus like you can actually compile

00:29:54,799 --> 00:29:58,000
lip c plus plus yourself and put them in

00:29:56,720 --> 00:29:59,919
the code base

00:29:58,000 --> 00:30:01,600
that can they can also they can improve

00:29:59,919 --> 00:30:04,399
code size actually

00:30:01,600 --> 00:30:06,559
you can have uh other c plus plus

00:30:04,399 --> 00:30:08,080
libraries like boost and i can they have

00:30:06,559 --> 00:30:09,679
they suffer from similar problems

00:30:08,080 --> 00:30:11,679
because they are all templated header

00:30:09,679 --> 00:30:14,399
only libraries

00:30:11,679 --> 00:30:15,200
what happens is when we use a c plus

00:30:14,399 --> 00:30:18,399
plus function

00:30:15,200 --> 00:30:21,440
uh uh in in in our code base

00:30:18,399 --> 00:30:23,279
and the compiler inlines them so you get

00:30:21,440 --> 00:30:24,880
lot of code duplication as well as

00:30:23,279 --> 00:30:26,480
increase in the code size because of

00:30:24,880 --> 00:30:29,039
inline

00:30:26,480 --> 00:30:30,799
a nice way to get rid of this

00:30:29,039 --> 00:30:33,600
disadvantage is by

00:30:30,799 --> 00:30:33,919
explicit template instantiations so when

00:30:33,600 --> 00:30:36,799
we

00:30:33,919 --> 00:30:38,960
instantiate a template explicitly then

00:30:36,799 --> 00:30:42,320
that is the only copy that will be used

00:30:38,960 --> 00:30:44,320
and we can just put

00:30:42,320 --> 00:30:46,559
actually good no inline on all those

00:30:44,320 --> 00:30:48,480
functions that way

00:30:46,559 --> 00:30:50,480
the inlining will not happen and during

00:30:48,480 --> 00:30:51,520
the link time only one definition which

00:30:50,480 --> 00:30:54,559
was the explicit

00:30:51,520 --> 00:30:56,720
instantiation will be used

00:30:54,559 --> 00:30:57,600
it might be slightly tricky to implement

00:30:56,720 --> 00:30:59,279
uh do

00:30:57,600 --> 00:31:00,799
and there is some maintenance overhead

00:30:59,279 --> 00:31:02,399
as well because then you have to

00:31:00,799 --> 00:31:04,640
maintain your own c plus standard

00:31:02,399 --> 00:31:07,039
library but

00:31:04,640 --> 00:31:08,720
it can be worth the code size it gives

00:31:07,039 --> 00:31:11,279
like decent code size

00:31:08,720 --> 00:31:11,279
reduction

00:31:13,279 --> 00:31:19,840
okay source code optimizations

00:31:21,039 --> 00:31:27,519
yeah okay yeah

00:31:25,279 --> 00:31:27,519
so

00:31:28,720 --> 00:31:36,320
when we uh have a code base which is um

00:31:32,240 --> 00:31:38,880
there for like a decent period of time

00:31:36,320 --> 00:31:39,679
developers keep putting code in there or

00:31:38,880 --> 00:31:43,279
like

00:31:39,679 --> 00:31:44,000
and the new developers would come they

00:31:43,279 --> 00:31:45,919
would add their

00:31:44,000 --> 00:31:47,600
new features based on market style you

00:31:45,919 --> 00:31:49,200
can have new features

00:31:47,600 --> 00:31:51,039
now when we keep adding features the

00:31:49,200 --> 00:31:54,080
source code starts to

00:31:51,039 --> 00:31:55,840
bloat right it is hard to find people

00:31:54,080 --> 00:31:57,919
who care about deleting the code base

00:31:55,840 --> 00:32:00,880
but it is very easy to find people who

00:31:57,919 --> 00:32:02,640
want to add code base so and the problem

00:32:00,880 --> 00:32:03,039
reflect in the code base itself you will

00:32:02,640 --> 00:32:06,399
see

00:32:03,039 --> 00:32:08,720
lot of like dead code basically

00:32:06,399 --> 00:32:08,720
we can

00:32:10,320 --> 00:32:16,559
in c plus it is quite a habit for many

00:32:13,679 --> 00:32:18,399
developers to write code in header file

00:32:16,559 --> 00:32:20,080
like they'll write entire definition in

00:32:18,399 --> 00:32:20,960
the header file even if it is not a

00:32:20,080 --> 00:32:24,080
template

00:32:20,960 --> 00:32:25,840
templated code base so when we put a

00:32:24,080 --> 00:32:28,000
function definition in the header file

00:32:25,840 --> 00:32:30,559
it just gets copied over and over

00:32:28,000 --> 00:32:31,600
to all the translation unit and in a big

00:32:30,559 --> 00:32:33,760
code base

00:32:31,600 --> 00:32:35,760
imagine if you have some widely used

00:32:33,760 --> 00:32:38,880
header files it can just

00:32:35,760 --> 00:32:42,159
have insane amount of um

00:32:38,880 --> 00:32:44,559
code size bloat there so moving the

00:32:42,159 --> 00:32:46,799
function definitions from header file to

00:32:44,559 --> 00:32:50,399
like dot cpp the source file

00:32:46,799 --> 00:32:53,519
can help um code size

00:32:50,399 --> 00:32:56,399
it will reduce the code size quite a bit

00:32:53,519 --> 00:32:58,320
some of the things which we do are not

00:32:56,399 --> 00:32:59,919
even intentional it is just the

00:32:58,320 --> 00:33:02,080
abstraction penalty of c

00:32:59,919 --> 00:33:03,600
plus like imagine if you have a class

00:33:02,080 --> 00:33:04,559
where you have not declared the

00:33:03,600 --> 00:33:06,559
constructor

00:33:04,559 --> 00:33:08,480
or like defined the constructor the

00:33:06,559 --> 00:33:10,159
compiler defines them for you

00:33:08,480 --> 00:33:12,000
yeah and it will just copy the

00:33:10,159 --> 00:33:13,840
construction everywhere

00:33:12,000 --> 00:33:15,519
same goes for destructor operator

00:33:13,840 --> 00:33:18,000
overloading

00:33:15,519 --> 00:33:18,880
and if you have like template functions

00:33:18,000 --> 00:33:21,519
inside the class

00:33:18,880 --> 00:33:22,640
same thing happens now with like there

00:33:21,519 --> 00:33:24,240
is a

00:33:22,640 --> 00:33:26,080
new c plus plus standards you start

00:33:24,240 --> 00:33:27,279
having more rules like rule of three

00:33:26,080 --> 00:33:29,279
rule of seven

00:33:27,279 --> 00:33:31,120
so if you define a couple of them the

00:33:29,279 --> 00:33:33,120
compiler will generate code for other

00:33:31,120 --> 00:33:35,279
constructors like move constructor or

00:33:33,120 --> 00:33:38,799
something or destructor

00:33:35,279 --> 00:33:41,279
now and they cause code bloat and unlike

00:33:38,799 --> 00:33:44,240
without even you knowing it if you go

00:33:41,279 --> 00:33:47,039
and investigate you have to actually

00:33:44,240 --> 00:33:48,159
introspect quite a bit to find out these

00:33:47,039 --> 00:33:51,279
um

00:33:48,159 --> 00:33:53,440
code bloat a nice way to do is to

00:33:51,279 --> 00:33:55,039
declare the function uh the constructor

00:33:53,440 --> 00:33:57,760
in your class

00:33:55,039 --> 00:33:59,600
definition and define it in a cpp file

00:33:57,760 --> 00:34:00,240
even if it is a default definition you

00:33:59,600 --> 00:34:02,559
want

00:34:00,240 --> 00:34:04,960
you can define it in the cpp file and it

00:34:02,559 --> 00:34:07,760
will save your code size

00:34:04,960 --> 00:34:08,480
surprisingly it gives a decent code size

00:34:07,760 --> 00:34:12,960
gains

00:34:08,480 --> 00:34:12,960
and i've used this very recently

00:34:19,280 --> 00:34:24,879
yeah one um other source code

00:34:22,879 --> 00:34:26,480
optimization is to use a cheaper data

00:34:24,879 --> 00:34:30,800
structure

00:34:26,480 --> 00:34:33,280
this is a um uh i'm putting up a

00:34:30,800 --> 00:34:34,720
very counter intuitive example here just

00:34:33,280 --> 00:34:36,639
to show uh

00:34:34,720 --> 00:34:38,480
uh how surprising things can be when we

00:34:36,639 --> 00:34:41,520
are using um

00:34:38,480 --> 00:34:43,919
like c plus plus so

00:34:41,520 --> 00:34:45,679
we use standard vector standard deck

00:34:43,919 --> 00:34:46,399
unordered map and ordered set quite a

00:34:45,679 --> 00:34:48,639
bit like

00:34:46,399 --> 00:34:49,760
people rarely use standard list these

00:34:48,639 --> 00:34:52,879
days

00:34:49,760 --> 00:34:55,760
but the code size of code size footprint

00:34:52,879 --> 00:34:58,560
of vector is larger compared to std list

00:34:55,760 --> 00:34:59,599
and why do we use vector for performance

00:34:58,560 --> 00:35:02,480
but if performance

00:34:59,599 --> 00:35:04,000
is not the most desired thing we don't

00:35:02,480 --> 00:35:07,680
have to use hdd vector

00:35:04,000 --> 00:35:09,520
right so um choosing a data structure

00:35:07,680 --> 00:35:12,640
can have huge impact in code size

00:35:09,520 --> 00:35:16,079
as well and these things are

00:35:12,640 --> 00:35:18,240
not very widely known for because we

00:35:16,079 --> 00:35:19,280
assume all the time that vector is all

00:35:18,240 --> 00:35:21,599
the time better than

00:35:19,280 --> 00:35:24,400
standard list and similarly goes for

00:35:21,599 --> 00:35:28,000
unordered map versus standard map

00:35:24,400 --> 00:35:30,240
and i have some numbers here

00:35:28,000 --> 00:35:31,280
so as you can see it's a very small test

00:35:30,240 --> 00:35:34,160
program

00:35:31,280 --> 00:35:35,839
on the top we have standard map versus

00:35:34,160 --> 00:35:37,599
standard unordered map

00:35:35,839 --> 00:35:39,359
and if you see it's a very small file

00:35:37,599 --> 00:35:40,880
you just have declared a map

00:35:39,359 --> 00:35:43,119
and i'm assigning a variable and

00:35:40,880 --> 00:35:44,640
returning just to not

00:35:43,119 --> 00:35:46,160
prevent compiler from optimizing

00:35:44,640 --> 00:35:49,200
everything here

00:35:46,160 --> 00:35:49,680
and i have optimized for code size like

00:35:49,200 --> 00:35:52,320
clang

00:35:49,680 --> 00:35:54,320
dash oz oz is optimized for code size

00:35:52,320 --> 00:35:56,320
aggressively

00:35:54,320 --> 00:35:58,480
with a standard map the code size is

00:35:56,320 --> 00:36:00,720
approximately 14 kilobytes

00:35:58,480 --> 00:36:02,800
but with standard unordered map it is

00:36:00,720 --> 00:36:05,680
approximately 15 kilobytes

00:36:02,800 --> 00:36:07,359
so i'm not saying that uh you should

00:36:05,680 --> 00:36:08,320
start using standard map all the time

00:36:07,359 --> 00:36:11,280
for code size

00:36:08,320 --> 00:36:12,400
this is one specific example just to

00:36:11,280 --> 00:36:15,119
give an intuition

00:36:12,400 --> 00:36:16,320
that what appears may not always be um

00:36:15,119 --> 00:36:18,079
the case so you have to

00:36:16,320 --> 00:36:19,680
unless you investigate deeply into the

00:36:18,079 --> 00:36:23,520
code base uh

00:36:19,680 --> 00:36:26,880
it is um it is not wise to just

00:36:23,520 --> 00:36:29,359
um rely on popular wisdom like sometimes

00:36:26,880 --> 00:36:30,640
based on the demands of the code base

00:36:29,359 --> 00:36:32,880
and workload

00:36:30,640 --> 00:36:35,520
i think uh things require different

00:36:32,880 --> 00:36:37,839
software engineering methodologies

00:36:35,520 --> 00:36:40,000
similarly goes for standard list 13

00:36:37,839 --> 00:36:43,520
kilobyte versus 14.3 kilobyte

00:36:40,000 --> 00:36:47,119
on vector so it can be quite surprising

00:36:43,520 --> 00:36:47,119
um by looking at these things

00:36:47,920 --> 00:36:51,920
all right um getting in inside into the

00:36:51,280 --> 00:36:57,200
code base

00:36:51,920 --> 00:36:57,200
using compiler techniques

00:36:57,520 --> 00:37:01,440
in a code base where if you have lot of

00:37:00,240 --> 00:37:04,560
code bloat because

00:37:01,440 --> 00:37:07,920
several engineers are working on on

00:37:04,560 --> 00:37:09,920
that application over a period of time

00:37:07,920 --> 00:37:11,920
you have a lot of iterations of features

00:37:09,920 --> 00:37:13,280
the old features die out but the codes

00:37:11,920 --> 00:37:16,240
remains there

00:37:13,280 --> 00:37:18,480
there will be a lot of dead code um

00:37:16,240 --> 00:37:20,839
consciously or unconsciously

00:37:18,480 --> 00:37:22,000
because of the software development

00:37:20,839 --> 00:37:24,960
process

00:37:22,000 --> 00:37:25,359
what we can do is we can find out which

00:37:24,960 --> 00:37:27,280
code

00:37:25,359 --> 00:37:28,960
which functions are getting used in

00:37:27,280 --> 00:37:32,160
production or not

00:37:28,960 --> 00:37:34,839
what we can do is there is a there are

00:37:32,160 --> 00:37:37,280
compiler flags like f instrument

00:37:34,839 --> 00:37:40,320
functions we can use these flags

00:37:37,280 --> 00:37:43,040
to collect data about which functions

00:37:40,320 --> 00:37:46,400
are getting executed

00:37:43,040 --> 00:37:48,800
imagine so what these flags do is it

00:37:46,400 --> 00:37:50,720
allow you to add a function call at the

00:37:48,800 --> 00:37:52,480
beginning of every function

00:37:50,720 --> 00:37:55,520
like this like f patchable function

00:37:52,480 --> 00:37:58,160
entry and f instrument functions

00:37:55,520 --> 00:37:58,640
and you can define a function which is

00:37:58,160 --> 00:38:01,040
just

00:37:58,640 --> 00:38:02,240
imagine that function as is just very

00:38:01,040 --> 00:38:04,079
simple counter

00:38:02,240 --> 00:38:05,839
so if any function is called you you

00:38:04,079 --> 00:38:07,440
find out that this function was called

00:38:05,839 --> 00:38:10,880
and if you collect data across a large

00:38:07,440 --> 00:38:10,880
code uh user base

00:38:10,960 --> 00:38:15,119
or uh or a large number of test cases

00:38:13,599 --> 00:38:16,640
you will get an idea which functions are

00:38:15,119 --> 00:38:18,480
frequently used or which functions are

00:38:16,640 --> 00:38:20,560
not used at all

00:38:18,480 --> 00:38:22,320
so it it doesn't mean that if a function

00:38:20,560 --> 00:38:23,280
was never called it will never be called

00:38:22,320 --> 00:38:25,680
in future

00:38:23,280 --> 00:38:26,320
let's say error handling code you don't

00:38:25,680 --> 00:38:28,480
want

00:38:26,320 --> 00:38:30,079
to delete your error handling code but

00:38:28,480 --> 00:38:31,520
you still want to know which functions

00:38:30,079 --> 00:38:32,720
have the least probability of getting

00:38:31,520 --> 00:38:35,839
called

00:38:32,720 --> 00:38:39,280
what happens is and then we can

00:38:35,839 --> 00:38:42,720
deploy engineers to find out

00:38:39,280 --> 00:38:45,040
that are they actually dead what

00:38:42,720 --> 00:38:46,079
using these methodologies we can

00:38:45,040 --> 00:38:48,400
increase the probability

00:38:46,079 --> 00:38:49,760
of finding functions or debt functions

00:38:48,400 --> 00:38:52,079
quite a bit so instead of

00:38:49,760 --> 00:38:53,119
in introspecting a million functions you

00:38:52,079 --> 00:38:55,760
are only

00:38:53,119 --> 00:38:57,200
investigating 1000 or 10 000 functions

00:38:55,760 --> 00:38:59,599
so that has a huge

00:38:57,200 --> 00:39:00,720
saving on engineering cost and still get

00:38:59,599 --> 00:39:03,839
a most of

00:39:00,720 --> 00:39:03,839
code size reductions

00:39:04,079 --> 00:39:07,359
i have recently implemented similar

00:39:06,160 --> 00:39:08,960
things in llvm

00:39:07,359 --> 00:39:11,280
it is called function entry

00:39:08,960 --> 00:39:13,520
instrumentation it is very cheap it is

00:39:11,280 --> 00:39:16,400
lock free you can deploy in production

00:39:13,520 --> 00:39:17,359
it only collects data when a function is

00:39:16,400 --> 00:39:19,599
called

00:39:17,359 --> 00:39:20,560
uh the fun the performance overhead will

00:39:19,599 --> 00:39:23,200
be negligible

00:39:20,560 --> 00:39:23,920
and there are facility to disable are

00:39:23,200 --> 00:39:27,440
enabled

00:39:23,920 --> 00:39:29,359
for specific functions so

00:39:27,440 --> 00:39:30,560
if you are using llvm in your code base

00:39:29,359 --> 00:39:32,560
you can try it out

00:39:30,560 --> 00:39:35,440
i hope it will give you useful data to

00:39:32,560 --> 00:39:35,440
reduce code size

00:39:38,400 --> 00:39:42,400
so i think this like i have already

00:39:40,720 --> 00:39:44,240
discussed things here like getting

00:39:42,400 --> 00:39:46,800
insights into codebase

00:39:44,240 --> 00:39:48,720
um one more thing we can do is once we

00:39:46,800 --> 00:39:51,280
find that less used part of

00:39:48,720 --> 00:39:52,320
the code base like imagine we have a

00:39:51,280 --> 00:39:54,000
feature which very

00:39:52,320 --> 00:39:55,920
few people are using but we still want

00:39:54,000 --> 00:39:58,640
to keep them

00:39:55,920 --> 00:40:00,160
what we can do is we can collect set of

00:39:58,640 --> 00:40:02,240
features which are less used

00:40:00,160 --> 00:40:04,800
and put them in a separate shared

00:40:02,240 --> 00:40:04,800
library

00:40:05,119 --> 00:40:08,480
what that will do is it will not reduce

00:40:06,720 --> 00:40:10,160
the code size of the program but it will

00:40:08,480 --> 00:40:11,920
reduce the working set

00:40:10,160 --> 00:40:13,680
so when the program loads it doesn't

00:40:11,920 --> 00:40:15,200
need to load the shared library it will

00:40:13,680 --> 00:40:17,440
only load them

00:40:15,200 --> 00:40:19,680
for specific cases when those features

00:40:17,440 --> 00:40:25,200
are exercised

00:40:19,680 --> 00:40:29,760
so this helps reduce the launch time

00:40:25,200 --> 00:40:32,640
another very risky uh

00:40:29,760 --> 00:40:33,040
approach is to do binary compression

00:40:32,640 --> 00:40:35,680
like

00:40:33,040 --> 00:40:37,520
imagine uh there is in a code base you

00:40:35,680 --> 00:40:40,880
can keep some of the functions like

00:40:37,520 --> 00:40:42,800
main function or few functions as it is

00:40:40,880 --> 00:40:44,160
and just compress the entire binary

00:40:42,800 --> 00:40:47,440
using a

00:40:44,160 --> 00:40:50,560
well-known library like zlib or lib zlg

00:40:47,440 --> 00:40:52,400
i found this one recently

00:40:50,560 --> 00:40:54,000
and in the main pro main function when

00:40:52,400 --> 00:40:56,960
the program is getting loaded

00:40:54,000 --> 00:40:57,760
you uncompress the binary and then load

00:40:56,960 --> 00:41:01,520
the program

00:40:57,760 --> 00:41:02,319
uh as as on demand so this will reduce

00:41:01,520 --> 00:41:04,960
code size

00:41:02,319 --> 00:41:06,720
like quite dramatically but um again

00:41:04,960 --> 00:41:07,839
there's a maintenance overhead debugging

00:41:06,720 --> 00:41:10,560
is a nightmare

00:41:07,839 --> 00:41:11,440
because if you collect some um if the

00:41:10,560 --> 00:41:14,000
program crashes

00:41:11,440 --> 00:41:14,640
in in deployment then um yeah there will

00:41:14,000 --> 00:41:16,800
be

00:41:14,640 --> 00:41:19,040
tricky engineering things that you have

00:41:16,800 --> 00:41:20,960
to do but if you're like so desperate

00:41:19,040 --> 00:41:22,800
this is also one of the approaches it

00:41:20,960 --> 00:41:25,839
can reduce code size by like

00:41:22,800 --> 00:41:28,880
20 30 it is a big one

00:41:25,839 --> 00:41:32,480
yeah but it is risky and it can uh

00:41:28,880 --> 00:41:32,480
reduce the performance also little bit

00:41:32,839 --> 00:41:39,760
um that's all for now like uh i have

00:41:36,640 --> 00:41:43,359
some references here and now i will take

00:41:39,760 --> 00:41:45,599
questions let me see there are questions

00:41:43,359 --> 00:41:48,640
here

00:41:45,599 --> 00:41:50,319
yeah so uh first question is what are

00:41:48,640 --> 00:41:53,119
the security implications of fno

00:41:50,319 --> 00:41:53,119
function sections

00:41:53,359 --> 00:42:00,560
if the i'm not aware of

00:41:56,560 --> 00:42:00,560
um any security implications

00:42:00,720 --> 00:42:03,760
i'm not a security expert guys so but i

00:42:03,200 --> 00:42:06,960
imagine

00:42:03,760 --> 00:42:10,000
the compiler does not do anything um

00:42:06,960 --> 00:42:11,440
special to um help or reduce the

00:42:10,000 --> 00:42:14,720
security

00:42:11,440 --> 00:42:15,599
um if if compiler has inserted a section

00:42:14,720 --> 00:42:18,640
for

00:42:15,599 --> 00:42:19,280
a specific function i don't know like if

00:42:18,640 --> 00:42:21,359
there are

00:42:19,280 --> 00:42:23,680
tricks like hacking tricks i'm i'm not

00:42:21,359 --> 00:42:25,760
in that domain at all so i'm sorry

00:42:23,680 --> 00:42:28,640
but as far as i can say they should have

00:42:25,760 --> 00:42:28,640
similar behavior

00:42:28,960 --> 00:42:34,640
the second question is is there a good

00:42:31,440 --> 00:42:37,839
good process to get to the

00:42:34,640 --> 00:42:38,319
is there a good process to get to the

00:42:37,839 --> 00:42:41,520
right

00:42:38,319 --> 00:42:45,200
inline limit it seems it would require

00:42:41,520 --> 00:42:47,839
a lot of trials to get it right um

00:42:45,200 --> 00:42:49,119
yeah it requires trial and error but um

00:42:47,839 --> 00:42:51,359
you don't have to iterate

00:42:49,119 --> 00:42:52,480
uh like n times you can do binary uh

00:42:51,359 --> 00:42:54,240
search kind of thing

00:42:52,480 --> 00:42:55,760
like let's say the inline threshold is

00:42:54,240 --> 00:42:59,520
uh 300 and

00:42:55,760 --> 00:43:01,760
start with like 200 and see if that

00:42:59,520 --> 00:43:03,599
basically uh just simple divide and

00:43:01,760 --> 00:43:06,079
conquer algorithm will get you

00:43:03,599 --> 00:43:06,720
to the right number in like in a in a

00:43:06,079 --> 00:43:09,280
matter of

00:43:06,720 --> 00:43:10,400
days or two depending on the the build

00:43:09,280 --> 00:43:12,560
time like if your binary

00:43:10,400 --> 00:43:14,640
takes like two days to build then i'm

00:43:12,560 --> 00:43:17,440
sorry but

00:43:14,640 --> 00:43:19,200
it it should not algorithmically it

00:43:17,440 --> 00:43:20,640
would conserve converge very quickly

00:43:19,200 --> 00:43:26,079
like four or five iterations you will

00:43:20,640 --> 00:43:27,599
get to the very sweet spot

00:43:26,079 --> 00:43:30,400
idea on percentage of code size

00:43:27,599 --> 00:43:30,400
reduction achieved

00:43:30,960 --> 00:43:34,240
achieved in standard library for c plus

00:43:32,880 --> 00:43:36,000
plus i am thinking

00:43:34,240 --> 00:43:37,680
how worthwhile it is to maintain an

00:43:36,000 --> 00:43:39,200
optimized copy of it

00:43:37,680 --> 00:43:41,200
depends if you are using a lot of c plus

00:43:39,200 --> 00:43:43,200
plus code base like if it is entirely c

00:43:41,200 --> 00:43:45,280
plus plus it could go five to ten

00:43:43,200 --> 00:43:47,440
percent if you have a lot of

00:43:45,280 --> 00:43:49,440
ninja c plus programmers who write all

00:43:47,440 --> 00:43:50,319
templates all the time it can go higher

00:43:49,440 --> 00:43:52,720
also

00:43:50,319 --> 00:43:54,319
so um yeah it depends on the code base

00:43:52,720 --> 00:43:59,200
but

00:43:54,319 --> 00:43:59,200
i can assure five percent quite easily

00:44:00,400 --> 00:44:05,119
f ipa the next question is fip icf is

00:44:03,440 --> 00:44:08,319
enabled by default at o2 and

00:44:05,119 --> 00:44:09,040
os is that right i wonder what of those

00:44:08,319 --> 00:44:11,359
flags

00:44:09,040 --> 00:44:14,079
need to be added to o0 if they are not

00:44:11,359 --> 00:44:16,160
so at o0 you don't want to enable any

00:44:14,079 --> 00:44:17,280
compiler flag only very minimum number

00:44:16,160 --> 00:44:20,640
of compiler flags are

00:44:17,280 --> 00:44:22,880
added at o0 o0 has worse performance

00:44:20,640 --> 00:44:24,480
verse code size it is not meant for

00:44:22,880 --> 00:44:25,680
deployment it is meant for debugging

00:44:24,480 --> 00:44:28,720
purposes and

00:44:25,680 --> 00:44:31,040
faster build time things like that and c

00:44:28,720 --> 00:44:32,560
plus plus standard compliance like if

00:44:31,040 --> 00:44:34,400
yeah like

00:44:32,560 --> 00:44:36,079
some functions has to be inlined if the

00:44:34,400 --> 00:44:37,839
language demands it so they will be

00:44:36,079 --> 00:44:41,040
inlined at o0 also

00:44:37,839 --> 00:44:41,440
some like move semantics will work at o0

00:44:41,040 --> 00:44:43,040
also

00:44:41,440 --> 00:44:45,119
you don't need compiler magic to work

00:44:43,040 --> 00:44:46,319
there but it is not like the move

00:44:45,119 --> 00:44:48,640
semantics

00:44:46,319 --> 00:44:49,839
was never there your compilers have been

00:44:48,640 --> 00:44:51,680
doing a lot of

00:44:49,839 --> 00:44:52,960
not all of them but most of more

00:44:51,680 --> 00:44:55,520
semantics

00:44:52,960 --> 00:44:57,599
before it came into the language itself

00:44:55,520 --> 00:45:01,040
compiler knows how to do those things

00:44:57,599 --> 00:45:04,000
so at o0 um yeah these things are not

00:45:01,040 --> 00:45:05,920
very meaningful at o0

00:45:04,000 --> 00:45:08,319
have mostly used pgo for performance

00:45:05,920 --> 00:45:09,839
optimi improvement but i wonder if

00:45:08,319 --> 00:45:11,760
based on runtime information the

00:45:09,839 --> 00:45:14,079
compiler can reduce size i have never

00:45:11,760 --> 00:45:15,839
done that experiment yes i encourage you

00:45:14,079 --> 00:45:18,319
to try it out it will help you a lot if

00:45:15,839 --> 00:45:20,079
you have a larger code base and where

00:45:18,319 --> 00:45:21,760
like so many developers are have been

00:45:20,079 --> 00:45:24,720
writing code forever you will find

00:45:21,760 --> 00:45:25,839
insane amount of dead code um yeah i can

00:45:24,720 --> 00:45:29,200
uh

00:45:25,839 --> 00:45:32,400
i would encourage you to try that

00:45:29,200 --> 00:45:35,839
instrumentation firefox gives a

00:45:32,400 --> 00:45:35,839
sorry yeah

00:45:35,920 --> 00:45:41,119
can unused functions be removed even

00:45:38,079 --> 00:45:43,839
without f no function sections

00:45:41,119 --> 00:45:44,400
yes linker can do that not for all of

00:45:43,839 --> 00:45:46,800
them but

00:45:44,400 --> 00:45:48,640
for many of them uh if you have indirect

00:45:46,800 --> 00:45:50,800
function call they will not be removed

00:45:48,640 --> 00:45:51,920
uh like depending on the visibility of

00:45:50,800 --> 00:45:55,760
the function like

00:45:51,920 --> 00:45:58,880
that is what it is uh if you try flto

00:45:55,760 --> 00:46:00,720
at flt or so many um functions are

00:45:58,880 --> 00:46:02,160
internalized so their visibility is

00:46:00,720 --> 00:46:04,800
changed from external to

00:46:02,160 --> 00:46:05,200
uh like local to a link unit and then

00:46:04,800 --> 00:46:06,880
the

00:46:05,200 --> 00:46:08,560
linker can remove many of those trade

00:46:06,880 --> 00:46:12,000
functions so you

00:46:08,560 --> 00:46:14,640
don't uh i'm sure with function stations

00:46:12,000 --> 00:46:17,839
more of them can be removed but even

00:46:14,640 --> 00:46:17,839
without it can be removed

00:46:18,319 --> 00:46:22,880
let's see what is the other question

00:46:20,319 --> 00:46:26,079
firefox gives a warning about

00:46:22,880 --> 00:46:27,839
the libglz website yeah i'm not

00:46:26,079 --> 00:46:29,200
recommending that website i just found

00:46:27,839 --> 00:46:31,599
it online they have

00:46:29,200 --> 00:46:32,240
uh i think they they don't have very low

00:46:31,599 --> 00:46:35,040
footprint

00:46:32,240 --> 00:46:36,640
uh during the decoding so i mean it's

00:46:35,040 --> 00:46:38,800
not my product i don't know

00:46:36,640 --> 00:46:40,560
any of those people working on them

00:46:38,800 --> 00:46:42,640
please try it at your own risk

00:46:40,560 --> 00:46:45,280
but i just found it online and i was

00:46:42,640 --> 00:46:45,280
looking at them

00:46:46,640 --> 00:46:53,440
i'm loving this thank you very much

00:46:50,000 --> 00:46:56,720
um okay i have few minutes

00:46:53,440 --> 00:46:58,240
i can share few more things like if you

00:46:56,720 --> 00:47:00,160
want to find more about this

00:46:58,240 --> 00:47:01,280
i would encourage you to read the manual

00:47:00,160 --> 00:47:04,480
pages um

00:47:01,280 --> 00:47:05,040
this is a very nice thing to do like if

00:47:04,480 --> 00:47:08,640
you see

00:47:05,040 --> 00:47:11,839
a man gcc or on llbm also has a

00:47:08,640 --> 00:47:12,800
nice documentation gcc has a very

00:47:11,839 --> 00:47:15,760
elaborate

00:47:12,800 --> 00:47:17,200
documentation um like simple just

00:47:15,760 --> 00:47:19,599
command control f for

00:47:17,200 --> 00:47:20,800
size you will find just search for size

00:47:19,599 --> 00:47:23,280
and you will find so many

00:47:20,800 --> 00:47:24,319
very useful information and it is a good

00:47:23,280 --> 00:47:27,599
read you will get

00:47:24,319 --> 00:47:29,440
a lot of insight into how compiler

00:47:27,599 --> 00:47:31,359
works like how what are the things that

00:47:29,440 --> 00:47:35,839
we can do there

00:47:31,359 --> 00:47:35,839
um you can

00:47:36,839 --> 00:47:40,480
yeah there might be some other

00:47:39,119 --> 00:47:43,280
optimizations i

00:47:40,480 --> 00:47:44,800
uh i would have missed here it is quite

00:47:43,280 --> 00:47:47,119
possible

00:47:44,800 --> 00:47:48,000
you can try it out or you can ask on the

00:47:47,119 --> 00:47:50,720
mailing list

00:47:48,000 --> 00:47:51,760
there are compiler developers they and

00:47:50,720 --> 00:47:55,359
like me

00:47:51,760 --> 00:47:58,000
they also like to help everyone so

00:47:55,359 --> 00:47:58,800
if you ask on mailing list or um their

00:47:58,000 --> 00:48:01,839
chat thread

00:47:58,800 --> 00:48:05,040
both llpm gcc have very

00:48:01,839 --> 00:48:07,599
um um like a lot of

00:48:05,040 --> 00:48:09,280
developers they are active there so you

00:48:07,599 --> 00:48:09,839
can you can ask any question there if

00:48:09,280 --> 00:48:13,200
you want

00:48:09,839 --> 00:48:17,200
you need help on code size um they'll

00:48:13,200 --> 00:48:19,200
they'll be very happy to help you there

00:48:17,200 --> 00:48:20,960
uh it is open source you can read uh

00:48:19,200 --> 00:48:22,319
read through their mailing list also i'm

00:48:20,960 --> 00:48:24,400
sure there are many

00:48:22,319 --> 00:48:25,440
deep discussions about courses going on

00:48:24,400 --> 00:48:27,200
there

00:48:25,440 --> 00:48:29,599
for a long period of time so you know

00:48:27,200 --> 00:48:32,800
there might be some useful things to

00:48:29,599 --> 00:48:35,440
to read in that cases also

00:48:32,800 --> 00:48:37,280
um for me i i don't know maybe you can

00:48:35,440 --> 00:48:40,079
reach out to me on twitter or something

00:48:37,280 --> 00:48:43,440
i can help there as well

00:48:40,079 --> 00:48:49,839
um if there are no more questions then

00:48:43,440 --> 00:48:49,839
let's see

00:48:55,680 --> 00:48:59,200
yeah there is one more question i can

00:48:57,200 --> 00:49:00,880
understand that optimizing for

00:48:59,200 --> 00:49:02,960
better code size can affect performance

00:49:00,880 --> 00:49:05,760
but can it break the functionality

00:49:02,960 --> 00:49:06,640
no compilers are not meant to break for

00:49:05,760 --> 00:49:08,160
functionality

00:49:06,640 --> 00:49:10,400
if there's a bug in the compiler which

00:49:08,160 --> 00:49:12,400
is very rare it can happen but

00:49:10,400 --> 00:49:14,559
the semantically it should not happen at

00:49:12,400 --> 00:49:16,800
all you should get the same

00:49:14,559 --> 00:49:19,119
behavior because that is required by the

00:49:16,800 --> 00:49:20,319
standard both cnc plus plus it is called

00:49:19,119 --> 00:49:22,559
as if rule

00:49:20,319 --> 00:49:23,440
as a fruit means the behavior must be

00:49:22,559 --> 00:49:26,640
the same

00:49:23,440 --> 00:49:28,880
in a very crude way but you get the idea

00:49:26,640 --> 00:49:31,760
thank you very much everyone i totally

00:49:28,880 --> 00:49:34,800
enjoyed this session and i want to thank

00:49:31,760 --> 00:49:38,160
the linux this open source summit

00:49:34,800 --> 00:49:45,119
folks to giving me opportunity

00:49:38,160 --> 00:49:47,200
thank you

00:49:45,119 --> 00:49:47,200

YouTube URL: https://www.youtube.com/watch?v=6IuDWfuMEno


