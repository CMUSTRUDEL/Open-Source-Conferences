Title: API Gateway & Ingress Management: Simplify Cluster Management Across Any Platform or Environment
Publication date: 2020-09-03
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	API Gateway & Ingress Management: Simplify Cluster Management Across Any Platform or Environment - Marco Palladino, Kong
Captions: 
	00:00:03,919 --> 00:00:08,720
hello everybody

00:00:05,359 --> 00:00:12,080
um today we're going to be talking about

00:00:08,720 --> 00:00:14,639
api gateway and ingress management

00:00:12,080 --> 00:00:17,119
my name is marco palladino i'm the cto

00:00:14,639 --> 00:00:20,160
and co-founder of cog

00:00:17,119 --> 00:00:20,880
and this presentation is divided into

00:00:20,160 --> 00:00:23,920
different

00:00:20,880 --> 00:00:25,359
um two different sections one you know

00:00:23,920 --> 00:00:27,119
we're going to be talking about ingress

00:00:25,359 --> 00:00:27,599
understanding what kong is and how we

00:00:27,119 --> 00:00:30,240
can use

00:00:27,599 --> 00:00:31,039
kong on kubernetes and then i'm going to

00:00:30,240 --> 00:00:32,399
be

00:00:31,039 --> 00:00:35,680
sharing my screen and pull up the

00:00:32,399 --> 00:00:37,520
terminal to practice a live demo

00:00:35,680 --> 00:00:40,320
so we're going to be seeing it running

00:00:37,520 --> 00:00:44,000
running it in action

00:00:40,320 --> 00:00:45,440
you see um just if you take a step back

00:00:44,000 --> 00:00:47,200
you know we're we're entering a new

00:00:45,440 --> 00:00:48,239
world for software and this is a new

00:00:47,200 --> 00:00:50,320
world that's been

00:00:48,239 --> 00:00:52,320
i've been you know uh has been with us

00:00:50,320 --> 00:00:55,600
for a few for alpha decade

00:00:52,320 --> 00:00:58,640
now you know in 2013 2014 with docker in

00:00:55,600 --> 00:01:00,800
2013 and kubernetes in 2014

00:00:58,640 --> 00:01:02,640
really we are building applications in a

00:01:00,800 --> 00:01:06,960
new way and of course

00:01:02,640 --> 00:01:06,960
as we um

00:01:07,200 --> 00:01:13,520
and of course as we are transitioning to

00:01:11,040 --> 00:01:14,960
um you know to to this new world we're

00:01:13,520 --> 00:01:17,360
distributing our software

00:01:14,960 --> 00:01:19,200
and we're adding more and more services

00:01:17,360 --> 00:01:20,880
uh we're decoupling our monoliths in

00:01:19,200 --> 00:01:23,520
more and more services

00:01:20,880 --> 00:01:24,720
uh that are going to be um you know

00:01:23,520 --> 00:01:26,080
connected to each other and we're going

00:01:24,720 --> 00:01:27,520
to be deploying across across

00:01:26,080 --> 00:01:30,000
the world across different regions in

00:01:27,520 --> 00:01:31,360
order to be able to uh to run modern

00:01:30,000 --> 00:01:33,920
micro service applications

00:01:31,360 --> 00:01:35,600
and as we do that of course we gain

00:01:33,920 --> 00:01:36,720
something we're able to decouple our

00:01:35,600 --> 00:01:39,439
software

00:01:36,720 --> 00:01:41,040
we're able to decentralize not just how

00:01:39,439 --> 00:01:42,880
we run our applications

00:01:41,040 --> 00:01:44,240
but we're also able to decentralize how

00:01:42,880 --> 00:01:45,280
the teams are building these

00:01:44,240 --> 00:01:47,119
applications

00:01:45,280 --> 00:01:48,320
but as we do that and as we increase the

00:01:47,119 --> 00:01:51,200
number of services

00:01:48,320 --> 00:01:52,960
we're also going to be reducing the

00:01:51,200 --> 00:01:55,360
simplicity of running everything

00:01:52,960 --> 00:01:57,119
in in production um of course the

00:01:55,360 --> 00:01:58,479
monolith had many problems but one thing

00:01:57,119 --> 00:02:00,079
the mallet had

00:01:58,479 --> 00:02:01,920
it was simple you know it's very simple

00:02:00,079 --> 00:02:03,840
to conceptually think about it it's one

00:02:01,920 --> 00:02:04,320
thing one thing only we deploy it and it

00:02:03,840 --> 00:02:06,079
runs

00:02:04,320 --> 00:02:08,959
then of course it's hard to scale it's

00:02:06,079 --> 00:02:11,920
how to deploy it's hard to contribute

00:02:08,959 --> 00:02:12,959
but it's simple and as we decouple our

00:02:11,920 --> 00:02:15,040
services

00:02:12,959 --> 00:02:16,959
of course that simplicity goes away but

00:02:15,040 --> 00:02:18,959
we gain something else it's dynamic we

00:02:16,959 --> 00:02:20,400
can deploy much faster we can increase

00:02:18,959 --> 00:02:23,920
and improve the business

00:02:20,400 --> 00:02:25,520
at a much rapid pace running all of this

00:02:23,920 --> 00:02:27,200
would be very problematic if we didn't

00:02:25,520 --> 00:02:28,720
have a platform like kubernetes and so

00:02:27,200 --> 00:02:32,239
kubernetes comes to the rescue

00:02:28,720 --> 00:02:32,959
we can use kubernetes to deploy our new

00:02:32,239 --> 00:02:36,400
services

00:02:32,959 --> 00:02:37,200
our new applications in a very in a very

00:02:36,400 --> 00:02:39,920
easy way

00:02:37,200 --> 00:02:41,840
by leveraging the abstraction layers

00:02:39,920 --> 00:02:44,879
that kubernetes provide us

00:02:41,840 --> 00:02:47,360
now kubernetes abstracts away

00:02:44,879 --> 00:02:49,200
our infrastructure but all the workloads

00:02:47,360 --> 00:02:50,879
that kubernetes is scheduling in the

00:02:49,200 --> 00:02:53,680
underlying virtual machines

00:02:50,879 --> 00:02:54,640
do not live under a rock we still need

00:02:53,680 --> 00:02:58,080
to be able

00:02:54,640 --> 00:03:00,319
to access them from from the outside

00:02:58,080 --> 00:03:02,159
and in order to enable this use case

00:03:00,319 --> 00:03:05,200
kubernetes provides us

00:03:02,159 --> 00:03:07,040
with a few different resources

00:03:05,200 --> 00:03:09,200
that we could be using in order to make

00:03:07,040 --> 00:03:09,920
this happen so there's three different

00:03:09,200 --> 00:03:11,760
ways

00:03:09,920 --> 00:03:13,440
actually there is a fourth way which is

00:03:11,760 --> 00:03:14,400
cube proxy and i'm not going to cover

00:03:13,440 --> 00:03:16,000
that today

00:03:14,400 --> 00:03:19,360
but primarily there is three different

00:03:16,000 --> 00:03:22,159
ways that we can access our services

00:03:19,360 --> 00:03:22,800
from from the outside using kubernetes

00:03:22,159 --> 00:03:24,720
we can

00:03:22,800 --> 00:03:26,799
configure not port we can configure a

00:03:24,720 --> 00:03:28,720
load balancer we can configure

00:03:26,799 --> 00:03:30,080
an ingress so let's go through all of

00:03:28,720 --> 00:03:33,440
them and

00:03:30,080 --> 00:03:36,400
deep dive into why ingress seems to be

00:03:33,440 --> 00:03:36,720
the best way to allow external traffic

00:03:36,400 --> 00:03:38,879
to

00:03:36,720 --> 00:03:41,040
enter our kubernetes cluster so let's

00:03:38,879 --> 00:03:44,840
start with noteport nodeport

00:03:41,040 --> 00:03:48,319
is perhaps the most primitive way for

00:03:44,840 --> 00:03:51,599
exposing a service in kubernetes

00:03:48,319 --> 00:03:54,000
so that external clients can consume it

00:03:51,599 --> 00:03:54,720
it's a very simple concept with nodeport

00:03:54,000 --> 00:03:58,319
we're going to

00:03:54,720 --> 00:03:59,680
be opening up a port that's bound to the

00:03:58,319 --> 00:04:02,480
non-ap address

00:03:59,680 --> 00:04:03,680
for every service that we want to expose

00:04:02,480 --> 00:04:05,280
that means if we have 10 different

00:04:03,680 --> 00:04:08,799
services we're going to be having

00:04:05,280 --> 00:04:10,799
10 different ports for each one of them

00:04:08,799 --> 00:04:13,200
you know it's quite primitive because of

00:04:10,799 --> 00:04:15,200
course it's bound to the node ap address

00:04:13,200 --> 00:04:17,199
it's one service per port and even the

00:04:15,200 --> 00:04:20,880
port range that we can use it's quite

00:04:17,199 --> 00:04:24,400
limited so if we want in production

00:04:20,880 --> 00:04:26,160
to allow clients to use to consume our

00:04:24,400 --> 00:04:27,680
services within our kubernetes cluster

00:04:26,160 --> 00:04:30,880
perhaps it's not the best

00:04:27,680 --> 00:04:33,440
the best way to do it there is going to

00:04:30,880 --> 00:04:36,000
be another entity called load balancer

00:04:33,440 --> 00:04:37,199
which allows us to expose a service via

00:04:36,000 --> 00:04:38,560
effectively a load balancer

00:04:37,199 --> 00:04:40,560
functionality

00:04:38,560 --> 00:04:41,600
that usually the cloud bankers implement

00:04:40,560 --> 00:04:42,639
with their own load balancer

00:04:41,600 --> 00:04:45,919
implementations

00:04:42,639 --> 00:04:46,560
so we have our services uh we want to be

00:04:45,919 --> 00:04:49,600
able

00:04:46,560 --> 00:04:51,120
to provision a load balancer and this

00:04:49,600 --> 00:04:53,759
will effectively create

00:04:51,120 --> 00:04:54,800
one load balancer per service the

00:04:53,759 --> 00:04:56,080
problem with this

00:04:54,800 --> 00:04:57,919
is that the cloud vendors are going to

00:04:56,080 --> 00:04:59,840
be charging us for

00:04:57,919 --> 00:05:02,639
every load balancer that we're starting

00:04:59,840 --> 00:05:07,120
and if we do have many load balancers

00:05:02,639 --> 00:05:08,960
this can get very expensive very quickly

00:05:07,120 --> 00:05:10,800
therefore we're going to be looking at

00:05:08,960 --> 00:05:12,400
the ingress resource so this is an

00:05:10,800 --> 00:05:14,800
independent resource

00:05:12,400 --> 00:05:16,479
so this is not attached to our services

00:05:14,800 --> 00:05:19,520
but it's independent

00:05:16,479 --> 00:05:19,919
um whereas node port and load balancer

00:05:19,520 --> 00:05:22,800
were

00:05:19,919 --> 00:05:24,080
attached to the to the service object to

00:05:22,800 --> 00:05:26,080
the service resource

00:05:24,080 --> 00:05:28,479
this is the independent therefore it

00:05:26,080 --> 00:05:30,000
makes this resource quite decoupled and

00:05:28,479 --> 00:05:32,320
isolated from the services it's like

00:05:30,000 --> 00:05:34,479
this additional abstraction layer

00:05:32,320 --> 00:05:35,680
that we are placing on top of our

00:05:34,479 --> 00:05:39,280
services

00:05:35,680 --> 00:05:42,000
in this layer this ingress

00:05:39,280 --> 00:05:43,039
allows us to put all the the root the

00:05:42,000 --> 00:05:45,520
routing rules

00:05:43,039 --> 00:05:47,120
for all our services in one place so we

00:05:45,520 --> 00:05:47,840
don't have them decoupled across each

00:05:47,120 --> 00:05:49,759
service

00:05:47,840 --> 00:05:50,960
but they're in a separate place all

00:05:49,759 --> 00:05:53,280
together

00:05:50,960 --> 00:05:54,240
the advantage of ingress is you know

00:05:53,280 --> 00:05:55,440
ingers it's a spec

00:05:54,240 --> 00:05:56,720
and there's going to be different

00:05:55,440 --> 00:05:58,240
implementations that are going to be

00:05:56,720 --> 00:05:59,360
running on top of the ingress ingress

00:05:58,240 --> 00:06:01,440
abstracts away

00:05:59,360 --> 00:06:02,560
the basic routing functionality but it

00:06:01,440 --> 00:06:05,120
still allows

00:06:02,560 --> 00:06:06,479
for ingress implementations to be able

00:06:05,120 --> 00:06:09,759
to provide

00:06:06,479 --> 00:06:10,479
higher value features uh on top of this

00:06:09,759 --> 00:06:12,479
layer

00:06:10,479 --> 00:06:13,919
that we can then apply uh and we're

00:06:12,479 --> 00:06:17,039
gonna see this in the case of con we can

00:06:13,919 --> 00:06:20,080
we can then apply on top of our services

00:06:17,039 --> 00:06:21,520
now the ingress um you know

00:06:20,080 --> 00:06:24,160
doesn't change the ap address it's the

00:06:21,520 --> 00:06:26,319
same ip address uh we can

00:06:24,160 --> 00:06:27,759
expose our ingress to pretty much

00:06:26,319 --> 00:06:31,360
consume any service

00:06:27,759 --> 00:06:33,280
we have inside of our cluster

00:06:31,360 --> 00:06:34,960
uh like i said the ingress it's quite

00:06:33,280 --> 00:06:36,880
comes in quite handy

00:06:34,960 --> 00:06:38,720
because it allows us to centralize all

00:06:36,880 --> 00:06:41,039
the routing rules in one place

00:06:38,720 --> 00:06:42,880
therefore we can decide from that one

00:06:41,039 --> 00:06:43,120
place what services we want to expose

00:06:42,880 --> 00:06:45,600
and

00:06:43,120 --> 00:06:47,440
how we want to go govern them by using

00:06:45,600 --> 00:06:51,360
the ingress implementations that we want

00:06:47,440 --> 00:06:54,479
to deploy as well as in the case of cong

00:06:51,360 --> 00:06:55,919
this allows us to apply uh some of those

00:06:54,479 --> 00:06:58,479
higher level features in a

00:06:55,919 --> 00:07:00,160
quite quite easy way so for example uh

00:06:58,479 --> 00:07:00,960
by using a con ingresscon it's an open

00:07:00,160 --> 00:07:02,479
source and

00:07:00,960 --> 00:07:04,880
it's an open source api gateway as a

00:07:02,479 --> 00:07:08,080
matter of fact uh it's one of the most

00:07:04,880 --> 00:07:10,160
widely adopted open source api gateway

00:07:08,080 --> 00:07:11,360
uh in the community uh you can find it

00:07:10,160 --> 00:07:12,800
on github of course

00:07:11,360 --> 00:07:14,400
and we can apply authentication

00:07:12,800 --> 00:07:16,160
authorization rules we can apply rate

00:07:14,400 --> 00:07:19,039
limiting rules tracing metrics

00:07:16,160 --> 00:07:20,240
observability and and the interesting

00:07:19,039 --> 00:07:21,840
thing about kong

00:07:20,240 --> 00:07:23,199
in particular you know different ingress

00:07:21,840 --> 00:07:23,919
implementations have different feature

00:07:23,199 --> 00:07:27,840
sets

00:07:23,919 --> 00:07:31,120
kung is an l4 and l7

00:07:27,840 --> 00:07:34,479
ingress which means that we can

00:07:31,120 --> 00:07:38,080
use cong not just as your traditional

00:07:34,479 --> 00:07:39,759
not just as an ingress used as an api

00:07:38,080 --> 00:07:41,599
gateway on top of our kubernetes

00:07:39,759 --> 00:07:44,160
clusters but we can also use it

00:07:41,599 --> 00:07:46,000
as a lightweight router to enable

00:07:44,160 --> 00:07:47,840
cross-cluster communication across

00:07:46,000 --> 00:07:49,599
multiple kubernetes clusters

00:07:47,840 --> 00:07:51,199
so if we have some you know services

00:07:49,599 --> 00:07:52,479
running in one cluster some services

00:07:51,199 --> 00:07:55,919
running in another cluster

00:07:52,479 --> 00:07:58,080
and those services may not be apis http

00:07:55,919 --> 00:08:00,639
apis or jrpc apis

00:07:58,080 --> 00:08:02,319
but maybe you know for example databases

00:08:00,639 --> 00:08:02,800
or redis connections whatever data is

00:08:02,319 --> 00:08:06,160
really

00:08:02,800 --> 00:08:08,080
any tcp connection kong can route and

00:08:06,160 --> 00:08:09,599
enter within the cluster it also

00:08:08,080 --> 00:08:11,599
supports k native

00:08:09,599 --> 00:08:13,280
if that's something that you're adopting

00:08:11,599 --> 00:08:15,520
so cong makes no assumption

00:08:13,280 --> 00:08:16,400
effectively as to what the underlying

00:08:15,520 --> 00:08:18,800
service is

00:08:16,400 --> 00:08:19,440
it can be an api that we want to expose

00:08:18,800 --> 00:08:21,280
to our

00:08:19,440 --> 00:08:23,280
external developers or internal teams in

00:08:21,280 --> 00:08:25,039
the organization it can also be a

00:08:23,280 --> 00:08:26,240
service that we want to consume from

00:08:25,039 --> 00:08:28,160
another service

00:08:26,240 --> 00:08:29,360
in another kubernetes cluster so it's

00:08:28,160 --> 00:08:32,080
quite flexible

00:08:29,360 --> 00:08:35,039
in the way it it it provisions this

00:08:32,080 --> 00:08:35,039
ingress functionality

00:08:36,719 --> 00:08:42,719
it's open source you can deploy kong

00:08:40,000 --> 00:08:44,959
on from github um you know it has been

00:08:42,719 --> 00:08:48,399
running kong was created in 2015

00:08:44,959 --> 00:08:50,080
and up until now kong has built not only

00:08:48,399 --> 00:08:53,040
adoption but also quite of um

00:08:50,080 --> 00:08:54,640
you know engaged community that helps us

00:08:53,040 --> 00:08:57,200
making the gateway better and better

00:08:54,640 --> 00:08:57,200
over time

00:08:57,920 --> 00:09:01,760
it provides a hundred uh you know we

00:09:00,640 --> 00:09:04,320
natalie kong

00:09:01,760 --> 00:09:05,680
congress right now has 1.5 million

00:09:04,320 --> 00:09:08,160
instances per month

00:09:05,680 --> 00:09:10,320
uh running across the world and you know

00:09:08,160 --> 00:09:12,080
was born in 2015 from another company

00:09:10,320 --> 00:09:12,560
before being the cto and co-founder of

00:09:12,080 --> 00:09:14,480
kong

00:09:12,560 --> 00:09:16,240
i was the cto and co-founder of mass

00:09:14,480 --> 00:09:19,279
shape which was the largest api

00:09:16,240 --> 00:09:21,440
marketplace in the world back in 2015.

00:09:19,279 --> 00:09:23,920
uh my shape you know was a marketplace

00:09:21,440 --> 00:09:26,000
that allowed the developers to either

00:09:23,920 --> 00:09:27,360
find the apis to consume or publish

00:09:26,000 --> 00:09:29,680
their own api

00:09:27,360 --> 00:09:30,640
for to allow other people to consume it

00:09:29,680 --> 00:09:33,200
um and so

00:09:30,640 --> 00:09:34,800
you know we needed ourselves a gateway

00:09:33,200 --> 00:09:36,320
that could run on kubernetes that could

00:09:34,800 --> 00:09:38,880
run in a distributed way

00:09:36,320 --> 00:09:40,720
and back then in 2015 there wasn't

00:09:38,880 --> 00:09:41,680
really anything like that so we built it

00:09:40,720 --> 00:09:43,839
ourselves

00:09:41,680 --> 00:09:45,519
and we built it in a very in a very

00:09:43,839 --> 00:09:48,080
lightweight and fast

00:09:45,519 --> 00:09:49,279
uh and fast way the performance the ease

00:09:48,080 --> 00:09:50,480
of use the performance and the

00:09:49,279 --> 00:09:52,720
portability of kong

00:09:50,480 --> 00:09:54,160
really are the three pillars that

00:09:52,720 --> 00:09:56,399
identify the project

00:09:54,160 --> 00:09:58,399
and um and you know we built it for

00:09:56,399 --> 00:09:58,880
ourselves and then we have open sourced

00:09:58,399 --> 00:10:02,000
it

00:09:58,880 --> 00:10:06,480
and the gateway adoption was

00:10:02,000 --> 00:10:10,399
so much faster than the shape adoption

00:10:06,480 --> 00:10:12,959
that in 2017 we made a call to

00:10:10,399 --> 00:10:14,560
divest the marketplace mass shape and

00:10:12,959 --> 00:10:17,120
focus fully on kong

00:10:14,560 --> 00:10:19,120
and since then kong has been has been

00:10:17,120 --> 00:10:21,200
you know growing uh we have 180

00:10:19,120 --> 00:10:22,959
plus core contributors 50 000 community

00:10:21,200 --> 00:10:24,160
members it's being adopted by not only

00:10:22,959 --> 00:10:26,640
community but also

00:10:24,160 --> 00:10:28,399
organizations from all over the world so

00:10:26,640 --> 00:10:29,519
um it's quite of a stable and

00:10:28,399 --> 00:10:31,920
feature-rich

00:10:29,519 --> 00:10:32,640
feature-rich gateway and we also provide

00:10:31,920 --> 00:10:35,760
more than

00:10:32,640 --> 00:10:36,720
500 plugins across the world that the

00:10:35,760 --> 00:10:38,399
community has built

00:10:36,720 --> 00:10:40,240
to enhance what the gateway can do and

00:10:38,399 --> 00:10:43,279
of course all of this feature set

00:10:40,240 --> 00:10:43,920
is available out of the box as an

00:10:43,279 --> 00:10:46,959
ingress

00:10:43,920 --> 00:10:48,640
on kubernetes

00:10:46,959 --> 00:10:50,240
i know there are i'm seeing there is uh

00:10:48,640 --> 00:10:51,920
some questions about service mesh and

00:10:50,240 --> 00:10:52,959
gateway i'm going to be addressing those

00:10:51,920 --> 00:10:55,600
questions

00:10:52,959 --> 00:10:58,320
uh later on uh at the end of this

00:10:55,600 --> 00:10:58,320
presentation

00:10:58,720 --> 00:11:03,120
born in 2015 from a shape agnostic and

00:11:01,120 --> 00:11:04,079
kubernetes native you can configure kong

00:11:03,120 --> 00:11:07,600
we can configure

00:11:04,079 --> 00:11:09,600
kong by using uh kubernetes crds

00:11:07,600 --> 00:11:11,360
um you know hundreds of millions of

00:11:09,600 --> 00:11:12,880
downloads it's been used in production

00:11:11,360 --> 00:11:14,480
in mission critical use cases in pretty

00:11:12,880 --> 00:11:15,760
much every every industry you know

00:11:14,480 --> 00:11:17,279
everybody's moving to kubernetes

00:11:15,760 --> 00:11:19,839
everybody needs an ingress

00:11:17,279 --> 00:11:21,040
um it's built on top of engine x when it

00:11:19,839 --> 00:11:23,519
comes to

00:11:21,040 --> 00:11:25,680
the networking non-blocking networking i

00:11:23,519 --> 00:11:26,720
o and we have extended engine x with lua

00:11:25,680 --> 00:11:28,880
and luagit

00:11:26,720 --> 00:11:29,760
so if you're familiar with uh the lua

00:11:28,880 --> 00:11:32,079
luigi

00:11:29,760 --> 00:11:33,920
stack uh that's called open resting open

00:11:32,079 --> 00:11:36,560
rest effectively is a framework

00:11:33,920 --> 00:11:38,399
that allows us to hook into the request

00:11:36,560 --> 00:11:40,240
and response life cycle

00:11:38,399 --> 00:11:42,079
that are you know that are being

00:11:40,240 --> 00:11:43,040
processed by nginx and it allows us to

00:11:42,079 --> 00:11:45,440
extend it

00:11:43,040 --> 00:11:47,519
in on a very extremely fast virtual

00:11:45,440 --> 00:11:50,959
machine implementation of lua

00:11:47,519 --> 00:11:51,920
luajit and we've built we built an

00:11:50,959 --> 00:11:53,440
ingress

00:11:51,920 --> 00:11:55,120
and a service mesh so i'm going to be

00:11:53,440 --> 00:11:57,440
talking about service mesh later on

00:11:55,120 --> 00:11:58,720
um data plane that can be deployed

00:11:57,440 --> 00:12:00,639
pretty much anywhere in kubernetes

00:11:58,720 --> 00:12:02,800
ingress it's only one of the deployments

00:12:00,639 --> 00:12:04,079
there is 20 plus different deployments

00:12:02,800 --> 00:12:06,000
you could be downloading this on a

00:12:04,079 --> 00:12:07,440
raspberry pi and make that part of your

00:12:06,000 --> 00:12:10,000
cluster so it's very

00:12:07,440 --> 00:12:12,079
simple lightweight but also quite

00:12:10,000 --> 00:12:14,399
extensible

00:12:12,079 --> 00:12:14,399
um

00:12:18,560 --> 00:12:22,240
the concept of plugins it's a very

00:12:20,320 --> 00:12:25,279
important concept in kong

00:12:22,240 --> 00:12:28,079
you know kong without plugins

00:12:25,279 --> 00:12:29,839
it's it's a plugable it's a plugable

00:12:28,079 --> 00:12:32,399
framework but it doesn't do much

00:12:29,839 --> 00:12:34,480
plugins really are the features and

00:12:32,399 --> 00:12:37,600
functionalities that we can adopt

00:12:34,480 --> 00:12:38,079
on top of our apis and some of these

00:12:37,600 --> 00:12:39,839
plugins

00:12:38,079 --> 00:12:41,279
are built by kong some of these plugins

00:12:39,839 --> 00:12:42,800
are built by the community and there is

00:12:41,279 --> 00:12:44,800
a plugin sdk

00:12:42,800 --> 00:12:46,320
that allows pretty much everybody to

00:12:44,800 --> 00:12:48,160
build their own plugins if they want to

00:12:46,320 --> 00:12:50,839
do so you can build plugins in

00:12:48,160 --> 00:12:52,160
lua in c in golang so it's quite

00:12:50,839 --> 00:12:54,079
extensible uh

00:12:52,160 --> 00:12:55,600
plugins can do all sorts of things

00:12:54,079 --> 00:12:57,200
plugins can provide authentication

00:12:55,600 --> 00:12:58,959
authorization features plugins can

00:12:57,200 --> 00:13:01,519
provide security traffic control

00:12:58,959 --> 00:13:02,959
integrations with serverless uh

00:13:01,519 --> 00:13:04,800
integration with monitoring and

00:13:02,959 --> 00:13:06,240
analytics solutions transformations

00:13:04,800 --> 00:13:08,720
logging so there is a

00:13:06,240 --> 00:13:09,440
i believe more than 60 plus plugins that

00:13:08,720 --> 00:13:11,040
we bundle

00:13:09,440 --> 00:13:12,959
that are bundled with kong and are

00:13:11,040 --> 00:13:14,240
available out of the box

00:13:12,959 --> 00:13:16,480
and then like i said there is a

00:13:14,240 --> 00:13:19,040
community of 500 plus plugins on github

00:13:16,480 --> 00:13:21,839
that we could also be using on top of

00:13:19,040 --> 00:13:21,839
our ingress

00:13:22,639 --> 00:13:26,079
the kubernetes ingress controller

00:13:24,160 --> 00:13:27,920
particularly uh it's

00:13:26,079 --> 00:13:30,160
actually been the same it was all

00:13:27,920 --> 00:13:31,519
together in one repository we found out

00:13:30,160 --> 00:13:33,519
that that doesn't really scale much

00:13:31,519 --> 00:13:35,120
well when it comes to the issues and

00:13:33,519 --> 00:13:36,880
requests and the project management

00:13:35,120 --> 00:13:38,720
so we decided to separate the english

00:13:36,880 --> 00:13:40,240
controller aspects of cog into a

00:13:38,720 --> 00:13:42,480
separate repository

00:13:40,240 --> 00:13:43,760
uh kong slash kubernetes dash ingress

00:13:42,480 --> 00:13:45,839
dash controller

00:13:43,760 --> 00:13:47,839
uh and we also provide a set of guides

00:13:45,839 --> 00:13:48,959
and tutorials that will help you getting

00:13:47,839 --> 00:13:51,839
up and running with

00:13:48,959 --> 00:13:53,600
setting up a very flexible ingress the

00:13:51,839 --> 00:13:56,240
kong ingress on top of any

00:13:53,600 --> 00:13:57,120
kubernetes cluster on any cloud and then

00:13:56,240 --> 00:13:58,959
being able to

00:13:57,120 --> 00:14:00,720
apply plugins on top of it so in the

00:13:58,959 --> 00:14:02,240
demo today we're going to be seeing

00:14:00,720 --> 00:14:03,279
security plugins we're going to be

00:14:02,240 --> 00:14:04,959
seeing

00:14:03,279 --> 00:14:07,440
rate limiting plugins we're going to be

00:14:04,959 --> 00:14:09,279
seeing observability plugins

00:14:07,440 --> 00:14:10,480
so let's not waste any time let's go

00:14:09,279 --> 00:14:14,000
straight into

00:14:10,480 --> 00:14:16,880
into the demo um but um

00:14:14,000 --> 00:14:18,000
before i go um so uh there is a question

00:14:16,880 --> 00:14:20,800
does kong support

00:14:18,000 --> 00:14:21,279
service mesh like envoy or istio do you

00:14:20,800 --> 00:14:24,160
need

00:14:21,279 --> 00:14:25,519
a service mesh with cog you can use kong

00:14:24,160 --> 00:14:27,040
kong doesn't make any assumptions to

00:14:25,519 --> 00:14:29,279
what the upstream

00:14:27,040 --> 00:14:31,120
service is it can be a service mesh and

00:14:29,279 --> 00:14:33,360
we have integrated natively

00:14:31,120 --> 00:14:34,959
with istio and with kuma whom is a

00:14:33,360 --> 00:14:36,560
service mesh that's open source and has

00:14:34,959 --> 00:14:39,600
been donated two days ago

00:14:36,560 --> 00:14:40,639
to the cncf uh foundation as a sandbox

00:14:39,600 --> 00:14:43,760
project

00:14:40,639 --> 00:14:45,440
and and it integrates natively natively

00:14:43,760 --> 00:14:45,920
with kong so you can use kang as an

00:14:45,440 --> 00:14:48,000
ingress

00:14:45,920 --> 00:14:49,199
to enter a mesh you can also use skunk

00:14:48,000 --> 00:14:52,000
as an egress

00:14:49,199 --> 00:14:53,680
for a mesh and we can apply we can apply

00:14:52,000 --> 00:14:55,040
our plugins not just in the ingress

00:14:53,680 --> 00:14:57,920
capacity

00:14:55,040 --> 00:14:59,120
but also in an egress capacity so it can

00:14:57,920 --> 00:15:01,440
work pretty much

00:14:59,120 --> 00:15:03,600
with with all sorts of things you can we

00:15:01,440 --> 00:15:06,079
can also use kong in front of

00:15:03,600 --> 00:15:08,000
for example aws lambdas we can also use

00:15:06,079 --> 00:15:09,519
kong in front of kafka

00:15:08,000 --> 00:15:11,279
we provide you know kafka

00:15:09,519 --> 00:15:13,360
transformations to automatically

00:15:11,279 --> 00:15:16,000
transition a service to service requests

00:15:13,360 --> 00:15:17,839
into an event-based request so the

00:15:16,000 --> 00:15:20,240
plugins that kong provides

00:15:17,839 --> 00:15:21,839
are extremely powerful today in the demo

00:15:20,240 --> 00:15:23,760
for the sake of simplicity i'm going to

00:15:21,839 --> 00:15:25,680
be showing some very simple plugins

00:15:23,760 --> 00:15:27,440
but you can take this as a starting

00:15:25,680 --> 00:15:29,199
point to go and experiment with more

00:15:27,440 --> 00:15:30,800
plugins you know plugins that do request

00:15:29,199 --> 00:15:31,680
response transformation all sorts of

00:15:30,800 --> 00:15:34,000
things

00:15:31,680 --> 00:15:35,440
um so today in the demo i'm going to be

00:15:34,000 --> 00:15:37,120
sharing my screen now

00:15:35,440 --> 00:15:38,480
i'm going to be running a mini cube

00:15:37,120 --> 00:15:40,000
cluster on my computer

00:15:38,480 --> 00:15:42,720
i'm going to be deploying a very simple

00:15:40,000 --> 00:15:44,320
service that i'm going to be using for

00:15:42,720 --> 00:15:45,920
for for the demo and i'm going to be

00:15:44,320 --> 00:15:47,360
deploying a kong ingress

00:15:45,920 --> 00:15:49,519
then once i have the kang ingress

00:15:47,360 --> 00:15:52,079
deployed i'm going to be

00:15:49,519 --> 00:15:54,399
uh configuring a few plugins on top of

00:15:52,079 --> 00:15:56,800
the ingress so we can all see how kong

00:15:54,399 --> 00:15:58,079
works with plugins and what kong can do

00:15:56,800 --> 00:16:00,000
and this is really meant to give you a

00:15:58,079 --> 00:16:04,959
look and feel of the project

00:16:00,000 --> 00:16:04,959
so i'm going to be showing my screen now

00:16:07,360 --> 00:16:13,920
and if everything went well

00:16:10,639 --> 00:16:16,480
you should be seeing my terminal

00:16:13,920 --> 00:16:18,000
um right now i'm running an empty

00:16:16,480 --> 00:16:19,519
cluster so you know

00:16:18,000 --> 00:16:21,040
this is an empty kubernetes cluster

00:16:19,519 --> 00:16:22,720
running on top of mini cube there is

00:16:21,040 --> 00:16:24,079
really nothing going on here

00:16:22,720 --> 00:16:25,600
so the first thing i'm going to be doing

00:16:24,079 --> 00:16:27,360
is deploying a simple service that we're

00:16:25,600 --> 00:16:29,600
going to be using for our demo

00:16:27,360 --> 00:16:30,480
um first and foremost uh all these

00:16:29,600 --> 00:16:33,839
instructions

00:16:30,480 --> 00:16:35,920
i'm showing my browser now

00:16:33,839 --> 00:16:37,120
all of these instructions can be found

00:16:35,920 --> 00:16:39,519
in the documentation

00:16:37,120 --> 00:16:41,120
so in the docs directory uh we do

00:16:39,519 --> 00:16:43,040
provide

00:16:41,120 --> 00:16:44,880
a set of guides and tutorials that you

00:16:43,040 --> 00:16:47,519
can follow and really

00:16:44,880 --> 00:16:48,880
it show these are some just some of the

00:16:47,519 --> 00:16:51,040
things that we can

00:16:48,880 --> 00:16:52,240
you know that we demonstrate on top of

00:16:51,040 --> 00:16:55,440
kong uh but

00:16:52,240 --> 00:16:58,480
then of course all of these um

00:16:55,440 --> 00:17:00,160
all of the plugins could be used uh in

00:16:58,480 --> 00:17:01,440
an inverse capacity so we're talking

00:17:00,160 --> 00:17:02,800
about many different plugins and many

00:17:01,440 --> 00:17:05,280
different integrations that can

00:17:02,800 --> 00:17:06,640
use out of the box on top of car so

00:17:05,280 --> 00:17:10,079
let's go ahead and

00:17:06,640 --> 00:17:12,480
install a very simple service

00:17:10,079 --> 00:17:14,160
um i call it the echo service that's

00:17:12,480 --> 00:17:15,039
going to be acting back every request

00:17:14,160 --> 00:17:18,319
i'm making

00:17:15,039 --> 00:17:20,400
so um this uh

00:17:18,319 --> 00:17:22,079
this service is quite simple uh it's a

00:17:20,400 --> 00:17:23,280
service it's a deployment and it tackles

00:17:22,079 --> 00:17:24,480
back pretty much every request we're

00:17:23,280 --> 00:17:26,640
sending to him

00:17:24,480 --> 00:17:28,720
to to the service so if i if i look at

00:17:26,640 --> 00:17:32,559
the namespace i'm sorry at the pods

00:17:28,720 --> 00:17:36,000
we see that we have a new echo pod

00:17:32,559 --> 00:17:38,000
and uh if i if i look at

00:17:36,000 --> 00:17:40,080
the services that have right now

00:17:38,000 --> 00:17:41,039
deployed this we see there is an acre

00:17:40,080 --> 00:17:44,840
service

00:17:41,039 --> 00:17:47,760
so if i if i port forward the echo

00:17:44,840 --> 00:17:52,000
service

00:17:47,760 --> 00:17:52,000
we can make a few requests to it and

00:17:52,160 --> 00:17:55,200
and as you would expect this is a very

00:17:54,000 --> 00:17:57,600
simple service

00:17:55,200 --> 00:17:59,600
it just echoes back the request that i'm

00:17:57,600 --> 00:18:00,160
making the request headers the request

00:17:59,600 --> 00:18:01,679
body

00:18:00,160 --> 00:18:03,039
and so on and so forth so it's very

00:18:01,679 --> 00:18:04,400
simple and it's great for debugging

00:18:03,039 --> 00:18:06,720
purposes

00:18:04,400 --> 00:18:08,400
now i'm connecting to this service using

00:18:06,720 --> 00:18:10,160
port forward but that's not the point of

00:18:08,400 --> 00:18:11,120
this demo the point of this demo is to

00:18:10,160 --> 00:18:13,360
use an ingress

00:18:11,120 --> 00:18:14,640
to be able to consume this service so

00:18:13,360 --> 00:18:16,000
i'm going to stop i'm going to close

00:18:14,640 --> 00:18:17,360
this window and i'm going to stop the

00:18:16,000 --> 00:18:20,480
port forwarding

00:18:17,360 --> 00:18:21,280
and i'm going to be installing cog

00:18:20,480 --> 00:18:24,320
ingress

00:18:21,280 --> 00:18:26,240
so if you go if we go back to uh

00:18:24,320 --> 00:18:28,000
the homepage or a repository there's

00:18:26,240 --> 00:18:28,640
different ways that we can install the

00:18:28,000 --> 00:18:31,200
ingress

00:18:28,640 --> 00:18:31,919
uh we can just use you know ayamo we can

00:18:31,200 --> 00:18:35,039
use helm

00:18:31,919 --> 00:18:36,400
helm charts um for for this presentation

00:18:35,039 --> 00:18:38,559
i'm gonna use the yamo

00:18:36,400 --> 00:18:40,240
and this will create a few resources in

00:18:38,559 --> 00:18:43,120
our system including

00:18:40,240 --> 00:18:44,240
a kong namespace so if we go and explore

00:18:43,120 --> 00:18:47,120
the kong namespace

00:18:44,240 --> 00:18:49,120
we see that the ingress is being created

00:18:47,120 --> 00:18:51,840
right now

00:18:49,120 --> 00:18:52,240
um this is a blank it's a brand new mini

00:18:51,840 --> 00:18:56,400
cube

00:18:52,240 --> 00:18:59,120
so it's going to download

00:18:56,400 --> 00:19:01,120
the the container and then run it it

00:18:59,120 --> 00:19:02,960
shouldn't take that much there we go

00:19:01,120 --> 00:19:05,919
now it's running i'm ready i'm waiting

00:19:02,960 --> 00:19:08,080
for it to be fully

00:19:05,919 --> 00:19:09,760
fully ready and there we go so now that

00:19:08,080 --> 00:19:12,960
you have our ingress

00:19:09,760 --> 00:19:14,640
running uh what i'm going to be doing is

00:19:12,960 --> 00:19:16,799
applying a very simple ingress

00:19:14,640 --> 00:19:18,400
configuration that is going to be

00:19:16,799 --> 00:19:22,240
exposing our echo service

00:19:18,400 --> 00:19:25,120
on a on a roof on a on a slash path

00:19:22,240 --> 00:19:26,480
so what this does it's quite simple i'm

00:19:25,120 --> 00:19:28,240
echoing back a configuration that

00:19:26,480 --> 00:19:31,280
creates a new ingress resource

00:19:28,240 --> 00:19:34,559
called demo uh we can configure

00:19:31,280 --> 00:19:35,360
annotations in in the ingress in this

00:19:34,559 --> 00:19:38,320
case

00:19:35,360 --> 00:19:39,039
um i am going to be stripping the path

00:19:38,320 --> 00:19:41,440
with kong

00:19:39,039 --> 00:19:42,400
i'm setting up an http rule every

00:19:41,440 --> 00:19:46,000
request

00:19:42,400 --> 00:19:47,039
to our route will go to a service name

00:19:46,000 --> 00:19:49,039
called echo

00:19:47,039 --> 00:19:50,320
on the service board quite

00:19:49,039 --> 00:19:53,600
straightforward

00:19:50,320 --> 00:19:55,600
if i apply this configuration we do

00:19:53,600 --> 00:19:58,400
create an ingress and if i now

00:19:55,600 --> 00:19:59,520
expose if i now go to the ip address of

00:19:58,400 --> 00:20:02,960
mini cube

00:19:59,520 --> 00:20:03,600
which is here i'll be able to access the

00:20:02,960 --> 00:20:05,679
ingress

00:20:03,600 --> 00:20:06,960
and access my service so let's go there

00:20:05,679 --> 00:20:08,080
and there we go this is the service

00:20:06,960 --> 00:20:10,720
being consumed

00:20:08,080 --> 00:20:12,159
through the ingress like i said this

00:20:10,720 --> 00:20:14,080
ingress doesn't do much right now it's a

00:20:12,159 --> 00:20:16,240
simple ingress it's a simple router

00:20:14,080 --> 00:20:18,320
that runs on top of an http service

00:20:16,240 --> 00:20:21,600
there is no functionality whatsoever

00:20:18,320 --> 00:20:24,400
running on top of this right now

00:20:21,600 --> 00:20:25,039
but let's change that let's go ahead for

00:20:24,400 --> 00:20:27,200
example

00:20:25,039 --> 00:20:29,120
and look at some of the plugins that we

00:20:27,200 --> 00:20:31,360
can apply on top of ingress

00:20:29,120 --> 00:20:32,159
so let's say i want to protect the

00:20:31,360 --> 00:20:35,120
ingress

00:20:32,159 --> 00:20:35,760
with um a key authentication uh

00:20:35,120 --> 00:20:37,520
protection

00:20:35,760 --> 00:20:39,200
so this allows us to effectively have an

00:20:37,520 --> 00:20:41,600
api key to uh

00:20:39,200 --> 00:20:43,039
to access our services if a gold kong

00:20:41,600 --> 00:20:44,480
you know the key authentication plugin

00:20:43,039 --> 00:20:46,320
uh like every plugin

00:20:44,480 --> 00:20:48,159
provides a few things it provides a name

00:20:46,320 --> 00:20:50,240
that's unique in this case it's the key

00:20:48,159 --> 00:20:52,159
of plugin and provides a configuration i

00:20:50,240 --> 00:20:53,520
can configure many things here

00:20:52,159 --> 00:20:55,360
but i'm going to be using the simplest

00:20:53,520 --> 00:20:57,760
configuration i can possibly have

00:20:55,360 --> 00:20:58,559
for this plugin and that is just the

00:20:57,760 --> 00:20:59,919
name

00:20:58,559 --> 00:21:01,679
so i'm going to be creating a new

00:20:59,919 --> 00:21:04,000
concluding resource this

00:21:01,679 --> 00:21:05,600
ships with the ingress i'm going to be

00:21:04,000 --> 00:21:07,280
creating assigning a name

00:21:05,600 --> 00:21:09,280
to this resource and i'm going to be

00:21:07,280 --> 00:21:11,120
specifying the name of the plugin that i

00:21:09,280 --> 00:21:13,840
want to use

00:21:11,120 --> 00:21:15,600
i could be using any plugin in this case

00:21:13,840 --> 00:21:17,039
i'm using the kiot plugin and you can

00:21:15,600 --> 00:21:18,799
find the names of those plugins

00:21:17,039 --> 00:21:22,159
you know by clicking on the plugin hub

00:21:18,799 --> 00:21:25,919
on you know congratulations

00:21:22,159 --> 00:21:27,760
but anyways let's go ahead and apply

00:21:25,919 --> 00:21:29,200
this plugin so i'm creating a plugin

00:21:27,760 --> 00:21:32,480
configuration

00:21:29,200 --> 00:21:33,120
that it's going to be available to the

00:21:32,480 --> 00:21:34,960
ingress

00:21:33,120 --> 00:21:37,039
but in order to make this work with the

00:21:34,960 --> 00:21:38,080
ingress i also need to update my ingress

00:21:37,039 --> 00:21:39,760
resource

00:21:38,080 --> 00:21:41,840
with this new annotation which

00:21:39,760 --> 00:21:43,440
determines what plugins are going to be

00:21:41,840 --> 00:21:45,440
running on the execution path of the

00:21:43,440 --> 00:21:47,679
ingress and in this case it's this new

00:21:45,440 --> 00:21:50,480
plugin configuration i've just created

00:21:47,679 --> 00:21:51,440
so if i do this i update the ingress

00:21:50,480 --> 00:21:55,200
object

00:21:51,440 --> 00:21:57,360
and if i go back and consume my service

00:21:55,200 --> 00:21:58,720
this is not going to work anymore so

00:21:57,360 --> 00:22:00,799
this is not going to work

00:21:58,720 --> 00:22:02,480
because the ingress will receive the

00:22:00,799 --> 00:22:03,679
request it will determine that there is

00:22:02,480 --> 00:22:05,360
a plugin enabled

00:22:03,679 --> 00:22:07,120
in this case key authentication and it

00:22:05,360 --> 00:22:07,919
will determine that i didn't set any key

00:22:07,120 --> 00:22:10,080
in my request

00:22:07,919 --> 00:22:12,000
therefore i am not authorized to make

00:22:10,080 --> 00:22:14,559
the request

00:22:12,000 --> 00:22:15,760
in order to be able to provision a key i

00:22:14,559 --> 00:22:18,720
need to create a con

00:22:15,760 --> 00:22:20,159
consumer a consumer in kong it's like um

00:22:18,720 --> 00:22:22,640
a client or a

00:22:20,159 --> 00:22:23,600
developer and a consumer can have

00:22:22,640 --> 00:22:26,320
multiple keys

00:22:23,600 --> 00:22:27,360
so you know with congo we can implement

00:22:26,320 --> 00:22:28,960
quite complex

00:22:27,360 --> 00:22:31,039
and this is just for kiosk but we can

00:22:28,960 --> 00:22:32,880
implement quite complex

00:22:31,039 --> 00:22:34,799
rules when it comes to what consumers

00:22:32,880 --> 00:22:36,080
what users are able to consume what

00:22:34,799 --> 00:22:37,679
services and how they're going to be

00:22:36,080 --> 00:22:41,200
managing their keys

00:22:37,679 --> 00:22:44,320
so in this case in order to move forward

00:22:41,200 --> 00:22:47,440
i need to create a consumer object

00:22:44,320 --> 00:22:50,320
in in kong um consumer

00:22:47,440 --> 00:22:51,760
name marco and then i need to be able i

00:22:50,320 --> 00:22:55,280
need to create a key

00:22:51,760 --> 00:22:57,120
that the marco consumer will use in

00:22:55,280 --> 00:23:00,320
order to be able to consume the service

00:22:57,120 --> 00:23:03,200
and this key as you can imagine is uh

00:23:00,320 --> 00:23:04,640
one second this key is going to be a

00:23:03,200 --> 00:23:06,400
kubernetes secret

00:23:04,640 --> 00:23:09,840
so i'm going to be creating a kubernetes

00:23:06,400 --> 00:23:12,960
secret marco api key

00:23:09,840 --> 00:23:16,240
of credential type kioff with

00:23:12,960 --> 00:23:17,280
the following secret key the credential

00:23:16,240 --> 00:23:19,760
type

00:23:17,280 --> 00:23:22,240
it's kiot because we want to create a

00:23:19,760 --> 00:23:23,360
simple api key but it can be

00:23:22,240 --> 00:23:24,640
you know different authentication

00:23:23,360 --> 00:23:25,360
plugins are going to be having different

00:23:24,640 --> 00:23:27,440
types

00:23:25,360 --> 00:23:30,159
so if i do this i create an api key and

00:23:27,440 --> 00:23:33,520
then i can associate the api key

00:23:30,159 --> 00:23:35,600
to the to the consumer

00:23:33,520 --> 00:23:36,799
to the consumer by updating the consumer

00:23:35,600 --> 00:23:39,919
object

00:23:36,799 --> 00:23:41,360
and adding a new credentials array that

00:23:39,919 --> 00:23:43,600
determines what keys

00:23:41,360 --> 00:23:44,400
belong to this user so in this case i

00:23:43,600 --> 00:23:47,120
want the

00:23:44,400 --> 00:23:47,840
marquee consumer to be associated with

00:23:47,120 --> 00:23:49,919
the key

00:23:47,840 --> 00:23:50,960
we have just created and that is secret

00:23:49,919 --> 00:23:54,240
one two three

00:23:50,960 --> 00:23:56,320
so if we do this we have an ingress

00:23:54,240 --> 00:23:57,279
we have a plugin we have a consumer and

00:23:56,320 --> 00:24:00,880
we have a key

00:23:57,279 --> 00:24:04,480
so let's go ahead and now make a request

00:24:00,880 --> 00:24:05,600
with the api key secret one two three

00:24:04,480 --> 00:24:09,919
and this request

00:24:05,600 --> 00:24:14,080
will now work again if i enter a run key

00:24:09,919 --> 00:24:16,080
the request will be blocked quite simple

00:24:14,080 --> 00:24:17,679
now of course you know being able to

00:24:16,080 --> 00:24:19,600
secure with an api key it's probably one

00:24:17,679 --> 00:24:21,919
of the simplest things that we can do

00:24:19,600 --> 00:24:23,679
another thing that we want to be able to

00:24:21,919 --> 00:24:26,240
perform on top of an ingress

00:24:23,679 --> 00:24:27,039
is visualizing you know what are all the

00:24:26,240 --> 00:24:28,880
requests

00:24:27,039 --> 00:24:30,400
that are coming through and for doing

00:24:28,880 --> 00:24:32,960
that comp provides

00:24:30,400 --> 00:24:34,880
um a native prometheus and graffana

00:24:32,960 --> 00:24:36,559
integration so if you go to

00:24:34,880 --> 00:24:38,400
analytics and monitoring we can see that

00:24:36,559 --> 00:24:38,799
it provides you know we integrate with

00:24:38,400 --> 00:24:41,120
with

00:24:38,799 --> 00:24:42,000
a few different providers but prometus

00:24:41,120 --> 00:24:43,520
is one of them

00:24:42,000 --> 00:24:45,200
so what i'm going to be doing is

00:24:43,520 --> 00:24:46,240
creating a new monitoring namespace

00:24:45,200 --> 00:24:48,000
where i'm going to be downloading

00:24:46,240 --> 00:24:49,360
prometus and grafana and then i'm going

00:24:48,000 --> 00:24:49,840
to be collecting metrics from the

00:24:49,360 --> 00:24:52,640
ingress

00:24:49,840 --> 00:24:54,640
out of the box so i create a new

00:24:52,640 --> 00:24:55,840
monitoring namespace

00:24:54,640 --> 00:24:58,840
and then within this monitoring

00:24:55,840 --> 00:25:00,400
namespace i am going to be installing

00:24:58,840 --> 00:25:01,520
prometus

00:25:00,400 --> 00:25:03,520
and you know the values and the

00:25:01,520 --> 00:25:07,200
configurations all of these examples

00:25:03,520 --> 00:25:08,320
are available on the github repository

00:25:07,200 --> 00:25:10,159
for the ingress

00:25:08,320 --> 00:25:11,919
so i'm going to be installing prometus

00:25:10,159 --> 00:25:15,200
and i am going to be selling

00:25:11,919 --> 00:25:17,520
grafana as well

00:25:15,200 --> 00:25:19,039
so if i do this obviously there is a new

00:25:17,520 --> 00:25:21,039
monitoring namespace

00:25:19,039 --> 00:25:22,880
uh then i can look into the monitoring

00:25:21,039 --> 00:25:25,919
namespace

00:25:22,880 --> 00:25:27,440
on ituring and i can see that we have a

00:25:25,919 --> 00:25:29,200
few different services running and

00:25:27,440 --> 00:25:30,640
initializing so this is going to take a

00:25:29,200 --> 00:25:32,400
while because it's downloading for me to

00:25:30,640 --> 00:25:35,440
the angry fan

00:25:32,400 --> 00:25:36,640
for my mini cube this is where the fan

00:25:35,440 --> 00:25:39,120
on my laptop

00:25:36,640 --> 00:25:39,760
starts turning on and increasing in

00:25:39,120 --> 00:25:42,799
speed

00:25:39,760 --> 00:25:43,520
i can hear it and we're waiting for

00:25:42,799 --> 00:25:45,520
grafana

00:25:43,520 --> 00:25:47,440
and then once we have all of these

00:25:45,520 --> 00:25:49,600
running we should also be able to see a

00:25:47,440 --> 00:25:51,679
few services here

00:25:49,600 --> 00:25:53,600
and that is the grafana service which

00:25:51,679 --> 00:25:57,279
i'm going to be using to load

00:25:53,600 --> 00:25:59,440
to load the dashboard and see our our

00:25:57,279 --> 00:26:00,480
our uh monitoring information okay now

00:25:59,440 --> 00:26:03,919
prometus is running

00:26:00,480 --> 00:26:05,679
rafan is running again

00:26:03,919 --> 00:26:08,159
this is not gonna work until i install

00:26:05,679 --> 00:26:10,559
the prometus plugin the prometus plugin

00:26:08,159 --> 00:26:11,279
uh is a plugin with name promises that

00:26:10,559 --> 00:26:14,320
determines

00:26:11,279 --> 00:26:17,360
that i am going to be able to

00:26:14,320 --> 00:26:18,799
uh make all the metrics available to two

00:26:17,360 --> 00:26:21,200
promoters and so

00:26:18,799 --> 00:26:22,080
if i go back to my terminal i'm going to

00:26:21,200 --> 00:26:25,120
be running

00:26:22,080 --> 00:26:28,320
the prometus plugin on top of

00:26:25,120 --> 00:26:31,200
um i'm going to create this new resource

00:26:28,320 --> 00:26:32,480
plugin prometus on top of my kubernetes

00:26:31,200 --> 00:26:36,159
cluster

00:26:32,480 --> 00:26:39,279
and if i do that now

00:26:36,159 --> 00:26:43,200
we have enabled metrics collection

00:26:39,279 --> 00:26:46,400
from our ingress so let's go and

00:26:43,200 --> 00:26:49,919
load the graphana

00:26:46,400 --> 00:26:52,960
the grafana service so if i go look at

00:26:49,919 --> 00:26:54,960
the services i have here

00:26:52,960 --> 00:26:57,120
monitoring uh there is going to be

00:26:54,960 --> 00:26:57,919
grafana before i do that let me get the

00:26:57,120 --> 00:27:00,320
grafana

00:26:57,919 --> 00:27:02,320
i will extract the grafana password that

00:27:00,320 --> 00:27:04,480
we're going to be using later on

00:27:02,320 --> 00:27:06,000
to connect and login into grafana and

00:27:04,480 --> 00:27:10,799
now that i can do that i can port

00:27:06,000 --> 00:27:15,200
forward port forward service grafana

00:27:10,799 --> 00:27:18,240
monitoring namespace uh i'm gonna

00:27:15,200 --> 00:27:21,600
expose it on port 3000. so now that

00:27:18,240 --> 00:27:24,320
we have that i can go import 3000

00:27:21,600 --> 00:27:24,960
this will start graffana admin the

00:27:24,320 --> 00:27:27,360
password

00:27:24,960 --> 00:27:29,919
is the password that we have retrieved

00:27:27,360 --> 00:27:33,520
from the kubernetes secret

00:27:29,919 --> 00:27:35,760
and i i should be able to log in and

00:27:33,520 --> 00:27:37,679
that's great i'm inside graffana right

00:27:35,760 --> 00:27:41,520
now as you can see

00:27:37,679 --> 00:27:44,000
grafana with the example i've executed

00:27:41,520 --> 00:27:44,880
it ships with a kong official dashboard

00:27:44,000 --> 00:27:47,360
so i'm going to be

00:27:44,880 --> 00:27:48,080
loading this dashboard and we can see we

00:27:47,360 --> 00:27:50,080
can see

00:27:48,080 --> 00:27:52,000
obviously we can we can see you know the

00:27:50,080 --> 00:27:54,000
charts that out of the box we provide on

00:27:52,000 --> 00:27:56,000
top of the ingress

00:27:54,000 --> 00:27:57,840
now there is no request being made so

00:27:56,000 --> 00:28:00,640
what i'm going to be doing

00:27:57,840 --> 00:28:01,039
is generate simulate some traffic so

00:28:00,640 --> 00:28:03,760
that

00:28:01,039 --> 00:28:05,120
this gets a little bit more interesting

00:28:03,760 --> 00:28:06,720
in grafana

00:28:05,120 --> 00:28:08,240
so i'm just going to be simulating some

00:28:06,720 --> 00:28:10,799
traffic

00:28:08,240 --> 00:28:12,240
you know in a while through loop on my

00:28:10,799 --> 00:28:15,279
on my terminal

00:28:12,240 --> 00:28:17,520
and by going back to grafana

00:28:15,279 --> 00:28:19,120
the last five minutes we should be

00:28:17,520 --> 00:28:21,760
seeing

00:28:19,120 --> 00:28:22,720
um you know promises i i forgot what's

00:28:21,760 --> 00:28:25,279
the interval

00:28:22,720 --> 00:28:27,039
uh but you know prometheus fetches every

00:28:25,279 --> 00:28:28,399
x number of seconds

00:28:27,039 --> 00:28:31,039
that the metrics and this is

00:28:28,399 --> 00:28:33,760
configurable at one point here

00:28:31,039 --> 00:28:36,240
we should be start seeing the charts

00:28:33,760 --> 00:28:36,240
let's see

00:28:37,200 --> 00:28:49,200
let's wait a few seconds

00:28:45,760 --> 00:28:49,200
and there we go we are seeing

00:28:49,279 --> 00:28:52,320
we are seeing

00:28:53,919 --> 00:29:00,640
the first point coming up online and

00:28:57,360 --> 00:29:04,159
as the next interval kicks in

00:29:00,640 --> 00:29:07,360
these points should become a line

00:29:04,159 --> 00:29:09,039
let's wait a little bit longer

00:29:07,360 --> 00:29:11,360
let's wait on just refreshing and

00:29:09,039 --> 00:29:14,720
refreshing so it says pops up

00:29:11,360 --> 00:29:17,840
we're going to be able to see it

00:29:14,720 --> 00:29:19,279
there we go so these are

00:29:17,840 --> 00:29:21,679
uh the requests per seconds that i'm

00:29:19,279 --> 00:29:24,799
generating from my

00:29:21,679 --> 00:29:27,840
uh while true loop on curl

00:29:24,799 --> 00:29:28,399
and uh it's uh it it shows the the

00:29:27,840 --> 00:29:30,320
service

00:29:28,399 --> 00:29:31,840
in this case the echo service it shows

00:29:30,320 --> 00:29:33,120
the bandwidth it shows all sorts of

00:29:31,840 --> 00:29:36,480
things

00:29:33,120 --> 00:29:38,320
of course now you know we have used the

00:29:36,480 --> 00:29:39,760
key authentication plugin we've used the

00:29:38,320 --> 00:29:44,240
prometus plugin

00:29:39,760 --> 00:29:46,559
so we can secure and we can observe

00:29:44,240 --> 00:29:48,480
what uh the traffic that we're sending

00:29:46,559 --> 00:29:50,960
to ingress

00:29:48,480 --> 00:29:52,799
another common use case is to you know

00:29:50,960 --> 00:29:55,039
for an ingress it's to rate

00:29:52,799 --> 00:29:56,640
limit the number of requests that our

00:29:55,039 --> 00:30:00,080
consumers can make

00:29:56,640 --> 00:30:01,360
on con we have this concept of plugins

00:30:00,080 --> 00:30:04,000
that can be applied

00:30:01,360 --> 00:30:04,880
globally to every service or every

00:30:04,000 --> 00:30:06,960
consumer

00:30:04,880 --> 00:30:08,080
that we're configuring but we can also

00:30:06,960 --> 00:30:10,000
apply plugins

00:30:08,080 --> 00:30:11,200
for a specific service we can also apply

00:30:10,000 --> 00:30:14,480
plugins

00:30:11,200 --> 00:30:16,399
per specific consumer and we can apply

00:30:14,480 --> 00:30:17,600
plugins for a specific service and

00:30:16,399 --> 00:30:20,240
consumer

00:30:17,600 --> 00:30:20,880
so in your typical api management use

00:30:20,240 --> 00:30:23,760
case

00:30:20,880 --> 00:30:25,679
we're going to be having consumers that

00:30:23,760 --> 00:30:26,320
can make let's say 100 requests per

00:30:25,679 --> 00:30:27,919
second

00:30:26,320 --> 00:30:30,240
but then there's going to be some users

00:30:27,919 --> 00:30:32,640
or consumers that we want to white list

00:30:30,240 --> 00:30:34,000
so with con we can apply plugins for

00:30:32,640 --> 00:30:36,159
those kind of consumers

00:30:34,000 --> 00:30:37,120
to give them a higher limit if we want

00:30:36,159 --> 00:30:40,480
to do so

00:30:37,120 --> 00:30:43,120
now the plugins can be applied not just

00:30:40,480 --> 00:30:45,760
the rate limiting plugin but any plugin

00:30:43,120 --> 00:30:48,799
can be applied on each combination of

00:30:45,760 --> 00:30:50,720
of consumer and service so if if you're

00:30:48,799 --> 00:30:52,480
going to be trying congress and you're

00:30:50,720 --> 00:30:53,679
going to be running this on on your

00:30:52,480 --> 00:30:54,480
system you know you can you can

00:30:53,679 --> 00:30:57,919
definitely

00:30:54,480 --> 00:30:58,720
experiment with with all of them uh so

00:30:57,919 --> 00:31:01,279
let's go ahead

00:30:58,720 --> 00:31:03,440
and install the rate limiting plugin so

00:31:01,279 --> 00:31:07,200
i'm going to be stopping

00:31:03,440 --> 00:31:10,559
i um i'm gonna be stopping my

00:31:07,200 --> 00:31:12,720
uh request generator here

00:31:10,559 --> 00:31:14,320
i'm going to be stopping uh the port

00:31:12,720 --> 00:31:16,880
forwarding

00:31:14,320 --> 00:31:18,559
for grafana and i'm going to be running

00:31:16,880 --> 00:31:21,360
another stuff i'm going to be

00:31:18,559 --> 00:31:23,200
installing another plugin that will

00:31:21,360 --> 00:31:25,600
protect and secure

00:31:23,200 --> 00:31:27,279
our requests so that we're not going to

00:31:25,600 --> 00:31:28,080
be able to send more than five per

00:31:27,279 --> 00:31:29,120
minute

00:31:28,080 --> 00:31:30,720
uh we're going to be using the rate

00:31:29,120 --> 00:31:32,240
limiting plugin the rate anything plugin

00:31:30,720 --> 00:31:34,000
can be quite complex

00:31:32,240 --> 00:31:35,360
in a sense that it's quite simple to get

00:31:34,000 --> 00:31:35,840
up and running with the rate limiting

00:31:35,360 --> 00:31:38,000
plugin

00:31:35,840 --> 00:31:39,440
but if you want to even further

00:31:38,000 --> 00:31:41,200
customize the behavior

00:31:39,440 --> 00:31:42,880
uh we have lots of properties that we

00:31:41,200 --> 00:31:43,840
can choose from so in the case of rate

00:31:42,880 --> 00:31:46,240
limiting

00:31:43,840 --> 00:31:47,840
uh we can choose uh how many requests

00:31:46,240 --> 00:31:49,840
per second per minute per hour per day

00:31:47,840 --> 00:31:50,799
per month we want to use per year we can

00:31:49,840 --> 00:31:52,720
limit by

00:31:50,799 --> 00:31:54,640
the consumer by credential so let's say

00:31:52,720 --> 00:31:56,320
that we want to leave just one api key

00:31:54,640 --> 00:31:58,159
not another api key

00:31:56,320 --> 00:31:59,840
we can leave it by service we can limit

00:31:58,159 --> 00:32:00,799
by all sorts of things so we can also

00:31:59,840 --> 00:32:03,039
store

00:32:00,799 --> 00:32:03,919
uh if we want the counters in a

00:32:03,039 --> 00:32:07,200
third-party

00:32:03,919 --> 00:32:08,320
radius host or we also support postgres

00:32:07,200 --> 00:32:11,360
and cassandra

00:32:08,320 --> 00:32:13,360
as back in stores for con for example

00:32:11,360 --> 00:32:14,799
in the case we want to build a global

00:32:13,360 --> 00:32:17,279
rate limiting policy

00:32:14,799 --> 00:32:20,559
that can cross that can be shared across

00:32:17,279 --> 00:32:23,440
different regions and different clusters

00:32:20,559 --> 00:32:25,279
so i am going to be uh installing my

00:32:23,440 --> 00:32:26,720
rate limiting plugin that's global i'm

00:32:25,279 --> 00:32:28,640
going to be limiting

00:32:26,720 --> 00:32:30,080
by five requests per minute i'm going to

00:32:28,640 --> 00:32:31,440
be applying this configuration

00:32:30,080 --> 00:32:34,000
and then let's make more than five

00:32:31,440 --> 00:32:34,799
requests per minute one two three four

00:32:34,000 --> 00:32:37,919
five

00:32:34,799 --> 00:32:41,039
and the system will then

00:32:37,919 --> 00:32:41,039
wait limit the request

00:32:41,360 --> 00:32:45,200
as you can see it's quite

00:32:43,360 --> 00:32:47,600
straightforward um

00:32:45,200 --> 00:32:49,840
simplicity is one of the things that we

00:32:47,600 --> 00:32:52,880
put lots of effort in the past few years

00:32:49,840 --> 00:32:55,919
to make sure that kong could be

00:32:52,880 --> 00:32:56,559
simple to get up and running with simple

00:32:55,919 --> 00:32:58,799
to deploy

00:32:56,559 --> 00:33:00,399
simple to scale and and of course there

00:32:58,799 --> 00:33:02,559
is more advanced functionality

00:33:00,399 --> 00:33:03,840
and you're only getting exposed to that

00:33:02,559 --> 00:33:06,000
complexity

00:33:03,840 --> 00:33:07,360
when the time is right and when we

00:33:06,000 --> 00:33:09,200
really need it

00:33:07,360 --> 00:33:10,880
but not not to get up and running with

00:33:09,200 --> 00:33:12,080
very simple use cases

00:33:10,880 --> 00:33:14,000
i've been doing a demo i've been running

00:33:12,080 --> 00:33:16,240
this demo for 20 minutes now and

00:33:14,000 --> 00:33:18,240
we installed kong ingress we installed a

00:33:16,240 --> 00:33:22,000
service we set up an ingress rule

00:33:18,240 --> 00:33:23,919
we created a consumer a key we have

00:33:22,000 --> 00:33:25,440
set up observability we are now rate

00:33:23,919 --> 00:33:28,000
limiting all the requests

00:33:25,440 --> 00:33:29,840
you can see that it's quite

00:33:28,000 --> 00:33:30,320
straightforward and and kubernetes

00:33:29,840 --> 00:33:31,600
native

00:33:30,320 --> 00:33:33,600
when it comes to configuring these

00:33:31,600 --> 00:33:36,720
resources

00:33:33,600 --> 00:33:38,480
so um i want to

00:33:36,720 --> 00:33:41,360
focus a little bit on the service mesh

00:33:38,480 --> 00:33:44,799
questions um you know

00:33:41,360 --> 00:33:46,240
cong can work on on top of a very simple

00:33:44,799 --> 00:33:49,919
service a very simple api

00:33:46,240 --> 00:33:51,519
it can work on top of functions

00:33:49,919 --> 00:33:54,159
in the case of kubernetes it can work on

00:33:51,519 --> 00:33:56,320
top of k native but it can also work

00:33:54,159 --> 00:33:58,159
with um with a service mesh you know

00:33:56,320 --> 00:34:00,000
with with service mesh service mesh is a

00:33:58,159 --> 00:34:02,240
topic that they've been very involved in

00:34:00,000 --> 00:34:03,360
uh in the past year in the context of

00:34:02,240 --> 00:34:06,320
kuma

00:34:03,360 --> 00:34:08,720
uh we do support a cycle envoy proxy

00:34:06,320 --> 00:34:09,440
that allows the kang ingress to be able

00:34:08,720 --> 00:34:12,480
to

00:34:09,440 --> 00:34:14,879
perform you know gateway

00:34:12,480 --> 00:34:15,839
functionality on the ingress side and

00:34:14,879 --> 00:34:19,280
then

00:34:15,839 --> 00:34:20,800
proxy the request to a cycle envoy

00:34:19,280 --> 00:34:22,879
proxy in order to be able to provision

00:34:20,800 --> 00:34:24,399
the right mutual tls certificates that

00:34:22,879 --> 00:34:24,960
would allow the request to enter the

00:34:24,399 --> 00:34:26,480
mesh

00:34:24,960 --> 00:34:28,079
you know when we think of service mesh

00:34:26,480 --> 00:34:30,480
and we think of

00:34:28,079 --> 00:34:31,200
the concept of service mesh it's quite

00:34:30,480 --> 00:34:34,079
it's quite

00:34:31,200 --> 00:34:35,040
you know service mesh as a very flat

00:34:34,079 --> 00:34:36,720
view of the world

00:34:35,040 --> 00:34:38,399
in a service mesh world there are

00:34:36,720 --> 00:34:40,079
services and services are

00:34:38,399 --> 00:34:42,000
it can be anything that makes a request

00:34:40,079 --> 00:34:43,760
or receives a request over the network

00:34:42,000 --> 00:34:46,159
and then we're going to be having those

00:34:43,760 --> 00:34:48,480
service requests that connect

00:34:46,159 --> 00:34:49,679
these different services together in the

00:34:48,480 --> 00:34:51,359
context of service mesh

00:34:49,679 --> 00:34:53,119
any service any service that makes a

00:34:51,359 --> 00:34:54,639
request or receives a request like an

00:34:53,119 --> 00:34:57,680
api like a database like

00:34:54,639 --> 00:35:00,000
reddit's it is a service so

00:34:57,680 --> 00:35:01,359
the con gateway it's not any different

00:35:00,000 --> 00:35:02,000
from any other service that we're

00:35:01,359 --> 00:35:04,960
running in our

00:35:02,000 --> 00:35:06,480
system the con gateway will make our

00:35:04,960 --> 00:35:10,880
will receive requests

00:35:06,480 --> 00:35:12,800
and make requests so we can easily

00:35:10,880 --> 00:35:14,720
so the gateway is a service itself we

00:35:12,800 --> 00:35:18,400
can easily deploy

00:35:14,720 --> 00:35:19,920
a cycle container next to kong gateway

00:35:18,400 --> 00:35:23,359
and by default we support

00:35:19,920 --> 00:35:25,280
istio and kuma and and by default that

00:35:23,359 --> 00:35:27,119
whole flow of you know from ingress to

00:35:25,280 --> 00:35:28,720
mesh it's completely taken care of so

00:35:27,119 --> 00:35:30,400
that we don't have to worry about

00:35:28,720 --> 00:35:32,000
about setting it up because it comes out

00:35:30,400 --> 00:35:34,560
of the box with istio

00:35:32,000 --> 00:35:34,560
and humor

00:35:35,200 --> 00:35:39,200
also you know we've been working with

00:35:37,920 --> 00:35:41,520
and i've been personally involved with

00:35:39,200 --> 00:35:43,599
many service mesh use cases with larger

00:35:41,520 --> 00:35:45,280
organizations that are going to be

00:35:43,599 --> 00:35:47,040
running multiple matches for

00:35:45,280 --> 00:35:48,560
different kinds of businesses or for

00:35:47,040 --> 00:35:51,200
different teams

00:35:48,560 --> 00:35:51,760
um you know it's very it's very hard to

00:35:51,200 --> 00:35:54,640
to run

00:35:51,760 --> 00:35:55,680
one large mesh for everybody for a

00:35:54,640 --> 00:35:58,560
couple of reasons

00:35:55,680 --> 00:35:59,680
we may want to start different meshes at

00:35:58,560 --> 00:36:03,760
different times

00:35:59,680 --> 00:36:06,160
therefore um you know we don't want to

00:36:03,760 --> 00:36:07,920
enable too much we don't want to require

00:36:06,160 --> 00:36:09,520
too much team coordination if they are

00:36:07,920 --> 00:36:10,720
all working on one mesh especially if

00:36:09,520 --> 00:36:11,760
they're coming from different lines of

00:36:10,720 --> 00:36:14,640
businesses

00:36:11,760 --> 00:36:16,640
and also we want to be able to enforce

00:36:14,640 --> 00:36:17,200
more you know security or more isolation

00:36:16,640 --> 00:36:19,599
across

00:36:17,200 --> 00:36:21,280
you know across different meshes for

00:36:19,599 --> 00:36:22,640
different applications

00:36:21,280 --> 00:36:25,359
so one of the use cases that they've

00:36:22,640 --> 00:36:29,040
been seeing is using um

00:36:25,359 --> 00:36:30,880
kong as these hop in the network that

00:36:29,040 --> 00:36:31,440
would allow to exit one mesh as an

00:36:30,880 --> 00:36:34,880
egress

00:36:31,440 --> 00:36:37,520
and then enter another mesh as um

00:36:34,880 --> 00:36:38,720
in an ingress capacity and so it is

00:36:37,520 --> 00:36:40,800
basically the gateway

00:36:38,720 --> 00:36:42,000
that not only allows us to accept

00:36:40,800 --> 00:36:44,240
external traffic

00:36:42,000 --> 00:36:46,480
to come inside of the kubernetes cluster

00:36:44,240 --> 00:36:48,720
but also within the same cluster

00:36:46,480 --> 00:36:50,880
it could be used as an internal gateway

00:36:48,720 --> 00:36:53,839
that allows us to exit one mesh

00:36:50,880 --> 00:36:54,640
and then try another mesh and in between

00:36:53,839 --> 00:36:56,960
being able to

00:36:54,640 --> 00:36:58,720
enforce user policies and ap api

00:36:56,960 --> 00:36:59,520
governance policies or onboarding

00:36:58,720 --> 00:37:01,119
policies

00:36:59,520 --> 00:37:03,200
to determine how those apis are being

00:37:01,119 --> 00:37:05,040
consumed if i am in a bank

00:37:03,200 --> 00:37:06,640
working for a global bank and i'm

00:37:05,040 --> 00:37:08,240
creating a banking application

00:37:06,640 --> 00:37:09,760
and there is another team building a

00:37:08,240 --> 00:37:11,280
trading application

00:37:09,760 --> 00:37:13,119
for all intents and purposes that

00:37:11,280 --> 00:37:14,800
trading team needs to be going through

00:37:13,119 --> 00:37:16,800
an onboarding process in order to be

00:37:14,800 --> 00:37:18,720
able to access the banking api

00:37:16,800 --> 00:37:20,960
so even if we work for the same

00:37:18,720 --> 00:37:23,599
organization i still want to be able

00:37:20,960 --> 00:37:25,359
to enforce rules on how that team is

00:37:23,599 --> 00:37:27,280
going to be using my system

00:37:25,359 --> 00:37:29,920
and i want to expose just a subset of

00:37:27,280 --> 00:37:31,200
the apis not all of the apis that are

00:37:29,920 --> 00:37:33,359
running in my banking app

00:37:31,200 --> 00:37:35,680
and so the gateway use case it's perfect

00:37:33,359 --> 00:37:37,920
for this because i can put a gateway

00:37:35,680 --> 00:37:40,160
internally expose just the apis that

00:37:37,920 --> 00:37:42,000
they want the other teams to consume

00:37:40,160 --> 00:37:43,760
with no dependencies whatsoever you know

00:37:42,000 --> 00:37:45,359
when we deploy a service mesh

00:37:43,760 --> 00:37:47,359
we have a decentralized sidecar

00:37:45,359 --> 00:37:48,079
deployment that needs to be deployed

00:37:47,359 --> 00:37:51,119
alongside

00:37:48,079 --> 00:37:53,359
each one of our services and that

00:37:51,119 --> 00:37:54,400
sidecar needs to be able to consume the

00:37:53,359 --> 00:37:56,160
control plane

00:37:54,400 --> 00:37:58,400
and there is instances where i don't

00:37:56,160 --> 00:38:00,640
want we can't deploy a sidecar

00:37:58,400 --> 00:38:02,640
or we don't want the sidecar to connect

00:38:00,640 --> 00:38:04,079
to our control plane because the control

00:38:02,640 --> 00:38:06,240
pane is quite sensitive and

00:38:04,079 --> 00:38:07,440
only our services should be able to get

00:38:06,240 --> 00:38:10,640
access to it

00:38:07,440 --> 00:38:12,079
therefore i can use a gateway to exit my

00:38:10,640 --> 00:38:14,480
mesh enter another mesh

00:38:12,079 --> 00:38:15,599
or i can use a gateway to enter a mesh

00:38:14,480 --> 00:38:17,920
from the edge

00:38:15,599 --> 00:38:19,920
from a mobile client for example or from

00:38:17,920 --> 00:38:21,040
external developers that couldn't deploy

00:38:19,920 --> 00:38:22,880
a cycle

00:38:21,040 --> 00:38:25,040
anyways even if they wanted to because

00:38:22,880 --> 00:38:25,599
we don't want to require them to do that

00:38:25,040 --> 00:38:27,119
and we don't want

00:38:25,599 --> 00:38:29,760
their sidecar to talk to our control

00:38:27,119 --> 00:38:31,680
plane so anyways to answer the question

00:38:29,760 --> 00:38:33,760
yes can be used in front of any service

00:38:31,680 --> 00:38:35,760
mesh in instant human particular

00:38:33,760 --> 00:38:37,440
cognitively supports envoy as a cycle

00:38:35,760 --> 00:38:38,160
proxy because cong like any other

00:38:37,440 --> 00:38:40,800
service

00:38:38,160 --> 00:38:42,960
is a service in the service mesh and um

00:38:40,800 --> 00:38:44,960
and also cong can be used for

00:38:42,960 --> 00:38:46,079
more traditional apis as well as com can

00:38:44,960 --> 00:38:48,079
be used as a

00:38:46,079 --> 00:38:50,160
lightweight router to enable

00:38:48,079 --> 00:38:51,680
cross-cluster kubernetes communication

00:38:50,160 --> 00:38:52,560
when it comes to pretty much any traffic

00:38:51,680 --> 00:38:56,160
not just

00:38:52,560 --> 00:38:59,599
http or jrpc traffic but but um

00:38:56,160 --> 00:39:00,400
any l4 traffic so it can be um kafka can

00:38:59,599 --> 00:39:02,320
be

00:39:00,400 --> 00:39:04,800
can be my sequel can be literally

00:39:02,320 --> 00:39:06,880
anything and we have users using kong

00:39:04,800 --> 00:39:09,680
in all of these different capacities so

00:39:06,880 --> 00:39:09,680
i hope that helps

00:39:10,240 --> 00:39:17,359
um and i am going to be

00:39:14,160 --> 00:39:17,359
stop the screen share

00:39:19,119 --> 00:39:22,480
and go into the next slide so today we

00:39:21,599 --> 00:39:26,480
have looked

00:39:22,480 --> 00:39:29,599
at different ways that we can expose our

00:39:26,480 --> 00:39:32,640
services in kubernetes uh not port

00:39:29,599 --> 00:39:34,160
load balancer ingress

00:39:32,640 --> 00:39:36,240
uh we focused on the kang ingress

00:39:34,160 --> 00:39:38,079
controller uh we've seen a live demo

00:39:36,240 --> 00:39:41,280
that allows us to secure

00:39:38,079 --> 00:39:42,640
and protect and rate limit and observe

00:39:41,280 --> 00:39:45,359
all the traffic that's going through the

00:39:42,640 --> 00:39:46,480
ingress we went on a dissertation about

00:39:45,359 --> 00:39:48,800
service mesh

00:39:46,480 --> 00:39:50,160
and uh and that's all so thank you so

00:39:48,800 --> 00:39:51,359
much you can download kong at

00:39:50,160 --> 00:39:55,040
kangachi.com

00:39:51,359 --> 00:39:56,480
install i'm going to be connected for

00:39:55,040 --> 00:39:59,520
next five minutes

00:39:56,480 --> 00:40:02,160
uh just in case you have some uh

00:39:59,520 --> 00:40:03,680
additional questions otherwise you can

00:40:02,160 --> 00:40:07,200
find me online at

00:40:03,680 --> 00:40:09,599
subnet marker on twitter or you can get

00:40:07,200 --> 00:40:11,200
involved with kong and with the ingress

00:40:09,599 --> 00:40:11,680
on our community channels that you can

00:40:11,200 --> 00:40:13,760
find

00:40:11,680 --> 00:40:15,119
on on github you can find on konghq.com

00:40:13,760 --> 00:40:17,359
as well and if you're looking for a

00:40:15,119 --> 00:40:20,400
service mesh that's quite simple to use

00:40:17,359 --> 00:40:22,480
and it's vendor neutral and it's it's a

00:40:20,400 --> 00:40:25,200
cncf sandbox project

00:40:22,480 --> 00:40:26,319
you can now look at kuma.io as a matter

00:40:25,200 --> 00:40:29,119
of fact it's the first

00:40:26,319 --> 00:40:31,200
envoy based service mesh that has been

00:40:29,119 --> 00:40:32,640
donated to the cncf foundation which is

00:40:31,200 --> 00:40:35,920
a linux foundation

00:40:32,640 --> 00:40:37,040
um entity and uh and of course the

00:40:35,920 --> 00:40:39,520
english controller

00:40:37,040 --> 00:40:40,480
natively communicates with kuma and kuma

00:40:39,520 --> 00:40:42,560
uh compared to

00:40:40,480 --> 00:40:44,319
to to istio it's much simpler to use

00:40:42,560 --> 00:40:47,359
it's a turnkey service mesh

00:40:44,319 --> 00:40:49,040
um it it scales quite well

00:40:47,359 --> 00:40:51,440
across the organization by supporting

00:40:49,040 --> 00:40:53,280
multi-tenancy and multi-mesh support

00:40:51,440 --> 00:40:55,119
and it can run on top of kubernetes but

00:40:53,280 --> 00:40:56,240
also virtual machine workloads and as a

00:40:55,119 --> 00:40:59,760
matter of fact

00:40:56,240 --> 00:41:02,480
there was a new version of qma yesterday

00:40:59,760 --> 00:41:04,240
that introduces a quite quite scalable

00:41:02,480 --> 00:41:06,160
and flexible way to support multiple

00:41:04,240 --> 00:41:08,800
regions and multiple kubernetes

00:41:06,160 --> 00:41:09,920
clusters within the same mesh of course

00:41:08,800 --> 00:41:11,920
then you can put

00:41:09,920 --> 00:41:13,839
an english controller like on top of all

00:41:11,920 --> 00:41:14,640
of this so you have the full stack end

00:41:13,839 --> 00:41:17,119
to end

00:41:14,640 --> 00:41:19,440
ingress and service mesh all connected

00:41:17,119 --> 00:41:22,160
with each other

00:41:19,440 --> 00:41:22,640
um the api gateway so there is one

00:41:22,160 --> 00:41:24,960
question

00:41:22,640 --> 00:41:26,640
how different is it from istio and and

00:41:24,960 --> 00:41:27,760
this question was asked in the context

00:41:26,640 --> 00:41:30,640
of the kang ingress

00:41:27,760 --> 00:41:32,839
when i was introducing kung ingress the

00:41:30,640 --> 00:41:35,280
ingress

00:41:32,839 --> 00:41:36,000
controller an english controller like

00:41:35,280 --> 00:41:38,400
kong

00:41:36,000 --> 00:41:39,760
um it has been used in the in an api

00:41:38,400 --> 00:41:41,839
gateway capacity

00:41:39,760 --> 00:41:43,599
and so the question is you know really

00:41:41,839 --> 00:41:44,160
if we have to abstract this question

00:41:43,599 --> 00:41:45,839
away

00:41:44,160 --> 00:41:48,240
the question is what what is the

00:41:45,839 --> 00:41:49,359
difference between an api gateway and a

00:41:48,240 --> 00:41:51,200
service mesh

00:41:49,359 --> 00:41:52,960
you see the api gateway and the service

00:41:51,200 --> 00:41:55,359
mesh are different kinds of deployments

00:41:52,960 --> 00:41:56,800
service mesh allows us to so service

00:41:55,359 --> 00:41:58,720
mesh it's more low level

00:41:56,800 --> 00:41:59,839
service mesh it's more of a service

00:41:58,720 --> 00:42:01,599
connectivity concern

00:41:59,839 --> 00:42:03,440
so we want we're making requests and

00:42:01,599 --> 00:42:05,599
connecting services together

00:42:03,440 --> 00:42:07,520
within the application and we want to

00:42:05,599 --> 00:42:07,839
secure that traffic we want to encrypt

00:42:07,520 --> 00:42:10,960
it

00:42:07,839 --> 00:42:12,880
we want to be able to uh observe that

00:42:10,960 --> 00:42:14,240
traffic so within the application we're

00:42:12,880 --> 00:42:16,480
going to be deploying a mesh

00:42:14,240 --> 00:42:18,240
that does all of that now we want our

00:42:16,480 --> 00:42:20,480
application to be able to talk to other

00:42:18,240 --> 00:42:22,640
applications we want to apply

00:42:20,480 --> 00:42:24,319
user governance on how the users are

00:42:22,640 --> 00:42:26,000
accessing our system we want to be able

00:42:24,319 --> 00:42:26,880
to provide a developer portal and a

00:42:26,000 --> 00:42:30,160
catalog

00:42:26,880 --> 00:42:32,240
to enter on our api

00:42:30,160 --> 00:42:34,160
in a very specific way and we want to do

00:42:32,240 --> 00:42:35,280
that with a centralized deployment so we

00:42:34,160 --> 00:42:38,560
do not want

00:42:35,280 --> 00:42:41,040
our clients consuming apis to require

00:42:38,560 --> 00:42:41,920
a sidecar in order to be able to consume

00:42:41,040 --> 00:42:44,319
our services

00:42:41,920 --> 00:42:45,920
as we know in a service mesh a service

00:42:44,319 --> 00:42:48,240
can consume another service

00:42:45,920 --> 00:42:49,839
only if both of them have a sidecar

00:42:48,240 --> 00:42:51,839
because the sidecar will assign the

00:42:49,839 --> 00:42:54,079
right mutual tls identity

00:42:51,839 --> 00:42:56,319
to the request that allows us to make

00:42:54,079 --> 00:42:58,640
that request in the first place

00:42:56,319 --> 00:43:00,160
if we have external developers outside

00:42:58,640 --> 00:43:01,119
of the organization we don't want to

00:43:00,160 --> 00:43:04,079
require

00:43:01,119 --> 00:43:05,760
a cycle and and most importantly we do

00:43:04,079 --> 00:43:07,599
not want to require them

00:43:05,760 --> 00:43:09,119
to connect their sidecar to our control

00:43:07,599 --> 00:43:10,560
plane which is a very sensitive topic

00:43:09,119 --> 00:43:12,880
you know it's a very sensitive

00:43:10,560 --> 00:43:14,240
system in our infrastructure and so

00:43:12,880 --> 00:43:14,800
we're going to be having an abstraction

00:43:14,240 --> 00:43:17,040
layer

00:43:14,800 --> 00:43:17,920
an api gateway deployed in an ingress

00:43:17,040 --> 00:43:20,160
capacity

00:43:17,920 --> 00:43:21,520
that can perform that can allow anybody

00:43:20,160 --> 00:43:23,440
to consume our services

00:43:21,520 --> 00:43:26,480
it can perform user onboarding and user

00:43:23,440 --> 00:43:28,720
governance in a centralized way

00:43:26,480 --> 00:43:30,560
it exposes only a subset of the apis

00:43:28,720 --> 00:43:33,680
that you want them to consume

00:43:30,560 --> 00:43:35,839
and then the ingress will enter the mesh

00:43:33,680 --> 00:43:37,359
to process that request and you know

00:43:35,839 --> 00:43:38,319
quite frankly the tracing and the

00:43:37,359 --> 00:43:40,160
observability

00:43:38,319 --> 00:43:42,079
aspects of them can be federated

00:43:40,160 --> 00:43:42,880
together so that we can trace and

00:43:42,079 --> 00:43:46,079
observe

00:43:42,880 --> 00:43:47,119
this entire flow from ingress to service

00:43:46,079 --> 00:43:49,599
mesh

00:43:47,119 --> 00:43:51,119
um you know with with a very tight

00:43:49,599 --> 00:43:53,440
integration in the case of kong

00:43:51,119 --> 00:43:55,920
that integration is withio and with

00:43:53,440 --> 00:43:55,920
cumin

00:43:56,640 --> 00:44:00,560
there is another question can you help

00:43:59,359 --> 00:44:04,240
talk more about

00:44:00,560 --> 00:44:08,160
how kong connect to different meshes

00:44:04,240 --> 00:44:10,480
you see we can use kong as an ingress

00:44:08,160 --> 00:44:11,440
to a mesh but we can also use kong as an

00:44:10,480 --> 00:44:14,880
egress

00:44:11,440 --> 00:44:17,599
from a mesh so if you want to

00:44:14,880 --> 00:44:19,040
so first and foremost exiting one mesh

00:44:17,599 --> 00:44:20,560
and entering another mesh

00:44:19,040 --> 00:44:23,040
means that we are going to be

00:44:20,560 --> 00:44:25,520
provisioning the right mutual tls

00:44:23,040 --> 00:44:27,119
certificates that allow us to exit the

00:44:25,520 --> 00:44:28,720
mesh and then enter another mesh

00:44:27,119 --> 00:44:31,680
which is most likely going to be secured

00:44:28,720 --> 00:44:33,760
with a different certificate authority

00:44:31,680 --> 00:44:37,839
so what the ingress does what kung do in

00:44:33,760 --> 00:44:40,640
this case it allows us to

00:44:37,839 --> 00:44:41,680
to funnel the egress requests through

00:44:40,640 --> 00:44:44,240
the gateway

00:44:41,680 --> 00:44:45,200
and then the gateway with that our envoy

00:44:44,240 --> 00:44:48,480
integration

00:44:45,200 --> 00:44:51,280
will reprovision the mutual tls

00:44:48,480 --> 00:44:51,760
to enter the other mesh so effectively

00:44:51,280 --> 00:44:53,839
the

00:44:51,760 --> 00:44:55,760
the gateway really is this hop in the

00:44:53,839 --> 00:44:58,640
network that allows us

00:44:55,760 --> 00:44:59,839
allows us to um to exit one mesh and

00:44:58,640 --> 00:45:01,280
enter another mesh i want to show you

00:44:59,839 --> 00:45:02,160
something there is a blog post that i've

00:45:01,280 --> 00:45:04,079
written

00:45:02,160 --> 00:45:05,599
uh a while ago and it is about the

00:45:04,079 --> 00:45:06,960
difference between api gateways and

00:45:05,599 --> 00:45:08,800
service mesh so i'm going to be showing

00:45:06,960 --> 00:45:10,319
my screen just real quick

00:45:08,800 --> 00:45:12,000
uh this is the blog post that i've

00:45:10,319 --> 00:45:14,079
written and uh

00:45:12,000 --> 00:45:15,280
and you know here i'm talking about the

00:45:14,079 --> 00:45:15,839
difference between gateways the

00:45:15,280 --> 00:45:17,760
different

00:45:15,839 --> 00:45:19,040
the difference between service mesh but

00:45:17,760 --> 00:45:22,400
most importantly

00:45:19,040 --> 00:45:25,440
at the end i also show an example on how

00:45:22,400 --> 00:45:28,480
a gateway can be used to enter and

00:45:25,440 --> 00:45:32,079
exit different different meshes

00:45:28,480 --> 00:45:32,960
so this is um this is a very nice

00:45:32,079 --> 00:45:34,880
explanation

00:45:32,960 --> 00:45:36,240
the blog it's called uh the difference

00:45:34,880 --> 00:45:38,240
between an api gateway and a service

00:45:36,240 --> 00:45:39,920
mesh that i strongly suggest to read

00:45:38,240 --> 00:45:41,359
because it really clears all of these

00:45:39,920 --> 00:45:45,040
all of these up

00:45:41,359 --> 00:45:49,280
um and in cuma was the cumin is the

00:45:45,040 --> 00:45:52,000
cognitive um the cncf

00:45:49,280 --> 00:45:53,040
only envoy-based service mesh donated to

00:45:52,000 --> 00:45:55,680
the foundation

00:45:53,040 --> 00:45:57,440
that we can use out of the box to create

00:45:55,680 --> 00:45:58,400
a mesh and then integrate it with a

00:45:57,440 --> 00:46:00,720
gateway.com

00:45:58,400 --> 00:46:02,319
and you know kuma like kong in congo

00:46:00,720 --> 00:46:03,680
with plugins in cuba we have policies

00:46:02,319 --> 00:46:04,880
that do all sorts of things and there is

00:46:03,680 --> 00:46:06,160
an integration with cong

00:46:04,880 --> 00:46:08,079
and of course we welcome more

00:46:06,160 --> 00:46:10,319
integrations with other gateways

00:46:08,079 --> 00:46:11,200
um if if anybody wants to contribute to

00:46:10,319 --> 00:46:14,400
them

00:46:11,200 --> 00:46:16,880
um yeah so i strongly suggest reading

00:46:14,400 --> 00:46:19,839
reading the uh this blog post uh then

00:46:16,880 --> 00:46:19,839
there is another question

00:46:21,200 --> 00:46:23,520
um

00:46:24,640 --> 00:46:30,319
would would english controller uh be

00:46:28,160 --> 00:46:31,520
a compliment or replacement for the open

00:46:30,319 --> 00:46:32,800
open shift for

00:46:31,520 --> 00:46:34,960
ingress controller it would be a

00:46:32,800 --> 00:46:36,720
replacement uh with kong

00:46:34,960 --> 00:46:38,000
we are getting an a replacement of an

00:46:36,720 --> 00:46:40,000
ingress controller it's a different

00:46:38,000 --> 00:46:41,599
implementation that supports l4 and l7

00:46:40,000 --> 00:46:42,319
it supports sk native out of the box it

00:46:41,599 --> 00:46:44,640
supports

00:46:42,319 --> 00:46:46,560
api full cycle api management really and

00:46:44,640 --> 00:46:49,440
it also allows us to exit and enter

00:46:46,560 --> 00:46:49,920
different service meshes um built in

00:46:49,440 --> 00:46:52,160
either

00:46:49,920 --> 00:46:54,800
on top of istio or kuma within our

00:46:52,160 --> 00:46:58,400
system so it's it's quite feature rich

00:46:54,800 --> 00:47:00,480
it's quite performant and it can cover

00:46:58,400 --> 00:47:01,760
pretty much all the use cases that

00:47:00,480 --> 00:47:03,280
normally we would need

00:47:01,760 --> 00:47:05,280
when deploying when deploying an english

00:47:03,280 --> 00:47:06,560
controller so i strongly suggest

00:47:05,280 --> 00:47:08,319
to give it a try and there is a very

00:47:06,560 --> 00:47:09,599
vibrant open source community that can

00:47:08,319 --> 00:47:11,280
also help

00:47:09,599 --> 00:47:14,560
if if you get stuck or if you have

00:47:11,280 --> 00:47:14,560
feedback or if you have questions

00:47:15,119 --> 00:47:18,319
there's another question can you

00:47:16,400 --> 00:47:20,079
integrate with a

00:47:18,319 --> 00:47:22,079
certificate manager or do you have your

00:47:20,079 --> 00:47:24,720
own acme certificate

00:47:22,079 --> 00:47:26,079
management controller um it can connect

00:47:24,720 --> 00:47:27,839
with

00:47:26,079 --> 00:47:29,359
it can provision its own certificates

00:47:27,839 --> 00:47:30,960
you can provision con

00:47:29,359 --> 00:47:32,800
english controller with your own

00:47:30,960 --> 00:47:34,480
certificates uh we also have

00:47:32,800 --> 00:47:36,880
integrations with ashley corp vault if

00:47:34,480 --> 00:47:39,440
you want to support a third party pki

00:47:36,880 --> 00:47:40,160
so i i strongly suggest to look at the

00:47:39,440 --> 00:47:41,599
plugins

00:47:40,160 --> 00:47:43,280
because they provide the different

00:47:41,599 --> 00:47:44,640
different ways to configure these

00:47:43,280 --> 00:47:46,319
all these different aspects and of

00:47:44,640 --> 00:47:46,800
course the official documentation by the

00:47:46,319 --> 00:47:48,640
way

00:47:46,800 --> 00:47:50,319
you can you we we can find that on kung

00:47:48,640 --> 00:47:52,640
hq dot com docs

00:47:50,319 --> 00:47:54,319
so that covers pretty much all all the

00:47:52,640 --> 00:47:57,520
different security use cases

00:47:54,319 --> 00:47:59,440
we can not only secure with mutual tls

00:47:57,520 --> 00:48:01,200
and encrypt everything that goes through

00:47:59,440 --> 00:48:03,599
the ingress we can also

00:48:01,200 --> 00:48:05,440
integrate the mutual gls of the ingress

00:48:03,599 --> 00:48:09,760
with a third party service mesh

00:48:05,440 --> 00:48:12,720
we can also install on top of mutual gls

00:48:09,760 --> 00:48:14,400
about 10 plus different authentication

00:48:12,720 --> 00:48:16,480
and authorization plugins

00:48:14,400 --> 00:48:18,319
like openldconnect jot tokens you know

00:48:16,480 --> 00:48:20,559
hmac api

00:48:18,319 --> 00:48:21,920
api keys is one of them and basic

00:48:20,559 --> 00:48:22,960
authentication you know it's quite

00:48:21,920 --> 00:48:25,839
complex

00:48:22,960 --> 00:48:27,200
uh on top of on top of kong and so we

00:48:25,839 --> 00:48:28,079
can also have different plugins for

00:48:27,200 --> 00:48:29,760
different services

00:48:28,079 --> 00:48:31,119
which is pretty cool that means if we

00:48:29,760 --> 00:48:32,480
have many different services

00:48:31,119 --> 00:48:35,040
in our running in our kubernetes

00:48:32,480 --> 00:48:37,280
clusters we can secure some of them

00:48:35,040 --> 00:48:39,200
with open id connect we can secure them

00:48:37,280 --> 00:48:41,599
some of them with mutual tls only

00:48:39,200 --> 00:48:42,480
we can secure some of them with api key

00:48:41,599 --> 00:48:44,720
only

00:48:42,480 --> 00:48:45,520
so it is quite flexible on how we can

00:48:44,720 --> 00:48:48,640
manage

00:48:45,520 --> 00:48:52,480
this entire this entire system um and

00:48:48,640 --> 00:48:54,400
you know also you know something that

00:48:52,480 --> 00:48:56,000
you know makes me very proud about kong

00:48:54,400 --> 00:48:57,520
kung is being used by hundreds of

00:48:56,000 --> 00:48:59,119
enterprise organizations in production

00:48:57,520 --> 00:49:00,240
information critical workloads so when

00:48:59,119 --> 00:49:01,920
we're looking at kong

00:49:00,240 --> 00:49:03,760
we're not just looking at an open source

00:49:01,920 --> 00:49:04,400
ingress or gateway that does all of

00:49:03,760 --> 00:49:07,440
these things

00:49:04,400 --> 00:49:09,760
but we're looking at an enterprise grade

00:49:07,440 --> 00:49:10,880
gateway that really can run in in all of

00:49:09,760 --> 00:49:12,240
these capacities

00:49:10,880 --> 00:49:14,640
in pretty much any enterprise

00:49:12,240 --> 00:49:16,960
environment so conga can also sync up

00:49:14,640 --> 00:49:17,599
for example a very a more complex use

00:49:16,960 --> 00:49:19,839
case

00:49:17,599 --> 00:49:21,200
would be being able to manage multiple

00:49:19,839 --> 00:49:22,800
cons account different

00:49:21,200 --> 00:49:24,480
across different kubernetes clusters

00:49:22,800 --> 00:49:27,280
across different clouds

00:49:24,480 --> 00:49:28,400
and for example integrate all of this

00:49:27,280 --> 00:49:31,280
with a

00:49:28,400 --> 00:49:31,599
with an on-premise data center kong can

00:49:31,280 --> 00:49:35,200
do

00:49:31,599 --> 00:49:37,200
all of the above so this demo today was

00:49:35,200 --> 00:49:38,960
quite simple but kong supports all of

00:49:37,200 --> 00:49:41,599
these bones as a matter of fact

00:49:38,960 --> 00:49:43,200
um it's it's quite of a portable system

00:49:41,599 --> 00:49:45,520
and kuma the service mesh that we

00:49:43,200 --> 00:49:47,280
that we are also contributing to it's

00:49:45,520 --> 00:49:48,640
also quite portable it's a service mesh

00:49:47,280 --> 00:49:49,680
that can run on service mesh and

00:49:48,640 --> 00:49:52,559
kubernetes

00:49:49,680 --> 00:49:52,960
and we can integrate both both together

00:49:52,559 --> 00:49:54,640
by

00:49:52,960 --> 00:49:56,319
abstracting away the service to service

00:49:54,640 --> 00:49:57,040
connectivity between a virtual machine

00:49:56,319 --> 00:49:59,200
workload

00:49:57,040 --> 00:50:00,480
and a kubernetes workload so if if

00:49:59,200 --> 00:50:01,599
you're looking for a service mesh that

00:50:00,480 --> 00:50:03,599
can span across

00:50:01,599 --> 00:50:05,119
all of your environments i also suggest

00:50:03,599 --> 00:50:07,040
looking at kuma it seems like we're

00:50:05,119 --> 00:50:10,960
coming up

00:50:07,040 --> 00:50:13,760
at the top of uh of my

00:50:10,960 --> 00:50:15,200
time so again if you have any questions

00:50:13,760 --> 00:50:17,040
i'll be happy to answer them

00:50:15,200 --> 00:50:18,319
online you can find me on twitter you

00:50:17,040 --> 00:50:20,400
can find me on github

00:50:18,319 --> 00:50:21,599
so keep keep them coming thank you so

00:50:20,400 --> 00:50:24,880
much for coming

00:50:21,599 --> 00:50:27,359
um to my talk and i hope all of these

00:50:24,880 --> 00:50:28,720
is a clear and exciting enough for you

00:50:27,359 --> 00:50:29,200
so that you can get up and running with

00:50:28,720 --> 00:50:31,520
it

00:50:29,200 --> 00:50:33,200
um you know very easily so thank you so

00:50:31,520 --> 00:50:36,480
much uh you can find kong

00:50:33,200 --> 00:50:39,520
at again kongkhi.com i'll

00:50:36,480 --> 00:50:41,839
um i'll see you online

00:50:39,520 --> 00:50:41,839

YouTube URL: https://www.youtube.com/watch?v=eTimEL2vu-Y


