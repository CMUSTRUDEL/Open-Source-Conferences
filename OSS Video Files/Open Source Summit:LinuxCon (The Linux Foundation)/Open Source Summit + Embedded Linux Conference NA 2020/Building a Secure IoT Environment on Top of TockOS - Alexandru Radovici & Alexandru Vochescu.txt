Title: Building a Secure IoT Environment on Top of TockOS - Alexandru Radovici & Alexandru Vochescu
Publication date: 2020-09-10
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	Building a Secure IoT Environment on Top of TockOS - Alexandru Radovici & Alexandru Vochescu, Politehnica University of Bucharest
Captions: 
	00:00:02,560 --> 00:00:06,799
hello everybody

00:00:03,679 --> 00:00:08,559
thank you for joining this talk um we

00:00:06,799 --> 00:00:11,519
are going to present tokos

00:00:08,559 --> 00:00:13,599
which is um an embedded operating system

00:00:11,519 --> 00:00:16,880
fully written in rust

00:00:13,599 --> 00:00:19,439
uh first of all a few words about us

00:00:16,880 --> 00:00:20,400
we are alex and alex myself alexander

00:00:19,439 --> 00:00:21,920
radovic

00:00:20,400 --> 00:00:24,080
i'm an assistant professor at the

00:00:21,920 --> 00:00:27,199
polytechnic university in bucharest

00:00:24,080 --> 00:00:29,599
my field of expertise is in operating

00:00:27,199 --> 00:00:31,840
systems and compilers

00:00:29,599 --> 00:00:32,960
i'm here together with alex my student

00:00:31,840 --> 00:00:34,800
um

00:00:32,960 --> 00:00:36,960
he's just graduated today with his

00:00:34,800 --> 00:00:39,040
bachelor's degree in engineering

00:00:36,960 --> 00:00:40,879
and his project was presenting his

00:00:39,040 --> 00:00:42,000
contributions to tocques just this

00:00:40,879 --> 00:00:44,480
morning

00:00:42,000 --> 00:00:46,320
uh i'm sorry if you have if you're

00:00:44,480 --> 00:00:49,360
making a bit of mistakes or if something

00:00:46,320 --> 00:00:52,480
is not clear it's 12 a.m in romania so

00:00:49,360 --> 00:00:55,760
it was a long day for us

00:00:52,480 --> 00:00:58,079
okay so um about half a year ago uh

00:00:55,760 --> 00:01:00,000
i was searching for interesting projects

00:00:58,079 --> 00:01:01,440
they were written in rust

00:01:00,000 --> 00:01:03,600
because of my interest in operating

00:01:01,440 --> 00:01:06,640
systems and system programming

00:01:03,600 --> 00:01:09,360
and i stumbled upon tokos

00:01:06,640 --> 00:01:10,960
tokos is a new embedded operating system

00:01:09,360 --> 00:01:14,000
which runs

00:01:10,960 --> 00:01:17,360
several applications concurrently on low

00:01:14,000 --> 00:01:19,520
power and low memory microcontrollers

00:01:17,360 --> 00:01:20,479
this is somehow very interesting because

00:01:19,520 --> 00:01:22,560
it borrows

00:01:20,479 --> 00:01:23,520
more or less the architecture of linux

00:01:22,560 --> 00:01:26,400
but uh

00:01:23,520 --> 00:01:27,040
applied to microcontrollers i'm not the

00:01:26,400 --> 00:01:30,079
creator

00:01:27,040 --> 00:01:31,200
i'm not affiliated topquest i just love

00:01:30,079 --> 00:01:33,280
the project and

00:01:31,200 --> 00:01:36,479
we me and my team contributed to it for

00:01:33,280 --> 00:01:36,479
the last six months

00:01:37,119 --> 00:01:41,200
okay so a few facts about talk os it's a

00:01:39,520 --> 00:01:44,320
preemptive operating system

00:01:41,200 --> 00:01:46,479
it was designed for cortex-m's mcus and

00:01:44,320 --> 00:01:48,159
then it has been ported to risk five

00:01:46,479 --> 00:01:50,079
because it's really a growing

00:01:48,159 --> 00:01:52,320
architecture and as we saw in the

00:01:50,079 --> 00:01:55,280
keynote more and more

00:01:52,320 --> 00:01:57,040
institutions are using risk five what

00:01:55,280 --> 00:01:59,119
makes it really different from other

00:01:57,040 --> 00:02:01,119
embedded operating systems that

00:01:59,119 --> 00:02:03,040
i have worked with it uses memory

00:02:01,119 --> 00:02:05,920
protection out of the box

00:02:03,040 --> 00:02:06,960
so if your mcu knows or has a memory

00:02:05,920 --> 00:02:10,080
protection unit

00:02:06,960 --> 00:02:12,720
your applications will have to obey it

00:02:10,080 --> 00:02:14,480
by default uh in the other operating

00:02:12,720 --> 00:02:17,120
systems that i've worked with this was

00:02:14,480 --> 00:02:18,720
an extra step that had to be taken

00:02:17,120 --> 00:02:20,840
uh it borrows a lot from the

00:02:18,720 --> 00:02:22,640
architecture of general operating

00:02:20,840 --> 00:02:25,360
systems the kernel

00:02:22,640 --> 00:02:28,160
is fully written in rust and is compiled

00:02:25,360 --> 00:02:30,480
completely separate from the user space

00:02:28,160 --> 00:02:32,160
um and applications are compiled

00:02:30,480 --> 00:02:33,920
separately so you don't need the kernel

00:02:32,160 --> 00:02:35,519
to compile an app

00:02:33,920 --> 00:02:37,680
applications could be written in any

00:02:35,519 --> 00:02:39,840
language like c or rust or

00:02:37,680 --> 00:02:40,879
anything that could compile uh to a

00:02:39,840 --> 00:02:43,760
binary

00:02:40,879 --> 00:02:46,720
and anything that supports position

00:02:43,760 --> 00:02:46,720
independent code

00:02:48,239 --> 00:02:51,840
before we dive in into tocques

00:02:50,640 --> 00:02:54,400
components

00:02:51,840 --> 00:02:54,879
um i want to talk to you about a little

00:02:54,400 --> 00:02:57,920
bit about

00:02:54,879 --> 00:03:00,000
rust rust is a systems programming

00:02:57,920 --> 00:03:02,720
language designed by mozilla

00:03:00,000 --> 00:03:03,519
its main purpose is to offer memory

00:03:02,720 --> 00:03:06,080
safety

00:03:03,519 --> 00:03:07,200
without the penalty of having a garbage

00:03:06,080 --> 00:03:09,440
collector

00:03:07,200 --> 00:03:11,680
and rust uses the borrow checker at

00:03:09,440 --> 00:03:14,800
compile time for this and ownership

00:03:11,680 --> 00:03:16,000
so basically programmers have to obey a

00:03:14,800 --> 00:03:19,040
lot of rules

00:03:16,000 --> 00:03:21,200
at compilation time um imagine like it's

00:03:19,040 --> 00:03:22,879
like having a language like java or

00:03:21,200 --> 00:03:26,400
net but without the overhead of a

00:03:22,879 --> 00:03:28,159
garbage collection or of a runtime

00:03:26,400 --> 00:03:30,239
due to the fact that it was designed as

00:03:28,159 --> 00:03:32,640
a systems programming language

00:03:30,239 --> 00:03:35,040
um from time to time when you're writing

00:03:32,640 --> 00:03:36,720
uh operating systems you have to access

00:03:35,040 --> 00:03:38,799
direct memory addresses or

00:03:36,720 --> 00:03:40,000
you have to directly do some pointer

00:03:38,799 --> 00:03:42,640
arithmetics

00:03:40,000 --> 00:03:44,799
or you need to do some unsafe typecasts

00:03:42,640 --> 00:03:46,799
these are generally forbidden in rust

00:03:44,799 --> 00:03:48,480
except that rust provides a keyword

00:03:46,799 --> 00:03:51,360
which is called unsafe

00:03:48,480 --> 00:03:53,760
and inside this unsafe block uh the

00:03:51,360 --> 00:03:55,840
compiler will not check memory safety

00:03:53,760 --> 00:03:57,120
so you as a programmer are allowed to do

00:03:55,840 --> 00:03:58,879
whatever you want so

00:03:57,120 --> 00:04:01,280
it's like programming in c and c plus

00:03:58,879 --> 00:04:05,120
plus inside of rust

00:04:01,280 --> 00:04:06,720
uh having said this um the tokus kernel

00:04:05,120 --> 00:04:08,799
is completely written in rust

00:04:06,720 --> 00:04:10,400
it's made out of two components the

00:04:08,799 --> 00:04:11,599
lower part which is the hardware

00:04:10,400 --> 00:04:14,159
abstraction layer

00:04:11,599 --> 00:04:16,160
this is where you write platform

00:04:14,159 --> 00:04:18,000
dependent codes and small drivers that

00:04:16,160 --> 00:04:20,479
interact with the hardware

00:04:18,000 --> 00:04:21,759
this part of the kernel does have some

00:04:20,479 --> 00:04:25,440
unsafe code because

00:04:21,759 --> 00:04:27,360
it's not possible to write it otherwise

00:04:25,440 --> 00:04:29,360
on the top of on the top part of the

00:04:27,360 --> 00:04:31,040
kernel we have the capsules

00:04:29,360 --> 00:04:33,040
these are the drivers it's just a

00:04:31,040 --> 00:04:35,199
different name for drivers

00:04:33,040 --> 00:04:36,400
uh these drivers are completely hardware

00:04:35,199 --> 00:04:37,840
independent so

00:04:36,400 --> 00:04:40,400
um they should work on any

00:04:37,840 --> 00:04:40,720
microcontroller they are not allowed to

00:04:40,400 --> 00:04:43,040
use

00:04:40,720 --> 00:04:45,040
the unsafe keyword so the compiler will

00:04:43,040 --> 00:04:47,120
not compile the capsule and not compile

00:04:45,040 --> 00:04:47,600
the kernel if inside the capsule you

00:04:47,120 --> 00:04:50,960
have an

00:04:47,600 --> 00:04:52,160
unsafe keyword they still reside inside

00:04:50,960 --> 00:04:53,919
the kernel and they

00:04:52,160 --> 00:04:56,160
talk to the lower part of the kernel

00:04:53,919 --> 00:04:57,680
through the hardware interface layer

00:04:56,160 --> 00:04:59,600
on top of the kernel we have the

00:04:57,680 --> 00:05:01,840
applications these are written in

00:04:59,600 --> 00:05:04,240
any programming language and they talk

00:05:01,840 --> 00:05:06,160
to the kernel using the system calls

00:05:04,240 --> 00:05:08,080
and interface with the capsules like

00:05:06,160 --> 00:05:10,240
that

00:05:08,080 --> 00:05:11,680
a better illustration of what i said is

00:05:10,240 --> 00:05:15,120
this picture which is

00:05:11,680 --> 00:05:16,960
uh from tokos's github on the lower part

00:05:15,120 --> 00:05:18,560
we have the hardware the microcontroller

00:05:16,960 --> 00:05:20,880
with all the peripherals

00:05:18,560 --> 00:05:22,720
the orange part are the drivers that are

00:05:20,880 --> 00:05:25,680
specific to each architecture

00:05:22,720 --> 00:05:27,840
so interfacing the spi the i square c

00:05:25,680 --> 00:05:29,600
the timers which are completely specific

00:05:27,840 --> 00:05:33,039
to any microcontrollers

00:05:29,600 --> 00:05:35,759
this part has untrust unsafe code

00:05:33,039 --> 00:05:37,199
um the tokus team has done great efforts

00:05:35,759 --> 00:05:39,759
to minimize the number of

00:05:37,199 --> 00:05:43,120
unsafe lines that are written here but

00:05:39,759 --> 00:05:44,880
there's no other way to do it

00:05:43,120 --> 00:05:46,720
on top of this you have the kernel the

00:05:44,880 --> 00:05:47,759
actual kernel which handles memory

00:05:46,720 --> 00:05:50,160
allocation

00:05:47,759 --> 00:05:51,520
scheduling and provides a hardware

00:05:50,160 --> 00:05:54,639
interface layer

00:05:51,520 --> 00:05:56,319
this still has some unsafe code

00:05:54,639 --> 00:05:58,479
and on the upper side of the kernel you

00:05:56,319 --> 00:05:59,039
have the capsules which interact with

00:05:58,479 --> 00:06:02,240
each other

00:05:59,039 --> 00:06:05,120
provide an api towards the application

00:06:02,240 --> 00:06:06,000
and use the lower capsules through the

00:06:05,120 --> 00:06:08,880
hardware interface

00:06:06,000 --> 00:06:09,600
layer these capsules cannot use unsafe

00:06:08,880 --> 00:06:11,680
code

00:06:09,600 --> 00:06:13,039
so they are guaranteed at compile time

00:06:11,680 --> 00:06:14,800
that capsules cannot

00:06:13,039 --> 00:06:16,319
write into each other's memory and

00:06:14,800 --> 00:06:19,600
cannot influence each other

00:06:16,319 --> 00:06:22,400
in a way that it shouldn't be desired um

00:06:19,600 --> 00:06:24,479
yes the top s kernel still has some

00:06:22,400 --> 00:06:25,440
unsafe code which is like writing code

00:06:24,479 --> 00:06:27,440
in c

00:06:25,440 --> 00:06:29,199
but compared to other embedded operating

00:06:27,440 --> 00:06:32,080
systems uh where you have

00:06:29,199 --> 00:06:33,199
tens of thousands of lines of kind of

00:06:32,080 --> 00:06:35,360
unsafe code

00:06:33,199 --> 00:06:36,319
in topquest you have a small number of

00:06:35,360 --> 00:06:39,680
lines that have to

00:06:36,319 --> 00:06:41,520
be audited manually on top of the kernel

00:06:39,680 --> 00:06:44,000
in this example you can see a c

00:06:41,520 --> 00:06:45,840
application a rasta application

00:06:44,000 --> 00:06:48,000
a service which could be written in any

00:06:45,840 --> 00:06:49,360
language and an application that tries

00:06:48,000 --> 00:06:51,599
to bring down the kernel

00:06:49,360 --> 00:06:52,479
by doing some infinite loop but because

00:06:51,599 --> 00:06:54,960
of rust

00:06:52,479 --> 00:06:58,319
octopuses protection this is really

00:06:54,960 --> 00:07:00,720
difficult for an application

00:06:58,319 --> 00:07:02,000
so why did i start why did you start

00:07:00,720 --> 00:07:03,440
contributing to the project

00:07:02,000 --> 00:07:05,599
and why did we find it really

00:07:03,440 --> 00:07:06,160
interesting uh well these are the three

00:07:05,599 --> 00:07:08,960
things

00:07:06,160 --> 00:07:10,479
uh first of all um it's the first

00:07:08,960 --> 00:07:11,599
embedded operating system that i see

00:07:10,479 --> 00:07:14,720
that is completely

00:07:11,599 --> 00:07:16,639
asynchronous so while applications can

00:07:14,720 --> 00:07:18,240
be preempted the kernel cannot be

00:07:16,639 --> 00:07:21,120
preempted so a driver

00:07:18,240 --> 00:07:22,880
cannot make an infinite loop or a driver

00:07:21,120 --> 00:07:25,599
cannot use a delay function

00:07:22,880 --> 00:07:26,400
so if it needs to wait for a peripheral

00:07:25,599 --> 00:07:29,599
it needs to

00:07:26,400 --> 00:07:30,319
issue an action to the peripheral give

00:07:29,599 --> 00:07:32,319
up

00:07:30,319 --> 00:07:34,160
the processor for an application and

00:07:32,319 --> 00:07:36,160
whenever the peripheral finishes

00:07:34,160 --> 00:07:38,560
it will signal the capsule via an

00:07:36,160 --> 00:07:42,160
interrupt and the capsule can continue

00:07:38,560 --> 00:07:44,639
um this is like a comparison would be

00:07:42,160 --> 00:07:45,280
tokus is for embedded operating systems

00:07:44,639 --> 00:07:48,319
like what

00:07:45,280 --> 00:07:50,080
node.js is for programming languages so

00:07:48,319 --> 00:07:52,479
it's completely asynchronous

00:07:50,080 --> 00:07:55,199
in linux the equivalent in user space

00:07:52,479 --> 00:07:58,240
would be the async io

00:07:55,199 --> 00:07:59,680
another interesting fact is that heap is

00:07:58,240 --> 00:08:02,000
not available to the kernel

00:07:59,680 --> 00:08:03,520
so all the buffers that are available in

00:08:02,000 --> 00:08:06,560
the kernel have to be known

00:08:03,520 --> 00:08:08,879
at compile time and this

00:08:06,560 --> 00:08:09,599
this gives us a lot of security because

00:08:08,879 --> 00:08:12,000
um

00:08:09,599 --> 00:08:13,520
the kernel cannot overflow memory

00:08:12,000 --> 00:08:16,879
because all the memory

00:08:13,520 --> 00:08:18,879
space is known before but um

00:08:16,879 --> 00:08:21,280
it does create a problem when writing

00:08:18,879 --> 00:08:23,039
drivers because some drivers really need

00:08:21,280 --> 00:08:25,360
to allocate some memory to store

00:08:23,039 --> 00:08:28,160
information about applications

00:08:25,360 --> 00:08:30,080
um this is handled through grants and

00:08:28,160 --> 00:08:34,640
i'll talk about grants a little bit

00:08:30,080 --> 00:08:38,000
later uh turquoise is rather new

00:08:34,640 --> 00:08:40,080
they started in 2014. boys that are

00:08:38,000 --> 00:08:42,080
supported in tokos i divided in three

00:08:40,080 --> 00:08:44,320
categories the stable category

00:08:42,080 --> 00:08:45,920
and these boards are fully supported all

00:08:44,320 --> 00:08:47,360
the peripherals work

00:08:45,920 --> 00:08:49,200
so if you just want to build some

00:08:47,360 --> 00:08:50,959
applications on top os

00:08:49,200 --> 00:08:52,959
i would strongly recommend using these

00:08:50,959 --> 00:08:56,080
boards the second category

00:08:52,959 --> 00:08:58,480
is developmental boards these boards are

00:08:56,080 --> 00:09:00,320
uh partially work but there are still

00:08:58,480 --> 00:09:01,600
some peripherals and some functions that

00:09:00,320 --> 00:09:03,839
are not available

00:09:01,600 --> 00:09:06,240
this is where i had a contribution by

00:09:03,839 --> 00:09:09,279
submitting the stm discovery boards and

00:09:06,240 --> 00:09:12,320
alex submitted the imx uh

00:09:09,279 --> 00:09:13,839
imxrt board um if you want to develop

00:09:12,320 --> 00:09:14,399
talk os and play a little bit with the

00:09:13,839 --> 00:09:16,000
kernel

00:09:14,399 --> 00:09:17,920
uh these are the boards that i would

00:09:16,000 --> 00:09:20,080
recommend as well

00:09:17,920 --> 00:09:22,320
and there is also experimental boards

00:09:20,080 --> 00:09:23,120
mostly risk 5 architecture because it's

00:09:22,320 --> 00:09:26,240
rather new

00:09:23,120 --> 00:09:28,640
in tokus um these boards work but do

00:09:26,240 --> 00:09:30,560
expect some failures or some memory

00:09:28,640 --> 00:09:32,080
problems or some running problems with

00:09:30,560 --> 00:09:35,279
these boards

00:09:32,080 --> 00:09:37,600
um okay uh

00:09:35,279 --> 00:09:39,279
tokus has been getting some momentum and

00:09:37,600 --> 00:09:41,760
people are starting to look at it

00:09:39,279 --> 00:09:42,720
um google has decided to use tokos for

00:09:41,760 --> 00:09:45,519
opensk

00:09:42,720 --> 00:09:47,760
opensk is a project from google where

00:09:45,519 --> 00:09:49,040
you could build an usb stick for digital

00:09:47,760 --> 00:09:51,120
signatures

00:09:49,040 --> 00:09:53,680
um and there's a great effort from the

00:09:51,120 --> 00:09:55,360
topwise developers to port os and fully

00:09:53,680 --> 00:09:57,760
support open titan

00:09:55,360 --> 00:09:58,399
open titan is a project that wants to

00:09:57,760 --> 00:10:02,079
provide

00:09:58,399 --> 00:10:02,480
an open source uh silicon root of trust

00:10:02,079 --> 00:10:04,720
for

00:10:02,480 --> 00:10:05,680
um signature and encryption chips that

00:10:04,720 --> 00:10:08,079
you will find in

00:10:05,680 --> 00:10:10,399
the new appliances and computers it's a

00:10:08,079 --> 00:10:13,040
consortium of several companies

00:10:10,399 --> 00:10:13,839
and um i really think tocques is a

00:10:13,040 --> 00:10:16,560
really good

00:10:13,839 --> 00:10:16,560
option for it

00:10:17,200 --> 00:10:21,440
so a little bit about applications um as

00:10:20,000 --> 00:10:23,120
i said applications are

00:10:21,440 --> 00:10:24,880
compiled out of three so you don't need

00:10:23,120 --> 00:10:26,000
the kernel of tokus to compile an

00:10:24,880 --> 00:10:27,920
application

00:10:26,000 --> 00:10:29,120
they compile it with standalone binary

00:10:27,920 --> 00:10:31,839
it's not an alpha file

00:10:29,120 --> 00:10:33,519
and we'll see that further on if the

00:10:31,839 --> 00:10:35,680
microcontroller does have a memory

00:10:33,519 --> 00:10:37,839
protection unit the application will

00:10:35,680 --> 00:10:39,519
have to obey it so whenever the kernel

00:10:37,839 --> 00:10:41,120
switches to an application

00:10:39,519 --> 00:10:43,040
it will program the the memory

00:10:41,120 --> 00:10:44,880
protection unit uh

00:10:43,040 --> 00:10:46,160
so that the application can access only

00:10:44,880 --> 00:10:48,800
its memory

00:10:46,160 --> 00:10:50,560
and this is really good as i remember

00:10:48,800 --> 00:10:53,519
putting a javascript

00:10:50,560 --> 00:10:55,680
engine last year for vr toss and

00:10:53,519 --> 00:10:58,720
javascript is a little bit memory hungry

00:10:55,680 --> 00:11:02,000
and we had a lot of stack overflows or

00:10:58,720 --> 00:11:03,680
memory overflows and the the result was

00:11:02,000 --> 00:11:05,040
really unpredictable it was really hard

00:11:03,680 --> 00:11:07,680
for us to debug and see

00:11:05,040 --> 00:11:08,880
uh what went wrong um talkers

00:11:07,680 --> 00:11:11,360
application do

00:11:08,880 --> 00:11:11,920
fault so like linux application that

00:11:11,360 --> 00:11:14,560
segment

00:11:11,920 --> 00:11:16,480
segments sec faults sorry these

00:11:14,560 --> 00:11:18,079
application faults so if they try to

00:11:16,480 --> 00:11:20,000
write outside their memory

00:11:18,079 --> 00:11:22,000
uh the mpu will stop them and you will

00:11:20,000 --> 00:11:24,720
get a really nice log with default and

00:11:22,000 --> 00:11:27,600
we'll see how it looks like further on

00:11:24,720 --> 00:11:28,079
it has downside uh applications need to

00:11:27,600 --> 00:11:30,480
have

00:11:28,079 --> 00:11:31,519
relocatable codes so the compiler needs

00:11:30,480 --> 00:11:33,680
to be able to do

00:11:31,519 --> 00:11:35,519
a position independent code and this has

00:11:33,680 --> 00:11:37,120
been a challenge mostly for risk 5

00:11:35,519 --> 00:11:38,800
architecture

00:11:37,120 --> 00:11:40,399
and the thing that they somehow borrowed

00:11:38,800 --> 00:11:42,800
from android it seems like

00:11:40,399 --> 00:11:44,880
they borrowed it from android

00:11:42,800 --> 00:11:46,800
applications can expose services

00:11:44,880 --> 00:11:48,320
and other applications can browse for

00:11:46,800 --> 00:11:49,120
those services and consume those

00:11:48,320 --> 00:11:51,040
services

00:11:49,120 --> 00:11:55,120
and this is the model of inter-process

00:11:51,040 --> 00:11:55,120
communication that topless provides

00:11:55,200 --> 00:11:59,040
if we look at the memory layout you

00:11:57,360 --> 00:11:59,680
might notice that it's a little bit

00:11:59,040 --> 00:12:02,320
strange

00:11:59,680 --> 00:12:02,959
um probably you are used to see the

00:12:02,320 --> 00:12:05,440
stack

00:12:02,959 --> 00:12:06,560
on the top at the top of the memory in

00:12:05,440 --> 00:12:08,720
case of top os

00:12:06,560 --> 00:12:09,680
the application code is resides inside

00:12:08,720 --> 00:12:11,839
the flash

00:12:09,680 --> 00:12:13,839
the stack is at the bottom part of the

00:12:11,839 --> 00:12:16,240
memory so every application

00:12:13,839 --> 00:12:18,000
will have to specify up front how much

00:12:16,240 --> 00:12:20,720
stack it wants to use

00:12:18,000 --> 00:12:22,160
uh this is a decision made because to

00:12:20,720 --> 00:12:23,040
prevent application from stack

00:12:22,160 --> 00:12:24,720
overflowing

00:12:23,040 --> 00:12:27,120
so if they overflow the stack what

00:12:24,720 --> 00:12:29,760
happens the application will basically

00:12:27,120 --> 00:12:31,680
uh overflow the memory boundary and the

00:12:29,760 --> 00:12:33,200
mpu will stop the application and you

00:12:31,680 --> 00:12:34,399
will get a nice report that the

00:12:33,200 --> 00:12:37,839
application did some

00:12:34,399 --> 00:12:39,360
um fault if the if the stack were at the

00:12:37,839 --> 00:12:41,120
top of the memory it would just

00:12:39,360 --> 00:12:43,839
overwrite your heap and that would lead

00:12:41,120 --> 00:12:45,600
to uh undefined behavior

00:12:43,839 --> 00:12:47,279
on top of the stack we have the data

00:12:45,600 --> 00:12:49,680
then we have the heap

00:12:47,279 --> 00:12:52,480
and at the top of the memory of an

00:12:49,680 --> 00:12:54,240
application we have the grant so as i

00:12:52,480 --> 00:12:56,480
said the kernel is not able to

00:12:54,240 --> 00:12:58,959
dynamically allocate memory

00:12:56,480 --> 00:12:59,920
so every capsule that needs to keep some

00:12:58,959 --> 00:13:02,560
information

00:12:59,920 --> 00:13:03,760
on a per application basis needs to

00:13:02,560 --> 00:13:06,079
declare upfront

00:13:03,760 --> 00:13:08,000
how much memory it needs to use for

00:13:06,079 --> 00:13:09,519
every application

00:13:08,000 --> 00:13:11,760
this amount is the same it doesn't

00:13:09,519 --> 00:13:14,800
matter what kind of application you run

00:13:11,760 --> 00:13:16,240
uh on the technical side they have to

00:13:14,800 --> 00:13:19,440
declare some structures

00:13:16,240 --> 00:13:20,959
in rust uh when an application is loaded

00:13:19,440 --> 00:13:23,360
the kernel will sum up

00:13:20,959 --> 00:13:24,320
all the requirements from the capsules

00:13:23,360 --> 00:13:27,200
and add that

00:13:24,320 --> 00:13:29,120
memory space to the application memory

00:13:27,200 --> 00:13:30,720
if the memory cannot be allocated the

00:13:29,120 --> 00:13:33,839
application won't start

00:13:30,720 --> 00:13:34,880
um so it's either it's like a

00:13:33,839 --> 00:13:36,720
transactional

00:13:34,880 --> 00:13:38,639
thing so either the application starts

00:13:36,720 --> 00:13:40,399
and then there is enough memory for the

00:13:38,639 --> 00:13:42,000
kernel and the application to run

00:13:40,399 --> 00:13:43,519
either the application doesn't start

00:13:42,000 --> 00:13:46,839
because the kernel cannot allocate

00:13:43,519 --> 00:13:50,399
enough memory for its drivers

00:13:46,839 --> 00:13:53,600
um another interesting fact

00:13:50,399 --> 00:13:54,240
is that um topquest re uses real system

00:13:53,600 --> 00:13:56,880
calls

00:13:54,240 --> 00:13:59,199
so in many embedded operating systems

00:13:56,880 --> 00:14:01,920
system calls are just the function calls

00:13:59,199 --> 00:14:03,040
in this case the tocquez uses the

00:14:01,920 --> 00:14:05,440
supervisor

00:14:03,040 --> 00:14:07,600
call instruction on arm and the

00:14:05,440 --> 00:14:10,079
equivalent on risk five

00:14:07,600 --> 00:14:10,720
it exposes five system calls out of

00:14:10,079 --> 00:14:13,199
which

00:14:10,720 --> 00:14:15,279
uh yield is the only one that is

00:14:13,199 --> 00:14:18,560
blocking system calls

00:14:15,279 --> 00:14:22,000
um so every process in tokos has

00:14:18,560 --> 00:14:24,480
an event loop basically a callback queue

00:14:22,000 --> 00:14:26,160
so when a capsule needs to inform an

00:14:24,480 --> 00:14:28,800
application about an action

00:14:26,160 --> 00:14:30,639
it will schedule a callback callbacks

00:14:28,800 --> 00:14:31,680
are not called while the application is

00:14:30,639 --> 00:14:34,160
running

00:14:31,680 --> 00:14:34,880
whenever the application uh calls the

00:14:34,160 --> 00:14:37,839
system called

00:14:34,880 --> 00:14:38,480
yield um the topos kernel will verify

00:14:37,839 --> 00:14:40,160
the queue

00:14:38,480 --> 00:14:42,320
if there is a callback function in the

00:14:40,160 --> 00:14:44,160
queue it will call the callback function

00:14:42,320 --> 00:14:46,560
and then resume the application from the

00:14:44,160 --> 00:14:50,240
system call this is very similar to

00:14:46,560 --> 00:14:52,000
a generator in python um

00:14:50,240 --> 00:14:54,320
when your main function exits in the

00:14:52,000 --> 00:14:56,160
application the c library will simply

00:14:54,320 --> 00:14:58,000
yield continuously

00:14:56,160 --> 00:15:00,240
this is the only system called and can

00:14:58,000 --> 00:15:02,480
block an application

00:15:00,240 --> 00:15:04,880
subscribe subscribe allows an

00:15:02,480 --> 00:15:06,880
application to register a callback

00:15:04,880 --> 00:15:09,199
it gets the capsule number this is the

00:15:06,880 --> 00:15:11,279
id of the driver and the top s kernel

00:15:09,199 --> 00:15:12,800
will redirect this subscribe call to the

00:15:11,279 --> 00:15:14,399
specified capsule

00:15:12,800 --> 00:15:17,279
and the call and the pointer to a

00:15:14,399 --> 00:15:20,079
callback function and the user data

00:15:17,279 --> 00:15:21,839
the command system call is similar to

00:15:20,079 --> 00:15:25,040
ioctl from linux

00:15:21,839 --> 00:15:26,800
it will ask the driver a specific driver

00:15:25,040 --> 00:15:29,120
to perform an action

00:15:26,800 --> 00:15:30,160
the difference being that the result of

00:15:29,120 --> 00:15:32,320
the system call

00:15:30,160 --> 00:15:33,920
is not the result of the action it's

00:15:32,320 --> 00:15:37,360
just an acknowledgement

00:15:33,920 --> 00:15:39,680
that the action will be performed

00:15:37,360 --> 00:15:41,680
allow provides a mechanism for

00:15:39,680 --> 00:15:42,560
applications to share a buffer with a

00:15:41,680 --> 00:15:44,800
driver

00:15:42,560 --> 00:15:46,399
for instance if you have a capsule that

00:15:44,800 --> 00:15:48,079
um wants to read something from the

00:15:46,399 --> 00:15:49,600
flash or from the network

00:15:48,079 --> 00:15:51,680
uh you will share a buffer with the

00:15:49,600 --> 00:15:52,240
driver the driver will fill the buffer

00:15:51,680 --> 00:15:55,440
and then

00:15:52,240 --> 00:15:57,839
call you back that the buffer is filled

00:15:55,440 --> 00:15:59,120
the last one is memory operation this is

00:15:57,839 --> 00:16:02,480
targeted to the kernel

00:15:59,120 --> 00:16:04,959
it's similar to brk or sprk from linux

00:16:02,480 --> 00:16:06,839
uh it does memory management so it

00:16:04,959 --> 00:16:08,079
highers the heap or lowers the heap

00:16:06,839 --> 00:16:10,320
limit

00:16:08,079 --> 00:16:12,399
just to give you a quick idea on how a

00:16:10,320 --> 00:16:14,720
system call would work

00:16:12,399 --> 00:16:16,399
first of all you have the application

00:16:14,720 --> 00:16:19,120
let's say you want to take

00:16:16,399 --> 00:16:20,480
some accelerometer data the first step

00:16:19,120 --> 00:16:22,800
will be to

00:16:20,480 --> 00:16:24,720
allow a buffer so that the accelerometer

00:16:22,800 --> 00:16:25,920
capsule can place the result inside the

00:16:24,720 --> 00:16:28,000
buffer

00:16:25,920 --> 00:16:29,120
afterwards your application would have

00:16:28,000 --> 00:16:30,800
to subscribe

00:16:29,120 --> 00:16:32,720
so that it can get a call back when the

00:16:30,800 --> 00:16:34,480
buffer is has been filled

00:16:32,720 --> 00:16:36,880
the third item would be to send the

00:16:34,480 --> 00:16:38,880
command and the capsule will understand

00:16:36,880 --> 00:16:40,959
that it needs to perform the action

00:16:38,880 --> 00:16:43,680
the capsule will interact with the lower

00:16:40,959 --> 00:16:45,360
level capsules and with the hardware

00:16:43,680 --> 00:16:47,360
but the command system can be returned

00:16:45,360 --> 00:16:49,440
immediately and afterwards your

00:16:47,360 --> 00:16:51,759
application will probably be healed

00:16:49,440 --> 00:16:52,959
and wait for the callback when the data

00:16:51,759 --> 00:16:55,759
is available

00:16:52,959 --> 00:16:57,120
so um this is like this is a little bit

00:16:55,759 --> 00:17:00,880
more complicated but

00:16:57,120 --> 00:17:00,880
offers you greater flexibility

00:17:01,759 --> 00:17:08,000
okay about writing applications

00:17:05,439 --> 00:17:09,520
uh for now liptoxy is fully supported

00:17:08,000 --> 00:17:10,880
and this is the recommended way in

00:17:09,520 --> 00:17:13,039
writing applications

00:17:10,880 --> 00:17:14,400
it's built on top of new leap c and deep

00:17:13,039 --> 00:17:16,559
c plus plus

00:17:14,400 --> 00:17:17,439
uh it has bindings for lua and little

00:17:16,559 --> 00:17:19,679
vgl

00:17:17,439 --> 00:17:20,880
it still has a problem with the risc 5

00:17:19,679 --> 00:17:23,439
architecture

00:17:20,880 --> 00:17:24,799
as the compiler is not able to generate

00:17:23,439 --> 00:17:27,760
the correct code for

00:17:24,799 --> 00:17:29,280
position independent if you want to try

00:17:27,760 --> 00:17:30,960
programming in rust you could write

00:17:29,280 --> 00:17:32,240
applications in rust it's still a

00:17:30,960 --> 00:17:35,280
developmental uh

00:17:32,240 --> 00:17:37,120
library it's in active development

00:17:35,280 --> 00:17:38,640
it still has a big bug because there's a

00:17:37,120 --> 00:17:41,760
big compiler bug

00:17:38,640 --> 00:17:44,240
um that prevents us in building uh

00:17:41,760 --> 00:17:47,440
position independent code the right way

00:17:44,240 --> 00:17:49,919
so i would strongly suggest you to use c

00:17:47,440 --> 00:17:52,160
uh our small contribution to the project

00:17:49,919 --> 00:17:54,080
was to import the d language that was my

00:17:52,160 --> 00:17:55,760
student teona severin which also

00:17:54,080 --> 00:17:57,919
graduated today

00:17:55,760 --> 00:18:01,120
uh and she boarded the d language and

00:17:57,919 --> 00:18:02,720
enabled the language for arm and talk os

00:18:01,120 --> 00:18:05,600
uh of course without the garbage

00:18:02,720 --> 00:18:07,919
collection about the garbage collection

00:18:05,600 --> 00:18:08,960
uh you might have seen yara this morning

00:18:07,919 --> 00:18:12,080
and uh

00:18:08,960 --> 00:18:14,240
in the keynote her work was importing

00:18:12,080 --> 00:18:14,720
jerryscript to top os gerryscript is a

00:18:14,240 --> 00:18:17,200
really

00:18:14,720 --> 00:18:18,160
performant javascript library it's used

00:18:17,200 --> 00:18:21,360
by fitbit

00:18:18,160 --> 00:18:24,880
in this device in the watch's

00:18:21,360 --> 00:18:28,400
face um it works on topquest

00:18:24,880 --> 00:18:30,080
gpios buttons lets timers we still have

00:18:28,400 --> 00:18:31,679
some issues with the memory protection

00:18:30,080 --> 00:18:34,160
because the metal protection

00:18:31,679 --> 00:18:34,960
unit is not as flexible as the one on

00:18:34,160 --> 00:18:36,799
your computer

00:18:34,960 --> 00:18:38,880
so it imposes some memory alignment

00:18:36,799 --> 00:18:41,280
limitations and javascript is really

00:18:38,880 --> 00:18:43,679
memory hungry

00:18:41,280 --> 00:18:44,640
uh when it comes to the executable we

00:18:43,679 --> 00:18:47,760
won't have an elf

00:18:44,640 --> 00:18:50,080
file for tokos we have a tbf file

00:18:47,760 --> 00:18:51,120
uh it contains a header which specifies

00:18:50,080 --> 00:18:52,640
how much stack

00:18:51,120 --> 00:18:54,559
and how much memory the application

00:18:52,640 --> 00:18:57,760
needs and then the actual

00:18:54,559 --> 00:19:01,039
application binary a really cool fact

00:18:57,760 --> 00:19:02,880
is that tokus applications can be

00:19:01,039 --> 00:19:04,880
shipped with several architecture in the

00:19:02,880 --> 00:19:06,320
same file in the tab file talk

00:19:04,880 --> 00:19:08,320
application bundle

00:19:06,320 --> 00:19:10,960
this is more or less the same way apple

00:19:08,320 --> 00:19:12,640
ships applications for the iphone

00:19:10,960 --> 00:19:14,400
you have several iphone processors and

00:19:12,640 --> 00:19:18,000
you have one binary that contains

00:19:14,400 --> 00:19:20,240
a small binary for each of them uh

00:19:18,000 --> 00:19:21,280
for loading toques applications you

00:19:20,240 --> 00:19:23,520
don't have to

00:19:21,280 --> 00:19:25,440
rewrite the whole full flash you can

00:19:23,520 --> 00:19:28,160
load on the microcontroller flash

00:19:25,440 --> 00:19:30,080
only the application this is done by

00:19:28,160 --> 00:19:30,880
talk loader which is a small python

00:19:30,080 --> 00:19:33,600
script

00:19:30,880 --> 00:19:34,880
that does this for you and they even

00:19:33,600 --> 00:19:37,120
implement in an app store

00:19:34,880 --> 00:19:39,440
so you could write talk loader the name

00:19:37,120 --> 00:19:41,039
of the app it will download the tab file

00:19:39,440 --> 00:19:43,440
select the correct architecture

00:19:41,039 --> 00:19:44,880
and ship it to your microcontroller so

00:19:43,440 --> 00:19:47,840
this is a really cool feature

00:19:44,880 --> 00:19:51,440
and i haven't seen this before in a

00:19:47,840 --> 00:19:54,559
microcontroller embedded system

00:19:51,440 --> 00:19:56,320
uh i would like to ask alex now to uh

00:19:54,559 --> 00:19:57,679
walk you through what it means to port a

00:19:56,320 --> 00:20:01,280
new board to topquest

00:19:57,679 --> 00:20:01,280
alex if you can take it from here

00:20:02,640 --> 00:20:10,400
yes hello so this is the nxp imxrt

00:20:06,720 --> 00:20:11,280
uh 1052 evkb the board that we managed

00:20:10,400 --> 00:20:14,400
to port to

00:20:11,280 --> 00:20:17,919
pocos and it features an arm cortex

00:20:14,400 --> 00:20:19,120
m7 cpu with a nominal frequency of 600

00:20:17,919 --> 00:20:20,799
megahertz

00:20:19,120 --> 00:20:22,480
this is actually an interesting board

00:20:20,799 --> 00:20:24,640
for us because

00:20:22,480 --> 00:20:26,000
it also allows us to work on a side

00:20:24,640 --> 00:20:29,200
project of ours

00:20:26,000 --> 00:20:29,600
which is to run webassembly code on top

00:20:29,200 --> 00:20:33,039
of

00:20:29,600 --> 00:20:35,360
tokus in the user space also

00:20:33,039 --> 00:20:36,640
i would like to use this opportunity to

00:20:35,360 --> 00:20:39,600
thank um

00:20:36,640 --> 00:20:41,600
the nxp office in romania for supporting

00:20:39,600 --> 00:20:43,200
uh this project with boards and also

00:20:41,600 --> 00:20:47,600
scholarships

00:20:43,200 --> 00:20:51,120
coming back to the board the nxp evkb

00:20:47,600 --> 00:20:52,799
offers a user controlled led a button

00:20:51,120 --> 00:20:55,760
and also a motion sensor

00:20:52,799 --> 00:20:57,919
this was these were used for testing the

00:20:55,760 --> 00:21:00,480
facilities that we implemented

00:20:57,919 --> 00:21:00,960
other notable facts it has an ethernet

00:21:00,480 --> 00:21:06,159
port

00:21:00,960 --> 00:21:08,880
and also a 256 megabyte sdram

00:21:06,159 --> 00:21:09,360
so in our process to port os for this

00:21:08,880 --> 00:21:10,880
board

00:21:09,360 --> 00:21:13,440
we created support for a new

00:21:10,880 --> 00:21:16,320
architecture the arm cortex m7

00:21:13,440 --> 00:21:18,240
which was mostly based on the existing

00:21:16,320 --> 00:21:20,720
arm cortex m4 which was already

00:21:18,240 --> 00:21:22,960
supported by tokos

00:21:20,720 --> 00:21:25,280
we also managed to implement some of the

00:21:22,960 --> 00:21:28,320
core features for this board which are

00:21:25,280 --> 00:21:30,320
for example the serial line

00:21:28,320 --> 00:21:32,559
for communicating with the board the i

00:21:30,320 --> 00:21:33,200
squared c peripheral which was tested by

00:21:32,559 --> 00:21:36,640
using the

00:21:33,200 --> 00:21:39,360
motion sensor and for example the gpio

00:21:36,640 --> 00:21:40,880
which was tested by using the user led

00:21:39,360 --> 00:21:44,559
present on the board

00:21:40,880 --> 00:21:47,760
finally we also ported the

00:21:44,559 --> 00:21:49,520
rust library for the user space for this

00:21:47,760 --> 00:21:51,679
board

00:21:49,520 --> 00:21:52,880
now let's take a look at what means to

00:21:51,679 --> 00:21:56,799
implement a feature

00:21:52,880 --> 00:21:58,640
in tokos in the kernel so the first part

00:21:56,799 --> 00:22:01,360
we have to define the registers

00:21:58,640 --> 00:22:03,120
for example the structure of for the

00:22:01,360 --> 00:22:06,080
general purpose registers

00:22:03,120 --> 00:22:07,520
in the right picture after that for each

00:22:06,080 --> 00:22:10,080
register that was defined

00:22:07,520 --> 00:22:10,720
we have to define each component for

00:22:10,080 --> 00:22:14,000
example

00:22:10,720 --> 00:22:16,880
the prescale register in the left photo

00:22:14,000 --> 00:22:18,480
after that we map the structure of

00:22:16,880 --> 00:22:20,720
registers in the memory

00:22:18,480 --> 00:22:24,080
and implement the functions that are

00:22:20,720 --> 00:22:24,080
related to that feature

00:22:24,720 --> 00:22:28,559
one of the major problems that we

00:22:27,360 --> 00:22:31,120
encountered uh

00:22:28,559 --> 00:22:33,600
during this process is that the imxrt

00:22:31,120 --> 00:22:35,600
has a huge number of registers for the

00:22:33,600 --> 00:22:39,039
input output multiplexer controller

00:22:35,600 --> 00:22:42,400
we had 154 registers

00:22:39,039 --> 00:22:45,360
yeah in order to deploy

00:22:42,400 --> 00:22:46,480
an application we have to use the mcu

00:22:45,360 --> 00:22:48,960
expresso id

00:22:46,480 --> 00:22:50,320
and the sdk for this board which are

00:22:48,960 --> 00:22:53,039
also normally used

00:22:50,320 --> 00:22:54,559
in order to program an application for

00:22:53,039 --> 00:22:58,240
for this board

00:22:54,559 --> 00:23:01,760
then we import an sdk example

00:22:58,240 --> 00:23:04,400
like hello world and then uh separately

00:23:01,760 --> 00:23:05,360
compile the talk image which will also

00:23:04,400 --> 00:23:06,799
have to contain

00:23:05,360 --> 00:23:08,960
the application that will run in the

00:23:06,799 --> 00:23:12,480
user space and then

00:23:08,960 --> 00:23:15,039
drag and drop the application in the ide

00:23:12,480 --> 00:23:17,120
configure the debug to select our image

00:23:15,039 --> 00:23:19,360
or the doc image instead of the

00:23:17,120 --> 00:23:20,240
image that would be generated by the sdk

00:23:19,360 --> 00:23:22,559
example

00:23:20,240 --> 00:23:23,520
and then just hit debug in order to

00:23:22,559 --> 00:23:27,520
program the

00:23:23,520 --> 00:23:28,320
the device we encountered quite a few

00:23:27,520 --> 00:23:30,559
problems

00:23:28,320 --> 00:23:33,360
throughout the development process the

00:23:30,559 --> 00:23:36,159
major problem that we had was

00:23:33,360 --> 00:23:37,280
an issue with the system timer which was

00:23:36,159 --> 00:23:40,799
mostly due to a

00:23:37,280 --> 00:23:43,279
wrong timer frequency and we fixed this

00:23:40,799 --> 00:23:45,279
with a pull request which is uh

00:23:43,279 --> 00:23:47,520
in the process of being accepted which

00:23:45,279 --> 00:23:51,120
extends the functionality of the

00:23:47,520 --> 00:23:53,760
systick for the arm cortex-m

00:23:51,120 --> 00:23:54,559
processors uh other problems that we

00:23:53,760 --> 00:23:57,919
encountered

00:23:54,559 --> 00:24:01,440
pub compiler error in the prost library

00:23:57,919 --> 00:24:04,000
and also a bus error we were actually

00:24:01,440 --> 00:24:04,960
implementing the fix for this and right

00:24:04,000 --> 00:24:07,840
before we

00:24:04,960 --> 00:24:09,760
uh tried to create the pull request it

00:24:07,840 --> 00:24:11,919
was already fixed by the doc

00:24:09,760 --> 00:24:14,400
core theme and patched in the in the

00:24:11,919 --> 00:24:14,400
upstream

00:24:14,960 --> 00:24:18,320
oh we are now working on importing the

00:24:17,840 --> 00:24:21,760
full

00:24:18,320 --> 00:24:24,799
core our cortex m7 features

00:24:21,760 --> 00:24:26,080
uh we have already implemented all 16

00:24:24,799 --> 00:24:29,840
mpu regions

00:24:26,080 --> 00:24:32,960
and we are working on supporting full

00:24:29,840 --> 00:24:35,360
cache features for this board

00:24:32,960 --> 00:24:36,559
after that we will implement the the

00:24:35,360 --> 00:24:38,960
other features that were

00:24:36,559 --> 00:24:40,159
not touched yet for example the spi and

00:24:38,960 --> 00:24:42,640
the other net

00:24:40,159 --> 00:24:45,360
and after that we will take a look at

00:24:42,640 --> 00:24:48,720
the other devices from the imxrt

00:24:45,360 --> 00:24:51,200
family such as the 1060. uh

00:24:48,720 --> 00:24:52,640
if there are any uh if there is anyone

00:24:51,200 --> 00:24:55,679
in the audience from

00:24:52,640 --> 00:24:57,520
from nxp we would love to collaborate uh

00:24:55,679 --> 00:25:00,480
in order to better integrate that

00:24:57,520 --> 00:25:02,320
this top os development project with the

00:25:00,480 --> 00:25:05,120
mcu expresso ide

00:25:02,320 --> 00:25:05,520
as for the moment we are kind of doing a

00:25:05,120 --> 00:25:08,559
hack

00:25:05,520 --> 00:25:12,640
like uh drag and dropping the

00:25:08,559 --> 00:25:15,520
the talk image inside of the the ide

00:25:12,640 --> 00:25:16,559
also as alex mentioned earlier in the

00:25:15,520 --> 00:25:19,520
presentation

00:25:16,559 --> 00:25:20,640
uh tokos provides an application called

00:25:19,520 --> 00:25:23,840
talkloader

00:25:20,640 --> 00:25:25,760
which helps you to program devices that

00:25:23,840 --> 00:25:28,720
are supported by uh

00:25:25,760 --> 00:25:30,640
boards that are supported by tokos so we

00:25:28,720 --> 00:25:31,440
are also planning on extending the

00:25:30,640 --> 00:25:33,919
support for

00:25:31,440 --> 00:25:35,120
the talk loader in order to support the

00:25:33,919 --> 00:25:37,440
imxrt

00:25:35,120 --> 00:25:37,440
board

00:25:40,240 --> 00:25:46,000
for the demo alex

00:25:43,679 --> 00:25:46,799
yes i need to get on the air thank you

00:25:46,000 --> 00:25:48,880
alex so much

00:25:46,799 --> 00:25:50,640
uh before we have a demo uh i would like

00:25:48,880 --> 00:25:53,600
to answer one of the questions

00:25:50,640 --> 00:25:55,120
so um the question is if there are any

00:25:53,600 --> 00:25:57,840
plans for app signing

00:25:55,120 --> 00:25:59,120
uh yes there is a tokus threat model

00:25:57,840 --> 00:26:01,279
which you can find on the

00:25:59,120 --> 00:26:02,799
tokens repository and this has been

00:26:01,279 --> 00:26:05,039
already a discussion

00:26:02,799 --> 00:26:08,320
and adding a digital signature or a way

00:26:05,039 --> 00:26:08,320
of verifying that apps are

00:26:08,400 --> 00:26:13,039
legit let's say like that uh i have

00:26:11,520 --> 00:26:14,799
another question but that's one

00:26:13,039 --> 00:26:16,080
about the footprint but i will answer it

00:26:14,799 --> 00:26:18,480
during the demo

00:26:16,080 --> 00:26:20,480
so first of all uh let me let's dive

00:26:18,480 --> 00:26:24,159
into this i will share my screen

00:26:20,480 --> 00:26:28,799
uh so the entire screen

00:26:24,159 --> 00:26:30,720
okay um my screen should be visible

00:26:28,799 --> 00:26:31,840
alex can you confirm that my screen is

00:26:30,720 --> 00:26:35,760
visible

00:26:31,840 --> 00:26:36,320
yes yes it's visible okay so just a few

00:26:35,760 --> 00:26:39,360
seconds

00:26:36,320 --> 00:26:42,000
i will show you what i have here

00:26:39,360 --> 00:26:42,960
so uh this is tokos this is the tokes

00:26:42,000 --> 00:26:45,279
repository

00:26:42,960 --> 00:26:46,720
as you can see um this is just a kernel

00:26:45,279 --> 00:26:49,200
not the user space

00:26:46,720 --> 00:26:51,279
we have an architecture folder with the

00:26:49,200 --> 00:26:53,520
processor architectures

00:26:51,279 --> 00:26:54,400
we have a chips folder where we have a

00:26:53,520 --> 00:26:56,080
specific chip

00:26:54,400 --> 00:26:57,919
that contains one of the architecture

00:26:56,080 --> 00:27:00,159
and has the peripherals

00:26:57,919 --> 00:27:02,559
and we have a boards folder where we

00:27:00,159 --> 00:27:04,720
have the entry point of the kernel

00:27:02,559 --> 00:27:06,240
for this example i will use the arduino

00:27:04,720 --> 00:27:09,200
nano ble

00:27:06,240 --> 00:27:10,799
it has just been added this week to uh

00:27:09,200 --> 00:27:13,520
as a supported board

00:27:10,799 --> 00:27:14,640
and the reset handler of the cpu is

00:27:13,520 --> 00:27:17,360
basically the

00:27:14,640 --> 00:27:19,440
main or the entry point into the kernel

00:27:17,360 --> 00:27:22,399
we also have a folder with the capsules

00:27:19,440 --> 00:27:24,480
or the drivers a documentation folder

00:27:22,399 --> 00:27:25,760
and the kernel folder where we can see

00:27:24,480 --> 00:27:27,679
uh several info

00:27:25,760 --> 00:27:30,240
where the kernel resides the scheduler

00:27:27,679 --> 00:27:32,159
process loader and so on and so forth

00:27:30,240 --> 00:27:33,279
for the demo i will use the arduino

00:27:32,159 --> 00:27:36,559
board so

00:27:33,279 --> 00:27:39,120
let me just unlock the phone uh if this

00:27:36,559 --> 00:27:42,399
would work

00:27:39,120 --> 00:27:44,480
okay so you should be able to see my

00:27:42,399 --> 00:27:47,600
phone

00:27:44,480 --> 00:27:50,320
so i have here an arduino ble board uh

00:27:47,600 --> 00:27:51,600
it's about thirty dollars you can buy it

00:27:50,320 --> 00:27:54,480
out of amazon

00:27:51,600 --> 00:27:56,880
it's hooked up to an lcd screen a really

00:27:54,480 --> 00:27:58,880
nice small lcd screen over spi

00:27:56,880 --> 00:28:01,440
and it's not running anything at the

00:27:58,880 --> 00:28:03,440
moment so but the first step that i want

00:28:01,440 --> 00:28:06,720
to do is to flash the kernel

00:28:03,440 --> 00:28:09,679
so um i will enter the boards folder

00:28:06,720 --> 00:28:10,559
and choose nano the nano board and i

00:28:09,679 --> 00:28:15,200
will say make

00:28:10,559 --> 00:28:18,559
program and program

00:28:15,200 --> 00:28:20,559
sorry program i will put the arduino

00:28:18,559 --> 00:28:22,640
into flash mode and i still need to

00:28:20,559 --> 00:28:23,840
specify the port this is a problem on

00:28:22,640 --> 00:28:26,480
the mac somehow it

00:28:23,840 --> 00:28:27,279
does not detect automatically the port

00:28:26,480 --> 00:28:29,120
so um

00:28:27,279 --> 00:28:30,960
as you can see it compiled the kernel i

00:28:29,120 --> 00:28:32,960
already had it compiled

00:28:30,960 --> 00:28:34,159
after the compilation coming back to the

00:28:32,960 --> 00:28:36,080
footprint

00:28:34,159 --> 00:28:38,799
you can see here the size of the kernel

00:28:36,080 --> 00:28:42,480
so this is about 90 kilobytes in text

00:28:38,799 --> 00:28:44,640
the data is about 2 kilobytes bss

00:28:42,480 --> 00:28:46,799
is about 55 so the total memory

00:28:44,640 --> 00:28:50,159
footprint should be somewhere around

00:28:46,799 --> 00:28:52,110
um 90 kilobytes of memory of ram and

00:28:50,159 --> 00:28:53,440
90 kilobytes of um

00:28:52,110 --> 00:28:56,960
[Music]

00:28:53,440 --> 00:29:00,000
i'm sorry a flash

00:28:56,960 --> 00:29:02,640
the kernel is flashed onto the cpu

00:29:00,000 --> 00:29:03,760
on the microcontroller as you can see it

00:29:02,640 --> 00:29:06,799
does nothing so

00:29:03,760 --> 00:29:10,480
it's just a kernel um

00:29:06,799 --> 00:29:14,159
if we were to open the serial line um

00:29:10,480 --> 00:29:16,559
this is uh done with top loader listen

00:29:14,159 --> 00:29:18,240
you can see it writes initialization

00:29:16,559 --> 00:29:21,600
complete entering main loop

00:29:18,240 --> 00:29:24,080
and that's it okay so let's

00:29:21,600 --> 00:29:24,960
write an application this is the user

00:29:24,080 --> 00:29:28,480
space for talk

00:29:24,960 --> 00:29:30,000
i will use detoxi uh you can find new

00:29:28,480 --> 00:29:32,559
lib here which is pre-compiled

00:29:30,000 --> 00:29:34,480
lvgl the lua library the leap talk

00:29:32,559 --> 00:29:36,640
library which provides the system calls

00:29:34,480 --> 00:29:39,120
and the user space for the capsules

00:29:36,640 --> 00:29:40,240
and the examples i will take the blink

00:29:39,120 --> 00:29:42,480
example

00:29:40,240 --> 00:29:43,840
and this is how talk is program looks

00:29:42,480 --> 00:29:45,840
like as you can see

00:29:43,840 --> 00:29:47,279
it's more or less like a normal

00:29:45,840 --> 00:29:48,320
application that you would write for

00:29:47,279 --> 00:29:50,399
your computer

00:29:48,320 --> 00:29:52,240
so there's nothing specific to the

00:29:50,399 --> 00:29:54,640
microcontroller it's just the main

00:29:52,240 --> 00:29:55,760
and you use the normal function that you

00:29:54,640 --> 00:29:58,240
would use

00:29:55,760 --> 00:29:59,520
so i'm just going to enter examples and

00:29:58,240 --> 00:30:02,399
blink

00:29:59,520 --> 00:30:04,480
i will compile this and say make as you

00:30:02,399 --> 00:30:06,399
can see it compiled the application

00:30:04,480 --> 00:30:08,000
it didn't need any kernel so this is a

00:30:06,399 --> 00:30:10,720
normal c compiler

00:30:08,000 --> 00:30:12,240
and it builds uh three architectures the

00:30:10,720 --> 00:30:16,720
cortex m0 cortex

00:30:12,240 --> 00:30:19,679
m3 and cortex m4 files

00:30:16,720 --> 00:30:20,559
also we have a tbf file out of them so

00:30:19,679 --> 00:30:22,720
how do we flash an

00:30:20,559 --> 00:30:24,480
application we will use talk loader is

00:30:22,720 --> 00:30:24,960
not fully supported for arduino so we

00:30:24,480 --> 00:30:27,919
will use

00:30:24,960 --> 00:30:29,440
bosak bosak is the normal arduino

00:30:27,919 --> 00:30:32,720
bootloader

00:30:29,440 --> 00:30:36,000
and as you can see i will flash the

00:30:32,720 --> 00:30:39,120
cortex m the file is called

00:30:36,000 --> 00:30:39,520
cortex and tbf so simply i will simply

00:30:39,120 --> 00:30:42,480
fi

00:30:39,520 --> 00:30:44,080
flash only the tbf file not the kernel

00:30:42,480 --> 00:30:45,840
again i'll put the arduino in the

00:30:44,080 --> 00:30:47,840
flashing mode

00:30:45,840 --> 00:30:50,000
start flashing it was super fast the

00:30:47,840 --> 00:30:54,399
application was really really small

00:30:50,000 --> 00:30:58,399
and as you can see it flashes the lens

00:30:54,399 --> 00:30:59,039
um once again if we go into the listener

00:30:58,399 --> 00:31:01,200
we can see

00:30:59,039 --> 00:31:03,360
um the device just started but it's not

00:31:01,200 --> 00:31:04,799
writing anything on the screen

00:31:03,360 --> 00:31:07,360
now let's try a more difficult

00:31:04,799 --> 00:31:09,200
application something with a screen

00:31:07,360 --> 00:31:10,720
i have have here an application that

00:31:09,200 --> 00:31:13,039
uses lvgl

00:31:10,720 --> 00:31:15,120
it just writes loading displays a gauge

00:31:13,039 --> 00:31:18,240
and then says hello talk os

00:31:15,120 --> 00:31:20,480
i will go into our vgl okay so this

00:31:18,240 --> 00:31:21,039
application was about one kilobytes of

00:31:20,480 --> 00:31:23,919
text

00:31:21,039 --> 00:31:24,799
and it used about three kilobytes of

00:31:23,919 --> 00:31:26,559
memory

00:31:24,799 --> 00:31:29,120
uh so add this to the kernel and that is

00:31:26,559 --> 00:31:30,880
the footprint uh in case of the screen

00:31:29,120 --> 00:31:31,279
this will be a little bit larger because

00:31:30,880 --> 00:31:34,559
it has

00:31:31,279 --> 00:31:38,080
lvgl about 60 kilobytes of ram

00:31:34,559 --> 00:31:39,760
and about 9 kilobytes

00:31:38,080 --> 00:31:41,600
oh sorry 9 kilobytes of ram and 60

00:31:39,760 --> 00:31:43,519
kilobytes of flash

00:31:41,600 --> 00:31:45,120
we have built the application let's

00:31:43,519 --> 00:31:48,720
flash it so i will use again

00:31:45,120 --> 00:31:49,760
balsa and just go and flash the screen

00:31:48,720 --> 00:31:52,880
so i will

00:31:49,760 --> 00:31:56,159
instead of blink i will write screen

00:31:52,880 --> 00:32:00,399
sorry not skin lvgl this is cortex

00:31:56,159 --> 00:32:02,240
and pbf and i would

00:32:00,399 --> 00:32:04,399
usually do this with talk loader but

00:32:02,240 --> 00:32:06,399
it's not supported yet for this

00:32:04,399 --> 00:32:07,760
as you can see flashing takes a little

00:32:06,399 --> 00:32:11,120
bit longer

00:32:07,760 --> 00:32:14,880
and here we go if we get lucky uh

00:32:11,120 --> 00:32:17,200
yes leds are um

00:32:14,880 --> 00:32:19,600
i'm sorry you can see the screen is

00:32:17,200 --> 00:32:19,600
working

00:32:22,000 --> 00:32:26,159
okay it says loading whenever it's

00:32:24,080 --> 00:32:28,399
finished yeah

00:32:26,159 --> 00:32:30,000
the application was normal normal

00:32:28,399 --> 00:32:32,799
application

00:32:30,000 --> 00:32:33,679
so if i want to flash two applications i

00:32:32,799 --> 00:32:36,880
could do that

00:32:33,679 --> 00:32:38,880
so what i have to do i will exit this

00:32:36,880 --> 00:32:41,279
and i will simply concatenate

00:32:38,880 --> 00:32:43,120
concatenate the blink application and

00:32:41,279 --> 00:32:45,600
the lvgl application

00:32:43,120 --> 00:32:47,440
into one single file which is called

00:32:45,600 --> 00:32:50,559
appsdbf

00:32:47,440 --> 00:32:52,960
this is done and now let's flash it

00:32:50,559 --> 00:32:54,080
um you will see an interesting thing

00:32:52,960 --> 00:32:56,799
here

00:32:54,080 --> 00:32:57,919
oh forgot to put the arduino into flash

00:32:56,799 --> 00:32:59,919
mode

00:32:57,919 --> 00:33:01,279
here we go you can see it's a little

00:32:59,919 --> 00:33:05,200
large

00:33:01,279 --> 00:33:08,399
and surprise the lens work

00:33:05,200 --> 00:33:12,080
the screen not so much oh sorry so

00:33:08,399 --> 00:33:17,279
let's work but the screen

00:33:12,080 --> 00:33:17,279
not so much oh my phone just uh

00:33:17,519 --> 00:33:24,159
okay so what happened here

00:33:21,760 --> 00:33:24,799
we're gonna use stock loader to uh

00:33:24,159 --> 00:33:26,799
listen

00:33:24,799 --> 00:33:29,039
to see whatever the the arduino is

00:33:26,799 --> 00:33:31,200
saying as you can see uh due to the

00:33:29,039 --> 00:33:32,960
memory protection you need alignment

00:33:31,200 --> 00:33:35,200
even though it had enough memory it

00:33:32,960 --> 00:33:35,679
could not flash both it could not start

00:33:35,200 --> 00:33:39,279
both

00:33:35,679 --> 00:33:41,600
applications uh a trick that you can do

00:33:39,279 --> 00:33:42,480
is to concatenate them in a different

00:33:41,600 --> 00:33:45,440
order so

00:33:42,480 --> 00:33:46,000
first the screen and then the leds i

00:33:45,440 --> 00:33:49,120
just

00:33:46,000 --> 00:33:50,720
change the concatenation up flash it

00:33:49,120 --> 00:33:54,480
again

00:33:50,720 --> 00:33:57,279
and here we go this time

00:33:54,480 --> 00:34:00,240
it should they should both work so it

00:33:57,279 --> 00:34:04,000
started as you can see legs are flashing

00:34:00,240 --> 00:34:07,519
and the application is running

00:34:04,000 --> 00:34:09,040
okay so um yeah switching back to alex

00:34:07,519 --> 00:34:11,679
if you can show us a little bit about

00:34:09,040 --> 00:34:11,679
the nxp

00:34:12,159 --> 00:34:18,839
yes just a second to share my screen

00:34:16,639 --> 00:34:21,280
uh you have to close your share screen

00:34:18,839 --> 00:34:25,440
first oh sorry sorry alex

00:34:21,280 --> 00:34:25,440
here you go no problem

00:34:26,000 --> 00:34:30,320
okay you should see my screen right now

00:34:28,639 --> 00:34:33,040
right

00:34:30,320 --> 00:34:35,839
i see it can you confirm alex okay yes

00:34:33,040 --> 00:34:38,240
yes i can see it oh what we have here

00:34:35,839 --> 00:34:39,919
okay super so what we have here is a

00:34:38,240 --> 00:34:43,440
simple application for

00:34:39,919 --> 00:34:46,800
the nxp board which tests the

00:34:43,440 --> 00:34:47,520
sim a few facilities a few facilities of

00:34:46,800 --> 00:34:50,639
the

00:34:47,520 --> 00:34:50,960
of the board so uh in order to program

00:34:50,639 --> 00:34:54,000
it

00:34:50,960 --> 00:34:54,800
i i have hit make in order to compile

00:34:54,000 --> 00:34:57,920
the application

00:34:54,800 --> 00:35:00,079
this is uh over the leaptoxi uh

00:34:57,920 --> 00:35:01,599
library so this is only the application

00:35:00,079 --> 00:35:04,640
from the user space

00:35:01,599 --> 00:35:08,400
after this we go back to the talk

00:35:04,640 --> 00:35:10,560
development folder we make sure that

00:35:08,400 --> 00:35:11,599
the app variable points to the

00:35:10,560 --> 00:35:14,079
application

00:35:11,599 --> 00:35:15,520
that will be used as a user space

00:35:14,079 --> 00:35:18,079
application

00:35:15,520 --> 00:35:19,920
for now we have to put both the

00:35:18,079 --> 00:35:22,400
application and the kernel

00:35:19,920 --> 00:35:24,160
at the same time on the board since the

00:35:22,400 --> 00:35:25,839
board is not supposed supported by the

00:35:24,160 --> 00:35:29,520
talk loader

00:35:25,839 --> 00:35:32,800
so i see i simply hit my program

00:35:29,520 --> 00:35:36,000
in order to to get the

00:35:32,800 --> 00:35:40,079
the binary file after that

00:35:36,000 --> 00:35:44,000
in my mcu expresso ide i have a

00:35:40,079 --> 00:35:45,520
simple uh sdk example the hello world i

00:35:44,000 --> 00:35:48,480
drag and drop

00:35:45,520 --> 00:35:48,480
the talk image

00:35:48,560 --> 00:35:52,320
normally what i would do i would hit

00:35:51,040 --> 00:35:54,320
here the

00:35:52,320 --> 00:35:56,720
enter the configuration mode to see if

00:35:54,320 --> 00:36:00,720
the application is mine that

00:35:56,720 --> 00:36:04,400
will be programmed on the device

00:36:00,720 --> 00:36:05,359
and now i press debug oh just a second i

00:36:04,400 --> 00:36:08,160
forgot to

00:36:05,359 --> 00:36:08,160
insert the board

00:36:09,040 --> 00:36:13,839
yes it should see it okay

00:36:17,040 --> 00:36:20,320
okay so it was copied on the device next

00:36:19,680 --> 00:36:22,480
step

00:36:20,320 --> 00:36:24,960
we open a serial connection with a

00:36:22,480 --> 00:36:28,880
device

00:36:24,960 --> 00:36:28,880
oh it's the other port

00:36:32,160 --> 00:36:37,200
okay and then if i hit run

00:36:37,359 --> 00:36:41,040
so it's a simple application which

00:36:39,200 --> 00:36:44,320
allows me to insert my name

00:36:41,040 --> 00:36:47,359
and then i can turn on and off an led

00:36:44,320 --> 00:36:50,000
i will turn on the led in order to

00:36:47,359 --> 00:36:51,040
and i will stop sharing the screen so

00:36:50,000 --> 00:36:54,720
that you can see

00:36:51,040 --> 00:36:59,920
on my camera oh

00:36:54,720 --> 00:36:59,920
i don't know if it's full screen okay

00:37:02,000 --> 00:37:10,160
so the led that was okay just a second

00:37:06,720 --> 00:37:10,160
the board is connected sorry

00:37:10,240 --> 00:37:22,320
oh okay you've seen okay and if i

00:37:14,079 --> 00:37:26,000
go back to share screen in just a second

00:37:22,320 --> 00:37:28,720
and back to the serial line if i want

00:37:26,000 --> 00:37:31,200
to cause a fault a hard fault i simply

00:37:28,720 --> 00:37:34,240
press x

00:37:31,200 --> 00:37:35,040
no it the board is connected what

00:37:34,240 --> 00:37:39,200
happens

00:37:35,040 --> 00:37:41,839
i have a yeah

00:37:39,200 --> 00:37:42,560
what happens is that i have on on my mac

00:37:41,839 --> 00:37:46,160
only usb

00:37:42,560 --> 00:37:50,160
c so the adapter

00:37:46,160 --> 00:37:53,839
is not fully working

00:37:50,160 --> 00:37:56,880
just a second usbc is not

00:37:53,839 --> 00:38:01,440
fully not a standard yet

00:37:56,880 --> 00:38:04,960
so um yep and the apple decided to

00:38:01,440 --> 00:38:07,310
drop the usb ports

00:38:04,960 --> 00:38:09,839
okay so if you can see so back here

00:38:07,310 --> 00:38:13,440
[Music]

00:38:09,839 --> 00:38:16,320
okay if i press x to cause a hard fold

00:38:13,440 --> 00:38:16,800
because the program runs in debug mode

00:38:16,320 --> 00:38:19,839
uh

00:38:16,800 --> 00:38:21,760
first mcxpresso will take over and say

00:38:19,839 --> 00:38:25,280
okay you get a hard for here

00:38:21,760 --> 00:38:26,880
and if i press continue i will get the

00:38:25,280 --> 00:38:29,440
output for the hard fault

00:38:26,880 --> 00:38:30,320
uh from the from the top os operating

00:38:29,440 --> 00:38:34,000
system

00:38:30,320 --> 00:38:36,640
so here if i go up it says where it

00:38:34,000 --> 00:38:37,280
it hit kernel banning and it also says

00:38:36,640 --> 00:38:40,400
the folding

00:38:37,280 --> 00:38:42,640
memory address which is 0800

00:38:40,400 --> 00:38:45,200
because i created the null pointer and

00:38:42,640 --> 00:38:47,359
assigned a value to it

00:38:45,200 --> 00:38:48,640
also if we want we can see other

00:38:47,359 --> 00:38:51,040
information such as the

00:38:48,640 --> 00:38:51,920
the values of the registers uh the way

00:38:51,040 --> 00:38:55,440
the memory

00:38:51,920 --> 00:38:57,359
layout looks and uh which regions from

00:38:55,440 --> 00:38:59,280
the mpu were used

00:38:57,359 --> 00:39:02,800
i don't know if you want to add anything

00:38:59,280 --> 00:39:05,839
else else to this alex

00:39:02,800 --> 00:39:07,599
no uh i the thing is like

00:39:05,839 --> 00:39:09,280
alex can send me the binary right now

00:39:07,599 --> 00:39:11,200
and i could run the same app on my

00:39:09,280 --> 00:39:12,400
arduino board and it would work exactly

00:39:11,200 --> 00:39:14,720
in the same way

00:39:12,400 --> 00:39:16,480
um here the kernel actually panicked

00:39:14,720 --> 00:39:18,160
because this is a debug mode but there's

00:39:16,480 --> 00:39:20,560
a setting in tokos

00:39:18,160 --> 00:39:22,800
alex if you could unshare your screen so

00:39:20,560 --> 00:39:26,560
i can share mine

00:39:22,800 --> 00:39:30,320
yes of course uh there's a setting

00:39:26,560 --> 00:39:34,880
in os which okay starts

00:39:30,320 --> 00:39:37,359
just sharing is not working for me

00:39:34,880 --> 00:39:39,119
uh oh sorry it was a problem with the

00:39:37,359 --> 00:39:42,320
browser

00:39:39,119 --> 00:39:43,200
our entire screen okay so getting back

00:39:42,320 --> 00:39:46,400
to my screen

00:39:43,200 --> 00:39:49,440
uh you can see here there's a setting

00:39:46,400 --> 00:39:51,680
setting in uh os

00:39:49,440 --> 00:39:53,280
uh about what to do if an application

00:39:51,680 --> 00:39:55,200
falls uh one is panic

00:39:53,280 --> 00:39:57,119
this is for development so you can see

00:39:55,200 --> 00:39:59,280
the debug

00:39:57,119 --> 00:40:01,040
and the segmentation fold the others are

00:39:59,280 --> 00:40:02,960
just terminate the app and stop it and

00:40:01,040 --> 00:40:03,920
the third one is restart the app so the

00:40:02,960 --> 00:40:06,240
system does not

00:40:03,920 --> 00:40:07,440
uh completely fail if an app actually

00:40:06,240 --> 00:40:11,680
fails

00:40:07,440 --> 00:40:14,319
um yeah that would be it um

00:40:11,680 --> 00:40:15,359
i still i think we still have 10 minutes

00:40:14,319 --> 00:40:18,400
for questions

00:40:15,359 --> 00:40:20,480
uh i have a question here uh

00:40:18,400 --> 00:40:22,640
which says if capsules are grouped

00:40:20,480 --> 00:40:24,319
together to make

00:40:22,640 --> 00:40:26,000
efficient use of interrupt signals from

00:40:24,319 --> 00:40:27,440
hardware in other words is there a limit

00:40:26,000 --> 00:40:28,960
of a number of capsules we can use

00:40:27,440 --> 00:40:29,839
related to the number of interrupt

00:40:28,960 --> 00:40:32,720
signals

00:40:29,839 --> 00:40:33,520
uh and no as far as i know you could use

00:40:32,720 --> 00:40:36,640
uh

00:40:33,520 --> 00:40:40,079
as many capsules uh you want

00:40:36,640 --> 00:40:42,640
uh you do have to make some changes

00:40:40,079 --> 00:40:44,640
i mean interrupts are sent not to the

00:40:42,640 --> 00:40:48,160
capsule but to the lower

00:40:44,640 --> 00:40:51,200
level um if you look at the

00:40:48,160 --> 00:40:53,440
tok os image

00:40:51,200 --> 00:40:55,119
interrupts are in this orange part so

00:40:53,440 --> 00:40:56,960
whenever a hardware has an interrupt it

00:40:55,119 --> 00:40:58,960
goes to this orange part

00:40:56,960 --> 00:41:00,319
and this orange part sends it to a

00:40:58,960 --> 00:41:02,960
capsule technically

00:41:00,319 --> 00:41:04,079
you can have one capsule connected to

00:41:02,960 --> 00:41:06,240
one

00:41:04,079 --> 00:41:09,359
mini driver here in the orange part but

00:41:06,240 --> 00:41:11,280
tocques supports what we call um

00:41:09,359 --> 00:41:13,200
virtual uh drivers where you have a

00:41:11,280 --> 00:41:15,760
virtual capsule that could

00:41:13,200 --> 00:41:17,440
that talks to the lower level capsule

00:41:15,760 --> 00:41:18,960
and distributes the interrupt to upper

00:41:17,440 --> 00:41:21,839
layer capsules

00:41:18,960 --> 00:41:23,119
so yeah technically that's okay uh i

00:41:21,839 --> 00:41:24,720
have another question

00:41:23,119 --> 00:41:27,200
what about running tacos on something

00:41:24,720 --> 00:41:29,280
like the raspberry pi uh

00:41:27,200 --> 00:41:30,720
we as the group in the polytechnica are

00:41:29,280 --> 00:41:33,359
already working on this

00:41:30,720 --> 00:41:34,640
uh we're trying to point it to cortex a

00:41:33,359 --> 00:41:36,720
technically it would work

00:41:34,640 --> 00:41:38,400
it means we need to add the chip and

00:41:36,720 --> 00:41:39,359
memory protection would be probably

00:41:38,400 --> 00:41:41,040
different

00:41:39,359 --> 00:41:42,640
uh the first step would be to use simple

00:41:41,040 --> 00:41:43,599
memory protection with one to one

00:41:42,640 --> 00:41:46,160
mapping and then

00:41:43,599 --> 00:41:49,200
yeah it should work so probably in a

00:41:46,160 --> 00:41:51,760
year it should be okay

00:41:49,200 --> 00:41:52,319
uh sorry i'm just seeing a static screen

00:41:51,760 --> 00:41:55,119
now no

00:41:52,319 --> 00:41:56,720
demo i don't know um this is something

00:41:55,119 --> 00:41:59,520
technical

00:41:56,720 --> 00:42:00,880
uh yeah somebody said i would be

00:41:59,520 --> 00:42:02,800
interested in doing it

00:42:00,880 --> 00:42:04,560
okay sure that would be really really

00:42:02,800 --> 00:42:07,839
nice so uh let's talk

00:42:04,560 --> 00:42:10,240
uh if you can talk to us on this

00:42:07,839 --> 00:42:11,839
on slack that would be great and i think

00:42:10,240 --> 00:42:13,839
i can reply to you

00:42:11,839 --> 00:42:16,160
you have my email on the website so just

00:42:13,839 --> 00:42:20,079
send me an email that would be great

00:42:16,160 --> 00:42:22,640
uh yeah oh i'll write you an email i saw

00:42:20,079 --> 00:42:25,440
your email now

00:42:22,640 --> 00:42:27,200
okay how upgrade how can you upgrade one

00:42:25,440 --> 00:42:29,839
app from multiple applications like

00:42:27,200 --> 00:42:32,000
blink and display

00:42:29,839 --> 00:42:33,440
upgrading an app that's a little bit

00:42:32,000 --> 00:42:36,400
tricky so for now

00:42:33,440 --> 00:42:37,359
apps are located on the flash one after

00:42:36,400 --> 00:42:40,800
the other

00:42:37,359 --> 00:42:43,040
so um if the upgraded app has the same

00:42:40,800 --> 00:42:45,440
size as the previous version that would

00:42:43,040 --> 00:42:46,400
work otherwise yes you would have to

00:42:45,440 --> 00:42:49,599
move the other app

00:42:46,400 --> 00:42:51,680
further on or uh closer to this one uh

00:42:49,599 --> 00:42:54,000
but this is a work in progress so

00:42:51,680 --> 00:42:54,960
the tokens design team is thinking on

00:42:54,000 --> 00:42:56,960
how to better

00:42:54,960 --> 00:42:58,079
how to improve this for now apps are

00:42:56,960 --> 00:43:00,319
just located in the

00:42:58,079 --> 00:43:02,880
flash one after the other so updating

00:43:00,319 --> 00:43:05,760
one of them is difficult if that one app

00:43:02,880 --> 00:43:05,760
is not the last one

00:43:06,960 --> 00:43:15,119
uh okay uh

00:43:13,119 --> 00:43:16,560
i don't know i think i answered most of

00:43:15,119 --> 00:43:20,079
the questions here if there are any

00:43:16,560 --> 00:43:27,839
other questions from the audience

00:43:20,079 --> 00:43:27,839
thomas i'll write an email

00:43:30,079 --> 00:43:37,200
okay if there are any other questions on

00:43:33,839 --> 00:43:39,839
i think we should wait because um

00:43:37,200 --> 00:43:40,480
yeah there's another question ah nice

00:43:39,839 --> 00:43:44,480
work guys

00:43:40,480 --> 00:43:46,240
thank you as i said we're not the

00:43:44,480 --> 00:43:47,599
main developers we just contributed and

00:43:46,240 --> 00:43:49,599
played with it so uh

00:43:47,599 --> 00:43:51,200
there's a big tokus team working every

00:43:49,599 --> 00:43:53,359
day on the top s system so

00:43:51,200 --> 00:43:56,560
um we just contributed a little bit to

00:43:53,359 --> 00:43:56,560
the tokyo system

00:43:58,160 --> 00:44:01,599
okay

00:43:58,680 --> 00:44:05,280
[Music]

00:44:01,599 --> 00:44:07,760
uh alex do you see any other question

00:44:05,280 --> 00:44:08,640
uh yeah thomas also replied they would

00:44:07,760 --> 00:44:11,599
love to use

00:44:08,640 --> 00:44:14,000
with the wassiweb assembly yes we are

00:44:11,599 --> 00:44:17,040
currently working as a side project

00:44:14,000 --> 00:44:21,040
to see if we can run webassembly

00:44:17,040 --> 00:44:21,040
on top of it yeah

00:44:21,200 --> 00:44:26,079
over over us that was the first ride

00:44:23,680 --> 00:44:26,079
that way

00:44:26,400 --> 00:44:33,200
um i think with wassi we had the problem

00:44:30,560 --> 00:44:37,760
we want to continue

00:44:33,200 --> 00:44:39,280
sorry oh no no come on go on

00:44:37,760 --> 00:44:41,520
so with wassi i think the problem was

00:44:39,280 --> 00:44:42,160
that alex really tried the web assembly

00:44:41,520 --> 00:44:44,400
um

00:44:42,160 --> 00:44:46,720
the interpreter that we had the executor

00:44:44,400 --> 00:44:48,480
was technically non-dependent on the

00:44:46,720 --> 00:44:51,680
rust standard library but

00:44:48,480 --> 00:44:54,000
due to a bug in cargo it would still try

00:44:51,680 --> 00:44:56,079
to link the standard library so it was

00:44:54,000 --> 00:44:58,079
impossible for us to uh build it

00:44:56,079 --> 00:45:00,079
i actually have more details on this but

00:44:58,079 --> 00:45:02,720
uh

00:45:00,079 --> 00:45:04,079
yes for for the moment there is only one

00:45:02,720 --> 00:45:06,480
module over rust

00:45:04,079 --> 00:45:08,079
which is able to to interpret

00:45:06,480 --> 00:45:10,319
webassembly code

00:45:08,079 --> 00:45:12,079
uh that is not dependent on the standard

00:45:10,319 --> 00:45:15,119
library standard library

00:45:12,079 --> 00:45:16,960
and this one as alex said has recursive

00:45:15,119 --> 00:45:18,960
dependencies on standard

00:45:16,960 --> 00:45:20,400
on the standard library so what so what

00:45:18,960 --> 00:45:22,560
that means is that

00:45:20,400 --> 00:45:23,680
it has a module which depends on

00:45:22,560 --> 00:45:27,119
standard library

00:45:23,680 --> 00:45:30,640
and even if we uh specify that

00:45:27,119 --> 00:45:33,200
we compile with feature no no std

00:45:30,640 --> 00:45:34,079
it's still uh it still crashes it's a

00:45:33,200 --> 00:45:37,440
cargo bug

00:45:34,079 --> 00:45:40,079
and even in the latest uh cargo issue

00:45:37,440 --> 00:45:41,760
it does not uh work i tried i tried the

00:45:40,079 --> 00:45:44,240
latest the nightly version and it did

00:45:41,760 --> 00:45:44,240
not work

00:45:44,319 --> 00:45:46,960
what so

00:45:48,240 --> 00:45:50,560
okay

00:45:51,599 --> 00:45:54,880
oh sorry to answer thomas question about

00:45:54,160 --> 00:45:57,839
node.js

00:45:54,880 --> 00:45:58,240
uh javascript uh v8 that's a little bit

00:45:57,839 --> 00:46:00,079
big

00:45:58,240 --> 00:46:01,440
for what the microcontroller can do

00:46:00,079 --> 00:46:04,240
probably on the raspberry pi

00:46:01,440 --> 00:46:06,800
it would work um but you can use

00:46:04,240 --> 00:46:07,200
javascript so we tried javascript it's a

00:46:06,800 --> 00:46:09,200
really

00:46:07,200 --> 00:46:11,359
optimized javascript machine it's

00:46:09,200 --> 00:46:12,560
optimized for size fitbit is using it

00:46:11,359 --> 00:46:16,640
for its watches

00:46:12,560 --> 00:46:17,359
i mean it supports um javascript 1.6 i

00:46:16,640 --> 00:46:19,280
think

00:46:17,359 --> 00:46:20,800
uh and you can even write typescript and

00:46:19,280 --> 00:46:22,800
transpile it to

00:46:20,800 --> 00:46:24,640
es5 and run it we did this with

00:46:22,800 --> 00:46:26,839
javascript the only problem is

00:46:24,640 --> 00:46:29,440
memory but otherwise it's working pretty

00:46:26,839 --> 00:46:31,359
well

00:46:29,440 --> 00:46:33,040
did you answer the question about how to

00:46:31,359 --> 00:46:34,160
upgrade one app from multiple

00:46:33,040 --> 00:46:37,359
applications like

00:46:34,160 --> 00:46:38,800
blink and display is that possible okay

00:46:37,359 --> 00:46:42,000
okay yes

00:46:38,800 --> 00:46:44,160
one after the other upgrading one is

00:46:42,000 --> 00:46:45,200
okay if that's the last app if it's an

00:46:44,160 --> 00:46:47,440
app in the middle

00:46:45,200 --> 00:46:50,240
as long as it has the same size that's

00:46:47,440 --> 00:46:53,680
fine uh what you could do is basically

00:46:50,240 --> 00:46:55,839
pad so far the tbf file so that

00:46:53,680 --> 00:46:57,599
um you would have space for further

00:46:55,839 --> 00:46:58,079
updates but this is a work in progress

00:46:57,599 --> 00:47:00,000
we

00:46:58,079 --> 00:47:02,560
the docquest team is working on solving

00:47:00,000 --> 00:47:02,560
this issue

00:47:02,800 --> 00:47:05,760
okay uh

00:47:07,040 --> 00:47:10,400
okay i don't know if we have any more

00:47:09,040 --> 00:47:14,160
questions here

00:47:10,400 --> 00:47:16,720
questions here um thomas also

00:47:14,160 --> 00:47:18,640
added uh as well on which channel we

00:47:16,720 --> 00:47:21,440
will be on

00:47:18,640 --> 00:47:22,800
uh i think on slack on the iot channel

00:47:21,440 --> 00:47:25,119
so i think

00:47:22,800 --> 00:47:26,319
you can i'm just entering the iot

00:47:25,119 --> 00:47:29,599
channel right now so

00:47:26,319 --> 00:47:31,839
um i think it's two track internet of

00:47:29,599 --> 00:47:31,839
things

00:47:34,800 --> 00:47:41,119
yeah yeah yeah slack iot channel yeah

00:47:38,720 --> 00:47:41,119
exactly

00:47:51,040 --> 00:47:55,359
okay well if they're not if there aren't

00:47:53,599 --> 00:47:56,880
any other questions i really hope you

00:47:55,359 --> 00:47:57,839
answered everything thank you so much

00:47:56,880 --> 00:47:59,839
for your attention

00:47:57,839 --> 00:48:01,599
um once again sorry if it was a little

00:47:59,839 --> 00:48:04,800
bit confusing or

00:48:01,599 --> 00:48:08,000
uh we made a mistake it is 1am

00:48:04,800 --> 00:48:11,280
in the morning here so

00:48:08,000 --> 00:48:14,000
and also and also we hope

00:48:11,280 --> 00:48:16,000
we hope that uh at least a bit of the

00:48:14,000 --> 00:48:19,119
demo was able to be seen

00:48:16,000 --> 00:48:21,839
for the person who did not uh did not

00:48:19,119 --> 00:48:21,839

YouTube URL: https://www.youtube.com/watch?v=bTtETFqJXPk


