Title: Building Bare Metal Toolchains, Crosstool-ng and Yocto Project - Mark Hatle, Xilinx
Publication date: 2020-09-10
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	Building Bare Metal Toolchains, Crosstool-ng and Yocto Project - Mark Hatle, Xilinx
Captions: 
	00:00:03,600 --> 00:00:07,600
hello

00:00:04,640 --> 00:00:09,200
uh welcome to uh building bare metal

00:00:07,600 --> 00:00:11,040
tool chains cross tool and g and the

00:00:09,200 --> 00:00:13,360
octa project

00:00:11,040 --> 00:00:14,920
my name is mark hatley uh i'm a senior

00:00:13,360 --> 00:00:17,520
software engineer with

00:00:14,920 --> 00:00:18,960
xilinx and i've also been involved with

00:00:17,520 --> 00:00:21,359
a lot of yakta project things in the

00:00:18,960 --> 00:00:21,359
past

00:00:22,080 --> 00:00:27,199
so recently i was tasked with creating a

00:00:26,400 --> 00:00:30,240
bare metal

00:00:27,199 --> 00:00:32,800
tool chain for one of our products and

00:00:30,240 --> 00:00:34,320
in the past it had been always done with

00:00:32,800 --> 00:00:36,559
crosstool ng

00:00:34,320 --> 00:00:38,480
or they'd been sourced from another

00:00:36,559 --> 00:00:41,520
location such as arm

00:00:38,480 --> 00:00:43,520
and what we were finding is that due to

00:00:41,520 --> 00:00:46,480
limited resources at times

00:00:43,520 --> 00:00:48,559
we needed to be able to go and have

00:00:46,480 --> 00:00:50,480
common bugs common features between the

00:00:48,559 --> 00:00:51,120
linux tool chains the bare metal tool

00:00:50,480 --> 00:00:53,760
chains

00:00:51,120 --> 00:00:54,960
and even non-non-linux non-bare metal

00:00:53,760 --> 00:00:57,120
tool chains

00:00:54,960 --> 00:00:58,320
and so the first step in trying to unify

00:00:57,120 --> 00:01:01,039
all the software

00:00:58,320 --> 00:01:03,840
was to see about can we move from cross

00:01:01,039 --> 00:01:08,159
20 to a yakto project type build

00:01:03,840 --> 00:01:08,159
uh and will this actually help us out

00:01:09,680 --> 00:01:13,840
so what i'm going to quickly go over is

00:01:12,080 --> 00:01:15,119
what cross tool ng is if you don't

00:01:13,840 --> 00:01:16,560
if you don't already know what that is

00:01:15,119 --> 00:01:17,840
if you do know just hold on with me and

00:01:16,560 --> 00:01:20,400
we'll get into the

00:01:17,840 --> 00:01:22,479
the meat of it a bit after that um what

00:01:20,400 --> 00:01:24,880
the octoproject sdk builder is

00:01:22,479 --> 00:01:26,560
how this can work with bare metal tool

00:01:24,880 --> 00:01:28,159
chains

00:01:26,560 --> 00:01:29,520
and and this is the part that i think is

00:01:28,159 --> 00:01:31,840
is the important part is really my

00:01:29,520 --> 00:01:34,960
experiences with doing this

00:01:31,840 --> 00:01:36,079
how we got uh into the octa project

00:01:34,960 --> 00:01:37,520
configurations

00:01:36,079 --> 00:01:39,680
for the bare metal tool chains and then

00:01:37,520 --> 00:01:41,520
finally recommendations on

00:01:39,680 --> 00:01:43,200
if you should even do this and if you

00:01:41,520 --> 00:01:43,840
shouldn't if you should or shouldn't do

00:01:43,200 --> 00:01:46,479
this

00:01:43,840 --> 00:01:48,799
uh when is the right time to consider a

00:01:46,479 --> 00:01:48,799
switch

00:01:49,040 --> 00:01:53,200
so first off is cross 12 g this is what

00:01:51,520 --> 00:01:54,720
a lot of people are using for bare metal

00:01:53,200 --> 00:01:56,640
tool chains

00:01:54,720 --> 00:01:58,079
and when i just to be clear when i talk

00:01:56,640 --> 00:01:59,119
about bare metal tool chains these are

00:01:58,079 --> 00:02:00,880
non

00:01:59,119 --> 00:02:03,360
operating system specific tool chains

00:02:00,880 --> 00:02:06,240
primarily used for boot loaders firmware

00:02:03,360 --> 00:02:06,560
things like that and cross tooling g is

00:02:06,240 --> 00:02:08,959
an

00:02:06,560 --> 00:02:10,640
excellent way to get started building

00:02:08,959 --> 00:02:12,319
bare metal tool chains as well as tool

00:02:10,640 --> 00:02:14,239
chains even for targeting linux

00:02:12,319 --> 00:02:16,879
such as the raspberry pi and things like

00:02:14,239 --> 00:02:20,160
that latest version of cross21g

00:02:16,879 --> 00:02:22,080
is version 1.24

00:02:20,160 --> 00:02:23,680
it's very easy to use it has a menu

00:02:22,080 --> 00:02:24,959
config so if you've ever configured a

00:02:23,680 --> 00:02:26,560
linux kernel you already know what the

00:02:24,959 --> 00:02:29,680
menu config system looks like

00:02:26,560 --> 00:02:31,120
and you just invoke it using ct-ng menu

00:02:29,680 --> 00:02:33,760
config

00:02:31,120 --> 00:02:34,640
and then it also has a very large list

00:02:33,760 --> 00:02:36,800
of

00:02:34,640 --> 00:02:38,160
example tool chains and this is great

00:02:36,800 --> 00:02:40,160
for beginners who just say

00:02:38,160 --> 00:02:41,840
i need an arm 64 tool chain or i need a

00:02:40,160 --> 00:02:45,280
power pc tool chain

00:02:41,840 --> 00:02:48,000
they can go and look at the examples

00:02:45,280 --> 00:02:50,400
and then choose one and then make any

00:02:48,000 --> 00:02:52,400
minor modifications to that it's also

00:02:50,400 --> 00:02:54,160
very very good at doing reproducible

00:02:52,400 --> 00:02:55,599
source builds of tool chains

00:02:54,160 --> 00:02:57,200
so that if you have a problem or you're

00:02:55,599 --> 00:02:58,000
testing a feature or whatever it's very

00:02:57,200 --> 00:02:59,920
easy to keep

00:02:58,000 --> 00:03:01,599
iterating over this and rebuilding tool

00:02:59,920 --> 00:03:05,840
chains and know that you're getting a

00:03:01,599 --> 00:03:07,920
very clear rebuild

00:03:05,840 --> 00:03:10,239
so the other very nice thing about cross

00:03:07,920 --> 00:03:11,440
tool ng is because it's really based on

00:03:10,239 --> 00:03:15,040
the gnu

00:03:11,440 --> 00:03:16,480
gcc framework everything that it builds

00:03:15,040 --> 00:03:19,519
is runtime relocatable

00:03:16,480 --> 00:03:20,560
that means that if i build my my bare

00:03:19,519 --> 00:03:23,440
metal tool chain

00:03:20,560 --> 00:03:25,040
for opt bare metal and then my user

00:03:23,440 --> 00:03:27,280
installs it into opt

00:03:25,040 --> 00:03:29,920
my project it's still going to work fine

00:03:27,280 --> 00:03:31,920
without any changes

00:03:29,920 --> 00:03:33,440
the one downside of the cross tool ng at

00:03:31,920 --> 00:03:35,440
least in my experience has been the

00:03:33,440 --> 00:03:36,799
binaries become very very specific to

00:03:35,440 --> 00:03:38,480
the host they were built on

00:03:36,799 --> 00:03:39,840
and so what you end up doing is using an

00:03:38,480 --> 00:03:42,159
engineering practice called lowest

00:03:39,840 --> 00:03:43,680
common denominator you find out

00:03:42,159 --> 00:03:46,000
what operating system your users are

00:03:43,680 --> 00:03:47,599
going to be using and then

00:03:46,000 --> 00:03:49,440
building for the one that's most

00:03:47,599 --> 00:03:51,200
compatible on all of those

00:03:49,440 --> 00:03:53,840
and so for instance if i've got users

00:03:51,200 --> 00:03:57,120
that are using red hat 7 red hat 8

00:03:53,840 --> 00:03:58,720
ubuntu debian i would probably do my

00:03:57,120 --> 00:04:00,640
builds on red hat 7 because it's the

00:03:58,720 --> 00:04:02,000
oldest out of the set and if i build it

00:04:00,640 --> 00:04:03,439
there i know it's going to work on all

00:04:02,000 --> 00:04:05,280
the various pieces

00:04:03,439 --> 00:04:07,040
the other issue with crosstown g is it

00:04:05,280 --> 00:04:08,799
absolutely can build for sigwin and

00:04:07,040 --> 00:04:10,319
other host operating systems

00:04:08,799 --> 00:04:12,080
but it does require that you already

00:04:10,319 --> 00:04:13,200
have a cygwin compiler it's not going to

00:04:12,080 --> 00:04:16,720
build one for you

00:04:13,200 --> 00:04:16,720
as part of that build process

00:04:16,959 --> 00:04:20,239
and so just an example of what the

00:04:18,320 --> 00:04:21,680
configuration looks like again if you've

00:04:20,239 --> 00:04:22,960
ever done a linux kernel configuration

00:04:21,680 --> 00:04:25,280
you're already seeing these

00:04:22,960 --> 00:04:26,400
these uh windows and how to operate them

00:04:25,280 --> 00:04:27,919
but it's a very simple text

00:04:26,400 --> 00:04:29,520
configuration

00:04:27,919 --> 00:04:31,120
you can use graphic configuration if you

00:04:29,520 --> 00:04:33,520
want but text configuration is the

00:04:31,120 --> 00:04:33,520
standard

00:04:33,759 --> 00:04:37,199
and the output of this is a series of

00:04:36,400 --> 00:04:40,240
features

00:04:37,199 --> 00:04:42,720
ct underscore some option

00:04:40,240 --> 00:04:44,400
such use pipes what flags you want to

00:04:42,720 --> 00:04:45,680
add to the system what architecture

00:04:44,400 --> 00:04:48,080
you're going to do

00:04:45,680 --> 00:04:49,680
and et cetera et cetera and a lot of

00:04:48,080 --> 00:04:51,120
these architecture flights are specific

00:04:49,680 --> 00:04:53,199
to the architecture

00:04:51,120 --> 00:04:55,199
um there's a multi-lib flag do i want to

00:04:53,199 --> 00:04:56,479
create the one librarian targeting or do

00:04:55,199 --> 00:04:59,280
i need to create multiple

00:04:56,479 --> 00:05:00,720
multiple versions and so in the work

00:04:59,280 --> 00:05:02,320
that we've done at xylinks we have to

00:05:00,720 --> 00:05:04,240
create multiple versions

00:05:02,320 --> 00:05:06,400
because we don't know exactly what our

00:05:04,240 --> 00:05:08,639
customers configuration is going to be

00:05:06,400 --> 00:05:10,400
and so we always generate multi-lib tool

00:05:08,639 --> 00:05:11,360
chains so that the customer can choose

00:05:10,400 --> 00:05:15,360
the right version

00:05:11,360 --> 00:05:15,360
for their targeted application

00:05:16,400 --> 00:05:20,240
and so when you actually run crosstown g

00:05:18,720 --> 00:05:22,080
and start the build process you get

00:05:20,240 --> 00:05:24,400
windows that look something like this

00:05:22,080 --> 00:05:26,080
where it starts out it pervert uh starts

00:05:24,400 --> 00:05:28,720
performing various sanity checks

00:05:26,080 --> 00:05:30,400
various compilations uh everything else

00:05:28,720 --> 00:05:32,880
and then it finally gets to the end

00:05:30,400 --> 00:05:34,400
and um it finishes writes out the files

00:05:32,880 --> 00:05:35,039
and tells you where it wrote out the

00:05:34,400 --> 00:05:36,400
files

00:05:35,039 --> 00:05:38,080
and then from that point on you can just

00:05:36,400 --> 00:05:39,520
use the tool chain or you can package it

00:05:38,080 --> 00:05:42,560
up and and give it to somebody else

00:05:39,520 --> 00:05:42,560
that's going to use it for you

00:05:44,000 --> 00:05:47,280
so now let's switch over to the octa

00:05:45,919 --> 00:05:50,000
project

00:05:47,280 --> 00:05:52,000
how is this different the yakta project

00:05:50,000 --> 00:05:53,600
is not just focused on tool chains tool

00:05:52,000 --> 00:05:55,520
chains is actually quite a small part of

00:05:53,600 --> 00:05:58,160
the octa project but it's in

00:05:55,520 --> 00:05:59,759
uh it's a very nice necessary part of

00:05:58,160 --> 00:06:02,080
the octa project

00:05:59,759 --> 00:06:04,080
and so the octa project itself is really

00:06:02,080 --> 00:06:06,000
a full distribution build environment

00:06:04,080 --> 00:06:07,600
um so everything starts with a

00:06:06,000 --> 00:06:09,840
distribution configuration

00:06:07,600 --> 00:06:11,360
you have local project configurations

00:06:09,840 --> 00:06:12,639
and then you have machine or target

00:06:11,360 --> 00:06:14,800
configurations

00:06:12,639 --> 00:06:16,560
this combination of configurations

00:06:14,800 --> 00:06:18,240
actually defines what you want to build

00:06:16,560 --> 00:06:19,520
and how you want to build it

00:06:18,240 --> 00:06:22,880
and then it does it through a standard

00:06:19,520 --> 00:06:25,919
mechanism um the octa project

00:06:22,880 --> 00:06:28,160
while linux is its main focus

00:06:25,919 --> 00:06:29,840
is not actually linux specific and so

00:06:28,160 --> 00:06:33,199
you can absolutely build bare metal

00:06:29,840 --> 00:06:35,280
free rtos open amp um we've seen other

00:06:33,199 --> 00:06:37,840
things being built with it that's that's

00:06:35,280 --> 00:06:39,600
fairly interesting sometimes um the

00:06:37,840 --> 00:06:42,000
outputs of the octa project

00:06:39,600 --> 00:06:42,880
um primarily are runtime images for

00:06:42,000 --> 00:06:44,960
users so

00:06:42,880 --> 00:06:46,560
disk images but they don't have to be

00:06:44,960 --> 00:06:49,199
and so you can build an sdk

00:06:46,560 --> 00:06:50,639
which is the traditional tool chain that

00:06:49,199 --> 00:06:52,560
crosstool ng would

00:06:50,639 --> 00:06:54,240
be creating or you can build what's

00:06:52,560 --> 00:06:56,800
called an esdk

00:06:54,240 --> 00:06:58,240
which is not only a tool chain but it's

00:06:56,800 --> 00:07:00,240
also the full build environment so that

00:06:58,240 --> 00:07:01,919
you can make modifications to it

00:07:00,240 --> 00:07:03,680
or the applications that were built with

00:07:01,919 --> 00:07:05,840
it and then regenerate them

00:07:03,680 --> 00:07:08,080
for the purposes of this presentation

00:07:05,840 --> 00:07:09,599
i'm really only talking about the sdk

00:07:08,080 --> 00:07:11,680
because it's really the mapping that

00:07:09,599 --> 00:07:16,080
that matches closest to what crosstalk

00:07:11,680 --> 00:07:19,199
you can do and so as i said with the

00:07:16,080 --> 00:07:21,120
the um before is the octa project sdk

00:07:19,199 --> 00:07:22,800
is that mapping and there's really a

00:07:21,120 --> 00:07:25,919
couple of different ways that the the

00:07:22,800 --> 00:07:29,120
yacht project sdk itself can be defined

00:07:25,919 --> 00:07:32,160
um there's a target sd targeted sdk

00:07:29,120 --> 00:07:33,840
what this is is i'm going to say i'm

00:07:32,160 --> 00:07:35,280
going to build a linux operating system

00:07:33,840 --> 00:07:36,560
i want all of these things in my linux

00:07:35,280 --> 00:07:39,280
operating system

00:07:36,560 --> 00:07:40,080
oh and build me an sdk that i'm that you

00:07:39,280 --> 00:07:42,080
know will

00:07:40,080 --> 00:07:43,840
allow my users to create applications

00:07:42,080 --> 00:07:45,599
for that so you're not really defining

00:07:43,840 --> 00:07:46,160
the sdk you're letting the system define

00:07:45,599 --> 00:07:47,759
it

00:07:46,160 --> 00:07:49,280
and then there's a secondary one which

00:07:47,759 --> 00:07:50,720
again is going back is

00:07:49,280 --> 00:07:52,639
is really the one i'm talking about

00:07:50,720 --> 00:07:55,680
which is called a defined sdk

00:07:52,639 --> 00:07:57,759
this is really where the sdk is

00:07:55,680 --> 00:08:00,080
specified component by component by

00:07:57,759 --> 00:08:02,639
component i must have been utils i must

00:08:00,080 --> 00:08:04,160
have gcc i must have new lib i must have

00:08:02,639 --> 00:08:06,000
lib gloss

00:08:04,160 --> 00:08:08,000
things like that and then of course the

00:08:06,000 --> 00:08:10,000
sdks can be multi-lib enabled

00:08:08,000 --> 00:08:11,680
and the octa project and cross tool and

00:08:10,000 --> 00:08:14,160
g do handle multi-labs a little bit

00:08:11,680 --> 00:08:14,160
differently

00:08:14,479 --> 00:08:16,960
um so actually there was a question in

00:08:15,759 --> 00:08:18,080
the chat let me answer that quickly

00:08:16,960 --> 00:08:18,479
because i think it's a good time to do

00:08:18,080 --> 00:08:20,720
it

00:08:18,479 --> 00:08:23,360
uh what give what's an example of

00:08:20,720 --> 00:08:25,599
modifications you can make with an e-sdk

00:08:23,360 --> 00:08:26,800
so for bare metal i'm really not sure if

00:08:25,599 --> 00:08:29,440
it's a good use case

00:08:26,800 --> 00:08:31,199
but for the general case the esdk would

00:08:29,440 --> 00:08:33,200
allow you to say change

00:08:31,199 --> 00:08:36,080
a new lib and then regenerate your tool

00:08:33,200 --> 00:08:37,200
chain i would allow you to change

00:08:36,080 --> 00:08:38,640
if you're doing linux build an

00:08:37,200 --> 00:08:40,240
application i want to make a

00:08:38,640 --> 00:08:42,479
configuration change

00:08:40,240 --> 00:08:43,760
to my security modules and then you'd be

00:08:42,479 --> 00:08:46,560
able to make that configuration change

00:08:43,760 --> 00:08:46,560
and move on from that

00:08:49,360 --> 00:08:53,839
so the octa project sk output of it is a

00:08:52,320 --> 00:08:54,959
self extracting this is a

00:08:53,839 --> 00:08:57,760
sh file but it's really a

00:08:54,959 --> 00:09:00,720
self-extracting shell script

00:08:57,760 --> 00:09:01,519
and the nice thing about this is inside

00:09:00,720 --> 00:09:04,240
of that

00:09:01,519 --> 00:09:06,320
extracted archive is really an entirely

00:09:04,240 --> 00:09:07,600
self-contained sdk environment and why i

00:09:06,320 --> 00:09:08,000
say self-contained that means it

00:09:07,600 --> 00:09:09,680
provides

00:09:08,000 --> 00:09:11,600
its own geolocy its own runtime

00:09:09,680 --> 00:09:13,200
components everything required for those

00:09:11,600 --> 00:09:14,320
applications and libraries to work

00:09:13,200 --> 00:09:17,519
properly

00:09:14,320 --> 00:09:17,839
the sdk can also build cross compilers

00:09:17,519 --> 00:09:19,600
for

00:09:17,839 --> 00:09:21,519
cygwin and other environments as needed

00:09:19,600 --> 00:09:22,320
so if you're building an sdk to target

00:09:21,519 --> 00:09:24,080
cygwin

00:09:22,320 --> 00:09:25,360
from your linux machine you don't have

00:09:24,080 --> 00:09:26,800
to provide a cygwin

00:09:25,360 --> 00:09:28,480
compiler all you have to do is say i

00:09:26,800 --> 00:09:30,959
want the output to be cygwin it'll say

00:09:28,480 --> 00:09:34,399
oh i also need to build a cygwin

00:09:30,959 --> 00:09:36,240
compiler and so those two items itself

00:09:34,399 --> 00:09:38,240
eliminate one of the downfalls of what i

00:09:36,240 --> 00:09:39,519
saw in the crosstown g which is i don't

00:09:38,240 --> 00:09:41,040
have to focus on lowe's common

00:09:39,519 --> 00:09:44,640
denominator anymore

00:09:41,040 --> 00:09:47,680
and i don't have to have a magic sigwin

00:09:44,640 --> 00:09:48,480
compiler somewhere to point across 21g

00:09:47,680 --> 00:09:50,320
at

00:09:48,480 --> 00:09:51,839
however is a downside to what the octa

00:09:50,320 --> 00:09:53,040
project does compared to

00:09:51,839 --> 00:09:56,160
cross tool and g and that's that

00:09:53,040 --> 00:09:58,240
automatic relocation the sdk itself

00:09:56,160 --> 00:09:59,760
because of providing all of the

00:09:58,240 --> 00:10:01,440
environment components

00:09:59,760 --> 00:10:02,959
actually has things referenced and

00:10:01,440 --> 00:10:05,839
configurations linked to

00:10:02,959 --> 00:10:07,680
the installation location and so if you

00:10:05,839 --> 00:10:09,200
change that installation location it can

00:10:07,680 --> 00:10:10,959
no longer find the glibc

00:10:09,200 --> 00:10:12,560
version that came with or some of the

00:10:10,959 --> 00:10:13,360
other real-time components that it came

00:10:12,560 --> 00:10:15,760
with

00:10:13,360 --> 00:10:17,440
and so the sacrifice is you lose the

00:10:15,760 --> 00:10:20,240
automatic runtime relocation in the

00:10:17,440 --> 00:10:22,000
normally octa project sdk

00:10:20,240 --> 00:10:24,480
for a lot of users this really isn't a

00:10:22,000 --> 00:10:26,399
big deal but i do know that

00:10:24,480 --> 00:10:28,640
for some corporate users they like to

00:10:26,399 --> 00:10:30,480
have it install it in an nfs share

00:10:28,640 --> 00:10:31,760
and then the users mount that nfs share

00:10:30,480 --> 00:10:34,000
in random places

00:10:31,760 --> 00:10:35,360
if everybody mounted that nfs share to

00:10:34,000 --> 00:10:37,760
the same exact path

00:10:35,360 --> 00:10:39,279
that it was the original install was on

00:10:37,760 --> 00:10:40,240
it would work just fine it's really only

00:10:39,279 --> 00:10:43,600
when the path

00:10:40,240 --> 00:10:45,440
changes so an example of the octa

00:10:43,600 --> 00:10:47,120
project build environment

00:10:45,440 --> 00:10:48,720
the first thing that we always do is we

00:10:47,120 --> 00:10:51,040
run an oent build envy

00:10:48,720 --> 00:10:51,920
this sets up the runtime environment uh

00:10:51,040 --> 00:10:53,600
we can then

00:10:51,920 --> 00:10:56,000
edit our configuration files under the

00:10:53,600 --> 00:10:58,480
conf directory primarily comp

00:10:56,000 --> 00:11:00,079
local.conf or we can pass some of these

00:10:58,480 --> 00:11:03,519
things in on the command line

00:11:00,079 --> 00:11:05,120
and so in the example here i'm passing

00:11:03,519 --> 00:11:06,800
in that i want to build a xilinx

00:11:05,120 --> 00:11:08,320
standalone distribution which is

00:11:06,800 --> 00:11:10,320
something that i defined

00:11:08,320 --> 00:11:12,000
i want the machine to be my microblaze

00:11:10,320 --> 00:11:13,519
tool chain definition

00:11:12,000 --> 00:11:15,200
and then i'm going to build my meta tool

00:11:13,519 --> 00:11:16,800
chain and my meta tool chain is that

00:11:15,200 --> 00:11:18,320
defined sdk

00:11:16,800 --> 00:11:19,760
and the results of that is what you see

00:11:18,320 --> 00:11:21,200
in the window on the right because i

00:11:19,760 --> 00:11:22,320
have a whole bunch of things building

00:11:21,200 --> 00:11:23,600
all at once

00:11:22,320 --> 00:11:25,920
and you may not be able to see it on

00:11:23,600 --> 00:11:29,040
your screen but there are about 7 000

00:11:25,920 --> 00:11:31,120
tasks that it's going to execute

00:11:29,040 --> 00:11:33,360
if if you compare this against crosstool

00:11:31,120 --> 00:11:37,760
ng doing exactly the same build

00:11:33,360 --> 00:11:39,279
cross 21 g does significantly less work

00:11:37,760 --> 00:11:40,800
some of this is because of the way the

00:11:39,279 --> 00:11:44,880
octa project is defined

00:11:40,800 --> 00:11:44,880
some of it is actually because of um

00:11:45,600 --> 00:11:49,279
there are additional safety systems

00:11:47,600 --> 00:11:52,880
built into the octa project to prevent

00:11:49,279 --> 00:11:56,399
contamination between multi lips

00:11:52,880 --> 00:11:59,120
and so if that magic

00:11:56,399 --> 00:12:00,720
xilinx standalone configuration i pulled

00:11:59,120 --> 00:12:02,160
out some of the relevant uh

00:12:00,720 --> 00:12:03,760
configuration lines just kind of show

00:12:02,160 --> 00:12:05,120
you what they are

00:12:03,760 --> 00:12:06,959
the first thing that we want to do is we

00:12:05,120 --> 00:12:08,639
actually want to define what is this

00:12:06,959 --> 00:12:10,959
distribution

00:12:08,639 --> 00:12:11,760
um and from that definition you can see

00:12:10,959 --> 00:12:14,160
that

00:12:11,760 --> 00:12:15,600
uh it's designing standalone we've got a

00:12:14,160 --> 00:12:17,519
version number so that we can change

00:12:15,600 --> 00:12:19,279
that if necessary we have a target

00:12:17,519 --> 00:12:21,839
vendor that way we know that this is

00:12:19,279 --> 00:12:22,959
typed specifically for xilinx

00:12:21,839 --> 00:12:24,240
if you're another company you just put

00:12:22,959 --> 00:12:26,160
your company name in or if it's a

00:12:24,240 --> 00:12:29,440
product you put your product name in

00:12:26,160 --> 00:12:31,200
we set up our lib c to be nulib because

00:12:29,440 --> 00:12:32,639
for bare metal it's generally what what

00:12:31,200 --> 00:12:33,839
you end up using even if you don't

00:12:32,639 --> 00:12:35,200
actually use new lib for your

00:12:33,839 --> 00:12:37,519
compilation

00:12:35,200 --> 00:12:38,560
and then we wanted to have a very

00:12:37,519 --> 00:12:42,639
specific version

00:12:38,560 --> 00:12:45,600
uh sdk version is embedded in the name

00:12:42,639 --> 00:12:47,200
of the sdk file that is generated and so

00:12:45,600 --> 00:12:48,880
we wanted to be very clear that this was

00:12:47,200 --> 00:12:50,480
called xilinx standalone

00:12:48,880 --> 00:12:52,240
so that there wasn't any confusion with

00:12:50,480 --> 00:12:54,160
anything maybe arm would ship or

00:12:52,240 --> 00:12:55,600
that we've shipped in the past or

00:12:54,160 --> 00:12:58,560
whatever so that's kind of where

00:12:55,600 --> 00:12:58,560
those variables come from

00:12:58,800 --> 00:13:02,959
i also needed to say that we needed to

00:13:00,959 --> 00:13:04,800
have specific static libraries

00:13:02,959 --> 00:13:06,800
by default the octa project generally

00:13:04,800 --> 00:13:07,600
does not install static libraries into

00:13:06,800 --> 00:13:08,880
an sdk

00:13:07,600 --> 00:13:11,600
this is primarily for license

00:13:08,880 --> 00:13:13,279
contamination reasons on most

00:13:11,600 --> 00:13:15,279
full operating systems you don't really

00:13:13,279 --> 00:13:17,040
want to use static libraries

00:13:15,279 --> 00:13:18,480
but that that does not hold true for

00:13:17,040 --> 00:13:21,440
bare metal so that's where the

00:13:18,480 --> 00:13:24,639
lipstick dependencies comes in we also

00:13:21,440 --> 00:13:26,800
need to clear some normal defaults

00:13:24,639 --> 00:13:27,680
i won't go over those too much that'd be

00:13:26,800 --> 00:13:29,279
something that

00:13:27,680 --> 00:13:31,519
if you're really curious why we have to

00:13:29,279 --> 00:13:34,000
do that

00:13:31,519 --> 00:13:35,600
ask me in slack afterwards or ask on the

00:13:34,000 --> 00:13:36,959
octa project mailing list and i'm happy

00:13:35,600 --> 00:13:38,720
to help you out and explain this a

00:13:36,959 --> 00:13:41,839
little bit more in detail

00:13:38,720 --> 00:13:43,199
and then finally for mingw

00:13:41,839 --> 00:13:45,120
we actually found an issue with bare

00:13:43,199 --> 00:13:46,399
metal tool chains that we have to very

00:13:45,120 --> 00:13:48,240
very specifically say

00:13:46,399 --> 00:13:50,639
i have to have the p threads library in

00:13:48,240 --> 00:13:52,000
order for this to work from mingw

00:13:50,639 --> 00:13:54,399
and so that's where the very last line

00:13:52,000 --> 00:13:57,760
comes in so it's really a workaround for

00:13:54,399 --> 00:13:59,839
for probably a bug and those items

00:13:57,760 --> 00:14:03,839
those bug work runs are going to go back

00:13:59,839 --> 00:14:03,839
upstream as i continue to do my work

00:14:04,240 --> 00:14:09,120
so the second piece of it then is this

00:14:06,639 --> 00:14:12,560
microblaze tool chain configuration

00:14:09,120 --> 00:14:13,120
how do i actually define a configuration

00:14:12,560 --> 00:14:15,600
that has

00:14:13,120 --> 00:14:17,120
all of the multi libs in it that i need

00:14:15,600 --> 00:14:19,680
and this configuration

00:14:17,120 --> 00:14:21,600
is very much extreme this is not a

00:14:19,680 --> 00:14:23,519
typical yakuto project thing but this is

00:14:21,600 --> 00:14:26,160
something that we needed because

00:14:23,519 --> 00:14:28,000
uh for the xylinks microblaze i think we

00:14:26,160 --> 00:14:29,680
have defined 48 configuration

00:14:28,000 --> 00:14:31,680
48 multi libs right now but if you

00:14:29,680 --> 00:14:33,760
actually do the conf

00:14:31,680 --> 00:14:36,480
the combinatorial on it it's well over

00:14:33,760 --> 00:14:38,240
100 that that are possible to configure

00:14:36,480 --> 00:14:40,240
and that's all because the microblaze is

00:14:38,240 --> 00:14:44,000
an fpga

00:14:40,240 --> 00:14:46,160
dynamic software processor

00:14:44,000 --> 00:14:47,920
software as opposed that it's running on

00:14:46,160 --> 00:14:49,839
the fpga

00:14:47,920 --> 00:14:51,279
so the first thing that we have to do is

00:14:49,839 --> 00:14:52,720
we have to set a variable called

00:14:51,279 --> 00:14:53,680
multi-lip global variants this is

00:14:52,720 --> 00:14:56,800
basically

00:14:53,680 --> 00:14:57,760
these are all of the vari the multi-lib

00:14:56,800 --> 00:14:59,440
variants that are

00:14:57,760 --> 00:15:01,120
that are allowed in the system by

00:14:59,440 --> 00:15:04,560
default multi-lib global vari

00:15:01,120 --> 00:15:08,000
variance is very simple and it's just um

00:15:04,560 --> 00:15:09,440
32 and 64. but that's not really what

00:15:08,000 --> 00:15:10,959
we're defining in this case what we're

00:15:09,440 --> 00:15:14,000
defining is things like

00:15:10,959 --> 00:15:17,600
um mble mbs

00:15:14,000 --> 00:15:18,880
bs uh mbp and on and on and on and then

00:15:17,600 --> 00:15:20,639
you can even see the last one there

00:15:18,880 --> 00:15:23,360
which is quite a complex

00:15:20,639 --> 00:15:24,720
uh which is mb microblaze le little

00:15:23,360 --> 00:15:28,639
endian m64

00:15:24,720 --> 00:15:32,240
64 64-bit uh bs um which is the uh

00:15:28,639 --> 00:15:34,000
uh barrel shift um and then it's

00:15:32,240 --> 00:15:35,279
mf which is a hardware floating point

00:15:34,000 --> 00:15:36,720
unit and i don't even remember what the

00:15:35,279 --> 00:15:38,639
pd part is at the end

00:15:36,720 --> 00:15:41,440
so you can see that there's quite a few

00:15:38,639 --> 00:15:42,800
things for each of the configurations we

00:15:41,440 --> 00:15:45,680
then need to define

00:15:42,800 --> 00:15:47,440
exactly what our default tune is if the

00:15:45,680 --> 00:15:49,519
default tune is already defined within

00:15:47,440 --> 00:15:51,279
the octa project then i can just set

00:15:49,519 --> 00:15:52,480
default tune equals and leave it at that

00:15:51,279 --> 00:15:53,440
i don't have to set any of the other

00:15:52,480 --> 00:15:55,680
things

00:15:53,440 --> 00:15:57,440
microblaze though is unique because it

00:15:55,680 --> 00:15:58,959
is a configurable processor there really

00:15:57,440 --> 00:16:01,680
are no default tunes

00:15:58,959 --> 00:16:03,360
defined and so i have to manually define

00:16:01,680 --> 00:16:05,040
each one of these

00:16:03,360 --> 00:16:07,199
and in this example you can see the base

00:16:05,040 --> 00:16:08,639
one is simply microblaze

00:16:07,199 --> 00:16:10,560
and all we're doing is saying this is a

00:16:08,639 --> 00:16:11,360
big indian microblaze with no additional

00:16:10,560 --> 00:16:13,040
features

00:16:11,360 --> 00:16:15,199
and that's it and then we define a

00:16:13,040 --> 00:16:16,959
little indian version and then we define

00:16:15,199 --> 00:16:18,880
a barrel shift version which is really a

00:16:16,959 --> 00:16:20,639
big endian with barrel shift and if

00:16:18,880 --> 00:16:22,399
you keep looking down the file then

00:16:20,639 --> 00:16:25,120
there's a little endian barrel shift and

00:16:22,399 --> 00:16:25,120
on and on and on

00:16:26,480 --> 00:16:33,839
so with the octa project um

00:16:30,560 --> 00:16:35,519
what actually changes

00:16:33,839 --> 00:16:39,040
compared to cross tool and g or compared

00:16:35,519 --> 00:16:40,399
to how how we used to build this stuff

00:16:39,040 --> 00:16:42,160
one of the biggest things that we found

00:16:40,399 --> 00:16:43,040
is that crosstool ng has a very

00:16:42,160 --> 00:16:46,480
different set

00:16:43,040 --> 00:16:48,800
of default arguments for

00:16:46,480 --> 00:16:49,680
bin utils and so when i say default

00:16:48,800 --> 00:16:52,240
arguments this is

00:16:49,680 --> 00:16:53,519
configure arguments uh this is the way

00:16:52,240 --> 00:16:55,120
that patches are applied

00:16:53,519 --> 00:16:57,360
and some things like that so we had a

00:16:55,120 --> 00:17:00,480
lot of work to do to reconcile this

00:16:57,360 --> 00:17:02,639
it turns out in the end that this really

00:17:00,480 --> 00:17:04,480
wasn't a cross tool in g issue

00:17:02,639 --> 00:17:07,520
it's really a whoever defined that

00:17:04,480 --> 00:17:10,319
configuration for crosstool and g

00:17:07,520 --> 00:17:12,000
um they said a whole bunch of things and

00:17:10,319 --> 00:17:13,679
the reason they set these things has

00:17:12,000 --> 00:17:15,760
kind of been lost to history

00:17:13,679 --> 00:17:17,439
um they either don't work for xilinx

00:17:15,760 --> 00:17:18,240
anymore or they were an open source

00:17:17,439 --> 00:17:20,400
person

00:17:18,240 --> 00:17:21,919
and it all made sense at the time but it

00:17:20,400 --> 00:17:24,240
was never really tracked

00:17:21,919 --> 00:17:26,319
why a specific option was set and the

00:17:24,240 --> 00:17:28,559
octa project's been very good at

00:17:26,319 --> 00:17:30,080
reevaluating these options over time and

00:17:28,559 --> 00:17:31,280
removing ones that don't make sense

00:17:30,080 --> 00:17:32,880
anymore

00:17:31,280 --> 00:17:35,120
and we have exactly the same behavior

00:17:32,880 --> 00:17:37,360
with gcc um

00:17:35,120 --> 00:17:39,120
and uh one of the things that the octo

00:17:37,360 --> 00:17:44,320
project typically does

00:17:39,120 --> 00:17:46,880
was that it builds um gcc multiple times

00:17:44,320 --> 00:17:48,480
one for each multi-lib and for our bare

00:17:46,880 --> 00:17:51,440
metal we didn't want that behavior

00:17:48,480 --> 00:17:53,039
it was for 48 multi-libs that's insane

00:17:51,440 --> 00:17:53,919
and so we actually had to put a patch

00:17:53,039 --> 00:17:56,240
into the system

00:17:53,919 --> 00:17:58,559
that builds gcc once turns on the

00:17:56,240 --> 00:17:59,679
multi-lib configuration option in gcc

00:17:58,559 --> 00:18:02,720
itself

00:17:59,679 --> 00:18:04,400
but it actually creates all sim links as

00:18:02,720 --> 00:18:05,039
the alternative names that way we

00:18:04,400 --> 00:18:07,840
preserve

00:18:05,039 --> 00:18:09,280
the yakto project interfaces but we only

00:18:07,840 --> 00:18:11,919
build it once and it

00:18:09,280 --> 00:18:13,440
doesn't so much save build time but it

00:18:11,919 --> 00:18:16,559
definitely saves disk space

00:18:13,440 --> 00:18:19,440
it's significantly smaller

00:18:16,559 --> 00:18:21,360
we also had to re-enable some previous

00:18:19,440 --> 00:18:22,880
options in gcc for the new lib

00:18:21,360 --> 00:18:24,880
configuration

00:18:22,880 --> 00:18:27,200
the default new loop configuration in

00:18:24,880 --> 00:18:29,200
the octa project

00:18:27,200 --> 00:18:30,559
for whatever reason isn't compatible

00:18:29,200 --> 00:18:31,679
with some of the things that we've done

00:18:30,559 --> 00:18:32,960
in the past

00:18:31,679 --> 00:18:34,799
and we needed to make sure that the

00:18:32,960 --> 00:18:36,480
compatibility was was kept

00:18:34,799 --> 00:18:38,080
i'm unfortunately not a new lib expert

00:18:36,480 --> 00:18:39,760
by any means so

00:18:38,080 --> 00:18:41,120
i'm going by what other people have told

00:18:39,760 --> 00:18:42,720
me on this that they basically said no

00:18:41,120 --> 00:18:45,440
no you have to have this option set or

00:18:42,720 --> 00:18:47,200
it's not going to work properly

00:18:45,440 --> 00:18:48,480
and then finally the new lib libgloss we

00:18:47,200 --> 00:18:51,919
did have to adjust the work

00:18:48,480 --> 00:18:53,679
uh the defaults we also had to add some

00:18:51,919 --> 00:18:55,280
code to the octa project to deal with

00:18:53,679 --> 00:18:57,360
multi-lib conflicts

00:18:55,280 --> 00:18:58,720
this is code that i do intend to submit

00:18:57,360 --> 00:19:00,960
back to the octa project

00:18:58,720 --> 00:19:02,480
um i'm working on updating to the

00:19:00,960 --> 00:19:03,120
current version the octa project right

00:19:02,480 --> 00:19:05,280
now

00:19:03,120 --> 00:19:06,320
and as that work uh gets further along

00:19:05,280 --> 00:19:08,000
i'll actually have patches

00:19:06,320 --> 00:19:09,679
that that can go to the master version

00:19:08,000 --> 00:19:12,640
the octa project

00:19:09,679 --> 00:19:14,480
and then there was also an issue where

00:19:12,640 --> 00:19:14,799
libgloss new lib just always assumed

00:19:14,480 --> 00:19:17,840
that

00:19:14,799 --> 00:19:19,679
because they weren't multi-lib that only

00:19:17,840 --> 00:19:21,280
one single dependency was fine

00:19:19,679 --> 00:19:23,120
but the octa project has multi-lib

00:19:21,280 --> 00:19:24,640
dependencies as well so i had to teach

00:19:23,120 --> 00:19:26,160
the the

00:19:24,640 --> 00:19:28,720
lip gloss and new lip those multi-lip

00:19:26,160 --> 00:19:28,720
dependencies

00:19:29,360 --> 00:19:33,280
so let's take a quick look at the

00:19:31,600 --> 00:19:34,640
difference between them just based on up

00:19:33,280 --> 00:19:38,480
to this point

00:19:34,640 --> 00:19:41,679
so crosstown g is very easy to configure

00:19:38,480 --> 00:19:44,000
it's functionally limited to tool chains

00:19:41,679 --> 00:19:44,880
operating system dependencies runtime

00:19:44,000 --> 00:19:46,720
relocation

00:19:44,880 --> 00:19:48,160
is great in it it does exactly what a

00:19:46,720 --> 00:19:50,400
lot of people want

00:19:48,160 --> 00:19:52,160
mingw is definitely there but it does

00:19:50,400 --> 00:19:55,280
require that external compiler

00:19:52,160 --> 00:19:57,200
on the octa project side though um we

00:19:55,280 --> 00:19:59,280
have sample configurations for linux but

00:19:57,200 --> 00:20:01,840
bare metal is very limited so i had to

00:19:59,280 --> 00:20:04,960
figure most of this out myself

00:20:01,840 --> 00:20:08,159
i would not call it easy

00:20:04,960 --> 00:20:09,360
for tool chain side i think that um it's

00:20:08,159 --> 00:20:11,039
well it's capable of doing a lot more

00:20:09,360 --> 00:20:12,320
than tool chains for the purpose of this

00:20:11,039 --> 00:20:14,320
comparison though they're basically

00:20:12,320 --> 00:20:16,640
functionally equivalent

00:20:14,320 --> 00:20:18,080
um the yocto project though does have

00:20:16,640 --> 00:20:20,799
that host operating separation

00:20:18,080 --> 00:20:21,520
but at the expense of then the the

00:20:20,799 --> 00:20:22,960
installed

00:20:21,520 --> 00:20:24,559
tool chains are no longer runtime

00:20:22,960 --> 00:20:27,440
relocatable they're installed time

00:20:24,559 --> 00:20:29,520
relocatable but not run time relocatable

00:20:27,440 --> 00:20:31,520
and then finally it will automatically

00:20:29,520 --> 00:20:35,840
generate anything needed for the

00:20:31,520 --> 00:20:35,840
mingw output

00:20:35,919 --> 00:20:39,520
so let's get in some some further

00:20:37,520 --> 00:20:43,440
experiences on this

00:20:39,520 --> 00:20:46,720
um so now transitioning from crosstown g

00:20:43,440 --> 00:20:49,039
to the octa project sdk

00:20:46,720 --> 00:20:51,520
i'll recap why we had to do this it

00:20:49,039 --> 00:20:54,799
really was unifying the source code

00:20:51,520 --> 00:20:55,919
and a lot of a lot of people questioned

00:20:54,799 --> 00:20:57,600
it when i first

00:20:55,919 --> 00:20:58,960
brought this up inside the company well

00:20:57,600 --> 00:21:00,400
why do we have to do this bare metal is

00:20:58,960 --> 00:21:01,600
a very different use case than the linux

00:21:00,400 --> 00:21:04,720
use case

00:21:01,600 --> 00:21:06,480
and very soon after the project

00:21:04,720 --> 00:21:09,360
was started we actually ran into a

00:21:06,480 --> 00:21:11,360
really good example on why this helps

00:21:09,360 --> 00:21:12,559
we had somebody that was trying to debug

00:21:11,360 --> 00:21:13,679
bare metal tool chains

00:21:12,559 --> 00:21:15,679
and the debugger hit a certain

00:21:13,679 --> 00:21:16,000
instruction and failed and they really

00:21:15,679 --> 00:21:18,960
didn't

00:21:16,000 --> 00:21:19,760
know why it failed they could use the

00:21:18,960 --> 00:21:21,200
octoproject

00:21:19,760 --> 00:21:23,039
bare metal tool chain and the

00:21:21,200 --> 00:21:25,039
instruction did not fail

00:21:23,039 --> 00:21:26,880
and it turns out it was a combination of

00:21:25,039 --> 00:21:28,640
yokto project configuration

00:21:26,880 --> 00:21:30,559
and a patch that was in the octa project

00:21:28,640 --> 00:21:32,080
to fix a linux bug

00:21:30,559 --> 00:21:33,919
and it just so happened that that linux

00:21:32,080 --> 00:21:35,440
bug also affected bare metal

00:21:33,919 --> 00:21:37,440
but for whatever reason had never been

00:21:35,440 --> 00:21:38,320
back ported to the xilinx cross tool and

00:21:37,440 --> 00:21:42,400
g version of the

00:21:38,320 --> 00:21:43,760
of this gdb and so by creating it

00:21:42,400 --> 00:21:45,520
by ensuring that we're using the same

00:21:43,760 --> 00:21:45,840
source code generally speaking we're

00:21:45,520 --> 00:21:48,240
both

00:21:45,840 --> 00:21:49,760
bug and feature compatible now and so

00:21:48,240 --> 00:21:52,080
somebody fixes one problem they're

00:21:49,760 --> 00:21:54,960
probably fixing it in both uh systems

00:21:52,080 --> 00:21:56,559
and so it really proved the point that

00:21:54,960 --> 00:22:00,159
we saved a bunch of engineering time by

00:21:56,559 --> 00:22:03,120
unifying our source code base

00:22:00,159 --> 00:22:04,960
but the transition was not painless we

00:22:03,120 --> 00:22:07,360
anticipated that it would probably take

00:22:04,960 --> 00:22:08,320
two maybe three weeks to do the

00:22:07,360 --> 00:22:11,280
transition

00:22:08,320 --> 00:22:11,280
it took three months

00:22:11,520 --> 00:22:15,679
now to be clear this wasn't three months

00:22:13,760 --> 00:22:18,159
of me working on it constantly

00:22:15,679 --> 00:22:19,600
but it was three months of iteration so

00:22:18,159 --> 00:22:20,720
it took two to three weeks to do the

00:22:19,600 --> 00:22:22,720
first version of it

00:22:20,720 --> 00:22:24,080
then i handed off that to the test team

00:22:22,720 --> 00:22:25,039
and the team doing bare metal and it

00:22:24,080 --> 00:22:26,640
passed

00:22:25,039 --> 00:22:27,679
and then people started to use it and

00:22:26,640 --> 00:22:29,120
they found that there were certain

00:22:27,679 --> 00:22:30,799
things that were not working properly

00:22:29,120 --> 00:22:32,480
and so we iterated another one and

00:22:30,799 --> 00:22:34,960
another one and another one

00:22:32,480 --> 00:22:36,640
and by the time we had everything stable

00:22:34,960 --> 00:22:38,320
or better than the previous version that

00:22:36,640 --> 00:22:40,159
we'd started with it was about three

00:22:38,320 --> 00:22:41,600
months of iteration

00:22:40,159 --> 00:22:44,799
now that we've transitioned to the

00:22:41,600 --> 00:22:46,480
octave project i i don't expect anything

00:22:44,799 --> 00:22:48,240
major from a maintenance standpoint or

00:22:46,480 --> 00:22:49,679
anything uh that would be more difficult

00:22:48,240 --> 00:22:51,520
than crosstown g

00:22:49,679 --> 00:22:53,120
but i did track down one of the reasons

00:22:51,520 --> 00:22:54,559
why some of this transition and

00:22:53,120 --> 00:22:57,120
maintenance was difficult

00:22:54,559 --> 00:22:59,039
and that's really because um people

00:22:57,120 --> 00:23:01,120
didn't understand why certain

00:22:59,039 --> 00:23:02,799
multi libs were enabled people didn't

00:23:01,120 --> 00:23:04,159
understand why certain arguments were

00:23:02,799 --> 00:23:07,360
set in crosstool and g

00:23:04,159 --> 00:23:09,200
or the or i guess crosstown g primarily

00:23:07,360 --> 00:23:10,799
a little bit in the octo project but at

00:23:09,200 --> 00:23:11,520
least on the octo project side i was

00:23:10,799 --> 00:23:13,520
able to ask

00:23:11,520 --> 00:23:15,039
people who made those decisions hey why

00:23:13,520 --> 00:23:17,280
is this thing turned on

00:23:15,039 --> 00:23:18,320
but on the crosstown g side because it

00:23:17,280 --> 00:23:20,159
um and i

00:23:18,320 --> 00:23:22,159
and i'm not talking about the cross 20

00:23:20,159 --> 00:23:23,919
community just to be clear i'm talking

00:23:22,159 --> 00:23:26,159
about the people who did the integration

00:23:23,919 --> 00:23:27,760
five six years ago and silence some of

00:23:26,159 --> 00:23:30,240
them were not there anymore some of them

00:23:27,760 --> 00:23:31,919
said oh because we were told to do it

00:23:30,240 --> 00:23:33,600
and they really didn't understand why

00:23:31,919 --> 00:23:36,320
those options were set

00:23:33,600 --> 00:23:37,600
um if the components that i was using

00:23:36,320 --> 00:23:39,039
were coming from the crosstalling g

00:23:37,600 --> 00:23:39,600
community i actually expect that their

00:23:39,039 --> 00:23:41,520
support

00:23:39,600 --> 00:23:43,760
their their help would have been a lot a

00:23:41,520 --> 00:23:44,320
lot better um but internally it was very

00:23:43,760 --> 00:23:48,559
difficult

00:23:44,320 --> 00:23:50,080
there's also um a belief that because

00:23:48,559 --> 00:23:52,000
the tool chain worked the only thing

00:23:50,080 --> 00:23:52,559
they had to do was upgrade the source

00:23:52,000 --> 00:23:55,200
code

00:23:52,559 --> 00:23:56,720
they didn't upgrade cross tool ng in

00:23:55,200 --> 00:23:57,919
effect the version of crosstalk g we

00:23:56,720 --> 00:23:59,600
were using was about two and a half

00:23:57,919 --> 00:24:01,600
three years old

00:23:59,600 --> 00:24:02,960
and so that added some complications to

00:24:01,600 --> 00:24:05,200
the configurations that added some

00:24:02,960 --> 00:24:06,880
complications to the transition

00:24:05,200 --> 00:24:08,799
um it's these are all the things that

00:24:06,880 --> 00:24:12,320
you have to be aware of and it's really

00:24:08,799 --> 00:24:14,080
easy to get across 20g or yakta project

00:24:12,320 --> 00:24:15,600
or even your own build systems

00:24:14,080 --> 00:24:17,279
to simply say it works i don't want to

00:24:15,600 --> 00:24:18,720
touch it anymore i'm only using it for

00:24:17,279 --> 00:24:19,360
bare metal i don't need the latest tool

00:24:18,720 --> 00:24:21,120
chain

00:24:19,360 --> 00:24:23,039
and then three years later come and you

00:24:21,120 --> 00:24:24,720
do have to upgrade for a new feature or

00:24:23,039 --> 00:24:26,799
a bug fix or something

00:24:24,720 --> 00:24:27,919
and then find that you don't have what

00:24:26,799 --> 00:24:29,760
you need in order for it to work

00:24:27,919 --> 00:24:33,679
properly

00:24:29,760 --> 00:24:37,039
so definitely something to be aware of

00:24:33,679 --> 00:24:37,679
um then uh and again the initial goal on

00:24:37,039 --> 00:24:39,520
this for

00:24:37,679 --> 00:24:40,880
arm i mostly talked about microblades at

00:24:39,520 --> 00:24:43,279
this point but for arm

00:24:40,880 --> 00:24:44,159
was simply to uh to make sure that we

00:24:43,279 --> 00:24:47,760
were

00:24:44,159 --> 00:24:49,679
compatible um one of the things though

00:24:47,760 --> 00:24:51,520
that was required for our arm work is we

00:24:49,679 --> 00:24:52,960
actually had to have runtime relocation

00:24:51,520 --> 00:24:54,799
capable system

00:24:52,960 --> 00:24:56,400
and so what we ended up doing is

00:24:54,799 --> 00:24:58,320
creating a script

00:24:56,400 --> 00:24:59,520
that wrapped all of the executables on

00:24:58,320 --> 00:25:01,600
the system uh

00:24:59,520 --> 00:25:02,640
found out what the runtime location was

00:25:01,600 --> 00:25:04,559
of the script

00:25:02,640 --> 00:25:06,320
and then called the actual binary with

00:25:04,559 --> 00:25:08,159
all of those environment variables

00:25:06,320 --> 00:25:10,640
set properly and all the other

00:25:08,159 --> 00:25:10,640
components

00:25:10,880 --> 00:25:16,799
so runtime location is possible but i

00:25:13,600 --> 00:25:19,440
don't recommend it it really is a hack

00:25:16,799 --> 00:25:21,600
um so i've got a link here on so you can

00:25:19,440 --> 00:25:24,000
actually see the full version of our

00:25:21,600 --> 00:25:25,520
uh configurations this is the arm

00:25:24,000 --> 00:25:26,799
configuration that i have listed here

00:25:25,520 --> 00:25:28,960
but i just wanted to kind of give you an

00:25:26,799 --> 00:25:31,760
idea of how

00:25:28,960 --> 00:25:33,679
i'd call it insane our configuration is

00:25:31,760 --> 00:25:34,400
and why this is probably not the right

00:25:33,679 --> 00:25:36,640
way to do it

00:25:34,400 --> 00:25:37,440
long term but it was a way for us to do

00:25:36,640 --> 00:25:39,520
the transition

00:25:37,440 --> 00:25:40,799
and now we can focus on what do we

00:25:39,520 --> 00:25:41,679
actually need out of this and bring this

00:25:40,799 --> 00:25:44,320
down

00:25:41,679 --> 00:25:45,760
and so what we started with was a

00:25:44,320 --> 00:25:48,960
configuration that was based

00:25:45,760 --> 00:25:51,200
on the work that arm arm provided us uh

00:25:48,960 --> 00:25:52,480
and had 17 multi loops defined inside of

00:25:51,200 --> 00:25:54,320
gcc itself

00:25:52,480 --> 00:25:56,320
and you can do a print multi-libs in

00:25:54,320 --> 00:25:58,640
order to find out what the multi-libs

00:25:56,320 --> 00:26:00,080
available in any given tool chain are

00:25:58,640 --> 00:26:01,520
and i'm not going to list them all here

00:26:00,080 --> 00:26:02,720
but there's a big combination between

00:26:01,520 --> 00:26:06,080
standard arm

00:26:02,720 --> 00:26:09,039
32-bit v5 v6 v7

00:26:06,080 --> 00:26:12,159
floating point no floating point and

00:26:09,039 --> 00:26:13,760
then some 32-bit arm v8

00:26:12,159 --> 00:26:15,919
and also some additional custom

00:26:13,760 --> 00:26:19,760
configurations that we found

00:26:15,919 --> 00:26:20,159
and what i went back to my team for is i

00:26:19,760 --> 00:26:23,120
said

00:26:20,159 --> 00:26:23,679
okay we have 17 things here to find i

00:26:23,120 --> 00:26:25,360
don't

00:26:23,679 --> 00:26:27,520
and i'm a relatively new person to

00:26:25,360 --> 00:26:30,080
xilinx and i said i don't think anybody

00:26:27,520 --> 00:26:33,360
at xilinx has ever released an arm v5

00:26:30,080 --> 00:26:36,720
um do we need the arm v5 tool chains

00:26:33,360 --> 00:26:36,720
and the answer is nobody knows

00:26:36,880 --> 00:26:41,120
so this again is the somebody originally

00:26:39,760 --> 00:26:42,000
said well this works

00:26:41,120 --> 00:26:44,080
i'm just going to leave the

00:26:42,000 --> 00:26:45,919
configuration i'm not going to change it

00:26:44,080 --> 00:26:48,240
and then arm provided it to us and arm

00:26:45,919 --> 00:26:50,240
says well they still have rmv fives and

00:26:48,240 --> 00:26:50,640
sixes and sevens and everything else out

00:26:50,240 --> 00:26:53,840
there

00:26:50,640 --> 00:26:54,400
so from an arm arm perspective they are

00:26:53,840 --> 00:26:56,000
needed

00:26:54,400 --> 00:26:57,600
but from xilinx perspective i don't

00:26:56,000 --> 00:27:00,000
think they actually are

00:26:57,600 --> 00:27:01,200
and so we needed to so the next

00:27:00,000 --> 00:27:02,720
iteration of this is i'll

00:27:01,200 --> 00:27:04,720
work with the team to actually start

00:27:02,720 --> 00:27:06,240
filtering those 17 multilings down my

00:27:04,720 --> 00:27:07,600
goal is to really get down to about 10

00:27:06,240 --> 00:27:09,760
multi-lips

00:27:07,600 --> 00:27:11,360
we'll see if that happens the other

00:27:09,760 --> 00:27:14,080
piece

00:27:11,360 --> 00:27:15,679
was that the arm configuration comes

00:27:14,080 --> 00:27:18,640
with switches that are simply not

00:27:15,679 --> 00:27:20,000
applicable to xilinx products primarily

00:27:18,640 --> 00:27:23,200
things to work around

00:27:20,000 --> 00:27:24,640
errata things like that and when i

00:27:23,200 --> 00:27:26,240
investigated the errata

00:27:24,640 --> 00:27:28,320
it was very clear that they they don't

00:27:26,240 --> 00:27:29,760
apply to xilinx products or at least

00:27:28,320 --> 00:27:30,799
they don't apply to anything that's

00:27:29,760 --> 00:27:33,039
modern

00:27:30,799 --> 00:27:34,480
and so i went and i said can we turn

00:27:33,039 --> 00:27:35,760
these things off and after

00:27:34,480 --> 00:27:38,000
quite a long discussion the answer is

00:27:35,760 --> 00:27:40,080
finally yeah we can and

00:27:38,000 --> 00:27:41,200
it turns out that i wasn't really

00:27:40,080 --> 00:27:43,120
turning them off

00:27:41,200 --> 00:27:44,880
i was refusing to turn them on because

00:27:43,120 --> 00:27:46,080
the octa project did not use those

00:27:44,880 --> 00:27:47,840
errata switches

00:27:46,080 --> 00:27:49,679
because as far as the octa project knows

00:27:47,840 --> 00:27:51,760
all modern arm processors don't have

00:27:49,679 --> 00:27:54,720
those erratas it's really old stuff or

00:27:51,760 --> 00:27:54,720
pre-production stuff

00:27:55,760 --> 00:27:58,799
the next tool chain that came in was the

00:27:58,399 --> 00:28:02,000
arm

00:27:58,799 --> 00:28:05,200
r r and m profiles these are the real

00:28:02,000 --> 00:28:08,080
time and microcontroller profiles um

00:28:05,200 --> 00:28:09,120
so there were 22 multi libs defined here

00:28:08,080 --> 00:28:10,559
if you look at the

00:28:09,120 --> 00:28:13,600
data sheets at least for the products

00:28:10,559 --> 00:28:16,880
that i was working on it's really

00:28:13,600 --> 00:28:18,159
simply an arm are to remember notes i

00:28:16,880 --> 00:28:20,960
think r5f

00:28:18,159 --> 00:28:22,480
is the uh the one i needed to target but

00:28:20,960 --> 00:28:23,760
why do we have all of the rest of these

00:28:22,480 --> 00:28:25,279
things listed here

00:28:23,760 --> 00:28:27,279
and again it goes back to the same thing

00:28:25,279 --> 00:28:28,960
do i actually need these

00:28:27,279 --> 00:28:30,640
probably not but our first goal was

00:28:28,960 --> 00:28:32,320
simply compatibility

00:28:30,640 --> 00:28:34,559
uh and then we'll work on bringing these

00:28:32,320 --> 00:28:36,320
down so my goal is

00:28:34,559 --> 00:28:38,799
uh within the next year hopefully weed

00:28:36,320 --> 00:28:40,080
this uh 22 multi libs down probably into

00:28:38,799 --> 00:28:42,559
five or six

00:28:40,080 --> 00:28:43,279
um one thing though that we did have to

00:28:42,559 --> 00:28:46,720
do is we did

00:28:43,279 --> 00:28:50,080
actually have to define a custom

00:28:46,720 --> 00:28:51,600
tune called arm rm because the octa

00:28:50,080 --> 00:28:54,880
project did not already have

00:28:51,600 --> 00:28:59,279
a an arm r or m profile configuration

00:28:54,880 --> 00:29:02,799
but it had all the rest of them

00:28:59,279 --> 00:29:05,039
uh arm 64 this was easy very easy

00:29:02,799 --> 00:29:07,440
we wanted to have two multi-libs defined

00:29:05,039 --> 00:29:08,799
um which is basically a 32-bit and a

00:29:07,440 --> 00:29:12,399
64-bit

00:29:08,799 --> 00:29:14,399
sorry 264 bits a regular 64-bit and a

00:29:12,399 --> 00:29:17,440
64-bit ilp 32

00:29:14,399 --> 00:29:19,279
variant um with the

00:29:17,440 --> 00:29:21,360
the way that our processors are defined

00:29:19,279 --> 00:29:25,440
and everything else the big little

00:29:21,360 --> 00:29:27,360
uh a72 a53 combination

00:29:25,440 --> 00:29:29,520
tune was actually the right tune for us

00:29:27,360 --> 00:29:30,799
and so this one was just as simple as me

00:29:29,520 --> 00:29:32,240
saying yep this is what we're going to

00:29:30,799 --> 00:29:33,279
do everybody else said yeah that makes

00:29:32,240 --> 00:29:35,120
perfect sense

00:29:33,279 --> 00:29:36,559
because everybody because we only had

00:29:35,120 --> 00:29:39,200
two multi-libs it's really easy for them

00:29:36,559 --> 00:29:41,360
to verify this is really easy to do

00:29:39,200 --> 00:29:42,799
and it doesn't have that 10-15 year

00:29:41,360 --> 00:29:44,640
legacy of

00:29:42,799 --> 00:29:45,919
people having made changes and

00:29:44,640 --> 00:29:50,640
configurations

00:29:45,919 --> 00:29:50,640
so this was the easy one

00:29:50,720 --> 00:29:55,039
and then we've got the microblaze and

00:29:53,200 --> 00:29:56,880
this is where i said before there's 48

00:29:55,039 --> 00:29:59,120
multi-libs defined but there's actually

00:29:56,880 --> 00:30:00,799
more than 48 permutations possible in

00:29:59,120 --> 00:30:03,279
this configuration

00:30:00,799 --> 00:30:04,080
um microblaze if if you're not aware of

00:30:03,279 --> 00:30:06,320
that is

00:30:04,080 --> 00:30:07,520
um functionally similar to a lot of the

00:30:06,320 --> 00:30:10,480
risk 5

00:30:07,520 --> 00:30:11,279
stuff in my opinion where it's a

00:30:10,480 --> 00:30:14,080
software

00:30:11,279 --> 00:30:15,279
primarily a software defined processor

00:30:14,080 --> 00:30:16,960
that you can turn on and off

00:30:15,279 --> 00:30:18,559
instructions but those instructions are

00:30:16,960 --> 00:30:19,679
defined in the compiler

00:30:18,559 --> 00:30:21,679
so all you have to do is tell the

00:30:19,679 --> 00:30:23,279
compiler i have a barrel shift unit or i

00:30:21,679 --> 00:30:24,640
don't have a barrel shift unit

00:30:23,279 --> 00:30:27,279
and so that's where what leads to these

00:30:24,640 --> 00:30:29,200
permutations

00:30:27,279 --> 00:30:31,440
and in this case all of the microblaze

00:30:29,200 --> 00:30:33,279
stuff was designed link specific

00:30:31,440 --> 00:30:35,120
some of it was upstream but but from

00:30:33,279 --> 00:30:37,520
across 20g standpoint

00:30:35,120 --> 00:30:40,240
a tool chain standpoint it really is a a

00:30:37,520 --> 00:30:40,240
sign links thing

00:30:41,360 --> 00:30:46,399
um so we move over to the

00:30:44,480 --> 00:30:47,520
memorial configurations and what we

00:30:46,399 --> 00:30:50,399
defined uh

00:30:47,520 --> 00:30:52,320
as part of our 2020.1 release was this

00:30:50,399 --> 00:30:54,159
meta xylink standalone layer

00:30:52,320 --> 00:30:56,399
and then inside of that we actually have

00:30:54,159 --> 00:30:58,240
patches uh one of the patches was for

00:30:56,399 --> 00:31:00,000
bin utils we had to disable gold as the

00:30:58,240 --> 00:31:03,039
linker we had to disable gproff

00:31:00,000 --> 00:31:04,720
shared libraries we did have to enable

00:31:03,039 --> 00:31:06,240
link time optimization because some of

00:31:04,720 --> 00:31:09,760
the microblaze systems that we do

00:31:06,240 --> 00:31:11,440
are very memory limited we had to

00:31:09,760 --> 00:31:13,360
enable static configurations as well as

00:31:11,440 --> 00:31:16,320
multi-libs for arm

00:31:13,360 --> 00:31:17,600
we had to make sure that enable

00:31:16,320 --> 00:31:18,640
interwork was defined and then

00:31:17,600 --> 00:31:20,960
microblaze

00:31:18,640 --> 00:31:22,080
we had to disable this in infinii array

00:31:20,960 --> 00:31:23,679
and these are things

00:31:22,080 --> 00:31:25,200
in both the enable inner work and the

00:31:23,679 --> 00:31:27,360
the disable and at finian

00:31:25,200 --> 00:31:30,559
array they actually came from the cross

00:31:27,360 --> 00:31:30,559
21 g configurations

00:31:31,519 --> 00:31:35,919
gcc side very similar enable new lib

00:31:34,480 --> 00:31:36,880
turn off other things enable other

00:31:35,919 --> 00:31:40,240
things

00:31:36,880 --> 00:31:41,600
um we had to set some defaults uh

00:31:40,240 --> 00:31:43,600
i'm trying to say there's anything

00:31:41,600 --> 00:31:45,440
important here um

00:31:43,600 --> 00:31:46,960
i think the the one from microblaze and

00:31:45,440 --> 00:31:47,440
this was part of what took us three

00:31:46,960 --> 00:31:50,000
months

00:31:47,440 --> 00:31:51,200
uh to figure out was we missed the

00:31:50,000 --> 00:31:53,760
disable and

00:31:51,200 --> 00:31:55,919
infinity array in the gcc configuration

00:31:53,760 --> 00:31:58,159
it was defined properly in bin utils but

00:31:55,919 --> 00:31:59,519
not in gcc we just missed it

00:31:58,159 --> 00:32:01,200
and so what we're finding is that

00:31:59,519 --> 00:32:04,720
software would run

00:32:01,200 --> 00:32:06,640
and then when it got um to uh

00:32:04,720 --> 00:32:08,640
an exit all of a sudden the software

00:32:06,640 --> 00:32:09,279
might crash not always but it might

00:32:08,640 --> 00:32:10,720
crash

00:32:09,279 --> 00:32:12,720
and it turned out in the end it was

00:32:10,720 --> 00:32:14,000
because the uh we had missed that one

00:32:12,720 --> 00:32:15,760
argument it took a lot of

00:32:14,000 --> 00:32:17,360
back and forth uh looking at the cross

00:32:15,760 --> 00:32:19,039
21 g configuration

00:32:17,360 --> 00:32:22,000
looking at the octoproject configuration

00:32:19,039 --> 00:32:22,000
really synchronizing them

00:32:22,480 --> 00:32:28,159
okay and then um new lib libglass

00:32:26,080 --> 00:32:29,360
this is probably one of the places that

00:32:28,159 --> 00:32:32,799
this work is uh

00:32:29,360 --> 00:32:36,000
probably very xylic specific um xilinx

00:32:32,799 --> 00:32:38,080
implements our hardware drivers

00:32:36,000 --> 00:32:39,120
not as part of libgloss but in something

00:32:38,080 --> 00:32:42,559
called lib zill

00:32:39,120 --> 00:32:45,200
xl for xylinks so we need

00:32:42,559 --> 00:32:47,039
needed to build new lib and lib gloss in

00:32:45,200 --> 00:32:49,919
order to build the tool chain

00:32:47,039 --> 00:32:51,440
and then we replace parts of lip gloss

00:32:49,919 --> 00:32:52,720
with libezil later on

00:32:51,440 --> 00:32:54,720
but in order to be able to do that

00:32:52,720 --> 00:32:56,480
replacement we had to make sure that lip

00:32:54,720 --> 00:32:58,399
gloss and new lid were both compiled

00:32:56,480 --> 00:33:00,480
with exactly the same options

00:32:58,399 --> 00:33:02,159
and the one that was causing a

00:33:00,480 --> 00:33:04,720
significant problems because

00:33:02,159 --> 00:33:05,919
um again i'm not a new lube expert and

00:33:04,720 --> 00:33:08,320
didn't realize it

00:33:05,919 --> 00:33:10,480
was this disabled disabled new lib

00:33:08,320 --> 00:33:13,760
supplied syscalls

00:33:10,480 --> 00:33:16,640
what happens is without that set new lib

00:33:13,760 --> 00:33:18,559
will supply the basic system cis calls

00:33:16,640 --> 00:33:20,480
even though libgloss or something like

00:33:18,559 --> 00:33:22,240
libgloss is really supposed to supply it

00:33:20,480 --> 00:33:23,440
and so you run into a clash where things

00:33:22,240 --> 00:33:25,440
sometimes won't link

00:33:23,440 --> 00:33:27,200
or if they link the wrong version of the

00:33:25,440 --> 00:33:28,480
library will actually be used or

00:33:27,200 --> 00:33:30,480
wrong version of the function will be

00:33:28,480 --> 00:33:31,760
used and so

00:33:30,480 --> 00:33:33,600
we learned the hard way that it's that

00:33:31,760 --> 00:33:34,880
disabled new loop supplies this calls

00:33:33,600 --> 00:33:36,799
and then finally that multi-lib

00:33:34,880 --> 00:33:39,679
configuration is a very simple work

00:33:36,799 --> 00:33:41,120
around to add the dependencies

00:33:39,679 --> 00:33:43,440
but it's something that i think needs to

00:33:41,120 --> 00:33:45,679
go back upstream but until i get

00:33:43,440 --> 00:33:47,679
everything working on master i don't

00:33:45,679 --> 00:33:49,360
have a specific patch to send up because

00:33:47,679 --> 00:33:50,320
it's possible this stuff has been fixed

00:33:49,360 --> 00:33:53,360
and master already

00:33:50,320 --> 00:33:54,720
in the octa project

00:33:53,360 --> 00:33:56,799
so let's take a look at the lessons

00:33:54,720 --> 00:33:59,440
learned the more multi-libs

00:33:56,799 --> 00:33:59,919
the longer the project parse time is

00:33:59,440 --> 00:34:02,799
with

00:33:59,919 --> 00:34:04,799
um i i tried to provide a table here

00:34:02,799 --> 00:34:06,559
that that showed parse time

00:34:04,799 --> 00:34:08,800
compilation time things like that

00:34:06,559 --> 00:34:11,359
compare it against cross 21 g

00:34:08,800 --> 00:34:13,119
this is a very very simple configuration

00:34:11,359 --> 00:34:14,879
that i'm doing a comparison against

00:34:13,119 --> 00:34:17,359
if you don't have a simple configuration

00:34:14,879 --> 00:34:20,879
the parse time can blow up exponentially

00:34:17,359 --> 00:34:24,320
just as a warning so microblaze which is

00:34:20,879 --> 00:34:25,760
by far the very worst configuration with

00:34:24,320 --> 00:34:27,200
48 multi-libs

00:34:25,760 --> 00:34:29,280
it took eight minutes to parse the

00:34:27,200 --> 00:34:30,879
simple configuration

00:34:29,280 --> 00:34:32,800
and crest 20 doesn't have that parsing

00:34:30,879 --> 00:34:34,960
time at all so there really wasn't a

00:34:32,800 --> 00:34:36,639
cost there and the compilation time is a

00:34:34,960 --> 00:34:38,320
lot higher because it's doing

00:34:36,639 --> 00:34:40,480
more work to ensure each of the

00:34:38,320 --> 00:34:41,119
multi-libs is completely separate from

00:34:40,480 --> 00:34:43,520
each other

00:34:41,119 --> 00:34:44,960
and then combining them in the end and

00:34:43,520 --> 00:34:46,560
so from a time

00:34:44,960 --> 00:34:47,919
and resource perspective the octa

00:34:46,560 --> 00:34:49,679
project is a lot more expensive than

00:34:47,919 --> 00:34:50,720
crosstown g for doing something like

00:34:49,679 --> 00:34:53,919
this

00:34:50,720 --> 00:34:55,679
um if i turn on other components of the

00:34:53,919 --> 00:34:57,280
system which are absolutely not used by

00:34:55,679 --> 00:34:59,680
any of these configurations my parse

00:34:57,280 --> 00:35:01,040
time exploded to 48 50 minutes

00:34:59,680 --> 00:35:02,720
and that was before the compilation

00:35:01,040 --> 00:35:05,359
started and

00:35:02,720 --> 00:35:06,800
this is all on a reasonably fast modern

00:35:05,359 --> 00:35:10,480
machine 32 cores

00:35:06,800 --> 00:35:11,839
or sorry 16 course 32 threads with 128

00:35:10,480 --> 00:35:13,359
gigs of ram so this isn't a small

00:35:11,839 --> 00:35:15,920
machine

00:35:13,359 --> 00:35:16,720
and so you can kind of see that the

00:35:15,920 --> 00:35:20,000
trade-off

00:35:16,720 --> 00:35:21,839
and time to build and parse and

00:35:20,000 --> 00:35:24,240
everything else

00:35:21,839 --> 00:35:25,280
you have to be able to justify that by

00:35:24,240 --> 00:35:27,839
having either

00:35:25,280 --> 00:35:29,599
a one common yakta project interface uh

00:35:27,839 --> 00:35:31,680
one common user interface or one common

00:35:29,599 --> 00:35:32,320
set of source code if you can't justify

00:35:31,680 --> 00:35:35,680
that

00:35:32,320 --> 00:35:39,280
this work is probably not worth it

00:35:35,680 --> 00:35:41,520
so my recommendations here for a quick

00:35:39,280 --> 00:35:42,880
tool chain firmware users bios

00:35:41,520 --> 00:35:45,440
developers

00:35:42,880 --> 00:35:46,000
i want to build my u-boot all of those

00:35:45,440 --> 00:35:48,880
things

00:35:46,000 --> 00:35:49,520
crosstown g is far quicker far easier to

00:35:48,880 --> 00:35:51,680
use

00:35:49,520 --> 00:35:53,119
just keep that in mind if anybody has a

00:35:51,680 --> 00:35:54,720
question ever asked me

00:35:53,119 --> 00:35:56,000
should i use crosstalk ng or the octa

00:35:54,720 --> 00:35:57,359
project first question is what are you

00:35:56,000 --> 00:35:58,640
doing with it and i'll probably say

00:35:57,359 --> 00:36:00,400
crosstown g

00:35:58,640 --> 00:36:02,560
unless they have a very specific yaktor

00:36:00,400 --> 00:36:05,440
project use case

00:36:02,560 --> 00:36:07,280
so one of the other nice things that you

00:36:05,440 --> 00:36:09,520
can do with the octa project and we

00:36:07,280 --> 00:36:11,440
started to look at this

00:36:09,520 --> 00:36:12,560
was you can actually use the exact same

00:36:11,440 --> 00:36:14,400
source code

00:36:12,560 --> 00:36:16,240
with the octa project just use the same

00:36:14,400 --> 00:36:17,839
patches and integrate them

00:36:16,240 --> 00:36:19,920
but what we found was between the

00:36:17,839 --> 00:36:20,400
configuration switches and the desire to

00:36:19,920 --> 00:36:24,960
have a

00:36:20,400 --> 00:36:26,160
common set of source code with crosstool

00:36:24,960 --> 00:36:28,160
sorry sorry common set of source code

00:36:26,160 --> 00:36:28,960
within the octa project we ended up

00:36:28,160 --> 00:36:31,040
basically

00:36:28,960 --> 00:36:32,720
dismissing uh crosstown g source code

00:36:31,040 --> 00:36:34,320
completely

00:36:32,720 --> 00:36:35,520
and then we focused on the configuration

00:36:34,320 --> 00:36:36,800
switches to make sure that they were

00:36:35,520 --> 00:36:37,920
configured properly

00:36:36,800 --> 00:36:39,359
and over time we're going to get those

00:36:37,920 --> 00:36:40,960
configuration switches closer to the

00:36:39,359 --> 00:36:42,320
octa project than closer to

00:36:40,960 --> 00:36:44,160
what the previous cross 21g

00:36:42,320 --> 00:36:47,040
configurations were um

00:36:44,160 --> 00:36:49,680
but it's a transition strategy for the

00:36:47,040 --> 00:36:51,680
octa project itself

00:36:49,680 --> 00:36:52,880
i found that it was easiest if i have to

00:36:51,680 --> 00:36:56,400
create a cygwin

00:36:52,880 --> 00:36:58,079
tool chain um since windows is moving

00:36:56,400 --> 00:36:59,680
towards uh more of that linux

00:36:58,079 --> 00:37:01,280
environment for windows

00:36:59,680 --> 00:37:03,680
hopefully maybe sigmund won't be

00:37:01,280 --> 00:37:05,119
necessary much longer

00:37:03,680 --> 00:37:06,480
that's my hope and then if that's the

00:37:05,119 --> 00:37:08,000
case then the advantage of the octa

00:37:06,480 --> 00:37:11,119
budget kind of goes away which i'm

00:37:08,000 --> 00:37:12,400
i'm perfectly fine with um and then

00:37:11,119 --> 00:37:14,480
finally which i've said

00:37:12,400 --> 00:37:16,320
multiple times the octa project

00:37:14,480 --> 00:37:18,320
absolutely takes more time

00:37:16,320 --> 00:37:20,640
and takes more effort especially if you

00:37:18,320 --> 00:37:23,200
are not um familiar with some of these

00:37:20,640 --> 00:37:25,839
these switches and configurations but

00:37:23,200 --> 00:37:27,680
yet once you have it figured out

00:37:25,839 --> 00:37:29,200
it becomes very reproducible and you

00:37:27,680 --> 00:37:31,200
have a common set of source code and

00:37:29,200 --> 00:37:33,440
configuration switches with linux

00:37:31,200 --> 00:37:36,079
and so it may simplify your defect

00:37:33,440 --> 00:37:37,520
handling your feature fixes

00:37:36,079 --> 00:37:38,960
creating new features for your tool

00:37:37,520 --> 00:37:40,720
chains integrating those new features

00:37:38,960 --> 00:37:42,560
and even testing those features

00:37:40,720 --> 00:37:45,040
and so it's just something to be aware

00:37:42,560 --> 00:37:48,320
of that

00:37:45,040 --> 00:37:51,200
the penalty for the more complex system

00:37:48,320 --> 00:37:53,680
may be worth it for your use case um i

00:37:51,200 --> 00:37:54,800
believe that for my use case it is worth

00:37:53,680 --> 00:37:57,119
it

00:37:54,800 --> 00:37:58,480
but if i was just going to build a tool

00:37:57,119 --> 00:37:59,839
chain i would actually use crosstall and

00:37:58,480 --> 00:38:04,160
g for that

00:37:59,839 --> 00:38:07,200
so that's kind of where where i stand

00:38:04,160 --> 00:38:08,480
and with that i'm open for questions um

00:38:07,200 --> 00:38:10,160
i see that there's a qui

00:38:08,480 --> 00:38:11,520
i've already answered one uh let's take

00:38:10,160 --> 00:38:13,760
a look at another one

00:38:11,520 --> 00:38:16,000
um so somebody asked about vivado

00:38:13,760 --> 00:38:18,960
eclipse sdks using the octa project

00:38:16,000 --> 00:38:20,320
um components i am not involved at all

00:38:18,960 --> 00:38:22,320
with the vovato stuff

00:38:20,320 --> 00:38:24,000
um but our bare metal tool chains that i

00:38:22,320 --> 00:38:27,200
was creating for this

00:38:24,000 --> 00:38:28,160
is what novato and our vitus products

00:38:27,200 --> 00:38:30,400
use

00:38:28,160 --> 00:38:32,800
uh primarily for building firmwares just

00:38:30,400 --> 00:38:34,720
to be clear not the linux side the linux

00:38:32,800 --> 00:38:36,800
tool chains are also provided by my

00:38:34,720 --> 00:38:38,640
group but

00:38:36,800 --> 00:38:40,560
they they are loaded into the vivado

00:38:38,640 --> 00:38:42,400
vitus and come from the octa project

00:38:40,560 --> 00:38:43,760
specifically for this but i don't know

00:38:42,400 --> 00:38:47,839
much about the rest about how it's

00:38:43,760 --> 00:38:47,839
integrated sorry

00:38:47,920 --> 00:38:52,000
um question what methods did you use to

00:38:50,400 --> 00:38:53,920
determine what to enable and disable the

00:38:52,000 --> 00:38:55,680
configurations

00:38:53,920 --> 00:38:57,920
we used two different methods one we

00:38:55,680 --> 00:39:01,119
actually queried

00:38:57,920 --> 00:39:02,960
gcc on both sides and use the various

00:39:01,119 --> 00:39:04,640
print options the spec file print

00:39:02,960 --> 00:39:05,760
options things like that and we started

00:39:04,640 --> 00:39:08,560
comparing things

00:39:05,760 --> 00:39:09,920
our initial goal was to identify the

00:39:08,560 --> 00:39:11,680
configurations

00:39:09,920 --> 00:39:13,280
and then see what was different between

00:39:11,680 --> 00:39:14,720
the octa project things for multilibs

00:39:13,280 --> 00:39:15,440
that was easy it's print print multi

00:39:14,720 --> 00:39:18,000
lives

00:39:15,440 --> 00:39:19,599
for the configuration stuff there is a

00:39:18,000 --> 00:39:21,599
print version that will print

00:39:19,599 --> 00:39:22,800
some of the configurations for the spec

00:39:21,599 --> 00:39:24,320
file things again

00:39:22,800 --> 00:39:25,680
we'll print some of the spec file we

00:39:24,320 --> 00:39:27,280
could start there and start looking at

00:39:25,680 --> 00:39:31,040
that

00:39:27,280 --> 00:39:33,760
we also looked at the configuration log

00:39:31,040 --> 00:39:34,960
from the crosstown g builds and by

00:39:33,760 --> 00:39:36,640
looking at those logs

00:39:34,960 --> 00:39:38,720
we were able to see oh it passed the

00:39:36,640 --> 00:39:41,520
following arguments into

00:39:38,720 --> 00:39:42,400
uh configure for ben utils or gcc and

00:39:41,520 --> 00:39:44,320
then i looked at those same

00:39:42,400 --> 00:39:46,079
configuration logs on the octa project

00:39:44,320 --> 00:39:48,160
and did that same comparison

00:39:46,079 --> 00:39:50,320
and so back and forth we we started to

00:39:48,160 --> 00:39:53,839
do that

00:39:50,320 --> 00:39:55,119
um richard uh good question i forgot to

00:39:53,839 --> 00:39:56,000
mention this he asked which the octa

00:39:55,119 --> 00:39:57,760
project released was

00:39:56,000 --> 00:39:59,119
all of where all these things computed

00:39:57,760 --> 00:40:01,440
against and this was against

00:39:59,119 --> 00:40:03,359
the zeus release which is the 3.0

00:40:01,440 --> 00:40:05,200
release from last fall the october time

00:40:03,359 --> 00:40:07,119
frame release

00:40:05,200 --> 00:40:08,560
we are working towards doing master

00:40:07,119 --> 00:40:10,800
right now but i do not yet

00:40:08,560 --> 00:40:12,480
have the tool chain components upgraded

00:40:10,800 --> 00:40:13,359
to the latest master version of the tool

00:40:12,480 --> 00:40:17,280
chain

00:40:13,359 --> 00:40:19,920
uh so i don't know if the parsing or the

00:40:17,280 --> 00:40:22,000
or the compilation is any faster i think

00:40:19,920 --> 00:40:24,240
the parsing will be faster just from

00:40:22,000 --> 00:40:25,599
other project stuff that i've done but i

00:40:24,240 --> 00:40:27,280
don't have any numbers to actually back

00:40:25,599 --> 00:40:28,720
that up it might just be it

00:40:27,280 --> 00:40:31,760
it's the same i don't expect it to be

00:40:28,720 --> 00:40:31,760
any slower just to be clear

00:40:32,319 --> 00:40:37,920
um next question was how about builder

00:40:35,359 --> 00:40:39,359
have we used it i have not used build

00:40:37,920 --> 00:40:42,400
root in many years

00:40:39,359 --> 00:40:43,520
um and because xilinx is focused on

00:40:42,400 --> 00:40:46,560
yakto project

00:40:43,520 --> 00:40:47,520
uh primarily for our linux um embedded

00:40:46,560 --> 00:40:50,720
linux uh

00:40:47,520 --> 00:40:52,720
offerings pedal linux

00:40:50,720 --> 00:40:54,319
i focused on the octoproject i am i

00:40:52,720 --> 00:40:56,000
would not be surprised that build root

00:40:54,319 --> 00:40:57,680
can do a lot of what i've talked about

00:40:56,000 --> 00:40:59,040
especially with bare metal tool chains

00:40:57,680 --> 00:40:59,440
but i just don't have any experience

00:40:59,040 --> 00:41:03,520
there

00:40:59,440 --> 00:41:03,520
to say either way if it if it's usable

00:41:04,319 --> 00:41:08,000
uh next question um describe how the

00:41:06,720 --> 00:41:08,880
bare metal tool chains can work with

00:41:08,000 --> 00:41:12,000
open amp

00:41:08,880 --> 00:41:15,599
um so again i'm not an open amp

00:41:12,000 --> 00:41:17,680
expert uh or i i know what it is

00:41:15,599 --> 00:41:19,119
um i actually work with people who i

00:41:17,680 --> 00:41:21,440
have given tool chains to

00:41:19,119 --> 00:41:23,040
to work on openamp and they said it just

00:41:21,440 --> 00:41:25,839
worked

00:41:23,040 --> 00:41:27,200
as far as debugging goes that i don't

00:41:25,839 --> 00:41:28,960
know how they're doing debugging i'm

00:41:27,200 --> 00:41:31,359
guessing it's with jtag but i really

00:41:28,960 --> 00:41:33,200
don't know

00:41:31,359 --> 00:41:35,440
most of the bare metal stuff that i have

00:41:33,200 --> 00:41:35,760
done in the past on both arm processors

00:41:35,440 --> 00:41:38,240
and

00:41:35,760 --> 00:41:39,839
other cpus has almost always been jtag

00:41:38,240 --> 00:41:41,920
based

00:41:39,839 --> 00:41:44,640
so i don't know specifics about xylinks

00:41:41,920 --> 00:41:46,640
i've never done any actual jta

00:41:44,640 --> 00:41:48,000
bare metal application development here

00:41:46,640 --> 00:41:51,200
at xylinx so i'm

00:41:48,000 --> 00:41:51,200
not familiar with their tooling

00:41:54,000 --> 00:41:57,200
um performance specs on the previous

00:41:55,760 --> 00:42:00,000
side seem to be purse

00:41:57,200 --> 00:42:02,800
was potentially disk bound so the

00:42:00,000 --> 00:42:05,680
machine that i ran those numbers on

00:42:02,800 --> 00:42:07,040
has two disks in a raid one it is

00:42:05,680 --> 00:42:10,720
spinning media

00:42:07,040 --> 00:42:14,000
and so it very well could be disk bound

00:42:10,720 --> 00:42:16,960
but what i was finding though

00:42:14,000 --> 00:42:17,359
is even if it's disc bound the amount of

00:42:16,960 --> 00:42:19,119
work

00:42:17,359 --> 00:42:20,880
that the yokta project was doing in

00:42:19,119 --> 00:42:23,040
comparison with crosstaling was

00:42:20,880 --> 00:42:26,319
significantly more work

00:42:23,040 --> 00:42:27,040
um so even if the octa project was 84

00:42:26,319 --> 00:42:30,319
minutes

00:42:27,040 --> 00:42:30,319
in fact i'll go back to that slide

00:42:31,440 --> 00:42:35,520
so even if the octa project was 84

00:42:33,359 --> 00:42:38,160
minutes on microblaze and it was disc

00:42:35,520 --> 00:42:41,119
bound and crosstonji was 32.

00:42:38,160 --> 00:42:41,839
i would not expect even with the fastest

00:42:41,119 --> 00:42:44,000
ram disks

00:42:41,839 --> 00:42:46,800
for the yaktor project stuff to be any

00:42:44,000 --> 00:42:50,960
faster than about 50 minutes

00:42:46,800 --> 00:42:52,800
i've done things in the past with

00:42:50,960 --> 00:42:54,319
with ram discs compared to hard drives

00:42:52,800 --> 00:42:56,800
in raid 1

00:42:54,319 --> 00:42:59,520
and i found that it's ram is a much

00:42:56,800 --> 00:43:02,160
bigger deal and with 128 megs of ram

00:42:59,520 --> 00:43:04,000
uh sorry 128 gigs of ram i never got

00:43:02,160 --> 00:43:05,680
close to a ram threshold on the system i

00:43:04,000 --> 00:43:08,640
watched this the whole time

00:43:05,680 --> 00:43:10,560
and i did get load averages in the 4 and

00:43:08,640 --> 00:43:12,480
500 range

00:43:10,560 --> 00:43:14,160
but my ram usage never went above about

00:43:12,480 --> 00:43:16,079
80 gigabytes

00:43:14,160 --> 00:43:18,079
and so i wasn't bound from a ram i was

00:43:16,079 --> 00:43:19,440
never swapping anything like that

00:43:18,079 --> 00:43:20,720
and so i think these numbers are

00:43:19,440 --> 00:43:23,520
representative they're obviously not

00:43:20,720 --> 00:43:23,520
going to be perfect though

00:43:24,800 --> 00:43:29,040
uh next question why did i choose

00:43:26,240 --> 00:43:32,319
multi-lib over multi-config

00:43:29,040 --> 00:43:32,880
um the the plain answer was that uh the

00:43:32,319 --> 00:43:34,560
previous

00:43:32,880 --> 00:43:36,079
um configurations and the vitus and

00:43:34,560 --> 00:43:36,880
vivado products were expecting a

00:43:36,079 --> 00:43:40,240
multi-lib

00:43:36,880 --> 00:43:42,560
configuration with one uh gcc

00:43:40,240 --> 00:43:44,400
binary to execute that would then pick

00:43:42,560 --> 00:43:48,720
the correct library the correct

00:43:44,400 --> 00:43:51,119
configuration arguments and just run it

00:43:48,720 --> 00:43:52,880
the current integration does not know

00:43:51,119 --> 00:43:54,800
how the octoproject

00:43:52,880 --> 00:43:56,400
environment files work it does not know

00:43:54,800 --> 00:43:57,440
how the octave project configuration

00:43:56,400 --> 00:44:00,400
components work

00:43:57,440 --> 00:44:02,400
it's focused purely on i want to run gcc

00:44:00,400 --> 00:44:04,079
if i pass in these options i know the

00:44:02,400 --> 00:44:05,839
right library is going to get loaded by

00:44:04,079 --> 00:44:07,599
gcc and linked together

00:44:05,839 --> 00:44:09,680
and so that's why multi-lib was used

00:44:07,599 --> 00:44:11,520
over multi-config

00:44:09,680 --> 00:44:13,359
but even in the future i don't know that

00:44:11,520 --> 00:44:15,520
i'm necessarily going to change this

00:44:13,359 --> 00:44:18,160
um like i said my my main thing is to

00:44:15,520 --> 00:44:19,440
clean up the multi lips 48 is insane 22

00:44:18,160 --> 00:44:21,920
is insane

00:44:19,440 --> 00:44:22,560
17 is insane there's really no reason

00:44:21,920 --> 00:44:24,960
for that

00:44:22,560 --> 00:44:26,960
many of them what we need to do is

00:44:24,960 --> 00:44:27,599
identify that these are the ones that

00:44:26,960 --> 00:44:29,119
are common

00:44:27,599 --> 00:44:31,440
these are the ones that people actually

00:44:29,119 --> 00:44:33,520
use and bring those numbers down

00:44:31,440 --> 00:44:36,000
and not only is that going to make it

00:44:33,520 --> 00:44:37,200
easier from a compilation standpoint but

00:44:36,000 --> 00:44:38,560
it's going to make it easier from a

00:44:37,200 --> 00:44:39,920
support standpoint and that's actually

00:44:38,560 --> 00:44:41,200
what i'm more worried about is the

00:44:39,920 --> 00:44:43,520
support side of things

00:44:41,200 --> 00:44:44,319
if somebody files a bug do i have to

00:44:43,520 --> 00:44:47,200
spend

00:44:44,319 --> 00:44:48,560
an hour to reproduce a binary tool chain

00:44:47,200 --> 00:44:50,319
just so that i can say yeah there's a

00:44:48,560 --> 00:44:52,480
bug there and then pass it off to a tool

00:44:50,319 --> 00:44:54,960
chain expert or somebody like that

00:44:52,480 --> 00:44:56,400
um if i only have to build two two multi

00:44:54,960 --> 00:44:58,160
libs i can spend 15

00:44:56,400 --> 00:44:59,200
20 minutes building a tool chain doing

00:44:58,160 --> 00:45:01,760
the same thing and then i don't feel

00:44:59,200 --> 00:45:03,280
like i'm wasting my time

00:45:01,760 --> 00:45:04,560
uh and then of course the more multi

00:45:03,280 --> 00:45:06,000
libs the more chance you have for bugs

00:45:04,560 --> 00:45:07,839
in those multi loops so it's it's

00:45:06,000 --> 00:45:10,960
trade-offs that we have to worry about

00:45:07,839 --> 00:45:12,240
for the multi-config stuff we do plan on

00:45:10,960 --> 00:45:15,520
using that for

00:45:12,240 --> 00:45:16,000
multiple operating systems so depending

00:45:15,520 --> 00:45:19,440
on

00:45:16,000 --> 00:45:20,960
if multi-config can be used for sdks and

00:45:19,440 --> 00:45:22,720
esdks

00:45:20,960 --> 00:45:24,400
what we may do is be able to provide a

00:45:22,720 --> 00:45:25,920
single tool chain that will now work on

00:45:24,400 --> 00:45:27,520
bare metal and linux

00:45:25,920 --> 00:45:28,720
and then you would choose i want the

00:45:27,520 --> 00:45:30,160
bare metal tool chain or i want the

00:45:28,720 --> 00:45:32,319
linux tool chain

00:45:30,160 --> 00:45:35,280
something like that and so that could be

00:45:32,319 --> 00:45:36,560
a very good use of the multi-config

00:45:35,280 --> 00:45:38,480
but up to this point everything's been

00:45:36,560 --> 00:45:39,040
bare metal based because the linux tool

00:45:38,480 --> 00:45:40,560
chains

00:45:39,040 --> 00:45:41,839
were already octoproject-based and they

00:45:40,560 --> 00:45:46,240
just worked so we didn't make any

00:45:41,839 --> 00:45:49,359
changes to them

00:45:46,240 --> 00:45:51,599
see any other questions so that's all

00:45:49,359 --> 00:46:01,839
the questions i've gotten so far

00:45:51,599 --> 00:46:01,839
does anybody else have any questions

00:46:04,319 --> 00:46:07,440
okay i don't see any other questions

00:46:05,760 --> 00:46:10,560
coming in um

00:46:07,440 --> 00:46:11,280
so i will be on the slack uh embedded

00:46:10,560 --> 00:46:14,960
track channel

00:46:11,280 --> 00:46:18,160
uh as well as i'm on the yacto

00:46:14,960 --> 00:46:18,960
channel as well you can certainly reach

00:46:18,160 --> 00:46:22,960
me

00:46:18,960 --> 00:46:25,920
from it's mark.h-a-t-l-e

00:46:22,960 --> 00:46:27,520
at colonel.crashing.org if you've got

00:46:25,920 --> 00:46:30,079
any questions or on the

00:46:27,520 --> 00:46:31,520
yakuto project direct i'm frey there

00:46:30,079 --> 00:46:33,040
f-r-a-y

00:46:31,520 --> 00:46:34,960
so thank you very much thank you for

00:46:33,040 --> 00:46:36,079
attending any questions please let me

00:46:34,960 --> 00:46:43,839
know

00:46:36,079 --> 00:46:43,839
thank you

00:46:43,920 --> 00:46:46,000

YouTube URL: https://www.youtube.com/watch?v=b0yXASkIIv8


