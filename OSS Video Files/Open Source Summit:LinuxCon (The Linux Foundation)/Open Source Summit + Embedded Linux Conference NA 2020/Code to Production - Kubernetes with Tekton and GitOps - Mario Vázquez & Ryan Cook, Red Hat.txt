Title: Code to Production - Kubernetes with Tekton and GitOps - Mario Vázquez & Ryan Cook, Red Hat
Publication date: 2020-09-03
Playlist: Open Source Summit + Embedded Linux Conference NA 2020
Description: 
	Code to Production - Kubernetes with Tekton and GitOps - Mario Vázquez & Ryan Cook, Red Hat
Captions: 
	00:00:02,720 --> 00:00:05,200
hi everybody

00:00:03,439 --> 00:00:08,320
uh good morning good afternoon good

00:00:05,200 --> 00:00:10,559
evening um where the time zone you are

00:00:08,320 --> 00:00:12,799
um mario and i are going to do a

00:00:10,559 --> 00:00:14,240
presentation today on kubernetes with

00:00:12,799 --> 00:00:15,280
techton and gitops

00:00:14,240 --> 00:00:18,640
so we're going to do is we're going to

00:00:15,280 --> 00:00:18,640
go straight to our first slide

00:00:19,119 --> 00:00:25,199
so as i said i'm ryan cook um

00:00:22,160 --> 00:00:27,680
and this is an amazing engineer

00:00:25,199 --> 00:00:28,720
mario vazquez with me and what we're

00:00:27,680 --> 00:00:29,679
going to do is we're going to present

00:00:28,720 --> 00:00:32,399
and talk about

00:00:29,679 --> 00:00:33,440
a product actually two products today

00:00:32,399 --> 00:00:36,239
that have been

00:00:33,440 --> 00:00:38,719
just completely influential in the last

00:00:36,239 --> 00:00:40,320
year year and a half of our work

00:00:38,719 --> 00:00:41,920
we've been incredibly passionate about

00:00:40,320 --> 00:00:43,600
both these products

00:00:41,920 --> 00:00:45,920
and so we're happy to share what we've

00:00:43,600 --> 00:00:47,600
learned thus far with them

00:00:45,920 --> 00:00:49,039
so why don't we just get straight into

00:00:47,600 --> 00:00:51,360
it

00:00:49,039 --> 00:00:52,160
so let's start off by talking about what

00:00:51,360 --> 00:00:54,000
git ops is

00:00:52,160 --> 00:00:56,320
i know that it's been becoming a really

00:00:54,000 --> 00:00:59,359
popular term we've seen a lot about it

00:00:56,320 --> 00:01:01,680
on twitter within the community

00:00:59,359 --> 00:01:04,080
get ops is actually just storing your

00:01:01,680 --> 00:01:05,840
aim yaml kubernetes objects within your

00:01:04,080 --> 00:01:08,640
get repository

00:01:05,840 --> 00:01:10,400
thus the get version portion of this and

00:01:08,640 --> 00:01:12,720
then the operations part of it

00:01:10,400 --> 00:01:14,320
is is the best way to describe it is

00:01:12,720 --> 00:01:17,520
that

00:01:14,320 --> 00:01:19,759
the ops part of it is running cube apply

00:01:17,520 --> 00:01:20,960
f of your git objects over and over and

00:01:19,759 --> 00:01:23,680
over again

00:01:20,960 --> 00:01:25,600
so think of get ops and implementing it

00:01:23,680 --> 00:01:26,479
with your environment as having an extra

00:01:25,600 --> 00:01:29,200
admin

00:01:26,479 --> 00:01:30,960
whose sole job it is is to just stare at

00:01:29,200 --> 00:01:33,280
your repository

00:01:30,960 --> 00:01:34,799
and apply objects as they come in or as

00:01:33,280 --> 00:01:36,799
they change

00:01:34,799 --> 00:01:38,000
a lot of these get ops tools and the one

00:01:36,799 --> 00:01:40,560
we'll be covering today

00:01:38,000 --> 00:01:42,560
have templating options with the help of

00:01:40,560 --> 00:01:44,960
helm and customize

00:01:42,560 --> 00:01:47,119
and you just have to kind of fit the

00:01:44,960 --> 00:01:49,520
tool versus home or customize

00:01:47,119 --> 00:01:51,520
of how you want to use it the best part

00:01:49,520 --> 00:01:52,560
about git ops and all these tools are

00:01:51,520 --> 00:01:55,280
that there is no

00:01:52,560 --> 00:01:57,280
object limit creations so you can

00:01:55,280 --> 00:01:58,399
install at third party tools such as

00:01:57,280 --> 00:02:01,439
crossplane

00:01:58,399 --> 00:02:02,799
or you know some of the other plugins

00:02:01,439 --> 00:02:04,799
from the cloud providers

00:02:02,799 --> 00:02:06,320
store those in git and the get ops tool

00:02:04,799 --> 00:02:08,640
will apply it

00:02:06,320 --> 00:02:09,520
and then lastly there's remediation of

00:02:08,640 --> 00:02:11,599
your environment

00:02:09,520 --> 00:02:12,800
through web hooks or sometimes it's

00:02:11,599 --> 00:02:14,720
actually just a controller running

00:02:12,800 --> 00:02:18,000
within the environment just

00:02:14,720 --> 00:02:19,840
checking on your repository but with

00:02:18,000 --> 00:02:22,400
this there comes some best practices

00:02:19,840 --> 00:02:24,239
um as with everything that we do least

00:02:22,400 --> 00:02:26,160
privileges as possible

00:02:24,239 --> 00:02:28,239
you don't want to give a good ops tool

00:02:26,160 --> 00:02:30,000
just kind of cluster admin access to

00:02:28,239 --> 00:02:32,720
everything

00:02:30,000 --> 00:02:34,560
because you know things go awry if you

00:02:32,720 --> 00:02:36,480
don't have a testing framework set up

00:02:34,560 --> 00:02:37,680
you might remove a very important

00:02:36,480 --> 00:02:40,800
namespace

00:02:37,680 --> 00:02:42,160
so just identifying the privileges that

00:02:40,800 --> 00:02:44,080
are important to your environment and

00:02:42,160 --> 00:02:46,160
what you want to apply

00:02:44,080 --> 00:02:48,239
and then store code and kubernetes

00:02:46,160 --> 00:02:50,239
objects in different repositories this

00:02:48,239 --> 00:02:52,080
one's kind of back and forth

00:02:50,239 --> 00:02:53,760
we've had really good success with

00:02:52,080 --> 00:02:56,800
storing them separately

00:02:53,760 --> 00:02:58,959
just because of the fact that one might

00:02:56,800 --> 00:03:00,640
move faster than the other one

00:02:58,959 --> 00:03:02,480
um depending on the get ops tool that

00:03:00,640 --> 00:03:05,280
you use you might have web hooks

00:03:02,480 --> 00:03:06,720
and if you're committing a readme update

00:03:05,280 --> 00:03:08,640
you don't actually just want to push out

00:03:06,720 --> 00:03:11,360
a new build or at least evaluate if

00:03:08,640 --> 00:03:13,680
there's a new build

00:03:11,360 --> 00:03:15,760
there's also set up proper rbac access

00:03:13,680 --> 00:03:19,519
for your git repositories

00:03:15,760 --> 00:03:21,360
and then avoid storing regular secrets

00:03:19,519 --> 00:03:23,440
within your git repository the reason

00:03:21,360 --> 00:03:24,959
why i say that is regular secrets are

00:03:23,440 --> 00:03:27,440
base 64.

00:03:24,959 --> 00:03:28,000
you run base64-d and that's no longer a

00:03:27,440 --> 00:03:30,400
secret

00:03:28,000 --> 00:03:32,959
so mario will actually show today in the

00:03:30,400 --> 00:03:35,760
demonstration how to use sealed secrets

00:03:32,959 --> 00:03:36,720
and then with always documentation is

00:03:35,760 --> 00:03:39,040
huge

00:03:36,720 --> 00:03:40,799
um definitely document the process and

00:03:39,040 --> 00:03:42,400
to recreate your get ops tool and

00:03:40,799 --> 00:03:44,080
artifacts

00:03:42,400 --> 00:03:45,440
and just document the whole process

00:03:44,080 --> 00:03:47,040
because you don't want to be trying to

00:03:45,440 --> 00:03:49,360
figure out how to do this at three in

00:03:47,040 --> 00:03:51,440
the morning

00:03:49,360 --> 00:03:53,680
so there's a couple different deployment

00:03:51,440 --> 00:03:55,680
models when we're looking at get ops

00:03:53,680 --> 00:03:56,959
and there's different tools that use the

00:03:55,680 --> 00:04:00,000
different methodologies

00:03:56,959 --> 00:04:02,480
there's some tools that can handle both

00:04:00,000 --> 00:04:03,519
um for example we'll talk about the hub

00:04:02,480 --> 00:04:06,239
and spoke

00:04:03,519 --> 00:04:07,599
what this is is a get ops tool that sits

00:04:06,239 --> 00:04:09,360
on a cluster

00:04:07,599 --> 00:04:10,640
we'll call this one that sits in your

00:04:09,360 --> 00:04:12,400
main office

00:04:10,640 --> 00:04:13,680
and then from there it interacts with

00:04:12,400 --> 00:04:14,480
all of your different kubernetes

00:04:13,680 --> 00:04:17,280
clusters

00:04:14,480 --> 00:04:18,320
out in the world all over the place but

00:04:17,280 --> 00:04:21,840
they don't have

00:04:18,320 --> 00:04:22,160
any sort of tooling on them that keeps

00:04:21,840 --> 00:04:24,639
them

00:04:22,160 --> 00:04:25,919
in sync it is all handled straight from

00:04:24,639 --> 00:04:29,280
that in-office

00:04:25,919 --> 00:04:29,680
kubernetes cluster on the other side of

00:04:29,280 --> 00:04:32,720
that

00:04:29,680 --> 00:04:34,160
there is a cluster independent mode and

00:04:32,720 --> 00:04:37,360
this one's a little bit different

00:04:34,160 --> 00:04:39,360
because it only cares about itself

00:04:37,360 --> 00:04:40,960
so all of those independent clusters all

00:04:39,360 --> 00:04:42,800
over the world in the cloud

00:04:40,960 --> 00:04:44,160
they have their own get ops tool running

00:04:42,800 --> 00:04:45,840
and they're calling back to get

00:04:44,160 --> 00:04:48,479
themselves

00:04:45,840 --> 00:04:50,320
this is kind of nice because it doesn't

00:04:48,479 --> 00:04:52,560
require a connection between your

00:04:50,320 --> 00:04:54,639
office to that cloud provider or that

00:04:52,560 --> 00:04:56,160
distributed data center

00:04:54,639 --> 00:04:59,040
but it's kind of harder to manage

00:04:56,160 --> 00:05:02,400
because they're all of these individual

00:04:59,040 --> 00:05:03,600
um get offs tools and clusters and so on

00:05:02,400 --> 00:05:04,800
so you really just have to kind of pick

00:05:03,600 --> 00:05:08,240
the tool that really fits your

00:05:04,800 --> 00:05:08,240
organization and your scale

00:05:08,560 --> 00:05:12,560
so the tool that we've just been kind of

00:05:11,120 --> 00:05:15,600
almost in love with for the last

00:05:12,560 --> 00:05:17,919
year has been argo cd the reason why

00:05:15,600 --> 00:05:19,440
we've kind of chose this one is

00:05:17,919 --> 00:05:21,280
the fact that it can operate in a hub

00:05:19,440 --> 00:05:22,720
and spoke model

00:05:21,280 --> 00:05:24,720
and it can operate in a cluster

00:05:22,720 --> 00:05:27,360
independent module so

00:05:24,720 --> 00:05:28,000
it has like that both kind of feel to it

00:05:27,360 --> 00:05:30,240
um

00:05:28,000 --> 00:05:32,320
there's templating with customizing helm

00:05:30,240 --> 00:05:33,520
um we absolutely love customize because

00:05:32,320 --> 00:05:35,280
it's so easy

00:05:33,520 --> 00:05:36,639
especially we do a ton of work in

00:05:35,280 --> 00:05:39,120
multi-cluster

00:05:36,639 --> 00:05:41,280
so customize and the github store are

00:05:39,120 --> 00:05:44,400
just like our best friends

00:05:41,280 --> 00:05:46,960
argo cd also brings in the idea of

00:05:44,400 --> 00:05:48,639
pruning which a lot of github's tools

00:05:46,960 --> 00:05:52,800
are really scared of

00:05:48,639 --> 00:05:54,720
um when i say it does pruning think of

00:05:52,800 --> 00:05:57,199
think of a situation where you apply

00:05:54,720 --> 00:06:00,240
something manually to your cluster

00:05:57,199 --> 00:06:04,400
and it's not good at all and

00:06:00,240 --> 00:06:06,400
it's just there what the argo cd will do

00:06:04,400 --> 00:06:08,479
is it will actually remediate that and

00:06:06,400 --> 00:06:09,600
remove that manually created item from

00:06:08,479 --> 00:06:11,759
your cluster

00:06:09,600 --> 00:06:13,039
so if you're security minded this is

00:06:11,759 --> 00:06:15,759
awesome this is

00:06:13,039 --> 00:06:17,440
a security administrator as well as your

00:06:15,759 --> 00:06:19,919
get ops tool

00:06:17,440 --> 00:06:21,520
handling stuff for you this this get ops

00:06:19,919 --> 00:06:24,319
tool is security and

00:06:21,520 --> 00:06:26,560
deployment and as i said earlier it does

00:06:24,319 --> 00:06:30,319
multi-cluster configurations which is

00:06:26,560 --> 00:06:32,160
massive for the work that we do

00:06:30,319 --> 00:06:33,600
so as i was saying a minute ago we love

00:06:32,160 --> 00:06:36,000
customize

00:06:33,600 --> 00:06:36,960
customize was actually the tool itself

00:06:36,000 --> 00:06:39,520
the tooling

00:06:36,960 --> 00:06:42,680
and the ability to use it was integrated

00:06:39,520 --> 00:06:45,520
into kubernetes 1.14 so if you run

00:06:42,680 --> 00:06:47,600
cubeapply.k it's going to attempt to

00:06:45,520 --> 00:06:49,919
customize your directory

00:06:47,600 --> 00:06:51,360
um all customize really does is allows

00:06:49,919 --> 00:06:54,560
you to provide overrides

00:06:51,360 --> 00:06:57,039
of specific entries for example

00:06:54,560 --> 00:06:59,360
if one location should have more

00:06:57,039 --> 00:07:01,199
replicas of a pod than another

00:06:59,360 --> 00:07:02,639
it's just it's really cool and really

00:07:01,199 --> 00:07:04,720
simplistic

00:07:02,639 --> 00:07:06,720
and it makes your your code kind of

00:07:04,720 --> 00:07:09,039
minimalized

00:07:06,720 --> 00:07:12,000
and it's super powerful when we talk

00:07:09,039 --> 00:07:12,000
about multi-cluster

00:07:13,120 --> 00:07:16,479
so now we're going to completely switch

00:07:14,560 --> 00:07:19,280
gears and go to techton

00:07:16,479 --> 00:07:21,280
um with get offs in our argo cd tool

00:07:19,280 --> 00:07:23,840
that was applying resources to our

00:07:21,280 --> 00:07:25,599
environments and keeping them in check

00:07:23,840 --> 00:07:27,120
techton is going to be actually our ci

00:07:25,599 --> 00:07:29,120
cd tool

00:07:27,120 --> 00:07:30,319
and it's the ability to when i say that

00:07:29,120 --> 00:07:32,479
csdd tool

00:07:30,319 --> 00:07:33,840
it's going to create our artifacts or

00:07:32,479 --> 00:07:38,000
environment it can create

00:07:33,840 --> 00:07:39,919
images it can create a pull request

00:07:38,000 --> 00:07:42,479
of our different deployment of the image

00:07:39,919 --> 00:07:45,840
that we just created

00:07:42,479 --> 00:07:48,000
it runs serverless so when i say that

00:07:45,840 --> 00:07:49,919
that means there is no pod sitting there

00:07:48,000 --> 00:07:52,720
waiting for work to happen

00:07:49,919 --> 00:07:54,160
you actually launch against the uh

00:07:52,720 --> 00:07:55,919
techton endpoint

00:07:54,160 --> 00:07:58,639
and then a pod is created and then goes

00:07:55,919 --> 00:08:00,720
away when it's done so it's

00:07:58,639 --> 00:08:02,319
different than previous generations

00:08:00,720 --> 00:08:03,840
where we have our jenkins server that

00:08:02,319 --> 00:08:06,960
just hangs out and waits for

00:08:03,840 --> 00:08:11,120
work to be done this only executes when

00:08:06,960 --> 00:08:11,840
called upon um it enables pipeline and

00:08:11,120 --> 00:08:14,000
workflow

00:08:11,840 --> 00:08:16,000
functionality that is something that

00:08:14,000 --> 00:08:17,840
argo can't do today

00:08:16,000 --> 00:08:19,599
argo will look at a directory and it's

00:08:17,840 --> 00:08:22,960
just going to apply everything

00:08:19,599 --> 00:08:24,560
in no specific order a demonstration

00:08:22,960 --> 00:08:27,520
which i'll show here in a moment

00:08:24,560 --> 00:08:28,479
shows why order is sometimes important

00:08:27,520 --> 00:08:30,160
and then the last piece i'm going to

00:08:28,479 --> 00:08:31,680
cover it's pluggable when i say that

00:08:30,160 --> 00:08:33,839
it's pluggable

00:08:31,680 --> 00:08:35,839
you could take the same set of tasks

00:08:33,839 --> 00:08:37,440
that your developers and your users and

00:08:35,839 --> 00:08:38,880
administrators develop

00:08:37,440 --> 00:08:40,719
and then you actually just hand it out

00:08:38,880 --> 00:08:42,640
to everybody

00:08:40,719 --> 00:08:44,000
so the cool thing is creates a really a

00:08:42,640 --> 00:08:46,080
sharing environment

00:08:44,000 --> 00:08:47,920
you can reuse these tasks over and over

00:08:46,080 --> 00:08:49,360
in different pipelines

00:08:47,920 --> 00:08:50,959
or in different groups within your

00:08:49,360 --> 00:08:53,360
organization

00:08:50,959 --> 00:08:54,240
and so the next step is i'm actually

00:08:53,360 --> 00:08:56,000
going to break down some of this

00:08:54,240 --> 00:08:57,600
terminology i know that i just said

00:08:56,000 --> 00:09:01,279
pipeline

00:08:57,600 --> 00:09:03,680
so they have these individual

00:09:01,279 --> 00:09:04,959
um i guess processes is the best way to

00:09:03,680 --> 00:09:08,160
put it a task

00:09:04,959 --> 00:09:11,839
is the simplest process a pipeline

00:09:08,160 --> 00:09:13,519
is a series of tasks and you see this

00:09:11,839 --> 00:09:15,120
event listener trigger binding and

00:09:13,519 --> 00:09:19,760
trigger template

00:09:15,120 --> 00:09:21,839
and that allows you to create a web hook

00:09:19,760 --> 00:09:24,080
that will execute this pipeline in these

00:09:21,839 --> 00:09:25,760
tasks so to kind of break this

00:09:24,080 --> 00:09:27,680
a little bit easier for us to understand

00:09:25,760 --> 00:09:30,240
let me show you example of a pipeline

00:09:27,680 --> 00:09:32,000
that i have to use regularly

00:09:30,240 --> 00:09:33,680
so as you see when i'm sharing my screen

00:09:32,000 --> 00:09:35,120
here i have to do like a ton of

00:09:33,680 --> 00:09:38,800
multi-cluster work

00:09:35,120 --> 00:09:42,000
and i make mistakes frequently um

00:09:38,800 --> 00:09:44,800
so what i did was i have this pipeline

00:09:42,000 --> 00:09:46,640
that creates clusters sleeps and then

00:09:44,800 --> 00:09:47,680
peers the two newly created clusters

00:09:46,640 --> 00:09:49,600
together

00:09:47,680 --> 00:09:51,920
so i have highlighted here this create

00:09:49,600 --> 00:09:54,800
test so let's actually break down

00:09:51,920 --> 00:09:55,760
what this actually looks like so this

00:09:54,800 --> 00:09:58,240
creek

00:09:55,760 --> 00:09:59,360
cluster task all that it really actually

00:09:58,240 --> 00:10:02,880
is

00:09:59,360 --> 00:10:04,720
is running a cube ctl create command

00:10:02,880 --> 00:10:06,320
and what it's doing is it's checking my

00:10:04,720 --> 00:10:08,240
git repository

00:10:06,320 --> 00:10:09,920
and then applying whatever is a negative

00:10:08,240 --> 00:10:11,760
repository

00:10:09,920 --> 00:10:13,600
so where does the get repository

00:10:11,760 --> 00:10:15,839
actually come from

00:10:13,600 --> 00:10:16,959
and that is actually where that task run

00:10:15,839 --> 00:10:19,760
comes in

00:10:16,959 --> 00:10:20,320
your task run tells the task what the

00:10:19,760 --> 00:10:23,519
answers

00:10:20,320 --> 00:10:25,760
are to the variables that it needs so

00:10:23,519 --> 00:10:26,800
as you can see i have my gear repository

00:10:25,760 --> 00:10:29,120
here

00:10:26,800 --> 00:10:31,440
and my path to my yaml file in which

00:10:29,120 --> 00:10:34,399
that create cluster

00:10:31,440 --> 00:10:37,760
task actually has to run the really cool

00:10:34,399 --> 00:10:39,279
thing is going back to this task here

00:10:37,760 --> 00:10:41,279
actually i'm able to use it more than

00:10:39,279 --> 00:10:43,680
one time so

00:10:41,279 --> 00:10:45,120
you're seeing it here going to my

00:10:43,680 --> 00:10:47,040
pipeline

00:10:45,120 --> 00:10:48,640
you're gonna see this create cluster one

00:10:47,040 --> 00:10:50,560
and create cluster two

00:10:48,640 --> 00:10:53,040
that's the strength of pipelines because

00:10:50,560 --> 00:10:55,839
i have multiple tasks

00:10:53,040 --> 00:10:56,959
going in a specific order and then at

00:10:55,839 --> 00:11:00,160
the end of it i

00:10:56,959 --> 00:11:03,200
i end up with two clusters that are

00:11:00,160 --> 00:11:03,839
amazon peered together and allow me to

00:11:03,200 --> 00:11:06,720
develop

00:11:03,839 --> 00:11:08,720
and start working immediately so looking

00:11:06,720 --> 00:11:09,279
at our pipeline it's very similar to

00:11:08,720 --> 00:11:12,480
tasks

00:11:09,279 --> 00:11:14,000
it's just a little bit more dense we

00:11:12,480 --> 00:11:17,200
have a couple parameters that we

00:11:14,000 --> 00:11:18,720
require to run our pipeline and those

00:11:17,200 --> 00:11:20,079
are actually answered within our

00:11:18,720 --> 00:11:22,320
pipeline run

00:11:20,079 --> 00:11:24,880
um as you see here here's my answers i'd

00:11:22,320 --> 00:11:27,040
like cluster one and cluster two

00:11:24,880 --> 00:11:30,240
uh as you see here and then it

00:11:27,040 --> 00:11:32,399
references our create cluster pipeline

00:11:30,240 --> 00:11:33,360
so as you see they all kind of tie back

00:11:32,399 --> 00:11:34,720
together

00:11:33,360 --> 00:11:36,800
and then the last item that i'm going to

00:11:34,720 --> 00:11:39,440
cover is the

00:11:36,800 --> 00:11:39,839
what they call a trigger template it

00:11:39,440 --> 00:11:42,000
looks

00:11:39,839 --> 00:11:43,200
very similar to pipelines as you can see

00:11:42,000 --> 00:11:45,440
here

00:11:43,200 --> 00:11:48,000
same variables we have a pipeline

00:11:45,440 --> 00:11:50,880
resource and we have our pipeline run

00:11:48,000 --> 00:11:52,240
and what this trigger template and below

00:11:50,880 --> 00:11:53,440
as you see here trigger binding and

00:11:52,240 --> 00:11:55,920
event list

00:11:53,440 --> 00:11:57,360
this actually creates a web hook and

00:11:55,920 --> 00:12:00,079
what you can do with this web hook

00:11:57,360 --> 00:12:00,480
is you can give this to github get lab

00:12:00,079 --> 00:12:02,079
and then

00:12:00,480 --> 00:12:04,240
anytime your code is committed it's

00:12:02,079 --> 00:12:05,600
going to kick off a new build for you

00:12:04,240 --> 00:12:08,160
so mario is actually going to show that

00:12:05,600 --> 00:12:11,519
later on with a really fun demo

00:12:08,160 --> 00:12:14,079
with some cicd testing so

00:12:11,519 --> 00:12:16,240
going back to our slides you're actually

00:12:14,079 --> 00:12:20,800
going to probably ask me right now

00:12:16,240 --> 00:12:22,720
why are you using argo and tecton

00:12:20,800 --> 00:12:24,480
and the easiest way and kind of why i

00:12:22,720 --> 00:12:27,440
showed that demonstration a minute ago

00:12:24,480 --> 00:12:29,279
is the fact that i need my clusters

00:12:27,440 --> 00:12:31,360
actually created

00:12:29,279 --> 00:12:33,279
before i can actually peer them and

00:12:31,360 --> 00:12:35,040
that's one of the things argo cd would

00:12:33,279 --> 00:12:35,600
actually create my clusters for me and

00:12:35,040 --> 00:12:39,279
do an

00:12:35,600 --> 00:12:40,079
amazing job of it but it would never

00:12:39,279 --> 00:12:42,240
know

00:12:40,079 --> 00:12:44,639
when they were actually available to the

00:12:42,240 --> 00:12:47,040
point where i could actually peer them

00:12:44,639 --> 00:12:48,800
so they kind of go hand in hand together

00:12:47,040 --> 00:12:51,839
and create a very

00:12:48,800 --> 00:12:52,639
very strong team and they utilize each

00:12:51,839 --> 00:12:55,040
other's strengths

00:12:52,639 --> 00:12:56,240
uh techton is perfect at handling your

00:12:55,040 --> 00:12:58,240
image life cycle

00:12:56,240 --> 00:13:00,880
argo cd doesn't really have any idea of

00:12:58,240 --> 00:13:02,720
that so when i say your image lifecycle

00:13:00,880 --> 00:13:04,959
tecton is going to build your container

00:13:02,720 --> 00:13:05,920
image it's going to put all the assets

00:13:04,959 --> 00:13:07,360
and then it's going to push it to your

00:13:05,920 --> 00:13:09,519
repository

00:13:07,360 --> 00:13:12,560
you can add testing within techton uh

00:13:09,519 --> 00:13:14,800
your tech on tasks in your pipeline

00:13:12,560 --> 00:13:16,800
and then the really fun thing where we

00:13:14,800 --> 00:13:19,040
tie this all back together with argo

00:13:16,800 --> 00:13:20,000
and what i was saying earlier you can

00:13:19,040 --> 00:13:22,959
have all of your tasks

00:13:20,000 --> 00:13:25,040
sitting in one get repository and then

00:13:22,959 --> 00:13:26,800
you just provide the namespace and argo

00:13:25,040 --> 00:13:28,800
is going to share out any tasks that

00:13:26,800 --> 00:13:30,560
your team comes up with

00:13:28,800 --> 00:13:32,000
to the different namespaces to those

00:13:30,560 --> 00:13:33,680
different developer groups

00:13:32,000 --> 00:13:35,120
so that we're not recreating the same

00:13:33,680 --> 00:13:38,560
work over and over again

00:13:35,120 --> 00:13:41,440
so it it's such a good team together

00:13:38,560 --> 00:13:42,320
um one handles the ammo objects other

00:13:41,440 --> 00:13:46,800
creates

00:13:42,320 --> 00:13:48,959
handles the workflows and asset creation

00:13:46,800 --> 00:13:50,560
so i'm actually going to cover a couple

00:13:48,959 --> 00:13:53,199
of helpful binaries

00:13:50,560 --> 00:13:54,959
that um you would actually use uh when

00:13:53,199 --> 00:13:57,199
it comes to these scenarios

00:13:54,959 --> 00:13:59,199
you'll see there's an argo cd binary all

00:13:57,199 --> 00:14:01,199
this actually does is it allows you to

00:13:59,199 --> 00:14:03,920
interact with auger cd

00:14:01,199 --> 00:14:06,079
are not using the web ui um there's also

00:14:03,920 --> 00:14:08,160
the tkn binary

00:14:06,079 --> 00:14:10,079
same exact story it allows you to

00:14:08,160 --> 00:14:12,560
interact with techton

00:14:10,079 --> 00:14:13,279
without having to actually go and modify

00:14:12,560 --> 00:14:16,399
the ammo

00:14:13,279 --> 00:14:18,000
or running cube cuddle logs and trying

00:14:16,399 --> 00:14:18,560
to figure out what this job's actually

00:14:18,000 --> 00:14:20,720
going

00:14:18,560 --> 00:14:21,760
on or what's what's happening to it and

00:14:20,720 --> 00:14:25,279
then last

00:14:21,760 --> 00:14:26,880
how i mentioned earlier with cube seal

00:14:25,279 --> 00:14:28,880
cube seal will allow us to create

00:14:26,880 --> 00:14:29,839
concealed secrets which we can actually

00:14:28,880 --> 00:14:33,199
store

00:14:29,839 --> 00:14:34,639
within our excuse me uh within our git

00:14:33,199 --> 00:14:37,199
repository

00:14:34,639 --> 00:14:38,720
and the sealed secrets are only able to

00:14:37,199 --> 00:14:42,160
be unlocked unless you have the

00:14:38,720 --> 00:14:44,079
the required certificates and so

00:14:42,160 --> 00:14:45,440
um with that being said let's actually

00:14:44,079 --> 00:14:47,519
see a demonstration

00:14:45,440 --> 00:14:48,880
of all of these pieces together with

00:14:47,519 --> 00:14:51,839
argo cd

00:14:48,880 --> 00:14:53,519
uh techton um as you can see here this

00:14:51,839 --> 00:14:55,440
is kind of the demo architecture

00:14:53,519 --> 00:14:57,440
we're gonna store our yemo files within

00:14:55,440 --> 00:15:00,160
git

00:14:57,440 --> 00:15:01,120
and then uh argo cd is going to actually

00:15:00,160 --> 00:15:03,519
populate

00:15:01,120 --> 00:15:05,279
our stage and production namespaces with

00:15:03,519 --> 00:15:08,079
the assets created

00:15:05,279 --> 00:15:11,120
uh by tekton and with that i'm going to

00:15:08,079 --> 00:15:11,120
pass over to mario

00:15:11,199 --> 00:15:18,240
okay thank you ryan all right so

00:15:15,040 --> 00:15:20,079
let me explain uh the demo that we are

00:15:18,240 --> 00:15:23,199
going to do today a bit

00:15:20,079 --> 00:15:25,519
so basically we have a really simple

00:15:23,199 --> 00:15:28,639
golan application

00:15:25,519 --> 00:15:29,839
that we want to every time a new commit

00:15:28,639 --> 00:15:31,519
hits the

00:15:29,839 --> 00:15:33,440
master branch of our application

00:15:31,519 --> 00:15:36,959
repository we want

00:15:33,440 --> 00:15:37,360
a pipeline to be run which will link our

00:15:36,959 --> 00:15:40,639
code

00:15:37,360 --> 00:15:43,759
then it will test our code and finally

00:15:40,639 --> 00:15:45,920
it will build our code and when all of

00:15:43,759 --> 00:15:47,600
that happens if everything goes okay

00:15:45,920 --> 00:15:49,759
then we will create a new container

00:15:47,600 --> 00:15:51,360
image that will be pushed to a

00:15:49,759 --> 00:15:52,959
container registry in this case we're

00:15:51,360 --> 00:15:57,519
using quay

00:15:52,959 --> 00:16:01,440
and on top of that we will update the

00:15:57,519 --> 00:16:03,120
the deployment files and then we will

00:16:01,440 --> 00:16:04,399
be able to deploy the new release

00:16:03,120 --> 00:16:05,680
automatically to the stitching

00:16:04,399 --> 00:16:07,519
environment

00:16:05,680 --> 00:16:09,120
and then for the production environment

00:16:07,519 --> 00:16:12,720
we will see a different pipeline

00:16:09,120 --> 00:16:16,240
which will basically promote the stage

00:16:12,720 --> 00:16:18,399
image to the production environment

00:16:16,240 --> 00:16:20,639
and that will generate a pr and when

00:16:18,399 --> 00:16:24,000
that pr is reviewed when that merges

00:16:20,639 --> 00:16:24,480
then the application will be deployed to

00:16:24,000 --> 00:16:26,480
the

00:16:24,480 --> 00:16:27,920
production environment in this case as

00:16:26,480 --> 00:16:30,959
ryan said

00:16:27,920 --> 00:16:32,959
we are using name spaces as environments

00:16:30,959 --> 00:16:35,040
but this could be done using different

00:16:32,959 --> 00:16:38,079
clusters and every cluster

00:16:35,040 --> 00:16:38,880
will be a different environment argo cd

00:16:38,079 --> 00:16:41,600
as you know

00:16:38,880 --> 00:16:43,519
supports multi-cluster so you could do

00:16:41,600 --> 00:16:47,040
that as well

00:16:43,519 --> 00:16:51,279
and without further ado let me

00:16:47,040 --> 00:16:54,959
share my screen really quick

00:16:51,279 --> 00:16:56,800
all right so this is the you are

00:16:54,959 --> 00:16:58,000
seeing now is the argo cd web ui but

00:16:56,800 --> 00:16:59,600
let's just start

00:16:58,000 --> 00:17:01,519
explaining the different repositories

00:16:59,600 --> 00:17:04,079
that we have so the first one

00:17:01,519 --> 00:17:05,280
as i said it's uh the application

00:17:04,079 --> 00:17:07,679
repository

00:17:05,280 --> 00:17:08,720
here we have a really simple golang

00:17:07,679 --> 00:17:10,880
application

00:17:08,720 --> 00:17:12,160
we have the docker file which instructs

00:17:10,880 --> 00:17:15,120
how to build the image

00:17:12,160 --> 00:17:15,600
using the binaries we have the test the

00:17:15,120 --> 00:17:18,799
test

00:17:15,600 --> 00:17:21,839
file files and

00:17:18,799 --> 00:17:24,720
it's just a single rant

00:17:21,839 --> 00:17:25,760
that's pretty much it and then we have

00:17:24,720 --> 00:17:28,559
the cicd

00:17:25,760 --> 00:17:30,320
repository in this cic repository we

00:17:28,559 --> 00:17:33,039
have multiple branches

00:17:30,320 --> 00:17:34,720
so the first one that i'm going to show

00:17:33,039 --> 00:17:38,880
is the ci

00:17:34,720 --> 00:17:43,679
here's where where we store every single

00:17:38,880 --> 00:17:47,840
uh ci file that we use for tecton

00:17:43,679 --> 00:17:47,840
it's taking a bit to load

00:17:48,080 --> 00:17:50,400
you see

00:17:52,960 --> 00:17:56,559
all right i cannot reach the

00:17:56,960 --> 00:18:01,120
okay anyway so we have different

00:17:58,640 --> 00:18:01,760
branches so we have the ci branch which

00:18:01,120 --> 00:18:04,000
has the

00:18:01,760 --> 00:18:05,200
tecton files that we are going to use in

00:18:04,000 --> 00:18:08,000
our pipelines

00:18:05,200 --> 00:18:08,720
then we have the config branch which

00:18:08,000 --> 00:18:12,160
will store

00:18:08,720 --> 00:18:14,240
the different files used by

00:18:12,160 --> 00:18:16,080
choose to deploy our application to

00:18:14,240 --> 00:18:19,120
multiple environments

00:18:16,080 --> 00:18:23,679
um i really need this to to load

00:18:19,120 --> 00:18:29,840
in order to explain it well maybe i can

00:18:23,679 --> 00:18:29,840
go to github if this is not working

00:18:31,360 --> 00:18:34,160
okay never mind

00:18:36,480 --> 00:18:43,840
let me change to a different repository

00:18:39,840 --> 00:18:43,840
really quick

00:18:46,640 --> 00:18:50,960
okay so basically this is the same repo

00:18:49,120 --> 00:18:54,400
which is public on github

00:18:50,960 --> 00:18:57,120
so as i said we have the config branch

00:18:54,400 --> 00:18:58,880
where we have the files that are common

00:18:57,120 --> 00:19:01,760
to all our environments

00:18:58,880 --> 00:19:02,559
so for example here we have a deployment

00:19:01,760 --> 00:19:04,720
this is a

00:19:02,559 --> 00:19:06,240
really simple kubernetes deployment we

00:19:04,720 --> 00:19:08,799
have an image and then

00:19:06,240 --> 00:19:10,000
we have a release environment variable

00:19:08,799 --> 00:19:12,000
which we can set to

00:19:10,000 --> 00:19:13,600
different values in this case is set to

00:19:12,000 --> 00:19:16,400
base release

00:19:13,600 --> 00:19:18,160
and then we have the service and the

00:19:16,400 --> 00:19:19,600
customization file the customization

00:19:18,160 --> 00:19:21,919
file in this case

00:19:19,600 --> 00:19:24,640
for the ones that know about customize

00:19:21,919 --> 00:19:26,880
it's really simple we just we are just

00:19:24,640 --> 00:19:28,880
saying that we are we have two resources

00:19:26,880 --> 00:19:29,840
here the deployment file and the service

00:19:28,880 --> 00:19:32,000
file

00:19:29,840 --> 00:19:33,679
and then we have the different branches

00:19:32,000 --> 00:19:35,039
for our environments we have for example

00:19:33,679 --> 00:19:38,320
production

00:19:35,039 --> 00:19:41,440
and in this range we have

00:19:38,320 --> 00:19:43,280
different files this file

00:19:41,440 --> 00:19:44,720
those are the files that are deferred

00:19:43,280 --> 00:19:46,960
from our config

00:19:44,720 --> 00:19:48,000
configuration our base configuration

00:19:46,960 --> 00:19:50,240
sorry

00:19:48,000 --> 00:19:51,520
so if we look at the deployment you can

00:19:50,240 --> 00:19:54,080
see that we are just

00:19:51,520 --> 00:19:55,120
using a different image and then we are

00:19:54,080 --> 00:19:57,440
setting the release

00:19:55,120 --> 00:19:59,520
variable to a different uh value in this

00:19:57,440 --> 00:20:02,559
case production release

00:19:59,520 --> 00:20:05,200
so that's that's okay other than that

00:20:02,559 --> 00:20:06,320
um here here in the customization file

00:20:05,200 --> 00:20:09,520
we are seeing that

00:20:06,320 --> 00:20:13,039
our base files are present on this

00:20:09,520 --> 00:20:15,039
same git repository on the config branch

00:20:13,039 --> 00:20:17,120
and then we have other resources that

00:20:15,039 --> 00:20:19,919
are specific to this environment

00:20:17,120 --> 00:20:20,720
which are the name space and the ingress

00:20:19,919 --> 00:20:22,559
and then we are

00:20:20,720 --> 00:20:24,880
patching the deployment file so if we

00:20:22,559 --> 00:20:26,320
look at the namespace for example here

00:20:24,880 --> 00:20:27,919
we can see that we are using a

00:20:26,320 --> 00:20:30,400
reverseros production name

00:20:27,919 --> 00:20:31,840
for our namespace and for example if we

00:20:30,400 --> 00:20:35,200
go to the states

00:20:31,840 --> 00:20:36,159
branch we will see that we are using

00:20:35,200 --> 00:20:39,520
this

00:20:36,159 --> 00:20:42,480
name for the states so that's

00:20:39,520 --> 00:20:43,360
what we have in the gitlab repository

00:20:42,480 --> 00:20:46,720
and now

00:20:43,360 --> 00:20:49,039
i'm going to explain the

00:20:46,720 --> 00:20:49,760
the different pipelines with a more

00:20:49,039 --> 00:20:53,679
detailed

00:20:49,760 --> 00:20:58,000
drm so first our developers

00:20:53,679 --> 00:21:01,360
will send code changes to um

00:20:58,000 --> 00:21:04,240
to gitlab and and then

00:21:01,360 --> 00:21:05,520
when that happens that will actually uh

00:21:04,240 --> 00:21:08,080
trigger a web hook

00:21:05,520 --> 00:21:09,520
the web hook will instruct techton to

00:21:08,080 --> 00:21:12,799
run a pipeline

00:21:09,520 --> 00:21:14,559
the pipeline uh will lean test

00:21:12,799 --> 00:21:16,720
and then build our code create a new

00:21:14,559 --> 00:21:17,840
image we'll push the new image to the

00:21:16,720 --> 00:21:21,840
red hat create

00:21:17,840 --> 00:21:22,320
io registry then the pipeline will go

00:21:21,840 --> 00:21:25,600
ahead

00:21:22,320 --> 00:21:26,960
and update the cicd repository and in

00:21:25,600 --> 00:21:29,520
the states

00:21:26,960 --> 00:21:30,480
branch the deployment file will be

00:21:29,520 --> 00:21:33,520
modified

00:21:30,480 --> 00:21:36,799
so now it uses the new release that was

00:21:33,520 --> 00:21:39,760
created on quay.iot new image

00:21:36,799 --> 00:21:41,600
after that happens that change on the

00:21:39,760 --> 00:21:44,159
cicd repository

00:21:41,600 --> 00:21:45,039
will trigger another web hook that

00:21:44,159 --> 00:21:48,400
willian stroke

00:21:45,039 --> 00:21:50,640
will instruct argo cd to actually

00:21:48,400 --> 00:21:52,240
actually go ahead and deploy the

00:21:50,640 --> 00:21:56,080
application to the state's

00:21:52,240 --> 00:21:58,159
namespace that way

00:21:56,080 --> 00:21:59,840
once a commit hits the master branch on

00:21:58,159 --> 00:22:03,200
our application repository

00:21:59,840 --> 00:22:04,000
we will get the that code deployed

00:22:03,200 --> 00:22:07,679
automatically

00:22:04,000 --> 00:22:10,320
without a human human intervention

00:22:07,679 --> 00:22:11,360
and then when we have tested the code on

00:22:10,320 --> 00:22:12,799
the staging environment

00:22:11,360 --> 00:22:15,200
and we are ready to move it to

00:22:12,799 --> 00:22:17,440
production there's a different pipeline

00:22:15,200 --> 00:22:20,720
in this case the developers

00:22:17,440 --> 00:22:24,000
or the csat means whoever

00:22:20,720 --> 00:22:26,880
wants to needs to

00:22:24,000 --> 00:22:28,240
run a pipeline manually we'll need to

00:22:26,880 --> 00:22:30,720
introduce some data

00:22:28,240 --> 00:22:31,840
and that will actually generate a

00:22:30,720 --> 00:22:34,640
pipeline run

00:22:31,840 --> 00:22:35,200
that will go ahead and open a pull

00:22:34,640 --> 00:22:38,480
request

00:22:35,200 --> 00:22:41,679
against our cicd repository

00:22:38,480 --> 00:22:42,480
on the production branch and then that

00:22:41,679 --> 00:22:45,360
pr

00:22:42,480 --> 00:22:45,760
will be reviewed by some of some people

00:22:45,360 --> 00:22:48,799
or

00:22:45,760 --> 00:22:51,840
maybe the environment admins or whatever

00:22:48,799 --> 00:22:52,559
and once once this pr once that pr is

00:22:51,840 --> 00:22:55,840
merged

00:22:52,559 --> 00:22:57,280
then argo cd that will trigger a web

00:22:55,840 --> 00:22:59,840
hook and argo cd

00:22:57,280 --> 00:23:01,919
will go ahead and create the production

00:22:59,840 --> 00:23:05,200
and deploy the production

00:23:01,919 --> 00:23:09,760
application so

00:23:05,200 --> 00:23:12,720
let me go to argo cd really quick

00:23:09,760 --> 00:23:13,919
so now we don't have anything loaded in

00:23:12,720 --> 00:23:16,240
argo cd

00:23:13,919 --> 00:23:17,360
so the first thing that i'm going to do

00:23:16,240 --> 00:23:20,480
is

00:23:17,360 --> 00:23:24,000
i'm going to add the

00:23:20,480 --> 00:23:24,400
cicd repository so githubs is all about

00:23:24,000 --> 00:23:26,960
git

00:23:24,400 --> 00:23:28,080
so we need our git repository loaded

00:23:26,960 --> 00:23:29,840
into gitlab

00:23:28,080 --> 00:23:32,080
so i'm i'm saying this is my git

00:23:29,840 --> 00:23:32,960
repository i don't need any username or

00:23:32,080 --> 00:23:36,080
password

00:23:32,960 --> 00:23:38,720
in order to clone it so i will go ahead

00:23:36,080 --> 00:23:38,720
click connect

00:23:40,000 --> 00:23:44,799
and that so that our git repository to

00:23:47,200 --> 00:23:51,840
let me see

00:23:55,360 --> 00:23:57,760
all right

00:23:58,559 --> 00:24:04,159
so i don't know if something is

00:24:00,880 --> 00:24:06,880
happening with the

00:24:04,159 --> 00:24:08,080
with the gitlab server but it's not

00:24:06,880 --> 00:24:13,200
working for me

00:24:08,080 --> 00:24:13,200
let me try uh let's try using the

00:24:14,480 --> 00:24:20,320
the cli let's see if we have

00:24:18,000 --> 00:24:20,320
more

00:24:21,380 --> 00:24:25,360
[Music]

00:24:23,120 --> 00:24:25,360
okay

00:24:28,640 --> 00:24:35,840
so it seems i cannot i cannot reach

00:24:32,000 --> 00:24:39,760
the the argus the gitlab server from my

00:24:35,840 --> 00:24:42,799
computer or from the server so

00:24:39,760 --> 00:24:43,840
i need to so our gitlab is down so i'm

00:24:42,799 --> 00:24:45,760
going to

00:24:43,840 --> 00:24:47,760
try to perform the same demo using

00:24:45,760 --> 00:24:48,320
github i'm not sure if everything will

00:24:47,760 --> 00:24:51,440
work

00:24:48,320 --> 00:24:53,840
i will try to make it work so as i

00:24:51,440 --> 00:24:56,400
as i said i'm going to use this

00:24:53,840 --> 00:25:00,080
repository here

00:24:56,400 --> 00:25:03,520
in this case it will be github um

00:25:00,080 --> 00:25:03,520
then i'm sorry

00:25:04,640 --> 00:25:08,159
okay let's go to github this is

00:25:07,120 --> 00:25:10,799
connected

00:25:08,159 --> 00:25:11,200
and now i'm going to go ahead and create

00:25:10,799 --> 00:25:14,799
the

00:25:11,200 --> 00:25:17,600
staging application um

00:25:14,799 --> 00:25:19,600
let me create applications really quick

00:25:17,600 --> 00:25:22,080
so i'm going to

00:25:19,600 --> 00:25:22,080
name it

00:25:22,880 --> 00:25:29,039
reverse words states

00:25:26,000 --> 00:25:31,120
then the project will be used so argo cd

00:25:29,039 --> 00:25:33,360
has different projects you can

00:25:31,120 --> 00:25:34,720
like have projects to store your

00:25:33,360 --> 00:25:37,039
different applications

00:25:34,720 --> 00:25:38,000
like if it was an image space kind of

00:25:37,039 --> 00:25:41,919
thing

00:25:38,000 --> 00:25:45,840
um sorry i'm working on the web ui now

00:25:41,919 --> 00:25:48,159
and and yes basically we are

00:25:45,840 --> 00:25:49,679
creating the application under default

00:25:48,159 --> 00:25:52,159
now the sync policy

00:25:49,679 --> 00:25:53,679
i'm setting it to automatic automat

00:25:52,159 --> 00:25:56,880
automatic what that means

00:25:53,679 --> 00:25:59,840
is that um argo cd

00:25:56,880 --> 00:26:01,760
will will query the git repository every

00:25:59,840 --> 00:26:04,640
three minutes by default

00:26:01,760 --> 00:26:05,279
and we'll try to see if any change is

00:26:04,640 --> 00:26:07,919
needed

00:26:05,279 --> 00:26:09,200
for our application and then we have

00:26:07,919 --> 00:26:11,520
here the print

00:26:09,200 --> 00:26:13,120
plant resources that ryan explained

00:26:11,520 --> 00:26:14,480
before what planning is we are not going

00:26:13,120 --> 00:26:17,840
to activate this

00:26:14,480 --> 00:26:19,039
and then self healing it's kind of the

00:26:17,840 --> 00:26:22,000
opposite of

00:26:19,039 --> 00:26:23,039
of pruning i would say so in case there

00:26:22,000 --> 00:26:25,120
is something in it

00:26:23,039 --> 00:26:26,240
that is not in the kubernetes cluster

00:26:25,120 --> 00:26:29,200
because someone

00:26:26,240 --> 00:26:30,799
someone deleted it or something argo cd

00:26:29,200 --> 00:26:34,159
will go ahead and

00:26:30,799 --> 00:26:36,840
create that for us again then we want to

00:26:34,159 --> 00:26:38,080
validate the

00:26:36,840 --> 00:26:41,600
resources

00:26:38,080 --> 00:26:43,679
against the schema then we have the the

00:26:41,600 --> 00:26:45,919
repository url which is the reverse

00:26:43,679 --> 00:26:47,520
words cicd repository

00:26:45,919 --> 00:26:49,120
as we are creating the states

00:26:47,520 --> 00:26:52,000
application we are going to

00:26:49,120 --> 00:26:53,039
to use the stage revision and our

00:26:52,000 --> 00:26:55,120
deployment files

00:26:53,039 --> 00:26:57,760
are in the root folder for that

00:26:55,120 --> 00:26:59,440
repository so we don't have any folders

00:26:57,760 --> 00:27:01,200
when you're using githubs there are

00:26:59,440 --> 00:27:03,679
multiple ways of

00:27:01,200 --> 00:27:05,039
storing your artifacts let's say inside

00:27:03,679 --> 00:27:07,200
the git repository

00:27:05,039 --> 00:27:09,039
you can go with folders or you can go

00:27:07,200 --> 00:27:11,679
with branches

00:27:09,039 --> 00:27:12,159
this is not a standard so you can do it

00:27:11,679 --> 00:27:15,440
the way

00:27:12,159 --> 00:27:17,520
that fits best for you then

00:27:15,440 --> 00:27:19,200
as a destination we are using the

00:27:17,520 --> 00:27:22,240
cluster where argo cd is running

00:27:19,200 --> 00:27:24,159
if we had more clusters added to this

00:27:22,240 --> 00:27:26,399
argo cd

00:27:24,159 --> 00:27:27,760
instance we could basically choose

00:27:26,399 --> 00:27:28,559
different clusters here that's the way

00:27:27,760 --> 00:27:31,840
that you do

00:27:28,559 --> 00:27:33,919
multi-cluster with argo cd

00:27:31,840 --> 00:27:37,279
and then the name space that we are

00:27:33,919 --> 00:27:39,919
deploying it's reverse words states

00:27:37,279 --> 00:27:41,520
the customize is okay let me try to

00:27:39,919 --> 00:27:44,720
verify if

00:27:41,520 --> 00:27:47,840
gitlab is working okay

00:27:44,720 --> 00:27:50,240
uh no luck that's right

00:27:47,840 --> 00:27:51,279
this will some things will fail uh we

00:27:50,240 --> 00:27:54,960
will try to

00:27:51,279 --> 00:27:54,960
see what fails and why

00:27:56,240 --> 00:28:00,080
so basically argosy now went ahead and

00:27:58,960 --> 00:28:03,520
created the

00:28:00,080 --> 00:28:06,720
different the different

00:28:03,520 --> 00:28:10,000
objects here we can see the

00:28:06,720 --> 00:28:12,799
deploy the deployment the service

00:28:10,000 --> 00:28:15,360
the ingress that won't work because it's

00:28:12,799 --> 00:28:17,279
using a different

00:28:15,360 --> 00:28:20,159
it's using a different domain that it's

00:28:17,279 --> 00:28:24,080
not properly set up at this point

00:28:20,159 --> 00:28:26,960
um then we have the board and

00:28:24,080 --> 00:28:28,480
let me let me try to i'm not sure if we

00:28:26,960 --> 00:28:31,760
will have time

00:28:28,480 --> 00:28:35,840
for doing this but i want to

00:28:31,760 --> 00:28:39,360
basically that

00:28:35,840 --> 00:28:43,679
to work so let's go to stage

00:28:39,360 --> 00:28:46,880
in the ingress let's edit the ingress

00:28:43,679 --> 00:28:47,279
oops all right i'm going to do it from

00:28:46,880 --> 00:28:49,760
the

00:28:47,279 --> 00:28:49,760
cli

00:28:52,799 --> 00:28:58,640
or maybe maybe we can we can go ahead

00:28:56,840 --> 00:29:01,440
and

00:28:58,640 --> 00:29:03,200
uh we can go ahead and continue with

00:29:01,440 --> 00:29:06,320
without that working

00:29:03,200 --> 00:29:09,520
okay i will do that um

00:29:06,320 --> 00:29:11,039
now i'm going to do the same thing

00:29:09,520 --> 00:29:15,200
i'm going to create a new application

00:29:11,039 --> 00:29:19,760
for production but in this case

00:29:15,200 --> 00:29:22,000
i'm i'm going to use the argo cd cli

00:29:19,760 --> 00:29:22,960
so this will be the command argo cd

00:29:22,000 --> 00:29:26,159
create project

00:29:22,960 --> 00:29:26,799
then the project same parameters but in

00:29:26,159 --> 00:29:29,679
this case

00:29:26,799 --> 00:29:30,320
i need to change the i need to change

00:29:29,679 --> 00:29:33,120
the

00:29:30,320 --> 00:29:36,399
the repository because this one is not

00:29:33,120 --> 00:29:41,840
it's not working because it's down

00:29:36,399 --> 00:29:41,840
so let me do that really quick

00:29:48,000 --> 00:29:53,360
okay so now the production application

00:29:50,880 --> 00:29:56,559
is created so we should see

00:29:53,360 --> 00:30:00,159
the production application coming up

00:29:56,559 --> 00:30:03,600
here same as before the ingress

00:30:00,159 --> 00:30:09,360
will be wrong because it's pointing to

00:30:03,600 --> 00:30:12,880
to a different server basically

00:30:09,360 --> 00:30:16,320
so that uh will not work um

00:30:12,880 --> 00:30:19,440
but now uh what what

00:30:16,320 --> 00:30:23,200
we wanted to show was the the web hook

00:30:19,440 --> 00:30:26,559
and i'm afraid that i'm not going to

00:30:23,200 --> 00:30:28,880
i'm not i won't be able to show that on

00:30:26,559 --> 00:30:29,600
on gitlab so i'm going to show it on

00:30:28,880 --> 00:30:32,159
github

00:30:29,600 --> 00:30:34,080
which is kind of the same but we we

00:30:32,159 --> 00:30:35,919
won't be able to run the

00:30:34,080 --> 00:30:37,760
automatic web hooks so i will need to

00:30:35,919 --> 00:30:42,240
run the pipeline manually

00:30:37,760 --> 00:30:51,840
but anyway i need to log in really quick

00:30:42,240 --> 00:30:51,840
let me do that

00:30:58,159 --> 00:31:05,840
okay let me put my authenticator code

00:31:06,799 --> 00:31:09,200
all right

00:31:14,320 --> 00:31:20,799
okay so if if i go to settings

00:31:18,720 --> 00:31:22,240
here you can see that we have the

00:31:20,799 --> 00:31:24,799
webhooks thing

00:31:22,240 --> 00:31:25,840
so in gitlab what i would i would do is

00:31:24,799 --> 00:31:29,200
basically

00:31:25,840 --> 00:31:30,320
come here and

00:31:29,200 --> 00:31:33,279
for this is for the deployment

00:31:30,320 --> 00:31:35,519
repository i will configure a webhook

00:31:33,279 --> 00:31:37,600
that says that whenever is there is a

00:31:35,519 --> 00:31:41,200
push to the

00:31:37,600 --> 00:31:41,760
to any branch it needs to send a webhook

00:31:41,200 --> 00:31:46,320
to this

00:31:41,760 --> 00:31:49,919
url this url is basically a argo cd

00:31:46,320 --> 00:31:50,399
endpoint and argo cd it's smart enough

00:31:49,919 --> 00:31:53,120
to

00:31:50,399 --> 00:31:53,600
understand which application it needs to

00:31:53,120 --> 00:31:56,080
update

00:31:53,600 --> 00:31:57,760
because um when you create an

00:31:56,080 --> 00:31:58,640
application you define a git repository

00:31:57,760 --> 00:32:01,919
and then

00:31:58,640 --> 00:32:02,480
you define a branch for that application

00:32:01,919 --> 00:32:04,720
so

00:32:02,480 --> 00:32:05,679
it will read the git repository and then

00:32:04,720 --> 00:32:07,919
it will read the

00:32:05,679 --> 00:32:09,679
branch and we'll update the application

00:32:07,919 --> 00:32:11,679
that is configured with this repository

00:32:09,679 --> 00:32:15,120
and this branch

00:32:11,679 --> 00:32:16,000
and now that i'm logging uh let me see

00:32:15,120 --> 00:32:19,360
if i can

00:32:16,000 --> 00:32:20,720
if i can fix the well the url for the

00:32:19,360 --> 00:32:23,840
application

00:32:20,720 --> 00:32:28,320
in that way we could see

00:32:23,840 --> 00:32:33,279
the different versions being deployed

00:32:28,320 --> 00:32:33,279
so this is not like that

00:32:33,360 --> 00:32:38,880
this will be a different

00:32:37,039 --> 00:32:40,640
well it won't work anyway so i'm not

00:32:38,880 --> 00:32:44,159
going to do that we will see it

00:32:40,640 --> 00:32:45,840
using the cli okay and then for the

00:32:44,159 --> 00:32:48,080
reverse application so for the other

00:32:45,840 --> 00:32:50,480
repository which is the one for the

00:32:48,080 --> 00:32:54,840
application it will be the same

00:32:50,480 --> 00:32:57,120
so basically a web hook that

00:32:54,840 --> 00:32:59,919
um

00:32:57,120 --> 00:33:02,080
we'll connect to the tecton event

00:32:59,919 --> 00:33:05,679
endpoint that we have published on our

00:33:02,080 --> 00:33:08,799
uh cluster and that will be

00:33:05,679 --> 00:33:10,320
um captured by tecton and we'll run the

00:33:08,799 --> 00:33:13,679
pipeline as we

00:33:10,320 --> 00:33:17,360
as we want so now

00:33:13,679 --> 00:33:20,240
let's see if i can basically

00:33:17,360 --> 00:33:22,720
force a pipeline run using the tecton

00:33:20,240 --> 00:33:26,080
cli

00:33:22,720 --> 00:33:29,760
so we have here uh

00:33:26,080 --> 00:33:32,960
the dkn cli

00:33:29,760 --> 00:33:36,399
so now uh we are using the reverse

00:33:32,960 --> 00:33:40,720
words tecton namespace

00:33:36,399 --> 00:33:44,000
and we want uh one sec

00:33:40,720 --> 00:33:44,000
i'm going to copy paste this

00:33:47,279 --> 00:33:56,240
so actually we have the web ui for the

00:33:52,480 --> 00:33:58,559
for tekton let me show that really quick

00:33:56,240 --> 00:33:59,519
so here we have the tecton dashboard

00:33:58,559 --> 00:34:01,840
where we can say

00:33:59,519 --> 00:34:03,600
where we can see the different uh

00:34:01,840 --> 00:34:06,159
pipelines that we have and i think that

00:34:03,600 --> 00:34:07,039
uh well we can run the pi band from here

00:34:06,159 --> 00:34:10,480
so let me

00:34:07,039 --> 00:34:12,720
create a pipeline run so basically here

00:34:10,480 --> 00:34:14,079
we have the reverse the name space where

00:34:12,720 --> 00:34:15,919
we are running the pipeline

00:34:14,079 --> 00:34:17,520
the name of the pipeline that we will

00:34:15,919 --> 00:34:20,800
run then we need to

00:34:17,520 --> 00:34:24,960
provide some resources so they give the

00:34:20,800 --> 00:34:26,720
the repository for getting the code um

00:34:24,960 --> 00:34:29,040
i need to change that really quick

00:34:26,720 --> 00:34:31,839
because it's pointing to

00:34:29,040 --> 00:34:31,839
it's pointing to

00:34:33,359 --> 00:34:38,639
to the gitlab instance that it's down

00:34:36,639 --> 00:34:40,639
okay let me do the right that really

00:34:38,639 --> 00:34:44,159
quick i'm on the terminal now

00:34:40,639 --> 00:34:48,079
um this is in the build

00:34:44,159 --> 00:34:50,800
pipeline so

00:34:48,079 --> 00:34:50,800
keep cdl

00:35:01,839 --> 00:35:07,440
wait one sec let's see if i can do it

00:35:05,760 --> 00:35:12,160
from the web drive it will be

00:35:07,440 --> 00:35:15,359
um okay

00:35:12,160 --> 00:35:17,920
it will be easier for you and for me

00:35:15,359 --> 00:35:18,720
okay so we have the cicd repository here

00:35:17,920 --> 00:35:20,240
uh let's

00:35:18,720 --> 00:35:22,560
update this yaml i don't know if we can

00:35:20,240 --> 00:35:27,760
update this yammer here okay we can't

00:35:22,560 --> 00:35:27,760
okay back to the terminal all right

00:35:28,839 --> 00:35:35,359
um oh

00:35:30,320 --> 00:35:35,359
sorry that was wrong

00:35:36,079 --> 00:35:40,000
so now we have the pipeline resources

00:35:38,079 --> 00:35:42,800
i'm going to edit

00:35:40,000 --> 00:35:45,119
uh these two resources here so basically

00:35:42,800 --> 00:35:47,520
the cic repository

00:35:45,119 --> 00:35:47,520
and the

00:35:48,960 --> 00:35:52,960
and the other repository for the

00:35:50,480 --> 00:35:52,960
application

00:35:57,440 --> 00:36:05,599
okay i want the ssl verify

00:36:02,400 --> 00:36:06,079
and then i'm going to the same for the

00:36:05,599 --> 00:36:12,400
base

00:36:06,079 --> 00:36:14,960
git repository here we don't need this

00:36:12,400 --> 00:36:14,960
and then

00:36:20,000 --> 00:36:26,800
we have i think that's pretty much

00:36:23,440 --> 00:36:30,160
it what we need and now i'm going to

00:36:26,800 --> 00:36:33,440
i'm going back to the to the web ui

00:36:30,160 --> 00:36:37,839
so we can go ahead and run the pipeline

00:36:33,440 --> 00:36:41,599
so you can see it um

00:36:37,839 --> 00:36:43,359
so reverse build pipeline

00:36:41,599 --> 00:36:45,920
reverse word we are using the

00:36:43,359 --> 00:36:49,040
application git representer here

00:36:45,920 --> 00:36:49,680
we need to use the this image which is

00:36:49,040 --> 00:36:53,119
the

00:36:49,680 --> 00:36:55,920
way io image we will use

00:36:53,119 --> 00:36:56,720
a different tag for example since we are

00:36:55,920 --> 00:36:58,400
running this

00:36:56,720 --> 00:37:00,720
manually we will need we will need to

00:36:58,400 --> 00:37:03,680
provide a tag if this was run

00:37:00,720 --> 00:37:04,160
using the web hook what will happen is

00:37:03,680 --> 00:37:06,560
that

00:37:04,160 --> 00:37:08,400
the the commit id from the git

00:37:06,560 --> 00:37:11,280
repository for the application

00:37:08,400 --> 00:37:12,880
will be used as image stack so that way

00:37:11,280 --> 00:37:14,720
you have the latest

00:37:12,880 --> 00:37:16,079
commit id as your image stack you can

00:37:14,720 --> 00:37:17,839
see which

00:37:16,079 --> 00:37:19,440
you can know which senses were

00:37:17,839 --> 00:37:21,119
introduced by that image by looking at

00:37:19,440 --> 00:37:24,160
the commit id

00:37:21,119 --> 00:37:25,520
okay and then we need to use this

00:37:24,160 --> 00:37:28,320
service account

00:37:25,520 --> 00:37:29,440
which has privileges to push the image

00:37:28,320 --> 00:37:33,359
to query

00:37:29,440 --> 00:37:33,359
and that should be it let's see

00:37:34,160 --> 00:37:37,280
so uh we need to wait a bit because we

00:37:36,800 --> 00:37:42,320
need

00:37:37,280 --> 00:37:43,760
um to wait the pots to start

00:37:42,320 --> 00:37:46,000
in the meantime i'm going to check if

00:37:43,760 --> 00:37:50,320
git clap it's up again

00:37:46,000 --> 00:37:52,640
but it seems it's it's down

00:37:50,320 --> 00:37:52,640
okay

00:37:54,640 --> 00:37:59,359
so basically what this is doing if i go

00:37:56,800 --> 00:38:01,520
to a terminal

00:37:59,359 --> 00:38:05,839
you will be able to see that we have

00:38:01,520 --> 00:38:05,839
some pots

00:38:08,800 --> 00:38:17,040
okay so this is the pipeline run

00:38:14,160 --> 00:38:19,839
and the the pipeline is running at the

00:38:17,040 --> 00:38:19,839
moment

00:38:25,680 --> 00:38:30,800
okay so now the the application code is

00:38:29,359 --> 00:38:33,520
being downloaded

00:38:30,800 --> 00:38:34,800
and we will basically lean the code

00:38:33,520 --> 00:38:37,200
after that

00:38:34,800 --> 00:38:38,480
we will go ahead and test and run the

00:38:37,200 --> 00:38:42,320
test

00:38:38,480 --> 00:38:45,200
and when that when that is done we will

00:38:42,320 --> 00:38:46,400
basically go ahead and create a new

00:38:45,200 --> 00:38:50,079
image and

00:38:46,400 --> 00:38:52,400
publish it to the quay io repository

00:38:50,079 --> 00:38:54,400
and then the last step will fail because

00:38:52,400 --> 00:38:57,040
it the last step

00:38:54,400 --> 00:38:58,839
will be connecting to the git repository

00:38:57,040 --> 00:39:02,800
and update the deployment

00:38:58,839 --> 00:39:04,400
file and since the gitlab instance that

00:39:02,800 --> 00:39:06,880
we are using for demo is down

00:39:04,400 --> 00:39:08,880
we won't be able to show that so i'm

00:39:06,880 --> 00:39:09,680
sorry maybe we can share a video with

00:39:08,880 --> 00:39:15,839
you after

00:39:09,680 --> 00:39:15,839
after that

00:39:21,359 --> 00:39:25,280
all right so the linkedin is complete

00:39:24,160 --> 00:39:28,960
now the next step

00:39:25,280 --> 00:39:32,160
will be testing the code so the body is

00:39:28,960 --> 00:39:32,160
still waiting to start

00:39:37,920 --> 00:39:40,960
okay now it's running

00:39:41,520 --> 00:39:48,400
same thing so it will basically

00:39:45,520 --> 00:39:51,520
run our tests that are defined in our

00:39:48,400 --> 00:39:51,520
application repository

00:39:52,000 --> 00:39:55,680
and in case uh all the all the tests are

00:39:54,720 --> 00:39:58,000
okay then

00:39:55,680 --> 00:39:59,599
it will continue and will generate the

00:39:58,000 --> 00:40:00,960
image

00:39:59,599 --> 00:40:02,400
this will take a bit because it's the

00:40:00,960 --> 00:40:03,520
first time that we run the pipeline in

00:40:02,400 --> 00:40:06,720
this cluster

00:40:03,520 --> 00:40:09,680
but the next runs will be

00:40:06,720 --> 00:40:10,880
faster since we will have most of the

00:40:09,680 --> 00:40:25,839
container images

00:40:10,880 --> 00:40:25,839
available locally

00:40:36,839 --> 00:40:39,839
okay

00:40:44,160 --> 00:40:48,240
so i'm going to show you what will

00:40:47,520 --> 00:40:51,440
happen

00:40:48,240 --> 00:40:54,640
in the git repository so

00:40:51,440 --> 00:40:56,560
in this repository here in the cicd

00:40:54,640 --> 00:40:59,680
repository

00:40:56,560 --> 00:41:02,800
the pipeline will go ahead and

00:40:59,680 --> 00:41:05,839
in the states runs

00:41:02,800 --> 00:41:07,280
will basically update this file and here

00:41:05,839 --> 00:41:10,319
this will be changed

00:41:07,280 --> 00:41:11,280
by the tag that the pipeline has defined

00:41:10,319 --> 00:41:14,640
in this case

00:41:11,280 --> 00:41:18,400
we define the oss20

00:41:14,640 --> 00:41:21,280
tags so we we will need to update this

00:41:18,400 --> 00:41:23,440
to that tag when the pipeline ends so

00:41:21,280 --> 00:41:26,640
let's wait for that to happen

00:41:23,440 --> 00:41:30,000
and when that happen uh happens we will

00:41:26,640 --> 00:41:32,560
i will manually update the the file so

00:41:30,000 --> 00:41:32,560
we will see

00:41:32,640 --> 00:41:36,240
the application being updated

00:41:36,720 --> 00:41:43,280
so now

00:41:39,920 --> 00:41:43,599
while this is running oh sorry i was in

00:41:43,280 --> 00:41:47,200
the

00:41:43,599 --> 00:41:47,200
terminal for this whole time and

00:41:47,520 --> 00:41:51,440
and this is what's happening on the argo

00:41:49,520 --> 00:41:52,960
city sorry in the tecton dashboard so

00:41:51,440 --> 00:41:55,839
basically the linting

00:41:52,960 --> 00:41:57,359
and the testing is complete and now we

00:41:55,839 --> 00:42:00,640
are building the image

00:41:57,359 --> 00:42:01,119
here and next step will be pushing the

00:42:00,640 --> 00:42:04,160
image

00:42:01,119 --> 00:42:07,760
and as i said what will happen is

00:42:04,160 --> 00:42:10,240
that when the pipeline finishes

00:42:07,760 --> 00:42:11,440
this file in the gitlab repository would

00:42:10,240 --> 00:42:14,720
be

00:42:11,440 --> 00:42:18,000
updated so this stack will

00:42:14,720 --> 00:42:21,200
be set to oss20 instead of this

00:42:18,000 --> 00:42:23,200
commit id here so

00:42:21,200 --> 00:42:24,880
i'm saying that let's wait for that to

00:42:23,200 --> 00:42:28,839
happen and then i will update the file

00:42:24,880 --> 00:42:31,839
and we should see the application being

00:42:28,839 --> 00:42:31,839
updated

00:42:42,839 --> 00:42:47,359
okay

00:42:44,800 --> 00:42:49,119
you can see here the tag and that we

00:42:47,359 --> 00:42:52,400
define

00:42:49,119 --> 00:42:55,359
us 2020 that's us 20 sorry and then

00:42:52,400 --> 00:42:56,960
these states will legally likely fail

00:42:55,359 --> 00:42:57,520
because we don't have connectivity with

00:42:56,960 --> 00:43:01,599
the

00:42:57,520 --> 00:43:01,599
git server so

00:43:01,920 --> 00:43:09,359
i'm going to basically update the file

00:43:05,200 --> 00:43:12,480
manually so here

00:43:09,359 --> 00:43:15,760
let's go ahead and use

00:43:12,480 --> 00:43:19,760
us 20 so you

00:43:15,760 --> 00:43:23,040
this is the deduct that we use it

00:43:19,760 --> 00:43:26,160
for the pipeline to run okay

00:43:23,040 --> 00:43:29,440
so now as soon as i change this or if

00:43:26,160 --> 00:43:32,640
that was changed by the pipeline argo cd

00:43:29,440 --> 00:43:35,760
will receive a web hook that will

00:43:32,640 --> 00:43:36,720
trigger an application deployment this

00:43:35,760 --> 00:43:39,280
is not going to happen

00:43:36,720 --> 00:43:41,200
because this repository is not

00:43:39,280 --> 00:43:44,480
configured to

00:43:41,200 --> 00:43:46,079
use this argo cd web hook so

00:43:44,480 --> 00:43:47,520
what i'm going to do is basically run

00:43:46,079 --> 00:43:50,800
the sync which is

00:43:47,520 --> 00:43:53,440
what will happen when the web hook

00:43:50,800 --> 00:43:55,839
is triggered so basically we want to

00:43:53,440 --> 00:43:55,839
synchronize

00:43:55,920 --> 00:44:01,839
and this should see that the repository

00:43:59,040 --> 00:44:03,280
is out of sync because the deployment

00:44:01,839 --> 00:44:07,119
file was updated

00:44:03,280 --> 00:44:11,200
so now we can see how the argo cd

00:44:07,119 --> 00:44:14,240
went ahead and updated the deployment

00:44:11,200 --> 00:44:18,800
object and that generated a new pod

00:44:14,240 --> 00:44:18,800
which if we go to the terminal now

00:44:20,839 --> 00:44:23,839
here

00:44:24,240 --> 00:44:30,640
we can see that new pot deployed here

00:44:27,280 --> 00:44:30,640
and if we look at the image

00:44:31,839 --> 00:44:36,720
we can see that it's running the os20

00:44:34,839 --> 00:44:42,319
image

00:44:36,720 --> 00:44:42,319
and then if we look at production

00:44:49,760 --> 00:44:54,480
we can see here that we are using a

00:44:52,319 --> 00:44:58,560
different image

00:44:54,480 --> 00:44:58,560
um sorry i missed the bot

00:44:59,680 --> 00:45:06,560
okay so next step

00:45:02,800 --> 00:45:10,079
will be running the

00:45:06,560 --> 00:45:13,359
the promote the promotion pipeline

00:45:10,079 --> 00:45:13,359
so i'm going to do that

00:45:14,240 --> 00:45:18,560
i'm going to show you the the command

00:45:17,280 --> 00:45:22,400
that we will use

00:45:18,560 --> 00:45:26,079
for running this using the the dkn

00:45:22,400 --> 00:45:28,160
cli so we will need to introduce the

00:45:26,079 --> 00:45:30,079
name space where our pipeline is defined

00:45:28,160 --> 00:45:33,040
then we will start the pipeline

00:45:30,079 --> 00:45:33,680
this is the pylon that we want to start

00:45:33,040 --> 00:45:36,079
the

00:45:33,680 --> 00:45:36,720
resource that we're using as application

00:45:36,079 --> 00:45:39,359
git

00:45:36,720 --> 00:45:40,640
is the cicd repository so this is a

00:45:39,359 --> 00:45:42,720
repository

00:45:40,640 --> 00:45:44,960
where the pull request will be created

00:45:42,720 --> 00:45:47,040
to update our deployment file

00:45:44,960 --> 00:45:49,839
this is the file that we are updating in

00:45:47,040 --> 00:45:52,480
this case is the deployment jamal

00:45:49,839 --> 00:45:53,280
this is the states branch so where are

00:45:52,480 --> 00:45:56,000
we

00:45:53,280 --> 00:45:57,280
going to get the release that is

00:45:56,000 --> 00:45:59,599
deployed on the estates

00:45:57,280 --> 00:46:01,839
environment in our case is a states

00:45:59,599 --> 00:46:05,119
branch inside the reverse word

00:46:01,839 --> 00:46:05,440
cicd repository and then here we have

00:46:05,119 --> 00:46:07,760
the

00:46:05,440 --> 00:46:09,440
another parameter which is the states

00:46:07,760 --> 00:46:13,040
application url

00:46:09,440 --> 00:46:15,359
which can be used in order to

00:46:13,040 --> 00:46:16,319
run tests against our applications in

00:46:15,359 --> 00:46:19,040
this pipeline

00:46:16,319 --> 00:46:20,880
it was a really damp test that was

00:46:19,040 --> 00:46:24,000
accessing the

00:46:20,880 --> 00:46:25,280
the application using a core command and

00:46:24,000 --> 00:46:27,920
then

00:46:25,280 --> 00:46:29,440
the pipeline will basically go ahead and

00:46:27,920 --> 00:46:31,599
create the pull request

00:46:29,440 --> 00:46:33,680
so instead of creating the pull request

00:46:31,599 --> 00:46:37,440
which won't work

00:46:33,680 --> 00:46:40,880
because git is done i will go ahead

00:46:37,440 --> 00:46:41,359
go back to firefox then i want to get

00:46:40,880 --> 00:46:45,280
this

00:46:41,359 --> 00:46:47,119
stack here i want to go to production

00:46:45,280 --> 00:46:49,920
and again this is not how you do githubs

00:46:47,119 --> 00:46:53,040
at all so sorry about that

00:46:49,920 --> 00:46:55,280
um you will that will be a pull request

00:46:53,040 --> 00:46:56,880
then some reviewers should take care of

00:46:55,280 --> 00:46:58,240
reviewing that pull request make sure

00:46:56,880 --> 00:47:00,480
that everything is okay

00:46:58,240 --> 00:47:02,240
different companies will have different

00:47:00,480 --> 00:47:04,160
uh workflows or different teams will

00:47:02,240 --> 00:47:07,680
have different workflows as well

00:47:04,160 --> 00:47:10,319
so but in the end

00:47:07,680 --> 00:47:12,240
when the change reaches the production

00:47:10,319 --> 00:47:17,680
branch

00:47:12,240 --> 00:47:20,319
and that will trigger the argo cd

00:47:17,680 --> 00:47:21,040
directivity web hook and now the

00:47:20,319 --> 00:47:24,559
production

00:47:21,040 --> 00:47:27,119
as you can see it fired the it fired the

00:47:24,559 --> 00:47:28,319
update automatically because basically

00:47:27,119 --> 00:47:30,240
uh every three minutes

00:47:28,319 --> 00:47:31,760
argo cd will basically go to the git

00:47:30,240 --> 00:47:33,839
repository and see if

00:47:31,760 --> 00:47:35,119
anything change in this case the

00:47:33,839 --> 00:47:38,160
deployment changed

00:47:35,119 --> 00:47:41,119
so i i didn't need to hit

00:47:38,160 --> 00:47:41,680
sync here it's automatic so you have

00:47:41,119 --> 00:47:45,040
that

00:47:41,680 --> 00:47:48,079
two ways of working you can just wait

00:47:45,040 --> 00:47:51,599
for argo cd to go and get the changes

00:47:48,079 --> 00:47:54,960
or you can uh using a web hook you can

00:47:51,599 --> 00:47:58,480
as soon as the file is updated

00:47:54,960 --> 00:48:01,680
get the application deployed and now

00:47:58,480 --> 00:48:03,440
if we look at the well that won't work

00:48:01,680 --> 00:48:04,880
so we're not wasting time looking at the

00:48:03,440 --> 00:48:09,040
output

00:48:04,880 --> 00:48:13,760
um here we will see a different pod

00:48:09,040 --> 00:48:18,000
now sorry

00:48:13,760 --> 00:48:18,000
so this spot will be using

00:48:18,160 --> 00:48:24,319
the products the image that was tested

00:48:21,200 --> 00:48:24,720
on a staging so that's the way that you

00:48:24,319 --> 00:48:28,559
can

00:48:24,720 --> 00:48:31,760
basically go from the code to a stage

00:48:28,559 --> 00:48:35,280
and last step to production

00:48:31,760 --> 00:48:38,960
and now i want to

00:48:35,280 --> 00:48:40,319
so that will be the demo that shows how

00:48:38,960 --> 00:48:43,520
you get to

00:48:40,319 --> 00:48:47,119
production your code and then

00:48:43,520 --> 00:48:50,240
and now i want to introduce you to

00:48:47,119 --> 00:48:52,640
seal it secrets as ryan said uh

00:48:50,240 --> 00:48:53,760
uploading secrets to git is not a good

00:48:52,640 --> 00:48:57,440
idea

00:48:53,760 --> 00:48:58,480
so basically i'm going to show this

00:48:57,440 --> 00:49:02,720
really quick

00:48:58,480 --> 00:49:06,960
so cubesil you need to deploy a

00:49:02,720 --> 00:49:10,319
a controller which basically uses pkpki

00:49:06,960 --> 00:49:12,800
for encrypting your secrets

00:49:10,319 --> 00:49:12,800
and then

00:49:13,359 --> 00:49:18,400
i'm going to create a damp secret here

00:49:19,280 --> 00:49:23,280
so you can see this is a regular

00:49:21,440 --> 00:49:25,200
kubernetes secret

00:49:23,280 --> 00:49:27,599
we're almost out of time so i'm going

00:49:25,200 --> 00:49:30,800
really fast

00:49:27,599 --> 00:49:33,920
this secret as you can see here

00:49:30,800 --> 00:49:35,040
you can decode it using base64 that's

00:49:33,920 --> 00:49:37,839
the as ram said

00:49:35,040 --> 00:49:38,720
it is not secure at all so you you can

00:49:37,839 --> 00:49:41,920
you shouldn't

00:49:38,720 --> 00:49:45,920
upload this file to git but instead

00:49:41,920 --> 00:49:49,040
you can use sealed secrets so basically

00:49:45,920 --> 00:49:50,880
here the cubesale command will read your

00:49:49,040 --> 00:49:54,000
kubernetes equivalent cells

00:49:50,880 --> 00:49:56,960
and we'll connect to the uh we'll use

00:49:54,000 --> 00:49:58,480
the keepsail controller to to encrypt

00:49:56,960 --> 00:50:00,559
your secret so we are

00:49:58,480 --> 00:50:02,559
saying okay i want to seal this secret

00:50:00,559 --> 00:50:04,880
that is the secret that we just created

00:50:02,559 --> 00:50:06,960
before and i want you to output the

00:50:04,880 --> 00:50:10,160
select secret in this file

00:50:06,960 --> 00:50:12,800
okay so now this is a select secret

00:50:10,160 --> 00:50:13,599
as you can see we have the same data but

00:50:12,800 --> 00:50:16,640
this is a new

00:50:13,599 --> 00:50:18,160
it is a crd which has the encrypted data

00:50:16,640 --> 00:50:20,640
instead of data and here we have the

00:50:18,160 --> 00:50:21,920
password for example if we try and if we

00:50:20,640 --> 00:50:25,040
try to decode

00:50:21,920 --> 00:50:27,280
this as we did before this will fail

00:50:25,040 --> 00:50:29,119
this is a binary binary output because

00:50:27,280 --> 00:50:32,160
this file is actually encrypted

00:50:29,119 --> 00:50:33,040
so now you could go ahead upload this

00:50:32,160 --> 00:50:36,640
file to git

00:50:33,040 --> 00:50:38,880
and it's safe then argo cd or

00:50:36,640 --> 00:50:40,480
the application that that you use for

00:50:38,880 --> 00:50:43,200
deploying

00:50:40,480 --> 00:50:44,960
will basically create the sealed secret

00:50:43,200 --> 00:50:47,440
and once the sealed secret is created in

00:50:44,960 --> 00:50:52,839
the cluster for example if i go ahead

00:50:47,440 --> 00:50:56,960
and i create this secret here

00:50:52,839 --> 00:50:56,960
um there's still a secret

00:50:57,520 --> 00:51:05,119
okay now

00:51:00,960 --> 00:51:07,520
i should see um

00:51:05,119 --> 00:51:10,240
after a while i should see the well

00:51:07,520 --> 00:51:14,079
after a while now it should be

00:51:10,240 --> 00:51:14,079
in this repository in this name space

00:51:16,720 --> 00:51:21,440
i should see the test secret which now

00:51:19,920 --> 00:51:24,240
it will be

00:51:21,440 --> 00:51:25,839
usable by kubernetes so you can see here

00:51:24,240 --> 00:51:28,880
that we have the password that we had

00:51:25,839 --> 00:51:32,160
before in this case

00:51:28,880 --> 00:51:32,559
you can go ahead and oh sorry i was

00:51:32,160 --> 00:51:35,760
doing

00:51:32,559 --> 00:51:38,960
all of this in the terminal i'm so sorry

00:51:35,760 --> 00:51:41,359
you can go ahead and decrypt the the

00:51:38,960 --> 00:51:41,359
secret

00:51:43,040 --> 00:51:47,760
but the sealed secret as you can see

00:51:46,240 --> 00:51:49,760
here

00:51:47,760 --> 00:51:51,920
you cannot decode that so if you try to

00:51:49,760 --> 00:51:52,960
do that you will get a binary output as

00:51:51,920 --> 00:51:54,800
you can see here

00:51:52,960 --> 00:51:56,319
so that's the file that you should

00:51:54,800 --> 00:51:59,119
upload to to git

00:51:56,319 --> 00:52:00,240
and when you create that file into

00:51:59,119 --> 00:52:03,599
insecurities

00:52:00,240 --> 00:52:04,240
using argo cd um you will get the secret

00:52:03,599 --> 00:52:05,520
decode

00:52:04,240 --> 00:52:09,200
[Applause]

00:52:05,520 --> 00:52:10,319
so you will get an encrypted secret and

00:52:09,200 --> 00:52:13,680
you could use that

00:52:10,319 --> 00:52:16,160
in your applications and that's

00:52:13,680 --> 00:52:16,160
that's it

00:52:17,200 --> 00:52:20,800
we will answer the questions after the

00:52:20,319 --> 00:52:23,119
talk

00:52:20,800 --> 00:52:24,160
and we are available on the slack

00:52:23,119 --> 00:52:27,119
channel

00:52:24,160 --> 00:52:30,079
um the demo the working demo it's it's

00:52:27,119 --> 00:52:32,420
available in the github repository

00:52:30,079 --> 00:52:33,599
that you will have on the escape

00:52:32,420 --> 00:52:36,319
[Music]

00:52:33,599 --> 00:52:37,760
website you can go there there are the

00:52:36,319 --> 00:52:39,440
you have the slides there

00:52:37,760 --> 00:52:40,880
and at the end of the slides you have

00:52:39,440 --> 00:52:44,319
the

00:52:40,880 --> 00:52:46,240
you have the link to the demo

00:52:44,319 --> 00:52:47,599
so you can basically create an

00:52:46,240 --> 00:52:50,240
environment using

00:52:47,599 --> 00:52:52,240
any kubernetes cluster you so any

00:52:50,240 --> 00:52:56,559
kubernetes distribution you use

00:52:52,240 --> 00:52:56,559
and run the demo by yourself

00:52:57,520 --> 00:53:01,839
and thank you very much for attending

00:52:59,520 --> 00:53:01,839
the session

00:53:20,880 --> 00:53:24,960
i'm not sure if you all can still hear

00:53:22,319 --> 00:53:27,359
us but um thank you all for attending

00:53:24,960 --> 00:53:28,000
um we really appreciate your time today

00:53:27,359 --> 00:53:30,240
uh mario

00:53:28,000 --> 00:53:31,040
thank you as well for creating a demo on

00:53:30,240 --> 00:53:34,559
the fly

00:53:31,040 --> 00:53:36,000
so um really cool stuff i hope we

00:53:34,559 --> 00:53:38,400
answered a lot of your questions

00:53:36,000 --> 00:53:39,760
uh like mario said we'll be in the slack

00:53:38,400 --> 00:53:43,200
after the call

00:53:39,760 --> 00:53:45,440
um and elsewhere if you can reach us

00:53:43,200 --> 00:53:46,400
if you need to reach us uh we're also on

00:53:45,440 --> 00:53:49,280
twitter so

00:53:46,400 --> 00:53:50,240
feel free to connect and ask us any

00:53:49,280 --> 00:53:57,839
questions

00:53:50,240 --> 00:53:57,839
you guys might see fit

00:54:25,520 --> 00:54:27,599

YouTube URL: https://www.youtube.com/watch?v=62fMLBt1Vsw


