Title: Low-Latency, Deterministic Networking with Standard Linux... Magnus Karlsson & Björn Töpel, Intel
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Low-Latency, Deterministic Networking with Standard Linux using XDP Sockets - Magnus Karlsson & Björn Töpel, Intel Corporation*

Application areas such as time sensitive networking and packet processing usually require some combination of high throughput, low latency and determinism in their packet processing characteristics. Satisfying these requirements with standard sockets have been found to be challenging, so application writers have resorted to use bare-metal solutions such as DPDK and vendor specific SDKs. While these solutions often manage to meet the tough performance goals, they break a number of security properties of Linux, poses integration challenges and are a lot harder to use than standard sockets.

In this session, we present XDP sockets (AF_XDP), that was introduced in Linux 4.18. XDP sockets have been designed from ground up to be able to deterministically deliver sub microsecond packet latencies and process many millions of packets a second. We will present how to use XDP sockets from user space, an overview of the kernel and driver implementation, as well as a performance evaluation.
Captions: 
	00:00:00,060 --> 00:00:09,929
hello dear me okay good I'm a bit early

00:00:06,480 --> 00:00:12,330
but let's get going so can I surprised

00:00:09,929 --> 00:00:14,280
to see so many people to want to see

00:00:12,330 --> 00:00:15,480
this sort of niche topic and I see

00:00:14,280 --> 00:00:16,890
there's some real-time people here as

00:00:15,480 --> 00:00:22,230
well so they'll probably bash me for the

00:00:16,890 --> 00:00:24,449
title so we'll see I figured I started

00:00:22,230 --> 00:00:26,550
right away with some like your tea sir

00:00:24,449 --> 00:00:28,170
you know everybody loves benchmarking

00:00:26,550 --> 00:00:29,849
and you know depending on the kind of

00:00:28,170 --> 00:00:33,899
person you're you might be scared off so

00:00:29,849 --> 00:00:35,790
if so it's time to leave so here's the

00:00:33,899 --> 00:00:39,829
test where I'm blasting a host with

00:00:35,790 --> 00:00:39,829
fifty million packets per second and

00:00:40,700 --> 00:00:45,120
we'll have two different mechanism

00:00:43,170 --> 00:00:46,920
before receiving the packets so in the

00:00:45,120 --> 00:00:49,500
first three different tests so in the

00:00:46,920 --> 00:00:52,170
first test will receive the packet I

00:00:49,500 --> 00:00:54,239
would wrap it the middle one we actually

00:00:52,170 --> 00:00:56,100
generate packet from the host and try to

00:00:54,239 --> 00:00:58,289
send as many as possible outlets and the

00:00:56,100 --> 00:01:00,899
third we do simple max once we receive

00:00:58,289 --> 00:01:03,870
the packet we swap it swap the MAC

00:01:00,899 --> 00:01:07,920
address and send it back out and as you

00:01:03,870 --> 00:01:09,570
can see the life blue where we're used

00:01:07,920 --> 00:01:12,030
to song called eighth packet which has

00:01:09,570 --> 00:01:12,720
been around in the kernel since forever

00:01:12,030 --> 00:01:15,210
I guess

00:01:12,720 --> 00:01:16,530
yung-chun can probably tell us when it

00:01:15,210 --> 00:01:18,900
was introduced but it's been around

00:01:16,530 --> 00:01:20,640
forever so and it's typically what's

00:01:18,900 --> 00:01:22,830
used for to speed up for example so it's

00:01:20,640 --> 00:01:26,670
the mechanism before receiving roll

00:01:22,830 --> 00:01:29,009
frames in the Linux kernel as so 4:18 a

00:01:26,670 --> 00:01:31,049
new mechanism came up which is called

00:01:29,009 --> 00:01:34,409
xtp socket and that's what I'll be

00:01:31,049 --> 00:01:36,930
addressing here and as you can see you

00:01:34,409 --> 00:01:40,950
know it's a nice benchmark at least if

00:01:36,930 --> 00:01:43,979
you're coming from XP LAN so sort of a

00:01:40,950 --> 00:01:49,470
packet roughly maxes out about 1 million

00:01:43,979 --> 00:01:54,720
and whereas XP sockets has much better

00:01:49,470 --> 00:01:56,520
performance all right so before we

00:01:54,720 --> 00:01:58,710
actually can start we need some word

00:01:56,520 --> 00:02:00,600
from our sponsors the legal department

00:01:58,710 --> 00:02:02,040
and you're not supposed to read all of

00:02:00,600 --> 00:02:04,259
it but I really like the second bullet

00:02:02,040 --> 00:02:06,420
here so no computer system can be

00:02:04,259 --> 00:02:08,399
absolutely secure and you know being

00:02:06,420 --> 00:02:11,720
from Intel and time back to what Greg

00:02:08,399 --> 00:02:11,720
said this morning it's you know

00:02:11,780 --> 00:02:16,560
right so a little bit about me so my

00:02:14,100 --> 00:02:20,760
name is Bjorn and I'm working for this

00:02:16,560 --> 00:02:22,860
big shift enter and I'm mostly working

00:02:20,760 --> 00:02:24,300
with Linux networking things on the

00:02:22,860 --> 00:02:28,140
inside

00:02:24,300 --> 00:02:29,760
I maintain the xtp sockets and together

00:02:28,140 --> 00:02:33,570
with my good friend and colleague Magnus

00:02:29,760 --> 00:02:38,180
- you can please wave and on top of that

00:02:33,570 --> 00:02:38,180
I also maintain the risk 5 BPF jet

00:02:38,360 --> 00:02:46,590
all right so xtp sockets what is it and

00:02:42,660 --> 00:02:49,860
why should he care so before actually

00:02:46,590 --> 00:02:52,470
get into what XP socket is we need to do

00:02:49,860 --> 00:02:53,970
some TLA that's three letter acronym so

00:02:52,470 --> 00:02:57,210
with a show of hands how many people I

00:02:53,970 --> 00:02:59,880
don't know would be PFS ok that's that's

00:02:57,210 --> 00:03:02,820
good so beep F I'll just do the

00:02:59,880 --> 00:03:04,770
whirlwind tour them BBFS or stands for

00:03:02,820 --> 00:03:09,060
birthday packet filter and it's a

00:03:04,770 --> 00:03:10,950
mechanism where it lets a user insert

00:03:09,060 --> 00:03:13,230
snippets of code into various hook in

00:03:10,950 --> 00:03:15,630
the kernel so you can use it for tracing

00:03:13,230 --> 00:03:17,700
and you can use it for extending the

00:03:15,630 --> 00:03:19,560
kernel in a safe way so that the

00:03:17,700 --> 00:03:23,160
biggest-selling which would be BFS that

00:03:19,560 --> 00:03:25,709
well while you can insert a snippet of

00:03:23,160 --> 00:03:29,310
code it cannot crash the kernel so it's

00:03:25,709 --> 00:03:31,490
sort of the killer feature so way back

00:03:29,310 --> 00:03:35,640
at native conference for a couple years

00:03:31,490 --> 00:03:38,250
back Tom Herbert and Alexis table or

00:03:35,640 --> 00:03:41,430
table had an idea like what if we add a

00:03:38,250 --> 00:03:43,560
BBF ook at the earliest place possible

00:03:41,430 --> 00:03:45,450
in the receive path who wears that well

00:03:43,560 --> 00:03:48,690
that's right after the DMA has been

00:03:45,450 --> 00:03:51,680
completed they named this hook x2 P

00:03:48,690 --> 00:03:54,320
which stands for the expressed data path

00:03:51,680 --> 00:03:57,120
sterday is that okay we have this

00:03:54,320 --> 00:03:59,489
receive hook where we insert a BPF

00:03:57,120 --> 00:04:00,000
program so what can you do this BPF

00:03:59,489 --> 00:04:02,250
program

00:04:00,000 --> 00:04:03,860
well first you can after you receive a

00:04:02,250 --> 00:04:07,410
packet you can modify the packet okay

00:04:03,860 --> 00:04:08,910
you can drop the packet you can take the

00:04:07,410 --> 00:04:11,489
pack in and send it back out on the same

00:04:08,910 --> 00:04:14,910
interface again and you can do redirect

00:04:11,489 --> 00:04:16,080
that means you receive it back yet you

00:04:14,910 --> 00:04:18,380
take the back to understand it back out

00:04:16,080 --> 00:04:22,320
on a different network interface card

00:04:18,380 --> 00:04:24,120
you can't take the pack you down pass it

00:04:22,320 --> 00:04:24,930
to Colonel tend occur like hey please

00:04:24,120 --> 00:04:27,270
process this

00:04:24,930 --> 00:04:28,650
pack it on a different core and finally

00:04:27,270 --> 00:04:31,590
you can actually take the packet and

00:04:28,650 --> 00:04:32,820
pass it out to a socket and that's next

00:04:31,590 --> 00:04:36,389
to these sockets so it's a way of

00:04:32,820 --> 00:04:39,870
getting packed gets real fast from decks

00:04:36,389 --> 00:04:42,419
people right so this is all of the

00:04:39,870 --> 00:04:44,310
picture of how it all fits in so at the

00:04:42,419 --> 00:04:46,800
bottom you have the network interface

00:04:44,310 --> 00:04:48,660
card you see next to me hope they're

00:04:46,800 --> 00:04:55,560
everything in dork blue has this related

00:04:48,660 --> 00:04:57,509
to BBF you see the BBF Maps BPF Maps

00:04:55,560 --> 00:05:00,030
it's a Mac it's sort of a structure that

00:04:57,509 --> 00:05:02,220
that can be shared between you land and

00:05:00,030 --> 00:05:06,570
the kernel to pass information back and

00:05:02,220 --> 00:05:08,940
forth between BPF and the user so we

00:05:06,570 --> 00:05:11,610
take the regular flow there the NIC

00:05:08,940 --> 00:05:13,620
receive the packet we enter the next P

00:05:11,610 --> 00:05:16,860
program you can do various decisions

00:05:13,620 --> 00:05:19,349
there's again you can drop it you can

00:05:16,860 --> 00:05:24,810
redirect to left XTP socket which you

00:05:19,349 --> 00:05:26,610
can see right on top of XP program you

00:05:24,810 --> 00:05:29,310
can pass it through a regular networking

00:05:26,610 --> 00:05:32,820
stack which is done by something called

00:05:29,310 --> 00:05:35,960
X to be pass to just receive a packet

00:05:32,820 --> 00:05:38,970
and pass it directly to stack and then

00:05:35,960 --> 00:05:40,889
when actually enters the regular stack

00:05:38,970 --> 00:05:43,470
it will create a structure called the S

00:05:40,889 --> 00:05:46,199
key before the socket buff or just skb

00:05:43,470 --> 00:05:49,590
for short and that's the kernel

00:05:46,199 --> 00:05:50,880
representation of a packet so when you

00:05:49,590 --> 00:05:54,210
have a networking back in the kernel

00:05:50,880 --> 00:05:55,800
it's an SUV unless is in the XP world

00:05:54,210 --> 00:06:00,300
because then we don't have an XP because

00:05:55,800 --> 00:06:02,159
it's so early make sense and as you can

00:06:00,300 --> 00:06:04,199
see and this is part of what went form

00:06:02,159 --> 00:06:06,509
is come from like there's a whole lot

00:06:04,199 --> 00:06:14,520
more code when you go up to the wave

00:06:06,509 --> 00:06:17,370
packet and compared to a FX to be clear

00:06:14,520 --> 00:06:20,340
good all right so how do you actually

00:06:17,370 --> 00:06:23,180
use this thunk so on the left you have a

00:06:20,340 --> 00:06:27,120
regular Island socket and this time is

00:06:23,180 --> 00:06:29,509
for example UDP sockets so you start off

00:06:27,120 --> 00:06:33,410
by creating a socket you bind it to some

00:06:29,509 --> 00:06:36,720
address and then you start receiving

00:06:33,410 --> 00:06:39,389
packets understanding packets typically

00:06:36,720 --> 00:06:42,120
each receive and each term is a system

00:06:39,389 --> 00:06:46,190
call and on top of that you need to copy

00:06:42,120 --> 00:06:50,039
data from the kernel side to the Uslan

00:06:46,190 --> 00:06:52,169
and as again as greg pointed out system

00:06:50,039 --> 00:06:53,880
calls has become much more expensive

00:06:52,169 --> 00:06:59,449
nowadays with all these mitigations

00:06:53,880 --> 00:07:02,400
around on the right hand side we have

00:06:59,449 --> 00:07:03,810
dates the B socket program which is

00:07:02,400 --> 00:07:05,430
again as you can see in much more code

00:07:03,810 --> 00:07:09,240
so it's much more complicated to use and

00:07:05,430 --> 00:07:11,819
this is true again for if package so

00:07:09,240 --> 00:07:14,220
typically like easy to use nossek not as

00:07:11,819 --> 00:07:22,830
fast which is a shame but we can get

00:07:14,220 --> 00:07:25,590
back to it later you start off by you

00:07:22,830 --> 00:07:28,979
start off by creating a socket of type X

00:07:25,590 --> 00:07:30,750
DP and then you allocate something that

00:07:28,979 --> 00:07:33,210
we call the packet buffers that's just

00:07:30,750 --> 00:07:37,199
an area where you want to place the

00:07:33,210 --> 00:07:41,219
packets and this packet array is divided

00:07:37,199 --> 00:07:43,979
into fixed sized chunks so for example

00:07:41,219 --> 00:07:47,699
if you when you register the factory

00:07:43,979 --> 00:07:49,560
later with state that okay each this

00:07:47,699 --> 00:07:52,110
bacteria is divided into chunks there

00:07:49,560 --> 00:07:57,090
are say 4 K so you can't receive packets

00:07:52,110 --> 00:08:00,479
large and 4k that sounds and then you

00:07:57,090 --> 00:08:02,280
register to the kernel and so and this

00:08:00,479 --> 00:08:04,289
is the first optimization like you don't

00:08:02,280 --> 00:08:06,479
have to do cockpit anymore because you

00:08:04,289 --> 00:08:11,099
let the kernel know that this is my area

00:08:06,479 --> 00:08:15,000
where actually will place the data third

00:08:11,099 --> 00:08:18,449
you create a couple of rings right yeah

00:08:15,000 --> 00:08:22,080
and I'll get back to how these rings

00:08:18,449 --> 00:08:24,270
look and how you use them but that is

00:08:22,080 --> 00:08:28,070
that instead of using explicit system

00:08:24,270 --> 00:08:28,070
calls use rings to pass

00:08:28,460 --> 00:08:33,029
events back and forth or pass ownership

00:08:30,930 --> 00:08:36,959
of buffers so in this rings and that's

00:08:33,029 --> 00:08:39,089
also a difference between regular

00:08:36,959 --> 00:08:41,039
sockets and they affect it is that you

00:08:39,089 --> 00:08:42,810
actually passed descriptors to the data

00:08:41,039 --> 00:08:45,300
you don't pass the actual data now I'll

00:08:42,810 --> 00:08:49,890
get into the details were how these

00:08:45,300 --> 00:08:52,290
descriptors look like later right and

00:08:49,890 --> 00:08:54,269
then okay so these rings they're shared

00:08:52,290 --> 00:08:59,130
between the kernel and the user so it's

00:08:54,269 --> 00:09:02,149
a shared structure finally you do a bind

00:08:59,130 --> 00:09:04,519
call and the bank codes can be special

00:09:02,149 --> 00:09:08,160
instead of having a dress you have

00:09:04,519 --> 00:09:10,860
device and then the queue so most I

00:09:08,160 --> 00:09:12,720
would say all come to contemporary mix

00:09:10,860 --> 00:09:15,329
now they have multiple receive and send

00:09:12,720 --> 00:09:17,130
queues so typically Linux the default

00:09:15,329 --> 00:09:22,320
setup is that you are one received queue

00:09:17,130 --> 00:09:24,120
and send queue per core so for a FXP you

00:09:22,320 --> 00:09:25,230
can you have to select a certain

00:09:24,120 --> 00:09:27,899
hardware queue

00:09:25,230 --> 00:09:29,430
so for example if your neck casts or

00:09:27,899 --> 00:09:32,190
it's configured to have four received

00:09:29,430 --> 00:09:36,680
queues you will need to create four FXP

00:09:32,190 --> 00:09:38,970
sockets and then finally you start

00:09:36,680 --> 00:09:41,459
receiving events from the ranks and

00:09:38,970 --> 00:09:43,529
sending a master rings and you all say

00:09:41,459 --> 00:09:46,170
so the question is do we need system

00:09:43,529 --> 00:09:49,440
calls at all well truth is we need some

00:09:46,170 --> 00:09:51,120
but I'll get back to that later and

00:09:49,440 --> 00:09:53,490
again this is you know this is a lot of

00:09:51,120 --> 00:09:56,730
boilerplate code so what we've done is

00:09:53,490 --> 00:09:58,829
we've sort of tried to make it easier to

00:09:56,730 --> 00:10:01,380
use by hiding it into library coastally

00:09:58,829 --> 00:10:04,529
BPF only BBF is part of the kernel as

00:10:01,380 --> 00:10:06,029
well so you can like my opinion don't

00:10:04,529 --> 00:10:08,149
like this raw code use the library

00:10:06,029 --> 00:10:08,149
instead

00:10:11,190 --> 00:10:19,110
all right so this is what the XP

00:10:17,010 --> 00:10:20,040
descriptor looks like this really simple

00:10:19,110 --> 00:10:22,470
is it address

00:10:20,040 --> 00:10:24,960
it's a length and a set of options so

00:10:22,470 --> 00:10:28,620
let's start so options is not used we

00:10:24,960 --> 00:10:30,360
have some ideas for that to use before -

00:10:28,620 --> 00:10:32,460
chaining packets because as I said

00:10:30,360 --> 00:10:35,010
earlier the chunk size is fixed so you

00:10:32,460 --> 00:10:39,720
can only receive packet of this like

00:10:35,010 --> 00:10:42,480
smaller than the chunk size the address

00:10:39,720 --> 00:10:44,250
is not a user point pointer or use one

00:10:42,480 --> 00:10:47,220
pointer it's actually the offset into

00:10:44,250 --> 00:10:49,920
this packet buffer so for example the

00:10:47,220 --> 00:10:52,410
first chunk in your buffer array that's

00:10:49,920 --> 00:10:56,130
zero so zero is not a null point pointer

00:10:52,410 --> 00:10:57,690
it's a valid offset length again the

00:10:56,130 --> 00:11:00,360
lengths are actual packet so if you have

00:10:57,690 --> 00:11:03,810
data within these chunks that's less

00:11:00,360 --> 00:11:07,130
than a chunk so say we have 64 bytes the

00:11:03,810 --> 00:11:07,130
length will be 64 Oh

00:11:08,430 --> 00:11:12,530
as you can see in the top that's where

00:11:10,320 --> 00:11:17,850
you find a new API as well

00:11:12,530 --> 00:11:18,600
yeah Linux I have fixed appeal okay so

00:11:17,850 --> 00:11:22,790
here are the Rings

00:11:18,600 --> 00:11:27,510
so for each XP socket there's at least

00:11:22,790 --> 00:11:30,390
or there's at least two rings but

00:11:27,510 --> 00:11:32,460
typically there's four of them so first

00:11:30,390 --> 00:11:34,320
there are there see ring that works ring

00:11:32,460 --> 00:11:37,410
and there's the transmission range of

00:11:34,320 --> 00:11:39,090
the TX ring and corresponding to each of

00:11:37,410 --> 00:11:40,140
those rings there are a couple more I

00:11:39,090 --> 00:11:41,430
will get back to those later

00:11:40,140 --> 00:11:44,040
so there's a field ring on the

00:11:41,430 --> 00:11:47,340
completion rate so let's start so to

00:11:44,040 --> 00:11:49,680
receive a packet in the ORAC spring in

00:11:47,340 --> 00:11:51,750
this case the userland

00:11:49,680 --> 00:11:55,770
process is the consumer and the kernel

00:11:51,750 --> 00:11:58,740
is the producer so the user will read

00:11:55,770 --> 00:12:05,100
off or pick XP descriptors from the ring

00:11:58,740 --> 00:12:07,050
and then bump the consumer pointer so

00:12:05,100 --> 00:12:09,000
what are we using this pilgrim for well

00:12:07,050 --> 00:12:11,640
the idea is that as remember we

00:12:09,000 --> 00:12:14,040
registered the memory to the kernel and

00:12:11,640 --> 00:12:17,190
this mechanism the field ring is used to

00:12:14,040 --> 00:12:20,700
pass ownership from the user land to the

00:12:17,190 --> 00:12:23,459
kernel so we - and as you can see that's

00:12:20,700 --> 00:12:25,649
not a complete descriptor it's

00:12:23,459 --> 00:12:27,600
the address field because we don't need

00:12:25,649 --> 00:12:29,519
to pass the length when we pass it to

00:12:27,600 --> 00:12:34,069
Colonel we just need to say like use

00:12:29,519 --> 00:12:36,389
this chunk make sounds ok good

00:12:34,069 --> 00:12:38,730
same thing with the completion ring so

00:12:36,389 --> 00:12:42,600
it's sort of the upside down version of

00:12:38,730 --> 00:12:44,939
the oxide so instead of Colonel being

00:12:42,600 --> 00:12:47,189
the producer it's the user space

00:12:44,939 --> 00:12:50,579
application being the producer so we

00:12:47,189 --> 00:12:54,449
pass descriptors into the to the ring we

00:12:50,579 --> 00:12:56,519
bump the point the head pointer and it

00:12:54,449 --> 00:12:59,519
will be consumed it will be consumed by

00:12:56,519 --> 00:13:03,079
the by the kernel and when the kernel

00:12:59,519 --> 00:13:05,730
has sent out the frame it will return

00:13:03,079 --> 00:13:08,999
the chunk back to user application we

00:13:05,730 --> 00:13:11,040
have a completion ring so it's one way

00:13:08,999 --> 00:13:12,480
of looking at these rings is passing

00:13:11,040 --> 00:13:19,170
ownership back and forth between the

00:13:12,480 --> 00:13:22,769
kernel without doing system calls all

00:13:19,170 --> 00:13:24,839
right so this sounds good another thing

00:13:22,769 --> 00:13:30,299
but do we need system the system calls

00:13:24,839 --> 00:13:32,339
well yes it's the short answer so since

00:13:30,299 --> 00:13:34,559
we're you saying ship share drinks

00:13:32,339 --> 00:13:36,600
between the kernel a Uslan the kernel

00:13:34,559 --> 00:13:40,829
need to pull these rings to get events

00:13:36,600 --> 00:13:42,600
and one could imagine that yes we could

00:13:40,829 --> 00:13:45,269
have a kernel thread running and just

00:13:42,600 --> 00:13:47,459
picking trying to pick events as fast as

00:13:45,269 --> 00:13:51,990
possible but in reality that's you know

00:13:47,459 --> 00:13:54,329
it's wasteful of resources so instead we

00:13:51,990 --> 00:13:56,999
have a flag in the Rings that the user

00:13:54,329 --> 00:14:00,869
in two shakes called neat wake up so you

00:13:56,999 --> 00:14:04,259
check this flag and if if the ring sort

00:14:00,869 --> 00:14:06,959
of signals to the use application that

00:14:04,259 --> 00:14:10,100
hey hey use you need to wake the kernel

00:14:06,959 --> 00:14:13,589
up and you wake it up with a system call

00:14:10,100 --> 00:14:18,209
for example send message or the pole

00:14:13,589 --> 00:14:21,029
system home so that is or when for

00:14:18,209 --> 00:14:23,939
example if you're receiving packets then

00:14:21,029 --> 00:14:25,470
the kernel will have will be woken up a

00:14:23,939 --> 00:14:27,240
saying from the same so you won't need

00:14:25,470 --> 00:14:28,980
any safe in the calls but for example

00:14:27,240 --> 00:14:31,230
when you're actually sending the stuff

00:14:28,980 --> 00:14:32,970
then and not receiving then you need to

00:14:31,230 --> 00:14:35,149
explicitly tell the current like wake up

00:14:32,970 --> 00:14:38,149
and the

00:14:35,149 --> 00:14:41,959
and also and I'll get back to this later

00:14:38,149 --> 00:14:46,610
so if for example if user forgets to add

00:14:41,959 --> 00:14:48,380
entries into the field ring that their

00:14:46,610 --> 00:14:51,560
see path will be stored at some point

00:14:48,380 --> 00:14:53,779
and if it's toward its know what was the

00:14:51,560 --> 00:14:55,970
point of polling so instead it sets the

00:14:53,779 --> 00:14:59,029
need wakeup flag and the colonel goes to

00:14:55,970 --> 00:15:04,209
sleep or the or the colonel process or

00:14:59,029 --> 00:15:04,209
current of thread doing the reception

00:15:06,010 --> 00:15:12,920
and this sort of ties into other or big

00:15:10,130 --> 00:15:16,130
difference with these kind of Sarkis

00:15:12,920 --> 00:15:18,890
compared to usual sorry so with XTP

00:15:16,130 --> 00:15:21,250
sockets the allocation is done the

00:15:18,890 --> 00:15:24,160
kernel allocates frame from the user

00:15:21,250 --> 00:15:26,990
from the user land provided buffers

00:15:24,160 --> 00:15:28,760
whereas the usual like a regular socket

00:15:26,990 --> 00:15:31,420
they would you know use the page

00:15:28,760 --> 00:15:34,790
alligator allocated frame put it on the

00:15:31,420 --> 00:15:37,279
neck hardware ring and they received the

00:15:34,790 --> 00:15:39,920
buffer here instead we actually allocate

00:15:37,279 --> 00:15:41,750
from the user land so it's really

00:15:39,920 --> 00:15:44,180
important that compared to other

00:15:41,750 --> 00:15:48,380
application the use land application

00:15:44,180 --> 00:15:51,350
need to be well behaved so for example

00:15:48,380 --> 00:15:53,870
you need to say on the receive path for

00:15:51,350 --> 00:15:56,149
example you need to fill the field ring

00:15:53,870 --> 00:15:58,370
in order to receive packets and also you

00:15:56,149 --> 00:16:00,110
need to empty the receive ring in order

00:15:58,370 --> 00:16:02,300
to receive packets if the ring is full

00:16:00,110 --> 00:16:04,760
you won't get in packets a similar on

00:16:02,300 --> 00:16:07,850
the transmission side so if you place a

00:16:04,760 --> 00:16:11,420
lot of packets on the send ring but you

00:16:07,850 --> 00:16:14,350
don't empty the completion ring well you

00:16:11,420 --> 00:16:14,350
won't send on the packets

00:16:22,760 --> 00:16:28,990
right so some pointers we find more

00:16:25,550 --> 00:16:31,820
information so first is documentation

00:16:28,990 --> 00:16:36,230
top one and then there's a sample

00:16:31,820 --> 00:16:37,820
application your samples BPF and also

00:16:36,230 --> 00:16:40,010
the library that I talked about which

00:16:37,820 --> 00:16:40,639
sort of hides most of their messy

00:16:40,010 --> 00:16:43,010
details

00:16:40,639 --> 00:16:45,829
it's called Leiby PF you can find out

00:16:43,010 --> 00:16:48,050
there I think there's a standalone

00:16:45,829 --> 00:16:50,540
version only BPF that Facebook is

00:16:48,050 --> 00:16:55,940
maintaining so there's some work github

00:16:50,540 --> 00:16:59,690
but they typically take like stable

00:16:55,940 --> 00:17:03,800
releases all they BPF and package it so

00:16:59,690 --> 00:17:05,179
you can if you're not if you don't want

00:17:03,800 --> 00:17:08,890
to handle the whole kernel tree that

00:17:05,179 --> 00:17:08,890
done that's one way of doing it

00:17:14,820 --> 00:17:23,940
all right so maybe say that you want to

00:17:21,690 --> 00:17:25,710
implement support for this in your own

00:17:23,940 --> 00:17:29,670
driver so how many here are show hands

00:17:25,710 --> 00:17:34,200
I'm an arrow driver developers okay so

00:17:29,670 --> 00:17:36,840
that's like one-third what do you need

00:17:34,200 --> 00:17:39,230
to say that you have a driver that

00:17:36,840 --> 00:17:41,490
supports regular Linux networking

00:17:39,230 --> 00:17:44,070
because as you remember from the first

00:17:41,490 --> 00:17:46,260
diagram you need explicit support for

00:17:44,070 --> 00:17:48,120
x2p so you need to do modifications for

00:17:46,260 --> 00:17:57,090
the drivers so that's sort of the cost

00:17:48,120 --> 00:18:00,810
of the extra performance before we get

00:17:57,090 --> 00:18:03,570
into that we need to so what is needed

00:18:00,810 --> 00:18:05,870
from a driving perspective so again

00:18:03,570 --> 00:18:10,230
let's say that you have driver that's a

00:18:05,870 --> 00:18:14,310
basic Linux support so you have a drive

00:18:10,230 --> 00:18:16,110
in the Chrome tree the first thing you

00:18:14,310 --> 00:18:17,880
do since these rings don't talk about

00:18:16,110 --> 00:18:19,830
they are locked less and they're single

00:18:17,880 --> 00:18:21,330
producers in consumers we need to make

00:18:19,830 --> 00:18:25,140
sure when we're producing two these

00:18:21,330 --> 00:18:29,460
rings that there are only one like they

00:18:25,140 --> 00:18:34,980
need to be synchronized and what most

00:18:29,460 --> 00:18:39,510
NIC that implements XP does is relying

00:18:34,980 --> 00:18:43,950
on something called nappy so now pay is

00:18:39,510 --> 00:18:47,880
an abstraction that the networking

00:18:43,950 --> 00:18:49,590
device drivers use to well implement the

00:18:47,880 --> 00:18:51,300
bottom half after interrupts so you

00:18:49,590 --> 00:18:53,820
receive an interrupt in that or it's

00:18:51,300 --> 00:18:56,340
it's a way of different work and it's

00:18:53,820 --> 00:18:58,170
built on top of the software queues so

00:18:56,340 --> 00:19:02,580
software queues are guaranteed to be

00:18:58,170 --> 00:19:04,500
only round once per core so for example

00:19:02,580 --> 00:19:06,420
if you have a really old driver that not

00:19:04,500 --> 00:19:10,650
using NAAFI then you need to make sure

00:19:06,420 --> 00:19:15,720
that you only produce like you don't

00:19:10,650 --> 00:19:17,670
have one writer to the race I think

00:19:15,720 --> 00:19:20,510
actually most drivers in letters now are

00:19:17,670 --> 00:19:20,510
based on not they so

00:19:29,680 --> 00:19:38,770
this so that's the first thing so when

00:19:33,970 --> 00:19:45,490
XP started that is again a hook in the

00:19:38,770 --> 00:19:49,510
driver and this was you know that it was

00:19:45,490 --> 00:19:51,190
a grandiose idea but in reality adding

00:19:49,510 --> 00:19:53,950
support for XP has taken a real a long

00:19:51,190 --> 00:19:56,500
time so there you know it's like four

00:19:53,950 --> 00:19:58,270
years four years old and still the

00:19:56,500 --> 00:20:01,660
amount of drivers to actually support XP

00:19:58,270 --> 00:20:03,580
is file of you so what the community

00:20:01,660 --> 00:20:05,500
desire arm was adding something called

00:20:03,580 --> 00:20:09,670
like a generic or fall back tomorrow for

00:20:05,500 --> 00:20:13,330
X to P so and so this is adding an XP

00:20:09,670 --> 00:20:15,190
hook right after the skb has been

00:20:13,330 --> 00:20:18,160
allocated so it's like it's a slow

00:20:15,190 --> 00:20:20,410
version of xtp but it was added in order

00:20:18,160 --> 00:20:21,970
to make sure that you know people can

00:20:20,410 --> 00:20:27,309
start playing with XP would actually

00:20:21,970 --> 00:20:29,679
drive the support so again for the best

00:20:27,309 --> 00:20:31,450
performance first you need to add the

00:20:29,679 --> 00:20:35,320
prop breaks to be support your driver

00:20:31,450 --> 00:20:37,720
secondly if you do that well we get

00:20:35,320 --> 00:20:40,270
better performance but just still won't

00:20:37,720 --> 00:20:42,340
get the best performance because they're

00:20:40,270 --> 00:20:45,400
not doing several copies a regular XP

00:20:42,340 --> 00:20:49,840
support still allocates frames from the

00:20:45,400 --> 00:20:52,840
page allocator and in order to get 0 cop

00:20:49,840 --> 00:20:54,040
support that is the the frame that would

00:20:52,840 --> 00:20:56,350
pass from userland

00:20:54,040 --> 00:20:59,890
it's placed directly on the ring

00:20:56,350 --> 00:21:02,730
hardware buffer then we need additional

00:20:59,890 --> 00:21:07,000
support your drivers so there's like yet

00:21:02,730 --> 00:21:13,320
to face first add X to be support the

00:21:07,000 --> 00:21:13,320
second way add support

00:21:17,670 --> 00:21:28,030
all right so this only address is the

00:21:23,940 --> 00:21:33,040
civil pub support so when you start off

00:21:28,030 --> 00:21:35,020
by adding HP support you have the the

00:21:33,040 --> 00:21:38,710
first two NGOs so that's called backs

00:21:35,020 --> 00:21:40,690
into the driver implementation the first

00:21:38,710 --> 00:21:44,500
one called endo BBF that's the one that

00:21:40,690 --> 00:21:53,140
sort of registers the program or the XP

00:21:44,500 --> 00:21:54,940
program to your driver right the XP

00:21:53,140 --> 00:21:58,360
transmission func transmit function

00:21:54,940 --> 00:22:01,960
that's used for redirect redirect to

00:21:58,360 --> 00:22:03,730
other interfaces so that's sort of if

00:22:01,960 --> 00:22:05,920
you implement XP you have support to

00:22:03,730 --> 00:22:11,170
that if you want to add zero cop support

00:22:05,920 --> 00:22:13,810
you need one additional callback and

00:22:11,170 --> 00:22:15,550
that's to wake up the kernel which I

00:22:13,810 --> 00:22:18,010
talked about earlier with a system call

00:22:15,550 --> 00:22:19,420
so you we need a mechanism to wake up

00:22:18,010 --> 00:22:21,960
the kernel

00:22:19,420 --> 00:22:23,460
[Music]

00:22:21,960 --> 00:22:29,050
what else

00:22:23,460 --> 00:22:33,370
yeah so we add the serial cop support by

00:22:29,050 --> 00:22:35,050
adding a adding a structure to the

00:22:33,370 --> 00:22:37,570
driver called the you ma'am and the you

00:22:35,050 --> 00:22:42,040
mem is the abstraction from the exterior

00:22:37,570 --> 00:22:44,200
a fxp layer that contains the packet

00:22:42,040 --> 00:22:47,110
buffer and the field and completion ring

00:22:44,200 --> 00:22:49,390
so that is that use this human structure

00:22:47,110 --> 00:22:52,930
and instead of using the page allocator

00:22:49,390 --> 00:22:57,900
you allocate from the you man and also

00:22:52,930 --> 00:23:03,300
it exposes the rings that you can use to

00:22:57,900 --> 00:23:08,230
complete the transmission distant

00:23:03,300 --> 00:23:10,590
packets and also to allocate from the

00:23:08,230 --> 00:23:10,590
field ring

00:23:17,700 --> 00:23:23,120
all right so here again as you can see

00:23:20,940 --> 00:23:25,620
there's a lot of in 10 drivers there so

00:23:23,120 --> 00:23:30,140
the most recent one is the ice driver

00:23:25,620 --> 00:23:34,290
with some 100 Gig driver

00:23:30,140 --> 00:23:37,200
the first one is 40 gig driver and iqb

00:23:34,290 --> 00:23:40,520
is the 10 gig one and also Mellanox has

00:23:37,200 --> 00:23:44,370
had the support for their new necks and

00:23:40,520 --> 00:23:46,350
I think Broadcom is working on it what

00:23:44,370 --> 00:23:55,100
they are but we'll see when it actually

00:23:46,350 --> 00:24:03,540
rides so sort of finish up with some

00:23:55,100 --> 00:24:07,070
benchmarks so the set stop is as

00:24:03,540 --> 00:24:11,550
following so I used fairly new kernel

00:24:07,070 --> 00:24:17,190
from the EPF next tree which is a pre

00:24:11,550 --> 00:24:21,050
5.5 kernel I have a you know fairly new

00:24:17,190 --> 00:24:26,730
skylake machine that's painted three gig

00:24:21,050 --> 00:24:30,120
gigahertz and a four gig Nick 30 years

00:24:26,730 --> 00:24:34,170
that I have except a clear rated just

00:24:30,120 --> 00:24:36,210
blast packets to the to the host I just

00:24:34,170 --> 00:24:39,800
I'm just using one received queue and

00:24:36,210 --> 00:24:39,800
once thank you from the hardware I

00:24:39,830 --> 00:24:45,300
annotated this noise with - - course on

00:24:43,140 --> 00:24:48,380
one course and to course mean that the

00:24:45,300 --> 00:24:51,120
software queue is running on a different

00:24:48,380 --> 00:24:52,470
core or the kernel side processing is

00:24:51,120 --> 00:24:54,360
running on different core than the user

00:24:52,470 --> 00:24:57,920
application whereas one core everything

00:24:54,360 --> 00:25:00,960
kernel and I think runs on the same core

00:24:57,920 --> 00:25:03,090
and the latest investment is sort of

00:25:00,960 --> 00:25:05,340
it's kinda naive actually to be honest

00:25:03,090 --> 00:25:07,260
it what I've been doing is I just add

00:25:05,340 --> 00:25:08,790
instrumentation to the Exia send the

00:25:07,260 --> 00:25:10,320
packet loop the packet back to the

00:25:08,790 --> 00:25:13,400
packing and return and measure the

00:25:10,320 --> 00:25:13,400
intern way does it

00:25:15,409 --> 00:25:22,379
right so this is the first one that you

00:25:17,759 --> 00:25:25,309
saw at the beginning as you'll see a

00:25:22,379 --> 00:25:33,240
packet really maxes out at about roughly

00:25:25,309 --> 00:25:35,220
1 million packets and just a note when

00:25:33,240 --> 00:25:36,870
we added we started this work you know

00:25:35,220 --> 00:25:38,399
all the meltdown inspectors that weren't

00:25:36,870 --> 00:25:41,039
around but we're seeing I mean we're

00:25:38,399 --> 00:25:43,320
really getting hurt by the specter v2

00:25:41,039 --> 00:25:47,580
stuff so I think the on the receive side

00:25:43,320 --> 00:25:50,789
there would rob close to 10 million

00:25:47,580 --> 00:25:55,529
packets so we need to work that back

00:25:50,789 --> 00:26:02,600
again so this is to course and as you

00:25:55,529 --> 00:26:02,600
can see one core is a drop interestingly

00:26:03,350 --> 00:26:13,639
the packet Mac swap completely dies for

00:26:08,549 --> 00:26:13,639
some reason just non 9k or package there

00:26:14,149 --> 00:26:23,580
but still if you compare it to course to

00:26:18,269 --> 00:26:26,990
one core it's still I mean performance

00:26:23,580 --> 00:26:26,990
the core is still better than one core

00:26:27,379 --> 00:26:34,580
what else interesting it you can see

00:26:30,720 --> 00:26:36,869
that takes only ER maxes out at 21

00:26:34,580 --> 00:26:38,700
million packets and that's because

00:26:36,869 --> 00:26:40,830
that's the horrible limitations we can't

00:26:38,700 --> 00:26:43,619
get out more packets than 21 million

00:26:40,830 --> 00:26:44,970
there so if we add an additional socket

00:26:43,619 --> 00:26:51,059
there we can probably get more packets

00:26:44,970 --> 00:26:54,029
out all right so this is dam template

00:26:51,059 --> 00:26:56,399
latency so again what I did I just

00:26:54,029 --> 00:27:01,860
you know instrumented packet and when it

00:26:56,399 --> 00:27:05,159
just looped it back with a Mac swap late

00:27:01,860 --> 00:27:07,980
to see in micros you know it's really

00:27:05,159 --> 00:27:11,159
good here but then again like this is a

00:27:07,980 --> 00:27:13,710
really few system calls so but in terms

00:27:11,159 --> 00:27:17,840
of weight otherwise were really good

00:27:13,710 --> 00:27:17,840
compared to a packet

00:27:18,170 --> 00:27:25,100
whereas if we actually you know dial up

00:27:22,070 --> 00:27:28,130
the packet rates with this sort of fire

00:27:25,100 --> 00:27:29,210
Oh scenario we go from you know micros

00:27:28,130 --> 00:27:33,830
actually MELAS

00:27:29,210 --> 00:27:36,980
but the worst case for XP sockets is

00:27:33,830 --> 00:27:39,730
still like one digit MELAS I think it's

00:27:36,980 --> 00:27:39,730
still pretty good

00:27:47,220 --> 00:27:51,810
that's about it faction and as usual in

00:27:50,280 --> 00:27:54,630
these campaigns there's a lot of people

00:27:51,810 --> 00:27:55,980
involved so thanks to all these people

00:27:54,630 --> 00:28:03,000
helping out you know writing cows

00:27:55,980 --> 00:28:04,650
testing stuff so so I figured it's a bit

00:28:03,000 --> 00:28:12,540
early but if you have questions I'll be

00:28:04,650 --> 00:28:17,030
happy to answer on my cap yourself none

00:28:12,540 --> 00:28:17,030

YouTube URL: https://www.youtube.com/watch?v=p61PlC9y62k


