Title: Profiling CPU and Memory on Linux, with Opensource Graphical Tools - David Faure, KDAB
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Profiling CPU and Memory on Linux, with Opensource Graphical Tools - David Faure, KDAB*

Finding out where you application is allocating memory, or where it's spending a lot of CPU time -- or even where it's waiting for something, has never been easier. KDAB has developed two opensource tools for this. The first one is heaptrack, for memory profiling. The second one is hotspot, for CPU (and off-CPU) profiling, based on the powerful perf tools from the Linux kernel.

The great benefit of heaptrack and hotspot is that they have been designed for application developers, who don't have to know all the internals of the Linux kernel just to profile their application.
They provide graphical representations that make it quick and easy to spot where the problem is.
Captions: 
	00:00:00,030 --> 00:00:05,520
all right hello everyone my name is

00:00:02,730 --> 00:00:08,970
David four I work for a company called K

00:00:05,520 --> 00:00:11,309
dab what we do is cute OpenGL and super

00:00:08,970 --> 00:00:14,089
Express for instance I've been doing

00:00:11,309 --> 00:00:16,710
cute for 20 years in the KDF project and

00:00:14,089 --> 00:00:19,140
one of the things we ended up doing as a

00:00:16,710 --> 00:00:22,170
company when working on customer code on

00:00:19,140 --> 00:00:25,199
Linux is we felt the need to have better

00:00:22,170 --> 00:00:28,740
tools for profiling and so we ended up

00:00:25,199 --> 00:00:31,500
writing to open source tools which

00:00:28,740 --> 00:00:33,600
basically make it easier to profile CPU

00:00:31,500 --> 00:00:36,360
and memory so I'm going to present these

00:00:33,600 --> 00:00:40,079
two tools to you so they are GPL and

00:00:36,360 --> 00:00:42,420
available for free and I'm hoping all of

00:00:40,079 --> 00:00:44,640
you will benefit from that when you want

00:00:42,420 --> 00:00:47,129
to do some profiling emilynics so there

00:00:44,640 --> 00:00:50,039
are the two tools are called hip track

00:00:47,129 --> 00:00:52,379
and hotspot hip track is about memory

00:00:50,039 --> 00:00:55,079
profiling and hotspot is about

00:00:52,379 --> 00:00:57,329
CPU and of CPU profiling based on perf

00:00:55,079 --> 00:00:58,620
we'll talk about that one next so even

00:00:57,329 --> 00:01:00,800
if you don't like the first one don't

00:00:58,620 --> 00:01:03,210
run away the second one is even better

00:01:00,800 --> 00:01:06,810
let's start with hip tracks so this is

00:01:03,210 --> 00:01:08,970
about profiling memory allocations if

00:01:06,810 --> 00:01:11,060
you think of you know my application

00:01:08,970 --> 00:01:13,979
uses a lot of memory how can I fix that

00:01:11,060 --> 00:01:15,450
if you're lucky enough you don't delete

00:01:13,979 --> 00:01:17,250
anything and you can use a leak checker

00:01:15,450 --> 00:01:19,170
at the end of your program to find out

00:01:17,250 --> 00:01:21,420
you know what memory you have allocated

00:01:19,170 --> 00:01:23,790
that is kind of the easy case there are

00:01:21,420 --> 00:01:25,920
many many tools to do leak checking this

00:01:23,790 --> 00:01:27,570
is not what this is about this is more

00:01:25,920 --> 00:01:29,850
about the case where your application

00:01:27,570 --> 00:01:32,579
grows and grows in terms of memory of a

00:01:29,850 --> 00:01:34,409
time it creates many objects but then

00:01:32,579 --> 00:01:37,259
when you quit the application everything

00:01:34,409 --> 00:01:39,150
gets nicely deleted and then leak

00:01:37,259 --> 00:01:40,920
checkers wouldn't find anything so you

00:01:39,150 --> 00:01:43,920
need a tool that that can tell you

00:01:40,920 --> 00:01:45,750
you've been allocating memory from this

00:01:43,920 --> 00:01:47,310
part of the code and this is where most

00:01:45,750 --> 00:01:50,280
of the allocations come from and so you

00:01:47,310 --> 00:01:54,390
want to see stack traces of where the

00:01:50,280 --> 00:01:56,130
allocations come from so that's a tool

00:01:54,390 --> 00:01:58,290
that you know we thought that should be

00:01:56,130 --> 00:01:58,590
easy enough to write right I'll hard can

00:01:58,290 --> 00:02:00,689
it be

00:01:58,590 --> 00:02:02,520
we just need to hook into malloc and

00:02:00,689 --> 00:02:06,360
free and record every rotation

00:02:02,520 --> 00:02:08,750
easy right so hooking that's easy you

00:02:06,360 --> 00:02:11,190
just write an LD preload library which

00:02:08,750 --> 00:02:13,500
hooks into mark and free and you get all

00:02:11,190 --> 00:02:15,270
of the applications that's easy

00:02:13,500 --> 00:02:17,520
connecting back traces that's a little

00:02:15,270 --> 00:02:20,820
bit more involved there are ways to do

00:02:17,520 --> 00:02:22,220
that so then you you you know resolve

00:02:20,820 --> 00:02:25,230
the bug symbols get to do off

00:02:22,220 --> 00:02:29,130
information to do that and then you have

00:02:25,230 --> 00:02:30,570
a load of back traces and and then the

00:02:29,130 --> 00:02:33,150
next step is to actually collect these

00:02:30,570 --> 00:02:35,670
back traces together and present them to

00:02:33,150 --> 00:02:39,510
the user in a nice way so that's what we

00:02:35,670 --> 00:02:42,180
did with hip track in it is comparable

00:02:39,510 --> 00:02:44,400
to the massive tool of valgrind

00:02:42,180 --> 00:02:48,120
except that val green is very very slow

00:02:44,400 --> 00:02:50,310
on the other hand hip track doesn't have

00:02:48,120 --> 00:02:52,830
that problem because the code runs as

00:02:50,310 --> 00:02:55,590
usual it's only malloc and free that

00:02:52,830 --> 00:02:57,330
have a little bit of overhead even

00:02:55,590 --> 00:03:02,160
better we can attach to a running

00:02:57,330 --> 00:03:04,320
process which is you know that's easy to

00:03:02,160 --> 00:03:07,440
do you just open gdb on the process

00:03:04,320 --> 00:03:10,620
force it to load the library and then

00:03:07,440 --> 00:03:12,480
quit again except of course this gives

00:03:10,620 --> 00:03:13,890
kind of a partial view of your

00:03:12,480 --> 00:03:15,510
application because you're missing all

00:03:13,890 --> 00:03:17,610
of the allocations that happen before

00:03:15,510 --> 00:03:20,250
that so it can be a little bit strange

00:03:17,610 --> 00:03:22,500
you have free without a malloc so that

00:03:20,250 --> 00:03:24,300
could be a little bit confusing and so

00:03:22,500 --> 00:03:27,480
in general you want to run this on the

00:03:24,300 --> 00:03:29,430
entire program or a benchmark or a unit

00:03:27,480 --> 00:03:33,750
test that you wrote further for that

00:03:29,430 --> 00:03:35,550
problem of course because we resolve all

00:03:33,750 --> 00:03:40,019
of the debug symbols to get the stack

00:03:35,550 --> 00:03:41,400
traces during recording that generates a

00:03:40,019 --> 00:03:43,860
lot of data that has to be processed

00:03:41,400 --> 00:03:46,260
afterwards so the GUI is a little bit

00:03:43,860 --> 00:03:48,420
slow when loading traces because there

00:03:46,260 --> 00:03:50,100
is a lot of data to process we have

00:03:48,420 --> 00:03:51,900
ideas of how to improve that in the

00:03:50,100 --> 00:03:54,360
future but you know for now that's one

00:03:51,900 --> 00:03:55,739
of the small problems with it so it's

00:03:54,360 --> 00:03:58,590
better if you do that on a small

00:03:55,739 --> 00:04:00,510
application or a kind of a test case or

00:03:58,590 --> 00:04:02,730
a benchmark rather than a very very

00:04:00,510 --> 00:04:04,500
large application or at least if you do

00:04:02,730 --> 00:04:06,840
it on a very large application do it for

00:04:04,500 --> 00:04:10,820
a short amount of time not for one hour

00:04:06,840 --> 00:04:13,620
that's just impossible so the the tool

00:04:10,820 --> 00:04:17,100
you can get on github it's actually part

00:04:13,620 --> 00:04:18,930
of Acadia project so I have two hats

00:04:17,100 --> 00:04:21,570
right the KDE open-source project and

00:04:18,930 --> 00:04:24,060
the collab company so the code is on the

00:04:21,570 --> 00:04:26,250
KD project whereas what we did ask a dev

00:04:24,060 --> 00:04:26,910
is to provide continuous integration for

00:04:26,250 --> 00:04:29,250
it

00:04:26,910 --> 00:04:31,260
and generating an app image so that you

00:04:29,250 --> 00:04:32,130
can install it without having to compile

00:04:31,260 --> 00:04:34,500
it at all

00:04:32,130 --> 00:04:37,530
so the URL is up there so that you can

00:04:34,500 --> 00:04:40,040
get it from there so that's really easy

00:04:37,530 --> 00:04:42,960
to install because all you have to do is

00:04:40,040 --> 00:04:45,150
you know download make it executable and

00:04:42,960 --> 00:04:50,340
run and it it contains all of the

00:04:45,150 --> 00:04:51,420
required dependencies right so let's

00:04:50,340 --> 00:04:53,610
have a look at what it looks like

00:04:51,420 --> 00:04:55,320
actually I'll do that as a demo that's

00:04:53,610 --> 00:04:57,990
always more fun especially when things

00:04:55,320 --> 00:05:01,290
go wrong so we have this little

00:04:57,990 --> 00:05:02,700
application here I'm a ke and Q

00:05:01,290 --> 00:05:05,070
developer so obviously this is going to

00:05:02,700 --> 00:05:07,050
be a cute application and the

00:05:05,070 --> 00:05:10,140
application works right I can run it and

00:05:07,050 --> 00:05:13,770
take some time and at the end it says I

00:05:10,140 --> 00:05:15,630
found a thousand matches now if I want

00:05:13,770 --> 00:05:19,260
to run this in hip track all I have to

00:05:15,630 --> 00:05:21,720
do is keep track my application and then

00:05:19,260 --> 00:05:24,210
it runs it again but this time it

00:05:21,720 --> 00:05:27,630
records all of the memory allocations

00:05:24,210 --> 00:05:29,910
and deallocations at the end it tells me

00:05:27,630 --> 00:05:32,850
a few stats ok you have done I don't

00:05:29,910 --> 00:05:35,520
know million allocations and then a lot

00:05:32,850 --> 00:05:38,490
of them were temporary allocations what

00:05:35,520 --> 00:05:40,260
we mean by temporary allocation is if

00:05:38,490 --> 00:05:43,200
you look at all of these events all of

00:05:40,260 --> 00:05:45,810
the monarch and all of the free if we

00:05:43,200 --> 00:05:47,940
spot a malloc and free on the same area

00:05:45,810 --> 00:05:49,830
of memory next to each other so there

00:05:47,940 --> 00:05:52,680
was no other model country in between

00:05:49,830 --> 00:05:55,020
this is a temporary allocation it's an

00:05:52,680 --> 00:05:58,410
object or a you know some bit of memory

00:05:55,020 --> 00:06:00,540
that was allocated used and destroyed

00:05:58,410 --> 00:06:04,980
right away sometimes you have to but

00:06:00,540 --> 00:06:07,320
sometimes you can maybe avoid that right

00:06:04,980 --> 00:06:08,880
so the nice thing about hit track is

00:06:07,320 --> 00:06:09,450
that it actually tells us what we need

00:06:08,880 --> 00:06:11,520
to do next

00:06:09,450 --> 00:06:15,420
you just copy/paste the end of the

00:06:11,520 --> 00:06:17,670
output which has run the you run heap

00:06:15,420 --> 00:06:20,160
track again in analyze mode with this

00:06:17,670 --> 00:06:22,410
recording file that was just generated

00:06:20,160 --> 00:06:24,030
and if I do that I get this Givi

00:06:22,410 --> 00:06:26,490
application which is too big for this

00:06:24,030 --> 00:06:30,060
monitor there we are

00:06:26,490 --> 00:06:33,790
I don't know if you can see the bottom

00:06:30,060 --> 00:06:35,620
right so the first tab is kind of a

00:06:33,790 --> 00:06:38,230
summary where we can see where the

00:06:35,620 --> 00:06:39,730
largest memory leaks came from most of

00:06:38,230 --> 00:06:41,830
the memory allocations came from and so

00:06:39,730 --> 00:06:43,540
on this is not the most useful view what

00:06:41,830 --> 00:06:45,550
you want to do in these kind of tools is

00:06:43,540 --> 00:06:48,640
to switch to the frame graph we all love

00:06:45,550 --> 00:06:52,600
lemongrass they are a very easy way to

00:06:48,640 --> 00:06:56,170
see where the biggest offenders are so

00:06:52,600 --> 00:06:59,680
basically in this view here the wider a

00:06:56,170 --> 00:07:03,010
rectangle is the most memory was

00:06:59,680 --> 00:07:04,450
allocated from that piece of code if I

00:07:03,010 --> 00:07:06,850
want to look at so I'll come back to

00:07:04,450 --> 00:07:08,260
this but overall if I look at the amount

00:07:06,850 --> 00:07:09,580
of memory that was consumed by this

00:07:08,260 --> 00:07:11,440
application over time

00:07:09,580 --> 00:07:13,840
well okay the graph here is not very

00:07:11,440 --> 00:07:15,670
interesting because it's a very linear

00:07:13,840 --> 00:07:18,460
but yeah the allocations went up and up

00:07:15,670 --> 00:07:21,280
and that right and what we do in the

00:07:18,460 --> 00:07:23,530
frame graph is to take the peak of that

00:07:21,280 --> 00:07:25,570
graph so basically at the point where we

00:07:23,530 --> 00:07:27,610
used most memory where did it come from

00:07:25,570 --> 00:07:30,220
so that's what the frame graph shows

00:07:27,610 --> 00:07:33,040
because right now I'm looking at memory

00:07:30,220 --> 00:07:34,630
peak so I can see that at the time where

00:07:33,040 --> 00:07:37,210
this application was using most memory

00:07:34,630 --> 00:07:40,180
the memory came from Q string number

00:07:37,210 --> 00:07:43,840
over here and some appending over there

00:07:40,180 --> 00:07:46,150
and we show you the codes that we can

00:07:43,840 --> 00:07:48,550
relate that to the code the other thing

00:07:46,150 --> 00:07:52,270
I'm interested in is if you go back here

00:07:48,550 --> 00:07:54,130
and the summary as well it said there is

00:07:52,270 --> 00:07:55,690
really a large number of temporary

00:07:54,130 --> 00:07:58,690
locations so I want to see what they

00:07:55,690 --> 00:08:00,910
come from I can go here and switch the

00:07:58,690 --> 00:08:03,580
the thing I'm looking at to be temporary

00:08:00,910 --> 00:08:07,570
locations and then I can see that all of

00:08:03,580 --> 00:08:10,090
them the ten million of them came from Q

00:08:07,570 --> 00:08:11,920
string constructor in Maine and if I

00:08:10,090 --> 00:08:14,230
want to see where exactly I can actually

00:08:11,920 --> 00:08:17,140
go call a collie it will switch to that

00:08:14,230 --> 00:08:19,870
other tab and I can see that the

00:08:17,140 --> 00:08:22,450
temporary locations here come from and I

00:08:19,870 --> 00:08:24,700
can even get nine numbers somewhere in

00:08:22,450 --> 00:08:27,970
there if the window is big enough which

00:08:24,700 --> 00:08:29,820
is not temporary locations that's the

00:08:27,970 --> 00:08:33,100
bottom row so that actually comes from

00:08:29,820 --> 00:08:37,420
line 23 okay let's have a look at this

00:08:33,100 --> 00:08:40,060
code it's in here 9:23 is where all of

00:08:37,420 --> 00:08:42,190
my temporary locations come from and I

00:08:40,060 --> 00:08:44,800
know probably not all of you

00:08:42,190 --> 00:08:47,139
cute but think of it as STD string right

00:08:44,800 --> 00:08:49,810
basically the same what we do on line 23

00:08:47,139 --> 00:08:52,149
is we create a string just to compare

00:08:49,810 --> 00:08:55,800
with it and that is of course a

00:08:52,149 --> 00:08:58,269
temporary object that shows up as

00:08:55,800 --> 00:09:01,000
allocation and the allocation right away

00:08:58,269 --> 00:09:03,220
of that object so that's obviously where

00:09:01,000 --> 00:09:05,860
all of this temporary location come from

00:09:03,220 --> 00:09:07,389
we can fix that there are cute api's for

00:09:05,860 --> 00:09:15,100
that right now I could do queue that in

00:09:07,389 --> 00:09:19,449
one string I will rebuild and now I run

00:09:15,100 --> 00:09:22,600
hip track again temporary location zero

00:09:19,449 --> 00:09:25,350
that looks good already right and even

00:09:22,600 --> 00:09:27,610
if those numbers here where you know

00:09:25,350 --> 00:09:29,649
mixing up a lot of other things then I

00:09:27,610 --> 00:09:33,819
wouldn't see anything what I can do now

00:09:29,649 --> 00:09:37,060
is run hip track analyze it has a dish

00:09:33,819 --> 00:09:39,310
mode where I can actually do dash D and

00:09:37,060 --> 00:09:42,129
then I have my two files the old

00:09:39,310 --> 00:09:44,079
recording and the new recording and now

00:09:42,129 --> 00:09:46,750
what it will show is the difference

00:09:44,079 --> 00:09:48,939
between the two so if I come here I can

00:09:46,750 --> 00:09:50,829
see - 10 million

00:09:48,939 --> 00:09:53,050
temporary allocations this is good right

00:09:50,829 --> 00:09:55,329
it's red because it's the biggest number

00:09:53,050 --> 00:09:57,910
but it's actually good I want to - in

00:09:55,329 --> 00:09:59,439
there my new recording has a lot less

00:09:57,910 --> 00:10:02,079
temporary locations than the old

00:09:59,439 --> 00:10:04,060
recording which also means a lot less

00:10:02,079 --> 00:10:06,009
allocations at all right not just

00:10:04,060 --> 00:10:09,899
temporary but of course the overall

00:10:06,009 --> 00:10:13,240
number of memory allocations went down

00:10:09,899 --> 00:10:17,230
right so that's basically hit for hip

00:10:13,240 --> 00:10:18,430
track I need to move on to hotspot but

00:10:17,230 --> 00:10:21,339
as you can see it makes it very

00:10:18,430 --> 00:10:24,639
convenient to find memory allocations in

00:10:21,339 --> 00:10:26,649
your code so this I showed it is only

00:10:24,639 --> 00:10:29,110
available on linux but this is the next

00:10:26,649 --> 00:10:31,509
conference so that's fine it does not

00:10:29,110 --> 00:10:33,160
have support for recording on one

00:10:31,509 --> 00:10:35,139
machine and looking at it on another

00:10:33,160 --> 00:10:38,230
machine that still needs to be

00:10:35,139 --> 00:10:40,750
implemented we could imagine more green

00:10:38,230 --> 00:10:45,260
features but at least it's very useful

00:10:40,750 --> 00:10:48,260
already all right now hotspot

00:10:45,260 --> 00:10:51,930
so the other thing we want to do here is

00:10:48,260 --> 00:10:55,080
profile applications that use too much

00:10:51,930 --> 00:10:57,630
CPU ran for too long or even wait for

00:10:55,080 --> 00:10:59,610
too long so basically that is something

00:10:57,630 --> 00:11:01,290
you can do on Linux with perf but the

00:10:59,610 --> 00:11:03,390
problem of purpose that it was written

00:11:01,290 --> 00:11:05,340
by kernel developers these are really

00:11:03,390 --> 00:11:07,380
fine people but in terms of making user

00:11:05,340 --> 00:11:09,840
interfaces that not really what they do

00:11:07,380 --> 00:11:11,880
and so what they did is perf report

00:11:09,840 --> 00:11:13,620
which is a common line to which we

00:11:11,880 --> 00:11:15,750
looked into it's really hard to

00:11:13,620 --> 00:11:17,550
interpret we thought we are cute

00:11:15,750 --> 00:11:19,230
programmers how about we do a nice GUI

00:11:17,550 --> 00:11:21,540
for this which is a lot easier to

00:11:19,230 --> 00:11:25,020
interpret so that is called hotspot and

00:11:21,540 --> 00:11:26,610
you can find it on github as well it

00:11:25,020 --> 00:11:28,500
depends on a large number of

00:11:26,610 --> 00:11:30,420
dependencies but again we provide an app

00:11:28,500 --> 00:11:34,910
image you can install it in mana click

00:11:30,420 --> 00:11:37,650
so that's really easy so the idea is

00:11:34,910 --> 00:11:39,630
doing of course just a subset of what

00:11:37,650 --> 00:11:41,430
perfect can do because perf can do many

00:11:39,630 --> 00:11:46,140
many things what we want to do is

00:11:41,430 --> 00:11:47,610
sampling profiling and of two kinds the

00:11:46,140 --> 00:11:49,980
first kind is what is my application

00:11:47,610 --> 00:11:52,200
doing when it's actually running when

00:11:49,980 --> 00:11:55,080
it's on CPU and the threads are you know

00:11:52,200 --> 00:11:57,060
calculating stuff where do I spend my

00:11:55,080 --> 00:12:00,690
time and the other thing that hotspot

00:11:57,060 --> 00:12:02,790
can do is providing the off CPU time my

00:12:00,690 --> 00:12:06,420
application is waiting on a mutex

00:12:02,790 --> 00:12:07,890
network file whatever and then I want to

00:12:06,420 --> 00:12:10,050
see that and see what are the biggest

00:12:07,890 --> 00:12:14,670
offenders in terms of waiting for

00:12:10,050 --> 00:12:19,320
something so let me do a demo of that I

00:12:14,670 --> 00:12:22,350
will start hotspot somewhere and then if

00:12:19,320 --> 00:12:25,980
I start off but it shows me

00:12:22,350 --> 00:12:29,580
yeah good enough I can do record data

00:12:25,980 --> 00:12:30,839
and I have some application oh yeah let

00:12:29,580 --> 00:12:38,580
me show you the application first

00:12:30,839 --> 00:12:42,210
it is concurrent it's an application

00:12:38,580 --> 00:12:44,490
that draws a fractal image and when I

00:12:42,210 --> 00:12:47,490
resize the window it is really slow

00:12:44,490 --> 00:12:50,010
right I'm resizing and it takes forever

00:12:47,490 --> 00:12:52,320
to compute the new size right so that's

00:12:50,010 --> 00:12:54,600
the big report how do we figure out why

00:12:52,320 --> 00:12:56,670
is my application slow the first thing

00:12:54,600 --> 00:12:57,610
we need to do is a benchmark so that you

00:12:56,670 --> 00:12:59,770
can reproduce the

00:12:57,610 --> 00:13:02,620
so we did we did that in that

00:12:59,770 --> 00:13:04,000
application with - b1 so that's the

00:13:02,620 --> 00:13:06,220
application itself provides a benchmark

00:13:04,000 --> 00:13:08,620
mode where it doesn't do any user

00:13:06,220 --> 00:13:10,540
interaction it will simply do one

00:13:08,620 --> 00:13:13,480
calculation and exit and that is a

00:13:10,540 --> 00:13:16,180
benchmark we can use them right so

00:13:13,480 --> 00:13:19,480
that's what I can do the recording on I

00:13:16,180 --> 00:13:21,430
bypassed benchmark here you enable of C

00:13:19,480 --> 00:13:23,590
group of CPU profiling so that I

00:13:21,430 --> 00:13:28,150
actually do both on and off CPU at the

00:13:23,590 --> 00:13:30,040
same time stop recording now curve is

00:13:28,150 --> 00:13:32,980
actually running the application and

00:13:30,040 --> 00:13:39,010
recording samples and when it's done I

00:13:32,980 --> 00:13:40,900
can view the results and again some

00:13:39,010 --> 00:13:42,280
summary in the first tab we don't really

00:13:40,900 --> 00:13:44,890
care well there is one thing we always

00:13:42,280 --> 00:13:48,220
want to look at is how many samples did

00:13:44,890 --> 00:13:50,500
I get 10,000 that's good sometimes perf

00:13:48,220 --> 00:13:52,870
messes up and we get eight samples that

00:13:50,500 --> 00:13:55,510
is statistically not relevant at all and

00:13:52,870 --> 00:13:57,940
you need to rerun or configure perf in a

00:13:55,510 --> 00:14:01,000
better way so yes I have 10,000 samples

00:13:57,940 --> 00:14:03,880
which is like 5000 per second that's

00:14:01,000 --> 00:14:07,270
fine now I can go to the frame graph and

00:14:03,880 --> 00:14:10,420
if I'm looking for cycles so actually

00:14:07,270 --> 00:14:12,040
CPU cycles then I can see where is my

00:14:10,420 --> 00:14:14,290
application taking time and I can see

00:14:12,040 --> 00:14:16,300
okay it is taking quite some time in

00:14:14,290 --> 00:14:17,800
fast norm I can look at you know what

00:14:16,300 --> 00:14:20,110
that thing is doing and whether I can

00:14:17,800 --> 00:14:23,500
make it faster it's also spending some

00:14:20,110 --> 00:14:26,350
time in square and also some time in

00:14:23,500 --> 00:14:28,150
that first pass method itself right

00:14:26,350 --> 00:14:30,160
there is no calls being made here

00:14:28,150 --> 00:14:34,390
because that is the code of that file

00:14:30,160 --> 00:14:35,710
itself okay now the thing about that

00:14:34,390 --> 00:14:38,590
program is that it's supposed to be

00:14:35,710 --> 00:14:41,470
multi-threaded and do all of that in

00:14:38,590 --> 00:14:43,660
separate threads so let's have a look at

00:14:41,470 --> 00:14:45,820
how well it managed to actually run in

00:14:43,660 --> 00:14:48,820
many threads so I can use that view at

00:14:45,820 --> 00:14:51,460
the bottom which shows me so the first

00:14:48,820 --> 00:14:53,710
the the stuff at the top is the CPU so I

00:14:51,460 --> 00:14:55,540
can see the CPUs have been doing stuff

00:14:53,710 --> 00:14:58,390
right I have multiple CPUs running

00:14:55,540 --> 00:15:01,060
though it's not orange everywhere so

00:14:58,390 --> 00:15:03,520
there is sometimes some CPU don't do

00:15:01,060 --> 00:15:05,530
anything like CPU one over here more

00:15:03,520 --> 00:15:08,290
interesting I can scroll down and see my

00:15:05,530 --> 00:15:10,090
threads so I have the main thread I have

00:15:08,290 --> 00:15:11,110
two from cute and then I have a whole

00:15:10,090 --> 00:15:14,290
bunch of threads in

00:15:11,110 --> 00:15:18,010
threat - and what do I see far too many

00:15:14,290 --> 00:15:20,079
threats and they keep waiting right

00:15:18,010 --> 00:15:21,700
there an alley for most of them they run

00:15:20,079 --> 00:15:24,190
a little bit and then nothing and then

00:15:21,700 --> 00:15:25,540
they're in the wait for a long time and

00:15:24,190 --> 00:15:29,079
if I want to see what they are waiting

00:15:25,540 --> 00:15:32,290
waiting for I can go back to the frame

00:15:29,079 --> 00:15:35,589
graph and say show me the off CPU time

00:15:32,290 --> 00:15:38,200
which is really the time where a thread

00:15:35,589 --> 00:15:39,640
is waiting sometimes a thread is waiting

00:15:38,200 --> 00:15:42,190
for a good reason right it waits for

00:15:39,640 --> 00:15:43,800
work to do in this application they were

00:15:42,190 --> 00:15:45,940
supposed to go ahead and crunch numbers

00:15:43,800 --> 00:15:48,160
so if I look at what they've been

00:15:45,940 --> 00:15:50,950
waiting for who there is this mutex lock

00:15:48,160 --> 00:15:53,410
in here that takes 80% of the waiting

00:15:50,950 --> 00:15:55,300
time now I can go into the code look at

00:15:53,410 --> 00:15:57,760
what that mutex is actually locking and

00:15:55,300 --> 00:15:59,380
figure out okay it's a far too big scope

00:15:57,760 --> 00:16:01,329
and actually in this example it can be

00:15:59,380 --> 00:16:02,980
reduced and so on there are a number of

00:16:01,329 --> 00:16:05,920
things we can do to this code I don't

00:16:02,980 --> 00:16:08,980
have the time to show that to make this

00:16:05,920 --> 00:16:10,480
application run much better and reduce

00:16:08,980 --> 00:16:11,860
the number of threads of course I have

00:16:10,480 --> 00:16:14,050
eight cause there should be eight

00:16:11,860 --> 00:16:17,050
threads not 20 or I don't know how many

00:16:14,050 --> 00:16:19,660
and do the locking in the in the right

00:16:17,050 --> 00:16:23,199
way but that's that's the whole idea of

00:16:19,660 --> 00:16:25,329
this is to be able to see where is my

00:16:23,199 --> 00:16:27,279
application doing some work and spending

00:16:25,329 --> 00:16:30,910
time doing it and where is my

00:16:27,279 --> 00:16:33,370
application just waiting for things and

00:16:30,910 --> 00:16:35,800
and what is it waiting for so mostly on

00:16:33,370 --> 00:16:37,750
the mutex here it's waiting on a white

00:16:35,800 --> 00:16:39,670
condition that's probably just waiting

00:16:37,750 --> 00:16:43,720
for what to do that is probably fine but

00:16:39,670 --> 00:16:45,880
you know you can cook into that in hot

00:16:43,720 --> 00:16:49,329
spot obviously because this is sampling

00:16:45,880 --> 00:16:51,070
right preference regularly like you know

00:16:49,329 --> 00:16:54,820
five thousand times per seconds and

00:16:51,070 --> 00:16:57,699
collects back traces so the whole idea

00:16:54,820 --> 00:16:59,410
is that if you do that often enough the

00:16:57,699 --> 00:17:02,290
the data you're looking at is what's

00:16:59,410 --> 00:17:04,150
relevant it's not a problem that maybe I

00:17:02,290 --> 00:17:06,579
missed a little bit of code somewhere it

00:17:04,150 --> 00:17:08,439
will not show in any batteries if it's

00:17:06,579 --> 00:17:10,299
that small then it doesn't matter what

00:17:08,439 --> 00:17:12,549
matters is what actually takes time so

00:17:10,299 --> 00:17:15,160
statistically I want to see what's over

00:17:12,549 --> 00:17:17,140
there but because it's sampling there is

00:17:15,160 --> 00:17:19,270
no way to do dipping in this case

00:17:17,140 --> 00:17:21,130
because two runs of the same code would

00:17:19,270 --> 00:17:22,750
still be a little bit different so we

00:17:21,130 --> 00:17:24,240
can't do a diff because we would get

00:17:22,750 --> 00:17:25,799
noise in there

00:17:24,240 --> 00:17:29,400
it would be nice but it's just not

00:17:25,799 --> 00:17:31,320
possible and again here if I didn't know

00:17:29,400 --> 00:17:34,500
the source code I could go too fast

00:17:31,320 --> 00:17:36,390
Mandelbrot do call a collie and over

00:17:34,500 --> 00:17:38,730
here I could see the actual lines of

00:17:36,390 --> 00:17:41,520
code so I can see where most of the

00:17:38,730 --> 00:17:45,450
waiting comes from I can order on of CPU

00:17:41,520 --> 00:17:47,030
time including colors so this one it

00:17:45,450 --> 00:17:50,730
usually works better on a bigger screen

00:17:47,030 --> 00:17:54,450
so now I started here and I I would go

00:17:50,730 --> 00:17:59,580
to this line here 1 2 4 and if I open

00:17:54,450 --> 00:18:03,270
that somehow it's supposed to run myself

00:17:59,580 --> 00:18:05,280
down out here okay the rover demos

00:18:03,270 --> 00:18:08,250
normally you can jump to the line here

00:18:05,280 --> 00:18:09,750
something's broken oh well then you can

00:18:08,250 --> 00:18:13,590
see the line of code and that's where

00:18:09,750 --> 00:18:17,669
the locking happens obviously right so

00:18:13,590 --> 00:18:19,799
that's a hotspot so basically what I

00:18:17,669 --> 00:18:21,630
would like you to do is download compile

00:18:19,799 --> 00:18:24,510
or use the app image for hip track and

00:18:21,630 --> 00:18:26,309
hotspot if all of this was way above

00:18:24,510 --> 00:18:28,320
your head you can buy a training from us

00:18:26,309 --> 00:18:29,880
so the tool III but of course you mean

00:18:28,320 --> 00:18:33,539
we have to eat so what we do is sell

00:18:29,880 --> 00:18:36,059
trainings and consulting and yeah if you

00:18:33,539 --> 00:18:39,059
if you have any questions that don't fit

00:18:36,059 --> 00:18:41,669
here this is my email and you can email

00:18:39,059 --> 00:18:44,600
me but yeah for now

00:18:41,669 --> 00:18:44,600
any questions

00:18:52,879 --> 00:19:01,799
- to talk I'm a Christian world cross

00:18:58,249 --> 00:19:05,519
cross - do you have a plan - what you

00:19:01,799 --> 00:19:07,979
say what first - was not able to people

00:19:05,519 --> 00:19:10,200
with running cost environment work

00:19:07,979 --> 00:19:12,570
suppose we collecting some data in on

00:19:10,200 --> 00:19:16,320
some small immediate device and penalize

00:19:12,570 --> 00:19:18,659
it on our original machine do you have

00:19:16,320 --> 00:19:22,969
any plans to implement this chronology

00:19:18,659 --> 00:19:26,519
do know it you permit it all it won't

00:19:22,969 --> 00:19:28,289
actually you make me realize that what I

00:19:26,519 --> 00:19:30,149
said was a bit of a simplification if

00:19:28,289 --> 00:19:32,369
you have an emetic device you can use

00:19:30,149 --> 00:19:35,429
hip track on it as long as you have the

00:19:32,369 --> 00:19:37,440
debug symbols on the device which I know

00:19:35,429 --> 00:19:39,149
is a problem in some cases but there are

00:19:37,440 --> 00:19:41,279
cases where you can do that right if you

00:19:39,149 --> 00:19:43,139
have a large enough embedded device you

00:19:41,279 --> 00:19:46,200
can copy the debug symbols onto the

00:19:43,139 --> 00:19:47,940
device and then the track will work what

00:19:46,200 --> 00:19:50,459
doesn't work is to try and do like in

00:19:47,940 --> 00:19:51,899
you can do with perf where you run it on

00:19:50,459 --> 00:19:53,909
the embedded device without debug

00:19:51,899 --> 00:19:57,389
symbols you get a trace that is

00:19:53,909 --> 00:20:00,119
basically just instruction addresses but

00:19:57,389 --> 00:20:03,119
not resolved to actual function names so

00:20:00,119 --> 00:20:04,979
that trace you you then move away to a

00:20:03,119 --> 00:20:07,200
developer machine and there you can

00:20:04,979 --> 00:20:08,940
resolve with the debug symbols and get

00:20:07,200 --> 00:20:11,009
stack traces that is something that perf

00:20:08,940 --> 00:20:14,129
supports out of the box so obviously for

00:20:11,009 --> 00:20:15,899
hotspot it works right but it's not

00:20:14,129 --> 00:20:17,279
something that's done by heat track but

00:20:15,899 --> 00:20:19,499
if you have room enough to have the

00:20:17,279 --> 00:20:22,469
debug symbols then you're fine you can

00:20:19,499 --> 00:20:24,149
then move the the actual recording onto

00:20:22,469 --> 00:20:28,190
the developer machine and use the GUI to

00:20:24,149 --> 00:20:28,190
look at it okay thanks

00:20:29,059 --> 00:20:40,799
any other questions you get to run over

00:20:32,609 --> 00:20:44,029
there okay I think it's better for the

00:20:40,799 --> 00:20:44,029
recording if we have it on the right

00:20:50,670 --> 00:20:54,540
can you do it pretty much the same thing

00:20:52,620 --> 00:20:56,070
in the batch mode what for instance if

00:20:54,540 --> 00:20:58,170
you ran something in completely non

00:20:56,070 --> 00:21:01,460
interactive we get some XML file and

00:20:58,170 --> 00:21:03,600
outlaw downloaded for the laser analysis

00:21:01,460 --> 00:21:04,860
I'm sorry the sound isn't very good I

00:21:03,600 --> 00:21:07,020
didn't hear all of it did you say it's

00:21:04,860 --> 00:21:08,520
an XML file yeah can you do it in the

00:21:07,020 --> 00:21:10,140
batch mode and non interactive

00:21:08,520 --> 00:21:12,990
completely so for instance you run it

00:21:10,140 --> 00:21:14,820
somewhere on the Kostya your application

00:21:12,990 --> 00:21:18,179
you get some output in XML and then

00:21:14,820 --> 00:21:20,130
download it for the analysis yes to make

00:21:18,179 --> 00:21:22,530
it easy I showed you recording from

00:21:20,130 --> 00:21:23,970
hotspot but actually and what I do most

00:21:22,530 --> 00:21:26,790
of the time is to record from the common

00:21:23,970 --> 00:21:30,660
line you can do per free called and then

00:21:26,790 --> 00:21:33,240
the same common line and then well yeah

00:21:30,660 --> 00:21:34,710
you need that's why it's annoying and

00:21:33,240 --> 00:21:36,510
that's why you're like Geary's you need

00:21:34,710 --> 00:21:38,640
to ask for back traces to be in there

00:21:36,510 --> 00:21:39,990
with coke left off and then you can do

00:21:38,640 --> 00:21:41,669
the recording on the common line which

00:21:39,990 --> 00:21:44,040
means you can actually script this and

00:21:41,669 --> 00:21:46,679
automate it as much as you want this is

00:21:44,040 --> 00:21:48,660
you know that part is kind of the

00:21:46,679 --> 00:21:49,919
standard perfect part you can do perfect

00:21:48,660 --> 00:21:52,860
record just like you would do normally

00:21:49,919 --> 00:21:56,660
what hotspot provides is the Givi for it

00:21:52,860 --> 00:21:59,040
at least for the cycles and and seminar

00:21:56,660 --> 00:22:01,650
recording for the own CPU recording

00:21:59,040 --> 00:22:04,169
that's all there is to it for the off

00:22:01,650 --> 00:22:06,990
CPU filing that is a little bit a little

00:22:04,169 --> 00:22:09,540
bit more tricky hotspot does use perf

00:22:06,990 --> 00:22:12,390
for that but there isn't a single event

00:22:09,540 --> 00:22:14,850
for this in Perth so there is a bit of

00:22:12,390 --> 00:22:17,360
post-processing happening in hotspot to

00:22:14,850 --> 00:22:19,980
be able to understand this so actually

00:22:17,360 --> 00:22:22,110
it is possible to do that on the command

00:22:19,980 --> 00:22:24,299
line like I have a an analyst for this I

00:22:22,110 --> 00:22:26,100
have a purse of CPU record but if you

00:22:24,299 --> 00:22:27,270
look at what it says it's a whole bunch

00:22:26,100 --> 00:22:30,090
of things that you actually need to put

00:22:27,270 --> 00:22:33,360
in there what you can do is you use

00:22:30,090 --> 00:22:35,370
hotspots initially once on your machine

00:22:33,360 --> 00:22:37,290
and then you go to the summary tab and

00:22:35,370 --> 00:22:40,140
you check out the actual command that it

00:22:37,290 --> 00:22:41,730
has run which is here and that you can

00:22:40,140 --> 00:22:46,970
copy-paste and run again in the future

00:22:41,730 --> 00:22:46,970
on outside of the GUI okay

00:22:54,110 --> 00:23:05,310
okay yeah at the back over there can you

00:22:57,210 --> 00:23:07,860
bring the mic yeah sure Thanks so for

00:23:05,310 --> 00:23:11,610
hot spot is there any limitation that

00:23:07,860 --> 00:23:14,010
would prevent it from working for data

00:23:11,610 --> 00:23:16,170
directly sampled from the colonel

00:23:14,010 --> 00:23:18,990
instead of user space programs or can I

00:23:16,170 --> 00:23:20,790
just feed my poor according for current

00:23:18,990 --> 00:23:24,030
events into the GUI and they will give

00:23:20,790 --> 00:23:25,470
me something useful oh yeah as long as

00:23:24,030 --> 00:23:27,960
you can do a perfect record in it will

00:23:25,470 --> 00:23:30,390
work in there I have proof I see kernel

00:23:27,960 --> 00:23:32,100
symbols at the top of there it's all the

00:23:30,390 --> 00:23:36,000
same to perf so it's all the same to

00:23:32,100 --> 00:23:38,370
hotspot okay that's great and all you

00:23:36,000 --> 00:23:40,560
have to do because that's the little

00:23:38,370 --> 00:23:43,020
missing link I didn't show if you start

00:23:40,560 --> 00:23:46,080
hotspot in a directory where there is a

00:23:43,020 --> 00:23:48,360
preferred data file as recorded by perf

00:23:46,080 --> 00:23:50,400
then hotspot will just pick it up and

00:23:48,360 --> 00:23:52,890
the thing it does on startup is to load

00:23:50,400 --> 00:23:55,680
the file from the current directory so

00:23:52,890 --> 00:23:58,670
that's it right now it's showing the

00:23:55,680 --> 00:23:58,670
recording adjusted

00:24:11,200 --> 00:24:17,980
does this work for all architectures

00:24:13,150 --> 00:24:20,470
Intel arm PowerPC this is perf works

00:24:17,980 --> 00:24:23,800
hotspot works right because it's just a

00:24:20,470 --> 00:24:26,380
GUI so as far as I know Perez work on

00:24:23,800 --> 00:24:28,480
all of the architecture it is part of

00:24:26,380 --> 00:24:32,260
the Linux kernel so it is as possible as

00:24:28,480 --> 00:24:33,820
the Linux kernel ok thanks and for those

00:24:32,260 --> 00:24:37,180
of you who want a bit more advanced

00:24:33,820 --> 00:24:39,670
usage when you when you record with perf

00:24:37,180 --> 00:24:40,960
you can actually choose which events

00:24:39,670 --> 00:24:42,520
you're interested in I've been showing

00:24:40,960 --> 00:24:44,620
only cycles but it could be anything

00:24:42,520 --> 00:24:48,070
else and it will actually show up here

00:24:44,620 --> 00:24:49,750
in the in the drop box here if I do perf

00:24:48,070 --> 00:24:56,020
record with my own and yes that one

00:24:49,750 --> 00:24:59,040
enables a few more things so that I have

00:24:56,020 --> 00:25:02,500
enabled more like instructions and

00:24:59,040 --> 00:25:06,190
memory load or cache misses and these

00:25:02,500 --> 00:25:08,980
kind of things so it's loading all of

00:25:06,190 --> 00:25:11,020
that we need to profile this thing right

00:25:08,980 --> 00:25:12,910
and now I can see instructions and cache

00:25:11,020 --> 00:25:15,160
misses and tools because this is what

00:25:12,910 --> 00:25:17,440
I've recorded so hotspot will pick up

00:25:15,160 --> 00:25:21,870
whatever you have chosen to record in

00:25:17,440 --> 00:25:21,870
the in the preferred data file

00:25:26,660 --> 00:25:31,780
any other questions yep

00:25:39,459 --> 00:25:46,909
with a hip trick too what happens if the

00:25:42,919 --> 00:25:47,919
application is quit or killed before the

00:25:46,909 --> 00:25:50,479
report is written

00:25:47,919 --> 00:25:54,589
you mean 4-perf or hip track deep

00:25:50,479 --> 00:25:57,129
trekker with hip track yeah the right

00:25:54,589 --> 00:26:00,079
thing will happen at the end I'm

00:25:57,129 --> 00:26:01,969
wondering if we have you know all we

00:26:00,079 --> 00:26:05,929
need is signal Hendra to kind of catch

00:26:01,969 --> 00:26:10,729
the termination of the application I'm

00:26:05,929 --> 00:26:13,909
not sure if we have that let's try to

00:26:10,729 --> 00:26:16,249
the program it can attach to the project

00:26:13,909 --> 00:26:18,200
has both modes just like gdb like what

00:26:16,249 --> 00:26:20,389
I'm doing here is to just start the

00:26:18,200 --> 00:26:22,909
application in hip track which basically

00:26:20,389 --> 00:26:24,440
sets LD preload to point to dot a so

00:26:22,909 --> 00:26:27,769
file that's the it's kind of the easy

00:26:24,440 --> 00:26:29,589
setup if you can do a lip print out it

00:26:27,769 --> 00:26:33,349
also has support for attaching to a

00:26:29,589 --> 00:26:35,440
running app with Dash P and the PID but

00:26:33,349 --> 00:26:39,379
it's kind of two different modes right

00:26:35,440 --> 00:26:41,209
so I think if you can attach you can

00:26:39,379 --> 00:26:43,969
detach as well but this one runs too

00:26:41,209 --> 00:26:52,070
fast now I can quit it before hey okay

00:26:43,969 --> 00:26:52,879
let's do something much bigger yeah I

00:26:52,070 --> 00:26:55,940
think it worked

00:26:52,879 --> 00:26:58,219
yeah it works I I did ctrl C to just you

00:26:55,940 --> 00:27:00,919
know kill it it's not exactly as if you

00:26:58,219 --> 00:27:02,959
died but close enough and the signal

00:27:00,919 --> 00:27:06,229
handler caught it and and output the

00:27:02,959 --> 00:27:08,299
final sort that works because I think

00:27:06,229 --> 00:27:10,579
that's an important feature for embedded

00:27:08,299 --> 00:27:13,519
systems many of them are developed to be

00:27:10,579 --> 00:27:17,119
safe when switched off and so there are

00:27:13,519 --> 00:27:19,429
no effort put in a clear shutdown right

00:27:17,119 --> 00:27:21,739
that is true sometimes you just can't

00:27:19,429 --> 00:27:26,419
create the application right yeah the

00:27:21,739 --> 00:27:29,419
the system is no safe for power loss yep

00:27:26,419 --> 00:27:31,639
and you don't spend any effort on a real

00:27:29,419 --> 00:27:33,409
clean shutdown and that's the point

00:27:31,639 --> 00:27:36,709
where many of the memory heap trackers

00:27:33,409 --> 00:27:40,519
fail because that is true that's another

00:27:36,709 --> 00:27:42,529
advantage of doing it this way so yeah

00:27:40,519 --> 00:27:44,299
you can you can just interrupt the app

00:27:42,529 --> 00:27:45,559
or kill it and then it will it will

00:27:44,299 --> 00:27:48,369
catch that I guess I can do the same

00:27:45,559 --> 00:27:48,369
with the kill design

00:27:49,110 --> 00:27:56,170
maybe not all of them because I might

00:27:51,190 --> 00:27:58,270
have a few banging around but yeah let's

00:27:56,170 --> 00:28:01,090
kill it and then yeah there you go

00:27:58,270 --> 00:28:03,520
it did say I just generated file here

00:28:01,090 --> 00:28:04,260
and then I can open file so just kill

00:28:03,520 --> 00:28:07,380
you up

00:28:04,260 --> 00:28:07,380
thank you

00:28:10,350 --> 00:28:20,820
so if truck is like a lot wetter respect

00:28:17,490 --> 00:28:26,890
worgen what has the limitation respect

00:28:20,820 --> 00:28:31,030
Mastiff or the memory leak profiler the

00:28:26,890 --> 00:28:34,690
limitations over massive the reason

00:28:31,030 --> 00:28:41,350
massive is really slow but probably is

00:28:34,690 --> 00:28:48,490
able to the technique with her memory

00:28:41,350 --> 00:28:53,230
human memory allocation that attract a

00:28:48,490 --> 00:28:56,110
not as far as I know massive hooked into

00:28:53,230 --> 00:28:58,600
malloc and free using valgrind which

00:28:56,110 --> 00:29:01,090
gives you the same result as hip track

00:28:58,600 --> 00:29:02,980
except much slower if you're interested

00:29:01,090 --> 00:29:04,930
in kernel memory then of course you need

00:29:02,980 --> 00:29:07,660
to go with you know lower-level

00:29:04,930 --> 00:29:09,700
tools like peripheral TT ng which can

00:29:07,660 --> 00:29:10,990
look at these things but that is kind of

00:29:09,700 --> 00:29:13,540
a different level

00:29:10,990 --> 00:29:15,160
I realized I may be talking to the wrong

00:29:13,540 --> 00:29:16,540
audience right these are tools we made

00:29:15,160 --> 00:29:18,430
for application developers and here

00:29:16,540 --> 00:29:20,290
there are lots of kernel developers so

00:29:18,430 --> 00:29:24,370
it's good to figure out that curve can

00:29:20,290 --> 00:29:26,320
be used with kernel tracing but in terms

00:29:24,370 --> 00:29:28,810
of hip track that is meant to be

00:29:26,320 --> 00:29:34,560
application applications not anything

00:29:28,810 --> 00:29:39,700
lower level than that so question is

00:29:34,560 --> 00:29:42,820
directed unlocked page map or a lock

00:29:39,700 --> 00:29:45,730
page she's called to camera or is April

00:29:42,820 --> 00:29:49,030
or like it for other library that look

00:29:45,730 --> 00:29:52,870
to my look called something like that it

00:29:49,030 --> 00:29:55,810
is a dynamically loadable library that

00:29:52,870 --> 00:29:58,540
that hooks into malloc and free so I

00:29:55,810 --> 00:30:00,340
don't think in hook into M map because

00:29:58,540 --> 00:30:02,500
from an application developer point

00:30:00,340 --> 00:30:05,230
um map does not allocate memory and no

00:30:02,500 --> 00:30:09,340
in Canada is but right it's not the same

00:30:05,230 --> 00:30:11,610
kind of memory okay thank you but that

00:30:09,340 --> 00:30:14,710
could be added if we wanted to right

00:30:11,610 --> 00:30:17,040
alright thanks everyone have a nice

00:30:14,710 --> 00:30:17,040
conference

00:30:18,080 --> 00:30:21,050

YouTube URL: https://www.youtube.com/watch?v=HOR4LiS4uMI


