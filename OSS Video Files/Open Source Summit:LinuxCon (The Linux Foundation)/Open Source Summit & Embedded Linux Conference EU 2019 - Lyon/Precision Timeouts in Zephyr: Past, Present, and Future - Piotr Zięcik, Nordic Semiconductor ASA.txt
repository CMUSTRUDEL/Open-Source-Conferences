Title: Precision Timeouts in Zephyr: Past, Present, and Future - Piotr Zięcik, Nordic Semiconductor ASA
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Precision Timeouts in Zephyr: Past, Present, and Future - Piotr Zięcik, Nordic Semiconductor ASA*

An operating system dedicated for embedded real-time applications must include precise timing infrastructure providing the same level of service regardless of the system load and state. In this session, Piotr Zięcik will give insight into Zephyr timing infrastructure and cover recent activities aimed to improve real-time capabilities of this operating system, as well as compare the achieved performance with real-world requirements. Piotr Zięcik will also present plans for long-term evolution of Zephyr timing infrastructure.
Captions: 
	00:00:00,030 --> 00:00:07,140
okay so let's start from some

00:00:02,669 --> 00:00:11,280
introduction my name is P&G I working

00:00:07,140 --> 00:00:14,040
for the Nordic semiconductor and I am

00:00:11,280 --> 00:00:16,970
internal called owner of the kernel in

00:00:14,040 --> 00:00:19,830
the Nordic which means that every patch

00:00:16,970 --> 00:00:25,380
which goes from Nordic to the Cardinal

00:00:19,830 --> 00:00:28,199
have to be reviewed by me today I will

00:00:25,380 --> 00:00:31,529
talk about the time outs in the fur we

00:00:28,199 --> 00:00:34,380
start with some tell dowry so we start

00:00:31,529 --> 00:00:36,750
we I tell what are the timers in the

00:00:34,380 --> 00:00:39,600
Zephir carnal and where you can find

00:00:36,750 --> 00:00:42,329
them and then I will give you one

00:00:39,600 --> 00:00:46,110
real-world example why the precision of

00:00:42,329 --> 00:00:49,079
these timeouts matters after that we

00:00:46,110 --> 00:00:52,649
will go to the main part of this

00:00:49,079 --> 00:00:56,129
presentation when I show you some

00:00:52,649 --> 00:01:00,390
benchmark how the timeout subsystem in

00:00:56,129 --> 00:01:04,220
the Zephir behaves then presents on past

00:01:00,390 --> 00:01:07,260
current and future work plant for the

00:01:04,220 --> 00:01:11,130
fixing the problems we identified during

00:01:07,260 --> 00:01:17,509
our benchmarking so let's start with

00:01:11,130 --> 00:01:22,170
that with the tower if you ever if even

00:01:17,509 --> 00:01:24,090
try to use Zephir in some even hello

00:01:22,170 --> 00:01:28,259
world application you note that there

00:01:24,090 --> 00:01:31,829
are several API calls which takes some

00:01:28,259 --> 00:01:34,049
kind of the time as an argument so you

00:01:31,829 --> 00:01:36,659
can sleep for several milliseconds you

00:01:34,049 --> 00:01:40,049
can schedule timer over over some

00:01:36,659 --> 00:01:44,610
duration of beard you can have time out

00:01:40,049 --> 00:01:47,520
of the operation all these API calls

00:01:44,610 --> 00:01:51,000
shuttle a timeout inside the Zephyr

00:01:47,520 --> 00:01:55,170
kernel and the kernel itself tracks the

00:01:51,000 --> 00:01:58,770
all individual timeouts and programs the

00:01:55,170 --> 00:02:01,649
system timer in in order to get an

00:01:58,770 --> 00:02:05,579
interrupt when the given I'm out the

00:02:01,649 --> 00:02:07,399
timeout is expiring and this interrupts

00:02:05,579 --> 00:02:10,530
allows you to handle something

00:02:07,399 --> 00:02:12,840
regardless of the state of the system so

00:02:10,530 --> 00:02:16,980
the system may be idle the system might

00:02:12,840 --> 00:02:20,130
execute something but when the timeout

00:02:16,980 --> 00:02:23,820
expires something happens a thread can

00:02:20,130 --> 00:02:26,820
be work walking up some users user

00:02:23,820 --> 00:02:31,680
provides handler is called work is

00:02:26,820 --> 00:02:36,210
submitted to our queue on the fingers in

00:02:31,680 --> 00:02:39,240
general the timeout should be exactly at

00:02:36,210 --> 00:02:39,990
a time when shadowed however this is not

00:02:39,240 --> 00:02:44,250
possible

00:02:39,990 --> 00:02:46,500
in practice we have CPUs which have

00:02:44,250 --> 00:02:49,050
finished speed which aren't handling

00:02:46,500 --> 00:02:52,709
interrupts takes some time executing

00:02:49,050 --> 00:02:55,950
kernel code takes some time so we cannot

00:02:52,709 --> 00:03:00,120
be exactly at the moment of time but

00:02:55,950 --> 00:03:03,150
what we can do is we can be as close as

00:03:00,120 --> 00:03:06,570
possible which means that when the

00:03:03,150 --> 00:03:09,870
interrupt is signaled the kernel takes

00:03:06,570 --> 00:03:12,080
some action and do the minimal work to

00:03:09,870 --> 00:03:18,209
do that something associated with the

00:03:12,080 --> 00:03:23,030
timeout what we cannot do is we cannot

00:03:18,209 --> 00:03:28,080
do premature expiration which means that

00:03:23,030 --> 00:03:30,660
our timeout cannot expire before we

00:03:28,080 --> 00:03:35,459
scheduled that because with this this

00:03:30,660 --> 00:03:40,670
will not allow for any real-world time

00:03:35,459 --> 00:03:46,650
and management so the question how to

00:03:40,670 --> 00:03:48,780
measure the quality of the timeouts we

00:03:46,650 --> 00:03:51,810
can run some benchmark we can try to

00:03:48,780 --> 00:03:54,030
measure some real value we get some

00:03:51,810 --> 00:03:57,030
results represented by dots on the

00:03:54,030 --> 00:04:01,680
picture and we can define the various

00:03:57,030 --> 00:04:04,290
properties of the subsystem so the first

00:04:01,680 --> 00:04:08,360
property is a crossing across it tells

00:04:04,290 --> 00:04:11,610
you how close you are to real value and

00:04:08,360 --> 00:04:12,840
regarding the timeouts time measurements

00:04:11,610 --> 00:04:16,979
in embedded devices

00:04:12,840 --> 00:04:20,789
this part is defined by the hardware to

00:04:16,979 --> 00:04:23,789
be more specific by the accuracy of the

00:04:20,789 --> 00:04:24,070
crystal or unyk other oscillator you are

00:04:23,789 --> 00:04:28,060
used

00:04:24,070 --> 00:04:32,200
to measure the time the next property

00:04:28,060 --> 00:04:36,310
you have to verifies the resolution the

00:04:32,200 --> 00:04:38,740
resolutions the resolutions is limited

00:04:36,310 --> 00:04:42,270
by the hardware you will have one

00:04:38,740 --> 00:04:44,740
megahertz clock on your system timer

00:04:42,270 --> 00:04:47,560
your resolution is limited to one

00:04:44,740 --> 00:04:50,680
microsecond because you are not able to

00:04:47,560 --> 00:04:55,990
distinguish two events happening within

00:04:50,680 --> 00:04:59,050
one microsecond the operating system has

00:04:55,990 --> 00:05:02,290
only one task here should not great

00:04:59,050 --> 00:05:05,020
hardware capabilities so should should

00:05:02,290 --> 00:05:11,860
take everything that Hardware provides

00:05:05,020 --> 00:05:15,280
and not break it and the last property

00:05:11,860 --> 00:05:18,010
is the precision the precision tells you

00:05:15,280 --> 00:05:22,990
how close each measurement of the same

00:05:18,010 --> 00:05:25,870
things are each other the hardware is

00:05:22,990 --> 00:05:29,050
always precise which means that if you

00:05:25,870 --> 00:05:31,980
program the hardware to wait for four

00:05:29,050 --> 00:05:35,500
cycles this will be always four cycles

00:05:31,980 --> 00:05:38,580
the operating system should be precise -

00:05:35,500 --> 00:05:41,470
however handling all of these timeouts

00:05:38,580 --> 00:05:47,410
it's a lot of work and this is the area

00:05:41,470 --> 00:05:49,800
when we are focusing and why the

00:05:47,410 --> 00:05:53,530
precision of timeouts really matters

00:05:49,800 --> 00:05:56,080
because I'm from Nordic the example here

00:05:53,530 --> 00:05:58,210
will be bluetooth so if you know

00:05:56,080 --> 00:06:01,720
probably now there are protocols

00:05:58,210 --> 00:06:04,390
Bluetooth Low Energy and it's low energy

00:06:01,720 --> 00:06:08,050
because it's tries to minimize the radio

00:06:04,390 --> 00:06:11,550
usage which means that the peripheral

00:06:08,050 --> 00:06:15,910
side receiving sight on the picture

00:06:11,550 --> 00:06:19,420
turns the radio receiver only when it

00:06:15,910 --> 00:06:22,620
has to exchange the data the central

00:06:19,420 --> 00:06:26,230
part on the picture this is transmitter

00:06:22,620 --> 00:06:30,510
periodically asks the periphery if it's

00:06:26,230 --> 00:06:34,300
if the peripheral has something to send

00:06:30,510 --> 00:06:37,960
when receiver is on in our trip it

00:06:34,300 --> 00:06:42,020
consumes 20 milli amperes of power

00:06:37,960 --> 00:06:45,380
however the budget for the devices built

00:06:42,020 --> 00:06:49,720
around our trip is for micro amp or

00:06:45,380 --> 00:06:53,720
whole trip of average power consumption

00:06:49,720 --> 00:06:56,720
and the radius of link on the high level

00:06:53,720 --> 00:06:59,990
looks simple however we have to take

00:06:56,720 --> 00:07:03,020
under account some limitations the first

00:06:59,990 --> 00:07:05,960
limitation is the clock drift on the

00:07:03,020 --> 00:07:09,080
transmitter side that the transmitter

00:07:05,960 --> 00:07:12,110
will not transmit exactly at for every 4

00:07:09,080 --> 00:07:14,900
seconds because the crystal used in the

00:07:12,110 --> 00:07:17,180
transmitter have some accuracy which

00:07:14,900 --> 00:07:20,330
means that I'll timeout scheduled by the

00:07:17,180 --> 00:07:22,940
transmitter device have also accuracy

00:07:20,330 --> 00:07:24,950
and we can ship the pulse which means

00:07:22,940 --> 00:07:28,910
that we have take that under account on

00:07:24,950 --> 00:07:32,510
the receiver side widening the receiving

00:07:28,910 --> 00:07:35,120
window the same happens on the receiver

00:07:32,510 --> 00:07:37,190
side we are not synchronized to common

00:07:35,120 --> 00:07:40,310
clock we have an oscillator this

00:07:37,190 --> 00:07:42,890
oscillator have some properties one of

00:07:40,310 --> 00:07:45,350
this is accuracy and we have widen the

00:07:42,890 --> 00:07:48,910
receiving with receiving window in order

00:07:45,350 --> 00:07:52,419
to take on the rack count this drift -

00:07:48,910 --> 00:07:55,090
on top of that this is software overhead

00:07:52,419 --> 00:07:57,919
when we have a time out we have some

00:07:55,090 --> 00:08:01,580
some time is needed to handle that time

00:07:57,919 --> 00:08:04,280
out and some time is needed to turn on

00:08:01,580 --> 00:08:07,190
the radio which means that you have we

00:08:04,280 --> 00:08:10,220
have to take under account that overhead

00:08:07,190 --> 00:08:14,470
and schedule the time out a bit earlier

00:08:10,220 --> 00:08:17,090
and our receiving window is wider and

00:08:14,470 --> 00:08:20,120
whenever this receiving window is wider

00:08:17,090 --> 00:08:23,030
the more power we are consuming while

00:08:20,120 --> 00:08:26,229
the real part when the receiving

00:08:23,030 --> 00:08:30,890
receiving happens is still the same so

00:08:26,229 --> 00:08:33,110
in this example we can clearly see of

00:08:30,890 --> 00:08:35,390
collaboration between the precision of

00:08:33,110 --> 00:08:38,240
the time outs in the system and some

00:08:35,390 --> 00:08:43,430
high level quality benchmark of the

00:08:38,240 --> 00:08:46,339
system likes power usage so if this is

00:08:43,430 --> 00:08:48,920
so important for us let's do some

00:08:46,339 --> 00:08:50,760
benchmark and check how the Zephyr

00:08:48,920 --> 00:08:53,530
behaves

00:08:50,760 --> 00:08:59,560
so we created a very simple benchmark

00:08:53,530 --> 00:09:03,340
which runs the 100 tests of the K timer

00:08:59,560 --> 00:09:07,200
API which are shifted by some fixed

00:09:03,340 --> 00:09:10,870
amount of the time by the key busy wait

00:09:07,200 --> 00:09:12,370
in case of our associate the key busy

00:09:10,870 --> 00:09:15,160
wait is not using the time out

00:09:12,370 --> 00:09:17,650
infrastructure on the Zephyr and we know

00:09:15,160 --> 00:09:23,200
that it's precise because it's basically

00:09:17,650 --> 00:09:26,440
spins waiting for the hardware so all

00:09:23,200 --> 00:09:31,810
timeouts are are close to each other and

00:09:26,440 --> 00:09:35,560
as accurate as possible the K timer uses

00:09:31,810 --> 00:09:37,480
the Zephyr timeout subsystem and this is

00:09:35,560 --> 00:09:42,340
the part we are going to benchmark and

00:09:37,480 --> 00:09:45,280
we also benchmarked the K microsleep API

00:09:42,340 --> 00:09:47,470
as these allows us to use the shorter

00:09:45,280 --> 00:09:50,310
periods of times in life because it's

00:09:47,470 --> 00:09:52,960
accept argument in the microseconds so

00:09:50,310 --> 00:09:57,460
if we stated the benchmark like that

00:09:52,960 --> 00:10:03,160
this is our ideal result so basically

00:09:57,460 --> 00:10:06,370
you see that the time spent in the kbz

00:10:03,160 --> 00:10:09,370
white plus time spent in the cut timer

00:10:06,370 --> 00:10:12,870
exactly matches with our timer and this

00:10:09,370 --> 00:10:19,060
is ideal result this will not happen

00:10:12,870 --> 00:10:21,790
what will happen is that what can happen

00:10:19,060 --> 00:10:25,480
in the real system is that will be

00:10:21,790 --> 00:10:27,850
slight beyond the target because there

00:10:25,480 --> 00:10:29,800
is some execution between the running of

00:10:27,850 --> 00:10:33,100
these two tests and thus there is some

00:10:29,800 --> 00:10:38,140
overhead but let's look about the

00:10:33,100 --> 00:10:42,880
results here is the result of the this

00:10:38,140 --> 00:10:47,680
benchmark taken about half year ago as

00:10:42,880 --> 00:10:53,340
you see most of the timeouts and that

00:10:47,680 --> 00:10:53,340
prematurely be for our target the

00:10:53,430 --> 00:10:59,980
difference is very small but we are

00:10:57,100 --> 00:11:01,480
basically violating one of the

00:10:59,980 --> 00:11:04,510
principles of the

00:11:01,480 --> 00:11:07,089
mouths API in an operating system you

00:11:04,510 --> 00:11:10,380
have to expire at the time or a later

00:11:07,089 --> 00:11:13,000
and if you are expiring the lighter

00:11:10,380 --> 00:11:16,750
all the del I have to be explained

00:11:13,000 --> 00:11:18,940
somehow the second part as the second

00:11:16,750 --> 00:11:21,750
part you can look is that from time to

00:11:18,940 --> 00:11:26,380
time from one test to another we have a

00:11:21,750 --> 00:11:30,579
spike we expiring a way too long to wait

00:11:26,380 --> 00:11:35,050
light later than we intended to and this

00:11:30,579 --> 00:11:39,760
is something also bad because this delay

00:11:35,050 --> 00:11:41,800
is not justified by anything system had

00:11:39,760 --> 00:11:45,130
plenty of time to schedule the time out

00:11:41,800 --> 00:11:50,130
to have to handle time out but from time

00:11:45,130 --> 00:11:50,130
to time it took way longer than expected

00:11:50,730 --> 00:11:55,420
the worst situation is in came across

00:11:53,560 --> 00:12:00,610
sleep we try to sleep for one

00:11:55,420 --> 00:12:03,399
microsecond the higher time was 10

00:12:00,610 --> 00:12:06,010
milliseconds more than 10 milliseconds

00:12:03,399 --> 00:12:08,500
this was because of the tick of 10

00:12:06,010 --> 00:12:13,060
milliseconds at the time the default

00:12:08,500 --> 00:12:15,250
tick however you still see that it's not

00:12:13,060 --> 00:12:18,069
bound to the tick which is 10

00:12:15,250 --> 00:12:21,010
milliseconds it's bound to there too

00:12:18,069 --> 00:12:26,350
much higher value which is more than 12

00:12:21,010 --> 00:12:30,579
milliseconds there are good things all

00:12:26,350 --> 00:12:35,199
of this is now fixed during that

00:12:30,579 --> 00:12:38,170
investigation we identified some

00:12:35,199 --> 00:12:41,050
problems and these problems are for most

00:12:38,170 --> 00:12:46,000
of the part fixed which means that now

00:12:41,050 --> 00:12:48,639
zephyr allows us to set the very high

00:12:46,000 --> 00:12:52,540
degrade which increases the resolution

00:12:48,639 --> 00:12:54,970
from 10 milliseconds to 30 and half

00:12:52,540 --> 00:12:57,880
microsecond in case of our trip

00:12:54,970 --> 00:13:00,220
the next problem we identified is die

00:12:57,880 --> 00:13:02,290
adding or removing time out so for

00:13:00,220 --> 00:13:06,040
example scheduling the time get the K

00:13:02,290 --> 00:13:09,339
timer in one thread you could delay an

00:13:06,040 --> 00:13:13,779
existing timeout indefinitely this

00:13:09,339 --> 00:13:15,070
problem is also already soft also we

00:13:13,779 --> 00:13:18,570
found some hardware

00:13:15,070 --> 00:13:22,200
specific bugs when the software don't

00:13:18,570 --> 00:13:25,210
did not take under consideration some

00:13:22,200 --> 00:13:27,160
hardware hardware capabilities and

00:13:25,210 --> 00:13:29,290
hardware limitations one of that

00:13:27,160 --> 00:13:33,720
limitation is that you cannot schedule

00:13:29,290 --> 00:13:37,270
the time out for the next cycle of the

00:13:33,720 --> 00:13:39,160
system timer on various Hardware you

00:13:37,270 --> 00:13:42,130
have to take under account that there is

00:13:39,160 --> 00:13:46,240
a minimal timeout you can schedule this

00:13:42,130 --> 00:13:50,230
is now handled but if this was very easy

00:13:46,240 --> 00:13:52,870
part there are some dragons in there and

00:13:50,230 --> 00:13:57,640
I show you in this presentation on the

00:13:52,870 --> 00:14:00,130
one dragon but with two heads the one

00:13:57,640 --> 00:14:03,210
head is called unit and the second heads

00:14:00,130 --> 00:14:07,420
is the rounding and let's consider one

00:14:03,210 --> 00:14:09,790
system you are building and because you

00:14:07,420 --> 00:14:12,880
would like to measure some time with the

00:14:09,790 --> 00:14:15,940
millisecond precision you set you that

00:14:12,880 --> 00:14:19,410
your system will use 1000 ticks per

00:14:15,940 --> 00:14:23,430
seconds which means that one tick in the

00:14:19,410 --> 00:14:26,710
zephyr kernel equals to one millisecond

00:14:23,430 --> 00:14:29,140
however you would like to use the Nordic

00:14:26,710 --> 00:14:33,550
hardware and the Nordic hardware uses

00:14:29,140 --> 00:14:36,580
the lowest power of still later we have

00:14:33,550 --> 00:14:40,680
in the system for the system timer which

00:14:36,580 --> 00:14:44,470
uses the crystal from the typical clock

00:14:40,680 --> 00:14:47,160
and because hardware and is not used

00:14:44,470 --> 00:14:51,700
system timer is not using floating-point

00:14:47,160 --> 00:14:55,360
every deal I have to be have to be

00:14:51,700 --> 00:14:58,210
programmed in integer number of hardware

00:14:55,360 --> 00:15:02,080
cycles which means that in our case this

00:14:58,210 --> 00:15:06,970
will be 32 cycles per one tick this also

00:15:02,080 --> 00:15:09,850
means that our tick is 0.9 milliseconds

00:15:06,970 --> 00:15:13,540
however the system still thinks that

00:15:09,850 --> 00:15:16,840
this is 1 millisecond what is the result

00:15:13,540 --> 00:15:20,740
our timeouts in your system will expire

00:15:16,840 --> 00:15:22,890
prematurely if the timeout is sure this

00:15:20,740 --> 00:15:26,020
will be hidden by the software overhead

00:15:22,890 --> 00:15:29,740
but when the timeout becomes longer and

00:15:26,020 --> 00:15:34,540
longer the difference will be will raise

00:15:29,740 --> 00:15:37,390
to and we start to not to see that how

00:15:34,540 --> 00:15:39,790
to fix that problem first we can

00:15:37,390 --> 00:15:43,600
eliminate tactics and use the hardware

00:15:39,790 --> 00:15:45,910
cycles directly inside the kernel but

00:15:43,600 --> 00:15:51,220
this is not possible if practice the

00:15:45,910 --> 00:15:53,530
zephyr also supports the associ with

00:15:51,220 --> 00:15:56,910
system timer counted in the harvard

00:15:53,530 --> 00:16:02,460
hundreds of megahertz and for example

00:15:56,910 --> 00:16:06,430
32-bit integer on 200 megahertz machine

00:16:02,460 --> 00:16:10,080
spawns 221 milliseconds of time which

00:16:06,430 --> 00:16:13,750
means that if you would like to use the

00:16:10,080 --> 00:16:15,970
cycles to measure one minute this is not

00:16:13,750 --> 00:16:19,900
possible on 32-bit representation which

00:16:15,970 --> 00:16:23,200
currently have the second solution is

00:16:19,900 --> 00:16:25,510
the change the definition of the tick at

00:16:23,200 --> 00:16:28,270
the moment we are specifying how

00:16:25,510 --> 00:16:31,360
magnetics we would like to have in one

00:16:28,270 --> 00:16:34,810
second if we specify that how many

00:16:31,360 --> 00:16:37,210
hardware cycles you like we would like

00:16:34,810 --> 00:16:41,440
to have in one tick then the problem

00:16:37,210 --> 00:16:43,750
will disappear so far because this

00:16:41,440 --> 00:16:47,050
change is not done in the zephyr is

00:16:43,750 --> 00:16:49,000
being discussed we have work around we

00:16:47,050 --> 00:16:52,630
can carefully choose the conflicts is

00:16:49,000 --> 00:16:55,900
clock ticks per second value to

00:16:52,630 --> 00:16:59,140
basically ensure that one tick will be

00:16:55,900 --> 00:17:01,710
integer number of Hardware cycles but

00:16:59,140 --> 00:17:06,790
this will not solve all the problem

00:17:01,710 --> 00:17:11,650
that's the another example let's build a

00:17:06,790 --> 00:17:16,030
system with 100 ticks per second so

00:17:11,650 --> 00:17:22,329
every tick 10 milliseconds of time is

00:17:16,030 --> 00:17:26,170
consumed and our our counters in the

00:17:22,329 --> 00:17:29,380
kernel just increases by 10 every tick

00:17:26,170 --> 00:17:31,179
and everything is okay however you know

00:17:29,380 --> 00:17:34,240
we have the hardware which have the

00:17:31,179 --> 00:17:36,179
fancy number of the hardware cycles per

00:17:34,240 --> 00:17:40,230
second so we would like to mitigate that

00:17:36,179 --> 00:17:49,050
so we set the ticks per

00:17:40,230 --> 00:17:53,000
to 128 and now the the time represented

00:17:49,050 --> 00:17:56,190
inside the kernel is not no longer

00:17:53,000 --> 00:17:59,520
integer of milliseconds and milliseconds

00:17:56,190 --> 00:18:02,280
is the unit you are using to communicate

00:17:59,520 --> 00:18:05,820
with the caramel you cannot use another

00:18:02,280 --> 00:18:10,470
unit right now which means that the same

00:18:05,820 --> 00:18:12,990
amount of time measured in using the

00:18:10,470 --> 00:18:15,510
caramel IP I will give you different

00:18:12,990 --> 00:18:19,680
results depending on the time when you

00:18:15,510 --> 00:18:23,520
start the measurement and you see that

00:18:19,680 --> 00:18:26,220
on the picture for example tick one

00:18:23,520 --> 00:18:30,560
takes seven milliseconds according to

00:18:26,220 --> 00:18:30,560
the kernel and tick to takes eight

00:18:31,130 --> 00:18:36,690
result you basically cannot do on the

00:18:34,830 --> 00:18:40,560
time of the measurement using this

00:18:36,690 --> 00:18:45,750
kernel API because you never know if you

00:18:40,560 --> 00:18:50,670
have shorter or longer tick how to fix

00:18:45,750 --> 00:18:53,220
the problem we can do drastic change we

00:18:50,670 --> 00:18:56,640
can use sticks instead of an artifical

00:18:53,220 --> 00:18:59,070
units in the kernel api and this just

00:18:56,640 --> 00:19:03,470
leave all the time conversion to the

00:18:59,070 --> 00:19:05,520
application this is a drastic change but

00:19:03,470 --> 00:19:07,680
if we don't do that

00:19:05,520 --> 00:19:10,470
the only way to have precise time

00:19:07,680 --> 00:19:17,490
representation in the application is to

00:19:10,470 --> 00:19:20,160
your cycles directly so this is just a

00:19:17,490 --> 00:19:23,360
few of the problems we have in the

00:19:20,160 --> 00:19:26,730
industry regarding the timeouts and

00:19:23,360 --> 00:19:30,660
these problems are currently being

00:19:26,730 --> 00:19:35,550
addressed on the github so what we are

00:19:30,660 --> 00:19:38,340
trying to do is to change the whole idea

00:19:35,550 --> 00:19:42,870
of dealing with time with inside the

00:19:38,340 --> 00:19:46,190
zephyr both from the inside the kernel

00:19:42,870 --> 00:19:50,340
and on the kernel application boundary

00:19:46,190 --> 00:19:53,190
first part of that is to allowing the

00:19:50,340 --> 00:19:56,340
application to choose

00:19:53,190 --> 00:20:00,840
the rounding for the unit conversion and

00:19:56,340 --> 00:20:04,410
for that we together with Intel are

00:20:00,840 --> 00:20:06,900
proposing the new API which allows you

00:20:04,410 --> 00:20:08,970
to convert between the time units like

00:20:06,900 --> 00:20:12,120
ticks microsecond milliseconds

00:20:08,970 --> 00:20:14,610
nanoseconds etc and choose the rounding

00:20:12,120 --> 00:20:16,980
mode so are we going to floor are we

00:20:14,610 --> 00:20:21,720
going to sale and we're going to find

00:20:16,980 --> 00:20:23,820
the nearest value the next part which we

00:20:21,720 --> 00:20:27,000
have to do is to change the internal

00:20:23,820 --> 00:20:30,090
time representation on the Zephyr kernel

00:20:27,000 --> 00:20:34,290
because at the moment the all-time

00:20:30,090 --> 00:20:36,390
representation is just integer and sinus

00:20:34,290 --> 00:20:39,500
and width of this integer

00:20:36,390 --> 00:20:43,800
depends on the person who wrote the code

00:20:39,500 --> 00:20:46,440
which have some interesting side effects

00:20:43,800 --> 00:20:48,540
because some parts are using signs and

00:20:46,440 --> 00:20:50,490
doing the calculation the signed integer

00:20:48,540 --> 00:20:51,780
some other parts take this on the

00:20:50,490 --> 00:20:55,680
unsigned and so on

00:20:51,780 --> 00:20:58,680
so what we're proposing is to basically

00:20:55,680 --> 00:21:01,740
I create a new type intended to

00:20:58,680 --> 00:21:07,350
represent basically some time and use it

00:21:01,740 --> 00:21:10,200
in all the places in the kernel when

00:21:07,350 --> 00:21:11,940
some time is involved at the moment

00:21:10,200 --> 00:21:15,720
there are discussion if this type should

00:21:11,940 --> 00:21:18,660
be signed or not because for some people

00:21:15,720 --> 00:21:21,450
some people would like to represent the

00:21:18,660 --> 00:21:26,070
past events and some people would like

00:21:21,450 --> 00:21:30,240
to would like to have longer timeouts in

00:21:26,070 --> 00:21:33,390
the future with the change of the

00:21:30,240 --> 00:21:35,240
internal representation we also

00:21:33,390 --> 00:21:37,950
proposing the change of the external

00:21:35,240 --> 00:21:42,210
representation the one you are using in

00:21:37,950 --> 00:21:44,580
the kernel API what we identified that

00:21:42,210 --> 00:21:47,000
we would like to specify the time out in

00:21:44,580 --> 00:21:50,880
the way that we can use different units

00:21:47,000 --> 00:21:53,310
because from you as the user the SI

00:21:50,880 --> 00:21:57,260
units like milliseconds second and so on

00:21:53,310 --> 00:22:00,570
are more convenient to use if you are

00:21:57,260 --> 00:22:02,970
specifying just timeout however if you

00:22:00,570 --> 00:22:04,890
would like to measure some time the

00:22:02,970 --> 00:22:07,169
ticks are better because then you

00:22:04,890 --> 00:22:09,820
control the converse

00:22:07,169 --> 00:22:13,989
which means that we have to specify both

00:22:09,820 --> 00:22:16,629
value and the unit the second part is

00:22:13,989 --> 00:22:20,320
the reference point at the moment our

00:22:16,629 --> 00:22:23,109
timeouts are scheduled from them now the

00:22:20,320 --> 00:22:24,869
problem which now is that it might be

00:22:23,109 --> 00:22:27,759
not there now you're thinking about

00:22:24,869 --> 00:22:30,759
because you can get the interrupt which

00:22:27,759 --> 00:22:33,729
takes some time and you move you now so

00:22:30,759 --> 00:22:36,070
what we're proposing is that we would

00:22:33,729 --> 00:22:38,889
like to specify the reference point it

00:22:36,070 --> 00:22:42,369
can be still now but it can be absolute

00:22:38,889 --> 00:22:44,619
time if this will be absolute time then

00:22:42,369 --> 00:22:47,139
you can easily schedule one event

00:22:44,619 --> 00:22:50,979
depending on the time when the other

00:22:47,139 --> 00:22:53,440
event happened this helps us to solve

00:22:50,979 --> 00:22:55,210
the problem like in the blood of because

00:22:53,440 --> 00:22:58,269
we are referencing some event which

00:22:55,210 --> 00:23:02,080
happened in the past not the time when

00:22:58,269 --> 00:23:03,549
we are executing the code and the last

00:23:02,080 --> 00:23:06,849
thing we would like to include in that

00:23:03,549 --> 00:23:10,419
structure is the clock source at the

00:23:06,849 --> 00:23:14,049
moment Zephyr uses only one clock source

00:23:10,419 --> 00:23:18,700
which is the system timer and for us in

00:23:14,049 --> 00:23:22,149
this this is something which might be

00:23:18,700 --> 00:23:25,690
problematic we are targeting low-power

00:23:22,149 --> 00:23:28,749
devices and we would like to use the

00:23:25,690 --> 00:23:32,019
best hardware suite for the task with

00:23:28,749 --> 00:23:35,799
the current clock source we are taking

00:23:32,019 --> 00:23:38,799
as least power as possible but the

00:23:35,799 --> 00:23:41,919
resolution of the timer is not the best

00:23:38,799 --> 00:23:44,200
we have other timers in system however

00:23:41,919 --> 00:23:46,509
this will require higher frequency clock

00:23:44,200 --> 00:23:51,029
and higher frequency clock means more

00:23:46,509 --> 00:23:55,149
power so we would like to include the

00:23:51,029 --> 00:23:57,940
include the type of the clock and give

00:23:55,149 --> 00:24:01,570
the choose for the for the application

00:23:57,940 --> 00:24:03,789
developer to choose between the right of

00:24:01,570 --> 00:24:06,549
between the power and precision and

00:24:03,789 --> 00:24:10,719
other properties like for example

00:24:06,549 --> 00:24:13,059
accuracy we would like to do that change

00:24:10,719 --> 00:24:15,369
in the way that existing application

00:24:13,059 --> 00:24:17,970
will require minimal work to port which

00:24:15,369 --> 00:24:23,210
means that current macros

00:24:17,970 --> 00:24:26,430
will allow you to smoke transition but

00:24:23,210 --> 00:24:30,150
this is not enough if you would like to

00:24:26,430 --> 00:24:33,180
have the operating system which is both

00:24:30,150 --> 00:24:35,940
easy to use and allow us to do the

00:24:33,180 --> 00:24:38,160
things like blood of stack when the time

00:24:35,940 --> 00:24:45,150
precision of the timers it's really

00:24:38,160 --> 00:24:49,140
matter we need you as you seen the the

00:24:45,150 --> 00:24:53,940
work involved requires changing of the

00:24:49,140 --> 00:24:56,370
very very basic principles of the

00:24:53,940 --> 00:24:59,490
operating system and we can handle that

00:24:56,370 --> 00:25:02,460
but it also involved the change of the

00:24:59,490 --> 00:25:05,700
api's change of the time representations

00:25:02,460 --> 00:25:09,030
and if you look in the code you see that

00:25:05,700 --> 00:25:11,990
drivers for your associates are using

00:25:09,030 --> 00:25:15,590
the cardinal api with some timeouts you

00:25:11,990 --> 00:25:19,740
see that your application network stacks

00:25:15,590 --> 00:25:22,530
frameworks etc are using is using that

00:25:19,740 --> 00:25:25,050
api's which means that the change we are

00:25:22,530 --> 00:25:29,550
trying to do will affect all of you and

00:25:25,050 --> 00:25:31,710
this is why would like to invite you to

00:25:29,550 --> 00:25:34,290
participate in the discussions about the

00:25:31,710 --> 00:25:37,920
direction of these changes I'll show you

00:25:34,290 --> 00:25:40,530
some problems I'll show you some very

00:25:37,920 --> 00:25:45,450
specific cases we are currently

00:25:40,530 --> 00:25:48,500
discussed but there are much more in the

00:25:45,450 --> 00:25:55,410
presented issues on the github you can

00:25:48,500 --> 00:25:58,110
see other with similar showing similar

00:25:55,410 --> 00:26:01,230
problems in different areas of the

00:25:58,110 --> 00:26:04,020
timeout handling if you would like to

00:26:01,230 --> 00:26:05,610
talk about the better API for time

00:26:04,020 --> 00:26:08,700
conversion there is already pull

00:26:05,610 --> 00:26:11,940
requests with some discussions for

00:26:08,700 --> 00:26:15,660
example about this value signal unsigned

00:26:11,940 --> 00:26:19,590
about 64 bits and so on and there is

00:26:15,660 --> 00:26:22,340
another pull request which shows you how

00:26:19,590 --> 00:26:25,200
we would like to change the

00:26:22,340 --> 00:26:27,840
representation of the timeout for the

00:26:25,200 --> 00:26:30,010
kernel interface so these are things

00:26:27,840 --> 00:26:33,740
which are currently discussed in the

00:26:30,010 --> 00:26:38,890
we would like to have them included in

00:26:33,740 --> 00:26:41,780
some form in 72.1 but without your help

00:26:38,890 --> 00:26:46,220
even the minimal like discussing the

00:26:41,780 --> 00:26:48,770
changes or let's say more demanding like

00:26:46,220 --> 00:26:51,590
porting the the various subsystem of the

00:26:48,770 --> 00:26:53,930
new api this will be not possible and

00:26:51,590 --> 00:26:56,630
with this message I end this

00:26:53,930 --> 00:27:05,590
presentation and would like to say thank

00:26:56,630 --> 00:27:05,590
you do you have any questions

00:27:18,360 --> 00:27:26,130
so thank you for your presentation the

00:27:23,190 --> 00:27:29,490
new timeout specification type that you

00:27:26,130 --> 00:27:32,430
were proposing it it's a little more

00:27:29,490 --> 00:27:34,800
complex than a simple integer how much

00:27:32,430 --> 00:27:39,840
overhead do you see that adding to the

00:27:34,800 --> 00:27:43,200
to the timeout API calls in general the

00:27:39,840 --> 00:27:47,940
structure we are proposing has to fit in

00:27:43,200 --> 00:27:50,400
64 bits because Siskel's cannot pass the

00:27:47,940 --> 00:27:53,520
structure as a value at the moment but

00:27:50,400 --> 00:27:55,470
we can pass 64 bit values which means

00:27:53,520 --> 00:27:57,900
that everything I mentioned in the

00:27:55,470 --> 00:28:01,500
presentation have to fit in 64 bits and

00:27:57,900 --> 00:28:07,500
we already do the benchmarking about

00:28:01,500 --> 00:28:09,540
both size and speed the difference in

00:28:07,500 --> 00:28:13,020
the current filter two bit and the

00:28:09,540 --> 00:28:15,540
propose him on typical application you

00:28:13,020 --> 00:28:18,180
will see like less than one percent of

00:28:15,540 --> 00:28:26,160
increase of the C's under of the size

00:28:18,180 --> 00:28:31,110
and almost almost not visible change of

00:28:26,160 --> 00:28:34,020
the of the performance unless your

00:28:31,110 --> 00:28:36,420
hardware has some troubles with 64 bits

00:28:34,020 --> 00:28:42,530
and 64 bits operations are expects if

00:28:36,420 --> 00:28:42,530
expensive another questions

00:28:48,910 --> 00:28:55,489
if not thank you very much

00:28:51,630 --> 00:28:55,489

YouTube URL: https://www.youtube.com/watch?v=nOYLyNxe_Ck


