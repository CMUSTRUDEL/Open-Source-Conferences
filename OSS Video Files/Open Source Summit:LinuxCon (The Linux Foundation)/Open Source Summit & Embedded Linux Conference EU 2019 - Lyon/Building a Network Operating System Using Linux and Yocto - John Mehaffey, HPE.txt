Title: Building a Network Operating System Using Linux and Yocto - John Mehaffey, HPE
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Building a Network Operating System Using Linux and Yocto - John Mehaffey, HPE*

A Network Operating System puts special demands on the Linux Kernel, in terms of features and scale. John will show the size and performance issues we encountered, and tricks to overcome them.

For the Halon NOS, which was based off the Openswitch project, the Linux kernel went from version 4.4 in the initial release through all the LTS kernels to version 4.19 currently. After each upgrade there is a period of time when all issues are ascribed to the upgrade. John will share lessons learned in managing expectations and perceptions after upgrading the kernel.

John will share the problems we encountered with upgrading infrastructure (kernel, subsystems, and Yocto) in a product development organization, and how we overcame them.

John will show how we used Yocto Layers to implement Platform Independent and Platform Dependent features, in a multiple platform environment.

Finally, John will share lessons we learned about PCI software architecture for modular chassis network switches.
Captions: 
	00:00:00,060 --> 00:00:06,540
well I apologize for that I'm gonna have

00:00:02,790 --> 00:00:13,620
to go fast here to make up time so I

00:00:06,540 --> 00:00:15,750
apologize this talk is about building a

00:00:13,620 --> 00:00:19,109
network operating system using Linux in

00:00:15,750 --> 00:00:22,080
Yocto my name is John McAfee I'm a Linux

00:00:19,109 --> 00:00:25,289
kernel Architect at Hewlett Packard

00:00:22,080 --> 00:00:27,119
enterprise it's not about how to build a

00:00:25,289 --> 00:00:30,300
network switch per se but it's how to

00:00:27,119 --> 00:00:34,820
use Linux and Yocto and how we did that

00:00:30,300 --> 00:00:37,469
to build our aruba OS CX

00:00:34,820 --> 00:00:40,440
that's a marketing name I'm gonna use

00:00:37,469 --> 00:00:43,739
Halon within this presentation

00:00:40,440 --> 00:00:46,410
network operating system is basically a

00:00:43,739 --> 00:00:51,539
command set it looks a lot like a Cisco

00:00:46,410 --> 00:00:53,969
switch with things like turning turning

00:00:51,539 --> 00:00:56,340
off a port and you say shut but to turn

00:00:53,969 --> 00:00:58,579
it on turn on a port you say no shut

00:00:56,340 --> 00:01:02,070
anyway you get used to it after a while

00:00:58,579 --> 00:01:08,100
it's based on open switch and it's based

00:01:02,070 --> 00:01:09,810
on Linux underneath it all the both the

00:01:08,100 --> 00:01:12,600
kernel end user land although all the

00:01:09,810 --> 00:01:16,979
applications and everything are based on

00:01:12,600 --> 00:01:19,439
Linux and and GCC and Yocto as the build

00:01:16,979 --> 00:01:21,689
system this talk will discuss the

00:01:19,439 --> 00:01:28,979
practical challenges of combining those

00:01:21,689 --> 00:01:31,560
open source technologies looks like I

00:01:28,979 --> 00:01:34,520
lost all my timings I hope I've got the

00:01:31,560 --> 00:01:34,520
right presentation up

00:01:36,030 --> 00:01:41,290
the Linux kernel is is very configurable

00:01:39,600 --> 00:01:45,450
the trick is finding the right

00:01:41,290 --> 00:01:50,560
combination of kernel configurations and

00:01:45,450 --> 00:01:55,360
tables and and various pieces that go

00:01:50,560 --> 00:01:58,840
together to make it work in in the

00:01:55,360 --> 00:02:02,110
switch we use Ram based system it's

00:01:58,840 --> 00:02:04,840
completely memory based that includes

00:02:02,110 --> 00:02:09,010
the kernel all the routing tables and

00:02:04,840 --> 00:02:11,740
those sorts of things along with the

00:02:09,010 --> 00:02:14,470
user land is a ram disk trick here is

00:02:11,740 --> 00:02:17,140
you start small so you don't really want

00:02:14,470 --> 00:02:19,720
to start with the SDK that you get from

00:02:17,140 --> 00:02:21,790
your chip vendor that's got everything

00:02:19,720 --> 00:02:23,950
in it but the kitchen sink it's hard to

00:02:21,790 --> 00:02:26,020
pare that down but if you start small

00:02:23,950 --> 00:02:31,510
and build your way up you end up with a

00:02:26,020 --> 00:02:34,780
much more manageable size use the octo

00:02:31,510 --> 00:02:36,640
layers mechanism to add platform

00:02:34,780 --> 00:02:40,530
dependent features so we'll talk more

00:02:36,640 --> 00:02:43,680
about the layers and how that works but

00:02:40,530 --> 00:02:50,680
it really helps you configure different

00:02:43,680 --> 00:02:52,870
platforms differently and if you have

00:02:50,680 --> 00:02:57,090
dependent kernels for instance k exec

00:02:52,870 --> 00:03:00,880
kernel or we in our case we also have a

00:02:57,090 --> 00:03:03,790
boot kernel that we use you trim those

00:03:00,880 --> 00:03:06,160
even more aggressively it's it's easy to

00:03:03,790 --> 00:03:07,780
start with you know here's here's the OS

00:03:06,160 --> 00:03:12,300
that we have we'll just use reuse that

00:03:07,780 --> 00:03:12,300
but it wastes a lot of space and time

00:03:12,790 --> 00:03:20,440
use busybox start with busybox when you

00:03:15,730 --> 00:03:21,220
need the real features that aren't in

00:03:20,440 --> 00:03:23,920
the busybox

00:03:21,220 --> 00:03:26,800
we didn't try and configure busybox we

00:03:23,920 --> 00:03:27,959
just use busybox and as it came out you

00:03:26,800 --> 00:03:30,310
don't really want to go down that path

00:03:27,959 --> 00:03:32,650
you know if you configure busybox and

00:03:30,310 --> 00:03:34,570
you run into more problems you just go

00:03:32,650 --> 00:03:35,420
down that rat hole so we didn't do that

00:03:34,570 --> 00:03:39,640
we would use the

00:03:35,420 --> 00:03:42,739
real packages when busybox wasn't enough

00:03:39,640 --> 00:03:45,950
if you've got a small Ram footprint a

00:03:42,739 --> 00:03:48,050
smaller networks which you can share RAM

00:03:45,950 --> 00:03:50,540
for functions that are needed at

00:03:48,050 --> 00:03:53,180
different times for instance if you're

00:03:50,540 --> 00:03:54,709
redundant management says so there's a

00:03:53,180 --> 00:03:57,500
problem with this we need to reboot it

00:03:54,709 --> 00:04:00,380
and you want to get your logs and your

00:03:57,500 --> 00:04:01,489
core dumps and everything together you

00:04:00,380 --> 00:04:05,599
really want to failover the

00:04:01,489 --> 00:04:09,880
functionality to another another CPU or

00:04:05,599 --> 00:04:12,380
another switch and then use that time to

00:04:09,880 --> 00:04:14,000
gather all your pieces you don't no

00:04:12,380 --> 00:04:18,729
longer need Network buffers and so on

00:04:14,000 --> 00:04:18,729
you can use that space differently

00:04:22,960 --> 00:04:28,100
kernel updates if you saw the keynote

00:04:25,850 --> 00:04:29,810
Gregg Cobra Hartman says you really want

00:04:28,100 --> 00:04:31,580
to keep up to date with your kernels I

00:04:29,810 --> 00:04:35,120
agree with that

00:04:31,580 --> 00:04:37,880
we started with kernel for four in 2015

00:04:35,120 --> 00:04:41,600
and then migrated to the LTS kernel is

00:04:37,880 --> 00:04:46,550
available in Yocto along the way those

00:04:41,600 --> 00:04:49,910
kernel updates boy I wish my this this

00:04:46,550 --> 00:04:51,979
isn't the presentation anyways they

00:04:49,910 --> 00:04:54,020
provide critical bug fixes they provide

00:04:51,979 --> 00:04:56,180
security updates they provide new

00:04:54,020 --> 00:04:59,360
features that that perhaps your your

00:04:56,180 --> 00:05:02,200
newer hardware platforms need but they

00:04:59,360 --> 00:05:04,640
also provide a convenient excuse for

00:05:02,200 --> 00:05:06,950
engineers to say well the kernel upgrade

00:05:04,640 --> 00:05:08,360
you know it failed after my code was

00:05:06,950 --> 00:05:10,640
working fine and after the kernel

00:05:08,360 --> 00:05:13,070
upgrade it doesn't work anymore when we

00:05:10,640 --> 00:05:16,550
upgraded from four four two four nine we

00:05:13,070 --> 00:05:19,760
got 18 different bugs all blamed on the

00:05:16,550 --> 00:05:22,460
kernel half of those were actually code

00:05:19,760 --> 00:05:24,140
or design flaws that were exposed by the

00:05:22,460 --> 00:05:26,270
upgrade the kernel didn't used to care

00:05:24,140 --> 00:05:30,560
about it and it started you know being a

00:05:26,270 --> 00:05:34,130
little bit more careful with with

00:05:30,560 --> 00:05:35,690
parameters and so we had to fix it in in

00:05:34,130 --> 00:05:36,950
the in their code yeah your code worked

00:05:35,690 --> 00:05:40,310
before it it doesn't work now and it's

00:05:36,950 --> 00:05:42,260
your code that's bad only two of those

00:05:40,310 --> 00:05:45,370
were actually kernel issues the rest

00:05:42,260 --> 00:05:45,370
were misunderstandings

00:05:47,460 --> 00:05:53,410
management perception is guided by its

00:05:51,190 --> 00:05:56,830
initial reports and from people that

00:05:53,410 --> 00:05:59,080
they trust you know master architect

00:05:56,830 --> 00:06:02,170
level people they they listen to them

00:05:59,080 --> 00:06:02,890
and not saying you know no no it's

00:06:02,170 --> 00:06:04,900
really not

00:06:02,890 --> 00:06:08,740
we had to spend a lot of time doing

00:06:04,900 --> 00:06:11,410
triage and analysis and putting together

00:06:08,740 --> 00:06:13,180
presentations to management

00:06:11,410 --> 00:06:15,850
it really helped a lot that our

00:06:13,180 --> 00:06:18,910
management at HPE is is pretty much all

00:06:15,850 --> 00:06:21,070
you know from the ranks technical people

00:06:18,910 --> 00:06:24,250
that understand this sort of stuff but

00:06:21,070 --> 00:06:27,550
it had to be explained in in words they

00:06:24,250 --> 00:06:29,890
could understand so once we did that

00:06:27,550 --> 00:06:33,130
they understood the the issues and why

00:06:29,890 --> 00:06:36,460
we needed to upgrade Colonels and for

00:06:33,130 --> 00:06:39,610
some reason the upgrade from four four

00:06:36,460 --> 00:06:40,120
nine to four fourteen was a lot more

00:06:39,610 --> 00:06:42,160
smoothly

00:06:40,120 --> 00:06:44,440
maybe we just flushed out all the all

00:06:42,160 --> 00:06:48,040
the really bad bugs or maybe it wasn't

00:06:44,440 --> 00:06:49,660
as difficult of a transition but it went

00:06:48,040 --> 00:06:52,720
a lot more smoothly and management

00:06:49,660 --> 00:06:55,710
expectations were were properly set so

00:06:52,720 --> 00:06:55,710
we didn't have that same issue

00:06:59,530 --> 00:07:05,919
Yocto layers we use extensively in Halon

00:07:02,970 --> 00:07:08,259
we've got pakhi layers for the basics

00:07:05,919 --> 00:07:11,380
there's four Pocky layers that we use

00:07:08,259 --> 00:07:13,810
meta meta Pocky meta yak Toby SP and

00:07:11,380 --> 00:07:17,470
then we added a layer called Pocky

00:07:13,810 --> 00:07:20,199
patches so any time an engineer want to

00:07:17,470 --> 00:07:22,479
change something that was in the Pocky

00:07:20,199 --> 00:07:24,970
layer one of the Pocky layers we said no

00:07:22,479 --> 00:07:26,800
you can't change the layer there you

00:07:24,970 --> 00:07:29,590
have to put the changes in to Pocky

00:07:26,800 --> 00:07:33,190
patches and that helps us upgrade the

00:07:29,590 --> 00:07:35,830
Yocto so we keep our Pocky pristine and

00:07:33,190 --> 00:07:37,630
then we can just remove it and then put

00:07:35,830 --> 00:07:42,729
in a new one and then apply the patches

00:07:37,630 --> 00:07:44,830
that they're still necessary we we've

00:07:42,729 --> 00:07:47,650
got an open embedded layer a lot of

00:07:44,830 --> 00:07:49,630
stuff and open embedded we only bring in

00:07:47,650 --> 00:07:53,409
the stuff that we need open embedded is

00:07:49,630 --> 00:07:54,400
very large and cost a lot of space when

00:07:53,409 --> 00:07:57,310
we wanted brought in the whole

00:07:54,400 --> 00:07:59,740
openembedded as a layer so we just pick

00:07:57,310 --> 00:08:04,750
and choose and bring that into the open

00:07:59,740 --> 00:08:07,090
embedded layer we have a metaphor there

00:08:04,750 --> 00:08:09,639
for open source packages that aren't

00:08:07,090 --> 00:08:16,020
part of Pocky or openembedded stuff like

00:08:09,639 --> 00:08:19,060
dev tools and real time database stuff

00:08:16,020 --> 00:08:23,080
math packages various things that we

00:08:19,060 --> 00:08:25,570
bring in from open source we have a

00:08:23,080 --> 00:08:29,289
Halon common layer that is common

00:08:25,570 --> 00:08:32,440
between all of the boot motors and and

00:08:29,289 --> 00:08:35,380
everything and then we have the Halon

00:08:32,440 --> 00:08:40,390
distro layer which is the commands the

00:08:35,380 --> 00:08:42,700
NOS commands that that our custom and

00:08:40,390 --> 00:08:45,160
common to all of the Halon platforms and

00:08:42,700 --> 00:08:47,500
then we have platform dependent layers

00:08:45,160 --> 00:08:49,600
which are features that are only needed

00:08:47,500 --> 00:08:51,370
by some switches and not by others if

00:08:49,600 --> 00:08:53,320
you have a big chassis of course which

00:08:51,370 --> 00:09:00,070
it has a different set of features then

00:08:53,320 --> 00:09:01,779
and then a small edge box that is very

00:09:00,070 --> 00:09:04,140
limited in memory and limited in

00:09:01,779 --> 00:09:04,140
features

00:09:04,630 --> 00:09:11,210
how many of you are familiar with Yocto

00:09:06,950 --> 00:09:14,000
octal layers okay so you guys get it

00:09:11,210 --> 00:09:16,450
Yocto layers you'll have the same issues

00:09:14,000 --> 00:09:19,370
as kernel upgrades doctor upgrades

00:09:16,450 --> 00:09:20,660
they're a lot harder to justify then the

00:09:19,370 --> 00:09:23,390
kernel upgrades because you don't have

00:09:20,660 --> 00:09:27,500
quite so many CVS and if you do you can

00:09:23,390 --> 00:09:31,400
you can pick and choose and management

00:09:27,500 --> 00:09:34,160
really doesn't want you know to have any

00:09:31,400 --> 00:09:36,140
trouble right well we're getting close

00:09:34,160 --> 00:09:37,850
to release you know it's only a few

00:09:36,140 --> 00:09:43,150
months away we don't want to have any of

00:09:37,850 --> 00:09:45,710
these changes so you try and do your

00:09:43,150 --> 00:09:48,320
Yocto upgrades at the beginning of a

00:09:45,710 --> 00:09:50,420
release but often the beginning of a

00:09:48,320 --> 00:09:54,050
release is the end of the previous

00:09:50,420 --> 00:09:55,700
release key personnel are often needed

00:09:54,050 --> 00:09:58,940
elsewhere the customers are finding

00:09:55,700 --> 00:10:01,580
issues with the release and they just

00:09:58,940 --> 00:10:04,340
start you know let's let's put all hands

00:10:01,580 --> 00:10:07,580
on deck and fix find out fix what the

00:10:04,340 --> 00:10:09,710
problem is and that kind of thing so the

00:10:07,580 --> 00:10:12,589
the takeaway is you've got to be

00:10:09,710 --> 00:10:14,510
persistent and if you see a release

00:10:12,589 --> 00:10:16,850
coming up say in six months you're going

00:10:14,510 --> 00:10:20,630
to be releasing and then moving on to

00:10:16,850 --> 00:10:28,700
the next the next release then that's

00:10:20,630 --> 00:10:31,310
the time to to branch you know get your

00:10:28,700 --> 00:10:32,600
prep work done you know even you know

00:10:31,310 --> 00:10:33,470
even if you've got it pretty well done

00:10:32,600 --> 00:10:35,360
you know you're still going to have

00:10:33,470 --> 00:10:38,420
maybe a month of transition but that

00:10:35,360 --> 00:10:40,300
month is okay it's the the three months

00:10:38,420 --> 00:10:44,260
that it takes to bring it in that that

00:10:40,300 --> 00:10:44,260
puts you behind the eight ball again

00:10:47,499 --> 00:10:53,779
subsystem upgrades also have the same

00:10:51,109 --> 00:10:57,199
issues upgrades of large subsystems such

00:10:53,779 --> 00:11:00,199
as the a ASIC SDK they they have the

00:10:57,199 --> 00:11:01,669
same issues in addition we don't

00:11:00,199 --> 00:11:05,599
normally allow merge commits in our git

00:11:01,669 --> 00:11:08,559
repository that cause issues but for a

00:11:05,599 --> 00:11:12,219
large subsystem it's easiest if you

00:11:08,559 --> 00:11:15,349
branch and then remove the old code

00:11:12,219 --> 00:11:17,719
bring in a pristine copy of the new code

00:11:15,349 --> 00:11:20,389
and then replay all of the commits that

00:11:17,719 --> 00:11:23,659
were on top of that old code so if you

00:11:20,389 --> 00:11:25,909
if you follow that as a methodology then

00:11:23,659 --> 00:11:29,419
it works pretty well the the commits

00:11:25,909 --> 00:11:31,579
come in one at a time some maybe aren't

00:11:29,419 --> 00:11:34,419
needed anymore some you know are minor

00:11:31,579 --> 00:11:38,389
upgrades some you might have to rewrite

00:11:34,419 --> 00:11:42,649
but once you're ready and you have have

00:11:38,389 --> 00:11:47,629
your your commit you know your upgrade

00:11:42,649 --> 00:11:50,029
ready to go then you you push it into

00:11:47,629 --> 00:11:52,729
your repository make sure you save the

00:11:50,029 --> 00:11:55,099
shop before that push and the Shaw that

00:11:52,729 --> 00:11:57,079
that comes out after that push because

00:11:55,099 --> 00:11:59,599
you're for sure gonna have people coming

00:11:57,079 --> 00:12:02,509
and saying well you're ace your SDK

00:11:59,599 --> 00:12:05,449
upgrade you know broke my code and

00:12:02,509 --> 00:12:07,069
sometimes that happens months later you

00:12:05,449 --> 00:12:08,749
know it's like okay well I've got this

00:12:07,069 --> 00:12:11,029
issue it only happens once in a while

00:12:08,749 --> 00:12:15,669
and I've traced it down to the SDK

00:12:11,029 --> 00:12:19,339
upgrade so it's useful to have actual

00:12:15,669 --> 00:12:21,109
system images that can be booted with

00:12:19,339 --> 00:12:23,449
those Shaw's from before and after save

00:12:21,109 --> 00:12:24,829
those for four months you know sometimes

00:12:23,449 --> 00:12:27,649
like I said three months five months

00:12:24,829 --> 00:12:30,849
later people ask you is did you have an

00:12:27,649 --> 00:12:30,849
image that I can just try it on

00:12:36,920 --> 00:12:46,069
Halon uses 527 out of the pocky packages

00:12:41,620 --> 00:12:49,790
122 of the foss packages 276 kernel

00:12:46,069 --> 00:12:53,509
modules some of those are custom 518

00:12:49,790 --> 00:12:58,069
custom userland packages that we wrote

00:12:53,509 --> 00:12:59,569
for the for the NOS for Halon currently

00:12:58,069 --> 00:13:02,060
we support two architectures and six

00:12:59,569 --> 00:13:10,699
variants so we're using all of the power

00:13:02,060 --> 00:13:13,220
of octo build x varied widely throughout

00:13:10,699 --> 00:13:17,810
the development sometimes as much as

00:13:13,220 --> 00:13:20,509
four hours and we tried a lot of

00:13:17,810 --> 00:13:24,550
experiments to get things down we tried

00:13:20,509 --> 00:13:28,490
C cash we tried ice cream we tried

00:13:24,550 --> 00:13:31,160
Electric accelerator we tried you know

00:13:28,490 --> 00:13:32,689
that the ASIC SDK we said well if you're

00:13:31,160 --> 00:13:35,720
an SGD a developer you got to live with

00:13:32,689 --> 00:13:38,300
it but you know when you're when you're

00:13:35,720 --> 00:13:40,579
done then just check in the library that

00:13:38,300 --> 00:13:42,439
comes out of that build process and then

00:13:40,579 --> 00:13:46,699
everybody else doesn't need to live with

00:13:42,439 --> 00:13:49,040
with building the SDK every time we you

00:13:46,699 --> 00:13:53,089
know we've got it down to two reasonable

00:13:49,040 --> 00:13:54,500
amount it's about 20 minutes to 40

00:13:53,089 --> 00:13:57,470
minutes for a bill depending on what you

00:13:54,500 --> 00:14:01,040
change which is still too much but we're

00:13:57,470 --> 00:14:04,880
working to get it down biggest remaining

00:14:01,040 --> 00:14:08,029
issue we have is depends chains our

00:14:04,880 --> 00:14:11,089
system is based that the user land

00:14:08,029 --> 00:14:15,560
software is based on C make C make needs

00:14:11,089 --> 00:14:19,699
to have all of the packages that it

00:14:15,560 --> 00:14:21,649
needs in the this route so you have to

00:14:19,699 --> 00:14:24,199
say it depends on this and so if you

00:14:21,649 --> 00:14:26,209
make a minor change to a package say you

00:14:24,199 --> 00:14:27,769
add a check for a null pointer or

00:14:26,209 --> 00:14:29,420
something like that it doesn't really

00:14:27,769 --> 00:14:32,420
change you don't really need to rebuild

00:14:29,420 --> 00:14:34,100
everything but docto says well it

00:14:32,420 --> 00:14:35,509
depends on that and you rebuilt that so

00:14:34,100 --> 00:14:37,910
now you need to rebuild everything that

00:14:35,509 --> 00:14:39,559
depends on that and the blast radius

00:14:37,910 --> 00:14:42,680
from a change that's high up on that

00:14:39,559 --> 00:14:45,019
depends changes can be quite large I

00:14:42,680 --> 00:14:46,459
think I might have some some ideas on

00:14:45,019 --> 00:14:46,820
how to mitigate that and I'm going to

00:14:46,459 --> 00:14:50,720
take

00:14:46,820 --> 00:14:59,680
to the Yocto bo BOF that's after this

00:14:50,720 --> 00:15:04,010
meeting and finally we ended up with

00:14:59,680 --> 00:15:07,730
some PCI issues that turned out to be

00:15:04,010 --> 00:15:09,740
one of our biggest headaches and it's

00:15:07,730 --> 00:15:13,340
primarily due to the high availability

00:15:09,740 --> 00:15:16,330
requirements of our chassis products the

00:15:13,340 --> 00:15:19,580
core switches the h.a architecture

00:15:16,330 --> 00:15:22,130
requires basically that the modular line

00:15:19,580 --> 00:15:24,590
cards that plug into the backplane have

00:15:22,130 --> 00:15:26,690
to remain up and passing traffic during

00:15:24,590 --> 00:15:29,120
a failover event so if the CPU fails

00:15:26,690 --> 00:15:31,370
from the active to the standby you would

00:15:29,120 --> 00:15:34,460
want to have it continue to pass traffic

00:15:31,370 --> 00:15:36,310
now if you're hunting packets to the CPU

00:15:34,460 --> 00:15:39,140
those of course would get dropped and

00:15:36,310 --> 00:15:43,610
there would be you know recovery from

00:15:39,140 --> 00:15:50,210
that the the failover happens fairly

00:15:43,610 --> 00:15:54,140
rapidly this is a very schematic diagram

00:15:50,210 --> 00:15:55,910
of the PCI architecture in the backplane

00:15:54,140 --> 00:15:57,740
you have an active CPU and you have a

00:15:55,910 --> 00:16:00,680
standby CPU which is powered up and

00:15:57,740 --> 00:16:02,330
keeping synced with all of the the

00:16:00,680 --> 00:16:04,760
changes that are going on on the active

00:16:02,330 --> 00:16:06,950
CPU there's a non-transparent bridge

00:16:04,760 --> 00:16:09,830
that fans out to all the wine cards on

00:16:06,950 --> 00:16:11,990
the backplane the line cards actually

00:16:09,830 --> 00:16:15,020
have another non-transparent bridge on

00:16:11,990 --> 00:16:17,150
them and then that fans out to CPU the

00:16:15,020 --> 00:16:20,990
ASIC and all the all the PCI peripherals

00:16:17,150 --> 00:16:24,080
that are on that and a lot of our our

00:16:20,990 --> 00:16:26,450
problems stemmed from the fact that it

00:16:24,080 --> 00:16:30,080
isn't tested this way in the open-source

00:16:26,450 --> 00:16:32,510
community you know that the usual PCI

00:16:30,080 --> 00:16:34,940
architecture has the route complex on

00:16:32,510 --> 00:16:38,420
the CPU talking to an n transparent

00:16:34,940 --> 00:16:40,430
bridge which then talks to endpoints and

00:16:38,420 --> 00:16:42,410
so non transparent bridge talking to

00:16:40,430 --> 00:16:50,830
another non transparent bridge isn't

00:16:42,410 --> 00:16:53,900
well tested so we had blind cards have a

00:16:50,830 --> 00:16:55,340
fairly underpowered CPU running a

00:16:53,900 --> 00:16:58,430
transport layer on there

00:16:55,340 --> 00:17:00,830
and what we would find is if there was a

00:16:58,430 --> 00:17:04,100
lot of packets being punted at the CPU a

00:17:00,830 --> 00:17:06,730
lot of traffic over the PCI bus the

00:17:04,100 --> 00:17:09,470
transport layer would starve due to

00:17:06,730 --> 00:17:11,959
interrupts the DMA traffic it wasn't so

00:17:09,470 --> 00:17:16,520
much of a PCI bandwidth problem but a

00:17:11,959 --> 00:17:18,290
cpu bandwidth problem dealing with the

00:17:16,520 --> 00:17:20,329
interrupts of that traffic and since the

00:17:18,290 --> 00:17:22,220
interrupts are in the kernel they have a

00:17:20,329 --> 00:17:24,920
higher priority and the transport layer

00:17:22,220 --> 00:17:26,720
would timeout and the management

00:17:24,920 --> 00:17:27,860
software would say oh that blind card is

00:17:26,720 --> 00:17:32,000
it's not working

00:17:27,860 --> 00:17:34,700
and it would reboot it so against that

00:17:32,000 --> 00:17:36,920
problem was we created a fair share of

00:17:34,700 --> 00:17:40,070
rhythm so that transport layer would

00:17:36,920 --> 00:17:44,900
always get some cycles even under IDM a

00:17:40,070 --> 00:17:47,570
traffic loads we ran into a problem

00:17:44,900 --> 00:17:50,840
where PCI drivers on the CPU the main

00:17:47,570 --> 00:17:53,110
CPU would miss interrupts and then you

00:17:50,840 --> 00:17:55,910
know confused it and it would lock up

00:17:53,110 --> 00:17:57,770
this is a known problem that was fixed

00:17:55,910 --> 00:18:00,020
in later kernels but it wasn't fixed

00:17:57,770 --> 00:18:03,140
well enough for our particular PCI

00:18:00,020 --> 00:18:04,970
architecture so we ran we went back to

00:18:03,140 --> 00:18:07,340
just using Coleman rather than their UPS

00:18:04,970 --> 00:18:11,030
and that seemed to fix most of those

00:18:07,340 --> 00:18:14,780
kind of issues the 30s we ran into was

00:18:11,030 --> 00:18:17,870
the active standby failover would cause

00:18:14,780 --> 00:18:19,790
issues the non-transparent bridge on the

00:18:17,870 --> 00:18:23,120
bridges on the line cards would have to

00:18:19,790 --> 00:18:25,660
switch from one CPU to the other the PCI

00:18:23,120 --> 00:18:29,000
drivers just looked really up to that

00:18:25,660 --> 00:18:30,590
and the answer basically is when we

00:18:29,000 --> 00:18:35,150
failover we need to reset all the PCI

00:18:30,590 --> 00:18:36,830
links to the CPU and one of the biggest

00:18:35,150 --> 00:18:40,370
changes that made the most difference

00:18:36,830 --> 00:18:44,320
was changing to using so the BCI driver

00:18:40,370 --> 00:18:46,310
we use Ethernet over PCI driver we

00:18:44,320 --> 00:18:49,460
severely modified the one that's

00:18:46,310 --> 00:18:51,260
available in open source but it made a

00:18:49,460 --> 00:18:53,900
big difference the ethernet protocol is

00:18:51,260 --> 00:18:56,420
is much more forgiving of things like

00:18:53,900 --> 00:18:58,119
changes in link status and switching

00:18:56,420 --> 00:19:02,079
over to a different CPU and that kind

00:18:58,119 --> 00:19:03,819
thing the KISS principle keep it simple

00:19:02,079 --> 00:19:06,999
definitely applied here I mean this

00:19:03,819 --> 00:19:08,889
stuff is very complicated and if you get

00:19:06,999 --> 00:19:13,149
very complicated in your own software

00:19:08,889 --> 00:19:15,519
you're just asking for trouble apologize

00:19:13,149 --> 00:19:19,299
for the speed of that but that's the end

00:19:15,519 --> 00:19:21,309
of my talk so I think we have five

00:19:19,299 --> 00:19:27,989
minutes or so for questions if there are

00:19:21,309 --> 00:19:27,989
any yes

00:19:30,650 --> 00:19:36,200
the question is how difficult is this to

00:19:33,080 --> 00:19:38,030
port this to another platform we're not

00:19:36,200 --> 00:19:40,910
finding it terribly difficult I mean it

00:19:38,030 --> 00:19:44,260
depends on on how different the platform

00:19:40,910 --> 00:19:46,840
is you know we've recently started using

00:19:44,260 --> 00:19:50,630
like I said a different architecture

00:19:46,840 --> 00:19:55,340
which you know causes a whole raft of

00:19:50,630 --> 00:19:57,350
issues but it's it's manageable so I

00:19:55,340 --> 00:20:00,800
don't know in terms of difficulty yeah

00:19:57,350 --> 00:20:02,660
there's putting a new platform in aside

00:20:00,800 --> 00:20:04,309
from from actually designing the

00:20:02,660 --> 00:20:08,230
hardware of it you know just the

00:20:04,309 --> 00:20:08,230
software changes a few months

00:20:16,120 --> 00:20:25,929
yes um that's not too terribly difficult

00:20:21,880 --> 00:20:28,210
than our experience there's there's you

00:20:25,929 --> 00:20:30,010
know a bit of interface issues but it's

00:20:28,210 --> 00:20:31,990
it's fairly straightforward if you have

00:20:30,010 --> 00:20:35,860
a working you know booting hardware

00:20:31,990 --> 00:20:39,520
platform and kernel then you know the

00:20:35,860 --> 00:20:42,010
the Heylin configuration so in the in

00:20:39,520 --> 00:20:44,020
the in the Halon layer and then in the

00:20:42,010 --> 00:20:46,870
meta distro you know it has all of the

00:20:44,020 --> 00:20:50,230
kernel configurations so we use CFG

00:20:46,870 --> 00:20:53,860
files and SEC files and so it brings in

00:20:50,230 --> 00:20:55,840
the Halon configuration on top of the

00:20:53,860 --> 00:20:57,730
layers that you know you just you know

00:20:55,840 --> 00:21:00,730
you quote you concentrate your your

00:20:57,730 --> 00:21:02,770
layer on the architecture and things

00:21:00,730 --> 00:21:04,299
that you need for your peripherals and

00:21:02,770 --> 00:21:06,610
things that you have in the hardware and

00:21:04,299 --> 00:21:10,720
then the Halon layer brings in the other

00:21:06,610 --> 00:21:12,190
pieces that are needed for the nas so

00:21:10,720 --> 00:21:13,799
from a kernels perspective it's it's

00:21:12,190 --> 00:21:17,710
fairly straightforward

00:21:13,799 --> 00:21:21,659
you know there's testing you know of

00:21:17,710 --> 00:21:24,700
course there's always issues regarding

00:21:21,659 --> 00:21:30,570
integrating new tests into the CIT and

00:21:24,700 --> 00:21:30,570
infrastructure anybody else

00:21:44,010 --> 00:21:47,870
so you talk about Colonel configuration

00:21:52,820 --> 00:22:00,170
so we use the k config database for

00:21:56,360 --> 00:22:02,270
configuring the actual Halon nas and so

00:22:00,170 --> 00:22:05,030
you know that's that's a very well

00:22:02,270 --> 00:22:07,100
understood so all of all the network

00:22:05,030 --> 00:22:09,980
configuration stuff is encapsulated in a

00:22:07,100 --> 00:22:13,670
menu config kind of thing that that you

00:22:09,980 --> 00:22:15,830
bring in those default configs and you

00:22:13,670 --> 00:22:17,390
can bring in custom configs of those

00:22:15,830 --> 00:22:19,040
halo and configs and then the software

00:22:17,390 --> 00:22:23,720
when it's built it takes all those

00:22:19,040 --> 00:22:26,200
config things into consideration other

00:22:23,720 --> 00:22:26,200
questions

00:22:28,980 --> 00:22:36,350
well thank you sorry about the delay

00:22:32,350 --> 00:22:36,350

YouTube URL: https://www.youtube.com/watch?v=BZTBO6aMjmc


