Title: Developing the RISC-V Hypervisor Extensions in QEMU - Alistair Francis, Western Digital
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Developing the RISC-V Hypervisor Extensions in QEMU - Alistair Francis, Western Digital

In this presentation Alistair will talk about the work he and his colleagues did to add the RISC-V Hypervisor Extension support to QEMU. This allows everyone to use QEMU as a development platform for porting Hypervisors to RISC-V.

He will discuss how the RISC-V Hypervisor extension works and how it is different to other common architectures Hypervisor support. He will also talk about how the extension was implemented in QEMU and problems that were identified with the draft specification in the process. Finally he will conclude with the current upstream status and any pending work related to both QEMU and the RISC-V Hypervisor specification in general, he will also cover Hypervisor project porting status.
Captions: 
	00:00:00,030 --> 00:00:06,299
Hey all right so it's good and quiet so

00:00:02,879 --> 00:00:08,340
single start so my name is Alastair and

00:00:06,299 --> 00:00:11,160
I work for Western Digital as part of

00:00:08,340 --> 00:00:13,440
the research and development team so my

00:00:11,160 --> 00:00:15,839
colleagues and I focus on risk five and

00:00:13,440 --> 00:00:17,430
the Linux ecosystem and today I'm here

00:00:15,839 --> 00:00:21,869
to talk about developing the risk five

00:00:17,430 --> 00:00:23,640
hypervisor extensions in qmu so I'll

00:00:21,869 --> 00:00:25,109
start with what a hypervisor is quickly

00:00:23,640 --> 00:00:27,210
and why we use them and why they're

00:00:25,109 --> 00:00:29,519
exciting then I'll talk about the risk

00:00:27,210 --> 00:00:32,430
by of - visor spec at the current status

00:00:29,519 --> 00:00:34,170
and details about it they'll go over the

00:00:32,430 --> 00:00:36,750
current risk by hypervisors that exist

00:00:34,170 --> 00:00:39,210
the queue implementation the kimmy

00:00:36,750 --> 00:00:40,559
future work improvements to the draft

00:00:39,210 --> 00:00:43,559
spec that came out of all this

00:00:40,559 --> 00:00:45,180
at least from the Q side the overall

00:00:43,559 --> 00:00:50,340
current status and then if we have time

00:00:45,180 --> 00:00:52,230
a demo in questions so what a hypervisor

00:00:50,340 --> 00:00:54,390
is a hypervisor allows you to run

00:00:52,230 --> 00:00:57,300
virtual machines so compared to

00:00:54,390 --> 00:00:59,850
containers a hypervisor is a full OS so

00:00:57,300 --> 00:01:03,030
you run a kernel and full user space

00:00:59,850 --> 00:01:04,860
inside in your virtual machines and

00:01:03,030 --> 00:01:08,340
extremely common in the enterprise world

00:01:04,860 --> 00:01:10,439
so cloud companies use them AWS as all

00:01:08,340 --> 00:01:12,510
of that stuff all runs on hypervisors it

00:01:10,439 --> 00:01:14,460
allows you to share machines and and do

00:01:12,510 --> 00:01:17,310
fancy to save restore migration or what

00:01:14,460 --> 00:01:19,710
type of stuff operating system uses use

00:01:17,310 --> 00:01:21,659
them so in the Microsoft world there's

00:01:19,710 --> 00:01:24,479
they have edge defender which they used

00:01:21,659 --> 00:01:26,430
to protect browsers and cubes is the

00:01:24,479 --> 00:01:29,240
famous open source one that's based on

00:01:26,430 --> 00:01:31,890
Zen and allows you to partition

00:01:29,240 --> 00:01:34,320
basically applications and protect

00:01:31,890 --> 00:01:36,390
against different types of tax they also

00:01:34,320 --> 00:01:40,049
used in consumer products so the Xbox

00:01:36,390 --> 00:01:41,899
one is based on a hypervisor and uses

00:01:40,049 --> 00:01:45,060
that to handle game switching and things

00:01:41,899 --> 00:01:46,860
so they're big in the enterprise and the

00:01:45,060 --> 00:01:49,729
big x86 world but it also big and

00:01:46,860 --> 00:01:52,649
embedded they used to process isolation

00:01:49,729 --> 00:01:55,500
in security at critical applications and

00:01:52,649 --> 00:01:59,640
they also used to run multiple legacy

00:01:55,500 --> 00:02:01,710
OSS so the famous example of this is you

00:01:59,640 --> 00:02:03,899
say have a car and you have five chips

00:02:01,710 --> 00:02:05,909
that used to do breaks and power

00:02:03,899 --> 00:02:08,160
steering and infotainment and all these

00:02:05,909 --> 00:02:12,030
things and you can consolidate down into

00:02:08,160 --> 00:02:13,400
one CPU core a big SOC split it'll pin

00:02:12,030 --> 00:02:15,500
your brakes to one core

00:02:13,400 --> 00:02:17,200
so it's always running pin your steering

00:02:15,500 --> 00:02:19,540
to another and then run everything else

00:02:17,200 --> 00:02:21,349
between all your other cause to do

00:02:19,540 --> 00:02:23,450
entertainment and communications and

00:02:21,349 --> 00:02:25,940
whatever else you want to do to cut

00:02:23,450 --> 00:02:28,000
costs and simplify things so I glasses

00:02:25,940 --> 00:02:30,769
are used everywhere all over the place

00:02:28,000 --> 00:02:33,440
and Suzanne and KVM are the two

00:02:30,769 --> 00:02:35,720
well-known open source ones about GPL

00:02:33,440 --> 00:02:37,250
with lots of talks here about kam

00:02:35,720 --> 00:02:40,250
especially because there's a KVM forum

00:02:37,250 --> 00:02:42,290
and expose there's another relatively

00:02:40,250 --> 00:02:44,329
new hypervisor it's also GPL it's open

00:02:42,290 --> 00:02:47,840
source and I'll go into loop for more

00:02:44,329 --> 00:02:51,290
details about that later so the wrist

00:02:47,840 --> 00:02:53,569
fire extension status I'm not going to

00:02:51,290 --> 00:02:56,390
talk too much about the wrist 5 spec in

00:02:53,569 --> 00:02:58,430
general just that the way it works is

00:02:56,390 --> 00:03:00,049
you have kind of a base spec and you add

00:02:58,430 --> 00:03:02,540
extensions on top based on where you're

00:03:00,049 --> 00:03:04,609
interested in and the risk 5 hypervisor

00:03:02,540 --> 00:03:07,430
extension the virtualization extension

00:03:04,609 --> 00:03:09,440
is an extra extension on top of that so

00:03:07,430 --> 00:03:14,150
it's designed to support both bare metal

00:03:09,440 --> 00:03:16,370
and hosted hypervisors and the 0.4 draft

00:03:14,150 --> 00:03:19,700
was released one about four months ago

00:03:16,370 --> 00:03:22,370
isn't it and so it's a draft so drop

00:03:19,700 --> 00:03:24,859
spec means that it's gonna change so if

00:03:22,370 --> 00:03:26,870
you implemented this today don't expect

00:03:24,859 --> 00:03:29,060
it to keep working when the next version

00:03:26,870 --> 00:03:30,739
comes out eventually it'll be frozen or

00:03:29,060 --> 00:03:33,079
ratified and then there's guarantees

00:03:30,739 --> 00:03:35,260
about backwards compatibility and all

00:03:33,079 --> 00:03:38,060
that stuff but draft it means it's not

00:03:35,260 --> 00:03:39,440
additions have happened since then but

00:03:38,060 --> 00:03:41,720
generally today while I'm talking about

00:03:39,440 --> 00:03:43,579
is the 0.4 version just because that's

00:03:41,720 --> 00:03:45,230
what all the software is using because

00:03:43,579 --> 00:03:48,590
it's too hard to keep updating every

00:03:45,230 --> 00:03:51,169
time one commit changes in the spec so

00:03:48,590 --> 00:03:54,349
Western Digital ported key mu-x visor

00:03:51,169 --> 00:03:56,510
and KVM on the 0.3 version of the spec

00:03:54,349 --> 00:03:57,739
which is the previous one we're since

00:03:56,510 --> 00:04:00,560
I've dated everything and we're now

00:03:57,739 --> 00:04:06,290
using the latest the 0.4 version and

00:04:00,560 --> 00:04:10,280
we'll update from there to sir and the

00:04:06,290 --> 00:04:12,620
actual details so in the risk 5 world we

00:04:10,280 --> 00:04:15,260
have these privilege modes so normally

00:04:12,620 --> 00:04:17,539
we have just m/s and new so this is your

00:04:15,260 --> 00:04:19,810
firmware your operating system and your

00:04:17,539 --> 00:04:19,810
user

00:04:20,060 --> 00:04:26,180
it's kind of like l3l one and heals your

00:04:23,300 --> 00:04:29,150
enamel with the risk v hypervisor

00:04:26,180 --> 00:04:32,720
extension it changes to this so we kind

00:04:29,150 --> 00:04:35,030
of partition the s in the year so you

00:04:32,720 --> 00:04:37,220
can see here the firmware the way you

00:04:35,030 --> 00:04:38,690
run open spi in the machine mode that

00:04:37,220 --> 00:04:41,870
doesn't change you don't virtualize your

00:04:38,690 --> 00:04:43,820
firmware in the next step is your HS

00:04:41,870 --> 00:04:46,160
where you run your supervisor where you

00:04:43,820 --> 00:04:48,200
run your hypervisor the key thing here

00:04:46,160 --> 00:04:50,419
though is if you had a hypervisor

00:04:48,200 --> 00:04:52,070
extension in your hardware and you

00:04:50,419 --> 00:04:53,330
wanted and you didn't want to do didn't

00:04:52,070 --> 00:04:55,220
care a hypervisor you didn't want to use

00:04:53,330 --> 00:04:57,919
it and your kernel didn't support it

00:04:55,220 --> 00:05:00,110
you could run an unmodified kernel in HS

00:04:57,919 --> 00:05:01,850
you don't have to update your kernel to

00:05:00,110 --> 00:05:03,800
handle the hypervisor extension if you

00:05:01,850 --> 00:05:05,510
don't want to use it so you can just

00:05:03,800 --> 00:05:07,460
keep running it there you're going to

00:05:05,510 --> 00:05:10,190
use the space in new mode and in the

00:05:07,460 --> 00:05:11,840
future you could update your operating

00:05:10,190 --> 00:05:14,419
system to add support for the hypervisor

00:05:11,840 --> 00:05:17,600
spec so you don't have to have weird

00:05:14,419 --> 00:05:19,010
hooks to hook back but if you do want to

00:05:17,600 --> 00:05:21,560
use a hypervisor spec and you do want to

00:05:19,010 --> 00:05:24,169
run hypervisors you run a HS your

00:05:21,560 --> 00:05:25,460
hypervisor user space runs in you so in

00:05:24,169 --> 00:05:28,460
the in the risk 5 where we say the

00:05:25,460 --> 00:05:30,680
virtualization saw for V equals 0 and

00:05:28,460 --> 00:05:32,840
then your guest run in this V mode it's

00:05:30,680 --> 00:05:37,940
virtualization on guess Linux and guest

00:05:32,840 --> 00:05:41,030
user space so on top of that we have

00:05:37,940 --> 00:05:42,530
these new CSRs so CSR as a the risk 5

00:05:41,030 --> 00:05:45,350
way of controlling everything control

00:05:42,530 --> 00:05:49,910
via CPUs doing the code control status

00:05:45,350 --> 00:05:52,340
registers and so they normally prefixed

00:05:49,910 --> 00:05:54,919
by the letter of the privilege so s

00:05:52,340 --> 00:05:57,620
status is the status control register

00:05:54,919 --> 00:06:01,130
for s mode for your operating system M

00:05:57,620 --> 00:06:02,419
status is for the machine mode so when

00:06:01,130 --> 00:06:04,580
you're in your hypervisor on

00:06:02,419 --> 00:06:06,680
virtualizations off you have these new

00:06:04,580 --> 00:06:08,030
ones so all your S ones are still there

00:06:06,680 --> 00:06:09,169
they're all unchanged you can use them

00:06:08,030 --> 00:06:11,720
as you always did you can run an

00:06:09,169 --> 00:06:14,360
unmodified operating system but now you

00:06:11,720 --> 00:06:15,650
have these HS so HS is for the

00:06:14,360 --> 00:06:18,729
hypervisor things to control the

00:06:15,650 --> 00:06:20,810
hypervisor status for the hypervisor

00:06:18,729 --> 00:06:23,020
second-stage translation for your to

00:06:20,810 --> 00:06:25,400
stage MMU I'll talk about that next

00:06:23,020 --> 00:06:26,690
delegation settings for your guests

00:06:25,400 --> 00:06:29,300
things like that things that a

00:06:26,690 --> 00:06:32,510
hypervisor needs to do but now you have

00:06:29,300 --> 00:06:36,260
these vs and this is a weird one

00:06:32,510 --> 00:06:39,200
so vs is the virtual copy of the guest s

00:06:36,260 --> 00:06:40,730
status press registers so you have all

00:06:39,200 --> 00:06:43,790
these copies you can you can see them on

00:06:40,730 --> 00:06:47,360
the slide so vs status is the guest

00:06:43,790 --> 00:06:50,420
status status and when you transition

00:06:47,360 --> 00:06:53,300
from hyper biased or virtualized to not

00:06:50,420 --> 00:06:56,360
virtualized the hardware will alias the

00:06:53,300 --> 00:06:57,590
s register to the vs register so when

00:06:56,360 --> 00:06:59,660
you're running in your guests your

00:06:57,590 --> 00:07:02,510
guests will access the s status register

00:06:59,660 --> 00:07:06,050
but in hardware that will transparently

00:07:02,510 --> 00:07:07,730
access the vs status register and the

00:07:06,050 --> 00:07:10,460
guest then can't edit the hypervisor

00:07:07,730 --> 00:07:13,430
status or the hypervisor HS registers

00:07:10,460 --> 00:07:15,230
then when you swap back the hardware

00:07:13,430 --> 00:07:16,880
automatically swap them back or in this

00:07:15,230 --> 00:07:19,250
case Jim you'll swap them for you but

00:07:16,880 --> 00:07:21,650
the hardware will handle swapping vs and

00:07:19,250 --> 00:07:22,880
s status accordingly and it's actually

00:07:21,650 --> 00:07:28,160
one of the hardest things to implement

00:07:22,880 --> 00:07:31,100
in CHEM you it gets kind of tricky so a

00:07:28,160 --> 00:07:32,900
two stage MMU so one of the general

00:07:31,100 --> 00:07:35,990
things a hypervisor extensions do in

00:07:32,900 --> 00:07:39,170
hardware is you have true stage of MMU

00:07:35,990 --> 00:07:40,670
so the first one is for your guest and

00:07:39,170 --> 00:07:41,900
when virtualization is on there's only

00:07:40,670 --> 00:07:42,320
applies when you're running inside of

00:07:41,900 --> 00:07:44,780
guest

00:07:42,320 --> 00:07:46,910
so the first one translates your guest

00:07:44,780 --> 00:07:48,800
virtual address to your guest physical

00:07:46,910 --> 00:07:50,990
address this is controlled by your guest

00:07:48,800 --> 00:07:52,970
kernel with Linux or whatever it is and

00:07:50,990 --> 00:07:54,050
it sets it up as it always would it

00:07:52,970 --> 00:07:55,760
doesn't have to know that it's

00:07:54,050 --> 00:07:58,580
hypervisor it just does whatever

00:07:55,760 --> 00:08:01,190
wouldn't normally do the second stage is

00:07:58,580 --> 00:08:03,410
run by the hypervisor so it sets this up

00:08:01,190 --> 00:08:05,210
and that does your guest physical

00:08:03,410 --> 00:08:07,310
address to your host physical address

00:08:05,210 --> 00:08:09,140
and the hypervisor will set this up

00:08:07,310 --> 00:08:12,290
differently for different guests and and

00:08:09,140 --> 00:08:16,460
it will manage it to map it to physical

00:08:12,290 --> 00:08:19,490
memory this follows the if anyone knows

00:08:16,460 --> 00:08:21,200
the risk 5 hypervisor risk 5 mm you

00:08:19,490 --> 00:08:23,300
stuff it basically follows the same

00:08:21,200 --> 00:08:26,000
things it's the standard format the SP

00:08:23,300 --> 00:08:29,000
32 or 39 or 48 depending on your bit

00:08:26,000 --> 00:08:31,070
lengths and things and it just kind of

00:08:29,000 --> 00:08:33,140
loops the stage through twice so it's

00:08:31,070 --> 00:08:35,300
not that much reimplementation you don't

00:08:33,140 --> 00:08:37,340
have like a whole new page table walker

00:08:35,300 --> 00:08:39,470
and and all this stuff it kind of loops

00:08:37,340 --> 00:08:41,030
it through there are some differences

00:08:39,470 --> 00:08:43,280
which I'll talk about in implementation

00:08:41,030 --> 00:08:45,190
that to make it not that trivial but

00:08:43,280 --> 00:08:49,700
it's not that hub

00:08:45,190 --> 00:08:51,589
and iron interrupts sir before anyone

00:08:49,700 --> 00:08:54,050
asks later the respite hypervisor

00:08:51,589 --> 00:08:57,200
extension does not have virtualized

00:08:54,050 --> 00:08:59,890
interrupts or an iommu it's not specked

00:08:57,200 --> 00:09:03,140
out there and there's no implementations

00:08:59,890 --> 00:09:04,580
well at least publicly and sir the

00:09:03,140 --> 00:09:07,250
interrupts are injected from the

00:09:04,580 --> 00:09:12,290
hypervisor to the guest using the VSIP

00:09:07,250 --> 00:09:14,839
so sip s IP CSR is the interrupts ending

00:09:12,290 --> 00:09:15,740
for the OS the VSIP is your guest

00:09:14,839 --> 00:09:17,899
interim

00:09:15,740 --> 00:09:20,180
so the hypervisor writes into the guest

00:09:17,899 --> 00:09:21,709
interrupts pending then transitions to

00:09:20,180 --> 00:09:24,920
the guest and the guest then gets an

00:09:21,709 --> 00:09:26,959
interrupt from the intra pending this

00:09:24,920 --> 00:09:29,720
the hypervisor is in charge of emulating

00:09:26,959 --> 00:09:33,470
spi calls SBI is is kind of like the

00:09:29,720 --> 00:09:34,910
risk of five equivalent of PSC I it does

00:09:33,470 --> 00:09:36,230
lots of different things but the

00:09:34,910 --> 00:09:39,800
hypervisor is in charge of handling that

00:09:36,230 --> 00:09:42,320
and the hypervisor can also use the true

00:09:39,800 --> 00:09:45,020
state genu to trap and emulate MMI or

00:09:42,320 --> 00:09:46,459
accesses and this allows you to tell the

00:09:45,020 --> 00:09:47,720
guest there's a UART when it's not

00:09:46,459 --> 00:09:49,670
really anything there and when they

00:09:47,720 --> 00:09:51,230
access it you trap-trap into the

00:09:49,670 --> 00:09:52,880
hypervisor the hypervisor sees what's

00:09:51,230 --> 00:09:58,970
going on and pretends to be you out or

00:09:52,880 --> 00:10:01,160
something and so quickly just comparing

00:09:58,970 --> 00:10:03,950
it to a out 64 which is kind of a

00:10:01,160 --> 00:10:05,930
similar concept if anyone knows that

00:10:03,950 --> 00:10:08,480
there's no separate privileged minority

00:10:05,930 --> 00:10:11,810
in the risk v hypervisor unlike a out 64

00:10:08,480 --> 00:10:13,400
which has yield 2 so this means there is

00:10:11,810 --> 00:10:15,740
five hypervisor suits really well for

00:10:13,400 --> 00:10:17,630
both type 1 and type 2 hypervisors but

00:10:15,740 --> 00:10:21,170
you don't have to track back down to

00:10:17,630 --> 00:10:25,430
like a previous level it just kind of

00:10:21,170 --> 00:10:28,430
splits the lesson new modes the risk 5

00:10:25,430 --> 00:10:29,900
also can use virtual interrupts you can

00:10:28,430 --> 00:10:32,060
inject them into CSR like I just talked

00:10:29,900 --> 00:10:33,110
about with the fit or the VSIP csr so

00:10:32,060 --> 00:10:35,930
you don't have to have virtualized

00:10:33,110 --> 00:10:37,820
interrupt support the risk 5 hypervisor

00:10:35,930 --> 00:10:40,670
extension also has support for nested

00:10:37,820 --> 00:10:44,600
type of nested virtualization so you can

00:10:40,670 --> 00:10:46,310
use V T vm and DTS are to trap into the

00:10:44,600 --> 00:10:47,899
hypervisor on certain operations and

00:10:46,310 --> 00:10:51,050
this allows you to do nested although

00:10:47,899 --> 00:10:54,220
that hasn't been done yet and the last

00:10:51,050 --> 00:11:00,480
one you can use spi

00:10:54,220 --> 00:11:03,220
do timers and interrupts so as to ported

00:11:00,480 --> 00:11:05,830
hypervisors that support the risk by

00:11:03,220 --> 00:11:09,700
hypervisor extension and these are

00:11:05,830 --> 00:11:13,390
expires and KVM so XYZ is a is a

00:11:09,700 --> 00:11:15,100
monolithic bare-metal hypervisor the

00:11:13,390 --> 00:11:17,530
nice thing about exercise is it has no

00:11:15,100 --> 00:11:20,620
requirement on linux so k vm obviously

00:11:17,530 --> 00:11:22,690
requires linux and then at least until

00:11:20,620 --> 00:11:25,450
kind of recently requires Linux as well

00:11:22,690 --> 00:11:26,830
so X bar can boot up straight to a

00:11:25,450 --> 00:11:29,080
prompt and then you can start to guess

00:11:26,830 --> 00:11:31,090
from that this made it simpler to port

00:11:29,080 --> 00:11:34,390
the extensions as well my colleagues are

00:11:31,090 --> 00:11:37,120
telling me we could Co develop the emu

00:11:34,390 --> 00:11:38,170
and expires at the same time as we were

00:11:37,120 --> 00:11:40,270
both working on them and can test

00:11:38,170 --> 00:11:41,980
against each other so when I colleagues

00:11:40,270 --> 00:11:43,420
as a talk on expires of tomorrow if

00:11:41,980 --> 00:11:44,050
anyone wants to hear more details about

00:11:43,420 --> 00:11:46,570
how it works

00:11:44,050 --> 00:11:48,190
and if you want to use the risk 5 work

00:11:46,570 --> 00:11:50,050
you have to go to the X Y as a next

00:11:48,190 --> 00:11:54,340
branch it hasn't made into the master

00:11:50,050 --> 00:11:56,200
branch yet and KVM KVM is the kernel

00:11:54,340 --> 00:11:59,020
module for the linux kernel that turns

00:11:56,200 --> 00:12:01,060
linux kernel into a hypervisor there's

00:11:59,020 --> 00:12:02,290
lots of stuff about KVM this week KPM

00:12:01,060 --> 00:12:04,720
forums on at the end of the week and

00:12:02,290 --> 00:12:08,050
there's a talk with a colleague and

00:12:04,720 --> 00:12:11,470
myself on Wednesday about same thing q

00:12:08,050 --> 00:12:13,900
in KVM everyone's interested there's a

00:12:11,470 --> 00:12:17,130
github link for KVM I'll talk more at

00:12:13,900 --> 00:12:19,660
the end about the status of the patches

00:12:17,130 --> 00:12:21,730
so just to give you another idea this is

00:12:19,660 --> 00:12:24,970
what a bare-metal hypervisor looks like

00:12:21,730 --> 00:12:27,340
on on risk 5 so your machine mode your

00:12:24,970 --> 00:12:30,910
open spi runs in your M mode then your

00:12:27,340 --> 00:12:33,100
hypervisor runs at HS mode inside and on

00:12:30,910 --> 00:12:36,280
top of that your guest kernels running

00:12:33,100 --> 00:12:38,070
vs and bu mode so I think I've explained

00:12:36,280 --> 00:12:41,350
a lot of that already

00:12:38,070 --> 00:12:43,750
and KVM looks a little different so

00:12:41,350 --> 00:12:46,000
again your firmware and M mode your host

00:12:43,750 --> 00:12:48,820
Linux kernel with the k vm module can

00:12:46,000 --> 00:12:50,920
run in HS mode then you're Kim you or k

00:12:48,820 --> 00:12:52,570
vm tool or whatever you're using friends

00:12:50,920 --> 00:12:54,850
a new mode and that's part of

00:12:52,570 --> 00:12:56,830
virtualization off and then your guest

00:12:54,850 --> 00:12:59,710
kernel and guest user space running vs

00:12:56,830 --> 00:13:03,210
and the mode so this is different to

00:12:59,710 --> 00:13:03,210
other architectures

00:13:05,190 --> 00:13:11,769
so talk about implementing Kim you what

00:13:08,649 --> 00:13:15,990
is Kim you it's very quick very quick

00:13:11,769 --> 00:13:19,389
open-source emulator so it uses TCG to

00:13:15,990 --> 00:13:20,949
translate a host or guests instruction

00:13:19,389 --> 00:13:24,850
into a host instruction this allows you

00:13:20,949 --> 00:13:26,680
to run risk 5 operating systems binaries

00:13:24,850 --> 00:13:29,860
everything on whatever architecture you

00:13:26,680 --> 00:13:31,990
want Kim use not cycle accurate it's not

00:13:29,860 --> 00:13:33,430
a like a simulation platform

00:13:31,990 --> 00:13:34,750
it's an emulation platform so it's

00:13:33,430 --> 00:13:36,760
functionally at grew up in on cycle

00:13:34,750 --> 00:13:38,730
accurate doesn't pretend to have a

00:13:36,760 --> 00:13:41,860
pipeline and caches and all these things

00:13:38,730 --> 00:13:42,910
this allows it to be really quick it's

00:13:41,860 --> 00:13:44,470
not written in maintained by a single

00:13:42,910 --> 00:13:45,490
company it's a bigger business project

00:13:44,470 --> 00:13:47,620
there's a whole lot of Kim you

00:13:45,490 --> 00:13:48,880
developers here this week especially for

00:13:47,620 --> 00:13:52,180
the KVM forum at the end of the week

00:13:48,880 --> 00:13:53,829
it's GPL has a great mailing list all

00:13:52,180 --> 00:13:56,529
that stuff so it's a great platform to

00:13:53,829 --> 00:14:01,149
use to develop and both the extension

00:13:56,529 --> 00:14:03,190
and software on top of the extension so

00:14:01,149 --> 00:14:04,810
the current kami invitation patches on

00:14:03,190 --> 00:14:08,800
the list everything we do is a resource

00:14:04,810 --> 00:14:10,600
we not gonna keep it it supports both 32

00:14:08,800 --> 00:14:13,540
and 64-bit RISC FIRE Firefighters

00:14:10,600 --> 00:14:15,160
extensions all the CSR's including

00:14:13,540 --> 00:14:17,620
swapping the CSRs I talked about earlier

00:14:15,160 --> 00:14:18,459
the interrupts are generated correctly

00:14:17,620 --> 00:14:20,380
to the hypervisor

00:14:18,459 --> 00:14:23,110
which can then delegate them to the

00:14:20,380 --> 00:14:24,760
guest OS s floating point is correctly

00:14:23,110 --> 00:14:26,320
controlled the hypervisor can disabled

00:14:24,760 --> 00:14:28,300
guest floating point and we handle that

00:14:26,320 --> 00:14:30,970
and the through stage and I'm you is

00:14:28,300 --> 00:14:33,550
fully supported so they the patches on

00:14:30,970 --> 00:14:35,620
list and emerged but once they are they

00:14:33,550 --> 00:14:37,449
expect it to be the hypervisor extension

00:14:35,620 --> 00:14:39,640
will still be disabled by default so

00:14:37,449 --> 00:14:41,230
it's a drop spec we don't wanna turn it

00:14:39,640 --> 00:14:43,149
on for everyone and have it change

00:14:41,230 --> 00:14:45,399
versions and all these things so you

00:14:43,149 --> 00:14:50,170
have to enable it with this this - GPU

00:14:45,399 --> 00:14:52,690
option Navi 64 then X - H equals true so

00:14:50,170 --> 00:14:56,170
X - is just a standard key mu way of

00:14:52,690 --> 00:14:57,579
saying it's experimental you don't rely

00:14:56,170 --> 00:14:59,500
on this feature to still be there next

00:14:57,579 --> 00:15:01,389
release exactly the same it's it's gonna

00:14:59,500 --> 00:15:03,699
change and the H is just hypervisor

00:15:01,389 --> 00:15:05,860
extensions you can turn it on and off so

00:15:03,699 --> 00:15:07,449
the patches on the on list so you can

00:15:05,860 --> 00:15:09,279
apply them from there or if you want a

00:15:07,449 --> 00:15:11,290
branch there's a link there for the

00:15:09,279 --> 00:15:13,340
branch I think if you just search like

00:15:11,290 --> 00:15:17,750
risk 5 emu

00:15:13,340 --> 00:15:19,040
we come so some things have already I've

00:15:17,750 --> 00:15:22,340
already gone in it had to be made in

00:15:19,040 --> 00:15:24,560
preparation to Kim you so the MIT CSR

00:15:22,340 --> 00:15:26,960
which is the overall global pending

00:15:24,560 --> 00:15:29,630
interrupts CSR used to be updated

00:15:26,960 --> 00:15:31,820
atomically this is because you have your

00:15:29,630 --> 00:15:34,700
CPU running but other CPUs could

00:15:31,820 --> 00:15:36,860
generate IP is into your CPU and you

00:15:34,700 --> 00:15:38,060
didn't want it just changing being it

00:15:36,860 --> 00:15:40,910
not being overwritten and information

00:15:38,060 --> 00:15:43,490
being lost updating that atomically is a

00:15:40,910 --> 00:15:46,820
real pain when you're swapping your

00:15:43,490 --> 00:15:49,880
registers all the time so you it just

00:15:46,820 --> 00:15:51,380
gets a headache and and prone to bugs so

00:15:49,880 --> 00:15:53,030
instead we update it to lock the ire

00:15:51,380 --> 00:15:55,130
thread if I never knows Kimmy

00:15:53,030 --> 00:15:57,620
implantation that's a standard Thank You

00:15:55,130 --> 00:15:59,090
meters you lock the i/o thread sir you

00:15:57,620 --> 00:16:02,450
know no one else is gonna come and

00:15:59,090 --> 00:16:04,190
change your stats we last of the is a

00:16:02,450 --> 00:16:06,200
extensions by the command line like I

00:16:04,190 --> 00:16:08,660
just talked about that's important so we

00:16:06,200 --> 00:16:10,340
could disable it by default it's also

00:16:08,660 --> 00:16:12,740
useful for other extensions as they come

00:16:10,340 --> 00:16:14,150
in so talk about vector extensions now

00:16:12,740 --> 00:16:15,560
for example and cami so this will be

00:16:14,150 --> 00:16:18,610
useful for those too because it also

00:16:15,560 --> 00:16:23,200
dropped and the some floating-point

00:16:18,610 --> 00:16:23,200
consolidation to try and simplify that

00:16:23,590 --> 00:16:28,100
so um you we have to maintain the

00:16:26,090 --> 00:16:31,300
hypervisor state we have to know if

00:16:28,100 --> 00:16:33,920
we're virtualized now and if we're not

00:16:31,300 --> 00:16:36,020
so this isn't that hard to do we only

00:16:33,920 --> 00:16:38,930
you know state only changes on traps or

00:16:36,020 --> 00:16:40,850
turns so it's there's only a handful of

00:16:38,930 --> 00:16:42,950
places to change it could change and and

00:16:40,850 --> 00:16:45,170
we know what they're going to be the

00:16:42,950 --> 00:16:49,400
problem is is that the risk 5 -

00:16:45,170 --> 00:16:51,560
extension allows em and HS mode to

00:16:49,400 --> 00:16:53,240
pretend to be virtualized so you can do

00:16:51,560 --> 00:16:55,130
loads and stores through the second

00:16:53,240 --> 00:16:56,300
stage the to say generate you and I'll

00:16:55,130 --> 00:16:59,030
talk about this on the next slide when I

00:16:56,300 --> 00:17:01,790
talk about the enemy so human needs to

00:16:59,030 --> 00:17:03,650
know if this is happening to then decide

00:17:01,790 --> 00:17:05,990
if we're gonna run those accesses

00:17:03,650 --> 00:17:08,600
through a to say sure I'm you and the

00:17:05,990 --> 00:17:10,760
other weird thing is that certain faults

00:17:08,600 --> 00:17:14,870
can never be delegated so no matter what

00:17:10,760 --> 00:17:15,830
your delegation settings are for like if

00:17:14,870 --> 00:17:17,540
you should go to the guest of the

00:17:15,830 --> 00:17:19,520
hypervisor on certain events they're

00:17:17,540 --> 00:17:21,440
just ignored and you have to track to

00:17:19,520 --> 00:17:23,930
the hypervisor it's like a two stage in

00:17:21,440 --> 00:17:26,030
memory failure in the second stage has

00:17:23,930 --> 00:17:26,959
to trap to the hypervisor and so in Kim

00:17:26,030 --> 00:17:28,100
you well we keep

00:17:26,959 --> 00:17:30,620
track of this as part of the

00:17:28,100 --> 00:17:32,299
virtualization state and if anyone ever

00:17:30,620 --> 00:17:35,240
looks at the code is interested we use

00:17:32,299 --> 00:17:37,580
this force HS exempt and we have helped

00:17:35,240 --> 00:17:39,470
us to set and read that and that allows

00:17:37,580 --> 00:17:43,970
you to forcefully trap into the

00:17:39,470 --> 00:17:45,740
hypervisor so the two-stage enemy so

00:17:43,970 --> 00:17:47,390
when you're virtualized the two SH M mu

00:17:45,740 --> 00:17:49,100
is always bond you can do one-to-one

00:17:47,390 --> 00:17:52,090
mapping if you don't use it but it's

00:17:49,100 --> 00:17:52,090
always gonna be two stages

00:17:52,130 --> 00:17:56,000
but the true stages can be turned on

00:17:54,080 --> 00:17:57,830
even when virtualization is off so

00:17:56,000 --> 00:18:00,740
that's why I just talked about so if the

00:17:57,830 --> 00:18:03,350
idea for this is that if you trap into

00:18:00,740 --> 00:18:04,549
the hypervisor or your firmware and your

00:18:03,350 --> 00:18:06,950
firmware or hypervisor I want to know

00:18:04,549 --> 00:18:09,559
what caused the trap they can turn the

00:18:06,950 --> 00:18:11,120
two stage MMU on which only applies to

00:18:09,559 --> 00:18:13,610
loads and stores not to instruction

00:18:11,120 --> 00:18:15,470
fetches they can then load or store or

00:18:13,610 --> 00:18:17,029
slowed and only load the address of the

00:18:15,470 --> 00:18:18,169
instruction then they have the

00:18:17,029 --> 00:18:19,700
instruction that faulted and then they

00:18:18,169 --> 00:18:22,340
can decode it and see why it faulted and

00:18:19,700 --> 00:18:25,399
what to do maybe they should return

00:18:22,340 --> 00:18:28,399
something or do something else right so

00:18:25,399 --> 00:18:30,409
you have to know both if your

00:18:28,399 --> 00:18:32,929
virtualized or if you want to pretend to

00:18:30,409 --> 00:18:35,750
do a virtual access and then the really

00:18:32,929 --> 00:18:37,159
fun part with with this bit is then it

00:18:35,750 --> 00:18:40,760
changes the registers you read or write

00:18:37,159 --> 00:18:42,590
or you read so if your virtualized and

00:18:40,760 --> 00:18:44,870
you're doing your stage 1 translation

00:18:42,590 --> 00:18:48,860
you want to look at the SATP register

00:18:44,870 --> 00:18:51,260
which is the guest train the guest page

00:18:48,860 --> 00:18:54,230
table the top of the page table register

00:18:51,260 --> 00:18:55,610
but if you're an M mode and you want to

00:18:54,230 --> 00:18:58,700
do two states you and when you look up

00:18:55,610 --> 00:19:00,140
you have to read the vsta vs ATP

00:18:58,700 --> 00:19:02,029
register because you want to use the

00:19:00,140 --> 00:19:04,580
guests register not the actual value

00:19:02,029 --> 00:19:05,899
hypervisor register so it's these weird

00:19:04,580 --> 00:19:07,100
things you always have to keep track of

00:19:05,899 --> 00:19:09,799
where you are and what state you're in

00:19:07,100 --> 00:19:11,480
and this is I think definitely the part

00:19:09,799 --> 00:19:13,520
the point of bugs because it's very easy

00:19:11,480 --> 00:19:14,919
to accidentally read the wrong register

00:19:13,520 --> 00:19:17,570
or check the wrong conditional and and

00:19:14,919 --> 00:19:18,919
suddenly you're using the hypervisor

00:19:17,570 --> 00:19:22,039
page table instead of the guest page

00:19:18,919 --> 00:19:24,470
table to do a two stage lookup and like

00:19:22,039 --> 00:19:27,169
I said the second tape stage failures

00:19:24,470 --> 00:19:28,850
have to trap to the hypervisor and the

00:19:27,169 --> 00:19:30,649
way qyx is these are kind of two

00:19:28,850 --> 00:19:31,730
different places we figure out we're

00:19:30,649 --> 00:19:33,350
going to have an exception and then we

00:19:31,730 --> 00:19:34,909
handle the exception and much later on a

00:19:33,350 --> 00:19:36,230
different place and so you had to keep

00:19:34,909 --> 00:19:37,770
track of that to make sure we don't

00:19:36,230 --> 00:19:41,540
delegate that later

00:19:37,770 --> 00:19:41,540
and don't exactly lose that information

00:19:42,170 --> 00:19:46,350
so register swapping registers whole

00:19:44,700 --> 00:19:50,100
thing is my least favorite plug this

00:19:46,350 --> 00:19:53,910
whole thing so it gets really

00:19:50,100 --> 00:19:57,030
complicated because of the way risk five

00:19:53,910 --> 00:19:59,460
Cs arts work so a lot of the CSRs there

00:19:57,030 --> 00:20:01,710
is the M mode and s mode so like M

00:19:59,460 --> 00:20:04,140
status there's M status and s status but

00:20:01,710 --> 00:20:06,600
the s status register is actually a

00:20:04,140 --> 00:20:08,550
masked version of M status so M status

00:20:06,600 --> 00:20:11,010
is the register contains all the

00:20:08,550 --> 00:20:13,320
information and s status is just some of

00:20:11,010 --> 00:20:15,480
that information for the guests that the

00:20:13,320 --> 00:20:18,480
OS can see the OS doesn't see all of it

00:20:15,480 --> 00:20:20,970
need to see some of it so Kimmy uses M

00:20:18,480 --> 00:20:22,830
status internally to track the status we

00:20:20,970 --> 00:20:25,200
don't have like a second independent way

00:20:22,830 --> 00:20:27,390
to know what we're doing we just read em

00:20:25,200 --> 00:20:29,820
status so M status always has the latest

00:20:27,390 --> 00:20:31,680
updates of what privilege mode were in

00:20:29,820 --> 00:20:34,560
or whatever it is and so we read from

00:20:31,680 --> 00:20:37,110
that so swapping that back and forward

00:20:34,560 --> 00:20:39,450
while not keep needing to keep it

00:20:37,110 --> 00:20:42,720
updated all the time is is quite

00:20:39,450 --> 00:20:44,190
difficult so if s mode only registers

00:20:42,720 --> 00:20:45,900
things that Kim you doesn't really care

00:20:44,190 --> 00:20:48,390
about they easy we just value swap them

00:20:45,900 --> 00:20:51,600
on on virtualization changes so trap

00:20:48,390 --> 00:20:54,540
some returns the s the M status and mie

00:20:51,600 --> 00:20:57,150
we use pointers just it's kind of easier

00:20:54,540 --> 00:20:58,800
just to swap the pointer and then copy

00:20:57,150 --> 00:21:00,330
the values around so you don't have to

00:20:58,800 --> 00:21:02,790
clobber things and copy them back and

00:21:00,330 --> 00:21:03,390
forth and the MIPS es I liked it too a

00:21:02,790 --> 00:21:05,430
bit earlier

00:21:03,390 --> 00:21:08,430
now that's no longer atomically accessed

00:21:05,430 --> 00:21:10,590
we can value sort that too so this is

00:21:08,430 --> 00:21:14,460
what the register swapping looks like so

00:21:10,590 --> 00:21:16,800
in hardware and let oh yeah what if you

00:21:14,460 --> 00:21:18,720
access the s status CSR and your

00:21:16,800 --> 00:21:21,120
virtualization is off you get the s

00:21:18,720 --> 00:21:23,610
status ISA which is actually just some

00:21:21,120 --> 00:21:25,770
part on top of the M status itself and

00:21:23,610 --> 00:21:27,870
if virtualization is on you get the vs

00:21:25,770 --> 00:21:31,350
status CSR which is some part on top of

00:21:27,870 --> 00:21:32,970
the M says so then in km you if you

00:21:31,350 --> 00:21:35,970
access the M status which is a pointer

00:21:32,970 --> 00:21:38,010
then you either get em status in overt

00:21:35,970 --> 00:21:39,600
which appoints two or M status Verte

00:21:38,010 --> 00:21:41,460
depending if you virtualized or not and

00:21:39,600 --> 00:21:45,390
then if you access s status

00:21:41,460 --> 00:21:46,670
GM status in overt masked or M status

00:21:45,390 --> 00:21:48,900
birthmarks

00:21:46,670 --> 00:21:50,400
so the guest doesn't have to do this the

00:21:48,900 --> 00:21:51,220
guests just accesses a status in whom

00:21:50,400 --> 00:21:53,740
you will figure out

00:21:51,220 --> 00:21:55,809
what needs to do and translate it the

00:21:53,740 --> 00:21:57,610
reason it kind of ends up being sort of

00:21:55,809 --> 00:21:59,559
complex and some other architectures

00:21:57,610 --> 00:22:01,120
have arrays and they can kind of keep

00:21:59,559 --> 00:22:03,250
all this information like if virtualized

00:22:01,120 --> 00:22:05,020
read the second index of the array if

00:22:03,250 --> 00:22:08,200
not read the zero like the first index

00:22:05,020 --> 00:22:09,850
is your index things like that is that

00:22:08,200 --> 00:22:11,679
the Quizlet risk five have the risk five

00:22:09,850 --> 00:22:13,870
world is so modular there's probably a

00:22:11,679 --> 00:22:16,299
lot of people who will use RIS file or

00:22:13,870 --> 00:22:19,179
do respite work and never care about the

00:22:16,299 --> 00:22:21,190
hypervisor extension so to force them to

00:22:19,179 --> 00:22:23,080
understand every time they accessed em

00:22:21,190 --> 00:22:25,480
status if they're virtualized or not

00:22:23,080 --> 00:22:27,429
virtualized which ones do they access it

00:22:25,480 --> 00:22:30,940
just seems like a pain so the idea here

00:22:27,429 --> 00:22:32,650
is that at all times all the registers

00:22:30,940 --> 00:22:34,539
are correct if you access em status no

00:22:32,650 --> 00:22:36,400
matter where you are in the code you're

00:22:34,539 --> 00:22:38,679
creating the correct EM status and

00:22:36,400 --> 00:22:41,110
hypervisor extension kind of off by

00:22:38,679 --> 00:22:43,600
itself will make sure to update that

00:22:41,110 --> 00:22:45,549
correctly the theory is that when people

00:22:43,600 --> 00:22:48,179
come later and add whatever new

00:22:45,549 --> 00:22:51,220
extension they don't have to deal with

00:22:48,179 --> 00:22:52,870
figuring out which state they're in and

00:22:51,220 --> 00:22:57,970
and virtualized on my virtual ace that's

00:22:52,870 --> 00:23:00,880
the that's the idea there so future work

00:22:57,970 --> 00:23:03,010
so current plan is to upstream what we

00:23:00,880 --> 00:23:05,620
currently have if it's not upstream it's

00:23:03,010 --> 00:23:08,110
just not worth having so we want it in

00:23:05,620 --> 00:23:10,600
mainline I'll talk about that a little

00:23:08,110 --> 00:23:12,900
bit later too so the other thing is to

00:23:10,600 --> 00:23:15,340
update he'll be accused he'll be cashing

00:23:12,900 --> 00:23:17,919
I don't know how many people need know

00:23:15,340 --> 00:23:20,740
um you steal B stuff but it caches to

00:23:17,919 --> 00:23:23,289
your V's and we can flush them and right

00:23:20,740 --> 00:23:26,080
now we just wash on any sign of anything

00:23:23,289 --> 00:23:29,110
if it's someone said to flush just plus

00:23:26,080 --> 00:23:32,289
everything and so the idea is hopefully

00:23:29,110 --> 00:23:34,390
we can change that to kind of save some

00:23:32,289 --> 00:23:36,549
of the virtualization State when we

00:23:34,390 --> 00:23:38,740
catch them so we can flush just the

00:23:36,549 --> 00:23:40,240
virtualized or not virtualized State but

00:23:38,740 --> 00:23:41,890
depending on s fence or haystack

00:23:40,240 --> 00:23:43,600
h vance instruction so it should be a

00:23:41,890 --> 00:23:45,549
little quicker but it should also help

00:23:43,600 --> 00:23:47,610
catch bugs in the software so if your

00:23:45,549 --> 00:23:49,780
software is incorrectly flushing things

00:23:47,610 --> 00:23:52,240
kim you will bring it up and you'll see

00:23:49,780 --> 00:23:54,250
it otherwise now you would never really

00:23:52,240 --> 00:23:55,179
notice Kimmy just flushes so much it it

00:23:54,250 --> 00:23:57,549
doesn't matter and it might not actually

00:23:55,179 --> 00:23:58,809
work on how we're that's kind of a point

00:23:57,549 --> 00:24:00,580
there

00:23:58,809 --> 00:24:02,769
update to the spec

00:24:00,580 --> 00:24:05,259
keep updating until it's draft and even

00:24:02,769 --> 00:24:06,849
then keep updating it add support the

00:24:05,259 --> 00:24:09,219
nested virtualization so I talked about

00:24:06,849 --> 00:24:10,899
nested virtualization a start but those

00:24:09,219 --> 00:24:13,959
bits don't connect through door anything

00:24:10,899 --> 00:24:16,239
at the moment in CHEM you it kind of had

00:24:13,959 --> 00:24:17,739
the test cuz no one was really brining

00:24:16,239 --> 00:24:19,690
the nested virtualization so we'd have

00:24:17,739 --> 00:24:21,580
to get a hypervisor updated to support

00:24:19,690 --> 00:24:24,399
that and also at the same time

00:24:21,580 --> 00:24:27,369
developing and kmu and 32-bit Linux

00:24:24,399 --> 00:24:31,830
guests don't work yet so we just run

00:24:27,369 --> 00:24:31,830
bare metal guess but likes fails to brew

00:24:32,099 --> 00:24:38,440
so the original 0 to 3 that we did all

00:24:36,279 --> 00:24:40,599
the work on had this background swapping

00:24:38,440 --> 00:24:41,559
register stuff it was a little different

00:24:40,599 --> 00:24:44,129
to the way we do it now with this

00:24:41,559 --> 00:24:46,570
virtual status or the virtual registers

00:24:44,129 --> 00:24:48,669
and it was unclear where interrupts

00:24:46,570 --> 00:24:51,190
should go to and who should handle them

00:24:48,669 --> 00:24:53,200
and things like that so we caught that

00:24:51,190 --> 00:24:55,239
well mostly a lot of bugs and Kim you

00:24:53,200 --> 00:24:57,159
caught that and so that's cleared up now

00:24:55,239 --> 00:25:03,999
as part of the update 2:04 it's how much

00:24:57,159 --> 00:25:05,499
clearer how the shadow registers work so

00:25:03,999 --> 00:25:07,509
the overall current status so like I

00:25:05,499 --> 00:25:08,649
said the viewers the second version of

00:25:07,509 --> 00:25:10,869
the hypervisor patches are on the

00:25:08,649 --> 00:25:12,209
mailing list about half of them have

00:25:10,869 --> 00:25:14,469
being reviewed if anyone's interested

00:25:12,209 --> 00:25:17,709
more as the better you can go look at

00:25:14,469 --> 00:25:19,690
them we might make it into 4.2 which is

00:25:17,709 --> 00:25:22,509
the next release of Q I think by the end

00:25:19,690 --> 00:25:24,339
of the year otherwise would be 5.0 that

00:25:22,509 --> 00:25:26,289
kind of depends on soft freezes and hard

00:25:24,339 --> 00:25:28,839
phrases and all that stuff so there's

00:25:26,289 --> 00:25:30,549
KVM patches on list a my colleague and I

00:25:28,839 --> 00:25:32,950
are talking about KVM on Wednesday if

00:25:30,549 --> 00:25:35,219
interested in that and the KVM patches

00:25:32,950 --> 00:25:38,169
are mostly reviewed then after that

00:25:35,219 --> 00:25:39,519
expires expires of hatches on expires

00:25:38,169 --> 00:25:41,109
the next branch waiting to be released

00:25:39,519 --> 00:25:43,539
and my colleague has to talk about

00:25:41,109 --> 00:25:45,459
expires tomorrow it's really interesting

00:25:43,539 --> 00:25:47,529
you should go look at that over an SPI

00:25:45,459 --> 00:25:49,989
which is the firmware for verse 5 the

00:25:47,529 --> 00:25:51,190
go-to firmware so the firmware needs

00:25:49,989 --> 00:25:53,529
changes to handle the hypervisor

00:25:51,190 --> 00:25:55,450
extensions as well and that's been

00:25:53,529 --> 00:25:58,539
released in the 0.5 release which is

00:25:55,450 --> 00:26:01,299
latest release so that's all good to go

00:25:58,539 --> 00:26:02,859
and 0.5 of the hypervisor spec I heard

00:26:01,299 --> 00:26:05,019
was supposed to come out this week so

00:26:02,859 --> 00:26:08,889
sometime soon we should be getting that

00:26:05,019 --> 00:26:11,450
and then we can look at updating so I

00:26:08,889 --> 00:26:13,340
have a demo and questions

00:26:11,450 --> 00:26:21,580
if anyone has any questions you might

00:26:13,340 --> 00:26:21,580
start that first okay the demo

00:26:30,290 --> 00:26:37,050
yeah so here's just Kim you with no

00:26:34,800 --> 00:26:39,840
graphic which is a standard way of

00:26:37,050 --> 00:26:41,040
studying Kim you diverting this is the

00:26:39,840 --> 00:26:44,400
thing I was saying it turned the

00:26:41,040 --> 00:26:47,990
hypervisor extensions on where kernel is

00:26:44,400 --> 00:26:51,570
this is XYZ that expires a kernel

00:26:47,990 --> 00:26:53,480
running urban SPI this is a in an ID

00:26:51,570 --> 00:26:59,070
that expires it all can you see that

00:26:53,480 --> 00:27:00,570
strives do anymore okay

00:26:59,070 --> 00:27:03,780
in Rd and then we have some append

00:27:00,570 --> 00:27:05,429
options and sp4 so I'll get that in a

00:27:03,780 --> 00:27:12,600
second so open spi boots

00:27:05,429 --> 00:27:16,500
this is expires are so it brings up four

00:27:12,600 --> 00:27:19,830
CPUs that copies in all the kernel and

00:27:16,500 --> 00:27:24,690
root of s this takes a while I think

00:27:19,830 --> 00:27:28,110
it's a really big curl now I guess yeah

00:27:24,690 --> 00:27:31,230
I think it says yeah so it says this is

00:27:28,110 --> 00:27:32,700
the risk five is a string so we're RV 64

00:27:31,230 --> 00:27:37,910
and it's a H and therefore the

00:27:32,700 --> 00:27:44,960
hypervisor extension this is expires oh

00:27:37,910 --> 00:27:44,960
so we can kick the first guest

00:27:51,980 --> 00:27:55,149
best guess

00:28:00,960 --> 00:28:05,100
so we bind to the UN of the guests and

00:28:03,570 --> 00:28:08,460
so the way expires or works is these

00:28:05,100 --> 00:28:11,190
guests run this little um a damn metal

00:28:08,460 --> 00:28:14,490
thing so we can say hello SS low back

00:28:11,190 --> 00:28:15,960
and we can use it to autoexec so it's

00:28:14,490 --> 00:28:20,630
kind of already copied in the kernel so

00:28:15,960 --> 00:28:20,630
now we'll boodle in after time

00:28:24,830 --> 00:28:30,100
this is over SSH which is why it's all

00:28:26,690 --> 00:28:30,100
kind of jumping around

00:28:37,330 --> 00:28:40,590
yes with low yeah

00:28:48,980 --> 00:28:56,000
area so this is inside the x-files oh

00:28:53,779 --> 00:29:00,350
this is our Linux we have two CPUs pasta

00:28:56,000 --> 00:29:05,269
to the guest and we can assign it an IP

00:29:00,350 --> 00:29:09,230
address yup now we jump back to X Y Z I

00:29:05,269 --> 00:29:11,440
just exited out we can kick the second

00:29:09,230 --> 00:29:11,440
guest

00:29:22,180 --> 00:29:36,270
by into it what exactly it so now we

00:29:25,270 --> 00:29:36,270
have two guests running take second

00:29:43,210 --> 00:29:50,430
now we can ping from the second guest

00:29:46,980 --> 00:29:50,430
the first guest

00:30:00,840 --> 00:30:13,780
yes they're still running I can listen

00:30:02,950 --> 00:30:16,990
to your guests and list the CPUs and I

00:30:13,780 --> 00:30:25,960
can buy it back through it and so it's

00:30:16,990 --> 00:30:28,600
ii guess still pinging away go back to

00:30:25,960 --> 00:30:34,690
the first guest and we contain the

00:30:28,600 --> 00:30:37,330
second guest so yeah so that's basic

00:30:34,690 --> 00:30:39,970
hypervisor running on rougarous v

00:30:37,330 --> 00:30:41,620
hypervisor running on top of q mu okay

00:30:39,970 --> 00:30:47,650
so now any more question or any

00:30:41,620 --> 00:30:53,070
questions our eyes are done then we can

00:30:47,650 --> 00:30:53,070
just keep watching a ping yeah

00:30:57,680 --> 00:31:02,420
is the ping time worse with the

00:30:59,660 --> 00:31:05,090
hypervisor on them with off you mean if

00:31:02,420 --> 00:31:10,490
I ran like to Kimmy winces and made them

00:31:05,090 --> 00:31:15,140
talk to each other I don't know I don't

00:31:10,490 --> 00:31:16,340
I don't know it's pretty I mean it looks

00:31:15,140 --> 00:31:20,480
a little slower because the SSH

00:31:16,340 --> 00:31:23,320
connection is kind of sucky but yeah I

00:31:20,480 --> 00:31:23,320
don't know it's a good question

00:31:28,280 --> 00:31:33,740
that's it

00:31:30,420 --> 00:31:33,740
okay I'm done

00:31:34,620 --> 00:31:39,850

YouTube URL: https://www.youtube.com/watch?v=eNUn9uMPcCs


