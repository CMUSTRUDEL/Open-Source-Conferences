Title: Boot Time Memory Management - Mike Rapoport, IBM
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Boot Time Memory Management - Mike Rapoport, IBM*

Normally, memory allocations in kernel are done using kmalloc(), vmalloc() or their hybrid kvmalloc() functions. They all are baked by the page allocator and alloc_page() functions family. But during system boot when the most of the platform initialization code is run neither of them is available because the allocators are not yet set up.

For early memory management Linux has an allocator called `memblock` that provides the earliest abstraction of the physical memory and can be used nearly from the very beginning of the kernel execution.

This talk will cover the memblock APIs, the expectations and requirements for the architecture specific parts of the memory management setup and will wrap up with description of page allocator initialization.
Captions: 
	00:00:00,030 --> 00:00:05,509
all right hey I'm Mike and I'm going to

00:00:03,600 --> 00:00:09,030
talk about boot time memory management

00:00:05,509 --> 00:00:11,010
and so these are topics I'm going to

00:00:09,030 --> 00:00:12,929
cover no more or less to some level of

00:00:11,010 --> 00:00:15,570
details it's called Linux initialized

00:00:12,929 --> 00:00:18,150
its memory management subsystem what

00:00:15,570 --> 00:00:21,869
happens from that perspective from the

00:00:18,150 --> 00:00:26,460
moment Linux starts after bootloader

00:00:21,869 --> 00:00:28,890
jumps into it and until the moment it is

00:00:26,460 --> 00:00:32,460
possible to use in pager location and

00:00:28,890 --> 00:00:34,140
came out and all the usual allocation

00:00:32,460 --> 00:00:37,829
methods we know from the kernel

00:00:34,140 --> 00:00:40,440
development and one of the topics that

00:00:37,829 --> 00:00:42,420
our camera is member which is a

00:00:40,440 --> 00:00:45,719
important memory management of the Linux

00:00:42,420 --> 00:00:49,530
kernel what api's and does it provide to

00:00:45,719 --> 00:00:54,930
the developers and how they can and

00:00:49,530 --> 00:00:57,780
should be used so normally when we

00:00:54,930 --> 00:01:01,079
developed the kernel code we use a lock

00:00:57,780 --> 00:01:04,050
page came along came a shock or whatever

00:01:01,079 --> 00:01:08,080
other allocator there is there and

00:01:04,050 --> 00:01:10,990
like in the end every allocation in the

00:01:08,080 --> 00:01:14,590
kernel boils down to by the pager

00:01:10,990 --> 00:01:18,010
locator granting some physical memory to

00:01:14,590 --> 00:01:20,200
that or another allocation request it

00:01:18,010 --> 00:01:23,260
can be cached with command cashes it can

00:01:20,200 --> 00:01:25,810
be used with their general or other

00:01:23,260 --> 00:01:30,070
methods in the end everything is about

00:01:25,810 --> 00:01:32,950
in physical pager locator so physical

00:01:30,070 --> 00:01:35,440
page a locator itself is really complex

00:01:32,950 --> 00:01:38,080
based and it needs memory to allocate

00:01:35,440 --> 00:01:41,170
its own data structures that it uses to

00:01:38,080 --> 00:01:43,420
manage the entire physical memory but

00:01:41,170 --> 00:01:46,330
these data structure are not readily

00:01:43,420 --> 00:01:48,970
available at the time you start

00:01:46,330 --> 00:01:52,840
executing the kernel and their needs

00:01:48,970 --> 00:01:57,190
their need they will reason it for some

00:01:52,840 --> 00:01:59,920
other mechanism to take care of memory

00:01:57,190 --> 00:02:04,350
allocations before pager locator is

00:01:59,920 --> 00:02:06,940
available for normal use so when

00:02:04,350 --> 00:02:10,060
bootloader jumps into the Linux kernel

00:02:06,940 --> 00:02:13,540
that's more or less a the view of the

00:02:10,060 --> 00:02:18,819
physical memory it's a bit difficult for

00:02:13,540 --> 00:02:23,140
me so I just can wave my hands and there

00:02:18,819 --> 00:02:26,530
are several used regions the kernel code

00:02:23,140 --> 00:02:28,630
data etc a the parameters bootloader

00:02:26,530 --> 00:02:32,920
passed to the Linux kernel it can be

00:02:28,630 --> 00:02:35,770
command line days data structure it can

00:02:32,920 --> 00:02:37,990
being device tree or depends on

00:02:35,770 --> 00:02:40,599
particular architecture there is an

00:02:37,990 --> 00:02:42,730
optional in it or the image that will be

00:02:40,599 --> 00:02:45,400
used as the very first initial user

00:02:42,730 --> 00:02:50,410
space file system and there is sometimes

00:02:45,400 --> 00:02:52,959
a few more data that is live for a

00:02:50,410 --> 00:02:55,750
during the kernel execution it can be

00:02:52,959 --> 00:02:58,000
used should be used when the kernel

00:02:55,750 --> 00:02:58,750
tries to access fumer or do something

00:02:58,000 --> 00:03:00,790
with it

00:02:58,750 --> 00:03:03,670
this is also architecture dependent not

00:03:00,790 --> 00:03:09,550
architectures believe that in piece and

00:03:03,670 --> 00:03:11,349
the most memory as we can see here the

00:03:09,550 --> 00:03:14,350
most of the memory is freeing the

00:03:11,349 --> 00:03:17,410
problem is the kernel still doesn't know

00:03:14,350 --> 00:03:19,270
where it is so whenever

00:03:17,410 --> 00:03:23,740
according to Colonel tries to access

00:03:19,270 --> 00:03:25,900
some of the physical memory it can

00:03:23,740 --> 00:03:27,940
actually overwrite either Colonel or in

00:03:25,900 --> 00:03:29,620
it or Dean or some other important piece

00:03:27,940 --> 00:03:30,880
of information in the parameters that

00:03:29,620 --> 00:03:33,240
were passed from good order to the

00:03:30,880 --> 00:03:33,240
colonel

00:03:34,050 --> 00:03:42,060
so it should the colonel should be very

00:03:38,320 --> 00:03:45,730
careful it what it does with the memory

00:03:42,060 --> 00:03:48,400
before the last bullet here and may mean

00:03:45,730 --> 00:03:51,370
it so what happens it's quite a lot of

00:03:48,400 --> 00:03:53,590
code that runs from the start of the

00:03:51,370 --> 00:03:55,450
colonel till the point when the

00:03:53,590 --> 00:03:59,500
alligators are set up and then

00:03:55,450 --> 00:04:01,720
functional so usually what's happening

00:03:59,500 --> 00:04:05,110
it's also architecture dependent but for

00:04:01,720 --> 00:04:09,040
the most part assembly code sets up some

00:04:05,110 --> 00:04:13,210
basic breach table a basic page tables

00:04:09,040 --> 00:04:17,380
with the memory pre-allocated for them

00:04:13,210 --> 00:04:20,170
from the BSS in the kernel so that it

00:04:17,380 --> 00:04:23,530
won't overwrite some essential

00:04:20,170 --> 00:04:26,650
information and the fact that they're in

00:04:23,530 --> 00:04:30,790
the BSS already makes them visible and

00:04:26,650 --> 00:04:34,380
as an on-location the next step usually

00:04:30,790 --> 00:04:37,570
is that setup arch for each of

00:04:34,380 --> 00:04:41,580
twenty-something architectures detects

00:04:37,570 --> 00:04:44,620
the physical memory a configuration and

00:04:41,580 --> 00:04:47,140
then notifies the rest of the kernel

00:04:44,620 --> 00:04:48,940
where the physical memory lives what is

00:04:47,140 --> 00:04:51,160
the starting address for today and

00:04:48,940 --> 00:04:56,020
addressing how its organized in banks

00:04:51,160 --> 00:04:58,690
Numa nodes whatnot and also setup

00:04:56,020 --> 00:05:01,300
architecture for every chin down every

00:04:58,690 --> 00:05:04,570
architecture in the kernel make sure

00:05:01,300 --> 00:05:06,760
that the areas in from the previous

00:05:04,570 --> 00:05:08,710
slide the kernel parameters intervene

00:05:06,760 --> 00:05:10,840
whatever essential that is in memories

00:05:08,710 --> 00:05:15,100
it should live during the kernel

00:05:10,840 --> 00:05:17,290
execution is reserved and it it's known

00:05:15,100 --> 00:05:22,540
for the rest of the kernel that this

00:05:17,290 --> 00:05:27,639
memory should not be touched then start

00:05:22,540 --> 00:05:32,680
kernel from the in it may not see

00:05:27,639 --> 00:05:36,310
you must use an early memory allocation

00:05:32,680 --> 00:05:40,740
because he delegate several large

00:05:36,310 --> 00:05:44,259
buffers that page alligator won't would

00:05:40,740 --> 00:05:47,979
wouldn't grant to anyone because of

00:05:44,259 --> 00:05:51,340
certain restrictions and only the at

00:05:47,979 --> 00:05:54,219
that point said that chemicals mmm in it

00:05:51,340 --> 00:05:56,379
which interns transfers all the physical

00:05:54,219 --> 00:05:58,509
memory pages that were not yet reserved

00:05:56,379 --> 00:06:01,270
to the page allocation and from that

00:05:58,509 --> 00:06:05,610
point everyone can use page out came in

00:06:01,270 --> 00:06:10,449
came out and so on and so on

00:06:05,610 --> 00:06:13,210
and I must note also that from from the

00:06:10,449 --> 00:06:15,550
beginning of the criminal execution to

00:06:13,210 --> 00:06:19,270
the point where the memory management

00:06:15,550 --> 00:06:20,349
system is initialized it's quite a lot

00:06:19,270 --> 00:06:23,469
of going on there

00:06:20,349 --> 00:06:27,460
it's SM pins evolution is saying see

00:06:23,469 --> 00:06:31,680
groups kernel print key buffers all

00:06:27,460 --> 00:06:35,259
other kind of things and they all must

00:06:31,680 --> 00:06:40,180
take proper care of their memory

00:06:35,259 --> 00:06:48,240
locations so what happened a long while

00:06:40,180 --> 00:06:51,580
ago and to do so until in linux beat 2.3

00:06:48,240 --> 00:06:55,839
the code for this is actually from

00:06:51,580 --> 00:06:57,399
historical linux and get trees every

00:06:55,839 --> 00:07:01,300
function that was called from start

00:06:57,399 --> 00:07:04,599
kernel was passed memory start memory

00:07:01,300 --> 00:07:06,719
and and if we did some memory allocation

00:07:04,599 --> 00:07:09,669
if it needed some memory it just

00:07:06,719 --> 00:07:11,199
returned the new memory start to account

00:07:09,669 --> 00:07:13,960
for the memory allocated for that

00:07:11,199 --> 00:07:16,539
particular Oh page in woken soul beside

00:07:13,960 --> 00:07:20,020
whatever it is so if they came out

00:07:16,539 --> 00:07:23,409
looking it needed 1k of memories to

00:07:20,020 --> 00:07:25,930
create metadata for came all caches it

00:07:23,409 --> 00:07:28,089
just received memory starts in 16

00:07:25,930 --> 00:07:30,490
kilobytes and then it returned 17

00:07:28,089 --> 00:07:34,810
kilobytes as a new memory start for the

00:07:30,490 --> 00:07:39,090
rest of the system in version 2 points

00:07:34,810 --> 00:07:42,640
read point 23 press 3

00:07:39,090 --> 00:07:46,180
for the first time appeared a bootleg

00:07:42,640 --> 00:07:49,470
memory allocator called butum which was

00:07:46,180 --> 00:07:52,390
a first feet alligator based on bitmaps

00:07:49,470 --> 00:07:55,780
with every physical page represented by

00:07:52,390 --> 00:07:59,410
a bit and that bitmap zero says pages

00:07:55,780 --> 00:08:03,760
occupied once a page is free one says

00:07:59,410 --> 00:08:07,150
page is occupied and then in the setup

00:08:03,760 --> 00:08:09,850
code for instance console pc on it etc

00:08:07,150 --> 00:08:13,570
could use bad butum allocation functions

00:08:09,850 --> 00:08:16,150
and they went to cup the free bits in

00:08:13,570 --> 00:08:21,220
the bitmap and then made make sure that

00:08:16,150 --> 00:08:27,670
the pages were reserved for that in

00:08:21,220 --> 00:08:31,900
other functions that allocated them at

00:08:27,670 --> 00:08:35,620
the time went people discover it various

00:08:31,900 --> 00:08:37,830
problems with boot ma'am and that it was

00:08:35,620 --> 00:08:40,330
quite challenging in evolving

00:08:37,830 --> 00:08:42,729
infrastructure for memory physical

00:08:40,330 --> 00:08:45,880
memory configuration they appeared

00:08:42,729 --> 00:08:48,070
numerous systems not every machine had

00:08:45,880 --> 00:08:51,310
started its memory from Madras 0 it

00:08:48,070 --> 00:08:54,040
could move forever in the 32-bit address

00:08:51,310 --> 00:08:56,830
space I mean physical address space and

00:08:54,040 --> 00:09:01,060
for a larger machine of their days like

00:08:56,830 --> 00:09:03,820
32gb from the bitmap would be quite

00:09:01,060 --> 00:09:06,100
large it would be one mega of bitmap so

00:09:03,820 --> 00:09:07,380
searching that bitmap would be quite

00:09:06,100 --> 00:09:15,220
expensive

00:09:07,380 --> 00:09:18,240
and from version 2.5 a new mechanism for

00:09:15,220 --> 00:09:20,470
early memory allocations was suggested

00:09:18,240 --> 00:09:23,380
actually it initially was implemented

00:09:20,470 --> 00:09:25,600
for PowerPC 64-bit they didn't use

00:09:23,380 --> 00:09:27,910
bitmap and a good member at all they

00:09:25,600 --> 00:09:30,820
used their own mechanisms they called

00:09:27,910 --> 00:09:33,100
then logical memory blocks which

00:09:30,820 --> 00:09:38,470
eventually was renamed to member lock

00:09:33,100 --> 00:09:43,150
and as time went it was adopted by more

00:09:38,470 --> 00:09:45,490
more architectures at first pretty long

00:09:43,150 --> 00:09:48,100
period they existed a compatibility

00:09:45,490 --> 00:09:52,959
layer between main block and

00:09:48,100 --> 00:09:55,170
but ma'am for instance x86 used that no

00:09:52,959 --> 00:09:58,690
boot mem compatibility layer so that

00:09:55,170 --> 00:10:01,149
actual memory allocations at early boot

00:09:58,690 --> 00:10:03,880
process were done by the main block but

00:10:01,149 --> 00:10:07,839
the rest of the system seen at the older

00:10:03,880 --> 00:10:13,569
put'em api's and boot map was completely

00:10:07,839 --> 00:10:16,990
removed in 4.20 so the rest of this talk

00:10:13,569 --> 00:10:19,060
is about mem block and I apologize for

00:10:16,990 --> 00:10:24,399
annoyed developers who are still using

00:10:19,060 --> 00:10:26,440
all the kernels but still a post booting

00:10:24,399 --> 00:10:29,079
mmm block API is pretty well documented

00:10:26,440 --> 00:10:31,750
and you can see the reference

00:10:29,079 --> 00:10:37,079
documentation in the kernel

00:10:31,750 --> 00:10:40,240
documentation page it can also talk now

00:10:37,079 --> 00:10:44,800
maíam block does have some advantages

00:10:40,240 --> 00:10:47,800
over boot name and because it uses

00:10:44,800 --> 00:10:50,829
static data structures embedded into the

00:10:47,800 --> 00:10:53,500
BSS so it can be used straight away

00:10:50,829 --> 00:10:55,810
virtually from - even from the assembly

00:10:53,500 --> 00:10:59,589
code you can call some and block

00:10:55,810 --> 00:11:04,329
something and allocate memory it doesn't

00:10:59,589 --> 00:11:08,170
need to manage the people they put names

00:11:04,329 --> 00:11:10,209
bitmap which was very difficult and you

00:11:08,170 --> 00:11:11,829
you would see a lot of code trying to

00:11:10,209 --> 00:11:15,100
find the exact place where that bitmap

00:11:11,829 --> 00:11:18,370
can be placed and not to clobber with

00:11:15,100 --> 00:11:20,889
other important things in the memory the

00:11:18,370 --> 00:11:23,740
other thing in the allocation itself has

00:11:20,889 --> 00:11:25,660
a bit more complex logic than simply

00:11:23,740 --> 00:11:29,380
tracking the last year's bit in the

00:11:25,660 --> 00:11:31,540
bitmap and one of more dangerous

00:11:29,380 --> 00:11:34,029
features of main block is then whenever

00:11:31,540 --> 00:11:36,509
you allocate memory it may implicitly in

00:11:34,029 --> 00:11:39,689
growth in internal data structures

00:11:36,509 --> 00:11:42,430
allocate some more physical memory and

00:11:39,689 --> 00:11:45,430
consequently cooperate the memory or

00:11:42,430 --> 00:11:49,779
already using so some care should be

00:11:45,430 --> 00:11:54,279
taken to avoid this to happen and this

00:11:49,779 --> 00:11:57,130
is how my block is represents the

00:11:54,279 --> 00:11:58,079
physical memory so yellow is a memory

00:11:57,130 --> 00:11:59,649
bank

00:11:58,079 --> 00:12:03,399
suppose we have

00:11:59,649 --> 00:12:07,899
like I I suppose we have four memory

00:12:03,399 --> 00:12:10,899
banks and then the blue blue rectangles

00:12:07,899 --> 00:12:14,829
are the memories it dissolved in use so

00:12:10,899 --> 00:12:19,269
my blog has two structures called member

00:12:14,829 --> 00:12:21,790
log type 1 my blog type memory and one

00:12:19,269 --> 00:12:25,990
member type Reserve each of these

00:12:21,790 --> 00:12:29,619
structures is an array of initially 188

00:12:25,990 --> 00:12:33,040
entries and each entry in the array

00:12:29,619 --> 00:12:35,829
represents a memory region a continuous

00:12:33,040 --> 00:12:39,730
physical memory region they started it

00:12:35,829 --> 00:12:41,670
has base sized some flags that allowed

00:12:39,730 --> 00:12:45,040
to distinguish regions with different

00:12:41,670 --> 00:12:47,679
properties for instant mirrored memory

00:12:45,040 --> 00:12:54,369
or all the crazy things with no Maps the

00:12:47,679 --> 00:12:58,209
term people invented and it has a node

00:12:54,369 --> 00:13:00,939
ID so that main block would know which

00:12:58,209 --> 00:13:03,850
memory bank been to build which group

00:13:00,939 --> 00:13:08,709
which memory banks belong to which Numa

00:13:03,850 --> 00:13:13,410
node in the system now the memory array

00:13:08,709 --> 00:13:16,720
represents memory bank memory banks as

00:13:13,410 --> 00:13:18,879
plain physical memory banks and the

00:13:16,720 --> 00:13:22,480
reserved array represents the used

00:13:18,879 --> 00:13:24,970
memory that somebody in the kernel cared

00:13:22,480 --> 00:13:32,639
to tell my blog that hey I'm using this

00:13:24,970 --> 00:13:35,110
please take care of it so these arrays

00:13:32,639 --> 00:13:37,389
obviously not directly accessible for

00:13:35,110 --> 00:13:41,620
the modifications you have to use api's

00:13:37,389 --> 00:13:44,139
to modify them and the basic api's for

00:13:41,620 --> 00:13:47,350
dealing with my blocks erase its member

00:13:44,139 --> 00:13:50,889
okay domain block head node these and

00:13:47,350 --> 00:13:54,220
get base address and size of the region

00:13:50,889 --> 00:13:56,980
you would like to make available to men

00:13:54,220 --> 00:13:59,529
walk and that region goes into the

00:13:56,980 --> 00:14:02,350
memory range so these functions

00:13:59,529 --> 00:14:05,589
effectively register physical memory

00:14:02,350 --> 00:14:08,800
banks with network dangerous man block

00:14:05,589 --> 00:14:11,079
remove which is kind of weird because

00:14:08,800 --> 00:14:13,929
there is no hot lock at that time but

00:14:11,079 --> 00:14:16,720
still some architectures want to make

00:14:13,929 --> 00:14:18,910
sure some parts of physical memory are

00:14:16,720 --> 00:14:21,100
not visible to the kernel and are not

00:14:18,910 --> 00:14:23,679
mapped by page reallocator but you

00:14:21,100 --> 00:14:25,839
solidly buy devices of famer or some

00:14:23,679 --> 00:14:28,720
kind of stuff things that not exactly

00:14:25,839 --> 00:14:32,160
the kernel itself so the choose to

00:14:28,720 --> 00:14:36,459
implement mem block remove and make some

00:14:32,160 --> 00:14:38,920
reservations of physical memory for

00:14:36,459 --> 00:14:42,759
other purposes and normal camera memory

00:14:38,920 --> 00:14:45,129
usage there is also member reserve which

00:14:42,759 --> 00:14:48,670
is the lowest level allocation function

00:14:45,129 --> 00:14:51,160
and that simply says ok I am using it

00:14:48,670 --> 00:14:54,489
from here to here this is my memory and

00:14:51,160 --> 00:14:58,600
I want it I want it there and I don't

00:14:54,489 --> 00:15:00,999
want anybody to touch it and there is

00:14:58,600 --> 00:15:03,160
man block free so if you did some

00:15:00,999 --> 00:15:05,439
reservation of memory and you don't need

00:15:03,160 --> 00:15:08,290
that memory anymore you can just free it

00:15:05,439 --> 00:15:11,170
it will be available for any subsequent

00:15:08,290 --> 00:15:13,569
reservation or whenever the pages are

00:15:11,170 --> 00:15:15,429
handed to the pager or cutter it will be

00:15:13,569 --> 00:15:20,139
making able to make use of that physical

00:15:15,429 --> 00:15:23,230
memory but then people realize that

00:15:20,139 --> 00:15:25,480
these basics are probably not enough to

00:15:23,230 --> 00:15:26,920
do actual memory management because

00:15:25,480 --> 00:15:29,049
every time you need to allocate memory

00:15:26,920 --> 00:15:33,329
you have to search where the free memory

00:15:29,049 --> 00:15:37,869
is then make it man block reserved and

00:15:33,329 --> 00:15:41,649
it was a repeating parting for a lot of

00:15:37,869 --> 00:15:45,759
PowerPC code back then so they've added

00:15:41,649 --> 00:15:47,439
several additional api's that were

00:15:45,759 --> 00:15:51,540
renamed with the time but now they're

00:15:47,439 --> 00:15:57,699
called member lock fees along something

00:15:51,540 --> 00:16:02,049
what they do is they allocate a chunk of

00:15:57,699 --> 00:16:04,540
physical memory with specified alignment

00:16:02,049 --> 00:16:07,809
of specified size there are some

00:16:04,540 --> 00:16:09,999
modifications that allowed to restrict

00:16:07,809 --> 00:16:12,339
where the memory is allocated for

00:16:09,999 --> 00:16:16,470
instance member local crane feeds our

00:16:12,339 --> 00:16:19,059
cranes allow us to say okay I want

00:16:16,470 --> 00:16:20,730
memory location between these physical

00:16:19,059 --> 00:16:23,040
anderson that physical address

00:16:20,730 --> 00:16:25,770
and member Locke will try to satisfy

00:16:23,040 --> 00:16:30,720
that request you can also try to

00:16:25,770 --> 00:16:32,700
allocate from my particular Numa node if

00:16:30,720 --> 00:16:34,950
there is no memory in that particular

00:16:32,700 --> 00:16:39,060
Numa node member lock will fall back to

00:16:34,950 --> 00:16:41,670
other Numa nodes and so it tries as hard

00:16:39,060 --> 00:16:46,770
as possible to grant memory rather than

00:16:41,670 --> 00:16:50,760
to satisfy any restrictions all these

00:16:46,770 --> 00:16:52,830
functions are considered for now at

00:16:50,760 --> 00:16:58,080
least buy me something somewhat lien

00:16:52,830 --> 00:17:00,840
legacy and probably it's better to use

00:16:58,080 --> 00:17:04,470
the other set of functions that I will

00:17:00,840 --> 00:17:06,449
cover in in the bit and these functions

00:17:04,470 --> 00:17:09,839
return physical address of the allocated

00:17:06,449 --> 00:17:12,300
memory and on the contrary there is

00:17:09,839 --> 00:17:13,709
another set of alligators that return

00:17:12,300 --> 00:17:17,970
virtual addresses of the allocated

00:17:13,709 --> 00:17:21,329
memory in the two basic functions from

00:17:17,970 --> 00:17:23,579
that family is man walk aleck trying

00:17:21,329 --> 00:17:29,130
knee draw and my block collector I need

00:17:23,579 --> 00:17:31,020
is so the short one and gets a whole

00:17:29,130 --> 00:17:33,230
bunch of restrictions where the memory

00:17:31,020 --> 00:17:38,550
should be located what no that should be

00:17:33,230 --> 00:17:41,160
gotten from and some other flags that

00:17:38,550 --> 00:17:43,830
specified that probably memory should be

00:17:41,160 --> 00:17:47,430
with memory mirroring enabled or some

00:17:43,830 --> 00:17:50,700
other things and if the location

00:17:47,430 --> 00:17:52,620
succeeds in including all the fault box

00:17:50,700 --> 00:17:56,850
mem work does implicitly which I'll

00:17:52,620 --> 00:18:00,180
cover a bit later the main block a log

00:17:56,850 --> 00:18:02,280
try need is going to convert the

00:18:00,180 --> 00:18:05,670
physical address of the memory it found

00:18:02,280 --> 00:18:07,650
two virtual address do the mem set zero

00:18:05,670 --> 00:18:10,220
for the entire range allocated and

00:18:07,650 --> 00:18:14,100
return that virtual address to the koala

00:18:10,220 --> 00:18:17,760
and for some of the earlier locations of

00:18:14,100 --> 00:18:20,250
larger pieces of memory the men's zero

00:18:17,760 --> 00:18:22,590
was considered something that hurts

00:18:20,250 --> 00:18:24,420
performance and therefore should not be

00:18:22,590 --> 00:18:27,870
done because these areas

00:18:24,420 --> 00:18:30,840
anyway initialized to something else so

00:18:27,870 --> 00:18:32,010
people added man block Alec try need

00:18:30,840 --> 00:18:35,580
role

00:18:32,010 --> 00:18:39,510
which does all the things that the

00:18:35,580 --> 00:18:44,700
trainee does but in the end it leaves

00:18:39,510 --> 00:18:48,630
the memory unsaid and it either contains

00:18:44,700 --> 00:18:51,059
garbage or it could be poisoned if your

00:18:48,630 --> 00:18:54,840
kernel has enough VM debug features

00:18:51,059 --> 00:19:01,860
turned on they at Build time or at boot

00:18:54,840 --> 00:19:04,230
time or even both now these two of large

00:19:01,860 --> 00:19:09,720
beasts and have way too many parameters

00:19:04,230 --> 00:19:13,110
for most uses so there is a bunch of

00:19:09,720 --> 00:19:17,790
convenience wrappers around the mantle

00:19:13,110 --> 00:19:19,710
collector I need and they differ in the

00:19:17,790 --> 00:19:22,679
amount of restrictions they put for the

00:19:19,710 --> 00:19:25,890
memory allocations and the simplest one

00:19:22,679 --> 00:19:28,290
is member karlik which is used in most

00:19:25,890 --> 00:19:31,710
of the places when somebody needs early

00:19:28,290 --> 00:19:34,710
memory just received size and alignment

00:19:31,710 --> 00:19:36,090
and that's all you don't need anything

00:19:34,710 --> 00:19:37,679
more than if you don't need anything

00:19:36,090 --> 00:19:41,280
more than that you're good to go with

00:19:37,679 --> 00:19:43,650
member karlik now if you want to have

00:19:41,280 --> 00:19:45,990
your memory allocated above certain

00:19:43,650 --> 00:19:48,840
physical memory address up above certain

00:19:45,990 --> 00:19:53,120
physical address probably you would want

00:19:48,840 --> 00:19:55,710
to use my block Alec from which tries to

00:19:53,120 --> 00:19:58,860
let you have your memory where you

00:19:55,710 --> 00:20:01,950
specified if it cannot eat again falls

00:19:58,860 --> 00:20:03,390
back to the rest of the memory because

00:20:01,950 --> 00:20:07,160
for mem look it's more important to

00:20:03,390 --> 00:20:09,120
satisfy the allocation than to complain

00:20:07,160 --> 00:20:12,600
then to complain with all the

00:20:09,120 --> 00:20:16,740
restrictions there's also my block a low

00:20:12,600 --> 00:20:19,500
Alec law and for some architectures was

00:20:16,740 --> 00:20:22,830
it was very important to have certain

00:20:19,500 --> 00:20:28,080
pieces allocated from what's called low

00:20:22,830 --> 00:20:33,830
memory for instance I 386 must have its

00:20:28,080 --> 00:20:37,020
deem I CDMA memory below 16 megabytes so

00:20:33,830 --> 00:20:39,600
there is a lot of gods that allocates

00:20:37,020 --> 00:20:43,530
memory from lower memory region

00:20:39,600 --> 00:20:46,650
and therefore this corner this rubber is

00:20:43,530 --> 00:20:49,039
quite useful and whenever somebody wants

00:20:46,650 --> 00:20:51,809
to allocate from a certain Newman note

00:20:49,039 --> 00:20:53,690
and it's the only restriction for the

00:20:51,809 --> 00:20:57,600
locator there is member karlik node

00:20:53,690 --> 00:21:01,280
which tries to give the requester memory

00:20:57,600 --> 00:21:04,919
from the exact number naughty task form

00:21:01,280 --> 00:21:07,500
and there is also member karlik role for

00:21:04,919 --> 00:21:10,650
those who do not want to have their

00:21:07,500 --> 00:21:13,080
memory cleared to zero and then for

00:21:10,650 --> 00:21:16,850
those who consider its performance

00:21:13,080 --> 00:21:21,510
drawback they always can ask for memory

00:21:16,850 --> 00:21:23,250
as it is and again if enough VM debug

00:21:21,510 --> 00:21:29,190
features are turned on it will be

00:21:23,250 --> 00:21:33,900
poisoned now how the whole may block

00:21:29,190 --> 00:21:37,559
allocation works so suppose my blog got

00:21:33,900 --> 00:21:40,159
a request to allocate the say green

00:21:37,559 --> 00:21:40,159
rectangle

00:21:44,130 --> 00:21:54,210
this one so it will drivers impose

00:21:49,650 --> 00:21:57,420
memory and reserve the race to see where

00:21:54,210 --> 00:22:00,810
the free memory is which the yellow the

00:21:57,420 --> 00:22:04,980
yellow bars actually represent the free

00:22:00,810 --> 00:22:08,190
memory and in it continues the traversal

00:22:04,980 --> 00:22:10,800
at Jillian finds the free memory area

00:22:08,190 --> 00:22:16,470
large enough to satisfy the require a

00:22:10,800 --> 00:22:19,260
location request excuse me and then

00:22:16,470 --> 00:22:22,080
after the memory found it will be

00:22:19,260 --> 00:22:24,540
reserved and there will be a new entry

00:22:22,080 --> 00:22:27,420
and memory in member lock reserved rain

00:22:24,540 --> 00:22:30,090
that will represent the reserved memory

00:22:27,420 --> 00:22:33,150
a evening allocation if there are some

00:22:30,090 --> 00:22:37,110
allocations with that help adjustment

00:22:33,150 --> 00:22:40,200
addresses mm block tries to merge him so

00:22:37,110 --> 00:22:46,740
the array won't grow beyond some limits

00:22:40,200 --> 00:22:50,460
and then here a member can implicitly

00:22:46,740 --> 00:22:53,820
grows in reserved rain if you had

00:22:50,460 --> 00:22:59,310
already allocated 188 areas and you're

00:22:53,820 --> 00:23:02,820
located allocating the 199th area the

00:22:59,310 --> 00:23:06,720
array will be doubled and this of course

00:23:02,820 --> 00:23:10,140
has a possibility of overwriting some of

00:23:06,720 --> 00:23:12,690
the accused memory so some caution

00:23:10,140 --> 00:23:15,300
should be taking that one one don't

00:23:12,690 --> 00:23:18,570
won't happen and I'll talk about it a

00:23:15,300 --> 00:23:22,020
bit later so the basic function that

00:23:18,570 --> 00:23:24,360
traverses the arrays is my block fine

00:23:22,020 --> 00:23:27,570
being ranged node which takes into

00:23:24,360 --> 00:23:31,110
account all the restrictions and all the

00:23:27,570 --> 00:23:37,170
criteria like minimal address maximal

00:23:31,110 --> 00:23:40,290
address flags and numa node and it can

00:23:37,170 --> 00:23:43,290
search in both directions both bottom-up

00:23:40,290 --> 00:23:47,010
and top-down the default for mem block

00:23:43,290 --> 00:23:50,560
is top-down allocation so it starts from

00:23:47,010 --> 00:23:53,710
the end of the memory but there is a

00:23:50,560 --> 00:23:58,720
control method that was to force

00:23:53,710 --> 00:24:02,770
bottom-up allocations now these two

00:23:58,720 --> 00:24:06,270
basic functions never called or almost

00:24:02,770 --> 00:24:14,860
never code by themselves there is also a

00:24:06,270 --> 00:24:19,270
wrappers for them that they do in like

00:24:14,860 --> 00:24:22,780
in a loop allocation so that may block a

00:24:19,270 --> 00:24:24,760
lock range need tries to make the

00:24:22,780 --> 00:24:29,440
allocation with whole bunch of

00:24:24,760 --> 00:24:33,640
restrictions user put there but if it

00:24:29,440 --> 00:24:36,220
fails it retries to allocate memory from

00:24:33,640 --> 00:24:38,260
other node in the system so that

00:24:36,220 --> 00:24:40,360
allocation will succeed if the

00:24:38,260 --> 00:24:43,150
particular node doesn't have enough

00:24:40,360 --> 00:24:46,780
memory to accommodate the request and

00:24:43,150 --> 00:24:49,510
this auction a returns a physical

00:24:46,780 --> 00:24:51,940
address of the allocated memory and then

00:24:49,510 --> 00:24:55,150
there is a locking journal which

00:24:51,940 --> 00:24:57,130
actually implements all the member

00:24:55,150 --> 00:25:02,620
karlik functions that return virtual

00:24:57,130 --> 00:25:05,260
address that that does another retry

00:25:02,620 --> 00:25:07,890
without a lower bound for the allocation

00:25:05,260 --> 00:25:11,680
so if somebody said okay I want memory

00:25:07,890 --> 00:25:14,260
about this address and Mamluk alacranes

00:25:11,680 --> 00:25:16,840
need didn't succeed to find memory above

00:25:14,260 --> 00:25:19,750
this address member karlik in journal

00:25:16,840 --> 00:25:24,700
will try to find memory below that

00:25:19,750 --> 00:25:29,110
address as well there is a bunch of

00:25:24,700 --> 00:25:33,010
functions that allow controlling the

00:25:29,110 --> 00:25:36,940
behavior of the allocator itself so to

00:25:33,010 --> 00:25:42,310
avoid the problem of a growing implicit

00:25:36,940 --> 00:25:44,770
growth of reserved array you can disable

00:25:42,310 --> 00:25:47,980
array resizing with main block Alaura

00:25:44,770 --> 00:25:50,800
size which gets to or false and

00:25:47,980 --> 00:25:53,340
respectively in you as a disable or

00:25:50,800 --> 00:25:57,930
enable resize of my block arrays

00:25:53,340 --> 00:26:00,870
in case you restrict your disabled and

00:25:57,930 --> 00:26:02,750
implicit growth of the race your

00:26:00,870 --> 00:26:06,150
location will fail and you get nice

00:26:02,750 --> 00:26:07,740
crash but still you know you something

00:26:06,150 --> 00:26:10,740
you did something wrong instead of

00:26:07,740 --> 00:26:14,850
having some memory corruption along the

00:26:10,740 --> 00:26:16,620
road in a few milliseconds then there is

00:26:14,850 --> 00:26:20,370
ability to set bottom-up or top-down

00:26:16,620 --> 00:26:22,620
direction and then every architecture so

00:26:20,370 --> 00:26:24,840
they need a different way of limiting

00:26:22,620 --> 00:26:27,030
the actual memory that can be used for

00:26:24,840 --> 00:26:29,550
the memory locations there is a whole

00:26:27,030 --> 00:26:31,590
bunch of setting limits which became

00:26:29,550 --> 00:26:34,980
more or less the same but a bit

00:26:31,590 --> 00:26:36,420
different and each one of them I simply

00:26:34,980 --> 00:26:38,370
used by different architectures that

00:26:36,420 --> 00:26:41,550
implemented it and pushed it some time

00:26:38,370 --> 00:26:46,260
ago into the main block probably in some

00:26:41,550 --> 00:26:51,720
time sometimes going along will unify at

00:26:46,260 --> 00:26:54,260
least some of them next and you can

00:26:51,720 --> 00:26:57,180
query the main block state and see

00:26:54,260 --> 00:26:59,820
what's going on there there is a method

00:26:57,180 --> 00:27:04,410
to find out what is your physical memory

00:26:59,820 --> 00:27:07,110
size rather than go and ask fewer or or

00:27:04,410 --> 00:27:10,050
traverse all the mm block arrays you

00:27:07,110 --> 00:27:12,450
just can tell you it can tell you how

00:27:10,050 --> 00:27:15,780
much reserved memory there is in the

00:27:12,450 --> 00:27:19,890
system it can tell you what is your

00:27:15,780 --> 00:27:22,650
start of physical RAM and where it ends

00:27:19,890 --> 00:27:27,180
which is useful for instance on arms

00:27:22,650 --> 00:27:30,450
that may have a lot lot of possibilities

00:27:27,180 --> 00:27:36,480
for physical memory mapping it actually

00:27:30,450 --> 00:27:40,740
depends on the SOC vendor you can check

00:27:36,480 --> 00:27:43,950
if some physical address is actually in

00:27:40,740 --> 00:27:48,120
physical memory if it's already used and

00:27:43,950 --> 00:27:52,070
you can see what is the highest load

00:27:48,120 --> 00:27:52,070
address for the memory allocations

00:27:52,730 --> 00:27:58,160
if you need something beyond these

00:27:55,520 --> 00:28:00,680
interfaces that already available you

00:27:58,160 --> 00:28:06,280
can simply traverse in the main block

00:28:00,680 --> 00:28:09,830
erase with a lot of different iterators

00:28:06,280 --> 00:28:13,160
it's it's not the full list by the way

00:28:09,830 --> 00:28:17,150
there are more of them and each of the

00:28:13,160 --> 00:28:21,800
iterators have some differences so most

00:28:17,150 --> 00:28:24,350
important for for each premium range

00:28:21,800 --> 00:28:27,590
that traverses intersection between

00:28:24,350 --> 00:28:30,470
memory and reserved erase so what you

00:28:27,590 --> 00:28:34,460
get is actually free memory regions and

00:28:30,470 --> 00:28:36,980
you can do something with them and then

00:28:34,460 --> 00:28:40,280
another one is for each reserved memory

00:28:36,980 --> 00:28:42,950
region which is used mostly at the time

00:28:40,280 --> 00:28:44,840
when men block hands over the memory to

00:28:42,950 --> 00:28:46,850
the pager or cutter so the creature or

00:28:44,840 --> 00:28:49,040
cutter will know that this memory is

00:28:46,850 --> 00:28:52,400
already in use and they will not all get

00:28:49,040 --> 00:28:54,470
it to somebody else so most of them are

00:28:52,400 --> 00:28:56,060
pretty well documented and you can take

00:28:54,470 --> 00:29:04,910
a look in the kernel documentation if

00:28:56,060 --> 00:29:09,200
you'd like so now let's return a bit to

00:29:04,910 --> 00:29:12,020
the memory management initialization the

00:29:09,200 --> 00:29:15,560
important piece that should be taken

00:29:12,020 --> 00:29:20,870
care of and all architecture does do

00:29:15,560 --> 00:29:22,460
this mostly right and that the kernel in

00:29:20,870 --> 00:29:25,790
it are different web pages whatever

00:29:22,460 --> 00:29:28,010
memory is occupied by the time kernel

00:29:25,790 --> 00:29:34,940
starts should be reserved as soon as

00:29:28,010 --> 00:29:37,910
possible and then and then you can run

00:29:34,940 --> 00:29:41,570
with the main block resize on and

00:29:37,910 --> 00:29:44,150
allocate memory as as much as you need

00:29:41,570 --> 00:29:46,970
as long as you have all the reserved end

00:29:44,150 --> 00:29:50,030
areas reserved very early in the boot

00:29:46,970 --> 00:29:54,560
process the next thing that's going on

00:29:50,030 --> 00:29:57,830
is the detection of physical memory as

00:29:54,560 --> 00:30:01,580
we already seen in each architecture

00:29:57,830 --> 00:30:05,049
desert in its own way it queries funeral

00:30:01,580 --> 00:30:07,450
do it is from the device tree asks bias

00:30:05,049 --> 00:30:11,080
it's not it's also important to have

00:30:07,450 --> 00:30:12,970
this piece as a as soon as possible so

00:30:11,080 --> 00:30:17,649
you'll be able to allocate the physical

00:30:12,970 --> 00:30:20,860
memory and then if a certain machine has

00:30:17,649 --> 00:30:24,070
some restrictions for physical memory of

00:30:20,860 --> 00:30:27,249
ability like you'd like to have all your

00:30:24,070 --> 00:30:29,619
upper banks available only to this B or

00:30:27,249 --> 00:30:32,769
virtual machines or whatever you can

00:30:29,619 --> 00:30:34,779
limit main block and ensure that it

00:30:32,769 --> 00:30:39,669
won't allocate that physical memory for

00:30:34,779 --> 00:30:41,559
normal camera usage and in the end of

00:30:39,669 --> 00:30:44,950
this boot memory

00:30:41,559 --> 00:30:48,820
boom boom boot process they start care

00:30:44,950 --> 00:30:51,460
no calls a minute in which in turn calls

00:30:48,820 --> 00:30:53,980
member Creole and at the time member

00:30:51,460 --> 00:30:57,190
traverses all the memory and reserved

00:30:53,980 --> 00:31:00,070
erase and passes the whole physical

00:30:57,190 --> 00:31:02,409
memory to the pager cutter and while I

00:31:00,070 --> 00:31:07,029
can you can live normally you have came

00:31:02,409 --> 00:31:13,619
out so these are some references I using

00:31:07,029 --> 00:31:13,619
I used in the talk thank you very much

00:31:13,820 --> 00:31:17,740

YouTube URL: https://www.youtube.com/watch?v=NP7wU7A218k


