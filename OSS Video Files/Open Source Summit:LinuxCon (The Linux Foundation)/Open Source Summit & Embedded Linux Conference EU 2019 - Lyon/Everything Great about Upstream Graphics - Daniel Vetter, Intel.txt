Title: Everything Great about Upstream Graphics - Daniel Vetter, Intel
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Everything Great about Upstream Graphics - Daniel Vetter, Intel*

This talk will cover upstream technologies, infrastructure and driver components relevant for enabling the graphics side of an SoC: Improvements in zero-copy buffer sharing across drivers, better infrastructure for sharing driver components and some SoC specific hardware features like writeback support, self refresh panels, and more. The talk will also cover current development and what the near future will bring.

Upstream graphics has been a solid foundation on the desktop for years. This talk will show that the dream of enabling upstream first, and then shipping on Android, CrOS, genivi, ... or any other custom linux based solution can now also be achieved for SoCs and tiny embedded systems.
Captions: 
	00:00:00,030 --> 00:00:06,240
okay welcome everybody I am I'm Daniel

00:00:03,389 --> 00:00:10,290
I'm the commentator of the Linux kernel

00:00:06,240 --> 00:00:12,540
Sun graphics subsystem beforehand I was

00:00:10,290 --> 00:00:15,389
maintaining it for quite a while for the

00:00:12,540 --> 00:00:17,880
Intel driver I'm working for internals

00:00:15,389 --> 00:00:19,800
open-source graphics center and I'm

00:00:17,880 --> 00:00:23,010
gonna talk about everything great about

00:00:19,800 --> 00:00:26,189
upstream graphics and for context first

00:00:23,010 --> 00:00:31,099
off obviously this title is only

00:00:26,189 --> 00:00:33,270
relevant because ten years ago or so

00:00:31,099 --> 00:00:37,110
things were most definitely not

00:00:33,270 --> 00:00:39,930
everything great so ten years ago we we

00:00:37,110 --> 00:00:42,239
just the bad I'll be more than 10 years

00:00:39,930 --> 00:00:45,059
ago we merged the graphics execution

00:00:42,239 --> 00:00:47,840
manager which it's like the first

00:00:45,059 --> 00:00:52,170
attempt Linux has ever seen as something

00:00:47,840 --> 00:00:55,199
resembling a remotely modern memory

00:00:52,170 --> 00:01:00,320
manager for graphics which is the merged

00:00:55,199 --> 00:01:03,000
kernel mode setting Oh was just a bit a

00:01:00,320 --> 00:01:05,159
label swindle because there was already

00:01:03,000 --> 00:01:07,020
kernel mode setting in the form of FP

00:01:05,159 --> 00:01:10,290
death well this was kind of kernel mode

00:01:07,020 --> 00:01:14,010
setting for for kind of big basket of

00:01:10,290 --> 00:01:17,369
GPUs with OpenGL integrated so we have

00:01:14,010 --> 00:01:20,729
we just started this entire fpf vs. DRM

00:01:17,369 --> 00:01:22,110
struggle on total confusion about so

00:01:20,729 --> 00:01:23,820
which made setting driver do you

00:01:22,110 --> 00:01:26,790
actually want on they were proudly

00:01:23,820 --> 00:01:29,610
celebrating OpenGL for to you like five

00:01:26,790 --> 00:01:33,060
years behind industry so so it was

00:01:29,610 --> 00:01:34,890
pretty depressing if we scroll full

00:01:33,060 --> 00:01:38,040
dirty today

00:01:34,890 --> 00:01:39,810
the kernel the graphics subsystem in the

00:01:38,040 --> 00:01:42,030
kernel is like ten percent of the kernel

00:01:39,810 --> 00:01:44,130
plus user spice so it's one of the

00:01:42,030 --> 00:01:47,159
biggest subsystem there there is in the

00:01:44,130 --> 00:01:50,090
kernel so from nothing to kind of the

00:01:47,159 --> 00:01:54,420
biggest thing or one of the biggest oh

00:01:50,090 --> 00:01:56,040
we have 50 full atomic mass setting

00:01:54,420 --> 00:01:57,960
drivers which is kind of the latest and

00:01:56,040 --> 00:02:00,290
greatest and display dummy support or

00:01:57,960 --> 00:02:02,700
display user space api service support

00:02:00,290 --> 00:02:06,899
which is kind of fun because i've done a

00:02:02,700 --> 00:02:10,259
similar talk two months ago at plumbers

00:02:06,899 --> 00:02:12,209
and back then the number was 50 so we do

00:02:10,259 --> 00:02:13,410
merge these drivers in a pretty brisk

00:02:12,209 --> 00:02:15,780
pace

00:02:13,410 --> 00:02:17,640
on the userspace side we support all the

00:02:15,780 --> 00:02:21,450
latest and greatest stuff nowadays with

00:02:17,640 --> 00:02:25,670
OpenGL jelly as welcome and I think that

00:02:21,450 --> 00:02:29,160
the most impressive fold really is we've

00:02:25,670 --> 00:02:32,190
taken these desktop mate setting and

00:02:29,160 --> 00:02:35,340
memory management IDs and cut them down

00:02:32,190 --> 00:02:38,040
until they were so tiny that tiny enough

00:02:35,340 --> 00:02:43,320
for the tiniest embedded stuff so now we

00:02:38,040 --> 00:02:46,740
have the smallest full display atomic

00:02:43,320 --> 00:02:48,900
driver dadly half is less than 250 lines

00:02:46,740 --> 00:02:53,400
including whitespace and curly braces

00:02:48,900 --> 00:02:55,740
and that the licensing current and the

00:02:53,400 --> 00:02:58,230
biggest one we have is like 2.2 million

00:02:55,740 --> 00:03:01,140
lines of code probably bigger by now I

00:02:58,230 --> 00:03:04,500
didn't recheck that number so we have

00:03:01,140 --> 00:03:08,000
like a factor of 10,000 between the

00:03:04,500 --> 00:03:10,800
smallest and the biggest driver oh so

00:03:08,000 --> 00:03:12,960
yeah that's that smallest drivers I mean

00:03:10,800 --> 00:03:16,170
it's not a joke it has hot on clock

00:03:12,960 --> 00:03:19,140
support it supports the full atomic user

00:03:16,170 --> 00:03:22,080
space API I'll come with the bullet in

00:03:19,140 --> 00:03:24,030
layers on top for the old a legacy

00:03:22,080 --> 00:03:26,910
atomic that we've merged ten years ago

00:03:24,030 --> 00:03:30,209
and it supports FB they've all bells and

00:03:26,910 --> 00:03:32,100
whistles it uses defend memory

00:03:30,209 --> 00:03:34,500
management so that everything just gets

00:03:32,100 --> 00:03:37,560
cleaned up and the things get shot down

00:03:34,500 --> 00:03:41,130
it has DMA buff import/export support so

00:03:37,560 --> 00:03:44,550
you can actually I grinder on a GPU then

00:03:41,130 --> 00:03:49,200
display on this it's for a tiny little

00:03:44,550 --> 00:03:51,120
panel behind an SPI bus like display it

00:03:49,200 --> 00:03:52,830
there and the caramel will do all the

00:03:51,120 --> 00:03:54,500
synchronization so you don't start

00:03:52,830 --> 00:03:56,640
displaying before the thing is or

00:03:54,500 --> 00:03:58,260
copying the buffer to the panel before

00:03:56,640 --> 00:04:00,150
the thing is actually ran there isn't

00:03:58,260 --> 00:04:01,890
user space just excuse it all up and

00:04:00,150 --> 00:04:03,840
can't forget about it I just have

00:04:01,890 --> 00:04:06,060
suspend regime which would be a grand

00:04:03,840 --> 00:04:08,790
total of team of functions and probably

00:04:06,060 --> 00:04:11,730
like five to ten lines of code I guess

00:04:08,790 --> 00:04:17,549
the people who even wrote this just

00:04:11,730 --> 00:04:20,010
didn't need this so oh I do think like

00:04:17,549 --> 00:04:22,380
the upstream graphics subsystem has has

00:04:20,010 --> 00:04:26,820
fully arrived in the embedded world for

00:04:22,380 --> 00:04:31,780
like tiny displays in tiny drivers

00:04:26,820 --> 00:04:35,350
also let's look at their all the things

00:04:31,780 --> 00:04:37,720
it took to get there and I think one of

00:04:35,350 --> 00:04:41,770
one of the most important things is this

00:04:37,720 --> 00:04:45,430
new atomic mate setting API which

00:04:41,770 --> 00:04:48,490
instead of like an entire forest of

00:04:45,430 --> 00:04:50,710
ioctl to set up your display you know

00:04:48,490 --> 00:04:53,320
like this one the atomic ioctl when you

00:04:50,710 --> 00:04:55,780
say he's all the changes you want I want

00:04:53,320 --> 00:04:58,360
today for the next frame his other

00:04:55,780 --> 00:05:00,910
composition changes all the like colour

00:04:58,360 --> 00:05:07,570
management changes with all the rant

00:05:00,910 --> 00:05:09,580
buffers do it on door so that is the

00:05:07,570 --> 00:05:11,080
cool thing that is atomic mustard API is

00:05:09,580 --> 00:05:13,419
also the motivation for it to really

00:05:11,080 --> 00:05:16,390
span from and that it there we have lots

00:05:13,419 --> 00:05:19,419
and lots of scanner planes for low power

00:05:16,390 --> 00:05:21,970
low power use it use cases like this

00:05:19,419 --> 00:05:24,430
playing a video embedded in a friend and

00:05:21,970 --> 00:05:26,680
in a browser window where you want to

00:05:24,430 --> 00:05:29,470
use a special plane for this video and

00:05:26,680 --> 00:05:31,180
phrase everything else up to the big

00:05:29,470 --> 00:05:33,280
desk tabs there you have lots and lots

00:05:31,180 --> 00:05:35,500
of outputs and though the problem more

00:05:33,280 --> 00:05:38,050
is like how can I configure like the

00:05:35,500 --> 00:05:40,780
three four screens and that puts that I

00:05:38,050 --> 00:05:41,380
have without getting past the hardware

00:05:40,780 --> 00:05:45,130
limits

00:05:41,380 --> 00:05:47,260
Oh we added like blending the other

00:05:45,130 --> 00:05:49,960
rights back so you can freeze down you

00:05:47,260 --> 00:05:53,320
can composition and can use your display

00:05:49,960 --> 00:05:55,660
as a as a composition engine which is a

00:05:53,320 --> 00:05:59,050
lot more power efficient than rendering

00:05:55,660 --> 00:06:02,380
stuff live live GL e else call a

00:05:59,050 --> 00:06:04,990
conversion are gracefully handling I'll

00:06:02,380 --> 00:06:07,060
link failures and nowadays like if you

00:06:04,990 --> 00:06:11,260
plug in a display port cable there's

00:06:07,060 --> 00:06:15,490
this an entire computer on that thing on

00:06:11,260 --> 00:06:17,979
it fails on we can now tell the user

00:06:15,490 --> 00:06:20,770
space that you've sorry something broke

00:06:17,979 --> 00:06:23,350
please try again or you need to like

00:06:20,770 --> 00:06:25,479
reduce the resolution change your

00:06:23,350 --> 00:06:27,700
desktop or we even have like content

00:06:25,479 --> 00:06:30,580
protection zone Netflix works and Chrome

00:06:27,700 --> 00:06:32,440
OS I'm pretty much everything else so

00:06:30,580 --> 00:06:35,050
this is the user space API which has

00:06:32,440 --> 00:06:38,050
made a tremendous improvement and kind

00:06:35,050 --> 00:06:39,470
of helped us unify between the FPS and

00:06:38,050 --> 00:06:42,620
better the old and

00:06:39,470 --> 00:06:47,060
a little bitty kind of the graphics

00:06:42,620 --> 00:06:51,530
people or at least there I started

00:06:47,060 --> 00:06:55,160
personally and nice unified as all but

00:06:51,530 --> 00:07:00,860
all if you have such a massive user

00:06:55,160 --> 00:07:03,440
space API you don't brightest in 250

00:07:00,860 --> 00:07:05,900
lines of code so will be also have is

00:07:03,440 --> 00:07:08,510
lots and lots of kernel internal helpers

00:07:05,900 --> 00:07:15,560
that help you break down this complexity

00:07:08,510 --> 00:07:18,020
and allow you yet to write a driver that

00:07:15,560 --> 00:07:23,840
implements this full-featured API in

00:07:18,020 --> 00:07:26,870
very few lines of code so there's the

00:07:23,840 --> 00:07:30,140
entire mode setting helpers for this

00:07:26,870 --> 00:07:32,270
atomic framework which is designed to be

00:07:30,140 --> 00:07:38,090
very model or so for example if you're a

00:07:32,270 --> 00:07:40,190
big desktop GPU maybe did to suggest

00:07:38,090 --> 00:07:42,440
that the implementation flow or or

00:07:40,190 --> 00:07:44,570
commit flow how you program the hardware

00:07:42,440 --> 00:07:47,060
doesn't fit for all your different

00:07:44,570 --> 00:07:50,210
outputs so you rewrite that for your

00:07:47,060 --> 00:07:52,640
driver but maybe your desktop GP is very

00:07:50,210 --> 00:07:55,370
simple plain hard there so we just reuse

00:07:52,640 --> 00:07:58,880
that and you're good and on the flip

00:07:55,370 --> 00:08:00,940
side maybe you have a special sequence

00:07:58,880 --> 00:08:07,010
before you enable the plane so you can

00:08:00,940 --> 00:08:08,840
add that so it's it's very flexible and

00:08:07,010 --> 00:08:13,729
most drivers kind of used something

00:08:08,840 --> 00:08:17,600
between maybe a few functions from that

00:08:13,729 --> 00:08:19,340
library to just use it completely then

00:08:17,600 --> 00:08:21,890
on top of that done and this is where

00:08:19,340 --> 00:08:24,650
the last the school party trekker with

00:08:21,890 --> 00:08:27,110
the tiny driver it's gonna display a

00:08:24,650 --> 00:08:31,100
simple display pipe i'll helper

00:08:27,110 --> 00:08:32,870
which takes i mean because if all you

00:08:31,100 --> 00:08:34,969
have is a panel that you just upload the

00:08:32,870 --> 00:08:36,620
next frame you don't need all these

00:08:34,969 --> 00:08:39,650
features you don't have them right back

00:08:36,620 --> 00:08:42,710
you don't have entire column management

00:08:39,650 --> 00:08:44,420
and and and adjustment pipeline days is

00:08:42,710 --> 00:08:47,900
you copy the buffer and you're done and

00:08:44,420 --> 00:08:51,080
then there's one GPIO to enable the

00:08:47,900 --> 00:08:53,640
panel and shut it down or maybe reset it

00:08:51,080 --> 00:08:56,310
if it's very fancy so we have this in

00:08:53,640 --> 00:08:59,760
this blowpipe helpful which takes all

00:08:56,310 --> 00:09:02,640
the super flexible atomic userspace api

00:08:59,760 --> 00:09:06,330
on breaks at the ante you have one thing

00:09:02,640 --> 00:09:08,850
and his york date function on this is

00:09:06,330 --> 00:09:12,300
the latest he when you take an old SP

00:09:08,850 --> 00:09:14,370
def driver from the FB - subsystem and

00:09:12,300 --> 00:09:16,290
converted over to the atomic with all

00:09:14,370 --> 00:09:20,510
the helpers for applets for EDI

00:09:16,290 --> 00:09:24,120
deporting under symbol this by piper

00:09:20,510 --> 00:09:28,820
those drivers actually shrink by usually

00:09:24,120 --> 00:09:31,380
effective t2 for so so nowadays kind of

00:09:28,820 --> 00:09:34,200
the subsystem that started with big

00:09:31,380 --> 00:09:38,150
desktops is better at embedded and the

00:09:34,200 --> 00:09:40,980
subsystem that started at embedded all

00:09:38,150 --> 00:09:43,410
the self refresh hope i hope is I'm

00:09:40,980 --> 00:09:45,420
gonna talk later on about it and you get

00:09:43,410 --> 00:09:48,990
full-featured FB that family should live

00:09:45,420 --> 00:09:53,180
like one line so including the blank

00:09:48,990 --> 00:09:56,220
support so that your proprietary moly

00:09:53,180 --> 00:09:58,080
non open-source Jesus pious driver can

00:09:56,220 --> 00:10:02,540
just directly render into your frame

00:09:58,080 --> 00:10:06,480
buffer this it all works lessons learned

00:10:02,540 --> 00:10:09,240
from atomic so atomic is it's kind of

00:10:06,480 --> 00:10:10,920
like a database it's it's you commit and

00:10:09,240 --> 00:10:16,110
date or everything goes through or

00:10:10,920 --> 00:10:18,270
nothing goes through on the traditional

00:10:16,110 --> 00:10:20,070
way to do that is you start committing

00:10:18,270 --> 00:10:22,140
and then you roll back and someone is

00:10:20,070 --> 00:10:26,780
gonna forget that one register rights or

00:10:22,140 --> 00:10:29,790
something on making sure it all works

00:10:26,780 --> 00:10:32,250
look like very fragile design we tried

00:10:29,790 --> 00:10:34,890
to do that in some prototyping in civil

00:10:32,250 --> 00:10:37,770
we're doing an atomic is the entire

00:10:34,890 --> 00:10:40,730
state update is a complete new copy of

00:10:37,770 --> 00:10:43,440
the entire driver state so for every

00:10:40,730 --> 00:10:45,540
scanner detention for every hardware

00:10:43,440 --> 00:10:46,920
plane for every output we have state

00:10:45,540 --> 00:10:47,810
structures are there completely

00:10:46,920 --> 00:10:51,390
freestanding

00:10:47,810 --> 00:10:54,090
so rollback it's just you free a bit of

00:10:51,390 --> 00:10:57,060
memory and you're done which makes it a

00:10:54,090 --> 00:10:59,520
very safe and it also makes it makes it

00:10:57,060 --> 00:11:02,640
a lot easier to catch driver box in

00:10:59,520 --> 00:11:05,860
review because in atomic we also allow

00:11:02,640 --> 00:11:08,980
user space to just ask the dis work

00:11:05,860 --> 00:11:12,370
which is needed because generally you

00:11:08,980 --> 00:11:14,110
first need to think about your

00:11:12,370 --> 00:11:16,330
composition like what are you gonna use

00:11:14,110 --> 00:11:19,920
to display how therefore although you

00:11:16,330 --> 00:11:22,360
can are composite with the gr engine

00:11:19,920 --> 00:11:23,590
always as much as possible if the

00:11:22,360 --> 00:11:26,590
display because that's more power

00:11:23,590 --> 00:11:28,660
efficient and then once you made that

00:11:26,590 --> 00:11:31,240
the session then you start the rendering

00:11:28,660 --> 00:11:33,040
with the GL engine and then you do the

00:11:31,240 --> 00:11:35,800
actual commit to halt there and if the

00:11:33,040 --> 00:11:37,210
third step fails you screwed because

00:11:35,800 --> 00:11:39,940
you've already done all the rendering

00:11:37,210 --> 00:11:42,520
assuming a good workout so we have we

00:11:39,940 --> 00:11:45,580
have this atomic check check only our

00:11:42,520 --> 00:11:48,130
mate which just tells you what does work

00:11:45,580 --> 00:11:50,050
yes or no I know obviously this is not

00:11:48,130 --> 00:11:52,090
allowed to change any drivers state or

00:11:50,050 --> 00:11:53,470
any hardware state and by having these

00:11:52,090 --> 00:11:57,580
completely free standing state

00:11:53,470 --> 00:12:01,800
structures we make it a lot easier to

00:11:57,580 --> 00:12:05,500
catch kind of bucks in this area um I

00:12:01,800 --> 00:12:07,750
said already are like making the helpers

00:12:05,500 --> 00:12:11,140
as modeler as possible so you can pick

00:12:07,750 --> 00:12:15,400
and choose has been really good I know

00:12:11,140 --> 00:12:18,970
the thing we they um so the model in

00:12:15,400 --> 00:12:21,160
atomic is you have objects which kind of

00:12:18,970 --> 00:12:23,830
represent things in your Hall there and

00:12:21,160 --> 00:12:25,750
then properties which is things you can

00:12:23,830 --> 00:12:29,710
change and then value so it's it's

00:12:25,750 --> 00:12:32,500
triples but semantically they're they're

00:12:29,710 --> 00:12:34,720
all strings are a lot of them are

00:12:32,500 --> 00:12:38,620
strings like enumeration thingies but

00:12:34,720 --> 00:12:41,740
for encoding we just have all triples of

00:12:38,620 --> 00:12:44,800
unsigned integers and the encoding and

00:12:41,740 --> 00:12:46,600
decoding is all done in the core which I

00:12:44,800 --> 00:12:49,930
think helps a lot in kind of forcing

00:12:46,600 --> 00:12:53,230
standardization so the driver never sees

00:12:49,930 --> 00:12:55,540
kind of these these funny values it only

00:12:53,230 --> 00:13:00,160
ever sees see structures where you can

00:12:55,540 --> 00:13:04,120
use real enum types and see over you

00:13:00,160 --> 00:13:06,100
instead of having an object ID you grab

00:13:04,120 --> 00:13:08,260
a reference for that object and you fill

00:13:06,100 --> 00:13:12,030
in the pointer and so all that

00:13:08,260 --> 00:13:14,710
bookkeeping is not in the driver code um

00:13:12,030 --> 00:13:17,590
we they were also solving the locking

00:13:14,710 --> 00:13:18,540
entirely in Decorah so if the driver for

00:13:17,590 --> 00:13:22,110
example

00:13:18,540 --> 00:13:25,980
has two outputs and you can share planes

00:13:22,110 --> 00:13:28,170
between them I for example have four

00:13:25,980 --> 00:13:30,800
here and four on the other and now uses

00:13:28,170 --> 00:13:33,980
basements TVs 8 on the other a nice tea

00:13:30,800 --> 00:13:37,949
grab the state from the second pipeline

00:13:33,980 --> 00:13:39,810
so you can reallocate these these planes

00:13:37,949 --> 00:13:41,910
and obviously this needs a bit of

00:13:39,810 --> 00:13:43,889
locking because user spies in the second

00:13:41,910 --> 00:13:47,670
thread might also want to be something

00:13:43,889 --> 00:13:50,070
over here and for correctness the way

00:13:47,670 --> 00:13:53,010
the locking works is the driver just

00:13:50,070 --> 00:13:56,070
asks for the state objects in its atomic

00:13:53,010 --> 00:13:57,829
check function it tries to compute

00:13:56,070 --> 00:14:00,060
whether this is possible or not and

00:13:57,829 --> 00:14:03,329
internally every time we grab a new

00:14:00,060 --> 00:14:05,970
state the the atomic core takes care of

00:14:03,329 --> 00:14:10,980
all the locking and the deadlock

00:14:05,970 --> 00:14:12,930
avoidance is just kind of a complicated

00:14:10,980 --> 00:14:14,820
thing because we essentially do graph

00:14:12,930 --> 00:14:19,230
locking as the only subsystem in the

00:14:14,820 --> 00:14:21,779
kernel so this state getting might fail

00:14:19,230 --> 00:14:25,620
because we can't get lock and you need

00:14:21,779 --> 00:14:28,920
to kind of retry maybe not so great as

00:14:25,620 --> 00:14:30,420
we definitely need new tests so starting

00:14:28,920 --> 00:14:33,060
a beginning this year this is now

00:14:30,420 --> 00:14:37,290
mandatory we have a user space test

00:14:33,060 --> 00:14:39,569
suite and we should have proper user

00:14:37,290 --> 00:14:44,160
space ap ice backpacks for all these

00:14:39,569 --> 00:14:47,040
these properties which we need to do

00:14:44,160 --> 00:14:48,959
sooner than later but it's not the at

00:14:47,040 --> 00:14:51,829
mandatory well it's not yet quickly

00:14:48,959 --> 00:14:54,810
what's what's the best way to do this a

00:14:51,829 --> 00:14:56,970
case study for a helper is is like self

00:14:54,810 --> 00:15:00,420
refresh and manual uploads so you have a

00:14:56,970 --> 00:15:03,600
panel and it has its own frame buffer

00:15:00,420 --> 00:15:05,970
and if there's nothing and every time

00:15:03,600 --> 00:15:09,120
you want to change something or you need

00:15:05,970 --> 00:15:13,670
to kind of manually uploads the changed

00:15:09,120 --> 00:15:13,670
area of your frame buffer to the panel

00:15:13,760 --> 00:15:19,560
and there's somewhat similar concept is

00:15:16,470 --> 00:15:22,500
self refresh there if you continuously

00:15:19,560 --> 00:15:26,550
send frames you switch temerity not

00:15:22,500 --> 00:15:29,459
sending frames and obviously the trouble

00:15:26,550 --> 00:15:31,810
is any time something changes you need

00:15:29,459 --> 00:15:33,640
to make sure that the update gets to the

00:15:31,810 --> 00:15:35,470
annal in both of these cases and you

00:15:33,640 --> 00:15:37,870
know it's just showing the same frozen

00:15:35,470 --> 00:15:40,480
screen because he stopped updating but

00:15:37,870 --> 00:15:42,400
there's lots of entry points there's FPF

00:15:40,480 --> 00:15:45,610
emulation that you might need this the

00:15:42,400 --> 00:15:50,260
old kms kernel mode setting this the new

00:15:45,610 --> 00:15:53,050
atomic interface or I will be doing is

00:15:50,260 --> 00:15:55,839
with with the damage tracking helpers we

00:15:53,050 --> 00:15:59,770
we kind of provide the driver a unified

00:15:55,839 --> 00:16:01,839
entry point saw from the driver point if

00:15:59,770 --> 00:16:05,529
you like you breyer up the damage

00:16:01,839 --> 00:16:07,660
tracking thing and all these users may

00:16:05,529 --> 00:16:10,150
say guys look at the same obviously you

00:16:07,660 --> 00:16:13,630
can overwrite then if system legacy

00:16:10,150 --> 00:16:15,100
comfortability thing is oh and user

00:16:13,630 --> 00:16:17,320
space can even tell you like I just

00:16:15,100 --> 00:16:20,260
changed this tiny part of the screen

00:16:17,320 --> 00:16:22,390
please only up like that if you can I'm

00:16:20,260 --> 00:16:24,190
the same way of self refresh I mean self

00:16:22,390 --> 00:16:26,170
refresh essentially shut down the entire

00:16:24,190 --> 00:16:27,700
display except you don't shut down the

00:16:26,170 --> 00:16:35,290
panel because the users still looking at

00:16:27,700 --> 00:16:37,390
that so we have a help of which keeps

00:16:35,290 --> 00:16:39,610
track of that like switch is everything

00:16:37,390 --> 00:16:42,400
back on again as soon as as activity

00:16:39,610 --> 00:16:45,180
kicks in and essentially the only thing

00:16:42,400 --> 00:16:48,760
besides like plugging that helper

00:16:45,180 --> 00:16:50,589
implementation in to your driver is in

00:16:48,760 --> 00:16:52,930
your your panels enable and disable

00:16:50,589 --> 00:16:55,390
function you need to check ready you're

00:16:52,930 --> 00:16:57,640
going in self refresh married or not are

00:16:55,390 --> 00:17:01,000
not shut down the panel if it's just

00:16:57,640 --> 00:17:04,300
soft refresh so essentially all this

00:17:01,000 --> 00:17:07,329
complexity is is all in the helper code

00:17:04,300 --> 00:17:13,209
into actual driver implementations is is

00:17:07,329 --> 00:17:18,189
like 1t handful lines okay oh yeah we

00:17:13,209 --> 00:17:20,290
have more awesome stuffing just again

00:17:18,189 --> 00:17:23,230
all mati write it by SS ease and

00:17:20,290 --> 00:17:26,079
embedded systems making the drivers more

00:17:23,230 --> 00:17:30,429
modeler we have bridges which are kind

00:17:26,079 --> 00:17:32,860
of transcoded thingies because everyone

00:17:30,429 --> 00:17:35,140
uses the same HDMI transcoder more or

00:17:32,860 --> 00:17:36,400
less or we have panel drivers because

00:17:35,140 --> 00:17:37,090
they're they all have kind of different

00:17:36,400 --> 00:17:39,760
quirks

00:17:37,090 --> 00:17:43,620
so you can have a generic driver and you

00:17:39,760 --> 00:17:43,620
just plug in your panel driver

00:17:44,230 --> 00:17:52,460
we've lived et and we have quite a bit

00:17:49,400 --> 00:17:55,940
of support for more general components

00:17:52,460 --> 00:18:00,910
so you can stitch together your driver

00:17:55,940 --> 00:18:05,230
if kind of the standard Linux arm song

00:18:00,910 --> 00:18:07,820
DT approach with device three bindings

00:18:05,230 --> 00:18:10,670
there's there's also a lot of ongoing

00:18:07,820 --> 00:18:13,760
work in this this area with we're trying

00:18:10,670 --> 00:18:16,610
to manage to state for these bridge

00:18:13,760 --> 00:18:21,440
chips better integrated better with

00:18:16,610 --> 00:18:24,110
atomic maybe expose it like allowing you

00:18:21,440 --> 00:18:27,230
to change these are bridges kind of just

00:18:24,110 --> 00:18:29,690
generally more our flexibility we've had

00:18:27,230 --> 00:18:33,320
quite a bit of work in making unlock

00:18:29,690 --> 00:18:35,270
work just mostly really useful for

00:18:33,320 --> 00:18:37,100
developments are you unplug your your

00:18:35,270 --> 00:18:39,650
panel and plugging the next one into

00:18:37,100 --> 00:18:42,350
your SPI bus like state if the kernel

00:18:39,650 --> 00:18:45,770
doesn't phrase and at least for for this

00:18:42,350 --> 00:18:48,710
play only drivers this works now on the

00:18:45,770 --> 00:18:52,340
render side we still have a lot of of

00:18:48,710 --> 00:18:54,140
like a lot more kind of data structures

00:18:52,340 --> 00:18:55,760
that are shared with other drivers like

00:18:54,140 --> 00:18:59,630
for serie copy and all that

00:18:55,760 --> 00:19:04,420
oh they the reference caning isn't quite

00:18:59,630 --> 00:19:08,270
corrected yet and related see that all

00:19:04,420 --> 00:19:11,350
everyone loves to use the device managed

00:19:08,270 --> 00:19:14,810
allocation and and everything else api's

00:19:11,350 --> 00:19:16,970
the problem is that the user space

00:19:14,810 --> 00:19:19,400
visible data structures have different

00:19:16,970 --> 00:19:23,410
lifetime rules than you physical device

00:19:19,400 --> 00:19:26,480
and most drivers get this wrong so the

00:19:23,410 --> 00:19:30,170
way it's slow in the process of of

00:19:26,480 --> 00:19:33,980
providing equally simple support but if

00:19:30,170 --> 00:19:37,130
to correct lifetime rules so that's all

00:19:33,980 --> 00:19:39,650
the display stuff there's this obvious

00:19:37,130 --> 00:19:41,420
laws of rendering like Geelong and

00:19:39,650 --> 00:19:45,080
things and in the kernel

00:19:41,420 --> 00:19:48,350
we have an entire bouquet of of API is

00:19:45,080 --> 00:19:50,720
created over the last ten years to make

00:19:48,350 --> 00:19:55,779
not just zero copy Burke which is what

00:19:50,720 --> 00:19:59,109
DNA before as4 that makes zero copy

00:19:55,779 --> 00:20:01,960
on synchronization and usage uses user

00:19:59,109 --> 00:20:04,749
space just submits an entire queue so

00:20:01,960 --> 00:20:08,679
you could these stuff like decode a new

00:20:04,749 --> 00:20:10,899
frame on Europe and pac-dk there in beer

00:20:08,679 --> 00:20:12,549
for Linux that's at least a D I think

00:20:10,899 --> 00:20:16,479
it's not quite managed a yeah

00:20:12,549 --> 00:20:19,840
Oh pass that to you like your OpenGL

00:20:16,479 --> 00:20:22,779
render block say something with at an

00:20:19,840 --> 00:20:25,090
impasse it either this way on the kernel

00:20:22,779 --> 00:20:28,210
using these DMA reservation and DMA

00:20:25,090 --> 00:20:32,559
fences behind the seat behind user space

00:20:28,210 --> 00:20:34,809
make sure that all all these are all

00:20:32,559 --> 00:20:36,789
these operations are all there correctly

00:20:34,809 --> 00:20:41,049
so that they don't start before the

00:20:36,789 --> 00:20:43,570
previous one has completed Oh which in

00:20:41,049 --> 00:20:45,399
extreme cases creates a graph locking

00:20:43,570 --> 00:20:47,499
problem there someone starts here and

00:20:45,399 --> 00:20:49,389
starts locking buffers and thriver

00:20:47,499 --> 00:20:50,469
states and someone starts over here and

00:20:49,389 --> 00:20:52,869
then they meet in the middle and this

00:20:50,469 --> 00:20:55,960
Noveck so we have this weight line new

00:20:52,869 --> 00:20:59,259
tax stuff in the kernel in the core

00:20:55,960 --> 00:21:01,799
kernel actually which allows you t to

00:20:59,259 --> 00:21:04,210
solve generate graph locking problems i

00:21:01,799 --> 00:21:06,999
can just have an arbitrary set of

00:21:04,210 --> 00:21:10,149
buffers oh whatever you want and just

00:21:06,999 --> 00:21:12,969
lock them in any arbitrary away and it

00:21:10,149 --> 00:21:15,419
does reliably detect their locks and get

00:21:12,969 --> 00:21:20,919
you out of a bind

00:21:15,419 --> 00:21:24,369
there's motivated by Balcon the the DRM

00:21:20,919 --> 00:21:28,320
sync objects which is is kind of these

00:21:24,369 --> 00:21:32,469
DMA fences for ordering concurrent

00:21:28,320 --> 00:21:38,019
things in a kind of more modern way that

00:21:32,469 --> 00:21:40,299
that fits in the spirit of walking or if

00:21:38,019 --> 00:21:42,460
you do all that sharing drivers also

00:21:40,299 --> 00:21:46,149
need to agree on what the data actually

00:21:42,460 --> 00:21:48,940
looks like there's no reasonably useful

00:21:46,149 --> 00:21:50,769
standard in depth so in the in the

00:21:48,940 --> 00:21:55,239
graphics subsystem we created our own

00:21:50,769 --> 00:21:56,309
for C C span it which is officially used

00:21:55,239 --> 00:22:01,539
by OpenGL

00:21:56,309 --> 00:22:04,280
egl and Vulcan and we have modifiers for

00:22:01,539 --> 00:22:07,010
stuff like tiling formats

00:22:04,280 --> 00:22:09,680
or framed off the compressions of the

00:22:07,010 --> 00:22:11,480
arm frame before compression eyes now

00:22:09,680 --> 00:22:13,610
it's now supported by quite a lot of

00:22:11,480 --> 00:22:16,040
drivers so you cannot just do serie copy

00:22:13,610 --> 00:22:19,370
but you can do serie copy of compressed

00:22:16,040 --> 00:22:22,940
data iso safety saving more memory

00:22:19,370 --> 00:22:24,890
bandwidth and so this this is kind of

00:22:22,940 --> 00:22:28,130
all that that all boss all day the use

00:22:24,890 --> 00:22:31,820
of space irrelevant pieces we also have

00:22:28,130 --> 00:22:36,020
a lot of helpers for implementing these

00:22:31,820 --> 00:22:38,060
drivers a scaler a TT m is kind of the

00:22:36,020 --> 00:22:41,540
memory my natural one of the memory

00:22:38,060 --> 00:22:45,170
manager which is a bit monolithic on is

00:22:41,540 --> 00:22:47,260
seeing a lot of refactoring we have

00:22:45,170 --> 00:22:50,090
around helpers so for kind of yoked

00:22:47,260 --> 00:22:52,370
chips that still seem to survive which

00:22:50,090 --> 00:22:57,200
have a little bit of onboard video

00:22:52,370 --> 00:22:59,600
memory although I think most of that is

00:22:57,200 --> 00:23:02,000
moving just to the panels but not always

00:22:59,600 --> 00:23:04,700
so you can manage that and then the ash

00:23:02,000 --> 00:23:09,170
man so the shared memory helpers which

00:23:04,700 --> 00:23:11,450
is for all that ICC's normal memory and

00:23:09,170 --> 00:23:15,130
as usual like under this place a

00:23:11,450 --> 00:23:17,960
batteries included now always like a

00:23:15,130 --> 00:23:23,600
graphics stack is is not just the kernel

00:23:17,960 --> 00:23:29,660
or there's also lots of lots stuff going

00:23:23,600 --> 00:23:32,570
on in in user space so that the big

00:23:29,660 --> 00:23:35,540
things there is is the gallium layer

00:23:32,570 --> 00:23:38,750
that we have a for brightening GL

00:23:35,540 --> 00:23:41,930
drivers so GL especially on the desktop

00:23:38,750 --> 00:23:46,250
GL side bit less on the GL es sorry

00:23:41,930 --> 00:23:48,560
there's a very old very clerk a API on

00:23:46,250 --> 00:23:50,060
this this gallium thing essentially

00:23:48,560 --> 00:23:53,030
takes that and breaks it down to

00:23:50,060 --> 00:23:57,170
something that looks a lot more more

00:23:53,030 --> 00:24:00,320
than a lot more kind of almost like

00:23:57,170 --> 00:24:03,290
bulking where you just have constant

00:24:00,320 --> 00:24:06,860
state objects and nothing changes

00:24:03,290 --> 00:24:09,140
anymore on the driver can just write

00:24:06,860 --> 00:24:12,290
these these commands too hard there and

00:24:09,140 --> 00:24:16,590
becomes a lot more simple our we have a

00:24:12,290 --> 00:24:19,919
huge compiler framework called

00:24:16,590 --> 00:24:23,120
which are very creatively it stands for

00:24:19,919 --> 00:24:31,980
new or your so new intermediate

00:24:23,120 --> 00:24:34,259
representation what's going on anyway on

00:24:31,980 --> 00:24:36,779
this dis is used by all the all the GL

00:24:34,259 --> 00:24:40,590
drivers we have reverse engineering

00:24:36,779 --> 00:24:43,320
tools which at least for some companies

00:24:40,590 --> 00:24:45,389
seem to be better and more powerful at

00:24:43,320 --> 00:24:48,470
documenting hardware than what the real

00:24:45,389 --> 00:24:50,669
other companies have and Chronister the

00:24:48,470 --> 00:24:53,970
industry standards groups that's

00:24:50,669 --> 00:24:54,690
defining GL and balkan and GL es and all

00:24:53,970 --> 00:24:56,429
these stands

00:24:54,690 --> 00:24:58,950
they're also opening up so they have an

00:24:56,429 --> 00:25:03,960
open source test suite for conformance

00:24:58,950 --> 00:25:05,610
testing you can do book reports so in

00:25:03,960 --> 00:25:10,340
the in the user space side I would also

00:25:05,610 --> 00:25:13,700
say lots of great infrastructure and

00:25:10,340 --> 00:25:17,789
didn't even students open primary so

00:25:13,700 --> 00:25:21,809
specifically for SOC since this year

00:25:17,789 --> 00:25:25,049
across the colonel and the Mesa 3d uses

00:25:21,809 --> 00:25:28,350
base stack we have mostly reverse

00:25:25,049 --> 00:25:32,129
engineer but drivers for pretty much

00:25:28,350 --> 00:25:35,340
anything you can buy in si si from the

00:25:32,129 --> 00:25:37,350
tiniest Devon Tech Horus which still

00:25:35,340 --> 00:25:41,129
don't have an iommu or anything else

00:25:37,350 --> 00:25:45,259
really up TT kind of the big SS sees

00:25:41,129 --> 00:25:45,259
that I am the and Intel are shopping o

00:25:45,529 --> 00:25:50,549
all these drivers use the gallium

00:25:48,119 --> 00:25:54,929
framework so even Intel has has not

00:25:50,549 --> 00:25:56,730
switched over to that and I think one of

00:25:54,929 --> 00:26:00,330
the most interesting stories that's

00:25:56,730 --> 00:26:03,649
happening right now is there's a bulking

00:26:00,330 --> 00:26:07,289
driver for AMD hardware the rad B driver

00:26:03,649 --> 00:26:09,119
which is not developed by AMD because

00:26:07,289 --> 00:26:11,490
they AMD one is kind of closed source

00:26:09,119 --> 00:26:13,499
throw stuff over the wall of sources

00:26:11,490 --> 00:26:17,009
whereas this one is developed by

00:26:13,499 --> 00:26:20,639
customers and community and OS release r

00:26:17,009 --> 00:26:23,850
plus a CEO again very creative name is

00:26:20,639 --> 00:26:26,100
just a AMD compiler which is a new

00:26:23,850 --> 00:26:29,340
compiler based on this newer thing

00:26:26,100 --> 00:26:34,260
as a very very small team like about a

00:26:29,340 --> 00:26:36,510
handful of people o of customers he used

00:26:34,260 --> 00:26:38,970
this like wolf is using this on their

00:26:36,510 --> 00:26:43,950
steam machines steam boxes with Linux

00:26:38,970 --> 00:26:47,310
and they're baiting I envy so just to

00:26:43,950 --> 00:26:49,140
shower that I get these helpers and all

00:26:47,310 --> 00:26:52,740
this code is in userspace

00:26:49,140 --> 00:26:53,730
or it's it's competitive against an

00:26:52,740 --> 00:26:56,670
entire company

00:26:53,730 --> 00:26:59,610
so maybe show it in too late because

00:26:56,670 --> 00:27:03,240
it's it's a frequently asked questions

00:26:59,610 --> 00:27:06,210
by MIT the kernel people insist on open

00:27:03,240 --> 00:27:08,610
source user space one is it's just a

00:27:06,210 --> 00:27:11,820
technical necessary and necessity I

00:27:08,610 --> 00:27:14,190
notice subsystems like a RDMA and I

00:27:11,820 --> 00:27:16,920
think media is also moving that way that

00:27:14,190 --> 00:27:19,320
create a lot of user space ap I agree

00:27:16,920 --> 00:27:21,810
you can't review the kernel side if you

00:27:19,320 --> 00:27:24,360
don't see the use of space and the other

00:27:21,810 --> 00:27:26,340
thing is also it's a bit of cake and eat

00:27:24,360 --> 00:27:28,650
it T have your cake and eat it a

00:27:26,340 --> 00:27:32,610
situation I mean from the upstream a

00:27:28,650 --> 00:27:36,960
customer value standardization on door

00:27:32,610 --> 00:27:41,130
if you want to do lots of or then the

00:27:36,960 --> 00:27:44,150
value add in your close user space it's

00:27:41,130 --> 00:27:48,120
kind of want to have it both ways what

00:27:44,150 --> 00:27:50,340
doesn't work so the recommendation and

00:27:48,120 --> 00:27:52,620
that's that's officially ok with

00:27:50,340 --> 00:27:57,420
everyone is if you want to do special

00:27:52,620 --> 00:27:59,130
sauce vendor lock-in in one driver you

00:27:57,420 --> 00:28:03,390
know any closest driver you can just do

00:27:59,130 --> 00:28:05,250
that but we still still require an open

00:28:03,390 --> 00:28:07,470
source implementation for users place

00:28:05,250 --> 00:28:11,730
API and so for pretty much all these

00:28:07,470 --> 00:28:13,740
chips for SSE stitch now I do all stack

00:28:11,730 --> 00:28:16,500
implementation so you're asked the right

00:28:13,740 --> 00:28:19,320
people in those companies with the right

00:28:16,500 --> 00:28:22,710
questions they can give you both a fully

00:28:19,320 --> 00:28:25,200
open source user space or like the

00:28:22,710 --> 00:28:28,710
closed source kind of standard sometimes

00:28:25,200 --> 00:28:31,250
more standard all driver running on top

00:28:28,710 --> 00:28:31,250
of upstream

00:28:31,910 --> 00:28:38,340
which leads us to the next thing so how

00:28:34,470 --> 00:28:41,490
to use to ship this because like an

00:28:38,340 --> 00:28:43,380
abstract I promise it's not just awesome

00:28:41,490 --> 00:28:45,390
upstream you can actually ship this and

00:28:43,380 --> 00:28:47,940
their recommendation I would say is

00:28:45,390 --> 00:28:49,920
definitely just do it to all stack with

00:28:47,940 --> 00:28:53,580
close source and open source use of

00:28:49,920 --> 00:28:56,520
spice both running on the one single

00:28:53,580 --> 00:28:58,200
upstream kernel driver and then there's

00:28:56,520 --> 00:29:01,740
still the problem for back polling

00:28:58,200 --> 00:29:03,840
because upstream is just not used often

00:29:01,740 --> 00:29:05,910
enough like everyone's hanging around on

00:29:03,840 --> 00:29:09,450
LTS kernels that are at least two years

00:29:05,910 --> 00:29:11,880
old on the recommendation there is don't

00:29:09,450 --> 00:29:13,740
back fault the driver that leads to

00:29:11,880 --> 00:29:16,200
Manas because then you first spend

00:29:13,740 --> 00:29:17,910
refactoring the driver and making it

00:29:16,200 --> 00:29:19,890
really small and using it all that

00:29:17,910 --> 00:29:22,110
making sure uses all the help of

00:29:19,890 --> 00:29:24,690
functions but then you you you you need

00:29:22,110 --> 00:29:27,450
a equally big back pole team that reacts

00:29:24,690 --> 00:29:29,640
all the crap it's just pointless

00:29:27,450 --> 00:29:32,040
so back for the entire subsystem that's

00:29:29,640 --> 00:29:34,140
pretty much what everyone does and from

00:29:32,040 --> 00:29:38,400
what I'm understanding the Android kind

00:29:34,140 --> 00:29:41,340
of stable kernel interface thing the GK

00:29:38,400 --> 00:29:44,070
I I think it's called will also switch

00:29:41,340 --> 00:29:48,059
that to that model so every time Android

00:29:44,070 --> 00:29:51,300
adds new kernels they'll back port the

00:29:48,059 --> 00:29:53,670
lightest upstream DRM subsystem to all

00:29:51,300 --> 00:29:58,550
their supported kernels so that you

00:29:53,670 --> 00:30:01,410
don't have to like live it old stuff

00:29:58,550 --> 00:30:05,040
also nice stuff going on on the testing

00:30:01,410 --> 00:30:06,780
side or we have lots of internal unit

00:30:05,040 --> 00:30:09,570
tests so we're very much looking forward

00:30:06,780 --> 00:30:13,470
to K unit finally having landed so we

00:30:09,570 --> 00:30:17,250
can convert them over to something more

00:30:13,470 --> 00:30:20,910
standardized be using the ITT GPU tests

00:30:17,250 --> 00:30:25,200
are tests weight which is going to

00:30:20,910 --> 00:30:28,230
across driver test suite and user space

00:30:25,200 --> 00:30:30,990
T to validate on as I mentioned for any

00:30:28,230 --> 00:30:33,390
new user space API having having

00:30:30,990 --> 00:30:35,910
validation test Suites in there is now

00:30:33,390 --> 00:30:37,350
required to kind of help make sure that

00:30:35,910 --> 00:30:40,350
all the drivers implement these

00:30:37,350 --> 00:30:43,650
interfaces the same way for validating

00:30:40,350 --> 00:30:45,360
we use ERC's from the hardware so you

00:30:43,650 --> 00:30:48,300
can render in software

00:30:45,360 --> 00:30:51,180
and then you can like for the ye we plan

00:30:48,300 --> 00:30:55,050
some there and render it using all their

00:30:51,180 --> 00:30:57,120
planes and be compared to TCR sees to

00:30:55,050 --> 00:30:59,480
make sure everyone implements at the

00:30:57,120 --> 00:31:01,560
same way and right now

00:30:59,480 --> 00:31:04,920
unfortunately not all hall there has a

00:31:01,560 --> 00:31:06,540
Searcy support some have bright back

00:31:04,920 --> 00:31:08,340
which is more powerful so right now

00:31:06,540 --> 00:31:15,290
there's this patches on the review for

00:31:08,340 --> 00:31:15,290
ITT the validation with right back I

00:31:15,680 --> 00:31:21,390
think we also have a pretty great

00:31:18,620 --> 00:31:24,030
community are they're switching over to

00:31:21,390 --> 00:31:25,890
get lap so mailing lists a death at

00:31:24,030 --> 00:31:28,500
least for everything except the colonel

00:31:25,890 --> 00:31:31,260
for the colonel it is a bits are stalled

00:31:28,500 --> 00:31:33,180
on infrastructure work but ideas very

00:31:31,260 --> 00:31:35,700
much that at least pool requests from

00:31:33,180 --> 00:31:39,060
self systems will will use get lap

00:31:35,700 --> 00:31:41,700
long-term with nicely integrated CI and

00:31:39,060 --> 00:31:44,550
I do think we will at least run

00:31:41,700 --> 00:31:47,730
experiments with opening up our good lap

00:31:44,550 --> 00:31:50,900
or pull requests kind of nice more than

00:31:47,730 --> 00:31:55,800
integrated review code change and CI

00:31:50,900 --> 00:31:58,800
solutions for contributors our

00:31:55,800 --> 00:32:01,860
conference which is called ecstasy is

00:31:58,800 --> 00:32:04,020
also nicely growing and the going full

00:32:01,860 --> 00:32:09,330
professional now we have sponsor since

00:32:04,020 --> 00:32:13,170
since last year o slide Outlook or DMA

00:32:09,330 --> 00:32:16,530
buff heaps which formerly still called

00:32:13,170 --> 00:32:20,490
ion is in staging is getting D stashed

00:32:16,530 --> 00:32:24,870
on I'm hearing it's happening real see

00:32:20,490 --> 00:32:26,220
now that's I think in version 7 or so so

00:32:24,870 --> 00:32:28,620
hopefully one of the next Colonel

00:32:26,220 --> 00:32:32,070
resistors will have happened or there's

00:32:28,620 --> 00:32:34,200
a lot of work going on or and kind of

00:32:32,070 --> 00:32:36,240
use of space allocators I mean it's it's

00:32:34,200 --> 00:32:38,550
nice if you in theory can share

00:32:36,240 --> 00:32:40,380
compressed buffers this you're a copy

00:32:38,550 --> 00:32:43,560
between drivers but if you know one can

00:32:40,380 --> 00:32:45,210
figure out that this is possible it's a

00:32:43,560 --> 00:32:47,220
bit of tough soul on the current

00:32:45,210 --> 00:32:50,730
solution I think we found Reuters you

00:32:47,220 --> 00:32:53,040
just hard coded in growl ah ah doesn't

00:32:50,730 --> 00:32:56,600
work so well on desktop and doesn't

00:32:53,040 --> 00:32:58,830
really great design for for SS easy to

00:32:56,600 --> 00:33:01,200
saw there's this

00:32:58,830 --> 00:33:04,860
quite a bit going on there and another

00:33:01,200 --> 00:33:08,930
thing that's not ready in patch form yet

00:33:04,860 --> 00:33:11,310
there's lots of discussion going on is

00:33:08,930 --> 00:33:15,870
integration with kind of the media side

00:33:11,310 --> 00:33:17,850
which is solving a lot of the same

00:33:15,870 --> 00:33:20,040
problems around buffer firmance and

00:33:17,850 --> 00:33:23,610
sharing buffers and integrating in all

00:33:20,040 --> 00:33:26,580
antonova viral pipeline there sometimes

00:33:23,610 --> 00:33:30,360
they have a nice solution or sometimes

00:33:26,580 --> 00:33:32,940
like the display side the DRM subsystem

00:33:30,360 --> 00:33:35,790
sign has a better solution or kind of

00:33:32,940 --> 00:33:38,400
more experience and it will be nice to

00:33:35,790 --> 00:33:41,940
somehow figure out how we can get these

00:33:38,400 --> 00:33:45,150
T sub systems to work together a bit

00:33:41,940 --> 00:33:47,580
more closely but the details are I think

00:33:45,150 --> 00:33:51,270
entirely up in the air Hannover look

00:33:47,580 --> 00:33:53,940
like so summary are DRM the the graphics

00:33:51,270 --> 00:33:56,100
subsystem in in upstream it scales by a

00:33:53,940 --> 00:34:00,030
factor of ten thousands from the tiniest

00:33:56,100 --> 00:34:02,520
to the biggest I really think like

00:34:00,030 --> 00:34:07,380
nowadays we have batteries included for

00:34:02,520 --> 00:34:09,990
everything oh for shipping I would say

00:34:07,380 --> 00:34:12,810
that the standard is to do all stack you

00:34:09,990 --> 00:34:17,970
have your one single upstream kernel

00:34:12,810 --> 00:34:19,950
driver for GL and GL es on you have or

00:34:17,970 --> 00:34:22,860
do all stack in userspace with the

00:34:19,950 --> 00:34:26,310
reverse engineer mostly most often

00:34:22,860 --> 00:34:30,090
reverse engineered driver to kind of

00:34:26,310 --> 00:34:33,470
justify the user space API and the close

00:34:30,090 --> 00:34:36,179
sort of stack with all the value-add and

00:34:33,470 --> 00:34:38,010
for shipping second point is you just

00:34:36,179 --> 00:34:43,169
back both the entire subsystem that's

00:34:38,010 --> 00:34:45,500
what everyone does and that's it I think

00:34:43,169 --> 00:34:45,500
we have

00:34:46,169 --> 00:34:52,840
maybe no time for questions but perhaps

00:34:49,149 --> 00:34:55,650
if there's a very short one otherwise

00:34:52,840 --> 00:35:00,619
thanks a lot for listening

00:34:55,650 --> 00:35:00,619

YouTube URL: https://www.youtube.com/watch?v=kVzHOgt6WGE


