Title: Keylime - An Open Source TPM Project for Remote Trust of IoT - Luke Hinds, Red Hat
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Keylime - An Open Source TPM Project for Remote Trust of IoT - Luke Hinds, Red Hat

Keylime (keylime.dev) is a young, rapidly growing open source project originally created in the security research department of MIT's Lincoln Laboratory. It provides a way of measuring the cryptographic hardware root of trust of devices hosting an Trusted Platform Module (TPM) chip. Keylime is about making TPM technology accessible for developers and users. It handles the complexity, you drive the use case!
Captions: 
	00:00:00,000 --> 00:00:05,940
okay appreciate that everybody so my

00:00:02,879 --> 00:00:08,220
name is Luke wines and we're going to be

00:00:05,940 --> 00:00:11,639
doing a talk on a new project called

00:00:08,220 --> 00:00:13,710
keyline okay so I'll go into the ins and

00:00:11,639 --> 00:00:19,350
the ins and outs of what Key Lime is and

00:00:13,710 --> 00:00:22,529
and what it covers so quick intro so I'm

00:00:19,350 --> 00:00:26,730
a security engineer I work at Red Hat in

00:00:22,529 --> 00:00:28,980
the office of technology and being

00:00:26,730 --> 00:00:32,540
around security for a good number of

00:00:28,980 --> 00:00:36,780
years now mainly talling and

00:00:32,540 --> 00:00:39,120
vulnerability management and research so

00:00:36,780 --> 00:00:41,040
I recently joined the product Security

00:00:39,120 --> 00:00:43,680
Committee for kubernetes but I've done

00:00:41,040 --> 00:00:47,840
stuff in OpenStack and opendaylight in

00:00:43,680 --> 00:00:51,600
various open source security committees

00:00:47,840 --> 00:00:55,410
I live in Wiltshire in the UK it's a

00:00:51,600 --> 00:00:57,510
it's a rural area it's mainly software

00:00:55,410 --> 00:01:00,719
developers and farmers as about as much

00:00:57,510 --> 00:01:02,460
as you gather and and I'm a keen runner

00:01:00,719 --> 00:01:04,350
as well so if anybody wants to talk

00:01:02,460 --> 00:01:11,909
running I could probably talk about that

00:01:04,350 --> 00:01:13,890
all night so yep okay so let's let's

00:01:11,909 --> 00:01:15,270
define the problem what is it that we're

00:01:13,890 --> 00:01:17,070
actually looking at here because because

00:01:15,270 --> 00:01:20,340
without a problem you can't really have

00:01:17,070 --> 00:01:24,869
a solution can you so essentially we're

00:01:20,340 --> 00:01:31,290
talking about remote IOT trust okay now

00:01:24,869 --> 00:01:33,659
that the key take from here is is the

00:01:31,290 --> 00:01:37,350
remote parts so with IOT consider that

00:01:33,659 --> 00:01:39,150
devices are often in physically easily

00:01:37,350 --> 00:01:41,340
accessible places so they you know they

00:01:39,150 --> 00:01:45,240
can be tampered with they're not within

00:01:41,340 --> 00:01:46,979
a secure place like a data center or an

00:01:45,240 --> 00:01:49,110
office a lot of the time we might be

00:01:46,979 --> 00:01:52,530
talking about units that are up in the

00:01:49,110 --> 00:01:55,530
in the roof or outside or and situated

00:01:52,530 --> 00:01:58,250
in areas where it's very difficult to

00:01:55,530 --> 00:02:01,200
maintain a level of physical security

00:01:58,250 --> 00:02:03,719
and from that physical security the

00:02:01,200 --> 00:02:07,490
actual software security itself because

00:02:03,719 --> 00:02:07,490
people can access that device

00:02:07,570 --> 00:02:12,040
so if we consider the security we want

00:02:10,630 --> 00:02:14,730
to see if I can turn this round because

00:02:12,040 --> 00:02:17,950
I can't see the can't see my own slides

00:02:14,730 --> 00:02:21,520
okay so first of all we have physical

00:02:17,950 --> 00:02:24,460
protections so if we have a unit it's

00:02:21,520 --> 00:02:26,410
not very economical to have a human

00:02:24,460 --> 00:02:29,260
watch over it all the time so you know

00:02:26,410 --> 00:02:32,320
security guards CCTV all of these things

00:02:29,260 --> 00:02:34,270
are not going to work there is various

00:02:32,320 --> 00:02:37,480
types of tamper prevention that you can

00:02:34,270 --> 00:02:40,959
use so these adhesives can be used to

00:02:37,480 --> 00:02:45,480
seal the box you get special security

00:02:40,959 --> 00:02:47,800
bits talks these are like screwdrivers

00:02:45,480 --> 00:02:50,440
typically your don't know what they've

00:02:47,800 --> 00:02:52,330
you know whether this is a universal

00:02:50,440 --> 00:02:54,550
term but where the Philips and a

00:02:52,330 --> 00:02:57,190
flathead and and they had these sort of

00:02:54,550 --> 00:03:00,370
talks where they're these variations of

00:02:57,190 --> 00:03:02,080
screw heads again really they're not

00:03:00,370 --> 00:03:03,940
really going to provide any decent level

00:03:02,080 --> 00:03:05,620
of security and then you have tamper

00:03:03,940 --> 00:03:07,690
monitoring which is effectively where

00:03:05,620 --> 00:03:09,910
there's trip switches so if you open the

00:03:07,690 --> 00:03:13,209
device it would trigger off on a note

00:03:09,910 --> 00:03:17,500
now the problem with physical protection

00:03:13,209 --> 00:03:19,000
schemes is it's a game of cat and mouse

00:03:17,500 --> 00:03:21,970
so eventually somebody's going to get

00:03:19,000 --> 00:03:23,850
hold of it there's going to be a design

00:03:21,970 --> 00:03:26,170
flaw that's not originally anticipated

00:03:23,850 --> 00:03:28,209
and somebody's going to be able to open

00:03:26,170 --> 00:03:30,190
the unit and bypass the security

00:03:28,209 --> 00:03:32,440
protections that you have and if we look

00:03:30,190 --> 00:03:34,780
at safe braking the history of safe

00:03:32,440 --> 00:03:37,870
braking you know it's just a continuous

00:03:34,780 --> 00:03:40,450
cycle of more security and then somebody

00:03:37,870 --> 00:03:44,280
circumvent our security then we also

00:03:40,450 --> 00:03:47,260
have software security so we have

00:03:44,280 --> 00:03:50,100
mandatory access control discretionary

00:03:47,260 --> 00:03:54,580
so we have our standard permissions

00:03:50,100 --> 00:03:57,070
selinux or a palmer labels and we had

00:03:54,580 --> 00:04:00,340
couldn't have cryptographic Authority so

00:03:57,070 --> 00:04:01,450
we can sign objects we can look at the

00:04:00,340 --> 00:04:03,280
hash and then

00:04:01,450 --> 00:04:05,050
prepare and then make a decision that

00:04:03,280 --> 00:04:08,500
somebody's not tampered with that

00:04:05,050 --> 00:04:10,989
particular hash to suggest US Trustee

00:04:08,500 --> 00:04:13,300
and then there's obviously like

00:04:10,989 --> 00:04:15,730
integrity verification systems tripwire

00:04:13,300 --> 00:04:17,859
and aid and there's many I mean we could

00:04:15,730 --> 00:04:19,780
go on all day about the various sort of

00:04:17,859 --> 00:04:23,710
software security solutions that there

00:04:19,780 --> 00:04:27,100
are but again the problem is the

00:04:23,710 --> 00:04:29,020
software trust is it resides either in

00:04:27,100 --> 00:04:31,120
the memory or in the disk so if there's

00:04:29,020 --> 00:04:33,250
a private key that will be resident in

00:04:31,120 --> 00:04:35,500
the memory what will be in the disk and

00:04:33,250 --> 00:04:37,600
and and so that can be accessed it could

00:04:35,500 --> 00:04:40,300
be tampered it can be spoofed and so

00:04:37,600 --> 00:04:43,210
forth and then the other aspect is

00:04:40,300 --> 00:04:44,770
you're at the mercy of the lower levels

00:04:43,210 --> 00:04:46,990
of the stack so what do I mean by that

00:04:44,770 --> 00:04:49,560
if we take for example that we're

00:04:46,990 --> 00:04:51,970
talking about a remote device here

00:04:49,560 --> 00:04:54,610
essentially you have a chain of trust

00:04:51,970 --> 00:04:56,860
from the firmware the bootloader or the

00:04:54,610 --> 00:04:59,320
shim you're in it Rama first your kernel

00:04:56,860 --> 00:05:01,630
your modules your user land and your

00:04:59,320 --> 00:05:03,510
runtime so again if we think about we've

00:05:01,630 --> 00:05:07,419
got a device that we've remotely

00:05:03,510 --> 00:05:09,280
instantiated and provisioned you can

00:05:07,419 --> 00:05:11,860
really only see the latter stages of

00:05:09,280 --> 00:05:13,810
that instantiation so you can you know

00:05:11,860 --> 00:05:17,229
you can log in with a shell session you

00:05:13,810 --> 00:05:19,600
can move around you can change accounts

00:05:17,229 --> 00:05:21,490
but you can't really get an implicit

00:05:19,600 --> 00:05:24,010
level of trust in the level and lower

00:05:21,490 --> 00:05:27,070
levels of the stack itself you have to

00:05:24,010 --> 00:05:31,539
kind of make a noose level of trust in

00:05:27,070 --> 00:05:32,820
that so this brings us on to a hardware

00:05:31,539 --> 00:05:37,120
root of trust

00:05:32,820 --> 00:05:39,070
aka trusted platform modules now I'm not

00:05:37,120 --> 00:05:40,750
really going to go into the deep ins and

00:05:39,070 --> 00:05:42,940
outs of TPM there's probably a few

00:05:40,750 --> 00:05:45,400
people here that mean well know them

00:05:42,940 --> 00:05:47,530
even better than I do so we're just

00:05:45,400 --> 00:05:50,430
going to do a 101 just to bring those up

00:05:47,530 --> 00:05:54,220
to speed that are new to the technology

00:05:50,430 --> 00:05:56,200
so it's a it's a specialized chip it's

00:05:54,220 --> 00:05:59,200
not a crypto accelerator

00:05:56,200 --> 00:06:01,479
it's just has a very simple engine that

00:05:59,200 --> 00:06:04,660
can perform certain operations such as

00:06:01,479 --> 00:06:08,080
sign-in and hashing and so forth it has

00:06:04,660 --> 00:06:10,180
an RSA key pair that it's it's

00:06:08,080 --> 00:06:11,580
inaccessible to software it's only a

00:06:10,180 --> 00:06:15,090
particular bus

00:06:11,580 --> 00:06:17,400
that can connect to perform requests for

00:06:15,090 --> 00:06:19,470
various operations now there's there's

00:06:17,400 --> 00:06:22,320
actually multiple keys there's an

00:06:19,470 --> 00:06:24,060
intensity key there's a station after

00:06:22,320 --> 00:06:26,970
station key and you can create your own

00:06:24,060 --> 00:06:29,970
keys from that but essentially that the

00:06:26,970 --> 00:06:33,810
key part to consider here is that the

00:06:29,970 --> 00:06:35,340
private counterpart is siloed and is

00:06:33,810 --> 00:06:40,670
within that chip and it can't be

00:06:35,340 --> 00:06:42,750
accessed the TPM is able to hash

00:06:40,670 --> 00:06:44,550
critical sections of firmware and

00:06:42,750 --> 00:06:46,200
software so by hash we're talking

00:06:44,550 --> 00:06:48,990
effectively just creating a

00:06:46,200 --> 00:06:53,060
cryptographic hash okay to show the

00:06:48,990 --> 00:06:56,190
state of that particular object but the

00:06:53,060 --> 00:06:58,410
extra part that a TPM can do is it can

00:06:56,190 --> 00:07:00,390
make those hashes public and it will

00:06:58,410 --> 00:07:03,360
sign them with the private key which

00:07:00,390 --> 00:07:06,780
remember is physically inaccessible

00:07:03,360 --> 00:07:10,110
within the TPM chip to itself so using

00:07:06,780 --> 00:07:12,300
the public key you can verify that the

00:07:10,110 --> 00:07:13,740
hash list has been signed by a TPM and

00:07:12,300 --> 00:07:15,960
it's not being tampered with because

00:07:13,740 --> 00:07:18,600
obviously if it's been tampered then it

00:07:15,960 --> 00:07:20,160
would break the cryptography so that's

00:07:18,600 --> 00:07:22,710
effectively something that we call an

00:07:20,160 --> 00:07:24,600
event lock and with this event log being

00:07:22,710 --> 00:07:27,060
made public you can then do something

00:07:24,600 --> 00:07:30,390
called remote attestation so you can

00:07:27,060 --> 00:07:32,400
remotely outside of the device look at

00:07:30,390 --> 00:07:34,770
the hash measurements be sure that a TPM

00:07:32,400 --> 00:07:37,200
actually sign that hash list and then

00:07:34,770 --> 00:07:43,970
verify the integrity of the system

00:07:37,200 --> 00:07:46,950
remotely so some of the usages for a TPM

00:07:43,970 --> 00:07:48,020
it's quite commonly used for disk

00:07:46,950 --> 00:07:51,960
encryption

00:07:48,020 --> 00:07:54,390
so if device was removed from for

00:07:51,960 --> 00:07:56,430
example from a laptop the TPM would no

00:07:54,390 --> 00:07:59,130
longer be a be present so you would be

00:07:56,430 --> 00:08:02,070
able to get the data from the drive it's

00:07:59,130 --> 00:08:05,490
also used for a password key protection

00:08:02,070 --> 00:08:08,640
machine identification it's been used in

00:08:05,490 --> 00:08:11,460
gaming to stop people cheating and then

00:08:08,640 --> 00:08:13,680
as certainly a platform integrity which

00:08:11,460 --> 00:08:15,900
is what we're interested in here that's

00:08:13,680 --> 00:08:18,650
a particular use of the TPM that we're

00:08:15,900 --> 00:08:18,650
using in key line

00:08:19,750 --> 00:08:26,260
okay so what is key line so key lime is

00:08:23,920 --> 00:08:31,090
a project that provides open source

00:08:26,260 --> 00:08:34,360
remote attestation it was originally

00:08:31,090 --> 00:08:36,640
devised in MIT Lincoln labs in this they

00:08:34,360 --> 00:08:39,270
have a security team there they came up

00:08:36,640 --> 00:08:42,039
with the white paper that cryptographic

00:08:39,270 --> 00:08:44,110
relations that we used and they put

00:08:42,039 --> 00:08:46,360
together some Ernie code as a proof of

00:08:44,110 --> 00:08:48,700
concept and since then it's become an

00:08:46,360 --> 00:08:54,070
open-source project which there is

00:08:48,700 --> 00:08:58,050
different people are working on so

00:08:54,070 --> 00:09:02,560
keyline provides a measured boot so

00:08:58,050 --> 00:09:04,990
again the TPM will measure various

00:09:02,560 --> 00:09:07,780
artifacts such as the firmware the

00:09:04,990 --> 00:09:13,900
bootloader you're in it Rama fest your

00:09:07,780 --> 00:09:16,690
kernel your modules and then that list

00:09:13,900 --> 00:09:19,780
of hashes is made public and then you

00:09:16,690 --> 00:09:21,550
can verify that nobody is tempered with

00:09:19,780 --> 00:09:22,750
any of those particular objects now

00:09:21,550 --> 00:09:25,150
there's a bit more to it than that

00:09:22,750 --> 00:09:27,760
there's a an extend operation it's a

00:09:25,150 --> 00:09:30,970
one-way hash so hashes are concatenated

00:09:27,760 --> 00:09:34,900
together and then they rehashed and this

00:09:30,970 --> 00:09:36,430
provides a level of assurity because

00:09:34,900 --> 00:09:42,390
it's very difficult to go back on a

00:09:36,430 --> 00:09:46,450
one-way function it also provides remote

00:09:42,390 --> 00:09:48,760
runtime attestation so in the kernel

00:09:46,450 --> 00:09:51,040
there's integrity measurement

00:09:48,760 --> 00:09:53,140
architecture okay and it's been

00:09:51,040 --> 00:09:59,190
something in the kernel since I think

00:09:53,140 --> 00:10:01,270
linux 2.6 kernel 2.6 and IMA is

00:09:59,190 --> 00:10:05,170
effectively it's a subsystem where

00:10:01,270 --> 00:10:07,990
whenever a certain action occurs and a

00:10:05,170 --> 00:10:12,000
system call happens so I have here B PRM

00:10:07,990 --> 00:10:15,250
and map SC Linux labels have changed

00:10:12,000 --> 00:10:17,230
files are executed as various policies

00:10:15,250 --> 00:10:20,260
that you can set up and what will happen

00:10:17,230 --> 00:10:23,800
is when that occurs the hash will be

00:10:20,260 --> 00:10:29,320
captured it will be put into a security

00:10:23,800 --> 00:10:32,200
FS and then the TPM will perform

00:10:29,320 --> 00:10:35,730
and extend on that hash so I build up

00:10:32,200 --> 00:10:37,839
that cryptographic hash tree again and

00:10:35,730 --> 00:10:40,660
what one of the things we do with key

00:10:37,839 --> 00:10:43,209
lime is we can continuously monitor that

00:10:40,660 --> 00:10:45,519
list as is populated and compare it to a

00:10:43,209 --> 00:10:48,190
whitelist of values that we consider

00:10:45,519 --> 00:10:50,560
good so we have like a golden statement

00:10:48,190 --> 00:10:52,300
we want the system to be in and we can

00:10:50,560 --> 00:10:54,100
then tell if somebody is remotely

00:10:52,300 --> 00:10:56,350
executed something that we don't have

00:10:54,100 --> 00:10:59,260
whitelisted or they've changed something

00:10:56,350 --> 00:11:02,079
or they've changed Nestle in its label

00:10:59,260 --> 00:11:04,600
then we can know within a matter of

00:11:02,079 --> 00:11:06,399
seconds that the machines being

00:11:04,600 --> 00:11:10,480
compromised and then start to take an

00:11:06,399 --> 00:11:14,380
action we also can do encrypted payloads

00:11:10,480 --> 00:11:16,240
so what we do here is effectively we

00:11:14,380 --> 00:11:19,839
monitor the machine so we can monitor

00:11:16,240 --> 00:11:25,300
the boot monitor the runtime with ima

00:11:19,839 --> 00:11:27,630
and then if the cryptographic state of

00:11:25,300 --> 00:11:30,459
that machine is as we expect it to be

00:11:27,630 --> 00:11:31,930
then we can unload an encrypted payload

00:11:30,459 --> 00:11:33,449
on that machine so that could be

00:11:31,930 --> 00:11:36,670
effectively that could be some

00:11:33,449 --> 00:11:39,550
certificates and secrets perhaps a

00:11:36,670 --> 00:11:43,019
config file that has database password

00:11:39,550 --> 00:11:47,050
strings any sort of sensitive data and

00:11:43,019 --> 00:11:49,510
we also have a revocation framework so

00:11:47,050 --> 00:11:51,040
when a node fails a state there's a

00:11:49,510 --> 00:11:53,620
series of actions that you can take

00:11:51,040 --> 00:11:54,970
afterwards and I'll go into those a bit

00:11:53,620 --> 00:12:01,209
more we've got some more details on

00:11:54,970 --> 00:12:04,660
those so this is the the architecture so

00:12:01,209 --> 00:12:08,860
the way to consider this is that over to

00:12:04,660 --> 00:12:11,680
the to your right we effectively have

00:12:08,860 --> 00:12:14,769
the remote domain so this is where our

00:12:11,680 --> 00:12:17,760
IOT devices and then over to your left

00:12:14,769 --> 00:12:20,610
we have on-premise so these would be

00:12:17,760 --> 00:12:23,260
systems that you have within your local

00:12:20,610 --> 00:12:26,740
control perhaps within your your your

00:12:23,260 --> 00:12:30,899
home network first of all we had the

00:12:26,740 --> 00:12:34,000
verifier so the verify continuously

00:12:30,899 --> 00:12:36,970
monitors the integrity state of the

00:12:34,000 --> 00:12:39,940
agent which runs on the actual node that

00:12:36,970 --> 00:12:40,820
we wish to monitor this is where all of

00:12:39,940 --> 00:12:43,160
the cryptograph

00:12:40,820 --> 00:12:46,250
verification happens for the boot and

00:12:43,160 --> 00:12:49,520
run time and so forth and for anybody

00:12:46,250 --> 00:12:53,440
interested in TPMS this continuously

00:12:49,520 --> 00:12:56,780
polls a TPM quote which is where

00:12:53,440 --> 00:13:00,020
effectively we request a quote from the

00:12:56,780 --> 00:13:04,340
TPM on the current cryptographic state

00:13:00,020 --> 00:13:06,800
machine we have a register where we keep

00:13:04,340 --> 00:13:09,170
the public keys that the TPM

00:13:06,800 --> 00:13:12,260
manufacturers provide that can be used

00:13:09,170 --> 00:13:14,960
to attest the signatures that we get

00:13:12,260 --> 00:13:17,240
back and we also register the agent

00:13:14,960 --> 00:13:19,070
there we have a simple database and then

00:13:17,240 --> 00:13:21,050
we have a revocation service which is

00:13:19,070 --> 00:13:24,530
the framework where we can kick off

00:13:21,050 --> 00:13:28,040
specific events that occur should unload

00:13:24,530 --> 00:13:29,420
fairness integrity state and then we can

00:13:28,040 --> 00:13:33,950
also interface with a certificate

00:13:29,420 --> 00:13:36,080
authority so for example CF SSL so again

00:13:33,950 --> 00:13:38,030
if a machine fails its state then we

00:13:36,080 --> 00:13:40,820
could revoke a certificate which in turn

00:13:38,030 --> 00:13:45,530
will perhaps strip down all the TLS or

00:13:40,820 --> 00:13:47,480
IPSec connections and last of all quite

00:13:45,530 --> 00:13:49,520
interesting some of you may have noticed

00:13:47,480 --> 00:13:52,700
in the middle it says HTTP that's

00:13:49,520 --> 00:13:55,280
intentionally put there because we don't

00:13:52,700 --> 00:13:57,290
have any secrets at all that pass across

00:13:55,280 --> 00:13:59,480
this connection so this can actually be

00:13:57,290 --> 00:14:01,760
open because it's effectively all that

00:13:59,480 --> 00:14:04,190
comes back as a TPM quote with a nonce

00:14:01,760 --> 00:14:07,070
and if somebody tried to tamper with

00:14:04,190 --> 00:14:08,390
that it would break the cryptography and

00:14:07,070 --> 00:14:11,060
then though it would be seen as failed

00:14:08,390 --> 00:14:17,240
so we have no reason to protect that

00:14:11,060 --> 00:14:20,960
connection at all ok so it can be

00:14:17,240 --> 00:14:24,230
deployed in many different architectural

00:14:20,960 --> 00:14:27,560
models so a single site to a single node

00:14:24,230 --> 00:14:30,860
or device a single site to many many

00:14:27,560 --> 00:14:32,870
many different devices or nodes a

00:14:30,860 --> 00:14:34,730
multi-site multi node so you could

00:14:32,870 --> 00:14:38,060
connect multiple data centers together

00:14:34,730 --> 00:14:41,390
and then have a whole many many

00:14:38,060 --> 00:14:43,910
relationship of of nodes it works very

00:14:41,390 --> 00:14:46,370
well within multi tenant within a cloud

00:14:43,910 --> 00:14:49,160
scenario where I would be a cloud

00:14:46,370 --> 00:14:51,980
consumer I would have a workload that

00:14:49,160 --> 00:14:55,490
has a sensitive

00:14:51,980 --> 00:14:57,830
angle to it and I can effectively ask a

00:14:55,490 --> 00:15:00,800
cloud provider can I trust your hardware

00:14:57,830 --> 00:15:02,900
so I can remotely test their hardware if

00:15:00,800 --> 00:15:04,850
I can trust it then I can schedule my

00:15:02,900 --> 00:15:10,460
load to execute on that that particular

00:15:04,850 --> 00:15:12,350
hypervisor and multiple can attest a

00:15:10,460 --> 00:15:15,980
single node so you could effectively

00:15:12,350 --> 00:15:18,140
have a like a a user a tester machine

00:15:15,980 --> 00:15:22,850
and then the provider of that machine

00:15:18,140 --> 00:15:24,380
would test the machine as well okay so

00:15:22,850 --> 00:15:27,290
let's have a look at some of the use

00:15:24,380 --> 00:15:30,950
cases so the first one is where we

00:15:27,290 --> 00:15:34,250
actually bootstrap the machine and then

00:15:30,950 --> 00:15:37,960
we tag on it's not mandatory but we're

00:15:34,250 --> 00:15:43,550
going to tag on an encrypted payload

00:15:37,960 --> 00:15:44,870
okay so again we have our at the bottom

00:15:43,550 --> 00:15:46,310
we've got our machine that we're

00:15:44,870 --> 00:15:49,010
monitoring and this is running the

00:15:46,310 --> 00:15:51,200
keylime agent okay and this has a TPM

00:15:49,010 --> 00:15:53,660
chip and then at the top we had the

00:15:51,200 --> 00:15:55,370
verifier which performs the cryptic rock

00:15:53,660 --> 00:15:57,830
with the current excuse me the

00:15:55,370 --> 00:15:59,570
cryptographic verification and then we

00:15:57,830 --> 00:16:02,390
have the register where we register the

00:15:59,570 --> 00:16:06,050
load and we keep the public TPM keys and

00:16:02,390 --> 00:16:08,690
then over to the far right here we have

00:16:06,050 --> 00:16:10,160
our user and they're going to use

00:16:08,690 --> 00:16:11,840
something called the key line tell'em

00:16:10,160 --> 00:16:14,030
which is effectively just a CLI

00:16:11,840 --> 00:16:15,950
application that we provide but there's

00:16:14,030 --> 00:16:18,020
REST API so all of this as well so you

00:16:15,950 --> 00:16:20,960
could develop your own system to

00:16:18,020 --> 00:16:22,820
integrate with key line and what's going

00:16:20,960 --> 00:16:28,600
to happen is using this key lime tenant

00:16:22,820 --> 00:16:32,590
the the user is going to create a key

00:16:28,600 --> 00:16:32,590
just check on my keys

00:16:43,430 --> 00:16:47,519
okay I don't know why I've brought it

00:16:45,810 --> 00:16:49,800
out a full-screen mode because my keys

00:16:47,519 --> 00:16:52,139
disappeared I've got my keys back right

00:16:49,800 --> 00:16:54,750
so effectively what's going to happen is

00:16:52,139 --> 00:16:56,660
we're going to create the key okay and

00:16:54,750 --> 00:16:59,610
this is called the bootstrap key and

00:16:56,660 --> 00:17:02,389
this is going to be cryptographic to be

00:16:59,610 --> 00:17:05,730
split into two pieces

00:17:02,389 --> 00:17:08,579
now we're going to call these V and u

00:17:05,730 --> 00:17:11,459
first of all we're going to delegate to

00:17:08,579 --> 00:17:14,400
the verifier that we want to monitor the

00:17:11,459 --> 00:17:16,829
integrity of a machine so we're going to

00:17:14,400 --> 00:17:20,189
send them the V counterpart of the key

00:17:16,829 --> 00:17:23,250
that's being split into two then we're

00:17:20,189 --> 00:17:25,500
going to send the you half to the device

00:17:23,250 --> 00:17:28,380
itself which is running the key lime

00:17:25,500 --> 00:17:31,260
agent we're then going to ask the

00:17:28,380 --> 00:17:34,010
verifier to perform an integrity check

00:17:31,260 --> 00:17:36,570
so it's going to perform a TPM quote

00:17:34,010 --> 00:17:39,750
onto the agent which is then going to

00:17:36,570 --> 00:17:42,690
communicate to the TPM itself using a

00:17:39,750 --> 00:17:46,559
TPM to software stack what's going to

00:17:42,690 --> 00:17:49,740
happen is if that integrity is shown to

00:17:46,559 --> 00:17:51,299
be sound in that we know that nothing

00:17:49,740 --> 00:17:53,970
has been tampered with it

00:17:51,299 --> 00:17:56,610
cryptographically checks out then the

00:17:53,970 --> 00:17:59,309
second part of the key is going to be

00:17:56,610 --> 00:18:01,679
provided to the agent who can then put

00:17:59,309 --> 00:18:05,340
these together and then has the

00:18:01,679 --> 00:18:08,940
bootstrap key to be able to unencrypted

00:18:05,340 --> 00:18:10,760
the payload now this payload it could be

00:18:08,940 --> 00:18:15,360
something that we send over the wire or

00:18:10,760 --> 00:18:17,100
it could be stored within an OS image so

00:18:15,360 --> 00:18:20,100
it could be embedded into the image

00:18:17,100 --> 00:18:22,770
itself whether that be an IR so cue Cal

00:18:20,100 --> 00:18:25,110
2 or whatever format you have so the

00:18:22,770 --> 00:18:29,400
keys are recombined by the agent and

00:18:25,110 --> 00:18:32,220
then it's able to execute the payload

00:18:29,400 --> 00:18:35,909
and safely have the secrets delivered to

00:18:32,220 --> 00:18:39,270
the device so for example if this device

00:18:35,909 --> 00:18:41,850
failed the verification then our V

00:18:39,270 --> 00:18:44,700
counterpart of the key is not going to

00:18:41,850 --> 00:18:45,809
be made available to the agent and the

00:18:44,700 --> 00:18:47,280
agent is not going to be able to do

00:18:45,809 --> 00:18:48,450
anything with that information so

00:18:47,280 --> 00:18:50,520
effectively if somebody hacked the

00:18:48,450 --> 00:18:51,389
Machine they're not going to be able to

00:18:50,520 --> 00:18:54,989
get hold of you'll see

00:18:51,389 --> 00:18:57,919
grits so that's the first use case that

00:18:54,989 --> 00:19:00,269
we have which is an encrypted payload

00:18:57,919 --> 00:19:01,889
the second one is what I spoke about

00:19:00,269 --> 00:19:05,369
earlier which is continuous remote

00:19:01,889 --> 00:19:07,469
attestation so for this one what we have

00:19:05,369 --> 00:19:08,789
is a whitelist let me give you an

00:19:07,469 --> 00:19:11,149
example so you can see what I'm talking

00:19:08,789 --> 00:19:11,149
about

00:19:24,080 --> 00:19:31,130
so this is a this is a whitelist it's

00:19:27,050 --> 00:19:34,610
pretty simple we've got a hash and then

00:19:31,130 --> 00:19:38,030
we have the POSIX path to the file this

00:19:34,610 --> 00:19:41,510
was generated by an archiving and in it

00:19:38,030 --> 00:19:44,210
Rama fess of a kind of a stock operating

00:19:41,510 --> 00:19:47,350
system so as I said we've got the hash

00:19:44,210 --> 00:19:47,350
and the file itself

00:19:57,880 --> 00:20:05,350
and this is ima the ima integrity

00:20:02,470 --> 00:20:08,980
measurement architecture it stores this

00:20:05,350 --> 00:20:10,690
on security FS and again there's a few

00:20:08,980 --> 00:20:13,990
more labels but effectively we've got a

00:20:10,690 --> 00:20:15,790
hash and then we have the full POSIX

00:20:13,990 --> 00:20:18,880
path to the object that's being measured

00:20:15,790 --> 00:20:22,660
now what happens is every time a Cisco

00:20:18,880 --> 00:20:26,380
is made of various Cisco the IMA will

00:20:22,660 --> 00:20:30,730
update this list so it will generate a

00:20:26,380 --> 00:20:33,010
new hash but that hash will be created

00:20:30,730 --> 00:20:36,190
and extended by the TPM so you have a

00:20:33,010 --> 00:20:37,840
hardware root of trust now using these

00:20:36,190 --> 00:20:40,210
two where the point of comparison

00:20:37,840 --> 00:20:42,820
between the current state of the machine

00:20:40,210 --> 00:20:46,050
and our whiteness the state that we

00:20:42,820 --> 00:20:46,050
expect the machine to be in

00:20:58,210 --> 00:21:03,730
so as we can see again we have the key

00:21:01,540 --> 00:21:05,770
lime turn on our CLI application and we

00:21:03,730 --> 00:21:07,270
got the whitelist so what we do is we

00:21:05,770 --> 00:21:10,270
send the whitelist to the verifier

00:21:07,270 --> 00:21:11,800
remember the verifies on premise we're

00:21:10,270 --> 00:21:14,410
not sending it out into the dangerous

00:21:11,800 --> 00:21:17,140
world where the agent resides so we send

00:21:14,410 --> 00:21:19,240
this to the verifier the verify

00:21:17,140 --> 00:21:21,790
generates our nonce so that we don't

00:21:19,240 --> 00:21:23,770
have any susceptibility to replay

00:21:21,790 --> 00:21:27,250
attacks and so forth and then it

00:21:23,770 --> 00:21:29,590
performs a TPM quote to the device and

00:21:27,250 --> 00:21:31,840
the device will return the quote and

00:21:29,590 --> 00:21:33,910
then the verifier will perform that

00:21:31,840 --> 00:21:36,550
cryptographic comparison their

00:21:33,910 --> 00:21:40,860
differential between the expected state

00:21:36,550 --> 00:21:43,420
and the current state now if that fails

00:21:40,860 --> 00:21:45,370
then there's a series of actions that we

00:21:43,420 --> 00:21:48,760
can take which we'll look at next but

00:21:45,370 --> 00:21:52,300
just to to refresh we have the whitelist

00:21:48,760 --> 00:21:54,790
which is the Golden State we have ima

00:21:52,300 --> 00:21:57,040
which populates a list based on the

00:21:54,790 --> 00:21:59,710
current state which is updated updated

00:21:57,040 --> 00:22:03,310
in real time every time an event occurs

00:21:59,710 --> 00:22:06,070
and keyline remotely a test the system

00:22:03,310 --> 00:22:09,490
state ima against the Golden State and

00:22:06,070 --> 00:22:10,660
that happens continuously we typically

00:22:09,490 --> 00:22:13,630
work at around

00:22:10,660 --> 00:22:15,580
it's a configurable interval but our

00:22:13,630 --> 00:22:19,000
poll is over I think the default is

00:22:15,580 --> 00:22:22,780
every two seconds and one verify can do

00:22:19,000 --> 00:22:25,300
that to thousands of devices so it's

00:22:22,780 --> 00:22:30,100
very light traffic we're talking it's ER

00:22:25,300 --> 00:22:32,560
it's a very small get request and and we

00:22:30,100 --> 00:22:35,080
did do some benchmarking and we managed

00:22:32,560 --> 00:22:38,100
to we took it up to 2,000 devices

00:22:35,080 --> 00:22:38,100
against one verifier

00:22:47,990 --> 00:22:52,790
okay so we look at the verification

00:22:50,110 --> 00:22:54,350
revocation framework so what we're

00:22:52,790 --> 00:22:59,480
talking about here is effectively where

00:22:54,350 --> 00:23:02,300
a device fails it's trust state again we

00:22:59,480 --> 00:23:04,790
have the verifier at the top and then at

00:23:02,300 --> 00:23:07,460
the bottom we have the key lime agents

00:23:04,790 --> 00:23:10,790
and the difference is this connects into

00:23:07,460 --> 00:23:13,220
a certificate authority and then what

00:23:10,790 --> 00:23:16,340
happens when the device fails it state

00:23:13,220 --> 00:23:21,500
the verifier will send out a revocation

00:23:16,340 --> 00:23:24,560
event to all of the other nodes that are

00:23:21,500 --> 00:23:26,510
alongside the failed node and it will

00:23:24,560 --> 00:23:28,550
tell it to perform some local actions

00:23:26,510 --> 00:23:31,670
well we'll look at what local actions

00:23:28,550 --> 00:23:35,480
are in the next slide and at the same

00:23:31,670 --> 00:23:37,460
time should a node fail I mean we had

00:23:35,480 --> 00:23:40,340
that bootstrap key that were created

00:23:37,460 --> 00:23:43,310
that could be part of a certificate

00:23:40,340 --> 00:23:45,980
authority so as a request could be made

00:23:43,310 --> 00:23:48,350
into a certificate authority to revoke

00:23:45,980 --> 00:23:51,620
the certificate so then if you built up

00:23:48,350 --> 00:23:54,710
a TLS structure or some IPSec tunnels

00:23:51,620 --> 00:23:58,420
based on that certificate authority that

00:23:54,710 --> 00:23:58,420
node would then effectively be cut off

00:24:03,620 --> 00:24:07,820
okay so let's just have a little bit

00:24:06,320 --> 00:24:12,260
more of a deep dive on what the

00:24:07,820 --> 00:24:14,320
revocation framework is so it's a it's a

00:24:12,260 --> 00:24:16,669
custom framework so you can effectively

00:24:14,320 --> 00:24:18,500
you can come up with anything I mean the

00:24:16,669 --> 00:24:21,799
world's your oyster if you can write

00:24:18,500 --> 00:24:24,230
some simple bash or sand Python uu

00:24:21,799 --> 00:24:26,809
script it yourself and as I say you know

00:24:24,230 --> 00:24:30,080
anything that you can script can be

00:24:26,809 --> 00:24:35,120
kicked off locally on the machines so a

00:24:30,080 --> 00:24:38,059
good example would be a node fails the

00:24:35,120 --> 00:24:40,250
verified er sends out a revocation event

00:24:38,059 --> 00:24:42,649
which is signed said you know this the

00:24:40,250 --> 00:24:44,870
actual verify this that's generated that

00:24:42,649 --> 00:24:47,059
revocation event and you could tell all

00:24:44,870 --> 00:24:49,570
of the local machines apart from the

00:24:47,059 --> 00:24:52,490
failed machine this machine has failed

00:24:49,570 --> 00:24:54,710
knockout this century from authorized

00:24:52,490 --> 00:24:58,610
keys you know that's something that be

00:24:54,710 --> 00:25:02,659
relatively simple to script another one

00:24:58,610 --> 00:25:04,820
would be of a again a node fails and the

00:25:02,659 --> 00:25:06,830
verifier cause your certificate

00:25:04,820 --> 00:25:09,470
authority to make a certificate

00:25:06,830 --> 00:25:11,360
revocation and again the example that I

00:25:09,470 --> 00:25:13,370
used earlier this would invalidate all

00:25:11,360 --> 00:25:15,559
in TLS connections and then effectively

00:25:13,370 --> 00:25:18,100
you'd cut the node off because it's been

00:25:15,559 --> 00:25:18,100
compromised

00:25:21,680 --> 00:25:31,160
okay a little bit more about the project

00:25:24,740 --> 00:25:33,020
itself so we've had some some really

00:25:31,160 --> 00:25:34,850
nice organic growth people have found

00:25:33,020 --> 00:25:36,920
the project from various Google searches

00:25:34,850 --> 00:25:39,440
and they've come along they've shown an

00:25:36,920 --> 00:25:41,870
interest and they've actually turned

00:25:39,440 --> 00:25:45,650
into people that are contributed so

00:25:41,870 --> 00:25:47,570
we're kind of a multi vendor project

00:25:45,650 --> 00:25:49,700
there's a couple of independent

00:25:47,570 --> 00:25:52,160
developers this that'll come along and

00:25:49,700 --> 00:25:55,040
start working on the project as well so

00:25:52,160 --> 00:25:58,540
as you can see we've this is a kind of

00:25:55,040 --> 00:26:01,460
like a an auto generation metric of a

00:25:58,540 --> 00:26:04,040
github projects current state so as you

00:26:01,460 --> 00:26:06,620
can see there's an increasing

00:26:04,040 --> 00:26:08,750
year-on-year commits we've got a young

00:26:06,620 --> 00:26:11,900
but established codebase developed by a

00:26:08,750 --> 00:26:14,450
large development team the first commit

00:26:11,900 --> 00:26:17,240
was made in October 2016 which is when

00:26:14,450 --> 00:26:19,670
MIT uploaded the code today github

00:26:17,240 --> 00:26:22,930
repository and then it says the most

00:26:19,670 --> 00:26:22,930
recent one was an hour ago

00:26:24,710 --> 00:26:28,670
we're very welcoming and friendly to

00:26:27,470 --> 00:26:30,470
people that want to come along and get

00:26:28,670 --> 00:26:32,600
involved you don't have to be a security

00:26:30,470 --> 00:26:35,870
expert you don't have to even be a

00:26:32,600 --> 00:26:38,090
developer we need people that just try

00:26:35,870 --> 00:26:42,110
out the solution tell us how to improve

00:26:38,090 --> 00:26:44,000
it perhaps write documentation you know

00:26:42,110 --> 00:26:46,850
we're very open to any help that we get

00:26:44,000 --> 00:26:49,160
we do mark issues as good first issues

00:26:46,850 --> 00:26:51,830
and this has attracted some people to

00:26:49,160 --> 00:26:53,510
the project and we have a contributions

00:26:51,830 --> 00:26:55,850
guide which they tell you exactly how to

00:26:53,510 --> 00:26:57,950
make a poor request what sort of issues

00:26:55,850 --> 00:26:59,930
we need help with and we are we're a

00:26:57,950 --> 00:27:04,580
friendly community I like to think we're

00:26:59,930 --> 00:27:09,200
a welcoming community since the project

00:27:04,580 --> 00:27:11,060
was opened by MIT we've worked on trying

00:27:09,200 --> 00:27:14,150
to have as much continuous integration

00:27:11,060 --> 00:27:17,030
automation testing as we can so every

00:27:14,150 --> 00:27:19,910
time somebody makes a patch we

00:27:17,030 --> 00:27:23,450
instantiate a container which runs a TPM

00:27:19,910 --> 00:27:27,080
emulator and then all of those scenarios

00:27:23,450 --> 00:27:30,269
that I've just outlined where a machine

00:27:27,080 --> 00:27:32,639
has are tested and we fail and

00:27:30,269 --> 00:27:34,289
so forth we we carry out functional

00:27:32,639 --> 00:27:38,039
equivalents of those tests within a

00:27:34,289 --> 00:27:40,320
container if the test fails then Travis

00:27:38,039 --> 00:27:41,759
will tell the poor request that it

00:27:40,320 --> 00:27:44,700
failed and they'll need that you know

00:27:41,759 --> 00:27:48,359
the developer would need to fix it make

00:27:44,700 --> 00:27:53,039
a git commit amend send up the patch

00:27:48,359 --> 00:27:56,459
again and we'll retest it we also are in

00:27:53,039 --> 00:27:59,070
the midst of doing the same with all of

00:27:56,459 --> 00:28:02,940
our upstream dependencies so we use the

00:27:59,070 --> 00:28:04,679
TPM to software stack there's a software

00:28:02,940 --> 00:28:07,019
stack a set of tools and a resource

00:28:04,679 --> 00:28:09,029
manager that they develop and they have

00:28:07,019 --> 00:28:10,320
various versions and of course their

00:28:09,029 --> 00:28:12,239
master branch so we're going to start

00:28:10,320 --> 00:28:16,229
testing against that so that we can

00:28:12,239 --> 00:28:18,749
capture any breakages as they happen we

00:28:16,229 --> 00:28:21,419
have all our documentation that's also

00:28:18,749 --> 00:28:24,719
generated by Sphinx and is rendered on

00:28:21,419 --> 00:28:26,879
to read the docs and we're going to also

00:28:24,719 --> 00:28:29,869
set up build testing so as far as

00:28:26,879 --> 00:28:33,209
coverage at the moment we're working on

00:28:29,869 --> 00:28:38,659
a lot of the standard Linux distribution

00:28:33,209 --> 00:28:41,519
so fedora ubuntu debian raspberry pi

00:28:38,659 --> 00:28:44,519
basta release has been recently been

00:28:41,519 --> 00:28:46,859
verified and and we're also open to

00:28:44,519 --> 00:28:49,289
working with as many distributions that

00:28:46,859 --> 00:28:52,019
we can say if somebody came forward and

00:28:49,289 --> 00:28:54,989
they wanted to get it working on X we as

00:28:52,019 --> 00:28:56,459
a community would support them we'll

00:28:54,989 --> 00:29:02,190
discuss things over an issue or

00:28:56,459 --> 00:29:06,479
troubleshoot it with you and so forth so

00:29:02,190 --> 00:29:08,869
we currently have weekly meetings every

00:29:06,479 --> 00:29:11,759
meeting the agenda is a github issue

00:29:08,869 --> 00:29:15,389
that way we can easily link into issues

00:29:11,759 --> 00:29:17,849
and pull requests and do a you know an

00:29:15,389 --> 00:29:19,829
at a sign to a particular person and so

00:29:17,849 --> 00:29:23,179
forth and that helps us easily track

00:29:19,829 --> 00:29:27,119
everything and we also meet once a week

00:29:23,179 --> 00:29:30,299
Wednesday 1500 UTC we have a get a

00:29:27,119 --> 00:29:32,039
channel where we meet and we discuss the

00:29:30,299 --> 00:29:35,219
various items that we need to go through

00:29:32,039 --> 00:29:38,749
and this gets a channel is also it's

00:29:35,219 --> 00:29:41,190
there 24/7 so if somebody was trying to

00:29:38,749 --> 00:29:43,049
achieve something with a system or

00:29:41,190 --> 00:29:44,070
something didn't worked you'd be able to

00:29:43,049 --> 00:29:46,139
jump in there

00:29:44,070 --> 00:29:47,700
quite a few of the core developers hang

00:29:46,139 --> 00:29:49,739
out on that channel and you'll be able

00:29:47,700 --> 00:29:51,389
to get support so that's the other key

00:29:49,739 --> 00:29:54,179
thing that we wanted for this project

00:29:51,389 --> 00:29:57,269
really was that when new people come

00:29:54,179 --> 00:29:58,769
along they try to get it to work

00:29:57,269 --> 00:30:00,659
you know something blows up they're

00:29:58,769 --> 00:30:03,149
getting an exception you know they have

00:30:00,659 --> 00:30:08,309
support people that are running around

00:30:03,149 --> 00:30:10,009
and help them to get that to work so

00:30:08,309 --> 00:30:12,840
what's coming next

00:30:10,009 --> 00:30:17,129
at the moment we're working on VT pn

00:30:12,840 --> 00:30:19,639
support so a VT PM is a virtual TPM so

00:30:17,129 --> 00:30:22,619
effectively a virtual TPM could be

00:30:19,639 --> 00:30:26,309
rendered within a virtual machine or a

00:30:22,619 --> 00:30:29,849
container now their key thing with a

00:30:26,309 --> 00:30:32,940
virtual TPM you don't have that hardware

00:30:29,849 --> 00:30:35,539
root of trust so effectively the keys

00:30:32,940 --> 00:30:38,970
for the VT PM are stored within the disk

00:30:35,539 --> 00:30:41,129
but VT p.m. VT p ms are very useful

00:30:38,970 --> 00:30:44,609
because you can create them at scale and

00:30:41,129 --> 00:30:47,340
every container or virtual machine can

00:30:44,609 --> 00:30:49,159
run its own local TPM so one of the

00:30:47,340 --> 00:30:52,289
things we've been looking at doing is is

00:30:49,159 --> 00:30:55,529
extending that hardware trust from the

00:30:52,289 --> 00:30:56,879
hardware TPM into the virtual TPM so at

00:30:55,529 --> 00:30:59,279
the moment we're working on this with

00:30:56,879 --> 00:31:01,109
Boston University and one of the

00:30:59,279 --> 00:31:03,179
professors from MIT that originally

00:31:01,109 --> 00:31:05,580
works on the project and we're

00:31:03,179 --> 00:31:08,190
effectively going to pull all of the

00:31:05,580 --> 00:31:11,460
quotes together to build them into a

00:31:08,190 --> 00:31:14,849
Merkle tree and then have one central

00:31:11,460 --> 00:31:17,570
hardware request quote requested a TPM

00:31:14,849 --> 00:31:20,340
which will then effectively allow us to

00:31:17,570 --> 00:31:22,200
pull a quote of thousands of thousands

00:31:20,340 --> 00:31:24,090
of devices into a single operation

00:31:22,200 --> 00:31:26,820
because one of the things with Hardware

00:31:24,090 --> 00:31:29,070
T pians they're not designed for

00:31:26,820 --> 00:31:31,529
handling multiple requests they

00:31:29,070 --> 00:31:33,960
typically expect to just work with one

00:31:31,529 --> 00:31:37,379
Mitch were one piece of metal machine

00:31:33,960 --> 00:31:39,869
themselves so this would allow us to

00:31:37,379 --> 00:31:41,820
have Maskell and it extends the

00:31:39,869 --> 00:31:46,080
cryptographic trust from the hardware

00:31:41,820 --> 00:31:48,149
TPM to the V TPM the other thing we're

00:31:46,080 --> 00:31:51,659
working on at the moment is key lime is

00:31:48,149 --> 00:31:54,570
developed in - and we're porting the

00:31:51,659 --> 00:31:56,830
agent to rust so that the agent is the

00:31:54,570 --> 00:31:59,610
part that runs on the remote

00:31:56,830 --> 00:32:02,590
machine so that's in a more hostile

00:31:59,610 --> 00:32:03,820
environment and we're going through rust

00:32:02,590 --> 00:32:04,720
quite simply because it's very

00:32:03,820 --> 00:32:07,059
performant

00:32:04,720 --> 00:32:10,419
there's no runtime garbage collection

00:32:07,059 --> 00:32:12,760
and the security Ross has a very strict

00:32:10,419 --> 00:32:16,240
compiler around memory safety and Fred

00:32:12,760 --> 00:32:18,309
safety so you tend to deal with a lot of

00:32:16,240 --> 00:32:19,659
your security technical debt when you're

00:32:18,309 --> 00:32:26,100
actually trying to get your code to

00:32:19,659 --> 00:32:28,950
compile so last of all just to round up

00:32:26,100 --> 00:32:31,149
you know we're at where a young project

00:32:28,950 --> 00:32:33,490
we're looking for people to get involved

00:32:31,149 --> 00:32:36,730
anybody you know you don't have to be a

00:32:33,490 --> 00:32:40,570
security crypto expert or even a

00:32:36,730 --> 00:32:42,519
developer architects users people that

00:32:40,570 --> 00:32:44,919
have got TP ohms people that are

00:32:42,519 --> 00:32:46,059
producing their own boards anybody we

00:32:44,919 --> 00:32:48,669
welcome you to come along and get

00:32:46,059 --> 00:32:51,130
involved we have a website where you can

00:32:48,669 --> 00:32:52,899
get hold of everything easily like our

00:32:51,130 --> 00:32:55,840
documentation find out where the

00:32:52,899 --> 00:32:58,179
repositories are how to get a simple

00:32:55,840 --> 00:33:01,299
system up and running and then as

00:32:58,179 --> 00:33:04,240
mentioned earlier we have a community

00:33:01,299 --> 00:33:07,690
chat channel where you can jump in 24/7

00:33:04,240 --> 00:33:12,940
and ask any questions so talking to

00:33:07,690 --> 00:33:17,159
questions we have a few minutes should

00:33:12,940 --> 00:33:17,159
anybody have anything they'd like to ask

00:33:18,600 --> 00:33:33,010
probably going to need a mic is this one

00:33:24,250 --> 00:33:35,710
good one T thanks for the talk the

00:33:33,010 --> 00:33:38,429
connection to the TPM is usually we are

00:33:35,710 --> 00:33:40,929
asked a C on the board so that would be

00:33:38,429 --> 00:33:43,240
subject to local attacks is there some

00:33:40,929 --> 00:33:47,519
way to authenticate that if you have

00:33:43,240 --> 00:33:47,519
trusted boot or something on my associ

00:33:48,530 --> 00:33:54,610
we this part is looked after by the TPM

00:33:51,650 --> 00:33:57,860
software stack so they have a built-in

00:33:54,610 --> 00:33:59,990
session authentication system so we're

00:33:57,860 --> 00:34:01,940
quite lucky what we do is we effectively

00:33:59,990 --> 00:34:04,610
wrap around the command set that they

00:34:01,940 --> 00:34:06,679
provide and that allows us to put in

00:34:04,610 --> 00:34:08,409
commands to create a session and they've

00:34:06,679 --> 00:34:11,000
got lots of things in there to prevent

00:34:08,409 --> 00:34:13,310
dictionary attacks and replay attacks

00:34:11,000 --> 00:34:16,399
and stuff like that so so luckily that

00:34:13,310 --> 00:34:19,399
because we sit on top of a quite

00:34:16,399 --> 00:34:22,820
actively developed stack that provides a

00:34:19,399 --> 00:34:25,609
resource manager a set of tools and a

00:34:22,820 --> 00:34:27,580
software stack itself the TSS that's

00:34:25,609 --> 00:34:30,190
actually all part of that system there

00:34:27,580 --> 00:34:34,520
does that answer your question go

00:34:30,190 --> 00:34:36,770
somewhere else yeah sure thank you for

00:34:34,520 --> 00:34:39,679
for so sharing these community inside

00:34:36,770 --> 00:34:42,590
that was very very interesting well one

00:34:39,679 --> 00:34:44,990
question was that who's sponsoring the

00:34:42,590 --> 00:34:48,409
CI a in infrastructure and who is

00:34:44,990 --> 00:34:55,669
maintaining and operating the pipeline

00:34:48,409 --> 00:34:59,150
so nobody at present it's it's it's a

00:34:55,669 --> 00:35:02,750
free Travis they provide a free account

00:34:59,150 --> 00:35:06,590
for open source projects and when I tend

00:35:02,750 --> 00:35:11,050
to set it set it up myself so I sponsor

00:35:06,590 --> 00:35:11,050
it but not with cash this time okay

00:35:16,100 --> 00:35:21,060
in the beginning you mentioned a few

00:35:18,420 --> 00:35:24,750
times that the TPM is doing measuring of

00:35:21,060 --> 00:35:27,570
various code at boot I'm a bit surprised

00:35:24,750 --> 00:35:29,460
because I thought the GPM is not doing

00:35:27,570 --> 00:35:31,410
DMA and controlling all the busses so

00:35:29,460 --> 00:35:39,270
how exactly it's the TPM measuring

00:35:31,410 --> 00:35:41,520
anything effectively what happens is so

00:35:39,270 --> 00:35:44,850
the TPM never makes a decision on the

00:35:41,520 --> 00:35:48,300
trust state all it does is it signs the

00:35:44,850 --> 00:35:51,480
object itself so there'll be this is

00:35:48,300 --> 00:35:53,130
where I'm not I'm not a TPM expert but

00:35:51,480 --> 00:35:56,160
from what I understand there's a core

00:35:53,130 --> 00:35:59,550
root of trust there's a CR TM ok which

00:35:56,160 --> 00:36:02,220
is like a seed ok and then it will take

00:35:59,550 --> 00:36:04,380
the next part of the boot chain whatever

00:36:02,220 --> 00:36:06,780
that might be the firmware and it'll

00:36:04,380 --> 00:36:08,940
take a hash of that you know add the two

00:36:06,780 --> 00:36:11,190
hashes together so it'll concatenate

00:36:08,940 --> 00:36:14,820
them and then it will sign those and

00:36:11,190 --> 00:36:17,460
then the next part will be measured ok

00:36:14,820 --> 00:36:21,270
and then that will continue until you

00:36:17,460 --> 00:36:23,010
have a complete one-way hash function

00:36:21,270 --> 00:36:25,920
which has allow you to effectively

00:36:23,010 --> 00:36:28,080
replay the the boot is that is that what

00:36:25,920 --> 00:36:36,450
you were asking about or something

00:36:28,080 --> 00:36:39,480
around the communication so the TPM is

00:36:36,450 --> 00:36:41,580
not not the thing on which the security

00:36:39,480 --> 00:36:43,770
depends but rather another component

00:36:41,580 --> 00:36:48,420
which reads all the data and feeds it to

00:36:43,770 --> 00:36:50,280
the TPM so the GPM even if the TPM is

00:36:48,420 --> 00:36:52,590
working correctly you have no guarantee

00:36:50,280 --> 00:36:55,470
that the rest of the system hasn't been

00:36:52,590 --> 00:36:58,080
tampered with because the rest is

00:36:55,470 --> 00:37:02,340
reading the data right so there's this

00:36:58,080 --> 00:37:05,310
there's - within the context of keyline

00:37:02,340 --> 00:37:07,590
there's two parts that feed the TPM so

00:37:05,310 --> 00:37:10,470
one of them is IME which is part of the

00:37:07,590 --> 00:37:12,090
Linux subsystem okay I wouldn't really

00:37:10,470 --> 00:37:14,100
be able to tell you about the attack

00:37:12,090 --> 00:37:16,860
vectors in there but it's it's been

00:37:14,100 --> 00:37:18,690
around for about I think close to nine

00:37:16,860 --> 00:37:21,690
ten years that code now so it's pretty

00:37:18,690 --> 00:37:24,210
well audited and that that came out in

00:37:21,690 --> 00:37:27,270
kernel 2.6 I think

00:37:24,210 --> 00:37:30,270
so that's ima which measures the runtime

00:37:27,270 --> 00:37:35,089
okay and what will happen is I may if it

00:37:30,270 --> 00:37:37,890
senses a TPM then it will send its

00:37:35,089 --> 00:37:40,380
measurements into the TPM into a

00:37:37,890 --> 00:37:42,660
platform configuration register which is

00:37:40,380 --> 00:37:46,380
a particular part of the TPM where a

00:37:42,660 --> 00:37:49,770
hash is stored okay now if it's the boot

00:37:46,380 --> 00:37:53,550
then there is in fact a shim which can

00:37:49,770 --> 00:37:55,650
do the same thing it can if a TPM is

00:37:53,550 --> 00:37:59,700
present then the shim will extend its

00:37:55,650 --> 00:38:01,740
measurements into the TPM itself around

00:37:59,700 --> 00:38:04,140
the protections on that I wouldn't be

00:38:01,740 --> 00:38:05,760
able to comment I'm relying on the kind

00:38:04,140 --> 00:38:07,559
of the maintainer Xand and the people

00:38:05,760 --> 00:38:09,270
that are developing that so we're more

00:38:07,559 --> 00:38:11,390
of an application that's sitting on top

00:38:09,270 --> 00:38:14,970
of that software stack but it's very

00:38:11,390 --> 00:38:17,430
widely audited I believe in and so I'd

00:38:14,970 --> 00:38:20,550
be fairly confident in the security of

00:38:17,430 --> 00:38:23,910
that no exploits have been reported

00:38:20,550 --> 00:38:26,490
since TPM 1.2 which was depreciated

00:38:23,910 --> 00:38:29,460
quite a long time ago and I think that's

00:38:26,490 --> 00:38:31,349
the case if somebody was I think they

00:38:29,460 --> 00:38:33,650
had an oscilloscope and a soldering iron

00:38:31,349 --> 00:38:38,040
and you know it was that sort of attack

00:38:33,650 --> 00:38:46,250
okay the worse anybody else have a

00:38:38,040 --> 00:38:46,250
question okay yeah sure

00:38:49,130 --> 00:38:53,880
so we have you have been talking about

00:38:51,240 --> 00:38:56,549
having a certificate for the key in the

00:38:53,880 --> 00:38:59,849
TPM on many a better systems you also

00:38:56,549 --> 00:39:01,710
have certificates and keys for things

00:38:59,849 --> 00:39:05,640
like VPN tunnels or something like that

00:39:01,710 --> 00:39:07,710
is managing and renewing certificates of

00:39:05,640 --> 00:39:09,780
that kind also in scope for keylime was

00:39:07,710 --> 00:39:13,559
that something that another component

00:39:09,780 --> 00:39:14,990
would do so that would be managed by a

00:39:13,559 --> 00:39:24,089
certificate authority

00:39:14,990 --> 00:39:28,069
okay so keylime not something that we do

00:39:24,089 --> 00:39:33,119
at present all we would be able to do is

00:39:28,069 --> 00:39:35,940
we could effectively try the certificate

00:39:33,119 --> 00:39:38,369
into a CA in the aspect of the machine

00:39:35,940 --> 00:39:40,829
is compromised you can revoke and

00:39:38,369 --> 00:39:42,450
invalidate that certificate you could do

00:39:40,829 --> 00:39:46,740
an encrypted payload which would have

00:39:42,450 --> 00:39:48,930
your your SSH keys your TLS certificates

00:39:46,740 --> 00:39:52,230
and so forth so the trust state the

00:39:48,930 --> 00:39:53,849
machine is good then a key will the

00:39:52,230 --> 00:39:55,530
second part of the key will be released

00:39:53,849 --> 00:40:00,329
which would allow the device to unlock

00:39:55,530 --> 00:40:02,730
its secrets so you could do a follow up

00:40:00,329 --> 00:40:05,190
provision that's quite possible where

00:40:02,730 --> 00:40:08,339
you could restage some more secrets but

00:40:05,190 --> 00:40:12,000
again you'd ensure a non compromised

00:40:08,339 --> 00:40:15,950
state on the machine first and you could

00:40:12,000 --> 00:40:23,880
tie that into a CA as well yep

00:40:15,950 --> 00:40:25,290
okay anybody else cool okay so thanks

00:40:23,880 --> 00:40:26,670
everybody for your help sorry about me

00:40:25,290 --> 00:40:28,440
having to keep been around I couldn't

00:40:26,670 --> 00:40:30,630
see the slides on my laptop so that's

00:40:28,440 --> 00:40:34,619
why I had to keep training my head round

00:40:30,630 --> 00:40:36,599
but um I'm here all week so do come and

00:40:34,619 --> 00:40:39,089
grab me if anybody wants to you know

00:40:36,599 --> 00:40:41,220
learn some more details or find out a

00:40:39,089 --> 00:40:43,200
bit more about the project I'm here all

00:40:41,220 --> 00:40:44,640
week as well I'm also here for the the

00:40:43,200 --> 00:40:46,680
Linux security summit where I'm

00:40:44,640 --> 00:40:48,990
hopefully going to do a demo of Key Lime

00:40:46,680 --> 00:40:50,609
we're doing live demo if we can so thank

00:40:48,990 --> 00:40:52,670
you

00:40:50,609 --> 00:40:52,670

YouTube URL: https://www.youtube.com/watch?v=jtbWnod5hoY


