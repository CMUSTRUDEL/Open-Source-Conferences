Title: Introduction to HyperBus Memory Devices - Vignesh Raghavendra, Texas Instruments
Publication date: 2019-11-04
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Introduction to HyperBus Memory Devices - Vignesh Raghavendra, Texas Instruments

HyperBus is a high performance 8-bit Double Data Rate bus used to connect SoCs with high performance flash devices. HyperFlash is a NOR based, Common Flash Interface (CFI) compliant HyperBus memory device. Itâ€™s increasingly replacing Parallel flashes due to faster boot time and reduced pin count. In this presentation, Vignesh will talk about the HyperBus framework he introduced recently in the Linux kernel under Memory Technology Devices (MTD) subsystem and how it supports HyperBus memory devices like HyperFlash.
The presentation introduces HyperBus protocol, CFI specification, HyperFlash and their kernel framework. It also provides an overview of how to write a new HyperBus Memory Controller Driver.
Finally the presentation talks about improvements made to CFI framework to reuse existing code in supporting HyperFlash and the challenges and problems that still need to be addressed.
Captions: 
	00:00:00,030 --> 00:00:05,879
okay let me get started good morning

00:00:03,300 --> 00:00:07,259
everyone welcome to my talk on high

00:00:05,879 --> 00:00:10,110
reverse memory devices

00:00:07,259 --> 00:00:14,219
my name is Magnus I'm from Texas

00:00:10,110 --> 00:00:17,400
Instruments India I mostly work on the

00:00:14,219 --> 00:00:22,710
linux SOC support for texas instrument

00:00:17,400 --> 00:00:25,230
devices and I go maintain the memory

00:00:22,710 --> 00:00:27,119
technology devices subsystem in Linux

00:00:25,230 --> 00:00:31,410
especially the common flash interface

00:00:27,119 --> 00:00:34,770
part and type of flash part of it okay

00:00:31,410 --> 00:00:37,559
so this is the agenda of my talk today

00:00:34,770 --> 00:00:40,309
so I'll start with hyper bus types of

00:00:37,559 --> 00:00:43,559
high purpose memories hyper bus protocol

00:00:40,309 --> 00:00:45,649
the hyper flash commands said the kernel

00:00:43,559 --> 00:00:49,289
framework for the hyper flash and

00:00:45,649 --> 00:00:51,480
writing a controller try work and what

00:00:49,289 --> 00:00:54,270
are the recent developments and future

00:00:51,480 --> 00:00:59,730
enhancements that can be done for hyper

00:00:54,270 --> 00:01:04,680
bus framework okay so what is hyper bus

00:00:59,730 --> 00:01:08,610
hyper bus is a serial bus now at SEL bus

00:01:04,680 --> 00:01:12,479
have multiple lines so that's that's a

00:01:08,610 --> 00:01:14,220
pretty name definitions now but the it's

00:01:12,479 --> 00:01:17,220
a high-speed bus connecting and hyper

00:01:14,220 --> 00:01:21,210
bus memory device to the SOC or the

00:01:17,220 --> 00:01:24,720
controller it has up to eight data lines

00:01:21,210 --> 00:01:27,240
or it has exactly data lines but it

00:01:24,720 --> 00:01:29,040
works in double data rate that is data

00:01:27,240 --> 00:01:32,180
is transferred on both raising and

00:01:29,040 --> 00:01:34,950
falling edge of the clock

00:01:32,180 --> 00:01:36,450
it uses either a single-ended block or

00:01:34,950 --> 00:01:38,729
differential clock depending on the

00:01:36,450 --> 00:01:40,680
voltage if it's a 1.8 volt part it will

00:01:38,729 --> 00:01:42,750
use a single-ended clock sorry a

00:01:40,680 --> 00:01:46,439
differential clock otherwise it can just

00:01:42,750 --> 00:01:48,960
use a single-ended core there is a chip

00:01:46,439 --> 00:01:51,329
select similar to a spy bus to select

00:01:48,960 --> 00:01:53,729
the manual device and a data stop sensor

00:01:51,329 --> 00:01:56,369
this is an eye speed interface data

00:01:53,729 --> 00:01:58,979
strokes helps in having a

00:01:56,369 --> 00:02:04,710
accurate data capture window for the

00:01:58,979 --> 00:02:07,469
host there are two types of hyper bus

00:02:04,710 --> 00:02:09,090
memory devices today in the market first

00:02:07,469 --> 00:02:10,890
one is an hyper flash which is a

00:02:09,090 --> 00:02:13,740
persistent storage

00:02:10,890 --> 00:02:17,190
to spine or flashes and there is hyper

00:02:13,740 --> 00:02:21,090
RAM which is a pseudo static RAM for

00:02:17,190 --> 00:02:22,800
retracted abilities mostly type of hyper

00:02:21,090 --> 00:02:25,740
flash devices are used on embedded

00:02:22,800 --> 00:02:30,990
devices and not exactly on server

00:02:25,740 --> 00:02:32,490
machines and etc so moving hard so as I

00:02:30,990 --> 00:02:34,800
said hyper flash is a lot

00:02:32,490 --> 00:02:37,950
technology-based device so it is

00:02:34,800 --> 00:02:40,020
organized into a sector and pages a

00:02:37,950 --> 00:02:43,440
sector is the smallest addressable unit

00:02:40,020 --> 00:02:46,880
whereas pages the maximum amount of data

00:02:43,440 --> 00:02:50,760
that you can write in one transaction so

00:02:46,880 --> 00:02:53,760
since it's a eight line purse walking in

00:02:50,760 --> 00:02:55,890
DDR mode so effectively it is a 16-bit

00:02:53,760 --> 00:02:58,709
bus that is you can transfer 16 bit of

00:02:55,890 --> 00:03:04,440
data per clock and therefore the word

00:02:58,709 --> 00:03:07,860
size is also 16 bits hyper flash only

00:03:04,440 --> 00:03:10,019
uses the data stroke for while reading

00:03:07,860 --> 00:03:12,870
that is only hyper flash is able to

00:03:10,019 --> 00:03:15,390
toggle the data stroke line and it

00:03:12,870 --> 00:03:17,700
doesn't expect host tutoral the data

00:03:15,390 --> 00:03:23,400
stroke line when it is writing data to

00:03:17,700 --> 00:03:27,060
the flash it works actually at least at

00:03:23,400 --> 00:03:30,239
100 200 megahertz frequency so you can

00:03:27,060 --> 00:03:31,769
get a read through put of about 400

00:03:30,239 --> 00:03:34,860
megabytes per second because you are

00:03:31,769 --> 00:03:38,130
transferring 2 bytes per clock so it's a

00:03:34,860 --> 00:03:41,310
pretty fast interface and since if it is

00:03:38,130 --> 00:03:43,709
a nor technology-based device there is

00:03:41,310 --> 00:03:46,049
very little setup the district pipe and

00:03:43,709 --> 00:03:48,269
if you are using it for an instant on

00:03:46,049 --> 00:03:51,290
kind of applications and fastboot kind

00:03:48,269 --> 00:03:57,360
of requirements this is a very good

00:03:51,290 --> 00:04:00,450
storage media yeah so what type of flash

00:03:57,360 --> 00:04:02,160
does is it kind it kind of crossed the

00:04:00,450 --> 00:04:03,600
features of the parallel not memories

00:04:02,160 --> 00:04:06,480
that are already there and kind of

00:04:03,600 --> 00:04:08,190
combines with serial memories to reduce

00:04:06,480 --> 00:04:11,519
the number of pins that are actually

00:04:08,190 --> 00:04:13,799
required to connect the device and

00:04:11,519 --> 00:04:19,739
therefore takes the best of the both

00:04:13,799 --> 00:04:22,979
kind of analogy so and this is kind of a

00:04:19,739 --> 00:04:24,169
competitive technology for octal spinal

00:04:22,979 --> 00:04:28,729
devices that are

00:04:24,169 --> 00:04:31,719
available credential just a brief note

00:04:28,729 --> 00:04:35,509
about hyper RAM as well sure it is a

00:04:31,719 --> 00:04:39,740
pseudo static Ram capable of having its

00:04:35,509 --> 00:04:42,080
own self refresh sakura tree and it is

00:04:39,740 --> 00:04:44,689
exactly been compatible with an hyper

00:04:42,080 --> 00:04:46,789
flash device but it uses a

00:04:44,689 --> 00:04:49,580
bi-directional data stroke that is if a

00:04:46,789 --> 00:04:53,240
host has to drive the data stroke when

00:04:49,580 --> 00:04:55,279
writing to the flash and device will

00:04:53,240 --> 00:04:58,939
drive the stroke when it when when

00:04:55,279 --> 00:05:02,840
reading this is required because since

00:04:58,939 --> 00:05:05,330
RAM needs to be refreshed every now and

00:05:02,840 --> 00:05:07,210
then it is quite possible that during a

00:05:05,330 --> 00:05:10,629
ride there may be a need for refresh and

00:05:07,210 --> 00:05:14,539
you have to give that what you say the

00:05:10,629 --> 00:05:16,370
weight face so that the device is

00:05:14,539 --> 00:05:21,500
refreshed and then you can go ahead and

00:05:16,370 --> 00:05:24,080
do the write transaction so yeah this is

00:05:21,500 --> 00:05:25,310
how we can divide the transaction on a

00:05:24,080 --> 00:05:28,219
hyper bus

00:05:25,310 --> 00:05:31,129
basically there are three phases command

00:05:28,219 --> 00:05:38,089
address phase weight phase and data

00:05:31,129 --> 00:05:40,310
phase so in the command address phase it

00:05:38,089 --> 00:05:42,529
is it indicates what type of transaction

00:05:40,310 --> 00:05:46,279
it is and what is the address to which

00:05:42,529 --> 00:05:48,889
this transaction is targeted to so this

00:05:46,279 --> 00:05:51,080
is always driven by the master this this

00:05:48,889 --> 00:05:53,779
face is always driven by the master and

00:05:51,080 --> 00:05:55,430
there is a wait phase where either host

00:05:53,779 --> 00:05:57,919
is waiting for the Refresh to complete

00:05:55,430 --> 00:06:00,379
or host is waiting for the flash to

00:05:57,919 --> 00:06:03,229
start sending data and then a data phase

00:06:00,379 --> 00:06:05,060
which depending on the transaction would

00:06:03,229 --> 00:06:10,129
either be from host side of the device

00:06:05,060 --> 00:06:12,050
side so just an example of how it would

00:06:10,129 --> 00:06:14,599
look on a bus very similar to a spy

00:06:12,050 --> 00:06:16,969
transaction you have chip select going

00:06:14,599 --> 00:06:21,259
down followed by the command address

00:06:16,969 --> 00:06:26,839
face here since it's a DDR bus you just

00:06:21,259 --> 00:06:29,839
it just takes three cycle four eight six

00:06:26,839 --> 00:06:32,120
bytes of data to go up and then the

00:06:29,839 --> 00:06:35,089
flash response with data here and you

00:06:32,120 --> 00:06:39,490
can see that rewrites in data strobe

00:06:35,089 --> 00:06:39,490
toggling to indicate value data window

00:06:40,440 --> 00:06:46,870
okay so to explain a bit what happens

00:06:45,460 --> 00:06:50,380
actually in the command address phase

00:06:46,870 --> 00:06:52,840
and what does 47 bits 48 bits represent

00:06:50,380 --> 00:06:55,210
so the highest built xlvii will

00:06:52,840 --> 00:06:57,700
represent whether it's a real

00:06:55,210 --> 00:07:02,460
transaction or a right transaction the

00:06:57,700 --> 00:07:02,460
46th build represents whether this is a

00:07:02,550 --> 00:07:07,600
address that that is targeting memory

00:07:05,020 --> 00:07:11,410
space or the register space this is

00:07:07,600 --> 00:07:13,090
mostly used by hyper Ram where if you

00:07:11,410 --> 00:07:15,570
want to control the registers of the

00:07:13,090 --> 00:07:20,800
hyper Ram then you would probably said

00:07:15,570 --> 00:07:22,540
one publisher at the 46 bit one to

00:07:20,800 --> 00:07:24,910
indicate its targeting register space

00:07:22,540 --> 00:07:26,860
otherwise it's all mostly 0 and

00:07:24,910 --> 00:07:28,840
targeting the memory space or where

00:07:26,860 --> 00:07:33,820
exactly where actually where the actual

00:07:28,840 --> 00:07:35,560
data is stored and a bit fortify

00:07:33,820 --> 00:07:38,350
represents whether it's a linear

00:07:35,560 --> 00:07:41,020
transaction or a graph transaction half

00:07:38,350 --> 00:07:43,870
transaction might you know you can wrap

00:07:41,020 --> 00:07:46,150
around the addresses at 16 by 32 byte or

00:07:43,870 --> 00:07:47,860
64 byte boundary based on the

00:07:46,150 --> 00:07:50,260
configuration that is done on the flash

00:07:47,860 --> 00:07:54,300
side so this is useful in you know

00:07:50,260 --> 00:07:58,630
filling up a cache line or something so

00:07:54,300 --> 00:08:01,390
then the actual address itself so hyper

00:07:58,630 --> 00:08:04,810
bus has of today supports 32-bit

00:08:01,390 --> 00:08:09,220
addressing so you have address line 31

00:08:04,810 --> 00:08:12,760
address bits a 31 to a 0 so average a 31

00:08:09,220 --> 00:08:16,000
to a 3 would map to the 29 bits will map

00:08:12,760 --> 00:08:19,050
to bits 44 to 16 and there is a reserved

00:08:16,000 --> 00:08:22,300
bit range in the middle which is 15 to

00:08:19,050 --> 00:08:27,070
victory and then the last 3 bits are

00:08:22,300 --> 00:08:30,880
mapped to bridge 2 to 0 so there's a

00:08:27,070 --> 00:08:34,360
concept called half page which is the

00:08:30,880 --> 00:08:38,770
size of the a to do a 0 which is 16

00:08:34,360 --> 00:08:42,219
bytes so it depends on the flash but for

00:08:38,770 --> 00:08:44,560
example on hyper flash these 16 bytes

00:08:42,219 --> 00:08:47,080
represents the smallest unit on which

00:08:44,560 --> 00:08:48,750
ECC is calculated so if we want to

00:08:47,080 --> 00:08:51,960
enable ECC on a

00:08:48,750 --> 00:09:00,330
flash you probably do rewrite or with

00:08:51,960 --> 00:09:03,690
16-byte and Garrity so bit about the

00:09:00,330 --> 00:09:11,190
programming sequence of how software

00:09:03,690 --> 00:09:13,380
interacts with the flash itself so so

00:09:11,190 --> 00:09:15,810
hyper flash follows the common flash

00:09:13,380 --> 00:09:19,530
interface external command set zero zero

00:09:15,810 --> 00:09:21,390
two edges the same command set that post

00:09:19,530 --> 00:09:25,230
parallel nor flashes by Cypress or

00:09:21,390 --> 00:09:27,540
legacy MD flashes use we already have a

00:09:25,230 --> 00:09:29,850
driver in kernel implementing this for a

00:09:27,540 --> 00:09:32,550
long time so you can find it under

00:09:29,850 --> 00:09:38,730
drivers MTD chips see a file commands

00:09:32,550 --> 00:09:40,620
with dot C so the flash comes up in read

00:09:38,730 --> 00:09:42,720
mode where it is possible for you to

00:09:40,620 --> 00:09:47,490
directly go and read the data on the

00:09:42,720 --> 00:09:51,090
flash so going back here so you just

00:09:47,490 --> 00:09:53,250
need to set bit 47 to 1 and then bit

00:09:51,090 --> 00:09:55,260
fortify to linear mapping and then set

00:09:53,250 --> 00:09:58,530
the address bit and flash will start

00:09:55,260 --> 00:10:02,130
responding with the data so a basic

00:09:58,530 --> 00:10:05,130
transaction will start reading data from

00:10:02,130 --> 00:10:12,110
the flash so it's very useful for quick

00:10:05,130 --> 00:10:15,630
read kind of applications yeah so

00:10:12,110 --> 00:10:17,910
programming or writing to the flash or

00:10:15,630 --> 00:10:22,530
anything that modifies content on the

00:10:17,910 --> 00:10:29,040
flash is a bit tricky so there are two

00:10:22,530 --> 00:10:31,700
step unlocked stage where you write an

00:10:29,040 --> 00:10:35,040
predefined value to a predefined address

00:10:31,700 --> 00:10:38,100
has step one and step two so a lot 1 and

00:10:35,040 --> 00:10:42,540
unlock two after which the flash is open

00:10:38,100 --> 00:10:44,970
for programming actually so then write

00:10:42,540 --> 00:10:49,080
for example this sequence is showing how

00:10:44,970 --> 00:10:52,020
to write fight well 512 bytes of data to

00:10:49,080 --> 00:10:53,790
the flash so in that case the sector

00:10:52,020 --> 00:10:58,530
address to which you want to do the

00:10:53,790 --> 00:11:01,110
update you write value 0 X - 5 which is

00:10:58,530 --> 00:11:02,670
the right to buffer combined to the

00:11:01,110 --> 00:11:06,060
start of the sector address

00:11:02,670 --> 00:11:09,630
and then tell how many bites needs to be

00:11:06,060 --> 00:11:12,180
updated and actually and then send the

00:11:09,630 --> 00:11:13,740
actual data so this data is not actually

00:11:12,180 --> 00:11:16,250
directly returned to the flash instead

00:11:13,740 --> 00:11:19,380
its buffered within the flash first and

00:11:16,250 --> 00:11:22,560
you have to issue a confirmation command

00:11:19,380 --> 00:11:25,530
the last step here to the sector address

00:11:22,560 --> 00:11:29,970
so that the programming actually happens

00:11:25,530 --> 00:11:34,470
and the hyper flash supports up to 512

00:11:29,970 --> 00:11:36,780
bytes of buffering in this way again all

00:11:34,470 --> 00:11:38,250
these addresses are 16-bit word

00:11:36,780 --> 00:11:46,350
addresses and not actually the byte

00:11:38,250 --> 00:11:49,100
addresses that are being shown here okay

00:11:46,350 --> 00:11:50,640
then flash supports something called as

00:11:49,100 --> 00:11:53,280
address space

00:11:50,640 --> 00:11:55,260
overlays basically there are multiple

00:11:53,280 --> 00:11:57,780
parallel address spaces within the hypo

00:11:55,260 --> 00:12:00,210
flash the default address space is where

00:11:57,780 --> 00:12:03,210
the actual data is stored there are

00:12:00,210 --> 00:12:05,550
other address spaces like device ID or

00:12:03,210 --> 00:12:08,280
common flash interface error space where

00:12:05,550 --> 00:12:10,050
there is a table which tells you about

00:12:08,280 --> 00:12:12,660
the actual device itself and its

00:12:10,050 --> 00:12:15,450
parameters there is status registers

00:12:12,660 --> 00:12:17,370
address space and production bits which

00:12:15,450 --> 00:12:21,420
can be set to protect the individual

00:12:17,370 --> 00:12:26,220
sectors and many more vendors specific

00:12:21,420 --> 00:12:28,320
address spaces may be present so there

00:12:26,220 --> 00:12:31,260
will be a specific set of sequences that

00:12:28,320 --> 00:12:33,840
will be given in a datasheet to tell how

00:12:31,260 --> 00:12:35,310
to enter a specific address space once

00:12:33,840 --> 00:12:39,540
those commands are sent and you had

00:12:35,310 --> 00:12:41,670
enter a specific address space even if

00:12:39,540 --> 00:12:44,400
the whole entire flash will be replaced

00:12:41,670 --> 00:12:47,370
with the new address space so reading

00:12:44,400 --> 00:12:49,770
data from same address would give you

00:12:47,370 --> 00:12:54,900
different data depending on which outer

00:12:49,770 --> 00:12:57,530
space you are in and there is no need

00:12:54,900 --> 00:13:01,110
for separate commands for each and every

00:12:57,530 --> 00:13:04,640
register axis so it will just become a

00:13:01,110 --> 00:13:04,640
serial address place overlay

00:13:09,420 --> 00:13:15,790
so moving on to the different types of

00:13:12,990 --> 00:13:18,070
hyper bus controller we solve the flash

00:13:15,790 --> 00:13:21,310
part now on to the SOC part where the

00:13:18,070 --> 00:13:23,710
controller is so there are two broad

00:13:21,310 --> 00:13:27,010
variety of hyper bus controllers that we

00:13:23,710 --> 00:13:29,170
can see the first one is dedicated hyper

00:13:27,010 --> 00:13:32,500
bus controllers which only understand

00:13:29,170 --> 00:13:34,930
hyper bus protocol and they saw that

00:13:32,500 --> 00:13:36,760
they can support memory map access to

00:13:34,930 --> 00:13:38,950
the flash where in the inter flash can

00:13:36,760 --> 00:13:43,420
be accessed directly by CPU as if it's

00:13:38,950 --> 00:13:45,610
an IDE associate rest so and there are

00:13:43,420 --> 00:13:49,780
multi I of serial controllers which

00:13:45,610 --> 00:13:53,200
support wide variety of protocols such

00:13:49,780 --> 00:13:57,340
as it can support a spine or spine 9l

00:13:53,200 --> 00:13:59,140
spy or even a hyper bus etc so they may

00:13:57,340 --> 00:14:01,720
or may not have memory mapped access but

00:13:59,140 --> 00:14:07,660
these are the two variety of controllers

00:14:01,720 --> 00:14:13,020
that you can see out there this slide

00:14:07,660 --> 00:14:13,020
shows how mm IO capable controller works

00:14:13,140 --> 00:14:21,880
you can see that for example on an SOC

00:14:17,760 --> 00:14:24,910
let's say for some white flour sorry

00:14:21,880 --> 00:14:26,290
let's say for example at address 8

00:14:24,910 --> 00:14:28,510
followed by seven zeros to eight

00:14:26,290 --> 00:14:30,670
followed by all F there is a memory map

00:14:28,510 --> 00:14:34,240
interface that is exposed to access the

00:14:30,670 --> 00:14:36,790
flash so whenever CP orders write access

00:14:34,240 --> 00:14:38,260
to this address range the associate

00:14:36,790 --> 00:14:40,390
interconnect would probably route it to

00:14:38,260 --> 00:14:42,700
the high purpose memory controller and

00:14:40,390 --> 00:14:44,950
the high purpose memory controller in

00:14:42,700 --> 00:14:49,780
turn on the hyper bus will generate

00:14:44,950 --> 00:14:52,540
required common address we and datastage

00:14:49,780 --> 00:14:54,280
so since it knows the transaction that

00:14:52,540 --> 00:14:57,940
is coming in is a read or a write

00:14:54,280 --> 00:15:00,970
transaction and the address range so the

00:14:57,940 --> 00:15:04,210
48 bits of the command address face

00:15:00,970 --> 00:15:06,310
where what whether the 47 bit needs to

00:15:04,210 --> 00:15:09,460
be set or Lord will be decided by the

00:15:06,310 --> 00:15:13,780
hyper bus controller and it can talk to

00:15:09,460 --> 00:15:16,990
the hyper flash this is very useful when

00:15:13,780 --> 00:15:18,910
when if we if it needs to be used for

00:15:16,990 --> 00:15:21,120
xip kind of use cases although not

00:15:18,910 --> 00:15:23,790
something for linux but

00:15:21,120 --> 00:15:31,320
you can easily execute called out of

00:15:23,790 --> 00:15:33,510
hyper flash memory so let's come to the

00:15:31,320 --> 00:15:36,210
main part which is how this is supported

00:15:33,510 --> 00:15:37,500
in Linux kernel and the software part of

00:15:36,210 --> 00:15:39,870
it

00:15:37,500 --> 00:15:44,970
hyper was framework is relatively known

00:15:39,870 --> 00:15:48,440
new and it was merged in kernel 5.3 we

00:15:44,970 --> 00:15:51,030
found our only support type of flash and

00:15:48,440 --> 00:15:54,900
hyper am is not supported at the moment

00:15:51,030 --> 00:15:59,220
and support mm IO capable hyper burst

00:15:54,900 --> 00:16:01,770
controllers and so most of the code is

00:15:59,220 --> 00:16:04,770
just reuse of the existing common flash

00:16:01,770 --> 00:16:09,930
framework so on the top we have the MTD

00:16:04,770 --> 00:16:14,550
layer which provides the user space and

00:16:09,930 --> 00:16:17,070
the kernel level interfaces and there is

00:16:14,550 --> 00:16:19,050
common flash interface driver which

00:16:17,070 --> 00:16:21,330
implements the parallel nor command said

00:16:19,050 --> 00:16:25,200
required that that is used by the hyper

00:16:21,330 --> 00:16:28,500
flash and below that there is map

00:16:25,200 --> 00:16:33,180
framework which was I mean which is

00:16:28,500 --> 00:16:35,820
actually to forward the request of CFI

00:16:33,180 --> 00:16:41,430
layer onto the memory map capable

00:16:35,820 --> 00:16:43,860
drivers and and hyper bus framework kind

00:16:41,430 --> 00:16:45,690
of accessing layer between the hyper bus

00:16:43,860 --> 00:16:48,270
memory controller driver and my

00:16:45,690 --> 00:16:50,660
framework forwarding the calls from the

00:16:48,270 --> 00:16:53,850
mat framework on to the hyper bus driver

00:16:50,660 --> 00:16:56,700
and at the lowest level you have the

00:16:53,850 --> 00:17:00,000
hardware so basically it's mostly reuse

00:16:56,700 --> 00:17:02,640
of the command set driver and giving a

00:17:00,000 --> 00:17:04,560
hook onto the map framework so that the

00:17:02,640 --> 00:17:09,000
hyper bus controller drivers can plug

00:17:04,560 --> 00:17:10,589
into it so there were a few

00:17:09,000 --> 00:17:14,550
modifications that need to be made to

00:17:10,589 --> 00:17:17,720
the CFI layer to support hyper flash one

00:17:14,550 --> 00:17:21,720
of them or the main one is actually the

00:17:17,720 --> 00:17:23,730
status register polling in case of write

00:17:21,720 --> 00:17:26,610
or erase after the completion of write

00:17:23,730 --> 00:17:28,470
or erase there was a there is a need to

00:17:26,610 --> 00:17:30,330
you know pull the flash to know whether

00:17:28,470 --> 00:17:33,210
the write or erase operation is complete

00:17:30,330 --> 00:17:36,029
the legacy CFI driver used to

00:17:33,210 --> 00:17:38,940
look at the data lines toggling to

00:17:36,029 --> 00:17:43,020
determine whether or not the programming

00:17:38,940 --> 00:17:45,720
gets complete but it's not possible with

00:17:43,020 --> 00:17:47,370
the type of hyper flash kind of hyper

00:17:45,720 --> 00:17:51,809
burst kind of device where we have

00:17:47,370 --> 00:17:56,039
double data rate time and just a tie o

00:17:51,809 --> 00:17:57,600
lines for a 16-bit bus so the way it

00:17:56,039 --> 00:18:00,150
works in hyper flashes there is a

00:17:57,600 --> 00:18:02,789
dedicated status register which you can

00:18:00,150 --> 00:18:04,770
go and read it to know whether the write

00:18:02,789 --> 00:18:07,409
or erase is complete and it also

00:18:04,770 --> 00:18:10,110
provides a nice status saying okay what

00:18:07,409 --> 00:18:17,730
failed and why did you fail in case of

00:18:10,110 --> 00:18:20,340
failures so okay if you're writing an

00:18:17,730 --> 00:18:23,190
hyper bus memory controller driver so

00:18:20,340 --> 00:18:25,140
what needs to be done it's a very simple

00:18:23,190 --> 00:18:28,230
interface as of now so you have to

00:18:25,140 --> 00:18:31,799
implement the hyper bus ops which

00:18:28,230 --> 00:18:35,279
consists of these five functions I'll go

00:18:31,799 --> 00:18:39,840
through them in the next slide so the

00:18:35,279 --> 00:18:41,610
the first one is read 16 which is used

00:18:39,840 --> 00:18:45,270
to read sixteen bits of data in a single

00:18:41,610 --> 00:18:48,029
bus and mostly used to read from non

00:18:45,270 --> 00:18:50,130
default address spaces such as ID or CFI

00:18:48,029 --> 00:18:52,740
space for the status register space and

00:18:50,130 --> 00:18:54,480
then there is write 16 which is the

00:18:52,740 --> 00:18:56,789
complement of read 16 which is used to

00:18:54,480 --> 00:18:59,610
write 16 bit of data in a single burst

00:18:56,789 --> 00:19:04,710
and there is copy from and copy to which

00:18:59,610 --> 00:19:07,559
does the majority of writes and reads of

00:19:04,710 --> 00:19:09,720
data from the actual flash memory area

00:19:07,559 --> 00:19:11,880
if you are reading the data from the

00:19:09,720 --> 00:19:16,500
flash it's actually done by the copy

00:19:11,880 --> 00:19:21,929
from interface so the reason for having

00:19:16,500 --> 00:19:25,309
this read 16 and write 16 is that the

00:19:21,929 --> 00:19:29,090
memory map controllers are capable of

00:19:25,309 --> 00:19:31,890
although you hyper bus is a 16-bit bus

00:19:29,090 --> 00:19:35,970
you are not supposed to do byte accesses

00:19:31,890 --> 00:19:38,190
the memory map controller device drivers

00:19:35,970 --> 00:19:43,500
sorry memory map controller IPS are

00:19:38,190 --> 00:19:46,320
capable of you know doing non 16-bit

00:19:43,500 --> 00:19:48,299
accesses as well so for example if you

00:19:46,320 --> 00:19:51,750
- right one byte of data the controller

00:19:48,299 --> 00:19:54,389
might offend 0xff to the higher byte and

00:19:51,750 --> 00:19:57,630
make it a 16-bit right and tried it on

00:19:54,389 --> 00:20:01,500
to the flash this would be ok if you are

00:19:57,630 --> 00:20:03,750
writing to normal flash memory space but

00:20:01,500 --> 00:20:06,630
this would be a problem if if the target

00:20:03,750 --> 00:20:09,389
was a status register or a configuration

00:20:06,630 --> 00:20:10,889
register for example where you want

00:20:09,389 --> 00:20:11,399
exactly the value that needs to be

00:20:10,889 --> 00:20:17,009
written

00:20:11,399 --> 00:20:19,590
so therefore read 16 right 16 must use

00:20:17,009 --> 00:20:22,559
proper i/o accessors which will do

00:20:19,590 --> 00:20:27,210
16-bit accesses whereas copy do and copy

00:20:22,559 --> 00:20:29,940
from are okay to use nor default

00:20:27,210 --> 00:20:31,529
accesses as well and do all the

00:20:29,940 --> 00:20:34,200
optimization that is required to read

00:20:31,529 --> 00:20:36,840
data from the flash finally we have a

00:20:34,200 --> 00:20:39,629
utility for calibration which is called

00:20:36,840 --> 00:20:43,710
very only on by the core code so that

00:20:39,629 --> 00:20:47,600
the the hyper bus controller driver can

00:20:43,710 --> 00:20:49,679
calibrate the controller itself because

00:20:47,600 --> 00:20:51,570
because this is a very high speed

00:20:49,679 --> 00:20:54,600
interface operating at 200 megahertz

00:20:51,570 --> 00:20:57,179
most devices may have a file and may

00:20:54,600 --> 00:20:59,789
need to calibrate a file or have to

00:20:57,179 --> 00:21:03,330
calibrate somebody ll locking or or some

00:20:59,789 --> 00:21:05,070
of the stuff so the core provides a

00:21:03,330 --> 00:21:09,620
calibration utility which is called even

00:21:05,070 --> 00:21:09,620
before trying to detect the flash device

00:21:11,779 --> 00:21:21,870
okay so once the driver implements the

00:21:16,529 --> 00:21:23,549
hyper bus ops itself for every hyper

00:21:21,870 --> 00:21:27,210
flash device that is discovered on the

00:21:23,549 --> 00:21:33,179
bus you register a hyper bus device onto

00:21:27,210 --> 00:21:35,279
the core so this is the structure most

00:21:33,179 --> 00:21:37,409
important one would be the map info

00:21:35,279 --> 00:21:39,870
which represents the start and educators

00:21:37,409 --> 00:21:43,259
and start addressing the in address of

00:21:39,870 --> 00:21:48,570
the physical map where you can access

00:21:43,259 --> 00:21:51,059
the flash device followed by the pointer

00:21:48,570 --> 00:21:51,720
to the node itself and diam Creedy store

00:21:51,059 --> 00:21:54,809
which

00:21:51,720 --> 00:21:56,879
get populated once their device is

00:21:54,809 --> 00:21:59,070
registered and the hyper bus controller

00:21:56,879 --> 00:22:03,539
structure which will consist of the

00:21:59,070 --> 00:22:05,909
hyper bus ops we also have an enum for

00:22:03,539 --> 00:22:08,159
member type for now we only support type

00:22:05,909 --> 00:22:11,279
of flash and this is just for future

00:22:08,159 --> 00:22:13,470
extinction once this is populated can

00:22:11,279 --> 00:22:18,840
just call hyper bus register device and

00:22:13,470 --> 00:22:21,720
register the device with the core so

00:22:18,840 --> 00:22:25,590
this is a device tree representation for

00:22:21,720 --> 00:22:28,529
tea I am six for SOC cyber bus

00:22:25,590 --> 00:22:33,029
controller node there is a memory map

00:22:28,529 --> 00:22:38,429
window available at this range and it is

00:22:33,029 --> 00:22:41,009
being assigned to to to chip selects so

00:22:38,429 --> 00:22:43,500
the chip select 0 has 64 megabytes of

00:22:41,009 --> 00:22:45,870
data result and megabytes of address

00:22:43,500 --> 00:22:49,700
space reserved and chip select one has

00:22:45,870 --> 00:22:53,129
another 64 bytes of 64 megabytes of

00:22:49,700 --> 00:22:56,389
address range reserved so yeah

00:22:53,129 --> 00:23:00,690
and using the ranges we map it to the

00:22:56,389 --> 00:23:02,789
flash device where the first entry here

00:23:00,690 --> 00:23:04,759
represents the chip selects itself and

00:23:02,789 --> 00:23:07,980
the second entry would represent the

00:23:04,759 --> 00:23:10,980
start and the size of the flash so

00:23:07,980 --> 00:23:13,320
compatible for hyper flash would be

00:23:10,980 --> 00:23:17,149
Cypress hyper flash or it's also

00:23:13,320 --> 00:23:17,149
backward compatible with the CFI flash

00:23:17,299 --> 00:23:22,740
so I haven't shown the second slave

00:23:20,159 --> 00:23:27,440
device but it will be exactly same but

00:23:22,740 --> 00:23:27,440
just the chip selects at the one so yeah

00:23:28,759 --> 00:23:34,019
how do you access hyper flash from user

00:23:31,710 --> 00:23:38,789
space it's same as any other empty

00:23:34,019 --> 00:23:42,090
device so it exposes slash dev slash MTD

00:23:38,789 --> 00:23:44,460
X to the user space or MPD block if we

00:23:42,090 --> 00:23:48,149
are using the block device on top of it

00:23:44,460 --> 00:23:55,470
so we can use the MTD utils that are

00:23:48,149 --> 00:23:57,809
available on the infrared link and yeah

00:23:55,470 --> 00:24:02,930
you can also use any of the flash file

00:23:57,809 --> 00:24:05,540
systems such as UV ifs so that

00:24:02,930 --> 00:24:11,690
you can have a root of s onto the hyper

00:24:05,540 --> 00:24:13,660
flash or any of the storage yeah so one

00:24:11,690 --> 00:24:16,730
of the recent developments has been that

00:24:13,660 --> 00:24:18,980
there has been a new jeddak

00:24:16,730 --> 00:24:24,290
specification called extended spy

00:24:18,980 --> 00:24:27,920
specification or XXVI specification jes

00:24:24,290 --> 00:24:29,780
t25 one so the aim of this document is

00:24:27,920 --> 00:24:31,490
actually to standardize the command

00:24:29,780 --> 00:24:35,210
certain programming of different serial

00:24:31,490 --> 00:24:37,250
flashes but it's kind of thinks of all

00:24:35,210 --> 00:24:40,480
types of serial flashes out there and

00:24:37,250 --> 00:24:43,040
being put into a single specification so

00:24:40,480 --> 00:24:45,620
there are two profiles mentioned in the

00:24:43,040 --> 00:24:48,200
XXVI specification which is profile 1

00:24:45,620 --> 00:24:50,630
and profile 2 so the profile 1 mostly

00:24:48,200 --> 00:24:54,740
talks about the regular spy devices the

00:24:50,630 --> 00:24:59,210
spine or flashes up to octal octal spy

00:24:54,740 --> 00:25:05,170
flashes and profile 2 talks about the

00:24:59,210 --> 00:25:08,180
high purpose protocol itself so yeah so

00:25:05,170 --> 00:25:11,990
therefore now hyper flash is also an X X

00:25:08,180 --> 00:25:15,440
bi standard but if you really try to

00:25:11,990 --> 00:25:18,860
compare how these two protocol look on

00:25:15,440 --> 00:25:21,710
the with respect to each other so the

00:25:18,860 --> 00:25:23,480
above diagram is of spy flash protocol

00:25:21,710 --> 00:25:26,150
where you have one or two byte of

00:25:23,480 --> 00:25:27,710
command phase depending on if it's a DDR

00:25:26,150 --> 00:25:30,200
mode you have to bite of command phase

00:25:27,710 --> 00:25:32,090
or if it's a STR mode there is a single

00:25:30,200 --> 00:25:34,970
byte of command phase followed by an

00:25:32,090 --> 00:25:37,120
address phase it can be up to three to

00:25:34,970 --> 00:25:39,380
four bytes most likely for by addressing

00:25:37,120 --> 00:25:42,290
followed by a weight phase and data fish

00:25:39,380 --> 00:25:47,210
but on the hype of flaaaav hyper bus

00:25:42,290 --> 00:25:49,280
protocol there is just six byte combined

00:25:47,210 --> 00:25:51,650
command and address phase and the

00:25:49,280 --> 00:25:54,500
problem is the address is kind of not

00:25:51,650 --> 00:25:57,110
divided among one of the bytes it's it

00:25:54,500 --> 00:25:59,360
spans all the way from the you know

00:25:57,110 --> 00:26:02,600
first byte to the sixth white so you

00:25:59,360 --> 00:26:08,510
can't really divide this into two phases

00:26:02,600 --> 00:26:10,400
but the the XS by a standard kind of

00:26:08,510 --> 00:26:15,140
that's another profile and says okay

00:26:10,400 --> 00:26:16,370
these two are are almost same in terms

00:26:15,140 --> 00:26:21,320
of the

00:26:16,370 --> 00:26:23,900
phases of transaction so we do have

00:26:21,320 --> 00:26:27,500
excess bi complement hyper flash devices

00:26:23,900 --> 00:26:30,710
on the market so such flashes will power

00:26:27,500 --> 00:26:35,480
up in spy mode which is single bit mode

00:26:30,710 --> 00:26:37,450
1 s 1 s 1 as a 1 bit command sorry what

00:26:35,480 --> 00:26:40,400
one buyer command and one wire of

00:26:37,450 --> 00:26:43,910
addressing and the one wire data phase

00:26:40,400 --> 00:26:45,620
also so this is backward compatible to

00:26:43,910 --> 00:26:49,370
any of the spy devices that we find in

00:26:45,620 --> 00:26:51,650
the market but using that mode you can

00:26:49,370 --> 00:26:53,270
program a bit in the configuration

00:26:51,650 --> 00:26:58,550
register which will switch the flash

00:26:53,270 --> 00:27:01,370
although the hyper flash mode and then

00:26:58,550 --> 00:27:03,950
it will work with the normal command

00:27:01,370 --> 00:27:08,000
address data phase kind of things that I

00:27:03,950 --> 00:27:10,130
showed in the beginning so although one

00:27:08,000 --> 00:27:12,080
advantage of X s Perry complaint flashes

00:27:10,130 --> 00:27:15,560
they have the serial flash discoverable

00:27:12,080 --> 00:27:18,920
table or SFTP table which has wide range

00:27:15,560 --> 00:27:21,470
of parameters and things described about

00:27:18,920 --> 00:27:25,310
the flash that software can read in

00:27:21,470 --> 00:27:26,960
runtime and try to find out what needs

00:27:25,310 --> 00:27:29,630
to be done with this flash exactly

00:27:26,960 --> 00:27:31,970
without actually knowing to know the

00:27:29,630 --> 00:27:36,530
exact part number and so on everything

00:27:31,970 --> 00:27:38,510
is discoverable on the flame yeah we

00:27:36,530 --> 00:27:41,810
still don't have support for X SPI or

00:27:38,510 --> 00:27:46,160
compliant flash or the flash controllers

00:27:41,810 --> 00:27:50,210
which can support both spy nor flashes

00:27:46,160 --> 00:27:52,520
as well as hyper flash devices but what

00:27:50,210 --> 00:27:54,320
we have today is we have a spy mem layer

00:27:52,520 --> 00:27:57,110
which is an abstraction between the spy

00:27:54,320 --> 00:28:00,200
subsystem and flies spy flash memory

00:27:57,110 --> 00:28:03,800
devices and it has been able to work

00:28:00,200 --> 00:28:06,380
with any type of flash spine and spine

00:28:03,800 --> 00:28:09,110
are and so on so we could probably

00:28:06,380 --> 00:28:13,520
extend that to also support the hyper

00:28:09,110 --> 00:28:17,420
flash so the the spy MEMS of system has

00:28:13,520 --> 00:28:19,700
spy mem of template which expects one

00:28:17,420 --> 00:28:21,910
byte of address sorry one byte of

00:28:19,700 --> 00:28:26,330
command and four byte of address and

00:28:21,910 --> 00:28:27,890
followed by a data but hyper flash is

00:28:26,330 --> 00:28:29,220
slightly different that it has a

00:28:27,890 --> 00:28:32,250
combined commander

00:28:29,220 --> 00:28:35,520
face of six bytes we could probably add

00:28:32,250 --> 00:28:37,919
a new member to the template saying okay

00:28:35,520 --> 00:28:39,960
this is an hyper flash mode and then

00:28:37,919 --> 00:28:42,000
extend the command and address field so

00:28:39,960 --> 00:28:44,400
that you can accommodate the hyper flash

00:28:42,000 --> 00:28:46,620
protocol as well

00:28:44,400 --> 00:28:48,720
if we could do that then it should be

00:28:46,620 --> 00:28:50,909
possible to use the spy not cover and

00:28:48,720 --> 00:28:54,360
the hype of I prefer hyperbole score has

00:28:50,909 --> 00:28:56,789
ease with the spy memo ops to you know

00:28:54,360 --> 00:28:59,669
use a single controller driver to talk

00:28:56,789 --> 00:29:07,610
to both spy spinal devices as well as

00:28:59,669 --> 00:29:11,070
type of flash devices yeah these are the

00:29:07,610 --> 00:29:13,799
some of the enhancements that can be

00:29:11,070 --> 00:29:16,799
done to the framework but is one of the

00:29:13,799 --> 00:29:20,250
thing is the right performance is quite

00:29:16,799 --> 00:29:22,710
slow because the right is done at word

00:29:20,250 --> 00:29:26,610
granularity that is 16 bit at a time

00:29:22,710 --> 00:29:28,980
sure but type of flash can in general to

00:29:26,610 --> 00:29:31,460
fight while bytes buffered right at a

00:29:28,980 --> 00:29:34,830
time so should be able to extend that

00:29:31,460 --> 00:29:36,630
there's also need to add DMA support for

00:29:34,830 --> 00:29:38,669
reading data from the flash given that

00:29:36,630 --> 00:29:42,539
we can go up all the way to 400

00:29:38,669 --> 00:29:45,330
megabytes per second using DMA would

00:29:42,539 --> 00:29:49,490
would be the only way to actually you

00:29:45,330 --> 00:29:53,070
know get that such high throughput but

00:29:49,490 --> 00:29:55,740
most flash file systems such as you BFS

00:29:53,070 --> 00:29:58,169
and Jeff fs2 would use vemma lock

00:29:55,740 --> 00:30:00,150
buffers and we can't just pass around

00:29:58,169 --> 00:30:02,130
beam a lot buffers and try to map it and

00:30:00,150 --> 00:30:04,080
use it for DMA that's that's that's not

00:30:02,130 --> 00:30:07,679
possible because of various limitations

00:30:04,080 --> 00:30:10,340
so that needs to be handled in high

00:30:07,679 --> 00:30:15,870
purpose core or at MPD layer level and

00:30:10,340 --> 00:30:18,539
yeah then probably extend the controller

00:30:15,870 --> 00:30:21,000
itself sorry probably extend the core

00:30:18,539 --> 00:30:22,860
itself to use the spy my mobs so that we

00:30:21,000 --> 00:30:25,710
can support multi protocols PI

00:30:22,860 --> 00:30:28,830
controllers as well as the X SPI support

00:30:25,710 --> 00:30:34,679
for the spy and hyper flash compatible

00:30:28,830 --> 00:30:36,630
devices okay so yeah that's our job

00:30:34,679 --> 00:30:38,669
these are some of the references where

00:30:36,630 --> 00:30:41,830
you can find hyperbola fication

00:30:38,669 --> 00:30:44,019
type of flash and hyper arm data sheets

00:30:41,830 --> 00:30:49,120
and you can find the source of hyper

00:30:44,019 --> 00:30:51,220
busco or at the github yeah

00:30:49,120 --> 00:30:52,510
so thanks to my company Texas

00:30:51,220 --> 00:30:54,669
Instruments I until the next foundation

00:30:52,510 --> 00:30:58,950
for providing an opportunity to speak

00:30:54,669 --> 00:31:20,529
here without I open for question answers

00:30:58,950 --> 00:31:23,139
thanks thanks for acting so I saw your

00:31:20,529 --> 00:31:25,149
batch history Linux and you with mailing

00:31:23,139 --> 00:31:28,809
lists thanks for them good work thank

00:31:25,149 --> 00:31:34,090
you you keep mentioning the Ruby file

00:31:28,809 --> 00:31:36,039
system and basically Ruby on the empty

00:31:34,090 --> 00:31:39,039
on the hypervisor path isn't the hyper

00:31:36,039 --> 00:31:43,090
flash kind of an nor flash so why would

00:31:39,039 --> 00:31:45,279
you run be on top of that why would you

00:31:43,090 --> 00:31:49,990
run ubi on top of that why would you run

00:31:45,279 --> 00:31:53,260
the ruby eye on top of I well you can

00:31:49,990 --> 00:31:55,899
run any of the file systems but you

00:31:53,260 --> 00:31:58,450
still need to do I mean you don't need

00:31:55,899 --> 00:32:00,899
to do we're leveling kind of things that

00:31:58,450 --> 00:32:03,130
is required for nine but it's still

00:32:00,899 --> 00:32:05,590
erasing the same sector again and again

00:32:03,130 --> 00:32:09,580
and trying to use the same one as kind

00:32:05,590 --> 00:32:12,070
of not really good for nor has well this

00:32:09,580 --> 00:32:15,659
is the purpose is to do the word logging

00:32:12,070 --> 00:32:15,659
basically yeah okay thanks

00:32:25,080 --> 00:32:29,909
so where where is this subsystem living

00:32:27,899 --> 00:32:34,470
it's a direct under drivers already

00:32:29,909 --> 00:32:38,840
under the current flash drivers so it's

00:32:34,470 --> 00:32:43,369
it here it's under drivers MDD hyper bus

00:32:38,840 --> 00:32:43,369
so it's under the hi i'm grady framework

00:32:58,560 --> 00:33:05,800
hi program we need a you know if there's

00:33:03,310 --> 00:33:08,080
a good use case then we can start

00:33:05,800 --> 00:33:11,230
implementing targeting the use case so

00:33:08,080 --> 00:33:13,270
that you really know that I mean just

00:33:11,230 --> 00:33:15,250
supporting in out-of-the-blue would

00:33:13,270 --> 00:33:16,720
probably not meet the requirement when

00:33:15,250 --> 00:33:20,110
somebody actually tries to use it so

00:33:16,720 --> 00:33:23,830
that's that's why I kind of haven't come

00:33:20,110 --> 00:33:24,880
to that part yet yes yes because there's

00:33:23,830 --> 00:33:29,470
absolutely no programming required

00:33:24,880 --> 00:33:32,260
actually so well yeah and it's most

00:33:29,470 --> 00:33:34,450
likely that hi program is a supplement

00:33:32,260 --> 00:33:37,090
for people who are trying to use it on

00:33:34,450 --> 00:33:38,920
MCU side where hyper flash would act as

00:33:37,090 --> 00:33:40,750
a storage and hyper Ram has a small

00:33:38,920 --> 00:33:44,830
amount of ram memory and it might be a

00:33:40,750 --> 00:33:48,880
single multi-chip package which can be

00:33:44,830 --> 00:33:51,540
used for such applications may not be a

00:33:48,880 --> 00:33:51,540
linux use case

00:33:57,810 --> 00:34:02,270
do you know which other windows do and

00:34:00,060 --> 00:34:05,550
provide happier bus and their devices

00:34:02,270 --> 00:34:08,240
sorry I do know other vendors who

00:34:05,550 --> 00:34:10,410
provide hyper bus and their devices

00:34:08,240 --> 00:34:12,120
vendors who provide high purpose in

00:34:10,410 --> 00:34:15,810
their associates

00:34:12,120 --> 00:34:18,240
there are tea I associate the I am six

00:34:15,810 --> 00:34:20,370
five four SOC which has hyper bus

00:34:18,240 --> 00:34:24,920
controller on it and I know Renaissance

00:34:20,370 --> 00:34:24,920
also has a similar associate

00:34:36,079 --> 00:34:43,609
did you compare the throughputs between

00:34:38,210 --> 00:34:45,379
usings octaves by mod I purpose through

00:34:43,609 --> 00:34:47,690
port in terms of throughput human or

00:34:45,379 --> 00:34:50,450
yeah I think you can use the same

00:34:47,690 --> 00:34:53,899
controller with both correct protocol so

00:34:50,450 --> 00:34:56,109
did you compare the through boots no I

00:34:53,899 --> 00:34:59,630
haven't done the benchmarking yet no

00:34:56,109 --> 00:35:02,030
even octaves we have often more support

00:34:59,630 --> 00:35:04,160
but up till DDR more support is still

00:35:02,030 --> 00:35:05,780
something that's missing in kernel as

00:35:04,160 --> 00:35:08,589
well so we don't support the DDR mode

00:35:05,780 --> 00:35:13,460
and hyper versus DDR bus by default so

00:35:08,589 --> 00:35:15,920
that's still binding to Veda yeah but I

00:35:13,460 --> 00:35:18,410
would theoretically it seems like both

00:35:15,920 --> 00:35:26,210
are both can operate at 200 megahertz

00:35:18,410 --> 00:35:31,690
and DDR so yeah it should be identical

00:35:26,210 --> 00:35:31,690
if I if I take a guess yeah okay thanks

00:35:34,210 --> 00:35:37,640
okay thanks thanks for seeing it thank

00:35:37,039 --> 00:35:42,290
you

00:35:37,640 --> 00:35:42,290

YouTube URL: https://www.youtube.com/watch?v=fY_e0P0qZJA


