Title: BoF: Multibuild for Zephyr RTOS - Marti Bolivar, Nordic Semiconductor
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	BoF: Multibuild for Zephyr RTOS - Marti Bolivar, Nordic Semiconductor*

The Zephyr RTOS build system currently supports generating a single application image. This build is isolated from other related images, such as bootloaders, secure vs. nonsecure Arm TrustZone images, multi-core applications communicating via IPC mechanisms, etc.

This is a problem because these images can be interdependent in ways that require compatible configurations between images (including Kconfig, device tree chosen nodes, linker script memory layout, etc.). Since the build system is agnostic to other images, this is left to the application developer or system designer to manage. That's unnecessarily error prone, since the build system could check for common errors itself if only it knew about all the executables in the system.

Different Zephyr downstream distributions have solved this problem in different ways, but there's so far no consensus on how to solve this problem upstream. This BoF is meant to keep the conversation going among anyone who is interested in this topic.
Captions: 
	00:00:00,030 --> 00:00:04,290
all right I'm gonna go ahead and get

00:00:01,410 --> 00:00:06,660
started so today we're going to talk

00:00:04,290 --> 00:00:08,880
about a problem that we're calling multi

00:00:06,660 --> 00:00:10,559
build this is probably if anybody's an

00:00:08,880 --> 00:00:11,880
MCU developer this is distinct from the

00:00:10,559 --> 00:00:13,799
multi image that I'm see Buddha's

00:00:11,880 --> 00:00:15,030
talking about so those are maybe this is

00:00:13,799 --> 00:00:18,300
not the droids you're looking for but

00:00:15,030 --> 00:00:19,800
all right so we're gonna do a little

00:00:18,300 --> 00:00:22,859
disclaimer talk about what the problem

00:00:19,800 --> 00:00:25,320
is and talk about one approach which has

00:00:22,859 --> 00:00:27,990
been put into the PR that you can see up

00:00:25,320 --> 00:00:30,630
there 13 to 672 and then I want to try

00:00:27,990 --> 00:00:32,309
to get to discussion as quick as I can

00:00:30,630 --> 00:00:34,079
though I don't know how much time we're

00:00:32,309 --> 00:00:35,160
gonna have I'm gonna make this is

00:00:34,079 --> 00:00:37,860
something that we've been discussing

00:00:35,160 --> 00:00:39,540
within Zephyr for quite some time and so

00:00:37,860 --> 00:00:42,300
I'm assuming that there's kind of gonna

00:00:39,540 --> 00:00:44,250
be a huge level of difference of

00:00:42,300 --> 00:00:46,590
experience with this problem in the room

00:00:44,250 --> 00:00:48,090
from what is this problem to like we

00:00:46,590 --> 00:00:50,550
were just arguing about it for the past

00:00:48,090 --> 00:00:52,469
couple hours right over there and I'll

00:00:50,550 --> 00:00:55,410
do my best to assume as little as

00:00:52,469 --> 00:00:58,859
possible and then hand it off so the

00:00:55,410 --> 00:01:00,420
disclaimer is that Nordic has has a dog

00:00:58,859 --> 00:01:02,160
in this fight we have a very particular

00:01:00,420 --> 00:01:03,539
solution which we're running in our down

00:01:02,160 --> 00:01:06,720
stream we've been running it for quite

00:01:03,539 --> 00:01:08,189
some time it does work however I am

00:01:06,720 --> 00:01:10,530
trying this is an upstream focused

00:01:08,189 --> 00:01:13,080
presentation and I'm kind of be kind of

00:01:10,530 --> 00:01:15,210
an impartial just describer of what's

00:01:13,080 --> 00:01:17,060
going on but you know everybody knows

00:01:15,210 --> 00:01:20,460
who pays my bills so that's out there

00:01:17,060 --> 00:01:21,689
what's the problem okay there are an

00:01:20,460 --> 00:01:24,090
increasing number of use cases that

00:01:21,689 --> 00:01:25,259
we've been running into throughout the

00:01:24,090 --> 00:01:27,299
community really this is not just

00:01:25,259 --> 00:01:29,369
restricted to my company where we want

00:01:27,299 --> 00:01:32,250
to build multiple Zephyr binaries that

00:01:29,369 --> 00:01:33,990
are all interdependent in some sense and

00:01:32,250 --> 00:01:36,600
the sense can be very different

00:01:33,990 --> 00:01:40,619
depending on the use case but they are

00:01:36,600 --> 00:01:42,509
all sort of targeting one SOC and the

00:01:40,619 --> 00:01:44,700
way that we can do this now is that we

00:01:42,509 --> 00:01:47,970
can create a separate build system for

00:01:44,700 --> 00:01:49,890
every one of these binaries and then do

00:01:47,970 --> 00:01:51,960
whatever however you know tools we

00:01:49,890 --> 00:01:53,130
choose to validate the interdependencies

00:01:51,960 --> 00:01:55,290
between them or you know past

00:01:53,130 --> 00:01:57,600
dependencies between them and then get

00:01:55,290 --> 00:01:59,340
them running on reports right so there

00:01:57,600 --> 00:02:01,979
are some problems with this which I will

00:01:59,340 --> 00:02:04,110
go into and we have a proposed solution

00:02:01,979 --> 00:02:07,110
for this but you know that's what we're

00:02:04,110 --> 00:02:09,629
here to discuss okay so the first of

00:02:07,110 --> 00:02:10,649
these is usability and what you can see

00:02:09,629 --> 00:02:12,569
listed is that you know you've got

00:02:10,649 --> 00:02:14,280
multiple built-in flash steps but it's a

00:02:12,569 --> 00:02:15,660
little bit more

00:02:14,280 --> 00:02:17,430
difficult than that right there are

00:02:15,660 --> 00:02:18,990
certain cases like how much space I'm

00:02:17,430 --> 00:02:20,490
allocating to my bootloader and how much

00:02:18,990 --> 00:02:24,480
is left over to the application where it

00:02:20,490 --> 00:02:26,040
would be really nice to do it in a more

00:02:24,480 --> 00:02:27,270
integrated way where if I increase the

00:02:26,040 --> 00:02:29,490
amount of space allocated to my

00:02:27,270 --> 00:02:30,990
bootloader the amount of space allocated

00:02:29,490 --> 00:02:34,110
the application is decreased by the same

00:02:30,990 --> 00:02:35,760
amount or in other contexts you know

00:02:34,110 --> 00:02:37,860
like you know trusted firmware image you

00:02:35,760 --> 00:02:39,270
have a partition between the peripherals

00:02:37,860 --> 00:02:41,100
between your secure and your non secure

00:02:39,270 --> 00:02:43,530
world so if I use the spy in my secure

00:02:41,100 --> 00:02:45,750
world I cannot use it in the non secure

00:02:43,530 --> 00:02:47,550
world and it would be great if we can

00:02:45,750 --> 00:02:49,830
produce kind of a single system that

00:02:47,550 --> 00:02:52,020
knows that and can check it for the user

00:02:49,830 --> 00:02:54,990
so you know it's not just that there's

00:02:52,020 --> 00:02:56,730
more steps it's also that inner

00:02:54,990 --> 00:02:58,320
dependency leaves more work in the hands

00:02:56,730 --> 00:02:59,850
of the application developer unless we

00:02:58,320 --> 00:03:02,390
have kind of more framework level

00:02:59,850 --> 00:03:05,580
support before this somewhere in Zephyr

00:03:02,390 --> 00:03:08,010
there are some performance concerns and

00:03:05,580 --> 00:03:11,160
the main issue is that you know a build

00:03:08,010 --> 00:03:12,930
jag has these sort of serialized steps

00:03:11,160 --> 00:03:14,220
at the beginning in the end and then in

00:03:12,930 --> 00:03:15,690
between it's you know using a longer

00:03:14,220 --> 00:03:17,370
course to build the individual C files

00:03:15,690 --> 00:03:18,810
but you know while it's doing linking

00:03:17,370 --> 00:03:21,000
that's very inherently serial it's

00:03:18,810 --> 00:03:23,070
generating header files for autocomplete

00:03:21,000 --> 00:03:25,140
for example you can't really build any C

00:03:23,070 --> 00:03:28,470
files until that's done so there are

00:03:25,140 --> 00:03:30,780
some steps that if you're doing each of

00:03:28,470 --> 00:03:33,060
these binary if you're evaluating the

00:03:30,780 --> 00:03:34,890
DAGs for these build systems separately

00:03:33,060 --> 00:03:36,330
then you're leaving some you know

00:03:34,890 --> 00:03:39,150
performance on the table especially at

00:03:36,330 --> 00:03:40,440
the beginning in the end and then if

00:03:39,150 --> 00:03:42,299
you're doing them in parallel like you

00:03:40,440 --> 00:03:44,519
know you're allocating some threads to

00:03:42,299 --> 00:03:46,739
one application binary and another set

00:03:44,519 --> 00:03:48,720
of threads to another well that limits

00:03:46,739 --> 00:03:50,549
you from doing some cross-checking in

00:03:48,720 --> 00:03:54,170
some ways but it also is kind of unclear

00:03:50,549 --> 00:03:56,190
about how to map threads to build right

00:03:54,170 --> 00:03:58,739
you're also doing some repeated

00:03:56,190 --> 00:04:00,330
configure time work but then the main

00:03:58,739 --> 00:04:01,470
thing is kind of what we already started

00:04:00,330 --> 00:04:03,750
getting into is the dependency

00:04:01,470 --> 00:04:05,730
management right so everybody's got you

00:04:03,750 --> 00:04:08,340
know their if everybody's got their own

00:04:05,730 --> 00:04:10,830
application build directory so you can't

00:04:08,340 --> 00:04:14,040
share memory between like say a minyan

00:04:10,830 --> 00:04:15,390
core right so if you've got a single SOC

00:04:14,040 --> 00:04:18,690
where you've got a Bluetooth controller

00:04:15,390 --> 00:04:21,030
on it that's a separate core than the

00:04:18,690 --> 00:04:23,010
application core you're gonna need

00:04:21,030 --> 00:04:24,180
probably some shared memory area to swap

00:04:23,010 --> 00:04:26,520
your buffers around right and it would

00:04:24,180 --> 00:04:27,350
be nice to be able to say in one place

00:04:26,520 --> 00:04:29,570
and have a single

00:04:27,350 --> 00:04:32,720
and of truth where are the boundaries of

00:04:29,570 --> 00:04:34,190
this memory area right there's another

00:04:32,720 --> 00:04:35,510
case that comes up with with trust zone

00:04:34,190 --> 00:04:37,520
which is just not just like the

00:04:35,510 --> 00:04:40,610
partitions of the peripherals it's also

00:04:37,520 --> 00:04:41,990
that you're gonna have kind of a system

00:04:40,610 --> 00:04:43,910
call interface between the non-secure

00:04:41,990 --> 00:04:46,220
world and the secure world right so the

00:04:43,910 --> 00:04:49,550
way that that's gonna work is that the

00:04:46,220 --> 00:04:53,030
secure build is going to generate dot a

00:04:49,550 --> 00:04:55,010
that the build system for the insecure

00:04:53,030 --> 00:04:56,660
world must link in right so it's gonna

00:04:55,010 --> 00:04:57,860
give you some function signatures and

00:04:56,660 --> 00:05:00,170
give you the study that you can link

00:04:57,860 --> 00:05:02,990
into your insecure image that lets you

00:05:00,170 --> 00:05:04,070
call into the secure world right and so

00:05:02,990 --> 00:05:05,600
if you're gonna do this with multiple

00:05:04,070 --> 00:05:07,670
bill directories you have to somehow you

00:05:05,600 --> 00:05:11,510
know let the other one know as an input

00:05:07,670 --> 00:05:13,490
here's my previous output archive and

00:05:11,510 --> 00:05:14,660
then you know there's this issue which

00:05:13,490 --> 00:05:17,390
we've already talked about like

00:05:14,660 --> 00:05:20,410
enforcing compatibility which comes up

00:05:17,390 --> 00:05:21,590
in the bootloader use case for example

00:05:20,410 --> 00:05:25,130
okay

00:05:21,590 --> 00:05:26,960
I wanted to talk about example use cases

00:05:25,130 --> 00:05:29,390
before going on hit my backup slides

00:05:26,960 --> 00:05:31,850
because this is something that we we had

00:05:29,390 --> 00:05:34,610
a question about an hour ago

00:05:31,850 --> 00:05:37,010
so bootloader chains are one so MCU boot

00:05:34,610 --> 00:05:39,140
is a zephyr application and it's gonna

00:05:37,010 --> 00:05:40,670
boot the main zephyr application it

00:05:39,140 --> 00:05:41,780
needs to know where it is it needs to

00:05:40,670 --> 00:05:44,420
know how to upgrade it all this other

00:05:41,780 --> 00:05:47,360
stuff longer chains of the same thing

00:05:44,420 --> 00:05:49,300
you know so we have multiple stage booth

00:05:47,360 --> 00:05:51,380
right so it's not just a two stage boot

00:05:49,300 --> 00:05:53,270
the minion cores we've already talked

00:05:51,380 --> 00:05:55,640
about another thing you might think

00:05:53,270 --> 00:05:58,520
about would up in terms of minion cores

00:05:55,640 --> 00:06:01,280
which are kind of very the inherently a

00:05:58,520 --> 00:06:02,870
MP SOC s where you've got like it's not

00:06:01,280 --> 00:06:05,540
just like an SMP core right everybody

00:06:02,870 --> 00:06:06,830
here understands that another one you

00:06:05,540 --> 00:06:07,820
might run into is that there could be

00:06:06,830 --> 00:06:10,490
like a really fast

00:06:07,820 --> 00:06:12,950
sleepy application core that wants to

00:06:10,490 --> 00:06:14,690
offload a little bit of work to a lower

00:06:12,950 --> 00:06:15,920
power core that might be you know kind

00:06:14,690 --> 00:06:17,120
of directly polling on a sensor or

00:06:15,920 --> 00:06:18,800
something like that in the application

00:06:17,120 --> 00:06:22,400
core for power management reasons wants

00:06:18,800 --> 00:06:24,080
to go back to bed as soon as it can and

00:06:22,400 --> 00:06:25,310
then Trustin we've kind of already

00:06:24,080 --> 00:06:27,860
talked about so these are kind of the

00:06:25,310 --> 00:06:29,330
main use cases that we think that we'd

00:06:27,860 --> 00:06:30,800
like to try to address at least at first

00:06:29,330 --> 00:06:32,270
and so this is where we're sort of

00:06:30,800 --> 00:06:35,450
restricting our discussion to because

00:06:32,270 --> 00:06:37,150
this is a very broad problem space so

00:06:35,450 --> 00:06:40,070
I'm going to rewind

00:06:37,150 --> 00:06:42,950
all right now those of you who are

00:06:40,070 --> 00:06:44,930
familiar with Semak may say great it has

00:06:42,950 --> 00:06:47,750
this external project feature why don't

00:06:44,930 --> 00:06:49,280
we just use that and there is a an open

00:06:47,750 --> 00:06:52,820
a NP sample and up screams effort which

00:06:49,280 --> 00:06:55,700
does there is a problem with it which is

00:06:52,820 --> 00:06:57,590
that the dependencies between the two

00:06:55,700 --> 00:06:59,420
builds are not propagated between them

00:06:57,590 --> 00:07:00,710
so if I have you know an application you

00:06:59,420 --> 00:07:02,630
know kind of the main application and

00:07:00,710 --> 00:07:04,940
then I've got my like little open a NP

00:07:02,630 --> 00:07:06,950
minion core over here what's going to

00:07:04,940 --> 00:07:08,720
happen is that if you update a file

00:07:06,950 --> 00:07:10,340
which both of those applications rely on

00:07:08,720 --> 00:07:12,380
like say some file in the kernel and

00:07:10,340 --> 00:07:13,820
then build the top level build system

00:07:12,380 --> 00:07:15,380
again it doesn't know about the

00:07:13,820 --> 00:07:17,750
dependencies down here and so it doesn't

00:07:15,380 --> 00:07:19,550
rebuild them so it's not it doesn't

00:07:17,750 --> 00:07:21,410
really work properly right it's not it's

00:07:19,550 --> 00:07:23,030
not at least as far as we can tell a

00:07:21,410 --> 00:07:25,850
good solution out of the box for this

00:07:23,030 --> 00:07:31,460
problem because we want to manage these

00:07:25,850 --> 00:07:32,660
dependencies and Sebastian says no he

00:07:31,460 --> 00:07:35,390
knows way more about Tzemach than I ever

00:07:32,660 --> 00:07:38,320
will it's just working as designed

00:07:35,390 --> 00:07:38,320
basically

00:07:55,509 --> 00:08:02,479
unknown yeah but it doesn't work the way

00:07:58,189 --> 00:08:03,739
we want is that the TLDR on that so this

00:08:02,479 --> 00:08:05,239
is kind of the approach that we've got

00:08:03,739 --> 00:08:06,559
right now and I'm just gonna to quick

00:08:05,239 --> 00:08:08,239
time check because I do want to try to

00:08:06,559 --> 00:08:09,709
leave some room for discussion although

00:08:08,239 --> 00:08:15,049
I expect that we're gonna be talking

00:08:09,709 --> 00:08:16,279
about this all week okay so see Mike has

00:08:15,049 --> 00:08:18,769
this feature called add subdirectory

00:08:16,279 --> 00:08:20,239
right and you can say you know they

00:08:18,769 --> 00:08:22,429
execute the script files in this

00:08:20,239 --> 00:08:26,089
subdirectory and include them in my

00:08:22,429 --> 00:08:29,839
current build system so right now what

00:08:26,089 --> 00:08:32,389
we have is a way to basically call add

00:08:29,839 --> 00:08:34,789
subdirectory on the top level

00:08:32,389 --> 00:08:36,709
application directory of another Zephyr

00:08:34,789 --> 00:08:39,800
application right so you've got one

00:08:36,709 --> 00:08:43,189
application which has a top-level

00:08:39,800 --> 00:08:44,449
cmakelists right and it's gonna via you

00:08:43,189 --> 00:08:46,009
know the mechanisms that you're probably

00:08:44,449 --> 00:08:47,959
familiar with if you're zephyr developer

00:08:46,009 --> 00:08:49,579
call into the mains effort build system

00:08:47,959 --> 00:08:51,410
right and then that's gonna add

00:08:49,579 --> 00:08:54,139
subdirectory and all the kernel drivers

00:08:51,410 --> 00:08:58,399
all the other subsystems one of the new

00:08:54,139 --> 00:09:01,279
things that you can do though is say i'm

00:08:58,399 --> 00:09:03,379
building all of this for my main image

00:09:01,279 --> 00:09:05,540
my app image right but you can also say

00:09:03,379 --> 00:09:07,879
i want you to add a new Zephyr image

00:09:05,540 --> 00:09:09,829
right and what that's gonna do is it's

00:09:07,879 --> 00:09:11,540
gonna clear out a lot of the global

00:09:09,829 --> 00:09:14,000
variable namespace that we kind of rely

00:09:11,540 --> 00:09:16,370
on within Zephyr so for example all our

00:09:14,000 --> 00:09:18,680
K config variables that are the result

00:09:16,370 --> 00:09:20,449
of merging our k config fragments become

00:09:18,680 --> 00:09:22,160
global see make variables in the Zephyr

00:09:20,449 --> 00:09:25,850
build system and we use that throughout

00:09:22,160 --> 00:09:29,209
to say add this C file to the build if

00:09:25,850 --> 00:09:31,610
def config feature right and so that

00:09:29,209 --> 00:09:34,129
obviously won't work with if we're

00:09:31,610 --> 00:09:35,480
trying to put all of this into one big C

00:09:34,129 --> 00:09:37,309
make build system which is what we're

00:09:35,480 --> 00:09:39,230
trying to do so we have this new magic

00:09:37,309 --> 00:09:40,970
thing called image and whenever you

00:09:39,230 --> 00:09:44,709
switch images you can then call add

00:09:40,970 --> 00:09:47,089
subdirectory on your new application

00:09:44,709 --> 00:09:49,550
top-level C make lists and it's gonna

00:09:47,089 --> 00:09:51,259
add it and you know reset all your kick

00:09:49,550 --> 00:09:54,709
all your config foods and do a bunch of

00:09:51,259 --> 00:09:56,930
other stuff now there there are some

00:09:54,709 --> 00:10:01,250
drawbacks to this because not everything

00:09:56,930 --> 00:10:03,110
in C m'q can be named spaced it has kind

00:10:01,250 --> 00:10:05,300
of this long legacy of backwards

00:10:03,110 --> 00:10:06,390
compatibility and that introduces some

00:10:05,300 --> 00:10:08,540
constraints into

00:10:06,390 --> 00:10:11,880
what you can name space in particular

00:10:08,540 --> 00:10:14,340
there is a global target named space so

00:10:11,880 --> 00:10:20,550
I cannot call something you know

00:10:14,340 --> 00:10:22,560
driver's USB whatever vendor and you

00:10:20,550 --> 00:10:23,760
know have that be the top-level target

00:10:22,560 --> 00:10:25,980
to build that library for some

00:10:23,760 --> 00:10:27,750
particular application and then reuse

00:10:25,980 --> 00:10:29,070
that target name for another application

00:10:27,750 --> 00:10:31,130
that may want to configure USB

00:10:29,070 --> 00:10:35,430
differently right so that's a problem

00:10:31,130 --> 00:10:38,460
and what we have chosen to do is prefix

00:10:35,430 --> 00:10:39,830
the names of targets with the name of

00:10:38,460 --> 00:10:42,000
the image that we're currently building

00:10:39,830 --> 00:10:45,750
and the same thing is true for certain

00:10:42,000 --> 00:10:47,280
global variables the cache right there

00:10:45,750 --> 00:10:49,860
are certain you know see make namespaces

00:10:47,280 --> 00:10:51,120
that we are prefixing with the name of

00:10:49,860 --> 00:10:52,950
the image right so this is not a small

00:10:51,120 --> 00:10:55,530
change this is a pretty big change that

00:10:52,950 --> 00:10:58,620
affects many many files throughout the

00:10:55,530 --> 00:11:00,240
build system one thing that we're trying

00:10:58,620 --> 00:11:02,940
to do with this PR since the first time

00:11:00,240 --> 00:11:04,830
that it was proposed upstream is that

00:11:02,940 --> 00:11:08,510
we've moved as many global variables as

00:11:04,830 --> 00:11:11,040
we could into target properties of this

00:11:08,510 --> 00:11:12,360
new target that we interact through a

00:11:11,040 --> 00:11:15,390
variable and so that's what's that's the

00:11:12,360 --> 00:11:17,730
first thing on the next-to-last second

00:11:15,390 --> 00:11:20,340
level bullet so there's this variable

00:11:17,730 --> 00:11:23,970
called Zephyr target and it expands to

00:11:20,340 --> 00:11:25,620
image Zephyr right and so you say I want

00:11:23,970 --> 00:11:28,200
you to set a property on the current

00:11:25,620 --> 00:11:30,180
Zephyr target and you as the author of

00:11:28,200 --> 00:11:32,640
like a driver level C make file don't

00:11:30,180 --> 00:11:34,140
need to know like which image at my

00:11:32,640 --> 00:11:35,550
building for it's just like this is some

00:11:34,140 --> 00:11:37,560
sort of property that's global to the

00:11:35,550 --> 00:11:39,630
image and so by moving as many things

00:11:37,560 --> 00:11:41,280
over to properties we're trying to

00:11:39,630 --> 00:11:43,170
decrease the scope of this but there are

00:11:41,280 --> 00:11:45,690
certain things like for example targets

00:11:43,170 --> 00:11:47,940
that we just can't change because it's a

00:11:45,690 --> 00:11:50,100
CMake thing so that's that's kind of a

00:11:47,940 --> 00:11:55,920
20-second overview of what we have

00:11:50,100 --> 00:11:57,390
proposed and I didn't you know I didn't

00:11:55,920 --> 00:11:58,800
write the C make parts of this all I did

00:11:57,390 --> 00:12:02,310
was kind of make it work with West and

00:11:58,800 --> 00:12:03,990
and tweak it a little bit so I'm looking

00:12:02,310 --> 00:12:05,970
at this as independently as I can and

00:12:03,990 --> 00:12:07,980
I'm trying to make lists of pros and

00:12:05,970 --> 00:12:10,080
cons that I think there is broad

00:12:07,980 --> 00:12:12,270
consensus on and of course again this is

00:12:10,080 --> 00:12:14,190
highly asterisks if you disagree that

00:12:12,270 --> 00:12:16,200
there's consensus on anything in this

00:12:14,190 --> 00:12:19,500
list like yell at me and I will

00:12:16,200 --> 00:12:21,480
I will be wrong so one of the pros is

00:12:19,500 --> 00:12:23,399
that this exists and it works we've

00:12:21,480 --> 00:12:26,490
shipped this downstream it has been part

00:12:23,399 --> 00:12:28,290
of official releases it works with Segar

00:12:26,490 --> 00:12:30,720
embedded studio which is the ide that we

00:12:28,290 --> 00:12:32,850
use so you know one major advantage is

00:12:30,720 --> 00:12:34,680
that within a single CMake build system

00:12:32,850 --> 00:12:36,720
which you can point an IDE at because I

00:12:34,680 --> 00:12:40,860
des understand Simic you can get an

00:12:36,720 --> 00:12:42,720
overview of your entire build it is you

00:12:40,860 --> 00:12:44,519
know easy to use from the perspective of

00:12:42,720 --> 00:12:46,529
building and flashing right because you

00:12:44,519 --> 00:12:47,970
can use the same tools you know if

00:12:46,529 --> 00:12:50,279
you're using a racemic and ninja or if

00:12:47,970 --> 00:12:52,170
you're using West build and flash you do

00:12:50,279 --> 00:12:53,970
it once and it builds all of the

00:12:52,170 --> 00:12:57,720
applications and knows how to flash them

00:12:53,970 --> 00:12:59,459
all together it does solve the

00:12:57,720 --> 00:13:00,690
performance problems right it's one big

00:12:59,459 --> 00:13:02,430
build system that means there's only one

00:13:00,690 --> 00:13:04,110
job server and so one since the

00:13:02,430 --> 00:13:05,430
dependencies are tracked properly you

00:13:04,110 --> 00:13:09,449
know different linker steps can be

00:13:05,430 --> 00:13:10,709
performed in parallel the fine-grained

00:13:09,449 --> 00:13:12,029
target and dependency sharing and

00:13:10,709 --> 00:13:13,320
configure time work is only done once

00:13:12,029 --> 00:13:14,790
kind of by definition because there's

00:13:13,320 --> 00:13:17,970
only one build system right that's what

00:13:14,790 --> 00:13:21,060
C make does that's its purpose so there

00:13:17,970 --> 00:13:22,410
are some cons one is that in its current

00:13:21,060 --> 00:13:24,449
form it doesn't allow multiple tool

00:13:22,410 --> 00:13:27,329
chains so if you're you know targeting

00:13:24,449 --> 00:13:28,980
two different architectures for example

00:13:27,329 --> 00:13:31,829
that's an issue we have done some early

00:13:28,980 --> 00:13:33,180
prototyping which is at least convinced

00:13:31,829 --> 00:13:35,040
us internally that this can be overcome

00:13:33,180 --> 00:13:36,600
with another layer of indirection like

00:13:35,040 --> 00:13:38,430
every every problem right so you point

00:13:36,600 --> 00:13:40,620
your your tool chain at at scripts that

00:13:38,430 --> 00:13:42,329
then knows some image specific context

00:13:40,620 --> 00:13:45,959
for what tool chain to call out to it's

00:13:42,329 --> 00:13:48,329
not solvable the other two are that it

00:13:45,959 --> 00:13:50,519
is complex and that it won't go away

00:13:48,329 --> 00:13:51,839
right so you need to know you know you

00:13:50,519 --> 00:13:54,779
will need to know about this if you

00:13:51,839 --> 00:13:58,680
develop at least driver or kernel level

00:13:54,779 --> 00:14:00,300
zephir code and that will cost some

00:13:58,680 --> 00:14:01,709
maintenance because you know you might

00:14:00,300 --> 00:14:02,910
forget to put the image there you might

00:14:01,709 --> 00:14:04,680
use the old target name without the

00:14:02,910 --> 00:14:05,670
image prefix and then it's gonna work

00:14:04,680 --> 00:14:09,000
when you're only building one

00:14:05,670 --> 00:14:10,560
application but subtly break in case you

00:14:09,000 --> 00:14:15,889
want to build that same application as a

00:14:10,560 --> 00:14:18,690
sub image right there are some

00:14:15,889 --> 00:14:21,000
differences of opinion where people

00:14:18,690 --> 00:14:22,889
believe that certain things are pros and

00:14:21,000 --> 00:14:24,750
true and other people do not believe

00:14:22,889 --> 00:14:27,779
that those things are true at all

00:14:24,750 --> 00:14:28,980
and likewise for cons there you know

00:14:27,779 --> 00:14:29,910
some people think that a non recursive

00:14:28,980 --> 00:14:31,050
build just like

00:14:29,910 --> 00:14:36,270
is the best practice and we should

00:14:31,050 --> 00:14:38,730
always do it I think the main opposition

00:14:36,270 --> 00:14:41,430
to that is like not if it's too

00:14:38,730 --> 00:14:44,600
complicated or intrusive and there seems

00:14:41,430 --> 00:14:45,950
to be a different perspective on that

00:14:44,600 --> 00:14:48,780
[Music]

00:14:45,950 --> 00:14:50,160
yeah you can kind of read it people you

00:14:48,780 --> 00:14:52,200
know people sort of feel like on the on

00:14:50,160 --> 00:14:53,850
the on the left yeah we're both looking

00:14:52,200 --> 00:14:56,520
at the same thing on the left you know

00:14:53,850 --> 00:14:58,410
that it's kind of it's worth it right I

00:14:56,520 --> 00:15:00,300
guess how I would try to sum it up that

00:14:58,410 --> 00:15:01,470
like given that this works given that it

00:15:00,300 --> 00:15:04,740
exists given that it's been deployed for

00:15:01,470 --> 00:15:07,320
a long time in production the fact that

00:15:04,740 --> 00:15:09,150
it introduces these complexity costs is

00:15:07,320 --> 00:15:11,550
worth it and then I think on the other

00:15:09,150 --> 00:15:13,710
side people are saying no we should do

00:15:11,550 --> 00:15:15,030
this elsewhere like doing this in CMake

00:15:13,710 --> 00:15:17,700
is not the right place to be doing this

00:15:15,030 --> 00:15:20,520
and again this is just like my read on

00:15:17,700 --> 00:15:22,860
the discussion and and please during the

00:15:20,520 --> 00:15:25,980
discussion tell me tell me what I got

00:15:22,860 --> 00:15:28,170
wrong okay so let's get to it I do have

00:15:25,980 --> 00:15:30,960
some ideas but I do kind of just want to

00:15:28,170 --> 00:15:33,330
let people talk I will skip to the last

00:15:30,960 --> 00:15:34,740
one which is you know obviously trying

00:15:33,330 --> 00:15:36,150
to guess what your users are doing is

00:15:34,740 --> 00:15:37,620
very hard and it's been really nice

00:15:36,150 --> 00:15:39,450
actually to have bricks here kind of

00:15:37,620 --> 00:15:41,460
telling us as a user how he feels about

00:15:39,450 --> 00:15:43,710
it and I would really encourage any

00:15:41,460 --> 00:15:46,890
Zephyr users that haven't had a chance

00:15:43,710 --> 00:15:50,310
to give their opinion to please please

00:15:46,890 --> 00:15:54,630
do so so that you know we're not just

00:15:50,310 --> 00:15:56,460
guessing well yeah so what is is this

00:15:54,630 --> 00:15:57,660
really better is this you know just do

00:15:56,460 --> 00:15:59,160
we want to keep the same way is

00:15:57,660 --> 00:16:03,120
recursive see make a viable alternative

00:15:59,160 --> 00:16:04,620
do we disagree entirely vehemently

00:16:03,120 --> 00:16:06,810
enough that we're never gonna be able to

00:16:04,620 --> 00:16:08,820
upstream this some some ideas for

00:16:06,810 --> 00:16:14,640
discussion but otherwise anybody wants

00:16:08,820 --> 00:16:17,000
the mic or we can just talk now you're

00:16:14,640 --> 00:16:18,210
shy okay that's fun

00:16:17,000 --> 00:16:21,540
[Music]

00:16:18,210 --> 00:16:21,540
anybody have any questions

00:16:32,320 --> 00:16:39,630
test test okay that sounds like it's

00:16:34,240 --> 00:16:42,910
working right so I don't know how

00:16:39,630 --> 00:16:44,980
recursive versus non recursive differs

00:16:42,910 --> 00:16:46,839
between see make and make you know

00:16:44,980 --> 00:16:50,440
there's the famous paper recursive make

00:16:46,839 --> 00:16:52,029
considered harmful and it talks about a

00:16:50,440 --> 00:16:53,949
lot of problems with doing recursive

00:16:52,029 --> 00:16:56,139
makes mostly about dependencies not

00:16:53,949 --> 00:16:58,149
having anything to do between the

00:16:56,139 --> 00:17:01,060
invitations and your bills don't work

00:16:58,149 --> 00:17:03,940
and it seems like you've got that same

00:17:01,060 --> 00:17:09,059
notion here of that stuff that shared

00:17:03,940 --> 00:17:11,410
between these would not be shared I

00:17:09,059 --> 00:17:13,360
guess the question is what are the I

00:17:11,410 --> 00:17:15,010
didn't see like spelling out this is the

00:17:13,360 --> 00:17:17,260
records first I've seen on the slides of

00:17:15,010 --> 00:17:20,530
recursive make is an alternative you

00:17:17,260 --> 00:17:22,449
talking about just like a top level so

00:17:20,530 --> 00:17:24,069
you make file that just invokes it see

00:17:22,449 --> 00:17:25,600
make several times kind of thing or

00:17:24,069 --> 00:17:33,250
separate build directories with scripts

00:17:25,600 --> 00:17:34,270
that kind of thing I mean at one level

00:17:33,250 --> 00:17:37,030
you could always have

00:17:34,270 --> 00:17:38,980
I mean think of how like Yocto does

00:17:37,030 --> 00:17:40,630
something like this where you know we've

00:17:38,980 --> 00:17:42,730
invoke see make and do it once this way

00:17:40,630 --> 00:17:46,000
and then we invoke it and do it this way

00:17:42,730 --> 00:17:47,620
and there's some external tool that then

00:17:46,000 --> 00:17:51,610
combines all of this together and just

00:17:47,620 --> 00:17:54,280
builds it and I I don't know if I have

00:17:51,610 --> 00:18:00,130
enough opinions about what's better or

00:17:54,280 --> 00:18:03,990
not on that but I don't think I don't

00:18:00,130 --> 00:18:03,990
know if I have a question so

00:18:08,740 --> 00:18:16,960
so the core of the problem of the

00:18:12,230 --> 00:18:20,150
recursive make you being harmful is that

00:18:16,960 --> 00:18:25,430
build systems work by having a graph

00:18:20,150 --> 00:18:29,170
they're tracking all dependencies but if

00:18:25,430 --> 00:18:32,150
you don't have one graph but several

00:18:29,170 --> 00:18:38,360
then and they're actually do exists

00:18:32,150 --> 00:18:42,290
dependencies between the graphs then the

00:18:38,360 --> 00:18:44,780
the the the solutions for pretending

00:18:42,290 --> 00:18:46,820
like you're one graph they don't scale

00:18:44,780 --> 00:18:52,340
very well and yeah we're not really sure

00:18:46,820 --> 00:19:01,660
how to yeah I can't comment specifically

00:18:52,340 --> 00:19:06,550
but yeah I think I read like i ported

00:19:01,660 --> 00:19:11,600
the linux kernel's build system k built

00:19:06,550 --> 00:19:14,480
from a fear or zephyr used to use like

00:19:11,600 --> 00:19:15,980
nearly a one-to-one a copy of the linux

00:19:14,480 --> 00:19:19,520
kernel's build system and i ported that

00:19:15,980 --> 00:19:24,940
to see make together with hamas and

00:19:19,520 --> 00:19:27,380
several people and in that top of the

00:19:24,940 --> 00:19:30,050
cable bill system it had like this

00:19:27,380 --> 00:19:32,650
comment about because we do recursive

00:19:30,050 --> 00:19:37,309
make you have to be very careful about

00:19:32,650 --> 00:19:40,220
the order that you include sub modules

00:19:37,309 --> 00:19:42,590
in the linux kernel so i'm not sure i

00:19:40,220 --> 00:19:44,660
agree that it works fine in the linux

00:19:42,590 --> 00:19:48,340
kernel but i guess someone else will

00:19:44,660 --> 00:19:48,340
have to comment on that

00:19:59,790 --> 00:20:02,420
yeah

00:20:07,740 --> 00:20:12,090
yeah that's even worse I would say

00:20:48,990 --> 00:20:58,559
versus not a kind of different software

00:21:31,280 --> 00:21:35,480
like purple configuration

00:21:48,060 --> 00:21:53,060
the question was is this in device tree

00:21:49,860 --> 00:21:53,060
and it's like yes

00:23:00,240 --> 00:23:05,830
yeah cuz they need energy could

00:23:03,279 --> 00:23:08,250
concurrently right there a booth and

00:23:05,830 --> 00:23:08,250
never come back

00:23:09,539 --> 00:23:12,539
right

00:24:58,720 --> 00:25:04,370
yeah yeah this is exactly the same thing

00:25:02,180 --> 00:25:07,040
that I maybe shed some right

00:25:04,370 --> 00:25:09,560
more from the outside because we are

00:25:07,040 --> 00:25:13,790
doing ibi systems and there we have

00:25:09,560 --> 00:25:16,070
really complex SLC's with big courseware

00:25:13,790 --> 00:25:18,920
Linux is running on and as a secure

00:25:16,070 --> 00:25:21,050
world and there are some tiny cores that

00:25:18,920 --> 00:25:23,120
are running on the same as IC and

00:25:21,050 --> 00:25:26,570
artists not safer in this case but

00:25:23,120 --> 00:25:28,190
anyway and but the problem is the same

00:25:26,570 --> 00:25:31,280
you have to share peripherals you have

00:25:28,190 --> 00:25:41,090
to share your flash your device three

00:25:31,280 --> 00:25:44,630
must be correct and no absolutely not I

00:25:41,090 --> 00:25:47,030
mean we have different artists that have

00:25:44,630 --> 00:25:49,670
completely different build systems and

00:25:47,030 --> 00:25:51,170
but in the end you still have the

00:25:49,670 --> 00:25:52,820
problem that you have to share some

00:25:51,170 --> 00:25:54,680
common configuration between the

00:25:52,820 --> 00:25:57,950
different parts it may be the flash

00:25:54,680 --> 00:26:00,440
layout it may be in the memory map which

00:25:57,950 --> 00:26:03,310
also boils down to the to the device

00:26:00,440 --> 00:26:03,310
tree of the kernel

00:26:15,269 --> 00:26:23,649
it is I mean we also have the problem

00:26:18,749 --> 00:26:26,200
yes if you also have shared headers yeah

00:26:23,649 --> 00:26:28,419
we have the f of Z we have also if ap is

00:26:26,200 --> 00:26:31,720
between the different course you know

00:26:28,419 --> 00:26:33,759
and they need to have to share some some

00:26:31,720 --> 00:26:39,489
header file some common definitions what

00:26:33,759 --> 00:26:41,200
the API calls are yeah about this this

00:26:39,489 --> 00:26:45,309
one is actually simple but for example

00:26:41,200 --> 00:26:47,499
we have some some parts on the system

00:26:45,309 --> 00:26:50,349
that to the can communication with the

00:26:47,499 --> 00:26:53,109
car and they have some very specific API

00:26:50,349 --> 00:26:55,570
is that are exposed to Linux and this is

00:26:53,109 --> 00:26:58,659
some kind of RPC calls and they have to

00:26:55,570 --> 00:27:01,570
share some common i IDL in the end so we

00:26:58,659 --> 00:27:04,149
have parts of the system that share

00:27:01,570 --> 00:27:09,009
really common source code and I think

00:27:04,149 --> 00:27:12,519
your problem is just one one one part of

00:27:09,009 --> 00:27:15,909
it so but there's a bigger scope it work

00:27:12,519 --> 00:27:18,220
here and the way how we solved it by our

00:27:15,909 --> 00:27:29,259
own tool so we we created a Maribelle

00:27:18,220 --> 00:27:34,509
tool to drive all these builds yeah so

00:27:29,259 --> 00:27:38,379
and it is the way how it does it is do

00:27:34,509 --> 00:27:41,349
you really you you get all your two

00:27:38,379 --> 00:27:43,509
chains configured by that and you put

00:27:41,349 --> 00:27:46,239
out the dependencies between those and

00:27:43,509 --> 00:27:49,629
then you let the tool build the

00:27:46,239 --> 00:27:51,609
different images in parallel and then

00:27:49,629 --> 00:27:53,950
stitch them together to bigger images

00:27:51,609 --> 00:27:58,019
and in the end you have some big flash

00:27:53,950 --> 00:27:58,019
image that you put onto your no flash

00:28:02,970 --> 00:28:08,410
yep you have to really separate these

00:28:06,280 --> 00:28:12,160
parts together and hand over the build

00:28:08,410 --> 00:28:24,670
results from from one package to the

00:28:12,160 --> 00:28:26,410
another one but you know yeah that's a

00:28:24,670 --> 00:28:30,610
big graph you have all different

00:28:26,410 --> 00:28:34,360
entities from NIMH free artists which is

00:28:30,610 --> 00:28:36,790
running on one core up to the busybox

00:28:34,360 --> 00:28:38,650
package the Linux kernel they are all

00:28:36,790 --> 00:28:41,470
different packages and they have

00:28:38,650 --> 00:28:44,320
dependencies between each other so the

00:28:41,470 --> 00:28:50,860
Dipsy needs the kernel headers and so on

00:28:44,320 --> 00:28:53,560
and then yes you're so we don't use

00:28:50,860 --> 00:29:29,620
Yocto anymore we just replace it also

00:28:53,560 --> 00:29:31,630
with the same - yeah but pippick doesn't

00:29:29,620 --> 00:29:34,770
really cope with the multi-tool try and

00:29:31,630 --> 00:29:34,770
very good

00:29:42,100 --> 00:29:46,750
I'm not sure if this one is really soft

00:30:05,770 --> 00:30:09,109
[Music]

00:30:18,640 --> 00:30:24,890
can be so relatively easily and

00:30:21,590 --> 00:30:28,310
expensively objective appreciation of

00:30:24,890 --> 00:30:32,260
course and an optimized manner with the

00:30:28,310 --> 00:30:32,260
current see make build system the others

00:30:36,970 --> 00:30:44,270
okay so I mean we can say okay let's do

00:30:40,910 --> 00:30:47,570
that this way but other use cases let's

00:30:44,270 --> 00:30:49,780
solve using some method tool but then we

00:30:47,570 --> 00:30:49,780
go

00:31:16,160 --> 00:31:30,180
then you have its I mean this this or

00:31:27,090 --> 00:31:32,880
that particular problem multiple images

00:31:30,180 --> 00:31:35,370
from a common code base that's this one

00:31:32,880 --> 00:31:39,120
now if your use case includes also

00:31:35,370 --> 00:31:41,160
stitching with pre-built binaries if it

00:31:39,120 --> 00:31:43,080
includes combining with Linux all of

00:31:41,160 --> 00:31:45,000
that you need a label but that

00:31:43,080 --> 00:31:47,130
particular problem is solved by this it

00:31:45,000 --> 00:31:48,960
solve in an efficient manner now you can

00:31:47,130 --> 00:31:51,630
argue that the complexity added to the

00:31:48,960 --> 00:31:54,930
belphins not work so then we might as

00:31:51,630 --> 00:31:58,170
well fix support all the news cases with

00:31:54,930 --> 00:32:00,000
a meta tool instead that's a fair we can

00:31:58,170 --> 00:32:02,460
discuss that but when I'm trying to get

00:32:00,000 --> 00:32:05,840
here is that this this this change does

00:32:02,460 --> 00:32:05,840
not try to solve all these problems

00:32:40,500 --> 00:32:44,520
and then you can scale it up

00:34:35,310 --> 00:34:39,690
just served for non-recursive

00:35:05,450 --> 00:35:11,360
that's the pull request for the person

00:35:07,980 --> 00:35:13,500
who is asking you got it okay

00:35:11,360 --> 00:35:17,280
all right I think we're about actually

00:35:13,500 --> 00:35:19,110
at a time I started my timer imminently

00:35:17,280 --> 00:35:20,460
let's keep discussing but for now I

00:35:19,110 --> 00:35:21,450
guess we should we should let the good

00:35:20,460 --> 00:35:25,920
folks who are in the back of the room

00:35:21,450 --> 00:35:28,660
and running the the room have their time

00:35:25,920 --> 00:35:33,350
back thanks a lot

00:35:28,660 --> 00:35:33,350

YouTube URL: https://www.youtube.com/watch?v=ZZJ-r94MUnI


