Title: Timing Boot Time Reduction Techniques - Michael Opdenacker, Bootlin
Publication date: 2019-10-29
Playlist: Open Source Summit & Embedded Linux Conference EU 2019 - Lyon
Description: 
	Timing Boot Time Reduction Techniques - Michael Opdenacker, Bootlin

During this talk, Michael will describe the most helpful techniques to reduce the boot time of embedded Linux systems, together with recent measures of the corresponding savings they bring, such as toolchain options, kernel compression options, kernel command line parameters, eliminating unnecessary copying in the bootloader, optimizing storage performance and understanding and using U-Boot's Falcon mode. Michael will also show tools to identify parts which can be eliminated (such as finding all the files not accessed during the boot sequence) or optimized.

Last but not least, time is relative to space as we all know. This aspect of the equation will also matter.
Captions: 
	00:00:00,060 --> 00:00:07,589
all right dad to come to start story so

00:00:05,069 --> 00:00:10,410
I realized that I just have 35 minutes

00:00:07,589 --> 00:00:12,630
for this talked it's bit short but I'm

00:00:10,410 --> 00:00:15,750
supposed to put fast anyway so let's do

00:00:12,630 --> 00:00:19,380
that efficiently I hope you have a fast

00:00:15,750 --> 00:00:24,420
brain as well at least at this time of

00:00:19,380 --> 00:00:26,250
the day so I microd Necker you can read

00:00:24,420 --> 00:00:29,760
that so actually this this presentation

00:00:26,250 --> 00:00:31,910
is a has a goal to actually give you

00:00:29,760 --> 00:00:34,290
some measurements about boot time

00:00:31,910 --> 00:00:36,600
techniques that can be they can be used

00:00:34,290 --> 00:00:38,070
so to help you guys know in advance

00:00:36,600 --> 00:00:41,670
where there are some technique is with

00:00:38,070 --> 00:00:44,910
worth exploring or not so I'm gonna be

00:00:41,670 --> 00:00:47,010
quick on the technical explanation like

00:00:44,910 --> 00:00:50,010
how this works and things like that and

00:00:47,010 --> 00:00:53,579
I'll more focus on the savings that I

00:00:50,010 --> 00:00:55,829
achieved on this kind of system so it's

00:00:53,579 --> 00:00:59,879
a basically a big evil bigger bone black

00:00:55,829 --> 00:01:05,100
with an LCD cape connected to it as a

00:00:59,879 --> 00:01:08,430
standard the USB webcam and it's is just

00:01:05,100 --> 00:01:11,390
playing on booting understanded the SD

00:01:08,430 --> 00:01:15,090
card from Kingston like cat for like a

00:01:11,390 --> 00:01:17,970
relatively normal when that's not

00:01:15,090 --> 00:01:20,000
especially fast so it's gonna on the

00:01:17,970 --> 00:01:22,200
software side it's gonna play ffmpeg

00:01:20,000 --> 00:01:25,650
just to show the video stream from the

00:01:22,200 --> 00:01:27,860
USB camera and this the initial time for

00:01:25,650 --> 00:01:30,900
the system was nine forty five seconds

00:01:27,860 --> 00:01:32,909
including a late the two seconds timer

00:01:30,900 --> 00:01:37,590
at the second time out in new boot so it

00:01:32,909 --> 00:01:41,759
easy to optimize of course another being

00:01:37,590 --> 00:01:47,670
very fair here so again here the goal is

00:01:41,759 --> 00:01:49,799
to to to give you results to use and in

00:01:47,670 --> 00:01:52,920
particular for you good Falcon mode I

00:01:49,799 --> 00:01:54,090
had I had trouble finding some details

00:01:52,920 --> 00:01:56,180
like it seems that not so many people

00:01:54,090 --> 00:01:58,259
are using it yet for bull time

00:01:56,180 --> 00:02:00,090
optimization it's and it's really worth

00:01:58,259 --> 00:02:02,159
it actually so I'll give you a share

00:02:00,090 --> 00:02:05,000
some some tech technical details and

00:02:02,159 --> 00:02:05,000
some results with you

00:02:05,060 --> 00:02:09,869
so here the there are great

00:02:08,250 --> 00:02:11,790
presentations about boot time reduction

00:02:09,869 --> 00:02:13,650
they already they have already been

00:02:11,790 --> 00:02:16,500
archived from previous year

00:02:13,650 --> 00:02:20,939
see conferences so I'll give links to

00:02:16,500 --> 00:02:24,000
them here I just want to give you simple

00:02:20,939 --> 00:02:26,819
principles the idea is to first focus on

00:02:24,000 --> 00:02:29,099
optimizing things that won't hurt your

00:02:26,819 --> 00:02:33,120
your ability to to further reduce and

00:02:29,099 --> 00:02:35,370
measure in the next steps of the of the

00:02:33,120 --> 00:02:38,459
boot process so start by the usually by

00:02:35,370 --> 00:02:40,079
the end like user space to chain and

00:02:38,459 --> 00:02:42,480
things like that and progressively move

00:02:40,079 --> 00:02:44,549
into the early boot steps like I mean

00:02:42,480 --> 00:02:46,409
the init scripts and then the kernel

00:02:44,549 --> 00:02:48,000
compression and eventually boot loader

00:02:46,409 --> 00:02:49,379
but when you optimize the boot loader

00:02:48,000 --> 00:02:51,629
you want touch the kernel again so

00:02:49,379 --> 00:02:54,060
that's fine if you do that the opposite

00:02:51,629 --> 00:02:56,879
way you lock down I mean you may you may

00:02:54,060 --> 00:02:58,980
get much much faster you have you lose

00:02:56,879 --> 00:03:00,540
the ability to to optimize the kernel

00:02:58,980 --> 00:03:04,829
anymore because you have no tracing no

00:03:00,540 --> 00:03:08,400
no debugging so the another technique

00:03:04,829 --> 00:03:11,760
I'm using too is keeping a quite slower

00:03:08,400 --> 00:03:15,599
relatively slow storage and quite as

00:03:11,760 --> 00:03:17,910
long as I can so that I can like it's

00:03:15,599 --> 00:03:20,310
like it's like a magnifying glass it

00:03:17,910 --> 00:03:24,440
makes that the times longer and easier

00:03:20,310 --> 00:03:27,720
to observe like some some some deltas in

00:03:24,440 --> 00:03:29,730
in behavior are easier to observe if

00:03:27,720 --> 00:03:34,139
they are slow enough this way I don't

00:03:29,730 --> 00:03:36,510
use like the fastest compression for

00:03:34,139 --> 00:03:38,340
example I keep the default one which

00:03:36,510 --> 00:03:43,139
makes a bigger kernel which takes more

00:03:38,340 --> 00:03:44,459
time and of course you can have a good

00:03:43,139 --> 00:03:47,790
time presentation without this quote

00:03:44,459 --> 00:03:51,260
from Donald that knows the premature

00:03:47,790 --> 00:03:56,310
optimization is the root of all evil

00:03:51,260 --> 00:03:59,729
so first to teen optimizations so I just

00:03:56,310 --> 00:04:02,269
compared an arm tool chain with tempo

00:03:59,729 --> 00:04:05,879
tool chain and the result was

00:04:02,269 --> 00:04:10,530
surprisingly good like with thumb I have

00:04:05,879 --> 00:04:13,229
like if the full system size is 18

00:04:10,530 --> 00:04:15,239
percent smaller than with an regular arm

00:04:13,229 --> 00:04:18,690
to change so it's really worth it to use

00:04:15,239 --> 00:04:20,940
it there's no real performance benefits

00:04:18,690 --> 00:04:24,060
it's it's about the same performance so

00:04:20,940 --> 00:04:24,990
I'll buy it I'll buy that smaller in

00:04:24,060 --> 00:04:29,970
same performance

00:04:24,990 --> 00:04:33,360
I keep this I also try to replace you

00:04:29,970 --> 00:04:36,870
see Lipsy well obviously GDC as well by

00:04:33,360 --> 00:04:40,440
muscle and we have a win in terms of

00:04:36,870 --> 00:04:42,360
Science Library size starting with a

00:04:40,440 --> 00:04:45,750
file system that has the library insta

00:04:42,360 --> 00:04:49,380
inside it so I'm saving 16 percent of

00:04:45,750 --> 00:04:51,000
the library size - it's worth it the

00:04:49,380 --> 00:04:53,699
goal eventually is to have a small

00:04:51,000 --> 00:04:56,190
system that will fit as an interim FS in

00:04:53,699 --> 00:04:58,560
the kernel binary to have like just one

00:04:56,190 --> 00:05:02,039
read from the MMC instead of multiple

00:04:58,560 --> 00:05:04,050
ones so one of the goals is to reduce

00:05:02,039 --> 00:05:07,199
the system size as well to make it

00:05:04,050 --> 00:05:11,840
faster to load so we start - I'll sleep

00:05:07,199 --> 00:05:14,820
see then optimizing the applications

00:05:11,840 --> 00:05:17,039
so did you general idea is to compile

00:05:14,820 --> 00:05:21,030
your application with less features less

00:05:17,039 --> 00:05:23,220
dependencies and yes so at the end the

00:05:21,030 --> 00:05:27,389
program is smaller and you have less

00:05:23,220 --> 00:05:29,729
less libraries that are built so at the

00:05:27,389 --> 00:05:31,560
end when I got with MFM peg was a

00:05:29,729 --> 00:05:35,460
reduction of the total file system size

00:05:31,560 --> 00:05:38,039
as generated by bed root from 16

00:05:35,460 --> 00:05:41,039
megabytes to 3 something megabytes like

00:05:38,039 --> 00:05:44,460
my almost minus 80 percent which saved

00:05:41,039 --> 00:05:47,389
about our animalistic 150 milliseconds

00:05:44,460 --> 00:05:50,659
in application loading execution time

00:05:47,389 --> 00:05:53,360
because probably you try less things

00:05:50,659 --> 00:05:55,979
normally it is loading on the amount but

00:05:53,360 --> 00:05:58,289
probably the code is trying to load a

00:05:55,979 --> 00:06:00,870
few things and testing things at the end

00:05:58,289 --> 00:06:03,449
the total reduction was about 350

00:06:00,870 --> 00:06:05,070
milliseconds maybe because there might

00:06:03,449 --> 00:06:12,840
be some fast amount time as well I

00:06:05,070 --> 00:06:16,110
expected less but let's take it now

00:06:12,840 --> 00:06:18,599
let's talk about the init init script

00:06:16,110 --> 00:06:22,620
optimization and also reducing the size

00:06:18,599 --> 00:06:24,180
of the root system as a whole so there's

00:06:22,620 --> 00:06:27,539
a this there are some techniques that

00:06:24,180 --> 00:06:29,610
are documented like to analyze the would

00:06:27,539 --> 00:06:31,259
process with boot chardee for example or

00:06:29,610 --> 00:06:36,610
using some and who that's associated

00:06:31,259 --> 00:06:39,009
with system D you don't mount

00:06:36,610 --> 00:06:40,750
Rockstar says you simplify the busybox

00:06:39,009 --> 00:06:42,550
configuration and think few things like

00:06:40,750 --> 00:06:45,909
that they are well documented also on

00:06:42,550 --> 00:06:48,550
the olynyk's wiki there's a nice chapter

00:06:45,909 --> 00:06:50,169
about boot time reduction and switching

00:06:48,550 --> 00:06:51,639
to static executables so I'll go through

00:06:50,169 --> 00:06:54,310
each of them

00:06:51,639 --> 00:06:57,849
so yes effectively if a smaller file

00:06:54,310 --> 00:07:00,340
system is faster to mount especially as

00:06:57,849 --> 00:07:02,590
our goal at the end is going to be to

00:07:00,340 --> 00:07:08,319
load the root filesystem inside a root

00:07:02,590 --> 00:07:10,150
filesystem so the kernel will be smaller

00:07:08,319 --> 00:07:12,550
to load from storage if the instrument

00:07:10,150 --> 00:07:22,990
has a smaller kernel decompression will

00:07:12,550 --> 00:07:25,900
be faster - how many well explain that

00:07:22,990 --> 00:07:28,210
later and if it should be the kernel and

00:07:25,900 --> 00:07:30,099
filesystem are loaded in inside a single

00:07:28,210 --> 00:07:31,779
read operation from storage which also

00:07:30,099 --> 00:07:34,360
makes sense rather than multiple small

00:07:31,779 --> 00:07:36,509
ones which may start need time to start

00:07:34,360 --> 00:07:38,500
and there could be some of overhead

00:07:36,509 --> 00:07:39,279
defined system layers and things like

00:07:38,500 --> 00:07:41,469
that

00:07:39,279 --> 00:07:45,699
the interim FS is a very efficient

00:07:41,469 --> 00:07:48,279
technique for existing files so a

00:07:45,699 --> 00:07:51,159
technique to detect unnecessary files is

00:07:48,279 --> 00:07:53,440
to take advantage of the fact that Linux

00:07:51,159 --> 00:07:55,389
stores the last access times for files

00:07:53,440 --> 00:07:58,210
so don't hesitate to boot your system

00:07:55,389 --> 00:08:02,169
the first time and then just take your

00:07:58,210 --> 00:08:04,120
SD card out and just run a fine - a time

00:08:02,169 --> 00:08:06,069
on it on it and you'll find the fact the

00:08:04,120 --> 00:08:08,110
files which have actually been accessed

00:08:06,069 --> 00:08:10,419
during the boot process so that's a way

00:08:08,110 --> 00:08:12,370
of eliminating the ones that that were

00:08:10,419 --> 00:08:20,050
not accessed or finding out at least and

00:08:12,370 --> 00:08:21,639
you can decide what else we also

00:08:20,050 --> 00:08:24,430
simplified the busybox configurations

00:08:21,639 --> 00:08:27,069
which this reduced the size from six

00:08:24,430 --> 00:08:30,789
hundred kilobytes 700 kilobytes to a six

00:08:27,069 --> 00:08:32,079
kilobytes with dynamically compiled

00:08:30,789 --> 00:08:34,779
against you see deep sea so it's quite

00:08:32,079 --> 00:08:36,519
nice in terms of science and I did at

00:08:34,779 --> 00:08:41,529
the end the total file system size was

00:08:36,519 --> 00:08:44,140
reduced by 24% like down to two that 33

00:08:41,529 --> 00:08:45,339
megabytes in terms of boot time

00:08:44,140 --> 00:08:48,490
difference it's hardly noticeable

00:08:45,339 --> 00:08:49,270
because of the on-demand loading I guess

00:08:48,490 --> 00:08:51,580
and

00:08:49,270 --> 00:08:54,090
because the any scripts didn't take much

00:08:51,580 --> 00:08:54,090
time anyway

00:08:55,900 --> 00:09:03,120
here in that system I just had two

00:08:58,180 --> 00:09:05,830
executables actually busybox and ffmpeg

00:09:03,120 --> 00:09:08,320
it really made sense to eliminate the

00:09:05,830 --> 00:09:09,670
shared libraries because you have a lot

00:09:08,320 --> 00:09:11,020
of code that you eventually don't use

00:09:09,670 --> 00:09:13,750
effectively you might copy some code

00:09:11,020 --> 00:09:15,730
inside two executables ffmpeg and

00:09:13,750 --> 00:09:18,580
busybox but the overhead is still not so

00:09:15,730 --> 00:09:22,330
much so here as you can see you can see

00:09:18,580 --> 00:09:24,310
the content it's the only thing that's

00:09:22,330 --> 00:09:28,330
left in the filesystem after my

00:09:24,310 --> 00:09:33,840
optimizations so eventually yes I'm down

00:09:28,330 --> 00:09:36,880
to 158 megabytes of total storage space

00:09:33,840 --> 00:09:41,530
as measured by the top archive that

00:09:36,880 --> 00:09:44,860
Bitteroot generates so that's that's all

00:09:41,530 --> 00:09:47,980
I need actually yeah some file system

00:09:44,860 --> 00:09:50,320
optimizations well we could test various

00:09:47,980 --> 00:09:57,100
file systems here the goal is simple we

00:09:50,320 --> 00:09:58,810
just switching to a need from FS so we

00:09:57,100 --> 00:10:00,940
did compared with other file systems but

00:09:58,810 --> 00:10:03,040
it really made sense to switch any any

00:10:00,940 --> 00:10:04,540
trimester person in that case so the

00:10:03,040 --> 00:10:08,170
root file system is in emitted in the

00:10:04,540 --> 00:10:10,120
kernel image this will just one access

00:10:08,170 --> 00:10:12,540
to storage as I told you you don't need

00:10:10,120 --> 00:10:15,190
a block storage and file system drivers

00:10:12,540 --> 00:10:16,450
so the kernel is going to be bigger

00:10:15,190 --> 00:10:22,900
because you include the file system

00:10:16,450 --> 00:10:24,280
inside but once you remove the once

00:10:22,900 --> 00:10:26,260
you'll remove the next slide actually

00:10:24,280 --> 00:10:29,320
once you'll remove the block support and

00:10:26,260 --> 00:10:31,900
MMC support in the chrono you use you

00:10:29,320 --> 00:10:33,670
actually get back the size the overhead

00:10:31,900 --> 00:10:35,980
no no not exactly with the boot time

00:10:33,670 --> 00:10:38,620
that you that you lost because the

00:10:35,980 --> 00:10:40,000
kernel was bigger the car was still

00:10:38,620 --> 00:10:44,530
bigger with any trauma fest and it was

00:10:40,000 --> 00:10:46,540
before but you recover the the extra

00:10:44,530 --> 00:10:49,270
time decompressing the kernel and

00:10:46,540 --> 00:10:51,700
copying it so there's something you have

00:10:49,270 --> 00:10:53,710
to remember that people may not realize

00:10:51,700 --> 00:10:56,710
is that it's very important to not

00:10:53,710 --> 00:10:58,270
compress the inner SRAM FS which is not

00:10:56,710 --> 00:10:59,140
the default at least for the big bone

00:10:58,270 --> 00:11:02,020
black

00:10:59,140 --> 00:11:06,490
def config file so make sure you have

00:11:02,020 --> 00:11:09,040
any time FS sorry compression none

00:11:06,490 --> 00:11:11,380
otherwise the could the interface is

00:11:09,040 --> 00:11:13,180
compress it's compressed twice once

00:11:11,380 --> 00:11:17,560
before being emitted in the kernel and

00:11:13,180 --> 00:11:20,230
the kernel compresses it again so this

00:11:17,560 --> 00:11:22,770
actually achieved like a reduction of

00:11:20,230 --> 00:11:31,410
size of 200 kilobytes and saved about

00:11:22,770 --> 00:11:37,000
170 mega many seconds of boot time right

00:11:31,410 --> 00:11:40,810
so I so at the end effectively I I got

00:11:37,000 --> 00:11:42,670
back the same boot time as before even a

00:11:40,810 --> 00:11:46,780
little less than before even though the

00:11:42,670 --> 00:11:49,960
kernel was bigger thanks to having less

00:11:46,780 --> 00:11:51,910
things to less things to initialize at

00:11:49,960 --> 00:11:58,030
boot time like no block support no

00:11:51,910 --> 00:12:02,170
immensity support now if you worried

00:11:58,030 --> 00:12:05,710
about current optimizations you notice

00:12:02,170 --> 00:12:08,320
this in code debug feature in the kernel

00:12:05,710 --> 00:12:10,260
that allows you to to dump actually in

00:12:08,320 --> 00:12:13,540
for some information about the starting

00:12:10,260 --> 00:12:16,720
time and ending time of function calls

00:12:13,540 --> 00:12:19,870
during the boot process so you can use

00:12:16,720 --> 00:12:22,570
this to dump more information in the

00:12:19,870 --> 00:12:24,730
kernel log and then you write your DMS

00:12:22,570 --> 00:12:27,090
stitch or you you copy the console

00:12:24,730 --> 00:12:29,920
output to a file and you process it with

00:12:27,090 --> 00:12:33,390
scripts good granted PL and it generates

00:12:29,920 --> 00:12:38,350
a graph like this with the biggest

00:12:33,390 --> 00:12:41,650
consumers of boot time so when one of

00:12:38,350 --> 00:12:43,810
the first ones was done up first first

00:12:41,650 --> 00:12:46,510
the technique you could use you could

00:12:43,810 --> 00:12:48,670
okay you actually get the names of the

00:12:46,510 --> 00:12:50,650
functions here you can look at look at

00:12:48,670 --> 00:12:52,720
look them up in the EDX here typically

00:12:50,650 --> 00:12:55,660
it excited boot in that con that indexes

00:12:52,720 --> 00:12:57,820
the kernel source code and then you can

00:12:55,660 --> 00:12:59,920
try to eliminate to figure out what it

00:12:57,820 --> 00:13:01,800
what this means and whether you need it

00:12:59,920 --> 00:13:06,550
or not

00:13:01,800 --> 00:13:08,320
so just be aware that some functions

00:13:06,550 --> 00:13:09,970
that are reported by the unit code debug

00:13:08,320 --> 00:13:11,650
are actually the name of a module

00:13:09,970 --> 00:13:11,860
underscore in it they don't correspond

00:13:11,650 --> 00:13:14,430
to

00:13:11,860 --> 00:13:17,170
actual function name in the source code

00:13:14,430 --> 00:13:18,970
then you can use some techniques to try

00:13:17,170 --> 00:13:20,769
to optimize the existing drivers like

00:13:18,970 --> 00:13:25,089
looking for parameters that will impact

00:13:20,769 --> 00:13:28,839
the behavior of of modules and account

00:13:25,089 --> 00:13:32,760
for the increased delay so just an

00:13:28,839 --> 00:13:36,370
example using this I I realized that

00:13:32,760 --> 00:13:38,890
before this this tracer in it traces to

00:13:36,370 --> 00:13:41,350
a CFS so only in it retracing

00:13:38,890 --> 00:13:43,839
infrastructure here was taking about

00:13:41,350 --> 00:13:46,209
like five hundred and fifty milliseconds

00:13:43,839 --> 00:13:48,010
to it to initialize that was enabled by

00:13:46,209 --> 00:13:54,940
default so I removed it and see the lot

00:13:48,010 --> 00:13:58,120
of space and n time others

00:13:54,940 --> 00:14:00,399
there's the TTY interface the serial

00:13:58,120 --> 00:14:03,940
interface for the O map which was taking

00:14:00,399 --> 00:14:05,860
a huge amount of time I didn't find an

00:14:03,940 --> 00:14:08,290
obvious reason in the code I found some

00:14:05,860 --> 00:14:10,360
parameters corresponding to the number

00:14:08,290 --> 00:14:14,790
of TT Y's that are initialized but

00:14:10,360 --> 00:14:18,640
haven't managed to to change that yet

00:14:14,790 --> 00:14:20,470
other things like a network driver that

00:14:18,640 --> 00:14:22,920
need that that will be disabled anyway

00:14:20,470 --> 00:14:25,720
so I'll took care of it

00:14:22,920 --> 00:14:28,329
some things that that are related to the

00:14:25,720 --> 00:14:30,070
USB initialization of the camera

00:14:28,329 --> 00:14:32,410
it cannot be skipped I have to keep it

00:14:30,070 --> 00:14:34,390
and all your other ones were actually

00:14:32,410 --> 00:14:36,010
not low-hanging fruit

00:14:34,390 --> 00:14:38,920
there they were quite big so quite small

00:14:36,010 --> 00:14:39,970
sorry so I meant by expected to save

00:14:38,920 --> 00:14:42,190
that the corresponding time by

00:14:39,970 --> 00:14:43,990
eliminating some features from them from

00:14:42,190 --> 00:14:45,880
the kernel by working on a controller

00:14:43,990 --> 00:14:50,860
configuration and reducing the number of

00:14:45,880 --> 00:14:52,930
features the preset loops per Jaffe is a

00:14:50,860 --> 00:14:55,420
well-documented technique for reducing

00:14:52,930 --> 00:14:57,910
the time so when you boot for the first

00:14:55,420 --> 00:14:59,890
time the kernel is going to estimate how

00:14:57,910 --> 00:15:04,810
fast you'd go through the calibration

00:14:59,890 --> 00:15:07,390
loop that you use in new delay so it's

00:15:04,810 --> 00:15:09,670
not-it's not necessary to run this this

00:15:07,390 --> 00:15:12,160
loop every time you just do it once

00:15:09,670 --> 00:15:14,769
get the loops per GC value and feed it

00:15:12,160 --> 00:15:16,300
to the kernel command line so in in the

00:15:14,769 --> 00:15:21,610
past were saving more time now it's

00:15:16,300 --> 00:15:22,390
saving 82 milliseconds on linux the in

00:15:21,610 --> 00:15:23,950
the next wiki

00:15:22,390 --> 00:15:27,790
maybe still 200 millisecond

00:15:23,950 --> 00:15:32,640
if I recall correctly or 25g fees or

00:15:27,790 --> 00:15:32,640
250g fees or 25 degrees

00:15:38,320 --> 00:15:43,330
another thing is SMP so people were

00:15:41,800 --> 00:15:44,920
saying tryouts and people that have

00:15:43,330 --> 00:15:47,470
never tried and if activity on a single

00:15:44,920 --> 00:15:49,060
core cpu or even in a multi-course if it

00:15:47,470 --> 00:15:53,650
could make sense to disable its MP which

00:15:49,060 --> 00:15:55,870
makes your system faster like this like

00:15:53,650 --> 00:15:59,770
hundred and twenty six milliseconds of

00:15:55,870 --> 00:16:01,140
boot time savings and noticeable size

00:15:59,770 --> 00:16:03,430
reduction as well

00:16:01,140 --> 00:16:04,780
compressed kernel so all the time and

00:16:03,430 --> 00:16:06,970
when I mention a kernel size it's going

00:16:04,780 --> 00:16:09,340
to be compressed so it's even bigger if

00:16:06,970 --> 00:16:11,710
you decompress it and it also contains

00:16:09,340 --> 00:16:13,120
the neutron manifest so it is not

00:16:11,710 --> 00:16:15,670
completely fair

00:16:13,120 --> 00:16:17,530
I mean you if you if you you remove the

00:16:15,670 --> 00:16:20,110
interim emphasize inside the kernel it's

00:16:17,530 --> 00:16:21,850
even better setting savings so here if

00:16:20,110 --> 00:16:24,850
you have only one CPU core you could

00:16:21,850 --> 00:16:26,050
that's a clear winner otherwise if you

00:16:24,850 --> 00:16:28,930
have multiple cores you might try to

00:16:26,050 --> 00:16:30,490
start with you had you need SMP of

00:16:28,930 --> 00:16:33,040
course but you may try with one core and

00:16:30,490 --> 00:16:35,200
plug in the the the next ones I don't

00:16:33,040 --> 00:16:39,310
know but it's good with what it's going

00:16:35,200 --> 00:16:41,680
to give you removing kernel module

00:16:39,310 --> 00:16:43,750
support will save 82 kilobytes of

00:16:41,680 --> 00:16:46,240
compressed kernel size 20 milliseconds

00:16:43,750 --> 00:16:48,100
of boot time I had a bigger number in

00:16:46,240 --> 00:16:49,960
mind but now that's better

00:16:48,100 --> 00:16:52,210
probably I remember it from past

00:16:49,960 --> 00:16:53,740
experiments something like 300 kilobytes

00:16:52,210 --> 00:16:58,390
but now it's more efficient I guess but

00:16:53,740 --> 00:17:00,760
it's again it's the compressed kernel so

00:16:58,390 --> 00:17:05,860
be careful when you do this be conscious

00:17:00,760 --> 00:17:07,570
take your time you end up like being

00:17:05,860 --> 00:17:08,920
very feeling lucky and removing lots of

00:17:07,570 --> 00:17:14,920
things and you have no clue why your

00:17:08,920 --> 00:17:18,610
kernel doesn't boot anymore oh yes and

00:17:14,920 --> 00:17:21,810
notice that when I when I had to do to

00:17:18,610 --> 00:17:24,910
do this is first remove all modules

00:17:21,810 --> 00:17:26,320
otherwise if I remove module support all

00:17:24,910 --> 00:17:27,730
the modules are turned into which I

00:17:26,320 --> 00:17:30,460
don't use in my system I don't hold

00:17:27,730 --> 00:17:32,410
modules are turned into static ones and

00:17:30,460 --> 00:17:34,150
you end up with features that you don't

00:17:32,410 --> 00:17:36,250
know whether you can remove them on

00:17:34,150 --> 00:17:36,880
earth so I'm looking for a way to turn

00:17:36,250 --> 00:17:40,059
on module

00:17:36,880 --> 00:17:43,809
- no in a automatic where so maybe by

00:17:40,059 --> 00:17:45,429
just doing a set on the config files but

00:17:43,809 --> 00:17:48,309
it is kind of disrupts and dependencies

00:17:45,429 --> 00:17:51,370
they're not sure exactly what the best

00:17:48,309 --> 00:17:56,350
way is to turn modules and to know maybe

00:17:51,370 --> 00:17:57,610
a new star config make something or no

00:17:56,350 --> 00:18:00,760
modules or something like that would be

00:17:57,610 --> 00:18:03,760
will be nice so remove all modules first

00:18:00,760 --> 00:18:06,250
and then you can remove module support

00:18:03,760 --> 00:18:11,080
and then remove the static ones that you

00:18:06,250 --> 00:18:12,909
don't need another technique is to

00:18:11,080 --> 00:18:14,020
silence the console with the quiet

00:18:12,909 --> 00:18:18,760
command line parameter

00:18:14,020 --> 00:18:21,100
it says 577 milliseconds that's good

00:18:18,760 --> 00:18:23,409
that's very nice because the console is

00:18:21,100 --> 00:18:25,419
a slow device so that's easy to

00:18:23,409 --> 00:18:28,750
understand why it it saves that much

00:18:25,419 --> 00:18:31,659
time then you of course you can go ahead

00:18:28,750 --> 00:18:36,039
and beyond and remove complete support

00:18:31,659 --> 00:18:37,630
for writing messages like even the

00:18:36,039 --> 00:18:40,090
messages don't don't get compiled in

00:18:37,630 --> 00:18:43,090
which is a lot of colonel spice

00:18:40,090 --> 00:18:47,260
so disabled contain print k config bug

00:18:43,090 --> 00:18:49,690
which says write 5% of the size also

00:18:47,260 --> 00:18:52,440
removing kids all seems surprised me

00:18:49,690 --> 00:18:54,970
because it's saved like a hundred and

00:18:52,440 --> 00:18:57,370
hundred seven kilobytes for the

00:18:54,970 --> 00:19:00,760
compressed kernel so it means it's a lot

00:18:57,370 --> 00:19:02,650
of space the total savings for both

00:19:00,760 --> 00:19:05,049
although these things I didn't cinder in

00:19:02,650 --> 00:19:07,809
turning of the kernel messages like

00:19:05,049 --> 00:19:09,970
saved a lot of time seven hundred

00:19:07,809 --> 00:19:12,340
megabyte a milliseconds and more than

00:19:09,970 --> 00:19:15,549
200 kilobytes in the compressed can also

00:19:12,340 --> 00:19:20,799
in terms of before compression it met is

00:19:15,549 --> 00:19:22,960
probably much more using config embedded

00:19:20,799 --> 00:19:26,890
in config expert allows you to to turn

00:19:22,960 --> 00:19:29,200
your generate kernel which can run any

00:19:26,890 --> 00:19:31,510
application into a dedicated one which

00:19:29,200 --> 00:19:34,600
can only render the system calls that

00:19:31,510 --> 00:19:37,390
you that you need to know to run so it

00:19:34,600 --> 00:19:39,520
can you can come out like compile out

00:19:37,390 --> 00:19:42,610
some system calls that you're sure you

00:19:39,520 --> 00:19:45,250
never use in your particular system this

00:19:42,610 --> 00:19:47,950
reduces the the size by 51 kilobytes

00:19:45,250 --> 00:19:50,260
compressed and a good time by 34

00:19:47,950 --> 00:19:50,800
milliseconds essentially because there's

00:19:50,260 --> 00:19:55,410
less

00:19:50,800 --> 00:19:59,230
to initialize and to correlate smaller I

00:19:55,410 --> 00:19:59,590
tried some to Colonel didn't work this

00:19:59,230 --> 00:20:01,480
time

00:19:59,590 --> 00:20:04,210
so in userspace twas a good result but

00:20:01,480 --> 00:20:07,960
in in kernel space surprisingly the same

00:20:04,210 --> 00:20:10,630
tool chain I got 40 kilobytes extra

00:20:07,960 --> 00:20:12,760
space and a total boost time that was

00:20:10,630 --> 00:20:15,520
also increased by 5 milliseconds so I I

00:20:12,760 --> 00:20:20,440
didn't select that one I probably need

00:20:15,520 --> 00:20:27,760
to find any idea why this this is this

00:20:20,440 --> 00:20:30,760
way ok so I did I did try effectively to

00:20:27,760 --> 00:20:34,920
do disabled arm and wind separately but

00:20:30,760 --> 00:20:34,920
you you device to do that together so

00:20:35,670 --> 00:20:44,770
I'll try yeah thanks oh I do that the

00:20:42,400 --> 00:20:47,230
other way like first disable the arm and

00:20:44,770 --> 00:20:50,980
unwinder and then and this and then

00:20:47,230 --> 00:20:53,950
thumb okay sounds good I made some tests

00:20:50,980 --> 00:20:56,680
with the slab locators no change slab is

00:20:53,950 --> 00:20:58,870
still the best slab which is supposed to

00:20:56,680 --> 00:21:01,360
be much simpler is actually not so good

00:20:58,870 --> 00:21:07,960
in terms of performance it's a disaster

00:21:01,360 --> 00:21:10,720
even for well I have I have a like 511

00:21:07,960 --> 00:21:14,740
512 megabytes of RAM so maybe it's too

00:21:10,720 --> 00:21:17,710
much full of slob so I I stuck to slab

00:21:14,740 --> 00:21:21,910
so slob apparently makes sense for very

00:21:17,710 --> 00:21:23,770
small systems with very small amount of

00:21:21,910 --> 00:21:27,040
memory if I had reduced the amount of

00:21:23,770 --> 00:21:29,020
RAM maybe I had an idea like boot my

00:21:27,040 --> 00:21:31,630
bigger bone black with just 16 Meg's of

00:21:29,020 --> 00:21:33,970
RAM and see if it gets bigger if it gets

00:21:31,630 --> 00:21:37,840
better III forgot about that

00:21:33,970 --> 00:21:40,840
that that idea but effectively it's much

00:21:37,840 --> 00:21:44,680
much much much slower like more than one

00:21:40,840 --> 00:21:48,040
almost 150 seconds of increased boot

00:21:44,680 --> 00:21:51,820
time kernel compression is interesting

00:21:48,040 --> 00:21:55,120
too you have various compression schemes

00:21:51,820 --> 00:21:57,580
that are available by default it's Ezard

00:21:55,120 --> 00:22:01,620
ma at least in born black I guess it's

00:21:57,580 --> 00:22:04,330
board dependent or maybe it's a default

00:22:01,620 --> 00:22:08,409
which makes sense I guess for

00:22:04,330 --> 00:22:10,059
say t6 so I made some tests I've dated a

00:22:08,409 --> 00:22:14,470
test I had before which were based on

00:22:10,059 --> 00:22:17,590
Twitter - internal so here as you can

00:22:14,470 --> 00:22:19,809
see as the DOE wins over as their ma and

00:22:17,590 --> 00:22:23,169
even gzip which is actually the closest

00:22:19,809 --> 00:22:25,590
one so the best contenders are gzip and

00:22:23,169 --> 00:22:29,260
instead open their zero wins so f 0 is a

00:22:25,590 --> 00:22:31,360
is a very fancy compressor it doesn't

00:22:29,260 --> 00:22:33,700
compress as well as gzip can do like

00:22:31,360 --> 00:22:35,740
your 15% less something like that but

00:22:33,700 --> 00:22:38,110
it's very fast so yeah you have a bit

00:22:35,740 --> 00:22:42,490
bigger kernel but it's much faster to

00:22:38,110 --> 00:22:45,190
decompress at that time it was time to

00:22:42,490 --> 00:22:49,870
switch to faster storage because we are

00:22:45,190 --> 00:22:53,409
closed between a gzip and and I said oh

00:22:49,870 --> 00:22:56,740
so I I selected some some SD cards with

00:22:53,409 --> 00:22:58,809
better performance even and eventually

00:22:56,740 --> 00:23:01,360
when it happened I found a model model

00:22:58,809 --> 00:23:04,120
that was not the highest end model of SD

00:23:01,360 --> 00:23:06,220
cards but it was the guest the best

00:23:04,120 --> 00:23:09,010
performance like I could get like if

00:23:06,220 --> 00:23:11,950
even if you take it a SanDisk extreme

00:23:09,010 --> 00:23:13,179
extreme extreme something you the

00:23:11,950 --> 00:23:15,340
limitation is eventually where the

00:23:13,179 --> 00:23:18,279
hardware can do in terms of reach

00:23:15,340 --> 00:23:23,320
performance I guess so here are those

00:23:18,279 --> 00:23:25,990
tailwinds even with first yeah the

00:23:23,320 --> 00:23:27,909
difference is about the same but I did

00:23:25,990 --> 00:23:31,090
then from that from now on I am sticking

00:23:27,909 --> 00:23:37,029
on the faster storage but I didn't want

00:23:31,090 --> 00:23:39,039
that to disturb the the tests I tried a

00:23:37,029 --> 00:23:42,419
cc optimized for size so compiling the

00:23:39,039 --> 00:23:45,460
kernel with - OS instead of - OH -

00:23:42,419 --> 00:23:46,960
actually the the results depends on how

00:23:45,460 --> 00:23:51,639
fast your CPU is so on the bigger bone

00:23:46,960 --> 00:23:57,070
black the winner is o - the kernel

00:23:51,639 --> 00:24:01,059
eventually is now OS is a little faster

00:23:57,070 --> 00:24:03,850
a little faster but hardly four

00:24:01,059 --> 00:24:07,720
milliseconds but if you have a slower

00:24:03,850 --> 00:24:10,450
CPU you can really have always slowing

00:24:07,720 --> 00:24:12,159
down your machine significantly and keep

00:24:10,450 --> 00:24:14,740
in mind that the system calls that

00:24:12,159 --> 00:24:17,470
you're making we'll run some kernel

00:24:14,740 --> 00:24:18,340
routines that will be slower to to to to

00:24:17,470 --> 00:24:20,890
execute so

00:24:18,340 --> 00:24:23,950
that made me mad that might not always

00:24:20,890 --> 00:24:26,890
be a good solution to use always in

00:24:23,950 --> 00:24:30,940
terms of long long long term performance

00:24:26,890 --> 00:24:33,160
so here as I chose OS but it it really

00:24:30,940 --> 00:24:37,450
depends on on your on your platform on

00:24:33,160 --> 00:24:39,940
how fast your CPU can be alright slow it

00:24:37,450 --> 00:24:43,150
can be other things removing the proc

00:24:39,940 --> 00:24:46,240
file system removes about 50 kilobytes

00:24:43,150 --> 00:24:49,270
of space but in my case even though proc

00:24:46,240 --> 00:24:50,920
was not mounted I believe ffmpeg stopped

00:24:49,270 --> 00:24:53,620
working when I removed support for

00:24:50,920 --> 00:24:55,960
Prague so maybe ffmpeg months proc by

00:24:53,620 --> 00:24:59,680
itself if it doesn't find it that's

00:24:55,960 --> 00:25:03,850
funny so at least I could remove some

00:24:59,680 --> 00:25:05,190
some support like /proc slices but saved

00:25:03,850 --> 00:25:10,500
a little bit not much

00:25:05,190 --> 00:25:13,750
removing CSFs saved to 22 kilobytes and

00:25:10,500 --> 00:25:17,620
35 milliseconds of boot time so that's

00:25:13,750 --> 00:25:19,150
good so you can do that if that's

00:25:17,620 --> 00:25:21,940
compatible with your like what your

00:25:19,150 --> 00:25:23,740
applications are expecting of course so

00:25:21,940 --> 00:25:27,900
if you're lucky you don't use Provinces

00:25:23,740 --> 00:25:31,060
you're fine otherwise you can't do that

00:25:27,900 --> 00:25:32,590
removing all the compiled time checks

00:25:31,060 --> 00:25:36,360
all the compiler options in kernel

00:25:32,590 --> 00:25:38,680
hacking will say about 40 kilobytes

00:25:36,360 --> 00:25:41,170
especially configurable info which I

00:25:38,680 --> 00:25:43,560
expect it to be bigger and also

00:25:41,170 --> 00:25:46,740
effectively changing the arm and winder

00:25:43,560 --> 00:25:50,680
technique for nicer stack traces

00:25:46,740 --> 00:25:55,000
replacing the EAB is stack and unwinder

00:25:50,680 --> 00:25:57,370
by the default one saves effectively 24

00:25:55,000 --> 00:26:00,960
kilobytes of space so I'll try with the

00:25:57,370 --> 00:26:05,610
thumb too and see how they they interact

00:26:00,960 --> 00:26:10,630
so there's a little bit of here increase

00:26:05,610 --> 00:26:14,950
and in terms of of booting but it's it's

00:26:10,630 --> 00:26:18,400
almost negligible so I kept this the

00:26:14,950 --> 00:26:21,850
default and minor now in the original

00:26:18,400 --> 00:26:23,770
and wonderful form another technique you

00:26:21,850 --> 00:26:26,320
can use is I've been appending the DB to

00:26:23,770 --> 00:26:29,620
the to the kernel it's just because I

00:26:26,320 --> 00:26:31,890
observed that I observed that if you a

00:26:29,620 --> 00:26:34,980
new boot you see that the first

00:26:31,890 --> 00:26:38,040
load loading of the the image is as fast

00:26:34,980 --> 00:26:40,320
because it's big enough but the TTB is

00:26:38,040 --> 00:26:42,570
smaller and therefore the performance is

00:26:40,320 --> 00:26:46,320
that but you is not the best one and

00:26:42,570 --> 00:26:50,280
therefore oops the the idea was to use

00:26:46,320 --> 00:26:53,040
the sorry the old technique when you boo

00:26:50,280 --> 00:26:55,620
didn't support the DTV you just appended

00:26:53,040 --> 00:26:58,080
the TTB at the end of the kernel and the

00:26:55,620 --> 00:27:00,360
kernel binary and it just works so I'm

00:26:58,080 --> 00:27:03,750
I'm just doing this like cutting them

00:27:00,360 --> 00:27:05,130
and and loading that I just have one

00:27:03,750 --> 00:27:06,510
image to load instead of two

00:27:05,130 --> 00:27:08,850
and if activity the performance is

00:27:06,510 --> 00:27:12,750
better like I saved 20 20 milliseconds

00:27:08,850 --> 00:27:15,270
of boot time like I measure that at

00:27:12,750 --> 00:27:19,320
kernel starting kernel time user space

00:27:15,270 --> 00:27:21,419
starting time it's a little bit but can

00:27:19,320 --> 00:27:24,110
it can give you the extra milliseconds

00:27:21,419 --> 00:27:26,669
that you need to achieve your objectives

00:27:24,110 --> 00:27:29,040
and to finish the bootloader

00:27:26,669 --> 00:27:30,360
optimizations so there are lots of

00:27:29,040 --> 00:27:33,120
techniques that are well documented for

00:27:30,360 --> 00:27:36,419
improving your boot which is a slow slow

00:27:33,120 --> 00:27:38,730
program by default here I just decided

00:27:36,419 --> 00:27:42,630
to skip you boot all the way and using

00:27:38,730 --> 00:27:45,150
the Falcon mode so it's just instead of

00:27:42,630 --> 00:27:47,549
loading the the second stage of your

00:27:45,150 --> 00:27:49,620
boot you just load Linux right away

00:27:47,549 --> 00:27:51,600
taking advantage of the front Falcon mod

00:27:49,620 --> 00:27:53,850
infrastructure of failure boot which is

00:27:51,600 --> 00:27:55,919
actually easy to use and the nice thing

00:27:53,850 --> 00:27:58,260
about it is the same technique for for

00:27:55,919 --> 00:28:01,910
using it whatever the body that that you

00:27:58,260 --> 00:28:06,720
have provided it supports the u-boot SPL

00:28:01,910 --> 00:28:08,610
so you need you good legacy image so you

00:28:06,720 --> 00:28:11,370
image instead of a third image so you

00:28:08,610 --> 00:28:13,140
have to load the loading address of the

00:28:11,370 --> 00:28:16,160
that kernel inside the you image

00:28:13,140 --> 00:28:20,370
container you copy that to the SD card

00:28:16,160 --> 00:28:22,169
an optimization in you do you would you

00:28:20,370 --> 00:28:24,330
would compile time was disabled support

00:28:22,169 --> 00:28:25,890
for an environment in the SPL which

00:28:24,330 --> 00:28:29,130
apparently is possible but takes a lot

00:28:25,890 --> 00:28:31,679
of time so I saved 250 milliseconds it's

00:28:29,130 --> 00:28:37,080
that's really the environment was huge

00:28:31,679 --> 00:28:40,919
like 128 whatever I don't remember the

00:28:37,080 --> 00:28:45,140
size but it was unnecessarily big right

00:28:40,919 --> 00:28:46,850
so in case you want you want to use the

00:28:45,140 --> 00:28:50,390
we have full details on our training

00:28:46,850 --> 00:28:52,490
labs I'm sorry but here are the most

00:28:50,390 --> 00:28:54,590
important ones so to run the Falcon mode

00:28:52,490 --> 00:28:57,740
you just need to first load the you

00:28:54,590 --> 00:28:59,510
image a new boot set the boot arts if

00:28:57,740 --> 00:29:01,270
you don't have it yet we already have it

00:28:59,510 --> 00:29:04,880
actually when you boot in normal mode

00:29:01,270 --> 00:29:08,660
then you simulate the booting the Linux

00:29:04,880 --> 00:29:11,570
kernel so it just like boot said

00:29:08,660 --> 00:29:13,700
actually boot am with you image it just

00:29:11,570 --> 00:29:16,040
close the kernel kernel headers prepares

00:29:13,700 --> 00:29:17,510
the a tags for passing that information

00:29:16,040 --> 00:29:18,710
to the kernel and boot it but it doesn't

00:29:17,510 --> 00:29:21,640
do that just be pass that information

00:29:18,710 --> 00:29:25,460
from reading the the kernel binary and

00:29:21,640 --> 00:29:27,580
writes eventually you can write that to

00:29:25,460 --> 00:29:30,679
a file that's called art on the MMC card

00:29:27,580 --> 00:29:32,000
just to store in that information so

00:29:30,679 --> 00:29:34,490
that you good doesn't have to compute it

00:29:32,000 --> 00:29:36,919
every time you boot here the size is a

00:29:34,490 --> 00:29:39,919
bit arbitrary it can be probably smaller

00:29:36,919 --> 00:29:41,929
so that's a 16 K for that information

00:29:39,919 --> 00:29:44,870
that I didn't have time to figure out

00:29:41,929 --> 00:29:47,900
exactly the exact size of it so once you

00:29:44,870 --> 00:29:51,110
have done all these four steps you just

00:29:47,900 --> 00:29:52,400
can reset and your boot will wet your

00:29:51,110 --> 00:29:55,549
body would just boot quit through the

00:29:52,400 --> 00:29:57,049
DSP L the first part of your boot and

00:29:55,549 --> 00:30:01,340
directly and straight to the Linux

00:29:57,049 --> 00:30:02,900
kernel and in case you need to get back

00:30:01,340 --> 00:30:05,660
to the previous you just take your SD

00:30:02,900 --> 00:30:07,880
card to not normally boot just take the

00:30:05,660 --> 00:30:12,559
SD card out remove the arcs file and

00:30:07,880 --> 00:30:15,669
you're good to go and that's the normal

00:30:12,559 --> 00:30:18,890
case with ttb so that's the same thing

00:30:15,669 --> 00:30:21,169
except that your instead of exporting a

00:30:18,890 --> 00:30:23,150
tags you export FTD information

00:30:21,169 --> 00:30:26,540
flattened device tree but other ways

00:30:23,150 --> 00:30:29,000
here when you reduce SPL export you have

00:30:26,540 --> 00:30:31,850
the load the the address in RAM where

00:30:29,000 --> 00:30:35,720
the the data are like this this one

00:30:31,850 --> 00:30:37,549
sorry in the size of it like the the end

00:30:35,720 --> 00:30:43,100
and the beginning so you compute the

00:30:37,549 --> 00:30:46,280
size from from from both both numbers so

00:30:43,100 --> 00:30:48,350
I the Falcon mode is nice because it

00:30:46,280 --> 00:30:50,960
saves almost 500 milliseconds of the

00:30:48,350 --> 00:30:55,309
time like not going through you boot

00:30:50,960 --> 00:30:56,990
didn't have even have to optimize it and

00:30:55,309 --> 00:30:59,450
the total boot time at the end here

00:30:56,990 --> 00:31:03,110
is now 2 to 5 milliseconds so here I

00:30:59,450 --> 00:31:05,059
have something to explain that's that's

00:31:03,110 --> 00:31:08,600
that this this time is when I'm in user

00:31:05,059 --> 00:31:12,260
space so I'm a new space after 750 and

00:31:08,600 --> 00:31:14,450
75 milliseconds roughly and now I have

00:31:12,260 --> 00:31:16,970
think think because of the fact I'm

00:31:14,450 --> 00:31:18,649
connected to a USB camera us USB is a

00:31:16,970 --> 00:31:20,840
synchronous I have to wait for the

00:31:18,649 --> 00:31:23,360
camera to be detected and in my case it

00:31:20,840 --> 00:31:26,029
takes one to two seconds I haven't

00:31:23,360 --> 00:31:27,080
managed to address that yet so it's a

00:31:26,029 --> 00:31:29,600
bit frustrating because I'm doing

00:31:27,080 --> 00:31:32,450
nothing for one or two seconds I could

00:31:29,600 --> 00:31:34,520
like display a screen and do things or

00:31:32,450 --> 00:31:36,440
just instead of using a camera I

00:31:34,520 --> 00:31:39,289
probably will switch to just displaying

00:31:36,440 --> 00:31:43,190
a video which could start immediately so

00:31:39,289 --> 00:31:46,399
now you can see after once that video is

00:31:43,190 --> 00:31:49,370
ready asked Erin ffmpeg which takes

00:31:46,399 --> 00:31:53,029
about like 500 milliseconds to to run

00:31:49,370 --> 00:31:55,130
and and start showing the first frame on

00:31:53,029 --> 00:31:58,580
the screen so I modified ffmpeg to

00:31:55,130 --> 00:32:00,080
actually write message on its log I have

00:31:58,580 --> 00:32:03,610
to decoding the first frame and actually

00:32:00,080 --> 00:32:06,140
to write a GPIO as well so that I could

00:32:03,610 --> 00:32:10,669
count the time or not we know it has

00:32:06,140 --> 00:32:13,490
connected to the to the board so I

00:32:10,669 --> 00:32:16,010
didn't manage to effectively to reduce

00:32:13,490 --> 00:32:34,159
that time for USB any ideas for making

00:32:16,010 --> 00:32:36,590
us be synchronous like in the in the

00:32:34,159 --> 00:32:41,779
driver okay cool okay

00:32:36,590 --> 00:32:43,880
like the USB cord okay thanks hey thanks

00:32:41,779 --> 00:32:48,169
didn't manage to boot yet without the

00:32:43,880 --> 00:32:50,809
TTY layer but this probably needs extra

00:32:48,169 --> 00:32:52,820
work but I expect it to save 100 is a

00:32:50,809 --> 00:32:56,630
few hundreds of milliseconds and so if

00:32:52,820 --> 00:32:58,340
very minute eliminate it is like 600

00:32:56,630 --> 00:33:03,470
milliseconds that I was found founding

00:32:58,340 --> 00:33:05,450
in in the boot tracer Plus this 1.2

00:33:03,470 --> 00:33:08,570
seconds for the USB camera to be

00:33:05,450 --> 00:33:10,970
enumerated I'm gonna be I should be

00:33:08,570 --> 00:33:16,130
below one second one second so that's

00:33:10,970 --> 00:33:19,010
quite nice yeah the time is limited I

00:33:16,130 --> 00:33:21,740
just have two minutes left so don't miss

00:33:19,010 --> 00:33:24,889
a Chris Simon Simon's presentation

00:33:21,740 --> 00:33:28,270
tomorrow on optimizations related to

00:33:24,889 --> 00:33:30,529
system D you have other presentations

00:33:28,270 --> 00:33:32,750
from past DLCs which are brilliant

00:33:30,529 --> 00:33:36,440
that's why I put the one side I love

00:33:32,750 --> 00:33:37,880
best there's also our boot time training

00:33:36,440 --> 00:33:39,110
materials and labs which are more

00:33:37,880 --> 00:33:41,360
extensive slides on the various

00:33:39,110 --> 00:33:43,549
techniques to be used and advice so

00:33:41,360 --> 00:33:46,370
that's a training course we can teach as

00:33:43,549 --> 00:33:50,539
well so questions suggestions or

00:33:46,370 --> 00:33:52,520
comments if we have time and I'd like to

00:33:50,539 --> 00:33:55,639
finish with this like a picture of the

00:33:52,520 --> 00:33:59,510
various techniques that that that I used

00:33:55,639 --> 00:34:03,370
and highlighting the most important ones

00:33:59,510 --> 00:34:06,860
as hopefully it helps you to to explore

00:34:03,370 --> 00:34:11,169
some techniques which really were worth

00:34:06,860 --> 00:34:11,169
it in our case at least any questions

00:34:11,290 --> 00:34:14,290
yes

00:34:21,960 --> 00:34:30,790
hello one of the suggestion for you if

00:34:27,250 --> 00:34:33,130
you change for size you take you image

00:34:30,790 --> 00:34:36,540
from the fat if you make it very small

00:34:33,130 --> 00:34:39,910
you can reduce a boot time or if you use

00:34:36,540 --> 00:34:42,520
raw raw partition instead of fat it

00:34:39,910 --> 00:34:44,679
would be even faster also you can remove

00:34:42,520 --> 00:34:45,160
fat support from the u-boot which is

00:34:44,679 --> 00:34:47,560
right

00:34:45,160 --> 00:34:49,419
true that's it I haven't had time to do

00:34:47,560 --> 00:34:51,460
that but it's the next one

00:34:49,419 --> 00:34:54,220
yes officially directly raw read raw

00:34:51,460 --> 00:35:04,600
data at 6 of States rather than reading

00:34:54,220 --> 00:35:08,260
going through fat thanks I have a

00:35:04,600 --> 00:35:10,390
question about another like site of this

00:35:08,260 --> 00:35:13,870
optimization how do you buck such a

00:35:10,390 --> 00:35:16,450
system without pins right it's getting

00:35:13,870 --> 00:35:20,770
worse and worse like the so to enable

00:35:16,450 --> 00:35:22,900
everything back the pocket or no well I

00:35:20,770 --> 00:35:28,570
have I really have to do things in the

00:35:22,900 --> 00:35:31,990
right order link debug first and then

00:35:28,570 --> 00:35:34,180
optimize but so analyze the performance

00:35:31,990 --> 00:35:36,670
with things like s trace and things like

00:35:34,180 --> 00:35:38,500
that do as much tracing as I need to do

00:35:36,670 --> 00:35:40,930
ahead of time or not too late at least

00:35:38,500 --> 00:35:43,770
otherwise with this approach effectively

00:35:40,930 --> 00:35:48,940
at the last agent stages I'm stuck

00:35:43,770 --> 00:35:51,250
effectively actually there one of the

00:35:48,940 --> 00:35:53,020
things I used to do was I had some

00:35:51,250 --> 00:35:55,960
macros to write directly to the serial

00:35:53,020 --> 00:35:59,440
port so and then I could use the serial

00:35:55,960 --> 00:36:02,590
timing program so or you can if you have

00:35:59,440 --> 00:36:04,420
a logic analyzer use GPIO s oh yes so

00:36:02,590 --> 00:36:06,970
it's it's not like having the full print

00:36:04,420 --> 00:36:10,980
K but just for you own just out of out

00:36:06,970 --> 00:36:10,980
of character alright take your number

00:36:12,060 --> 00:36:16,900
and by the way I was using great serial

00:36:14,350 --> 00:36:18,130
from you so thanks it's worth mentioning

00:36:16,900 --> 00:36:22,200
everything was done with bribes here

00:36:18,130 --> 00:36:22,200
you'll hear thanks

00:36:28,400 --> 00:36:33,450
my answer to this and I didn't

00:36:31,290 --> 00:36:36,060
understand me correctly but did you

00:36:33,450 --> 00:36:41,280
already did you at all including its

00:36:36,060 --> 00:36:45,720
grips in your example or did you just -

00:36:41,280 --> 00:36:47,910
in it equals yes exactly yes so in it

00:36:45,720 --> 00:36:49,290
equals my play video script that waits

00:36:47,910 --> 00:36:51,540
for the video device to be ready and

00:36:49,290 --> 00:36:54,470
then start a fast intact so just when I

00:36:51,540 --> 00:36:57,420
replace the in script by just to my own

00:36:54,470 --> 00:37:01,740
on script which is not in it anymore so

00:36:57,420 --> 00:37:05,480
if you effectively if you exit you you

00:37:01,740 --> 00:37:05,480
cannot do the kernel panic immediately

00:37:13,540 --> 00:37:18,580
have you tried by passing the script all

00:37:15,880 --> 00:37:22,780
together just pointing directly to - -

00:37:18,580 --> 00:37:24,430
if MPEG with assembling all right but I

00:37:22,780 --> 00:37:27,670
still need to pass the come on line for

00:37:24,430 --> 00:37:29,590
ffmpeg well this so I have like you

00:37:27,670 --> 00:37:31,750
script that calls ffmpeg

00:37:29,590 --> 00:37:33,810
almost right away waiting for the device

00:37:31,750 --> 00:37:37,300
with the device video device to be ready

00:37:33,810 --> 00:37:39,190
but should work yeah effectively all the

00:37:37,300 --> 00:37:40,690
map if a TV you could have you yeah all

00:37:39,190 --> 00:37:43,690
the mounting and things like that is

00:37:40,690 --> 00:37:45,490
easy to do from C code so waiting for

00:37:43,690 --> 00:37:47,070
the device file to be present mounting

00:37:45,490 --> 00:37:49,720
something if you need to mount something

00:37:47,070 --> 00:37:53,200
can be done in C code so quickly I could

00:37:49,720 --> 00:37:55,630
tweak ffmpeg to to do that directly yep

00:37:53,200 --> 00:37:58,420
true and I would save the time like

00:37:55,630 --> 00:38:00,609
executing busybox SH and things like

00:37:58,420 --> 00:38:02,910
that I would save a lot of time to some

00:38:00,609 --> 00:38:02,910
time at least

00:38:08,690 --> 00:38:16,369
allowed to disable tracing it takes a

00:38:12,580 --> 00:38:20,270
515 minutes seconds it something very

00:38:16,369 --> 00:38:23,240
big part I seen so why does the disable

00:38:20,270 --> 00:38:26,380
tracing takes so much time which one

00:38:23,240 --> 00:38:31,670
sorry disable tracing oh yeah

00:38:26,380 --> 00:38:34,160
pivot is quite surprising well it's I

00:38:31,670 --> 00:38:37,070
guess there's a lot of overhead in that

00:38:34,160 --> 00:38:38,810
case I should investigate that probably

00:38:37,070 --> 00:38:43,820
in deeper detail but that's what I

00:38:38,810 --> 00:38:45,200
observed yeah it's it's surprising that

00:38:43,820 --> 00:38:46,849
any in the kind of production they've

00:38:45,200 --> 00:38:48,109
config you have like this option that

00:38:46,849 --> 00:38:50,660
really slows down good time

00:38:48,109 --> 00:38:52,280
significantly so that's something worth

00:38:50,660 --> 00:38:54,970
investigating and maybe change the def

00:38:52,280 --> 00:38:56,690
config for that for that CPU how many

00:38:54,970 --> 00:38:59,800
unfortunately I think we're out of time

00:38:56,690 --> 00:38:59,800
yes thank you

00:39:00,340 --> 00:39:03,749

YouTube URL: https://www.youtube.com/watch?v=6sUiDJlJiYw


