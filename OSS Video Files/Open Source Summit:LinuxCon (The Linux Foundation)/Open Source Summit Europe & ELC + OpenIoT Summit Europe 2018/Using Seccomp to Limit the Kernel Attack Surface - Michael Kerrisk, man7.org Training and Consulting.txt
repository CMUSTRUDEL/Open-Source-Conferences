Title: Using Seccomp to Limit the Kernel Attack Surface - Michael Kerrisk, man7.org Training and Consulting
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Using Seccomp to Limit the Kernel Attack Surface - Michael Kerrisk, man7.org Training and Consulting

The seccomp (secure computing) facility is a means to select exactly which system calls a program is permitted to make and to restrict the arguments that may be passed to those system calls. System call filtering is achieved by writing BPF programs--programs written for a small in-kernel virtual machine that is able to examine system call numbers and arguments. Seccomp applications include sandboxing and failure-mode testing, and seccomp is by now used in a number of web browsers, container systems, and elsewhere. After outlining the basics of the BPF virtual machine, we look at some examples of filtering programs that restrict the set of permitted system calls, consider some productivity aids for seccomp writing filters, and note also some caveats to with respect to the use of seccomp. 

About Michael Kerrisk
Michael Kerrisk is the author of the acclaimed book, "The Linux Programming Interface" (http://man7.org/tlpi/), a guide and reference for system programming on Linux and UNIX. He contributes to the Linux kernel primarily via documentation, review, and testing of new kernel-user-space interfaces. He has contributed to the Linux man-pages project (http://www.kernel.org/doc/man-pages/) since 2000, and been the project maintainer since 2004. Michael is a trainer and consultant, living in Munich, Germany.
Captions: 
	00:00:00,030 --> 00:00:04,920
and I warn people that I might start a

00:00:02,850 --> 00:00:06,330
little early and so I'm gonna hold true

00:00:04,920 --> 00:00:08,639
to my word because I got a lot of things

00:00:06,330 --> 00:00:19,800
I want to say so I'll get through some

00:00:08,639 --> 00:00:21,630
of the basics already so this is sort of

00:00:19,800 --> 00:00:22,560
the third piece of presentation I'm

00:00:21,630 --> 00:00:24,119
doing here at the conference and there's

00:00:22,560 --> 00:00:26,580
a whole bunch of sort of container in

00:00:24,119 --> 00:00:28,320
isolation type topics I did see groups

00:00:26,580 --> 00:00:29,970
yes there were at least a few people I

00:00:28,320 --> 00:00:34,980
saw yesterday or here today so that's a

00:00:29,970 --> 00:00:36,000
good and I'm doing sitcom now and on

00:00:34,980 --> 00:00:38,460
Wednesday I'm going to talk about

00:00:36,000 --> 00:00:39,750
username spaces so if you want to find

00:00:38,460 --> 00:00:41,840
out a little bits and pieces that are

00:00:39,750 --> 00:00:46,170
used to build sand boxes and containers

00:00:41,840 --> 00:00:46,670
I'm gonna cover most of them excuse me a

00:00:46,170 --> 00:00:49,879
moment

00:00:46,670 --> 00:00:49,879
sorry about that

00:00:49,980 --> 00:00:56,730
so sitcom so oh just a little bit about

00:00:56,340 --> 00:00:58,199
myself

00:00:56,730 --> 00:01:01,680
I'm the maintainer of the Linux man

00:00:58,199 --> 00:01:04,949
pages project I wrote a book I do

00:01:01,680 --> 00:01:07,580
training courses okay on stuff like this

00:01:04,949 --> 00:01:11,700
just in case

00:01:07,580 --> 00:01:13,010
so sitcom what's the fundamental idea

00:01:11,700 --> 00:01:16,650
that's going on here

00:01:13,010 --> 00:01:20,159
the kernel provides I don't know four

00:01:16,650 --> 00:01:22,259
hundred or so different system calls the

00:01:20,159 --> 00:01:24,659
way most of us think about system calls

00:01:22,259 --> 00:01:27,659
is there are a way of asking the kernel

00:01:24,659 --> 00:01:30,210
to get something done the way an

00:01:27,659 --> 00:01:32,490
attacker thinks of those system calls is

00:01:30,210 --> 00:01:35,720
this is four to four hundred different

00:01:32,490 --> 00:01:38,790
ways I can try and subvert the system

00:01:35,720 --> 00:01:42,270
now there are 400 different system calls

00:01:38,790 --> 00:01:44,520
but most programs only make a small

00:01:42,270 --> 00:01:47,820
subset of those system calls it would be

00:01:44,520 --> 00:01:50,399
quite typical that many common programs

00:01:47,820 --> 00:01:53,610
in their lifetime would under make say

00:01:50,399 --> 00:01:57,600
at the most forty different system calls

00:01:53,610 --> 00:02:00,540
and the idea here is then suppose we

00:01:57,600 --> 00:02:02,909
have a program we expect to make it to

00:02:00,540 --> 00:02:05,820
make a certain set of system calls but

00:02:02,909 --> 00:02:09,239
for some reason it makes one of the

00:02:05,820 --> 00:02:11,069
other system calls now the possible

00:02:09,239 --> 00:02:13,390
reason there is the program has been

00:02:11,069 --> 00:02:16,300
subverted and tripped into

00:02:13,390 --> 00:02:17,980
executing malicious code and so if it

00:02:16,300 --> 00:02:20,800
tries to execute a system call we don't

00:02:17,980 --> 00:02:23,709
expect we want to stop it doing that

00:02:20,800 --> 00:02:26,500
because something is wrong and that's

00:02:23,709 --> 00:02:27,850
what set camp is about making sure that

00:02:26,500 --> 00:02:29,980
if a prohm tries to do things that we

00:02:27,850 --> 00:02:37,720
don't expect in terms of system calls

00:02:29,980 --> 00:02:39,280
it's prevented from doing so okay so

00:02:37,720 --> 00:02:41,470
what we're doing then effectively is

00:02:39,280 --> 00:02:44,650
reducing the attack surface of the

00:02:41,470 --> 00:02:46,720
kernel now if a program gets subvert it

00:02:44,650 --> 00:02:48,430
you know we expected the program to

00:02:46,720 --> 00:02:52,180
let's say make 40 different system calls

00:02:48,430 --> 00:02:54,780
but now with set comp it can only make

00:02:52,180 --> 00:02:56,950
those 40 different system calls which

00:02:54,780 --> 00:03:01,440
limits the possibilities for the

00:02:56,950 --> 00:03:01,440
attacker to try and subvert the system

00:03:05,670 --> 00:03:12,010
alrighty so sick clump it's actually

00:03:09,519 --> 00:03:14,890
been around for a long time it was first

00:03:12,010 --> 00:03:17,980
implemented back in 2005 but in a much

00:03:14,890 --> 00:03:19,930
more limited form the way you set up set

00:03:17,980 --> 00:03:23,920
compact then for a particular process

00:03:19,930 --> 00:03:26,440
right one to a certain profile and when

00:03:23,920 --> 00:03:29,470
you did that the process was then in

00:03:26,440 --> 00:03:32,079
strict SiC comp mode and in strict

00:03:29,470 --> 00:03:34,540
strict CENTCOM mode the process was only

00:03:32,079 --> 00:03:38,829
allowed to make for system calls read

00:03:34,540 --> 00:03:41,890
and write to iron files exit to

00:03:38,829 --> 00:03:43,030
terminate and sig returned now su return

00:03:41,890 --> 00:03:44,680
is an assistant call you'd never

00:03:43,030 --> 00:03:47,230
normally make directly from an

00:03:44,680 --> 00:03:51,250
application it's used under the covers

00:03:47,230 --> 00:03:52,450
to implement signal handlers so with the

00:03:51,250 --> 00:03:53,860
strict mode the only thing you do is

00:03:52,450 --> 00:03:59,790
read and write files that are already

00:03:53,860 --> 00:04:01,810
open or terminate or catch signals if

00:03:59,790 --> 00:04:03,730
the program tries to make any other

00:04:01,810 --> 00:04:05,019
system calls of the process tries to

00:04:03,730 --> 00:04:06,940
make another system calls then it gets

00:04:05,019 --> 00:04:09,989
killed with a signal signal and it's

00:04:06,940 --> 00:04:14,590
it's it's dead straight away of course

00:04:09,989 --> 00:04:17,500
the original idea here when this strict

00:04:14,590 --> 00:04:20,440
CENTCOM mode was implemented was to

00:04:17,500 --> 00:04:22,690
create a marketplace and CPU cycles the

00:04:20,440 --> 00:04:25,270
kernel of elihpa concerned under AR can

00:04:22,690 --> 00:04:27,430
you Lee had this idea that you know you

00:04:25,270 --> 00:04:30,280
could sell your CPU time to some

00:04:27,430 --> 00:04:32,650
else they would provide you with perhaps

00:04:30,280 --> 00:04:35,229
some bytecode or perhaps some native

00:04:32,650 --> 00:04:38,500
code that did some compute bound tasks

00:04:35,229 --> 00:04:40,720
and you could run it on your system safe

00:04:38,500 --> 00:04:42,699
in the knowledge that the only things

00:04:40,720 --> 00:04:46,000
that could do in terms of interacting

00:04:42,699 --> 00:04:48,340
with your kernel were reading on writing

00:04:46,000 --> 00:04:50,380
on file descriptors that you'd given to

00:04:48,340 --> 00:04:52,240
that program because one of the system

00:04:50,380 --> 00:04:54,370
one of the system calls that isn't

00:04:52,240 --> 00:04:56,199
allowed there is open to open a new file

00:04:54,370 --> 00:04:59,050
so you can only read and write files

00:04:56,199 --> 00:05:05,680
that have already been opened for you or

00:04:59,050 --> 00:05:10,690
terminate or catch signals so for a long

00:05:05,680 --> 00:05:12,550
time of this this the some the some CPU

00:05:10,690 --> 00:05:14,889
marketplace idea never really took off

00:05:12,550 --> 00:05:18,160
and so for a long time

00:05:14,889 --> 00:05:22,389
set compsat around etc not being much

00:05:18,160 --> 00:05:27,160
used but things changed seven years

00:05:22,389 --> 00:05:29,110
later in 2012 linux 3.5 when sic called

00:05:27,160 --> 00:05:31,810
filtering was added and this was such a

00:05:29,110 --> 00:05:34,389
big change to how sitcom work that

00:05:31,810 --> 00:05:38,050
sometimes this is called set comp 2 and

00:05:34,389 --> 00:05:40,570
the key point here now is you can load a

00:05:38,050 --> 00:05:43,960
filter program into the kernel and you

00:05:40,570 --> 00:05:46,000
can choose which system calls are going

00:05:43,960 --> 00:05:48,159
to be allowed and disallowed so you no

00:05:46,000 --> 00:05:49,599
longer have just the strict mode where

00:05:48,159 --> 00:05:51,699
there's only a certain full set of

00:05:49,599 --> 00:05:53,320
system calls allowed you can say well

00:05:51,699 --> 00:05:55,389
actually this is the set of system calls

00:05:53,320 --> 00:05:57,310
I'm going to allow and everything else

00:05:55,389 --> 00:05:59,050
is disallowed or perhaps you can just

00:05:57,310 --> 00:06:03,460
say all and disallow certain system

00:05:59,050 --> 00:06:06,009
calls and allow everything else okay the

00:06:03,460 --> 00:06:07,710
way you did this for you used PR CTL

00:06:06,009 --> 00:06:10,300
which is one of these sort of horrible

00:06:07,710 --> 00:06:12,220
multiplexing system calls it does dozens

00:06:10,300 --> 00:06:15,430
of different things to a process and one

00:06:12,220 --> 00:06:19,180
of the things you can do is set a sick

00:06:15,430 --> 00:06:20,680
comp filter for the process so now you

00:06:19,180 --> 00:06:23,470
can choose which system calls are going

00:06:20,680 --> 00:06:26,139
to be allowed and disallowed now people

00:06:23,470 --> 00:06:29,440
wanted this sort of feature for a very

00:06:26,139 --> 00:06:31,330
long time before sitcom two was invented

00:06:29,440 --> 00:06:35,500
people have been wanting this ability to

00:06:31,330 --> 00:06:37,419
filter system calls in some way for many

00:06:35,500 --> 00:06:39,669
years and they've been various mechanism

00:06:37,419 --> 00:06:41,530
proposed over the years but they all

00:06:39,669 --> 00:06:43,360
were rejected by Colonel Val

00:06:41,530 --> 00:06:45,850
because they were perhaps over

00:06:43,360 --> 00:06:49,120
complicated or difficult to maintain or

00:06:45,850 --> 00:06:51,610
somehow unsuitable for being merged into

00:06:49,120 --> 00:06:53,800
the mainline kernel and when this speech

00:06:51,610 --> 00:06:56,890
you did finding it used a deaf I trying

00:06:53,800 --> 00:06:59,380
to get merged then people started using

00:06:56,890 --> 00:07:02,530
it pretty quickly and by now it's being

00:06:59,380 --> 00:07:04,930
used in a lot of tools and this is just

00:07:02,530 --> 00:07:07,090
a few examples so for example the web

00:07:04,930 --> 00:07:09,730
browsers are using it the container

00:07:07,090 --> 00:07:13,030
frameworks are using it tools like fire

00:07:09,730 --> 00:07:15,610
pack and fire jail flat pack and fire

00:07:13,030 --> 00:07:19,960
jailer using it system DS using

00:07:15,610 --> 00:07:23,100
assistant he uses everything which is a

00:07:19,960 --> 00:07:26,350
good thing okay

00:07:23,100 --> 00:07:28,950
the work on set comp is still ongoing

00:07:26,350 --> 00:07:30,910
there's even new stuff getting

00:07:28,950 --> 00:07:33,880
interesting new stuff getting added

00:07:30,910 --> 00:07:37,060
right at the moment but especially back

00:07:33,880 --> 00:07:39,540
in sorry I've jumped ahead a little bit

00:07:37,060 --> 00:07:43,120
I've so I've jumped ahead a little bit

00:07:39,540 --> 00:07:45,760
the next three seventeen then there was

00:07:43,120 --> 00:07:48,160
a new system called added call set comp

00:07:45,760 --> 00:07:51,220
and this is the sort of more modern way

00:07:48,160 --> 00:07:53,919
of establishing a set comp filter and it

00:07:51,220 --> 00:07:58,840
provides more options than the PR CTL

00:07:53,919 --> 00:08:00,010
system call and as I said there's more

00:07:58,840 --> 00:08:02,020
work ongoing so there was a lot of

00:08:00,010 --> 00:08:03,160
features that are added in kernel 4:14

00:08:02,020 --> 00:08:04,390
there's a whole lot of other features

00:08:03,160 --> 00:08:06,400
that are being worked on at the moment

00:08:04,390 --> 00:08:08,800
that are likely to land and the next

00:08:06,400 --> 00:08:10,990
kernel release or not the next Colonel

00:08:08,800 --> 00:08:17,070
Reese but the next one or two releases

00:08:10,990 --> 00:08:19,780
after that I would estimate okay so

00:08:17,070 --> 00:08:22,330
what's going on here the fundamental

00:08:19,780 --> 00:08:24,040
idea is we can write filter programs

00:08:22,330 --> 00:08:25,750
that make decisions about system calls

00:08:24,040 --> 00:08:27,910
and those systems that those filter

00:08:25,750 --> 00:08:30,750
programs can make decisions based on the

00:08:27,910 --> 00:08:33,520
system call number and the system call

00:08:30,750 --> 00:08:37,990
arguments and when I say arguments I

00:08:33,520 --> 00:08:39,310
mean the register values so the filter

00:08:37,990 --> 00:08:41,500
program can say oh I like the system

00:08:39,310 --> 00:08:44,430
called the system call number and I like

00:08:41,500 --> 00:08:46,600
the values in these registers or I don't

00:08:44,430 --> 00:08:48,550
what I'm trying to get across there is

00:08:46,600 --> 00:08:50,260
the filter program can look at the

00:08:48,550 --> 00:08:52,089
registers that contain the arguments

00:08:50,260 --> 00:08:54,680
some of those arguments might be

00:08:52,089 --> 00:08:58,220
pointers the filter pro

00:08:54,680 --> 00:08:59,269
can't dereference the pointers obviously

00:08:58,220 --> 00:09:00,680
that would be an interesting thing to do

00:08:59,269 --> 00:09:02,959
especially if the pointer pointed to

00:09:00,680 --> 00:09:04,790
let's say a path name but the filter

00:09:02,959 --> 00:09:06,559
programs can't do that sort of thing at

00:09:04,790 --> 00:09:08,240
the moment there is someone who's

00:09:06,559 --> 00:09:10,119
working on adding that sort of

00:09:08,240 --> 00:09:12,050
functionality there's a new Alice M that

00:09:10,119 --> 00:09:13,939
someone I know has been working on for

00:09:12,050 --> 00:09:16,040
two or three is called land lock which

00:09:13,939 --> 00:09:18,410
is intended among other things to bring

00:09:16,040 --> 00:09:23,480
that sort of functionality to second but

00:09:18,410 --> 00:09:26,149
it doesn't exist at this time so in

00:09:23,480 --> 00:09:27,649
order to use set comp we in a user space

00:09:26,149 --> 00:09:30,170
program in your field through a few

00:09:27,649 --> 00:09:33,139
steps the user space program builds a

00:09:30,170 --> 00:09:35,089
filter program like admin a kind of

00:09:33,139 --> 00:09:38,509
binary blob which is interpreted by a

00:09:35,089 --> 00:09:40,819
virtual machine it installs that filter

00:09:38,509 --> 00:09:43,069
program into the kernel the kernel has

00:09:40,819 --> 00:09:46,339
this virtual machine implementation and

00:09:43,069 --> 00:09:49,100
then the program executes SunTrust to

00:09:46,339 --> 00:09:50,929
the code in other words some some

00:09:49,100 --> 00:09:53,149
arbitrary third-party code that we don't

00:09:50,929 --> 00:09:56,389
necessarily trust or perhaps some code

00:09:53,149 --> 00:09:57,529
that we feel could be compromised and of

00:09:56,389 --> 00:09:58,160
course the way that code is going to be

00:09:57,529 --> 00:10:01,040
executed

00:09:58,160 --> 00:10:02,779
either we exact a new program or perhaps

00:10:01,040 --> 00:10:04,220
we've dynamically loaded a shared

00:10:02,779 --> 00:10:06,079
library in other words a plugin and

00:10:04,220 --> 00:10:09,079
we're gonna execute functions from that

00:10:06,079 --> 00:10:12,350
plugin and now from this point onwards

00:10:09,079 --> 00:10:12,949
from the point where this the filter is

00:10:12,350 --> 00:10:16,429
installed

00:10:12,949 --> 00:10:21,829
every system call gets checked to see is

00:10:16,429 --> 00:10:24,379
it a permitted system call or not okay

00:10:21,829 --> 00:10:25,790
once you've installed that filter for

00:10:24,379 --> 00:10:28,519
the process or once the process is

00:10:25,790 --> 00:10:30,559
installed that filter for itself the

00:10:28,519 --> 00:10:33,170
filter can't be removed

00:10:30,559 --> 00:10:34,790
let's make sense a filter is a kind of

00:10:33,170 --> 00:10:37,699
declaration we're about to execute some

00:10:34,790 --> 00:10:39,079
code that we don't necessarily trust we

00:10:37,699 --> 00:10:41,269
don't want that code to be able to

00:10:39,079 --> 00:10:42,949
remove the filter so once it filters

00:10:41,269 --> 00:10:48,439
through establish for a process its

00:10:42,949 --> 00:10:54,519
permanent okay so these set comp

00:10:48,439 --> 00:10:58,160
programs are expressed using the the BPF

00:10:54,519 --> 00:11:00,589
BPF language berkeley packet filter now

00:10:58,160 --> 00:11:02,420
it's it's quite possible that many of

00:11:00,589 --> 00:11:05,389
you have heard of BPF already of course

00:11:02,420 --> 00:11:06,769
because it's used with tcp dump and tcp

00:11:05,389 --> 00:11:08,030
dump has been around for a right I know

00:11:06,769 --> 00:11:12,530
25 more than 20

00:11:08,030 --> 00:11:16,070
five years now and the way that BPF is

00:11:12,530 --> 00:11:17,960
used with TCP dump TCP dump of course

00:11:16,070 --> 00:11:19,640
it's monitoring network traffic and a

00:11:17,960 --> 00:11:22,090
notable characteristic of network

00:11:19,640 --> 00:11:24,380
traffic is there's a lot of it and

00:11:22,090 --> 00:11:26,720
mostly you're interested in a small

00:11:24,380 --> 00:11:27,950
piece of the conversations going between

00:11:26,720 --> 00:11:30,710
two endpoints you don't want to see

00:11:27,950 --> 00:11:34,550
everything else that is getting sent

00:11:30,710 --> 00:11:37,190
across than the network link so what you

00:11:34,550 --> 00:11:39,680
want TCP dump to do for you is to filter

00:11:37,190 --> 00:11:42,080
the information so the only C selected

00:11:39,680 --> 00:11:44,510
Network packets and that's that's that's

00:11:42,080 --> 00:11:47,600
what TCP dump does now that filtering

00:11:44,510 --> 00:11:49,730
could happen theoretically in user space

00:11:47,600 --> 00:11:52,280
in other words the TCP dump could put

00:11:49,730 --> 00:11:55,250
the network device into promiscuous mode

00:11:52,280 --> 00:11:58,520
get every packet into user space and

00:11:55,250 --> 00:12:01,460
spec the packet that's possible the

00:11:58,520 --> 00:12:03,590
problem with doing that approach is the

00:12:01,460 --> 00:12:05,420
sheer volume of data that needs to be

00:12:03,590 --> 00:12:07,820
transferred across the kernel user space

00:12:05,420 --> 00:12:10,310
boundary would put a big load on the

00:12:07,820 --> 00:12:12,260
system so just transferring that data is

00:12:10,310 --> 00:12:16,640
expensive because there's so much of it

00:12:12,260 --> 00:12:18,980
so the idea with BPF and TCP dump is the

00:12:16,640 --> 00:12:21,080
with TCP dump you can install a BPF

00:12:18,980 --> 00:12:23,270
program in the kernel and that BPF

00:12:21,080 --> 00:12:25,460
program does a check on the network

00:12:23,270 --> 00:12:27,410
packet header and decides is this an

00:12:25,460 --> 00:12:29,540
interesting packet or not and if it's

00:12:27,410 --> 00:12:31,610
interesting then the packet gets

00:12:29,540 --> 00:12:34,790
transferred across the kernel user space

00:12:31,610 --> 00:12:36,770
boundary and the brilliance of set comp

00:12:34,790 --> 00:12:39,140
was to realize this virtual machine that

00:12:36,770 --> 00:12:40,790
is being used for inspecting Network

00:12:39,140 --> 00:12:43,190
packet headers which of course are just

00:12:40,790 --> 00:12:45,890
a bunch of bytes this could be

00:12:43,190 --> 00:12:48,200
generalized to inspecting system call

00:12:45,890 --> 00:12:53,290
numbers and their arguments which are

00:12:48,200 --> 00:12:56,180
just a bunch of bytes and so that's why

00:12:53,290 --> 00:12:58,010
when that idea of sent comp was proposed

00:12:56,180 --> 00:12:59,030
to go from the point where is initially

00:12:58,010 --> 00:13:00,710
proposed to the point was actually

00:12:59,030 --> 00:13:04,480
merchants of the kernel I only took

00:13:00,710 --> 00:13:09,530
about a year which is pretty good for a

00:13:04,480 --> 00:13:10,610
a major kernel change okay but part of

00:13:09,530 --> 00:13:13,070
the thing that assisted there was

00:13:10,610 --> 00:13:20,840
reusing this initial this existing

00:13:13,070 --> 00:13:22,019
technology okay so BPF defines a virtual

00:13:20,840 --> 00:13:23,459
machine it's a virtual

00:13:22,019 --> 00:13:24,689
is interpreted by the kernel this

00:13:23,459 --> 00:13:26,670
virtual machine has a few

00:13:24,689 --> 00:13:29,100
characteristics it's got a very simple

00:13:26,670 --> 00:13:30,629
instruction set small set of

00:13:29,100 --> 00:13:32,759
instructions all the instructions are

00:13:30,629 --> 00:13:36,300
the same size this means the kernel can

00:13:32,759 --> 00:13:40,019
implement the virtual machine easily and

00:13:36,300 --> 00:13:42,449
in a way that is efficient fast the

00:13:40,019 --> 00:13:47,939
kernel can also do things like verifying

00:13:42,449 --> 00:13:50,579
that programs are valid and safe okay so

00:13:47,939 --> 00:13:52,889
one of the things about BPF programs

00:13:50,579 --> 00:13:55,589
there are jump instructions but you can

00:13:52,889 --> 00:13:57,929
only jump forward in a program so

00:13:55,589 --> 00:14:00,209
programs are directed acyclic graphs

00:13:57,929 --> 00:14:03,239
that means the colonel knows that every

00:14:00,209 --> 00:14:04,920
BPF program will complete because of

00:14:03,239 --> 00:14:06,619
course i forget him a BPF program inside

00:14:04,920 --> 00:14:09,029
the kernel was executing that could loop

00:14:06,619 --> 00:14:10,769
then you could have conducted a denial

00:14:09,029 --> 00:14:12,540
of service attack against the kernel

00:14:10,769 --> 00:14:16,739
well that's not possible because you can

00:14:12,540 --> 00:14:17,879
only go forward in a program there's

00:14:16,739 --> 00:14:19,350
simple at the instruction sets very

00:14:17,879 --> 00:14:21,569
simple this means the kernel can verify

00:14:19,350 --> 00:14:23,610
the opcodes are valid and the arguments

00:14:21,569 --> 00:14:26,309
are valid the kernel can even do things

00:14:23,610 --> 00:14:28,439
like detecting beard code where the some

00:14:26,309 --> 00:14:31,319
piece of code and the BPF program where

00:14:28,439 --> 00:14:33,449
there's a jump over the code but no jump

00:14:31,319 --> 00:14:35,910
into the code so that code could never

00:14:33,449 --> 00:14:38,069
be executed if you try and load a BPF

00:14:35,910 --> 00:14:40,290
filter program into the kernel like that

00:14:38,069 --> 00:14:44,939
the kernel rejects it because it's got

00:14:40,290 --> 00:14:47,939
dead code the kernel can also verify

00:14:44,939 --> 00:14:49,920
that every BPF program completes with a

00:14:47,939 --> 00:14:52,889
return instruction the return

00:14:49,920 --> 00:14:54,360
instruction is basically an information

00:14:52,889 --> 00:14:59,899
from the BPF program to the kernel

00:14:54,360 --> 00:14:59,899
saying do we like the system call or not

00:15:00,470 --> 00:15:04,919
BPF programs the limiter than sighs they

00:15:02,850 --> 00:15:06,299
came back to full k of instructions

00:15:04,919 --> 00:15:10,169
which seems to be enough for most

00:15:06,299 --> 00:15:12,480
people's needs so let's look at this

00:15:10,169 --> 00:15:14,970
virtual machine a bit more closely it's

00:15:12,480 --> 00:15:17,939
um it's got an accumulator register it's

00:15:14,970 --> 00:15:19,559
a 32-bit register there's a data area

00:15:17,939 --> 00:15:21,649
this is the information the program can

00:15:19,559 --> 00:15:24,419
operate on the starter area is

00:15:21,649 --> 00:15:27,389
information about the system call for

00:15:24,419 --> 00:15:32,399
example the system call number and the

00:15:27,389 --> 00:15:34,769
register values the argument values the

00:15:32,399 --> 00:15:35,710
instructions are 64 bits in size and

00:15:34,769 --> 00:15:37,360
expressed

00:15:35,710 --> 00:15:42,720
a see structure and the see structure is

00:15:37,360 --> 00:15:45,220
defined in the mundane head of files the

00:15:42,720 --> 00:15:48,280
64 bit instruction looks like this it

00:15:45,220 --> 00:15:51,220
begins with a 16 bit opcode at the end

00:15:48,280 --> 00:15:53,770
there's a 32 bit operand that the opcode

00:15:51,220 --> 00:15:55,780
uses and for some instructions there are

00:15:53,770 --> 00:15:58,570
two other byte fields that are used and

00:15:55,780 --> 00:16:02,080
these used for conditional jump

00:15:58,570 --> 00:16:04,660
instructions where these are instruction

00:16:02,080 --> 00:16:06,820
offset saying how far should we jump and

00:16:04,660 --> 00:16:09,760
conditional jump instructions BPF is a

00:16:06,820 --> 00:16:11,200
little bit unusual there's two targets

00:16:09,760 --> 00:16:13,810
for every jump there's a jump false

00:16:11,200 --> 00:16:16,120
target and a jump true target so you can

00:16:13,810 --> 00:16:18,130
jump in either of two directions or

00:16:16,120 --> 00:16:22,390
either of two distances I should say

00:16:18,130 --> 00:16:29,710
depending on whether the the conditional

00:16:22,390 --> 00:16:31,750
test is true or false it's a it's a kind

00:16:29,710 --> 00:16:34,390
of pseudo assembler like language it's a

00:16:31,750 --> 00:16:36,700
virtual machine so it's a sign of a

00:16:34,390 --> 00:16:39,220
basic kind of assembler type language

00:16:36,700 --> 00:16:41,950
we've got load instructions

00:16:39,220 --> 00:16:43,330
we've got store instructions one of

00:16:41,950 --> 00:16:44,770
these you can do with BPH programs as

00:16:43,330 --> 00:16:46,570
well as the data area that you can

00:16:44,770 --> 00:16:48,370
operate on there's some working memory

00:16:46,570 --> 00:16:51,070
that you can use to store information

00:16:48,370 --> 00:16:53,380
that you've calculated and you want to

00:16:51,070 --> 00:16:56,230
save temporarily

00:16:53,380 --> 00:16:58,330
there's jump instructions there's the

00:16:56,230 --> 00:17:00,070
usual kinds of arithmetic and logic

00:16:58,330 --> 00:17:04,000
instructions you know add multiply left

00:17:00,070 --> 00:17:05,800
shift and XOR and so on and there's

00:17:04,000 --> 00:17:12,310
these return instructions which say to

00:17:05,800 --> 00:17:14,950
the kernel do we like this system call

00:17:12,310 --> 00:17:19,330
or not should the system call be allowed

00:17:14,950 --> 00:17:20,650
to be executed okay so we've got these

00:17:19,330 --> 00:17:21,730
conditional jump instructions we're

00:17:20,650 --> 00:17:24,640
going to go we've got conditional and

00:17:21,730 --> 00:17:26,680
unconditional jump instructions the

00:17:24,640 --> 00:17:29,110
conditional jump instructions consists

00:17:26,680 --> 00:17:31,350
of the usual pieces an opcode saying

00:17:29,110 --> 00:17:33,550
what kind of conditionally testing a

00:17:31,350 --> 00:17:36,340
value that we're going to test against

00:17:33,550 --> 00:17:39,850
in the operand and then a jump false

00:17:36,340 --> 00:17:41,050
offset and a jump true offset and in

00:17:39,850 --> 00:17:43,000
terms of the conditional jump

00:17:41,050 --> 00:17:45,700
instructions we've got the sort of usual

00:17:43,000 --> 00:17:48,400
things you might expect an equality test

00:17:45,700 --> 00:17:49,610
a greater than test a greater than or

00:17:48,400 --> 00:17:52,160
equal test

00:17:49,610 --> 00:17:54,260
a bit set yes that's what the J set is

00:17:52,160 --> 00:17:56,720
and if you look at that list and that's

00:17:54,260 --> 00:17:57,740
the complete list by the way you might

00:17:56,720 --> 00:17:59,360
say well there seem to be some things

00:17:57,740 --> 00:18:02,240
that are missing there where's the jump

00:17:59,360 --> 00:18:05,240
not equal or the jump less than or equal

00:18:02,240 --> 00:18:07,790
and so on well those other alternatives

00:18:05,240 --> 00:18:10,309
are just the false branches of the

00:18:07,790 --> 00:18:15,010
existing instructions so the false

00:18:10,309 --> 00:18:17,929
branch from jump equal is jump not equal

00:18:15,010 --> 00:18:20,630
okay and the targets for these jumps are

00:18:17,929 --> 00:18:22,340
expressed as relative offsets certain

00:18:20,630 --> 00:18:23,929
number of instructions to jump zero

00:18:22,340 --> 00:18:25,790
means don't do a jump at all in other

00:18:23,929 --> 00:18:28,970
words execute the very next instruction

00:18:25,790 --> 00:18:31,610
otherwise you can jump up to 255

00:18:28,970 --> 00:18:34,059
instructions forward now if you want to

00:18:31,610 --> 00:18:36,350
jump further than that there's another

00:18:34,059 --> 00:18:39,200
unconditional jump instruction jump

00:18:36,350 --> 00:18:41,240
always and there the offset is expressed

00:18:39,200 --> 00:18:44,059
in the operand which is 16 bits which is

00:18:41,240 --> 00:18:46,580
way more than you need to cover the 4k

00:18:44,059 --> 00:18:51,970
of available instructions in the that

00:18:46,580 --> 00:18:54,500
are possible in a BPF program okay so

00:18:51,970 --> 00:18:57,080
what the kernel does for this BPF

00:18:54,500 --> 00:18:59,630
program for every system halt the BPF

00:18:57,080 --> 00:19:01,610
program gets ten it get executed test is

00:18:59,630 --> 00:19:03,620
the system call and allowed system call

00:19:01,610 --> 00:19:06,820
or not and the kernel provides a

00:19:03,620 --> 00:19:12,890
read-only buffer of data that describes

00:19:06,820 --> 00:19:14,950
the system call we can exceed there's a

00:19:12,890 --> 00:19:18,410
heater file here that shows us what that

00:19:14,950 --> 00:19:20,030
that that data area looks like this is

00:19:18,410 --> 00:19:23,330
the data that's being provided by the

00:19:20,030 --> 00:19:26,929
kernel to the BPF program and we've got

00:19:23,330 --> 00:19:28,760
a various piece of information here for

00:19:26,929 --> 00:19:30,980
example the first thing we've got the

00:19:28,760 --> 00:19:33,620
system call number which system call be

00:19:30,980 --> 00:19:37,429
executing now down the end here we've

00:19:33,620 --> 00:19:39,049
got a number of arguments on Linux the

00:19:37,429 --> 00:19:41,960
maximum number of arguments that the

00:19:39,049 --> 00:19:44,330
system call can have is 6 so this space

00:19:41,960 --> 00:19:46,460
and that data to allow for up to 6

00:19:44,330 --> 00:19:48,080
arguments now obviously the number of

00:19:46,460 --> 00:19:49,640
arguments that's actually used depends

00:19:48,080 --> 00:19:53,270
on the system for some system calls use

00:19:49,640 --> 00:19:54,679
no arguments but of course you know that

00:19:53,270 --> 00:19:56,600
when you write your filter program and

00:19:54,679 --> 00:20:00,410
you write your filter program to access

00:19:56,600 --> 00:20:02,570
the right number of arguments now

00:20:00,410 --> 00:20:04,090
there's a couple of other fields in

00:20:02,570 --> 00:20:07,930
there as well

00:20:04,090 --> 00:20:10,810
an architecture field this tells us what

00:20:07,930 --> 00:20:13,990
our picture are we currently XQ titles

00:20:10,810 --> 00:20:16,120
at arms and x86 is it MIPS or whatever

00:20:13,990 --> 00:20:20,590
I'll come back to saying why that's

00:20:16,120 --> 00:20:22,840
important soon and then one hour fuel in

00:20:20,590 --> 00:20:24,940
there the instruction pointer now this

00:20:22,840 --> 00:20:27,670
is telling us from where in the

00:20:24,940 --> 00:20:32,140
processes of virtual address space was

00:20:27,670 --> 00:20:34,870
this system call mage ok so this is the

00:20:32,140 --> 00:20:36,790
real virtual dress in your in the actual

00:20:34,870 --> 00:20:39,370
process itself that where the system

00:20:36,790 --> 00:20:40,660
call was made and when I first came

00:20:39,370 --> 00:20:42,970
across that I thought what's the use

00:20:40,660 --> 00:20:44,740
case why why would you want to use that

00:20:42,970 --> 00:20:46,420
information and I invented fantastical

00:20:44,740 --> 00:20:48,100
use cases like a good divisor filter

00:20:46,420 --> 00:20:51,400
program where if the filter if the

00:20:48,100 --> 00:20:53,110
system call was made from a certain

00:20:51,400 --> 00:20:55,240
shared library in a certain range of the

00:20:53,110 --> 00:20:57,610
address space then we want to stop the

00:20:55,240 --> 00:20:59,320
system call being made and I finally got

00:20:57,610 --> 00:21:01,840
to talk to the set comp developers about

00:20:59,320 --> 00:21:11,020
why it exists why that field exists the

00:21:01,840 --> 00:21:13,450
answer was because we could okay now you

00:21:11,020 --> 00:21:17,590
could you know if you are feeling very

00:21:13,450 --> 00:21:21,820
1950s or 1940s code up your BPF programs

00:21:17,590 --> 00:21:23,560
in binary by hand there are certain

00:21:21,820 --> 00:21:26,050
productivity tools that make the job

00:21:23,560 --> 00:21:28,690
easier at the very least there are some

00:21:26,050 --> 00:21:30,910
macros to find in header files that make

00:21:28,690 --> 00:21:32,470
your life easier if you're gonna do this

00:21:30,910 --> 00:21:33,910
by hand there are some other better

00:21:32,470 --> 00:21:37,300
productivity tools that I'll mention

00:21:33,910 --> 00:21:39,460
briefly later on as well so there's some

00:21:37,300 --> 00:21:42,730
macro is then for example in the header

00:21:39,460 --> 00:21:46,000
files that are used to construct BPF

00:21:42,730 --> 00:21:48,640
statements and BPF jump statements now

00:21:46,000 --> 00:21:51,010
all these macros are doing is taking

00:21:48,640 --> 00:21:52,990
values together taking values and use

00:21:51,010 --> 00:21:55,420
them to build and initializer for that

00:21:52,990 --> 00:21:58,510
64 bit structure that contains an opcode

00:21:55,420 --> 00:22:01,600
I jumped true a jump false and an

00:21:58,510 --> 00:22:04,300
argument so BPF statement just takes an

00:22:01,600 --> 00:22:06,000
opcode and an argument the the I can I

00:22:04,300 --> 00:22:07,960
don't know for some reason it's called K

00:22:06,000 --> 00:22:11,050
some history there I don't know the

00:22:07,960 --> 00:22:13,990
details and it takes those two values

00:22:11,050 --> 00:22:14,560
builds the 64 bit initializer the true

00:22:13,990 --> 00:22:16,419
and the false

00:22:14,560 --> 00:22:18,970
r0 because this isn't a jump

00:22:16,419 --> 00:22:21,129
direction and there's another macro BPF

00:22:18,970 --> 00:22:23,799
jump where you give it an opcode an

00:22:21,129 --> 00:22:26,679
operand and a jump true and jump false

00:22:23,799 --> 00:22:32,039
argument and again it constructs a

00:22:26,679 --> 00:22:35,350
64-bit initializer so here's an example

00:22:32,039 --> 00:22:37,869
what this instruction does it's a load

00:22:35,350 --> 00:22:40,899
instruction that's what the BP FLD tells

00:22:37,869 --> 00:22:44,379
us now the first argument is constructed

00:22:40,899 --> 00:22:46,359
by pouring together various bit fields

00:22:44,379 --> 00:22:49,090
okay these bit fields these these are

00:22:46,359 --> 00:22:52,690
the needs values here are just bit masks

00:22:49,090 --> 00:22:54,999
that are defined in header files what

00:22:52,690 --> 00:22:57,909
this these the the first segment here is

00:22:54,999 --> 00:23:00,369
being defined using three bit fields odd

00:22:57,909 --> 00:23:03,190
together it's a load instruction then

00:23:00,369 --> 00:23:06,009
the LD of the BP FW says what is the

00:23:03,190 --> 00:23:08,049
size that we're loading it's a word in

00:23:06,009 --> 00:23:10,869
other words 32 bits and then the last

00:23:08,049 --> 00:23:14,200
part BPF abs says where is where are we

00:23:10,869 --> 00:23:16,659
doing the load from and yet the ABS here

00:23:14,200 --> 00:23:18,700
means load from the data in other words

00:23:16,659 --> 00:23:23,230
the area that describes the system call

00:23:18,700 --> 00:23:26,259
so we're loading a four byte word into

00:23:23,230 --> 00:23:28,509
the accumulator in preparation for doing

00:23:26,259 --> 00:23:32,799
something now then the question is well

00:23:28,509 --> 00:23:35,649
which word are we loading well we're

00:23:32,799 --> 00:23:36,309
loading the word at offset of structs at

00:23:35,649 --> 00:23:38,980
comdata

00:23:36,309 --> 00:23:43,299
arch now who's come across the offset of

00:23:38,980 --> 00:23:45,789
macro before usually I find relatively

00:23:43,299 --> 00:23:49,149
few people have done have seen this what

00:23:45,789 --> 00:23:51,249
this it's a handy little macro you give

00:23:49,149 --> 00:23:53,080
it a structured arrow the name of the

00:23:51,249 --> 00:23:54,609
structure and the name of a feel inside

00:23:53,080 --> 00:23:57,519
that structure and it gives you back the

00:23:54,609 --> 00:23:59,590
byte offset of that field so going back

00:23:57,519 --> 00:24:03,909
to that structure definition yeah we

00:23:59,590 --> 00:24:07,359
said sorry sitcom structure sitcom data

00:24:03,909 --> 00:24:08,429
comma arch give me off off offset of the

00:24:07,359 --> 00:24:12,220
archfield

00:24:08,429 --> 00:24:16,049
what's gonna tell me what's the return

00:24:12,220 --> 00:24:21,100
value from offset off it's gonna be four

00:24:16,049 --> 00:24:23,529
yeah four byte integer yeah so what

00:24:21,100 --> 00:24:27,989
we're saying there is load the

00:24:23,529 --> 00:24:27,989
architecture field into the accumulator

00:24:29,470 --> 00:24:34,790
all righty another example this is a

00:24:32,890 --> 00:24:38,780
conditional jump instruction we're

00:24:34,790 --> 00:24:40,820
saying do a jump the kind of jump we're

00:24:38,780 --> 00:24:42,500
doing it's in a quality test it's a

00:24:40,820 --> 00:24:45,530
conditional jump it's an equality as' is

00:24:42,500 --> 00:24:47,090
the value in the accumulator equal to

00:24:45,530 --> 00:24:49,429
something and then the question is what

00:24:47,090 --> 00:24:51,410
something well the BPF cases there's

00:24:49,429 --> 00:24:53,570
something that's in the operand of this

00:24:51,410 --> 00:24:55,790
instruction and what's in the operand of

00:24:53,570 --> 00:24:56,210
this instruction it's the value ordered

00:24:55,790 --> 00:25:02,179
arche

00:24:56,210 --> 00:25:03,740
x86 64 now this is just a magic value in

00:25:02,179 --> 00:25:06,650
one of the kernel header files that

00:25:03,740 --> 00:25:10,460
corresponds to the the architecture x86

00:25:06,650 --> 00:25:13,549
64 every architecture has a unique value

00:25:10,460 --> 00:25:16,700
for the for the architecture type as

00:25:13,549 --> 00:25:19,970
seen by things like the audit subsystem

00:25:16,700 --> 00:25:21,919
and sitcom now if the value in the

00:25:19,970 --> 00:25:23,450
accumulator is equal to this particular

00:25:21,919 --> 00:25:25,520
value here then we're going to jump

00:25:23,450 --> 00:25:27,080
forward one instruction in other words

00:25:25,520 --> 00:25:29,780
skip the very next instruction and the

00:25:27,080 --> 00:25:32,059
BPF program otherwise we're going to

00:25:29,780 --> 00:25:36,520
jump forward zero instructions in other

00:25:32,059 --> 00:25:36,520
words execute the very next instruction

00:25:36,640 --> 00:25:44,179
okay another example a a return

00:25:41,870 --> 00:25:46,010
statement this is information that the

00:25:44,179 --> 00:25:47,720
SEP program is giving back to the kernel

00:25:46,010 --> 00:25:49,940
it's saying where we're terminating a

00:25:47,720 --> 00:25:52,040
terminating execution of the BPF program

00:25:49,940 --> 00:25:54,020
now and we're gonna tell the colonel

00:25:52,040 --> 00:25:56,929
what do we think about this system call

00:25:54,020 --> 00:25:59,929
Sobe PF return terminate execution the

00:25:56,929 --> 00:26:02,179
program passing back the value in the

00:25:59,929 --> 00:26:04,160
operand that's what the BPF case is and

00:26:02,179 --> 00:26:07,669
the value in the operand says ret kill

00:26:04,160 --> 00:26:10,850
process we don't like this system call

00:26:07,669 --> 00:26:20,380
we don't like it so much that the kernel

00:26:10,850 --> 00:26:23,210
should kill the process okay so I

00:26:20,380 --> 00:26:26,059
mentioned this architecture field that

00:26:23,210 --> 00:26:27,470
appears in the data area and I just want

00:26:26,059 --> 00:26:31,820
to add a little bit more about that and

00:26:27,470 --> 00:26:34,370
the point is that every BPF program will

00:26:31,820 --> 00:26:36,470
look at a complete program soon every

00:26:34,370 --> 00:26:39,440
BPF program should check the

00:26:36,470 --> 00:26:41,659
architecture of the the on which it's

00:26:39,440 --> 00:26:42,620
running now there's a few different

00:26:41,659 --> 00:26:45,230
reasons for this

00:26:42,620 --> 00:26:47,269
the first thing to realize is system

00:26:45,230 --> 00:26:49,580
call numbers are different on different

00:26:47,269 --> 00:26:51,110
our cages the system call numbers on arm

00:26:49,580 --> 00:26:54,200
are different from system call numbers

00:26:51,110 --> 00:26:55,789
on x86 on x86 even system call numbers

00:26:54,200 --> 00:27:00,580
on x86 32 are different from these

00:26:55,789 --> 00:27:04,850
typical numbers on x86 64 and so on so

00:27:00,580 --> 00:27:07,580
we are building a BPF program that

00:27:04,850 --> 00:27:09,350
checks system call numbers and those

00:27:07,580 --> 00:27:11,749
system call numbers depend on the

00:27:09,350 --> 00:27:14,149
architecture so we better make sure

00:27:11,749 --> 00:27:15,740
we're executing on the architecture we

00:27:14,149 --> 00:27:18,259
really thought we were executing on

00:27:15,740 --> 00:27:20,509
because if we're not then we're making

00:27:18,259 --> 00:27:23,899
the wrong assumptions about system call

00:27:20,509 --> 00:27:26,179
numbers now why why could things go

00:27:23,899 --> 00:27:28,789
wrong like this perhaps we just we

00:27:26,179 --> 00:27:31,460
constructed a BPF blob on one system and

00:27:28,789 --> 00:27:33,619
then using a lot of configuration making

00:27:31,460 --> 00:27:35,600
it management system we installed that

00:27:33,619 --> 00:27:38,480
BPF block blob on another system and a

00:27:35,600 --> 00:27:40,549
program loaded it and installed that BPF

00:27:38,480 --> 00:27:43,610
filter for itself but it happened by

00:27:40,549 --> 00:27:45,919
accident that the blob was built on one

00:27:43,610 --> 00:27:48,279
architecture but got loaded on another

00:27:45,919 --> 00:27:51,970
architecture that could be a possibility

00:27:48,279 --> 00:27:56,179
there are other possibilities though

00:27:51,970 --> 00:27:59,539
we've got things like modern x86 modern

00:27:56,179 --> 00:28:04,480
x86 architectures that actually support

00:27:59,539 --> 00:28:08,539
multiple system call a be eyes so on x86

00:28:04,480 --> 00:28:11,869
64 we've got the asari on x86 we've got

00:28:08,539 --> 00:28:16,610
our modern x86 we've got the x86 64 ABI

00:28:11,869 --> 00:28:19,399
we've got the old i386 api and we've

00:28:16,610 --> 00:28:25,340
also got the x32 ABI

00:28:19,399 --> 00:28:28,279
which is a has 32-bit integers and and

00:28:25,340 --> 00:28:32,809
and sorry 32-bit Long's and pointers but

00:28:28,279 --> 00:28:35,509
a 64 gigabyte I'm sorry I'm a 64-bit

00:28:32,809 --> 00:28:38,720
address space and each one of those

00:28:35,509 --> 00:28:41,149
three architectures has in some cases at

00:28:38,720 --> 00:28:48,019
least different numbers for the

00:28:41,149 --> 00:28:50,240
different system calls so I said when

00:28:48,019 --> 00:28:53,419
you install a set comp filter it stays

00:28:50,240 --> 00:28:55,460
permanently install for the process well

00:28:53,419 --> 00:28:57,980
the thing is a process could exec

00:28:55,460 --> 00:28:59,870
different programs during its lifetime

00:28:57,980 --> 00:29:03,169
and it might start off executing a

00:28:59,870 --> 00:29:06,440
64-bit x86 program but then that program

00:29:03,169 --> 00:29:08,539
executes a three eight six binary now

00:29:06,440 --> 00:29:10,640
that binary is going to use different

00:29:08,539 --> 00:29:13,039
system call numbers and those system

00:29:10,640 --> 00:29:16,520
call numbers won't necessarily be valid

00:29:13,039 --> 00:29:19,580
when tested in that by the same set comp

00:29:16,520 --> 00:29:21,169
BPF filter program so it's it's

00:29:19,580 --> 00:29:24,460
imperative that the filter program

00:29:21,169 --> 00:29:29,929
always has to begin by checking the

00:29:24,460 --> 00:29:34,159
architecture on which it's running okay

00:29:29,929 --> 00:29:35,960
now once a field is installed every

00:29:34,159 --> 00:29:38,179
system call that the process then makes

00:29:35,960 --> 00:29:41,450
gets tested answer the filter the filter

00:29:38,179 --> 00:29:44,539
returns a value saying do we like this

00:29:41,450 --> 00:29:46,940
system for or not and this is done with

00:29:44,539 --> 00:29:49,520
one of these BPF ret instructions and

00:29:46,940 --> 00:29:52,039
the return value the filter gives back

00:29:49,520 --> 00:29:54,590
to the kernel consists of 32 bits the

00:29:52,039 --> 00:29:58,159
first 16 bits the topmost 16 bits are

00:29:54,590 --> 00:30:00,140
some kind of action saying you know what

00:29:58,159 --> 00:30:02,539
do we generally think about the system

00:30:00,140 --> 00:30:04,370
called is it good is it bad there's

00:30:02,539 --> 00:30:07,370
various choices you can make and the

00:30:04,370 --> 00:30:10,789
bottom 16 bits are some kind of data

00:30:07,370 --> 00:30:12,289
that goes with the action ok so this is

00:30:10,789 --> 00:30:15,320
the information that the BPF filter

00:30:12,289 --> 00:30:19,309
program is returning to the kernel to

00:30:15,320 --> 00:30:22,070
say you know do something in response to

00:30:19,309 --> 00:30:24,470
our decision about this system core and

00:30:22,070 --> 00:30:26,270
what sort of return values can we give

00:30:24,470 --> 00:30:29,870
or can the BPF program give back to the

00:30:26,270 --> 00:30:32,840
kernel BPF rattle ow yep the system

00:30:29,870 --> 00:30:37,610
falls fine let the system call proceed

00:30:32,840 --> 00:30:41,600
and the process continue or BBF ret cool

00:30:37,610 --> 00:30:43,880
process we don't like this system halt

00:30:41,600 --> 00:30:46,429
we we don't like it so much you should

00:30:43,880 --> 00:30:47,840
kill the process straight away and all

00:30:46,429 --> 00:30:51,350
the threads in the process get killed

00:30:47,840 --> 00:30:53,360
they get killed as though although the

00:30:51,350 --> 00:30:55,789
process gets killed as stone it was

00:30:53,360 --> 00:30:58,460
killed with a sixth signal I'll say as

00:30:55,789 --> 00:31:02,000
slow because there is actually no signal

00:30:58,460 --> 00:31:04,399
involved ok the process is killed

00:31:02,000 --> 00:31:06,590
outright but to another process

00:31:04,399 --> 00:31:08,390
for instance a parent process or a P

00:31:06,590 --> 00:31:11,120
trace process that was observed

00:31:08,390 --> 00:31:13,520
serving this process it would look like

00:31:11,120 --> 00:31:15,410
the process was killed with a success

00:31:13,520 --> 00:31:17,210
signal and the reason that success

00:31:15,410 --> 00:31:20,030
signal or that that decision was made is

00:31:17,210 --> 00:31:22,040
success is one of the is the traditional

00:31:20,030 --> 00:31:27,230
signal meaning a process tried to

00:31:22,040 --> 00:31:29,540
execute an invalid system call okay

00:31:27,230 --> 00:31:31,490
another possibility the filter program

00:31:29,540 --> 00:31:34,549
could return to the kernel saying set

00:31:31,490 --> 00:31:37,670
comp rekt kill thread we don't like this

00:31:34,549 --> 00:31:39,559
system call kill the thread that made it

00:31:37,670 --> 00:31:42,830
but if it's a multi-threaded process

00:31:39,559 --> 00:31:46,309
then the rest of the threads continue

00:31:42,830 --> 00:31:48,080
which is kind of odd I find but it's

00:31:46,309 --> 00:31:51,110
possible okay

00:31:48,080 --> 00:31:54,440
another possibility is we say set comp

00:31:51,110 --> 00:31:59,030
ret no now what this says for the kernel

00:31:54,440 --> 00:32:01,429
is don't execute the system for make it

00:31:59,030 --> 00:32:04,190
look like the system call has failed and

00:32:01,429 --> 00:32:05,570
in the ER no value that's returned to

00:32:04,190 --> 00:32:07,160
the user space program

00:32:05,570 --> 00:32:11,000
there'll be whatever value is specified

00:32:07,160 --> 00:32:12,530
in the bottom 16 bits of the return

00:32:11,000 --> 00:32:15,460
value in other words the set comp ret

00:32:12,530 --> 00:32:18,260
data field going back there remember the

00:32:15,460 --> 00:32:21,230
return value is two pieces of 16-bit

00:32:18,260 --> 00:32:23,660
action and 16 bits of data well the data

00:32:21,230 --> 00:32:25,640
says what what

00:32:23,660 --> 00:32:27,530
ernõ value should be returned to the

00:32:25,640 --> 00:32:29,240
user space program so from the point of

00:32:27,530 --> 00:32:31,070
view the user space program it looks

00:32:29,240 --> 00:32:32,540
like the system call failed but the

00:32:31,070 --> 00:32:35,559
program can carry on doing whatever it

00:32:32,540 --> 00:32:38,179
wants to do in response to the failure

00:32:35,559 --> 00:32:39,740
there are a few other actions as well

00:32:38,179 --> 00:32:41,360
but I'm not going to try and talk about

00:32:39,740 --> 00:32:44,840
them I just mention they exist you can

00:32:41,360 --> 00:32:52,070
read about them in the manual page okay

00:32:44,840 --> 00:32:55,370
so in order to use and to install a BPF

00:32:52,070 --> 00:32:58,429
program a process uses either the PR CTL

00:32:55,370 --> 00:33:00,559
system call or the set comp system call

00:32:58,429 --> 00:33:03,830
to say that we want to install a BPA

00:33:00,559 --> 00:33:05,179
filter and we've got a series of

00:33:03,830 --> 00:33:07,820
arguments there so for instance for

00:33:05,179 --> 00:33:10,340
CENTCOM this last argument here is a

00:33:07,820 --> 00:33:13,160
pointer to the BPF program that we want

00:33:10,340 --> 00:33:15,020
to install I'll ignore the flags you can

00:33:13,160 --> 00:33:16,640
read about them in manual page but this

00:33:15,020 --> 00:33:18,350
point are there to the filter program

00:33:16,640 --> 00:33:20,720
looks like this it's appointed to a

00:33:18,350 --> 00:33:21,880
structure of type sock F program this

00:33:20,720 --> 00:33:24,940
tells us about the

00:33:21,880 --> 00:33:27,910
working origins of BPF a socket filter

00:33:24,940 --> 00:33:31,120
program okay and what's a net structure

00:33:27,910 --> 00:33:33,670
there's a pointer to a filter program a

00:33:31,120 --> 00:33:37,150
sock filter again networking origins

00:33:33,670 --> 00:33:40,210
that is our actual BPF program and up

00:33:37,150 --> 00:33:46,450
here the Len I of the lint field is the

00:33:40,210 --> 00:33:50,380
size of that program okay now this is

00:33:46,450 --> 00:33:54,280
slightly complicated to explain but I

00:33:50,380 --> 00:33:58,630
hope I get it across if you're going to

00:33:54,280 --> 00:34:01,330
use sync comp the process either has to

00:33:58,630 --> 00:34:05,470
be privileged or it has to set something

00:34:01,330 --> 00:34:07,390
called the no new proves bit now what is

00:34:05,470 --> 00:34:09,700
this bit about so this means if you if

00:34:07,390 --> 00:34:11,950
the process is unprivileged it has to

00:34:09,700 --> 00:34:14,919
set this bit now this is a this is a

00:34:11,950 --> 00:34:17,649
process attribute again set with the

00:34:14,919 --> 00:34:21,010
good old multiplexing PR CTL system call

00:34:17,649 --> 00:34:24,520
and what is this bit mean it means that

00:34:21,010 --> 00:34:28,450
if this process now execute a set UID or

00:34:24,520 --> 00:34:33,129
a set GID or a program or a program with

00:34:28,450 --> 00:34:35,860
capabilities those the seek UID bit the

00:34:33,129 --> 00:34:42,220
set GID but the file K police are

00:34:35,860 --> 00:34:44,740
ignored now why is that let's suppose

00:34:42,220 --> 00:34:48,460
you're an attacker and you're an attack

00:34:44,740 --> 00:34:51,899
I've turned off deliberately you're an

00:34:48,460 --> 00:34:56,830
attacker who knows about sit comp and

00:34:51,899 --> 00:35:00,430
you know that people who write set UID

00:34:56,830 --> 00:35:02,590
programs aren't always tidy and what

00:35:00,430 --> 00:35:04,390
they do they sometimes make mistakes you

00:35:02,590 --> 00:35:06,280
know perhaps they don't reject protect

00:35:04,390 --> 00:35:10,170
the return value from some system call

00:35:06,280 --> 00:35:13,540
that maybe could fail and you think hey

00:35:10,170 --> 00:35:15,190
this this this this developer of the set

00:35:13,540 --> 00:35:17,470
UID root program they didn't change the

00:35:15,190 --> 00:35:18,700
return value on that system call because

00:35:17,470 --> 00:35:22,870
they assumed the system call would

00:35:18,700 --> 00:35:25,930
always succeed but I can use set comp to

00:35:22,870 --> 00:35:28,210
make that system call fail in other

00:35:25,930 --> 00:35:30,940
words I can use set comp this is what I

00:35:28,210 --> 00:35:34,060
hope I could use set comp to make the

00:35:30,940 --> 00:35:38,050
set your ID root program do some

00:35:34,060 --> 00:35:39,820
thing unexpected that's the theory okay

00:35:38,050 --> 00:35:41,410
attackers love that sort of thing making

00:35:39,820 --> 00:35:42,910
a privileged proof of program

00:35:41,410 --> 00:35:46,090
through something unexpected is the

00:35:42,910 --> 00:35:48,550
first step and privilege escalation now

00:35:46,090 --> 00:35:50,950
that's actually not possible though

00:35:48,550 --> 00:35:53,200
because if you're an unprivileged user

00:35:50,950 --> 00:35:55,480
if you want in your sitcom you have to

00:35:53,200 --> 00:35:58,090
set there's no new proofs but first and

00:35:55,480 --> 00:36:00,550
that says that set UID bits and set GID

00:35:58,090 --> 00:36:03,400
bits and file table is now no longer

00:36:00,550 --> 00:36:06,460
have an effect so it's to avoid that

00:36:03,400 --> 00:36:08,350
kind of theoretical attack that I

00:36:06,460 --> 00:36:14,290
mentioned it's not possible because of

00:36:08,350 --> 00:36:15,850
this okay if you try and install a

00:36:14,290 --> 00:36:17,770
sitcom filter and you're not privileged

00:36:15,850 --> 00:36:22,390
and you haven't set that bit then the

00:36:17,770 --> 00:36:27,820
kernel says no sorry all righty

00:36:22,390 --> 00:36:29,920
let's look at a real example so we've

00:36:27,820 --> 00:36:31,900
got a program here what it's going to do

00:36:29,920 --> 00:36:34,900
it's going to infer what sets the known

00:36:31,900 --> 00:36:38,700
you proves but using PR CTL then it's

00:36:34,900 --> 00:36:41,200
got some code that installs a filter and

00:36:38,700 --> 00:36:44,230
then we're gonna execute some system for

00:36:41,200 --> 00:36:47,050
open okay there's a little clue there

00:36:44,230 --> 00:36:48,580
with the next line we won't get this far

00:36:47,050 --> 00:36:51,340
in the code and that's because the

00:36:48,580 --> 00:36:53,230
sitcom filter is going to kill the

00:36:51,340 --> 00:36:56,680
process when it tries to make the open

00:36:53,230 --> 00:36:59,800
system call so let's look at this BPF

00:36:56,680 --> 00:37:02,440
filter what have we got for instructions

00:36:59,800 --> 00:37:05,230
okay this my install filter function the

00:37:02,440 --> 00:37:09,520
very first thing it does is define us an

00:37:05,230 --> 00:37:12,580
array of stretch sock filter structures

00:37:09,520 --> 00:37:14,860
and what are the the we've got various

00:37:12,580 --> 00:37:16,390
instructions in each one of these array

00:37:14,860 --> 00:37:21,670
elements the first instruction here says

00:37:16,390 --> 00:37:24,970
load a word into the accumulator from

00:37:21,670 --> 00:37:27,040
the data area and then the word that

00:37:24,970 --> 00:37:28,780
we're loading is the word at offset of

00:37:27,040 --> 00:37:32,290
architecture in other words load the

00:37:28,780 --> 00:37:35,560
architecture into the accumulator then

00:37:32,290 --> 00:37:37,540
do a conditional jump is the information

00:37:35,560 --> 00:37:39,820
in the accumulator equal to the value in

00:37:37,540 --> 00:37:42,850
the operand and your friend value is

00:37:39,820 --> 00:37:45,790
arch x86 64 in other words we're asking

00:37:42,850 --> 00:37:48,069
it's the architecture executing on x86

00:37:45,790 --> 00:37:49,749
64 if it is

00:37:48,069 --> 00:37:50,979
gonna jump forward one instruction in

00:37:49,749 --> 00:37:54,579
other words were going to skip over the

00:37:50,979 --> 00:37:56,799
next instruction if it's not equal then

00:37:54,579 --> 00:37:59,199
I'm gonna jump forward zero instructions

00:37:56,799 --> 00:38:02,769
to this return statement says kill the

00:37:59,199 --> 00:38:05,380
process we're not on the architecture we

00:38:02,769 --> 00:38:07,930
expected the system call numbers are not

00:38:05,380 --> 00:38:10,989
going to be what we expect so let's get

00:38:07,930 --> 00:38:15,160
out of here terminate the process but

00:38:10,989 --> 00:38:17,559
otherwise we do is further forward we

00:38:15,160 --> 00:38:19,749
load into the accumulator a word from

00:38:17,559 --> 00:38:23,469
the data area the word we're loading is

00:38:19,749 --> 00:38:24,969
the word at the offset of the system

00:38:23,469 --> 00:38:27,190
call number other words load the system

00:38:24,969 --> 00:38:30,459
call number into the accumulator and

00:38:27,190 --> 00:38:34,749
then we do an equality test is the word

00:38:30,459 --> 00:38:36,609
in the accumulator jump equality testing

00:38:34,749 --> 00:38:38,799
against the value in the operand is it

00:38:36,609 --> 00:38:40,269
equal to the in our open value no in our

00:38:38,799 --> 00:38:42,279
open is just the value that's defined in

00:38:40,269 --> 00:38:44,589
one of the header files it's the number

00:38:42,279 --> 00:38:46,660
of the open system call on this our

00:38:44,589 --> 00:38:50,109
kicker so if this is an open system call

00:38:46,660 --> 00:38:54,009
jump forward two instructions zero one

00:38:50,109 --> 00:38:55,449
to land down here and that is return to

00:38:54,009 --> 00:39:01,029
the controller of the kernel telling the

00:38:55,449 --> 00:39:02,440
kernel kill the process and then if it's

00:39:01,029 --> 00:39:04,690
not equal to open then we jump forward

00:39:02,440 --> 00:39:07,539
Sara instructions and we test we load

00:39:04,690 --> 00:39:08,890
into the accumulator the sorry we do an

00:39:07,539 --> 00:39:11,109
equality guess is the word and it came

00:39:08,890 --> 00:39:13,269
murder equal to the open edge system

00:39:11,109 --> 00:39:15,519
call number now open at is a variation

00:39:13,269 --> 00:39:17,170
on open so we're checking for both kinds

00:39:15,519 --> 00:39:18,400
of system calls that do an open there

00:39:17,170 --> 00:39:20,650
are actually if you are the system calls

00:39:18,400 --> 00:39:23,559
that open files as well but this is my

00:39:20,650 --> 00:39:25,150
simple example so if it is equal to the

00:39:23,559 --> 00:39:28,180
open answers and Paul jump forward one

00:39:25,150 --> 00:39:31,449
instruction now with zero one kill the

00:39:28,180 --> 00:39:34,150
process otherwise jump for zero

00:39:31,449 --> 00:39:39,549
instructions when we land here every

00:39:34,150 --> 00:39:41,259
other system call is allowed okay here's

00:39:39,549 --> 00:39:43,809
the rest of my install filled a program

00:39:41,259 --> 00:39:45,729
there's my struct F prog structure the

00:39:43,809 --> 00:39:48,430
filter field of the structure points to

00:39:45,729 --> 00:39:50,319
my actual filter program the size of

00:39:48,430 --> 00:39:53,859
that filled a program I put in to Len

00:39:50,319 --> 00:39:56,440
it's the Sun it's the size of the filter

00:39:53,859 --> 00:39:57,880
array divided by the size of the first

00:39:56,440 --> 00:40:01,349
LM hello it's the number of instructions

00:39:57,880 --> 00:40:01,349
in the filter

00:40:01,469 --> 00:40:08,829
okay so when I run the program then

00:40:05,079 --> 00:40:11,049
what's gonna happen is I see this being

00:40:08,829 --> 00:40:12,640
printed out by the shell bad system pool

00:40:11,049 --> 00:40:14,559
what I don't see is that message from

00:40:12,640 --> 00:40:16,329
the program that said no you won't see

00:40:14,559 --> 00:40:18,910
this that printf string saying you won't

00:40:16,329 --> 00:40:21,039
see this string and that's because the

00:40:18,910 --> 00:40:25,089
program or the process tried to call

00:40:21,039 --> 00:40:28,569
open the BPF filter denied that the

00:40:25,089 --> 00:40:30,099
kernel killed the process and it made it

00:40:28,569 --> 00:40:32,829
look like the process terminated with a

00:40:30,099 --> 00:40:34,869
success signal the shell saw that the

00:40:32,829 --> 00:40:36,940
process that it started looked like it

00:40:34,869 --> 00:40:39,819
was killed by a success signal and print

00:40:36,940 --> 00:40:47,640
out the standard text correspond to the

00:40:39,819 --> 00:40:49,839
signature signal bad system core okay I

00:40:47,640 --> 00:40:51,130
knew I wasn't gonna have enough time I

00:40:49,839 --> 00:40:55,479
think I'm supposed to finish now is that

00:40:51,130 --> 00:40:56,589
true I think it is okay

00:40:55,479 --> 00:41:01,749
I'm gonna race through I'm not going

00:40:56,589 --> 00:41:05,170
into round two another example did you

00:41:01,749 --> 00:41:06,849
do okay I'll just quickly say PRC TL and

00:41:05,170 --> 00:41:10,719
sitcom one of the filters that you

00:41:06,849 --> 00:41:13,900
install they might allow PRC VL and SiC

00:41:10,719 --> 00:41:16,569
constables if that's the case then you

00:41:13,900 --> 00:41:18,039
can add more filters to the process

00:41:16,569 --> 00:41:20,920
so if process might have multiple

00:41:18,039 --> 00:41:24,969
filters in effect all those filters get

00:41:20,920 --> 00:41:26,049
executors that's possible there are some

00:41:24,969 --> 00:41:30,309
other details there that I'm not going

00:41:26,049 --> 00:41:32,739
to try and get through if you if your

00:41:30,309 --> 00:41:34,839
filters allow you to do fork or clone to

00:41:32,739 --> 00:41:36,910
create child processes the child

00:41:34,839 --> 00:41:38,739
inherits the filters know it's fork and

00:41:36,910 --> 00:41:41,049
clone can't be used to escape filtering

00:41:38,739 --> 00:41:42,640
same thing if the filters allow exactly

00:41:41,049 --> 00:41:44,949
doing so that you can examine your

00:41:42,640 --> 00:41:47,109
program the filters stay in place so

00:41:44,949 --> 00:41:50,890
executing your program isn't a way of

00:41:47,109 --> 00:41:52,630
escaping a filter either now once you do

00:41:50,890 --> 00:41:55,539
this when you install a BPA filter this

00:41:52,630 --> 00:41:58,569
gets executed for every system call

00:41:55,539 --> 00:42:00,579
there is a performance cost but in these

00:41:58,569 --> 00:42:02,780
days of spectra and meltdown it matters

00:42:00,579 --> 00:42:05,700
less and less

00:42:02,780 --> 00:42:08,820
okay so for example on that example that

00:42:05,700 --> 00:42:10,890
I just showed you where I had six BPF

00:42:08,820 --> 00:42:12,330
instructions in my filter if I took that

00:42:10,890 --> 00:42:14,190
filter and instead applied it to a

00:42:12,330 --> 00:42:16,170
program it just calls the get PPID

00:42:14,190 --> 00:42:19,920
system called returns the parent process

00:42:16,170 --> 00:42:24,510
ID that's of course a very cheap system

00:42:19,920 --> 00:42:26,550
call if I ran that on an old system

00:42:24,510 --> 00:42:29,250
they've increased the execution of the

00:42:26,550 --> 00:42:31,170
process about 25 percent now two things

00:42:29,250 --> 00:42:33,930
I want to say about that 25 percent if

00:42:31,170 --> 00:42:36,150
the JIT compiler wasn't enabled there

00:42:33,930 --> 00:42:39,270
was a JIT compile of a BPF which makes

00:42:36,150 --> 00:42:42,150
BPF go quite a lot faster and that was

00:42:39,270 --> 00:42:43,920
25 percent on a kernel that didn't have

00:42:42,150 --> 00:42:46,140
the spectra and meltdown mitigations

00:42:43,920 --> 00:42:49,440
installed because nowadays get PPID

00:42:46,140 --> 00:42:52,500
takes 300 percent more time to execute

00:42:49,440 --> 00:42:55,260
than it used to so yeah we can reduce

00:42:52,500 --> 00:42:57,150
that 25 percent to 6 percent and then

00:42:55,260 --> 00:43:04,830
the JIT compiler again reduces it 2

00:42:57,150 --> 00:43:06,630
percent okay all righty just a little

00:43:04,830 --> 00:43:08,340
word of warning BPF seems like a great

00:43:06,630 --> 00:43:11,280
thing to some people and there's a

00:43:08,340 --> 00:43:12,680
useful thing but one of these are going

00:43:11,280 --> 00:43:15,630
to do when you install it when you

00:43:12,680 --> 00:43:17,040
create BPA filters for a process or for

00:43:15,630 --> 00:43:19,470
a program is you're gonna ask yourself

00:43:17,040 --> 00:43:22,470
well which system calls does my program

00:43:19,470 --> 00:43:25,920
actually make and that's not an easy

00:43:22,470 --> 00:43:27,900
question to answer and there are various

00:43:25,920 --> 00:43:29,490
ways you might you might try s tracing

00:43:27,900 --> 00:43:32,460
your prospective process you don't talk

00:43:29,490 --> 00:43:36,660
to Demeter to hear about that Dimitri's

00:43:32,460 --> 00:43:39,720
going to talk about s trace later on the

00:43:36,660 --> 00:43:41,820
thing is there's no perfect way of

00:43:39,720 --> 00:43:43,530
answering this question you hope that

00:43:41,820 --> 00:43:47,070
you've got a right because if you've got

00:43:43,530 --> 00:43:50,310
it wrong and your filter denied a

00:43:47,070 --> 00:43:52,410
legitimate system call then your filters

00:43:50,310 --> 00:43:55,850
going to caused your application to

00:43:52,410 --> 00:44:00,810
crash ok so you can use set comp to

00:43:55,850 --> 00:44:02,850
inject bugs into an application and it's

00:44:00,810 --> 00:44:04,560
maybe even more complicated with in a

00:44:02,850 --> 00:44:06,540
program we normally call wrapper

00:44:04,560 --> 00:44:08,580
functions not sister we don't use call

00:44:06,540 --> 00:44:10,410
numbers directly and those wrapper

00:44:08,580 --> 00:44:13,770
functions their behavior in the C

00:44:10,410 --> 00:44:15,420
library changes over time what I'm

00:44:13,770 --> 00:44:17,130
trying to say here is you can't just

00:44:15,420 --> 00:44:18,420
create a set can't filter forget about

00:44:17,130 --> 00:44:20,160
it it's got to be part of your

00:44:18,420 --> 00:44:21,870
continuous integration testing it's got

00:44:20,160 --> 00:44:25,140
to be unit tested like every other piece

00:44:21,870 --> 00:44:28,350
of code ok so it's got to be part of

00:44:25,140 --> 00:44:29,670
your general testing of your application

00:44:28,350 --> 00:44:33,390
there's nautical here that talks about

00:44:29,670 --> 00:44:37,440
that on lwn net the inherent fragility

00:44:33,390 --> 00:44:38,700
of set comp ok I just want to very

00:44:37,440 --> 00:44:41,580
briefly mention there are some other

00:44:38,700 --> 00:44:43,110
tools then for improving your

00:44:41,580 --> 00:44:44,750
productivity with set Congress that idea

00:44:43,110 --> 00:44:48,240
of hand coding those instruction

00:44:44,750 --> 00:44:50,970
instructions gets old really fast there

00:44:48,240 --> 00:44:53,280
is a library round called Lib set comp

00:44:50,970 --> 00:44:55,770
it's a set of API where you can say I

00:44:53,280 --> 00:44:57,390
want a filter that does this give me a

00:44:55,770 --> 00:44:59,700
rule that filters for the open system

00:44:57,390 --> 00:45:01,170
call or perhaps the fork system call or

00:44:59,700 --> 00:45:03,690
a rule that filters for the closed

00:45:01,170 --> 00:45:04,830
system call and then you can say I want

00:45:03,690 --> 00:45:07,350
a very set of rules and then you can say

00:45:04,830 --> 00:45:10,080
ok now construct that filter for me and

00:45:07,350 --> 00:45:12,090
install us for the process so what this

00:45:10,080 --> 00:45:14,010
filter here is doing we're saying this

00:45:12,090 --> 00:45:15,840
context object here is the sort of

00:45:14,010 --> 00:45:17,940
general handle on which everything hangs

00:45:15,840 --> 00:45:20,700
and we're saying initialize the object

00:45:17,940 --> 00:45:23,430
add a rule saying that clone should fail

00:45:20,700 --> 00:45:26,550
with the perm fork should fail with

00:45:23,430 --> 00:45:28,680
Enochs app load the filter into the

00:45:26,550 --> 00:45:31,080
kernel and then execute some code which

00:45:28,680 --> 00:45:33,480
is going to be filtered so then when we

00:45:31,080 --> 00:45:36,450
try and call for kir fork is going to

00:45:33,480 --> 00:45:39,330
fail ok so this is much more comfortable

00:45:36,450 --> 00:45:45,240
than coding up those instructions

00:45:39,330 --> 00:45:48,260
yourself by hand yeah and I think I

00:45:45,240 --> 00:45:52,050
really must be over time now so I won't

00:45:48,260 --> 00:45:54,120
say much more than that and maybe if

00:45:52,050 --> 00:46:01,220
there's one or two questions otherwise

00:45:54,120 --> 00:46:05,240
I'll let the next speak it on here yes

00:46:01,220 --> 00:46:08,960
a filter that is installed cannot be

00:46:05,240 --> 00:46:11,180
removed and it cannot be changed okay

00:46:08,960 --> 00:46:12,470
you can add more filters but that only

00:46:11,180 --> 00:46:15,890
thing that only makes things more

00:46:12,470 --> 00:46:17,690
restrictive I think I knew that

00:46:15,890 --> 00:46:23,660
yeah a new filter can change the

00:46:17,690 --> 00:46:25,609
behavior of an existing filter yeah so

00:46:23,660 --> 00:46:36,880
if there's multiple filters all of them

00:46:25,609 --> 00:46:36,880
must permit the system core ok question

00:46:38,920 --> 00:46:48,130
you have to yell at me I'm sorry I'm so

00:46:46,660 --> 00:46:51,490
sorry I can't hear you from up here it's

00:46:48,130 --> 00:46:52,660
actually a very big room maybe we can

00:46:51,490 --> 00:46:54,730
talk about offline because I think the

00:46:52,660 --> 00:46:57,180
next speaker needs to get set up is it

00:46:54,730 --> 00:46:57,180
you Dimitri

00:47:14,760 --> 00:47:21,910
yeah yeah is there a portal way of

00:47:19,660 --> 00:47:26,680
writing second filters libtech Kampf is

00:47:21,910 --> 00:47:28,660
the best we've got at the moment it does

00:47:26,680 --> 00:47:31,660
a lot of the architecture specific stuff

00:47:28,660 --> 00:47:34,630
for you but it's not quite perfect but

00:47:31,660 --> 00:47:37,089
it's the best we've got the there is an

00:47:34,630 --> 00:47:41,530
idea that one day sitcom will be able to

00:47:37,089 --> 00:47:45,250
use ebps and 3bf EBP if there is a clang

00:47:41,530 --> 00:47:49,210
front end than ever to degenerate EBP of

00:47:45,250 --> 00:47:58,299
code but so far sitcom can't use EPP f

00:47:49,210 --> 00:48:00,880
it only uses classic PPF no it's not

00:47:58,299 --> 00:48:04,329
unison the inherent the inherent

00:48:00,880 --> 00:48:06,309
fragility of sitcom you know it's those

00:48:04,329 --> 00:48:08,470
filters have got to be tested like every

00:48:06,309 --> 00:48:13,839
other piece of code in a future-proof

00:48:08,470 --> 00:48:15,210
way you know okay where is the next

00:48:13,839 --> 00:48:18,450
speaker

00:48:15,210 --> 00:48:21,450
yeah sorry look please don't agree no

00:48:18,450 --> 00:48:21,450
problem

00:55:44,280 --> 00:55:51,270
okay got two microphones okay

00:56:11,540 --> 00:56:19,000
okay neither can you hear me yes okay

00:56:15,460 --> 00:56:22,040
welcome thanks everybody for being here

00:56:19,000 --> 00:56:25,940
this is a talk on how to ride more than

00:56:22,040 --> 00:56:28,490
video camera driver for Linux and I

00:56:25,940 --> 00:56:31,130
would like to use an example as a

00:56:28,490 --> 00:56:33,490
well-known framework which is going

00:56:31,130 --> 00:56:36,680
through removal or duplication process

00:56:33,490 --> 00:56:38,900
to show how the system we work on as

00:56:36,680 --> 00:56:41,870
change since the times that framework

00:56:38,900 --> 00:56:44,440
has been implemented and hopefully I

00:56:41,870 --> 00:56:46,850
would like to give some suggestion and

00:56:44,440 --> 00:56:49,460
examples if you have drivers depending

00:56:46,850 --> 00:56:52,010
on set framework on how to make them or

00:56:49,460 --> 00:56:53,840
now remove those dependencies and have

00:56:52,010 --> 00:56:57,980
your driver working for next kernel

00:56:53,840 --> 00:57:00,410
releases so these are few of my contacts

00:56:57,980 --> 00:57:04,640
my name is iacopo this is my email

00:57:00,410 --> 00:57:05,900
address this is my RC contact I'm an

00:57:04,640 --> 00:57:08,390
embedded Linux and free software

00:57:05,900 --> 00:57:11,200
developer and I work as a consultant and

00:57:08,390 --> 00:57:14,120
I've been lucky enough to work with the

00:57:11,200 --> 00:57:16,160
excellent renesis mainline kernel team

00:57:14,120 --> 00:57:19,070
in the last two years which gave me the

00:57:16,160 --> 00:57:22,280
opportunity to contribute to Linux in a

00:57:19,070 --> 00:57:24,350
kind of a regular way I would like to

00:57:22,280 --> 00:57:26,960
thanks renesis of course for sponsoring

00:57:24,350 --> 00:57:31,130
me and supporting and given this talk

00:57:26,960 --> 00:57:32,840
and the activities and that's the talk

00:57:31,130 --> 00:57:34,790
outlined so we're gonna look at what's

00:57:32,840 --> 00:57:36,230
happening at SOC camera which is the

00:57:34,790 --> 00:57:38,810
framework that I've been talking about

00:57:36,230 --> 00:57:42,980
and what has changed since the day that

00:57:38,810 --> 00:57:45,020
SOC camera has been implemented the main

00:57:42,980 --> 00:57:46,460
difference is that how system boots

00:57:45,020 --> 00:57:49,730
because we had moved from a world where

00:57:46,460 --> 00:57:52,910
system boots using both eyes to see suit

00:57:49,730 --> 00:57:55,880
through to femur supported boot process

00:57:52,910 --> 00:57:59,690
and that changes the way we discover and

00:57:55,880 --> 00:58:01,460
probe and creates devices power

00:57:59,690 --> 00:58:04,790
management has changed as well that

00:58:01,460 --> 00:58:08,210
depends on how the image capture devices

00:58:04,790 --> 00:58:09,650
are show up in user space and finally I

00:58:08,210 --> 00:58:11,900
would like to give a practical example

00:58:09,650 --> 00:58:14,150
of a driver that was developed at for

00:58:11,900 --> 00:58:16,060
SOC camera and has been made the mole

00:58:14,150 --> 00:58:20,720
early in biddeford Linux driver in

00:58:16,060 --> 00:58:22,400
recent current releases I would like

00:58:20,720 --> 00:58:25,039
also to introduce a bit of glossary

00:58:22,400 --> 00:58:28,039
because words are sometimes confusing

00:58:25,039 --> 00:58:30,799
to capture images we need of course an

00:58:28,039 --> 00:58:33,859
image sensor that produces those images

00:58:30,799 --> 00:58:36,919
and the receiving port which is usually

00:58:33,859 --> 00:58:39,049
installed on the SOC a sensor driver

00:58:36,919 --> 00:58:41,299
controls an image sensor and the bridge

00:58:39,049 --> 00:58:45,349
or receiver driver controls the

00:58:41,299 --> 00:58:47,689
receiving port on the SOC on modern

00:58:45,349 --> 00:58:50,150
system we have we still have an image

00:58:47,689 --> 00:58:52,219
sensor that produce images and an image

00:58:50,150 --> 00:58:54,559
receiver but we also have several

00:58:52,219 --> 00:58:57,709
components on the SOC that takes care of

00:58:54,559 --> 00:59:00,709
image transformation manipulation image

00:58:57,709 --> 00:59:02,419
sensor and drivers for those kind of

00:59:00,709 --> 00:59:06,369
components are generally called via the

00:59:02,419 --> 00:59:08,539
sub device driver let's start by

00:59:06,369 --> 00:59:10,819
discussing what's happening to us to see

00:59:08,539 --> 00:59:14,479
camera and start by saying that SSE

00:59:10,819 --> 00:59:15,919
camera was great in my opinion and can I

00:59:14,479 --> 00:59:20,329
ask how many people you are at level

00:59:15,919 --> 00:59:23,029
work with us a C cameras ok just a few

00:59:20,329 --> 00:59:25,069
but so if you work with that framework

00:59:23,029 --> 00:59:27,140
you know it it was great because he

00:59:25,069 --> 00:59:30,739
provides you nice abstraction a way for

00:59:27,140 --> 00:59:32,839
the crude before a to API which might be

00:59:30,739 --> 00:59:33,890
kind of scary if that's the first video

00:59:32,839 --> 00:59:36,409
driver you have - right

00:59:33,890 --> 00:59:38,239
it's kind of scary to deal with all the

00:59:36,409 --> 00:59:42,019
complexity of the video for Linux API

00:59:38,239 --> 00:59:45,799
all the i/o city else you have to take

00:59:42,019 --> 00:59:47,809
take care of buffer allocation and this

00:59:45,799 --> 00:59:50,719
is a camera obstructed all those things

00:59:47,809 --> 00:59:51,019
away in a nice way and that's why it was

00:59:50,719 --> 00:59:53,449
made

00:59:51,019 --> 00:59:56,359
adopted in a lot of driver in mainline

00:59:53,449 --> 00:59:58,549
and I don't have statistics for that but

00:59:56,359 --> 01:00:01,189
my feeling is that in BSP and in

00:59:58,549 --> 01:00:03,529
downstream kernels he was kind very well

01:00:01,189 --> 01:00:06,229
all the BSP kernel I've been working

01:00:03,529 --> 01:00:10,909
with if they have a camera driver it was

01:00:06,229 --> 01:00:13,039
being an SEC camera and it was so

01:00:10,909 --> 01:00:15,109
adopted because it has good points like

01:00:13,039 --> 01:00:18,559
as I've said it provided a nice

01:00:15,109 --> 01:00:20,949
abstraction away from before - it's the

01:00:18,559 --> 01:00:23,179
same framework for writing bridges and

01:00:20,949 --> 01:00:25,279
sensor drivers so you learn one

01:00:23,179 --> 01:00:29,119
framework you write two drivers that was

01:00:25,279 --> 01:00:31,339
nice and also provides an easy way to

01:00:29,119 --> 01:00:33,769
link bridge driver to sensor drivers

01:00:31,339 --> 01:00:35,539
because the two of them had to be linked

01:00:33,769 --> 01:00:37,470
in order for the bridge driver to call

01:00:35,539 --> 01:00:40,530
separation on the sensor one

01:00:37,470 --> 01:00:42,090
of course there is a bad side since we

01:00:40,530 --> 01:00:45,330
are removing that there is a bad side of

01:00:42,090 --> 01:00:47,010
course and SEC camera was developed in a

01:00:45,330 --> 01:00:50,520
time where system boot is through both

01:00:47,010 --> 01:00:53,340
eyes and this support for Oh F or device

01:00:50,520 --> 01:00:55,440
three and now in a CPI which is gaining

01:00:53,340 --> 01:00:58,290
traction that the system's well is

01:00:55,440 --> 01:01:01,770
limited it isn't that I know but it's

01:00:58,290 --> 01:01:04,380
limited and we're gonna see why it uses

01:01:01,770 --> 01:01:07,500
a set of deprecated operation which is a

01:01:04,380 --> 01:01:11,400
fixable things but while the v4l to api

01:01:07,500 --> 01:01:13,290
evolved the sse camera frame of using

01:01:11,400 --> 01:01:15,990
those api has not been evolved in the

01:01:13,290 --> 01:01:18,900
same way so this is fixable but it's not

01:01:15,990 --> 01:01:20,760
been done so far and more than

01:01:18,900 --> 01:01:23,220
everything else the media controller and

01:01:20,760 --> 01:01:25,800
subway VPI that has been introduced like

01:01:23,220 --> 01:01:27,750
five six years ago are actual gain

01:01:25,800 --> 01:01:30,900
changes because they change the way that

01:01:27,750 --> 01:01:33,720
how image capture devices show up in

01:01:30,900 --> 01:01:38,130
user space so they change SOC camera

01:01:33,720 --> 01:01:41,010
ever really kept up with that and what's

01:01:38,130 --> 01:01:43,410
happening to a sassy camera SOC cameras

01:01:41,010 --> 01:01:45,450
it's deprecated for a long time so you

01:01:43,410 --> 01:01:47,640
are suggesting not to use that for right

01:01:45,450 --> 01:01:49,890
drivers but it's gonna be removed

01:01:47,640 --> 01:01:53,310
finally because it's a long time we're

01:01:49,890 --> 01:01:57,210
gonna that talks about that possibly in

01:01:53,310 --> 01:01:59,430
the next kernel release the last SOC

01:01:57,210 --> 01:02:01,860
camera bridge driver has been removed as

01:01:59,430 --> 01:02:03,720
being important to be a video finish

01:02:01,860 --> 01:02:06,200
driver last year so there are no more

01:02:03,720 --> 01:02:08,640
platforms that depend on that framework

01:02:06,200 --> 01:02:12,030
although there are some sensor driver

01:02:08,640 --> 01:02:14,820
may note the order of tens ten of them

01:02:12,030 --> 01:02:16,950
probably that have not been ported yet

01:02:14,820 --> 01:02:18,930
and they're going to be possibly removed

01:02:16,950 --> 01:02:21,540
there are discussion these days moving

01:02:18,930 --> 01:02:24,480
them to staging or moving that or

01:02:21,540 --> 01:02:26,480
removing them completely it's possible

01:02:24,480 --> 01:02:29,100
they're gonna be removed completely and

01:02:26,480 --> 01:02:31,740
that's the file organization we know

01:02:29,100 --> 01:02:33,960
that platform bridge drivers are usually

01:02:31,740 --> 01:02:36,630
drivers media platform an SOC camera

01:02:33,960 --> 01:02:38,700
drivers are diverse media platform SOC

01:02:36,630 --> 01:02:42,480
camera and here we have no more

01:02:38,700 --> 01:02:44,430
dependencies why for drivers media score

01:02:42,480 --> 01:02:46,380
see where sense of drivers are we have

01:02:44,430 --> 01:02:46,970
some of them which have which will be

01:02:46,380 --> 01:02:49,900
removed

01:02:46,970 --> 01:02:51,789
currently may line we have

01:02:49,900 --> 01:02:53,380
and of a confusing situation because we

01:02:51,789 --> 01:02:55,900
have two driver from the same device

01:02:53,380 --> 01:02:57,369
with just kind of confusing but firm

01:02:55,900 --> 01:03:00,160
necessarily this is what this is going

01:02:57,369 --> 01:03:02,710
away so there are drivers here that

01:03:00,160 --> 01:03:04,359
needs to be ported here and that's work

01:03:02,710 --> 01:03:06,940
to do if somebody would like to

01:03:04,359 --> 01:03:10,329
contribute to that it's it's nice thing

01:03:06,940 --> 01:03:12,789
to do what has changed then since the

01:03:10,329 --> 01:03:15,279
time when an SSC camera was implemented

01:03:12,789 --> 01:03:17,829
as we said the device discovery and

01:03:15,279 --> 01:03:20,289
linking mechanism has changed nowadays

01:03:17,829 --> 01:03:23,740
we do that using notifiers and they sync

01:03:20,289 --> 01:03:26,349
matching power - power management has

01:03:23,740 --> 01:03:28,980
changed as well due to the way how visa

01:03:26,349 --> 01:03:32,020
device are we exposed in user space and

01:03:28,980 --> 01:03:35,619
we now have free standard framework for

01:03:32,020 --> 01:03:38,230
clock and regulators and so SOC camera

01:03:35,619 --> 01:03:41,170
doesn't use deprecated framers for that

01:03:38,230 --> 01:03:43,000
so every time it's possible we should

01:03:41,170 --> 01:03:46,690
use the standard frame was for dealing

01:03:43,000 --> 01:03:50,020
with those two things let's start

01:03:46,690 --> 01:03:51,789
talking about device probing and never

01:03:50,020 --> 01:03:54,730
look at that how device probe was

01:03:51,789 --> 01:03:57,490
performed in the legacy way so we have

01:03:54,730 --> 01:04:00,880
five components here board fives bridge

01:03:57,490 --> 01:04:02,170
driver as a/c camera sensor driver and

01:04:00,880 --> 01:04:05,230
of course the beautiful Linux -

01:04:02,170 --> 01:04:07,450
framework the board file is nothing

01:04:05,230 --> 01:04:09,460
about the playing C file that register

01:04:07,450 --> 01:04:12,309
devices and drivers one after the other

01:04:09,460 --> 01:04:14,710
all devices in the system and at a

01:04:12,309 --> 01:04:16,960
certain point you will add the platform

01:04:14,710 --> 01:04:20,170
driver for the bridge driver so that

01:04:16,960 --> 01:04:22,390
causes the bridge driver to probe at the

01:04:20,170 --> 01:04:24,849
end of the probe section or the probe

01:04:22,390 --> 01:04:26,859
function the bridge driver will probably

01:04:24,849 --> 01:04:28,900
register itself to the SOC camera

01:04:26,859 --> 01:04:31,480
framework that causes the SOC camera to

01:04:28,900 --> 01:04:33,970
do all the it initialization operation

01:04:31,480 --> 01:04:37,299
and that serve at a certain point if we

01:04:33,970 --> 01:04:39,430
start registering us personalizes how

01:04:37,299 --> 01:04:41,859
does it do that it does that using a

01:04:39,430 --> 01:04:44,160
video for LG function which is this one

01:04:41,859 --> 01:04:47,079
before to ask where C news of that board

01:04:44,160 --> 01:04:49,000
which creates a new I square C device

01:04:47,079 --> 01:04:52,420
that causes the sensor driver to probe

01:04:49,000 --> 01:04:54,309
and our turfs to identify while the

01:04:52,420 --> 01:04:56,770
board file knows the I square C bus

01:04:54,309 --> 01:04:59,710
number and the I square C address of the

01:04:56,770 --> 01:05:03,010
device and passes it down to the in the

01:04:59,710 --> 01:05:03,820
coal chain until here which where those

01:05:03,010 --> 01:05:06,270
two information

01:05:03,820 --> 01:05:08,410
I used to identify the sense of driver

01:05:06,270 --> 01:05:11,170
so in the old world

01:05:08,410 --> 01:05:13,930
we have that devices identified by the I

01:05:11,170 --> 01:05:16,030
square C addresses and more important

01:05:13,930 --> 01:05:18,010
and everything the device probing is

01:05:16,030 --> 01:05:20,350
sequential so we have the bridge driver

01:05:18,010 --> 01:05:24,250
probing before the sense of driving and

01:05:20,350 --> 01:05:26,500
that guarantees that every time a sense

01:05:24,250 --> 01:05:31,150
of driver probes it has a boots driver

01:05:26,500 --> 01:05:34,200
to connect to in the new world we have

01:05:31,150 --> 01:05:37,780
we moved to a firmer base boot process

01:05:34,200 --> 01:05:39,640
so nowadays devices are creating parsing

01:05:37,780 --> 01:05:42,070
the film description of the system and

01:05:39,640 --> 01:05:44,050
the advices are not identified anymore

01:05:42,070 --> 01:05:47,350
by I square C addresses by the femur

01:05:44,050 --> 01:05:48,670
note references and again more important

01:05:47,350 --> 01:05:50,530
than everything there is no guarantee

01:05:48,670 --> 01:05:54,510
any more on the probing border of the

01:05:50,530 --> 01:05:57,280
stop of the drivers so this is a DTS and

01:05:54,510 --> 01:05:59,920
in the DTS we have a description or if

01:05:57,280 --> 01:06:01,990
we do input port here and of a nice

01:05:59,920 --> 01:06:03,970
crusty bus on the ice core Sebastian

01:06:01,990 --> 01:06:06,220
there is a sensor identified by an

01:06:03,970 --> 01:06:08,880
address and the system builds Linux

01:06:06,220 --> 01:06:12,190
boots and start parsing the DTS until he

01:06:08,880 --> 01:06:15,190
finds the video input port nodes that

01:06:12,190 --> 01:06:17,350
causes the bridge driver to probe and at

01:06:15,190 --> 01:06:20,110
a certain point it start parsing the ice

01:06:17,350 --> 01:06:23,620
query bus which creates the sense of

01:06:20,110 --> 01:06:27,220
driver which probes again and can safely

01:06:23,620 --> 01:06:29,320
connect to the bridge driver but we can

01:06:27,220 --> 01:06:31,030
also have the other way around so the

01:06:29,320 --> 01:06:32,410
ice core see bus is registered before

01:06:31,030 --> 01:06:36,100
the video input port

01:06:32,410 --> 01:06:38,320
this is probed first and the session

01:06:36,100 --> 01:06:41,080
driver probes completed its pro

01:06:38,320 --> 01:06:44,200
operation but finds no one there to

01:06:41,080 --> 01:06:46,030
register to and that might be a problem

01:06:44,200 --> 01:06:48,810
it's actually a problem because now

01:06:46,030 --> 01:06:51,670
device probing is totally asynchronous

01:06:48,810 --> 01:06:55,090
we have no guarantees which is the

01:06:51,670 --> 01:06:57,280
probing order and again we need to

01:06:55,090 --> 01:07:01,630
identify devices by de fumer node

01:06:57,280 --> 01:07:03,490
references how to do that well before l2

01:07:01,630 --> 01:07:06,040
framework to the rescue here because it

01:07:03,490 --> 01:07:08,290
has two components that are designed for

01:07:06,040 --> 01:07:11,080
helping you how drive is doing that

01:07:08,290 --> 01:07:15,100
exactly which are before l2 async and

01:07:11,080 --> 01:07:17,980
before else ufw node how do they work

01:07:15,100 --> 01:07:21,369
and how drivers use them while we have

01:07:17,980 --> 01:07:23,859
drive again DTS and the two framework

01:07:21,369 --> 01:07:25,510
components and in DTS we have

01:07:23,859 --> 01:07:28,570
description on the input port on the

01:07:25,510 --> 01:07:30,910
output ports of the bridge driver which

01:07:28,570 --> 01:07:33,460
has two ports connected to two or more

01:07:30,910 --> 01:07:37,060
ten points which are possibly sensor of

01:07:33,460 --> 01:07:41,080
sub devices driver the sense the bridge

01:07:37,060 --> 01:07:43,900
driver probes and uses V defer to FW

01:07:41,080 --> 01:07:45,970
node framework to parse the DTS and

01:07:43,900 --> 01:07:47,070
collect references to the remote

01:07:45,970 --> 01:07:50,830
endpoints

01:07:47,070 --> 01:07:53,230
those two are collected in the form of V

01:07:50,830 --> 01:07:54,970
deferral to acing sub device which is an

01:07:53,230 --> 01:07:58,180
abstraction provided you review by this

01:07:54,970 --> 01:08:00,700
part of the framework and those two

01:07:58,180 --> 01:08:03,369
devices are collected by the bridge

01:08:00,700 --> 01:08:05,770
driver what does the bridge the bridge

01:08:03,369 --> 01:08:08,040
driver do with that the bridge driver's

01:08:05,770 --> 01:08:11,890
chose them in what is called a notifier

01:08:08,040 --> 01:08:14,830
it's actually referred to async notifier

01:08:11,890 --> 01:08:16,779
which is provided fine by this part of

01:08:14,830 --> 01:08:20,620
the framework and notifier is nothing

01:08:16,779 --> 01:08:22,900
but a collection of famer not references

01:08:20,620 --> 01:08:27,489
the bridge driver or a generic driver is

01:08:22,900 --> 01:08:29,259
waiting for v4l tracings maintains a

01:08:27,489 --> 01:08:32,319
list of all notify register in the

01:08:29,259 --> 01:08:34,390
system now we have three four in total

01:08:32,319 --> 01:08:36,900
which is kind of a likely in a system

01:08:34,390 --> 01:08:39,310
but it's possible totally possible and

01:08:36,900 --> 01:08:42,009
the bridge driver does nothing but

01:08:39,310 --> 01:08:46,270
register its notifier with devices is

01:08:42,009 --> 01:08:49,980
waiting for to the v4 to async referral

01:08:46,270 --> 01:08:51,730
to a syncs maintains as well a list of

01:08:49,980 --> 01:08:54,370
waiting devices

01:08:51,730 --> 01:08:57,310
this has devices or sub devices that

01:08:54,370 --> 01:09:00,400
probe and no one is waiting for them so

01:08:57,310 --> 01:09:02,620
they put in the waiting list at the

01:09:00,400 --> 01:09:04,960
certain point in time we have that the

01:09:02,620 --> 01:09:08,680
sensor driver probes eventually and it

01:09:04,960 --> 01:09:12,279
uses v4 l to fw node to parse its local

01:09:08,680 --> 01:09:17,650
endpoint and create a v4 LT Racing sub

01:09:12,279 --> 01:09:19,720
device representation of itself it will

01:09:17,650 --> 01:09:22,779
then register that to be pharrell to a

01:09:19,720 --> 01:09:26,230
sings which adds them to the list of

01:09:22,779 --> 01:09:28,500
waiting devices but the two of them gets

01:09:26,230 --> 01:09:31,239
matches so there is someone waiting for

01:09:28,500 --> 01:09:33,679
this sensor

01:09:31,239 --> 01:09:36,290
when the two of them gets matching that

01:09:33,679 --> 01:09:38,870
causes the village racing to call a

01:09:36,290 --> 01:09:42,080
callback on their on the bridge driver

01:09:38,870 --> 01:09:44,839
that bounds the sub device to drive it

01:09:42,080 --> 01:09:47,270
so in this way the bridge will have and

01:09:44,839 --> 01:09:51,080
handle a reference to the sense of

01:09:47,270 --> 01:09:54,560
driver the second okay we are waiting

01:09:51,080 --> 01:09:56,239
for two sensor drivers and the second

01:09:54,560 --> 01:09:58,100
sensor eventual will probe in future

01:09:56,239 --> 01:09:59,780
that's the same things usually before

01:09:58,100 --> 01:10:01,429
else you have lovely node create a

01:09:59,780 --> 01:10:04,010
difference racing subdivides

01:10:01,429 --> 01:10:06,560
representation of itself and register

01:10:04,010 --> 01:10:09,350
that to be for us racing that causes the

01:10:06,560 --> 01:10:11,570
same device to be mentioned and the sub

01:10:09,350 --> 01:10:13,100
device bound and the bounce and about

01:10:11,570 --> 01:10:16,610
callback to be called on the bridge

01:10:13,100 --> 01:10:18,290
driver and so in this way the bridge has

01:10:16,610 --> 01:10:21,620
reference to both the sensor drivers

01:10:18,290 --> 01:10:23,980
waiting for there is a lot of things I'm

01:10:21,620 --> 01:10:26,719
not sure I have not shown you which is

01:10:23,980 --> 01:10:28,730
there's no not only the bound coal-based

01:10:26,719 --> 01:10:32,120
there is things called complete callback

01:10:28,730 --> 01:10:34,370
that it's usually cold when all the sub

01:10:32,120 --> 01:10:37,340
device notifier or all the not the

01:10:34,370 --> 01:10:40,250
synchronous sub device the notifier is

01:10:37,340 --> 01:10:42,469
waiting for have been registered the

01:10:40,250 --> 01:10:45,139
complete callback is usually called year

01:10:42,469 --> 01:10:48,980
the complete callback usually called

01:10:45,139 --> 01:10:51,199
creates all the user special

01:10:48,980 --> 01:10:53,510
representations video device no the

01:10:51,199 --> 01:10:57,320
meter sub device node connected to the

01:10:53,510 --> 01:10:59,719
world capturing infrastructure there is

01:10:57,320 --> 01:11:02,900
discussion going on nowadays if it's a

01:10:59,719 --> 01:11:04,790
good things if you have eight let's say

01:11:02,900 --> 01:11:07,850
you are waiting for eight cameras and

01:11:04,790 --> 01:11:09,409
one of them is not probing do you want

01:11:07,850 --> 01:11:12,679
your system to be working or not

01:11:09,409 --> 01:11:14,929
so should complete be called only when

01:11:12,679 --> 01:11:16,880
all these sub devices are probed or

01:11:14,929 --> 01:11:19,280
sometime it's a good things to have a

01:11:16,880 --> 01:11:21,920
working system even if one of your sub

01:11:19,280 --> 01:11:24,590
devices or camera phase there will be

01:11:21,920 --> 01:11:26,480
discussion about that in the video for

01:11:24,590 --> 01:11:30,710
the next a meeting on two days from now

01:11:26,480 --> 01:11:33,980
and let's see what's happened that of

01:11:30,710 --> 01:11:35,690
course that's what we show so far is the

01:11:33,980 --> 01:11:38,360
situation where the bridge driver probes

01:11:35,690 --> 01:11:40,570
first but we wanted to solve a problem

01:11:38,360 --> 01:11:44,120
which is their synchronous probing

01:11:40,570 --> 01:11:47,420
problems so the sensor may prefer

01:11:44,120 --> 01:11:50,480
so the sensor probes uses before a 2fw

01:11:47,420 --> 01:11:53,050
node to register it async sub device and

01:11:50,480 --> 01:11:55,400
that gets headed to the waiting list

01:11:53,050 --> 01:11:57,530
nobody is waiting for them because there

01:11:55,400 --> 01:11:59,800
are no notifiers waiting for this sub

01:11:57,530 --> 01:12:02,210
device but in a certain point in future

01:11:59,800 --> 01:12:03,950
the bridge driver probes and will

01:12:02,210 --> 01:12:08,870
register and notify waiting for this

01:12:03,950 --> 01:12:11,840
advice the two of them gets matched and

01:12:08,870 --> 01:12:15,400
the two of them gets connected so we

01:12:11,840 --> 01:12:17,960
effectively solve the problem of async

01:12:15,400 --> 01:12:23,030
probing sequences using those two

01:12:17,960 --> 01:12:24,950
framework and the ones view of you that

01:12:23,030 --> 01:12:27,350
knows as the camera knows that assists

01:12:24,950 --> 01:12:30,530
SOC camera can do that actually does

01:12:27,350 --> 01:12:34,670
that it uses those two framework and so

01:12:30,530 --> 01:12:36,380
why it what has changed since then what

01:12:34,670 --> 01:12:38,510
has changed since the time where as such

01:12:36,380 --> 01:12:41,420
the camera has been implemented is that

01:12:38,510 --> 01:12:44,510
now sub devices can have notifiers as

01:12:41,420 --> 01:12:47,090
well this has been introduced one year

01:12:44,510 --> 01:12:50,270
ago by Nicolas sakari and Laurent which

01:12:47,090 --> 01:12:52,610
are the main author of the difference

01:12:50,270 --> 01:12:55,460
who async and refer to fw node

01:12:52,610 --> 01:12:59,000
frameworks to support the Renaissance

01:12:55,460 --> 01:13:02,300
our car CSI infrastructure which as sub

01:12:59,000 --> 01:13:04,430
devices that are connected to sensors so

01:13:02,300 --> 01:13:06,740
we moved from a situation where we have

01:13:04,430 --> 01:13:09,080
a receiver which has notifier and

01:13:06,740 --> 01:13:11,720
connects to sub device to a situation

01:13:09,080 --> 01:13:14,750
where sub device can have a sub notify

01:13:11,720 --> 01:13:17,330
and eventually that sub device says that

01:13:14,750 --> 01:13:19,520
sub notify will be connected to two

01:13:17,330 --> 01:13:21,650
other sub devices this can create a

01:13:19,520 --> 01:13:25,940
chain of arbitrary complexity it's

01:13:21,650 --> 01:13:27,590
usually just one of two level but that's

01:13:25,940 --> 01:13:30,440
nothing preventing you from making more

01:13:27,590 --> 01:13:32,330
complicated things here and right now I

01:13:30,440 --> 01:13:35,330
think a couple of driver main lines are

01:13:32,330 --> 01:13:37,640
usually that IMX were our card for sure

01:13:35,330 --> 01:13:39,770
but also in accessing or using some

01:13:37,640 --> 01:13:42,320
device notifier and it's expected that

01:13:39,770 --> 01:13:47,360
more devices will use this abstraction

01:13:42,320 --> 01:13:49,580
as well power management as we said

01:13:47,360 --> 01:13:52,370
power management has changed as well due

01:13:49,580 --> 01:13:54,590
to the way that video devices are now

01:13:52,370 --> 01:13:56,660
represented in user space and that

01:13:54,590 --> 01:13:57,350
depends on the way on the introduction

01:13:56,660 --> 01:14:02,330
of me

01:13:57,350 --> 01:14:05,030
controller and subdiv api so media

01:14:02,330 --> 01:14:07,970
controller the old device the old world

01:14:05,030 --> 01:14:09,800
no media controller clip devices they

01:14:07,970 --> 01:14:12,110
work with a single device note

01:14:09,800 --> 01:14:14,180
abstraction so the one that we were all

01:14:12,110 --> 01:14:16,810
are used to the death video zero

01:14:14,180 --> 01:14:18,710
abstraction so for a wall capturing

01:14:16,810 --> 01:14:21,680
infrastructure you just have a single

01:14:18,710 --> 01:14:24,080
device known in userspace and that

01:14:21,680 --> 01:14:26,120
causes all operation to be sequential

01:14:24,080 --> 01:14:30,710
they goes through a single device node

01:14:26,120 --> 01:14:32,600
and gets directed to the sub device we

01:14:30,710 --> 01:14:34,910
now live in a world where media control

01:14:32,600 --> 01:14:36,770
is everywhere and it's going to be

01:14:34,910 --> 01:14:38,780
everywhere hopefully in the next year

01:14:36,770 --> 01:14:40,340
and V the device no they are not the

01:14:38,780 --> 01:14:42,560
only abstraction we have in user space

01:14:40,340 --> 01:14:46,520
because we have also video sub device

01:14:42,560 --> 01:14:48,610
node and that cause is all operation not

01:14:46,520 --> 01:14:52,070
to be sequential anymore but instead

01:14:48,610 --> 01:14:55,880
they can be perform on sub devices and

01:14:52,070 --> 01:14:57,950
video devices at the same time so let's

01:14:55,880 --> 01:15:00,050
see an example of that this is a legacy

01:14:57,950 --> 01:15:02,180
system where we have the simplest

01:15:00,050 --> 01:15:04,400
possible capture infrastructure so we

01:15:02,180 --> 01:15:06,680
have a sensor that is connected to an I

01:15:04,400 --> 01:15:09,190
square C bus and it's connected to a

01:15:06,680 --> 01:15:13,790
receiver port where it transmit pixels

01:15:09,190 --> 01:15:16,460
in kernel space they will be they will

01:15:13,790 --> 01:15:18,470
be managed by a receiver driver a sensor

01:15:16,460 --> 01:15:21,470
driver that's the framework part which

01:15:18,470 --> 01:15:24,080
is coming to the to to the the kernel

01:15:21,470 --> 01:15:25,700
frameworks and the user space we will

01:15:24,080 --> 01:15:28,490
have just a single device node

01:15:25,700 --> 01:15:30,650
abstraction so all this infrastructure

01:15:28,490 --> 01:15:35,150
really is represented by a single device

01:15:30,650 --> 01:15:37,880
node we have of course the video for LG

01:15:35,150 --> 01:15:42,580
compliant application and which

01:15:37,880 --> 01:15:45,590
interfaces with all that with v4 - api's

01:15:42,580 --> 01:15:47,330
usually at the first thing we operation

01:15:45,590 --> 01:15:49,460
we have to do if you want to use the

01:15:47,330 --> 01:15:53,900
video device it's to call an open on

01:15:49,460 --> 01:15:57,490
this video device node and usually at

01:15:53,900 --> 01:16:01,490
set power at open time the bridge driver

01:15:57,490 --> 01:16:04,130
just powers up the sensor so in that way

01:16:01,490 --> 01:16:09,510
every other operation the sensor driver

01:16:04,130 --> 01:16:12,060
is ready to send pixel to the receiver

01:16:09,510 --> 01:16:15,510
so the referral to compliant application

01:16:12,060 --> 01:16:17,910
start calling very different ioctl set

01:16:15,510 --> 01:16:21,540
formants get formats allocate buffers

01:16:17,910 --> 01:16:24,330
whatever and the certain point and all

01:16:21,540 --> 01:16:26,640
the operation will be translated by the

01:16:24,330 --> 01:16:29,430
receiver driver to the sense of driver

01:16:26,640 --> 01:16:32,370
using a different to sub that call

01:16:29,430 --> 01:16:34,410
operation at a certain point we will

01:16:32,370 --> 01:16:36,180
receive a stream on so the application

01:16:34,410 --> 01:16:39,840
won't actually the sensor to stream

01:16:36,180 --> 01:16:42,390
pixels and this causes a lot of settings

01:16:39,840 --> 01:16:44,250
to be sent on the ice christi bus and

01:16:42,390 --> 01:16:49,710
picture we start flowing in this

01:16:44,250 --> 01:16:51,600
direction this is what this is what the

01:16:49,710 --> 01:16:53,850
modern device might look like a very

01:16:51,600 --> 01:16:55,739
simplified actually modern device might

01:16:53,850 --> 01:16:57,750
look like so we still have a sensor we

01:16:55,739 --> 01:17:00,480
still have a receiver port but we also

01:16:57,750 --> 01:17:02,580
have a lot of components on the SOC that

01:17:00,480 --> 01:17:04,830
takes care of image transformation and

01:17:02,580 --> 01:17:06,960
manipulation that can be resizing

01:17:04,830 --> 01:17:10,890
conversion between one format and

01:17:06,960 --> 01:17:13,920
another formatting system memory depend

01:17:10,890 --> 01:17:18,030
too depends on your platform and of

01:17:13,920 --> 01:17:21,989
course the drivers that helps that are

01:17:18,030 --> 01:17:24,090
much different from the legacy one and

01:17:21,989 --> 01:17:26,730
they might have different components

01:17:24,090 --> 01:17:30,120
they you may have one asp driver

01:17:26,730 --> 01:17:32,130
handling all three of them one receiver

01:17:30,120 --> 01:17:34,890
driver that's depends on your platform

01:17:32,130 --> 01:17:37,800
but the important thing is that this is

01:17:34,890 --> 01:17:39,780
how it would look like in user space so

01:17:37,800 --> 01:17:42,570
we still have the video device not zero

01:17:39,780 --> 01:17:44,550
which the application uses to start

01:17:42,570 --> 01:17:46,980
streaming and call a certain set of

01:17:44,550 --> 01:17:49,910
operation but we also have all these

01:17:46,980 --> 01:17:52,680
device nodes here which are subdivided

01:17:49,910 --> 01:17:57,030
where the application can cause sub the

01:17:52,680 --> 01:18:00,239
operation as well so this is what may

01:17:57,030 --> 01:18:02,640
happen we may have villages we have some

01:18:00,239 --> 01:18:05,880
devices our your city else : v the sub

01:18:02,640 --> 01:18:07,920
device know that any any time and there

01:18:05,880 --> 01:18:10,950
is no relationship with what between one

01:18:07,920 --> 01:18:14,460
and the other so we might have those to

01:18:10,950 --> 01:18:16,170
call different times and that causes all

01:18:14,460 --> 01:18:17,790
of your operation to be now a

01:18:16,170 --> 01:18:20,340
synchronous because there is not a

01:18:17,790 --> 01:18:22,530
shared notation of power settings

01:18:20,340 --> 01:18:25,860
anymore along all this pipeline

01:18:22,530 --> 01:18:28,410
so the only thing the only suggestion

01:18:25,860 --> 01:18:30,510
that I have for if you are to implement

01:18:28,410 --> 01:18:33,660
a driver in this kind of situation is

01:18:30,510 --> 01:18:36,150
always cache your settings every time

01:18:33,660 --> 01:18:38,490
because you never know the power state

01:18:36,150 --> 01:18:40,740
your driver is working in you may

01:18:38,490 --> 01:18:42,930
receive a set format and your sensor

01:18:40,740 --> 01:18:44,640
might not be powered at all because we

01:18:42,930 --> 01:18:47,190
don't have the single entry point we add

01:18:44,640 --> 01:18:51,600
when working with no media controller

01:18:47,190 --> 01:18:55,710
systems that cause for maintaining a

01:18:51,600 --> 01:18:57,390
driver wise power state notation every

01:18:55,710 --> 01:18:59,970
time you should know if your device is

01:18:57,390 --> 01:19:02,250
powered or not and even better if you

01:18:59,970 --> 01:19:04,170
want to make that ref count it's even

01:19:02,250 --> 01:19:06,930
better because if you receive two set

01:19:04,170 --> 01:19:10,110
power that should not happen but who

01:19:06,930 --> 01:19:13,170
knows what user space is doing you

01:19:10,110 --> 01:19:16,940
should receive choose power of the power

01:19:13,170 --> 01:19:16,940
to actually power of the device

01:19:17,390 --> 01:19:22,050
also you should cast cache or your

01:19:20,100 --> 01:19:24,540
settings and apply them and the time

01:19:22,050 --> 01:19:26,850
where is known the sensor or the sub

01:19:24,540 --> 01:19:29,250
devices to be powered and it that's

01:19:26,850 --> 01:19:31,950
usually stream on time because when you

01:19:29,250 --> 01:19:35,370
receive a stream on just that you should

01:19:31,950 --> 01:19:39,690
start sending pixel and at that time the

01:19:35,370 --> 01:19:42,090
sensor should be powered on also this is

01:19:39,690 --> 01:19:44,790
a general suggestion for not just for

01:19:42,090 --> 01:19:48,270
video devices but try to use runtime

01:19:44,790 --> 01:19:50,610
p.m. runtime p.m. makes provides even

01:19:48,270 --> 01:19:52,080
abstraction that it's more similar to

01:19:50,610 --> 01:19:54,360
the sequential flow of the operation

01:19:52,080 --> 01:19:56,910
that we've seen before so it easy

01:19:54,360 --> 01:20:00,540
development and ref counting of power

01:19:56,910 --> 01:20:04,950
states of course it's not always

01:20:00,540 --> 01:20:07,470
possible it's working Clark's GPS and

01:20:04,950 --> 01:20:09,300
regulators has said we have frameworks

01:20:07,470 --> 01:20:10,710
for that right now and they should be

01:20:09,300 --> 01:20:14,550
used whenever possible

01:20:10,710 --> 01:20:17,430
and relating to power management routine

01:20:14,550 --> 01:20:20,850
in the legacy world we have the board

01:20:17,430 --> 01:20:24,390
file that provided power management

01:20:20,850 --> 01:20:26,880
routine to the sensor so this is how SOC

01:20:24,390 --> 01:20:30,960
camera used to do that there is an SOC

01:20:26,880 --> 01:20:34,590
camera linked with a power call back and

01:20:30,960 --> 01:20:35,570
the board file just filled that pointer

01:20:34,590 --> 01:20:37,880
with

01:20:35,570 --> 01:20:40,010
a routine defined in the board file so

01:20:37,880 --> 01:20:42,830
when the driver needed to power up on

01:20:40,010 --> 01:20:44,930
power off the sensor it called this

01:20:42,830 --> 01:20:48,170
things here and the board file has all

01:20:44,930 --> 01:20:50,600
the references to regulators reset

01:20:48,170 --> 01:20:53,360
whatever it need to power on and off the

01:20:50,600 --> 01:20:58,450
sensor of course we don't have board

01:20:53,360 --> 01:20:58,450
files anymore we have DTS or a CPI and

01:20:58,480 --> 01:21:03,650
how would you do that what you should

01:21:01,340 --> 01:21:06,350
use the GPIO clock and regulator

01:21:03,650 --> 01:21:09,710
frameworks every time they interface

01:21:06,350 --> 01:21:13,070
with the DTS you collect references from

01:21:09,710 --> 01:21:15,760
FEMA which is usually called FM or not

01:21:13,070 --> 01:21:19,820
the vamp depending if you want to use

01:21:15,760 --> 01:21:25,160
the then clock or regulators get and use

01:21:19,820 --> 01:21:26,900
the name using DTS and the driver itself

01:21:25,160 --> 01:21:30,560
should not rely anymore on the board

01:21:26,900 --> 01:21:32,900
files turning on and off the single

01:21:30,560 --> 01:21:37,070
components but if the driver itself that

01:21:32,900 --> 01:21:42,850
should enable disable the regulators or

01:21:37,070 --> 01:21:46,100
the reset line at SS power time

01:21:42,850 --> 01:21:49,310
practical so this is an example of a

01:21:46,100 --> 01:21:52,730
video driver that was was developed

01:21:49,310 --> 01:21:55,700
using SOC camera and in recent I think

01:21:52,730 --> 01:21:58,970
two releases ago has been ported to be a

01:21:55,700 --> 01:22:00,410
plain beautiful Linux to drivers so I

01:21:58,970 --> 01:22:02,780
would like to go through all the paths

01:22:00,410 --> 01:22:06,230
not all of them but some patches there

01:22:02,780 --> 01:22:09,020
and show you what are the steps that has

01:22:06,230 --> 01:22:11,240
been performed to do that in order if

01:22:09,020 --> 01:22:13,730
you have any driver dependency camera

01:22:11,240 --> 01:22:16,790
and you want to pour them and possibly

01:22:13,730 --> 01:22:21,380
submit them for inclusion that's a kind

01:22:16,790 --> 01:22:23,630
of of a guidelines for doing that so the

01:22:21,380 --> 01:22:25,790
first thing we did was just copy the

01:22:23,630 --> 01:22:28,370
service or driver as it was from SSC

01:22:25,790 --> 01:22:31,280
camera to the video file index to sensor

01:22:28,370 --> 01:22:33,260
driver directory that was a choice that

01:22:31,280 --> 01:22:35,690
allowed us to see the differences

01:22:33,260 --> 01:22:40,190
without having any modification the

01:22:35,690 --> 01:22:42,170
first comment then the first comment

01:22:40,190 --> 01:22:44,090
actually removed all the dependencies

01:22:42,170 --> 01:22:46,100
from SOC camera from the driver and

01:22:44,090 --> 01:22:47,869
that's exactly what we have been talking

01:22:46,100 --> 01:22:50,780
about

01:22:47,869 --> 01:22:52,550
ending clock and GPS and the drivers and

01:22:50,780 --> 01:22:55,310
not relying on the board file for doing

01:22:52,550 --> 01:22:57,619
that register da Singh sub device

01:22:55,310 --> 01:22:58,730
because SOC camera was doing that for

01:22:57,619 --> 01:23:02,179
you and now you should do that

01:22:58,730 --> 01:23:05,300
explicitly in your driver remove SOC

01:23:02,179 --> 01:23:07,869
camera specific deprecated operation

01:23:05,300 --> 01:23:11,179
with the for Linux to this operation are

01:23:07,869 --> 01:23:12,889
know what other placated SOC cameras

01:23:11,179 --> 01:23:15,080
still depends on that and still wants

01:23:12,889 --> 01:23:17,540
them so they had to be removed and we

01:23:15,080 --> 01:23:20,030
implemented in the proper set format and

01:23:17,540 --> 01:23:22,820
get format operation and there were a

01:23:20,030 --> 01:23:24,920
few changes which are specific to this

01:23:22,820 --> 01:23:27,650
driver which are specific to this

01:23:24,920 --> 01:23:30,800
drivers are just here for reference

01:23:27,650 --> 01:23:36,110
of course the build system has to be

01:23:30,800 --> 01:23:39,020
adjusted but that trivial and then after

01:23:36,110 --> 01:23:41,719
a plain video for Linux - driver has

01:23:39,020 --> 01:23:44,900
been made out of the SOC camera

01:23:41,719 --> 01:23:47,119
depending one the fun begins because

01:23:44,900 --> 01:23:48,800
people actually started using that and

01:23:47,119 --> 01:23:51,139
that's exciting because patches that

01:23:48,800 --> 01:23:54,290
start coming so people actually start

01:23:51,139 --> 01:23:57,199
using that and specifically patches have

01:23:54,290 --> 01:23:59,119
been heading components parts of to that

01:23:57,199 --> 01:24:01,040
driver that made the modern with the

01:23:59,119 --> 01:24:04,210
finish driver out of what it was an old

01:24:01,040 --> 01:24:06,650
one so the first thing we saw was

01:24:04,210 --> 01:24:09,469
heading media controller support to this

01:24:06,650 --> 01:24:12,920
driver that means that the driver now

01:24:09,469 --> 01:24:15,409
has a sub device at the sub device in

01:24:12,920 --> 01:24:18,650
you as a sub device in the user space so

01:24:15,409 --> 01:24:20,650
you now need to handle nested set power

01:24:18,650 --> 01:24:24,800
calls that's exactly the thing that

01:24:20,650 --> 01:24:28,159
cache your setting and keep power not a

01:24:24,800 --> 01:24:31,670
power state notation in your driver also

01:24:28,159 --> 01:24:33,800
you should not access registers when the

01:24:31,670 --> 01:24:36,500
sensor is powered down now you can

01:24:33,800 --> 01:24:38,750
receive the gets a controller get

01:24:36,500 --> 01:24:40,310
control from user space while your

01:24:38,750 --> 01:24:42,590
sensor is powered down and you should

01:24:40,310 --> 01:24:46,119
pay attention not accessing the ask or

01:24:42,590 --> 01:24:48,739
see bus why the sensor is powered off

01:24:46,119 --> 01:24:51,050
the worst support for frame interval

01:24:48,739 --> 01:24:53,110
handling this is a kind of a request

01:24:51,050 --> 01:24:55,760
right now if you want to submit them

01:24:53,110 --> 01:24:57,199
beautiful Linux driver frame and lling

01:24:55,760 --> 01:24:59,929
is something at this kind of mandatory

01:24:57,199 --> 01:25:02,260
doing that at least for a few frame

01:24:59,929 --> 01:25:02,260
rates

01:25:02,720 --> 01:25:08,160
that's another things that cause for

01:25:05,160 --> 01:25:11,610
shared state notation so if your driver

01:25:08,160 --> 01:25:13,650
is streaming you should refuse you

01:25:11,610 --> 01:25:16,320
should return ebz or an other error

01:25:13,650 --> 01:25:19,670
flags if you want to set format or

01:25:16,320 --> 01:25:22,470
change the into the frame interval and

01:25:19,670 --> 01:25:24,390
the last change it's the creation of the

01:25:22,470 --> 01:25:25,860
sub device know that goes along with the

01:25:24,390 --> 01:25:29,970
support for the media controller

01:25:25,860 --> 01:25:33,000
operations so I've been probably two

01:25:29,970 --> 01:25:35,010
fasts we have 10 minutes for question I

01:25:33,000 --> 01:25:36,780
hope you'd have some at least because

01:25:35,010 --> 01:25:38,580
otherwise I've been really too fast you

01:25:36,780 --> 01:25:41,070
had a hundred slides so it was worried

01:25:38,580 --> 01:25:42,900
that it was the time was not enough but

01:25:41,070 --> 01:25:45,240
actually I've been probably talking too

01:25:42,900 --> 01:25:48,600
fast if you have any question or

01:25:45,240 --> 01:25:51,330
anything you want to talk about or any

01:25:48,600 --> 01:25:54,600
question about any discussion about how

01:25:51,330 --> 01:25:56,490
things could evolve in not just for SOC

01:25:54,600 --> 01:25:58,530
camera based driver but sensor driver in

01:25:56,490 --> 01:26:01,400
general there are two microphones here

01:25:58,530 --> 01:26:01,400
so please go ahead

01:26:10,729 --> 01:26:15,619
so I'm just wondering when you're

01:26:13,489 --> 01:26:17,449
writing this new code you're adapting it

01:26:15,619 --> 01:26:19,249
what sort of technique to use for

01:26:17,449 --> 01:26:21,139
debugging and working what's going wrong

01:26:19,249 --> 01:26:22,610
because it strikes me this is a more

01:26:21,139 --> 01:26:24,249
complex setup of everything being any

01:26:22,610 --> 01:26:26,809
synchronous and when it's not working

01:26:24,249 --> 01:26:29,690
you might not have much idea as to which

01:26:26,809 --> 01:26:31,729
bit isn't actually hooking up so you get

01:26:29,690 --> 01:26:34,130
hungry and that's the first thing no I

01:26:31,729 --> 01:26:35,989
mean you get disappointed with things

01:26:34,130 --> 01:26:39,229
that's what that's the first debugging

01:26:35,989 --> 01:26:41,239
tool you use usually and what that the

01:26:39,229 --> 01:26:44,030
pentathlon the system that you use but

01:26:41,239 --> 01:26:46,219
things are now a synchronous so having a

01:26:44,030 --> 01:26:50,659
notion again of what is the power state

01:26:46,219 --> 01:26:53,659
that's always useful and talking about

01:26:50,659 --> 01:26:55,190
streaming start and stop that and now

01:26:53,659 --> 01:26:57,229
handle through the media controller

01:26:55,190 --> 01:27:02,559
frameworks so you have a pipeline

01:26:57,229 --> 01:27:02,559
notation the pipeline it's where's that

01:27:04,239 --> 01:27:12,079
that's me it's basically a pipeline all

01:27:08,659 --> 01:27:13,909
the components here are put in a

01:27:12,079 --> 01:27:16,820
pipeline and when you start streaming

01:27:13,909 --> 01:27:19,429
the media controller frameworks goes one

01:27:16,820 --> 01:27:22,400
on the other and coastal start stream on

01:27:19,429 --> 01:27:24,199
all of them so having the begin adding

01:27:22,400 --> 01:27:25,550
the enabling the bug in the media

01:27:24,199 --> 01:27:27,050
controller frameworks help you

01:27:25,550 --> 01:27:30,530
understanding what's going on at each

01:27:27,050 --> 01:27:32,659
step or the capture process but in the

01:27:30,530 --> 01:27:34,519
end you should just know what's

01:27:32,659 --> 01:27:36,050
happening in your sensor driver if you

01:27:34,519 --> 01:27:37,670
have problem streaming the panzram for

01:27:36,050 --> 01:27:40,729
what problem you have you don't receive

01:27:37,670 --> 01:27:43,610
images you receive bear the images you

01:27:40,729 --> 01:27:45,559
are missing a set format call that

01:27:43,610 --> 01:27:47,300
depends from the driver usually and or

01:27:45,559 --> 01:27:49,699
you and what the bug in tools your

01:27:47,300 --> 01:27:51,889
system provide because compared to other

01:27:49,699 --> 01:27:55,190
parts of the system it's art to the bug

01:27:51,889 --> 01:27:56,989
those kind of thing is in jtech because

01:27:55,190 --> 01:27:59,900
what there is a nice person bus in the

01:27:56,989 --> 01:28:02,090
middle so you should the last the resort

01:27:59,900 --> 01:28:04,729
is printing out all the messages you're

01:28:02,090 --> 01:28:06,739
sending on the ice core CMOS printing

01:28:04,729 --> 01:28:08,170
all of them see what's happened go and

01:28:06,739 --> 01:28:11,840
go with the datasheet

01:28:08,170 --> 01:28:15,079
the comparison so there are different

01:28:11,840 --> 01:28:16,639
degrees of complexity you may want to

01:28:15,079 --> 01:28:20,030
handles I don't know if you have a

01:28:16,639 --> 01:28:21,650
specific use case for that or well

01:28:20,030 --> 01:28:23,300
it's not so you give them a so we have

01:28:21,650 --> 01:28:29,800
time for five minutes afterwards -

01:28:23,300 --> 01:28:29,800
that's okay okay thank you thank you

01:28:31,750 --> 01:28:40,180
anyone else okay so thank you more time

01:28:38,389 --> 01:28:47,659
for in for coffee

01:28:40,180 --> 01:28:47,659

YouTube URL: https://www.youtube.com/watch?v=-hmG5An2bN8


