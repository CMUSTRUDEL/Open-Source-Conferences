Title: Device Security in IoT - Ashutosh Singh, Arm Ltd
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Device Security in IoT - Ashutosh Singh, Arm Ltd

Device security is becoming increasingly complex and expensive with exponential growth in connected devices. E.g. Devices must support secure boot to prevent malicious software installation
Communication must be secure and trusted to protect data and infrastructure Compartmentalisation in device software scope limit software vulnerabilities. 

This talk covers security considerations across various scenarios and how they apply to software/hardware specs using "Trusted Firmware for M" as reference.
Introductory level details of the Platform Security Architecture(PSA) are covered as well.
 
Presentation Structure:
Discussion about some of the use-cases and device states and associated security implications
Breaking it down: Common device security principles
Introduction to Trusted Firmware for M and PSA
Hardware and software architecture of a connected device
Questions 

About Ashutosh Singh
Technical Lead for Trusted Firmware M project at Arm, driving software architecture for platform security for embedded devices.

My broader focus involves defining security architecture for high level use-cases such as Digital Rights Management(DRM), Transport Layer Security (TLS) and identifying security features for next generation Arm processors
Captions: 
	00:00:00,120 --> 00:00:05,250
hello everyone my name is ash Tosh and I

00:00:03,870 --> 00:00:07,799
am part of the open source software

00:00:05,250 --> 00:00:09,559
group with naam and today I'm going to

00:00:07,799 --> 00:00:14,750
talk about some basic concepts about

00:00:09,559 --> 00:00:14,750
device security for connected devices

00:00:18,800 --> 00:00:23,760
I'll start with some common use cases

00:00:21,960 --> 00:00:25,740
which are applicable to all of the

00:00:23,760 --> 00:00:29,279
connected devices and the security

00:00:25,740 --> 00:00:31,349
challenges they face some of the basic

00:00:29,279 --> 00:00:34,469
principles security principles which can

00:00:31,349 --> 00:00:37,500
be applied to all the use cases and then

00:00:34,469 --> 00:00:38,879
if you talk about the PS a program the

00:00:37,500 --> 00:00:41,129
platform security architecture firm

00:00:38,879 --> 00:00:43,170
program for Mom and a brief introduction

00:00:41,129 --> 00:00:45,930
to adjust it from there EMM project at

00:00:43,170 --> 00:00:49,340
the end and in the end we'll have some

00:00:45,930 --> 00:00:49,340
time for questions and answers in

00:00:52,730 --> 00:00:57,559
character devices space every device is

00:00:55,559 --> 00:01:00,000
unique and every use case is unique

00:00:57,559 --> 00:01:02,640
however there are some common usage

00:01:00,000 --> 00:01:05,220
patterns if you look deep enough there

00:01:02,640 --> 00:01:09,960
is a underlying theme across all the

00:01:05,220 --> 00:01:11,850
different use cases all the devices they

00:01:09,960 --> 00:01:13,710
need some form of connectivity

00:01:11,850 --> 00:01:15,180
it could be device to device

00:01:13,710 --> 00:01:16,950
communication or it will be

00:01:15,180 --> 00:01:19,470
communication between a device and a

00:01:16,950 --> 00:01:23,430
server or it could be a communication

00:01:19,470 --> 00:01:26,060
between device to a node in the in a

00:01:23,430 --> 00:01:26,060
mesh network

00:01:27,380 --> 00:01:32,189
there is some form of data processing

00:01:29,430 --> 00:01:33,960
involved in all the use cases the data

00:01:32,189 --> 00:01:35,970
could be sensor data being collected on

00:01:33,960 --> 00:01:39,960
a device and securely transmitted to a

00:01:35,970 --> 00:01:41,909
remote entity it could be DRM data if

00:01:39,960 --> 00:01:44,159
you talk about the multimedia content it

00:01:41,909 --> 00:01:48,000
could be biometric data in case of

00:01:44,159 --> 00:01:50,549
medical devices and the usage patterns

00:01:48,000 --> 00:01:52,860
of this data is very complex and the

00:01:50,549 --> 00:01:55,460
ownership of this data becomes extremely

00:01:52,860 --> 00:01:55,460
complex to manage

00:01:56,480 --> 00:02:01,430
device management the devices that gets

00:01:59,660 --> 00:02:04,940
deployed are meant to be in the field

00:02:01,430 --> 00:02:07,160
for many years and the scale of default

00:02:04,940 --> 00:02:10,160
deployment is quite large and it's going

00:02:07,160 --> 00:02:11,900
to be even larger in the future they

00:02:10,160 --> 00:02:15,170
cannot be managed individually and they

00:02:11,900 --> 00:02:17,900
cannot be managed on management basis

00:02:15,170 --> 00:02:21,920
they need to be managed remotely somehow

00:02:17,900 --> 00:02:23,390
and in a more automated fashion when

00:02:21,920 --> 00:02:25,940
this might want to control certain

00:02:23,390 --> 00:02:29,060
features based on a licensing model for

00:02:25,940 --> 00:02:32,360
a particular use case when this might

00:02:29,060 --> 00:02:34,760
want to revoke or invoke certificates on

00:02:32,360 --> 00:02:39,980
a device based on the subscription that

00:02:34,760 --> 00:02:41,720
the user has paid for their before mat

00:02:39,980 --> 00:02:43,010
updates because again devices are going

00:02:41,720 --> 00:02:45,260
to be in the field for a very long time

00:02:43,010 --> 00:02:47,360
there will be security fixes at the

00:02:45,260 --> 00:02:50,330
feature updates and the buff fixes on

00:02:47,360 --> 00:02:52,670
the device and finally the incident

00:02:50,330 --> 00:02:54,380
management there will be security

00:02:52,670 --> 00:02:57,860
incidents there will be cases where

00:02:54,380 --> 00:03:02,360
devices become vulnerable the software

00:02:57,860 --> 00:03:05,450
become broken down by security

00:03:02,360 --> 00:03:09,100
researchers or hackers and they need to

00:03:05,450 --> 00:03:09,100
be fixed by firmware update

00:03:10,000 --> 00:03:14,780
and finally the vendor management the

00:03:12,830 --> 00:03:17,030
ecosystem is going to be very complex

00:03:14,780 --> 00:03:18,770
where different silicon vendors

00:03:17,030 --> 00:03:20,780
different operating system vendors and

00:03:18,770 --> 00:03:22,850
the audience they try to collaborate

00:03:20,780 --> 00:03:24,680
with each other and they would want to

00:03:22,850 --> 00:03:29,270
limit the trust they need to put in each

00:03:24,680 --> 00:03:31,940
other so it's a very complex supply

00:03:29,270 --> 00:03:34,550
chain where we want to make sure that

00:03:31,940 --> 00:03:38,060
the amount of trust each vendor need to

00:03:34,550 --> 00:03:43,910
put in each other has has is contained

00:03:38,060 --> 00:03:46,880
and it's limited and all of these uses

00:03:43,910 --> 00:03:50,150
scenarios have some underlying common

00:03:46,880 --> 00:03:52,370
security challenges all of the

00:03:50,150 --> 00:03:54,560
communicating entities before they start

00:03:52,370 --> 00:03:56,900
any communication they won't want to

00:03:54,560 --> 00:03:59,000
establish a trust they would want to

00:03:56,900 --> 00:04:01,250
make sure that they are talking to the

00:03:59,000 --> 00:04:03,170
right entity on the other end if a

00:04:01,250 --> 00:04:06,500
server is talking to a device there are

00:04:03,170 --> 00:04:09,859
certain to imply trust and that trust

00:04:06,500 --> 00:04:10,599
could mean that the if your end device

00:04:09,859 --> 00:04:12,459
is compromised

00:04:10,599 --> 00:04:14,950
it can compromise the rest of the

00:04:12,459 --> 00:04:17,169
network and once the trust is

00:04:14,950 --> 00:04:19,299
established the communication itself

00:04:17,169 --> 00:04:21,130
need to be secured because the physical

00:04:19,299 --> 00:04:24,430
medium on which they actually

00:04:21,130 --> 00:04:26,410
communicate can be a compromisable

00:04:24,430 --> 00:04:30,460
network it could be a connector which

00:04:26,410 --> 00:04:32,139
itself is not secure we will talk about

00:04:30,460 --> 00:04:34,919
the data management this is probably the

00:04:32,139 --> 00:04:38,139
most complex bit and it has a lot of

00:04:34,919 --> 00:04:39,759
socio-economic issue aspects as well who

00:04:38,139 --> 00:04:42,190
owns the data if you're talking about

00:04:39,759 --> 00:04:44,680
the biometric device if you're talking

00:04:42,190 --> 00:04:47,440
about the DRM license management that's

00:04:44,680 --> 00:04:49,630
even more complex where you would want

00:04:47,440 --> 00:04:51,280
to leave the content or a device for a

00:04:49,630 --> 00:04:53,590
limited period of time and the

00:04:51,280 --> 00:04:55,210
subscription if expires you would want

00:04:53,590 --> 00:04:58,150
to be able to show that the content

00:04:55,210 --> 00:05:04,000
cannot be used or reused or reused or

00:04:58,150 --> 00:05:06,699
misused beyond the given time similarly

00:05:04,000 --> 00:05:08,560
for device poisoning since there there

00:05:06,699 --> 00:05:11,349
are monetary aspects attached to the

00:05:08,560 --> 00:05:14,410
device provisioning feature enabled

00:05:11,349 --> 00:05:16,539
invent and disable meant we would want

00:05:14,410 --> 00:05:19,990
to make it secure so that the

00:05:16,539 --> 00:05:22,870
subscription model and the money-making

00:05:19,990 --> 00:05:27,000
model to people make are supported by

00:05:22,870 --> 00:05:29,590
the underlying security basics and

00:05:27,000 --> 00:05:33,310
finally the vendor management and the

00:05:29,590 --> 00:05:35,080
forward updates I think it is quite

00:05:33,310 --> 00:05:37,270
evident that the managing different

00:05:35,080 --> 00:05:41,289
vendors and the mutual trust is a very

00:05:37,270 --> 00:05:42,550
complex scenario and then when you talk

00:05:41,289 --> 00:05:45,250
about the form where it base they're

00:05:42,550 --> 00:05:46,210
even more complex because the software

00:05:45,250 --> 00:05:48,849
could be coming from many different

00:05:46,210 --> 00:05:50,800
places the secure side software where

00:05:48,849 --> 00:05:52,389
there could be another entity they see

00:05:50,800 --> 00:05:54,130
at the non secure side and the business

00:05:52,389 --> 00:05:57,400
case when there could be another entity

00:05:54,130 --> 00:05:59,830
and you may want to install applications

00:05:57,400 --> 00:06:01,000
coming from multiple other partners and

00:05:59,830 --> 00:06:09,550
they wouldn't want to trust each other

00:06:01,000 --> 00:06:12,400
to address all these different security

00:06:09,550 --> 00:06:15,219
scenarios and different use cases there

00:06:12,400 --> 00:06:18,039
are some underlying basic principles

00:06:15,219 --> 00:06:22,539
underlying building blocks which can be

00:06:18,039 --> 00:06:24,460
applied to all of the use cases and well

00:06:22,539 --> 00:06:26,590
this is not exhaustive list this

00:06:24,460 --> 00:06:30,100
destroys the initial building blocks

00:06:26,590 --> 00:06:35,500
that you need to have to secure a end

00:06:30,100 --> 00:06:36,250
device in a connected mesh immutable

00:06:35,500 --> 00:06:38,590
route of trust

00:06:36,250 --> 00:06:41,980
this is the absolutely trusted part of

00:06:38,590 --> 00:06:43,480
your device and when you could even when

00:06:41,980 --> 00:06:46,900
someone creates a threat model for their

00:06:43,480 --> 00:06:48,430
use case this need to be ensure that the

00:06:46,900 --> 00:06:51,190
initial part of the system need to be

00:06:48,430 --> 00:06:54,010
ensured to be non mutable and if the

00:06:51,190 --> 00:06:57,460
initial part is compromised all bets are

00:06:54,010 --> 00:06:59,950
off so for any use case you need to have

00:06:57,460 --> 00:07:04,540
the absolute start point for your trust

00:06:59,950 --> 00:07:06,930
in the doors itself that leads to the

00:07:04,540 --> 00:07:10,450
chain of trust and software integrity

00:07:06,930 --> 00:07:12,700
the different links in the chain need to

00:07:10,450 --> 00:07:14,260
validate the next link in the in the in

00:07:12,700 --> 00:07:16,420
the in the chain and make sure that the

00:07:14,260 --> 00:07:18,790
next entity is certified and is

00:07:16,420 --> 00:07:21,790
validated and it's not compromised and

00:07:18,790 --> 00:07:23,350
by creating this chain we ensure that

00:07:21,790 --> 00:07:25,690
the all of the all of the software that

00:07:23,350 --> 00:07:32,200
is running on a device is not

00:07:25,690 --> 00:07:34,620
compromised hardware and software will

00:07:32,200 --> 00:07:36,850
have bugs they will have issues and

00:07:34,620 --> 00:07:39,340
since the devices are going to be in the

00:07:36,850 --> 00:07:41,650
field for a very long time we would want

00:07:39,340 --> 00:07:43,480
to contain the scope of every one

00:07:41,650 --> 00:07:48,100
ability that get six tickets exposed

00:07:43,480 --> 00:07:49,720
be the hardware or the software so the

00:07:48,100 --> 00:07:51,580
principle of least privilege means that

00:07:49,720 --> 00:07:54,130
your system should be divided in the

00:07:51,580 --> 00:07:58,420
smallest possible pieces which do not

00:07:54,130 --> 00:07:59,890
really trust each other so your

00:07:58,420 --> 00:08:02,770
application should be should be should

00:07:59,890 --> 00:08:04,480
be given just enough privilege so that

00:08:02,770 --> 00:08:06,490
they can function and nothing else

00:08:04,480 --> 00:08:11,890
and the same principle applies to the

00:08:06,490 --> 00:08:13,840
rest of the system as well the software

00:08:11,890 --> 00:08:17,050
should be updatable so if it device is

00:08:13,840 --> 00:08:19,540
deployed we will want to make sure that

00:08:17,050 --> 00:08:22,120
any vulnerability that it caters gets

00:08:19,540 --> 00:08:23,890
exposed in the future in the hardware or

00:08:22,120 --> 00:08:28,750
the software can be mitigated by

00:08:23,890 --> 00:08:30,400
providing a software update device

00:08:28,750 --> 00:08:33,520
identification and authentication this

00:08:30,400 --> 00:08:35,470
is interesting because the when you talk

00:08:33,520 --> 00:08:36,729
about the secure communication it is not

00:08:35,470 --> 00:08:38,169
only

00:08:36,729 --> 00:08:40,089
it's not sufficient to establish a

00:08:38,169 --> 00:08:42,310
secure link between two devices or two

00:08:40,089 --> 00:08:44,290
entities it's also important to make

00:08:42,310 --> 00:08:46,779
sure that they recognizing each other

00:08:44,290 --> 00:08:49,810
for which you need to have a very unique

00:08:46,779 --> 00:08:52,449
identifier which ties a device the

00:08:49,810 --> 00:08:56,170
secure communication to a to a unique

00:08:52,449 --> 00:09:01,420
device so the server or the receiving

00:08:56,170 --> 00:09:03,160
side on the on your IT device they can

00:09:01,420 --> 00:09:05,820
authenticate each other and they can

00:09:03,160 --> 00:09:05,820
trust each other

00:09:05,970 --> 00:09:12,010
finally lifecycle management when we

00:09:09,699 --> 00:09:13,449
talk about a device manufacturing

00:09:12,010 --> 00:09:15,670
process there are multiple vendors

00:09:13,449 --> 00:09:18,699
involved the silicon could be given by

00:09:15,670 --> 00:09:20,079
one partner while the OEM could be

00:09:18,699 --> 00:09:22,209
putting the whole system around the

00:09:20,079 --> 00:09:25,690
silicon while the software could be

00:09:22,209 --> 00:09:27,279
coming from so many different places to

00:09:25,690 --> 00:09:30,550
be able to secure the supply chain and

00:09:27,279 --> 00:09:32,649
the different stages of the supply chain

00:09:30,550 --> 00:09:34,480
is important important to

00:09:32,649 --> 00:09:36,790
compartmentalize that aspect as well

00:09:34,480 --> 00:09:38,920
it's important to limit the resources

00:09:36,790 --> 00:09:40,600
hardware and software resources which

00:09:38,920 --> 00:09:45,269
are visible in the different parts of

00:09:40,600 --> 00:09:45,269
your the product life cycle development

00:09:46,500 --> 00:09:51,930
let's look at these different building

00:09:48,970 --> 00:09:55,540
blocks in a bit more detail one by one

00:09:51,930 --> 00:09:57,220
guru frost and the chain of trust rue de

00:09:55,540 --> 00:10:01,839
France in Jerez you usually go together

00:09:57,220 --> 00:10:05,139
they they need they they kind of that

00:10:01,839 --> 00:10:06,850
they go together most of our time the

00:10:05,139 --> 00:10:09,670
root of truss need to be implemented in

00:10:06,850 --> 00:10:11,079
the RTL itself so to be able to

00:10:09,670 --> 00:10:14,079
compromise the device you need to be

00:10:11,079 --> 00:10:17,130
able to compromise the RTL and which is

00:10:14,079 --> 00:10:20,399
normally quite difficult and involves

00:10:17,130 --> 00:10:26,170
hardware level and very deeply embedded

00:10:20,399 --> 00:10:28,899
attack the immutable immutable root of

00:10:26,170 --> 00:10:32,970
truss is responsible for initiating the

00:10:28,899 --> 00:10:35,560
root of trust so it is responsible for

00:10:32,970 --> 00:10:37,060
authenticating the nest next set of the

00:10:35,560 --> 00:10:39,250
software which is going to run on device

00:10:37,060 --> 00:10:43,480
and it should be able to do it securely

00:10:39,250 --> 00:10:44,850
and that security is or rather that

00:10:43,480 --> 00:10:48,459
guarantee is provided by the

00:10:44,850 --> 00:10:49,580
cryptography so the next stage of the

00:10:48,459 --> 00:10:51,340
software

00:10:49,580 --> 00:10:55,010
be signed by the public key of the

00:10:51,340 --> 00:10:56,810
software vendor and the device should be

00:10:55,010 --> 00:10:59,240
able to authenticate the software which

00:10:56,810 --> 00:11:04,240
is running on the device by checking the

00:10:59,240 --> 00:11:07,280
signature of the binary this the

00:11:04,240 --> 00:11:09,890
immutable root of trust is also the very

00:11:07,280 --> 00:11:11,750
first empty point in the system so it

00:11:09,890 --> 00:11:13,820
also needs to assist in the factory

00:11:11,750 --> 00:11:17,660
floor floor provisioning when the device

00:11:13,820 --> 00:11:19,460
is is coming out of the fabrication you

00:11:17,660 --> 00:11:20,720
need to provision keys you need to

00:11:19,460 --> 00:11:23,780
provision the software you need to

00:11:20,720 --> 00:11:25,880
provision the hardware keys come from

00:11:23,780 --> 00:11:30,050
different vendors and that part also

00:11:25,880 --> 00:11:32,240
might require some level of guarantee so

00:11:30,050 --> 00:11:34,790
the the whole process of provisioning

00:11:32,240 --> 00:11:38,300
itself is not compromised on the factory

00:11:34,790 --> 00:11:41,270
floor and the initial route of trust may

00:11:38,300 --> 00:11:45,230
be required to assist in the initial

00:11:41,270 --> 00:11:47,510
factory provisioning then the next stage

00:11:45,230 --> 00:11:50,030
which is again the next stages is a

00:11:47,510 --> 00:11:52,670
logical step when you talk about the

00:11:50,030 --> 00:11:55,520
updatable bootloader this is a logical

00:11:52,670 --> 00:11:57,140
separation in some of the use cases the

00:11:55,520 --> 00:11:59,600
next stage could be clubbed in the

00:11:57,140 --> 00:12:03,790
immutable root of trust or it could be

00:11:59,600 --> 00:12:03,790
clubbed with the runtime software so

00:12:04,690 --> 00:12:10,100
this block is essentially in some of

00:12:08,480 --> 00:12:14,110
these very simple use cases can be

00:12:10,100 --> 00:12:17,690
clubbed with the immutable root of trust

00:12:14,110 --> 00:12:20,900
because for simple use cases you may not

00:12:17,690 --> 00:12:23,180
want to spend the additional Ram ROM and

00:12:20,900 --> 00:12:26,390
the hardware requirements that come with

00:12:23,180 --> 00:12:30,800
the actual physical separation of the

00:12:26,390 --> 00:12:33,110
different stages of boot so when you

00:12:30,800 --> 00:12:35,330
talk about the updatable boot order you

00:12:33,110 --> 00:12:38,240
should be able to authenticate the the

00:12:35,330 --> 00:12:41,270
final the business case software which

00:12:38,240 --> 00:12:42,740
is going to run on the device it also

00:12:41,270 --> 00:12:45,680
need to participate in the forum where

00:12:42,740 --> 00:12:48,020
update process I'll try to cover the

00:12:45,680 --> 00:12:49,280
firmware update or a example from where

00:12:48,020 --> 00:12:51,500
update process in one of the later

00:12:49,280 --> 00:12:54,730
slides it will become slightly clearer

00:12:51,500 --> 00:12:58,130
why bootloader gets involved in stage

00:12:54,730 --> 00:12:59,450
finally the runtime software the runtime

00:12:58,130 --> 00:13:02,750
software is where you implement your

00:12:59,450 --> 00:13:06,940
business use case your actual of

00:13:02,750 --> 00:13:11,029
use case which is very divisive specific

00:13:06,940 --> 00:13:13,970
it also need to support the firmware

00:13:11,029 --> 00:13:15,740
update process and provide the final use

00:13:13,970 --> 00:13:23,120
case level compartmentalization of the

00:13:15,740 --> 00:13:26,810
system the next building block place

00:13:23,120 --> 00:13:28,880
will of least privilege this is not

00:13:26,810 --> 00:13:30,490
limited the compartmentalization is not

00:13:28,880 --> 00:13:33,589
limited to just hardware or the software

00:13:30,490 --> 00:13:37,519
this is a general principle that one

00:13:33,589 --> 00:13:39,769
should follow throughout the product

00:13:37,519 --> 00:13:41,480
development lifecycle and see if there

00:13:39,769 --> 00:13:44,260
are two aspects of the system which can

00:13:41,480 --> 00:13:46,839
be compartmentalized so that they do not

00:13:44,260 --> 00:13:51,050
compromise each other or cannot

00:13:46,839 --> 00:13:53,000
interfere with each other how do the

00:13:51,050 --> 00:13:55,610
software compartmentalization is a key

00:13:53,000 --> 00:13:57,949
aspect of it because that's where most

00:13:55,610 --> 00:14:01,269
of the complexities of the system are

00:13:57,949 --> 00:14:03,440
going to lie the compartment

00:14:01,269 --> 00:14:05,600
compartmentalization all supplies the

00:14:03,440 --> 00:14:09,860
cryptographic keys especially the

00:14:05,600 --> 00:14:11,949
hardware keys where if the same key is

00:14:09,860 --> 00:14:14,060
used for deriving multiple different

00:14:11,949 --> 00:14:17,060
cryptographic keys for different use

00:14:14,060 --> 00:14:18,890
cases one would want to make sure that

00:14:17,060 --> 00:14:21,649
the key derivation tree is very clean

00:14:18,890 --> 00:14:26,320
and the key hierarchy is set up in a way

00:14:21,649 --> 00:14:30,440
that no one can make their way back into

00:14:26,320 --> 00:14:32,649
deriving a key for a different use case

00:14:30,440 --> 00:14:38,540
[Music]

00:14:32,649 --> 00:14:40,970
if you look at this block diagram in

00:14:38,540 --> 00:14:44,630
this this is the conventional system

00:14:40,970 --> 00:14:46,250
that most of us are familiar with where

00:14:44,630 --> 00:14:50,870
you would have some sort of OS kernel

00:14:46,250 --> 00:14:52,880
scheduler privileged code handler which

00:14:50,870 --> 00:14:55,760
will run on the on the at the hardware

00:14:52,880 --> 00:14:58,910
level it will have provide certain OS

00:14:55,760 --> 00:15:00,649
features and on top of it all you would

00:14:58,910 --> 00:15:02,060
have the application firmware and

00:15:00,649 --> 00:15:07,639
there's the convention of the system

00:15:02,060 --> 00:15:09,230
that here we are used to see now in the

00:15:07,639 --> 00:15:10,790
conventional systems is possible that

00:15:09,230 --> 00:15:13,310
you have a lot of security aware

00:15:10,790 --> 00:15:15,290
software as well either in this part or

00:15:13,310 --> 00:15:16,850
Neen in the US part

00:15:15,290 --> 00:15:18,500
and the more complex the the application

00:15:16,850 --> 00:15:22,370
software becomes the more complicated

00:15:18,500 --> 00:15:24,579
complicated the OS kernel becomes it

00:15:22,370 --> 00:15:29,870
becomes harder to contain the security

00:15:24,579 --> 00:15:31,759
vulnerabilities so what this means we

00:15:29,870 --> 00:15:34,759
should separate this security aware

00:15:31,759 --> 00:15:37,759
aspects of the system and put it on a

00:15:34,759 --> 00:15:40,970
different sandbox which is what this

00:15:37,759 --> 00:15:44,300
sandbox provides that you separate the

00:15:40,970 --> 00:15:46,610
system in a business case the business

00:15:44,300 --> 00:15:50,360
use case is specific software and all of

00:15:46,610 --> 00:15:51,829
the security aware software can be

00:15:50,360 --> 00:15:55,279
implemented and handled on the

00:15:51,829 --> 00:15:58,370
right-hand side of this picture and this

00:15:55,279 --> 00:16:02,240
boundary should be enforced by the

00:15:58,370 --> 00:16:04,610
hardware itself now once this separation

00:16:02,240 --> 00:16:06,769
is done there are different scenarios

00:16:04,610 --> 00:16:09,670
where this secure side software itself

00:16:06,769 --> 00:16:12,529
could be coming from different vendors

00:16:09,670 --> 00:16:14,990
there could be certain very use cases

00:16:12,529 --> 00:16:17,930
specific for example DRM they are if you

00:16:14,990 --> 00:16:20,060
talk about the DRV use case that and if

00:16:17,930 --> 00:16:22,579
we talk about multiple vendors for DRM

00:16:20,060 --> 00:16:24,620
use cases they would have some level of

00:16:22,579 --> 00:16:26,630
functionality on the secure world some

00:16:24,620 --> 00:16:28,490
level of function I'll be here and if

00:16:26,630 --> 00:16:29,779
their different vendors again they would

00:16:28,490 --> 00:16:31,130
not want to trust each other

00:16:29,779 --> 00:16:35,839
they would want to have some level of

00:16:31,130 --> 00:16:39,079
guarantee that a vendor content provided

00:16:35,839 --> 00:16:42,350
a is not able to see the certificates

00:16:39,079 --> 00:16:44,709
and keys of the content provider B for

00:16:42,350 --> 00:16:46,579
that reason there is a need to have

00:16:44,709 --> 00:16:50,000
compartmentalization on the secure side

00:16:46,579 --> 00:16:52,730
as well which is what this block these

00:16:50,000 --> 00:16:55,850
green boxes represent that you need to

00:16:52,730 --> 00:16:57,889
have the boundary between the non secure

00:16:55,850 --> 00:17:00,470
side software and the secure side

00:16:57,889 --> 00:17:03,319
software but secure side software itself

00:17:00,470 --> 00:17:07,400
need to have a compartmentalization to

00:17:03,319 --> 00:17:08,959
be able to ensure that different vendors

00:17:07,400 --> 00:17:11,030
can implement their software without

00:17:08,959 --> 00:17:15,010
worrying about someone stealing their

00:17:11,030 --> 00:17:15,010
data or the software IP

00:17:17,500 --> 00:17:23,230
firmware update I already mentioned that

00:17:21,089 --> 00:17:25,569
hardware and software will have our

00:17:23,230 --> 00:17:27,189
abilities the devices are going to be

00:17:25,569 --> 00:17:30,250
deployed for a very long time and

00:17:27,189 --> 00:17:32,590
someone will break them and we need to

00:17:30,250 --> 00:17:35,200
be able to react to that in some cases

00:17:32,590 --> 00:17:39,460
and in some cases proactively identify

00:17:35,200 --> 00:17:41,830
issues and go and fix them and once the

00:17:39,460 --> 00:17:44,019
issues are identified and fixed we need

00:17:41,830 --> 00:17:46,059
to have a secure mechanism to provide

00:17:44,019 --> 00:17:48,399
those updates to millions of millions or

00:17:46,059 --> 00:17:53,039
billions of devices which are in the

00:17:48,399 --> 00:17:58,419
field so the devices should have a

00:17:53,039 --> 00:18:00,009
automated way of being updated and when

00:17:58,419 --> 00:18:01,840
you talk about the firmware update this

00:18:00,009 --> 00:18:04,029
again becomes very complex when you talk

00:18:01,840 --> 00:18:05,649
about the multi vendor scenarios the

00:18:04,029 --> 00:18:06,490
secure side software could be coming

00:18:05,649 --> 00:18:07,899
from one place

00:18:06,490 --> 00:18:09,909
the non secure side software could be

00:18:07,899 --> 00:18:13,179
coming from a different place and the

00:18:09,909 --> 00:18:16,570
device should be able to securely get

00:18:13,179 --> 00:18:19,259
the uplands we get the firmware from

00:18:16,570 --> 00:18:21,519
different vendors be able to

00:18:19,259 --> 00:18:23,250
compartmentalize them be able to

00:18:21,519 --> 00:18:27,269
assemble them together without

00:18:23,250 --> 00:18:31,000
compromising the originally intended

00:18:27,269 --> 00:18:33,820
separation of logic with different

00:18:31,000 --> 00:18:38,440
entities so this is a sample this is an

00:18:33,820 --> 00:18:40,419
example implementation of how the secure

00:18:38,440 --> 00:18:43,299
firmware update can be performed on a

00:18:40,419 --> 00:18:45,370
device you have the separation between

00:18:43,299 --> 00:18:47,110
secured one in one secure world the

00:18:45,370 --> 00:18:49,149
update client on the north secure side

00:18:47,110 --> 00:18:54,039
would download the binary from the

00:18:49,149 --> 00:18:56,049
server or another connected device it

00:18:54,039 --> 00:18:58,779
will talk to its peer in the secure

00:18:56,049 --> 00:19:01,029
world and ask to it to authenticate the

00:18:58,779 --> 00:19:02,769
downloaded binary and once the

00:19:01,029 --> 00:19:04,659
authentication is has passed

00:19:02,769 --> 00:19:08,049
the boundary will be dumped into the

00:19:04,659 --> 00:19:10,059
flash and after which device would be

00:19:08,049 --> 00:19:11,470
reset the boot order comes up and it

00:19:10,059 --> 00:19:13,480
sees that there's a new binary in the

00:19:11,470 --> 00:19:15,639
system and it need to perform some

00:19:13,480 --> 00:19:19,059
checks some cryptographic checks to make

00:19:15,639 --> 00:19:21,809
sure that the image is not a tampered

00:19:19,059 --> 00:19:24,519
image or there's no it's not a rollback

00:19:21,809 --> 00:19:26,759
attack it's not some old binary which is

00:19:24,519 --> 00:19:29,049
being provided again on the device and

00:19:26,759 --> 00:19:30,310
all those actions can be performed by

00:19:29,049 --> 00:19:38,260
the bootloader

00:19:30,310 --> 00:19:41,410
to secure the whole process device

00:19:38,260 --> 00:19:42,850
identification and authentication I've

00:19:41,410 --> 00:19:46,210
already talked about the immutable

00:19:42,850 --> 00:19:48,310
unique identity it is important to have

00:19:46,210 --> 00:19:51,730
a developer device identity which cannot

00:19:48,310 --> 00:19:53,890
be spoofed which cannot be tampered with

00:19:51,730 --> 00:19:56,260
to ensure that the communicating

00:19:53,890 --> 00:20:00,790
entities are able to absolutely trust

00:19:56,260 --> 00:20:02,890
each other and the communication again

00:20:00,790 --> 00:20:05,560
need to be secured between the

00:20:02,890 --> 00:20:08,320
communicating entities but before the

00:20:05,560 --> 00:20:10,030
communication could start the the trust

00:20:08,320 --> 00:20:14,320
establishment can be run through

00:20:10,030 --> 00:20:17,800
cryptographic certificates having said

00:20:14,320 --> 00:20:20,230
that it's not as simple as that in very

00:20:17,800 --> 00:20:22,750
simple devices you wouldn't want to put

00:20:20,230 --> 00:20:24,520
a very complex certificate parsing

00:20:22,750 --> 00:20:26,410
software for example if you are talking

00:20:24,520 --> 00:20:28,150
about lightbulb I wouldn't want to

00:20:26,410 --> 00:20:31,480
implement a lot of software logic or

00:20:28,150 --> 00:20:34,440
hardware logic to be able to perform RSS

00:20:31,480 --> 00:20:37,750
English teacher or ECDSA signature check

00:20:34,440 --> 00:20:39,520
in those cases we need to find a

00:20:37,750 --> 00:20:41,710
different approach and in some cases

00:20:39,520 --> 00:20:43,900
it's okay to have a shared secret

00:20:41,710 --> 00:20:45,340
between your light bulb and the router

00:20:43,900 --> 00:20:48,850
that you have you may have installed on

00:20:45,340 --> 00:20:50,730
your on your in your home and if they

00:20:48,850 --> 00:20:54,340
have a pre-programmed provision

00:20:50,730 --> 00:20:57,040
symmetric symmetric key they could use

00:20:54,340 --> 00:21:00,370
that symmetric key for establishing the

00:20:57,040 --> 00:21:02,680
trust with each other finally the device

00:21:00,370 --> 00:21:06,390
attestation attestation

00:21:02,680 --> 00:21:09,340
is a concept which is quite heavily

00:21:06,390 --> 00:21:12,430
being standardized in the industry right

00:21:09,340 --> 00:21:14,200
now what this means is this is a health

00:21:12,430 --> 00:21:17,710
report or it's a report card of the

00:21:14,200 --> 00:21:20,590
device that gets sent to the remote

00:21:17,710 --> 00:21:23,440
entity the remote entity being a cloud

00:21:20,590 --> 00:21:25,360
entity the report contains the

00:21:23,440 --> 00:21:30,160
information such as what is the boot

00:21:25,360 --> 00:21:32,230
signature what was the hash of the hash

00:21:30,160 --> 00:21:34,870
of the image which is running on the

00:21:32,230 --> 00:21:37,090
device was this physical location was it

00:21:34,870 --> 00:21:38,980
identity and based on the report that

00:21:37,090 --> 00:21:41,530
gets sent by the device to the server

00:21:38,980 --> 00:21:44,080
the server can decide whether it should

00:21:41,530 --> 00:21:47,640
it should trust the device or should

00:21:44,080 --> 00:21:49,690
allow it certain features or should it

00:21:47,640 --> 00:21:51,429
completely block this because the

00:21:49,690 --> 00:21:57,820
software version that it has has

00:21:51,429 --> 00:22:00,130
vulnerabilities for the lifecycle

00:21:57,820 --> 00:22:02,980
management is trying to focus on the

00:22:00,130 --> 00:22:05,500
solution I am trying to highlight some

00:22:02,980 --> 00:22:07,840
of the problems because it's a very

00:22:05,500 --> 00:22:12,490
complex topic and I will not be able to

00:22:07,840 --> 00:22:13,960
talk about this in given time the when

00:22:12,490 --> 00:22:17,519
you talk about the lifecycle management

00:22:13,960 --> 00:22:19,779
the first stage is silicon manufacturer

00:22:17,519 --> 00:22:22,389
silicon manufacturer need to be able to

00:22:19,779 --> 00:22:24,460
secure the device provisioning need to

00:22:22,389 --> 00:22:28,120
make sure that on the factory floor

00:22:24,460 --> 00:22:30,340
when these the keys are being programmed

00:22:28,120 --> 00:22:32,409
or the identities of the device are

00:22:30,340 --> 00:22:34,990
being programmed the whole process is

00:22:32,409 --> 00:22:40,600
secure and is guaranteed to work in a

00:22:34,990 --> 00:22:43,090
certain way and the manual the human

00:22:40,600 --> 00:22:47,080
interaction in the whole process doesn't

00:22:43,090 --> 00:22:49,299
affect the guarantee that the system is

00:22:47,080 --> 00:22:53,200
going to provide in the later phase of

00:22:49,299 --> 00:22:54,760
the life cycle also the silicon vendor

00:22:53,200 --> 00:22:57,700
might want to follow certain licensing

00:22:54,760 --> 00:22:59,169
model what that means is they would they

00:22:57,700 --> 00:23:02,049
might want to create a single device

00:22:59,169 --> 00:23:05,169
with multiple peripherals or multiple

00:23:02,049 --> 00:23:09,070
features but based on the subscription

00:23:05,169 --> 00:23:12,039
model the OEM has paid for they may want

00:23:09,070 --> 00:23:14,110
to limit the features and the they might

00:23:12,039 --> 00:23:16,870
not limit the features and may want

00:23:14,110 --> 00:23:20,740
absolute guarantee that those features

00:23:16,870 --> 00:23:24,210
cannot be hacked or they cannot be

00:23:20,740 --> 00:23:28,000
maliciously enabled or disabled

00:23:24,210 --> 00:23:31,389
similarly when it comes to OS vendor or

00:23:28,000 --> 00:23:33,399
the OEM they were there that there is

00:23:31,389 --> 00:23:34,899
need to have a central entity which will

00:23:33,399 --> 00:23:36,370
integrate all the software coming from

00:23:34,899 --> 00:23:39,279
different places make sure that they all

00:23:36,370 --> 00:23:43,149
work together at the same time ensuring

00:23:39,279 --> 00:23:45,600
that the the different vendors do not

00:23:43,149 --> 00:23:50,409
end up compromising each other's

00:23:45,600 --> 00:23:52,860
software or IP so the harder IP finally

00:23:50,409 --> 00:23:55,450
when the device is deployed the

00:23:52,860 --> 00:23:56,950
complexity there is how

00:23:55,450 --> 00:24:00,159
you manage different fragments coming

00:23:56,950 --> 00:24:02,470
from different devices how do you and if

00:24:00,159 --> 00:24:06,760
a device is compromised

00:24:02,470 --> 00:24:08,080
beyond the repairable state then how do

00:24:06,760 --> 00:24:12,130
we make sure that the device is not

00:24:08,080 --> 00:24:15,580
usable anymore this is a very small

00:24:12,130 --> 00:24:17,980
snippet of the lifecycle management

00:24:15,580 --> 00:24:22,000
problem and that's where I would leave

00:24:17,980 --> 00:24:24,100
the lifecycle management to support

00:24:22,000 --> 00:24:26,700
these are different building blocks for

00:24:24,100 --> 00:24:28,960
security there is a need to have

00:24:26,700 --> 00:24:31,389
Hardware building blocks which can

00:24:28,960 --> 00:24:35,169
support these different security

00:24:31,389 --> 00:24:38,500
functionalities and some of this is not

00:24:35,169 --> 00:24:41,320
again exhaustive list but just a quick

00:24:38,500 --> 00:24:45,039
look at the various solutions that most

00:24:41,320 --> 00:24:46,360
of devices would need to have immutable

00:24:45,039 --> 00:24:46,720
route of trust we already talked about

00:24:46,360 --> 00:24:49,059
that

00:24:46,720 --> 00:24:51,720
this is going to be mostly the RTL code

00:24:49,059 --> 00:24:55,419
the ROM code that people put in devices

00:24:51,720 --> 00:25:01,419
having said that if for a certain use

00:24:55,419 --> 00:25:04,570
case the the physical guarantees are

00:25:01,419 --> 00:25:08,549
made about the silicon itself and the

00:25:04,570 --> 00:25:11,019
there are certain threat vectors the

00:25:08,549 --> 00:25:13,389
final use case owner doesn't want to

00:25:11,019 --> 00:25:15,700
worry about what doesn't care about then

00:25:13,389 --> 00:25:17,440
the immutable immutable root of trust

00:25:15,700 --> 00:25:19,990
can be a programmable entity

00:25:17,440 --> 00:25:22,269
you could have otps in the systems that

00:25:19,990 --> 00:25:25,350
can be programmed as the provisioning

00:25:22,269 --> 00:25:30,490
time and that becomes the programmed

00:25:25,350 --> 00:25:34,299
immutable root of trust the harder

00:25:30,490 --> 00:25:36,730
unique key this allows binding the

00:25:34,299 --> 00:25:39,429
filesystem on a device to a specific

00:25:36,730 --> 00:25:41,620
device and whatever you store on a

00:25:39,429 --> 00:25:43,419
device so make by making sure the hard

00:25:41,620 --> 00:25:47,529
way by making sure that there is a

00:25:43,419 --> 00:25:49,840
unique key program on the hardware you

00:25:47,529 --> 00:25:53,169
ensure that all the file systems that

00:25:49,840 --> 00:25:56,289
are there on the device are tied to that

00:25:53,169 --> 00:25:58,480
device so if someone tries to pluck out

00:25:56,289 --> 00:26:00,370
the file system and the storage system

00:25:58,480 --> 00:26:02,649
from the from the device and tries to

00:26:00,370 --> 00:26:04,210
play it back on a different device it

00:26:02,649 --> 00:26:06,519
would fail because the file system would

00:26:04,210 --> 00:26:08,620
have been encrypted by the hardware

00:26:06,519 --> 00:26:08,980
unique key which is going to be

00:26:08,620 --> 00:26:12,720
different

00:26:08,980 --> 00:26:15,460
or different samples of the same device

00:26:12,720 --> 00:26:15,790
device identity we talked about that as

00:26:15,460 --> 00:26:19,450
well

00:26:15,790 --> 00:26:21,790
this is important to have in a system to

00:26:19,450 --> 00:26:25,410
make sure that the communicating

00:26:21,790 --> 00:26:28,480
entities can identify each other

00:26:25,410 --> 00:26:30,490
non-volatile counters they they are

00:26:28,480 --> 00:26:34,540
required to make sure that when a device

00:26:30,490 --> 00:26:36,669
is exposed to rollback attacks then

00:26:34,540 --> 00:26:40,330
using these counters you can verify if

00:26:36,669 --> 00:26:42,549
the new image or the file system content

00:26:40,330 --> 00:26:46,480
so new image coming from the server or

00:26:42,549 --> 00:26:49,510
new image coming from the external

00:26:46,480 --> 00:26:53,169
storage or the contents of the file

00:26:49,510 --> 00:26:56,620
system are not content from a previous

00:26:53,169 --> 00:26:58,059
iteration which may have expired

00:26:56,620 --> 00:27:01,440
certificates in case of the file system

00:26:58,059 --> 00:27:04,299
or in case of binary might have

00:27:01,440 --> 00:27:06,070
vulnerabilities so non-volatile counters

00:27:04,299 --> 00:27:09,070
are required on the system to ensure

00:27:06,070 --> 00:27:13,210
that these rollbacks attacks cannot be

00:27:09,070 --> 00:27:15,640
performed then comes the hardware

00:27:13,210 --> 00:27:17,040
isolation support we talked about the

00:27:15,640 --> 00:27:19,330
software and hardware

00:27:17,040 --> 00:27:21,160
compartmentalization but to be able to

00:27:19,330 --> 00:27:23,380
support that on a system need to have

00:27:21,160 --> 00:27:26,320
support on a device itself on the

00:27:23,380 --> 00:27:31,450
hardware itself to facilitate the

00:27:26,320 --> 00:27:34,090
compartmentalization root of Russkies on

00:27:31,450 --> 00:27:35,890
a device would ensure that a different

00:27:34,090 --> 00:27:38,080
players on the in the in a multi vendor

00:27:35,890 --> 00:27:40,510
scenarios can control the error sets

00:27:38,080 --> 00:27:43,000
separately for example a silicon vendor

00:27:40,510 --> 00:27:45,490
can use the root of trust their D root

00:27:43,000 --> 00:27:49,750
of Russkies to enable disable their

00:27:45,490 --> 00:27:53,220
features the OEM can have their own root

00:27:49,750 --> 00:27:57,910
of trust to enable disable their own

00:27:53,220 --> 00:27:59,679
content management policy crypto

00:27:57,910 --> 00:28:02,380
accelerator while this is not a

00:27:59,679 --> 00:28:05,790
mandatory requirement on a system you

00:28:02,380 --> 00:28:08,200
could perform cryptography in software

00:28:05,790 --> 00:28:10,929
but a lot of times it's better to have

00:28:08,200 --> 00:28:13,390
the cryptography in the hardware and not

00:28:10,929 --> 00:28:16,210
allow the software to see the hardware

00:28:13,390 --> 00:28:17,980
keys and instead allow the cryptographic

00:28:16,210 --> 00:28:21,260
accelerator to make use of these

00:28:17,980 --> 00:28:23,660
Hardware keys so that way if the

00:28:21,260 --> 00:28:25,820
a compromise in there in the software

00:28:23,660 --> 00:28:28,610
the compromise doesn't affect the

00:28:25,820 --> 00:28:31,010
originally provisioned hardware keys it

00:28:28,610 --> 00:28:33,650
would then and after which you can

00:28:31,010 --> 00:28:36,530
create a different key derivation tree

00:28:33,650 --> 00:28:38,900
and discard the old software and old old

00:28:36,530 --> 00:28:42,590
keys and rely on the new key derivation

00:28:38,900 --> 00:28:45,440
policy and finally the lifecycle

00:28:42,590 --> 00:28:47,240
management there are aspects of

00:28:45,440 --> 00:28:48,980
lifecycle management which need to be

00:28:47,240 --> 00:28:51,920
handled in the hardware and need to be

00:28:48,980 --> 00:28:57,610
enforced by the hardware hardware and it

00:28:51,920 --> 00:28:57,610
should be built in in the silicon itself

00:28:58,960 --> 00:29:02,500
any questions so far

00:29:03,880 --> 00:29:16,280
okay yeah so is the question that

00:29:14,090 --> 00:29:19,430
happened how many secure partitions can

00:29:16,280 --> 00:29:22,310
be supported in the system this is very

00:29:19,430 --> 00:29:24,980
used cases specific I'll come to some of

00:29:22,310 --> 00:29:27,500
these software building blocks that we

00:29:24,980 --> 00:29:30,650
provide in one of the later slides but

00:29:27,500 --> 00:29:32,390
this again depends on the use case if

00:29:30,650 --> 00:29:35,750
you're talking about a very simple use

00:29:32,390 --> 00:29:40,210
case again light bulb you probably need

00:29:35,750 --> 00:29:42,880
two building blocks on the secure side

00:29:40,210 --> 00:29:45,680
cryptography and secure storage and

00:29:42,880 --> 00:29:49,040
that's probably good enough for a very

00:29:45,680 --> 00:29:52,760
simple use case in some of the more

00:29:49,040 --> 00:29:55,580
complex use cases there for example DRM

00:29:52,760 --> 00:29:58,100
the item will require certain software

00:29:55,580 --> 00:30:01,600
to be running on the secure side as well

00:29:58,100 --> 00:30:05,270
so what that means your all of your

00:30:01,600 --> 00:30:09,860
indiana issue are using GPUs and display

00:30:05,270 --> 00:30:11,420
process to do the decoding then you

00:30:09,860 --> 00:30:14,180
would need some software which can

00:30:11,420 --> 00:30:17,450
handle the interfaces for the graphics

00:30:14,180 --> 00:30:19,400
hardware or the video driver and some

00:30:17,450 --> 00:30:21,760
software which can run to the final

00:30:19,400 --> 00:30:25,310
overlay between these different

00:30:21,760 --> 00:30:26,810
differently generated layers and that

00:30:25,310 --> 00:30:29,210
software can become quite complex and

00:30:26,810 --> 00:30:31,160
that software itself might become

00:30:29,210 --> 00:30:33,110
fertile compartmentalized into different

00:30:31,160 --> 00:30:35,510
parts on the secure side

00:30:33,110 --> 00:30:39,350
so it's very hard to say how many blocks

00:30:35,510 --> 00:30:43,660
says how many blocks do you need in in

00:30:39,350 --> 00:30:43,660
general it's very used cases specific

00:30:46,390 --> 00:30:53,000
there is no Hardware imposed well your

00:30:50,270 --> 00:30:54,970
limited memory so you may have limited

00:30:53,000 --> 00:30:59,000
memory and Linda the hardware resources

00:30:54,970 --> 00:31:01,190
yeah so the framework boys there is no

00:30:59,000 --> 00:31:04,400
limit how much you can you can put on

00:31:01,190 --> 00:31:06,680
the of course if you can talk about the

00:31:04,400 --> 00:31:08,150
extremes where you're you in 32

00:31:06,680 --> 00:31:11,530
calculations might overflow if you're

00:31:08,150 --> 00:31:16,450
talking about more than four Giga

00:31:11,530 --> 00:31:16,450
partitions but those are the extremes

00:31:16,870 --> 00:31:23,960
platform security architecture this is

00:31:22,190 --> 00:31:28,100
an initiative from arm which it got

00:31:23,960 --> 00:31:29,690
launched sometime in 2017 and just last

00:31:28,100 --> 00:31:33,400
week it became public

00:31:29,690 --> 00:31:36,320
all of these specifications and

00:31:33,400 --> 00:31:40,130
documentation and the philosophy behind

00:31:36,320 --> 00:31:43,010
that is now publicly available this

00:31:40,130 --> 00:31:46,640
again the platform security architecture

00:31:43,010 --> 00:31:49,910
is a overarching program which covers

00:31:46,640 --> 00:31:56,510
not only what I just talked about but it

00:31:49,910 --> 00:31:59,300
has much bigger scope in general as you

00:31:56,510 --> 00:32:01,280
see it here it has three major aspects

00:31:59,300 --> 00:32:03,530
analyzing what the different use cases

00:32:01,280 --> 00:32:08,420
are understanding what kind of threats

00:32:03,530 --> 00:32:09,650
they they get exposed to and based on

00:32:08,420 --> 00:32:12,700
the understanding that built by the

00:32:09,650 --> 00:32:14,570
initial analysis architecting the

00:32:12,700 --> 00:32:16,850
specifications architecting the

00:32:14,570 --> 00:32:20,360
different parts of the hardware the soft

00:32:16,850 --> 00:32:21,950
software to ensure that the the threat

00:32:20,360 --> 00:32:24,770
vectors which have been identified can

00:32:21,950 --> 00:32:29,690
be mitigated and finally the software

00:32:24,770 --> 00:32:32,600
implementation which is what the testers

00:32:29,690 --> 00:32:34,790
from where em project is the trust of

00:32:32,600 --> 00:32:39,850
our M provides open-source

00:32:34,790 --> 00:32:39,850
implementation of PSA architecture

00:32:41,720 --> 00:32:47,279
this is a very high level view of war

00:32:44,220 --> 00:32:49,590
distrusted from where and project is its

00:32:47,279 --> 00:32:51,929
open-source project it's going by a

00:32:49,590 --> 00:32:55,679
garnon's body I think we announced

00:32:51,929 --> 00:33:02,070
eagerness as well sometime last week in

00:32:55,679 --> 00:33:04,619
tech on what we have today is some of

00:33:02,070 --> 00:33:06,539
these building blocks in the system the

00:33:04,619 --> 00:33:09,149
different program DSM software provides

00:33:06,539 --> 00:33:10,590
a boot order which talks which takes

00:33:09,149 --> 00:33:15,840
care of the initial group of trust and

00:33:10,590 --> 00:33:18,779
the chain of trust it provides this

00:33:15,840 --> 00:33:20,789
isolation between the non secure world

00:33:18,779 --> 00:33:25,950
and the security aware part of the

00:33:20,789 --> 00:33:28,559
system then there is a framework which

00:33:25,950 --> 00:33:31,409
allows this separation between the

00:33:28,559 --> 00:33:36,080
different worlds and the on the secure

00:33:31,409 --> 00:33:38,749
world different different box different

00:33:36,080 --> 00:33:43,919
parts of the security of their software

00:33:38,749 --> 00:33:46,889
so in the absolute terms bootloader is

00:33:43,919 --> 00:33:49,019
going to have it will have the highest

00:33:46,889 --> 00:33:52,590
amount of privilege and highest amount

00:33:49,019 --> 00:33:55,590
of access to the system resources in

00:33:52,590 --> 00:34:00,210
some cases bootloader will block certain

00:33:55,590 --> 00:34:02,519
resources and only allow usage of

00:34:00,210 --> 00:34:05,220
certain resources in the rest of the

00:34:02,519 --> 00:34:09,210
software one of them being the hardware

00:34:05,220 --> 00:34:12,240
unique key at the boot order front at

00:34:09,210 --> 00:34:14,789
the booted stage itself we could derive

00:34:12,240 --> 00:34:17,129
a key from the hardware unique key and

00:34:14,789 --> 00:34:19,589
block the access to the hardware keys

00:34:17,129 --> 00:34:24,329
saying that beyond this no one can make

00:34:19,589 --> 00:34:26,629
direct use of the hardware keys and

00:34:24,329 --> 00:34:29,869
still has to use the derived keys

00:34:26,629 --> 00:34:34,289
given by the bootloader in which case

00:34:29,869 --> 00:34:39,599
only compromise parts to Hardware keys

00:34:34,289 --> 00:34:41,940
gets blocked out then comes the

00:34:39,599 --> 00:34:44,429
framework in the SPM this is the part

00:34:41,940 --> 00:34:47,220
which provides sandboxing for the

00:34:44,429 --> 00:34:48,779
runtime software and now the initial

00:34:47,220 --> 00:34:53,360
boot process and the initial load of

00:34:48,779 --> 00:34:55,940
trust is is verified and is finished

00:34:53,360 --> 00:34:58,220
spm here the secured partition manager

00:34:55,940 --> 00:35:00,250
here provides the sandbox in between

00:34:58,220 --> 00:35:03,440
different on different parts here

00:35:00,250 --> 00:35:07,010
finally there are some common building

00:35:03,440 --> 00:35:08,990
blocks which apply across different use

00:35:07,010 --> 00:35:10,640
cases across I would say some of this is

00:35:08,990 --> 00:35:14,360
will apply to all of the use cases

00:35:10,640 --> 00:35:16,460
things like crypto and secure storage in

00:35:14,360 --> 00:35:18,740
some cases at the station as well they

00:35:16,460 --> 00:35:21,590
applied no matter what the use cases you

00:35:18,740 --> 00:35:24,830
need to have secure communication you

00:35:21,590 --> 00:35:26,860
need to have a way of securely

00:35:24,830 --> 00:35:29,390
transmitting data between two entities

00:35:26,860 --> 00:35:32,380
for which you need to have cryptography

00:35:29,390 --> 00:35:40,010
cryptographic support to be able to do

00:35:32,380 --> 00:35:43,700
security LS some of these entities audit

00:35:40,010 --> 00:35:45,410
log this provides trace of what happened

00:35:43,700 --> 00:35:48,350
on a device in case there had there is a

00:35:45,410 --> 00:35:51,290
security incident it provides mitigation

00:35:48,350 --> 00:35:53,540
against the repudiation attacks where if

00:35:51,290 --> 00:35:56,840
a certain transaction was requested by

00:35:53,540 --> 00:35:58,430
entity that entity cannot deny later on

00:35:56,840 --> 00:35:59,930
saying that I never I never met that

00:35:58,430 --> 00:36:02,870
because in the first place for example

00:35:59,930 --> 00:36:05,420
financial transactions so it creates a

00:36:02,870 --> 00:36:08,690
log on the device of the security

00:36:05,420 --> 00:36:12,980
critical events on system so that that

00:36:08,690 --> 00:36:19,730
can be used to verify the claims later

00:36:12,980 --> 00:36:23,420
on on behalf of the device vendor and

00:36:19,730 --> 00:36:25,970
finally we know that every use case is

00:36:23,420 --> 00:36:28,460
going to have different software they

00:36:25,970 --> 00:36:30,410
need different building blocks and they

00:36:28,460 --> 00:36:32,870
will be used your use cases specific

00:36:30,410 --> 00:36:36,350
software and which will need a different

00:36:32,870 --> 00:36:39,920
sandbox altogether so the trusted

00:36:36,350 --> 00:36:42,740
firmware employ project provides a way

00:36:39,920 --> 00:36:45,040
to create these user specific sandboxes

00:36:42,740 --> 00:36:45,040
as well

00:36:48,810 --> 00:36:54,750
I'll walk you through a very simple

00:36:51,690 --> 00:36:58,890
example to showcase how it all fits

00:36:54,750 --> 00:37:01,080
together in terms of software this is a

00:36:58,890 --> 00:37:02,820
use case where a security LS connection

00:37:01,080 --> 00:37:07,620
is established between a remote entity

00:37:02,820 --> 00:37:09,570
and the device on this side on this side

00:37:07,620 --> 00:37:12,480
this is the convention software you

00:37:09,570 --> 00:37:14,190
might have the Thiele stack here in

00:37:12,480 --> 00:37:16,560
whenever aerialists transaction is

00:37:14,190 --> 00:37:20,580
initiated there will be some

00:37:16,560 --> 00:37:23,250
cryptographic operations to be done now

00:37:20,580 --> 00:37:25,800
for the TLS use case it needs

00:37:23,250 --> 00:37:28,040
cryptography but the protocol itself

00:37:25,800 --> 00:37:31,730
doesn't need to see the exact

00:37:28,040 --> 00:37:35,970
cryptographic key being used for the

00:37:31,730 --> 00:37:39,060
encryption decryption authentication so

00:37:35,970 --> 00:37:42,060
by following the logic of least

00:37:39,060 --> 00:37:44,670
privilege we compartmentalize the system

00:37:42,060 --> 00:37:46,830
into multiple smaller parts small part

00:37:44,670 --> 00:37:49,140
one small part being secure storage

00:37:46,830 --> 00:37:51,690
which actually has the content which

00:37:49,140 --> 00:37:55,590
actually has the TLS keys and

00:37:51,690 --> 00:37:57,720
certificates the crypto is a

00:37:55,590 --> 00:38:01,530
cryptographic engine which can perform

00:37:57,720 --> 00:38:03,840
requests on behalf of all the callers on

00:38:01,530 --> 00:38:06,270
the non secure side or the caller could

00:38:03,840 --> 00:38:09,810
be somewhere here in the secure side as

00:38:06,270 --> 00:38:11,940
well so for the TLS use case TLS makes a

00:38:09,810 --> 00:38:14,430
request for encryption decryption /

00:38:11,940 --> 00:38:18,450
authentication become request comes to

00:38:14,430 --> 00:38:22,380
decrypt a crypto checks a crypto fetches

00:38:18,450 --> 00:38:25,290
the key from the secure storage in in

00:38:22,380 --> 00:38:28,560
plaintext and then it performs a check

00:38:25,290 --> 00:38:30,570
to see if this calling entity is on

00:38:28,560 --> 00:38:32,760
based on this framework based on this

00:38:30,570 --> 00:38:34,920
framework it'll check if the calling

00:38:32,760 --> 00:38:38,340
entity is allowed to make use of this

00:38:34,920 --> 00:38:41,100
key or not or it does this key belong to

00:38:38,340 --> 00:38:43,170
another entity somewhere here if the

00:38:41,100 --> 00:38:46,080
check passes there it will make use of

00:38:43,170 --> 00:38:49,050
that key in this domain itself perform

00:38:46,080 --> 00:38:53,130
the cryptography again encryption

00:38:49,050 --> 00:38:54,660
decryption authentication and return the

00:38:53,130 --> 00:38:58,410
result back to the caller in a non

00:38:54,660 --> 00:39:01,150
secure world the key aspect is that the

00:38:58,410 --> 00:39:04,960
cryptographic keys and certificates

00:39:01,150 --> 00:39:06,460
never leave the secure domain and their

00:39:04,960 --> 00:39:09,640
visibility is again limited to a very

00:39:06,460 --> 00:39:11,890
small part of the software in the bigger

00:39:09,640 --> 00:39:13,990
scheme of things so anywhere learner

00:39:11,890 --> 00:39:16,420
ability in the rest of the system will

00:39:13,990 --> 00:39:18,549
still make sure that your keys which are

00:39:16,420 --> 00:39:20,710
probably one of the most important that

00:39:18,549 --> 00:39:30,190
says are sets on a device are not

00:39:20,710 --> 00:39:33,369
compromised that is it I wanted to cover

00:39:30,190 --> 00:39:36,430
today we have another talk by one of my

00:39:33,369 --> 00:39:39,339
colleagues on Wednesday or Wednesday

00:39:36,430 --> 00:39:42,430
afternoon and where he is going to talk

00:39:39,339 --> 00:39:47,609
about the compartmentalization in TFM in

00:39:42,430 --> 00:39:50,650
great more detail many of us are here

00:39:47,609 --> 00:39:52,029
many of our team members are here the in

00:39:50,650 --> 00:39:56,650
this conference if you would like to

00:39:52,029 --> 00:40:01,150
talk about BSA or TSM or anything in

00:39:56,650 --> 00:40:03,940
general please find us will be we have

00:40:01,150 --> 00:40:09,130
our armed booth as well so most of us

00:40:03,940 --> 00:40:30,190
will be hanging around in that booth the

00:40:09,130 --> 00:40:50,279
questions that someone has mic I'm not

00:40:30,190 --> 00:40:52,660
sure if it is on yeah that works yeah so

00:40:50,279 --> 00:40:54,430
I'm aware of the fighters tag but I

00:40:52,660 --> 00:40:57,700
don't fully had not gone to the

00:40:54,430 --> 00:41:02,730
technical details of the Fido software

00:40:57,700 --> 00:41:02,730
stack so I can't really comment on

00:41:19,500 --> 00:41:28,240
the PSA program is slightly wider than

00:41:24,250 --> 00:41:30,790
the just securing the device just just

00:41:28,240 --> 00:41:33,270
securing these some parts of bits at

00:41:30,790 --> 00:41:35,530
some point it will cover things like

00:41:33,270 --> 00:41:38,170
certification or it could it could

00:41:35,530 --> 00:41:41,200
become much more wider than just the

00:41:38,170 --> 00:41:44,650
firmware framework so in that context

00:41:41,200 --> 00:41:47,220
phyto can be a PSA compliant entity at

00:41:44,650 --> 00:41:51,100
some point so what we have is

00:41:47,220 --> 00:41:52,870
specification and a open source

00:41:51,100 --> 00:41:54,760
implementation that doesn't mean that

00:41:52,870 --> 00:41:58,050
this is the only implementation that can

00:41:54,760 --> 00:42:00,850
exist well as long as it complies to the

00:41:58,050 --> 00:42:03,100
specifications that we provide me as a

00:42:00,850 --> 00:42:04,930
TFM engineer as a different tech lead I

00:42:03,100 --> 00:42:08,290
would like everyone to use the DSM but

00:42:04,930 --> 00:42:12,330
from the program point of view as long

00:42:08,290 --> 00:42:16,210
as is any de software a solution of

00:42:12,330 --> 00:42:19,860
complies to these specifications it is

00:42:16,210 --> 00:42:19,860
it would still be PSA compliant

00:42:33,040 --> 00:42:36,730
any last question

00:42:43,260 --> 00:42:46,880
in which case thank you everyone

00:42:47,310 --> 00:42:50,790

YouTube URL: https://www.youtube.com/watch?v=9fFSlpD7NjQ


