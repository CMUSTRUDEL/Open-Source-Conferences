Title: Linux and Zephyr “Talking” to Each Other in the Same SoC - Diego Sueiro, Sepura   Embarcados
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Linux and Zephyr “Talking” to Each Other in the Same SoC - Diego Sueiro, Sepura / Embarcados

 SoC vendors are launching Hybrid Multiprocessors (HMP) architectures where one or more cores deal with the end-user application and other cores implement specific features. Instead of battling with Linux Kernel to meet the real-time constraints, you can defer the “dirty” work to a microcontroller in an isolated and controlled environment and it is where Zephyr excels.

It is important that hybrid cores communicate with each other to meet the application requirements. The RPMsg can be used in these kinds of arrangements exposing an API independent of the underlying inter-core communication.

In this presentation, Diego Sueiro will talk about how Linux and Zephyr can share data using RPMsg, initialization flow, and configurations needed to enable its communication.

Main topics of this session:

    Real-Time applications with HMP
    RPMsg on Linux
    Enabling RPMsg-lite on Zephyr
    Demo
    Future work

About Diego Sueiro
Control & Automation Engineer with more than 10 years of experience in embedded software development.
Working with Embedded Real-time Linux Platform development at Sepura and contributing to Zephyr Project by adding support for Hybrid Multi Processors.
Supports and manages the Web Portal "www.embarcados.com.br", responsible for the diffusion of Embedded Development in Brazil.
Presented talks about Embedded Linux and Yocto Project development in events in Brazil.
Captions: 
	00:00:00,030 --> 00:00:07,950
so I am Diego swear I am an embedded

00:00:04,730 --> 00:00:11,820
Linux platform engineer at superior in

00:00:07,950 --> 00:00:15,660
Canberra Guk and I am the CEO of embark

00:00:11,820 --> 00:00:17,910
Addis which means embedded a website

00:00:15,660 --> 00:00:21,960
with articles about embedded systems

00:00:17,910 --> 00:00:25,199
development in Portuguese okay first of

00:00:21,960 --> 00:00:28,830
all I'm sorry about my turbo English but

00:00:25,199 --> 00:00:33,090
I hope you be able to understand what I

00:00:28,830 --> 00:00:35,820
am trying to pass to you okay so this is

00:00:33,090 --> 00:00:39,290
gonna be our agenda first we are going

00:00:35,820 --> 00:00:41,190
to talk about these heterogeneous

00:00:39,290 --> 00:00:45,329
multiprocessors in real-time

00:00:41,190 --> 00:00:52,440
applications then we will introduce to a

00:00:45,329 --> 00:00:54,570
open a MP then to RP RP msg then we are

00:00:52,440 --> 00:00:56,789
going to talk about a variation of these

00:00:54,570 --> 00:01:01,289
another implementation that is the RP

00:00:56,789 --> 00:01:05,250
msg light then we will see how we enable

00:01:01,289 --> 00:01:10,560
the RP message on Linux how do we enable

00:01:05,250 --> 00:01:13,979
the RP message light on Zafar how is the

00:01:10,560 --> 00:01:19,590
communication set up between the Linux

00:01:13,979 --> 00:01:23,400
and Zephyr with some luck a demo it's

00:01:19,590 --> 00:01:25,680
working here let's see if when I will

00:01:23,400 --> 00:01:30,540
factually show you if this is gonna work

00:01:25,680 --> 00:01:33,720
and the future work about this the

00:01:30,540 --> 00:01:36,900
organizer shrunk the the presentation

00:01:33,720 --> 00:01:39,570
from 15 minutes to 40 minutes let's see

00:01:36,900 --> 00:01:43,680
if I will be able to make it in 40

00:01:39,570 --> 00:01:46,380
minutes if not if I have to go through

00:01:43,680 --> 00:01:48,509
quickly to these lives or I can show you

00:01:46,380 --> 00:01:50,970
the demo I will be more than happy to

00:01:48,509 --> 00:01:56,210
show you offline your address any

00:01:50,970 --> 00:02:00,390
questions after the presentation okay so

00:01:56,210 --> 00:02:03,840
before we start just a few words this

00:02:00,390 --> 00:02:06,840
work I've made with the hardware

00:02:03,840 --> 00:02:10,500
efference platform is an imx7 processor

00:02:06,840 --> 00:02:12,900
from when XP the full open a EMP

00:02:10,500 --> 00:02:16,230
implementation was not used

00:02:12,900 --> 00:02:19,379
and it's not being totally covered here

00:02:16,230 --> 00:02:25,560
and you will understand the reasons

00:02:19,379 --> 00:02:28,590
during this talk the foo a.m. P on

00:02:25,560 --> 00:02:31,200
Zephyr is supported on mainline but

00:02:28,590 --> 00:02:35,879
mostly the demo application for DS is

00:02:31,200 --> 00:02:38,640
for an XP processor with a cortex m0 and

00:02:35,879 --> 00:02:41,700
a cortex m4 and the Zephyr is red there

00:02:38,640 --> 00:02:48,329
is an instance of Zephyr for each core

00:02:41,700 --> 00:02:50,639
on these for the open EMP and of course

00:02:48,329 --> 00:02:54,359
the work is open source it's not

00:02:50,639 --> 00:02:58,980
mainline it yet for both Linux kernel

00:02:54,359 --> 00:03:02,129
and the Zephyr so let's talk about real

00:02:58,980 --> 00:03:06,560
time applications in H and piece as

00:03:02,129 --> 00:03:11,069
known as hybrid annuity processing or a

00:03:06,560 --> 00:03:14,430
symmetric multiprocessing you choose the

00:03:11,069 --> 00:03:16,980
flavor that's you most like ok

00:03:14,430 --> 00:03:19,590
the idea is different CPU architectures

00:03:16,980 --> 00:03:22,079
and combinations can be found in the

00:03:19,590 --> 00:03:25,280
same associate like application course

00:03:22,079 --> 00:03:28,909
with cortex say something the espys

00:03:25,280 --> 00:03:33,109
FPGAs low power and real time

00:03:28,909 --> 00:03:37,260
performance scores like a cortex m4 or

00:03:33,109 --> 00:03:40,139
graphics acceleration video encoding

00:03:37,260 --> 00:03:42,930
decoding and this kind of things some

00:03:40,139 --> 00:03:45,780
applications may have requirements like

00:03:42,930 --> 00:03:49,049
real time performance performance

00:03:45,780 --> 00:03:53,510
optimization low power consumption fast

00:03:49,049 --> 00:03:57,449
booting system integrity and security

00:03:53,510 --> 00:04:03,180
usage of certified software solutions or

00:03:57,449 --> 00:04:05,549
even reuse a legacy software in the

00:04:03,180 --> 00:04:09,329
Linux kernel with the pre empty RT

00:04:05,549 --> 00:04:12,510
patches can meet some of these

00:04:09,329 --> 00:04:17,220
requirements but turning customizing

00:04:12,510 --> 00:04:21,260
debugging maintaining updating is costly

00:04:17,220 --> 00:04:24,840
in terms of knowledge time and money

00:04:21,260 --> 00:04:26,130
with the hybrid multi processing you can

00:04:24,840 --> 00:04:28,770
have

00:04:26,130 --> 00:04:32,130
our complete isolation and partitioning

00:04:28,770 --> 00:04:36,090
of the softer domains you can have

00:04:32,130 --> 00:04:40,470
sensors and actuators hub and even a

00:04:36,090 --> 00:04:44,360
reduction of the boem costs but some

00:04:40,470 --> 00:04:46,759
challenge will come up inter processor

00:04:44,360 --> 00:04:50,190
synchronization and communication

00:04:46,759 --> 00:04:53,840
efficient power management share the

00:04:50,190 --> 00:04:57,750
resources isolation and protection cache

00:04:53,840 --> 00:05:01,710
coherency management so like the remote

00:04:57,750 --> 00:05:06,320
processor can be accessing an altar

00:05:01,710 --> 00:05:09,979
dated data and the SOC vendors are

00:05:06,320 --> 00:05:13,169
investing a lot in these new hybrids

00:05:09,979 --> 00:05:15,270
architectures for different marketing

00:05:13,169 --> 00:05:18,120
verticals

00:05:15,270 --> 00:05:20,729
let's take a look whom how a typical

00:05:18,120 --> 00:05:24,889
hybrid the multi processing looks like

00:05:20,729 --> 00:05:28,710
in a top-level view so on the left side

00:05:24,889 --> 00:05:31,699
here we have our application core cortex

00:05:28,710 --> 00:05:34,949
say something with its dedicated apps

00:05:31,699 --> 00:05:38,970
peripherals and memories and on the

00:05:34,949 --> 00:05:41,789
right side our real-time core with again

00:05:38,970 --> 00:05:43,949
with its dedicated real-time

00:05:41,789 --> 00:05:47,820
applications for referrals and memory

00:05:43,949 --> 00:05:52,860
and we will have this shared resources

00:05:47,820 --> 00:05:59,240
like peripherals and memory to be able

00:05:52,860 --> 00:05:59,240
to exchange data between these two cores

00:05:59,690 --> 00:06:09,000
here in the left diagram this one we can

00:06:06,180 --> 00:06:12,919
see the differences between SMP

00:06:09,000 --> 00:06:16,820
synchronous multi processing and and a

00:06:12,919 --> 00:06:21,930
synchronous multi processing here so

00:06:16,820 --> 00:06:25,440
here we find mostly one instance of the

00:06:21,930 --> 00:06:29,639
operating system running on the top of

00:06:25,440 --> 00:06:32,789
the same core architectures and now it

00:06:29,639 --> 00:06:35,880
turret literally knows arrangement you

00:06:32,789 --> 00:06:38,810
will have a different operating system

00:06:35,880 --> 00:06:45,770
running on a different core

00:06:38,810 --> 00:06:48,139
architecture on the right side is shown

00:06:45,770 --> 00:06:51,800
the difference that the different course

00:06:48,139 --> 00:06:53,960
in a shared bus topology where you have

00:06:51,800 --> 00:06:56,930
your different cores in here a bus

00:06:53,960 --> 00:07:00,200
fabric that it's shared between these

00:06:56,930 --> 00:07:01,310
cores and they can eventually share the

00:07:00,200 --> 00:07:03,860
slave device

00:07:01,310 --> 00:07:08,330
these are slave devices we eventually

00:07:03,860 --> 00:07:11,780
generate interrupts that is again share

00:07:08,330 --> 00:07:22,780
it can be shared between those cars as

00:07:11,780 --> 00:07:28,040
well okay so let's see a real-life

00:07:22,780 --> 00:07:32,560
example here for the imx7 solo processor

00:07:28,040 --> 00:07:37,910
we have our main CPU here our cortex a7

00:07:32,560 --> 00:07:41,450
with its own features caches and here we

00:07:37,910 --> 00:07:45,919
have the secondary CPU that is a cortex

00:07:41,450 --> 00:07:51,289
m4 with its own caches and features in

00:07:45,919 --> 00:07:56,450
this case for the IMX processors the nxp

00:07:51,289 --> 00:07:58,690
has these Hardware unit that the first

00:07:56,450 --> 00:08:03,640
one is the resource domain controller

00:07:58,690 --> 00:08:10,130
that is it to be to you effectually

00:08:03,640 --> 00:08:13,940
manage the access to the to the bus to

00:08:10,130 --> 00:08:16,760
the bus fabric of the SOC and the cores

00:08:13,940 --> 00:08:22,010
to a to to be able to access these

00:08:16,760 --> 00:08:29,150
resources these common resources then we

00:08:22,010 --> 00:08:31,580
have the messaging unit that is the the

00:08:29,150 --> 00:08:35,900
set of mailbox registers that we when

00:08:31,580 --> 00:08:38,719
able you to share data between those

00:08:35,900 --> 00:08:43,370
cores or even generate interrupts to

00:08:38,719 --> 00:08:47,900
notify each core and then you have this

00:08:43,370 --> 00:08:51,440
semaphore that is a basically a hardware

00:08:47,900 --> 00:08:56,269
enforces semaphore

00:08:51,440 --> 00:08:58,190
so we saw how hybrids multiprocessing

00:08:56,269 --> 00:09:01,250
looks like let's talk about now the

00:08:58,190 --> 00:09:05,360
frameworks and protocols options that we

00:09:01,250 --> 00:09:09,800
have to available to communicate between

00:09:05,360 --> 00:09:12,860
these are synchronous scores so the open

00:09:09,800 --> 00:09:15,649
EMP is a standard and managed by the

00:09:12,860 --> 00:09:18,980
multi-core Association and it is

00:09:15,649 --> 00:09:22,519
implemented in both Linux kernel and the

00:09:18,980 --> 00:09:26,360
firming line it is composed by the

00:09:22,519 --> 00:09:28,750
remote proc which stands for remote

00:09:26,360 --> 00:09:32,120
processor which is a framework for

00:09:28,750 --> 00:09:35,449
lifecycle operations that allows the

00:09:32,120 --> 00:09:39,079
master to control and manage the remote

00:09:35,449 --> 00:09:43,639
processors so operations like a power on

00:09:39,079 --> 00:09:47,720
/ off reset firmware loading are

00:09:43,639 --> 00:09:50,120
implemented in this framework then you

00:09:47,720 --> 00:09:54,470
have a messaging framework that is the

00:09:50,120 --> 00:09:57,199
RPM SG the remote processor messaging

00:09:54,470 --> 00:10:00,769
that provides the inter processor

00:09:57,199 --> 00:10:04,000
communication by using the VTR yo

00:10:00,769 --> 00:10:07,130
component for shared memory management

00:10:04,000 --> 00:10:10,519
when you want to send or receive the

00:10:07,130 --> 00:10:14,630
data from to the master and remote core

00:10:10,519 --> 00:10:19,160
ok it's oh it's all about shared memory

00:10:14,630 --> 00:10:22,459
ok you have proxy operations as well

00:10:19,160 --> 00:10:26,569
where user space apps running on the

00:10:22,459 --> 00:10:30,079
master side have transparent access to

00:10:26,569 --> 00:10:33,470
the remote using file system calls like

00:10:30,079 --> 00:10:37,160
open closed readwrite so it's very

00:10:33,470 --> 00:10:42,290
simple in this very transparent in this

00:10:37,160 --> 00:10:45,350
matter and proposed by s T and is still

00:10:42,290 --> 00:10:49,670
in discussion the resource management

00:10:45,350 --> 00:10:53,089
that is the R proc SRM that is a

00:10:49,670 --> 00:10:57,129
management for the Sheridan system

00:10:53,089 --> 00:11:01,639
resources like memory reset clocks and

00:10:57,129 --> 00:11:03,309
sheriff referrals resources between the

00:11:01,639 --> 00:11:05,010
master and the remote without

00:11:03,309 --> 00:11:07,740
conflicting to

00:11:05,010 --> 00:11:10,890
to honor this is a stewing discussion

00:11:07,740 --> 00:11:14,460
there is no implementation that we can

00:11:10,890 --> 00:11:16,800
test or something like that it depends

00:11:14,460 --> 00:11:19,920
on the liebe motto as an operating

00:11:16,800 --> 00:11:23,240
system environment abstraction layer and

00:11:19,920 --> 00:11:27,240
a hardware abstraction layer as well and

00:11:23,240 --> 00:11:30,540
there is a working in progress to

00:11:27,240 --> 00:11:35,520
decouple the ARP the remote proc from

00:11:30,540 --> 00:11:39,780
the RP MSG to be used independently and

00:11:35,520 --> 00:11:42,210
because of this it will not be used on

00:11:39,780 --> 00:11:45,510
our demo here and you will understand

00:11:42,210 --> 00:11:49,110
that the dependency between them in this

00:11:45,510 --> 00:11:51,900
is light we are going to take a very

00:11:49,110 --> 00:11:54,860
quick look on this diagram because the

00:11:51,900 --> 00:12:00,620
idea is not to go into detail but

00:11:54,860 --> 00:12:04,080
roughly after the master side here

00:12:00,620 --> 00:12:08,070
receives the remote fumer image it will

00:12:04,080 --> 00:12:11,400
decode it to find a resource table that

00:12:08,070 --> 00:12:13,950
is in the header of this femur this

00:12:11,400 --> 00:12:15,930
resource table basically contains the

00:12:13,950 --> 00:12:20,280
information about the communication

00:12:15,930 --> 00:12:22,440
channels supported by the remote with

00:12:20,280 --> 00:12:25,710
this information then the master will

00:12:22,440 --> 00:12:30,150
create the view t io device to

00:12:25,710 --> 00:12:33,320
communicate with the remote then it will

00:12:30,150 --> 00:12:36,420
effectually boot the remote processor

00:12:33,320 --> 00:12:41,430
here we will start the remote processor

00:12:36,420 --> 00:12:44,780
right and the remote processor when it

00:12:41,430 --> 00:12:48,390
initialize with it will get this

00:12:44,780 --> 00:12:51,990
resource table information and create

00:12:48,390 --> 00:12:55,590
its own virtual device and then

00:12:51,990 --> 00:12:57,660
advertise the remote channels to the

00:12:55,590 --> 00:13:04,770
master and now they are good to go to

00:12:57,660 --> 00:13:07,530
communicate so and the hearing in the

00:13:04,770 --> 00:13:10,080
middle we it is show how you generate

00:13:07,530 --> 00:13:14,970
these resource table and putting the

00:13:10,080 --> 00:13:19,050
remote fear mode there is a restriction

00:13:14,970 --> 00:13:23,310
today that is for the imx7 the

00:13:19,050 --> 00:13:28,200
the remote broken mainline driver does

00:13:23,310 --> 00:13:31,100
not implement the view t io / data from

00:13:28,200 --> 00:13:34,590
the firmer the resource table and

00:13:31,100 --> 00:13:37,980
instead of these and XP implemented in

00:13:34,590 --> 00:13:42,030
their repository all these Vitiello

00:13:37,980 --> 00:13:46,320
initialization device create device

00:13:42,030 --> 00:13:49,380
creation rings queues inside the RP

00:13:46,320 --> 00:13:54,390
message drive by using the data from the

00:13:49,380 --> 00:13:57,750
device tree so these data will be set in

00:13:54,390 --> 00:13:59,610
the device T device tree and the RT

00:13:57,750 --> 00:14:02,310
message driver will consume this

00:13:59,610 --> 00:14:04,590
information instead of the remote proc

00:14:02,310 --> 00:14:11,880
getting the resource table from the

00:14:04,590 --> 00:14:15,330
femur and then created okay so now let's

00:14:11,880 --> 00:14:16,340
talk about the RP message but it's very

00:14:15,330 --> 00:14:19,470
simple okay

00:14:16,340 --> 00:14:24,780
following the OSI standard we have the

00:14:19,470 --> 00:14:27,590
physical layer here where we find the

00:14:24,780 --> 00:14:31,560
shared memory and the inter core

00:14:27,590 --> 00:14:35,490
interrupt is the mailbox then we have

00:14:31,560 --> 00:14:38,220
the media access control layer which is

00:14:35,490 --> 00:14:42,450
basically implementing the VTA oh and

00:14:38,220 --> 00:14:46,250
the beauty beauty il queues and then the

00:14:42,450 --> 00:14:49,320
transport layer that is the ARP message

00:14:46,250 --> 00:14:54,440
implementation for the messaging

00:14:49,320 --> 00:14:58,410
transactions for the physical layer so

00:14:54,440 --> 00:15:00,870
here in the Left diagram we have the

00:14:58,410 --> 00:15:04,920
shared memory that is user that you

00:15:00,870 --> 00:15:09,750
exchange the message and interrupt lines

00:15:04,920 --> 00:15:14,160
to notify each processor on the right

00:15:09,750 --> 00:15:22,320
side for the NXP we will use the message

00:15:14,160 --> 00:15:25,440
unit to be able not to exchange the data

00:15:22,320 --> 00:15:28,470
but it's not it's the message unity is

00:15:25,440 --> 00:15:31,790
not the shared memory so we use the

00:15:28,470 --> 00:15:34,550
interrupts control registers in the

00:15:31,790 --> 00:15:43,160
message unity to notify each processor

00:15:34,550 --> 00:15:46,100
and we use one register to notify the

00:15:43,160 --> 00:15:50,329
other processor if we want to receive a

00:15:46,100 --> 00:15:57,740
data or sender data but the data itself

00:15:50,329 --> 00:16:01,970
it's not in this unit okay the media

00:15:57,740 --> 00:16:04,790
access layer the vio we will not have

00:16:01,970 --> 00:16:08,240
time to cover the VTR your component in

00:16:04,790 --> 00:16:11,420
details but as a top level introduction

00:16:08,240 --> 00:16:15,260
it basically is used to transfer the

00:16:11,420 --> 00:16:18,860
data in a shared memory region using a

00:16:15,260 --> 00:16:26,089
single writer single reader circular

00:16:18,860 --> 00:16:29,560
buffer and each side transmission or

00:16:26,089 --> 00:16:34,880
reception has choose to ring buffers

00:16:29,560 --> 00:16:39,019
using an available ring buffer the ring

00:16:34,880 --> 00:16:42,199
buffers roughly contain the address of

00:16:39,019 --> 00:16:46,970
the shared memory location where the RP

00:16:42,199 --> 00:16:50,779
message data is okay and in the open a

00:16:46,970 --> 00:16:54,170
MP wiki there are details on how the RP

00:16:50,779 --> 00:16:59,990
message framework uses the vio and all

00:16:54,170 --> 00:17:04,459
the data structures okay there are these

00:16:59,990 --> 00:17:10,549
two presentations that gives more detail

00:17:04,459 --> 00:17:13,370
about the vio itself and finally that

00:17:10,549 --> 00:17:17,209
source port layer we find it the RP

00:17:13,370 --> 00:17:21,740
message protocol implementation the

00:17:17,209 --> 00:17:24,079
message is again is storing in in a

00:17:21,740 --> 00:17:27,459
shared memory area and the address is

00:17:24,079 --> 00:17:31,010
all the routier yo vert all rings and

00:17:27,459 --> 00:17:35,330
it's very simple you have 32 bits for a

00:17:31,010 --> 00:17:38,299
source local address then a 32 bit for

00:17:35,330 --> 00:17:42,049
the destination address reserved area

00:17:38,299 --> 00:17:44,870
then you put the length of the payload

00:17:42,049 --> 00:17:49,580
of the data

00:17:44,870 --> 00:17:53,330
and some flags this is it in a more a

00:17:49,580 --> 00:17:58,850
higher level view for the RP message we

00:17:53,330 --> 00:18:03,680
have here our master and or example a

00:17:58,850 --> 00:18:06,620
remote in each side you have an endpoint

00:18:03,680 --> 00:18:11,480
what we call endpoint with a local

00:18:06,620 --> 00:18:16,790
address right and when a communication

00:18:11,480 --> 00:18:21,190
channel is announced it is created this

00:18:16,790 --> 00:18:26,240
endpoint will create a logical link so

00:18:21,190 --> 00:18:29,960
in a in the same shared memory you can

00:18:26,240 --> 00:18:35,120
have different channels between

00:18:29,960 --> 00:18:38,540
different endpoints okay so here is an

00:18:35,120 --> 00:18:42,320
example of when the master wants to send

00:18:38,540 --> 00:18:44,150
an information it puts the data of

00:18:42,320 --> 00:18:47,360
course it's local address and the

00:18:44,150 --> 00:18:49,580
destination address upon receiving the

00:18:47,360 --> 00:18:52,910
remote side will be coded our case of

00:18:49,580 --> 00:18:56,030
these messages for me but it's from the

00:18:52,910 --> 00:18:59,750
this address so yeah this is the channel

00:18:56,030 --> 00:19:04,510
and then we'll carry on on your

00:18:59,750 --> 00:19:06,230
application now let's take a look in the

00:19:04,510 --> 00:19:10,880
RP message

00:19:06,230 --> 00:19:13,309
light so it's altered and maintenance by

00:19:10,880 --> 00:19:16,490
Merrick Novak

00:19:13,309 --> 00:19:21,100
it's a implementation it's a it's a

00:19:16,490 --> 00:19:25,700
simplification of the extensive API

00:19:21,100 --> 00:19:29,000
implemented by by the OpenMP it has on

00:19:25,700 --> 00:19:32,690
smaller smaller footprint when compared

00:19:29,000 --> 00:19:34,640
to the open a MP implementation you can

00:19:32,690 --> 00:19:38,809
see more details about these in the

00:19:34,640 --> 00:19:43,760
github page has an option to use an

00:19:38,809 --> 00:19:47,179
aesthetic API so Noma locks and to

00:19:43,760 --> 00:19:50,559
reduce the code size and this can be

00:19:47,179 --> 00:19:54,530
very beneficial for a small system and

00:19:50,559 --> 00:19:57,560
it's totally decoupled from the remote

00:19:54,530 --> 00:20:02,720
proc there is no remote proc

00:19:57,560 --> 00:20:05,450
dependency here ether has to Subic

00:20:02,720 --> 00:20:08,780
components one is the cue that is a

00:20:05,450 --> 00:20:11,830
blocking receiving API which is commonly

00:20:08,780 --> 00:20:14,570
find in the artists environments and

00:20:11,830 --> 00:20:18,920
requires an implementation in the

00:20:14,570 --> 00:20:21,170
environmental updation layer the other

00:20:18,920 --> 00:20:24,560
component is the name service which

00:20:21,170 --> 00:20:27,530
allows the communicating nodes to send

00:20:24,560 --> 00:20:31,270
announcements about the channels like a

00:20:27,530 --> 00:20:34,040
creation and deletion of these channels

00:20:31,270 --> 00:20:36,380
these name service announcement is

00:20:34,040 --> 00:20:40,040
implemented in the Linux kernel site and

00:20:36,380 --> 00:20:42,200
it's mandatory for the remote to send it

00:20:40,040 --> 00:20:47,330
is announcement in order to the Linux

00:20:42,200 --> 00:20:51,380
kernel create the channel and be able to

00:20:47,330 --> 00:20:54,770
communicate with the remote site the

00:20:51,380 --> 00:20:57,200
architecture so in this diagram you can

00:20:54,770 --> 00:21:00,320
see that this how the source code is

00:20:57,200 --> 00:21:03,830
structured you basically have here

00:21:00,320 --> 00:21:05,600
Europe your application source code then

00:21:03,830 --> 00:21:08,480
you have the API layer that is

00:21:05,600 --> 00:21:11,330
effectually implementing the API the

00:21:08,480 --> 00:21:17,110
name service the cues and the core of

00:21:11,330 --> 00:21:20,560
the RPMs G then the engine that is

00:21:17,110 --> 00:21:25,370
implementing the view to yoyo vgq and

00:21:20,560 --> 00:21:29,150
then the porting layer which is splitted

00:21:25,370 --> 00:21:35,120
in the environment porting layer so like

00:21:29,150 --> 00:21:39,890
freertos burma toe or zephyr and the

00:21:35,120 --> 00:21:42,440
platform that is an abstraction layer

00:21:39,890 --> 00:21:44,590
for the underlying hardware that you

00:21:42,440 --> 00:21:48,500
find on your system

00:21:44,590 --> 00:21:51,530
the rpms EG light is fully compatible

00:21:48,500 --> 00:21:54,910
with what is implemented in the Linux

00:21:51,530 --> 00:22:00,740
kernel side or with the IP message

00:21:54,910 --> 00:22:02,720
standards this is a diagram that we can

00:22:00,740 --> 00:22:05,780
see the interaction between these

00:22:02,720 --> 00:22:09,220
components and some examples of function

00:22:05,780 --> 00:22:10,320
calls that you will find between this

00:22:09,220 --> 00:22:12,570
compound

00:22:10,320 --> 00:22:14,370
and the source code is very simple and

00:22:12,570 --> 00:22:21,480
it's very easy to follow

00:22:14,370 --> 00:22:25,860
okay so let's see how do we enable the

00:22:21,480 --> 00:22:28,800
RP message on Linux in this case we are

00:22:25,860 --> 00:22:30,990
following the platform that we are using

00:22:28,800 --> 00:22:35,580
that is the NXP imx7

00:22:30,990 --> 00:22:37,710
and using the ion the nxp Linux kernel

00:22:35,580 --> 00:22:43,770
source code so this is not in the main

00:22:37,710 --> 00:22:51,600
line okay and this is regarding the 4.9

00:22:43,770 --> 00:22:55,050
version when you set the config SOC imx7

00:22:51,600 --> 00:22:58,700
it will automatically select all these

00:22:55,050 --> 00:23:04,170
RP message related the configs and the

00:22:58,700 --> 00:23:06,510
MU driver okay and here you can see the

00:23:04,170 --> 00:23:11,130
source code location for these drivers

00:23:06,510 --> 00:23:11,880
and it will select him as a module these

00:23:11,130 --> 00:23:15,210
IMX

00:23:11,880 --> 00:23:18,150
RP message et toi that is effectually

00:23:15,210 --> 00:23:20,880
the driver that will expose the RP

00:23:18,150 --> 00:23:24,090
message channel to the user space as a

00:23:20,880 --> 00:23:26,540
TTY device so from the user space see -

00:23:24,090 --> 00:23:31,650
he looks the remote will look like

00:23:26,540 --> 00:23:38,010
ordinary serial port so no secrets from

00:23:31,650 --> 00:23:41,310
the UART from the user space side the

00:23:38,010 --> 00:23:45,110
device tree so in this case for the imx7

00:23:41,310 --> 00:23:49,640
Solo in the DTS I we needed to add the

00:23:45,110 --> 00:23:52,890
message you need to note the register

00:23:49,640 --> 00:23:55,260
range the registered address all the

00:23:52,890 --> 00:23:58,950
interrupts the clocks that it's using

00:23:55,260 --> 00:24:03,930
and the RP message node with the

00:23:58,950 --> 00:24:07,700
compatible string for the hard word for

00:24:03,930 --> 00:24:13,530
the board like in this case the warp 7

00:24:07,700 --> 00:24:16,920
which uses the imx7 solo processor we we

00:24:13,530 --> 00:24:21,230
will set on the RP message node the

00:24:16,920 --> 00:24:23,860
memory the shared memory region ok and

00:24:21,230 --> 00:24:26,799
we needed to instructor the kernel

00:24:23,860 --> 00:24:30,610
that this that this is a reserved the

00:24:26,799 --> 00:24:37,000
area you are not gonna map this area

00:24:30,610 --> 00:24:39,340
okay oh we we enable the you are with

00:24:37,000 --> 00:24:43,450
sorry we disable the you are to

00:24:39,340 --> 00:24:46,030
interface because in this demo I am

00:24:43,450 --> 00:24:51,880
using the you are to chill for the m4

00:24:46,030 --> 00:24:57,090
side as a normal console serial console

00:24:51,880 --> 00:25:02,290
okay so let's see how do we enable this

00:24:57,090 --> 00:25:04,750
RP message light on Zephyr so the I am X

00:25:02,290 --> 00:25:08,230
mu driver is the steering review in

00:25:04,750 --> 00:25:11,850
Zephyr so then I created a fork from

00:25:08,230 --> 00:25:15,510
this PR and added support for the imx7

00:25:11,850 --> 00:25:19,330
specifically and the warp seven board

00:25:15,510 --> 00:25:21,820
the exp guy is tried to add the ARP

00:25:19,330 --> 00:25:24,130
message light on Zephyr but the

00:25:21,820 --> 00:25:27,250
technical steering committee of Zephyr

00:25:24,130 --> 00:25:29,980
choose to only include the open EMP

00:25:27,250 --> 00:25:33,220
implementation as the default IP C

00:25:29,980 --> 00:25:37,030
mechanism but it's still it's very easy

00:25:33,220 --> 00:25:41,620
to have the RPMs satellite compiled

00:25:37,030 --> 00:25:43,960
alongside with Zephyr so because of

00:25:41,620 --> 00:25:47,020
these I created a fork from the RPMs a

00:25:43,960 --> 00:25:52,030
delight to support the Zephyr that

00:25:47,020 --> 00:25:56,790
environment to layer and supported the

00:25:52,030 --> 00:26:05,669
imx7 platform as well by using the MU

00:25:56,790 --> 00:26:09,660
driver the MU driver on Zephyr we

00:26:05,669 --> 00:26:13,720
implemented a zephyr ipm that is

00:26:09,660 --> 00:26:16,900
interpreter process inter processor

00:26:13,720 --> 00:26:22,120
mailbox API that is defined in this

00:26:16,900 --> 00:26:24,309
header and here you find the source all

00:26:22,120 --> 00:26:30,160
the source code location related to the

00:26:24,309 --> 00:26:33,970
MU driver and we configure and we use

00:26:30,160 --> 00:26:37,450
the MA IPM driver align it with the

00:26:33,970 --> 00:26:41,920
Linux side where the RP message we you

00:26:37,450 --> 00:26:45,960
four bytes with the register index one

00:26:41,920 --> 00:26:48,790
for the messaging direction control in

00:26:45,960 --> 00:26:51,160
using the beat 16 so I think if it's

00:26:48,790 --> 00:26:56,530
zero is receiving if it's one it's

00:26:51,160 --> 00:26:58,870
transmitting the parting layers in the

00:26:56,530 --> 00:27:02,620
ARP message light the zephyr porting

00:26:58,870 --> 00:27:06,460
layer is define it in this header okay

00:27:02,620 --> 00:27:10,140
and it's implemented in this source code

00:27:06,460 --> 00:27:12,520
file and it provides general OS

00:27:10,140 --> 00:27:15,220
functionalities like memory handling

00:27:12,520 --> 00:27:18,670
allocation the allocation mutexes

00:27:15,220 --> 00:27:20,110
operations and for the platform side or

00:27:18,670 --> 00:27:22,570
the imx7

00:27:20,110 --> 00:27:24,580
it will be implemented the the API

00:27:22,570 --> 00:27:30,760
define it in this header and it's

00:27:24,580 --> 00:27:36,910
implemented in this source code that

00:27:30,760 --> 00:27:40,000
it's basically exposing the or

00:27:36,910 --> 00:27:46,750
abstracting how to use the IP am driver

00:27:40,000 --> 00:27:49,810
on zephyr to build it we need to choose

00:27:46,750 --> 00:27:52,510
to which you selected the subsystem the

00:27:49,810 --> 00:27:55,560
ipm subsystem inside the Zephyr that is

00:27:52,510 --> 00:28:00,150
controlled with the config IP M and

00:27:55,560 --> 00:28:02,560
select our lower-level driver

00:28:00,150 --> 00:28:07,300
implementation of the IP m in this case

00:28:02,560 --> 00:28:11,410
is going to be the IP m IMX to build the

00:28:07,300 --> 00:28:16,540
IP the RPMs agility itself we control by

00:28:11,410 --> 00:28:18,900
using this configuration and it is

00:28:16,540 --> 00:28:24,760
compiled alongside with the application

00:28:18,900 --> 00:28:30,090
using the normal cake config that prj

00:28:24,760 --> 00:28:34,630
confit and cmakelists file it's a very

00:28:30,090 --> 00:28:38,170
like when you compile a normal server

00:28:34,630 --> 00:28:42,130
application and this is a list of all

00:28:38,170 --> 00:28:45,640
the source code related to these remote

00:28:42,130 --> 00:28:47,680
echo sample app we are gonna sing the

00:28:45,640 --> 00:28:52,060
tails like a little bit more about this

00:28:47,680 --> 00:28:55,330
app so now let's see

00:28:52,060 --> 00:29:09,490
the communication set up between Linux

00:28:55,330 --> 00:29:12,850
and Zephyr some water so in a top-level

00:29:09,490 --> 00:29:15,940
view in the left side we have our master

00:29:12,850 --> 00:29:18,480
domain the Linux running on the a7 and

00:29:15,940 --> 00:29:23,560
on the right side the remote domain

00:29:18,480 --> 00:29:26,740
running Zephyr on the m4 for our demo on

00:29:23,560 --> 00:29:30,910
the power-up the u-boot on the master

00:29:26,740 --> 00:29:33,910
side is responsible for loading both of

00:29:30,910 --> 00:29:38,080
the Linux kernel and the Zephyr on the

00:29:33,910 --> 00:29:40,780
m4 side and start the images boot the

00:29:38,080 --> 00:29:44,260
images when the Zephyr boots

00:29:40,780 --> 00:29:47,800
it creates the future the virtue queues

00:29:44,260 --> 00:29:53,530
and waits for the master to signal that

00:29:47,800 --> 00:29:56,980
the link is up in parallel the kernel

00:29:53,530 --> 00:29:59,530
boots right and then the RP message

00:29:56,980 --> 00:30:02,920
driver creates the virtual cue and

00:29:59,530 --> 00:30:06,520
points and then notifies the remote

00:30:02,920 --> 00:30:10,480
processor that the link is up the

00:30:06,520 --> 00:30:13,350
remotes and then after notify it will

00:30:10,480 --> 00:30:16,210
wait for the name service announcement

00:30:13,350 --> 00:30:19,240
on the remote side by receiving this

00:30:16,210 --> 00:30:23,500
link that the link is up it will create

00:30:19,240 --> 00:30:26,440
the endpoint and send the name service

00:30:23,500 --> 00:30:30,750
announcement after that both sides are

00:30:26,440 --> 00:30:30,750
good to go to send and receive messages

00:30:31,440 --> 00:30:39,040
let's see what do we have for our demo

00:30:36,270 --> 00:30:46,450
simplistically so I have here is the

00:30:39,040 --> 00:30:49,870
warp 7 board the very small board so the

00:30:46,450 --> 00:30:53,260
again the a7 the master domain with

00:30:49,870 --> 00:30:57,310
Linux we are connected to the UART one

00:30:53,260 --> 00:31:00,640
of this system and the remote side

00:30:57,310 --> 00:31:04,169
running zephyr the m4 core we have the

00:31:00,640 --> 00:31:07,820
you are - connected between those two

00:31:04,169 --> 00:31:12,450
course the RP message by using the MU

00:31:07,820 --> 00:31:17,249
and the shared memory for exchanging the

00:31:12,450 --> 00:31:20,399
data all the source code how to compile

00:31:17,249 --> 00:31:23,879
generate the Linux distro and zephyr

00:31:20,399 --> 00:31:28,259
image and it's all documented here and

00:31:23,879 --> 00:31:31,230
you can have access later let's take a

00:31:28,259 --> 00:31:35,070
brief look into the remote app the code

00:31:31,230 --> 00:31:39,739
is strip it because to fit in the screen

00:31:35,070 --> 00:31:42,960
so we set our local endpoint address and

00:31:39,739 --> 00:31:45,869
here we have a set of defines that needs

00:31:42,960 --> 00:31:52,470
to be aligned with the Linux I'd like

00:31:45,869 --> 00:31:58,200
the shared memory address then the the

00:31:52,470 --> 00:32:02,399
max size of the RP messaging the max

00:31:58,200 --> 00:32:06,809
size of the RP message messages and the

00:32:02,399 --> 00:32:09,029
a string with the the the the channel

00:32:06,809 --> 00:32:15,509
announced okay the name service

00:32:09,029 --> 00:32:19,399
announced then this is our task we

00:32:15,509 --> 00:32:23,429
basically declare the variables for the

00:32:19,399 --> 00:32:27,450
RP message instance the cue the endpoint

00:32:23,429 --> 00:32:30,749
in this case we are using name service

00:32:27,450 --> 00:32:34,259
so we can have a handle when it receives

00:32:30,749 --> 00:32:36,960
some name service it can can it can

00:32:34,259 --> 00:32:41,789
cause a callback and you can do a

00:32:36,960 --> 00:32:44,759
process that you want here is the

00:32:41,789 --> 00:32:49,919
initialization process so we call the

00:32:44,759 --> 00:32:53,460
ARP message Eli to remoting it with the

00:32:49,919 --> 00:32:56,009
shared memory address the link ID and

00:32:53,460 --> 00:32:59,519
then it will return a pointer to the ARP

00:32:56,009 --> 00:33:03,059
message instance then we are going to

00:32:59,519 --> 00:33:10,139
wait for the link and as soon as the

00:33:03,059 --> 00:33:13,919
master side notifies we create our queue

00:33:10,139 --> 00:33:17,399
and with regarding that instance and

00:33:13,919 --> 00:33:18,300
then with the queue and the instance we

00:33:17,399 --> 00:33:20,970
then create

00:33:18,300 --> 00:33:26,370
the endpoint the local endpoint with

00:33:20,970 --> 00:33:28,800
that address we send now we are good to

00:33:26,370 --> 00:33:34,800
go to sender the name service announced

00:33:28,800 --> 00:33:38,010
and here we are inside a while true good

00:33:34,800 --> 00:33:41,760
to go to receive and send data in this

00:33:38,010 --> 00:33:47,880
case we are using the receive block API

00:33:41,760 --> 00:33:51,750
as soon as our a data arrived we we will

00:33:47,880 --> 00:33:56,930
format that data by prepending an echo

00:33:51,750 --> 00:34:02,760
string and send it back to the remote

00:33:56,930 --> 00:34:06,960
okay so we can see here it a it will

00:34:02,760 --> 00:34:09,330
feel with the remote address and then we

00:34:06,960 --> 00:34:15,660
do whatever what we want and then we

00:34:09,330 --> 00:34:23,420
sent back to the remote address yeah so

00:34:15,660 --> 00:34:23,420
let me show right demo no it's time okay

00:34:23,570 --> 00:34:38,730
so in this side we have the a7 UART can

00:34:35,310 --> 00:34:42,600
you can you see the is it good besides

00:34:38,730 --> 00:34:46,140
yeah and on this side we have the UART

00:34:42,600 --> 00:34:49,880
from the M for running cipher so here we

00:34:46,140 --> 00:34:56,220
stop it on new boot so if I issue a

00:34:49,880 --> 00:35:01,170
reset I'm gonna reset the system cross

00:34:56,220 --> 00:35:06,450
finger yeah so we can see that z4 booted

00:35:01,170 --> 00:35:09,420
is waiting for the master and then when

00:35:06,450 --> 00:35:14,280
the the ARP ARP message driver came up

00:35:09,420 --> 00:35:18,260
it notified then the Zephyr send the

00:35:14,280 --> 00:35:21,030
name service announced back and on the

00:35:18,260 --> 00:35:23,130
desire P message driver in the

00:35:21,030 --> 00:35:25,410
initialization after receiving the the

00:35:23,130 --> 00:35:29,600
name service announced it will send our

00:35:25,410 --> 00:35:29,600
hello world string okay

00:35:34,559 --> 00:35:40,769
so here oops

00:35:47,980 --> 00:36:01,510
okay so if we look into the damask so we

00:35:55,480 --> 00:36:05,260
can see that when the RP message driver

00:36:01,510 --> 00:36:09,850
is coming up and it says that the the

00:36:05,260 --> 00:36:12,010
meu is ready for exchanging data to send

00:36:09,850 --> 00:36:15,400
the oil and notifying data to the other

00:36:12,010 --> 00:36:18,520
core then it will say that the RP

00:36:15,400 --> 00:36:23,050
message you host is online to registred

00:36:18,520 --> 00:36:25,870
the driver and then when it receives the

00:36:23,050 --> 00:36:29,230
the channel announced it created this

00:36:25,870 --> 00:36:32,770
channel and then it notifies the tty

00:36:29,230 --> 00:36:38,290
driver that the channel is there and the

00:36:32,770 --> 00:36:44,910
tty driver is ready to go so if I for

00:36:38,290 --> 00:36:48,370
example do an echo here then we can see

00:36:44,910 --> 00:36:54,400
here that it's a receive ative 7 bytes

00:36:48,370 --> 00:37:08,430
ELC e and then it's send echo with the

00:36:54,400 --> 00:37:08,430
string back if we use the micro home so

00:37:12,800 --> 00:37:15,970
see here

00:37:18,480 --> 00:37:28,589
well it's not showing this side no any

00:37:21,030 --> 00:37:33,800
more so oh here okay so whenever I type

00:37:28,589 --> 00:37:33,800
here I don't know why it's not updating

00:37:37,820 --> 00:37:44,640
yeah so if I keep typing here so I can

00:37:42,210 --> 00:37:48,410
for each character is sending and then

00:37:44,640 --> 00:37:48,410
receiving it back okay

00:37:48,680 --> 00:37:54,720
almost finishing so let's continue so

00:37:52,320 --> 00:37:57,030
this is the demo is very simple it's

00:37:54,720 --> 00:38:01,710
just a proof of concept that we can have

00:37:57,030 --> 00:38:05,070
Zafar in Linux exchanging data so the

00:38:01,710 --> 00:38:07,710
future work so what we need to be

00:38:05,070 --> 00:38:12,089
upstreaming in the upstream so the

00:38:07,710 --> 00:38:14,970
remote proc driver the mainline driver

00:38:12,089 --> 00:38:19,290
dealing with the RP message the beauty

00:38:14,970 --> 00:38:23,339
il creation for the RP message usage the

00:38:19,290 --> 00:38:26,690
MU driver and the RP message drivers we

00:38:23,339 --> 00:38:30,450
have some patch works to deal with this

00:38:26,690 --> 00:38:33,420
on the open am P hopefully having these

00:38:30,450 --> 00:38:38,069
decoupling between the remote proc and

00:38:33,420 --> 00:38:39,270
the rpms G on the Zephyr effectually

00:38:38,069 --> 00:38:45,569
having the IMX

00:38:39,270 --> 00:38:49,589
MU driver merge it and maybe having the

00:38:45,569 --> 00:38:52,680
RP message light as alternative and I

00:38:49,589 --> 00:38:55,680
want to conduct some latency measurement

00:38:52,680 --> 00:38:58,079
test by varying the memory type because

00:38:55,680 --> 00:39:01,380
all these imx7 you can use external

00:38:58,079 --> 00:39:03,780
memory the DDR or internal memories it

00:39:01,380 --> 00:39:06,660
has a set of internal memories that's

00:39:03,780 --> 00:39:09,420
supposed to be fast much faster than the

00:39:06,660 --> 00:39:15,020
external memory using static and dynamic

00:39:09,420 --> 00:39:17,520
memory allocation copy no copy mechanism

00:39:15,020 --> 00:39:20,280
message buffer size so change the

00:39:17,520 --> 00:39:25,970
message buffer size and even the number

00:39:20,280 --> 00:39:31,710
of buffers so here the references and

00:39:25,970 --> 00:39:38,180
yeah this is it any question

00:39:31,710 --> 00:39:38,180
I have a microphone here

00:39:50,860 --> 00:40:00,800
so on Amy six in each seven as a

00:39:56,920 --> 00:40:03,110
architecture does that Linux processor

00:40:00,800 --> 00:40:05,750
is a master but maybe another

00:40:03,110 --> 00:40:09,950
architecture it will be the opposite

00:40:05,750 --> 00:40:13,340
maybe the m4 is an ester so is it

00:40:09,950 --> 00:40:19,840
possible to do that Sofia protects the

00:40:13,340 --> 00:40:27,650
memory of Linux and and Sun yes it is

00:40:19,840 --> 00:40:30,560
but the result with the RPMs okay from

00:40:27,650 --> 00:40:32,840
the software perspective it is possible

00:40:30,560 --> 00:40:36,050
to have the Zephyr as as the master

00:40:32,840 --> 00:40:40,010
controlling what happens with the a7 but

00:40:36,050 --> 00:40:43,780
we have a constraint in the hardware for

00:40:40,010 --> 00:40:47,780
the IMX processor in this isometric

00:40:43,780 --> 00:40:52,460
symmetric arrangement that is the a7 is

00:40:47,780 --> 00:40:57,970
the primary core it is the core that we

00:40:52,460 --> 00:41:01,610
effectually start the m4 core you can't

00:40:57,970 --> 00:41:07,810
you can't boot first on the m4 and then

00:41:01,610 --> 00:41:07,810
both on the a7 it's a harder constraint

00:41:10,660 --> 00:41:13,940
actually

00:41:12,350 --> 00:41:17,210
that's a good question because I don't

00:41:13,940 --> 00:41:20,030
know on the Linux implementation if it

00:41:17,210 --> 00:41:22,130
is possible the Linux to be a remote I

00:41:20,030 --> 00:41:24,620
don't think so I think that the Linux is

00:41:22,130 --> 00:41:27,080
only master I can be wrong and don't

00:41:24,620 --> 00:41:30,620
know if someone here has this

00:41:27,080 --> 00:41:32,570
information but I think that but from

00:41:30,620 --> 00:41:35,660
your application perspective you can

00:41:32,570 --> 00:41:39,080
implement saying that okay no the m4 is

00:41:35,660 --> 00:41:43,090
effectually controlling things in the a7

00:41:39,080 --> 00:41:43,090
so you can do this from your application

00:41:47,390 --> 00:41:50,390
yeah

00:41:52,130 --> 00:41:55,130
yeah

00:42:02,080 --> 00:42:05,960
just a short note that you really should

00:42:04,760 --> 00:42:08,330
have a look at the mainline kernel

00:42:05,960 --> 00:42:11,570
because a colleague of mine recently

00:42:08,330 --> 00:42:14,540
mainlined several patches related to RP

00:42:11,570 --> 00:42:16,370
message there okay and I don't know

00:42:14,540 --> 00:42:17,750
about the exact state but you should

00:42:16,370 --> 00:42:23,930
have a closer look

00:42:17,750 --> 00:42:27,940
yeah I look at two weeks ago so in two

00:42:23,930 --> 00:42:27,940
weeks a lot of things can change right a

00:42:32,260 --> 00:42:39,920
human in that in your demo you bought

00:42:35,680 --> 00:42:42,920
load there's a butyl cortex and for does

00:42:39,920 --> 00:42:47,000
that mean that it's was loaded to ram

00:42:42,920 --> 00:42:51,110
memory of our own sisters just culto to

00:42:47,000 --> 00:42:53,870
flash memory in this case the zephyr is

00:42:51,110 --> 00:42:58,010
being loaded in a TCM memory there is an

00:42:53,870 --> 00:43:01,310
old ship memory of 32 k so it's an old

00:42:58,010 --> 00:43:08,930
ship memory I think this application

00:43:01,310 --> 00:43:14,470
this demo has 15k of flash and or 21k of

00:43:08,930 --> 00:43:14,470
flesh and 15k of ram it's a very small

00:43:17,470 --> 00:43:22,480
any more questions

00:43:25,920 --> 00:43:32,090
okay so this is it thank you very much

00:43:28,590 --> 00:43:32,090

YouTube URL: https://www.youtube.com/watch?v=4zMyjaEgj2U


