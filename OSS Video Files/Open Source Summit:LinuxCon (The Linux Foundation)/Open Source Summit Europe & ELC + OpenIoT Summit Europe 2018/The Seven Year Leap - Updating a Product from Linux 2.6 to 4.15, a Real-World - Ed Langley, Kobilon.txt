Title: The Seven Year Leap - Updating a Product from Linux 2.6 to 4.15, a Real-World - Ed Langley, Kobilon
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	The Seven Year Leap - Updating a Product from Linux 2.6 to 4.15, a Real-World Project Case Study - Ed Langley, Kobilon

Many Linux devices actively developed/maintained out there for niche markets are still running a 2.6 series kernel. Backporting becomes a regular habit, but often updating the kernel is deemed too risky.

In this talk, Ed Langley will discuss a real-world project in which he did just that - update a single purpose OMAP3 based Android device from 2.6.37 to 4.15.

What issues in the project finally led to the upgrade? How was the effort estimated? Convincing upper management to go ahead, task breakdown and planning out the approach.

On the technical side: What just worked, and what did not, what used to require a separate driver 7 years ago, and is now accomplished in 3 lines of a dts file. Closed source GPU driver woes, and fun with running 4.15 whilst trying to stick with Android KitKat. Yes, you can run old Android on a new kernel!

Finally, how long did it all take in the end? 

About Ed Langley
Ed has been working on device drivers, BSPs and userspace software for embedded products for Linux and other OSes, in a professional capacity for the last 12 years or so. Most of that time has been spent with embedded software consultancies - most recently Adeneo/Witekio and now Kobilon, helping customers with Linux drivers and BSPs in order to get their devices to market. These roles have given quite a varied insight into many industries which are integrating ever more complex and connected software.

Ed last spoke at a conference at the UK Unix Users Group back in 2009, so this would be a return after a rather long break from presenting!
Captions: 
	00:00:00,299 --> 00:00:07,919
hello everyone.welcome the seven-year

00:00:02,909 --> 00:00:10,440
leap this is about what happens in a

00:00:07,919 --> 00:00:13,429
project to develop or maintain a

00:00:10,440 --> 00:00:16,830
products when the decision is made to

00:00:13,429 --> 00:00:19,199
update the kernel from what is by now a

00:00:16,830 --> 00:00:23,550
very old version several major versions

00:00:19,199 --> 00:00:29,789
at once to what was at the time the

00:00:23,550 --> 00:00:33,390
latest stable release of mainline so my

00:00:29,789 --> 00:00:38,190
name is Ed Langley from Co blonde

00:00:33,390 --> 00:00:41,160
embedded software consultancy and as I

00:00:38,190 --> 00:00:45,030
say this talk is based on an actual

00:00:41,160 --> 00:00:47,399
projects that happened and when I said

00:00:45,030 --> 00:00:49,500
real-world in the title I don't I don't

00:00:47,399 --> 00:00:52,440
just mean it really happened I mean in

00:00:49,500 --> 00:00:55,949
the real world when you're developing in

00:00:52,440 --> 00:00:56,719
products sometimes things don't go so

00:00:55,949 --> 00:01:00,329
well

00:00:56,719 --> 00:01:02,430
devices just won't work and so I've

00:01:00,329 --> 00:01:06,150
tries to convey some of the actual

00:01:02,430 --> 00:01:08,549
challenges because having nice code is

00:01:06,150 --> 00:01:10,080
great but when you've got a ship then

00:01:08,549 --> 00:01:16,520
sometimes you have to make compromises

00:01:10,080 --> 00:01:19,530
to get it out so for this case study

00:01:16,520 --> 00:01:23,030
yeah what were the issues that led to

00:01:19,530 --> 00:01:26,100
finally upgrading this old colonel

00:01:23,030 --> 00:01:29,759
how will the upper management sold on

00:01:26,100 --> 00:01:32,960
the idea what kind of issues ran into

00:01:29,759 --> 00:01:35,729
along the way and if anyone else here is

00:01:32,960 --> 00:01:40,470
ever tasks with estimating or

00:01:35,729 --> 00:01:43,020
implementing a similar exercise how long

00:01:40,470 --> 00:01:47,790
did it take in this case might be a

00:01:43,020 --> 00:01:49,890
useful reference for you so if you're

00:01:47,790 --> 00:01:51,420
updating from two point six straight to

00:01:49,890 --> 00:01:53,430
four point something that kind of

00:01:51,420 --> 00:01:54,930
implies that the products which is

00:01:53,430 --> 00:02:00,270
running a pretty old colonel by that

00:01:54,930 --> 00:02:02,610
point so this is not the first time that

00:02:00,270 --> 00:02:04,680
the topic of dealing with old curls has

00:02:02,610 --> 00:02:06,540
been covered in the east kind of

00:02:04,680 --> 00:02:10,289
conferences so I've just referenced a

00:02:06,540 --> 00:02:12,050
few here whales talk about coping with

00:02:10,289 --> 00:02:14,940
an old colonel

00:02:12,050 --> 00:02:19,080
fixing up ESP they had an old kernel in

00:02:14,940 --> 00:02:22,200
its and just maintaining it software not

00:02:19,080 --> 00:02:25,260
over a long term and in that particular

00:02:22,200 --> 00:02:27,540
talk making sure you have a ready

00:02:25,260 --> 00:02:29,940
upgrade mechanism in place which implies

00:02:27,540 --> 00:02:32,820
you have a newer kernel to upgrade to in

00:02:29,940 --> 00:02:36,660
the field so the only thing I would add

00:02:32,820 --> 00:02:38,910
to the topic of older kernels it would

00:02:36,660 --> 00:02:42,870
be to ask where are you on the kernel

00:02:38,910 --> 00:02:44,760
age spectrum or at least squares of

00:02:42,870 --> 00:02:46,320
projects because people can find

00:02:44,760 --> 00:02:48,270
themselves working on products or

00:02:46,320 --> 00:02:51,780
projects that has an old kernel in its

00:02:48,270 --> 00:02:54,690
for a long time and it kind of ends up

00:02:51,780 --> 00:02:57,990
being their area of expertise so over on

00:02:54,690 --> 00:03:00,450
this is a scale of kernel age that

00:02:57,990 --> 00:03:03,450
people might work with right over there

00:03:00,450 --> 00:03:06,000
on the left people creating the very

00:03:03,450 --> 00:03:08,820
newest version that hasn't hasn't been

00:03:06,000 --> 00:03:12,870
released yet and then system on the chip

00:03:08,820 --> 00:03:15,120
vendors might take a newish mainline put

00:03:12,870 --> 00:03:17,520
it in a public repository add their

00:03:15,120 --> 00:03:20,489
supports for their chips or platforms

00:03:17,520 --> 00:03:23,400
and then you've got new product

00:03:20,489 --> 00:03:26,400
developments so if you get a Yocto BSP

00:03:23,400 --> 00:03:27,720
today unless you do anything weird with

00:03:26,400 --> 00:03:31,560
your recipes you're probably going to

00:03:27,720 --> 00:03:34,080
get a four point nine ish kernel come

00:03:31,560 --> 00:03:39,180
out and then going right all the way

00:03:34,080 --> 00:03:41,070
along here you get two projects that

00:03:39,180 --> 00:03:43,620
have been in development for a long time

00:03:41,070 --> 00:03:46,110
or in in maintenance mode maybe still

00:03:43,620 --> 00:03:48,989
adding Avenue really a new fix here and

00:03:46,110 --> 00:03:51,269
there or a feature and that's kind of

00:03:48,989 --> 00:03:55,290
where the example in this case studies

00:03:51,269 --> 00:03:57,810
it's about number six there and this

00:03:55,290 --> 00:04:00,180
this discussion is about moving that

00:03:57,810 --> 00:04:02,970
projects right the way over to more like

00:04:00,180 --> 00:04:06,420
number three at which point is make much

00:04:02,970 --> 00:04:08,519
easier to take any fixes that are

00:04:06,420 --> 00:04:14,550
helpful for other people feed them right

00:04:08,519 --> 00:04:18,510
in at the left ie upstream so in this

00:04:14,550 --> 00:04:22,700
example for this project what was it it

00:04:18,510 --> 00:04:25,150
was a handsets for specific users

00:04:22,700 --> 00:04:26,560
running Android the user

00:04:25,150 --> 00:04:30,430
didn't know it runs Android it just

00:04:26,560 --> 00:04:34,509
boots into a custom app specific for the

00:04:30,430 --> 00:04:36,729
purpose of that device and to the

00:04:34,509 --> 00:04:38,979
customers credit they had used a

00:04:36,729 --> 00:04:41,919
hardware design that's very closely

00:04:38,979 --> 00:04:44,740
followed the beagleboard-xm

00:04:41,919 --> 00:04:47,830
anyone remembers that from several years

00:04:44,740 --> 00:04:51,130
ago now that's based on a Texas

00:04:47,830 --> 00:04:54,729
Instruments OMAP 3 which got rebranded

00:04:51,130 --> 00:04:57,460
to a DaVinci and they were the only

00:04:54,729 --> 00:05:00,520
major difference was they were using the

00:04:57,460 --> 00:05:02,320
display through what Texas Instruments

00:05:00,520 --> 00:05:10,139
calls the remote frame buffer interface

00:05:02,320 --> 00:05:14,050
which is actually just Miffy DVI so

00:05:10,139 --> 00:05:18,010
there are already a few problems that

00:05:14,050 --> 00:05:21,990
got solved before upgrading just living

00:05:18,010 --> 00:05:26,289
with the older kernel and the major one

00:05:21,990 --> 00:05:28,360
was the real-time clock alarm needed to

00:05:26,289 --> 00:05:31,410
wake up the handsets after a fixed

00:05:28,360 --> 00:05:36,280
duration so it could do a GSM sync and

00:05:31,410 --> 00:05:39,550
yeah that took a series of commits back

00:05:36,280 --> 00:05:42,310
ported from three points something and a

00:05:39,550 --> 00:05:44,590
lot of fixing up is quite heavily

00:05:42,310 --> 00:05:48,699
integrated into the platform code for

00:05:44,590 --> 00:05:52,210
that ship and then the project started

00:05:48,699 --> 00:05:54,310
running into issues that were not so

00:05:52,210 --> 00:05:57,669
easily so well that wasn't easily solved

00:05:54,310 --> 00:05:59,710
but issues a series of issues that

00:05:57,669 --> 00:06:03,789
altogether was not an easy proposition

00:05:59,710 --> 00:06:06,430
to solve the main the main requirement

00:06:03,789 --> 00:06:09,190
feature was the battery life the suspend

00:06:06,430 --> 00:06:13,270
current drawer needed to be a third of

00:06:09,190 --> 00:06:15,340
what it was and in order to get that a

00:06:13,270 --> 00:06:17,169
lot of power management code from later

00:06:15,340 --> 00:06:20,020
kernels but it needs to be back forces

00:06:17,169 --> 00:06:24,340
again that's very heavily integrated

00:06:20,020 --> 00:06:26,740
into the platform code for the chip the

00:06:24,340 --> 00:06:28,510
SD card you take it out after boot you

00:06:26,740 --> 00:06:30,490
take it out and put it back in nothing

00:06:28,510 --> 00:06:32,650
happens I first thought I thought this

00:06:30,490 --> 00:06:36,669
sounds like just a pin muxing issue on

00:06:32,650 --> 00:06:38,770
the car detect line run the function

00:06:36,669 --> 00:06:41,110
tracer I could see the interrupts firing

00:06:38,770 --> 00:06:43,840
going off into the OMAP hardware mod

00:06:41,110 --> 00:06:45,819
framework which whoever works with an

00:06:43,840 --> 00:06:47,830
old map on an old colonel there's a

00:06:45,819 --> 00:06:50,680
whole ream of platformer code in there

00:06:47,830 --> 00:06:54,280
the deals of ohm apps and plugging all

00:06:50,680 --> 00:06:56,590
the on peripherals together and

00:06:54,280 --> 00:06:59,949
it's soon transpired that was again

00:06:56,590 --> 00:07:03,069
gonna be a lot of very complex back

00:06:59,949 --> 00:07:07,150
forcing together get that working in a

00:07:03,069 --> 00:07:10,030
two point six and then the big problem

00:07:07,150 --> 00:07:13,770
was the suspend lockup or became known

00:07:10,030 --> 00:07:17,169
as the suspend lockup amongst everyone

00:07:13,770 --> 00:07:19,180
so very briefly goes into the spend is

00:07:17,169 --> 00:07:19,659
coming out the suspend gets stuck

00:07:19,180 --> 00:07:22,690
somewhere

00:07:19,659 --> 00:07:24,460
it's very intermittent eventually

00:07:22,690 --> 00:07:29,530
realized how to reproduce it more

00:07:24,460 --> 00:07:30,729
reliably even just last week rehearsing

00:07:29,530 --> 00:07:32,680
for this I came up with some further

00:07:30,729 --> 00:07:37,120
ideas I could go back and try solve it

00:07:32,680 --> 00:07:40,780
again but as consultants I sort of you

00:07:37,120 --> 00:07:46,090
feel obliged to offer good advice to

00:07:40,780 --> 00:07:47,919
your clients and at this point I said to

00:07:46,090 --> 00:07:49,930
them yeah I could I could keep spending

00:07:47,919 --> 00:07:51,550
more time investigating all these issues

00:07:49,930 --> 00:07:53,550
but what are you gonna have at the end

00:07:51,550 --> 00:07:55,930
of it okay that's if we solve the locker

00:07:53,550 --> 00:07:59,080
it's still gonna have to a higher

00:07:55,930 --> 00:08:03,969
current draw and you hand said battery

00:07:59,080 --> 00:08:06,069
life is too too low so the upgrade had

00:08:03,969 --> 00:08:08,529
already been raised as a suggestion

00:08:06,069 --> 00:08:13,469
before and then kicked around and

00:08:08,529 --> 00:08:15,789
murmured about and go away again so I

00:08:13,469 --> 00:08:18,789
suggested it and if you ever suggest

00:08:15,789 --> 00:08:20,680
anything to management at work typical

00:08:18,789 --> 00:08:23,020
kind of questions that come back or

00:08:20,680 --> 00:08:23,529
along the lines of well how long is this

00:08:23,020 --> 00:08:26,469
going to take

00:08:23,529 --> 00:08:30,969
and ie how much is it going to cost us

00:08:26,469 --> 00:08:34,959
right so it's very difficult to estimate

00:08:30,969 --> 00:08:39,310
an entire kernel port right so the

00:08:34,959 --> 00:08:42,099
tactic in this case is to estimate how

00:08:39,310 --> 00:08:44,380
much how long it's going to take to get

00:08:42,099 --> 00:08:46,120
a new kernel running to the point where

00:08:44,380 --> 00:08:48,339
you can establish while it's fixed the

00:08:46,120 --> 00:08:50,199
issues and then we'll carry on with

00:08:48,339 --> 00:08:53,610
adding the rest of the peripheral

00:08:50,199 --> 00:08:53,610
support your custom path

00:08:53,710 --> 00:09:02,830
so that's is how I got the buy-in in

00:08:56,620 --> 00:09:05,020
this example so that's the lesson just

00:09:02,830 --> 00:09:08,170
if you want to sell the idea you only

00:09:05,020 --> 00:09:12,220
need to provide the estimate and with

00:09:08,170 --> 00:09:14,860
undersell for what you need to get get

00:09:12,220 --> 00:09:25,330
the the understanding we know this is a

00:09:14,860 --> 00:09:27,670
goer we can carry on so if you sort of

00:09:25,330 --> 00:09:29,950
thinking about the same activity

00:09:27,670 --> 00:09:32,440
depending on the system on chip do you

00:09:29,950 --> 00:09:34,240
have getting to the point where you have

00:09:32,440 --> 00:09:36,160
a kernel running and you can do some

00:09:34,240 --> 00:09:38,860
basic testing might not be so easy in

00:09:36,160 --> 00:09:41,500
this case there's a lot of platform

00:09:38,860 --> 00:09:43,390
supports for the OMAP already up

00:09:41,500 --> 00:09:49,600
streamed into mainline by now and

00:09:43,390 --> 00:09:52,420
settled there for some years so the plan

00:09:49,600 --> 00:09:54,400
just ignore Android for now build a

00:09:52,420 --> 00:09:57,730
basic rousseff s the easiest way

00:09:54,400 --> 00:10:04,330
possible use that to boot the kernel and

00:09:57,730 --> 00:10:06,160
do some command-line testing now with a

00:10:04,330 --> 00:10:09,820
much newer kernel you need a newer tool

00:10:06,160 --> 00:10:12,490
chain but try and then build at an old

00:10:09,820 --> 00:10:14,320
Android source tree with a new it's all

00:10:12,490 --> 00:10:17,100
chain you get all kinds of problems just

00:10:14,320 --> 00:10:18,340
pouring out so the technique as for that

00:10:17,100 --> 00:10:20,500
later

00:10:18,340 --> 00:10:22,960
it was a noose or chain for the kernel

00:10:20,500 --> 00:10:28,810
oldest or chain for them for the Android

00:10:22,960 --> 00:10:30,670
so it doesn't really matter now I was

00:10:28,810 --> 00:10:33,640
like okay I can go get a kernel all

00:10:30,670 --> 00:10:35,350
right I'll just just Google what's the

00:10:33,640 --> 00:10:38,410
best way to be able to kernel for a

00:10:35,350 --> 00:10:42,070
beagleboard-xm or not that for Bhosle

00:10:38,410 --> 00:10:45,340
but some I kind of got sidetracked by

00:10:42,070 --> 00:10:48,060
various kind of github projects for his

00:10:45,340 --> 00:10:50,350
build routes that's optimized for

00:10:48,060 --> 00:10:52,390
BeagleBoard or you know here's the

00:10:50,350 --> 00:10:55,630
BeagleBoard kernel on somebody's

00:10:52,390 --> 00:10:57,010
repository in hindsight the best thing

00:10:55,630 --> 00:11:01,330
to do is just go and get the mainline

00:10:57,010 --> 00:11:04,660
kernel and establish what's the config

00:11:01,330 --> 00:11:05,620
menu config file we need what's the DTB

00:11:04,660 --> 00:11:07,630
you need

00:11:05,620 --> 00:11:09,670
and they're all is they're all there in

00:11:07,630 --> 00:11:12,130
the mainline tree and it's much simply

00:11:09,670 --> 00:11:17,620
we just use those and get going on a

00:11:12,130 --> 00:11:19,330
mainline kernel so if you get a newer

00:11:17,620 --> 00:11:21,610
kernel I was talking about this with

00:11:19,330 --> 00:11:24,190
someone last night you do need new EU

00:11:21,610 --> 00:11:26,890
boots right obviously for the DTB

00:11:24,190 --> 00:11:29,440
loading yeah it's yeah you could get by

00:11:26,890 --> 00:11:31,510
without having to load a DD deep deep B

00:11:29,440 --> 00:11:36,010
but why would you want to it's much

00:11:31,510 --> 00:11:38,440
simpler just upgrade them as a pair the

00:11:36,010 --> 00:11:40,980
consideration I had early on was I knew

00:11:38,440 --> 00:11:44,550
that they would want to be able to

00:11:40,980 --> 00:11:47,800
insert an SD card and when the on chip

00:11:44,550 --> 00:11:51,580
bootloader recognizes there's an SD card

00:11:47,800 --> 00:11:53,050
there well unless you opened the case

00:11:51,580 --> 00:11:56,410
and press the user button it will boot

00:11:53,050 --> 00:11:58,060
from NAND if there's a valid mlo in

00:11:56,410 --> 00:12:03,340
there if you've ever worked with TI

00:11:58,060 --> 00:12:05,380
chips so if the mlo sees an SD card it

00:12:03,340 --> 00:12:07,150
will boot that you boots so they need to

00:12:05,380 --> 00:12:09,670
be backwards compatible and forwards

00:12:07,150 --> 00:12:11,560
compatible so that was just the case

00:12:09,670 --> 00:12:15,790
making sure that the new you boot could

00:12:11,560 --> 00:12:18,880
be loaded with the same file name to the

00:12:15,790 --> 00:12:21,040
same memory address and just made sure

00:12:18,880 --> 00:12:27,280
to establish that early on so it didn't

00:12:21,040 --> 00:12:31,240
come back to bite me later so after a

00:12:27,280 --> 00:12:34,450
time got a new kernel up and running on

00:12:31,240 --> 00:12:38,620
this handset had a debug zero okay were

00:12:34,450 --> 00:12:40,900
just pouring out a thing that gave me a

00:12:38,620 --> 00:12:43,330
command line and I was quite impressed

00:12:40,900 --> 00:12:45,400
of how much just works actually because

00:12:43,330 --> 00:12:48,010
they followed the reference design for

00:12:45,400 --> 00:12:50,500
the BeagleBoard you can press the power

00:12:48,010 --> 00:12:52,270
button went into the P make and the

00:12:50,500 --> 00:12:56,500
thing just went to sleep I like to the

00:12:52,270 --> 00:12:58,840
power supply and glorious the battery

00:12:56,500 --> 00:13:04,030
that the current drawer was spot on the

00:12:58,840 --> 00:13:06,790
target figure so is like Shing the

00:13:04,030 --> 00:13:11,590
suspend lock up looks like it had gone

00:13:06,790 --> 00:13:14,830
in RTC alarm was still there from after

00:13:11,590 --> 00:13:17,290
I'd back ported its of the past and you

00:13:14,830 --> 00:13:18,970
could insert an SD card any time you

00:13:17,290 --> 00:13:27,519
like so brilliant

00:13:18,970 --> 00:13:32,529
welcome to 2018 so as I say went through

00:13:27,519 --> 00:13:36,069
all those issues checks them off the

00:13:32,529 --> 00:13:38,829
suspend lockup I just not something this

00:13:36,069 --> 00:13:41,740
script that just goes to sleep 10

00:13:38,829 --> 00:13:45,329
seconds wakes up 10 seconds later left

00:13:41,740 --> 00:13:50,199
that running all night 2000 cycles later

00:13:45,329 --> 00:13:51,970
and then reproduce all the methods that

00:13:50,199 --> 00:13:54,370
you can make it happen more regularly

00:13:51,970 --> 00:13:55,870
check it doesn't happen anymore and I

00:13:54,370 --> 00:13:58,689
just run that every time I added

00:13:55,870 --> 00:14:00,610
something new to the build just to make

00:13:58,689 --> 00:14:02,470
sure it didn't regress or there was

00:14:00,610 --> 00:14:13,259
actually a driver that was just causing

00:14:02,470 --> 00:14:18,939
it on this platform so then we come to

00:14:13,259 --> 00:14:22,180
adding the peripherals back in because

00:14:18,939 --> 00:14:24,939
at the moment it was just a device with

00:14:22,180 --> 00:14:25,569
a serial port and he needs to be able to

00:14:24,939 --> 00:14:29,379
pick it up

00:14:25,569 --> 00:14:33,519
I would display that like driver and so

00:14:29,379 --> 00:14:34,870
on so this is where the 7-year leap idea

00:14:33,519 --> 00:14:37,509
comes into it because it sort of feels

00:14:34,870 --> 00:14:40,000
like if you've been working on 2.6 for

00:14:37,509 --> 00:14:41,620
ages it feels a bit like jumping into a

00:14:40,000 --> 00:14:43,089
time machine and arriving in the present

00:14:41,620 --> 00:14:45,100
where everything's mostly the same but

00:14:43,089 --> 00:14:48,399
that's a few tricky differences that can

00:14:45,100 --> 00:14:51,639
catch you out so have a good look around

00:14:48,399 --> 00:14:54,009
what's there before you just start

00:14:51,639 --> 00:14:58,329
blindly forward poor seeing all your

00:14:54,009 --> 00:15:01,899
drivers the haphazard manner this is an

00:14:58,329 --> 00:15:04,629
example the backlight had been done by

00:15:01,899 --> 00:15:05,170
back ports in the Pandora backlight

00:15:04,629 --> 00:15:08,800
driver

00:15:05,170 --> 00:15:10,600
it's 2.6 renaming it changing the PWM

00:15:08,800 --> 00:15:12,939
channel so I was sort of in the process

00:15:10,600 --> 00:15:15,069
of doing that and after about 10 minutes

00:15:12,939 --> 00:15:17,079
I thought isn't there a better way of

00:15:15,069 --> 00:15:20,230
doing this now than adding a whole new C

00:15:17,079 --> 00:15:25,990
file just to change one value in there

00:15:20,230 --> 00:15:29,050
and it turns out there is you just

00:15:25,990 --> 00:15:31,660
specify in your DTS you want to use the

00:15:29,050 --> 00:15:32,710
generic pulse width modulation back

00:15:31,660 --> 00:15:35,380
lights I

00:15:32,710 --> 00:15:39,550
just give it a PWM instance which is the

00:15:35,380 --> 00:15:44,140
one off the P make on here and ctv t WM

00:15:39,550 --> 00:15:47,680
t WL pwm one just change that number for

00:15:44,140 --> 00:15:50,320
the channel you want so that was a

00:15:47,680 --> 00:15:53,800
lesson learned is don't rush to forward

00:15:50,320 --> 00:15:56,410
port customizations from your old panel

00:15:53,800 --> 00:15:58,540
have a good look around make sure

00:15:56,410 --> 00:16:02,440
there's not a more elegant way to do it

00:15:58,540 --> 00:16:08,530
in the much newer version are you going

00:16:02,440 --> 00:16:12,130
to sew on that topic it's a really good

00:16:08,530 --> 00:16:14,170
idea to just learn how to use device

00:16:12,130 --> 00:16:17,860
tree properly if you've been working on

00:16:14,170 --> 00:16:19,030
two point six for three years and you

00:16:17,860 --> 00:16:22,030
actually want to have a play with a

00:16:19,030 --> 00:16:24,310
modern kernel for once because I see a

00:16:22,030 --> 00:16:29,140
lot of people copying and pasting stuff

00:16:24,310 --> 00:16:31,990
out of similar DT s's and it's a really

00:16:29,140 --> 00:16:33,880
good idea to understand how to go

00:16:31,990 --> 00:16:36,970
through the documentation and see

00:16:33,880 --> 00:16:40,600
exactly what attributes are available to

00:16:36,970 --> 00:16:43,210
you not just rely on well this looks

00:16:40,600 --> 00:16:47,740
like the right thing but I don't really

00:16:43,210 --> 00:16:49,720
know how to customise it properly so

00:16:47,740 --> 00:16:52,330
that was an example of don't blindly

00:16:49,720 --> 00:16:54,940
forward bought this one in turn turns

00:16:52,330 --> 00:16:57,160
out the best solution was the just

00:16:54,940 --> 00:16:59,740
forward port the changes so the lesson

00:16:57,160 --> 00:17:02,410
there was take everything on a

00:16:59,740 --> 00:17:04,300
case-by-case basis sometimes easier to

00:17:02,410 --> 00:17:08,760
just take the customizations for a

00:17:04,300 --> 00:17:08,760
platform and just move them forward so

00:17:09,060 --> 00:17:18,100
the display and come back to that our

00:17:11,860 --> 00:17:20,110
FBI display interface this is where I'd

00:17:18,100 --> 00:17:23,940
said yeah I think we'll be adding the

00:17:20,110 --> 00:17:27,339
display get you the next build next week

00:17:23,940 --> 00:17:30,340
after going to turn on in the menu

00:17:27,339 --> 00:17:33,610
config not being able to find this and

00:17:30,340 --> 00:17:36,670
then establishing that when I mark it is

00:17:33,610 --> 00:17:39,130
unbroken and build it it doesn't build

00:17:36,670 --> 00:17:43,000
yeah I was like not gonna have that

00:17:39,130 --> 00:17:44,800
ready after all for you know the next

00:17:43,000 --> 00:17:48,790
build

00:17:44,800 --> 00:17:51,490
so yeah it works through it's basically

00:17:48,790 --> 00:17:55,300
a case of working through fixing up the

00:17:51,490 --> 00:17:58,060
our FBI driver to work again in 4.14

00:17:55,300 --> 00:18:01,360
because I think it just fallen into

00:17:58,060 --> 00:18:05,710
disuse not many people use that display

00:18:01,360 --> 00:18:07,600
output on that platform and looking

00:18:05,710 --> 00:18:10,510
through the commit history I did see

00:18:07,600 --> 00:18:11,980
that actually all all the changes now

00:18:10,510 --> 00:18:15,880
supposed to be going on in the direct

00:18:11,980 --> 00:18:17,740
rendering manager where a lot of the all

00:18:15,880 --> 00:18:20,620
of the old map display drivers have been

00:18:17,740 --> 00:18:22,810
copied over to a new place and that's

00:18:20,620 --> 00:18:26,290
where I should have been working on it

00:18:22,810 --> 00:18:28,180
but again in the real world the best way

00:18:26,290 --> 00:18:30,070
to do this in a timely manner was just

00:18:28,180 --> 00:18:34,270
to fix it up where the driver have been

00:18:30,070 --> 00:18:38,320
left behind as is and it would be nice

00:18:34,270 --> 00:18:40,690
to upstream that change but in order to

00:18:38,320 --> 00:18:42,430
do that I will probably have to move it

00:18:40,690 --> 00:18:44,530
to the right place before we get

00:18:42,430 --> 00:18:46,450
accepted because they say why are you

00:18:44,530 --> 00:18:48,340
changing over there that's old and

00:18:46,450 --> 00:18:54,940
there's no active development going on

00:18:48,340 --> 00:18:56,560
there and also again looking around the

00:18:54,940 --> 00:18:59,230
source tree to make sure you're not

00:18:56,560 --> 00:19:01,420
reinventing the wheel I was like well

00:18:59,230 --> 00:19:05,830
I've got an H X 8 3 something something

00:19:01,420 --> 00:19:08,290
which outputs to an ili 9 8 something oh

00:19:05,830 --> 00:19:10,840
there's some drivers in the staging tree

00:19:08,290 --> 00:19:12,430
here the chips that sound like that and

00:19:10,840 --> 00:19:15,730
looking through the data sheets yes some

00:19:12,430 --> 00:19:19,330
of those chips do have my PD bi as one

00:19:15,730 --> 00:19:21,250
of their interfaces but the way that

00:19:19,330 --> 00:19:24,790
that's all of those drivers kind of

00:19:21,250 --> 00:19:27,970
intended for s bi decoders hanging off

00:19:24,790 --> 00:19:30,190
of smaller micros and the way they were

00:19:27,970 --> 00:19:33,300
all plumbed together in software is it's

00:19:30,190 --> 00:19:38,080
like a world away from how an old map

00:19:33,300 --> 00:19:41,590
goes through a display subsystem to do

00:19:38,080 --> 00:19:44,350
its graphics so I sort of thought okay I

00:19:41,590 --> 00:19:48,610
don't feel like I'm reproducing anything

00:19:44,350 --> 00:19:51,100
major here but the point is to just make

00:19:48,610 --> 00:19:53,050
sure there aren't already some drivers

00:19:51,100 --> 00:19:58,090
hiding somewhere in the tree that you

00:19:53,050 --> 00:19:58,610
could use so yeah that's once I got it

00:19:58,090 --> 00:20:01,040
building

00:19:58,610 --> 00:20:03,650
and the driver was reporting it was

00:20:01,040 --> 00:20:05,980
happy I was expecting something to come

00:20:03,650 --> 00:20:09,950
up on the display and there was nothing

00:20:05,980 --> 00:20:12,320
so yeah I went through the sort of usual

00:20:09,950 --> 00:20:13,970
troubleshooting of approach as you can

00:20:12,320 --> 00:20:16,790
see I was really concerned about those

00:20:13,970 --> 00:20:18,740
clocks came to back to those three times

00:20:16,790 --> 00:20:21,250
to be fair the second time I did find

00:20:18,740 --> 00:20:24,470
some of them weren't actually turned on

00:20:21,250 --> 00:20:26,150
at which point it yeah it was counting

00:20:24,470 --> 00:20:28,780
down the pixels remaining to be outputs

00:20:26,150 --> 00:20:33,380
to zero and doing an interrupt so

00:20:28,780 --> 00:20:35,660
eventually I found looking through the

00:20:33,380 --> 00:20:37,040
schematics again which is a popular

00:20:35,660 --> 00:20:39,140
hobby for someone who can't get their

00:20:37,040 --> 00:20:42,140
driver working

00:20:39,140 --> 00:20:44,570
I did find now I should know that on a

00:20:42,140 --> 00:20:46,460
real schematic they don't put it all on

00:20:44,570 --> 00:20:48,260
the same page I'm sure you've seen this

00:20:46,460 --> 00:20:51,799
right that's probably look at them every

00:20:48,260 --> 00:20:53,780
day as well so when you've got a level

00:20:51,799 --> 00:20:56,210
shifter there and it's got two voltage

00:20:53,780 --> 00:20:58,580
rails coming out of it it's you know if

00:20:56,210 --> 00:21:01,160
you're busy it's easy to assume they're

00:20:58,580 --> 00:21:02,840
just fixed power rails right and when

00:21:01,160 --> 00:21:05,150
you come back again for maybe the eighth

00:21:02,840 --> 00:21:06,860
time you realize oh actually they go

00:21:05,150 --> 00:21:12,340
into the P macand you need to turn them

00:21:06,860 --> 00:21:15,740
on and you can see here some 2.6 error

00:21:12,340 --> 00:21:19,309
platform code the ones favorite kind of

00:21:15,740 --> 00:21:24,169
code right there it is a big time it

00:21:19,309 --> 00:21:30,710
would turn on the regulator's in the pea

00:21:24,169 --> 00:21:34,100
Mick so the point is a really good thing

00:21:30,710 --> 00:21:37,910
to do when you embark on forward forcing

00:21:34,100 --> 00:21:40,160
a long way in terms of a colonel would

00:21:37,910 --> 00:21:43,610
be to go through all your platform code

00:21:40,160 --> 00:21:45,760
there's custom to your device and audit

00:21:43,610 --> 00:21:51,020
that and make sure it is all reproduced

00:21:45,760 --> 00:21:52,850
correctly in device tree source because

00:21:51,020 --> 00:21:55,520
it's like doing a code review it's more

00:21:52,850 --> 00:21:57,410
optimal than rice in the bad code and

00:21:55,520 --> 00:22:00,020
debugging it afterwards it's better to

00:21:57,410 --> 00:22:02,270
just make sure you've turned everything

00:22:00,020 --> 00:22:09,710
on properly instead of waiting for it to

00:22:02,270 --> 00:22:11,950
not work so then it came to putting

00:22:09,710 --> 00:22:16,760
Android back on

00:22:11,950 --> 00:22:18,920
and yeah it's not quite as simple as

00:22:16,760 --> 00:22:20,960
just yeah I take that test routes Aversa

00:22:18,920 --> 00:22:26,030
way and put the Android images back and

00:22:20,960 --> 00:22:30,080
it just boots to start I hadn't put the

00:22:26,030 --> 00:22:32,090
client done anything with the GPU yet so

00:22:30,080 --> 00:22:34,790
I just told Android to render in

00:22:32,090 --> 00:22:41,870
software which I expected would be a bit

00:22:34,790 --> 00:22:44,870
slow and then when I did put the Android

00:22:41,870 --> 00:22:49,070
images back they didn't just boot and

00:22:44,870 --> 00:22:51,590
you've got unpack um disk keep adding

00:22:49,070 --> 00:22:53,030
more utilities in there eventually

00:22:51,590 --> 00:22:54,710
putting a whole shell in there so I

00:22:53,030 --> 00:22:58,730
could just boot into the Android gram

00:22:54,710 --> 00:23:01,520
disk try and manually chivvy it into

00:22:58,730 --> 00:23:03,770
life and slowly established

00:23:01,520 --> 00:23:08,809
yeah the kernels missing various things

00:23:03,770 --> 00:23:10,730
Android needs obviously in hindsight so

00:23:08,809 --> 00:23:13,550
there's the first two that was just a

00:23:10,730 --> 00:23:15,350
case of forward forcing those as is from

00:23:13,550 --> 00:23:19,010
the latest kernel where they were

00:23:15,350 --> 00:23:22,010
present they'd been taken out because

00:23:19,010 --> 00:23:26,300
Android had become more better in later

00:23:22,010 --> 00:23:30,710
releases just working on a more vanilla

00:23:26,300 --> 00:23:36,320
kernel Android debug bridge wasn't

00:23:30,710 --> 00:23:38,600
working and this is an example of again

00:23:36,320 --> 00:23:42,320
don't blindly forward pork because I

00:23:38,600 --> 00:23:45,020
started to take the latest available

00:23:42,320 --> 00:23:48,410
version of the Android composite USB

00:23:45,020 --> 00:23:51,620
gadget driver tried to force that into

00:23:48,410 --> 00:23:56,390
the new kernel it turned out it wasn't

00:23:51,620 --> 00:23:58,400
gonna be an easy job and I thought well

00:23:56,390 --> 00:24:01,340
how does the newer releases of Android

00:23:58,400 --> 00:24:03,860
to deal without this driver and after

00:24:01,340 --> 00:24:07,420
reading up found that well actually it

00:24:03,860 --> 00:24:10,550
uses the standard USB gadget config of s

00:24:07,420 --> 00:24:11,630
framework to create a composite USB

00:24:10,550 --> 00:24:13,460
device on the fly

00:24:11,630 --> 00:24:15,590
or when did that get added to Android

00:24:13,460 --> 00:24:17,660
having to be in the release that I was

00:24:15,590 --> 00:24:20,120
using so it's just a simple case of

00:24:17,660 --> 00:24:23,660
telling it do that instead of using the

00:24:20,120 --> 00:24:24,559
old driver and everything was all okay

00:24:23,660 --> 00:24:30,320
with a bit of

00:24:24,559 --> 00:24:32,389
system configuration so again take

00:24:30,320 --> 00:24:34,070
everything on a case-by-case basis and

00:24:32,389 --> 00:24:36,559
establish what the path of least

00:24:34,070 --> 00:24:39,919
resistance is sometimes it is easier to

00:24:36,559 --> 00:24:44,870
forward port other times it's better to

00:24:39,919 --> 00:24:47,360
do it a much newer way so got to the

00:24:44,870 --> 00:24:50,389
points where the test team had an

00:24:47,360 --> 00:24:52,429
Android device that they could test with

00:24:50,389 --> 00:24:55,820
the same test cases that the old colonel

00:24:52,429 --> 00:24:58,029
was using the HAP team had something

00:24:55,820 --> 00:25:02,360
they can plug into Android studio and

00:24:58,029 --> 00:25:05,299
load their app onto and run it and if

00:25:02,360 --> 00:25:07,789
you're wondering if you upgrade an

00:25:05,299 --> 00:25:10,340
android kitkat device to a four point X

00:25:07,789 --> 00:25:12,289
kernel it doesn't just print the kernel

00:25:10,340 --> 00:25:14,419
version there there's like a regex

00:25:12,289 --> 00:25:17,090
in some Java somewhere which doesn't

00:25:14,419 --> 00:25:19,220
work with that version so I had to go

00:25:17,090 --> 00:25:20,840
and manually alter that because I'll be

00:25:19,220 --> 00:25:22,730
damned if I'm gonna update the kernel on

00:25:20,840 --> 00:25:27,080
this thing it's not gonna print it in my

00:25:22,730 --> 00:25:29,720
about device screen so the tech that the

00:25:27,080 --> 00:25:32,659
feedback from the test team initially

00:25:29,720 --> 00:25:35,240
apart from her a well done was it's a

00:25:32,659 --> 00:25:38,119
bit slow and I was like yeah that'd be

00:25:35,240 --> 00:25:43,749
that GPU then so didn't quite get the

00:25:38,119 --> 00:25:49,220
brake hose open for like that rest so

00:25:43,749 --> 00:25:51,549
this is a graph of a trace which is an

00:25:49,220 --> 00:25:53,509
Android version of system trace

00:25:51,549 --> 00:25:56,409
basically comes out of the kernel

00:25:53,509 --> 00:25:57,619
function tracer and makes a nice charts

00:25:56,409 --> 00:26:01,070
for you

00:25:57,619 --> 00:26:03,950
and those solid bars at the bottom the

00:26:01,070 --> 00:26:07,009
graphics taking all of the time before

00:26:03,950 --> 00:26:09,889
the next display updates to fill the

00:26:07,009 --> 00:26:11,360
frame and on that platform at least that

00:26:09,889 --> 00:26:13,070
would just slow the whole system down

00:26:11,360 --> 00:26:18,559
because it seemed to all seem to be

00:26:13,070 --> 00:26:21,110
timed off of the display update so all

00:26:18,559 --> 00:26:25,399
I'll just summarize reenable in the GPU

00:26:21,110 --> 00:26:29,749
support as there is a binary library and

00:26:25,399 --> 00:26:31,999
daemon in userspace and a kernel glue

00:26:29,749 --> 00:26:35,460
module lots of versioning and

00:26:31,999 --> 00:26:37,649
possibility and it's just a big pain

00:26:35,460 --> 00:26:41,659
I think that's all anyone wants to know

00:26:37,649 --> 00:26:41,659
about binary only GPUs right

00:26:41,840 --> 00:26:47,640
now what makes a product sub products

00:26:44,640 --> 00:26:50,549
are not just a board with a few drivers

00:26:47,640 --> 00:26:52,830
on it it's all the stuff in between all

00:26:50,549 --> 00:26:56,580
right so if you work at the products end

00:26:52,830 --> 00:26:59,880
of Linux on devices you'll be familiar

00:26:56,580 --> 00:27:02,520
with system integration which is getting

00:26:59,880 --> 00:27:05,070
it ready for a member of the general

00:27:02,520 --> 00:27:08,450
public to use who doesn't want to plug

00:27:05,070 --> 00:27:11,130
their debug serial port into the thing

00:27:08,450 --> 00:27:14,390
so yeah I sort of played around with an

00:27:11,130 --> 00:27:17,250
and to get that more optimally set up

00:27:14,390 --> 00:27:19,919
had some trouble with the GPIO numbering

00:27:17,250 --> 00:27:25,440
just randomly changing every time you

00:27:19,919 --> 00:27:27,330
boot the device and yeah the ADB and the

00:27:25,440 --> 00:27:29,880
GPU kind of took a few more goes around

00:27:27,330 --> 00:27:32,370
or two more goes each so to get them

00:27:29,880 --> 00:27:37,110
working properly in Windows what for the

00:27:32,370 --> 00:27:39,330
ADB stuff so yeah as I said as a

00:27:37,110 --> 00:27:42,059
reference for anyone the weather wants

00:27:39,330 --> 00:27:45,390
to or ever gets tasked with doing

00:27:42,059 --> 00:27:47,520
something similar themselves it might be

00:27:45,390 --> 00:27:50,220
useful to have some figures about how

00:27:47,520 --> 00:27:52,649
long this example took as a reference

00:27:50,220 --> 00:27:56,159
I appreciate might be hard to read those

00:27:52,649 --> 00:27:58,380
numbers but the gantry you can see from

00:27:56,159 --> 00:28:02,549
the Gantt chart there's 20 weeks showing

00:27:58,380 --> 00:28:05,220
there and the longest bar at the top was

00:28:02,549 --> 00:28:08,549
that our FBI driver and then the longest

00:28:05,220 --> 00:28:11,039
bits at the bottom of the GPU stuff once

00:28:08,549 --> 00:28:17,520
and then again when the vsync wasn't

00:28:11,039 --> 00:28:19,140
firing properly the vsync interrupts so

00:28:17,520 --> 00:28:24,120
I'll just leave these up for a few

00:28:19,140 --> 00:28:26,760
seconds now in reality because of the

00:28:24,120 --> 00:28:31,140
scheduling of this work it was done on a

00:28:26,760 --> 00:28:34,169
part-time basis so what I did was take

00:28:31,140 --> 00:28:38,159
the hours and we plot them on that chart

00:28:34,169 --> 00:28:41,250
as as if they were done as eight hour

00:28:38,159 --> 00:28:47,610
work days so it's 20 weeks based on a

00:28:41,250 --> 00:28:49,110
40-hour week those 94 days well about

00:28:47,610 --> 00:28:53,880
800 hours of work

00:28:49,110 --> 00:28:57,090
in total so yeah just to summarize again

00:28:53,880 --> 00:29:02,790
the main kind of lessons learnt during

00:28:57,090 --> 00:29:06,000
this particular example if you want to

00:29:02,790 --> 00:29:09,270
broach the subject of come on guys let's

00:29:06,000 --> 00:29:11,550
update this turn already it's much

00:29:09,270 --> 00:29:13,440
easier cell if you say well let's just

00:29:11,550 --> 00:29:16,320
establish it's gonna fix what we need

00:29:13,440 --> 00:29:21,210
first and just estimate on that basis

00:29:16,320 --> 00:29:24,809
and then they can decide from there take

00:29:21,210 --> 00:29:27,179
each driver or piece of platform

00:29:24,809 --> 00:29:29,460
customization on a case-by-case basis

00:29:27,179 --> 00:29:36,630
some things are easier so just forward

00:29:29,460 --> 00:29:39,690
ports like the well the GPU drivers in

00:29:36,630 --> 00:29:43,260
this case in the kernel or to leave

00:29:39,690 --> 00:29:47,400
behind Android composite USB gadget the

00:29:43,260 --> 00:29:49,080
backlight driver what to extend the new

00:29:47,400 --> 00:29:52,140
implementation of backlight as an

00:29:49,080 --> 00:29:55,740
example go through all your platform

00:29:52,140 --> 00:29:58,620
data at the beginning and plan outs we

00:29:55,740 --> 00:30:03,000
implementing it in you probably in your

00:29:58,620 --> 00:30:05,700
device tree now this is more of a

00:30:03,000 --> 00:30:07,200
personal lesson for me because yeah like

00:30:05,700 --> 00:30:09,990
I said there's some changes that I would

00:30:07,200 --> 00:30:12,300
have liked the upstream out of this is

00:30:09,990 --> 00:30:13,920
much easier and I'm sure many of you

00:30:12,300 --> 00:30:16,200
know this to do it while you're doing

00:30:13,920 --> 00:30:18,360
the work don't let the project gather

00:30:16,200 --> 00:30:20,550
dust and come back to thinking I

00:30:18,360 --> 00:30:22,710
wouldn't be great to upstream some stuff

00:30:20,550 --> 00:30:24,960
but head of this conference you got to

00:30:22,710 --> 00:30:27,710
get it all out again you actually have

00:30:24,960 --> 00:30:31,670
to do some changes to make it acceptable

00:30:27,710 --> 00:30:37,770
upstream so that's kind of planned out

00:30:31,670 --> 00:30:40,200
for the future and yeah every project

00:30:37,770 --> 00:30:42,870
has different challenges in this case

00:30:40,200 --> 00:30:45,480
getting a new account on there it was

00:30:42,870 --> 00:30:47,550
actually relatively easy because a lot

00:30:45,480 --> 00:30:49,920
of the platform support was already in

00:30:47,550 --> 00:30:56,429
the tree your mileage might vary

00:30:49,920 --> 00:31:00,300
depending on your system on chip ok I

00:30:56,429 --> 00:31:02,870
finished quite in time unexpectedly so

00:31:00,300 --> 00:31:07,670
does anyone have any questions

00:31:02,870 --> 00:31:19,730
yes looks like I'm doing my own mic

00:31:07,670 --> 00:31:23,770
running come on guys thank you for the

00:31:19,730 --> 00:31:26,810
nice talk I didn't get how you handled

00:31:23,770 --> 00:31:29,510
specific I mean Colonel Android kernel

00:31:26,810 --> 00:31:32,030
features like ash ma'am I'm staying with

00:31:29,510 --> 00:31:34,850
the older Android user space how how did

00:31:32,030 --> 00:31:39,170
you handle that well for the ash man I

00:31:34,850 --> 00:31:41,990
literally took the ash man C file copied

00:31:39,170 --> 00:31:44,300
it into the new kernel tree and I think

00:31:41,990 --> 00:31:47,290
those may be a few little bits about

00:31:44,300 --> 00:31:48,560
five lines of changes just to get it to

00:31:47,290 --> 00:31:50,600
work

00:31:48,560 --> 00:31:53,780
thankfully that's quite a self contained

00:31:50,600 --> 00:31:58,490
driver so it really just worked as is

00:31:53,780 --> 00:32:03,980
across the kernel versions so that that

00:31:58,490 --> 00:32:06,170
was that one when I rehearsed this talk

00:32:03,980 --> 00:32:08,960
the feedback was well we're not really

00:32:06,170 --> 00:32:11,450
interested in Android edit so just talk

00:32:08,960 --> 00:32:13,400
about generic kernel stuff so I tried to

00:32:11,450 --> 00:32:16,730
sort of gloss over the Android stuff a

00:32:13,400 --> 00:32:17,870
bit to make time but come talk to me

00:32:16,730 --> 00:32:19,940
afterwards if you want to hear more

00:32:17,870 --> 00:32:22,640
about running old Android on a new

00:32:19,940 --> 00:32:24,170
kernel because I've seen a few mentions

00:32:22,640 --> 00:32:29,300
online about it but I don't think many

00:32:24,170 --> 00:32:31,250
people are doing it but the thing you

00:32:29,300 --> 00:32:32,930
can update a kernel on a device I'm sure

00:32:31,250 --> 00:32:34,760
many of you know this and it doesn't

00:32:32,930 --> 00:32:37,610
really impact system performance if you

00:32:34,760 --> 00:32:41,000
update update Android from KitKat to say

00:32:37,610 --> 00:32:42,950
two releases near your device is going

00:32:41,000 --> 00:32:43,340
to slow to a crawl it's just not gonna

00:32:42,950 --> 00:32:46,960
happen

00:32:43,340 --> 00:32:52,520
so that's why I stuck with the older

00:32:46,960 --> 00:32:54,250
KitKat Android released all right thank

00:32:52,520 --> 00:33:00,110
you you anticipated all my questions

00:32:54,250 --> 00:33:03,140
okay anyone else got any questions no

00:33:00,110 --> 00:33:04,970
okay well if you if you're just feeling

00:33:03,140 --> 00:33:06,800
you're shy come on up to the front and

00:33:04,970 --> 00:33:11,320
ask me or send me an email

00:33:06,800 --> 00:33:11,320

YouTube URL: https://www.youtube.com/watch?v=l8Y92EgT-lA


