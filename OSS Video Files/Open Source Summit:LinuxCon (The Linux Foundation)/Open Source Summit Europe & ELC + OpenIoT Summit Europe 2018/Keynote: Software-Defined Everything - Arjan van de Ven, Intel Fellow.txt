Title: Keynote: Software-Defined Everything - Arjan van de Ven, Intel Fellow
Publication date: 2018-10-22
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Keynote: Software-Defined Everything - Arjan van de Ven, Intel Fellow & Director of Linux Systems Engineering, Open Source Technology Center, Intel 

About Arjan van de Ven
Arjan van de Ven is an Intel Fellow as well as director of Linux Systems Engineering in the Open Source Technology Center at Intel Corporation. Arjan’s passion is addressing the seemingly impossible through technical innovation, such as Clear Containers with Intel® Virtualization Technology and the Clear Linux OS. He is a key contributor to silicon architecture and helps Intel business groups define future processor/platform features.

Arjan is a frequent speaker at open source conferences and often presents Intel Linux and open source strategy with analysts. He’s has been granted 21 patents and holds dual master’s degrees: business administration from Tilburg University-TIAS Business School and electrotechnical engineering from Eindhoven University.
Captions: 
	00:00:00,000 --> 00:00:05,100
hello I'm going to talk about something

00:00:02,970 --> 00:00:07,919
that we call it Intel software to find

00:00:05,100 --> 00:00:11,269
everything and I know this is embedded

00:00:07,919 --> 00:00:13,040
conference and know software-defined

00:00:11,269 --> 00:00:16,190
networking software on computers

00:00:13,040 --> 00:00:18,210
historically a data center thing and

00:00:16,190 --> 00:00:19,740
because this is an embedded conference I

00:00:18,210 --> 00:00:25,170
want to at least touch a few things on

00:00:19,740 --> 00:00:26,189
that's it software-defined compute we

00:00:25,170 --> 00:00:29,029
all know what it is it's about

00:00:26,189 --> 00:00:31,019
virtualization containers isolation

00:00:29,029 --> 00:00:33,329
performance those kind of things it's

00:00:31,019 --> 00:00:35,550
about slicing a system into something

00:00:33,329 --> 00:00:38,879
that is dynamic that you can run by the

00:00:35,550 --> 00:00:41,850
second that you can spin up spin down so

00:00:38,879 --> 00:00:44,100
for the final networking well it avoids

00:00:41,850 --> 00:00:46,020
having to run a wire somewhere I kid you

00:00:44,100 --> 00:00:47,789
want to change your world you want to

00:00:46,020 --> 00:00:49,289
change an application you don't have to

00:00:47,789 --> 00:00:51,360
call the network guide to run a wire

00:00:49,289 --> 00:00:52,219
from building a to building B so for the

00:00:51,360 --> 00:00:55,050
file storage

00:00:52,219 --> 00:00:56,610
same concept you you you turn something

00:00:55,050 --> 00:00:59,460
physical into something more enjoyable

00:00:56,610 --> 00:01:03,090
and this has driven the data center this

00:00:59,460 --> 00:01:04,920
has driven the cloud and as Jim talked

00:01:03,090 --> 00:01:07,170
earlier about cloud native computing at

00:01:04,920 --> 00:01:08,939
all it enabled a whole new world on top

00:01:07,170 --> 00:01:11,520
of this sort of software-defined

00:01:08,939 --> 00:01:15,390
infrastructure you have dynamic capacity

00:01:11,520 --> 00:01:18,920
have flexibility and that allowed the

00:01:15,390 --> 00:01:21,210
new class of applications you have

00:01:18,920 --> 00:01:24,450
machine learning or at scale you have

00:01:21,210 --> 00:01:26,659
Hadoop you have SPARC you have many of

00:01:24,450 --> 00:01:28,860
these applications that are no longer a

00:01:26,659 --> 00:01:31,409
small little thing in a box but they're

00:01:28,860 --> 00:01:34,650
actually based on scaling infrastructure

00:01:31,409 --> 00:01:37,170
scaling up scaling down this was cloud

00:01:34,650 --> 00:01:38,640
and if you it's almost a slide I could

00:01:37,170 --> 00:01:40,170
have put almost almost almost screen two

00:01:38,640 --> 00:01:41,250
years ago five years ago when this was

00:01:40,170 --> 00:01:44,369
cloud No

00:01:41,250 --> 00:01:47,340
so further find everything is basically

00:01:44,369 --> 00:01:49,710
admitting that the software-defined data

00:01:47,340 --> 00:01:51,780
architecture data center architecture is

00:01:49,710 --> 00:01:54,200
becoming the architecture of everything

00:01:51,780 --> 00:01:58,020
it's a dominant design pattern that

00:01:54,200 --> 00:01:59,250
really is going to dominate every single

00:01:58,020 --> 00:02:03,659
industry we our software is running

00:01:59,250 --> 00:02:06,450
today we know the cloud but it's also

00:02:03,659 --> 00:02:08,940
taking over IOT your nest thermostat

00:02:06,450 --> 00:02:10,800
it's just an example of Software Defined

00:02:08,940 --> 00:02:13,290
everything half the application of your

00:02:10,800 --> 00:02:15,930
thermostat is running in the cloud

00:02:13,290 --> 00:02:18,330
half of your light bulbs if you don't

00:02:15,930 --> 00:02:19,830
think about it half of what making your

00:02:18,330 --> 00:02:23,100
light bulb smart is actually not in your

00:02:19,830 --> 00:02:24,840
house it's somewhere else and that's

00:02:23,100 --> 00:02:26,190
something that everybody keeps talking

00:02:24,840 --> 00:02:30,090
about edge what is the edge

00:02:26,190 --> 00:02:33,150
well edge is a cloud distributed or it

00:02:30,090 --> 00:02:36,210
is your home to the cloud all of these

00:02:33,150 --> 00:02:38,520
industries and is are taking over the

00:02:36,210 --> 00:02:41,460
paranor software-defined everything in

00:02:38,520 --> 00:02:43,230
this field an example of the next

00:02:41,460 --> 00:02:45,320
generation of evolution and I was in

00:02:43,230 --> 00:02:47,400
China a few weeks ago where they really

00:02:45,320 --> 00:02:49,830
Romania factoring is fundamentally

00:02:47,400 --> 00:02:51,960
changing rather than building a factory

00:02:49,830 --> 00:02:54,360
for building one specific product really

00:02:51,960 --> 00:02:57,750
they make an more generic factory that

00:02:54,360 --> 00:02:59,790
take this software can define at the

00:02:57,750 --> 00:03:01,950
time of production what they want to do

00:02:59,790 --> 00:03:03,570
rather than retooling for four weeks to

00:03:01,950 --> 00:03:05,610
change products they can retool in

00:03:03,570 --> 00:03:08,700
minutes to a new building a new new

00:03:05,610 --> 00:03:10,710
device after that the hardest part that

00:03:08,700 --> 00:03:12,540
we haven't conquered yet is automotive

00:03:10,710 --> 00:03:16,410
and Jim talked about automotive Linux

00:03:12,540 --> 00:03:18,660
earlier but a car is hard if you buy a

00:03:16,410 --> 00:03:21,989
car today and you coat you or you see

00:03:18,660 --> 00:03:23,910
one outside here a typical modern car as

00:03:21,989 --> 00:03:25,680
about a hundred microcontrollers so when

00:03:23,910 --> 00:03:28,170
I control your brakes your your tire

00:03:25,680 --> 00:03:34,410
pressure as a whole what about a hundred

00:03:28,170 --> 00:03:38,160
little CPUs doing things these CPUs run

00:03:34,410 --> 00:03:39,660
about eight operating systems that's

00:03:38,160 --> 00:03:43,170
about a hundred million lines of carnac

00:03:39,660 --> 00:03:45,480
code in a car from the dashboard to your

00:03:43,170 --> 00:03:49,010
brakes to Android for the kids in the

00:03:45,480 --> 00:03:51,330
back it's all complicated and

00:03:49,010 --> 00:03:57,630
complicated systems that are fixed are

00:03:51,330 --> 00:03:58,950
rigid are sort of the past so the cars

00:03:57,630 --> 00:04:00,720
becoming the data center and when you go

00:03:58,950 --> 00:04:03,660
to a self-driving car it is even more

00:04:00,720 --> 00:04:04,890
obvious you have a stunning amount of

00:04:03,660 --> 00:04:07,320
machine learning it's a stunning amount

00:04:04,890 --> 00:04:11,250
of map data that all makes a car a data

00:04:07,320 --> 00:04:15,540
center so what makes cars hard what

00:04:11,250 --> 00:04:18,269
makes cars heart is safety if you run

00:04:15,540 --> 00:04:20,459
your Amazon machine and once a while you

00:04:18,269 --> 00:04:22,200
have a little stutter for 10

00:04:20,459 --> 00:04:24,450
milliseconds or another seconds and it's

00:04:22,200 --> 00:04:26,250
back to business you don't notice if

00:04:24,450 --> 00:04:26,520
your braking system at 100 millisecond

00:04:26,250 --> 00:04:31,020
delay

00:04:26,520 --> 00:04:33,990
you kind of notice so the car is a

00:04:31,020 --> 00:04:36,560
little has a set of constraints that are

00:04:33,990 --> 00:04:38,879
a little harder than the data center and

00:04:36,560 --> 00:04:41,250
functionally safe and Jim mentioned it

00:04:38,879 --> 00:04:43,110
earlier functional safety is actually

00:04:41,250 --> 00:04:43,949
the next barrier for Software Defined

00:04:43,110 --> 00:04:45,900
everything

00:04:43,949 --> 00:04:47,550
how do you do software to find

00:04:45,900 --> 00:04:50,280
everything in a world where functionally

00:04:47,550 --> 00:04:52,229
safe matters and again safety is about

00:04:50,280 --> 00:04:56,990
not dying when you when you push your

00:04:52,229 --> 00:04:59,759
brake pad at intro we look at this in a

00:04:56,990 --> 00:05:02,159
sort of an architecture where you have a

00:04:59,759 --> 00:05:04,830
system where part of the system is

00:05:02,159 --> 00:05:07,500
functional safe but parts of the system

00:05:04,830 --> 00:05:09,060
run more generic applications and they

00:05:07,500 --> 00:05:11,190
have to interact together and awaited to

00:05:09,060 --> 00:05:16,229
still save but you have flexibility for

00:05:11,190 --> 00:05:17,819
the applications and that's what your

00:05:16,229 --> 00:05:21,419
logos on this slide I'll cover somewhat

00:05:17,819 --> 00:05:24,090
I'm a little bit later in this

00:05:21,419 --> 00:05:27,000
software-defined world one thing we're

00:05:24,090 --> 00:05:28,800
really realizing is the old paradigm of

00:05:27,000 --> 00:05:30,930
hey we add a feature over here we add a

00:05:28,800 --> 00:05:33,270
feature over there it's kind of breaking

00:05:30,930 --> 00:05:36,270
down and that if you have very complex

00:05:33,270 --> 00:05:38,190
technology said that took a touch many

00:05:36,270 --> 00:05:41,219
pieces on the software stack you really

00:05:38,190 --> 00:05:42,870
have to build the whole stack and test

00:05:41,219 --> 00:05:44,430
it and optimize it to make sure that you

00:05:42,870 --> 00:05:47,219
don't miss a little piece here or that

00:05:44,430 --> 00:05:48,330
it's all work together well that's until

00:05:47,219 --> 00:05:50,639
we care about performance we add

00:05:48,330 --> 00:05:53,729
features to our CPUs when we add a new

00:05:50,639 --> 00:05:55,919
instruction like let's say X 512 it

00:05:53,729 --> 00:05:57,270
turns out that the the pieces of

00:05:55,919 --> 00:05:59,669
software you have to touch to make this

00:05:57,270 --> 00:06:01,710
work all the way to the end user is a

00:05:59,669 --> 00:06:03,389
stunning amount yeah sure we have a

00:06:01,710 --> 00:06:05,250
kernel patch which is ten lines that's

00:06:03,389 --> 00:06:07,680
easy there's a compiler change I would

00:06:05,250 --> 00:06:09,029
get a sea change - turns out you have to

00:06:07,680 --> 00:06:12,000
hit search KVM you have to touch

00:06:09,029 --> 00:06:14,250
kubernetes you have to touch your whole

00:06:12,000 --> 00:06:16,560
OpenStack whatever prostration layer you

00:06:14,250 --> 00:06:18,000
put or below or above it you have to

00:06:16,560 --> 00:06:19,919
touch all the frameworks in the middle

00:06:18,000 --> 00:06:21,270
the math libraries all the way to the

00:06:19,919 --> 00:06:23,039
machine learning frameworks and even

00:06:21,270 --> 00:06:26,279
above that just for one little feature

00:06:23,039 --> 00:06:29,130
and the only chance you have to get that

00:06:26,279 --> 00:06:30,870
to work is to actually build but we end

00:06:29,130 --> 00:06:32,940
up calling a reference stack build it

00:06:30,870 --> 00:06:35,159
open source the stack even though it's

00:06:32,940 --> 00:06:38,279
just mostly configuration build it show

00:06:35,159 --> 00:06:39,070
it measure the performance analyze it

00:06:38,279 --> 00:06:41,650
and actually

00:06:39,070 --> 00:06:44,890
allow and the user to verify and see

00:06:41,650 --> 00:06:47,140
what it what it is doing machine

00:06:44,890 --> 00:06:49,030
learning is the obvious candidate there

00:06:47,140 --> 00:06:51,010
but we're looking at database as a

00:06:49,030 --> 00:06:53,200
service we're looking at all kinds of

00:06:51,010 --> 00:06:55,030
odd use cases where this sort of

00:06:53,200 --> 00:06:58,810
vertical stack integration is actually

00:06:55,030 --> 00:07:00,250
needed and actually it's hard and good I

00:06:58,810 --> 00:07:03,910
like our problems like Jen said so

00:07:00,250 --> 00:07:05,770
that's okay at the basis of these stacks

00:07:03,910 --> 00:07:10,150
as an operating system the kernel the

00:07:05,770 --> 00:07:12,580
next row is plugging my Hopi project or

00:07:10,150 --> 00:07:14,260
my sort of passion project the Cleo

00:07:12,580 --> 00:07:17,170
Linux project is that it's a

00:07:14,260 --> 00:07:18,910
distribution we make it Intel for for

00:07:17,170 --> 00:07:21,460
the last four or five years where you

00:07:18,910 --> 00:07:23,290
really want to sort of change a little

00:07:21,460 --> 00:07:24,880
bit how operating things are built but

00:07:23,290 --> 00:07:27,160
also have a place where we can actually

00:07:24,880 --> 00:07:30,640
innovate make sure all the pieces work

00:07:27,160 --> 00:07:32,200
together very well in order to sort of

00:07:30,640 --> 00:07:35,080
be the foundation of those vertical use

00:07:32,200 --> 00:07:37,720
cases if you look at any use case in the

00:07:35,080 --> 00:07:39,640
cloud Linux is at the bottom and earlier

00:07:37,720 --> 00:07:42,460
Jim talked about Linux is everywhere

00:07:39,640 --> 00:07:43,000
yeah today so it starts with a Linux

00:07:42,460 --> 00:07:45,310
layer

00:07:43,000 --> 00:07:47,400
it's opted with the Linux is for

00:07:45,310 --> 00:07:49,390
obviously optimized for the hardware

00:07:47,400 --> 00:07:51,340
functional safety is important because

00:07:49,390 --> 00:07:55,330
it starts at the bottom you need to have

00:07:51,340 --> 00:07:58,570
that layer where the foundation is can

00:07:55,330 --> 00:08:00,100
be functionally safe and that's as much

00:07:58,570 --> 00:08:01,930
as people here in the room like the

00:08:00,100 --> 00:08:03,570
right software functionally safe is a

00:08:01,930 --> 00:08:08,260
lot about prototypes and paperwork

00:08:03,570 --> 00:08:09,280
so there's a lot of that on there you

00:08:08,260 --> 00:08:10,900
need to be able to update you need

00:08:09,280 --> 00:08:13,840
you're able to write a modern software

00:08:10,900 --> 00:08:15,070
with using CI CD it's all those kind of

00:08:13,840 --> 00:08:20,440
things are part of how you build an

00:08:15,070 --> 00:08:21,580
operating system on top of that you have

00:08:20,440 --> 00:08:24,190
thought about weak but you can call the

00:08:21,580 --> 00:08:26,140
isolation layer and I said some people

00:08:24,190 --> 00:08:29,290
like VM some people like containers some

00:08:26,140 --> 00:08:31,630
people like a little bit of both but for

00:08:29,290 --> 00:08:33,760
a lot of the isolation layers people use

00:08:31,630 --> 00:08:34,990
virtual machines especially in a world

00:08:33,760 --> 00:08:37,570
where you need to be functionally safe

00:08:34,990 --> 00:08:40,390
and the limit foundation project called

00:08:37,570 --> 00:08:42,550
acorn is a very lightweight hypervisor

00:08:40,390 --> 00:08:43,840
what is really trying to be simple and

00:08:42,550 --> 00:08:46,150
small so that you could actually make

00:08:43,840 --> 00:08:47,350
safety claims about it somewhere that is

00:08:46,150 --> 00:08:49,360
about paperwork but somewhere that is

00:08:47,350 --> 00:08:51,100
about showing that no there aren't

00:08:49,360 --> 00:08:52,510
memory allocations that can fail and

00:08:51,100 --> 00:08:54,519
then that your brains don't work

00:08:52,510 --> 00:08:57,070
right you want to make sure that

00:08:54,519 --> 00:08:58,300
everything is configured upfront you

00:08:57,070 --> 00:09:00,220
know that nothing is going to fail or

00:08:58,300 --> 00:09:02,350
randomly on you so that if you hit the

00:09:00,220 --> 00:09:06,910
brake pedal you actually slow down the

00:09:02,350 --> 00:09:08,500
car that is actually hard and the simple

00:09:06,910 --> 00:09:10,899
hypervisor underneath allows you to

00:09:08,500 --> 00:09:11,829
partition a physical system in a part

00:09:10,899 --> 00:09:13,870
where I can make these kind of

00:09:11,829 --> 00:09:15,190
assemblies and claims and a part where

00:09:13,870 --> 00:09:18,370
you don't need to do that I can run more

00:09:15,190 --> 00:09:20,410
fancier software as some of it is you

00:09:18,370 --> 00:09:21,940
also have to figure out how do you do

00:09:20,410 --> 00:09:24,279
graphics because it turns out by

00:09:21,940 --> 00:09:26,500
regulation your speedometer in your car

00:09:24,279 --> 00:09:27,880
is actually safety critical thing if

00:09:26,500 --> 00:09:31,170
your speedometer doesn't work anymore

00:09:27,880 --> 00:09:33,550
you're not allowed to drive your car and

00:09:31,170 --> 00:09:35,079
sure so you have to have graphics that

00:09:33,550 --> 00:09:37,959
actually show this parameter and

00:09:35,079 --> 00:09:38,980
guarantee that it's there so graphics

00:09:37,959 --> 00:09:42,100
has to be shared you have to have real

00:09:38,980 --> 00:09:44,740
time it can be big and small footprint

00:09:42,100 --> 00:09:46,240
is not an optimization statement

00:09:44,740 --> 00:09:48,490
small footprint is really statement

00:09:46,240 --> 00:09:50,230
about can we do enough paperwork and an

00:09:48,490 --> 00:09:53,230
analysis to prove that my brakes will

00:09:50,230 --> 00:09:54,970
work and if you have a million lines of

00:09:53,230 --> 00:09:57,250
code you're not going to get there if

00:09:54,970 --> 00:09:58,600
you have twenty thirty thousand lines of

00:09:57,250 --> 00:10:00,850
code you have maybe a chance to be able

00:09:58,600 --> 00:10:02,889
to show that this code path cannot fail

00:10:00,850 --> 00:10:05,980
because there isn't there aren't

00:10:02,889 --> 00:10:10,540
constructs in a code that can fail so

00:10:05,980 --> 00:10:14,290
this is a quad the second layer of art

00:10:10,540 --> 00:10:17,019
is about the trade-off between speed and

00:10:14,290 --> 00:10:19,029
security and Jim talked about containers

00:10:17,019 --> 00:10:21,790
versus virtual machines a little bit

00:10:19,029 --> 00:10:24,630
it's historically people consider social

00:10:21,790 --> 00:10:28,870
machine secure containers they're fast

00:10:24,630 --> 00:10:32,410
they're sort of secure depending on your

00:10:28,870 --> 00:10:35,440
security pattern your threat model can

00:10:32,410 --> 00:10:37,720
we do security and speed I've talked

00:10:35,440 --> 00:10:40,300
many times before about a project we

00:10:37,720 --> 00:10:43,000
call clear containers that shows that a

00:10:40,300 --> 00:10:46,329
you can use a hypervisor as a backbone

00:10:43,000 --> 00:10:47,800
of your container infrastructure so that

00:10:46,329 --> 00:10:49,569
you use a container infrastructure for

00:10:47,800 --> 00:10:51,730
deploying your software but you can use

00:10:49,569 --> 00:10:55,360
the security of a virtual machine as for

00:10:51,730 --> 00:10:56,110
the isolation part we've partnered with

00:10:55,360 --> 00:10:58,329
hyper

00:10:56,110 --> 00:11:01,319
to run through the tool project called

00:10:58,329 --> 00:11:03,970
cotta containers which is really about

00:11:01,319 --> 00:11:06,250
making building an industry base between

00:11:03,970 --> 00:11:10,270
a series of partner companies

00:11:06,250 --> 00:11:13,000
and community contributors so that we

00:11:10,270 --> 00:11:16,600
have one container infrastructure based

00:11:13,000 --> 00:11:18,820
on virtualization and the end result is

00:11:16,600 --> 00:11:20,380
you have something light because it's

00:11:18,820 --> 00:11:22,750
containers but at the same time it's

00:11:20,380 --> 00:11:24,370
it's secure because the isolation is

00:11:22,750 --> 00:11:30,240
done using the fertilization harder of

00:11:24,370 --> 00:11:32,980
your system okay so that's half of it

00:11:30,240 --> 00:11:35,530
we've been if you look at a traditional

00:11:32,980 --> 00:11:38,590
hypervisor SATA pfk vm in the kernel you

00:11:35,530 --> 00:11:41,580
have qmu on top and you're on your guest

00:11:38,590 --> 00:11:45,010
iliza know in the VM it turns out that

00:11:41,580 --> 00:11:47,860
qmu is kind of big um you'd as many many

00:11:45,010 --> 00:11:49,750
many things including emulating a floppy

00:11:47,860 --> 00:11:51,550
drive including a floppy drive

00:11:49,750 --> 00:11:53,260
controller and emulating a cable at

00:11:51,550 --> 00:11:55,960
between the copy drive controller and a

00:11:53,260 --> 00:11:58,930
floppy and all of those kind of things

00:11:55,960 --> 00:12:00,940
you don't need any cloud setup and from

00:11:58,930 --> 00:12:05,220
a security perspective you don't want if

00:12:00,940 --> 00:12:07,900
you have and we looked at it typical

00:12:05,220 --> 00:12:10,870
hypervisor set up has about two three

00:12:07,900 --> 00:12:13,510
hundred device emulation models running

00:12:10,870 --> 00:12:16,390
at any point in time any of those device

00:12:13,510 --> 00:12:18,160
emulation models is a place that is code

00:12:16,390 --> 00:12:20,050
that runs on a hypervisor side that the

00:12:18,160 --> 00:12:23,440
guest can talk to which by definition

00:12:20,050 --> 00:12:25,000
because the security exposure we started

00:12:23,440 --> 00:12:27,390
looking at okay do we need that we don't

00:12:25,000 --> 00:12:30,730
need a floppy controller anymore because

00:12:27,390 --> 00:12:31,810
if I hire a new employee today they

00:12:30,730 --> 00:12:37,960
don't even know what the floppy looked

00:12:31,810 --> 00:12:39,880
like so we started saying okay how much

00:12:37,960 --> 00:12:43,330
can we remove from a emulation

00:12:39,880 --> 00:12:47,530
hypervisor layer to still run on Linux

00:12:43,330 --> 00:12:49,600
and maybe some windows without without

00:12:47,530 --> 00:12:52,480
losing any of and this project called

00:12:49,600 --> 00:12:54,610
Nemo and we sort of managed to reduce

00:12:52,480 --> 00:12:57,100
the code footprint of an active qmu byte

00:12:54,610 --> 00:12:58,480
ten times a set of two million lines of

00:12:57,100 --> 00:13:00,280
code you have about two hundred thousand

00:12:58,480 --> 00:13:02,950
lines of code running at it in reality

00:13:00,280 --> 00:13:06,760
it says memory it's a startup time and

00:13:02,950 --> 00:13:09,190
it reduces your security exposure okay

00:13:06,760 --> 00:13:12,040
so we talked I talked earlier about

00:13:09,190 --> 00:13:13,570
exposing hardware features you have to

00:13:12,040 --> 00:13:16,990
do the OS you have to do a kernel you

00:13:13,570 --> 00:13:18,730
have to a hypervisor and you have to do

00:13:16,990 --> 00:13:19,660
the runtimes all these kind of things if

00:13:18,730 --> 00:13:23,140
you do it if you do

00:13:19,660 --> 00:13:25,840
right across all these pieces of the

00:13:23,140 --> 00:13:28,240
stack you can actually get very very

00:13:25,840 --> 00:13:30,730
significant performance increases we've

00:13:28,240 --> 00:13:34,540
noticed that if you take out of the box

00:13:30,730 --> 00:13:36,760
sort of an optimized stack and you spend

00:13:34,540 --> 00:13:38,290
a week or two fixing the right operating

00:13:36,760 --> 00:13:40,060
system making sure all the pieces are

00:13:38,290 --> 00:13:41,980
there you can get some time then eight

00:13:40,060 --> 00:13:44,860
times ten times performance 15 times

00:13:41,980 --> 00:13:47,530
performance increase just by changing a

00:13:44,860 --> 00:13:50,050
few software things so getting it wrong

00:13:47,530 --> 00:13:51,550
first is getting it right is a very very

00:13:50,050 --> 00:13:53,050
significant amount of performance and

00:13:51,550 --> 00:13:56,770
performance as course performance is

00:13:53,050 --> 00:13:59,830
power it's all the same kind of thing so

00:13:56,770 --> 00:14:01,180
we're free as a as a from an Intel

00:13:59,830 --> 00:14:02,740
perspective we're trying really hard to

00:14:01,180 --> 00:14:06,610
make sure all this just work for you

00:14:02,740 --> 00:14:09,010
that and that means that we have to

00:14:06,610 --> 00:14:12,270
optimize not just the kernel notice the

00:14:09,010 --> 00:14:14,680
hypervisor but also the layer above it

00:14:12,270 --> 00:14:16,870
the eigen library if you want to return

00:14:14,680 --> 00:14:19,540
stuff laude the Hadoop layer if you want

00:14:16,870 --> 00:14:21,540
to do big data tends to flow itself of

00:14:19,540 --> 00:14:23,710
course zealand there's a lot of

00:14:21,540 --> 00:14:25,510
libraries that we're now really working

00:14:23,710 --> 00:14:27,400
on making sure all the little pieces

00:14:25,510 --> 00:14:28,540
optimizations are there and you know

00:14:27,400 --> 00:14:34,270
don't in a way that you can actually

00:14:28,540 --> 00:14:36,970
consume I use and the last thing is I

00:14:34,270 --> 00:14:38,320
need to plug or booth if you want to see

00:14:36,970 --> 00:14:39,880
anything I've talked about today we have

00:14:38,320 --> 00:14:43,930
a series of demos in our booth in the

00:14:39,880 --> 00:14:45,280
show floor few floors down so if you

00:14:43,930 --> 00:14:48,250
want to talk to us I'll be there all day

00:14:45,280 --> 00:14:51,310
several of our engineer's are going to

00:14:48,250 --> 00:14:57,010
be there okay and with that thank you

00:14:51,310 --> 00:14:59,130
for listening and thank you Jim thank

00:14:57,010 --> 00:14:59,130

YouTube URL: https://www.youtube.com/watch?v=Y3GCp4sYWMM


