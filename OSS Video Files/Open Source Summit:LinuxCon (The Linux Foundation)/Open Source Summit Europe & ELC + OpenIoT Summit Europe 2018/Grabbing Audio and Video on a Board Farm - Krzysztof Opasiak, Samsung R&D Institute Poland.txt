Title: Grabbing Audio and Video on a Board Farm - Krzysztof Opasiak, Samsung R&D Institute Poland
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Grabbing Audio and Video on a Board Farm - Krzysztof Opasiak, Samsung R&D Institute Poland

 Running a test lab usually has two purposes: automated tests and sharing boards among developers. For many use cases accessing a board over serial console and being able to boot a custom kernel is enough. But what if you develop multimedia drivers or apps and their QA requires grabbing audio and video output from your board?

Krzysztof starts his story with a gentle introduction to MuxPi: open hardware board which allows unified remote access to (almost) any Single Board Computer. The most important features and limitations of this board are presented in this part. Next, he shows how to extend it with audio and video capture capabilities using a cheap ($30) HDMI extender and provide this stream to remote machine. Then the story goes to human input emulation and integrating whole solution into single convenient open source app. Finally there is Q&A session and hopefully some discussion. 

About Krzysztof Opasiak
Krzysztof Opasiak is a PhD student at Warsaw University of Technology. He works as Kernel and System Developer at Samsung R&D Institute Poland. Since 2013 involved in USB support development in Tizen OS. Maintainer of libusbgx, a library for USB gadgets management through ConfigFS. Open Source enthusiast and speaker at several Linux and Open Source Conferences.
Captions: 
	00:00:00,030 --> 00:00:05,009
so hello good morning everyone welcome

00:00:02,510 --> 00:00:07,859
my name is Christophe Appa shocked I

00:00:05,009 --> 00:00:10,380
work for Samsung R&D Institute Poland

00:00:07,859 --> 00:00:13,230
and today I'd like to share with you my

00:00:10,380 --> 00:00:17,460
story about grabbing algea and video on

00:00:13,230 --> 00:00:19,859
a board farm so generally I know this is

00:00:17,460 --> 00:00:22,140
where it's very early so if I fall

00:00:19,859 --> 00:00:24,180
asleep during my talk please remember to

00:00:22,140 --> 00:00:25,800
wake me up in the end because I have to

00:00:24,180 --> 00:00:28,560
pass the microphone to the next speaker

00:00:25,800 --> 00:00:31,109
and I hope that if you fall asleep it

00:00:28,560 --> 00:00:34,739
will be really a comfortable sleep okay

00:00:31,109 --> 00:00:37,620
so now let's go to our presentation so

00:00:34,739 --> 00:00:39,420
the agenda for today first of all I

00:00:37,620 --> 00:00:42,510
would like to tell you a few words why

00:00:39,420 --> 00:00:44,760
people run a board farm generally it

00:00:42,510 --> 00:00:47,789
takes a lot of time and a lot of money

00:00:44,760 --> 00:00:50,730
to take it to not only to build it but

00:00:47,789 --> 00:00:52,829
also to maintain it then I will go

00:00:50,730 --> 00:00:55,379
through some typical setups in

00:00:52,829 --> 00:00:58,410
particular I will tell about lava and I

00:00:55,379 --> 00:01:00,239
will tell you I will tell about slab

00:00:58,410 --> 00:01:04,019
stock which we are building in Samsung

00:01:00,239 --> 00:01:06,600
and then I will go to the HDMI PI which

00:01:04,019 --> 00:01:10,250
is my proof of concept of how to grab

00:01:06,600 --> 00:01:13,680
audio and video on a board farm how to

00:01:10,250 --> 00:01:16,740
use your target remotely with full audio

00:01:13,680 --> 00:01:18,450
and video support then I will go to

00:01:16,740 --> 00:01:21,360
future work because this is only a

00:01:18,450 --> 00:01:25,830
proof-of-concept it works I would say it

00:01:21,360 --> 00:01:28,799
works perfectly but has some issues I

00:01:25,830 --> 00:01:31,979
think that it this can be done much

00:01:28,799 --> 00:01:34,530
better that's why I suggest some some

00:01:31,979 --> 00:01:37,520
future steps then I will go to the

00:01:34,530 --> 00:01:41,600
summary and the Q&A session in the end

00:01:37,520 --> 00:01:44,549
so generally what is a board forum

00:01:41,600 --> 00:01:47,009
building a board forum means that you

00:01:44,549 --> 00:01:51,060
are taking some kind of room and put the

00:01:47,009 --> 00:01:53,310
put there a lot of boards why so the

00:01:51,060 --> 00:01:56,850
first use case is to run automated

00:01:53,310 --> 00:01:59,520
testing we need testing during whole

00:01:56,850 --> 00:02:01,939
software lifecycle not only in the end

00:01:59,520 --> 00:02:05,790
when we ship our product to the client

00:02:01,939 --> 00:02:06,420
in case of projects like OpenStack or

00:02:05,790 --> 00:02:09,599
onap

00:02:06,420 --> 00:02:12,330
or big projects related to the cloud or

00:02:09,599 --> 00:02:13,740
server infrastructure it's there is very

00:02:12,330 --> 00:02:16,830
high pressure on the sea

00:02:13,740 --> 00:02:21,060
system in terms of kernel we are doing a

00:02:16,830 --> 00:02:23,280
little a little bit to less of testing

00:02:21,060 --> 00:02:25,980
so that's why we should put more

00:02:23,280 --> 00:02:28,710
pressure on it and manual testing of

00:02:25,980 --> 00:02:30,570
kernel is really time consuming it's not

00:02:28,710 --> 00:02:32,190
easy to test your patches every time

00:02:30,570 --> 00:02:35,340
when you are sending them it's not easy

00:02:32,190 --> 00:02:37,500
to take the kernel every minute because

00:02:35,340 --> 00:02:40,140
there is a lot of comets coming to the -

00:02:37,500 --> 00:02:42,150
to the lineage tree so we should really

00:02:40,140 --> 00:02:44,750
test it if this doesn't break out our

00:02:42,150 --> 00:02:48,390
hardware or maybe not our hardware but

00:02:44,750 --> 00:02:50,340
booting a kernel on our hardware so what

00:02:48,390 --> 00:02:52,710
we can do well we can try to use them

00:02:50,340 --> 00:02:54,510
later but it's not always the real

00:02:52,710 --> 00:02:56,700
hardware there are some bugs that are

00:02:54,510 --> 00:02:58,740
really Hardware dependent so that's why

00:02:56,700 --> 00:03:01,620
we sometimes should use the real

00:02:58,740 --> 00:03:03,720
hardware and try to test our changes and

00:03:01,620 --> 00:03:07,920
newest kernel versions of on that

00:03:03,720 --> 00:03:11,460
hardware another use case is sharing the

00:03:07,920 --> 00:03:13,290
hardware generally there is always not

00:03:11,460 --> 00:03:16,170
enough hardware even if you are working

00:03:13,290 --> 00:03:19,410
in a hardware company developer boards

00:03:16,170 --> 00:03:21,420
are always always busy so that's why we

00:03:19,410 --> 00:03:23,700
are sharing both boards among many

00:03:21,420 --> 00:03:26,370
developers if you are working in the

00:03:23,700 --> 00:03:28,290
same office it's really easy to do this

00:03:26,370 --> 00:03:30,690
you can you know just the ball past the

00:03:28,290 --> 00:03:33,420
board to your colleague but still yuck

00:03:30,690 --> 00:03:36,060
Orlick has to recreate your setup setup

00:03:33,420 --> 00:03:38,280
serial set up all the stuff that is

00:03:36,060 --> 00:03:41,370
needed to play with the board all the

00:03:38,280 --> 00:03:43,380
stuff that he is working on etc what if

00:03:41,370 --> 00:03:45,840
we could say that this board is always

00:03:43,380 --> 00:03:48,300
ready to be used and you can just you

00:03:45,840 --> 00:03:51,600
know allocate a time slot and everything

00:03:48,300 --> 00:03:54,870
is connected another use case is when

00:03:51,600 --> 00:03:57,720
your target is secret well if you are

00:03:54,870 --> 00:03:59,760
working with consumer electronics it's

00:03:57,720 --> 00:04:01,950
not always the software that is very

00:03:59,760 --> 00:04:04,800
secret but the look and feel of the end

00:04:01,950 --> 00:04:07,110
device so you may try to pass by

00:04:04,800 --> 00:04:12,780
passages by providing developers with a

00:04:07,110 --> 00:04:15,150
so-called black box electronics but what

00:04:12,780 --> 00:04:17,340
if you could skip that step of producing

00:04:15,150 --> 00:04:19,500
these black box electronics and just

00:04:17,340 --> 00:04:22,260
produce the real targets and put them in

00:04:19,500 --> 00:04:24,780
a closed room when no one have access to

00:04:22,260 --> 00:04:27,120
and developers will just get a remote

00:04:24,780 --> 00:04:27,710
access and try to deploy their software

00:04:27,120 --> 00:04:30,229
and

00:04:27,710 --> 00:04:36,050
play with the board us as if it would be

00:04:30,229 --> 00:04:38,120
on their desks next item is having

00:04:36,050 --> 00:04:41,419
access to the remote machine

00:04:38,120 --> 00:04:43,610
well many companies is scatter all

00:04:41,419 --> 00:04:46,039
around the world or even if you are only

00:04:43,610 --> 00:04:48,110
basing for example UK you may have a

00:04:46,039 --> 00:04:50,990
client from China and they have a client

00:04:48,110 --> 00:04:52,789
from Japan etc if you have only one

00:04:50,990 --> 00:04:54,470
target then probably it's going to be

00:04:52,789 --> 00:04:57,169
shipped to your office and you will work

00:04:54,470 --> 00:05:00,410
on it but what if you work with multiple

00:04:57,169 --> 00:05:03,680
products come on it's not always easy to

00:05:00,410 --> 00:05:05,750
get an access to the exact board that we

00:05:03,680 --> 00:05:08,330
had to fix the issue on because for

00:05:05,750 --> 00:05:10,430
example Samsung sells mobile phones with

00:05:08,330 --> 00:05:13,070
different chipset in different corners

00:05:10,430 --> 00:05:16,250
of the world so if you are based in USA

00:05:13,070 --> 00:05:18,710
it's not very easy for you to get for

00:05:16,250 --> 00:05:22,310
example galaxy s 9 with the chipset that

00:05:18,710 --> 00:05:24,889
is being sold in Korea you have to order

00:05:22,310 --> 00:05:27,919
it in Korea wait for example one week to

00:05:24,889 --> 00:05:31,400
ship it etc it not only costs but it

00:05:27,919 --> 00:05:37,180
also increased the time between finding

00:05:31,400 --> 00:05:40,130
a bug and fixing it so it's not easy

00:05:37,180 --> 00:05:42,740
there is a lot of use cases but it's not

00:05:40,130 --> 00:05:45,260
very easy to have a bored farm there is

00:05:42,740 --> 00:05:47,900
a lot of challenges the first of them is

00:05:45,260 --> 00:05:49,520
that every board is unique so if you are

00:05:47,900 --> 00:05:52,010
working with multiple boards but you

00:05:49,520 --> 00:05:54,710
would like to have a unified access you

00:05:52,010 --> 00:05:55,849
need to somehow figure out how to

00:05:54,710 --> 00:05:59,030
unified it

00:05:55,849 --> 00:06:01,490
it's not easy there is some supporting

00:05:59,030 --> 00:06:04,190
hardware I would say but is either

00:06:01,490 --> 00:06:08,150
expensive or either not very available

00:06:04,190 --> 00:06:10,400
and there is this maintenance cost if

00:06:08,150 --> 00:06:12,380
you are having a complicated setup if

00:06:10,400 --> 00:06:14,449
you are using multiple targets within

00:06:12,380 --> 00:06:18,110
the same machine if something gets wrong

00:06:14,449 --> 00:06:19,729
with one board it may you may end up of

00:06:18,110 --> 00:06:21,590
a situation that you have to disconnect

00:06:19,729 --> 00:06:24,289
all other boards from that machine and

00:06:21,590 --> 00:06:26,300
try to debug the issue this may block a

00:06:24,289 --> 00:06:31,009
lot of work that is being done by other

00:06:26,300 --> 00:06:35,570
developers another issues stability as

00:06:31,009 --> 00:06:40,910
people say USB works yes it works for

00:06:35,570 --> 00:06:43,370
one day two days but after a week of

00:06:40,910 --> 00:06:45,590
don't work on a board farm it starts

00:06:43,370 --> 00:06:48,020
getting really messy you will get a lot

00:06:45,590 --> 00:06:51,080
of new errors your targets won't will

00:06:48,020 --> 00:06:55,490
stop a numerating so USB it's not as

00:06:51,080 --> 00:06:59,000
stable as the internet then there is a

00:06:55,490 --> 00:07:01,640
scalability issue you always start small

00:06:59,000 --> 00:07:04,070
you start for example of a single board

00:07:01,640 --> 00:07:06,980
but really fast you are trying to

00:07:04,070 --> 00:07:08,390
connect additional boards and if you are

00:07:06,980 --> 00:07:10,610
doing this in the wrong way

00:07:08,390 --> 00:07:14,660
then it quickly end up in a situation

00:07:10,610 --> 00:07:17,510
that you are the only one who knows how

00:07:14,660 --> 00:07:21,800
this stuff is configured if someone came

00:07:17,510 --> 00:07:25,160
to the room he says oh my gosh what this

00:07:21,800 --> 00:07:27,950
cable is for I have no idea how what

00:07:25,160 --> 00:07:29,450
happened it's just not working and there

00:07:27,950 --> 00:07:31,580
you've got the phone in the middle of

00:07:29,450 --> 00:07:33,350
the night that oh come on you have to

00:07:31,580 --> 00:07:36,350
come to the office because we don't know

00:07:33,350 --> 00:07:40,130
what happened and serial for the board

00:07:36,350 --> 00:07:42,380
number 32 is not working so it's not

00:07:40,130 --> 00:07:46,430
easy it's just like running a server

00:07:42,380 --> 00:07:49,490
room so what are the typical setups how

00:07:46,430 --> 00:07:52,850
people deal with it the first one and

00:07:49,490 --> 00:07:54,770
the oldest one is lava lava stands for

00:07:52,850 --> 00:07:57,950
rule in our automated validation

00:07:54,770 --> 00:08:01,280
architecture basically lava allows you

00:07:57,950 --> 00:08:04,220
to run a board farm with a setup that

00:08:01,280 --> 00:08:06,710
there are number with the distributed

00:08:04,220 --> 00:08:09,169
set up so the main server is lava

00:08:06,710 --> 00:08:11,780
scheduler or lava master this is a

00:08:09,169 --> 00:08:15,950
server where you just submit a job the

00:08:11,780 --> 00:08:17,870
job is described by Yama and in the job

00:08:15,950 --> 00:08:20,560
typically you just download the image

00:08:17,870 --> 00:08:24,080
flash it to the device under the test

00:08:20,560 --> 00:08:26,540
boot your board run some kind of test

00:08:24,080 --> 00:08:30,530
scripts and collect the artifacts to

00:08:26,540 --> 00:08:33,169
present this to the upper layer so this

00:08:30,530 --> 00:08:36,500
is all described in that Yama Java

00:08:33,169 --> 00:08:38,870
language and this lava lava scheduler

00:08:36,500 --> 00:08:40,820
selects the dispatcher that should

00:08:38,870 --> 00:08:45,260
execute the test of some particular

00:08:40,820 --> 00:08:48,230
board and pass the description and to

00:08:45,260 --> 00:08:50,660
this dispatcher dispatcher is a machine

00:08:48,230 --> 00:08:54,860
that has some device under test

00:08:50,660 --> 00:08:57,170
connected usually you will connect to

00:08:54,860 --> 00:08:59,630
we'll get the PC with some kind of power

00:08:57,170 --> 00:09:03,529
relays with some kind of serial adapters

00:08:59,630 --> 00:09:06,290
with USB hub or maybe Ethernet switch it

00:09:03,529 --> 00:09:08,390
depends what your boards offer but

00:09:06,290 --> 00:09:10,279
generally you have loved one level

00:09:08,390 --> 00:09:12,740
dispatcher with multiple boards and

00:09:10,279 --> 00:09:14,839
obviously you may have number of that

00:09:12,740 --> 00:09:16,910
kind of laboratories so for example one

00:09:14,839 --> 00:09:20,959
might be place in USA and the other one

00:09:16,910 --> 00:09:23,839
in Korea so there is also a concept of

00:09:20,959 --> 00:09:27,640
lab in a box and basically it's a

00:09:23,839 --> 00:09:31,370
concept from Bay Libre from last ELC

00:09:27,640 --> 00:09:34,279
what they did is they containerized lava

00:09:31,370 --> 00:09:36,230
dispatcher and lava master and put them

00:09:34,279 --> 00:09:40,040
on a single machine obviously this can

00:09:36,230 --> 00:09:42,230
be scaled up and you can just deploy a

00:09:40,040 --> 00:09:44,600
master on the other machine but the

00:09:42,230 --> 00:09:47,540
concept is to put everything into one

00:09:44,600 --> 00:09:50,480
single PC box so what we've got here is

00:09:47,540 --> 00:09:51,470
the power power delivery unit some kind

00:09:50,480 --> 00:09:53,959
of motherboard

00:09:51,470 --> 00:09:57,440
we've got acne probe which are used to

00:09:53,959 --> 00:10:00,079
measure the power consumptions we've got

00:09:57,440 --> 00:10:03,490
some number of device under test and

00:10:00,079 --> 00:10:07,370
everything is closed into a single box

00:10:03,490 --> 00:10:09,440
it's nice it looks really nice but the

00:10:07,370 --> 00:10:11,839
problem is that still if something

00:10:09,440 --> 00:10:13,279
happens with a single board you may end

00:10:11,839 --> 00:10:16,040
up in a situation that you have to

00:10:13,279 --> 00:10:18,829
disconnect multiple boards to debug the

00:10:16,040 --> 00:10:21,709
issue because for example if your USB

00:10:18,829 --> 00:10:23,839
stops working it's not that only one

00:10:21,709 --> 00:10:26,360
target which is connected via USB will

00:10:23,839 --> 00:10:27,949
be unavailable all which are connected

00:10:26,360 --> 00:10:30,920
to that controller are going to be

00:10:27,949 --> 00:10:33,649
unavailable so still you may need to

00:10:30,920 --> 00:10:36,850
reboot the machine which means that you

00:10:33,649 --> 00:10:39,470
all you have down all the board's so

00:10:36,850 --> 00:10:43,430
that's why we took different different

00:10:39,470 --> 00:10:46,130
approach we decided that a single device

00:10:43,430 --> 00:10:50,810
under test should be connected to single

00:10:46,130 --> 00:10:54,050
PC like machine well I say a PC like I'm

00:10:50,810 --> 00:10:56,480
saying not PC like you know with the

00:10:54,050 --> 00:11:00,170
huge box and huge mem amount of memory

00:10:56,480 --> 00:11:03,260
no I'm just talking about a small single

00:11:00,170 --> 00:11:06,230
board computer called nano PI so what we

00:11:03,260 --> 00:11:08,800
did is we developed an add-on to the

00:11:06,230 --> 00:11:11,740
Nano pioneer which

00:11:08,800 --> 00:11:14,890
unifies the access to almost any board

00:11:11,740 --> 00:11:17,709
and this is the very top but the very

00:11:14,890 --> 00:11:21,399
bottom layer of our solution so you may

00:11:17,709 --> 00:11:23,709
have similar devices we are they are

00:11:21,399 --> 00:11:26,140
called Mac spies and you may have

00:11:23,709 --> 00:11:29,200
different device under the under tests

00:11:26,140 --> 00:11:32,160
and the benefit of this approach is that

00:11:29,200 --> 00:11:35,170
the upper layer you provide only

00:11:32,160 --> 00:11:38,860
Internet connection and here you connect

00:11:35,170 --> 00:11:41,560
the power supply so in the upper layer

00:11:38,860 --> 00:11:43,420
doesn't even know what kind of target is

00:11:41,560 --> 00:11:45,850
you connected or how to flash it how to

00:11:43,420 --> 00:11:48,579
play with it because it's all done with

00:11:45,850 --> 00:11:51,399
the Mook spy it provides the unified

00:11:48,579 --> 00:11:54,010
kind of API that allows you to access

00:11:51,399 --> 00:11:56,680
the device and execute some kind of

00:11:54,010 --> 00:11:58,600
tasks for example do the power cycle for

00:11:56,680 --> 00:12:03,070
example flash the image or for example

00:11:58,600 --> 00:12:04,980
deploy something on the target but this

00:12:03,070 --> 00:12:07,720
is only the very basic building block

00:12:04,980 --> 00:12:09,670
the next step which you have to take is

00:12:07,720 --> 00:12:12,220
how to allocate this device to the

00:12:09,670 --> 00:12:15,700
developer or to the test system so

00:12:12,220 --> 00:12:18,160
that's why we develop berta and this is

00:12:15,700 --> 00:12:21,550
a kind of equivalent of lab treat that

00:12:18,160 --> 00:12:24,190
someone may of you may know what it does

00:12:21,550 --> 00:12:26,860
it allows to allocate the target for

00:12:24,190 --> 00:12:28,570
some certain period of time so for

00:12:26,860 --> 00:12:29,829
example you can with a request that

00:12:28,570 --> 00:12:32,410
you'd like to get access to the

00:12:29,829 --> 00:12:34,120
raspberry pi you may also pass some

00:12:32,410 --> 00:12:36,490
capabilities of that device for example

00:12:34,120 --> 00:12:38,380
it should have camera connected it

00:12:36,490 --> 00:12:41,440
should be able to capture the video or

00:12:38,380 --> 00:12:45,610
something and biruta provides you an SSH

00:12:41,440 --> 00:12:47,800
tunnel to some particular device but

00:12:45,610 --> 00:12:50,140
giving an access to the device it's not

00:12:47,800 --> 00:12:52,300
always enough it's fine if you'd like to

00:12:50,140 --> 00:12:54,010
play with the device debug something for

00:12:52,300 --> 00:12:57,010
a short period of time or something like

00:12:54,010 --> 00:12:59,589
this but if you'd like to run your

00:12:57,010 --> 00:13:02,190
automated tests you need another system

00:12:59,589 --> 00:13:05,430
that's why we developed fellows and

00:13:02,190 --> 00:13:07,870
fellows from the upper side is almost

00:13:05,430 --> 00:13:11,230
compatible with lava so it also takes

00:13:07,870 --> 00:13:14,110
the llamo job description and then it

00:13:11,230 --> 00:13:18,670
used biruta to get the access to the

00:13:14,110 --> 00:13:21,310
hardware and deploy and run tests all

00:13:18,670 --> 00:13:21,939
the stack and all the design for that

00:13:21,310 --> 00:13:24,399
board

00:13:21,939 --> 00:13:27,939
open source so you can get it from our

00:13:24,399 --> 00:13:29,979
github because this talk is really

00:13:27,939 --> 00:13:32,109
focused on a hardware because I will be

00:13:29,979 --> 00:13:34,929
talking how to grab audio and video and

00:13:32,109 --> 00:13:35,499
that kind of set up let's focus on MOOCs

00:13:34,929 --> 00:13:39,069
by now

00:13:35,499 --> 00:13:41,589
so what MOOCs by really is so like I

00:13:39,069 --> 00:13:44,409
told me earlier this is a single bird

00:13:41,589 --> 00:13:47,289
computer called nano PI Y which is nano

00:13:44,409 --> 00:13:49,869
PI because it was cheap it was cheap and

00:13:47,289 --> 00:13:51,639
powerful enough so there was no other

00:13:49,869 --> 00:13:53,829
reason to choose it if you'd like to use

00:13:51,639 --> 00:13:56,709
different single board computer like

00:13:53,829 --> 00:13:59,499
Raspberry Pi or anything else okay just

00:13:56,709 --> 00:14:01,509
develop an adapter and connect it there

00:13:59,499 --> 00:14:03,789
is another problem we are not stick to

00:14:01,509 --> 00:14:07,479
the nano PI or we are not depending on

00:14:03,789 --> 00:14:09,879
any of its features so we get the nano

00:14:07,479 --> 00:14:11,529
pine here over here and this now the

00:14:09,879 --> 00:14:14,829
Pioneer is connected to the

00:14:11,529 --> 00:14:17,799
microcontroller which provides all the

00:14:14,829 --> 00:14:20,589
low-level interfaces of the board so

00:14:17,799 --> 00:14:23,109
what we've got first of all we've got

00:14:20,589 --> 00:14:25,389
power control so you can control the

00:14:23,109 --> 00:14:28,179
power if the device is powered on or off

00:14:25,389 --> 00:14:30,179
you can not only control this but you

00:14:28,179 --> 00:14:34,199
can also measure the power consumption

00:14:30,179 --> 00:14:38,789
so it also contains the ACMA probes the

00:14:34,199 --> 00:14:41,949
next thing is the SD Max what SD Max is

00:14:38,789 --> 00:14:45,489
most of single board computers may boot

00:14:41,949 --> 00:14:48,099
from the micro SD card it's quite

00:14:45,489 --> 00:14:51,639
convenient to flash the micro SD card

00:14:48,099 --> 00:14:55,329
via a USB for example or to execute

00:14:51,639 --> 00:14:59,199
pixie boot or anything like this if your

00:14:55,329 --> 00:15:01,929
bootloader is working but if you are

00:14:59,199 --> 00:15:04,779
flashing hole images including the

00:15:01,929 --> 00:15:08,409
bootloader you have no guarantee that

00:15:04,779 --> 00:15:10,869
the bootloader is not broken so that's

00:15:08,409 --> 00:15:14,229
why we decided that we have we need an

00:15:10,869 --> 00:15:18,119
automated way to recover our device in

00:15:14,229 --> 00:15:21,459
case when we flash a broken bootloader

00:15:18,119 --> 00:15:23,709
that's why there is micro SD card the

00:15:21,459 --> 00:15:26,439
multiplexer demultiplexer

00:15:23,709 --> 00:15:29,319
means that the micro SD card which is

00:15:26,439 --> 00:15:31,899
inside the moog spy can be connected

00:15:29,319 --> 00:15:35,860
either to the device under the test or

00:15:31,899 --> 00:15:37,930
to internal micro SD card reader so

00:15:35,860 --> 00:15:40,180
if you switch this you may always flash

00:15:37,930 --> 00:15:44,320
the whole image of the micro SD card and

00:15:40,180 --> 00:15:46,959
recover from almost any state the next

00:15:44,320 --> 00:15:48,730
feature is diaper when your board is

00:15:46,959 --> 00:15:52,060
just booting after connecting the power

00:15:48,730 --> 00:15:55,390
it's fine but there are some really nice

00:15:52,060 --> 00:15:57,880
designs that some words require for

00:15:55,390 --> 00:16:00,339
example pressing a button to boot after

00:15:57,880 --> 00:16:01,269
connecting the power so to automate that

00:16:00,339 --> 00:16:04,029
kind of stuff

00:16:01,269 --> 00:16:06,670
MOOCs pie contains diapers which ours

00:16:04,029 --> 00:16:09,690
which stands for dynamic jumpers so we

00:16:06,670 --> 00:16:13,269
can emulate a button press or button

00:16:09,690 --> 00:16:15,970
button press things there is obviously

00:16:13,269 --> 00:16:18,820
the building's serial support and there

00:16:15,970 --> 00:16:20,350
is also the USB serial switch because if

00:16:18,820 --> 00:16:22,839
you are developing something for the

00:16:20,350 --> 00:16:25,510
mobile phone you may end up in a

00:16:22,839 --> 00:16:28,390
situation that serial is on the same

00:16:25,510 --> 00:16:30,339
pins as USB so we have to use the

00:16:28,390 --> 00:16:32,290
suitable resistor to choose whether we

00:16:30,339 --> 00:16:34,630
would like to connect your mobile phone

00:16:32,290 --> 00:16:38,110
as a USB device or you'd like to get the

00:16:34,630 --> 00:16:41,709
serial access to two to the kernel or

00:16:38,110 --> 00:16:44,860
two to the bootloader there is also

00:16:41,709 --> 00:16:47,649
display because it's really nice and

00:16:44,860 --> 00:16:49,930
easy to deploy a device but when it

00:16:47,649 --> 00:16:52,449
comes to the maintenance you need to

00:16:49,930 --> 00:16:54,790
have some kind of way to identify that

00:16:52,449 --> 00:16:56,589
for example this is the broken board if

00:16:54,790 --> 00:16:58,690
you have like hundred of those boards

00:16:56,589 --> 00:17:01,360
it's really nice to have at least a

00:16:58,690 --> 00:17:02,170
diode to signal that this is the board

00:17:01,360 --> 00:17:03,820
which is broken

00:17:02,170 --> 00:17:06,339
something is wrong this is the board you

00:17:03,820 --> 00:17:08,380
should check instead of just going

00:17:06,339 --> 00:17:11,709
through all the boards and looking which

00:17:08,380 --> 00:17:14,230
one is the the broken one it's also

00:17:11,709 --> 00:17:17,110
extendable which means that we provide

00:17:14,230 --> 00:17:20,260
an extension cord to to which you can

00:17:17,110 --> 00:17:23,110
connect your own atom when we were when

00:17:20,260 --> 00:17:26,530
we've been developing this we really

00:17:23,110 --> 00:17:29,860
think that mm people will do crazy stuff

00:17:26,530 --> 00:17:33,130
with it we don't know all the use cases

00:17:29,860 --> 00:17:35,020
for example we do not support TV over

00:17:33,130 --> 00:17:37,540
here but there is an add-on developed

00:17:35,020 --> 00:17:40,360
which provides you the remote control

00:17:37,540 --> 00:17:43,030
for the TV we don't have any speaker or

00:17:40,360 --> 00:17:45,100
microphone here but there is an add-on

00:17:43,030 --> 00:17:46,750
that provides you the speaker and the

00:17:45,100 --> 00:17:49,020
microphone so you can for example

00:17:46,750 --> 00:17:54,120
there's some NLP stuff

00:17:49,020 --> 00:17:56,850
and in the end there is no video or out

00:17:54,120 --> 00:18:00,350
the input on that board but it can

00:17:56,850 --> 00:18:03,029
develop an add-on that provides you this

00:18:00,350 --> 00:18:06,000
so what is on the board in terms of

00:18:03,029 --> 00:18:10,559
audio and video there is a tid injector

00:18:06,000 --> 00:18:12,510
so what what does it is well this is how

00:18:10,559 --> 00:18:16,470
the board looks like and you see that

00:18:12,510 --> 00:18:20,370
there is an HDMI connector over here but

00:18:16,470 --> 00:18:23,640
this is only a fake HDMI what does it

00:18:20,370 --> 00:18:26,760
mean to connect a monitor every time

00:18:23,640 --> 00:18:30,000
when you connect a monitor over HDMI it

00:18:26,760 --> 00:18:32,880
sends the information about the

00:18:30,000 --> 00:18:36,270
available resolutions to the board so

00:18:32,880 --> 00:18:39,179
the board waits for that information and

00:18:36,270 --> 00:18:41,370
when only it receives it it starts

00:18:39,179 --> 00:18:44,220
playing the video there may be nothing

00:18:41,370 --> 00:18:46,980
on the other side but the board will

00:18:44,220 --> 00:18:50,190
think that the monitor is connected why

00:18:46,980 --> 00:18:53,130
we need it to use cases first of them is

00:18:50,190 --> 00:18:55,230
that not every board is really happy to

00:18:53,130 --> 00:18:58,020
boot up without monitor connected and

00:18:55,230 --> 00:19:00,990
the second use case is to just simply

00:18:58,020 --> 00:19:04,260
make a screen shot before we had this

00:19:00,990 --> 00:19:06,299
add-on for grabbing audience video we

00:19:04,260 --> 00:19:08,100
were doing just software screenshots by

00:19:06,299 --> 00:19:10,679
logging to the board and making a

00:19:08,100 --> 00:19:12,570
screenshot but to make a screenshot you

00:19:10,679 --> 00:19:14,669
need to somehow emulate that the monitor

00:19:12,570 --> 00:19:17,460
is connected otherwise you will get just

00:19:14,669 --> 00:19:20,909
blank screen so that's why we we have

00:19:17,460 --> 00:19:24,120
developed this idid injector and we put

00:19:20,909 --> 00:19:25,850
this on the on the mock spy board to

00:19:24,120 --> 00:19:30,179
make this happen

00:19:25,850 --> 00:19:32,640
so this is the MOOC spy but now let's go

00:19:30,179 --> 00:19:35,850
to the meet let's go to the grabbing

00:19:32,640 --> 00:19:38,850
audio and video because as you saw there

00:19:35,850 --> 00:19:42,929
is only some kind of fake stuff to

00:19:38,850 --> 00:19:44,789
emulate that so what can we do first of

00:19:42,929 --> 00:19:47,580
all we could just go to the shop and buy

00:19:44,789 --> 00:19:49,380
an HDMI grabber they are really

00:19:47,580 --> 00:19:51,779
available on the market is not a problem

00:19:49,380 --> 00:19:54,110
to buy them the only problem is that it

00:19:51,779 --> 00:19:58,080
costs around three hundred dollars and

00:19:54,110 --> 00:20:01,169
still if you buy single device it's not

00:19:58,080 --> 00:20:02,400
enough for your board fire usually you

00:20:01,169 --> 00:20:05,370
need at least ten

00:20:02,400 --> 00:20:08,730
them or maybe 100 of them it depends on

00:20:05,370 --> 00:20:11,550
your board farm size and still even if

00:20:08,730 --> 00:20:14,250
you use that device you need to somehow

00:20:11,550 --> 00:20:16,680
stream the video over the network which

00:20:14,250 --> 00:20:20,040
means that potentially you may need to

00:20:16,680 --> 00:20:23,550
convert it and converting a video on a

00:20:20,040 --> 00:20:26,160
single board computer like nano pie it's

00:20:23,550 --> 00:20:29,280
not really something you would like to

00:20:26,160 --> 00:20:31,650
do because it takes a lot of time so it

00:20:29,280 --> 00:20:33,720
would increase the delay if you'd like

00:20:31,650 --> 00:20:37,400
to just make a screen shot if you'd like

00:20:33,720 --> 00:20:40,470
to just use this to for example make

00:20:37,400 --> 00:20:42,510
some videos of the board something

00:20:40,470 --> 00:20:46,260
something like that so only the

00:20:42,510 --> 00:20:48,900
automated test stuff ok it will work but

00:20:46,260 --> 00:20:51,360
we should consider not only the

00:20:48,900 --> 00:20:55,020
automated tests but also remote access

00:20:51,360 --> 00:20:57,930
for the developer the other issue is

00:20:55,020 --> 00:21:01,320
that many of those grabbers require USB

00:20:57,930 --> 00:21:03,690
3.0 and obviously a single board

00:21:01,320 --> 00:21:06,600
computer for less than $10 it's not

00:21:03,690 --> 00:21:09,720
equipped with that so it may be not easy

00:21:06,600 --> 00:21:12,300
to connect it another issue that is that

00:21:09,720 --> 00:21:15,540
those grabbers comes in different mean

00:21:12,300 --> 00:21:19,140
different prices in different forms

00:21:15,540 --> 00:21:23,550
let's say and some of them use CPU very

00:21:19,140 --> 00:21:25,770
extensively and this Anna once again on

00:21:23,550 --> 00:21:29,190
a single board computer may become an

00:21:25,770 --> 00:21:31,260
issue so that's why I picked up an idea

00:21:29,190 --> 00:21:34,290
from FOSDEM presented by one of the

00:21:31,260 --> 00:21:38,610
Intel guys he mentioned that there is a

00:21:34,290 --> 00:21:42,600
really nice device it's called LK foul

00:21:38,610 --> 00:21:45,330
three seven three egg wood it is well

00:21:42,600 --> 00:21:49,770
this is HDMI extender so what is

00:21:45,330 --> 00:21:52,650
designed for if you enter this shop you

00:21:49,770 --> 00:21:56,460
may see that most of the TVs are playing

00:21:52,650 --> 00:21:59,370
the same video so if you would like to

00:21:56,460 --> 00:22:01,140
connect every of those tvs to a separate

00:21:59,370 --> 00:22:04,790
media device you would need a lot of

00:22:01,140 --> 00:22:08,700
HDMI cables and those are length limited

00:22:04,790 --> 00:22:11,490
so to overcome that length an extender

00:22:08,700 --> 00:22:14,760
like this one has been developed in the

00:22:11,490 --> 00:22:16,410
pair of devices consists of the receiver

00:22:14,760 --> 00:22:20,310
and sender

00:22:16,410 --> 00:22:22,620
receiver is a device that takes HDMI out

00:22:20,310 --> 00:22:26,070
input out yeah

00:22:22,620 --> 00:22:28,980
it has HDMI input and provides the MPEG

00:22:26,070 --> 00:22:33,090
stream over the network to any other

00:22:28,980 --> 00:22:35,400
device and then to the TV you may

00:22:33,090 --> 00:22:37,140
connect the other side which takes the

00:22:35,400 --> 00:22:41,790
MPEG stream from the network and

00:22:37,140 --> 00:22:45,210
provides HDMI output so it's really nice

00:22:41,790 --> 00:22:48,120
solution and the funny thing is that you

00:22:45,210 --> 00:22:50,880
can easily grab this video stream not

00:22:48,120 --> 00:22:54,150
only on that particular device but for

00:22:50,880 --> 00:22:56,520
example on your computer and another

00:22:54,150 --> 00:23:01,980
really nice thing about it is that it

00:22:56,520 --> 00:23:04,920
costs $30 so it's extremely cheap so

00:23:01,980 --> 00:23:08,610
what is the wiring of our setup so we've

00:23:04,920 --> 00:23:11,790
got the mock spy and this is our let's

00:23:08,610 --> 00:23:15,780
say remote computer for for now I use

00:23:11,790 --> 00:23:17,670
the eternal two USB and icon I'm

00:23:15,780 --> 00:23:21,930
connected via ethernet to the Nano

00:23:17,670 --> 00:23:24,630
pioneer this nano PI has this MUX pipe

00:23:21,930 --> 00:23:29,610
connected and the power supply five

00:23:24,630 --> 00:23:32,280
volts the power supply here is delivered

00:23:29,610 --> 00:23:35,250
to the device under the test this is the

00:23:32,280 --> 00:23:39,360
place where I can decide whether this

00:23:35,250 --> 00:23:42,570
power supply is on or off there are also

00:23:39,360 --> 00:23:46,110
two jumpers on the board first of them

00:23:42,570 --> 00:23:50,130
is used to decide to decide whether HDMI

00:23:46,110 --> 00:23:53,190
extender should be powered on or off the

00:23:50,130 --> 00:23:53,760
second one is used to control quality of

00:23:53,190 --> 00:23:57,120
the image

00:23:53,760 --> 00:23:59,880
orginally this board comes with with a

00:23:57,120 --> 00:24:01,560
button that when you press it it just

00:23:59,880 --> 00:24:04,620
changed the resolution there are two

00:24:01,560 --> 00:24:08,280
resolutions available it's not really

00:24:04,620 --> 00:24:09,840
stable it doesn't always work but it is

00:24:08,280 --> 00:24:13,680
possible to change to limit the

00:24:09,840 --> 00:24:17,790
resolution from Full HD to - the smaller

00:24:13,680 --> 00:24:20,370
one - the 7200 P then we've got our

00:24:17,790 --> 00:24:24,810
device under the test which is connected

00:24:20,370 --> 00:24:27,410
via HDMI to this HDMI extender and a

00:24:24,810 --> 00:24:30,010
HDMI extender is connected via ethernet

00:24:27,410 --> 00:24:32,320
to the mooks by board

00:24:30,010 --> 00:24:35,230
this internet is available on the nano

00:24:32,320 --> 00:24:39,040
pi so nah nope i can take the input from

00:24:35,230 --> 00:24:42,790
here I mean the MPEG stream and stream

00:24:39,040 --> 00:24:46,600
it to the remote machine device under

00:24:42,790 --> 00:24:49,660
the test has also a USB connected so

00:24:46,600 --> 00:24:53,050
nano pioneer here in this case is used

00:24:49,660 --> 00:24:56,470
to emulate both keyboard and mouse to

00:24:53,050 --> 00:24:58,870
provide also user input from here to the

00:24:56,470 --> 00:25:02,050
device under the test it will see this

00:24:58,870 --> 00:25:03,940
in a demo so this is how it looks like

00:25:02,050 --> 00:25:08,770
when all these everything is connected

00:25:03,940 --> 00:25:12,730
you see the HDMI cable internet cable to

00:25:08,770 --> 00:25:16,210
the MUX PI power supply Internet to my

00:25:12,730 --> 00:25:19,060
laptop or to some remote machine there

00:25:16,210 --> 00:25:21,670
is also micro SD card the multiplexer

00:25:19,060 --> 00:25:24,400
like I mentioned earlier and there is

00:25:21,670 --> 00:25:31,210
the USB cable which goes to the Nano

00:25:24,400 --> 00:25:33,910
pioneer so how do we start first of all

00:25:31,210 --> 00:25:37,330
we have to somehow capture this MPEG

00:25:33,910 --> 00:25:41,020
stream it turns out that by default this

00:25:37,330 --> 00:25:43,240
device is shipped with IP like this one

00:25:41,020 --> 00:25:46,000
so we have to set up a suitable IP on

00:25:43,240 --> 00:25:49,810
your computer and then just try to grab

00:25:46,000 --> 00:25:53,350
the multicast group identified with that

00:25:49,810 --> 00:25:55,450
IP you can it can be captured by almost

00:25:53,350 --> 00:25:58,300
any software that is doing video

00:25:55,450 --> 00:26:02,830
processing for example VLC for example

00:25:58,300 --> 00:26:05,980
ffmpeg and many others generally I got

00:26:02,830 --> 00:26:09,010
the best results by using VLC maybe it

00:26:05,980 --> 00:26:10,660
is an issue with ffmpeg parameters or

00:26:09,010 --> 00:26:13,660
ffmpeg stream I don't know

00:26:10,660 --> 00:26:16,060
I'm not ffmpeg specialist that's why I

00:26:13,660 --> 00:26:16,570
just you know went with a simple

00:26:16,060 --> 00:26:19,720
solution

00:26:16,570 --> 00:26:22,630
I used VLC and it turns out that VLC

00:26:19,720 --> 00:26:24,820
parameters really matters depending on

00:26:22,630 --> 00:26:27,100
those parameters you may control how big

00:26:24,820 --> 00:26:30,000
is the delay and you may control how

00:26:27,100 --> 00:26:32,860
often your image will get some glitches

00:26:30,000 --> 00:26:35,080
unfortunately there is a trade-off let's

00:26:32,860 --> 00:26:37,960
delay you'd like to get more glitches

00:26:35,080 --> 00:26:39,810
you are going to get sorry nothing is

00:26:37,960 --> 00:26:43,480
best

00:26:39,810 --> 00:26:43,930
vo subversion also really matters by

00:26:43,480 --> 00:26:46,780
default

00:26:43,930 --> 00:26:50,310
Ubuntu 1604 that I used to test it was

00:26:46,780 --> 00:26:52,600
shipped with VLC 2 point something

00:26:50,310 --> 00:26:55,720
unfortunately it didn't work in my use

00:26:52,600 --> 00:26:59,770
case that's why I had to recompile the

00:26:55,720 --> 00:27:02,560
three point something and it works and

00:26:59,770 --> 00:27:05,590
the Nano PI kernel version really

00:27:02,560 --> 00:27:08,830
matters I mean if you use too old kernel

00:27:05,590 --> 00:27:12,820
then you will end up in very big delay

00:27:08,830 --> 00:27:14,530
and if you use too to newer kernel then

00:27:12,820 --> 00:27:18,520
you will end up with a lot of glitches

00:27:14,530 --> 00:27:22,920
and are a lot of broken UDP frames which

00:27:18,520 --> 00:27:26,470
unfortunately destroys your video okay

00:27:22,920 --> 00:27:29,140
so solution if you'd like to just take a

00:27:26,470 --> 00:27:32,650
screenshot so you would like to have a

00:27:29,140 --> 00:27:35,680
hardware screenshot to check if your UI

00:27:32,650 --> 00:27:38,140
is booted correctly then it's really

00:27:35,680 --> 00:27:40,960
enough to use ffmpeg on the nano pine

00:27:38,140 --> 00:27:42,910
and you're done but if you'd like to

00:27:40,960 --> 00:27:45,940
consider also use case with a remote

00:27:42,910 --> 00:27:49,180
access you need to somehow stream the

00:27:45,940 --> 00:27:52,270
video the simple solution is to you just

00:27:49,180 --> 00:27:54,700
use socket and receive the video stream

00:27:52,270 --> 00:28:00,160
on a one card and just stream it to

00:27:54,700 --> 00:28:02,650
another IP so the issue here is that it

00:28:00,160 --> 00:28:05,410
caused a really high CPU load on the

00:28:02,650 --> 00:28:08,680
nano pine and the second issue is that

00:28:05,410 --> 00:28:11,320
it really increased the delay so we have

00:28:08,680 --> 00:28:13,990
to think about something better and this

00:28:11,320 --> 00:28:17,800
something better is to do the streaming

00:28:13,990 --> 00:28:21,250
and routing inside the kernel so that's

00:28:17,800 --> 00:28:24,280
why you may use SMC root and the simple

00:28:21,250 --> 00:28:27,790
rule of iptables to just change the

00:28:24,280 --> 00:28:31,000
sender IP and stream the student a

00:28:27,790 --> 00:28:33,340
remote machine unfortunately this is

00:28:31,000 --> 00:28:35,680
also not a perfect solution because I

00:28:33,340 --> 00:28:38,800
was unable to change the destination if

00:28:35,680 --> 00:28:40,780
we got here some kind of network guy who

00:28:38,800 --> 00:28:43,660
knows how to do this because I tried to

00:28:40,780 --> 00:28:46,780
use IP tables for that unfortunately it

00:28:43,660 --> 00:28:49,080
was not working so if someone knows how

00:28:46,780 --> 00:28:53,800
to do this patches are welcome there

00:28:49,080 --> 00:28:56,290
will be linked on the other slide so

00:28:53,800 --> 00:28:57,320
summing up audio and video what we have

00:28:56,290 --> 00:28:59,750
to what doing

00:28:57,320 --> 00:29:05,299
to make this working first of all we

00:28:59,750 --> 00:29:07,580
need VLC version three dots and and the

00:29:05,299 --> 00:29:10,429
good parameters I found was network

00:29:07,580 --> 00:29:13,730
caching 200 and clock jitter zero it

00:29:10,429 --> 00:29:16,070
provides a reasonable delay with not so

00:29:13,730 --> 00:29:21,500
many glitches so it worked fine at least

00:29:16,070 --> 00:29:25,039
for me I used the kernel 4.11 it worked

00:29:21,500 --> 00:29:27,500
and the delay is not so big it turns out

00:29:25,039 --> 00:29:30,169
that the delay of the network card which

00:29:27,500 --> 00:29:33,080
is connected via a USB is smaller than

00:29:30,169 --> 00:29:36,500
with the built-in one I don't know why

00:29:33,080 --> 00:29:41,120
but this is what I found out and I use

00:29:36,500 --> 00:29:43,820
the same serial to dot oh okay but

00:29:41,120 --> 00:29:46,100
having an audio and video in an MPEG

00:29:43,820 --> 00:29:49,070
stream on a remote machine is not really

00:29:46,100 --> 00:29:51,289
enough because you may need to play with

00:29:49,070 --> 00:29:54,200
the application that is running on the

00:29:51,289 --> 00:29:56,299
device under test that's why you would

00:29:54,200 --> 00:29:59,480
like to provide input events from your

00:29:56,299 --> 00:30:03,649
remote machine to the device under the

00:29:59,480 --> 00:30:06,350
test to do this we use nano pioneer it

00:30:03,649 --> 00:30:09,259
is equipped with USB device controller

00:30:06,350 --> 00:30:13,009
so effectively it may act as any random

00:30:09,259 --> 00:30:15,559
USB device fortunately a Linux kernel

00:30:13,009 --> 00:30:18,620
provides the implementation of human

00:30:15,559 --> 00:30:22,399
interface protocol which allows you to

00:30:18,620 --> 00:30:27,919
really easily simulate both keyboard

00:30:22,399 --> 00:30:29,720
mouse joystick anything like to set up

00:30:27,919 --> 00:30:32,779
everything on the nano PI you have to

00:30:29,720 --> 00:30:39,250
execute that kind of script or just use

00:30:32,779 --> 00:30:41,830
lip usb GX and to setup it so keyboard

00:30:39,250 --> 00:30:44,179
how do we emulate keyboard after

00:30:41,830 --> 00:30:47,299
executing that script from the previous

00:30:44,179 --> 00:30:51,409
slide you will get to the to new device

00:30:47,299 --> 00:30:55,909
nodes they will be called that hit g0

00:30:51,409 --> 00:30:58,370
and DEF hit g1 v g0 in this case is

00:30:55,909 --> 00:31:01,100
responsible for emulating the keyboard

00:30:58,370 --> 00:31:02,179
so how do we emulate the keyboard we

00:31:01,100 --> 00:31:05,000
emulate a keyboard

00:31:02,179 --> 00:31:07,370
by writing a report descriptors which

00:31:05,000 --> 00:31:10,760
are defined in human interface protocol

00:31:07,370 --> 00:31:12,650
to that device node so what is the for

00:31:10,760 --> 00:31:15,970
of the report descriptor for a keyboard

00:31:12,650 --> 00:31:18,530
it's relatively simple the first byte

00:31:15,970 --> 00:31:21,169
please note that the order here is

00:31:18,530 --> 00:31:23,270
reversed so this is the less significant

00:31:21,169 --> 00:31:28,190
the least significant significant byte

00:31:23,270 --> 00:31:30,770
bit and the first four bits our control

00:31:28,190 --> 00:31:34,070
shift out and GUI on the left side of

00:31:30,770 --> 00:31:36,650
the keyboard the next for our control

00:31:34,070 --> 00:31:40,630
shift out GUI on the right side of the

00:31:36,650 --> 00:31:43,730
keyboard and then you may send from zero

00:31:40,630 --> 00:31:48,850
there is a zero placeholder and then you

00:31:43,730 --> 00:31:51,799
may send send from zero up to six keys

00:31:48,850 --> 00:31:55,190
so in this case this particular report

00:31:51,799 --> 00:31:59,450
descriptors means that we have a shift

00:31:55,190 --> 00:32:02,809
pressed on our machine and a button

00:31:59,450 --> 00:32:04,880
which looks in that way so effectively a

00:32:02,809 --> 00:32:07,190
character which will be recognized by

00:32:04,880 --> 00:32:13,160
the device under the test would be a

00:32:07,190 --> 00:32:17,179
quotation mark so the next thing is

00:32:13,160 --> 00:32:19,850
Mouse it's not really easy and

00:32:17,179 --> 00:32:22,160
convenient to emulate a mouse which is

00:32:19,850 --> 00:32:24,530
being passed to the remote machine why

00:32:22,160 --> 00:32:27,200
because every time when you move your

00:32:24,530 --> 00:32:30,919
mouse you should send a new report event

00:32:27,200 --> 00:32:33,040
so we will end up by really filling your

00:32:30,919 --> 00:32:36,740
network traffic with a lot of

00:32:33,040 --> 00:32:39,290
unnecessary movement events so that's

00:32:36,740 --> 00:32:42,230
why it's much more convenient to emulate

00:32:39,290 --> 00:32:44,660
a touchscreen this way your report

00:32:42,230 --> 00:32:47,540
events are sent only when the mouse

00:32:44,660 --> 00:32:49,790
button is pressed so for example you

00:32:47,540 --> 00:32:52,490
don't have problems that Mouse is moved

00:32:49,790 --> 00:32:55,100
outside of the application zone because

00:32:52,490 --> 00:32:57,410
obviously you don't want to send input

00:32:55,100 --> 00:33:02,179
events when the mouse is outside of the

00:32:57,410 --> 00:33:04,760
video zone so that's why so i emulate

00:33:02,179 --> 00:33:07,640
the touch screen and it's relatively

00:33:04,760 --> 00:33:10,220
easy it also have a report descriptor

00:33:07,640 --> 00:33:13,400
the first byte is the number of fingers

00:33:10,220 --> 00:33:16,040
so this is them RI the there may be

00:33:13,400 --> 00:33:18,500
multiple of finger descriptions ping

00:33:16,040 --> 00:33:22,820
your ID some random integer because I

00:33:18,500 --> 00:33:24,440
use only one finger estate whether it is

00:33:22,820 --> 00:33:29,870
pressed or not

00:33:24,440 --> 00:33:31,820
and the X and y position of the event so

00:33:29,870 --> 00:33:34,880
effectively when you click a mouse on

00:33:31,820 --> 00:33:37,490
some somewhere on the video you have to

00:33:34,880 --> 00:33:41,240
do recalculation because they have their

00:33:37,490 --> 00:33:43,340
own maximum and minimum you have to do

00:33:41,240 --> 00:33:47,300
recalculation of the V from the video

00:33:43,340 --> 00:33:49,760
position to the human interface position

00:33:47,300 --> 00:33:52,520
and then send the suitable report

00:33:49,760 --> 00:33:55,130
descriptors obviously all those commands

00:33:52,520 --> 00:33:57,260
should be executed on a nano PI so you

00:33:55,130 --> 00:33:59,630
should this device node is visible on a

00:33:57,260 --> 00:34:06,110
nano PI Neil so that's why we have to

00:33:59,630 --> 00:34:08,660
use SSH to send this event so how to put

00:34:06,110 --> 00:34:11,930
this all together well I wrote a simple

00:34:08,660 --> 00:34:16,490
application with QT library y QT because

00:34:11,930 --> 00:34:19,280
it was simple nothing personal I use Q

00:34:16,490 --> 00:34:21,650
SSH to execute all the commands so to

00:34:19,280 --> 00:34:25,580
set up the heat gadget to set up the

00:34:21,650 --> 00:34:31,100
video forwarding and to emulate the

00:34:25,580 --> 00:34:34,430
human interface I use Q VLC to display

00:34:31,100 --> 00:34:37,310
this is basically just a QT widget which

00:34:34,430 --> 00:34:39,620
allows you to embed the VLC video player

00:34:37,310 --> 00:34:41,630
inside your application nothing special

00:34:39,620 --> 00:34:44,600
and all this all the thing is

00:34:41,630 --> 00:34:47,960
open-source together with this wiring

00:34:44,600 --> 00:34:50,540
schematic so so so you may just pick it

00:34:47,960 --> 00:34:54,650
up and try to try to play it obviously

00:34:50,540 --> 00:34:58,100
patches are welcome so live demo ok

00:34:54,650 --> 00:35:00,440
let's see if it works so what I've got

00:34:58,100 --> 00:35:05,000
here is the same setup as you show on a

00:35:00,440 --> 00:35:07,190
picture this is the Mook spy on the left

00:35:05,000 --> 00:35:09,860
side the device under test which is

00:35:07,190 --> 00:35:13,280
Raspberry Pi in this case and the HDMI

00:35:09,860 --> 00:35:16,010
grabber which is above so by default the

00:35:13,280 --> 00:35:19,070
grabber is shipped with the really nice

00:35:16,010 --> 00:35:22,070
metal black box but it has some one

00:35:19,070 --> 00:35:25,550
issue the cooling is not really good so

00:35:22,070 --> 00:35:28,070
that's why I had to remove the case and

00:35:25,550 --> 00:35:30,560
put this in really in a room with really

00:35:28,070 --> 00:35:32,720
good air conditioning because after like

00:35:30,560 --> 00:35:36,110
2 hours or something is getting really

00:35:32,720 --> 00:35:38,350
hot and this generates a lot of video

00:35:36,110 --> 00:35:38,350
issues

00:35:38,380 --> 00:35:44,330
okay so the application is not very

00:35:41,150 --> 00:35:48,140
fancy as you see there there is just one

00:35:44,330 --> 00:35:50,990
window and there is just one many you

00:35:48,140 --> 00:35:53,660
just connect by providing the IP address

00:35:50,990 --> 00:35:55,610
of the nano PI and the port to which

00:35:53,660 --> 00:35:58,300
you'd like to connect username and

00:35:55,610 --> 00:36:01,550
password which is visible for everyone

00:35:58,300 --> 00:36:04,130
and you just click OK

00:36:01,550 --> 00:36:06,580
so when you click OK and we have

00:36:04,130 --> 00:36:09,640
successfully connected to the Mook spy

00:36:06,580 --> 00:36:13,640
you have to click OK once again

00:36:09,640 --> 00:36:17,060
surprising I have no idea if you heard

00:36:13,640 --> 00:36:19,370
that but there was some noise from the

00:36:17,060 --> 00:36:22,220
Mook spy it means that something gets

00:36:19,370 --> 00:36:25,040
connected we enabled the HDMI grabber

00:36:22,220 --> 00:36:27,860
and we enable the power supply to the

00:36:25,040 --> 00:36:31,880
board so what is now actually happening

00:36:27,860 --> 00:36:35,150
is Raspberry Pi rebooting so in couple

00:36:31,880 --> 00:36:41,180
of seconds we should see the screen from

00:36:35,150 --> 00:36:44,900
from the Raspberry Pi here as you see

00:36:41,180 --> 00:36:46,940
I'm using two small power supply so this

00:36:44,900 --> 00:36:51,140
is already an output from the Raspberry

00:36:46,940 --> 00:36:54,050
Pi and now what we can do is we can for

00:36:51,140 --> 00:36:56,590
example click and you see that there are

00:36:54,050 --> 00:36:59,540
two Mouse's or two two Mouse pointers

00:36:56,590 --> 00:37:02,810
one of them comes from the Raspberry Pi

00:36:59,540 --> 00:37:05,840
the smaller one and the bigger one is my

00:37:02,810 --> 00:37:09,440
desktop mouse so every time I click the

00:37:05,840 --> 00:37:12,160
Raspberry Pi mouse moves so for example

00:37:09,440 --> 00:37:18,350
I may now try to close that window

00:37:12,160 --> 00:37:21,680
Sadam it's closed I may also open for

00:37:18,350 --> 00:37:28,730
example the home or something and maybe

00:37:21,680 --> 00:37:31,670
try to play some video it's playing with

00:37:28,730 --> 00:37:33,740
the overlay so if you'd like to take a

00:37:31,670 --> 00:37:36,140
screenshot you would probably not see

00:37:33,740 --> 00:37:38,870
this video because it's harder of

00:37:36,140 --> 00:37:40,760
overlay and one of issues of that

00:37:38,870 --> 00:37:42,980
application it that is that sound is not

00:37:40,760 --> 00:37:46,550
always working like it is now not

00:37:42,980 --> 00:37:48,740
working but you need to restart the

00:37:46,550 --> 00:37:52,009
grabber and restart the board and you

00:37:48,740 --> 00:37:55,650
could get this in

00:37:52,009 --> 00:37:57,619
as you see the video is playing quite

00:37:55,650 --> 00:38:00,049
nicely

00:37:57,619 --> 00:38:03,509
okay so issues

00:38:00,049 --> 00:38:05,670
first of all lack of mouse tracking this

00:38:03,509 --> 00:38:08,009
may be a kind of issue if you'd like to

00:38:05,670 --> 00:38:10,319
port for example play a game on your

00:38:08,009 --> 00:38:15,210
device under test like minecraft or

00:38:10,319 --> 00:38:18,029
something I didn't manage to make

00:38:15,210 --> 00:38:21,809
internal multicast to unicast conversion

00:38:18,029 --> 00:38:25,829
so still MOOC spy generates a multicast

00:38:21,809 --> 00:38:28,910
signal this is kind of an issue if you

00:38:25,829 --> 00:38:31,940
would like to use more than one rubber

00:38:28,910 --> 00:38:35,549
so this is our use case so really if

00:38:31,940 --> 00:38:39,420
someone has an idea how to do incur a

00:38:35,549 --> 00:38:41,729
multicast the unicast conversion really

00:38:39,420 --> 00:38:44,819
patches or welcome or maybe just try to

00:38:41,729 --> 00:38:47,729
find me in the corridors there is some

00:38:44,819 --> 00:38:51,599
kind of delay probably didn't notice it

00:38:47,729 --> 00:38:54,539
but there is like one second or maybe

00:38:51,599 --> 00:38:58,259
half of a second delay before between my

00:38:54,539 --> 00:39:01,349
click and when mouse pointer moves it's

00:38:58,259 --> 00:39:05,309
kind of related to the grabber itself

00:39:01,349 --> 00:39:07,319
because it does a lot of buffering when

00:39:05,309 --> 00:39:10,079
you are playing just a video over the

00:39:07,319 --> 00:39:12,390
network like in the shop the delay

00:39:10,079 --> 00:39:14,670
doesn't really matter what is important

00:39:12,390 --> 00:39:16,799
that all TVs play the same content at

00:39:14,670 --> 00:39:18,390
the same time so that's why they are

00:39:16,799 --> 00:39:21,210
doing here some kind of internal

00:39:18,390 --> 00:39:25,170
buffering and they need to flash that

00:39:21,210 --> 00:39:26,539
buffer before I get a new video there is

00:39:25,170 --> 00:39:30,029
also the video quality

00:39:26,539 --> 00:39:34,049
well the issue here is that it's not

00:39:30,029 --> 00:39:37,229
really possible to tweak it you can get

00:39:34,049 --> 00:39:40,440
it it's reasonable I think it's more

00:39:37,229 --> 00:39:42,299
than enough to work with it but you

00:39:40,440 --> 00:39:45,359
cannot tweak the parameters if you'd

00:39:42,299 --> 00:39:47,759
like to use for example last network

00:39:45,359 --> 00:39:50,910
bandwidth or you have one gigabit

00:39:47,759 --> 00:39:52,529
internet and you'd like to stream the

00:39:50,910 --> 00:39:54,809
best possible quality

00:39:52,529 --> 00:39:57,390
it's just fixed in the hardware you

00:39:54,809 --> 00:40:00,599
cannot really edit it and another issue

00:39:57,390 --> 00:40:03,569
is stability the stream itself is not a

00:40:00,599 --> 00:40:04,950
pure MPEG stream it contains some

00:40:03,569 --> 00:40:09,540
preparatory changes

00:40:04,950 --> 00:40:12,540
and the VLC or the the lower layers are

00:40:09,540 --> 00:40:15,630
not always able to get for example audio

00:40:12,540 --> 00:40:17,550
and video in sync and this end up in a

00:40:15,630 --> 00:40:21,030
situation that you for example lose your

00:40:17,550 --> 00:40:24,060
audio so we have to do something with it

00:40:21,030 --> 00:40:26,280
and that's why I suggest some future

00:40:24,060 --> 00:40:29,640
work so if someone is interested in this

00:40:26,280 --> 00:40:32,430
idea you can just take a proof of

00:40:29,640 --> 00:40:35,010
concept and start playing with it but

00:40:32,430 --> 00:40:38,880
what I found more interesting is that

00:40:35,010 --> 00:40:41,070
you can use a kind of open source open

00:40:38,880 --> 00:40:44,990
source and opens open hardware project

00:40:41,070 --> 00:40:48,090
from Australia to do something better

00:40:44,990 --> 00:40:50,040
like I mentioned this grabber is really

00:40:48,090 --> 00:40:54,920
cheap but it has a lot of stability

00:40:50,040 --> 00:40:57,930
issues and it's not really open hardware

00:40:54,920 --> 00:41:02,480
so that's why you can use the team

00:40:57,930 --> 00:41:05,580
videos and the team videos provides a

00:41:02,480 --> 00:41:08,580
board which is called new motto OPS's

00:41:05,580 --> 00:41:10,980
and basically this project is used to

00:41:08,580 --> 00:41:14,000
record the conferences like this one so

00:41:10,980 --> 00:41:17,700
it has multiple HDMI inputs and multiple

00:41:14,000 --> 00:41:22,110
HDMI outputs and it may provide also the

00:41:17,700 --> 00:41:25,670
network stream and the USB UVC stream so

00:41:22,110 --> 00:41:28,380
if we try to collaborate with them and

00:41:25,670 --> 00:41:30,390
reduce the hardware because the issue

00:41:28,380 --> 00:41:33,530
here is that we cannot take this

00:41:30,390 --> 00:41:38,130
hardware as this because it costs a lot

00:41:33,530 --> 00:41:43,200
so we could reduce it use less powerful

00:41:38,130 --> 00:41:47,340
FPGA use less Hardware in terms of HDMI

00:41:43,200 --> 00:41:49,170
files and just you know take it and use

00:41:47,340 --> 00:41:52,170
it and create the open hardware version

00:41:49,170 --> 00:41:55,500
of that driver the really nice thing is

00:41:52,170 --> 00:41:59,370
that they are not using the VHDL or any

00:41:55,500 --> 00:42:02,280
FPGA related language they use just

00:41:59,370 --> 00:42:05,280
million which is a Python toolbox for

00:42:02,280 --> 00:42:07,590
creating FPGA bitstream it's really nice

00:42:05,280 --> 00:42:12,480
if you didn't play with it I really

00:42:07,590 --> 00:42:13,470
recommend to try it so to-do list you

00:42:12,480 --> 00:42:16,230
have to get access to the new

00:42:13,470 --> 00:42:18,630
motherboard and limit the bitstream to

00:42:16,230 --> 00:42:21,809
the FPGA to to just the things we need

00:42:18,630 --> 00:42:24,440
and then find cheaper FPGA and

00:42:21,809 --> 00:42:27,180
redesigned the board to handle it so

00:42:24,440 --> 00:42:30,329
summing up creating a board farm is

00:42:27,180 --> 00:42:32,220
challenging there are two approaches

00:42:30,329 --> 00:42:34,079
basically multiple Deut single

00:42:32,220 --> 00:42:36,480
controller or single doot single

00:42:34,079 --> 00:42:39,630
controller which is the later one

00:42:36,480 --> 00:42:43,410
because we think it's better in terms of

00:42:39,630 --> 00:42:45,960
maintenance and there is HDMI this HDMI

00:42:43,410 --> 00:42:48,569
extender may be useful for testing but

00:42:45,960 --> 00:42:52,200
remember it may have some issues so we

00:42:48,569 --> 00:42:54,839
might try to fix them or try to go with

00:42:52,200 --> 00:42:58,440
the open hardware Video Grabber from

00:42:54,839 --> 00:43:00,509
Team videos so thank you very much

00:42:58,440 --> 00:43:05,339
I'm not sure if we have time for

00:43:00,509 --> 00:43:07,410
questions nope okay so just find me in

00:43:05,339 --> 00:43:09,900
the corridor if you are interested in

00:43:07,410 --> 00:43:12,029
Slav there are some brochures you may

00:43:09,900 --> 00:43:13,610
try it you may take them and read about

00:43:12,029 --> 00:43:16,729
okay thank you

00:43:13,610 --> 00:43:16,729

YouTube URL: https://www.youtube.com/watch?v=mw79nfp7ARE


