Title: 10 Years of the Industrial I O Kernel Subsystem - Jonathan Cameron, Huawei
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	10 Years of the Industrial I/O Kernel Subsystem - Jonathan Cameron, Huawei

This talk, by the original author and continuing maintainer of the Linux kernel IIO subystem looks at the path to where we are today, mistakes made, lessons learned and potential future directions.

A brief introduction will get the audience up to speed with IIO, in particular defining what IIO isn't! This will be use case driven; both common and the obscure / interesting.

This is not a tutorial, but rather a call to arms to drive things forward. It will include examples, but focus on the wider generalities rather than a deep dive. Diversions include taking a subsystem through staging; difficulty of defining userspace ABI; userspace drivers vs kernel drivers; mentor-ship both received and passed on; and the importance of community building and attracting new contributors!

No detailed knowledge of the kernel is necessary, just an interest in improving Linux support of sensors. 

About Jonathan Cameron
Jonathan is the maintainer of the Linux Industrial I/O subsystem. He took the 'scratching an itch' path to this role, of asking how to do what he wanted in existing frameworks and getting the response: "you can't really, so propose something new". IIO was born. It turned out that other people had similar requirements and now we have well over 200 drivers across a diverse range of devices.

After spending many years messing around with sensors and cameras in academia and then a spell working within the really pretty world of X-ray imaging, he has finally come back to the kernel world and now works on a range of topics at the Huawei Research Centre in Cambridge, UK. Particular recent focus has been on the CCIX coherent fabric specs and software support.

Jonathan has previously spoken in various academic conferences and regularly presents internally, but this is first talk at Linux conference.
Captions: 
	00:00:00,030 --> 00:00:07,859
so I'm Jonathan Cameron I'm the

00:00:03,300 --> 00:00:09,630
maintainer of industrial IO and yeah

00:00:07,859 --> 00:00:11,400
been doing this for a while and it

00:00:09,630 --> 00:00:12,809
turned out when we came to sort of time

00:00:11,400 --> 00:00:15,269
to submit papers of conference it's been

00:00:12,809 --> 00:00:16,949
pretty much 10 years to the month since

00:00:15,269 --> 00:00:20,460
the first few emails went out in the

00:00:16,949 --> 00:00:23,939
first few RFC's so thought we'd do a

00:00:20,460 --> 00:00:26,340
talk on that that period of time really

00:00:23,939 --> 00:00:28,199
and what happened so gonna break it down

00:00:26,340 --> 00:00:30,599
to a number of different things first of

00:00:28,199 --> 00:00:32,730
all to understand basically any piece of

00:00:30,599 --> 00:00:36,180
code one of the fundamental things is

00:00:32,730 --> 00:00:39,000
why did it end up as it did we all know

00:00:36,180 --> 00:00:41,190
that if we start again we'll end up with

00:00:39,000 --> 00:00:43,739
a different answer to any given sort of

00:00:41,190 --> 00:00:45,420
software project than we actually did so

00:00:43,739 --> 00:00:48,989
it's a bit so I'm gonna provide a bit of

00:00:45,420 --> 00:00:51,420
information about what I wanted to do

00:00:48,989 --> 00:00:53,809
what some other people here wanted to do

00:00:51,420 --> 00:00:56,870
and how we evolved into where we are now

00:00:53,809 --> 00:00:59,010
now some stuff on interface principles

00:00:56,870 --> 00:01:01,079
this is because one of the biggest

00:00:59,010 --> 00:01:04,080
things that industrial i/o really is is

00:01:01,079 --> 00:01:05,700
a user space interface this is true of

00:01:04,080 --> 00:01:07,290
pretty much any kernel subsystem because

00:01:05,700 --> 00:01:09,750
you can change anything inside the

00:01:07,290 --> 00:01:11,010
kernel but what you can't change is

00:01:09,750 --> 00:01:14,640
anything that will make a regression in

00:01:11,010 --> 00:01:17,040
user space have a very very brief

00:01:14,640 --> 00:01:18,630
summary on the i/o architecture and this

00:01:17,040 --> 00:01:20,040
is more about understanding some of the

00:01:18,630 --> 00:01:22,830
issues that are going to come on to talk

00:01:20,040 --> 00:01:24,270
about this talk it's not meant to be a

00:01:22,830 --> 00:01:25,770
tutorial I've got some good references

00:01:24,270 --> 00:01:28,890
at the end if that's what you're looking

00:01:25,770 --> 00:01:31,860
for but it's been covered reasonably

00:01:28,890 --> 00:01:33,270
well in previous presentations and then

00:01:31,860 --> 00:01:36,600
we're going to focus quite heavily on

00:01:33,270 --> 00:01:39,770
some of the mistakes we made I made most

00:01:36,600 --> 00:01:42,060
of them so I can be rude about them and

00:01:39,770 --> 00:01:44,340
finally I think one of the most

00:01:42,060 --> 00:01:46,409
important things about an area of the

00:01:44,340 --> 00:01:48,840
kernel is the community that's been

00:01:46,409 --> 00:01:50,759
built up around it so I'd like to add a

00:01:48,840 --> 00:01:56,070
few words on that as we get towards the

00:01:50,759 --> 00:01:57,689
end so first of all some history now

00:01:56,070 --> 00:02:00,680
it's a quote from the cathedral on the

00:01:57,689 --> 00:02:05,219
bazaar the famous sort of open source

00:02:00,680 --> 00:02:08,940
text all good software projects start

00:02:05,219 --> 00:02:11,640
with a developer's personal age so what

00:02:08,940 --> 00:02:13,080
was mine I was working on an academic

00:02:11,640 --> 00:02:15,090
project

00:02:13,080 --> 00:02:16,350
called Sesame which is an incredibly

00:02:15,090 --> 00:02:17,790
controlled acronym that I can never

00:02:16,350 --> 00:02:20,940
remember but has something to do with

00:02:17,790 --> 00:02:23,580
sensors and sport and what we were doing

00:02:20,940 --> 00:02:27,000
was we were sticking sensors on athletes

00:02:23,580 --> 00:02:30,300
the main target was pretty good sort of

00:02:27,000 --> 00:02:33,120
national level sprinters and that was

00:02:30,300 --> 00:02:35,040
somewhat challenging there weren't many

00:02:33,120 --> 00:02:37,620
platforms out there 10 years ago to do

00:02:35,040 --> 00:02:40,500
this with we did have one we had a thing

00:02:37,620 --> 00:02:41,910
called the I might to which was very

00:02:40,500 --> 00:02:43,950
similar to the gum sticks if anyone

00:02:41,910 --> 00:02:48,420
remembers the early gum sticks it's

00:02:43,950 --> 00:02:50,430
based on a px a 270 processor had sort

00:02:48,420 --> 00:02:52,920
of basic wireless capabilities but not

00:02:50,430 --> 00:02:54,390
Wi-Fi anything like that and it had the

00:02:52,920 --> 00:02:56,370
sort of early versions of what we now

00:02:54,390 --> 00:02:57,540
call capes or shields those sort of

00:02:56,370 --> 00:03:01,560
things you could plug another board in

00:02:57,540 --> 00:03:02,700
or a standard set of connectors now one

00:03:01,560 --> 00:03:04,709
of the first things we did with that is

00:03:02,700 --> 00:03:07,320
we actually wanted to run a Wi-Fi chip

00:03:04,709 --> 00:03:09,330
on it the very early SDIO open source

00:03:07,320 --> 00:03:11,780
drivers would just begin to appear so

00:03:09,330 --> 00:03:14,130
that was a marvel the Barrett Barrett s

00:03:11,780 --> 00:03:15,840
driver and to do that we needed to

00:03:14,130 --> 00:03:16,890
actually have the current kernel as

00:03:15,840 --> 00:03:19,080
opposed to the one that we got from

00:03:16,890 --> 00:03:21,510
Intel research that was some years I

00:03:19,080 --> 00:03:25,260
have day so we did that upstream that

00:03:21,510 --> 00:03:26,190
allsports still there then we came on to

00:03:25,260 --> 00:03:28,170
what we actually wanted to do was to

00:03:26,190 --> 00:03:31,800
measure things so we were looking at

00:03:28,170 --> 00:03:33,030
sensor drivers and the obvious question

00:03:31,800 --> 00:03:34,290
was yeah well we've kind of got used to

00:03:33,030 --> 00:03:36,000
this upstreaming thing it's quite nice

00:03:34,290 --> 00:03:37,470
it goes forward with new versions of the

00:03:36,000 --> 00:03:41,160
kernel we get new features we support

00:03:37,470 --> 00:03:42,900
new parts great so yeah here's upstream

00:03:41,160 --> 00:03:46,620
the sensor drivers so we had a bunch of

00:03:42,900 --> 00:03:48,030
them from Intel that they've done that

00:03:46,620 --> 00:03:51,720
we're in various states and we're sort

00:03:48,030 --> 00:03:53,250
of ok so how do we do this so now we

00:03:51,720 --> 00:03:54,840
come on to some requirements what do we

00:03:53,250 --> 00:03:57,060
actually want to do we wanted a simple

00:03:54,840 --> 00:03:59,160
interface option I'm doing very very

00:03:57,060 --> 00:04:00,450
straightforward hold we're munching have

00:03:59,160 --> 00:04:01,980
been around for a while used for

00:04:00,450 --> 00:04:05,100
monitoring things like fans temperature

00:04:01,980 --> 00:04:07,890
sensors you just read a CISO festival

00:04:05,100 --> 00:04:10,049
and you get a value is a nice string

00:04:07,890 --> 00:04:12,780
it's very simple what it efficient

00:04:10,049 --> 00:04:14,640
streaming however because you don't

00:04:12,780 --> 00:04:16,830
actually get to do much sort of inertial

00:04:14,640 --> 00:04:19,590
measurement of a sensor arm sensor on a

00:04:16,830 --> 00:04:23,190
sprinters leg if you only pull it a few

00:04:19,590 --> 00:04:25,110
times a second versus FS so we could

00:04:23,190 --> 00:04:26,650
look at input which has the whole event

00:04:25,110 --> 00:04:29,139
system

00:04:26,650 --> 00:04:30,550
it's moderately efficient but I am

00:04:29,139 --> 00:04:33,520
targeted at one very particular

00:04:30,550 --> 00:04:36,490
application which is human input so we

00:04:33,520 --> 00:04:39,220
did what you did in those days we asked

00:04:36,490 --> 00:04:40,660
the Linux kernel mailing list key thing

00:04:39,220 --> 00:04:42,460
wants back then a reasonable number of

00:04:40,660 --> 00:04:44,380
people actually read it's going to main

00:04:42,460 --> 00:04:47,320
list because it wasn't quite such a fire

00:04:44,380 --> 00:04:48,820
hoses that's become it was still a good

00:04:47,320 --> 00:04:51,820
few hundred messages a day but it you

00:04:48,820 --> 00:04:55,210
could actually get replies and then the

00:04:51,820 --> 00:04:56,979
answer was oh oh no we don't really do

00:04:55,210 --> 00:04:58,630
that in input don't we do that in

00:04:56,979 --> 00:04:59,949
Hardware monitoring doesn't really make

00:04:58,630 --> 00:05:04,060
sense to expand them you know you have

00:04:59,949 --> 00:05:05,320
to do something new now here's the first

00:05:04,060 --> 00:05:07,660
of the issues that were going to raise

00:05:05,320 --> 00:05:09,039
during this talk these were my

00:05:07,660 --> 00:05:11,110
requirements I had one particular

00:05:09,039 --> 00:05:13,600
project I had that first knowledge as

00:05:11,110 --> 00:05:15,729
we'll see they'll quite a number of

00:05:13,600 --> 00:05:21,850
other requirements came in from other

00:05:15,729 --> 00:05:24,340
users so what is I hey it's called

00:05:21,850 --> 00:05:26,380
industrial i/o for reasons that I be

00:05:24,340 --> 00:05:27,850
honest I can't quite remember we got

00:05:26,380 --> 00:05:31,180
into a whole naming debate and that's

00:05:27,850 --> 00:05:32,680
what came out so I'll start with a

00:05:31,180 --> 00:05:33,940
slightly backwards definition because

00:05:32,680 --> 00:05:36,970
this is one people often get a bit

00:05:33,940 --> 00:05:39,099
confused about is what isn't it it is

00:05:36,970 --> 00:05:40,539
not intended to be a replacement for

00:05:39,099 --> 00:05:42,639
those things that are already done well

00:05:40,539 --> 00:05:44,410
so here I'd listed it's not not

00:05:42,639 --> 00:05:46,150
replacement for Hardware monitoring it's

00:05:44,410 --> 00:05:48,910
not a replacement for input

00:05:46,150 --> 00:05:50,020
they both do their job these days we've

00:05:48,910 --> 00:05:53,740
had a few sensors that overlap with

00:05:50,020 --> 00:05:54,729
audio applications again if it's an

00:05:53,740 --> 00:06:00,910
audio device and you're using it for

00:05:54,729 --> 00:06:03,340
audio leave it in audio i/o is is broad

00:06:00,910 --> 00:06:05,050
we're not focused on one relatively

00:06:03,340 --> 00:06:06,910
narrow area we actually tried that

00:06:05,050 --> 00:06:10,599
because during the very early

00:06:06,910 --> 00:06:12,250
development Ohio Intel someone working

00:06:10,599 --> 00:06:13,330
for Intel Center driver for an ambient

00:06:12,250 --> 00:06:15,610
light sensor and said well is it's silly

00:06:13,330 --> 00:06:17,220
it's big complicated subsystem and all I

00:06:15,610 --> 00:06:20,800
want to do is to measure a light signal

00:06:17,220 --> 00:06:22,270
so we gave it a go we go all the way to

00:06:20,800 --> 00:06:23,889
a pull request to merge our new little

00:06:22,270 --> 00:06:25,860
subsystem so we've moved over a couple

00:06:23,889 --> 00:06:28,300
of drivers tomorrow at the time and

00:06:25,860 --> 00:06:30,580
various people chipped in at the end

00:06:28,300 --> 00:06:33,250
including Lunas and he made a very good

00:06:30,580 --> 00:06:34,750
statement as as you know if you've ever

00:06:33,250 --> 00:06:37,960
had a pull request we could rejected

00:06:34,750 --> 00:06:40,409
it's a somewhat of a knock back but he

00:06:37,960 --> 00:06:42,449
was right so he said I do think that

00:06:40,409 --> 00:06:44,459
it's crazy to start doing new subsystems

00:06:42,449 --> 00:06:49,619
for every little thing that way lies

00:06:44,459 --> 00:06:50,999
madness yeah so we went back and carried

00:06:49,619 --> 00:06:53,939
on plowing on the IO for another couple

00:06:50,999 --> 00:06:56,099
of months before we got anyway so now we

00:06:53,939 --> 00:06:58,849
get on to what devices do we support

00:06:56,099 --> 00:07:03,139
because that sort of defines what IO is

00:06:58,849 --> 00:07:06,239
so basically anything that's an ADC so

00:07:03,139 --> 00:07:08,929
takes a analog signal in gives you a

00:07:06,239 --> 00:07:12,209
nice number somewhere in your processor

00:07:08,929 --> 00:07:13,019
a digital to analog converter so the Dax

00:07:12,209 --> 00:07:16,800
going the other way

00:07:13,019 --> 00:07:18,689
that was added a while later but you get

00:07:16,800 --> 00:07:20,429
parts that do both so it makes sense to

00:07:18,689 --> 00:07:22,289
share as much infrastructure as possible

00:07:20,429 --> 00:07:24,059
and there are certain similarities of

00:07:22,289 --> 00:07:25,829
though there are also differences for

00:07:24,059 --> 00:07:28,589
what you do when you're coming in and

00:07:25,829 --> 00:07:30,269
what you're doing out so just listed a

00:07:28,589 --> 00:07:32,610
few things here a DC is you've got

00:07:30,269 --> 00:07:35,699
accelerometers gyroscopes magnetometers

00:07:32,610 --> 00:07:38,309
I'm use white sensors chemical sensors a

00:07:35,699 --> 00:07:41,159
lot of volatile organic compound sensors

00:07:38,309 --> 00:07:44,279
fairly recently things for measuring

00:07:41,159 --> 00:07:47,849
pollution dangerous gas sensors have

00:07:44,279 --> 00:07:50,669
started turning up health sensors things

00:07:47,849 --> 00:07:52,439
like pulse oximeters where you shine a

00:07:50,669 --> 00:07:54,629
light through someone's finger and you

00:07:52,439 --> 00:07:57,149
can measure their pulse rate fairly

00:07:54,629 --> 00:07:59,219
indirect rotation sensors and others

00:07:57,149 --> 00:08:02,219
thanks tend to be a bit simpler it's

00:07:59,219 --> 00:08:06,449
mostly actual stacks and digital

00:08:02,219 --> 00:08:07,800
potentiometers so now I mentioned

00:08:06,449 --> 00:08:09,959
earlier that the key thing is the

00:08:07,800 --> 00:08:15,029
interface of what what is the interface

00:08:09,959 --> 00:08:17,610
fire it's meant the purpose of having

00:08:15,029 --> 00:08:19,979
this interface is to allow generic user

00:08:17,610 --> 00:08:23,579
space code so I've listed a few examples

00:08:19,979 --> 00:08:26,909
here so we've got libero AO IO sensor

00:08:23,579 --> 00:08:29,639
proxy which is positive gnome I think

00:08:26,909 --> 00:08:33,589
and some work intel did on an android

00:08:29,639 --> 00:08:35,639
sensor how there are others

00:08:33,589 --> 00:08:36,569
lots of people spin their own because

00:08:35,639 --> 00:08:39,569
they're doing one very particular

00:08:36,569 --> 00:08:42,539
application and we have example code in

00:08:39,569 --> 00:08:44,339
tools in the kernel now the key thing is

00:08:42,539 --> 00:08:46,470
it must be consistent and one of my

00:08:44,339 --> 00:08:49,319
personal aims in any sort of user space

00:08:46,470 --> 00:08:50,610
interface is if at all possible you

00:08:49,319 --> 00:08:53,459
shouldn't have to read the documentation

00:08:50,610 --> 00:08:53,760
to work out what it's doing and what

00:08:53,459 --> 00:08:55,670
that

00:08:53,760 --> 00:08:59,220
you just read from Sisyphus actually is

00:08:55,670 --> 00:09:00,630
so there are no magic numbers they

00:08:59,220 --> 00:09:03,930
obvious did a few of the principles we

00:09:00,630 --> 00:09:05,460
built upon so we decided and this is

00:09:03,930 --> 00:09:08,490
different for instance for more input

00:09:05,460 --> 00:09:11,820
does we so the all control and metadata

00:09:08,490 --> 00:09:13,560
would be via Sisyphus when you read from

00:09:11,820 --> 00:09:16,440
the buffered sort of interface and come

00:09:13,560 --> 00:09:18,930
out on a character device you just get

00:09:16,440 --> 00:09:20,640
data you don't get and you can telling

00:09:18,930 --> 00:09:22,500
you what that data is because that's

00:09:20,640 --> 00:09:23,940
considered to be predictable because

00:09:22,500 --> 00:09:27,690
you've configured what you want to come

00:09:23,940 --> 00:09:29,610
out we do have single channel polled

00:09:27,690 --> 00:09:31,500
reads for a Sisyphus so this is again

00:09:29,610 --> 00:09:33,390
similar to what Hardware monitoring does

00:09:31,500 --> 00:09:35,160
it gives you a very quick and easy way

00:09:33,390 --> 00:09:37,050
of just reading what's the value on my

00:09:35,160 --> 00:09:38,640
sensor now if nothing else even on

00:09:37,050 --> 00:09:40,530
high-speed systems it's awfully useful

00:09:38,640 --> 00:09:44,180
for debugging just to be able to poke it

00:09:40,530 --> 00:09:48,300
with cat we then use character devices

00:09:44,180 --> 00:09:49,920
for getting the actual main data flow

00:09:48,300 --> 00:09:53,580
out when we run in at any significant

00:09:49,920 --> 00:09:55,170
speed with FIFO so that you don't

00:09:53,580 --> 00:09:56,160
actually have to have user space

00:09:55,170 --> 00:09:58,980
constantly ready

00:09:56,160 --> 00:10:00,750
to get the data it can come back and in

00:09:58,980 --> 00:10:02,730
a synchronous fashion we also use

00:10:00,750 --> 00:10:04,290
character devices for events we do have

00:10:02,730 --> 00:10:06,000
some other interfaces for high speed

00:10:04,290 --> 00:10:07,980
devices but I'm not going to touch on

00:10:06,000 --> 00:10:12,420
those much today just is this too much

00:10:07,980 --> 00:10:15,000
to cover so very brief summary of the

00:10:12,420 --> 00:10:18,750
architecture and this will lead on to

00:10:15,000 --> 00:10:21,570
our second issue so there are two sort

00:10:18,750 --> 00:10:23,820
of fundamental ways to use IO you either

00:10:21,570 --> 00:10:26,880
use a simple polled read where you just

00:10:23,820 --> 00:10:29,310
read him from CFS or use this concept of

00:10:26,880 --> 00:10:32,490
triggers and buffers there was a talk

00:10:29,310 --> 00:10:33,780
earlier today looking at UAVs and he

00:10:32,490 --> 00:10:34,770
covered this actually quite well so I'm

00:10:33,780 --> 00:10:37,470
only going to touch them it fairly

00:10:34,770 --> 00:10:39,930
briefly but the basic concept is that a

00:10:37,470 --> 00:10:42,510
trigger is it's not like an oscilloscope

00:10:39,930 --> 00:10:44,370
trigger where you one signal fires off a

00:10:42,510 --> 00:10:46,770
whole range of captures afterwards and

00:10:44,370 --> 00:10:49,110
you get well whatever fits on the screen

00:10:46,770 --> 00:10:51,180
or whatever your buffer set - it's much

00:10:49,110 --> 00:10:54,150
closer to the sort of trigger you use on

00:10:51,180 --> 00:10:56,370
a camera where you're saying capture me

00:10:54,150 --> 00:11:00,480
all of the pixels as close as possible

00:10:56,370 --> 00:11:02,370
to now so what you will do is you will

00:11:00,480 --> 00:11:05,730
gather a series of concurrent samples

00:11:02,370 --> 00:11:07,200
from all the enabled channels as I

00:11:05,730 --> 00:11:09,000
mentioned a moment ago we

00:11:07,200 --> 00:11:11,880
use buffering it's actually just

00:11:09,000 --> 00:11:14,270
implemented as a k5o in order to allow

00:11:11,880 --> 00:11:17,820
asynchronous reads

00:11:14,270 --> 00:11:20,190
so here's the simplest one this is just

00:11:17,820 --> 00:11:23,070
a Sisyphus read so we start there on the

00:11:20,190 --> 00:11:25,920
top left of the green block and we read

00:11:23,070 --> 00:11:29,100
a Sisyphus fall it cools down into the

00:11:25,920 --> 00:11:30,450
IO core down it goes via callbacks get

00:11:29,100 --> 00:11:32,640
some meta data so it actually knows

00:11:30,450 --> 00:11:35,040
which time all it was so associates it

00:11:32,640 --> 00:11:36,270
with the file you actually read from and

00:11:35,040 --> 00:11:40,010
at the end it chats to the hardware

00:11:36,270 --> 00:11:43,920
typically this is over I to C or SPI or

00:11:40,010 --> 00:11:45,960
any number of other buses yeah pretty

00:11:43,920 --> 00:11:47,520
much anything including weird and

00:11:45,960 --> 00:11:48,960
wonderful custom buses that seem people

00:11:47,520 --> 00:11:52,440
seem to like with sensors occasionally

00:11:48,960 --> 00:11:54,360
and then on the way back the value is

00:11:52,440 --> 00:11:56,340
returned up to i/o core which is

00:11:54,360 --> 00:11:58,680
responsible for doing formatting so what

00:11:56,340 --> 00:12:00,750
it does is it takes a number in a

00:11:58,680 --> 00:12:02,250
particular and and it has a specified

00:12:00,750 --> 00:12:06,720
format coming from the driver that says

00:12:02,250 --> 00:12:08,520
this is an integer plus some micro

00:12:06,720 --> 00:12:10,170
element it's the way it's defined and

00:12:08,520 --> 00:12:12,210
this is just to give us a something

00:12:10,170 --> 00:12:13,500
that's a bit close to floating-point but

00:12:12,210 --> 00:12:15,630
it's a bit more constrained and easier

00:12:13,500 --> 00:12:18,180
to handle typically in the kernel and

00:12:15,630 --> 00:12:20,700
then we return a string up to user space

00:12:18,180 --> 00:12:22,310
now the classic question we got asked in

00:12:20,700 --> 00:12:24,330
the early days and it's come up

00:12:22,310 --> 00:12:25,770
relatively recently with Hardware

00:12:24,330 --> 00:12:28,950
monitoring which has kind of slowly

00:12:25,770 --> 00:12:31,080
moving in the direction we did is why do

00:12:28,950 --> 00:12:33,450
you have the core in there you're just

00:12:31,080 --> 00:12:34,620
reading a file and your drivers

00:12:33,450 --> 00:12:36,600
returning a value it could do everything

00:12:34,620 --> 00:12:38,580
and the way it was doing Hardware motion

00:12:36,600 --> 00:12:40,890
as it was always the ABI was enforced by

00:12:38,580 --> 00:12:43,200
review you just looked very very

00:12:40,890 --> 00:12:44,850
carefully at what every driver was

00:12:43,200 --> 00:12:48,560
providing in the way of CFS interface

00:12:44,850 --> 00:12:50,430
and ensured that it act with the spec

00:12:48,560 --> 00:12:53,250
there's nothing else that makes review

00:12:50,430 --> 00:12:56,490
really tricky because you've got a lot

00:12:53,250 --> 00:12:58,020
of sisyphus files names to read so

00:12:56,490 --> 00:13:00,870
that's one of the advantages you enforce

00:12:58,020 --> 00:13:02,850
an ABI by making it sort of structured

00:13:00,870 --> 00:13:05,220
so that the core gets a definition of

00:13:02,850 --> 00:13:06,690
what it is going to read and you have to

00:13:05,220 --> 00:13:09,120
keep to attend all the file names and

00:13:06,690 --> 00:13:11,010
things are generated from that and the

00:13:09,120 --> 00:13:14,220
other use is the first of our

00:13:11,010 --> 00:13:16,500
requirements changes that came in so

00:13:14,220 --> 00:13:19,710
this came took after a conversation at

00:13:16,500 --> 00:13:20,640
this same conference five years ago in

00:13:19,710 --> 00:13:22,920
Edinburgh

00:13:20,640 --> 00:13:25,980
with mark brown he said well I kind of

00:13:22,920 --> 00:13:27,780
want to do SOC ABCs and they get used

00:13:25,980 --> 00:13:29,580
for everything I want one subsystem I

00:13:27,780 --> 00:13:33,080
don't want to have a different subsystem

00:13:29,580 --> 00:13:35,730
for doing touch screens for measuring

00:13:33,080 --> 00:13:37,220
the sort of battery voltages these sort

00:13:35,730 --> 00:13:39,450
of things it's all the same hardware

00:13:37,220 --> 00:13:42,510
obviously we need some stuff above to do

00:13:39,450 --> 00:13:44,160
the sort of user space format in and all

00:13:42,510 --> 00:13:46,770
to provide that information to where it

00:13:44,160 --> 00:13:48,450
needs to be now a pun was in i/o at the

00:13:46,770 --> 00:13:51,210
time we didn't really have that layer of

00:13:48,450 --> 00:13:53,370
separation but because we had this

00:13:51,210 --> 00:13:55,380
passed through the core we have a

00:13:53,370 --> 00:13:56,820
slightly alternative one and so this is

00:13:55,380 --> 00:13:59,550
the in kernel interface that you can see

00:13:56,820 --> 00:14:01,350
looks almost exactly the same so you do

00:13:59,550 --> 00:14:04,260
a read but now it's not from user space

00:14:01,350 --> 00:14:06,060
it's from another driver and it goes

00:14:04,260 --> 00:14:08,400
down through the same path callbacks

00:14:06,060 --> 00:14:10,890
adds metadata all the way back but this

00:14:08,400 --> 00:14:12,360
time we don't pass a string we just

00:14:10,890 --> 00:14:15,030
passed the actual values and the

00:14:12,360 --> 00:14:18,360
description of what format they're in to

00:14:15,030 --> 00:14:19,650
the consumer driver and this is used for

00:14:18,360 --> 00:14:21,360
a number of things we've got a bird

00:14:19,650 --> 00:14:23,120
driver two Hardware monitoring for those

00:14:21,360 --> 00:14:25,200
occasions when you've got a nice fast

00:14:23,120 --> 00:14:26,340
typically so people quite often do

00:14:25,200 --> 00:14:28,890
Hardware monitoring with one mega

00:14:26,340 --> 00:14:30,120
Swampert a DC's which makes no real

00:14:28,890 --> 00:14:32,820
sense except for the fact that they had

00:14:30,120 --> 00:14:36,060
a box of those on the shelf so they use

00:14:32,820 --> 00:14:38,550
them and we're not going to have two

00:14:36,060 --> 00:14:39,900
drivers in Linux to support the very

00:14:38,550 --> 00:14:43,080
very slow case where you're just reading

00:14:39,900 --> 00:14:45,720
a temperature a few times a second so we

00:14:43,080 --> 00:14:48,930
do it using this approach of an in

00:14:45,720 --> 00:14:51,890
kernel call into a an i/o driver and

00:14:48,930 --> 00:14:55,590
there are the users so thermal battery

00:14:51,890 --> 00:14:57,030
monitoring and other i/o devices we'll

00:14:55,590 --> 00:14:58,890
have some examples of those in a few

00:14:57,030 --> 00:15:00,660
minutes so this is the more complex play

00:14:58,890 --> 00:15:04,800
so this is the one where we're doing the

00:15:00,660 --> 00:15:07,710
triggers put into the buffers so down in

00:15:04,800 --> 00:15:09,210
the bottom left there we've got a this

00:15:07,710 --> 00:15:11,670
is a typical device it has a data ready

00:15:09,210 --> 00:15:13,890
signal it's self clocked it has its own

00:15:11,670 --> 00:15:16,500
sequencer and it's just feeding data

00:15:13,890 --> 00:15:19,050
rails on its own sort of internal tick

00:15:16,500 --> 00:15:21,540
that you've configured so the first

00:15:19,050 --> 00:15:22,740
thing you see on the left here is we we

00:15:21,540 --> 00:15:24,810
actually have a separate chunk in IO

00:15:22,740 --> 00:15:25,980
which is known as an IO trigger now this

00:15:24,810 --> 00:15:28,290
doesn't actually have to be coming from

00:15:25,980 --> 00:15:30,120
the same hardware at all and also it

00:15:28,290 --> 00:15:31,950
doesn't have to just get fed to the same

00:15:30,120 --> 00:15:34,020
hardware so in this example we've got it

00:15:31,950 --> 00:15:34,370
split two ways so we're actually running

00:15:34,020 --> 00:15:36,560
two

00:15:34,370 --> 00:15:38,990
different i/o devices of one data ready

00:15:36,560 --> 00:15:40,850
trigger seems an odd thing to do but if

00:15:38,990 --> 00:15:43,040
like I was in the early days you're

00:15:40,850 --> 00:15:44,660
working with inertial sensors it's quite

00:15:43,040 --> 00:15:46,310
common to want to be able to grab the

00:15:44,660 --> 00:15:49,130
gyroscope at the same time as the

00:15:46,310 --> 00:15:50,930
accelerometer or as at least as close as

00:15:49,130 --> 00:15:54,800
you possibly can and in some sort of

00:15:50,930 --> 00:15:57,200
constrained time difference so from

00:15:54,800 --> 00:15:59,060
there we go across and we say okay so we

00:15:57,200 --> 00:16:00,380
know we now know there's data to read so

00:15:59,060 --> 00:16:02,750
we got lost the hardware for the the

00:16:00,380 --> 00:16:04,580
data that comes and we call this thing

00:16:02,750 --> 00:16:07,580
called push two buffers which originally

00:16:04,580 --> 00:16:09,830
just pushed into a K FIFO and up to user

00:16:07,580 --> 00:16:12,860
space but again because we had this ABI

00:16:09,830 --> 00:16:14,750
I'm sort of abstraction layer we had the

00:16:12,860 --> 00:16:16,880
option when when you did the sock ADCs

00:16:14,750 --> 00:16:19,040
to come along and say well actually what

00:16:16,880 --> 00:16:22,100
we can do here is we can put a d' marks

00:16:19,040 --> 00:16:24,070
in there we can split the superset of

00:16:22,100 --> 00:16:26,300
all the channels that anyone's asked for

00:16:24,070 --> 00:16:28,310
into two different data streams and we

00:16:26,300 --> 00:16:30,830
can send one off to our consumer device

00:16:28,310 --> 00:16:32,120
or to multiple consumer devices you can

00:16:30,830 --> 00:16:34,370
have pretty much as many of those as you

00:16:32,120 --> 00:16:35,900
like and one up towards I use this place

00:16:34,370 --> 00:16:38,029
interface so on the left in that branch

00:16:35,900 --> 00:16:41,150
to seven bi I got a bit carried away

00:16:38,029 --> 00:16:44,120
here it goes to an internal internal

00:16:41,150 --> 00:16:46,100
user and on the right it goes towards

00:16:44,120 --> 00:16:49,130
our user space where we add it to the

00:16:46,100 --> 00:16:51,709
tail of the K FIFO and we have things

00:16:49,130 --> 00:16:55,190
like watershed interrupts you can

00:16:51,709 --> 00:16:56,990
control yeah how long basically it is

00:16:55,190 --> 00:17:00,500
before you send it interrupts up to user

00:16:56,990 --> 00:17:02,300
space and the user space sort of portion

00:17:00,500 --> 00:17:05,300
of the code can be sitting there using

00:17:02,300 --> 00:17:07,610
select or pole to wait until there's

00:17:05,300 --> 00:17:09,890
that much data are available and then it

00:17:07,610 --> 00:17:14,959
goes in and queries and does the read

00:17:09,890 --> 00:17:16,760
and gets the data so the problem we had

00:17:14,959 --> 00:17:18,230
was we've now come up with this this

00:17:16,760 --> 00:17:20,839
situation where we can handle and can

00:17:18,230 --> 00:17:24,890
see in kernel consumers and we can

00:17:20,839 --> 00:17:26,540
handle user space now what we do still

00:17:24,890 --> 00:17:28,100
have is we have very tight coupling that

00:17:26,540 --> 00:17:29,960
user space interface is not currently

00:17:28,100 --> 00:17:32,870
optional it's been on the list of things

00:17:29,960 --> 00:17:35,450
to fix for a very long time and we're

00:17:32,870 --> 00:17:37,130
sort of slowly occasionally moving in

00:17:35,450 --> 00:17:39,500
that direction so the idea is that in

00:17:37,130 --> 00:17:41,780
many stock cases you actually don't care

00:17:39,500 --> 00:17:46,400
about to use the space iobit because no

00:17:41,780 --> 00:17:49,419
one's gonna read it now I don't know if

00:17:46,400 --> 00:17:51,409
to anyone that it's a little bit complex

00:17:49,419 --> 00:17:53,120
so the classic question we always get

00:17:51,409 --> 00:17:56,659
asked is why why did you end up with

00:17:53,120 --> 00:17:58,220
something so complex and there's

00:17:56,659 --> 00:18:00,379
basically one word for that flexibility

00:17:58,220 --> 00:18:02,110
we had a number of different use cases

00:18:00,379 --> 00:18:03,980
we have people starting to do

00:18:02,110 --> 00:18:05,539
software-defined radio although that

00:18:03,980 --> 00:18:06,679
needs a whole load of extra

00:18:05,539 --> 00:18:08,659
infrastructure which we'll talk about

00:18:06,679 --> 00:18:10,669
later because the data rates are very

00:18:08,659 --> 00:18:13,639
high we had myself who is still trying

00:18:10,669 --> 00:18:15,320
to measure stuff on athletes and we have

00:18:13,639 --> 00:18:17,870
the guys are trying to do power

00:18:15,320 --> 00:18:20,179
monitoring similar sort of applications

00:18:17,870 --> 00:18:22,759
or light sensors or to take someone's

00:18:20,179 --> 00:18:24,529
pulse so the key thing here is you know

00:18:22,759 --> 00:18:26,000
all devices have to do it all pretty

00:18:24,529 --> 00:18:27,649
much everything in here is optional and

00:18:26,000 --> 00:18:29,750
when you first try to drive that you may

00:18:27,649 --> 00:18:32,389
well write only some small subset you

00:18:29,750 --> 00:18:33,860
might just do so surface probably so you

00:18:32,389 --> 00:18:35,509
just do the simple reads of a channel

00:18:33,860 --> 00:18:37,519
some devices never go beyond that

00:18:35,509 --> 00:18:40,460
they're slow there's never any reasons

00:18:37,519 --> 00:18:41,779
support the other interfaces and I

00:18:40,460 --> 00:18:43,070
mentioned with the triggers you can

00:18:41,779 --> 00:18:45,409
actually end up in the situation where

00:18:43,070 --> 00:18:47,120
one device provides the trigger and this

00:18:45,409 --> 00:18:48,559
could be something like a high

00:18:47,120 --> 00:18:51,799
resolution timer it doesn't even have to

00:18:48,559 --> 00:18:54,769
be a piece of sort of explicit ohio

00:18:51,799 --> 00:18:56,529
hardware we have sisyphus triggers where

00:18:54,769 --> 00:18:59,269
you just poke a file in sisyphus and

00:18:56,529 --> 00:19:00,590
that results in all of your sensors that

00:18:59,269 --> 00:19:04,009
you've got attached to that trigger

00:19:00,590 --> 00:19:06,409
grabbing a set of data and the other aim

00:19:04,009 --> 00:19:08,570
ultimately is the i/o user space should

00:19:06,409 --> 00:19:10,190
just be yet another internal user and

00:19:08,570 --> 00:19:12,200
the reason for this is that we only end

00:19:10,190 --> 00:19:16,309
up with one code path so there's less

00:19:12,200 --> 00:19:18,169
code to look after specs ability also

00:19:16,309 --> 00:19:20,450
lets us do cool things so I like these

00:19:18,169 --> 00:19:22,549
examples this is a fairly heavy

00:19:20,450 --> 00:19:25,250
contributor so I own in recent years

00:19:22,549 --> 00:19:27,710
peter rosen and he always seems to want

00:19:25,250 --> 00:19:30,049
to measure really strange things so in

00:19:27,710 --> 00:19:31,429
this particular case he was looking at

00:19:30,049 --> 00:19:33,230
envelope rotations this is where you've

00:19:31,429 --> 00:19:35,870
got a relatively fast-moving waveform

00:19:33,230 --> 00:19:37,759
and all you actually care about is what

00:19:35,870 --> 00:19:39,049
is the maximum value it ever reaches and

00:19:37,759 --> 00:19:42,230
what is the minimum value it ever

00:19:39,049 --> 00:19:44,570
reaches obviously you could sample that

00:19:42,230 --> 00:19:46,070
with an extremely fast ADC but the

00:19:44,570 --> 00:19:49,700
approach that's often used is to use a

00:19:46,070 --> 00:19:52,039
comparator but a comparator if it gives

00:19:49,700 --> 00:19:53,779
you a value as your output is

00:19:52,039 --> 00:19:56,299
effectively an ADC it's just maybe see

00:19:53,779 --> 00:19:59,690
measuring the maximum minimum or one at

00:19:56,299 --> 00:20:02,450
a time of the waveform so he prevented

00:19:59,690 --> 00:20:04,810
this using those consumer and

00:20:02,450 --> 00:20:08,750
so what we actually have is we have a

00:20:04,810 --> 00:20:10,010
comparison driver that takes the input

00:20:08,750 --> 00:20:12,980
signal that you actually trying to

00:20:10,010 --> 00:20:14,990
measure but it also is using a DAC via a

00:20:12,980 --> 00:20:16,670
consumer interface it's kind of the

00:20:14,990 --> 00:20:19,340
wrong name for it when we're driving a

00:20:16,670 --> 00:20:21,830
tank but anyway it controls the DAC and

00:20:19,340 --> 00:20:25,010
then you get a nice interrupts out if

00:20:21,830 --> 00:20:26,750
your waveform crosses the threshold and

00:20:25,010 --> 00:20:28,370
if it does you change your value of you

00:20:26,750 --> 00:20:30,800
that can you try again are you on a bit

00:20:28,370 --> 00:20:32,750
longer and sooner or later you converge

00:20:30,800 --> 00:20:34,640
at the right place the reasons I never

00:20:32,750 --> 00:20:35,600
quite established he also didn't

00:20:34,640 --> 00:20:37,030
actually have a DAC

00:20:35,600 --> 00:20:39,020
what he had was a digital potentiometer

00:20:37,030 --> 00:20:41,780
so we ended up with this chain of

00:20:39,020 --> 00:20:43,970
devices so he implemented the DAC using

00:20:41,780 --> 00:20:46,490
digital potentiometer using the inker

00:20:43,970 --> 00:20:49,940
kernel consumer interface which was then

00:20:46,490 --> 00:20:51,410
used by the comparator and then the

00:20:49,940 --> 00:20:53,690
ultimate thing ended up building one

00:20:51,410 --> 00:20:55,580
device out of a number of independent

00:20:53,690 --> 00:20:57,970
components and you can replace any of

00:20:55,580 --> 00:21:00,740
these with an alternative implementation

00:20:57,970 --> 00:21:01,220
just recently we have also gained our

00:21:00,740 --> 00:21:05,240
first

00:21:01,220 --> 00:21:08,690
generic ADC driver done sorry agency

00:21:05,240 --> 00:21:09,920
touchscreen driver so this is a problem

00:21:08,690 --> 00:21:11,930
for a lot of touchscreen controllers

00:21:09,920 --> 00:21:14,570
because they often have some strange

00:21:11,930 --> 00:21:16,160
built in sequence in hardware so they're

00:21:14,570 --> 00:21:17,780
not easily mapped directly onto an ADC

00:21:16,160 --> 00:21:19,970
but there is a class of relatively

00:21:17,780 --> 00:21:21,950
simple devices particularly resistive

00:21:19,970 --> 00:21:24,890
touchscreens way you can do this so you

00:21:21,950 --> 00:21:26,450
can have one driver plug it in to so you

00:21:24,890 --> 00:21:31,450
plug your touchscreen into an ADC and

00:21:26,450 --> 00:21:33,980
you can use it as a normal input device

00:21:31,450 --> 00:21:36,260
so this is sort of the biggest issue

00:21:33,980 --> 00:21:37,490
we're trying to design a subsystem even

00:21:36,260 --> 00:21:40,490
over ten years I've tried to think what

00:21:37,490 --> 00:21:42,340
it'll be like in longer time period it's

00:21:40,490 --> 00:21:44,990
very difficult to predict the future

00:21:42,340 --> 00:21:49,520
some of these arguably we should have

00:21:44,990 --> 00:21:50,600
noticed API mistakes so things not to do

00:21:49,520 --> 00:21:54,950
should you be trying to come up with an

00:21:50,600 --> 00:21:56,600
API don't ever think wouldn't it be nice

00:21:54,950 --> 00:21:58,730
if we could just get rid of that index

00:21:56,600 --> 00:22:01,310
there because hardly ever used so we can

00:21:58,730 --> 00:22:03,320
make it optional because you end up with

00:22:01,310 --> 00:22:06,140
things like this so initially we thought

00:22:03,320 --> 00:22:08,030
well if it's an accelerometer it'll have

00:22:06,140 --> 00:22:11,870
a direction typically associated with an

00:22:08,030 --> 00:22:13,670
axis and we define X Y Zed we also have

00:22:11,870 --> 00:22:15,140
separately the ability to give channels

00:22:13,670 --> 00:22:15,950
and index because if it's nadie C

00:22:15,140 --> 00:22:17,120
obviously

00:22:15,950 --> 00:22:19,730
when I said it doesn't make a lot of

00:22:17,120 --> 00:22:21,320
sense but then we sort of defined it so

00:22:19,730 --> 00:22:23,660
that typically you don't use one or the

00:22:21,320 --> 00:22:26,090
other of course lo and behold along came

00:22:23,660 --> 00:22:28,370
a three axis accelerometer with two

00:22:26,090 --> 00:22:30,320
accelerometers on each axis covering

00:22:28,370 --> 00:22:32,240
different ranges and suddenly we ended

00:22:30,320 --> 00:22:34,460
up having to have user space support

00:22:32,240 --> 00:22:36,470
what was in theory always possible but

00:22:34,460 --> 00:22:38,570
never implemented which was both at the

00:22:36,470 --> 00:22:42,140
same time so we should just had the

00:22:38,570 --> 00:22:44,240
index there from start here's another

00:22:42,140 --> 00:22:46,130
one in the early days we were trying to

00:22:44,240 --> 00:22:47,720
remain as compatible as possible with

00:22:46,130 --> 00:22:50,540
harbor monitoring thinking other's loads

00:22:47,720 --> 00:22:52,460
of code out there let's try and use the

00:22:50,540 --> 00:22:55,460
same naming let's try and use the same

00:22:52,460 --> 00:22:57,740
units so that people can just use their

00:22:55,460 --> 00:22:59,240
existing code it's an ADC in a different

00:22:57,740 --> 00:23:02,450
subsystem but otherwise you've got to

00:22:59,240 --> 00:23:04,610
point it at a different set of files now

00:23:02,450 --> 00:23:06,110
Halldor mantra is targeted at one very

00:23:04,610 --> 00:23:08,270
particular application which is

00:23:06,110 --> 00:23:10,280
monitoring pretty much currents and

00:23:08,270 --> 00:23:13,610
voltages and things like fan speeds and

00:23:10,280 --> 00:23:15,590
temperatures on a motherboard and they

00:23:13,610 --> 00:23:17,960
tend to come in nice well-defined ranges

00:23:15,590 --> 00:23:20,300
so you tend to measure things in

00:23:17,960 --> 00:23:22,640
millivolts beakers probably not going

00:23:20,300 --> 00:23:25,610
above 12 volts so plenty of room in a

00:23:22,640 --> 00:23:28,070
reasonably small number of bits and then

00:23:25,610 --> 00:23:30,020
comes along some of the three phase

00:23:28,070 --> 00:23:33,740
power monitors and similar stuff where

00:23:30,020 --> 00:23:36,470
suddenly we're up at well small numbers

00:23:33,740 --> 00:23:38,330
of kilovolts and then some of the

00:23:36,470 --> 00:23:40,280
extremely precise ADCs measuring at the

00:23:38,330 --> 00:23:43,460
other end and we're down in very very

00:23:40,280 --> 00:23:46,400
small numbers of micro volts or Pico

00:23:43,460 --> 00:23:47,870
volts now we do have the ability to

00:23:46,400 --> 00:23:48,980
cover that range because I mentioned

00:23:47,870 --> 00:23:50,300
earlier we do have this concept of the

00:23:48,980 --> 00:23:52,670
type that allows you to basically

00:23:50,300 --> 00:23:55,100
redefine what the valley you passed out

00:23:52,670 --> 00:23:59,570
was is the gain a sort of pseudo

00:23:55,100 --> 00:24:01,100
floating point without the nasty mass so

00:23:59,570 --> 00:24:02,150
what we should actually have done is in

00:24:01,100 --> 00:24:03,860
the first place just go we're gonna pick

00:24:02,150 --> 00:24:08,060
us down at you I'm gonna go with normal

00:24:03,860 --> 00:24:10,850
SI units volts amps watts don't don't

00:24:08,060 --> 00:24:12,140
get into the game of trying to match the

00:24:10,850 --> 00:24:13,370
reason this is a problem is that you do

00:24:12,140 --> 00:24:15,230
have to look at the documents to know

00:24:13,370 --> 00:24:16,940
what the unit is for some of the very

00:24:15,230 --> 00:24:18,290
standard measurements whereas if we just

00:24:16,940 --> 00:24:18,740
gone with the basic ones everyone would

00:24:18,290 --> 00:24:21,530
have known

00:24:18,740 --> 00:24:23,960
and I'd say once or twice a year one

00:24:21,530 --> 00:24:26,120
gets passed and we end up with a fixed

00:24:23,960 --> 00:24:28,870
patch going ah this was out by a factor

00:24:26,120 --> 00:24:28,870
of ten to the six

00:24:28,940 --> 00:24:36,350
only noticed once it gets to some user

00:24:30,890 --> 00:24:38,270
space app and think had a crazy graph so

00:24:36,350 --> 00:24:40,940
here's another one we have this sort of

00:24:38,270 --> 00:24:44,720
wide range in IO we have lots of

00:24:40,940 --> 00:24:46,700
different devices now we spend a lot of

00:24:44,720 --> 00:24:49,760
time trying to work out how to abstract

00:24:46,700 --> 00:24:52,210
a new class of device so that we can

00:24:49,760 --> 00:24:55,100
represent it in a way that is consistent

00:24:52,210 --> 00:24:57,560
with what we've already got now we did

00:24:55,100 --> 00:24:59,630
this for counter drivers so this is

00:24:57,560 --> 00:25:01,700
things that are measuring quadrature

00:24:59,630 --> 00:25:03,800
encoders typically they're measuring

00:25:01,700 --> 00:25:08,690
something thats related to rotation but

00:25:03,800 --> 00:25:11,990
name may not be directly they don't fit

00:25:08,690 --> 00:25:13,700
well we kind of made it work but it was

00:25:11,990 --> 00:25:17,330
getting stretched more and more and more

00:25:13,700 --> 00:25:19,880
we were abusing various interfaces it

00:25:17,330 --> 00:25:22,790
wasn't pretty so actually we've got in

00:25:19,880 --> 00:25:26,500
fairly final stages of review a separate

00:25:22,790 --> 00:25:26,500
counter subsystem it didn't make sense

00:25:27,070 --> 00:25:34,130
so my screen just bit um yeah so having

00:25:32,870 --> 00:25:37,390
moved that out we've ended up with a

00:25:34,130 --> 00:25:39,380
much cleaner abstraction it's much more

00:25:37,390 --> 00:25:41,210
appropriately flexible especially in the

00:25:39,380 --> 00:25:42,380
right places rather than allowing you to

00:25:41,210 --> 00:25:45,080
do things that make no sense um

00:25:42,380 --> 00:25:47,240
quadrature encoders however we do of

00:25:45,080 --> 00:25:48,770
course have to maintain the historic ABI

00:25:47,240 --> 00:25:50,090
so those drivers that have been in i/o

00:25:48,770 --> 00:25:54,040
for a while they're gonna have to do

00:25:50,090 --> 00:25:54,040
both which is not great

00:26:00,410 --> 00:26:04,460
so this is probably the most complex one

00:26:02,510 --> 00:26:07,850
so I only touched on this briefly but

00:26:04,460 --> 00:26:10,130
one side effects are bolting in the sort

00:26:07,850 --> 00:26:13,280
of sock ADC use case within kernel

00:26:10,130 --> 00:26:15,620
interfaces was that we have a problem

00:26:13,280 --> 00:26:17,330
with our original CFS interface which is

00:26:15,620 --> 00:26:19,550
if you've got an internal user say a

00:26:17,330 --> 00:26:22,490
touchscreen that's sitting there wanting

00:26:19,550 --> 00:26:24,020
to read the X and y-axis of the

00:26:22,490 --> 00:26:26,930
touchscreen and he wants to do it at

00:26:24,020 --> 00:26:28,430
nice high rates it's very hard to stop

00:26:26,930 --> 00:26:30,620
that process because someone came in

00:26:28,430 --> 00:26:35,090
with a CFS read and just wants to ping

00:26:30,620 --> 00:26:36,800
some random battery measurement and this

00:26:35,090 --> 00:26:38,540
is because there's no sort of indication

00:26:36,800 --> 00:26:39,890
of interest there's no way of saying

00:26:38,540 --> 00:26:41,540
actually now I'm going to want that in a

00:26:39,890 --> 00:26:43,670
minute could you could you add it to

00:26:41,540 --> 00:26:45,380
those channels that are going to go be

00:26:43,670 --> 00:26:47,600
captured every single time and just

00:26:45,380 --> 00:26:49,400
buffer it so I can grab it later we

00:26:47,600 --> 00:26:52,190
don't have any clean way of doing that

00:26:49,400 --> 00:26:54,070
and I'm very open to any suggestions of

00:26:52,190 --> 00:26:57,260
how we get ourselves out of that hole

00:26:54,070 --> 00:27:01,490
right now we just dodged it by not

00:26:57,260 --> 00:27:04,460
supporting it now here's another common

00:27:01,490 --> 00:27:07,010
question on Io which is high-performance

00:27:04,460 --> 00:27:08,630
devices rather helpfully is a load of

00:27:07,010 --> 00:27:09,170
analog devices guys here so if you want

00:27:08,630 --> 00:27:13,280
to ask about that

00:27:09,170 --> 00:27:16,880
that's hot over there but it brings some

00:27:13,280 --> 00:27:18,770
problems you need a different way of

00:27:16,880 --> 00:27:21,530
getting data out of the kernel you can't

00:27:18,770 --> 00:27:23,450
be running through K FIFO the overheads

00:27:21,530 --> 00:27:25,370
are way too high you've got to basically

00:27:23,450 --> 00:27:28,640
be dearme in into a buffer that's

00:27:25,370 --> 00:27:30,670
immediately visible from user space now

00:27:28,640 --> 00:27:33,170
we've had DMA buffers for quite a while

00:27:30,670 --> 00:27:34,730
but there are limitations in the

00:27:33,170 --> 00:27:37,190
interface because we've tried to bolt it

00:27:34,730 --> 00:27:39,800
in to our existing buffer infrastructure

00:27:37,190 --> 00:27:41,180
and the one classic limitation we were

00:27:39,800 --> 00:27:44,450
chatting about last night in the museum

00:27:41,180 --> 00:27:48,470
was that we don't support multiple

00:27:44,450 --> 00:27:50,890
buffers and certain devices are going to

00:27:48,470 --> 00:27:55,610
DMA different channels into different

00:27:50,890 --> 00:27:58,370
regions of memory often these devices

00:27:55,610 --> 00:27:59,990
have very complex triggering systems

00:27:58,370 --> 00:28:02,510
because you're capturing something at

00:27:59,990 --> 00:28:03,980
extremely high rates and you don't just

00:28:02,510 --> 00:28:06,200
want to capture at the same eight

00:28:03,980 --> 00:28:07,490
channels sort of one two three four five

00:28:06,200 --> 00:28:09,080
six seven eight one two three four five

00:28:07,490 --> 00:28:13,160
six seven eight you want to do something

00:28:09,080 --> 00:28:13,910
more complex you might have simultaneous

00:28:13,160 --> 00:28:16,070
sampling a certain

00:28:13,910 --> 00:28:17,600
channels and not others it gets really

00:28:16,070 --> 00:28:21,530
much more sophisticated than you

00:28:17,600 --> 00:28:24,230
typically do on a simple SPI ADC you

00:28:21,530 --> 00:28:26,180
often need inline metadata so sometimes

00:28:24,230 --> 00:28:28,790
these devices will also range very high

00:28:26,180 --> 00:28:32,240
rates and so we can't just read it for

00:28:28,790 --> 00:28:34,880
in Sisyphus they can be self describing

00:28:32,240 --> 00:28:37,300
so you will often get the device put in

00:28:34,880 --> 00:28:40,670
a little record at the beginning of a

00:28:37,300 --> 00:28:43,250
thousand samples or every 10,000 samples

00:28:40,670 --> 00:28:46,220
or something like that saying what's in

00:28:43,250 --> 00:28:48,200
those samples and we don't yet handle

00:28:46,220 --> 00:28:50,270
these in mainline so it's an open

00:28:48,200 --> 00:28:52,640
question on exactly how we can do it in

00:28:50,270 --> 00:28:57,140
a nice generic way that works for a wide

00:28:52,640 --> 00:29:01,520
range of devices so I think this is my

00:28:57,140 --> 00:29:03,980
final issue this is the the hard way we

00:29:01,520 --> 00:29:06,860
were dealing with is getting more

00:29:03,980 --> 00:29:08,330
complex perhaps everyday there were a

00:29:06,860 --> 00:29:10,610
lot of things that used to be done by

00:29:08,330 --> 00:29:13,730
proprietary microcontrollers wired up to

00:29:10,610 --> 00:29:15,050
a sensor and are now done they sort of

00:29:13,730 --> 00:29:17,390
we've got nice Linux system they will

00:29:15,050 --> 00:29:18,740
just move it on there so a classic

00:29:17,390 --> 00:29:20,540
example of this is something like a

00:29:18,740 --> 00:29:23,390
pulse oximeter now a pulse oximeter

00:29:20,540 --> 00:29:25,220
works by just shining an LED from one

00:29:23,390 --> 00:29:26,960
side of your finger and typically

00:29:25,220 --> 00:29:28,250
putting a sensor on the other side and

00:29:26,960 --> 00:29:31,100
measuring how much light gets through

00:29:28,250 --> 00:29:34,580
it's a bit more complex than that but

00:29:31,100 --> 00:29:36,410
more or less now the algorithms to

00:29:34,580 --> 00:29:40,220
actually do that conversion from a light

00:29:36,410 --> 00:29:42,710
signal through to a pole straight both

00:29:40,220 --> 00:29:44,540
rely on long-term data you have to

00:29:42,710 --> 00:29:46,900
capture a significant number of seconds

00:29:44,540 --> 00:29:49,760
worth of data typically to do it and

00:29:46,900 --> 00:29:52,070
it's all heavily proprietary there are

00:29:49,760 --> 00:29:53,600
open source implementations there are

00:29:52,070 --> 00:29:56,960
there usually things that came out of

00:29:53,600 --> 00:29:59,050
academic papers so yeah use them at your

00:29:56,960 --> 00:30:01,970
own risk

00:29:59,050 --> 00:30:03,530
but it's not something that sort of

00:30:01,970 --> 00:30:05,900
considered generic now the way we've

00:30:03,530 --> 00:30:07,370
handled this so far is that the the

00:30:05,900 --> 00:30:08,830
actual signal you're measuring is still

00:30:07,370 --> 00:30:11,600
something we can describe in a nice

00:30:08,830 --> 00:30:14,180
consistent way it's a light measurement

00:30:11,600 --> 00:30:16,250
it's often a series of light

00:30:14,180 --> 00:30:18,530
measurements and then we can move to

00:30:16,250 --> 00:30:20,210
user space to deal with actually turning

00:30:18,530 --> 00:30:24,140
those into the signal you want it's not

00:30:20,210 --> 00:30:25,700
ideal but it's where we are now I

00:30:24,140 --> 00:30:27,110
mentioned earlier the importance of

00:30:25,700 --> 00:30:29,780
community

00:30:27,110 --> 00:30:31,520
to be honest the i/o subsystem is to a

00:30:29,780 --> 00:30:34,130
great extent the community it's not

00:30:31,520 --> 00:30:36,049
really the code code is fine and well

00:30:34,130 --> 00:30:39,880
interfaces are very important the rest

00:30:36,049 --> 00:30:42,200
of the code isn't nearly as important as

00:30:39,880 --> 00:30:44,799
the feedback that everyone gives each

00:30:42,200 --> 00:30:48,200
other and the enormous amount of review

00:30:44,799 --> 00:30:49,970
things so let's go through a bit of a

00:30:48,200 --> 00:30:52,580
bit more of the history just to jump

00:30:49,970 --> 00:30:55,910
back again so how did I get into the

00:30:52,580 --> 00:30:57,530
kernel in the first place first of all

00:30:55,910 --> 00:30:59,000
we did the classic we did some posts so

00:30:57,530 --> 00:31:00,290
L came out there's nowhere else to send

00:30:59,000 --> 00:31:04,429
it because it wasn't an existing

00:31:00,290 --> 00:31:06,049
subsystem we got some feedback every few

00:31:04,429 --> 00:31:07,130
months we put a new version up everyone

00:31:06,049 --> 00:31:09,850
has forgotten what the code looked like

00:31:07,130 --> 00:31:12,530
we got the same feedback sometimes

00:31:09,850 --> 00:31:15,080
sometimes we got new feedback new people

00:31:12,530 --> 00:31:17,480
got involved wasn't great well this was

00:31:15,080 --> 00:31:22,220
just around the period when staging came

00:31:17,480 --> 00:31:24,200
about so we don't we kind of know our

00:31:22,220 --> 00:31:24,980
codes okay but we don't really know

00:31:24,200 --> 00:31:26,270
where we're going

00:31:24,980 --> 00:31:27,620
we haven't actually figured out what the

00:31:26,270 --> 00:31:30,110
right answer for the use of space

00:31:27,620 --> 00:31:33,049
interfaces and things are they've been

00:31:30,110 --> 00:31:37,910
sort of Greg and said Tom we take a

00:31:33,049 --> 00:31:42,309
subsystem through staging yeah okay so

00:31:37,910 --> 00:31:45,169
we did and actually it works pretty well

00:31:42,309 --> 00:31:47,030
like a lot of great feedback because it

00:31:45,169 --> 00:31:49,610
allowed people to sort of get around to

00:31:47,030 --> 00:31:52,100
it when they had the time their people

00:31:49,610 --> 00:31:53,480
give in whole day's worth of review

00:31:52,100 --> 00:31:55,370
comments they'd obviously spent

00:31:53,480 --> 00:31:58,040
considerable time going through that the

00:31:55,370 --> 00:31:59,960
drivers on bergman in particular did a

00:31:58,040 --> 00:32:03,470
very detailed review that changed a

00:31:59,960 --> 00:32:04,610
whole chunk of the interface and just

00:32:03,470 --> 00:32:07,669
came out in the blue because it was sat

00:32:04,610 --> 00:32:10,640
there in stage it was great off to a

00:32:07,669 --> 00:32:13,360
while we've got to the point where I use

00:32:10,640 --> 00:32:19,340
a space ABI was stable and we could

00:32:13,360 --> 00:32:21,860
finally look at moving out of station so

00:32:19,340 --> 00:32:24,110
I had fun gathering data just to show

00:32:21,860 --> 00:32:25,910
you the sort of progress over time so

00:32:24,110 --> 00:32:27,740
that on the left there we started off we

00:32:25,910 --> 00:32:30,650
had our app principle three drivers I

00:32:27,740 --> 00:32:32,570
think it was in the first bit to go into

00:32:30,650 --> 00:32:35,809
staging there were a couple war in there

00:32:32,570 --> 00:32:38,179
on the mailing list at the time around

00:32:35,809 --> 00:32:39,740
about 2.6 0.36 we started getting

00:32:38,179 --> 00:32:41,120
significant interest from other people I

00:32:39,740 --> 00:32:43,670
think I may have written

00:32:41,120 --> 00:32:46,070
the drivers up to there with a know a

00:32:43,670 --> 00:32:48,920
few contributions from others and it

00:32:46,070 --> 00:32:50,510
took us a while it took us three years

00:32:48,920 --> 00:32:52,370
before we'd actually pin down the

00:32:50,510 --> 00:32:54,770
interface enough to really consider

00:32:52,370 --> 00:32:56,600
moving out of staging and by then we had

00:32:54,770 --> 00:32:58,070
a number of companies involved with some

00:32:56,600 --> 00:33:02,060
machine drivers in the hope that we

00:32:58,070 --> 00:33:04,700
someday get our stay so we did and as

00:33:02,060 --> 00:33:07,280
you can see a load of driver's moved

00:33:04,700 --> 00:33:09,980
over from staging quite quickly I've had

00:33:07,280 --> 00:33:11,330
more new drivers turned up rather faster

00:33:09,980 --> 00:33:14,390
then we got the existing ones out of

00:33:11,330 --> 00:33:17,000
staging and there was still about 20 in

00:33:14,390 --> 00:33:18,410
staging but we've had peaks where things

00:33:17,000 --> 00:33:20,390
have got very very busy where we've had

00:33:18,410 --> 00:33:23,990
I think the biggest was twenty drivers

00:33:20,390 --> 00:33:26,120
turn up in one Colonel cycle but now

00:33:23,990 --> 00:33:29,390
typically we'll get in four five six

00:33:26,120 --> 00:33:31,130
drivers per cycle so it's a more

00:33:29,390 --> 00:33:32,750
reasonable rate and it is perhaps

00:33:31,130 --> 00:33:34,400
slowing down a bit and I think this is

00:33:32,750 --> 00:33:36,490
mostly because the hardware

00:33:34,400 --> 00:33:39,620
manufacturers have finally started

00:33:36,490 --> 00:33:42,320
standardizing their interfaces if you

00:33:39,620 --> 00:33:45,050
look at a new SD micro accelerometer for

00:33:42,320 --> 00:33:47,060
instance it's often pretty much the same

00:33:45,050 --> 00:33:48,740
interface as the previous one whereas a

00:33:47,060 --> 00:33:51,320
couple years ago it was all new device

00:33:48,740 --> 00:33:53,990
new complete interface every register

00:33:51,320 --> 00:33:55,340
changed so you couldn't share a driver

00:33:53,990 --> 00:33:58,630
so often now it's just a question of

00:33:55,340 --> 00:34:00,890
adding an ID and maybe a couple of

00:33:58,630 --> 00:34:04,160
couple of little parameters to say what

00:34:00,890 --> 00:34:07,370
the range of the device is so who wrote

00:34:04,160 --> 00:34:09,080
these drivers well wasn't me I think in

00:34:07,370 --> 00:34:10,700
the current i/o subsystem so we had two

00:34:09,080 --> 00:34:12,160
hundred and sixty something drivers I

00:34:10,700 --> 00:34:15,380
think I wrote three of them

00:34:12,160 --> 00:34:17,600
I've got hardware for a few more but not

00:34:15,380 --> 00:34:19,430
really very many they're quite a few

00:34:17,600 --> 00:34:22,070
companies involved I think we're at

00:34:19,430 --> 00:34:23,570
somewhere over 20 easily identified

00:34:22,070 --> 00:34:25,370
companies I have no idea who some of the

00:34:23,570 --> 00:34:27,890
people work for or if they're hobbyists

00:34:25,370 --> 00:34:30,050
or whatever we do have quite a lot of

00:34:27,890 --> 00:34:31,820
hobbyists I'll come on to why I think

00:34:30,050 --> 00:34:37,280
that is in a minute we have some

00:34:31,820 --> 00:34:39,050
students we also have always had Oh for

00:34:37,280 --> 00:34:41,090
a long time anyway we've had extremely

00:34:39,050 --> 00:34:44,510
good contributions from some of the

00:34:41,090 --> 00:34:47,060
outreach programs so outreach program

00:34:44,510 --> 00:34:51,890
for women then outreach why and also

00:34:47,060 --> 00:34:53,120
Google Summer of Code anyway want to

00:34:51,890 --> 00:34:55,079
know who wrote something in the kernel

00:34:53,120 --> 00:34:58,019
what do you do you fire up get the

00:34:55,079 --> 00:34:59,459
I was a bit annoyed actually I still end

00:34:58,019 --> 00:35:00,709
up at the top of both these lists but

00:34:59,459 --> 00:35:04,259
only just

00:35:00,709 --> 00:35:05,729
so it's moderately close there's some

00:35:04,259 --> 00:35:08,789
very familiar names who are sat in the

00:35:05,729 --> 00:35:10,529
audience on this list but what's

00:35:08,789 --> 00:35:12,119
actually interesting is not really who

00:35:10,529 --> 00:35:14,309
the top couple of people are to my mind

00:35:12,119 --> 00:35:16,200
it's it's it's how long those tails are

00:35:14,309 --> 00:35:17,910
so obviously it's a lot of data on this

00:35:16,200 --> 00:35:20,519
slide but if we were to pick out the

00:35:17,910 --> 00:35:23,700
source of level that means someone wrote

00:35:20,519 --> 00:35:25,200
to driver so a short driver might be

00:35:23,700 --> 00:35:27,239
less than this but if we take greater

00:35:25,200 --> 00:35:30,089
than a thousand lines of code so that

00:35:27,239 --> 00:35:33,599
means we've had 65 people contribute a

00:35:30,089 --> 00:35:35,549
driver over 260 drivers we've had 11

00:35:33,599 --> 00:35:39,479
people who realistically it can be

00:35:35,549 --> 00:35:45,900
contributed five drivers or one really

00:35:39,479 --> 00:35:47,729
really big one and yeah significant

00:35:45,900 --> 00:35:50,999
contributions are in huge numbers so

00:35:47,729 --> 00:35:54,779
overall this 512 people have contributed

00:35:50,999 --> 00:35:57,569
to IO but we do always get the ABI cross

00:35:54,779 --> 00:35:59,039
kernel changes but they're down in the

00:35:57,569 --> 00:36:03,119
small number of patches or some all

00:35:59,039 --> 00:36:04,170
numbers of lines of code so now I think

00:36:03,119 --> 00:36:06,779
it's worth saying a few things about

00:36:04,170 --> 00:36:09,199
what makes a good community and I think

00:36:06,779 --> 00:36:11,579
this first one is is very very important

00:36:09,199 --> 00:36:14,369
it also stops the maintain of burning

00:36:11,579 --> 00:36:16,410
out if you haven't got good reviewers

00:36:14,369 --> 00:36:19,109
for a sub system and people who are

00:36:16,410 --> 00:36:21,930
doing this a couple of times a week they

00:36:19,109 --> 00:36:24,449
send out replies to emails and if

00:36:21,930 --> 00:36:26,160
excellent review give mentorship often

00:36:24,449 --> 00:36:28,170
informal they'll just spend some time

00:36:26,160 --> 00:36:31,709
talking to a new contributor talking

00:36:28,170 --> 00:36:34,619
through the process doing the classics

00:36:31,709 --> 00:36:36,660
pointing out please don't talk post and

00:36:34,619 --> 00:36:40,799
all of the other elements that come with

00:36:36,660 --> 00:36:42,449
it now the key thing with this is that

00:36:40,799 --> 00:36:44,069
these reviewers and we do have I don't

00:36:42,449 --> 00:36:45,539
know a steady maybe ten people who do

00:36:44,069 --> 00:36:48,839
this now

00:36:45,539 --> 00:36:52,400
is their willingness to engage and one

00:36:48,839 --> 00:36:54,809
thing I put here is also to be persuaded

00:36:52,400 --> 00:36:56,369
often and I do this myself

00:36:54,809 --> 00:36:57,930
I'll review something I go no no you've

00:36:56,369 --> 00:37:02,670
done this all wrong as politely as

00:36:57,930 --> 00:37:03,900
possible and then three or forty miles

00:37:02,670 --> 00:37:04,739
later they go okay I don't really

00:37:03,900 --> 00:37:08,330
understand why you're saying that's

00:37:04,739 --> 00:37:09,800
wrong and then sometimes it'll turn out

00:37:08,330 --> 00:37:13,880
they were right or it's somewhere

00:37:09,800 --> 00:37:15,920
between the two so why do we get so many

00:37:13,880 --> 00:37:17,840
new contributors one is we have

00:37:15,920 --> 00:37:21,920
extremely tangible things its motion

00:37:17,840 --> 00:37:24,440
devices they're cheap that's good you

00:37:21,920 --> 00:37:26,720
can start simple to just get a Sisyphus

00:37:24,440 --> 00:37:30,320
sort of pulled interface to run it's a

00:37:26,720 --> 00:37:31,760
few tens of lines of code we have a

00:37:30,320 --> 00:37:32,930
history of new contributors this is

00:37:31,760 --> 00:37:36,410
useful because there's an awful lot of

00:37:32,930 --> 00:37:39,560
sources of information it isn't our

00:37:36,410 --> 00:37:41,270
documentation our documentation is awful

00:37:39,560 --> 00:37:43,670
so if anyone is interested in writing

00:37:41,270 --> 00:37:47,450
documentation please talk to me off to

00:37:43,670 --> 00:37:48,920
its well gets it one day besides mention

00:37:47,450 --> 00:37:52,460
here briefly the outreach programs we've

00:37:48,920 --> 00:37:54,650
had some great mentors so Daniel Tavian

00:37:52,460 --> 00:37:56,120
Allison and Greg of all mented people

00:37:54,650 --> 00:37:57,260
over the years and we've had some great

00:37:56,120 --> 00:37:58,490
students I haven't lifted them here

00:37:57,260 --> 00:38:01,970
because they're in the reference list at

00:37:58,490 --> 00:38:04,010
the end so one final slide which is how

00:38:01,970 --> 00:38:05,480
to get involved perhaps this is

00:38:04,010 --> 00:38:06,980
motivating you to do so or perhaps

00:38:05,480 --> 00:38:08,990
you've already been thinking about it

00:38:06,980 --> 00:38:11,870
first of all yet usual subscribe to the

00:38:08,990 --> 00:38:13,700
mailing list I definitely prefer people

00:38:11,870 --> 00:38:15,260
send emails there but I will quite

00:38:13,700 --> 00:38:16,700
happily reply to personal messages if

00:38:15,260 --> 00:38:19,330
you're uncomfortable with doing so

00:38:16,700 --> 00:38:22,160
certainly for the first posts and things

00:38:19,330 --> 00:38:24,890
but you can get some cheap hardware mess

00:38:22,160 --> 00:38:27,410
around with it I do occasionally send to

00:38:24,890 --> 00:38:29,120
dues other people do as well where we

00:38:27,410 --> 00:38:31,970
found something that we just not quite

00:38:29,120 --> 00:38:33,440
getting around to and it's a suitable

00:38:31,970 --> 00:38:35,720
task for someone who's just starting out

00:38:33,440 --> 00:38:37,760
if there isn't one at the moment feel

00:38:35,720 --> 00:38:39,530
free to send a message to this saying

00:38:37,760 --> 00:38:42,350
how is that I'm new is there anything I

00:38:39,530 --> 00:38:44,210
can do and yeah we'll find something

00:38:42,350 --> 00:38:47,600
we've still got a number of drivers in

00:38:44,210 --> 00:38:49,580
staging that need cleaning up so to

00:38:47,600 --> 00:38:51,620
finish off some references as I said

00:38:49,580 --> 00:38:54,380
this wasn't a tutorial some of those are

00:38:51,620 --> 00:38:57,080
some of them on some of them are fun

00:38:54,380 --> 00:38:58,130
applications I may have missed something

00:38:57,080 --> 00:38:59,930
incidentally so if anyone's looking

00:38:58,130 --> 00:39:02,450
they're thinking you miss my talk this

00:38:59,930 --> 00:39:05,240
is what Google gave me because I

00:39:02,450 --> 00:39:09,920
couldn't remember them or these talks

00:39:05,240 --> 00:39:10,970
for this week one still to come say yep

00:39:09,920 --> 00:39:14,360
there's now reach my talk which i think

00:39:10,970 --> 00:39:16,280
is tomorrow in which Georgiana who was a

00:39:14,360 --> 00:39:19,760
student earlier this year as is

00:39:16,280 --> 00:39:21,500
presenting it so do turn up to that the

00:39:19,760 --> 00:39:21,819
other two people instantly are around if

00:39:21,500 --> 00:39:23,680
you're

00:39:21,819 --> 00:39:27,400
I'm about don't you missed or you

00:39:23,680 --> 00:39:29,469
weren't going to thee it'll work job so

00:39:27,400 --> 00:39:30,670
here's very briefly is the intern blogs

00:39:29,469 --> 00:39:32,259
now these are great if you're getting

00:39:30,670 --> 00:39:33,640
started because one of the things that

00:39:32,259 --> 00:39:36,789
all of these projects encourage is

00:39:33,640 --> 00:39:38,170
people to document what they did now if

00:39:36,789 --> 00:39:39,729
I get a new bit of hardware I often

00:39:38,170 --> 00:39:41,890
check those first because it's a lot

00:39:39,729 --> 00:39:46,180
quicker I'm trying to find the setup

00:39:41,890 --> 00:39:50,009
guide for a random i2c controller and

00:39:46,180 --> 00:39:52,660
that's pretty much all I had to say so

00:39:50,009 --> 00:39:57,009
you talk really quickly you might get a

00:39:52,660 --> 00:39:59,799
question it I kind of over around any

00:39:57,009 --> 00:40:07,140
questions if not I'm around so just grab

00:39:59,799 --> 00:40:08,510
me good given we're out time anyway

00:40:07,140 --> 00:40:11,849
thank you much

00:40:08,510 --> 00:40:11,849

YouTube URL: https://www.youtube.com/watch?v=644oH1FXdtE


