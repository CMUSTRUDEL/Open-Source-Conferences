Title: The Modern Linux Graphics Stack on Embedded Systems - Michael Tretter, Pengutronix
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	The Modern Linux Graphics Stack on Embedded Systems - Michael Tretter, Pengutronix

Wayland advances to replace X as the goto windowing system in Linux, many applications and graphic toolkits are rapidly improving their Wayland support. Recent additions to the Direct Rendering Manager (DRM), e.g., atomic modeset and format modifiers, allow compositors to make smarter decisions how to utilize the hardware. This is critical for embedded systems, as these decisions affect the graphics performance and power usage. Therefore, a Wayland compositor becomes a compelling choice for building embedded systems that feature any graphical user interface.

Michael will walk through the Linux graphics stack from Kernel drivers to applications to show the components of the modern Linux graphics stack. In addition to DRM and Wayland, Michael will focus on Weston, the reference Wayland compositor. 

About Michael Tretter
Michael Tretter works as a software developer at Pengutronix. His main field of work is the Linux graphics infrastructure including Mesa, Weston, and Gstreamer.
Captions: 
	00:00:00,060 --> 00:00:06,600
good morning everyone my name is

00:00:04,170 --> 00:00:09,300
Michelle and I work for Penghu tronics

00:00:06,600 --> 00:00:12,389
at the graphic steak so I will be

00:00:09,300 --> 00:00:14,839
talking today about what the modern

00:00:12,389 --> 00:00:18,330
Linux graphics stack on embedded systems

00:00:14,839 --> 00:00:22,800
for that we will first have a look at a

00:00:18,330 --> 00:00:26,580
typical modern Linux user interface so

00:00:22,800 --> 00:00:27,119
that's a modern user interface just

00:00:26,580 --> 00:00:30,090
kidding

00:00:27,119 --> 00:00:34,620
usually modern interfaces look like this

00:00:30,090 --> 00:00:37,530
KDE the plasma window manager or gnome

00:00:34,620 --> 00:00:44,399
is all different kinds of applications

00:00:37,530 --> 00:00:47,730
and that's a typical desktop use case on

00:00:44,399 --> 00:00:51,329
the desktop you just choose some desktop

00:00:47,730 --> 00:00:53,699
environment like KDE or no install it

00:00:51,329 --> 00:00:56,969
and your graphical user interface just

00:00:53,699 --> 00:01:02,190
works I put this in quotes but it just

00:00:56,969 --> 00:01:06,270
works so what is different in embedded

00:01:02,190 --> 00:01:10,110
systems and that's what we will or I

00:01:06,270 --> 00:01:12,270
will be talking today the agenda is like

00:01:10,110 --> 00:01:14,729
follows and I will start with a look at

00:01:12,270 --> 00:01:16,920
the modern you know traffic stack then

00:01:14,729 --> 00:01:19,710
especially on graphics in embedded

00:01:16,920 --> 00:01:23,189
systems and what's so special about it

00:01:19,710 --> 00:01:27,119
and finally on Western on embedded

00:01:23,189 --> 00:01:29,329
systems on embedded graphics so let's

00:01:27,119 --> 00:01:32,130
start with the Linux graphics stack

00:01:29,329 --> 00:01:36,270
usually it starts with a windowing

00:01:32,130 --> 00:01:39,090
system you have a display server that

00:01:36,270 --> 00:01:43,770
takes care of the display and manages

00:01:39,090 --> 00:01:46,829
multiple applications windows and these

00:01:43,770 --> 00:01:53,240
applications talk to the display server

00:01:46,829 --> 00:01:57,090
using a specific protocol or protocols

00:01:53,240 --> 00:02:01,200
this has been for 30 years or even more

00:01:57,090 --> 00:02:03,259
the x11 protocol I just put the xorg

00:02:01,200 --> 00:02:06,240
here because it's the most commonly used

00:02:03,259 --> 00:02:09,569
implementation but it's the x11

00:02:06,240 --> 00:02:13,620
protocols in a more modern use case you

00:02:09,569 --> 00:02:18,739
will use valent for that and remain

00:02:13,620 --> 00:02:22,170
of the talk will be more about Weyland

00:02:18,739 --> 00:02:24,599
so it said it starts with your display

00:02:22,170 --> 00:02:27,569
server in Wayland it's called a Whelan

00:02:24,599 --> 00:02:30,900
compositor the UI of the compositor is

00:02:27,569 --> 00:02:35,159
usually called shell so we have the

00:02:30,900 --> 00:02:39,120
Welland compositor here on top of that

00:02:35,159 --> 00:02:41,790
we have multiple applications the use

00:02:39,120 --> 00:02:47,760
the protocols in Wayland a typical

00:02:41,790 --> 00:02:52,109
protocol is the xdg shell protocol which

00:02:47,760 --> 00:02:53,790
allows to create windows and has this

00:02:52,109 --> 00:02:56,730
different functionality right like

00:02:53,790 --> 00:02:59,849
resizing maximizing dragging and all

00:02:56,730 --> 00:03:04,650
these things you would expect from your

00:02:59,849 --> 00:03:08,099
desktop you can have different

00:03:04,650 --> 00:03:10,950
applications and different graphic

00:03:08,099 --> 00:03:14,760
toolkits for that for example cute I'm

00:03:10,950 --> 00:03:19,709
gtk both support of the valent protocol

00:03:14,760 --> 00:03:23,430
especially the x2 G's xtg shell protocol

00:03:19,709 --> 00:03:26,970
and chromium as well so if you are using

00:03:23,430 --> 00:03:33,389
an HTML application you can run it on

00:03:26,970 --> 00:03:35,609
chromium on Wayland we load that your

00:03:33,389 --> 00:03:40,019
compositor somehow has to use to display

00:03:35,609 --> 00:03:43,470
for that it uses Lib DRM and some DRM

00:03:40,019 --> 00:03:51,389
driver in the kernel and that drives the

00:03:43,470 --> 00:03:55,400
display so exactly here comes the DRM

00:03:51,389 --> 00:03:55,400
and especially came as in to play

00:03:55,430 --> 00:04:01,139
Wayland uses OpenGL for compositing the

00:03:58,739 --> 00:04:05,579
different applications together for that

00:04:01,139 --> 00:04:09,359
it uses Mesa and some GPU driver and

00:04:05,579 --> 00:04:13,109
actually GPU Hardware below that to make

00:04:09,359 --> 00:04:16,919
it really fast can also add animations

00:04:13,109 --> 00:04:22,590
and transparency so your windows can pop

00:04:16,919 --> 00:04:25,890
in or burn if you close them so that's

00:04:22,590 --> 00:04:27,389
more or less the graphics stack if your

00:04:25,890 --> 00:04:30,659
client uses ok

00:04:27,389 --> 00:04:35,400
as well it bypasses the I'm compositor

00:04:30,659 --> 00:04:37,650
and users Mesa directly that's something

00:04:35,400 --> 00:04:41,009
that's different in valent then it was

00:04:37,650 --> 00:04:43,469
in x11 so the output of your client

00:04:41,009 --> 00:04:46,439
belongs to the client it renders into it

00:04:43,469 --> 00:04:52,759
and passes this output to the compositor

00:04:46,439 --> 00:04:52,759
which then creates the final M frame so

00:04:54,770 --> 00:05:00,750
final overview we have the clients that

00:04:58,050 --> 00:05:04,229
render their surface the compositor

00:05:00,750 --> 00:05:06,949
composite sit together and then forward

00:05:04,229 --> 00:05:16,020
to the display driver which displays it

00:05:06,949 --> 00:05:18,960
any questions so far I hope not so now

00:05:16,020 --> 00:05:22,279
if you go to embed what is different

00:05:18,960 --> 00:05:24,810
about embedded Maxime already said some

00:05:22,279 --> 00:05:27,300
points of view so we have limited

00:05:24,810 --> 00:05:29,849
hardware resources especially we have a

00:05:27,300 --> 00:05:31,529
limited memory bandwidth and all the

00:05:29,849 --> 00:05:34,800
different hardware resources use the

00:05:31,529 --> 00:05:37,379
memory so the more research

00:05:34,800 --> 00:05:39,960
hardware resources we are using the less

00:05:37,379 --> 00:05:42,419
memory Panthers we have left so that's

00:05:39,960 --> 00:05:46,310
really the constraining factor and in

00:05:42,419 --> 00:05:46,310
many cases we have a limited power

00:05:46,490 --> 00:05:52,979
limited power so if you are battery

00:05:48,810 --> 00:05:55,680
driven and so I'm usually you have

00:05:52,979 --> 00:05:59,580
different hardware accelerators for your

00:05:55,680 --> 00:06:05,729
graphics and like GPUs video decoders

00:05:59,580 --> 00:06:09,539
and display so the GPU for 3d hardware

00:06:05,729 --> 00:06:11,789
acceleration display controllers as here

00:06:09,539 --> 00:06:14,370
you have especially different overlays M

00:06:11,789 --> 00:06:16,469
hotta overlays which can be used so you

00:06:14,370 --> 00:06:18,629
don't have to composite a new compositor

00:06:16,469 --> 00:06:21,029
but you just put your output to

00:06:18,629 --> 00:06:24,389
different overlays and it's composited

00:06:21,029 --> 00:06:26,729
in your display controller and you have

00:06:24,389 --> 00:06:36,360
these harder video encoders and decoders

00:06:26,729 --> 00:06:40,800
too to not put that much to not use your

00:06:36,360 --> 00:06:44,970
CPU for that and waste energy and

00:06:40,800 --> 00:06:47,010
if you buy an SOC usually you get an IP

00:06:44,970 --> 00:06:49,980
course from different vendors so your

00:06:47,010 --> 00:06:53,360
SOC vendor buys IP calls from different

00:06:49,980 --> 00:07:00,500
IP vendors puts them together in SOC and

00:06:53,360 --> 00:07:03,600
uses them that leads to maybe

00:07:00,500 --> 00:07:07,410
incompatible as my P course

00:07:03,600 --> 00:07:09,419
so one outputs memory that is

00:07:07,410 --> 00:07:12,270
specifically aligned which is not

00:07:09,419 --> 00:07:16,220
compatible with another IP core or uses

00:07:12,270 --> 00:07:21,810
a special tiling or a proprietary tiling

00:07:16,220 --> 00:07:24,680
and then you sometimes even have special

00:07:21,810 --> 00:07:28,440
hardware units for translating between

00:07:24,680 --> 00:07:31,979
this the tiling of one and IP core to

00:07:28,440 --> 00:07:40,919
another or between a pixel format from

00:07:31,979 --> 00:07:42,990
one IP core to another so you have all

00:07:40,919 --> 00:07:47,120
these peculiarities of the embedded

00:07:42,990 --> 00:07:50,430
hardware now if you take an application

00:07:47,120 --> 00:07:53,390
developer or designer that is used to

00:07:50,430 --> 00:07:57,690
desktop development it's he's used to

00:07:53,390 --> 00:08:05,130
just develop on the desktop see a window

00:07:57,690 --> 00:08:07,860
of the final application and he's not

00:08:05,130 --> 00:08:10,229
aware of the hardware limitations

00:08:07,860 --> 00:08:13,919
hopefully you talk to him that he should

00:08:10,229 --> 00:08:17,340
be aware but not necessarily the case

00:08:13,919 --> 00:08:19,560
so can we somehow achieve the

00:08:17,340 --> 00:08:27,120
convenience of developing an application

00:08:19,560 --> 00:08:32,370
on a desktop for embedded systems for

00:08:27,120 --> 00:08:36,870
that our graphics tech must optimally

00:08:32,370 --> 00:08:43,640
use the graphics hardware while the

00:08:36,870 --> 00:08:46,470
drivers support or provide proper

00:08:43,640 --> 00:08:49,100
abstractions of this hardware the user

00:08:46,470 --> 00:08:51,720
space uses it but your application

00:08:49,100 --> 00:08:53,670
developer does not need to care or

00:08:51,720 --> 00:08:59,070
doesn't have to care about all this

00:08:53,670 --> 00:09:01,800
of this and now I will have a look at

00:08:59,070 --> 00:09:07,500
the applications that the drivers

00:09:01,800 --> 00:09:11,370
provide for user space so there is the

00:09:07,500 --> 00:09:13,200
Linux DMAP framework the neighbors

00:09:11,370 --> 00:09:15,990
allowed to share buffers between

00:09:13,200 --> 00:09:17,820
different drivers the one driver exports

00:09:15,990 --> 00:09:21,720
the buffer another one imports it and

00:09:17,820 --> 00:09:26,130
this allows to avoid copies between the

00:09:21,720 --> 00:09:28,710
client and the compositor and this is

00:09:26,130 --> 00:09:36,150
really important to save memory

00:09:28,710 --> 00:09:40,230
bandwidth a second abstraction is the

00:09:36,150 --> 00:09:43,580
atomic mode setting if you want to use

00:09:40,230 --> 00:09:46,530
overlay planes of your hardware and you

00:09:43,580 --> 00:09:49,200
put your frame on one after the other

00:09:46,530 --> 00:09:53,670
you might get in between states where

00:09:49,200 --> 00:09:55,410
you have the old state on one plane and

00:09:53,670 --> 00:09:57,930
a new state on the other plane so you

00:09:55,410 --> 00:10:02,480
want to change all at once and that's

00:09:57,930 --> 00:10:06,540
impossible with atomic mode setting and

00:10:02,480 --> 00:10:08,790
this allows for the compositor to really

00:10:06,540 --> 00:10:11,910
make use of all the different hardware

00:10:08,790 --> 00:10:14,430
planes because it just sets up the new

00:10:11,910 --> 00:10:20,540
state and sends it to the display

00:10:14,430 --> 00:10:20,540
hardware and it's there in one instance

00:10:21,050 --> 00:10:33,000
so this video in pixel format so usually

00:10:26,430 --> 00:10:35,130
in video decoders you have y UV format

00:10:33,000 --> 00:10:36,690
which is completely different from RGB

00:10:35,130 --> 00:10:42,360
formats that are typically used by

00:10:36,690 --> 00:10:45,170
display units so if you render you

00:10:42,360 --> 00:10:47,310
usually convert these formats to

00:10:45,170 --> 00:10:51,900
something that the display understands

00:10:47,310 --> 00:10:54,600
but some display controllers might even

00:10:51,900 --> 00:10:57,180
understand why you reformats or even

00:10:54,600 --> 00:11:02,430
different custom formats like I said

00:10:57,180 --> 00:11:05,670
before IP cores understand strange

00:11:02,430 --> 00:11:08,430
formats or your hardware

00:11:05,670 --> 00:11:14,630
your hardware has some converter built

00:11:08,430 --> 00:11:17,010
in two translators so this is also

00:11:14,630 --> 00:11:20,250
provided by the driver so drivers tell

00:11:17,010 --> 00:11:22,970
you what they support and furthermore

00:11:20,250 --> 00:11:27,720
you have tiling formats which allow to

00:11:22,970 --> 00:11:31,290
save memory bandwidth by reordering the

00:11:27,720 --> 00:11:36,360
pixels of your frame and having a better

00:11:31,290 --> 00:11:40,230
i'm cache better cache accesses this is

00:11:36,360 --> 00:11:44,550
described by format modifiers and this

00:11:40,230 --> 00:11:47,340
allows to share buffers with a specific

00:11:44,550 --> 00:11:50,430
tiling between other units so if your

00:11:47,340 --> 00:11:54,300
video decoder produces some proprietary

00:11:50,430 --> 00:11:56,310
tiling format and your driver provides a

00:11:54,300 --> 00:11:59,400
modifier for that and your display

00:11:56,310 --> 00:12:01,920
controller provides a modifier for that

00:11:59,400 --> 00:12:05,400
it understands this proprietary tiling

00:12:01,920 --> 00:12:09,030
format westin might be able to just past

00:12:05,400 --> 00:12:14,340
buffer to the display unit display

00:12:09,030 --> 00:12:16,950
controller so from the driver side we

00:12:14,340 --> 00:12:19,880
have all these features but the user

00:12:16,950 --> 00:12:23,300
space actually and use these features

00:12:19,880 --> 00:12:25,560
for that we will have a look at Weston

00:12:23,300 --> 00:12:29,090
and Weston is the reference

00:12:25,560 --> 00:12:32,910
implementation of beylin compositor and

00:12:29,090 --> 00:12:35,250
as we see here in the readme it as

00:12:32,910 --> 00:12:40,430
explicitly states that it's useful for

00:12:35,250 --> 00:12:46,010
embedded industrial applications and for

00:12:40,430 --> 00:12:49,220
kiosks so that might be a useful

00:12:46,010 --> 00:12:55,530
application that we can use in our

00:12:49,220 --> 00:12:58,250
embedded system furthermore if we look

00:12:55,530 --> 00:13:03,270
interesting we see the DRM back-end

00:12:58,250 --> 00:13:07,230
which uses the Linux JMS API so it's

00:13:03,270 --> 00:13:11,310
exactly using the displays or the DRM

00:13:07,230 --> 00:13:14,580
drivers for the displays and if we look

00:13:11,310 --> 00:13:16,650
into the main page for that it's again

00:13:14,580 --> 00:13:17,820
stating that it's able to use Hardware

00:13:16,650 --> 00:13:20,190
overlays

00:13:17,820 --> 00:13:22,620
and what's very interesting is that

00:13:20,190 --> 00:13:25,890
full-screen surfaces will be sent out

00:13:22,620 --> 00:13:30,990
directly without compositing so we might

00:13:25,890 --> 00:13:33,500
even be able to save using or to avoid

00:13:30,990 --> 00:13:41,390
using the GPU for our compositing here

00:13:33,500 --> 00:13:44,610
which again saves me memory bandwidth so

00:13:41,390 --> 00:13:46,320
now I will change the pace a bit so

00:13:44,610 --> 00:13:47,250
don't be scared of the slides it will be

00:13:46,320 --> 00:13:48,720
code on it

00:13:47,250 --> 00:13:51,090
you don't have to read it you don't have

00:13:48,720 --> 00:13:54,680
to understand it if you download the

00:13:51,090 --> 00:13:57,420
slides from the webpage from the thingy

00:13:54,680 --> 00:13:59,490
you can have a look at it look for the

00:13:57,420 --> 00:14:01,860
functions and read it by yourself in the

00:13:59,490 --> 00:14:06,870
code so that's much better than trying

00:14:01,860 --> 00:14:09,600
to follow me here so first and if we

00:14:06,870 --> 00:14:11,460
prepare the planes so that's when the

00:14:09,600 --> 00:14:14,520
compositor asks the display hard

00:14:11,460 --> 00:14:18,420
controller for the supported planes we

00:14:14,520 --> 00:14:21,840
can see that it does a DRM get mode get

00:14:18,420 --> 00:14:24,690
property block and reads formats and

00:14:21,840 --> 00:14:29,030
modifiers from the blob so it's aware of

00:14:24,690 --> 00:14:29,030
what the display control is supporting

00:14:29,690 --> 00:14:35,910
second step is the rendering so we have

00:14:32,400 --> 00:14:39,120
render the rendering and separated from

00:14:35,910 --> 00:14:43,320
our flashing to the hardware and the

00:14:39,120 --> 00:14:47,720
flashing actually does a DRM atomic di

00:14:43,320 --> 00:14:52,010
mode atomic emit so Weston uses the

00:14:47,720 --> 00:14:56,000
atomic commit a API for TM so it can

00:14:52,010 --> 00:15:02,790
directly change all the planes at once

00:14:56,000 --> 00:15:05,940
then I want you you can see here at one

00:15:02,790 --> 00:15:10,290
step in the compositing at the westin

00:15:05,940 --> 00:15:13,380
assigns different plane a sign of the

00:15:10,290 --> 00:15:16,530
plane state and it tries different modes

00:15:13,380 --> 00:15:21,540
here once with planes only it then it

00:15:16,530 --> 00:15:25,260
tries to use planes and compositing in

00:15:21,540 --> 00:15:28,700
the renderer and if all fails it renders

00:15:25,260 --> 00:15:28,700
everything together and

00:15:29,530 --> 00:15:37,870
in the proposed state um you can see

00:15:34,540 --> 00:15:43,030
here that it first tries to prepare the

00:15:37,870 --> 00:15:47,020
skin out view and afterwards the overlay

00:15:43,030 --> 00:15:50,110
and if this so it tries to put a surface

00:15:47,020 --> 00:15:53,290
on the Oval on the skin out and then

00:15:50,110 --> 00:15:55,990
overlay and if this fails it just adds

00:15:53,290 --> 00:16:04,060
it to the renderer region which will be

00:15:55,990 --> 00:16:07,480
rendered together the final part is can

00:16:04,060 --> 00:16:12,040
we actually directly get the buffers

00:16:07,480 --> 00:16:14,790
from clients into our compositor or to

00:16:12,040 --> 00:16:20,680
flip it furthermore on the overlay and

00:16:14,790 --> 00:16:22,830
that is done your MFP get from View

00:16:20,680 --> 00:16:27,250
Function

00:16:22,830 --> 00:16:29,740
you can see that it tries to get one

00:16:27,250 --> 00:16:34,650
from if it gets a DMA buff it tries to

00:16:29,740 --> 00:16:37,840
get at your MFP from that and it's

00:16:34,650 --> 00:16:40,810
actually it there so all of this you can

00:16:37,840 --> 00:16:43,930
find and the lip rest and composite TR m

00:16:40,810 --> 00:16:47,500
dot C file it's pretty large so look up

00:16:43,930 --> 00:16:52,570
these functions and they will help you

00:16:47,500 --> 00:16:55,150
so as conclusion of that we have seen

00:16:52,570 --> 00:17:00,040
that the DMA of import is supported by

00:16:55,150 --> 00:17:02,430
West atomic mode set is supported we can

00:17:00,040 --> 00:17:06,400
use overlay planes because of that and

00:17:02,430 --> 00:17:09,520
we also have a format modifiers so we

00:17:06,400 --> 00:17:16,260
know that buffers have a specific tiling

00:17:09,520 --> 00:17:20,550
format what doesn't work is if we get

00:17:16,260 --> 00:17:24,520
specifically tired and client buffer and

00:17:20,550 --> 00:17:27,720
want to put it on an output plane West

00:17:24,520 --> 00:17:31,480
currently doesn't understand this and

00:17:27,720 --> 00:17:35,410
GBM API doesn't provide means to do so

00:17:31,480 --> 00:17:42,100
yet yes

00:17:35,410 --> 00:17:47,020
so that's about how Wesson uses DRM

00:17:42,100 --> 00:17:50,020
api's as a final step we will now look

00:17:47,020 --> 00:17:56,290
into how we build a user interface with

00:17:50,020 --> 00:17:59,260
Wesson so as I said before the user

00:17:56,290 --> 00:18:02,950
interface is defined by the west by a

00:17:59,260 --> 00:18:05,500
Western shell if you replace the DRM

00:18:02,950 --> 00:18:09,520
backend by the valent backend or if

00:18:05,500 --> 00:18:12,940
you're using an X based system by the X

00:18:09,520 --> 00:18:15,880
back end x11 pattern then you can

00:18:12,940 --> 00:18:18,850
develop this western shell on your

00:18:15,880 --> 00:18:22,900
desktop PC which is again a point for

00:18:18,850 --> 00:18:27,190
your user interface designer designers

00:18:22,900 --> 00:18:30,130
and to actually test it you have to run

00:18:27,190 --> 00:18:32,260
on your hardware and use the deer and

00:18:30,130 --> 00:18:34,420
back-end for that so you won't be able

00:18:32,260 --> 00:18:41,230
to test the DRM features on your desktop

00:18:34,420 --> 00:18:44,440
PC in order to write a desktop Western

00:18:41,230 --> 00:18:46,510
shell you go to the Western dot in a

00:18:44,440 --> 00:18:49,360
configuration file there you have a

00:18:46,510 --> 00:18:53,710
shell property and you can put your own

00:18:49,360 --> 00:18:59,580
shell as a string behind the string will

00:18:53,710 --> 00:19:02,190
be an executable object file which is

00:18:59,580 --> 00:19:06,910
loaded by Wesen

00:19:02,190 --> 00:19:09,280
and in this loadable object file you

00:19:06,910 --> 00:19:13,540
will implement the extra cheese shell

00:19:09,280 --> 00:19:18,250
protocol and then you use the person to

00:19:13,540 --> 00:19:24,180
actually talk to the compositor it looks

00:19:18,250 --> 00:19:28,930
like this so you have some application

00:19:24,180 --> 00:19:31,750
and the application speaks the extra

00:19:28,930 --> 00:19:35,770
cheese shell protocol with your shell

00:19:31,750 --> 00:19:38,200
and your shell then users functions

00:19:35,770 --> 00:19:40,570
defined and the westin compositor dot h

00:19:38,200 --> 00:19:45,900
to talk to the person which does then

00:19:40,570 --> 00:19:45,900
all this magic stuff with the DRM

00:19:47,120 --> 00:19:55,400
so again a bit of code the entry

00:19:51,620 --> 00:19:57,830
function to your an object is needs to

00:19:55,400 --> 00:19:59,390
be called wet shell in it so if you have

00:19:57,830 --> 00:20:01,340
this function this will be the first

00:19:59,390 --> 00:20:05,030
function that is called by best when it

00:20:01,340 --> 00:20:07,280
loads the shell and at one point you

00:20:05,030 --> 00:20:11,180
call Western compositors get you a

00:20:07,280 --> 00:20:17,620
repaint then it will repaint the current

00:20:11,180 --> 00:20:21,500
state of the so the final frame for

00:20:17,620 --> 00:20:24,710
output you need to do a lot of stuff in

00:20:21,500 --> 00:20:28,250
between so if you want some examples on

00:20:24,710 --> 00:20:29,600
how to do that you can go to the western

00:20:28,250 --> 00:20:32,330
sources there you have an example

00:20:29,600 --> 00:20:35,810
desktop shell implementation which is

00:20:32,330 --> 00:20:39,020
for a desktop use case then you have div

00:20:35,810 --> 00:20:42,830
ice shell implementation which is for an

00:20:39,020 --> 00:20:46,610
in vehicle infotainment use case and you

00:20:42,830 --> 00:20:48,410
have the full screen shell which is for

00:20:46,610 --> 00:20:53,900
a single application that runs in

00:20:48,410 --> 00:20:56,360
full-screen so wait in vehicle

00:20:53,900 --> 00:21:00,260
infotainment sounds a lot like an

00:20:56,360 --> 00:21:06,170
embedded use case so we might just use

00:21:00,260 --> 00:21:12,260
this ivi shell for for our embedded

00:21:06,170 --> 00:21:16,850
system so the ivi shell is exactly for

00:21:12,260 --> 00:21:19,490
the embedded or HMI use case this allows

00:21:16,850 --> 00:21:22,310
the composite or more control about the

00:21:19,490 --> 00:21:24,680
surfaces from clients it identifies

00:21:22,310 --> 00:21:27,860
clients by a specific idea and knows

00:21:24,680 --> 00:21:35,380
which surface belongs to which client

00:21:27,860 --> 00:21:38,270
and the problem with ivi shell is it

00:21:35,380 --> 00:21:42,140
supports the I VI application and

00:21:38,270 --> 00:21:43,580
protocol for app to be able to you

00:21:42,140 --> 00:21:48,140
specify these IDs

00:21:43,580 --> 00:21:50,960
so the xdg shell is not supported and

00:21:48,140 --> 00:21:55,550
all your common applications and all

00:21:50,960 --> 00:21:59,450
your all the traffic tickets or won't

00:21:55,550 --> 00:22:03,580
work on the IV I shall so

00:21:59,450 --> 00:22:08,900
but there is a patch set on the Weiland

00:22:03,580 --> 00:22:12,800
double mailing list for adding the xdg

00:22:08,900 --> 00:22:17,290
shell protocol to the IV I shall so if

00:22:12,800 --> 00:22:22,070
you use this patch set you can just run

00:22:17,290 --> 00:22:23,000
normal epic normal applications on the

00:22:22,070 --> 00:22:25,880
IVIG shell

00:22:23,000 --> 00:22:29,720
so that makes IV I shall again

00:22:25,880 --> 00:22:32,390
interesting for an embedded use case so

00:22:29,720 --> 00:22:38,660
we have a look at the IV I shall to know

00:22:32,390 --> 00:22:44,470
what we have to do we have some IV i

00:22:38,660 --> 00:22:47,270
iii-vi shell implementation which

00:22:44,470 --> 00:22:51,320
implements this the shell protocol

00:22:47,270 --> 00:22:54,670
so the IV I application protocol or the

00:22:51,320 --> 00:22:58,400
XD shell protocols are implemented here

00:22:54,670 --> 00:23:01,280
this again uses the IV I layout library

00:22:58,400 --> 00:23:02,780
which takes care of all the surfaces and

00:23:01,280 --> 00:23:07,460
different layers that allow you to

00:23:02,780 --> 00:23:10,900
manage your client applications and this

00:23:07,460 --> 00:23:16,040
library talk to your compositor back-end

00:23:10,900 --> 00:23:19,310
in order to create user interface with

00:23:16,040 --> 00:23:24,760
that your addition you have this HMI

00:23:19,310 --> 00:23:24,760
controller this is responsible for

00:23:25,420 --> 00:23:31,250
positioning your surfaces

00:23:27,770 --> 00:23:33,980
how they relate to each other and on top

00:23:31,250 --> 00:23:37,070
of that you can have user interface that

00:23:33,980 --> 00:23:39,350
looks like this for example so this is

00:23:37,070 --> 00:23:43,640
the example user interface that comes

00:23:39,350 --> 00:23:47,330
with Weston no idea action so in order

00:23:43,640 --> 00:23:52,100
to have our own user interface we just

00:23:47,330 --> 00:23:55,550
cut here and replace the HMI controller

00:23:52,100 --> 00:24:02,840
and this user interface and reuse this

00:23:55,550 --> 00:24:09,590
ibi layout library this library

00:24:02,840 --> 00:24:12,640
export API called the ibi layout so in

00:24:09,590 --> 00:24:16,490
your H my controller you

00:24:12,640 --> 00:24:19,790
cause I VI lae out get API you will get

00:24:16,490 --> 00:24:21,320
an IV I layout interface and in this

00:24:19,790 --> 00:24:24,620
interface you are able to create

00:24:21,320 --> 00:24:27,560
surfaces position these surfaces and add

00:24:24,620 --> 00:24:30,080
two surfaces to various layers and do

00:24:27,560 --> 00:24:33,500
your user interface implementation

00:24:30,080 --> 00:24:36,050
once your configured your interface you

00:24:33,500 --> 00:24:38,870
do a commit changes which will then

00:24:36,050 --> 00:24:46,450
trigger the repaint and update your

00:24:38,870 --> 00:24:49,390
frames that's basically how you

00:24:46,450 --> 00:24:53,210
implement an HMI controller for the

00:24:49,390 --> 00:24:57,500
ideation so are there any alternatives

00:24:53,210 --> 00:25:01,130
to Weston yes they are there are the WL

00:24:57,500 --> 00:25:03,890
routes project and the cute Whelan

00:25:01,130 --> 00:25:06,500
compositor which are the most prominent

00:25:03,890 --> 00:25:13,970
from my point of view first a look at

00:25:06,500 --> 00:25:21,290
the WLWT so it's a modular valent

00:25:13,970 --> 00:25:27,080
compositor library again it has an

00:25:21,290 --> 00:25:30,890
interesting protocol which is the wlr

00:25:27,080 --> 00:25:36,340
layer shell unstable v1 protocol which

00:25:30,890 --> 00:25:40,940
allows clients to specify anchors and

00:25:36,340 --> 00:25:44,600
positions in on the final composited

00:25:40,940 --> 00:25:47,990
frame so this might be also interesting

00:25:44,600 --> 00:25:50,840
for writing such a user interface for an

00:25:47,990 --> 00:25:55,970
embedded system and it's currently used

00:25:50,840 --> 00:25:59,870
by a sway by the wash for the libram 5

00:25:55,970 --> 00:26:02,930
and Putin which is the example I'm

00:25:59,870 --> 00:26:08,030
compositor for that and several more

00:26:02,930 --> 00:26:11,000
that I'm not aware of and problem with

00:26:08,030 --> 00:26:14,870
WL routes is it does not support overlay

00:26:11,000 --> 00:26:18,050
planes yet and it does not support the

00:26:14,870 --> 00:26:20,120
format modifiers so it is interesting

00:26:18,050 --> 00:26:23,510
from the application developer point of

00:26:20,120 --> 00:26:25,380
view but it's not yet suited for using

00:26:23,510 --> 00:26:29,320
it in an embedded system

00:26:25,380 --> 00:26:32,860
and then there is the cute Valen

00:26:29,320 --> 00:26:35,170
compositor it's a cute module for

00:26:32,860 --> 00:26:39,460
developing display server so exactly

00:26:35,170 --> 00:26:42,490
what we need it provides a qml interface

00:26:39,460 --> 00:26:47,650
which makes it really simple to write a

00:26:42,490 --> 00:26:50,140
compositor and someone who writes

00:26:47,650 --> 00:26:53,140
applications are ready in qml with

00:26:50,140 --> 00:26:58,090
writing a compositor with qml is really

00:26:53,140 --> 00:27:00,940
easy and therefore as it uses qml it's a

00:26:58,090 --> 00:27:04,420
pretty well tested decorate from

00:27:00,940 --> 00:27:06,490
technology there the problem is acute

00:27:04,420 --> 00:27:10,180
Wayland compositor is it does not use

00:27:06,490 --> 00:27:13,750
atomic mode cert and therefore it cannot

00:27:10,180 --> 00:27:16,390
use overlay planes and it cannot use the

00:27:13,750 --> 00:27:20,020
format modifiers and it's also difficult

00:27:16,390 --> 00:27:26,680
to or it's not that performant to use it

00:27:20,020 --> 00:27:32,130
in an embedded news case so there come

00:27:26,680 --> 00:27:35,650
my open questions that I still not sure

00:27:32,130 --> 00:27:35,800
how if there is a net proper answer for

00:27:35,650 --> 00:27:39,280
that

00:27:35,800 --> 00:27:41,860
so first is it really useful to have a

00:27:39,280 --> 00:27:44,080
desktop environment for the UI

00:27:41,860 --> 00:27:46,720
developers of the embedded systems or

00:27:44,080 --> 00:27:49,330
does it maybe hurt more if we make it

00:27:46,720 --> 00:27:51,130
development easy on a desktop and then

00:27:49,330 --> 00:27:56,170
switch to an embedded system and

00:27:51,130 --> 00:27:59,110
everything falls apart therefore should

00:27:56,170 --> 00:28:02,050
and furthermore should the compositor

00:27:59,110 --> 00:28:04,200
really hide the hardware complexity so

00:28:02,050 --> 00:28:07,060
if everything happens magically

00:28:04,200 --> 00:28:10,210
generically over several systems in the

00:28:07,060 --> 00:28:17,080
compositor developer does not have that

00:28:10,210 --> 00:28:19,840
much control or the developer might know

00:28:17,080 --> 00:28:22,750
that something uses less bandwidth does

00:28:19,840 --> 00:28:24,190
it if it does it differently so is it

00:28:22,750 --> 00:28:26,170
really good to have everything in the

00:28:24,190 --> 00:28:31,330
compositor or do we want to have more

00:28:26,170 --> 00:28:36,790
control from applications furthermore in

00:28:31,330 --> 00:28:39,190
or in the compositor who decides what

00:28:36,790 --> 00:28:42,580
shall be rendered what shall be put on

00:28:39,190 --> 00:28:44,440
the overlay planes is it more efficient

00:28:42,580 --> 00:28:45,970
to render everything together is it more

00:28:44,440 --> 00:28:50,160
efficient to have one single application

00:28:45,970 --> 00:28:53,350
on an overlay I don't know and I'm not

00:28:50,160 --> 00:28:59,650
sure if it can be decided for all use

00:28:53,350 --> 00:29:03,280
cases and should we provide means for

00:28:59,650 --> 00:29:06,460
clients or client applications to decide

00:29:03,280 --> 00:29:08,530
their position or should the compositor

00:29:06,460 --> 00:29:12,760
decide for all clients where they should

00:29:08,530 --> 00:29:16,990
be put so if we have like a notification

00:29:12,760 --> 00:29:19,360
and shut the application that shows the

00:29:16,990 --> 00:29:22,270
notification decide where to put it or

00:29:19,360 --> 00:29:29,470
is it the compositor who decides I'm

00:29:22,270 --> 00:29:33,370
also not sure about that so with that I

00:29:29,470 --> 00:29:34,830
come to the summary first I looked at

00:29:33,370 --> 00:29:41,220
the Linux graphics stack including

00:29:34,830 --> 00:29:44,050
Wayland on top Mesa and PRM for 3d

00:29:41,220 --> 00:29:46,540
acceleration and for interfacing with

00:29:44,050 --> 00:29:48,970
display controllers then I especially

00:29:46,540 --> 00:29:52,960
looked at the abstraction does that DRM

00:29:48,970 --> 00:29:55,090
provides for the peculiarities of the

00:29:52,960 --> 00:29:59,320
embedded hardware and how to how it can

00:29:55,090 --> 00:30:01,690
be efficiently used then how Weston uses

00:29:59,320 --> 00:30:04,270
this erm features and where you can find

00:30:01,690 --> 00:30:06,610
it in the western' code and finally how

00:30:04,270 --> 00:30:10,540
to build an embedded UI with Weston

00:30:06,610 --> 00:30:15,130
using so building your own shell or

00:30:10,540 --> 00:30:18,400
using the IDI shell for that so with

00:30:15,130 --> 00:30:23,560
that if you have any questions remarks

00:30:18,400 --> 00:30:26,980
opinions answers then talk to me

00:30:23,560 --> 00:30:29,920
tomorrow at the penguin expose write me

00:30:26,980 --> 00:30:32,860
an email or just find me at a conference

00:30:29,920 --> 00:30:35,710
and talk to me I will be happy to talk

00:30:32,860 --> 00:30:39,750
about these things so thank you for your

00:30:35,710 --> 00:30:39,750
attention and thanks

00:30:45,350 --> 00:30:52,430
any questions or answers now and there

00:30:49,050 --> 00:30:52,430
are microphones on the side

00:30:57,220 --> 00:31:04,810
I there any backwards compatibility

00:31:01,090 --> 00:31:07,990
between different shell versions because

00:31:04,810 --> 00:31:12,420
you are presenting sleight of creating a

00:31:07,990 --> 00:31:15,720
new shell for Western and it has a

00:31:12,420 --> 00:31:27,400
variable name it was a nom named like

00:31:15,720 --> 00:31:30,430
version six unstable something so I'm

00:31:27,400 --> 00:31:33,100
not sure I don't think so but I'm not

00:31:30,430 --> 00:31:36,310
really sure so for the extra cheese

00:31:33,100 --> 00:31:39,610
shell it's finally stable so that's a

00:31:36,310 --> 00:31:41,950
stable protocol I use the unstable one

00:31:39,610 --> 00:31:47,830
and because it's from the examples I

00:31:41,950 --> 00:31:48,520
copied and cut together I don't know

00:31:47,830 --> 00:31:52,090
actually

00:31:48,520 --> 00:31:54,640
okay for example if I have latest

00:31:52,090 --> 00:31:58,480
Western and I use an application which

00:31:54,640 --> 00:32:11,100
uses like shell protocol version to go

00:31:58,480 --> 00:32:11,100
it work I have to try sir okay thank you

00:32:16,660 --> 00:32:25,890
okay don't see any further questions

00:32:20,170 --> 00:32:25,890

YouTube URL: https://www.youtube.com/watch?v=k9mobviOpFQ


