Title: Strategies for Developing and Deploying your Embedded Applications and Images - Mirza Krak
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Strategies for Developing and Deploying your Embedded Applications and Images - Mirza Krak, Mender.io

We will delve into multiple strategies you can use for developing and deploying code to embedded devices. We will compare and contrast the following:

Lightweight package managers: ipkg/opkg
Desktop package managers: rpm/deb
Configuration Management Tools
Smart Package Manager
Yocto Runtime Package Management
PXE boot
OTA updaters: Mender


As with any decision, it is rarely black-and-white and we will cover some of the benefits and the limitations of all the different methods mentioned, to make sure you have the most critical information needed to decide for yourself whether a given strategy would be a good fit for your embedded application development.

This talk will cover how different mechanisms are implemented in the real world and how choosing the right strategy, understanding its benefits and drawbacks, can speed up and improve the whole development process. 

About Mirza Krak
Mirza Krak is currently part of the Mender.io open source project to deploy OTA software updates to embedded Linux devices.
Mirza Krak is an embedded Linux solution specialist with seven years of experience in the field. He is involved in various other open-source projects and is a Linux kernel contributor.

Mirza's expertise is within Board Support Package development which ranges from hardware bringup, bootloaders, Linux kernel and build systems (Yocto/OE-core).

Mirza has previosuly spoken at Embedded Linux Conference.
Captions: 
	00:00:01,820 --> 00:00:09,750
okay I think we can get started we are

00:00:06,480 --> 00:00:11,610
about on time thanks you thank you for

00:00:09,750 --> 00:00:13,830
joining my session I'm the guy that

00:00:11,610 --> 00:00:15,900
stands between you and lunch so I would

00:00:13,830 --> 00:00:19,890
try to get through this quickly so we

00:00:15,900 --> 00:00:21,660
can all go any and today I'm going to be

00:00:19,890 --> 00:00:23,279
talking about strategies for deploying

00:00:21,660 --> 00:00:27,570
developing and deploying embedded

00:00:23,279 --> 00:00:29,160
applications and images and for you that

00:00:27,570 --> 00:00:31,890
attended the previous talk in this room

00:00:29,160 --> 00:00:34,290
from my colleague drew there is some

00:00:31,890 --> 00:00:37,410
overlap or I'm going to go into some

00:00:34,290 --> 00:00:42,780
details of some of the features that he

00:00:37,410 --> 00:00:48,420
mentioned so the scope what we're

00:00:42,780 --> 00:00:52,230
talking about today is this loop while

00:00:48,420 --> 00:00:54,379
you are developing applications or when

00:00:52,230 --> 00:00:57,420
you're developing your a better system

00:00:54,379 --> 00:00:59,190
where you build some kind of software

00:00:57,420 --> 00:01:02,760
you need to deploy it to your device you

00:00:59,190 --> 00:01:05,460
need to test it and what we're trying to

00:01:02,760 --> 00:01:08,040
do here in my my session is to take a

00:01:05,460 --> 00:01:11,280
look at a few of the tools that are

00:01:08,040 --> 00:01:13,439
available to us it's also telling a bit

00:01:11,280 --> 00:01:16,650
the story that I've been through

00:01:13,439 --> 00:01:18,869
throughout my career in embedded in a

00:01:16,650 --> 00:01:22,290
Linux the tools I've used and what I use

00:01:18,869 --> 00:01:27,240
today as my primary tools when

00:01:22,290 --> 00:01:29,570
developing systems and applications so

00:01:27,240 --> 00:01:32,840
quick cover you more detailed overview

00:01:29,570 --> 00:01:35,400
we try to take a look at by a bit that

00:01:32,840 --> 00:01:37,290
desktop environment and how that works

00:01:35,400 --> 00:01:41,790
when you when you work when you develop

00:01:37,290 --> 00:01:44,490
applications and Linux systems I will

00:01:41,790 --> 00:01:47,610
take a look at the embedded environment

00:01:44,490 --> 00:01:50,540
that's available to us as well and I

00:01:47,610 --> 00:01:53,009
will try to take a look a bit

00:01:50,540 --> 00:01:55,969
development workflow was using package

00:01:53,009 --> 00:01:58,579
management managers but also using a

00:01:55,969 --> 00:02:02,119
Yocto who a core

00:01:58,579 --> 00:02:04,670
package management system I'm getting to

00:02:02,119 --> 00:02:09,379
that a bit later we also take a look at

00:02:04,670 --> 00:02:11,660
the network booting and using a software

00:02:09,379 --> 00:02:15,530
update solution as a development tool as

00:02:11,660 --> 00:02:18,470
well so a little bit about me

00:02:15,530 --> 00:02:20,750
my name is Marissa I've been working

00:02:18,470 --> 00:02:25,069
with embedded Linux in the last seven

00:02:20,750 --> 00:02:28,129
years started out more at hardware side

00:02:25,069 --> 00:02:30,379
like hardware development also doing

00:02:28,129 --> 00:02:33,290
low-level stuff like you boot and Linux

00:02:30,379 --> 00:02:37,040
kernel development and last two or three

00:02:33,290 --> 00:02:40,519
years it's mostly been Yocto and build

00:02:37,040 --> 00:02:44,000
root build systems creating custom

00:02:40,519 --> 00:02:46,400
distributions and stuff like that and I

00:02:44,000 --> 00:02:50,690
am working with Aaron Burr Empire

00:02:46,400 --> 00:02:52,310
Solutions Architect at Nolan Tech and I

00:02:50,690 --> 00:02:54,890
also worked with a member the tile

00:02:52,310 --> 00:02:57,440
project which is an over-the-air update

00:02:54,890 --> 00:02:59,329
or embedded Linux we also have a booth

00:02:57,440 --> 00:03:04,100
upstairs so if you have any questions

00:02:59,329 --> 00:03:07,840
about that you're welcome to join us so

00:03:04,100 --> 00:03:10,790
let's start with the desktop environment

00:03:07,840 --> 00:03:14,780
so develop developing applications on

00:03:10,790 --> 00:03:17,750
our own desktop or laptop system where

00:03:14,780 --> 00:03:20,690
you have Ubuntu generally everything is

00:03:17,750 --> 00:03:22,630
available to you to opt get installed if

00:03:20,690 --> 00:03:26,060
you're missing some dependency library

00:03:22,630 --> 00:03:30,290
or you need to development tools like C

00:03:26,060 --> 00:03:31,940
make or make or it's all available to

00:03:30,290 --> 00:03:33,650
you pretty easily it's just up to get

00:03:31,940 --> 00:03:35,959
install and you're good to go

00:03:33,650 --> 00:03:39,609
you also have a high level availability

00:03:35,959 --> 00:03:44,690
of trace tools and debug tools like a GB

00:03:39,609 --> 00:03:47,840
gdb astrays or other things so you have

00:03:44,690 --> 00:03:50,660
a lot more control over your when you're

00:03:47,840 --> 00:03:53,780
running your binary for example you can

00:03:50,660 --> 00:03:55,069
easily debug it sis your your building

00:03:53,780 --> 00:03:58,579
and running and testing on the same

00:03:55,069 --> 00:04:01,489
machine so and you generally when you

00:03:58,579 --> 00:04:04,819
are able to do this you have very short

00:04:01,489 --> 00:04:10,519
cycles of making code changes building

00:04:04,819 --> 00:04:12,260
to testing and generally I mean I would

00:04:10,519 --> 00:04:14,360
probably try to keep the

00:04:12,260 --> 00:04:19,070
meant as much as possible on a desktop

00:04:14,360 --> 00:04:22,100
or on a PC and even go to some extent to

00:04:19,070 --> 00:04:24,940
mock certain hardware features to be

00:04:22,100 --> 00:04:27,949
able to do some basic sanity testing on

00:04:24,940 --> 00:04:30,410
the desktop environment just because you

00:04:27,949 --> 00:04:34,850
get these short cycles of changing code

00:04:30,410 --> 00:04:38,330
building and deploying sort of thing but

00:04:34,850 --> 00:04:40,039
also be aware that's like it's mostly

00:04:38,330 --> 00:04:43,010
basic testing because you are not

00:04:40,039 --> 00:04:46,760
testing on your dedicated hardware where

00:04:43,010 --> 00:04:50,840
this will run eventually and you also

00:04:46,760 --> 00:04:53,360
have maybe have some constraints that if

00:04:50,840 --> 00:04:56,360
if you're embedded device is less

00:04:53,360 --> 00:05:00,770
powerful that also has an effect on your

00:04:56,360 --> 00:05:02,330
binaries and stuff like that so you can

00:05:00,770 --> 00:05:05,270
go to there like it when you go to the

00:05:02,330 --> 00:05:08,139
desk and budgets into your better system

00:05:05,270 --> 00:05:12,220
you can probably reproduce most of the

00:05:08,139 --> 00:05:15,650
the applications you have access to like

00:05:12,220 --> 00:05:17,240
ambien Ubuntu or raspbian if you're

00:05:15,650 --> 00:05:19,280
running in better devices which are

00:05:17,240 --> 00:05:21,800
similar to a desktop environment that

00:05:19,280 --> 00:05:23,419
you have on your laptop so you can

00:05:21,800 --> 00:05:28,400
install development tools on that as

00:05:23,419 --> 00:05:30,440
well and make see making it and you can

00:05:28,400 --> 00:05:32,560
use that as a development workstation

00:05:30,440 --> 00:05:34,910
but you shouldn't really because

00:05:32,560 --> 00:05:39,590
generally it's very slow it's not like

00:05:34,910 --> 00:05:42,410
compile times are terrible and it you

00:05:39,590 --> 00:05:46,840
cannot really set up this exact same

00:05:42,410 --> 00:05:49,940
environment that you have on your PC so

00:05:46,840 --> 00:05:53,150
it's not really by about viable in the

00:05:49,940 --> 00:05:56,199
long run so what we need to do start

00:05:53,150 --> 00:05:58,789
doing is cross device development right

00:05:56,199 --> 00:06:01,940
we cannot really use our embedded

00:05:58,789 --> 00:06:03,560
devices as development stations so we

00:06:01,940 --> 00:06:06,110
need to use our laptops or desktops

00:06:03,560 --> 00:06:07,930
which are much faster but that is then

00:06:06,110 --> 00:06:10,940
we need to start cross compiling an

00:06:07,930 --> 00:06:14,240
application and that's when it starts to

00:06:10,940 --> 00:06:16,840
get a bit complicated but this is them

00:06:14,240 --> 00:06:19,629
accepted approach nowadays and this is

00:06:16,840 --> 00:06:22,059
how generally

00:06:19,629 --> 00:06:24,449
most people do it using Yocto or build

00:06:22,059 --> 00:06:26,589
route or other build systems to

00:06:24,449 --> 00:06:28,869
cross-compile on a more powerful machine

00:06:26,589 --> 00:06:31,119
and then transfer it to the device only

00:06:28,869 --> 00:06:33,249
the binary system but it also introduces

00:06:31,119 --> 00:06:34,869
complexity because now you have you

00:06:33,249 --> 00:06:36,610
compile the code in one place and now

00:06:34,869 --> 00:06:38,619
you need to transfer it to one device or

00:06:36,610 --> 00:06:40,659
transfer it to multiple devices and then

00:06:38,619 --> 00:06:44,860
you need to run testing and this is

00:06:40,659 --> 00:06:46,899
where it gets a bit messy so like the

00:06:44,860 --> 00:06:48,639
initial approach or the entry point that

00:06:46,899 --> 00:06:51,249
most people have experienced in this

00:06:48,639 --> 00:06:54,399
room probably you need to transfer files

00:06:51,249 --> 00:06:56,649
between your laptop or desktop and your

00:06:54,399 --> 00:07:01,330
device so you can easily do that with

00:06:56,649 --> 00:07:05,110
secure copy for example SSH or take a

00:07:01,330 --> 00:07:06,639
USB stick transfer it but this is like

00:07:05,110 --> 00:07:09,939
the this is the entry point and it's

00:07:06,639 --> 00:07:12,399
surprisingly how many people are they

00:07:09,939 --> 00:07:18,039
stopped here this is how they develop

00:07:12,399 --> 00:07:19,599
applications for a better devices but it

00:07:18,039 --> 00:07:22,240
is of course our prone and this is not

00:07:19,599 --> 00:07:24,189
something that you you it's a lot of

00:07:22,240 --> 00:07:28,149
manual work and there's people still

00:07:24,189 --> 00:07:32,319
trying to automate this as well but it's

00:07:28,149 --> 00:07:34,689
not really recommended so then you if

00:07:32,319 --> 00:07:36,009
you have if you're using ID integrated

00:07:34,689 --> 00:07:40,389
development environments they usually

00:07:36,009 --> 00:07:43,269
have some kind of plugins or to be able

00:07:40,389 --> 00:07:45,369
to cross compile and usually you shall

00:07:43,269 --> 00:07:47,189
have some kind of post build hooks which

00:07:45,369 --> 00:07:51,269
will transfer your binary to the device

00:07:47,189 --> 00:07:54,610
and run it so you can from the IDE

00:07:51,269 --> 00:07:56,769
run your binary on the device for

00:07:54,610 --> 00:08:00,459
example in the if you're using QT

00:07:56,769 --> 00:08:03,639
creator you can launch the debug server

00:08:00,459 --> 00:08:08,259
on the device and also connect and do

00:08:03,639 --> 00:08:12,550
debugging remotely but people do know

00:08:08,259 --> 00:08:17,529
it's not very common to use I don't use

00:08:12,550 --> 00:08:20,680
the IDs that much it at least so the

00:08:17,529 --> 00:08:22,539
next step would be okay we have package

00:08:20,680 --> 00:08:25,169
managers that's pretty familiar to all

00:08:22,539 --> 00:08:30,430
of us and that's how we install

00:08:25,169 --> 00:08:32,040
applications on our laptops so and with

00:08:30,430 --> 00:08:34,440
that you get

00:08:32,040 --> 00:08:37,729
some kind of more sanity checks more

00:08:34,440 --> 00:08:40,140
controls you can state dependencies that

00:08:37,729 --> 00:08:42,990
the binary that you are installing and

00:08:40,140 --> 00:08:45,810
his dependence has dependencies on this

00:08:42,990 --> 00:08:48,300
version of this library to get more more

00:08:45,810 --> 00:08:51,440
sanity checks to a wire avoid

00:08:48,300 --> 00:08:54,540
error-prone manual transfer of devices

00:08:51,440 --> 00:09:00,960
and generally there is three popular

00:08:54,540 --> 00:09:01,770
package managers you have the Debian one

00:09:00,960 --> 00:09:10,470
and Fedora

00:09:01,770 --> 00:09:13,080
and open opkg so the step bought what

00:09:10,470 --> 00:09:15,270
you would do trying to utilize that

00:09:13,080 --> 00:09:17,940
you'll probably the step in your build

00:09:15,270 --> 00:09:21,300
system when you're compiling your

00:09:17,940 --> 00:09:24,630
application if you using make let's say

00:09:21,300 --> 00:09:26,550
make Debian package right so it packages

00:09:24,630 --> 00:09:29,220
your binary and if your application has

00:09:26,550 --> 00:09:32,430
some extra configuration files along

00:09:29,220 --> 00:09:34,380
with it and packages in a depth file

00:09:32,430 --> 00:09:38,790
that you can transfer to your device and

00:09:34,380 --> 00:09:42,570
install and this again gives you more

00:09:38,790 --> 00:09:47,420
dependency tracking sanity checks and it

00:09:42,570 --> 00:09:51,030
gets a bit less error-prone we can also

00:09:47,420 --> 00:09:55,260
provide custom package feeds where you

00:09:51,030 --> 00:09:57,960
can upload your your debian package that

00:09:55,260 --> 00:10:02,250
you create for your application and make

00:09:57,960 --> 00:10:05,600
it easily available to your devices and

00:10:02,250 --> 00:10:08,430
package managers are useful usually

00:10:05,600 --> 00:10:10,500
during development or prototyping when

00:10:08,430 --> 00:10:13,650
you're working with a better device and

00:10:10,500 --> 00:10:16,350
you you trying to debug something you

00:10:13,650 --> 00:10:18,870
notice how I'm using a tool like guess

00:10:16,350 --> 00:10:21,180
trace or TCP dump power iperf or

00:10:18,870 --> 00:10:22,620
whatever and then you just run apt-get

00:10:21,180 --> 00:10:25,290
install and they can continue on

00:10:22,620 --> 00:10:27,480
debugging whatever problem you're doing

00:10:25,290 --> 00:10:27,690
right now but this is not always the

00:10:27,480 --> 00:10:29,910
case

00:10:27,690 --> 00:10:31,200
you don't tell package managers on all

00:10:29,910 --> 00:10:33,690
them and buy the devices this is

00:10:31,200 --> 00:10:36,000
generally if you're using a debian or

00:10:33,690 --> 00:10:38,580
Ubuntu or raspbian something like that

00:10:36,000 --> 00:10:43,510
in your embedded system but if you don't

00:10:38,580 --> 00:10:46,810
have that this

00:10:43,510 --> 00:10:51,720
person descriptor and I'm gonna focus a

00:10:46,810 --> 00:10:56,740
bit more on dr. project and work or and

00:10:51,720 --> 00:10:58,690
how to utilize create package feeds in

00:10:56,740 --> 00:11:01,450
this environment similar to what you

00:10:58,690 --> 00:11:03,820
would have in a debian styles this

00:11:01,450 --> 00:11:07,000
systems so there's something called the

00:11:03,820 --> 00:11:10,150
on some distribution which is which

00:11:07,000 --> 00:11:13,780
maintains package feeds they have a meta

00:11:10,150 --> 00:11:15,700
unstrung layer and it seems that it's I

00:11:13,780 --> 00:11:18,130
haven't used it in a while but it I

00:11:15,700 --> 00:11:20,170
checked it updates it stills it seems

00:11:18,130 --> 00:11:25,180
that it's still maintained and they have

00:11:20,170 --> 00:11:27,550
a sumo branch from this year so this is

00:11:25,180 --> 00:11:30,910
what you typically would do is include

00:11:27,550 --> 00:11:32,800
meta angstrom in your doctor builds and

00:11:30,910 --> 00:11:35,890
set your distribution wrong strong and

00:11:32,800 --> 00:11:38,650
then you get package feeds that the

00:11:35,890 --> 00:11:43,030
angstrom distribution maintains so this

00:11:38,650 --> 00:11:45,400
is this is also helpful while doing

00:11:43,030 --> 00:11:48,420
prototyping or early development of your

00:11:45,400 --> 00:11:55,000
own by the platform if you're using that

00:11:48,420 --> 00:11:56,920
but but also angstrom is a lot more than

00:11:55,000 --> 00:12:00,210
package feeds so you don't maybe you

00:11:56,920 --> 00:12:02,800
don't want to use it for other reasons

00:12:00,210 --> 00:12:04,750
the package feeds are nice but maybe in

00:12:02,800 --> 00:12:09,130
the long run you're trying to create a

00:12:04,750 --> 00:12:12,160
more customized based on pokey or

00:12:09,130 --> 00:12:16,690
something like that and then there's a

00:12:12,160 --> 00:12:19,210
way to create this as well using your

00:12:16,690 --> 00:12:20,790
tool where core this is how mainstream

00:12:19,210 --> 00:12:26,110
does it as well

00:12:20,790 --> 00:12:28,390
so Yocto generates package feeds for you

00:12:26,110 --> 00:12:32,410
basically when you do a build image

00:12:28,390 --> 00:12:38,080
build you will get one of the output

00:12:32,410 --> 00:12:42,160
directories is packages so you can

00:12:38,080 --> 00:12:45,160
choose between or p.m. Deb and ipk and

00:12:42,160 --> 00:12:48,790
it's stored under the attempt deploy ipk

00:12:45,160 --> 00:12:51,360
so that's just the packages and it's

00:12:48,790 --> 00:12:53,650
you're not yet a complete package feed

00:12:51,360 --> 00:12:55,480
so what you normally would need to do is

00:12:53,650 --> 00:12:57,860
there's a command that's a bit big

00:12:55,480 --> 00:13:01,100
package index that January

00:12:57,860 --> 00:13:03,050
the files that the package management

00:13:01,100 --> 00:13:10,010
that package manager that you're running

00:13:03,050 --> 00:13:12,709
on device needs so after you have run

00:13:10,010 --> 00:13:16,100
the package index command you can simply

00:13:12,709 --> 00:13:18,910
expose the deploy folder where all your

00:13:16,100 --> 00:13:22,010
packages are on a simple HTTP server

00:13:18,910 --> 00:13:28,130
which makes it accessible on the local

00:13:22,010 --> 00:13:31,100
network for your device but this only

00:13:28,130 --> 00:13:34,519
fixes the like the server-side package

00:13:31,100 --> 00:13:37,519
feed in this case so what you need you

00:13:34,519 --> 00:13:40,070
also need the tools on your embedded

00:13:37,519 --> 00:13:42,529
device so there's a extra image feature

00:13:40,070 --> 00:13:47,180
that you can set that package management

00:13:42,529 --> 00:13:50,930
that will install if you're using epyck

00:13:47,180 --> 00:13:53,209
yeah if you whatever package manager you

00:13:50,930 --> 00:13:56,680
choose it will install the device

00:13:53,209 --> 00:14:01,339
specific tools needed to fetch packages

00:13:56,680 --> 00:14:03,949
there's also a template file or alright

00:14:01,339 --> 00:14:05,990
it's a rest complete recipe actually in

00:14:03,949 --> 00:14:09,140
meta openembedded which is called distro

00:14:05,990 --> 00:14:10,449
feed configs so if you include that in

00:14:09,140 --> 00:14:12,589
your build it will generate the

00:14:10,449 --> 00:14:14,990
configuration files needed for your

00:14:12,589 --> 00:14:17,570
package manager and that you run on your

00:14:14,990 --> 00:14:20,449
device and there is some configuration

00:14:17,570 --> 00:14:24,410
parameters that you can set and the

00:14:20,449 --> 00:14:26,180
interesting is the URL or the IP address

00:14:24,410 --> 00:14:32,540
on the local network where your package

00:14:26,180 --> 00:14:38,240
feed is well yeah and if you take a look

00:14:32,540 --> 00:14:44,149
like what what that recipe creates in

00:14:38,240 --> 00:14:45,529
the case if you're using poopy co g it

00:14:44,149 --> 00:14:47,959
creates all the like the feed

00:14:45,529 --> 00:14:50,600
configuration files depending on auto

00:14:47,959 --> 00:14:51,500
auto tech chure also generic packages

00:14:50,600 --> 00:14:55,460
and

00:14:51,500 --> 00:15:00,320
and this is all output from Yocto and

00:14:55,460 --> 00:15:01,940
you can see the URL that's configurable

00:15:00,320 --> 00:15:04,280
so if you change that to your local IP

00:15:01,940 --> 00:15:11,600
address you basically have a local

00:15:04,280 --> 00:15:14,600
package feed that you can utilize so in

00:15:11,600 --> 00:15:19,310
the workflow if you set this up while

00:15:14,600 --> 00:15:21,350
doing development in some way and then

00:15:19,310 --> 00:15:25,880
it's easy to make changes in your build

00:15:21,350 --> 00:15:27,470
environment you just and you rebuild the

00:15:25,880 --> 00:15:29,450
image and then you rebuild the package

00:15:27,470 --> 00:15:32,000
index and then it's are available for

00:15:29,450 --> 00:15:34,370
your device to fetch you don't have to

00:15:32,000 --> 00:15:37,520
reflash the device with a disk image

00:15:34,370 --> 00:15:40,820
each time you make a change you can also

00:15:37,520 --> 00:15:43,580
run them a bit breakworld command that

00:15:40,820 --> 00:15:45,230
will generate packages for everything

00:15:43,580 --> 00:15:48,740
that's buildable in your environment

00:15:45,230 --> 00:15:50,870
basically so it builds that you

00:15:48,740 --> 00:15:55,300
shouldn't but yeah that takes a while so

00:15:50,870 --> 00:15:57,590
you should but that's a way of like

00:15:55,300 --> 00:16:02,150
providing a more complete package feed

00:15:57,590 --> 00:16:06,080
even if it's built when you build the

00:16:02,150 --> 00:16:07,700
image maybe you don't know what package

00:16:06,080 --> 00:16:10,370
you will need so bitbake world will

00:16:07,700 --> 00:16:13,640
build everything then it's a available

00:16:10,370 --> 00:16:18,830
through a package feed your device while

00:16:13,640 --> 00:16:22,900
doing in development any questions or

00:16:18,830 --> 00:16:22,900
like you can interrupt me while

00:16:29,670 --> 00:16:34,410
so there is something also I have never

00:16:31,860 --> 00:16:37,410
done this myself but apparently there's

00:16:34,410 --> 00:16:41,820
people doing this and sure they can do

00:16:37,410 --> 00:16:44,519
that yeah but in an enduring the server

00:16:41,820 --> 00:16:45,839
world or like Enterprise it's very

00:16:44,519 --> 00:16:48,420
common to have some kind of

00:16:45,839 --> 00:16:51,269
configuration management tool to manage

00:16:48,420 --> 00:16:53,220
a fleet of service or and there's a lot

00:16:51,269 --> 00:16:57,390
of tools that are available there's

00:16:53,220 --> 00:17:00,600
cfengine puppet and Sibyl Chef and these

00:16:57,390 --> 00:17:04,559
are all out configuration of automation

00:17:00,600 --> 00:17:08,370
over a large fleet of devices and some

00:17:04,559 --> 00:17:11,880
are applying these workflows to embedded

00:17:08,370 --> 00:17:13,260
devices as well so that means you have

00:17:11,880 --> 00:17:15,839
some kind of golden image that you

00:17:13,260 --> 00:17:17,400
install on all your devices that you

00:17:15,839 --> 00:17:20,010
need to install the configuration

00:17:17,400 --> 00:17:22,079
management server on your device this is

00:17:20,010 --> 00:17:24,110
usually something like a manual work

00:17:22,079 --> 00:17:26,730
that you would do during provisioning

00:17:24,110 --> 00:17:28,679
and you also have to set up connectivity

00:17:26,730 --> 00:17:31,260
and trust between your configuration

00:17:28,679 --> 00:17:33,809
management server and the device and

00:17:31,260 --> 00:17:35,760
then you are able to script the

00:17:33,809 --> 00:17:39,750
configuration of your device using these

00:17:35,760 --> 00:17:42,919
tools which is an interesting approach

00:17:39,750 --> 00:17:42,919
as well

00:17:46,990 --> 00:17:53,980
so but usually when working with

00:17:50,620 --> 00:17:56,770
embedded systems you you have a daddy

00:17:53,980 --> 00:17:59,020
key in some cases you build a certain

00:17:56,770 --> 00:18:01,779
hardware hardware for a certain use case

00:17:59,020 --> 00:18:03,789
and then you have some custom kernel and

00:18:01,779 --> 00:18:06,399
you have some custom kernel options that

00:18:03,789 --> 00:18:08,649
you depend on and then you write some

00:18:06,399 --> 00:18:11,559
application that integrates with other

00:18:08,649 --> 00:18:14,230
system components in the system so it's

00:18:11,559 --> 00:18:17,140
not a single binary anymore it's

00:18:14,230 --> 00:18:19,450
starting to get like a full system that

00:18:17,140 --> 00:18:21,880
you have developing so you testing

00:18:19,450 --> 00:18:26,110
usually involves you have to deploy

00:18:21,880 --> 00:18:28,299
everything to test reliably and

00:18:26,110 --> 00:18:31,200
otherwise you're just testing a single

00:18:28,299 --> 00:18:35,140
binary in a complete system so the same

00:18:31,200 --> 00:18:37,890
and when you move on to this more like a

00:18:35,140 --> 00:18:40,890
system level testing or when your

00:18:37,890 --> 00:18:42,909
application grows and and it's

00:18:40,890 --> 00:18:46,480
integrating with other components in the

00:18:42,909 --> 00:18:50,200
system and there are way other ways of

00:18:46,480 --> 00:18:54,970
doing it and one way is Network booting

00:18:50,200 --> 00:18:57,909
which is pretty common in continuous

00:18:54,970 --> 00:18:59,860
integration systems as well and what you

00:18:57,909 --> 00:19:01,809
what you do is you provide all the

00:18:59,860 --> 00:19:05,380
resources necessary to boot your device

00:19:01,809 --> 00:19:07,750
or network so the device on boot fetches

00:19:05,380 --> 00:19:10,390
both the Linux kernel device tree and

00:19:07,750 --> 00:19:12,909
the root filesystem meaning that you

00:19:10,390 --> 00:19:16,480
just need to reboot the device to update

00:19:12,909 --> 00:19:18,760
the software but there are there is some

00:19:16,480 --> 00:19:22,690
complexity involved in setting up a

00:19:18,760 --> 00:19:27,190
network booting but it can also be

00:19:22,690 --> 00:19:28,779
easily extended to multiple devices so

00:19:27,190 --> 00:19:31,210
if you have seven devices that you want

00:19:28,779 --> 00:19:32,679
to deploy the same software and maybe

00:19:31,210 --> 00:19:37,500
they are interacting with each other as

00:19:32,679 --> 00:19:37,500
well this is a way of doing that so

00:19:37,890 --> 00:19:44,590
Network booting and it's pretty common

00:19:41,440 --> 00:19:47,140
to use something called pixie Linux or

00:19:44,590 --> 00:19:49,230
pixie pixie boot in your boot if you're

00:19:47,140 --> 00:19:53,190
using your butt at the bootloader

00:19:49,230 --> 00:19:59,710
and pixie boot in your boot is add

00:19:53,190 --> 00:20:03,940
almost a bit pixie Linux and what you

00:19:59,710 --> 00:20:06,460
what you are using basically is TFTP so

00:20:03,940 --> 00:20:08,320
you have a TFTP server somewhere it can

00:20:06,460 --> 00:20:11,529
be your laptop or desktop or you have a

00:20:08,320 --> 00:20:14,710
central system where you put your build

00:20:11,529 --> 00:20:18,220
artifacts or your yeah that you want to

00:20:14,710 --> 00:20:20,159
deploy it to your devices and this is

00:20:18,220 --> 00:20:23,919
what it what a typical pixie boot

00:20:20,159 --> 00:20:26,110
configuration file looks like there is

00:20:23,919 --> 00:20:28,450
more complexity in setting this up but

00:20:26,110 --> 00:20:30,809
but what this means is that every time

00:20:28,450 --> 00:20:33,580
the device reboots it's gonna fetch

00:20:30,809 --> 00:20:40,090
software from the network and then it

00:20:33,580 --> 00:20:44,049
makes it somewhat easier to deploy but

00:20:40,090 --> 00:20:51,909
you can also script it using the boot

00:20:44,049 --> 00:20:52,270
shell or a shell language and like we

00:20:51,909 --> 00:20:57,220
are just

00:20:52,270 --> 00:21:01,059
TFTP the kernel image device tree and

00:20:57,220 --> 00:21:04,929
then set up network file storage mount

00:21:01,059 --> 00:21:07,450
the root filesystem and again this is

00:21:04,929 --> 00:21:10,299
pretty common used in continuous

00:21:07,450 --> 00:21:13,830
integration systems you can also set

00:21:10,299 --> 00:21:18,490
this up for your development workflow to

00:21:13,830 --> 00:21:21,779
optimize the time you spend on waiting

00:21:18,490 --> 00:21:24,779
for like software to be transferred or

00:21:21,779 --> 00:21:24,779
yeah

00:21:28,930 --> 00:21:36,610
yeah and in the end similar to Network

00:21:34,150 --> 00:21:38,770
booting when you need to have a complete

00:21:36,610 --> 00:21:40,690
system that you're testing that's both

00:21:38,770 --> 00:21:43,000
the Linux kernel and your application

00:21:40,690 --> 00:21:46,060
application binaries and configuration

00:21:43,000 --> 00:21:51,930
files where you are applied custom

00:21:46,060 --> 00:21:54,820
configurations all across the device so

00:21:51,930 --> 00:21:57,310
there's a lot of like update solutions

00:21:54,820 --> 00:21:58,990
nowadays I work with one of them member

00:21:57,310 --> 00:22:04,480
but there's route there's software

00:21:58,990 --> 00:22:06,370
update SW update and there's more and if

00:22:04,480 --> 00:22:08,770
you integrate one of these early on in

00:22:06,370 --> 00:22:11,820
the developed development process you

00:22:08,770 --> 00:22:14,260
can use these as development tools to

00:22:11,820 --> 00:22:16,600
deploy your builds two devices real

00:22:14,260 --> 00:22:19,980
reliably but also like on on many

00:22:16,600 --> 00:22:22,330
devices if you're testing many devices

00:22:19,980 --> 00:22:24,130
one benefit is also that you're like

00:22:22,330 --> 00:22:25,900
it's similar if you are deploying the

00:22:24,130 --> 00:22:29,410
same system in production for doing

00:22:25,900 --> 00:22:31,780
software updates you test it throughout

00:22:29,410 --> 00:22:33,670
the whole development process if you are

00:22:31,780 --> 00:22:35,770
using the same tool to build confidence

00:22:33,670 --> 00:22:38,560
that everything is working that the

00:22:35,770 --> 00:22:44,230
tools are appropriately configured and

00:22:38,560 --> 00:22:47,550
that they are working and if you some of

00:22:44,230 --> 00:22:51,880
these are using image based updates

00:22:47,550 --> 00:22:53,920
which is really nice when doing testing

00:22:51,880 --> 00:22:56,320
because image based means that your

00:22:53,920 --> 00:22:58,450
device is so stateless when you flash

00:22:56,320 --> 00:23:00,430
them with an image or the flash ten

00:22:58,450 --> 00:23:03,460
devices with the same image you are

00:23:00,430 --> 00:23:04,630
pretty sure what the software what

00:23:03,460 --> 00:23:07,210
software you are running on these

00:23:04,630 --> 00:23:08,800
devices so there's no like someone has

00:23:07,210 --> 00:23:11,500
entered that advice will change the

00:23:08,800 --> 00:23:16,000
configuration file that effects your

00:23:11,500 --> 00:23:19,920
tests or but also one benefit if these

00:23:16,000 --> 00:23:22,980
these update solutions generally have

00:23:19,920 --> 00:23:25,450
robustness built in so you're not

00:23:22,980 --> 00:23:26,770
breaking devices because that can be

00:23:25,450 --> 00:23:29,950
quite tedious if you are doing

00:23:26,770 --> 00:23:31,780
development work and you do you do not

00:23:29,950 --> 00:23:33,310
do an update and you brick your device

00:23:31,780 --> 00:23:37,420
and you have to pull out all your tools

00:23:33,310 --> 00:23:38,480
to reflash it and so that's also a help

00:23:37,420 --> 00:23:41,430
to

00:23:38,480 --> 00:23:46,920
is the developed development flow so the

00:23:41,430 --> 00:23:50,730
same and it also fits well into

00:23:46,920 --> 00:23:52,470
developer workflows like build system

00:23:50,730 --> 00:23:56,400
integration you have some kind of

00:23:52,470 --> 00:23:59,540
something that produces about an image

00:23:56,400 --> 00:24:02,490
that you need to transfer to your device

00:23:59,540 --> 00:24:03,870
which are build artifacts and then

00:24:02,490 --> 00:24:07,440
generally you have some kind of central

00:24:03,870 --> 00:24:09,150
place if you're if you ever if you have

00:24:07,440 --> 00:24:12,030
update solution the city that's able to

00:24:09,150 --> 00:24:14,460
do over-the-air updates you probably

00:24:12,030 --> 00:24:16,770
have some kind of management server and

00:24:14,460 --> 00:24:21,300
you can utilize this in your development

00:24:16,770 --> 00:24:29,340
cycles to update or test on larger

00:24:21,300 --> 00:24:31,530
fleets reality reliably and just to see

00:24:29,340 --> 00:24:34,680
some use it I'm working with Amanda I'm

00:24:31,530 --> 00:24:39,630
using memory a lot as a development tool

00:24:34,680 --> 00:24:42,030
as well and Amanda does like deploys a

00:24:39,630 --> 00:24:44,310
be update strategy which means that you

00:24:42,030 --> 00:24:46,350
have to you have two full copies of the

00:24:44,310 --> 00:24:47,040
operating system and you do image based

00:24:46,350 --> 00:24:52,620
updates

00:24:47,040 --> 00:24:54,740
she always update the whole system and

00:24:52,620 --> 00:24:59,100
you can meander works both in like a

00:24:54,740 --> 00:25:02,100
command line mode so I can set up expose

00:24:59,100 --> 00:25:04,050
my artifacts on the local network and if

00:25:02,100 --> 00:25:07,470
I have terminal access to my device I

00:25:04,050 --> 00:25:11,460
can apply that update a simple command

00:25:07,470 --> 00:25:16,260
line command but I can also integrate it

00:25:11,460 --> 00:25:19,920
in like the meander server and with my

00:25:16,260 --> 00:25:22,500
CI a continuous integration loop so

00:25:19,920 --> 00:25:24,450
let's when I push our first changes

00:25:22,500 --> 00:25:26,730
they're automatically built and they can

00:25:24,450 --> 00:25:29,850
be automatically deployed to certain

00:25:26,730 --> 00:25:31,290
devices as well and this is generally

00:25:29,850 --> 00:25:37,740
what the command would look like if I'm

00:25:31,290 --> 00:25:40,700
on the client terminal to fetch an

00:25:37,740 --> 00:25:40,700
artifact and apply it

00:25:44,110 --> 00:25:49,169
I think that's it I'm pretty fast

00:25:50,290 --> 00:25:53,280
any questions

00:25:58,420 --> 00:26:01,200
I do ask

00:26:02,500 --> 00:26:08,080
okay so on the slide where you were

00:26:05,390 --> 00:26:11,900
talking about package fees with Yocto

00:26:08,080 --> 00:26:14,030
how broadly applicable are those

00:26:11,900 --> 00:26:15,950
packages are they very specific to the

00:26:14,030 --> 00:26:18,320
particular board you built for or can

00:26:15,950 --> 00:26:22,220
they be built so that you know the

00:26:18,320 --> 00:26:24,710
obviously the the the arm core or

00:26:22,220 --> 00:26:26,270
whatever can they be used on other kinds

00:26:24,710 --> 00:26:28,659
of platforms typically yeah

00:26:26,270 --> 00:26:32,120
yeah the configuration files includes

00:26:28,659 --> 00:26:34,909
recipes generally specify ok if a recipe

00:26:32,120 --> 00:26:36,919
specifies this is a arm specific package

00:26:34,909 --> 00:26:39,950
and it's going to end up in our own

00:26:36,919 --> 00:26:41,990
specific folder in the package field so

00:26:39,950 --> 00:26:45,710
if you're running like x86 you won't get

00:26:41,990 --> 00:26:47,890
access to so that's one of the benefits

00:26:45,710 --> 00:26:50,690
of using that to distro feed config it

00:26:47,890 --> 00:26:52,370
generates configuration files based on

00:26:50,690 --> 00:26:55,309
your current architecture that you are

00:26:52,370 --> 00:26:57,620
building with your image so you can have

00:26:55,309 --> 00:27:01,490
multiple architecture you can like you

00:26:57,620 --> 00:27:03,950
can have both arm and x86 feeds in the

00:27:01,490 --> 00:27:05,690
same folder as long as the configuration

00:27:03,950 --> 00:27:13,630
files for points to their correct

00:27:05,690 --> 00:27:16,280
locations have you considered using the

00:27:13,630 --> 00:27:20,169
Yocto way of test image to create like a

00:27:16,280 --> 00:27:20,169
test image integration for a meander

00:27:21,070 --> 00:27:29,120
yeah I think we're not using that I've

00:27:25,940 --> 00:27:32,450
used it in other projects our testing

00:27:29,120 --> 00:27:37,390
framework is based on Python pie taste

00:27:32,450 --> 00:27:40,880
and fabric I think so that's what we

00:27:37,390 --> 00:27:43,900
what I have used your toe test framework

00:27:40,880 --> 00:27:48,200
in other projects which is pretty nice

00:27:43,900 --> 00:27:50,570
and it's fairly easy to set up yeah so

00:27:48,200 --> 00:27:53,780
is your framework available for the

00:27:50,570 --> 00:27:57,190
users of manner or is it just when you

00:27:53,780 --> 00:28:00,830
develop a number I mean all our QA is

00:27:57,190 --> 00:28:02,870
open source it's only that we have our

00:28:00,830 --> 00:28:05,659
Jenkins server that runs the builds

00:28:02,870 --> 00:28:07,490
that's not publicly accessible but all

00:28:05,659 --> 00:28:09,640
the scripts we are using is publicly

00:28:07,490 --> 00:28:09,640
available

00:28:10,450 --> 00:28:15,920
hi I was wondering your your promoting

00:28:13,640 --> 00:28:18,320
packages is this just full deployment

00:28:15,920 --> 00:28:21,170
and then a B images for production and

00:28:18,320 --> 00:28:24,650
or sorry development versus production

00:28:21,170 --> 00:28:26,450
yeah generally package managers are they

00:28:24,650 --> 00:28:29,240
are really good while development

00:28:26,450 --> 00:28:32,030
developed me but not something that I

00:28:29,240 --> 00:28:34,090
would do you use deploying say during

00:28:32,030 --> 00:28:39,940
production you'd be prefer an a/v image

00:28:34,090 --> 00:28:39,940
yeah I prefer a image updates thank you

00:28:42,010 --> 00:28:46,100
could you please explain

00:28:43,760 --> 00:28:48,650
at what level mentor works is it kind of

00:28:46,100 --> 00:28:50,380
extension to you boot or any other boot

00:28:48,650 --> 00:28:53,240
loader or it's a user space application

00:28:50,380 --> 00:28:56,870
so how it generally works it's

00:28:53,240 --> 00:28:59,420
everything the chimp action now that

00:28:56,870 --> 00:29:02,060
it's a critter client in user space that

00:28:59,420 --> 00:29:06,350
you have it's the mentor client it's a

00:29:02,060 --> 00:29:09,170
management server but the mender client

00:29:06,350 --> 00:29:10,850
requires you boot integration because

00:29:09,170 --> 00:29:13,430
you need to have control of their boot

00:29:10,850 --> 00:29:15,620
command if you are having you need to

00:29:13,430 --> 00:29:18,320
switch like which partition am i voting

00:29:15,620 --> 00:29:23,470
right now and that that happens in your

00:29:18,320 --> 00:29:23,470
boot so I loved it

00:29:32,870 --> 00:29:41,770
okay there's no more questions thank you

00:29:36,799 --> 00:29:41,770

YouTube URL: https://www.youtube.com/watch?v=rCDZVjHHC6o


