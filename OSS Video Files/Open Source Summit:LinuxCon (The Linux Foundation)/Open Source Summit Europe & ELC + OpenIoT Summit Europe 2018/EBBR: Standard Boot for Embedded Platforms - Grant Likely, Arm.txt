Title: EBBR: Standard Boot for Embedded Platforms - Grant Likely, Arm
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	EBBR: Standard Boot for Embedded Platforms - Grant Likely, Arm

Booting and embedded systems are not always simple. Even though most platforms have U-Boot firmware, each one has slightly different behavior with regard to installing and booting an OS. In addition, the embedded boot flow uses entirely different interfaces when compared to the general purpose server and desktop ecosystems. All this adds up to requiring custom enablement for each platform, which is not viable for most OS distribution projects.

The Embedded Base Boot Requirements (EBBR) project is a new effort to define a standard for booting embedded platforms that is supportable by the existing OS ecosystem. EBBR specifies a subset of the UEFI standard that can be implemented with upstream U-Boot and takes into account design patterns common on embedded systems. In this session, we'll discuss the goals of the EBBR project, the state of the EBBR document right now, and the progress to creating EBBR reference platforms using existing QEMU models and popular development boards. 

About Grant Likely
Grant Likely is a Linux kernel engineer working for Arm, Ltd. He is perhaps best know for his work on the Devicetree subsystem used by many embedded Linux systems, and for representing kernel developers on the
Linux Foundation Technical Advisory Board. At Arm, Grant works on software architecture in the Central Engineering Open Source Software group.

Occasionally he picks up a soldering iron and pretends to be a hardware engineer.
Captions: 
	00:00:00,030 --> 00:00:05,580
good morning everyone well I'm actually

00:00:04,170 --> 00:00:07,770
quite surprised that I've got so many

00:00:05,580 --> 00:00:09,150
people here when I'm competing with a

00:00:07,770 --> 00:00:10,650
number of other talks and it's 9 o'clock

00:00:09,150 --> 00:00:12,150
in the morning I suppose it's early

00:00:10,650 --> 00:00:14,790
enough in the conference the people are

00:00:12,150 --> 00:00:17,820
getting up thank you very much for

00:00:14,790 --> 00:00:20,010
coming my name is grant likely I am an

00:00:17,820 --> 00:00:21,779
engineer at arm working I've been

00:00:20,010 --> 00:00:25,170
involved with the Linux community for

00:00:21,779 --> 00:00:27,240
many years and I am here to talk about

00:00:25,170 --> 00:00:29,580
something that I'm hoping is really

00:00:27,240 --> 00:00:32,160
boring because it's about standards it's

00:00:29,580 --> 00:00:34,110
about making things just work rather

00:00:32,160 --> 00:00:38,010
than exciting new features or things

00:00:34,110 --> 00:00:41,820
like this so I've got a short talk here

00:00:38,010 --> 00:00:43,500
on a project that I am a number of

00:00:41,820 --> 00:00:46,110
others in the Linux community have been

00:00:43,500 --> 00:00:47,730
working on recently to make when we're

00:00:46,110 --> 00:00:50,039
doing embedded systems to make it a

00:00:47,730 --> 00:00:51,870
whole lot easier to get past that stage

00:00:50,039 --> 00:00:53,670
of being able to boot being able to

00:00:51,870 --> 00:00:56,989
manage being able to to update the

00:00:53,670 --> 00:00:59,940
system and the project is called ebbr

00:00:56,989 --> 00:01:02,789
ebbr stands for embedded based boot

00:00:59,940 --> 00:01:05,250
requirements so before I get into that I

00:01:02,789 --> 00:01:07,860
want to talk a little bit about the

00:01:05,250 --> 00:01:12,630
history that we have with with firmware

00:01:07,860 --> 00:01:14,960
in the computer industry so I'm in

00:01:12,630 --> 00:01:17,520
medicine for a lot of you this will be

00:01:14,960 --> 00:01:21,710
this is not new information but I won't

00:01:17,520 --> 00:01:27,270
kind of take it from a particular stance

00:01:21,710 --> 00:01:29,610
with the in the desktop PC server market

00:01:27,270 --> 00:01:32,610
we've had for a long time right from

00:01:29,610 --> 00:01:35,759
very early on there's been a very strong

00:01:32,610 --> 00:01:37,500
push towards being able to the hardware

00:01:35,759 --> 00:01:39,540
vendors produce their hardware and then

00:01:37,500 --> 00:01:42,659
we've got a number of OS vendors that

00:01:39,540 --> 00:01:45,810
want to run on it after you know after

00:01:42,659 --> 00:01:48,210
very early days it became very very

00:01:45,810 --> 00:01:49,979
obvious that the software vendors the OS

00:01:48,210 --> 00:01:51,119
vendors could not support all the

00:01:49,979 --> 00:01:53,640
hardware that was out there there was

00:01:51,119 --> 00:01:56,640
just too much and that drove a whole

00:01:53,640 --> 00:01:58,500
bunch of this there was the expectation

00:01:56,640 --> 00:02:00,840
that end users would be installing their

00:01:58,500 --> 00:02:03,420
operating systems it drove a lot of

00:02:00,840 --> 00:02:04,860
horizontal integration so the PC vendors

00:02:03,420 --> 00:02:06,390
they were cared about their hardware

00:02:04,860 --> 00:02:07,680
they didn't want want to have to deal

00:02:06,390 --> 00:02:10,430
with the software and so you've got that

00:02:07,680 --> 00:02:13,200
that tearing that goes on which requires

00:02:10,430 --> 00:02:13,800
which creates just a combinational

00:02:13,200 --> 00:02:15,930
explosion

00:02:13,800 --> 00:02:17,190
of the number of situations that you can

00:02:15,930 --> 00:02:21,360
get in of the different pieces of

00:02:17,190 --> 00:02:23,060
hardware this required standardization

00:02:21,360 --> 00:02:26,160
this was actually an economic incentive

00:02:23,060 --> 00:02:29,040
that the companies that were involved

00:02:26,160 --> 00:02:30,480
sometimes happily sometimes kicking and

00:02:29,040 --> 00:02:32,160
screaming they got involved with

00:02:30,480 --> 00:02:35,100
standards and they had to make their

00:02:32,160 --> 00:02:37,940
products conform to standards to allow

00:02:35,100 --> 00:02:40,260
for them to play within that market

00:02:37,940 --> 00:02:42,660
those of us who build embedded systems

00:02:40,260 --> 00:02:44,880
know that that market is that that

00:02:42,660 --> 00:02:49,740
doesn't work the same way for most of

00:02:44,880 --> 00:02:51,060
our embedded systems were we have one

00:02:49,740 --> 00:02:53,730
company that generally makes the

00:02:51,060 --> 00:02:55,680
hardware usually the same company has

00:02:53,730 --> 00:02:58,080
direct control over the OS or at least

00:02:55,680 --> 00:03:00,900
the one company has control over that

00:02:58,080 --> 00:03:03,540
final product of the board there so see

00:03:00,900 --> 00:03:05,070
the software operating system and the

00:03:03,540 --> 00:03:07,170
applications that run on that is all

00:03:05,070 --> 00:03:10,860
bound together and is managed by by a

00:03:07,170 --> 00:03:13,200
single place that vertical integration

00:03:10,860 --> 00:03:15,210
is great because you can go whatever you

00:03:13,200 --> 00:03:16,860
need to do you can go in you can change

00:03:15,210 --> 00:03:21,300
it you can make it work the way that you

00:03:16,860 --> 00:03:22,920
need to and some have said within them

00:03:21,300 --> 00:03:25,890
better community it's like we don't care

00:03:22,920 --> 00:03:27,870
about standards which I don't think is

00:03:25,890 --> 00:03:29,580
entirely true we do care about standards

00:03:27,870 --> 00:03:31,530
but often the moment the standard isn't

00:03:29,580 --> 00:03:32,730
actually helping us we go often we do

00:03:31,530 --> 00:03:34,980
something else we do what we need to

00:03:32,730 --> 00:03:36,360
because of our tight timeframes because

00:03:34,980 --> 00:03:39,270
we've got to get products out the door

00:03:36,360 --> 00:03:41,670
we just want to we do what we need to to

00:03:39,270 --> 00:03:43,770
get done but when things do work when

00:03:41,670 --> 00:03:44,940
the standards do work it helps as long

00:03:43,770 --> 00:03:49,580
because that's one less thing that we

00:03:44,940 --> 00:03:52,080
need to be need to be dealing with so

00:03:49,580 --> 00:03:53,340
the economic incentive just happens to

00:03:52,080 --> 00:03:55,470
be that not there and without that

00:03:53,340 --> 00:03:57,780
economic incentive to make sure that

00:03:55,470 --> 00:04:00,750
we've got standards in place to boot it

00:03:57,780 --> 00:04:02,970
just doesn't happen and so and not from

00:04:00,750 --> 00:04:04,170
malice just because we've got other

00:04:02,970 --> 00:04:09,600
things we've got better things to do

00:04:04,170 --> 00:04:11,250
with our time things are getting more

00:04:09,600 --> 00:04:12,840
complicated now we're getting more

00:04:11,250 --> 00:04:15,959
capable and what kinds of hardware were

00:04:12,840 --> 00:04:20,489
able to produce we've got a lot of SBC's

00:04:15,959 --> 00:04:22,890
now you know 15 years ago it was their

00:04:20,489 --> 00:04:24,479
only engineers with large budgets were

00:04:22,890 --> 00:04:26,729
able to get access to a lot of the

00:04:24,479 --> 00:04:27,490
development boards there wasn't a whole

00:04:26,729 --> 00:04:28,750
lot of hacker

00:04:27,490 --> 00:04:31,330
words that were really available and

00:04:28,750 --> 00:04:34,509
there was a limit to the amount that you

00:04:31,330 --> 00:04:36,520
could actually do things have changed

00:04:34,509 --> 00:04:38,500
quite a bit now I mean we've got just an

00:04:36,520 --> 00:04:41,349
explosion of kind of single board

00:04:38,500 --> 00:04:43,270
computers that are available to to

00:04:41,349 --> 00:04:45,880
hobbyists to companies that are wanting

00:04:43,270 --> 00:04:49,440
to start prototyping get it get a

00:04:45,880 --> 00:04:51,729
product out there for a very low cost

00:04:49,440 --> 00:04:53,710
and the software stacks getting a whole

00:04:51,729 --> 00:04:57,400
lot more complicated where a lot of

00:04:53,710 --> 00:04:58,660
applications the number of years ago for

00:04:57,400 --> 00:05:00,460
probably if you know we could probably

00:04:58,660 --> 00:05:01,720
do it with Linux kernel busybox

00:05:00,460 --> 00:05:03,900
and then a little bit of custom code on

00:05:01,720 --> 00:05:06,639
top as we're getting into IOT devices

00:05:03,900 --> 00:05:07,720
the capability the amount of software

00:05:06,639 --> 00:05:09,909
that we need to be running on these

00:05:07,720 --> 00:05:11,560
devices is starting to get larger we're

00:05:09,909 --> 00:05:12,909
expecting more other devices we're

00:05:11,560 --> 00:05:17,229
expecting to have network stacks we're

00:05:12,909 --> 00:05:19,449
expecting to have security a secure

00:05:17,229 --> 00:05:21,370
updates we're expecting to have the

00:05:19,449 --> 00:05:23,860
ability to keep track of many different

00:05:21,370 --> 00:05:27,340
revisions of the hardware because it's

00:05:23,860 --> 00:05:28,960
easier to come get these this equipment

00:05:27,340 --> 00:05:30,400
some some companies have multiple pieces

00:05:28,960 --> 00:05:33,580
of hardware and they need to support it

00:05:30,400 --> 00:05:35,590
all but with you know how do you make

00:05:33,580 --> 00:05:40,630
sure that those things all behave the

00:05:35,590 --> 00:05:43,419
same way and this becomes a it's

00:05:40,630 --> 00:05:45,900
becoming more and more desirable to be

00:05:43,419 --> 00:05:48,729
able to actually use pre can distros

00:05:45,900 --> 00:05:50,979
even on embedded platforms you know so

00:05:48,729 --> 00:05:52,419
for a long time we were comfortable you

00:05:50,979 --> 00:05:55,000
know we are comfortable with using like

00:05:52,419 --> 00:05:57,430
Yocto or build route to get an image put

00:05:55,000 --> 00:06:00,250
together but now there's also the well

00:05:57,430 --> 00:06:02,380
do I really need to man maintain all of

00:06:00,250 --> 00:06:04,330
that software do I need to be the one

00:06:02,380 --> 00:06:06,460
who's responsible for the kernel and all

00:06:04,330 --> 00:06:08,199
of user space when the product I'm

00:06:06,460 --> 00:06:10,780
working on I'm mostly interested in my

00:06:08,199 --> 00:06:14,199
application in fact if I can offload a

00:06:10,780 --> 00:06:16,180
lot of that maintenance of this of the

00:06:14,199 --> 00:06:18,759
of most of the software stack to a

00:06:16,180 --> 00:06:20,979
distribution partner whether it's a

00:06:18,759 --> 00:06:23,020
traditional distro or an embedded distro

00:06:20,979 --> 00:06:24,729
don't there's lots of options out there

00:06:23,020 --> 00:06:25,870
that means that there's less engineering

00:06:24,729 --> 00:06:28,330
work that I need to be spending my time

00:06:25,870 --> 00:06:30,460
on so there's an economic they're

00:06:28,330 --> 00:06:32,800
starting to be an economic incentive to

00:06:30,460 --> 00:06:35,289
make sure that these embedded these

00:06:32,800 --> 00:06:38,710
traditionally embedded platforms can be

00:06:35,289 --> 00:06:40,300
supported and run with existing

00:06:38,710 --> 00:06:42,490
distributions

00:06:40,300 --> 00:06:45,240
so for example the Debian's the Sousa is

00:06:42,490 --> 00:06:47,770
the Red House bunches of the world

00:06:45,240 --> 00:06:50,619
should it be possible should we be able

00:06:47,770 --> 00:06:52,539
to put together and boot an embedded

00:06:50,619 --> 00:06:54,689
system and all of these SBC's that are

00:06:52,539 --> 00:06:57,969
easily available with these standard

00:06:54,689 --> 00:07:00,129
platforms I think it's we we should be

00:06:57,969 --> 00:07:03,550
able to the district certainly think we

00:07:00,129 --> 00:07:07,360
should be able to but it's really really

00:07:03,550 --> 00:07:10,360
hard every single SBC that's out there

00:07:07,360 --> 00:07:11,860
has a different you know what if we put

00:07:10,360 --> 00:07:14,919
you boot on the board and quite often

00:07:11,860 --> 00:07:16,749
the install the way that you moves

00:07:14,919 --> 00:07:18,129
configured behaves slightly differently

00:07:16,749 --> 00:07:20,259
there's slightly different food scripts

00:07:18,129 --> 00:07:22,179
it needs a slightly different setup for

00:07:20,259 --> 00:07:25,539
the the way the device tree is passed

00:07:22,179 --> 00:07:28,149
through and it's an it's impossible for

00:07:25,539 --> 00:07:30,249
the Linux distros or even any other

00:07:28,149 --> 00:07:32,110
operating system to support this beyond

00:07:30,249 --> 00:07:34,209
just a couple of boards because every

00:07:32,110 --> 00:07:41,259
single new board is new engineering

00:07:34,209 --> 00:07:43,689
effort required it's also not

00:07:41,259 --> 00:07:45,249
supportable because the number of board

00:07:43,689 --> 00:07:48,279
specific images that we end up needing

00:07:45,249 --> 00:07:49,959
to have we've got not only is it a

00:07:48,279 --> 00:07:52,419
problem of the boot flow of how do you

00:07:49,959 --> 00:07:54,279
get from firmware on a board into an

00:07:52,419 --> 00:07:56,439
operating system but how do you tell

00:07:54,279 --> 00:08:00,039
that operating system about what's on

00:07:56,439 --> 00:08:01,990
that board you know many of you are

00:08:00,039 --> 00:08:04,749
familiar with of course with device tree

00:08:01,990 --> 00:08:07,719
and you can blame me for some of the

00:08:04,749 --> 00:08:09,279
pain and for some device tree but with

00:08:07,719 --> 00:08:11,379
device reeds one of the major things

00:08:09,279 --> 00:08:13,990
that did that gave us that separation of

00:08:11,379 --> 00:08:15,759
board description and the firmware that

00:08:13,990 --> 00:08:17,589
actually are the the operating system

00:08:15,759 --> 00:08:19,059
that runs on the board the next step is

00:08:17,589 --> 00:08:20,759
to take that machine description and

00:08:19,059 --> 00:08:22,689
actually make that part of the platform

00:08:20,759 --> 00:08:23,949
once you take those four machine

00:08:22,689 --> 00:08:26,050
descriptions and make it part of the

00:08:23,949 --> 00:08:29,169
platform now we're in the situation if

00:08:26,050 --> 00:08:31,149
we've got a standard boot flow and the

00:08:29,169 --> 00:08:32,769
machine is able to describe itself to

00:08:31,149 --> 00:08:35,500
the operating system we're now in a

00:08:32,769 --> 00:08:36,880
situation where the standard istros can

00:08:35,500 --> 00:08:38,769
actually support it in their released

00:08:36,880 --> 00:08:40,870
images without having to go in and hack

00:08:38,769 --> 00:08:43,860
things around or get a custom kernel to

00:08:40,870 --> 00:08:43,860
get the board up and running

00:08:46,630 --> 00:08:51,519
so and then that that opens up once

00:08:49,389 --> 00:08:53,829
you've got that ability that opens up

00:08:51,519 --> 00:08:56,019
the the district's being able to

00:08:53,829 --> 00:08:58,360
actually perform there's the work that

00:08:56,019 --> 00:09:01,029
they do with doing colonel updates

00:08:58,360 --> 00:09:04,389
keeping up on security updates and being

00:09:01,029 --> 00:09:07,139
able to install and update all parts of

00:09:04,389 --> 00:09:09,940
the operating system in a standard way

00:09:07,139 --> 00:09:12,600
so some of the other problems I've just

00:09:09,940 --> 00:09:15,100
got on this slide so I don't forget

00:09:12,600 --> 00:09:16,690
there's a couple of other use cases in

00:09:15,100 --> 00:09:20,589
the embedded space that ends up being

00:09:16,690 --> 00:09:22,060
painful one is is that with the with

00:09:20,589 --> 00:09:24,459
embedded firmware we haven't really had

00:09:22,060 --> 00:09:26,259
a standard pre boot environment so there

00:09:24,459 --> 00:09:28,569
have been a number of embedded platforms

00:09:26,259 --> 00:09:30,130
that I've worked on where they've wanted

00:09:28,569 --> 00:09:34,000
to they've needed to do some custom

00:09:30,130 --> 00:09:36,190
stuff at boot time well okay well though

00:09:34,000 --> 00:09:38,440
they'll you say the the you boot API and

00:09:36,190 --> 00:09:40,000
go and write a little bit of code it's

00:09:38,440 --> 00:09:42,910
not necessarily portable to another

00:09:40,000 --> 00:09:45,579
platform so the API that has been there

00:09:42,910 --> 00:09:48,730
has been insufficient to this point and

00:09:45,579 --> 00:09:50,470
the world isn't all Linux we pretend it

00:09:48,730 --> 00:09:51,910
is we light weaves keep all our device

00:09:50,470 --> 00:09:55,930
tree files in the Linux kernel source

00:09:51,910 --> 00:09:58,029
tree but FreeBSD is interested in

00:09:55,930 --> 00:09:59,290
supporting these platforms too Microsoft

00:09:58,029 --> 00:10:00,910
is supporting is interested in

00:09:59,290 --> 00:10:02,350
supporting these platforms the other

00:10:00,910 --> 00:10:04,509
operating systems that are there some of

00:10:02,350 --> 00:10:06,100
those crazy experimental stuff I love

00:10:04,509 --> 00:10:07,389
the people who do crazy stuff who do

00:10:06,100 --> 00:10:09,009
things that don't seem to make any sense

00:10:07,389 --> 00:10:10,660
because they're the ones who regret

00:10:09,009 --> 00:10:15,670
coming up with the ideas that are

00:10:10,660 --> 00:10:17,889
interesting for future products all this

00:10:15,670 --> 00:10:19,240
comes down to is when it comes to the

00:10:17,889 --> 00:10:21,100
feature list that I want to see am i

00:10:19,240 --> 00:10:23,980
firmware exciting is not one of them

00:10:21,100 --> 00:10:25,779
when I when I bring up a board what I

00:10:23,980 --> 00:10:28,810
want is I want it to work I want to be

00:10:25,779 --> 00:10:31,060
able to whether I'm using a existing

00:10:28,810 --> 00:10:32,889
distro and put in put an image on it

00:10:31,060 --> 00:10:35,500
that it will just boot or if even if I'm

00:10:32,889 --> 00:10:37,389
building an image from scratch I don't

00:10:35,500 --> 00:10:39,490
want to have to do custom board specific

00:10:37,389 --> 00:10:43,470
stuff just to get my operating system up

00:10:39,490 --> 00:10:46,089
and running these are solvable problems

00:10:43,470 --> 00:10:47,649
there's no technical barriers to the

00:10:46,089 --> 00:10:50,319
kind of standardization that's required

00:10:47,649 --> 00:10:52,480
here there's we've got all the

00:10:50,319 --> 00:10:55,600
technology that we need to do

00:10:52,480 --> 00:10:57,160
we've got as I was just saying with the

00:10:55,600 --> 00:10:59,139
octo know is this isn't just about

00:10:57,160 --> 00:11:01,089
supporting distros on embedded platforms

00:10:59,139 --> 00:11:03,699
this is even about supporting custom

00:11:01,089 --> 00:11:05,139
vertically integrated stacks on s pcs

00:11:03,699 --> 00:11:07,359
because once you've got those standards

00:11:05,139 --> 00:11:08,859
in place and they work it means you

00:11:07,359 --> 00:11:10,269
don't have to go filling with that you

00:11:08,859 --> 00:11:15,759
can spend your engineering time on other

00:11:10,269 --> 00:11:17,589
things also platform specific features

00:11:15,759 --> 00:11:19,569
aren't actually impeded so one of the

00:11:17,589 --> 00:11:23,169
arguments against standardization is

00:11:19,569 --> 00:11:24,970
well I need to do my custom thing that's

00:11:23,169 --> 00:11:26,230
no problem doing your custom thing is

00:11:24,970 --> 00:11:28,749
there what the standard does is gives

00:11:26,230 --> 00:11:30,790
you a framework so that you've got a

00:11:28,749 --> 00:11:34,720
place to go and do your custom thing

00:11:30,790 --> 00:11:35,889
without breaking the existing flow and

00:11:34,720 --> 00:11:38,410
we're just doing a whole lot duplicating

00:11:35,889 --> 00:11:40,629
of the same work it really isn't a need

00:11:38,410 --> 00:11:46,149
to do that so the the whole point this

00:11:40,629 --> 00:11:47,559
ebbr project is as it's I'm here at a

00:11:46,149 --> 00:11:50,410
software conference talking about a

00:11:47,559 --> 00:11:52,480
project about a document so ebbr is a

00:11:50,410 --> 00:11:54,669
document that's all it is but it's a

00:11:52,480 --> 00:11:56,859
document that covers some of the things

00:11:54,669 --> 00:11:59,859
that have already been going on within

00:11:56,859 --> 00:12:01,779
the embedded community and it actually

00:11:59,859 --> 00:12:04,480
pulls them together as this is kind of

00:12:01,779 --> 00:12:05,709
what needs to be there to be a standard

00:12:04,480 --> 00:12:12,850
and I'm gonna talk a little bit about

00:12:05,709 --> 00:12:15,309
that now so just on the topic of the you

00:12:12,850 --> 00:12:17,289
know even on embedded platforms I need

00:12:15,309 --> 00:12:21,309
to have this a case study this is a

00:12:17,289 --> 00:12:22,839
platform that I had been looking at say

00:12:21,309 --> 00:12:25,119
you've got a cable set-top box these

00:12:22,839 --> 00:12:27,999
things tend to have when they're

00:12:25,119 --> 00:12:29,799
provided by the cable provider they tend

00:12:27,999 --> 00:12:31,539
to have very fixed or very defined

00:12:29,799 --> 00:12:35,559
stacks and they've they're controlled

00:12:31,539 --> 00:12:39,189
they're managed remotely from the from

00:12:35,559 --> 00:12:42,509
the cable provider minimal local storage

00:12:39,189 --> 00:12:44,799
it's every time it boots up it looks for

00:12:42,509 --> 00:12:46,419
looks for updates off the network

00:12:44,799 --> 00:12:47,799
it needs a pre boot agent and they were

00:12:46,419 --> 00:12:50,199
doing them whole bunch of custom work on

00:12:47,799 --> 00:12:51,699
every single platform to be able to go

00:12:50,199 --> 00:12:53,470
and see do I need to do some

00:12:51,699 --> 00:12:56,139
configuration or updates to this

00:12:53,470 --> 00:12:57,939
platform before I boot the OS multiple

00:12:56,139 --> 00:13:00,039
hairy Hardware variants that they had to

00:12:57,939 --> 00:13:03,100
support but they were really hitting the

00:13:00,039 --> 00:13:04,269
pain of not having a single OS image one

00:13:03,100 --> 00:13:05,410
of the things that the standardization

00:13:04,269 --> 00:13:09,910
was giving them

00:13:05,410 --> 00:13:11,560
is all those funky silly embedded things

00:13:09,910 --> 00:13:13,149
that they needed to do didn't had a

00:13:11,560 --> 00:13:15,879
framework for being able to do that him

00:13:13,149 --> 00:13:17,529
so the having a common API at firmware

00:13:15,879 --> 00:13:20,139
allow them to go do what they needed to

00:13:17,529 --> 00:13:23,170
do while still having a Linux kernel

00:13:20,139 --> 00:13:25,300
that was built from the from mainline

00:13:23,170 --> 00:13:27,069
source be able to get information with

00:13:25,300 --> 00:13:33,100
the platform and and boot on into the

00:13:27,069 --> 00:13:35,949
system right so I think I've established

00:13:33,100 --> 00:13:37,660
standards are good they don't appears so

00:13:35,949 --> 00:13:39,850
what if we're trying to standardize the

00:13:37,660 --> 00:13:43,420
boot interface what do we actually work

00:13:39,850 --> 00:13:44,829
on there are an awful lot of projects

00:13:43,420 --> 00:13:47,470
that we've got in the you know I've just

00:13:44,829 --> 00:13:49,899
got a small survey of them here you boot

00:13:47,470 --> 00:13:53,199
of course is what most embedded

00:13:49,899 --> 00:13:56,680
platforms for little kernel or possibly

00:13:53,199 --> 00:13:57,399
Tiano core is used on a lot of Android

00:13:56,680 --> 00:13:59,740
devices

00:13:57,399 --> 00:14:03,040
there's core boots wears Chrome OS has

00:13:59,740 --> 00:14:05,019
been using there's a wealth when shinty

00:14:03,040 --> 00:14:07,120
on record there's Linux boot that has

00:14:05,019 --> 00:14:09,220
been gaining a lot of traction in the in

00:14:07,120 --> 00:14:10,810
the server space there's a lot of these

00:14:09,220 --> 00:14:12,490
projects that are out there and it's not

00:14:10,810 --> 00:14:14,259
just about the bootloader firmware

00:14:12,490 --> 00:14:16,870
because there's another set of firmware

00:14:14,259 --> 00:14:18,850
that set of Pro projects that are

00:14:16,870 --> 00:14:22,000
involved here as well so trusted

00:14:18,850 --> 00:14:24,009
firmware is as a project that runs at

00:14:22,000 --> 00:14:25,930
the higher privilege level from where

00:14:24,009 --> 00:14:29,980
your operating system will run this

00:14:25,930 --> 00:14:33,550
stuff needs to be there whether we do a

00:14:29,980 --> 00:14:35,079
transformer or a vendor specific thing

00:14:33,550 --> 00:14:37,630
there's also trusted execution

00:14:35,079 --> 00:14:40,449
environments there's a lot of moving

00:14:37,630 --> 00:14:41,920
pieces here and so we need to choose if

00:14:40,449 --> 00:14:43,300
we're gonna try to push towards

00:14:41,920 --> 00:14:45,550
standards on embedded we need to choose

00:14:43,300 --> 00:14:48,720
a few things that that we're going to

00:14:45,550 --> 00:14:52,059
start working on so what do we start

00:14:48,720 --> 00:14:55,120
well especially when your project is

00:14:52,059 --> 00:14:56,740
just a document you need to have some

00:14:55,120 --> 00:15:00,579
things that are actually where we're

00:14:56,740 --> 00:15:02,949
actually making some progress so the the

00:15:00,579 --> 00:15:04,209
intent of this this process with ebbr

00:15:02,949 --> 00:15:07,629
was to start with things that we already

00:15:04,209 --> 00:15:08,259
have working an upstream well before you

00:15:07,629 --> 00:15:11,050
know ebbr

00:15:08,259 --> 00:15:14,050
was conceived of about a year and a bit

00:15:11,050 --> 00:15:15,610
ago took a little bit of time to get up

00:15:14,050 --> 00:15:16,799
and running but there was already work

00:15:15,610 --> 00:15:19,919
going on

00:15:16,799 --> 00:15:22,679
within u-boot to standardize what what

00:15:19,919 --> 00:15:25,019
the boot flow would be that gave us gave

00:15:22,679 --> 00:15:27,659
us a base fund for for what we would be

00:15:25,019 --> 00:15:29,459
working on and most of what was needed

00:15:27,659 --> 00:15:31,769
was right there and what was missing was

00:15:29,459 --> 00:15:33,269
some discussion over how that actually

00:15:31,769 --> 00:15:37,199
should be implemented what the guidance

00:15:33,269 --> 00:15:38,459
is for putting that on to a platform we

00:15:37,199 --> 00:15:41,339
want stuff that was implemented in

00:15:38,459 --> 00:15:43,589
upstream projects and we want to start

00:15:41,339 --> 00:15:45,739
with is achievable goals I don't have

00:15:43,589 --> 00:15:47,999
makes no sense to me to go off and do a

00:15:45,739 --> 00:15:50,039
specification project in this day and

00:15:47,999 --> 00:15:51,869
age when there's no software backing you

00:15:50,039 --> 00:15:53,759
so all the stuff that's going into ebbr

00:15:51,869 --> 00:15:55,679
is stuff that's already being already

00:15:53,759 --> 00:15:58,349
implemented or being implemented in open

00:15:55,679 --> 00:15:59,659
source projects so that's why we started

00:15:58,349 --> 00:16:01,799
with hugh boot and trusted firmware a

00:15:59,659 --> 00:16:03,659
all of the stuff that I'm talking about

00:16:01,799 --> 00:16:05,789
here today is equally applicable to the

00:16:03,659 --> 00:16:08,279
other firmware projects and one of the

00:16:05,789 --> 00:16:10,889
questions I've gotten is why don't you

00:16:08,279 --> 00:16:11,639
do with this firmware instead of you

00:16:10,889 --> 00:16:14,429
boot

00:16:11,639 --> 00:16:15,809
it's simply pragmatism of it was we

00:16:14,429 --> 00:16:16,259
needed a place to start and that make

00:16:15,809 --> 00:16:17,879
sense

00:16:16,259 --> 00:16:19,559
besides for most of the platforms that

00:16:17,879 --> 00:16:21,989
we care about you boot is already on

00:16:19,559 --> 00:16:27,289
there so that's the that's the same

00:16:21,989 --> 00:16:30,199
place to start right so what is ebbr

00:16:27,289 --> 00:16:33,329
ebbr is a platform requirements document

00:16:30,199 --> 00:16:35,039
it is you know if you're familiar with

00:16:33,329 --> 00:16:36,869
the windows ecosystem is similar to the

00:16:35,039 --> 00:16:39,359
document that Microsoft Publisher is

00:16:36,869 --> 00:16:42,119
that says if we are so to support

00:16:39,359 --> 00:16:43,829
Windows on this platform then you your

00:16:42,119 --> 00:16:46,349
platform needs to conform to the

00:16:43,829 --> 00:16:48,689
requirements in this spec it's not a

00:16:46,349 --> 00:16:50,069
technical spec that says you know how

00:16:48,689 --> 00:16:51,869
you implement all the features of what

00:16:50,069 --> 00:16:53,909
features but it's a document that refers

00:16:51,869 --> 00:16:55,649
to the other specs and then fills in the

00:16:53,909 --> 00:17:00,059
gaps where things are ambiguous or

00:16:55,649 --> 00:17:02,609
missing it's intended to be usable by

00:17:00,059 --> 00:17:06,240
Linux distributions in particular for

00:17:02,609 --> 00:17:10,199
them to say this is the base standard if

00:17:06,240 --> 00:17:12,869
you want your board your SBC or a better

00:17:10,199 --> 00:17:15,360
product to be bootable with a standard

00:17:12,869 --> 00:17:19,230
operating system then you should conform

00:17:15,360 --> 00:17:24,899
to what this document says and then it's

00:17:19,230 --> 00:17:27,720
it so and then the other thing that this

00:17:24,899 --> 00:17:29,169
is is it's a completely open process so

00:17:27,720 --> 00:17:33,070
as

00:17:29,169 --> 00:17:35,440
I work for arm and arm is you know we

00:17:33,070 --> 00:17:38,350
produce a lot of IP and we produce a lot

00:17:35,440 --> 00:17:39,610
of specification documents a lot of the

00:17:38,350 --> 00:17:43,630
time we do things in a very proprietary

00:17:39,610 --> 00:17:45,549
manner we we go off we ask the we ask

00:17:43,630 --> 00:17:47,140
our partners what do you want we go off

00:17:45,549 --> 00:17:48,070
we write it we come back and say is this

00:17:47,140 --> 00:17:49,390
it

00:17:48,070 --> 00:17:51,280
and then we either give it to the more

00:17:49,390 --> 00:17:52,990
we license it or whatever this is

00:17:51,280 --> 00:17:55,960
actually a very new process for us we

00:17:52,990 --> 00:17:59,020
realized that while those who are

00:17:55,960 --> 00:18:00,549
involved arm is hosting this but for

00:17:59,020 --> 00:18:02,140
this to be useful especially for this

00:18:00,549 --> 00:18:03,760
community for the embedded community its

00:18:02,140 --> 00:18:06,100
of no value if we go off and do

00:18:03,760 --> 00:18:08,440
something in private and then say here

00:18:06,100 --> 00:18:10,990
you go actually in fact we tried that

00:18:08,440 --> 00:18:12,400
the first version of ebbr we asked

00:18:10,990 --> 00:18:13,990
everyone what they wanted we went away

00:18:12,400 --> 00:18:15,370
we wrote it we came back and said is

00:18:13,990 --> 00:18:18,120
this what you want and we heard nothing

00:18:15,370 --> 00:18:21,429
because no one was interested

00:18:18,120 --> 00:18:23,320
we took a reset we went back and this

00:18:21,429 --> 00:18:25,480
completely changed the process so now

00:18:23,320 --> 00:18:28,720
instead of being proprietary we're using

00:18:25,480 --> 00:18:30,700
a Creative Commons license by us a so

00:18:28,720 --> 00:18:33,429
anybody can is welcome to contribute

00:18:30,700 --> 00:18:35,860
were drafting and hosting the project on

00:18:33,429 --> 00:18:37,600
github all of our conversations our

00:18:35,860 --> 00:18:40,240
mailing list it looks like a regular

00:18:37,600 --> 00:18:42,220
open source project anyone can

00:18:40,240 --> 00:18:45,390
participate there's no dock you there's

00:18:42,220 --> 00:18:47,679
no contributor agreement for using a DCO

00:18:45,390 --> 00:18:51,220
developer certificate of origin same as

00:18:47,679 --> 00:18:53,169
the Linux kernel process and the

00:18:51,220 --> 00:18:55,299
document is written in restructured text

00:18:53,169 --> 00:18:56,799
so if you don't fertile us kernel

00:18:55,299 --> 00:18:58,179
hackers we can actually go and just

00:18:56,799 --> 00:19:01,990
write a patch if we don't like what the

00:18:58,179 --> 00:19:04,000
spec says and then finally it was

00:19:01,990 --> 00:19:07,419
architecture independent so while this

00:19:04,000 --> 00:19:09,700
is hosted by arm and our primary the

00:19:07,419 --> 00:19:12,070
primary driver right now is supporting

00:19:09,700 --> 00:19:15,700
arm platforms it's open to any

00:19:12,070 --> 00:19:17,380
architectures we've had risk 5 be

00:19:15,700 --> 00:19:21,130
interested and have been in some of the

00:19:17,380 --> 00:19:23,080
conversations and there's been questions

00:19:21,130 --> 00:19:25,750
from other architectures so anybody who

00:19:23,080 --> 00:19:27,280
wants to submit contribute support for

00:19:25,750 --> 00:19:29,700
another architecture to the document and

00:19:27,280 --> 00:19:32,289
be able to have architecture specific

00:19:29,700 --> 00:19:37,600
requirements in they're more than

00:19:32,289 --> 00:19:39,970
welcome to join this project it's also

00:19:37,600 --> 00:19:41,919
implementation independent I went on a

00:19:39,970 --> 00:19:42,610
long time about we did this with you

00:19:41,919 --> 00:19:43,960
boot butt

00:19:42,610 --> 00:19:47,440
thing in the document actually says you

00:19:43,960 --> 00:19:50,320
boot the the the spec has been written

00:19:47,440 --> 00:19:51,730
with you boot in mind right so it's it's

00:19:50,320 --> 00:19:53,200
the we know we've got all these

00:19:51,730 --> 00:19:55,450
platforms we've know we've got all these

00:19:53,200 --> 00:19:56,860
platforms with you boot we know we've

00:19:55,450 --> 00:19:58,990
got an upstream you a project with

00:19:56,860 --> 00:20:00,880
features that we need this talk to it

00:19:58,990 --> 00:20:02,320
says if you're doing if you're doing you

00:20:00,880 --> 00:20:04,390
blues everything that's in this document

00:20:02,320 --> 00:20:05,830
you can do it's already there in fact

00:20:04,390 --> 00:20:08,440
it's not a hard left as long as you can

00:20:05,830 --> 00:20:09,790
get up to main line or close to main

00:20:08,440 --> 00:20:15,220
line you've got just about everything

00:20:09,790 --> 00:20:16,929
that you need it's so it's possible to

00:20:15,220 --> 00:20:19,870
implement this with you boot and also

00:20:16,929 --> 00:20:24,240
with Tiano core which is UEFI the UEFI

00:20:19,870 --> 00:20:27,040
specs reference implementation it's also

00:20:24,240 --> 00:20:29,140
UEFI and this is where I get a lot of

00:20:27,040 --> 00:20:32,130
questions of weight for doing UEFI

00:20:29,140 --> 00:20:34,840
that's that big bloated PC stuff right

00:20:32,130 --> 00:20:37,809
no I need to be very very clear on this

00:20:34,840 --> 00:20:40,240
one UEFI is as a specification for

00:20:37,809 --> 00:20:42,220
firmware interface and it provides it's

00:20:40,240 --> 00:20:44,200
it's a big spec there's a lot of stuff

00:20:42,220 --> 00:20:45,700
in there there's a lot of hardware

00:20:44,200 --> 00:20:49,000
specific things in there but it's just a

00:20:45,700 --> 00:20:51,520
specification and it defines an ABI for

00:20:49,000 --> 00:20:53,740
how applications can be running at boot

00:20:51,520 --> 00:20:55,360
time how to hand off to an operating

00:20:53,740 --> 00:20:57,429
system and how to provide some very

00:20:55,360 --> 00:21:00,010
minimal services while the operating

00:20:57,429 --> 00:21:00,730
system is running this is easily

00:21:00,010 --> 00:21:03,429
implementable

00:21:00,730 --> 00:21:05,650
in well I say easily I can say easily

00:21:03,429 --> 00:21:08,080
because I didn't write the code ask Alex

00:21:05,650 --> 00:21:12,190
graph over here oh ah how how easy the

00:21:08,080 --> 00:21:14,380
the process has been it's so it

00:21:12,190 --> 00:21:16,630
implements the where we're choosing the

00:21:14,380 --> 00:21:18,490
UEFI ABI because it's a standard because

00:21:16,630 --> 00:21:21,730
it's what's already used in the in the

00:21:18,490 --> 00:21:23,380
PC space it isn't costly it's not

00:21:21,730 --> 00:21:26,559
expensive it doesn't add a whole lot of

00:21:23,380 --> 00:21:27,730
bloat to your to your firmware and it

00:21:26,559 --> 00:21:29,980
means that you now have an interface

00:21:27,730 --> 00:21:32,860
that the the distros can actually use it

00:21:29,980 --> 00:21:35,380
also defines behavior which means when

00:21:32,860 --> 00:21:37,780
you have an image rather than each has

00:21:35,380 --> 00:21:40,870
each board saying well I like my image

00:21:37,780 --> 00:21:44,650
on this partition of my SD card or my

00:21:40,870 --> 00:21:46,510
emmc it defines a predictable process

00:21:44,650 --> 00:21:50,290
for how you actually boot how you

00:21:46,510 --> 00:21:53,080
actually change go from an image on an

00:21:50,290 --> 00:21:54,730
SD card or a USB or off the network to

00:21:53,080 --> 00:21:56,530
something that can be executed without

00:21:54,730 --> 00:22:01,630
that application having to

00:21:56,530 --> 00:22:02,950
ahead of time what you're booting on the

00:22:01,630 --> 00:22:06,130
document also contains a bunch of

00:22:02,950 --> 00:22:09,340
additional architecture guidance such as

00:22:06,130 --> 00:22:11,860
zero on air 64 for example we specify

00:22:09,340 --> 00:22:14,920
PSC I and what PSC I is it's just

00:22:11,860 --> 00:22:17,670
another interface to instead of having

00:22:14,920 --> 00:22:21,430
to do board specific or SOC specific

00:22:17,670 --> 00:22:23,530
features to power control your CPUs PSC

00:22:21,430 --> 00:22:27,220
I defines that interface and we will as

00:22:23,530 --> 00:22:29,350
your ebbr will add more more specs as

00:22:27,220 --> 00:22:31,180
they become relevant to the platform the

00:22:29,350 --> 00:22:32,650
I deal with ebbr is that the first

00:22:31,180 --> 00:22:34,210
release of it is going to be kind of a

00:22:32,650 --> 00:22:36,640
baseline of how you would boot and then

00:22:34,210 --> 00:22:38,260
as we go forward it will evolve and

00:22:36,640 --> 00:22:41,460
bring in more standards as those

00:22:38,260 --> 00:22:45,460
standards and the implementations evolve

00:22:41,460 --> 00:22:47,100
and finally its accounts for the

00:22:45,460 --> 00:22:49,630
constraints that we had embedded systems

00:22:47,100 --> 00:22:51,970
pcs have a very specific view of the

00:22:49,630 --> 00:22:53,530
world they assume that you have firmware

00:22:51,970 --> 00:22:55,360
and you have your operating system

00:22:53,530 --> 00:22:57,720
firmware lives on the baseboard your

00:22:55,360 --> 00:23:00,970
operating system lives on the m'aimes on

00:22:57,720 --> 00:23:04,600
your MDOT - or on your hard disk or on

00:23:00,970 --> 00:23:06,220
your USB stick we don't have that idea

00:23:04,600 --> 00:23:08,380
quite often we've got an emmc device

00:23:06,220 --> 00:23:11,260
everything's on that same device or we

00:23:08,380 --> 00:23:13,480
have a NAND flash and we have to have to

00:23:11,260 --> 00:23:15,610
deal with firmware and the operating

00:23:13,480 --> 00:23:19,120
system resident on the same device this

00:23:15,610 --> 00:23:21,760
causes problems in the PC world it

00:23:19,120 --> 00:23:25,090
assumes that the firmware can actually

00:23:21,760 --> 00:23:27,400
provide runtime services can provide the

00:23:25,090 --> 00:23:28,720
ability to update variables because

00:23:27,400 --> 00:23:30,490
that's on a different device firmware

00:23:28,720 --> 00:23:34,420
can just go talk to that device well if

00:23:30,490 --> 00:23:36,400
your storage devices emmc your firmware

00:23:34,420 --> 00:23:37,780
if you call into a runtime service with

00:23:36,400 --> 00:23:41,530
firmware firmware can't go touch your

00:23:37,780 --> 00:23:43,300
emmc because the MSE is the Linux is

00:23:41,530 --> 00:23:44,710
using it it's SCOTUS file system on

00:23:43,300 --> 00:23:46,420
there so if you start creating

00:23:44,710 --> 00:23:49,170
transactions there you're going to have

00:23:46,420 --> 00:23:51,940
corruption you're going to have problems

00:23:49,170 --> 00:23:54,250
we need to account for that in embedded

00:23:51,940 --> 00:23:57,820
and there's guidance that's going into

00:23:54,250 --> 00:24:01,750
ebbr on how you do that or in this case

00:23:57,820 --> 00:24:05,440
is we have a spec change on UEFI that's

00:24:01,750 --> 00:24:07,420
pending that allows us to move to those

00:24:05,440 --> 00:24:08,930
runtime services just return not

00:24:07,420 --> 00:24:10,340
implemented

00:24:08,930 --> 00:24:12,350
and then we've got to move there's

00:24:10,340 --> 00:24:13,850
another mechanism that's being talked

00:24:12,350 --> 00:24:15,530
about on how you do variable updates

00:24:13,850 --> 00:24:17,600
which is actually the most important

00:24:15,530 --> 00:24:19,400
part of runtime services of if you're

00:24:17,600 --> 00:24:20,990
doing an operating system and you need

00:24:19,400 --> 00:24:23,180
to change the boot flow the way you do

00:24:20,990 --> 00:24:24,620
that is variables if you can't do that

00:24:23,180 --> 00:24:27,200
with runtime services we need another

00:24:24,620 --> 00:24:29,510
mechanism and ebbr has talked so with

00:24:27,200 --> 00:24:31,400
that and then it also talks about just

00:24:29,510 --> 00:24:33,170
the just the mechanics of sharing

00:24:31,400 --> 00:24:34,550
firmware between firmware and the

00:24:33,170 --> 00:24:36,020
operating system between the same device

00:24:34,550 --> 00:24:38,420
so that the operating system doesn't

00:24:36,020 --> 00:24:39,590
come along and just go erase all of your

00:24:38,420 --> 00:24:43,280
firmware and then suddenly you're not

00:24:39,590 --> 00:24:46,280
moving anymore how am i doing on time

00:24:43,280 --> 00:24:48,500
I'm not too bad so the project's hosted

00:24:46,280 --> 00:24:50,330
on github there's a regular maydel main

00:24:48,500 --> 00:24:53,540
unless hosted by Lennar oh we have a

00:24:50,330 --> 00:24:55,040
weekly conference call it's as I already

00:24:53,540 --> 00:25:01,130
talked about it being an open source

00:24:55,040 --> 00:25:03,500
project current release is we've got

00:25:01,130 --> 00:25:05,150
seven pre-release which is available if

00:25:03,500 --> 00:25:08,060
you in fact just go to github arm

00:25:05,150 --> 00:25:12,170
software ebbr into the releases page and

00:25:08,060 --> 00:25:14,960
you'll find the PDF go read it provide

00:25:12,170 --> 00:25:16,790
comments to the to the mailing list or

00:25:14,960 --> 00:25:18,050
you know come find one of us who's

00:25:16,790 --> 00:25:19,730
worked on it so some of the folks who

00:25:18,050 --> 00:25:27,610
have worked on it we've got Alex graph

00:25:19,730 --> 00:25:30,110
over here Daniel sorry Daniel Thompson

00:25:27,610 --> 00:25:33,170
who in the room has worked on ebbr

00:25:30,110 --> 00:25:34,760
because I just can't see everyone we've

00:25:33,170 --> 00:25:36,110
just got Alex and Daniel at the moment

00:25:34,760 --> 00:25:37,970
but there's a committee we've got

00:25:36,110 --> 00:25:40,520
silicon vendors in the room we've got

00:25:37,970 --> 00:25:42,640
the distro benders so Sousa and Red Hat

00:25:40,520 --> 00:25:47,960
have been involved

00:25:42,640 --> 00:25:49,820
we've got Rob or sorry Tom Rainey that

00:25:47,960 --> 00:25:51,800
you and maintainer has been involved so

00:25:49,820 --> 00:25:53,150
any of those folks you can see the who's

00:25:51,800 --> 00:25:54,280
been involved in he'll go and ask them

00:25:53,150 --> 00:25:57,290
questions

00:25:54,280 --> 00:26:00,230
we want to release a 1.0 as a baseline

00:25:57,290 --> 00:26:02,300
in in December and by that time we

00:26:00,230 --> 00:26:04,850
expect everything that's in ebbr

00:26:02,300 --> 00:26:06,110
is also implemented in new boot so if

00:26:04,850 --> 00:26:09,890
you're up-to-date you should be able to

00:26:06,110 --> 00:26:12,590
bring a platform Owen FreeBSD boots on

00:26:09,890 --> 00:26:15,260
it that was a nice surprise when FreeBSD

00:26:12,590 --> 00:26:18,380
suddenly showed up at Lenara Connect a

00:26:15,260 --> 00:26:19,940
few weeks ago and booted it worked on

00:26:18,380 --> 00:26:25,430
some of our

00:26:19,940 --> 00:26:26,930
initial platforms in the version 1.0

00:26:25,430 --> 00:26:28,880
it's going to include airs three two and

00:26:26,930 --> 00:26:30,110
a r64 unless someone comes along with

00:26:28,880 --> 00:26:32,720
another architecture we could put in

00:26:30,110 --> 00:26:34,220
there well of the basic UEFI ABI we'll

00:26:32,720 --> 00:26:36,500
have the hardware description platform

00:26:34,220 --> 00:26:38,690
it required to be provided by the

00:26:36,500 --> 00:26:40,760
platform either device tree or a CPI

00:26:38,690 --> 00:26:44,870
this is a bit controversial but the

00:26:40,760 --> 00:26:47,870
intent here is ebbr includes everything

00:26:44,870 --> 00:26:49,550
on the server platforms right Linux

00:26:47,870 --> 00:26:51,350
supports both a CPI and device tree as

00:26:49,550 --> 00:26:54,500
long as you supply one of them and the

00:26:51,350 --> 00:26:57,380
mainline kernel can boot you're good

00:26:54,500 --> 00:27:00,020
I've shared storage guidance there's PS

00:26:57,380 --> 00:27:03,230
CI runtime services and some exceptions

00:27:00,020 --> 00:27:04,790
to the UEFI spec we have Peter Jones

00:27:03,230 --> 00:27:06,830
from Red Hat has been involved as well

00:27:04,790 --> 00:27:09,140
and he's been talking to the UEFI spec

00:27:06,830 --> 00:27:11,170
so we don't want a lot of exceptions but

00:27:09,140 --> 00:27:13,490
we can put them in if we need them and

00:27:11,170 --> 00:27:14,780
then after 1.0 we're going to start

00:27:13,490 --> 00:27:15,950
looking at the more complicated issues

00:27:14,780 --> 00:27:17,000
we're going to talk about secure boot

00:27:15,950 --> 00:27:19,160
we're going to talk about capsule

00:27:17,000 --> 00:27:22,130
updates other embedded use cases such as

00:27:19,160 --> 00:27:26,540
a B updates the better UEFI compliance

00:27:22,130 --> 00:27:28,580
and that is e PBR thank you questions

00:27:26,540 --> 00:27:31,810
there's microphones on either side of

00:27:28,580 --> 00:27:31,810
the stage if you have a question

00:27:35,890 --> 00:27:39,039
[Music]

00:27:41,799 --> 00:27:43,860
Oh

00:27:48,690 --> 00:27:55,480
hello I have a specifically used case

00:27:52,210 --> 00:27:59,110
that for a project we have requirement

00:27:55,480 --> 00:28:03,280
of fast booting we're in a hybrid the

00:27:59,110 --> 00:28:07,270
multiprocessor we had cortex ARM Cortex

00:28:03,280 --> 00:28:09,880
something and a DSP in the same SOC so

00:28:07,270 --> 00:28:13,830
for the first booting we use it the DSP

00:28:09,880 --> 00:28:17,860
offload to the DSB the root filesystem

00:28:13,830 --> 00:28:21,610
loading yeah is there something that you

00:28:17,860 --> 00:28:27,820
are thinking having in this standard as

00:28:21,610 --> 00:28:30,040
well it's for fast booting I mean it

00:28:27,820 --> 00:28:32,980
depends on whether or not you boot as it

00:28:30,040 --> 00:28:34,990
is is fast enough for you if you were

00:28:32,980 --> 00:28:38,050
able to turn off most of your drivers in

00:28:34,990 --> 00:28:40,690
you boot and get get to loading the OS

00:28:38,050 --> 00:28:43,540
then it helps you there because you can

00:28:40,690 --> 00:28:46,240
the the view if I ABI doesn't really add

00:28:43,540 --> 00:28:47,710
any any significant time so you'd still

00:28:46,240 --> 00:28:50,800
be able to do the fast but if you needed

00:28:47,710 --> 00:28:54,180
to do something custom you could do an

00:28:50,800 --> 00:28:57,490
application that uses the UEFI API which

00:28:54,180 --> 00:28:59,320
gives you you're having a standard API

00:28:57,490 --> 00:29:03,960
but also gives you access to networking

00:28:59,320 --> 00:29:06,700
and block block storage USB any of the

00:29:03,960 --> 00:29:08,530
drivers tax that are within within new

00:29:06,700 --> 00:29:10,030
boot so you'd be able to use that you'd

00:29:08,530 --> 00:29:13,180
still need to do platform specific stuff

00:29:10,030 --> 00:29:16,270
you can always do for your custom plat

00:29:13,180 --> 00:29:18,550
for your platform to say the fast path

00:29:16,270 --> 00:29:20,320
is I'm gonna just go and I'm gonna call

00:29:18,550 --> 00:29:22,840
gonna move straight through to this one

00:29:20,320 --> 00:29:24,460
that I know is there but if I had an

00:29:22,840 --> 00:29:25,900
exception then I'll take the slow path

00:29:24,460 --> 00:29:28,030
and I'll go through an update and I'll

00:29:25,900 --> 00:29:30,040
look for boots sources that are in

00:29:28,030 --> 00:29:34,000
another direction so the standard gives

00:29:30,040 --> 00:29:36,340
you a a common behavior but you're

00:29:34,000 --> 00:29:38,620
always able to do for for my case I will

00:29:36,340 --> 00:29:39,970
go and do a custom behavior for this

00:29:38,620 --> 00:29:45,330
platform and then fall back to the

00:29:39,970 --> 00:29:45,330
common behavior other questions

00:29:47,590 --> 00:29:52,100
so while working in the automotive and

00:29:50,360 --> 00:29:54,080
Metis space how most of the requirements

00:29:52,100 --> 00:29:56,360
that we get through from our customers

00:29:54,080 --> 00:29:59,030
at the moment or focus very heavily on

00:29:56,360 --> 00:30:00,560
security for example my Vita yes things

00:29:59,030 --> 00:30:02,690
now I think you've got that as your

00:30:00,560 --> 00:30:04,130
first point on your next steps yes this

00:30:02,690 --> 00:30:05,390
is something you haven't looked at yet

00:30:04,130 --> 00:30:06,830
or just knew you'd in the back of your

00:30:05,390 --> 00:30:10,430
mind you haven't addressed properly yet

00:30:06,830 --> 00:30:12,350
yes we've talked about a little bit we

00:30:10,430 --> 00:30:13,760
haven't put any significant effort into

00:30:12,350 --> 00:30:18,920
it because we need to get the baseline

00:30:13,760 --> 00:30:21,950
out yes none of the features that we are

00:30:18,920 --> 00:30:24,140
I don't think any of the features for

00:30:21,950 --> 00:30:27,500
you if I secure boot are implemented in

00:30:24,140 --> 00:30:31,550
you boot yet Alex can talk more

00:30:27,500 --> 00:30:34,760
intelligently on that so the main reason

00:30:31,550 --> 00:30:37,250
we don't have secured in 100 is simply

00:30:34,760 --> 00:30:39,770
as grant said we don't want to run

00:30:37,250 --> 00:30:42,110
before we walk we want to boot first and

00:30:39,770 --> 00:30:43,960
have something that has a baseline and

00:30:42,110 --> 00:30:46,190
then work on unsecured things on top

00:30:43,960 --> 00:30:47,690
because that is it another completely

00:30:46,190 --> 00:30:50,390
different future standardized on me you

00:30:47,690 --> 00:30:52,100
want to ideally follow the UEFI way of

00:30:50,390 --> 00:30:54,230
secure boot as much as we can just to be

00:30:52,100 --> 00:30:56,660
compatible if that doesn't fit

00:30:54,230 --> 00:30:59,360
requirements like if you see that the

00:30:56,660 --> 00:31:00,710
the UEFI secure boot way is insufficient

00:30:59,360 --> 00:31:02,330
for the automotive use case we would

00:31:00,710 --> 00:31:07,580
love to just get that feedback it's

00:31:02,330 --> 00:31:09,650
really we are a community driven spec as

00:31:07,580 --> 00:31:11,240
far as implantation goes there actually

00:31:09,650 --> 00:31:13,580
is a company right now implementing

00:31:11,240 --> 00:31:16,100
secure boot using UEFI the so hold the

00:31:13,580 --> 00:31:17,420
whole UEFI secure would flow in you boot

00:31:16,100 --> 00:31:19,700
and that's gonna come in the next couple

00:31:17,420 --> 00:31:21,610
month I think I think yeah so it's it's

00:31:19,700 --> 00:31:24,320
working progress it just isn't there yet

00:31:21,610 --> 00:31:26,540
it's it's also one of the one of the

00:31:24,320 --> 00:31:29,060
reasons why we've been what we want to

00:31:26,540 --> 00:31:31,070
have an EVP are because we want to use

00:31:29,060 --> 00:31:34,520
you know there's already processes for

00:31:31,070 --> 00:31:36,380
doing security that we want to be able

00:31:34,520 --> 00:31:39,800
to use the same things that are working

00:31:36,380 --> 00:31:43,220
on the PC secure boot as on as on the

00:31:39,800 --> 00:31:45,920
embedded platforms corner so then just

00:31:43,220 --> 00:31:49,100
been reading through the PDF and yes

00:31:45,920 --> 00:31:51,260
well-written and clear but for lazy

00:31:49,100 --> 00:31:53,690
people is there a platform you can point

00:31:51,260 --> 00:31:57,140
to that say it's implementing or just

00:31:53,690 --> 00:31:58,680
say used to get you would master used to

00:31:57,140 --> 00:32:02,190
comment destroy infrastructure and

00:31:58,680 --> 00:32:05,190
enable you find your done Raspberry Pi

00:32:02,190 --> 00:32:07,010
works quite well we've got we'll have a

00:32:05,190 --> 00:32:09,300
bunch of demos at the tech showcase

00:32:07,010 --> 00:32:14,790
later which you know hopefully they'll

00:32:09,300 --> 00:32:19,350
work so Raspberry Pi works well ultra 96

00:32:14,790 --> 00:32:20,730
works well the macchiato Ben I'm just

00:32:19,350 --> 00:32:22,530
thinking of once off the table there are

00:32:20,730 --> 00:32:26,160
a number of platforms that work

00:32:22,530 --> 00:32:27,780
reasonably well were hitting you know in

00:32:26,160 --> 00:32:31,110
fact one of the things that I've wanted

00:32:27,780 --> 00:32:32,520
to bring up her to do is try to do some

00:32:31,110 --> 00:32:34,110
kind of plugfest and start actually

00:32:32,520 --> 00:32:35,490
testing these things because they work

00:32:34,110 --> 00:32:37,260
the functionality is there but we need

00:32:35,490 --> 00:32:38,520
to do a bunch of testing Raspberry Pi is

00:32:37,260 --> 00:32:41,310
a good place to start

00:32:38,520 --> 00:32:43,890
there's also going to be a qmu model

00:32:41,310 --> 00:32:46,770
basically a can Daniel Daniel Stone has

00:32:43,890 --> 00:32:48,570
been pulling that together or organizing

00:32:46,770 --> 00:32:50,550
that so that you'll just be able to

00:32:48,570 --> 00:32:53,820
bring it up in qmu and see the flow and

00:32:50,550 --> 00:32:55,290
how that all works hope to have that by

00:32:53,820 --> 00:32:57,810
the time they've got a 1.0 release as

00:32:55,290 --> 00:32:59,760
well get the people working on the am

00:32:57,810 --> 00:33:02,550
logic gilbert port mainlining said they

00:32:59,760 --> 00:33:06,030
want to support ebbr and yes they think

00:33:02,550 --> 00:33:09,360
they turned on all the right options but

00:33:06,030 --> 00:33:11,730
they were still a bit unsure how to test

00:33:09,360 --> 00:33:13,620
actual compliance yeah we don't have

00:33:11,730 --> 00:33:14,790
compliance tests yet that if that is the

00:33:13,620 --> 00:33:18,060
missing piece there's a bunch of work

00:33:14,790 --> 00:33:21,840
going on right now that Susie is doing

00:33:18,060 --> 00:33:25,620
on STC or sorry SCT which is the UEFI

00:33:21,840 --> 00:33:28,020
self certification test we're able to

00:33:25,620 --> 00:33:30,120
you boot is currently able to run the

00:33:28,020 --> 00:33:31,680
SCT and tell you a whole bunch of

00:33:30,120 --> 00:33:33,180
failures but that's better than not

00:33:31,680 --> 00:33:35,760
running the SCT at all

00:33:33,180 --> 00:33:38,520
there's once we've got some useful

00:33:35,760 --> 00:33:43,950
results out of SCT that's probably going

00:33:38,520 --> 00:33:45,450
to be our compliance platform so so to

00:33:43,950 --> 00:33:48,990
answer that question really really

00:33:45,450 --> 00:33:51,210
quickly if you are you would based your

00:33:48,990 --> 00:33:53,090
main line your device tree in you boot

00:33:51,210 --> 00:33:55,050
the one that you boo consumes is

00:33:53,090 --> 00:33:56,520
compatible with mainline Linux and

00:33:55,050 --> 00:33:59,190
actually contains all the same node so

00:33:56,520 --> 00:34:02,070
you don't rip out things you enable this

00:33:59,190 --> 00:34:05,100
tribute and you enable the distribute

00:34:02,070 --> 00:34:06,300
and and you don't expel anything like

00:34:05,100 --> 00:34:07,380
you disable efi then you're obviously

00:34:06,300 --> 00:34:08,669
not compliant anymore

00:34:07,380 --> 00:34:10,380
but if you don't expect me to save

00:34:08,669 --> 00:34:11,750
anything automatically everything will

00:34:10,380 --> 00:34:14,090
just happen to be BR

00:34:11,750 --> 00:34:15,349
so if you don't do anything weird you

00:34:14,090 --> 00:34:21,230
basically are compliant whether you

00:34:15,349 --> 00:34:23,330
would platform today yep how we do so I

00:34:21,230 --> 00:34:26,270
guess the reality for us is we tend to

00:34:23,330 --> 00:34:28,310
go over bootloader SOC provider it

00:34:26,270 --> 00:34:29,840
shipping as part of their SDK yes I'm

00:34:28,310 --> 00:34:32,480
just wondering how long you think it be

00:34:29,840 --> 00:34:33,830
before broke on say no we don't want you

00:34:32,480 --> 00:34:36,020
doing bolt anymore

00:34:33,830 --> 00:34:39,379
EB BR is what we're gonna be supporting

00:34:36,020 --> 00:34:42,740
in the future that's a hard question

00:34:39,379 --> 00:34:46,369
simply because that depends on vendors

00:34:42,740 --> 00:34:48,169
SDK release cycles any board that's

00:34:46,369 --> 00:34:50,780
currently support in you boot mainline

00:34:48,169 --> 00:34:54,889
of course here you can immediately go

00:34:50,780 --> 00:34:56,389
and say I'll just use that I can't say

00:34:54,889 --> 00:34:58,640
what the timeline is going to be on the

00:34:56,389 --> 00:35:01,520
vendors but I think that the the distros

00:34:58,640 --> 00:35:03,109
are going to start saying look you got

00:35:01,520 --> 00:35:05,359
to do this or we're not going to support

00:35:03,109 --> 00:35:11,170
you so if a vendor wants to be sort of

00:35:05,359 --> 00:35:13,940
ported by Debian RedHat souza Ubuntu

00:35:11,170 --> 00:35:15,230
FreeBSD I think that's going to start

00:35:13,940 --> 00:35:18,650
becoming a requirement probably in the

00:35:15,230 --> 00:35:20,630
next year ish ish depending on the

00:35:18,650 --> 00:35:22,670
distro so yeah so you definitely talking

00:35:20,630 --> 00:35:24,140
to the distros I mean these are you

00:35:22,670 --> 00:35:26,900
talking to this OC vendors as well

00:35:24,140 --> 00:35:33,380
tonight's involves welcome st is

00:35:26,900 --> 00:35:41,150
involved who else do we have involved as

00:35:33,380 --> 00:35:42,680
a lynx is involved yes so an XP any

00:35:41,150 --> 00:35:45,109
vendors who aren't involved are welcome

00:35:42,680 --> 00:35:48,290
to come and come and join and help out

00:35:45,109 --> 00:35:51,170
okay thank you great any other questions

00:35:48,290 --> 00:35:53,500
I think I've got a good time for a

00:35:51,170 --> 00:35:53,500
couple more

00:35:57,590 --> 00:36:03,690
hello so one of the major requirements

00:36:00,720 --> 00:36:06,690
in my business and regarding to pudding

00:36:03,690 --> 00:36:08,610
is implementing recovery safe food right

00:36:06,690 --> 00:36:10,830
particularly if you think on end devices

00:36:08,610 --> 00:36:13,320
yes like this that's the document

00:36:10,830 --> 00:36:15,000
contains somehow patterns for that or

00:36:13,320 --> 00:36:19,440
doesn't even though that you could

00:36:15,000 --> 00:36:21,270
implement already such things if it the

00:36:19,440 --> 00:36:23,670
document doesn't contain anything about

00:36:21,270 --> 00:36:25,800
reliable about you know reliable fall

00:36:23,670 --> 00:36:27,600
back or that's the kind of situation

00:36:25,800 --> 00:36:29,160
you'd be able to do reliable updates and

00:36:27,600 --> 00:36:30,930
fall backs that's one of the things that

00:36:29,160 --> 00:36:33,090
we're planning to tackle after one point

00:36:30,930 --> 00:36:34,980
oh I don't know if that will be

00:36:33,090 --> 00:36:38,010
something that goes in the spec proper

00:36:34,980 --> 00:36:39,120
or in guidance documentation right

00:36:38,010 --> 00:36:40,620
because there's some interpretation

00:36:39,120 --> 00:36:42,330
document that goes along with that as

00:36:40,620 --> 00:36:44,520
well of you know how you should do

00:36:42,330 --> 00:36:47,700
things everything that's needed to do

00:36:44,520 --> 00:36:50,670
reliable boot or most the stuff is DITA

00:36:47,700 --> 00:36:51,630
is there right so to if you do a be boot

00:36:50,670 --> 00:36:53,310
you would probably have two different

00:36:51,630 --> 00:36:54,870
variables to say this is my primary this

00:36:53,310 --> 00:36:56,550
is my secondary and then you need to

00:36:54,870 --> 00:36:58,560
fall back mechanism to detect when

00:36:56,550 --> 00:37:02,070
you're not when the previous one didn't

00:36:58,560 --> 00:37:04,920
boot and then switch said well that's

00:37:02,070 --> 00:37:07,590
there we don't have guidance on that yet

00:37:04,920 --> 00:37:09,950
and we will need to do that okay any

00:37:07,590 --> 00:37:09,950
other questions

00:37:18,500 --> 00:37:25,680
so I want to build an operating system

00:37:22,650 --> 00:37:28,619
that's the point I'm looking at it and I

00:37:25,680 --> 00:37:32,220
have really bad experiences with secure

00:37:28,619 --> 00:37:39,210
boot from what I've done right so if I

00:37:32,220 --> 00:37:43,769
also I use x86 yes well I was looking at

00:37:39,210 --> 00:37:49,109
the standards and I wonder if I don't

00:37:43,769 --> 00:37:51,180
use secure boot and I use x86 if I try

00:37:49,109 --> 00:37:54,089
to follow the standards to get into a

00:37:51,180 --> 00:37:57,180
more general solution to my system will

00:37:54,089 --> 00:38:03,509
it will it but will it work because I

00:37:57,180 --> 00:38:09,680
just wonder so on x86 well first of all

00:38:03,509 --> 00:38:13,410
for x86 if how should I answer this one

00:38:09,680 --> 00:38:15,569
with secure boot the whether or not

00:38:13,410 --> 00:38:19,740
secure boot is turned on is going to be

00:38:15,569 --> 00:38:23,009
dependent on the platform and so it

00:38:19,740 --> 00:38:25,380
would be the option of the board felt

00:38:23,009 --> 00:38:26,789
like the the board vendor on whether or

00:38:25,380 --> 00:38:27,779
not they turned on secured boot and

00:38:26,789 --> 00:38:30,059
whether or not it was allowed to be

00:38:27,779 --> 00:38:31,559
turned off I think for most for all of

00:38:30,059 --> 00:38:34,619
the development platforms or all the s

00:38:31,559 --> 00:38:37,619
pcs I want to see secure boot enabled

00:38:34,619 --> 00:38:39,720
available available II turned off and

00:38:37,619 --> 00:38:41,190
into setup mode so that the end user

00:38:39,720 --> 00:38:43,380
through well those of us who are

00:38:41,190 --> 00:38:45,329
developing things can actually probably

00:38:43,380 --> 00:38:49,259
miss events most people don't know what

00:38:45,329 --> 00:38:51,299
it is yes it's not that useful for do

00:38:49,259 --> 00:38:52,710
you sort to know oh do you want to curb

00:38:51,299 --> 00:38:52,980
it because most people don't know what

00:38:52,710 --> 00:38:55,710
it is

00:38:52,980 --> 00:38:57,329
right one of the advantages is if it's

00:38:55,710 --> 00:38:59,700
turned on right away then the distros

00:38:57,329 --> 00:39:01,200
can say we've got a secure image it'll

00:38:59,700 --> 00:39:03,329
boot securely you'll know what you're in

00:39:01,200 --> 00:39:05,670
but you can turn it off for when doing

00:39:03,329 --> 00:39:07,710
the custom stuff thank you

00:39:05,670 --> 00:39:09,170
all right Ivan told my time is up so

00:39:07,710 --> 00:39:13,389
thank you very much

00:39:09,170 --> 00:39:13,389

YouTube URL: https://www.youtube.com/watch?v=Zz5wGjY9VpU


