Title: BoF: Embedded Update Tools - Jan L端bbe, Pengutronix
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	BoF: Embedded Update Tools - Jan L端bbe, Pengutronix

 This BoF will start with a quick overview of existing open source update tools and servers. As there are many alternatives by now, the focus of the BoF will be to have an open discussion between users and developers about real-world experiences and unsolved problems.

Some possible topics that could be discussed based on interest:
- Benefits vs. complexity of multiple signatures (TUF)
- Detecting a successful update
- Automated testing of the update process
- Delta-updates for bandwidth-constrained devices (GSM)
- Migration of user data
- Peer to peer update distribution
- ...

Although the submitter is the author of rauc, the intention is to focus on use-cases and not on specific tools. 

About Jan L端bbe
After building Linux smartphones with OpenMoko and deploying open source GSM networks to cruise ships, Jan L端bbe joined Pengutronix in 2012 as a kernel hacker. Since then he helps customers understand Linux and how it can solve their problems. While not hacking Linux, Jan builds atomic clocks at the Stratum 0 hacker space in Brunswick. Previously, he presented at ELCE 2016&2017, FOSDEM, the Linux Days in Chemnitz and the OSADL Networking Days.
Captions: 
	00:00:00,030 --> 00:00:07,379
yeah okay so let's get started I'm young

00:00:04,589 --> 00:00:09,510
liberal from penguia chronics and I'm

00:00:07,379 --> 00:00:11,670
one of the two main developers of rock

00:00:09,510 --> 00:00:13,950
but that should be the topic here

00:00:11,670 --> 00:00:15,929
because I want to talk about update

00:00:13,950 --> 00:00:19,500
tools for embedded systems in general

00:00:15,929 --> 00:00:23,010
and but just I want to talk I want to

00:00:19,500 --> 00:00:26,910
hear from you and I hope we can start a

00:00:23,010 --> 00:00:28,529
nice discussion about the topics that

00:00:26,910 --> 00:00:33,020
have not been solved by the existing

00:00:28,529 --> 00:00:35,910
tools so yeah the existing tools are

00:00:33,020 --> 00:00:38,850
updating tools which should be able to

00:00:35,910 --> 00:00:40,620
update the root filesystem application

00:00:38,850 --> 00:00:43,550
whatever that may be on our method

00:00:40,620 --> 00:00:47,010
systems obviously the kernel device tree

00:00:43,550 --> 00:00:49,500
I've been in it um FS possibly the boot

00:00:47,010 --> 00:00:51,420
loader because even in the field we

00:00:49,500 --> 00:00:54,420
might find problems in the boot loader

00:00:51,420 --> 00:00:57,270
and have to update that some systems can

00:00:54,420 --> 00:01:00,420
do that others don't probably also

00:00:57,270 --> 00:01:03,480
depends on the hardware and additional

00:01:00,420 --> 00:01:09,530
components like firmware for FPGAs CPI

00:01:03,480 --> 00:01:12,200
DS or microcontrollers on our bots so

00:01:09,530 --> 00:01:15,540
what are the basic features all the

00:01:12,200 --> 00:01:19,229
different tools are there already

00:01:15,540 --> 00:01:20,759
supports failsafe upgrade so if the

00:01:19,229 --> 00:01:23,220
system crashes or anything goes wrong

00:01:20,759 --> 00:01:26,790
during the update the system shouldn't

00:01:23,220 --> 00:01:28,829
be damaged you should be able to roll

00:01:26,790 --> 00:01:31,290
back so if you boot into the new system

00:01:28,829 --> 00:01:33,930
and then decide you like the old one

00:01:31,290 --> 00:01:36,299
better should be able to switch to the

00:01:33,930 --> 00:01:38,750
old system again we won't have

00:01:36,299 --> 00:01:43,290
signatures on our updates because

00:01:38,750 --> 00:01:45,180
there's dangerous internet out there so

00:01:43,290 --> 00:01:47,009
we want to make sure that the update

00:01:45,180 --> 00:01:50,220
that are installed are actually produced

00:01:47,009 --> 00:01:52,740
by us compatibility checks to make sure

00:01:50,220 --> 00:01:54,479
that we don't install the wrong update

00:01:52,740 --> 00:01:57,740
on a system and break it that way even

00:01:54,479 --> 00:02:02,549
if it might be signed by the core person

00:01:57,740 --> 00:02:05,070
online an update offline updates are

00:02:02,549 --> 00:02:06,840
basically you you have the update system

00:02:05,070 --> 00:02:08,280
download the update over the internet or

00:02:06,840 --> 00:02:10,410
there are also systems out there which

00:02:08,280 --> 00:02:11,819
have no or very little internet

00:02:10,410 --> 00:02:14,099
connectivity and

00:02:11,819 --> 00:02:15,239
technician who goes there with a USB

00:02:14,099 --> 00:02:19,889
stick or something like that and

00:02:15,239 --> 00:02:23,430
installs an update so the existing tools

00:02:19,889 --> 00:02:26,819
support workflows like that then we need

00:02:23,430 --> 00:02:29,519
some build system integration so what

00:02:26,819 --> 00:02:32,930
have you York tour built route it is

00:02:29,519 --> 00:02:36,510
just whatever builds an update image

00:02:32,930 --> 00:02:39,109
that should be easy and shouldn't be

00:02:36,510 --> 00:02:42,269
something you need to build yourself and

00:02:39,109 --> 00:02:44,939
in the simplest case we want to have an

00:02:42,269 --> 00:02:47,400
a/b mechanism to switch between two

00:02:44,939 --> 00:02:50,400
systems to get this failsafe and

00:02:47,400 --> 00:02:53,549
rollback update there are some

00:02:50,400 --> 00:02:57,090
additional features which not all of

00:02:53,549 --> 00:03:00,620
these systems have or not in an extent

00:02:57,090 --> 00:03:03,829
which I would call finished or complete

00:03:00,620 --> 00:03:06,719
for example encryption of update

00:03:03,829 --> 00:03:08,909
artifacts at rest so you can trance

00:03:06,719 --> 00:03:12,079
transport an USB stick with an update

00:03:08,909 --> 00:03:16,500
image to the system and if it gets lost

00:03:12,079 --> 00:03:18,569
nobody has access to the application

00:03:16,500 --> 00:03:20,159
data which is in the update then you

00:03:18,569 --> 00:03:22,650
have the question where to store that

00:03:20,159 --> 00:03:25,799
key to decrypt the update which is not

00:03:22,650 --> 00:03:28,040
easy to answer and also the topic of

00:03:25,799 --> 00:03:30,209
data updates some of these tools

00:03:28,040 --> 00:03:32,159
supported others don't

00:03:30,209 --> 00:03:37,889
depends on the use cases if that's

00:03:32,159 --> 00:03:41,159
interesting so what have we as open

00:03:37,889 --> 00:03:44,819
source tools to do updates in that sense

00:03:41,159 --> 00:03:47,549
there's SW update by Stefano Babbage

00:03:44,819 --> 00:03:51,540
from Danks which has been around a few

00:03:47,549 --> 00:03:55,259
years there's meander amended IO which

00:03:51,540 --> 00:03:57,659
also includes in the update server more

00:03:55,259 --> 00:04:01,109
focused on on the online update side of

00:03:57,659 --> 00:04:03,870
things there's route which I started

00:04:01,109 --> 00:04:07,789
with a colleague of mine has also been

00:04:03,870 --> 00:04:11,039
around a few years and several artists

00:04:07,789 --> 00:04:12,719
at the end of the slides I have a list

00:04:11,039 --> 00:04:15,659
and some comparisons done by other

00:04:12,719 --> 00:04:18,449
people but we shouldn't focus on the

00:04:15,659 --> 00:04:19,639
individual tools at least in the

00:04:18,449 --> 00:04:21,680
beginning

00:04:19,639 --> 00:04:24,470
and they are also saya dyes tools

00:04:21,680 --> 00:04:27,800
compared to the image based tools I

00:04:24,470 --> 00:04:30,259
mentioned before for example or s3 which

00:04:27,800 --> 00:04:34,129
was started I think by some of the grown

00:04:30,259 --> 00:04:37,099
people who basically treat a complete

00:04:34,129 --> 00:04:39,229
system like a git repository so you can

00:04:37,099 --> 00:04:41,599
check in new versions transmit them over

00:04:39,229 --> 00:04:43,639
the net and install them on others and

00:04:41,599 --> 00:04:44,479
switch between different revisions on

00:04:43,639 --> 00:04:48,889
the same system

00:04:44,479 --> 00:04:51,770
and there's also SW up D from interv I

00:04:48,889 --> 00:04:54,919
think it's used by clear Linux which

00:04:51,770 --> 00:04:57,379
groups different features into bundles

00:04:54,919 --> 00:05:00,740
that can be installed in a file system

00:04:57,379 --> 00:05:05,750
so it's more like Westry in that regard

00:05:00,740 --> 00:05:07,849
so I said I don't want to focus on

00:05:05,750 --> 00:05:10,639
specific tools because then we wouldn't

00:05:07,849 --> 00:05:15,560
get to the interesting topics which have

00:05:10,639 --> 00:05:18,949
not been solved so what is for the

00:05:15,560 --> 00:05:22,009
discussion please talk about generic

00:05:18,949 --> 00:05:26,000
topics and I'd like to focus on image

00:05:22,009 --> 00:05:29,990
based updates or complete file system

00:05:26,000 --> 00:05:35,960
based updates not on systems like Debian

00:05:29,990 --> 00:05:39,169
or IPM or PKG based updates because in

00:05:35,960 --> 00:05:41,449
our experience doing updates on a

00:05:39,169 --> 00:05:42,949
package level it's very difficult to

00:05:41,449 --> 00:05:45,039
test because you have so many

00:05:42,949 --> 00:05:49,039
combinations things that can go wrong

00:05:45,039 --> 00:05:52,129
it's easier to test a defined state of

00:05:49,039 --> 00:05:55,699
the system and then deploy that into the

00:05:52,129 --> 00:05:59,870
field so I just like to focus on full

00:05:55,699 --> 00:06:03,469
system updates and their arses updater

00:05:59,870 --> 00:06:06,289
tools like resin I all for example which

00:06:03,469 --> 00:06:08,569
are mainly mechanism to deploy

00:06:06,289 --> 00:06:11,029
applications in containers on embedded

00:06:08,569 --> 00:06:13,460
systems so that doesn't cover how to

00:06:11,029 --> 00:06:17,060
update the base system itself how to

00:06:13,460 --> 00:06:18,770
update the bootloader so in some cases

00:06:17,060 --> 00:06:22,789
that's interesting but they are

00:06:18,770 --> 00:06:25,759
different tools and different topics to

00:06:22,789 --> 00:06:28,940
solve there so basically what I'm

00:06:25,759 --> 00:06:32,360
looking for are wall stories people who

00:06:28,940 --> 00:06:33,460
have used those tools good experiences

00:06:32,360 --> 00:06:36,920
bad experiences

00:06:33,460 --> 00:06:43,270
missing features where we should spend

00:06:36,920 --> 00:06:47,590
our efforts next and solve problems so

00:06:43,270 --> 00:06:51,560
maybe to get feeling for the audience

00:06:47,590 --> 00:06:55,430
how many of you have developed systems

00:06:51,560 --> 00:07:03,620
with such field update tools and deploy

00:06:55,430 --> 00:07:06,260
them already so maybe half how many of

00:07:03,620 --> 00:07:14,510
you are planning to do that and don't

00:07:06,260 --> 00:07:17,710
have that maybe third ok so at least

00:07:14,510 --> 00:07:22,970
from half of you my expect some answers

00:07:17,710 --> 00:07:24,260
so I've prepared an Atta pad probably

00:07:22,970 --> 00:07:29,120
most of you know how that works

00:07:24,260 --> 00:07:33,650
it's a document you can edit

00:07:29,120 --> 00:07:36,940
interactively so you have the link here

00:07:33,650 --> 00:07:47,570
you can open that on your laptops

00:07:36,940 --> 00:07:52,240
readable again so basically what I said

00:07:47,570 --> 00:07:52,240
already is in that document

00:08:06,830 --> 00:08:14,120
so and I've prepared some topics which I

00:08:11,840 --> 00:08:17,840
think might be interesting to discuss

00:08:14,120 --> 00:08:21,110
here but I actually don't know so I want

00:08:17,840 --> 00:08:23,479
to first collect some additional topics

00:08:21,110 --> 00:08:28,009
and then do a poll which we should

00:08:23,479 --> 00:08:31,460
discuss first so that most people find

00:08:28,009 --> 00:08:33,919
some interesting topics here so we have

00:08:31,460 --> 00:08:36,260
two microphones in the front so please

00:08:33,919 --> 00:08:41,360
if you have something to say come up to

00:08:36,260 --> 00:08:44,750
the microphone so in addition to the

00:08:41,360 --> 00:08:47,390
topics we have here you have any

00:08:44,750 --> 00:08:54,320
additional topics we should put on the

00:08:47,390 --> 00:08:57,040
lists put up to about just just come up

00:08:54,320 --> 00:08:57,040
to look the microphone

00:09:10,760 --> 00:09:26,000
I have it's under related software so no

00:09:20,030 --> 00:09:28,310
additional topics oh it is them more

00:09:26,000 --> 00:09:35,630
interest in in in discussing the basic

00:09:28,310 --> 00:09:40,210
stuff I mentioned under salsals okay

00:09:35,630 --> 00:09:40,210
then let's just go

00:10:30,339 --> 00:10:47,350
an additional topic otherwise yeah just

00:10:37,779 --> 00:10:58,990
come up to the microphone any additional

00:10:47,350 --> 00:11:00,939
ones both both should work I know it is

00:10:58,990 --> 00:11:04,139
complicated to get that's right but I

00:11:00,939 --> 00:11:10,139
was wondering about the encryption of

00:11:04,139 --> 00:11:13,600
the update so I know that yeah I think

00:11:10,139 --> 00:11:16,300
the key key will give it's complicated

00:11:13,600 --> 00:11:19,230
to but somewhere but so that would be

00:11:16,300 --> 00:11:19,230
one question yeah

00:11:22,640 --> 00:11:26,260
no internet just wrong

00:11:30,970 --> 00:11:36,880
so and some people are writing binary

00:11:33,910 --> 00:11:42,070
doof's data updates for bandwidth

00:11:36,880 --> 00:11:43,600
constraint devices and hybrid setups for

00:11:42,070 --> 00:11:52,180
mix requirements reliable system

00:11:43,600 --> 00:11:53,920
partition and something else okay okay

00:11:52,180 --> 00:12:00,700
could we get a fixed battery for that

00:11:53,920 --> 00:12:03,700
one okay so my question is how to in the

00:12:00,700 --> 00:12:05,700
case it cannot do a B updates if you

00:12:03,700 --> 00:12:10,500
just can't you don't have the capacity

00:12:05,700 --> 00:12:10,500
what can you do to mitigate the risks

00:12:22,630 --> 00:12:27,819
so yeah let's go through them collect

00:12:25,630 --> 00:12:29,800
how many people are interested in

00:12:27,819 --> 00:12:34,589
discussing them and just pick up maybe

00:12:29,800 --> 00:12:37,690
three or four most interested topics so

00:12:34,589 --> 00:12:41,399
how to target different markets and

00:12:37,690 --> 00:12:41,399
environments who's interested in that

00:12:42,029 --> 00:13:03,519
five six people encrypted updates ten

00:12:59,459 --> 00:13:08,589
alternatives for ID systems for resource

00:13:03,519 --> 00:13:15,389
constraint systems twenty how to detect

00:13:08,589 --> 00:13:24,540
a successful update twenty again

00:13:15,389 --> 00:13:24,540
migration of user data twenty-five

00:13:25,319 --> 00:13:33,959
generic discussion about missing

00:13:27,699 --> 00:13:37,089
features in the existing tools three

00:13:33,959 --> 00:13:45,490
automated testing of the update process

00:13:37,089 --> 00:13:52,769
itself fifteen base system independent

00:13:45,490 --> 00:13:55,899
or versus the application update eight

00:13:52,769 --> 00:14:06,160
signing with hardware security module or

00:13:55,899 --> 00:14:08,019
crypto tokens three benefits of benefits

00:14:06,160 --> 00:14:10,240
versus complexity of multiple signatures

00:14:08,019 --> 00:14:12,670
so our systems which require many

00:14:10,240 --> 00:14:18,060
signatures before they update can be

00:14:12,670 --> 00:14:21,480
installed like the update framework six

00:14:18,060 --> 00:14:21,480
date updates

00:14:22,510 --> 00:14:34,700
fifteen is basically yeah I'd say that

00:14:29,390 --> 00:14:40,840
that's the same as binary discs updating

00:14:34,700 --> 00:14:42,200
secondary systems or processors ten

00:14:40,840 --> 00:14:44,030
peer-to-peer

00:14:42,200 --> 00:14:46,130
update distribution so if you have a

00:14:44,030 --> 00:14:52,810
network of many systems which is

00:14:46,130 --> 00:15:02,090
connected certain internet slowly to

00:14:52,810 --> 00:15:04,850
atomic bootloader updates fifteen hybrid

00:15:02,090 --> 00:15:06,920
setups reliable system partitions and

00:15:04,850 --> 00:15:11,690
partition for user applications I would

00:15:06,920 --> 00:15:17,780
say that's the same as base system

00:15:11,690 --> 00:15:20,600
versus application updates common format

00:15:17,780 --> 00:15:27,380
for images with manifests for signature

00:15:20,600 --> 00:15:32,500
and dependencies one and ease of

00:15:27,380 --> 00:15:42,710
supporting a new bootloader one as well

00:15:32,500 --> 00:15:48,680
so what have we let's say migration of

00:15:42,710 --> 00:15:56,000
user data twenty five and yeah basically

00:15:48,680 --> 00:15:59,810
start with that so maybe I can start

00:15:56,000 --> 00:16:03,530
with what we've been doing for that for

00:15:59,810 --> 00:16:06,530
our customers basically they all have a

00:16:03,530 --> 00:16:07,940
be systems where the root filesystem and

00:16:06,530 --> 00:16:10,160
the application is stored

00:16:07,940 --> 00:16:12,170
but that's read-only so for the

00:16:10,160 --> 00:16:15,920
application data for configuration data

00:16:12,170 --> 00:16:18,380
like IP addresses used on the network

00:16:15,920 --> 00:16:21,350
interfaces and so on those cannot be

00:16:18,380 --> 00:16:23,900
stored in the root filesystem so the

00:16:21,350 --> 00:16:27,500
obvious solution is to use some third

00:16:23,900 --> 00:16:29,810
partition for this data but then you

00:16:27,500 --> 00:16:31,700
have the question what happens if you

00:16:29,810 --> 00:16:34,920
need to change the format of the data in

00:16:31,700 --> 00:16:36,570
an update so there basically

00:16:34,920 --> 00:16:39,570
a few different approaches you can do

00:16:36,570 --> 00:16:40,680
there just define a format with

00:16:39,570 --> 00:16:44,100
something like Jason where you can a

00:16:40,680 --> 00:16:46,290
dish add addition properties where the

00:16:44,100 --> 00:16:48,959
old system won't be confused on a

00:16:46,290 --> 00:16:52,230
rollback but you might lose the data if

00:16:48,959 --> 00:16:56,699
it if the configuration data is written

00:16:52,230 --> 00:16:59,300
again another approach is to have two

00:16:56,699 --> 00:17:02,880
data partitions which is basically

00:16:59,300 --> 00:17:05,160
copied on an update to the currently

00:17:02,880 --> 00:17:07,740
inactive one and the new system then

00:17:05,160 --> 00:17:09,860
does some data migration like a database

00:17:07,740 --> 00:17:13,470
migration script or something like that

00:17:09,860 --> 00:17:16,860
the advantage is that the you can do

00:17:13,470 --> 00:17:18,600
real migrations of the schema but when

00:17:16,860 --> 00:17:22,410
you fall back you are running with old

00:17:18,600 --> 00:17:25,470
data so you need to have some way in the

00:17:22,410 --> 00:17:26,970
application to maybe switch off or

00:17:25,470 --> 00:17:31,770
disable booting the old system

00:17:26,970 --> 00:17:36,169
completely so yeah I'd be interested in

00:17:31,770 --> 00:17:41,850
how problems like this have been solved

00:17:36,169 --> 00:17:43,799
by other people so I think they've been

00:17:41,850 --> 00:17:46,370
being solved good experiences bad

00:17:43,799 --> 00:17:46,370
experiences

00:17:51,330 --> 00:18:01,200
nobody I didn't expect that I would be a

00:17:54,989 --> 00:18:05,039
solo entertainer here so please come up

00:18:01,200 --> 00:18:07,519
to the microphone and relate your

00:18:05,039 --> 00:18:07,519
experiences

00:18:12,960 --> 00:18:19,020
I actually have more question so how do

00:18:16,289 --> 00:18:21,299
you deal for like things which are

00:18:19,020 --> 00:18:24,090
general open source tools or libraries

00:18:21,299 --> 00:18:26,370
which need some config file in /e TC so

00:18:24,090 --> 00:18:28,320
do you consider slash CTC being data

00:18:26,370 --> 00:18:30,179
always or is that part of the root

00:18:28,320 --> 00:18:33,840
filesystem or how do you deal with that

00:18:30,179 --> 00:18:35,850
I think for the user kind of application

00:18:33,840 --> 00:18:39,299
it's quite clear the user must make sure

00:18:35,850 --> 00:18:41,990
that on an update this application can

00:18:39,299 --> 00:18:45,649
still read the old configuration or the

00:18:41,990 --> 00:18:49,080
application should just kind of yeah

00:18:45,649 --> 00:18:51,510
migrate it but for the rest for root

00:18:49,080 --> 00:18:55,309
file systems or for things which you

00:18:51,510 --> 00:18:59,970
don't control it's a bit harder yeah

00:18:55,309 --> 00:19:02,730
from my experience it's mostly the

00:18:59,970 --> 00:19:06,870
different figuration of system utilities

00:19:02,730 --> 00:19:11,210
like SSH or network manager or host a PD

00:19:06,870 --> 00:19:14,940
or something like that pretty static and

00:19:11,210 --> 00:19:17,730
in many cases it's enough to do some

00:19:14,940 --> 00:19:19,919
templating from data in the

00:19:17,730 --> 00:19:23,700
configuration partition so on boot-up

00:19:19,919 --> 00:19:26,789
you read maybe the IP address or Wi-Fi

00:19:23,700 --> 00:19:29,240
SSID and password from the data

00:19:26,789 --> 00:19:32,159
partition generate configuration files

00:19:29,240 --> 00:19:33,990
at runtime in an overlay file system or

00:19:32,159 --> 00:19:37,529
something like that and then start these

00:19:33,990 --> 00:19:42,029
services the benefit of that is that if

00:19:37,529 --> 00:19:44,460
you move to a new SSH version where you

00:19:42,029 --> 00:19:47,820
need to modify other things which are

00:19:44,460 --> 00:19:50,490
not stored in the configuration not

00:19:47,820 --> 00:19:53,250
modifiable by the user then you just

00:19:50,490 --> 00:19:55,740
change your template and the template is

00:19:53,250 --> 00:19:57,659
also contained in the root filesystem so

00:19:55,740 --> 00:20:03,559
you always can generate a matching

00:19:57,659 --> 00:20:07,940
configuration to the updated software

00:20:03,559 --> 00:20:10,169
and you can also computer copy complete

00:20:07,940 --> 00:20:12,929
contributions in your data partition and

00:20:10,169 --> 00:20:14,820
copy them back on startup okay but then

00:20:12,929 --> 00:20:17,039
you have some kind of ABI between the

00:20:14,820 --> 00:20:21,179
application and those templates that

00:20:17,039 --> 00:20:22,810
thing you kind of replace there or but

00:20:21,179 --> 00:20:27,420
that's I guess that's fine

00:20:22,810 --> 00:20:29,980
yeah there's some tools which have

00:20:27,420 --> 00:20:33,640
schema to generate configuration files

00:20:29,980 --> 00:20:36,150
from our decorative descriptions in JSON

00:20:33,640 --> 00:20:36,150
or something like that

00:20:36,720 --> 00:20:43,390
our Geass lenses I think if you google

00:20:40,420 --> 00:20:45,580
that that might be something to try but

00:20:43,390 --> 00:20:48,310
in most cases we didn't need the

00:20:45,580 --> 00:20:52,120
complexity just templating of static

00:20:48,310 --> 00:20:58,840
values into configuration files for open

00:20:52,120 --> 00:21:01,150
source services so maybe to get also

00:20:58,840 --> 00:21:02,560
some feedback to your question so this

00:21:01,150 --> 00:21:05,940
is essentially also what we are using

00:21:02,560 --> 00:21:10,300
for our application so on the one hand

00:21:05,940 --> 00:21:11,890
we didn't also mainly we didn't want to

00:21:10,300 --> 00:21:14,410
integrate the knowledge how to write

00:21:11,890 --> 00:21:17,350
these configuration files into our

00:21:14,410 --> 00:21:22,870
application so our application writes

00:21:17,350 --> 00:21:26,650
its own little data base so it's just

00:21:22,870 --> 00:21:30,400
text bellend and key value database and

00:21:26,650 --> 00:21:33,610
then we have a small little application

00:21:30,400 --> 00:21:36,520
that bundles that know-how based really

00:21:33,610 --> 00:21:39,370
for that that's a distribution currently

00:21:36,520 --> 00:21:43,270
in there and to generate the

00:21:39,370 --> 00:21:44,890
configuration file so for what and we

00:21:43,270 --> 00:21:48,430
only do that when we shut down the

00:21:44,890 --> 00:21:51,160
system because like by design for our

00:21:48,430 --> 00:21:54,190
application it is desired that the user

00:21:51,160 --> 00:21:57,270
does changes and then they only are

00:21:54,190 --> 00:22:01,780
activated once the system is rebooted

00:21:57,270 --> 00:22:05,680
and maybe also in regards of the topic

00:22:01,780 --> 00:22:08,850
you had in regards of user data so yeah

00:22:05,680 --> 00:22:11,850
we came to the conclusion that because

00:22:08,850 --> 00:22:14,680
our the configuration of our

00:22:11,850 --> 00:22:18,580
complication is really really complex so

00:22:14,680 --> 00:22:21,610
we really made the decision to when you

00:22:18,580 --> 00:22:24,070
install we store that user data in a

00:22:21,610 --> 00:22:27,340
separate partition so if you install an

00:22:24,070 --> 00:22:29,740
update which is compatible to that user

00:22:27,340 --> 00:22:32,710
data it will continue to use that if

00:22:29,740 --> 00:22:36,390
it's not compatible it intentionally

00:22:32,710 --> 00:22:42,150
falls back to a default configuration

00:22:36,390 --> 00:22:45,600
and on top of that is that we then still

00:22:42,150 --> 00:22:47,580
retain these old configurations as long

00:22:45,600 --> 00:22:49,770
as possible so we have like like three

00:22:47,580 --> 00:22:52,620
slots four configurations and if the

00:22:49,770 --> 00:22:55,380
user then decides to let say installs an

00:22:52,620 --> 00:22:58,470
update things maybe not what I wanted

00:22:55,380 --> 00:23:02,190
goes back he still has like the last two

00:22:58,470 --> 00:23:04,650
configurations he can go back that also

00:23:02,190 --> 00:23:08,210
works if you go back to all software

00:23:04,650 --> 00:23:11,840
version yes so it's really like like a

00:23:08,210 --> 00:23:13,830
like like caching the old versions and

00:23:11,840 --> 00:23:17,000
yeah you're not throwing them away

00:23:13,830 --> 00:23:19,260
immediately how do you check if that

00:23:17,000 --> 00:23:20,940
configuration is still compatible to the

00:23:19,260 --> 00:23:23,970
new software that's something your

00:23:20,940 --> 00:23:26,760
update or two tool does okay that is

00:23:23,970 --> 00:23:30,330
then really a manual step the user has

00:23:26,760 --> 00:23:32,669
to do so like an external configuration

00:23:30,330 --> 00:23:35,669
program or you can see okay what is in

00:23:32,669 --> 00:23:37,650
the other slots and say okay yeah based

00:23:35,669 --> 00:23:40,169
on date and some version information kay

00:23:37,650 --> 00:23:40,620
that's where I want to go back to as

00:23:40,169 --> 00:23:45,330
well

00:23:40,620 --> 00:23:47,429
so the also roll that so this is Fitz I

00:23:45,330 --> 00:23:52,250
would say in the image and for our

00:23:47,429 --> 00:23:55,679
application also the updates we have a

00:23:52,250 --> 00:23:59,220
external configuration tool and you use

00:23:55,679 --> 00:24:03,480
that tool for downloading updates to the

00:23:59,220 --> 00:24:05,309
system as well as selecting with which

00:24:03,480 --> 00:24:09,000
configuration do you want to run to so

00:24:05,309 --> 00:24:11,270
it's really like a configuration tool is

00:24:09,000 --> 00:24:15,059
that something you would need from an

00:24:11,270 --> 00:24:18,809
open source updating tool to handle

00:24:15,059 --> 00:24:21,570
these workflows are you losing one yes

00:24:18,809 --> 00:24:26,429
we are using from Stephan all the

00:24:21,570 --> 00:24:31,470
software update and so we are using that

00:24:26,429 --> 00:24:35,220
in a way that we have a proprietary USB

00:24:31,470 --> 00:24:38,549
protocol for going from a Windows PC to

00:24:35,220 --> 00:24:41,309
the embedded Linux system and then the

00:24:38,549 --> 00:24:42,919
data is really pushed blocked by a block

00:24:41,309 --> 00:24:46,950
into a software update and then

00:24:42,919 --> 00:24:49,050
everything goes normal so but no so

00:24:46,950 --> 00:24:50,460
theoretically yes we could do also with

00:24:49,050 --> 00:24:52,560
the software update like

00:24:50,460 --> 00:24:55,080
over-the-air updates and all that fancy

00:24:52,560 --> 00:24:58,470
stuff but in our application for

00:24:55,080 --> 00:25:02,160
regulatory purposes its that is anyhow

00:24:58,470 --> 00:25:04,860
not allowed you have to be at the system

00:25:02,160 --> 00:25:10,850
and you do the update so thus this is

00:25:04,860 --> 00:25:10,850
good for us thank you

00:25:13,090 --> 00:25:19,910
well about the topic stated the the

00:25:16,850 --> 00:25:21,710
internet immigrations if one in one of

00:25:19,910 --> 00:25:24,140
our products we use the strategy of

00:25:21,710 --> 00:25:26,840
moving almost all of the user data to

00:25:24,140 --> 00:25:30,770
the cloud so we only store like a token

00:25:26,840 --> 00:25:33,260
and the network settings on the device

00:25:30,770 --> 00:25:35,270
to connect to the internet and then the

00:25:33,260 --> 00:25:37,520
device if it is not sure what to do what

00:25:35,270 --> 00:25:39,260
the configuration is it can just always

00:25:37,520 --> 00:25:42,140
go to the cloud and check what's the

00:25:39,260 --> 00:25:44,300
show configuration that the user has set

00:25:42,140 --> 00:25:48,290
up on that I understand that this is

00:25:44,300 --> 00:25:51,350
this approach is quite limited based on

00:25:48,290 --> 00:25:53,690
the device purposes but looks but it

00:25:51,350 --> 00:25:55,610
works for us and I don't know maybe if

00:25:53,690 --> 00:25:57,860
your device is like hardly connected I

00:25:55,610 --> 00:26:00,110
mean not hardly but definitely connected

00:25:57,860 --> 00:26:02,030
to the Internet you can use that and as

00:26:00,110 --> 00:26:04,880
a fallback you can always run user

00:26:02,030 --> 00:26:08,750
migrations on the cloud backhand and all

00:26:04,880 --> 00:26:11,500
that so how's it going for you and do

00:26:08,750 --> 00:26:15,770
you have a way to identify the

00:26:11,500 --> 00:26:18,110
individual devices so yes each device

00:26:15,770 --> 00:26:21,110
has a usually token that serves as a

00:26:18,110 --> 00:26:24,710
cryptographically approved access token

00:26:21,110 --> 00:26:27,650
to the backhand and it has no device ID

00:26:24,710 --> 00:26:29,840
we use these IDs to track them in the

00:26:27,650 --> 00:26:33,050
software updates also so we can

00:26:29,840 --> 00:26:34,790
distinguish device ie from device B so

00:26:33,050 --> 00:26:41,120
maybe that helps a lot with the

00:26:34,790 --> 00:26:45,430
dissolution but I'm probably the issue

00:26:41,120 --> 00:26:48,860
as I can see is that in the case of

00:26:45,430 --> 00:26:50,420
back-end outage we have only a local

00:26:48,860 --> 00:26:52,850
cache the configuration and the user

00:26:50,420 --> 00:26:55,030
cannot access the configuration and

00:26:52,850 --> 00:27:02,920
that's the greatest limitation of this

00:26:55,030 --> 00:27:06,530
approach as far as I can see we've got a

00:27:02,920 --> 00:27:09,310
AV system with a user partition this

00:27:06,530 --> 00:27:12,140
type you described and in our case we

00:27:09,310 --> 00:27:15,290
you know after upgrade the first thing

00:27:12,140 --> 00:27:17,480
that run when a new version starts it

00:27:15,290 --> 00:27:18,950
runs a migration script which updates

00:27:17,480 --> 00:27:22,310
the user date if there's been any change

00:27:18,950 --> 00:27:23,630
you can think but the main issue with

00:27:22,310 --> 00:27:25,490
that is of course it prevents a rollback

00:27:23,630 --> 00:27:25,860
effectively and that something we

00:27:25,490 --> 00:27:28,080
haven't

00:27:25,860 --> 00:27:30,090
we haven't we'd like to get to in the

00:27:28,080 --> 00:27:32,490
future I think the other topics you got

00:27:30,090 --> 00:27:34,169
a very texting a successful upgrade and

00:27:32,490 --> 00:27:35,580
obviously if we were to do that we'd

00:27:34,169 --> 00:27:37,289
need a way of rolling back and you've

00:27:35,580 --> 00:27:40,110
only got one way migration together kind

00:27:37,289 --> 00:27:42,210
of prevents that so you know typically

00:27:40,110 --> 00:27:44,490
the actual content of any migration is

00:27:42,210 --> 00:27:46,880
very minor modifications to early a very

00:27:44,490 --> 00:27:49,169
small in profile so I guess it'd be good

00:27:46,880 --> 00:27:49,919
and I don't know of any tools to do this

00:27:49,169 --> 00:27:51,809
but it could have something that would

00:27:49,919 --> 00:27:54,059
just take a snapshot of the file of the

00:27:51,809 --> 00:27:56,610
user changes before you apply the

00:27:54,059 --> 00:27:58,200
migration and then so that you could

00:27:56,610 --> 00:28:02,159
roll them back afterwards I don't have

00:27:58,200 --> 00:28:04,049
any tools I can basically store metadata

00:28:02,159 --> 00:28:06,990
with the snapshot for which older

00:28:04,049 --> 00:28:08,909
version of this configuration applies I

00:28:06,990 --> 00:28:13,889
think that's probably the way we want to

00:28:08,909 --> 00:28:15,990
go but we haven't do we have actual

00:28:13,889 --> 00:28:18,149
problems with that happening and fee

00:28:15,990 --> 00:28:20,580
over it has not yet so far we've not had

00:28:18,149 --> 00:28:21,809
to roll back but I mean in order to make

00:28:20,580 --> 00:28:26,360
the system more robust it would be

00:28:21,809 --> 00:28:29,940
preferable if it was available yeah okay

00:28:26,360 --> 00:28:34,669
so maybe just one more comment and then

00:28:29,940 --> 00:28:38,190
I think we need to go to the next topic

00:28:34,669 --> 00:28:42,899
we are using kind of we have an a/b

00:28:38,190 --> 00:28:45,350
system with a data petition and using

00:28:42,899 --> 00:28:48,210
combination of overlay FS force

00:28:45,350 --> 00:28:50,549
configurations like network addresses

00:28:48,210 --> 00:28:52,200
and network configuration you know on

00:28:50,549 --> 00:28:55,500
the other hand our application updates

00:28:52,200 --> 00:28:58,889
the database on startups that's how we

00:28:55,500 --> 00:29:03,840
do it and you are not doing roll backs

00:28:58,889 --> 00:29:09,690
on that user data we didn't hit to right

00:29:03,840 --> 00:29:11,669
now and there's also not that many but

00:29:09,690 --> 00:29:14,760
now but we have to check later if

00:29:11,669 --> 00:29:21,409
there's some something we need to do

00:29:14,760 --> 00:29:21,409
there to do over backs on that okay

00:29:22,080 --> 00:29:32,490
so the next topic is this one yeah

00:29:33,490 --> 00:29:36,149
so

00:29:38,570 --> 00:29:45,980
alternatives for the two ladies systems

00:29:42,790 --> 00:29:47,570
in general I like a be best because it

00:29:45,980 --> 00:29:51,380
keeps the first system simple you don't

00:29:47,570 --> 00:29:54,410
have a specific role for each slot but

00:29:51,380 --> 00:29:56,750
what we've done and what's supported by

00:29:54,410 --> 00:30:00,050
rock and I think also by SW update is

00:29:56,750 --> 00:30:02,480
that you have a smaller rescue system

00:30:00,050 --> 00:30:06,650
which usually doesn't contain the

00:30:02,480 --> 00:30:08,540
application maybe just corner appended

00:30:06,650 --> 00:30:12,020
in the comm file system which contains

00:30:08,540 --> 00:30:13,670
maybe a web interface in the updater so

00:30:12,020 --> 00:30:19,130
that can be as small as a few megabytes

00:30:13,670 --> 00:30:20,990
and then you can basically if the main

00:30:19,130 --> 00:30:26,510
system fails to start you fall back to

00:30:20,990 --> 00:30:28,400
the updater system and from there the

00:30:26,510 --> 00:30:31,970
user can install up there to recover the

00:30:28,400 --> 00:30:33,950
system the main disadvantage is

00:30:31,970 --> 00:30:36,130
obviously that to install an update you

00:30:33,950 --> 00:30:38,690
must first reboot into the rescue system

00:30:36,130 --> 00:30:42,020
disrupt the normal running application

00:30:38,690 --> 00:30:44,090
and then reboot again to switch back and

00:30:42,020 --> 00:30:47,270
roll back is harder because you don't

00:30:44,090 --> 00:30:50,990
have the old copy anymore but yeah

00:30:47,270 --> 00:30:53,810
that's usually how we do it if we have

00:30:50,990 --> 00:31:01,820
to because the storage space is too

00:30:53,810 --> 00:31:04,820
small with with 'man sees the problem

00:31:01,820 --> 00:31:07,250
doesn't happen that that often anymore

00:31:04,820 --> 00:31:09,770
because you have four gigabytes or eight

00:31:07,250 --> 00:31:12,790
gigabytes of MMC and then it's easy to

00:31:09,770 --> 00:31:12,790
have a B systems

00:31:14,430 --> 00:31:26,990
any more comments to that or did you

00:31:19,620 --> 00:31:32,490
cover that completely another

00:31:26,990 --> 00:31:35,070
interesting alternative if you have many

00:31:32,490 --> 00:31:38,370
systems in a local network and some

00:31:35,070 --> 00:31:40,230
other controlling system in there an

00:31:38,370 --> 00:31:42,840
alternative might be to have the rescue

00:31:40,230 --> 00:31:44,450
system just boot of a network if you

00:31:42,840 --> 00:31:47,250
have enough control over your bootloader

00:31:44,450 --> 00:31:49,440
then you just have an a system on the

00:31:47,250 --> 00:31:52,710
device itself and if that fails to boot

00:31:49,440 --> 00:31:55,650
you go back to TFTP from the controlling

00:31:52,710 --> 00:32:00,090
server and that one can then recover the

00:31:55,650 --> 00:32:02,940
system that's more flexible I think then

00:32:00,090 --> 00:32:06,090
just having a and rescue because then

00:32:02,940 --> 00:32:08,250
you just install a new risk recovery

00:32:06,090 --> 00:32:12,140
mechanism on the server and recover any

00:32:08,250 --> 00:32:12,140
problems you cause on the devices itself

00:32:15,650 --> 00:32:23,580
throw OS tree into the mix there as I as

00:32:20,040 --> 00:32:26,010
an alternative so focused oh sure I work

00:32:23,580 --> 00:32:30,390
on meta data which is OS tree for for

00:32:26,010 --> 00:32:33,600
Yocto but the advantage there is that

00:32:30,390 --> 00:32:36,150
rather than having this fixed three-way

00:32:33,600 --> 00:32:38,220
split between the a and the B and the

00:32:36,150 --> 00:32:40,170
user partition all of that is in one

00:32:38,220 --> 00:32:43,740
file system and then it uses some chroot

00:32:40,170 --> 00:32:47,760
magic and hard links to avoid multiple

00:32:43,740 --> 00:32:50,340
copies of files so if the problem for

00:32:47,760 --> 00:32:53,010
not wanting a B is lack of storage space

00:32:50,340 --> 00:32:56,310
or this need to do a lot front part

00:32:53,010 --> 00:32:59,310
partition there no s3 sort of solves

00:32:56,310 --> 00:33:02,520
that problem and also solves the Delta

00:32:59,310 --> 00:33:03,390
problem a bit later but you need to

00:33:02,520 --> 00:33:08,760
trust your filesystem

00:33:03,390 --> 00:33:11,210
yes so you in all cases you have to

00:33:08,760 --> 00:33:13,920
trust the magic that goes on in emmc

00:33:11,210 --> 00:33:16,890
that does block remapping in this case

00:33:13,920 --> 00:33:21,690
you also have to trust the XT for your

00:33:16,890 --> 00:33:25,590
favorite thing and our suggestion for

00:33:21,690 --> 00:33:27,210
people who wanted to not do that is is

00:33:25,590 --> 00:33:27,700
to go back to your rollback thing so you

00:33:27,210 --> 00:33:30,970
end

00:33:27,700 --> 00:33:34,330
with a small recovery partition which

00:33:30,970 --> 00:33:37,389
will reformat ext4 and grab a new image

00:33:34,330 --> 00:33:39,700
over the network and then assuming you

00:33:37,389 --> 00:33:42,760
trust the ex T's hard against power off

00:33:39,700 --> 00:33:46,860
and corruption then you could use that

00:33:42,760 --> 00:33:46,860
yeah that's a good daughter interview

00:33:50,130 --> 00:33:53,549
okay next one

00:34:02,190 --> 00:34:11,400
detecting a successful update ties back

00:34:06,990 --> 00:34:15,960
into yeah recovery obviously into doing

00:34:11,400 --> 00:34:19,320
migration and it's surprisingly

00:34:15,960 --> 00:34:22,800
difficult to do that well what we've

00:34:19,320 --> 00:34:25,620
been doing so far is just to have system

00:34:22,800 --> 00:34:29,100
service that starts late in the normal

00:34:25,620 --> 00:34:32,900
boot and basically we set the boot

00:34:29,100 --> 00:34:35,070
counter that works reasonably well but

00:34:32,900 --> 00:34:39,080
there's a class of problems you can't

00:34:35,070 --> 00:34:42,240
detect with that for example you have

00:34:39,080 --> 00:34:45,210
you need to have two network connection

00:34:42,240 --> 00:34:47,490
to contact the update server so the new

00:34:45,210 --> 00:34:50,220
system for some reason doesn't have

00:34:47,490 --> 00:34:51,900
working network maybe the DHCP client is

00:34:50,220 --> 00:34:54,120
broken or something like that there's

00:34:51,900 --> 00:34:57,090
just a boot anomaly you mark that as a

00:34:54,120 --> 00:34:59,580
valid boot and you still can't do a

00:34:57,090 --> 00:35:03,150
recovery or you can't connect to the

00:34:59,580 --> 00:35:07,860
system so yeah basically the system is a

00:35:03,150 --> 00:35:11,520
brick there has been some progress on

00:35:07,860 --> 00:35:14,490
the system decides where this I think

00:35:11,520 --> 00:35:17,550
it's in the last few weeks it has been

00:35:14,490 --> 00:35:19,830
merged this mechanism for automatic boot

00:35:17,550 --> 00:35:23,010
assessment basically they added some

00:35:19,830 --> 00:35:26,430
boot targets which allow ordering such

00:35:23,010 --> 00:35:27,990
check services into the boot who can

00:35:26,430 --> 00:35:30,810
just add a system via service which

00:35:27,990 --> 00:35:33,000
checks a specific aspect of your system

00:35:30,810 --> 00:35:35,040
maybe surface of the application a

00:35:33,000 --> 00:35:37,740
network connectivity check and so on and

00:35:35,040 --> 00:35:40,140
you can assemble them as system D

00:35:37,740 --> 00:35:44,730
services in a target and only if all

00:35:40,140 --> 00:35:46,920
those checks we're done correctly the

00:35:44,730 --> 00:35:51,030
system would get marked as a successful

00:35:46,920 --> 00:35:52,650
boot so maybe the system has no network

00:35:51,030 --> 00:35:54,710
the user needs to power cycle the system

00:35:52,650 --> 00:36:00,720
three times and then it switches back

00:35:54,710 --> 00:36:02,190
it's still not perfect but so far I

00:36:00,720 --> 00:36:05,430
don't have any better ideas

00:36:02,190 --> 00:36:09,950
so I'd be interested in anyone who has

00:36:05,430 --> 00:36:09,950
solved that's in a better way

00:36:12,790 --> 00:36:26,600
that's what I feel

00:36:15,170 --> 00:36:29,170
nobody yeah any ideas what we should try

00:36:26,600 --> 00:36:29,170
in that direction

00:36:44,300 --> 00:36:51,710
so so I'm not sure what the exact

00:36:48,770 --> 00:36:54,230
problem is here so because I mean like

00:36:51,710 --> 00:36:57,380
in play go we just ssh to the board and

00:36:54,230 --> 00:36:59,450
if we make connection it's up so is the

00:36:57,380 --> 00:37:01,970
issue that you can't detect that the

00:36:59,450 --> 00:37:05,810
newly installed software is actually

00:37:01,970 --> 00:37:07,810
there versus the rescue or that the

00:37:05,810 --> 00:37:11,180
newly installed software actually works

00:37:07,810 --> 00:37:16,330
correctly or well enough but we don't

00:37:11,180 --> 00:37:19,010
need to fall back okay so many of our

00:37:16,330 --> 00:37:23,720
customers have every constraint testing

00:37:19,010 --> 00:37:25,010
resources so yeah if all our software

00:37:23,720 --> 00:37:27,440
perfect you wouldn't need rollback or

00:37:25,010 --> 00:37:31,900
something like that so okay we need to

00:37:27,440 --> 00:37:34,970
decide when to rollback and obviously a

00:37:31,900 --> 00:37:37,490
kernel crash during boot is easily

00:37:34,970 --> 00:37:40,700
handled by not incrementing the boot

00:37:37,490 --> 00:37:42,680
counter so three kernel crashes later

00:37:40,700 --> 00:37:43,070
you run the old system again but they

00:37:42,680 --> 00:37:45,800
are

00:37:43,070 --> 00:37:48,410
if the update system itself doesn't work

00:37:45,800 --> 00:37:50,210
anymore in the new system or if you had

00:37:48,410 --> 00:37:53,450
access to the system but stup can boot

00:37:50,210 --> 00:37:55,850
correctly when you have a running system

00:37:53,450 --> 00:37:59,090
which you can't use and you can't easily

00:37:55,850 --> 00:38:02,090
recover from so we need have to have

00:37:59,090 --> 00:38:05,300
yeah automated ways to detect that will

00:38:02,090 --> 00:38:07,010
will be project specific probably are

00:38:05,300 --> 00:38:13,070
you looking for some kind of standard

00:38:07,010 --> 00:38:15,470
metric for what constitutes I mean yeah

00:38:13,070 --> 00:38:18,080
the obvious thing is you have network

00:38:15,470 --> 00:38:22,310
access and the updating service daemon

00:38:18,080 --> 00:38:24,770
runs something like right I was hoping

00:38:22,310 --> 00:38:26,510
maybe twice and then if the second one

00:38:24,770 --> 00:38:34,970
works then it the first one was good

00:38:26,510 --> 00:38:36,920
yeah so I don't have really a solution

00:38:34,970 --> 00:38:39,350
but I just wanted to tell you what we

00:38:36,920 --> 00:38:42,980
did so we just ended up having a service

00:38:39,350 --> 00:38:45,650
waiting until system D is ready send

00:38:42,980 --> 00:38:47,090
trying to talk to all services which are

00:38:45,650 --> 00:38:48,710
interesting so we have a list of

00:38:47,090 --> 00:38:51,500
interesting services not interesting

00:38:48,710 --> 00:38:55,070
services trying to get from them what's

00:38:51,500 --> 00:38:57,170
what's their status is and then we open

00:38:55,070 --> 00:39:00,349
the very bad pit or

00:38:57,170 --> 00:39:03,109
of hardware which we depend on so we

00:39:00,349 --> 00:39:05,150
have modems in our hardware and so we

00:39:03,109 --> 00:39:05,869
try to get out of the modem are you

00:39:05,150 --> 00:39:07,819
working

00:39:05,869 --> 00:39:10,400
do we need to update you are you working

00:39:07,819 --> 00:39:14,059
still and we still have no solution to

00:39:10,400 --> 00:39:15,950
end this because we can and we have no

00:39:14,059 --> 00:39:18,410
network connectivity but it's not our

00:39:15,950 --> 00:39:20,270
fault and so and we can drawback because

00:39:18,410 --> 00:39:24,049
we are part of a network which updates

00:39:20,270 --> 00:39:26,690
and maybe we are updated but our master

00:39:24,049 --> 00:39:29,920
is not updated so I would be very

00:39:26,690 --> 00:39:33,380
interested in something yeah

00:39:29,920 --> 00:39:35,000
implementing a sort of quorum also so 10

00:39:33,380 --> 00:39:36,770
are saying it's good to us saying it's

00:39:35,000 --> 00:39:39,170
not it's good enough for us or so and

00:39:36,770 --> 00:39:41,780
we're trying with this but we found no

00:39:39,170 --> 00:39:44,599
good solution for this but I think this

00:39:41,780 --> 00:39:47,500
is really needed to decide when to roll

00:39:44,599 --> 00:39:47,500
back and we're not

00:39:53,390 --> 00:39:59,270
as a so we've had this problem

00:39:56,570 --> 00:40:00,170
Billy updaters I think this is an area

00:39:59,270 --> 00:40:06,380
which is always going to be project

00:40:00,170 --> 00:40:08,720
specific and my feeling my goal is this

00:40:06,380 --> 00:40:11,060
is a point where it would be really good

00:40:08,720 --> 00:40:13,700
to collaboratively create some API

00:40:11,060 --> 00:40:15,350
because on one hand there's the updaters

00:40:13,700 --> 00:40:17,150
and there's a bunch of those and they

00:40:15,350 --> 00:40:18,500
all have this problem and a bunch of

00:40:17,150 --> 00:40:21,310
other problems where they need to

00:40:18,500 --> 00:40:24,890
interact with the rest of the system and

00:40:21,310 --> 00:40:26,900
but the API is very narrow is just okay

00:40:24,890 --> 00:40:30,110
oh it's not okay exactly and if we could

00:40:26,900 --> 00:40:31,310
make that that standard I think that API

00:40:30,110 --> 00:40:32,540
is gonna have some other stuff in it

00:40:31,310 --> 00:40:34,280
because you probably need a signal that

00:40:32,540 --> 00:40:36,080
you've made a rollback so the user user

00:40:34,280 --> 00:40:38,240
space can recover and then there's a

00:40:36,080 --> 00:40:39,590
whole bunch of other places where the

00:40:38,240 --> 00:40:41,840
update system needs to hook the rest of

00:40:39,590 --> 00:40:45,140
the thing but that would be one part of

00:40:41,840 --> 00:40:46,150
a contract between the update system and

00:40:45,140 --> 00:40:48,470
the rest of the thing and then you can

00:40:46,150 --> 00:40:51,950
do your checks in system D and whatever

00:40:48,470 --> 00:40:54,980
and then we want a standard way to poke

00:40:51,950 --> 00:40:57,680
an update oh yeah I think what the

00:40:54,980 --> 00:41:01,040
system lis people have implemented there

00:40:57,680 --> 00:41:02,600
is already 80 percent of that so you

00:41:01,040 --> 00:41:05,720
have one target which contains two

00:41:02,600 --> 00:41:10,220
checks and another target which confirms

00:41:05,720 --> 00:41:13,160
the boot as okay or to handle a failed

00:41:10,220 --> 00:41:17,390
boot so you can just plug into that with

00:41:13,160 --> 00:41:22,250
system D services and the logic I think

00:41:17,390 --> 00:41:26,540
is enough to handle those checks system

00:41:22,250 --> 00:41:28,850
DB today yeah it sounds like it's

00:41:26,540 --> 00:41:31,330
standardized enough so we couldn't just

00:41:28,850 --> 00:41:31,330
use that

00:41:35,020 --> 00:41:41,150
so so one thing you know related

00:41:39,020 --> 00:41:43,510
specifically to the issue of networking

00:41:41,150 --> 00:41:45,920
mode was being down and you know

00:41:43,510 --> 00:41:48,560
multi-component systems I think there's

00:41:45,920 --> 00:41:50,990
definitely a case for you know a higher

00:41:48,560 --> 00:41:52,580
level orchestration view of this right

00:41:50,990 --> 00:41:54,080
each individual system has the ability

00:41:52,580 --> 00:41:55,490
to detect boot

00:41:54,080 --> 00:41:56,750
successful boot and whether it's you

00:41:55,490 --> 00:41:58,310
know the ability to talk to some

00:41:56,750 --> 00:41:59,420
specific server on the internet or you

00:41:58,310 --> 00:42:01,280
know your clients are up and running

00:41:59,420 --> 00:42:04,100
that's one level but then you're I think

00:42:01,280 --> 00:42:05,570
ultimately in any in any complex design

00:42:04,100 --> 00:42:07,850
you're gonna have to have some well

00:42:05,570 --> 00:42:09,470
higher level orchestration that can

00:42:07,850 --> 00:42:11,450
detect failures that are simply not

00:42:09,470 --> 00:42:13,790
detectable from an individual node in

00:42:11,450 --> 00:42:15,830
the system and I know we've talked to

00:42:13,790 --> 00:42:17,630
plenty of users that are looking at very

00:42:15,830 --> 00:42:19,160
large systems very complex systems

00:42:17,630 --> 00:42:21,380
bringing all kinds of different levels

00:42:19,160 --> 00:42:23,060
of devices together and ultimately that

00:42:21,380 --> 00:42:24,890
that's what they're looking at right the

00:42:23,060 --> 00:42:26,180
the devices themselves can say yes I

00:42:24,890 --> 00:42:28,970
know there's something wrong with me but

00:42:26,180 --> 00:42:30,890
that can only go so far until you have

00:42:28,970 --> 00:42:32,240
to have something that it's completely

00:42:30,890 --> 00:42:33,830
outside of the system that says okay

00:42:32,240 --> 00:42:34,220
this portion over here is just not there

00:42:33,830 --> 00:42:35,960
anymore

00:42:34,220 --> 00:42:37,190
and then you know at that point that you

00:42:35,960 --> 00:42:39,260
might have to send technicians out or

00:42:37,190 --> 00:42:42,020
whatever if you're talking you know very

00:42:39,260 --> 00:42:46,910
large transit systems or things like

00:42:42,020 --> 00:42:50,270
that do we have any standout API for

00:42:46,910 --> 00:42:51,740
that project specific yeah none that

00:42:50,270 --> 00:42:53,330
I've heard of everything all the

00:42:51,740 --> 00:42:55,520
discussions I've had about it have been

00:42:53,330 --> 00:42:57,170
very very project specific I mean

00:42:55,520 --> 00:42:58,760
obviously they you know some of the

00:42:57,170 --> 00:43:00,500
lower-level technologies they used you

00:42:58,760 --> 00:43:02,480
know the JSON and the the various

00:43:00,500 --> 00:43:03,590
transport layers and MQTT and that kind

00:43:02,480 --> 00:43:05,810
of thing those things are obviously

00:43:03,590 --> 00:43:08,000
standardized but it's how all the

00:43:05,810 --> 00:43:11,360
components are put together is gonna be

00:43:08,000 --> 00:43:14,200
again very application specific yeah

00:43:11,360 --> 00:43:14,200
thank you mm-hmm

00:43:15,900 --> 00:43:22,210
I'm not sure if this is connected but is

00:43:20,140 --> 00:43:24,099
it possible to use Buddha integrity so

00:43:22,210 --> 00:43:26,290
you know the a cryptographic hash of

00:43:24,099 --> 00:43:29,020
what the image should be after it was

00:43:26,290 --> 00:43:32,710
successful and then verify that you know

00:43:29,020 --> 00:43:34,540
at that level I think all those systems

00:43:32,710 --> 00:43:37,119
we've mentioned already checked during

00:43:34,540 --> 00:43:39,849
installation and you can combine that

00:43:37,119 --> 00:43:42,599
with something like the Verity like

00:43:39,849 --> 00:43:45,460
Android does to detect corruption of the

00:43:42,599 --> 00:43:50,920
day yeah side system or application data

00:43:45,460 --> 00:43:52,930
on disk but in most cases the problems

00:43:50,920 --> 00:43:55,900
that actually happen are just bugs in

00:43:52,930 --> 00:44:00,609
the application and not corruption that

00:43:55,900 --> 00:44:03,900
happens on the device itself and so it's

00:44:00,609 --> 00:44:07,540
not a failed updated to failed payload

00:44:03,900 --> 00:44:11,740
the payload is wrong from the beginning

00:44:07,540 --> 00:44:14,500
yeah okay and yeah because the testing

00:44:11,740 --> 00:44:17,260
wasn't good enough so the customer

00:44:14,500 --> 00:44:18,940
didn't catch that problem and it happens

00:44:17,260 --> 00:44:21,220
in the field and we still want to have

00:44:18,940 --> 00:44:28,140
some way back to the old system so we

00:44:21,220 --> 00:44:31,150
can recover the systems in the field we

00:44:28,140 --> 00:44:34,530
often have different kind of faults and

00:44:31,150 --> 00:44:39,369
we can did exam and we report them on

00:44:34,530 --> 00:44:43,810
devices but we assume most of us have a

00:44:39,369 --> 00:44:49,890
wet dog did which is a hardware watchdog

00:44:43,810 --> 00:44:53,890
and usually in our case we link our

00:44:49,890 --> 00:45:00,210
application watchdog to decide watchdog

00:44:53,890 --> 00:45:05,170
in case we have if the software and goes

00:45:00,210 --> 00:45:07,240
faulty and not only one month which is

00:45:05,170 --> 00:45:10,810
detected as faulty and the new a report

00:45:07,240 --> 00:45:14,950
it eats so in this case we will take we

00:45:10,810 --> 00:45:17,610
reboot the system so usually when we do

00:45:14,950 --> 00:45:21,020
show me a grant we want to

00:45:17,610 --> 00:45:25,200
know very soon if it is okay or not but

00:45:21,020 --> 00:45:29,670
by waiting for the watchdog to kick off

00:45:25,200 --> 00:45:32,190
or not we might get some help in knowing

00:45:29,670 --> 00:45:36,930
either system is okay because we already

00:45:32,190 --> 00:45:40,410
did it we have some failsafe safe well

00:45:36,930 --> 00:45:43,800
some sanity check in our embedded

00:45:40,410 --> 00:45:47,460
software so we can just use it through

00:45:43,800 --> 00:45:49,800
the version yeah that's something we've

00:45:47,460 --> 00:45:53,330
also done with customers to just wait

00:45:49,800 --> 00:45:56,310
five minutes before the system is the

00:45:53,330 --> 00:46:01,110
newly installed system is marked as okay

00:45:56,310 --> 00:46:05,460
to just wait if any crash or the the

00:46:01,110 --> 00:46:08,790
wash talk at triggers reboot so that

00:46:05,460 --> 00:46:10,260
works well in cases way the applications

00:46:08,790 --> 00:46:14,130
already have some integration with the

00:46:10,260 --> 00:46:17,280
work watchdog which is interesting is we

00:46:14,130 --> 00:46:20,370
did the work already because the bug is

00:46:17,280 --> 00:46:26,460
already in place for insanity in our

00:46:20,370 --> 00:46:29,880
software what I've also been thinking

00:46:26,460 --> 00:46:34,710
about this I think they're actually two

00:46:29,880 --> 00:46:39,420
kind of successful one is the device is

00:46:34,710 --> 00:46:41,550
doing its work and so it can run and it

00:46:39,420 --> 00:46:44,970
can all do all kind of things and the

00:46:41,550 --> 00:46:47,190
other is I can install an update so

00:46:44,970 --> 00:46:49,950
basically these are a bit orthogonal and

00:46:47,190 --> 00:46:52,110
we are putting it in the same part or

00:46:49,950 --> 00:46:55,950
more or less here and I think it might

00:46:52,110 --> 00:46:58,110
be different to decide do any both or

00:46:55,950 --> 00:47:00,090
doin it either because if it's I can

00:46:58,110 --> 00:47:02,160
install an update I don't need to fall

00:47:00,090 --> 00:47:05,930
back on the air on the old system to

00:47:02,160 --> 00:47:10,050
install the new update to fix things but

00:47:05,930 --> 00:47:12,900
you can but if it doesn't run right now

00:47:10,050 --> 00:47:14,820
I think that's too kind of things that

00:47:12,900 --> 00:47:17,370
need to be looked at separately because

00:47:14,820 --> 00:47:19,860
I am not allowed to try to install an

00:47:17,370 --> 00:47:23,280
app that if the updater is broken but it

00:47:19,860 --> 00:47:26,190
might still continue running and do the

00:47:23,280 --> 00:47:29,430
necessary things in terms of downtime so

00:47:26,190 --> 00:47:31,330
so I can keep running the new system so

00:47:29,430 --> 00:47:34,690
there might be

00:47:31,330 --> 00:47:40,720
to separate the two and decide what to

00:47:34,690 --> 00:47:44,490
do for either of them yeah I think we

00:47:40,720 --> 00:47:50,380
still have 10 minutes left probably me

00:47:44,490 --> 00:47:53,740
so I choose one at random atomic

00:47:50,380 --> 00:48:02,560
bootloader updates or our data it

00:47:53,740 --> 00:48:05,320
updates probably more interesting so in

00:48:02,560 --> 00:48:07,720
in route we now have for some months

00:48:05,320 --> 00:48:11,050
support for C async which in this

00:48:07,720 --> 00:48:13,900
another project Polina pattering - yeah

00:48:11,050 --> 00:48:16,470
basically - something like the rsync

00:48:13,900 --> 00:48:19,840
algorithm of a whole file file systems

00:48:16,470 --> 00:48:22,690
so it will only download those things it

00:48:19,840 --> 00:48:26,800
doesn't have in the old 4 system can you

00:48:22,690 --> 00:48:29,380
reuse parts it already has so that keeps

00:48:26,800 --> 00:48:33,850
the download size pretty small if you

00:48:29,380 --> 00:48:35,920
have Network and that's useful for you

00:48:33,850 --> 00:48:39,100
for systems which are connected to the

00:48:35,920 --> 00:48:41,980
cellular data or something like that but

00:48:39,100 --> 00:48:45,510
what we currently don't have is some

00:48:41,980 --> 00:48:47,740
explicit binary data to the old version

00:48:45,510 --> 00:48:54,280
which could be installed in an offline

00:48:47,740 --> 00:48:59,170
way so I think the OS 3 people have

00:48:54,280 --> 00:49:03,000
basically under control for the image

00:48:59,170 --> 00:49:06,460
update mechanisms I don't know of a

00:49:03,000 --> 00:49:08,290
finished solution so maybe someone has

00:49:06,460 --> 00:49:10,530
built something like that our experience

00:49:08,290 --> 00:49:10,530
with that

00:49:16,870 --> 00:49:22,910
so our use case was pretty much for

00:49:20,030 --> 00:49:25,580
stayed up there it's it's updates over

00:49:22,910 --> 00:49:29,840
GSM cellular modems so and and that's

00:49:25,580 --> 00:49:32,630
like 100,000 devices updated over each

00:49:29,840 --> 00:49:34,940
own cellular modem and it's a price tag

00:49:32,630 --> 00:49:37,370
per megabyte that you sent so Delta

00:49:34,940 --> 00:49:41,630
update size was like the single target

00:49:37,370 --> 00:49:43,760
that we had to minimize and to solve

00:49:41,630 --> 00:49:46,970
that we looked at different algorithms

00:49:43,760 --> 00:49:50,030
like see a shrink there's also this VC

00:49:46,970 --> 00:49:51,710
diff it's pretty I don't know if it's a

00:49:50,030 --> 00:49:54,830
stand-up but it's it's a common format

00:49:51,710 --> 00:49:57,200
for describing a delta it's implemented

00:49:54,830 --> 00:49:59,720
by Google in open BC diff and it's

00:49:57,200 --> 00:50:02,990
implemented by another tool called

00:49:59,720 --> 00:50:04,730
X Delta free I found that the later one

00:50:02,990 --> 00:50:08,360
was was pretty much impossible to link

00:50:04,730 --> 00:50:10,760
with so I chose the Google version and

00:50:08,360 --> 00:50:13,880
then also there's different Google

00:50:10,760 --> 00:50:17,960
project that's embedded in in chrome and

00:50:13,880 --> 00:50:20,810
chromium that's called cassette and it's

00:50:17,960 --> 00:50:23,900
it's basically so there's like the free

00:50:20,810 --> 00:50:25,940
options that we found machetes also it's

00:50:23,900 --> 00:50:27,560
falling back to be a stiff if it doesn't

00:50:25,940 --> 00:50:30,590
really have the options to use its own

00:50:27,560 --> 00:50:34,730
specialized version so it's Chris chat

00:50:30,590 --> 00:50:36,650
and VCF and and see a shrink and in our

00:50:34,730 --> 00:50:39,170
case we actually ended up implementing

00:50:36,650 --> 00:50:42,200
all three of them in the same update

00:50:39,170 --> 00:50:44,930
tool so that when we built the update

00:50:42,200 --> 00:50:47,000
from the old version of our system to

00:50:44,930 --> 00:50:48,620
the new version we actually generate all

00:50:47,000 --> 00:50:51,890
three of them then choose the best ones

00:50:48,620 --> 00:50:53,420
so and in the usual case the kernel

00:50:51,890 --> 00:50:54,710
image is going to use one version and

00:50:53,420 --> 00:50:56,720
the root filesystem is gonna use another

00:50:54,710 --> 00:51:00,050
version and then we puzzle that into the

00:50:56,720 --> 00:51:01,850
same update and send it out so and

00:51:00,050 --> 00:51:04,790
that's and then of course we also have

00:51:01,850 --> 00:51:06,650
the option to use a full update if

00:51:04,790 --> 00:51:08,510
that's what I do one been developing

00:51:06,650 --> 00:51:10,520
because they don't wanna generating like

00:51:08,510 --> 00:51:12,410
what do I have on target now it's I

00:51:10,520 --> 00:51:15,710
don't remember so I just push the full

00:51:12,410 --> 00:51:18,110
update how much do you save with those

00:51:15,710 --> 00:51:22,160
approaches all the depends on the update

00:51:18,110 --> 00:51:24,800
so but but actually so we're working

00:51:22,160 --> 00:51:25,819
with 20 megabytes of file system size

00:51:24,800 --> 00:51:28,759
new in

00:51:25,819 --> 00:51:32,319
and now in the Squa surface image and I

00:51:28,759 --> 00:51:34,400
don't know is like deltas are from free

00:51:32,319 --> 00:51:37,519
kilobytes for the kilobytes to to

00:51:34,400 --> 00:51:39,079
several megabytes and and even removing

00:51:37,519 --> 00:51:42,859
stuff from your image is gonna take up

00:51:39,079 --> 00:51:44,619
space in your Delta so yeah okay and and

00:51:42,859 --> 00:51:48,640
it works very well

00:51:44,619 --> 00:51:48,640
yep yeah that's interesting

00:51:53,400 --> 00:51:57,460
we did our own you know a B update

00:51:56,050 --> 00:51:59,470
system because we were very short of

00:51:57,460 --> 00:52:02,350
develop a resource in time we just used

00:51:59,470 --> 00:52:03,460
our sink and we have an a/b system so we

00:52:02,350 --> 00:52:04,960
just have an our sink demon on the

00:52:03,460 --> 00:52:07,390
server and we just ask think the B

00:52:04,960 --> 00:52:08,830
system using the a in adjusted

00:52:07,390 --> 00:52:10,720
comparator which you can do with our

00:52:08,830 --> 00:52:12,430
sinks one of our sinks options and it's

00:52:10,720 --> 00:52:14,050
work surprisingly well it works well

00:52:12,430 --> 00:52:16,720
enough that we've never had to go and

00:52:14,050 --> 00:52:19,600
improve it it's because we have a lot of

00:52:16,720 --> 00:52:22,030
devices over GSM and they're saving it's

00:52:19,600 --> 00:52:24,460
very efficient I think that's the arcing

00:52:22,030 --> 00:52:29,140
batch file mechanism we just know we

00:52:24,460 --> 00:52:31,630
just know it's not the awesome that

00:52:29,140 --> 00:52:36,610
there's something I I tried I think has

00:52:31,630 --> 00:52:40,000
a mechanism when when it does a copy

00:52:36,610 --> 00:52:42,940
operation it can write basically the

00:52:40,000 --> 00:52:44,800
Delta to a batch file which can then be

00:52:42,940 --> 00:52:47,560
applied to the same base again on a

00:52:44,800 --> 00:52:51,490
different system so you can use air sink

00:52:47,560 --> 00:52:53,880
even offline by transferring those batch

00:52:51,490 --> 00:52:56,070
files yeah but we've always you know

00:52:53,880 --> 00:52:59,740
situation we're always online and so

00:52:56,070 --> 00:53:01,990
we're using the a to the big image and

00:52:59,740 --> 00:53:03,910
just aren't using a thing to transfer

00:53:01,990 --> 00:53:11,590
the differences and that's really quite

00:53:03,910 --> 00:53:15,300
efficient okay we also have an old

00:53:11,590 --> 00:53:18,550
boards we which modem is quite slow so

00:53:15,300 --> 00:53:22,090
our strategy was also something like

00:53:18,550 --> 00:53:24,670
whoo mate but at the file level so the

00:53:22,090 --> 00:53:28,060
Jeff is done like which files have

00:53:24,670 --> 00:53:30,760
changed but one of the main problem

00:53:28,060 --> 00:53:34,090
there is how to implement the removal of

00:53:30,760 --> 00:53:37,600
files that have been removed after the

00:53:34,090 --> 00:53:40,480
updates so this is hot rolled back

00:53:37,600 --> 00:53:42,600
because if you have a problem you have

00:53:40,480 --> 00:53:46,870
removed for instance an important file

00:53:42,600 --> 00:53:50,530
that may cause some trouble but you have

00:53:46,870 --> 00:53:53,740
known not an a/b scheme but a risk you

00:53:50,530 --> 00:53:55,660
production so that's not very much a

00:53:53,740 --> 00:54:01,570
problem in the worst case we just fall

00:53:55,660 --> 00:54:05,440
back into rescue ok so I think

00:54:01,570 --> 00:54:06,880
I'm almost out of time I just I just

00:54:05,440 --> 00:54:08,980
wanted to add that when you're running

00:54:06,880 --> 00:54:10,780
like a delta update system you also have

00:54:08,980 --> 00:54:11,800
the whole new class of problems that you

00:54:10,780 --> 00:54:14,470
want to be sure that you're updating

00:54:11,800 --> 00:54:17,530
from the right old boys into the new

00:54:14,470 --> 00:54:20,260
version and that takes like and and also

00:54:17,530 --> 00:54:21,640
the update path becomes critical so if

00:54:20,260 --> 00:54:23,230
you're on a to version

00:54:21,640 --> 00:54:25,030
old file system then you want to

00:54:23,230 --> 00:54:26,890
actually do two updates in a row and

00:54:25,030 --> 00:54:28,540
maybe you have like this big matrix or

00:54:26,890 --> 00:54:31,090
software updates you might want to fetch

00:54:28,540 --> 00:54:32,890
from the update so so adds and a whole

00:54:31,090 --> 00:54:35,430
new class well see I think software

00:54:32,890 --> 00:54:37,870
problem but simply doing that if online

00:54:35,430 --> 00:54:39,490
do you have for the other tools

00:54:37,870 --> 00:54:41,890
mechanism to check that you're updating

00:54:39,490 --> 00:54:43,540
from the correct version oh well my

00:54:41,890 --> 00:54:45,220
update bundle ships have checked some of

00:54:43,540 --> 00:54:47,770
the old version so and fails if it's

00:54:45,220 --> 00:54:49,240
wrong but and then now I have a problem

00:54:47,770 --> 00:54:51,760
they're both devices like how much

00:54:49,240 --> 00:54:54,010
checksum in the block device so I have

00:54:51,760 --> 00:54:56,260
to store somewhere in the update how big

00:54:54,010 --> 00:54:58,690
is the old version also also that's yeah

00:54:56,260 --> 00:55:06,910
you hit another class of gets complex

00:54:58,690 --> 00:55:10,350
yeah okay it's some final comments also

00:55:06,910 --> 00:55:10,350
interesting for you yes

00:55:11,090 --> 00:55:15,789

YouTube URL: https://www.youtube.com/watch?v=_0h5cWTuz24


