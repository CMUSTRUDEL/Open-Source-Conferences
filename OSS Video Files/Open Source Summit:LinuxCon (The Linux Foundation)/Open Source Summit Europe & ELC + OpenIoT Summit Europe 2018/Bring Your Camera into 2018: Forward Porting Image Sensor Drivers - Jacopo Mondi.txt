Title: Bring Your Camera into 2018: Forward Porting Image Sensor Drivers - Jacopo Mondi
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Bring Your Camera into 2018: Forward Porting Image Sensor Drivers - Jacopo Mondi, Renesas
embedded linux conference

The Linux media community tried in the past to ease the work of camera driver developers by providing frameworks and methods to abstract away from the crude V4L2 APIs. Some of those frameworks, as the 'soc_camera' one, have served their purpose so well they are often found in most BSPs and non-mainline camera drivers.

In the forthcoming Linux kernel releases said framework will be obsoleted, and developers of BSPs and downstream kernels will find themselves in the need to port their existing drivers. This presentation aims to provide them an overview on how to better do that while presenting how sensor drivers are expected to evolve as the hardware complexity image capture subsystems in embedded devices keep increasing year after year. 

About Jacopo Mondi
Jacopo is software engineer with a passion for embedded, operating systems and free software. In the last 5 years he collected development experiences on mobile and industrial grade devices based on different system on chips and platforms, mostly working on integrating video and graphics peripherals on Linux based platforms.

He has recently started contributing regularly to the Linux kernel after joining the Renesas upstream kernel team in late 2016, enjoying the opportunity to work closely with the kernel development community.

He presented at FOSDEM, LinuxLab and local free software related events.
Captions: 
	00:00:00,000 --> 00:00:06,830
okay right uh can you hear me yes okay

00:00:04,020 --> 00:00:09,900
welcome thanks everybody for being here

00:00:06,830 --> 00:00:13,799
this is a talk on how to ride more than

00:00:09,900 --> 00:00:16,350
video camera driver for Linux and I

00:00:13,799 --> 00:00:18,990
would like to use an example as a

00:00:16,350 --> 00:00:21,350
well-known framework which is going

00:00:18,990 --> 00:00:24,539
through removal or duplication process

00:00:21,350 --> 00:00:26,910
to show how the system we work on has

00:00:24,539 --> 00:00:29,730
changed since the time said framework

00:00:26,910 --> 00:00:32,300
has been implemented and hopefully I

00:00:29,730 --> 00:00:34,710
would like to give some suggestion and

00:00:32,300 --> 00:00:37,320
examples if you have dry this depending

00:00:34,710 --> 00:00:39,870
on set framework or now to make them or

00:00:37,320 --> 00:00:41,730
now remove those dependencies and have

00:00:39,870 --> 00:00:45,840
your driver working for next kernel

00:00:41,730 --> 00:00:48,270
releases so these are few of my contacts

00:00:45,840 --> 00:00:52,500
my name is iacopo this is my email

00:00:48,270 --> 00:00:53,760
address this is my RC contact I'm an

00:00:52,500 --> 00:00:56,340
embedded Linux and free software

00:00:53,760 --> 00:00:59,059
developer and I work as a consultant and

00:00:56,340 --> 00:01:01,980
I've been lucky enough to work with the

00:00:59,059 --> 00:01:04,470
excellent renesis mainline kernel team

00:01:01,980 --> 00:01:06,930
in the last two years which gave me the

00:01:04,470 --> 00:01:10,140
opportunity to contribute to Linux in a

00:01:06,930 --> 00:01:12,090
kind of a regular way I would like to

00:01:10,140 --> 00:01:14,790
thanks renesis of course for sponsoring

00:01:12,090 --> 00:01:18,990
me and supporting and given this talk

00:01:14,790 --> 00:01:20,700
and the activities and that's the talk

00:01:18,990 --> 00:01:22,680
outline so we're gonna look at what's

00:01:20,700 --> 00:01:24,090
happening at SOC camera which is the

00:01:22,680 --> 00:01:26,670
framework and I've been talking about

00:01:24,090 --> 00:01:30,840
and what has changed since the day that

00:01:26,670 --> 00:01:32,880
SOC camera has been implemented the main

00:01:30,840 --> 00:01:34,320
difference is that how system boots

00:01:32,880 --> 00:01:37,619
because we had moved from a world where

00:01:34,320 --> 00:01:40,770
system boots using both eyes to see suit

00:01:37,619 --> 00:01:43,740
through to femur supported boot process

00:01:40,770 --> 00:01:47,549
and that changes the way we discover and

00:01:43,740 --> 00:01:49,320
probe and creates devices power

00:01:47,549 --> 00:01:52,500
management has changed as well that

00:01:49,320 --> 00:01:56,100
depends on how the image capture devices

00:01:52,500 --> 00:01:57,509
are show up in user space and finally I

00:01:56,100 --> 00:02:00,180
would like to give a practical example

00:01:57,509 --> 00:02:02,310
of a driver that was developed for SOC

00:02:00,180 --> 00:02:05,310
camera and has been made a mole early in

00:02:02,310 --> 00:02:09,179
biddeford Linux driver recent current

00:02:05,310 --> 00:02:11,069
releases I would like also to introduce

00:02:09,179 --> 00:02:12,950
a bit of glossary because words are

00:02:11,069 --> 00:02:15,890
sometimes confusing

00:02:12,950 --> 00:02:18,680
to cut two images we need of course an

00:02:15,890 --> 00:02:21,739
image sensor that produces those images

00:02:18,680 --> 00:02:24,769
and the receiving port which is usually

00:02:21,739 --> 00:02:26,930
installed on the SOC a sensor driver

00:02:24,769 --> 00:02:29,180
controls an image sensor and the bridge

00:02:26,930 --> 00:02:33,200
or receiver driver controls the

00:02:29,180 --> 00:02:35,540
receiving port on the SOC on modern

00:02:33,200 --> 00:02:38,000
system we have we still have an image

00:02:35,540 --> 00:02:40,069
sensor that produce images and an image

00:02:38,000 --> 00:02:42,410
receiver but we also have several

00:02:40,069 --> 00:02:45,590
components on the SOC that takes care of

00:02:42,410 --> 00:02:48,530
image transformation manipulation image

00:02:45,590 --> 00:02:50,299
sensor and drivers for those kind of

00:02:48,530 --> 00:02:54,220
components are generally called via the

00:02:50,299 --> 00:02:56,390
sub device driver let's start by

00:02:54,220 --> 00:02:58,700
discussing what's happening to a CC

00:02:56,390 --> 00:03:02,360
camera and start by saying that SOC

00:02:58,700 --> 00:03:04,280
camera was great in my opinion and can I

00:03:02,360 --> 00:03:09,410
ask how many people you I've ever worked

00:03:04,280 --> 00:03:11,299
with SOC cameras okay just a few but so

00:03:09,410 --> 00:03:13,519
if you work with that framework you know

00:03:11,299 --> 00:03:16,190
it it was great because he provides you

00:03:13,519 --> 00:03:19,519
nice abstraction a way for the crude v4

00:03:16,190 --> 00:03:21,290
a2 API which might be kind of scary if

00:03:19,519 --> 00:03:23,930
that's the first video driver you have

00:03:21,290 --> 00:03:25,430
to write it's kind of scary to deal with

00:03:23,930 --> 00:03:29,540
all the complexity of the video for

00:03:25,430 --> 00:03:32,569
Linux API all the i/o city else you have

00:03:29,540 --> 00:03:35,359
to take take care of buffer allocation

00:03:32,569 --> 00:03:38,180
and sec camera obstructed all those

00:03:35,359 --> 00:03:38,900
things away in a nice way and that's why

00:03:38,180 --> 00:03:41,299
it was made

00:03:38,900 --> 00:03:44,239
adopted in a lot of driver in mainline

00:03:41,299 --> 00:03:46,400
and i don't have statistics for that but

00:03:44,239 --> 00:03:48,680
my feeling is that in BSP and in

00:03:46,400 --> 00:03:50,989
downstream kernels he was kind of very

00:03:48,680 --> 00:03:53,329
well all the BSP kernel I've been

00:03:50,989 --> 00:03:58,280
working with if they have a camera

00:03:53,329 --> 00:04:00,230
driver it was being an SEC camera and it

00:03:58,280 --> 00:04:02,299
was so adopted because it has good

00:04:00,230 --> 00:04:05,170
points like as I've said it provided a

00:04:02,299 --> 00:04:07,790
nice abstraction away for referral -

00:04:05,170 --> 00:04:10,730
it's the same framework for writing

00:04:07,790 --> 00:04:12,950
bridges and sensor drivers so you learn

00:04:10,730 --> 00:04:16,789
one framework you write two drivers that

00:04:12,950 --> 00:04:19,220
was nice and also provides an easy way

00:04:16,789 --> 00:04:21,620
to link bridge driver to sensor drivers

00:04:19,220 --> 00:04:23,390
because the two of them had to be linked

00:04:21,620 --> 00:04:25,290
in order for the bridge driver to call

00:04:23,390 --> 00:04:28,410
separation on the sensor one

00:04:25,290 --> 00:04:29,820
of course there is a bad side since we

00:04:28,410 --> 00:04:33,210
are removing that there is a bad side of

00:04:29,820 --> 00:04:34,890
course and SEC camera was developed in a

00:04:33,210 --> 00:04:37,710
time where system boot is through both

00:04:34,890 --> 00:04:41,010
eyes and this support for Oh F or a

00:04:37,710 --> 00:04:42,900
device 3 and nowadays CPI which is

00:04:41,010 --> 00:04:46,170
gaining traction by the system as well

00:04:42,900 --> 00:04:49,650
is limited it is there I know but it's

00:04:46,170 --> 00:04:52,260
limited and we're gonna see why it uses

00:04:49,650 --> 00:04:55,350
a set of deprecated operation which is a

00:04:52,260 --> 00:04:59,430
fixable things but while the v4l to api

00:04:55,350 --> 00:05:01,620
above the SC camera frame of using those

00:04:59,430 --> 00:05:04,020
api has not been evolved in the same way

00:05:01,620 --> 00:05:07,230
so this is fixable but it's not been

00:05:04,020 --> 00:05:09,180
done so far and more than everything

00:05:07,230 --> 00:05:11,490
else the media controller and sub Larry

00:05:09,180 --> 00:05:14,250
P I that have been introduced like five

00:05:11,490 --> 00:05:16,170
six years ago are actual game changes

00:05:14,250 --> 00:05:18,990
because they changed the way that how

00:05:16,170 --> 00:05:22,050
image capture devices show up in user

00:05:18,990 --> 00:05:26,010
space so they change SOC camera ever

00:05:22,050 --> 00:05:29,240
really kept up with that and what's

00:05:26,010 --> 00:05:31,560
happening to SSE camera SOC cameras its

00:05:29,240 --> 00:05:33,330
deprecated for a long time so you are

00:05:31,560 --> 00:05:35,520
suggesting not to use that for right

00:05:33,330 --> 00:05:37,740
drivers but it's gonna be removed

00:05:35,520 --> 00:05:41,190
finally because it's a long time we're

00:05:37,740 --> 00:05:45,060
gonna that talks about that possibly in

00:05:41,190 --> 00:05:47,280
the next kernel release the last SOC

00:05:45,060 --> 00:05:49,740
camera bridge driver has been removed as

00:05:47,280 --> 00:05:51,600
being important to be a video finish

00:05:49,740 --> 00:05:53,840
driver last year so there are no more

00:05:51,600 --> 00:05:56,520
platforms that depend on that frame work

00:05:53,840 --> 00:05:59,910
although there are some sense of driver

00:05:56,520 --> 00:06:02,670
may note the order of tens ten of them

00:05:59,910 --> 00:06:04,800
probably that have not been ported yet

00:06:02,670 --> 00:06:06,900
and they're going to be possibly removed

00:06:04,800 --> 00:06:09,390
there are discussion this day if moving

00:06:06,900 --> 00:06:12,330
them to staging or moving that or

00:06:09,390 --> 00:06:14,330
removing them completely it's possible

00:06:12,330 --> 00:06:16,980
they're gonna be removed completely and

00:06:14,330 --> 00:06:19,440
that's the file organization we know

00:06:16,980 --> 00:06:21,840
that platform bridge drivers are usually

00:06:19,440 --> 00:06:24,510
and drivers media platform an SOC camera

00:06:21,840 --> 00:06:26,580
drivers are diverse media platform SOC

00:06:24,510 --> 00:06:30,060
camera and here we have no more

00:06:26,580 --> 00:06:32,160
dependencies while for drivers media I

00:06:30,060 --> 00:06:34,110
square C were seems to drive the saw we

00:06:32,160 --> 00:06:37,729
have some of them which have which will

00:06:34,110 --> 00:06:39,650
be removed currently may line we have

00:06:37,729 --> 00:06:41,240
and of a confusing situation because we

00:06:39,650 --> 00:06:43,759
have two driver from the same device

00:06:41,240 --> 00:06:45,229
with just kind of confusing but firm

00:06:43,759 --> 00:06:48,020
necessarily this is what this is going

00:06:45,229 --> 00:06:50,599
away so there are drivers here that

00:06:48,020 --> 00:06:52,219
needs to be ported here and that's work

00:06:50,599 --> 00:06:54,800
to do if somebody would like to

00:06:52,219 --> 00:06:55,930
contribute to that it's it's nice thing

00:06:54,800 --> 00:06:58,430
to do

00:06:55,930 --> 00:07:01,639
what has changed then since the time

00:06:58,430 --> 00:07:03,529
when an SSC camera was implemented as we

00:07:01,639 --> 00:07:06,050
said the device discovery and Lincoln

00:07:03,529 --> 00:07:08,150
mechanism has changed nowadays we do

00:07:06,050 --> 00:07:11,569
that using notifiers and they sync

00:07:08,150 --> 00:07:14,210
matching power - power management has

00:07:11,569 --> 00:07:17,839
changed as well due to the way how V the

00:07:14,210 --> 00:07:19,909
device are we exposing user space and we

00:07:17,839 --> 00:07:23,479
now have free standard framework for

00:07:19,909 --> 00:07:25,909
clock and regulators and so SOC camera

00:07:23,479 --> 00:07:28,819
doesn't use deprecated frame was for

00:07:25,909 --> 00:07:30,710
that so every time it's possible we

00:07:28,819 --> 00:07:34,339
should use the standard frame was for

00:07:30,710 --> 00:07:37,099
dealing with those two things let's

00:07:34,339 --> 00:07:39,680
start talking about device probing and

00:07:37,099 --> 00:07:42,589
ever look at that how device probe was

00:07:39,680 --> 00:07:45,080
performed in the legacy way so we have

00:07:42,589 --> 00:07:48,139
five components here both files

00:07:45,080 --> 00:07:49,849
bridge driver as a see camera sensor

00:07:48,139 --> 00:07:53,089
driver and of course the video for Linux

00:07:49,849 --> 00:07:55,310
- framework the board file is nothing

00:07:53,089 --> 00:07:57,319
but the playing C file that register

00:07:55,310 --> 00:08:00,199
devices and drivers one after the other

00:07:57,319 --> 00:08:02,569
all devices in the system and at a

00:08:00,199 --> 00:08:04,819
certain point you will add the platform

00:08:02,569 --> 00:08:08,059
driver for the bridge drivers so that

00:08:04,819 --> 00:08:10,249
causes the bridge driver to probe at the

00:08:08,059 --> 00:08:12,740
end of the probe section of the probe

00:08:10,249 --> 00:08:14,719
function the bridge driver will probably

00:08:12,740 --> 00:08:16,759
register itself to the SOC camera

00:08:14,719 --> 00:08:19,339
framework that causes the SOC camera to

00:08:16,759 --> 00:08:21,740
do all the it initialization operation

00:08:19,339 --> 00:08:24,159
and that serve at a certain point it

00:08:21,740 --> 00:08:27,289
will start registering I squishy devices

00:08:24,159 --> 00:08:29,749
how does it do that it does that using a

00:08:27,289 --> 00:08:32,019
video for LG function which is this one

00:08:29,749 --> 00:08:34,969
before to ask where C news of that board

00:08:32,019 --> 00:08:36,889
which creates a new I square C device

00:08:34,969 --> 00:08:40,279
that causes the sensor driver to probe

00:08:36,889 --> 00:08:42,169
and hour those two identified while the

00:08:40,279 --> 00:08:44,630
board file knows the I square C bus

00:08:42,169 --> 00:08:47,569
number and the I square C address of the

00:08:44,630 --> 00:08:50,839
device and passes it down to the in the

00:08:47,569 --> 00:08:51,440
coal chain until here which were those

00:08:50,839 --> 00:08:54,160
two infirm

00:08:51,440 --> 00:08:57,800
I used to identify the sense of driver

00:08:54,160 --> 00:08:59,870
so in the old world we have that device

00:08:57,800 --> 00:09:03,079
is identified by I square C addresses

00:08:59,870 --> 00:09:05,149
and more important than everything the

00:09:03,079 --> 00:09:07,129
device probing is sequential so we have

00:09:05,149 --> 00:09:10,240
the bridge driver probing before the

00:09:07,129 --> 00:09:13,339
sensor drive it and that guarantees that

00:09:10,240 --> 00:09:17,449
every time a sense of driver probes it

00:09:13,339 --> 00:09:21,050
has a boots rather to connect to in the

00:09:17,449 --> 00:09:24,589
new world we have we moved to a firmer

00:09:21,050 --> 00:09:26,000
base boot process so nowadays devices

00:09:24,589 --> 00:09:28,220
are creating parsing the film

00:09:26,000 --> 00:09:30,170
description of the system and the

00:09:28,220 --> 00:09:32,120
advices are not identified anymore by I

00:09:30,170 --> 00:09:35,329
square C addresses by the femur node

00:09:32,120 --> 00:09:36,949
references and again more important than

00:09:35,329 --> 00:09:38,629
everything there is no guarantee any

00:09:36,949 --> 00:09:43,399
more on the probing border of the stop

00:09:38,629 --> 00:09:45,379
of the drivers so this is a DTS and in

00:09:43,399 --> 00:09:48,199
the DTS we have a description or if we

00:09:45,379 --> 00:09:50,120
do input port here and of a nice crusty

00:09:48,199 --> 00:09:53,120
bus on the ice core Sebastian there is a

00:09:50,120 --> 00:09:54,740
sensor identified by an address and the

00:09:53,120 --> 00:09:57,620
system builds linux builds and start

00:09:54,740 --> 00:10:00,470
parsing the DTS and telling me he finds

00:09:57,620 --> 00:10:03,079
the video input port nodes that causes

00:10:00,470 --> 00:10:05,240
the bridge driver to probe and that a

00:10:03,079 --> 00:10:07,970
certain point it start parsing the ice

00:10:05,240 --> 00:10:11,480
query bus which creates the sense of

00:10:07,970 --> 00:10:15,079
driver which probes again and can safely

00:10:11,480 --> 00:10:17,180
connect to the bridge driver but we can

00:10:15,079 --> 00:10:19,100
also have the other way around so the

00:10:17,180 --> 00:10:20,449
ice core see bus is registered before

00:10:19,100 --> 00:10:23,959
the video input port

00:10:20,449 --> 00:10:26,180
this is probed first and the session

00:10:23,959 --> 00:10:28,939
driver probes completed its bro

00:10:26,180 --> 00:10:32,060
operation but file finds no one there to

00:10:28,939 --> 00:10:34,100
register to and that might be a problem

00:10:32,060 --> 00:10:36,699
it's actually a problem because now

00:10:34,100 --> 00:10:39,529
device probing is totally asynchronous

00:10:36,699 --> 00:10:43,100
we have no guarantees which is the

00:10:39,529 --> 00:10:45,139
probing order and again we need to

00:10:43,100 --> 00:10:49,490
identify devices by the femur node

00:10:45,139 --> 00:10:51,529
references how to do that well before -

00:10:49,490 --> 00:10:53,899
framework to the rescue because it has

00:10:51,529 --> 00:10:56,180
two components that are designed for

00:10:53,899 --> 00:10:59,000
helping you how Drive is doing that

00:10:56,180 --> 00:11:03,139
exactly which are before chasing and

00:10:59,000 --> 00:11:04,790
before a ufw node how do they work and

00:11:03,139 --> 00:11:07,490
how drive and use them

00:11:04,790 --> 00:11:10,700
well we have a bridge drive again DGS

00:11:07,490 --> 00:11:12,890
and the two framework components and in

00:11:10,700 --> 00:11:15,110
DTS we have description on the input

00:11:12,890 --> 00:11:18,260
port on the output port of the bridge

00:11:15,110 --> 00:11:20,690
driver which has two ports connected to

00:11:18,260 --> 00:11:24,470
two remote end points which are possibly

00:11:20,690 --> 00:11:27,560
sensor of sub devices driver the sense

00:11:24,470 --> 00:11:31,040
the bridge driver probes and uses video

00:11:27,560 --> 00:11:33,860
for two FW node framework to parse the

00:11:31,040 --> 00:11:37,400
DTS and collect references to the remote

00:11:33,860 --> 00:11:40,070
end points those two are collected in

00:11:37,400 --> 00:11:42,110
the form of V deferral to acing sub

00:11:40,070 --> 00:11:44,300
device which is an abstraction provided

00:11:42,110 --> 00:11:48,140
to review by this part of the framework

00:11:44,300 --> 00:11:50,930
and those two devices are collected by

00:11:48,140 --> 00:11:53,090
the bridge driver what does the bridge

00:11:50,930 --> 00:11:54,830
the bridge driver do with that the

00:11:53,090 --> 00:11:58,430
bridge drivers toss them in what is

00:11:54,830 --> 00:12:01,790
called a notifier it's actually referred

00:11:58,430 --> 00:12:03,500
to async notifier which is provided fine

00:12:01,790 --> 00:12:06,400
by this part of the framework and

00:12:03,500 --> 00:12:09,260
notifier is nothing but a collection of

00:12:06,400 --> 00:12:13,580
film or not references the bridge driver

00:12:09,260 --> 00:12:16,340
or a generic driver is waiting for v4l

00:12:13,580 --> 00:12:19,130
tracings maintains a list of all notify

00:12:16,340 --> 00:12:21,620
register in the system now we have three

00:12:19,130 --> 00:12:23,570
four in total which is kind of a likely

00:12:21,620 --> 00:12:26,600
in a system but it's possible totally

00:12:23,570 --> 00:12:29,090
possible and the bridge driver does

00:12:26,600 --> 00:12:31,280
nothing but register its notifier with

00:12:29,090 --> 00:12:36,560
devices is waiting for - deferral to

00:12:31,280 --> 00:12:40,220
async referral to a sinks maintains as

00:12:36,560 --> 00:12:43,250
well a list of waiting devices this has

00:12:40,220 --> 00:12:45,800
devices or sub devices that probe and no

00:12:43,250 --> 00:12:49,160
one is waiting for them so they put in

00:12:45,800 --> 00:12:51,140
the waiting list at the certain point in

00:12:49,160 --> 00:12:54,620
time we have that the sensor driver

00:12:51,140 --> 00:12:57,400
probes eventually and it uses v4l - fw

00:12:54,620 --> 00:13:02,050
node to parse its local endpoint and

00:12:57,400 --> 00:13:05,960
create a V for LG wasting sub device

00:13:02,050 --> 00:13:08,240
representation of itself it will then

00:13:05,960 --> 00:13:11,120
register that to be furel to a sinks

00:13:08,240 --> 00:13:14,570
which adds them to the list of waiting

00:13:11,120 --> 00:13:17,390
devices but the two of them gets matches

00:13:14,570 --> 00:13:19,110
so there is someone waiting for this

00:13:17,390 --> 00:13:21,580
sensor

00:13:19,110 --> 00:13:24,280
when the two of them gets matching that

00:13:21,580 --> 00:13:26,740
causes the village racing to call it

00:13:24,280 --> 00:13:29,920
cold medic on the on the bridge driver

00:13:26,740 --> 00:13:32,710
that bounds the sub device to drive it

00:13:29,920 --> 00:13:35,140
so in this way the bridge will of and

00:13:32,710 --> 00:13:38,950
handle a reference to the sense of

00:13:35,140 --> 00:13:42,430
driver the second okay we are waiting

00:13:38,950 --> 00:13:44,110
for two sensor drivers and the second

00:13:42,430 --> 00:13:45,970
sensor eventual will problem future

00:13:44,110 --> 00:13:47,650
that's the same things usually before

00:13:45,970 --> 00:13:49,300
else you have lovely node create a

00:13:47,650 --> 00:13:51,850
difference racing subdivides

00:13:49,300 --> 00:13:54,430
representation of itself and register

00:13:51,850 --> 00:13:57,220
that to be for us racing that causes the

00:13:54,430 --> 00:13:59,440
same device to be matching and the sub

00:13:57,220 --> 00:14:00,970
device bound and the bounce and about

00:13:59,440 --> 00:14:04,480
callback to be called on the bridge

00:14:00,970 --> 00:14:06,400
driver and so in this way the bridge has

00:14:04,480 --> 00:14:09,490
reference to both the sensor driver is

00:14:06,400 --> 00:14:11,850
waiting for there is another things I'm

00:14:09,490 --> 00:14:14,620
not sure I have not shown you which is

00:14:11,850 --> 00:14:16,600
there's no not only the bound Colbert

00:14:14,620 --> 00:14:19,990
there is things called complete callback

00:14:16,600 --> 00:14:22,240
that it's usually cold when all the sub

00:14:19,990 --> 00:14:25,210
device notifier or all denote the

00:14:22,240 --> 00:14:28,120
synchronous sub device the notifier is

00:14:25,210 --> 00:14:30,240
waiting for I have been registered the

00:14:28,120 --> 00:14:33,010
complete callback is usually called here

00:14:30,240 --> 00:14:36,850
the complete callback usually called

00:14:33,010 --> 00:14:39,070
creates all the user special

00:14:36,850 --> 00:14:41,350
representations video device know the

00:14:39,070 --> 00:14:45,190
meter sub device node connected to the

00:14:41,350 --> 00:14:47,560
world capturing infrastructure there is

00:14:45,190 --> 00:14:50,770
discussion going on nowadays if it's a

00:14:47,560 --> 00:14:52,660
good things if you have eight let's say

00:14:50,770 --> 00:14:55,720
you are waiting for eight cameras and

00:14:52,660 --> 00:14:57,280
one of them is not probing do you want

00:14:55,720 --> 00:15:00,550
your system to be working or not

00:14:57,280 --> 00:15:02,800
so should complete be called only when

00:15:00,550 --> 00:15:04,750
all these sub devices are probed or

00:15:02,800 --> 00:15:07,150
sometime it's a good things to have a

00:15:04,750 --> 00:15:09,790
working system even if one of your sub

00:15:07,150 --> 00:15:12,460
devices or camera phase there will be

00:15:09,790 --> 00:15:14,500
discussion about that in the video for

00:15:12,460 --> 00:15:18,670
the next a meeting on two days from now

00:15:14,500 --> 00:15:21,850
and let's see what's happened that of

00:15:18,670 --> 00:15:23,560
course that's what we show so far is the

00:15:21,850 --> 00:15:26,230
situation where the bridge driver probes

00:15:23,560 --> 00:15:28,440
first but we wanted to solve a problem

00:15:26,230 --> 00:15:31,990
which is there synchronous probing

00:15:28,440 --> 00:15:35,470
problems so the sensor may prefer

00:15:31,990 --> 00:15:38,350
so the sensor probes uses before l to fw

00:15:35,470 --> 00:15:40,920
know to register it acing sub device and

00:15:38,350 --> 00:15:43,270
that gets headed to the waiting list

00:15:40,920 --> 00:15:45,400
nobody is waiting for them because there

00:15:43,270 --> 00:15:47,670
are no notifiers waiting for this sub

00:15:45,400 --> 00:15:50,080
device but in a certain point in future

00:15:47,670 --> 00:15:51,820
the bridge driver probes and will

00:15:50,080 --> 00:15:56,920
register a notify waiting for this

00:15:51,820 --> 00:15:59,710
advice the tuadaan gets matched and the

00:15:56,920 --> 00:16:03,270
two of them gets connected so we

00:15:59,710 --> 00:16:06,130
effectively solve the problem of async

00:16:03,270 --> 00:16:11,440
probing sequences using those two frame

00:16:06,130 --> 00:16:13,600
and the ones view of you that knows as

00:16:11,440 --> 00:16:15,940
the camera knows that assists SOC camera

00:16:13,600 --> 00:16:19,510
can do that actually does that it uses

00:16:15,940 --> 00:16:22,990
those two framework and so why it what

00:16:19,510 --> 00:16:24,700
has changed since then what has changed

00:16:22,990 --> 00:16:27,280
since the time where as such the camera

00:16:24,700 --> 00:16:30,640
has been implemented is that now sub

00:16:27,280 --> 00:16:32,950
devices can have notifiers as well this

00:16:30,640 --> 00:16:35,650
has been introduced one year ago by

00:16:32,950 --> 00:16:38,950
Niklas Sakari and Laurent which are the

00:16:35,650 --> 00:16:41,580
main author of the difference who async

00:16:38,950 --> 00:16:44,320
and before - FW node frameworks to

00:16:41,580 --> 00:16:47,740
support the Renaissance our car CSI

00:16:44,320 --> 00:16:50,740
infrastructure which as sub devices that

00:16:47,740 --> 00:16:52,300
are connected to sensors so we moved

00:16:50,740 --> 00:16:55,030
from a situation where we have a

00:16:52,300 --> 00:16:57,880
receiver which has notifier and connects

00:16:55,030 --> 00:17:00,240
to sub device to a situation where sub

00:16:57,880 --> 00:17:02,920
device can have a sub notify and

00:17:00,240 --> 00:17:05,230
eventually that sub device says that sub

00:17:02,920 --> 00:17:07,750
notify will be connected to two other

00:17:05,230 --> 00:17:10,390
sub devices this can create a chain of

00:17:07,750 --> 00:17:14,050
arbitrary complexity it's usually just

00:17:10,390 --> 00:17:15,459
one of two level but that's nothing

00:17:14,050 --> 00:17:18,310
preventing you from making more

00:17:15,459 --> 00:17:20,199
complicated things here and right now I

00:17:18,310 --> 00:17:23,199
think a couple of driver main lines are

00:17:20,199 --> 00:17:25,480
usually that IMX were our card for sure

00:17:23,199 --> 00:17:27,520
but also high in excess now using some

00:17:25,480 --> 00:17:30,190
device notifier and it's expected that

00:17:27,520 --> 00:17:35,230
more devices will use this abstraction

00:17:30,190 --> 00:17:37,450
as well power management as we said

00:17:35,230 --> 00:17:40,240
power management has changed as well due

00:17:37,450 --> 00:17:42,460
to the way that video devices are now

00:17:40,240 --> 00:17:44,500
represented in user space and that

00:17:42,460 --> 00:17:45,220
depends on the way on the introduction

00:17:44,500 --> 00:17:50,200
of media

00:17:45,220 --> 00:17:52,900
controller and subdiv api so media

00:17:50,200 --> 00:17:55,840
controller the old device the old world

00:17:52,900 --> 00:17:57,669
no media controller clip devices they

00:17:55,840 --> 00:17:59,980
work with a single device note

00:17:57,669 --> 00:18:02,110
abstraction so the one that we were all

00:17:59,980 --> 00:18:04,679
are used to the death video zero

00:18:02,110 --> 00:18:06,700
abstraction so for a wall capturing

00:18:04,679 --> 00:18:09,549
infrastructure you just have a single

00:18:06,700 --> 00:18:11,950
device known in user space and that

00:18:09,549 --> 00:18:13,990
causes all operation to be sequential

00:18:11,950 --> 00:18:18,580
they goes through a single device node

00:18:13,990 --> 00:18:20,470
and gets directed to the sub device we

00:18:18,580 --> 00:18:22,780
now live in a world where media control

00:18:20,470 --> 00:18:24,640
is everywhere and it's going to be

00:18:22,780 --> 00:18:26,650
everywhere hopefully in the next year

00:18:24,640 --> 00:18:28,390
and V the device no they are not the

00:18:26,650 --> 00:18:30,429
only abstraction we have in user space

00:18:28,390 --> 00:18:34,360
because we have also video sub device

00:18:30,429 --> 00:18:36,480
node and that cause is all operation not

00:18:34,360 --> 00:18:39,940
to be sequential anymore but instead

00:18:36,480 --> 00:18:43,750
they can be perform on sub devices and

00:18:39,940 --> 00:18:45,520
video devices at the same time so let's

00:18:43,750 --> 00:18:47,919
see an example of that this is a legacy

00:18:45,520 --> 00:18:50,049
system where we have the simplest

00:18:47,919 --> 00:18:52,270
possible capture infrastructure so we

00:18:50,049 --> 00:18:54,549
have a sensor that is connected to an I

00:18:52,270 --> 00:18:57,059
square C bus and it's connected to a

00:18:54,549 --> 00:19:01,570
receiver port where it transmit pixels

00:18:57,059 --> 00:19:04,330
in kernel space they will be they will

00:19:01,570 --> 00:19:06,340
be managed by a receiver driver a sensor

00:19:04,330 --> 00:19:09,340
driver that's the framework part which

00:19:06,340 --> 00:19:11,950
is coming to the to to the the kernel

00:19:09,340 --> 00:19:13,570
frameworks and the user space we will

00:19:11,950 --> 00:19:16,360
have just a single device node

00:19:13,570 --> 00:19:18,520
abstraction so all this infrastructure

00:19:16,360 --> 00:19:23,020
really is represented by a single device

00:19:18,520 --> 00:19:25,750
node we have of course the video for LG

00:19:23,020 --> 00:19:28,570
compliant application and which

00:19:25,750 --> 00:19:32,860
interfaces with all that with referral

00:19:28,570 --> 00:19:34,690
to api's usually at the first thing we

00:19:32,860 --> 00:19:37,330
operation we have to do if you want to

00:19:34,690 --> 00:19:41,770
use the video device it's to : open on

00:19:37,330 --> 00:19:45,360
this video device node and usually at

00:19:41,770 --> 00:19:49,360
set power at open time the bridge driver

00:19:45,360 --> 00:19:51,940
just powers up the sensor so in that way

00:19:49,360 --> 00:19:57,400
every other operation the sensor drive

00:19:51,940 --> 00:19:59,350
it's ready to send pixel to the receiver

00:19:57,400 --> 00:20:02,170
so the referral to compliant

00:19:59,350 --> 00:20:04,840
applications start calling the different

00:20:02,170 --> 00:20:07,240
ioctl sat for months get formats

00:20:04,840 --> 00:20:11,320
allocate buffers whatever and the

00:20:07,240 --> 00:20:13,720
certain point and all the operation will

00:20:11,320 --> 00:20:16,420
be translated by the receiver driver to

00:20:13,720 --> 00:20:19,809
the sense of driver using a different to

00:20:16,420 --> 00:20:21,730
sub that cooperation at a certain point

00:20:19,809 --> 00:20:23,680
we will receive a stream on so the

00:20:21,730 --> 00:20:27,220
application won't actually the sensor to

00:20:23,680 --> 00:20:29,950
stream pixels and this causes a lot of

00:20:27,220 --> 00:20:32,110
settings to be sent on the ice crevasse

00:20:29,950 --> 00:20:37,570
and pixel we start flowing in this

00:20:32,110 --> 00:20:39,760
direction this is what this is what the

00:20:37,570 --> 00:20:41,740
modern device might look like a very

00:20:39,760 --> 00:20:43,630
simplified actually modern device might

00:20:41,740 --> 00:20:45,610
look like so we still have a sensor we

00:20:43,630 --> 00:20:48,340
still have a receiver port but we also

00:20:45,610 --> 00:20:50,440
have a lot of components on the SOC that

00:20:48,340 --> 00:20:52,720
takes care of image transformation and

00:20:50,440 --> 00:20:54,820
manipulation that can be resizing

00:20:52,720 --> 00:20:58,750
conversion between one format and

00:20:54,820 --> 00:21:02,260
another formatting system memory depend

00:20:58,750 --> 00:21:07,500
- depends on your platform and of course

00:21:02,260 --> 00:21:10,120
the drivers that help that are much

00:21:07,500 --> 00:21:13,150
different from the legacy one and they

00:21:10,120 --> 00:21:15,760
might have different components they you

00:21:13,150 --> 00:21:19,030
may have one ASP driver and Link all

00:21:15,760 --> 00:21:20,470
three of them one receiver driver that's

00:21:19,030 --> 00:21:23,230
depends on your platform but the

00:21:20,470 --> 00:21:25,900
important thing is that this is how it

00:21:23,230 --> 00:21:27,610
would look like in user space so we

00:21:25,900 --> 00:21:30,429
still have the video device not zero

00:21:27,610 --> 00:21:32,410
which the application uses to start

00:21:30,429 --> 00:21:34,840
streaming and call a certain set of

00:21:32,410 --> 00:21:37,770
operation but we also have all these

00:21:34,840 --> 00:21:40,540
device nodes here which are subdivided

00:21:37,770 --> 00:21:44,890
where the application can cause sub the

00:21:40,540 --> 00:21:47,440
operation as well so this is what may

00:21:44,890 --> 00:21:50,170
happen we may have videoed shifts we

00:21:47,440 --> 00:21:52,740
have some devices are your city else : v

00:21:50,170 --> 00:21:55,240
the sub device know that any anytime and

00:21:52,740 --> 00:21:57,940
there is no relationship with one

00:21:55,240 --> 00:21:59,800
between one and the other so we might

00:21:57,940 --> 00:22:03,460
have those two called different times

00:21:59,800 --> 00:22:05,200
and that causes all of your operation to

00:22:03,460 --> 00:22:08,200
be now a synchronous because there is

00:22:05,200 --> 00:22:10,440
not a shared notation of power settings

00:22:08,200 --> 00:22:13,710
anymore along all this pipeline

00:22:10,440 --> 00:22:16,500
so the only thing the only suggestion

00:22:13,710 --> 00:22:18,360
that I have for if you are to implement

00:22:16,500 --> 00:22:21,510
a driver in this kind of situation is

00:22:18,360 --> 00:22:24,000
always cache your settings every time

00:22:21,510 --> 00:22:26,370
because you never know the power state

00:22:24,000 --> 00:22:28,620
your driver is working in you may

00:22:26,370 --> 00:22:30,810
receive a set format and your sensor

00:22:28,620 --> 00:22:32,490
might not be powered at all because we

00:22:30,810 --> 00:22:35,070
don't have the single entry point we add

00:22:32,490 --> 00:22:39,510
when working with no media controller

00:22:35,070 --> 00:22:43,560
systems that cause for maintaining a

00:22:39,510 --> 00:22:45,270
driver wise power state notation every

00:22:43,560 --> 00:22:47,820
time you should know if your device is

00:22:45,270 --> 00:22:50,100
powered or not and even better if you

00:22:47,820 --> 00:22:52,020
want to make that ref count it's even

00:22:50,100 --> 00:22:54,810
better because if you receive two set

00:22:52,020 --> 00:22:57,960
power that should not happen but who

00:22:54,810 --> 00:23:01,560
knows what user space is doing you

00:22:57,960 --> 00:23:04,790
should receive - power of the power to

00:23:01,560 --> 00:23:04,790
actually power of the device

00:23:05,240 --> 00:23:10,200
also you should cast cache all your

00:23:07,980 --> 00:23:13,080
settings and apply them at a time where

00:23:10,200 --> 00:23:15,240
is known the sensor or the sub devices

00:23:13,080 --> 00:23:18,090
to be powered and it that's usually

00:23:15,240 --> 00:23:20,520
stream on time because when you receive

00:23:18,090 --> 00:23:23,250
a stream on use that you should start

00:23:20,520 --> 00:23:27,540
sending pixel and at that time the

00:23:23,250 --> 00:23:29,940
sensor should be powered on also this is

00:23:27,540 --> 00:23:32,670
a general suggestion for not just for

00:23:29,940 --> 00:23:36,150
video devices but try to use run time

00:23:32,670 --> 00:23:38,370
p.m. run time p.m. makes provides even

00:23:36,150 --> 00:23:40,080
abstraction that it's more similar to

00:23:38,370 --> 00:23:43,110
the sequential flow of operation that

00:23:40,080 --> 00:23:46,230
we've seen before so it easy development

00:23:43,110 --> 00:23:49,830
and ref counting of power States of

00:23:46,230 --> 00:23:50,960
course is not always possible it's

00:23:49,830 --> 00:23:54,540
working

00:23:50,960 --> 00:23:56,490
Clark's GPS and regulators has said we

00:23:54,540 --> 00:23:57,960
have frameworks for that right now and

00:23:56,490 --> 00:24:02,070
they should be used whenever possible

00:23:57,960 --> 00:24:04,620
and relating to power management's

00:24:02,070 --> 00:24:08,250
routine in the legacy world we have the

00:24:04,620 --> 00:24:11,250
board file that provided power

00:24:08,250 --> 00:24:14,160
management routine to the sensor so this

00:24:11,250 --> 00:24:17,940
is how SOC camera used to do that there

00:24:14,160 --> 00:24:21,840
is an SOC camera linked with a power

00:24:17,940 --> 00:24:24,450
call back and the board file just filled

00:24:21,840 --> 00:24:24,630
that pointer with a routine the finding

00:24:24,450 --> 00:24:27,120
the

00:24:24,630 --> 00:24:29,730
world file so when the driver needed to

00:24:27,120 --> 00:24:32,160
power up on power off the sensor it

00:24:29,730 --> 00:24:34,130
called this things here and the board

00:24:32,160 --> 00:24:37,260
file has all the references to

00:24:34,130 --> 00:24:40,530
regulators reset whatever it need to

00:24:37,260 --> 00:24:42,150
power on and off the sensor of course we

00:24:40,530 --> 00:24:48,120
don't have board files anymore we have

00:24:42,150 --> 00:24:51,150
DTS or ACPI and how would you do that

00:24:48,120 --> 00:24:53,730
what you should use the GPIO clock and

00:24:51,150 --> 00:24:56,550
regulator frameworks every time they

00:24:53,730 --> 00:24:59,100
interface with the DTS you collect

00:24:56,550 --> 00:25:01,890
references from FEMA which is usually

00:24:59,100 --> 00:25:06,180
called FM or not the vamp depending if

00:25:01,890 --> 00:25:08,370
you want to use the them clock or

00:25:06,180 --> 00:25:13,440
regulators get and use the name using

00:25:08,370 --> 00:25:15,930
the TS and the driver itself should not

00:25:13,440 --> 00:25:19,590
rely anymore on the board files turning

00:25:15,930 --> 00:25:21,180
on and off the single components but if

00:25:19,590 --> 00:25:24,930
the driver itself that should enable

00:25:21,180 --> 00:25:31,710
disable the computer the regulators or

00:25:24,930 --> 00:25:34,940
the reset line @s power time practical

00:25:31,710 --> 00:25:38,400
so this is an example of a video driver

00:25:34,940 --> 00:25:41,730
that was was developed using SOC camera

00:25:38,400 --> 00:25:44,340
and in recent I think two releases ago

00:25:41,730 --> 00:25:47,490
has been ported to be a plain beautiful

00:25:44,340 --> 00:25:49,470
Linux to drivers so I would like to go

00:25:47,490 --> 00:25:52,230
through all the paths not all of them

00:25:49,470 --> 00:25:55,680
but some patches there and show you what

00:25:52,230 --> 00:25:57,330
are the steps that has been performed to

00:25:55,680 --> 00:25:59,820
do that in order and if you have any

00:25:57,330 --> 00:26:02,460
driver depending on SC camera and you

00:25:59,820 --> 00:26:05,460
want to pour them and possibly submit

00:26:02,460 --> 00:26:09,480
them for inclusion that's the kind of of

00:26:05,460 --> 00:26:11,850
a guidelines for doing that so the first

00:26:09,480 --> 00:26:14,490
thing we did was just copy the service

00:26:11,850 --> 00:26:16,500
or driver as it was from SSC camera to

00:26:14,490 --> 00:26:19,650
the video for Linux to sensor driver

00:26:16,500 --> 00:26:21,990
directory that was a choice that allowed

00:26:19,650 --> 00:26:26,850
us to see the differences without having

00:26:21,990 --> 00:26:29,310
any modification the first comment then

00:26:26,850 --> 00:26:31,230
the first comment actually removed all

00:26:29,310 --> 00:26:33,240
the dependencies from SOC camera from

00:26:31,230 --> 00:26:36,810
the driver and that's exactly what what

00:26:33,240 --> 00:26:38,759
we have been talking about ending clock

00:26:36,810 --> 00:26:40,969
and GPA OS and the drivers and

00:26:38,759 --> 00:26:44,159
relying on the board file for doing that

00:26:40,969 --> 00:26:45,989
register da Singh sub device because SOC

00:26:44,159 --> 00:26:47,489
camera was doing that for you and now

00:26:45,989 --> 00:26:51,559
you should do that explicitly in your

00:26:47,489 --> 00:26:54,449
driver remove SOC camera specific

00:26:51,559 --> 00:26:57,479
deprecated operation video for Linux -

00:26:54,449 --> 00:26:59,789
this operation are know what other

00:26:57,479 --> 00:27:02,159
brocaded SOC camera still depends on

00:26:59,789 --> 00:27:03,719
that and still wants them so they had to

00:27:02,159 --> 00:27:05,969
be removed and were implemented in the

00:27:03,719 --> 00:27:08,249
proper set format and get format

00:27:05,969 --> 00:27:11,039
operation and there were a few changes

00:27:08,249 --> 00:27:13,379
which are specific to get to this driver

00:27:11,039 --> 00:27:15,509
which are specific to this driver so

00:27:13,379 --> 00:27:18,749
just here for reference

00:27:15,509 --> 00:27:23,999
of course the build system has to be

00:27:18,749 --> 00:27:26,909
adjusted but that trivial and then after

00:27:23,999 --> 00:27:29,579
a plain video for Linux - driver has

00:27:26,909 --> 00:27:32,729
been made out of the SSE camera

00:27:29,579 --> 00:27:34,709
depending one the fun begin

00:27:32,729 --> 00:27:36,690
because people actually start using that

00:27:34,709 --> 00:27:38,999
and that's exciting because patches are

00:27:36,690 --> 00:27:42,179
start coming so people actually start

00:27:38,999 --> 00:27:45,089
using that and specifically patches have

00:27:42,179 --> 00:27:46,949
been heading components parts of to that

00:27:45,089 --> 00:27:48,899
driver that made the modern with the

00:27:46,949 --> 00:27:52,069
finish driver out of what it was an old

00:27:48,899 --> 00:27:54,509
one so the first thing we saw was

00:27:52,069 --> 00:27:57,359
heading media controller support to this

00:27:54,509 --> 00:28:00,779
driver that means that the driver now

00:27:57,359 --> 00:28:02,399
has a sub device and the sub device in

00:28:00,779 --> 00:28:06,209
here as a sub device in the user space

00:28:02,399 --> 00:28:08,249
so you now need to handle nested set

00:28:06,209 --> 00:28:12,509
power calls that's exactly the thing

00:28:08,249 --> 00:28:14,690
that cache or setting a keep a power not

00:28:12,509 --> 00:28:18,509
a power state notation in your driver

00:28:14,690 --> 00:28:21,149
also you should not access registers

00:28:18,509 --> 00:28:24,359
when the server is powered down now you

00:28:21,149 --> 00:28:26,609
can receive the gets a control get

00:28:24,359 --> 00:28:28,169
control from user space while your

00:28:26,609 --> 00:28:30,479
sensor is powered down and you should

00:28:28,169 --> 00:28:33,979
pay attention not accessing the ask or

00:28:30,479 --> 00:28:36,599
see bus why the sensor is powered off

00:28:33,979 --> 00:28:38,909
the worst support for frame interval

00:28:36,599 --> 00:28:40,969
handling this is a kind of a request

00:28:38,909 --> 00:28:43,619
right now if you want to submit them

00:28:40,969 --> 00:28:44,940
beautiful Linux driver frame and lling

00:28:43,619 --> 00:28:47,789
is something that is kind of mandatory

00:28:44,940 --> 00:28:50,119
doing that at least for a few frame

00:28:47,789 --> 00:28:50,119
rates

00:28:50,590 --> 00:28:56,030
that's and other things that cause for

00:28:53,030 --> 00:28:59,480
shared state notation so if your driver

00:28:56,030 --> 00:29:01,940
is streaming you should refuse you

00:28:59,480 --> 00:29:04,760
should return ebz or another error flags

00:29:01,940 --> 00:29:08,690
if you want to set format or change the

00:29:04,760 --> 00:29:10,550
into the frame interval and the last

00:29:08,690 --> 00:29:12,260
change it's the creation of the sub

00:29:10,550 --> 00:29:13,730
device note that goes along with the

00:29:12,260 --> 00:29:17,840
support for the media controller

00:29:13,730 --> 00:29:20,840
operations so I've been probably two

00:29:17,840 --> 00:29:22,880
fasts we have ten minutes for question I

00:29:20,840 --> 00:29:24,590
hope you'd have some at least me because

00:29:22,880 --> 00:29:26,450
otherwise I've been really too fast I

00:29:24,590 --> 00:29:28,940
had a hundred slides so it was worried

00:29:26,450 --> 00:29:30,740
that it was the time was not enough but

00:29:28,940 --> 00:29:33,110
actually I've been probably talking too

00:29:30,740 --> 00:29:36,470
fast if you have any question or

00:29:33,110 --> 00:29:39,200
anything you want to talk about or any

00:29:36,470 --> 00:29:42,470
question about any discussion about how

00:29:39,200 --> 00:29:44,360
things could evolve in not just for SOC

00:29:42,470 --> 00:29:46,520
camera base driver but sensor driver in

00:29:44,360 --> 00:29:49,240
general there are two microphones here

00:29:46,520 --> 00:29:49,240
so please go ahead

00:29:58,600 --> 00:30:03,490
so I'm just wondering when you're

00:30:01,360 --> 00:30:05,320
writing this new code you're adapting it

00:30:03,490 --> 00:30:07,120
what sort of technique to use for

00:30:05,320 --> 00:30:09,009
debugging and working what's going wrong

00:30:07,120 --> 00:30:10,299
because it strikes me this is a more

00:30:09,009 --> 00:30:12,120
complex setup of everything being

00:30:10,299 --> 00:30:14,679
asynchronous and when it's not working

00:30:12,120 --> 00:30:17,559
you might not have much idea as to which

00:30:14,679 --> 00:30:19,870
bit isn't actually hooking up so you get

00:30:17,559 --> 00:30:21,789
hungry and that's the first thing no no

00:30:19,870 --> 00:30:23,470
why I mean you get disappointed with

00:30:21,789 --> 00:30:26,950
things that's what that's the first

00:30:23,470 --> 00:30:29,110
debugging tool you use you and well that

00:30:26,950 --> 00:30:31,899
depends on the system that you use but

00:30:29,110 --> 00:30:34,090
things are now a synchronous so having a

00:30:31,899 --> 00:30:38,529
notion again of what is the power state

00:30:34,090 --> 00:30:41,529
that's always useful and talking about

00:30:38,529 --> 00:30:43,059
streaming start and stop that and now

00:30:41,529 --> 00:30:45,070
handle through the media controller

00:30:43,059 --> 00:30:46,840
frameworks so you have a pipeline

00:30:45,070 --> 00:30:54,399
notation the pipeline

00:30:46,840 --> 00:30:58,740
it's where's that that's it's basically

00:30:54,399 --> 00:31:01,240
a pipeline all the components here are

00:30:58,740 --> 00:31:02,649
put in a pipeline and when you start

00:31:01,240 --> 00:31:05,529
streaming the media controller

00:31:02,649 --> 00:31:09,070
frameworks goes one on the other and

00:31:05,529 --> 00:31:11,289
coasts start stream on all of them so

00:31:09,070 --> 00:31:13,000
having the begin adding the enabling the

00:31:11,289 --> 00:31:14,649
bug in the media controller frameworks

00:31:13,000 --> 00:31:17,529
help you understanding what's going on

00:31:14,649 --> 00:31:20,110
at each step or the capture process but

00:31:17,529 --> 00:31:22,059
in the end you should just you know

00:31:20,110 --> 00:31:23,350
what's happening in your sense of driver

00:31:22,059 --> 00:31:25,059
if you have problem streaming the

00:31:23,350 --> 00:31:26,740
panzram for what problem you have you

00:31:25,059 --> 00:31:30,279
don't receive images you receive bear

00:31:26,740 --> 00:31:32,440
the images you are missing a set format

00:31:30,279 --> 00:31:34,509
coal that depends from the driver

00:31:32,440 --> 00:31:36,340
usually and or you and what the bug in

00:31:34,509 --> 00:31:38,620
tools your system provides because

00:31:36,340 --> 00:31:40,570
compared to other parts of the system

00:31:38,620 --> 00:31:44,110
it's our to debug those kind of thing

00:31:40,570 --> 00:31:46,059
using jtech because what there is a nice

00:31:44,110 --> 00:31:48,669
person bus in the middle so you should

00:31:46,059 --> 00:31:50,740
the last the resort is printing out all

00:31:48,669 --> 00:31:53,590
the messages you're sending on the ice

00:31:50,740 --> 00:31:55,269
query bus printing all of them see

00:31:53,590 --> 00:31:58,710
what's happened go and go with the data

00:31:55,269 --> 00:32:02,649
sheet the comparison so there are

00:31:58,710 --> 00:32:04,480
different degrees of complexity you may

00:32:02,649 --> 00:32:07,110
want to handle I don't know if you have

00:32:04,480 --> 00:32:09,519
a specific use case for that or well

00:32:07,110 --> 00:32:10,770
it's not that you give them a so we have

00:32:09,519 --> 00:32:15,600
time so five

00:32:10,770 --> 00:32:17,660
after that circuit okay thank you thank

00:32:15,600 --> 00:32:17,660
you

00:32:19,610 --> 00:32:28,050
anyone else okay so thank you more time

00:32:26,250 --> 00:32:31,849
for in for coffee

00:32:28,050 --> 00:32:31,849

YouTube URL: https://www.youtube.com/watch?v=PJVlvUf0gP4


