Title: Common Attacks on IoT Devices - Christina Quast
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Common Attacks on IoT Devices - Christina Quast

The importance of securing embedded devices has become clear to the whole industry as they started to play a bigger role in our daily lives in recent years. Up to now, it has been easy to compromise IoT devices such as vacuum robot, IP cameras, smart home devices, etc.

In the early days of IoT, attackers could often succeed without having physical access to the device.
By now more and more OEMs took steps to improve the defenses of their devices, which in turn has led the attackers to improve their strategies. Among others, the possession of a potential target is often times a necessity for a feasible attack.

This talk will shed light on the landscape of recent attacks on IoT devices. This enables the discussion of common pitfalls in designing embedded systems in order to raise awareness for this topic. 

About Christina Quast
Christina, has recently finished her Master's Degree in Electrical Engineering at TU Berlin and works as an Embedded Systems Engineer.
She has been attending IT Security Conferences and playing IT Security CTFs for several years.
Furthermore, she worked as a part time Linux Kernel Driver Developer for several companies, and tries to bring together the world of Embedded Systems and IT Security.
Captions: 
	00:00:00,060 --> 00:00:05,009
okay so however welcome to my

00:00:02,040 --> 00:00:07,980
presentation my name is Christina cast

00:00:05,009 --> 00:00:10,590
at daytime I'm a normal and better

00:00:07,980 --> 00:00:13,769
systems developer but at night time or

00:00:10,590 --> 00:00:16,320
something I like playing IT security CGS

00:00:13,769 --> 00:00:19,109
or IT security for games or go to

00:00:16,320 --> 00:00:22,410
security conferences to find out how to

00:00:19,109 --> 00:00:24,439
hack devices and I felt like talking to

00:00:22,410 --> 00:00:27,510
my colleagues many of my colleagues

00:00:24,439 --> 00:00:29,789
didn't imagine how the attacker things

00:00:27,510 --> 00:00:31,349
like what the attack vectors are what

00:00:29,789 --> 00:00:32,969
what the view of an attacker is and I

00:00:31,349 --> 00:00:41,969
wanted to bring this to a developer

00:00:32,969 --> 00:00:44,760
conference it's knowledge so this is my

00:00:41,969 --> 00:00:47,640
agenda in short I've talked about

00:00:44,760 --> 00:00:49,860
software and hardware text and tell you

00:00:47,640 --> 00:00:52,949
some example at Tech stories I've seen

00:00:49,860 --> 00:00:58,109
in the last years and let's start with

00:00:52,949 --> 00:01:00,359
what is IOT so IOT were traditionally

00:00:58,109 --> 00:01:03,510
more analog devices like your light bulb

00:01:00,359 --> 00:01:05,549
or your garage opener or your baby

00:01:03,510 --> 00:01:07,920
monitor which are now connected to

00:01:05,549 --> 00:01:09,600
network so often those devices are

00:01:07,920 --> 00:01:11,400
rather power constrained and memory

00:01:09,600 --> 00:01:12,780
constrained and oftentimes that's

00:01:11,400 --> 00:01:13,320
secured because you don't care about

00:01:12,780 --> 00:01:16,590
security

00:01:13,320 --> 00:01:19,979
well somebody hacked my IOT lightbulb

00:01:16,590 --> 00:01:23,610
why should I care one of the reasons we

00:01:19,979 --> 00:01:26,729
saw in 2016 for example there was this

00:01:23,610 --> 00:01:28,979
Mira botnet which was mainly created out

00:01:26,729 --> 00:01:32,040
of IOT devices which now started to

00:01:28,979 --> 00:01:34,680
attack did it a distributed

00:01:32,040 --> 00:01:37,560
denial-of-service attack on done Dana's

00:01:34,680 --> 00:01:40,320
so that DNS requests whom some major

00:01:37,560 --> 00:01:43,649
websites like Netflix or Spotify or a

00:01:40,320 --> 00:01:45,600
B&B failed and the thing is those

00:01:43,649 --> 00:01:46,530
devices are still out there this button

00:01:45,600 --> 00:01:48,479
still exists

00:01:46,530 --> 00:01:52,200
and we don't know how many devices there

00:01:48,479 --> 00:01:55,170
are so your device could be one of the

00:01:52,200 --> 00:01:57,840
one attacking and the problem is not

00:01:55,170 --> 00:02:01,340
just you cannot pinpoint like this

00:01:57,840 --> 00:02:04,770
manufacturer is to be held responsible

00:02:01,340 --> 00:02:05,700
because there's a supply chain which is

00:02:04,770 --> 00:02:09,000
rather large

00:02:05,700 --> 00:02:11,640
you have the PCB and render then we have

00:02:09,000 --> 00:02:12,980
the ESP the port Support Package vendors

00:02:11,640 --> 00:02:15,260
like Marvel and broad

00:02:12,980 --> 00:02:17,569
which created SDK for you to work on

00:02:15,260 --> 00:02:19,250
then there's the odium the original

00:02:17,569 --> 00:02:22,489
device manufacturer which puts his own

00:02:19,250 --> 00:02:24,590
SDK on top of it then reseller of which

00:02:22,489 --> 00:02:26,810
puts his name on this whole package and

00:02:24,590 --> 00:02:29,660
the OEM the Original Equipment

00:02:26,810 --> 00:02:32,540
Manufacturer so you have so many steps

00:02:29,660 --> 00:02:34,489
you have so many touching hands hands

00:02:32,540 --> 00:02:38,120
touching the code which introduced packs

00:02:34,489 --> 00:02:41,480
as well and also an embedded device has

00:02:38,120 --> 00:02:44,690
many a large attack surface it can be

00:02:41,480 --> 00:02:47,090
connected over a wireless connection the

00:02:44,690 --> 00:02:49,370
firmware process can take place or

00:02:47,090 --> 00:02:52,069
wireless connection for example it can

00:02:49,370 --> 00:02:54,440
provide a web server or mobile

00:02:52,069 --> 00:02:56,150
applications so you have many many

00:02:54,440 --> 00:03:01,760
places that you can actually try to

00:02:56,150 --> 00:03:05,360
attack so let's talk about software so

00:03:01,760 --> 00:03:07,400
what does the attacker do first he has

00:03:05,360 --> 00:03:09,950
the same that normal embedded systems

00:03:07,400 --> 00:03:12,140
developer does when he gets a device and

00:03:09,950 --> 00:03:14,150
no documentation he basically tries to

00:03:12,140 --> 00:03:16,400
understand how does thing works he tries

00:03:14,150 --> 00:03:19,040
to reverse-engineer he inspects the

00:03:16,400 --> 00:03:21,109
components the data sheets looks at the

00:03:19,040 --> 00:03:23,989
firmware update process and looks better

00:03:21,109 --> 00:03:25,970
you can tamper with that a bit he looks

00:03:23,989 --> 00:03:30,100
at the Flash content which is already on

00:03:25,970 --> 00:03:31,760
device so like if the firmware is some

00:03:30,100 --> 00:03:34,370
well-known and well-documented

00:03:31,760 --> 00:03:37,310
architecture like arm or Power PC or

00:03:34,370 --> 00:03:40,040
MIPS is rather an easier task and you

00:03:37,310 --> 00:03:42,530
have ethics which are that they average

00:03:40,040 --> 00:03:46,220
easy and then the most complicated RF

00:03:42,530 --> 00:03:48,609
PJs because the FPGA is just hardware so

00:03:46,220 --> 00:03:51,950
the vendor can have put any program any

00:03:48,609 --> 00:03:54,590
bit stream on it and it's hard to figure

00:03:51,950 --> 00:03:56,780
out what he actually put on it anymore

00:03:54,590 --> 00:04:01,340
PCB layers your device your board has

00:03:56,780 --> 00:04:03,709
the more complicated gets to analyze and

00:04:01,340 --> 00:04:05,870
any attacker he would temper with the

00:04:03,709 --> 00:04:09,310
firmware update process he would try to

00:04:05,870 --> 00:04:12,349
rewrite some part of the memory also

00:04:09,310 --> 00:04:15,769
using jtech channel for example or other

00:04:12,349 --> 00:04:17,570
debug channels to have a feedback and

00:04:15,769 --> 00:04:19,729
establish a communication channel over

00:04:17,570 --> 00:04:24,110
serial or detect to see what kind of

00:04:19,729 --> 00:04:25,200
effects his changes have so if you want

00:04:24,110 --> 00:04:26,970
to analyze a firmer

00:04:25,200 --> 00:04:30,000
if you want to analyze the software

00:04:26,970 --> 00:04:32,400
running on this borders what where do

00:04:30,000 --> 00:04:34,260
you get this firmer like in most cases

00:04:32,400 --> 00:04:36,390
you can dump it from the flash memory

00:04:34,260 --> 00:04:38,070
but otherwise you can look around

00:04:36,390 --> 00:04:41,310
further you can find a firmware on the

00:04:38,070 --> 00:04:42,900
FTP server of the manufacturer they also

00:04:41,310 --> 00:04:46,770
FTP index sites where you can search

00:04:42,900 --> 00:04:50,130
some devices canvass CDs or DVDs very

00:04:46,770 --> 00:04:52,830
can search for the firmware or very good

00:04:50,130 --> 00:04:54,930
attack vector is looking at via shark so

00:04:52,830 --> 00:04:57,570
if the firmware update process takes

00:04:54,930 --> 00:05:02,100
place over an unencrypted connection the

00:04:57,570 --> 00:05:04,260
foe TLS then you can kind of dump the

00:05:02,100 --> 00:05:08,360
firmware out of the data which was

00:05:04,260 --> 00:05:11,100
transmitted or if it's just just a blob

00:05:08,360 --> 00:05:13,050
you can analyze the firmware and look at

00:05:11,100 --> 00:05:15,690
the firmware update or tune and see how

00:05:13,050 --> 00:05:18,230
where which part of the binary blobs you

00:05:15,690 --> 00:05:21,780
just dumped is mapped in memory later

00:05:18,230 --> 00:05:24,270
furthermore in firmware you sometimes

00:05:21,780 --> 00:05:26,000
find code or strings and you can search

00:05:24,270 --> 00:05:29,460
on the known websites like Google

00:05:26,000 --> 00:05:32,100
commerce or Sportsnet or something but

00:05:29,460 --> 00:05:33,930
you can recognize some open source so

00:05:32,100 --> 00:05:35,880
software which was just taken from a

00:05:33,930 --> 00:05:39,690
Chinese manufacturer and put into this

00:05:35,880 --> 00:05:42,270
box then yeah you can decompile you can

00:05:39,690 --> 00:05:45,630
recompile you can change some values you

00:05:42,270 --> 00:05:48,300
can faster device so then random data to

00:05:45,630 --> 00:05:49,380
it and see whether it crashes and for

00:05:48,300 --> 00:05:52,650
example if the firmware it's not

00:05:49,380 --> 00:05:55,110
stripped so it has some debug symbols in

00:05:52,650 --> 00:05:57,690
it or if you find human readable strings

00:05:55,110 --> 00:05:59,100
and it's easier but once you get the

00:05:57,690 --> 00:06:00,900
hang of it if you're really good and

00:05:59,100 --> 00:06:04,590
reversing it doesn't keep your phone

00:06:00,900 --> 00:06:06,780
proposing this anyways so what what kind

00:06:04,590 --> 00:06:10,380
of software do we use one of them you

00:06:06,780 --> 00:06:13,500
see on the top right on the slide this

00:06:10,380 --> 00:06:16,350
is an screenshots which I took from Ida

00:06:13,500 --> 00:06:18,210
so I know it's like more or less the

00:06:16,350 --> 00:06:22,100
standard which is used nowadays by

00:06:18,210 --> 00:06:26,640
reversers it it has a nice GUI unless

00:06:22,100 --> 00:06:28,680
lets you look at the code flow then if

00:06:26,640 --> 00:06:31,260
you are more into open source and

00:06:28,680 --> 00:06:34,200
command-line tools there's rod r2 which

00:06:31,260 --> 00:06:35,940
is being developed and I heard a new

00:06:34,200 --> 00:06:38,130
up-and-coming as binary ninja but I

00:06:35,940 --> 00:06:38,969
didn't try it out yet

00:06:38,130 --> 00:06:40,919
then for

00:06:38,969 --> 00:06:43,519
impacts on your software you can use

00:06:40,919 --> 00:06:47,069
flow finder or the Metasploit framework

00:06:43,519 --> 00:06:49,349
metal sports more it's like a set or a

00:06:47,069 --> 00:06:51,749
database of exploits which you can just

00:06:49,349 --> 00:06:54,989
launch on a type on a target even if

00:06:51,749 --> 00:06:57,749
it's remote and to automatically perform

00:06:54,989 --> 00:06:58,829
those attacks the now some tools for

00:06:57,749 --> 00:07:02,969
analysis

00:06:58,829 --> 00:07:05,909
like from rokka rokka rokka it uses pin

00:07:02,969 --> 00:07:07,860
walk which will go through a binary plop

00:07:05,909 --> 00:07:09,569
and it will be searching for headers for

00:07:07,860 --> 00:07:11,489
example of which it can recognize and

00:07:09,569 --> 00:07:13,469
then it will print you of the files

00:07:11,489 --> 00:07:16,349
which is possibly found in this binary

00:07:13,469 --> 00:07:18,899
blob and you can extract them it used to

00:07:16,349 --> 00:07:21,419
be CPU rec to recognize the architecture

00:07:18,899 --> 00:07:24,029
the firmware is written for and that's

00:07:21,419 --> 00:07:26,729
also the firmware analog analysis

00:07:24,029 --> 00:07:28,529
toolkit or a rather academic project

00:07:26,729 --> 00:07:31,799
effects different analysis and

00:07:28,529 --> 00:07:35,729
comparison tool and if your device

00:07:31,799 --> 00:07:38,969
exposes a web server you can use the

00:07:35,729 --> 00:07:42,299
usual tools like SQL map to find SQL

00:07:38,969 --> 00:07:45,360
injections or SS lies in order to see

00:07:42,299 --> 00:07:49,199
whether you configure your server right

00:07:45,360 --> 00:07:52,229
for SSL or go bus faster for an

00:07:49,199 --> 00:07:55,110
extensive list I recommend you to check

00:07:52,229 --> 00:07:57,959
out the OWASP websites the open web

00:07:55,110 --> 00:08:01,739
application security project which kind

00:07:57,959 --> 00:08:05,099
of have more extensive knowledge and put

00:08:01,739 --> 00:08:07,409
it on their list and for interfacing

00:08:05,099 --> 00:08:12,239
with your device you would use the usual

00:08:07,409 --> 00:08:15,149
ones in for example gdb and open OCD so

00:08:12,239 --> 00:08:16,919
in terms of hardware there are three

00:08:15,149 --> 00:08:18,779
kinds of attacks you can have non

00:08:16,919 --> 00:08:20,399
invasive attacks you can have any

00:08:18,779 --> 00:08:23,759
invasive attacks and fully embrace of

00:08:20,399 --> 00:08:25,799
attacks so for non invasive attacks you

00:08:23,759 --> 00:08:28,099
don't have a direct chip access you only

00:08:25,799 --> 00:08:32,759
have the external signals and you try to

00:08:28,099 --> 00:08:34,709
work with those for example you can

00:08:32,759 --> 00:08:36,569
search for the new art or jtech and try

00:08:34,709 --> 00:08:39,689
to interface for your device and get

00:08:36,569 --> 00:08:41,370
control over it in this manner or if the

00:08:39,689 --> 00:08:44,069
right protection security hughes is not

00:08:41,370 --> 00:08:45,990
enabled you can change the bootloader

00:08:44,069 --> 00:08:48,689
you can patch it and let it load your

00:08:45,990 --> 00:08:51,600
own firmware you can do hardware for

00:08:48,689 --> 00:08:51,880
saying like I would estimate that one

00:08:51,600 --> 00:08:55,750
out

00:08:51,880 --> 00:08:57,310
of ten hardware or crutches or do you

00:08:55,750 --> 00:08:59,070
know what's passing as housing as you're

00:08:57,310 --> 00:09:01,900
sending random data to your hardware and

00:08:59,070 --> 00:09:04,810
severe head crush and I guess like one

00:09:01,900 --> 00:09:08,620
out of ten crushes you can actually

00:09:04,810 --> 00:09:11,830
transfer you can create an exploit out

00:09:08,620 --> 00:09:14,260
of that and then there are other sites

00:09:11,830 --> 00:09:16,150
on our text like timing attacks for

00:09:14,260 --> 00:09:18,010
example if you have a computation which

00:09:16,150 --> 00:09:21,460
depends on the value of the secret data

00:09:18,010 --> 00:09:23,230
for example you are Cal your you have

00:09:21,460 --> 00:09:25,120
your secret and you have the user input

00:09:23,230 --> 00:09:27,610
and you are comparing the first

00:09:25,120 --> 00:09:29,740
character and do a break out of your

00:09:27,610 --> 00:09:32,260
vial loop if it's not correct than the

00:09:29,740 --> 00:09:34,570
second character and so on so it means

00:09:32,260 --> 00:09:37,810
like the more characters we have right

00:09:34,570 --> 00:09:40,390
as an attacker the more time it will

00:09:37,810 --> 00:09:42,700
take for the device to respond and so

00:09:40,390 --> 00:09:46,060
you can brute force one character after

00:09:42,700 --> 00:09:48,340
another in this manner also cache miss

00:09:46,060 --> 00:09:50,800
and cache it times have a huge timing

00:09:48,340 --> 00:09:53,130
difference so which is also used for

00:09:50,800 --> 00:09:56,470
example and specular Metro in those

00:09:53,130 --> 00:10:00,250
cache timing attacks so you can always

00:09:56,470 --> 00:10:03,280
find a pattern in those different timing

00:10:00,250 --> 00:10:05,170
differences so basically in this kind of

00:10:03,280 --> 00:10:07,690
attack you trace instructions you axe

00:10:05,170 --> 00:10:10,600
your excess register values you can

00:10:07,690 --> 00:10:12,460
modify media called memory content or

00:10:10,600 --> 00:10:16,890
extract code and data but you're not

00:10:12,460 --> 00:10:16,890
actually physically opening up the chip

00:10:17,280 --> 00:10:23,020
yeah other non invasive attacks like

00:10:20,290 --> 00:10:25,300
site X for example heartbeat whooshing

00:10:23,020 --> 00:10:28,210
is when you apply a voltage which is too

00:10:25,300 --> 00:10:30,520
high or too low or higher or lower than

00:10:28,210 --> 00:10:33,550
what's your chip originally expected and

00:10:30,520 --> 00:10:36,430
you hope for funny effect or that your

00:10:33,550 --> 00:10:38,320
chip calculates any manner which is not

00:10:36,430 --> 00:10:41,260
expected and makes a mistake and you can

00:10:38,320 --> 00:10:43,240
use that to heck it or get more

00:10:41,260 --> 00:10:46,330
information about the secret there's

00:10:43,240 --> 00:10:48,160
also glitching attacks work and out of

00:10:46,330 --> 00:10:51,820
the clock period during the execution of

00:10:48,160 --> 00:10:54,880
a program and have similar effect the

00:10:51,820 --> 00:10:56,980
nearest power noses if the power

00:10:54,880 --> 00:10:59,350
consumption of your device depends on

00:10:56,980 --> 00:11:02,530
the secret data which is computed in

00:10:59,350 --> 00:11:04,390
that moment you can get information from

00:11:02,530 --> 00:11:06,790
that and I will be presenting an attack

00:11:04,390 --> 00:11:08,589
and that later just simple power

00:11:06,790 --> 00:11:10,630
analysis where you're directly looking

00:11:08,589 --> 00:11:12,490
at the power traces but there's also

00:11:10,630 --> 00:11:14,560
differential power analysis where you

00:11:12,490 --> 00:11:17,980
kind of correlate the power traces you

00:11:14,560 --> 00:11:23,620
took and if your correlation criteria is

00:11:17,980 --> 00:11:26,350
right you get a pink in your right

00:11:23,620 --> 00:11:28,779
there's also a em radiation general

00:11:26,350 --> 00:11:31,180
attacks or acoustic channels so all

00:11:28,779 --> 00:11:33,339
these side effects of a computation you

00:11:31,180 --> 00:11:38,589
can try to find a pattern and get more

00:11:33,339 --> 00:11:40,269
information about the secret then there

00:11:38,589 --> 00:11:44,019
are semi invasive attacks where you

00:11:40,269 --> 00:11:47,680
actually cap a package and then you can

00:11:44,019 --> 00:11:50,140
shine infrared light onto this chip and

00:11:47,680 --> 00:11:54,610
with a certain probability a gate which

00:11:50,140 --> 00:11:56,110
switches will emit a photon and in this

00:11:54,610 --> 00:11:58,390
manner you can't find a location for

00:11:56,110 --> 00:11:59,110
your attack for example the picture we

00:11:58,390 --> 00:12:02,290
saw before

00:11:59,110 --> 00:12:04,420
here you see emitted photon from from

00:12:02,290 --> 00:12:06,880
your chips and you can assume that the

00:12:04,420 --> 00:12:08,200
brighter areas are gates which are

00:12:06,880 --> 00:12:10,180
switching a lot for example the

00:12:08,200 --> 00:12:14,050
brightest spot you see on the left would

00:12:10,180 --> 00:12:22,839
be the clock or at the airport for

00:12:14,050 --> 00:12:24,670
example memory address exercies but the

00:12:22,839 --> 00:12:26,740
problem with laser clashing is you don't

00:12:24,670 --> 00:12:28,060
you have an unknown timing it's more or

00:12:26,740 --> 00:12:30,040
less trial and error because you're

00:12:28,060 --> 00:12:34,079
shooting this laser on a big area and

00:12:30,040 --> 00:12:39,010
you hope that chip does an error in his

00:12:34,079 --> 00:12:41,980
calculation so if semi invasive attacks

00:12:39,010 --> 00:12:44,500
didn't work then you can try fully

00:12:41,980 --> 00:12:47,709
invasive attacks which require much more

00:12:44,500 --> 00:12:50,490
effort but you have a 100% success rate

00:12:47,709 --> 00:12:53,500
so you can use a focus iron beam to

00:12:50,490 --> 00:12:56,890
remove or put material on the chip and

00:12:53,500 --> 00:12:59,290
for example create micro probing yeah

00:12:56,890 --> 00:13:01,959
probing paths so basically you can

00:12:59,290 --> 00:13:04,300
allows any pet or any signal in your

00:13:01,959 --> 00:13:06,790
chip you want but obviously it's much

00:13:04,300 --> 00:13:10,029
more it costs much more it takes more

00:13:06,790 --> 00:13:13,120
time and knowledge to do that but fully

00:13:10,029 --> 00:13:14,920
invasive attack I mainly used if you

00:13:13,120 --> 00:13:18,390
have counter measures put in place and

00:13:14,920 --> 00:13:18,390
hardware and you want to circumvent it

00:13:19,839 --> 00:13:28,149
so mainly for the non-invasive attacks

00:13:24,769 --> 00:13:31,639
those are the tools which are used the

00:13:28,149 --> 00:13:33,649
otoscope for just looking at logic

00:13:31,639 --> 00:13:36,440
signals or another chick analyzer if you

00:13:33,649 --> 00:13:38,420
want to analyze you are for example then

00:13:36,440 --> 00:13:40,730
for jtech there are good open source

00:13:38,420 --> 00:13:43,720
alternatives as well for example the

00:13:40,730 --> 00:13:45,949
good fat created by choice good speed or

00:13:43,720 --> 00:13:49,399
I've heard many good things about the

00:13:45,949 --> 00:13:51,649
blackmagic probe in front the year side

00:13:49,399 --> 00:13:53,329
channel attacks I mentioned like power

00:13:51,649 --> 00:13:55,760
glitching and so on

00:13:53,329 --> 00:13:58,730
two years ago you had to make your own

00:13:55,760 --> 00:13:59,959
set up using an FPGA because that was

00:13:58,730 --> 00:14:03,050
the only thing which would get the

00:13:59,959 --> 00:14:04,370
timing right but nowadays you can take

00:14:03,050 --> 00:14:06,740
the chest chip Whisperer

00:14:04,370 --> 00:14:10,519
to do the coaching and partners for you

00:14:06,740 --> 00:14:12,649
out of the box you can use the face 10

00:14:10,519 --> 00:14:16,850
services which is based on the good fat

00:14:12,649 --> 00:14:19,699
to do some host site Titan scripting and

00:14:16,850 --> 00:14:22,339
to fastest your device you use P device

00:14:19,699 --> 00:14:24,589
drivers and if you want to do SDR

00:14:22,339 --> 00:14:26,930
software-defined radio there are the

00:14:24,589 --> 00:14:29,750
heck RF and actually more devices which

00:14:26,930 --> 00:14:32,660
I didn't list here that you can use the

00:14:29,750 --> 00:14:34,639
RF it's a great Scot gadgets device

00:14:32,660 --> 00:14:40,069
which can send and receive from one

00:14:34,639 --> 00:14:41,569
megahertz for 6 gigahertz so let's go

00:14:40,069 --> 00:14:44,209
through some real world attacks this

00:14:41,569 --> 00:14:45,709
work theory now let's go to practice so

00:14:44,209 --> 00:14:47,569
there was this nice video which i really

00:14:45,709 --> 00:14:49,880
recommend to you which is called heck

00:14:47,569 --> 00:14:52,910
all the things and 20 devices and 45

00:14:49,880 --> 00:14:56,720
minutes but they presented how they yeah

00:14:52,910 --> 00:14:59,209
on 20 devices pretty fast in a very

00:14:56,720 --> 00:15:01,880
entertaining manner so one of the common

00:14:59,209 --> 00:15:04,610
attacks was just connecting to UART and

00:15:01,880 --> 00:15:09,139
oftentimes you just put into a console

00:15:04,610 --> 00:15:10,839
where you have no password or password

00:15:09,139 --> 00:15:15,410
which you can guess easily and you can

00:15:10,839 --> 00:15:19,779
replace the image devices running using

00:15:15,410 --> 00:15:22,519
this console sometimes the UART is

00:15:19,779 --> 00:15:24,410
populated sometimes it's not but even if

00:15:22,519 --> 00:15:26,750
it's not populate you can easily just

00:15:24,410 --> 00:15:29,020
put your own connector on it soldered on

00:15:26,750 --> 00:15:30,320
the board

00:15:29,020 --> 00:15:33,900
[Applause]

00:15:30,320 --> 00:15:35,310
what else did it was for example change

00:15:33,900 --> 00:15:39,570
some parameters of the kernel

00:15:35,310 --> 00:15:41,370
command-line like if for example like

00:15:39,570 --> 00:15:43,320
when you've locked yourself out of your

00:15:41,370 --> 00:15:45,750
computer you boot it up and you put in

00:15:43,320 --> 00:15:47,610
it equals business H into the kernel

00:15:45,750 --> 00:15:50,370
command line and food directly boot up

00:15:47,610 --> 00:15:53,010
into a shell and from here you can ER

00:15:50,370 --> 00:15:57,300
mount devices you can replace the image

00:15:53,010 --> 00:15:59,940
and put your own further also a boot

00:15:57,300 --> 00:16:02,280
loaders they try to execute a

00:15:59,940 --> 00:16:04,260
pre-configured script and you can just

00:16:02,280 --> 00:16:06,440
if you have access to the memory you can

00:16:04,260 --> 00:16:09,150
just put a script with the same name

00:16:06,440 --> 00:16:13,740
instead of that and it will boot up with

00:16:09,150 --> 00:16:16,950
your firmware for attack which if those

00:16:13,740 --> 00:16:19,200
who don't work you can try to short the

00:16:16,950 --> 00:16:22,050
pins of the nand which contains input

00:16:19,200 --> 00:16:24,240
loader and maybe one out of ten times it

00:16:22,050 --> 00:16:25,950
will route up into a corrupted you put

00:16:24,240 --> 00:16:28,590
environment but you have control and you

00:16:25,950 --> 00:16:30,630
can again replace a further because the

00:16:28,590 --> 00:16:32,940
thing for the attackers you just have to

00:16:30,630 --> 00:16:36,750
get it right one out of 100 times and

00:16:32,940 --> 00:16:39,030
you heck to your device as a defender

00:16:36,750 --> 00:16:43,100
you actually have to get a right 100

00:16:39,030 --> 00:16:46,430
times or your device it's corrupt

00:16:43,100 --> 00:16:49,740
sometimes they analyze the fervor and

00:16:46,430 --> 00:16:52,260
they found hard-coded or basic Saphir of

00:16:49,740 --> 00:16:54,720
64 encoded usernames and passwords of

00:16:52,260 --> 00:16:56,850
the binary yeah basics before it's not

00:16:54,720 --> 00:17:00,480
encryption it's just encoding it's

00:16:56,850 --> 00:17:02,490
basically easy to decipher also brute

00:17:00,480 --> 00:17:04,890
forcing worked and some devices because

00:17:02,490 --> 00:17:07,560
um many manufacturers would just use

00:17:04,890 --> 00:17:14,630
root and manufacturer name as a password

00:17:07,560 --> 00:17:18,930
so you can easily get in what else and

00:17:14,630 --> 00:17:22,650
they had access to an EMC or they wrote

00:17:18,930 --> 00:17:25,589
as your D binary on the EMC which uses a

00:17:22,650 --> 00:17:28,140
similar protocol to whatever n SD card

00:17:25,589 --> 00:17:30,690
readers using and afterwards takes

00:17:28,140 --> 00:17:35,520
executed CSV binary on the device and

00:17:30,690 --> 00:17:38,730
got routed that way other devices they

00:17:35,520 --> 00:17:40,230
took user input unsanitized and put it

00:17:38,730 --> 00:17:42,570
into a system

00:17:40,230 --> 00:17:44,970
function for example and obviously if

00:17:42,570 --> 00:17:47,549
you put semi-cool on reboot semicolon

00:17:44,970 --> 00:17:49,889
your device will reboot and you can put

00:17:47,549 --> 00:17:55,080
any system command or best commands you

00:17:49,889 --> 00:17:57,869
want in that often WEP or Wi-Fi password

00:17:55,080 --> 00:17:59,730
fields of the configuration page were

00:17:57,869 --> 00:18:01,919
not sanitized it would just take

00:17:59,730 --> 00:18:06,659
whatever you give to it or network

00:18:01,919 --> 00:18:08,460
folder names who would put any commands

00:18:06,659 --> 00:18:12,869
into a network folder name right there

00:18:08,460 --> 00:18:14,999
trustworthy or URL parameters sometimes

00:18:12,869 --> 00:18:20,429
they could just execute a command by

00:18:14,999 --> 00:18:22,049
just passing it to another URL also if I

00:18:20,429 --> 00:18:24,059
my update takes place over an

00:18:22,049 --> 00:18:27,119
unencrypted channel for example just

00:18:24,059 --> 00:18:29,100
plain HTTP or FTP it can be intercepted

00:18:27,119 --> 00:18:31,590
they can put a man in the middle attack

00:18:29,100 --> 00:18:34,049
in place so you send your fervor I

00:18:31,590 --> 00:18:36,080
modify it and I sent it further to the

00:18:34,049 --> 00:18:41,700
device you want to update and well I

00:18:36,080 --> 00:18:44,970
control the device now then this one was

00:18:41,700 --> 00:18:47,340
an a rather academic attack they

00:18:44,970 --> 00:18:48,659
attacked a PLC a programmable logic

00:18:47,340 --> 00:18:52,200
controller which is used a lot in

00:18:48,659 --> 00:18:55,379
industry and they tried to downgrade to

00:18:52,200 --> 00:18:58,019
an older firmware version but it didn't

00:18:55,379 --> 00:19:00,570
work it didn't let them do that they

00:18:58,019 --> 00:19:01,919
search for jtech or something similar

00:19:00,570 --> 00:19:04,409
they didn't find it on the board

00:19:01,919 --> 00:19:06,659
they tried injecting code on the webpage

00:19:04,409 --> 00:19:09,419
of the manufacturer to do a firmware

00:19:06,659 --> 00:19:11,700
update and put their firmware on this

00:19:09,419 --> 00:19:14,309
device but it didn't work they assumed

00:19:11,700 --> 00:19:16,409
that maybe it affirmative was there was

00:19:14,309 --> 00:19:18,749
a checksum over the firmware or differ

00:19:16,409 --> 00:19:21,029
ever signed so that's why it was not not

00:19:18,749 --> 00:19:26,070
taken so they ended up actually

00:19:21,029 --> 00:19:27,179
modifying the port so the flash tab

00:19:26,070 --> 00:19:28,619
which contained the first-stage

00:19:27,179 --> 00:19:32,009
bootloader

00:19:28,619 --> 00:19:36,029
was right protected using a pin and a

00:19:32,009 --> 00:19:44,039
disorder discipline and could alter any

00:19:36,029 --> 00:19:46,619
data on this on this flash chip then

00:19:44,039 --> 00:19:49,169
there was an attack on an electronic

00:19:46,619 --> 00:19:53,520
safe lock file or which was presented at

00:19:49,169 --> 00:19:55,710
Def Con 24 so what he had was

00:19:53,520 --> 00:19:57,930
a metal box and outside of this metal

00:19:55,710 --> 00:20:00,420
box he would have a keypad a buzzer in

00:19:57,930 --> 00:20:02,370
the battery and inside behind steel

00:20:00,420 --> 00:20:06,150
doors there was a lock and amps you an

00:20:02,370 --> 00:20:07,830
EEPROM and a boat motor so and between

00:20:06,150 --> 00:20:09,330
those two inside and outside there was

00:20:07,830 --> 00:20:13,380
just one hole to pass the wire through

00:20:09,330 --> 00:20:15,390
and the good thing was that inside the

00:20:13,380 --> 00:20:18,450
MCU and the EEPROM they were connected

00:20:15,390 --> 00:20:22,980
by a direct line which was connected to

00:20:18,450 --> 00:20:25,520
a pole pull up so every time the device

00:20:22,980 --> 00:20:27,810
would reach zero from the EEPROM the

00:20:25,520 --> 00:20:30,150
voltage drop over the pull-up would be

00:20:27,810 --> 00:20:34,560
higher so he could record a higher

00:20:30,150 --> 00:20:36,510
current from taken from the battery so

00:20:34,560 --> 00:20:38,850
he could look at the power trace

00:20:36,510 --> 00:20:43,080
directly and say okay this one is a zero

00:20:38,850 --> 00:20:46,800
just one it's the one so how can you

00:20:43,080 --> 00:20:49,800
mitigate this kind of attack yeah so he

00:20:46,800 --> 00:20:51,960
would put any any combination of numbers

00:20:49,800 --> 00:20:55,680
in there he would read on the power

00:20:51,960 --> 00:20:58,740
trace the real secret which was read out

00:20:55,680 --> 00:21:00,980
from the EEPROM and he could put in that

00:20:58,740 --> 00:21:03,900
real secret afterwards and you can

00:21:00,980 --> 00:21:06,540
protect yourself getting against those

00:21:03,900 --> 00:21:09,780
kind of attack by for example storing Z

00:21:06,540 --> 00:21:11,640
hash instead of the real secret so the

00:21:09,780 --> 00:21:13,920
attacker can just seize your hash but it

00:21:11,640 --> 00:21:18,150
doesn't first he doesn't possibly know

00:21:13,920 --> 00:21:18,960
how he has calculated and the second

00:21:18,150 --> 00:21:21,090
attack he did

00:21:18,960 --> 00:21:23,970
so this easy attack didn't work on this

00:21:21,090 --> 00:21:25,740
block so he did timing attack they're

00:21:23,970 --> 00:21:27,690
gonna I described before but you have

00:21:25,740 --> 00:21:31,680
this while loop where you compare the

00:21:27,690 --> 00:21:34,170
real secret character to the user input

00:21:31,680 --> 00:21:36,060
one by one and if there's one mismatch

00:21:34,170 --> 00:21:39,480
between characters encountered you just

00:21:36,060 --> 00:21:41,700
break out of the loop so you see it in

00:21:39,480 --> 00:21:44,640
the power trace the more characters you

00:21:41,700 --> 00:21:45,150
get right the mortgages he entered were

00:21:44,640 --> 00:21:47,310
correct

00:21:45,150 --> 00:21:50,310
the longer it took for the lock to

00:21:47,310 --> 00:21:52,320
respond the problem this case was after

00:21:50,310 --> 00:21:52,710
five tries he got locked out for ten

00:21:52,320 --> 00:21:55,230
minutes

00:21:52,710 --> 00:21:57,840
so brute forcing is not so easy if you

00:21:55,230 --> 00:22:00,960
have to wait ten minutes between a tries

00:21:57,840 --> 00:22:03,120
but you get lucky because no way an

00:22:00,960 --> 00:22:03,779
EEPROM if you reset it it would be reset

00:22:03,120 --> 00:22:07,289
to zero

00:22:03,779 --> 00:22:17,340
F F so everything is one but in this

00:22:07,289 --> 00:22:23,129
case EEPROM in this case the EEPROM was

00:22:17,340 --> 00:22:25,469
an STM 8's so when you reset it

00:22:23,129 --> 00:22:28,950
it was reset to zero so he had this

00:22:25,469 --> 00:22:33,690
small time window of 500 microseconds

00:22:28,950 --> 00:22:35,820
after or and he count the number of

00:22:33,690 --> 00:22:38,879
tries he performed for stored and EEPROM

00:22:35,820 --> 00:22:43,619
as well so in order to write a new

00:22:38,879 --> 00:22:45,149
counter value in the EEPROM the counter

00:22:43,619 --> 00:22:47,539
is set to zero before it's in an

00:22:45,149 --> 00:22:50,849
initialized as a new value so he had a

00:22:47,539 --> 00:22:53,489
500 microseconds timeframe after the

00:22:50,849 --> 00:22:56,129
write starts where this counter would be

00:22:53,489 --> 00:22:57,839
at zero and if he applied the brownout

00:22:56,129 --> 00:23:00,179
voltage exactly at this moment in time

00:22:57,839 --> 00:23:02,609
he would have gained infant amount of

00:23:00,179 --> 00:23:05,070
tries because the counter would be reset

00:23:02,609 --> 00:23:09,029
to zero and how can you imagine gate

00:23:05,070 --> 00:23:12,119
against this attack you can do constant

00:23:09,029 --> 00:23:14,669
time comparisons so basically you check

00:23:12,119 --> 00:23:17,339
all the values and then you give back

00:23:14,669 --> 00:23:20,609
better the key code entered was correct

00:23:17,339 --> 00:23:22,349
or not or using hash secrets so you

00:23:20,609 --> 00:23:24,179
actually have to wait for all the inputs

00:23:22,349 --> 00:23:28,289
from the user you calculate and then you

00:23:24,179 --> 00:23:32,219
compare so another question is how do

00:23:28,289 --> 00:23:34,109
you protect against that well you can

00:23:32,219 --> 00:23:37,190
start with protecting and buffer

00:23:34,109 --> 00:23:41,849
overflow stack overflows heat overflows

00:23:37,190 --> 00:23:43,669
by comparing rigorously the buffer

00:23:41,849 --> 00:23:46,919
bounds

00:23:43,669 --> 00:23:52,080
don't use the unknown unsafe functions

00:23:46,919 --> 00:23:54,059
like gets or string compare you see

00:23:52,080 --> 00:23:56,339
safer functions like F Guetta's or

00:23:54,059 --> 00:23:59,609
string and compare which takes into

00:23:56,339 --> 00:24:01,469
account the buffer size the many

00:23:59,609 --> 00:24:05,249
compilers have secure compiler flags

00:24:01,469 --> 00:24:09,389
where you can disable or enable the

00:24:05,249 --> 00:24:12,960
annex bit of the stack so these deck

00:24:09,389 --> 00:24:16,139
becomes non-executable you can activity

00:24:12,960 --> 00:24:17,120
stack protection and so on also build

00:24:16,139 --> 00:24:20,150
systems like your

00:24:17,120 --> 00:24:22,700
- and the truth we'll have flex for that

00:24:20,150 --> 00:24:25,310
or you can enable it in your there are

00:24:22,700 --> 00:24:28,360
some secure options in in the corner

00:24:25,310 --> 00:24:33,680
which you can enable by our menu config

00:24:28,360 --> 00:24:36,740
then if your device has a web server you

00:24:33,680 --> 00:24:39,290
should protect against SQL injections or

00:24:36,740 --> 00:24:40,730
cross-site scripting instead of

00:24:39,290 --> 00:24:41,990
blacklist in commands you should

00:24:40,730 --> 00:24:43,190
whitelist your commands

00:24:41,990 --> 00:24:48,380
because you should never underestimate

00:24:43,190 --> 00:24:50,240
the creativity of an attacker and never

00:24:48,380 --> 00:24:53,330
directly take user input and put it in

00:24:50,240 --> 00:24:55,190
system or something always sanitize

00:24:53,330 --> 00:25:02,990
always validate input coming from the

00:24:55,190 --> 00:25:05,360
user don't trust user input ever so if

00:25:02,990 --> 00:25:07,520
you do firmware updates always do it

00:25:05,360 --> 00:25:10,400
over a secure Channel overdo it

00:25:07,520 --> 00:25:12,410
obviously over TLS because otherwise

00:25:10,400 --> 00:25:15,830
yeah you can just mend the middle this

00:25:12,410 --> 00:25:17,300
update don't don't do your own crypto

00:25:15,830 --> 00:25:20,000
there are so many libraries which you

00:25:17,300 --> 00:25:25,640
can use where many eyes have looked over

00:25:20,000 --> 00:25:28,610
and which are tests or yeah tested by

00:25:25,640 --> 00:25:32,810
many people don't rule your don't

00:25:28,610 --> 00:25:34,970
reinvent your crypto real maybe also

00:25:32,810 --> 00:25:37,190
implement an empty rollback protection

00:25:34,970 --> 00:25:42,500
because often older farmers have known

00:25:37,190 --> 00:25:46,070
bugs and a hacker could just reinstall

00:25:42,500 --> 00:25:47,720
an older version and applied the box

00:25:46,070 --> 00:25:53,390
which were box two years ago five years

00:25:47,720 --> 00:25:58,010
ago don't have hard coded secrets in

00:25:53,390 --> 00:25:59,720
your forever always um don't put

00:25:58,010 --> 00:26:01,460
usernames and passwords and so on as

00:25:59,720 --> 00:26:03,920
hard coded secrets enter your server or

00:26:01,460 --> 00:26:07,040
in unprotected storage like for example

00:26:03,920 --> 00:26:09,860
EEPROM of flesh is not safe storage you

00:26:07,040 --> 00:26:12,380
should put your keys in there and if you

00:26:09,860 --> 00:26:14,180
do or if your platform has a trusted

00:26:12,380 --> 00:26:15,620
execution environment like trust own

00:26:14,180 --> 00:26:19,370
forearm or STX

00:26:15,620 --> 00:26:22,180
for Intel we should try to use that the

00:26:19,370 --> 00:26:25,010
Identity Management have different user

00:26:22,180 --> 00:26:28,799
have different accounts for web

00:26:25,010 --> 00:26:31,619
management and for remote console access

00:26:28,799 --> 00:26:33,989
don't pour tokens and ID's and cookies

00:26:31,619 --> 00:26:36,269
enter URL because the attacker can just

00:26:33,989 --> 00:26:38,519
live it and replay it especially and

00:26:36,269 --> 00:26:41,070
don't use tokens which can easily be get

00:26:38,519 --> 00:26:43,980
like sequential numbers 1 2 3 is not a

00:26:41,070 --> 00:26:48,659
secure token or current time it's not a

00:26:43,980 --> 00:26:51,419
secure token you can guess that use

00:26:48,659 --> 00:26:53,970
secure passwords for logins for the UART

00:26:51,419 --> 00:26:56,100
for example and in the best case you

00:26:53,970 --> 00:26:59,129
would have an individual secret for each

00:26:56,100 --> 00:27:01,139
device to deliver because otherwise one

00:26:59,129 --> 00:27:03,389
device gets hacked all your devices are

00:27:01,139 --> 00:27:07,830
compromised if you have one password per

00:27:03,389 --> 00:27:10,109
device it's only this one then how many

00:27:07,830 --> 00:27:11,580
of us have unused language or shell

00:27:10,109 --> 00:27:14,190
interpreters in our devices

00:27:11,580 --> 00:27:15,989
how many bash and dash an - and that is

00:27:14,190 --> 00:27:19,409
H we have in this devices which we never

00:27:15,989 --> 00:27:22,859
use or libraries the more attack surface

00:27:19,409 --> 00:27:25,350
and attacker has the more tools you will

00:27:22,859 --> 00:27:26,840
find to exploit the device so reducing

00:27:25,350 --> 00:27:30,570
the attack surface is one of the

00:27:26,840 --> 00:27:33,119
protections against hacking also disable

00:27:30,570 --> 00:27:35,700
ancient and ancient and legacy legacy

00:27:33,119 --> 00:27:37,230
protocols like FTP and telnet you would

00:27:35,700 --> 00:27:41,249
be surprised how many devices are out

00:27:37,230 --> 00:27:42,659
there which still use that removed

00:27:41,249 --> 00:27:46,710
debugging interfaces because a hacker

00:27:42,659 --> 00:27:48,239
can also enter from there and also many

00:27:46,710 --> 00:27:51,210
factors often have those management

00:27:48,239 --> 00:27:53,909
interfaces where they can do customer

00:27:51,210 --> 00:27:57,809
support where they have either and very

00:27:53,909 --> 00:28:00,960
easily possible password or no password

00:27:57,809 --> 00:28:04,470
at all and oftentimes those interfaces

00:28:00,960 --> 00:28:07,259
come with root privilege yeah if

00:28:04,470 --> 00:28:08,879
possible check third party core code and

00:28:07,259 --> 00:28:12,259
SDKs I don't know whether it's always

00:28:08,879 --> 00:28:14,580
possible data tools you can use for that

00:28:12,259 --> 00:28:17,070
keep your kernel your frameworks your

00:28:14,580 --> 00:28:19,950
libraries up to date for example using a

00:28:17,070 --> 00:28:22,080
package manager and check whether the

00:28:19,950 --> 00:28:24,269
you tools you use are vulnerable there

00:28:22,080 --> 00:28:26,970
are many vulnerability databases and you

00:28:24,269 --> 00:28:28,850
just enter a diversion of your two-year

00:28:26,970 --> 00:28:32,090
using and see whether it has known

00:28:28,850 --> 00:28:36,509
vulnerabilities or you use one of the

00:28:32,090 --> 00:28:39,899
tools recommended by all ASP in order to

00:28:36,509 --> 00:28:41,020
check third-party code or components or

00:28:39,899 --> 00:28:43,330
do something

00:28:41,020 --> 00:28:47,590
take analysis on it and it will tell you

00:28:43,330 --> 00:28:50,620
where there might be possible bugs and

00:28:47,590 --> 00:28:55,150
your threat modeling like getting the

00:28:50,620 --> 00:28:58,000
shoes of an attacker and think how

00:28:55,150 --> 00:29:00,250
through which port can you enter like

00:28:58,000 --> 00:29:03,790
what are the possible vulnerable parts

00:29:00,250 --> 00:29:05,950
of your device and once you your device

00:29:03,790 --> 00:29:07,990
gets compromised how do you treat with

00:29:05,950 --> 00:29:13,120
it how do you how do you contain the

00:29:07,990 --> 00:29:15,970
damage which is done so if you didn't

00:29:13,120 --> 00:29:18,760
take an anything from this lecture

00:29:15,970 --> 00:29:21,040
maybe those points so the main attack

00:29:18,760 --> 00:29:23,890
vectors for devices are crypto or the

00:29:21,040 --> 00:29:29,740
evap interface or old firmware that

00:29:23,890 --> 00:29:31,180
still has bugs from 2000 or doing it

00:29:29,740 --> 00:29:33,340
from the update process over an

00:29:31,180 --> 00:29:38,410
unencrypted Channel or having clear text

00:29:33,340 --> 00:29:42,640
passwords and your binary or storing

00:29:38,410 --> 00:29:45,340
secrets in an unprotected place and so

00:29:42,640 --> 00:29:46,960
maybe it's a good idea to integrate

00:29:45,340 --> 00:29:48,520
security tests already in your

00:29:46,960 --> 00:29:51,280
continuous integration or your

00:29:48,520 --> 00:29:53,050
development cycle instead of in the end

00:29:51,280 --> 00:29:55,750
after your product is finished and ready

00:29:53,050 --> 00:29:57,610
to be shipped to find some security

00:29:55,750 --> 00:30:01,510
vulnerabilities and not have the time to

00:29:57,610 --> 00:30:05,410
fix it afterwards and also there's

00:30:01,510 --> 00:30:09,190
basically not a wave how you can really

00:30:05,410 --> 00:30:13,270
secure your system 100% it just makes it

00:30:09,190 --> 00:30:15,190
harder for the attacker or more so that

00:30:13,270 --> 00:30:16,630
he would have to invest more cost or

00:30:15,190 --> 00:30:18,730
more time in order to hack your device

00:30:16,630 --> 00:30:21,010
but it's never impossible you just try

00:30:18,730 --> 00:30:22,840
to get the bar as high as possible so

00:30:21,010 --> 00:30:26,950
basically that we he will attack the

00:30:22,840 --> 00:30:28,930
other manufacturer not you so do you

00:30:26,950 --> 00:30:29,530
have any thank you for for listening to

00:30:28,930 --> 00:30:34,590
me

00:30:29,530 --> 00:30:34,590
renting and do you have any questions

00:30:45,680 --> 00:30:48,280
so

00:30:50,490 --> 00:30:54,340
hello

00:30:52,030 --> 00:30:57,039
so you recommended each device having

00:30:54,340 --> 00:30:59,890
their own secret for the keys and such

00:30:57,039 --> 00:31:01,960
and I agree that's a great idea do you

00:30:59,890 --> 00:31:04,809
have any suggestions on tools to help

00:31:01,960 --> 00:31:08,130
manage like thousands or tens of

00:31:04,809 --> 00:31:14,230
thousands of keys across out there I

00:31:08,130 --> 00:31:17,860
didn't try out anything but maybe mentor

00:31:14,230 --> 00:31:20,440
since they have tools to to Ferrari

00:31:17,860 --> 00:31:22,299
update processes securely maybe they

00:31:20,440 --> 00:31:24,940
have a solution for that but I don't

00:31:22,299 --> 00:31:29,140
know you would have to talk to them yeah

00:31:24,940 --> 00:31:31,030
I know more of the attacker side and

00:31:29,140 --> 00:31:36,960
actually how to protect us because it's

00:31:31,030 --> 00:31:36,960
really hard to protect okay thank you

00:31:37,620 --> 00:31:47,170
more questions okay thank you

00:31:43,990 --> 00:31:47,170

YouTube URL: https://www.youtube.com/watch?v=vKZVbX-hNyE


