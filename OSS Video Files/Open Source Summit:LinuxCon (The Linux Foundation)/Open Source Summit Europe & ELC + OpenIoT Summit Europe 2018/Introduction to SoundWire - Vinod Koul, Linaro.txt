Title: Introduction to SoundWire - Vinod Koul, Linaro
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Introduction to SoundWire - Vinod Koul, Linaro

SoundWire is a new MIPI Audio Interface specification. It specifies a low complexity, low power, low latency, two-pin (clock and data), multi-drop bus that allows for the transfer of multiple audio streams along with embedded control/command information.

This protocol is intended to eventually replace HDA and I2S in PCs and embedded systems.

We explore the details of the recently added SoundWire Linux subsystem (merged into Linux 4.16) to help people get introduced to SoundWire and speed up the adoption of this new bus. We explain the SoundWire bus, interfaces and changes required by the existing device drivers in order to add SoundWire support. We also explore the enumeration methods used for different architectures. 

About Vinod Koul
Vinod works for Linaro and is focussed in upstreaming for Qualcomm platforms. In past Vinod has worked on Audio for Intel.

Vinod is the maintainer of Linux dmaengine subsystem, SoundWire subsystem. He also wrote and maintains the ALSA compressed audio framework and user library.
Captions: 
	00:00:00,560 --> 00:00:05,250
hello everybody welcome to this talk

00:00:03,000 --> 00:00:09,150
about sound well my name is Vinod Cole I

00:00:05,250 --> 00:00:11,130
work for Lennar oh and I maintain sound

00:00:09,150 --> 00:00:13,049
we're a subsystem and Linux kernel along

00:00:11,130 --> 00:00:16,080
with some other bits like dma engine and

00:00:13,049 --> 00:00:17,900
some audio stuff so sound where is one

00:00:16,080 --> 00:00:20,070
of the new protocols which has been

00:00:17,900 --> 00:00:23,490
being developed by the maybe it's a

00:00:20,070 --> 00:00:25,560
maybe standard and I wrote the initial

00:00:23,490 --> 00:00:27,869
bus framework for that and we exchanged

00:00:25,560 --> 00:00:31,410
it so we're going to talk about that a

00:00:27,869 --> 00:00:34,110
little bit so to start with the agenda

00:00:31,410 --> 00:00:35,820
is basically we'll go on why sound wire

00:00:34,110 --> 00:00:38,790
and what it tries to solve which is not

00:00:35,820 --> 00:00:41,760
kind of done by the existing audio

00:00:38,790 --> 00:00:43,980
protocols available out there then we'll

00:00:41,760 --> 00:00:46,980
move to the bit of topologies kind of

00:00:43,980 --> 00:00:48,719
build up how sound where it was and how

00:00:46,980 --> 00:00:50,670
somewhere tries to do things differently

00:00:48,719 --> 00:00:52,980
as compared all this stuff and then

00:00:50,670 --> 00:00:54,870
we'll move into the protocols kind of

00:00:52,980 --> 00:00:56,190
try to skim the surface of protocol it's

00:00:54,870 --> 00:00:58,770
quite vast protocol and quite

00:00:56,190 --> 00:01:00,570
complicated in fact in my opinion well

00:00:58,770 --> 00:01:02,969
then it won't be you know we can do

00:01:00,570 --> 00:01:04,860
justice to it in next 3040 minutes so

00:01:02,969 --> 00:01:08,340
we'll just skim the surface introduce

00:01:04,860 --> 00:01:11,970
the topics of it and then move over to

00:01:08,340 --> 00:01:16,070
the Linux subsystem introduce the api's

00:01:11,970 --> 00:01:18,750
bit and data structures a bit standards

00:01:16,070 --> 00:01:20,700
we all know there are always end member

00:01:18,750 --> 00:01:24,180
standards we try to solve that with n

00:01:20,700 --> 00:01:27,180
plus 1 standard and then it becomes n

00:01:24,180 --> 00:01:29,310
plus 1 standard so hopefully sound we're

00:01:27,180 --> 00:01:32,310
will not be like that as we always try

00:01:29,310 --> 00:01:34,049
to wish but we'll see how it pans out in

00:01:32,310 --> 00:01:36,329
the future that has been quite decent

00:01:34,049 --> 00:01:39,450
interest in both SOC folks as well as

00:01:36,329 --> 00:01:42,210
codec vendor folks so probably will see

00:01:39,450 --> 00:01:44,790
devices shipping sound we're probably

00:01:42,210 --> 00:01:49,290
next year and motor adoption by the

00:01:44,790 --> 00:01:51,630
vendors so in comparison to the existing

00:01:49,290 --> 00:01:53,790
audio standards first what comes to your

00:01:51,630 --> 00:01:55,560
mind is HD audio this is something which

00:01:53,790 --> 00:01:58,890
probably run on your laptop or your

00:01:55,560 --> 00:02:00,899
desktop SD already was done way back in

00:01:58,890 --> 00:02:03,719
early 2000 but I haven't been

00:02:00,899 --> 00:02:07,530
predominantly by Intel and it's PC

00:02:03,719 --> 00:02:09,840
centric take slot number of pens and

00:02:07,530 --> 00:02:12,720
it's not really friendly with respect to

00:02:09,840 --> 00:02:13,220
power so embedded world or mobile world

00:02:12,720 --> 00:02:15,410
doesn't

00:02:13,220 --> 00:02:19,310
so what they do is they have we do I to

00:02:15,410 --> 00:02:21,620
s on that or tedium as you call it again

00:02:19,310 --> 00:02:23,270
the pin count on this bus is not great

00:02:21,620 --> 00:02:25,850
it doesn't do control so you need to

00:02:23,270 --> 00:02:29,960
have always a sideband I to see or spy

00:02:25,850 --> 00:02:32,510
to do control and GP I use then we also

00:02:29,960 --> 00:02:34,400
have a PDM which is basically

00:02:32,510 --> 00:02:36,140
direct-attached microphones you can

00:02:34,400 --> 00:02:39,350
connect them to your sock or your codex

00:02:36,140 --> 00:02:41,540
so PDM again that limitation is that you

00:02:39,350 --> 00:02:43,670
can only have two devices and then on a

00:02:41,540 --> 00:02:46,820
particular link you can do command and

00:02:43,670 --> 00:02:48,080
control then before sound wear was

00:02:46,820 --> 00:02:51,860
developed there was another me P

00:02:48,080 --> 00:02:55,730
protocol they int protocol it's called

00:02:51,860 --> 00:02:57,200
slim bus people try to solve all these

00:02:55,730 --> 00:02:58,910
problems with the slim bus but

00:02:57,200 --> 00:03:00,980
eventually there was not widespread

00:02:58,910 --> 00:03:03,230
adoption because of meters factor

00:03:00,980 --> 00:03:04,880
primarily being the complexity of the

00:03:03,230 --> 00:03:07,070
protocol was too much and people

00:03:04,880 --> 00:03:08,600
couldn't do simpler devices the cost of

00:03:07,070 --> 00:03:11,720
doing simple devices were very much in

00:03:08,600 --> 00:03:14,330
terms of transistors so that led to

00:03:11,720 --> 00:03:17,959
sound where which kind of can be viewed

00:03:14,330 --> 00:03:20,900
as a improved version of slim bus in lot

00:03:17,959 --> 00:03:23,630
of terminologies so what does it try to

00:03:20,900 --> 00:03:25,640
do or watch when the sound guy

00:03:23,630 --> 00:03:27,890
development started what people wanted

00:03:25,640 --> 00:03:30,230
to do out of sound where was that we

00:03:27,890 --> 00:03:33,140
should have a bus which has a lesser pin

00:03:30,230 --> 00:03:35,900
count and we can do both command as well

00:03:33,140 --> 00:03:37,760
as control when we said control it's not

00:03:35,900 --> 00:03:39,800
just register gate rights but also kind

00:03:37,760 --> 00:03:41,540
of have a capability to wake the system

00:03:39,800 --> 00:03:44,350
up so that we can eliminate the need of

00:03:41,540 --> 00:03:47,269
the external GPIO of the system then

00:03:44,350 --> 00:03:49,790
slim bus initially although it was

00:03:47,269 --> 00:03:51,769
targeted to do PCM and PDM but

00:03:49,790 --> 00:03:54,110
unfortunately there were restrictions on

00:03:51,769 --> 00:03:57,049
how the pd 'm evolved on the protocol so

00:03:54,110 --> 00:03:59,959
pd m was never really supported but with

00:03:57,049 --> 00:04:02,540
this protocol we try to have both PCM as

00:03:59,959 --> 00:04:03,769
well as pd m supported multi-drop is

00:04:02,540 --> 00:04:06,170
another feature which comes to mind

00:04:03,769 --> 00:04:07,730
because if you look at I 2 s I 2 SS

00:04:06,170 --> 00:04:10,400
predominately you have point-to-point

00:04:07,730 --> 00:04:12,350
link or PDMS point-to-point link so it

00:04:10,400 --> 00:04:14,480
would help doing device terminal

00:04:12,350 --> 00:04:17,299
topologies if we have a multi drop bus

00:04:14,480 --> 00:04:18,950
and then as usual you want to solve the

00:04:17,299 --> 00:04:23,720
problem not just for embedded or mobile

00:04:18,950 --> 00:04:25,870
but for pcs as well so in this respect

00:04:23,720 --> 00:04:28,389
how we build it on top all

00:04:25,870 --> 00:04:30,430
is for somewhere or like you initially

00:04:28,389 --> 00:04:32,620
start with a simple case where you have

00:04:30,430 --> 00:04:34,960
a master which is on the application

00:04:32,620 --> 00:04:38,050
processor and you kind of partition it

00:04:34,960 --> 00:04:40,780
and drill that master particular driving

00:04:38,050 --> 00:04:42,639
your codex which can be speakers or

00:04:40,780 --> 00:04:45,610
amplifiers or microphones and so forth

00:04:42,639 --> 00:04:47,530
and it's a simple description and then

00:04:45,610 --> 00:04:50,470
what we can do is have additional

00:04:47,530 --> 00:04:52,630
masters and split them into different

00:04:50,470 --> 00:04:54,820
functions as given in this diagram like

00:04:52,630 --> 00:04:56,800
you have all the rendering devices the

00:04:54,820 --> 00:05:00,820
playback on one mastering on the capture

00:04:56,800 --> 00:05:02,410
or do different like a simple dumb codec

00:05:00,820 --> 00:05:05,500
which is basically implementing your

00:05:02,410 --> 00:05:07,990
wired headset and another smart speaker

00:05:05,500 --> 00:05:10,389
or digital speaker as we can call it so

00:05:07,990 --> 00:05:12,669
this is just a simple topology but if we

00:05:10,389 --> 00:05:17,320
try to make it more complicated we can

00:05:12,669 --> 00:05:19,240
have a multi-lane system where if you

00:05:17,320 --> 00:05:21,370
look at from this point this topology

00:05:19,240 --> 00:05:23,650
point of view you have single master and

00:05:21,370 --> 00:05:27,820
that single master is able to drive a

00:05:23,650 --> 00:05:29,889
quite modern complicated mobile audio

00:05:27,820 --> 00:05:32,139
topology where you have a codec

00:05:29,889 --> 00:05:33,490
connected as well as a modem connected

00:05:32,139 --> 00:05:36,760
probably a DSP as well

00:05:33,490 --> 00:05:38,320
BT FM chip and if you notice in this

00:05:36,760 --> 00:05:41,650
diagram

00:05:38,320 --> 00:05:45,250
not all data lines are required to go to

00:05:41,650 --> 00:05:47,500
master so you can have a communication

00:05:45,250 --> 00:05:49,479
in this case where master is not really

00:05:47,500 --> 00:05:51,910
involved in two slaves can directly talk

00:05:49,479 --> 00:05:55,150
to each other so this is the kind of use

00:05:51,910 --> 00:05:57,130
cases which sound where tries to solve

00:05:55,150 --> 00:05:59,440
how it goes we see probably next year

00:05:57,130 --> 00:06:01,660
down the line with devices it market but

00:05:59,440 --> 00:06:04,930
that's the main motivation of why we

00:06:01,660 --> 00:06:07,180
wanted to sound where another is like

00:06:04,930 --> 00:06:09,340
bridge cut apologies if you're a device

00:06:07,180 --> 00:06:11,349
lengths or other things do you have some

00:06:09,340 --> 00:06:13,960
limitation so you can also implement a

00:06:11,349 --> 00:06:15,729
bridge where devices master on one side

00:06:13,960 --> 00:06:19,060
and kind of slave and doing a bridging

00:06:15,729 --> 00:06:20,560
in between so this kind of gives us a

00:06:19,060 --> 00:06:22,870
little bit of motivation on what should

00:06:20,560 --> 00:06:25,780
we expect from sound by protocol so

00:06:22,870 --> 00:06:27,160
let's go into the protocol a little bit

00:06:25,780 --> 00:06:29,080
so as you can see in the previous

00:06:27,160 --> 00:06:31,539
diagrams it's a two pin bus which has

00:06:29,080 --> 00:06:35,080
data and clock we can do both 1.2 and

00:06:31,539 --> 00:06:36,909
1.8 volts and then as we see in the

00:06:35,080 --> 00:06:38,569
multi Lane diagram you can have multiple

00:06:36,909 --> 00:06:40,309
data lines

00:06:38,569 --> 00:06:41,749
if your bandwidth is not sufficient or

00:06:40,309 --> 00:06:43,429
you want to have complex audio

00:06:41,749 --> 00:06:47,539
topologies you can do multiple data

00:06:43,429 --> 00:06:49,009
lines then it's a serial bus but it's a

00:06:47,539 --> 00:06:50,330
dual data rate bus so what it

00:06:49,009 --> 00:06:52,309
essentially means when your clock has

00:06:50,330 --> 00:06:54,110
rendered both on the rising edge as well

00:06:52,309 --> 00:06:56,599
as on the falling edge we will sample

00:06:54,110 --> 00:06:58,159
data so that essentially drives your

00:06:56,599 --> 00:07:01,009
bandwidth to excess compared to your

00:06:58,159 --> 00:07:02,959
clock rate of the bus and then flame

00:07:01,009 --> 00:07:04,939
lengths typically if you look at any of

00:07:02,959 --> 00:07:07,189
the serial bus protocols you will have a

00:07:04,939 --> 00:07:09,349
frame where you have a dedicated header

00:07:07,189 --> 00:07:11,899
and then a payload and then that's fixed

00:07:09,349 --> 00:07:14,839
for the duration and you will not be

00:07:11,899 --> 00:07:17,389
able to adjust it but typically if you

00:07:14,839 --> 00:07:20,419
look at audio put user scenarios you may

00:07:17,389 --> 00:07:22,490
be probably rendering to your headset

00:07:20,419 --> 00:07:24,949
and then you want to start a capture

00:07:22,490 --> 00:07:27,020
session as well or you have a bloated

00:07:24,949 --> 00:07:28,939
shine coming you know stuff like that so

00:07:27,020 --> 00:07:31,999
in this case your bandwidth requirements

00:07:28,939 --> 00:07:33,889
are not static they keep on increasing

00:07:31,999 --> 00:07:36,589
or decreasing based on what you want to

00:07:33,889 --> 00:07:40,099
do with the bus so as a result you may

00:07:36,589 --> 00:07:42,199
want to have a feature where your frame

00:07:40,099 --> 00:07:44,269
length is also variable you can change

00:07:42,199 --> 00:07:47,449
it on the flight runtime without having

00:07:44,269 --> 00:07:49,249
to sacrifice in audio quality so that is

00:07:47,449 --> 00:07:53,449
something which sound we're trying to

00:07:49,249 --> 00:07:55,039
solve as well then as a consequence we

00:07:53,449 --> 00:07:57,409
don't have a static clock we can scale

00:07:55,039 --> 00:07:58,999
dynamically the clock right up to twelve

00:07:57,409 --> 00:08:00,409
point eight megahertz which is basically

00:07:58,999 --> 00:08:03,309
the electrical limit of the protocol

00:08:00,409 --> 00:08:05,389
right now then since it's also

00:08:03,309 --> 00:08:07,180
predominantly focused on our mobile

00:08:05,389 --> 00:08:10,759
ecosystem and I made a Tico system

00:08:07,180 --> 00:08:13,399
people want to be have it to be more

00:08:10,759 --> 00:08:16,219
power friendly so at runtime we can do a

00:08:13,399 --> 00:08:18,379
clock stop and do a power down of the

00:08:16,219 --> 00:08:22,159
whole bus and obviously it supports both

00:08:18,379 --> 00:08:24,709
PCM and PDM along with that in case of

00:08:22,159 --> 00:08:26,389
audio Vee since it's targeting audio we

00:08:24,709 --> 00:08:28,039
have both AIESEC on us as well as I said

00:08:26,389 --> 00:08:32,029
on a support of the audio rates

00:08:28,039 --> 00:08:33,949
essentially it helps you to run on a

00:08:32,029 --> 00:08:36,139
particular clock rate both forty four

00:08:33,949 --> 00:08:38,839
one at 48 kilohertz kind of frequency

00:08:36,139 --> 00:08:40,639
sets so that's quite helpful because a

00:08:38,839 --> 00:08:42,860
lot of protocols are not able to do that

00:08:40,639 --> 00:08:48,470
so you rely on external mechanisms to do

00:08:42,860 --> 00:08:50,959
that so as whole modern or your embedded

00:08:48,470 --> 00:08:51,560
ecosystem evolved in last like say five

00:08:50,959 --> 00:08:53,210
or eight

00:08:51,560 --> 00:08:56,779
years we have seen evolution of the

00:08:53,210 --> 00:08:58,190
espys now ESP maybe on the sock side or

00:08:56,779 --> 00:09:00,260
on the codec side but if it's on the

00:08:58,190 --> 00:09:02,330
codec side what codec guys want is to be

00:09:00,260 --> 00:09:05,210
able to load huge blob of data which are

00:09:02,330 --> 00:09:07,250
basically our coefficients and your

00:09:05,210 --> 00:09:09,650
parameters so typically what they will

00:09:07,250 --> 00:09:12,290
do they will write put a side spy bus on

00:09:09,650 --> 00:09:14,240
it and then drive the data blobs through

00:09:12,290 --> 00:09:15,920
that so soundboy tries to solve by

00:09:14,240 --> 00:09:18,770
having a dedicated bulk transfer

00:09:15,920 --> 00:09:20,360
capability and you can do tons of

00:09:18,770 --> 00:09:21,920
register writes and at a very good

00:09:20,360 --> 00:09:23,420
bandwidth depending on again

00:09:21,920 --> 00:09:26,390
implementation of your master and the

00:09:23,420 --> 00:09:31,100
slave devices bandwidths of megabits are

00:09:26,390 --> 00:09:32,660
possible then low gate count so one of

00:09:31,100 --> 00:09:34,700
the good things about the protocol

00:09:32,660 --> 00:09:36,680
definition was for the master a lot of

00:09:34,700 --> 00:09:38,810
things are mandatory but for the slave

00:09:36,680 --> 00:09:40,670
some things most of the things are

00:09:38,810 --> 00:09:43,250
actually optional so what that does is

00:09:40,670 --> 00:09:45,980
you can make a really good big complex

00:09:43,250 --> 00:09:48,680
slave system but then you can also go

00:09:45,980 --> 00:09:50,450
and design reduce the all optional

00:09:48,680 --> 00:09:52,730
features and come up with a set of

00:09:50,450 --> 00:09:54,470
device which is very simplistic in

00:09:52,730 --> 00:09:56,330
nature and your gate count ultimately

00:09:54,470 --> 00:09:57,890
goes down so that helps in having a

00:09:56,330 --> 00:09:58,370
simpler implementations and drive the

00:09:57,890 --> 00:10:02,270
cost down

00:09:58,370 --> 00:10:06,800
hopefully reduction as well and device

00:10:02,270 --> 00:10:09,040
sorry on protocol control point of view

00:10:06,800 --> 00:10:11,960
we can enumerate what is on the bus and

00:10:09,040 --> 00:10:14,020
it will tell we can find out when the

00:10:11,960 --> 00:10:17,300
device is show up or when they are not

00:10:14,020 --> 00:10:20,900
latched on to the bus so that is allowed

00:10:17,300 --> 00:10:22,970
in the spec but the whole enumeration

00:10:20,900 --> 00:10:24,470
process is driven by the software so

00:10:22,970 --> 00:10:25,880
software needs to play a little bit of a

00:10:24,470 --> 00:10:31,310
role here we'll go into that a little

00:10:25,880 --> 00:10:35,600
bit then the sound where current version

00:10:31,310 --> 00:10:38,600
is spec version is 1.1 and it doesn't

00:10:35,600 --> 00:10:40,250
define date device classes but then

00:10:38,600 --> 00:10:43,760
there's a provision for it in the spec

00:10:40,250 --> 00:10:44,990
so in future we should expect that some

00:10:43,760 --> 00:10:46,490
people will come up with there's already

00:10:44,990 --> 00:10:49,010
work going on and maybe work good for

00:10:46,490 --> 00:10:51,200
that so we can have device classes so

00:10:49,010 --> 00:10:52,910
what essentially means is for simpler

00:10:51,200 --> 00:10:54,709
devices like microphones or speaker

00:10:52,910 --> 00:10:56,959
people should not be able writing

00:10:54,709 --> 00:10:58,670
additional software and your device

00:10:56,959 --> 00:11:00,500
class software will be able to handle

00:10:58,670 --> 00:11:02,660
that just like kind of a USB based

00:11:00,500 --> 00:11:04,130
device concepts so that is still

00:11:02,660 --> 00:11:04,840
work-in-progress that has not been done

00:11:04,130 --> 00:11:07,360
but

00:11:04,840 --> 00:11:09,580
spec has provision for it already so

00:11:07,360 --> 00:11:12,790
it's not like we left the door closed at

00:11:09,580 --> 00:11:14,740
the moment okay so we've been talking

00:11:12,790 --> 00:11:16,810
about various device types let's look

00:11:14,740 --> 00:11:18,100
into what are the actual devices the

00:11:16,810 --> 00:11:20,980
first master

00:11:18,100 --> 00:11:23,170
so master is a device which is supposed

00:11:20,980 --> 00:11:26,650
to drive your clock and does the data

00:11:23,170 --> 00:11:29,230
handling then it recall that we have a

00:11:26,650 --> 00:11:32,290
concept called bus keeper so it means

00:11:29,230 --> 00:11:34,630
that it own it will assign who should be

00:11:32,290 --> 00:11:37,750
driving a bit slot so coming back or

00:11:34,630 --> 00:11:39,700
what is a bit slot bits lot since I said

00:11:37,750 --> 00:11:41,860
that it's a double data rate bus and we

00:11:39,700 --> 00:11:44,200
had pumping data on both the edges of

00:11:41,860 --> 00:11:45,940
the clock in this case what it means is

00:11:44,200 --> 00:11:47,320
each edge of the clock is referred to as

00:11:45,940 --> 00:11:50,940
a bit slot so that's kind of a

00:11:47,320 --> 00:11:54,670
terminology sound where perspec uses so

00:11:50,940 --> 00:11:56,200
it will do the bus management and assign

00:11:54,670 --> 00:11:58,180
owners of each bit Scott who is allowed

00:11:56,200 --> 00:12:00,670
to drive on that particular bit slot who

00:11:58,180 --> 00:12:04,690
is not and that is essentially a role of

00:12:00,670 --> 00:12:06,580
master then we have slave slave became

00:12:04,690 --> 00:12:09,310
as we said audio peripherals like

00:12:06,580 --> 00:12:11,920
microphone colleagues or speakers and

00:12:09,310 --> 00:12:14,410
then up to 11 slaves can be connected on

00:12:11,920 --> 00:12:16,060
a bus 11 is a magic number we go into

00:12:14,410 --> 00:12:18,880
details on why a little bit later

00:12:16,060 --> 00:12:20,830
it can interrupt it can wake up the

00:12:18,880 --> 00:12:24,700
system so assuming you have done an

00:12:20,830 --> 00:12:26,140
audio implementation and you would when

00:12:24,700 --> 00:12:27,550
you're idle you will expect that you

00:12:26,140 --> 00:12:29,830
will power down everything and then

00:12:27,550 --> 00:12:31,660
somebody in such check so it has in-band

00:12:29,830 --> 00:12:34,030
signaling mechanisms so that it can wake

00:12:31,660 --> 00:12:36,520
up both itself as well as the mus from

00:12:34,030 --> 00:12:40,150
the AP so that's allowed similarly it

00:12:36,520 --> 00:12:41,940
can interrupt so there's a sigma there's

00:12:40,150 --> 00:12:44,680
some event let's say you have a DSP

00:12:41,940 --> 00:12:47,800
implemented in a codec and then see you

00:12:44,680 --> 00:12:49,510
detected some funny words you can take a

00:12:47,800 --> 00:12:51,700
wake the system up or interrupt the

00:12:49,510 --> 00:12:54,130
system up with those things and it

00:12:51,700 --> 00:12:57,520
reports status that's basically so we

00:12:54,130 --> 00:13:00,670
have two types of statuses one is master

00:12:57,520 --> 00:13:03,880
service specs status where it can tell

00:13:00,670 --> 00:13:04,930
what is your current device state and

00:13:03,880 --> 00:13:06,790
everything and then there's an

00:13:04,930 --> 00:13:08,860
implementation define which can be

00:13:06,790 --> 00:13:12,580
basically based on what your device

00:13:08,860 --> 00:13:14,230
implementation is there's another piece

00:13:12,580 --> 00:13:17,230
of interesting equipment called monitor

00:13:14,230 --> 00:13:18,279
in the spec so what monitor essentially

00:13:17,230 --> 00:13:20,050
means is you have

00:13:18,279 --> 00:13:22,269
sophisticated test equipment which you

00:13:20,050 --> 00:13:25,689
can attached on a bus and then it can

00:13:22,269 --> 00:13:27,579
snow and help you in debug and test and

00:13:25,689 --> 00:13:30,100
there are a couple of vendors who

00:13:27,579 --> 00:13:33,579
provide sound where monitor monitors in

00:13:30,100 --> 00:13:35,410
the market today and if you desire it

00:13:33,579 --> 00:13:37,540
can also take over the bus management

00:13:35,410 --> 00:13:39,459
from the master and start issuing the

00:13:37,540 --> 00:13:42,100
commands got even in this case but still

00:13:39,459 --> 00:13:44,110
the bus master has to continue bumping a

00:13:42,100 --> 00:13:49,870
clock that's not allowed to do mean by

00:13:44,110 --> 00:13:53,230
the master data ports so since it's

00:13:49,870 --> 00:13:56,379
clear towards audio so one of the things

00:13:53,230 --> 00:13:58,959
what spec defines is a concept of data

00:13:56,379 --> 00:14:01,749
ports so each master and slave how to

00:13:58,959 --> 00:14:04,089
define how many data put the support and

00:14:01,749 --> 00:14:07,149
it's basically logical entity where you

00:14:04,089 --> 00:14:10,449
will send or receive the transmission

00:14:07,149 --> 00:14:13,209
protocol sorry payload data and as I

00:14:10,449 --> 00:14:14,649
said since people want to have

00:14:13,209 --> 00:14:18,069
implementations where we they can

00:14:14,649 --> 00:14:19,990
simplify the data port is mandatory but

00:14:18,069 --> 00:14:21,610
the type of data port is optional you

00:14:19,990 --> 00:14:23,980
can have a very simplistic data port

00:14:21,610 --> 00:14:25,389
which doesn't do much of the fancy bells

00:14:23,980 --> 00:14:27,009
and whistles features but then you can

00:14:25,389 --> 00:14:30,069
have a complete data port which does a

00:14:27,009 --> 00:14:32,050
lot of things extra so types of data

00:14:30,069 --> 00:14:33,790
port will be either simple which is very

00:14:32,050 --> 00:14:36,399
dumb now doesn't do anything or reduced

00:14:33,790 --> 00:14:37,629
where it can have some capabilities or

00:14:36,399 --> 00:14:42,009
full where it has all the capabilities

00:14:37,629 --> 00:14:43,870
supported by the spec then again on a

00:14:42,009 --> 00:14:46,930
particular device we can have up to 15

00:14:43,870 --> 00:14:49,180
data ports 0 is always reserved for bulk

00:14:46,930 --> 00:14:51,610
transfer capability so we've talked

00:14:49,180 --> 00:14:53,680
about bulk transfer for writing large

00:14:51,610 --> 00:14:55,269
blobs of data so if you if I device

00:14:53,680 --> 00:14:59,170
supports that it should support the data

00:14:55,269 --> 00:15:00,550
point 0 then data about one 214 are

00:14:59,170 --> 00:15:02,620
reserved for audio functions this is

00:15:00,550 --> 00:15:05,050
where actually all your streams are

00:15:02,620 --> 00:15:07,329
directed towards and 15 is basically in

00:15:05,050 --> 00:15:08,559
alias to 1 to 15 port so if you have

00:15:07,329 --> 00:15:10,990
something like broadcast you want to

00:15:08,559 --> 00:15:14,490
send out or receive that's done by the

00:15:10,990 --> 00:15:17,709
data port 1 to 4 I'm sorry did about 15

00:15:14,490 --> 00:15:19,449
how does the frame look like interesting

00:15:17,709 --> 00:15:20,730
bit now so as you can see in this

00:15:19,449 --> 00:15:24,550
diagram

00:15:20,730 --> 00:15:26,379
sound well spec defines a frame as a

00:15:24,550 --> 00:15:28,860
combination of row as n columns and

00:15:26,379 --> 00:15:28,860
these are the

00:15:29,510 --> 00:15:34,020
these are allowed rows and column values

00:15:32,040 --> 00:15:36,270
it draws starts from two onwards and the

00:15:34,020 --> 00:15:39,150
max value it can go is 16 call them from

00:15:36,270 --> 00:15:42,420
48 onwards and max I guess is somewhere

00:15:39,150 --> 00:15:45,300
250 and as you can see there's a nice

00:15:42,420 --> 00:15:47,700
correlation between these diagrams such

00:15:45,300 --> 00:15:51,030
these values based on audio frequencies

00:15:47,700 --> 00:15:52,950
you want to support and a particular

00:15:51,030 --> 00:16:00,060
frame is combination of row and columns

00:15:52,950 --> 00:16:01,800
so in this case if we also need to send

00:16:00,060 --> 00:16:05,010
a control word which is basically your

00:16:01,800 --> 00:16:08,820
command and control field and always the

00:16:05,010 --> 00:16:13,230
first row is the deepest row for T eight

00:16:08,820 --> 00:16:14,820
columns dedicated like 48 rows of the

00:16:13,230 --> 00:16:16,920
first column are always dedicated to the

00:16:14,820 --> 00:16:19,710
control word rest can be dedicated for

00:16:16,920 --> 00:16:21,930
your audio data or bulk transfer as you

00:16:19,710 --> 00:16:24,060
would did necessary this is all decided

00:16:21,930 --> 00:16:28,110
by the master at the time of initiation

00:16:24,060 --> 00:16:31,440
and before it tries to program so a PCM

00:16:28,110 --> 00:16:34,440
can be allocated slots in any rows or

00:16:31,440 --> 00:16:36,780
columns will C and P diem by its nature

00:16:34,440 --> 00:16:38,580
it generates one bit at a time so it's

00:16:36,780 --> 00:16:41,400
recommended that you generally have a

00:16:38,580 --> 00:16:44,550
one particular column dedicated for

00:16:41,400 --> 00:16:46,770
billions that essentially ensures that

00:16:44,550 --> 00:16:51,210
you don't have any conflict between PC

00:16:46,770 --> 00:16:53,820
MP diem and control word okay now these

00:16:51,210 --> 00:16:57,420
number of rows and columns are chosen so

00:16:53,820 --> 00:16:58,770
this kind of thing one must think so as

00:16:57,420 --> 00:17:01,170
you can see in the serial transmission

00:16:58,770 --> 00:17:03,420
case we will always transmit the row

00:17:01,170 --> 00:17:05,100
first followed by all the columns of

00:17:03,420 --> 00:17:06,589
that particular row and then draw so

00:17:05,100 --> 00:17:11,940
it's kind of basically a raster scan

00:17:06,589 --> 00:17:14,190
kind of mechanism this also ensures for

00:17:11,940 --> 00:17:16,350
things like PDM that you keep on bumping

00:17:14,190 --> 00:17:18,000
a bit at a time on the column as in when

00:17:16,350 --> 00:17:21,810
they arrive if your clock rates are

00:17:18,000 --> 00:17:24,360
matching also ensures that if you are

00:17:21,810 --> 00:17:27,870
sending this control word on the per day

00:17:24,360 --> 00:17:30,690
on a row zero if you have momentary some

00:17:27,870 --> 00:17:32,640
errors on the bus your errors are

00:17:30,690 --> 00:17:35,340
getting distributed evenly and it's not

00:17:32,640 --> 00:17:39,380
that couple of bit errors are completely

00:17:35,340 --> 00:17:39,380
making your control would go for a toss

00:17:39,440 --> 00:17:44,640
based on these rows and columns this is

00:17:41,880 --> 00:17:47,130
a couple of examples of typical common

00:17:44,640 --> 00:17:49,200
usages of rosin colour frame shapes so

00:17:47,130 --> 00:17:52,170
this is a 48 cross - where this

00:17:49,200 --> 00:17:54,570
particular row will be dedicated for

00:17:52,170 --> 00:17:58,710
your control word 48 bits and then we

00:17:54,570 --> 00:18:02,370
can send audio data on this column this

00:17:58,710 --> 00:18:05,550
48 cross 2 is very commonly used in case

00:18:02,370 --> 00:18:08,760
you want to be doing a simple playback

00:18:05,550 --> 00:18:11,640
to 2800 for 24 bits to do which you will

00:18:08,760 --> 00:18:14,630
probably see in your headset or your

00:18:11,640 --> 00:18:17,340
speakers so this is the most common

00:18:14,630 --> 00:18:19,380
frame shape you will encounter then you

00:18:17,340 --> 00:18:22,200
can also have this other examples 48

00:18:19,380 --> 00:18:24,929
cross 4 where you may want to be doing

00:18:22,200 --> 00:18:26,730
both playback and capture as you might

00:18:24,929 --> 00:18:29,910
have noticed if you do that with 24-bit

00:18:26,730 --> 00:18:32,010
audio you will be only occupying two

00:18:29,910 --> 00:18:35,309
columns and one column will go freeze so

00:18:32,010 --> 00:18:36,929
that's up to system designer to choose

00:18:35,309 --> 00:18:38,400
what kind of topology he wants to

00:18:36,929 --> 00:18:40,230
support what kind of rates he wants to

00:18:38,400 --> 00:18:42,390
support and how the column ship should

00:18:40,230 --> 00:18:45,000
be arrived at from the implementation

00:18:42,390 --> 00:18:47,760
point of view bus right now doesn't

00:18:45,000 --> 00:18:49,260
choose anything it's left to the master

00:18:47,760 --> 00:18:52,080
because master knows the system very

00:18:49,260 --> 00:18:53,400
well so we carry what kind of be given

00:18:52,080 --> 00:18:56,880
the bandwidth what kind of frame shape

00:18:53,400 --> 00:19:00,720
would you like to support another

00:18:56,880 --> 00:19:02,550
example so as Rose will go beyond 64

00:19:00,720 --> 00:19:04,950
because we can go all the way up to

00:19:02,550 --> 00:19:07,230
sorry 48 - all the way up to 64 and you

00:19:04,950 --> 00:19:09,450
can add this with audio data or bulk

00:19:07,230 --> 00:19:12,690
transfer data and you might have noticed

00:19:09,450 --> 00:19:15,330
this particular bit after 48 data is

00:19:12,690 --> 00:19:17,760
kind of left for payload but in

00:19:15,330 --> 00:19:20,700
practical circumstances I have never

00:19:17,760 --> 00:19:24,240
found a use for it till now it's kind of

00:19:20,700 --> 00:19:26,010
gets waste so 48 bits of control word

00:19:24,240 --> 00:19:30,660
how do they look like this is what we

00:19:26,010 --> 00:19:32,370
transmit on a particular control work

00:19:30,660 --> 00:19:35,040
there can be three types of commands it

00:19:32,370 --> 00:19:36,960
can be paying read or write when it's

00:19:35,040 --> 00:19:39,540
paying it can be either ping request

00:19:36,960 --> 00:19:40,980
from the slave so a slave can say can

00:19:39,540 --> 00:19:43,170
you send a ping command in that case

00:19:40,980 --> 00:19:45,960
they will assert this ping request and

00:19:43,170 --> 00:19:47,880
master will send the ping command or it

00:19:45,960 --> 00:19:49,740
can be read right which is opcode of 1

00:19:47,880 --> 00:19:50,210
and 3 we read write is basically your

00:19:49,740 --> 00:19:52,760
register

00:19:50,210 --> 00:19:54,650
right for the sleeves if we are doing

00:19:52,760 --> 00:19:57,080
register readwrite then we put device

00:19:54,650 --> 00:19:59,150
address here register address for the

00:19:57,080 --> 00:20:02,120
device in these bits from eight onwards

00:19:59,150 --> 00:20:04,640
all the way up down to 23 and then the

00:20:02,120 --> 00:20:07,790
register readwrite data is in this 33 to

00:20:04,640 --> 00:20:11,300
40 bit so this is how a register read or

00:20:07,790 --> 00:20:12,770
write will be performed if we are not

00:20:11,300 --> 00:20:14,480
doing registered readwrite then things

00:20:12,770 --> 00:20:17,750
are interesting because we are doing a

00:20:14,480 --> 00:20:20,120
ping command ping command is essentially

00:20:17,750 --> 00:20:22,490
a way for it can be redone initiated by

00:20:20,120 --> 00:20:25,160
either master or by the ping request by

00:20:22,490 --> 00:20:27,890
a way for the master to know what all

00:20:25,160 --> 00:20:31,580
the slaves are doing and how the is that

00:20:27,890 --> 00:20:33,140
any status update on those we were

00:20:31,580 --> 00:20:35,240
talking about my monitor brief

00:20:33,140 --> 00:20:36,560
previously so if there's a monitor and

00:20:35,240 --> 00:20:38,210
it wants to relinquish the control of

00:20:36,560 --> 00:20:41,180
the bus they can do that by asserting

00:20:38,210 --> 00:20:43,550
the bus request bit and whenever master

00:20:41,180 --> 00:20:46,460
is ready it can do that by giving the

00:20:43,550 --> 00:20:48,530
bus release bit here when the ping

00:20:46,460 --> 00:20:50,210
command is issued each slave on the bus

00:20:48,530 --> 00:20:52,640
was attached it's supposed to send the

00:20:50,210 --> 00:20:54,890
status that is given in since we have 11

00:20:52,640 --> 00:20:57,980
slaves so all the seven slaves can give

00:20:54,890 --> 00:21:00,950
status been 2 bits we're going to start

00:20:57,980 --> 00:21:03,200
with a little bit later this is also a

00:21:00,950 --> 00:21:06,110
slave status and then we have this

00:21:03,200 --> 00:21:09,500
static bed definition all the way from

00:21:06,110 --> 00:21:14,030
24 to 31 this is essentially synch word

00:21:09,500 --> 00:21:16,760
so when when you boot the system and the

00:21:14,030 --> 00:21:18,890
clock is start triggered at that time a

00:21:16,760 --> 00:21:21,620
slave has to synchronize to the master

00:21:18,890 --> 00:21:23,570
clock and this is the way it does it by

00:21:21,620 --> 00:21:26,000
listening on this particular sync word

00:21:23,570 --> 00:21:27,620
it will try to listen on the sync word

00:21:26,000 --> 00:21:28,730
once it's detected a sync word it will

00:21:27,620 --> 00:21:31,100
derive a frame shape information

00:21:28,730 --> 00:21:34,130
frequency information and then latch

00:21:31,100 --> 00:21:37,280
onto the bus along with the scene this

00:21:34,130 --> 00:21:39,260
fixed sync word there's also a provision

00:21:37,280 --> 00:21:40,070
of 41 to 44 bits which is basically a

00:21:39,260 --> 00:21:43,760
dynamic thing

00:21:40,070 --> 00:21:45,260
so this sync word is supposed to be

00:21:43,760 --> 00:21:47,960
designed in such a way that it's not

00:21:45,260 --> 00:21:50,840
commonly found in audio payload but then

00:21:47,960 --> 00:21:52,790
whatever the probability probability is

00:21:50,840 --> 00:21:54,860
very low so that is why they want to

00:21:52,790 --> 00:21:56,750
minimize that low probability even

00:21:54,860 --> 00:21:58,970
further by having a dynamic sync bits

00:21:56,750 --> 00:22:02,780
four bits it's essentially pseudo-random

00:21:58,970 --> 00:22:04,039
binary sequence and that eliminates the

00:22:02,780 --> 00:22:09,919
possibility of you lat

00:22:04,039 --> 00:22:13,220
farrahfig sink okay so what is remaining

00:22:09,919 --> 00:22:15,470
are these three bits so this is the

00:22:13,220 --> 00:22:16,909
parity for your frame so you want to

00:22:15,470 --> 00:22:20,239
check what's the parity on that and you

00:22:16,909 --> 00:22:23,659
do verification so at the assuming we

00:22:20,239 --> 00:22:26,029
are doing a read or write us end up code

00:22:23,659 --> 00:22:28,909
here device address register address and

00:22:26,029 --> 00:22:31,070
if it's a read sorry right the right

00:22:28,909 --> 00:22:33,830
data is here if it's a read the slave is

00:22:31,070 --> 00:22:35,479
supposed to put rain data here so within

00:22:33,830 --> 00:22:37,190
this particular frame you have actually

00:22:35,479 --> 00:22:39,109
performed the whole read or write

00:22:37,190 --> 00:22:41,179
operation and the result of that

00:22:39,109 --> 00:22:43,309
operation is given in these two bits so

00:22:41,179 --> 00:22:44,960
this is where the slave will tell you is

00:22:43,309 --> 00:22:47,239
that each successful or a write

00:22:44,960 --> 00:22:53,629
successful by asserting these knack or

00:22:47,239 --> 00:22:55,789
add bets okay now in the previous

00:22:53,629 --> 00:22:58,700
diagram if you see there's a device

00:22:55,789 --> 00:23:04,849
address we'll go how this device address

00:22:58,700 --> 00:23:07,519
is right each slave on may be a device

00:23:04,849 --> 00:23:10,849
is supposed to implement a 48-bit device

00:23:07,519 --> 00:23:14,299
address and how that 48-bit is formed is

00:23:10,849 --> 00:23:16,460
first 16 bits our manufacturer ID this

00:23:14,299 --> 00:23:19,249
is a standard my mep manufacture code

00:23:16,460 --> 00:23:23,210
assigned by mep alliance and you can

00:23:19,249 --> 00:23:25,609
find it on em ID dot me p dot o-r-g each

00:23:23,210 --> 00:23:29,269
when that has a specific code just like

00:23:25,609 --> 00:23:31,669
your PCI device ID code then each vendor

00:23:29,269 --> 00:23:33,379
will on its own parts assign a 16-bit

00:23:31,669 --> 00:23:36,169
part ID so other particular parts

00:23:33,379 --> 00:23:38,570
they're doing one unique thing about

00:23:36,169 --> 00:23:42,009
audio devices is you may have on a

00:23:38,570 --> 00:23:44,299
particular must same kind of devices and

00:23:42,009 --> 00:23:46,159
how do you uniquely distinguish between

00:23:44,299 --> 00:23:48,580
them for example you may have four

00:23:46,159 --> 00:23:51,710
microphones attached and doing a

00:23:48,580 --> 00:23:53,179
beamforming application so in this case

00:23:51,710 --> 00:23:55,429
round wear allows you to have four

00:23:53,179 --> 00:23:57,139
additional bits four unique ID so this

00:23:55,429 --> 00:23:58,729
is left to the implementers how they

00:23:57,139 --> 00:24:02,389
want to implement it probably a GPO a

00:23:58,729 --> 00:24:04,999
pulldown or whatever and or a particular

00:24:02,389 --> 00:24:07,249
abode fuse programming so that allows

00:24:04,999 --> 00:24:09,200
you to uniquely address same class of

00:24:07,249 --> 00:24:11,840
devices with the same type of devices

00:24:09,200 --> 00:24:14,179
within a particular bus along with that

00:24:11,840 --> 00:24:15,649
we dedicate four bits to versioning so

00:24:14,179 --> 00:24:16,169
sorry I'd know founder Protocol version

00:24:15,649 --> 00:24:17,759
is

00:24:16,169 --> 00:24:19,379
not once so that's what we should expect

00:24:17,759 --> 00:24:21,450
a must read

00:24:19,379 --> 00:24:24,749
there was a 1.0 but then I don't think

00:24:21,450 --> 00:24:27,200
anybody implemented that as we said

00:24:24,749 --> 00:24:29,639
there's a future division for classes so

00:24:27,200 --> 00:24:33,690
it's still reserved bet they have not

00:24:29,639 --> 00:24:36,059
defined it yet okay so this 48 bit is

00:24:33,690 --> 00:24:37,919
what uniquely identifies that but then

00:24:36,059 --> 00:24:40,409
your control vote itself is 48 bits so

00:24:37,919 --> 00:24:42,779
we cannot really send 48 bits to address

00:24:40,409 --> 00:24:44,850
a device so there's always a translation

00:24:42,779 --> 00:24:47,159
from device address to device number

00:24:44,850 --> 00:24:53,210
which is our 4 bit value which we saw in

00:24:47,159 --> 00:24:56,119
the control board so this 4 bit value

00:24:53,210 --> 00:25:05,850
where is assigned by the master to the

00:24:56,119 --> 00:25:08,100
particulars relays and this okay so this

00:25:05,850 --> 00:25:10,019
plays a role in the enumeration stay a

00:25:08,100 --> 00:25:12,629
little bit for a couple of slides with

00:25:10,019 --> 00:25:14,489
this 0 number 4 device number is 4

00:25:12,629 --> 00:25:15,929
devices which are attached to the bus it

00:25:14,489 --> 00:25:17,669
essentially means that you're

00:25:15,929 --> 00:25:21,419
synchronized to the clock you understand

00:25:17,669 --> 00:25:23,789
what is the frame shape running and so

00:25:21,419 --> 00:25:25,379
forth and when you are properly attached

00:25:23,789 --> 00:25:27,629
and you are assigned a device number by

00:25:25,379 --> 00:25:30,600
the bus that is when you will be in the

00:25:27,629 --> 00:25:32,429
device 1 2 11 12 and 13 is reserved for

00:25:30,600 --> 00:25:33,570
the group so you can group class or

00:25:32,429 --> 00:25:36,119
devices let's say you have two

00:25:33,570 --> 00:25:38,009
microphones or you have two speakers

00:25:36,119 --> 00:25:39,119
which are identical and you want to

00:25:38,009 --> 00:25:40,739
program that all at the same time

00:25:39,119 --> 00:25:42,179
because you it's a stereo speaker you

00:25:40,739 --> 00:25:44,129
won't want to program them independently

00:25:42,179 --> 00:25:46,980
so you can create a group of devices

00:25:44,129 --> 00:25:48,960
which you are always communicating at

00:25:46,980 --> 00:25:50,759
the same time and programming the same

00:25:48,960 --> 00:25:53,460
time so this can be done by two groups

00:25:50,759 --> 00:25:55,769
12 and 13 14 years ago 4 must reduce

00:25:53,460 --> 00:25:58,830
which you can can do for our internal

00:25:55,769 --> 00:26:02,210
programming 15 is a broadcast device

00:25:58,830 --> 00:26:05,609
number so if you send up command with 15

00:26:02,210 --> 00:26:09,179
as a device number so all the slaves are

00:26:05,609 --> 00:26:10,830
supposed to respond to that now this

00:26:09,179 --> 00:26:14,309
kind of solves our mystery why we can

00:26:10,830 --> 00:26:18,330
only support 11 devices because of this

00:26:14,309 --> 00:26:19,919
partitioning now in on the enumeration

00:26:18,330 --> 00:26:22,440
that's the only the missing piece in

00:26:19,919 --> 00:26:25,830
this particular puzzle so whether you

00:26:22,440 --> 00:26:27,629
are synchronized to the clock you will

00:26:25,830 --> 00:26:29,200
have a ping command issued or you can

00:26:27,629 --> 00:26:31,149
request a ping command

00:26:29,200 --> 00:26:33,309
that point of times level reports that

00:26:31,149 --> 00:26:34,779
it's attached on device number zero this

00:26:33,309 --> 00:26:37,360
is the default boot sequence for a

00:26:34,779 --> 00:26:39,490
particular slave then software will go

00:26:37,360 --> 00:26:43,750
and read the 48 bit device ID which is

00:26:39,490 --> 00:26:45,789
device now register 0 to 5 and then it

00:26:43,750 --> 00:26:48,039
will assign a particular device number

00:26:45,789 --> 00:26:50,139
to the particular slave so once it's a

00:26:48,039 --> 00:26:52,179
sign from the anywhere value from 1 to

00:26:50,139 --> 00:26:54,730
11 we need to program it back to the

00:26:52,179 --> 00:26:56,350
device so before we do a device number

00:26:54,730 --> 00:26:58,809
programming on device number register

00:26:56,350 --> 00:27:00,970
once that is done slave has to again

00:26:58,809 --> 00:27:04,240
come back and report attached on that

00:27:00,970 --> 00:27:06,279
particular device so if you see go back

00:27:04,240 --> 00:27:08,470
to this so this is a slave status

00:27:06,279 --> 00:27:09,250
assuming we have programming on device

00:27:08,470 --> 00:27:11,200
number 6

00:27:09,250 --> 00:27:13,210
initially he will come and tell me I am

00:27:11,200 --> 00:27:15,760
attached on 0 will go and read the

00:27:13,210 --> 00:27:18,399
register assign it let's say slave

00:27:15,760 --> 00:27:20,679
number 6 and then it will say attached

00:27:18,399 --> 00:27:25,240
here this is where the enumeration cycle

00:27:20,679 --> 00:27:27,250
completes ok the device number is

00:27:25,240 --> 00:27:29,230
dynamic in nature so that means once you

00:27:27,250 --> 00:27:31,750
assign it it's not there forever it can

00:27:29,230 --> 00:27:33,370
be lost if you lose the clock you are no

00:27:31,750 --> 00:27:35,649
longer synchronized you will come back

00:27:33,370 --> 00:27:37,750
and say I'm reporting again attached on

00:27:35,649 --> 00:27:41,139
device number 0 so you reprogram it back

00:27:37,750 --> 00:27:42,850
then if you are doing a very very

00:27:41,139 --> 00:27:45,909
low-power domain where you lose sync to

00:27:42,850 --> 00:27:48,279
the clock you don't because after some

00:27:45,909 --> 00:27:50,799
time master may have done some more

00:27:48,279 --> 00:27:52,720
changes to the frame shape so the older

00:27:50,799 --> 00:27:55,299
clock which you had assumption was no

00:27:52,720 --> 00:27:58,120
longer valid so you need to again listen

00:27:55,299 --> 00:28:00,100
to the clock and synchronize again so in

00:27:58,120 --> 00:28:02,230
this case they always go back and say

00:28:00,100 --> 00:28:08,679
attached on device 0 whenever they

00:28:02,230 --> 00:28:11,320
synchronized ok sound wear spec

00:28:08,679 --> 00:28:13,210
implements lot of nice things it allows

00:28:11,320 --> 00:28:15,909
you to find out what devices there on

00:28:13,210 --> 00:28:18,700
the bus and enumerate it but it doesn't

00:28:15,909 --> 00:28:21,870
tell me what that device is if I get a

00:28:18,700 --> 00:28:24,429
device on the bus with a part number and

00:28:21,870 --> 00:28:28,210
manufacturer number bar I have no idea

00:28:24,429 --> 00:28:30,639
what to do with it so in this case wise

00:28:28,210 --> 00:28:33,429
guys that maybe came up with a spec

00:28:30,639 --> 00:28:35,440
called disco which is stands for

00:28:33,429 --> 00:28:38,500
discovery in configuration so what the

00:28:35,440 --> 00:28:41,350
spec does is it implements a lot of

00:28:38,500 --> 00:28:42,520
properties for master and slave these

00:28:41,350 --> 00:28:45,400
properties

00:28:42,520 --> 00:28:47,200
by spec definition are optional but in

00:28:45,400 --> 00:28:49,600
the next of system we have taken a view

00:28:47,200 --> 00:28:52,240
that these properties are mandatory if

00:28:49,600 --> 00:28:54,250
you want to get linux support this for

00:28:52,240 --> 00:28:55,900
the simple reason that we now know what

00:28:54,250 --> 00:28:57,820
to do with the particular slave how to

00:28:55,900 --> 00:28:59,800
program it what are the timeout values

00:28:57,820 --> 00:29:01,600
what are the registers implemented does

00:28:59,800 --> 00:29:04,450
it have a data for simple reduced or

00:29:01,600 --> 00:29:06,880
complex what kind of capabilities does

00:29:04,450 --> 00:29:08,320
the device have we're not leaving we are

00:29:06,880 --> 00:29:09,910
not talking about audio functionality

00:29:08,320 --> 00:29:11,440
yet but from the sound or protocol point

00:29:09,910 --> 00:29:13,480
of view what does it implement and how

00:29:11,440 --> 00:29:16,090
many resistors can I read and write so

00:29:13,480 --> 00:29:19,300
this is what discourse Peck implements

00:29:16,090 --> 00:29:22,510
it specifies these properties as a CPI

00:29:19,300 --> 00:29:25,570
DSD methods or device tree and

00:29:22,510 --> 00:29:27,610
properties current implementation

00:29:25,570 --> 00:29:30,820
actually suppose a CPI we don't do DT

00:29:27,610 --> 00:29:33,250
yet it describes or what the

00:29:30,820 --> 00:29:37,650
capabilities of your master or slave are

00:29:33,250 --> 00:29:43,630
okay now switching gears to the Linux

00:29:37,650 --> 00:29:47,320
this is how the bus looks like so this

00:29:43,630 --> 00:29:49,000
is the bus structure which is created by

00:29:47,320 --> 00:29:51,340
the master and then we initialize it

00:29:49,000 --> 00:29:54,490
first member is the device ID pointer

00:29:51,340 --> 00:29:56,260
this points to your master device then

00:29:54,490 --> 00:29:58,720
we have link ID so you may have multiple

00:29:56,260 --> 00:30:01,050
masters implemented so we assign each a

00:29:58,720 --> 00:30:03,520
unique link to our uniquely identify it

00:30:01,050 --> 00:30:05,680
master can have multiple slaves so we

00:30:03,520 --> 00:30:09,580
clearly you store them in the linked

00:30:05,680 --> 00:30:12,490
list of slaves since each bus needs to

00:30:09,580 --> 00:30:14,290
keep track of all the 0 sorry 1 to 11

00:30:12,490 --> 00:30:16,090
device numbers and who is assigned and

00:30:14,290 --> 00:30:18,730
which is not assigned that is done by

00:30:16,090 --> 00:30:21,070
using the sign bitmap for

00:30:18,730 --> 00:30:25,210
synchronization purpose samurai can do

00:30:21,070 --> 00:30:26,710
both control and comma streaming so for

00:30:25,210 --> 00:30:29,260
messaging which is basically where I oh

00:30:26,710 --> 00:30:30,970
we use a separate messaging lock and for

00:30:29,260 --> 00:30:33,250
streaming purpose which is a separate

00:30:30,970 --> 00:30:36,130
messaging lock reason for these 2

00:30:33,250 --> 00:30:37,960
different locks is essentially to be

00:30:36,130 --> 00:30:40,510
able to do parallel operations because

00:30:37,960 --> 00:30:42,250
typically the register programming and

00:30:40,510 --> 00:30:45,580
audio programming can run in parallel

00:30:42,250 --> 00:30:49,630
and we can push the throughput here then

00:30:45,580 --> 00:30:51,100
since one of the not-so-good things

00:30:49,630 --> 00:30:53,410
which I personally don't like about the

00:30:51,100 --> 00:30:56,050
protocol is it specifies good

00:30:53,410 --> 00:30:56,380
transmission protocol it specifies how

00:30:56,050 --> 00:30:58,330
slow

00:30:56,380 --> 00:31:01,810
should be implemented but then it leaves

00:30:58,330 --> 00:31:03,520
a completely blank on how a master

00:31:01,810 --> 00:31:05,340
should be implemented there are no

00:31:03,520 --> 00:31:07,600
master rod host controller interface

00:31:05,340 --> 00:31:10,000
specification specified in Samba

00:31:07,600 --> 00:31:11,590
protocols so the bus cannot assume

00:31:10,000 --> 00:31:14,500
anything about the master so in order

00:31:11,590 --> 00:31:16,540
for it to program anything on the master

00:31:14,500 --> 00:31:26,410
it needs the help of the master device

00:31:16,540 --> 00:31:28,720
oh sorry wrong yeah so it needs master

00:31:26,410 --> 00:31:30,550
to provide bunch of callback ops for

00:31:28,720 --> 00:31:34,330
master programming as well as must

00:31:30,550 --> 00:31:36,460
report programming then some robust

00:31:34,330 --> 00:31:38,650
based on the use cases it will do bus

00:31:36,460 --> 00:31:40,420
parameter calculation what is the frame

00:31:38,650 --> 00:31:42,700
shape and which required so those are

00:31:40,420 --> 00:31:44,110
stored in this then we had disco

00:31:42,700 --> 00:31:47,800
properties those are stored in the

00:31:44,110 --> 00:31:49,900
master properties since the intended

00:31:47,800 --> 00:31:52,270
scenarios audio and audio streams can

00:31:49,900 --> 00:31:55,450
come and go at any point of time we

00:31:52,270 --> 00:31:57,100
track them to the runtime list somewhere

00:31:55,450 --> 00:31:58,450
supports deferred messaging that is

00:31:57,100 --> 00:32:00,180
tracked through the different messaging

00:31:58,450 --> 00:32:04,750
and then we have a bunch of clock

00:32:00,180 --> 00:32:08,350
timeouts for banks which influx last is

00:32:04,750 --> 00:32:11,740
the multi link so on top of sound we're

00:32:08,350 --> 00:32:13,660
at least what Intel has done is to drive

00:32:11,740 --> 00:32:16,000
more complex usages they take two

00:32:13,660 --> 00:32:18,160
masters and tie them together and try

00:32:16,000 --> 00:32:20,290
one stream over it one of the examples

00:32:18,160 --> 00:32:22,240
can be let's say you have a big

00:32:20,290 --> 00:32:24,910
microphone array like sixteen

00:32:22,240 --> 00:32:27,040
microphones you can attach eight on one

00:32:24,910 --> 00:32:29,380
bus on eight on one other four on one or

00:32:27,040 --> 00:32:32,350
multiple large multiple speakers and so

00:32:29,380 --> 00:32:35,410
forth so in that case your stream come

00:32:32,350 --> 00:32:37,390
power can consist of multiple masters so

00:32:35,410 --> 00:32:39,100
if that is the case we first set this

00:32:37,390 --> 00:32:41,890
flag as true and do the things

00:32:39,100 --> 00:32:43,630
appropriately in the bus and these are

00:32:41,890 --> 00:32:46,390
the APS so once you have this data

00:32:43,630 --> 00:32:48,640
structure you allocate it and then you

00:32:46,390 --> 00:32:51,850
can invoke somewhere at bus master API

00:32:48,640 --> 00:32:54,880
this will initialize the rest of the

00:32:51,850 --> 00:32:59,350
data structures and start initial

00:32:54,880 --> 00:33:01,180
scanning your firmware so if you are

00:32:59,350 --> 00:33:02,680
implementing a CPI system or if you're

00:33:01,180 --> 00:33:04,690
implementing a device tree system you

00:33:02,680 --> 00:33:08,080
although it's an innumerable bus you

00:33:04,690 --> 00:33:09,070
still need to describe your device sound

00:33:08,080 --> 00:33:11,380
very devices

00:33:09,070 --> 00:33:14,080
your firmware one of the reasons for

00:33:11,380 --> 00:33:15,399
that is although it's enumerable it's

00:33:14,080 --> 00:33:18,190
not discoverable so we don't know a lot

00:33:15,399 --> 00:33:22,840
of properties on it so we rely on a CPI

00:33:18,190 --> 00:33:24,820
n device tree to do that so it will do

00:33:22,840 --> 00:33:26,769
the scanning of the firmware respective

00:33:24,820 --> 00:33:29,470
firmware and start adding the slaves and

00:33:26,769 --> 00:33:31,419
that's when your slave device objects

00:33:29,470 --> 00:33:33,009
are created once the slave device will

00:33:31,419 --> 00:33:38,019
object created if you have a driver for

00:33:33,009 --> 00:33:40,179
ed that driver will be probed and okay

00:33:38,019 --> 00:33:42,009
looking at master Ops so this is what

00:33:40,179 --> 00:33:47,019
the master ops you are supposed to

00:33:42,009 --> 00:33:49,720
implement read property is where is a

00:33:47,019 --> 00:33:51,460
callback which you can provide to read

00:33:49,720 --> 00:33:54,009
the disc of properties implemented for

00:33:51,460 --> 00:33:56,200
your particular device transfer message

00:33:54,009 --> 00:33:59,169
is for transferring the data message

00:33:56,200 --> 00:34:01,240
onto the bus since we don't have a host

00:33:59,169 --> 00:34:04,049
control spec we can't do that on our own

00:34:01,240 --> 00:34:06,639
will and master to do that for us then

00:34:04,049 --> 00:34:08,550
you we do we can do deferred messaging

00:34:06,639 --> 00:34:12,310
for that there's a different callback

00:34:08,550 --> 00:34:14,379
for so one of the things I will start

00:34:12,310 --> 00:34:16,450
pointing out was that sound was supports

00:34:14,379 --> 00:34:18,520
multiple registered pages so you can

00:34:16,450 --> 00:34:22,359
have multiple register pages and you can

00:34:18,520 --> 00:34:26,260
address a lot of I think 65 kilobyte of

00:34:22,359 --> 00:34:29,020
register space with that so in this case

00:34:26,260 --> 00:34:31,300
most sound where spec implementation is

00:34:29,020 --> 00:34:32,619
actually on the page 0 so whenever we

00:34:31,300 --> 00:34:35,829
want to do a sound byte slave

00:34:32,619 --> 00:34:38,319
programming we need to always reset page

00:34:35,829 --> 00:34:40,540
address 0 so that's a quick call back to

00:34:38,319 --> 00:34:42,220
do that then whenever you have a bus

00:34:40,540 --> 00:34:47,409
configuration you can set it using this

00:34:42,220 --> 00:34:49,510
callback and one of the things which

00:34:47,409 --> 00:34:51,460
sound where does as I was talking is

00:34:49,510 --> 00:34:56,079
having the capability of dynamically

00:34:51,460 --> 00:34:57,670
adding and a use case without doing any

00:34:56,079 --> 00:34:59,109
glitches which is kind of unique to the

00:34:57,670 --> 00:35:02,130
sound protocol as compared to other

00:34:59,109 --> 00:35:05,950
usages so you know how that is done is

00:35:02,130 --> 00:35:08,440
sound where you find out what other

00:35:05,950 --> 00:35:11,079
parameters you want for the new stream

00:35:08,440 --> 00:35:13,660
to be added then program that and what's

00:35:11,079 --> 00:35:16,660
all of everybody's program configured we

00:35:13,660 --> 00:35:18,940
do the switch of the whole duyst system

00:35:16,660 --> 00:35:21,609
at one point of time because sound we're

00:35:18,940 --> 00:35:22,850
implements to banks so there you have a

00:35:21,609 --> 00:35:25,160
shadow

00:35:22,850 --> 00:35:26,810
Bank one you can keep on programming on

00:35:25,160 --> 00:35:28,130
the alternate Bank and then switch onto

00:35:26,810 --> 00:35:30,800
the bank at the same time all the

00:35:28,130 --> 00:35:32,990
devices are synced and switched so this

00:35:30,800 --> 00:35:35,240
ensures that there are no glitches in

00:35:32,990 --> 00:35:37,250
the audio you program everything so for

00:35:35,240 --> 00:35:38,840
that we have a couple of callbacks to

00:35:37,250 --> 00:35:40,670
master to let it know that we are going

00:35:38,840 --> 00:35:47,420
to perform a bank switch before and

00:35:40,670 --> 00:35:49,100
after slave slave device simple kind of

00:35:47,420 --> 00:35:52,060
for the next device where we track what

00:35:49,100 --> 00:35:56,060
is a 48-bit device ID then embed this

00:35:52,060 --> 00:36:00,290
Linux truck device as done by the other

00:35:56,060 --> 00:36:02,900
devices slave status is it enumerated is

00:36:00,290 --> 00:36:05,030
it attached it is detached that's what

00:36:02,900 --> 00:36:07,400
we track here then pointer to the bus

00:36:05,030 --> 00:36:09,830
it's part of and slave also needs some

00:36:07,400 --> 00:36:17,470
operations for the same poor programming

00:36:09,830 --> 00:36:20,660
and poor programming as well as for the

00:36:17,470 --> 00:36:23,240
linked programming so that is done

00:36:20,660 --> 00:36:24,830
through the mass live ops again we have

00:36:23,240 --> 00:36:27,350
disco properties for slave so those are

00:36:24,830 --> 00:36:29,960
stone here and it's part of the bus link

00:36:27,350 --> 00:36:31,220
lists to note for that and once the

00:36:29,960 --> 00:36:33,350
ports are program because you can have

00:36:31,220 --> 00:36:35,570
multiple programs so you can program

00:36:33,350 --> 00:36:36,890
them a synchronously and wait on them so

00:36:35,570 --> 00:36:38,630
we have a completion for that and

00:36:36,890 --> 00:36:41,960
finally the device number which is

00:36:38,630 --> 00:36:43,340
assigned this is how the software driver

00:36:41,960 --> 00:36:44,750
looks like if you are implementing a

00:36:43,340 --> 00:36:46,850
driver this is all the most interesting

00:36:44,750 --> 00:36:49,430
structure for you name program or

00:36:46,850 --> 00:36:51,680
shutdown as in case of the standard next

00:36:49,430 --> 00:36:56,990
driver then your heidi table for the

00:36:51,680 --> 00:36:58,640
devices and your slave ops so how do you

00:36:56,990 --> 00:37:00,380
register a slave if you are implementing

00:36:58,640 --> 00:37:02,270
a slave driver you need to call

00:37:00,380 --> 00:37:05,180
somewhere registered slave driver and

00:37:02,270 --> 00:37:08,330
that will register device for you before

00:37:05,180 --> 00:37:10,220
that we would have done scan of the

00:37:08,330 --> 00:37:11,870
firmware for your sound right devices so

00:37:10,220 --> 00:37:15,890
on this your probe method will get

00:37:11,870 --> 00:37:18,200
called and your device is your driver is

00:37:15,890 --> 00:37:20,990
attached to the device but with a word

00:37:18,200 --> 00:37:25,190
of caution at this point of time your

00:37:20,990 --> 00:37:27,370
slave is not attached so do not attempt

00:37:25,190 --> 00:37:30,170
to communicate with the slave on probe

00:37:27,370 --> 00:37:32,720
that's a little tricky because that's

00:37:30,170 --> 00:37:34,720
the way protocol works only or when you

00:37:32,720 --> 00:37:37,990
have attached then you can attempt to do

00:37:34,720 --> 00:37:42,760
communication with the protocol for with

00:37:37,990 --> 00:37:46,359
your device so until you get a attached

00:37:42,760 --> 00:37:51,069
a status update do not attempt to call

00:37:46,359 --> 00:37:52,990
them the bus okay so we probe only on

00:37:51,069 --> 00:37:54,849
the manufacturer ID and part ID

00:37:52,990 --> 00:37:58,119
instanceid is not used for obvious

00:37:54,849 --> 00:37:59,859
reasons and on device and impression we

00:37:58,119 --> 00:38:01,569
update the status to the driver this is

00:37:59,859 --> 00:38:05,650
when you can start reading the registers

00:38:01,569 --> 00:38:08,470
of the device these are the slave ops we

00:38:05,650 --> 00:38:10,210
have big property since video can do

00:38:08,470 --> 00:38:13,150
interrupts we have interrupts call that

00:38:10,210 --> 00:38:14,950
for that then whenever status changes we

00:38:13,150 --> 00:38:16,060
bust let's the sleigh you know what is

00:38:14,950 --> 00:38:18,040
the status

00:38:16,060 --> 00:38:19,690
whenever bus config changes we have a

00:38:18,040 --> 00:38:21,730
bus contract callback so it let us know

00:38:19,690 --> 00:38:23,530
what's the con new configuration and

00:38:21,730 --> 00:38:25,960
whenever ports are prepared or D

00:38:23,530 --> 00:38:28,930
prepared we know by device know about

00:38:25,960 --> 00:38:31,480
the port parameters now coming back to

00:38:28,930 --> 00:38:33,579
disco properties since we said it's

00:38:31,480 --> 00:38:35,859
mandatory for the software we provide

00:38:33,579 --> 00:38:37,720
two nice API somtyme master read

00:38:35,859 --> 00:38:41,470
property and some Wesley Reed property

00:38:37,720 --> 00:38:43,810
so this callback this ApS will go and

00:38:41,470 --> 00:38:46,300
read your respective firmware if it's a

00:38:43,810 --> 00:38:48,790
device tree or a CPI we don't actually

00:38:46,300 --> 00:38:50,740
care because we use nice callbacks

00:38:48,790 --> 00:38:51,849
called device property callbacks which

00:38:50,740 --> 00:38:54,339
are agnostic to the firmware

00:38:51,849 --> 00:38:57,190
implementation you have and it will go

00:38:54,339 --> 00:39:00,220
and read the standard disk or specific

00:38:57,190 --> 00:39:02,980
size specified properties and it will

00:39:00,220 --> 00:39:08,530
initialize your property data structure

00:39:02,980 --> 00:39:11,410
now the property callbacks are mandatory

00:39:08,530 --> 00:39:13,270
but it is not mandatory to call these

00:39:11,410 --> 00:39:15,190
two ApS you can have your own

00:39:13,270 --> 00:39:17,020
implementation it is mandatory to

00:39:15,190 --> 00:39:18,940
provide a callback but what that

00:39:17,020 --> 00:39:21,609
callback does is up to the implementer

00:39:18,940 --> 00:39:23,800
so if you are fully compliant with

00:39:21,609 --> 00:39:27,280
discus spec you can just point it out to

00:39:23,800 --> 00:39:29,290
these two api's if you are not you can

00:39:27,280 --> 00:39:31,119
have your own implementation if you are

00:39:29,290 --> 00:39:32,920
partially there and partially not there

00:39:31,119 --> 00:39:34,839
then you can call in your own

00:39:32,920 --> 00:39:37,150
implementation the standard api is and

00:39:34,839 --> 00:39:39,420
then put your sacred sauce on top of it

00:39:37,150 --> 00:39:39,420
okay

00:39:40,050 --> 00:39:47,580
io so i oh we have read and write

00:39:46,390 --> 00:39:49,440
callbacks

00:39:47,580 --> 00:39:51,780
saundra read and sound read/write api's

00:39:49,440 --> 00:39:54,210
these are basically your register read

00:39:51,780 --> 00:39:55,890
and write ap ice and then we also have a

00:39:54,210 --> 00:39:58,680
something like end read and write which

00:39:55,890 --> 00:40:01,590
allow you to read contiguous maybe a

00:39:58,680 --> 00:40:04,020
bunch of registers but in practice I

00:40:01,590 --> 00:40:06,600
expect nobody to use those ApS because

00:40:04,020 --> 00:40:10,710
they should be using rich map reg maps

00:40:06,600 --> 00:40:13,050
of what is already available so since we

00:40:10,710 --> 00:40:16,260
do audio how's the audio stream looked

00:40:13,050 --> 00:40:18,720
like so this is the audio stream we

00:40:16,260 --> 00:40:22,230
allocated a stream object for even aware

00:40:18,720 --> 00:40:23,910
there's audio instance going on we track

00:40:22,230 --> 00:40:25,620
the stream parameters state of the

00:40:23,910 --> 00:40:28,410
stream and what is the type which is

00:40:25,620 --> 00:40:30,960
basically PDM in PCM and wheeling your

00:40:28,410 --> 00:40:36,810
refine stream can have multiple masters

00:40:30,960 --> 00:40:39,360
so a list of masters in this sorry one

00:40:36,810 --> 00:40:42,360
quick thing about this is we can have

00:40:39,360 --> 00:40:44,940
multiple we can have one or more masters

00:40:42,360 --> 00:40:47,190
at least one master is mandatory in a

00:40:44,940 --> 00:40:48,750
stream it may be the case that you

00:40:47,190 --> 00:40:50,220
actually do not have a master in a

00:40:48,750 --> 00:40:52,530
stream you may be doing a slave to slave

00:40:50,220 --> 00:40:54,870
communication but you still need a bus

00:40:52,530 --> 00:40:57,090
master to drive the clock so a data port

00:40:54,870 --> 00:40:59,070
of master is not mandatory but a master

00:40:57,090 --> 00:41:01,530
is mandatory similarly if we can have

00:40:59,070 --> 00:41:02,880
one or more slaves in the stream and the

00:41:01,530 --> 00:41:05,040
master slave are represented by

00:41:02,880 --> 00:41:08,340
somewhere master runtime and somewhere

00:41:05,040 --> 00:41:10,740
slave runtime they just structures

00:41:08,340 --> 00:41:12,930
streaming API is you can allocate the

00:41:10,740 --> 00:41:15,060
stream object using sound where allocate

00:41:12,930 --> 00:41:16,920
stream and free that up with early

00:41:15,060 --> 00:41:19,080
stream once you have allocated the

00:41:16,920 --> 00:41:22,230
object you can add the masters using

00:41:19,080 --> 00:41:23,700
stream add master or stream add slave so

00:41:22,230 --> 00:41:25,560
if you are am a slave implementer you

00:41:23,700 --> 00:41:27,420
just need to make sure that you are

00:41:25,560 --> 00:41:29,370
calling add slave if you are a master

00:41:27,420 --> 00:41:34,470
implementer you need to call allocate

00:41:29,370 --> 00:41:36,270
and add master then once your object is

00:41:34,470 --> 00:41:37,830
allocated you need to prepare the stream

00:41:36,270 --> 00:41:41,430
this is typically done from the audio

00:41:37,830 --> 00:41:43,500
pal box my Hardware params

00:41:41,430 --> 00:41:45,870
it should be linked to your prepare

00:41:43,500 --> 00:41:47,010
stream and if you are doing enabled it

00:41:45,870 --> 00:41:47,700
should be typically called from your

00:41:47,010 --> 00:41:51,150
start stream

00:41:47,700 --> 00:41:53,430
similarly disable and D prepare okay

00:41:51,150 --> 00:41:55,200
what do we do in streaming is we

00:41:53,430 --> 00:41:57,510
calculate the bandwidth and the frame

00:41:55,200 --> 00:41:59,490
shape required and then program the

00:41:57,510 --> 00:42:00,750
transport parameters again in this case

00:41:59,490 --> 00:42:01,270
we will perform the Bank switch to

00:42:00,750 --> 00:42:03,610
enable and you

00:42:01,270 --> 00:42:05,800
transport then we configure the ports

00:42:03,610 --> 00:42:07,120
and enable the ports and banks wish to

00:42:05,800 --> 00:42:10,840
enable the force actually

00:42:07,120 --> 00:42:13,270
so converse is done on the data current

00:42:10,840 --> 00:42:16,690
status quickly so saundra subsystem was

00:42:13,270 --> 00:42:19,210
actually merged in 4.16 linux and then

00:42:16,690 --> 00:42:21,280
streaming support we added in 4.20

00:42:19,210 --> 00:42:23,800
multi-link support is actually in linux

00:42:21,280 --> 00:42:26,680
next and we'll go for folder 20 read map

00:42:23,800 --> 00:42:28,570
is also available we have Intel sound

00:42:26,680 --> 00:42:31,480
wire controller as well as the cadence

00:42:28,570 --> 00:42:33,700
IP block which Intel employment what is

00:42:31,480 --> 00:42:36,400
remaining is surface support for

00:42:33,700 --> 00:42:37,690
properties and then debug support I have

00:42:36,400 --> 00:42:40,660
patches probably they will go in further

00:42:37,690 --> 00:42:43,780
21 along where the device tree support

00:42:40,660 --> 00:42:45,970
for these devices these are the lengths

00:42:43,780 --> 00:42:47,830
this is a link to movie spec

00:42:45,970 --> 00:42:50,050
unfortunately you need to be a me team

00:42:47,830 --> 00:42:51,730
member to be able to access the spec the

00:42:50,050 --> 00:42:54,250
Disco spec is freely available because

00:42:51,730 --> 00:42:56,670
the software spec and then the link to

00:42:54,250 --> 00:43:12,280
the source free and documentation

00:42:56,670 --> 00:43:14,350
questions it's me P up something I don't

00:43:12,280 --> 00:43:17,310
know it whenever we use disco we're

00:43:14,350 --> 00:43:17,310
supposed to use SM with it

00:43:17,770 --> 00:43:41,980
discovery in configuration spec it's

00:43:21,010 --> 00:43:48,360
defined by maybe sorry yes yeah right no

00:43:41,980 --> 00:43:48,360
it doesn't say for that yep

00:43:50,830 --> 00:43:58,670
that's a good question so I know

00:43:54,820 --> 00:44:00,440
everybody in audio ecosystem has a sound

00:43:58,670 --> 00:44:03,050
where master/slave based on where they

00:44:00,440 --> 00:44:07,040
reside upstream support is only there

00:44:03,050 --> 00:44:10,370
for Intel and next year is when I know

00:44:07,040 --> 00:44:12,770
that there will be devices shipping with

00:44:10,370 --> 00:44:15,770
somewhere in them and you can buy them

00:44:12,770 --> 00:44:17,090
of mugga in dome of the market I expect

00:44:15,770 --> 00:44:20,960
by end of next year you will have a

00:44:17,090 --> 00:44:26,840
significant support for devices both in

00:44:20,960 --> 00:44:28,270
linux as well as in the ecosystem good

00:44:26,840 --> 00:44:29,840
question

00:44:28,270 --> 00:44:34,460
unfortunately I don't have a crystal

00:44:29,840 --> 00:44:39,800
ball to tell you that any other

00:44:34,460 --> 00:44:41,000
questions yeah spec is there if you are

00:44:39,800 --> 00:44:48,850
maybe a member you can go and download

00:44:41,000 --> 00:44:48,850
it that's not my call unfortunately yeah

00:44:54,360 --> 00:44:59,860
no but I don't expect it to be any worse

00:44:57,730 --> 00:45:03,100
if you don't have production system told

00:44:59,860 --> 00:45:07,420
me that I didn't see yet but it would be

00:45:03,100 --> 00:45:09,250
much much better as compared to i2 SS as

00:45:07,420 --> 00:45:23,050
compared as compared to i2 s is what I

00:45:09,250 --> 00:45:25,420
would pursue yeah nope

00:45:23,050 --> 00:45:28,480
so the question from Liam is we have a

00:45:25,420 --> 00:45:30,070
prepare callback and since it's invoke

00:45:28,480 --> 00:45:31,210
from the audio hardware parens we should

00:45:30,070 --> 00:45:34,450
rename it to Hardware params

00:45:31,210 --> 00:45:37,750
unfortunately no because prepare is a

00:45:34,450 --> 00:45:40,150
stream straight in sound where and we

00:45:37,750 --> 00:45:42,280
want to move from the strain stream

00:45:40,150 --> 00:45:45,430
transition to prepare state so that is

00:45:42,280 --> 00:45:47,740
why it's a prepare if tomorrow audio

00:45:45,430 --> 00:45:49,990
guys make it something else we should

00:45:47,740 --> 00:45:54,750
not change this API or it can be called

00:45:49,990 --> 00:45:54,750
from non audio context hypothetically I

00:45:55,140 --> 00:46:01,300
agree I agree we had a good debate and

00:45:59,290 --> 00:46:03,910
our friend Pierre has that a lot of - a

00:46:01,300 --> 00:46:10,320
lot to say on that so we'll stick with

00:46:03,910 --> 00:46:10,320
prepare for now yeah I agree

00:46:13,230 --> 00:46:24,980
sorry

00:46:16,090 --> 00:46:36,890
eight bits yeah I think it said

00:46:24,980 --> 00:46:42,710
I'll check again sure yeah yeah can you

00:46:36,890 --> 00:46:45,980
yeah so I must just stop the silence so

00:46:42,710 --> 00:46:47,300
let's talk after this because Rob people

00:46:45,980 --> 00:46:49,280
are waiting for the next session so

00:46:47,300 --> 00:46:53,110
thank you very much for attendance and

00:46:49,280 --> 00:46:53,110

YouTube URL: https://www.youtube.com/watch?v=uegPu0lop08


