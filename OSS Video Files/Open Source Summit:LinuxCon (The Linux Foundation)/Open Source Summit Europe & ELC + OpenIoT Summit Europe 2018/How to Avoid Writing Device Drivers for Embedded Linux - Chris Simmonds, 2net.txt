Title: How to Avoid Writing Device Drivers for Embedded Linux - Chris Simmonds, 2net
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	How to Avoid Writing Device Drivers for Embedded Linux - Chris Simmonds, 2net

 Writing device drivers is time consuming and error prone. The good news is that in most cases you don't have to because Linux provides ready-made drivers for common types of interface. If you want to twiddle some GPIO pins, fade the brightness of an LED or read the temperature using a chip you got from Adafruit, it is all done for you. Well … almost all: you still have to write some user-space code to call the generic driver.

In this presentation I will give examples using three subsystems: GPIO, PWM and I2C. For each one I will show you how to write code to control hardware from the safe and simple environment of your application, written in C or C++ (bindings for other languages exist). If all goes well, there will be live demos of each category. 

About Chris Simmonds
Chris Simmonds is a software consultant and trainer living in southern England. He has almost two decades of experience in designing and building open-source embedded systems. He is the founder and chief consultant at 2net Ltd, which provides professional training and mentoring services in embedded Linux, Linux device drivers, and Android platform development. He has trained engineers at many of the biggest companies in the embedded world. He is the author of the book “Mastering Embedded Linux Programming”, and is a frequent presenter at open source and embedded conferences, including the Embedded Linux Conference and Embedded World. You can see some of his work on the “Inner Penguin” blog at www.2net.co.uk
Captions: 
	00:00:00,350 --> 00:00:06,870
good morning everybody and welcome to

00:00:03,140 --> 00:00:14,849
this talk on how not to write device

00:00:06,870 --> 00:00:17,279
drivers skip that I'm if you don't know

00:00:14,849 --> 00:00:19,920
me already I've been working in embedded

00:00:17,279 --> 00:00:22,830
Linux for many years and you can catch

00:00:19,920 --> 00:00:25,320
up with me at these places but the

00:00:22,830 --> 00:00:29,670
important thing then is that today I

00:00:25,320 --> 00:00:34,829
want to be talking about device drivers

00:00:29,670 --> 00:00:36,000
and how to do it in user space so I'll

00:00:34,829 --> 00:00:38,940
begin by talking a little bit about

00:00:36,000 --> 00:00:41,340
device drivers in kernel space just to

00:00:38,940 --> 00:00:44,250
give the background and then we'll talk

00:00:41,340 --> 00:00:45,960
about user space device drivers and I'll

00:00:44,250 --> 00:00:49,079
follow up with this some example was

00:00:45,960 --> 00:00:58,440
using GP iOS pulse width modulation and

00:00:49,079 --> 00:01:03,769
I squared C so the conventional driver

00:00:58,440 --> 00:01:07,650
model is that all the hardware is

00:01:03,769 --> 00:01:10,650
accessed via the kernel so if you want

00:01:07,650 --> 00:01:13,409
to access some hardware you have to

00:01:10,650 --> 00:01:16,189
write a kernel device driver that

00:01:13,409 --> 00:01:20,939
exposes some kind of interface within

00:01:16,189 --> 00:01:23,030
the user level and then applications way

00:01:20,939 --> 00:01:25,080
up here can you see that we can't

00:01:23,030 --> 00:01:27,390
applications somewhere way up here can

00:01:25,080 --> 00:01:30,360
then call the kernel system interfaces

00:01:27,390 --> 00:01:33,079
the kernel then accesses the hardware on

00:01:30,360 --> 00:01:33,079
your behalf

00:01:33,750 --> 00:01:39,119
down here in the kernel you can handle

00:01:36,570 --> 00:01:41,070
things like interrupts and also do fancy

00:01:39,119 --> 00:01:48,840
things with DMA and all kinds of other

00:01:41,070 --> 00:01:53,220
stuff and then the interface between the

00:01:48,840 --> 00:01:55,649
kernel and the application is we'll

00:01:53,220 --> 00:01:57,990
basically through files as we know in

00:01:55,649 --> 00:01:59,759
linux everything is a file

00:01:57,990 --> 00:02:03,780
except network interfaces which are

00:01:59,759 --> 00:02:05,189
sockets but that's almost a file so most

00:02:03,780 --> 00:02:07,649
of the time when you're writing user

00:02:05,189 --> 00:02:10,560
applications you interact with the

00:02:07,649 --> 00:02:11,900
device whatever it is via the POSIX

00:02:10,560 --> 00:02:16,200
function calls I

00:02:11,900 --> 00:02:19,069
open/close read write etc and the father

00:02:16,200 --> 00:02:21,810
you are accessing are going to be

00:02:19,069 --> 00:02:25,499
usually either device nodes that's the

00:02:21,810 --> 00:02:29,189
stuff in the /dev directory or we can

00:02:25,499 --> 00:02:32,430
also expose attributes via the sisyphus

00:02:29,189 --> 00:02:35,340
interface via slash assists whatever so

00:02:32,430 --> 00:02:39,239
for example we'll look at at the moment

00:02:35,340 --> 00:02:45,120
in the GPIO and you can access GPIOs

00:02:39,239 --> 00:02:46,680
through slices slash class slash GPIO so

00:02:45,120 --> 00:02:53,099
this is the this is the normal way of

00:02:46,680 --> 00:02:55,949
doing things so Reineke kernel device

00:02:53,099 --> 00:02:57,930
drivers is a lot of fun and hands up who

00:02:55,949 --> 00:03:01,530
has written device drivers for kernel

00:02:57,930 --> 00:03:02,939
before yeah pretty much everybody so I

00:03:01,530 --> 00:03:07,560
mean it's great fun I really really

00:03:02,939 --> 00:03:11,579
enjoy that but it is a little time

00:03:07,560 --> 00:03:13,560
consuming you are working within a

00:03:11,579 --> 00:03:16,049
kernel environment which is quite a lot

00:03:13,560 --> 00:03:19,139
different to a normal programming

00:03:16,049 --> 00:03:22,849
environment and it has the problem that

00:03:19,139 --> 00:03:25,799
if you introduce a bug in kernel driver

00:03:22,849 --> 00:03:27,389
then you can crash the entire kernel and

00:03:25,799 --> 00:03:30,389
bring the entire system to a halt

00:03:27,389 --> 00:03:35,909
so bugs in kernel code are much more

00:03:30,389 --> 00:03:37,560
serious than bugs in user space so the

00:03:35,909 --> 00:03:40,650
reason for this presentation really is

00:03:37,560 --> 00:03:43,169
to say that if possible it would be good

00:03:40,650 --> 00:03:46,979
if we didn't have to write kernel device

00:03:43,169 --> 00:03:49,650
drivers both because it takes a certain

00:03:46,979 --> 00:03:52,889
amount of time and effort but mostly

00:03:49,650 --> 00:03:56,669
because it introduces points of failure

00:03:52,889 --> 00:03:59,159
into your system so I want to encourage

00:03:56,669 --> 00:04:02,129
you when you are accessing hardware to

00:03:59,159 --> 00:04:04,079
think can I do this from user space do I

00:04:02,129 --> 00:04:06,419
really need a kernel device driver to do

00:04:04,079 --> 00:04:09,569
this thing if you can do it from user

00:04:06,419 --> 00:04:13,699
space then do so that is safer and

00:04:09,569 --> 00:04:13,699
easier for everyone

00:04:17,260 --> 00:04:21,580
not about device trees so since we're

00:04:19,480 --> 00:04:26,020
talking mostly to an embedded audience

00:04:21,580 --> 00:04:28,810
here you'll be aware that if you're

00:04:26,020 --> 00:04:31,090
working on arm platforms and several

00:04:28,810 --> 00:04:34,750
other platforms as well in order to

00:04:31,090 --> 00:04:36,670
access the hardware that you will need

00:04:34,750 --> 00:04:41,560
to tell the kernel where the hardware is

00:04:36,670 --> 00:04:43,570
and you do that through a device tree so

00:04:41,560 --> 00:04:44,890
as a part of this but I'm not actually

00:04:43,570 --> 00:04:47,230
going to go into this because that's

00:04:44,890 --> 00:04:49,540
kind of too much in detail for this look

00:04:47,230 --> 00:04:50,410
at this session but as part of this

00:04:49,540 --> 00:04:52,750
exercise

00:04:50,410 --> 00:04:55,810
you still need to write the device tree

00:04:52,750 --> 00:04:57,880
or the device tree overlay to give the

00:04:55,810 --> 00:05:05,860
kernel access to the particular bit of

00:04:57,880 --> 00:05:08,160
hardware you're trying to get to so I'm

00:05:05,860 --> 00:05:12,190
going to start with GPIO s

00:05:08,160 --> 00:05:14,650
general purpose input output so these

00:05:12,190 --> 00:05:17,680
are the most basic level of digital i/o

00:05:14,650 --> 00:05:19,540
on on a system there are a bunch of pins

00:05:17,680 --> 00:05:24,120
that we can configure for inputs and

00:05:19,540 --> 00:05:29,440
outputs and outputs we can use them to

00:05:24,120 --> 00:05:31,930
control lights relays we can control

00:05:29,440 --> 00:05:35,230
other chip selects and various other

00:05:31,930 --> 00:05:37,660
things and then as inputs we can use it

00:05:35,230 --> 00:05:40,020
to read the state of a digital inputs

00:05:37,660 --> 00:05:46,330
which could be a switch or a button or

00:05:40,020 --> 00:05:48,370
something else and when we read them as

00:05:46,330 --> 00:05:49,840
inputs we can either read them in polled

00:05:48,370 --> 00:05:53,380
mode we can just keep on reading the the

00:05:49,840 --> 00:05:56,230
input and see what it is or in most

00:05:53,380 --> 00:05:57,610
cases on most modern SOC s we can

00:05:56,230 --> 00:06:01,180
configure the GPIO s

00:05:57,610 --> 00:06:02,770
to generate an interrupt and the

00:06:01,180 --> 00:06:06,970
interfaces we're going to be looking at

00:06:02,770 --> 00:06:12,580
allow us to to wait for that interrupt

00:06:06,970 --> 00:06:14,500
so we don't have to keep on poling you

00:06:12,580 --> 00:06:18,040
have the luxury at the moment of having

00:06:14,500 --> 00:06:23,350
two interfaces to user space interfaces

00:06:18,040 --> 00:06:27,220
to GPIO s we have the old GPIO lib

00:06:23,350 --> 00:06:30,050
interface it's not a library by the way

00:06:27,220 --> 00:06:32,759
it's a kernel driver

00:06:30,050 --> 00:06:35,819
so gpio lib has been around for quite

00:06:32,759 --> 00:06:38,610
some time it exists as a Sisyphus

00:06:35,819 --> 00:06:40,259
interface the great thing about it is

00:06:38,610 --> 00:06:41,729
that's scriptable it's just a bunch of

00:06:40,259 --> 00:06:43,529
files you can write shell script or

00:06:41,729 --> 00:06:46,939
whatever to access those files so it's

00:06:43,529 --> 00:06:50,159
nice and easy but it has a few problems

00:06:46,939 --> 00:06:52,740
in particular it doesn't handle

00:06:50,159 --> 00:06:54,990
interrupts particularly well and there

00:06:52,740 --> 00:06:58,139
can be issues with if you want to change

00:06:54,990 --> 00:07:02,159
more than one input or output at the

00:06:58,139 --> 00:07:06,569
same time so we have in in addition then

00:07:02,159 --> 00:07:09,659
the GPIO see dev interface which is the

00:07:06,569 --> 00:07:12,870
modern better way of accessing GPIO s

00:07:09,659 --> 00:07:14,219
but since it uses ioctl functions as

00:07:12,870 --> 00:07:18,960
you'll see in a moment

00:07:14,219 --> 00:07:24,719
you have to write some code to do that

00:07:18,960 --> 00:07:28,039
you can't script it so starting off then

00:07:24,719 --> 00:07:34,740
with the GPIO lis abscissa FS interface

00:07:28,039 --> 00:07:37,379
so first of all looking in the still not

00:07:34,740 --> 00:07:39,449
working looking in sis class GPIO you'll

00:07:37,379 --> 00:07:41,789
see a number of registers called GPIO

00:07:39,449 --> 00:07:44,430
chips something-or-other so each one of

00:07:41,789 --> 00:07:47,629
those each one of those directories

00:07:44,430 --> 00:07:50,789
rather represents a GPIO register

00:07:47,629 --> 00:07:54,569
typically as in this case here the

00:07:50,789 --> 00:07:56,699
registers are 32 bits each and we have

00:07:54,569 --> 00:08:02,870
four of them

00:07:56,699 --> 00:08:06,180
this actually is from a BeagleBone and

00:08:02,870 --> 00:08:08,939
we can then we have these two files

00:08:06,180 --> 00:08:11,159
called export and an export so you can

00:08:08,939 --> 00:08:13,800
write a number to the export file and

00:08:11,159 --> 00:08:17,879
that will export a GPIO to use a space

00:08:13,800 --> 00:08:19,439
which you can then access and then when

00:08:17,879 --> 00:08:21,629
you're done with it you can earn export

00:08:19,439 --> 00:08:26,580
it by writing the same number to the

00:08:21,629 --> 00:08:30,930
unexplored file now these numbers are a

00:08:26,580 --> 00:08:32,820
linear range well they're a range of

00:08:30,930 --> 00:08:35,370
numbers starting usually starting from

00:08:32,820 --> 00:08:39,120
zero and going up to the maximum average

00:08:35,370 --> 00:08:41,519
number of GPIO s you have so in the

00:08:39,120 --> 00:08:42,350
example here GPIO chip zero this

00:08:41,519 --> 00:08:45,230
register

00:08:42,350 --> 00:08:49,190
we'll have the first 32gb iOS numbered

00:08:45,230 --> 00:08:53,600
from 0 to 31 and then GPIO chip 32 we'll

00:08:49,190 --> 00:08:59,750
have the next bunch number 32 to 63 and

00:08:53,600 --> 00:09:02,860
so on and so on this is a slight pest

00:08:59,750 --> 00:09:05,050
because it means you have to convert the

00:09:02,860 --> 00:09:09,080
normally when you look at the schematics

00:09:05,050 --> 00:09:12,800
you will see the the schematics label

00:09:09,080 --> 00:09:15,950
the GPIO s as the GPIO register and then

00:09:12,800 --> 00:09:18,860
the bit within that register so you have

00:09:15,950 --> 00:09:27,470
to convert that GPIO chip and register

00:09:18,860 --> 00:09:31,220
number into a linear GPIO range looking

00:09:27,470 --> 00:09:33,050
within the GPIO chip directory you can

00:09:31,220 --> 00:09:36,050
see there are a bunch of files the

00:09:33,050 --> 00:09:38,060
important ones are one called base which

00:09:36,050 --> 00:09:41,330
tells you the first GPIO number

00:09:38,060 --> 00:09:43,340
occurring in this register so we're

00:09:41,330 --> 00:09:48,410
looking at a GPIO chip 0 on the on the

00:09:43,340 --> 00:09:50,540
screen so base will contain 0 n GPIO

00:09:48,410 --> 00:09:53,840
tells you how many GPIO pins there are

00:09:50,540 --> 00:09:57,980
in this register 32 in this case and

00:09:53,840 --> 00:10:00,710
then label is a arbitrary label to

00:09:57,980 --> 00:10:03,950
identify this thing and in the case of

00:10:00,710 --> 00:10:05,960
this particular SOC you will see that it

00:10:03,950 --> 00:10:12,580
is just the name of the chip it will be

00:10:05,960 --> 00:10:17,450
GPIO chip 0 so then if we want to export

00:10:12,580 --> 00:10:21,470
say pin 42 which would be the tenth pin

00:10:17,450 --> 00:10:25,460
on the second GPIO chip you just write

00:10:21,470 --> 00:10:28,370
42 to the export file and then you see

00:10:25,460 --> 00:10:31,520
that magically GPIO 42 has appeared as a

00:10:28,370 --> 00:10:35,570
subdirectory assuming that's possible if

00:10:31,520 --> 00:10:37,370
if the GPIO is already been used by for

00:10:35,570 --> 00:10:39,740
example something within the kernel then

00:10:37,370 --> 00:10:42,110
the export will fail but assuming it is

00:10:39,740 --> 00:10:49,040
a free GPIO that we can export to user

00:10:42,110 --> 00:10:51,200
space that will succeed and then if you

00:10:49,040 --> 00:10:54,980
look within that new directory you get

00:10:51,200 --> 00:10:56,630
the access to the GPIO s so

00:10:54,980 --> 00:10:58,459
there are a bunch of things in here as

00:10:56,630 --> 00:11:02,149
well the important things here are a

00:10:58,459 --> 00:11:05,899
file called direction which can be

00:11:02,149 --> 00:11:08,570
either outputs or in so I out or in for

00:11:05,899 --> 00:11:14,540
an output or an input it defaults to an

00:11:08,570 --> 00:11:17,480
input and then we have the file called

00:11:14,540 --> 00:11:21,579
value which represents the value of the

00:11:17,480 --> 00:11:24,589
level of the of the pin so if it's an

00:11:21,579 --> 00:11:26,870
input when we read value we read the the

00:11:24,589 --> 00:11:31,190
level of the pin one for high 0 for low

00:11:26,870 --> 00:11:34,310
and when it's an output we can write 1

00:11:31,190 --> 00:11:38,779
or 0 2 value and that sets the output to

00:11:34,310 --> 00:11:41,839
be either high or low and then we have

00:11:38,779 --> 00:11:44,779
this file called active low which we can

00:11:41,839 --> 00:11:46,160
set to 1 to invert that logic so it

00:11:44,779 --> 00:11:47,870
turns out the hardware engineers get a

00:11:46,160 --> 00:11:49,250
bit confused about high voltage and low

00:11:47,870 --> 00:11:51,889
voltages quite often they get it wrong

00:11:49,250 --> 00:11:55,310
so in order to get it right again you

00:11:51,889 --> 00:11:57,079
can flip active low by setting the one

00:11:55,310 --> 00:11:59,839
to that which means that when you write

00:11:57,079 --> 00:12:01,699
a 1 to it if it's an output here it goes

00:11:59,839 --> 00:12:09,290
low and when you are to zero to it it

00:12:01,699 --> 00:12:12,560
goes high ok good

00:12:09,290 --> 00:12:14,470
next thing interrupts so if you want to

00:12:12,560 --> 00:12:16,490
monitor an input

00:12:14,470 --> 00:12:20,060
you can't just poll it but that's

00:12:16,490 --> 00:12:24,440
inefficient so if the GPIO Hardware

00:12:20,060 --> 00:12:27,500
underneath can can generate interrupts

00:12:24,440 --> 00:12:31,220
on a level change then we will have this

00:12:27,500 --> 00:12:33,920
extra file called edge and we can write

00:12:31,220 --> 00:12:36,740
to that to indicate how we want to

00:12:33,920 --> 00:12:38,180
generate the interrupt so edge can be

00:12:36,740 --> 00:12:42,440
non meaning we don't generate any

00:12:38,180 --> 00:12:45,050
interrupts or rising or falling riser or

00:12:42,440 --> 00:12:49,819
both so we can interrupt on the rising

00:12:45,050 --> 00:12:52,790
edge a falling edge or both of those so

00:12:49,819 --> 00:12:57,230
in the example on slide on writing the

00:12:52,790 --> 00:12:58,970
string falling to GPIO 60 /h that will

00:12:57,230 --> 00:13:04,750
then give me an interrupt on a falling

00:12:58,970 --> 00:13:07,520
edge and then unfortunately can't

00:13:04,750 --> 00:13:09,560
you can't use the interrupts mechanism

00:13:07,520 --> 00:13:12,940
from a script you need to actually write

00:13:09,560 --> 00:13:16,490
a bit of code and you need to poll and

00:13:12,940 --> 00:13:18,650
there's some examples on my website but

00:13:16,490 --> 00:13:20,560
not on the slides which show you how to

00:13:18,650 --> 00:13:22,460
do that

00:13:20,560 --> 00:13:23,750
but essentially you call the poll

00:13:22,460 --> 00:13:25,339
function that will block until the

00:13:23,750 --> 00:13:27,350
interrupt comes along when the interrupt

00:13:25,339 --> 00:13:31,480
comes along you unblock and then you

00:13:27,350 --> 00:13:31,480
read the value and find out what it was

00:13:33,279 --> 00:13:44,150
okay so that's the GPIO lib interface

00:13:37,839 --> 00:13:48,620
the GPIO C dev interface achieves a

00:13:44,150 --> 00:13:51,110
similar thing but using nodes in /dev so

00:13:48,620 --> 00:13:55,600
when you enable this you'll find that in

00:13:51,110 --> 00:13:58,730
/dev you have GPIO chip 0 1 2 3 etc so

00:13:55,600 --> 00:14:03,140
each one of those knows in slash dev

00:13:58,730 --> 00:14:08,770
represents a GPIO register similar to

00:14:03,140 --> 00:14:11,000
the GPIO chip directory in Sisyphus the

00:14:08,770 --> 00:14:14,589
difference then is that there are no

00:14:11,000 --> 00:14:17,390
subdirectories so GPIO chip is a

00:14:14,589 --> 00:14:20,630
character node character device node and

00:14:17,390 --> 00:14:23,330
so it doesn't have a structure within it

00:14:20,630 --> 00:14:31,130
you have to open it and then you can use

00:14:23,330 --> 00:14:32,959
ioctl functions to access the pins why

00:14:31,130 --> 00:14:35,120
so this is actually more complicated

00:14:32,959 --> 00:14:37,760
more coding to do simple things at least

00:14:35,120 --> 00:14:40,430
what are the advantages well first of

00:14:37,760 --> 00:14:43,190
all it has the name scheme that's more

00:14:40,430 --> 00:14:47,510
accurately accurately reflects what

00:14:43,190 --> 00:14:50,600
you'll see on the schematic so we named

00:14:47,510 --> 00:14:53,720
them now using the register GPIO chip 1

00:14:50,600 --> 00:14:56,360
2 3 etc and then we number the pins

00:14:53,720 --> 00:15:03,170
within that exactly as you will see on

00:14:56,360 --> 00:15:05,330
the hardware diagrams and also since we

00:15:03,170 --> 00:15:07,700
are treating the register as a single

00:15:05,330 --> 00:15:10,089
entity you can actually do several

00:15:07,700 --> 00:15:13,040
transactions in one single function call

00:15:10,089 --> 00:15:16,220
so we can set a number of bits for

00:15:13,040 --> 00:15:17,380
example in one function call and we can

00:15:16,220 --> 00:15:21,800
do that without glitch

00:15:17,380 --> 00:15:24,440
whereas with the gpio lib interface you

00:15:21,800 --> 00:15:27,230
could only change one input or output at

00:15:24,440 --> 00:15:31,970
a time so you can change one output at a

00:15:27,230 --> 00:15:33,410
time I should say and the way it handles

00:15:31,970 --> 00:15:37,760
interrupts is of the little nicer as

00:15:33,410 --> 00:15:40,100
well so I'm not going to go through

00:15:37,760 --> 00:15:42,230
every single aspect of this because it's

00:15:40,100 --> 00:15:46,490
quite a complicated programming

00:15:42,230 --> 00:15:51,020
interface so I'll just give a some demo

00:15:46,490 --> 00:15:54,290
code that gives the basic idea so this

00:15:51,020 --> 00:16:00,950
bit of code is going to be writing to

00:15:54,290 --> 00:16:05,000
GPIO chip 1 in 21 which is an LED if you

00:16:00,950 --> 00:16:06,950
have a BeagleBone black so the first lot

00:16:05,000 --> 00:16:09,980
is just their various include files you

00:16:06,950 --> 00:16:13,250
need and the variables the interesting

00:16:09,980 --> 00:16:17,750
stuff is on the next slide so here we

00:16:13,250 --> 00:16:20,900
open GPIO chip 1 the next line we set

00:16:17,750 --> 00:16:27,200
the line offsets to be 21 remember

00:16:20,900 --> 00:16:29,450
that's the pin we wanted 121 set the

00:16:27,200 --> 00:16:30,740
flags so we want this to be an output

00:16:29,450 --> 00:16:34,880
because we're going to use it to control

00:16:30,740 --> 00:16:38,990
an LED default values so initially we're

00:16:34,880 --> 00:16:41,030
going to set it to 0 and consume a label

00:16:38,990 --> 00:16:43,730
we can actually give a human readable

00:16:41,030 --> 00:16:47,770
string or at least a meaningful string

00:16:43,730 --> 00:16:50,450
and meaningful label to these GPIO pins

00:16:47,770 --> 00:16:54,140
which helps with debugging and and

00:16:50,450 --> 00:16:56,960
suchlike and then the last line have a

00:16:54,140 --> 00:16:59,240
number of lines we want is 1 so having

00:16:56,960 --> 00:17:04,580
created that request structure we then

00:16:59,240 --> 00:17:06,200
do the ioctl get line handle ioctl so

00:17:04,580 --> 00:17:09,440
this is a little bit of magic because

00:17:06,200 --> 00:17:14,230
this will return a new file descriptor a

00:17:09,440 --> 00:17:14,230
new handle if you like for this request

00:17:14,890 --> 00:17:23,330
so we can now use it actually returns in

00:17:19,370 --> 00:17:26,500
the request structure in the FD field so

00:17:23,330 --> 00:17:29,970
then if you look at the ioctl down here

00:17:26,500 --> 00:17:33,570
we are using that far the script

00:17:29,970 --> 00:17:37,380
then to change the state of this GPIO

00:17:33,570 --> 00:17:40,980
pin okay and we could do this multiple

00:17:37,380 --> 00:17:43,890
times we could have different file

00:17:40,980 --> 00:17:48,150
descriptors for different groups of pins

00:17:43,890 --> 00:17:51,630
on this GPIO and as you can see where we

00:17:48,150 --> 00:17:56,100
have line offsets up here the fact it is

00:17:51,630 --> 00:17:58,770
line offsets is it's an array so we can

00:17:56,100 --> 00:18:01,919
actually create a file descriptor handle

00:17:58,770 --> 00:18:04,049
which represents more than one pin so as

00:18:01,919 --> 00:18:05,940
I say we can then manipulate several

00:18:04,049 --> 00:18:08,880
pins in one go in a single function call

00:18:05,940 --> 00:18:14,220
so we atomically change those outputs

00:18:08,880 --> 00:18:16,860
without any glitches so it's a nicer

00:18:14,220 --> 00:18:18,240
interface from a technical viewpoint but

00:18:16,860 --> 00:18:24,690
there's a bit more coding involved to

00:18:18,240 --> 00:18:27,900
make it work you can also so the GPIO

00:18:24,690 --> 00:18:33,929
CDF has an event mechanism which is tied

00:18:27,900 --> 00:18:36,510
in to the GPIO interrupt mechanism I've

00:18:33,929 --> 00:18:39,150
got an example of that code but it's

00:18:36,510 --> 00:18:42,539
plenty around so using that we can then

00:18:39,150 --> 00:18:43,830
listen on an event we can use pole or

00:18:42,539 --> 00:18:51,780
select to wait for the event to happen

00:18:43,830 --> 00:18:55,710
and then we handle the event already so

00:18:51,780 --> 00:18:57,419
GPIO that's the that's the fun stuff the

00:18:55,710 --> 00:19:00,000
next few things so I need to look at

00:18:57,419 --> 00:19:03,809
pulse width modulation and I need to

00:19:00,000 --> 00:19:09,690
look at I squared C and then I need to

00:19:03,809 --> 00:19:12,320
make a few something that remarks so

00:19:09,690 --> 00:19:16,440
pulse width modulation this isn't so

00:19:12,320 --> 00:19:20,100
often used perhaps as GPIO s but pretty

00:19:16,440 --> 00:19:24,900
much every SOC has some PWM registers

00:19:20,100 --> 00:19:27,030
pedia PWM circuits and essentially the

00:19:24,900 --> 00:19:29,640
idea of a pulse width modulation is that

00:19:27,030 --> 00:19:31,409
you can create a pulse train as shown at

00:19:29,640 --> 00:19:33,390
the top of a slide there where you have

00:19:31,409 --> 00:19:36,150
a period for the pulse and a duty cycle

00:19:33,390 --> 00:19:38,610
which is the percentage of the period

00:19:36,150 --> 00:19:42,790
essentially that the the level is high

00:19:38,610 --> 00:19:45,520
and then by modifying the duty cycle

00:19:42,790 --> 00:19:48,400
you can change it from 0% which means

00:19:45,520 --> 00:19:49,870
it's permanently after 100% which means

00:19:48,400 --> 00:19:56,890
it's permanently on sewing to the full

00:19:49,870 --> 00:19:59,980
range and it's used the two common use

00:19:56,890 --> 00:20:02,770
cases for pwms are dimmable LEDs

00:19:59,980 --> 00:20:06,310
including back lights so as you change

00:20:02,770 --> 00:20:10,150
the the duty cycle the LED will be

00:20:06,310 --> 00:20:13,750
brighter or dimmer and the second case

00:20:10,150 --> 00:20:16,270
is for servo motors typical typically

00:20:13,750 --> 00:20:19,180
servo motors are controlled by a pulse

00:20:16,270 --> 00:20:21,250
width modulated chain and the deflection

00:20:19,180 --> 00:20:27,750
of the servo motor is controlled by the

00:20:21,250 --> 00:20:32,710
duty cycle so this is kind of useful

00:20:27,750 --> 00:20:34,930
it's fairly simple to to program again

00:20:32,710 --> 00:20:38,320
there is in this case just one interface

00:20:34,930 --> 00:20:43,630
and it's a sisyphus FS interface very

00:20:38,320 --> 00:20:48,550
similar to the GPIO lib interface so if

00:20:43,630 --> 00:20:51,730
we look in this class speed of PWM you

00:20:48,550 --> 00:20:53,290
will see that okay there's a slight

00:20:51,730 --> 00:20:55,120
missing key actually you will see that

00:20:53,290 --> 00:20:59,920
there are a number of PD BM chips

00:20:55,120 --> 00:21:03,570
one for each PDA PWM interface some PWM

00:20:59,920 --> 00:21:06,970
interfaces can handle multiple channels

00:21:03,570 --> 00:21:09,070
so here I'm looking inside a PWM chip 0

00:21:06,970 --> 00:21:13,150
again this is actually from a BeagleBone

00:21:09,070 --> 00:21:20,680
and if we look we need with inside the

00:21:13,150 --> 00:21:22,060
PWM chip you can see that there is my

00:21:20,680 --> 00:21:23,440
arrow needs to move along a little bit

00:21:22,060 --> 00:21:26,080
actually there are two files called

00:21:23,440 --> 00:21:28,480
export and an export so move that

00:21:26,080 --> 00:21:31,060
mentally along a little bit the arrow

00:21:28,480 --> 00:21:35,530
should be pointing to the export so we

00:21:31,060 --> 00:21:38,530
can write the PWM number to export and

00:21:35,530 --> 00:21:43,330
that will then export it and on export

00:21:38,530 --> 00:21:45,940
works in Reverse there is also a file

00:21:43,330 --> 00:21:49,660
there called n / PWM which says how many

00:21:45,940 --> 00:21:53,290
PDM interfaces we have for this PWM chip

00:21:49,660 --> 00:21:55,450
and in the case of this particular chip

00:21:53,290 --> 00:21:58,809
which again is the Beagle bone

00:21:55,450 --> 00:22:04,149
this PDMS PWM chip zero actually

00:21:58,809 --> 00:22:11,049
supports two PWM channels so I can write

00:22:04,149 --> 00:22:13,299
either one or zero or one to export so

00:22:11,049 --> 00:22:18,580
let's go ahead and export channels zero

00:22:13,299 --> 00:22:21,159
and we find then that we get a new

00:22:18,580 --> 00:22:24,700
directory for this PWM interface called

00:22:21,159 --> 00:22:27,639
people PWM zero and if you look within

00:22:24,700 --> 00:22:30,610
that we have the controls necessary to

00:22:27,639 --> 00:22:34,149
control the period and the duty cycle

00:22:30,610 --> 00:22:35,799
and there's a flag to enable it or or

00:22:34,149 --> 00:22:37,779
disable it so initially it will be

00:22:35,799 --> 00:22:42,100
disabled which means it's not actually

00:22:37,779 --> 00:22:45,580
running we can then set the period in

00:22:42,100 --> 00:22:48,090
nanoseconds and the duty cycle so that's

00:22:45,580 --> 00:22:52,809
the on part of the period also in

00:22:48,090 --> 00:22:56,799
nanoseconds oh and there's a far they

00:22:52,809 --> 00:22:59,529
also called polarity we can set polarity

00:22:56,799 --> 00:23:05,169
to 1 which means that it flips it round

00:22:59,529 --> 00:23:06,940
so during the the on period it will be

00:23:05,169 --> 00:23:14,620
low and during the off period it will be

00:23:06,940 --> 00:23:16,210
high so it just inverts the waveform so

00:23:14,620 --> 00:23:19,299
we can do this from the command line or

00:23:16,210 --> 00:23:23,200
from a script so in this case supposing

00:23:19,299 --> 00:23:28,570
I want a PWM with a 1 millisecond period

00:23:23,200 --> 00:23:30,909
and a 50% duty cycle so one millisecond

00:23:28,570 --> 00:23:34,600
turns out to be a million nanoseconds so

00:23:30,909 --> 00:23:37,830
we write 1 million to the period and we

00:23:34,600 --> 00:23:42,159
want it to be 50% on 50% off so we write

00:23:37,830 --> 00:23:44,679
the 500,000 nanoseconds to duty cycle

00:23:42,159 --> 00:23:47,830
this means the thing will be yeah half

00:23:44,679 --> 00:23:50,139
on and half off and then we write one to

00:23:47,830 --> 00:23:52,590
the enable file and that sets the whole

00:23:50,139 --> 00:23:52,590
thing running

00:23:55,050 --> 00:24:01,360
okay so again that's fairly simple to do

00:23:58,150 --> 00:24:03,610
from user space and then the last thing

00:24:01,360 --> 00:24:07,270
on the finish I'm going to talk about is

00:24:03,610 --> 00:24:10,840
going to be I squared C so this is

00:24:07,270 --> 00:24:16,650
inherently more complicated I squared C

00:24:10,840 --> 00:24:20,880
is a simple serial bus to wire bus

00:24:16,650 --> 00:24:25,780
usually used to connect sensor devices

00:24:20,880 --> 00:24:26,800
small eeproms may be control devices

00:24:25,780 --> 00:24:31,390
like touchscreens

00:24:26,800 --> 00:24:35,260
although they usually use SPI so with I

00:24:31,390 --> 00:24:38,080
squared C it is a bus so you have a bus

00:24:35,260 --> 00:24:38,740
controller which is part usually part of

00:24:38,080 --> 00:24:43,120
the SOC

00:24:38,740 --> 00:24:47,080
and then on the bus you have a number of

00:24:43,120 --> 00:24:50,830
peripherals the peripherals have a seven

00:24:47,080 --> 00:24:52,960
bit address usually hardwired so when

00:24:50,830 --> 00:24:55,330
you buy an I squared C chip the

00:24:52,960 --> 00:24:58,600
datasheet tells you which address it is

00:24:55,330 --> 00:25:00,490
using commonly there are two or maybe

00:24:58,600 --> 00:25:05,320
four addresses you can choose farm by

00:25:00,490 --> 00:25:08,110
linking various wires together if you

00:25:05,320 --> 00:25:11,530
have a problem with a conflict where you

00:25:08,110 --> 00:25:16,120
have to I squared C devices with the

00:25:11,530 --> 00:25:17,650
same address well you can put what would

00:25:16,120 --> 00:25:21,820
they put them on different buses most

00:25:17,650 --> 00:25:24,160
systems have several I square C bus

00:25:21,820 --> 00:25:29,620
controllers so you can put them onto

00:25:24,160 --> 00:25:33,880
separate I squared C buses or well well

00:25:29,620 --> 00:25:35,170
you can go and buy a different chip the

00:25:33,880 --> 00:25:39,340
way the addressing works is a little bit

00:25:35,170 --> 00:25:42,100
odd so we have one 128 addresses from a

00:25:39,340 --> 00:25:45,250
seven bit address but a bunch of them

00:25:42,100 --> 00:25:47,860
are reserved by the the bus mechanic or

00:25:45,250 --> 00:25:54,580
the bus electrics so it turns out you

00:25:47,860 --> 00:25:58,540
only really have 112 nodes per bus so

00:25:54,580 --> 00:26:02,170
accessing this from user space you can

00:25:58,540 --> 00:26:05,020
do this by enabling the C dev the I

00:26:02,170 --> 00:26:07,520
squared C dev driver within the kernel

00:26:05,020 --> 00:26:11,810
and that will

00:26:07,520 --> 00:26:16,360
those in the dev directory a device node

00:26:11,810 --> 00:26:20,210
for each of the master bus controllers

00:26:16,360 --> 00:26:23,000
so you might see something like this so

00:26:20,210 --> 00:26:29,200
here we have to balance two controllers

00:26:23,000 --> 00:26:32,360
on bus zero and bus 1 and then as before

00:26:29,200 --> 00:26:35,030
you can access them using open close

00:26:32,360 --> 00:26:38,510
read and write but most of the time you

00:26:35,030 --> 00:26:40,370
use the I used some ioctl functions to

00:26:38,510 --> 00:26:44,660
actually initiate ice I squared C

00:26:40,370 --> 00:26:47,050
transactions the structures you'll need

00:26:44,660 --> 00:26:55,960
to do all this stuff are defined in that

00:26:47,050 --> 00:26:57,830
i2c dev dot H file just as a

00:26:55,960 --> 00:27:02,000
illustration of a couple of things you

00:26:57,830 --> 00:27:04,010
can do so there is a package called I

00:27:02,000 --> 00:27:06,920
squared C tools which help you in

00:27:04,010 --> 00:27:11,000
debugging these things so this is an

00:27:06,920 --> 00:27:14,600
example of using I squared C detect on a

00:27:11,000 --> 00:27:17,480
bus and it's printing out so essentially

00:27:14,600 --> 00:27:20,320
it does a probe to every possible

00:27:17,480 --> 00:27:25,190
address and then prints out the results

00:27:20,320 --> 00:27:30,770
so in this case here there is a device

00:27:25,190 --> 00:27:38,360
at address 39 and they also a bunch of

00:27:30,770 --> 00:27:40,910
things at 53 257 but they're marked with

00:27:38,360 --> 00:27:46,090
a u u so that means they are already

00:27:40,910 --> 00:27:50,210
used by the kernel so we cannot access

00:27:46,090 --> 00:27:54,110
those that those addresses from user

00:27:50,210 --> 00:27:57,260
space in point of fact since again this

00:27:54,110 --> 00:28:01,670
is from a BeagleBone those addresses are

00:27:57,260 --> 00:28:03,830
the I squared C V problems that are used

00:28:01,670 --> 00:28:05,840
by the BeagleBone which contain various

00:28:03,830 --> 00:28:07,660
IDs and suchlike but they're handled

00:28:05,840 --> 00:28:10,580
internally within the caller we can't

00:28:07,660 --> 00:28:15,800
without some fiddling around access some

00:28:10,580 --> 00:28:20,200
from user space so any up so we have a

00:28:15,800 --> 00:28:20,200
device an unhandled device at address 39

00:28:22,000 --> 00:28:29,179
so again from the command line we can

00:28:26,990 --> 00:28:33,080
use there's an I squared C get in I

00:28:29,179 --> 00:28:36,110
squared C set command so we can use this

00:28:33,080 --> 00:28:40,130
for simple diagnostics and simple use

00:28:36,110 --> 00:28:44,330
cases so with I squared C get we give it

00:28:40,130 --> 00:28:47,120
the bus we want to talk to the trip

00:28:44,330 --> 00:28:52,520
address and then the register on that

00:28:47,120 --> 00:28:57,470
ship so in my example here it turns out

00:28:52,520 --> 00:29:01,790
that the the chip at addressed 39 is

00:28:57,470 --> 00:29:04,840
actually a ambient light sensor which I

00:29:01,790 --> 00:29:06,890
bought from Adafruit one time and

00:29:04,840 --> 00:29:11,440
reading through the datasheet from this

00:29:06,890 --> 00:29:15,350
we can see that register 8a contains the

00:29:11,440 --> 00:29:16,460
actually contains the ID so we can check

00:29:15,350 --> 00:29:18,320
that we have the right chip and the

00:29:16,460 --> 00:29:22,490
right version of the chip by reading the

00:29:18,320 --> 00:29:24,410
ID register at 0 X 8 a and it come comes

00:29:22,490 --> 00:29:26,540
back with 50 and then I look in the

00:29:24,410 --> 00:29:31,340
datasheet and they says yes 50 indicates

00:29:26,540 --> 00:29:34,940
this is the right chip so we can use I

00:29:31,340 --> 00:29:39,679
squares so you get to read any 8-bit

00:29:34,940 --> 00:29:42,710
register in a similar way we can use I

00:29:39,679 --> 00:29:47,270
squared C set to change a register value

00:29:42,710 --> 00:29:52,540
I squeeze these I squared C set the bus

00:29:47,270 --> 00:29:52,540
the chip the register and then the value

00:29:55,320 --> 00:30:01,389
[Music]

00:29:57,659 --> 00:30:04,330
if so you can do a certain amount using

00:30:01,389 --> 00:30:07,090
I squared C get and set you can do more

00:30:04,330 --> 00:30:10,899
can more complicated control of the of

00:30:07,090 --> 00:30:14,380
the chip by using the ioctl functions so

00:30:10,899 --> 00:30:20,710
we can use sorry this example code here

00:30:14,380 --> 00:30:27,309
is showing how to read a know so you

00:30:20,710 --> 00:30:29,350
were writing register said it again so

00:30:27,309 --> 00:30:31,360
actually that this code is reading so

00:30:29,350 --> 00:30:35,440
we're open in the the bus I squared C -

00:30:31,360 --> 00:30:39,639
1 we're selecting through the ioctl we

00:30:35,440 --> 00:30:43,389
want to talk to chip 39 and then

00:30:39,639 --> 00:30:47,740
actually we are doing a read of the ID

00:30:43,389 --> 00:30:49,480
register which is at 0 X 8 a it turns

00:30:47,740 --> 00:30:51,250
out that the way that I squared C works

00:30:49,480 --> 00:30:54,370
in actual fact it's you have to do a

00:30:51,250 --> 00:30:57,039
writer than a read it's basically a loop

00:30:54,370 --> 00:30:58,929
so you have to write the value and then

00:30:57,039 --> 00:31:01,029
read the read so you write the register

00:30:58,929 --> 00:31:08,200
value out and then you read the contents

00:31:01,029 --> 00:31:11,320
of the register back alrighty so there

00:31:08,200 --> 00:31:13,600
are 3 as examples of systems of

00:31:11,320 --> 00:31:17,260
increasing complexity from GPIO s which

00:31:13,600 --> 00:31:18,730
are comparatively simple PWM slightly

00:31:17,260 --> 00:31:21,340
more simple slightly more complicating

00:31:18,730 --> 00:31:22,899
maybe and then with I squared C you can

00:31:21,340 --> 00:31:25,690
do quite complicated stuff but again

00:31:22,899 --> 00:31:30,490
doing it without having to touch the

00:31:25,690 --> 00:31:37,539
kernel there are similar interfaces

00:31:30,490 --> 00:31:38,830
generic drivers for SPI for USB and also

00:31:37,539 --> 00:31:41,380
a bunch of others I should have

00:31:38,830 --> 00:31:44,860
mentioned so for example if you are

00:31:41,380 --> 00:31:48,820
using GPIO s as if you have a bunch of

00:31:44,860 --> 00:31:50,590
GPIO buttons to control the user

00:31:48,820 --> 00:31:53,970
interface or something there's a whole

00:31:50,590 --> 00:31:58,570
GPIO buttons subsystem which will map a

00:31:53,970 --> 00:32:01,269
button a key press a button press into a

00:31:58,570 --> 00:32:04,000
key a key code which you can then handle

00:32:01,269 --> 00:32:07,299
within your user interface so we have

00:32:04,000 --> 00:32:08,920
GPIO buttons we have also the LED

00:32:07,299 --> 00:32:11,830
subsystem so

00:32:08,920 --> 00:32:14,410
my example was using the GPIO level to

00:32:11,830 --> 00:32:16,360
access the led there's actually a whole

00:32:14,410 --> 00:32:19,030
as sysclass

00:32:16,360 --> 00:32:24,130
LEDs subsystem which does more

00:32:19,030 --> 00:32:27,520
sophisticated things with LEDs and then

00:32:24,130 --> 00:32:29,560
you can also go drop you can Oh table

00:32:27,520 --> 00:32:32,440
you can ago also go still further by

00:32:29,560 --> 00:32:34,960
using the user-defined IO subsystem so

00:32:32,440 --> 00:32:39,610
this is very generic it allows you to

00:32:34,960 --> 00:32:42,130
create again from user space a program

00:32:39,610 --> 00:32:46,300
that completely accesses the hardware

00:32:42,130 --> 00:32:48,940
sent using the u io framework you can

00:32:46,300 --> 00:32:51,850
map the registers of the the piece of

00:32:48,940 --> 00:32:55,180
hardware into the application memory

00:32:51,850 --> 00:32:57,940
address space you can also write a

00:32:55,180 --> 00:33:00,340
little stub kernel function which will

00:32:57,940 --> 00:33:01,990
handle interrupts and then you can

00:33:00,340 --> 00:33:06,130
actually do the majority of the handling

00:33:01,990 --> 00:33:10,030
in user space so this is the the main

00:33:06,130 --> 00:33:12,970
use case for this seems to be FPGAs if

00:33:10,030 --> 00:33:15,580
you haven't if your great an FPGA you

00:33:12,970 --> 00:33:18,820
will inevitably be creating some kind of

00:33:15,580 --> 00:33:22,450
interface through that piece of hardware

00:33:18,820 --> 00:33:25,990
and the simplest way to access access

00:33:22,450 --> 00:33:29,100
that from user space is to use the u i/o

00:33:25,990 --> 00:33:34,260
subsystem to access your bunch of

00:33:29,100 --> 00:33:34,260
registers that are exposed on the FPGA

00:33:36,690 --> 00:33:44,530
what are you missing by not writing a

00:33:39,910 --> 00:33:46,060
kernel device driver so there are some

00:33:44,530 --> 00:33:48,010
things there are there are reasons that

00:33:46,060 --> 00:33:54,880
kernel device drivers exist in the first

00:33:48,010 --> 00:33:59,020
place there are a couple of things to do

00:33:54,880 --> 00:34:03,070
with robustness and performance so it is

00:33:59,020 --> 00:34:07,960
perhaps a worry to you that if you are

00:34:03,070 --> 00:34:10,060
handling a device from user space a user

00:34:07,960 --> 00:34:13,000
user space program can be killed

00:34:10,060 --> 00:34:16,120
and terminated whereas there's no way to

00:34:13,000 --> 00:34:18,310
kill or terminate a kernel device driver

00:34:16,120 --> 00:34:22,720
except by terminating the entire kernel

00:34:18,310 --> 00:34:25,450
of course so it is may be smart and

00:34:22,720 --> 00:34:28,960
you could be regarded as being more

00:34:25,450 --> 00:34:33,280
robust to put the code into the kernel

00:34:28,960 --> 00:34:36,849
for that reason also within the karna we

00:34:33,280 --> 00:34:40,800
have a lot of sophisticated locking

00:34:36,849 --> 00:34:43,750
techniques from spin locks mutexes

00:34:40,800 --> 00:34:46,659
read/write locks and the recopy white

00:34:43,750 --> 00:34:50,409
update mechanism so you can do if you

00:34:46,659 --> 00:34:52,270
have highly contended locking scenarios

00:34:50,409 --> 00:34:55,540
you can do those better in the kernel

00:34:52,270 --> 00:34:57,849
then you kind of use a space and also

00:34:55,540 --> 00:34:59,170
you have more direct access access to

00:34:57,849 --> 00:35:02,230
the hardware so you can do fancy things

00:34:59,170 --> 00:35:06,040
with memory addresses and DMAs and such

00:35:02,230 --> 00:35:08,590
like and then finally and probably the

00:35:06,040 --> 00:35:10,690
biggest reason to write kernel device

00:35:08,590 --> 00:35:12,550
drivers in the first place is that there

00:35:10,690 --> 00:35:14,920
are a whole bunch of subsystems within

00:35:12,550 --> 00:35:17,650
the kernel which you can just slot in

00:35:14,920 --> 00:35:19,390
another device driver took a to cover so

00:35:17,650 --> 00:35:22,750
a simple example of this is the

00:35:19,390 --> 00:35:27,700
backlight the LCD backlight it's usually

00:35:22,750 --> 00:35:29,680
a PWM channel that controls that so you

00:35:27,700 --> 00:35:32,650
could quite easily control it from user

00:35:29,680 --> 00:35:35,500
space using the PWM user space mechanism

00:35:32,650 --> 00:35:38,349
we just talked about but in fact there

00:35:35,500 --> 00:35:41,260
is another subsystem the backlight

00:35:38,349 --> 00:35:45,130
subsystem which exposes a different user

00:35:41,260 --> 00:35:48,730
interface via sisyphus and if you want

00:35:45,130 --> 00:35:50,770
to expose your LCD backlight using that

00:35:48,730 --> 00:35:54,420
standard interface you would have to

00:35:50,770 --> 00:35:54,420
write some kernel code to do that

00:35:55,830 --> 00:36:00,490
okay-dokey and that is everything I have

00:35:58,599 --> 00:36:04,240
to say on this subject right now so we

00:36:00,490 --> 00:36:09,130
have a couple of minutes literally three

00:36:04,240 --> 00:36:10,960
minutes spare for questions so if you if

00:36:09,130 --> 00:36:12,339
you want to ask me a question can I

00:36:10,960 --> 00:36:15,430
encourage you to come and use the

00:36:12,339 --> 00:36:18,580
microphones here so that the question is

00:36:15,430 --> 00:36:21,490
recorded on the on the video that's been

00:36:18,580 --> 00:36:25,480
made but yes anybody have any questions

00:36:21,490 --> 00:36:27,869
or comments on not writing kernel device

00:36:25,480 --> 00:36:27,869
drivers

00:36:29,829 --> 00:36:33,669
I'm afraid it's a long walk

00:36:42,950 --> 00:36:50,130
just working yeah seems to her focus has

00:36:47,730 --> 00:36:53,790
been made on being at access DNA from

00:36:50,130 --> 00:36:56,280
the use of space in our company for that

00:36:53,790 --> 00:36:57,839
kind of task but there didn't seem to be

00:36:56,280 --> 00:37:01,530
anything very stable yet there was some

00:36:57,839 --> 00:37:03,720
movement in that area but more so which

00:37:01,530 --> 00:37:05,190
interfaces did you did you look at which

00:37:03,720 --> 00:37:07,740
one of us we were looking at there was

00:37:05,190 --> 00:37:15,599
something that exposed setting up the

00:37:07,740 --> 00:37:18,780
DMA Channel from a user task yeah so

00:37:15,599 --> 00:37:22,319
accessing DMA channels directly from

00:37:18,780 --> 00:37:25,109
user space is kind of tricky because the

00:37:22,319 --> 00:37:28,500
DMA channel is but the side the DMA

00:37:25,109 --> 00:37:32,940
hardware is very specific to an

00:37:28,500 --> 00:37:34,980
application to a chip and the way the

00:37:32,940 --> 00:37:37,309
memory is allocated in the way memory

00:37:34,980 --> 00:37:41,849
addresses are handled is also very

00:37:37,309 --> 00:37:44,400
system specific so I would guess well

00:37:41,849 --> 00:37:46,680
okay I'm not aware of any standardized

00:37:44,400 --> 00:37:49,170
way of accessing DMA channels from user

00:37:46,680 --> 00:37:51,270
space and I would guess that there would

00:37:49,170 --> 00:37:54,660
not be such a thing because it is kind

00:37:51,270 --> 00:37:56,430
of tricky and device specific so there

00:37:54,660 --> 00:38:00,150
may be particularly examples in

00:37:56,430 --> 00:38:01,980
particular particular board support

00:38:00,150 --> 00:38:04,460
packages but I don't expect to find a

00:38:01,980 --> 00:38:04,460
generic one

00:38:13,800 --> 00:38:16,490
okay

00:38:22,350 --> 00:38:28,110
hello hi talking about GPIO s have you

00:38:25,380 --> 00:38:31,500
looked at Lib GPIO D which is a tool

00:38:28,110 --> 00:38:33,420
that exposes four character driver sets

00:38:31,500 --> 00:38:37,010
of functions that you can over script or

00:38:33,420 --> 00:38:40,460
a fiber binding since your patent oh

00:38:37,010 --> 00:38:43,620
yeah so there's a good point

00:38:40,460 --> 00:38:45,870
the way I describe the interface is is

00:38:43,620 --> 00:38:48,090
that you write the IOC tails directly in

00:38:45,870 --> 00:38:50,070
your you know in your code to control

00:38:48,090 --> 00:38:53,340
either GPIO S or I squared C or whatever

00:38:50,070 --> 00:38:56,850
there are in many cases libraries that

00:38:53,340 --> 00:39:01,920
will help you do this including lib GPIO

00:38:56,850 --> 00:39:04,080
beep yeah which is gives you a

00:39:01,920 --> 00:39:06,480
high-level abstraction and is easier to

00:39:04,080 --> 00:39:09,090
code to so in fact I would actually

00:39:06,480 --> 00:39:11,220
recommend you would use one a libraries

00:39:09,090 --> 00:39:15,290
such as that I just didn't really have

00:39:11,220 --> 00:39:15,290
time to delve into that in the slides

00:39:16,280 --> 00:39:22,440
it's it's also upstream in your camera

00:39:19,890 --> 00:39:26,940
so you can build it in okay okay right I

00:39:22,440 --> 00:39:28,980
didn't know that good okay

00:39:26,940 --> 00:39:32,360
maybe time for one more question I think

00:39:28,980 --> 00:39:32,360
we're coming to the end of our slot

00:39:33,140 --> 00:39:37,140
Michael you know in there a Raspberry Pi

00:39:35,460 --> 00:39:39,120
well there are lots of Python libraries

00:39:37,140 --> 00:39:41,010
for for doing stuff in user space never

00:39:39,120 --> 00:39:43,590
change your kernel yeah any any

00:39:41,010 --> 00:39:45,810
experiment on other platforms like I

00:39:43,590 --> 00:39:47,640
guess it's possible at Rice this works

00:39:45,810 --> 00:39:52,140
the same way on people in black for

00:39:47,640 --> 00:39:56,130
example well it would be nice if there

00:39:52,140 --> 00:39:59,010
was so certainly the the Raspberry Pi

00:39:56,130 --> 00:40:01,950
and the Beagle bone also has bone script

00:39:59,010 --> 00:40:03,780
which does something very similar so

00:40:01,950 --> 00:40:06,450
these these platforms are highly

00:40:03,780 --> 00:40:12,000
scriptable using python or json or

00:40:06,450 --> 00:40:15,720
whatever scripting language you like I I

00:40:12,000 --> 00:40:17,970
don't know of very much effort to port

00:40:15,720 --> 00:40:22,550
that to other more deeply embedded

00:40:17,970 --> 00:40:28,230
platforms so Mike's experience at least

00:40:22,550 --> 00:40:30,000
if you get a single board computer or a

00:40:28,230 --> 00:40:33,170
system on module from one of the many

00:40:30,000 --> 00:40:35,869
vendors of these things they don't come

00:40:33,170 --> 00:40:38,510
Python support very much they don't come

00:40:35,869 --> 00:40:40,369
with with fully scripted whatever so it

00:40:38,510 --> 00:40:44,329
would be nice if they if they were to

00:40:40,369 --> 00:40:45,980
and maybe as the Raspberry Pi concept

00:40:44,329 --> 00:40:49,700
continues to roll through people will

00:40:45,980 --> 00:40:51,559
start doing this more but yeah it would

00:40:49,700 --> 00:40:52,640
make the life it would make our lives a

00:40:51,559 --> 00:40:58,790
lot easier if we could just write

00:40:52,640 --> 00:41:01,760
everything in Python code okay I think

00:40:58,790 --> 00:41:05,990
we're pretty much out of time now so if

00:41:01,760 --> 00:41:09,920
anybody has any remaining questions grab

00:41:05,990 --> 00:41:12,040
me as we finish this this session but

00:41:09,920 --> 00:41:14,180
meanwhile thank you all very much for

00:41:12,040 --> 00:41:16,359
coming along to this and I hope it's

00:41:14,180 --> 00:41:16,359
been useful

00:41:17,920 --> 00:41:20,749

YouTube URL: https://www.youtube.com/watch?v=QIO2pJqMxjE


