Title: DMA Safety in Buffers for Linux Kernel Device Drivers - Wolfram Sang, Renesas   Consultant
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	DMA Safety in Buffers for Linux Kernel Device Drivers - Wolfram Sang, Renesas / Consultant

This talk is about findings which originated from an issue in the I2C subsystem but then became more widespread. The question was if externally allocated message buffers for the I2C subsystem need to be DMA safe. That gained importance and needed a proper solution.

While working on this, buffer handling in other subsystems was evaluated regarding DMA safety. It turned out that some, including I2C, work rather by coincidence or, at least, on assumptions which are likely to be true, but not always. And those assumptions might even be less likely true in the future, given some structural changes kernel hardening brings.

Learn that a check if buffers are DMA capable is surprisingly not an easy task. And find out which solutions exist as of today. With safety being an increasing interest for embedded, more eyes are needed for this problem. 

About Wolfram Sang
Wolfram Sang has been working as a Linux kernel developer for embedded systems since 2008. He maintains the I2C subsystem and works as a consultant, mainly for the Renesas Upstream Kernel Team. Programming since his childhood, he still hacks his machines from the 80s, especially the C64. When not using computers, he is interested in ecological topics, likes cooking and tries to keep his Japanese alive. He has spoken at various conferences like ELCE, ELC, OpenSourceSummit, LinuxCon, LinuxTag, and FOSDEM multiple times mostly about kernel topics.
Captions: 
	00:00:00,110 --> 00:00:08,069
thank you very much all for coming here

00:00:02,340 --> 00:00:11,400
had this for me quite early time my name

00:00:08,069 --> 00:00:15,199
is Warren I'm the current maintainer of

00:00:11,400 --> 00:00:17,910
the I square XI subsystem in Linux and I

00:00:15,199 --> 00:00:22,699
want to talk about today about something

00:00:17,910 --> 00:00:25,830
I learned the hard way when I was

00:00:22,699 --> 00:00:29,099
preparing my subsystem for proper DMA

00:00:25,830 --> 00:00:31,050
usage so and I found a few things out I

00:00:29,099 --> 00:00:34,200
want to speak about I want to get known

00:00:31,050 --> 00:00:37,170
and I hope you can spread them and we

00:00:34,200 --> 00:00:39,590
can together raise awareness and

00:00:37,170 --> 00:00:45,180
hopefully somewhere settle this topic

00:00:39,590 --> 00:00:48,180
because if DMA goes wrong and unexpected

00:00:45,180 --> 00:00:51,239
situation situations you can imagine

00:00:48,180 --> 00:00:56,730
that I can have quite drastic

00:00:51,239 --> 00:00:59,309
consequences so about I Square C and D

00:00:56,730 --> 00:01:01,800
mas if some of you say why would you

00:00:59,309 --> 00:01:03,989
ever use DMA with I square C then I'm

00:01:01,800 --> 00:01:07,260
quite kind of with you

00:01:03,989 --> 00:01:09,810
the usual use case is that you send lots

00:01:07,260 --> 00:01:12,119
of small messages like they're having a

00:01:09,810 --> 00:01:17,430
register and the value you want to poke

00:01:12,119 --> 00:01:20,340
into that register so when I Square C

00:01:17,430 --> 00:01:24,689
entered Linux long long ago DMA wasn't

00:01:20,340 --> 00:01:25,770
really considered and so there were also

00:01:24,689 --> 00:01:28,650
no rules

00:01:25,770 --> 00:01:31,650
how buffers should be should they should

00:01:28,650 --> 00:01:33,299
they be should DMA taken B into account

00:01:31,650 --> 00:01:36,180
when you set up the message buffers

00:01:33,299 --> 00:01:38,040
because of course we have inside the

00:01:36,180 --> 00:01:40,049
struct I Square C message we have a

00:01:38,040 --> 00:01:45,899
pointer to a buffer where the actual

00:01:40,049 --> 00:01:47,579
data data is and one thing well you all

00:01:45,899 --> 00:01:50,130
know Murphy's Law if you don't have

00:01:47,579 --> 00:01:53,100
clear rules and give a chance of things

00:01:50,130 --> 00:01:56,390
going wrong things will go wrong in all

00:01:53,100 --> 00:01:59,759
possible ways you can imagine when I

00:01:56,390 --> 00:02:02,759
finally had only notice that they have

00:01:59,759 --> 00:02:04,590
issues with sending buffers via DMA and

00:02:02,759 --> 00:02:06,360
found out well well do the buffers come

00:02:04,590 --> 00:02:08,910
from like really come from everywhere

00:02:06,360 --> 00:02:10,380
heaps tagged read-only data okay map

00:02:08,910 --> 00:02:14,610
memory

00:02:10,380 --> 00:02:17,280
and whatnot so if you if there is no

00:02:14,610 --> 00:02:24,630
route people go creative and do all this

00:02:17,280 --> 00:02:28,560
kind of stuff so when when thinking

00:02:24,630 --> 00:02:35,400
about it more or trying to get a clear

00:02:28,560 --> 00:02:37,290
rule oh you're sorry with some

00:02:35,400 --> 00:02:40,500
discussions after some discussions on

00:02:37,290 --> 00:02:42,810
the mailing list I thought it would be

00:02:40,500 --> 00:02:47,550
still best to have a clear rule which

00:02:42,810 --> 00:02:49,650
says DMA is optional I don't want like

00:02:47,550 --> 00:02:54,120
other subsystems do that they require

00:02:49,650 --> 00:02:56,880
their message buffers to be DMA safe but

00:02:54,120 --> 00:02:59,580
I didn't want to go that road for

00:02:56,880 --> 00:03:02,370
i-square she in retrospect for the

00:02:59,580 --> 00:03:04,350
reasons I've given there I was afraid of

00:03:02,370 --> 00:03:06,570
regressions because they were like this

00:03:04,350 --> 00:03:10,320
zillion of drivers getting buffers from

00:03:06,570 --> 00:03:12,270
everywhere and to which to drivers for

00:03:10,320 --> 00:03:18,560
hardware we don't have access to and I

00:03:12,270 --> 00:03:23,900
didn't want to mess convert that and so

00:03:18,560 --> 00:03:27,150
it was optional this the default case is

00:03:23,900 --> 00:03:29,040
we don't care too much about DMA but we

00:03:27,150 --> 00:03:33,090
want to have some guidance if you want

00:03:29,040 --> 00:03:34,739
to use DMA and of course that's why I'm

00:03:33,090 --> 00:03:36,660
here I want to speak about this that

00:03:34,739 --> 00:03:39,660
this is the case so people know and can

00:03:36,660 --> 00:03:42,239
handle their buffers properly so great

00:03:39,660 --> 00:03:45,180
now I decided that DMA is optional for

00:03:42,239 --> 00:03:49,530
i-square see that but but that means we

00:03:45,180 --> 00:03:52,860
have two potential code paths so we have

00:03:49,530 --> 00:03:56,040
a buffer which is DMA safe or we don't

00:03:52,860 --> 00:03:57,930
have and we need to go in bus drivers

00:03:56,040 --> 00:03:59,489
sending out the data to go this or that

00:03:57,930 --> 00:04:03,720
direction but how do we decide which

00:03:59,489 --> 00:04:06,120
direction to go ideally we would do this

00:04:03,720 --> 00:04:07,530
in a perfect world we will do this at

00:04:06,120 --> 00:04:09,540
runtime we just look at the buffer and

00:04:07,530 --> 00:04:11,220
say yeah that's good we use DMA or no

00:04:09,540 --> 00:04:16,709
it's not good so let's just you pulled

00:04:11,220 --> 00:04:19,169
it out and yeah that's the time I what

00:04:16,709 --> 00:04:21,150
and they I wondered yeah why isn't there

00:04:19,169 --> 00:04:21,739
a function for us like it's DMA capable

00:04:21,150 --> 00:04:28,550
for

00:04:21,739 --> 00:04:31,759
for what and the the fact that such a

00:04:28,550 --> 00:04:34,910
function does not exist already of

00:04:31,759 --> 00:04:38,300
course should raise him that this is not

00:04:34,910 --> 00:04:40,880
a very easy topic and it probably does

00:04:38,300 --> 00:04:42,740
not exist for a reason but I wanted to

00:04:40,880 --> 00:04:46,069
be brave and find out on my own and just

00:04:42,740 --> 00:04:48,740
how should the function look like if I

00:04:46,069 --> 00:04:51,590
want to find out at run time if a buffer

00:04:48,740 --> 00:04:53,180
is deem a safe so I started looking what

00:04:51,590 --> 00:04:57,110
kind of functions we have to check that

00:04:53,180 --> 00:05:01,370
and then you verify find like maybe this

00:04:57,110 --> 00:05:02,840
address and this function and then you

00:05:01,370 --> 00:05:06,020
find out well it's not enough there's

00:05:02,840 --> 00:05:09,130
there's a might be a better one or you

00:05:06,020 --> 00:05:12,020
should take out into consideration this

00:05:09,130 --> 00:05:15,500
or objects might be on the stack that

00:05:12,020 --> 00:05:17,960
you need to check out as well and by

00:05:15,500 --> 00:05:20,240
pointing out this this is what Gregg for

00:05:17,960 --> 00:05:22,190
Hartman so the use be subsystem also

00:05:20,240 --> 00:05:25,400
needs to deal with that problem Lehman

00:05:22,190 --> 00:05:28,039
is safe or not and they have I think

00:05:25,400 --> 00:05:30,289
they mainly she used to check with that

00:05:28,039 --> 00:05:32,000
function and then somebody said oh well

00:05:30,289 --> 00:05:34,580
maybe we need to add this check as well

00:05:32,000 --> 00:05:35,930
and I don't want to bet wreck I just

00:05:34,580 --> 00:05:39,469
want to make out it's really complicated

00:05:35,930 --> 00:05:40,849
to or hard to know which functions there

00:05:39,469 --> 00:05:43,580
are inside the kernel interesado I

00:05:40,849 --> 00:05:46,630
didn't know we had that macro to check

00:05:43,580 --> 00:05:49,280
it so um it really it is complicated and

00:05:46,630 --> 00:05:52,310
if you think about cache line alignment

00:05:49,280 --> 00:05:55,009
and this was the point where I said okay

00:05:52,310 --> 00:06:01,569
no this is not going to fly I understand

00:05:55,009 --> 00:06:04,389
why there is no such function yet and

00:06:01,569 --> 00:06:09,530
this check at run time

00:06:04,389 --> 00:06:12,380
I won't go this way there is this geumja

00:06:09,530 --> 00:06:14,690
oh it's renamed but these days I'm sorry

00:06:12,380 --> 00:06:18,669
this file name is not corrected it has

00:06:14,690 --> 00:06:23,509
been moved but it's basically the same

00:06:18,669 --> 00:06:26,270
there's a debug kay config option for

00:06:23,509 --> 00:06:28,729
DMA and if you do development I really

00:06:26,270 --> 00:06:30,740
really recommend to have it on all the

00:06:28,729 --> 00:06:32,100
time because it will find a lot of

00:06:30,740 --> 00:06:35,880
things

00:06:32,100 --> 00:06:39,150
it's made it found the back in a driver

00:06:35,880 --> 00:06:42,390
for four renesis hardware I I'm looking

00:06:39,150 --> 00:06:44,100
after which we could find before it

00:06:42,390 --> 00:06:49,250
appeared in the field so it's really

00:06:44,100 --> 00:06:53,010
good but it's not good for production

00:06:49,250 --> 00:06:56,880
kernels of course so you should really

00:06:53,010 --> 00:06:59,880
do this during development and so ok I

00:06:56,880 --> 00:07:02,190
should also I I've also talked about it

00:06:59,880 --> 00:07:04,470
about this topic in honor at a

00:07:02,190 --> 00:07:07,500
conference in Japan so if you see some

00:07:04,470 --> 00:07:10,620
strike through this is the information

00:07:07,500 --> 00:07:13,470
which has changed since this talk and I

00:07:10,620 --> 00:07:15,870
think it's quite worth noting that the

00:07:13,470 --> 00:07:22,590
DMA debug code increased by one kilobyte

00:07:15,870 --> 00:07:25,110
since this summer so it's really a

00:07:22,590 --> 00:07:28,380
delicate topic so we have that but we

00:07:25,110 --> 00:07:32,040
can't use it for production kernels it

00:07:28,380 --> 00:07:35,040
but it's another idea how how acceptable

00:07:32,040 --> 00:07:38,370
is uncomplicated this issue is so what I

00:07:35,040 --> 00:07:41,610
did for I squishy is say I have an

00:07:38,370 --> 00:07:43,770
opt-in approach so with with an ice

00:07:41,610 --> 00:07:46,650
cream the messages can have certain

00:07:43,770 --> 00:07:50,250
flags and so I just added a new flag

00:07:46,650 --> 00:07:53,070
which says yes I know this buffer can be

00:07:50,250 --> 00:07:56,460
handled with DMA it's called DMA safe so

00:07:53,070 --> 00:07:58,680
opt-in which means that a lot of driver

00:07:56,460 --> 00:08:00,600
need to be manually audited and added

00:07:58,680 --> 00:08:04,820
but I think this is when you look at

00:08:00,600 --> 00:08:04,820
regression this is the same thing to do

00:08:05,090 --> 00:08:14,730
and to make it easier for drivers I have

00:08:08,610 --> 00:08:17,250
a small API which helps you to if you

00:08:14,730 --> 00:08:18,780
want to do DMA you just use this helper

00:08:17,250 --> 00:08:21,060
function and the message you want to

00:08:18,780 --> 00:08:23,850
process and it will check for you if the

00:08:21,060 --> 00:08:26,820
buffer is DMA safe based on the flag and

00:08:23,850 --> 00:08:30,570
if it's not EMA safe you get a bounce

00:08:26,820 --> 00:08:32,729
buffer so that whenever the when this

00:08:30,570 --> 00:08:34,770
function returns and you have a non null

00:08:32,729 --> 00:08:36,750
pointer you have a buffer you can use

00:08:34,770 --> 00:08:41,810
with DMA and you don't need to care

00:08:36,750 --> 00:08:44,310
where it comes from and there's cleanup

00:08:41,810 --> 00:08:45,490
function for that as well which as you

00:08:44,310 --> 00:08:50,230
see got renamed to

00:08:45,490 --> 00:08:51,190
the API a little more proper this is

00:08:50,230 --> 00:08:52,899
super sip

00:08:51,190 --> 00:08:54,670
really we're still thinking about I

00:08:52,899 --> 00:08:57,339
scratchy is super simple most of the

00:08:54,670 --> 00:08:59,529
messages will not require DMA so this is

00:08:57,339 --> 00:09:02,649
a one-to-one mapping in one's buffer

00:08:59,529 --> 00:09:08,110
mapping if you have if you're not happy

00:09:02,649 --> 00:09:11,470
with that you can do your own pool based

00:09:08,110 --> 00:09:14,470
approach based on this DMA flag if you

00:09:11,470 --> 00:09:17,589
want that but I think for the generic

00:09:14,470 --> 00:09:25,720
approach this one-to-one mapping is it's

00:09:17,589 --> 00:09:29,170
okay and on the I square sheet client

00:09:25,720 --> 00:09:33,310
side we have queue new function calls

00:09:29,170 --> 00:09:35,620
so the standard function called to just

00:09:33,310 --> 00:09:38,020
get and receive data are called I Square

00:09:35,620 --> 00:09:45,330
C master receive and send and now we

00:09:38,020 --> 00:09:45,330
have that extended with DMA safe so that

00:09:46,410 --> 00:09:51,430
you can use this new flag from from the

00:09:49,690 --> 00:09:54,430
client side and have have all that

00:09:51,430 --> 00:09:56,620
properly working it's worth noting that

00:09:54,430 --> 00:09:57,940
if you use send messages from user space

00:09:56,620 --> 00:10:01,779
that we have a user space a def

00:09:57,940 --> 00:10:04,240
interface they are all copy those

00:10:01,779 --> 00:10:05,950
messages are all copied from user space

00:10:04,240 --> 00:10:08,140
to kernel space anyway and then it's

00:10:05,950 --> 00:10:09,820
guaranteed that those buffers are DMA

00:10:08,140 --> 00:10:11,709
safe so happily we don't need to fix

00:10:09,820 --> 00:10:17,560
user space that's that's a good good

00:10:11,709 --> 00:10:19,750
news and they're also quite a lot used

00:10:17,560 --> 00:10:22,300
in the kernel are not directly I Square

00:10:19,750 --> 00:10:24,660
C transfers but as M bus transfers to

00:10:22,300 --> 00:10:29,560
kind of a fallback for more limited

00:10:24,660 --> 00:10:31,959
hardware and this I square C controllers

00:10:29,560 --> 00:10:33,700
emulate these smbus Calton or everything

00:10:31,959 --> 00:10:35,500
which is emulated will be also D

00:10:33,700 --> 00:10:39,010
emissive because there's copying around

00:10:35,500 --> 00:10:41,079
so actually most drivers should be okay

00:10:39,010 --> 00:10:43,839
with this change there are some which

00:10:41,079 --> 00:10:46,870
are directly using hi square C messages

00:10:43,839 --> 00:10:49,990
which need to be adapted as I said opt

00:10:46,870 --> 00:10:52,149
in every driver needs to be checked and

00:10:49,990 --> 00:10:55,470
the bus master drivers need to handle

00:10:52,149 --> 00:10:55,470
that flag also

00:10:56,470 --> 00:11:04,070
the problem with i-square see again it's

00:11:00,250 --> 00:11:06,920
not only used directly but also well

00:11:04,070 --> 00:11:13,670
like read map is a huge user of i-square

00:11:06,920 --> 00:11:17,270
she especially exciting codex and stuff

00:11:13,670 --> 00:11:22,340
like this and so I needed to sing with

00:11:17,270 --> 00:11:25,670
Marc Brown how he could access this new

00:11:22,340 --> 00:11:27,710
DMA safe functions and by the way how

00:11:25,670 --> 00:11:30,500
handle I asked him how it Eric Schmidt

00:11:27,710 --> 00:11:33,770
handles DMA at all because it doesn't

00:11:30,500 --> 00:11:36,170
use not only am i Square C but SPI and

00:11:33,770 --> 00:11:39,940
slim bus and whatever buses is sometimes

00:11:36,170 --> 00:11:42,710
buses I've never heard of and they

00:11:39,940 --> 00:11:44,960
what's a common ground of this and

00:11:42,710 --> 00:11:47,420
that's what he said we pretty much

00:11:44,960 --> 00:11:49,250
assume everything is DMA safe it so it's

00:11:47,420 --> 00:11:58,010
an assumption there's also not a clear

00:11:49,250 --> 00:11:59,690
rule and when saying how I can't really

00:11:58,010 --> 00:12:02,570
think of a particular good way how to

00:11:59,690 --> 00:12:04,880
handle all this and what I proposed to

00:12:02,570 --> 00:12:07,220
him doing him a safe is not particularly

00:12:04,880 --> 00:12:10,730
appealing but might be the best we can

00:12:07,220 --> 00:12:13,190
have I'm pretty aware that this is just

00:12:10,730 --> 00:12:14,960
what I came up with is a solution only

00:12:13,190 --> 00:12:18,400
for I square C which it's not very

00:12:14,960 --> 00:12:21,380
generic but I really want did want to

00:12:18,400 --> 00:12:22,970
get this part of the kernel more robust

00:12:21,380 --> 00:12:25,940
because people were seeing crashes

00:12:22,970 --> 00:12:27,950
because of that and this is what I could

00:12:25,940 --> 00:12:31,100
come up with in that short amount of

00:12:27,950 --> 00:12:33,220
time and he really nailed it when I

00:12:31,100 --> 00:12:35,540
asked so should we do it like this I

00:12:33,220 --> 00:12:37,400
really like this phrase it's hard to

00:12:35,540 --> 00:12:39,410
summon enthusiasm but yes without

00:12:37,400 --> 00:12:42,920
changes to the DMA stuff is probably as

00:12:39,410 --> 00:12:45,650
good as we can do which is exactly my

00:12:42,920 --> 00:12:47,480
opinion so I implemented that and I'm

00:12:45,650 --> 00:12:51,550
happy that we improved the situation but

00:12:47,480 --> 00:12:56,300
I'm not super happy about it because

00:12:51,550 --> 00:12:58,430
what he also later said we need like

00:12:56,300 --> 00:13:01,520
annotated buffers it would be super

00:12:58,430 --> 00:13:03,500
super great if we have a buffer object

00:13:01,520 --> 00:13:05,850
or whatever which could be annotated so

00:13:03,500 --> 00:13:08,250
we just can check if this was DMA safe

00:13:05,850 --> 00:13:09,569
so I put this on the i-square sea level

00:13:08,250 --> 00:13:13,459
but it should be really on the lower

00:13:09,569 --> 00:13:15,690
level but we don't have that yet and

00:13:13,459 --> 00:13:21,779
actually as you can imagine this is a

00:13:15,690 --> 00:13:24,300
big task yeah

00:13:21,779 --> 00:13:26,399
and because red net is a user of other

00:13:24,300 --> 00:13:30,029
subsystems I checked some other

00:13:26,399 --> 00:13:32,940
subsystems and they're likes for sure's

00:13:30,029 --> 00:13:34,740
Limbo's SP MI and one wire which do have

00:13:32,940 --> 00:13:37,160
buffers with they they have in the same

00:13:34,740 --> 00:13:40,050
situation that I square si used to be

00:13:37,160 --> 00:13:42,899
they have some structs to pass around

00:13:40,050 --> 00:13:44,910
messages these structs have a buffer

00:13:42,899 --> 00:13:48,600
point pointer to a buffer and they have

00:13:44,910 --> 00:13:51,240
no rules set and nothing is mentioned

00:13:48,600 --> 00:13:54,720
about the buffers being DMA safe or not

00:13:51,240 --> 00:13:57,029
and so it could easily happen that

00:13:54,720 --> 00:13:59,940
somebody is partying a buffer which gets

00:13:57,029 --> 00:14:03,420
someone used with the DMA capable

00:13:59,940 --> 00:14:07,470
controller and things can go wrong

00:14:03,420 --> 00:14:09,779
really bad from from that point the

00:14:07,470 --> 00:14:12,269
nasty thing is most most of the time it

00:14:09,779 --> 00:14:15,300
will work but when you look from it as a

00:14:12,269 --> 00:14:16,920
safety purse perspective most of the

00:14:15,300 --> 00:14:24,630
time is not good enough clearly not good

00:14:16,920 --> 00:14:27,540
enough it needs to work every time SPI

00:14:24,630 --> 00:14:32,880
is another subsystem I looked at it's a

00:14:27,540 --> 00:14:34,439
lot better even given the documentation

00:14:32,880 --> 00:14:37,860
side of things because it has clearly

00:14:34,439 --> 00:14:39,509
documented where I said where

00:14:37,860 --> 00:14:41,189
follow standard kernel routes and

00:14:39,509 --> 00:14:44,279
provide DMA save buffers in your

00:14:41,189 --> 00:14:46,199
messages so this is a clear rule it even

00:14:44,279 --> 00:14:49,649
has helpers to do the mapping and

00:14:46,199 --> 00:14:52,170
unwrapping so you could think great this

00:14:49,649 --> 00:14:57,750
is the subsystem all cases solve DMA is

00:14:52,170 --> 00:15:02,160
not an issue for them but I am I found a

00:14:57,750 --> 00:15:10,230
thread where there was an issue with

00:15:02,160 --> 00:15:14,970
doing an u BFS file system on an SPI nor

00:15:10,230 --> 00:15:18,720
flash at well obviously connected to the

00:15:14,970 --> 00:15:21,629
system via SPI and you BFS

00:15:18,720 --> 00:15:23,339
for reasons which I haven't really dug

00:15:21,629 --> 00:15:26,970
into but in that message set were said

00:15:23,339 --> 00:15:31,439
are okay use a farm a log buffers at

00:15:26,970 --> 00:15:33,899
some times and there's a whole thread

00:15:31,439 --> 00:15:35,759
how to fix this issue I am Not sure I

00:15:33,899 --> 00:15:38,100
haven't Jeff followed up but I'm not

00:15:35,759 --> 00:15:40,019
sure if it's fixed by now but there was

00:15:38,100 --> 00:15:43,199
a lengthy discussion about how to do

00:15:40,019 --> 00:15:46,860
things properly so even with these clear

00:15:43,199 --> 00:15:52,699
rules there can be still issues so if

00:15:46,860 --> 00:15:57,209
you okay

00:15:52,699 --> 00:15:59,459
Wow okay Arne said that spine or is

00:15:57,209 --> 00:16:02,879
completely separate from SPI in the

00:15:59,459 --> 00:16:06,089
kernel so that might be that the rule is

00:16:02,879 --> 00:16:08,339
not affected but it's still a point in

00:16:06,089 --> 00:16:12,149
the kernel where the problem I want to

00:16:08,339 --> 00:16:14,730
point out here is not maybe not really

00:16:12,149 --> 00:16:18,259
well handled and well it could be really

00:16:14,730 --> 00:16:24,899
root filesystem widgets on it right and

00:16:18,259 --> 00:16:29,040
a similar problem it was was also with

00:16:24,899 --> 00:16:31,079
SPI and went to do cache flushing which

00:16:29,040 --> 00:16:33,300
also started as a simple patch and

00:16:31,079 --> 00:16:39,720
turned out into a lengthy discussion how

00:16:33,300 --> 00:16:42,360
to do this properly and that also showed

00:16:39,720 --> 00:16:45,089
that sometimes DMA handling is based on

00:16:42,360 --> 00:16:48,809
assumptions which were most work most of

00:16:45,089 --> 00:16:51,720
the time but not always and it's worth

00:16:48,809 --> 00:16:55,370
but to be aware of it and then to audit

00:16:51,720 --> 00:16:55,370
your systems if you are affected or not

00:17:00,860 --> 00:17:12,810
the author the subtleness of this issue

00:17:04,199 --> 00:17:19,310
can hit people in some unexpected ways

00:17:12,810 --> 00:17:24,510
for example if you if you get a buffer

00:17:19,310 --> 00:17:26,550
inside the struct you're pretty

00:17:24,510 --> 00:17:30,660
have pretty good chances that you don't

00:17:26,550 --> 00:17:32,940
meet your cache line alignments so that

00:17:30,660 --> 00:17:35,190
is what some people go wrong so if you

00:17:32,940 --> 00:17:36,720
get your buffer just the buffer the

00:17:35,190 --> 00:17:38,460
kernel might handle the cache line

00:17:36,720 --> 00:17:39,930
alignments for you if you do this inside

00:17:38,460 --> 00:17:41,280
the struct you get the memory for the

00:17:39,930 --> 00:17:43,710
whole struct and the buffer is somewhere

00:17:41,280 --> 00:17:47,490
in that you might not have the cache

00:17:43,710 --> 00:17:48,780
line alignments the this is just the

00:17:47,490 --> 00:17:50,130
introduction some people get this wrong

00:17:48,780 --> 00:17:54,060
but some people know this

00:17:50,130 --> 00:17:57,810
it gets more supple if you use def MK

00:17:54,060 --> 00:18:00,120
malik instead of k malach because if you

00:17:57,810 --> 00:18:03,420
get just the buffer with came a lock

00:18:00,120 --> 00:18:07,380
things will most likely go right but if

00:18:03,420 --> 00:18:09,780
you used f MK malik you still get this

00:18:07,380 --> 00:18:12,570
buffer you can use but internally it

00:18:09,780 --> 00:18:16,590
gets prepended it gets it is put into a

00:18:12,570 --> 00:18:20,610
struct as well and the cache line

00:18:16,590 --> 00:18:24,270
alignments are mostly broken again so as

00:18:20,610 --> 00:18:27,630
a rule of thumb it's pretty good too if

00:18:24,270 --> 00:18:30,780
you want to use DMA capable buffers to

00:18:27,630 --> 00:18:32,460
not used F MK Mela and I think this is

00:18:30,780 --> 00:18:36,450
largely not know I didn't know that

00:18:32,460 --> 00:18:38,190
before it's very subtle but I think it's

00:18:36,450 --> 00:18:44,940
a rule of thumb which needs to be told

00:18:38,190 --> 00:18:47,520
ought to be fixed or to be fixed yeah

00:18:44,940 --> 00:18:49,620
and then we have other issues like

00:18:47,520 --> 00:18:50,460
people work with buffer from stack which

00:18:49,620 --> 00:18:54,360
is pretty

00:18:50,460 --> 00:18:56,580
I wouldn't say common but it's not like

00:18:54,360 --> 00:19:01,650
a no-go because for example on arm it

00:18:56,580 --> 00:19:03,060
mostly works like a charm but even if it

00:19:01,650 --> 00:19:05,760
works on your architecture it's

00:19:03,060 --> 00:19:07,290
definitely architecture dependent but

00:19:05,760 --> 00:19:09,600
even on architectures which could make

00:19:07,290 --> 00:19:10,550
it work we have this config V map stacks

00:19:09,600 --> 00:19:14,260
of a virtual

00:19:10,550 --> 00:19:14,260
stacked so how that will break for sure

00:19:18,880 --> 00:19:25,850
yes that's what I said so okay on sounds

00:19:22,940 --> 00:19:27,380
view on this it doesn't work it just

00:19:25,850 --> 00:19:28,970
works accidentally but that's what

00:19:27,380 --> 00:19:47,660
people see they just do it and it works

00:19:28,970 --> 00:19:49,820
and so on the drivers okay so you can

00:19:47,660 --> 00:19:52,370
walk okay I like that I like rules of

00:19:49,820 --> 00:19:56,230
thumb don't do that even on arm you

00:19:52,370 --> 00:19:58,580
might get data corruptions on the stack

00:19:56,230 --> 00:20:01,700
yeah and then one other issues is you

00:19:58,580 --> 00:20:03,950
really have to I put it in brackets but

00:20:01,700 --> 00:20:05,600
still rules can be overlooked ignored by

00:20:03,950 --> 00:20:08,000
people just hacking around and I'm not

00:20:05,600 --> 00:20:09,770
reading so if you have roots like this

00:20:08,000 --> 00:20:13,660
you should really make sure they pop up

00:20:09,770 --> 00:20:23,720
everywhere and people are aware of that

00:20:13,660 --> 00:20:25,820
so how are doing not too bad so so my

00:20:23,720 --> 00:20:29,330
conclusions from trying to get my

00:20:25,820 --> 00:20:33,200
subsystem proper with DMA and their

00:20:29,330 --> 00:20:37,760
buffers proper with DMA is I was kind of

00:20:33,200 --> 00:20:40,520
shocked to see how how much DMA

00:20:37,760 --> 00:20:44,510
transfers in the kernel are based on

00:20:40,520 --> 00:20:48,340
assumptions which are true accidentally

00:20:44,510 --> 00:20:52,310
true or whatnot but are not really

00:20:48,340 --> 00:20:53,240
rocket through yeah rocket proof I don't

00:20:52,310 --> 00:20:58,070
know it said an English word

00:20:53,240 --> 00:21:00,350
but you know what I mean I have dealt in

00:20:58,070 --> 00:21:02,960
the last month a bit more so I was in

00:21:00,350 --> 00:21:06,500
this so to Linux workshop which deals a

00:21:02,960 --> 00:21:09,830
lot with safety and with that interest

00:21:06,500 --> 00:21:11,840
reason I think this is this situation is

00:21:09,830 --> 00:21:15,620
not only bad but becomes especially bad

00:21:11,840 --> 00:21:17,570
because if you if I see all the devices

00:21:15,620 --> 00:21:19,940
where Linux should go into I really want

00:21:17,570 --> 00:21:21,240
the DMA to be proper because things go

00:21:19,940 --> 00:21:24,929
wrong horribly is that

00:21:21,240 --> 00:21:27,770
the case I learned there's no easy way

00:21:24,929 --> 00:21:30,480
to detect this is rot at run time yet

00:21:27,770 --> 00:21:32,760
the debug option I mentioned everyone

00:21:30,480 --> 00:21:34,559
should have that when on when developing

00:21:32,760 --> 00:21:39,690
to find bugs it's not good for

00:21:34,559 --> 00:21:41,909
production production use so its current

00:21:39,690 --> 00:21:45,120
state is it's not really detectable at

00:21:41,909 --> 00:21:48,510
run time yet if how what what kind of

00:21:45,120 --> 00:21:50,610
buffer you have so we need to audit and

00:21:48,510 --> 00:21:56,190
be very aware of what what's happening

00:21:50,610 --> 00:22:00,149
there the good solution is a big task as

00:21:56,190 --> 00:22:03,990
I as I said already annotated buffers

00:22:00,149 --> 00:22:08,460
would be awesome which as much handling

00:22:03,990 --> 00:22:11,880
as possible from Corcoran all subs many

00:22:08,460 --> 00:22:15,179
memory subsystems so the users don't

00:22:11,880 --> 00:22:18,510
have much choice to get it wrong at the

00:22:15,179 --> 00:22:20,640
last talk somebody mentioned if the DMA

00:22:18,510 --> 00:22:22,799
buff from video for Linux could be an

00:22:20,640 --> 00:22:25,890
option I didn't check at that time I

00:22:22,799 --> 00:22:28,970
checked it a little bit but I think it's

00:22:25,890 --> 00:22:31,260
too much designed for video for Linux I

00:22:28,970 --> 00:22:33,000
don't think it would be efficient I

00:22:31,260 --> 00:22:35,429
think efficient would be really for that

00:22:33,000 --> 00:22:39,510
targeted solution which then DMA buff

00:22:35,429 --> 00:22:42,870
might convert you to hop onto or so some

00:22:39,510 --> 00:22:44,610
but I don't think the a buff is a good

00:22:42,870 --> 00:22:47,490
solution we need something which is a

00:22:44,610 --> 00:22:55,640
big task of course if you want to do

00:22:47,490 --> 00:22:58,500
that I hope I could demonstrate that the

00:22:55,640 --> 00:23:00,990
problems are can be very subtle and

00:22:58,500 --> 00:23:04,169
think about the came a log versus def MK

00:23:00,990 --> 00:23:09,299
Mela problem for example or the fact

00:23:04,169 --> 00:23:12,720
that when I was talking about the u BFS

00:23:09,299 --> 00:23:16,020
thing accessing the SPI nor memory that

00:23:12,720 --> 00:23:18,870
the UV FS layer can be bringing bringing

00:23:16,020 --> 00:23:22,529
problems where the SPI nor itself might

00:23:18,870 --> 00:23:24,330
be okay so stuff like this and some of

00:23:22,529 --> 00:23:26,279
the box are pretty long-standing as I

00:23:24,330 --> 00:23:29,630
said I don't know if this UV FS problem

00:23:26,279 --> 00:23:29,630
is actually softened by now

00:23:31,720 --> 00:23:37,940
for subsystem maintainer I really can

00:23:34,370 --> 00:23:40,490
recommend just write out rules be it

00:23:37,940 --> 00:23:42,740
whatever they may require your buffers

00:23:40,490 --> 00:23:44,960
to be DMA safe or not whatever but just

00:23:42,740 --> 00:23:46,490
make a rule other as you found out with

00:23:44,960 --> 00:23:50,480
I square C things go in all directions

00:23:46,490 --> 00:23:53,540
and keep an eye on this during reviews

00:23:50,480 --> 00:23:55,910
so I sadly I didn't have so that's a new

00:23:53,540 --> 00:23:58,250
subsystem coming the hi 3c subsystem I

00:23:55,910 --> 00:24:01,640
certainly did not have too much time at

00:23:58,250 --> 00:24:03,290
looking these patches but what I said is

00:24:01,640 --> 00:24:06,800
hey you didn't say anything about your

00:24:03,290 --> 00:24:09,200
diem buffers being DMA please please do

00:24:06,800 --> 00:24:11,840
that and they I think they decided that

00:24:09,200 --> 00:24:13,760
their buffers should be DMA safe but

00:24:11,840 --> 00:24:18,500
this it's written out and also this is a

00:24:13,760 --> 00:24:20,300
good thing for developers I hope I said

00:24:18,500 --> 00:24:22,070
it at least three times by now there's

00:24:20,300 --> 00:24:32,620
config diem a debug when you're

00:24:22,070 --> 00:24:38,510
developing please use it okay thank you

00:24:32,620 --> 00:24:40,820
it's config DMA API debug like I said it

00:24:38,510 --> 00:24:43,910
fixed a problem for me before it turned

00:24:40,820 --> 00:24:45,530
out in the field where the the length of

00:24:43,910 --> 00:24:49,100
the buffer was an or headin off by

00:24:45,530 --> 00:24:51,740
Wambach and if you're touching code

00:24:49,100 --> 00:24:54,490
anyhow for whatever reasons and it uses

00:24:51,740 --> 00:24:57,380
TM hey just take these extra minutes to

00:24:54,490 --> 00:24:58,760
double check that all the DMA related

00:24:57,380 --> 00:25:01,580
things especially when it comes to

00:24:58,760 --> 00:25:09,950
buffers are really proper and not based

00:25:01,580 --> 00:25:13,580
on assumptions and yeah this is room for

00:25:09,950 --> 00:25:15,940
developers and for everyone this is more

00:25:13,580 --> 00:25:18,050
like also if you think about managers or

00:25:15,940 --> 00:25:21,320
organizations like let's say the Linux

00:25:18,050 --> 00:25:25,030
Foundation if you care about safety pay

00:25:21,320 --> 00:25:27,680
attention about to DMA because this is

00:25:25,030 --> 00:25:30,380
we're not in a good in my opinion the

00:25:27,680 --> 00:25:32,060
state of that is given the quality we

00:25:30,380 --> 00:25:33,710
want to have in the Linux kernel we're

00:25:32,060 --> 00:25:37,340
not not good at that

00:25:33,710 --> 00:25:40,060
and to do that we really spread the

00:25:37,340 --> 00:25:43,320
words document what's wrong and

00:25:40,060 --> 00:25:45,570
collaborate on how we can fix things and

00:25:43,320 --> 00:25:48,180
this is a big task it needs a lot of

00:25:45,570 --> 00:25:50,460
eyes and a lot of thought and but we

00:25:48,180 --> 00:25:57,360
want to have I am quite sure we want to

00:25:50,460 --> 00:26:01,920
have it so yeah this is basically what I

00:25:57,360 --> 00:26:06,360
wanted to talk about I hope you're a

00:26:01,920 --> 00:26:10,320
half way as shocked as I am if you if

00:26:06,360 --> 00:26:15,630
you care about good working devices with

00:26:10,320 --> 00:26:17,160
Linux that's good we have like 10

00:26:15,630 --> 00:26:23,760
minutes more for questions

00:26:17,160 --> 00:26:28,320
and do we have a mic for that I shall

00:26:23,760 --> 00:26:31,820
repeat the questions probably right good

00:26:28,320 --> 00:26:31,820
then do we have questions there

00:27:03,740 --> 00:27:14,190
so so you were suggesting to you so

00:27:11,460 --> 00:27:16,860
there are DMA pooling functions and your

00:27:14,190 --> 00:27:20,640
suggestion is to use that kind of ethos

00:27:16,860 --> 00:27:23,220
those functions which which access the

00:27:20,640 --> 00:27:30,210
pool and so we can have a guarantee that

00:27:23,220 --> 00:27:35,090
DMA will correctly work can we have that

00:27:30,210 --> 00:27:35,090
microphone this one

00:27:41,159 --> 00:27:49,950
ah there are actually two DMA api's what

00:27:48,450 --> 00:27:52,529
you are referring to is the streaming

00:27:49,950 --> 00:27:54,509
API where we do explicit cache flushes

00:27:52,529 --> 00:27:58,019
what we have - what you asked about is

00:27:54,509 --> 00:27:59,700
the coherent DMA api with the DMA a lot

00:27:58,019 --> 00:28:02,269
coherent and so on these are not

00:27:59,700 --> 00:28:05,190
compatible if you use dmal or coherent

00:28:02,269 --> 00:28:08,340
you get a buffer that is not acceptable

00:28:05,190 --> 00:28:11,429
to be passed into a driver that expects

00:28:08,340 --> 00:28:16,799
a buffer to be used with the streaming

00:28:11,429 --> 00:28:18,659
API so this is not only not sufficient

00:28:16,799 --> 00:28:22,950
it's actually actually wrong you cannot

00:28:18,659 --> 00:28:27,269
use this and enforce things like I

00:28:22,950 --> 00:28:29,849
square C - accessing as our solutions

00:28:27,269 --> 00:28:32,159
with dealing with pooling even if you

00:28:29,849 --> 00:28:34,019
have a custom one I think we have a

00:28:32,159 --> 00:28:39,499
tendency that this is over engineered

00:28:34,019 --> 00:28:47,070
because DMA is rare so you might I think

00:28:39,499 --> 00:28:50,179
other questions well if you want to

00:28:47,070 --> 00:28:50,179
update you get a microphone

00:28:54,690 --> 00:29:01,570
so why to use DMA and because some

00:28:57,790 --> 00:29:03,790
hardware allows only easy there my DMA

00:29:01,570 --> 00:29:07,480
transfer well this is one of the reasons

00:29:03,790 --> 00:29:09,910
yeah yeah in hardware world everything

00:29:07,480 --> 00:29:12,450
is possible there are indeedy I Square C

00:29:09,910 --> 00:29:17,640
controllers which can only do do ma

00:29:12,450 --> 00:29:17,640
awesome mark you had a question a

00:29:20,820 --> 00:29:24,430
meeting lots of people are great it's

00:29:23,740 --> 00:29:28,590
good for your health

00:29:24,430 --> 00:29:32,920
yeah so just on the spine or stuff it's

00:29:28,590 --> 00:29:34,810
supposed to be fixed I don't claim to

00:29:32,920 --> 00:29:37,060
understand it sufficiently solidly that

00:29:34,810 --> 00:29:41,080
I'm 100% certain but I supposed to be

00:29:37,060 --> 00:29:43,240
fixed the issue is that you can allocate

00:29:41,080 --> 00:29:45,550
memory with V malloc as well as other

00:29:43,240 --> 00:29:47,740
memory allocation functions and if

00:29:45,550 --> 00:29:50,890
memory is allocated with V malloc you

00:29:47,740 --> 00:29:53,410
need to map it differently because this

00:29:50,890 --> 00:29:55,090
is helpful and useful but fortunately

00:29:53,410 --> 00:29:56,920
you can actually there's a function you

00:29:55,090 --> 00:30:01,060
can call to check if a given buffer is V

00:29:56,920 --> 00:30:10,870
my liked which makes that tractable but

00:30:01,060 --> 00:30:13,120
yeah it's a pain yeah one more thing

00:30:10,870 --> 00:30:16,360
that you one more trap that you can fall

00:30:13,120 --> 00:30:18,100
into so a buffer can be DMA safe for one

00:30:16,360 --> 00:30:20,260
device but not for another device

00:30:18,100 --> 00:30:22,090
because of the location in physical

00:30:20,260 --> 00:30:25,120
memory some devices have a limited view

00:30:22,090 --> 00:30:27,340
of the physical address space so you can

00:30:25,120 --> 00:30:30,220
have a buffer that requires to be in the

00:30:27,340 --> 00:30:32,230
lower address like within the first four

00:30:30,220 --> 00:30:36,160
gigabytes while another device can

00:30:32,230 --> 00:30:38,950
access data beyond that or within the

00:30:36,160 --> 00:30:40,440
first 24 mega by 16 megabytes or

00:30:38,950 --> 00:30:44,290
something like that

00:30:40,440 --> 00:30:47,560
so came ela : so there's no generic way

00:30:44,290 --> 00:30:50,290
to check whether device with a piece of

00:30:47,560 --> 00:30:53,140
well but the pointer points is something

00:30:50,290 --> 00:30:57,540
that is accessible using DMA unless you

00:30:53,140 --> 00:31:01,060
also say which device should access it

00:30:57,540 --> 00:31:02,440
but I might become confused because I'm

00:31:01,060 --> 00:31:04,060
on stage but that would mean we don't

00:31:02,440 --> 00:31:06,460
have a way in the kernel to get a buffer

00:31:04,060 --> 00:31:09,279
which is surely do you may say

00:31:06,460 --> 00:31:11,169
we have a way to do that but you have to

00:31:09,279 --> 00:31:13,539
pass a pointer to the device structure

00:31:11,169 --> 00:31:16,710
for this and we've talked about every

00:31:13,539 --> 00:31:18,940
device we can get getting buffer that is

00:31:16,710 --> 00:31:26,230
accessible by that device if it can do

00:31:18,940 --> 00:31:30,460
DMA which function is that it come

00:31:26,230 --> 00:31:32,799
together so that would go back to the

00:31:30,460 --> 00:31:34,720
DMA a lot if you do if you use the dmal

00:31:32,799 --> 00:31:37,210
a log functions then you can get a

00:31:34,720 --> 00:31:39,850
buffer that is accessible by that device

00:31:37,210 --> 00:31:41,409
it is also slow to access from Colonel

00:31:39,850 --> 00:31:44,820
if you don't have cache coherent memory

00:31:41,409 --> 00:31:44,820
yeah yeah Kashmir ABMA

00:31:44,909 --> 00:32:00,909
well yeah just to say that I walked on

00:31:58,119 --> 00:32:04,240
couple of spy devices where I try to use

00:32:00,909 --> 00:32:07,570
make them DMS safe because you be

00:32:04,240 --> 00:32:11,200
aggressive you be ifs was passing we

00:32:07,570 --> 00:32:13,809
lack buffers so it turns out that that

00:32:11,200 --> 00:32:18,330
doesn't work well with VI VD caches

00:32:13,809 --> 00:32:22,779
which are there on older platforms and

00:32:18,330 --> 00:32:26,590
also on platforms that have

00:32:22,779 --> 00:32:28,779
LPA enabled where DMA can access only

00:32:26,590 --> 00:32:30,730
within 32 bits but with LP a you can

00:32:28,779 --> 00:32:34,659
access physical memory connect higher

00:32:30,730 --> 00:32:37,179
address and yeah those type of buffers

00:32:34,659 --> 00:32:39,850
still failed with whatever checks that

00:32:37,179 --> 00:32:43,240
are there right I don't see anywhere

00:32:39,850 --> 00:32:47,769
other than maybe if DMA map single was

00:32:43,240 --> 00:32:51,909
to somehow provide a bones buffer find

00:32:47,769 --> 00:32:55,960
out whether this is here yeah it does so

00:32:51,909 --> 00:32:59,289
Jim a map single should if the memory is

00:32:55,960 --> 00:33:01,539
team a capable it will map it possibly

00:32:59,289 --> 00:33:03,639
using an album you if there's no memory

00:33:01,539 --> 00:33:05,409
I remember you and the device it's not

00:33:03,639 --> 00:33:07,210
DMA capable and it should allocate a

00:33:05,409 --> 00:33:09,929
bounce buffer this is currently not

00:33:07,210 --> 00:33:14,440
fully implemented on answer to because

00:33:09,929 --> 00:33:15,410
nobody has done it doctor it's not hard

00:33:14,440 --> 00:33:17,720
to do I've

00:33:15,410 --> 00:33:19,580
to a number of people that volunteered

00:33:17,720 --> 00:33:21,710
at some point to do it but nobody has

00:33:19,580 --> 00:33:25,010
ever completed I don't think it's more

00:33:21,710 --> 00:33:27,530
than a couple of days work actually but

00:33:25,010 --> 00:33:31,670
until that is done you cannot pass a

00:33:27,530 --> 00:33:33,440
hymen buff of like a buffer beyond the

00:33:31,670 --> 00:33:38,600
first four gigabyte on the 32-bit arm

00:33:33,440 --> 00:33:42,080
system so this is therefore I'm 64 sa

00:33:38,600 --> 00:33:44,870
not 432 that's what is it

00:33:42,080 --> 00:33:47,660
I mean TMI map single providing the

00:33:44,870 --> 00:33:49,190
bones buffers stay for I'm 64 but not

00:33:47,660 --> 00:33:51,920
for home that you don't start watching

00:33:49,190 --> 00:33:53,810
that would be correct yes almost

00:33:51,920 --> 00:33:56,210
architectures it just works because the

00:33:53,810 --> 00:33:59,030
architectures either use the software

00:33:56,210 --> 00:34:03,200
TLB or they are guaranteed to have an

00:33:59,030 --> 00:34:04,280
iommu and I'm 32 we do not guarantee we

00:34:03,200 --> 00:34:06,560
do not guarantee this at the moment

00:34:04,280 --> 00:34:08,210
because most people don't have that much

00:34:06,560 --> 00:34:10,910
memory and it's very rare to actually

00:34:08,210 --> 00:34:13,550
run into this I'm so happy that you guys

00:34:10,910 --> 00:34:15,320
all basically confirmed my basic feeling

00:34:13,550 --> 00:34:17,840
which is like on most active

00:34:15,320 --> 00:34:20,120
architectures it should work like I

00:34:17,840 --> 00:34:26,240
think this pretty much describes the

00:34:20,120 --> 00:34:28,820
situation we're in yeah but maybe a good

00:34:26,240 --> 00:34:32,660
good no one stole it so a few minutes

00:34:28,820 --> 00:34:35,330
but it's it's nice to see in the I

00:34:32,660 --> 00:34:37,190
square subsystem that bus master drivers

00:34:35,330 --> 00:34:39,860
are catching up that they sit really say

00:34:37,190 --> 00:34:42,470
oh we had this oops because the message

00:34:39,860 --> 00:34:47,150
buffer came from I think it came

00:34:42,470 --> 00:34:50,360
directly from module read-only data

00:34:47,150 --> 00:34:52,130
because it was a firmware and then they

00:34:50,360 --> 00:34:54,410
are yeah guys cool you have this flag

00:34:52,130 --> 00:35:00,560
and then they could correct things to

00:34:54,410 --> 00:35:03,040
work so a bit of success yay more

00:35:00,560 --> 00:35:03,040
questions

00:35:07,430 --> 00:35:12,650
one two three four salt

00:35:12,720 --> 00:35:19,750

YouTube URL: https://www.youtube.com/watch?v=JDwaMClvV-s


