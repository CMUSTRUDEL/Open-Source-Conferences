Title: Uh-oh, It's I O Ordering! - Will Deacon, Arm
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	Uh-oh, It's I/O Ordering! - Will Deacon, Arm

The Linux kernel provides a rich collection of memory barriers which can be used to enforce ordering of memory accesses between multiple agents. In the case where these agents are all CPUs, we have recently adopted a formal model which allows developers to reason about concurrent interactions between them. However, when I/O and DMA-capable devices are added to the mix, the semantics once again being blurred and recent discussions on the mailing lists show a common lack of understanding of the intended barrier semantics.

This presentation will give a brief tour of the I/O ordering barriers support in mainline Linux: which barriers to use in your driver, when you need to use them and how to achieve the best performance.

About Will Deacon
Will is a Linux kernel hacker at Arm Ltd. with an unhealthy interest in concurrency and computer architecture. He is an active upstream contributor and co-maintains various parts of the kernel including the arm64 architecture port and the memory consistency model.
Captions: 
	00:00:00,000 --> 00:00:04,560
I think we're about ready to get started

00:00:01,350 --> 00:00:06,930
so it's nearly four o'clock and we're

00:00:04,560 --> 00:00:08,400
stuck in the dungeon so we're gonna talk

00:00:06,930 --> 00:00:11,759
about memory ordering I might fall

00:00:08,400 --> 00:00:13,049
asleep in my own talk if I do come and

00:00:11,759 --> 00:00:18,210
kick me or something and we'll see if we

00:00:13,049 --> 00:00:19,770
can gets the end of it who I apparently

00:00:18,210 --> 00:00:22,380
when I present I do this so if I start

00:00:19,770 --> 00:00:25,590
doing this hopefully I'm not asleep

00:00:22,380 --> 00:00:27,269
come maintain a bunch of stuff and the

00:00:25,590 --> 00:00:29,130
arm 64 architecture with Catalan and

00:00:27,269 --> 00:00:33,420
then some other bits and pieces

00:00:29,130 --> 00:00:35,550
including the Atomics in Linux the

00:00:33,420 --> 00:00:37,290
locking interfaces the memory model and

00:00:35,550 --> 00:00:40,590
recently TLB invalidation as well so

00:00:37,290 --> 00:00:43,170
it's kind of grotty concurrent stuff and

00:00:40,590 --> 00:00:44,940
I work I do all that in the open-source

00:00:43,170 --> 00:00:46,320
software group but um or I have a close

00:00:44,940 --> 00:00:48,660
working relationship with the

00:00:46,320 --> 00:00:50,219
architecture and technology group who

00:00:48,660 --> 00:00:51,750
produce all the sort of whiz-bang

00:00:50,219 --> 00:00:54,449
features they get implemented in CPUs

00:00:51,750 --> 00:00:57,600
and as part of the relationship I've got

00:00:54,449 --> 00:00:59,219
with them I helped put together the UM

00:00:57,600 --> 00:01:01,980
v8 memory model for the ARM architecture

00:00:59,219 --> 00:01:04,140
and formalism of that as well and if

00:01:01,980 --> 00:01:05,880
that wasn't enough I also do C++ memory

00:01:04,140 --> 00:01:08,909
model well that's a big committee thing

00:01:05,880 --> 00:01:10,979
I have a minor role there but um I'm

00:01:08,909 --> 00:01:13,049
involved and last time I spoke at ELC

00:01:10,979 --> 00:01:14,820
which was here five years ago for me I

00:01:13,049 --> 00:01:17,159
also spoke about memory ordering so I'm

00:01:14,820 --> 00:01:17,850
a little bit of a stuck record perhaps a

00:01:17,159 --> 00:01:20,130
one-trick pony

00:01:17,850 --> 00:01:22,229
but I've modified it a bit to talk about

00:01:20,130 --> 00:01:24,030
by ordering this time which is gonna be

00:01:22,229 --> 00:01:29,610
about things like DMA and stuff like

00:01:24,030 --> 00:01:32,850
that so to set the scene a little bit

00:01:29,610 --> 00:01:35,610
what's my idea of paradise so this place

00:01:32,850 --> 00:01:37,350
looked pretty good a tropical desert

00:01:35,610 --> 00:01:38,909
island but there's one thing you can do

00:01:37,350 --> 00:01:41,130
to improve this tropical desert island

00:01:38,909 --> 00:01:44,790
immensely as to make it a uniprocessor

00:01:41,130 --> 00:01:46,290
tropical desert island and that's that's

00:01:44,790 --> 00:01:46,619
also an alpha so it's kind of even

00:01:46,290 --> 00:01:49,920
better

00:01:46,619 --> 00:01:51,450
don't tell my employer but that's the

00:01:49,920 --> 00:01:52,979
baddest gives my photoshop skills get

00:01:51,450 --> 00:01:55,409
you know this the shadows not quite the

00:01:52,979 --> 00:01:57,329
right angle but it's great you know I'll

00:01:55,409 --> 00:01:59,100
take it and the reason I like this so

00:01:57,329 --> 00:02:01,560
much is because you the complexity and

00:01:59,100 --> 00:02:04,259
the burden that I spend all of my

00:02:01,560 --> 00:02:05,909
working hours worrying about just goes

00:02:04,259 --> 00:02:10,920
away so you know there's no peripherals

00:02:05,909 --> 00:02:13,050
either right the grim reality is that we

00:02:10,920 --> 00:02:13,440
cram thousands of these poor CPUs with

00:02:13,050 --> 00:02:16,260
no net

00:02:13,440 --> 00:02:18,210
like all our network these air

00:02:16,260 --> 00:02:20,430
conditioned warehouses right that the

00:02:18,210 --> 00:02:22,080
island dream is gone it does not exist I

00:02:20,430 --> 00:02:24,090
really wish it did but this is what

00:02:22,080 --> 00:02:25,710
we're dealing with loads of us like

00:02:24,090 --> 00:02:27,510
loads of instances of Linux and within

00:02:25,710 --> 00:02:29,940
each instance of Linux you've got

00:02:27,510 --> 00:02:31,560
coherency and SMP all over the place so

00:02:29,940 --> 00:02:36,750
we have to deal with concurrency we

00:02:31,560 --> 00:02:38,460
can't have what we wanted so even with a

00:02:36,750 --> 00:02:40,110
single coherent shared memory which is

00:02:38,460 --> 00:02:42,300
basically what you expect when you're

00:02:40,110 --> 00:02:45,270
writing concurrent code for CPUs GPU

00:02:42,300 --> 00:02:47,160
people have a bit more out they have to

00:02:45,270 --> 00:02:48,540
deal with but we've got a single current

00:02:47,160 --> 00:02:50,400
shared memory you have one copy of a

00:02:48,540 --> 00:02:53,040
variable and you're modifying it mutable

00:02:50,400 --> 00:02:57,270
States even in that case concurrency is

00:02:53,040 --> 00:02:59,370
really difficult reasons that it

00:02:57,270 --> 00:03:00,600
difficult you can't you can't write your

00:02:59,370 --> 00:03:03,870
program and then reason about it

00:03:00,600 --> 00:03:05,370
executing in steps because you can have

00:03:03,870 --> 00:03:07,020
outcomes I'll show you later you can

00:03:05,370 --> 00:03:08,450
have outcomes which don't correspond to

00:03:07,020 --> 00:03:10,560
a stepwise execution of the program

00:03:08,450 --> 00:03:13,320
because your memory accesses can be

00:03:10,560 --> 00:03:15,450
reordered for example and when your

00:03:13,320 --> 00:03:18,060
program goes wrong which is probably

00:03:15,450 --> 00:03:20,430
rare but enough that you get told off or

00:03:18,060 --> 00:03:22,370
you crash something you put some

00:03:20,430 --> 00:03:24,270
instrumentation in and it starts working

00:03:22,370 --> 00:03:27,239
which is the worst kind of bug

00:03:24,270 --> 00:03:28,590
Heisenberg so you had you strive for

00:03:27,239 --> 00:03:29,730
this balance between performance and

00:03:28,590 --> 00:03:30,930
correctness because you could put a

00:03:29,730 --> 00:03:33,120
whopping great big lock around your

00:03:30,930 --> 00:03:36,060
program and it'll work but it's probably

00:03:33,120 --> 00:03:38,220
not fast enough and when you go to look

00:03:36,060 --> 00:03:39,680
at tools to reason about or to validate

00:03:38,220 --> 00:03:42,030
your code you know there's not really a

00:03:39,680 --> 00:03:43,290
concurrent gdb in the sense that you can

00:03:42,030 --> 00:03:45,300
just connect a debugger and it says all

00:03:43,290 --> 00:03:47,340
your race is here there are things

00:03:45,300 --> 00:03:48,989
coming along but it's not the same

00:03:47,340 --> 00:03:50,519
interactive instant response kind of

00:03:48,989 --> 00:03:53,670
stuff that you're used to with a single

00:03:50,519 --> 00:03:55,680
processor so the CP is basically not

00:03:53,670 --> 00:03:57,239
doing what you asked it to do can it get

00:03:55,680 --> 00:03:58,230
worse than this well of course it can I

00:03:57,239 --> 00:03:59,880
thought you would never talk here it

00:03:58,230 --> 00:04:00,959
gets much worse than this but well we'll

00:03:59,880 --> 00:04:05,550
go through this bit first otherwise

00:04:00,959 --> 00:04:07,410
we're all going to just give up and I

00:04:05,550 --> 00:04:08,760
forgot when I did this talk that I can't

00:04:07,410 --> 00:04:10,019
just go straight to I ordering we're

00:04:08,760 --> 00:04:11,400
gonna have to do memory ordering first

00:04:10,019 --> 00:04:13,080
and so I've had to cram it in five

00:04:11,400 --> 00:04:14,700
minutes but let's see how we do at the

00:04:13,080 --> 00:04:15,810
end of the talk as examples and if we

00:04:14,700 --> 00:04:18,000
don't get through all of those is fine

00:04:15,810 --> 00:04:22,430
if you get stuck here please stop me and

00:04:18,000 --> 00:04:24,539
not do my best so here's an example

00:04:22,430 --> 00:04:25,750
called store buffering you'll see why

00:04:24,539 --> 00:04:28,960
it's called been a minute

00:04:25,750 --> 00:04:32,950
so there's two CPUs and this is sort of

00:04:28,960 --> 00:04:35,770
kernel code issue got two shared

00:04:32,950 --> 00:04:38,200
variables x and y they're both 0 in

00:04:35,770 --> 00:04:42,100
memory initially and then we've got two

00:04:38,200 --> 00:04:44,950
local register variables foo and bar so

00:04:42,100 --> 00:04:47,530
each CPU our CP 0 writes 1 to X and then

00:04:44,950 --> 00:04:50,230
it reads Y into foo and CB 1 does the

00:04:47,530 --> 00:04:51,970
opposite it writes 1 to Y and then reads

00:04:50,230 --> 00:04:54,070
X into bar and the million-dollar

00:04:51,970 --> 00:04:55,960
question is what are the permissible

00:04:54,070 --> 00:04:57,160
values for foo and bar cuz you could run

00:04:55,960 --> 00:04:59,410
this program many times right in

00:04:57,160 --> 00:05:01,240
depending on which CPU may goes a bit

00:04:59,410 --> 00:05:02,800
quicker than the other or the order in

00:05:01,240 --> 00:05:05,260
which things propagate you know you may

00:05:02,800 --> 00:05:07,000
get different outcomes so does anyone

00:05:05,260 --> 00:05:10,570
want to have a guess at a permissible

00:05:07,000 --> 00:05:12,100
outcome all of them correct yes

00:05:10,570 --> 00:05:13,000
congratulations so that's that's well

00:05:12,100 --> 00:05:15,480
it's a good question right because

00:05:13,000 --> 00:05:17,860
whatever you said like I said yes and

00:05:15,480 --> 00:05:19,540
all all production architectures will

00:05:17,860 --> 00:05:21,550
permit that the perhaps counterintuitive

00:05:19,540 --> 00:05:25,630
result here which is that foo and bar

00:05:21,550 --> 00:05:27,390
can be 0 and I can show you that if you

00:05:25,630 --> 00:05:30,540
want we've got a little bit of time

00:05:27,390 --> 00:05:30,540
ignore this

00:05:30,960 --> 00:05:39,010
this is cryptic gobbledygook from

00:05:33,460 --> 00:05:40,690
economics so there's the test in x86

00:05:39,010 --> 00:05:43,330
assembly you can see there's only four

00:05:40,690 --> 00:05:45,970
instructions and I can just this is a

00:05:43,330 --> 00:05:51,570
memory model toolkit I can actually run

00:05:45,970 --> 00:05:51,570
that on my laptop a million times

00:05:52,650 --> 00:05:59,020
ok and for some reason it let's go back

00:05:56,080 --> 00:06:00,850
to them for some reason it prints out

00:05:59,020 --> 00:06:02,830
CPU info at the end so I just do some

00:06:00,850 --> 00:06:07,800
scroll up past all of that it's always

00:06:02,830 --> 00:06:10,990
the same way hey ok so now you can see

00:06:07,800 --> 00:06:12,790
what we saw so we ran it 10 million

00:06:10,990 --> 00:06:14,320
times and there are the four outcomes

00:06:12,790 --> 00:06:16,890
and we did actually see all four on my

00:06:14,320 --> 00:06:19,300
laptop just then well I was running and

00:06:16,890 --> 00:06:21,850
so yes you were correct and my laptop

00:06:19,300 --> 00:06:26,470
agrees with you let's try and get back

00:06:21,850 --> 00:06:30,240
to the slides there we are good so now

00:06:26,470 --> 00:06:32,590
you believe me I'm not making it up how

00:06:30,240 --> 00:06:34,930
anyone got idea how the clues in the

00:06:32,590 --> 00:06:38,590
name of the test

00:06:34,930 --> 00:06:40,270
well done so it's still buffering and

00:06:38,590 --> 00:06:41,650
the thing is that you these right ones

00:06:40,270 --> 00:06:43,090
who is basically sit in the local store

00:06:41,650 --> 00:06:44,949
buffers and the local store buffers are

00:06:43,090 --> 00:06:46,930
not snooped by other CPUs so when the

00:06:44,949 --> 00:06:48,820
other CPUs do their with when the CPUs

00:06:46,930 --> 00:06:50,320
do their corresponding read that

00:06:48,820 --> 00:06:52,750
variable is not yet been updated in

00:06:50,320 --> 00:06:54,820
terms of it's not emit made visible to

00:06:52,750 --> 00:06:57,009
other people and that looks a bit like

00:06:54,820 --> 00:07:01,180
the read and the write get reordered on

00:06:57,009 --> 00:07:03,850
each core and the reason this is

00:07:01,180 --> 00:07:07,840
counterintuitive to some people is

00:07:03,850 --> 00:07:09,340
because there's this memory model called

00:07:07,840 --> 00:07:13,180
sequential consistency which says that

00:07:09,340 --> 00:07:15,280
your program has to run stepwise so that

00:07:13,180 --> 00:07:16,690
the concurrent execution of the program

00:07:15,280 --> 00:07:19,180
looks like an interleaving of the

00:07:16,690 --> 00:07:21,639
threads so I've labeled the four

00:07:19,180 --> 00:07:22,660
statements here a B C and D and what

00:07:21,639 --> 00:07:24,550
you're allowed to do basically is come

00:07:22,660 --> 00:07:25,840
up with interleavings as long as the

00:07:24,550 --> 00:07:27,639
order they are in the program is

00:07:25,840 --> 00:07:30,520
preserved so a always has to be before B

00:07:27,639 --> 00:07:32,639
and C always has to be before D and

00:07:30,520 --> 00:07:34,570
there's some example interleavings and

00:07:32,639 --> 00:07:36,190
that's easy to reason about

00:07:34,570 --> 00:07:38,620
quote-unquote there's lots of you know

00:07:36,190 --> 00:07:41,020
concurrency modeling tool kits which are

00:07:38,620 --> 00:07:43,449
built upon SC and the big problem with

00:07:41,020 --> 00:07:45,639
SC which is such a consistency is it

00:07:43,449 --> 00:07:47,410
forbids the zero outcome in the previous

00:07:45,639 --> 00:07:49,479
example so it gives you this concurrent

00:07:47,410 --> 00:07:50,949
toolkit and a memory model that's quote

00:07:49,479 --> 00:07:52,090
unquote easy to reason about but it's

00:07:50,949 --> 00:07:53,680
just it's not applicable to the real

00:07:52,090 --> 00:07:55,030
world because nobody builds SC machines

00:07:53,680 --> 00:07:56,260
or at least there are no SC

00:07:55,030 --> 00:07:59,970
architectures out there and you saw that

00:07:56,260 --> 00:08:03,729
on my laptop so that's a problem so

00:07:59,970 --> 00:08:05,199
people have some people have realized

00:08:03,729 --> 00:08:06,849
this is an issue and they've come up

00:08:05,199 --> 00:08:09,039
with ways to reason about weak memory

00:08:06,849 --> 00:08:10,630
behavior so that's non SC behaviors I

00:08:09,039 --> 00:08:13,240
Eve as ero zero case that we've been

00:08:10,630 --> 00:08:14,710
talking about and one way you can talk

00:08:13,240 --> 00:08:16,300
about those is with these very cryptic

00:08:14,710 --> 00:08:18,039
things called litmus tests which also

00:08:16,300 --> 00:08:19,419
have cryptic names so I'm gonna explain

00:08:18,039 --> 00:08:21,690
to you the structure of the litmus test

00:08:19,419 --> 00:08:25,210
and so you get an idea for what they are

00:08:21,690 --> 00:08:27,070
so this one is called MP MP plus Popple

00:08:25,210 --> 00:08:29,220
+ po ignore that bit we just call it MP

00:08:27,070 --> 00:08:33,039
that stands for message passing okay

00:08:29,220 --> 00:08:36,400
ignore this next line it's an AR 64

00:08:33,039 --> 00:08:39,250
assembly and this part here between the

00:08:36,400 --> 00:08:42,250
curly braces is setting up our shared

00:08:39,250 --> 00:08:43,360
memory so everything is 0 at the start

00:08:42,250 --> 00:08:45,550
of time that's just an implicit

00:08:43,360 --> 00:08:48,010
assumption of a litmus test and we have

00:08:45,550 --> 00:08:48,790
two variables x and y so it says on cpu

00:08:48,010 --> 00:08:53,050
00:08:48,790 --> 00:08:54,370
zero is zero : register x 1.is x what i

00:08:53,050 --> 00:08:56,500
actually means is it's a pointer to X

00:08:54,370 --> 00:08:57,760
but the cement the syntax here doesn't

00:08:56,500 --> 00:08:59,410
have the ampersand if it there's a

00:08:57,760 --> 00:09:02,200
pointer to X in register X 1 and there's

00:08:59,410 --> 00:09:05,740
a pointer to Y and register X 3 and over

00:09:02,200 --> 00:09:09,670
here it's a CP 1 X 1 has appointed to Y

00:09:05,740 --> 00:09:11,170
and X 3 has appointed to X so that's

00:09:09,670 --> 00:09:12,580
we've got our registers they've got

00:09:11,170 --> 00:09:15,100
pointers to America's shared variables

00:09:12,580 --> 00:09:16,960
and then you have the test here which is

00:09:15,100 --> 00:09:19,630
the footer of the program here and the

00:09:16,960 --> 00:09:21,610
program here you've got p 0 processes 0

00:09:19,630 --> 00:09:22,720
p 1 processor 1 they execute

00:09:21,610 --> 00:09:24,910
concurrently they execute at the same

00:09:22,720 --> 00:09:27,520
time and they run these instructions so

00:09:24,910 --> 00:09:29,830
this guy moves one into this register W

00:09:27,520 --> 00:09:32,410
0 and then stores it to X 1 which has a

00:09:29,830 --> 00:09:35,170
pointer to X so actually if you draw

00:09:32,410 --> 00:09:38,170
this it looks a bit like this so we do

00:09:35,170 --> 00:09:40,600
Fred 0 which is p 0 here does write x

00:09:38,170 --> 00:09:43,020
equals 1 write Y release because this is

00:09:40,600 --> 00:09:46,780
a special kind of order inducing store

00:09:43,020 --> 00:09:49,840
to be 1 and this guy over here reads Y

00:09:46,780 --> 00:09:51,880
and reads X here and the constraint at

00:09:49,840 --> 00:09:54,250
the bottom constrains the values that

00:09:51,880 --> 00:09:56,080
these registers can hold so X 0 and it's

00:09:54,250 --> 00:09:57,790
the same as W 0 for the purpose of this

00:09:56,080 --> 00:10:00,160
example it's just the 64 bit view of

00:09:57,790 --> 00:10:03,490
that register and with that knowledge

00:10:00,160 --> 00:10:05,320
but that exists clause you can create

00:10:03,490 --> 00:10:06,430
this reads from arrow and this thing

00:10:05,320 --> 00:10:08,920
called a from read error which I don't

00:10:06,430 --> 00:10:11,200
have time to go into but what you've got

00:10:08,920 --> 00:10:13,420
is you you write X you write Y this guy

00:10:11,200 --> 00:10:15,130
reads why is it allowed to read x equals

00:10:13,420 --> 00:10:17,410
0 so if you think of this as data and

00:10:15,130 --> 00:10:19,090
flag you know you write the data you set

00:10:17,410 --> 00:10:20,560
the flag this guy sees the updated flag

00:10:19,090 --> 00:10:22,300
does it see the old data that's kind of

00:10:20,560 --> 00:10:24,610
a weak memory question which you could

00:10:22,300 --> 00:10:26,080
ask and you can run that through at all

00:10:24,610 --> 00:10:27,850
and it will tell you the answer the

00:10:26,080 --> 00:10:29,620
thing to remember there's the basically

00:10:27,850 --> 00:10:32,650
the takeaway that I want you to have is

00:10:29,620 --> 00:10:34,630
that you've got a cycle here and cycles

00:10:32,650 --> 00:10:36,670
are bad and whether or not you need to

00:10:34,630 --> 00:10:38,200
worry about a cycle is determined by the

00:10:36,670 --> 00:10:43,930
memory model and that's kind of memory

00:10:38,200 --> 00:10:48,820
models in five minutes and that's the

00:10:43,930 --> 00:10:50,170
easy case don't worry I don't think I've

00:10:48,820 --> 00:10:53,050
got any more litmus test so I haven't

00:10:50,170 --> 00:10:54,640
checked are doing K so we can take this

00:10:53,050 --> 00:10:57,430
beyond shared memory communication so

00:10:54,640 --> 00:10:59,320
we're already most of the research out

00:10:57,430 --> 00:11:00,700
there for concurrency is dealing with

00:10:59,320 --> 00:11:02,060
sequential consistency there's a whole

00:11:00,700 --> 00:11:03,980
bunch of people doing week

00:11:02,060 --> 00:11:06,760
memory consistency and I don't really

00:11:03,980 --> 00:11:08,690
know of anything going on in this area

00:11:06,760 --> 00:11:13,850
which is unfortunately needed for

00:11:08,690 --> 00:11:16,040
operating system not all communication

00:11:13,850 --> 00:11:18,460
between observers thread CPUs is via

00:11:16,040 --> 00:11:21,740
explicit my accesses to share memory so

00:11:18,460 --> 00:11:23,600
imagine this case here which is a slight

00:11:21,740 --> 00:11:25,490
change of the previous one if we write x

00:11:23,600 --> 00:11:28,270
equals one and then instead of writing

00:11:25,490 --> 00:11:30,680
to Y we write to an interrupt controller

00:11:28,270 --> 00:11:33,320
which triggers an interrupt on thread 1

00:11:30,680 --> 00:11:35,750
and then it reads the old X okay now

00:11:33,320 --> 00:11:37,400
there's no cycle here so memory model

00:11:35,750 --> 00:11:40,810
like classical memory model logic says

00:11:37,400 --> 00:11:44,720
well that's fine Linux may not like this

00:11:40,810 --> 00:11:46,040
probably be quite bad so we need a way

00:11:44,720 --> 00:11:49,190
of talking about these kind of tests

00:11:46,040 --> 00:11:50,960
which doesn't really exist and it's not

00:11:49,190 --> 00:11:51,950
just interrupts there's a whole bunch of

00:11:50,960 --> 00:11:53,570
other ways you can do it so it could be

00:11:51,950 --> 00:11:55,190
DMA from a peripheral it could be

00:11:53,570 --> 00:11:56,780
objects to a page table you can either

00:11:55,190 --> 00:11:58,910
have weird things like regulators where

00:11:56,780 --> 00:12:00,260
you power on a regulator and then try to

00:11:58,910 --> 00:12:01,280
access the thing that's been powered on

00:12:00,260 --> 00:12:03,800
you will need to make sure that that's

00:12:01,280 --> 00:12:05,510
happens in the right order and most

00:12:03,800 --> 00:12:07,670
people go where it's all out of scope no

00:12:05,510 --> 00:12:10,040
one does this but of course yeah Linux

00:12:07,670 --> 00:12:12,560
does this all the time it's because it's

00:12:10,040 --> 00:12:13,880
difficult and it's already hard enough I

00:12:12,560 --> 00:12:19,490
think people don't want to go that extra

00:12:13,880 --> 00:12:23,990
mile so what I want you to think about

00:12:19,490 --> 00:12:26,240
is we can generalize the idea of shared

00:12:23,990 --> 00:12:28,250
coherent memory just a little bit so we

00:12:26,240 --> 00:12:29,900
can generalize this so the inter inter

00:12:28,250 --> 00:12:32,930
process communication we consider it as

00:12:29,900 --> 00:12:34,700
accesses to endpoints so an access is

00:12:32,930 --> 00:12:35,840
and I'm saying this is this is something

00:12:34,700 --> 00:12:36,710
I've come up with for this talk you know

00:12:35,840 --> 00:12:39,290
there other ways you can look at this

00:12:36,710 --> 00:12:41,180
it's just how I think about it so an

00:12:39,290 --> 00:12:43,750
access is an event targeting a specific

00:12:41,180 --> 00:12:45,950
endpoint which causes it to change state

00:12:43,750 --> 00:12:49,000
so that could be you know in a memory

00:12:45,950 --> 00:12:49,000
case there could be a write to memory

00:12:49,060 --> 00:12:52,520
now says it may cause it to change state

00:12:51,290 --> 00:12:55,010
because a read probably doesn't for

00:12:52,520 --> 00:12:56,660
memory and an endpoint is a piece of

00:12:55,010 --> 00:12:58,490
hardware with a mutable state which can

00:12:56,660 --> 00:13:00,530
respond to accesses and then maybe it

00:12:58,490 --> 00:13:02,690
can also generate other accesses like

00:13:00,530 --> 00:13:05,210
accessing a DNA engine which then

00:13:02,690 --> 00:13:09,890
accesses memory here are some modern

00:13:05,210 --> 00:13:11,300
endpoints so for us for it for Linux it

00:13:09,890 --> 00:13:13,070
we don't quite need this generalization

00:13:11,300 --> 00:13:15,010
as far as I'm explaining here we really

00:13:13,070 --> 00:13:17,110
just need to care about memory or mm IO

00:13:15,010 --> 00:13:18,400
when I say lmao its si Oh mm pointers

00:13:17,110 --> 00:13:20,590
it's stuff that you get back from IO

00:13:18,400 --> 00:13:24,130
remap is what we're considering since

00:13:20,590 --> 00:13:25,750
that and it's memory and we'll just

00:13:24,130 --> 00:13:27,940
consider all accesses to be load store

00:13:25,750 --> 00:13:29,620
operations via the appropriate accesses

00:13:27,940 --> 00:13:30,670
in Linux so it's things like read L and

00:13:29,620 --> 00:13:33,040
write L which I'm going to talk more

00:13:30,670 --> 00:13:34,900
about there are also peripherals that

00:13:33,040 --> 00:13:36,970
have perhaps funny system register

00:13:34,900 --> 00:13:37,990
interfaces but not gonna go into that

00:13:36,970 --> 00:13:39,370
either so we're kind of limiting the

00:13:37,990 --> 00:13:44,290
scope a bit for this talk but the same

00:13:39,370 --> 00:13:47,530
kind of idea applies and then once

00:13:44,290 --> 00:13:48,580
you've got sort of that in your head we

00:13:47,530 --> 00:13:50,200
need to distinguish one other thing

00:13:48,580 --> 00:13:52,290
which is ordering versus completion so

00:13:50,200 --> 00:13:54,580
the way I like to think of this is

00:13:52,290 --> 00:13:56,620
ordering requires that two accesses to

00:13:54,580 --> 00:13:58,000
the same end point will remain in order

00:13:56,620 --> 00:13:59,890
on their way to that end point so in

00:13:58,000 --> 00:14:02,200
this floating picture here you've got

00:13:59,890 --> 00:14:03,490
CPU zero which has done access a and

00:14:02,200 --> 00:14:05,860
then it's done access B and these are

00:14:03,490 --> 00:14:08,320
going towards this end point here so in

00:14:05,860 --> 00:14:11,080
this case you know perhaps there they

00:14:08,320 --> 00:14:12,160
are ordered perhaps and that means that

00:14:11,080 --> 00:14:13,720
everyone's always going to see them in

00:14:12,160 --> 00:14:15,880
order and as they propagate down here

00:14:13,720 --> 00:14:17,140
towards the end point you know B's not

00:14:15,880 --> 00:14:18,700
allowed to overtake a they have to

00:14:17,140 --> 00:14:20,080
remain in order and that might be

00:14:18,700 --> 00:14:22,450
because you put a barrier between them

00:14:20,080 --> 00:14:25,150
or it might be because of memory type or

00:14:22,450 --> 00:14:27,370
whatever and CPU CPU one will see them

00:14:25,150 --> 00:14:28,630
both in order because of that the

00:14:27,370 --> 00:14:29,710
crucially doesn't hold anything up right

00:14:28,630 --> 00:14:34,840
it just punched them out and they

00:14:29,710 --> 00:14:37,780
propagate in order so completion on the

00:14:34,840 --> 00:14:39,880
other hand requires a prior access to

00:14:37,780 --> 00:14:44,830
reach a certain point before it can

00:14:39,880 --> 00:14:45,910
initiate a later access so for reads we

00:14:44,830 --> 00:14:48,610
say that reads complete when they have

00:14:45,910 --> 00:14:49,480
their data so they appear to compete at

00:14:48,610 --> 00:14:52,330
the end point you know if you if you're

00:14:49,480 --> 00:14:55,300
reading from a memory or a peripheral

00:14:52,330 --> 00:14:56,710
you can't you can't satisfy the read

00:14:55,300 --> 00:14:57,940
until it's completed its gonna go

00:14:56,710 --> 00:15:00,280
somewhere it's gonna pick up its value

00:14:57,940 --> 00:15:01,540
then we say it's completed and then

00:15:00,280 --> 00:15:03,310
after that you know that reads how

00:15:01,540 --> 00:15:05,710
complete we can do something else for

00:15:03,310 --> 00:15:07,300
rates they can I should be buffered even

00:15:05,710 --> 00:15:09,130
merged and they can complete early like

00:15:07,300 --> 00:15:11,080
for example on a posted right so here if

00:15:09,130 --> 00:15:14,020
a was a right it might complete at this

00:15:11,080 --> 00:15:15,220
buffer and now we can do B so in this

00:15:14,020 --> 00:15:17,830
case we're saying we have to complete a

00:15:15,220 --> 00:15:19,270
and then we can do be so completion sort

00:15:17,830 --> 00:15:22,690
of implies ordering that you can also

00:15:19,270 --> 00:15:24,070
use completion to achieve the effects of

00:15:22,690 --> 00:15:24,910
ordering two different endpoints and

00:15:24,070 --> 00:15:26,710
that's what we're going to talk about

00:15:24,910 --> 00:15:31,660
for the to the

00:15:26,710 --> 00:15:38,740
then xio accesses so yep let's go on to

00:15:31,660 --> 00:15:41,320
the API shikhandi the one of the big

00:15:38,740 --> 00:15:42,940
problems with i/o ordering is it really

00:15:41,320 --> 00:15:44,320
is it's like a melting pot of lots of

00:15:42,940 --> 00:15:45,940
different memory models so you might

00:15:44,320 --> 00:15:49,600
have the CPU memory model which it preps

00:15:45,940 --> 00:15:51,910
the architecture model and then that

00:15:49,600 --> 00:15:53,440
might interface to an interconnect which

00:15:51,910 --> 00:15:55,240
has an internal memory model which is in

00:15:53,440 --> 00:15:58,420
programmer visible and then someone has

00:15:55,240 --> 00:16:00,010
to bridge that to a another bus like PCI

00:15:58,420 --> 00:16:04,480
wait which does have a programmer

00:16:00,010 --> 00:16:05,800
visible memory model and because all of

00:16:04,480 --> 00:16:07,810
these things have their own memory model

00:16:05,800 --> 00:16:09,250
and it's a lot of it's at the mercy of

00:16:07,810 --> 00:16:11,530
the hardware integrator to get this

00:16:09,250 --> 00:16:13,030
right it can be really complicated and

00:16:11,530 --> 00:16:14,800
and it means you can build systems that

00:16:13,030 --> 00:16:17,560
are broken you could in theory integrate

00:16:14,800 --> 00:16:19,330
a system where you cannot interact with

00:16:17,560 --> 00:16:20,890
the PCI memory model from software point

00:16:19,330 --> 00:16:24,190
of view because the thing in the middle

00:16:20,890 --> 00:16:26,230
just what doesn't play ball so Linux

00:16:24,190 --> 00:16:32,650
kind of has to assume some basic sanity

00:16:26,230 --> 00:16:38,740
here and yeah correct bridging is

00:16:32,650 --> 00:16:40,930
crucial so the two things we need to

00:16:38,740 --> 00:16:43,360
consider really is DMA buffers which are

00:16:40,930 --> 00:16:46,120
allocated via dmal or coherent or Maps

00:16:43,360 --> 00:16:47,380
using the streaming API so linux has

00:16:46,120 --> 00:16:48,550
that interface and it makes an

00:16:47,380 --> 00:16:50,680
assumption about the coherence of

00:16:48,550 --> 00:16:51,790
devices so devices you the DMA coherent

00:16:50,680 --> 00:16:53,230
or it's not we don't have a middle

00:16:51,790 --> 00:16:54,820
ground where all its coherent for these

00:16:53,230 --> 00:16:57,070
types of things up to this point it's

00:16:54,820 --> 00:16:58,480
just coherent or it's not go here and

00:16:57,070 --> 00:17:01,510
mmm i/o regions are mapped using i/o

00:16:58,480 --> 00:17:03,790
remap and that requires aligned accesses

00:17:01,510 --> 00:17:06,010
when you make them it gives you some

00:17:03,790 --> 00:17:07,930
exercise guarantees it guarantees that

00:17:06,010 --> 00:17:09,880
you don't speculate things there are

00:17:07,930 --> 00:17:12,940
some funny versions of IRA map like i/o

00:17:09,880 --> 00:17:14,860
remap WC which is weaker and I remarked

00:17:12,940 --> 00:17:16,120
ash which is stronger the semantics of

00:17:14,860 --> 00:17:17,890
these are pretty vague they're very

00:17:16,120 --> 00:17:20,200
driven by x86 if you if you're going to

00:17:17,890 --> 00:17:22,810
start using IRA map WC or no cash in

00:17:20,200 --> 00:17:24,490
your driver watch out because there's a

00:17:22,810 --> 00:17:25,959
good chance you won't have portable

00:17:24,490 --> 00:17:27,250
correctness well you might not be

00:17:25,959 --> 00:17:29,020
correct across different architectures

00:17:27,250 --> 00:17:32,550
in those cases but we're going to

00:17:29,020 --> 00:17:32,550
concentrate on IR remap ready for this

00:17:34,090 --> 00:17:38,650
so here are the default bio accesses so

00:17:36,490 --> 00:17:42,220
any of you've written a kernel driver as

00:17:38,650 --> 00:17:44,590
probably used early some of these you've

00:17:42,220 --> 00:17:46,540
got your IR mem star back from i/o remap

00:17:44,590 --> 00:17:47,710
and you want to dereference it well you

00:17:46,540 --> 00:17:48,460
can't just blindly dereference it

00:17:47,710 --> 00:17:49,990
because everything will go wrong a

00:17:48,460 --> 00:17:51,400
compiler won't realize what it is and

00:17:49,990 --> 00:17:54,910
who knows what will happen you might

00:17:51,400 --> 00:17:56,740
break the machine or these crash so you

00:17:54,910 --> 00:18:00,610
use a special access so there's these in

00:17:56,740 --> 00:18:03,460
X out X so in B you know is for reading

00:18:00,610 --> 00:18:05,140
that's a legacy x86 port IO access

00:18:03,460 --> 00:18:07,510
instruction but we have an API for it

00:18:05,140 --> 00:18:09,310
and on other architectures it'll be a

00:18:07,510 --> 00:18:12,520
memory map thing under the hood but

00:18:09,310 --> 00:18:14,680
that's where they are we also have read

00:18:12,520 --> 00:18:16,750
X and write X a read L right L things

00:18:14,680 --> 00:18:19,090
like that for accessing explicitly

00:18:16,750 --> 00:18:22,930
mapped mm IO and then you can use io

00:18:19,090 --> 00:18:24,640
read 30 to 32 those kind of things which

00:18:22,930 --> 00:18:26,380
expands to the correct access are based

00:18:24,640 --> 00:18:28,540
on what the devices is under the hood

00:18:26,380 --> 00:18:30,760
and these are the default accesses they

00:18:28,540 --> 00:18:31,810
pretty much always do what you want that

00:18:30,760 --> 00:18:33,880
they can be quite expensive and I'll

00:18:31,810 --> 00:18:36,970
talk about in a minute there are little

00:18:33,880 --> 00:18:38,380
endian by default and they're ordered

00:18:36,970 --> 00:18:42,580
against other accesses to the same

00:18:38,380 --> 00:18:44,590
endpoint so if you do to write ELLs to a

00:18:42,580 --> 00:18:46,930
given mm/yr region that you IRA Maps

00:18:44,590 --> 00:18:50,200
they will be ordered to that IO region

00:18:46,930 --> 00:18:53,350
which is often a desirable property you

00:18:50,200 --> 00:18:55,750
can push writes by doing a reback so if

00:18:53,350 --> 00:18:57,190
you write L and then read our back the

00:18:55,750 --> 00:18:59,310
write L is gonna have to reach the end

00:18:57,190 --> 00:19:01,300
point before your we can come back and

00:18:59,310 --> 00:19:04,870
here's the bit which makes it really

00:19:01,300 --> 00:19:07,930
really really expensive and on x86 which

00:19:04,870 --> 00:19:10,480
is that right access initiates after

00:19:07,930 --> 00:19:11,770
completing prime Emory rights so if you

00:19:10,480 --> 00:19:13,420
remember that well completion means that

00:19:11,770 --> 00:19:14,860
means that your memory rights that are

00:19:13,420 --> 00:19:17,460
before the right access I have to go all

00:19:14,860 --> 00:19:19,420
the way out to memory and be visible and

00:19:17,460 --> 00:19:20,890
depending on your Co here and see that

00:19:19,420 --> 00:19:21,970
could be a different point but you got

00:19:20,890 --> 00:19:24,730
to push everything out your least gonna

00:19:21,970 --> 00:19:26,290
have to drain your store buffer and then

00:19:24,730 --> 00:19:27,940
you can initiate the the right access to

00:19:26,290 --> 00:19:28,360
the device but only that you can't do it

00:19:27,940 --> 00:19:30,340
earlier

00:19:28,360 --> 00:19:34,090
similarly for reads the read access

00:19:30,340 --> 00:19:35,110
completes before initiating later memory

00:19:34,090 --> 00:19:37,690
reads and it also is ordered with

00:19:35,110 --> 00:19:39,850
respect to later delay loops as well not

00:19:37,690 --> 00:19:41,290
currently on arm I'm fixing that which

00:19:39,850 --> 00:19:43,890
was a patch that came out of writing

00:19:41,290 --> 00:19:43,890
this presentation

00:19:44,740 --> 00:19:49,910
so this is kind of the reason it's it's

00:19:47,510 --> 00:19:51,230
it's designed like this is because if

00:19:49,910 --> 00:19:52,850
you're interacting with a device that's

00:19:51,230 --> 00:19:54,320
done DMA it kind of makes sense right so

00:19:52,850 --> 00:19:56,360
you right so you say you want to

00:19:54,320 --> 00:19:57,770
transmit some data you right into the

00:19:56,360 --> 00:20:00,410
DMA buffer and then you write to the

00:19:57,770 --> 00:20:01,640
device saying please DMA my my buffer

00:20:00,410 --> 00:20:02,930
the stuff I just wrote to memory or

00:20:01,640 --> 00:20:04,250
you're right ELLs gonna give you that

00:20:02,930 --> 00:20:05,960
guarantee because it's ordered with

00:20:04,250 --> 00:20:09,620
respect to those it completes them I

00:20:05,960 --> 00:20:11,600
should say you can do some crazy stuff

00:20:09,620 --> 00:20:15,710
with spin locks using this just try not

00:20:11,600 --> 00:20:17,570
to do it it's very complicated on non

00:20:15,710 --> 00:20:20,180
x86 this is really expensive I keep

00:20:17,570 --> 00:20:21,380
saying that so what do we do because in

00:20:20,180 --> 00:20:24,200
the cases where you don't care about

00:20:21,380 --> 00:20:27,020
watering memory accesses you don't want

00:20:24,200 --> 00:20:31,010
to pay this price well you can chill out

00:20:27,020 --> 00:20:32,270
we've got relaxed accesses and they are

00:20:31,010 --> 00:20:36,260
actually quite heavily used because that

00:20:32,270 --> 00:20:37,250
performance berlonis is so high so we

00:20:36,260 --> 00:20:39,170
don't have them for everything we have

00:20:37,250 --> 00:20:40,880
them for read L and write l kind of

00:20:39,170 --> 00:20:42,620
style accesses right L relax read L

00:20:40,880 --> 00:20:45,980
relaxed which are just for these

00:20:42,620 --> 00:20:49,040
accesses here and also for the string

00:20:45,980 --> 00:20:51,080
variants with the S or the rep so that

00:20:49,040 --> 00:20:53,690
the idea of these string accesses that

00:20:51,080 --> 00:20:55,430
it's when you're reading from a memory

00:20:53,690 --> 00:20:56,510
map FIFO something like that so you

00:20:55,430 --> 00:20:57,830
don't actually care about memory

00:20:56,510 --> 00:21:00,290
accesses at all it's just endpoint

00:20:57,830 --> 00:21:01,310
accesses so you don't need ordering

00:21:00,290 --> 00:21:04,250
there we don't need completion

00:21:01,310 --> 00:21:05,480
guarantees so these don't provide any

00:21:04,250 --> 00:21:07,700
completion guarantees but what they do

00:21:05,480 --> 00:21:09,860
provide is that they remain order to the

00:21:07,700 --> 00:21:11,990
same endpoint and people forget that so

00:21:09,860 --> 00:21:13,640
I think there are quite a lot of cases

00:21:11,990 --> 00:21:15,460
where you're not worried about DMA but

00:21:13,640 --> 00:21:18,140
you want to make sure your accesses

00:21:15,460 --> 00:21:19,310
arrive at the endpoint in order that's

00:21:18,140 --> 00:21:20,870
still guaranteed for the relaxed

00:21:19,310 --> 00:21:22,790
accesses and in hindsight maybe relax

00:21:20,870 --> 00:21:24,080
wasn't such a good name because it

00:21:22,790 --> 00:21:25,550
really makes them sound like you can't

00:21:24,080 --> 00:21:27,400
rely on anything you can you've still

00:21:25,550 --> 00:21:29,540
got that order to the same endpoint

00:21:27,400 --> 00:21:31,940
practically they probably also work with

00:21:29,540 --> 00:21:38,330
spin locks but yeah if your machine

00:21:31,940 --> 00:21:40,310
crashes don't blame me so mandatory

00:21:38,330 --> 00:21:41,900
barrier so what you can do is you can if

00:21:40,310 --> 00:21:44,180
you need to be explicit about the

00:21:41,900 --> 00:21:45,680
ordering and offenses that you want you

00:21:44,180 --> 00:21:46,850
can use a mandatory barriers and you can

00:21:45,680 --> 00:21:49,130
even use them in conjunction with the

00:21:46,850 --> 00:21:51,140
relaxed accesses if you were I don't

00:21:49,130 --> 00:21:53,300
know where you do that maybe it's useful

00:21:51,140 --> 00:21:54,560
to do sometimes so we've got three of

00:21:53,300 --> 00:21:56,690
those they're a bit like the SMP

00:21:54,560 --> 00:21:58,850
barriers without the prefix so

00:21:56,690 --> 00:22:01,000
Mb completes prior reads and writes

00:21:58,850 --> 00:22:03,110
before initiates later reads and writes

00:22:01,000 --> 00:22:06,260
and this is for all different end points

00:22:03,110 --> 00:22:07,670
and memory right and then fire mb/s just

00:22:06,260 --> 00:22:08,990
reached reads and WMV its rights to

00:22:07,670 --> 00:22:10,190
rights they're fairly straightforward if

00:22:08,990 --> 00:22:11,990
you ever add one of these please put a

00:22:10,190 --> 00:22:13,700
comment there because it's impossible to

00:22:11,990 --> 00:22:17,360
recode that just has these willy-nilly

00:22:13,700 --> 00:22:18,380
you just can't remove them so if you use

00:22:17,360 --> 00:22:22,010
them in conjunction with the relax

00:22:18,380 --> 00:22:23,870
accesses for example right L basically

00:22:22,010 --> 00:22:25,520
behaves like a WMV and then a write L

00:22:23,870 --> 00:22:27,560
relaxed and that's pretty much how we

00:22:25,520 --> 00:22:31,820
implement it and I'm 64 and this W&B is

00:22:27,560 --> 00:22:35,180
expensive and then this is just another

00:22:31,820 --> 00:22:37,580
example if you wanted to order or

00:22:35,180 --> 00:22:40,730
complete a right before initiating a

00:22:37,580 --> 00:22:42,890
read you have to use an MB because right

00:22:40,730 --> 00:22:44,890
L doesn't do that that's the only way

00:22:42,890 --> 00:22:47,240
you can have right to read order in here

00:22:44,890 --> 00:22:49,220
but if you're doing normal DMA with the

00:22:47,240 --> 00:22:53,980
same device you generally don't need

00:22:49,220 --> 00:22:53,980
this you can use the default accesses

00:22:56,260 --> 00:23:01,760
good so another type of ordering

00:22:59,660 --> 00:23:02,630
mechanism we have DMA barriers now these

00:23:01,760 --> 00:23:05,750
are actually quite a lot different these

00:23:02,630 --> 00:23:07,910
are only intended to be used for DMA or

00:23:05,750 --> 00:23:10,790
coherent allocations and they only

00:23:07,910 --> 00:23:13,040
provide ordering for um memory accesses

00:23:10,790 --> 00:23:14,390
memory accesses and they're much much

00:23:13,040 --> 00:23:16,670
much cheaper than all of the other

00:23:14,390 --> 00:23:17,810
fences so a common use for these in fact

00:23:16,670 --> 00:23:20,120
the only use I've really seen is where

00:23:17,810 --> 00:23:21,740
you have a coherent descriptor ring and

00:23:20,120 --> 00:23:23,570
maybe a device is doing DMA of

00:23:21,740 --> 00:23:25,910
descriptors which have a payload and a

00:23:23,570 --> 00:23:27,860
valid flag and you want to read the

00:23:25,910 --> 00:23:30,350
valid flag and then read the payload and

00:23:27,860 --> 00:23:33,740
you can use for example a DMA RMB to

00:23:30,350 --> 00:23:35,990
order those reads no effect on IRM

00:23:33,740 --> 00:23:39,140
access and they're relatively cheap so

00:23:35,990 --> 00:23:42,830
yeah if you're writing a coherent DMA

00:23:39,140 --> 00:23:45,050
ring the read side of that just just use

00:23:42,830 --> 00:23:47,000
DMA RMB don't use RMB the ARB is much

00:23:45,050 --> 00:23:51,800
much quicker and I think it's quicker on

00:23:47,000 --> 00:23:53,420
x86 as well so let's go through some

00:23:51,800 --> 00:23:54,770
examples I went through the kernel

00:23:53,420 --> 00:23:56,720
source code to try and find examples of

00:23:54,770 --> 00:23:57,800
uses of these so the slides are

00:23:56,720 --> 00:23:58,850
available if you ever want to go back

00:23:57,800 --> 00:23:59,180
and have a look and actually in doing

00:23:58,850 --> 00:24:01,980
this

00:23:59,180 --> 00:24:03,870
I found bugs in code I'd written so

00:24:01,980 --> 00:24:06,330
I don't know what that says about the

00:24:03,870 --> 00:24:09,600
API but at least i-i've now documented

00:24:06,330 --> 00:24:11,039
it and I have patches so so here's an

00:24:09,600 --> 00:24:13,529
example this was one case right she got

00:24:11,039 --> 00:24:16,019
it right my favorite driver cuz I wrote

00:24:13,529 --> 00:24:18,929
it submitting a command to the SMU so

00:24:16,019 --> 00:24:21,330
the SMM use it's an arm immu and it has

00:24:18,929 --> 00:24:23,549
a memory map cue so we've got this cue

00:24:21,330 --> 00:24:25,470
right here and we're basically just

00:24:23,549 --> 00:24:27,809
copying from something in memory to a

00:24:25,470 --> 00:24:30,480
DMA buffer so this is a DMA a coherent

00:24:27,809 --> 00:24:33,809
in memory buffer so we copy the stuff in

00:24:30,480 --> 00:24:35,309
there's a bunch of stores and then we're

00:24:33,809 --> 00:24:37,380
gonna do this little bit weird maths

00:24:35,309 --> 00:24:40,649
because it's a cue and then a write l2

00:24:37,380 --> 00:24:42,299
update the memory mapped so it's

00:24:40,649 --> 00:24:45,149
probably here to update the memory

00:24:42,299 --> 00:24:46,350
mapped register say hey there's some new

00:24:45,149 --> 00:24:47,610
stuff in the queue so you need to make

00:24:46,350 --> 00:24:50,490
sure that what you wrote to the memory

00:24:47,610 --> 00:24:52,080
map queue is completed before you write

00:24:50,490 --> 00:24:55,200
to the device which is why you need a

00:24:52,080 --> 00:25:01,440
write L so that's a classic example of

00:24:55,200 --> 00:25:03,480
where you need to use write L so here's

00:25:01,440 --> 00:25:04,980
another example and I'm not very I don't

00:25:03,480 --> 00:25:06,149
know much about networking and just to

00:25:04,980 --> 00:25:09,059
the north fit on a slide so I had to

00:25:06,149 --> 00:25:11,039
trim things down a bit but we have this

00:25:09,059 --> 00:25:13,710
Ethernet driver here for reading our X

00:25:11,039 --> 00:25:15,779
data so there's a function here called M

00:25:13,710 --> 00:25:17,100
V reg read which is basically just a

00:25:15,779 --> 00:25:19,110
riddle I think it might be a hash define

00:25:17,100 --> 00:25:23,490
to read or so just treat that as a

00:25:19,110 --> 00:25:25,860
riedle I ran out of slide and we do a we

00:25:23,490 --> 00:25:28,440
call that this MV net or us Q busy desk

00:25:25,860 --> 00:25:29,970
not get which is here so that's our read

00:25:28,440 --> 00:25:31,710
or to find out how much stuff is there

00:25:29,970 --> 00:25:33,840
how much stuff is there in my receive

00:25:31,710 --> 00:25:37,289
queue how many descriptors do I have and

00:25:33,840 --> 00:25:39,120
once we know we basically get something

00:25:37,289 --> 00:25:42,750
out of there and then we need to do a

00:25:39,120 --> 00:25:44,909
mem copy here and this mem copy has to

00:25:42,750 --> 00:25:46,740
be ordered because it's a reading from

00:25:44,909 --> 00:25:50,250
the Q with respect to when we find out

00:25:46,740 --> 00:25:51,510
how many descriptors there are so we

00:25:50,250 --> 00:25:53,490
could have complete these guys now you

00:25:51,510 --> 00:25:55,620
might think hang on a minute there's a

00:25:53,490 --> 00:25:58,019
sort of a dependency here in some sense

00:25:55,620 --> 00:26:00,360
because this rx to do forms part of the

00:25:58,019 --> 00:26:02,250
condition of the while loop so maybe

00:26:00,360 --> 00:26:04,139
that's enough to give us ordering and

00:26:02,250 --> 00:26:06,659
essentially not because the CPU can

00:26:04,139 --> 00:26:08,309
speculate this these loads here in the

00:26:06,659 --> 00:26:09,510
mem copy in theory so you could still

00:26:08,309 --> 00:26:11,340
have an issue so you do need to use

00:26:09,510 --> 00:26:13,260
write l know read out there so you can't

00:26:11,340 --> 00:26:14,850
use read L relaxed so it's like the

00:26:13,260 --> 00:26:15,130
opposite of the previous example we're

00:26:14,850 --> 00:26:17,500
doing

00:26:15,130 --> 00:26:24,730
a read of the register and then a read

00:26:17,500 --> 00:26:26,140
of the memory so here's you know I've

00:26:24,730 --> 00:26:27,550
just given you two examples why you

00:26:26,140 --> 00:26:29,140
should never use the relaxed accesses

00:26:27,550 --> 00:26:31,150
which is not what I want so let's let's

00:26:29,140 --> 00:26:33,010
move on to their relaxed accesses here

00:26:31,150 --> 00:26:34,510
is a driver again I've had to trim it

00:26:33,010 --> 00:26:36,010
down a bit to keep it on the slide but

00:26:34,510 --> 00:26:39,160
basically what it's doing is its setting

00:26:36,010 --> 00:26:40,570
up the parameters for a DMA in mm i/o

00:26:39,160 --> 00:26:41,830
registers so there's a whole bunch of

00:26:40,570 --> 00:26:43,480
stuff it's a display driver which is

00:26:41,830 --> 00:26:45,610
another thing I know nothing about but

00:26:43,480 --> 00:26:47,230
um there's got a mem con which needs to

00:26:45,610 --> 00:26:50,320
be started then an address and a pitch

00:26:47,230 --> 00:26:51,580
and then there's GMC setting zero it's

00:26:50,320 --> 00:26:53,140
the thing that actually says right go

00:26:51,580 --> 00:26:53,590
and do the DMA using the parameters I

00:26:53,140 --> 00:26:54,970
just gave you

00:26:53,590 --> 00:26:56,650
so that achieve the parameters

00:26:54,970 --> 00:26:57,910
themselves we don't care we can use

00:26:56,650 --> 00:26:59,590
relaxed here because we just need to

00:26:57,910 --> 00:27:02,590
make sure they're ordered with respect

00:26:59,590 --> 00:27:04,000
to this guy and if you remember relaxed

00:27:02,590 --> 00:27:06,730
accesses are ordered to the same end

00:27:04,000 --> 00:27:09,250
point but the final right L which

00:27:06,730 --> 00:27:11,380
triggers the DMA that needs to be

00:27:09,250 --> 00:27:13,450
ordered with respect to M prime memory

00:27:11,380 --> 00:27:15,280
rights okay needs to complete them I

00:27:13,450 --> 00:27:17,590
should say I keep getting all your wrong

00:27:15,280 --> 00:27:20,500
people tend to get this wrong and you'll

00:27:17,590 --> 00:27:23,230
see WM B's littered over here which is

00:27:20,500 --> 00:27:24,520
probably worse than just using right L

00:27:23,230 --> 00:27:26,410
for everything because it makes the code

00:27:24,520 --> 00:27:27,850
more confusing so you don't need W M

00:27:26,410 --> 00:27:33,850
beads in this case this is this is

00:27:27,850 --> 00:27:35,710
perfectly fine this will work okay you

00:27:33,850 --> 00:27:38,620
might not recognize this file because

00:27:35,710 --> 00:27:40,810
it's not in mainline unfortunately it is

00:27:38,620 --> 00:27:42,460
in the Ubuntu kernel package because

00:27:40,810 --> 00:27:46,000
they apparently shipped a special kernel

00:27:42,460 --> 00:27:49,150
for this SOC which is suboptimal and

00:27:46,000 --> 00:27:50,800
this this file brings up the l2 and

00:27:49,150 --> 00:27:52,180
initializes the snoop control unit which

00:27:50,800 --> 00:27:52,720
is questionable whether Linux should be

00:27:52,180 --> 00:27:54,790
doing this

00:27:52,720 --> 00:28:00,700
so take take a deep breath because this

00:27:54,790 --> 00:28:02,500
is a marvel of code um yeah so I'm sure

00:28:00,700 --> 00:28:03,880
these are all documented and we could

00:28:02,500 --> 00:28:05,080
probably just figure out where the bug

00:28:03,880 --> 00:28:07,420
is but there is a bug here and it's

00:28:05,080 --> 00:28:08,950
actually quite a cryptic bug and I do

00:28:07,420 --> 00:28:10,750
need to fix Linux that's another thing

00:28:08,950 --> 00:28:12,390
that the arm 64 port doesn't doesn't

00:28:10,750 --> 00:28:14,500
quite get this right either

00:28:12,390 --> 00:28:16,870
and the issue is we're doing a

00:28:14,500 --> 00:28:18,970
right-tail relaxed - apparently dear

00:28:16,870 --> 00:28:22,120
cert this reset with these magic values

00:28:18,970 --> 00:28:26,020
then there's an mb and we have to wait

00:28:22,120 --> 00:28:28,539
for 54 microseconds and then turn this

00:28:26,020 --> 00:28:30,099
thing on and assumingly this is critical

00:28:28,539 --> 00:28:32,379
otherwise this somehow hasn't had an

00:28:30,099 --> 00:28:35,919
effect I have no idea but the problem is

00:28:32,379 --> 00:28:37,239
this this can complete early as I showed

00:28:35,919 --> 00:28:38,499
in those diagrams earlier on right

00:28:37,239 --> 00:28:41,019
there's there's no guarantee here that

00:28:38,499 --> 00:28:44,679
this is actually had an effect it might

00:28:41,019 --> 00:28:46,749
be buffered so this you delay here we've

00:28:44,679 --> 00:28:48,009
the CPU can wait 54 microseconds a

00:28:46,749 --> 00:28:49,570
device might still not have seen this

00:28:48,009 --> 00:28:50,589
and then this could go and join it in

00:28:49,570 --> 00:28:51,929
the buffer and there you can see them

00:28:50,589 --> 00:28:55,029
both at the same time so there's no

00:28:51,929 --> 00:28:58,509
guarantee that the device is gonna see

00:28:55,029 --> 00:29:03,489
the delay here anyone got an idea how

00:28:58,509 --> 00:29:06,039
you would fix this exactly so you read

00:29:03,489 --> 00:29:08,049
put a read back here which is gonna

00:29:06,039 --> 00:29:09,369
force that guy to come out and go all

00:29:08,049 --> 00:29:10,479
the way to the endpoint then you can do

00:29:09,369 --> 00:29:11,859
your wait and then you can do this I'm

00:29:10,479 --> 00:29:14,679
gonna fix it and then that will also

00:29:11,859 --> 00:29:18,190
work it on 64 it currently does work on

00:29:14,679 --> 00:29:19,719
power and it does work on x86 and it

00:29:18,190 --> 00:29:21,009
seems that actually this is quite a

00:29:19,719 --> 00:29:23,789
common pattern for people to do an

00:29:21,009 --> 00:29:25,809
access to nm mio and then spin for a bit

00:29:23,789 --> 00:29:28,479
but like like I said um where it's not a

00:29:25,809 --> 00:29:32,949
mainline so sure this is done by some

00:29:28,479 --> 00:29:35,889
reliable firmware instead so another

00:29:32,949 --> 00:29:36,969
thing you should the DMA em beasts so

00:29:35,889 --> 00:29:38,799
this one is great because they put a

00:29:36,969 --> 00:29:40,539
comment in so whoever wrote this code

00:29:38,799 --> 00:29:43,539
thank you very much this was a joy to

00:29:40,539 --> 00:29:46,869
read just found it very easily so where

00:29:43,539 --> 00:29:49,119
it's in an InfiniBand driver it's in a

00:29:46,869 --> 00:29:50,709
task lit polling this notification queue

00:29:49,119 --> 00:29:52,179
and there's a budget basically of how

00:29:50,709 --> 00:29:54,009
many things we're gonna try and pull out

00:29:52,179 --> 00:29:55,329
of this queue and there's two bits we do

00:29:54,009 --> 00:29:57,909
is we grab something out of the queue

00:29:55,329 --> 00:30:01,509
and check is it valid if it's not valid

00:29:57,909 --> 00:30:03,549
we just skip we're done and if it is

00:30:01,509 --> 00:30:05,199
valid all great it was valid so now we

00:30:03,549 --> 00:30:07,389
can go and actually access the stuff in

00:30:05,199 --> 00:30:08,859
the buffer that the payload part I

00:30:07,389 --> 00:30:11,489
should say and we need to make sure that

00:30:08,859 --> 00:30:13,690
we don't speculatively load the payload

00:30:11,489 --> 00:30:15,009
then the thing becomes valid and we

00:30:13,690 --> 00:30:16,539
think that we saw the valid payload we

00:30:15,009 --> 00:30:18,339
need ordering between checking valid and

00:30:16,539 --> 00:30:20,589
reading the payload and you can do that

00:30:18,339 --> 00:30:26,649
with the DMA R and B and this is a good

00:30:20,589 --> 00:30:31,199
example of that so this is another one

00:30:26,649 --> 00:30:33,909
of my favorite drivers of course lying

00:30:31,199 --> 00:30:34,719
this is the SMC ni'mal when X dot Z and

00:30:33,909 --> 00:30:35,919
if you haven't if you haven't

00:30:34,719 --> 00:30:39,669
encountered this driver you haven't

00:30:35,919 --> 00:30:40,830
lived so this this has some nice

00:30:39,669 --> 00:30:42,450
wrappers

00:30:40,830 --> 00:30:44,640
for these functions so we've got to

00:30:42,450 --> 00:30:46,080
receive and ascend which some reason

00:30:44,640 --> 00:30:48,180
have got different style in naming and

00:30:46,080 --> 00:30:49,380
but they expand to these macros well

00:30:48,180 --> 00:30:52,260
they use these macros so there's a pool

00:30:49,380 --> 00:30:55,080
days turn up push data which is another

00:30:52,260 --> 00:30:56,490
way of saying reading a writing data and

00:30:55,080 --> 00:30:58,410
you can see how these macros are then

00:30:56,490 --> 00:30:59,820
defined in terms of in their cell and in

00:30:58,410 --> 00:31:02,400
our test cell which then eventually you

00:30:59,820 --> 00:31:05,040
go to the right 32 rep library 32 right

00:31:02,400 --> 00:31:06,600
there using the string accesses and this

00:31:05,040 --> 00:31:08,160
particular piece of hardware can be

00:31:06,600 --> 00:31:10,550
built and very often is built without

00:31:08,160 --> 00:31:13,440
any DMA capability so the way that you

00:31:10,550 --> 00:31:14,520
get data out or get data in from it I

00:31:13,440 --> 00:31:18,300
should say there's just a narrow i/o

00:31:14,520 --> 00:31:20,250
register and you read it and you get 32

00:31:18,300 --> 00:31:21,630
bits of packet and then you read it

00:31:20,250 --> 00:31:22,890
again and you get the next 32 bit and

00:31:21,630 --> 00:31:24,320
you just keep reading and if you can't

00:31:22,890 --> 00:31:28,320
read it fast enough it all goes wrong

00:31:24,320 --> 00:31:29,490
and similar for sending stuff out so

00:31:28,320 --> 00:31:30,600
that's what these macros are doing and

00:31:29,490 --> 00:31:33,240
in that case you really don't care about

00:31:30,600 --> 00:31:34,350
any memory ordering as long as you're

00:31:33,240 --> 00:31:35,580
getting the stuff out of the FIFO in

00:31:34,350 --> 00:31:37,470
order and that's guaranteed by the

00:31:35,580 --> 00:31:39,930
string accesses so that's why we use

00:31:37,470 --> 00:31:42,690
them there so is actually once you

00:31:39,930 --> 00:31:48,540
untangle all of the preprocessor it's

00:31:42,690 --> 00:31:50,100
actually a reasonable example so I'm

00:31:48,540 --> 00:31:53,060
pretending to offer a hundred pound

00:31:50,100 --> 00:31:56,790
reward because there is a rumor that

00:31:53,060 --> 00:32:00,720
some Adaptec card is rumored to do DMA

00:31:56,790 --> 00:32:03,770
on a read so you read a register and

00:32:00,720 --> 00:32:06,420
then it does a DMA which is a bit weird

00:32:03,770 --> 00:32:07,380
it's not really does make any sense why

00:32:06,420 --> 00:32:08,310
you would build hardware like this

00:32:07,380 --> 00:32:09,510
because reads are quite expensive

00:32:08,310 --> 00:32:11,520
because you actually have to complete at

00:32:09,510 --> 00:32:12,960
the end point I couldn't find anything

00:32:11,520 --> 00:32:15,840
in the tree but there's a lot of code in

00:32:12,960 --> 00:32:17,190
the tree and all I have is this sum

00:32:15,840 --> 00:32:20,070
Adaptec card or I don't think it's a

00:32:17,190 --> 00:32:21,360
very new cut so in theory to fix this

00:32:20,070 --> 00:32:24,630
and make sure it works you'd require an

00:32:21,360 --> 00:32:27,480
explicit mb before the mm i/o read so if

00:32:24,630 --> 00:32:29,190
you find it you can come and claim your

00:32:27,480 --> 00:32:31,590
hundred pound reward and I'll probably

00:32:29,190 --> 00:32:32,910
not give it to you have a look it'd be

00:32:31,590 --> 00:32:34,410
great if you let me know if you find any

00:32:32,910 --> 00:32:36,150
examples because this will this will not

00:32:34,410 --> 00:32:37,440
work without the mb so maybe your reward

00:32:36,150 --> 00:32:40,380
is actually you have to write a patch to

00:32:37,440 --> 00:32:42,270
add the mb okay

00:32:40,380 --> 00:32:44,490
any questions oh and thanks to aunt and

00:32:42,270 --> 00:32:48,240
Ben for helping me reverse-engineer the

00:32:44,490 --> 00:32:50,900
semantics of these api's that's it

00:32:48,240 --> 00:32:50,900
question

00:32:54,719 --> 00:32:58,209
and if you have a question you have to

00:32:56,559 --> 00:33:07,209
come up to the front and there's a mic

00:32:58,209 --> 00:33:09,249
there and I'm like there if you want

00:33:07,209 --> 00:33:10,959
your tropical island with non SMP

00:33:09,249 --> 00:33:15,129
platform you might not want to bring it

00:33:10,959 --> 00:33:19,439
alpha not a wall of them right that's

00:33:15,129 --> 00:33:22,149
true alpha it started off well and

00:33:19,439 --> 00:33:22,959
they're not a comment on the whole maybe

00:33:22,149 --> 00:33:25,689
you don't want to bring that up

00:33:22,959 --> 00:33:28,679
infirmary in Linux on the l2 cache

00:33:25,689 --> 00:33:32,499
config oh yeah I know it's a complicated

00:33:28,679 --> 00:33:34,239
subject but at least we see the mess now

00:33:32,499 --> 00:33:37,239
because it would be the same in firmer

00:33:34,239 --> 00:33:39,849
it wouldn't be fixed but yeah that's

00:33:37,239 --> 00:33:42,729
true and there's quite a lot going on

00:33:39,849 --> 00:33:47,439
obviously to have open source firmware

00:33:42,729 --> 00:33:49,179
now but the incentive is perhaps not as

00:33:47,439 --> 00:33:50,769
strong as having open source operating

00:33:49,179 --> 00:33:52,869
system there's not as much to get back

00:33:50,769 --> 00:33:54,249
from it so you're right at least we can

00:33:52,869 --> 00:33:56,619
see the code and we can reason about it

00:33:54,249 --> 00:33:58,899
and as I say even if they fix that code

00:33:56,619 --> 00:34:00,309
there's actually an underlying bug in

00:33:58,899 --> 00:34:03,389
our back end which I'm now going to fix

00:34:00,309 --> 00:34:06,459
so it was useful for that you're right

00:34:03,389 --> 00:34:09,519
yep thanks for the talk could you show

00:34:06,459 --> 00:34:11,109
slide number between 25 once again

00:34:09,519 --> 00:34:13,629
please don't buy me what did I do this

00:34:11,109 --> 00:34:17,079
one yeah if I understood you right you

00:34:13,629 --> 00:34:21,250
said that MB here is not enough or is

00:34:17,079 --> 00:34:23,230
the bug yeah so the look here so the

00:34:21,250 --> 00:34:25,990
problem is yes so MB is gonna force this

00:34:23,230 --> 00:34:27,490
guy to complete but if you remember the

00:34:25,990 --> 00:34:29,109
completion diagram I showed you can

00:34:27,490 --> 00:34:31,539
complete earlier because I posted right

00:34:29,109 --> 00:34:34,869
for example so when you complete this

00:34:31,539 --> 00:34:36,279
right here the device this l2 based

00:34:34,869 --> 00:34:38,049
thing might still not see it there could

00:34:36,279 --> 00:34:39,879
be a buffer a hub where buffer before

00:34:38,049 --> 00:34:41,319
that device so all it means is that this

00:34:39,879 --> 00:34:43,990
guy's guaranteed to have got into that

00:34:41,319 --> 00:34:46,210
buffer but it at that point it's not

00:34:43,990 --> 00:34:49,059
able to effect any state change on the

00:34:46,210 --> 00:34:53,049
DL to base this this power controlled

00:34:49,059 --> 00:34:54,490
here so then you wait this 54 then this

00:34:53,049 --> 00:34:55,929
guy can also go and sit in the buffer

00:34:54,490 --> 00:34:59,739
and then perhaps they both go out

00:34:55,929 --> 00:35:01,569
together and you see one cycle at the

00:34:59,739 --> 00:35:02,970
end point between the two rights which

00:35:01,569 --> 00:35:05,790
probably isn't what

00:35:02,970 --> 00:35:07,410
going for here I mean it also might work

00:35:05,790 --> 00:35:09,420
fine and given that this is sock

00:35:07,410 --> 00:35:10,920
specific in my work fine on that SOC I'm

00:35:09,420 --> 00:35:12,869
just trying to use an example for this

00:35:10,920 --> 00:35:14,250
was the only when I I found this by

00:35:12,869 --> 00:35:18,560
chance when I was looking to see what

00:35:14,250 --> 00:35:28,290
this file was and and it's yeah

00:35:18,560 --> 00:35:30,359
not the correct use of the the API this

00:35:28,290 --> 00:35:32,420
code probably know how to look is there

00:35:30,359 --> 00:35:34,710
actually anything preventing us from

00:35:32,420 --> 00:35:41,220
speculating the you delay even before

00:35:34,710 --> 00:35:44,070
the right of starts so it depends if the

00:35:41,220 --> 00:35:47,280
if the you delay is backed by a memory

00:35:44,070 --> 00:35:50,190
mapped timer then the MB will hold it up

00:35:47,280 --> 00:35:52,859
if it's backed by an system register

00:35:50,190 --> 00:35:55,320
reads then actually probably not I was

00:35:52,859 --> 00:35:56,310
thinking of the classical loop of

00:35:55,320 --> 00:35:59,910
million times

00:35:56,310 --> 00:36:03,480
implementation yeah and if that doesn't

00:35:59,910 --> 00:36:05,310
contain any loads or stores basically

00:36:03,480 --> 00:36:08,580
any memory access is gonna be held up by

00:36:05,310 --> 00:36:09,690
the MB but you delay doesn't do any

00:36:08,580 --> 00:36:13,290
memory access in the trivia

00:36:09,690 --> 00:36:15,270
implementation we could just do the Hugh

00:36:13,290 --> 00:36:17,040
delay even before we do the right L and

00:36:15,270 --> 00:36:18,150
the read read l and the memory barrier

00:36:17,040 --> 00:36:21,990
you might you might run into trouble

00:36:18,150 --> 00:36:23,609
with because you'll get a let me think

00:36:21,990 --> 00:36:25,800
about this it's quite complicated the

00:36:23,609 --> 00:36:28,710
backwards control loop might stop that I

00:36:25,800 --> 00:36:30,450
don't ever think about it but it

00:36:28,710 --> 00:36:31,740
certainly can go wrong you need that you

00:36:30,450 --> 00:36:33,089
need that read L and we have to put some

00:36:31,740 --> 00:36:34,500
magic in the read L to make sure that we

00:36:33,089 --> 00:36:36,480
hold up stuff probably using a fake

00:36:34,500 --> 00:36:41,220
control dependency which is based on a

00:36:36,480 --> 00:36:43,920
trick from how PC actually another

00:36:41,220 --> 00:36:49,650
question not about the sweat thus I

00:36:43,920 --> 00:36:52,020
always effects when writes complete or

00:36:49,650 --> 00:36:55,680
not for example on all your examples you

00:36:52,020 --> 00:36:58,859
use 32-bit writes right and if you for

00:36:55,680 --> 00:37:02,820
example in interleaved exam with 16 bits

00:36:58,859 --> 00:37:04,410
or by tries does it effect somehow so if

00:37:02,820 --> 00:37:09,060
you you mean if you this was like a

00:37:04,410 --> 00:37:11,250
series right B's or something not a

00:37:09,060 --> 00:37:12,990
serious but interleaved for example if

00:37:11,250 --> 00:37:14,680
you go to that slide where you have

00:37:12,990 --> 00:37:17,320
three rights

00:37:14,680 --> 00:37:19,390
I'll relaxed and one right at the end

00:37:17,320 --> 00:37:22,540
yeah I think it was probably just wrong

00:37:19,390 --> 00:37:26,380
this one yeah the second one will be

00:37:22,540 --> 00:37:28,630
right be okay so that's still okay so

00:37:26,380 --> 00:37:30,580
actually if you look at these whilst

00:37:28,630 --> 00:37:33,220
they're using the same base these are

00:37:30,580 --> 00:37:35,380
all different offsets so all you need is

00:37:33,220 --> 00:37:37,060
to make sure that they're accessing the

00:37:35,380 --> 00:37:39,630
the same device and then you'll have

00:37:37,060 --> 00:37:41,950
order they don't have to the the actual

00:37:39,630 --> 00:37:44,470
underlying addresses do not need to

00:37:41,950 --> 00:37:52,180
overlap and you'll still get still get

00:37:44,470 --> 00:37:58,350
the order there okay I think I'm about

00:37:52,180 --> 00:37:58,350

YouTube URL: https://www.youtube.com/watch?v=i6DayghhA8Q


