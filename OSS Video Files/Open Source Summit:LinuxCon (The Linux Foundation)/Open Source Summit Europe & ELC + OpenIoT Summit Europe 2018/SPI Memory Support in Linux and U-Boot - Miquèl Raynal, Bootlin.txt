Title: SPI Memory Support in Linux and U-Boot - Miquèl Raynal, Bootlin
Publication date: 2018-10-25
Playlist: Open Source Summit Europe & ELC + OpenIoT Summit Europe 2018
Description: 
	SPI Memory Support in Linux and U-Boot - Miquèl Raynal, Bootlin

For a long time already, SPI memories have been supported in Linux and U-Boot. They were relatively small and slow (like dataflash and EEPROM) but the new trend in the embedded world is now leaning towards fast SPI NOR and SPI NAND devices which people tend to use as their main storage.

In this talk Miquèl will present how those devices work and how you can get the best performance out of them by using advanced SPI modes like Dual or Quad SPI. He will also talk about the rework he did in Linux and U-Boot to be able to support all kinds of SPI memories (SPI NOR, SPI NAND, SPI SRAM) using the same SPI controller driver and still be able to benefit from advanced features (like direct mapping) provided by some SPI controllers. 

About Miquèl Raynal
Miquèl is an embedded Linux engineer at Bootlin since 2017. | He has been working on various ARM embedded systems and is the co-maintainer of the NAND subsystem. | Miquèl recently worked on SPI NAND support in Linux and U-Boot.
Captions: 
	00:00:00,089 --> 00:00:05,160
hello everyone thanks for watching this

00:00:02,820 --> 00:00:09,780
session it's about my memory support in

00:00:05,160 --> 00:00:12,509
Linux and you boot let me introduce

00:00:09,780 --> 00:00:16,170
myself I'm Michael I'm working at butene

00:00:12,509 --> 00:00:18,510
we do kind of staff training and as part

00:00:16,170 --> 00:00:22,260
of this job I've been involved in the

00:00:18,510 --> 00:00:24,779
port of the spy memory framework in new

00:00:22,260 --> 00:00:28,710
boot and that's what I'm talking about

00:00:24,779 --> 00:00:32,099
today so this is my sister gonna talk

00:00:28,710 --> 00:00:34,020
about the entity subsystem this is

00:00:32,099 --> 00:00:37,739
pretty much how I feel now that I know

00:00:34,020 --> 00:00:40,110
all the subsystems hopefully having such

00:00:37,739 --> 00:00:42,690
contributions like the creation of this

00:00:40,110 --> 00:00:50,010
spy memory framework will improve things

00:00:42,690 --> 00:00:52,500
but we are not there yet so this talk is

00:00:50,010 --> 00:00:53,879
about spy memories I will start with the

00:00:52,500 --> 00:00:58,289
spy bus

00:00:53,879 --> 00:01:03,270
what has changed to support the storage

00:00:58,289 --> 00:01:05,790
over spy buses and how we do we support

00:01:03,270 --> 00:01:07,770
it in Linux on your boot and maybe

00:01:05,790 --> 00:01:11,700
getting feedback from users if there are

00:01:07,770 --> 00:01:14,520
any in this room so let's start small

00:01:11,700 --> 00:01:18,590
with the spy bus it's for y of us as you

00:01:14,520 --> 00:01:22,619
know there is one chip select per device

00:01:18,590 --> 00:01:24,150
one o'clock and two data lines one from

00:01:22,619 --> 00:01:25,710
the master to the slave one from the

00:01:24,150 --> 00:01:28,950
slave to the master which means it's a

00:01:25,710 --> 00:01:31,200
full duplex protocol it runs at ten

00:01:28,950 --> 00:01:34,049
megahertz which for me is really read is

00:01:31,200 --> 00:01:37,290
really high and really people will say

00:01:34,049 --> 00:01:42,420
it's incredibly slow but for us it's

00:01:37,290 --> 00:01:47,700
quite ok in the embedded world spy is

00:01:42,420 --> 00:01:52,170
good but for storage it wasn't it wasn't

00:01:47,700 --> 00:01:54,990
enough so people starting thinking how

00:01:52,170 --> 00:01:57,780
we can improve the throughput first

00:01:54,990 --> 00:01:59,939
solution is to increase the clock of

00:01:57,780 --> 00:02:04,079
course so now we can see buses running

00:01:59,939 --> 00:02:08,399
at 100 megahertz the second solution is

00:02:04,079 --> 00:02:09,820
to increase the number of i/o lines data

00:02:08,399 --> 00:02:12,850
i/o lines

00:02:09,820 --> 00:02:16,270
so now we know we have a dual spiked

00:02:12,850 --> 00:02:20,290
whites by an octave spy and of course

00:02:16,270 --> 00:02:22,180
you can double the rate with double data

00:02:20,290 --> 00:02:23,740
rate mode when you sample both on the

00:02:22,180 --> 00:02:26,740
rising edge and the falling edge of the

00:02:23,740 --> 00:02:29,260
clock of course all of these comes with

00:02:26,740 --> 00:02:31,930
an extra cost and it's a bit more

00:02:29,260 --> 00:02:35,380
complex to handle the fact that we use

00:02:31,930 --> 00:02:39,340
dual quad or octo modes means the

00:02:35,380 --> 00:02:41,550
protocol is now half duplex not fully

00:02:39,340 --> 00:02:43,660
blacks anymore

00:02:41,550 --> 00:02:45,490
the number of airlines is

00:02:43,660 --> 00:02:48,430
device-specific and there is a

00:02:45,490 --> 00:02:52,080
negotiation between the spy controller

00:02:48,430 --> 00:02:57,040
and the between the master and the slave

00:02:52,080 --> 00:03:00,550
this is just primary protocol so it's

00:02:57,040 --> 00:03:03,880
made of different cycles of codes

00:03:00,550 --> 00:03:06,340
address cycles dummy cycles and data in

00:03:03,880 --> 00:03:11,080
our data out cycles this is pretty

00:03:06,340 --> 00:03:15,400
standard all of this makes primary

00:03:11,080 --> 00:03:20,800
commands this is the basics of an

00:03:15,400 --> 00:03:25,720
exchange with a spy memory the opcode

00:03:20,800 --> 00:03:27,489
that's at the at the beginning will

00:03:25,720 --> 00:03:30,550
determine what's after if there is

00:03:27,489 --> 00:03:33,700
another opcode with there are another

00:03:30,550 --> 00:03:36,700
address bytes baby dummy byte so that I

00:03:33,700 --> 00:03:41,380
write data data bytes and if yes how

00:03:36,700 --> 00:03:43,269
many this is the generic part of the spy

00:03:41,380 --> 00:03:47,970
memory protocol of course the common set

00:03:43,269 --> 00:03:50,650
are different what is the cycles we know

00:03:47,970 --> 00:03:54,190
we now know about the spine and and

00:03:50,650 --> 00:03:55,600
spinal command sets might have other

00:03:54,190 --> 00:03:57,790
ones

00:03:55,600 --> 00:04:02,350
what's pretty standard here is the fact

00:03:57,790 --> 00:04:07,269
that we need to read write erase access

00:04:02,350 --> 00:04:09,519
internal read registers those are our

00:04:07,269 --> 00:04:11,950
two registered as a pretty standard

00:04:09,519 --> 00:04:14,380
actually I don't think there is a a real

00:04:11,950 --> 00:04:17,320
specification around this but for now

00:04:14,380 --> 00:04:18,130
we've only seen ships following this so

00:04:17,320 --> 00:04:20,340
this is great

00:04:18,130 --> 00:04:23,520
please guys continue like this

00:04:20,340 --> 00:04:24,389
and of course vendors can add at their

00:04:23,520 --> 00:04:26,400
own outcodes

00:04:24,389 --> 00:04:32,960
if they want to add some features to

00:04:26,400 --> 00:04:36,270
their chips this is an example of Reid

00:04:32,960 --> 00:04:39,720
we don't know it's pretty

00:04:36,270 --> 00:04:42,180
straightforward it's just one command

00:04:39,720 --> 00:04:45,780
and one upcountry address bytes and then

00:04:42,180 --> 00:04:48,800
the data you want to read with Nance

00:04:45,780 --> 00:04:51,810
it's always more complicated with Nance

00:04:48,800 --> 00:04:55,979
you know you can't read byte by byte you

00:04:51,810 --> 00:04:59,060
have to to read a page which is usually

00:04:55,979 --> 00:05:02,700
2k for case it depends

00:04:59,060 --> 00:05:05,760
so first you have to read an entire page

00:05:02,700 --> 00:05:07,770
and put it in cash during this time you

00:05:05,760 --> 00:05:10,889
will pull a status register until the

00:05:07,770 --> 00:05:12,990
operation is done and once this is done

00:05:10,889 --> 00:05:18,300
you can actually read the data from the

00:05:12,990 --> 00:05:21,479
cache in the penmanship so this is the

00:05:18,300 --> 00:05:26,789
theory let's see how it's handled in

00:05:21,479 --> 00:05:29,460
Linux first initially spy memories were

00:05:26,789 --> 00:05:33,600
handled like West reported like any of

00:05:29,460 --> 00:05:39,450
the devices with drivers in driver / MPD

00:05:33,600 --> 00:05:42,990
/ devices they were made of regular spy

00:05:39,450 --> 00:05:48,539
messages and spy transfers it worked

00:05:42,990 --> 00:05:51,270
great until we people people used more

00:05:48,539 --> 00:05:55,349
advanced PI controllers that can do

00:05:51,270 --> 00:06:00,120
highest reports and automate things so a

00:05:55,349 --> 00:06:05,430
spinal subsystem was created to handle

00:06:00,120 --> 00:06:08,220
the spinal command set and the the spy

00:06:05,430 --> 00:06:11,099
control drivers the advanced ones could

00:06:08,220 --> 00:06:16,220
implement the spinal interface okay so

00:06:11,099 --> 00:06:20,789
this is this was the stack at this time

00:06:16,220 --> 00:06:23,130
you had spinal controller drivers just

00:06:20,789 --> 00:06:27,360
dealing with Hardware on the spine of

00:06:23,130 --> 00:06:29,279
our work with dealing with the no spinal

00:06:27,360 --> 00:06:33,469
command set

00:06:29,279 --> 00:06:37,019
of course for regular spy controllers

00:06:33,469 --> 00:06:40,079
people wrote a specific a generic driver

00:06:37,019 --> 00:06:42,809
which is called m25 p88 an awful name

00:06:40,079 --> 00:06:45,389
for this because it's used for much more

00:06:42,809 --> 00:06:47,819
than one single controller but it's

00:06:45,389 --> 00:06:49,739
basically translates what's given by the

00:06:47,819 --> 00:06:56,309
spinal framework into something

00:06:49,739 --> 00:06:59,699
understandable by the spy framework so

00:06:56,309 --> 00:07:04,589
this works great until people started

00:06:59,699 --> 00:07:06,629
adding spinal you must know that spy

00:07:04,589 --> 00:07:08,759
memory controllers spy controllers and

00:07:06,629 --> 00:07:13,579
those who have these advanced features

00:07:08,759 --> 00:07:17,159
not care about what's in the opcodes

00:07:13,579 --> 00:07:19,229
there are memory agnostic so one

00:07:17,159 --> 00:07:23,009
solution could have been to write

00:07:19,229 --> 00:07:27,689
another span spine on stack like this

00:07:23,009 --> 00:07:31,199
one but beside but this would have

00:07:27,689 --> 00:07:35,839
duplicated a lot of code because the

00:07:31,199 --> 00:07:39,569
underlying hardware is the same so the

00:07:35,839 --> 00:07:42,599
the solution that has been proved was to

00:07:39,569 --> 00:07:45,299
use instead of you the spy framework was

00:07:42,599 --> 00:07:51,959
to use the spy spy memory framework a

00:07:45,299 --> 00:07:54,689
new one on top of it the spine and

00:07:51,959 --> 00:07:59,209
fairmark was added pretty much like the

00:07:54,689 --> 00:08:02,699
spinal framework and the m25 PhD driver

00:07:59,209 --> 00:08:07,469
that's our example from the beginning

00:08:02,699 --> 00:08:10,110
with a read within a read attempt so a

00:08:07,469 --> 00:08:12,149
user tries to read an empty device from

00:08:10,110 --> 00:08:14,729
user space it goes through the entity

00:08:12,149 --> 00:08:17,999
framework and then depending on the

00:08:14,729 --> 00:08:20,299
underlying chip it really goes through

00:08:17,999 --> 00:08:23,129
the spider framework or spinal framework

00:08:20,299 --> 00:08:27,059
this one will handle the common set so

00:08:23,129 --> 00:08:30,689
will translate the read request into the

00:08:27,059 --> 00:08:34,589
spy memory operations and the spy mem

00:08:30,689 --> 00:08:37,469
framework will act as a sink and check

00:08:34,589 --> 00:08:40,590
if the spy controller drivers can handle

00:08:37,469 --> 00:08:44,610
such optimize is

00:08:40,590 --> 00:08:47,970
there is a there is a hook which is

00:08:44,610 --> 00:08:49,710
called a supported op and if yes we'll

00:08:47,970 --> 00:08:53,300
call the hook eggs a cup which is

00:08:49,710 --> 00:08:56,790
implemented by this driver to send

00:08:53,300 --> 00:09:01,980
actually send the data to the spy chip

00:08:56,790 --> 00:09:05,910
spy flash if the driver cannot handle

00:09:01,980 --> 00:09:07,680
the operation the spy memory framework

00:09:05,910 --> 00:09:12,120
will know it thanks to the support of

00:09:07,680 --> 00:09:19,340
hook and we'll fall back to regular spy

00:09:12,120 --> 00:09:23,130
transfers that's all for Linux so what

00:09:19,340 --> 00:09:26,930
about you boot now well I've been

00:09:23,130 --> 00:09:29,640
involved in migrating the spy memory

00:09:26,930 --> 00:09:32,430
framework and the spine and framework to

00:09:29,640 --> 00:09:36,600
you boot from Linux to you boot we

00:09:32,430 --> 00:09:39,510
needed a bit of redesign because you put

00:09:36,600 --> 00:09:44,700
used internally its own glue about

00:09:39,510 --> 00:09:47,160
around the NCD devices yeah we spent

00:09:44,700 --> 00:09:51,000
some time cleaning all of this and also

00:09:47,160 --> 00:09:53,670
really rewriting a bit how to handle

00:09:51,000 --> 00:09:55,320
partitions actually the partition work

00:09:53,670 --> 00:09:57,870
is not even mainlined

00:09:55,320 --> 00:10:03,630
in Linux I need to find some time to do

00:09:57,870 --> 00:10:06,600
it so now you have entity devices having

00:10:03,630 --> 00:10:08,610
parents until there is no more

00:10:06,600 --> 00:10:10,680
partitions and we are on the actual

00:10:08,610 --> 00:10:14,760
entity device which is the real physical

00:10:10,680 --> 00:10:17,610
one all this work has been merged in the

00:10:14,760 --> 00:10:18,810
aussie to the last alpha 2 because we've

00:10:17,610 --> 00:10:23,670
been ab in late

00:10:18,810 --> 00:10:25,950
thanks to Travis CI we had some troubles

00:10:23,670 --> 00:10:28,530
getting all the configurations work so

00:10:25,950 --> 00:10:33,210
Tamra nee accepted to match this work a

00:10:28,530 --> 00:10:37,490
bit later than than the merge window but

00:10:33,210 --> 00:10:37,490
you its main line now and you can try it

00:10:38,390 --> 00:10:45,690
so this was the internal stuff any good

00:10:42,660 --> 00:10:48,690
but from a user perspective you need to

00:10:45,690 --> 00:10:50,960
interact with your device there were

00:10:48,690 --> 00:10:55,580
three there are three come

00:10:50,960 --> 00:10:58,640
to do that sf4 spy flash named and one

00:10:55,580 --> 00:11:02,060
month also the NT departs command

00:10:58,640 --> 00:11:05,660
actually the question was shall we add a

00:11:02,060 --> 00:11:10,220
spine on command now and the answer is

00:11:05,660 --> 00:11:12,580
no because we trimmed all this internal

00:11:10,220 --> 00:11:15,740
glue to use most of the entity stack and

00:11:12,580 --> 00:11:18,410
there is no real reason to not use the

00:11:15,740 --> 00:11:21,350
abstraction of the entity layer so

00:11:18,410 --> 00:11:24,110
instead we wrote an entity command which

00:11:21,350 --> 00:11:28,190
should duplicate duplicate the three

00:11:24,110 --> 00:11:31,220
other commands at the top it acts almost

00:11:28,190 --> 00:11:35,900
like them there isn't help you can have

00:11:31,220 --> 00:11:38,570
a look at for people handling partitions

00:11:35,900 --> 00:11:42,140
that was a question that was asked to me

00:11:38,570 --> 00:11:45,800
a few times the entity parts command

00:11:42,140 --> 00:11:49,190
will be duplicated not the tip not the

00:11:45,800 --> 00:11:52,100
entity parts viable you can still define

00:11:49,190 --> 00:11:54,530
over your partitions there because it

00:11:52,100 --> 00:11:57,710
will still be used by by Linux if you

00:11:54,530 --> 00:12:00,560
put it in the in the command line but

00:11:57,710 --> 00:12:04,750
now any time you will use the MTD

00:12:00,560 --> 00:12:08,420
commands to read all right your devices

00:12:04,750 --> 00:12:11,810
it will check if the entry department or

00:12:08,420 --> 00:12:15,470
entity ID variables have changed and if

00:12:11,810 --> 00:12:18,200
yes it will automatically update the MTD

00:12:15,470 --> 00:12:27,080
partitions before doing the real job you

00:12:18,200 --> 00:12:30,280
asked for so what's next in the future

00:12:27,080 --> 00:12:34,550
we would like to support direct mapping

00:12:30,280 --> 00:12:36,620
it would be a great feature to have it

00:12:34,550 --> 00:12:39,470
will even allowed to execute in place

00:12:36,620 --> 00:12:41,860
code from Spain and ships by no chips

00:12:39,470 --> 00:12:41,860
and sorry

00:12:42,670 --> 00:12:49,270
we should convert all the spinal

00:12:45,310 --> 00:12:55,550
controllers these controllers in the red

00:12:49,270 --> 00:12:57,740
in the red thing before it's part of the

00:12:55,550 --> 00:13:00,320
past we don't want to see them anymore

00:12:57,740 --> 00:13:02,840
and now they should be migrated to use a

00:13:00,320 --> 00:13:05,740
spy memory framework

00:13:02,840 --> 00:13:08,480
and of course try not to reproduce our

00:13:05,740 --> 00:13:12,410
previous mistakes stay memory agnostic

00:13:08,480 --> 00:13:14,930
do not mix everything just a few words

00:13:12,410 --> 00:13:18,500
about the direct mapping you can create

00:13:14,930 --> 00:13:21,380
a gem map object and it will appear like

00:13:18,500 --> 00:13:25,250
regular memory for you you can have you

00:13:21,380 --> 00:13:28,690
can do German read or write on it if

00:13:25,250 --> 00:13:32,089
your controller supports it it would

00:13:28,690 --> 00:13:34,160
automatically do the the spy memory

00:13:32,089 --> 00:13:39,110
operations on those papers and access

00:13:34,160 --> 00:13:45,050
the spine on / none or no device and it

00:13:39,110 --> 00:13:48,190
would be transparent for you so now

00:13:45,050 --> 00:13:51,529
what's in the pipe for the spinal side

00:13:48,190 --> 00:13:55,610
it was recently added the non-uniform

00:13:51,529 --> 00:13:58,070
erase sizes I know some spinal

00:13:55,610 --> 00:14:00,230
controllers are being migrated like the

00:13:58,070 --> 00:14:05,300
Atma and makers microchip one and the

00:14:00,230 --> 00:14:11,330
physical spinal controllers the direct

00:14:05,300 --> 00:14:14,240
mapping API of course and the m25 PhD

00:14:11,330 --> 00:14:16,520
drivers I talked about before is being

00:14:14,240 --> 00:14:20,180
renamed to be something more generic

00:14:16,520 --> 00:14:24,710
like spy - no dot C which is much more

00:14:20,180 --> 00:14:27,620
meaningful for us this is for spinal for

00:14:24,710 --> 00:14:32,350
spinal now we have the same problematic

00:14:27,620 --> 00:14:35,839
about G map API of course what's missing

00:14:32,350 --> 00:14:38,390
the support for on flash bad block table

00:14:35,839 --> 00:14:41,810
right now we rely on the bad blood

00:14:38,390 --> 00:14:45,020
markers so it would be great to have a

00:14:41,810 --> 00:14:48,920
whole flashback table like with parallel

00:14:45,020 --> 00:14:51,860
nuns there is an unfree page parameter

00:14:48,920 --> 00:14:55,820
page in some chips we don't read it

00:14:51,860 --> 00:14:58,400
maybe we could optimize some things the

00:14:55,820 --> 00:15:01,220
ECC enzyme there is no generic ECC

00:14:58,400 --> 00:15:06,950
engine block right now for spine on

00:15:01,220 --> 00:15:10,400
ships we can only use chips with on the

00:15:06,950 --> 00:15:13,190
ECC otherwise it will not work right now

00:15:10,400 --> 00:15:14,200
with this framework but it will be great

00:15:13,190 --> 00:15:18,160
to have it for

00:15:14,200 --> 00:15:22,959
to have a software ECC running on your

00:15:18,160 --> 00:15:25,120
SOC I think support for new chips is

00:15:22,959 --> 00:15:27,959
something we are looking for so if you

00:15:25,120 --> 00:15:31,449
are already using Spain and chips please

00:15:27,959 --> 00:15:34,540
contribute the drivers for these chips

00:15:31,449 --> 00:15:38,079
are really small and anyway if you're

00:15:34,540 --> 00:15:41,250
using the MT 29 F driver spinal driver

00:15:38,079 --> 00:15:43,589
it's going to be removed anytime soon

00:15:41,250 --> 00:15:48,339
probably in the next release so you

00:15:43,589 --> 00:15:52,329
really should migrate to this to this

00:15:48,339 --> 00:15:54,430
new framework yeah that's all for me

00:15:52,329 --> 00:15:55,630
thank you for your attention now if you

00:15:54,430 --> 00:16:02,220
have any question I'd be pleased to

00:15:55,630 --> 00:16:02,220
answer them now microphone

00:16:14,130 --> 00:16:21,130
hi in our products we are using some

00:16:17,620 --> 00:16:24,640
fancy nor SPI trips from Spanish on they

00:16:21,130 --> 00:16:27,940
have they have two dice inside one

00:16:24,640 --> 00:16:30,100
package yes which is as the you word

00:16:27,940 --> 00:16:32,560
version that we are using is 2017 dot

00:16:30,100 --> 00:16:34,720
one which is not supported officially is

00:16:32,560 --> 00:16:36,430
there any plan to support those fancy

00:16:34,720 --> 00:16:38,980
configurations and newer versions of you

00:16:36,430 --> 00:16:40,990
good because there are a lot of patches

00:16:38,980 --> 00:16:43,510
around yeah but none of them has been

00:16:40,990 --> 00:16:45,760
mainland preferable the patches are from

00:16:43,510 --> 00:16:47,860
the islands because there are the only

00:16:45,760 --> 00:16:51,580
vendor who support those chips and their

00:16:47,860 --> 00:16:55,060
associate some work has been delayed

00:16:51,580 --> 00:16:58,990
because of internal changes we discussed

00:16:55,060 --> 00:17:03,220
a lot with yagan we with you would spy

00:16:58,990 --> 00:17:05,500
maintainer and hi can't hands for you

00:17:03,220 --> 00:17:09,850
right now I think maybe market here and

00:17:05,500 --> 00:17:11,920
can no I don't know where he's well I

00:17:09,850 --> 00:17:15,220
can have an answer right now with this

00:17:11,920 --> 00:17:20,010
but you can ping maybe again which

00:17:15,220 --> 00:17:20,010
working as maintainer for in this area

00:17:27,740 --> 00:17:35,730
any other question no okay well thank

00:17:35,130 --> 00:17:38,779
you

00:17:35,730 --> 00:17:38,779

YouTube URL: https://www.youtube.com/watch?v=PkWbuLM_gmU


