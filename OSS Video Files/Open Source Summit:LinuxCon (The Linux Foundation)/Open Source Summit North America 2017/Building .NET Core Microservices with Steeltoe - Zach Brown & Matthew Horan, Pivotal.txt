Title: Building .NET Core Microservices with Steeltoe - Zach Brown & Matthew Horan, Pivotal
Publication date: 2017-09-13
Playlist: Open Source Summit North America 2017
Description: 
	Building .NET Core Microservices with Steeltoe - Zach Brown & Matthew Horan, Pivotal

The software world is moving to microservices. For all their benefits, microservice architectures expose many distributed computing problems that developers need to solve--problems like service discovery, shared configuration, distributed tracing, etc. The good news is that Netflix, Spring Cloud, and others have developed industry standard patterns to simplify the task of building resilient scale-out microservice-based applications. Until very recently, however, this technology has really only been accessible to Java devs. Steeltoe is a new OSS project that makes these patterns available to .NET developers.

In this presentation, we will provide an overview of Steeltoe and why we created it. We will cover current capabilities, future roadmap, and of course, demos that show how it works.

http://steeltoe.io
https://github.com/steeltoeoss
twitter: @steeltoeoss

About Zach Brown
Zach Brown starting building web sites in the 90s using Netscape-optimized HTML, cgi, and lots of Photoshop lens flares. He spent many years as an enterprise software developer in the Microsoft ecosystem, and now works at Pivotal in San Francisco as a customer-facing Product Owner for Pivotal Cloud Foundry and Steeltoe.

About Matthew Horan
Matthew Horan has spent over a decade developing Web applications. Before becoming a developer, he worked as a systems administrator at various startups and hosting providers. Having worked with just about every configuration management tool, and being a developer by trade, he was naturally drawn to Cloud Foundry. He has focused on .NET due to a desire to bring the best practices of Pivotal's Cloud Foundry platform to a wider audience.
Captions: 
	00:00:00,719 --> 00:00:06,480
so my name's Zack brown this is Matt

00:00:04,170 --> 00:00:08,400
Horan and today we're gonna talk a

00:00:06,480 --> 00:00:11,639
little bit about this open source

00:00:08,400 --> 00:00:14,960
project called Steel Toe and how it

00:00:11,639 --> 00:00:16,170
helps you build resilient micro-services

00:00:14,960 --> 00:00:19,230
with.net

00:00:16,170 --> 00:00:21,590
from dotnet and and it's it's really

00:00:19,230 --> 00:00:23,279
cool so let's go ahead and dive in

00:00:21,590 --> 00:00:25,949
alright well this is what we're gonna

00:00:23,279 --> 00:00:28,830
look at today you can see we'll talk a

00:00:25,949 --> 00:00:31,980
little bit about the dotnet Renaissance

00:00:28,830 --> 00:00:34,140
we are in this interesting period right

00:00:31,980 --> 00:00:36,239
now with regards to net and I'll talk a

00:00:34,140 --> 00:00:38,730
little bit more about that then we'll

00:00:36,239 --> 00:00:41,280
tell you what is steel-toe and then some

00:00:38,730 --> 00:00:43,110
details on why is Steel Toe in other

00:00:41,280 --> 00:00:46,230
words why we built it and what's in

00:00:43,110 --> 00:00:47,250
Steel Toe and we'll talk a little bit

00:00:46,230 --> 00:00:49,530
about cloud foundry

00:00:47,250 --> 00:00:51,210
because cloud foundry it's where we'll

00:00:49,530 --> 00:00:54,239
run our demos today and you'll hear us

00:00:51,210 --> 00:00:55,890
mention it throughout the talk just so

00:00:54,239 --> 00:00:57,410
you understand what it is and where

00:00:55,890 --> 00:00:59,879
we're deploying these applications to

00:00:57,410 --> 00:01:01,800
and then we'll give a really cool demo

00:00:59,879 --> 00:01:03,719
to show some of this stuff and then I'll

00:01:01,800 --> 00:01:05,489
follow it up with a little bit of our

00:01:03,719 --> 00:01:08,250
roadmap for Steel Toe where we're going

00:01:05,489 --> 00:01:12,000
next and some additional resources if

00:01:08,250 --> 00:01:14,280
you all want to dig in and try some of

00:01:12,000 --> 00:01:17,610
it out yourself alright

00:01:14,280 --> 00:01:21,299
Oh before we start let me invite you

00:01:17,610 --> 00:01:24,090
encourage you to be engaged take photos

00:01:21,299 --> 00:01:26,759
tweet let's have the dialogue that we're

00:01:24,090 --> 00:01:29,520
starting here be the beginning and not

00:01:26,759 --> 00:01:31,100
limit this conversation to the scope and

00:01:29,520 --> 00:01:33,840
space and time of this presentation

00:01:31,100 --> 00:01:36,689
let's take it on the road feel free to

00:01:33,840 --> 00:01:41,100
follow us on Twitter and let's let's

00:01:36,689 --> 00:01:45,930
keep the conversation going all right so

00:01:41,100 --> 00:01:48,030
welcome to the dotnet renaissance some

00:01:45,930 --> 00:01:51,149
people in the open source world when you

00:01:48,030 --> 00:01:55,110
say the word net they automatically

00:01:51,149 --> 00:01:57,420
think old-school they think maybe it's

00:01:55,110 --> 00:01:59,189
passe or that it's not what the cool

00:01:57,420 --> 00:02:00,329
kids are doing I don't know what the

00:01:59,189 --> 00:02:03,090
cool kids are doing maybe they're all

00:02:00,329 --> 00:02:06,119
writing golang or Ruby or nodejs or

00:02:03,090 --> 00:02:08,039
something but lately some interesting

00:02:06,119 --> 00:02:11,580
things have been happening up in Redmond

00:02:08,039 --> 00:02:14,490
there are a lot of changes underfoot

00:02:11,580 --> 00:02:17,040
and all together they make right now a

00:02:14,490 --> 00:02:19,350
really exciting time to be a dotnet

00:02:17,040 --> 00:02:20,880
developer so in case you're not clear

00:02:19,350 --> 00:02:22,340
what I'm talking about let me refresh

00:02:20,880 --> 00:02:26,820
your memory

00:02:22,340 --> 00:02:29,160
Microsoft loves Linux you know you can

00:02:26,820 --> 00:02:32,310
run bash on Windows now you can run

00:02:29,160 --> 00:02:33,330
Linux containers on Windows who could

00:02:32,310 --> 00:02:36,780
have seen this coming

00:02:33,330 --> 00:02:40,650
a couple of years ago Steve Ballmer very

00:02:36,780 --> 00:02:42,870
famously said Linux is a cancer and now

00:02:40,650 --> 00:02:44,640
we've got Satya Nadella up in front of

00:02:42,870 --> 00:02:47,480
this giant stage with Microsoft loves

00:02:44,640 --> 00:02:50,010
Linux I know that I I secretly wish

00:02:47,480 --> 00:02:52,290
somebody from Microsoft would send Steve

00:02:50,010 --> 00:02:54,120
a big box of those t-shirts that say

00:02:52,290 --> 00:02:56,040
Microsoft loves Linux I would love to

00:02:54,120 --> 00:03:05,070
see him at one of the Clippers games

00:02:56,040 --> 00:03:07,830
rockin that t-shirt well yes indeed he

00:03:05,070 --> 00:03:10,740
is isn't he all right well how about

00:03:07,830 --> 00:03:13,110
this one Microsoft loves open-source so

00:03:10,740 --> 00:03:14,700
this is another significant pivot it

00:03:13,110 --> 00:03:16,650
used to be that the ultimate sign of

00:03:14,700 --> 00:03:19,019
success for your dotnet related

00:03:16,650 --> 00:03:20,910
open-source project was when Microsoft

00:03:19,019 --> 00:03:22,050
came out with their commercial version

00:03:20,910 --> 00:03:25,709
of whatever you were doing

00:03:22,050 --> 00:03:27,840
and tried to squash your project so so

00:03:25,709 --> 00:03:29,970
this is a big deal that they're now

00:03:27,840 --> 00:03:34,230
fostering a community in community

00:03:29,970 --> 00:03:37,950
projects and net is now open source

00:03:34,230 --> 00:03:40,800
the.net framework is now it's part of

00:03:37,950 --> 00:03:42,930
this dotnet foundation and there's

00:03:40,800 --> 00:03:44,850
they're working really hard to foster a

00:03:42,930 --> 00:03:47,190
community around it and in addition

00:03:44,850 --> 00:03:49,200
there's now dotnet core this

00:03:47,190 --> 00:03:51,420
cross-platform set of runtimes and

00:03:49,200 --> 00:03:55,320
frameworks that run on Linux that run on

00:03:51,420 --> 00:03:57,330
Mac OS in addition to Windows and of

00:03:55,320 --> 00:04:00,090
course Visual Studio had to get in on

00:03:57,330 --> 00:04:03,180
the lovefest - there's a full-blown

00:04:00,090 --> 00:04:06,269
Visual Studio IDE that runs on Mac OS

00:04:03,180 --> 00:04:07,920
now and there's a new lightweight editor

00:04:06,269 --> 00:04:10,620
called Visual Studio code if you haven't

00:04:07,920 --> 00:04:14,549
tried it it's pretty cool runs on Linux

00:04:10,620 --> 00:04:17,580
runs on Mac runs on Windows but wait

00:04:14,549 --> 00:04:21,359
that's not all sequel server now runs on

00:04:17,580 --> 00:04:24,870
Linux all right take a minute and look

00:04:21,359 --> 00:04:25,620
at all those hearts as I'm sure you're

00:04:24,870 --> 00:04:29,080
aware

00:04:25,620 --> 00:04:32,080
statistics show that most long-lasting

00:04:29,080 --> 00:04:34,870
loving relationships and marriages they

00:04:32,080 --> 00:04:37,660
start when you write two names with a

00:04:34,870 --> 00:04:41,260
heart in between it could be on your

00:04:37,660 --> 00:04:43,510
notebook your desk at school a carved

00:04:41,260 --> 00:04:47,410
into a tree trunk or my personal

00:04:43,510 --> 00:04:50,530
favorite carved into wet cement so what

00:04:47,410 --> 00:04:52,630
does it mean all those hearts well when

00:04:50,530 --> 00:04:55,710
you write a heart with your sweetheart

00:04:52,630 --> 00:04:58,750
it means that things are getting serious

00:04:55,710 --> 00:05:02,230
so what are we left to take away from

00:04:58,750 --> 00:05:04,570
this image of so many hearts things that

00:05:02,230 --> 00:05:08,500
Microsoft they're starting to get

00:05:04,570 --> 00:05:10,750
serious all right so what's all this

00:05:08,500 --> 00:05:11,350
about the dotnet Renaissance earlier

00:05:10,750 --> 00:05:15,220
this summer

00:05:11,350 --> 00:05:17,260
Ian Cooper at the NDC Oslo conference he

00:05:15,220 --> 00:05:19,270
said we are on the cusp of a dotnet

00:05:17,260 --> 00:05:21,310
Renaissance and the way that he framed

00:05:19,270 --> 00:05:22,450
it is he looked at a lot of things that

00:05:21,310 --> 00:05:24,250
are happening in the community now

00:05:22,450 --> 00:05:27,190
specifically he had all sorts of

00:05:24,250 --> 00:05:30,430
statistics about how we're losing jobs

00:05:27,190 --> 00:05:32,050
c-sharp jobs are on the decline and then

00:05:30,430 --> 00:05:34,180
he likened it to something that happened

00:05:32,050 --> 00:05:37,810
in the Java community six or seven years

00:05:34,180 --> 00:05:40,720
ago and there was this time when in the

00:05:37,810 --> 00:05:42,670
Java world the JVM was losing developers

00:05:40,720 --> 00:05:47,110
and they were losing him to Ruby on

00:05:42,670 --> 00:05:49,660
Rails the idea was that people were

00:05:47,110 --> 00:05:53,740
moving away from those really high

00:05:49,660 --> 00:05:55,930
friction heavy-duty app servers Java EE

00:05:53,740 --> 00:05:57,610
app servers and moving to this low

00:05:55,930 --> 00:06:00,490
friction experience of building websites

00:05:57,610 --> 00:06:03,430
with Ruby well what happened after that

00:06:00,490 --> 00:06:04,930
was there was this Renaissance of

00:06:03,430 --> 00:06:08,740
projects that came up

00:06:04,930 --> 00:06:11,380
nettie the Spring Framework Netflix OSS

00:06:08,740 --> 00:06:15,310
and suddenly they really reinvigorated

00:06:11,380 --> 00:06:17,740
and filled out this rich community there

00:06:15,310 --> 00:06:20,290
was an explosion of projects around

00:06:17,740 --> 00:06:23,470
things like high resilience or high

00:06:20,290 --> 00:06:26,920
scalability 12 factors micro service

00:06:23,470 --> 00:06:29,080
application architectures so where does

00:06:26,920 --> 00:06:31,090
that leave us with net well if you look

00:06:29,080 --> 00:06:33,730
at the example of net net just have its

00:06:31,090 --> 00:06:34,720
15th birthday this year Java is around

00:06:33,730 --> 00:06:37,330
20 years old

00:06:34,720 --> 00:06:38,230
so maybe timing-wise were about the

00:06:37,330 --> 00:06:40,860
right time

00:06:38,230 --> 00:06:44,830
for some kind of a cool thing to happen

00:06:40,860 --> 00:06:48,190
we've got a cross-platform net core was

00:06:44,830 --> 00:06:50,110
released Microsoft's pivot towards the

00:06:48,190 --> 00:06:52,500
open source community and embracing that

00:06:50,110 --> 00:06:56,500
community instead of competing with it

00:06:52,500 --> 00:06:58,330
but where we are is we're still we're

00:06:56,500 --> 00:07:00,460
still missing some pieces

00:06:58,330 --> 00:07:02,980
at least until recently there hasn't

00:07:00,460 --> 00:07:05,950
been that rich community of tooling for

00:07:02,980 --> 00:07:07,960
resilient micro services so that is

00:07:05,950 --> 00:07:10,900
where Steel Toe comes in and that's what

00:07:07,960 --> 00:07:12,670
we're gonna talk about today all right

00:07:10,900 --> 00:07:14,500
what is Steel Toe at this point I'm

00:07:12,670 --> 00:07:18,010
gonna hand it over to Matt to talk us

00:07:14,500 --> 00:07:19,570
through what steel tool is cool

00:07:18,010 --> 00:07:21,610
so Steel Toe is an open-source project

00:07:19,570 --> 00:07:22,750
is that pointed out it's sponsored by

00:07:21,610 --> 00:07:26,320
the company that we both work for

00:07:22,750 --> 00:07:29,890
pivotal and it provides client libraries

00:07:26,320 --> 00:07:31,660
for spring cloud Netflix OSS and in

00:07:29,890 --> 00:07:33,880
addition some extra tooling to help it

00:07:31,660 --> 00:07:36,160
make it a little bit easier to use cloud

00:07:33,880 --> 00:07:37,420
foundry and cloud foundry services so

00:07:36,160 --> 00:07:40,750
it's a kid mentioned something about

00:07:37,420 --> 00:07:42,040
that and and so it's this open source

00:07:40,750 --> 00:07:45,340
project that you kind of add to your

00:07:42,040 --> 00:07:47,590
project and your application can use all

00:07:45,340 --> 00:07:50,650
this code that's already existed from

00:07:47,590 --> 00:07:52,630
Netflix and from from other sorban

00:07:50,650 --> 00:07:54,910
source projects and this is the

00:07:52,630 --> 00:07:57,520
steel-toe logo here it's actually an S

00:07:54,910 --> 00:07:59,830
if you if you couldn't tell that I did

00:07:57,520 --> 00:08:01,360
not design it if I did design it it

00:07:59,830 --> 00:08:03,820
would have looked something like this

00:08:01,360 --> 00:08:04,570
which I did in the about 15 minutes

00:08:03,820 --> 00:08:06,670
ago

00:08:04,570 --> 00:08:11,170
so I'm glad we had a designer do that

00:08:06,670 --> 00:08:14,530
professionally but before we get into

00:08:11,170 --> 00:08:19,060
what makes up steel let's talk about why

00:08:14,530 --> 00:08:23,050
we built it so the first reason is to

00:08:19,060 --> 00:08:26,340
help you get your dotnet Haitians cloud

00:08:23,050 --> 00:08:30,730
native and so would it be in there well

00:08:26,340 --> 00:08:32,710
this tall factor app concept which came

00:08:30,730 --> 00:08:34,030
out around the time of Heroku and inside

00:08:32,710 --> 00:08:38,020
of this platform as-a-service

00:08:34,030 --> 00:08:40,740
movement which was an effort to help you

00:08:38,020 --> 00:08:44,350
kind of D couple applications from

00:08:40,740 --> 00:08:47,680
keeping state on disk and relying on

00:08:44,350 --> 00:08:49,420
things like J session ID and Java to pin

00:08:47,680 --> 00:08:51,000
application instances for inbound

00:08:49,420 --> 00:08:54,480
requests because you didn't have

00:08:51,000 --> 00:08:57,660
shared session store maybe using like a

00:08:54,480 --> 00:08:59,670
database instead of relying on disk

00:08:57,660 --> 00:09:01,530
persistence or hard coding database

00:08:59,670 --> 00:09:04,260
strings into your applications right all

00:09:01,530 --> 00:09:06,960
these things are anti patterns in

00:09:04,260 --> 00:09:08,210
Anatole factory application and so 12

00:09:06,960 --> 00:09:11,370
factor net if you're not familiar

00:09:08,210 --> 00:09:12,870
actually spells out these these twelve

00:09:11,370 --> 00:09:15,660
factors that are important for

00:09:12,870 --> 00:09:19,560
applications that are targeting cloud

00:09:15,660 --> 00:09:23,310
native deployment and Cloud Foundry

00:09:19,560 --> 00:09:25,860
being a cloud native deployment runtime

00:09:23,310 --> 00:09:27,240
and a platform as a service that's where

00:09:25,860 --> 00:09:30,990
steel-toe kind of glues everything

00:09:27,240 --> 00:09:33,990
together and so steel-toe helps you

00:09:30,990 --> 00:09:36,720
follow all these good practices for

00:09:33,990 --> 00:09:38,580
cloud native applications not writing to

00:09:36,720 --> 00:09:41,550
the registry getting rid of global

00:09:38,580 --> 00:09:43,020
application cache all these all these

00:09:41,550 --> 00:09:46,500
anti patterns when we want to move away

00:09:43,020 --> 00:09:48,180
from that server that Joe set up for you

00:09:46,500 --> 00:09:50,100
in the back room and you know you can

00:09:48,180 --> 00:09:53,400
only ever get that server running again

00:09:50,100 --> 00:09:54,840
when you call him because it's down and

00:09:53,400 --> 00:09:57,630
then of course

00:09:54,840 --> 00:10:00,480
micro services great oh this wouldn't be

00:09:57,630 --> 00:10:02,630
a technology conference without talking

00:10:00,480 --> 00:10:05,400
about micro services right and so

00:10:02,630 --> 00:10:07,950
steel-toe enables this building and

00:10:05,400 --> 00:10:12,890
deployment of resilient cloud native

00:10:07,950 --> 00:10:16,980
micro services and what we mean here is

00:10:12,890 --> 00:10:19,020
enabling you know developers to take

00:10:16,980 --> 00:10:21,720
ownership of a small portion of an

00:10:19,020 --> 00:10:24,950
application and iterate on that making

00:10:21,720 --> 00:10:28,440
it easy to run test Suites and and build

00:10:24,950 --> 00:10:30,090
components in isolation give teams the

00:10:28,440 --> 00:10:31,440
empowerment to make their own decisions

00:10:30,090 --> 00:10:34,380
and then come together and build that

00:10:31,440 --> 00:10:37,730
whole product this increases developer

00:10:34,380 --> 00:10:41,120
velocity and decreases test cycle time

00:10:37,730 --> 00:10:44,400
it also makes it well to build

00:10:41,120 --> 00:10:48,570
applications say you had a giant

00:10:44,400 --> 00:10:51,500
application that required on the dotnet

00:10:48,570 --> 00:10:53,850
desktop CLR on a Windows Server right

00:10:51,500 --> 00:10:57,660
but you want to enable moving away from

00:10:53,850 --> 00:11:00,300
Windows you know all these very tightly

00:10:57,660 --> 00:11:03,570
coupled Windows applications so now we

00:11:00,300 --> 00:11:04,680
have the ability to run part of an

00:11:03,570 --> 00:11:07,620
application in a micro so

00:11:04,680 --> 00:11:10,320
on deck or on Linux and part of that

00:11:07,620 --> 00:11:12,870
application on the.net desktop CLR on

00:11:10,320 --> 00:11:16,560
Windows and so that's kind of this dream

00:11:12,870 --> 00:11:18,240
realized with with micro-services and

00:11:16,560 --> 00:11:20,880
then you can always scale these

00:11:18,240 --> 00:11:23,130
components up individually and so say

00:11:20,880 --> 00:11:25,200
you're expecting a lot of people to go

00:11:23,130 --> 00:11:27,600
to your homepage and you want to have

00:11:25,200 --> 00:11:28,860
high throughput there but maybe not

00:11:27,600 --> 00:11:30,270
everybody's gonna turn it into paying

00:11:28,860 --> 00:11:32,010
customers and go through your shopping

00:11:30,270 --> 00:11:33,870
cart rate so you can kind of scale every

00:11:32,010 --> 00:11:35,370
component separately and will actually

00:11:33,870 --> 00:11:39,779
show you that in the demo a little bit

00:11:35,370 --> 00:11:42,300
later but microservices are hard and

00:11:39,779 --> 00:11:44,820
this is a great tweet that kind of

00:11:42,300 --> 00:11:46,680
captured that we replaced our monolith

00:11:44,820 --> 00:11:48,630
with microservices so that every outage

00:11:46,680 --> 00:11:51,959
can be more like a murder mystery and

00:11:48,630 --> 00:11:53,880
that's true right micro services at our

00:11:51,959 --> 00:11:55,680
distributed system so you're taking this

00:11:53,880 --> 00:11:57,540
thing that was a monolith and that had

00:11:55,680 --> 00:11:59,220
his own problem so we're hard to reason

00:11:57,540 --> 00:12:02,310
about and hard to work on that codebase

00:11:59,220 --> 00:12:02,970
and now you broke it down and up he's a

00:12:02,310 --> 00:12:05,040
look about

00:12:02,970 --> 00:12:07,230
reason about hopefully a little bit

00:12:05,040 --> 00:12:11,490
harder or less hard to reason about on

00:12:07,230 --> 00:12:13,770
their own like what is going on here and

00:12:11,490 --> 00:12:16,230
so how do you troubleshoot these micro

00:12:13,770 --> 00:12:18,270
services and they all come together how

00:12:16,230 --> 00:12:19,709
do you set configuration across all

00:12:18,270 --> 00:12:22,200
those applications in a consistent

00:12:19,709 --> 00:12:24,930
manner we mentioned with the 12 factor

00:12:22,200 --> 00:12:27,060
you're not supposed to be variables into

00:12:24,930 --> 00:12:30,690
your code so now how do you distribute

00:12:27,060 --> 00:12:34,140
those variables through how do you look

00:12:30,690 --> 00:12:35,940
up addresses as you consume there are

00:12:34,140 --> 00:12:39,000
things like constant their service

00:12:35,940 --> 00:12:42,540
discovery mechanisms but you're gonna

00:12:39,000 --> 00:12:44,279
need a way to say you're running a new

00:12:42,540 --> 00:12:45,779
sixth or which is what we'll demo today

00:12:44,279 --> 00:12:47,100
you got a front-end that's going to talk

00:12:45,779 --> 00:12:49,980
to a back-end how do you find those

00:12:47,100 --> 00:12:53,670
services right and what do you do when

00:12:49,980 --> 00:12:55,770
one of those services goes down so your

00:12:53,670 --> 00:12:57,810
back-end inevitably is gonna go down at

00:12:55,770 --> 00:13:00,329
some point and is your application gonna

00:12:57,810 --> 00:13:03,899
throw a 500 error when that happens you

00:13:00,329 --> 00:13:06,300
don't want that so the good news is

00:13:03,899 --> 00:13:09,209
Netflix solved a lot of these problems

00:13:06,300 --> 00:13:11,940
for us or in the spring community Java

00:13:09,209 --> 00:13:14,210
with their Netflix SAS initiative and so

00:13:11,940 --> 00:13:17,300
they worked on

00:13:14,210 --> 00:13:20,210
Yuriko service discovered the historic

00:13:17,300 --> 00:13:22,390
s-- circuit breaker and released a lot

00:13:20,210 --> 00:13:26,300
of this as open source software and

00:13:22,390 --> 00:13:28,310
pivotal has been working on kind of

00:13:26,300 --> 00:13:31,010
continuing that and since netflix has

00:13:28,310 --> 00:13:35,029
moved on to other fun and exciting new

00:13:31,010 --> 00:13:40,430
buggies and and we actually then were

00:13:35,029 --> 00:13:42,589
able to take some of that back to net so

00:13:40,430 --> 00:13:44,200
that's why you built still tool to help

00:13:42,589 --> 00:13:46,730
you build

00:13:44,200 --> 00:13:49,459
net applications and leverage spring

00:13:46,730 --> 00:13:52,310
cloud tooling billion micro services

00:13:49,459 --> 00:13:57,320
check out all buzzwords you really want

00:13:52,310 --> 00:13:58,180
to use steel-toe so Zack tell us what's

00:13:57,320 --> 00:14:02,600
inside the box

00:13:58,180 --> 00:14:04,550
okay so what's in Steel Toe we heard

00:14:02,600 --> 00:14:08,870
about what Steel Toe is we heard about

00:14:04,550 --> 00:14:11,660
why we built it let's take a look so I

00:14:08,870 --> 00:14:13,550
think the libraries that make up Steel

00:14:11,660 --> 00:14:16,520
Toe roughly fall into two categories the

00:14:13,550 --> 00:14:19,459
first are things that help support you

00:14:16,520 --> 00:14:21,380
do cloud native net especially run

00:14:19,459 --> 00:14:24,770
dotnet applications on Cloud Foundry and

00:14:21,380 --> 00:14:27,800
so the the first in that group of things

00:14:24,770 --> 00:14:29,720
are connectors so we have these built-in

00:14:27,800 --> 00:14:33,850
connectors that help you automatically

00:14:29,720 --> 00:14:37,339
wire up your connection to come in

00:14:33,850 --> 00:14:41,570
backing data services for example MySQL

00:14:37,339 --> 00:14:43,970
Postgres RabbitMQ and even oweth so the

00:14:41,570 --> 00:14:46,370
way that these work is on Cloud Foundry

00:14:43,970 --> 00:14:49,040
you deploy an application and you bind a

00:14:46,370 --> 00:14:52,850
backing service to it so maybe it's a

00:14:49,040 --> 00:14:54,610
Redis database or a MySQL database the

00:14:52,850 --> 00:14:56,959
credentials for that application

00:14:54,610 --> 00:15:00,140
effectively the connection string gets

00:14:56,959 --> 00:15:02,329
injected into the environment of the

00:15:00,140 --> 00:15:04,100
container where application will run so

00:15:02,329 --> 00:15:05,660
your application all it needs to know is

00:15:04,100 --> 00:15:08,089
where to look for that information

00:15:05,660 --> 00:15:13,820
so steel-toe just wires all those up

00:15:08,089 --> 00:15:16,970
automatically next steel-toe provides

00:15:13,820 --> 00:15:21,350
some security providers so there's an

00:15:16,970 --> 00:15:25,339
OAuth 2 SSO provider there is a provider

00:15:21,350 --> 00:15:28,279
for JWT resource protection so for

00:15:25,339 --> 00:15:30,829
example if you want to use a JWT token

00:15:28,279 --> 00:15:33,350
in order to access a secured rest

00:15:30,829 --> 00:15:35,360
endpoint and in addition to those to

00:15:33,350 --> 00:15:37,250
steel-toe also makes available an

00:15:35,360 --> 00:15:39,860
additional security provider which

00:15:37,250 --> 00:15:42,380
allows you to easily use a Cloud Foundry

00:15:39,860 --> 00:15:46,579
based Redis instance if you are

00:15:42,380 --> 00:15:49,480
leveraging the asp.net core there's a

00:15:46,579 --> 00:15:51,680
keyring store in asp.net core security

00:15:49,480 --> 00:15:53,930
there's data protection it's called

00:15:51,680 --> 00:15:55,610
asp.net core data protection and the

00:15:53,930 --> 00:15:58,370
problem is the way that it's built by

00:15:55,610 --> 00:16:00,380
default it writes your keys to disk

00:15:58,370 --> 00:16:02,420
which is not a very cloud friendly or

00:16:00,380 --> 00:16:04,970
cloud native pattern so what we've done

00:16:02,420 --> 00:16:09,889
is extend it so that all those keys are

00:16:04,970 --> 00:16:11,540
written to a Redis backing store alright

00:16:09,889 --> 00:16:13,579
and this is another really cool thing

00:16:11,540 --> 00:16:16,699
that's part of so and we'll demo it

00:16:13,579 --> 00:16:19,519
today there are management endpoints so

00:16:16,699 --> 00:16:21,589
it's fired by a spring project called

00:16:19,519 --> 00:16:23,139
spring boot actuator if anybody's a Java

00:16:21,589 --> 00:16:26,690
developer you might have heard of it

00:16:23,139 --> 00:16:28,639
there are these endpoints that end up

00:16:26,690 --> 00:16:30,529
decorating your application

00:16:28,639 --> 00:16:31,970
that can help you manage it maybe your

00:16:30,529 --> 00:16:33,800
application or your micro service is

00:16:31,970 --> 00:16:36,110
running in production and you want to

00:16:33,800 --> 00:16:37,430
get some information from it to help

00:16:36,110 --> 00:16:39,949
troubleshoot some problem that you're

00:16:37,430 --> 00:16:42,199
having but you're limited to what you

00:16:39,949 --> 00:16:45,829
can do in terms of how invasive you can

00:16:42,199 --> 00:16:47,779
be in your poking around so what this

00:16:45,829 --> 00:16:49,610
library does is you bind to this library

00:16:47,779 --> 00:16:51,019
and it automatically ornaments your

00:16:49,610 --> 00:16:54,079
application with these endpoints and

00:16:51,019 --> 00:16:56,240
they are things like info so this info

00:16:54,079 --> 00:16:59,329
endpoint it returns application

00:16:56,240 --> 00:17:02,510
information which could include say the

00:16:59,329 --> 00:17:05,089
exact git commit that the running

00:17:02,510 --> 00:17:06,589
application code corresponds to so if

00:17:05,089 --> 00:17:09,530
you're an operator you're trying to

00:17:06,589 --> 00:17:10,429
troubleshoot an application knowing what

00:17:09,530 --> 00:17:13,790
the source code for that application

00:17:10,429 --> 00:17:16,040
looks like is very helpful there's a

00:17:13,790 --> 00:17:17,260
health endpoint that returns some health

00:17:16,040 --> 00:17:20,449
information about your application

00:17:17,260 --> 00:17:24,439
there's a trace endpoint that is a

00:17:20,449 --> 00:17:27,319
circularbuffer of the last 100 HTTP

00:17:24,439 --> 00:17:29,960
requests and responses so very powerful

00:17:27,319 --> 00:17:32,330
very useful tool right there and then

00:17:29,960 --> 00:17:35,630
lastly this is my favorite loggers

00:17:32,330 --> 00:17:38,210
allows you to dynamically configure and

00:17:35,630 --> 00:17:41,240
this is on your running application the

00:17:38,210 --> 00:17:44,480
logging level all the way down

00:17:41,240 --> 00:17:47,150
to the class level and you can do that

00:17:44,480 --> 00:17:48,770
on an application instance basis so if

00:17:47,150 --> 00:17:50,420
your app is running at horizontal scale

00:17:48,770 --> 00:17:53,120
and you've got one instance that keeps

00:17:50,420 --> 00:17:57,230
crashing you can drill into it and find

00:17:53,120 --> 00:17:59,750
out exactly why all right so those are

00:17:57,230 --> 00:18:02,360
the management end points we've also got

00:17:59,750 --> 00:18:04,580
some configuration providers there's a

00:18:02,360 --> 00:18:06,679
configuration API provided by dotnet

00:18:04,580 --> 00:18:08,929
which enables you to pull values out of

00:18:06,679 --> 00:18:10,970
different sources and then access them

00:18:08,929 --> 00:18:13,910
from within your application in this

00:18:10,970 --> 00:18:17,270
form of a hierarchical configuration

00:18:13,910 --> 00:18:19,820
dictionary if you will and so they each

00:18:17,270 --> 00:18:21,650
of these providers supports reading a

00:18:19,820 --> 00:18:24,170
set of key value pairs from different

00:18:21,650 --> 00:18:27,650
sources so it might be from file sources

00:18:24,170 --> 00:18:31,400
like JSON files or XML files or it's

00:18:27,650 --> 00:18:33,830
Microsoft so ini files they're our

00:18:31,400 --> 00:18:36,410
environment variables or command-line

00:18:33,830 --> 00:18:39,290
arguments but they also have a structure

00:18:36,410 --> 00:18:41,179
for creating custom configu providers so

00:18:39,290 --> 00:18:43,220
steel-toe provides two custom

00:18:41,179 --> 00:18:45,710
configuration providers the first one is

00:18:43,220 --> 00:18:48,950
called Cloud Foundry and I talked about

00:18:45,710 --> 00:18:49,940
this environment variable that's a set

00:18:48,950 --> 00:18:51,800
of environment variables that are

00:18:49,940 --> 00:18:54,140
available inside of your application

00:18:51,800 --> 00:18:56,809
container so this will read all of those

00:18:54,140 --> 00:18:59,750
into your configuration dictionary and

00:18:56,809 --> 00:19:01,730
then the second one is config server so

00:18:59,750 --> 00:19:04,700
it has anyone here heard of spring cloud

00:19:01,730 --> 00:19:06,500
config server spring cloud can fix

00:19:04,700 --> 00:19:08,510
server is an implementation of the

00:19:06,500 --> 00:19:09,679
shared configuration pattern it pulls

00:19:08,510 --> 00:19:11,960
your configuration out of your

00:19:09,679 --> 00:19:13,610
application and then you can read it

00:19:11,960 --> 00:19:16,100
into your application across a bunch of

00:19:13,610 --> 00:19:17,059
different environments you can have

00:19:16,100 --> 00:19:20,090
different config for different

00:19:17,059 --> 00:19:22,730
environments etc and it writes all of

00:19:20,090 --> 00:19:25,070
that data or stores it in a repo it

00:19:22,730 --> 00:19:26,630
could be a git repo which gives you the

00:19:25,070 --> 00:19:29,480
advantage that you have full

00:19:26,630 --> 00:19:31,730
traceability to who made changes when or

00:19:29,480 --> 00:19:33,650
you can back it by a vault if you want

00:19:31,730 --> 00:19:35,679
to store connection strings in there and

00:19:33,650 --> 00:19:39,620
I think I've got a slide that shows

00:19:35,679 --> 00:19:41,420
roughly how it works so somebody on the

00:19:39,620 --> 00:19:43,250
far left side there updates

00:19:41,420 --> 00:19:45,740
configuration in the repo and these are

00:19:43,250 --> 00:19:48,440
like gamal files they're like JSON files

00:19:45,740 --> 00:19:51,440
and then your applications come online

00:19:48,440 --> 00:19:53,330
app app AFB up see and they pull the

00:19:51,440 --> 00:19:54,650
config from the config server which

00:19:53,330 --> 00:19:57,560
is out to that repo and pulls it in

00:19:54,650 --> 00:19:59,720
dynamically so the cool part is there's

00:19:57,560 --> 00:20:02,230
an end point for each application that

00:19:59,720 --> 00:20:04,250
you can hit that will refresh that that

00:20:02,230 --> 00:20:05,480
configuration while the application is

00:20:04,250 --> 00:20:07,520
running you don't have to stop and

00:20:05,480 --> 00:20:11,120
restart it you don't have to reap it or

00:20:07,520 --> 00:20:12,950
something like that so it's you know

00:20:11,120 --> 00:20:15,860
gives you the ability to to dynamically

00:20:12,950 --> 00:20:17,780
refresh that configuration it's also got

00:20:15,860 --> 00:20:19,370
the built-in ability to change that

00:20:17,780 --> 00:20:21,800
configuration in different environments

00:20:19,370 --> 00:20:24,170
and even override it as you move from

00:20:21,800 --> 00:20:28,540
say running on your local machine to

00:20:24,170 --> 00:20:28,540
running on Cloud Foundry or in the cloud

00:20:29,230 --> 00:20:34,310
alright resilient micro-services meant

00:20:31,820 --> 00:20:36,830
you want to talk us through the sharika

00:20:34,310 --> 00:20:40,960
yeah one of those other components that

00:20:36,830 --> 00:20:44,210
came from the Netflix OSS community is

00:20:40,960 --> 00:20:47,150
Eureka and so Eureka is service

00:20:44,210 --> 00:20:50,680
discovery sort of like console except

00:20:47,150 --> 00:20:53,590
instead of using DNS like console does

00:20:50,680 --> 00:20:56,060
Eureka actually has its own internal

00:20:53,590 --> 00:20:58,030
mechanism for doing lookup and so

00:20:56,060 --> 00:21:03,260
everyone who implements this Eureka

00:20:58,030 --> 00:21:05,210
pattern has to run has to run the Eureka

00:21:03,260 --> 00:21:07,010
code and there is actually a Eureka

00:21:05,210 --> 00:21:09,980
server that runs somewhere the service

00:21:07,010 --> 00:21:11,780
registry with quad foundry this can be

00:21:09,980 --> 00:21:14,480
provided to you via the spring cloud

00:21:11,780 --> 00:21:17,660
services or you can just run this server

00:21:14,480 --> 00:21:20,360
by itself it's just it's actually a java

00:21:17,660 --> 00:21:22,100
application that just stands up and so

00:21:20,360 --> 00:21:24,140
applications when they come online

00:21:22,100 --> 00:21:26,210
register themselves with the service

00:21:24,140 --> 00:21:29,060
registry and then somebody who needs to

00:21:26,210 --> 00:21:31,220
consume something something from the

00:21:29,060 --> 00:21:32,930
environment and maybe you're talking

00:21:31,220 --> 00:21:35,210
about the music stores so maybe there's

00:21:32,930 --> 00:21:38,360
a database that front-end needs to reach

00:21:35,210 --> 00:21:41,000
out to and it can look up the address of

00:21:38,360 --> 00:21:45,170
that database via the service registry

00:21:41,000 --> 00:21:48,250
and so this this server already exists

00:21:45,170 --> 00:21:52,100
it's part of that open source Eureka

00:21:48,250 --> 00:21:55,040
community and the steel-toe library

00:21:52,100 --> 00:21:57,320
includes a client that allows you to

00:21:55,040 --> 00:22:00,170
both register producers as they're

00:21:57,320 --> 00:22:02,720
called and also register consumers that

00:22:00,170 --> 00:22:04,760
can look up those producers and so this

00:22:02,720 --> 00:22:06,800
solves that how do I find service a

00:22:04,760 --> 00:22:09,200
service B service C

00:22:06,800 --> 00:22:11,990
it doesn't require using DNS or anything

00:22:09,200 --> 00:22:14,090
like that it just uses this Eureka

00:22:11,990 --> 00:22:18,380
client and the great thing is it hooks

00:22:14,090 --> 00:22:20,720
right into the standard dotnet HTTP

00:22:18,380 --> 00:22:22,820
library so there's nothing crazy you

00:22:20,720 --> 00:22:29,210
have to do here to integrate with Eureka

00:22:22,820 --> 00:22:31,250
you just plug it in and and it works we

00:22:29,210 --> 00:22:34,250
took a little circuit breaker pattern so

00:22:31,250 --> 00:22:37,160
this implementation in Steel Toe comes

00:22:34,250 --> 00:22:39,260
from Netflix history and so the circuit

00:22:37,160 --> 00:22:42,260
breaker pattern I'll talk about a bit on

00:22:39,260 --> 00:22:46,370
the next next slide but this allows you

00:22:42,260 --> 00:22:48,290
to bypass those failing services instead

00:22:46,370 --> 00:22:50,240
of flowing up the page or the 500 error

00:22:48,290 --> 00:22:53,030
and having a terrible experience you can

00:22:50,240 --> 00:22:55,610
have this nice graceful degradation you

00:22:53,030 --> 00:22:58,460
also get this rich metrics and

00:22:55,610 --> 00:23:00,260
monitoring experience this Netflix

00:22:58,460 --> 00:23:01,700
already built this beautiful dashboard

00:23:00,260 --> 00:23:04,040
for looking at this information

00:23:01,700 --> 00:23:05,930
the steel-toe library implements the

00:23:04,040 --> 00:23:09,890
pattern and then streams back all those

00:23:05,930 --> 00:23:12,010
metrics to the history dashboard so the

00:23:09,890 --> 00:23:15,190
actual pattern looks a bit like this

00:23:12,010 --> 00:23:19,190
when the circuit breaker is closed all

00:23:15,190 --> 00:23:21,410
calls to an API just passed through when

00:23:19,190 --> 00:23:24,590
they succeed it resets a counter in an

00:23:21,410 --> 00:23:27,800
error counter when it fails it

00:23:24,590 --> 00:23:30,740
increments a counter and when a

00:23:27,800 --> 00:23:34,160
threshold is met it trips the circuit

00:23:30,740 --> 00:23:36,530
breaker and no longer passes traffic to

00:23:34,160 --> 00:23:38,810
that broken API so then you can put a

00:23:36,530 --> 00:23:40,640
nice error page in there or you know

00:23:38,810 --> 00:23:42,890
maybe fall over to a different API or

00:23:40,640 --> 00:23:46,100
give a different user experience while

00:23:42,890 --> 00:23:49,240
that back-end service is recovering when

00:23:46,100 --> 00:23:51,740
the circuit breaker is open we'll be

00:23:49,240 --> 00:23:53,660
keeping track of that fail count and

00:23:51,740 --> 00:23:56,900
seeing to continue see if that fail

00:23:53,660 --> 00:24:00,110
count continues to go up if if it starts

00:23:56,900 --> 00:24:03,050
to succeed we enter this half open state

00:24:00,110 --> 00:24:04,820
and begin doing check to see if that

00:24:03,050 --> 00:24:06,650
service is actually alive and we

00:24:04,820 --> 00:24:08,360
determined it is alive we reset the

00:24:06,650 --> 00:24:10,670
circuit breaker and start this process

00:24:08,360 --> 00:24:13,040
over again and so all this is is

00:24:10,670 --> 00:24:15,770
provided in the steel-toe library by a

00:24:13,040 --> 00:24:18,419
history implementation and it streams

00:24:15,770 --> 00:24:25,379
all that data back to the

00:24:18,419 --> 00:24:27,989
History X dashboard so steel-toe is open

00:24:25,379 --> 00:24:30,989
and flexible it works with dotnet core

00:24:27,989 --> 00:24:33,690
and the dotnet framework it works on

00:24:30,989 --> 00:24:39,090
Windows and Linux and it works

00:24:33,690 --> 00:24:40,429
standalone and on Cloud Foundry so I

00:24:39,090 --> 00:24:43,619
just wanted to follow that up by saying

00:24:40,429 --> 00:24:46,710
there's no other dotnet library that I

00:24:43,619 --> 00:24:49,320
know of that allows you to access the

00:24:46,710 --> 00:24:52,679
Eureka service discovery server from

00:24:49,320 --> 00:24:54,239
Netflix there are other circuit breakers

00:24:52,679 --> 00:24:57,269
out there but none of them have this

00:24:54,239 --> 00:24:58,859
rich history dashboard and all the

00:24:57,269 --> 00:25:00,929
metrics that get emitted so there's some

00:24:58,859 --> 00:25:04,080
some really cool unique value here in in

00:25:00,929 --> 00:25:05,399
steel-toe all right well you've heard us

00:25:04,080 --> 00:25:07,080
talk about Cloud Foundry a bunch of

00:25:05,399 --> 00:25:09,299
times but in case you're not sure

00:25:07,080 --> 00:25:11,549
exactly what it is then let me tell you

00:25:09,299 --> 00:25:14,129
a little bit about it I have this great

00:25:11,549 --> 00:25:15,539
diagram here which was very obviously

00:25:14,129 --> 00:25:17,730
created by somebody who works in

00:25:15,539 --> 00:25:20,039
marketing and not somebody who's on the

00:25:17,730 --> 00:25:22,590
architecture team I heard a great quote

00:25:20,039 --> 00:25:24,389
at a conference earlier this year where

00:25:22,590 --> 00:25:26,190
somebody said this diagram what I

00:25:24,389 --> 00:25:27,779
recommend you do is print it out and

00:25:26,190 --> 00:25:30,869
then you can use the back of that page

00:25:27,779 --> 00:25:33,419
to write your notes on and so this this

00:25:30,869 --> 00:25:35,460
might fall into that category so Cloud

00:25:33,419 --> 00:25:37,350
Foundry is a pass it's a platform as a

00:25:35,460 --> 00:25:40,019
service that you can deploy applications

00:25:37,350 --> 00:25:42,749
to and then as a developer you have to

00:25:40,019 --> 00:25:45,239
worry very very little about packaging

00:25:42,749 --> 00:25:47,669
that application up Cloud Foundry is

00:25:45,239 --> 00:25:50,159
very flexible it runs on a variety of

00:25:47,669 --> 00:25:52,350
different cloud infrastructures you've

00:25:50,159 --> 00:25:53,820
got all the major public clouds you can

00:25:52,350 --> 00:25:57,179
run it in your private data center on

00:25:53,820 --> 00:25:59,489
top of VMware or OpenStack and it does

00:25:57,179 --> 00:26:01,169
that by virtue of an infrastructure

00:25:59,489 --> 00:26:04,139
orchestration and management layer

00:26:01,169 --> 00:26:05,820
called Bosh it creates all the VMS it

00:26:04,139 --> 00:26:08,100
creates all the networks and all the

00:26:05,820 --> 00:26:09,570
things in between and then it's got

00:26:08,100 --> 00:26:12,749
health management to make sure that they

00:26:09,570 --> 00:26:14,879
stay alive so then on top of that it's

00:26:12,749 --> 00:26:16,919
got Cloud Foundry uses a build pack a

00:26:14,879 --> 00:26:19,590
construct if you're familiar with Heroku

00:26:16,919 --> 00:26:21,200
build packs for example they take a look

00:26:19,590 --> 00:26:23,070
at your application source code

00:26:21,200 --> 00:26:25,769
determine what language it is

00:26:23,070 --> 00:26:28,200
and then automatically assume

00:26:25,769 --> 00:26:29,519
automatically assemble all of the things

00:26:28,200 --> 00:26:30,149
you need to run your application your

00:26:29,519 --> 00:26:32,369
application

00:26:30,149 --> 00:26:34,619
time if there's a if it's Java you'll

00:26:32,369 --> 00:26:37,649
need a JVM and some sort of an

00:26:34,619 --> 00:26:39,839
application server for example and then

00:26:37,649 --> 00:26:41,389
all of the dependencies that your

00:26:39,839 --> 00:26:44,639
application has it pulls it all together

00:26:41,389 --> 00:26:46,379
bundles it up into a package deploys it

00:26:44,639 --> 00:26:48,149
into a container and then schedules that

00:26:46,379 --> 00:26:51,119
container somewhere running on a

00:26:48,149 --> 00:26:53,069
container host VM and and then your

00:26:51,119 --> 00:26:54,509
application is health managed it's got

00:26:53,069 --> 00:26:57,929
integrated logging and all sorts of

00:26:54,509 --> 00:27:01,409
other cool stuff so today in our demo we

00:26:57,929 --> 00:27:03,269
will show you an application it's made

00:27:01,409 --> 00:27:07,049
up of a bunch of micro services running

00:27:03,269 --> 00:27:09,719
on Cloud Foundry it'll be running on PWS

00:27:07,049 --> 00:27:13,679
pivotal web service services so that's

00:27:09,719 --> 00:27:16,169
pivotal x' multi-tenant public instance

00:27:13,679 --> 00:27:17,939
of Cloud Foundry it's actually you know

00:27:16,169 --> 00:27:20,129
60 days free if you want to sign up you

00:27:17,939 --> 00:27:23,099
can run applications there try it out

00:27:20,129 --> 00:27:28,409
and so with that why don't we go ahead

00:27:23,099 --> 00:27:30,329
and dive into the demo cool live demos

00:27:28,409 --> 00:27:38,579
are always a little risky but let's see

00:27:30,329 --> 00:27:41,159
how this goes so over here there is a

00:27:38,579 --> 00:27:43,319
slide that looks at your micro services

00:27:41,159 --> 00:27:45,919
architecture if you want to show it

00:27:43,319 --> 00:27:45,919
before

00:27:53,710 --> 00:27:59,179
so here's a quick overview of the actual

00:27:56,720 --> 00:27:59,750
architecture here is the front end user

00:27:59,179 --> 00:28:04,159
Qi

00:27:59,750 --> 00:28:07,510
app there's a back end store service

00:28:04,159 --> 00:28:10,039
Abeka and shopping service in the back

00:28:07,510 --> 00:28:11,780
each of those services are independent

00:28:10,039 --> 00:28:14,510
they all have their own backing store in

00:28:11,780 --> 00:28:18,230
my sequel and the music UI also has a

00:28:14,510 --> 00:28:20,150
front end Redis store and we use that

00:28:18,230 --> 00:28:21,679
for a session cache so once you log into

00:28:20,150 --> 00:28:23,690
the site it keeps you logged in right

00:28:21,679 --> 00:28:26,299
there's no instance pinning for any

00:28:23,690 --> 00:28:29,450
inbound connections it's all just doing

00:28:26,299 --> 00:28:31,760
that transparently and this is sort of a

00:28:29,450 --> 00:28:33,590
standard net reference application

00:28:31,760 --> 00:28:35,179
that's out there the Music Store and

00:28:33,590 --> 00:28:37,039
what we've done is taken it and we've

00:28:35,179 --> 00:28:38,750
just replaced some of the components

00:28:37,039 --> 00:28:40,250
with some of the patterns so in between

00:28:38,750 --> 00:28:43,580
those different micro-services calls

00:28:40,250 --> 00:28:45,159
their circuit breakers Eureka is used to

00:28:43,580 --> 00:28:47,179
look up the location of those services

00:28:45,159 --> 00:28:51,830
configuration all comes from the spring

00:28:47,179 --> 00:28:54,049
cloud config server etc yeah and so this

00:28:51,830 --> 00:29:00,880
this front-end app is just that music UI

00:28:54,049 --> 00:29:00,880
I'm gonna log in just for fun maybe

00:29:08,500 --> 00:29:13,059
and so here this front end is just

00:29:11,049 --> 00:29:17,039
accessing that back end music store

00:29:13,059 --> 00:29:19,480
service the front end is using the

00:29:17,039 --> 00:29:21,100
eureka service discovery to go and find

00:29:19,480 --> 00:29:24,280
that service the application code

00:29:21,100 --> 00:29:25,780
doesn't have hard-coded IP addresses for

00:29:24,280 --> 00:29:28,510
that service in it it just has a

00:29:25,780 --> 00:29:30,880
reference in there and then the eureka

00:29:28,510 --> 00:29:33,610
service government has those services

00:29:30,880 --> 00:29:35,950
registered with it and will turn the IP

00:29:33,610 --> 00:29:39,280
address for those services that the

00:29:35,950 --> 00:29:42,909
front end can go and find it when I go

00:29:39,280 --> 00:29:44,590
to add something to my cart the front

00:29:42,909 --> 00:29:48,070
end actually reaches out to a second

00:29:44,590 --> 00:29:50,350
back-end service the order service and

00:29:48,070 --> 00:29:52,240
or is it sorry the shopping cart service

00:29:50,350 --> 00:29:53,919
and adds this the shopping cart and so

00:29:52,240 --> 00:29:55,990
when I view my shopping cart this

00:29:53,919 --> 00:29:58,320
actually reads from that second service

00:29:55,990 --> 00:30:01,809
right and then if I continue this

00:29:58,320 --> 00:30:04,809
process here check out this is actually

00:30:01,809 --> 00:30:06,610
that third service the checkout service

00:30:04,809 --> 00:30:09,520
right and if I were to fill this hole

00:30:06,610 --> 00:30:11,860
for this would submit back to this

00:30:09,520 --> 00:30:14,380
back-end service and I enter my promo

00:30:11,860 --> 00:30:18,070
code free and it it'll process this

00:30:14,380 --> 00:30:19,600
order for me but the interesting thing

00:30:18,070 --> 00:30:20,950
to show you here is you know what's

00:30:19,600 --> 00:30:23,650
what's happening here on the front end

00:30:20,950 --> 00:30:26,620
versus those back-end services and so

00:30:23,650 --> 00:30:29,799
this is the quad foundry application

00:30:26,620 --> 00:30:31,659
manager console here you can see all the

00:30:29,799 --> 00:30:35,350
applications that are running here and

00:30:31,659 --> 00:30:37,809
bump up the font size of it we've got

00:30:35,350 --> 00:30:39,909
that front end music UI service and the

00:30:37,809 --> 00:30:43,000
back end music store order processing

00:30:39,909 --> 00:30:45,130
and shopping cart services and you see

00:30:43,000 --> 00:30:48,760
here I actually have these two instances

00:30:45,130 --> 00:30:51,390
of the music store UI and when I

00:30:48,760 --> 00:30:54,669
mentioned the the bit about that session

00:30:51,390 --> 00:30:56,980
is when I reload this page right I don't

00:30:54,669 --> 00:30:59,830
want to be logged out and so having that

00:30:56,980 --> 00:31:02,080
session store work is kind of what makes

00:30:59,830 --> 00:31:05,350
this whole page work but the other thing

00:31:02,080 --> 00:31:08,230
that we mentioned was those spring cloud

00:31:05,350 --> 00:31:11,140
actuators and so you'll notice a little

00:31:08,230 --> 00:31:14,559
difference here between this page and

00:31:11,140 --> 00:31:16,360
this page here it just says music UI

00:31:14,559 --> 00:31:18,280
it's a regular app over here it shows

00:31:16,360 --> 00:31:19,960
the number of instances I have and some

00:31:18,280 --> 00:31:22,279
high-level information about my

00:31:19,960 --> 00:31:25,849
application but it's not super you

00:31:22,279 --> 00:31:30,499
pull over here when I click on the music

00:31:25,849 --> 00:31:32,599
store instance I get this little icon up

00:31:30,499 --> 00:31:34,580
here which is actually for spring

00:31:32,599 --> 00:31:36,679
applications but it what it means is

00:31:34,580 --> 00:31:40,460
we've actually implemented the actuators

00:31:36,679 --> 00:31:41,719
API and so when I go to my instances

00:31:40,460 --> 00:31:44,960
over here I can click this little arrow

00:31:41,719 --> 00:31:47,210
and get this additional detail about my

00:31:44,960 --> 00:31:49,849
application so I can see what disk space

00:31:47,210 --> 00:31:52,299
is available on there and this doesn't

00:31:49,849 --> 00:31:54,589
just work on Cloud Foundry this works

00:31:52,299 --> 00:31:57,080
theoretically anywhere but it only has

00:31:54,589 --> 00:31:58,849
this integration here so this is a

00:31:57,080 --> 00:32:01,039
standard API for getting this

00:31:58,849 --> 00:32:02,989
information from your applications it's

00:32:01,039 --> 00:32:05,269
just an API endpoint that returns a JSON

00:32:02,989 --> 00:32:09,889
string and then our UI designers made it

00:32:05,269 --> 00:32:12,200
pretty in this application screen one of

00:32:09,889 --> 00:32:14,509
the other components of actuators is

00:32:12,200 --> 00:32:17,179
viewing the trace right so I can see

00:32:14,509 --> 00:32:19,999
everything that came in and out of those

00:32:17,179 --> 00:32:22,159
request headers here for for my

00:32:19,999 --> 00:32:24,279
application and so if I'm trying to

00:32:22,159 --> 00:32:28,399
debug some failure with my application

00:32:24,279 --> 00:32:30,679
here to console and and dig into that

00:32:28,399 --> 00:32:33,109
whenever somebody buys that one item

00:32:30,679 --> 00:32:35,330
tries to checkout with that it's that

00:32:33,109 --> 00:32:36,859
minute work CD I know it is right then

00:32:35,330 --> 00:32:39,019
that's the that's the thing that crashes

00:32:36,859 --> 00:32:40,429
it right so so this is that circular

00:32:39,019 --> 00:32:45,559
buffer that I mentioned earlier in the

00:32:40,429 --> 00:32:47,239
trace endpoint and if I if I was trying

00:32:45,559 --> 00:32:49,489
to debug something and I don't know what

00:32:47,239 --> 00:32:52,190
sort it is is pushed up to cloud foundry

00:32:49,489 --> 00:32:54,950
this is that info endpoint that returns

00:32:52,190 --> 00:32:57,080
the get sha and where that where that

00:32:54,950 --> 00:32:59,210
code came from right and so you can see

00:32:57,080 --> 00:33:01,399
oh this came from my laptop I pushed it

00:32:59,210 --> 00:33:04,460
up there last night this is the show

00:33:01,399 --> 00:33:09,259
that I pushed and now that can help us

00:33:04,460 --> 00:33:11,239
debug what's running and maybe I'm not

00:33:09,259 --> 00:33:12,859
getting enough verbosity or maybe I'm

00:33:11,239 --> 00:33:15,769
getting too much verbosity in my logs

00:33:12,859 --> 00:33:18,499
and so this is what Zack had mentioned

00:33:15,769 --> 00:33:21,229
you can actually with the live instances

00:33:18,499 --> 00:33:24,499
change the logging levels of this code

00:33:21,229 --> 00:33:28,279
that's running in production right and

00:33:24,499 --> 00:33:30,499
this actually ends a request to you back

00:33:28,279 --> 00:33:35,320
to my app so you need to be paying in a

00:33:30,499 --> 00:33:37,000
different way it's actually with so

00:33:35,320 --> 00:33:38,860
not anyone can hit these end points and

00:33:37,000 --> 00:33:40,870
change my application but it's tightly

00:33:38,860 --> 00:33:43,150
integrated with quad foundry and apps

00:33:40,870 --> 00:33:45,130
manager but it is a standard API under

00:33:43,150 --> 00:33:46,780
the hood and you can do that across your

00:33:45,130 --> 00:33:48,370
whole application or you can do that on

00:33:46,780 --> 00:33:49,570
an individual instance of your

00:33:48,370 --> 00:33:53,320
application if it's running at

00:33:49,570 --> 00:33:57,280
horizontal scale and one more thing we

00:33:53,320 --> 00:33:59,410
can do here yes I want to stop this

00:33:57,280 --> 00:34:00,190
music store instance and see what

00:33:59,410 --> 00:34:03,190
happens

00:34:00,190 --> 00:34:13,900
so my music UI instance is still running

00:34:03,190 --> 00:34:17,950
and so if I reload this homepage see did

00:34:13,900 --> 00:34:19,750
it actually stop it did actually stop

00:34:17,950 --> 00:34:21,669
and so this home page actually

00:34:19,750 --> 00:34:24,220
gracefully degraded and this is that

00:34:21,669 --> 00:34:26,410
History X pattern and that is it's not

00:34:24,220 --> 00:34:29,290
returning hundred here on the home page

00:34:26,410 --> 00:34:30,880
and now if I try to go around here it's

00:34:29,290 --> 00:34:35,620
not gonna work very well

00:34:30,880 --> 00:34:37,900
but it some of these responses in in

00:34:35,620 --> 00:34:39,520
that historic spatter right and so this

00:34:37,900 --> 00:34:41,740
is you know ultimately what you'd want

00:34:39,520 --> 00:34:43,210
to do with your application when you're

00:34:41,740 --> 00:34:46,650
building with micro-service is to make

00:34:43,210 --> 00:34:46,650
sure that it gracefully degrades

00:34:53,859 --> 00:35:01,310
all right all right well as we promised

00:34:58,160 --> 00:35:02,810
I would like to talk to you a little bit

00:35:01,310 --> 00:35:04,790
about where we're going next with Steel

00:35:02,810 --> 00:35:07,190
Toe and I'd love to hear from you if

00:35:04,790 --> 00:35:10,040
there are suggestions for where we

00:35:07,190 --> 00:35:13,490
should go next so the spring boot

00:35:10,040 --> 00:35:16,520
actuator project has a huge list of

00:35:13,490 --> 00:35:18,410
endpoints and there are quite a few out

00:35:16,520 --> 00:35:20,180
there but there's a couple really

00:35:18,410 --> 00:35:21,710
valuable ones that we haven't built yet

00:35:20,180 --> 00:35:23,270
that we want to get in there and they

00:35:21,710 --> 00:35:25,490
involve the ability to pull down a

00:35:23,270 --> 00:35:27,440
thread dump or a heap dump from your

00:35:25,490 --> 00:35:29,420
running application so that's cool

00:35:27,440 --> 00:35:31,579
that's something that's coming soon

00:35:29,420 --> 00:35:34,099
Netflix ribbon is probably the next

00:35:31,579 --> 00:35:36,619
Netflix project that will pull in it

00:35:34,099 --> 00:35:40,220
provides you a client-side load balancer

00:35:36,619 --> 00:35:42,890
plugin so that you can load balance from

00:35:40,220 --> 00:35:46,069
your calling application across all

00:35:42,890 --> 00:35:49,220
those you know if you're using Eureka to

00:35:46,069 --> 00:35:51,050
reach out to provider micro services and

00:35:49,220 --> 00:35:54,050
you want to consume them you pull down a

00:35:51,050 --> 00:35:56,240
list and it might be a list of you know

00:35:54,050 --> 00:35:58,130
some number a dozen instances of that

00:35:56,240 --> 00:36:00,950
application running at scale well how do

00:35:58,130 --> 00:36:03,079
you load balance in between them so

00:36:00,950 --> 00:36:05,089
ribbon provides a whole bunch of

00:36:03,079 --> 00:36:07,579
pluggable load balancing algorithms that

00:36:05,089 --> 00:36:11,000
you can use to to bring your own if you

00:36:07,579 --> 00:36:14,150
will and then lastly distributed tracing

00:36:11,000 --> 00:36:16,250
with Zipkin Fernet so you heard about

00:36:14,150 --> 00:36:18,140
the murder mystery that can be

00:36:16,250 --> 00:36:20,990
troubleshooting your micro services and

00:36:18,140 --> 00:36:23,030
production so Zipkin helps you do

00:36:20,990 --> 00:36:24,829
distributed tracing so you can look at

00:36:23,030 --> 00:36:27,440
that call stack as it goes from micro

00:36:24,829 --> 00:36:29,359
service to micro service anything else

00:36:27,440 --> 00:36:34,450
that that you're you're burning to see

00:36:29,359 --> 00:36:34,450
in here anyone anyone

00:36:36,420 --> 00:36:41,170
Prometheus endpoints is a good idea we

00:36:39,550 --> 00:36:42,490
haven't we haven't thought a whole lot

00:36:41,170 --> 00:36:43,390
about it but it's definitely something

00:36:42,490 --> 00:36:45,310
that's possible

00:36:43,390 --> 00:36:46,960
I know there's there's a lot of

00:36:45,310 --> 00:36:52,599
integration with Prometheus and Cloud

00:36:46,960 --> 00:36:56,440
Foundry all right so how do you get

00:36:52,599 --> 00:36:59,440
started these slides are available on on

00:36:56,440 --> 00:37:01,030
the website for the conference you can

00:36:59,440 --> 00:37:05,290
pull them down got links here to our

00:37:01,030 --> 00:37:08,050
website github repo our nougat feed as

00:37:05,290 --> 00:37:09,790
well as we've got a slack channel it's

00:37:08,050 --> 00:37:11,619
public you can register yourself and

00:37:09,790 --> 00:37:12,820
join and ask questions directly to the

00:37:11,619 --> 00:37:17,500
engineers that are building this stuff

00:37:12,820 --> 00:37:19,420
and then lastly other resources I wanted

00:37:17,500 --> 00:37:21,940
to at least plug we've got a two day

00:37:19,420 --> 00:37:23,710
training class coming up for folks who

00:37:21,940 --> 00:37:26,260
are building dotnet applications on

00:37:23,710 --> 00:37:27,579
cloud foundry it's in San Francisco

00:37:26,260 --> 00:37:31,740
during the spring one platform

00:37:27,579 --> 00:37:34,960
conference in early December and there's

00:37:31,740 --> 00:37:37,930
yeah it'll be a great class please

00:37:34,960 --> 00:37:39,670
please join if you'd like to dig in a

00:37:37,930 --> 00:37:42,040
little bit on your own here are a couple

00:37:39,670 --> 00:37:43,390
blog articles about some interesting

00:37:42,040 --> 00:37:47,290
things that people have done with Steel

00:37:43,390 --> 00:37:49,650
Toe so with that I think we're we're

00:37:47,290 --> 00:37:49,650
ready for questions

00:37:54,310 --> 00:38:00,730
any questions all right well in that

00:37:58,540 --> 00:38:02,460
case thank you very much for for coming

00:38:00,730 --> 00:38:06,949
to our talk

00:38:02,460 --> 00:38:06,949

YouTube URL: https://www.youtube.com/watch?v=qItci8lLgJw


