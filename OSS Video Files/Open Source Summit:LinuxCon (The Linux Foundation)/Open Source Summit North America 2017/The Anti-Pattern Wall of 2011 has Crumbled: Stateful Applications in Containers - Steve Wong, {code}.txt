Title: The Anti-Pattern Wall of 2011 has Crumbled: Stateful Applications in Containers - Steve Wong, {code}
Publication date: 2017-09-12
Playlist: Open Source Summit North America 2017
Description: 
	The Anti-Pattern Wall of 2011 has Crumbled: Stateful Applications in Containers - Steve Wong, {code}

The “12 factor app” was written in 2011 and became a widely cited classic of useful patterns for application architecture. #6 on the list said: apps shall be stateless.

There is some question as to whether this made sense even at the time it was written – some suggest it was simply declaring state to be someone else’s problem.

Containers have been rapidly evolving since – Docker was released 2 years later. In a rapidly advancing field, design patterns should be periodically challenged.

Open source projects have been adding features specifically intended to allow the pets (stateful) to be hosted alongside the cattle (stateless). The Kubernetes StatefulSet is one example.

This talk will survey currently available support and best practices for running stateful services on popular open source platforms. Proposals and works-in-progress will also be covered.

About Steve Wong
Strategic Open Source Partner Engineer, {code} Dell Technologies
Steve Wong is an Open Source Engineer with the {code} team. Steve has been participating in the Apache Mesos, DC/OS, Kubernetes, and REX-Ray projects.
Captions: 
	00:00:00,060 --> 00:00:07,109
so Who am I I'm Steve Wong I'm an

00:00:04,440 --> 00:00:09,330
open-source software engineer I work for

00:00:07,109 --> 00:00:13,139
a team that we called the code team and

00:00:09,330 --> 00:00:15,900
it's funded by Dell technologies

00:00:13,139 --> 00:00:17,550
we're software engineers who are

00:00:15,900 --> 00:00:20,250
assigned to work on community

00:00:17,550 --> 00:00:22,619
open-source projects in the past two

00:00:20,250 --> 00:00:28,710
years I personally have been working a

00:00:22,619 --> 00:00:31,679
lot on DCOs in kubernetes mezzos I added

00:00:28,710 --> 00:00:34,140
the storage interface for external

00:00:31,679 --> 00:00:36,710
volume mounts to a patch the Apache

00:00:34,140 --> 00:00:39,809
Bezos project that would be the DVD I

00:00:36,710 --> 00:00:42,480
isolator and I've been active on the

00:00:39,809 --> 00:00:43,579
kubernetes storage sync for about two

00:00:42,480 --> 00:00:47,070
years

00:00:43,579 --> 00:00:49,620
my group code also maintains an Apache

00:00:47,070 --> 00:00:53,280
licensed open-source project called Rex

00:00:49,620 --> 00:00:58,530
ray it's designed to support docker

00:00:53,280 --> 00:01:01,289
volume driver mounts on multiple

00:00:58,530 --> 00:01:04,949
container runtimes as well as multiple

00:01:01,289 --> 00:01:08,640
container orchestrators and we're also

00:01:04,949 --> 00:01:13,580
off active in the container storage

00:01:08,640 --> 00:01:13,580
interface initiative that is underway

00:01:14,360 --> 00:01:19,470
what I'm going to talk about today is

00:01:16,799 --> 00:01:22,520
just a brief intro to the history of the

00:01:19,470 --> 00:01:25,049
containers and they the twelve factors

00:01:22,520 --> 00:01:27,840
then moving on I'm going to cover

00:01:25,049 --> 00:01:32,310
container orchestrators and past

00:01:27,840 --> 00:01:34,979
platforms platform as-a-service I'm

00:01:32,310 --> 00:01:37,619
going to cover Orchestrator support for

00:01:34,979 --> 00:01:41,130
stateful services and then finally I'm

00:01:37,619 --> 00:01:43,079
going to wrap up with basically the

00:01:41,130 --> 00:01:46,500
first three are going to cover the state

00:01:43,079 --> 00:01:50,159
of running stateful inside containers

00:01:46,500 --> 00:01:53,009
and I'll wrap up with a call to action

00:01:50,159 --> 00:01:56,250
on what you can do to get involved with

00:01:53,009 --> 00:02:00,030
stateful now we'll start with a history

00:01:56,250 --> 00:02:01,979
lesson on containers some of these dates

00:02:00,030 --> 00:02:04,229
vary I went and tried to research this

00:02:01,979 --> 00:02:06,240
and some of these came out to be plus or

00:02:04,229 --> 00:02:08,310
minus a year I think the difference is

00:02:06,240 --> 00:02:11,030
maybe when somebody wrote the first

00:02:08,310 --> 00:02:13,850
commit in a repository to win it

00:02:11,030 --> 00:02:17,300
available to the general public but you

00:02:13,850 --> 00:02:19,069
know don't throw stones if you know more

00:02:17,300 --> 00:02:20,959
than I do when I'm off by a year here

00:02:19,069 --> 00:02:23,990
they should be pretty close and the

00:02:20,959 --> 00:02:26,300
point here is that containers aren't

00:02:23,990 --> 00:02:29,090
really new you can get traces of them

00:02:26,300 --> 00:02:34,700
all the way back to 1979 and the old

00:02:29,090 --> 00:02:39,580
AT&T UNIX be seven containers moved on

00:02:34,700 --> 00:02:43,130
in to the first decade of the year 2000

00:02:39,580 --> 00:02:45,560
Google released process containers and

00:02:43,130 --> 00:02:48,860
these later became packaged into the

00:02:45,560 --> 00:02:54,170
Linux kernel as control groups or also

00:02:48,860 --> 00:02:58,340
known as C groups after these initial

00:02:54,170 --> 00:02:59,870
containers a movement evolved to support

00:02:58,340 --> 00:03:01,880
what was called platform-as-a-service

00:02:59,870 --> 00:03:03,920
and this was a movement that was

00:03:01,880 --> 00:03:07,160
designed to simplify the effort to

00:03:03,920 --> 00:03:10,100
deploy build run and manage applications

00:03:07,160 --> 00:03:12,560
by giving you a foundation of ready to

00:03:10,100 --> 00:03:15,200
run components so that you didn't worry

00:03:12,560 --> 00:03:19,040
about networks operating systems

00:03:15,200 --> 00:03:22,510
middleware servers storage and backing

00:03:19,040 --> 00:03:25,070
services such as databases these were

00:03:22,510 --> 00:03:29,660
fundamentally based on containers

00:03:25,070 --> 00:03:31,549
whether they you know drill down and

00:03:29,660 --> 00:03:34,390
explained it to you or not and the

00:03:31,549 --> 00:03:36,500
advantage of these platform as a service

00:03:34,390 --> 00:03:39,230
offerings were that you could reduce

00:03:36,500 --> 00:03:41,209
complexity and thus effort because much

00:03:39,230 --> 00:03:43,880
of that infrastructure comes

00:03:41,209 --> 00:03:46,310
pre-configured and abstracted behind

00:03:43,880 --> 00:03:48,739
something with automated management the

00:03:46,310 --> 00:03:51,320
disadvantage of these past platforms is

00:03:48,739 --> 00:03:54,109
that you have reduced flexibility to

00:03:51,320 --> 00:03:56,980
support to select the exact tools that

00:03:54,109 --> 00:04:00,350
you want you know in many cases these

00:03:56,980 --> 00:04:03,799
platform as a service offerings are

00:04:00,350 --> 00:04:06,380
opinionated and they picked the tool the

00:04:03,799 --> 00:04:09,590
tool solution so once it's picked you

00:04:06,380 --> 00:04:12,590
live with it some of these past

00:04:09,590 --> 00:04:18,979
platforms also face charges of having

00:04:12,590 --> 00:04:21,200
single vendor lock-in finally about a

00:04:18,979 --> 00:04:23,610
year after this cluster of past

00:04:21,200 --> 00:04:27,389
platforms come came out

00:04:23,610 --> 00:04:29,759
this set of patterns and anti patterns

00:04:27,389 --> 00:04:32,430
called the 12 factors was published by

00:04:29,759 --> 00:04:36,659
an Adam Wiggins he was a co-founder of

00:04:32,430 --> 00:04:39,150
Heroku which one could say I think is

00:04:36,659 --> 00:04:41,250
the pioneering past platform although

00:04:39,150 --> 00:04:43,110
when I did a Google search it turned out

00:04:41,250 --> 00:04:45,300
that there maybe were as many as 10 of

00:04:43,110 --> 00:04:50,069
these it's just some of them perished

00:04:45,300 --> 00:04:52,169
and are no longer with us so I don't

00:04:50,069 --> 00:04:54,689
really know what it looked like at the

00:04:52,169 --> 00:04:57,210
time because I wasn't dealing with past

00:04:54,689 --> 00:05:01,650
but this is this is what's my research

00:04:57,210 --> 00:05:03,689
told me and that the 12 factors were

00:05:01,650 --> 00:05:06,689
designed to abstract out the platform

00:05:03,689 --> 00:05:09,330
your app ran on and they used containers

00:05:06,689 --> 00:05:13,770
and they supported horizontal scale out

00:05:09,330 --> 00:05:16,199
of apps using container technology what

00:05:13,770 --> 00:05:19,319
were the 12 factors or what are the 12

00:05:16,199 --> 00:05:21,870
factors that the website hosting this is

00:05:19,319 --> 00:05:24,180
still alive and well they were a

00:05:21,870 --> 00:05:26,789
collection of patterns intended really

00:05:24,180 --> 00:05:31,469
to guide deployment of apps on the

00:05:26,789 --> 00:05:33,449
Heroku platform but they applied I would

00:05:31,469 --> 00:05:38,969
contend equally well on the other past

00:05:33,449 --> 00:05:42,779
platforms such as Cloud Foundry where

00:05:38,969 --> 00:05:45,599
did this come about in terms of modern

00:05:42,779 --> 00:05:48,120
containers docker well it turns out that

00:05:45,599 --> 00:05:51,599
the 12 factors were published in 2011

00:05:48,120 --> 00:05:55,589
and docker didn't come out until 2013 it

00:05:51,599 --> 00:05:59,159
in fact was a spinoff of the 2011 dot

00:05:55,589 --> 00:06:02,189
cloud you see on that diagram the

00:05:59,159 --> 00:06:05,460
container orchestrators depends on which

00:06:02,189 --> 00:06:09,089
one the mezzos container Orchestrator

00:06:05,460 --> 00:06:11,310
actually predates the 12 factors

00:06:09,089 --> 00:06:14,699
although it wasn't running at the time

00:06:11,310 --> 00:06:18,360
on docker containers it had it had its

00:06:14,699 --> 00:06:20,819
own bezos container Iser based on Linux

00:06:18,360 --> 00:06:23,580
containers and they added support for

00:06:20,819 --> 00:06:28,310
docker later swarm and kubernetes

00:06:23,580 --> 00:06:28,310
clearly came after the 12 factors

00:06:29,129 --> 00:06:33,479
what is the difference I mean we've got

00:06:31,439 --> 00:06:37,639
mezzos kubernetes

00:06:33,479 --> 00:06:37,639
swarm as container orchestrators

00:06:38,190 --> 00:06:43,920
these past platforms and really I would

00:06:40,530 --> 00:06:46,110
use this analogy of comparing them to

00:06:43,920 --> 00:06:48,660
pizza as a service you've got there in

00:06:46,110 --> 00:06:51,990
the two columns delivery pizza and

00:06:48,660 --> 00:06:54,720
frozen pizza now if you get the delivery

00:06:51,990 --> 00:06:57,660
pizza that I would contend is the

00:06:54,720 --> 00:06:59,490
equivalent of poss where more of the

00:06:57,660 --> 00:07:04,260
choices are made for you you know you

00:06:59,490 --> 00:07:06,540
deal with the vendor takes care of the

00:07:04,260 --> 00:07:08,700
cheese the toppings the pizza sauce the

00:07:06,540 --> 00:07:12,300
pizza dough the oven the electric and

00:07:08,700 --> 00:07:14,430
gas and shows up at your door and you're

00:07:12,300 --> 00:07:17,070
done you don't get to pick the oven that

00:07:14,430 --> 00:07:20,100
that's taken care of when you go to the

00:07:17,070 --> 00:07:22,290
frozen pizza it's using your oven and

00:07:20,100 --> 00:07:24,750
gas and you maybe have a little more

00:07:22,290 --> 00:07:26,880
choice if you like that extra crispy

00:07:24,750 --> 00:07:30,000
you're in control of your own oven if

00:07:26,880 --> 00:07:32,280
you wanted to throw a few extra veggies

00:07:30,000 --> 00:07:34,860
on top of that frozen pizza have at it

00:07:32,280 --> 00:07:37,530
now this is the whole continuum of this

00:07:34,860 --> 00:07:40,440
you know to to do this right in this

00:07:37,530 --> 00:07:42,860
talk I'm really talking about the the

00:07:40,440 --> 00:07:45,390
twelve factors relating to pass and

00:07:42,860 --> 00:07:47,970
container orchestrators relating to

00:07:45,390 --> 00:07:50,520
containers but the fact is parallel to

00:07:47,970 --> 00:07:53,390
this you could draw even more columns

00:07:50,520 --> 00:07:56,370
covering infrastructure-as-a-service

00:07:53,390 --> 00:07:59,310
virtualization even running on bare

00:07:56,370 --> 00:08:03,480
metal and the more you know in this

00:07:59,310 --> 00:08:06,210
continuum horizontally you'd deal with a

00:08:03,480 --> 00:08:07,830
less opinionated provider of service all

00:08:06,210 --> 00:08:09,570
the way down to potentially the

00:08:07,830 --> 00:08:13,230
equivalent of pizza of growing your own

00:08:09,570 --> 00:08:15,900
wheat you know threshing it growing your

00:08:13,230 --> 00:08:18,360
own Tomatoes and really I would contend

00:08:15,900 --> 00:08:21,750
in IT you have all of these choices but

00:08:18,360 --> 00:08:23,730
the the modern trend seems to be that in

00:08:21,750 --> 00:08:25,620
many organizations you're trying to

00:08:23,730 --> 00:08:28,530
eliminate this complexity which

00:08:25,620 --> 00:08:30,300
eliminates your operational expense now

00:08:28,530 --> 00:08:31,410
it isn't to say you have to choose one

00:08:30,300 --> 00:08:34,320
or the other there are many

00:08:31,410 --> 00:08:36,450
organizations where one division might

00:08:34,320 --> 00:08:39,090
have things going on that makes sense to

00:08:36,450 --> 00:08:43,050
run on infrastructure as a service

00:08:39,090 --> 00:08:47,580
another one on a container Orchestrator

00:08:43,050 --> 00:08:49,440
and a third on pass but that's how I

00:08:47,580 --> 00:08:51,370
would compare these two you're you're

00:08:49,440 --> 00:08:54,350
basically

00:08:51,370 --> 00:08:57,140
you're basically in an arena where the

00:08:54,350 --> 00:08:59,930
past platforms make more choices for you

00:08:57,140 --> 00:09:03,770
but because of that they remove options

00:08:59,930 --> 00:09:05,090
from you what are the 12 factors say

00:09:03,770 --> 00:09:08,530
well the one I'm going to talk about

00:09:05,090 --> 00:09:10,970
today is factor number six it says

00:09:08,530 --> 00:09:14,120
execute the app has one or more

00:09:10,970 --> 00:09:16,160
stateless platform processes why would

00:09:14,120 --> 00:09:18,590
they say that well it's pretty easy if

00:09:16,160 --> 00:09:21,710
you if you have a stateless process

00:09:18,590 --> 00:09:24,140
whether it's in a container or on a pass

00:09:21,710 --> 00:09:26,390
in a container they're easy to replace

00:09:24,140 --> 00:09:29,510
an upgrade you just shoot them in the

00:09:26,390 --> 00:09:32,240
head and bring up another one it's easy

00:09:29,510 --> 00:09:34,400
to automate scale up and scale down

00:09:32,240 --> 00:09:36,710
because there's nothing you care about

00:09:34,400 --> 00:09:41,650
inside these things if you've maintained

00:09:36,710 --> 00:09:44,570
statelessness now on the other hand I

00:09:41,650 --> 00:09:47,360
love this I love this quote that

00:09:44,570 --> 00:09:50,930
somebody tweeted out there and it says

00:09:47,360 --> 00:09:53,720
there's stateless as a hoax I mean if

00:09:50,930 --> 00:09:54,410
you take the aerial view you can't go

00:09:53,720 --> 00:09:56,720
out there

00:09:54,410 --> 00:09:59,090
with a story that literally everything

00:09:56,720 --> 00:10:02,120
is stateless I mean somewhere if you're

00:09:59,090 --> 00:10:04,550
gonna build a useful stat useful app it

00:10:02,120 --> 00:10:06,440
can't be something that has Alzheimer's

00:10:04,550 --> 00:10:08,720
every time the power goes out or you

00:10:06,440 --> 00:10:12,320
shut it down I mean so that states got

00:10:08,720 --> 00:10:15,140
to live somewhere and this person's

00:10:12,320 --> 00:10:17,300
contention is that there is actually no

00:10:15,140 --> 00:10:21,350
such thing as a stateless architecture

00:10:17,300 --> 00:10:23,810
it it's just declaring that the state

00:10:21,350 --> 00:10:26,270
part the difficult part is someone

00:10:23,810 --> 00:10:28,550
else's problem it doesn't make the

00:10:26,270 --> 00:10:30,530
problem go away now in this picture if

00:10:28,550 --> 00:10:32,510
you can see it in the background they

00:10:30,530 --> 00:10:35,600
used an ostrich with a head in it saying

00:10:32,510 --> 00:10:38,900
in the head in the sand I suggest that

00:10:35,600 --> 00:10:41,150
maybe a more appropriate animal analogy

00:10:38,900 --> 00:10:43,010
would be to use the elephant you know

00:10:41,150 --> 00:10:46,730
that there's still state there on these

00:10:43,010 --> 00:10:48,050
past platforms Heroku for example or

00:10:46,730 --> 00:10:49,040
Cloud Foundry they don't really

00:10:48,050 --> 00:10:53,240
eliminate it

00:10:49,040 --> 00:10:55,760
they just declare that and I've got it

00:10:53,240 --> 00:10:58,220
here that any data that needs to persist

00:10:55,760 --> 00:11:00,440
must be stored in a stateful backing

00:10:58,220 --> 00:11:02,750
service well that's where your state is

00:11:00,440 --> 00:11:04,329
you've just declared it out of scope the

00:11:02,750 --> 00:11:06,249
other guys problem but the

00:11:04,329 --> 00:11:08,019
often in the room is that it's still

00:11:06,249 --> 00:11:09,269
layering you're pretending you don't see

00:11:08,019 --> 00:11:12,129
it

00:11:09,269 --> 00:11:14,829
what exactly is one of these stateful

00:11:12,129 --> 00:11:16,779
backing services well in the era when

00:11:14,829 --> 00:11:21,579
the 12 factors were originally written

00:11:16,779 --> 00:11:24,879
2011 it was typically a database and the

00:11:21,579 --> 00:11:27,339
12 factors goes on to advise that this

00:11:24,879 --> 00:11:30,519
database or the stateful backing service

00:11:27,339 --> 00:11:34,119
should be consumed behind an API such as

00:11:30,519 --> 00:11:36,339
an HTTP network service now what exactly

00:11:34,119 --> 00:11:38,920
would that be well if you're running in

00:11:36,339 --> 00:11:41,529
AWS in the Amazon Cloud it would be

00:11:38,920 --> 00:11:43,600
something like Amazon's DynamoDB if

00:11:41,529 --> 00:11:46,089
you're on Prem it would be something

00:11:43,600 --> 00:11:48,369
like an Oracle database something

00:11:46,089 --> 00:11:50,079
basically maintained by either your

00:11:48,369 --> 00:11:53,439
service provider or if you're dealing

00:11:50,079 --> 00:11:55,269
with the Oracle example a team of Oracle

00:11:53,439 --> 00:11:57,910
DBA s you know high-priced

00:11:55,269 --> 00:12:02,319
experts that maintain this stateful

00:11:57,910 --> 00:12:04,299
backing service well what's that changes

00:12:02,319 --> 00:12:07,660
a little bit in modern times I would

00:12:04,299 --> 00:12:10,299
contend that since 2011 some of these it

00:12:07,660 --> 00:12:14,230
isn't just databases it's moved on to

00:12:10,299 --> 00:12:17,889
various forms of no sequel things like

00:12:14,230 --> 00:12:20,339
Cassandra Kafka Redis keeping

00:12:17,889 --> 00:12:26,290
state other than simply in-memory

00:12:20,339 --> 00:12:29,470
elastic Hadoop and what if you want to

00:12:26,290 --> 00:12:32,139
run these kinds of stateful services but

00:12:29,470 --> 00:12:34,259
you're the guy responsible for your

00:12:32,139 --> 00:12:36,249
whole IT organization in other words

00:12:34,259 --> 00:12:39,249
suddenly it isn't the other guy's

00:12:36,249 --> 00:12:41,850
problem you're the guy ring maintaining

00:12:39,249 --> 00:12:44,799
that stateful backing sewer service

00:12:41,850 --> 00:12:47,709
there are perfectly valid reasons why

00:12:44,799 --> 00:12:49,989
you'd want to maintain your own - maybe

00:12:47,709 --> 00:12:52,929
you want to pick the version of your own

00:12:49,989 --> 00:12:54,610
tool and/or database maybe you want to

00:12:52,929 --> 00:12:57,009
customize it maybe you want to stay

00:12:54,610 --> 00:12:59,470
portable across clouds in other words I

00:12:57,009 --> 00:13:04,029
want to put together an app that I could

00:12:59,470 --> 00:13:07,179
run on Amazon AWS but also run it on the

00:13:04,029 --> 00:13:09,879
Google cloud and also run it in certain

00:13:07,179 --> 00:13:13,689
Geographic reason regions in an on-prem

00:13:09,879 --> 00:13:15,759
data center you know in order to

00:13:13,689 --> 00:13:17,390
maintain that portability you can't go

00:13:15,759 --> 00:13:19,579
use something like dynamo

00:13:17,390 --> 00:13:24,079
you might want to pick an open source

00:13:19,579 --> 00:13:26,870
solution and take management

00:13:24,079 --> 00:13:29,089
responsibility for it another good

00:13:26,870 --> 00:13:32,209
reason for doing this yourself is to

00:13:29,089 --> 00:13:33,470
main to avoid database monoliths the

00:13:32,209 --> 00:13:36,320
fact is and a lot of those

00:13:33,470 --> 00:13:40,390
platform-as-a-service solutions the

00:13:36,320 --> 00:13:43,130
platform would stand up a database and

00:13:40,390 --> 00:13:46,779
every app using it on that platform

00:13:43,130 --> 00:13:52,209
would be connected to that behind the

00:13:46,779 --> 00:13:55,010
the API but ultimately that results in a

00:13:52,209 --> 00:13:59,329
monolith where all of this information

00:13:55,010 --> 00:14:03,610
is in in the one big basket well what's

00:13:59,329 --> 00:14:03,610
the problem with monoliths well

00:14:03,970 --> 00:14:10,910
monoliths are bad for a number of

00:14:06,860 --> 00:14:13,040
reasons if you let a database get large

00:14:10,910 --> 00:14:15,980
how are you safely gonna move move it

00:14:13,040 --> 00:14:18,019
you know moving it to another location

00:14:15,980 --> 00:14:20,810
or a different version or a different

00:14:18,019 --> 00:14:23,750
technology can be as complex as

00:14:20,810 --> 00:14:25,940
rebuilding a 40-story high-rise in a

00:14:23,750 --> 00:14:28,279
dense urban area where you're going to

00:14:25,940 --> 00:14:30,680
have to orchestrate an implosion with

00:14:28,279 --> 00:14:32,360
other buildings filled with people that

00:14:30,680 --> 00:14:35,990
you care about right next to it the

00:14:32,360 --> 00:14:37,640
bottom line is in my observation and you

00:14:35,990 --> 00:14:39,980
know I work for a technology vendor

00:14:37,640 --> 00:14:42,350
that's pretty big and storage my

00:14:39,980 --> 00:14:44,300
observation is that once a database gets

00:14:42,350 --> 00:14:47,360
large sufficiently large

00:14:44,300 --> 00:14:49,370
nobody ever moves it nobody wants to bet

00:14:47,360 --> 00:14:52,970
their career on the risk involved with

00:14:49,370 --> 00:14:55,160
moving the you know why is Oracle still

00:14:52,970 --> 00:14:57,350
here well because there's a lot of

00:14:55,160 --> 00:14:59,540
really big ones and nobody wants to bet

00:14:57,350 --> 00:15:01,490
their career on taking the risk of

00:14:59,540 --> 00:15:04,310
moving it I mean once these get large

00:15:01,490 --> 00:15:07,250
that problem can be not just the risk of

00:15:04,310 --> 00:15:09,079
collateral damage and the the time it

00:15:07,250 --> 00:15:11,300
will take and the outage where your

00:15:09,079 --> 00:15:13,430
services are off the air but really

00:15:11,300 --> 00:15:15,949
these things can sometimes get so big

00:15:13,430 --> 00:15:17,990
that it the problem is like moving all

00:15:15,949 --> 00:15:20,870
the water out of the Atlantic Ocean into

00:15:17,990 --> 00:15:22,790
the Pacific it's just not doable with

00:15:20,870 --> 00:15:26,029
the technology you're likely to get in

00:15:22,790 --> 00:15:29,810
hand get on hand or with the budget that

00:15:26,029 --> 00:15:32,330
you're likely to have so

00:15:29,810 --> 00:15:35,000
just like people advised against

00:15:32,330 --> 00:15:37,820
monoliths when you're building you know

00:15:35,000 --> 00:15:39,470
unrelated apps whether they're related

00:15:37,820 --> 00:15:42,080
or not you know the whole principle of

00:15:39,470 --> 00:15:45,230
separation of concerns I would contend

00:15:42,080 --> 00:15:47,720
that when it comes to data storage it's

00:15:45,230 --> 00:15:51,140
a good idea to avoid these monoliths

00:15:47,720 --> 00:15:53,240
that if two apps are not related they

00:15:51,140 --> 00:15:55,790
shouldn't be saving their things in the

00:15:53,240 --> 00:15:59,089
same database that gives you the

00:15:55,790 --> 00:16:00,950
flexibility to do things like pick

00:15:59,089 --> 00:16:02,510
differe technologies when they make

00:16:00,950 --> 00:16:05,560
sense and it keeps them from getting

00:16:02,510 --> 00:16:08,270
bigger so you can do things like change

00:16:05,560 --> 00:16:10,220
versions independently I mean consider

00:16:08,270 --> 00:16:13,310
the logistics if you had a hundred

00:16:10,220 --> 00:16:16,100
different apps all in one database and

00:16:13,310 --> 00:16:17,330
then you want to update it you're going

00:16:16,100 --> 00:16:19,339
to have to have a hundred different

00:16:17,330 --> 00:16:22,430
teams responsible for those apps

00:16:19,339 --> 00:16:24,339
coordinate this effort to ascertain

00:16:22,430 --> 00:16:26,450
whether they're comfortable and

00:16:24,339 --> 00:16:28,940
compatible with this version change

00:16:26,450 --> 00:16:31,940
whereas if you kept these as separate

00:16:28,940 --> 00:16:35,300
instances of that data store you could

00:16:31,940 --> 00:16:38,740
do the common things like canary testing

00:16:35,300 --> 00:16:42,140
where you have one team maybe one that

00:16:38,740 --> 00:16:45,080
has a relatively low cost should it fail

00:16:42,140 --> 00:16:48,440
go out there and do the testing for it

00:16:45,080 --> 00:16:50,960
first and then and only then only if you

00:16:48,440 --> 00:16:52,520
have a satisfactory experience let that

00:16:50,960 --> 00:16:56,900
ripple through to the rest of your

00:16:52,520 --> 00:16:59,390
organization you could also do things if

00:16:56,900 --> 00:17:04,490
you avoid monoliths of having a team

00:16:59,390 --> 00:17:07,189
with a key value store that discovers a

00:17:04,490 --> 00:17:08,959
newer open-source key value store that's

00:17:07,189 --> 00:17:11,540
likely to work better for them have the

00:17:08,959 --> 00:17:14,270
freedom to upgrade without impacting

00:17:11,540 --> 00:17:16,220
others I mean and let's face it and in

00:17:14,270 --> 00:17:18,410
this field things change all the time

00:17:16,220 --> 00:17:21,770
the only constant is that things change

00:17:18,410 --> 00:17:27,319
so avoiding these monoliths in your data

00:17:21,770 --> 00:17:30,820
store makes a lot of sense so if if we

00:17:27,319 --> 00:17:33,560
agree that we want to give people the

00:17:30,820 --> 00:17:36,380
flexibilities offered in containers and

00:17:33,560 --> 00:17:38,630
container orchestrators things like dev

00:17:36,380 --> 00:17:40,870
teams engaging in kind of their own self

00:17:38,630 --> 00:17:43,520
service of picking their own tools

00:17:40,870 --> 00:17:46,440
taking advantage of container

00:17:43,520 --> 00:17:48,210
attributes like consistency no matter

00:17:46,440 --> 00:17:50,640
where you run you know looks the same

00:17:48,210 --> 00:17:53,400
whether you're on the Amazon Cloud the

00:17:50,640 --> 00:17:56,100
Google cloud or on Prem you want to have

00:17:53,400 --> 00:17:59,010
these things packaged with dependency

00:17:56,100 --> 00:18:00,990
management you want to take advantage of

00:17:59,010 --> 00:18:04,260
an orchestration platform that can do

00:18:00,990 --> 00:18:06,630
health monitoring automatic rollouts and

00:18:04,260 --> 00:18:10,620
roll roll backs declarative

00:18:06,630 --> 00:18:13,500
configuration putting these things in

00:18:10,620 --> 00:18:17,750
containers if you can do it makes a lot

00:18:13,500 --> 00:18:22,220
of sense there's a lot of value here so

00:18:17,750 --> 00:18:25,560
my wrap-up on the 12 factors is that I'm

00:18:22,220 --> 00:18:28,680
not I'm not challenging the whole thing

00:18:25,560 --> 00:18:32,490
I'm actually in full agreement that with

00:18:28,680 --> 00:18:35,610
the 12 fact or principle that publishing

00:18:32,490 --> 00:18:37,860
any any data store behind an interface

00:18:35,610 --> 00:18:41,790
is a good idea having a controlled

00:18:37,860 --> 00:18:44,490
abstraction layer but I want one that's

00:18:41,790 --> 00:18:47,340
I want to enable one that's hosted on a

00:18:44,490 --> 00:18:49,610
container orchestration platform that

00:18:47,340 --> 00:18:52,230
gets to cheat on that rule that all

00:18:49,610 --> 00:18:55,830
processes must be stateless you know

00:18:52,230 --> 00:18:58,080
there may be in 2011 that wasn't doable

00:18:55,830 --> 00:19:01,590
but on a modern container Orchestrator

00:18:58,080 --> 00:19:05,400
platform stateless running in containers

00:19:01,590 --> 00:19:07,290
is supported and I'll go on of further

00:19:05,400 --> 00:19:11,580
slides to back that up if you have

00:19:07,290 --> 00:19:14,460
doubts but by by accepting the fact that

00:19:11,580 --> 00:19:16,560
maybe the 12 factors should be a little

00:19:14,460 --> 00:19:18,900
bit flexible we can preserve its

00:19:16,560 --> 00:19:21,750
usefulness and I mean there are a lot of

00:19:18,900 --> 00:19:23,340
deccan documents you know in this

00:19:21,750 --> 00:19:26,280
technology field that should have a

00:19:23,340 --> 00:19:29,250
sell-by date of six months or a year the

00:19:26,280 --> 00:19:33,960
fact is the 12 factors have survived

00:19:29,250 --> 00:19:37,260
from 2011 to 2017 pretty pretty well and

00:19:33,960 --> 00:19:39,390
a six year life in any document in this

00:19:37,260 --> 00:19:41,490
field is pretty decent

00:19:39,390 --> 00:19:44,550
I'm not saying tear down the whole thing

00:19:41,490 --> 00:19:47,040
I'm just saying we need to treat these

00:19:44,550 --> 00:19:49,490
12 factors not like some religious code

00:19:47,040 --> 00:19:51,930
a cell or treat them like a law book and

00:19:49,490 --> 00:19:55,110
you'll just you'll make yourself

00:19:51,930 --> 00:19:56,970
miserable doing that they they should be

00:19:55,110 --> 00:20:01,710
respected and considered

00:19:56,970 --> 00:20:03,480
when it makes sense now if you're

00:20:01,710 --> 00:20:05,190
skeptical unfortunately it looks like

00:20:03,480 --> 00:20:08,640
that's pretty hard to read but what that

00:20:05,190 --> 00:20:11,880
is just to point out that stateful in

00:20:08,640 --> 00:20:15,630
containers isn't new and isn't just

00:20:11,880 --> 00:20:17,490
crazy talk this is a snapshot of docker

00:20:15,630 --> 00:20:20,130
hub and it turns out that if you go to

00:20:17,490 --> 00:20:22,320
docker hub you can actually sort these

00:20:20,130 --> 00:20:24,539
by popularity in other words the number

00:20:22,320 --> 00:20:29,250
of downloads well in the day I got this

00:20:24,539 --> 00:20:32,190
this is a top 12 list of images off of

00:20:29,250 --> 00:20:34,289
docker hub and it turns out that seven

00:20:32,190 --> 00:20:37,260
of the top 12 on the day I looked

00:20:34,289 --> 00:20:40,710
we're stateful applications so pretty

00:20:37,260 --> 00:20:44,490
clearly people are doing this this isn't

00:20:40,710 --> 00:20:49,110
crazy talk if we move on to container

00:20:44,490 --> 00:20:52,890
orchestrators we've got this is a chart

00:20:49,110 --> 00:20:55,140
showing the features in an assortment of

00:20:52,890 --> 00:20:58,679
container orchestrators related to

00:20:55,140 --> 00:21:01,740
running stateful in stateful apps inside

00:20:58,679 --> 00:21:04,350
containers so on the far left you can

00:21:01,740 --> 00:21:06,690
see DCOs supports external volume

00:21:04,350 --> 00:21:09,539
external persistent volume mounts in

00:21:06,690 --> 00:21:12,600
fact kubernetes Bezos and swarm do as

00:21:09,539 --> 00:21:14,429
well DCOs and maze O's support

00:21:12,600 --> 00:21:16,409
frameworks in other words this is a two

00:21:14,429 --> 00:21:18,510
level scheduler if you're not so if

00:21:16,409 --> 00:21:21,950
you're not familiar with it and they

00:21:18,510 --> 00:21:24,809
have frameworks that have been published

00:21:21,950 --> 00:21:27,030
specifically to support stateful

00:21:24,809 --> 00:21:31,110
applications being managed on the

00:21:27,030 --> 00:21:34,850
platform and scheduled out onto cluster

00:21:31,110 --> 00:21:38,179
nodes DCOs has packages to support

00:21:34,850 --> 00:21:40,470
stateful apps running in containers

00:21:38,179 --> 00:21:43,110
kubernetes has something pretty similar

00:21:40,470 --> 00:21:45,059
called helm charts kubernetes also

00:21:43,110 --> 00:21:49,830
operators and stateful sets and I'm

00:21:45,059 --> 00:21:52,770
going to go into these in detail now you

00:21:49,830 --> 00:21:55,650
on some forms of these stateful backing

00:21:52,770 --> 00:21:57,840
stores it is possible to use local

00:21:55,650 --> 00:22:02,100
storage for state but there's a downside

00:21:57,840 --> 00:22:04,830
to this you know my what I would compare

00:22:02,100 --> 00:22:07,140
this to is I'd say that you know you

00:22:04,830 --> 00:22:10,100
could you could be really crazy and run

00:22:07,140 --> 00:22:12,140
something like Postgres or my sequel

00:22:10,100 --> 00:22:14,330
direct-attached storage in a cluster

00:22:12,140 --> 00:22:17,480
note but if you do that and the

00:22:14,330 --> 00:22:20,540
container is killed or that cluster node

00:22:17,480 --> 00:22:25,060
catches fire and burns your data is gone

00:22:20,540 --> 00:22:28,520
like forever there are other things like

00:22:25,060 --> 00:22:31,520
Cassandra that do involve some forms of

00:22:28,520 --> 00:22:33,560
replication so maybe you feel some pain

00:22:31,520 --> 00:22:36,260
when it goes down but it might be

00:22:33,560 --> 00:22:38,690
recoverable but I would use the analogy

00:22:36,260 --> 00:22:41,360
to using local storage to be like

00:22:38,690 --> 00:22:44,150
smoking a cigarette you take that first

00:22:41,360 --> 00:22:46,460
rag it tastes good at first maybe you

00:22:44,150 --> 00:22:49,040
see other nodes doing it but in the long

00:22:46,460 --> 00:22:51,650
run it's gonna learn lead to shorter

00:22:49,040 --> 00:22:56,570
data life expectancy and reduce your

00:22:51,650 --> 00:22:58,310
capacity your lung capacity the the

00:22:56,570 --> 00:23:00,820
alternative this is something called

00:22:58,310 --> 00:23:04,580
external volume mounts where you use

00:23:00,820 --> 00:23:07,730
some sort of data communication network

00:23:04,580 --> 00:23:10,400
communication to attach a storage volume

00:23:07,730 --> 00:23:13,520
that is provided off your cluster note

00:23:10,400 --> 00:23:17,060
and these external volume mounts how do

00:23:13,520 --> 00:23:18,740
they work well there if you're a techie

00:23:17,060 --> 00:23:21,560
geek like me you're probably familiar

00:23:18,740 --> 00:23:24,970
with the sci-fi TV series Star Trek and

00:23:21,560 --> 00:23:27,470
I would say that a persistent volume of

00:23:24,970 --> 00:23:30,260
persistent app using an external mount

00:23:27,470 --> 00:23:34,160
is just like that familiar episode of

00:23:30,260 --> 00:23:36,290
Star Trek your data base binary can be

00:23:34,160 --> 00:23:38,990
like that guy in the red shirt in other

00:23:36,290 --> 00:23:41,930
words the expendable guy who you know if

00:23:38,990 --> 00:23:43,880
you've watched many episodes isn't going

00:23:41,930 --> 00:23:46,520
to ever be seen again by that's by the

00:23:43,880 --> 00:23:51,140
by the end of that one-hour episode that

00:23:46,520 --> 00:23:53,180
red shirt guy is dead the the stateful

00:23:51,140 --> 00:23:55,280
app binary can be the guy in the red

00:23:53,180 --> 00:23:58,070
shirt so long as you use an external

00:23:55,280 --> 00:24:01,040
volume mount which is the guy in the

00:23:58,070 --> 00:24:02,540
yellow shirt when trouble arises the guy

00:24:01,040 --> 00:24:04,520
in the yellow shirt picks up the

00:24:02,540 --> 00:24:08,810
communicator and says beam me up Scotty

00:24:04,520 --> 00:24:11,600
and he flees to safety the red the red

00:24:08,810 --> 00:24:13,160
shirt guys are dead but the state the

00:24:11,600 --> 00:24:15,860
stuff you cared about in your database

00:24:13,160 --> 00:24:18,350
it got beamed up you can beam it back

00:24:15,860 --> 00:24:19,910
down to another planet pick some other

00:24:18,350 --> 00:24:23,940
red shirt guys and you're back in

00:24:19,910 --> 00:24:26,009
business if you're running things like

00:24:23,940 --> 00:24:28,529
Postgres my sequel the traditional

00:24:26,009 --> 00:24:31,409
relational databases that is really how

00:24:28,529 --> 00:24:32,970
you're going to do it here there might

00:24:31,409 --> 00:24:35,100
be an alternative with some of them of

00:24:32,970 --> 00:24:37,379
sharding them but you know the baseline

00:24:35,100 --> 00:24:37,759
single node database that's how you do

00:24:37,379 --> 00:24:40,639
it

00:24:37,759 --> 00:24:45,299
Cassandra could take the red shirt guy

00:24:40,639 --> 00:24:47,580
getting knocked off but in fact in some

00:24:45,299 --> 00:24:49,740
instances there might be benefits to

00:24:47,580 --> 00:24:53,669
using an external volume out even if

00:24:49,740 --> 00:24:56,549
even with cluster where storage like

00:24:53,669 --> 00:24:59,309
Cassandra this all depends and I guess

00:24:56,549 --> 00:25:01,259
this is getting into a second talk that

00:24:59,309 --> 00:25:03,059
takes more than an hour but I'd invite

00:25:01,259 --> 00:25:05,789
you to come and see me if you're curious

00:25:03,059 --> 00:25:07,470
about that either after the talk or I'm

00:25:05,789 --> 00:25:14,039
hanging out in a booth we're sponsoring

00:25:07,470 --> 00:25:16,590
downstairs but bottom line is external

00:25:14,039 --> 00:25:19,110
persistent volume mods are like the Star

00:25:16,590 --> 00:25:21,659
Trek it untethered your data from a

00:25:19,110 --> 00:25:24,269
particular cluster node and lets the

00:25:21,659 --> 00:25:27,570
container Orchestrator do things like

00:25:24,269 --> 00:25:32,509
upgrade the database binary with a very

00:25:27,570 --> 00:25:35,399
short term hit on on your downtime and

00:25:32,509 --> 00:25:37,470
it allows you to migrate things across

00:25:35,399 --> 00:25:41,070
these nodes so you could do things like

00:25:37,470 --> 00:25:43,309
a plan maintenance activity on it on a

00:25:41,070 --> 00:25:46,529
compute

00:25:43,309 --> 00:25:48,690
moving on to frameworks like I said all

00:25:46,529 --> 00:25:50,610
of the container orchestrators now

00:25:48,690 --> 00:25:53,879
support those external volume outs

00:25:50,610 --> 00:25:57,389
they're there they've just become

00:25:53,879 --> 00:26:01,679
Universal the frameworks are found in

00:25:57,389 --> 00:26:03,690
Apache mezzos and DCOs now these

00:26:01,679 --> 00:26:06,799
frameworks can support both state and

00:26:03,690 --> 00:26:09,539
full and stateless applications but

00:26:06,799 --> 00:26:13,610
stateful app management is a primary use

00:26:09,539 --> 00:26:16,740
case and maze those frameworks exist for

00:26:13,610 --> 00:26:18,779
pretty much all of those stateful

00:26:16,740 --> 00:26:20,159
services I showed in that prior one and

00:26:18,779 --> 00:26:22,649
at the end of my talk I'll have a

00:26:20,159 --> 00:26:24,539
diagram that you can take with you that

00:26:22,649 --> 00:26:29,610
actually links to where you can find

00:26:24,539 --> 00:26:31,769
these the DCOs

00:26:29,610 --> 00:26:36,110
container Orchestrator also has a

00:26:31,769 --> 00:26:36,110
concept of packages and

00:26:36,140 --> 00:26:42,830
on the stateful side packages exist for

00:26:38,899 --> 00:26:45,470
Cassandra elastic HDFS kafka MongoDB my

00:26:42,830 --> 00:26:47,539
sequel Postgres Redis and even more and

00:26:45,470 --> 00:26:51,279
this provides an app store like

00:26:47,539 --> 00:26:54,440
experience complete with a UI plus a CLI

00:26:51,279 --> 00:26:56,269
for deploying these stateful apps so

00:26:54,440 --> 00:27:00,620
they're basically moving this into the

00:26:56,269 --> 00:27:05,480
realm of the easy button for deploying

00:27:00,620 --> 00:27:08,389
stateful kubernetes like DCOs has helm

00:27:05,480 --> 00:27:10,730
charts and it's a similar thing an app

00:27:08,389 --> 00:27:13,220
store experience it supports update and

00:27:10,730 --> 00:27:14,870
roll back of the stateful apps helm

00:27:13,220 --> 00:27:18,519
charts are available for Cassandra

00:27:14,870 --> 00:27:22,840
elastic HDFS kafka my sequel

00:27:18,519 --> 00:27:28,070
Postgres Redis and more and it's growing

00:27:22,840 --> 00:27:30,620
kubernetes also has a recent edition

00:27:28,070 --> 00:27:32,809
called stateful sets now it turns out

00:27:30,620 --> 00:27:36,440
with many of these cluster aware scale

00:27:32,809 --> 00:27:41,960
out things like I don't know keeper for

00:27:36,440 --> 00:27:45,080
example they're based on a horizontally

00:27:41,960 --> 00:27:47,929
scalable set of nodes that have unique

00:27:45,080 --> 00:27:50,090
network identifiers in other words they

00:27:47,929 --> 00:27:52,159
know that this guy is node 1 this other

00:27:50,090 --> 00:27:54,889
guy is node 2 and this other guy with

00:27:52,159 --> 00:27:57,769
this host name is node 3 the stateful

00:27:54,889 --> 00:28:01,130
sets take care of separating out the

00:27:57,769 --> 00:28:04,639
configuration of these things and it and

00:28:01,130 --> 00:28:06,889
keeping these running using stateful

00:28:04,639 --> 00:28:09,350
persistent storage the kubernetes

00:28:06,889 --> 00:28:11,269
stateful set also manages and this is

00:28:09,350 --> 00:28:15,769
very important in some of these cluster

00:28:11,269 --> 00:28:19,960
aware replicating stateful solutions

00:28:15,769 --> 00:28:22,610
it supports ordered startup and shutdown

00:28:19,960 --> 00:28:25,190
including a graceful shutdown where you

00:28:22,610 --> 00:28:28,100
might be able to drain transactions in

00:28:25,190 --> 00:28:30,200
progress rather than have this be the

00:28:28,100 --> 00:28:35,269
equivalent of randomly pulling the plug

00:28:30,200 --> 00:28:38,029
on a bunch of servers some of these can

00:28:35,269 --> 00:28:40,159
recover in the unordered scenario but it

00:28:38,029 --> 00:28:41,960
just takes a lot longer and if you can

00:28:40,159 --> 00:28:45,679
have this scenario where you can shut

00:28:41,960 --> 00:28:48,080
them down gracefully if you're engaging

00:28:45,679 --> 00:28:49,520
in a plan meaning it's activity upgrade

00:28:48,080 --> 00:28:52,370
something like that it's just

00:28:49,520 --> 00:28:57,380
a much more pleasant reduced downtime

00:28:52,370 --> 00:28:59,750
experience finally kubernetes supports

00:28:57,380 --> 00:29:02,780
something called operators and an

00:28:59,750 --> 00:29:04,970
operator we're getting into kubernetes

00:29:02,780 --> 00:29:07,220
design here but I'm gonna go for it an

00:29:04,970 --> 00:29:10,040
operator is based on the kubernetes

00:29:07,220 --> 00:29:12,440
controller concept and in kubernetes a

00:29:10,040 --> 00:29:14,920
controller is something like the you

00:29:12,440 --> 00:29:18,110
know the thermostat that controls your

00:29:14,920 --> 00:29:20,990
furnace or air conditioner where you

00:29:18,110 --> 00:29:24,410
start by setting or declaring a desired

00:29:20,990 --> 00:29:26,990
state say 72 degrees Fahrenheit and the

00:29:24,410 --> 00:29:29,750
controllers this continuous process that

00:29:26,990 --> 00:29:32,090
looks at what your desired state has

00:29:29,750 --> 00:29:33,680
been declared to be goes out and takes a

00:29:32,090 --> 00:29:36,260
measurement of the current state and

00:29:33,680 --> 00:29:42,740
does what is necessary to maintain that

00:29:36,260 --> 00:29:45,440
condition so this these controllers can

00:29:42,740 --> 00:29:48,940
take a declaration that I want X number

00:29:45,440 --> 00:29:51,830
of nodes of my horizontally scaled out

00:29:48,940 --> 00:29:52,550
stateful solution and simply make it

00:29:51,830 --> 00:29:54,800
happen

00:29:52,550 --> 00:29:58,280
health monitoring the health monitor

00:29:54,800 --> 00:30:00,890
this well it runs and engage in

00:29:58,280 --> 00:30:06,320
self-healing when things should things

00:30:00,890 --> 00:30:08,630
go wrong an operator is free to be

00:30:06,320 --> 00:30:11,330
layered upon other kubernetes concepts

00:30:08,630 --> 00:30:15,650
like stateful sets external persistent

00:30:11,330 --> 00:30:18,260
volume mounts etc and they often are but

00:30:15,650 --> 00:30:21,320
the bottom line is that kubernetes has

00:30:18,260 --> 00:30:25,010
an inventory that is out there now and

00:30:21,320 --> 00:30:29,060
growing of operators specifically built

00:30:25,010 --> 00:30:31,820
to support stateful apps if you want a

00:30:29,060 --> 00:30:33,410
demo of this I've got two suggestions

00:30:31,820 --> 00:30:38,060
here so tomorrow

00:30:33,410 --> 00:30:40,070
at 10:55 there's a session which is a

00:30:38,060 --> 00:30:43,820
tutorial of running stateful

00:30:40,070 --> 00:30:45,800
applications on kubernetes and during

00:30:43,820 --> 00:30:49,280
this tutorial which is going to involve

00:30:45,800 --> 00:30:52,580
sada lee of google and chris duchesne of

00:30:49,280 --> 00:30:57,530
the code group that I work in you're

00:30:52,580 --> 00:30:59,720
going to see a demo deploying stateful

00:30:57,530 --> 00:31:02,080
on kubernetes and it's an entir app

00:30:59,720 --> 00:31:03,850
using stateful and

00:31:02,080 --> 00:31:05,980
they're going to demonstrate first

00:31:03,850 --> 00:31:07,930
deploying it to the Google public cloud

00:31:05,980 --> 00:31:11,770
and then deploying the same app

00:31:07,930 --> 00:31:16,960
unchanged to an on-prem Hardware

00:31:11,770 --> 00:31:19,180
scenario and there's that there's

00:31:16,960 --> 00:31:21,460
actually user participation in this so

00:31:19,180 --> 00:31:23,890
bring your laptop finally if you're

00:31:21,460 --> 00:31:26,260
sticking around for maze oscon there is

00:31:23,890 --> 00:31:30,400
a workshop on building your first

00:31:26,260 --> 00:31:32,320
stateful service on DCOs so if this is a

00:31:30,400 --> 00:31:33,970
subject that interests you and you're

00:31:32,320 --> 00:31:37,360
potentially interested in either of

00:31:33,970 --> 00:31:41,260
these container orchestrators I'd

00:31:37,360 --> 00:31:45,670
recommend these sessions getting back to

00:31:41,260 --> 00:31:48,880
the 12 factors I'm not the first one to

00:31:45,670 --> 00:31:52,570
recognize the fact that as good as the

00:31:48,880 --> 00:31:55,060
12 factors was it perhaps is in in need

00:31:52,570 --> 00:31:57,700
of some embellishment it turns out that

00:31:55,060 --> 00:32:00,190
there's an O'Reilly book that is

00:31:57,700 --> 00:32:03,250
excellent in fact some of the ideas for

00:32:00,190 --> 00:32:06,550
my presentation came from this book as

00:32:03,250 --> 00:32:09,430
well as a presentation that I sat in at

00:32:06,550 --> 00:32:13,780
a meet-up by Randall Schwartz who is the

00:32:09,430 --> 00:32:16,150
MC of the Foss weekly show and at the

00:32:13,780 --> 00:32:18,880
end of my deck here I'll show a link to

00:32:16,150 --> 00:32:20,530
that will allow you to you'll have to

00:32:18,880 --> 00:32:23,350
give up your email but you can download

00:32:20,530 --> 00:32:28,600
a free copy a PDF of this O'Reilly book

00:32:23,350 --> 00:32:32,710
and it basically I'm making the point

00:32:28,600 --> 00:32:35,050
that the the specific 12 fact or line

00:32:32,710 --> 00:32:37,090
item that relates to stateful maybe

00:32:35,050 --> 00:32:39,160
needs an update but this book goes into

00:32:37,090 --> 00:32:41,260
more detail on other things of the 12

00:32:39,160 --> 00:32:43,600
factors and if you're deploying things

00:32:41,260 --> 00:32:45,610
on either a pass or a container

00:32:43,600 --> 00:32:51,910
Orchestrator system I recommend this

00:32:45,610 --> 00:32:53,890
book highly so it's stateful perfect on

00:32:51,910 --> 00:32:56,130
these container orchestrators no I'm

00:32:53,890 --> 00:32:59,620
gonna give you a warning up front that

00:32:56,130 --> 00:33:01,870
this is an active area but there are

00:32:59,620 --> 00:33:05,830
there are parts of this story of

00:33:01,870 --> 00:33:07,390
stateful on in containers on container

00:33:05,830 --> 00:33:09,130
orchestrators that are ripe for

00:33:07,390 --> 00:33:12,070
improvement

00:33:09,130 --> 00:33:15,670
the first one is backup you know to do

00:33:12,070 --> 00:33:19,630
backup right you need solutions

00:33:15,670 --> 00:33:21,580
like kissing of these applications and I

00:33:19,630 --> 00:33:24,400
mean the applications themselves things

00:33:21,580 --> 00:33:27,400
like Postgres typically have a CLI you

00:33:24,400 --> 00:33:31,630
can call to drain transaction and

00:33:27,400 --> 00:33:34,990
progress and get them to flush caches in

00:33:31,630 --> 00:33:37,600
memory down to the storage level so that

00:33:34,990 --> 00:33:40,240
the storage can be utilized in a backup

00:33:37,600 --> 00:33:43,420
but what you typically want to do in

00:33:40,240 --> 00:33:45,400
there is trigger a snapshot I mean in

00:33:43,420 --> 00:33:47,800
the old days in virtualization that

00:33:45,400 --> 00:33:51,130
storage was evolved to the point where

00:33:47,800 --> 00:33:53,230
with popular storage solutions they had

00:33:51,130 --> 00:33:55,480
built-in snapshot solutions where you

00:33:53,230 --> 00:33:57,970
just call an API saying snapshot this

00:33:55,480 --> 00:34:00,060
volume like that the snapshot is

00:33:57,970 --> 00:34:02,590
retained maybe in a copy-on-write

00:34:00,060 --> 00:34:04,780
scenario or something but then the

00:34:02,590 --> 00:34:08,800
database can go back immediately into

00:34:04,780 --> 00:34:12,070
production and the the outage related to

00:34:08,800 --> 00:34:15,160
a backup was typically miniscule and

00:34:12,070 --> 00:34:19,090
perhaps undetectable you know that that

00:34:15,160 --> 00:34:23,410
snapshot made that instantaneous I am

00:34:19,090 --> 00:34:25,780
working in with storage SIG's in both

00:34:23,410 --> 00:34:28,270
mais au s-- and kubernetes and i can

00:34:25,780 --> 00:34:31,630
tell you that these groups are working

00:34:28,270 --> 00:34:34,780
on support for snapshot now but it isn't

00:34:31,630 --> 00:34:40,570
there today so it's something that's

00:34:34,780 --> 00:34:43,720
something that's still in the air the

00:34:40,570 --> 00:34:45,940
second item is that storage plug-in

00:34:43,720 --> 00:34:48,010
drivers are not standardized against

00:34:45,940 --> 00:34:52,030
across these platforms now if you're a

00:34:48,010 --> 00:34:55,030
big organization that maybe is running

00:34:52,030 --> 00:34:57,250
multiple container orchestrators and

00:34:55,030 --> 00:35:00,100
they're non-uniform there are people out

00:34:57,250 --> 00:35:02,530
there who run one department in maze O's

00:35:00,100 --> 00:35:04,870
and a different one in kubernetes or one

00:35:02,530 --> 00:35:08,920
on a pass platform like Cloud Foundry

00:35:04,870 --> 00:35:11,740
and another on Apache maze O's it would

00:35:08,920 --> 00:35:14,940
be a great thing if this interface to

00:35:11,740 --> 00:35:18,040
the backing external volumes that you

00:35:14,940 --> 00:35:20,590
keep to store the persistent information

00:35:18,040 --> 00:35:22,330
was standardized but they're not there

00:35:20,590 --> 00:35:25,620
is an effort underway called the

00:35:22,330 --> 00:35:29,050
container storage interface that is a

00:35:25,620 --> 00:35:29,710
group of both Orchestrator suppliers

00:35:29,050 --> 00:35:33,430
like KU

00:35:29,710 --> 00:35:38,760
Bernays mezzos docker cloud foundry and

00:35:33,430 --> 00:35:42,520
storage providers like dell NetApp a

00:35:38,760 --> 00:35:44,619
long list who is working on this but it

00:35:42,520 --> 00:35:48,130
isn't out there yet so we're we're

00:35:44,619 --> 00:35:50,680
having meetings we're designing it my

00:35:48,130 --> 00:35:54,580
code group actually had the first

00:35:50,680 --> 00:35:56,530
release today of a provider for this

00:35:54,580 --> 00:35:59,530
container storage interface but it's

00:35:56,530 --> 00:36:01,480
written against what is really a draft

00:35:59,530 --> 00:36:03,640
standard at this point it hasn't been

00:36:01,480 --> 00:36:06,670
universally agreed to by this group but

00:36:03,640 --> 00:36:08,650
we felt we had to go first so we had a

00:36:06,670 --> 00:36:15,040
press release today announcing the fact

00:36:08,650 --> 00:36:17,260
that we came out there with a call it a

00:36:15,040 --> 00:36:19,900
validation suite for this principle of

00:36:17,260 --> 00:36:22,030
the container storage interface and I

00:36:19,900 --> 00:36:24,160
would compare this contort container

00:36:22,030 --> 00:36:29,710
storage interface to the efforts like

00:36:24,160 --> 00:36:32,230
the container network interface that

00:36:29,710 --> 00:36:34,510
have evolved in the container space to

00:36:32,230 --> 00:36:35,260
make things portable and that work is

00:36:34,510 --> 00:36:37,660
underway

00:36:35,260 --> 00:36:40,450
there are also some rough edges related

00:36:37,660 --> 00:36:42,820
to replication volume resizing etcetera

00:36:40,450 --> 00:36:44,440
things that you've typically had

00:36:42,820 --> 00:36:47,890
available for years in the

00:36:44,440 --> 00:36:53,920
virtualization space we're still working

00:36:47,890 --> 00:36:55,960
on those on containers now don't let

00:36:53,920 --> 00:36:58,420
that scare you you know I went there and

00:36:55,960 --> 00:37:00,849
told you the honest truth that some of

00:36:58,420 --> 00:37:03,060
these things aren't really comparable to

00:37:00,849 --> 00:37:05,890
what you might find with virtualization

00:37:03,060 --> 00:37:09,520
maybe with some past platforms that run

00:37:05,890 --> 00:37:11,920
on top of virtualization but I would

00:37:09,520 --> 00:37:15,040
contend that even though there are still

00:37:11,920 --> 00:37:18,430
some rough edges if you're somebody who

00:37:15,040 --> 00:37:20,380
can make serious use of this the time to

00:37:18,430 --> 00:37:22,720
get involved is not to wait till it's

00:37:20,380 --> 00:37:25,410
done but get involved now you know the

00:37:22,720 --> 00:37:28,420
whole model of open source isn't like

00:37:25,410 --> 00:37:30,040
commercial software I used to work in

00:37:28,420 --> 00:37:32,230
commercial software and the way that

00:37:30,040 --> 00:37:35,380
worked is a product would typically have

00:37:32,230 --> 00:37:37,630
a product manager or guy a guy with that

00:37:35,380 --> 00:37:40,000
product manager title who would try to

00:37:37,630 --> 00:37:42,400
deduce a feature list maybe he talks to

00:37:40,000 --> 00:37:43,420
the biggest customers kind of ask some

00:37:42,400 --> 00:37:45,790
what he wants go

00:37:43,420 --> 00:37:47,920
off and builds things and then comes

00:37:45,790 --> 00:37:51,940
down from the mountain with the product

00:37:47,920 --> 00:37:54,430
already carved out if that isn't your

00:37:51,940 --> 00:37:57,940
liking or if you want features later

00:37:54,430 --> 00:38:00,130
it's typically you know a long cycle to

00:37:57,940 --> 00:38:02,650
get what you really want in if you get

00:38:00,130 --> 00:38:04,680
involved in an open-source project like

00:38:02,650 --> 00:38:07,089
this today well it's still forming

00:38:04,680 --> 00:38:09,430
you're going to be in a position to

00:38:07,089 --> 00:38:12,940
actually contribute and basically get

00:38:09,430 --> 00:38:16,059
what you want if you get a seat at that

00:38:12,940 --> 00:38:20,049
table and participate as an end user to

00:38:16,059 --> 00:38:22,599
represent your use cases and I'm kind of

00:38:20,049 --> 00:38:24,940
sitting on the other side building you

00:38:22,599 --> 00:38:26,859
know the implementation of this but I

00:38:24,940 --> 00:38:28,900
can tell you from the meetings that

00:38:26,859 --> 00:38:31,210
we've got in things like the kubernetes

00:38:28,900 --> 00:38:34,210
storage sig that we'd love to have more

00:38:31,210 --> 00:38:36,309
user involvement representing your use

00:38:34,210 --> 00:38:39,069
cases so that we can build the things

00:38:36,309 --> 00:38:41,290
that people are actually likely to use

00:38:39,069 --> 00:38:43,720
the other benefit you'd get of

00:38:41,290 --> 00:38:46,359
participating on that level before it's

00:38:43,720 --> 00:38:47,980
fully Bank is that the bottom line is

00:38:46,359 --> 00:38:49,780
here that if you're really a big

00:38:47,980 --> 00:38:52,000
organization at scale let's face it

00:38:49,780 --> 00:38:53,290
you're gonna need to have your staff or

00:38:52,000 --> 00:38:55,540
at least some members of your staff

00:38:53,290 --> 00:38:57,700
trained in this right to be able to

00:38:55,540 --> 00:39:00,640
troubleshoot this when things go wrong

00:38:57,700 --> 00:39:02,410
nothing is ever flawless well I'll tell

00:39:00,640 --> 00:39:04,420
you the one of the best ways to get

00:39:02,410 --> 00:39:06,760
training would be to get there with a

00:39:04,420 --> 00:39:09,220
seat at the table as this thing is being

00:39:06,760 --> 00:39:11,349
architected and designed because you're

00:39:09,220 --> 00:39:13,450
anybody who does that is truly gonna

00:39:11,349 --> 00:39:16,030
understand this from top to bottom and

00:39:13,450 --> 00:39:18,339
if you do run into bugs you're likely to

00:39:16,030 --> 00:39:20,770
build up contacts with the actual

00:39:18,339 --> 00:39:22,660
developers you know if you have some of

00:39:20,770 --> 00:39:25,270
these meetings are face-to-face is some

00:39:22,660 --> 00:39:27,670
of them are on Google Hangouts or zoom

00:39:25,270 --> 00:39:30,579
video calls but you would get to know

00:39:27,670 --> 00:39:32,859
the actual developers and I suspect that

00:39:30,579 --> 00:39:35,170
the net result of that is that if your

00:39:32,859 --> 00:39:39,549
organization uses this in mystery

00:39:35,170 --> 00:39:42,910
critical things that you'd have you'd

00:39:39,549 --> 00:39:44,589
have a contact list to where you could

00:39:42,910 --> 00:39:48,280
call these people you'd know who they

00:39:44,589 --> 00:39:50,170
were and they'd return your call so I'd

00:39:48,280 --> 00:39:53,339
invite you to get involved if this is

00:39:50,170 --> 00:39:56,800
something that your organization is

00:39:53,339 --> 00:39:59,320
potentially could could

00:39:56,800 --> 00:40:04,570
from and I'd invite you to get involved

00:39:59,320 --> 00:40:10,540
like now before it's done I want to get

00:40:04,570 --> 00:40:13,720
back you know to I'm gonna suggest to

00:40:10,540 --> 00:40:15,340
you that the gestation of containers you

00:40:13,720 --> 00:40:17,260
know I showed you I opened this talk

00:40:15,340 --> 00:40:19,540
with kind of the history of containers

00:40:17,260 --> 00:40:24,820
showing that containers go all the way

00:40:19,540 --> 00:40:28,080
back to 1979 and they they took a while

00:40:24,820 --> 00:40:30,100
to actually get adopted i I think that

00:40:28,080 --> 00:40:32,860
containers really didn't hit the

00:40:30,100 --> 00:40:35,230
mainstream until docker came out myself

00:40:32,860 --> 00:40:38,230
and I would compare this to the adoption

00:40:35,230 --> 00:40:42,130
of the automobile it turns out that the

00:40:38,230 --> 00:40:43,810
first gasoline engine thing like an

00:40:42,130 --> 00:40:47,410
automobile it was an engine attached to

00:40:43,810 --> 00:40:51,190
the push cart came out in 1870 it was

00:40:47,410 --> 00:40:54,730
until 1885 that Carl Benz made the first

00:40:51,190 --> 00:40:56,410
gas automobile for sale that guy in 1870

00:40:54,730 --> 00:40:59,230
just made that push guard for himself

00:40:56,410 --> 00:41:01,990
and this was handmade but you could

00:40:59,230 --> 00:41:06,220
order it it was hand produced finally in

00:41:01,990 --> 00:41:12,370
1903 Henry Ford put together a factory

00:41:06,220 --> 00:41:15,190
to mass-produce the Model T now let's

00:41:12,370 --> 00:41:18,190
see the effects of that in 1900 before

00:41:15,190 --> 00:41:20,980
the Model T this is New York City Fifth

00:41:18,190 --> 00:41:24,160
Avenue believe it or not those are all

00:41:20,980 --> 00:41:27,300
horses but somewhere in there in fact

00:41:24,160 --> 00:41:31,810
it's right here there's one automobile

00:41:27,300 --> 00:41:35,160
so that's that's something that's 1900

00:41:31,810 --> 00:41:37,750
New York City just thirteen years later

00:41:35,160 --> 00:41:41,620
there's one horse in that picture and

00:41:37,750 --> 00:41:48,760
it's all gone automobile so a span of 13

00:41:41,620 --> 00:41:54,360
years you know I would contend that this

00:41:48,760 --> 00:41:57,190
ban took 34 years from that guy first

00:41:54,360 --> 00:41:59,680
building the hand push cart to when it

00:41:57,190 --> 00:42:02,530
got popularized and this is very

00:41:59,680 --> 00:42:06,130
comparable to the development of chroot

00:42:02,530 --> 00:42:09,190
in 1979 taking all the way till about

00:42:06,130 --> 00:42:11,109
now four containers to get mainstream

00:42:09,190 --> 00:42:12,819
but when things move

00:42:11,109 --> 00:42:16,839
they actually move pretty darn quickly

00:42:12,819 --> 00:42:19,329
and this field of containers is moving

00:42:16,839 --> 00:42:23,529
quickly and stateful in containers is

00:42:19,329 --> 00:42:26,019
moving quickly as well so I think that

00:42:23,529 --> 00:42:28,210
this we're only a few years out before

00:42:26,019 --> 00:42:31,059
containers are universal for both

00:42:28,210 --> 00:42:33,700
stateless and stateful and once again to

00:42:31,059 --> 00:42:35,950
my point this this is why I think you

00:42:33,700 --> 00:42:37,690
should get involved now even if it

00:42:35,950 --> 00:42:41,619
doesn't quite have things like the

00:42:37,690 --> 00:42:44,680
volume snapshots yet that's the end of

00:42:41,619 --> 00:42:46,210
my talk I'm going to just show you a few

00:42:44,680 --> 00:42:48,579
things here because I'm gonna leave you

00:42:46,210 --> 00:42:52,210
with a link to this deck but this is the

00:42:48,579 --> 00:42:54,430
ubercharge kind of I raced through this

00:42:52,210 --> 00:42:56,829
but this shows you the support for all

00:42:54,430 --> 00:42:59,440
the stateful apps on the various

00:42:56,829 --> 00:43:02,019
container orchestrators and if you get

00:42:59,440 --> 00:43:03,579
this deck this is actually a hyperlink

00:43:02,019 --> 00:43:06,309
that actually takes you to the

00:43:03,579 --> 00:43:08,289
repository and the documentation for

00:43:06,309 --> 00:43:10,089
what's going on there so you can learn

00:43:08,289 --> 00:43:13,809
how to deploy these on the various

00:43:10,089 --> 00:43:16,269
container orchestrators if you want to

00:43:13,809 --> 00:43:20,380
take a picture of this one I've already

00:43:16,269 --> 00:43:23,380
published this deck up on SlideShare so

00:43:20,380 --> 00:43:27,400
this will get you to this deck that top

00:43:23,380 --> 00:43:31,239
link is the free O'Reilly book on the 12

00:43:27,400 --> 00:43:32,799
factors revisited I'll just leave that

00:43:31,239 --> 00:43:36,069
up for another second so you can get

00:43:32,799 --> 00:43:38,440
pictures of this and I did release this

00:43:36,069 --> 00:43:41,680
to the Linux Foundation who should

00:43:38,440 --> 00:43:44,259
publish it in my experience they'll get

00:43:41,680 --> 00:43:47,200
it in a couple weeks but they generally

00:43:44,259 --> 00:43:49,420
publish them as PDFs and I can't promise

00:43:47,200 --> 00:43:54,489
you that it will have working hyperlinks

00:43:49,420 --> 00:43:57,190
so going here might be better finally

00:43:54,489 --> 00:43:59,970
should you want to contact me you can

00:43:57,190 --> 00:44:02,019
get me on twitter at that handle i

00:43:59,970 --> 00:44:03,910
unfortunately see now that these maybe

00:44:02,019 --> 00:44:07,420
aren't super readable but this is the

00:44:03,910 --> 00:44:11,589
group I work for we've got a booth down

00:44:07,420 --> 00:44:14,349
in the expo hall so come and see us that

00:44:11,589 --> 00:44:20,039
said I guess I have room for some

00:44:14,349 --> 00:44:20,039
questions here if anybody's got any yeah

00:45:11,820 --> 00:45:20,640
well I okay he's asking if people are

00:45:17,940 --> 00:45:25,130
actually using kubernetes stateful sets

00:45:20,640 --> 00:45:25,130
to run stateful apps in production

00:45:42,010 --> 00:45:47,780
well I I think that there are people

00:45:46,280 --> 00:45:50,330
running in in production but there's

00:45:47,780 --> 00:45:53,359
varying levels of tolerance right I mean

00:45:50,330 --> 00:45:58,220
some people have more tolerance for

00:45:53,359 --> 00:46:00,710
failure than others I you know it's so

00:45:58,220 --> 00:46:04,460
new that in some fields like financial

00:46:00,710 --> 00:46:06,680
transactions my gut feel is that those

00:46:04,460 --> 00:46:10,040
guys tend to be the last adopters of

00:46:06,680 --> 00:46:19,910
technology and some others are much more

00:46:10,040 --> 00:46:22,910
aggressive now on some of these I think

00:46:19,910 --> 00:46:24,230
that it almost is required that they run

00:46:22,910 --> 00:46:26,240
in containers so if you look at

00:46:24,230 --> 00:46:28,760
something like a big data fast data

00:46:26,240 --> 00:46:31,430
solution like a Kafka I think the

00:46:28,760 --> 00:46:34,430
reference platform for that is in fact

00:46:31,430 --> 00:46:37,040
running in on Apache maze osore DCOs

00:46:34,430 --> 00:46:39,290
that you'd be really out of the

00:46:37,040 --> 00:46:41,810
mainstream if you were to stand those

00:46:39,290 --> 00:46:46,580
things out off of a platform like that

00:46:41,810 --> 00:46:48,890
so I think a lot of this depends

00:46:46,580 --> 00:46:52,369
specifically on what the stateful app is

00:46:48,890 --> 00:46:54,260
and a lot of it is your tolerance for

00:46:52,369 --> 00:46:54,710
pain you know the stuff isn't perfect

00:46:54,260 --> 00:46:56,869
yet

00:46:54,710 --> 00:47:00,080
some of these stateful solutions

00:46:56,869 --> 00:47:02,060
actually are cluster aware so some of

00:47:00,080 --> 00:47:05,450
these could even be used without the

00:47:02,060 --> 00:47:07,760
external volume outs using gas but you

00:47:05,450 --> 00:47:09,890
would you know the downside of that is

00:47:07,760 --> 00:47:11,869
that if you get sufficiently big like

00:47:09,890 --> 00:47:13,910
let's say you scale out horizontally to

00:47:11,869 --> 00:47:16,460
a thousand nodes once you get to that

00:47:13,910 --> 00:47:18,920
size my contention is you've almost

00:47:16,460 --> 00:47:21,050
you've always got some nodes in failure

00:47:18,920 --> 00:47:23,630
right I mean the probabilities just

00:47:21,050 --> 00:47:29,770
creep up the bigger the size gets and

00:47:23,630 --> 00:47:29,770
the logistics of that yeah so

00:47:32,320 --> 00:47:41,300
well it isn't perfect let's put it that

00:47:36,080 --> 00:47:43,310
way and but there are early adopters who

00:47:41,300 --> 00:47:45,800
are already going there and a lot of it

00:47:43,310 --> 00:47:48,170
depends on what your stateful app is and

00:47:45,800 --> 00:47:50,210
a lot of it like I say depends on your

00:47:48,170 --> 00:47:51,830
tolerance for pain what'll will cost you

00:47:50,210 --> 00:47:54,440
if there's a glitch if I have to do a

00:47:51,830 --> 00:48:00,830
recovery from a back up if things go

00:47:54,440 --> 00:48:03,530
wrong there's no Universal yes/no even

00:48:00,830 --> 00:48:07,070
in virtualization which has been here I

00:48:03,530 --> 00:48:08,870
don't know how many decades I think if

00:48:07,070 --> 00:48:12,890
somebody told you it would never fail

00:48:08,870 --> 00:48:14,750
ever they're a liar I mean this this

00:48:12,890 --> 00:48:17,030
stuff maybe isn't as good as some of

00:48:14,750 --> 00:48:18,770
those other solutions but it has other

00:48:17,030 --> 00:48:23,150
benefits I mean if you really want

00:48:18,770 --> 00:48:25,880
portability across clouds you know I

00:48:23,150 --> 00:48:30,080
don't know if you've ever tried to take

00:48:25,880 --> 00:48:33,320
a virtual machine running on pram in one

00:48:30,080 --> 00:48:34,790
hypervisor and then move it in into the

00:48:33,320 --> 00:48:38,920
Amazon Cloud and then move it back

00:48:34,790 --> 00:48:41,000
because my own experience with that is a

00:48:38,920 --> 00:48:48,560
conclusion that they're really not

00:48:41,000 --> 00:48:51,380
portable at all so you know this maybe

00:48:48,560 --> 00:48:53,150
isn't as good as some solutions at some

00:48:51,380 --> 00:48:55,990
things but it's way better at others

00:48:53,150 --> 00:48:58,610
that and you have to decide on your own

00:48:55,990 --> 00:49:03,230
which of these attributes is important

00:48:58,610 --> 00:49:05,840
to you and I can see with all of the R&D

00:49:03,230 --> 00:49:08,600
effort and human manpower being invested

00:49:05,840 --> 00:49:12,310
in these open-source projects I mean all

00:49:08,600 --> 00:49:14,900
of those things on that chart have

00:49:12,310 --> 00:49:16,670
dozens if not hundreds of people behind

00:49:14,900 --> 00:49:19,790
them and there's a lot of effort going

00:49:16,670 --> 00:49:22,690
into this stuff too to build it up and

00:49:19,790 --> 00:49:25,789
the world is going there

00:49:22,690 --> 00:49:25,789
[Music]

00:49:29,580 --> 00:49:36,450
I think that depends on the app - I mean

00:49:34,920 --> 00:49:38,820
there are some of these stateful apps

00:49:36,450 --> 00:49:42,570
people build a stateful app for

00:49:38,820 --> 00:49:44,850
something like I know there's a guy Josh

00:49:42,570 --> 00:49:48,570
burkas who's like a guru of Postgres

00:49:44,850 --> 00:49:50,880
who's speaking here and he's the if

00:49:48,570 --> 00:49:53,220
you're curious about running Postgres

00:49:50,880 --> 00:49:57,450
it's would be a sharded Postgres

00:49:53,220 --> 00:49:59,850
database server on stateful set he's the

00:49:57,450 --> 00:50:03,300
guy writing it so I think I'd suggest

00:49:59,850 --> 00:50:06,060
that maybe you have to ask that question

00:50:03,300 --> 00:50:08,730
in the context of the specific stateful

00:50:06,060 --> 00:50:10,440
app you are trying to run because the

00:50:08,730 --> 00:50:12,900
answer is different for all of them and

00:50:10,440 --> 00:50:15,060
some of them are in a more advanced

00:50:12,900 --> 00:50:18,060
condition than others

00:50:15,060 --> 00:50:19,500
oh I even I just notice odd is here so

00:50:18,060 --> 00:50:21,750
he's somewhat of an authority on

00:50:19,500 --> 00:50:23,670
kubernetes - do you have anything - I

00:50:21,750 --> 00:50:57,200
hate to put the spot but maybe you can

00:50:23,670 --> 00:51:02,550
contribute to my answer there at least

00:50:57,200 --> 00:51:05,160
we're fairly stable it's far better than

00:51:02,550 --> 00:51:08,330
it was when we started about a year

00:51:05,160 --> 00:51:11,430
so people are trying it out we do have

00:51:08,330 --> 00:51:20,670
customers deploying stateful

00:51:11,430 --> 00:51:25,600
applications using kubernetes anybody

00:51:20,670 --> 00:51:30,150
else okay well thank you for coming

00:51:25,600 --> 00:51:30,150

YouTube URL: https://www.youtube.com/watch?v=W8t1Zo85ySM


