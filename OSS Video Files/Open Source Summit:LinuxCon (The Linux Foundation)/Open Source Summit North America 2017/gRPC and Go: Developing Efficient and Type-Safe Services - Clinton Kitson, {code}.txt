Title: gRPC and Go: Developing Efficient and Type-Safe Services - Clinton Kitson, {code}
Publication date: 2017-09-12
Playlist: Open Source Summit North America 2017
Description: 
	gRPC and Go: Developing Efficient and Type-Safe Services - Clinton Kitson, {code}

While REST, JSON over HTTP 1.1, is ubiquitous, it is a simple text-based protocol that was not designed to handle the demands of modern cloud-native service architectures. The gRPC project, originated from work at Google, is intended to continue where JSON stopped. It is a universal RPC protocol that uses binary payload over HTTP 2.0 for creating efficient, strongly typed, idiomatic and expressive service APIs using the language of your choice (ten so far).

In this session, speaker Vladimir Vivien explores the use of gRPC with the Go programming language. The session starts with the definition of a service using gRPC’s interface definition language (IDL). It continues on to create a working service while demonstrating the different gRPC API styles including uni-directional, bi-directional and streaming. Lastly, the session explores implications such client development, integration with existing JSON environments, and security.

Presentation topics:

- gRPC overview
- gRPC and the Go programming language
- Service definition and code generation
- Synchronous and asynchronous streaming APIs
- gRPC services with REST gateways
- Secure services

About Clinton Kitson
Clint is the Technical Director for the {code} open source initiative. He focuses on contributing and building community around emerging trends in software-based infrastructure, containers, open source, and DevOps. He represents Dell Technologies as a CNCF governing board member. His technical background is from the service provider and Casino Gaming industries with a focus on operations and architecture where he most recently led transformational initiatives in automation, virtualization, storage, and networking.

In his free time, Clint enjoys golf, gold mining, swimming, spending time with his family, and being the “handyman” around the house.
Captions: 
	00:00:00,000 --> 00:00:05,879
who all here came to see Vlad anybody

00:00:02,250 --> 00:00:09,719
know who blattis Vlad is actually on my

00:00:05,879 --> 00:00:13,259
team but he's up in the top left picture

00:00:09,719 --> 00:00:15,780
here in Florida so he was hit in Tampa

00:00:13,259 --> 00:00:17,640
but luckily family's safe house is okay

00:00:15,780 --> 00:00:19,410
but he couldn't make it here to the

00:00:17,640 --> 00:00:20,550
conference so I am here for you instead

00:00:19,410 --> 00:00:22,199
of lad

00:00:20,550 --> 00:00:24,689
so Vlad is actually an author he's

00:00:22,199 --> 00:00:26,460
written this fantastic book on go he's

00:00:24,689 --> 00:00:29,519
actively on Twitter and he's a part of

00:00:26,460 --> 00:00:31,410
the the code team code is a open source

00:00:29,519 --> 00:00:33,570
initiative at Dell focused on

00:00:31,410 --> 00:00:35,850
contributing and building ecosystems and

00:00:33,570 --> 00:00:37,739
community all wrapped around emerging

00:00:35,850 --> 00:00:39,180
technologies so my team is really a

00:00:37,739 --> 00:00:41,399
group of open-source engineers and

00:00:39,180 --> 00:00:44,270
developer advocates that focuses on all

00:00:41,399 --> 00:00:48,660
kinds of cool technology i'ma go

00:00:44,270 --> 00:00:50,670
advocate i'ma go developer I've written

00:00:48,660 --> 00:00:53,129
plenty of stuff I'll tell you that Vlad

00:00:50,670 --> 00:00:55,140
is the deep dive guy but I'll do my best

00:00:53,129 --> 00:00:57,980
for you guys so if you have questions I

00:00:55,140 --> 00:01:01,980
may defer but let's see how those goes

00:00:57,980 --> 00:01:03,840
so we got three objectives today for the

00:01:01,980 --> 00:01:06,180
presentation first of all let's talk

00:01:03,840 --> 00:01:09,030
about why G RPC I've actually got a ton

00:01:06,180 --> 00:01:12,810
of experience in developing you know

00:01:09,030 --> 00:01:14,850
rest and HTTP based HTTP based

00:01:12,810 --> 00:01:16,680
interfaces so we'll talk a little bit

00:01:14,850 --> 00:01:19,920
about you know where we've been and why

00:01:16,680 --> 00:01:22,680
we're here at CR PC we'll go through an

00:01:19,920 --> 00:01:24,000
example of a GRP service and then we'll

00:01:22,680 --> 00:01:27,900
look at some of the extra features that

00:01:24,000 --> 00:01:30,240
you get by way of G RPC natively so why

00:01:27,900 --> 00:01:32,100
G RPC like what are we really trying to

00:01:30,240 --> 00:01:33,900
do now we're trying to connect two

00:01:32,100 --> 00:01:37,290
components together and we want to do

00:01:33,900 --> 00:01:39,630
this in as simple a way as possible if

00:01:37,290 --> 00:01:42,030
you look at the the orange depiction

00:01:39,630 --> 00:01:43,110
from component 1 and component 2 we just

00:01:42,030 --> 00:01:45,000
want that to be a straight line we

00:01:43,110 --> 00:01:47,579
wanted to be invisible right that should

00:01:45,000 --> 00:01:49,140
be as easy as it gets because connecting

00:01:47,579 --> 00:01:51,240
two components together isn't where the

00:01:49,140 --> 00:01:52,890
value is like the the workings in

00:01:51,240 --> 00:01:54,270
between them the value is just having

00:01:52,890 --> 00:01:56,340
those two things talk to each other so

00:01:54,270 --> 00:01:58,049
there's this crooked path that we can

00:01:56,340 --> 00:02:00,000
walk to get two components to talk to

00:01:58,049 --> 00:02:01,979
each other and that involves having

00:02:00,000 --> 00:02:03,930
discussions about rest like building a

00:02:01,979 --> 00:02:06,420
full rest model around having two things

00:02:03,930 --> 00:02:09,450
work together very difficult involves

00:02:06,420 --> 00:02:11,520
existing you know RPC methodologies that

00:02:09,450 --> 00:02:13,920
may be native to languages

00:02:11,520 --> 00:02:15,780
maybe it's HTV JSON to make a simple

00:02:13,920 --> 00:02:17,250
interface there's lots of discussions

00:02:15,780 --> 00:02:18,840
that happen around just how you connect

00:02:17,250 --> 00:02:20,010
two things together so I'm I'm pretty

00:02:18,840 --> 00:02:21,900
excited about what we're gonna talk

00:02:20,010 --> 00:02:23,940
about today which is simplifying this

00:02:21,900 --> 00:02:25,710
and standardizing it as you look at

00:02:23,940 --> 00:02:29,840
building out this communication between

00:02:25,710 --> 00:02:31,770
components so what's the situation today

00:02:29,840 --> 00:02:33,780
you know that it's really interesting

00:02:31,770 --> 00:02:36,990
because technology is changing the

00:02:33,780 --> 00:02:39,480
demand for interoperability is

00:02:36,990 --> 00:02:41,310
increasing day by day you know the user

00:02:39,480 --> 00:02:44,520
experience when I look at something like

00:02:41,310 --> 00:02:46,320
this like a my phone right most of us

00:02:44,520 --> 00:02:47,730
use our phone almost eight all day long

00:02:46,320 --> 00:02:49,560
and that user experience and

00:02:47,730 --> 00:02:51,270
responsiveness is really important to us

00:02:49,560 --> 00:02:52,710
but we travel through all kinds of

00:02:51,270 --> 00:02:55,410
different coverage zones through cell

00:02:52,710 --> 00:02:56,970
sites and stuff like that and getting

00:02:55,410 --> 00:02:58,860
the bandwidth getting the responsiveness

00:02:56,970 --> 00:03:00,900
it's just critical to user experience so

00:02:58,860 --> 00:03:03,480
we want to be as efficient as we can be

00:03:00,900 --> 00:03:05,730
when we talk about interoperating and it

00:03:03,480 --> 00:03:07,770
may be a service to a service it may be

00:03:05,730 --> 00:03:09,450
a phone to a service right we want all

00:03:07,770 --> 00:03:12,210
that communication to be super efficient

00:03:09,450 --> 00:03:13,770
so you know mobile technology is driving

00:03:12,210 --> 00:03:16,050
some changes here the other thing that's

00:03:13,770 --> 00:03:18,120
happening is software architectures are

00:03:16,050 --> 00:03:20,340
changing as well so we look at like a

00:03:18,120 --> 00:03:22,020
monolith application it was pretty

00:03:20,340 --> 00:03:23,220
simple to have different pieces of the

00:03:22,020 --> 00:03:25,650
application communicate because you're

00:03:23,220 --> 00:03:27,540
using you know in-memory processes that

00:03:25,650 --> 00:03:28,740
that just can naturally call functions

00:03:27,540 --> 00:03:30,120
and stuff like that

00:03:28,740 --> 00:03:31,830
but we look at taking these big mono

00:03:30,120 --> 00:03:34,860
lists and splitting them out to some

00:03:31,830 --> 00:03:36,510
type of logical you know micro services

00:03:34,860 --> 00:03:37,800
then you have to think about how these

00:03:36,510 --> 00:03:38,850
things are going to communicate with

00:03:37,800 --> 00:03:41,520
each other

00:03:38,850 --> 00:03:43,530
you're gonna develop your own JSON API

00:03:41,520 --> 00:03:45,120
or are you gonna use something simple to

00:03:43,530 --> 00:03:47,730
connected two components together at

00:03:45,120 --> 00:03:49,710
that point so you know that the mobile

00:03:47,730 --> 00:03:51,360
technology the changing you know

00:03:49,710 --> 00:03:53,490
software architectures and turn it in

00:03:51,360 --> 00:03:55,440
terms of using micro services these are

00:03:53,490 --> 00:03:59,240
both driving the need for something

00:03:55,440 --> 00:04:02,030
light to your PC so what's a scenario

00:03:59,240 --> 00:04:05,370
we've got a currency service for example

00:04:02,030 --> 00:04:07,250
the currency has a lookup capability

00:04:05,370 --> 00:04:10,440
that we're trying to expose in some way

00:04:07,250 --> 00:04:12,450
if you have a mobile client maybe it's

00:04:10,440 --> 00:04:14,040
Android that wants to use this service

00:04:12,450 --> 00:04:16,710
so I'm talking about developing a

00:04:14,040 --> 00:04:19,020
web-based app for example maybe it's an

00:04:16,710 --> 00:04:21,390
iPhone where I'd need to develop and

00:04:19,020 --> 00:04:23,020
c-sharp maybe it's a back-end process

00:04:21,390 --> 00:04:25,840
with Java Python go

00:04:23,020 --> 00:04:28,360
rust something like that maybe it's a

00:04:25,840 --> 00:04:31,060
desktop tool and it's running Seashore

00:04:28,360 --> 00:04:32,500
it's developed in c-sharp or Java and

00:04:31,060 --> 00:04:33,370
maybe it's a website back-end using

00:04:32,500 --> 00:04:36,430
nodejs

00:04:33,370 --> 00:04:37,930
write all different languages but you

00:04:36,430 --> 00:04:40,539
want to expose that functionality to

00:04:37,930 --> 00:04:42,129
this lookup service consistently so the

00:04:40,539 --> 00:04:44,349
problem is that there's multiple systems

00:04:42,129 --> 00:04:46,629
the you know if you if you're taking

00:04:44,349 --> 00:04:48,759
this mobile device area it's all

00:04:46,629 --> 00:04:50,560
bandwidth constrained in terms of you

00:04:48,759 --> 00:04:51,909
know working from a cellular site and

00:04:50,560 --> 00:04:53,139
getting the bandwidth all the way to the

00:04:51,909 --> 00:04:55,030
data center right it's something that

00:04:53,139 --> 00:04:56,800
should be really efficient you talk

00:04:55,030 --> 00:04:58,690
about real time data access so maybe

00:04:56,800 --> 00:05:00,669
you're streaming in terms of you know

00:04:58,690 --> 00:05:03,970
sending chunks of data rather than you

00:05:00,669 --> 00:05:07,150
know large globs of data different

00:05:03,970 --> 00:05:08,650
languages and platforms and the need to

00:05:07,150 --> 00:05:11,710
even version right if you're developing

00:05:08,650 --> 00:05:13,180
a centralized version of a service you

00:05:11,710 --> 00:05:14,380
know if you want to upgrade that service

00:05:13,180 --> 00:05:17,349
then you're gonna have to figure out a

00:05:14,380 --> 00:05:20,169
great versioning ability so that you're

00:05:17,349 --> 00:05:22,449
you're consuming languages they're able

00:05:20,169 --> 00:05:23,860
to interpret things correctly and

00:05:22,449 --> 00:05:25,599
backward compatibility so these are all

00:05:23,860 --> 00:05:27,039
like a bunch of things to consider as

00:05:25,599 --> 00:05:29,020
you're building out the service and

00:05:27,039 --> 00:05:31,990
making it platform agnostic at the end

00:05:29,020 --> 00:05:34,569
of the day so in comes kind of our first

00:05:31,990 --> 00:05:38,650
thing we'll talk about which is RPC over

00:05:34,569 --> 00:05:41,349
HTTP JSON this is a pretty good solution

00:05:38,650 --> 00:05:43,539
it's simple it's flexible it's kind of

00:05:41,349 --> 00:05:46,029
universally accepted the point here is

00:05:43,539 --> 00:05:48,969
when you have a RPC JSON interface

00:05:46,029 --> 00:05:50,289
you're doing a lot of the work right you

00:05:48,969 --> 00:05:53,380
basically said I've got two components

00:05:50,289 --> 00:05:54,580
and I'm gonna start with languages and I

00:05:53,380 --> 00:05:56,560
have to build like soup to nuts

00:05:54,580 --> 00:05:58,259
everything in that language to make

00:05:56,560 --> 00:06:01,060
these two things work working a

00:05:58,259 --> 00:06:03,159
interoperate and then if I want to build

00:06:01,060 --> 00:06:04,300
in safeguards like type checking and

00:06:03,159 --> 00:06:06,969
stuff like that to make it more

00:06:04,300 --> 00:06:08,469
consistent and predictable that's all on

00:06:06,969 --> 00:06:11,860
me to develop in every single language

00:06:08,469 --> 00:06:14,199
right so an RPC over HB JSON that's kind

00:06:11,860 --> 00:06:15,729
of a simple interface you'll see it

00:06:14,199 --> 00:06:17,560
pretty consistently across a lot of

00:06:15,729 --> 00:06:19,900
different technologies but it's got its

00:06:17,560 --> 00:06:21,490
downsides in terms of being predictable

00:06:19,900 --> 00:06:23,080
and it's got its downsides in terms of

00:06:21,490 --> 00:06:28,090
adoption and different languages and

00:06:23,080 --> 00:06:29,979
platforms I covered the data typing I

00:06:28,090 --> 00:06:33,580
think a big thing to cover here as well

00:06:29,979 --> 00:06:35,830
is the efficiency I'll give an example

00:06:33,580 --> 00:06:36,770
in a little bit but you know the idea

00:06:35,830 --> 00:06:38,629
that I'm going to take

00:06:36,770 --> 00:06:41,509
a language and I'm gonna have it

00:06:38,629 --> 00:06:42,889
communicate over a text and then I'm

00:06:41,509 --> 00:06:45,229
gonna have like serialization and

00:06:42,889 --> 00:06:47,030
deserialization of that text to try to

00:06:45,229 --> 00:06:49,610
fit it into object models after that

00:06:47,030 --> 00:06:51,379
it's very inefficient like it takes a

00:06:49,610 --> 00:06:54,289
lot of CPU cycles to actually do that

00:06:51,379 --> 00:06:56,780
translation and and send stuff over task

00:06:54,289 --> 00:06:58,250
text so it's really inefficient when you

00:06:56,780 --> 00:07:01,970
start looking at the the way it's

00:06:58,250 --> 00:07:04,159
transferring the data another important

00:07:01,970 --> 00:07:07,159
thing here is you know we're we're using

00:07:04,159 --> 00:07:09,409
HTTP as a transport and it's not a

00:07:07,159 --> 00:07:12,800
perfect translation between a language

00:07:09,409 --> 00:07:15,860
and the HTTP protocol so if I want to

00:07:12,800 --> 00:07:17,449
use errors for example you might think

00:07:15,860 --> 00:07:19,190
hey I can take my errors for my language

00:07:17,449 --> 00:07:21,409
and kind of encode them in the error

00:07:19,190 --> 00:07:24,229
response but that's not really true

00:07:21,409 --> 00:07:26,180
because errors in HTTP shouldn't include

00:07:24,229 --> 00:07:29,060
that type of the body so you can't

00:07:26,180 --> 00:07:30,800
really use the HTTP like protocol to

00:07:29,060 --> 00:07:32,870
encode like language specific

00:07:30,800 --> 00:07:34,870
information it just doesn't work out it

00:07:32,870 --> 00:07:37,490
doesn't translate in the right way so

00:07:34,870 --> 00:07:38,840
there's lots of work to do essentially

00:07:37,490 --> 00:07:40,909
if you want to take advantage of

00:07:38,840 --> 00:07:44,860
something like HTTP and throw your own

00:07:40,909 --> 00:07:47,509
JSON messaging layer and accomplish RPC

00:07:44,860 --> 00:07:51,440
so the next thing that people look at is

00:07:47,509 --> 00:07:54,620
well how about rest so if I if I say

00:07:51,440 --> 00:07:55,969
HTTP JSON and I say rest and they're

00:07:54,620 --> 00:07:58,279
completely two different things do you

00:07:55,969 --> 00:08:01,960
guys anybody disagree with that does

00:07:58,279 --> 00:08:05,900
that make sense or not let's say okay

00:08:01,960 --> 00:08:07,880
they are completely different HTTP JSON

00:08:05,900 --> 00:08:10,909
is just simply a way of encoding

00:08:07,880 --> 00:08:12,199
information and RPC is basically saying

00:08:10,909 --> 00:08:15,310
I'm gonna send these remote procedure

00:08:12,199 --> 00:08:18,710
calls over this transport essentially

00:08:15,310 --> 00:08:20,960
rest is actually kind of builds on top

00:08:18,710 --> 00:08:23,569
of those fundamentals rest actually

00:08:20,960 --> 00:08:26,210
leverages something like HTTP JSON but

00:08:23,569 --> 00:08:30,469
it's this idea that I can have a common

00:08:26,210 --> 00:08:32,990
way for developers to communicate the

00:08:30,469 --> 00:08:36,500
idea is like I want to be able to have a

00:08:32,990 --> 00:08:39,169
language point at an endpoint and if

00:08:36,500 --> 00:08:40,940
it's restful then that language should

00:08:39,169 --> 00:08:42,349
be able to figure out how to do

00:08:40,940 --> 00:08:45,050
everything it needs to do with that

00:08:42,349 --> 00:08:47,930
interface and so what that means is like

00:08:45,050 --> 00:08:50,630
to be a truly restful interface it needs

00:08:47,930 --> 00:08:52,890
to be self discoverable

00:08:50,630 --> 00:08:55,980
so it's kind of an interesting point so

00:08:52,890 --> 00:08:59,430
what is self discoverable in human terms

00:08:55,980 --> 00:09:02,910
in human terms it's basically the Google

00:08:59,430 --> 00:09:06,240
interface right for Google that is our

00:09:02,910 --> 00:09:08,220
UI to a search engine and I go to Google

00:09:06,240 --> 00:09:10,470
and I enter in whatever I want to search

00:09:08,220 --> 00:09:12,570
and I just know that that's how I get

00:09:10,470 --> 00:09:15,300
done what I want to get done I've

00:09:12,570 --> 00:09:17,610
learned about it all right so that's the

00:09:15,300 --> 00:09:19,200
UI and that is essentially self

00:09:17,610 --> 00:09:22,410
discoverable I've already figured it out

00:09:19,200 --> 00:09:26,520
I know how to use it in the case of

00:09:22,410 --> 00:09:28,649
computers how do I get a computer right

00:09:26,520 --> 00:09:31,020
orab learn it or an application to point

00:09:28,649 --> 00:09:33,810
at some end point and know what to do

00:09:31,020 --> 00:09:36,870
already alright and that's the idea of

00:09:33,810 --> 00:09:38,820
rest is there's a a pattern that can be

00:09:36,870 --> 00:09:41,940
employed which is the mais pattern and

00:09:38,820 --> 00:09:44,130
the mais pattern basically says take it

00:09:41,940 --> 00:09:46,170
application point it at this end point

00:09:44,130 --> 00:09:47,970
and when it gets there it's gonna know

00:09:46,170 --> 00:09:50,459
how to discover exactly what it can do

00:09:47,970 --> 00:09:53,190
it's gonna say okay here's an interface

00:09:50,459 --> 00:09:54,899
it's gonna list a menu you can go up you

00:09:53,190 --> 00:09:57,120
can go down you go left to get right you

00:09:54,899 --> 00:09:59,459
can go enter and that's gonna define

00:09:57,120 --> 00:10:01,500
like the ability to kind of traverse a

00:09:59,459 --> 00:10:03,959
hierarchy so when you look at like an

00:10:01,500 --> 00:10:07,320
arrest object model it's gonna include

00:10:03,959 --> 00:10:08,610
all kinds of different object types it's

00:10:07,320 --> 00:10:10,290
going to include all kinds of different

00:10:08,610 --> 00:10:12,209
actions you can do on these objects and

00:10:10,290 --> 00:10:14,579
that whole model is going to be self

00:10:12,209 --> 00:10:16,050
discoverable all right so that's the big

00:10:14,579 --> 00:10:18,839
difference between say something that's

00:10:16,050 --> 00:10:20,459
HB JSON like an RPC interface where you

00:10:18,839 --> 00:10:23,339
define all that ahead of time in a

00:10:20,459 --> 00:10:25,320
language and a rest interface which is

00:10:23,339 --> 00:10:27,209
self discoverable meaning you point a

00:10:25,320 --> 00:10:29,010
language at a rest endpoint and all of a

00:10:27,209 --> 00:10:31,860
sudden the language knows exactly what

00:10:29,010 --> 00:10:33,930
it can do the latter

00:10:31,860 --> 00:10:35,610
this whole rest interface which is the

00:10:33,930 --> 00:10:37,170
Nirvana essentially the holy grail of

00:10:35,610 --> 00:10:38,940
what we're really what's really trying

00:10:37,170 --> 00:10:42,000
to be accomplished make it simple to

00:10:38,940 --> 00:10:44,130
leverage any type of endpoint it's very

00:10:42,000 --> 00:10:45,990
difficult a people were write books on

00:10:44,130 --> 00:10:48,510
this stuff right there's conferences

00:10:45,990 --> 00:10:52,170
that are dedicated to building out truly

00:10:48,510 --> 00:10:53,520
restful services I highly suggest them

00:10:52,170 --> 00:10:55,200
if you're interested in actually

00:10:53,520 --> 00:10:57,510
pursuing a rest interface there's good

00:10:55,200 --> 00:10:59,100
reasons to still do so I highly suggest

00:10:57,510 --> 00:11:01,260
kind of researching and seeing what

00:10:59,100 --> 00:11:03,500
that's all about if you've heard of

00:11:01,260 --> 00:11:06,860
something like swagger or ap

00:11:03,500 --> 00:11:09,410
Yury right these are all kind of

00:11:06,860 --> 00:11:11,660
attempts at building frameworks around

00:11:09,410 --> 00:11:13,640
helping you build a rest interface and

00:11:11,660 --> 00:11:16,070
then what that should end up doing is

00:11:13,640 --> 00:11:18,080
giving you these API bindings in your

00:11:16,070 --> 00:11:20,090
languages that you can actually make use

00:11:18,080 --> 00:11:21,650
of in your applications to to solve the

00:11:20,090 --> 00:11:25,130
same problem that your RPC is trying to

00:11:21,650 --> 00:11:27,260
solve so you've got HTP json you've got

00:11:25,130 --> 00:11:29,660
RPC over that you've got these self

00:11:27,260 --> 00:11:31,640
discoverable rest interfaces which are

00:11:29,660 --> 00:11:33,920
made easier by way of something like

00:11:31,640 --> 00:11:35,660
swagger right and then you've got

00:11:33,920 --> 00:11:39,080
something like C RPC that that we're

00:11:35,660 --> 00:11:40,850
going to talk about so I mean if you

00:11:39,080 --> 00:11:42,650
look at this thread online this guy

00:11:40,850 --> 00:11:45,260
Simon Brown that I met this last weekend

00:11:42,650 --> 00:11:47,030
at software circus in the Europe he he

00:11:45,260 --> 00:11:49,670
consults with customers about software

00:11:47,030 --> 00:11:52,310
architecture and what he said down here

00:11:49,670 --> 00:11:55,310
is I've heard advice such as break up

00:11:52,310 --> 00:11:57,320
your monolith into micro services with

00:11:55,310 --> 00:11:59,510
REST API is between them a number of

00:11:57,320 --> 00:12:00,740
time this times this week and then the

00:11:59,510 --> 00:12:02,420
toffee says I've met a number of

00:12:00,740 --> 00:12:04,520
organizations who have done just this

00:12:02,420 --> 00:12:07,670
and they're now struggling for obvious

00:12:04,520 --> 00:12:09,230
reasons it's basically a bad idea right

00:12:07,670 --> 00:12:10,790
if you're gonna take an application and

00:12:09,230 --> 00:12:12,500
you're gonna split it up into micro

00:12:10,790 --> 00:12:14,390
services and then you're gonna have to

00:12:12,500 --> 00:12:17,180
take the time to define a REST API

00:12:14,390 --> 00:12:18,530
between every single service that's a

00:12:17,180 --> 00:12:19,910
lot of time and effort and you're

00:12:18,530 --> 00:12:21,230
probably not gonna get the value out of

00:12:19,910 --> 00:12:23,180
that that you need to so there's got to

00:12:21,230 --> 00:12:27,110
be a better way of getting these things

00:12:23,180 --> 00:12:29,000
to communicate so here's the kind of the

00:12:27,110 --> 00:12:31,910
summary slide of what I've been talking

00:12:29,000 --> 00:12:33,410
about in terms of setting up G RPC on

00:12:31,910 --> 00:12:36,110
the left side you've got some of these

00:12:33,410 --> 00:12:38,060
attempts at building or making it easier

00:12:36,110 --> 00:12:41,150
to build these interfaces who all's use

00:12:38,060 --> 00:12:44,810
soap before yeah what do you think about

00:12:41,150 --> 00:12:49,310
it for that for the record there's a lot

00:12:44,810 --> 00:12:51,560
of thumbs down I would say inefficient

00:12:49,310 --> 00:12:53,810
like if you have a large service by the

00:12:51,560 --> 00:12:56,330
time like the wisdom file is essentially

00:12:53,810 --> 00:12:58,070
this interface definition by the time

00:12:56,330 --> 00:13:00,230
this wisdom file gets consumed by a

00:12:58,070 --> 00:13:01,610
language I mean the the memory footprint

00:13:00,230 --> 00:13:04,520
is just insane sometimes

00:13:01,610 --> 00:13:08,300
so I'd say largely an efficient I talked

00:13:04,520 --> 00:13:09,770
about the serialization XML although

00:13:08,300 --> 00:13:11,930
very advanced in terms of the data

00:13:09,770 --> 00:13:14,839
structures you can encode inside of XML

00:13:11,930 --> 00:13:16,620
very heavy on the CPU right so very

00:13:14,839 --> 00:13:18,780
inefficient from a transport

00:13:16,620 --> 00:13:21,180
spective so soap is one that's been

00:13:18,780 --> 00:13:22,830
around for a long time another

00:13:21,180 --> 00:13:25,140
interesting point about it is that it's

00:13:22,830 --> 00:13:26,700
idiomatic in terms of client server so

00:13:25,140 --> 00:13:28,470
soap

00:13:26,700 --> 00:13:30,090
there's frameworks that have been

00:13:28,470 --> 00:13:32,670
written for different languages whether

00:13:30,090 --> 00:13:34,890
that's go or Python or anything else and

00:13:32,670 --> 00:13:36,990
it should help you actually create these

00:13:34,890 --> 00:13:41,010
language bindings that are soap and

00:13:36,990 --> 00:13:43,350
abled so the e Tomek why's like soap

00:13:41,010 --> 00:13:45,030
does have stuff that's out there but the

00:13:43,350 --> 00:13:46,980
problem is that it's not part of the

00:13:45,030 --> 00:13:48,900
soap project it's maintained

00:13:46,980 --> 00:13:50,250
independently by a bunch of people who

00:13:48,900 --> 00:13:52,020
care about those languages

00:13:50,250 --> 00:13:55,080
so there are frameworks that help you

00:13:52,020 --> 00:13:58,010
create idiomatic connectivity it's so

00:13:55,080 --> 00:14:01,200
curl friendly can you just pop open a

00:13:58,010 --> 00:14:03,540
you know a bash session and just go open

00:14:01,200 --> 00:14:04,650
a soap interface not really right so

00:14:03,540 --> 00:14:09,000
it's a little bit more difficult to

00:14:04,650 --> 00:14:12,240
troubleshoot yeah so inefficient I'd say

00:14:09,000 --> 00:14:13,860
no predictable somewhat because you've

00:14:12,240 --> 00:14:15,630
got your bindings newer languages on a

00:14:13,860 --> 00:14:17,460
client-server basis and that does

00:14:15,630 --> 00:14:19,260
provide some predictability you didn't

00:14:17,460 --> 00:14:21,600
build that all yourself there's some

00:14:19,260 --> 00:14:24,840
datatype validation to it so the next

00:14:21,600 --> 00:14:25,830
one down here is RPC over JSON which is

00:14:24,840 --> 00:14:27,420
basically where you said I'm gonna

00:14:25,830 --> 00:14:31,020
create my own interface but what the

00:14:27,420 --> 00:14:32,880
minimal amount of work at that point you

00:14:31,020 --> 00:14:34,380
don't have a client server stubs or

00:14:32,880 --> 00:14:35,520
client server bindings to take advantage

00:14:34,380 --> 00:14:37,980
of you got to write it all from scratch

00:14:35,520 --> 00:14:39,540
so lots of work just to make every

00:14:37,980 --> 00:14:42,720
language compatible if that's what you

00:14:39,540 --> 00:14:44,100
need to do it is curl friendly right so

00:14:42,720 --> 00:14:45,630
if you want to troubleshoot it you want

00:14:44,100 --> 00:14:47,610
to do testing on it by way of pulling up

00:14:45,630 --> 00:14:48,960
curl then that's available so that's

00:14:47,610 --> 00:14:51,120
kind of cool

00:14:48,960 --> 00:14:52,710
the frameworks are all custom to help

00:14:51,120 --> 00:14:56,460
take advantage of it

00:14:52,710 --> 00:14:58,410
there's serialization is whatever you

00:14:56,460 --> 00:15:00,270
want it to be JSON something like that

00:14:58,410 --> 00:15:03,330
it's probably not efficient and

00:15:00,270 --> 00:15:05,130
definitely not predictable custom rest

00:15:03,330 --> 00:15:07,410
the difference with the custom rest is

00:15:05,130 --> 00:15:09,210
that you probably took the time to build

00:15:07,410 --> 00:15:11,340
your own framework so rather than

00:15:09,210 --> 00:15:13,890
leveraging swagger or something like

00:15:11,340 --> 00:15:15,180
that you said hey I swagger doesn't do

00:15:13,890 --> 00:15:16,350
exactly what I need it doesn't fit my

00:15:15,180 --> 00:15:18,540
use case I'm gonna actually build

00:15:16,350 --> 00:15:21,090
swagger from scratch like we've done

00:15:18,540 --> 00:15:22,440
that and it's not too fun right but it

00:15:21,090 --> 00:15:24,780
does get you to be a little bit more

00:15:22,440 --> 00:15:27,990
predictable so that's what custom rest

00:15:24,780 --> 00:15:29,779
is all about it's not efficient and it's

00:15:27,990 --> 00:15:31,860
probably not predictable

00:15:29,779 --> 00:15:35,040
under arrest that's where we cover

00:15:31,860 --> 00:15:37,619
swagger you do get your idiomatic

00:15:35,040 --> 00:15:41,100
client/server stubs it is girl friendly

00:15:37,619 --> 00:15:43,139
at times but it's not efficient not

00:15:41,100 --> 00:15:45,809
predictable the very bottom one is where

00:15:43,139 --> 00:15:49,139
we get to GRP see so why is GRP so cool

00:15:45,809 --> 00:15:51,509
well the the stubs the bindings that you

00:15:49,139 --> 00:15:53,220
use for T RPC are all generated by way

00:15:51,509 --> 00:15:56,100
of the G RPC project

00:15:53,220 --> 00:15:58,139
so as the G RPC standard for protobuf

00:15:56,100 --> 00:15:59,879
etc is maintained and move forward then

00:15:58,139 --> 00:16:02,069
your bindings at the language level or

00:15:59,879 --> 00:16:05,069
actually all put out as well so they're

00:16:02,069 --> 00:16:06,959
all in sync chair pcs not curl friendly

00:16:05,069 --> 00:16:07,949
that's kind of an important point like

00:16:06,959 --> 00:16:10,350
but they have their own tools for

00:16:07,949 --> 00:16:12,569
troubleshooting but is that really

00:16:10,350 --> 00:16:14,999
important like if you're developing your

00:16:12,569 --> 00:16:16,759
application and I said hey the trade-off

00:16:14,999 --> 00:16:19,860
is that you're either curl friendly or

00:16:16,759 --> 00:16:21,929
you're super efficient what's more

00:16:19,860 --> 00:16:23,850
important all right that's probably

00:16:21,929 --> 00:16:25,589
you're super efficient because the

00:16:23,850 --> 00:16:27,569
bandwidth data center bandwidth CPU

00:16:25,589 --> 00:16:29,759
usage etc I think that that probably

00:16:27,569 --> 00:16:32,069
Trump's you know the the curl friendly

00:16:29,759 --> 00:16:37,049
side of what you get by using other

00:16:32,069 --> 00:16:39,259
types of methods the frameworks included

00:16:37,049 --> 00:16:41,339
for developing your your stubs

00:16:39,259 --> 00:16:43,920
serialization is binary

00:16:41,339 --> 00:16:45,600
all right so super efficient and it's

00:16:43,920 --> 00:16:47,699
predictable because everything is

00:16:45,600 --> 00:16:49,529
generated for you so let's go in and

00:16:47,699 --> 00:16:52,499
that's uh let's take I guess one more

00:16:49,529 --> 00:16:56,009
point here so the Linux philosophy

00:16:52,499 --> 00:16:57,059
applied so in Linux the idea with with

00:16:56,009 --> 00:16:58,860
all the different tools that are

00:16:57,059 --> 00:17:01,139
encompassed in the distributions is that

00:16:58,860 --> 00:17:02,670
you want to write focus tools and you

00:17:01,139 --> 00:17:04,679
want them to do their job do them well

00:17:02,670 --> 00:17:07,230
but you also want them to interoperate

00:17:04,679 --> 00:17:08,309
with other things so in Linux if you

00:17:07,230 --> 00:17:11,250
have different tools working together

00:17:08,309 --> 00:17:14,159
how do they communicate the Linux pipe

00:17:11,250 --> 00:17:17,250
right so what we're really looking to do

00:17:14,159 --> 00:17:20,309
is create a essentially a Linux pipe for

00:17:17,250 --> 00:17:24,209
boring distributed components and that

00:17:20,309 --> 00:17:26,309
is T RPC so G RPC is a universal

00:17:24,209 --> 00:17:29,460
open-source RPC framework designed to

00:17:26,309 --> 00:17:31,919
create efficient and fast polyglot

00:17:29,460 --> 00:17:34,679
services so polyglot meaning many

00:17:31,919 --> 00:17:36,870
languages any language with a usage

00:17:34,679 --> 00:17:38,610
ranging from data center scale so

00:17:36,870 --> 00:17:40,830
running back-end services in the data

00:17:38,610 --> 00:17:43,260
center to

00:17:40,830 --> 00:17:45,090
bandwidth constrained devices like my

00:17:43,260 --> 00:17:46,380
iphone traveling between all kinds of

00:17:45,090 --> 00:17:48,600
different parts of the world all right

00:17:46,380 --> 00:17:52,980
so that is the focus behind G RPC be

00:17:48,600 --> 00:17:56,610
efficient and be fast so G RPC is based

00:17:52,980 --> 00:17:58,710
on protobuf protocol buffers which are

00:17:56,610 --> 00:18:02,670
really how we can serialize data

00:17:58,710 --> 00:18:05,430
structured data so if I have a an object

00:18:02,670 --> 00:18:08,070
in a certain language the protobufs help

00:18:05,430 --> 00:18:09,720
me take that object serialize it into a

00:18:08,070 --> 00:18:11,400
protobuf object essentially

00:18:09,720 --> 00:18:13,740
and then on the other end that comes out

00:18:11,400 --> 00:18:14,940
as a language specific object all right

00:18:13,740 --> 00:18:17,190
so the protocol bus helped me with that

00:18:14,940 --> 00:18:19,440
translation and they helped me define

00:18:17,190 --> 00:18:21,390
kind of a middle ground so it's based on

00:18:19,440 --> 00:18:23,790
what we call an IDL which is the

00:18:21,390 --> 00:18:25,650
interface definition language which is

00:18:23,790 --> 00:18:26,970
where we could define like how do two

00:18:25,650 --> 00:18:29,250
things to communicate with each other

00:18:26,970 --> 00:18:31,740
this IDL essentially is what creates the

00:18:29,250 --> 00:18:33,090
client stubs and the server stubs and

00:18:31,740 --> 00:18:34,290
that's where you really focus all your

00:18:33,090 --> 00:18:37,290
time when you're defining your

00:18:34,290 --> 00:18:40,500
interfaces so it's got a simple IDL it

00:18:37,290 --> 00:18:43,230
uses HP two out of the gate so HP two is

00:18:40,500 --> 00:18:45,630
super efficient in terms of reusing HTTP

00:18:43,230 --> 00:18:47,580
connections so it's great for for mobile

00:18:45,630 --> 00:18:49,470
devices and just being efficient with

00:18:47,580 --> 00:18:52,290
data center resources

00:18:49,470 --> 00:18:54,360
it's got bi-directional support and

00:18:52,290 --> 00:18:57,780
streaming so if you want to have a

00:18:54,360 --> 00:19:00,750
client or a server send data to a phone

00:18:57,780 --> 00:19:02,610
if I've got a gigabyte in traffic you

00:19:00,750 --> 00:19:04,050
can actually stream that in chunks all

00:19:02,610 --> 00:19:06,180
right so that the client is able to have

00:19:04,050 --> 00:19:08,310
a great user experience with that and

00:19:06,180 --> 00:19:10,680
chunk through the data as it comes in

00:19:08,310 --> 00:19:12,480
versus one whole segment of data and

00:19:10,680 --> 00:19:14,520
there's other things so it's not only

00:19:12,480 --> 00:19:16,140
like the user experience but that has to

00:19:14,520 --> 00:19:17,130
do with the memory right if I have to

00:19:16,140 --> 00:19:19,830
chunk a gig of memory

00:19:17,130 --> 00:19:21,210
I need a chunk of a gig of ram right but

00:19:19,830 --> 00:19:23,010
if I can actually do that in bits and

00:19:21,210 --> 00:19:25,620
pieces and I can stream it to the device

00:19:23,010 --> 00:19:28,710
then the requirements to make sense of

00:19:25,620 --> 00:19:29,790
that data are much much smaller the

00:19:28,710 --> 00:19:33,150
other thing here is that it's got

00:19:29,790 --> 00:19:35,550
extensible middleware so if you're

00:19:33,150 --> 00:19:37,500
developing your interface there may be

00:19:35,550 --> 00:19:40,980
stuff that gr PC doesn't have already

00:19:37,500 --> 00:19:42,330
maybe you want to add some throttling

00:19:40,980 --> 00:19:44,520
maybe you want to add some

00:19:42,330 --> 00:19:45,720
authentication all kinds of different

00:19:44,520 --> 00:19:49,050
stuff like that that is that you can

00:19:45,720 --> 00:19:51,360
essentially inject in the G RPC work

00:19:49,050 --> 00:19:53,340
stream and it can intercept requests and

00:19:51,360 --> 00:19:54,480
do extra things on the request for you

00:19:53,340 --> 00:19:56,100
so plenty of X

00:19:54,480 --> 00:19:58,980
sensibility capabilities is what comes

00:19:56,100 --> 00:20:02,669
down to so what languages are there

00:19:58,980 --> 00:20:03,990
today all of these languages all right

00:20:02,669 --> 00:20:05,429
so a lot of the common languages that

00:20:03,990 --> 00:20:08,070
you would use for not only your

00:20:05,429 --> 00:20:09,990
front-end development for mobile devices

00:20:08,070 --> 00:20:13,890
but also your back-end development in

00:20:09,990 --> 00:20:16,650
the data center how about some

00:20:13,890 --> 00:20:19,590
performance examples we're looking here

00:20:16,650 --> 00:20:23,760
at a dashboard that shows the comparison

00:20:19,590 --> 00:20:26,160
of languages so if you just take a IDL a

00:20:23,760 --> 00:20:27,960
proto by five IDL you define it and you

00:20:26,160 --> 00:20:29,940
generate your client server stubs and

00:20:27,960 --> 00:20:32,490
you take a look at what the round-trip

00:20:29,940 --> 00:20:34,500
time is for for the language itself on

00:20:32,490 --> 00:20:37,679
the bottom you have your baseline which

00:20:34,500 --> 00:20:39,179
is your net perf so what is the you know

00:20:37,679 --> 00:20:41,429
what is the lowest expected performance

00:20:39,179 --> 00:20:42,870
and then the Delta between the net perf

00:20:41,429 --> 00:20:45,630
and any of the other colors is that

00:20:42,870 --> 00:20:46,830
languages you know added overhead for

00:20:45,630 --> 00:20:49,230
actually having the two processes

00:20:46,830 --> 00:20:53,600
communicate so in this case you've got

00:20:49,230 --> 00:20:55,919
C++ which is about 25 extra Melissa are

00:20:53,600 --> 00:20:58,500
nanoseconds and then you've got go

00:20:55,919 --> 00:21:01,559
c-sharp Java so super-efficient from

00:20:58,500 --> 00:21:02,820
that perspective here's some more

00:21:01,559 --> 00:21:06,660
practical results like when I was

00:21:02,820 --> 00:21:10,650
talking about XML JSON as compared to G

00:21:06,660 --> 00:21:13,679
RPC XML and JSON are text-based G RPC is

00:21:10,650 --> 00:21:16,440
binary based so the translation there is

00:21:13,679 --> 00:21:18,210
much much less in terms of getting stuff

00:21:16,440 --> 00:21:19,799
from one language to the other so here's

00:21:18,210 --> 00:21:23,160
an example at the very top you've got

00:21:19,799 --> 00:21:28,200
the JSON RPC interface the total time

00:21:23,160 --> 00:21:29,730
for the transaction was eight eight

00:21:28,200 --> 00:21:32,250
minutes in the seven seconds thank you

00:21:29,730 --> 00:21:35,610
and then you had G RPC the total time

00:21:32,250 --> 00:21:38,520
was 36 seconds so that's a pretty

00:21:35,610 --> 00:21:40,590
significant difference right if you

00:21:38,520 --> 00:21:44,190
actually take G RPC and you scale it out

00:21:40,590 --> 00:21:45,840
to many many hosts or many requests then

00:21:44,190 --> 00:21:47,880
the difference is even more substantial

00:21:45,840 --> 00:21:50,100
for accomplishing the aggregate task

00:21:47,880 --> 00:21:52,169
right because with G RPC you can stream

00:21:50,100 --> 00:21:54,299
or you can send it out in different ways

00:21:52,169 --> 00:21:56,820
so you get down to seven seconds at that

00:21:54,299 --> 00:22:02,040
point if you compare the amount of

00:21:56,820 --> 00:22:04,140
memory consumed so for the so the

00:22:02,040 --> 00:22:06,600
nanoseconds per operation was down by a

00:22:04,140 --> 00:22:08,060
hundred percent the allocations per

00:22:06,600 --> 00:22:09,650
operation was down by 20

00:22:08,060 --> 00:22:11,360
three percent and then the memory

00:22:09,650 --> 00:22:13,130
actually consumed through the operations

00:22:11,360 --> 00:22:16,520
with down about by about forty percent

00:22:13,130 --> 00:22:18,650
so huge difference like going with this

00:22:16,520 --> 00:22:20,060
human readable text format to make two

00:22:18,650 --> 00:22:22,640
components communicate together is

00:22:20,060 --> 00:22:24,470
probably a bad idea from a efficiency

00:22:22,640 --> 00:22:26,720
perspective using something with a

00:22:24,470 --> 00:22:29,660
binary format the jace that geography c

00:22:26,720 --> 00:22:33,290
helps you do is a good idea to keep

00:22:29,660 --> 00:22:34,220
things very very efficient cool how does

00:22:33,290 --> 00:22:37,130
this apply to something more practical

00:22:34,220 --> 00:22:40,460
so don't take this as gospel but just

00:22:37,130 --> 00:22:41,750
give you an example kubernetes like when

00:22:40,460 --> 00:22:43,730
you look at a cluster and you look at

00:22:41,750 --> 00:22:47,000
the CPU usage this is what's been said

00:22:43,730 --> 00:22:48,650
out of a kubernetes cluster because you

00:22:47,000 --> 00:22:49,420
know it doesn't use G RPC internally for

00:22:48,650 --> 00:22:52,730
everything right now

00:22:49,420 --> 00:22:56,090
someone's based on swagger and other API

00:22:52,730 --> 00:22:58,610
stuff but you've got about 47% of the

00:22:56,090 --> 00:23:00,260
CPU usage is what's been said I've heard

00:22:58,610 --> 00:23:03,140
this repeated a couple times but I'd

00:23:00,260 --> 00:23:05,750
love to get more firm details but 47% is

00:23:03,140 --> 00:23:06,980
based on translating text to have

00:23:05,750 --> 00:23:08,210
different things to communicate with

00:23:06,980 --> 00:23:11,900
each other and a Cooper natives cluster

00:23:08,210 --> 00:23:14,690
so a pretty cool example of why we

00:23:11,900 --> 00:23:17,170
probably don't want to do that so GRP

00:23:14,690 --> 00:23:20,120
service and go so let's get practical

00:23:17,170 --> 00:23:22,430
there is a so flag put together some

00:23:20,120 --> 00:23:24,860
great examples for you down here at this

00:23:22,430 --> 00:23:26,420
URL and that this is sessions obviously

00:23:24,860 --> 00:23:29,630
gonna be available after the conference

00:23:26,420 --> 00:23:31,910
through video and as a PowerPoint but

00:23:29,630 --> 00:23:33,920
that is a github repo that gives you

00:23:31,910 --> 00:23:35,420
some examples of how to use some of the

00:23:33,920 --> 00:23:37,400
RPC features that we're gonna walk

00:23:35,420 --> 00:23:39,140
through but what we're gonna do is

00:23:37,400 --> 00:23:41,180
something pretty simple we're gonna find

00:23:39,140 --> 00:23:44,090
this service contract which is this IDL

00:23:41,180 --> 00:23:46,310
this interface definition excuse me

00:23:44,090 --> 00:23:49,520
we're gonna compile the IDL into service

00:23:46,310 --> 00:23:51,470
interfaces and essentially a source code

00:23:49,520 --> 00:23:53,120
and then we're gonna actually implement

00:23:51,470 --> 00:23:57,560
the the methods that were defined to

00:23:53,120 --> 00:24:00,020
create a real working service so first

00:23:57,560 --> 00:24:04,370
of all look at the ideal so here we have

00:24:00,020 --> 00:24:05,930
a protobuf file at the very top you can

00:24:04,370 --> 00:24:07,750
see that we're defining the the version

00:24:05,930 --> 00:24:09,740
of protobuf that we'll be leveraging

00:24:07,750 --> 00:24:11,780
next up you can see the different

00:24:09,740 --> 00:24:14,150
messages and we've got three that were

00:24:11,780 --> 00:24:17,480
defining here one is an object which is

00:24:14,150 --> 00:24:20,060
the currency with a few fields in it the

00:24:17,480 --> 00:24:21,810
code the name number we're using strings

00:24:20,060 --> 00:24:23,850
in 32s there

00:24:21,810 --> 00:24:26,100
and then we've got a currency list which

00:24:23,850 --> 00:24:28,290
is essentially an array of the currency

00:24:26,100 --> 00:24:31,410
items and then we bought the currency

00:24:28,290 --> 00:24:34,050
request where we were receiving the

00:24:31,410 --> 00:24:36,120
ability to have a code and a number this

00:24:34,050 --> 00:24:38,190
service that we're creating is about

00:24:36,120 --> 00:24:40,380
being able to look up currency so

00:24:38,190 --> 00:24:42,570
there's a database of currency the US

00:24:40,380 --> 00:24:44,430
dollar may be indexed one you know the

00:24:42,570 --> 00:24:45,900
euro is indexed to write and we want to

00:24:44,430 --> 00:24:47,340
be able to like query that currency

00:24:45,900 --> 00:24:50,340
database that's what we're kind of

00:24:47,340 --> 00:24:52,140
generating here so that's the interface

00:24:50,340 --> 00:24:55,950
there's the request at the very bottom

00:24:52,140 --> 00:24:58,740
here we've actually got the currency

00:24:55,950 --> 00:25:01,260
service so this is a certain this is

00:24:58,740 --> 00:25:02,850
where we declare what the remote methods

00:25:01,260 --> 00:25:05,490
are that the clients gonna be able to

00:25:02,850 --> 00:25:08,940
access so in this case we've got the get

00:25:05,490 --> 00:25:11,100
currency list method and inside of it

00:25:08,940 --> 00:25:14,130
it's unary so we've got a request object

00:25:11,100 --> 00:25:16,680
and then we've got a list being returned

00:25:14,130 --> 00:25:17,880
from that method it's a pretty simple

00:25:16,680 --> 00:25:20,130
all right that's your protobuf

00:25:17,880 --> 00:25:22,260
definition that is this like middle

00:25:20,130 --> 00:25:26,610
ground that allows you to define the

00:25:22,260 --> 00:25:28,320
contract between two components so let's

00:25:26,610 --> 00:25:30,420
compile that so we've got our protobuf

00:25:28,320 --> 00:25:35,640
file I will use proto C to actually

00:25:30,420 --> 00:25:37,350
compile that into a generated code so

00:25:35,640 --> 00:25:39,450
this is generated code that you don't

00:25:37,350 --> 00:25:42,870
change right this comes out of that

00:25:39,450 --> 00:25:45,840
IDL so in this you can see kind of the

00:25:42,870 --> 00:25:48,180
one-to-one mapping of the message going

00:25:45,840 --> 00:25:50,310
into the type currency on the right side

00:25:48,180 --> 00:25:52,230
it's obviously go right but if you use

00:25:50,310 --> 00:25:53,430
proto C from a different language it

00:25:52,230 --> 00:25:55,920
would generate the code in whatever

00:25:53,430 --> 00:25:57,900
language that you're gonna be using so

00:25:55,920 --> 00:25:59,610
in goes perspective you've got the

00:25:57,900 --> 00:26:00,030
fields mapping pretty closely to the

00:25:59,610 --> 00:26:03,000
types

00:26:00,030 --> 00:26:05,430
you've got the array the currency list

00:26:03,000 --> 00:26:08,340
array going into an array that parameter

00:26:05,430 --> 00:26:10,110
of items with a array of currencies or

00:26:08,340 --> 00:26:11,880
currency pointers and then you've got

00:26:10,110 --> 00:26:14,700
the currency request mapping over and

00:26:11,880 --> 00:26:16,950
then here you have a an interface which

00:26:14,700 --> 00:26:19,470
is unary that includes the the context

00:26:16,950 --> 00:26:22,410
object so this is essentially working

00:26:19,470 --> 00:26:26,820
generated code and the next step is just

00:26:22,410 --> 00:26:29,190
implementing what I see on the right so

00:26:26,820 --> 00:26:32,030
let's implement it so here's the simple

00:26:29,190 --> 00:26:34,650
implementation we're gonna define a

00:26:32,030 --> 00:26:36,270
currency service struct and that's gonna

00:26:34,650 --> 00:26:38,580
be an array of pointers which are from

00:26:36,270 --> 00:26:40,470
the currency object that just came in on

00:26:38,580 --> 00:26:45,060
the last slide right with this new go

00:26:40,470 --> 00:26:46,830
object that got generated for us our our

00:26:45,060 --> 00:26:49,920
function is going to be the get currency

00:26:46,830 --> 00:26:52,890
list function and what we're gonna do

00:26:49,920 --> 00:26:57,780
here this is on the server side is we're

00:26:52,890 --> 00:27:02,160
gonna range a CSV so you can see under

00:26:57,780 --> 00:27:04,680
the for statement right here we're gonna

00:27:02,160 --> 00:27:07,830
range through a C data which is a CSV

00:27:04,680 --> 00:27:11,070
file if the request that comes in that

00:27:07,830 --> 00:27:13,380
specifies the number and the code I'm

00:27:11,070 --> 00:27:15,540
gonna append that item to the list and

00:27:13,380 --> 00:27:18,270
then I'm going to return this item down

00:27:15,540 --> 00:27:21,360
at the bottom as a currency list so this

00:27:18,270 --> 00:27:27,830
is the server-side implementing this get

00:27:21,360 --> 00:27:29,790
currency list function so here we have

00:27:27,830 --> 00:27:32,100
what this actually looks like as a

00:27:29,790 --> 00:27:34,410
runnable program first of all you see

00:27:32,100 --> 00:27:36,690
the data come in from a CSV file at the

00:27:34,410 --> 00:27:39,360
very top line then you can see that

00:27:36,690 --> 00:27:40,560
we're starting our listener and then

00:27:39,360 --> 00:27:44,340
we're gonna create our new currency

00:27:40,560 --> 00:27:46,910
service with this data object will

00:27:44,340 --> 00:27:49,500
create our G RPC server at that point

00:27:46,910 --> 00:27:51,510
we're gonna register that server and the

00:27:49,500 --> 00:27:54,630
G RPC server and the currency service

00:27:51,510 --> 00:27:57,150
together and the protobuf and then we're

00:27:54,630 --> 00:27:58,800
gonna serve down at the bottom alright

00:27:57,150 --> 00:28:01,680
so we've we've taken generated code

00:27:58,800 --> 00:28:03,720
we've created a pretty simple function

00:28:01,680 --> 00:28:05,670
which is this get currency list then we

00:28:03,720 --> 00:28:07,920
package it packaged it up as a runnable

00:28:05,670 --> 00:28:12,660
program and go so that we can actually

00:28:07,920 --> 00:28:14,850
serve up this G RPC endpoint so when I

00:28:12,660 --> 00:28:18,120
call it from the client this is what it

00:28:14,850 --> 00:28:20,490
looks like we've got a runnable program

00:28:18,120 --> 00:28:22,500
again as a client at the very top you've

00:28:20,490 --> 00:28:24,360
got a dial statement that says what's my

00:28:22,500 --> 00:28:28,140
endpoint that's hosting this chair PC

00:28:24,360 --> 00:28:30,480
service you're gonna create a client by

00:28:28,140 --> 00:28:32,510
passing the connection in and then

00:28:30,480 --> 00:28:35,760
you're gonna pass the client to the

00:28:32,510 --> 00:28:38,400
print USD function so the client gets

00:28:35,760 --> 00:28:40,680
passed in and then here it starts so

00:28:38,400 --> 00:28:44,060
we're gonna as a client we're executing

00:28:40,680 --> 00:28:46,080
that remote get currency list function

00:28:44,060 --> 00:28:48,120
we're gonna come down as we get the

00:28:46,080 --> 00:28:50,160
results and it will range through the

00:28:48,120 --> 00:28:53,930
volts all the items and will spit out

00:28:50,160 --> 00:28:55,740
the information that comes back so

00:28:53,930 --> 00:28:57,870
pretty simple we had the server-side

00:28:55,740 --> 00:29:00,360
implemented this is the client-side

00:28:57,870 --> 00:29:02,520
that's using the client stubs and he's

00:29:00,360 --> 00:29:05,490
making use of the data ranging through

00:29:02,520 --> 00:29:05,820
it and spitting out the results pretty

00:29:05,490 --> 00:29:10,290
cool

00:29:05,820 --> 00:29:13,920
pretty basic I should have used that for

00:29:10,290 --> 00:29:16,700
you guys but that's alright alright so

00:29:13,920 --> 00:29:19,560
any questions there does that make sense

00:29:16,700 --> 00:29:21,780
generate the bindings use the create the

00:29:19,560 --> 00:29:22,740
server create the client and all of a

00:29:21,780 --> 00:29:26,400
sudden the two things they're talking to

00:29:22,740 --> 00:29:29,130
each other no no rest model generated no

00:29:26,400 --> 00:29:32,070
working at an HTTP level right

00:29:29,130 --> 00:29:34,770
lots of predictability because there's

00:29:32,070 --> 00:29:36,450
typesafe like built into this so there's

00:29:34,770 --> 00:29:37,680
a lot a lot less guesswork you've got a

00:29:36,450 --> 00:29:39,660
really efficient way to make two things

00:29:37,680 --> 00:29:40,920
communicate together so let's get a

00:29:39,660 --> 00:29:43,710
little bit more complicated with it to

00:29:40,920 --> 00:29:46,770
show some of the features of G RPC so

00:29:43,710 --> 00:29:51,110
streaming what the heck is this I

00:29:46,770 --> 00:29:53,760
mentioned it earlier if I am say a

00:29:51,110 --> 00:29:56,640
device like this and I'm going to

00:29:53,760 --> 00:29:58,680
receive a data set and this data set is

00:29:56,640 --> 00:30:00,270
bigger I probably want to stream the

00:29:58,680 --> 00:30:02,580
data set to the device because then the

00:30:00,270 --> 00:30:05,340
device can decide how much it's gonna

00:30:02,580 --> 00:30:08,160
chunk by so if it's a gigabyte data set

00:30:05,340 --> 00:30:09,780
the device can pull off a megabyte look

00:30:08,160 --> 00:30:11,850
at it you know show it up on the device

00:30:09,780 --> 00:30:13,530
and then it can move on and get the next

00:30:11,850 --> 00:30:16,050
megabyte allowing the user to see the

00:30:13,530 --> 00:30:18,180
data in real time versus having to chunk

00:30:16,050 --> 00:30:20,310
through the gigabyte to show the results

00:30:18,180 --> 00:30:23,250
to the user so streaming is is pretty

00:30:20,310 --> 00:30:24,480
important from many perspectives but

00:30:23,250 --> 00:30:29,760
it's it's great for the user experience

00:30:24,480 --> 00:30:31,950
especially on the mobile side so what

00:30:29,760 --> 00:30:34,830
does this look like so if I update my

00:30:31,950 --> 00:30:37,140
IDL to include streaming this is what

00:30:34,830 --> 00:30:40,260
it's gonna look like at the very top you

00:30:37,140 --> 00:30:43,080
have the existing definition of get

00:30:40,260 --> 00:30:46,080
currency list and that's that's a non

00:30:43,080 --> 00:30:47,730
streaming example unchanged here as we

00:30:46,080 --> 00:30:50,310
step down we've got three different

00:30:47,730 --> 00:30:52,440
streams essentially we've got three

00:30:50,310 --> 00:30:54,000
different stream types one is server

00:30:52,440 --> 00:30:55,260
streaming and that's the example that

00:30:54,000 --> 00:30:57,480
was referring to you where I've got a

00:30:55,260 --> 00:30:59,310
client device and it's chunking

00:30:57,480 --> 00:31:01,809
essentially the the results that come in

00:30:59,310 --> 00:31:04,059
or the server is chunking it for me

00:31:01,809 --> 00:31:05,860
then I've got clients dreaming so the

00:31:04,059 --> 00:31:07,989
opposite is true of what I define from

00:31:05,860 --> 00:31:10,659
the server so in some cases you want the

00:31:07,989 --> 00:31:12,460
server to send in chunks and other cases

00:31:10,659 --> 00:31:16,090
you want the client to send in chunks

00:31:12,460 --> 00:31:17,830
maybe the client is on periscope writing

00:31:16,090 --> 00:31:20,019
your recording stuff and you want to

00:31:17,830 --> 00:31:21,759
send like chunks at a time upward you

00:31:20,019 --> 00:31:23,590
want the server to be ready to receive

00:31:21,759 --> 00:31:26,200
in that same way that it would be

00:31:23,590 --> 00:31:28,119
sending so you can see that the reverse

00:31:26,200 --> 00:31:29,980
is just the stream is just reversed in

00:31:28,119 --> 00:31:31,529
that case to have a stream be submitted

00:31:29,980 --> 00:31:34,149
rather than received

00:31:31,529 --> 00:31:35,619
there's also bi-directional streaming so

00:31:34,149 --> 00:31:37,690
maybe you want the communication in both

00:31:35,619 --> 00:31:41,440
ways to be streamed who knows so all

00:31:37,690 --> 00:31:45,460
three are possible here's an example of

00:31:41,440 --> 00:31:48,700
actually putting that into effect so if

00:31:45,460 --> 00:31:51,940
I'm on the it's a server stream example

00:31:48,700 --> 00:31:54,940
if I am on the server side affecting

00:31:51,940 --> 00:31:56,950
this get currency stream method then

00:31:54,940 --> 00:32:00,100
this is what I'm adding so as the

00:31:56,950 --> 00:32:02,980
results come in instead of appending to

00:32:00,100 --> 00:32:04,419
an array I'm just gonna send I'm going

00:32:02,980 --> 00:32:06,249
to open up that stream that came in to

00:32:04,419 --> 00:32:07,989
me and I'm gonna send that result

00:32:06,249 --> 00:32:09,609
real-time back to the client

00:32:07,989 --> 00:32:11,799
all right so instead of the server just

00:32:09,609 --> 00:32:13,330
appending in in memory and creating the

00:32:11,799 --> 00:32:15,609
the data set and then sending that as a

00:32:13,330 --> 00:32:17,649
whole it's gonna send the the results

00:32:15,609 --> 00:32:21,399
every time it gets one as it iterates

00:32:17,649 --> 00:32:23,679
through the array on the client side was

00:32:21,399 --> 00:32:26,980
this look like how is it different on

00:32:23,679 --> 00:32:30,460
the client side we're gonna activate the

00:32:26,980 --> 00:32:33,039
get currency stream method and then as

00:32:30,460 --> 00:32:35,399
we iterate through we get to this for

00:32:33,039 --> 00:32:39,460
session you're gonna see that we have a

00:32:35,399 --> 00:32:41,019
stream receive right and then we're

00:32:39,460 --> 00:32:43,149
gonna be printing out results as there's

00:32:41,019 --> 00:32:46,539
items that come into that stream so that

00:32:43,149 --> 00:32:48,489
for that for loop gets keeps on going

00:32:46,539 --> 00:32:50,529
essentially it's I think it's a blocking

00:32:48,489 --> 00:32:52,989
channel I would assume and once an item

00:32:50,529 --> 00:32:58,179
comes in the channel then it moves on

00:32:52,989 --> 00:33:04,299
and actually processes it cool

00:32:58,179 --> 00:33:07,020
questions they're good cool next one so

00:33:04,299 --> 00:33:09,490
how do I secure a gr PC interface

00:33:07,020 --> 00:33:12,400
another example of like if you wanted to

00:33:09,490 --> 00:33:14,770
roll this yourself getting TLS support

00:33:12,400 --> 00:33:16,299
across you know any language across

00:33:14,770 --> 00:33:26,710
different frameworks is difficult yep

00:33:16,299 --> 00:33:29,610
question yep so this example is not

00:33:26,710 --> 00:33:34,480
bi-directional right this would be the

00:33:29,610 --> 00:33:35,980
client well this is a server side and I

00:33:34,480 --> 00:33:36,760
actually don't know your answer they

00:33:35,980 --> 00:33:39,070
answer that because I haven't

00:33:36,760 --> 00:33:40,809
implemented the bi-directional so I can

00:33:39,070 --> 00:33:42,190
always we can follow up afterwards and

00:33:40,809 --> 00:33:48,460
get you in touch with one of the gr PC

00:33:42,190 --> 00:33:50,440
people yeah okay so another feature TLS

00:33:48,460 --> 00:33:52,120
how do you guys usually do TLS as you

00:33:50,440 --> 00:33:53,679
create your own you know way of getting

00:33:52,120 --> 00:33:55,929
things to communicate not very easily

00:33:53,679 --> 00:33:59,500
not very standard lis this is gonna be

00:33:55,929 --> 00:34:02,470
really easy so TLS set up for T RPC is

00:33:59,500 --> 00:34:04,870
this if you've got certificate files key

00:34:02,470 --> 00:34:07,059
files then you use the credentials new

00:34:04,870 --> 00:34:10,149
server TLS from file function there or

00:34:07,059 --> 00:34:13,810
method and then when you create your G

00:34:10,149 --> 00:34:17,109
RPC server then you pass in the GRP C

00:34:13,810 --> 00:34:19,540
creds object essentially and that is how

00:34:17,109 --> 00:34:23,260
you create the server side where it's

00:34:19,540 --> 00:34:25,450
SSL bet based at that point if I'm on

00:34:23,260 --> 00:34:27,429
the client it's just as simple

00:34:25,450 --> 00:34:30,310
essentially you use the same exact

00:34:27,429 --> 00:34:32,950
method for creating this TLS certs

00:34:30,310 --> 00:34:35,500
object and then you inject it right here

00:34:32,950 --> 00:34:37,629
with a with transport credentials method

00:34:35,500 --> 00:34:42,119
which will return that that credential

00:34:37,629 --> 00:34:44,349
object for the dial so pretty easy

00:34:42,119 --> 00:34:46,149
how about request timeouts how to

00:34:44,349 --> 00:34:48,010
usually deal with backups and requests

00:34:46,149 --> 00:34:50,290
and all that stuff well this is easy

00:34:48,010 --> 00:34:53,109
here so what you're gonna do is you're

00:34:50,290 --> 00:34:54,339
gonna use gos context object the context

00:34:53,109 --> 00:34:56,859
object is where you can pass around

00:34:54,339 --> 00:34:58,660
arbitrary data and it's thread safe

00:34:56,859 --> 00:35:01,930
essentially so you can send the context

00:34:58,660 --> 00:35:03,910
object to a method and then you know as

00:35:01,930 --> 00:35:05,740
it gets executed in a thread it's able

00:35:03,910 --> 00:35:06,849
to use the information on that context

00:35:05,740 --> 00:35:09,820
and make use of it

00:35:06,849 --> 00:35:12,130
so in this case we're going to augment

00:35:09,820 --> 00:35:15,940
the print USD function

00:35:12,130 --> 00:35:18,760
and then we're going to add in the

00:35:15,940 --> 00:35:21,100
context at the very top so at the top

00:35:18,760 --> 00:35:23,260
line here we've got context with time

00:35:21,100 --> 00:35:24,760
out and we're gonna specify the new

00:35:23,260 --> 00:35:26,830
context and then we're gonna say the

00:35:24,760 --> 00:35:29,650
time out is essentially 200 milliseconds

00:35:26,830 --> 00:35:31,210
and now I've got a context object that's

00:35:29,650 --> 00:35:33,880
got this 200 millisecond timeout

00:35:31,210 --> 00:35:36,700
information in it and then to make use

00:35:33,880 --> 00:35:39,610
of it I go down to the very next line

00:35:36,700 --> 00:35:42,430
down here and I say get the currency

00:35:39,610 --> 00:35:44,980
list past a context but that context

00:35:42,430 --> 00:35:47,920
has the timeout and so now if there is

00:35:44,980 --> 00:35:51,010
if the 200 milliseconds is exceeded then

00:35:47,920 --> 00:35:53,440
G RPC is going to err and say it didn't

00:35:51,010 --> 00:35:59,760
complete within the deadline so timeouts

00:35:53,440 --> 00:36:02,080
are easy cool like error handling I

00:35:59,760 --> 00:36:03,700
think when you look at the like air

00:36:02,080 --> 00:36:05,950
handling is probably one of the most

00:36:03,700 --> 00:36:10,510
inconsistent things as you look at how

00:36:05,950 --> 00:36:12,970
interfaces actually work together if you

00:36:10,510 --> 00:36:15,160
look at like I guess in my opinion if

00:36:12,970 --> 00:36:17,830
you want two things to work very

00:36:15,160 --> 00:36:19,990
predictably then what happens during

00:36:17,830 --> 00:36:22,330
errors is one of the most important

00:36:19,990 --> 00:36:24,790
things right if I've got an error and

00:36:22,330 --> 00:36:26,410
the the client side doesn't know how to

00:36:24,790 --> 00:36:28,300
recover it doesn't know what to do what

00:36:26,410 --> 00:36:29,500
steps to take alright then things can

00:36:28,300 --> 00:36:30,970
get out of sync and all kinds of

00:36:29,500 --> 00:36:33,070
problems happen so having well-defined

00:36:30,970 --> 00:36:34,990
errors is pretty important and it gets

00:36:33,070 --> 00:36:37,840
it's actually very easy as you used your

00:36:34,990 --> 00:36:41,440
PC to do that so an anti-pattern with ng

00:36:37,840 --> 00:36:43,960
RPC is to the is to send a error back

00:36:41,440 --> 00:36:45,730
which hasn't been decorated at all right

00:36:43,960 --> 00:36:47,200
sending back the exact error it's

00:36:45,730 --> 00:36:49,210
probably the not the thing you want to

00:36:47,200 --> 00:36:51,370
do you actually want to do some rapping

00:36:49,210 --> 00:36:55,570
on it so what does that look like so in

00:36:51,370 --> 00:36:58,030
the case of a server error if I've got

00:36:55,570 --> 00:37:00,010
an you know some type of a invalid input

00:36:58,030 --> 00:37:03,400
or something like that I want to return

00:37:00,010 --> 00:37:06,790
a new error that's got a you know more a

00:37:03,400 --> 00:37:08,200
invalid a codes invalid argument so it

00:37:06,790 --> 00:37:10,180
should have some type of a code

00:37:08,200 --> 00:37:12,070
established for that type of error that

00:37:10,180 --> 00:37:14,080
occurred and that should be actually

00:37:12,070 --> 00:37:15,760
defined within my protobuf essentially

00:37:14,080 --> 00:37:18,310
so that it translates back and forth

00:37:15,760 --> 00:37:20,830
easily and that error should actually

00:37:18,310 --> 00:37:22,420
indicate some extra information so that

00:37:20,830 --> 00:37:25,030
you can make sense of you know what's

00:37:22,420 --> 00:37:25,780
going on as the client tries to report

00:37:25,030 --> 00:37:30,310
back

00:37:25,780 --> 00:37:32,680
what the problem was on the client-side

00:37:30,310 --> 00:37:34,090
if that server is actually declaring the

00:37:32,680 --> 00:37:35,830
error which it should and it's

00:37:34,090 --> 00:37:37,000
decorating it a bit then it should be

00:37:35,830 --> 00:37:38,980
able to interpret it in different ways

00:37:37,000 --> 00:37:40,690
so as you know we've got this error that

00:37:38,980 --> 00:37:42,340
happened and I can switch through it and

00:37:40,690 --> 00:37:45,070
figure out what the error is then the

00:37:42,340 --> 00:37:47,350
client should actually go through and

00:37:45,070 --> 00:37:50,350
print a special message for that error

00:37:47,350 --> 00:37:52,000
so it's all easy and very possible as

00:37:50,350 --> 00:37:56,020
you use your PC to do this in a very

00:37:52,000 --> 00:37:59,200
standard way and you can even get more

00:37:56,020 --> 00:38:01,240
complex so if I decided that I wanted to

00:37:59,200 --> 00:38:03,430
add more information to the error that

00:38:01,240 --> 00:38:04,600
gets generated I'm able to do that and

00:38:03,430 --> 00:38:06,490
then at the very bottom I can

00:38:04,600 --> 00:38:09,970
essentially take that object that got

00:38:06,490 --> 00:38:14,830
generated and I can send back a an error

00:38:09,970 --> 00:38:17,110
based object through the interface so

00:38:14,830 --> 00:38:18,610
and then on the other side as I you know

00:38:17,110 --> 00:38:20,290
have a more complex air that gets

00:38:18,610 --> 00:38:22,570
generated by the server then I can make

00:38:20,290 --> 00:38:24,250
use of that error on the client and I

00:38:22,570 --> 00:38:26,800
can you know in this case what I'm doing

00:38:24,250 --> 00:38:28,330
if I started with an object which may

00:38:26,800 --> 00:38:30,970
have generated the error the reason for

00:38:28,330 --> 00:38:33,760
the air I can actually cast that object

00:38:30,970 --> 00:38:35,680
or I can assert it as the PB currency

00:38:33,760 --> 00:38:37,450
object and if it's you know if it

00:38:35,680 --> 00:38:39,010
doesn't assert correctly then I can

00:38:37,450 --> 00:38:40,840
actually spit that out at the client and

00:38:39,010 --> 00:38:42,540
I can show the client like hey here's

00:38:40,840 --> 00:38:44,920
the object the object that came through

00:38:42,540 --> 00:38:46,210
take a look for yourself and you tell me

00:38:44,920 --> 00:38:47,980
if there's something in here that was

00:38:46,210 --> 00:38:50,320
invalid that may have caused me to have

00:38:47,980 --> 00:38:52,720
a problem so all kinds of capabilities

00:38:50,320 --> 00:38:56,200
you can you can have by one making sure

00:38:52,720 --> 00:38:59,110
using the G RPC errors defining them and

00:38:56,200 --> 00:39:01,390
your protobuf but also doing more

00:38:59,110 --> 00:39:03,010
details and asserting the values so you

00:39:01,390 --> 00:39:04,690
can properly report like back to the

00:39:03,010 --> 00:39:07,440
client like what was going on on the

00:39:04,690 --> 00:39:10,420
server side and why there was an error

00:39:07,440 --> 00:39:13,470
other features so other really cool

00:39:10,420 --> 00:39:17,920
stuff with Jerry PC we talked about

00:39:13,470 --> 00:39:20,230
interceptors and taps a little bit so in

00:39:17,920 --> 00:39:21,850
the case of services like you may want

00:39:20,230 --> 00:39:24,670
to establish a tap that does some type

00:39:21,850 --> 00:39:26,440
of flow control so if you want to make

00:39:24,670 --> 00:39:28,600
sure that you know you're not overriding

00:39:26,440 --> 00:39:30,730
a service or doing do s attacks you

00:39:28,600 --> 00:39:32,710
could you can actually inject some types

00:39:30,730 --> 00:39:34,780
of middleware then it's sure you can

00:39:32,710 --> 00:39:36,160
establish some flow control if you had

00:39:34,780 --> 00:39:38,470
extra things you wanted to add for

00:39:36,160 --> 00:39:39,099
authorization you could do that

00:39:38,470 --> 00:39:40,359
so there's all

00:39:39,099 --> 00:39:43,299
kinds of extra goodies that you can

00:39:40,359 --> 00:39:47,200
inject inside of the the G RPC workflow

00:39:43,299 --> 00:39:48,910
to add some extra value on top there's

00:39:47,200 --> 00:39:52,150
tracing for more information about the

00:39:48,910 --> 00:39:54,369
transactions support for pluggable

00:39:52,150 --> 00:39:58,150
authorization and the ability to limit

00:39:54,369 --> 00:40:00,549
message sizes so so G RPC like I love it

00:39:58,150 --> 00:40:02,380
we're big fans as a team we just worked

00:40:00,549 --> 00:40:04,839
on one of our first implementations with

00:40:02,380 --> 00:40:08,069
it as part of the CSI project have you

00:40:04,839 --> 00:40:12,160
guys heard of CSI before or just

00:40:08,069 --> 00:40:14,019
interfaces in general CNI CRI

00:40:12,160 --> 00:40:17,650
CSI there's like three big ones right

00:40:14,019 --> 00:40:20,470
now anyways as you know the like cloud

00:40:17,650 --> 00:40:21,759
native ecosystems evolving as you know

00:40:20,470 --> 00:40:23,079
all these different components and these

00:40:21,759 --> 00:40:25,180
cloud native ecosystems are looking to

00:40:23,079 --> 00:40:26,799
talk talk to talk with one another then

00:40:25,180 --> 00:40:29,619
the interfaces and how they communicate

00:40:26,799 --> 00:40:30,910
are becoming much more important so one

00:40:29,619 --> 00:40:33,640
of the things that we're excited about

00:40:30,910 --> 00:40:36,039
is you know what erp c is bringing to

00:40:33,640 --> 00:40:38,349
the table and it is being used across

00:40:36,039 --> 00:40:40,390
these different interfaces so as

00:40:38,349 --> 00:40:42,819
container orchestrators like kubernetes

00:40:40,390 --> 00:40:44,529
are expanding out to be able to talk to

00:40:42,819 --> 00:40:46,269
you know different components and do

00:40:44,529 --> 00:40:49,930
more than they are today

00:40:46,269 --> 00:40:51,549
G RPC is what's being used so in one of

00:40:49,930 --> 00:40:54,099
the projects we've been working on very

00:40:51,549 --> 00:40:56,380
closely is the CSI project the container

00:40:54,099 --> 00:40:57,880
storage interface project and that's how

00:40:56,380 --> 00:41:01,299
a container Orchestrator talks to

00:40:57,880 --> 00:41:03,190
storage platform the the CSI interface

00:41:01,299 --> 00:41:05,140
or the G RPC interfaces he is there and

00:41:03,190 --> 00:41:06,759
so we had our first implementation with

00:41:05,140 --> 00:41:08,739
it recently and I can say it actually

00:41:06,759 --> 00:41:10,210
went really well so a lot of the

00:41:08,739 --> 00:41:12,579
challenges that the team had been

00:41:10,210 --> 00:41:15,339
looking at previously in terms of

00:41:12,579 --> 00:41:18,630
creating our custom like our own rest

00:41:15,339 --> 00:41:21,849
interface working in the HTTP JSON area

00:41:18,630 --> 00:41:23,410
those were all like problems arose which

00:41:21,849 --> 00:41:25,450
shaped some of what you guys see in this

00:41:23,410 --> 00:41:27,999
presentation today and a lot of that

00:41:25,450 --> 00:41:30,099
stuff went away as we embraced a RPC and

00:41:27,999 --> 00:41:33,519
worked very closely in the CSI project

00:41:30,099 --> 00:41:36,969
so we are we're very excited about it

00:41:33,519 --> 00:41:38,529
and I think it's a great way for great

00:41:36,969 --> 00:41:40,359
things for you guys to look at as you

00:41:38,529 --> 00:41:42,130
figure out like you know how to get your

00:41:40,359 --> 00:41:44,469
components to really talk to each other

00:41:42,130 --> 00:41:45,640
in the data center so with that that's

00:41:44,469 --> 00:41:51,539
that's pretty much all I had for you

00:41:45,640 --> 00:41:51,539
guys any any questions yep

00:41:58,390 --> 00:42:03,709
I'm actually not sure the answer to that

00:42:00,589 --> 00:42:05,150
so let me talk to me after and we'll get

00:42:03,709 --> 00:42:06,439
you hooked up with someone who can give

00:42:05,150 --> 00:42:08,509
you all the details that you want there

00:42:06,439 --> 00:42:11,660
I would encourage you though to pick up

00:42:08,509 --> 00:42:12,949
GRP CIO just bring up the website and

00:42:11,660 --> 00:42:14,719
they've got some great documentation

00:42:12,949 --> 00:42:16,819
that goes over all the details of what

00:42:14,719 --> 00:42:19,519
gr PC does and some of the stuff that

00:42:16,819 --> 00:42:23,900
they're working on well any other

00:42:19,519 --> 00:42:25,279
questions all right with that thank you

00:42:23,900 --> 00:42:25,870
guys very much and enjoy the rest of the

00:42:25,279 --> 00:42:29,150
conference

00:42:25,870 --> 00:42:29,150

YouTube URL: https://www.youtube.com/watch?v=J-NTfvYL_OE


