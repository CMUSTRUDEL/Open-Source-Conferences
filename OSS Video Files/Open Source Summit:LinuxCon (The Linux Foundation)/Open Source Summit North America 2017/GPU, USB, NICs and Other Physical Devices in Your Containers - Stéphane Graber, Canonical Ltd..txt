Title: GPU, USB, NICs and Other Physical Devices in Your Containers - Stéphane Graber, Canonical Ltd.
Publication date: 2017-09-12
Playlist: Open Source Summit North America 2017
Description: 
	GPU, USB, NICs and Other Physical Devices in Your Containers - Stéphane Graber, Canonical Ltd.

The very definition of a container is that it's a set of processes, or in this case full operating system which is sharing the kernel with the host machine.

This opens a full array of possibilities as far as what can be shared between host and container. This talk will be covering some of the most common use cases, such as sharing one or multiple GPUs with a container for compute use, accessing USB devices or physical network interfaces. Then go into slightly weirder cases of kernel device passthrough and see what can be done in such containers.

Outside of the obvious GPU compute use case, device passthrough can also be used to consolidate a number of distinct, mostly idle or old machines into just a single one, including any custom hardware that they may have attached to them and with very little hassle.

Working on Android apps and need to build a CI platform driving a large number of phones, USB passthrough can make this very easy for you too.

LXD will be used as the container manager as it makes all of this rather easy as part of its goal to offer a VM-like environment but built on top of Linux containers.

About Stéphane Graber
Stéphane Graber works as the technical lead for LXD at Canonical Ltd. He is the upstream project leader for LXC and LXD and a frequent speaker and track leader at various containers and other Linux related events.

Stéphane is also a long time contributor to the Ubuntu Linux distribution as an Ubuntu Core Developer and he currently sits on the Ubuntu Technical Board.

On his spare time, Stéphane helps organize a yearly security conference and contest in Montréal, Northsec, where his knowledge of Linux and network infrastructure is used to simulate the most complex of environments for the contestants.
Captions: 
	00:00:00,030 --> 00:00:05,060
welcome everyone I'm Stephan crabber I'm

00:00:02,159 --> 00:00:06,359
the project leader for Alexei laxity

00:00:05,060 --> 00:00:08,069
work

00:00:06,359 --> 00:00:12,710
canonical has a technical lead over

00:00:08,069 --> 00:00:15,420
there and today I want to talk about

00:00:12,710 --> 00:00:18,840
what happens to you know all the

00:00:15,420 --> 00:00:21,930
physical devices that you usually have

00:00:18,840 --> 00:00:24,480
to deal with on physical machines and

00:00:21,930 --> 00:00:27,619
some cases with virtual machines and how

00:00:24,480 --> 00:00:31,579
those map into the container world and

00:00:27,619 --> 00:00:33,780
what's possible with all that stuff so

00:00:31,579 --> 00:00:35,399
first of all a very quick intro I'm

00:00:33,780 --> 00:00:37,739
really sorry for anyone who was in

00:00:35,399 --> 00:00:39,210
Christians talk next door just before

00:00:37,739 --> 00:00:42,690
because that's gonna be a bit repetitive

00:00:39,210 --> 00:00:45,239
but in this talk I'll mostly be focusing

00:00:42,690 --> 00:00:47,370
on what we call system containers that

00:00:45,239 --> 00:00:48,840
is pretty different from the application

00:00:47,370 --> 00:00:51,000
container type model which is what

00:00:48,840 --> 00:00:53,489
docker rocket and those type of written

00:00:51,000 --> 00:00:56,219
times do system containers tend to be

00:00:53,489 --> 00:00:58,020
better suited when talking passing

00:00:56,219 --> 00:00:59,460
physical devices and dealing with like

00:00:58,020 --> 00:00:59,940
physical disks and Nick's and all that

00:00:59,460 --> 00:01:03,000
kind of stuff

00:00:59,940 --> 00:01:05,369
because their main goal is to provide

00:01:03,000 --> 00:01:07,860
the same semantics around containers as

00:01:05,369 --> 00:01:11,610
you would usually get around a virtual

00:01:07,860 --> 00:01:13,680
machine or physical system system

00:01:11,610 --> 00:01:15,869
containers are the oldest type of

00:01:13,680 --> 00:01:18,210
containers they've started with bsd

00:01:15,869 --> 00:01:20,520
jails then the similar approach was

00:01:18,210 --> 00:01:23,640
taken as a kernel patch called linux

00:01:20,520 --> 00:01:25,640
vserver solaris did something pretty

00:01:23,640 --> 00:01:28,409
similar to be as details but with

00:01:25,640 --> 00:01:30,240
networking sorted out which bsd didn't

00:01:28,409 --> 00:01:33,659
quite have when they limited storage

00:01:30,240 --> 00:01:36,570
zones then we got openvz which was

00:01:33,659 --> 00:01:40,290
another big candle budge set on the next

00:01:36,570 --> 00:01:43,140
to get system containers going after

00:01:40,290 --> 00:01:45,930
which work has happened in europe stream

00:01:43,140 --> 00:01:47,909
canada community to get system

00:01:45,930 --> 00:01:50,040
containers containers internal support

00:01:47,909 --> 00:01:53,939
linux kernel which in userspace

00:01:50,040 --> 00:01:56,009
led to the LXE project which then

00:01:53,939 --> 00:01:58,200
evolved recently in a more user friendly

00:01:56,009 --> 00:02:01,860
manner to into the legacy project as

00:01:58,200 --> 00:02:04,350
we've got right now containers like

00:02:01,860 --> 00:02:06,509
custom containers very much behave like

00:02:04,350 --> 00:02:08,280
a standalone system they've run an init

00:02:06,509 --> 00:02:10,470
system they run a clean destroy images

00:02:08,280 --> 00:02:12,480
they don't need any kind of specialized

00:02:10,470 --> 00:02:13,080
software that's container aware any of

00:02:12,480 --> 00:02:14,460
that stuff

00:02:13,080 --> 00:02:17,130
don't need custom images they don't even

00:02:14,460 --> 00:02:18,720
know that they will boot a full system

00:02:17,130 --> 00:02:21,840
exactly like you would on a normal

00:02:18,720 --> 00:02:23,340
machine or in virtual machine the only

00:02:21,840 --> 00:02:25,680
difference being does they share the

00:02:23,340 --> 00:02:27,090
camera with the host so long as you're

00:02:25,680 --> 00:02:28,890
not trying to run Windows or some other

00:02:27,090 --> 00:02:30,780
operating system you can run them you

00:02:28,890 --> 00:02:34,020
can run whatever in its distro you want

00:02:30,780 --> 00:02:35,130
inside a system container and there is

00:02:34,020 --> 00:02:37,800
no need for any kind of authorization

00:02:35,130 --> 00:02:42,450
because it's you're dealing with

00:02:37,800 --> 00:02:44,250
containers of so on so it runs on any

00:02:42,450 --> 00:02:45,360
architecture even architectures that

00:02:44,250 --> 00:02:48,330
might not support any kind of a

00:02:45,360 --> 00:02:49,980
transition extension and when talking

00:02:48,330 --> 00:02:51,840
and we're gonna go into more details

00:02:49,980 --> 00:02:53,459
after that when talking about physical

00:02:51,840 --> 00:02:58,560
devices that also means that you don't

00:02:53,459 --> 00:02:59,850
need any special firmware hardware

00:02:58,560 --> 00:03:01,980
platform on you of that kind of stuff to

00:02:59,850 --> 00:03:03,480
support physical device pass-through so

00:03:01,980 --> 00:03:05,430
for anyone who's been dealing with that

00:03:03,480 --> 00:03:07,110
in the VM world you're usually looking

00:03:05,430 --> 00:03:09,630
at whether your hardware is vfi or

00:03:07,110 --> 00:03:10,830
capable and like whether your

00:03:09,630 --> 00:03:14,250
motherboard supports it whether you've

00:03:10,830 --> 00:03:15,990
got the right set up of PCI lanes like

00:03:14,250 --> 00:03:18,300
put up Annie Lane is shared that kind of

00:03:15,990 --> 00:03:19,890
stuff aren't in try and get devices into

00:03:18,300 --> 00:03:22,380
a shape where you can move them into VMs

00:03:19,890 --> 00:03:25,650
with containers we use a single kernel

00:03:22,380 --> 00:03:32,489
so we don't need any of those hardware

00:03:25,650 --> 00:03:33,900
and firmware details at all now quickly

00:03:32,489 --> 00:03:38,459
talking about it's kind of you know use

00:03:33,900 --> 00:03:41,660
cases like where we're in what cases

00:03:38,459 --> 00:03:44,100
might you actually need physical stuff

00:03:41,660 --> 00:03:49,560
and we can't authorize a lot of things

00:03:44,100 --> 00:03:52,050
that's very nice but occasionally you do

00:03:49,560 --> 00:03:53,580
need to get down to hardware and one of

00:03:52,050 --> 00:03:55,320
the most common use cases these days is

00:03:53,580 --> 00:03:57,570
really computation when you whenever you

00:03:55,320 --> 00:03:59,519
want to deal with GPUs what are you're

00:03:57,570 --> 00:04:02,970
doing you know deep learning type thing

00:03:59,519 --> 00:04:07,110
or you just want to get rich by mining

00:04:02,970 --> 00:04:11,610
coins whatever whatever you like usually

00:04:07,110 --> 00:04:14,790
end up having to deal with GPUs you can

00:04:11,610 --> 00:04:17,760
do very fancy virtualized GPUs if you go

00:04:14,790 --> 00:04:20,070
with advanced server type models of GPUs

00:04:17,760 --> 00:04:21,359
they can let you slice a card into

00:04:20,070 --> 00:04:23,130
different that whole chunks those little

00:04:21,359 --> 00:04:24,660
chunks so that's like natural PCI

00:04:23,130 --> 00:04:25,750
devices and you can bind those to

00:04:24,660 --> 00:04:27,940
virtual machines

00:04:25,750 --> 00:04:31,090
but there's still some of had of all of

00:04:27,940 --> 00:04:33,430
that weather like this sizing is dynamic

00:04:31,090 --> 00:04:35,349
or not like how you actually assign

00:04:33,430 --> 00:04:36,580
resources and then the fact that you

00:04:35,349 --> 00:04:38,379
have to pass those two little machines

00:04:36,580 --> 00:04:40,120
that can be a bit painful there may be

00:04:38,379 --> 00:04:43,449
some other head you may not want to buy

00:04:40,120 --> 00:04:46,180
a multi thousand dollars cards just to

00:04:43,449 --> 00:04:47,379
be able to do that especially when you

00:04:46,180 --> 00:04:52,210
know all your vector machines are gonna

00:04:47,379 --> 00:04:54,940
be running Linux anyways so it does GPU

00:04:52,210 --> 00:04:56,650
is like one of the three big use case on

00:04:54,940 --> 00:04:58,449
this we've got four for any kind of

00:04:56,650 --> 00:05:00,400
device pass through in the next day and

00:04:58,449 --> 00:05:02,800
just in containers in general the other

00:05:00,400 --> 00:05:07,930
thing you usually run into is very fast

00:05:02,800 --> 00:05:09,909
networking that's the case is where you

00:05:07,930 --> 00:05:12,879
want to pass devices are capable of like

00:05:09,909 --> 00:05:15,430
40 or 100 gigabit connectivity or

00:05:12,879 --> 00:05:16,659
possibly if you're doing the h HH pc

00:05:15,430 --> 00:05:19,199
type workload you might care about

00:05:16,659 --> 00:05:22,740
features like our DMA to directly access

00:05:19,199 --> 00:05:25,930
memory from different hosts on a network

00:05:22,740 --> 00:05:27,729
those who could also pass through PCI

00:05:25,930 --> 00:05:28,750
pass-through but either you need a very

00:05:27,729 --> 00:05:30,669
fancy car that lets you do a

00:05:28,750 --> 00:05:32,919
virtualization and slicing or you need

00:05:30,669 --> 00:05:35,190
to have one physical card per virtual

00:05:32,919 --> 00:05:40,120
machine on your system which not always

00:05:35,190 --> 00:05:42,310
that great of it really and other new

00:05:40,120 --> 00:05:44,500
bunch of the devices that more people

00:05:42,310 --> 00:05:46,360
tend to deal with day to day I mean you

00:05:44,500 --> 00:05:47,740
might like in your company I don't know

00:05:46,360 --> 00:05:49,240
you might be doing Android app

00:05:47,740 --> 00:05:51,069
development you might want it to be able

00:05:49,240 --> 00:05:53,740
to test your code against physical

00:05:51,069 --> 00:05:55,389
devices sure you can get a bunch of

00:05:53,740 --> 00:05:57,250
raspberry PI's and connect stuff to them

00:05:55,389 --> 00:06:00,669
that's that's perfectly fine but you

00:05:57,250 --> 00:06:02,800
could also get like some beefy servers

00:06:00,669 --> 00:06:04,960
and just attach all your devices do not

00:06:02,800 --> 00:06:06,490
and then dispatch those physical USB

00:06:04,960 --> 00:06:10,000
devices to whatever container is running

00:06:06,490 --> 00:06:12,370
a given test against it so USB posture

00:06:10,000 --> 00:06:14,800
is very useful for the kind of stuff it

00:06:12,370 --> 00:06:17,139
also similar environments it means you

00:06:14,800 --> 00:06:19,270
can parse access to scientific equipment

00:06:17,139 --> 00:06:23,190
without like fancy scales or whatever

00:06:19,270 --> 00:06:26,620
you might have in a lab those tend to be

00:06:23,190 --> 00:06:29,889
pretty simple serial USB type device is

00:06:26,620 --> 00:06:32,080
that pretty damn trivial to pass to a

00:06:29,889 --> 00:06:33,520
container as well and then you've got

00:06:32,080 --> 00:06:36,009
some of the weirder cases I mean you've

00:06:33,520 --> 00:06:38,630
got things like HSMs for anyone who

00:06:36,009 --> 00:06:40,760
needs to store private keys very

00:06:38,630 --> 00:06:42,890
securely you might have a container that

00:06:40,760 --> 00:06:44,090
you want to do your kit management in

00:06:42,890 --> 00:06:45,470
that doesn't have any kind of internet

00:06:44,090 --> 00:06:48,740
access but needs to have access to the

00:06:45,470 --> 00:06:51,500
HSM so that can have like files dumped

00:06:48,740 --> 00:06:54,290
into it do signing and then push the

00:06:51,500 --> 00:06:58,390
file back out or something or not and

00:06:54,290 --> 00:07:01,940
then even weirder cases like phone cards

00:06:58,390 --> 00:07:05,210
it's not uncommon for companies to still

00:07:01,940 --> 00:07:07,430
get a good old t1 or similar type phone

00:07:05,210 --> 00:07:09,440
lines and that usually means either

00:07:07,430 --> 00:07:11,090
you've got a physical PBX or you've got

00:07:09,440 --> 00:07:17,840
something like asterisk running with a

00:07:11,090 --> 00:07:19,190
fancy phone card again like you maybe

00:07:17,840 --> 00:07:21,170
you're willing to waste a full machine

00:07:19,190 --> 00:07:23,150
just to run your PBX but maybe you're

00:07:21,170 --> 00:07:24,470
not and if you've got infrastructure set

00:07:23,150 --> 00:07:25,880
like you might as well just run all that

00:07:24,470 --> 00:07:30,220
stuff inside a container rather than

00:07:25,880 --> 00:07:33,320
running it on a dedicated machine and

00:07:30,220 --> 00:07:35,780
storage is always also a pretty

00:07:33,320 --> 00:07:38,000
important part of that very very fast

00:07:35,780 --> 00:07:41,060
storage and virtual machines doesn't

00:07:38,000 --> 00:07:42,020
tend to align always that well for

00:07:41,060 --> 00:07:43,940
anyone who's been dealing with card

00:07:42,020 --> 00:07:47,960
instances IO performance tends to be a

00:07:43,940 --> 00:07:49,280
bit of a bottleneck and usually turned

00:07:47,960 --> 00:07:51,170
to physical machines whenever you need

00:07:49,280 --> 00:07:53,560
to deal with really really fast storage

00:07:51,170 --> 00:07:56,450
be that you know nvme or whatever else

00:07:53,560 --> 00:07:58,100
again system containers will let you

00:07:56,450 --> 00:08:00,500
have something that feels like exactly

00:07:58,100 --> 00:08:04,960
your virtual machine or your own tiny

00:08:00,500 --> 00:08:08,570
cloud or something or not but be running

00:08:04,960 --> 00:08:11,030
like on single directly with the

00:08:08,570 --> 00:08:13,490
hardware directly talking directly to

00:08:11,030 --> 00:08:15,560
the hardware rather than having to go

00:08:13,490 --> 00:08:17,980
through X layers of virtualization and

00:08:15,560 --> 00:08:17,980
direction

00:08:21,830 --> 00:08:26,330
so that's some of the points I also kind

00:08:24,710 --> 00:08:28,220
of went through already some extent like

00:08:26,330 --> 00:08:31,310
how they will device pass-through works

00:08:28,220 --> 00:08:32,599
for containers rather than what you

00:08:31,310 --> 00:08:34,880
would usually get with like a virtual

00:08:32,599 --> 00:08:38,089
machine where you pass the PCI device or

00:08:34,880 --> 00:08:40,039
you pass and the actual device to it and

00:08:38,089 --> 00:08:41,959
then you need to load your drivers in

00:08:40,039 --> 00:08:43,940
there that will then track the beautiful

00:08:41,959 --> 00:08:48,110
device and then eventually access the

00:08:43,940 --> 00:08:50,750
hardware in a container the kernel will

00:08:48,110 --> 00:08:52,100
just load on the host whatever modules

00:08:50,750 --> 00:08:53,930
needed to talk directly to the other and

00:08:52,100 --> 00:08:56,510
in the device nodes that show up as a

00:08:53,930 --> 00:08:58,370
result of that are then exposed to the

00:08:56,510 --> 00:09:00,290
containers that you want to have access

00:08:58,370 --> 00:09:02,870
to that that means no red physician

00:09:00,290 --> 00:09:05,149
anywhere along that path direct access

00:09:02,870 --> 00:09:07,279
if you want it you just need your host

00:09:05,149 --> 00:09:13,070
kernel to have support for whatever

00:09:07,279 --> 00:09:14,510
device you just attached the tricky part

00:09:13,070 --> 00:09:16,370
some extender is figuring out exactly

00:09:14,510 --> 00:09:17,690
what device nodes you need to get and

00:09:16,370 --> 00:09:20,120
move into the container that's

00:09:17,690 --> 00:09:21,709
especially difficult with GPUs when

00:09:20,120 --> 00:09:26,029
you've got a system that's you know got

00:09:21,709 --> 00:09:28,190
a mix of multiple vendors of cards some

00:09:26,029 --> 00:09:29,899
of which come with drivers that gives

00:09:28,190 --> 00:09:32,890
you extra device notes things like

00:09:29,899 --> 00:09:36,529
Nvidia's their dev Nvidia tech devices

00:09:32,890 --> 00:09:38,089
that needs some extra logic to try and

00:09:36,529 --> 00:09:40,490
figure out exactly what it's tied to a

00:09:38,089 --> 00:09:42,050
specific piece of hardware but once you

00:09:40,490 --> 00:09:46,850
do it's pretty important and move those

00:09:42,050 --> 00:09:49,010
into the into the container the very

00:09:46,850 --> 00:09:51,440
interesting feature that you get from

00:09:49,010 --> 00:09:55,670
all of that especially when talking GPUs

00:09:51,440 --> 00:09:57,890
is that you can share those devices with

00:09:55,670 --> 00:10:00,050
as many containers as you want without

00:09:57,890 --> 00:10:01,490
needing like any fancy hardware feature

00:10:00,050 --> 00:10:02,350
to try and do slicing and that kind of

00:10:01,490 --> 00:10:05,810
stuff

00:10:02,350 --> 00:10:07,959
Linux will perfectly let you have like

00:10:05,810 --> 00:10:10,970
10 15 whatever pieces different

00:10:07,959 --> 00:10:14,360
processes talk to the same definition

00:10:10,970 --> 00:10:16,610
ode for rendering and there's nothing

00:10:14,360 --> 00:10:19,190
wrong with having multiple containers at

00:10:16,610 --> 00:10:22,430
all see the exact same device sure they

00:10:19,190 --> 00:10:25,310
will eventually they will share time on

00:10:22,430 --> 00:10:27,500
the card itself but you can do it and

00:10:25,310 --> 00:10:30,709
then it's effectively up to you whether

00:10:27,500 --> 00:10:33,680
you want to rat out or not rather than

00:10:30,709 --> 00:10:36,439
up to whatever the hardware gets you

00:10:33,680 --> 00:10:37,850
and the other thing that's pretty

00:10:36,439 --> 00:10:40,579
interesting is that you can attach and

00:10:37,850 --> 00:10:43,550
detach those devices on the fly exactly

00:10:40,579 --> 00:10:45,439
when you want it you don't need to take

00:10:43,550 --> 00:10:48,649
the system in our case the container

00:10:45,439 --> 00:10:50,170
down to replace hardware like remove a

00:10:48,649 --> 00:10:53,079
card other cards that kind of stuff

00:10:50,170 --> 00:10:55,360
usually hot plugging into a VM is pretty

00:10:53,079 --> 00:10:58,399
reliable that part works pretty well

00:10:55,360 --> 00:11:00,379
removing from a VM not always so much

00:10:58,399 --> 00:11:03,319
and if you're dealing with physical

00:11:00,379 --> 00:11:04,790
Hardware then yeah like you don't really

00:11:03,319 --> 00:11:07,279
want to start hot plugging and hot

00:11:04,790 --> 00:11:13,429
removing the hardware from your running

00:11:07,279 --> 00:11:16,069
server the bulk of this talk is going to

00:11:13,429 --> 00:11:17,089
be going through a demographic all of

00:11:16,069 --> 00:11:18,920
those different features in the way they

00:11:17,089 --> 00:11:21,249
work and XD so I just want to quickly go

00:11:18,920 --> 00:11:24,290
through what makes das before we do that

00:11:21,249 --> 00:11:24,829
legacy is as I mentioned an evolution of

00:11:24,290 --> 00:11:29,589
next dates

00:11:24,829 --> 00:11:31,670
Aleksey that means it's a modern

00:11:29,589 --> 00:11:34,399
container manager it's got a REST API

00:11:31,670 --> 00:11:37,550
it's got nice scripting it's fast by

00:11:34,399 --> 00:11:39,139
default it uses optimized storage for

00:11:37,550 --> 00:11:42,189
any kind of start drivers that you might

00:11:39,139 --> 00:11:47,360
think of like we support the FSBO FSL VM

00:11:42,189 --> 00:11:49,790
directory based data storage and knows

00:11:47,360 --> 00:11:51,199
how to do like extremely efficient

00:11:49,790 --> 00:11:53,389
cloning of containers and copying of

00:11:51,199 --> 00:11:54,920
containers all that kind of stuff it's

00:11:53,389 --> 00:11:57,610
secure by default we use every single

00:11:54,920 --> 00:12:02,480
kernel security features it can think of

00:11:57,610 --> 00:12:05,449
that cordial SMS we also use C groups

00:12:02,480 --> 00:12:09,800
for restriction restricting resource

00:12:05,449 --> 00:12:10,759
usage we use the and pivot all our

00:12:09,800 --> 00:12:12,709
containers aren't pivoted

00:12:10,759 --> 00:12:14,179
by default which means the that route

00:12:12,709 --> 00:12:17,269
inside your container is not reroute

00:12:14,179 --> 00:12:20,120
outside of it we use all the namespaces

00:12:17,269 --> 00:12:21,860
as well to get you like I'll see if I

00:12:20,120 --> 00:12:24,199
can technology can't possibly think of

00:12:21,860 --> 00:12:26,089
and it's just going to be very scalable

00:12:24,199 --> 00:12:28,459
so while the demo I'm going to give you

00:12:26,089 --> 00:12:29,929
is on a few individual systems a few

00:12:28,459 --> 00:12:31,999
containers it works just as well if

00:12:29,929 --> 00:12:34,549
you've got hundreds of different systems

00:12:31,999 --> 00:12:36,860
with running each hundreds to thousands

00:12:34,549 --> 00:12:39,139
of containers and because it's a

00:12:36,860 --> 00:12:40,549
networked type daemon it does support

00:12:39,139 --> 00:12:42,620
moving your containers from one host to

00:12:40,549 --> 00:12:44,240
another and using one of your hosts as

00:12:42,620 --> 00:12:46,819
an image server for the others all of

00:12:44,240 --> 00:12:50,420
those kind of nice Network interactions

00:12:46,819 --> 00:12:52,370
you can think of as far as what we

00:12:50,420 --> 00:12:56,360
support for device pass-through in next

00:12:52,370 --> 00:12:59,569
day we've got five device types right

00:12:56,360 --> 00:13:01,639
now well six technically we've got niche

00:12:59,569 --> 00:13:04,370
which is network interfaces that we

00:13:01,639 --> 00:13:05,540
support virtual interfaces so that just

00:13:04,370 --> 00:13:09,350
means your normal

00:13:05,540 --> 00:13:10,939
Linux bridge plus a virtual device that

00:13:09,350 --> 00:13:13,279
connected to it that's the default mode

00:13:10,939 --> 00:13:16,699
but we do support passing a physical

00:13:13,279 --> 00:13:17,959
device through so your device no just

00:13:16,699 --> 00:13:19,069
disappears from the host and shows up in

00:13:17,959 --> 00:13:23,059
a container effectively

00:13:19,069 --> 00:13:26,029
four disks which support either said

00:13:23,059 --> 00:13:28,129
just affinity binding a path from your

00:13:26,029 --> 00:13:30,949
host into the container so you can say

00:13:28,129 --> 00:13:32,809
that you want home your user name some

00:13:30,949 --> 00:13:34,759
directory show up a stash M&T in a

00:13:32,809 --> 00:13:39,049
container and they will do it for you or

00:13:34,759 --> 00:13:40,699
you can point to a physical block device

00:13:39,049 --> 00:13:42,049
without a full disk or partition and

00:13:40,699 --> 00:13:45,079
just reflects the amount that for you at

00:13:42,049 --> 00:13:47,990
a given path in a container for GPU with

00:13:45,079 --> 00:13:51,259
support passing existing GPU we figure

00:13:47,990 --> 00:13:53,419
out why DRI render nodes we need to move

00:13:51,259 --> 00:13:55,429
and whether there's anything additional

00:13:53,419 --> 00:13:57,019
like the CUDA type devices that we also

00:13:55,429 --> 00:13:59,620
need to expose to the container and we

00:13:57,019 --> 00:14:02,269
do that for you as well for USB devices

00:13:59,620 --> 00:14:04,069
anything that's supported by Libby USB

00:14:02,269 --> 00:14:07,129
so that's anything that looks at def

00:14:04,069 --> 00:14:09,399
both USB and accesses those device nodes

00:14:07,129 --> 00:14:11,419
we support as well so you can

00:14:09,399 --> 00:14:13,160
effectively configure a continuous thing

00:14:11,419 --> 00:14:15,079
like anything that's blood which has

00:14:13,160 --> 00:14:17,569
that Product ID and weather ID just pass

00:14:15,079 --> 00:14:19,069
it to the container or you can even say

00:14:17,569 --> 00:14:21,019
anything that's from that Product ID

00:14:19,069 --> 00:14:23,629
needs to be no ID nice be passed to the

00:14:21,019 --> 00:14:27,350
container because multiple devices like

00:14:23,629 --> 00:14:28,910
if a given piece of so how do I shows up

00:14:27,350 --> 00:14:30,139
as like three different devices or from

00:14:28,910 --> 00:14:31,639
the same vendor you can have them all

00:14:30,139 --> 00:14:34,730
automatically be passed to the container

00:14:31,639 --> 00:14:37,009
and we support hot plugging for USB as

00:14:34,730 --> 00:14:38,779
well as soon as legacy notices that

00:14:37,009 --> 00:14:40,309
protocol device has been turned into the

00:14:38,779 --> 00:14:42,199
host it just passes it to continue

00:14:40,309 --> 00:14:45,290
immediately there's no need to restore

00:14:42,199 --> 00:14:47,749
twenty fingers and for low-level

00:14:45,290 --> 00:14:50,120
type use cases we also support passing

00:14:47,749 --> 00:14:52,370
just any UNIX car televisor in X plug

00:14:50,120 --> 00:14:54,769
device that you might think of some of

00:14:52,370 --> 00:14:57,169
the use cases there is usually run my

00:14:54,769 --> 00:14:59,420
virtual machine hosts inside hell XD

00:14:57,169 --> 00:15:01,340
containers so install it

00:14:59,420 --> 00:15:04,100
inside a lexie container and a night

00:15:01,340 --> 00:15:08,390
pass death KVM from the host into the

00:15:04,100 --> 00:15:12,320
container alright so that was the

00:15:08,390 --> 00:15:16,510
growing speech now and it's good look

00:15:12,320 --> 00:15:19,130
look at how that thing actually works

00:15:16,510 --> 00:15:21,350
I'm hoping it's gonna be big enough the

00:15:19,130 --> 00:15:23,120
poem is that if it's been nice bigger

00:15:21,350 --> 00:15:26,420
than that then tables and stuff don't

00:15:23,120 --> 00:15:27,650
render anymore so I'm hoping that will

00:15:26,420 --> 00:15:30,130
do the trick

00:15:27,650 --> 00:15:33,140
the first thing we look at is just

00:15:30,130 --> 00:15:37,490
installed XD on a test system real quick

00:15:33,140 --> 00:15:41,600
just downloading latest version of flex

00:15:37,490 --> 00:15:44,000
D and installing that using the legacy

00:15:41,600 --> 00:15:47,690
snap package in this case we also have

00:15:44,000 --> 00:15:51,220
not expected res and whatnot and it was

00:15:47,690 --> 00:15:51,220
a bit slow and it was earlier

00:15:59,660 --> 00:16:02,970
whenever you prepare your demo you're

00:16:01,500 --> 00:16:04,770
donating at like 20 megabytes a second

00:16:02,970 --> 00:16:09,050
everything is great and when you

00:16:04,770 --> 00:16:18,029
actually do it then internet goes to

00:16:09,050 --> 00:16:22,170
think seriously are you kidding me it's

00:16:18,029 --> 00:16:26,820
just oh it might just be until it being

00:16:22,170 --> 00:16:34,170
done that would explain it I guess that

00:16:26,820 --> 00:16:35,760
would also be very sad because I can

00:16:34,170 --> 00:16:38,130
show some stuff locally but I don't have

00:16:35,760 --> 00:16:39,839
a GPU that I can really do anything

00:16:38,130 --> 00:16:47,220
useful with on this machine so that

00:16:39,839 --> 00:16:49,830
would be pretty unfortunate alright fine

00:16:47,220 --> 00:16:56,160
I'm gonna bounce to Wi-Fi and see if I

00:16:49,830 --> 00:16:57,810
get lucky if not I'm just gonna demo

00:16:56,160 --> 00:17:02,339
whatever I can locally but that would be

00:16:57,810 --> 00:17:04,980
unfortunate yeah I just reconnected it

00:17:02,339 --> 00:17:13,250
seems to be working with okay now

00:17:04,980 --> 00:17:13,250
reconnecting VPN epeans background

00:17:17,560 --> 00:17:21,760
[Music]

00:17:19,510 --> 00:17:28,360
come on the sage you're reconnected

00:17:21,760 --> 00:17:32,409
should do something about it I seriously

00:17:28,360 --> 00:17:34,809
have to reconnect oh yeah look around

00:17:32,409 --> 00:17:37,450
all right sir

00:17:34,809 --> 00:17:40,149
next is installed that was a bit harder

00:17:37,450 --> 00:17:42,549
than I thought it would be but yes just

00:17:40,149 --> 00:17:44,380
go to the initial config file XD which

00:17:42,549 --> 00:17:46,330
usually involves pressing enter cutter

00:17:44,380 --> 00:17:48,820
if you don't it's effectively gonna

00:17:46,330 --> 00:17:51,580
create you a new storage pool uses the

00:17:48,820 --> 00:17:55,090
FS in this case by default creates a

00:17:51,580 --> 00:17:58,950
default bridge with default unused

00:17:55,090 --> 00:18:01,630
subnet 51:56 there we go it's created

00:17:58,950 --> 00:18:05,649
now let's create a container I'm just

00:18:01,630 --> 00:18:09,429
gonna use say a CentOS 7 image because

00:18:05,649 --> 00:18:16,330
why not ah that's how Network supposed

00:18:09,429 --> 00:18:17,740
to work yeah yeah okay so if we list

00:18:16,330 --> 00:18:19,659
right now the container has an ipv6

00:18:17,740 --> 00:18:21,970
children ipv4 soon there we go

00:18:19,659 --> 00:18:23,679
so that container just created on

00:18:21,970 --> 00:18:26,980
default laxity which means it on the

00:18:23,679 --> 00:18:28,630
hands it's connected to a local bridge

00:18:26,980 --> 00:18:32,440
it doesn't have any physical devices on

00:18:28,630 --> 00:18:34,679
your that kind of stuff we can lift its

00:18:32,440 --> 00:18:38,019
entire config see what's going on there

00:18:34,679 --> 00:18:40,539
you might see down in devices there's if

00:18:38,019 --> 00:18:44,169
0 we see it's connected to Blake's TBR 0

00:18:40,539 --> 00:18:47,399
types bridged ok so that's the default

00:18:44,169 --> 00:18:50,559
config now let's change that a bit i've

00:18:47,399 --> 00:18:54,820
do have a awkwardly named

00:18:50,559 --> 00:18:56,980
E&P Levin at 0 thank ya so a physical

00:18:54,820 --> 00:19:00,639
device on the specific machine I'm not

00:18:56,980 --> 00:19:02,769
using right now I'm gonna tell Alex D to

00:19:00,639 --> 00:19:07,179
replace the if 0 device I've got in that

00:19:02,769 --> 00:19:10,380
container with that device instead no

00:19:07,179 --> 00:19:14,889
I'm just gonna bring it down and bring

00:19:10,380 --> 00:19:18,130
it back up which point we'll see how

00:19:14,889 --> 00:19:20,500
long DHCP decides to take today took a

00:19:18,130 --> 00:19:21,639
while earlier but the idea is that the

00:19:20,500 --> 00:19:24,370
container hasn't been stopped or

00:19:21,639 --> 00:19:26,590
anything it's just it's if 0 has been

00:19:24,370 --> 00:19:29,940
effectively removed a new one has been

00:19:26,590 --> 00:19:32,559
moved directly from the host in place

00:19:29,940 --> 00:19:33,310
with the exact same name and now inside

00:19:32,559 --> 00:19:34,870
the container I'm just

00:19:33,310 --> 00:19:36,310
two bands networking without restarting

00:19:34,870 --> 00:19:41,860
the container because I thought it could

00:19:36,310 --> 00:19:44,110
be faster but maybe not so see yeah yeah

00:19:41,860 --> 00:19:47,800
yeah so it did something that you should

00:19:44,110 --> 00:19:50,290
have an ipv4 it does so we see if you

00:19:47,800 --> 00:19:53,050
remember right it the IP before wasn't

00:19:50,290 --> 00:19:55,390
no ten dot something subnet which is

00:19:53,050 --> 00:19:58,390
what the bridge differed which uses no

00:19:55,390 --> 00:20:00,460
it's connected directly on physical

00:19:58,390 --> 00:20:06,160
network which is a 1 7 to 17 in this

00:20:00,460 --> 00:20:07,540
case now this one is not really related

00:20:06,160 --> 00:20:08,980
to all the past few of its kind of just

00:20:07,540 --> 00:20:14,140
for kicks because that's always fun

00:20:08,980 --> 00:20:18,010
so whoops what's going on here copy base

00:20:14,140 --> 00:20:21,460
not working today direct ok so I'm

00:20:18,010 --> 00:20:24,460
removing the if 0 device did yeah and

00:20:21,460 --> 00:20:28,870
I'm gonna re add it but connected to the

00:20:24,460 --> 00:20:35,860
original bridge and then restart that

00:20:28,870 --> 00:20:37,360
one container ok yeah it's but connected

00:20:35,860 --> 00:20:40,720
to the bridge number 9 enter the

00:20:37,360 --> 00:20:44,200
container there we go and I'm gonna be

00:20:40,720 --> 00:20:45,670
downloading a file from the local

00:20:44,200 --> 00:20:49,800
network we can see it so nothing at

00:20:45,670 --> 00:20:52,000
about 110 megabit per second

00:20:49,800 --> 00:20:56,500
actually no it's megabyte so don't ring

00:20:52,000 --> 00:20:58,750
a gigabit rate from the network what I

00:20:56,500 --> 00:21:00,940
can do now is I can dynamically add a

00:20:58,750 --> 00:21:03,640
setting of that device which is limits

00:21:00,940 --> 00:21:06,540
interest than the gibbet and we'll see

00:21:03,640 --> 00:21:15,040
the speed going down and down and down

00:21:06,540 --> 00:21:20,350
oh there we go 10 megabit oh we can move

00:21:15,040 --> 00:21:21,490
it I don't know 100 and we see how the

00:21:20,350 --> 00:21:23,590
fight might actually finish the nodding

00:21:21,490 --> 00:21:25,630
unfortunately that's going back up yeah

00:21:23,590 --> 00:21:30,130
it almost reached want to know give it

00:21:25,630 --> 00:21:31,690
again just before finishing so that's

00:21:30,130 --> 00:21:33,430
for the network stuff we can pass any

00:21:31,690 --> 00:21:35,500
network device we've got on your hosts

00:21:33,430 --> 00:21:37,780
if there are physical NICs just pass

00:21:35,500 --> 00:21:39,820
them in and they behave exactly like

00:21:37,780 --> 00:21:44,920
only no more device first next is

00:21:39,820 --> 00:21:50,340
concerns now let's go take a

00:21:44,920 --> 00:21:53,470
I'm in the container it's a bit laggy

00:21:50,340 --> 00:21:54,520
they're treating a new container this

00:21:53,470 --> 00:21:59,080
time Jen - because

00:21:54,520 --> 00:22:02,610
why not - you look at passing through

00:21:59,080 --> 00:22:02,610
disk devices and now that looks like

00:22:04,590 --> 00:22:11,830
that's where the node was faster when I

00:22:06,730 --> 00:22:18,580
tried the demo Nia what Jen - is

00:22:11,830 --> 00:22:19,990
surprisingly big all right oh no this is

00:22:18,580 --> 00:22:28,210
not recompiling itself when you launch

00:22:19,990 --> 00:22:30,280
it - sticks a little bit of time once it

00:22:28,210 --> 00:22:31,930
reaches 100% because since I'm using ZFS

00:22:30,280 --> 00:22:35,680
it means it's unpacking the image and

00:22:31,930 --> 00:22:37,390
creating a ZFS data set which then

00:22:35,680 --> 00:22:39,220
allows fit in containers very cheaply

00:22:37,390 --> 00:22:41,440
from that point on but the initial

00:22:39,220 --> 00:22:46,690
imagery import always takes bit longer

00:22:41,440 --> 00:22:49,170
because of that and a protection to is

00:22:46,690 --> 00:22:49,170
rather big

00:22:56,049 --> 00:22:59,899
yeah okay

00:22:57,950 --> 00:23:01,850
so doing to is fine I started the first

00:22:59,899 --> 00:23:04,549
thing we do is pretty simple just I want

00:23:01,850 --> 00:23:07,549
to expose slash home from the host into

00:23:04,549 --> 00:23:10,700
that demo discontinued I created at the

00:23:07,549 --> 00:23:11,149
mount point month /a I'm just gonna do

00:23:10,700 --> 00:23:16,639
that

00:23:11,149 --> 00:23:18,740
and then I can enter the container and

00:23:16,639 --> 00:23:20,960
look at what we've got in such mount

00:23:18,740 --> 00:23:24,649
we've got a directory and inside it we

00:23:20,960 --> 00:23:28,100
see my home directory that's a pretty

00:23:24,649 --> 00:23:30,590
simple case of just passing through any

00:23:28,100 --> 00:23:33,139
pops you want from your host next I'm

00:23:30,590 --> 00:23:36,409
going to format with X for spare SSD

00:23:33,139 --> 00:23:40,250
have gotten that given system and then

00:23:36,409 --> 00:23:42,230
tell XT I want to expose that's dev as

00:23:40,250 --> 00:23:45,769
de device into the container under the

00:23:42,230 --> 00:23:48,590
man point B also in the stash and so if

00:23:45,769 --> 00:23:49,850
we look at such mount we've got B it's

00:23:48,590 --> 00:23:51,889
because just got the last and font

00:23:49,850 --> 00:23:54,710
because it just got formatted but we can

00:23:51,889 --> 00:24:00,169
see at the bottom that it's devastated

00:23:54,710 --> 00:24:02,389
on month P and lastly for storage let's

00:24:00,169 --> 00:24:04,879
try and do something even more fun we

00:24:02,389 --> 00:24:07,519
recently added support force F in next

00:24:04,879 --> 00:24:09,769
day so I'm creating a new storage pool

00:24:07,519 --> 00:24:11,360
in next day itself so now if at least

00:24:09,769 --> 00:24:13,340
not so it pools we can see the fort is

00:24:11,360 --> 00:24:15,500
ZFS that's what was created at install

00:24:13,340 --> 00:24:17,779
time but then we've got safe that has

00:24:15,500 --> 00:24:22,429
been added there now I'm going to locate

00:24:17,779 --> 00:24:23,779
a new volume on surf called data to a6 a

00:24:22,429 --> 00:24:25,279
bit of time because of the surf cluster

00:24:23,779 --> 00:24:27,830
needing to replicate and whatnot

00:24:25,279 --> 00:24:31,309
there we go and now we can attach that

00:24:27,830 --> 00:24:33,490
particular safe data volume to the demo

00:24:31,309 --> 00:24:38,559
disk container with a device called C

00:24:33,490 --> 00:24:38,559
mounted at mount RC and

00:24:40,070 --> 00:24:45,300
go in the container and if we look at

00:24:43,230 --> 00:24:48,030
Mount we've got seed that's in there

00:24:45,300 --> 00:24:50,460
lost and found again and if we look out

00:24:48,030 --> 00:24:52,560
d/f we see that they've RPGs zero is

00:24:50,460 --> 00:24:55,550
mounted on Mount see so that's a safe

00:24:52,560 --> 00:24:57,900
volume that's attached to the container

00:24:55,550 --> 00:24:59,670
that can be very useful for people we

00:24:57,900 --> 00:25:00,960
need to like store big databases or

00:24:59,670 --> 00:25:02,580
whatnot a native application and

00:25:00,960 --> 00:25:04,860
clustering and whatnot of Ceph they can

00:25:02,580 --> 00:25:18,710
very easily attach step volumes to your

00:25:04,860 --> 00:25:18,710
containers this time let's try option X

00:25:19,490 --> 00:25:23,600
when I ran out of this choice pretty

00:25:21,480 --> 00:25:23,600
soon

00:25:25,820 --> 00:25:29,929
so the next thing I want to show is

00:25:27,379 --> 00:25:33,169
passing through UNIX devices

00:25:29,929 --> 00:25:34,429
that's what legs D tends to do for you

00:25:33,169 --> 00:25:37,369
with all of the other obstructions at

00:25:34,429 --> 00:25:38,720
your level we've got but this thing lets

00:25:37,369 --> 00:25:40,159
you attach anything else that you might

00:25:38,720 --> 00:25:41,570
come up with like only we had device

00:25:40,159 --> 00:25:43,580
that you've got that we've never heard

00:25:41,570 --> 00:25:45,200
of if it's got a UNIX character device

00:25:43,580 --> 00:25:48,139
an X plug device which is really pretty

00:25:45,200 --> 00:25:51,289
safe bet you can pass it so if that the

00:25:48,139 --> 00:25:55,009
first example I'll go with is KVM so I'm

00:25:51,289 --> 00:25:57,409
gonna attach to my unique demo UNIX

00:25:55,009 --> 00:26:04,009
container a new device called KVM that's

00:25:57,409 --> 00:26:06,529
a UNIX character device at Def KVM and

00:26:04,009 --> 00:26:08,570
now I'm inside the container and if I

00:26:06,529 --> 00:26:10,759
look at stash Dave I don't have much in

00:26:08,570 --> 00:26:12,859
there but I showed you of it a kvm

00:26:10,759 --> 00:26:14,960
device now don't really have the time to

00:26:12,859 --> 00:26:16,399
install it but I could install qmu there

00:26:14,960 --> 00:26:17,929
and then run in virtual machines from

00:26:16,399 --> 00:26:19,159
inside that container and container

00:26:17,929 --> 00:26:21,019
itself is completely unprivileged

00:26:19,159 --> 00:26:23,330
there's nothing running a real root in

00:26:21,019 --> 00:26:26,389
there it just has access to the DEF KVM

00:26:23,330 --> 00:26:28,099
device the other thing we can do is unix

00:26:26,389 --> 00:26:32,450
plug devices so in this case i'm passing

00:26:28,099 --> 00:26:35,869
that s de doctor to the container same

00:26:32,450 --> 00:26:38,840
thing if i go look in /dev we now have

00:26:35,869 --> 00:26:41,289
def as d and you could format it or do

00:26:38,840 --> 00:26:43,729
whatever you want with it except mounted

00:26:41,289 --> 00:26:46,009
it awkward but unprivileged containers

00:26:43,729 --> 00:26:48,919
are not allowed to mount blob devices

00:26:46,009 --> 00:26:50,479
except for very limited file systems so

00:26:48,919 --> 00:26:51,820
if you've got something that uses fuse

00:26:50,479 --> 00:26:56,239
it can interact with it

00:26:51,820 --> 00:26:57,950
x4 in Ubuntu you've got the major option

00:26:56,239 --> 00:26:59,899
that lets you bypass that but you can

00:26:57,950 --> 00:27:02,960
uncheck and it's Romantics x5 and if you

00:26:59,899 --> 00:27:07,159
want to but all of the first ends don't

00:27:02,960 --> 00:27:08,960
allow it the just like a safety feature

00:27:07,159 --> 00:27:10,549
you don't because that effectively

00:27:08,960 --> 00:27:13,549
allows an impervious user to mount a

00:27:10,549 --> 00:27:15,799
block device hitting the camel

00:27:13,549 --> 00:27:18,320
super block passing code they could

00:27:15,799 --> 00:27:19,669
handcraft a nasty block device that

00:27:18,320 --> 00:27:21,649
would then expect to be executed kernel

00:27:19,669 --> 00:27:23,179
code so that's not allowed by default

00:27:21,649 --> 00:27:24,409
you could make the container privileged

00:27:23,179 --> 00:27:29,119
at which point you would be allowed to

00:27:24,409 --> 00:27:30,899
mount okay that's it for this particular

00:27:29,119 --> 00:27:34,259
machine

00:27:30,899 --> 00:27:37,559
the next thing I want to show is GPU so

00:27:34,259 --> 00:27:39,059
we've got another system that's got two

00:27:37,559 --> 00:27:41,340
NVIDIA GPUs we can see there

00:27:39,059 --> 00:27:43,350
unfortunately they're two of the same so

00:27:41,340 --> 00:27:44,999
it's not nearly that great to see which

00:27:43,350 --> 00:27:48,090
has been passed all that kind stuff but

00:27:44,999 --> 00:27:50,159
that hosts us to NVIDIA GPUs we also

00:27:48,090 --> 00:27:53,610
have one container running on there

00:27:50,159 --> 00:27:56,039
called CUDA now if I go in that

00:27:53,610 --> 00:27:57,629
container and I run as my we'll see it

00:27:56,039 --> 00:28:01,529
fails because the container that doesn't

00:27:57,629 --> 00:28:04,320
have any GPU yet but I can tell XD to

00:28:01,529 --> 00:28:07,950
pass me a GPU in this case it passes the

00:28:04,320 --> 00:28:18,539
first one so I did said id zero and that

00:28:07,950 --> 00:28:20,490
is not working that's a bit special fine

00:28:18,539 --> 00:28:22,320
I'm just assuming it's the index that's

00:28:20,490 --> 00:28:27,029
confusing it's the power alright let's

00:28:22,320 --> 00:28:29,220
just try it out yep there we go

00:28:27,029 --> 00:28:30,269
oh I think I know why let me just

00:28:29,220 --> 00:28:34,259
recheck whether I'm right

00:28:30,269 --> 00:28:36,570
I believe that system used to just up to

00:28:34,259 --> 00:28:38,759
GPUs but nothing Knights goes 3 and 0

00:28:36,570 --> 00:28:41,639
I'm guessing it an Intel chip you

00:28:38,759 --> 00:28:47,759
so assuming that's the case that means

00:28:41,639 --> 00:28:50,279
that if I remove that GPU ok so I

00:28:47,759 --> 00:28:52,340
removed the GPU no I'm gonna re add it

00:28:50,279 --> 00:28:54,690
but this someone can go with index 1

00:28:52,340 --> 00:28:56,490
which should be an NVIDIA GPU which

00:28:54,690 --> 00:29:00,240
means it should show up there there we

00:28:56,490 --> 00:29:01,980
go it's much better and now I should be

00:29:00,240 --> 00:29:07,799
able to add another one I need to give

00:29:01,980 --> 00:29:08,789
it a name so TP one with ID 2 and there

00:29:07,799 --> 00:29:12,059
we go that's much better

00:29:08,789 --> 00:29:19,559
ok and that means that India we've got

00:29:12,059 --> 00:29:21,690
card 1 cup 2 and if I now pass 0 0 will

00:29:19,559 --> 00:29:25,289
not show up in Nvidia semi because it's

00:29:21,690 --> 00:29:27,419
an Intel GPU I think but it does show up

00:29:25,289 --> 00:29:29,490
as a dri note so you could do open sea

00:29:27,419 --> 00:29:31,139
open CA something against it if you

00:29:29,490 --> 00:29:33,330
wanted to that's gonna this is the same

00:29:31,139 --> 00:29:35,309
way like that an AMD GPU would show up

00:29:33,330 --> 00:29:36,779
they don't have a specific device not

00:29:35,309 --> 00:29:40,009
for compute but it does show up as

00:29:36,779 --> 00:29:40,009
render nodes dri

00:29:40,210 --> 00:29:45,510
now for actual computation stuff we can

00:29:42,549 --> 00:29:48,340
run one of the simple benchmarks from

00:29:45,510 --> 00:29:51,760
nvidia cuda just ruined does it quick

00:29:48,340 --> 00:29:53,620
bandwidth test against the GPU just to

00:29:51,760 --> 00:29:55,240
show what I mentioned earlier I can copy

00:29:53,620 --> 00:29:59,529
that container treating a second one

00:29:55,240 --> 00:30:00,880
with and then start the second container

00:29:59,529 --> 00:30:02,889
and takes it a bit of time because he

00:30:00,880 --> 00:30:04,299
needs to rewrite a bunch of stuff on the

00:30:02,889 --> 00:30:07,000
PI system real quick and that's system

00:30:04,299 --> 00:30:08,620
is a bit slow but the idea is that the

00:30:07,000 --> 00:30:11,919
cuda container is still running it's all

00:30:08,620 --> 00:30:14,019
those GPUs attached to it I copied it

00:30:11,919 --> 00:30:16,990
which means it's got cuda Juana's now

00:30:14,019 --> 00:30:19,299
the exact same config and can see the

00:30:16,990 --> 00:30:23,799
exact same GPUs as the first container

00:30:19,299 --> 00:30:25,630
so if you had some reason to run

00:30:23,799 --> 00:30:27,760
different workloads and not really care

00:30:25,630 --> 00:30:29,500
about dedicated GPU time you can just

00:30:27,760 --> 00:30:34,630
share the same GPUs with as many

00:30:29,500 --> 00:30:38,559
containers as you want and lastly in the

00:30:34,630 --> 00:30:40,480
demo this time I'm actually on my local

00:30:38,559 --> 00:30:44,710
laptop so I'm sure the network is not

00:30:40,480 --> 00:30:47,350
gonna be a problem this time I've got my

00:30:44,710 --> 00:30:48,820
cell phone here I've got a container

00:30:47,350 --> 00:30:54,159
that's training that's called Android

00:30:48,820 --> 00:30:55,929
dev yeah that continual ask the Android

00:30:54,159 --> 00:30:58,210
tools installed so if I run ADB devices

00:30:55,929 --> 00:31:01,710
that's gonna scan all this code on the

00:30:58,210 --> 00:31:01,710
USB bus and tell me I've got nothing

00:31:02,070 --> 00:31:07,539
which is kind of expected since the

00:31:04,539 --> 00:31:11,490
phone is not connected anyways but now

00:31:07,539 --> 00:31:11,490
if I was to connect it

00:31:14,320 --> 00:31:22,380
all right I need to enable USB debugging

00:31:17,740 --> 00:31:22,380
on the phone itself so that it works for

00:31:22,620 --> 00:31:29,440
so it can work with ADB so turn on

00:31:25,919 --> 00:31:35,590
development and turn on USB debugging

00:31:29,440 --> 00:31:38,019
there we go so now the phone if I look

00:31:35,590 --> 00:31:40,149
on my laptop itself I should be able to

00:31:38,019 --> 00:31:42,370
see a Sony device there we go

00:31:40,149 --> 00:31:44,019
it's showing up on USB it's still not

00:31:42,370 --> 00:31:45,759
showing up in the container that's

00:31:44,019 --> 00:31:49,389
because I've not passed it to the

00:31:45,759 --> 00:31:50,679
container so I can turn the XD that I

00:31:49,389 --> 00:31:52,690
want to pass to that Android dev

00:31:50,679 --> 00:31:55,090
container a new device called phone

00:31:52,690 --> 00:31:58,690
that's a USB device with the window ID

00:31:55,090 --> 00:32:01,539
and Product ID I showed earlier now the

00:31:58,690 --> 00:32:04,929
phone device has been passed on my phone

00:32:01,539 --> 00:32:07,029
it now shows the prompt for the security

00:32:04,929 --> 00:32:08,590
key for the container which means that

00:32:07,029 --> 00:32:10,480
it's got its fun something but it's

00:32:08,590 --> 00:32:14,679
offline since it's not trusted on the

00:32:10,480 --> 00:32:18,490
phone yet no it is which means I should

00:32:14,679 --> 00:32:26,129
be able to do then I trust it hard

00:32:18,490 --> 00:32:26,129
enough as it should prompted let's try

00:32:26,429 --> 00:32:29,429
ok

00:32:30,190 --> 00:32:37,080
yeah yeah some convincing

00:32:33,550 --> 00:32:39,640
so now kind of an adb shell and I get

00:32:37,080 --> 00:32:42,820
actually on to my container what God

00:32:39,640 --> 00:32:44,440
what happened in the hood is def bus USB

00:32:42,820 --> 00:32:47,680
device actually actually just do fine or

00:32:44,440 --> 00:32:49,150
not you can see the device the device no

00:32:47,680 --> 00:32:52,480
it was created under there which is for

00:32:49,150 --> 00:32:53,590
my phone no if I unplug the phone like

00:32:52,480 --> 00:32:56,290
they would attack that and remove it

00:32:53,590 --> 00:32:58,360
immediately and if the device is

00:32:56,290 --> 00:33:00,790
connected that much is the configured

00:32:58,360 --> 00:33:02,170
pattern then it just did just get

00:33:00,790 --> 00:33:07,090
created immediately whenever it's broken

00:33:02,170 --> 00:33:09,850
and that's it for just about all the

00:33:07,090 --> 00:33:12,790
devices that we support passing through

00:33:09,850 --> 00:33:16,300
right now and I've got five minutes left

00:33:12,790 --> 00:33:18,940
so it seems to work out pretty well just

00:33:16,300 --> 00:33:23,950
to recap Ganem what I showed

00:33:18,940 --> 00:33:25,630
now the we can really pass just about

00:33:23,950 --> 00:33:27,700
any device into the container

00:33:25,630 --> 00:33:30,190
the only real requirement is that your

00:33:27,700 --> 00:33:31,600
host kernel must support it so if it's

00:33:30,190 --> 00:33:33,220
some fancy piece of hardware that

00:33:31,600 --> 00:33:35,740
requires its own kernel module that you

00:33:33,220 --> 00:33:37,900
need to hand compile and load it only

00:33:35,740 --> 00:33:40,300
works if you can have whoever runs your

00:33:37,900 --> 00:33:41,880
horse to do that for you so long as they

00:33:40,300 --> 00:33:44,020
do you can pass it to your container

00:33:41,880 --> 00:33:47,170
just figure out what device nodes are

00:33:44,020 --> 00:33:48,910
needed if it's a GPU USB or USB device

00:33:47,170 --> 00:33:51,880
we've got nice abstractions that do all

00:33:48,910 --> 00:33:54,340
of that stuff for you if it's something

00:33:51,880 --> 00:33:56,620
fancier then you just need to figure out

00:33:54,340 --> 00:33:58,210
what the actual path and the dev is and

00:33:56,620 --> 00:34:00,400
you can pass that to the container and

00:33:58,210 --> 00:34:03,930
your container can then access that

00:34:00,400 --> 00:34:06,220
without any of the usual overhead the

00:34:03,930 --> 00:34:08,740
all of that stuff doesn't require any

00:34:06,220 --> 00:34:11,590
kind of fancy hardware you don't need

00:34:08,740 --> 00:34:14,860
vfi or you don't need like the right

00:34:11,590 --> 00:34:15,880
version of BIOS and motorboat and all of

00:34:14,860 --> 00:34:17,320
that said that usually comes in with

00:34:15,880 --> 00:34:20,320
trying to do that stuff with virtual

00:34:17,320 --> 00:34:22,510
machines because we don't need to

00:34:20,320 --> 00:34:24,370
virtualize PCI devices effectively we

00:34:22,510 --> 00:34:25,960
just pass the resulting device nodes

00:34:24,370 --> 00:34:27,520
none of that stuff applies you can use

00:34:25,960 --> 00:34:31,210
consumer grade hardware if you want to

00:34:27,520 --> 00:34:34,230
and just works and we can share those

00:34:31,210 --> 00:34:38,110
devices with as many containers you want

00:34:34,230 --> 00:34:39,399
it's pretty simple it just do the device

00:34:38,110 --> 00:34:42,370
knows exposed to more than one container

00:34:39,399 --> 00:34:44,950
so long as I cannot drive a support

00:34:42,370 --> 00:34:46,540
multiple accesses it's gonna walk fine

00:34:44,950 --> 00:34:48,190
the kind of driver doesn't support it in

00:34:46,540 --> 00:34:50,590
the first container attaches to a to the

00:34:48,190 --> 00:34:51,820
second one gets a mutually pretty clear

00:34:50,590 --> 00:34:53,050
error message coming back from the

00:34:51,820 --> 00:34:58,810
kernel saying that it's already being

00:34:53,050 --> 00:35:00,880
used and they can try again later and so

00:34:58,810 --> 00:35:03,160
that's it for what I've got here it's

00:35:00,880 --> 00:35:04,360
was really my goal here was really

00:35:03,160 --> 00:35:06,550
trying to show you that system

00:35:04,360 --> 00:35:08,710
containers are in a lot of cases very

00:35:06,550 --> 00:35:10,920
good replacement for virtual machines it

00:35:08,710 --> 00:35:15,250
in my mind it doesn't really make sense

00:35:10,920 --> 00:35:16,870
for people to run Linux on Linux like

00:35:15,250 --> 00:35:20,440
running a Linux virtual machine on top

00:35:16,870 --> 00:35:23,050
of Linux in most cases you don't really

00:35:20,440 --> 00:35:25,060
need to do not you could use a container

00:35:23,050 --> 00:35:27,370
not get any of the overhead and

00:35:25,060 --> 00:35:29,920
complexity that comes with not there are

00:35:27,370 --> 00:35:31,930
some cases where you need it because of

00:35:29,920 --> 00:35:33,610
special kind of modules because you need

00:35:31,930 --> 00:35:35,050
some very specific an old version or

00:35:33,610 --> 00:35:37,540
something or not or because you need one

00:35:35,050 --> 00:35:38,920
in the other operating system or you've

00:35:37,540 --> 00:35:41,950
got some very specific security

00:35:38,920 --> 00:35:44,020
constraint maybe but in the bulk of

00:35:41,950 --> 00:35:46,630
cases you can use containers just as you

00:35:44,020 --> 00:35:49,570
would virtual machines and you don't get

00:35:46,630 --> 00:35:52,090
any overhead you get crazy density of

00:35:49,570 --> 00:35:55,540
that and it's so usually much simpler

00:35:52,090 --> 00:35:56,860
and faster so that was really it for my

00:35:55,540 --> 00:35:59,620
talk I do have a bunch of flex these

00:35:56,860 --> 00:36:01,960
stickers if any of you like those and

00:35:59,620 --> 00:36:04,380
that's it does anyone have any questions

00:36:01,960 --> 00:36:04,380
me

00:36:19,920 --> 00:36:23,970
in the container that will always like

00:36:21,720 --> 00:36:27,780
we you can call them whatever you want

00:36:23,970 --> 00:36:31,140
really it doesn't matter for the GPU

00:36:27,780 --> 00:36:34,920
case when you say that you want the

00:36:31,140 --> 00:36:36,810
first card then we will align it at the

00:36:34,920 --> 00:36:39,750
dri level because there are occasion if

00:36:36,810 --> 00:36:42,600
some weirdnesses like if we remembered

00:36:39,750 --> 00:36:44,010
things like if you say passes the second

00:36:42,600 --> 00:36:46,890
card and we were to show it out Scout

00:36:44,010 --> 00:36:49,410
zero that would confuse some software

00:36:46,890 --> 00:36:51,210
that would be going to slag slash this

00:36:49,410 --> 00:36:54,420
to get some extra information that might

00:36:51,210 --> 00:36:57,450
be problematic so we usually pass it as

00:36:54,420 --> 00:37:00,770
it is as far as naming and we've not

00:36:57,450 --> 00:37:00,770
really run into any problems there

00:37:09,380 --> 00:37:14,670
okay yeah so I forgot to mention I'll

00:37:12,270 --> 00:37:17,790
take the physical next is that's the one

00:37:14,670 --> 00:37:19,260
case where sharing is tricky because the

00:37:17,790 --> 00:37:21,270
the way that the way it works at the

00:37:19,260 --> 00:37:23,520
current level is at a single NIC can

00:37:21,270 --> 00:37:26,010
network interface can only be in a

00:37:23,520 --> 00:37:27,450
single networking space so if you move

00:37:26,010 --> 00:37:28,770
it to a container it actually disappears

00:37:27,450 --> 00:37:30,480
from the host and that's the one case

00:37:28,770 --> 00:37:31,859
where that does happen if you want to

00:37:30,480 --> 00:37:33,210
share it the only way you can really do

00:37:31,859 --> 00:37:34,770
it is by creating a bridge on the host

00:37:33,210 --> 00:37:37,170
bridge ring that snake in there and then

00:37:34,770 --> 00:37:40,050
attaching containers it is the one case

00:37:37,170 --> 00:37:42,060
where you can't just share a device node

00:37:40,050 --> 00:37:44,339
effectively because NICs don't have

00:37:42,060 --> 00:37:47,210
device nodes and no dev they're their

00:37:44,339 --> 00:37:47,210
own cannon structure

00:37:47,900 --> 00:37:52,800
yeah so if you if so if yeah what you

00:37:51,210 --> 00:37:54,690
can't always do is if you do have the

00:37:52,800 --> 00:37:56,579
fancy hardware you can configure the

00:37:54,690 --> 00:37:59,700
fancy hardware to show us a bunch of

00:37:56,579 --> 00:38:01,140
physical little devices on hosts so you

00:37:59,700 --> 00:38:02,940
would have one physical network card

00:38:01,140 --> 00:38:05,069
that we didn't show up as like 10 if

00:38:02,940 --> 00:38:07,710
type devices on the host then you can

00:38:05,069 --> 00:38:09,510
dispatch those into your containers but

00:38:07,710 --> 00:38:12,869
if you've got a card that cannot do that

00:38:09,510 --> 00:38:14,520
split by itself then you should bridge

00:38:12,869 --> 00:38:16,050
it and then reach the containers into it

00:38:14,520 --> 00:38:17,790
or you can use Magdalene

00:38:16,050 --> 00:38:21,810
we also support Magdalene directly at

00:38:17,790 --> 00:38:23,780
legacy layer which might be faster than

00:38:21,810 --> 00:38:26,579
straight bridging given that some of

00:38:23,780 --> 00:38:28,740
most of the new cards are capable of at

00:38:26,579 --> 00:38:32,099
the other level listen for more than one

00:38:28,740 --> 00:38:33,930
MAC address which is like the usual

00:38:32,099 --> 00:38:35,250
that's a big bottleneck wave bridging if

00:38:33,930 --> 00:38:36,839
you bridge it a'dreea means you're going

00:38:35,250 --> 00:38:38,130
to promiscuous mode which then means a

00:38:36,839 --> 00:38:39,930
lot of overhead because all you the

00:38:38,130 --> 00:38:42,780
traffic from the neck actually hates the

00:38:39,930 --> 00:38:45,359
camel if use Magdalene you don't need to

00:38:42,780 --> 00:38:49,410
enter promiscuous mode until you

00:38:45,359 --> 00:38:50,550
actually hit the the number of MAC

00:38:49,410 --> 00:38:53,700
addresses that are given Nikki can

00:38:50,550 --> 00:38:55,770
listen for and that means that the card

00:38:53,700 --> 00:38:57,510
itself doesn't send and only sends the

00:38:55,770 --> 00:39:00,500
traffic that Kendall needs and not

00:38:57,510 --> 00:39:00,500
everything else

00:39:01,000 --> 00:39:04,000
hmm

00:39:19,040 --> 00:39:22,980
it does the exact same thing I mean as

00:39:21,450 --> 00:39:24,300
far as Enix is concerned you'd still

00:39:22,980 --> 00:39:27,030
have processes you still have some fancy

00:39:24,300 --> 00:39:28,590
name spacing around it but it's instead

00:39:27,030 --> 00:39:29,700
of being in the host network name space

00:39:28,590 --> 00:39:33,480
you're in the continuous end of time

00:39:29,700 --> 00:39:34,680
space and but it's still a post silver

00:39:33,480 --> 00:39:42,690
single process actually listening and

00:39:34,680 --> 00:39:44,310
just still goes exactly the same it

00:39:42,690 --> 00:39:46,920
depends what your it depends what you're

00:39:44,310 --> 00:39:48,150
doing I mean you it's the exact same you

00:39:46,920 --> 00:39:50,280
get the exact same thing as you would a

00:39:48,150 --> 00:39:52,020
normal network device on the next it

00:39:50,280 --> 00:39:54,720
shows up as an if there's an ethernet

00:39:52,020 --> 00:39:55,980
device the kernel does all of the

00:39:54,720 --> 00:39:58,050
network the network stack is still in

00:39:55,980 --> 00:40:00,000
the kernel and in your container you

00:39:58,050 --> 00:40:01,680
bind a given address and you cannot get

00:40:00,000 --> 00:40:05,060
your connections onto it

00:40:01,680 --> 00:40:05,060
that was no different

00:40:19,290 --> 00:40:24,970
and the packet just as it usually would

00:40:22,780 --> 00:40:27,010
will hit the network card will be for

00:40:24,970 --> 00:40:29,410
arrived in the kernel in the kernel

00:40:27,010 --> 00:40:33,010
driver for the network for that network

00:40:29,410 --> 00:40:36,550
card it will go into the normal kind of

00:40:33,010 --> 00:40:38,890
talking stack and at that points the

00:40:36,550 --> 00:40:42,010
only thing is that what's bound like it

00:40:38,890 --> 00:40:44,260
will do it in normal tcp/ip stack figure

00:40:42,010 --> 00:40:46,599
out what IP it's targeted to whether

00:40:44,260 --> 00:40:49,240
that port is bound by something the only

00:40:46,599 --> 00:40:51,910
thing is that all of the we work the net

00:40:49,240 --> 00:40:53,619
filter thing is namespaced so all of the

00:40:51,910 --> 00:40:56,020
firewalling and all that stuff is per

00:40:53,619 --> 00:40:57,430
container so it's gonna know that since

00:40:56,020 --> 00:40:58,900
that nick is in that particular

00:40:57,430 --> 00:41:01,540
container it needs to go shoot that's

00:40:58,900 --> 00:41:04,840
net filter set of rules on the host and

00:41:01,540 --> 00:41:06,310
then it will go and see what whether

00:41:04,840 --> 00:41:08,770
there's something bounce to that given

00:41:06,310 --> 00:41:10,030
IP and port and will hit it at the

00:41:08,770 --> 00:41:18,820
process level exactly that normally

00:41:10,030 --> 00:41:20,530
would now I shared review the main

00:41:18,820 --> 00:41:23,410
benefit is like you do have a bunch of

00:41:20,530 --> 00:41:24,970
so you might have some cases where say

00:41:23,410 --> 00:41:26,290
your development lab or something and

00:41:24,970 --> 00:41:28,390
you've got one machine that's got a

00:41:26,290 --> 00:41:30,369
couple of big GPUs and you've got

00:41:28,390 --> 00:41:33,040
20-something people that may want to run

00:41:30,369 --> 00:41:35,140
some workloads against that if they've

00:41:33,040 --> 00:41:36,790
got raw access to the machine they might

00:41:35,140 --> 00:41:39,250
just mess it up by installing crap all

00:41:36,790 --> 00:41:41,950
over the place with containers it's

00:41:39,250 --> 00:41:43,900
their own thing so if they break the

00:41:41,950 --> 00:41:47,099
user space well it just broke themselves

00:41:43,900 --> 00:41:49,240
they don't didn't break anyone else and

00:41:47,099 --> 00:41:50,859
yes it would be nicer for them to have a

00:41:49,240 --> 00:41:53,290
dedicated GPU because then it would

00:41:50,859 --> 00:41:55,930
guarantee its timing and performance but

00:41:53,290 --> 00:41:57,339
that's very expensive so for development

00:41:55,930 --> 00:41:58,960
environments it tends to be nicer for

00:41:57,339 --> 00:42:01,240
them to just be able to hit some shared

00:41:58,960 --> 00:42:02,650
GPUs do their tests against that and if

00:42:01,240 --> 00:42:04,119
you want to go to production and then

00:42:02,650 --> 00:42:05,740
want something that's always got the

00:42:04,119 --> 00:42:08,109
exact same performance then you can just

00:42:05,740 --> 00:42:11,190
pass a single GPU per container and gets

00:42:08,109 --> 00:42:11,190
guaranteed performance

00:42:14,449 --> 00:42:18,539
no you can pass it to multiple

00:42:16,890 --> 00:42:21,269
containers they all see it's the exact

00:42:18,539 --> 00:42:23,249
same thing as running multiple processes

00:42:21,269 --> 00:42:25,170
that are talking to your GPU on a normal

00:42:23,249 --> 00:42:26,579
laptop effectively you can have more

00:42:25,170 --> 00:42:28,259
than one piece of software do rendering

00:42:26,579 --> 00:42:29,759
at any given time you can have more than

00:42:28,259 --> 00:42:32,190
one container doing rendering at any

00:42:29,759 --> 00:42:40,949
given time it's just that you share the

00:42:32,190 --> 00:42:42,479
GPU memory and CPU time no we don't the

00:42:40,949 --> 00:42:46,469
in the vast majority of cases it's

00:42:42,479 --> 00:42:47,910
really like GPU you could do it for a

00:42:46,469 --> 00:42:50,789
long time by knowing exactly what

00:42:47,910 --> 00:42:52,559
devices you need to pass but that was a

00:42:50,789 --> 00:42:54,329
bit awkward so we added abstraction on

00:42:52,559 --> 00:42:55,559
top of it to make it nicer and that's

00:42:54,329 --> 00:42:58,619
the kind of thing we might end up doing

00:42:55,559 --> 00:43:00,599
for other devices but usually there's

00:42:58,619 --> 00:43:02,069
really nothing to do it's like you just

00:43:00,599 --> 00:43:04,499
plug some device it shows up as some

00:43:02,069 --> 00:43:06,839
device note in /dev you can just pass

00:43:04,499 --> 00:43:07,829
that into the container the the only

00:43:06,839 --> 00:43:10,829
case or you might want kernel

00:43:07,829 --> 00:43:12,299
development is if a device would in

00:43:10,829 --> 00:43:13,619
theory be able to have multiple

00:43:12,299 --> 00:43:15,119
connections to it but the kernel does

00:43:13,619 --> 00:43:17,339
not support that then you might want to

00:43:15,119 --> 00:43:18,599
try and get that resolved so that you

00:43:17,339 --> 00:43:20,819
can have multiple containers talking to

00:43:18,599 --> 00:43:22,079
it at the same time but that's again

00:43:20,819 --> 00:43:23,819
that wouldn't be any different than

00:43:22,079 --> 00:43:26,809
having multiple processes talking to it

00:43:23,819 --> 00:43:26,809
on the host directly

00:43:30,820 --> 00:43:38,210
[Music]

00:43:32,140 --> 00:43:39,950
yeah yeah you should be able to pass def

00:43:38,210 --> 00:43:41,780
TPM to multiple containers if you want

00:43:39,950 --> 00:43:45,260
to whether it's a good idea or not that

00:43:41,780 --> 00:43:47,900
that might depend but yes we're out of

00:43:45,260 --> 00:43:49,520
time so if anyone has more questions we

00:43:47,900 --> 00:43:51,200
can talk outside there are stickers

00:43:49,520 --> 00:43:52,120
there's if you want them thank you very

00:43:51,200 --> 00:43:56,460
much

00:43:52,120 --> 00:43:56,460

YouTube URL: https://www.youtube.com/watch?v=TYHGhmWh3J8


