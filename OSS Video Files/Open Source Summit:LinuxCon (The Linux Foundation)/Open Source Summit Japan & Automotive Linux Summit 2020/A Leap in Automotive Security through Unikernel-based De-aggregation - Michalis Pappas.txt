Title: A Leap in Automotive Security through Unikernel-based De-aggregation - Michalis Pappas
Publication date: 2020-12-03
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	A Leap in Automotive Security through Unikernel-based De-aggregation - Michalis Pappas, OpenSynergy GmbH
Captions: 
	00:00:07,359 --> 00:00:11,120
okay hi

00:00:08,080 --> 00:00:12,240
everyone i am michalis papas i am a

00:00:11,120 --> 00:00:14,960
senior engineer

00:00:12,240 --> 00:00:17,199
in virtualization at open synergy and

00:00:14,960 --> 00:00:18,960
today i'll present our advancements

00:00:17,199 --> 00:00:20,400
in virtualization security with the use

00:00:18,960 --> 00:00:22,240
of unit kernels

00:00:20,400 --> 00:00:24,320
and specifically show how the caucus

00:00:22,240 --> 00:00:25,119
hypervisor can leverage the unicrest

00:00:24,320 --> 00:00:28,840
project

00:00:25,119 --> 00:00:31,840
to create highly isolated unicorn-based

00:00:28,840 --> 00:00:31,840
services

00:00:34,000 --> 00:00:37,440
i'll start with a brief introduction to

00:00:36,239 --> 00:00:39,120
the cocos hypervisor

00:00:37,440 --> 00:00:40,640
and proceed to describe the security

00:00:39,120 --> 00:00:42,000
challenges caused by aggregating

00:00:40,640 --> 00:00:45,840
functionality

00:00:42,000 --> 00:00:47,520
on top of large monolithic guests

00:00:45,840 --> 00:00:49,200
we'll see how this aggregation is bad

00:00:47,520 --> 00:00:53,680
for security and highlight

00:00:49,200 --> 00:00:55,760
the need for component isolation

00:00:53,680 --> 00:00:57,520
i'll move on to show how unique kernels

00:00:55,760 --> 00:00:58,000
provide the suitable platform for

00:00:57,520 --> 00:01:00,320
building

00:00:58,000 --> 00:01:01,920
isolated components and introduce the

00:01:00,320 --> 00:01:03,920
unicaf project

00:01:01,920 --> 00:01:07,119
which allows us to build highly

00:01:03,920 --> 00:01:09,280
specialized operating system images

00:01:07,119 --> 00:01:12,960
we will focus on unicast architecture

00:01:09,280 --> 00:01:14,960
and have a look at some data that shows

00:01:12,960 --> 00:01:17,520
that the unicorns produced by unicraft

00:01:14,960 --> 00:01:19,280
are characterized by small size

00:01:17,520 --> 00:01:21,840
small memory footprint and high

00:01:19,280 --> 00:01:21,840
performance

00:01:22,000 --> 00:01:25,280
we will then have a closer look on how

00:01:23,920 --> 00:01:26,799
component isolation

00:01:25,280 --> 00:01:28,320
is an integral part of coco's

00:01:26,799 --> 00:01:29,840
hypervisor's architecture

00:01:28,320 --> 00:01:32,479
and see some additional features that

00:01:29,840 --> 00:01:35,439
complement this approach

00:01:32,479 --> 00:01:37,119
finally we will see how all these fit

00:01:35,439 --> 00:01:39,520
together with the case study

00:01:37,119 --> 00:01:41,520
on how we implement virtualization of

00:01:39,520 --> 00:01:45,040
trusted execution environments with the

00:01:41,520 --> 00:01:45,040
assistance of unicorns

00:01:46,960 --> 00:01:52,720
so the cocos hypervisor or cocos hp is a

00:01:50,000 --> 00:01:54,320
type 1 hypervisor that makes use of

00:01:52,720 --> 00:01:56,000
hardware support for visualization

00:01:54,320 --> 00:01:58,960
provided by

00:01:56,000 --> 00:01:59,840
the arm v8 architecture its main focus

00:01:58,960 --> 00:02:02,000
is secure

00:01:59,840 --> 00:02:03,200
and safety critical automotive systems

00:02:02,000 --> 00:02:08,479
and is certified as

00:02:03,200 --> 00:02:10,640
aslb under the iso 26262 standard

00:02:08,479 --> 00:02:12,560
the main purpose of the caucus

00:02:10,640 --> 00:02:14,319
hypervisor is to allow the consolidation

00:02:12,560 --> 00:02:15,920
of components of different criticality

00:02:14,319 --> 00:02:18,560
on the same soc

00:02:15,920 --> 00:02:20,319
which in practice means that you can run

00:02:18,560 --> 00:02:22,480
guests of different hazel

00:02:20,319 --> 00:02:24,640
levels on the same hardware and the

00:02:22,480 --> 00:02:26,480
hypervisor will provide guarantees for

00:02:24,640 --> 00:02:29,200
strong isolation and freedom from

00:02:26,480 --> 00:02:29,200
interference

00:02:31,440 --> 00:02:35,760
so strong isolation is critical for both

00:02:34,000 --> 00:02:38,239
security and safety

00:02:35,760 --> 00:02:39,920
but in reality guests are rarely

00:02:38,239 --> 00:02:43,840
completely isolated from each other and

00:02:39,920 --> 00:02:43,840
that's because of inter vm communication

00:02:44,239 --> 00:02:47,920
that is required in nearly every

00:02:46,239 --> 00:02:51,360
practical use case for at least

00:02:47,920 --> 00:02:53,120
some of the guests

00:02:51,360 --> 00:02:54,959
i'll demonstrate the effects of

00:02:53,120 --> 00:02:56,959
interview communication with an example

00:02:54,959 --> 00:03:00,319
so consider

00:02:56,959 --> 00:03:01,200
a typical automotive setup with a linux

00:03:00,319 --> 00:03:04,560
based

00:03:01,200 --> 00:03:07,120
instrument cluster and an android-based

00:03:04,560 --> 00:03:09,760
infotainment system along with an

00:03:07,120 --> 00:03:13,200
officer guest providing some other

00:03:09,760 --> 00:03:15,440
ecu functionality so in an ideal world

00:03:13,200 --> 00:03:17,040
these guests would run in complete

00:03:15,440 --> 00:03:20,159
isolation from each other

00:03:17,040 --> 00:03:23,120
and in this case

00:03:20,159 --> 00:03:25,840
the tcb of each case will consist of the

00:03:23,120 --> 00:03:25,840
hypervisor

00:03:27,040 --> 00:03:31,440
in reality however safety critical

00:03:29,840 --> 00:03:34,720
hypervisors are small

00:03:31,440 --> 00:03:36,159
and additional functionality is normally

00:03:34,720 --> 00:03:39,200
implemented by

00:03:36,159 --> 00:03:41,120
one or more previous guests in our

00:03:39,200 --> 00:03:43,440
example we can think of

00:03:41,120 --> 00:03:45,280
one pvm that provides some sort of

00:03:43,440 --> 00:03:48,720
visualization service to the

00:03:45,280 --> 00:03:52,159
ic and ibi guests let's say maybe

00:03:48,720 --> 00:03:52,159
device virtualization

00:03:52,319 --> 00:03:56,400
this normally introduces the requirement

00:03:54,799 --> 00:03:59,360
for interviewing communication between

00:03:56,400 --> 00:04:01,280
the pvm and its clients

00:03:59,360 --> 00:04:05,280
which is usually implemented over some

00:04:01,280 --> 00:04:05,280
primitives provided by the hypervisor

00:04:08,319 --> 00:04:11,840
because of intervention communication

00:04:10,159 --> 00:04:14,239
the security of the pvm

00:04:11,840 --> 00:04:16,479
becomes critical and that's because a

00:04:14,239 --> 00:04:18,400
compromise of the pvm can impact all the

00:04:16,479 --> 00:04:21,759
guests

00:04:18,400 --> 00:04:25,360
this pvm provides services too

00:04:21,759 --> 00:04:26,720
so now the pvm becomes part of the tcp

00:04:25,360 --> 00:04:29,360
of its clients

00:04:26,720 --> 00:04:31,280
or in other words the ic and the avi are

00:04:29,360 --> 00:04:34,960
part of the same trust domain

00:04:31,280 --> 00:04:37,520
so you can see at the bottom diagram

00:04:34,960 --> 00:04:38,479
how the ic and the api now have to trust

00:04:37,520 --> 00:04:42,479
the hypervisor

00:04:38,479 --> 00:04:44,560
and the pvm as well notice however that

00:04:42,479 --> 00:04:45,840
the autostar guest is completely

00:04:44,560 --> 00:04:48,160
unaffected by all this

00:04:45,840 --> 00:04:50,800
thanks to strong isolation guarantees

00:04:48,160 --> 00:04:52,960
provided by the hypervisor

00:04:50,800 --> 00:04:53,919
so even if the other guests are fully

00:04:52,960 --> 00:04:58,320
compromised

00:04:53,919 --> 00:04:58,320
the auto star guest remains secure

00:04:58,560 --> 00:05:03,280
so as the pvm becomes part of the tcb

00:05:01,680 --> 00:05:05,919
for some guests

00:05:03,280 --> 00:05:07,520
it must demonstrate a small attack

00:05:05,919 --> 00:05:09,600
surface

00:05:07,520 --> 00:05:11,280
this however is not the case with many

00:05:09,600 --> 00:05:13,440
deployments today as

00:05:11,280 --> 00:05:15,440
we can see previous cases implemented

00:05:13,440 --> 00:05:16,800
over large monolithic operating systems

00:05:15,440 --> 00:05:20,000
such as linux

00:05:16,800 --> 00:05:23,120
that come with a big attack surface

00:05:20,000 --> 00:05:26,080
and even worse these guests

00:05:23,120 --> 00:05:27,440
aggregate multiple services and this is

00:05:26,080 --> 00:05:29,919
clearly bad for security

00:05:27,440 --> 00:05:31,919
as it only takes one vulnerable service

00:05:29,919 --> 00:05:34,800
to gain access to the entire system

00:05:31,919 --> 00:05:37,039
and we have seen multiple cases of cvs

00:05:34,800 --> 00:05:38,960
describing vm escape attacks by

00:05:37,039 --> 00:05:40,000
exploiting vulnerabilities in device

00:05:38,960 --> 00:05:44,800
drivers

00:05:40,000 --> 00:05:44,800
so a system compromise now

00:05:44,880 --> 00:05:48,240
affects all services running on the same

00:05:46,960 --> 00:05:51,280
guest

00:05:48,240 --> 00:05:53,759
and consequently

00:05:51,280 --> 00:05:55,520
the superset of client vms is now at

00:05:53,759 --> 00:06:00,800
risk

00:05:55,520 --> 00:06:00,800
so this calls for a direction towards

00:06:01,039 --> 00:06:06,240
service disaggregation and of course

00:06:03,440 --> 00:06:08,160
this problem is widely recognized

00:06:06,240 --> 00:06:10,000
for example you can see a paper

00:06:08,160 --> 00:06:10,400
published by the zen project on how to

00:06:10,000 --> 00:06:14,240
improve

00:06:10,400 --> 00:06:14,240
zen security through disaggregation

00:06:15,759 --> 00:06:19,120
our answer on how to achieve this

00:06:17,360 --> 00:06:21,120
aggregation is by

00:06:19,120 --> 00:06:23,039
leveraging the strong isolation provided

00:06:21,120 --> 00:06:25,520
by the hypervisor

00:06:23,039 --> 00:06:27,460
to compartmentalize its service to an

00:06:25,520 --> 00:06:28,880
isolated vm

00:06:27,460 --> 00:06:30,960
[Music]

00:06:28,880 --> 00:06:32,960
in in the figure you can see how we can

00:06:30,960 --> 00:06:38,000
break down

00:06:32,960 --> 00:06:40,800
the large pvm

00:06:38,000 --> 00:06:41,600
into a set of specialized guests one of

00:06:40,800 --> 00:06:43,360
which

00:06:41,600 --> 00:06:44,800
one of is providing a single

00:06:43,360 --> 00:06:46,880
functionality

00:06:44,800 --> 00:06:49,199
and this gives us an improved

00:06:46,880 --> 00:06:52,240
architecture with respect to security

00:06:49,199 --> 00:06:55,840
as we preserve a small tcb

00:06:52,240 --> 00:06:58,319
by minimizing the attack surface and

00:06:55,840 --> 00:07:02,160
limit the impact of compromise to a

00:06:58,319 --> 00:07:05,360
single service

00:07:02,160 --> 00:07:06,319
now the question is whether that is

00:07:05,360 --> 00:07:08,319
possible

00:07:06,319 --> 00:07:10,479
so traditionally the addition of guests

00:07:08,319 --> 00:07:14,160
is considered expensive

00:07:10,479 --> 00:07:15,360
so it's been avoided and i would even go

00:07:14,160 --> 00:07:17,520
as far as

00:07:15,360 --> 00:07:20,639
arguing that the main force behind

00:07:17,520 --> 00:07:22,319
aggregation has been performance

00:07:20,639 --> 00:07:24,880
nowadays however the landscape has

00:07:22,319 --> 00:07:27,840
changed with automotive use

00:07:24,880 --> 00:07:29,039
being deployed over powerful socs for

00:07:27,840 --> 00:07:31,919
example

00:07:29,039 --> 00:07:32,720
renzo salvatore xs features eight arm

00:07:31,919 --> 00:07:35,280
cores and

00:07:32,720 --> 00:07:37,199
four gigabytes of memory and newer

00:07:35,280 --> 00:07:40,800
platforms exhibit

00:07:37,199 --> 00:07:44,639
even more powerful specifications

00:07:40,800 --> 00:07:45,919
um nevertheless we still need a suitable

00:07:44,639 --> 00:07:49,039
operating system

00:07:45,919 --> 00:07:50,960
so i put down some requirements so

00:07:49,039 --> 00:07:52,479
we have seen that for our security

00:07:50,960 --> 00:07:54,080
requirements we need an operating system

00:07:52,479 --> 00:07:57,120
that provides

00:07:54,080 --> 00:08:00,080
small minimal images

00:07:57,120 --> 00:08:01,120
for the performance reason state above

00:08:00,080 --> 00:08:03,840
we also need

00:08:01,120 --> 00:08:04,639
these images to be lightweight we would

00:08:03,840 --> 00:08:07,360
like to have

00:08:04,639 --> 00:08:09,039
some degree of modularity so that we can

00:08:07,360 --> 00:08:09,840
tailor down the applications to our

00:08:09,039 --> 00:08:13,120
requirements

00:08:09,840 --> 00:08:16,800
whether they are minimal or

00:08:13,120 --> 00:08:18,639
feature rich and finally we would like

00:08:16,800 --> 00:08:20,319
to be able to port existing components

00:08:18,639 --> 00:08:22,720
with minimal effort

00:08:20,319 --> 00:08:24,479
and it turns out that unicorns provide

00:08:22,720 --> 00:08:27,680
the highly suitable tool

00:08:24,479 --> 00:08:30,000
for our criteria so let's see what

00:08:27,680 --> 00:08:33,760
unicorns are

00:08:30,000 --> 00:08:36,240
um unicorns are highly specialized

00:08:33,760 --> 00:08:37,039
operating system images running on a

00:08:36,240 --> 00:08:40,560
single

00:08:37,039 --> 00:08:42,880
other space constructed by

00:08:40,560 --> 00:08:44,720
library operating systems so the idea is

00:08:42,880 --> 00:08:45,519
that the user gets provided with a set

00:08:44,720 --> 00:08:48,399
of libraries

00:08:45,519 --> 00:08:49,600
and selects the smallest set of them

00:08:48,399 --> 00:08:52,080
needed to implement

00:08:49,600 --> 00:08:54,880
the operating system constructs required

00:08:52,080 --> 00:08:59,279
by the application

00:08:54,880 --> 00:09:01,120
by specialized we mean that

00:08:59,279 --> 00:09:02,560
our unit kernels execute a single

00:09:01,120 --> 00:09:06,480
application

00:09:02,560 --> 00:09:08,240
and this is the opposite of

00:09:06,480 --> 00:09:10,640
the concept of traditional general

00:09:08,240 --> 00:09:14,320
purpose operating systems

00:09:10,640 --> 00:09:16,399
um by single of the space uh

00:09:14,320 --> 00:09:19,200
we mean that as there is only one

00:09:16,399 --> 00:09:20,640
application there is no distinction

00:09:19,200 --> 00:09:22,320
there is no need for distinction between

00:09:20,640 --> 00:09:24,959
use space and kernel space

00:09:22,320 --> 00:09:26,080
so our application runs entirely in

00:09:24,959 --> 00:09:36,000
kernel space

00:09:26,080 --> 00:09:38,480
and in arm this is l1 of course

00:09:36,000 --> 00:09:40,800
will introduce now unicraft which is the

00:09:38,480 --> 00:09:44,000
unicorn project we use

00:09:40,800 --> 00:09:47,040
in the cocos hypervisor unicraft is

00:09:44,000 --> 00:09:50,160
a posix compliant library os

00:09:47,040 --> 00:09:53,680
with a high degree of modularity

00:09:50,160 --> 00:09:56,000
provided under the bsd3 closed license

00:09:53,680 --> 00:09:57,200
when it comes to architecture unicraft

00:09:56,000 --> 00:09:59,680
implements

00:09:57,200 --> 00:10:00,480
functional units as micro libraries and

00:09:59,680 --> 00:10:04,000
organizes

00:10:00,480 --> 00:10:05,760
micro libraries into library pools

00:10:04,000 --> 00:10:07,519
very important feature of unicraft is

00:10:05,760 --> 00:10:09,040
that it is fully librarized which means

00:10:07,519 --> 00:10:12,399
that everything is a library

00:10:09,040 --> 00:10:15,440
and that includes the very core

00:10:12,399 --> 00:10:16,720
operating system primitives so on the

00:10:15,440 --> 00:10:19,839
diagram on the right

00:10:16,720 --> 00:10:22,000
going bottom to top

00:10:19,839 --> 00:10:23,279
you can see that one can choose between

00:10:22,000 --> 00:10:27,120
different architectures

00:10:23,279 --> 00:10:28,240
then you have different platforms to

00:10:27,120 --> 00:10:32,320
choose from

00:10:28,240 --> 00:10:34,079
such as kvm zen or in our case the code

00:10:32,320 --> 00:10:36,240
hypervisor

00:10:34,079 --> 00:10:38,240
moving up you can see the main library

00:10:36,240 --> 00:10:40,079
pool that

00:10:38,240 --> 00:10:42,240
provides things like schedulers memory

00:10:40,079 --> 00:10:44,880
allocators network stacks

00:10:42,240 --> 00:10:46,640
or even different flavors of a standard

00:10:44,880 --> 00:10:49,200
library

00:10:46,640 --> 00:10:50,720
or even runtimes for high-level

00:10:49,200 --> 00:10:53,600
languages

00:10:50,720 --> 00:10:56,000
the workflow for building an application

00:10:53,600 --> 00:10:59,519
is configuring unicraft using k-config

00:10:56,000 --> 00:11:01,760
to select a set of libraries

00:10:59,519 --> 00:11:03,600
and setting various parameters and

00:11:01,760 --> 00:11:04,079
developing or porting an application

00:11:03,600 --> 00:11:07,120
that

00:11:04,079 --> 00:11:09,360
uses these libraries

00:11:07,120 --> 00:11:10,480
then everything is linked together into

00:11:09,360 --> 00:11:14,000
a single binary which

00:11:10,480 --> 00:11:16,800
is the resulting unicorn image

00:11:14,000 --> 00:11:17,519
so from what we can see unicraft allows

00:11:16,800 --> 00:11:20,880
us to build

00:11:17,519 --> 00:11:22,399
highly specialized and minimal operating

00:11:20,880 --> 00:11:26,720
system images

00:11:22,399 --> 00:11:29,920
and being fully librarized it gives us

00:11:26,720 --> 00:11:33,040
a lot of control in our domain

00:11:29,920 --> 00:11:35,200
we are mainly interested into

00:11:33,040 --> 00:11:36,800
very minimal images but there have been

00:11:35,200 --> 00:11:40,160
occasions where

00:11:36,800 --> 00:11:43,760
using a wider set of libraries

00:11:40,160 --> 00:11:46,079
has been required to port

00:11:43,760 --> 00:11:47,360
third-party applications so having the

00:11:46,079 --> 00:11:51,279
flexibility to do that

00:11:47,360 --> 00:11:52,800
is important and being posix compliant

00:11:51,279 --> 00:11:54,320
means that it is possible to port

00:11:52,800 --> 00:11:55,200
applications from other operating

00:11:54,320 --> 00:11:58,639
systems with

00:11:55,200 --> 00:11:58,639
a reasonably small effort

00:12:02,079 --> 00:12:05,760
so let's have a look at unicraft's

00:12:04,399 --> 00:12:07,680
performance

00:12:05,760 --> 00:12:09,040
the graphs here come originally from the

00:12:07,680 --> 00:12:12,320
unicaf project

00:12:09,040 --> 00:12:15,200
and the first graph shows

00:12:12,320 --> 00:12:16,959
some comparisons of image size of common

00:12:15,200 --> 00:12:20,399
applications built

00:12:16,959 --> 00:12:22,240
as unique kernels with unicraft

00:12:20,399 --> 00:12:24,079
and we can see the resulting images are

00:12:22,240 --> 00:12:27,120
very small with the total image

00:12:24,079 --> 00:12:28,959
size ranging from a few hundreds of

00:12:27,120 --> 00:12:32,320
kilobytes

00:12:28,959 --> 00:12:35,920
up to less than two megabytes and

00:12:32,320 --> 00:12:39,839
with additional optimizations we can

00:12:35,920 --> 00:12:41,519
achieve even smaller images in terms of

00:12:39,839 --> 00:12:43,600
ideal memory usage we can see a

00:12:41,519 --> 00:12:46,399
comparison between individual unicraft

00:12:43,600 --> 00:12:49,839
applications and various

00:12:46,399 --> 00:12:51,839
linux images and by a look

00:12:49,839 --> 00:12:53,200
at the numbers we can see that the

00:12:51,839 --> 00:12:56,160
difference can be as large

00:12:53,200 --> 00:12:58,000
as an order of magnitude of course

00:12:56,160 --> 00:12:59,600
memory usage defense depends on the

00:12:58,000 --> 00:13:02,399
application

00:12:59,600 --> 00:13:03,680
workload so these numbers can change

00:13:02,399 --> 00:13:05,760
depending on the application

00:13:03,680 --> 00:13:07,839
but you can still get an idea of how big

00:13:05,760 --> 00:13:11,680
the difference can be

00:13:07,839 --> 00:13:13,600
regarding book times again we can

00:13:11,680 --> 00:13:15,440
we compare common applications running

00:13:13,600 --> 00:13:18,839
on unicraft against

00:13:15,440 --> 00:13:20,079
linux images and the difference here is

00:13:18,839 --> 00:13:22,560
significant

00:13:20,079 --> 00:13:23,440
as most unicraft applications boot in

00:13:22,560 --> 00:13:26,880
less than

00:13:23,440 --> 00:13:26,880
100 milliseconds

00:13:26,959 --> 00:13:30,160
the last graph on the bottom right shows

00:13:29,200 --> 00:13:33,040
the comparison

00:13:30,160 --> 00:13:34,720
of light vm which is based on work

00:13:33,040 --> 00:13:37,839
preceding unicraft against docker

00:13:34,720 --> 00:13:40,959
booting on a 64 core server

00:13:37,839 --> 00:13:44,320
we won't be looking at docker

00:13:40,959 --> 00:13:46,560
so much as it's not relevant to our case

00:13:44,320 --> 00:13:48,959
but rather on how it is possible to put

00:13:46,560 --> 00:13:51,600
a large number of unique kernels

00:13:48,959 --> 00:13:52,800
on a given core while maintaining high

00:13:51,600 --> 00:13:55,680
performance

00:13:52,800 --> 00:13:57,440
so the conclusion is that unicraft

00:13:55,680 --> 00:13:59,440
provides us with an environment that

00:13:57,440 --> 00:14:02,079
allows us to build highly performant

00:13:59,440 --> 00:14:06,160
operating system images which makes the

00:14:02,079 --> 00:14:06,160
addition of guests no longer expensive

00:14:09,519 --> 00:14:12,480
at this point i'll switch back to the

00:14:10,959 --> 00:14:14,240
coco's hypervisor and discuss an

00:14:12,480 --> 00:14:17,120
important part of our architecture which

00:14:14,240 --> 00:14:19,519
is coco supervisor extensions

00:14:17,120 --> 00:14:20,320
cocos hypervisor extensions allow us to

00:14:19,519 --> 00:14:22,560
delegate

00:14:20,320 --> 00:14:24,560
functionality from the hypervisor to

00:14:22,560 --> 00:14:27,199
extension vms

00:14:24,560 --> 00:14:29,199
and that is because in order to fulfill

00:14:27,199 --> 00:14:31,839
its security and safety requirements

00:14:29,199 --> 00:14:33,360
the hypervisor core implements only the

00:14:31,839 --> 00:14:36,560
smallest set of features required to

00:14:33,360 --> 00:14:38,320
provide isolated visualization

00:14:36,560 --> 00:14:40,399
non-essential functionality is

00:14:38,320 --> 00:14:42,399
implemented in extension vms

00:14:40,399 --> 00:14:45,760
which are executing in a separate

00:14:42,399 --> 00:14:48,480
address space from the hypervisor core

00:14:45,760 --> 00:14:50,160
and this operation functionality allows

00:14:48,480 --> 00:14:52,959
avoiding cascading failures

00:14:50,160 --> 00:14:53,680
as attacks on extension vms or

00:14:52,959 --> 00:14:56,399
malfunction

00:14:53,680 --> 00:14:58,000
or extension vms don't interfere with

00:14:56,399 --> 00:15:01,120
execution of other guests or

00:14:58,000 --> 00:15:03,680
hypervisor itself so

00:15:01,120 --> 00:15:04,320
hypervisor extensions are an important

00:15:03,680 --> 00:15:06,399
concept

00:15:04,320 --> 00:15:08,000
as they allow the hypervisor to preserve

00:15:06,399 --> 00:15:10,079
its small tcp

00:15:08,000 --> 00:15:11,760
and they additionally provide high

00:15:10,079 --> 00:15:12,959
flexibility and modularity to the whole

00:15:11,760 --> 00:15:15,440
architecture as

00:15:12,959 --> 00:15:17,120
users can pick extensions to tailor the

00:15:15,440 --> 00:15:21,680
hypervisor functionality

00:15:17,120 --> 00:15:21,680
to match their use case

00:15:25,120 --> 00:15:30,720
another feature that complements um

00:15:28,240 --> 00:15:32,480
hypervisor extensions is synchronous

00:15:30,720 --> 00:15:34,000
exception forwarding

00:15:32,480 --> 00:15:35,839
um synchronous exception forwarding

00:15:34,000 --> 00:15:38,320
allows dropping

00:15:35,839 --> 00:15:40,880
synchronous exceptions triggered by a vm

00:15:38,320 --> 00:15:44,240
in the hypervisor and

00:15:40,880 --> 00:15:46,160
dispatching requests to extension vms

00:15:44,240 --> 00:15:49,839
for handling

00:15:46,160 --> 00:15:51,680
so the cochlear visor can be

00:15:49,839 --> 00:15:54,880
configured to trap exceptions of this

00:15:51,680 --> 00:15:57,680
kind for a number of guests

00:15:54,880 --> 00:15:59,279
when an exception occurs execution of

00:15:57,680 --> 00:16:00,320
the guest that triggered the exception

00:15:59,279 --> 00:16:03,519
is blocked

00:16:00,320 --> 00:16:06,320
the hypervisor traps the exception and

00:16:03,519 --> 00:16:09,680
dispatches a request to a pre-configured

00:16:06,320 --> 00:16:11,199
extension vm the extension vm process

00:16:09,680 --> 00:16:12,800
the request

00:16:11,199 --> 00:16:14,800
it notifies the hypervisor with the

00:16:12,800 --> 00:16:16,959
response and

00:16:14,800 --> 00:16:17,839
the hypervisor updates the aborting

00:16:16,959 --> 00:16:22,880
guest context

00:16:17,839 --> 00:16:25,120
and resumes its execution okay

00:16:22,880 --> 00:16:26,160
so with all the background covered i am

00:16:25,120 --> 00:16:30,000
now ready to provide

00:16:26,160 --> 00:16:37,839
an example uh that shows how all these

00:16:30,000 --> 00:16:37,839
work together

00:16:38,079 --> 00:16:42,720
so this example shows how we can use a

00:16:41,600 --> 00:16:45,759
uni kernel based

00:16:42,720 --> 00:16:49,519
extension vm to provide

00:16:45,759 --> 00:16:53,199
te virtualization services i will first

00:16:49,519 --> 00:16:57,040
provide some background on tes

00:16:53,199 --> 00:16:58,880
so t is an acronym for trusted execution

00:16:57,040 --> 00:17:01,199
environment

00:16:58,880 --> 00:17:02,399
and trusted execution environments

00:17:01,199 --> 00:17:05,120
provide platforms

00:17:02,399 --> 00:17:06,559
with a secure environment that can be

00:17:05,120 --> 00:17:09,679
used to protect secrets

00:17:06,559 --> 00:17:11,439
and perform operations on them

00:17:09,679 --> 00:17:12,720
the idea is that if the system is

00:17:11,439 --> 00:17:16,480
compromised the

00:17:12,720 --> 00:17:19,280
secrets remain protected by the te

00:17:16,480 --> 00:17:21,439
common examples of functionalities

00:17:19,280 --> 00:17:22,720
implemented by tes are key management

00:17:21,439 --> 00:17:25,839
anti-rollback

00:17:22,720 --> 00:17:27,760
secure storage drm and secure credential

00:17:25,839 --> 00:17:30,240
processing

00:17:27,760 --> 00:17:31,360
so in this example we will be focusing

00:17:30,240 --> 00:17:36,559
on opti

00:17:31,360 --> 00:17:39,760
which is a t developed by linaro

00:17:36,559 --> 00:17:41,039
so optics execution model is governed by

00:17:39,760 --> 00:17:45,120
the

00:17:41,039 --> 00:17:47,360
global platform standards and

00:17:45,120 --> 00:17:48,799
the standard specifies client

00:17:47,360 --> 00:17:52,080
applications executing

00:17:48,799 --> 00:17:52,880
in a rich os environment that

00:17:52,080 --> 00:17:55,760
communicate

00:17:52,880 --> 00:17:57,840
with trusted applications running in the

00:17:55,760 --> 00:18:02,400
trusted execution environment

00:17:57,840 --> 00:18:02,400
and in arm-based architectures

00:18:02,720 --> 00:18:06,960
there is hardware support for that which

00:18:05,280 --> 00:18:09,919
is trust zone

00:18:06,960 --> 00:18:12,080
and which provides two execution

00:18:09,919 --> 00:18:12,880
contacts the normal world and the secure

00:18:12,080 --> 00:18:15,120
world

00:18:12,880 --> 00:18:16,559
in the normal world you have your usual

00:18:15,120 --> 00:18:21,200
operating system

00:18:16,559 --> 00:18:23,039
or multiple vms in the hypervisor

00:18:21,200 --> 00:18:25,280
and in the secure world we have the

00:18:23,039 --> 00:18:29,840
secure os

00:18:25,280 --> 00:18:29,840
which is in this case opti

00:18:30,240 --> 00:18:34,559
at any given time the processor can

00:18:32,480 --> 00:18:35,600
execute either in the normal world or in

00:18:34,559 --> 00:18:38,400
the secure world

00:18:35,600 --> 00:18:40,200
and communication is usually invoked by

00:18:38,400 --> 00:18:41,600
the normal world

00:18:40,200 --> 00:18:45,120
[Music]

00:18:41,600 --> 00:18:47,679
issuing a secure monitor call or smc

00:18:45,120 --> 00:18:48,799
which causes the processor to switch to

00:18:47,679 --> 00:18:51,919
the secure world

00:18:48,799 --> 00:18:51,919
and process the request

00:18:53,520 --> 00:18:58,480
nowadays these are becoming ubiquitous

00:18:56,320 --> 00:19:03,840
in various types of devices

00:18:58,480 --> 00:19:07,440
and so is the requirement for

00:19:03,840 --> 00:19:09,440
virtualization support so

00:19:07,440 --> 00:19:11,840
major things now start providing this

00:19:09,440 --> 00:19:11,840
feature

00:19:12,000 --> 00:19:18,000
virtualization support normally requires

00:19:15,120 --> 00:19:19,120
some assistance from the hypervisor and

00:19:18,000 --> 00:19:22,640
in update that

00:19:19,120 --> 00:19:25,840
involves appending

00:19:22,640 --> 00:19:29,679
its request with a vmid

00:19:25,840 --> 00:19:33,200
and performing some memory translations

00:19:29,679 --> 00:19:37,200
security checks some context

00:19:33,200 --> 00:19:40,240
maintenance and so on opt refers to the

00:19:37,200 --> 00:19:44,320
virtualization layer as the optimizator

00:19:40,240 --> 00:19:47,360
and there is a reference implementation

00:19:44,320 --> 00:19:50,240
in the zen hypervisor

00:19:47,360 --> 00:19:51,280
the architecture can be seen in the

00:19:50,240 --> 00:19:53,520
figure on the right

00:19:51,280 --> 00:19:55,440
so here we have two guests issuing

00:19:53,520 --> 00:19:59,320
requests to the secure os

00:19:55,440 --> 00:20:02,640
and all requests are relayed through the

00:19:59,320 --> 00:20:04,640
optimizator which is implemented as part

00:20:02,640 --> 00:20:07,360
of the hypervisor

00:20:04,640 --> 00:20:07,679
now the problem with implementing uh the

00:20:07,360 --> 00:20:10,559
t

00:20:07,679 --> 00:20:11,760
visualization layer in the hypervisor is

00:20:10,559 --> 00:20:15,360
that it doesn't scale

00:20:11,760 --> 00:20:17,600
very well uh in safety critical systems

00:20:15,360 --> 00:20:18,960
and that is because in the arm ecosystem

00:20:17,600 --> 00:20:21,840
there are several

00:20:18,960 --> 00:20:23,200
trusted execution environments and

00:20:21,840 --> 00:20:25,440
although

00:20:23,200 --> 00:20:27,200
all of them implement visualization

00:20:25,440 --> 00:20:31,039
support in a similar way

00:20:27,200 --> 00:20:31,840
that is with the help of a visualization

00:20:31,039 --> 00:20:34,880
layer

00:20:31,840 --> 00:20:38,000
currently there is no standard governing

00:20:34,880 --> 00:20:40,799
te virtualization that is implemented by

00:20:38,000 --> 00:20:43,039
vendors so the result is that the

00:20:40,799 --> 00:20:46,840
specifics of the visualization layer

00:20:43,039 --> 00:20:48,080
is very much dependent on the te

00:20:46,840 --> 00:20:51,120
implementation

00:20:48,080 --> 00:20:53,760
and the complexity of this layer again

00:20:51,120 --> 00:20:56,640
varies very much between different

00:20:53,760 --> 00:20:59,520
trusted execution environments

00:20:56,640 --> 00:21:01,280
so this means that a hypervisor needs to

00:20:59,520 --> 00:21:05,280
provide a different implementation

00:21:01,280 --> 00:21:08,400
for everything it needs support and

00:21:05,280 --> 00:21:11,760
when it comes to

00:21:08,400 --> 00:21:14,840
safety critical hypervisors that

00:21:11,760 --> 00:21:17,840
need to be certified this can be a

00:21:14,840 --> 00:21:17,840
problem

00:21:20,799 --> 00:21:26,159
so our approach is to remove the

00:21:24,159 --> 00:21:30,559
complexity from the hypervisor

00:21:26,159 --> 00:21:32,480
and outsource it to an extension vm

00:21:30,559 --> 00:21:34,320
by leveraging the synchronous exception

00:21:32,480 --> 00:21:38,159
forwarding feature

00:21:34,320 --> 00:21:38,159
that allows us to trap smcs

00:21:38,720 --> 00:21:43,919
happening on the guests

00:21:42,240 --> 00:21:45,679
and for them for handling to an

00:21:43,919 --> 00:21:50,480
extension vm

00:21:45,679 --> 00:21:54,240
the architecture is shown on the diagram

00:21:50,480 --> 00:21:58,640
so the a guest will

00:21:54,240 --> 00:22:02,640
issue an smc through the current driver

00:21:58,640 --> 00:22:05,600
the hypervisor will trap the smc it will

00:22:02,640 --> 00:22:06,640
issue a request to the te mediator which

00:22:05,600 --> 00:22:10,960
will

00:22:06,640 --> 00:22:14,799
perform all tasks required for

00:22:10,960 --> 00:22:18,480
visualization and then it will forward

00:22:14,799 --> 00:22:21,600
the smc to the secure monitor

00:22:18,480 --> 00:22:27,840
which will in turn dispatch it to the

00:22:21,600 --> 00:22:27,840
secure os

00:22:33,360 --> 00:22:37,760
when it comes to the extension vm we

00:22:35,440 --> 00:22:38,880
implement this case as a unicraft based

00:22:37,760 --> 00:22:41,280
unikernel

00:22:38,880 --> 00:22:43,679
which results into a nearly bare metal

00:22:41,280 --> 00:22:46,559
image which is exactly what we need for

00:22:43,679 --> 00:22:48,720
this type of application the image

00:22:46,559 --> 00:22:52,400
consists just

00:22:48,720 --> 00:22:53,440
of a few libraries so going from bottom

00:22:52,400 --> 00:22:55,200
to top

00:22:53,440 --> 00:22:56,799
we have the library that implements the

00:22:55,200 --> 00:23:01,039
architecture part

00:22:56,799 --> 00:23:01,600
in our case arts 64. then we have the

00:23:01,039 --> 00:23:04,000
cocos

00:23:01,600 --> 00:23:06,960
hv platform library that implements the

00:23:04,000 --> 00:23:09,840
core part of our guest

00:23:06,960 --> 00:23:11,520
then we have no leap c which implements

00:23:09,840 --> 00:23:13,520
a subset of the standard library for

00:23:11,520 --> 00:23:15,120
applications that don't require full

00:23:13,520 --> 00:23:18,400
implementation

00:23:15,120 --> 00:23:20,400
and the composite sweep the cockpit

00:23:18,400 --> 00:23:22,159
hypervisor extension library

00:23:20,400 --> 00:23:24,159
that implements a communication protocol

00:23:22,159 --> 00:23:26,559
with hypervisor core

00:23:24,159 --> 00:23:28,240
on the top we have the optimidator

00:23:26,559 --> 00:23:31,440
application that implements

00:23:28,240 --> 00:23:34,320
the main logic one last thing i would

00:23:31,440 --> 00:23:36,880
like to point out here is scheduling so

00:23:34,320 --> 00:23:37,760
as there may be several guests running

00:23:36,880 --> 00:23:39,760
on the system

00:23:37,760 --> 00:23:41,440
whether these are regular guests or

00:23:39,760 --> 00:23:43,600
hypervisor extensions

00:23:41,440 --> 00:23:46,000
we'd like to ensure that our extension

00:23:43,600 --> 00:23:47,200
vm consumes as little scheduling time as

00:23:46,000 --> 00:23:50,159
possible

00:23:47,200 --> 00:23:52,240
and we achieve that by adding the

00:23:50,159 --> 00:23:52,960
extension vm to the hypervisor scheduler

00:23:52,240 --> 00:23:56,320
when there is

00:23:52,960 --> 00:23:59,120
a synchronous exception to process and

00:23:56,320 --> 00:24:01,120
removing it by from the hypervisors

00:23:59,120 --> 00:24:02,720
scheduler as soon as handling is

00:24:01,120 --> 00:24:06,159
complete

00:24:02,720 --> 00:24:10,080
now remember when we introduced

00:24:06,159 --> 00:24:13,440
the synchronous exception forwarding

00:24:10,080 --> 00:24:15,919
that when a guest causes an exception

00:24:13,440 --> 00:24:16,799
execution is stopped for that guest

00:24:15,919 --> 00:24:20,799
until the

00:24:16,799 --> 00:24:20,799
exception is handled

00:24:22,400 --> 00:24:28,960
these two combined means that

00:24:25,679 --> 00:24:31,120
the extensions vm effectively steals the

00:24:28,960 --> 00:24:32,080
scheduler slot of the vm that cause the

00:24:31,120 --> 00:24:34,240
exception

00:24:32,080 --> 00:24:35,279
for the time it requires to handle the

00:24:34,240 --> 00:24:38,320
exception

00:24:35,279 --> 00:24:41,040
and return it back to

00:24:38,320 --> 00:24:42,960
its execution it returns it back to

00:24:41,040 --> 00:24:47,679
[Music]

00:24:42,960 --> 00:24:49,919
the hypervisor when it's time for

00:24:47,679 --> 00:24:52,240
the execution of the aborting guest to

00:24:49,919 --> 00:24:54,240
be resumed

00:24:52,240 --> 00:24:55,760
this allows us to maintain high

00:24:54,240 --> 00:24:58,840
performance as

00:24:55,760 --> 00:25:01,840
we keep the number of scheduled guests

00:24:58,840 --> 00:25:01,840
constant

00:25:03,200 --> 00:25:08,320
um coming to conclusions we saw how

00:25:06,000 --> 00:25:10,640
component aggregation

00:25:08,320 --> 00:25:12,440
imposes security risks and we

00:25:10,640 --> 00:25:15,520
highlighted the requirement for

00:25:12,440 --> 00:25:18,000
compartmentalization and isolation and

00:25:15,520 --> 00:25:21,039
we saw that unikernels are a suitable

00:25:18,000 --> 00:25:23,840
platform for that purpose

00:25:21,039 --> 00:25:25,919
we introduced unicroft and we saw how it

00:25:23,840 --> 00:25:26,480
can help us produce small specialized

00:25:25,919 --> 00:25:28,320
guests

00:25:26,480 --> 00:25:29,760
of high performance and low resource

00:25:28,320 --> 00:25:32,320
usage

00:25:29,760 --> 00:25:34,720
and we had a closer look on how the

00:25:32,320 --> 00:25:37,520
cocos hypervisor achieves isolation

00:25:34,720 --> 00:25:39,290
with the hypervisor extensions and

00:25:37,520 --> 00:25:41,039
synchronous exception forwarding

00:25:39,290 --> 00:25:43,200
[Music]

00:25:41,039 --> 00:25:44,960
looking ahead there is an obvious

00:25:43,200 --> 00:25:45,600
question on whether it is possible to

00:25:44,960 --> 00:25:49,200
isolate

00:25:45,600 --> 00:25:50,559
every single service or component and

00:25:49,200 --> 00:25:54,000
the truth is that

00:25:50,559 --> 00:25:55,919
there are several challenges ahead

00:25:54,000 --> 00:25:58,799
for instance there are cases of very

00:25:55,919 --> 00:26:01,039
complex device drivers

00:25:58,799 --> 00:26:02,320
that also depend on equally complex

00:26:01,039 --> 00:26:04,480
subsystems

00:26:02,320 --> 00:26:06,000
that would require a lot of work to port

00:26:04,480 --> 00:26:09,279
to a unique kernel

00:26:06,000 --> 00:26:12,400
and clearly in these cases it's probably

00:26:09,279 --> 00:26:14,080
a better idea to stick to linux when it

00:26:12,400 --> 00:26:17,600
comes to scalability

00:26:14,080 --> 00:26:20,720
what we have learned from micro kernels

00:26:17,600 --> 00:26:22,640
that feature a similar architecture is

00:26:20,720 --> 00:26:26,080
that scaling up

00:26:22,640 --> 00:26:28,480
involves its own challenges as well

00:26:26,080 --> 00:26:29,840
and based on the above it should all

00:26:28,480 --> 00:26:32,960
come down to achieving

00:26:29,840 --> 00:26:35,760
the right balance so this is it

00:26:32,960 --> 00:26:36,159
thank you for attending this talk and i

00:26:35,760 --> 00:26:39,840
hope

00:26:36,159 --> 00:26:39,840
you found it interesting

00:27:00,320 --> 00:27:02,400

YouTube URL: https://www.youtube.com/watch?v=F-dIN9gtncU


