Title: Adding AArch64 Support in the OpenJ9 Java Virtual Machine - Kazuhiro Konno, IBM Japan
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Adding AArch64 Support in the OpenJ9 Java Virtual Machine - Kazuhiro Konno, IBM Japan
Captions: 
	00:00:03,360 --> 00:00:08,000
hello everyone

00:00:04,319 --> 00:00:10,960
uh it is a great pleasure for me to

00:00:08,000 --> 00:00:12,480
have an opportunity to talk in uh open

00:00:10,960 --> 00:00:16,480
source summit japan today

00:00:12,480 --> 00:00:19,439
uh i am kondo kazuhiro from miami japan

00:00:16,480 --> 00:00:21,279
and i talk about my work in an open

00:00:19,439 --> 00:00:24,400
source java virtual machine

00:00:21,279 --> 00:00:28,000
open j9 adding support for

00:00:24,400 --> 00:00:31,119
new processor architecture to it

00:00:28,000 --> 00:00:33,840
i'm speaking live and i speak in english

00:00:31,119 --> 00:00:33,840
in this session

00:00:36,399 --> 00:00:39,680
i have to show

00:00:39,760 --> 00:00:46,480
this page and the next page

00:00:43,440 --> 00:00:49,039
by the rule of my company and

00:00:46,480 --> 00:00:58,559
disclaimers and

00:00:49,039 --> 00:01:02,800
notices for the trademarks

00:00:58,559 --> 00:01:07,040
okay let me start with

00:01:02,800 --> 00:01:09,520
who i am i am a software engineer

00:01:07,040 --> 00:01:12,159
at the software development organization

00:01:09,520 --> 00:01:16,400
in ibm japan

00:01:12,159 --> 00:01:20,000
i joined the company in 1995

00:01:16,400 --> 00:01:23,439
and i have been working on boarding

00:01:20,000 --> 00:01:29,200
and delivering ibm java

00:01:23,439 --> 00:01:29,200
to embedded systems for nearly 20 years

00:01:30,079 --> 00:01:36,640
my target devices include

00:01:33,520 --> 00:01:41,360
printers vending machines and

00:01:36,640 --> 00:01:44,799
car navigation systems for example

00:01:41,360 --> 00:01:48,000
a certain percentage of you

00:01:44,799 --> 00:01:51,520
may have consumer devices

00:01:48,000 --> 00:01:54,799
at your home with ibm java

00:01:51,520 --> 00:01:57,920
internally or had

00:01:54,799 --> 00:02:00,960
such devices in the past without

00:01:57,920 --> 00:02:03,840
knowing that although

00:02:00,960 --> 00:02:04,799
i cannot mention the name of the

00:02:03,840 --> 00:02:08,080
products

00:02:04,799 --> 00:02:11,280
i have worked on

00:02:08,080 --> 00:02:12,400
became a committer of two open source

00:02:11,280 --> 00:02:17,120
projects

00:02:12,400 --> 00:02:20,800
eclipse open j9 and eclipse omr

00:02:17,120 --> 00:02:23,440
year ago i will talk about

00:02:20,800 --> 00:02:26,400
the open source projects in the

00:02:23,440 --> 00:02:26,400
following pages

00:02:30,560 --> 00:02:34,160
today's agenda looks like this i am

00:02:32,959 --> 00:02:37,360
going to talk about

00:02:34,160 --> 00:02:41,200
openg9 and my work

00:02:37,360 --> 00:02:44,720
in the openg9 project to add support for

00:02:41,200 --> 00:02:44,720
ax64 linux

00:02:48,480 --> 00:02:57,360
let me start with uh open g9

00:02:52,959 --> 00:03:02,720
eclipse open g9 project was created

00:02:57,360 --> 00:03:06,080
three years ago in 2017

00:03:02,720 --> 00:03:08,159
it is an implementation of java virtual

00:03:06,080 --> 00:03:11,280
machine

00:03:08,159 --> 00:03:15,280
it originates from ibm's

00:03:11,280 --> 00:03:20,080
j9 virtual machine so the name is

00:03:15,280 --> 00:03:23,360
openg9 now after open source

00:03:20,080 --> 00:03:26,799
j9 ibm's own

00:03:23,360 --> 00:03:30,080
java virtual machine implementation

00:03:26,799 --> 00:03:33,599
is a proven and enterprise-grade

00:03:30,080 --> 00:03:37,920
java implementation it has been

00:03:33,599 --> 00:03:40,959
the core of ibm java sdks for

00:03:37,920 --> 00:03:44,400
many years and

00:03:40,959 --> 00:03:48,080
has been available bundled in

00:03:44,400 --> 00:03:51,200
ibm software such as websphere

00:03:48,080 --> 00:03:51,200
application server

00:03:51,280 --> 00:03:59,680
ibm java sdk supports systems with

00:03:56,239 --> 00:04:03,920
power architecture and ibm's

00:03:59,680 --> 00:04:09,760
mainframe system z as well as

00:04:03,920 --> 00:04:09,760
x86 linux windows and mac os

00:04:11,920 --> 00:04:19,359
j9 was open sourced three years ago

00:04:15,920 --> 00:04:22,560
to reach developers outside of

00:04:19,359 --> 00:04:25,919
ibm and

00:04:22,560 --> 00:04:29,520
ibm java sdk now uses

00:04:25,919 --> 00:04:29,520
openg9 as its score

00:04:40,240 --> 00:04:48,320
you can see the advantages of open j9

00:04:44,000 --> 00:04:52,639
over other java vm implementation

00:04:48,320 --> 00:04:56,160
at the open j9 project site

00:04:52,639 --> 00:04:59,759
that includes fast startup

00:04:56,160 --> 00:05:04,400
and smaller footprint and

00:04:59,759 --> 00:05:08,080
openj9 is also a cloud aware

00:05:04,400 --> 00:05:11,840
that means it is optimized for use

00:05:08,080 --> 00:05:11,840
in containers

00:05:12,320 --> 00:05:19,520
opengni has technologies

00:05:15,520 --> 00:05:24,240
called shared classes and aot

00:05:19,520 --> 00:05:30,160
aot is ahead of time compilation

00:05:24,240 --> 00:05:30,160
they contribute to faster startup

00:05:30,800 --> 00:05:35,360
please visit the project website for

00:05:33,759 --> 00:05:39,919
more details

00:05:35,360 --> 00:05:39,919
of the advantages of open j9

00:05:43,919 --> 00:05:49,759
i'd like to talk about the structure of

00:05:46,639 --> 00:05:49,759
openg9 here

00:05:49,840 --> 00:05:56,160
openj9 is an implementation of

00:05:52,880 --> 00:05:56,160
java virtual machine

00:05:56,479 --> 00:06:02,960
you may know that there is

00:05:59,520 --> 00:06:07,120
another java virtual machine that

00:06:02,960 --> 00:06:10,800
originates from sun and oracle

00:06:07,120 --> 00:06:10,800
which is called hotspot

00:06:12,160 --> 00:06:18,840
there is an open source project

00:06:15,199 --> 00:06:22,639
called openjdk

00:06:18,840 --> 00:06:22,639
and hotspot

00:06:23,360 --> 00:06:27,120
is the virtual machine developed in the

00:06:26,240 --> 00:06:30,080
open jdk

00:06:27,120 --> 00:06:32,800
project you can see it on the right side

00:06:30,080 --> 00:06:32,800
of this page

00:06:32,840 --> 00:06:40,560
and hotspot is not the only component

00:06:37,039 --> 00:06:44,560
in open jdk project and

00:06:40,560 --> 00:06:48,000
you can see the open jdk class library

00:06:44,560 --> 00:06:51,759
in the box above uh ibm

00:06:48,000 --> 00:06:54,800
has been collaborating with oracle

00:06:51,759 --> 00:06:57,840
in the open jdk project for

00:06:54,800 --> 00:07:01,199
the class library uh since

00:06:57,840 --> 00:07:04,720
uh 2000 2010

00:07:01,199 --> 00:07:08,400
and ibm has used the

00:07:04,720 --> 00:07:11,199
open jdk class library in ibm java

00:07:08,400 --> 00:07:11,199
sdks

00:07:11,759 --> 00:07:18,160
our java runtime combines

00:07:15,039 --> 00:07:21,520
the open jdk class library and the

00:07:18,160 --> 00:07:25,039
opengl virtual machine

00:07:21,520 --> 00:07:29,120
replacing the hotspot virtual machine in

00:07:25,039 --> 00:07:32,639
open jdk you can see it

00:07:29,120 --> 00:07:32,639
in the left side of the page

00:07:33,120 --> 00:07:41,360
the eclipse open j9

00:07:37,840 --> 00:07:44,960
java virtual machine at the bottom and

00:07:41,360 --> 00:07:48,720
on top on top of it is

00:07:44,960 --> 00:07:52,240
open jdk class library and there is

00:07:48,720 --> 00:07:57,039
adapter code that bridges between

00:07:52,240 --> 00:07:57,039
open j9 vm and class library

00:07:57,680 --> 00:08:07,120
this structure is basically the same

00:08:01,599 --> 00:08:13,840
as it used to be with ibm java sdk

00:08:07,120 --> 00:08:13,840
before open sourced

00:08:16,400 --> 00:08:20,800
going on to the next page

00:08:21,520 --> 00:08:28,400
i like to talk about open j9 and omr

00:08:29,599 --> 00:08:35,919
when j9 virtual machine was

00:08:32,880 --> 00:08:39,360
open sourced it was

00:08:35,919 --> 00:08:43,200
divided into two projects

00:08:39,360 --> 00:08:46,240
one is eclipse open g9 and the other is

00:08:43,200 --> 00:08:46,240
eclipse omr

00:08:46,480 --> 00:08:54,160
eclipse omr is a project

00:08:50,160 --> 00:08:58,240
that implements language independent

00:08:54,160 --> 00:09:02,959
uh runtime com technologies

00:08:58,240 --> 00:09:06,880
that includes garbage collection and

00:09:02,959 --> 00:09:11,440
compiler and polling layers

00:09:06,880 --> 00:09:15,360
uh the components in omr

00:09:11,440 --> 00:09:19,839
can be used to build other languages

00:09:15,360 --> 00:09:19,839
such as python and ruby

00:09:20,720 --> 00:09:27,760
there are uh implementations

00:09:24,080 --> 00:09:30,320
of such languages based on

00:09:27,760 --> 00:09:30,320
omr

00:09:31,040 --> 00:09:38,640
please don't ask me what omr

00:09:34,800 --> 00:09:42,800
stands for it used to be

00:09:38,640 --> 00:09:47,680
an acronym of something but uh

00:09:42,800 --> 00:09:47,680
it is now omar is omr

00:09:49,440 --> 00:09:57,440
eclipse open j9 project builds

00:09:53,279 --> 00:10:01,040
on top of omr uh focusing on the

00:09:57,440 --> 00:10:04,240
java virtual machine implementation

00:10:01,040 --> 00:10:07,920
and the java specific part

00:10:04,240 --> 00:10:11,680
of the components so

00:10:07,920 --> 00:10:14,800
you can see the compiler code

00:10:11,680 --> 00:10:19,360
resize in both projects

00:10:14,800 --> 00:10:20,880
in the omr site and the compiler

00:10:19,360 --> 00:10:24,160
component

00:10:20,880 --> 00:10:27,360
is the infrastructure for

00:10:24,160 --> 00:10:27,360
building compilers

00:10:28,640 --> 00:10:35,760
in the openg9 side

00:10:32,079 --> 00:10:36,640
it implements the java specific part of

00:10:35,760 --> 00:10:46,399
the

00:10:36,640 --> 00:10:51,040
javajit compiler

00:10:46,399 --> 00:10:54,240
now i am moving to the topic of

00:10:51,040 --> 00:10:54,240
ax 64.

00:10:54,320 --> 00:11:02,279
it is sometimes

00:10:57,920 --> 00:11:07,440
called as m64 or

00:11:02,279 --> 00:11:07,440
mv8a but uh

00:11:07,519 --> 00:11:14,720
those words sometimes have slightly

00:11:10,959 --> 00:11:18,600
different meanings but uh

00:11:14,720 --> 00:11:19,990
i mix the use of x64 and

00:11:18,600 --> 00:11:22,079
m64

00:11:19,990 --> 00:11:26,839
[Music]

00:11:22,079 --> 00:11:28,880
in this slice please don't care about

00:11:26,839 --> 00:11:32,640
that uh

00:11:28,880 --> 00:11:35,680
ark 64 is a 64-bit

00:11:32,640 --> 00:11:37,830
architecture from arm and

00:11:35,680 --> 00:11:39,079
it was announced in

00:11:37,830 --> 00:11:43,279
[Music]

00:11:39,079 --> 00:11:47,040
2011 nine years ago

00:11:43,279 --> 00:11:50,079
arm has its uh 32-bit architecture

00:11:47,040 --> 00:11:53,120
and that was widely used

00:11:50,079 --> 00:11:56,320
in embedded devices but

00:11:53,120 --> 00:11:59,600
when they introduced 64-bit

00:11:56,320 --> 00:12:03,200
architecture they defined

00:11:59,600 --> 00:12:07,360
a new instruction instruction set

00:12:03,200 --> 00:12:07,360
and register set

00:12:08,240 --> 00:12:14,959
what is important here is that

00:12:11,920 --> 00:12:19,279
it is not a simple extension

00:12:14,959 --> 00:12:24,000
from the previous 32-bit architecture

00:12:19,279 --> 00:12:28,320
and there is no upper compatibility

00:12:24,000 --> 00:12:28,320
between the instruction sets

00:12:29,120 --> 00:12:36,399
you can execute 32-bit

00:12:32,560 --> 00:12:41,120
instructions when you are running in

00:12:36,399 --> 00:12:45,920
64-bit mode of x86 or

00:12:41,120 --> 00:12:50,800
power architecture but that is not

00:12:45,920 --> 00:12:50,800
that that does not apply to r

00:12:51,440 --> 00:12:58,320
and nowadays

00:12:55,200 --> 00:13:01,519
most smartphones and

00:12:58,320 --> 00:13:06,560
both iphone and android

00:13:01,519 --> 00:13:11,120
run on 64-bit arm processors

00:13:06,560 --> 00:13:16,079
uh japanese supercomputer fujaku

00:13:11,120 --> 00:13:21,440
uses cpu cores of ax64 architecture

00:13:16,079 --> 00:13:24,959
with vector extension you may know

00:13:21,440 --> 00:13:29,600
fugaku was number one in the recent top

00:13:24,959 --> 00:13:29,600
500 list of supercomputers

00:13:30,399 --> 00:13:35,600
and you may also know that apple started

00:13:34,480 --> 00:13:39,600
to switch

00:13:35,600 --> 00:13:43,519
the processor in the macintosh

00:13:39,600 --> 00:13:49,839
from intel processors to its own

00:13:43,519 --> 00:13:49,839
64-bit arm processor last month

00:13:57,360 --> 00:14:03,920
as i mentioned in this talk earlier

00:14:00,800 --> 00:14:07,279
i belong to a team in ibm japan

00:14:03,920 --> 00:14:10,320
that delivers embedded java solutions

00:14:07,279 --> 00:14:10,320
to our customers

00:14:10,720 --> 00:14:17,440
it was clear that many of our customers

00:14:13,920 --> 00:14:23,279
were going to switch from 32-bit

00:14:17,440 --> 00:14:23,279
arm to 64-bit arm in the near future

00:14:23,440 --> 00:14:30,800
that is the reason why our team

00:14:27,279 --> 00:14:33,839
decided to add 64-bit arm

00:14:30,800 --> 00:14:38,040
to the list of supported architectures

00:14:33,839 --> 00:14:41,040
of open j9 in early

00:14:38,040 --> 00:14:41,040
00:14:41,120 --> 00:14:45,839
and the target os is linux

00:14:47,279 --> 00:14:54,079
in supporting the new processor

00:14:50,320 --> 00:14:58,959
in open j9 the

00:14:54,079 --> 00:15:02,320
jit compiler is the key component

00:14:58,959 --> 00:15:05,440
most of the other components

00:15:02,320 --> 00:15:08,800
in open g9 are written in tnc

00:15:05,440 --> 00:15:11,839
plus plus and you can just

00:15:08,800 --> 00:15:14,320
run compilers for the target systems to

00:15:11,839 --> 00:15:19,199
build those components

00:15:14,320 --> 00:15:22,160
but the jit compiler is a compiler

00:15:19,199 --> 00:15:22,720
it needs to generate instructions for

00:15:22,160 --> 00:15:25,839
the

00:15:22,720 --> 00:15:29,600
target processor

00:15:25,839 --> 00:15:30,480
i will explain what the jit compiler

00:15:29,600 --> 00:15:32,800
does

00:15:30,480 --> 00:15:32,800
later

00:15:34,399 --> 00:15:42,000
and by the way uh

00:15:38,160 --> 00:15:45,680
most of the developers of j9 and

00:15:42,000 --> 00:15:49,519
open g9 in ibm are

00:15:45,680 --> 00:15:54,560
located in countries like

00:15:49,519 --> 00:15:58,000
canada and united kingdom and india

00:15:54,560 --> 00:16:00,959
but uh i had uh

00:15:58,000 --> 00:16:02,320
worked with those developers around the

00:16:00,959 --> 00:16:06,639
world

00:16:02,320 --> 00:16:09,759
in 2015

00:16:06,639 --> 00:16:13,040
and that was before gna was

00:16:09,759 --> 00:16:13,040
open sourced uh

00:16:14,959 --> 00:16:23,680
i joined the development of

00:16:18,639 --> 00:16:27,279
ibm java sdk for 32-bit on

00:16:23,680 --> 00:16:30,560
at that time and

00:16:27,279 --> 00:16:34,160
i learned the structure of the

00:16:30,560 --> 00:16:37,680
jit compiler and how to debug

00:16:34,160 --> 00:16:40,800
the git compiler at that time

00:16:37,680 --> 00:16:45,120
and that experiences uh

00:16:40,800 --> 00:16:51,839
made it possible for me uh to work in

00:16:45,120 --> 00:16:51,839
this project for ax64

00:16:58,560 --> 00:17:02,490
okay

00:16:59,390 --> 00:17:02,490
[Music]

00:17:03,040 --> 00:17:12,319
i am the main developer for ax64 support

00:17:08,000 --> 00:17:12,319
but uh i was not the only one

00:17:12,400 --> 00:17:16,880
there are two others from ibm

00:17:17,520 --> 00:17:24,079
and also there were nearly

00:17:20,959 --> 00:17:28,480
10 students from a canadian

00:17:24,079 --> 00:17:31,679
university who are interested in

00:17:28,480 --> 00:17:35,360
compiler technology

00:17:31,679 --> 00:17:38,720
the students were working with an

00:17:35,360 --> 00:17:41,919
ibm laboratory in canada

00:17:38,720 --> 00:17:45,039
through the program and called

00:17:41,919 --> 00:17:48,480
ibm cass centers for

00:17:45,039 --> 00:17:52,320
advanced studies that is a

00:17:48,480 --> 00:17:55,200
collaboration program of ibm and

00:17:52,320 --> 00:17:55,200
universities

00:17:56,400 --> 00:18:05,919
we used slag and github

00:18:01,280 --> 00:18:15,840
and we also had

00:18:05,919 --> 00:18:15,840
weekly calls to exchange our status

00:18:17,039 --> 00:18:19,440
okay

00:18:20,559 --> 00:18:32,880
development timeline looks like this

00:18:28,480 --> 00:18:32,880
i started the development of

00:18:33,039 --> 00:18:41,039
by writing code for the compiler in

00:18:36,480 --> 00:18:44,960
the omr project in may

00:18:41,039 --> 00:18:48,160
2018 it took me

00:18:44,960 --> 00:18:52,799
more than half a year to implement

00:18:48,160 --> 00:18:52,799
functions in the omr site

00:18:52,880 --> 00:18:59,440
that includes the time for learning

00:18:56,080 --> 00:19:03,200
the ax64 instruction set and

00:18:59,440 --> 00:19:07,280
and digit compiler structure

00:19:03,200 --> 00:19:11,440
uh i used uh single board devices like

00:19:07,280 --> 00:19:14,960
raspberry pi's and jetson nanos

00:19:11,440 --> 00:19:14,960
the development platform

00:19:16,240 --> 00:19:19,600
then i built and enabled the java

00:19:18,799 --> 00:19:23,840
bytecode

00:19:19,600 --> 00:19:29,360
interpreter in the omr plot and no

00:19:23,840 --> 00:19:33,360
open g9 project in early 2019

00:19:29,360 --> 00:19:36,880
last year by doing this

00:19:33,360 --> 00:19:40,559
we were able to run java programs

00:19:36,880 --> 00:19:44,320
on ax64 laners without the

00:19:40,559 --> 00:19:44,320
jit compiler at this point

00:19:46,160 --> 00:19:49,679
the jit compiler development continued

00:19:48,960 --> 00:19:52,799
in the

00:19:49,679 --> 00:19:56,720
open j9 site from

00:19:52,799 --> 00:20:00,559
february last last year

00:19:56,720 --> 00:20:01,679
that implements the java specific part

00:20:00,559 --> 00:20:06,080
of the

00:20:01,679 --> 00:20:10,480
jit compiler that that

00:20:06,080 --> 00:20:13,520
that includes writing runtime routines

00:20:10,480 --> 00:20:20,559
of the compiler and that took

00:20:13,520 --> 00:20:23,840
very long

00:20:20,559 --> 00:20:27,440
okay it was somewhere last year

00:20:23,840 --> 00:20:31,280
when uh when the jit compiler

00:20:27,440 --> 00:20:34,559
first generated instructions

00:20:31,280 --> 00:20:37,600
for very simple java methods

00:20:34,559 --> 00:20:41,520
uh just like

00:20:37,600 --> 00:20:44,880
uh retaining returning a value

00:20:41,520 --> 00:20:48,320
passed as an argument

00:20:44,880 --> 00:20:50,799
shown in the slide

00:20:48,320 --> 00:20:52,080
another ibm developer joined in

00:20:50,799 --> 00:20:55,520
september

00:20:52,080 --> 00:20:59,679
to accelerate the development and then

00:20:55,520 --> 00:21:02,480
we were able to run many java programs

00:20:59,679 --> 00:21:04,960
with the jit compiler enabled by

00:21:02,480 --> 00:21:08,240
november

00:21:04,960 --> 00:21:12,000
then we added support for

00:21:08,240 --> 00:21:15,360
ahead of time compilation and enabled

00:21:12,000 --> 00:21:17,679
testing the nightly bills at the open

00:21:15,360 --> 00:21:20,880
source project

00:21:17,679 --> 00:21:24,000
we spent a couple of months

00:21:20,880 --> 00:21:27,280
in dividing before

00:21:24,000 --> 00:21:30,400
we finally released the

00:21:27,280 --> 00:21:34,320
first release in nepal

00:21:30,400 --> 00:21:38,400
this year that was

00:21:34,320 --> 00:21:41,679
jdk 11 only at that time but uh

00:21:38,400 --> 00:21:45,840
we added jdk 8 and

00:21:41,679 --> 00:21:45,840
15 in october

00:21:53,120 --> 00:21:59,600
now i would like to talk a little more

00:21:56,159 --> 00:22:02,480
detail on what i did

00:21:59,600 --> 00:22:03,760
starting with the work for building the

00:22:02,480 --> 00:22:06,799
java bytes called

00:22:03,760 --> 00:22:10,320
interpreter it

00:22:06,799 --> 00:22:13,840
is written in c and c plus plus

00:22:10,320 --> 00:22:17,600
and it is highly portable

00:22:13,840 --> 00:22:20,159
uh except that there are some files

00:22:17,600 --> 00:22:24,880
written in assembly code

00:22:20,159 --> 00:22:28,720
i had to add those files for ax64

00:22:24,880 --> 00:22:32,240
as you can see in the file names uh

00:22:28,720 --> 00:22:32,240
on the right of this page

00:22:32,320 --> 00:22:40,559
those assembly files uh written in

00:22:36,080 --> 00:22:43,240
m4 macros you also need to add

00:22:40,559 --> 00:22:45,120
configuration files and make files for

00:22:43,240 --> 00:22:49,760
ax64

00:22:45,120 --> 00:22:52,799
and add if depth lines for ax64

00:22:49,760 --> 00:22:56,080
in many places

00:22:52,799 --> 00:23:00,640
i needed to learn how the

00:22:56,080 --> 00:23:03,760
whole java runtime was built it is very

00:23:00,640 --> 00:23:09,840
big system and

00:23:03,760 --> 00:23:09,840
takes very long time to build uh

00:23:10,480 --> 00:23:18,240
it took me three weeks in total

00:23:15,200 --> 00:23:22,400
for adding those files

00:23:18,240 --> 00:23:26,320
and for debugging the interpreter

00:23:22,400 --> 00:23:26,320
before it started to work

00:23:27,039 --> 00:23:34,720
and it was the interpreter

00:23:30,480 --> 00:23:38,000
without the jit compiler so

00:23:34,720 --> 00:23:39,520
it is very slow but you can run java

00:23:38,000 --> 00:23:50,799
programs

00:23:39,520 --> 00:23:53,440
in an ax64 environment

00:23:50,799 --> 00:23:54,559
i'd like to talk about the jit compiler

00:23:53,440 --> 00:23:57,679
next

00:23:54,559 --> 00:24:00,720
uh as

00:23:57,679 --> 00:24:04,080
you may know uh jit

00:24:00,720 --> 00:24:08,240
is short for just in time

00:24:04,080 --> 00:24:11,440
and jit compilers are popular these days

00:24:08,240 --> 00:24:14,799
and they're used not only with

00:24:11,440 --> 00:24:18,480
java but uh in other environments like

00:24:14,799 --> 00:24:22,320
javascript and dot net and many other

00:24:18,480 --> 00:24:24,559
languages in java

00:24:22,320 --> 00:24:26,880
the jig compiler translates java byte

00:24:24,559 --> 00:24:30,880
code into native instructions

00:24:26,880 --> 00:24:31,440
at runtime look at the simple example on

00:24:30,880 --> 00:24:35,760
the

00:24:31,440 --> 00:24:40,000
right side translating four byte codes

00:24:35,760 --> 00:24:40,000
into three native instructions

00:24:40,320 --> 00:24:47,039
uh in open j9 uh the

00:24:43,760 --> 00:24:49,919
digit compiler is also used for ahead of

00:24:47,039 --> 00:24:49,919
time compilation

00:24:50,159 --> 00:24:54,400
alt stores the compiled codes in

00:24:52,799 --> 00:24:58,159
openglide's

00:24:54,400 --> 00:25:02,559
shared class cache so that the

00:24:58,159 --> 00:25:02,559
compiled code is reused

00:25:02,799 --> 00:25:06,880
the jit compiler in open j9 is written

00:25:06,240 --> 00:25:15,840
in

00:25:06,880 --> 00:25:15,840
cn c plus plus an assembly code

00:25:17,520 --> 00:25:20,799
now look at the structure of the source

00:25:20,159 --> 00:25:23,840
tree

00:25:20,799 --> 00:25:27,039
in this page this page

00:25:23,840 --> 00:25:31,600
focuses on the structure of the

00:25:27,039 --> 00:25:31,600
compiler directory in non-mr

00:25:32,159 --> 00:25:38,799
uh this is uh open

00:25:35,600 --> 00:25:42,480
uh omr project but uh

00:25:38,799 --> 00:25:45,760
openj9 project also has a

00:25:42,480 --> 00:25:49,120
similar structure in its

00:25:45,760 --> 00:25:49,120
compiler directory

00:25:50,880 --> 00:25:59,440
on the left side

00:25:56,400 --> 00:26:03,679
there are uh platform dependent uh

00:25:59,440 --> 00:26:07,440
uh platform independent uh directories

00:26:03,679 --> 00:26:11,279
uh that controls

00:26:07,440 --> 00:26:15,919
the compiler and that

00:26:11,279 --> 00:26:15,919
performs uh optimizing the code

00:26:16,240 --> 00:26:24,159
and the boxes on the right side

00:26:19,760 --> 00:26:28,320
uh shows the platform dependent

00:26:24,159 --> 00:26:31,440
directories open j9 and

00:26:28,320 --> 00:26:35,039
omr used to support

00:26:31,440 --> 00:26:38,559
p that is power collector

00:26:35,039 --> 00:26:41,840
and x for intel

00:26:38,559 --> 00:26:46,240
x86 and z

00:26:41,840 --> 00:26:49,520
and that is ibm's mainframe

00:26:46,240 --> 00:26:53,279
and there's a

00:26:49,520 --> 00:26:57,279
box for a 32-bit arm but

00:26:53,279 --> 00:27:00,559
the code for 32-bit arm

00:26:57,279 --> 00:27:03,200
is not maintained maintained

00:27:00,559 --> 00:27:03,200
actively

00:27:04,799 --> 00:27:12,400
in supporting the ark64

00:27:07,919 --> 00:27:12,400
we added a new directory here

00:27:12,880 --> 00:27:15,520
on the right

00:27:17,919 --> 00:27:25,039
and we wrote the code

00:27:21,200 --> 00:27:25,039
in it from scratch

00:27:26,159 --> 00:27:32,480
as i mentioned earlier

00:27:29,399 --> 00:27:36,640
ex-64 is not

00:27:32,480 --> 00:27:40,399
upper compatible with 32-bit arm

00:27:36,640 --> 00:27:49,840
and you cannot just extend the

00:27:40,399 --> 00:27:49,840
existing 32-bit arm code to support ax64

00:27:57,840 --> 00:28:04,799
and this page shows

00:28:01,679 --> 00:28:08,159
the work items and

00:28:04,799 --> 00:28:11,200
just compiler development

00:28:08,159 --> 00:28:14,840
on the omr side

00:28:11,200 --> 00:28:18,399
contains the capability of general

00:28:14,840 --> 00:28:21,440
generating ax64 instructions and

00:28:18,399 --> 00:28:24,159
register assignment uh it

00:28:21,440 --> 00:28:25,919
also has the implementations of more

00:28:24,159 --> 00:28:29,279
than 300

00:28:25,919 --> 00:28:32,640
evaluators evaluate as

00:28:29,279 --> 00:28:35,679
the functions that convert

00:28:32,640 --> 00:28:40,000
the operations at the

00:28:35,679 --> 00:28:45,840
intermediate language of openg9

00:28:40,000 --> 00:28:49,200
into native instructions uh

00:28:45,840 --> 00:28:54,240
on the topics and the tables of

00:28:49,200 --> 00:28:54,240
ax64 native instructions but uh

00:28:54,640 --> 00:28:58,399
the initial version of the native

00:28:56,880 --> 00:29:03,360
instruction table

00:28:58,399 --> 00:29:08,320
was written by the university students

00:29:03,360 --> 00:29:08,320
i mentioned in a couple of pages back

00:29:09,200 --> 00:29:14,880
the open g9 side

00:29:12,480 --> 00:29:14,880
of the

00:29:16,880 --> 00:29:24,840
jit compiler implement the java specific

00:29:20,640 --> 00:29:29,039
part of the compiler that includes

00:29:24,840 --> 00:29:32,480
evaluators for

00:29:29,039 --> 00:29:35,600
such as allocating new objects

00:29:32,480 --> 00:29:39,279
in java or or

00:29:35,600 --> 00:29:42,880
checking types

00:29:39,279 --> 00:29:46,399
check chest or instance of

00:29:42,880 --> 00:29:46,399
that kind of evaluators

00:29:47,360 --> 00:29:52,399
you also need many runtime

00:29:52,840 --> 00:29:55,840
routines

00:29:56,559 --> 00:30:05,200
and you also need interface

00:30:00,240 --> 00:30:05,200
with interpreter java interpreter

00:30:06,320 --> 00:30:15,120
we looked at the code uh

00:30:11,039 --> 00:30:18,240
in the p and arm directories

00:30:15,120 --> 00:30:18,240
as the reference

00:30:18,720 --> 00:30:28,480
when we implemented code for x64

00:30:24,320 --> 00:30:32,240
uh p and uh power and arm

00:30:28,480 --> 00:30:36,080
risk processors and they are more

00:30:32,240 --> 00:30:41,600
uh similar to ax64

00:30:36,080 --> 00:30:41,600
than the other architectures x86 and z

00:30:42,320 --> 00:30:50,159
uh the size of the code in the

00:30:46,279 --> 00:30:54,320
ax64 directories of

00:30:50,159 --> 00:30:54,320
omr and open j9

00:30:55,279 --> 00:31:02,080
nearly 40 000 lines

00:30:59,039 --> 00:31:06,720
in total after

00:31:02,080 --> 00:31:06,720
two years and a half of work

00:31:12,080 --> 00:31:16,240
going to the next page

00:31:16,720 --> 00:31:24,720
uh this page shows the history

00:31:20,640 --> 00:31:28,320
of my code contribution

00:31:24,720 --> 00:31:28,320
to the two projects

00:31:29,200 --> 00:31:35,679
on the left side is omr i started

00:31:33,360 --> 00:31:37,440
working with the compiler code in the

00:31:35,679 --> 00:31:41,200
omr side in

00:31:37,440 --> 00:31:44,640
may 2018

00:31:41,200 --> 00:31:47,679
and worked hard towards

00:31:44,640 --> 00:31:51,120
the end of the year

00:31:47,679 --> 00:31:56,080
then i switched to the openg9 project

00:31:51,120 --> 00:31:56,080
in early 2019

00:31:57,519 --> 00:32:05,120
i enabled the java interpreter

00:32:00,640 --> 00:32:08,240
for ax64 without the java

00:32:05,120 --> 00:32:11,039
jit compiler first then

00:32:08,240 --> 00:32:13,519
continue to write code for the jit

00:32:11,039 --> 00:32:16,480
compiler

00:32:13,519 --> 00:32:17,200
uh during that time i also worked on the

00:32:16,480 --> 00:32:20,240
omr

00:32:17,200 --> 00:32:24,000
side too because the features

00:32:20,240 --> 00:32:29,679
uh in the open j9 site

00:32:24,000 --> 00:32:33,200
requires some changes in the omr site

00:32:29,679 --> 00:32:36,960
and i was elected

00:32:33,200 --> 00:32:42,240
elected to be a committee of these

00:32:36,960 --> 00:32:46,399
two projects at the end of last year

00:32:42,240 --> 00:32:57,840
and i review and merge plume requests

00:32:46,399 --> 00:33:01,039
in those projects now

00:32:57,840 --> 00:33:03,840
i'd like to talk about challenges

00:33:01,039 --> 00:33:06,159
in the development activities in this

00:33:03,840 --> 00:33:06,159
page

00:33:07,120 --> 00:33:13,519
first communication with other

00:33:10,559 --> 00:33:13,519
contributors

00:33:14,000 --> 00:33:21,200
i work in japan and many work

00:33:18,000 --> 00:33:25,600
many other developers in ibm are

00:33:21,200 --> 00:33:28,880
located in north america and europe

00:33:25,600 --> 00:33:32,399
we had remote meetings weekly

00:33:28,880 --> 00:33:34,960
but uh it is not easy to have

00:33:32,399 --> 00:33:36,240
real-time communication with other

00:33:34,960 --> 00:33:41,039
developers

00:33:36,240 --> 00:33:41,039
because of the time zone difference

00:33:41,600 --> 00:33:50,320
and second it was the

00:33:45,679 --> 00:33:54,640
first news processor architecture

00:33:50,320 --> 00:33:59,039
that was added to gen9 and open g9

00:33:54,640 --> 00:34:02,559
in these more than 15 years

00:33:59,039 --> 00:34:06,320
so people in ibm

00:34:02,559 --> 00:34:09,760
don't remember how to develop

00:34:06,320 --> 00:34:12,480
the jit compiler for new architecture

00:34:09,760 --> 00:34:15,599
from scratch

00:34:12,480 --> 00:34:18,879
the structure of the

00:34:15,599 --> 00:34:21,480
jit and the features of the jit compiler

00:34:18,879 --> 00:34:22,960
is much different from

00:34:21,480 --> 00:34:27,359
[Music]

00:34:22,960 --> 00:34:27,359
those in early 2000s

00:34:27,679 --> 00:34:34,800
some people in the compiler technologies

00:34:31,119 --> 00:34:37,679
have already left the company

00:34:34,800 --> 00:34:37,679
since that time

00:34:37,919 --> 00:34:45,040
and we have design documents

00:34:41,679 --> 00:34:48,639
of the jet compiler in ibm but

00:34:45,040 --> 00:34:51,679
they are too old and

00:34:48,639 --> 00:34:56,480
the code has changed since

00:34:51,679 --> 00:34:56,480
they were implemented so

00:34:56,720 --> 00:35:03,440
i had to read the code

00:35:00,079 --> 00:35:07,599
of other architectures like power and

00:35:03,440 --> 00:35:10,640
32-bit arm for understanding

00:35:07,599 --> 00:35:14,400
uh what this function does and what

00:35:10,640 --> 00:35:18,240
that function does how this function

00:35:14,400 --> 00:35:21,280
that part relates to each other

00:35:18,240 --> 00:35:25,359
so i needed to understand

00:35:21,280 --> 00:35:28,480
uh not only the ark 64

00:35:25,359 --> 00:35:31,839
instructions but the instructions of

00:35:28,480 --> 00:35:31,839
other architectures

00:35:33,040 --> 00:35:37,839
another problem was the computing

00:35:35,920 --> 00:35:42,960
resource

00:35:37,839 --> 00:35:46,240
the number of the ex-64 servers

00:35:42,960 --> 00:35:50,880
available in the projects were

00:35:46,240 --> 00:35:56,079
limited and they are used for

00:35:50,880 --> 00:35:59,839
daily uh ci bills and

00:35:56,079 --> 00:35:59,839
nightly bills for testing

00:36:01,520 --> 00:36:09,680
as i mentioned earlier uh

00:36:05,680 --> 00:36:12,720
i used raspberry raspberry pies and

00:36:09,680 --> 00:36:15,760
other simple board

00:36:12,720 --> 00:36:20,640
computers for my

00:36:15,760 --> 00:36:24,839
development target i had to use them

00:36:20,640 --> 00:36:27,280
because of those limited computing

00:36:24,839 --> 00:36:30,800
resources

00:36:27,280 --> 00:36:36,160
building the open g9 runtime

00:36:30,800 --> 00:36:36,160
on raspberry pi's takes very long

00:36:37,040 --> 00:36:45,760
nearly one hour on raspberry pi 4

00:36:42,160 --> 00:36:48,960
so i usually cross build

00:36:45,760 --> 00:36:55,839
the runtime on x86 laners

00:36:48,960 --> 00:36:55,839
to save time

00:36:58,160 --> 00:37:05,040
okay this page shows the history of the

00:37:02,079 --> 00:37:08,480
performance improvement

00:37:05,040 --> 00:37:13,359
it is relative

00:37:08,480 --> 00:37:18,640
speed up compared to the interpreter

00:37:13,359 --> 00:37:20,560
in early 19 2019

00:37:18,640 --> 00:37:22,880
when the first release was made in

00:37:20,560 --> 00:37:26,240
naples this year

00:37:22,880 --> 00:37:28,720
only the low level optimization was

00:37:26,240 --> 00:37:31,839
enabled in the jit compiler

00:37:28,720 --> 00:37:33,359
because we wanted to focus on the

00:37:31,839 --> 00:37:38,960
stability

00:37:33,359 --> 00:37:41,119
in that release and the performance

00:37:38,960 --> 00:37:42,240
at that time was around five times

00:37:41,119 --> 00:37:45,359
faster than the

00:37:42,240 --> 00:37:49,839
interpreter after that

00:37:45,359 --> 00:37:54,480
in may and june and this year we enabled

00:37:49,839 --> 00:37:57,119
compiler optimization at higher levels

00:37:54,480 --> 00:37:59,599
which includes our technique called

00:37:57,119 --> 00:38:03,119
recompilation

00:37:59,599 --> 00:38:06,880
the july release is faster than the

00:38:03,119 --> 00:38:10,560
interpreter by 16 times

00:38:06,880 --> 00:38:12,960
we are implementing more work items

00:38:10,560 --> 00:38:19,839
in the jit compiler to improve the

00:38:12,960 --> 00:38:19,839
performance now

00:38:22,000 --> 00:38:30,320
the next page shows the comparison of

00:38:26,640 --> 00:38:33,920
memory sizes of openg9 and

00:38:30,320 --> 00:38:38,640
hotspot running open liberty

00:38:33,920 --> 00:38:38,640
uh webs web server uh

00:38:40,000 --> 00:38:47,119
i said uh the smaller footprint

00:38:43,359 --> 00:38:49,920
is one of the advantages of

00:38:47,119 --> 00:38:49,920
open j9

00:38:51,280 --> 00:38:55,359
as i measured the

00:38:55,520 --> 00:39:05,599
memory size that is in vm rss

00:39:00,560 --> 00:39:05,599
resident memory size

00:39:07,599 --> 00:39:15,359
open j9 is 20 21

00:39:11,839 --> 00:39:18,800
smaller compared to the other

00:39:15,359 --> 00:39:18,800
jvm implementation

00:39:27,119 --> 00:39:30,320
okay i'd like to talk about our future

00:39:29,920 --> 00:39:33,599
work

00:39:30,320 --> 00:39:37,599
uh to be uh honest uh the

00:39:33,599 --> 00:39:41,040
ax64 build of open g9

00:39:37,599 --> 00:39:44,800
is not as optimized as

00:39:41,040 --> 00:39:49,359
three other platforms

00:39:44,800 --> 00:39:53,680
p and x and z at this point

00:39:49,359 --> 00:39:59,040
so we have many work items

00:39:53,680 --> 00:39:59,040
to be implemented for better performance

00:39:59,440 --> 00:40:04,400
that includes methods called improvement

00:40:03,040 --> 00:40:07,599
and

00:40:04,400 --> 00:40:12,079
inlining recognized java methods

00:40:07,599 --> 00:40:16,319
such as array copy

00:40:12,079 --> 00:40:20,000
that is one example

00:40:16,319 --> 00:40:23,839
also we need to catch up

00:40:20,000 --> 00:40:26,800
with new features that will be in new

00:40:23,839 --> 00:40:30,720
versions of jdk

00:40:26,800 --> 00:40:36,000
we now support jdk 8 11 and

00:40:30,720 --> 00:40:40,000
15 and 8 and 11

00:40:36,000 --> 00:40:43,760
long term support versions

00:40:40,000 --> 00:40:47,040
jdk 16 and 17 will be coming

00:40:43,760 --> 00:40:50,839
in next year and jdk

00:40:47,040 --> 00:40:52,720
17 will be the next long term support

00:40:50,839 --> 00:40:55,920
version

00:40:52,720 --> 00:41:00,240
and we are also interested in

00:40:55,920 --> 00:41:00,240
supporting apple silicon mac

00:41:04,240 --> 00:41:08,640
we found that supporting uh apple

00:41:07,599 --> 00:41:12,480
silicon max

00:41:08,640 --> 00:41:15,680
is not very easy uh that jit needs to be

00:41:12,480 --> 00:41:19,280
changed because apple introduced

00:41:15,680 --> 00:41:22,480
a new restriction with the

00:41:19,280 --> 00:41:26,400
permissions of allocated memory

00:41:22,480 --> 00:41:26,400
for security reasons

00:41:26,720 --> 00:41:33,040
by the way there are some people

00:41:30,079 --> 00:41:33,520
in the opengl community who are working

00:41:33,040 --> 00:41:36,560
to

00:41:33,520 --> 00:41:39,359
enable the this compiler for

00:41:36,560 --> 00:41:39,359
risk 5.

00:41:39,920 --> 00:41:48,160
the opengl bytecode interpreter

00:41:44,319 --> 00:41:51,839
for risk 5 is already working

00:41:48,160 --> 00:41:55,680
and nightly builds uh available

00:41:51,839 --> 00:41:59,200
and they're working toward enabling

00:41:55,680 --> 00:42:03,359
jit compiler and i am helping them

00:41:59,200 --> 00:42:07,280
to implement the jet the information

00:42:03,359 --> 00:42:10,560
on what we did with ex-64

00:42:07,280 --> 00:42:10,560
in these two years

00:42:11,440 --> 00:42:19,839
so i am closing the

00:42:14,960 --> 00:42:19,839
talk by introducing um

00:42:20,319 --> 00:42:27,680
uh there's a site called

00:42:23,760 --> 00:42:31,760
adopt open jdk if you want to try

00:42:27,680 --> 00:42:34,960
uh open j9 with the application

00:42:31,760 --> 00:42:37,280
you can download the binaries from this

00:42:34,960 --> 00:42:37,280
site

00:42:37,359 --> 00:42:45,200
this site distributes uh both

00:42:40,960 --> 00:42:49,200
hotspot and openg9 so

00:42:45,200 --> 00:42:59,839
make sure you choose open j9

00:42:49,200 --> 00:42:59,839
on the right side right side of the page

00:42:59,920 --> 00:43:07,520
and the openg9 community welcomes

00:43:03,680 --> 00:43:10,640
your participation to the project

00:43:07,520 --> 00:43:13,760
there are github repositories

00:43:10,640 --> 00:43:16,240
for open j9 and omr

00:43:13,760 --> 00:43:18,880
and you can open issues and pull

00:43:16,240 --> 00:43:22,480
requests there

00:43:18,880 --> 00:43:24,640
and if you want to build opengl binaries

00:43:22,480 --> 00:43:28,400
yourself

00:43:24,640 --> 00:43:31,440
go to this document

00:43:28,400 --> 00:43:34,079
shown in this page for build

00:43:31,440 --> 00:43:34,079
instructions

00:43:35,760 --> 00:43:38,000
so

00:43:39,119 --> 00:43:44,400
this is the last page

00:43:42,160 --> 00:43:44,400
uh

00:43:46,319 --> 00:43:52,880
wrapping uh to summarize uh

00:43:49,760 --> 00:43:55,839
open j9 is another implementation of

00:43:52,880 --> 00:43:55,839
java virtual machine

00:43:56,319 --> 00:44:03,680
that was originally in the ibm

00:44:00,000 --> 00:44:08,000
java sdk and

00:44:03,680 --> 00:44:11,119
i and the team added ax64 linux

00:44:08,000 --> 00:44:15,760
to supported platforms of

00:44:11,119 --> 00:44:15,760
openg9 after two years of work

00:44:17,200 --> 00:44:23,920
and the main component that took

00:44:20,839 --> 00:44:28,240
time was the jit compiler

00:44:23,920 --> 00:44:28,240
as i explained in this session

00:44:28,880 --> 00:44:33,599
and again you can download and try

00:44:31,680 --> 00:44:38,960
openg9

00:44:33,599 --> 00:44:38,960
by downloading from adoption jdk

00:44:42,640 --> 00:44:49,920
so that's all from me

00:44:47,040 --> 00:44:51,839
today thank you for visiting this

00:44:49,920 --> 00:44:55,040
session

00:44:51,839 --> 00:44:58,240
so i would like to take

00:44:55,040 --> 00:45:00,720
questions and

00:44:58,240 --> 00:45:00,720
of course

00:45:02,880 --> 00:45:05,200
questions

00:45:16,839 --> 00:45:19,839
foreign

00:47:15,440 --> 00:47:25,839
i see no questions in the chat and join

00:47:19,359 --> 00:47:25,839
a tabs

00:47:28,079 --> 00:47:39,839
then again uh i'd like to thank you

00:47:32,880 --> 00:47:39,839
all who joined this session

00:48:32,839 --> 00:48:35,839
um

00:48:43,599 --> 00:48:46,400
okay uh

00:48:46,880 --> 00:48:52,400
i'm stopping the broadcast now thank you

00:48:49,760 --> 00:48:52,400
for joining

00:48:53,000 --> 00:48:56,000

YouTube URL: https://www.youtube.com/watch?v=TjdxUYafQ1M


