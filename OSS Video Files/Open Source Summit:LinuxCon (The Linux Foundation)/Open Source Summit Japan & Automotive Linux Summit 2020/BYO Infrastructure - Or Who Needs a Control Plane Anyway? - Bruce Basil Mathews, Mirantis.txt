Title: BYO Infrastructure - Or Who Needs a Control Plane Anyway? - Bruce Basil Mathews, Mirantis
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	BYO Infrastructure - Or Who Needs a Control Plane Anyway? - Bruce Basil Mathews, Mirantis
Captions: 
	00:00:07,600 --> 00:00:12,080
hello

00:00:08,320 --> 00:00:13,120
open summit japan welcome to this

00:00:12,080 --> 00:00:15,839
session

00:00:13,120 --> 00:00:18,080
bring your own infrastructure or who

00:00:15,839 --> 00:00:21,920
needs to run a control plane

00:00:18,080 --> 00:00:26,640
anyway i'm bruce basil matthews

00:00:21,920 --> 00:00:30,560
and i am a member of mirantis

00:00:26,640 --> 00:00:34,000
i have been in the industry for about 40

00:00:30,560 --> 00:00:36,880
some odd years and worked at a lot of

00:00:34,000 --> 00:00:39,360
different technology companies including

00:00:36,880 --> 00:00:40,559
sun microsystems and oracle and hewlett

00:00:39,360 --> 00:00:43,440
packard

00:00:40,559 --> 00:00:44,640
and when i started out i was using

00:00:43,440 --> 00:00:48,160
abacus

00:00:44,640 --> 00:00:50,640
and slide rules to do what i do

00:00:48,160 --> 00:00:53,760
and now fortunately it's advanced a

00:00:50,640 --> 00:00:53,760
little bit beyond that

00:00:54,079 --> 00:00:58,399
what are we going to talk about today

00:00:56,840 --> 00:01:00,160
well

00:00:58,399 --> 00:01:03,039
i'd like to sort of start with the

00:01:00,160 --> 00:01:06,159
foundation of where we were

00:01:03,039 --> 00:01:09,119
are and will be and that includes

00:01:06,159 --> 00:01:10,400
starting with where we've been uh and

00:01:09,119 --> 00:01:12,960
then

00:01:10,400 --> 00:01:14,479
going through some of the variations of

00:01:12,960 --> 00:01:17,280
writing applications for

00:01:14,479 --> 00:01:18,479
bare metal versus virtual machines

00:01:17,280 --> 00:01:22,880
versus containers

00:01:18,479 --> 00:01:26,799
in the world and then moving on to

00:01:22,880 --> 00:01:29,920
microservices and serverless computing

00:01:26,799 --> 00:01:33,759
as an option and i'd like to end

00:01:29,920 --> 00:01:36,880
that section with a important

00:01:33,759 --> 00:01:39,200
section on service decomposition because

00:01:36,880 --> 00:01:42,960
i think that as you make a transition

00:01:39,200 --> 00:01:45,119
from bare metal to vms and containers

00:01:42,960 --> 00:01:46,399
this need for decomposition comes into

00:01:45,119 --> 00:01:50,159
play and i want to make sure that

00:01:46,399 --> 00:01:50,159
everybody catches on with that

00:01:50,479 --> 00:01:54,000
then we're actually going to go through

00:01:51,759 --> 00:01:56,479
the physical infrastructure elements of

00:01:54,000 --> 00:01:58,320
bare metal versus virtual machines

00:01:56,479 --> 00:02:00,960
versus containers

00:01:58,320 --> 00:02:03,119
versus a category i call who cares and

00:02:00,960 --> 00:02:06,399
uh who cares is actually

00:02:03,119 --> 00:02:08,319
um sort of an outlandish

00:02:06,399 --> 00:02:09,599
thought on my part as to where we're

00:02:08,319 --> 00:02:12,959
headed

00:02:09,599 --> 00:02:16,480
beyond serverless computing

00:02:12,959 --> 00:02:18,720
i'm going to make a case for each and

00:02:16,480 --> 00:02:20,239
how about using all four of them in any

00:02:18,720 --> 00:02:22,800
different scenario

00:02:20,239 --> 00:02:24,400
and why you might want to do that and

00:02:22,800 --> 00:02:28,400
then bringing in this

00:02:24,400 --> 00:02:31,760
serverless and microservices environment

00:02:28,400 --> 00:02:34,640
that involves uh you know libraries from

00:02:31,760 --> 00:02:35,680
um you know public cloud offerings and

00:02:34,640 --> 00:02:39,360
and maybe even

00:02:35,680 --> 00:02:42,480
our own uh as we move forward

00:02:39,360 --> 00:02:44,959
and then how we'll add more

00:02:42,480 --> 00:02:46,800
uh methodologies down the road to

00:02:44,959 --> 00:02:49,760
accomplish that

00:02:46,800 --> 00:02:50,000
um and then i want to go into a little

00:02:49,760 --> 00:02:52,959
bit

00:02:50,000 --> 00:02:54,160
of the mechanics of this idea of what i

00:02:52,959 --> 00:02:56,400
call who cares

00:02:54,160 --> 00:02:58,159
it's my own flight of fancy but neutral

00:02:56,400 --> 00:03:02,879
networking

00:02:58,159 --> 00:03:02,879
during doing a neural network of

00:03:03,040 --> 00:03:07,760
elements within it uh using trusted

00:03:05,440 --> 00:03:10,159
computing as a foundation

00:03:07,760 --> 00:03:12,720
and standardization which i think will

00:03:10,159 --> 00:03:14,720
be the key to allowing this to get

00:03:12,720 --> 00:03:16,879
from as you see on the right the

00:03:14,720 --> 00:03:18,000
mainframe all the way down to the public

00:03:16,879 --> 00:03:21,360
cloud and

00:03:18,000 --> 00:03:22,400
using application code like ballerina

00:03:21,360 --> 00:03:27,120
versus

00:03:22,400 --> 00:03:30,239
fortran and pascal and things like that

00:03:27,120 --> 00:03:33,200
okay where we were are and will be

00:03:30,239 --> 00:03:35,680
and it's a very long journey uh it's

00:03:33,200 --> 00:03:37,360
gone over those 40 some odd years that i

00:03:35,680 --> 00:03:40,640
talked about earlier

00:03:37,360 --> 00:03:44,400
but we have to take that journey by

00:03:40,640 --> 00:03:44,400
taking the first steps

00:03:44,640 --> 00:03:49,840
so in the world where we have been

00:03:47,680 --> 00:03:51,599
um when you started off with punch cards

00:03:49,840 --> 00:03:53,439
and paper tapes and you're running down

00:03:51,599 --> 00:03:57,040
the hall to make sure you

00:03:53,439 --> 00:04:00,159
uh push them into the the

00:03:57,040 --> 00:04:03,680
machine uh holding

00:04:00,159 --> 00:04:05,840
uh stack uh and and

00:04:03,680 --> 00:04:07,120
don't spill any or don't get them out of

00:04:05,840 --> 00:04:08,720
sequence

00:04:07,120 --> 00:04:10,879
and when you had to wait for the stack

00:04:08,720 --> 00:04:13,840
to process and the

00:04:10,879 --> 00:04:14,560
mini computer then came into play and

00:04:13,840 --> 00:04:17,040
made

00:04:14,560 --> 00:04:18,959
a huge advancement i could run things

00:04:17,040 --> 00:04:20,799
without having to do that

00:04:18,959 --> 00:04:22,720
although i was still in some ways using

00:04:20,799 --> 00:04:26,560
paper tape and

00:04:22,720 --> 00:04:28,720
four millimeter dot tape to do things

00:04:26,560 --> 00:04:30,639
and then when finally we were able to

00:04:28,720 --> 00:04:34,400
set up cron jobs it was

00:04:30,639 --> 00:04:37,120
a lot easier to um not have to wait

00:04:34,400 --> 00:04:39,040
uh it would set it off itself and it

00:04:37,120 --> 00:04:42,720
would do something when it completed

00:04:39,040 --> 00:04:45,040
or and the biggest advantage

00:04:42,720 --> 00:04:45,759
at that point in time of where we had

00:04:45,040 --> 00:04:48,880
been

00:04:45,759 --> 00:04:50,960
was that a debugger would finally stop

00:04:48,880 --> 00:04:53,360
at the line that failed as opposed to

00:04:50,960 --> 00:04:55,360
just telling you that the entire

00:04:53,360 --> 00:04:57,360
code failed and you'd have to figure out

00:04:55,360 --> 00:04:59,759
where it was

00:04:57,360 --> 00:05:03,520
and when none of this mattered anymore

00:04:59,759 --> 00:05:03,520
we thought we had reached nirvana

00:05:05,360 --> 00:05:10,400
when you're writing applications it's a

00:05:08,400 --> 00:05:13,280
little bit different on each one of the

00:05:10,400 --> 00:05:15,120
platforms in this case bare metal

00:05:13,280 --> 00:05:18,639
application programs focused on

00:05:15,120 --> 00:05:21,520
business logic only and you let the

00:05:18,639 --> 00:05:22,800
machine language take care of dealing

00:05:21,520 --> 00:05:25,840
with

00:05:22,800 --> 00:05:29,039
all of the interaction um

00:05:25,840 --> 00:05:31,919
since computing was at a minimum

00:05:29,039 --> 00:05:34,000
the resources were like gold you had to

00:05:31,919 --> 00:05:38,000
make sure that you used

00:05:34,000 --> 00:05:39,840
a small portion as possible of ram

00:05:38,000 --> 00:05:42,400
and things like that the first

00:05:39,840 --> 00:05:43,199
programming that i ever did was targeted

00:05:42,400 --> 00:05:47,520
for eight

00:05:43,199 --> 00:05:51,520
bytes that's one character

00:05:47,520 --> 00:05:53,039
so you can imagine um if special drivers

00:05:51,520 --> 00:05:55,759
for things were involved

00:05:53,039 --> 00:05:57,039
to do the printing or storage or even

00:05:55,759 --> 00:06:00,639
the connectivity

00:05:57,039 --> 00:06:02,720
you had to build those drivers yourself

00:06:00,639 --> 00:06:04,000
and initialize them when you were

00:06:02,720 --> 00:06:05,520
loading the programs

00:06:04,000 --> 00:06:07,039
otherwise they wouldn't be considered

00:06:05,520 --> 00:06:08,800
part of it

00:06:07,039 --> 00:06:11,680
and you had to run your code through

00:06:08,800 --> 00:06:13,759
hundreds and hundreds and hundreds

00:06:11,680 --> 00:06:16,000
of debugging sessions before you ever

00:06:13,759 --> 00:06:17,919
executed in a production run

00:06:16,000 --> 00:06:20,160
because god helped you you didn't want

00:06:17,919 --> 00:06:22,000
to make it fail and have wasted those

00:06:20,160 --> 00:06:24,560
resources

00:06:22,000 --> 00:06:25,039
but if the application did happen to

00:06:24,560 --> 00:06:29,759
fail

00:06:25,039 --> 00:06:29,759
it was always because of the hardware

00:06:30,800 --> 00:06:36,960
moving on to the era of virtual machines

00:06:34,240 --> 00:06:39,039
and computing resources became a lot

00:06:36,960 --> 00:06:42,800
more commonplace

00:06:39,039 --> 00:06:46,319
um in places like vmware

00:06:42,800 --> 00:06:49,120
and openstack they were

00:06:46,319 --> 00:06:50,960
pretty prevalent and able to be created

00:06:49,120 --> 00:06:53,680
quickly

00:06:50,960 --> 00:06:54,960
we didn't we stopped caring about coding

00:06:53,680 --> 00:06:58,080
efficiency and

00:06:54,960 --> 00:07:01,759
size and all of those things although i

00:06:58,080 --> 00:07:04,800
contest that size continues to matter

00:07:01,759 --> 00:07:08,720
software libraries developed in c and

00:07:04,800 --> 00:07:12,080
other languages became commonplace

00:07:08,720 --> 00:07:14,000
and and took the place of actual coded

00:07:12,080 --> 00:07:17,360
sections of

00:07:14,000 --> 00:07:20,240
monolithic programs and the

00:07:17,360 --> 00:07:22,160
debuggers themselves started to hit on

00:07:20,240 --> 00:07:24,400
the line that failed

00:07:22,160 --> 00:07:26,720
and tell you the part of the line that

00:07:24,400 --> 00:07:28,880
needed to change and even make some

00:07:26,720 --> 00:07:30,479
uh recommendations about how to change

00:07:28,880 --> 00:07:33,840
it and

00:07:30,479 --> 00:07:37,199
your code always had to be recompiled

00:07:33,840 --> 00:07:37,199
for the different platforms

00:07:37,360 --> 00:07:41,840
they were all called unix but hpux was

00:07:40,800 --> 00:07:44,319
different then

00:07:41,840 --> 00:07:45,280
sun oz was different than aix was

00:07:44,319 --> 00:07:48,240
different than

00:07:45,280 --> 00:07:49,840
irix etc so you had to have different

00:07:48,240 --> 00:07:53,280
copies that were compiled

00:07:49,840 --> 00:07:53,280
against the different platforms

00:07:53,919 --> 00:07:58,879
all of a sudden recoverability became a

00:07:56,879 --> 00:08:02,000
very important part of things

00:07:58,879 --> 00:08:04,160
because the hardware wasn't as redundant

00:08:02,000 --> 00:08:07,360
and resilient as it could be

00:08:04,160 --> 00:08:09,280
but if the code failed once again

00:08:07,360 --> 00:08:13,840
you could still blame it on the hardware

00:08:09,280 --> 00:08:13,840
which was kind of an important thing

00:08:14,080 --> 00:08:19,520
applications written for containers now

00:08:17,199 --> 00:08:22,800
we're starting to move into a whole

00:08:19,520 --> 00:08:26,000
different type of beast

00:08:22,800 --> 00:08:29,039
and in order for me to give you that

00:08:26,000 --> 00:08:30,800
kind of sensibility for containers i

00:08:29,039 --> 00:08:32,719
have to give you some information about

00:08:30,800 --> 00:08:34,880
microservices and microservices

00:08:32,719 --> 00:08:37,760
architecture

00:08:34,880 --> 00:08:39,680
give you a bit about containers

00:08:37,760 --> 00:08:43,519
themselves and

00:08:39,680 --> 00:08:46,720
what their formats entail and

00:08:43,519 --> 00:08:49,120
how they work and

00:08:46,720 --> 00:08:51,279
some of the major differences between

00:08:49,120 --> 00:08:54,000
containers and virtual machines

00:08:51,279 --> 00:08:56,080
and once again i want to talk about

00:08:54,000 --> 00:08:56,880
service decomposition at the end of that

00:08:56,080 --> 00:09:00,080
because

00:08:56,880 --> 00:09:02,320
um you start there and

00:09:00,080 --> 00:09:05,279
especially if you're going beyond this

00:09:02,320 --> 00:09:07,040
point with me you'd have to

00:09:05,279 --> 00:09:10,200
really pay attention to how you do

00:09:07,040 --> 00:09:13,200
service decomposition

00:09:10,200 --> 00:09:16,080
recoverability once again becomes even

00:09:13,200 --> 00:09:16,880
more my part of the bargain as an

00:09:16,080 --> 00:09:20,160
application

00:09:16,880 --> 00:09:21,360
developer and writer but they have

00:09:20,160 --> 00:09:24,959
self-healing

00:09:21,360 --> 00:09:28,240
shift-left sre

00:09:24,959 --> 00:09:30,959
capabilities and policies that are now

00:09:28,240 --> 00:09:33,360
becoming a necessary part of the coding

00:09:30,959 --> 00:09:35,680
practices

00:09:33,360 --> 00:09:38,320
unfortunately since i have no idea where

00:09:35,680 --> 00:09:41,680
something is now running

00:09:38,320 --> 00:09:44,480
on worker nodes in some kind of cluster

00:09:41,680 --> 00:09:45,040
i can't blame the hardware anymore but

00:09:44,480 --> 00:09:50,399
that's

00:09:45,040 --> 00:09:52,399
okay we'll get through that one

00:09:50,399 --> 00:09:55,600
so let's talk about microservices and

00:09:52,399 --> 00:09:57,920
microservices architectures

00:09:55,600 --> 00:09:58,720
uh microservices uh define an

00:09:57,920 --> 00:10:01,920
architecture

00:09:58,720 --> 00:10:04,560
that that structures

00:10:01,920 --> 00:10:05,200
an application as a loosely coupled

00:10:04,560 --> 00:10:09,440
grouping

00:10:05,200 --> 00:10:12,160
of collaborative services

00:10:09,440 --> 00:10:13,760
the services communicate have

00:10:12,160 --> 00:10:17,200
inter-process protocols

00:10:13,760 --> 00:10:19,680
using things like http or grpc if

00:10:17,200 --> 00:10:23,120
they're

00:10:19,680 --> 00:10:25,360
asynchronous or synchronous and

00:10:23,120 --> 00:10:26,959
other things such as like kafka or amp

00:10:25,360 --> 00:10:31,680
iq

00:10:26,959 --> 00:10:33,760
rapidmq if they're not

00:10:31,680 --> 00:10:35,680
services can be developed and deployed

00:10:33,760 --> 00:10:37,760
all independently of each other so you

00:10:35,680 --> 00:10:40,399
can have different developers

00:10:37,760 --> 00:10:42,160
deploying managing and deploying

00:10:40,399 --> 00:10:44,160
different containers

00:10:42,160 --> 00:10:48,160
providing different services within the

00:10:44,160 --> 00:10:51,200
same application and it still works

00:10:48,160 --> 00:10:54,320
the way that that happens is by

00:10:51,200 --> 00:10:58,320
maintaining a persistent data structure

00:10:54,320 --> 00:11:01,440
that can easily be coupled and decoupled

00:10:58,320 --> 00:11:05,760
from each of the services so uh

00:11:01,440 --> 00:11:10,160
an input data set to a container

00:11:05,760 --> 00:11:14,079
gets massaged and an output data

00:11:10,160 --> 00:11:18,160
container is presented to the next

00:11:14,079 --> 00:11:20,160
container in the flow and

00:11:18,160 --> 00:11:23,120
all of that data consistency that that

00:11:20,160 --> 00:11:25,440
requires is totally up to me as the

00:11:23,120 --> 00:11:25,440
um

00:11:27,680 --> 00:11:33,519
application developer and it uses

00:11:30,800 --> 00:11:35,440
in general an event-driven architecture

00:11:33,519 --> 00:11:38,640
to accomplish that

00:11:35,440 --> 00:11:40,640
um and some of the mechanisms needed to

00:11:38,640 --> 00:11:41,680
ensure data consistency across all

00:11:40,640 --> 00:11:44,959
services

00:11:41,680 --> 00:11:44,959
are left up to me

00:11:46,480 --> 00:11:52,639
so why do people use microservices now

00:11:50,800 --> 00:11:54,560
as a foundation for their architecture

00:11:52,639 --> 00:11:56,399
as well

00:11:54,560 --> 00:11:58,480
because they're relatively small they're

00:11:56,399 --> 00:12:01,279
pretty easy to find out what went wrong

00:11:58,480 --> 00:12:02,160
pretty quickly and you can fix one part

00:12:01,279 --> 00:12:04,480
of it without

00:12:02,160 --> 00:12:05,279
having to mess with all of the other

00:12:04,480 --> 00:12:08,720
parts

00:12:05,279 --> 00:12:12,079
of your microservice services

00:12:08,720 --> 00:12:13,360
that make up an application you can

00:12:12,079 --> 00:12:16,720
deploy

00:12:13,360 --> 00:12:19,920
versions of your containers and

00:12:16,720 --> 00:12:21,240
individually more frequently so you can

00:12:19,920 --> 00:12:26,000
improve things much

00:12:21,240 --> 00:12:28,000
faster um you can localize those changes

00:12:26,000 --> 00:12:31,200
so you can quickly move

00:12:28,000 --> 00:12:34,000
from something that's talking to

00:12:31,200 --> 00:12:36,320
folks in japan from something that's

00:12:34,000 --> 00:12:39,040
talking to people in europe

00:12:36,320 --> 00:12:40,160
um pretty easy to isolate the faults

00:12:39,040 --> 00:12:42,720
because the

00:12:40,160 --> 00:12:43,839
containers themselves are are

00:12:42,720 --> 00:12:47,920
individually

00:12:43,839 --> 00:12:47,920
isolated and

00:12:48,000 --> 00:12:55,279
there's less of a need

00:12:51,360 --> 00:12:55,839
to commit to a particular technology

00:12:55,279 --> 00:12:59,040
stack

00:12:55,839 --> 00:13:00,000
because we are becoming more and more

00:12:59,040 --> 00:13:03,600
abstracted

00:13:00,000 --> 00:13:05,680
and distributed

00:13:03,600 --> 00:13:08,320
across this new microservices

00:13:05,680 --> 00:13:10,480
architecture

00:13:08,320 --> 00:13:12,399
the potential drawbacks of some of those

00:13:10,480 --> 00:13:13,040
things and you'll find these as you

00:13:12,399 --> 00:13:15,600
start

00:13:13,040 --> 00:13:16,399
making the transition is developers have

00:13:15,600 --> 00:13:19,600
to deal with

00:13:16,399 --> 00:13:21,600
some additional complexity especially in

00:13:19,600 --> 00:13:24,160
the deployment phases

00:13:21,600 --> 00:13:25,279
of things because they're distributed

00:13:24,160 --> 00:13:27,839
and

00:13:25,279 --> 00:13:29,440
service discovery becomes an important

00:13:27,839 --> 00:13:31,440
part of what goes on

00:13:29,440 --> 00:13:33,680
under the covers and that typically

00:13:31,440 --> 00:13:36,399
involves being able to catalog

00:13:33,680 --> 00:13:37,440
the new things that are coming in or

00:13:36,399 --> 00:13:40,240
recognize

00:13:37,440 --> 00:13:40,639
things that all of a sudden show up in

00:13:40,240 --> 00:13:43,360
the

00:13:40,639 --> 00:13:44,160
clusters that run the frameworks that

00:13:43,360 --> 00:13:48,240
run your

00:13:44,160 --> 00:13:50,399
microservices this represents a lot more

00:13:48,240 --> 00:13:53,040
security concerns than

00:13:50,399 --> 00:13:54,800
uh it used to so you've got to pay

00:13:53,040 --> 00:13:57,279
attention to that

00:13:54,800 --> 00:13:58,000
and as i mentioned earlier deployment is

00:13:57,279 --> 00:14:01,040
more

00:13:58,000 --> 00:14:04,320
complex than it used to be

00:14:01,040 --> 00:14:07,920
and people tell me that it

00:14:04,320 --> 00:14:10,959
requires more memory uh in consumption

00:14:07,920 --> 00:14:14,320
than its predecessors but i'm not

00:14:10,959 --> 00:14:14,320
convinced of that myself

00:14:14,800 --> 00:14:20,320
this new phase of dealing with

00:14:18,440 --> 00:14:23,600
microservices

00:14:20,320 --> 00:14:26,480
in an event-driven environment

00:14:23,600 --> 00:14:28,000
they've dubbed serverless and that's a

00:14:26,480 --> 00:14:30,240
misnomer of course

00:14:28,000 --> 00:14:31,120
because there's still physical hardware

00:14:30,240 --> 00:14:35,680
and

00:14:31,120 --> 00:14:38,959
uh physical application

00:14:35,680 --> 00:14:41,839
capabilities involved

00:14:38,959 --> 00:14:43,279
but they're only run when they're needed

00:14:41,839 --> 00:14:46,560
by the application

00:14:43,279 --> 00:14:50,480
they don't have to sit there

00:14:46,560 --> 00:14:53,680
burning cycles of computing

00:14:50,480 --> 00:14:54,320
unless they're actually in use and there

00:14:53,680 --> 00:14:58,240
are two

00:14:54,320 --> 00:15:02,399
different types of these

00:14:58,240 --> 00:15:04,959
elements some they call microservices

00:15:02,399 --> 00:15:06,160
and some they call functions and i've

00:15:04,959 --> 00:15:07,920
given a brief definition

00:15:06,160 --> 00:15:10,560
the difference between them the function

00:15:07,920 --> 00:15:13,680
relatively small bit

00:15:10,560 --> 00:15:16,639
and it performs a single act and uh

00:15:13,680 --> 00:15:17,680
typical microservice has a collection of

00:15:16,639 --> 00:15:21,040
those

00:15:17,680 --> 00:15:24,839
functions into a more uh

00:15:21,040 --> 00:15:26,880
complex um service that's going to be

00:15:24,839 --> 00:15:29,199
provided of course

00:15:26,880 --> 00:15:30,880
we always argue about it and developers

00:15:29,199 --> 00:15:32,240
will call things one thing and call

00:15:30,880 --> 00:15:35,600
things another

00:15:32,240 --> 00:15:38,720
um sort of interchangeably even though

00:15:35,600 --> 00:15:38,720
there are differences

00:15:39,680 --> 00:15:43,680
and that blurs those lines but i like to

00:15:41,759 --> 00:15:46,240
keep them separate

00:15:43,680 --> 00:15:48,000
uh if you want to find out more about

00:15:46,240 --> 00:15:51,040
serverless computing and

00:15:48,000 --> 00:15:52,800
and how it works in particular i found

00:15:51,040 --> 00:15:54,959
that this particular article went

00:15:52,800 --> 00:15:56,000
through it very well what is serverless

00:15:54,959 --> 00:15:58,160
and you can

00:15:56,000 --> 00:15:59,440
go there and look to your heart's

00:15:58,160 --> 00:16:01,279
content but

00:15:59,440 --> 00:16:02,880
i'm going to give you kind of a summary

00:16:01,279 --> 00:16:06,320
of what

00:16:02,880 --> 00:16:08,639
is involved in that article

00:16:06,320 --> 00:16:10,639
in an event-driven architecture that is

00:16:08,639 --> 00:16:14,720
specifically designed

00:16:10,639 --> 00:16:18,480
uh as a cloud-native component within

00:16:14,720 --> 00:16:22,240
a kubernetes framework so

00:16:18,480 --> 00:16:22,639
events are going on uh constantly clicks

00:16:22,240 --> 00:16:25,920
of

00:16:22,639 --> 00:16:29,440
of uh mouses and

00:16:25,920 --> 00:16:33,120
um uh entries into forms

00:16:29,440 --> 00:16:34,399
and uh copying and pasting and all of

00:16:33,120 --> 00:16:37,360
those things

00:16:34,399 --> 00:16:38,800
um and there are cues that are made

00:16:37,360 --> 00:16:41,440
available

00:16:38,800 --> 00:16:43,759
for each one of those events to be

00:16:41,440 --> 00:16:46,560
captured

00:16:43,759 --> 00:16:49,120
each one of those events then are

00:16:46,560 --> 00:16:53,440
presented to a mediator

00:16:49,120 --> 00:16:56,560
that's actually taking one at a time

00:16:53,440 --> 00:16:58,000
in the sequence that they came in and

00:16:56,560 --> 00:17:02,000
it's presenting

00:16:58,000 --> 00:17:04,000
the the events individually

00:17:02,000 --> 00:17:06,959
to all of the channels that are

00:17:04,000 --> 00:17:10,160
registered with the mediator

00:17:06,959 --> 00:17:13,039
and it asks the consumer

00:17:10,160 --> 00:17:14,559
of that channel do you are you

00:17:13,039 --> 00:17:18,160
responsible for this

00:17:14,559 --> 00:17:19,199
event are you responsible and generally

00:17:18,160 --> 00:17:22,160
they'll say no

00:17:19,199 --> 00:17:23,600
and one will say yes and when that

00:17:22,160 --> 00:17:26,400
happens

00:17:23,600 --> 00:17:26,880
that event consumer picks up the event

00:17:26,400 --> 00:17:30,640
and

00:17:26,880 --> 00:17:33,919
processes it through its microservice

00:17:30,640 --> 00:17:37,360
that's been created within it

00:17:33,919 --> 00:17:41,120
and if it changes the datagram

00:17:37,360 --> 00:17:43,840
that went into it and came out of it

00:17:41,120 --> 00:17:46,400
it then passes it on as a new event and

00:17:43,840 --> 00:17:48,960
this whole process starts again

00:17:46,400 --> 00:17:49,679
however if it doesn't that's the end of

00:17:48,960 --> 00:17:52,720
the process

00:17:49,679 --> 00:17:55,039
it finishes it and it moves on to the

00:17:52,720 --> 00:17:57,679
the mediator moves on to the next event

00:17:55,039 --> 00:17:57,679
in the queue

00:17:57,760 --> 00:18:02,880
so some of the benefits and drawbacks of

00:18:00,720 --> 00:18:05,360
this kind of approach to

00:18:02,880 --> 00:18:08,720
application development for cloud native

00:18:05,360 --> 00:18:11,360
environments is that it's very resilient

00:18:08,720 --> 00:18:12,000
you can find alternates that you can

00:18:11,360 --> 00:18:15,840
move to

00:18:12,000 --> 00:18:15,840
quickly if one

00:18:16,799 --> 00:18:22,799
parameter isn't met within the

00:18:20,160 --> 00:18:25,120
application service itself

00:18:22,799 --> 00:18:26,320
you can scale the individual parts of it

00:18:25,120 --> 00:18:30,559
in the mediation

00:18:26,320 --> 00:18:34,000
and the consumers in the event

00:18:30,559 --> 00:18:36,559
you know capture instead of

00:18:34,000 --> 00:18:38,559
scaling the whole thing so you save

00:18:36,559 --> 00:18:40,240
resources

00:18:38,559 --> 00:18:42,720
you can update features much more

00:18:40,240 --> 00:18:44,720
rapidly once again that's based on the

00:18:42,720 --> 00:18:46,320
microservices and the containers being

00:18:44,720 --> 00:18:49,520
somewhat isolated

00:18:46,320 --> 00:18:51,520
and it's very flexible for developers to

00:18:49,520 --> 00:18:54,559
add new things and

00:18:51,520 --> 00:18:57,760
use different languages starting from

00:18:54,559 --> 00:18:59,840
the older languages like c and

00:18:57,760 --> 00:19:02,160
and pascal and things like that going

00:18:59,840 --> 00:19:06,160
all the way up to the newer languages

00:19:02,160 --> 00:19:08,960
like golong and ballerina etc

00:19:06,160 --> 00:19:11,840
one of the bad parts of using a

00:19:08,960 --> 00:19:14,480
serverless microservices because

00:19:11,840 --> 00:19:15,840
there are no standards for each one of

00:19:14,480 --> 00:19:18,960
the

00:19:15,840 --> 00:19:21,520
providers each one has developed their

00:19:18,960 --> 00:19:24,000
own set of functions and microservices

00:19:21,520 --> 00:19:24,799
and they're different on each one of the

00:19:24,000 --> 00:19:27,200
public cloud

00:19:24,799 --> 00:19:28,559
platforms for example so if you deal

00:19:27,200 --> 00:19:32,080
with aws

00:19:28,559 --> 00:19:36,840
versus microsoft azure

00:19:32,080 --> 00:19:39,520
versus gce or gke

00:19:36,840 --> 00:19:41,600
you've got to deal with different

00:19:39,520 --> 00:19:43,600
libraries and rewrite your applications

00:19:41,600 --> 00:19:45,280
to accommodate them

00:19:43,600 --> 00:19:47,280
so that can be problematic as

00:19:45,280 --> 00:19:50,840
problematic as it was to

00:19:47,280 --> 00:19:53,840
recompile my code to run on hp ux and

00:19:50,840 --> 00:19:53,840
sonos

00:19:55,120 --> 00:20:01,760
now it's an old school kind

00:19:58,480 --> 00:20:04,640
of philosophy but i think it's still

00:20:01,760 --> 00:20:04,640
very important

00:20:05,280 --> 00:20:14,080
in order to obtain this and to move from

00:20:09,440 --> 00:20:19,440
the mainframe bare metal virtual machine

00:20:14,080 --> 00:20:22,960
uh containerized microservice

00:20:19,440 --> 00:20:25,600
serverless delivery you need to be able

00:20:22,960 --> 00:20:27,760
to decompose your application services

00:20:25,600 --> 00:20:31,600
into these very discreet

00:20:27,760 --> 00:20:34,000
uh parts that can be loosely coupled

00:20:31,600 --> 00:20:36,640
once again as we started with

00:20:34,000 --> 00:20:38,240
um and a lot of people don't have

00:20:36,640 --> 00:20:40,320
experience doing that

00:20:38,240 --> 00:20:42,080
so i'm going to give you my impressions

00:20:40,320 --> 00:20:44,320
of the things that have worked for me

00:20:42,080 --> 00:20:46,960
when i've done it

00:20:44,320 --> 00:20:48,400
you decompose by business capabilities

00:20:46,960 --> 00:20:50,880
for example

00:20:48,400 --> 00:20:53,280
uh you define a corresponding business

00:20:50,880 --> 00:20:54,159
capability as a separate component of

00:20:53,280 --> 00:20:56,720
your

00:20:54,159 --> 00:20:58,720
thing and it ends up being the list of

00:20:56,720 --> 00:21:00,159
microservices that satisfy that

00:20:58,720 --> 00:21:03,120
component

00:21:00,159 --> 00:21:03,600
or you decompose by the domain driven

00:21:03,120 --> 00:21:06,960
stuff

00:21:03,600 --> 00:21:09,919
within your design sub-domain so

00:21:06,960 --> 00:21:11,039
uh application sub-domains within the

00:21:09,919 --> 00:21:13,440
domains

00:21:11,039 --> 00:21:16,960
are contained within the individual

00:21:13,440 --> 00:21:20,240
microservices and containers

00:21:16,960 --> 00:21:22,640
or you can do it more of a

00:21:20,240 --> 00:21:24,880
quick and dirty way by just taking

00:21:22,640 --> 00:21:28,159
advantage of the verbs

00:21:24,880 --> 00:21:31,360
in your applications the the do

00:21:28,159 --> 00:21:32,799
factor and define those services as

00:21:31,360 --> 00:21:36,240
individual

00:21:32,799 --> 00:21:38,000
uh microservices and and

00:21:36,240 --> 00:21:40,159
functions that are responsible for

00:21:38,000 --> 00:21:43,440
fulfilling that specific action

00:21:40,159 --> 00:21:46,400
and that becomes a decomposed

00:21:43,440 --> 00:21:47,280
component or you can take the nouns or

00:21:46,400 --> 00:21:51,120
resources

00:21:47,280 --> 00:21:53,200
like objects and most object oriented

00:21:51,120 --> 00:21:55,520
folks are familiar with that one

00:21:53,200 --> 00:21:57,440
i personally like to use the

00:21:55,520 --> 00:22:01,039
decomposition

00:21:57,440 --> 00:22:04,240
verbs and nouns and resources

00:22:01,039 --> 00:22:06,799
so that i can apply human language

00:22:04,240 --> 00:22:07,919
to describing them to people they don't

00:22:06,799 --> 00:22:10,559
have to be dealt with

00:22:07,919 --> 00:22:12,880
as if they're a computer programmer if

00:22:10,559 --> 00:22:17,120
you take that approach

00:22:12,880 --> 00:22:20,320
okay effectively decomposing

00:22:17,120 --> 00:22:23,360
um services so that they fit in the

00:22:20,320 --> 00:22:26,559
new cloud native realm is

00:22:23,360 --> 00:22:29,520
only a you know each one each service

00:22:26,559 --> 00:22:31,280
small set of responsibilities follow the

00:22:29,520 --> 00:22:33,760
single responsibility

00:22:31,280 --> 00:22:34,720
principle you can look that one up in

00:22:33,760 --> 00:22:38,080
most uh

00:22:34,720 --> 00:22:40,720
computer uh science books

00:22:38,080 --> 00:22:42,320
and uh you can get a complete

00:22:40,720 --> 00:22:45,120
description of it

00:22:42,320 --> 00:22:46,240
um but really what you're doing is

00:22:45,120 --> 00:22:50,080
following the

00:22:46,240 --> 00:22:52,159
unix utilities of uh policy

00:22:50,080 --> 00:22:53,679
that each one of the utilities like

00:22:52,159 --> 00:22:56,320
graph and awk etc

00:22:53,679 --> 00:22:57,440
does one thing it does it very well it

00:22:56,320 --> 00:22:59,280
doesn't do those

00:22:57,440 --> 00:23:02,000
things multiply you have to put them

00:22:59,280 --> 00:23:03,760
together to accomplish that

00:23:02,000 --> 00:23:05,200
make sure that everything is loosely

00:23:03,760 --> 00:23:08,000
coupled don't tie

00:23:05,200 --> 00:23:08,640
anything to any dependency with any

00:23:08,000 --> 00:23:12,240
other

00:23:08,640 --> 00:23:13,440
um uh aspect of your application service

00:23:12,240 --> 00:23:15,840
or

00:23:13,440 --> 00:23:18,240
microservice if you do that you defeat

00:23:15,840 --> 00:23:21,200
the purpose

00:23:18,240 --> 00:23:22,320
and once again each one the services

00:23:21,200 --> 00:23:24,720
that you're creating

00:23:22,320 --> 00:23:25,919
has an input datagram and an output

00:23:24,720 --> 00:23:32,080
datagram

00:23:25,919 --> 00:23:35,280
and if the datagram is changed by the

00:23:32,080 --> 00:23:37,520
service being published it

00:23:35,280 --> 00:23:38,960
has to have some impact to the next

00:23:37,520 --> 00:23:41,440
event that happens

00:23:38,960 --> 00:23:43,520
otherwise it goes to the next set of

00:23:41,440 --> 00:23:46,559
events

00:23:43,520 --> 00:23:50,080
other services that consume that event

00:23:46,559 --> 00:23:52,799
update their data based on what happened

00:23:50,080 --> 00:23:53,440
with the datagram as it went through the

00:23:52,799 --> 00:23:55,919
service

00:23:53,440 --> 00:24:00,159
in advance of itself and that's what

00:23:55,919 --> 00:24:00,159
they call the invent driven architecture

00:24:00,880 --> 00:24:06,960
a lot of people ask me about whether the

00:24:04,080 --> 00:24:10,000
microservices architecture is any better

00:24:06,960 --> 00:24:11,919
than any of the other

00:24:10,000 --> 00:24:14,080
methodologies for architecting

00:24:11,919 --> 00:24:15,919
application services

00:24:14,080 --> 00:24:18,000
and although i'd love to give you an

00:24:15,919 --> 00:24:19,440
exact answer i'm going to give you a

00:24:18,000 --> 00:24:23,279
rather

00:24:19,440 --> 00:24:27,919
funky one that's not quite appealing

00:24:23,279 --> 00:24:27,919
to everyone it depends so

00:24:28,480 --> 00:24:35,279
if you've broken things down

00:24:32,240 --> 00:24:36,480
well enough to satisfy your needs for

00:24:35,279 --> 00:24:40,320
virtual machine

00:24:36,480 --> 00:24:42,880
hosting from bare metal hosting or from

00:24:40,320 --> 00:24:44,480
mainframe hosting to bare metal to

00:24:42,880 --> 00:24:47,440
virtual machine

00:24:44,480 --> 00:24:49,840
um then you have to ask yourself whether

00:24:47,440 --> 00:24:52,480
it's important to move to

00:24:49,840 --> 00:24:54,159
a containerization and which will

00:24:52,480 --> 00:24:58,080
require another

00:24:54,159 --> 00:25:01,360
uh set of decomposition

00:24:58,080 --> 00:25:02,799
everything that you do from the layer to

00:25:01,360 --> 00:25:06,159
layer to layer

00:25:02,799 --> 00:25:06,799
adds complexity and you need to have

00:25:06,159 --> 00:25:09,840
more

00:25:06,799 --> 00:25:13,679
expertise in the

00:25:09,840 --> 00:25:15,120
various requirements at each one of the

00:25:13,679 --> 00:25:18,320
layers

00:25:15,120 --> 00:25:19,360
for you know virtual bare metal virtual

00:25:18,320 --> 00:25:23,200
machine

00:25:19,360 --> 00:25:26,960
and a containerized microservice

00:25:23,200 --> 00:25:29,039
delivery for cloud native and

00:25:26,960 --> 00:25:31,039
those you need to know what you're doing

00:25:29,039 --> 00:25:34,720
to actually move there

00:25:31,039 --> 00:25:36,720
um networking um it's a

00:25:34,720 --> 00:25:38,640
whole new layer of complexity that's

00:25:36,720 --> 00:25:39,520
added onto it because there's so much

00:25:38,640 --> 00:25:43,600
more

00:25:39,520 --> 00:25:48,320
that the networks between things rely

00:25:43,600 --> 00:25:48,320
on within the containers and

00:25:49,600 --> 00:25:56,799
if you're not adding value in terms of

00:25:53,520 --> 00:25:59,039
creating each one of them then

00:25:56,799 --> 00:26:00,480
why go to the additional complexity

00:25:59,039 --> 00:26:02,400
that's my question

00:26:00,480 --> 00:26:03,600
if you keep asking that and the answer

00:26:02,400 --> 00:26:06,080
is yes

00:26:03,600 --> 00:26:08,240
keep moving on this course if not you

00:26:06,080 --> 00:26:10,159
can stop

00:26:08,240 --> 00:26:12,480
okay let's talk about the platforms

00:26:10,159 --> 00:26:13,520
themselves bare metal versus virtual

00:26:12,480 --> 00:26:15,760
machines

00:26:13,520 --> 00:26:16,799
versus containers versus that category

00:26:15,760 --> 00:26:18,400
of who cares

00:26:16,799 --> 00:26:19,840
and i'm almost getting to the point

00:26:18,400 --> 00:26:23,279
where i can tell you what

00:26:19,840 --> 00:26:25,120
who cares means okay so here's a

00:26:23,279 --> 00:26:27,919
depiction basically of those

00:26:25,120 --> 00:26:28,640
three different architectures and how

00:26:27,919 --> 00:26:31,600
they

00:26:28,640 --> 00:26:33,760
look um you've got the physical

00:26:31,600 --> 00:26:36,159
infrastructure layer at the bottom

00:26:33,760 --> 00:26:36,880
on bare metal there's a host operating

00:26:36,159 --> 00:26:39,360
system and

00:26:36,880 --> 00:26:40,159
applications run on top of it it's a

00:26:39,360 --> 00:26:45,039
single

00:26:40,159 --> 00:26:45,039
individual sort of monolithic

00:26:45,600 --> 00:26:49,679
thing that the applications are sitting

00:26:47,840 --> 00:26:53,120
in

00:26:49,679 --> 00:26:55,200
if you move to virtual machines you've

00:26:53,120 --> 00:26:56,480
got the same physical infrastructure

00:26:55,200 --> 00:26:59,120
sitting underlying it

00:26:56,480 --> 00:27:00,400
and there is a host operating system but

00:26:59,120 --> 00:27:04,080
now we've introduced

00:27:00,400 --> 00:27:06,720
an interceding hypervisor in which

00:27:04,080 --> 00:27:07,600
it can emulate different guest operating

00:27:06,720 --> 00:27:09,679
systems

00:27:07,600 --> 00:27:11,840
sitting in their own name spaces with

00:27:09,679 --> 00:27:14,960
their own ram and their own

00:27:11,840 --> 00:27:16,400
uh allocations of physical pieces of the

00:27:14,960 --> 00:27:19,640
hardware at the

00:27:16,400 --> 00:27:22,240
at the lower end finally from a

00:27:19,640 --> 00:27:24,640
containerization standpoint

00:27:22,240 --> 00:27:26,960
you do have the physical infrastructure

00:27:24,640 --> 00:27:30,320
and the host operating system

00:27:26,960 --> 00:27:30,320
as we originally had

00:27:31,440 --> 00:27:37,360
layered on top of that is an

00:27:34,480 --> 00:27:39,279
engine in this case i'm saying it's the

00:27:37,360 --> 00:27:44,080
docker engine but

00:27:39,279 --> 00:27:47,120
um k zeros is another version of that

00:27:44,080 --> 00:27:50,320
that morantus happens to produce

00:27:47,120 --> 00:27:53,360
and within that engine

00:27:50,320 --> 00:27:56,240
applications can be run in

00:27:53,360 --> 00:27:57,760
separate containers but they're still

00:27:56,240 --> 00:28:02,320
using the same

00:27:57,760 --> 00:28:05,679
operating system they're just taking

00:28:02,320 --> 00:28:06,720
advantage of connections to it uh via

00:28:05,679 --> 00:28:09,600
custom resource

00:28:06,720 --> 00:28:10,159
definitions and things like that so

00:28:09,600 --> 00:28:14,240
that's

00:28:10,159 --> 00:28:14,240
basic differences between the three

00:28:14,399 --> 00:28:21,440
the bare metal world presents some

00:28:17,760 --> 00:28:23,840
benefits over some of the others

00:28:21,440 --> 00:28:25,919
if you have workloads that demand the

00:28:23,840 --> 00:28:27,840
full computing capabilities

00:28:25,919 --> 00:28:29,520
of the physical hardware put it on bare

00:28:27,840 --> 00:28:31,840
metal

00:28:29,520 --> 00:28:33,200
if it requires specialized hardware in

00:28:31,840 --> 00:28:35,440
most cases

00:28:33,200 --> 00:28:39,039
um you know they can virtualize some of

00:28:35,440 --> 00:28:39,039
them now like gpus and

00:28:39,279 --> 00:28:42,320
you know smart cards and things like

00:28:41,120 --> 00:28:45,279
that

00:28:42,320 --> 00:28:46,960
but as this physical specialized

00:28:45,279 --> 00:28:49,120
hardware progresses

00:28:46,960 --> 00:28:51,039
some of them won't be able to be sliced

00:28:49,120 --> 00:28:53,760
off and you'll have to use the

00:28:51,039 --> 00:28:54,960
full physical infrastructure to uh

00:28:53,760 --> 00:28:58,000
accommodate them on them

00:28:54,960 --> 00:29:01,679
on the back plane um

00:28:58,000 --> 00:29:03,200
if you host on bare metal no noisy

00:29:01,679 --> 00:29:06,640
neighbor syndrome

00:29:03,200 --> 00:29:08,640
um and there's fewer moving parts

00:29:06,640 --> 00:29:09,840
if something breaks you know where to

00:29:08,640 --> 00:29:12,000
look for it

00:29:09,840 --> 00:29:13,600
and networking is much less complex

00:29:12,000 --> 00:29:16,720
because if i've

00:29:13,600 --> 00:29:20,399
plugged in the rj45

00:29:16,720 --> 00:29:24,399
uh plug and the light comes on

00:29:20,399 --> 00:29:24,399
i'm pretty sure i've got connectivity

00:29:24,480 --> 00:29:30,720
in virtual machines um

00:29:28,080 --> 00:29:33,840
this is where that service decomposition

00:29:30,720 --> 00:29:37,600
stuff starts to take into effect because

00:29:33,840 --> 00:29:39,679
you can split things up across multiple

00:29:37,600 --> 00:29:43,440
virtual machines

00:29:39,679 --> 00:29:45,200
in very different operating systems

00:29:43,440 --> 00:29:46,559
when you host these virtual machines on

00:29:45,200 --> 00:29:49,440
bare metal you can

00:29:46,559 --> 00:29:51,200
increase the utilization of those

00:29:49,440 --> 00:29:53,360
physical resources a lot

00:29:51,200 --> 00:29:54,640
on bare metal typically there's only

00:29:53,360 --> 00:29:56,240
about 30 percent

00:29:54,640 --> 00:29:58,640
of the physical hardware that actually

00:29:56,240 --> 00:30:01,279
gets used at any point in time

00:29:58,640 --> 00:30:04,799
on virtual machines you can push that up

00:30:01,279 --> 00:30:04,799
to 70 or 80 percent

00:30:05,200 --> 00:30:11,919
it in this emulation mode

00:30:08,880 --> 00:30:16,000
of the hypervisor uh you can

00:30:11,919 --> 00:30:19,360
emulate the use of things like

00:30:16,000 --> 00:30:22,240
nic cards and uh

00:30:19,360 --> 00:30:24,080
gpus and all kinds of other things so

00:30:22,240 --> 00:30:27,520
you can make more effective use of the

00:30:24,080 --> 00:30:30,720
physical hardware that you have

00:30:27,520 --> 00:30:32,720
that hypervisor usually has a machine

00:30:30,720 --> 00:30:33,360
monitor that's into it that allows you

00:30:32,720 --> 00:30:36,720
to create

00:30:33,360 --> 00:30:39,200
and run the virtual machines themselves

00:30:36,720 --> 00:30:40,399
and they create a buffer the hypervisor

00:30:39,200 --> 00:30:42,080
creates a buffer

00:30:40,399 --> 00:30:43,840
between the operating system and each

00:30:42,080 --> 00:30:46,159
one of the virtual machines

00:30:43,840 --> 00:30:47,200
so you can manipulate stuff in between

00:30:46,159 --> 00:30:51,200
them

00:30:47,200 --> 00:30:53,919
and um the

00:30:51,200 --> 00:30:55,120
virtual machines themselves run in their

00:30:53,919 --> 00:30:57,039
own namespaces

00:30:55,120 --> 00:30:58,399
and have their own operating systems

00:30:57,039 --> 00:31:01,120
associated to them

00:30:58,399 --> 00:31:02,559
so you can have windows and linux and

00:31:01,120 --> 00:31:06,720
unix platforms

00:31:02,559 --> 00:31:09,279
running on the same physical machine

00:31:06,720 --> 00:31:10,720
and they can be run at the same on the

00:31:09,279 --> 00:31:13,039
same physical server

00:31:10,720 --> 00:31:15,279
without interfering with each other

00:31:13,039 --> 00:31:17,600
which is kind of fun

00:31:15,279 --> 00:31:19,440
okay some of the benefits for those

00:31:17,600 --> 00:31:21,279
virtual machines

00:31:19,440 --> 00:31:23,760
is the hardware being virtualized to run

00:31:21,279 --> 00:31:25,360
multiple operating system instances

00:31:23,760 --> 00:31:26,880
uh if you need that to run your

00:31:25,360 --> 00:31:28,320
applications it's a pretty good way of

00:31:26,880 --> 00:31:30,480
doing it

00:31:28,320 --> 00:31:32,000
consolidates the multiple applications

00:31:30,480 --> 00:31:33,760
into a single system because

00:31:32,000 --> 00:31:35,360
you can host all the virtual machines

00:31:33,760 --> 00:31:38,880
there

00:31:35,360 --> 00:31:41,120
cost savings says there's a reduced

00:31:38,880 --> 00:31:44,159
footprint of physical hardware

00:31:41,120 --> 00:31:46,159
to host your application services and

00:31:44,159 --> 00:31:48,000
you can provision them faster because

00:31:46,159 --> 00:31:51,120
the physical hypervisored

00:31:48,000 --> 00:31:54,000
operating system is already running so

00:31:51,120 --> 00:31:56,080
you're just putting a definition on top

00:31:54,000 --> 00:31:58,799
of that of the virtual machine

00:31:56,080 --> 00:32:02,640
um and the increased utilization as i

00:31:58,799 --> 00:32:06,480
indicated earlier up to 70 percent

00:32:02,640 --> 00:32:08,799
okay if you've stayed with me this far

00:32:06,480 --> 00:32:11,120
and you want to deal with dealing with

00:32:08,799 --> 00:32:14,159
the containerization because you think

00:32:11,120 --> 00:32:18,000
the complexity is worth it

00:32:14,159 --> 00:32:21,760
you can run this sort of software

00:32:18,000 --> 00:32:24,799
uh in a cloud-native way predictably

00:32:21,760 --> 00:32:25,519
and it'll run from server to server as

00:32:24,799 --> 00:32:28,080
you move it

00:32:25,519 --> 00:32:31,360
or virtual machine to virtual machine as

00:32:28,080 --> 00:32:34,480
you move it in pretty much the same way

00:32:31,360 --> 00:32:35,440
and it provides a way of running the the

00:32:34,480 --> 00:32:38,480
isolated

00:32:35,440 --> 00:32:41,519
systems on a single host so

00:32:38,480 --> 00:32:43,120
each one of the services can be run and

00:32:41,519 --> 00:32:45,440
isolated

00:32:43,120 --> 00:32:46,880
on the single server host typically

00:32:45,440 --> 00:32:48,559
there's a framework

00:32:46,880 --> 00:32:50,960
uh that's associated with that and i'll

00:32:48,559 --> 00:32:55,360
get into that in a little bit

00:32:50,960 --> 00:32:58,159
um and the the as i

00:32:55,360 --> 00:33:01,279
mentioned earlier the engine you know

00:32:58,159 --> 00:33:03,120
either docker or k0s

00:33:01,279 --> 00:33:04,559
or whatever engine you happen to be

00:33:03,120 --> 00:33:06,960
running is just

00:33:04,559 --> 00:33:08,080
running on top of the host os and it's

00:33:06,960 --> 00:33:11,200
not really a

00:33:08,080 --> 00:33:15,039
hypervisor in that way but it has

00:33:11,200 --> 00:33:16,960
properties like a hypervisor uh

00:33:15,039 --> 00:33:18,640
the difference in that and a virtual

00:33:16,960 --> 00:33:19,919
machine obviously is the operating

00:33:18,640 --> 00:33:23,279
system kernel

00:33:19,919 --> 00:33:24,320
which is shared in a containerized

00:33:23,279 --> 00:33:27,200
environment

00:33:24,320 --> 00:33:28,720
and not shared in a virtual machine

00:33:27,200 --> 00:33:31,039
environment

00:33:28,720 --> 00:33:32,640
but because the containers are really

00:33:31,039 --> 00:33:36,399
lightweight

00:33:32,640 --> 00:33:37,279
um and and and tiny in terms of what

00:33:36,399 --> 00:33:40,480
their

00:33:37,279 --> 00:33:43,200
uh neat resources they need um

00:33:40,480 --> 00:33:44,480
they start up in seconds versus minutes

00:33:43,200 --> 00:33:46,799
to boot

00:33:44,480 --> 00:33:47,679
an operating system sitting in a virtual

00:33:46,799 --> 00:33:50,399
machine

00:33:47,679 --> 00:33:53,519
that's a big plus for recoverability and

00:33:50,399 --> 00:33:56,640
things like that

00:33:53,519 --> 00:33:59,200
and these containers have specific

00:33:56,640 --> 00:34:01,600
benefits over and above the virtualized

00:33:59,200 --> 00:34:03,279
or the bare metal world

00:34:01,600 --> 00:34:04,880
you can pack a lot more onto an

00:34:03,279 --> 00:34:05,600
application whereas you might be able to

00:34:04,880 --> 00:34:07,840
pack

00:34:05,600 --> 00:34:08,960
20 or so virtual machines onto a

00:34:07,840 --> 00:34:12,800
physical host

00:34:08,960 --> 00:34:15,200
you can do 200 2 000 containers on that

00:34:12,800 --> 00:34:18,720
same host

00:34:15,200 --> 00:34:22,079
and you know you can

00:34:18,720 --> 00:34:24,800
share things um much more easily

00:34:22,079 --> 00:34:25,679
in both the public and private cloud uh

00:34:24,800 --> 00:34:28,720
world

00:34:25,679 --> 00:34:29,599
by doing it and they'll allow you to

00:34:28,720 --> 00:34:32,960
share

00:34:29,599 --> 00:34:36,639
resources across those two together in

00:34:32,960 --> 00:34:36,639
you know hyper

00:34:36,879 --> 00:34:43,359
cluster worlds you can also

00:34:41,119 --> 00:34:46,399
accelerate development because of the

00:34:43,359 --> 00:34:48,399
quick packaging and testing and

00:34:46,399 --> 00:34:50,480
application development and it's a whole

00:34:48,399 --> 00:34:53,760
new realm of ci cd

00:34:50,480 --> 00:34:57,200
uh capabilities that um

00:34:53,760 --> 00:34:59,520
that move to agile basically and

00:34:57,200 --> 00:35:00,960
um since they all share that single

00:34:59,520 --> 00:35:03,119
operating system

00:35:00,960 --> 00:35:04,640
you're only maintaining one versus

00:35:03,119 --> 00:35:06,240
maintaining the virtual machine

00:35:04,640 --> 00:35:08,160
operating systems and

00:35:06,240 --> 00:35:11,440
that sort of thing so it makes it easier

00:35:08,160 --> 00:35:11,440
to do the care and feeding

00:35:12,240 --> 00:35:20,880
okay we finally get to the who cares

00:35:17,760 --> 00:35:23,680
um if you've taken the time to

00:35:20,880 --> 00:35:24,480
move off of the mainframes to bare metal

00:35:23,680 --> 00:35:27,760
to

00:35:24,480 --> 00:35:28,960
virtual machines and the applications

00:35:27,760 --> 00:35:34,560
have been compo

00:35:28,960 --> 00:35:34,560
decomposed and placed in containers

00:35:34,640 --> 00:35:41,599
instead of having a single location

00:35:38,960 --> 00:35:42,480
where you can run them in the boundaries

00:35:41,599 --> 00:35:44,240
of

00:35:42,480 --> 00:35:45,680
is it the bare metal of the virtual

00:35:44,240 --> 00:35:49,280
machine or

00:35:45,680 --> 00:35:52,640
that sort of thing what if

00:35:49,280 --> 00:35:55,119
all of the containers were placed into a

00:35:52,640 --> 00:35:57,119
secured registry

00:35:55,119 --> 00:35:58,320
and that secured registry was only

00:35:57,119 --> 00:36:02,480
accessible by

00:35:58,320 --> 00:36:05,599
your organization and

00:36:02,480 --> 00:36:07,599
if encoding is needed the containerized

00:36:05,599 --> 00:36:11,760
service for encoding

00:36:07,599 --> 00:36:15,599
would be drawn from the catalog of

00:36:11,760 --> 00:36:18,720
discovered services

00:36:15,599 --> 00:36:21,680
within your application service

00:36:18,720 --> 00:36:22,640
and would simply be allowed to do the

00:36:21,680 --> 00:36:25,760
encoding

00:36:22,640 --> 00:36:26,000
for you versus having to write it into

00:36:25,760 --> 00:36:30,079
the

00:36:26,000 --> 00:36:34,400
application and

00:36:30,079 --> 00:36:36,240
then if you don't need to worry about

00:36:34,400 --> 00:36:38,000
where things are running or how things

00:36:36,240 --> 00:36:42,160
are running

00:36:38,000 --> 00:36:45,280
you're able to scale um

00:36:42,160 --> 00:36:49,119
much more rapidly across multiple

00:36:45,280 --> 00:36:49,119
platform types at the same time

00:36:49,359 --> 00:36:53,920
you can do it across the servers you can

00:36:52,160 --> 00:36:57,599
do it

00:36:53,920 --> 00:37:01,280
to scale more easily you can do it to

00:36:57,599 --> 00:37:01,280
increase the network bandwidth

00:37:01,440 --> 00:37:05,680
all within the application services

00:37:03,839 --> 00:37:08,800
themselves

00:37:05,680 --> 00:37:10,560
um so so far

00:37:08,800 --> 00:37:12,560
what i've described is sort of like the

00:37:10,560 --> 00:37:14,320
promise of quote what they call

00:37:12,560 --> 00:37:17,760
serverless computing

00:37:14,320 --> 00:37:20,800
but in a serverless computing realm

00:37:17,760 --> 00:37:23,520
the downfall as i pointed out earlier is

00:37:20,800 --> 00:37:25,119
that you results in vendor lock and the

00:37:23,520 --> 00:37:27,280
one from aws

00:37:25,119 --> 00:37:28,320
is different than the one from azure is

00:37:27,280 --> 00:37:32,000
different than the

00:37:28,320 --> 00:37:36,800
one from gke so you get locked into one

00:37:32,000 --> 00:37:39,599
basically what if instead of relying

00:37:36,800 --> 00:37:39,599
on the

00:37:39,839 --> 00:37:42,880
vendor provided

00:37:43,119 --> 00:37:48,640
orchestration capabilities for

00:37:46,000 --> 00:37:52,400
serverless

00:37:48,640 --> 00:37:53,440
we hosted everything in a kubernetes

00:37:52,400 --> 00:37:55,280
infrastructure

00:37:53,440 --> 00:37:57,280
that was running in all of those

00:37:55,280 --> 00:38:00,079
environments

00:37:57,280 --> 00:38:02,800
now we don't need to really deal with

00:38:00,079 --> 00:38:06,079
vendor lock-in

00:38:02,800 --> 00:38:09,839
that the framework itself is the one

00:38:06,079 --> 00:38:13,040
seeking in its uh service discovery

00:38:09,839 --> 00:38:16,079
where the containers are what they

00:38:13,040 --> 00:38:18,079
are used to do like in coding or like

00:38:16,079 --> 00:38:20,800
increasing network bandwidth or those

00:38:18,079 --> 00:38:20,800
kinds of things

00:38:20,880 --> 00:38:27,359
people are now becoming familiar with

00:38:23,920 --> 00:38:29,920
the containerized world and the

00:38:27,359 --> 00:38:31,200
kubernetes framework is now becoming the

00:38:29,920 --> 00:38:35,520
most popular

00:38:31,200 --> 00:38:37,839
so you can reuse your existing

00:38:35,520 --> 00:38:40,160
skill sets you don't have to develop a

00:38:37,839 --> 00:38:42,160
whole lot of new ones

00:38:40,160 --> 00:38:43,200
multi-cluster environments become

00:38:42,160 --> 00:38:45,839
possible

00:38:43,200 --> 00:38:48,400
across multiple infrastructures that

00:38:45,839 --> 00:38:51,920
happen to be on-prem or

00:38:48,400 --> 00:38:53,760
in the quote cloud as people say

00:38:51,920 --> 00:38:55,839
can even create environments and

00:38:53,760 --> 00:38:59,119
resources which are shared

00:38:55,839 --> 00:39:02,320
among the private and public and

00:38:59,119 --> 00:39:05,839
allow the developers to place it where

00:39:02,320 --> 00:39:05,839
they think it runs best

00:39:06,160 --> 00:39:09,280
and here's where i want to introduce

00:39:08,480 --> 00:39:13,119
this idea

00:39:09,280 --> 00:39:14,960
of a service mesh which layers over the

00:39:13,119 --> 00:39:18,560
top of your multi-cluster

00:39:14,960 --> 00:39:20,560
environment um the one that i

00:39:18,560 --> 00:39:22,720
like to use to accomplish those kind of

00:39:20,560 --> 00:39:23,280
things is istio but there are others out

00:39:22,720 --> 00:39:28,240
there

00:39:23,280 --> 00:39:31,680
such as kong or super glue or those

00:39:28,240 --> 00:39:35,040
and they'll provide a quality of service

00:39:31,680 --> 00:39:36,800
and security capability across all of

00:39:35,040 --> 00:39:39,920
the networking that

00:39:36,800 --> 00:39:43,839
is involved to can interconnect all of

00:39:39,920 --> 00:39:43,839
those environments

00:39:44,079 --> 00:39:51,839
and if you take me one step further

00:39:48,800 --> 00:39:56,079
in this thinking about

00:39:51,839 --> 00:39:59,200
who cares and deciding on a

00:39:56,079 --> 00:40:02,640
standardized platform uh

00:39:59,200 --> 00:40:05,119
what if we built the intelligence

00:40:02,640 --> 00:40:07,119
into the provisioning of the containers

00:40:05,119 --> 00:40:10,240
and deployment of containers

00:40:07,119 --> 00:40:10,880
and things like that into a neural

00:40:10,240 --> 00:40:13,920
network

00:40:10,880 --> 00:40:16,400
that is sitting inside of

00:40:13,920 --> 00:40:17,599
the service mesh that's presented to all

00:40:16,400 --> 00:40:19,440
of these different

00:40:17,599 --> 00:40:21,119
clusters across all of these different

00:40:19,440 --> 00:40:24,160
platforms

00:40:21,119 --> 00:40:27,599
and it seeks in the

00:40:24,160 --> 00:40:31,200
trusted secured registry

00:40:27,599 --> 00:40:32,319
those things that it needs algorithms

00:40:31,200 --> 00:40:34,800
could be

00:40:32,319 --> 00:40:35,680
presented to scale up and down as

00:40:34,800 --> 00:40:39,280
required

00:40:35,680 --> 00:40:40,880
across multiple infrastructure types

00:40:39,280 --> 00:40:42,960
minimize the cost of maintaining the

00:40:40,880 --> 00:40:44,160
infrastructure and maximize its

00:40:42,960 --> 00:40:46,000
performance

00:40:44,160 --> 00:40:47,280
because now you can take advantage of it

00:40:46,000 --> 00:40:50,400
across all of them

00:40:47,280 --> 00:40:51,119
where it runs best instead of running

00:40:50,400 --> 00:40:54,240
things in

00:40:51,119 --> 00:40:55,119
individual servers we introduce the idea

00:40:54,240 --> 00:40:59,359
of tpm

00:40:55,119 --> 00:41:03,119
trusted computing and we

00:40:59,359 --> 00:41:05,920
ensure that only computers the physical

00:41:03,119 --> 00:41:06,800
hosts that have trusted computing that

00:41:05,920 --> 00:41:09,200
represent

00:41:06,800 --> 00:41:11,119
my organization are part of this

00:41:09,200 --> 00:41:14,720
clustered environment

00:41:11,119 --> 00:41:16,319
across multiple platforms and then

00:41:14,720 --> 00:41:19,440
all of the images in the trusted

00:41:16,319 --> 00:41:22,880
registry can be instantiated on whatever

00:41:19,440 --> 00:41:23,599
physical hosts they need to be under the

00:41:22,880 --> 00:41:28,319
control

00:41:23,599 --> 00:41:31,760
of the orchestrator kubernetes

00:41:28,319 --> 00:41:35,040
using the tpm technology to be able to

00:41:31,760 --> 00:41:38,560
ensure that it's the risk

00:41:35,040 --> 00:41:40,240
you know minimizes risk and it can

00:41:38,560 --> 00:41:43,839
distribute it

00:41:40,240 --> 00:41:45,680
with that risk mitigated

00:41:43,839 --> 00:41:48,400
what will have to happen to accomplish

00:41:45,680 --> 00:41:50,960
this obviously is standardization

00:41:48,400 --> 00:41:52,720
and a security model that works for

00:41:50,960 --> 00:41:54,720
everybody

00:41:52,720 --> 00:41:56,240
and this is something that the industry

00:41:54,720 --> 00:42:01,359
needs to work on

00:41:56,240 --> 00:42:03,599
in my opinion to continue a harmonious

00:42:01,359 --> 00:42:05,040
condition where all of the flavors of

00:42:03,599 --> 00:42:07,359
infrastructure

00:42:05,040 --> 00:42:08,560
and containers and virtual machines and

00:42:07,359 --> 00:42:11,920
bare metals

00:42:08,560 --> 00:42:16,720
can live together

00:42:11,920 --> 00:42:18,319
in a secured way

00:42:16,720 --> 00:42:20,319
all right a little bit of light reading

00:42:18,319 --> 00:42:21,359
for you guys to finish off on if you

00:42:20,319 --> 00:42:23,440
think that you

00:42:21,359 --> 00:42:25,680
like this kind of approach and like to

00:42:23,440 --> 00:42:28,319
read a little more on it

00:42:25,680 --> 00:42:29,680
there's a blog out there at the link

00:42:28,319 --> 00:42:31,440
that i've shared

00:42:29,680 --> 00:42:33,520
that hopefully will give you more

00:42:31,440 --> 00:42:35,359
additional information

00:42:33,520 --> 00:42:37,359
and then finally from my company

00:42:35,359 --> 00:42:40,720
marantis i wanted to

00:42:37,359 --> 00:42:44,160
sort of give you an idea of some

00:42:40,720 --> 00:42:47,280
freeware uh thing that's available

00:42:44,160 --> 00:42:48,319
for you called lens that will help you

00:42:47,280 --> 00:42:51,760
or

00:42:48,319 --> 00:42:54,720
manage these orchestration engines

00:42:51,760 --> 00:42:56,960
across multiple clusters uh as a

00:42:54,720 --> 00:42:58,000
developer and to be able to allow you to

00:42:56,960 --> 00:43:01,119
put things

00:42:58,000 --> 00:43:02,880
in one place or another or another uh

00:43:01,119 --> 00:43:05,760
depending on how you believe

00:43:02,880 --> 00:43:07,359
it will run best in your application

00:43:05,760 --> 00:43:10,480
service or

00:43:07,359 --> 00:43:11,440
cheapest or you know faster better

00:43:10,480 --> 00:43:13,760
cheaper

00:43:11,440 --> 00:43:15,119
this is a way of allowing you to decide

00:43:13,760 --> 00:43:17,280
which one of those

00:43:15,119 --> 00:43:18,640
to put them in because it will manage

00:43:17,280 --> 00:43:23,520
things on-prem

00:43:18,640 --> 00:43:23,520
in cloud etc all in the same way

00:43:24,160 --> 00:43:28,560
and i'm told that there will be some

00:43:26,160 --> 00:43:30,079
kind of question and answer sessions at

00:43:28,560 --> 00:43:33,200
the end of it

00:43:30,079 --> 00:43:36,720
so i'm putting this slide in

00:43:33,200 --> 00:43:39,760
to represent that and

00:43:36,720 --> 00:43:40,560
if you seem to think that there's

00:43:39,760 --> 00:43:45,920
something

00:43:40,560 --> 00:43:45,920
here that uh makes sense for you

00:43:46,000 --> 00:43:50,400
or didn't make sense for you please feel

00:43:48,560 --> 00:43:54,079
free to give me a shout out

00:43:50,400 --> 00:43:58,520
on on email my email address

00:43:54,079 --> 00:44:01,359
is b matthews b-m-a-t-h-e-w-s

00:43:58,520 --> 00:44:04,319
morantis.com please feel free that's

00:44:01,359 --> 00:44:04,319
what i'm here for

00:44:05,760 --> 00:44:10,880
thank you all very much and i hope you

00:44:08,079 --> 00:44:15,119
have a happy gobbler

00:44:10,880 --> 00:44:19,119
on the 25th of november take care

00:44:15,119 --> 00:44:23,839
be socially distant wash your hands

00:44:19,119 --> 00:44:23,839

YouTube URL: https://www.youtube.com/watch?v=Sp3R66NvJlM


