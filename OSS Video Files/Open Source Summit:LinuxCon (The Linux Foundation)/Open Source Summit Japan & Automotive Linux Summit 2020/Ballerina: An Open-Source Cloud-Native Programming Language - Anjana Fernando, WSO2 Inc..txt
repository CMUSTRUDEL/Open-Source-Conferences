Title: Ballerina: An Open-Source Cloud-Native Programming Language - Anjana Fernando, WSO2 Inc.
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Ballerina: An Open-Source Cloud-Native Programming Language - Anjana Fernando, WSO2 Inc.
Captions: 
	00:00:05,759 --> 00:00:08,960
hi everyone

00:00:06,720 --> 00:00:10,480
welcome to this session on ballerina an

00:00:08,960 --> 00:00:12,880
open source cloud native programming

00:00:10,480 --> 00:00:12,880
language

00:00:12,960 --> 00:00:16,080
so we have seen cloud native

00:00:14,639 --> 00:00:19,920
technologies being used

00:00:16,080 --> 00:00:23,760
to create scalable applications so

00:00:19,920 --> 00:00:28,160
we generally use them as a set of

00:00:23,760 --> 00:00:31,359
tools libraries frameworks that are used

00:00:28,160 --> 00:00:34,399
on top of existing program languages

00:00:31,359 --> 00:00:37,040
to make them cloud native ready so

00:00:34,399 --> 00:00:39,120
they can be used to write microservices

00:00:37,040 --> 00:00:42,640
to get these

00:00:39,120 --> 00:00:45,520
features retrofitted to these languages

00:00:42,640 --> 00:00:46,719
so uh what we have tried to do with

00:00:45,520 --> 00:00:49,920
ballerina

00:00:46,719 --> 00:00:53,360
is to create a program language

00:00:49,920 --> 00:00:55,280
from ground up uh by

00:00:53,360 --> 00:00:56,480
having these concepts of cloud

00:00:55,280 --> 00:00:59,680
nativeness

00:00:56,480 --> 00:01:02,480
inbuilt to the language itself so

00:00:59,680 --> 00:01:03,840
basically it's a language that is agile

00:01:02,480 --> 00:01:07,119
and network aware

00:01:03,840 --> 00:01:09,520
so uh the baron language knows about

00:01:07,119 --> 00:01:11,200
network endpoints it knows about how the

00:01:09,520 --> 00:01:14,640
network works how to do

00:01:11,200 --> 00:01:15,680
and communication and so on so the idea

00:01:14,640 --> 00:01:19,200
of this

00:01:15,680 --> 00:01:22,320
language is to create an additional

00:01:19,200 --> 00:01:23,600
abstraction layer uh of understanding

00:01:22,320 --> 00:01:26,320
the network to make

00:01:23,600 --> 00:01:27,680
the life of the developer much more

00:01:26,320 --> 00:01:31,600
easier

00:01:27,680 --> 00:01:34,640
in doing cloud native development

00:01:31,600 --> 00:01:36,320
so um in this presentation i'll be

00:01:34,640 --> 00:01:38,240
going through some of the major features

00:01:36,320 --> 00:01:39,840
of the language and i'll be doing some

00:01:38,240 --> 00:01:42,159
hands-on

00:01:39,840 --> 00:01:43,759
demonstrations on how the code looks

00:01:42,159 --> 00:01:47,200
like and

00:01:43,759 --> 00:01:52,000
how things work so let's

00:01:47,200 --> 00:01:54,799
get right into some samples

00:01:52,000 --> 00:01:55,280
so before that uh so another aspect is

00:01:54,799 --> 00:01:58,479
uh

00:01:55,280 --> 00:02:02,719
barana is a battery's included platform

00:01:58,479 --> 00:02:04,719
so um it has built-in support for

00:02:02,719 --> 00:02:06,799
most of the prominent technologies we

00:02:04,719 --> 00:02:10,560
use like starting from

00:02:06,799 --> 00:02:13,840
uh data type supports like xml json

00:02:10,560 --> 00:02:16,879
to uh transports like grpc

00:02:13,840 --> 00:02:18,080
nets uh and built-in observability

00:02:16,879 --> 00:02:21,440
features and so on

00:02:18,080 --> 00:02:23,200
so those are all built into the uh

00:02:21,440 --> 00:02:24,560
the language and the platform so you

00:02:23,200 --> 00:02:27,760
don't have to worry about

00:02:24,560 --> 00:02:30,239
having an other uh finding external

00:02:27,760 --> 00:02:34,720
libraries to get

00:02:30,239 --> 00:02:34,720
like the most general things done

00:02:35,599 --> 00:02:40,720
so let's look at a hello world scenario

00:02:39,040 --> 00:02:43,280
from ballerina

00:02:40,720 --> 00:02:44,800
so it's actually a hello world service

00:02:43,280 --> 00:02:47,840
that we are going to write

00:02:44,800 --> 00:02:49,680
so we are going to have like a simple

00:02:47,840 --> 00:02:52,959
banner service which will

00:02:49,680 --> 00:02:55,519
respond to http get so let's see how

00:02:52,959 --> 00:02:55,519
that is done

00:02:57,040 --> 00:03:03,599
so i'm going to use vs code for my demos

00:03:00,879 --> 00:03:04,720
so there's a burner vs code plugin that

00:03:03,599 --> 00:03:07,200
you can use

00:03:04,720 --> 00:03:08,000
uh so if you go to the vs code

00:03:07,200 --> 00:03:09,599
marketplace

00:03:08,000 --> 00:03:11,760
the banner plugin is there you can just

00:03:09,599 --> 00:03:14,959
directly install it from

00:03:11,760 --> 00:03:17,200
that place so here

00:03:14,959 --> 00:03:18,560
i'm just going to create a new file

00:03:17,200 --> 00:03:22,239
called the model belt

00:03:18,560 --> 00:03:23,599
so bell is the source file extension for

00:03:22,239 --> 00:03:28,080
barana

00:03:23,599 --> 00:03:32,080
code so here let's create a

00:03:28,080 --> 00:03:33,920
http service the plugin contains some

00:03:32,080 --> 00:03:36,080
shortcuts to create

00:03:33,920 --> 00:03:39,200
often used templates like here i have

00:03:36,080 --> 00:03:41,920
directly created a service

00:03:39,200 --> 00:03:43,840
and as you can see here so in ballerina

00:03:41,920 --> 00:03:46,959
we have a first class cons

00:03:43,840 --> 00:03:50,720
construct for services

00:03:46,959 --> 00:03:54,239
so a service can be an http service grpc

00:03:50,720 --> 00:03:56,319
a messaging service and so on so

00:03:54,239 --> 00:03:57,519
the type of the service depends on the

00:03:56,319 --> 00:04:00,560
type of

00:03:57,519 --> 00:04:02,159
http listener that it's bound to so here

00:04:00,560 --> 00:04:04,879
we have an http listener

00:04:02,159 --> 00:04:07,040
defined here so then this becomes an

00:04:04,879 --> 00:04:10,319
http service

00:04:07,040 --> 00:04:11,920
so let's call our service hello

00:04:10,319 --> 00:04:13,599
and this resource functions are the

00:04:11,920 --> 00:04:14,640
actual functionalities that are there in

00:04:13,599 --> 00:04:16,799
the service

00:04:14,640 --> 00:04:18,079
so here a resource function can be bound

00:04:16,799 --> 00:04:21,359
to a certain

00:04:18,079 --> 00:04:28,160
uh subcontext of http service

00:04:21,359 --> 00:04:31,759
so i'm going to say okay hi

00:04:28,160 --> 00:04:34,000
i can also give things like

00:04:31,759 --> 00:04:34,000
the

00:04:34,960 --> 00:04:38,080
base part for the service so i can say

00:04:37,440 --> 00:04:42,400
here

00:04:38,080 --> 00:04:45,320
okay this is mapped to the root context

00:04:42,400 --> 00:04:46,639
so here we are just going to send a

00:04:45,320 --> 00:04:49,759
response

00:04:46,639 --> 00:04:49,759
back to the caller

00:04:51,440 --> 00:04:58,479
we're just going to say hello

00:04:56,479 --> 00:05:01,199
some housekeeping tasks to do error

00:04:58,479 --> 00:05:01,199
handling here

00:05:02,880 --> 00:05:07,120
so that's it so this is our service

00:05:07,840 --> 00:05:15,919
then let's run it and see

00:05:12,960 --> 00:05:16,960
so when you say burner run command the

00:05:15,919 --> 00:05:22,000
source file it will

00:05:16,960 --> 00:05:27,039
build and run our program at once

00:05:22,000 --> 00:05:30,160
so here our service is up and running

00:05:27,039 --> 00:05:35,680
now we can send

00:05:30,160 --> 00:05:35,680
it an http request and see the response

00:05:37,840 --> 00:05:43,440
obvious path is from the root and

00:05:41,039 --> 00:05:44,800
the subcontext by default map so there

00:05:43,440 --> 00:05:48,240
is a function name

00:05:44,800 --> 00:05:48,240
so you can say hi

00:05:48,800 --> 00:05:53,199
so yes so you can see you got the

00:05:51,039 --> 00:05:55,759
response back

00:05:53,199 --> 00:05:56,960
so that's a simple http service using

00:05:55,759 --> 00:06:00,720
ballerina

00:05:56,960 --> 00:06:01,120
so then we can modify its behavior as

00:06:00,720 --> 00:06:04,479
well

00:06:01,120 --> 00:06:05,759
so we already saw the use of annotation

00:06:04,479 --> 00:06:08,080
earlier when we

00:06:05,759 --> 00:06:10,000
gave it the base path so we can do other

00:06:08,080 --> 00:06:13,120
things like we can restrict it

00:06:10,000 --> 00:06:15,680
only for post requests

00:06:13,120 --> 00:06:15,680
you can say

00:06:18,240 --> 00:06:21,840
it will only handle post

00:06:31,039 --> 00:06:36,880
so that should be added to the

00:06:34,319 --> 00:06:36,880
resource

00:06:37,600 --> 00:06:46,880
you can say okay i only have a post

00:06:42,319 --> 00:06:49,759
request here and here let's actually

00:06:46,880 --> 00:06:52,240
extract the payload that is sent to the

00:06:49,759 --> 00:06:52,240
service

00:06:52,880 --> 00:07:02,160
and use the request object

00:06:56,639 --> 00:07:04,560
and say give me the text payload

00:07:02,160 --> 00:07:04,560
and

00:07:07,199 --> 00:07:09,840
you have to say

00:07:14,080 --> 00:07:21,520
and afterwards we'll

00:07:17,759 --> 00:07:25,120
just echo back that uh

00:07:21,520 --> 00:07:31,840
payload data to the user

00:07:25,120 --> 00:07:31,840
so we'll say

00:07:32,479 --> 00:07:35,919
use the string template here

00:07:38,000 --> 00:07:45,840
and give the variable name

00:07:50,160 --> 00:07:52,400
so

00:07:54,720 --> 00:08:00,560
that's it for our service update let's

00:07:57,680 --> 00:08:00,560
run this and see

00:08:02,800 --> 00:08:07,599
and in this case we are going to send

00:08:05,919 --> 00:08:12,080
some

00:08:07,599 --> 00:08:15,440
payload as well so this will be a

00:08:12,080 --> 00:08:16,479
request and you can see here we got the

00:08:15,440 --> 00:08:19,599
response back

00:08:16,479 --> 00:08:22,080
with the payload we gave so it says give

00:08:19,599 --> 00:08:25,360
jack so it says hello jack

00:08:22,080 --> 00:08:26,800
and so on so that's like the simple way

00:08:25,360 --> 00:08:30,080
of handling

00:08:26,800 --> 00:08:30,080
services in ballerina

00:08:30,639 --> 00:08:34,959
and let's go to the next section of

00:08:33,519 --> 00:08:38,240
using connectors

00:08:34,959 --> 00:08:41,519
so we'll

00:08:38,240 --> 00:08:43,519
do a extended

00:08:41,519 --> 00:08:45,600
demonstration of the code we have by

00:08:43,519 --> 00:08:48,640
using some connectors

00:08:45,600 --> 00:08:50,000
so as i mentioned in berliner so it has

00:08:48,640 --> 00:08:53,680
some explicit knowledge

00:08:50,000 --> 00:08:54,080
on the network operations that we do um

00:08:53,680 --> 00:08:57,120
uh

00:08:54,080 --> 00:09:00,560
like then in fact uh

00:08:57,120 --> 00:09:01,360
uh for example the http post get and so

00:09:00,560 --> 00:09:04,560
on

00:09:01,360 --> 00:09:06,640
uh those are modeled as

00:09:04,560 --> 00:09:09,519
special operations in the language so

00:09:06,640 --> 00:09:12,320
for example when we say caller respond

00:09:09,519 --> 00:09:12,320
we call it a

00:09:13,920 --> 00:09:19,120
remote uh method invocation so

00:09:16,959 --> 00:09:20,560
it has a special syntax for it as well

00:09:19,120 --> 00:09:23,360
this error notation

00:09:20,560 --> 00:09:25,440
then the uh the runtime knows that we're

00:09:23,360 --> 00:09:28,160
actually doing a network call

00:09:25,440 --> 00:09:30,480
from the language so this this

00:09:28,160 --> 00:09:33,839
information can be used to

00:09:30,480 --> 00:09:35,200
do certain optimizations uh in network

00:09:33,839 --> 00:09:38,160
communication

00:09:35,200 --> 00:09:39,760
and also other aspects such as automatic

00:09:38,160 --> 00:09:44,480
observability and so on

00:09:39,760 --> 00:09:44,480
uh that i'll show later as well

00:09:44,800 --> 00:09:52,000
so here i'm going to use some connectors

00:09:48,800 --> 00:09:53,680
with our banner service so here

00:09:52,000 --> 00:09:55,279
uh there's a simple scenario where i'm

00:09:53,680 --> 00:09:58,959
going to use an amazon service

00:09:55,279 --> 00:10:03,200
dimension recognition service to do some

00:09:58,959 --> 00:10:06,160
image analysis and and return that

00:10:03,200 --> 00:10:06,800
response back to the client so let's see

00:10:06,160 --> 00:10:09,600
how

00:10:06,800 --> 00:10:09,600
we can do that

00:10:12,000 --> 00:10:17,600
so let's so actually it's going to be

00:10:14,320 --> 00:10:20,560
like a ocr operation so

00:10:17,600 --> 00:10:21,760
let's name our service ocr service so we

00:10:20,560 --> 00:10:26,320
are going to do some

00:10:21,760 --> 00:10:26,320
processing and

00:10:26,880 --> 00:10:30,880
so for this we are going to import a

00:10:31,200 --> 00:10:36,640
a module for the client

00:10:34,959 --> 00:10:39,760
uh where the client is act for the

00:10:36,640 --> 00:10:39,760
amazon account service

00:10:41,839 --> 00:10:47,360
so it's called amazon recognition okay

00:10:45,680 --> 00:10:48,880
so the first thing we have to do is

00:10:47,360 --> 00:10:52,160
create

00:10:48,880 --> 00:10:52,160
the configuration for this

00:10:56,240 --> 00:10:59,839
so we just can just create attributes

00:10:58,880 --> 00:11:01,760
and the

00:10:59,839 --> 00:11:03,200
required ones are the access key and the

00:11:01,760 --> 00:11:05,519
secret key

00:11:03,200 --> 00:11:07,440
so here i'm just going to use uh

00:11:05,519 --> 00:11:08,000
wellness config api to read in these

00:11:07,440 --> 00:11:10,640
values

00:11:08,000 --> 00:11:11,440
so that can be read from a configuration

00:11:10,640 --> 00:11:16,240
file

00:11:11,440 --> 00:11:16,240
or from environment variables so

00:11:16,720 --> 00:11:20,720
here i actually have my api keys and the

00:11:19,519 --> 00:11:23,279
secret

00:11:20,720 --> 00:11:23,760
uh the key and the secret values in a

00:11:23,279 --> 00:11:26,800
file

00:11:23,760 --> 00:11:29,279
here in callback fonts so i'm going to

00:11:26,800 --> 00:11:31,440
read from that

00:11:29,279 --> 00:11:33,760
so i have two properties called ak and

00:11:31,440 --> 00:11:33,760
sk

00:11:38,560 --> 00:11:43,680
so now my configuration is initialized

00:11:41,200 --> 00:11:46,079
so then the next part is creating the

00:11:43,680 --> 00:11:46,079
client

00:11:52,959 --> 00:11:57,839
so now we have the client ready as well

00:11:58,240 --> 00:12:01,839
so then for the client what we have to

00:12:00,639 --> 00:12:04,959
send is

00:12:01,839 --> 00:12:08,000
the binary payload that is sent to this

00:12:04,959 --> 00:12:12,160
resource function so the first thing is

00:12:08,000 --> 00:12:12,160
let's extract the binary payload

00:12:13,360 --> 00:12:20,959
we can say okay final payload

00:12:17,440 --> 00:12:20,959
and this is available here

00:12:22,240 --> 00:12:25,519
then we call the necessary remote method

00:12:24,560 --> 00:12:28,240
invocation

00:12:25,519 --> 00:12:30,000
so called detect text i give in the

00:12:28,240 --> 00:12:32,320
payload

00:12:30,000 --> 00:12:32,320
then

00:12:33,839 --> 00:12:39,839
you get the message from the detect text

00:12:42,000 --> 00:12:50,320
and we'll directly send it out

00:12:45,120 --> 00:12:50,320
to the client so we do a respond

00:12:50,480 --> 00:12:53,839
with the message

00:12:56,320 --> 00:12:59,360
so that's it

00:12:59,920 --> 00:13:04,240
for that uh that's the full

00:13:04,839 --> 00:13:08,399
implementation

00:13:06,000 --> 00:13:08,399
and

00:13:09,440 --> 00:13:12,480
let's run this and see

00:13:19,200 --> 00:13:23,279
okay now the service is up and running

00:13:23,440 --> 00:13:28,000
we'll send it an image so this is the

00:13:26,320 --> 00:13:30,160
image we are going to send

00:13:28,000 --> 00:13:32,720
and the expectation is this text would

00:13:30,160 --> 00:13:34,320
be examined from that remote service and

00:13:32,720 --> 00:13:38,160
we'll get the text the

00:13:34,320 --> 00:13:38,160
the text payload back

00:13:47,360 --> 00:13:51,440
so this is the curl command we have to

00:13:49,199 --> 00:13:51,440
use

00:13:52,399 --> 00:13:56,399
so we are sending the binary payload

00:13:54,160 --> 00:13:58,079
from a curl command and yes

00:13:56,399 --> 00:13:59,920
so you can see here we got the text

00:13:58,079 --> 00:14:03,120
response back

00:13:59,920 --> 00:14:06,880
uh from our back-end service

00:14:03,120 --> 00:14:08,639
so we can see here uh from the client

00:14:06,880 --> 00:14:12,240
to our banner service we do the remote

00:14:08,639 --> 00:14:15,040
method uh invocation and we send it back

00:14:12,240 --> 00:14:16,079
and as i said uh so the banner knows

00:14:15,040 --> 00:14:19,920
about these

00:14:16,079 --> 00:14:22,320
network endpoints and these are used

00:14:19,920 --> 00:14:24,000
in various in various aspects of the

00:14:22,320 --> 00:14:27,279
language

00:14:24,000 --> 00:14:30,399
so certain optimizations and also

00:14:27,279 --> 00:14:31,040
another unique part is uh this can be

00:14:30,399 --> 00:14:35,360
used

00:14:31,040 --> 00:14:35,360
uh for visualizing our code

00:14:35,760 --> 00:14:39,279
as sequence diagrams so the baron

00:14:38,000 --> 00:14:42,320
language

00:14:39,279 --> 00:14:46,639
is um from bottom up designed

00:14:42,320 --> 00:14:49,279
in order to be compatible with a

00:14:46,639 --> 00:14:50,240
sequence diagram concept so all the code

00:14:49,279 --> 00:14:52,800
will write here

00:14:50,240 --> 00:14:54,000
are by default one to one map about uh

00:14:52,800 --> 00:14:57,600
to a sequence diagram

00:14:54,000 --> 00:15:01,040
so in in the vs

00:14:57,600 --> 00:15:03,680
code so we can

00:15:01,040 --> 00:15:04,959
if we create the click this icon it

00:15:03,680 --> 00:15:08,720
automatically

00:15:04,959 --> 00:15:11,360
give you the sequence diagram view

00:15:08,720 --> 00:15:12,880
of the code you have just written as you

00:15:11,360 --> 00:15:16,480
can see here

00:15:12,880 --> 00:15:19,680
uh it contains all the actors the

00:15:16,480 --> 00:15:23,040
uh and the remote

00:15:19,680 --> 00:15:25,040
endpoints uh in their own lifeline

00:15:23,040 --> 00:15:26,240
so when you do a remote invocation like

00:15:25,040 --> 00:15:29,519
the detect text

00:15:26,240 --> 00:15:32,240
remote method location it's

00:15:29,519 --> 00:15:32,240
sent as a

00:15:32,880 --> 00:15:39,600
remote message between these lifelines

00:15:36,399 --> 00:15:41,600
so you can clearly see the interactions

00:15:39,600 --> 00:15:44,000
between

00:15:41,600 --> 00:15:45,199
the actors that are there in the system

00:15:44,000 --> 00:15:48,639
so especially when you have a

00:15:45,199 --> 00:15:51,680
complicated scenario it's very easy to

00:15:48,639 --> 00:15:54,480
see what's happening so

00:15:51,680 --> 00:15:56,800
for example i'll quickly modify this to

00:15:54,480 --> 00:16:00,160
have some

00:15:56,800 --> 00:16:02,480
uh conditional branches as well

00:16:00,160 --> 00:16:04,160
so i'll just do this error handling

00:16:02,480 --> 00:16:09,839
explicitly

00:16:04,160 --> 00:16:09,839
let's say if there is an array

00:16:15,519 --> 00:16:19,759
you can see here you can see clearly see

00:16:18,560 --> 00:16:21,440
from the statement

00:16:19,759 --> 00:16:23,440
these are the different branches here

00:16:21,440 --> 00:16:26,160
and so on so it's

00:16:23,440 --> 00:16:27,199
uh in a high level you can very easily

00:16:26,160 --> 00:16:27,680
understand the code that you have

00:16:27,199 --> 00:16:30,880
written

00:16:27,680 --> 00:16:37,839
so it becomes self-documenting code

00:16:30,880 --> 00:16:37,839
with this with this mapping

00:16:46,480 --> 00:16:50,399
and we'll quickly go through some other

00:16:49,839 --> 00:16:51,759
uh

00:16:50,399 --> 00:16:55,440
prominent features of the language as

00:16:51,759 --> 00:16:57,839
well so starting from uh concurrency

00:16:55,440 --> 00:17:00,480
in ballerina so we have a unique

00:16:57,839 --> 00:17:03,839
concurrency model

00:17:00,480 --> 00:17:08,079
based on something called strands

00:17:03,839 --> 00:17:11,600
strand is like a lightweight thread uh

00:17:08,079 --> 00:17:15,120
construct uh in ballerina and

00:17:11,600 --> 00:17:16,839
a worker is basically the realization of

00:17:15,120 --> 00:17:19,839
a strand

00:17:16,839 --> 00:17:21,120
so in a in a specific function we can

00:17:19,839 --> 00:17:25,199
have multiple workers

00:17:21,120 --> 00:17:30,480
for uh specifying uh

00:17:25,199 --> 00:17:30,480
concurrent executions and also

00:17:30,559 --> 00:17:34,160
communication between these workers are

00:17:32,320 --> 00:17:37,200
done using message parsing

00:17:34,160 --> 00:17:40,400
so as you can see here uh we can say

00:17:37,200 --> 00:17:43,440
certain we can define certain uh data

00:17:40,400 --> 00:17:45,600
variables here and say send this to the

00:17:43,440 --> 00:17:49,600
other worker and so on

00:17:45,600 --> 00:17:51,760
and from the compiler we

00:17:49,600 --> 00:17:53,600
automatically check uh these

00:17:51,760 --> 00:17:56,880
interactions we validate them

00:17:53,600 --> 00:17:59,039
in order to make sure that they don't uh

00:17:56,880 --> 00:18:00,000
result in deadlocks or anything like

00:17:59,039 --> 00:18:02,960
that

00:18:00,000 --> 00:18:04,799
and if you find that these contractions

00:18:02,960 --> 00:18:08,160
are not compatible with given compiler

00:18:04,799 --> 00:18:10,960
saying that

00:18:08,160 --> 00:18:11,360
this should be fixed and as you can see

00:18:10,960 --> 00:18:12,720
here

00:18:11,360 --> 00:18:14,640
from the sequence diagram also we

00:18:12,720 --> 00:18:16,880
clearly show how the

00:18:14,640 --> 00:18:18,880
message interactions are done with the

00:18:16,880 --> 00:18:21,280
multiple workers that are executing

00:18:18,880 --> 00:18:21,280
parallel

00:18:24,240 --> 00:18:30,160
also we

00:18:27,360 --> 00:18:31,039
uh support futures as well so we can get

00:18:30,160 --> 00:18:34,320
any

00:18:31,039 --> 00:18:35,280
uh function and make it run

00:18:34,320 --> 00:18:37,919
asynchronously

00:18:35,280 --> 00:18:39,200
so we can use the start keyword and we

00:18:37,919 --> 00:18:42,080
can run that

00:18:39,200 --> 00:18:43,760
and we get a future construct back which

00:18:42,080 --> 00:18:46,480
represents the

00:18:43,760 --> 00:18:47,600
the future value we will be getting so

00:18:46,480 --> 00:18:50,880
then we can

00:18:47,600 --> 00:18:53,280
later on wait on the future to

00:18:50,880 --> 00:18:56,080
finish the synchronous operation from

00:18:53,280 --> 00:18:58,720
executing and get the value

00:18:56,080 --> 00:19:00,880
so in that way we can model our

00:18:58,720 --> 00:19:03,760
operations

00:19:00,880 --> 00:19:03,760
in that manner as well

00:19:04,640 --> 00:19:08,000
and also that something that ties in

00:19:07,039 --> 00:19:11,200
with the

00:19:08,000 --> 00:19:12,559
concurrency model is also uh the input

00:19:11,200 --> 00:19:15,679
output subsystem

00:19:12,559 --> 00:19:19,600
so here uh in parana

00:19:15,679 --> 00:19:22,960
everything happens in an in an

00:19:19,600 --> 00:19:25,919
unblocking manner the i operations

00:19:22,960 --> 00:19:26,480
so we do that in a transparent manner

00:19:25,919 --> 00:19:30,000
where

00:19:26,480 --> 00:19:30,000
in our code uh

00:19:30,960 --> 00:19:34,480
the coding style will actually look like

00:19:32,640 --> 00:19:36,799
a blocking code

00:19:34,480 --> 00:19:39,440
call when we do calls like from our http

00:19:36,799 --> 00:19:43,200
client when we if we do like a get

00:19:39,440 --> 00:19:45,679
get request to a remote endpoint

00:19:43,200 --> 00:19:47,440
um so this looks like a typical blocking

00:19:45,679 --> 00:19:51,039
call but what happens

00:19:47,440 --> 00:19:54,240
uh in ballerina is in our

00:19:51,039 --> 00:19:57,120
time um we

00:19:54,240 --> 00:19:58,080
uh automatically suspend the execution

00:19:57,120 --> 00:20:01,360
strand that

00:19:58,080 --> 00:20:03,360
the exclusion context and we give the

00:20:01,360 --> 00:20:05,440
processing of the io operation

00:20:03,360 --> 00:20:07,520
to the operating system and only when

00:20:05,440 --> 00:20:11,280
that i operation is done

00:20:07,520 --> 00:20:14,320
we resume our strand so

00:20:11,280 --> 00:20:16,799
no operating system level

00:20:14,320 --> 00:20:18,720
threads are blocked in that manner so

00:20:16,799 --> 00:20:20,720
those are immediately released when we

00:20:18,720 --> 00:20:23,200
do those kind of operations

00:20:20,720 --> 00:20:24,720
and only when it's uh when our openings

00:20:23,200 --> 00:20:27,520
are done they resume

00:20:24,720 --> 00:20:28,559
uh with the video with the physical

00:20:27,520 --> 00:20:31,520
thread

00:20:28,559 --> 00:20:32,640
so this uh so in other typical program

00:20:31,520 --> 00:20:36,159
language we have to

00:20:32,640 --> 00:20:39,200
handle this on now on by using

00:20:36,159 --> 00:20:42,320
other callback mechanisms and so on but

00:20:39,200 --> 00:20:44,559
here we have we have done that in the

00:20:42,320 --> 00:20:47,600
language itself

00:20:44,559 --> 00:20:50,559
in the runtime and

00:20:47,600 --> 00:20:52,480
so in that way so the users get a

00:20:50,559 --> 00:20:56,559
familiar programming model to use

00:20:52,480 --> 00:21:02,080
uh to use uh these unlocking i o

00:20:56,559 --> 00:21:05,360
features as well

00:21:02,080 --> 00:21:07,360
so then uh let's move into uh like the

00:21:05,360 --> 00:21:10,640
docker community support we have

00:21:07,360 --> 00:21:14,440
uh in ballerina so uh

00:21:10,640 --> 00:21:18,000
in the in the cloud native um uh

00:21:14,440 --> 00:21:21,520
programming uh concepts so

00:21:18,000 --> 00:21:24,720
uh containerization is uh

00:21:21,520 --> 00:21:27,520
is critical and with that we need

00:21:24,720 --> 00:21:29,520
um container orchestration as well so

00:21:27,520 --> 00:21:32,640
document communities are

00:21:29,520 --> 00:21:34,880
leading technologies that that are used

00:21:32,640 --> 00:21:38,240
for those things

00:21:34,880 --> 00:21:40,799
so naturally barona also

00:21:38,240 --> 00:21:42,840
has inbuilt support for these

00:21:40,799 --> 00:21:46,400
technologies

00:21:42,840 --> 00:21:47,360
so basically uh we can take one of our

00:21:46,400 --> 00:21:51,520
services

00:21:47,360 --> 00:21:54,559
and uh automatically make it compatible

00:21:51,520 --> 00:21:56,320
uh with a container deployment and in a

00:21:54,559 --> 00:21:59,919
deployment like communities

00:21:56,320 --> 00:22:00,559
so let's see how we can convert our

00:21:59,919 --> 00:22:03,840
earlier

00:22:00,559 --> 00:22:08,320
scenario to be able to uh deploy

00:22:03,840 --> 00:22:08,320
in uh kubernetes as well

00:22:09,120 --> 00:22:15,600
so um so we have to do uh

00:22:12,240 --> 00:22:18,559
some minor uh changes to the

00:22:15,600 --> 00:22:20,159
record here so we are not changing the

00:22:18,559 --> 00:22:22,880
business logic of course

00:22:20,159 --> 00:22:25,600
so we are just going to annotate our

00:22:22,880 --> 00:22:29,039
service saying

00:22:25,600 --> 00:22:32,480
okay uh deploy these uh

00:22:29,039 --> 00:22:32,480
in a community's environment

00:22:33,440 --> 00:22:39,200
so we first do this by saying

00:22:37,520 --> 00:22:41,840
by adding a kubernetes deployment

00:22:39,200 --> 00:22:41,840
annotation

00:22:44,799 --> 00:22:51,280
and also we have to say okay

00:22:48,640 --> 00:22:53,520
expose this as a community service as

00:22:51,280 --> 00:22:53,520
well

00:22:53,679 --> 00:23:00,640
and we can give other uh parameters like

00:22:58,559 --> 00:23:01,679
the service type and so on so you can

00:23:00,640 --> 00:23:03,760
give like uh

00:23:01,679 --> 00:23:06,799
this is exposed as not port or load

00:23:03,760 --> 00:23:06,799
balancer and so on

00:23:07,200 --> 00:23:14,159
and we can also give

00:23:10,640 --> 00:23:16,960
other uh extended uh

00:23:14,159 --> 00:23:16,960
information like

00:23:17,440 --> 00:23:21,440
we can say a config map like for example

00:23:20,559 --> 00:23:23,760
we'll need

00:23:21,440 --> 00:23:26,000
that here because we are passing in uh

00:23:23,760 --> 00:23:29,440
external configuration properties

00:23:26,000 --> 00:23:30,080
for our services so here i'm going to

00:23:29,440 --> 00:23:36,960
give

00:23:30,080 --> 00:23:40,080
my configuration file as a config map

00:23:36,960 --> 00:23:42,240
and so these are the

00:23:40,080 --> 00:23:44,799
uh basically the the annotations we'll

00:23:42,240 --> 00:23:48,400
need in order to deploy this in

00:23:44,799 --> 00:23:52,080
uh in kubernetes so let's see

00:23:48,400 --> 00:23:54,640
uh how this is done

00:23:52,080 --> 00:23:56,480
so now we just have to go and do a burn

00:23:54,640 --> 00:23:59,200
up build on the source file

00:23:56,480 --> 00:24:00,240
so this is the so here we are just doing

00:23:59,200 --> 00:24:02,320
the build step

00:24:00,240 --> 00:24:04,559
rather than doing a run where we just

00:24:02,320 --> 00:24:07,440
build and run at the same time

00:24:04,559 --> 00:24:08,720
so what happens is in this time the

00:24:07,440 --> 00:24:12,240
compiler

00:24:08,720 --> 00:24:14,320
sees that we have these annotations

00:24:12,240 --> 00:24:16,840
oops

00:24:14,320 --> 00:24:19,840
[Music]

00:24:16,840 --> 00:24:19,840
okay

00:24:22,480 --> 00:24:26,159
so here the compile will see that i have

00:24:24,559 --> 00:24:27,360
these kubernetes annotations and it

00:24:26,159 --> 00:24:30,720
engages a

00:24:27,360 --> 00:24:32,799
compile extension to work on these

00:24:30,720 --> 00:24:34,400
aspects so what we'll do is it will

00:24:32,799 --> 00:24:36,960
automatically create

00:24:34,400 --> 00:24:38,640
things like the docker image and also

00:24:36,960 --> 00:24:41,520
kubernetes artifacts

00:24:38,640 --> 00:24:44,240
and provides us with a with the final

00:24:41,520 --> 00:24:46,240
command that we had

00:24:44,240 --> 00:24:48,880
execute in order to deploy this in

00:24:46,240 --> 00:24:48,880
kubernetes

00:24:50,480 --> 00:24:53,679
so let me run that

00:24:58,880 --> 00:25:06,159
okay so we can see uh now the

00:25:02,960 --> 00:25:08,559
uh our artifacts are deployed

00:25:06,159 --> 00:25:09,200
uh using the queen uh using the

00:25:08,559 --> 00:25:12,320
companies

00:25:09,200 --> 00:25:16,720
the config so we can check that by

00:25:12,320 --> 00:25:20,480
doing group ctl get pods you can see

00:25:16,720 --> 00:25:23,760
the pot is deployed and

00:25:20,480 --> 00:25:26,840
you can check for our service as well

00:25:23,760 --> 00:25:28,320
and you can see here our service is also

00:25:26,840 --> 00:25:31,440
deployed

00:25:28,320 --> 00:25:34,000
and we should be able to contact it

00:25:31,440 --> 00:25:34,000
through here

00:25:34,480 --> 00:25:43,840
so let's do a

00:25:37,840 --> 00:25:43,840
curl request for that as well

00:25:46,720 --> 00:25:50,400
okay the port is

00:25:54,559 --> 00:25:57,840
six three

00:25:58,640 --> 00:26:01,919
two three six three

00:26:03,600 --> 00:26:07,360
and now the request is going uh through

00:26:06,480 --> 00:26:09,840
the

00:26:07,360 --> 00:26:12,559
kuni setup and we can see we got the

00:26:09,840 --> 00:26:16,559
response back as well

00:26:12,559 --> 00:26:20,000
so now we basically used

00:26:16,559 --> 00:26:23,039
uh the kubernetes service that's

00:26:20,000 --> 00:26:26,799
exposed to northport

00:26:23,039 --> 00:26:29,520
and we sent a request and we got the

00:26:26,799 --> 00:26:29,520
response back

00:26:30,159 --> 00:26:33,520
so basically in the same way you can

00:26:32,320 --> 00:26:36,480
deploy to

00:26:33,520 --> 00:26:39,360
any kubernetes cluster as well like any

00:26:36,480 --> 00:26:42,400
hostel solution like in

00:26:39,360 --> 00:26:45,760
aws uh azure cloud

00:26:42,400 --> 00:26:48,799
uh and so on so it's just a matter of uh

00:26:45,760 --> 00:26:51,039
pointing your group ctl the group config

00:26:48,799 --> 00:26:52,159
and it'll be the same commands that you

00:26:51,039 --> 00:26:56,000
have to

00:26:52,159 --> 00:26:56,000
use to deploy the application

00:26:58,559 --> 00:27:03,279
so let's go to the next section

00:27:04,840 --> 00:27:08,799
um

00:27:06,720 --> 00:27:10,799
that's uh so i'll quickly go through

00:27:08,799 --> 00:27:12,960
some of the serverless uh features also

00:27:10,799 --> 00:27:16,880
we have in ballerina

00:27:12,960 --> 00:27:20,159
uh starting from mirabis lambda so

00:27:16,880 --> 00:27:22,399
uh in the same way as we did the

00:27:20,159 --> 00:27:24,080
kubernetes deployment it's just a matter

00:27:22,399 --> 00:27:27,440
of uh annotating

00:27:24,080 --> 00:27:29,520
a banner function and

00:27:27,440 --> 00:27:33,039
and will the compiler will automatically

00:27:29,520 --> 00:27:36,080
generate the required artifacts to

00:27:33,039 --> 00:27:36,080
to do the deployments

00:27:36,799 --> 00:27:43,200
so i'll quickly show an example of that

00:27:41,120 --> 00:27:44,320
uh so i already have a function a simple

00:27:43,200 --> 00:27:48,480
one where

00:27:44,320 --> 00:27:51,360
i'm generating a uuid and returning it

00:27:48,480 --> 00:27:53,679
and here also if you just do a burnout

00:27:51,360 --> 00:27:56,880
build

00:27:53,679 --> 00:27:58,000
um the compiler understands that i have

00:27:56,880 --> 00:28:03,679
annotated

00:27:58,000 --> 00:28:08,240
it saying spn aws lambda function

00:28:03,679 --> 00:28:10,320
and it creates the required the zip file

00:28:08,240 --> 00:28:12,880
and i can just deploy that using the

00:28:10,320 --> 00:28:16,320
wcli commands

00:28:12,880 --> 00:28:19,039
so here this

00:28:16,320 --> 00:28:20,799
the command is uh given here with some

00:28:19,039 --> 00:28:23,679
placeholder variable names

00:28:20,799 --> 00:28:25,039
that i should use for the functions so

00:28:23,679 --> 00:28:26,720
if you have multiple functions

00:28:25,039 --> 00:28:29,600
those will be listed here as well so

00:28:26,720 --> 00:28:32,960
other ones so here i only have

00:28:29,600 --> 00:28:36,799
one so

00:28:32,960 --> 00:28:36,799
i'll just say uuid

00:28:38,880 --> 00:28:42,320
and i'll just

00:28:42,559 --> 00:28:46,960
make sure the function is not there

00:28:44,480 --> 00:28:46,960
anymore

00:28:53,520 --> 00:28:55,840
okay

00:28:57,360 --> 00:29:00,399
so let's

00:29:01,679 --> 00:29:13,840
try this

00:29:32,320 --> 00:29:37,360
okay i have not set that value so let me

00:29:37,919 --> 00:29:41,840
set my lambda

00:29:42,000 --> 00:29:55,840
as well

00:29:57,600 --> 00:30:00,880
and also my region

00:30:02,240 --> 00:30:06,159
okay now we have all the parameters

00:30:04,159 --> 00:30:07,919
required

00:30:06,159 --> 00:30:10,559
this should be able to deploy the

00:30:07,919 --> 00:30:10,559
function now

00:30:12,399 --> 00:30:23,840
okay now the function is deployed let's

00:30:15,120 --> 00:30:23,840
try to do an invoke from the cli itself

00:30:31,840 --> 00:30:39,200
okay okay the execution is successful

00:30:37,200 --> 00:30:42,799
let's see the payload and we can see

00:30:39,200 --> 00:30:46,799
here we got the response out

00:30:42,799 --> 00:30:46,799
let's do that in a single command

00:30:47,919 --> 00:30:51,840
so you can see here

00:30:55,600 --> 00:30:59,039
these are separate invocations of the

00:30:57,360 --> 00:31:05,760
lambda functions we just deployed

00:30:59,039 --> 00:31:08,640
so uh in that way you can

00:31:05,760 --> 00:31:10,159
create lambdas in this way uh like

00:31:08,640 --> 00:31:12,159
easily using uh

00:31:10,159 --> 00:31:14,559
battery now so you don't have to worry

00:31:12,159 --> 00:31:17,440
about another extra build step

00:31:14,559 --> 00:31:18,080
uh on packaging these artifacts and so

00:31:17,440 --> 00:31:22,399
on that's

00:31:18,080 --> 00:31:22,399
automatically done by the compile itself

00:31:23,120 --> 00:31:29,600
and so

00:31:27,600 --> 00:31:31,760
let's go to the next one so in the same

00:31:29,600 --> 00:31:35,120
way we have

00:31:31,760 --> 00:31:38,240
support for uh asia functions as well

00:31:35,120 --> 00:31:41,279
uh so in a similar manner

00:31:38,240 --> 00:31:44,559
uh an annotation based approach is there

00:31:41,279 --> 00:31:47,840
when you want to define uh those type of

00:31:44,559 --> 00:31:49,340
server functions as well so here i have

00:31:47,840 --> 00:31:50,559
a

00:31:49,340 --> 00:31:52,960
[Music]

00:31:50,559 --> 00:31:54,240
a specific scenario that i have created

00:31:52,960 --> 00:31:58,720
uh

00:31:54,240 --> 00:32:00,960
using the azure functions uh so it's a

00:31:58,720 --> 00:32:01,760
scalable data processing scenario again

00:32:00,960 --> 00:32:05,039
with

00:32:01,760 --> 00:32:08,480
some processing of images where

00:32:05,039 --> 00:32:09,279
uh we take in requests through an http

00:32:08,480 --> 00:32:12,480
request

00:32:09,279 --> 00:32:15,120
and we take in the

00:32:12,480 --> 00:32:16,159
the binary data and an email address and

00:32:15,120 --> 00:32:18,799
we submit

00:32:16,159 --> 00:32:18,799
that to a

00:32:19,200 --> 00:32:23,919
blob storage initiator and also we queue

00:32:22,480 --> 00:32:26,720
those requests

00:32:23,919 --> 00:32:28,399
and using serverless functions we

00:32:26,720 --> 00:32:30,640
process the images

00:32:28,399 --> 00:32:31,840
we put it to other queues and we publish

00:32:30,640 --> 00:32:34,799
them using email

00:32:31,840 --> 00:32:35,440
so um so using of these intermediate

00:32:34,799 --> 00:32:37,200
queues

00:32:35,440 --> 00:32:39,760
and these other storage mechanism is

00:32:37,200 --> 00:32:43,760
used to scale the system

00:32:39,760 --> 00:32:46,640
um so uh we'll just show you how

00:32:43,760 --> 00:32:47,919
uh how we can how easily we can model

00:32:46,640 --> 00:32:49,840
this scenario

00:32:47,919 --> 00:32:51,039
uh using a server scenario uh with

00:32:49,840 --> 00:32:53,760
paradigm

00:32:51,039 --> 00:32:54,960
so this is basically the code that is

00:32:53,760 --> 00:32:59,200
required to do that

00:32:54,960 --> 00:33:02,960
so uh using uh functions um

00:32:59,200 --> 00:33:04,399
bindings uh concept um so input output

00:33:02,960 --> 00:33:07,440
bindings we can

00:33:04,399 --> 00:33:10,559
nicely chain uh

00:33:07,440 --> 00:33:12,640
these requests through multiple stages

00:33:10,559 --> 00:33:15,200
so we can create a workflow

00:33:12,640 --> 00:33:15,760
using this feature so in barana so we

00:33:15,200 --> 00:33:19,679
can

00:33:15,760 --> 00:33:20,000
say through a specific http trigger we

00:33:19,679 --> 00:33:22,960
are

00:33:20,000 --> 00:33:24,000
invoking this function and we can bind

00:33:22,960 --> 00:33:28,000
certain parameters

00:33:24,000 --> 00:33:30,240
to uh storage um

00:33:28,000 --> 00:33:32,799
options like queues job storage and so

00:33:30,240 --> 00:33:35,440
on just by setting values

00:33:32,799 --> 00:33:36,240
uh in the code so we don't have to worry

00:33:35,440 --> 00:33:38,799
about

00:33:36,240 --> 00:33:40,080
uh specific uh service clients being

00:33:38,799 --> 00:33:40,960
initialized here so

00:33:40,080 --> 00:33:43,760
don't need to worry about the

00:33:40,960 --> 00:33:45,200
credentials and everything the api keys

00:33:43,760 --> 00:33:46,559
but rather they are automatically

00:33:45,200 --> 00:33:50,000
handled through the system

00:33:46,559 --> 00:33:53,039
itself so in this way we can as i said

00:33:50,000 --> 00:33:54,720
why are these functions together so we

00:33:53,039 --> 00:33:56,960
can say

00:33:54,720 --> 00:33:58,159
we are setting a specific uh value in a

00:33:56,960 --> 00:34:00,399
queue

00:33:58,159 --> 00:34:01,919
in this function and it's directly bound

00:34:00,399 --> 00:34:04,080
to a

00:34:01,919 --> 00:34:05,200
another function where that function is

00:34:04,080 --> 00:34:07,760
into a

00:34:05,200 --> 00:34:08,320
uh to that queue from here so in this

00:34:07,760 --> 00:34:11,280
way it's

00:34:08,320 --> 00:34:12,639
by it's these two are connected and from

00:34:11,280 --> 00:34:15,919
at the last end

00:34:12,639 --> 00:34:17,359
again uh the results are sent uh through

00:34:15,919 --> 00:34:18,639
another serverless function here by

00:34:17,359 --> 00:34:21,280
sending an email

00:34:18,639 --> 00:34:23,839
so likewise it's a very convenient model

00:34:21,280 --> 00:34:27,280
these operations using this mechanism

00:34:23,839 --> 00:34:29,599
and paragraph makes it easier uh because

00:34:27,280 --> 00:34:30,879
it does all the build steps the

00:34:29,599 --> 00:34:34,800
deployment

00:34:30,879 --> 00:34:36,480
so just by building it

00:34:34,800 --> 00:34:38,480
it will be you will be presented with

00:34:36,480 --> 00:34:41,200
the diplomat artifacts

00:34:38,480 --> 00:34:42,320
then you can use the cli commands or any

00:34:41,200 --> 00:34:45,599
other deployment mechanisms

00:34:42,320 --> 00:34:49,839
to uh deploy it straight to uh

00:34:45,599 --> 00:34:49,839
the azure functions environment

00:34:51,200 --> 00:34:56,480
and also another aspect of

00:34:54,800 --> 00:34:58,480
cloud native and microsoft development

00:34:56,480 --> 00:35:01,119
is continuous

00:34:58,480 --> 00:35:01,599
integration and controller development

00:35:01,119 --> 00:35:04,640
so

00:35:01,599 --> 00:35:07,680
you can use many systems for that um

00:35:04,640 --> 00:35:10,560
like jenkins uh code fresh

00:35:07,680 --> 00:35:12,160
and so on and also we have uh support

00:35:10,560 --> 00:35:13,440
for github actions as well so there's a

00:35:12,160 --> 00:35:15,440
baron github action

00:35:13,440 --> 00:35:16,720
that is available you can you to

00:35:15,440 --> 00:35:19,359
directly uh

00:35:16,720 --> 00:35:21,520
build test button applications and

00:35:19,359 --> 00:35:25,680
direct deploy to an environment

00:35:21,520 --> 00:35:27,200
um that may be a kubernetes cluster

00:35:25,680 --> 00:35:28,800
serverless environment or anything like

00:35:27,200 --> 00:35:30,640
that so

00:35:28,800 --> 00:35:32,320
that can be done using the github

00:35:30,640 --> 00:35:36,079
functions uh

00:35:32,320 --> 00:35:36,079
features we have as well

00:35:36,800 --> 00:35:39,920
and also another critical feature we

00:35:39,280 --> 00:35:42,880
have

00:35:39,920 --> 00:35:44,320
uh is in barina is the building

00:35:42,880 --> 00:35:47,760
observability

00:35:44,320 --> 00:35:49,599
uh so um basically in

00:35:47,760 --> 00:35:51,359
any code we write especially when it

00:35:49,599 --> 00:35:54,560
comes to network

00:35:51,359 --> 00:35:56,240
endpoints um the system

00:35:54,560 --> 00:35:58,320
can automatically observe the operations

00:35:56,240 --> 00:36:01,520
that you do and it can generate

00:35:58,320 --> 00:36:04,240
metrics and tracing information

00:36:01,520 --> 00:36:05,200
uh based on those operations so that's

00:36:04,240 --> 00:36:06,960
where

00:36:05,200 --> 00:36:08,480
operations such as the remote method of

00:36:06,960 --> 00:36:08,960
invocation and so on automatically

00:36:08,480 --> 00:36:10,240
tracked

00:36:08,960 --> 00:36:12,960
because we know they are network

00:36:10,240 --> 00:36:14,320
operations and that can be used for the

00:36:12,960 --> 00:36:18,000
observability features

00:36:14,320 --> 00:36:22,560
the the functionality so we'll uh

00:36:18,000 --> 00:36:22,560
let's quickly do uh

00:36:23,839 --> 00:36:28,720
tracking of our earlier scenario used by

00:36:27,200 --> 00:36:32,320
enabling observability

00:36:28,720 --> 00:36:32,320
on it so

00:36:32,480 --> 00:36:36,320
it's just a matter of enabling

00:36:34,720 --> 00:36:38,240
observability

00:36:36,320 --> 00:36:40,000
when we are running it so we can

00:36:38,240 --> 00:36:43,839
globally say enable observability for

00:36:40,000 --> 00:36:43,839
the full application

00:36:45,119 --> 00:36:49,119
so by giving this runtime switch

00:36:49,440 --> 00:36:53,119
we can save and run and say the observer

00:36:52,320 --> 00:36:56,880
enabled is

00:36:53,119 --> 00:37:00,640
true and when you do that

00:36:56,880 --> 00:37:03,760
it starts an internal endpoint for

00:37:00,640 --> 00:37:06,640
uh uh for exposing

00:37:03,760 --> 00:37:07,520
metrics using uh for prometheus so from

00:37:06,640 --> 00:37:10,720
this

00:37:07,520 --> 00:37:14,160
server can connect to this endpoint and

00:37:10,720 --> 00:37:17,839
pull matrix information and also it

00:37:14,160 --> 00:37:18,400
starts up publishers for tracers based

00:37:17,839 --> 00:37:21,520
on the open

00:37:18,400 --> 00:37:24,640
open api standard

00:37:21,520 --> 00:37:28,400
uh sorry open tracing

00:37:24,640 --> 00:37:31,280
api rather so

00:37:28,400 --> 00:37:31,280
here by default

00:37:32,000 --> 00:37:35,359
uh we have we are shipping a jaeger

00:37:34,079 --> 00:37:37,440
client

00:37:35,359 --> 00:37:38,880
so you can directly connect to that uh

00:37:37,440 --> 00:37:42,560
to send uh

00:37:38,880 --> 00:37:45,599
tracing information and so here

00:37:42,560 --> 00:37:48,240
let's start up a

00:37:45,599 --> 00:37:50,400
promise server a jaeger and also a

00:37:48,240 --> 00:37:54,079
graphana for

00:37:50,400 --> 00:37:56,480
visualizing our metric information

00:37:54,079 --> 00:37:58,240
so for this scenario i'm going to start

00:37:56,480 --> 00:38:01,280
the servers using docker

00:37:58,240 --> 00:38:04,000
so that's

00:38:01,280 --> 00:38:06,480
just the easiest way to get things up

00:38:04,000 --> 00:38:11,040
and running quickly

00:38:06,480 --> 00:38:11,040
so i have the commands here

00:38:11,119 --> 00:38:16,400
so starting from prometheus grafana

00:38:17,680 --> 00:38:20,480
and yeah

00:38:26,079 --> 00:38:32,400
and let's send some requests just to

00:38:29,359 --> 00:38:37,040
populate uh

00:38:32,400 --> 00:38:40,480
the metric stores and the tracing

00:38:37,040 --> 00:38:42,720
information so

00:38:40,480 --> 00:38:42,720
now

00:38:45,040 --> 00:38:48,400
let's start up grafana

00:38:52,400 --> 00:38:57,200
the first thing is to add the data

00:38:54,880 --> 00:38:57,200
source

00:38:57,359 --> 00:39:01,839
so it will be prometheus and fine

00:39:08,320 --> 00:39:15,839
okay we added the

00:39:12,079 --> 00:39:15,839
data source then

00:39:15,920 --> 00:39:21,760
we import the dashboard so there's a

00:39:19,760 --> 00:39:23,200
default uh banner dashboard that uh that

00:39:21,760 --> 00:39:29,280
is already available

00:39:23,200 --> 00:39:31,599
with the default uh dashboards

00:39:29,280 --> 00:39:32,880
and right away we'll be we are seeing

00:39:31,599 --> 00:39:34,960
the stats

00:39:32,880 --> 00:39:36,960
from the request that were already sent

00:39:34,960 --> 00:39:38,640
and we get information like the http

00:39:36,960 --> 00:39:41,359
service metrics

00:39:38,640 --> 00:39:43,040
uh the request per minute the rates the

00:39:41,359 --> 00:39:46,560
error rates

00:39:43,040 --> 00:39:47,599
and so on and we have many graphs to see

00:39:46,560 --> 00:39:50,480
the service status

00:39:47,599 --> 00:39:52,720
and so on and also same is available for

00:39:50,480 --> 00:39:56,000
http client matrix as well

00:39:52,720 --> 00:39:57,599
and also other things such as when you

00:39:56,000 --> 00:39:59,040
have database operations like square

00:39:57,599 --> 00:40:02,960
client matrix

00:39:59,040 --> 00:40:04,880
and so on so obviously these

00:40:02,960 --> 00:40:06,720
dashboards can be updated as well so

00:40:04,880 --> 00:40:10,720
these are the default ones you will

00:40:06,720 --> 00:40:14,480
be getting so then let's

00:40:10,720 --> 00:40:16,070
uh move on to the tracing view as well

00:40:14,480 --> 00:40:17,760
so that's in

00:40:16,070 --> 00:40:20,319
[Music]

00:40:17,760 --> 00:40:20,319
jaeger

00:40:22,240 --> 00:40:26,240
so here we have our service ocr service

00:40:25,040 --> 00:40:28,560
so when you save

00:40:26,240 --> 00:40:30,160
find tracer so it has the two requests

00:40:28,560 --> 00:40:34,079
we sent

00:40:30,160 --> 00:40:39,359
and we see the tracing information uh

00:40:34,079 --> 00:40:43,040
to the spans that were collected

00:40:39,359 --> 00:40:44,960
so here there's only one service and it

00:40:43,040 --> 00:40:46,880
you can drill down to multiple aspects

00:40:44,960 --> 00:40:49,520
uh the operations that were

00:40:46,880 --> 00:40:50,720
executed in that so we can say starting

00:40:49,520 --> 00:40:53,280
from the

00:40:50,720 --> 00:40:54,960
edited text remote method and the

00:40:53,280 --> 00:40:58,319
internal hd clients that were used

00:40:54,960 --> 00:40:59,760
the post request and so on so obviously

00:40:58,319 --> 00:41:00,720
when you have multiple services it will

00:40:59,760 --> 00:41:03,359
show you the

00:41:00,720 --> 00:41:03,839
connection between the multiple services

00:41:03,359 --> 00:41:06,800
where

00:41:03,839 --> 00:41:07,760
it attracts all the hops through the

00:41:06,800 --> 00:41:10,319
network

00:41:07,760 --> 00:41:10,880
through like collision id that's shared

00:41:10,319 --> 00:41:14,319
among

00:41:10,880 --> 00:41:18,079
uh shared through the single

00:41:14,319 --> 00:41:20,480
round trip request

00:41:18,079 --> 00:41:21,680
so in that way you can drill down into

00:41:20,480 --> 00:41:22,400
what's happening in the network the

00:41:21,680 --> 00:41:26,000
request

00:41:22,400 --> 00:41:29,040
uh so especially useful when you are

00:41:26,000 --> 00:41:31,520
debugging your system or doing

00:41:29,040 --> 00:41:34,800
performance improvements

00:41:31,520 --> 00:41:38,079
um so basically that's how you get the

00:41:34,800 --> 00:41:40,319
uh the uh default

00:41:38,079 --> 00:41:41,599
um out of the box observable in

00:41:40,319 --> 00:41:44,400
ballerina so

00:41:41,599 --> 00:41:45,119
it tracks all the default uh operations

00:41:44,400 --> 00:41:47,440
so

00:41:45,119 --> 00:41:49,119
like 95 of the time that will be enough

00:41:47,440 --> 00:41:52,319
for the general cases

00:41:49,119 --> 00:41:55,359
uh where all the network operations and

00:41:52,319 --> 00:41:58,240
uh other actions are

00:41:55,359 --> 00:41:59,440
by default monitor uh and of course when

00:41:58,240 --> 00:42:02,240
you have some custom

00:41:59,440 --> 00:42:03,920
enrichment to be done you can use the

00:42:02,240 --> 00:42:06,720
observable use api

00:42:03,920 --> 00:42:09,599
to add some additional events or add

00:42:06,720 --> 00:42:09,599
more properties as well

00:42:11,760 --> 00:42:15,359
so there is a screenshot of when we have

00:42:14,400 --> 00:42:18,160
multiple

00:42:15,359 --> 00:42:21,200
services running the system like how the

00:42:18,160 --> 00:42:21,200
tracing ui would be

00:42:21,359 --> 00:42:25,920
so this is what we saw with

00:42:22,720 --> 00:42:25,920
probabilities and graphana

00:42:26,000 --> 00:42:31,760
and also um so bernard supports uh open

00:42:30,000 --> 00:42:35,119
api as well uh

00:42:31,760 --> 00:42:37,760
so that's uh uh standard that

00:42:35,119 --> 00:42:37,760
uh uh

00:42:38,160 --> 00:42:41,280
it was called struggle earlier basically

00:42:39,599 --> 00:42:44,880
so it's now open api

00:42:41,280 --> 00:42:47,839
so that can be used to define services

00:42:44,880 --> 00:42:48,319
in ballerina so starting from a swagger

00:42:47,839 --> 00:42:51,680
to

00:42:48,319 --> 00:42:52,880
create a burner service skeletons and

00:42:51,680 --> 00:42:55,680
stubs

00:42:52,880 --> 00:42:57,119
and also for creating clients as well so

00:42:55,680 --> 00:43:00,160
using the command line cli

00:42:57,119 --> 00:43:02,720
you can create this so invoke these

00:43:00,160 --> 00:43:02,720
operations

00:43:03,839 --> 00:43:07,760
so um and then for uh if you want to

00:43:07,119 --> 00:43:10,880
learn

00:43:07,760 --> 00:43:13,280
more about ballerina so in the banner by

00:43:10,880 --> 00:43:14,480
bernard website so we have a banner by

00:43:13,280 --> 00:43:17,920
example

00:43:14,480 --> 00:43:20,160
page where it goes through goes through

00:43:17,920 --> 00:43:23,359
the prominent language features

00:43:20,160 --> 00:43:24,240
uh through multiple examples so you can

00:43:23,359 --> 00:43:25,920
run them

00:43:24,240 --> 00:43:28,880
and learn how their work so they are

00:43:25,920 --> 00:43:31,359
commended examples step by step

00:43:28,880 --> 00:43:32,800
uh that's a quick way of uh getting the

00:43:31,359 --> 00:43:36,400
hang of the language

00:43:32,800 --> 00:43:40,000
um so verona is very similar to

00:43:36,400 --> 00:43:43,920
like uh syntax is similar

00:43:40,000 --> 00:43:48,000
to languages like uh c c plus or java

00:43:43,920 --> 00:43:49,440
uh so that type of uh syntax is there so

00:43:48,000 --> 00:43:50,480
it will be familiar to most of the

00:43:49,440 --> 00:43:54,400
people who have used

00:43:50,480 --> 00:43:56,720
uh similar languages other specialized

00:43:54,400 --> 00:44:00,079
concepts you can learn through the

00:43:56,720 --> 00:44:00,079
resources that are there in the website

00:44:01,040 --> 00:44:09,760
and also for beginners for program

00:44:05,520 --> 00:44:12,000
beginners who are new programming

00:44:09,760 --> 00:44:13,359
so we have written a book as well so

00:44:12,000 --> 00:44:16,800
myself and

00:44:13,359 --> 00:44:17,280
my colleague glamal we wrote a book

00:44:16,800 --> 00:44:20,240
where

00:44:17,280 --> 00:44:20,960
how you can learn program using berliner

00:44:20,240 --> 00:44:24,319
so

00:44:20,960 --> 00:44:26,079
anyone who uh total newcomers to

00:44:24,319 --> 00:44:27,359
programming can check out this book as

00:44:26,079 --> 00:44:30,800
well

00:44:27,359 --> 00:44:34,560
that use a new approach to

00:44:30,800 --> 00:44:34,560
teaching programming using the learner

00:44:34,839 --> 00:44:39,440
language and

00:44:36,400 --> 00:44:42,960
um of course this is an open source

00:44:39,440 --> 00:44:44,079
um project uh so the full code is there

00:44:42,960 --> 00:44:47,359
in github

00:44:44,079 --> 00:44:50,640
and it's licensed under uh

00:44:47,359 --> 00:44:54,319
apache2 the compiler and the runtime

00:44:50,640 --> 00:44:58,480
basically and you can contribute

00:44:54,319 --> 00:45:01,680
with ideas with code as well

00:44:58,480 --> 00:45:03,599
in any area and you can

00:45:01,680 --> 00:45:05,520
get into the conversation using stack

00:45:03,599 --> 00:45:08,880
overflow can ask questions

00:45:05,520 --> 00:45:10,800
and also our main point of

00:45:08,880 --> 00:45:13,359
interaction is through the stack channel

00:45:10,800 --> 00:45:17,359
so um you can go and

00:45:13,359 --> 00:45:20,960
join that as well and

00:45:17,359 --> 00:45:25,599
any any feedback would be

00:45:20,960 --> 00:45:30,319
is is basically welcome

00:45:25,599 --> 00:45:33,599
and much appreciated so um

00:45:30,319 --> 00:45:36,000
also uh the demos i used the demo code

00:45:33,599 --> 00:45:39,200
you can find it here in my github repo

00:45:36,000 --> 00:45:40,240
uh for the aws demo scenario and also

00:45:39,200 --> 00:45:41,920
the

00:45:40,240 --> 00:45:43,599
server scenario you can find the full

00:45:41,920 --> 00:45:45,359
code here and how to deploy them with

00:45:43,599 --> 00:45:48,640
the instructions

00:45:45,359 --> 00:45:51,839
so you can deploy on your own

00:45:48,640 --> 00:45:55,119
and check it out so

00:45:51,839 --> 00:45:58,000
that is it for my session um

00:45:55,119 --> 00:46:00,000
thank you for listening um if there are

00:45:58,000 --> 00:46:10,720
any questions i can

00:46:00,000 --> 00:46:10,720

YouTube URL: https://www.youtube.com/watch?v=gNzUnnelEMg


