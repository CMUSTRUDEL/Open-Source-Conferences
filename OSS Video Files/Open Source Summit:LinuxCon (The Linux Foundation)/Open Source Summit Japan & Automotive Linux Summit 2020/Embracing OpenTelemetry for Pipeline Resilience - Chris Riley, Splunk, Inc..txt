Title: Embracing OpenTelemetry for Pipeline Resilience - Chris Riley, Splunk, Inc.
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Embracing OpenTelemetry for Pipeline Resilience - Chris Riley, Splunk, Inc.
Captions: 
	00:00:06,000 --> 00:00:09,760
hello everybody and thank you for

00:00:07,759 --> 00:00:11,679
joining me at my session today

00:00:09,760 --> 00:00:13,120
i know it can be overwhelming the amount

00:00:11,679 --> 00:00:15,759
of content out there

00:00:13,120 --> 00:00:17,600
and especially trying to consume all

00:00:15,759 --> 00:00:19,760
that virtually is very challenging so i

00:00:17,600 --> 00:00:22,160
appreciate you taking the time

00:00:19,760 --> 00:00:23,760
to view my session and thank you for

00:00:22,160 --> 00:00:25,439
everybody at the summit

00:00:23,760 --> 00:00:27,920
for taking the time to put together this

00:00:25,439 --> 00:00:28,560
event uh it is a tremendous amount of

00:00:27,920 --> 00:00:32,000
work

00:00:28,560 --> 00:00:35,200
and i appreciate that so

00:00:32,000 --> 00:00:37,200
before we begin i just want to briefly

00:00:35,200 --> 00:00:38,640
introduce myself i think it's important

00:00:37,200 --> 00:00:40,879
to understand who's

00:00:38,640 --> 00:00:41,680
up here talking to you and and why they

00:00:40,879 --> 00:00:45,280
feel like

00:00:41,680 --> 00:00:47,680
they have uh i guess the right to do so

00:00:45,280 --> 00:00:48,399
my name is chris riley i am a devops

00:00:47,680 --> 00:00:51,840
advocate

00:00:48,399 --> 00:00:53,760
and in developer relations at splunk

00:00:51,840 --> 00:00:55,440
um you probably are familiar with splunk

00:00:53,760 --> 00:00:57,360
as a log

00:00:55,440 --> 00:00:59,199
logging tool but we are much more than

00:00:57,360 --> 00:01:02,320
that we have a lot of tools

00:00:59,199 --> 00:01:05,519
called our observability suite in the

00:01:02,320 --> 00:01:07,760
devops area and my job

00:01:05,519 --> 00:01:09,760
is to represent the practitioner both

00:01:07,760 --> 00:01:12,799
externally and internally

00:01:09,760 --> 00:01:15,680
in the area of devops so if you scan

00:01:12,799 --> 00:01:18,640
that qr code you'll get access to

00:01:15,680 --> 00:01:19,280
my three podcasts now which is a crazy

00:01:18,640 --> 00:01:22,240
amount of

00:01:19,280 --> 00:01:23,840
podcasts to be doing as well as other

00:01:22,240 --> 00:01:26,159
information to connect with me

00:01:23,840 --> 00:01:27,119
and i always love to connect with people

00:01:26,159 --> 00:01:29,439
who have joined my

00:01:27,119 --> 00:01:30,880
sessions because it's good to hear you

00:01:29,439 --> 00:01:32,799
know what you thought

00:01:30,880 --> 00:01:34,079
what you learned what you didn't learn

00:01:32,799 --> 00:01:37,759
maybe and also

00:01:34,079 --> 00:01:42,320
continue the conversation so

00:01:37,759 --> 00:01:44,960
this session is all about open telemetry

00:01:42,320 --> 00:01:46,079
more specifically about how open

00:01:44,960 --> 00:01:49,119
telemetry

00:01:46,079 --> 00:01:53,200
is building pipeline resilience

00:01:49,119 --> 00:01:57,600
for enterprises which is critical

00:01:53,200 --> 00:01:59,759
in the modern devops environment

00:01:57,600 --> 00:02:01,280
and that's where i want to start i

00:01:59,759 --> 00:02:05,040
really want to focus

00:02:01,280 --> 00:02:05,840
on the business side the business

00:02:05,040 --> 00:02:08,959
benefits

00:02:05,840 --> 00:02:11,760
of this technology because

00:02:08,959 --> 00:02:13,360
it's important to realize that a lot of

00:02:11,760 --> 00:02:16,720
times when we talk about

00:02:13,360 --> 00:02:18,080
devops the conversation is all about

00:02:16,720 --> 00:02:21,200
releasing code

00:02:18,080 --> 00:02:24,800
faster and better

00:02:21,200 --> 00:02:28,000
but the mechanisms for releasing those

00:02:24,800 --> 00:02:29,920
applications are also important it's

00:02:28,000 --> 00:02:32,400
very important to understand

00:02:29,920 --> 00:02:34,400
the framework the guard rails all the

00:02:32,400 --> 00:02:37,680
tooling which i refer to

00:02:34,400 --> 00:02:39,440
as the management plane for managing

00:02:37,680 --> 00:02:43,440
your cloud

00:02:39,440 --> 00:02:45,200
doing ci cd doing pipeline analytics

00:02:43,440 --> 00:02:47,360
getting data from your tooling for

00:02:45,200 --> 00:02:51,280
monitoring etc

00:02:47,360 --> 00:02:54,879
are just as important as

00:02:51,280 --> 00:02:58,159
the velocity of the applications itself

00:02:54,879 --> 00:03:01,360
and now you know

00:02:58,159 --> 00:03:03,840
our delivery change chains are always

00:03:01,360 --> 00:03:04,879
changing the nature of applications are

00:03:03,840 --> 00:03:07,040
always changing

00:03:04,879 --> 00:03:08,879
we'd like to believe at some point that

00:03:07,040 --> 00:03:11,280
the change is going to stop

00:03:08,879 --> 00:03:13,280
and we can say we have built the devops

00:03:11,280 --> 00:03:14,800
environment but the reality is is new

00:03:13,280 --> 00:03:17,599
technologies are coming out

00:03:14,800 --> 00:03:18,239
constantly and being in a market i

00:03:17,599 --> 00:03:20,400
understand

00:03:18,239 --> 00:03:21,440
that there's new new approaches new

00:03:20,400 --> 00:03:23,840
tooling

00:03:21,440 --> 00:03:25,599
being released on a monthly bi-monthly

00:03:23,840 --> 00:03:27,599
basis

00:03:25,599 --> 00:03:28,640
the changes in our application

00:03:27,599 --> 00:03:31,599
architectures

00:03:28,640 --> 00:03:32,799
and how we deploy our applications are

00:03:31,599 --> 00:03:36,560
directly

00:03:32,799 --> 00:03:40,000
impacting how we operate them

00:03:36,560 --> 00:03:41,840
and so even if you don't want to think

00:03:40,000 --> 00:03:44,239
about

00:03:41,840 --> 00:03:46,959
how we manage these applications you

00:03:44,239 --> 00:03:50,480
really have no choice

00:03:46,959 --> 00:03:52,959
because what used to be deploying code

00:03:50,480 --> 00:03:54,239
onto static infrastructures a lot of

00:03:52,959 --> 00:03:56,799
times we would even

00:03:54,239 --> 00:03:58,480
name the servers we were deploying our

00:03:56,799 --> 00:04:02,159
code to

00:03:58,480 --> 00:04:05,360
has transformed into

00:04:02,159 --> 00:04:08,480
distributed systems via microservices

00:04:05,360 --> 00:04:10,480
kubernetes what once was very

00:04:08,480 --> 00:04:12,640
slow-moving

00:04:10,480 --> 00:04:13,760
deployments to infrastructure that never

00:04:12,640 --> 00:04:16,959
changed

00:04:13,760 --> 00:04:18,720
is now a very rapid deployments

00:04:16,959 --> 00:04:20,160
to infrastructure that's always changing

00:04:18,720 --> 00:04:22,000
as a matter of fact

00:04:20,160 --> 00:04:23,840
the boundaries between your application

00:04:22,000 --> 00:04:25,919
and the infrastructure have blurred

00:04:23,840 --> 00:04:27,360
so now when you deploy applications

00:04:25,919 --> 00:04:30,000
you're actually deploying

00:04:27,360 --> 00:04:30,880
infrastructure along with it and it's

00:04:30,000 --> 00:04:34,160
ephemeral

00:04:30,880 --> 00:04:37,120
and stateless you tear it down

00:04:34,160 --> 00:04:39,680
rapidly along with every single

00:04:37,120 --> 00:04:39,680
deployment

00:04:39,919 --> 00:04:44,320
and application relationships the

00:04:42,800 --> 00:04:46,160
relationship between the components in

00:04:44,320 --> 00:04:47,600
the application are no longer in a

00:04:46,160 --> 00:04:50,880
single binary

00:04:47,600 --> 00:04:52,960
or a single part of code they're just

00:04:50,880 --> 00:04:53,919
they're they're distributed across

00:04:52,960 --> 00:04:57,120
services

00:04:53,919 --> 00:04:58,240
each service has its own stack each

00:04:57,120 --> 00:05:00,479
service has its own

00:04:58,240 --> 00:05:02,800
team building that service the

00:05:00,479 --> 00:05:05,919
relationship between those services

00:05:02,800 --> 00:05:10,320
also called contracts is a little bit

00:05:05,919 --> 00:05:12,080
unknown um you a single operator can't

00:05:10,320 --> 00:05:14,560
intuit the relationship between all

00:05:12,080 --> 00:05:18,960
these services you know starting around

00:05:14,560 --> 00:05:21,759
about around 15 micro services

00:05:18,960 --> 00:05:23,199
it's impossible for anybody to really

00:05:21,759 --> 00:05:26,160
know

00:05:23,199 --> 00:05:27,600
all of the dependencies and relationship

00:05:26,160 --> 00:05:30,320
between those services

00:05:27,600 --> 00:05:32,240
so identifying issues and getting data

00:05:30,320 --> 00:05:35,600
into the monitoring

00:05:32,240 --> 00:05:38,720
platform the management plan for this

00:05:35,600 --> 00:05:40,400
is a new challenge it's different and

00:05:38,720 --> 00:05:42,240
back where when we had static

00:05:40,400 --> 00:05:43,680
infrastructure we would start with the

00:05:42,240 --> 00:05:45,919
log

00:05:43,680 --> 00:05:47,520
now you can't start with the log the log

00:05:45,919 --> 00:05:49,440
is the destination

00:05:47,520 --> 00:05:51,039
hopefully you never have to get there

00:05:49,440 --> 00:05:54,560
but the log is the end point

00:05:51,039 --> 00:05:58,960
not the starting point so

00:05:54,560 --> 00:06:01,120
inevitably monitoring has to evolve

00:05:58,960 --> 00:06:02,479
and it has to evolve into this new

00:06:01,120 --> 00:06:05,199
industry term

00:06:02,479 --> 00:06:06,160
we use called observability the first

00:06:05,199 --> 00:06:09,280
question i get

00:06:06,160 --> 00:06:13,360
when i use the term observability

00:06:09,280 --> 00:06:16,400
is is observability just monitoring

00:06:13,360 --> 00:06:18,639
yeah ultimately it is

00:06:16,400 --> 00:06:20,240
um the way we look at observability is

00:06:18,639 --> 00:06:24,160
zerb observability

00:06:20,240 --> 00:06:25,520
is the data and the practices around

00:06:24,160 --> 00:06:28,800
that data

00:06:25,520 --> 00:06:32,000
are your modern monitoring

00:06:28,800 --> 00:06:33,759
practices so if you're a good

00:06:32,000 --> 00:06:35,919
techie curmudgeon like me and you hear a

00:06:33,759 --> 00:06:36,800
new term you probably just roll your

00:06:35,919 --> 00:06:38,639
eyes

00:06:36,800 --> 00:06:40,800
but if i can convince you that the

00:06:38,639 --> 00:06:42,080
reason using the term observability is

00:06:40,800 --> 00:06:43,759
important

00:06:42,080 --> 00:06:45,360
given the context of everything we're

00:06:43,759 --> 00:06:47,199
going to talk about around open

00:06:45,360 --> 00:06:50,160
telemetry

00:06:47,199 --> 00:06:51,440
is because the landscape of monitoring

00:06:50,160 --> 00:06:53,680
has changed

00:06:51,440 --> 00:06:55,199
it's a new problem space when we talk

00:06:53,680 --> 00:06:57,680
about monitoring

00:06:55,199 --> 00:06:58,639
distributed applications and modern

00:06:57,680 --> 00:07:01,039
cloud native

00:06:58,639 --> 00:07:03,039
applications and that problem space is

00:07:01,039 --> 00:07:06,800
significant enough

00:07:03,039 --> 00:07:10,639
that we need a term to to be efficient

00:07:06,800 --> 00:07:10,639
about topic talking about it

00:07:10,880 --> 00:07:16,720
so before i go on

00:07:13,919 --> 00:07:17,280
we really need to hone in on some key

00:07:16,720 --> 00:07:19,599
terms

00:07:17,280 --> 00:07:21,360
so the first is observability and and

00:07:19,599 --> 00:07:23,520
i've defined that for you and i'm going

00:07:21,360 --> 00:07:26,080
to use observability

00:07:23,520 --> 00:07:27,120
to talk about how we leverage open

00:07:26,080 --> 00:07:30,400
telemetry

00:07:27,120 --> 00:07:32,400
in our modern applications

00:07:30,400 --> 00:07:34,240
and then we need to talk about the data

00:07:32,400 --> 00:07:36,560
sources so i talked about

00:07:34,240 --> 00:07:38,080
observability essentially being data

00:07:36,560 --> 00:07:41,120
what does that mean

00:07:38,080 --> 00:07:45,360
well we have two new

00:07:41,120 --> 00:07:48,720
key sources of data namely traces

00:07:45,360 --> 00:07:52,639
and spans traces

00:07:48,720 --> 00:07:56,479
spans are an attribute of a trace

00:07:52,639 --> 00:07:59,759
and there's span contexts that are also

00:07:56,479 --> 00:08:03,280
a part of traces most of us are used to

00:07:59,759 --> 00:08:05,840
metrics which is a measurement

00:08:03,280 --> 00:08:07,440
and we're also used to logs which is

00:08:05,840 --> 00:08:08,319
traditionally what we think about when

00:08:07,440 --> 00:08:12,160
we think

00:08:08,319 --> 00:08:16,560
about monitoring all three of these are

00:08:12,160 --> 00:08:19,840
pillars of observability

00:08:16,560 --> 00:08:23,120
so perhaps traces are new to you

00:08:19,840 --> 00:08:26,400
let's dig into those a little bit

00:08:23,120 --> 00:08:29,520
now they are a standard um

00:08:26,400 --> 00:08:33,440
a tracer is how you get

00:08:29,520 --> 00:08:37,519
context from a tran a span

00:08:33,440 --> 00:08:41,039
or sorry from a trace spans

00:08:37,519 --> 00:08:44,159
are the time spent in

00:08:41,039 --> 00:08:45,200
any one call as a part of a trace so if

00:08:44,159 --> 00:08:48,560
you think about it

00:08:45,200 --> 00:08:51,279
the trace is the transaction

00:08:48,560 --> 00:08:52,560
from the point that a user enters your

00:08:51,279 --> 00:08:55,680
application

00:08:52,560 --> 00:08:58,800
to when they leave the application

00:08:55,680 --> 00:09:00,399
with inside that transaction they are

00:08:58,800 --> 00:09:03,760
spending time

00:09:00,399 --> 00:09:06,240
in specific calls

00:09:03,760 --> 00:09:07,600
and those are your spans so the amount

00:09:06,240 --> 00:09:11,200
of time is spent

00:09:07,600 --> 00:09:13,279
there and what is done there

00:09:11,200 --> 00:09:15,600
there's different types of spans you can

00:09:13,279 --> 00:09:18,640
have client server

00:09:15,600 --> 00:09:21,839
producer consumer and then also

00:09:18,640 --> 00:09:22,800
internal within the application spans

00:09:21,839 --> 00:09:26,240
have attributes

00:09:22,800 --> 00:09:26,800
which are key value pairs and have tags

00:09:26,240 --> 00:09:30,240
which are

00:09:26,800 --> 00:09:34,080
very critical metadata that you

00:09:30,240 --> 00:09:36,720
add to the spans to enhance their value

00:09:34,080 --> 00:09:37,680
one thing i will say here that tags are

00:09:36,720 --> 00:09:42,000
a

00:09:37,680 --> 00:09:44,480
um an information architecture

00:09:42,000 --> 00:09:46,480
challenge not a technology challenge so

00:09:44,480 --> 00:09:47,600
don't expect the technology to decide

00:09:46,480 --> 00:09:49,120
tax for you

00:09:47,600 --> 00:09:50,800
that is something that your team needs

00:09:49,120 --> 00:09:52,880
to decide from

00:09:50,800 --> 00:09:54,480
in our information architecture and

00:09:52,880 --> 00:09:58,720
application architecture

00:09:54,480 --> 00:10:04,640
perspective and then you also have

00:09:58,720 --> 00:10:07,839
events and and links as a part of spans

00:10:04,640 --> 00:10:11,839
also as a part of traces we have span

00:10:07,839 --> 00:10:15,040
processors so these are what

00:10:11,839 --> 00:10:17,279
send maybe from a batch perspective or

00:10:15,040 --> 00:10:18,720
from a you know one in one out

00:10:17,279 --> 00:10:22,079
perspective

00:10:18,720 --> 00:10:25,200
and then we have exporters of um

00:10:22,079 --> 00:10:26,480
spans so these are the tools that take

00:10:25,200 --> 00:10:28,320
from your infrastructure your

00:10:26,480 --> 00:10:31,360
application the

00:10:28,320 --> 00:10:33,680
spans and the traces and

00:10:31,360 --> 00:10:36,800
correlate them together and send them to

00:10:33,680 --> 00:10:36,800
your monitoring tool

00:10:36,959 --> 00:10:41,200
so now let's talk about metrics because

00:10:39,040 --> 00:10:44,800
this is another key aspect of

00:10:41,200 --> 00:10:44,800
observability and cloud native

00:10:44,839 --> 00:10:52,320
applications metrics are a measurement

00:10:48,399 --> 00:10:55,519
over a time series based measurement

00:10:52,320 --> 00:10:56,399
and an element in your application you

00:10:55,519 --> 00:10:59,279
choose

00:10:56,399 --> 00:11:00,399
to measure a lot of times in the context

00:10:59,279 --> 00:11:03,760
of metrics you'll hear

00:11:00,399 --> 00:11:05,680
about red metrics red

00:11:03,760 --> 00:11:07,120
is generally used for application

00:11:05,680 --> 00:11:09,040
performance monitoring

00:11:07,120 --> 00:11:10,959
and it stands for rate error and

00:11:09,040 --> 00:11:14,079
duration

00:11:10,959 --> 00:11:16,880
these are all key components to first

00:11:14,079 --> 00:11:18,560
quickly visualize your application for

00:11:16,880 --> 00:11:20,480
the team to understand the health and

00:11:18,560 --> 00:11:23,360
the performance of the application

00:11:20,480 --> 00:11:24,959
but in troubleshooting understanding how

00:11:23,360 --> 00:11:28,079
these metrics relate to

00:11:24,959 --> 00:11:31,600
key thresholds and

00:11:28,079 --> 00:11:35,200
slos that your application

00:11:31,600 --> 00:11:36,320
should be meeting and really the metrics

00:11:35,200 --> 00:11:40,079
themselves or

00:11:36,320 --> 00:11:42,800
red in this case or in this example

00:11:40,079 --> 00:11:43,360
are the slis these are the indicators

00:11:42,800 --> 00:11:46,720
that you're

00:11:43,360 --> 00:11:50,000
using so the raw aspects of

00:11:46,720 --> 00:11:52,880
a a metric are

00:11:50,000 --> 00:11:53,600
the measurement so what you're basically

00:11:52,880 --> 00:11:56,560
the name

00:11:53,600 --> 00:11:58,000
of what you're measuring like rate and

00:11:56,560 --> 00:12:01,279
the actual measurement

00:11:58,000 --> 00:12:05,040
so the values over a period

00:12:01,279 --> 00:12:06,000
of time you're going to be aggregating

00:12:05,040 --> 00:12:08,880
these

00:12:06,000 --> 00:12:11,760
and most monitoring tools are going to

00:12:08,880 --> 00:12:13,519
keep some some span of time of them

00:12:11,760 --> 00:12:15,440
what is important to consider in your

00:12:13,519 --> 00:12:17,680
monitoring tool both for traces and

00:12:15,440 --> 00:12:20,800
spans is the fidelity

00:12:17,680 --> 00:12:22,480
so a lot of tools will sample some will

00:12:20,800 --> 00:12:24,480
keep a hundred percent

00:12:22,480 --> 00:12:27,680
it's important and understand the impact

00:12:24,480 --> 00:12:29,920
of that in your environment

00:12:27,680 --> 00:12:31,519
so now we start to you may be asking why

00:12:29,920 --> 00:12:33,519
haven't you talked about open telemetry

00:12:31,519 --> 00:12:36,160
yet well all of that foundation is

00:12:33,519 --> 00:12:39,360
important for me to explain to you

00:12:36,160 --> 00:12:41,120
the value of open telemetry and and why

00:12:39,360 --> 00:12:44,079
you should consider it

00:12:41,120 --> 00:12:45,120
as a part of your environment so we use

00:12:44,079 --> 00:12:48,959
this term a lot

00:12:45,120 --> 00:12:52,720
um called gdi getting data in

00:12:48,959 --> 00:12:56,079
this is how you extract traces spans

00:12:52,720 --> 00:12:59,839
metrics logs from your application

00:12:56,079 --> 00:13:02,880
and transport them into your monitoring

00:12:59,839 --> 00:13:05,839
plane now in most

00:13:02,880 --> 00:13:08,000
instances and where we're used to

00:13:05,839 --> 00:13:09,120
looking at this from a very proprietary

00:13:08,000 --> 00:13:12,639
standpoint

00:13:09,120 --> 00:13:16,480
where the monitoring tool is also

00:13:12,639 --> 00:13:19,360
dictates the implementation of gdi

00:13:16,480 --> 00:13:20,079
and it's usually in the form of an agent

00:13:19,360 --> 00:13:23,279
those agents

00:13:20,079 --> 00:13:25,440
are proprietary and

00:13:23,279 --> 00:13:26,880
as they update you will update them and

00:13:25,440 --> 00:13:28,240
you're deploying them across your

00:13:26,880 --> 00:13:29,839
infrastructure

00:13:28,240 --> 00:13:31,760
if you have multiple monitoring tools

00:13:29,839 --> 00:13:35,519
you might have multiple types

00:13:31,760 --> 00:13:38,639
of agents well gdi

00:13:35,519 --> 00:13:40,959
is is something that every organization

00:13:38,639 --> 00:13:42,800
needs to deal with we're all getting the

00:13:40,959 --> 00:13:44,800
same kind of telemetry

00:13:42,800 --> 00:13:46,880
from our applications and our

00:13:44,800 --> 00:13:50,000
infrastructure

00:13:46,880 --> 00:13:50,880
and because of this it it doesn't really

00:13:50,000 --> 00:13:54,160
make sense

00:13:50,880 --> 00:13:57,279
that we would approach gdi

00:13:54,160 --> 00:13:59,920
differently for the monitoring tool

00:13:57,279 --> 00:14:00,800
or whether it's infrastructure or

00:13:59,920 --> 00:14:03,120
application

00:14:00,800 --> 00:14:05,120
whether it's agent or encode

00:14:03,120 --> 00:14:09,920
instrumentation

00:14:05,120 --> 00:14:13,519
so by treating it as a proprietary thing

00:14:09,920 --> 00:14:16,720
you've actually limited yourself

00:14:13,519 --> 00:14:20,240
from growing in the future because

00:14:16,720 --> 00:14:23,440
now if you want to change your

00:14:20,240 --> 00:14:25,440
your monitoring plane

00:14:23,440 --> 00:14:26,800
either from a configuration standpoint

00:14:25,440 --> 00:14:29,600
scaling it

00:14:26,800 --> 00:14:30,959
even or actually changing the tooling

00:14:29,600 --> 00:14:32,959
itself

00:14:30,959 --> 00:14:35,040
you also have to change how you collect

00:14:32,959 --> 00:14:36,639
the data and it's not just a trivial

00:14:35,040 --> 00:14:37,440
change of replacing one agent for

00:14:36,639 --> 00:14:40,079
another

00:14:37,440 --> 00:14:40,720
agent because those agencies start to

00:14:40,079 --> 00:14:45,680
determine

00:14:40,720 --> 00:14:49,519
and impose practices upon you

00:14:45,680 --> 00:14:50,959
really your your process of getting data

00:14:49,519 --> 00:14:54,240
into your application should be

00:14:50,959 --> 00:14:57,279
completely unshackled

00:14:54,240 --> 00:14:59,120
and it should be decoupled from

00:14:57,279 --> 00:15:01,040
the tools you use to monitor that

00:14:59,120 --> 00:15:02,880
application

00:15:01,040 --> 00:15:05,440
and it should not rule your

00:15:02,880 --> 00:15:08,240
infrastructure because once it does

00:15:05,440 --> 00:15:11,040
it actually dictates how you modernize

00:15:08,240 --> 00:15:15,120
your application

00:15:11,040 --> 00:15:18,240
also as you go faster

00:15:15,120 --> 00:15:20,480
and you need to bring more applications

00:15:18,240 --> 00:15:22,959
you need to onboard more applications in

00:15:20,480 --> 00:15:26,480
your environment

00:15:22,959 --> 00:15:29,360
without having a standard

00:15:26,480 --> 00:15:31,120
and an open way to collect data from

00:15:29,360 --> 00:15:33,920
those applications

00:15:31,120 --> 00:15:35,519
it's very hard to onboard it's your

00:15:33,920 --> 00:15:38,800
service onboarding process

00:15:35,519 --> 00:15:40,399
now has a whole slew of considerations

00:15:38,800 --> 00:15:42,320
that have to be made for

00:15:40,399 --> 00:15:44,560
your agent in the configuration of the

00:15:42,320 --> 00:15:46,880
agent etc

00:15:44,560 --> 00:15:48,480
which means that you simply can't scale

00:15:46,880 --> 00:15:51,279
you can't scale

00:15:48,480 --> 00:15:53,360
because you might have snowflake agents

00:15:51,279 --> 00:15:54,959
across your application

00:15:53,360 --> 00:15:56,800
different types of agents for different

00:15:54,959 --> 00:15:59,040
types of use cases for different types

00:15:56,800 --> 00:16:02,240
of stacks

00:15:59,040 --> 00:16:03,519
or simply because even if it's the same

00:16:02,240 --> 00:16:05,360
type of agent

00:16:03,519 --> 00:16:06,720
there's snowflake configurations in

00:16:05,360 --> 00:16:10,079
those agents to support

00:16:06,720 --> 00:16:12,880
new services so all of this

00:16:10,079 --> 00:16:14,160
is enabled you need to think about

00:16:12,880 --> 00:16:19,040
enabling

00:16:14,160 --> 00:16:21,040
scale decoupling your monitoring plane

00:16:19,040 --> 00:16:22,160
from the application and how you

00:16:21,040 --> 00:16:24,399
instrument it

00:16:22,160 --> 00:16:25,839
and building in pipeline resilience so

00:16:24,399 --> 00:16:29,279
resilience

00:16:25,839 --> 00:16:32,720
is a mindset and

00:16:29,279 --> 00:16:35,360
embracing open instrumentation and open

00:16:32,720 --> 00:16:36,000
data collection from your applications

00:16:35,360 --> 00:16:39,199
supports

00:16:36,000 --> 00:16:40,079
that mindset so that you can be better

00:16:39,199 --> 00:16:43,279
at building

00:16:40,079 --> 00:16:44,160
more resilient pipelines and delivery

00:16:43,279 --> 00:16:46,480
chains

00:16:44,160 --> 00:16:49,120
and the reason for that is because your

00:16:46,480 --> 00:16:51,199
instrumentation to get that data out

00:16:49,120 --> 00:16:53,040
is standardized no matter the

00:16:51,199 --> 00:16:55,680
application infrastructure

00:16:53,040 --> 00:16:57,759
no matter the tools you're using for

00:16:55,680 --> 00:17:01,360
monitoring it

00:16:57,759 --> 00:17:04,480
so that is the goal and that is why

00:17:01,360 --> 00:17:08,319
we really want to think about

00:17:04,480 --> 00:17:10,959
changing how we get data into our

00:17:08,319 --> 00:17:11,360
tooling but there's another element of

00:17:10,959 --> 00:17:14,319
this

00:17:11,360 --> 00:17:15,600
there's a missed opportunity because

00:17:14,319 --> 00:17:17,839
there is a lot

00:17:15,600 --> 00:17:20,240
of data that comes out of your

00:17:17,839 --> 00:17:22,079
infrastructure in your application

00:17:20,240 --> 00:17:23,760
and that data is powerful in a lot of

00:17:22,079 --> 00:17:27,280
ways some ways negative

00:17:23,760 --> 00:17:29,840
for example private information pii

00:17:27,280 --> 00:17:32,880
getting that data into your monitoring

00:17:29,840 --> 00:17:34,080
tool could be risky perhaps you don't

00:17:32,880 --> 00:17:36,480
want that data

00:17:34,080 --> 00:17:37,840
in your monitoring tool you need to

00:17:36,480 --> 00:17:40,799
massage it and make sure

00:17:37,840 --> 00:17:41,120
that your operators don't have access to

00:17:40,799 --> 00:17:44,720
that

00:17:41,120 --> 00:17:48,480
information even though it is present

00:17:44,720 --> 00:17:50,640
in the data of the application itself

00:17:48,480 --> 00:17:52,000
the other missed opportunity on all this

00:17:50,640 --> 00:17:54,480
data coming through

00:17:52,000 --> 00:17:56,400
is it'd be useful to apply business

00:17:54,480 --> 00:17:59,440
logic

00:17:56,400 --> 00:18:02,400
on your gdi on

00:17:59,440 --> 00:18:03,360
your telemetry so that you can be more

00:18:02,400 --> 00:18:05,039
efficient

00:18:03,360 --> 00:18:08,880
and effective with the data that's

00:18:05,039 --> 00:18:12,840
coming in maybe manipulating data or

00:18:08,880 --> 00:18:15,760
splitting data into multiple streams

00:18:12,840 --> 00:18:16,880
for um to better leverage that

00:18:15,760 --> 00:18:19,679
information

00:18:16,880 --> 00:18:21,280
in various ways and that gets to the

00:18:19,679 --> 00:18:24,240
flexibility of data flow

00:18:21,280 --> 00:18:26,240
instead of having proprietary agents

00:18:24,240 --> 00:18:26,799
which a lot of time are dumb agents that

00:18:26,240 --> 00:18:29,039
just

00:18:26,799 --> 00:18:30,480
take whatever they get they throw it

00:18:29,039 --> 00:18:32,160
into your monitoring plane

00:18:30,480 --> 00:18:33,760
you get to manipulate that data you

00:18:32,160 --> 00:18:35,760
could

00:18:33,760 --> 00:18:37,840
you want to be able to split it into

00:18:35,760 --> 00:18:40,559
multiple paths

00:18:37,840 --> 00:18:42,480
either some information goes one way

00:18:40,559 --> 00:18:44,880
other information goes another way

00:18:42,480 --> 00:18:46,880
or all the information goes to multiple

00:18:44,880 --> 00:18:50,000
tools like one goes to a logging tool

00:18:46,880 --> 00:18:53,039
one goes to an observability tool

00:18:50,000 --> 00:18:55,919
you want to have that control because

00:18:53,039 --> 00:18:58,080
one for one gets you into these weird

00:18:55,919 --> 00:18:59,919
scenarios where you're actually passing

00:18:58,080 --> 00:19:01,120
data from one monitoring tool to another

00:18:59,919 --> 00:19:03,679
monitoring tool

00:19:01,120 --> 00:19:04,720
sometimes three i've seen that type of

00:19:03,679 --> 00:19:08,240
configuration

00:19:04,720 --> 00:19:11,679
as well so all of this

00:19:08,240 --> 00:19:12,160
is leading to the idea that we need to

00:19:11,679 --> 00:19:16,240
look

00:19:12,160 --> 00:19:18,400
at technology and standards to help us

00:19:16,240 --> 00:19:20,640
embrace the business value of our

00:19:18,400 --> 00:19:22,400
telemetry coming from our applications

00:19:20,640 --> 00:19:26,000
and infrastructure

00:19:22,400 --> 00:19:26,960
and maximize that as well as unshackle

00:19:26,000 --> 00:19:30,000
us

00:19:26,960 --> 00:19:30,559
from the gdi aspects of getting that

00:19:30,000 --> 00:19:33,039
data

00:19:30,559 --> 00:19:35,280
into our monitoring plane and that's

00:19:33,039 --> 00:19:38,000
where open telemetry comes in

00:19:35,280 --> 00:19:40,000
and i put otel up there like all good

00:19:38,000 --> 00:19:43,679
industry terms we like to

00:19:40,000 --> 00:19:46,080
abbreviate we do it for kubernetes

00:19:43,679 --> 00:19:47,600
in the form of k8s we do it with

00:19:46,080 --> 00:19:51,440
observability

00:19:47,600 --> 00:19:54,000
in the form of o11y or oli

00:19:51,440 --> 00:19:56,160
if if you're really trendy we do the

00:19:54,000 --> 00:19:58,080
same with open telemetry and even within

00:19:56,160 --> 00:20:01,520
the open telemetry project

00:19:58,080 --> 00:20:03,520
where we call open telemetry hotel

00:20:01,520 --> 00:20:06,240
so if you see hotel it means open

00:20:03,520 --> 00:20:08,720
telemetry and yes i know this can

00:20:06,240 --> 00:20:10,880
get frustrating but it's useful for

00:20:08,720 --> 00:20:12,799
efficiency purposes but i generally will

00:20:10,880 --> 00:20:15,679
not use in conversation

00:20:12,799 --> 00:20:16,080
because it's better to stick with the

00:20:15,679 --> 00:20:18,080
full

00:20:16,080 --> 00:20:19,520
open telemetry name so people understand

00:20:18,080 --> 00:20:23,440
what you're talking about

00:20:19,520 --> 00:20:26,720
so the open telemetry project is a cncf

00:20:23,440 --> 00:20:27,440
open source project for gdi for getting

00:20:26,720 --> 00:20:29,280
data

00:20:27,440 --> 00:20:31,520
from your infrastructure and your

00:20:29,280 --> 00:20:34,640
application into your

00:20:31,520 --> 00:20:36,480
management plane or other tools you have

00:20:34,640 --> 00:20:39,520
a lot of control here

00:20:36,480 --> 00:20:43,200
it's built on open telemetry

00:20:39,520 --> 00:20:45,440
standards so first are the standards

00:20:43,200 --> 00:20:46,320
then you have the collector and the

00:20:45,440 --> 00:20:48,559
services

00:20:46,320 --> 00:20:50,400
implementing those standards the

00:20:48,559 --> 00:20:53,919
implementation

00:20:50,400 --> 00:20:57,840
comes from a collector and an agent

00:20:53,919 --> 00:21:01,120
and as always around open source

00:20:57,840 --> 00:21:02,080
a community so it is important to have a

00:21:01,120 --> 00:21:04,400
community

00:21:02,080 --> 00:21:05,440
of people contributing to the project

00:21:04,400 --> 00:21:08,559
and a community

00:21:05,440 --> 00:21:11,760
of people engaging in helping each other

00:21:08,559 --> 00:21:13,520
to be as effective as they possibly can

00:21:11,760 --> 00:21:17,840
around the project and it is a

00:21:13,520 --> 00:21:21,280
tremendous community

00:21:17,840 --> 00:21:23,760
here is where open telemetry

00:21:21,280 --> 00:21:24,480
fits in the nature of applications

00:21:23,760 --> 00:21:26,960
because

00:21:24,480 --> 00:21:27,520
we know that the typical enterprise is

00:21:26,960 --> 00:21:30,640
going to be

00:21:27,520 --> 00:21:33,280
in various stages of their cloud journey

00:21:30,640 --> 00:21:35,280
and their devops journey and that's okay

00:21:33,280 --> 00:21:38,240
and that probably is not going to change

00:21:35,280 --> 00:21:40,159
for a long amount of time so an

00:21:38,240 --> 00:21:42,400
organization is typically going to have

00:21:40,159 --> 00:21:44,480
some monolithic applications where you

00:21:42,400 --> 00:21:46,799
use proprietary

00:21:44,480 --> 00:21:48,400
agents you might have hybrid

00:21:46,799 --> 00:21:53,360
applications where you have some

00:21:48,400 --> 00:21:55,679
some cloud some monolith applications

00:21:53,360 --> 00:21:57,200
and you need to those two may even need

00:21:55,679 --> 00:21:59,200
to talk to each other

00:21:57,200 --> 00:22:01,679
and then you might have cloud native

00:21:59,200 --> 00:22:04,559
applications so these are applications

00:22:01,679 --> 00:22:06,880
born in the cloud and really what we're

00:22:04,559 --> 00:22:10,720
talking about that necessitate

00:22:06,880 --> 00:22:13,440
uh observability especially necessitate

00:22:10,720 --> 00:22:15,280
an open way to collect this data from

00:22:13,440 --> 00:22:19,120
the applications

00:22:15,280 --> 00:22:22,720
and really where open telemetry fits

00:22:19,120 --> 00:22:25,280
the best is in the cloud native

00:22:22,720 --> 00:22:26,159
application when i say cloud native i

00:22:25,280 --> 00:22:29,360
don't just

00:22:26,159 --> 00:22:31,679
mean cloud i mean

00:22:29,360 --> 00:22:32,880
a cloud-based application that is

00:22:31,679 --> 00:22:36,240
generally leveraging

00:22:32,880 --> 00:22:38,240
microservices and usually kubernetes

00:22:36,240 --> 00:22:39,440
um so the nature of the application is

00:22:38,240 --> 00:22:42,799
also changed

00:22:39,440 --> 00:22:43,919
in addition to the destination where it

00:22:42,799 --> 00:22:47,440
actually

00:22:43,919 --> 00:22:50,400
runs now

00:22:47,440 --> 00:22:51,360
let's dig into to what open telemetry

00:22:50,400 --> 00:22:55,440
really is

00:22:51,360 --> 00:22:57,760
from a technology standpoint

00:22:55,440 --> 00:22:58,559
so if you think about those key

00:22:57,760 --> 00:23:01,600
components

00:22:58,559 --> 00:23:05,039
of your application traces metrics

00:23:01,600 --> 00:23:05,840
logs those are the vertical aspects so

00:23:05,039 --> 00:23:10,240
these are

00:23:05,840 --> 00:23:13,440
the the data essentially

00:23:10,240 --> 00:23:17,039
the way you work with that data is

00:23:13,440 --> 00:23:20,360
it could be through apis

00:23:17,039 --> 00:23:23,360
various formats it's going to involve

00:23:20,360 --> 00:23:25,919
architectures like

00:23:23,360 --> 00:23:26,720
are you using the sidecar pattern how

00:23:25,919 --> 00:23:29,840
are you using

00:23:26,720 --> 00:23:31,760
collectors in a wide range of data

00:23:29,840 --> 00:23:35,440
formats just a tremendous

00:23:31,760 --> 00:23:38,559
amount of formats of this data json

00:23:35,440 --> 00:23:41,840
key value pairs etc

00:23:38,559 --> 00:23:45,120
so open telemetry is meant to encompass

00:23:41,840 --> 00:23:47,360
all of those logs are

00:23:45,120 --> 00:23:49,200
a feature on the roadmap they're not

00:23:47,360 --> 00:23:52,240
there yet today

00:23:49,200 --> 00:23:52,799
but traces spans and now metrics as a

00:23:52,240 --> 00:23:55,840
very

00:23:52,799 --> 00:23:58,159
very recently are are supported

00:23:55,840 --> 00:23:59,039
support it but the idea is that open

00:23:58,159 --> 00:24:02,400
telemetry

00:23:59,039 --> 00:24:06,159
is going to encompass all the layers

00:24:02,400 --> 00:24:08,480
and all the pillars of telemetry that is

00:24:06,159 --> 00:24:12,240
coming out of your infrastructure

00:24:08,480 --> 00:24:15,760
and application as i mentioned

00:24:12,240 --> 00:24:18,159
community is a such a tremendous part of

00:24:15,760 --> 00:24:19,760
this and why you do this in any open

00:24:18,159 --> 00:24:23,120
source project

00:24:19,760 --> 00:24:26,880
so there is just a tremendous backing

00:24:23,120 --> 00:24:30,080
between open telemetry between

00:24:26,880 --> 00:24:32,960
major cloud providers top industry

00:24:30,080 --> 00:24:35,279
vendors including splunk this project is

00:24:32,960 --> 00:24:39,039
a very important project to us

00:24:35,279 --> 00:24:43,360
and we have dedicated a lot of resources

00:24:39,039 --> 00:24:46,559
to contributing and making it successful

00:24:43,360 --> 00:24:48,480
as well as a ton of large cloud

00:24:46,559 --> 00:24:50,240
cloud native application vendors like

00:24:48,480 --> 00:24:53,200
mailchimp spotify

00:24:50,240 --> 00:24:54,080
postmates who are actually leveraging

00:24:53,200 --> 00:24:56,320
this

00:24:54,080 --> 00:24:57,120
at scale in production which is very

00:24:56,320 --> 00:24:59,279
important

00:24:57,120 --> 00:25:00,799
and then other open source projects

00:24:59,279 --> 00:25:04,000
because these come in

00:25:00,799 --> 00:25:06,159
to exporters and providers

00:25:04,000 --> 00:25:07,039
that are getting data in or consuming

00:25:06,159 --> 00:25:10,159
data

00:25:07,039 --> 00:25:13,760
from open telemetry i know those

00:25:10,159 --> 00:25:14,720
urls are are small give you a chance to

00:25:13,760 --> 00:25:16,960
screenshot this

00:25:14,720 --> 00:25:18,559
quickly because i i'm not sure if you're

00:25:16,960 --> 00:25:21,520
going to be able to get the slides

00:25:18,559 --> 00:25:23,520
so that you have access to those but

00:25:21,520 --> 00:25:26,840
there's just a tremendous amount

00:25:23,520 --> 00:25:29,520
of information regarding the project on

00:25:26,840 --> 00:25:32,240
opentelemetry.io

00:25:29,520 --> 00:25:34,400
few things just from statistics about

00:25:32,240 --> 00:25:37,520
the project i want to clarify

00:25:34,400 --> 00:25:39,120
it's not yet general availability so the

00:25:37,520 --> 00:25:44,240
project itself

00:25:39,120 --> 00:25:46,080
is still beta but it is very widely used

00:25:44,240 --> 00:25:48,320
and companies have been very successful

00:25:46,080 --> 00:25:50,960
with it and like i said the community

00:25:48,320 --> 00:25:53,120
is tremendous just go and look at the

00:25:50,960 --> 00:25:55,760
dev stats for it

00:25:53,120 --> 00:25:57,440
and the road map for it and it's

00:25:55,760 --> 00:25:59,600
fantastic which is important to

00:25:57,440 --> 00:26:01,679
understand that clearly

00:25:59,600 --> 00:26:03,360
it is going to get adopted it is going

00:26:01,679 --> 00:26:05,760
to be adopted widely

00:26:03,360 --> 00:26:08,720
and if you adopt it you're going to have

00:26:05,760 --> 00:26:11,120
a lot of utilities

00:26:08,720 --> 00:26:13,679
out there in the community to help you

00:26:11,120 --> 00:26:16,080
with implementation

00:26:13,679 --> 00:26:17,120
let's go back again it's important to

00:26:16,080 --> 00:26:20,720
reiterate

00:26:17,120 --> 00:26:24,000
why is open telemetry so important well

00:26:20,720 --> 00:26:25,919
it creates a a decouples

00:26:24,000 --> 00:26:28,000
how you get data into your monitoring

00:26:25,919 --> 00:26:31,200
tools

00:26:28,000 --> 00:26:32,480
from each other so the the tooling that

00:26:31,200 --> 00:26:35,279
collects the data

00:26:32,480 --> 00:26:36,000
from the tooling that makes utility of

00:26:35,279 --> 00:26:38,720
that data

00:26:36,000 --> 00:26:40,480
that's very important because it's

00:26:38,720 --> 00:26:42,080
vendor agnostic which means if you

00:26:40,480 --> 00:26:43,919
change your monitoring tools you don't

00:26:42,080 --> 00:26:48,320
have to change the way you collect that

00:26:43,919 --> 00:26:51,600
those tools it allows you to centralize

00:26:48,320 --> 00:26:54,320
and be consistent what you do with

00:26:51,600 --> 00:26:57,039
tags if you want to implement business

00:26:54,320 --> 00:26:58,960
processes like redaction of pii

00:26:57,039 --> 00:27:01,279
before it gets into the monitoring tool

00:26:58,960 --> 00:27:04,080
you get to centralize that logic

00:27:01,279 --> 00:27:04,880
so that as you scale and add new

00:27:04,080 --> 00:27:07,679
services

00:27:04,880 --> 00:27:08,159
it's consistent across all your services

00:27:07,679 --> 00:27:10,559
across

00:27:08,159 --> 00:27:11,520
all your infrastructure with no

00:27:10,559 --> 00:27:14,480
additional

00:27:11,520 --> 00:27:15,520
effort it also brings additional

00:27:14,480 --> 00:27:17,840
capabilities

00:27:15,520 --> 00:27:18,720
that you might not find in proprietary

00:27:17,840 --> 00:27:21,760
agents

00:27:18,720 --> 00:27:25,600
like compression encryption and logic

00:27:21,760 --> 00:27:28,640
around high performance and availability

00:27:25,600 --> 00:27:30,880
really it reduces the time to value so

00:27:28,640 --> 00:27:34,640
it reduces the amount of time

00:27:30,880 --> 00:27:36,640
from onboarding a new service to getting

00:27:34,640 --> 00:27:38,320
value and utility from the data from

00:27:36,640 --> 00:27:39,360
that service because you don't have to

00:27:38,320 --> 00:27:40,240
think about how you're going to

00:27:39,360 --> 00:27:42,880
instrument

00:27:40,240 --> 00:27:44,480
you're going to set a standard one

00:27:42,880 --> 00:27:45,360
standard for your organization that's

00:27:44,480 --> 00:27:47,520
going to be used

00:27:45,360 --> 00:27:48,640
no matter the infrastructure no matter

00:27:47,520 --> 00:27:51,200
the the

00:27:48,640 --> 00:27:52,880
um application there might be variations

00:27:51,200 --> 00:27:55,200
of that but even those variations are

00:27:52,880 --> 00:27:56,960
standardized so there's no question

00:27:55,200 --> 00:27:59,120
when you onboard a new service or you

00:27:56,960 --> 00:28:01,919
make a change to your service

00:27:59,120 --> 00:28:03,279
if you have to make a change to the the

00:28:01,919 --> 00:28:07,279
data collection

00:28:03,279 --> 00:28:10,080
as well objectives

00:28:07,279 --> 00:28:11,200
should be very clear but these are also

00:28:10,080 --> 00:28:13,919
the objectives

00:28:11,200 --> 00:28:14,720
of of the project to offer a vendor

00:28:13,919 --> 00:28:17,520
agnostic

00:28:14,720 --> 00:28:17,840
implementation of receiving processing

00:28:17,520 --> 00:28:21,120
and

00:28:17,840 --> 00:28:24,240
exporting to telemetry

00:28:21,120 --> 00:28:27,760
across from application

00:28:24,240 --> 00:28:30,080
to monitoring we want to make it

00:28:27,760 --> 00:28:31,840
very easy to use so everybody in the

00:28:30,080 --> 00:28:34,799
project is committed

00:28:31,840 --> 00:28:36,559
to increasing the ease of use of

00:28:34,799 --> 00:28:40,399
deploying the open telemetry

00:28:36,559 --> 00:28:41,600
collector working with the processors or

00:28:40,399 --> 00:28:44,320
the data

00:28:41,600 --> 00:28:45,760
and also exporting that data to your

00:28:44,320 --> 00:28:48,000
management plan

00:28:45,760 --> 00:28:50,480
want to have consistent formatting

00:28:48,000 --> 00:28:51,679
across all metadata across all traces

00:28:50,480 --> 00:28:55,520
spans logs

00:28:51,679 --> 00:28:59,440
metrics and all of this is to improve

00:28:55,520 --> 00:29:00,399
observability um by being built by a

00:28:59,440 --> 00:29:04,080
community

00:29:00,399 --> 00:29:07,120
of industry uh leading vendors as well

00:29:04,080 --> 00:29:09,760
as practitioners they are building their

00:29:07,120 --> 00:29:10,720
best practices into the technology as

00:29:09,760 --> 00:29:12,559
well

00:29:10,720 --> 00:29:14,000
there also is the ability to make it

00:29:12,559 --> 00:29:16,640
extensible so

00:29:14,000 --> 00:29:18,559
the the platform for building plug-ins

00:29:16,640 --> 00:29:21,440
into open telemetry

00:29:18,559 --> 00:29:23,039
because there is no one-size-fits-all

00:29:21,440 --> 00:29:26,080
application and environment

00:29:23,039 --> 00:29:30,159
is also tremendous to reduce the

00:29:26,080 --> 00:29:33,600
time to value of creating those custom

00:29:30,159 --> 00:29:36,880
integrations and then there is a single

00:29:33,600 --> 00:29:38,399
code base um there is the contributor

00:29:36,880 --> 00:29:41,440
code base

00:29:38,399 --> 00:29:42,640
as well as any extensions of that but it

00:29:41,440 --> 00:29:45,120
is a single

00:29:42,640 --> 00:29:45,840
code base for the collector uh to

00:29:45,120 --> 00:29:49,760
support

00:29:45,840 --> 00:29:52,840
logs traces or today traces

00:29:49,760 --> 00:29:54,240
and metrics in spans and in the future

00:29:52,840 --> 00:29:57,200
logs

00:29:54,240 --> 00:29:59,279
the components of the project are the

00:29:57,200 --> 00:30:00,799
specification the standard this is very

00:29:59,279 --> 00:30:01,840
important because this is what

00:30:00,799 --> 00:30:06,159
everything is built

00:30:01,840 --> 00:30:09,200
on so those are going to define

00:30:06,159 --> 00:30:13,120
how traces spans metrics logs

00:30:09,200 --> 00:30:15,279
are sent and structured

00:30:13,120 --> 00:30:16,880
um so it's it's very much around the

00:30:15,279 --> 00:30:20,399
data and cement

00:30:16,880 --> 00:30:22,480
uh semantic conventions around the data

00:30:20,399 --> 00:30:24,159
specifications like this can be hard to

00:30:22,480 --> 00:30:26,000
consume but it's important to understand

00:30:24,159 --> 00:30:27,840
that the specification is there

00:30:26,000 --> 00:30:30,000
and the collector and the client

00:30:27,840 --> 00:30:32,799
libraries are all implementations

00:30:30,000 --> 00:30:34,880
of that specification it may be useful

00:30:32,799 --> 00:30:36,960
for you to review the specifications so

00:30:34,880 --> 00:30:40,399
you understand

00:30:36,960 --> 00:30:42,640
the why between how these collectors

00:30:40,399 --> 00:30:44,399
and client libraries work and why it

00:30:42,640 --> 00:30:45,679
matters to your organization to

00:30:44,399 --> 00:30:47,279
standardize that

00:30:45,679 --> 00:30:49,679
then of course we have the collectors

00:30:47,279 --> 00:30:53,760
themselves which could be the agents

00:30:49,679 --> 00:30:56,080
or how it's implemented in code uh

00:30:53,760 --> 00:30:58,240
with client libraries now that's an

00:30:56,080 --> 00:31:00,640
important distinction to make

00:30:58,240 --> 00:31:01,279
um there's benefits to implementing in

00:31:00,640 --> 00:31:04,720
code

00:31:01,279 --> 00:31:07,200
there's benefits to using agents

00:31:04,720 --> 00:31:08,399
and which one you choose is going to be

00:31:07,200 --> 00:31:11,679
based on several

00:31:08,399 --> 00:31:12,240
several aspects whether the the stack

00:31:11,679 --> 00:31:14,320
your

00:31:12,240 --> 00:31:15,600
the language that you are writing your

00:31:14,320 --> 00:31:18,399
applications in

00:31:15,600 --> 00:31:18,880
has auto instrumentation but also a lot

00:31:18,399 --> 00:31:20,720
of times

00:31:18,880 --> 00:31:23,039
organizations have varied stacks where

00:31:20,720 --> 00:31:24,799
each service is written or

00:31:23,039 --> 00:31:27,200
services are written in multiple

00:31:24,799 --> 00:31:31,279
different languages in that case

00:31:27,200 --> 00:31:32,640
in order to embrace ease of use

00:31:31,279 --> 00:31:34,960
where you might have auto

00:31:32,640 --> 00:31:35,760
instrumentation for one stack and not

00:31:34,960 --> 00:31:38,880
the other

00:31:35,760 --> 00:31:39,919
maybe you use agents across all other on

00:31:38,880 --> 00:31:41,600
the agent side

00:31:39,919 --> 00:31:44,399
you know you have to think about things

00:31:41,600 --> 00:31:47,679
like scalability a lot of times

00:31:44,399 --> 00:31:49,440
it's easier to scale agents than to

00:31:47,679 --> 00:31:51,200
teach your development and engineering

00:31:49,440 --> 00:31:53,200
teams best practices

00:31:51,200 --> 00:31:55,440
around implementing with client

00:31:53,200 --> 00:31:55,919
libraries so there is a lot to consider

00:31:55,440 --> 00:31:57,840
here

00:31:55,919 --> 00:32:00,000
and a lot of it is not necessarily

00:31:57,840 --> 00:32:02,320
technological a lot of it has to do with

00:32:00,000 --> 00:32:05,360
the application architecture itself

00:32:02,320 --> 00:32:08,080
the size of your engineering teams and

00:32:05,360 --> 00:32:09,120
the growth how how the application is

00:32:08,080 --> 00:32:11,679
evolving

00:32:09,120 --> 00:32:13,360
over time you might have a combination

00:32:11,679 --> 00:32:14,559
normally you see organization

00:32:13,360 --> 00:32:17,679
standardizing

00:32:14,559 --> 00:32:18,640
on either in application or agent-based

00:32:17,679 --> 00:32:24,640
implementation

00:32:18,640 --> 00:32:26,559
of the open telemetry collector

00:32:24,640 --> 00:32:29,039
the components of the collector are

00:32:26,559 --> 00:32:32,559
fairly straightforward

00:32:29,039 --> 00:32:35,600
both for traces and metrics you have

00:32:32,559 --> 00:32:38,000
receivers and exporters

00:32:35,600 --> 00:32:38,640
there's a lot of standard receivers out

00:32:38,000 --> 00:32:42,159
there

00:32:38,640 --> 00:32:45,600
like jager and zipkin but there is also

00:32:42,159 --> 00:32:49,440
the otlp which is

00:32:45,600 --> 00:32:53,679
a standard format both for a receiver

00:32:49,440 --> 00:32:54,720
and exporter on the traces span that's

00:32:53,679 --> 00:32:56,799
typically where

00:32:54,720 --> 00:32:58,640
or the traces side that's typically

00:32:56,799 --> 00:33:02,559
where it's going to end because these

00:32:58,640 --> 00:33:05,360
are very common ways of getting traces

00:33:02,559 --> 00:33:06,080
and or traces and spans out of your

00:33:05,360 --> 00:33:08,880
application

00:33:06,080 --> 00:33:11,440
on the metric side you might have other

00:33:08,880 --> 00:33:14,559
receivers such as prometheus

00:33:11,440 --> 00:33:18,399
um and you your host

00:33:14,559 --> 00:33:22,159
by itself so data around cpu disk memory

00:33:18,399 --> 00:33:23,200
etc otlp the hope is that this is going

00:33:22,159 --> 00:33:25,600
to become

00:33:23,200 --> 00:33:26,720
the more common use case not to be

00:33:25,600 --> 00:33:29,840
confused

00:33:26,720 --> 00:33:33,679
with oltp which

00:33:29,840 --> 00:33:36,159
is another protocol out there

00:33:33,679 --> 00:33:36,720
but the hope is that organizations will

00:33:36,159 --> 00:33:40,080
embrace

00:33:36,720 --> 00:33:42,320
that as a best of breed for also

00:33:40,080 --> 00:33:43,360
making sure that your receivers and your

00:33:42,320 --> 00:33:48,000
exporters

00:33:43,360 --> 00:33:51,200
are based on open standards as well

00:33:48,000 --> 00:33:54,559
as the collector itself then you have

00:33:51,200 --> 00:33:57,919
processors so these are what manipulate

00:33:54,559 --> 00:33:59,440
the data essentially in stream within

00:33:57,919 --> 00:34:02,799
the collector

00:33:59,440 --> 00:34:04,480
um you can do it in in simple

00:34:02,799 --> 00:34:07,120
you know processing you can do it

00:34:04,480 --> 00:34:10,800
batched based

00:34:07,120 --> 00:34:12,480
there's logic here for high availability

00:34:10,800 --> 00:34:13,200
to make sure that there's retries and

00:34:12,480 --> 00:34:14,800
the data

00:34:13,200 --> 00:34:16,639
you know the transaction doesn't fail

00:34:14,800 --> 00:34:18,800
with inside of the processor

00:34:16,639 --> 00:34:20,000
you can implement sampling here if you

00:34:18,800 --> 00:34:22,480
choose to

00:34:20,000 --> 00:34:24,560
depending on the best practices we tend

00:34:22,480 --> 00:34:25,359
to take the approach that you should not

00:34:24,560 --> 00:34:27,359
sample

00:34:25,359 --> 00:34:28,800
and you should have full fidelity in

00:34:27,359 --> 00:34:30,720
traces and spans

00:34:28,800 --> 00:34:33,040
as well as the cardinality which is

00:34:30,720 --> 00:34:34,000
essentially all the permeations of

00:34:33,040 --> 00:34:36,399
metadata

00:34:34,000 --> 00:34:38,240
around the tracing spans but for

00:34:36,399 --> 00:34:39,359
different reasons you may choose to

00:34:38,240 --> 00:34:41,040
implement sample

00:34:39,359 --> 00:34:42,800
sampling and you can do that in the

00:34:41,040 --> 00:34:44,879
processor processors

00:34:42,800 --> 00:34:46,839
today are available in traces but not

00:34:44,879 --> 00:34:49,679
yet

00:34:46,839 --> 00:34:51,679
metrics

00:34:49,679 --> 00:34:53,599
there are other important aspects of the

00:34:51,679 --> 00:34:55,919
project um

00:34:53,599 --> 00:34:57,280
i've already kind of beat up on the idea

00:34:55,919 --> 00:35:00,240
that you know there

00:34:57,280 --> 00:35:02,160
is there's a huge community but there is

00:35:00,240 --> 00:35:03,839
also a really strong governance board

00:35:02,160 --> 00:35:04,560
because we do have a lot of vendors

00:35:03,839 --> 00:35:07,760
involved

00:35:04,560 --> 00:35:10,480
this implements the the code of conduct

00:35:07,760 --> 00:35:12,720
um is the steering committee for driving

00:35:10,480 --> 00:35:14,160
the technical direction of the project

00:35:12,720 --> 00:35:16,000
and making sure that things like

00:35:14,160 --> 00:35:19,119
documentation which are such a

00:35:16,000 --> 00:35:23,040
huge component of any platform

00:35:19,119 --> 00:35:26,960
any technology um are updated current

00:35:23,040 --> 00:35:30,320
and there and communicated with the

00:35:26,960 --> 00:35:32,960
community and then there is

00:35:30,320 --> 00:35:34,240
protocols so a lot of work being done

00:35:32,960 --> 00:35:37,599
around the otlp

00:35:34,240 --> 00:35:40,320
protocol um to create so more

00:35:37,599 --> 00:35:41,440
standards around getting data into the

00:35:40,320 --> 00:35:45,280
processors

00:35:41,440 --> 00:35:47,599
um from a exporter and receiva so in and

00:35:45,280 --> 00:35:47,599
out

00:35:49,200 --> 00:35:56,000
so let's look briefly at

00:35:52,320 --> 00:35:59,200
uh again what the collector is

00:35:56,000 --> 00:36:02,480
so it's a vendor agnostic implementation

00:35:59,200 --> 00:36:05,520
of the open telemetry standards

00:36:02,480 --> 00:36:08,000
it is a single binary

00:36:05,520 --> 00:36:08,960
um that can be deployed in different

00:36:08,000 --> 00:36:12,079
ways

00:36:08,960 --> 00:36:15,359
either as an agent and

00:36:12,079 --> 00:36:17,119
and or a gateway and then of course the

00:36:15,359 --> 00:36:17,440
client libraries are going to be what

00:36:17,119 --> 00:36:21,280
are

00:36:17,440 --> 00:36:25,040
implemented in application

00:36:21,280 --> 00:36:29,359
and it is the default destination of

00:36:25,040 --> 00:36:29,359
the client library data

00:36:34,960 --> 00:36:38,400
now let's look at the architecture of

00:36:37,280 --> 00:36:41,520
the collector

00:36:38,400 --> 00:36:42,480
so as i said you have receivers so

00:36:41,520 --> 00:36:45,839
you're going to go

00:36:42,480 --> 00:36:46,800
and define your receivers how you're

00:36:45,839 --> 00:36:50,560
getting data

00:36:46,800 --> 00:36:53,280
into the platform so the protocol

00:36:50,560 --> 00:36:54,240
the type of receiver and any

00:36:53,280 --> 00:36:56,720
configuration

00:36:54,240 --> 00:36:59,200
attributes to that then you're also

00:36:56,720 --> 00:37:02,320
going to have your exporters

00:36:59,200 --> 00:37:06,000
this is the destination of

00:37:02,320 --> 00:37:07,599
the data it's going it could be

00:37:06,000 --> 00:37:09,480
well it is going to be some sort of

00:37:07,599 --> 00:37:12,960
endpoint and some sort of

00:37:09,480 --> 00:37:14,720
authentication to that endpoint

00:37:12,960 --> 00:37:16,720
and then finally you have everything in

00:37:14,720 --> 00:37:19,760
between where a lot of magic

00:37:16,720 --> 00:37:22,320
can happen so these are

00:37:19,760 --> 00:37:23,680
your processors this is the relationship

00:37:22,320 --> 00:37:27,359
between the receiver

00:37:23,680 --> 00:37:27,760
your processors the the manipulation you

00:37:27,359 --> 00:37:30,880
do

00:37:27,760 --> 00:37:35,040
on top of the data all prior to getting

00:37:30,880 --> 00:37:37,280
to your destination via the exporter

00:37:35,040 --> 00:37:38,160
the cool thing is is it's not one for

00:37:37,280 --> 00:37:41,200
one

00:37:38,160 --> 00:37:44,240
so you can create multiple um

00:37:41,200 --> 00:37:46,640
destinations with multiple receivers or

00:37:44,240 --> 00:37:48,800
one receiver to multiple destinations

00:37:46,640 --> 00:37:50,640
like i said you know the hope is that

00:37:48,800 --> 00:37:54,240
there's a standardization around

00:37:50,640 --> 00:37:57,200
otlp but organizations need to adapt and

00:37:54,240 --> 00:37:58,720
this is exactly the point you might be

00:37:57,200 --> 00:38:01,280
adapting your receivers

00:37:58,720 --> 00:38:02,320
but you don't have to change how you

00:38:01,280 --> 00:38:04,880
collect that data

00:38:02,320 --> 00:38:06,640
you might be adapting your exporters but

00:38:04,880 --> 00:38:08,640
you don't need to change how you collect

00:38:06,640 --> 00:38:12,000
your data because that is a

00:38:08,640 --> 00:38:15,359
an immutable element of your

00:38:12,000 --> 00:38:19,040
your environment and the infrastructure

00:38:15,359 --> 00:38:21,440
that you're managing

00:38:19,040 --> 00:38:22,640
now as i said before there is this

00:38:21,440 --> 00:38:25,200
capability of building

00:38:22,640 --> 00:38:26,240
extensions or add-ins that might be

00:38:25,200 --> 00:38:28,160
specific

00:38:26,240 --> 00:38:29,440
around what you're what you're doing the

00:38:28,160 --> 00:38:32,240
community has built

00:38:29,440 --> 00:38:32,880
a lot of these always interesting to

00:38:32,240 --> 00:38:36,320
look at

00:38:32,880 --> 00:38:40,960
as you look at especially business logic

00:38:36,320 --> 00:38:40,960
and manipulation of the data in string

00:38:41,040 --> 00:38:45,680
so let's take another look of how this

00:38:43,839 --> 00:38:48,800
kind of comes together

00:38:45,680 --> 00:38:51,119
you have the agent you have

00:38:48,800 --> 00:38:52,160
client libraries on the application

00:38:51,119 --> 00:38:54,800
level

00:38:52,160 --> 00:38:56,079
or you're going to have tooling on the

00:38:54,800 --> 00:38:58,880
infrastructure level

00:38:56,079 --> 00:38:59,680
we haven't yet talked about serverless

00:38:58,880 --> 00:39:02,480
there might be

00:38:59,680 --> 00:39:03,359
certain wrappers around serverless so

00:39:02,480 --> 00:39:05,280
you can get

00:39:03,359 --> 00:39:07,359
the telemetry data from serverless

00:39:05,280 --> 00:39:10,400
applications as well

00:39:07,359 --> 00:39:13,760
and those are going to go through a

00:39:10,400 --> 00:39:16,480
gateway and eventually oops

00:39:13,760 --> 00:39:18,800
eventually make it to your observability

00:39:16,480 --> 00:39:18,800
tool

00:39:19,040 --> 00:39:22,240
how you're going to get started is more

00:39:20,800 --> 00:39:25,440
or less the same whether

00:39:22,240 --> 00:39:29,200
it's traces or metrics you

00:39:25,440 --> 00:39:32,320
instantiate in your

00:39:29,200 --> 00:39:34,320
client library or via an agent who's

00:39:32,320 --> 00:39:36,560
the is the instantiation you're going to

00:39:34,320 --> 00:39:39,599
instantiate a tracer

00:39:36,560 --> 00:39:41,920
or a meter you're going to

00:39:39,599 --> 00:39:43,599
create your infrastructure your

00:39:41,920 --> 00:39:47,119
application is going to create

00:39:43,599 --> 00:39:47,599
metrics or spans you're going to enhance

00:39:47,119 --> 00:39:50,960
those

00:39:47,599 --> 00:39:54,079
with metadata potentially tags etc

00:39:50,960 --> 00:39:57,680
and then you're going to have some sort

00:39:54,079 --> 00:40:01,680
of observer of that data prior to

00:39:57,680 --> 00:40:01,680
sending it to your monitoring plane

00:40:01,760 --> 00:40:06,880
the binaries are available in in all the

00:40:05,040 --> 00:40:10,319
areas you would expect

00:40:06,880 --> 00:40:11,119
linux windows but there is also yaml and

00:40:10,319 --> 00:40:15,040
helm

00:40:11,119 --> 00:40:18,240
charts for kubernetes and

00:40:15,040 --> 00:40:20,720
of course you could imagine all of these

00:40:18,240 --> 00:40:25,839
packages are going to expand

00:40:20,720 --> 00:40:29,040
as the project goes into other areas

00:40:25,839 --> 00:40:32,640
now it is written and go

00:40:29,040 --> 00:40:35,119
so it is a compiled

00:40:32,640 --> 00:40:36,079
technology and that's important to

00:40:35,119 --> 00:40:39,280
understand

00:40:36,079 --> 00:40:42,079
because it also creates um you know

00:40:39,280 --> 00:40:44,560
a lot of stability and supports the

00:40:42,079 --> 00:40:47,359
performance of the application

00:40:44,560 --> 00:40:48,640
so let's take a look quickly um about

00:40:47,359 --> 00:40:51,040
how this is implemented

00:40:48,640 --> 00:40:52,319
and and you know i say this is somewhat

00:40:51,040 --> 00:40:55,359
trivial

00:40:52,319 --> 00:40:57,760
it is this is in javascript

00:40:55,359 --> 00:40:58,560
basically the process is you create your

00:40:57,760 --> 00:41:03,359
tracer

00:40:58,560 --> 00:41:06,079
as we said you start to

00:41:03,359 --> 00:41:07,119
create span data coming from your

00:41:06,079 --> 00:41:09,440
application

00:41:07,119 --> 00:41:12,720
so you're going to start your span

00:41:09,440 --> 00:41:12,720
you're going to close your span

00:41:12,880 --> 00:41:15,920
with inside of your span you're going to

00:41:15,440 --> 00:41:19,520
apply

00:41:15,920 --> 00:41:20,400
attributes and and values associated

00:41:19,520 --> 00:41:22,880
with it

00:41:20,400 --> 00:41:25,040
i want to highlight that aspect because

00:41:22,880 --> 00:41:27,760
once it gets to the monitoring plane

00:41:25,040 --> 00:41:30,319
these attributes and the relationship

00:41:27,760 --> 00:41:34,000
between the attributes are a key

00:41:30,319 --> 00:41:36,960
element to reducing mttr on

00:41:34,000 --> 00:41:38,400
your application so when you're triaging

00:41:36,960 --> 00:41:41,680
and troubleshooting

00:41:38,400 --> 00:41:45,280
your application you need to be able to

00:41:41,680 --> 00:41:48,319
use these attributes as dimensions

00:41:45,280 --> 00:41:50,160
for looking at a service map which is

00:41:48,319 --> 00:41:52,800
what i showed before the relationship

00:41:50,160 --> 00:41:55,359
between all your services

00:41:52,800 --> 00:41:55,920
as a way to identify the root cause of

00:41:55,359 --> 00:41:58,319
issues

00:41:55,920 --> 00:41:59,520
because in a micro services based

00:41:58,319 --> 00:42:02,160
application

00:41:59,520 --> 00:42:03,200
the service that delivers the alert is

00:42:02,160 --> 00:42:05,599
not often

00:42:03,200 --> 00:42:07,839
the source of the alert that's exactly

00:42:05,599 --> 00:42:09,280
why you need traces and spans but within

00:42:07,839 --> 00:42:10,720
those traces

00:42:09,280 --> 00:42:13,280
you want to be able to look at the

00:42:10,720 --> 00:42:15,920
dimensions to really identify

00:42:13,280 --> 00:42:16,319
is the issue happening in what service

00:42:15,920 --> 00:42:17,680
is an

00:42:16,319 --> 00:42:19,359
application issue or is it an

00:42:17,680 --> 00:42:22,880
infrastructure issue

00:42:19,359 --> 00:42:26,160
and can we start to double click into

00:42:22,880 --> 00:42:26,960
things like um the customers being

00:42:26,160 --> 00:42:30,319
impacted

00:42:26,960 --> 00:42:31,760
um via tenants the version because you

00:42:30,319 --> 00:42:33,040
might have multiple versions of a

00:42:31,760 --> 00:42:36,240
service deployed

00:42:33,040 --> 00:42:37,119
across your application etc very very

00:42:36,240 --> 00:42:39,839
important

00:42:37,119 --> 00:42:42,800
element and again this is an

00:42:39,839 --> 00:42:44,960
infrastructure architecture challenge

00:42:42,800 --> 00:42:46,319
how you define these it's not a

00:42:44,960 --> 00:42:47,119
technology challenge so you need to

00:42:46,319 --> 00:42:50,079
think about this

00:42:47,119 --> 00:42:52,240
in advance for successful um

00:42:50,079 --> 00:42:54,960
troubleshooting you can always update it

00:42:52,240 --> 00:42:56,000
of course but it's better if you have an

00:42:54,960 --> 00:42:59,119
understanding

00:42:56,000 --> 00:43:02,720
uh to begin with so

00:42:59,119 --> 00:43:05,839
again i'm gonna go back

00:43:02,720 --> 00:43:09,200
um this is a manual implementation

00:43:05,839 --> 00:43:12,400
in javascript wouldn't it be nice

00:43:09,200 --> 00:43:15,440
not to do it manually so seeking out

00:43:12,400 --> 00:43:17,839
um auto instrumentation for your stack

00:43:15,440 --> 00:43:18,880
for your programming language is very

00:43:17,839 --> 00:43:22,400
helpful

00:43:18,880 --> 00:43:25,680
um this is how it's done with java

00:43:22,400 --> 00:43:26,000
and it of course makes every everybody's

00:43:25,680 --> 00:43:28,720
lives

00:43:26,000 --> 00:43:29,599
easier especially when you want to do

00:43:28,720 --> 00:43:32,240
this at scale

00:43:29,599 --> 00:43:33,280
the auto instrumentation is critical so

00:43:32,240 --> 00:43:35,599
always keep your eye

00:43:33,280 --> 00:43:37,280
on the roadmap for that if auto

00:43:35,599 --> 00:43:40,640
instrumentation is available

00:43:37,280 --> 00:43:44,800
leverage it if it's not maybe you

00:43:40,640 --> 00:43:46,319
you um default to agents instead

00:43:44,800 --> 00:43:48,640
the other and the other thing that's

00:43:46,319 --> 00:43:51,119
important is is not to

00:43:48,640 --> 00:43:52,000
mix and match your auto instrumentation

00:43:51,119 --> 00:43:55,200
um use

00:43:52,000 --> 00:43:58,640
one and only one

00:43:55,200 --> 00:43:59,839
now same is true with metrics very easy

00:43:58,640 --> 00:44:02,000
to implement

00:43:59,839 --> 00:44:03,040
today the auto instrumentation doesn't

00:44:02,000 --> 00:44:05,760
exist

00:44:03,040 --> 00:44:06,480
and but the implementation is not

00:44:05,760 --> 00:44:09,760
difficult

00:44:06,480 --> 00:44:12,480
so you instantiate the

00:44:09,760 --> 00:44:13,599
the meter within the meter you're going

00:44:12,480 --> 00:44:16,319
to define

00:44:13,599 --> 00:44:17,280
your your units of measurement and then

00:44:16,319 --> 00:44:20,560
you're going to create

00:44:17,280 --> 00:44:25,040
an observer to get that data out of

00:44:20,560 --> 00:44:27,280
your logs so i want to reiterate and i'm

00:44:25,040 --> 00:44:29,200
going to leave this screen up here

00:44:27,280 --> 00:44:30,720
for a few seconds here so you can

00:44:29,200 --> 00:44:31,040
screenshot it because there's a lot of

00:44:30,720 --> 00:44:34,000
great

00:44:31,040 --> 00:44:35,280
resources but before we go through those

00:44:34,000 --> 00:44:38,319
open telemetry

00:44:35,280 --> 00:44:41,520
is a cncf open source project

00:44:38,319 --> 00:44:44,160
which is critical to unshackling

00:44:41,520 --> 00:44:45,760
how you get data and telemetry from your

00:44:44,160 --> 00:44:48,319
infrastructure and applications

00:44:45,760 --> 00:44:50,079
into your management plane it brings the

00:44:48,319 --> 00:44:53,359
additional benefit

00:44:50,079 --> 00:44:54,960
of having processors and logics that you

00:44:53,359 --> 00:44:58,319
can apply on that data

00:44:54,960 --> 00:45:01,599
in stream and create multiple paths

00:44:58,319 --> 00:45:04,560
for that data the reason we do this

00:45:01,599 --> 00:45:05,839
though is not just to streamline and

00:45:04,560 --> 00:45:08,480
create more efficiency

00:45:05,839 --> 00:45:09,920
in our environment there's also the

00:45:08,480 --> 00:45:13,440
business side of it

00:45:09,920 --> 00:45:16,160
it makes sure that as

00:45:13,440 --> 00:45:17,599
your delivery chain changes and as your

00:45:16,160 --> 00:45:20,240
management plane

00:45:17,599 --> 00:45:22,000
changes you do not have to change how

00:45:20,240 --> 00:45:24,640
you think about collecting

00:45:22,000 --> 00:45:25,280
that data which is absolutely critical

00:45:24,640 --> 00:45:28,480
because

00:45:25,280 --> 00:45:31,839
if a proprietary agent determines

00:45:28,480 --> 00:45:33,760
how you manage

00:45:31,839 --> 00:45:35,040
your operating plane then it can be the

00:45:33,760 --> 00:45:37,680
difference between

00:45:35,040 --> 00:45:39,280
saying yes or no to something that could

00:45:37,680 --> 00:45:43,040
be extremely useful

00:45:39,280 --> 00:45:45,520
in your environment open telemetry

00:45:43,040 --> 00:45:47,839
starts with the standards the collector

00:45:45,520 --> 00:45:50,880
and the agent are implementations

00:45:47,839 --> 00:45:54,319
of those standards they are composed of

00:45:50,880 --> 00:45:56,160
receivers which take data from

00:45:54,319 --> 00:45:57,440
metrics traces and spans in in the

00:45:56,160 --> 00:46:00,560
future logs

00:45:57,440 --> 00:46:03,040
from your application and infrastructure

00:46:00,560 --> 00:46:04,079
exporters which deliver that to your

00:46:03,040 --> 00:46:06,400
management plane

00:46:04,079 --> 00:46:08,480
and then in the middle is a bunch of

00:46:06,400 --> 00:46:11,280
amazing technology for processing

00:46:08,480 --> 00:46:14,400
manipulating and creating

00:46:11,280 --> 00:46:16,960
resilience around that data

00:46:14,400 --> 00:46:18,960
so we firmly believe in this project the

00:46:16,960 --> 00:46:20,640
community believes in this project and i

00:46:18,960 --> 00:46:24,319
hope you consider it

00:46:20,640 --> 00:46:24,800
as the foundation of the relationship

00:46:24,319 --> 00:46:27,200
between

00:46:24,800 --> 00:46:28,000
how you monitor and operate and the

00:46:27,200 --> 00:46:30,720
applications

00:46:28,000 --> 00:46:31,520
themselves there's a ton of information

00:46:30,720 --> 00:46:33,520
out there

00:46:31,520 --> 00:46:35,440
i gave you a ton of information i

00:46:33,520 --> 00:46:37,680
understand that but here are some great

00:46:35,440 --> 00:46:39,760
resources around the specification

00:46:37,680 --> 00:46:41,040
around the collector there is a

00:46:39,760 --> 00:46:44,960
fantastic

00:46:41,040 --> 00:46:46,880
cnc f demo from steve flanders who is

00:46:44,960 --> 00:46:48,000
somebody on my team who has taught me

00:46:46,880 --> 00:46:50,640
everything pretty much

00:46:48,000 --> 00:46:53,040
everything i know about open telemetry

00:46:50,640 --> 00:46:54,960
and a big contributor to the project

00:46:53,040 --> 00:46:56,319
go watch that it includes everything i

00:46:54,960 --> 00:46:59,599
showed today including

00:46:56,319 --> 00:47:01,520
a demo there's also a webinar i told you

00:46:59,599 --> 00:47:03,280
that tags are a critical aspect of

00:47:01,520 --> 00:47:04,960
getting value from the data

00:47:03,280 --> 00:47:06,800
utility once you get it into the

00:47:04,960 --> 00:47:08,960
application and

00:47:06,800 --> 00:47:10,560
that's something that the team needs to

00:47:08,960 --> 00:47:11,520
determine from an architecture

00:47:10,560 --> 00:47:14,240
standpoint

00:47:11,520 --> 00:47:16,160
so there is a webinar for that here i

00:47:14,240 --> 00:47:19,040
wrote a blog post on the business value

00:47:16,160 --> 00:47:19,920
of open telemetry on devops.com you can

00:47:19,040 --> 00:47:22,720
view that

00:47:19,920 --> 00:47:25,040
as well as just a lot of information on

00:47:22,720 --> 00:47:27,359
getting statistics around the project

00:47:25,040 --> 00:47:28,960
more detail around resources learning

00:47:27,359 --> 00:47:31,599
more just around

00:47:28,960 --> 00:47:33,119
observability traces and spans in

00:47:31,599 --> 00:47:35,680
general

00:47:33,119 --> 00:47:38,000
thank you for your time please reach out

00:47:35,680 --> 00:47:39,680
and connect let me know if you have any

00:47:38,000 --> 00:47:42,480
questions let me know what you think of

00:47:39,680 --> 00:47:44,880
this session or that you just saw it

00:47:42,480 --> 00:47:46,559
i always love connecting with people who

00:47:44,880 --> 00:47:49,359
have

00:47:46,559 --> 00:47:50,079
joined me in my talks thank you have a

00:47:49,359 --> 00:48:01,280
great day

00:47:50,079 --> 00:48:01,280

YouTube URL: https://www.youtube.com/watch?v=2Zr9ADZdbh0


