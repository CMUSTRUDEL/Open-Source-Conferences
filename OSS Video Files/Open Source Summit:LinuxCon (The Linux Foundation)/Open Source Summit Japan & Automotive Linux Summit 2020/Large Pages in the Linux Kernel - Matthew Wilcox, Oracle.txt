Title: Large Pages in the Linux Kernel - Matthew Wilcox, Oracle
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Large Pages in the Linux Kernel - Matthew Wilcox, Oracle
Captions: 
	00:00:00,640 --> 00:00:04,640
good morning everybody my name is

00:00:03,199 --> 00:00:06,240
matthew wilcox and i'm a technical

00:00:04,640 --> 00:00:08,080
advisor at oracle

00:00:06,240 --> 00:00:10,080
i'm in the vince caron development team

00:00:08,080 --> 00:00:13,840
i've been a lunch calm developer

00:00:10,080 --> 00:00:15,360
for about 20 years now

00:00:13,840 --> 00:00:18,800
i'm here to talk to you today about

00:00:15,360 --> 00:00:22,560
large pay using large pages and linux

00:00:18,800 --> 00:00:25,680
so the when when we talk about

00:00:22,560 --> 00:00:28,320
managing memory the uh

00:00:25,680 --> 00:00:28,720
the default units that we manage memory

00:00:28,320 --> 00:00:32,559
in

00:00:28,720 --> 00:00:35,360
is pages and uh on on the next 86

00:00:32,559 --> 00:00:37,760
cpu uh there's those pages of four

00:00:35,360 --> 00:00:39,360
kilobytes in size

00:00:37,760 --> 00:00:42,320
and so when you look at a computer like

00:00:39,360 --> 00:00:44,879
the uh oracle server x8-8

00:00:42,320 --> 00:00:45,360
uh it's eight cpu system it has up to

00:00:44,879 --> 00:00:48,320
six

00:00:45,360 --> 00:00:48,960
six terabytes of memory and that's one

00:00:48,320 --> 00:00:52,320
and a half

00:00:48,960 --> 00:00:54,399
billion four kilobyte pages and

00:00:52,320 --> 00:00:55,600
that's that's a lot of memory to that

00:00:54,399 --> 00:00:59,680
that's a lot of

00:00:55,600 --> 00:01:03,039
objects to be managing now we don't

00:00:59,680 --> 00:01:04,640
we we do divide things up a bit uh we

00:01:03,039 --> 00:01:05,439
actually divide things up in a per numer

00:01:04,640 --> 00:01:07,920
node

00:01:05,439 --> 00:01:10,560
and so there's only 192 million pages

00:01:07,920 --> 00:01:10,560
per node

00:01:11,200 --> 00:01:15,200
but still 192 million pages is a lot and

00:01:14,080 --> 00:01:17,360
in case you're thinking that

00:01:15,200 --> 00:01:18,960
this really only affects large computers

00:01:17,360 --> 00:01:21,759
it doesn't uh

00:01:18,960 --> 00:01:22,960
my laptop has 16 gigabytes of ram that's

00:01:21,759 --> 00:01:26,000
4 million pages

00:01:22,960 --> 00:01:27,600
my phone has 4 gigabytes of ram

00:01:26,000 --> 00:01:31,439
so even my phone is dealing with

00:01:27,600 --> 00:01:33,520
managing a million pages

00:01:31,439 --> 00:01:35,360
as as you can expect that takes a lot of

00:01:33,520 --> 00:01:37,680
cpu time to do

00:01:35,360 --> 00:01:39,439
uh so we use this this thing called the

00:01:37,680 --> 00:01:41,759
last recently used list

00:01:39,439 --> 00:01:43,520
so every time we access a page we take

00:01:41,759 --> 00:01:44,000
it out to its current position in the

00:01:43,520 --> 00:01:47,040
list

00:01:44,000 --> 00:01:48,799
and we move it to the beginning for less

00:01:47,040 --> 00:01:50,720
and that involves touching a lot of

00:01:48,799 --> 00:01:53,600
cache lines um

00:01:50,720 --> 00:01:54,479
modifying lots of cache lines and uh if

00:01:53,600 --> 00:01:58,320
you're on

00:01:54,479 --> 00:02:00,240
a a system that um

00:01:58,320 --> 00:02:01,920
has something better to do with its

00:02:00,240 --> 00:02:03,680
caches though those are going to be cash

00:02:01,920 --> 00:02:05,600
cold and so we're doing a lot of cache

00:02:03,680 --> 00:02:07,200
misses

00:02:05,600 --> 00:02:09,440
and those caches done with a spin lock

00:02:07,200 --> 00:02:10,959
held and there are several

00:02:09,440 --> 00:02:13,760
patches out there at the moment trying

00:02:10,959 --> 00:02:16,239
to fix the problem but

00:02:13,760 --> 00:02:18,319
an lru list uh the lock protecting the

00:02:16,239 --> 00:02:21,120
light use is heavily contended

00:02:18,319 --> 00:02:22,640
so if our lru lists were shorter we

00:02:21,120 --> 00:02:23,680
would not see the same kind of

00:02:22,640 --> 00:02:26,480
contention

00:02:23,680 --> 00:02:26,480
that we do today

00:02:27,920 --> 00:02:31,920
so how can we solve this well one of the

00:02:30,400 --> 00:02:34,640
ways that's been

00:02:31,920 --> 00:02:35,760
discussed is to manage memory in larger

00:02:34,640 --> 00:02:38,160
pages so just

00:02:35,760 --> 00:02:41,680
increase the size of a page from being

00:02:38,160 --> 00:02:46,239
the same size as the cpus

00:02:41,680 --> 00:02:48,800
to being the size of a larger size

00:02:46,239 --> 00:02:50,239
perhaps 64 kilobytes

00:02:48,800 --> 00:02:52,080
uh obviously this approach is going to

00:02:50,239 --> 00:02:54,720
waste some memory uh

00:02:52,080 --> 00:02:56,000
because things that you know if you if

00:02:54,720 --> 00:02:57,440
you have a file that's only perhaps

00:02:56,000 --> 00:02:59,920
eight kilobytes in size

00:02:57,440 --> 00:03:01,280
all of a sudden it's a using exactly

00:02:59,920 --> 00:03:03,599
eight kilobytes for it

00:03:01,280 --> 00:03:05,200
you'll be using 64 kilobytes to to cache

00:03:03,599 --> 00:03:06,400
it

00:03:05,200 --> 00:03:08,640
and maybe that's not a problem with a

00:03:06,400 --> 00:03:09,599
larger system but this is also from on

00:03:08,640 --> 00:03:12,000
phones remember

00:03:09,599 --> 00:03:14,400
and so the phones may actually also have

00:03:12,000 --> 00:03:14,400
a problem

00:03:14,879 --> 00:03:19,280
a bigger concern is that it's hard to

00:03:17,519 --> 00:03:21,680
maintain the user api

00:03:19,280 --> 00:03:22,800
because the the user api thinks it can

00:03:21,680 --> 00:03:24,799
map

00:03:22,800 --> 00:03:26,799
on four kilobyte boundary and so if

00:03:24,799 --> 00:03:27,599
we're using 64 kilobyte pages and we're

00:03:26,799 --> 00:03:30,239
trying to map

00:03:27,599 --> 00:03:32,720
and focus by granularity that starts to

00:03:30,239 --> 00:03:34,959
get quite tricky to do

00:03:32,720 --> 00:03:37,840
and so this approach has never really

00:03:34,959 --> 00:03:37,840
found much favor

00:03:38,560 --> 00:03:41,680
another approach which was attempted

00:03:40,720 --> 00:03:44,959
earlier on

00:03:41,680 --> 00:03:46,640
is to manage just page cache memory

00:03:44,959 --> 00:03:49,200
large pages this

00:03:46,640 --> 00:03:50,239
also has some of the uh difficulties of

00:03:49,200 --> 00:03:53,920
managing

00:03:50,239 --> 00:03:55,280
uh of the previous approaches managing

00:03:53,920 --> 00:03:57,439
all the memory large pages

00:03:55,280 --> 00:03:59,280
it has some benefit it has not quite as

00:03:57,439 --> 00:04:00,799
many disadvantages

00:03:59,280 --> 00:04:02,560
but it does confuse people because

00:04:00,799 --> 00:04:04,640
people are never quite sure

00:04:02,560 --> 00:04:06,159
when it is supposed to be using page

00:04:04,640 --> 00:04:07,519
size when they're supposed to using page

00:04:06,159 --> 00:04:09,439
cache size

00:04:07,519 --> 00:04:11,040
and since the two were not actually

00:04:09,439 --> 00:04:11,599
different for very long don't denote it

00:04:11,040 --> 00:04:15,040
for

00:04:11,599 --> 00:04:16,880
for a long time nobody noticed

00:04:15,040 --> 00:04:18,560
uh when people get it wrong and so we

00:04:16,880 --> 00:04:20,079
had a flurry of patches which tried to

00:04:18,560 --> 00:04:23,040
fix some of this

00:04:20,079 --> 00:04:24,400
and in the end in 2016 we we just ripped

00:04:23,040 --> 00:04:28,639
out the

00:04:24,400 --> 00:04:29,919
page cache size macros entirely

00:04:28,639 --> 00:04:32,320
so the approach that i chose to

00:04:29,919 --> 00:04:35,680
investigate here was

00:04:32,320 --> 00:04:38,960
an adaptive use of large pages that is

00:04:35,680 --> 00:04:42,240
keep page sizes the same

00:04:38,960 --> 00:04:45,520
but allocate them in multiples

00:04:42,240 --> 00:04:46,320
whenever we could and the real question

00:04:45,520 --> 00:04:47,600
translates well

00:04:46,320 --> 00:04:49,440
how do we decide when it's going to be

00:04:47,600 --> 00:04:51,759
beneficial and i'll get into that a bit

00:04:49,440 --> 00:04:51,759
later

00:04:52,160 --> 00:04:55,759
so thenx already has the capability of

00:04:54,080 --> 00:04:57,919
allocating something called a compound

00:04:55,759 --> 00:05:01,600
page

00:04:57,919 --> 00:05:05,440
uh so you a compound page is

00:05:01,600 --> 00:05:07,120
uh necessarily a power to do in size

00:05:05,440 --> 00:05:08,639
so uh if you want to get a single page

00:05:07,120 --> 00:05:10,000
that's a zero page

00:05:08,639 --> 00:05:11,759
if you want to you can add a pair of

00:05:10,000 --> 00:05:14,320
pages that's more than one page

00:05:11,759 --> 00:05:16,160
and so on if you want to read more about

00:05:14,320 --> 00:05:17,600
this it's called the buddy allocator

00:05:16,160 --> 00:05:20,000
there's a lot of good documentation on

00:05:17,600 --> 00:05:21,680
it out there

00:05:20,000 --> 00:05:24,000
so the first page is called the head

00:05:21,680 --> 00:05:25,759
page and then all the other pages the

00:05:24,000 --> 00:05:28,800
tail pages

00:05:25,759 --> 00:05:30,240
which points to the head page and if you

00:05:28,800 --> 00:05:33,360
try and call

00:05:30,240 --> 00:05:34,639
a function on a tail page like lock page

00:05:33,360 --> 00:05:37,120
it will actually redirect to the head

00:05:34,639 --> 00:05:40,080
page it will lock the head page

00:05:37,120 --> 00:05:41,120
and this uh this this can confuse people

00:05:40,080 --> 00:05:42,800
when they try and

00:05:41,120 --> 00:05:44,800
lock one tail page and lock the next

00:05:42,800 --> 00:05:46,160
tail page and then they find that

00:05:44,800 --> 00:05:46,960
actually they're just dead locked

00:05:46,160 --> 00:05:48,880
because

00:05:46,960 --> 00:05:50,320
they've just tried to lock the same page

00:05:48,880 --> 00:05:52,479
twice

00:05:50,320 --> 00:05:54,800
i've fixed a couple of bugs along those

00:05:52,479 --> 00:05:54,800
lines

00:05:56,080 --> 00:06:02,880
so we've had the ability to allocate

00:05:59,680 --> 00:06:04,960
uh compact we've used compound pages

00:06:02,880 --> 00:06:07,840
for for memory for a while in the form

00:06:04,960 --> 00:06:07,840
of transparent huge pages

00:06:08,160 --> 00:06:12,400
and uh in 2016 when kirill added them to

00:06:11,280 --> 00:06:14,720
tempo first

00:06:12,400 --> 00:06:16,639
that was when the page cache first got

00:06:14,720 --> 00:06:20,240
the ability to store

00:06:16,639 --> 00:06:23,600
uh transparent huge pages

00:06:20,240 --> 00:06:25,680
in 2019 uh song

00:06:23,600 --> 00:06:26,639
uh had added support for doing read only

00:06:25,680 --> 00:06:28,160
huge pages

00:06:26,639 --> 00:06:30,639
and he was building on the work that

00:06:28,160 --> 00:06:33,520
camille had done for temp fs

00:06:30,639 --> 00:06:34,000
but now it was also available for file

00:06:33,520 --> 00:06:37,039
systems

00:06:34,000 --> 00:06:40,319
which use uh block

00:06:37,039 --> 00:06:41,759
block storage or indeed network storage

00:06:40,319 --> 00:06:43,759
and the way this is implemented is that

00:06:41,759 --> 00:06:45,520
you allocate compound pages

00:06:43,759 --> 00:06:47,039
uh but it was very limited in that it

00:06:45,520 --> 00:06:48,960
would

00:06:47,039 --> 00:06:51,919
you you only there are only two sizes

00:06:48,960 --> 00:06:55,440
supported uh or order zero pages

00:06:51,919 --> 00:06:58,080
normal pages base pages and uh pmd

00:06:55,440 --> 00:06:58,479
size pages and on x86 that would be an

00:06:58,080 --> 00:07:01,759
order

00:06:58,479 --> 00:07:04,800
an order nine page which is two

00:07:01,759 --> 00:07:04,800
megabytes of memory

00:07:07,520 --> 00:07:12,400
so about uh

00:07:10,639 --> 00:07:13,919
around about the beginning of this year

00:07:12,400 --> 00:07:14,400
i started working on something that i

00:07:13,919 --> 00:07:17,919
called

00:07:14,400 --> 00:07:19,919
new transparent huge pages and so i was

00:07:17,919 --> 00:07:21,919
recycling a lot of the transparent huge

00:07:19,919 --> 00:07:24,400
pages work that had been done

00:07:21,919 --> 00:07:25,039
and generalizing it so a transparent

00:07:24,400 --> 00:07:28,880
huge page is

00:07:25,039 --> 00:07:29,599
now no longer just two megabytes in size

00:07:28,880 --> 00:07:33,280
it could be

00:07:29,599 --> 00:07:37,360
almost any power of two in size

00:07:33,280 --> 00:07:40,960
and that led to uh because

00:07:37,360 --> 00:07:42,319
uh temperfest is a fully in memory file

00:07:40,960 --> 00:07:45,360
system

00:07:42,319 --> 00:07:46,560
there was uh little attention paid to

00:07:45,360 --> 00:07:50,879
things like

00:07:46,560 --> 00:07:53,680
how um something like dirtiness

00:07:50,879 --> 00:07:56,000
or whether the page was up to date uh or

00:07:53,680 --> 00:07:57,360
whether the page was under write back

00:07:56,000 --> 00:07:59,360
all the things don't make any sense for

00:07:57,360 --> 00:08:03,039
an in-memory file system so

00:07:59,360 --> 00:08:03,039
we didn't bother to track any of that

00:08:03,360 --> 00:08:09,919
uh so i i had to make a few changes

00:08:06,400 --> 00:08:10,240
to track some of that page state uh for

00:08:09,919 --> 00:08:13,599
the

00:08:10,240 --> 00:08:15,599
entire transfer of each page

00:08:13,599 --> 00:08:17,440
and then i introduced a bunch of new

00:08:15,599 --> 00:08:20,960
apis you can see there

00:08:17,440 --> 00:08:24,080
uh which um

00:08:20,960 --> 00:08:25,680
do but i think obvious things

00:08:24,080 --> 00:08:27,199
uh tell you how many pages there are in

00:08:25,680 --> 00:08:28,560
a transparent huge page

00:08:27,199 --> 00:08:30,720
tells you how many bytes there are in a

00:08:28,560 --> 00:08:32,240
transparent huge page because the order

00:08:30,720 --> 00:08:34,000
of a transparent huge pages like

00:08:32,240 --> 00:08:35,279
these three things will link to each

00:08:34,000 --> 00:08:36,000
other but some code wants to know one

00:08:35,279 --> 00:08:37,519
thing and something

00:08:36,000 --> 00:08:39,760
wants to know another so i provided

00:08:37,519 --> 00:08:42,640
authoring

00:08:39,760 --> 00:08:43,279
uh thp heads that so given any struck

00:08:42,640 --> 00:08:45,839
page

00:08:43,279 --> 00:08:46,880
it will it will give you the head page

00:08:45,839 --> 00:08:48,959
of it

00:08:46,880 --> 00:08:49,920
uh and then offset into hp that that

00:08:48,959 --> 00:08:53,440
will give you an

00:08:49,920 --> 00:08:54,560
uh a byte offset within this particular

00:08:53,440 --> 00:08:56,800
struct page

00:08:54,560 --> 00:08:57,839
of whatever you pass to it and generally

00:08:56,800 --> 00:09:01,120
that's that's a

00:08:57,839 --> 00:09:04,320
file offset and so that tells you

00:09:01,120 --> 00:09:06,320
how far into the page into a particular

00:09:04,320 --> 00:09:09,839
page

00:09:06,320 --> 00:09:09,839
and addresses

00:09:11,920 --> 00:09:14,880
when i came to merge

00:09:15,120 --> 00:09:19,440
i i i got a very long way with this

00:09:18,080 --> 00:09:22,640
approach

00:09:19,440 --> 00:09:25,680
and it was really only when i came to

00:09:22,640 --> 00:09:28,800
explaining it to other people and

00:09:25,680 --> 00:09:29,519
uh trying to justify what i'd done what

00:09:28,800 --> 00:09:31,600
i'd done

00:09:29,519 --> 00:09:32,959
and persuade maintains that they should

00:09:31,600 --> 00:09:35,600
merge it

00:09:32,959 --> 00:09:36,160
i really started to wonder whether i had

00:09:35,600 --> 00:09:38,720
indeed

00:09:36,160 --> 00:09:40,000
made the right decision that it was

00:09:38,720 --> 00:09:41,839
definitely expedient to use the

00:09:40,000 --> 00:09:46,080
transparent huge page

00:09:41,839 --> 00:09:47,200
uh code paths but it turns out that file

00:09:46,080 --> 00:09:48,959
system authors

00:09:47,200 --> 00:09:50,399
are generally unfamiliar with

00:09:48,959 --> 00:09:51,519
transparent huge pages

00:09:50,399 --> 00:09:53,920
because the only file system that's

00:09:51,519 --> 00:09:56,160
really supported up to now has been

00:09:53,920 --> 00:09:57,360
uh the shared memory file system it's

00:09:56,160 --> 00:10:01,279
mfs

00:09:57,360 --> 00:10:05,360
um other file system authors

00:10:01,279 --> 00:10:07,440
have paid no attention to it at all

00:10:05,360 --> 00:10:08,800
the temperfest is kind of a special file

00:10:07,440 --> 00:10:10,480
system off by itself

00:10:08,800 --> 00:10:13,440
uh regular filesystem developers don't

00:10:10,480 --> 00:10:16,320
look at it whereas

00:10:13,440 --> 00:10:18,000
file system authors tend to look at

00:10:16,320 --> 00:10:21,279
other file systems like this

00:10:18,000 --> 00:10:22,959
to gain inspiration so if if you talk to

00:10:21,279 --> 00:10:24,399
somebody who works on nfs they may well

00:10:22,959 --> 00:10:25,839
know things about several different

00:10:24,399 --> 00:10:29,040
network file systems

00:10:25,839 --> 00:10:30,480
and if you talk to say an ext4 developer

00:10:29,040 --> 00:10:32,560
they're probably quite familiar with how

00:10:30,480 --> 00:10:33,600
buttrfs and xfs do things

00:10:32,560 --> 00:10:36,000
because we're all looking at each

00:10:33,600 --> 00:10:37,440
other's code we're trying to figure out

00:10:36,000 --> 00:10:39,760
you know the best way to do something

00:10:37,440 --> 00:10:44,880
somebody comes up with a good idea then

00:10:39,760 --> 00:10:48,880
let's do that um

00:10:44,880 --> 00:10:52,320
the other thing that i noticed was that

00:10:48,880 --> 00:10:53,760
obviously i was working on x86 um

00:10:52,320 --> 00:10:56,000
but only some architectures support

00:10:53,760 --> 00:10:57,519
transparent huge pages it is actually

00:10:56,000 --> 00:11:00,959
something that

00:10:57,519 --> 00:11:02,320
an architecture has to opt into

00:11:00,959 --> 00:11:03,519
and that makes a lot of sense if you're

00:11:02,320 --> 00:11:05,519
talking about the original use of

00:11:03,519 --> 00:11:09,120
transparent huge pages

00:11:05,519 --> 00:11:09,120
to do things like

00:11:09,839 --> 00:11:15,680
insert a tlb entry that covers a much

00:11:13,920 --> 00:11:17,680
larger page that is something that

00:11:15,680 --> 00:11:19,120
an architecture needs to support it's

00:11:17,680 --> 00:11:21,279
something

00:11:19,120 --> 00:11:22,720
that you you actually need to write code

00:11:21,279 --> 00:11:26,240
um for example

00:11:22,720 --> 00:11:28,640
the alpha cpu has hardware support

00:11:26,240 --> 00:11:30,240
for larger page sizes but nobody's ever

00:11:28,640 --> 00:11:33,519
written the code for it

00:11:30,240 --> 00:11:35,279
so it's not activated

00:11:33,519 --> 00:11:37,519
the alpha does not support transparent

00:11:35,279 --> 00:11:42,320
huge pages even though the hardware does

00:11:37,519 --> 00:11:46,959
the linux port doesn't

00:11:42,320 --> 00:11:50,880
but i don't care uh i'm i'm not

00:11:46,959 --> 00:11:55,040
i'm not writing this code in order to

00:11:50,880 --> 00:11:57,040
make more efficient use of hardware tlbs

00:11:55,040 --> 00:11:59,360
i'm writing this to reduce the software

00:11:57,040 --> 00:12:00,720
of the head

00:11:59,360 --> 00:12:02,399
because that software overhead has now

00:12:00,720 --> 00:12:06,959
got to a point where it is

00:12:02,399 --> 00:12:06,959
just beyond acceptable

00:12:07,040 --> 00:12:13,600
so why shouldn't

00:12:10,160 --> 00:12:16,959
n68k and alpha and paris

00:12:13,600 --> 00:12:20,639
and all the other architectures

00:12:16,959 --> 00:12:23,360
have support for using large pages in

00:12:20,639 --> 00:12:23,360
the page cache

00:12:23,760 --> 00:12:27,519
and one way to that would be to sort of

00:12:26,000 --> 00:12:29,839
you know make some of these things

00:12:27,519 --> 00:12:31,839
not depend on transparent huge pages or

00:12:29,839 --> 00:12:34,480
or make transparent huge pages

00:12:31,839 --> 00:12:35,440
just split the config option uh so you

00:12:34,480 --> 00:12:37,680
could say well

00:12:35,440 --> 00:12:40,560
use it for for pnd size pages or just

00:12:37,680 --> 00:12:44,240
use it in general

00:12:40,560 --> 00:12:45,680
but then i was also trying to explain to

00:12:44,240 --> 00:12:48,000
persistent people exactly what a

00:12:45,680 --> 00:12:50,880
transparent huge page is

00:12:48,000 --> 00:12:51,760
and it became increasingly difficult to

00:12:50,880 --> 00:12:55,040
justify

00:12:51,760 --> 00:12:59,279
some of the choices i've made

00:12:55,040 --> 00:13:01,839
and one of those being when we call

00:12:59,279 --> 00:13:03,519
the file systems read page operation do

00:13:01,839 --> 00:13:04,959
we want to read an entire transparent

00:13:03,519 --> 00:13:07,360
huge page

00:13:04,959 --> 00:13:09,760
or do we want to read a specific subpage

00:13:07,360 --> 00:13:14,480
do we just want to read

00:13:09,760 --> 00:13:14,480
4k or do we want to read the whole thing

00:13:14,800 --> 00:13:20,639
and a file system can ask

00:13:18,079 --> 00:13:21,760
or and any piece of code can ask is this

00:13:20,639 --> 00:13:24,720
page a head page

00:13:21,760 --> 00:13:26,880
is it a tail page is is it a base page

00:13:24,720 --> 00:13:30,000
an auto zero page

00:13:26,880 --> 00:13:34,079
um but actually that doesn't matter

00:13:30,000 --> 00:13:36,880
that isn't necessarily um

00:13:34,079 --> 00:13:37,760
just because it's a tail page doesn't

00:13:36,880 --> 00:13:40,399
tell you

00:13:37,760 --> 00:13:41,040
i just want to read this tale page it

00:13:40,399 --> 00:13:43,040
might mean

00:13:41,040 --> 00:13:45,279
i'm i'm really interested in this tale

00:13:43,040 --> 00:13:47,760
page but i want you to read

00:13:45,279 --> 00:13:51,120
the whole transparent huge page that

00:13:47,760 --> 00:13:52,720
contains this tail page

00:13:51,120 --> 00:13:54,720
and then there's a similar kind of pro

00:13:52,720 --> 00:13:56,160
similar kind of question with the page

00:13:54,720 --> 00:13:58,480
fault handler

00:13:56,160 --> 00:13:59,760
uh do we want to satisfy the page fold

00:13:58,480 --> 00:14:01,839
with

00:13:59,760 --> 00:14:03,279
an entire translate page do we want just

00:14:01,839 --> 00:14:06,639
for just this specific one

00:14:03,279 --> 00:14:09,279
do we want to say well put in as many

00:14:06,639 --> 00:14:10,639
as as many till the entries as we can

00:14:09,279 --> 00:14:13,199
around this page

00:14:10,639 --> 00:14:14,720
exactly what are we dealing with and it

00:14:13,199 --> 00:14:17,920
becomes very tricky

00:14:14,720 --> 00:14:21,360
and what i had done is

00:14:17,920 --> 00:14:24,800
put in assertions a lot of points that

00:14:21,360 --> 00:14:27,519
a page definitely was a head page

00:14:24,800 --> 00:14:29,199
um but that didn't really i mean that

00:14:27,519 --> 00:14:32,160
that that worked out well

00:14:29,199 --> 00:14:33,600
what i was doing for my prototyping work

00:14:32,160 --> 00:14:34,720
but i didn't really want to leave all

00:14:33,600 --> 00:14:37,839
that in

00:14:34,720 --> 00:14:37,839
um for

00:14:38,399 --> 00:14:43,680
uh for production code and i also

00:14:42,240 --> 00:14:45,760
didn't don't want to have to replicate

00:14:43,680 --> 00:14:47,519
this to other file systems

00:14:45,760 --> 00:14:50,480
when when other file systems were also

00:14:47,519 --> 00:14:50,480
adding support for this

00:14:50,560 --> 00:14:56,800
and finally it's very hard to document

00:14:54,639 --> 00:14:58,480
exactly what it is you want um i i

00:14:56,800 --> 00:15:00,240
frequently catch myself saying

00:14:58,480 --> 00:15:02,480
oh this must be a head page and then

00:15:00,240 --> 00:15:04,320
people would turn around to me and say

00:15:02,480 --> 00:15:05,360
well yes but can't also be a base page i

00:15:04,320 --> 00:15:06,800
mean you're not guaranteed it's going to

00:15:05,360 --> 00:15:07,279
be a transformative page i'll say yes

00:15:06,800 --> 00:15:09,040
okay

00:15:07,279 --> 00:15:10,839
what i really mean here is it's either a

00:15:09,040 --> 00:15:12,320
base page or the head page for

00:15:10,839 --> 00:15:16,959
transparent

00:15:12,320 --> 00:15:20,079
and that quickly made the documentation

00:15:16,959 --> 00:15:23,040
uh very messy

00:15:20,079 --> 00:15:25,440
so i have decided to resolve a new

00:15:23,040 --> 00:15:28,959
approach

00:15:25,440 --> 00:15:32,880
which i call page folios

00:15:28,959 --> 00:15:36,720
and so when an interface says

00:15:32,880 --> 00:15:39,440
this is a folio this this this

00:15:36,720 --> 00:15:39,759
this parameter is a folio that means it

00:15:39,440 --> 00:15:43,279
is

00:15:39,759 --> 00:15:46,079
either a base page or it's the head page

00:15:43,279 --> 00:15:48,880
of a transparent huge page

00:15:46,079 --> 00:15:50,240
and in either case whatever is it

00:15:48,880 --> 00:15:52,560
whatever operations

00:15:50,240 --> 00:15:55,120
says that this function is doing it is

00:15:52,560 --> 00:15:58,399
definitely doing it on the entire

00:15:55,120 --> 00:15:59,360
size of the folio when we're not

00:15:58,399 --> 00:16:02,480
referring to

00:15:59,360 --> 00:16:04,480
a specific page of

00:16:02,480 --> 00:16:07,040
of of the folio we're referring to the

00:16:04,480 --> 00:16:08,320
entire folio

00:16:07,040 --> 00:16:10,079
and that way when somebody passes a

00:16:08,320 --> 00:16:12,720
struck page for an operation you know

00:16:10,079 --> 00:16:15,040
you're referring to a specific

00:16:12,720 --> 00:16:16,800
four kilobytes or depending on the

00:16:15,040 --> 00:16:18,959
architecture maybe 60 kilobytes or eight

00:16:16,800 --> 00:16:21,680
kilobytes or something

00:16:18,959 --> 00:16:23,440
um but if if somebody passes your folio

00:16:21,680 --> 00:16:26,560
you're dealing with whatever size that

00:16:23,440 --> 00:16:26,560
folio happens to be

00:16:26,720 --> 00:16:30,639
and so we have we now have to replicate

00:16:28,399 --> 00:16:31,040
a lot of the page infrastructure that we

00:16:30,639 --> 00:16:34,480
have

00:16:31,040 --> 00:16:36,800
so we have a page dirty macro

00:16:34,480 --> 00:16:37,680
now we need a folio dirty macro because

00:16:36,800 --> 00:16:41,120
the entire

00:16:37,680 --> 00:16:44,079
folio has to be tracked as a single unit

00:16:41,120 --> 00:16:44,720
and similarly for up to date active

00:16:44,079 --> 00:16:46,720
right back

00:16:44,720 --> 00:16:49,360
locked and there's about a dozen

00:16:46,720 --> 00:16:53,279
different flags that we set on

00:16:49,360 --> 00:16:55,920
on pages the next step will be modifying

00:16:53,279 --> 00:16:58,399
some apis

00:16:55,920 --> 00:16:59,759
for example the read page i was talking

00:16:58,399 --> 00:17:01,680
about that's going to want to take a

00:16:59,759 --> 00:17:04,959
stroke folio to indicate the operating

00:17:01,680 --> 00:17:08,240
on the entire stratfolio

00:17:04,959 --> 00:17:10,319
and then the new apis that i added just

00:17:08,240 --> 00:17:12,319
recently for transparent huge pages

00:17:10,319 --> 00:17:14,559
i'm going to have to pull those back out

00:17:12,319 --> 00:17:17,679
and put in these new

00:17:14,559 --> 00:17:18,880
folio equivalents there's a couple of

00:17:17,679 --> 00:17:20,640
new ones in here

00:17:18,880 --> 00:17:22,640
that that weren't simply they don't have

00:17:20,640 --> 00:17:26,640
an equivalent in the previous slide

00:17:22,640 --> 00:17:29,520
uh one is folio page so uh

00:17:26,640 --> 00:17:31,039
given the index within a file and a

00:17:29,520 --> 00:17:33,039
struct folio it returns

00:17:31,039 --> 00:17:36,000
the exact struct page for that

00:17:33,039 --> 00:17:36,000
particular index

00:17:36,240 --> 00:17:40,880
and then uh page folio does does the

00:17:38,960 --> 00:17:42,080
opposite it's given this struct page

00:17:40,880 --> 00:17:46,080
return me the folio

00:17:42,080 --> 00:17:49,200
which which this page is in

00:17:46,080 --> 00:17:51,520
and you you'll notice that struct folio

00:17:49,200 --> 00:17:55,360
is is not a particularly big

00:17:51,520 --> 00:17:56,559
structure indeed it's it's not really a

00:17:55,360 --> 00:17:59,120
structure of its own

00:17:56,559 --> 00:18:00,320
it's its purpose is to tell the c

00:17:59,120 --> 00:18:03,440
compiler

00:18:00,320 --> 00:18:04,240
and indeed the programmer this struct

00:18:03,440 --> 00:18:09,200
page

00:18:04,240 --> 00:18:12,080
is definitely not a tail page

00:18:09,200 --> 00:18:12,080
and so

00:18:12,320 --> 00:18:18,320
you you you literally can just cast

00:18:15,280 --> 00:18:21,600
between a strap folio instruct page

00:18:18,320 --> 00:18:23,600
um but if you do that you are throwing

00:18:21,600 --> 00:18:25,360
away the type information

00:18:23,600 --> 00:18:26,799
which struck folio gives you and

00:18:25,360 --> 00:18:28,880
sometimes that's the right thing to do

00:18:26,799 --> 00:18:31,039
sometimes you really do want to to just

00:18:28,880 --> 00:18:34,000
cast that away

00:18:31,039 --> 00:18:34,320
but usually you know i i don't want to

00:18:34,000 --> 00:18:35,760
see

00:18:34,320 --> 00:18:37,600
lots of files this file systems

00:18:35,760 --> 00:18:39,280
shouldn't be doing that uh

00:18:37,600 --> 00:18:40,640
in indeed the core vfs generally

00:18:39,280 --> 00:18:41,600
shouldn't be doing that that should be

00:18:40,640 --> 00:18:45,600
something

00:18:41,600 --> 00:18:47,520
being done really by the macros folio

00:18:45,600 --> 00:18:49,840
page and page folio

00:18:47,520 --> 00:18:50,559
it's it's not something should be done

00:18:49,840 --> 00:18:53,600
outside

00:18:50,559 --> 00:18:53,600
maybe some debug code

00:18:54,840 --> 00:18:59,280
so once we've got all that out of the

00:18:58,240 --> 00:19:02,240
way

00:18:59,280 --> 00:19:03,600
uh we can return to our earlier

00:19:02,240 --> 00:19:08,320
interesting problem

00:19:03,600 --> 00:19:08,320
of when should we allocate large pages

00:19:08,640 --> 00:19:14,400
and some people say well we

00:19:11,679 --> 00:19:15,760
we should allow user space to hint to us

00:19:14,400 --> 00:19:19,280
we should let we should we should

00:19:15,760 --> 00:19:19,760
have an api where where program opens a

00:19:19,280 --> 00:19:22,240
file

00:19:19,760 --> 00:19:23,679
and then calls f console and says i want

00:19:22,240 --> 00:19:25,200
to use large paper here's the size of

00:19:23,679 --> 00:19:26,960
page i want you to use the cache this

00:19:25,200 --> 00:19:30,559
file

00:19:26,960 --> 00:19:34,240
and we could do that um

00:19:30,559 --> 00:19:37,280
but often the user doesn't know

00:19:34,240 --> 00:19:39,520
and if they do know sometimes they they

00:19:37,280 --> 00:19:41,039
they tune on one particular hardware

00:19:39,520 --> 00:19:43,280
and they move to different hardware and

00:19:41,039 --> 00:19:46,400
a different decision would have made

00:19:43,280 --> 00:19:50,559
a better decision

00:19:46,400 --> 00:19:52,400
um there's also the case that

00:19:50,559 --> 00:19:53,840
files are not usually used by just one

00:19:52,400 --> 00:19:56,080
program they

00:19:53,840 --> 00:19:57,679
they may be written by one program and

00:19:56,080 --> 00:19:58,480
then read by three other different

00:19:57,679 --> 00:20:00,799
programs

00:19:58,480 --> 00:20:02,480
and if all four of those programs set

00:20:00,799 --> 00:20:04,720
different hints

00:20:02,480 --> 00:20:07,200
we don't know which one which hint we

00:20:04,720 --> 00:20:10,240
should be using

00:20:07,200 --> 00:20:11,360
and i don't like hints because it means

00:20:10,240 --> 00:20:15,360
that

00:20:11,360 --> 00:20:18,480
uh the user space has to change

00:20:15,360 --> 00:20:21,600
and i think this is a general

00:20:18,480 --> 00:20:24,880
system level optimization and

00:20:21,600 --> 00:20:29,039
it should just work naturally

00:20:24,880 --> 00:20:29,039
without anybody changing anything

00:20:30,559 --> 00:20:33,919
another important thing i think is the

00:20:32,559 --> 00:20:35,760
file system should not have to develop

00:20:33,919 --> 00:20:38,880
their own heuristics

00:20:35,760 --> 00:20:41,520
this is a caching decision being made by

00:20:38,880 --> 00:20:43,280
the vfs it's not something that a file

00:20:41,520 --> 00:20:45,120
system should necessarily get involved

00:20:43,280 --> 00:20:48,480
with

00:20:45,120 --> 00:20:49,840
uh there are a few cases where file

00:20:48,480 --> 00:20:52,320
systems

00:20:49,840 --> 00:20:53,679
want to tell the vfs hey that's a bad

00:20:52,320 --> 00:20:56,960
decision for me

00:20:53,679 --> 00:21:00,320
can we modify that uh that

00:20:56,960 --> 00:21:03,280
that decision slightly um

00:21:00,320 --> 00:21:05,919
but they shouldn't have to uh do that

00:21:03,280 --> 00:21:05,919
all themselves

00:21:06,159 --> 00:21:10,000
and so as i was i was looking around at

00:21:08,320 --> 00:21:12,240
how this should be done

00:21:10,000 --> 00:21:13,760
and i settled on page cache readerhead

00:21:12,240 --> 00:21:14,640
because that already makes caching

00:21:13,760 --> 00:21:17,679
decisions

00:21:14,640 --> 00:21:20,320
it decides how many pages to read ahead

00:21:17,679 --> 00:21:23,679
and that's currently kept around 256

00:21:20,320 --> 00:21:27,120
kilobytes on on most systems today

00:21:23,679 --> 00:21:30,000
and i enhanced it to decide how large

00:21:27,120 --> 00:21:32,080
those pages should be and it actually

00:21:30,000 --> 00:21:35,280
ramps up fairly aggressively

00:21:32,080 --> 00:21:38,400
uh in my testing uh

00:21:35,280 --> 00:21:39,520
just because i i want to test with a lot

00:21:38,400 --> 00:21:42,320
of

00:21:39,520 --> 00:21:42,320
large pages

00:21:43,200 --> 00:21:46,159
originally i thought maybe this is too

00:21:44,880 --> 00:21:47,600
aggressive i'm going to want to dial it

00:21:46,159 --> 00:21:49,520
back some

00:21:47,600 --> 00:21:53,120
make it not ramp up large pages quite as

00:21:49,520 --> 00:21:56,080
efficiently quite quite as aggressively

00:21:53,120 --> 00:21:57,120
but now i'm starting to think well maybe

00:21:56,080 --> 00:22:00,240
maybe it's right

00:21:57,120 --> 00:22:04,559
me maybe we do want to uh to

00:22:00,240 --> 00:22:06,640
to increases quite aggressively

00:22:04,559 --> 00:22:07,840
i mean there are downsides to use to

00:22:06,640 --> 00:22:10,559
using large pages

00:22:07,840 --> 00:22:12,559
the larger a page that you use uh the

00:22:10,559 --> 00:22:16,480
the larger the right amplification

00:22:12,559 --> 00:22:17,760
so if you dirty one byte in a 64

00:22:16,480 --> 00:22:21,360
kilobyte page

00:22:17,760 --> 00:22:24,960
you'll write back 64 kilobytes of data

00:22:21,360 --> 00:22:27,360
even though most of it was unchanged

00:22:24,960 --> 00:22:28,400
that said uh most devices handle that

00:22:27,360 --> 00:22:31,360
quite well

00:22:28,400 --> 00:22:32,880
there aren't really uh a lot of

00:22:31,360 --> 00:22:35,919
bandwidth limitations

00:22:32,880 --> 00:22:37,360
on on on most systems you can find

00:22:35,919 --> 00:22:38,640
assist you can find systems that don't

00:22:37,360 --> 00:22:40,400
have enough bandwidth you know on their

00:22:38,640 --> 00:22:43,679
pcie bus or something

00:22:40,400 --> 00:22:46,159
but um it is uh

00:22:43,679 --> 00:22:47,919
it's it's generally not a problem and

00:22:46,159 --> 00:22:49,360
you find that a lot of storage devices

00:22:47,919 --> 00:22:50,559
actually perform better with larger

00:22:49,360 --> 00:22:53,440
sizes

00:22:50,559 --> 00:22:54,640
um i i have a i just recently bought a

00:22:53,440 --> 00:22:57,600
new ssd

00:22:54,640 --> 00:22:58,559
and i discovered that it actually takes

00:22:57,600 --> 00:23:01,679
longer to read

00:22:58,559 --> 00:23:06,840
a 512 byte sector than it does to read

00:23:01,679 --> 00:23:10,640
four kilobytes and that's

00:23:06,840 --> 00:23:11,840
weird i mean i i would understand if it

00:23:10,640 --> 00:23:13,200
took about the same length of time but

00:23:11,840 --> 00:23:14,799
this actually takes longer

00:23:13,200 --> 00:23:16,880
i find really quite weird so that's an

00:23:14,799 --> 00:23:21,280
indication that storage vendors

00:23:16,880 --> 00:23:24,640
are optimizing their devices for having

00:23:21,280 --> 00:23:28,480
larger ios and that smaller ios are

00:23:24,640 --> 00:23:28,480
are these days inefficient

00:23:29,440 --> 00:23:36,240
i haven't done anything to

00:23:32,720 --> 00:23:38,159
allocate large pages for writes yet

00:23:36,240 --> 00:23:40,000
that's to me is future work i want to

00:23:38,159 --> 00:23:43,840
try and get the work that i've done

00:23:40,000 --> 00:23:45,520
upstream more than i want to make

00:23:43,840 --> 00:23:47,360
more than i want to have rights use

00:23:45,520 --> 00:23:50,720
large pages um

00:23:47,360 --> 00:23:54,640
but it is a deficit um but

00:23:50,720 --> 00:23:56,400
you know i i i i want to

00:23:54,640 --> 00:23:58,320
push out the benefits that i currently

00:23:56,400 --> 00:24:00,799
see so that everyone can take advantage

00:23:58,320 --> 00:24:04,000
of them

00:24:00,799 --> 00:24:05,679
uh page faults uh the reader head code

00:24:04,000 --> 00:24:08,720
works for those reads and

00:24:05,679 --> 00:24:10,880
page faults but one of the patches that

00:24:08,720 --> 00:24:14,880
i did recently

00:24:10,880 --> 00:24:18,559
looks at an existing hint m advise

00:24:14,880 --> 00:24:19,120
huge page and if you if you do have that

00:24:18,559 --> 00:24:23,760
set

00:24:19,120 --> 00:24:26,320
then uh it will use dnd size pages

00:24:23,760 --> 00:24:28,720
and also it will start to read ahead in

00:24:26,320 --> 00:24:29,760
pmd size units so two megabytes at a

00:24:28,720 --> 00:24:31,360
time

00:24:29,760 --> 00:24:32,799
so the first time you take a page fault

00:24:31,360 --> 00:24:34,159
it will actually be four megabytes it

00:24:32,799 --> 00:24:35,520
will be the two megabytes you're looking

00:24:34,159 --> 00:24:38,400
at

00:24:35,520 --> 00:24:40,320
and then the next two megabytes and then

00:24:38,400 --> 00:24:41,679
if you fold in that next two megabytes

00:24:40,320 --> 00:24:43,360
it will read it will start to read ahead

00:24:41,679 --> 00:24:45,840
the two megabytes after that

00:24:43,360 --> 00:24:48,720
so it's it's got the pipelining effect

00:24:45,840 --> 00:24:48,720
of reader head

00:24:48,880 --> 00:24:52,640
but it's doing two megabytes at a time

00:24:51,600 --> 00:24:56,400
rather than

00:24:52,640 --> 00:24:56,400
250 kilobytes at a time

00:24:59,039 --> 00:25:02,480
so one of the things that i had to do in

00:25:01,679 --> 00:25:05,360
order

00:25:02,480 --> 00:25:07,520
to make the reader head code work was

00:25:05,360 --> 00:25:11,200
that i had to change the api

00:25:07,520 --> 00:25:12,480
between the uh the vfs and the file

00:25:11,200 --> 00:25:15,600
system

00:25:12,480 --> 00:25:18,400
so that the reader head code would

00:25:15,600 --> 00:25:19,919
actually add the pages to the page cache

00:25:18,400 --> 00:25:21,679
and then tell the file system here are

00:25:19,919 --> 00:25:24,000
the pages that i've added go off and

00:25:21,679 --> 00:25:27,440
update them

00:25:24,000 --> 00:25:30,480
we used to have the file system we have

00:25:27,440 --> 00:25:33,200
video code would allocate would allocate

00:25:30,480 --> 00:25:34,640
some number of pages and then the file

00:25:33,200 --> 00:25:36,400
system would read into them and add them

00:25:34,640 --> 00:25:40,240
to the page cache

00:25:36,400 --> 00:25:43,520
uh but because uh because pages

00:25:40,240 --> 00:25:45,440
have to be aligned so if you allocate a

00:25:43,520 --> 00:25:48,559
two megabyte page it has to be

00:25:45,440 --> 00:25:49,200
at zero two megabytes four by six

00:25:48,559 --> 00:25:51,360
megabytes

00:25:49,200 --> 00:25:54,240
it can't be you can't put a two megabyte

00:25:51,360 --> 00:25:56,720
page at one megabyte offset in the file

00:25:54,240 --> 00:25:58,159
um so because you've got that kind of

00:25:56,720 --> 00:26:00,000
restriction

00:25:58,159 --> 00:26:01,679
it was going to be very very hard for

00:26:00,000 --> 00:26:03,360
file systems to know about those

00:26:01,679 --> 00:26:05,600
restrictions and and try to

00:26:03,360 --> 00:26:07,520
add themselves so it's much easier to do

00:26:05,600 --> 00:26:09,200
all that work up in the reader head code

00:26:07,520 --> 00:26:11,200
and then let the file system just take

00:26:09,200 --> 00:26:14,000
care of working with the page caches

00:26:11,200 --> 00:26:17,760
which it already knows how to do

00:26:14,000 --> 00:26:21,440
uh it was also a nice cleanup um

00:26:17,760 --> 00:26:23,919
i have not finished this conversion yet

00:26:21,440 --> 00:26:26,559
it's very hard to convert the file

00:26:23,919 --> 00:26:30,159
systems which use fs cache

00:26:26,559 --> 00:26:31,840
uh so that cleanup is still in progress

00:26:30,159 --> 00:26:33,840
and uh yeah we'll be able to delete a

00:26:31,840 --> 00:26:35,919
few hundred more lines of code

00:26:33,840 --> 00:26:37,120
once that is in progress because we'll

00:26:35,919 --> 00:26:39,120
be able to read

00:26:37,120 --> 00:26:41,200
we'll be able to remove the support in

00:26:39,120 --> 00:26:43,919
the vfs for the old

00:26:41,200 --> 00:26:44,720
uh read head function for the read pages

00:26:43,919 --> 00:26:48,159
function

00:26:44,720 --> 00:26:52,559
and just leave the new

00:26:48,159 --> 00:26:56,480
read head function

00:26:52,559 --> 00:26:59,440
so on one of the things that

00:26:56,480 --> 00:27:01,200
i think i said earlier that was not

00:26:59,440 --> 00:27:04,240
present was

00:27:01,200 --> 00:27:07,520
support for doing i o to large pages

00:27:04,240 --> 00:27:09,360
because it shim mfs

00:27:07,520 --> 00:27:11,039
or temperfest isn't in memory file

00:27:09,360 --> 00:27:13,520
system

00:27:11,039 --> 00:27:15,520
there's really been no need to support

00:27:13,520 --> 00:27:18,960
large pages

00:27:15,520 --> 00:27:21,440
um so mainly

00:27:18,960 --> 00:27:22,399
added support for multi-page bios and

00:27:21,440 --> 00:27:25,520
this this was

00:27:22,399 --> 00:27:29,520
to uh this was an optimization

00:27:25,520 --> 00:27:31,120
um because pages were often sequential

00:27:29,520 --> 00:27:32,840
this was we're getting a performance

00:27:31,120 --> 00:27:36,480
boost uh if

00:27:32,840 --> 00:27:39,679
if uh if if if the pages were sequential

00:27:36,480 --> 00:27:40,640
then we could describe uh an i o with

00:27:39,679 --> 00:27:42,399
much

00:27:40,640 --> 00:27:44,399
with with with many fewer data

00:27:42,399 --> 00:27:46,720
structures with only fewer entries in an

00:27:44,399 --> 00:27:46,720
array

00:27:46,960 --> 00:27:50,480
but this turned out to be very critical

00:27:48,799 --> 00:27:53,279
for me because it actually

00:27:50,480 --> 00:27:54,000
it meant that i didn't have to split up

00:27:53,279 --> 00:27:56,960
ios

00:27:54,000 --> 00:27:57,760
um i could do a single io i could say

00:27:56,960 --> 00:28:02,559
here is

00:27:57,760 --> 00:28:05,600
a 64 kilobyte page please read all of it

00:28:02,559 --> 00:28:06,880
um i turned out not to quite work so i

00:28:05,600 --> 00:28:10,640
had to fix a bug

00:28:06,880 --> 00:28:13,840
but um in the end i got support for

00:28:10,640 --> 00:28:16,080
large pages into the i o map code

00:28:13,840 --> 00:28:17,919
now the io map code used to be part of

00:28:16,080 --> 00:28:20,960
xfs

00:28:17,919 --> 00:28:21,279
and it got moved out into its own code

00:28:20,960 --> 00:28:25,679
and

00:28:21,279 --> 00:28:25,679
and now it's shared with zone fs as well

00:28:25,760 --> 00:28:29,679
we hope i think we all hope that file

00:28:28,320 --> 00:28:33,440
systems will be

00:28:29,679 --> 00:28:35,760
converted to use i o map so far

00:28:33,440 --> 00:28:37,279
many of them have not been and if

00:28:35,760 --> 00:28:37,679
somebody's looking for a project to take

00:28:37,279 --> 00:28:39,760
on

00:28:37,679 --> 00:28:41,600
then converting your favorite file

00:28:39,760 --> 00:28:46,159
system to use io map would be

00:28:41,600 --> 00:28:49,440
a great and very large project

00:28:46,159 --> 00:28:50,640
um then in collaboration with dave

00:28:49,440 --> 00:28:53,919
howells

00:28:50,640 --> 00:28:56,000
uh we're working on on support for

00:28:53,919 --> 00:28:59,200
network file systems

00:28:56,000 --> 00:29:02,799
and so this actually uh

00:28:59,200 --> 00:29:05,520
works with the uh uh

00:29:02,799 --> 00:29:06,640
with with with the fs cache that i was

00:29:05,520 --> 00:29:08,880
talking about in the

00:29:06,640 --> 00:29:10,159
previous slide part of the problem is

00:29:08,880 --> 00:29:12,399
the

00:29:10,159 --> 00:29:14,159
opportunity is that dave house is also

00:29:12,399 --> 00:29:15,120
writing on fs cache rewrite at the same

00:29:14,159 --> 00:29:17,279
time

00:29:15,120 --> 00:29:19,600
and so he and i have been collaborating

00:29:17,279 --> 00:29:22,000
a lot over the last few months

00:29:19,600 --> 00:29:22,640
uh making sure that fs cache is going to

00:29:22,000 --> 00:29:25,279
be

00:29:22,640 --> 00:29:26,399
php is going to make it possible to

00:29:25,279 --> 00:29:27,600
support thp

00:29:26,399 --> 00:29:30,159
there'll seem a certain amount of work

00:29:27,600 --> 00:29:33,600
to be done in each file system

00:29:30,159 --> 00:29:35,520
but the uh the the fs cache

00:29:33,600 --> 00:29:38,000
work will insulate the file system from

00:29:35,520 --> 00:29:40,960
the details of how the page cache works

00:29:38,000 --> 00:29:41,600
and so we may actually see support for

00:29:40,960 --> 00:29:43,440
all

00:29:41,600 --> 00:29:44,960
five of these network file systems and

00:29:43,440 --> 00:29:47,520
transparent huge pages

00:29:44,960 --> 00:29:49,760
before we see support for many block

00:29:47,520 --> 00:29:53,520
based file systems

00:29:49,760 --> 00:29:56,480
and uh here's a good long list of

00:29:53,520 --> 00:29:58,080
uh file systems which use buffer heads

00:29:56,480 --> 00:30:00,960
um

00:29:58,080 --> 00:30:03,039
that's not even all of them basically

00:30:00,960 --> 00:30:06,559
every block file system

00:30:03,039 --> 00:30:09,600
um uses buffer heads except for

00:30:06,559 --> 00:30:12,000
xfs and butterfs

00:30:09,600 --> 00:30:12,799
and butterfest has its own set of

00:30:12,000 --> 00:30:16,080
problems

00:30:12,799 --> 00:30:18,720
it doesn't currently support uh block

00:30:16,080 --> 00:30:21,279
sizes not equal to page size

00:30:18,720 --> 00:30:22,080
and so there are a lot of assumptions

00:30:21,279 --> 00:30:25,919
that

00:30:22,080 --> 00:30:27,520
one struck page deals with exactly one

00:30:25,919 --> 00:30:30,720
block on disk

00:30:27,520 --> 00:30:32,799
uh that is being worked on uh not by me

00:30:30,720 --> 00:30:34,240
and i look forward to collaborating with

00:30:32,799 --> 00:30:35,600
the battery fs people

00:30:34,240 --> 00:30:37,520
whenever they're ready to work with me

00:30:35,600 --> 00:30:40,159
on it they they have

00:30:37,520 --> 00:30:41,440
more important things to do right now

00:30:40,159 --> 00:30:43,360
that's fine

00:30:41,440 --> 00:30:46,320
i'm i'm busy enough without working on

00:30:43,360 --> 00:30:46,320
that at the moment

00:30:47,200 --> 00:30:51,360
so with the i o path taken care of we

00:30:49,840 --> 00:30:53,760
can then move on to looking at

00:30:51,360 --> 00:30:56,880
what it takes to actually support large

00:30:53,760 --> 00:30:56,880
pages in the page cache

00:30:56,960 --> 00:31:00,720
a lot of the patches that i've already

00:30:58,559 --> 00:31:02,720
got then simply remove the assumption

00:31:00,720 --> 00:31:04,880
that a compound page is exactly the size

00:31:02,720 --> 00:31:08,080
of a pnd

00:31:04,880 --> 00:31:11,440
so instead of saying oh

00:31:08,080 --> 00:31:14,720
is is this page a compound page

00:31:11,440 --> 00:31:17,600
yes then do two megabytes of stuff

00:31:14,720 --> 00:31:18,240
and instead we ask the page how large

00:31:17,600 --> 00:31:19,519
are you

00:31:18,240 --> 00:31:21,679
and currently the answer always comes

00:31:19,519 --> 00:31:23,200
back either i'm a four killer by page or

00:31:21,679 --> 00:31:24,880
two megabyte page because none of the

00:31:23,200 --> 00:31:28,640
other code is upstream yet

00:31:24,880 --> 00:31:29,360
uh but the the support is there and that

00:31:28,640 --> 00:31:33,200
was

00:31:29,360 --> 00:31:34,720
perhaps 50 patches to to to rip out all

00:31:33,200 --> 00:31:36,640
of the assumptions

00:31:34,720 --> 00:31:39,039
that a compound page was necessarily pmd

00:31:36,640 --> 00:31:39,039
sized

00:31:39,120 --> 00:31:44,320
another strand of uh development

00:31:42,480 --> 00:31:45,840
was supporting operations which aren't

00:31:44,320 --> 00:31:47,519
just aren't used by temperature so

00:31:45,840 --> 00:31:50,559
nobody's ever done the work

00:31:47,519 --> 00:31:51,120
to make them uh support transparent huge

00:31:50,559 --> 00:31:54,559
papers

00:31:51,120 --> 00:31:57,200
yeah transferring these pages um

00:31:54,559 --> 00:31:58,080
so temperatures doesn't support direct i

00:31:57,200 --> 00:32:01,120
o

00:31:58,080 --> 00:32:04,240
um no nobody tries to deduplicate

00:32:01,120 --> 00:32:07,200
uh files on tempest and

00:32:04,240 --> 00:32:08,880
uh stable pages are a concept uh which

00:32:07,200 --> 00:32:09,600
only makes sense for block based file

00:32:08,880 --> 00:32:11,760
systems

00:32:09,600 --> 00:32:13,279
or network file systems but anyway they

00:32:11,760 --> 00:32:14,799
don't make it doesn't make sense for

00:32:13,279 --> 00:32:18,720
backing source and if you'd ever

00:32:14,799 --> 00:32:20,000
looked at the staple pages code to say

00:32:18,720 --> 00:32:22,559
hey does it does this work if it's a

00:32:20,000 --> 00:32:26,480
transparent huge page

00:32:22,559 --> 00:32:30,559
um shadow entries are fun

00:32:26,480 --> 00:32:32,640
uh they are used when you uh

00:32:30,559 --> 00:32:34,480
you have a page in the page cache it

00:32:32,640 --> 00:32:36,240
goes on to the lru and then

00:32:34,480 --> 00:32:37,519
it falls off the end of the liu due to

00:32:36,240 --> 00:32:40,399
memory pressure

00:32:37,519 --> 00:32:41,279
so it would have still been on the lru

00:32:40,399 --> 00:32:45,600
if

00:32:41,279 --> 00:32:48,399
we had um if it was purely time based

00:32:45,600 --> 00:32:49,279
but because the lru is sometimes

00:32:48,399 --> 00:32:52,320
sometimes a lot of

00:32:49,279 --> 00:32:56,159
memory pressure uh there's this

00:32:52,320 --> 00:32:56,960
ins so this um this page gets removed

00:32:56,159 --> 00:32:59,200
from ram

00:32:56,960 --> 00:33:01,120
but rather than just saying oh well then

00:32:59,200 --> 00:33:04,799
it fell off the end of the lru list

00:33:01,120 --> 00:33:06,480
we effectively extend the lru list by

00:33:04,799 --> 00:33:08,720
putting some summary information

00:33:06,480 --> 00:33:10,320
into what's called a shadow of entry and

00:33:08,720 --> 00:33:12,480
so if we then re-fault

00:33:10,320 --> 00:33:13,440
on this page we look at its shadow entry

00:33:12,480 --> 00:33:16,159
and say well

00:33:13,440 --> 00:33:17,760
would this have still been on the lru

00:33:16,159 --> 00:33:20,080
list if the lrus were

00:33:17,760 --> 00:33:21,440
infinitely long and if so we treat it as

00:33:20,080 --> 00:33:23,440
a refault

00:33:21,440 --> 00:33:25,519
and if it would have been taken off the

00:33:23,440 --> 00:33:28,720
lru that's by now because it's so old

00:33:25,519 --> 00:33:30,320
then we treat it as a new fault uh this

00:33:28,720 --> 00:33:33,440
helps us track the working set

00:33:30,320 --> 00:33:37,519
of a process and helps us make

00:33:33,440 --> 00:33:40,320
better decisions about when the um

00:33:37,519 --> 00:33:43,039
when the process is going to need which

00:33:40,320 --> 00:33:43,039
kinds of pages

00:33:43,120 --> 00:33:46,480
another big chunk of work i had to do

00:33:45,039 --> 00:33:50,399
was making it possible to

00:33:46,480 --> 00:33:53,519
find uh large pages which were tagged

00:33:50,399 --> 00:33:55,360
if you also know msync and the

00:33:53,519 --> 00:33:57,679
the the range of the file that you're

00:33:55,360 --> 00:33:59,519
looking at is within a transparent huge

00:33:57,679 --> 00:34:01,679
page

00:33:59,519 --> 00:34:03,919
and that transparent huge page is dirty

00:34:01,679 --> 00:34:06,480
it must find that transparent huge page

00:34:03,919 --> 00:34:08,720
even though you're starting after the

00:34:06,480 --> 00:34:11,919
beginning of the page

00:34:08,720 --> 00:34:15,440
and that that proved to be that that's

00:34:11,919 --> 00:34:18,159
that pretty very hard to do and it

00:34:15,440 --> 00:34:18,800
involved changing how the page cache

00:34:18,159 --> 00:34:20,960
worked

00:34:18,800 --> 00:34:24,159
so that one isn't upstream yet but that

00:34:20,960 --> 00:34:24,159
is still pending

00:34:25,119 --> 00:34:29,119
and yet another problem i had is that

00:34:27,760 --> 00:34:31,359
various page cache functions were

00:34:29,119 --> 00:34:33,839
returning

00:34:31,359 --> 00:34:35,839
individual pages rather than just the

00:34:33,839 --> 00:34:37,520
head page

00:34:35,839 --> 00:34:38,800
or as i should now say portfolio it

00:34:37,520 --> 00:34:41,200
doesn't push the folio returns the

00:34:38,800 --> 00:34:44,320
struct pad agent so

00:34:41,200 --> 00:34:47,440
when we had um

00:34:44,320 --> 00:34:48,960
a compound page and we said

00:34:47,440 --> 00:34:51,200
give me all the pages between here and

00:34:48,960 --> 00:34:52,879
there it would actually return each of

00:34:51,200 --> 00:34:54,879
the individual pages

00:34:52,879 --> 00:34:56,320
whereas what almost every user wants is

00:34:54,879 --> 00:34:59,680
to be given

00:34:56,320 --> 00:35:03,040
just the head pages and so

00:34:59,680 --> 00:35:04,560
i had to go and audit all the places

00:35:03,040 --> 00:35:06,160
that use those functions and make sure

00:35:04,560 --> 00:35:10,000
that they were actually okay

00:35:06,160 --> 00:35:11,760
with receiving just the head page

00:35:10,000 --> 00:35:13,760
and some of those patches are currently

00:35:11,760 --> 00:35:16,640
in some are not

00:35:13,760 --> 00:35:19,280
uh there's about 50 patches so

00:35:16,640 --> 00:35:19,280
outstanding

00:35:20,240 --> 00:35:23,760
and there are some things i haven't

00:35:22,079 --> 00:35:27,280
fixed i i haven't

00:35:23,760 --> 00:35:30,720
figured out how to do at all um

00:35:27,280 --> 00:35:33,680
one of them is splitting of foliage so

00:35:30,720 --> 00:35:34,880
you'd want to do this if for example you

00:35:33,680 --> 00:35:37,040
have

00:35:34,880 --> 00:35:38,240
you know a cached file on the page cache

00:35:37,040 --> 00:35:40,400
and then you

00:35:38,240 --> 00:35:42,000
punch a hole in the middle of it or you

00:35:40,400 --> 00:35:45,839
truncate it down you need to trim

00:35:42,000 --> 00:35:45,839
off the end of the page

00:35:45,920 --> 00:35:53,280
and a lot of file systems will keep

00:35:49,440 --> 00:35:55,119
uh sub page information so

00:35:53,280 --> 00:35:56,960
uh often the block size of the file

00:35:55,119 --> 00:35:57,920
system will be smaller than the page

00:35:56,960 --> 00:35:59,040
size and particularly if using a

00:35:57,920 --> 00:36:01,599
transparent huge page

00:35:59,040 --> 00:36:02,400
it will definitely be smaller than that

00:36:01,599 --> 00:36:03,839
than

00:36:02,400 --> 00:36:05,760
the size that the block size will

00:36:03,839 --> 00:36:07,839
definitely small inside the page

00:36:05,760 --> 00:36:09,359
and so file systems will allocate small

00:36:07,839 --> 00:36:12,320
data structures

00:36:09,359 --> 00:36:12,960
and this is for example buffer heads are

00:36:12,320 --> 00:36:15,119
used for

00:36:12,960 --> 00:36:16,960
one things above the heads are useful is

00:36:15,119 --> 00:36:20,079
to keep track

00:36:16,960 --> 00:36:24,160
of individual

00:36:20,079 --> 00:36:27,520
uh disk blocks and whether the

00:36:24,160 --> 00:36:30,400
uh whether they individually are dirty

00:36:27,520 --> 00:36:30,400
or up-to-date

00:36:31,040 --> 00:36:39,280
and so when we come to split a page

00:36:35,760 --> 00:36:41,280
we then somehow have to re distribute

00:36:39,280 --> 00:36:43,200
the information that the file system is

00:36:41,280 --> 00:36:46,720
stored in the head page

00:36:43,200 --> 00:36:50,480
amongst all of the sub pages that the

00:36:46,720 --> 00:36:53,520
the huge page is being split into

00:36:50,480 --> 00:36:54,960
and that is very hard to do and so i'm

00:36:53,520 --> 00:36:55,920
trying to figure out various different

00:36:54,960 --> 00:36:58,720
ways to

00:36:55,920 --> 00:37:00,240
make that more efficient than it

00:36:58,720 --> 00:37:02,720
currently is

00:37:00,240 --> 00:37:04,320
and uh i'm i'm currently working around

00:37:02,720 --> 00:37:08,880
it by saying well

00:37:04,320 --> 00:37:11,839
we only allocate um

00:37:08,880 --> 00:37:13,680
we only allocate huge pages on veda head

00:37:11,839 --> 00:37:14,320
and that makes my life a lot easier

00:37:13,680 --> 00:37:18,640
because

00:37:14,320 --> 00:37:20,960
um the the the

00:37:18,640 --> 00:37:22,000
uh the page cannot be both dirty and

00:37:20,960 --> 00:37:25,599
up-to-date and

00:37:22,000 --> 00:37:27,359
not up-to-date um so i don't have to

00:37:25,599 --> 00:37:28,560
distribute quite as much information

00:37:27,359 --> 00:37:31,920
between the the

00:37:28,560 --> 00:37:31,920
the sub pages as uh

00:37:32,160 --> 00:37:36,720
but it's it's definitely probably needs

00:37:34,320 --> 00:37:38,400
to be fixed before i do the right

00:37:36,720 --> 00:37:39,680
support

00:37:38,400 --> 00:37:42,400
because then you can definitely have

00:37:39,680 --> 00:37:44,960
pages which are partially up-to-date

00:37:42,400 --> 00:37:46,640
and and partially dirty and it gets to

00:37:44,960 --> 00:37:48,839
be very very complicated

00:37:46,640 --> 00:37:50,240
and and you can't lose any of this

00:37:48,839 --> 00:37:52,560
information

00:37:50,240 --> 00:37:54,240
because then you you end up actually

00:37:52,560 --> 00:37:54,640
losing users data and people don't like

00:37:54,240 --> 00:37:57,839
it with

00:37:54,640 --> 00:38:01,839
the data and of course there are

00:37:57,839 --> 00:38:04,160
many many bugs to fix um

00:38:01,839 --> 00:38:08,320
that's basically my entire life right

00:38:04,160 --> 00:38:08,320
now is fixing bugs in in this patch set

00:38:08,880 --> 00:38:14,880
uh and then of course there's the things

00:38:11,760 --> 00:38:17,440
to do like allocating photos all right

00:38:14,880 --> 00:38:19,200
uh we have this uh kernel thread called

00:38:17,440 --> 00:38:22,800
k huge phd

00:38:19,200 --> 00:38:24,960
which tries to combine

00:38:22,800 --> 00:38:26,240
individual pages into a transparent huge

00:38:24,960 --> 00:38:29,440
page a pnd

00:38:26,240 --> 00:38:33,359
size transparent page and

00:38:29,440 --> 00:38:35,359
right now it sees that we have um

00:38:33,359 --> 00:38:37,040
we have large pages which are not

00:38:35,359 --> 00:38:38,079
necessarily pnd sites and it just gives

00:38:37,040 --> 00:38:40,560
up

00:38:38,079 --> 00:38:41,599
it says no i i i don't know how to how

00:38:40,560 --> 00:38:43,200
to deal with that

00:38:41,599 --> 00:38:44,800
it probably wouldn't be a lot of work to

00:38:43,200 --> 00:38:48,480
do um

00:38:44,800 --> 00:38:50,320
i just haven't prioritized doing it

00:38:48,480 --> 00:38:52,640
so if somebody wants a task to take on

00:38:50,320 --> 00:38:57,040
that that's that's something that uh

00:38:52,640 --> 00:38:58,480
definitely could be done uh

00:38:57,040 --> 00:39:00,079
so despite saying earlier that i'm doing

00:38:58,480 --> 00:39:01,440
this entirely for software reasons not

00:39:00,079 --> 00:39:04,960
for hardware reasons

00:39:01,440 --> 00:39:07,599
there are um

00:39:04,960 --> 00:39:08,000
architectures which support tlb entries

00:39:07,599 --> 00:39:12,160
which

00:39:08,000 --> 00:39:14,800
are larger than order zero

00:39:12,160 --> 00:39:15,920
but smaller than a pnd sized and one

00:39:14,800 --> 00:39:20,000
example that is 60

00:39:15,920 --> 00:39:20,000
our arm support 64 kilobyte pages

00:39:20,079 --> 00:39:25,200
and right now we don't have a good api

00:39:23,200 --> 00:39:26,640
for telling the architecture hey i want

00:39:25,200 --> 00:39:29,680
you to put in

00:39:26,640 --> 00:39:31,599
uh you know the the this this 64

00:39:29,680 --> 00:39:33,359
kilobyte page i've allocated i will put

00:39:31,599 --> 00:39:36,320
all 64 kilobytes of it into the

00:39:33,359 --> 00:39:38,160
into the page tables and uh it would be

00:39:36,320 --> 00:39:40,800
nice to have that

00:39:38,160 --> 00:39:42,240
um i i again this has just not made it's

00:39:40,800 --> 00:39:45,359
the top of my

00:39:42,240 --> 00:39:49,200
list yet and i would also like to

00:39:45,359 --> 00:39:50,800
support folios in butterfest and dxt4

00:39:49,200 --> 00:39:53,200
there are problems with both of those

00:39:50,800 --> 00:39:56,079
file systems they're not insurmountable

00:39:53,200 --> 00:39:57,680
uh we we absolutely can perform under

00:39:56,079 --> 00:39:58,720
some circumstances in both those file

00:39:57,680 --> 00:40:01,200
systems

00:39:58,720 --> 00:40:02,400
um it's just like i chose to start

00:40:01,200 --> 00:40:05,920
working on xfs

00:40:02,400 --> 00:40:08,240
and uh it's it's the

00:40:05,920 --> 00:40:10,560
only one currently working um i

00:40:08,240 --> 00:40:13,280
shouldn't say the only one because um

00:40:10,560 --> 00:40:15,280
dave howells has afs working with

00:40:13,280 --> 00:40:19,440
transparent huge ranges as well

00:40:15,280 --> 00:40:21,599
so there's uh i think the other fastest

00:40:19,440 --> 00:40:22,720
network file systems are not too far

00:40:21,599 --> 00:40:26,960
behind it

00:40:22,720 --> 00:40:31,040
um i i i want to take a crack at nfs

00:40:26,960 --> 00:40:33,280
um fairly shortly but um

00:40:31,040 --> 00:40:34,720
yeah there's that you know i have to i

00:40:33,280 --> 00:40:35,680
have to fix the bugs and the codes i

00:40:34,720 --> 00:40:39,839
currently have before i

00:40:35,680 --> 00:40:39,839
start writing anymore

00:40:41,359 --> 00:40:47,839
so was it worth it well we

00:40:44,800 --> 00:40:49,440
so curtin bench is a benchmark

00:40:47,839 --> 00:40:52,240
which just compiles the kernel which is

00:40:49,440 --> 00:40:53,920
obviously the most important workload

00:40:52,240 --> 00:40:55,520
and one of my colleagues was kind enough

00:40:53,920 --> 00:40:57,680
to run the benchmark for me

00:40:55,520 --> 00:40:59,200
and he saw a six percent reduction in

00:40:57,680 --> 00:41:02,079
kernel time

00:40:59,200 --> 00:41:02,560
and so the the the actual time went down

00:41:02,079 --> 00:41:06,079
i think

00:41:02,560 --> 00:41:10,480
from uh 100 uh

00:41:06,079 --> 00:41:11,760
maybe 210 seconds to 204 seconds

00:41:10,480 --> 00:41:14,000
but you have to remember that most of

00:41:11,760 --> 00:41:17,839
that time is

00:41:14,000 --> 00:41:22,079
spent in user space running gcc

00:41:17,839 --> 00:41:25,280
so the the the the bit that

00:41:22,079 --> 00:41:27,839
we can control i.e kernel time uh

00:41:25,280 --> 00:41:28,560
when went down substantially six percent

00:41:27,839 --> 00:41:32,079
i mean that

00:41:28,560 --> 00:41:34,079
that that's pretty good uh for

00:41:32,079 --> 00:41:36,560
a benchmark which we optimized so

00:41:34,079 --> 00:41:39,599
heavily for

00:41:36,560 --> 00:41:41,200
so on purpose so i i've put the uh the

00:41:39,599 --> 00:41:43,040
get tree in my slides

00:41:41,200 --> 00:41:46,240
uh you can go off and take a look at

00:41:43,040 --> 00:41:49,359
what i currently have

00:41:46,240 --> 00:41:52,319
um so to summarize um

00:41:49,359 --> 00:41:55,359
we get shorter liu lists water lock hold

00:41:52,319 --> 00:41:58,480
times fewer cache misses

00:41:55,359 --> 00:42:01,839
uh a tangential effect is that

00:41:58,480 --> 00:42:04,160
it's very hard at the moment to allocate

00:42:01,839 --> 00:42:06,000
larger pages and we actually allocate

00:42:04,160 --> 00:42:09,440
large pages for a lot of things

00:42:06,000 --> 00:42:11,119
um but it can be quite tricky

00:42:09,440 --> 00:42:13,040
under that there's a lot of

00:42:11,119 --> 00:42:14,160
fragmentation a lot of the fragmentation

00:42:13,040 --> 00:42:16,400
is actually due

00:42:14,160 --> 00:42:18,240
to the page cache the page cache will

00:42:16,400 --> 00:42:19,040
just allocate all the zero pages all the

00:42:18,240 --> 00:42:22,240
time

00:42:19,040 --> 00:42:25,280
and it will it will um

00:42:22,240 --> 00:42:27,119
make it very hard for larger pages to be

00:42:25,280 --> 00:42:28,960
created

00:42:27,119 --> 00:42:30,160
um if the page cache is allocating

00:42:28,960 --> 00:42:31,760
larger pages

00:42:30,160 --> 00:42:33,359
then the page cache can free larger

00:42:31,760 --> 00:42:35,599
pages too and

00:42:33,359 --> 00:42:37,599
it will make the entire system less

00:42:35,599 --> 00:42:41,040
fragmented

00:42:37,599 --> 00:42:43,680
uh we do larger ios to storage

00:42:41,040 --> 00:42:45,599
and maybe we'll be able to get rid of 16

00:42:43,680 --> 00:42:48,400
kilobyte or 64 kilobyte page size

00:42:45,599 --> 00:42:48,400
configurations

00:42:50,480 --> 00:42:57,599
i have i'm well i'm the main developer

00:42:54,560 --> 00:42:58,560
on this i'm doing most of the work this

00:42:57,599 --> 00:43:02,480
would not be possible

00:42:58,560 --> 00:43:05,599
without uh the help of so many people

00:43:02,480 --> 00:43:07,040
um these the people who i was able to

00:43:05,599 --> 00:43:08,480
think of this afternoon while i was

00:43:07,040 --> 00:43:12,079
writing these slides

00:43:08,480 --> 00:43:15,359
um i know if i i know i missed a

00:43:12,079 --> 00:43:15,599
song off this list for that uh but yes

00:43:15,359 --> 00:43:17,760
we

00:43:15,599 --> 00:43:19,359
we have contributions from all over the

00:43:17,760 --> 00:43:21,040
landscape the first system people here

00:43:19,359 --> 00:43:22,480
memory management people

00:43:21,040 --> 00:43:24,839
uh people are just generally sort of

00:43:22,480 --> 00:43:27,760
interested in this kind of thing

00:43:24,839 --> 00:43:29,920
um lots of people are

00:43:27,760 --> 00:43:30,800
giving their time to help make this

00:43:29,920 --> 00:43:33,440
possible

00:43:30,800 --> 00:43:34,240
and i want to thank all of them um it's

00:43:33,440 --> 00:43:36,720
it's been

00:43:34,240 --> 00:43:38,560
um it's been really fun working on this

00:43:36,720 --> 00:43:41,839
project we've

00:43:38,560 --> 00:43:41,839
covered a lot of ground

00:43:42,240 --> 00:43:49,040
so um thank you all for attending

00:43:46,000 --> 00:43:51,200
uh if you want to ask questions i'm i'm

00:43:49,040 --> 00:43:53,359
looking at the chat window right now

00:43:51,200 --> 00:44:09,839
um i believe we have about five minutes

00:43:53,359 --> 00:44:09,839
left in this presentation

00:44:44,319 --> 00:44:51,359
well i don't see any questions so

00:44:48,160 --> 00:44:51,760
thank you all for attending and uh i

00:44:51,359 --> 00:44:54,400
will

00:44:51,760 --> 00:45:05,839
stop the broadcast now please enjoy the

00:44:54,400 --> 00:45:05,839
rest of the conference

00:45:08,160 --> 00:45:10,240

YouTube URL: https://www.youtube.com/watch?v=hoSpvGxXgNg


