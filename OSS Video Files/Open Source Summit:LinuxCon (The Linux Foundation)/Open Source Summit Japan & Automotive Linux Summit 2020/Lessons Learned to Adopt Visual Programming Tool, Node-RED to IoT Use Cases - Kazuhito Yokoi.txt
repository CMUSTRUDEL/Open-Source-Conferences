Title: Lessons Learned to Adopt Visual Programming Tool, Node-RED to IoT Use Cases - Kazuhito Yokoi
Publication date: 2020-12-04
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Lessons Learned to Adopt Visual Programming Tool, Node-RED to IoT Use Cases - Kazuhito Yokoi, Hitachi, Ltd.
Captions: 
	00:00:03,520 --> 00:00:07,680
hello everyone

00:00:04,720 --> 00:00:08,480
my name is kazushio koi from starch

00:00:07,680 --> 00:00:11,599
today

00:00:08,480 --> 00:00:14,480
i'd like to talk about lessons learned

00:00:11,599 --> 00:00:15,040
to adopt visual programming tool node

00:00:14,480 --> 00:00:20,240
red

00:00:15,040 --> 00:00:20,240
to iot use cases let me start

00:00:22,960 --> 00:00:26,960
hi i'm kazuki okay i am a software

00:00:26,160 --> 00:00:30,080
engineer

00:00:26,960 --> 00:00:34,399
in hitachi on github i

00:00:30,080 --> 00:00:37,520
am one of maintainers in nodred project

00:00:34,399 --> 00:00:40,640
i developed another generator tool

00:00:37,520 --> 00:00:42,879
for node-red project and

00:00:40,640 --> 00:00:44,559
in hitachi there is a node-red

00:00:42,879 --> 00:00:48,000
contribution team

00:00:44,559 --> 00:00:52,320
we are 19 contributors

00:00:48,000 --> 00:00:53,600
and we have added over 80 000 lines of

00:00:52,320 --> 00:00:57,199
code

00:00:53,600 --> 00:01:00,800
and in terms of commit we have added

00:00:57,199 --> 00:01:04,400
over seven hundred comments

00:01:00,800 --> 00:01:07,680
for moderate project and

00:01:04,400 --> 00:01:11,680
there are two open source project

00:01:07,680 --> 00:01:15,040
which are originated by hitach so

00:01:11,680 --> 00:01:19,600
we developed and managed

00:01:15,040 --> 00:01:19,600
to open source project on github

00:01:22,720 --> 00:01:27,920
let me introduce about our iot platform

00:01:26,400 --> 00:01:31,280
lumada

00:01:27,920 --> 00:01:35,520
it is our iot platform to realize

00:01:31,280 --> 00:01:35,520
digital innovation with partners

00:01:36,479 --> 00:01:40,400
according to the gartner's report

00:01:39,200 --> 00:01:43,600
hitachi is

00:01:40,400 --> 00:01:46,640
one of data in industry iot

00:01:43,600 --> 00:01:50,799
market there is the name

00:01:46,640 --> 00:01:54,240
of dutch on the depot

00:01:50,799 --> 00:01:57,759
and of course we have used node red

00:01:54,240 --> 00:02:00,880
in dumada to realize component

00:01:57,759 --> 00:02:00,880
of the model

00:02:02,320 --> 00:02:08,239
to make the iot platform open

00:02:05,520 --> 00:02:09,200
we have used a lot of open source

00:02:08,239 --> 00:02:13,280
software

00:02:09,200 --> 00:02:16,319
on the mother to fill our requirement

00:02:13,280 --> 00:02:19,599
and improve the quality of code

00:02:16,319 --> 00:02:23,280
we are using upstream fast style

00:02:19,599 --> 00:02:26,160
development in this style

00:02:23,280 --> 00:02:27,040
we are always publishing the new

00:02:26,160 --> 00:02:31,519
features

00:02:27,040 --> 00:02:35,200
of open source software on github

00:02:31,519 --> 00:02:38,480
and in this style we can get the

00:02:35,200 --> 00:02:42,319
of feedback from open source community

00:02:38,480 --> 00:02:45,040
and improve the open source software

00:02:42,319 --> 00:02:45,040
rapidly

00:02:45,840 --> 00:02:52,640
from this slide i will introduce

00:02:49,120 --> 00:02:52,640
what is node red

00:02:53,360 --> 00:03:00,159
node red is low code programming tool

00:02:56,400 --> 00:03:04,560
to create solutions rapidly in node red

00:03:00,159 --> 00:03:08,560
history it was developed by ibm uk

00:03:04,560 --> 00:03:12,159
in 2014 and after that

00:03:08,560 --> 00:03:15,760
this project was transferred to

00:03:12,159 --> 00:03:16,560
js foundation currently it is openjs

00:03:15,760 --> 00:03:19,920
foundation

00:03:16,560 --> 00:03:23,599
under the linux foundation so

00:03:19,920 --> 00:03:26,879
everyone can contribute to the open

00:03:23,599 --> 00:03:29,760
open source project node red

00:03:26,879 --> 00:03:30,080
is pre-installed software in raspberry

00:03:29,760 --> 00:03:34,000
pi

00:03:30,080 --> 00:03:37,120
linux os so when we get to

00:03:34,000 --> 00:03:38,000
raspberry pi device node red is

00:03:37,120 --> 00:03:41,920
available

00:03:38,000 --> 00:03:46,720
on your device so it is good for

00:03:41,920 --> 00:03:50,080
a lot of users for example hobby users

00:03:46,720 --> 00:03:53,519
and students who want to

00:03:50,080 --> 00:03:58,840
run iot using raspberry pi

00:03:53,519 --> 00:04:02,319
and in company raspberry pi compatible

00:03:58,840 --> 00:04:06,959
devices is can be used

00:04:02,319 --> 00:04:10,720
to via iot use case

00:04:06,959 --> 00:04:10,720
in for example factories

00:04:10,879 --> 00:04:14,480
top right screenshot is node red pro

00:04:13,439 --> 00:04:17,440
editor

00:04:14,480 --> 00:04:19,280
on node-red pro editor there are a lot

00:04:17,440 --> 00:04:22,880
of connectors

00:04:19,280 --> 00:04:28,240
and the user can use the connectors

00:04:22,880 --> 00:04:31,280
to create their applications

00:04:28,240 --> 00:04:32,240
we surveyed the number of nodulated user

00:04:31,280 --> 00:04:35,520
companies

00:04:32,240 --> 00:04:38,960
in global fortune report

00:04:35,520 --> 00:04:39,280
according to our survey a half of global

00:04:38,960 --> 00:04:42,479
tech

00:04:39,280 --> 00:04:44,560
companies have used nodulate in their

00:04:42,479 --> 00:04:47,759
production environment

00:04:44,560 --> 00:04:50,320
or they introduce nodulate on their

00:04:47,759 --> 00:04:53,759
website

00:04:50,320 --> 00:04:56,960
for example widgets uses node red

00:04:53,759 --> 00:05:00,400
in their columnar home

00:04:56,960 --> 00:05:03,440
and nvc uses their

00:05:00,400 --> 00:05:06,560
obligated software

00:05:03,440 --> 00:05:09,680
and recently red hat

00:05:06,560 --> 00:05:12,560
released to open shift operator

00:05:09,680 --> 00:05:12,560
for node red

00:05:13,039 --> 00:05:17,600
so you can understand a lot of user

00:05:16,639 --> 00:05:21,360
companies

00:05:17,600 --> 00:05:21,360
are there in global

00:05:23,120 --> 00:05:30,080
last year node.red project released to

00:05:26,880 --> 00:05:33,520
version 1.0 of course

00:05:30,080 --> 00:05:36,880
it means api is

00:05:33,520 --> 00:05:40,320
stable and it is ready to

00:05:36,880 --> 00:05:43,520
for production environment

00:05:40,320 --> 00:05:45,840
and this year moderate project announced

00:05:43,520 --> 00:05:47,039
release plans including long-term

00:05:45,840 --> 00:05:50,400
support

00:05:47,039 --> 00:05:52,240
as you can see on the timeline we can

00:05:50,400 --> 00:05:55,759
continue to use

00:05:52,240 --> 00:05:59,039
major version more than one year

00:05:55,759 --> 00:06:02,240
it is good information for

00:05:59,039 --> 00:06:07,840
offline environment especially

00:06:02,240 --> 00:06:07,840
factories or inside companies

00:06:07,919 --> 00:06:14,960
nodulate supports various environment

00:06:11,120 --> 00:06:18,240
for example edge devices token images

00:06:14,960 --> 00:06:21,360
on cloud environment and local pc

00:06:18,240 --> 00:06:24,560
or local servers and

00:06:21,360 --> 00:06:27,600
this diagram shows systems

00:06:24,560 --> 00:06:30,720
using node red

00:06:27,600 --> 00:06:34,240
on left side all these systems

00:06:30,720 --> 00:06:37,280
edge devices can be used to collect

00:06:34,240 --> 00:06:41,759
sensor data directory and

00:06:37,280 --> 00:06:46,000
if the cloud environment is available

00:06:41,759 --> 00:06:51,120
edge device can send the sensor data

00:06:46,000 --> 00:06:54,160
to cloud environment via mqtt protocol

00:06:51,120 --> 00:06:56,400
on cloud environment node red can store

00:06:54,160 --> 00:07:00,960
sensor data to the data lake

00:06:56,400 --> 00:07:00,960
like mysql or file systems

00:07:01,039 --> 00:07:05,199
on id systems if there is existing

00:07:04,319 --> 00:07:09,039
systems

00:07:05,199 --> 00:07:14,240
or external services you can connect it

00:07:09,039 --> 00:07:14,240
to the services via the test api

00:07:15,440 --> 00:07:24,080
as of this year there are about

00:07:18,880 --> 00:07:27,199
3 000 connectors to create application

00:07:24,080 --> 00:07:31,680
to correct sensor data you can use

00:07:27,199 --> 00:07:35,039
camera node for capture camera

00:07:31,680 --> 00:07:39,840
and a modbus node to collect

00:07:35,039 --> 00:07:39,840
sensor data via modbus protocol

00:07:39,919 --> 00:07:46,879
and to control devices you can use

00:07:43,520 --> 00:07:49,919
serial node or gpio node

00:07:46,879 --> 00:07:49,919
for raspberry pi

00:07:50,000 --> 00:07:53,919
and if you want to connect to external

00:07:52,800 --> 00:07:58,160
systems

00:07:53,919 --> 00:08:01,520
websocket mqtt and hdd protocols

00:07:58,160 --> 00:08:05,199
are supported in node red and

00:08:01,520 --> 00:08:09,360
there is database connectors for example

00:08:05,199 --> 00:08:12,720
mysql postgresql oracle db

00:08:09,360 --> 00:08:16,479
and if you want to analyze

00:08:12,720 --> 00:08:19,919
a locally or own cloud you can use

00:08:16,479 --> 00:08:20,479
analysis connector to analyze sensor

00:08:19,919 --> 00:08:24,000
data

00:08:20,479 --> 00:08:27,199
or image data and the

00:08:24,000 --> 00:08:30,639
last thing is visualization

00:08:27,199 --> 00:08:36,159
to visualize sensor data node red

00:08:30,639 --> 00:08:36,159
has dashboard for visualize the data

00:08:36,719 --> 00:08:39,760
in this slide i would like to explain

00:08:39,200 --> 00:08:42,880
about

00:08:39,760 --> 00:08:45,600
the architecture inside node red

00:08:42,880 --> 00:08:46,640
as we can understand from the name of

00:08:45,600 --> 00:08:49,760
node red

00:08:46,640 --> 00:08:51,279
node red is executed on node.js

00:08:49,760 --> 00:08:54,399
environment

00:08:51,279 --> 00:08:55,760
in node.js environment there are two

00:08:54,399 --> 00:08:59,360
points

00:08:55,760 --> 00:08:59,360
first is a single thread

00:08:59,519 --> 00:09:07,040
when node.js executes program

00:09:03,040 --> 00:09:09,440
node.js use one cpu core

00:09:07,040 --> 00:09:11,760
and the second is non-blocking

00:09:09,440 --> 00:09:15,120
asynchronous io

00:09:11,760 --> 00:09:19,200
and node.js access to multiple

00:09:15,120 --> 00:09:22,959
external io not just use

00:09:19,200 --> 00:09:26,160
the io simultaneously

00:09:22,959 --> 00:09:31,279
so we need to care about

00:09:26,160 --> 00:09:31,279
the characteristics of the node.js

00:09:32,959 --> 00:09:39,839
from now i will talk about lessons

00:09:36,000 --> 00:09:39,839
around to adopt node red

00:09:40,000 --> 00:09:44,080
when we started to use node red in

00:09:42,560 --> 00:09:46,880
production system

00:09:44,080 --> 00:09:48,399
we encountered some concerns about

00:09:46,880 --> 00:09:52,880
stable operations

00:09:48,399 --> 00:09:55,440
and performance actually we have some of

00:09:52,880 --> 00:09:57,040
some knowledge about linux environment

00:09:55,440 --> 00:10:00,880
or java environment

00:09:57,040 --> 00:10:04,640
in our company on the other hand

00:10:00,880 --> 00:10:09,120
we have no knowledge about node.js

00:10:04,640 --> 00:10:12,240
and node-red for stable operations

00:10:09,120 --> 00:10:15,279
to solve the problem we evaluated

00:10:12,240 --> 00:10:17,040
the performance of node-red in our major

00:10:15,279 --> 00:10:20,079
use cases

00:10:17,040 --> 00:10:23,920
and there are two use cases

00:10:20,079 --> 00:10:26,720
the first is the data management

00:10:23,920 --> 00:10:28,560
system to collect values from sensor

00:10:26,720 --> 00:10:31,680
devices

00:10:28,560 --> 00:10:36,480
and the second scenario is a system

00:10:31,680 --> 00:10:36,480
integration to call multiple apis

00:10:36,959 --> 00:10:42,240
let me introduce scenario 1 from null

00:10:42,880 --> 00:10:46,079
this slide shows about the details of

00:10:45,760 --> 00:10:48,880
the

00:10:46,079 --> 00:10:50,240
data management system to collect sensor

00:10:48,880 --> 00:10:54,560
data

00:10:50,240 --> 00:10:57,920
as we can see on the light picture

00:10:54,560 --> 00:11:01,360
there are 10 million power meters on

00:10:57,920 --> 00:11:04,320
houses or stores and

00:11:01,360 --> 00:11:05,600
the data management system collects the

00:11:04,320 --> 00:11:09,279
sensor data

00:11:05,600 --> 00:11:13,040
every 30 minutes and

00:11:09,279 --> 00:11:18,000
in the system we want to evaluate

00:11:13,040 --> 00:11:18,000
the performance in edge use cases

00:11:18,399 --> 00:11:24,000
this slide shows the system overview

00:11:21,600 --> 00:11:25,440
to realize the metadata management

00:11:24,000 --> 00:11:30,240
system

00:11:25,440 --> 00:11:33,839
one meter sends three types of data

00:11:30,240 --> 00:11:37,760
first is meter id and second is

00:11:33,839 --> 00:11:41,600
timestamp and third is power usage

00:11:37,760 --> 00:11:45,920
and the power meters send the

00:11:41,600 --> 00:11:47,120
data to mqtt broker via the mqtt

00:11:45,920 --> 00:11:50,079
protocol

00:11:47,120 --> 00:11:51,200
and the node-red servers retrieve the

00:11:50,079 --> 00:11:54,399
sensor data

00:11:51,200 --> 00:11:58,639
via the mqtt broker

00:11:54,399 --> 00:12:02,000
and node-red servers store the data to

00:11:58,639 --> 00:12:05,839
nosql dvd via the hdd

00:12:02,000 --> 00:12:08,959
protocol node red supports

00:12:05,839 --> 00:12:12,399
both mqtt protocol and

00:12:08,959 --> 00:12:15,680
http protocol by default

00:12:12,399 --> 00:12:16,480
so node return can easily collect sensor

00:12:15,680 --> 00:12:21,839
data

00:12:16,480 --> 00:12:21,839
and save the data to other systems

00:12:22,399 --> 00:12:28,639
as i said in the previous slide we use

00:12:25,839 --> 00:12:30,480
default node red connectors to create

00:12:28,639 --> 00:12:33,279
node red flow

00:12:30,480 --> 00:12:35,600
to monitor resource usage we used our

00:12:33,279 --> 00:12:38,320
performance tool

00:12:35,600 --> 00:12:38,959
and to compare with single node.red

00:12:38,320 --> 00:12:41,600
server

00:12:38,959 --> 00:12:42,959
with multiple node-red servers in terms

00:12:41,600 --> 00:12:47,680
of scaling

00:12:42,959 --> 00:12:47,680
we prepared 900 servers

00:12:48,880 --> 00:12:53,200
we used two methods to understand the

00:12:51,519 --> 00:12:57,120
performance

00:12:53,200 --> 00:13:01,040
first is for a node-red single server

00:12:57,120 --> 00:13:02,000
firstly we added 1.5 million power

00:13:01,040 --> 00:13:05,040
meters

00:13:02,000 --> 00:13:09,519
and then we evaluated

00:13:05,040 --> 00:13:14,160
the resource usage of the nodal server

00:13:09,519 --> 00:13:15,200
and then we added more 1.5 million power

00:13:14,160 --> 00:13:18,240
meters

00:13:15,200 --> 00:13:21,440
and then we evaluated

00:13:18,240 --> 00:13:23,200
the resource usage again in this

00:13:21,440 --> 00:13:26,880
step-by-step method

00:13:23,200 --> 00:13:30,240
we understand the limit of the

00:13:26,880 --> 00:13:30,240
single node rate server

00:13:31,760 --> 00:13:35,920
as a result a single nodulator server

00:13:35,279 --> 00:13:39,120
used

00:13:35,920 --> 00:13:43,440
all of cpu usage before reaching

00:13:39,120 --> 00:13:46,480
our requirement 10 million power meters

00:13:43,440 --> 00:13:47,519
as you can understand the picture and

00:13:46,480 --> 00:13:50,639
graph

00:13:47,519 --> 00:13:53,920
when we used two five

00:13:50,639 --> 00:13:54,480
million power meters the cpu usage

00:13:53,920 --> 00:13:58,079
becomes

00:13:54,480 --> 00:14:01,440
full so we cannot handle all of

00:13:58,079 --> 00:14:04,480
the data in the case in case

00:14:01,440 --> 00:14:05,519
of the 2 million power meters the

00:14:04,480 --> 00:14:08,800
throughput

00:14:05,519 --> 00:14:12,079
is about 1 000 data

00:14:08,800 --> 00:14:15,279
per second correctly but we

00:14:12,079 --> 00:14:18,959
need more throughput

00:14:15,279 --> 00:14:18,959
to fill our requirement

00:14:20,240 --> 00:14:27,199
this evaluation is for multiple nodes

00:14:23,279 --> 00:14:30,800
servers we used 10 million power meters

00:14:27,199 --> 00:14:33,680
in all of cases as the first step

00:14:30,800 --> 00:14:34,000
we prepared one node red single server

00:14:33,680 --> 00:14:36,560
and

00:14:34,000 --> 00:14:37,279
then we checked the resource usage of

00:14:36,560 --> 00:14:40,480
the node

00:14:37,279 --> 00:14:43,519
server in the second step

00:14:40,480 --> 00:14:46,320
we added more 100 server and

00:14:43,519 --> 00:14:48,000
then check the resource usage of the two

00:14:46,320 --> 00:14:51,040
servers

00:14:48,000 --> 00:14:51,920
using the step-by-step scaling out

00:14:51,040 --> 00:14:54,480
method

00:14:51,920 --> 00:14:55,279
we surveyed the minimum number of the

00:14:54,480 --> 00:14:58,959
servers

00:14:55,279 --> 00:15:01,839
to handle the data correctly

00:14:58,959 --> 00:15:03,760
this graph shows the result of our

00:15:01,839 --> 00:15:07,199
evaluation

00:15:03,760 --> 00:15:11,600
and in our evaluation we added

00:15:07,199 --> 00:15:13,680
modulated server and the cpu usage

00:15:11,600 --> 00:15:16,959
decreased gradually

00:15:13,680 --> 00:15:20,160
and as a result we understand

00:15:16,959 --> 00:15:23,839
the minimum number of moderate server

00:15:20,160 --> 00:15:26,959
is aid to a stable operation

00:15:23,839 --> 00:15:27,920
and there are no bottleneck in other

00:15:26,959 --> 00:15:32,720
components

00:15:27,920 --> 00:15:32,720
like mqtt broker or network

00:15:33,920 --> 00:15:40,720
based on our evaluation we found

00:15:37,279 --> 00:15:42,000
that the throughput depends on one cpu

00:15:40,720 --> 00:15:45,199
core performance

00:15:42,000 --> 00:15:49,120
in a single node red server because

00:15:45,199 --> 00:15:52,160
single thread of the node.js environment

00:15:49,120 --> 00:15:55,519
to solve the situation

00:15:52,160 --> 00:15:58,320
there are two options first

00:15:55,519 --> 00:15:58,959
is increasing the number of node rep

00:15:58,320 --> 00:16:02,240
server

00:15:58,959 --> 00:16:05,600
to scale out and the second

00:16:02,240 --> 00:16:06,959
option is using multiple node-red

00:16:05,600 --> 00:16:10,160
processes

00:16:06,959 --> 00:16:13,360
in many cpu core servers

00:16:10,160 --> 00:16:16,240
for second solution we think that

00:16:13,360 --> 00:16:17,199
container environment will be effective

00:16:16,240 --> 00:16:20,480
so

00:16:17,199 --> 00:16:23,600
we evaluated container environment

00:16:20,480 --> 00:16:23,600
in scenario two

00:16:23,759 --> 00:16:29,279
from this slide i will introduce

00:16:26,399 --> 00:16:29,279
scenario two

00:16:30,240 --> 00:16:36,399
the scenario two is the system

00:16:32,560 --> 00:16:40,000
integration to call multiple rest api

00:16:36,399 --> 00:16:43,440
it is web system to compare with

00:16:40,000 --> 00:16:46,639
travel plans in this

00:16:43,440 --> 00:16:50,639
website 20 million users

00:16:46,639 --> 00:16:53,759
access the website and then the website

00:16:50,639 --> 00:16:54,240
called the external website to retrieve

00:16:53,759 --> 00:16:57,839
the

00:16:54,240 --> 00:17:01,839
travel plans and then the website

00:16:57,839 --> 00:17:06,799
returns suitable travel plans for users

00:17:01,839 --> 00:17:06,799
based on user conduct such conditions

00:17:06,959 --> 00:17:14,720
in our requirement the number of users

00:17:10,240 --> 00:17:19,600
is 20 million users per year

00:17:14,720 --> 00:17:23,839
and we calculated the amount of accesses

00:17:19,600 --> 00:17:27,600
the access is about 10 request

00:17:23,839 --> 00:17:30,799
in a second

00:17:27,600 --> 00:17:32,080
the response time is within 2 seconds in

00:17:30,799 --> 00:17:34,960
a request

00:17:32,080 --> 00:17:35,919
it is good time to handle the website

00:17:34,960 --> 00:17:39,679
without

00:17:35,919 --> 00:17:39,679
stress of the users

00:17:41,440 --> 00:17:44,799
in the scenario 2 we would like to

00:17:44,000 --> 00:17:47,679
evaluate

00:17:44,799 --> 00:17:49,280
the performance to integrate with other

00:17:47,679 --> 00:17:52,559
external systems

00:17:49,280 --> 00:17:52,559
using nodelet

00:17:53,840 --> 00:17:58,480
this is the system overview of the

00:17:56,720 --> 00:18:02,240
scenario 2

00:17:58,480 --> 00:18:07,200
in this system there is the web server

00:18:02,240 --> 00:18:11,200
to provide front-end ui or users

00:18:07,200 --> 00:18:14,240
and users input the search conditions

00:18:11,200 --> 00:18:18,000
like that and then

00:18:14,240 --> 00:18:20,880
the front end ui submit to the

00:18:18,000 --> 00:18:22,000
search condition to the node.red server

00:18:20,880 --> 00:18:25,520
via rest

00:18:22,000 --> 00:18:25,520
via web server

00:18:26,400 --> 00:18:34,559
and the node-led server calls the 25

00:18:30,160 --> 00:18:37,280
external website to get the travel plans

00:18:34,559 --> 00:18:38,000
and then the node red server narrowed

00:18:37,280 --> 00:18:42,000
down

00:18:38,000 --> 00:18:47,200
the 10 000 brands to

00:18:42,000 --> 00:18:47,200
75 digital currents for users

00:18:49,280 --> 00:18:54,480
this is the system configuration in our

00:18:52,640 --> 00:18:58,400
evaluation

00:18:54,480 --> 00:19:02,640
as i said we used container environment

00:18:58,400 --> 00:19:06,880
to examine the scaling of node red

00:19:02,640 --> 00:19:10,880
the bottom picture is the node red flow

00:19:06,880 --> 00:19:14,000
which we used it is branched flow

00:19:10,880 --> 00:19:17,440
so it looks redundant but

00:19:14,000 --> 00:19:17,840
it is easy to add the new additional

00:19:17,440 --> 00:19:21,840
rest

00:19:17,840 --> 00:19:21,840
api if needed

00:19:23,679 --> 00:19:28,240
this slide is about how to measure the

00:19:26,799 --> 00:19:31,360
performance

00:19:28,240 --> 00:19:37,200
in our performance evaluation we

00:19:31,360 --> 00:19:37,200
surveyed the cpu usage and response time

00:19:37,679 --> 00:19:42,080
to understand the minimum number of node

00:19:40,960 --> 00:19:45,679
red container

00:19:42,080 --> 00:19:48,960
to handle overall data we

00:19:45,679 --> 00:19:52,640
increased the number of containers step

00:19:48,960 --> 00:19:56,080
by step

00:19:52,640 --> 00:19:59,679
as you can see on the right graph

00:19:56,080 --> 00:20:03,039
average container cpu usage

00:19:59,679 --> 00:20:06,159
decreased gradually and we found

00:20:03,039 --> 00:20:08,799
that the minimum configuration needs 6

00:20:06,159 --> 00:20:12,159
containers for stable operations in

00:20:08,799 --> 00:20:12,159
terms of cpu

00:20:12,480 --> 00:20:19,280
when we use the 6 container environment

00:20:16,159 --> 00:20:20,320
the response time is about 600

00:20:19,280 --> 00:20:24,000
milliseconds

00:20:20,320 --> 00:20:27,440
on average it is good response time

00:20:24,000 --> 00:20:27,440
which we expected

00:20:29,440 --> 00:20:34,640
next we considered about the good

00:20:32,240 --> 00:20:38,240
response time

00:20:34,640 --> 00:20:41,760
as a result we found that the good

00:20:38,240 --> 00:20:44,640
response time is originated from the

00:20:41,760 --> 00:20:47,280
non-blocking i o of the node.js

00:20:44,640 --> 00:20:47,280
environment

00:20:47,440 --> 00:20:55,360
as you can see on the bottom diagram

00:20:51,120 --> 00:20:58,880
nodal deflo access the external ios

00:20:55,360 --> 00:21:02,080
at the same time so node.redraw

00:20:58,880 --> 00:21:02,880
does not use the a lot of time to

00:21:02,080 --> 00:21:08,159
aggregate

00:21:02,880 --> 00:21:08,159
the data from the external systems

00:21:08,400 --> 00:21:17,840
it is the benefit of node red to develop

00:21:12,000 --> 00:21:17,840
efficient flow without tuning

00:21:18,480 --> 00:21:25,440
in conclusion we found that node red

00:21:21,840 --> 00:21:28,799
has ability to adapt large iot system

00:21:25,440 --> 00:21:31,679
in terms of performance and

00:21:28,799 --> 00:21:33,200
especially node red is suitable for

00:21:31,679 --> 00:21:36,559
critical system

00:21:33,200 --> 00:21:40,080
in response time and

00:21:36,559 --> 00:21:43,520
if we want to need throughput of the

00:21:40,080 --> 00:21:46,960
nodulated system we need to consider

00:21:43,520 --> 00:21:51,120
about system design using container

00:21:46,960 --> 00:21:51,120
or vms to scale out

00:21:51,440 --> 00:21:55,600
next i will show the demonstration of

00:21:54,480 --> 00:21:58,880
node red

00:21:55,600 --> 00:22:02,080
in our evaluation i explained about

00:21:58,880 --> 00:22:04,799
the performance of node red but

00:22:02,080 --> 00:22:05,679
node red is good tool to create

00:22:04,799 --> 00:22:09,280
application

00:22:05,679 --> 00:22:13,760
without coding so in this demonstration

00:22:09,280 --> 00:22:17,120
i will explain about that

00:22:13,760 --> 00:22:20,559
the first demonstration is dedicated to

00:22:17,120 --> 00:22:23,360
the scenario one as i said node red

00:22:20,559 --> 00:22:25,360
can retrieve the sensor data via the

00:22:23,360 --> 00:22:28,400
mqtt protocol

00:22:25,360 --> 00:22:29,440
in this demo i will show the data

00:22:28,400 --> 00:22:32,559
collection

00:22:29,440 --> 00:22:36,000
by mqtt protocol

00:22:32,559 --> 00:22:37,840
and in node.project there is good

00:22:36,000 --> 00:22:40,960
dashboard component

00:22:37,840 --> 00:22:42,000
in this demonstration i will plot the

00:22:40,960 --> 00:22:45,200
sensor data

00:22:42,000 --> 00:22:45,200
to the dashboard

00:22:46,159 --> 00:22:53,760
this is node-red flow editor

00:22:49,520 --> 00:22:56,880
firstly i will select the mqtt

00:22:53,760 --> 00:23:00,799
node from the

00:22:56,880 --> 00:23:04,400
palette like this drag and drop

00:23:00,799 --> 00:23:07,760
the connector to the central workspace

00:23:04,400 --> 00:23:11,039
after that i configure the

00:23:07,760 --> 00:23:14,400
mqtt broker in this case

00:23:11,039 --> 00:23:14,400
it is local first

00:23:14,799 --> 00:23:23,840
and then i type the topic

00:23:18,000 --> 00:23:23,840
to specify the data

00:23:24,480 --> 00:23:30,880
next i select

00:23:27,600 --> 00:23:34,159
the chat node from

00:23:30,880 --> 00:23:38,559
dashboard group drag and drop

00:23:34,159 --> 00:23:41,600
the connector to the workspace

00:23:38,559 --> 00:23:43,840
it is default configuration so there is

00:23:41,600 --> 00:23:47,520
no change

00:23:43,840 --> 00:23:51,279
and then i wired the connectors

00:23:47,520 --> 00:23:54,559
like this after wiring connector

00:23:51,279 --> 00:23:58,640
i deploy the deploy button

00:23:54,559 --> 00:24:02,720
and then i open the

00:23:58,640 --> 00:24:06,640
dashboard ui as you can see

00:24:02,720 --> 00:24:09,760
there is time series data

00:24:06,640 --> 00:24:19,200
on chart component

00:24:09,760 --> 00:24:22,720
of dashboard

00:24:19,200 --> 00:24:26,000
in this demonstration i hope that

00:24:22,720 --> 00:24:30,000
you understand it is easy to get

00:24:26,000 --> 00:24:33,600
the sensor data via mqtt protocol

00:24:30,000 --> 00:24:38,640
and then a node red can easily

00:24:33,600 --> 00:24:38,640
output the sensor data to dashboard

00:24:40,000 --> 00:24:47,279
demonstration 2 is related to

00:24:43,200 --> 00:24:51,200
scenario 2 in this demonstration

00:24:47,279 --> 00:24:54,640
node red server calls translation apis

00:24:51,200 --> 00:24:57,679
on google cloud ibm cloud and

00:24:54,640 --> 00:25:00,880
microsoft azure cloud and

00:24:57,679 --> 00:25:05,200
after calling the desktop apis

00:25:00,880 --> 00:25:08,640
node.red server output translated text

00:25:05,200 --> 00:25:08,640
to the nodelet ui

00:25:09,679 --> 00:25:14,559
to reduce the demonstration time i

00:25:12,799 --> 00:25:17,919
prepared some component

00:25:14,559 --> 00:25:21,360
for the demonstration i will explain

00:25:17,919 --> 00:25:21,360
about each component

00:25:21,440 --> 00:25:28,720
firstly i pasted japanese text

00:25:25,520 --> 00:25:31,039
to the inject node to start node-red

00:25:28,720 --> 00:25:31,039
flow

00:25:34,799 --> 00:25:42,240
and orange object is post data

00:25:37,840 --> 00:25:45,600
to the google cloud

00:25:42,240 --> 00:25:45,600
it is json format

00:25:48,320 --> 00:25:57,840
and second object is post data

00:25:51,919 --> 00:25:57,840
for ibm cloud translator

00:26:01,840 --> 00:26:09,279
and the third object is post data

00:26:05,600 --> 00:26:09,279
for azure translator

00:26:09,520 --> 00:26:24,400
using the orange object japanese

00:26:13,919 --> 00:26:26,159
text is inserted to the post data as the

00:26:24,400 --> 00:26:30,320
next step

00:26:26,159 --> 00:26:33,600
i used the http request

00:26:30,320 --> 00:26:39,200
connector it is connected

00:26:33,600 --> 00:26:42,880
to retrieve the data from the rest apis

00:26:39,200 --> 00:26:46,159
i drag and drop it to the

00:26:42,880 --> 00:26:53,840
central workspace and then i

00:26:46,159 --> 00:26:53,840
wired the connectors

00:26:58,240 --> 00:27:05,440
after that i configured

00:27:01,440 --> 00:27:09,039
the end point setting firstly i

00:27:05,440 --> 00:27:12,400
opened the setting for

00:27:09,039 --> 00:27:17,200
google cloud firstly

00:27:12,400 --> 00:27:20,480
i selected http method as a post

00:27:17,200 --> 00:27:20,880
and then i pasted the endpoint of the

00:27:20,480 --> 00:27:23,919
rest

00:27:20,880 --> 00:27:28,799
api after that

00:27:23,919 --> 00:27:32,640
i copied api key

00:27:28,799 --> 00:27:36,799
and then i pasted

00:27:32,640 --> 00:27:36,799
the api key to the setting

00:27:36,880 --> 00:27:44,960
finally i changed the

00:27:40,080 --> 00:27:44,960
output format as json format

00:27:46,240 --> 00:27:55,120
and secondly i configure for

00:27:50,159 --> 00:27:58,559
ibm cloud http method is

00:27:55,120 --> 00:28:02,640
post i select it and

00:27:58,559 --> 00:28:06,000
i paste it the endpoint

00:28:02,640 --> 00:28:09,679
and finally i

00:28:06,000 --> 00:28:13,279
changed copied

00:28:09,679 --> 00:28:17,840
the api key and

00:28:13,279 --> 00:28:17,840
i pasted the api key

00:28:23,679 --> 00:28:27,760
next i changed the

00:28:27,919 --> 00:28:36,000
http request component for

00:28:31,679 --> 00:28:45,840
azure translator http method is

00:28:36,000 --> 00:28:45,840
post and url i paste it

00:28:52,799 --> 00:29:00,080
as your translator has

00:28:56,840 --> 00:29:03,360
a header

00:29:00,080 --> 00:29:06,799
header to set the api so

00:29:03,360 --> 00:29:10,240
i used the

00:29:06,799 --> 00:29:13,440
change connector to set the

00:29:10,240 --> 00:29:17,520
api to the header

00:29:13,440 --> 00:29:18,960
and then i clicked the deploy button to

00:29:17,520 --> 00:29:23,279
deploy the flow

00:29:18,960 --> 00:29:27,039
to the server side and then i start

00:29:23,279 --> 00:29:30,399
the node.red connector

00:29:27,039 --> 00:29:32,880
as you can see there is the

00:29:30,399 --> 00:29:35,600
english translation of the japanese

00:29:32,880 --> 00:29:35,600
translation

00:29:35,679 --> 00:29:43,760
this is our same result

00:29:40,960 --> 00:29:44,720
in this demonstration i hope that you

00:29:43,760 --> 00:29:47,240
understand

00:29:44,720 --> 00:29:50,720
nodulate can easily absorb the

00:29:47,240 --> 00:29:53,600
differentiation between the rest apis

00:29:50,720 --> 00:29:56,240
and easy to connect to the other

00:29:53,600 --> 00:29:56,240
services

00:29:56,799 --> 00:30:03,039
from this slide i will explain about

00:30:00,080 --> 00:30:06,080
decent contributions from stage to

00:30:03,039 --> 00:30:06,080
nodelet project

00:30:07,120 --> 00:30:13,039
the first is standard node right

00:30:10,240 --> 00:30:14,320
it is a desktop application version of

00:30:13,039 --> 00:30:17,520
node red

00:30:14,320 --> 00:30:20,840
and it includes node.js

00:30:17,520 --> 00:30:22,240
and node red connectors and chromium

00:30:20,840 --> 00:30:26,000
engine

00:30:22,240 --> 00:30:29,200
all of a component are included

00:30:26,000 --> 00:30:32,640
uh in the installer so

00:30:29,200 --> 00:30:36,880
a beginner user can install the

00:30:32,640 --> 00:30:40,799
node red without command line operation

00:30:36,880 --> 00:30:44,080
and it is easy to upgrade

00:30:40,799 --> 00:30:47,600
for offline environment we

00:30:44,080 --> 00:30:51,120
want to use the standalone node red

00:30:47,600 --> 00:30:54,240
for offline environment inside

00:30:51,120 --> 00:30:58,159
factory so we suggested and

00:30:54,240 --> 00:30:58,159
developed the project

00:30:59,279 --> 00:31:06,080
the second is the automated ui testing

00:31:03,039 --> 00:31:06,960
traditionally nodulate community had no

00:31:06,080 --> 00:31:11,919
method

00:31:06,960 --> 00:31:15,760
to test the browser ui to avoid degrade

00:31:11,919 --> 00:31:18,480
so we suggested the automatic ui testing

00:31:15,760 --> 00:31:20,960
for community and we developed the

00:31:18,480 --> 00:31:24,640
method

00:31:20,960 --> 00:31:26,159
this is the demo about the automated ui

00:31:24,640 --> 00:31:28,799
testing

00:31:26,159 --> 00:31:29,279
on browser stack environment automatic

00:31:28,799 --> 00:31:33,279
ui

00:31:29,279 --> 00:31:36,320
testing executed the ui test

00:31:33,279 --> 00:31:39,519
on materials of os and

00:31:36,320 --> 00:31:39,519
browser environments

00:31:40,240 --> 00:31:43,679
browser stack environment has many

00:31:42,880 --> 00:31:47,760
version of

00:31:43,679 --> 00:31:50,880
browsers using browser stack environment

00:31:47,760 --> 00:31:52,000
we can automatically create supported

00:31:50,880 --> 00:31:56,399
version list

00:31:52,000 --> 00:31:56,399
for each version of node red

00:31:59,120 --> 00:32:02,720
in this slide i will introduce node

00:32:01,840 --> 00:32:06,480
generator

00:32:02,720 --> 00:32:09,039
which is sub-project of node.project

00:32:06,480 --> 00:32:10,399
and the node generator is command line

00:32:09,039 --> 00:32:13,919
tool to generate

00:32:10,399 --> 00:32:15,039
custom node red connector from open api

00:32:13,919 --> 00:32:18,080
specification

00:32:15,039 --> 00:32:21,840
or other sources

00:32:18,080 --> 00:32:25,279
if open api document of partner apis

00:32:21,840 --> 00:32:26,000
or strategy original apis the node

00:32:25,279 --> 00:32:29,200
generator

00:32:26,000 --> 00:32:30,480
automatically creates their original

00:32:29,200 --> 00:32:34,480
nodelet connector

00:32:30,480 --> 00:32:37,760
from the open api document

00:32:34,480 --> 00:32:41,519
on the internet there is good example of

00:32:37,760 --> 00:32:45,039
node generator for example cisco

00:32:41,519 --> 00:32:46,480
uses node generator to create a custom

00:32:45,039 --> 00:32:49,840
connector to connect

00:32:46,480 --> 00:32:53,760
to cisco meraki dashboard

00:32:49,840 --> 00:32:57,519
and ibm website there is good example

00:32:53,760 --> 00:32:58,559
to connect to their original ai docker

00:32:57,519 --> 00:33:01,919
container

00:32:58,559 --> 00:33:01,919
using node generator

00:33:03,360 --> 00:33:07,600
this is the enhancement of node

00:33:05,919 --> 00:33:10,640
generator

00:33:07,600 --> 00:33:14,799
my colleague expanded the use case

00:33:10,640 --> 00:33:18,640
of the node generator in wc activities

00:33:14,799 --> 00:33:23,760
and he created

00:33:18,640 --> 00:33:26,799
the template for revolving description

00:33:23,760 --> 00:33:29,519
recently we started to suggest

00:33:26,799 --> 00:33:30,880
auto population server to generate a

00:33:29,519 --> 00:33:35,440
custom connector

00:33:30,880 --> 00:33:39,360
of edge devices around the server

00:33:35,440 --> 00:33:42,720
using this server node.red can easily

00:33:39,360 --> 00:33:46,559
create the custom connector from the

00:33:42,720 --> 00:33:46,559
devices around the node red

00:33:46,880 --> 00:33:50,640
for node-red dashboard we are always

00:33:49,840 --> 00:33:53,440
create

00:33:50,640 --> 00:33:55,279
custom ui connectors to visualize

00:33:53,440 --> 00:33:58,080
various data

00:33:55,279 --> 00:33:58,880
for example table ui connector to

00:33:58,080 --> 00:34:02,480
visualize

00:33:58,880 --> 00:34:06,159
table data and list connector

00:34:02,480 --> 00:34:10,079
and vega connector and recently

00:34:06,159 --> 00:34:13,359
we started to develop 3d ui connector

00:34:10,079 --> 00:34:16,800
to visualize 3d object

00:34:13,359 --> 00:34:19,440
on node red dashboard

00:34:16,800 --> 00:34:20,000
on the internet there is a good example

00:34:19,440 --> 00:34:23,359
using

00:34:20,000 --> 00:34:26,800
table ui connector recently

00:34:23,359 --> 00:34:29,839
the linux foundation guru and ibm

00:34:26,800 --> 00:34:30,560
announced new earthquake re running

00:34:29,839 --> 00:34:34,560
system

00:34:30,560 --> 00:34:38,399
as open source project in this project

00:34:34,560 --> 00:34:41,679
my table ui connector is used

00:34:38,399 --> 00:34:44,639
so we can see the table ui

00:34:41,679 --> 00:34:44,639
on the dashboard

00:34:46,879 --> 00:34:51,679
this slide explained about incoming

00:34:49,760 --> 00:34:54,639
message control

00:34:51,679 --> 00:34:55,760
based on our experience in performance

00:34:54,639 --> 00:34:59,520
tuning

00:34:55,760 --> 00:35:03,040
we found that the each connector

00:34:59,520 --> 00:35:05,760
has large q because of many access from

00:35:03,040 --> 00:35:08,240
outside

00:35:05,760 --> 00:35:10,400
to solve the situation we will

00:35:08,240 --> 00:35:14,240
contribute to the documentation

00:35:10,400 --> 00:35:14,240
how to use the data limit

00:35:15,119 --> 00:35:20,320
this year we contributed to the flow

00:35:18,320 --> 00:35:23,599
development guideline

00:35:20,320 --> 00:35:27,040
this guideline contains know-how about

00:35:23,599 --> 00:35:29,359
how to create the node-red flow based on

00:35:27,040 --> 00:35:33,200
our experience

00:35:29,359 --> 00:35:35,599
thanks to adding the document by ibm

00:35:33,200 --> 00:35:39,119
this document is available on the

00:35:35,599 --> 00:35:42,640
official node red website

00:35:39,119 --> 00:35:46,720
finally i introduce our activities

00:35:42,640 --> 00:35:46,720
to expand open source community

00:35:48,000 --> 00:35:54,079
we published articles about node-red

00:35:51,040 --> 00:35:57,359
on websites recently

00:35:54,079 --> 00:36:01,520
we wrote two articles about node-red

00:35:57,359 --> 00:36:05,040
to linux foundation blog the ax.com

00:36:01,520 --> 00:36:09,520
and i wrote the medium vlog

00:36:05,040 --> 00:36:09,520
about how to use the node generator

00:36:11,200 --> 00:36:14,720
in japan there is good to nodulate user

00:36:13,760 --> 00:36:17,920
community

00:36:14,720 --> 00:36:21,280
so with the community we always

00:36:17,920 --> 00:36:24,480
hold nodulated meetups in japan

00:36:21,280 --> 00:36:27,599
and as you know there is

00:36:24,480 --> 00:36:30,720
october event in october

00:36:27,599 --> 00:36:34,480
so to increase

00:36:30,720 --> 00:36:38,720
the number of node-red computers

00:36:34,480 --> 00:36:42,560
we hold october event for contribution

00:36:38,720 --> 00:36:45,680
on github and

00:36:42,560 --> 00:36:48,720
at the beginning of this year

00:36:45,680 --> 00:36:52,160
we hold moderate

00:36:48,720 --> 00:36:55,599
version 1.0 introduction for

00:36:52,160 --> 00:36:58,320
node red user community

00:36:55,599 --> 00:37:00,560
we also publish moderate books with

00:36:58,320 --> 00:37:04,160
community members

00:37:00,560 --> 00:37:07,200
currently we published three inter

00:37:04,160 --> 00:37:10,400
introductory books about node red

00:37:07,200 --> 00:37:10,880
and we wrote five articles from starch

00:37:10,400 --> 00:37:14,800
for

00:37:10,880 --> 00:37:18,480
mastery magazines and recently

00:37:14,800 --> 00:37:21,920
ibm employees have a plan to publish

00:37:18,480 --> 00:37:23,040
node network in english so we

00:37:21,920 --> 00:37:26,400
contributed

00:37:23,040 --> 00:37:29,119
to the nodulated book as one of tech

00:37:26,400 --> 00:37:29,119
reviewers

00:37:29,839 --> 00:37:36,720
the last slide about global conference

00:37:34,000 --> 00:37:37,520
we have organized annual moderate

00:37:36,720 --> 00:37:40,560
conference

00:37:37,520 --> 00:37:44,320
with community members and last

00:37:40,560 --> 00:37:47,680
year we hold nodulation tokyo

00:37:44,320 --> 00:37:51,280
at the statis conference hall and

00:37:47,680 --> 00:37:55,520
a lot of attendees and speakers joined

00:37:51,280 --> 00:37:59,040
the conference this year

00:37:55,520 --> 00:38:02,160
because of coffee 19 problem

00:37:59,040 --> 00:38:05,280
this conference is changed to

00:38:02,160 --> 00:38:08,320
online conference and but

00:38:05,280 --> 00:38:11,119
uh thanks to announcement

00:38:08,320 --> 00:38:12,079
from openjs foundation blog a lot of

00:38:11,119 --> 00:38:16,640
attendees

00:38:12,079 --> 00:38:19,680
joined the conference from worldwide

00:38:16,640 --> 00:38:20,640
if you are interested in the developer

00:38:19,680 --> 00:38:24,160
community

00:38:20,640 --> 00:38:26,800
or user community please join the

00:38:24,160 --> 00:38:26,800
community

00:38:28,560 --> 00:38:32,960
that's all let me close my session from

00:38:31,760 --> 00:38:36,480
now

00:38:32,960 --> 00:38:38,320
i'm glad if you started to use nodulate

00:38:36,480 --> 00:38:47,680
by my session

00:38:38,320 --> 00:38:49,760
thank you for listening have a nice day

00:38:47,680 --> 00:38:49,760

YouTube URL: https://www.youtube.com/watch?v=w-g_TF0mSGA


