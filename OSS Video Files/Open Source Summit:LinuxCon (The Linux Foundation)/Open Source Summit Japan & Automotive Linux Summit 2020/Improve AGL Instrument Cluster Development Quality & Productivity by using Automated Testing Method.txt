Title: Improve AGL Instrument Cluster Development Quality & Productivity by using Automated Testing Method
Publication date: 2020-12-03
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Improve AGL Instrument Cluster Development Quality and Productivity by using Automated Testing Method - Truong Cong Hieu & Nguyen Thanh Trung, FPT Software
Captions: 
	00:00:06,000 --> 00:00:09,519
hi

00:00:06,399 --> 00:00:10,559
everyone we are come from apt software

00:00:09,519 --> 00:00:14,240
corporation

00:00:10,559 --> 00:00:15,280
of vietnam and university of engineering

00:00:14,240 --> 00:00:18,640
and technology

00:00:15,280 --> 00:00:19,520
vietnam national university nice to meet

00:00:18,640 --> 00:00:22,000
all of you

00:00:19,520 --> 00:00:24,119
in the open source of miss japan and

00:00:22,000 --> 00:00:28,160
automotive linux submit

00:00:24,119 --> 00:00:32,000
2020 event as you know

00:00:28,160 --> 00:00:35,040
because of the coffee 19 pandemic

00:00:32,000 --> 00:00:38,640
therefore we conduct this event as

00:00:35,040 --> 00:00:40,399
a virtual meeting we are very excited

00:00:38,640 --> 00:00:44,719
about this kind of meeting

00:00:40,399 --> 00:00:47,039
because we feel saving and safety

00:00:44,719 --> 00:00:49,039
today we would like to present to you

00:00:47,039 --> 00:00:51,680
about our technical approaching

00:00:49,039 --> 00:00:52,399
for an cnc blood plus programming

00:00:51,680 --> 00:00:55,520
language

00:00:52,399 --> 00:00:55,920
automated unit test case generator and

00:00:55,520 --> 00:00:58,239
its

00:00:55,920 --> 00:00:59,199
application in embedded automotive

00:00:58,239 --> 00:01:04,320
projects

00:00:59,199 --> 00:01:04,320
in general and agl in particular

00:01:08,159 --> 00:01:12,400
the type of content for this

00:01:10,560 --> 00:01:15,360
presentation is include

00:01:12,400 --> 00:01:18,080
6 parts at the first part we would like

00:01:15,360 --> 00:01:18,640
to describe about our motivation of unit

00:01:18,080 --> 00:01:20,720
testing

00:01:18,640 --> 00:01:22,479
in embedded and automotive software

00:01:20,720 --> 00:01:24,799
development

00:01:22,479 --> 00:01:26,080
at the second part we introduced the

00:01:24,799 --> 00:01:28,640
technical methodology

00:01:26,080 --> 00:01:30,240
of automated unit test generation and

00:01:28,640 --> 00:01:33,439
some our research

00:01:30,240 --> 00:01:34,960
about this technique and from our

00:01:33,439 --> 00:01:37,200
research result

00:01:34,960 --> 00:01:38,720
we have developed by ourself an

00:01:37,200 --> 00:01:41,520
effective platform for

00:01:38,720 --> 00:01:44,159
cnc blood plus programming language

00:01:41,520 --> 00:01:47,759
automated unit test generation

00:01:44,159 --> 00:01:49,439
named aka iut the feature of this

00:01:47,759 --> 00:01:52,479
platform will be introduced

00:01:49,439 --> 00:01:53,439
in the third part recently we have

00:01:52,479 --> 00:01:56,399
applied

00:01:53,439 --> 00:01:58,479
the aka iut in some igl software

00:01:56,399 --> 00:02:00,320
components and seen many potential

00:01:58,479 --> 00:02:02,719
results

00:02:00,320 --> 00:02:05,280
the third part we will share with you

00:02:02,719 --> 00:02:07,200
about our efforts for this task and this

00:02:05,280 --> 00:02:10,080
result

00:02:07,200 --> 00:02:11,120
the fifth part is our conclusion and the

00:02:10,080 --> 00:02:15,840
future plan of

00:02:11,120 --> 00:02:15,840
ffd for akai iud tune

00:02:17,120 --> 00:02:24,560
what is unit testing we almost know

00:02:21,120 --> 00:02:25,840
that unit testing is a type of software

00:02:24,560 --> 00:02:28,720
testing

00:02:25,840 --> 00:02:30,160
where individual image or components

00:02:28,720 --> 00:02:33,519
like functions

00:02:30,160 --> 00:02:36,160
are macro are tested

00:02:33,519 --> 00:02:36,959
and the unit testing process is about

00:02:36,160 --> 00:02:39,519
validating

00:02:36,959 --> 00:02:40,560
each that unit or component of the

00:02:39,519 --> 00:02:45,599
software

00:02:40,560 --> 00:02:48,879
source code performs as desired or not

00:02:45,599 --> 00:02:51,840
unit testing have many benefit

00:02:48,879 --> 00:02:54,959
some most important benefits of duty are

00:02:51,840 --> 00:02:59,200
it possible to identify the problems

00:02:54,959 --> 00:03:02,480
earlier it helps reduce work ratio

00:02:59,200 --> 00:03:03,680
and development effort and in most

00:03:02,480 --> 00:03:06,959
industrial sector

00:03:03,680 --> 00:03:09,280
unit test is recognized as a

00:03:06,959 --> 00:03:10,959
up-to-date development document for

00:03:09,280 --> 00:03:15,440
example in automotive

00:03:10,959 --> 00:03:18,400
domain totally the earlier we process

00:03:15,440 --> 00:03:20,640
the ut activity the lower cost we have

00:03:18,400 --> 00:03:24,400
achieved

00:03:20,640 --> 00:03:28,080
although there are many benefits of ut

00:03:24,400 --> 00:03:31,360
but recently it has some challenges

00:03:28,080 --> 00:03:33,760
actually to design a good unit test case

00:03:31,360 --> 00:03:34,720
the tester or developer has to

00:03:33,760 --> 00:03:38,080
understand the

00:03:34,720 --> 00:03:41,280
entire of the source code clearly but

00:03:38,080 --> 00:03:46,159
to understanding the entire source code

00:03:41,280 --> 00:03:49,360
is make earth very darious and terrible

00:03:46,159 --> 00:03:53,280
almost of the proper initial condition

00:03:49,360 --> 00:03:56,000
to design a test case is like in actual

00:03:53,280 --> 00:03:56,720
then almost the manual test case will

00:03:56,000 --> 00:04:01,439
not be

00:03:56,720 --> 00:04:04,159
exercised the code in reality context

00:04:01,439 --> 00:04:08,000
which reduce the value and the the

00:04:04,159 --> 00:04:10,640
accuracy of unit test result

00:04:08,000 --> 00:04:14,159
the configuration management process of

00:04:10,640 --> 00:04:16,959
a ut project is very painful also

00:04:14,159 --> 00:04:17,680
to find the dependencies of the source

00:04:16,959 --> 00:04:21,759
tree

00:04:17,680 --> 00:04:24,720
as known as the system and the test sct

00:04:21,759 --> 00:04:27,280
on the other hand manual test creation

00:04:24,720 --> 00:04:30,400
is low productivity and need to improve

00:04:27,280 --> 00:04:33,840
an accessory the last one

00:04:30,400 --> 00:04:37,199
is in the minor aspect almost the

00:04:33,840 --> 00:04:40,080
industrial sector has their own ensuring

00:04:37,199 --> 00:04:40,639
development process need to integrate

00:04:40,080 --> 00:04:44,080
with

00:04:40,639 --> 00:04:46,800
ut solution but currently

00:04:44,080 --> 00:04:48,960
we have only high cost standalone

00:04:46,800 --> 00:04:53,919
commercial ut solutions

00:04:48,960 --> 00:04:57,600
like vector gas or cantata for instance

00:04:53,919 --> 00:04:58,479
therefore developing an automated test

00:04:57,600 --> 00:05:02,000
case

00:04:58,479 --> 00:05:04,880
generation is a good approaching

00:05:02,000 --> 00:05:06,320
to resume these challenges for

00:05:04,880 --> 00:05:09,360
industrial sector

00:05:06,320 --> 00:05:12,800
at current time

00:05:09,360 --> 00:05:15,199
for more detail as we have known

00:05:12,800 --> 00:05:16,479
there is no scope for errors and works

00:05:15,199 --> 00:05:20,160
when we are developing

00:05:16,479 --> 00:05:21,759
automotive embedded software of critical

00:05:20,160 --> 00:05:25,280
vertical ecu's

00:05:21,759 --> 00:05:28,800
in general and in instruction cluster

00:05:25,280 --> 00:05:29,680
in particular and so the software

00:05:28,800 --> 00:05:33,360
testing is

00:05:29,680 --> 00:05:36,840
our in need because the automotive

00:05:33,360 --> 00:05:39,919
intuition cluster has to respond several

00:05:36,840 --> 00:05:41,759
functionalities this embedded software

00:05:39,919 --> 00:05:44,880
is quite complex

00:05:41,759 --> 00:05:46,639
for example meter advanced driver

00:05:44,880 --> 00:05:50,880
assistance system

00:05:46,639 --> 00:05:53,600
ibi interact functional safety

00:05:50,880 --> 00:05:54,560
so the software testing activity take

00:05:53,600 --> 00:05:58,000
many effort

00:05:54,560 --> 00:06:01,600
of development team and it seems that

00:05:58,000 --> 00:06:05,039
currently almost of igl midway layer

00:06:01,600 --> 00:06:08,960
ut is developed manually and the ut

00:06:05,039 --> 00:06:12,160
activity is in floating status

00:06:08,960 --> 00:06:13,440
agl has two development mainline at this

00:06:12,160 --> 00:06:16,960
time

00:06:13,440 --> 00:06:18,639
ibi and cluster the most important task

00:06:16,960 --> 00:06:21,600
of igr contributors

00:06:18,639 --> 00:06:23,440
in cluster development is qm quality

00:06:21,600 --> 00:06:26,880
management activities

00:06:23,440 --> 00:06:29,280
to be able to release a mass production

00:06:26,880 --> 00:06:32,080
totally we need to improve the

00:06:29,280 --> 00:06:34,160
productivity of software testing process

00:06:32,080 --> 00:06:35,440
to ensure the quality of software

00:06:34,160 --> 00:06:37,440
deliverables

00:06:35,440 --> 00:06:40,000
to catch up an effective embedded

00:06:37,440 --> 00:06:41,840
automotive software development

00:06:40,000 --> 00:06:44,800
engineering process with higher

00:06:41,840 --> 00:06:44,800
productivity

00:06:46,080 --> 00:06:52,160
and now is the theoretical basics

00:06:49,840 --> 00:06:53,360
about cnc blood plus programming

00:06:52,160 --> 00:06:56,560
language automated

00:06:53,360 --> 00:06:59,599
unit test in aka iut

00:06:56,560 --> 00:07:02,800
our main approach is developing a

00:06:59,599 --> 00:07:06,639
platform that can generate test data

00:07:02,800 --> 00:07:09,680
automatically in wipeout testing

00:07:06,639 --> 00:07:12,080
the white box testing it allows

00:07:09,680 --> 00:07:13,120
to detect potential bugs in the source

00:07:12,080 --> 00:07:16,160
code

00:07:13,120 --> 00:07:16,720
some under mandatory input arguments to

00:07:16,160 --> 00:07:20,000
config

00:07:16,720 --> 00:07:21,120
the ut project is c and simpler plus

00:07:20,000 --> 00:07:24,479
projection tree

00:07:21,120 --> 00:07:25,360
and some coverage criteria for example

00:07:24,479 --> 00:07:28,400
statement

00:07:25,360 --> 00:07:31,759
branch mcdc

00:07:28,400 --> 00:07:34,960
with this input argument akai ut

00:07:31,759 --> 00:07:38,000
will create a set of test design

00:07:34,960 --> 00:07:41,919
that's that's case that's the report

00:07:38,000 --> 00:07:44,879
name test later as the output

00:07:41,919 --> 00:07:46,560
the most the most inspirational papers

00:07:44,879 --> 00:07:50,000
using to develop

00:07:46,560 --> 00:07:53,840
iud tune list as the following

00:07:50,000 --> 00:07:56,879
especially we have our main publication

00:07:53,840 --> 00:07:57,199
for the automated test case generation

00:07:56,879 --> 00:08:00,479
for

00:07:57,199 --> 00:08:03,199
cnc plus plus project as is following

00:08:00,479 --> 00:08:03,199
information

00:08:07,520 --> 00:08:11,199
these six steps need to be able to

00:08:10,319 --> 00:08:14,160
automate the

00:08:11,199 --> 00:08:16,160
test case generation the first is remove

00:08:14,160 --> 00:08:19,120
some pre-processor

00:08:16,160 --> 00:08:21,599
directive like if dab and platform

00:08:19,120 --> 00:08:24,639
dependency source code

00:08:21,599 --> 00:08:25,680
each pre-processor directly based on the

00:08:24,639 --> 00:08:29,680
configuration

00:08:25,680 --> 00:08:31,759
can recognize as a different suv

00:08:29,680 --> 00:08:33,839
the second step is to construct the

00:08:31,759 --> 00:08:36,399
source tree

00:08:33,839 --> 00:08:37,760
this step will model the constraint of

00:08:36,399 --> 00:08:41,120
huut

00:08:37,760 --> 00:08:41,760
into a three data structure we should

00:08:41,120 --> 00:08:44,159
choose

00:08:41,760 --> 00:08:45,440
data structure because it has parent and

00:08:44,159 --> 00:08:48,640
child relationship

00:08:45,440 --> 00:08:51,760
and can be passing easily by

00:08:48,640 --> 00:08:55,440
experiment we choose not entry

00:08:51,760 --> 00:08:58,640
is a folder a source code an inspire

00:08:55,440 --> 00:09:03,040
or glass and the tree leaf is

00:08:58,640 --> 00:09:05,440
mental attribute or variable

00:09:03,040 --> 00:09:06,640
the third step is instrument on

00:09:05,440 --> 00:09:10,240
functions

00:09:06,640 --> 00:09:12,800
we can catch the instruction of uut

00:09:10,240 --> 00:09:13,680
and we insert more information into the

00:09:12,800 --> 00:09:17,200
instruction

00:09:13,680 --> 00:09:18,000
and market edge instrument after this

00:09:17,200 --> 00:09:22,000
step

00:09:18,000 --> 00:09:24,320
we have an sud actually

00:09:22,000 --> 00:09:25,200
the first step is generating function

00:09:24,320 --> 00:09:28,399
control for

00:09:25,200 --> 00:09:32,320
graph cfg each function has

00:09:28,399 --> 00:09:32,320
its own described graph

00:09:32,399 --> 00:09:37,440
when we pass this graph we will have is

00:09:35,279 --> 00:09:39,519
cfg

00:09:37,440 --> 00:09:42,560
the function graph will be different

00:09:39,519 --> 00:09:45,360
with different coverage

00:09:42,560 --> 00:09:46,880
the fifth step is generating test data

00:09:45,360 --> 00:09:49,440
automatically

00:09:46,880 --> 00:09:51,680
this is the main part of our tune and

00:09:49,440 --> 00:09:53,680
the detail will be described in next

00:09:51,680 --> 00:09:57,200
slide

00:09:53,680 --> 00:09:58,880
after have the test data aca and ut can

00:09:57,200 --> 00:10:02,000
execute the test case

00:09:58,880 --> 00:10:04,160
based on this test data and the

00:10:02,000 --> 00:10:07,760
interface with some test framework

00:10:04,160 --> 00:10:09,360
like gtx or taxi to create the test

00:10:07,760 --> 00:10:12,399
driver component

00:10:09,360 --> 00:10:14,959
and generate the coverage report

00:10:12,399 --> 00:10:16,839
it is the final step when using current

00:10:14,959 --> 00:10:19,839
version of icar

00:10:16,839 --> 00:10:19,839
aud2

00:10:20,880 --> 00:10:27,279
the fifth step generate test data

00:10:23,920 --> 00:10:30,399
has several seven

00:10:27,279 --> 00:10:31,440
sub steps the first sub step is

00:10:30,399 --> 00:10:35,120
generating

00:10:31,440 --> 00:10:36,240
random initial test data based on the

00:10:35,120 --> 00:10:40,000
specification

00:10:36,240 --> 00:10:40,560
of unit of component after this step we

00:10:40,000 --> 00:10:44,320
have the

00:10:40,560 --> 00:10:47,360
initial test letter the second sub step

00:10:44,320 --> 00:10:50,079
is executing this initial test data

00:10:47,360 --> 00:10:52,399
by create the test driver interact with

00:10:50,079 --> 00:10:54,880
the test framework

00:10:52,399 --> 00:10:55,920
the third soft step is computing the

00:10:54,880 --> 00:10:59,279
current coverage

00:10:55,920 --> 00:11:01,760
based on the current cfg

00:10:59,279 --> 00:11:04,160
we have the status of coverage after

00:11:01,760 --> 00:11:07,279
this step

00:11:04,160 --> 00:11:08,079
the fourth step is create the path

00:11:07,279 --> 00:11:10,720
constraint

00:11:08,079 --> 00:11:12,800
that relative with the current test

00:11:10,720 --> 00:11:15,680
later

00:11:12,800 --> 00:11:16,560
next step we will negate the path

00:11:15,680 --> 00:11:18,959
constraint

00:11:16,560 --> 00:11:20,720
based on the current test status with

00:11:18,959 --> 00:11:24,160
the objective to generate

00:11:20,720 --> 00:11:27,680
new test data that responds

00:11:24,160 --> 00:11:31,040
to increase the coverage

00:11:27,680 --> 00:11:34,800
is fifth sub step in

00:11:31,040 --> 00:11:37,760
this substep we use digital algorithm

00:11:34,800 --> 00:11:39,600
to evaluate the negative point by

00:11:37,760 --> 00:11:42,640
finding the sorted battery

00:11:39,600 --> 00:11:45,839
in the cfg

00:11:42,640 --> 00:11:48,320
in the sixth step we will show the new

00:11:45,839 --> 00:11:49,760
path constraints to finding the new test

00:11:48,320 --> 00:11:52,240
data

00:11:49,760 --> 00:11:53,440
and at last we will execute the new test

00:11:52,240 --> 00:11:56,720
data

00:11:53,440 --> 00:12:00,240
this sequence will be executed until

00:11:56,720 --> 00:12:02,720
we meet the input requirement for the

00:12:00,240 --> 00:12:06,800
coverage

00:12:02,720 --> 00:12:09,839
the visualize information of all this

00:12:06,800 --> 00:12:12,079
of all staff will be described in next

00:12:09,839 --> 00:12:16,079
slide

00:12:12,079 --> 00:12:19,519
for visual all of the step

00:12:16,079 --> 00:12:25,279
we have this diagram like an example

00:12:19,519 --> 00:12:29,279
we choose the source code of tree type

00:12:25,279 --> 00:12:31,120
function as the unit under test

00:12:29,279 --> 00:12:32,399
from the source code we create the

00:12:31,120 --> 00:12:35,360
structure tree

00:12:32,399 --> 00:12:38,000
from the structure tree we will have the

00:12:35,360 --> 00:12:41,040
in treatment instruction

00:12:38,000 --> 00:12:42,480
in the first step we have the control

00:12:41,040 --> 00:12:46,240
follow grab

00:12:42,480 --> 00:12:47,440
three retire function on most of the

00:12:46,240 --> 00:12:52,160
source code pass

00:12:47,440 --> 00:12:55,440
we use cdd cnc plus development tooling

00:12:52,160 --> 00:12:58,480
in the fifth step we have the

00:12:55,440 --> 00:13:00,880
td1 as the first test data and the

00:12:58,480 --> 00:13:01,360
second test data is generated based on

00:13:00,880 --> 00:13:05,519
the

00:13:01,360 --> 00:13:08,160
test data the first test data and the

00:13:05,519 --> 00:13:10,720
third test data is generated by using

00:13:08,160 --> 00:13:13,360
the first and the second test data

00:13:10,720 --> 00:13:14,079
in actual we can use random method to

00:13:13,360 --> 00:13:17,279
pick up

00:13:14,079 --> 00:13:20,079
test data in parallel

00:13:17,279 --> 00:13:21,040
in practical in some cases choosing

00:13:20,079 --> 00:13:24,079
random method

00:13:21,040 --> 00:13:26,639
have more productivity because

00:13:24,079 --> 00:13:29,920
we can have the target coverage result

00:13:26,639 --> 00:13:32,560
by random test case

00:13:29,920 --> 00:13:33,680
in the sixth step is execute the test

00:13:32,560 --> 00:13:36,240
data

00:13:33,680 --> 00:13:38,959
based on the test framework like z-test

00:13:36,240 --> 00:13:38,959
or check-c

00:13:41,760 --> 00:13:50,800
these are aka iut's main features

00:13:47,120 --> 00:13:53,360
the aka iutune supports cnc plot

00:13:50,800 --> 00:13:54,720
plus projects with the following main

00:13:53,360 --> 00:13:58,399
features

00:13:54,720 --> 00:14:03,120
the programming language version is c

00:13:58,399 --> 00:14:06,639
99 and c plus plus 11 and c plus plus 14

00:14:03,120 --> 00:14:10,000
version we support multiple

00:14:06,639 --> 00:14:13,440
compiler support gcc

00:14:10,000 --> 00:14:14,959
and the plus plus and we can integrate

00:14:13,440 --> 00:14:19,519
it with

00:14:14,959 --> 00:14:22,639
any compiler currently

00:14:19,519 --> 00:14:26,639
iut platform can execute in

00:14:22,639 --> 00:14:29,839
linux and windows environment

00:14:26,639 --> 00:14:33,040
akka iut support

00:14:29,839 --> 00:14:36,079
various standard data types like

00:14:33,040 --> 00:14:39,519
primative types integral boolean

00:14:36,079 --> 00:14:43,839
float etc the right time like

00:14:39,519 --> 00:14:47,760
glass structure in them union and string

00:14:43,839 --> 00:14:49,199
plus plus stl standard template library

00:14:47,760 --> 00:14:52,399
is supported by aka

00:14:49,199 --> 00:14:55,760
aud tune also

00:14:52,399 --> 00:14:56,240
aka iot also support primitive execution

00:14:55,760 --> 00:14:59,519
block

00:14:56,240 --> 00:15:03,040
like inline overload override

00:14:59,519 --> 00:15:04,959
abstract class private public protected

00:15:03,040 --> 00:15:07,199
function

00:15:04,959 --> 00:15:08,480
and some function context like normal

00:15:07,199 --> 00:15:11,600
class namespace

00:15:08,480 --> 00:15:15,360
and abstract glass

00:15:11,600 --> 00:15:18,399
aka iot support multi-dimensional

00:15:15,360 --> 00:15:22,000
array and multi-level portal

00:15:18,399 --> 00:15:26,240
this is very easy to set up dimensional

00:15:22,000 --> 00:15:29,279
size by using ui of aka iut

00:15:26,240 --> 00:15:32,160
based on the configuration parameters

00:15:29,279 --> 00:15:33,600
aka ut will generate the suitable test

00:15:32,160 --> 00:15:36,320
data automatically

00:15:33,600 --> 00:15:37,360
for multi-dimensional array or

00:15:36,320 --> 00:15:41,440
multi-level

00:15:37,360 --> 00:15:44,959
portal support especially

00:15:41,440 --> 00:15:46,320
with support for a pointer the void

00:15:44,959 --> 00:15:48,959
portal is used

00:15:46,320 --> 00:15:50,560
in embedded automotive so school as a

00:15:48,959 --> 00:15:53,680
best practice pattern

00:15:50,560 --> 00:15:55,759
for flexible design and therefore it has

00:15:53,680 --> 00:15:57,680
to generate the test case for void

00:15:55,759 --> 00:16:00,720
pointer parameter

00:15:57,680 --> 00:16:04,240
but in akka iud we can config

00:16:00,720 --> 00:16:07,440
a void pointer as a primitive structure

00:16:04,240 --> 00:16:10,399
or use code type to respond with the

00:16:07,440 --> 00:16:10,399
real context

00:16:10,480 --> 00:16:14,560
the same with the void pointer the

00:16:13,199 --> 00:16:17,519
function pointer is

00:16:14,560 --> 00:16:18,560
also used widely in embedded automotive

00:16:17,519 --> 00:16:21,040
source code

00:16:18,560 --> 00:16:22,000
to respond with the function pointer we

00:16:21,040 --> 00:16:25,279
implement

00:16:22,000 --> 00:16:28,000
a smart method in account iot to pass

00:16:25,279 --> 00:16:28,800
the project to stream to suggest the

00:16:28,000 --> 00:16:32,639
function list

00:16:28,800 --> 00:16:36,959
that can be matched as the prototype of

00:16:32,639 --> 00:16:40,800
system under test function pointer

00:16:36,959 --> 00:16:44,160
in c plus plus and c

00:16:40,800 --> 00:16:46,320
99 the macro is widely because of its

00:16:44,160 --> 00:16:50,160
flexible uses

00:16:46,320 --> 00:16:53,120
aka iut also support the macro time

00:16:50,160 --> 00:16:54,639
as in the screenshot we see that aka iot

00:16:53,120 --> 00:16:56,720
can recognize a macro

00:16:54,639 --> 00:16:59,199
and such as user to conflict for this

00:16:56,720 --> 00:16:59,199
macro

00:16:59,600 --> 00:17:03,360
after configuration aka iut can generate

00:17:02,639 --> 00:17:06,400
test data

00:17:03,360 --> 00:17:07,360
for the macro and after execute the test

00:17:06,400 --> 00:17:10,880
data

00:17:07,360 --> 00:17:15,760
iot will report the result

00:17:10,880 --> 00:17:19,360
to us about in the test data

00:17:15,760 --> 00:17:22,880
of the power phone feature

00:17:19,360 --> 00:17:25,760
of c plus plus is template

00:17:22,880 --> 00:17:26,480
and the most impressive feature of arca

00:17:25,760 --> 00:17:30,160
iut

00:17:26,480 --> 00:17:32,559
is support template type template is

00:17:30,160 --> 00:17:34,480
generic type and based on the

00:17:32,559 --> 00:17:38,080
theoretical viewpoint

00:17:34,480 --> 00:17:41,520
it's hard to handle automated

00:17:38,080 --> 00:17:43,600
task generation but aka iut can

00:17:41,520 --> 00:17:46,000
pass the template and suggest to the

00:17:43,600 --> 00:17:48,400
user to choose the same kind of data for

00:17:46,000 --> 00:17:50,559
some template and generate the test case

00:17:48,400 --> 00:17:52,880
as primitives

00:17:50,559 --> 00:17:55,919
we also can define the custom source

00:17:52,880 --> 00:17:55,919
code for the template

00:17:57,600 --> 00:18:05,039
some other feature of

00:18:01,840 --> 00:18:09,039
account ut is described

00:18:05,039 --> 00:18:09,039
for the environment configuration

00:18:10,000 --> 00:18:13,440
for more detail we screen source summary

00:18:12,320 --> 00:18:16,559
window of

00:18:13,440 --> 00:18:17,600
iut we can create the multiple testing

00:18:16,559 --> 00:18:21,039
environment for

00:18:17,600 --> 00:18:24,160
cnc plus plus project

00:18:21,039 --> 00:18:26,400
we can stop a function this means that

00:18:24,160 --> 00:18:28,080
we can choose any return value for the

00:18:26,400 --> 00:18:31,600
function of sut

00:18:28,080 --> 00:18:35,039
using to testing other function

00:18:31,600 --> 00:18:37,360
we can define some custom user code

00:18:35,039 --> 00:18:39,039
in case we cannot generate the test data

00:18:37,360 --> 00:18:43,440
automatically we can use

00:18:39,039 --> 00:18:45,760
custom user code as a powerphone feature

00:18:43,440 --> 00:18:46,960
besides the generate test case

00:18:45,760 --> 00:18:50,080
automatically

00:18:46,960 --> 00:18:51,200
aka iet permit user creates their test

00:18:50,080 --> 00:18:54,840
game manually

00:18:51,200 --> 00:18:56,320
to respond for some spec specified use

00:18:54,840 --> 00:18:59,600
case

00:18:56,320 --> 00:18:59,600
we deliver the source

00:18:59,679 --> 00:19:04,080
we deliver the source code based by days

00:19:02,480 --> 00:19:06,320
therefore akai ut

00:19:04,080 --> 00:19:09,840
provides a smart mechanism to process

00:19:06,320 --> 00:19:12,960
the equipment to testing activity

00:19:09,840 --> 00:19:13,840
iut will report to you the duplicate the

00:19:12,960 --> 00:19:16,640
change

00:19:13,840 --> 00:19:17,600
of the source code need to regenerate

00:19:16,640 --> 00:19:21,520
the test case

00:19:17,600 --> 00:19:23,600
or not in the next test activity

00:19:21,520 --> 00:19:26,320
you can debug the test case using

00:19:23,600 --> 00:19:29,039
current account iot environment

00:19:26,320 --> 00:19:31,120
and last but not least aka igt will

00:19:29,039 --> 00:19:35,520
generate the test report management

00:19:31,120 --> 00:19:35,520
for management and development activity

00:19:36,240 --> 00:19:42,960
akka iut environment setup

00:19:39,360 --> 00:19:44,480
we have eight main step the first is

00:19:42,960 --> 00:19:48,799
choose a compiler

00:19:44,480 --> 00:19:51,039
the second is naming the environment

00:19:48,799 --> 00:19:52,799
the third is testing choosing the

00:19:51,039 --> 00:19:56,880
testing method

00:19:52,799 --> 00:20:00,400
the four is some use configuration

00:19:56,880 --> 00:20:02,640
and the fifth is locate the source file

00:20:00,400 --> 00:20:03,600
and the sixth is to choose euit and

00:20:02,640 --> 00:20:06,880
start function

00:20:03,600 --> 00:20:10,240
as in need and the seven

00:20:06,880 --> 00:20:10,880
is we create the user code custom user

00:20:10,240 --> 00:20:14,240
good

00:20:10,880 --> 00:20:17,280
in for some demand this is an optional

00:20:14,240 --> 00:20:21,120
step and the last year we will see

00:20:17,280 --> 00:20:23,840
the summarize of all configuration for

00:20:21,120 --> 00:20:23,840
environment

00:20:24,559 --> 00:20:31,760
after the shd exchange

00:20:28,080 --> 00:20:35,200
on demand we should using incremental

00:20:31,760 --> 00:20:38,080
testing aka iud will pass the source 3

00:20:35,200 --> 00:20:38,320
and know that the effect of modification

00:20:38,080 --> 00:20:41,280
in

00:20:38,320 --> 00:20:43,440
sut at the current time for both color

00:20:41,280 --> 00:20:46,240
and quality function

00:20:43,440 --> 00:20:47,520
aka iut will report to you the affected

00:20:46,240 --> 00:20:50,880
test claim

00:20:47,520 --> 00:20:53,600
the unusable test guide and the return

00:20:50,880 --> 00:20:53,600
test crisis

00:20:55,120 --> 00:20:58,640
one of the powerful features provided by

00:20:57,679 --> 00:21:01,919
aka ut

00:20:58,640 --> 00:21:03,200
is mixing both manual and automated

00:21:01,919 --> 00:21:08,320
generous test case

00:21:03,200 --> 00:21:11,760
for each eut by using this

00:21:08,320 --> 00:21:15,919
kind of feature

00:21:11,760 --> 00:21:19,760
which you can increase your productivity

00:21:15,919 --> 00:21:19,760
in unit test guide generation

00:21:20,320 --> 00:21:24,400
in case we have some reduction in test

00:21:23,360 --> 00:21:27,280
data

00:21:24,400 --> 00:21:29,120
aka iut can evaluate the effect of each

00:21:27,280 --> 00:21:32,320
test guy and suggest you

00:21:29,120 --> 00:21:35,600
the test guy can be removed but keep

00:21:32,320 --> 00:21:36,159
the expected coverage for example we can

00:21:35,600 --> 00:21:38,880
remove

00:21:36,159 --> 00:21:40,320
the display if there is other test cases

00:21:38,880 --> 00:21:43,840
in the same

00:21:40,320 --> 00:21:47,520
path aka iut

00:21:43,840 --> 00:21:50,159
provides a utility to dominate the

00:21:47,520 --> 00:21:53,039
source code for the function

00:21:50,159 --> 00:21:53,039
of the macro

00:21:53,200 --> 00:22:00,159
the utility will have you achieve

00:21:56,480 --> 00:22:03,520
the expected coverage in some complex

00:22:00,159 --> 00:22:03,520
business logistics code

00:22:06,159 --> 00:22:13,120
we have some

00:22:10,840 --> 00:22:16,240
because custom is

00:22:13,120 --> 00:22:16,799
good there are two types of custom user

00:22:16,240 --> 00:22:20,080
good

00:22:16,799 --> 00:22:22,080
the environment is good we

00:22:20,080 --> 00:22:24,080
will develop the source code that need

00:22:22,080 --> 00:22:27,120
to create the testing environment

00:22:24,080 --> 00:22:31,520
for example in case we have missing

00:22:27,120 --> 00:22:34,559
some library or function in the suv

00:22:31,520 --> 00:22:36,720
the parameters was called using to

00:22:34,559 --> 00:22:39,760
define the value for the

00:22:36,720 --> 00:22:42,880
for the input argument

00:22:39,760 --> 00:22:43,280
the asset source code using to compare

00:22:42,880 --> 00:22:46,000
the

00:22:43,280 --> 00:22:49,840
expected value and actual value by the

00:22:46,000 --> 00:22:49,840
runtime execution function

00:22:51,760 --> 00:22:58,480
and we can debugging the test driver as

00:22:55,120 --> 00:23:03,760
similar in other ide with

00:22:58,480 --> 00:23:03,760
some feature like blog point breakboy

00:23:05,440 --> 00:23:12,159
and now we can see a screen record

00:23:08,640 --> 00:23:12,880
of using aka iot tune aka iutune in

00:23:12,159 --> 00:23:23,840
action

00:23:12,880 --> 00:23:23,840
by some example

00:23:35,120 --> 00:23:41,039
we can create a new testing environment

00:23:47,840 --> 00:23:55,520
the the create testing environment

00:23:52,320 --> 00:23:59,760
have 7 steps

00:23:55,520 --> 00:23:59,760
and the first step is choose compiler

00:24:00,400 --> 00:24:05,679
currently aka iud support some compiler

00:24:04,159 --> 00:24:11,120
like

00:24:05,679 --> 00:24:11,120
gcc this is this g plus plus

00:24:15,919 --> 00:24:24,799
each compiler have their own instruction

00:24:20,000 --> 00:24:27,520
but we can reconfiguration

00:24:24,799 --> 00:24:28,720
in this project we will update the

00:24:27,520 --> 00:24:33,840
compile option

00:24:28,720 --> 00:24:33,840
and the link option

00:24:40,320 --> 00:24:48,559
because the igl application framework

00:24:44,080 --> 00:25:01,840
by the using afb version macro

00:24:48,559 --> 00:25:01,840
therefore we define this variable value

00:25:40,080 --> 00:25:44,000
our tune supports some coverage timeline

00:25:43,279 --> 00:25:47,520
statement

00:25:44,000 --> 00:25:52,080
branch and mcdc user can

00:25:47,520 --> 00:25:55,440
choose enable the white box

00:25:52,080 --> 00:25:57,840
testing for private and protected

00:25:55,440 --> 00:25:57,840
of class

00:26:01,840 --> 00:26:11,840
the user can choose

00:26:05,600 --> 00:26:11,840
the directory of the switchery

00:26:15,039 --> 00:26:20,480
each searches can mark as a search

00:26:17,840 --> 00:26:20,480
directory

00:26:20,799 --> 00:26:28,880
time handler directory is

00:26:25,360 --> 00:26:32,159
additional source

00:26:28,880 --> 00:26:36,159
for create the

00:26:32,159 --> 00:26:37,120
environment and the library include

00:26:36,159 --> 00:26:40,240
directory

00:26:37,120 --> 00:26:40,240
is the directory

00:26:40,720 --> 00:26:46,400
store the extend

00:26:43,760 --> 00:26:46,400
library

00:26:51,520 --> 00:26:55,679
in the seventh step user can add some

00:26:54,720 --> 00:27:01,039
user code

00:26:55,679 --> 00:27:01,039
need to view the configuration

00:27:04,840 --> 00:27:07,840
environment

00:27:14,720 --> 00:27:21,120
and after success to

00:27:17,760 --> 00:27:23,600
create a new environment we can

00:27:21,120 --> 00:27:25,679
see the structure of the project in the

00:27:23,600 --> 00:27:35,840
project structure

00:27:25,679 --> 00:27:35,840
by now

00:27:45,279 --> 00:27:52,559
user can choose manual generated

00:27:48,799 --> 00:27:57,120
test k for what function

00:27:52,559 --> 00:28:00,799
and input some suitable argument

00:27:57,120 --> 00:28:03,840
and execute the test guide

00:28:00,799 --> 00:28:03,840
and see the report

00:28:07,520 --> 00:28:12,480
the report include the coverage

00:28:14,840 --> 00:28:17,840
and

00:28:40,240 --> 00:28:47,919
besides the manual test case generate

00:28:43,679 --> 00:28:59,840
user can automat automated

00:28:47,919 --> 00:28:59,840
generate tesca

00:29:24,840 --> 00:29:31,760
okay

00:29:27,679 --> 00:29:33,120
not only generate sk automatically for

00:29:31,760 --> 00:29:36,640
one function

00:29:33,120 --> 00:29:41,279
aka iut can generate

00:29:36,640 --> 00:29:55,840
the test case automatically for

00:29:41,279 --> 00:29:55,840
multiple files or whole of the project

00:29:57,840 --> 00:30:04,720
and one the another feature of

00:30:01,360 --> 00:30:07,760
aka iut is compound test user

00:30:04,720 --> 00:30:09,600
can generate the test k the combined

00:30:07,760 --> 00:30:13,039
test scale and execute in

00:30:09,600 --> 00:30:16,240
one execution to achieve the

00:30:13,039 --> 00:30:16,960
suitable result with the interact

00:30:16,240 --> 00:30:23,840
between

00:30:16,960 --> 00:30:23,840
each unit and the test

00:32:10,559 --> 00:32:17,360
now is some result of aka iut

00:32:13,919 --> 00:32:20,720
tune in action apply for azl

00:32:17,360 --> 00:32:23,600
as in the demonstration we choose a gl

00:32:20,720 --> 00:32:24,240
application framework by the repository

00:32:23,600 --> 00:32:27,840
as

00:32:24,240 --> 00:32:28,720
a system under test this school has

00:32:27,840 --> 00:32:32,720
about

00:32:28,720 --> 00:32:35,919
24 000 live code

00:32:32,720 --> 00:32:37,840
the expected coverage for this

00:32:35,919 --> 00:32:40,880
demonstration project is

00:32:37,840 --> 00:32:44,000
eighty percent we have a locate

00:32:40,880 --> 00:32:47,679
five testers with junior scheme

00:32:44,000 --> 00:32:50,960
for cnc plus plus adm but as

00:32:47,679 --> 00:32:55,440
familiar with linux environment and

00:32:50,960 --> 00:32:58,880
aka iud 2 the hardware we use to build

00:32:55,440 --> 00:33:04,080
testing environment is intel

00:32:58,880 --> 00:33:04,080
i7 cpu and ubuntu

00:33:04,200 --> 00:33:11,120
16.4 version

00:33:07,360 --> 00:33:11,600
in the result we can do the ut activity

00:33:11,120 --> 00:33:15,360
for

00:33:11,600 --> 00:33:19,519
the icl application framework buyer in

00:33:15,360 --> 00:33:21,760
6.5 maintenance with junior testers

00:33:19,519 --> 00:33:22,880
the allocated efforts for studying the

00:33:21,760 --> 00:33:25,600
igl

00:33:22,880 --> 00:33:26,240
application by the source code and view

00:33:25,600 --> 00:33:30,240
the

00:33:26,240 --> 00:33:34,720
iot environment has a high proportion

00:33:30,240 --> 00:33:37,440
about 38 percent

00:33:34,720 --> 00:33:40,159
because the tester is junior with the

00:33:37,440 --> 00:33:43,519
agr platform

00:33:40,159 --> 00:33:47,200
and it takes about two or two

00:33:43,519 --> 00:33:50,320
three days for the intel

00:33:47,200 --> 00:33:54,720
pc to generate the test case for

00:33:50,320 --> 00:33:57,679
this repository in totally

00:33:54,720 --> 00:34:00,000
the average productivity using aka iud

00:33:57,679 --> 00:34:01,120
tune for a zl's application from

00:34:00,000 --> 00:34:04,840
provider is

00:34:01,120 --> 00:34:07,919
about 4 000 like a good

00:34:04,840 --> 00:34:10,480
minimum permanent

00:34:07,919 --> 00:34:12,560
it is more effective than manual unit

00:34:10,480 --> 00:34:15,919
test activity

00:34:12,560 --> 00:34:15,919
about 80 percent

00:34:16,159 --> 00:34:23,679
and now is some our conclusion

00:34:20,480 --> 00:34:26,000
we see that automated c and c plus

00:34:23,679 --> 00:34:27,599
plus programming language unit test

00:34:26,000 --> 00:34:29,440
generation

00:34:27,599 --> 00:34:32,159
is very effective for embedded

00:34:29,440 --> 00:34:35,359
automotive software development project

00:34:32,159 --> 00:34:37,119
it increases the productivity and reduce

00:34:35,359 --> 00:34:39,679
the manual mistake

00:34:37,119 --> 00:34:40,879
we should consider about the standard

00:34:39,679 --> 00:34:43,520
engineering process

00:34:40,879 --> 00:34:44,399
to using automated unit test case

00:34:43,520 --> 00:34:47,599
generation

00:34:44,399 --> 00:34:50,720
in natural sector but still keep

00:34:47,599 --> 00:34:53,839
the expected quality

00:34:50,720 --> 00:34:57,119
in the near future we eager and

00:34:53,839 --> 00:35:01,280
have a short-term plan to enrich

00:34:57,119 --> 00:35:04,480
aka iud tune by adding some feature like

00:35:01,280 --> 00:35:08,320
integrate aka iot platform to

00:35:04,480 --> 00:35:12,160
some standard ide

00:35:08,320 --> 00:35:15,280
like eclipse etc and we

00:35:12,160 --> 00:35:18,400
win steamplay effort to support c

00:35:15,280 --> 00:35:21,839
plus plus 17 version

00:35:18,400 --> 00:35:24,880
and we really want to cooperate with oem

00:35:21,839 --> 00:35:28,000
or t1 and make aka a ut

00:35:24,880 --> 00:35:29,520
in action to acquire certificate to

00:35:28,000 --> 00:35:32,480
using aka iut

00:35:29,520 --> 00:35:32,960
in embedded automotive project with low

00:35:32,480 --> 00:35:36,720
cost

00:35:32,960 --> 00:35:36,720
than other current platform

00:35:38,960 --> 00:35:45,680
and if you have any

00:35:42,400 --> 00:35:49,440
question or any discussion about

00:35:45,680 --> 00:35:52,560
our akai tiktutun please contact us with

00:35:49,440 --> 00:35:52,560
this information

00:35:53,119 --> 00:35:59,839
thank you

00:35:59,920 --> 00:36:02,000

YouTube URL: https://www.youtube.com/watch?v=xA0HcvGnQZw


