Title: Developing, Building and Testing Baremetal Applications Using The Yocto Project & OpenEmbedded...
Publication date: 2020-12-10
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	Developing, Building and Testing Your Baremetal Applications Using The Yocto Project and OpenEmbedded Infrastructure - Alejandro Enedino Hernandez Samaniego, Microsoft
Captions: 
	00:00:00,880 --> 00:00:04,160
so first of all thank you for joining my

00:00:02,879 --> 00:00:05,440
presentation my name is alejandro

00:00:04,160 --> 00:00:07,040
hernandez

00:00:05,440 --> 00:00:09,200
uh my presentation's name is uh

00:00:07,040 --> 00:00:10,880
developing building and testing your

00:00:09,200 --> 00:00:11,440
bare metal applications using the octa

00:00:10,880 --> 00:00:13,440
project

00:00:11,440 --> 00:00:14,559
in open embedded the infrastructure

00:00:13,440 --> 00:00:16,800
basically

00:00:14,559 --> 00:00:18,080
uh and yeah i'm gonna i'm just gonna get

00:00:16,800 --> 00:00:20,560
started

00:00:18,080 --> 00:00:21,359
so the outline of this presentation is

00:00:20,560 --> 00:00:23,199
the following

00:00:21,359 --> 00:00:25,519
um i'll go through some

00:00:23,199 --> 00:00:29,039
multi-architecture embed devices and why

00:00:25,519 --> 00:00:31,519
um i'll go through the runtime testing

00:00:29,039 --> 00:00:34,559
infrastructure coming from open embedded

00:00:31,519 --> 00:00:36,000
um how how it works already and what

00:00:34,559 --> 00:00:37,840
we're trying to do

00:00:36,000 --> 00:00:39,520
and then i'm gonna go and explain a

00:00:37,840 --> 00:00:41,120
little bit about

00:00:39,520 --> 00:00:42,559
um how you can how can you use the

00:00:41,120 --> 00:00:45,920
ocular project for

00:00:42,559 --> 00:00:48,800
uh bare metal applications and then

00:00:45,920 --> 00:00:49,840
at the very end we're going to go to

00:00:48,800 --> 00:00:53,840
doing an actual

00:00:49,840 --> 00:00:53,840
application example and a test

00:00:54,320 --> 00:01:00,480
um so first of all there's um

00:00:58,079 --> 00:01:03,039
as as time goes by we we see more and

00:01:00,480 --> 00:01:05,119
more devices that are multi architecture

00:01:03,039 --> 00:01:07,840
or heterogeneous devices

00:01:05,119 --> 00:01:08,479
um this is because it has a reason right

00:01:07,840 --> 00:01:11,280
like you have

00:01:08,479 --> 00:01:12,240
you can have several processors on on a

00:01:11,280 --> 00:01:14,960
single

00:01:12,240 --> 00:01:16,799
embedded product and it's because

00:01:14,960 --> 00:01:19,360
certain processors are

00:01:16,799 --> 00:01:19,840
uh better fitted to do some tasks than

00:01:19,360 --> 00:01:22,560
others

00:01:19,840 --> 00:01:24,000
so you usually have like for example in

00:01:22,560 --> 00:01:26,640
this device which is the one

00:01:24,000 --> 00:01:27,600
that i work with it's the azure sphere

00:01:26,640 --> 00:01:30,479
device

00:01:27,600 --> 00:01:32,240
and it has two processors it has a uh

00:01:30,479 --> 00:01:35,439
cortex a7 for example

00:01:32,240 --> 00:01:37,680
for linux and then a quartz cam m4 for

00:01:35,439 --> 00:01:39,200
bare metal this is just an example

00:01:37,680 --> 00:01:42,479
there's there's several of these

00:01:39,200 --> 00:01:46,799
and you can see it how the trend is

00:01:42,479 --> 00:01:46,799
uh to create these kind of devices

00:01:47,119 --> 00:01:52,240
um so yeah the open embedded runtime

00:01:50,320 --> 00:01:54,990
testing infrastructure so that's

00:01:52,240 --> 00:01:56,079
i want to point out that this is um

00:01:54,990 --> 00:01:57,920
[Music]

00:01:56,079 --> 00:02:00,079
this happens every day on the auto

00:01:57,920 --> 00:02:03,040
builder for the octo project

00:02:00,079 --> 00:02:04,079
every single day um several

00:02:03,040 --> 00:02:06,840
architectures are

00:02:04,079 --> 00:02:08,720
tested on on linux on the pocket

00:02:06,840 --> 00:02:10,080
distribution so

00:02:08,720 --> 00:02:11,760
this is something that happens every

00:02:10,080 --> 00:02:14,400
single day and it's how

00:02:11,760 --> 00:02:15,599
we in the doctor project get our test

00:02:14,400 --> 00:02:18,640
results and get um

00:02:15,599 --> 00:02:19,680
how our system the quality of our system

00:02:18,640 --> 00:02:22,720
basically

00:02:19,680 --> 00:02:25,920
um so how does this work the

00:02:22,720 --> 00:02:28,160
if you wanted to test a linux os um

00:02:25,920 --> 00:02:30,720
then the way it works right now is that

00:02:28,160 --> 00:02:31,920
um you can either do qmu you can do

00:02:30,720 --> 00:02:33,519
hardware as well

00:02:31,920 --> 00:02:36,560
in this example that i'm showing here

00:02:33,519 --> 00:02:39,840
this is uh on mylocal.com

00:02:36,560 --> 00:02:42,800
and i'm including the test image class

00:02:39,840 --> 00:02:45,519
uh i'm setting the target as qmu and i'm

00:02:42,800 --> 00:02:48,319
setting the test suites as auto

00:02:45,519 --> 00:02:49,680
which which is a uh you know a good

00:02:48,319 --> 00:02:52,800
number of tests that

00:02:49,680 --> 00:02:54,000
will give you a good idea of how your

00:02:52,800 --> 00:02:58,239
system is looking

00:02:54,000 --> 00:02:58,800
on a certain day um you can specify for

00:02:58,239 --> 00:03:01,840
example

00:02:58,800 --> 00:03:03,760
a simple remote um which

00:03:01,840 --> 00:03:04,879
on which you can specify an ip address

00:03:03,760 --> 00:03:06,640
for your device

00:03:04,879 --> 00:03:07,920
and then the test will be done through

00:03:06,640 --> 00:03:10,640
ssh

00:03:07,920 --> 00:03:11,840
um if that's what you want um on test

00:03:10,640 --> 00:03:13,680
suites for example

00:03:11,840 --> 00:03:14,879
one important thing is that you can

00:03:13,680 --> 00:03:18,400
specify

00:03:14,879 --> 00:03:21,840
um the per case basis

00:03:18,400 --> 00:03:24,959
so for example you could put ping ssh

00:03:21,840 --> 00:03:27,360
scp or parse logs those are four tests

00:03:24,959 --> 00:03:28,080
that i can use as an example those are

00:03:27,360 --> 00:03:31,360
located

00:03:28,080 --> 00:03:33,760
on the meta directory leave oqa

00:03:31,360 --> 00:03:36,000
runtime and then cases directory so if

00:03:33,760 --> 00:03:39,280
you go into that directory you can see

00:03:36,000 --> 00:03:42,799
um if a file per test

00:03:39,280 --> 00:03:44,799
um usually and you can find oh the ping

00:03:42,799 --> 00:03:46,159
test success so that i can i can do and

00:03:44,799 --> 00:03:49,120
test that now

00:03:46,159 --> 00:03:50,319
um it's important to point out as well

00:03:49,120 --> 00:03:51,840
that the order matters

00:03:50,319 --> 00:03:53,360
because they have dependencies between

00:03:51,840 --> 00:03:55,439
them so for example

00:03:53,360 --> 00:03:57,599
uh in the example i'm putting there

00:03:55,439 --> 00:03:59,920
there it's uh i put scp

00:03:57,599 --> 00:04:01,280
ping and ssh and what's going to happen

00:03:59,920 --> 00:04:03,599
in that case is that

00:04:01,280 --> 00:04:04,400
scp is going to be skipped and then ping

00:04:03,599 --> 00:04:06,239
is going to be run

00:04:04,400 --> 00:04:08,799
and ssh is going to be run and the

00:04:06,239 --> 00:04:10,239
reason is because the scp test itself

00:04:08,799 --> 00:04:12,879
depends on the ping test

00:04:10,239 --> 00:04:14,080
so um in this case it wouldn't work the

00:04:12,879 --> 00:04:16,720
correct order

00:04:14,080 --> 00:04:18,560
uh would be to put ping and then ssh and

00:04:16,720 --> 00:04:21,199
then scp

00:04:18,560 --> 00:04:22,000
so that's how it works on linux um

00:04:21,199 --> 00:04:24,240
normally

00:04:22,000 --> 00:04:26,320
this is right here for example i'm going

00:04:24,240 --> 00:04:29,040
to put an example how that works

00:04:26,320 --> 00:04:29,680
if i uh build the core image minimal uh

00:04:29,040 --> 00:04:32,400
image

00:04:29,680 --> 00:04:33,120
and then i pass this dash c test image

00:04:32,400 --> 00:04:35,840
i'm going to go back

00:04:33,120 --> 00:04:37,840
and replay that so if i bit big core

00:04:35,840 --> 00:04:39,919
image minimal and then patch that c

00:04:37,840 --> 00:04:43,040
to specify a task and then put test

00:04:39,919 --> 00:04:45,120
image as my task assuming i'm already

00:04:43,040 --> 00:04:46,960
i have already built the image what's

00:04:45,120 --> 00:04:48,560
gonna happen is that it's gonna the

00:04:46,960 --> 00:04:50,639
system is gonna bit big is gonna

00:04:48,560 --> 00:04:53,120
run the test image test as you can see

00:04:50,639 --> 00:04:54,240
there it's running on two seconds seven

00:04:53,120 --> 00:04:56,160
seconds

00:04:54,240 --> 00:04:57,759
and at some point bear with me a little

00:04:56,160 --> 00:05:01,199
bit um

00:04:57,759 --> 00:05:04,400
i'm gonna get a result from that test

00:05:01,199 --> 00:05:06,560
uh from those that's those tests

00:05:04,400 --> 00:05:08,240
um and then for example there it's

00:05:06,560 --> 00:05:11,840
complaining that i didn't put

00:05:08,240 --> 00:05:15,039
uh an ssa server on my image uh

00:05:11,840 --> 00:05:16,560
so i put ping and ssh and it says the

00:05:15,039 --> 00:05:19,120
ping test passed and then the

00:05:16,560 --> 00:05:20,560
ssh test was kept so the important thing

00:05:19,120 --> 00:05:22,880
here is that you can't see

00:05:20,560 --> 00:05:24,560
the report of what was passed what was

00:05:22,880 --> 00:05:26,960
kept um

00:05:24,560 --> 00:05:28,080
and what what failed right so that's how

00:05:26,960 --> 00:05:31,280
it works right now

00:05:28,080 --> 00:05:32,479
on on linux and that's the sort of

00:05:31,280 --> 00:05:35,759
context that you need for

00:05:32,479 --> 00:05:39,120
this um

00:05:35,759 --> 00:05:40,960
so i've implemented the top test image

00:05:39,120 --> 00:05:44,320
boot patterns in open embedded and

00:05:40,960 --> 00:05:45,120
this is because tests need a synchronous

00:05:44,320 --> 00:05:49,440
communication

00:05:45,120 --> 00:05:52,000
between the the host and the target and

00:05:49,440 --> 00:05:53,520
in the test image class you can see the

00:05:52,000 --> 00:05:57,199
examples

00:05:53,520 --> 00:05:57,520
on how to use those in the example there

00:05:57,199 --> 00:06:01,039
uh

00:05:57,520 --> 00:06:02,560
i think i'm uh if i have a web server

00:06:01,039 --> 00:06:04,080
running on an embedded device or

00:06:02,560 --> 00:06:06,400
something and my user is a web server

00:06:04,080 --> 00:06:09,440
i'm changing those specific variables

00:06:06,400 --> 00:06:11,919
um they are they are prepended with uh

00:06:09,440 --> 00:06:13,919
send and search depending on uh if it's

00:06:11,919 --> 00:06:17,120
something that the

00:06:13,919 --> 00:06:17,680
host will send or search on the output

00:06:17,120 --> 00:06:21,280
of the

00:06:17,680 --> 00:06:24,400
target uh and on the qmu runner that pi

00:06:21,280 --> 00:06:27,680
crypt which is what we use to run qmu uh

00:06:24,400 --> 00:06:28,720
automatically uh we can see the defaults

00:06:27,680 --> 00:06:31,039
are set

00:06:28,720 --> 00:06:32,800
and as an example well not example but

00:06:31,039 --> 00:06:36,080
the defaults are for example

00:06:32,800 --> 00:06:37,759
uh that you will to to search for a

00:06:36,080 --> 00:06:38,639
reach prompt you will search for the

00:06:37,759 --> 00:06:42,240
login

00:06:38,639 --> 00:06:44,479
uh column string your

00:06:42,240 --> 00:06:46,960
login user would be root and then your

00:06:44,479 --> 00:06:49,919
login succeeded will be the uh

00:06:46,960 --> 00:06:50,800
a regex like that and then a command

00:06:49,919 --> 00:06:53,919
finished

00:06:50,800 --> 00:06:56,639
uh regis would look like that as well

00:06:53,919 --> 00:06:58,160
so to make it i know it doesn't uh make

00:06:56,639 --> 00:07:00,240
a lot of sense right now but i'll make

00:06:58,160 --> 00:07:03,919
it more clear in this

00:07:00,240 --> 00:07:05,840
example the so whatever you see on red

00:07:03,919 --> 00:07:07,520
is coming on the is it's on the host

00:07:05,840 --> 00:07:11,599
whatever you see on

00:07:07,520 --> 00:07:13,120
uh purple it's on the target and

00:07:11,599 --> 00:07:14,720
so the first thing that happens is that

00:07:13,120 --> 00:07:15,440
the host tells the target to start

00:07:14,720 --> 00:07:18,960
booting

00:07:15,440 --> 00:07:20,880
again whether it is qmu or something um

00:07:18,960 --> 00:07:23,120
or if it if the target is a hardware

00:07:20,880 --> 00:07:25,039
device that needs to just starts booting

00:07:23,120 --> 00:07:26,560
and the host is reading the output of

00:07:25,039 --> 00:07:28,639
the bootlock

00:07:26,560 --> 00:07:29,759
um on the on the target what's gonna

00:07:28,639 --> 00:07:31,039
happen is that it's going to start

00:07:29,759 --> 00:07:33,759
booting and at some point

00:07:31,039 --> 00:07:35,680
it's going to get to a login prompt

00:07:33,759 --> 00:07:39,360
which is the string that we declared

00:07:35,680 --> 00:07:40,319
here in these variables so great we got

00:07:39,360 --> 00:07:42,000
a login prompt

00:07:40,319 --> 00:07:43,599
at that point the host is going to send

00:07:42,000 --> 00:07:46,400
the root new line

00:07:43,599 --> 00:07:47,520
uh string and then what's going to

00:07:46,400 --> 00:07:50,160
happen on the target is it

00:07:47,520 --> 00:07:50,879
is going to log in and we're going to

00:07:50,160 --> 00:07:53,919
get a

00:07:50,879 --> 00:07:55,440
uh a prompt a root prompt which is going

00:07:53,919 --> 00:07:58,240
to be something like root at

00:07:55,440 --> 00:07:58,879
something and then pound sign right uh

00:07:58,240 --> 00:08:00,720
so what's this

00:07:58,879 --> 00:08:02,240
what what that means is that we uh

00:08:00,720 --> 00:08:04,400
successfully logged in

00:08:02,240 --> 00:08:05,919
so now we're the root user user on the

00:08:04,400 --> 00:08:08,960
system

00:08:05,919 --> 00:08:10,319
and and the host knows that

00:08:08,960 --> 00:08:12,560
because it's going to search for that

00:08:10,319 --> 00:08:13,120
regex right and then at that point it's

00:08:12,560 --> 00:08:17,039
gonna

00:08:13,120 --> 00:08:19,360
um send commands to to the target

00:08:17,039 --> 00:08:20,080
that target um it's gonna execute the

00:08:19,360 --> 00:08:21,759
command

00:08:20,080 --> 00:08:23,120
and then it's gonna get another prompt

00:08:21,759 --> 00:08:24,400
because either the command already

00:08:23,120 --> 00:08:27,599
finished

00:08:24,400 --> 00:08:28,319
command finished and then the host will

00:08:27,599 --> 00:08:30,800
continually

00:08:28,319 --> 00:08:31,440
uh just read output so for example and

00:08:30,800 --> 00:08:34,240
then

00:08:31,440 --> 00:08:36,320
if if we were testing ping we would uh

00:08:34,240 --> 00:08:39,440
at this point would send ping

00:08:36,320 --> 00:08:41,039
uh we will uh the target will perform

00:08:39,440 --> 00:08:43,680
the pen command and then at some point

00:08:41,039 --> 00:08:45,839
it will exit and then it will uh finish

00:08:43,680 --> 00:08:46,800
and we're gonna read the output of that

00:08:45,839 --> 00:08:48,800
and then if

00:08:46,800 --> 00:08:50,399
we're gonna assert it looks as the way

00:08:48,800 --> 00:08:51,600
that we expect it to be and that means

00:08:50,399 --> 00:08:55,360
the pink command

00:08:51,600 --> 00:08:57,680
uh succeeded so that's how a test worked

00:08:55,360 --> 00:08:59,040
um that's all great but that's all in

00:08:57,680 --> 00:09:00,640
linux

00:08:59,040 --> 00:09:02,000
so i'm gonna switch a little bit and i'm

00:09:00,640 --> 00:09:02,720
gonna talk about developmental tool

00:09:02,000 --> 00:09:06,800
chains

00:09:02,720 --> 00:09:09,680
and applications on the octa project um

00:09:06,800 --> 00:09:11,760
so this is if you wanted to run an

00:09:09,680 --> 00:09:13,279
example of a bar metal application

00:09:11,760 --> 00:09:15,040
uh using the octa project these are

00:09:13,279 --> 00:09:16,560
these are the following that's the steps

00:09:15,040 --> 00:09:18,560
that you have to follow

00:09:16,560 --> 00:09:19,839
uh first you clone the the pocket

00:09:18,560 --> 00:09:22,160
repository

00:09:19,839 --> 00:09:24,080
you see the into pocky this is all

00:09:22,160 --> 00:09:25,760
normal this is this is what you usually

00:09:24,080 --> 00:09:28,000
do to build the linux

00:09:25,760 --> 00:09:29,440
uh you you source the environment and

00:09:28,000 --> 00:09:31,760
then you add your

00:09:29,440 --> 00:09:34,240
um the meta skeleton layer which comes

00:09:31,760 --> 00:09:35,760
from the pocket repository as well

00:09:34,240 --> 00:09:37,279
you can either use a bit big layers

00:09:35,760 --> 00:09:40,080
command or

00:09:37,279 --> 00:09:41,680
you can just add it to your bblayers.com

00:09:40,080 --> 00:09:44,720
either way it would work

00:09:41,680 --> 00:09:45,360
and then after that we're gonna in this

00:09:44,720 --> 00:09:48,640
case

00:09:45,360 --> 00:09:50,560
i'm using the qmuarm64 machine so i'm

00:09:48,640 --> 00:09:53,360
passing that to my local.com

00:09:50,560 --> 00:09:54,000
and very importantly i'm passing sleep

00:09:53,360 --> 00:09:55,920
skin

00:09:54,000 --> 00:09:57,200
this is leaves your variable uh bare

00:09:55,920 --> 00:09:58,399
metal uh

00:09:57,200 --> 00:10:00,240
the clearances believes he has bare

00:09:58,399 --> 00:10:02,399
metal and i'm saying i'm

00:10:00,240 --> 00:10:03,680
telling the build system that i'm not

00:10:02,399 --> 00:10:06,240
going to use the c library

00:10:03,680 --> 00:10:07,680
it's just going to be a burmel device

00:10:06,240 --> 00:10:08,959
and then after that you can use the

00:10:07,680 --> 00:10:11,120
bitpick and then

00:10:08,959 --> 00:10:12,959
uh bare metal hello world which is what

00:10:11,120 --> 00:10:15,200
uh the recipe is called

00:10:12,959 --> 00:10:16,399
it's on the meta skeleton layer uh you

00:10:15,200 --> 00:10:19,760
can look at it

00:10:16,399 --> 00:10:21,760
it's it's quite simple um after that

00:10:19,760 --> 00:10:23,279
after you you're done building you can

00:10:21,760 --> 00:10:25,440
just run run qmu

00:10:23,279 --> 00:10:26,560
just as you would with uh with the linux

00:10:25,440 --> 00:10:29,120
system

00:10:26,560 --> 00:10:29,600
and at the very end you'll get a you

00:10:29,120 --> 00:10:32,959
know once

00:10:29,600 --> 00:10:35,279
kmu runs uh you'll get a string

00:10:32,959 --> 00:10:37,839
hello a hello world application in this

00:10:35,279 --> 00:10:40,160
case is hello and embedded

00:10:37,839 --> 00:10:41,040
so that's great uh that's all you need

00:10:40,160 --> 00:10:44,320
to do to run

00:10:41,040 --> 00:10:45,760
a sample bare metal application using

00:10:44,320 --> 00:10:48,079
the octa project obviously all

00:10:45,760 --> 00:10:51,120
dependencies all the tool chain

00:10:48,079 --> 00:10:53,360
everything is is built there um

00:10:51,120 --> 00:10:54,959
it just works out of the box uh some

00:10:53,360 --> 00:10:57,040
interesting targets you can do

00:10:54,959 --> 00:10:59,120
um if you're not doing the bare metal uh

00:10:57,040 --> 00:11:01,200
hello world is you can use uh the bare

00:10:59,120 --> 00:11:04,480
metal tool chain meta tool chain

00:11:01,200 --> 00:11:06,640
target sorry which will get you an sdk

00:11:04,480 --> 00:11:07,839
uh if you do have an application that

00:11:06,640 --> 00:11:10,240
has dependencies

00:11:07,839 --> 00:11:12,320
um and you do bare metal hello world

00:11:10,240 --> 00:11:15,920
which is my application dashi

00:11:12,320 --> 00:11:18,640
popular adk you'll get an sdk

00:11:15,920 --> 00:11:20,160
um with along with the dependencies for

00:11:18,640 --> 00:11:23,920
your application

00:11:20,160 --> 00:11:24,560
um so so that way people can develop on

00:11:23,920 --> 00:11:26,959
top of that

00:11:24,560 --> 00:11:28,160
if you want to and one very important

00:11:26,959 --> 00:11:31,120
thing is that if you

00:11:28,160 --> 00:11:32,079
instead of doing tc leap c equals bare

00:11:31,120 --> 00:11:35,040
metal

00:11:32,079 --> 00:11:36,880
if you do tc leaps equals new lift uh

00:11:35,040 --> 00:11:39,200
you'll get the new lift c library

00:11:36,880 --> 00:11:40,320
which uh without going to a lot of

00:11:39,200 --> 00:11:42,320
details it's a

00:11:40,320 --> 00:11:43,839
it's a c library that's for embedded

00:11:42,320 --> 00:11:47,839
devices

00:11:43,839 --> 00:11:49,040
um it in again at a very high level it

00:11:47,839 --> 00:11:51,920
contains uh

00:11:49,040 --> 00:11:53,519
a lot of weak symbols uh for the main

00:11:51,920 --> 00:11:56,240
functions that you would need

00:11:53,519 --> 00:11:57,440
and then the lib gloss part of the new

00:11:56,240 --> 00:12:00,959
live

00:11:57,440 --> 00:12:03,519
source code will have the bsp

00:12:00,959 --> 00:12:05,040
uh part of it so registers and

00:12:03,519 --> 00:12:07,600
everything would be declared there

00:12:05,040 --> 00:12:08,639
so the quick symbols will allow uh new

00:12:07,600 --> 00:12:10,720
leap to link

00:12:08,639 --> 00:12:12,320
against your binary and then liblas

00:12:10,720 --> 00:12:13,120
would override that those things and

00:12:12,320 --> 00:12:15,519
then you'll get

00:12:13,120 --> 00:12:17,839
the actual result uh on your bare metal

00:12:15,519 --> 00:12:19,839
application

00:12:17,839 --> 00:12:21,519
so this is how it looks like again you

00:12:19,839 --> 00:12:24,240
clone the repository you see

00:12:21,519 --> 00:12:24,560
into the repository and then you do bit

00:12:24,240 --> 00:12:27,519
big

00:12:24,560 --> 00:12:28,720
bare metal hello world uh the bell

00:12:27,519 --> 00:12:31,760
system just works

00:12:28,720 --> 00:12:33,519
uh the same as as it does with linux

00:12:31,760 --> 00:12:36,639
and i'm gonna go back this goes too too

00:12:33,519 --> 00:12:39,440
fast um

00:12:36,639 --> 00:12:39,680
so so yeah it parses the recipe recipes

00:12:39,440 --> 00:12:41,839
and

00:12:39,680 --> 00:12:42,720
and and metadata at this point i've

00:12:41,839 --> 00:12:44,959
already built it

00:12:42,720 --> 00:12:46,959
so this is building from estate cache

00:12:44,959 --> 00:12:49,279
and that's why it's so fast

00:12:46,959 --> 00:12:50,160
but you can see that it's executing the

00:12:49,279 --> 00:12:52,160
different tasks for

00:12:50,160 --> 00:12:54,160
my specific application it actually

00:12:52,160 --> 00:12:55,920
generates an rpm

00:12:54,160 --> 00:12:58,000
um and if i poke around the deploy

00:12:55,920 --> 00:13:01,680
directory i can see in my deployed

00:12:58,000 --> 00:13:04,880
images in qmr64 i get a binary

00:13:01,680 --> 00:13:08,320
an l file a manifest

00:13:04,880 --> 00:13:11,920
and a kme boot file dot com file

00:13:08,320 --> 00:13:13,440
um the qmeboot.conf uh

00:13:11,920 --> 00:13:15,600
file is quite important because it's

00:13:13,440 --> 00:13:18,880
what allows us to just

00:13:15,600 --> 00:13:21,200
run run qmu afterwards even if you're

00:13:18,880 --> 00:13:22,079
building a normal linux distribution

00:13:21,200 --> 00:13:25,200
with this

00:13:22,079 --> 00:13:28,000
uh you'll still get that qmeboot.com and

00:13:25,200 --> 00:13:30,560
it just tells bit big how to run run qmu

00:13:28,000 --> 00:13:33,760
with arguments to pass for example

00:13:30,560 --> 00:13:34,720
um so for example there i'm running run

00:13:33,760 --> 00:13:38,240
qmu

00:13:34,720 --> 00:13:38,639
and the system already knows what to

00:13:38,240 --> 00:13:40,160
pass

00:13:38,639 --> 00:13:41,760
because of that file and which is

00:13:40,160 --> 00:13:43,600
generated automatically

00:13:41,760 --> 00:13:45,519
you don't have to take care of that now

00:13:43,600 --> 00:13:46,480
there's a class in in an open embedded

00:13:45,519 --> 00:13:49,199
that allows you to

00:13:46,480 --> 00:13:50,000
to the bare metal applications to get

00:13:49,199 --> 00:13:52,000
this

00:13:50,000 --> 00:13:53,360
um you can see for example there you can

00:13:52,000 --> 00:13:56,399
see the full command you can see i'm

00:13:53,360 --> 00:13:59,440
passing i think uh 128 megabytes of ram

00:13:56,399 --> 00:14:01,680
um 2656 actually

00:13:59,440 --> 00:14:03,600
you can see the cpu that i'm using and

00:14:01,680 --> 00:14:04,320
well at the very end you can see that i

00:14:03,600 --> 00:14:07,680
i

00:14:04,320 --> 00:14:08,880
do get the uh the string hello open

00:14:07,680 --> 00:14:11,760
embedded

00:14:08,880 --> 00:14:13,839
um so that means my application is is

00:14:11,760 --> 00:14:15,519
running properly it was built and run

00:14:13,839 --> 00:14:18,480
properly

00:14:15,519 --> 00:14:19,680
um so that's if you wanted to get

00:14:18,480 --> 00:14:22,000
started that's how

00:14:19,680 --> 00:14:25,279
you uh how you get your vermouth

00:14:22,000 --> 00:14:28,480
application running on on qmurx64

00:14:25,279 --> 00:14:31,040
um so let's say you wanted to do a

00:14:28,480 --> 00:14:32,959
something a bit more interesting uh with

00:14:31,040 --> 00:14:36,480
a bit more features

00:14:32,959 --> 00:14:37,839
um and you want to uh integrate that

00:14:36,480 --> 00:14:39,680
with the testing infrastructure that i

00:14:37,839 --> 00:14:42,079
mentioned before from linux

00:14:39,680 --> 00:14:44,000
um so what i did is i went to the qmu

00:14:42,079 --> 00:14:47,600
source code and i got the addresses for

00:14:44,000 --> 00:14:49,199
the uart for the ram um for the kernel

00:14:47,600 --> 00:14:51,120
and then i went to the developer's

00:14:49,199 --> 00:14:53,440
manual for arm

00:14:51,120 --> 00:14:55,440
i can see that my device is using a uart

00:14:53,440 --> 00:14:58,079
pl 011

00:14:55,440 --> 00:14:59,839
device and from there the important part

00:14:58,079 --> 00:15:02,880
is what i'm putting there on that table

00:14:59,839 --> 00:15:03,680
which is the data register uh the flag

00:15:02,880 --> 00:15:05,839
register

00:15:03,680 --> 00:15:07,600
receive status and and then the error

00:15:05,839 --> 00:15:09,519
clear register

00:15:07,600 --> 00:15:10,639
so i need those addresses because i'm

00:15:09,519 --> 00:15:12,800
gonna

00:15:10,639 --> 00:15:14,720
create my application this some of these

00:15:12,800 --> 00:15:16,800
are already using the bare metal one as

00:15:14,720 --> 00:15:18,160
uh i'm gonna show you in a little bit

00:15:16,800 --> 00:15:20,959
and

00:15:18,160 --> 00:15:22,079
uh you also need the startup code and

00:15:20,959 --> 00:15:24,000
the linker script

00:15:22,079 --> 00:15:25,360
which uh a lot of people are not

00:15:24,000 --> 00:15:26,720
familiar with those things because you

00:15:25,360 --> 00:15:28,560
usually get those things from the c

00:15:26,720 --> 00:15:29,920
runtime so on linux you don't have to

00:15:28,560 --> 00:15:31,040
worry about those things you you get

00:15:29,920 --> 00:15:33,120
them for free

00:15:31,040 --> 00:15:34,480
um on here you have you actually have to

00:15:33,120 --> 00:15:37,519
create those and

00:15:34,480 --> 00:15:38,839
and let um let the system know how it's

00:15:37,519 --> 00:15:42,639
supposed to run your code

00:15:38,839 --> 00:15:44,399
basically this is actually the code for

00:15:42,639 --> 00:15:48,560
the application that you saw

00:15:44,399 --> 00:15:51,680
so it just declares the where the uart

00:15:48,560 --> 00:15:54,959
address is and it has a very simple

00:15:51,680 --> 00:15:57,920
print you are zero function which

00:15:54,959 --> 00:16:00,160
only uh basically just passes that

00:15:57,920 --> 00:16:03,440
character to the driver

00:16:00,160 --> 00:16:06,160
um until it hits the end of the string

00:16:03,440 --> 00:16:06,560
and then i have a c entry function uh

00:16:06,160 --> 00:16:08,639
which

00:16:06,560 --> 00:16:11,040
calls that print ui function and and

00:16:08,639 --> 00:16:14,000
then the argument is hello open embedded

00:16:11,040 --> 00:16:14,399
nothing too fancy in there um do note

00:16:14,000 --> 00:16:16,639
that

00:16:14,399 --> 00:16:17,519
there's no main function on my c program

00:16:16,639 --> 00:16:20,800
in this case

00:16:17,519 --> 00:16:22,000
and that's on purpose um in this case

00:16:20,800 --> 00:16:25,600
i'm using the c entry

00:16:22,000 --> 00:16:28,639
function uh as my main function

00:16:25,600 --> 00:16:30,079
um this is the uh you can see the linker

00:16:28,639 --> 00:16:32,079
script on your left and you can see the

00:16:30,079 --> 00:16:34,639
startup code on your right

00:16:32,079 --> 00:16:36,000
uh these are coming already from uh if

00:16:34,639 --> 00:16:38,880
you do the remote hello world

00:16:36,000 --> 00:16:40,639
you get these um as an example where you

00:16:38,880 --> 00:16:44,000
can add on top

00:16:40,639 --> 00:16:47,440
um so first

00:16:44,000 --> 00:16:50,000
without like at a high level uh i got

00:16:47,440 --> 00:16:52,160
the ram address from the qmi source code

00:16:50,000 --> 00:16:53,600
and then i know that if i'm passing the

00:16:52,160 --> 00:16:57,440
dash channel argument to the

00:16:53,600 --> 00:16:59,759
qmu it adds a 0x1000 to it

00:16:57,440 --> 00:17:01,199
and then i the linker script will will

00:16:59,759 --> 00:17:03,519
make sure that i get my

00:17:01,199 --> 00:17:04,880
binary organized correctly the startup

00:17:03,519 --> 00:17:07,039
uh i'm going to get the text section

00:17:04,880 --> 00:17:08,799
from my startup.o file

00:17:07,039 --> 00:17:10,720
which is which is generated from the one

00:17:08,799 --> 00:17:11,360
on your right uh and all the other

00:17:10,720 --> 00:17:14,720
sections there

00:17:11,360 --> 00:17:15,679
text read only data data bss and then i

00:17:14,720 --> 00:17:18,319
get 4k

00:17:15,679 --> 00:17:20,000
of stack at the end and then the startup

00:17:18,319 --> 00:17:22,240
code basically just tells it

00:17:20,000 --> 00:17:23,120
uh that if you can i think you can see

00:17:22,240 --> 00:17:25,439
my cursor

00:17:23,120 --> 00:17:27,039
uh if you look here it's where i'm

00:17:25,439 --> 00:17:28,880
jumping to the c entry function so

00:17:27,039 --> 00:17:31,600
that's how it's gonna

00:17:28,880 --> 00:17:32,000
know it's gonna have to jump into this

00:17:31,600 --> 00:17:33,919
function

00:17:32,000 --> 00:17:35,679
instead of the main one you could name

00:17:33,919 --> 00:17:38,799
it main it's it's not a problem

00:17:35,679 --> 00:17:40,320
but in this case i uh on purpose i i

00:17:38,799 --> 00:17:43,360
named it differently so you could see

00:17:40,320 --> 00:17:45,120
that you have to change that

00:17:43,360 --> 00:17:48,480
um so that's a linker script that's the

00:17:45,120 --> 00:17:52,320
startup code and that's the actual code

00:17:48,480 --> 00:17:54,880
and again if you wanted to do that uh

00:17:52,320 --> 00:17:57,360
if you wanted to run that you'll get the

00:17:54,880 --> 00:17:59,919
hello open embedded uh string

00:17:57,360 --> 00:18:00,960
at the end and this doesn't have to be

00:17:59,919 --> 00:18:04,160
on qmu

00:18:00,960 --> 00:18:06,080
it is on qmu because it's simple but

00:18:04,160 --> 00:18:08,400
it just as easily can be on a hardware

00:18:06,080 --> 00:18:08,400
device

00:18:10,160 --> 00:18:14,720
so i am going to stop sharing for a

00:18:13,200 --> 00:18:19,679
second and i'm gonna

00:18:14,720 --> 00:18:19,679
switch my share screen to

00:18:20,080 --> 00:18:29,840
eternal give me a second

00:18:29,919 --> 00:18:34,880
and great my application is not showing

00:18:32,720 --> 00:18:34,880
up

00:18:36,160 --> 00:18:39,200
oh there you go

00:18:40,000 --> 00:18:44,960
okay i i hope you can see my screen

00:18:45,440 --> 00:18:48,160
i think you can

00:18:49,679 --> 00:18:56,240
alright so this is my terminal i'm on

00:18:53,039 --> 00:18:59,360
my pokey build directory um

00:18:56,240 --> 00:19:02,640
and again if i do bit big bare metal

00:18:59,360 --> 00:19:04,160
bare metal hello world

00:19:02,640 --> 00:19:05,520
i'll uh in this case it's not going to

00:19:04,160 --> 00:19:06,000
build anything because i already built

00:19:05,520 --> 00:19:07,760
but

00:19:06,000 --> 00:19:10,000
um just so you can see that that's how

00:19:07,760 --> 00:19:13,760
you do it

00:19:10,000 --> 00:19:16,080
if i go and poke around in the source

00:19:13,760 --> 00:19:16,080
code

00:19:19,679 --> 00:19:26,160
if i wanted to modify this and do a a

00:19:22,880 --> 00:19:28,400
again a more interesting program

00:19:26,160 --> 00:19:29,840
um which uses a bit more things than

00:19:28,400 --> 00:19:33,039
just printing a string

00:19:29,840 --> 00:19:34,960
um what i want to do is make it play

00:19:33,039 --> 00:19:36,880
well or play nice with the

00:19:34,960 --> 00:19:39,039
infrastructure that i showed you before

00:19:36,880 --> 00:19:40,480
which is expecting a login prompt it's

00:19:39,039 --> 00:19:43,440
expecting to get a user

00:19:40,480 --> 00:19:44,240
it's expected to get a command so uh

00:19:43,440 --> 00:19:47,600
what i did

00:19:44,240 --> 00:19:50,320
is that i modified the um the c

00:19:47,600 --> 00:19:52,480
code i haven't modified the startup code

00:19:50,320 --> 00:19:53,600
just want to show you that that stays

00:19:52,480 --> 00:19:56,400
the same

00:19:53,600 --> 00:19:58,480
i haven't modified the linker script

00:19:56,400 --> 00:20:01,440
either

00:19:58,480 --> 00:20:01,440
still the same as well

00:20:03,050 --> 00:20:06,320
[Music]

00:20:04,840 --> 00:20:08,880
and

00:20:06,320 --> 00:20:10,240
so what i did is i modified the the c

00:20:08,880 --> 00:20:11,919
code

00:20:10,240 --> 00:20:13,280
and one thing to note here very

00:20:11,919 --> 00:20:16,559
important is that i'm using

00:20:13,280 --> 00:20:18,000
uh standard and string that h

00:20:16,559 --> 00:20:19,520
and you're saying well this is a bare

00:20:18,000 --> 00:20:20,960
metal device how are you using it what

00:20:19,520 --> 00:20:23,120
that's coming from new liv

00:20:20,960 --> 00:20:24,640
so this time i'm gonna have to use uh

00:20:23,120 --> 00:20:25,520
new leave as my seat library when i'm

00:20:24,640 --> 00:20:28,640
building

00:20:25,520 --> 00:20:31,360
i created these uh set of macros um

00:20:28,640 --> 00:20:33,280
just to explain what i'm getting from

00:20:31,360 --> 00:20:34,640
from the arm developer manual basically

00:20:33,280 --> 00:20:37,840
they're just addresses

00:20:34,640 --> 00:20:40,960
and a couple masks that i'm using um

00:20:37,840 --> 00:20:45,120
to to read and write properly from the

00:20:40,960 --> 00:20:47,600
uart i created a couple functions um

00:20:45,120 --> 00:20:48,159
quite simple the putchar uart uh

00:20:47,600 --> 00:20:49,840
function

00:20:48,159 --> 00:20:51,679
basic it's basically got the same thing

00:20:49,840 --> 00:20:52,400
as as a print one that i showed you

00:20:51,679 --> 00:20:54,000
before

00:20:52,400 --> 00:20:57,039
in this case it's just using properly

00:20:54,000 --> 00:20:58,880
the uh the flag register tx

00:20:57,039 --> 00:21:00,640
uh but it's it's printing the characters

00:20:58,880 --> 00:21:02,799
on the on the uart

00:21:00,640 --> 00:21:05,600
um the print uart function is actually a

00:21:02,799 --> 00:21:08,080
wrapper for the put your uart function

00:21:05,600 --> 00:21:09,600
and lastly i have a read uart function

00:21:08,080 --> 00:21:11,840
because i also want to read

00:21:09,600 --> 00:21:14,000
what's coming for to me from the target

00:21:11,840 --> 00:21:16,720
and it that's just basically reading

00:21:14,000 --> 00:21:18,480
it's not it's not too fancy uh and then

00:21:16,720 --> 00:21:20,480
i have a check command function

00:21:18,480 --> 00:21:22,000
and my c entry function i modified a

00:21:20,480 --> 00:21:24,159
little bit as well

00:21:22,000 --> 00:21:25,280
as you can see it still starts with

00:21:24,159 --> 00:21:27,120
print uart and then

00:21:25,280 --> 00:21:29,600
in this case i switched now i'm not

00:21:27,120 --> 00:21:32,559
using open embedded i'm using hello

00:21:29,600 --> 00:21:34,480
uh open source summit japan 2020 uh and

00:21:32,559 --> 00:21:36,640
then i get into a while loop

00:21:34,480 --> 00:21:37,840
in which i'm i'm keeping i'm reading the

00:21:36,640 --> 00:21:40,640
uart and then

00:21:37,840 --> 00:21:42,240
you know uh checking for a command and

00:21:40,640 --> 00:21:44,880
and stuff like that

00:21:42,240 --> 00:21:46,240
so those are the modifications that i

00:21:44,880 --> 00:21:50,000
have made

00:21:46,240 --> 00:21:53,440
to to the example um

00:21:50,000 --> 00:21:58,320
to the example code and if i

00:21:53,440 --> 00:22:00,640
can share this again

00:21:58,320 --> 00:22:00,640
sorry

00:22:02,320 --> 00:22:08,960
okay so

00:22:05,520 --> 00:22:10,480
so we now have a um the bare metal

00:22:08,960 --> 00:22:12,480
application which is very simple

00:22:10,480 --> 00:22:13,919
this again coming from metaskeleton you

00:22:12,480 --> 00:22:17,280
should know that that's for as

00:22:13,919 --> 00:22:19,039
mean to be as an example now i have

00:22:17,280 --> 00:22:20,559
gotten that example and i've modified it

00:22:19,039 --> 00:22:23,679
to my own needs

00:22:20,559 --> 00:22:24,799
and the the last thing that you need is

00:22:23,679 --> 00:22:28,159
to create a taste

00:22:24,799 --> 00:22:30,000
a test case or reuse one that already

00:22:28,159 --> 00:22:31,760
existed in this case what i did is that

00:22:30,000 --> 00:22:33,360
i reused one

00:22:31,760 --> 00:22:35,120
well it's open source after all so we

00:22:33,360 --> 00:22:36,799
should reuse things um

00:22:35,120 --> 00:22:39,120
in this case i'm borrowing the one from

00:22:36,799 --> 00:22:42,240
coming from the meta fractal layer

00:22:39,120 --> 00:22:45,039
um if you wanted to do

00:22:42,240 --> 00:22:46,880
what i'm doing um you would clone the

00:22:45,039 --> 00:22:47,280
pocky distribution the pocky ripple

00:22:46,880 --> 00:22:48,720
sorry

00:22:47,280 --> 00:22:51,200
you will clone the metal three articles

00:22:48,720 --> 00:22:54,080
layer you add the meta reactor layer

00:22:51,200 --> 00:22:55,120
uh to your bblayers.com just as you did

00:22:54,080 --> 00:22:58,799
with them in a

00:22:55,120 --> 00:23:00,720
skeleton and one important thing is to

00:22:58,799 --> 00:23:03,039
uh so on the meta vr2 layer there

00:23:00,720 --> 00:23:06,080
there's a test called friartos

00:23:03,039 --> 00:23:07,520
uh echo and

00:23:06,080 --> 00:23:09,600
uh it's very simple i made some

00:23:07,520 --> 00:23:11,360
modifications but what i wanted to do is

00:23:09,600 --> 00:23:12,159
that my command is gonna be a question

00:23:11,360 --> 00:23:15,360
mark

00:23:12,159 --> 00:23:20,000
and a carriage return and then

00:23:15,360 --> 00:23:22,480
um i am expecting to see uh success

00:23:20,000 --> 00:23:24,159
coming from from from the other end

00:23:22,480 --> 00:23:26,480
right so that way i know

00:23:24,159 --> 00:23:27,600
i can assert and i know that my test

00:23:26,480 --> 00:23:30,880
gate ran uh

00:23:27,600 --> 00:23:32,960
properly uh so this is all the test for

00:23:30,880 --> 00:23:35,679
this is all the code sorry um on the

00:23:32,960 --> 00:23:37,760
test uh it's quite simple

00:23:35,679 --> 00:23:39,280
but it can be used as an example if you

00:23:37,760 --> 00:23:42,000
wanted to test something

00:23:39,280 --> 00:23:43,600
at least it tells me if the system is is

00:23:42,000 --> 00:23:44,559
running properly it was built and run

00:23:43,600 --> 00:23:48,400
properly

00:23:44,559 --> 00:23:49,360
every night so this is where everything

00:23:48,400 --> 00:23:51,760
gets

00:23:49,360 --> 00:23:52,720
wired in together remember when i showed

00:23:51,760 --> 00:23:55,760
you at the beginning

00:23:52,720 --> 00:23:59,279
um how the uh

00:23:55,760 --> 00:24:02,400
how test runs on linux and how you can

00:23:59,279 --> 00:24:04,320
override the patterns um either for

00:24:02,400 --> 00:24:05,520
when you get a login prompt or the user

00:24:04,320 --> 00:24:07,600
that you're using

00:24:05,520 --> 00:24:09,520
and the command subsidy uh the login

00:24:07,600 --> 00:24:11,919
succeeded or the command finished

00:24:09,520 --> 00:24:13,679
well you put these on your local.com for

00:24:11,919 --> 00:24:15,679
one of your com files

00:24:13,679 --> 00:24:16,799
um and then that's the way how you can

00:24:15,679 --> 00:24:18,640
override it

00:24:16,799 --> 00:24:21,039
so in this case i'm using it again the

00:24:18,640 --> 00:24:23,039
machine is my qm arm64

00:24:21,039 --> 00:24:24,320
i switched my tc leap c to new live in

00:24:23,039 --> 00:24:27,120
server metal

00:24:24,320 --> 00:24:29,039
i still inherit the uh test image class

00:24:27,120 --> 00:24:31,360
and i'm declaring the test suites

00:24:29,039 --> 00:24:33,279
um when it was on linux i put it auto

00:24:31,360 --> 00:24:35,279
and then i put ping in ssh

00:24:33,279 --> 00:24:38,000
in this case i'm using the friartos

00:24:35,279 --> 00:24:40,000
underscore echo test case

00:24:38,000 --> 00:24:42,000
and i'm overriding the following things

00:24:40,000 --> 00:24:45,520
um i'm expecting

00:24:42,000 --> 00:24:46,559
so i that the host will know that target

00:24:45,520 --> 00:24:49,039
has booted

00:24:46,559 --> 00:24:50,960
when it sees the open source summit

00:24:49,039 --> 00:24:53,120
japan 2020 string

00:24:50,960 --> 00:24:55,279
uh at that point the target will send

00:24:53,120 --> 00:24:58,400
the yaka project user

00:24:55,279 --> 00:25:00,480
to it the uh sorry the host will send

00:24:58,400 --> 00:25:02,000
that the target will say welcome because

00:25:00,480 --> 00:25:04,880
it knows that user

00:25:02,000 --> 00:25:05,279
and then every command will be a new

00:25:04,880 --> 00:25:07,200
line

00:25:05,279 --> 00:25:08,960
that's how it will recognize that right

00:25:07,200 --> 00:25:11,360
if i over override

00:25:08,960 --> 00:25:12,080
i override those things i modified my

00:25:11,360 --> 00:25:14,400
test case

00:25:12,080 --> 00:25:15,600
and i modified my code already so i got

00:25:14,400 --> 00:25:18,159
all those things

00:25:15,600 --> 00:25:19,600
together so what's gonna happen now uh

00:25:18,159 --> 00:25:21,919
on the bare metal case

00:25:19,600 --> 00:25:24,000
again the red things are on the host the

00:25:21,919 --> 00:25:25,840
purple things are on the target

00:25:24,000 --> 00:25:27,360
um the host will tell the target to

00:25:25,840 --> 00:25:29,120
start booting

00:25:27,360 --> 00:25:30,640
the target will start booting and then

00:25:29,120 --> 00:25:34,000
we'll print the oss

00:25:30,640 --> 00:25:35,919
j uh 2020 string uh

00:25:34,000 --> 00:25:37,840
at that point the hose will send yakta

00:25:35,919 --> 00:25:40,559
project or yp

00:25:37,840 --> 00:25:41,039
uh carriage return and then the target

00:25:40,559 --> 00:25:45,039
will say

00:25:41,039 --> 00:25:48,559
i know you welcome so that means we have

00:25:45,039 --> 00:25:49,679
logged in um at least uh that the system

00:25:48,559 --> 00:25:51,520
thinks that

00:25:49,679 --> 00:25:54,000
and then at that point it's when the

00:25:51,520 --> 00:25:55,919
command will be uh executed right

00:25:54,000 --> 00:25:57,840
um in this case i'm substituting the

00:25:55,919 --> 00:26:01,120
command with what's coming from the

00:25:57,840 --> 00:26:03,440
test case here i put a a question mark

00:26:01,120 --> 00:26:04,400
in there on cmv so that's that's what's

00:26:03,440 --> 00:26:06,080
going to happen

00:26:04,400 --> 00:26:07,679
uh it could have been something else but

00:26:06,080 --> 00:26:10,799
i just switched uh i just

00:26:07,679 --> 00:26:11,440
uh chose the question mark and then at

00:26:10,799 --> 00:26:15,440
that point

00:26:11,440 --> 00:26:17,440
um i'm going to see success because uh

00:26:15,440 --> 00:26:18,640
the the target will know that and it's

00:26:17,440 --> 00:26:20,799
going to print success

00:26:18,640 --> 00:26:23,520
the command will be finished and then

00:26:20,799 --> 00:26:24,400
the host will be reading the target

00:26:23,520 --> 00:26:27,440
output

00:26:24,400 --> 00:26:29,520
and we'll know everything's fine

00:26:27,440 --> 00:26:32,240
so if you wanted to run that this is how

00:26:29,520 --> 00:26:32,240
it would look like

00:26:33,960 --> 00:26:37,120
[Music]

00:26:35,120 --> 00:26:39,200
so i'm rebuilding the burmell

00:26:37,120 --> 00:26:41,919
application because i modified the code

00:26:39,200 --> 00:26:42,960
right so it doesn't take very long it's

00:26:41,919 --> 00:26:45,679
it's quite

00:26:42,960 --> 00:26:46,320
fast so i first rebuild it and then i

00:26:45,679 --> 00:26:50,880
pass the

00:26:46,320 --> 00:26:53,520
test image task to it using c

00:26:50,880 --> 00:26:54,240
and what's going to happen in a couple

00:26:53,520 --> 00:26:58,240
of seconds

00:26:54,240 --> 00:27:01,279
is that it's running the test image

00:26:58,240 --> 00:27:02,880
task as you can see here and there you

00:27:01,279 --> 00:27:06,000
can see the results

00:27:02,880 --> 00:27:09,039
it ran the friar toes test um

00:27:06,000 --> 00:27:12,400
in the past it ran one test i got

00:27:09,039 --> 00:27:15,600
success as one keep zero failure zero

00:27:12,400 --> 00:27:18,720
error zero so that's how you test a

00:27:15,600 --> 00:27:20,880
uh a berm that's how you uh

00:27:18,720 --> 00:27:22,320
make your bare mineral application

00:27:20,880 --> 00:27:24,480
interact properly with the open and

00:27:22,320 --> 00:27:27,760
better infrastructure for testing

00:27:24,480 --> 00:27:31,120
um yeah that's

00:27:27,760 --> 00:27:32,799
it i'm gonna be here for a while uh if

00:27:31,120 --> 00:27:35,840
you if you have questions uh please let

00:27:32,799 --> 00:27:35,840
me know

00:27:45,120 --> 00:27:49,840
i don't okay

00:27:56,559 --> 00:28:03,840
thank you guys for attending

00:28:03,919 --> 00:28:06,000

YouTube URL: https://www.youtube.com/watch?v=i4xNdS5gIwQ


