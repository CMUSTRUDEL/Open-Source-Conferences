Title: BPFTrace - Finally Dtrace Replacement for Linux - Peter Zaitsev, Percona
Publication date: 2020-12-10
Playlist: Open Source Summit Japan & Automotive Linux Summit 2020
Description: 
	BPFTrace - Finally Dtrace Replacement for Linux - Peter Zaitsev, Percona
Captions: 
	00:00:07,120 --> 00:00:11,200
okay

00:00:08,160 --> 00:00:14,480
well uh hello everyone

00:00:11,200 --> 00:00:16,560
good uh good morning uh

00:00:14,480 --> 00:00:18,160
it is interesting how time zone works

00:00:16,560 --> 00:00:21,359
it's still uh

00:00:18,160 --> 00:00:24,000
uh late uh evening on

00:00:21,359 --> 00:00:25,920
thursday here in north carolina in the

00:00:24,000 --> 00:00:29,039
united states where i'm speaking

00:00:25,920 --> 00:00:32,160
from you but uh in japan

00:00:29,039 --> 00:00:36,399
you are on friday already

00:00:32,160 --> 00:00:39,600
and the sun must be shining and bright

00:00:36,399 --> 00:00:44,000
well we will talk today about

00:00:39,600 --> 00:00:47,200
the bpf trace which is a fantastic tool

00:00:44,000 --> 00:00:50,480
and a great replacement for

00:00:47,200 --> 00:00:53,039
for d trace and more specifically

00:00:50,480 --> 00:00:53,840
we'll talk about the quick review of

00:00:53,039 --> 00:00:57,360
what

00:00:53,840 --> 00:01:00,480
epf and dtrace are we'll talk about

00:00:57,360 --> 00:01:03,039
epf tools landscape in general and what

00:01:00,480 --> 00:01:06,479
bpf trace tool

00:01:03,039 --> 00:01:09,040
gives us uh uh specifically

00:01:06,479 --> 00:01:09,520
now let's look at let's take a look at

00:01:09,040 --> 00:01:11,920
the

00:01:09,520 --> 00:01:13,200
instrumentation and durability basics on

00:01:11,920 --> 00:01:16,240
a very

00:01:13,200 --> 00:01:17,759
very high level you think about the

00:01:16,240 --> 00:01:20,880
observability

00:01:17,759 --> 00:01:22,960
this is our ability to look inside the

00:01:20,880 --> 00:01:25,119
iranian system and see

00:01:22,960 --> 00:01:26,479
what's going on and if you're dealing

00:01:25,119 --> 00:01:29,680
with complex systems

00:01:26,479 --> 00:01:33,439
as we all increasingly are it

00:01:29,680 --> 00:01:35,680
is extremely important for monitoring

00:01:33,439 --> 00:01:37,520
troubleshooting performance optimization

00:01:35,680 --> 00:01:40,240
and so on and so forth right

00:01:37,520 --> 00:01:41,200
and for us to see inside that running

00:01:40,240 --> 00:01:44,240
system

00:01:41,200 --> 00:01:46,960
we uh need to make sure what that is

00:01:44,240 --> 00:01:48,960
uh instrument right there are basically

00:01:46,960 --> 00:01:52,640
some points in the system

00:01:48,960 --> 00:01:55,920
which capture uh information from

00:01:52,640 --> 00:01:57,840
that writing systems there are typically

00:01:55,920 --> 00:01:59,040
two kinds of instrumentation you can

00:01:57,840 --> 00:02:01,200
speak about

00:01:59,040 --> 00:02:03,280
static instrumentation and dynamic

00:02:01,200 --> 00:02:06,640
instrumentation and i will

00:02:03,280 --> 00:02:09,759
talk about those two a little bit uh

00:02:06,640 --> 00:02:13,360
later in more details you think about

00:02:09,759 --> 00:02:17,680
high-level instrumentation approach

00:02:13,360 --> 00:02:20,800
you can think about either

00:02:17,680 --> 00:02:23,520
tracing that means you have actual

00:02:20,800 --> 00:02:24,560
places in the code and when a program

00:02:23,520 --> 00:02:27,599
executes

00:02:24,560 --> 00:02:30,560
those places in the code they emit

00:02:27,599 --> 00:02:31,440
a particular event when code point is

00:02:30,560 --> 00:02:35,200
reached

00:02:31,440 --> 00:02:36,080
right that event may just tell us what

00:02:35,200 --> 00:02:38,000
something happened

00:02:36,080 --> 00:02:39,760
or it may give us information about a

00:02:38,000 --> 00:02:43,120
timing error code and a

00:02:39,760 --> 00:02:44,720
whole worth of additional information as

00:02:43,120 --> 00:02:46,959
a progress of that event

00:02:44,720 --> 00:02:48,080
another approach which is also sometimes

00:02:46,959 --> 00:02:50,879
used

00:02:48,080 --> 00:02:51,599
is sampling so for example if you are

00:02:50,879 --> 00:02:55,200
you

00:02:51,599 --> 00:02:55,920
have used the tools like uh oprah file

00:02:55,200 --> 00:02:58,720
or ppro

00:02:55,920 --> 00:03:00,640
more recently those tools essentially

00:02:58,720 --> 00:03:02,840
sample the state of a system

00:03:00,640 --> 00:03:05,440
very frequently and forgot they can

00:03:02,840 --> 00:03:06,400
understand uh what's going on in the

00:03:05,440 --> 00:03:09,120
systems and

00:03:06,400 --> 00:03:10,000
what states the system spent the most

00:03:09,120 --> 00:03:13,599
time in

00:03:10,000 --> 00:03:15,040
right these are generally two approaches

00:03:13,599 --> 00:03:18,879
to

00:03:15,040 --> 00:03:22,080
to instrumentation now if you

00:03:18,879 --> 00:03:24,480
look at especially

00:03:22,080 --> 00:03:25,920
tracing approach as i mentioned there

00:03:24,480 --> 00:03:29,680
are two approaches

00:03:25,920 --> 00:03:31,200
to that static and dynamic

00:03:29,680 --> 00:03:32,720
if you have a static instrumentation

00:03:31,200 --> 00:03:35,760
then you have essentially

00:03:32,720 --> 00:03:35,760
the very specific

00:03:35,840 --> 00:03:40,640
counters or login points introduced

00:03:38,239 --> 00:03:44,879
throughout the code

00:03:40,640 --> 00:03:47,280
right and which computer statistics or

00:03:44,879 --> 00:03:48,560
log the data you want to be logged in

00:03:47,280 --> 00:03:51,680
this case

00:03:48,560 --> 00:03:54,239
we have to be mindful about the overhead

00:03:51,680 --> 00:03:55,200
and with that of course we only have so

00:03:54,239 --> 00:03:57,200
many

00:03:55,200 --> 00:03:59,200
data points we can compute because if

00:03:57,200 --> 00:04:01,760
you compute too many

00:03:59,200 --> 00:04:03,120
it becomes expensive and frankly you

00:04:01,760 --> 00:04:06,720
cannot really compute

00:04:03,120 --> 00:04:10,239
all kind of uh information stats

00:04:06,720 --> 00:04:12,560
uh right or anything you can potentially

00:04:10,239 --> 00:04:14,640
potentially use but at the same time

00:04:12,560 --> 00:04:18,320
static instrumentation is very

00:04:14,640 --> 00:04:21,199
useful right if you look at the linux

00:04:18,320 --> 00:04:23,600
right the proc fs contains a lot of

00:04:21,199 --> 00:04:25,199
stats which is derived through various

00:04:23,600 --> 00:04:27,840
stats implementation

00:04:25,199 --> 00:04:29,440
and many very good basic linux

00:04:27,840 --> 00:04:33,759
performance

00:04:29,440 --> 00:04:36,880
monitoring observability tools vm start

00:04:33,759 --> 00:04:37,280
top iostat and so on and so forth they

00:04:36,880 --> 00:04:41,360
are

00:04:37,280 --> 00:04:43,360
using that uh static instrumentation

00:04:41,360 --> 00:04:45,040
the dynamic instrumentations means you

00:04:43,360 --> 00:04:47,199
don't know

00:04:45,040 --> 00:04:48,960
in advance what you want to instrument

00:04:47,199 --> 00:04:52,560
and we can take a look at the

00:04:48,960 --> 00:04:55,680
running system and the instrument

00:04:52,560 --> 00:04:57,520
pretty much anything we want

00:04:55,680 --> 00:04:59,759
obviously that means if dynamic

00:04:57,520 --> 00:05:02,880
instrumentation we can really

00:04:59,759 --> 00:05:05,919
focus on very particular detail

00:05:02,880 --> 00:05:08,960
we want to investigate if you have to

00:05:05,919 --> 00:05:11,440
but at the same time uh that

00:05:08,960 --> 00:05:13,039
is more complicated for users because

00:05:11,440 --> 00:05:15,759
users have to really

00:05:13,039 --> 00:05:17,199
figure out what is it what they want to

00:05:15,759 --> 00:05:19,600
instrument rather than

00:05:17,199 --> 00:05:20,400
you know working with basic tools who

00:05:19,600 --> 00:05:23,680
just

00:05:20,400 --> 00:05:24,080
show us the right stuff so if you think

00:05:23,680 --> 00:05:27,199
about

00:05:24,080 --> 00:05:30,000
the g trace what is

00:05:27,199 --> 00:05:30,479
g trace and how it relates to those

00:05:30,000 --> 00:05:34,160
things

00:05:30,479 --> 00:05:36,479
i explained the d trace is our dynamics

00:05:34,160 --> 00:05:38,240
tracing framework right so it's focused

00:05:36,479 --> 00:05:41,840
on dynamic tracing

00:05:38,240 --> 00:05:44,240
as a name implies and

00:05:41,840 --> 00:05:47,039
this was developed in sun microsystems

00:05:44,240 --> 00:05:50,400
for solaris of course starting in

00:05:47,039 --> 00:05:52,000
2001 right so it has roots going almost

00:05:50,400 --> 00:05:55,360
20 years

00:05:52,000 --> 00:05:58,400
back it was first released in solaris

00:05:55,360 --> 00:06:02,240
uh solaris 10

00:05:58,400 --> 00:06:06,240
uh and it defines specific trace points

00:06:02,240 --> 00:06:08,880
in kernel and the user land right so uh

00:06:06,240 --> 00:06:10,080
you can specify oh i want to trace

00:06:08,880 --> 00:06:12,880
something which is

00:06:10,080 --> 00:06:14,160
you know with some human readable name

00:06:12,880 --> 00:06:17,680
additionally

00:06:14,160 --> 00:06:21,120
you can trace arbitrary uh functions

00:06:17,680 --> 00:06:23,520
and many more uh data points

00:06:21,120 --> 00:06:25,600
the key the absolutely genius thing

00:06:23,520 --> 00:06:28,639
about dtrac's design

00:06:25,600 --> 00:06:29,120
was and it was of course in its way it

00:06:28,639 --> 00:06:32,720
was

00:06:29,120 --> 00:06:35,199
doesn't have any overhead then

00:06:32,720 --> 00:06:37,440
not enabled right so a lot of those

00:06:35,199 --> 00:06:38,240
special names and functions was pretty

00:06:37,440 --> 00:06:39,840
much

00:06:38,240 --> 00:06:42,240
something like the bug symbols which

00:06:39,840 --> 00:06:46,400
were saying where to

00:06:42,240 --> 00:06:49,759
in uh insult the trace but it did not

00:06:46,400 --> 00:06:52,479
have any overhead and other

00:06:49,759 --> 00:06:53,280
ingenious the trace innovation was the d

00:06:52,479 --> 00:06:56,319
language

00:06:53,280 --> 00:06:59,680
which is language inspired by sea

00:06:56,319 --> 00:07:02,720
and oak which allowed to really uh

00:06:59,680 --> 00:07:05,759
write very cool programs

00:07:02,720 --> 00:07:06,880
right simple programs uh to compute and

00:07:05,759 --> 00:07:11,039
analyze

00:07:06,880 --> 00:07:13,680
uh results g trace proved to be so good

00:07:11,039 --> 00:07:14,840
it went well beyond solaris it was added

00:07:13,680 --> 00:07:18,160
to macos

00:07:14,840 --> 00:07:21,840
freebies net bz or oracle

00:07:18,160 --> 00:07:25,919
uh when it acquired sun they even ported

00:07:21,840 --> 00:07:27,360
dtrace uh to oracle linux as one of the

00:07:25,919 --> 00:07:30,880
differentiators

00:07:27,360 --> 00:07:33,840
right and later on we even

00:07:30,880 --> 00:07:34,479
re-licensed the the code to be available

00:07:33,840 --> 00:07:38,880
for

00:07:34,479 --> 00:07:41,599
linux mainstream but it's kind of

00:07:38,880 --> 00:07:43,280
uh was too little too late by that time

00:07:41,599 --> 00:07:46,960
g trace is now even

00:07:43,280 --> 00:07:50,240
available on windows so it is

00:07:46,960 --> 00:07:52,479
has a pretty uh broad adoption now if

00:07:50,240 --> 00:07:54,800
you look in g trace on linux

00:07:52,479 --> 00:07:55,599
it's not really available in stock linux

00:07:54,800 --> 00:07:57,840
kernel

00:07:55,599 --> 00:07:59,520
and it's not available from major linux

00:07:57,840 --> 00:08:03,039
distributions outside

00:07:59,520 --> 00:08:03,919
of oracle so that's a recent gpl code

00:08:03,039 --> 00:08:07,919
release

00:08:03,919 --> 00:08:11,520
was like it too little too late and

00:08:07,919 --> 00:08:14,160
linux over last

00:08:11,520 --> 00:08:14,879
decade you know pretty much figured out

00:08:14,160 --> 00:08:19,759
a way

00:08:14,879 --> 00:08:23,039
leaving g trace uh in the dust

00:08:19,759 --> 00:08:26,160
so how is tracing implemented in

00:08:23,039 --> 00:08:27,840
linux linux approach to tracing as

00:08:26,160 --> 00:08:31,360
actually to many things

00:08:27,840 --> 00:08:34,880
is to let multiple

00:08:31,360 --> 00:08:38,080
competing frameworks and approaches to

00:08:34,880 --> 00:08:38,479
exist in the kernel and see which of

00:08:38,080 --> 00:08:41,599
them

00:08:38,479 --> 00:08:43,839
over time over time wins

00:08:41,599 --> 00:08:46,240
right rather than kind of more of

00:08:43,839 --> 00:08:49,519
solaris design where it is

00:08:46,240 --> 00:08:52,800
mandated sort of everybody uses the same

00:08:49,519 --> 00:08:57,519
approach now for more details

00:08:52,800 --> 00:08:57,519
about this i really like this fantastic

00:08:57,600 --> 00:09:04,640
uh article by julia

00:09:00,959 --> 00:09:06,000
evans who talks about about linux

00:09:04,640 --> 00:09:09,120
tracing system

00:09:06,000 --> 00:09:11,200
and you can uh really

00:09:09,120 --> 00:09:13,279
read a lot about that and with some

00:09:11,200 --> 00:09:15,680
fantastic illustrations

00:09:13,279 --> 00:09:16,560
but really if you think about that you

00:09:15,680 --> 00:09:20,160
can see

00:09:16,560 --> 00:09:20,560
the linux tracing infrastructure can be

00:09:20,160 --> 00:09:23,920
seen

00:09:20,560 --> 00:09:27,040
as a free different layers

00:09:23,920 --> 00:09:28,640
one is type of a kernel interface right

00:09:27,040 --> 00:09:31,519
that's pretty much

00:09:28,640 --> 00:09:32,720
what you connect to the other is once

00:09:31,519 --> 00:09:35,680
you connect

00:09:32,720 --> 00:09:37,200
and able to consume that event what kind

00:09:35,680 --> 00:09:39,760
of program

00:09:37,200 --> 00:09:41,279
is going to be able to consume that

00:09:39,760 --> 00:09:44,640
event and i thought

00:09:41,279 --> 00:09:46,640
now you have all that events somehow

00:09:44,640 --> 00:09:48,480
produced and processed

00:09:46,640 --> 00:09:50,640
what kind of front-end what kind of

00:09:48,480 --> 00:09:52,560
command line tool right or other kind of

00:09:50,640 --> 00:09:54,800
tool you can use to really

00:09:52,560 --> 00:09:57,440
uh work with that information as a user

00:09:54,800 --> 00:10:01,279
right and as you can see

00:09:57,440 --> 00:10:04,959
in every uh approach as a

00:10:01,279 --> 00:10:06,640
office there are multiple different ways

00:10:04,959 --> 00:10:10,000
how you can

00:10:06,640 --> 00:10:12,160
approach approach tracing

00:10:10,000 --> 00:10:15,760
right so for example if you're speaking

00:10:12,160 --> 00:10:17,440
about consuming those events we can

00:10:15,760 --> 00:10:19,680
choose to store data in the kennel

00:10:17,440 --> 00:10:22,640
buffer and then proceed

00:10:19,680 --> 00:10:24,480
consume raw events and user space we can

00:10:22,640 --> 00:10:26,560
connect the kernel model which can be

00:10:24,480 --> 00:10:29,519
pretty much any program

00:10:26,560 --> 00:10:31,600
right compiled and inserted into a

00:10:29,519 --> 00:10:34,480
kernel or it can be epf program

00:10:31,600 --> 00:10:36,240
right which we'll be talking about more

00:10:34,480 --> 00:10:39,680
now as i mentioned

00:10:36,240 --> 00:10:43,120
ebpf is really this emerging linux

00:10:39,680 --> 00:10:46,480
standard when it comes to

00:10:43,120 --> 00:10:47,040
a dynamic and observability and actually

00:10:46,480 --> 00:10:50,079
many

00:10:47,040 --> 00:10:51,200
other things right but where does that

00:10:50,079 --> 00:10:53,600
evpf

00:10:51,200 --> 00:10:54,560
come from and what it is what the hell

00:10:53,600 --> 00:10:57,680
is that

00:10:54,560 --> 00:11:00,000
bpf well ebpf

00:10:57,680 --> 00:11:01,040
stands for extended berkeley pockets

00:11:00,000 --> 00:11:04,959
filter

00:11:01,040 --> 00:11:08,079
and it's originated or it roots

00:11:04,959 --> 00:11:11,519
goes far even further than

00:11:08,079 --> 00:11:14,560
d trace like almost 30 years ago

00:11:11,519 --> 00:11:18,800
uh it was uh

00:11:14,560 --> 00:11:21,120
designed as a tool for efficient

00:11:18,800 --> 00:11:22,880
uh packet filtering right that's what a

00:11:21,120 --> 00:11:27,279
berkeley packet filter uh

00:11:22,880 --> 00:11:29,839
stands for and epf stands for extended

00:11:27,279 --> 00:11:30,880
mercury packet filter extended version

00:11:29,839 --> 00:11:34,399
which is found

00:11:30,880 --> 00:11:36,079
in linux over time right then almost 30

00:11:34,399 --> 00:11:38,480
years is a lot of time

00:11:36,079 --> 00:11:40,160
it evolved to be general event

00:11:38,480 --> 00:11:41,519
processing framework rather than just a

00:11:40,160 --> 00:11:45,360
pocket filter

00:11:41,519 --> 00:11:46,079
and it also acquired now jit compiler so

00:11:45,360 --> 00:11:49,120
it's

00:11:46,079 --> 00:11:52,320
really can be high performance high

00:11:49,120 --> 00:11:56,240
efficiency solution if you compare

00:11:52,320 --> 00:11:59,360
evf and bpf on the high level uh

00:11:56,240 --> 00:12:02,639
we can see what upf has some

00:11:59,360 --> 00:12:06,320
advanced stuff right it has uh uh

00:12:02,639 --> 00:12:08,880
you know 64 bit registers it has

00:12:06,320 --> 00:12:09,680
a stack right and what's most important

00:12:08,880 --> 00:12:12,720
it has

00:12:09,680 --> 00:12:15,360
what's called map and these are

00:12:12,720 --> 00:12:16,959
the different special proposed data

00:12:15,360 --> 00:12:19,760
structures where

00:12:16,959 --> 00:12:21,680
information can be accumulated and

00:12:19,760 --> 00:12:25,440
processed which makes it

00:12:21,680 --> 00:12:29,680
much more powerful than playing bpf for

00:12:25,440 --> 00:12:33,720
all kind of different use cases evf

00:12:29,680 --> 00:12:37,040
was in linux kernels since 2000

00:12:33,720 --> 00:12:40,079
2014 right i mean

00:12:37,040 --> 00:12:43,279
so it's has been in

00:12:40,079 --> 00:12:45,279
linux kernel now for what about uh

00:12:43,279 --> 00:12:47,120
six years so it's pretty much sure and

00:12:45,279 --> 00:12:50,720
it is the stage where it gets

00:12:47,120 --> 00:12:54,079
to most of their uh linux

00:12:50,720 --> 00:12:56,160
distributions and it's available in uh

00:12:54,079 --> 00:12:57,279
many production installations which is

00:12:56,160 --> 00:12:59,519
great

00:12:57,279 --> 00:13:01,519
it's still being actually developed and

00:12:59,519 --> 00:13:03,279
it's also integrated in the pair of

00:13:01,519 --> 00:13:04,560
tooling system which is

00:13:03,279 --> 00:13:06,959
uh really one of the standard

00:13:04,560 --> 00:13:11,360
performance optimization tools we all

00:13:06,959 --> 00:13:15,440
use on linux the work is also ongoing

00:13:11,360 --> 00:13:17,920
if you check out this uh the url i show

00:13:15,440 --> 00:13:21,360
you on this slide you will find

00:13:17,920 --> 00:13:23,920
what what vpf

00:13:21,360 --> 00:13:25,600
continues to be developed and even in

00:13:23,920 --> 00:13:28,959
the very latest kernels

00:13:25,600 --> 00:13:32,680
there are some more and more

00:13:28,959 --> 00:13:33,839
trace points maps and some other uh

00:13:32,680 --> 00:13:36,720
functionality

00:13:33,839 --> 00:13:38,240
okay so as i mentioned already if you

00:13:36,720 --> 00:13:41,600
look at the evpf

00:13:38,240 --> 00:13:45,360
this is essentially a program

00:13:41,600 --> 00:13:48,399
which connects uh

00:13:45,360 --> 00:13:51,760
to a certain point in the kernel

00:13:48,399 --> 00:13:55,040
so how does that work

00:13:51,760 --> 00:13:59,120
evf program is written in the custom

00:13:55,040 --> 00:14:02,079
byte code right which linux kernel can

00:13:59,120 --> 00:14:03,920
uh can load the fact that it's loading

00:14:02,079 --> 00:14:07,760
this custom byte code

00:14:03,920 --> 00:14:12,240
uh means also what those programs can be

00:14:07,760 --> 00:14:16,240
verified to or prevent misuse

00:14:12,240 --> 00:14:19,279
right i mean maybe they don't

00:14:16,240 --> 00:14:22,079
get to be verified

00:14:19,279 --> 00:14:22,480
to protect you from yourself completely

00:14:22,079 --> 00:14:26,000
but

00:14:22,480 --> 00:14:29,360
to remove a lot of risks which come

00:14:26,000 --> 00:14:32,240
from loading general

00:14:29,360 --> 00:14:33,839
uh you know machine code in kernel right

00:14:32,240 --> 00:14:34,959
and then relative kernel level of

00:14:33,839 --> 00:14:38,000
privileges

00:14:34,959 --> 00:14:39,040
so for example if you have programs they

00:14:38,000 --> 00:14:42,560
cannot

00:14:39,040 --> 00:14:43,279
contain uh contain loops because loops

00:14:42,560 --> 00:14:46,560
are

00:14:43,279 --> 00:14:48,320
dangerous right they faculty can can get

00:14:46,560 --> 00:14:52,000
to a point that they never

00:14:48,320 --> 00:14:54,160
never complete now how do we get that

00:14:52,000 --> 00:14:57,360
byte code custom byte code

00:14:54,160 --> 00:15:00,880
actually llvm compiler can

00:14:57,360 --> 00:15:03,839
uh you compile evf

00:15:00,880 --> 00:15:04,320
as a target so you pretty much can write

00:15:03,839 --> 00:15:08,240
as

00:15:04,320 --> 00:15:11,360
uh c and in some cases you can

00:15:08,240 --> 00:15:13,760
uh get the output

00:15:11,360 --> 00:15:14,720
the challenge with this is what this

00:15:13,760 --> 00:15:17,440
compilation

00:15:14,720 --> 00:15:19,040
is kernel dependent right because a lot

00:15:17,440 --> 00:15:20,800
of the data structures which you may

00:15:19,040 --> 00:15:21,680
access in the kernel and so on and so

00:15:20,800 --> 00:15:24,240
forth

00:15:21,680 --> 00:15:26,240
uh they change with kernel with kernel

00:15:24,240 --> 00:15:28,880
and that is one of them

00:15:26,240 --> 00:15:30,560
i would say the challenges of epf other

00:15:28,880 --> 00:15:32,720
options and which i know is

00:15:30,560 --> 00:15:34,000
being worked right now to make it kind

00:15:32,720 --> 00:15:37,440
of more kernel

00:15:34,000 --> 00:15:41,040
or independent

00:15:37,440 --> 00:15:43,040
the good news is while epf really is

00:15:41,040 --> 00:15:46,880
this kind of scary

00:15:43,040 --> 00:15:49,279
custom byte code very few will ever need

00:15:46,880 --> 00:15:53,199
to run evpf programs

00:15:49,279 --> 00:15:56,720
directly so

00:15:53,199 --> 00:15:59,839
here is how the general interaction

00:15:56,720 --> 00:16:02,079
of a evf and kernel uh works

00:15:59,839 --> 00:16:04,560
so the user program using probably some

00:16:02,079 --> 00:16:07,360
of the tools will generate the evp

00:16:04,560 --> 00:16:08,560
of bytecode which will pass to the

00:16:07,360 --> 00:16:11,519
kernel which will

00:16:08,560 --> 00:16:14,480
verify that and load it as a program

00:16:11,519 --> 00:16:17,759
which will connect to one or few

00:16:14,480 --> 00:16:20,959
uh trace and interfaces k probes

00:16:17,759 --> 00:16:22,959
in the kernel u probes uh in the user

00:16:20,959 --> 00:16:23,920
program trace points perf events and so

00:16:22,959 --> 00:16:27,040
on and so forth

00:16:23,920 --> 00:16:30,639
and as it uh

00:16:27,040 --> 00:16:33,920
works uh it will uh

00:16:30,639 --> 00:16:35,360
store data in maps as i mentioned that

00:16:33,920 --> 00:16:37,360
which could be something like

00:16:35,360 --> 00:16:39,600
histogram right for example if i want to

00:16:37,360 --> 00:16:42,639
collect response time distributions

00:16:39,600 --> 00:16:47,360
which then can be asynchronously fetched

00:16:42,639 --> 00:16:50,560
by by some of some of the tools

00:16:47,360 --> 00:16:53,839
now here is the graph

00:16:50,560 --> 00:16:55,120
which shows you different events and

00:16:53,839 --> 00:16:58,560
different kernel

00:16:55,120 --> 00:17:03,199
versions which talk about what has been

00:16:58,560 --> 00:17:04,880
instrumented with trace points

00:17:03,199 --> 00:17:07,199
uh it corresponds to a different

00:17:04,880 --> 00:17:10,640
functionality in linux kernel

00:17:07,199 --> 00:17:13,919
and you can see what majority of

00:17:10,640 --> 00:17:13,919
the um

00:17:15,520 --> 00:17:22,079
interfaces right and subsystem is uh

00:17:18,720 --> 00:17:25,360
instrumented as well as there is a

00:17:22,079 --> 00:17:28,000
very good instrumentation at the

00:17:25,360 --> 00:17:29,440
various period cpu performance metrics

00:17:28,000 --> 00:17:33,039
right so you can

00:17:29,440 --> 00:17:34,240
the truck cycles instructions you can

00:17:33,039 --> 00:17:37,360
track where

00:17:34,240 --> 00:17:38,880
different cache misses happen and so on

00:17:37,360 --> 00:17:42,480
and so forth

00:17:38,880 --> 00:17:45,840
if you're really interested in g trace

00:17:42,480 --> 00:17:46,880
you may want to check out the project

00:17:45,840 --> 00:17:50,080
iovisor

00:17:46,880 --> 00:17:53,120
it contains a lot of great uvf

00:17:50,080 --> 00:17:56,559
uh stuff and that is every latest

00:17:53,120 --> 00:17:59,840
innovation is happening because in the

00:17:56,559 --> 00:18:01,919
while epf exists in mainly linux

00:17:59,840 --> 00:18:03,840
distributions this typically is not the

00:18:01,919 --> 00:18:07,919
latest version

00:18:03,840 --> 00:18:11,120
okay now let's talk a little bit about

00:18:07,919 --> 00:18:14,960
evf overhead right

00:18:11,120 --> 00:18:18,880
and the overhead

00:18:14,960 --> 00:18:23,360
now of course is uh not nil but it is

00:18:18,880 --> 00:18:27,200
great to see what it is mentioned in the

00:18:23,360 --> 00:18:30,640
uh nanoseconds recall

00:18:27,200 --> 00:18:34,000
right not milliseconds right or even

00:18:30,640 --> 00:18:37,280
uh even microseconds so what that means

00:18:34,000 --> 00:18:40,640
is what if you are running

00:18:37,280 --> 00:18:43,520
medium complexity evf program

00:18:40,640 --> 00:18:44,240
you typically can have hundreds of

00:18:43,520 --> 00:18:47,360
thousands

00:18:44,240 --> 00:18:51,039
or even maybe millions of triggers

00:18:47,360 --> 00:18:54,559
of that evf program uh per second

00:18:51,039 --> 00:18:56,559
per core right before the overhead

00:18:54,559 --> 00:19:00,080
becomes significant

00:18:56,559 --> 00:19:02,640
right so uh

00:19:00,080 --> 00:19:04,480
which is great now of course if you

00:19:02,640 --> 00:19:05,120
really want to hurt yourself right and

00:19:04,480 --> 00:19:08,000
if you

00:19:05,120 --> 00:19:08,960
create some very complicated evf program

00:19:08,000 --> 00:19:12,960
and connect it

00:19:08,960 --> 00:19:13,600
on a very highly triggered kernel

00:19:12,960 --> 00:19:16,880
functions

00:19:13,600 --> 00:19:20,240
you will have piano performance

00:19:16,880 --> 00:19:22,720
uh crawl to hold

00:19:20,240 --> 00:19:25,039
but that's has to be pretty much

00:19:22,720 --> 00:19:30,160
delivered right it's not that easy

00:19:25,039 --> 00:19:32,880
to make that mistake okay

00:19:30,160 --> 00:19:34,160
the next thing to talk about is evf

00:19:32,880 --> 00:19:35,919
front-ends

00:19:34,160 --> 00:19:38,080
so when you speak about front-end this

00:19:35,919 --> 00:19:42,160
pretty much means the tools

00:19:38,080 --> 00:19:45,280
which help us to not to write that pesky

00:19:42,160 --> 00:19:46,640
bpf byte code but instead use some

00:19:45,280 --> 00:19:50,240
command line tools which

00:19:46,640 --> 00:19:50,880
do all of that underneath if you look at

00:19:50,240 --> 00:19:54,000
the

00:19:50,880 --> 00:19:57,919
uh landscape

00:19:54,000 --> 00:20:00,320
in from 2019 right which didn't

00:19:57,919 --> 00:20:02,320
change i think that uh much right you

00:20:00,320 --> 00:20:05,360
can see there is a whole bunch of tools

00:20:02,320 --> 00:20:07,760
being available and i took that

00:20:05,360 --> 00:20:09,039
this slide from brandon greg right which

00:20:07,760 --> 00:20:12,799
talks about

00:20:09,039 --> 00:20:16,159
tools based on uh usability

00:20:12,799 --> 00:20:16,799
uh and scope right and to what extent

00:20:16,159 --> 00:20:19,679
the bar

00:20:16,799 --> 00:20:20,480
is filled is how complete is development

00:20:19,679 --> 00:20:22,960
of at all

00:20:20,480 --> 00:20:24,720
right what you can see in this case is

00:20:22,960 --> 00:20:27,840
what bpf trace

00:20:24,720 --> 00:20:31,280
kind of really fits in this

00:20:27,840 --> 00:20:34,400
sort of best zone right from one extent

00:20:31,280 --> 00:20:37,440
it is has a very high

00:20:34,400 --> 00:20:40,880
scope right it can really do

00:20:37,440 --> 00:20:42,480
a lot on the other hand it's also rather

00:20:40,880 --> 00:20:45,840
easy of use

00:20:42,480 --> 00:20:50,240
and it is also very mature

00:20:45,840 --> 00:20:50,240
in fact at this point

00:20:50,320 --> 00:20:56,000
it is uh generally available and has

00:20:53,919 --> 00:20:58,880
been in the stage for

00:20:56,000 --> 00:21:01,280
more than a year another front end which

00:20:58,880 --> 00:21:04,559
came to market slightly before

00:21:01,280 --> 00:21:05,280
vpf trace was bcc which also was good

00:21:04,559 --> 00:21:07,919
and really

00:21:05,280 --> 00:21:09,679
provided a lot of very you know cool

00:21:07,919 --> 00:21:12,559
stuff but that was

00:21:09,679 --> 00:21:13,600
not as uh easy to use and essentially

00:21:12,559 --> 00:21:17,520
when you think about

00:21:13,600 --> 00:21:20,960
developing ubcc tools so let's compare

00:21:17,520 --> 00:21:21,919
those two front ends if you think as a

00:21:20,960 --> 00:21:25,919
user

00:21:21,919 --> 00:21:29,039
vcc has great set of approval tools

00:21:25,919 --> 00:21:30,000
which are very easy to use convenient

00:21:29,039 --> 00:21:32,720
and so on and so forth

00:21:30,000 --> 00:21:34,000
but developing your own tools extended

00:21:32,720 --> 00:21:37,280
modifying

00:21:34,000 --> 00:21:40,400
is not easier with the f trace

00:21:37,280 --> 00:21:42,640
it has so far smaller collection of the

00:21:40,400 --> 00:21:45,760
tools at least last time i checked

00:21:42,640 --> 00:21:49,120
but it is much easier language to extend

00:21:45,760 --> 00:21:52,159
improve and modify uh your tools

00:21:49,120 --> 00:21:55,679
let's compare for example

00:21:52,159 --> 00:21:58,799
uh their uh you know program

00:21:55,679 --> 00:22:04,159
right some uh very

00:21:58,799 --> 00:22:07,360
simple which traces bash commands

00:22:04,159 --> 00:22:08,720
in bpf trace and bcc right you can

00:22:07,360 --> 00:22:12,480
probably see

00:22:08,720 --> 00:22:15,840
uh how easier to read

00:22:12,480 --> 00:22:16,400
right and how less sort of brutal vpf

00:22:15,840 --> 00:22:18,960
code

00:22:16,400 --> 00:22:19,520
is compared to the vcc code right it's

00:22:18,960 --> 00:22:23,280
still

00:22:19,520 --> 00:22:28,640
bcc is still much better than

00:22:23,280 --> 00:22:28,640
working with vcc uh epf byte code but

00:22:28,960 --> 00:22:35,919
not as not as easy

00:22:32,880 --> 00:22:37,039
if you look at bcc tools available new

00:22:35,919 --> 00:22:40,400
conceiver is

00:22:37,039 --> 00:22:43,919
a lot of tools as i mentioned and

00:22:40,400 --> 00:22:46,000
i absolutely uh love uh those right and

00:22:43,919 --> 00:22:47,760
especially when they came out compared

00:22:46,000 --> 00:22:50,240
to the standard

00:22:47,760 --> 00:22:51,120
you know top vm start and so on for

00:22:50,240 --> 00:22:54,960
those

00:22:51,120 --> 00:22:58,400
tools give you so much more visibility

00:22:54,960 --> 00:22:59,840
and without adding any overhead

00:22:58,400 --> 00:23:02,559
especially when you are

00:22:59,840 --> 00:23:03,679
not using them that is you know just

00:23:02,559 --> 00:23:07,039
absolutely

00:23:03,679 --> 00:23:09,120
uh fantastic okay

00:23:07,039 --> 00:23:10,159
the next thing for us to cover is to

00:23:09,120 --> 00:23:13,440
talk about g

00:23:10,159 --> 00:23:14,000
trace and bpf trays right how do those

00:23:13,440 --> 00:23:17,520
uh

00:23:14,000 --> 00:23:18,240
uh do those uh compare now if you think

00:23:17,520 --> 00:23:21,600
about

00:23:18,240 --> 00:23:25,280
uh uh getting things done

00:23:21,600 --> 00:23:27,200
right then it have to do to various

00:23:25,280 --> 00:23:28,880
performance analysis and travel through

00:23:27,200 --> 00:23:31,120
the problem

00:23:28,880 --> 00:23:32,080
you can see what if you are in a dtrace

00:23:31,120 --> 00:23:36,000
ecosystems

00:23:32,080 --> 00:23:39,919
you will use a lot of

00:23:36,000 --> 00:23:43,039
evd trace directly or d trace plus shell

00:23:39,919 --> 00:23:46,640
in the bpf uh space

00:23:43,039 --> 00:23:49,039
you would use bpf trace for relatively

00:23:46,640 --> 00:23:52,159
simple one-liners and simple

00:23:49,039 --> 00:23:54,480
um or simple tools right but

00:23:52,159 --> 00:23:55,360
if you want to write the complicated

00:23:54,480 --> 00:23:57,840
tools

00:23:55,360 --> 00:23:58,559
chances are that is where you would need

00:23:57,840 --> 00:24:01,760
to use

00:23:58,559 --> 00:24:05,039
bcc right but at the same time

00:24:01,760 --> 00:24:06,159
you can see what the bcc because of what

00:24:05,039 --> 00:24:08,720
it offers

00:24:06,159 --> 00:24:10,720
it is actually much more powerful than

00:24:08,720 --> 00:24:13,840
you ever could do

00:24:10,720 --> 00:24:18,720
with shell and d

00:24:13,840 --> 00:24:19,440
trace if you look at bpf trace vpf trace

00:24:18,720 --> 00:24:23,120
was

00:24:19,440 --> 00:24:26,400
inspired by a d trace

00:24:23,120 --> 00:24:27,919
of course right and it's similar in

00:24:26,400 --> 00:24:30,880
spirit but there is no

00:24:27,919 --> 00:24:31,679
direct comparability and also because

00:24:30,880 --> 00:24:35,760
there is

00:24:31,679 --> 00:24:36,960
many years in the gap between design of

00:24:35,760 --> 00:24:40,240
those tools

00:24:36,960 --> 00:24:43,440
bpf trace is really more

00:24:40,240 --> 00:24:45,360
powerful but if you have experience with

00:24:43,440 --> 00:24:48,400
gtrace you'll probably catch

00:24:45,360 --> 00:24:51,760
bpf trace in no time

00:24:48,400 --> 00:24:55,520
right so for example here uh

00:24:51,760 --> 00:24:58,720
how different functions and

00:24:55,520 --> 00:25:01,440
variables and dawn

00:24:58,720 --> 00:25:03,279
called in d trace and vtf trays right

00:25:01,440 --> 00:25:06,080
and if you just look

00:25:03,279 --> 00:25:07,200
at uh this comparison you'll see well it

00:25:06,080 --> 00:25:10,480
is not the same

00:25:07,200 --> 00:25:14,159
but they're kind of

00:25:10,480 --> 00:25:17,919
similar enough right so converting

00:25:14,159 --> 00:25:21,440
those would not be the major problem

00:25:17,919 --> 00:25:25,760
and in fact that is not a

00:25:21,440 --> 00:25:28,640
major problem it is uh typically harder

00:25:25,760 --> 00:25:29,279
to if you want to pour a program let's

00:25:28,640 --> 00:25:32,880
say from

00:25:29,279 --> 00:25:35,919
stellaris d trace to get the same stuff

00:25:32,880 --> 00:25:37,120
on linux is find the proper name for

00:25:35,919 --> 00:25:41,279
trace points

00:25:37,120 --> 00:25:45,120
then to convert the rest of the syntax

00:25:41,279 --> 00:25:48,240
let's look at more details

00:25:45,120 --> 00:25:52,480
in this case right so this is also

00:25:48,240 --> 00:25:55,520
now the same program

00:25:52,480 --> 00:25:58,720
which is uh implemented

00:25:55,520 --> 00:26:02,080
in bpf trace uh scripting language

00:25:58,720 --> 00:26:06,000
or in dtrace language d

00:26:02,080 --> 00:26:10,000
right again as you can see the syntax is

00:26:06,000 --> 00:26:12,400
not exactly the same but there is is

00:26:10,000 --> 00:26:13,600
a lot of things here which are uh which

00:26:12,400 --> 00:26:16,559
are similar

00:26:13,600 --> 00:26:18,320
and uh i would say that bpf trace syntax

00:26:16,559 --> 00:26:21,600
is designed to be

00:26:18,320 --> 00:26:25,600
slightly more compact and

00:26:21,600 --> 00:26:29,039
uh more clean if you like

00:26:25,600 --> 00:26:32,320
okay so

00:26:29,039 --> 00:26:32,799
bpf trace how do we get it and what is

00:26:32,320 --> 00:26:36,640
uh

00:26:32,799 --> 00:26:40,799
required if you look at

00:26:36,640 --> 00:26:44,320
requirements for vpf trace uh these are

00:26:40,799 --> 00:26:47,760
uh our requirements right you can see

00:26:44,320 --> 00:26:51,440
what majority of

00:26:47,760 --> 00:26:54,159
dpf trace functionality is

00:26:51,440 --> 00:26:54,960
available with most of the kernels

00:26:54,159 --> 00:26:58,480
you'll find

00:26:54,960 --> 00:26:58,480
now running in wild

00:27:04,400 --> 00:27:11,600
here is where different

00:27:08,559 --> 00:27:15,520
sort of uh prefixes

00:27:11,600 --> 00:27:19,600
uh trace points and other

00:27:15,520 --> 00:27:23,200
things would uh uh hit with

00:27:19,600 --> 00:27:27,200
vpf trace and again you can see

00:27:23,200 --> 00:27:31,600
it really gives us very good coverage

00:27:27,200 --> 00:27:36,399
of of different areas of the system

00:27:31,600 --> 00:27:39,600
and the hardware here is

00:27:36,399 --> 00:27:40,399
how epf price uh works right as you can

00:27:39,600 --> 00:27:44,320
see

00:27:40,399 --> 00:27:48,000
uh you get vpf program which goes and

00:27:44,320 --> 00:27:51,600
sort of compiles

00:27:48,000 --> 00:27:53,200
uh that program right your parser and

00:27:51,600 --> 00:27:57,200
goes through

00:27:53,200 --> 00:27:59,120
uh through c lang processor right but in

00:27:57,200 --> 00:28:05,120
the end you would

00:27:59,120 --> 00:28:08,720
get bpf byte code as we discussed then

00:28:05,120 --> 00:28:12,159
it gets loaded to kernel and

00:28:08,720 --> 00:28:13,120
so on and so off right it's interesting

00:28:12,159 --> 00:28:16,799
what

00:28:13,120 --> 00:28:19,840
when you run bpf trace program

00:28:16,799 --> 00:28:22,080
in most cases you will see like two

00:28:19,840 --> 00:28:23,120
events sort of working at the same time

00:28:22,080 --> 00:28:26,320
right you will have a

00:28:23,120 --> 00:28:29,279
bpf program in the kernel

00:28:26,320 --> 00:28:30,080
which is doing all the data gathering

00:28:29,279 --> 00:28:32,640
and then your

00:28:30,080 --> 00:28:34,320
bpf trace essentially blocks or just

00:28:32,640 --> 00:28:37,679
consume results

00:28:34,320 --> 00:28:40,640
and then the program epf trace or

00:28:37,679 --> 00:28:41,919
which runs the script terminates then

00:28:40,640 --> 00:28:44,960
the

00:28:41,919 --> 00:28:49,200
kernel epf programs are also

00:28:44,960 --> 00:28:51,120
unloaded if you want to run dpf trades

00:28:49,200 --> 00:28:53,360
and linear distributions

00:28:51,120 --> 00:28:54,960
you you'll find not all distributions

00:28:53,360 --> 00:28:57,760
currently have packages

00:28:54,960 --> 00:28:58,640
and also development is fast-paced so

00:28:57,760 --> 00:29:01,679
many

00:28:58,640 --> 00:29:04,640
may have outdated packages so if you're

00:29:01,679 --> 00:29:08,000
really into epf you may want to consider

00:29:04,640 --> 00:29:08,000
uh new packages

00:29:08,080 --> 00:29:14,399
now one way to get dpf trace is

00:29:11,360 --> 00:29:16,559
to use uh snap

00:29:14,399 --> 00:29:17,840
right but we'll talk about limitation

00:29:16,559 --> 00:29:20,159
what that gives

00:29:17,840 --> 00:29:21,600
and when you get that you will be able

00:29:20,159 --> 00:29:24,840
to run

00:29:21,600 --> 00:29:26,080
this kind of nice uh of one liners like

00:29:24,840 --> 00:29:30,399
this

00:29:26,080 --> 00:29:34,080
which uh pretty much allows us to

00:29:30,399 --> 00:29:37,120
uh trace where uh

00:29:34,080 --> 00:29:38,000
io re request performance by different

00:29:37,120 --> 00:29:40,159
processors

00:29:38,000 --> 00:29:41,679
right so in this case we can see

00:29:40,159 --> 00:29:45,039
actually quite interesting

00:29:41,679 --> 00:29:46,000
example of mysql which has this kind of

00:29:45,039 --> 00:29:47,679
double hump

00:29:46,000 --> 00:29:49,039
performance distribution right for this

00:29:47,679 --> 00:29:51,200
scale right

00:29:49,039 --> 00:29:52,640
it comes from a fact that some requests

00:29:51,200 --> 00:29:55,279
come from a cache

00:29:52,640 --> 00:29:57,520
right and they're generally fast and

00:29:55,279 --> 00:30:00,960
others

00:29:57,520 --> 00:30:01,440
uh come from reading the disk this gives

00:30:00,960 --> 00:30:04,640
us b

00:30:01,440 --> 00:30:07,600
model distribution right with uh

00:30:04,640 --> 00:30:08,799
this which i think is quite quite cool

00:30:07,600 --> 00:30:11,440
uh anyway

00:30:08,799 --> 00:30:13,600
uh if you figure out something and say

00:30:11,440 --> 00:30:14,320
hey that is a cool one liner i want to

00:30:13,600 --> 00:30:16,960
use

00:30:14,320 --> 00:30:16,960
you can actually

00:30:18,399 --> 00:30:27,760
say that in like a read bt file

00:30:23,520 --> 00:30:31,279
right for example and then run that file

00:30:27,760 --> 00:30:31,760
instead of passing one liner it will

00:30:31,279 --> 00:30:34,480
work

00:30:31,760 --> 00:30:36,559
uh it will work as well if you look at

00:30:34,480 --> 00:30:40,159
vpf trace details

00:30:36,559 --> 00:30:43,200
you will find what general syntax is uh

00:30:40,159 --> 00:30:45,440
kind of quite simple right

00:30:43,200 --> 00:30:46,880
you'll have a probe or several probes

00:30:45,440 --> 00:30:50,159
you attach to

00:30:46,880 --> 00:30:51,360
when you will have a filter which allows

00:30:50,159 --> 00:30:53,679
you to filter

00:30:51,360 --> 00:30:56,320
uh to more specifically to what to

00:30:53,679 --> 00:30:58,799
attach to so for example you can say hey

00:30:56,320 --> 00:31:00,240
i want to uh attach to this system

00:30:58,799 --> 00:31:02,240
called but

00:31:00,240 --> 00:31:03,279
only for given process id not for

00:31:02,240 --> 00:31:06,640
everything

00:31:03,279 --> 00:31:09,200
and then you have an action which

00:31:06,640 --> 00:31:10,640
gives us a mini program to run which can

00:31:09,200 --> 00:31:13,919
do some math store

00:31:10,640 --> 00:31:16,720
data in maps and

00:31:13,919 --> 00:31:16,720
so on and so forth

00:31:16,960 --> 00:31:24,480
as i mentioned number of tools

00:31:20,000 --> 00:31:27,519
which are uh initially created with bcc

00:31:24,480 --> 00:31:30,320
are now being powered with bpf trays

00:31:27,519 --> 00:31:31,279
right which are sort of same

00:31:30,320 --> 00:31:34,320
functionality

00:31:31,279 --> 00:31:35,679
just re-implemented using bpf framework

00:31:34,320 --> 00:31:38,640
and here are

00:31:35,679 --> 00:31:39,840
examples of some of the cool tools which

00:31:38,640 --> 00:31:43,120
i think

00:31:39,840 --> 00:31:45,600
not only greatly usable by themselves

00:31:43,120 --> 00:31:47,360
but they also provide good insights

00:31:45,600 --> 00:31:50,480
about who build uh

00:31:47,360 --> 00:31:50,480
build additional tools

00:31:51,760 --> 00:31:56,399
now if you ever want to see how a bpf

00:31:55,120 --> 00:31:59,519
code works

00:31:56,399 --> 00:32:00,080
well you can you can do this right you

00:31:59,519 --> 00:32:03,519
can

00:32:00,080 --> 00:32:06,720
actually do minus v

00:32:03,519 --> 00:32:07,840
for epf trace and it will show us uh the

00:32:06,720 --> 00:32:12,320
byte code

00:32:07,840 --> 00:32:12,320
right which is kind of i don't think

00:32:12,559 --> 00:32:20,159
a super interesting unless you are

00:32:16,720 --> 00:32:22,000
uh the developer right but if you

00:32:20,159 --> 00:32:23,360
really want to look into how different

00:32:22,000 --> 00:32:28,080
things uh

00:32:23,360 --> 00:32:31,760
work inside then you can do that

00:32:28,080 --> 00:32:35,919
okay now let's do some

00:32:31,760 --> 00:32:36,270
practice oh and let's say what we want

00:32:35,919 --> 00:32:38,399
to

00:32:36,270 --> 00:32:41,440
[Music]

00:32:38,399 --> 00:32:45,360
use bpf trace

00:32:41,440 --> 00:32:46,799
to trace mysql and let's say i want to

00:32:45,360 --> 00:32:50,799
trace

00:32:46,799 --> 00:32:52,320
uh their execution of a different

00:32:50,799 --> 00:32:56,000
queries

00:32:52,320 --> 00:32:59,279
in mysql there is dispatch command

00:32:56,000 --> 00:33:01,440
which is a pretty much function which is

00:32:59,279 --> 00:33:04,159
responsible for

00:33:01,440 --> 00:33:05,679
executing the query right or other

00:33:04,159 --> 00:33:08,880
commands right so

00:33:05,679 --> 00:33:10,640
generally if you look at the printing

00:33:08,880 --> 00:33:12,159
the second argument of that that should

00:33:10,640 --> 00:33:15,200
be the query

00:33:12,159 --> 00:33:18,960
if you run this comment though we will

00:33:15,200 --> 00:33:20,799
have uh the the problem

00:33:18,960 --> 00:33:22,960
in this case so that tells us oh what

00:33:20,799 --> 00:33:26,240
the file

00:33:22,960 --> 00:33:29,679
mysqld doesn't exist even while

00:33:26,240 --> 00:33:31,519
it's actually kind of does

00:33:29,679 --> 00:33:33,279
well the problem in this case is as i

00:33:31,519 --> 00:33:36,559
mentioned if i

00:33:33,279 --> 00:33:39,840
install standard snap package without

00:33:36,559 --> 00:33:42,000
additional options it will not

00:33:39,840 --> 00:33:42,880
have access to random files on the file

00:33:42,000 --> 00:33:46,720
system

00:33:42,880 --> 00:33:50,080
by uh by design right and you can

00:33:46,720 --> 00:33:54,799
either do that or

00:33:50,080 --> 00:33:58,159
i just pretty much decided not to

00:33:54,799 --> 00:34:02,399
mess with it and instead installed

00:33:58,159 --> 00:34:04,399
the bpf trace through aft package

00:34:02,399 --> 00:34:05,760
now when you do that though we'll get a

00:34:04,399 --> 00:34:09,520
second problem

00:34:05,760 --> 00:34:11,679
now we get a problem hey symbol doesn't

00:34:09,520 --> 00:34:14,159
exist

00:34:11,679 --> 00:34:16,639
right even though if you ever looked at

00:34:14,159 --> 00:34:19,679
the mysql source code you know

00:34:16,639 --> 00:34:22,560
there is a dispatch

00:34:19,679 --> 00:34:26,000
command like that so let's look at the

00:34:22,560 --> 00:34:29,280
mysql or actually in this case that was

00:34:26,000 --> 00:34:31,919
uh marie db symbols and see

00:34:29,280 --> 00:34:34,240
if that symbol of dispatch command

00:34:31,919 --> 00:34:37,280
actually exists

00:34:34,240 --> 00:34:40,720
and you would see it would but

00:34:37,280 --> 00:34:43,839
it will have that kind of

00:34:40,720 --> 00:34:47,520
funny cryptic name

00:34:43,839 --> 00:34:51,919
right and that cryptic name

00:34:47,520 --> 00:34:55,440
comes from c plus plus functions

00:34:51,919 --> 00:34:58,560
manglin because c plus plus allows us to

00:34:55,440 --> 00:35:01,520
have multiple functions of the same

00:34:58,560 --> 00:35:02,000
name by different signature right so to

00:35:01,520 --> 00:35:05,040
avoid

00:35:02,000 --> 00:35:08,640
conflicts it's kind of mangles them

00:35:05,040 --> 00:35:12,079
in this kind of funny way

00:35:08,640 --> 00:35:14,880
right but now if we

00:35:12,079 --> 00:35:16,800
find the right functions you want to do

00:35:14,880 --> 00:35:20,560
right which we did

00:35:16,800 --> 00:35:24,640
no uh we can uh

00:35:20,560 --> 00:35:24,640
connect the function and we will see

00:35:24,800 --> 00:35:29,440
uh the system output and that are

00:35:27,760 --> 00:35:32,720
actually their

00:35:29,440 --> 00:35:35,760
queries which system is uh

00:35:32,720 --> 00:35:37,680
israel right which is uh which is pretty

00:35:35,760 --> 00:35:40,720
cool

00:35:37,680 --> 00:35:44,480
okay well uh

00:35:40,720 --> 00:35:48,079
this is a brief uh introduction to their

00:35:44,480 --> 00:35:51,920
evf if you're really interested in

00:35:48,079 --> 00:35:55,280
uvf i would suggest you to

00:35:51,920 --> 00:35:58,400
check out brandon greg's website he has

00:35:55,280 --> 00:36:01,359
fantastic set of materials about epf

00:35:58,400 --> 00:36:02,320
uh you know right articles tutorials and

00:36:01,359 --> 00:36:06,320
so on so

00:36:02,320 --> 00:36:08,400
and actually uh i uh you know

00:36:06,320 --> 00:36:09,680
can't believe i uh forgot to include the

00:36:08,400 --> 00:36:14,400
picture here but

00:36:09,680 --> 00:36:17,680
uh brandon uh also published a book

00:36:14,400 --> 00:36:20,000
about evf which you you know can

00:36:17,680 --> 00:36:21,599
easily find in a place you find your

00:36:20,000 --> 00:36:25,680
books for

00:36:21,599 --> 00:36:29,280
and that is also fantastic tool to

00:36:25,680 --> 00:36:32,480
learn about that uh well

00:36:29,280 --> 00:36:35,599
with that that is pretty much

00:36:32,480 --> 00:36:37,920
all i have and i would be

00:36:35,599 --> 00:36:41,839
now happy to answer your questions if

00:36:37,920 --> 00:36:41,839
you have any

00:36:46,880 --> 00:36:55,520
okay let's see if i have

00:36:51,359 --> 00:36:58,880
somebody on chat

00:36:55,520 --> 00:36:58,880
okay q a

00:36:59,359 --> 00:37:04,880
okay how do we get your uh the question

00:37:02,720 --> 00:37:08,560
is how do you get your presentation my

00:37:04,880 --> 00:37:12,320
uh material well i will uh share

00:37:08,560 --> 00:37:14,160
their material with the conference

00:37:12,320 --> 00:37:16,480
organizers right and i would

00:37:14,160 --> 00:37:23,839
assume it will be shared to give all the

00:37:16,480 --> 00:37:23,839
other slides

00:37:26,400 --> 00:37:37,839
okay let's see anybody else

00:37:29,920 --> 00:37:37,839
any questions

00:37:38,160 --> 00:37:41,280
now have anybody been quiet have you

00:37:40,880 --> 00:37:45,359
guys

00:37:41,280 --> 00:37:49,119
used ebpf anybody use eppf

00:37:45,359 --> 00:37:52,480
you can maybe just type your answer yes

00:37:49,119 --> 00:37:52,480
no we're ever in a chat

00:37:55,119 --> 00:38:05,839
now nobody nobody home

00:38:16,839 --> 00:38:19,839
okay

00:38:22,240 --> 00:38:30,800
well uh let's see i

00:38:25,920 --> 00:38:30,800
have a little bit more time still okay

00:38:30,839 --> 00:38:35,520
yes thank you

00:38:38,720 --> 00:38:42,240
i hope i pronounce your name correctly

00:38:41,040 --> 00:38:44,720
uh

00:38:42,240 --> 00:38:47,119
well well i probably shouldn't even hope

00:38:44,720 --> 00:38:51,280
i am quite sure i uh

00:38:47,119 --> 00:38:51,280
butchered your name so the question

00:38:51,839 --> 00:38:55,920
has is uh do you go with vpf tray

00:38:54,960 --> 00:38:59,359
straight or use

00:38:55,920 --> 00:39:02,720
other tools first and end up using

00:38:59,359 --> 00:39:06,160
vpf trace well uh in

00:39:02,720 --> 00:39:09,280
in my opinion uh

00:39:06,160 --> 00:39:13,040
in many cases when you want to get some

00:39:09,280 --> 00:39:14,079
good insights you can use the tools with

00:39:13,040 --> 00:39:17,200
bpf trace

00:39:14,079 --> 00:39:21,200
already has provided

00:39:17,200 --> 00:39:24,079
right like for example uh there is a

00:39:21,200 --> 00:39:26,000
other tools to look at the i o latency

00:39:24,079 --> 00:39:28,320
distribution right which is

00:39:26,000 --> 00:39:31,040
fantastic way to troubleshoot

00:39:28,320 --> 00:39:31,040
performance

00:39:35,440 --> 00:39:40,960
uh performance problems right

00:39:38,640 --> 00:39:42,880
and that is where i would start but then

00:39:40,960 --> 00:39:46,160
you may say well you know what i am not

00:39:42,880 --> 00:39:48,320
only interested at the performance of

00:39:46,160 --> 00:39:50,800
all requests in general right i am

00:39:48,320 --> 00:39:52,320
interested in performance of requests

00:39:50,800 --> 00:39:54,960
which are more than

00:39:52,320 --> 00:39:56,079
you know 20 kilobytes in size right or

00:39:54,960 --> 00:39:59,359
something like that

00:39:56,079 --> 00:40:03,520
then you can go ahead and modify

00:39:59,359 --> 00:40:07,040
uh the the script

00:40:03,520 --> 00:40:09,119
uh right to defeat you to fit your units

00:40:07,040 --> 00:40:12,240
that is how i would approach right

00:40:09,119 --> 00:40:15,920
and again i mean uh i would say uh

00:40:12,240 --> 00:40:16,640
this in any case that is typically often

00:40:15,920 --> 00:40:20,319
a second

00:40:16,640 --> 00:40:23,599
step after you started

00:40:20,319 --> 00:40:26,319
uh looking at some built-in standard

00:40:23,599 --> 00:40:28,480
linux tools which we may be very well

00:40:26,319 --> 00:40:31,599
familiar with already

00:40:28,480 --> 00:40:39,839
right again top vm stats

00:40:31,599 --> 00:40:39,839
net start right and so on and so

00:40:42,640 --> 00:40:45,839
yes well that's cool i hope if you use

00:40:45,280 --> 00:40:50,079
uh

00:40:45,839 --> 00:40:53,760
g trace uh before that was

00:40:50,079 --> 00:40:56,319
helpful for you aj was asking

00:40:53,760 --> 00:41:01,119
or saying sharing of us what he had

00:40:56,319 --> 00:41:01,119
experienced using d3s but not upf

00:41:02,079 --> 00:41:07,680
yeah and uh shin zuki

00:41:05,280 --> 00:41:08,640
uh is saying what it's uh very

00:41:07,680 --> 00:41:11,520
interesting

00:41:08,640 --> 00:41:13,680
but seems uh what you need to read the

00:41:11,520 --> 00:41:17,119
material to understand it

00:41:13,680 --> 00:41:20,240
yes that is uh surely the case

00:41:17,119 --> 00:41:22,880
uh and uh uh

00:41:20,240 --> 00:41:24,560
i would definitely recommend you to to

00:41:22,880 --> 00:41:26,720
download and check out the slides when

00:41:24,560 --> 00:41:30,240
they would be

00:41:26,720 --> 00:41:32,240
uh available uh and also

00:41:30,240 --> 00:41:35,040
i kind of skip that slide but i also

00:41:32,240 --> 00:41:37,599
have a section of a further region

00:41:35,040 --> 00:41:38,560
in the in the slide deck if you want to

00:41:37,599 --> 00:41:43,119
read more about

00:41:38,560 --> 00:41:43,119
epf there is some additional information

00:41:46,839 --> 00:41:49,839
available

00:41:50,319 --> 00:41:52,960
yeah so

00:41:54,560 --> 00:42:00,160
yes it's a very easy question

00:42:00,839 --> 00:42:07,599
uh uh

00:42:03,119 --> 00:42:10,079
in this case i won't even try to

00:42:07,599 --> 00:42:10,079
read that

00:42:10,960 --> 00:42:16,000
rather than name uh does vpf trace has

00:42:14,880 --> 00:42:19,359
significant impact

00:42:16,000 --> 00:42:21,920
of performance of a system so

00:42:19,359 --> 00:42:25,440
as i uh mentioned in the presentation

00:42:21,920 --> 00:42:30,319
the cool things about bpf trace

00:42:25,440 --> 00:42:33,920
and over all the tools right what they

00:42:30,319 --> 00:42:36,480
only add their instrumentation

00:42:33,920 --> 00:42:37,200
overhead when you instrument something

00:42:36,480 --> 00:42:40,640
right

00:42:37,200 --> 00:42:43,760
so their instrumentation overhead

00:42:40,640 --> 00:42:46,960
in most cases is a or

00:42:43,760 --> 00:42:48,960
low like fraction of one percent maybe

00:42:46,960 --> 00:42:50,160
one percent right so it is actually safe

00:42:48,960 --> 00:42:53,359
to use

00:42:50,160 --> 00:42:56,480
uh in uh in production

00:42:53,359 --> 00:42:57,520
in some cases if you have uh a trace and

00:42:56,480 --> 00:42:59,920
something like hey

00:42:57,520 --> 00:43:00,720
i want to trace all the system calls in

00:42:59,920 --> 00:43:03,680
the system

00:43:00,720 --> 00:43:04,960
right and put some very complicated

00:43:03,680 --> 00:43:08,000
programs on them

00:43:04,960 --> 00:43:11,280
then in this case overhead will be high

00:43:08,000 --> 00:43:13,359
right but it's uh on right so

00:43:11,280 --> 00:43:15,440
it is typically a good idea as you're

00:43:13,359 --> 00:43:16,319
trying to to instrument and trace

00:43:15,440 --> 00:43:19,119
something

00:43:16,319 --> 00:43:20,880
is to think about how frequent event are

00:43:19,119 --> 00:43:27,440
you trying to

00:43:20,880 --> 00:43:30,960
uh instrument

00:43:27,440 --> 00:43:32,880
so takanori is asking

00:43:30,960 --> 00:43:34,720
how much is it difficult to write user

00:43:32,880 --> 00:43:38,480
aligned applications with

00:43:34,720 --> 00:43:38,480
eu probes supporting both

00:43:38,720 --> 00:43:46,000
both etf and uh

00:43:42,640 --> 00:43:49,200
and d trace uh so

00:43:46,000 --> 00:43:53,040
uh in this case it is uh

00:43:49,200 --> 00:43:57,760
you know hard for me to uh to answer

00:43:53,040 --> 00:43:57,760
uh this question right i am not uh

00:43:58,560 --> 00:44:04,960
frankly like quite sure what is uh

00:44:01,599 --> 00:44:08,000
uh what is the point uh

00:44:04,960 --> 00:44:10,800
in uh the in this case right like

00:44:08,000 --> 00:44:11,760
if you would say hey i want to uh get

00:44:10,800 --> 00:44:13,920
let's say some

00:44:11,760 --> 00:44:14,800
custom pro when i want to support the

00:44:13,920 --> 00:44:17,839
users

00:44:14,800 --> 00:44:21,040
which use both epf and dtrace uh

00:44:17,839 --> 00:44:23,440
you you can probably do that

00:44:21,040 --> 00:44:24,480
i were to too much of effort because the

00:44:23,440 --> 00:44:27,599
syntax is

00:44:24,480 --> 00:44:28,319
quite similar but uh what we see

00:44:27,599 --> 00:44:32,079
typically

00:44:28,319 --> 00:44:35,200
is uh users they would if we use

00:44:32,079 --> 00:44:36,640
one tool or another right or in many

00:44:35,200 --> 00:44:39,359
cases maybe even

00:44:36,640 --> 00:44:43,040
using kind of some high level tools some

00:44:39,359 --> 00:44:43,040
graphical user interface right or

00:44:48,839 --> 00:44:51,839
something

00:44:54,000 --> 00:45:01,440
okay let's see

00:44:57,680 --> 00:45:05,839
any other questions firsts maybe

00:45:01,440 --> 00:45:05,839
observations to share

00:45:26,640 --> 00:45:33,200
oh okay so

00:45:30,000 --> 00:45:35,839
uh so takanori is uh

00:45:33,200 --> 00:45:36,480
asking what if mysql supports solaris

00:45:35,839 --> 00:45:40,160
and

00:45:36,480 --> 00:45:43,440
linux uh so mysql needs to support

00:45:40,160 --> 00:45:46,480
both evf uh and uh uh

00:45:43,440 --> 00:45:50,400
gtrace uh

00:45:46,480 --> 00:45:55,520
yes uh i'm sorry i misunderstood

00:45:50,400 --> 00:45:55,520
the question so uh if you

00:45:55,680 --> 00:46:03,040
uh if you uh look at uh

00:46:00,480 --> 00:46:03,920
this is not quite how it works right the

00:46:03,040 --> 00:46:08,480
mysql

00:46:03,920 --> 00:46:12,000
itself it does not need to support

00:46:08,480 --> 00:46:15,200
either evf or or d trace

00:46:12,000 --> 00:46:15,760
right both those tools are designed so

00:46:15,200 --> 00:46:19,280
they can

00:46:15,760 --> 00:46:21,760
instrument any program without

00:46:19,280 --> 00:46:24,319
that program having any support for that

00:46:21,760 --> 00:46:26,880
as i showed in my example i pretty much

00:46:24,319 --> 00:46:28,720
pick the function i'm interested to

00:46:26,880 --> 00:46:32,160
trace in mysql

00:46:28,720 --> 00:46:34,800
right and then i did that with

00:46:32,160 --> 00:46:35,839
evf and again i could do the same in d

00:46:34,800 --> 00:46:39,200
trace

00:46:35,839 --> 00:46:42,560
now at some point in past

00:46:39,200 --> 00:46:45,760
mysql used to have like a specific uh

00:46:42,560 --> 00:46:50,079
sort of trace points like some better

00:46:45,760 --> 00:46:53,200
human names uh for uh d trace events

00:46:50,079 --> 00:46:56,720
uh but i think that since has been uh

00:46:53,200 --> 00:46:58,560
has been removed because a vast majority

00:46:56,720 --> 00:47:02,000
of my school deployment is on linux

00:46:58,560 --> 00:47:02,000
thursdays right not on solaris

00:47:04,240 --> 00:47:11,280
so for sunsuke

00:47:08,560 --> 00:47:14,160
if there is uh is asking if there is a

00:47:11,280 --> 00:47:17,200
slide deck url of those presentations

00:47:14,160 --> 00:47:21,040
uh uh now there is uh

00:47:17,200 --> 00:47:24,240
no uh slider url for this specific uh

00:47:21,040 --> 00:47:28,240
presentation where maybe the uh

00:47:24,240 --> 00:47:30,480
one similar to what i have uh

00:47:28,240 --> 00:47:31,839
presented before i typically like to

00:47:30,480 --> 00:47:35,040
give a slides

00:47:31,839 --> 00:47:36,480
to uh organizers right so they can

00:47:35,040 --> 00:47:38,319
distribute them

00:47:36,480 --> 00:47:39,599
uh according to their distribution

00:47:38,319 --> 00:47:42,720
policies as a

00:47:39,599 --> 00:47:45,280
as a courtesy right and instead of just

00:47:42,720 --> 00:47:45,280
having that

00:47:45,920 --> 00:47:53,839
accessible on the side

00:48:10,800 --> 00:48:15,760
okay well

00:48:16,800 --> 00:48:21,440
the suke is asking about explicit trace

00:48:19,599 --> 00:48:25,680
point in the middle of the function

00:48:21,440 --> 00:48:29,280
is deprecated or cannot be used

00:48:25,680 --> 00:48:31,040
as a complementary one well um

00:48:29,280 --> 00:48:32,960
i think the point is if you have an

00:48:31,040 --> 00:48:38,000
explicit trades point which is

00:48:32,960 --> 00:48:41,280
uh defined in many cases is it quite uh

00:48:38,000 --> 00:48:43,839
quite convenient to use

00:48:41,280 --> 00:48:45,760
right more convenient than a function

00:48:43,839 --> 00:48:47,119
and another value of a specifically

00:48:45,760 --> 00:48:50,559
named transport

00:48:47,119 --> 00:48:53,920
is what they can be stable

00:48:50,559 --> 00:48:55,680
uh where source code may be changing

00:48:53,920 --> 00:48:58,160
between major versions

00:48:55,680 --> 00:49:01,359
the functions may be removed renamed and

00:48:58,160 --> 00:49:04,720
so on and so forth right

00:49:01,359 --> 00:49:05,599
and then their instrumentations programs

00:49:04,720 --> 00:49:07,760
break

00:49:05,599 --> 00:49:09,760
while uh the trace points where

00:49:07,760 --> 00:49:11,839
typically developers take them on

00:49:09,760 --> 00:49:14,960
themselves to maintain

00:49:11,839 --> 00:49:16,400
uh they're much better right than

00:49:14,960 --> 00:49:31,839
different function names which they

00:49:16,400 --> 00:49:31,839
consider their own business

00:49:32,160 --> 00:49:35,760
okay well uh any more thoughts questions

00:49:35,520 --> 00:49:38,880
i

00:49:35,760 --> 00:49:42,839
i think we have just about

00:49:38,880 --> 00:49:45,839
a minute left of our generously allotted

00:49:42,839 --> 00:49:45,839
time

00:49:57,520 --> 00:50:02,240
okay well thank you for uh

00:50:00,720 --> 00:50:04,319
all your questions and for your

00:50:02,240 --> 00:50:04,720
wonderful participations i know it's not

00:50:04,319 --> 00:50:08,640
as

00:50:04,720 --> 00:50:11,200
easy to participate in a a virtual event

00:50:08,640 --> 00:50:20,160
as in a face-to-face fan so

00:50:11,200 --> 00:50:20,160

YouTube URL: https://www.youtube.com/watch?v=TZcNEYAbgmE


